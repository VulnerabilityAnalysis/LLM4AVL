{"tokens": [" static void rpza_decode_stream(RpzaContext *s)", " {", "     int width = s->avctx->width;", "     int stride = s->frame.linesize[0] / 2;", "     int row_inc = stride - 4;", "     int stream_ptr = 0;", "     int chunk_size;", "     unsigned char opcode;", "     int n_blocks;", "     unsigned short colorA = 0, colorB;", "     unsigned short color4[4];", "     unsigned char index, idx;", "     unsigned short ta, tb;", "      unsigned short *pixels = (unsigned short *)s->frame.data[0];", "      int row_ptr = 0;", "    int pixel_ptr = 0;", "     int pixel_ptr = -4;", "      int block_ptr;", "      int pixel_x, pixel_y;", "      int total_blocks;", "     if (s->buf[stream_ptr] != 0xe1)", "         av_log(s->avctx, AV_LOG_ERROR, \"First chunk byte is 0x%02x instead of 0xe1\\n\",", "             s->buf[stream_ptr]);", "     chunk_size = AV_RB32(&s->buf[stream_ptr]) & 0x00FFFFFF;", "     stream_ptr += 4;", "     if (chunk_size != s->size)", "         av_log(s->avctx, AV_LOG_ERROR, \"MOV chunk size != encoded chunk size; using MOV chunk size\\n\");", "     chunk_size = s->size;", "     total_blocks = ((s->avctx->width + 3) / 4) * ((s->avctx->height + 3) / 4);", "     while (stream_ptr < chunk_size) {", "         opcode = s->buf[stream_ptr++];  ", "         n_blocks = (opcode & 0x1f) + 1;  ", "         if ((opcode & 0x80) == 0) {", "             colorA = (opcode << 8) | (s->buf[stream_ptr++]);", "             opcode = 0;", "             if ((s->buf[stream_ptr] & 0x80) != 0) {", "                 opcode = 0x20;", "                 n_blocks = 1;", "             }", "         }", "         switch (opcode & 0xe0) {", "         case 0x80:", "             while (n_blocks--) {", "               ADVANCE_BLOCK();", "             }", "             break;", "         case 0xa0:", "              colorA = AV_RB16 (&s->buf[stream_ptr]);", "              stream_ptr += 2;", "              while (n_blocks--) {", "                 ADVANCE_BLOCK()", "                  block_ptr = row_ptr + pixel_ptr;", "                  for (pixel_y = 0; pixel_y < 4; pixel_y++) {", "                      for (pixel_x = 0; pixel_x < 4; pixel_x++){", "                         pixels[block_ptr] = colorA;", "                         block_ptr++;", "                      }", "                      block_ptr += row_inc;", "                  }", "                ADVANCE_BLOCK();", "              }", "              break;", "         case 0xc0:", "             colorA = AV_RB16 (&s->buf[stream_ptr]);", "             stream_ptr += 2;", "         case 0x20:", "             colorB = AV_RB16 (&s->buf[stream_ptr]);", "             stream_ptr += 2;", "             color4[0] = colorB;", "             color4[1] = 0;", "             color4[2] = 0;", "             color4[3] = colorA;", "             ta = (colorA >> 10) & 0x1F;", "             tb = (colorB >> 10) & 0x1F;", "             color4[1] |= ((11 * ta + 21 * tb) >> 5) << 10;", "             color4[2] |= ((21 * ta + 11 * tb) >> 5) << 10;", "             ta = (colorA >> 5) & 0x1F;", "             tb = (colorB >> 5) & 0x1F;", "             color4[1] |= ((11 * ta + 21 * tb) >> 5) << 5;", "             color4[2] |= ((21 * ta + 11 * tb) >> 5) << 5;", "             ta = colorA & 0x1F;", "             tb = colorB & 0x1F;", "             color4[1] |= ((11 * ta + 21 * tb) >> 5);", "             color4[2] |= ((21 * ta + 11 * tb) >> 5);", "              if (s->size - stream_ptr < n_blocks * 4)", "                  return;", "              while (n_blocks--) {", "                 ADVANCE_BLOCK();", "                  block_ptr = row_ptr + pixel_ptr;", "                  for (pixel_y = 0; pixel_y < 4; pixel_y++) {", "                      index = s->buf[stream_ptr++];", "                     for (pixel_x = 0; pixel_x < 4; pixel_x++){", "                         idx = (index >> (2 * (3 - pixel_x))) & 0x03;", "                         pixels[block_ptr] = color4[idx];", "                         block_ptr++;", "                      }", "                      block_ptr += row_inc;", "                  }", "                ADVANCE_BLOCK();", "              }", "              break;", "          case 0x00:", "              if (s->size - stream_ptr < 16)", "                  return;", "             ADVANCE_BLOCK();", "              block_ptr = row_ptr + pixel_ptr;", "              for (pixel_y = 0; pixel_y < 4; pixel_y++) {", "                  for (pixel_x = 0; pixel_x < 4; pixel_x++){", "                     if ((pixel_y != 0) || (pixel_x !=0)) {", "                         colorA = AV_RB16 (&s->buf[stream_ptr]);", "                         stream_ptr += 2;", "                     }", "                     pixels[block_ptr] = colorA;", "                     block_ptr++;", "                  }", "                  block_ptr += row_inc;", "              }", "            ADVANCE_BLOCK();", "              break;", "         default:", "             av_log(s->avctx, AV_LOG_ERROR, \"Unknown opcode %d in rpza chunk.\"", "                  \" Skip remaining %d bytes of chunk data.\\n\", opcode,", "                  chunk_size - stream_ptr);", "             return;", "         }  ", "     }", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void handle_data_packet(struct mt_connection *curconn, struct mt_mactelnet_hdr *pkthdr, int data_len) {", " \tstruct mt_mactelnet_control_hdr cpkt;", " \tstruct mt_packet pdata;", " \tunsigned char *data = pkthdr->data;", " \tunsigned int act_size = 0;", " \tint got_user_packet = 0;", " \tint got_pass_packet = 0;", " \tint got_width_packet = 0;", " \tint got_height_packet = 0;", " \tint success;", " \tsuccess = parse_control_packet(data, data_len - MT_HEADER_LEN, &cpkt);", " \twhile (success) {", " \t\tif (cpkt.cptype == MT_CPTYPE_BEGINAUTH) {", " \t\t\tint plen,i;", " \t\t\tif (!curconn->have_pass_salt) {", " \t\t\t\tfor (i = 0; i < 16; ++i) {", " \t\t\t\t\tcurconn->pass_salt[i] = rand() % 256;", " \t\t\t\t}", " \t\t\t\tcurconn->have_pass_salt = 1;", " \t\t\t\tmemset(curconn->trypassword, 0, sizeof(curconn->trypassword));", " \t\t\t}", " \t\t\tinit_packet(&pdata, MT_PTYPE_DATA, pkthdr->dstaddr, pkthdr->srcaddr, pkthdr->seskey, curconn->outcounter);", " \t\t\tplen = add_control_packet(&pdata, MT_CPTYPE_PASSSALT, (curconn->pass_salt), 16);", " \t\t\tcurconn->outcounter += plen;", " \t\t\tsend_udp(curconn, &pdata);", " \t\t} else if (cpkt.cptype == MT_CPTYPE_USERNAME && curconn->state != STATE_ACTIVE) {", " \t\t\tmemcpy(curconn->username, cpkt.data, act_size = (cpkt.length > MT_MNDP_MAX_STRING_SIZE - 1 ? MT_MNDP_MAX_STRING_SIZE - 1 : cpkt.length));", " \t\t\tcurconn->username[act_size] = 0;", " \t\t\tgot_user_packet = 1;", " \t\t} else if (cpkt.cptype == MT_CPTYPE_TERM_WIDTH && cpkt.length >= 2) {", " \t\t\tunsigned short width;", " \t\t\tmemcpy(&width, cpkt.data, 2);", " \t\t\tcurconn->terminal_width = le16toh(width);", " \t\t\tgot_width_packet = 1;", " \t\t} else if (cpkt.cptype == MT_CPTYPE_TERM_HEIGHT && cpkt.length >= 2) {", " \t\t\tunsigned short height;", " \t\t\tmemcpy(&height, cpkt.data, 2);", " \t\t\tcurconn->terminal_height = le16toh(height);", " \t\t\tgot_height_packet = 1;", " \t\t} else if (cpkt.cptype == MT_CPTYPE_TERM_TYPE) {", "  \t\t\tmemcpy(curconn->terminal_type, cpkt.data, act_size = (cpkt.length > 30 - 1 ? 30 - 1 : cpkt.length));", "  \t\t\tcurconn->terminal_type[act_size] = 0;", "\t\t} else if (cpkt.cptype == MT_CPTYPE_PASSWORD) {", " \t\t} else if (cpkt.cptype == MT_CPTYPE_PASSWORD && cpkt.length == 17) {", "  #if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)", "  \t\t\tmlock(curconn->trypassword, 17);", " #endif", " \t\t\tmemcpy(curconn->trypassword, cpkt.data, 17);", " \t\t\tgot_pass_packet = 1;", " \t\t} else if (cpkt.cptype == MT_CPTYPE_PLAINDATA) {", " \t\t\tif (curconn->state == STATE_ACTIVE && curconn->ptsfd != -1) {", " \t\t\t\twrite(curconn->ptsfd, cpkt.data, cpkt.length);", "  \t\t\t}", "  \t\t} else {", "\t\t\tsyslog(LOG_WARNING, _(\"(%d) Unhandeled control packet type: %d\"), curconn->seskey, cpkt.cptype);", " \t\t\tsyslog(LOG_WARNING, _(\"(%d) Unhandeled control packet type: %d, length: %d\"), curconn->seskey, cpkt.cptype, cpkt.length);", "  \t\t}", " \t\tsuccess = parse_control_packet(NULL, 0, &cpkt);", " \t}", " \tif (got_user_packet && got_pass_packet) {", " \t\tuser_login(curconn, pkthdr);", " \t}", " \tif (curconn->state == STATE_ACTIVE && (got_width_packet || got_height_packet)) {", " \t\tset_terminal_size(curconn->ptsfd, curconn->terminal_width, curconn->terminal_height);", " \t}", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" lha_read_file_header_1(struct archive_read *a, struct lha *lha)", " {", " \tconst unsigned char *p;", " \tsize_t extdsize;", " \tint i, err, err2;", " \tint namelen, padding;", " \tunsigned char headersum, sum_calculated;", " \terr = ARCHIVE_OK;", " \tif ((p = __archive_read_ahead(a, H1_FIXED_SIZE, NULL)) == NULL)", " \t\treturn (truncated_error(a));", " \tlha->header_size = p[H1_HEADER_SIZE_OFFSET] + 2;", " \theadersum = p[H1_HEADER_SUM_OFFSET];", " \tlha->compsize = archive_le32dec(p + H1_COMP_SIZE_OFFSET);", " \tlha->origsize = archive_le32dec(p + H1_ORIG_SIZE_OFFSET);", " \tlha->mtime = lha_dos_time(p + H1_DOS_TIME_OFFSET);", " \tnamelen = p[H1_NAME_LEN_OFFSET];", " \tpadding = ((int)lha->header_size) - H1_FIXED_SIZE - namelen;", " \tif (namelen > 230 || padding < 0)", " \t\tgoto invalid;", " \tif ((p = __archive_read_ahead(a, lha->header_size, NULL)) == NULL)", " \t\treturn (truncated_error(a));", " \tfor (i = 0; i < namelen; i++) {", " \t\tif (p[i + H1_FILE_NAME_OFFSET] == 0xff)", " \t\t\tgoto invalid; ", " \t}", " \tarchive_strncpy(&lha->filename, p + H1_FILE_NAME_OFFSET, namelen);", " \tlha->crc = archive_le16dec(p + H1_FILE_NAME_OFFSET + namelen);", " \tlha->setflag |= CRC_IS_SET;", " \tsum_calculated = lha_calcsum(0, p, 2, lha->header_size - 2);", " \t__archive_read_consume(a, lha->header_size - 2);", " \terr2 = lha_read_file_extended_header(a, lha, NULL, 2,", " \t    (size_t)(lha->compsize + 2), &extdsize);", " \tif (err2 < ARCHIVE_WARN)", " \t\treturn (err2);", " \tif (err2 < err)", " \t\terr = err2;", "  \tlha->compsize -= extdsize - 2;", " \tif (lha->compsize < 0)", " \t\tgoto invalid;\t ", "  \tif (sum_calculated != headersum) {", "  \t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,", "  \t\t    \"LHa header sum error\");", " \t\treturn (ARCHIVE_FATAL);", " \t}", " \treturn (err);", " invalid:", " \tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", " \t    \"Invalid LHa header\");", " \treturn (ARCHIVE_FATAL);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)   ", " {", " \tmp4object *mp4 = (mp4object *)malloc(sizeof(mp4object));", " \tif (mp4 == NULL) return 0;", "  \tmemset(mp4, 0, sizeof(mp4object));", " \tstruct stat64 mp4stat;", " \tstat64(filename, &mp4stat);", " \tmp4->filesize = mp4stat.st_size;", " \tif (mp4->filesize < 64) return 0;", "  #ifdef _WINDOWS", "  \tfopen_s(&mp4->mediafp, filename, \"rb\");", "  #else", " \tmp4->mediafp = fopen(filename, \"rb\");", " #endif", " \tif (mp4->mediafp)", " \t{", " \t\tuint32_t qttag, qtsize32, skip, type = 0, subtype = 0, num;", " \t\tsize_t len;", " \t\tint32_t nest = 0;", "  \t\tuint64_t nestsize[MAX_NEST_LEVEL] = { 0 };", "  \t\tuint64_t lastsize = 0, qtsize;", "  \t\tdo", "  \t\t{", "  \t\t\tlen = fread(&qtsize32, 1, 4, mp4->mediafp);", "  \t\t\tlen += fread(&qttag, 1, 4, mp4->mediafp);", "\t\t\tif (len == 8)", " \t\t\tmp4->filepos += len;", " \t\t\tif (len == 8 && mp4->filepos < mp4->filesize)", "  \t\t\t{", "  \t\t\t\tif (!VALID_FOURCC(qttag))", "  \t\t\t\t{", "\t\t\t\t\tLONGSEEK(mp4->mediafp, lastsize - 8 - 8, SEEK_CUR);", "\t\t\t\t\tNESTSIZE(lastsize - 8);", "\t\t\t\t\tcontinue;", " \t\t\t\t\tCloseSource((size_t)mp4);", " \t\t\t\t\tmp4 = NULL;", " \t\t\t\t\tbreak;", "  \t\t\t\t}", "  \t\t\t\tqtsize32 = BYTESWAP32(qtsize32);", "  \t\t\t\tif (qtsize32 == 1)  ", "  \t\t\t\t{", "\t\t\t\t\tfread(&qtsize, 1, 8, mp4->mediafp);", " \t\t\t\t\tlen = fread(&qtsize, 1, 8, mp4->mediafp);", " \t\t\t\t\tmp4->filepos += len;", "  \t\t\t\t\tqtsize = BYTESWAP64(qtsize) - 8;", "  \t\t\t\t}", "  \t\t\t\telse", " \t\t\t\t\tqtsize = qtsize32;", " \t\t\t\tnest++;", " \t\t\t\tif (qtsize < 8) break;", " \t\t\t\tif (nest >= MAX_NEST_LEVEL) break;", " \t\t\t\tnestsize[nest] = qtsize;", " \t\t\t\tlastsize = qtsize;", " #if PRINT_MP4_STRUCTURE\t", " \t\t\t\tfor (int i = 1; i < nest; i++) printf(\"    \");", " \t\t\t\tprintf(\"%c%c%c%c (%lld)\\n\", (qttag & 0xff), ((qttag >> 8) & 0xff), ((qttag >> 16) & 0xff), ((qttag >> 24) & 0xff), qtsize);", "  \t\t\t\tif (qttag == MAKEID('m', 'd', 'a', 't') ||", "  \t\t\t\t\tqttag == MAKEID('f', 't', 'y', 'p') ||", "\t\t\t\t\tqttag == MAKEID('u', 'd', 't', 'a'))", " \t\t\t\t\tqttag == MAKEID('u', 'd', 't', 'a') ||", " \t\t\t\t\tqttag == MAKEID('f', 'r', 'e', 'e'))", "  \t\t\t\t{", "\t\t\t\t\tLONGSEEK(mediafp, qtsize - 8, SEEK_CUR);", " \t\t\t\t\tLongSeek(mp4, qtsize - 8);", "  \t\t\t\t\tNESTSIZE(qtsize);", " \t\t\t\t\tcontinue;", " \t\t\t\t}", " #else", " \t\t\t\tif (qttag != MAKEID('m', 'o', 'o', 'v') &&  ", " \t\t\t\t\tqttag != MAKEID('m', 'v', 'h', 'd') &&", " \t\t\t\t\tqttag != MAKEID('t', 'r', 'a', 'k') &&", " \t\t\t\t\tqttag != MAKEID('m', 'd', 'i', 'a') &&", " \t\t\t\t\tqttag != MAKEID('m', 'd', 'h', 'd') &&", " \t\t\t\t\tqttag != MAKEID('m', 'i', 'n', 'f') &&", " \t\t\t\t\tqttag != MAKEID('g', 'm', 'i', 'n') &&", "  \t\t\t\t\tqttag != MAKEID('d', 'i', 'n', 'f') &&", "  \t\t\t\t\tqttag != MAKEID('a', 'l', 'i', 's') &&", "  \t\t\t\t\tqttag != MAKEID('s', 't', 's', 'd') &&", "\t\t\t\t\tqttag != MAKEID('a', 'l', 'i', 's') &&", "\t\t\t\t\tqttag != MAKEID('a', 'l', 'i', 's') &&", "  \t\t\t\t\tqttag != MAKEID('s', 't', 'b', 'l') &&", "  \t\t\t\t\tqttag != MAKEID('s', 't', 't', 's') &&", "  \t\t\t\t\tqttag != MAKEID('s', 't', 's', 'c') &&", " \t\t\t\t\tqttag != MAKEID('s', 't', 's', 'z') &&", " \t\t\t\t\tqttag != MAKEID('s', 't', 'c', 'o') &&", "  \t\t\t\t\tqttag != MAKEID('c', 'o', '6', '4') &&", "  \t\t\t\t\tqttag != MAKEID('h', 'd', 'l', 'r'))", "  \t\t\t\t{", "\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);", " \t\t\t\t\tLongSeek(mp4, qtsize - 8);", "  \t\t\t\t\tNESTSIZE(qtsize);", "  \t\t\t\t}", " \t\t\t\telse", " #endif", " \t\t\t\t\tif (qttag == MAKEID('m', 'v', 'h', 'd'))  ", " \t\t\t\t\t{", " \t\t\t\t\t\tlen = fread(&skip, 1, 4, mp4->mediafp);", " \t\t\t\t\t\tlen += fread(&skip, 1, 4, mp4->mediafp);", "  \t\t\t\t\t\tlen += fread(&skip, 1, 4, mp4->mediafp);", "  \t\t\t\t\t\tlen += fread(&mp4->clockdemon, 1, 4, mp4->mediafp); mp4->clockdemon = BYTESWAP32(mp4->clockdemon);", "  \t\t\t\t\t\tlen += fread(&mp4->clockcount, 1, 4, mp4->mediafp); mp4->clockcount = BYTESWAP32(mp4->clockcount);", "\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);  ", " \t\t\t\t\t\tmp4->filepos += len;", " \t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len);  ", "  \t\t\t\t\t\tNESTSIZE(qtsize);", "  \t\t\t\t\t}", " \t\t\t\t\telse if (qttag == MAKEID('m', 'd', 'h', 'd'))  ", " \t\t\t\t\t{", " \t\t\t\t\t\tmedia_header md;", " \t\t\t\t\t\tlen = fread(&md, 1, sizeof(md), mp4->mediafp);", " \t\t\t\t\t\tif (len == sizeof(md))", " \t\t\t\t\t\t{", " \t\t\t\t\t\t\tmd.creation_time = BYTESWAP32(md.creation_time);", " \t\t\t\t\t\t\tmd.modification_time = BYTESWAP32(md.modification_time);", " \t\t\t\t\t\t\tmd.time_scale = BYTESWAP32(md.time_scale);", " \t\t\t\t\t\t\tmd.duration = BYTESWAP32(md.duration);", " \t\t\t\t\t\t\tmp4->trak_clockdemon = md.time_scale;", " \t\t\t\t\t\t\tmp4->trak_clockcount = md.duration;", " \t\t\t\t\t\t\tif (mp4->videolength == 0.0)  ", " \t\t\t\t\t\t\t{", "  \t\t\t\t\t\t\t\tmp4->videolength = (float)((double)mp4->trak_clockcount / (double)mp4->trak_clockdemon);", "  \t\t\t\t\t\t\t}", "  \t\t\t\t\t\t}", "\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);  ", " \t\t\t\t\t\tmp4->filepos += len;", " \t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len);  ", "  \t\t\t\t\t\tNESTSIZE(qtsize);", "  \t\t\t\t\t}", " \t\t\t\t\telse if (qttag == MAKEID('h', 'd', 'l', 'r'))  ", " \t\t\t\t\t{", " \t\t\t\t\t\tuint32_t temp;", " \t\t\t\t\t\tlen = fread(&skip, 1, 4, mp4->mediafp);", "  \t\t\t\t\t\tlen += fread(&skip, 1, 4, mp4->mediafp);", "  \t\t\t\t\t\tlen += fread(&temp, 1, 4, mp4->mediafp);   ", "\t\t\t\t\t\tif (temp != MAKEID('a', 'l', 'i', 's'))", " \t\t\t\t\t\tif (temp != MAKEID('a', 'l', 'i', 's') && temp != MAKEID('u', 'r', 'l', ' '))", "  \t\t\t\t\t\t\ttype = temp;", "\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);  ", " \t\t\t\t\t\tmp4->filepos += len;", " \t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len);  ", "  \t\t\t\t\t\tNESTSIZE(qtsize);", " \t\t\t\t\t}", " \t\t\t\t\telse if (qttag == MAKEID('s', 't', 's', 'd'))  ", " \t\t\t\t\t{", " \t\t\t\t\t\tif (type == traktype)  ", " \t\t\t\t\t\t{", " \t\t\t\t\t\t\tlen = fread(&skip, 1, 4, mp4->mediafp);", " \t\t\t\t\t\t\tlen += fread(&skip, 1, 4, mp4->mediafp);", " \t\t\t\t\t\t\tlen += fread(&skip, 1, 4, mp4->mediafp);", " \t\t\t\t\t\t\tlen += fread(&subtype, 1, 4, mp4->mediafp);   ", " \t\t\t\t\t\t\tif (len == 16)", " \t\t\t\t\t\t\t{", " \t\t\t\t\t\t\t\tif (subtype != traksubtype)  ", " \t\t\t\t\t\t\t\t{", "  \t\t\t\t\t\t\t\t\ttype = 0;  ", "  \t\t\t\t\t\t\t\t}", "  \t\t\t\t\t\t\t}", "\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);  ", " \t\t\t\t\t\t\tmp4->filepos += len;", " \t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len);  ", "  \t\t\t\t\t\t}", "  \t\t\t\t\t\telse", "\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);", " \t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8);", "  \t\t\t\t\t\tNESTSIZE(qtsize);", "  \t\t\t\t\t}", " \t\t\t\t\telse if (qttag == MAKEID('s', 't', 's', 'c'))  ", " \t\t\t\t\t{", " \t\t\t\t\t\tif (type == traktype)  ", " \t\t\t\t\t\t{", " \t\t\t\t\t\t\tlen = fread(&skip, 1, 4, mp4->mediafp);", " \t\t\t\t\t\t\tlen += fread(&num, 1, 4, mp4->mediafp);", " \t\t\t\t\t\t\tnum = BYTESWAP32(num);", " \t\t\t\t\t\t\tif (num * 12 <= qtsize - 8 - len)", "  \t\t\t\t\t\t\t{", "  \t\t\t\t\t\t\t\tmp4->metastsc_count = num;", "  \t\t\t\t\t\t\t\tif (mp4->metastsc) free(mp4->metastsc);", "\t\t\t\t\t\t\t\tmp4->metastsc = (SampleToChunk *)malloc(num * 12);", "\t\t\t\t\t\t\t\tif (mp4->metastsc)", " \t\t\t\t\t\t\t\tif (num > 0)", "  \t\t\t\t\t\t\t\t{", "\t\t\t\t\t\t\t\t\tuint32_t total_stsc = num;", "\t\t\t\t\t\t\t\t\tlen += fread(mp4->metastsc, 1, num * sizeof(SampleToChunk), mp4->mediafp);", "\t\t\t\t\t\t\t\t\tdo", " \t\t\t\t\t\t\t\t\tmp4->metastsc = (SampleToChunk *)malloc(num * sizeof(SampleToChunk));", " \t\t\t\t\t\t\t\t\tif (mp4->metastsc)", "  \t\t\t\t\t\t\t\t\t{", "\t\t\t\t\t\t\t\t\t\tnum--;", "\t\t\t\t\t\t\t\t\t\tmp4->metastsc[num].chunk_num = BYTESWAP32(mp4->metastsc[num].chunk_num);", "\t\t\t\t\t\t\t\t\t\tmp4->metastsc[num].samples = BYTESWAP32(mp4->metastsc[num].samples);", "\t\t\t\t\t\t\t\t\t\tmp4->metastsc[num].id = BYTESWAP32(mp4->metastsc[num].id);", "\t\t\t\t\t\t\t\t\t} while (num > 0);", "\t\t\t\t\t\t\t\t}", " \t\t\t\t\t\t\t\t\t\tlen += fread(mp4->metastsc, 1, num * sizeof(SampleToChunk), mp4->mediafp);", "\t\t\t\t\t\t\t\tif (mp4->metastsc_count == 1 && mp4->metastsc[0].samples == 1)  ", " \t\t\t\t\t\t\t\t\t\tdo", " \t\t\t\t\t\t\t\t\t\t{", " \t\t\t\t\t\t\t\t\t\t\tnum--;", " \t\t\t\t\t\t\t\t\t\t\tmp4->metastsc[num].chunk_num = BYTESWAP32(mp4->metastsc[num].chunk_num);", " \t\t\t\t\t\t\t\t\t\t\tmp4->metastsc[num].samples = BYTESWAP32(mp4->metastsc[num].samples);", " \t\t\t\t\t\t\t\t\t\t\tmp4->metastsc[num].id = BYTESWAP32(mp4->metastsc[num].id);", " \t\t\t\t\t\t\t\t\t\t} while (num > 0);", " \t\t\t\t\t\t\t\t\t}", " \t\t\t\t\t\t\t\t}", " \t\t\t\t\t\t\t\telse", "  \t\t\t\t\t\t\t\t{", "\t\t\t\t\t\t\t\t\tif (mp4->metastsc) free(mp4->metastsc);", "\t\t\t\t\t\t\t\t\tmp4->metastsc = NULL;", "\t\t\t\t\t\t\t\t\tmp4->metastsc_count = 0;", " \t\t\t\t\t\t\t\t\tCloseSource((size_t)mp4);", " \t\t\t\t\t\t\t\t\tmp4 = NULL;", " \t\t\t\t\t\t\t\t\tbreak;", "  \t\t\t\t\t\t\t\t}", "  \t\t\t\t\t\t\t}", "\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);  ", " \t\t\t\t\t\t\tmp4->filepos += len;", " \t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len);  ", "  \t\t\t\t\t\t}", "  \t\t\t\t\t\telse", "\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);", " \t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8);", "  \t\t\t\t\t\tNESTSIZE(qtsize);", "  \t\t\t\t\t}", " \t\t\t\t\telse if (qttag == MAKEID('s', 't', 's', 'z'))  ", " \t\t\t\t\t{", " \t\t\t\t\t\tif (type == traktype)  ", " \t\t\t\t\t\t{", " \t\t\t\t\t\t\tuint32_t equalsamplesize;", " \t\t\t\t\t\t\tlen = fread(&skip, 1, 4, mp4->mediafp);", " \t\t\t\t\t\t\tlen += fread(&equalsamplesize, 1, 4, mp4->mediafp);", " \t\t\t\t\t\t\tlen += fread(&num, 1, 4, mp4->mediafp);", " \t\t\t\t\t\t\tnum = BYTESWAP32(num);", " \t\t\t\t\t\t\tif (num * 4 <= qtsize - 8 - len)", "  \t\t\t\t\t\t\t{", "  \t\t\t\t\t\t\t\tmp4->metasize_count = num;", "  \t\t\t\t\t\t\t\tif (mp4->metasizes) free(mp4->metasizes);", "\t\t\t\t\t\t\t\tmp4->metasizes = (uint32_t *)malloc(num * 4);", "\t\t\t\t\t\t\t\tif (mp4->metasizes)", " \t\t\t\t\t\t\t\tif(num > 0)", "  \t\t\t\t\t\t\t\t{", "\t\t\t\t\t\t\t\t\tif (equalsamplesize == 0)", " \t\t\t\t\t\t\t\t\tmp4->metasizes = (uint32_t *)malloc(num * 4);", " \t\t\t\t\t\t\t\t\tif (mp4->metasizes)", "  \t\t\t\t\t\t\t\t\t{", "\t\t\t\t\t\t\t\t\t\tlen += fread(mp4->metasizes, 1, num * 4, mp4->mediafp);", "\t\t\t\t\t\t\t\t\t\tdo", " \t\t\t\t\t\t\t\t\t\tif (equalsamplesize == 0)", "  \t\t\t\t\t\t\t\t\t\t{", "\t\t\t\t\t\t\t\t\t\t\tnum--;", "\t\t\t\t\t\t\t\t\t\t\tmp4->metasizes[num] = BYTESWAP32(mp4->metasizes[num]);", "\t\t\t\t\t\t\t\t\t\t} while (num > 0);", "\t\t\t\t\t\t\t\t\t}", "\t\t\t\t\t\t\t\t\telse", "\t\t\t\t\t\t\t\t\t{", "\t\t\t\t\t\t\t\t\t\tequalsamplesize = BYTESWAP32(equalsamplesize);", "\t\t\t\t\t\t\t\t\t\tdo", " \t\t\t\t\t\t\t\t\t\t\tlen += fread(mp4->metasizes, 1, num * 4, mp4->mediafp);", " \t\t\t\t\t\t\t\t\t\t\tdo", " \t\t\t\t\t\t\t\t\t\t\t{", " \t\t\t\t\t\t\t\t\t\t\t\tnum--;", " \t\t\t\t\t\t\t\t\t\t\t\tmp4->metasizes[num] = BYTESWAP32(mp4->metasizes[num]);", " \t\t\t\t\t\t\t\t\t\t\t} while (num > 0);", " \t\t\t\t\t\t\t\t\t\t}", " \t\t\t\t\t\t\t\t\t\telse", "  \t\t\t\t\t\t\t\t\t\t{", "\t\t\t\t\t\t\t\t\t\t\tnum--;", "\t\t\t\t\t\t\t\t\t\t\tmp4->metasizes[num] = equalsamplesize;", "\t\t\t\t\t\t\t\t\t\t} while (num > 0);", " \t\t\t\t\t\t\t\t\t\t\tequalsamplesize = BYTESWAP32(equalsamplesize);", " \t\t\t\t\t\t\t\t\t\t\tdo", " \t\t\t\t\t\t\t\t\t\t\t{", " \t\t\t\t\t\t\t\t\t\t\t\tnum--;", " \t\t\t\t\t\t\t\t\t\t\t\tmp4->metasizes[num] = equalsamplesize;", " \t\t\t\t\t\t\t\t\t\t\t} while (num > 0);", " \t\t\t\t\t\t\t\t\t\t}", "  \t\t\t\t\t\t\t\t\t}", "  \t\t\t\t\t\t\t\t}", " \t\t\t\t\t\t\t\telse", " \t\t\t\t\t\t\t\t{", " \t\t\t\t\t\t\t\t\tCloseSource((size_t)mp4);", " \t\t\t\t\t\t\t\t\tmp4 = NULL;", " \t\t\t\t\t\t\t\t\tbreak;", " \t\t\t\t\t\t\t\t}", "  \t\t\t\t\t\t\t}", "\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);  ", " \t\t\t\t\t\t\tmp4->filepos += len;", " \t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len);  ", "  \t\t\t\t\t\t}", "  \t\t\t\t\t\telse", "\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);", " \t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8);", "  \t\t\t\t\t\tNESTSIZE(qtsize);", "  \t\t\t\t\t}", " \t\t\t\t\telse if (qttag == MAKEID('s', 't', 'c', 'o'))  ", " \t\t\t\t\t{", " \t\t\t\t\t\tif (type == traktype)  ", " \t\t\t\t\t\t{", " \t\t\t\t\t\t\tlen = fread(&skip, 1, 4, mp4->mediafp);", " \t\t\t\t\t\t\tlen += fread(&num, 1, 4, mp4->mediafp);", "  \t\t\t\t\t\t\tnum = BYTESWAP32(num);", "  \t\t\t\t\t\t\tif (num * 4 <= qtsize - 8 - len)", "  \t\t\t\t\t\t\t{", " \t\t\t\t\t\t\t\tuint32_t metastco_count = num;", "  \t\t\t\t\t\t\t\tif (mp4->metastsc_count > 0 && num != mp4->metasize_count)", "  \t\t\t\t\t\t\t\t{", "\t\t\t\t\t\t\t\t\tmp4->indexcount = mp4->metasize_count;", " \t\t\t\t\t\t\t\t\tmp4->indexcount = num;", "  \t\t\t\t\t\t\t\t\tif (mp4->metaoffsets) free(mp4->metaoffsets);", "\t\t\t\t\t\t\t\t\tmp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);", "\t\t\t\t\t\t\t\t\tif (mp4->metaoffsets)", " \t\t\t\t\t\t\t\t\tif(num > 0)", "  \t\t\t\t\t\t\t\t\t{", "\t\t\t\t\t\t\t\t\t\tuint32_t *metaoffsets32 = NULL;", "\t\t\t\t\t\t\t\t\t\tmetaoffsets32 = (uint32_t *)malloc(num * 4);", "\t\t\t\t\t\t\t\t\t\tif (metaoffsets32)", " \t\t\t\t\t\t\t\t\t\tmp4->metaoffsets = (uint64_t *)malloc(num * 8);", " \t\t\t\t\t\t\t\t\t\tif (mp4->metaoffsets)", "  \t\t\t\t\t\t\t\t\t\t{", "\t\t\t\t\t\t\t\t\t\t\tuint64_t fileoffset = 0;", "\t\t\t\t\t\t\t\t\t\t\tint stsc_pos = 0;", "\t\t\t\t\t\t\t\t\t\t\tint stco_pos = 0;", "\t\t\t\t\t\t\t\t\t\t\tint repeat = 1;", "\t\t\t\t\t\t\t\t\t\t\tlen += fread(metaoffsets32, 1, num * 4, mp4->mediafp);", "\t\t\t\t\t\t\t\t\t\t\tdo", "\t\t\t\t\t\t\t\t\t\t\t{", "\t\t\t\t\t\t\t\t\t\t\t\tnum--;", "\t\t\t\t\t\t\t\t\t\t\t\tmetaoffsets32[num] = BYTESWAP32(metaoffsets32[num]);", "\t\t\t\t\t\t\t\t\t\t\t} while (num > 0);", "\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[0] = fileoffset = metaoffsets32[stco_pos];", "\t\t\t\t\t\t\t\t\t\t\tnum = 1;", "\t\t\t\t\t\t\t\t\t\t\twhile (num < mp4->metasize_count)", " \t\t\t\t\t\t\t\t\t\t\tuint32_t *metaoffsets32 = NULL;", " \t\t\t\t\t\t\t\t\t\t\tmetaoffsets32 = (uint32_t *)malloc(num * 4);", " \t\t\t\t\t\t\t\t\t\t\tif (metaoffsets32)", "  \t\t\t\t\t\t\t\t\t\t\t{", "\t\t\t\t\t\t\t\t\t\t\t\tif (stsc_pos + 1 < (int)mp4->metastsc_count && num == stsc_pos)", " \t\t\t\t\t\t\t\t\t\t\t\tuint64_t fileoffset = 0;", " \t\t\t\t\t\t\t\t\t\t\t\tint stsc_pos = 0;", " \t\t\t\t\t\t\t\t\t\t\t\tint stco_pos = 0;", " \t\t\t\t\t\t\t\t\t\t\t\tint repeat = 1;", " \t\t\t\t\t\t\t\t\t\t\t\tlen += fread(metaoffsets32, 1, num * 4, mp4->mediafp);", " \t\t\t\t\t\t\t\t\t\t\t\tdo", "  \t\t\t\t\t\t\t\t\t\t\t\t{", "\t\t\t\t\t\t\t\t\t\t\t\t\tstco_pos++; stsc_pos++;", "\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset = (uint64_t)metaoffsets32[stco_pos];", "\t\t\t\t\t\t\t\t\t\t\t\t\trepeat = 1;", "\t\t\t\t\t\t\t\t\t\t\t\t}", "\t\t\t\t\t\t\t\t\t\t\t\telse if (repeat == mp4->metastsc[stsc_pos].samples)", "\t\t\t\t\t\t\t\t\t\t\t\t{", "\t\t\t\t\t\t\t\t\t\t\t\t\tstco_pos++;", "\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset = (uint64_t)metaoffsets32[stco_pos];", "\t\t\t\t\t\t\t\t\t\t\t\t\trepeat = 1;", "\t\t\t\t\t\t\t\t\t\t\t\t}", "\t\t\t\t\t\t\t\t\t\t\t\telse", " \t\t\t\t\t\t\t\t\t\t\t\t\tnum--;", " \t\t\t\t\t\t\t\t\t\t\t\t\tmetaoffsets32[num] = BYTESWAP32(metaoffsets32[num]);", " \t\t\t\t\t\t\t\t\t\t\t\t} while (num > 0);", " \t\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[0] = fileoffset = metaoffsets32[stco_pos];", " \t\t\t\t\t\t\t\t\t\t\t\tnum = 1;", " \t\t\t\t\t\t\t\t\t\t\t\twhile (num < mp4->indexcount)", "  \t\t\t\t\t\t\t\t\t\t\t\t{", "\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset += (uint64_t)mp4->metasizes[num - 1];", "\t\t\t\t\t\t\t\t\t\t\t\t\trepeat++;", " \t\t\t\t\t\t\t\t\t\t\t\t\tif ((uint32_t)repeat == mp4->metastsc[stsc_pos].samples)", " \t\t\t\t\t\t\t\t\t\t\t\t\t{", " \t\t\t\t\t\t\t\t\t\t\t\t\t\tif ((uint32_t)stco_pos + 1 < metastco_count)", " \t\t\t\t\t\t\t\t\t\t\t\t\t\t{", " \t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstco_pos++;", " \t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset = (uint64_t)metaoffsets32[stco_pos];", " \t\t\t\t\t\t\t\t\t\t\t\t\t\t}", " \t\t\t\t\t\t\t\t\t\t\t\t\t\telse", " \t\t\t\t\t\t\t\t\t\t\t\t\t\t{", " \t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset += (uint64_t)mp4->metasizes[num - 1];", " \t\t\t\t\t\t\t\t\t\t\t\t\t\t}", " \t\t\t\t\t\t\t\t\t\t\t\t\t\tif ((uint32_t)stsc_pos + 1 < mp4->metastsc_count)", " \t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (mp4->metastsc[stsc_pos + 1].chunk_num == (uint32_t)stco_pos + 1)", " \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstsc_pos++;", " \t\t\t\t\t\t\t\t\t\t\t\t\t\trepeat = 1;", " \t\t\t\t\t\t\t\t\t\t\t\t\t}", " \t\t\t\t\t\t\t\t\t\t\t\t\telse", " \t\t\t\t\t\t\t\t\t\t\t\t\t{", " \t\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset += (uint64_t)mp4->metasizes[num - 1];", " \t\t\t\t\t\t\t\t\t\t\t\t\t\trepeat++;", " \t\t\t\t\t\t\t\t\t\t\t\t\t}", " \t\t\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[num] = fileoffset;", " \t\t\t\t\t\t\t\t\t\t\t\t\tnum++;", "  \t\t\t\t\t\t\t\t\t\t\t\t}", "\t\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[num] = fileoffset;", " \t\t\t\t\t\t\t\t\t\t\t\tif (mp4->metastsc) free(mp4->metastsc);", " \t\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc = NULL;", " \t\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc_count = 0;", "\t\t\t\t\t\t\t\t\t\t\t\tnum++;", " \t\t\t\t\t\t\t\t\t\t\t\tfree(metaoffsets32);", "  \t\t\t\t\t\t\t\t\t\t\t}", "\t\t\t\t\t\t\t\t\t\t\tif (mp4->metastsc) free(mp4->metastsc);", "\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc = NULL;", "\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc_count = 0;", "\t\t\t\t\t\t\t\t\t\t\tfree(metaoffsets32);", "  \t\t\t\t\t\t\t\t\t\t}", "  \t\t\t\t\t\t\t\t\t}", " \t\t\t\t\t\t\t\t\telse", " \t\t\t\t\t\t\t\t\t{", " \t\t\t\t\t\t\t\t\t\tCloseSource((size_t)mp4);", " \t\t\t\t\t\t\t\t\t\tmp4 = NULL;", " \t\t\t\t\t\t\t\t\t\tbreak;", " \t\t\t\t\t\t\t\t\t}", "  \t\t\t\t\t\t\t\t}", "  \t\t\t\t\t\t\t\telse", "  \t\t\t\t\t\t\t\t{", "  \t\t\t\t\t\t\t\t\tmp4->indexcount = num;", "  \t\t\t\t\t\t\t\t\tif (mp4->metaoffsets) free(mp4->metaoffsets);", "\t\t\t\t\t\t\t\t\tmp4->metaoffsets = (uint64_t *)malloc(num * 8);", "\t\t\t\t\t\t\t\t\tif (mp4->metaoffsets)", " \t\t\t\t\t\t\t\t\tif (num > 0)", "  \t\t\t\t\t\t\t\t\t{", "\t\t\t\t\t\t\t\t\t\tuint32_t *metaoffsets32 = NULL;", "\t\t\t\t\t\t\t\t\t\tmetaoffsets32 = (uint32_t *)malloc(num * 4);", "\t\t\t\t\t\t\t\t\t\tif (metaoffsets32)", " \t\t\t\t\t\t\t\t\t\tmp4->metaoffsets = (uint64_t *)malloc(num * 8);", " \t\t\t\t\t\t\t\t\t\tif (mp4->metaoffsets)", "  \t\t\t\t\t\t\t\t\t\t{", "\t\t\t\t\t\t\t\t\t\t\tsize_t readlen = fread(metaoffsets32, 1, num * 4, mp4->mediafp);", "\t\t\t\t\t\t\t\t\t\t\tlen += readlen;", "\t\t\t\t\t\t\t\t\t\t\tdo", " \t\t\t\t\t\t\t\t\t\t\tuint32_t *metaoffsets32 = NULL;", " \t\t\t\t\t\t\t\t\t\t\tmetaoffsets32 = (uint32_t *)malloc(num * 4);", " \t\t\t\t\t\t\t\t\t\t\tif (metaoffsets32)", "  \t\t\t\t\t\t\t\t\t\t\t{", "\t\t\t\t\t\t\t\t\t\t\t\tnum--;", "\t\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[num] = BYTESWAP32(metaoffsets32[num]);", "\t\t\t\t\t\t\t\t\t\t\t} while (num > 0);", " \t\t\t\t\t\t\t\t\t\t\t\tsize_t readlen = fread(metaoffsets32, 1, num * 4, mp4->mediafp);", " \t\t\t\t\t\t\t\t\t\t\t\tlen += readlen;", " \t\t\t\t\t\t\t\t\t\t\t\tdo", " \t\t\t\t\t\t\t\t\t\t\t\t{", " \t\t\t\t\t\t\t\t\t\t\t\t\tnum--;", " \t\t\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[num] = BYTESWAP32(metaoffsets32[num]);", " \t\t\t\t\t\t\t\t\t\t\t\t} while (num > 0);", "\t\t\t\t\t\t\t\t\t\t\tfree(metaoffsets32);", " \t\t\t\t\t\t\t\t\t\t\t\tfree(metaoffsets32);", " \t\t\t\t\t\t\t\t\t\t\t}", "  \t\t\t\t\t\t\t\t\t\t}", "  \t\t\t\t\t\t\t\t\t}", " \t\t\t\t\t\t\t\t\telse", " \t\t\t\t\t\t\t\t\t{", " \t\t\t\t\t\t\t\t\t\tCloseSource((size_t)mp4);", " \t\t\t\t\t\t\t\t\t\tmp4 = NULL;", " \t\t\t\t\t\t\t\t\t\tbreak;", " \t\t\t\t\t\t\t\t\t}", "  \t\t\t\t\t\t\t\t}", "  \t\t\t\t\t\t\t}", "\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);  ", " \t\t\t\t\t\t\tmp4->filepos += len;", " \t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len);  ", "  \t\t\t\t\t\t}", "  \t\t\t\t\t\telse", "\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);", " \t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8);", "  \t\t\t\t\t\tNESTSIZE(qtsize);", "  \t\t\t\t\t}", " \t\t\t\t\telse if (qttag == MAKEID('c', 'o', '6', '4'))  ", " \t\t\t\t\t{", " \t\t\t\t\t\tif (type == traktype)  ", " \t\t\t\t\t\t{", "  \t\t\t\t\t\t\tlen = fread(&skip, 1, 4, mp4->mediafp);", "  \t\t\t\t\t\t\tlen += fread(&num, 1, 4, mp4->mediafp);", "  \t\t\t\t\t\t\tnum = BYTESWAP32(num);", " \t\t\t\t\t\t\tif(num == 0)", " \t\t\t\t\t\t\t{", " \t\t\t\t\t\t\t\tCloseSource((size_t)mp4);", " \t\t\t\t\t\t\t\tmp4 = NULL;", " \t\t\t\t\t\t\t\tbreak;", " \t\t\t\t\t\t\t}", "  \t\t\t\t\t\t\tif (num * 8 <= qtsize - 8 - len)", "  \t\t\t\t\t\t\t{", "  \t\t\t\t\t\t\t\tif (mp4->metastsc_count > 0 && num != mp4->metasize_count)", "  \t\t\t\t\t\t\t\t{", "  \t\t\t\t\t\t\t\t\tmp4->indexcount = mp4->metasize_count;", "  \t\t\t\t\t\t\t\t\tif (mp4->metaoffsets) free(mp4->metaoffsets);", "\t\t\t\t\t\t\t\t\tmp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);", "\t\t\t\t\t\t\t\t\tif (mp4->metaoffsets)", " \t\t\t\t\t\t\t\t\tif (mp4->metasize_count)", "  \t\t\t\t\t\t\t\t\t{", "\t\t\t\t\t\t\t\t\t\tuint64_t *metaoffsets64 = NULL;", "\t\t\t\t\t\t\t\t\t\tmetaoffsets64 = (uint64_t *)malloc(num * 8);", "\t\t\t\t\t\t\t\t\t\tif (metaoffsets64)", " \t\t\t\t\t\t\t\t\t\tmp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);", " \t\t\t\t\t\t\t\t\t\tif (mp4->metaoffsets)", "  \t\t\t\t\t\t\t\t\t\t{", "\t\t\t\t\t\t\t\t\t\t\tuint64_t fileoffset = 0;", "\t\t\t\t\t\t\t\t\t\t\tint stsc_pos = 0;", "\t\t\t\t\t\t\t\t\t\t\tint stco_pos = 0;", "\t\t\t\t\t\t\t\t\t\t\tlen += fread(metaoffsets64, 1, num * 8, mp4->mediafp);", "\t\t\t\t\t\t\t\t\t\t\tdo", " \t\t\t\t\t\t\t\t\t\t\tuint64_t *metaoffsets64 = NULL;", " \t\t\t\t\t\t\t\t\t\t\tmetaoffsets64 = (uint64_t *)malloc(num * 8);", " \t\t\t\t\t\t\t\t\t\t\tif (metaoffsets64)", "  \t\t\t\t\t\t\t\t\t\t\t{", "\t\t\t\t\t\t\t\t\t\t\t\tnum--;", "\t\t\t\t\t\t\t\t\t\t\t\tmetaoffsets64[num] = BYTESWAP64(metaoffsets64[num]);", "\t\t\t\t\t\t\t\t\t\t\t} while (num > 0);", " \t\t\t\t\t\t\t\t\t\t\t\tuint64_t fileoffset = 0;", " \t\t\t\t\t\t\t\t\t\t\t\tint stsc_pos = 0;", " \t\t\t\t\t\t\t\t\t\t\t\tint stco_pos = 0;", " \t\t\t\t\t\t\t\t\t\t\t\tlen += fread(metaoffsets64, 1, num * 8, mp4->mediafp);", " \t\t\t\t\t\t\t\t\t\t\t\tdo", " \t\t\t\t\t\t\t\t\t\t\t\t{", " \t\t\t\t\t\t\t\t\t\t\t\t\tnum--;", " \t\t\t\t\t\t\t\t\t\t\t\t\tmetaoffsets64[num] = BYTESWAP64(metaoffsets64[num]);", " \t\t\t\t\t\t\t\t\t\t\t\t} while (num > 0);", "\t\t\t\t\t\t\t\t\t\t\tfileoffset = metaoffsets64[0];", "\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[0] = fileoffset;", " \t\t\t\t\t\t\t\t\t\t\t\tfileoffset = metaoffsets64[0];", " \t\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[0] = fileoffset;", "\t\t\t\t\t\t\t\t\t\t\tnum = 1;", "\t\t\t\t\t\t\t\t\t\t\twhile (num < mp4->metasize_count)", "\t\t\t\t\t\t\t\t\t\t\t{", "\t\t\t\t\t\t\t\t\t\t\t\tif (num != mp4->metastsc[stsc_pos].chunk_num - 1 && 0 == (num - (mp4->metastsc[stsc_pos].chunk_num - 1)) % mp4->metastsc[stsc_pos].samples)", "\t\t\t\t\t\t\t\t\t\t\t\t{", "\t\t\t\t\t\t\t\t\t\t\t\t\tstco_pos++;", "\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset = (uint64_t)metaoffsets64[stco_pos];", "\t\t\t\t\t\t\t\t\t\t\t\t}", "\t\t\t\t\t\t\t\t\t\t\t\telse", " \t\t\t\t\t\t\t\t\t\t\t\tnum = 1;", " \t\t\t\t\t\t\t\t\t\t\t\twhile (num < mp4->metasize_count)", "  \t\t\t\t\t\t\t\t\t\t\t\t{", "\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset += (uint64_t)mp4->metasizes[num - 1];", " \t\t\t\t\t\t\t\t\t\t\t\t\tif (num != mp4->metastsc[stsc_pos].chunk_num - 1 && 0 == (num - (mp4->metastsc[stsc_pos].chunk_num - 1)) % mp4->metastsc[stsc_pos].samples)", " \t\t\t\t\t\t\t\t\t\t\t\t\t{", " \t\t\t\t\t\t\t\t\t\t\t\t\t\tstco_pos++;", " \t\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset = (uint64_t)metaoffsets64[stco_pos];", " \t\t\t\t\t\t\t\t\t\t\t\t\t}", " \t\t\t\t\t\t\t\t\t\t\t\t\telse", " \t\t\t\t\t\t\t\t\t\t\t\t\t{", " \t\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset += (uint64_t)mp4->metasizes[num - 1];", " \t\t\t\t\t\t\t\t\t\t\t\t\t}", " \t\t\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[num] = fileoffset;", " \t\t\t\t\t\t\t\t\t\t\t\t\tnum++;", "  \t\t\t\t\t\t\t\t\t\t\t\t}", "\t\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[num] = fileoffset;", " \t\t\t\t\t\t\t\t\t\t\t\tif (mp4->metastsc) free(mp4->metastsc);", " \t\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc = NULL;", " \t\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc_count = 0;", "\t\t\t\t\t\t\t\t\t\t\t\tnum++;", " \t\t\t\t\t\t\t\t\t\t\t\tfree(metaoffsets64);", "  \t\t\t\t\t\t\t\t\t\t\t}", "\t\t\t\t\t\t\t\t\t\t\tif (mp4->metastsc) free(mp4->metastsc);", "\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc = NULL;", "\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc_count = 0;", "\t\t\t\t\t\t\t\t\t\t\tfree(metaoffsets64);", "  \t\t\t\t\t\t\t\t\t\t}", "  \t\t\t\t\t\t\t\t\t}", " \t\t\t\t\t\t\t\t\telse", " \t\t\t\t\t\t\t\t\t{", " \t\t\t\t\t\t\t\t\t\tCloseSource((size_t)mp4);", " \t\t\t\t\t\t\t\t\t\tmp4 = NULL;", " \t\t\t\t\t\t\t\t\t\tbreak;", " \t\t\t\t\t\t\t\t\t}", "  \t\t\t\t\t\t\t\t}", "  \t\t\t\t\t\t\t\telse", "  \t\t\t\t\t\t\t\t{", " \t\t\t\t\t\t\t\t\tmp4->indexcount = num;", " \t\t\t\t\t\t\t\t\tif (mp4->metaoffsets) free(mp4->metaoffsets);", " \t\t\t\t\t\t\t\t\tmp4->metaoffsets = (uint64_t *)malloc(num * 8);", " \t\t\t\t\t\t\t\t\tif (mp4->metaoffsets)", " \t\t\t\t\t\t\t\t\t{", " \t\t\t\t\t\t\t\t\t\tlen += fread(mp4->metaoffsets, 1, num * 8, mp4->mediafp);", " \t\t\t\t\t\t\t\t\t\tdo", " \t\t\t\t\t\t\t\t\t\t{", " \t\t\t\t\t\t\t\t\t\t\tnum--;", " \t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[num] = BYTESWAP64(mp4->metaoffsets[num]);", " \t\t\t\t\t\t\t\t\t\t} while (num > 0);", "  \t\t\t\t\t\t\t\t\t}", "  \t\t\t\t\t\t\t\t}", "  \t\t\t\t\t\t\t}", "\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);  ", " \t\t\t\t\t\t\tmp4->filepos += len;", " \t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len);  ", "  \t\t\t\t\t\t}", "  \t\t\t\t\t\telse", "\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);", " \t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8);", "  \t\t\t\t\t\tNESTSIZE(qtsize);", "  \t\t\t\t\t}", " \t\t\t\t\telse if (qttag == MAKEID('s', 't', 't', 's'))  ", " \t\t\t\t\t{", " \t\t\t\t\t\tif (type == traktype)  ", " \t\t\t\t\t\t{", " \t\t\t\t\t\t\tuint32_t totaldur = 0, samples = 0;", " \t\t\t\t\t\t\tint32_t entries = 0;", " \t\t\t\t\t\t\tlen = fread(&skip, 1, 4, mp4->mediafp);", " \t\t\t\t\t\t\tlen += fread(&num, 1, 4, mp4->mediafp);", " \t\t\t\t\t\t\tnum = BYTESWAP32(num);", " \t\t\t\t\t\t\tif (num * 8 <= qtsize - 8 - len)", " \t\t\t\t\t\t\t{", " \t\t\t\t\t\t\t\tentries = num;", " \t\t\t\t\t\t\t\tmp4->meta_clockdemon = mp4->trak_clockdemon;", " \t\t\t\t\t\t\t\tmp4->meta_clockcount = mp4->trak_clockcount;", " \t\t\t\t\t\t\t\twhile (entries > 0)", " \t\t\t\t\t\t\t\t{", " \t\t\t\t\t\t\t\t\tint32_t samplecount;", " \t\t\t\t\t\t\t\t\tint32_t duration;", " \t\t\t\t\t\t\t\t\tlen += fread(&samplecount, 1, 4, mp4->mediafp);", " \t\t\t\t\t\t\t\t\tsamplecount = BYTESWAP32(samplecount);", " \t\t\t\t\t\t\t\t\tlen += fread(&duration, 1, 4, mp4->mediafp);", " \t\t\t\t\t\t\t\t\tduration = BYTESWAP32(duration);", " \t\t\t\t\t\t\t\t\tsamples += samplecount;", " \t\t\t\t\t\t\t\t\tentries--;", " \t\t\t\t\t\t\t\t\ttotaldur += duration;", " \t\t\t\t\t\t\t\t\tmp4->metadatalength += (double)((double)samplecount * (double)duration / (double)mp4->meta_clockdemon);", "  \t\t\t\t\t\t\t\t}", "  \t\t\t\t\t\t\t\tmp4->basemetadataduration = mp4->metadatalength * (double)mp4->meta_clockdemon / (double)samples;", "  \t\t\t\t\t\t\t}", "\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);  ", " \t\t\t\t\t\t\tmp4->filepos += len;", " \t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len);  ", "  \t\t\t\t\t\t}", "  \t\t\t\t\t\telse", "\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);", " \t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8);", "  \t\t\t\t\t\tNESTSIZE(qtsize);", "  \t\t\t\t\t}", " \t\t\t\t\telse", " \t\t\t\t\t{", " \t\t\t\t\t\tNESTSIZE(8);", " \t\t\t\t\t}", " \t\t\t}", " \t\t\telse", " \t\t\t{", "  \t\t\t\tbreak;", "  \t\t\t}", "  \t\t} while (len > 0);", " \t\tif (mp4)", " \t\t{", " \t\t\tif (mp4->metasizes == NULL || mp4->metaoffsets == NULL)", " \t\t\t{", " \t\t\t\tCloseSource((size_t)mp4);", " \t\t\t\tmp4 = NULL;", " \t\t\t}", " \t\t}", "  \t}", "  \telse", "  \t{", " \t\tfree(mp4);", " \t\tmp4 = NULL;", " \t}", " \treturn (size_t)mp4;", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" jp2_box_t *jp2_box_get(jas_stream_t *in)", " {", " \tjp2_box_t *box;", " \tjp2_boxinfo_t *boxinfo;", " \tjas_stream_t *tmpstream;", " \tuint_fast32_t len;", " \tuint_fast64_t extlen;", " \tbool dataflag;", "  \tbox = 0;", "  \ttmpstream = 0;", "\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {", " \tif (!(box = jp2_box_create0())) {", "  \t\tgoto error;", "  \t}", "\tbox->ops = &jp2_boxinfo_unk.ops;", "  \tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {", "  \t\tgoto error;", "  \t}", "  \tboxinfo = jp2_boxinfolookup(box->type);", "  \tbox->info = boxinfo;", "  \tbox->len = len;", "  \tJAS_DBGLOG(10, (", "\t  \"preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n\",", " \t  \"preliminary processing of JP2 box: \"", " \t  \"type=%c%s%c (0x%08x); length=%\"PRIuFAST32\"\\n\",", "  \t  '\"', boxinfo->name, '\"', box->type, box->len", "  \t  ));", "  \tif (box->len == 1) {", " \t\tJAS_DBGLOG(10, (\"big length\\n\"));", "  \t\tif (jp2_getuint64(in, &extlen)) {", "  \t\t\tgoto error;", "  \t\t}", " \t\tif (extlen > 0xffffffffUL) {", " \t\t\tjas_eprintf(\"warning: cannot handle large 64-bit box length\\n\");", " \t\t\textlen = 0xffffffffUL;", " \t\t}", " \t\tbox->len = extlen;", " \t\tbox->datalen = extlen - JP2_BOX_HDRLEN(true);", " \t} else {", " \t\tbox->datalen = box->len - JP2_BOX_HDRLEN(false);", " \t}", " \tif (box->len != 0 && box->len < 8) {", " \t\tgoto error;", " \t}", " \tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));", " \tif (dataflag) {", " \t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {", " \t\t\tgoto error;", " \t\t}", " \t\tif (jas_stream_copy(tmpstream, in, box->datalen)) {", " \t\t\tjas_eprintf(\"cannot copy box data\\n\");", " \t\t\tgoto error;", " \t\t}", " \t\tjas_stream_rewind(tmpstream);", " \t\tbox->ops = &boxinfo->ops;", " \t\tif (box->ops->getdata) {", " \t\t\tif ((*box->ops->getdata)(box, tmpstream)) {", " \t\t\t\tjas_eprintf(\"cannot parse box data\\n\");", " \t\t\t\tgoto error;", " \t\t\t}", " \t\t}", " \t\tjas_stream_close(tmpstream);", " \t}", " \tif (jas_getdbglevel() >= 1) {", " \t\tjp2_box_dump(box, stderr);", " \t}", " \treturn box;", " error:", " \tif (box) {", " \t\tjp2_box_destroy(box);", " \t}", " \tif (tmpstream) {", " \t\tjas_stream_close(tmpstream);", " \t}", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void ff_jpeg2000_cleanup(Jpeg2000Component *comp, Jpeg2000CodingStyle *codsty)", " {", "     int reslevelno, bandno, precno;", "     for (reslevelno = 0;", "          comp->reslevel && reslevelno < codsty->nreslevels;", "          reslevelno++) {", "         Jpeg2000ResLevel *reslevel = comp->reslevel + reslevelno;", "          for (bandno = 0; bandno < reslevel->nbands; bandno++) {", "              Jpeg2000Band *band = reslevel->band + bandno;", "              for (precno = 0; precno < reslevel->num_precincts_x * reslevel->num_precincts_y; precno++) {", "                Jpeg2000Prec *prec = band->prec + precno;", "                av_freep(&prec->zerobits);", "                av_freep(&prec->cblkincl);", "                av_freep(&prec->cblk);", "                 if (band->prec) {", "                     Jpeg2000Prec *prec = band->prec + precno;", "                     av_freep(&prec->zerobits);", "                     av_freep(&prec->cblkincl);", "                     av_freep(&prec->cblk);", "                 }", "              }", "              av_freep(&band->prec);", "         }", "         av_freep(&reslevel->band);", "     }", "     ff_dwt_destroy(&comp->dwt);", "     av_freep(&comp->reslevel);", "     av_freep(&comp->i_data);", "     av_freep(&comp->f_data);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void vrend_renderer_context_create_internal(uint32_t handle, uint32_t nlen,", "                                             const char *debug_name)", " {", "    struct vrend_decode_ctx *dctx;", "     if (handle >= VREND_MAX_CTX)", "        return;", "    dctx = dec_ctx[handle];", "    if (dctx)", "       return;", "     dctx = malloc(sizeof(struct vrend_decode_ctx));", "     if (!dctx)", "        return;", "       return;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" gpk_parse_fileinfo(sc_card_t *card,", " \t\tconst u8 *buf, size_t buflen,", " \t\tsc_file_t *file)", " {", " \tconst u8\t*sp, *end, *next;", " \tint\t\ti, rc;", " \tmemset(file, 0, sizeof(*file));", " \tfor (i = 0; i < SC_MAX_AC_OPS; i++)", " \t\tsc_file_add_acl_entry(file, i, SC_AC_UNKNOWN, SC_AC_KEY_REF_NONE);", " \tend = buf + buflen;", " \tfor (sp = buf; sp + 2 < end; sp = next) {", " \t\tnext = sp + 2 + sp[1];", " \t\tif (next > end)", " \t\t\tbreak;", " \t\tif (sp[0] == 0x84) {", " \t\t\tif (sp[1] > sizeof(file->name))", " \t\t\t\tcontinue;", " \t\t\tmemset(file->name, 0, sizeof(file->name));", " \t\t\tmemcpy(file->name, sp+2, sp[1]);", " \t\t} else", "  \t\tif (sp[0] == 0x85) {", "  \t\t\tunsigned int\tac[3], n;", " \t\t\tif (sp + 11 + 2*3 >= end)", " \t\t\t\tbreak;", "  \t\t\tfile->id = (sp[4] << 8) | sp[5];", "  \t\t\tfile->size = (sp[8] << 8) | sp[9];", "  \t\t\tfile->record_length = sp[7];", " \t\t\tfor (n = 0; n < 3; n++)", " \t\t\t\tac[n] = (sp[10+2*n] << 8) | sp[11+2*n];", " \t\t\tswitch (sp[6] & 7) {", " \t\t\tcase 0x01: case 0x02: case 0x03: case 0x04:", " \t\t\tcase 0x05: case 0x06: case 0x07:", " \t\t\t\tfile->type = SC_FILE_TYPE_WORKING_EF;", " \t\t\t\tfile->ef_structure = sp[6] & 7;", " \t\t\t\tac_to_acl(ac[0], file, SC_AC_OP_UPDATE);", " \t\t\t\tac_to_acl(ac[1], file, SC_AC_OP_WRITE);", " \t\t\t\tac_to_acl(ac[2], file, SC_AC_OP_READ);", " \t\t\t\tbreak;", " \t\t\tcase 0x00:  ", " \t\t\t\tfile->type = SC_FILE_TYPE_DF;", " \t\t\t\tac_to_acl(ac[0], file, SC_AC_OP_LOCK);", " \t\t\t\tac_to_acl(ac[1], file, SC_AC_OP_CREATE);", " \t\t\t\tsc_file_add_acl_entry(file, SC_AC_OP_SELECT,", " \t\t\t\t\tSC_AC_NONE, SC_AC_KEY_REF_NONE);", " \t\t\t\tsc_file_add_acl_entry(file, SC_AC_OP_DELETE,", " \t\t\t\t\tSC_AC_NEVER, SC_AC_KEY_REF_NONE);", " \t\t\t\tsc_file_add_acl_entry(file, SC_AC_OP_REHABILITATE,", " \t\t\t\t\tSC_AC_NEVER, SC_AC_KEY_REF_NONE);", " \t\t\t\tsc_file_add_acl_entry(file, SC_AC_OP_INVALIDATE,", " \t\t\t\t\tSC_AC_NEVER, SC_AC_KEY_REF_NONE);", " \t\t\t\tsc_file_add_acl_entry(file, SC_AC_OP_LIST_FILES,", " \t\t\t\t\tSC_AC_NEVER, SC_AC_KEY_REF_NONE);", " \t\t\t\tbreak;", " \t\t\t}", " \t\t} else", " \t\tif (sp[0] == 0x6f) {", " \t\t\tfile->type = SC_FILE_TYPE_DF;", " \t\t\trc = gpk_parse_fci(card, sp + 2, sp[1], file);", " \t\t\tif (rc < 0)", " \t\t\t\treturn rc;", " \t\t}", " \t}", " \tif (file->record_length)", " \t\tfile->record_count = file->size / file->record_length;", " \tfile->magic = SC_FILE_MAGIC;", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static jas_image_cmpt_t *jas_image_cmpt_create(int_fast32_t tlx,", "   int_fast32_t tly, int_fast32_t hstep, int_fast32_t vstep,", "   int_fast32_t width, int_fast32_t height, uint_fast16_t depth, bool sgnd,", "   uint_fast32_t inmem)", " {", "  \tjas_image_cmpt_t *cmpt;", "  \tsize_t size;", " \tJAS_DBGLOG(100, (", " \t  \"jas_image_cmpt_create(%ld, %ld, %ld, %ld, %ld, %ld, %d, %d, %d)\\n\",", " \t  JAS_CAST(long, tlx),", " \t  JAS_CAST(long, tly),", " \t  JAS_CAST(long, hstep),", " \t  JAS_CAST(long, vstep),", " \t  JAS_CAST(long, width),", " \t  JAS_CAST(long, height),", " \t  JAS_CAST(int, depth),", " \t  sgnd,", " \t  inmem", " \t  ));", "  \tcmpt = 0;", "  \tif (width < 0 || height < 0 || hstep <= 0 || vstep <= 0) {", "  \t\tgoto error;", " \t}", " \tif (!jas_safe_intfast32_add(tlx, width, 0) ||", "  \t  !jas_safe_intfast32_add(tly, height, 0)) {", "  \t\tgoto error;", "  \t}", " \tif (!jas_safe_intfast32_mul3(width, height, depth, 0)) {", " \t\tgoto error;", " \t}", "  \tif (!(cmpt = jas_malloc(sizeof(jas_image_cmpt_t)))) {", "  \t\tgoto error;", " \t}", " \tcmpt->type_ = JAS_IMAGE_CT_UNKNOWN;", " \tcmpt->tlx_ = tlx;", " \tcmpt->tly_ = tly;", " \tcmpt->hstep_ = hstep;", " \tcmpt->vstep_ = vstep;", " \tcmpt->width_ = width;", " \tcmpt->height_ = height;", " \tcmpt->prec_ = depth;", " \tcmpt->sgnd_ = sgnd;", " \tcmpt->stream_ = 0;", " \tcmpt->cps_ = (depth + 7) / 8;", "\tif (!jas_safe_size_mul(cmpt->width_, cmpt->height_, &size) ||", "\t  !jas_safe_size_mul(size, cmpt->cps_, &size)) {", " \tif (!jas_safe_size_mul3(cmpt->width_, cmpt->height_, cmpt->cps_, &size)) {", "  \t\tgoto error;", "  \t}", "  \tcmpt->stream_ = (inmem) ? jas_stream_memopen2(0, size) :", " \t  jas_stream_tmpfile();", " \tif (!cmpt->stream_) {", " \t\tgoto error;", " \t}", " \tif (size > 0) {", " \t\tif (size - 1 > LONG_MAX) {", " \t\t\tgoto error;", " \t\t}", " \t\tif (jas_stream_seek(cmpt->stream_, size - 1, SEEK_SET) < 0 ||", " \t\t  jas_stream_putc(cmpt->stream_, 0) == EOF ||", " \t\t  jas_stream_seek(cmpt->stream_, 0, SEEK_SET) < 0) {", " \t\t\tgoto error;", " \t\t}", " \t}", " \treturn cmpt;", " error:", " \tif (cmpt) {", " \t\tjas_image_cmpt_destroy(cmpt);", " \t}", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" coolkey_find_attribute(sc_card_t *card, sc_cardctl_coolkey_attribute_t *attribute)", " {", " \tu8 object_record_type;", " \tCK_ATTRIBUTE_TYPE attr_type = attribute->attribute_type;", " \tconst u8 *obj = attribute->object->data;", " \tconst u8 *attr = NULL;", " \tsize_t buf_len = attribute->object->length;", " \tcoolkey_object_header_t *object_head;", " \tint attribute_count,i;", " \tattribute->attribute_data_type = SC_CARDCTL_COOLKEY_ATTR_TYPE_STRING;", " \tattribute->attribute_length = 0;", " \tattribute->attribute_value = NULL;", " \tif (obj == NULL) {", " \t\tint r = coolkey_fill_object(card, (sc_cardctl_coolkey_object_t *)attribute->object);", " \t\tif (r < 0) {", " \t\t\treturn r;", " \t\t}", " \t\tobj = attribute->object->data;", " \t}", " \tassert(sizeof(coolkey_object_header_t) >= sizeof(coolkey_v0_object_header_t));", " \tif (buf_len <= sizeof(coolkey_v0_object_header_t)) {", " \t\treturn SC_ERROR_CORRUPTED_DATA;", " \t}", " \tobject_head = (coolkey_object_header_t *)obj;", " \tobject_record_type = object_head->record_type;", " \tif ((object_record_type != COOLKEY_V1_OBJECT) && (object_record_type != COOLKEY_V0_OBJECT)) {", " \t\treturn SC_ERROR_CORRUPTED_DATA;", " \t}", " \tattr = coolkey_attribute_start(obj, object_record_type, buf_len);", " \tif (attr == NULL) {", " \t\treturn SC_ERROR_CORRUPTED_DATA;", " \t}", " \tbuf_len -= (attr-obj);", " \tattribute_count = coolkey_get_attribute_count(obj, object_record_type, buf_len);", "  \tfor (i=0; i < attribute_count; i++) {", "  \t\tsize_t record_len = coolkey_get_attribute_record_len(attr, object_record_type, buf_len);", "\t\tif (buf_len < record_len) {", " \t\tif (buf_len < record_len || record_len < 4) {", "  \t\t\t\treturn SC_ERROR_CORRUPTED_DATA;", "  \t\t}", " \t\tif (attr_type == coolkey_get_attribute_type(attr, object_record_type, record_len)) {", " \t\t\treturn coolkey_get_attribute_data(attr, object_record_type, record_len, attribute);", " \t\t}", " \t\tbuf_len -= record_len;", " \t\tattr += record_len;", " \t}", " \tif (object_record_type == COOLKEY_V1_OBJECT) {", " \t\tunsigned long fixed_attributes = bebytes2ulong(object_head->fixed_attributes_values);", " \t\treturn coolkey_get_attribute_data_fixed(attr_type, fixed_attributes, attribute);", " \t}", " \treturn SC_ERROR_DATA_OBJECT_NOT_FOUND;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  next_line(struct archive_read *a,", "      const char **b, ssize_t *avail, ssize_t *ravail, ssize_t *nl)", " {", " \tssize_t len;", " \tint quit;", " \tquit = 0;", " \tif (*avail == 0) {", " \t\t*nl = 0;", " \t\tlen = 0;", " \t} else", " \t\tlen = get_line_size(*b, *avail, nl);", " \twhile (*nl == 0 && len == *avail && !quit) {", " \t\tssize_t diff = *ravail - *avail;", " \t\tsize_t nbytes_req = (*ravail+1023) & ~1023U;", " \t\tssize_t tested;", " \t\tif (nbytes_req < (size_t)*ravail + 160)", " \t\t\tnbytes_req <<= 1;", " \t\t*b = __archive_read_ahead(a, nbytes_req, avail);", " \t\tif (*b == NULL) {", " \t\t\tif (*ravail >= *avail)", " \t\t\t\treturn (0);", " \t\t\t*b = __archive_read_ahead(a, *avail, avail);", " \t\t\tquit = 1;", " \t\t}", " \t\t*ravail = *avail;", "  \t\t*b += diff;", "  \t\t*avail -= diff;", "  \t\ttested = len; ", "\t\tlen = get_line_size(*b, *avail, nl);", " \t\tlen = get_line_size(*b + len, *avail - len, nl);", "  \t\tif (len >= 0)", "  \t\t\tlen += tested;", "  \t}", " \treturn (len);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" static int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)", "  {", "  \tjp2_bpcc_t *bpcc = &box->data.bpcc;", "  \tunsigned int i;", " \tbpcc->bpcs = 0;", "  \tbpcc->numcmpts = box->datalen;", "  \tif (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts, sizeof(uint_fast8_t)))) {", "  \t\treturn -1;", " \t}", " \tfor (i = 0; i < bpcc->numcmpts; ++i) {", " \t\tif (jp2_getuint8(in, &bpcc->bpcs[i])) {", " \t\t\treturn -1;", " \t\t}", " \t}", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int get_siz(Jpeg2000DecoderContext *s)", " {", "     int i;", "     int ncomponents;", "     uint32_t log2_chroma_wh = 0;", "     const enum AVPixelFormat *possible_fmts = NULL;", "     int possible_fmts_nb = 0;", "     if (bytestream2_get_bytes_left(&s->g) < 36)", "         return AVERROR_INVALIDDATA;", "     s->avctx->profile = bytestream2_get_be16u(&s->g);  ", "     s->width          = bytestream2_get_be32u(&s->g);  ", "     s->height         = bytestream2_get_be32u(&s->g);  ", "     s->image_offset_x = bytestream2_get_be32u(&s->g);  ", "     s->image_offset_y = bytestream2_get_be32u(&s->g);  ", "     s->tile_width     = bytestream2_get_be32u(&s->g);  ", "     s->tile_height    = bytestream2_get_be32u(&s->g);  ", "     s->tile_offset_x  = bytestream2_get_be32u(&s->g);  ", "     s->tile_offset_y  = bytestream2_get_be32u(&s->g);  ", "     ncomponents       = bytestream2_get_be16u(&s->g);  ", "     if (ncomponents <= 0) {", "         av_log(s->avctx, AV_LOG_ERROR, \"Invalid number of components: %d\\n\",", "                s->ncomponents);", "         return AVERROR_INVALIDDATA;", "     }", "     if (ncomponents > 4) {", "         avpriv_request_sample(s->avctx, \"Support for %d components\",", "                               s->ncomponents);", "         return AVERROR_PATCHWELCOME;", "     }", "     s->ncomponents = ncomponents;", "     if (s->tile_width <= 0 || s->tile_height <= 0) {", "         av_log(s->avctx, AV_LOG_ERROR, \"Invalid tile dimension %dx%d.\\n\",", "                s->tile_width, s->tile_height);", "         return AVERROR_INVALIDDATA;", "     }", "     if (bytestream2_get_bytes_left(&s->g) < 3 * s->ncomponents)", "         return AVERROR_INVALIDDATA;", "     for (i = 0; i < s->ncomponents; i++) {  ", "         uint8_t x    = bytestream2_get_byteu(&s->g);", "         s->cbps[i]   = (x & 0x7f) + 1;", "         s->precision = FFMAX(s->cbps[i], s->precision);", "          s->sgnd[i]   = !!(x & 0x80);", "          s->cdx[i]    = bytestream2_get_byteu(&s->g);", "          s->cdy[i]    = bytestream2_get_byteu(&s->g);", "        if (!s->cdx[i] || !s->cdy[i]) {", "         if (   !s->cdx[i] || s->cdx[i] == 3 || s->cdx[i] > 4", "             || !s->cdy[i] || s->cdy[i] == 3 || s->cdy[i] > 4) {", "              av_log(s->avctx, AV_LOG_ERROR, \"Invalid sample seperation\\n\");", "              return AVERROR_INVALIDDATA;", "          }", "         log2_chroma_wh |= s->cdy[i] >> 1 << i * 4 | s->cdx[i] >> 1 << i * 4 + 2;", "     }", "     s->numXtiles = ff_jpeg2000_ceildiv(s->width  - s->tile_offset_x, s->tile_width);", "     s->numYtiles = ff_jpeg2000_ceildiv(s->height - s->tile_offset_y, s->tile_height);", "     if (s->numXtiles * (uint64_t)s->numYtiles > INT_MAX/sizeof(*s->tile)) {", "         s->numXtiles = s->numYtiles = 0;", "         return AVERROR(EINVAL);", "     }", "     s->tile = av_mallocz_array(s->numXtiles * s->numYtiles, sizeof(*s->tile));", "     if (!s->tile) {", "         s->numXtiles = s->numYtiles = 0;", "         return AVERROR(ENOMEM);", "     }", "     for (i = 0; i < s->numXtiles * s->numYtiles; i++) {", "         Jpeg2000Tile *tile = s->tile + i;", "         tile->comp = av_mallocz(s->ncomponents * sizeof(*tile->comp));", "         if (!tile->comp)", "             return AVERROR(ENOMEM);", "     }", "     s->avctx->width  = ff_jpeg2000_ceildivpow2(s->width  - s->image_offset_x,", "                                                s->reduction_factor);", "     s->avctx->height = ff_jpeg2000_ceildivpow2(s->height - s->image_offset_y,", "                                                s->reduction_factor);", "     if (s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_2K ||", "         s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_4K) {", "         possible_fmts = xyz_pix_fmts;", "         possible_fmts_nb = FF_ARRAY_ELEMS(xyz_pix_fmts);", "     } else {", "         switch (s->colour_space) {", "         case 16:", "             possible_fmts = rgb_pix_fmts;", "             possible_fmts_nb = FF_ARRAY_ELEMS(rgb_pix_fmts);", "             break;", "         case 17:", "             possible_fmts = gray_pix_fmts;", "             possible_fmts_nb = FF_ARRAY_ELEMS(gray_pix_fmts);", "             break;", "         case 18:", "             possible_fmts = yuv_pix_fmts;", "             possible_fmts_nb = FF_ARRAY_ELEMS(yuv_pix_fmts);", "             break;", "         default:", "             possible_fmts = all_pix_fmts;", "             possible_fmts_nb = FF_ARRAY_ELEMS(all_pix_fmts);", "             break;", "         }", "     }", "     for (i = 0; i < possible_fmts_nb; ++i) {", "         if (pix_fmt_match(possible_fmts[i], ncomponents, s->precision, log2_chroma_wh, s->pal8)) {", "             s->avctx->pix_fmt = possible_fmts[i];", "             break;", "         }", "     }", "     if (s->avctx->pix_fmt == AV_PIX_FMT_NONE) {", "         av_log(s->avctx, AV_LOG_ERROR,", "                \"Unknown pix_fmt, profile: %d, colour_space: %d, \"", "                \"components: %d, precision: %d, \"", "                \"cdx[1]: %d, cdy[1]: %d, cdx[2]: %d, cdy[2]: %d\\n\",", "                s->avctx->profile, s->colour_space, ncomponents, s->precision,", "                ncomponents > 2 ? s->cdx[1] : 0,", "                ncomponents > 2 ? s->cdy[1] : 0,", "                ncomponents > 2 ? s->cdx[2] : 0,", "                ncomponents > 2 ? s->cdy[2] : 0);", "     }", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void _jsvTrace(JsVar *var, int indent, JsVar *baseVar, int level) {", " #ifdef SAVE_ON_FLASH", "   jsiConsolePrint(\"Trace unimplemented in this version.\\n\");", " #else", "   int i;", "   for (i=0;i<indent;i++) jsiConsolePrint(\" \");", "   if (!var) {", "     jsiConsolePrint(\"undefined\");", "     return;", "   }", "   jsvTraceLockInfo(var);", "   int lowestLevel = _jsvTraceGetLowestLevel(baseVar, var);", "   if (lowestLevel < level) {", "     jsiConsolePrint(\"...\\n\");", "     return;", "   }", "   if (jsvIsName(var)) jsiConsolePrint(\"Name \");", "   char endBracket = ' ';", "   if (jsvIsObject(var)) { jsiConsolePrint(\"Object { \"); endBracket = '}'; }", "   else if (jsvIsArray(var)) { jsiConsolePrintf(\"Array(%d) [ \", var->varData.integer); endBracket = ']'; }", "   else if (jsvIsNativeFunction(var)) { jsiConsolePrintf(\"NativeFunction 0x%x (%d) { \", var->varData.native.ptr, var->varData.native.argTypes); endBracket = '}'; }", "   else if (jsvIsFunction(var)) {", "     jsiConsolePrint(\"Function { \");", "     if (jsvIsFunctionReturn(var)) jsiConsolePrint(\"return \");", "     endBracket = '}';", "   } else if (jsvIsPin(var)) jsiConsolePrintf(\"Pin %d\", jsvGetInteger(var));", "   else if (jsvIsInt(var)) jsiConsolePrintf(\"Integer %d\", jsvGetInteger(var));", "   else if (jsvIsBoolean(var)) jsiConsolePrintf(\"Bool %s\", jsvGetBool(var)?\"true\":\"false\");", "    else if (jsvIsFloat(var)) jsiConsolePrintf(\"Double %f\", jsvGetFloat(var));", "    else if (jsvIsFunctionParameter(var)) jsiConsolePrintf(\"Param %q \", var);", "    else if (jsvIsArrayBufferName(var)) jsiConsolePrintf(\"ArrayBufferName[%d] \", jsvGetInteger(var));", "  else if (jsvIsArrayBuffer(var)) jsiConsolePrintf(\"%s \", jswGetBasicObjectName(var));  ", "   else if (jsvIsArrayBuffer(var)) jsiConsolePrintf(\"%s \", jswGetBasicObjectName(var)?jswGetBasicObjectName(var):\"unknown ArrayBuffer\");  ", "    else if (jsvIsString(var)) {", "      size_t blocks = 1;", "      if (jsvGetLastChild(var)) {", "       JsVar *v = jsvLock(jsvGetLastChild(var));", "       blocks += jsvCountJsVarsUsed(v);", "       jsvUnLock(v);", "     }", "     if (jsvIsFlatString(var)) {", "       blocks += jsvGetFlatStringBlocks(var);", "     }", "     jsiConsolePrintf(\"%sString [%d blocks] %q\", jsvIsFlatString(var)?\"Flat\":(jsvIsNativeString(var)?\"Native\":\"\"), blocks, var);", "   } else {", "     jsiConsolePrintf(\"Unknown %d\", var->flags & (JsVarFlags)~(JSV_LOCK_MASK));", "   }", "   if (jsvIsNameInt(var)) {", "     jsiConsolePrintf(\"= int %d\\n\", (int)jsvGetFirstChildSigned(var));", "     return;", "   } else if (jsvIsNameIntBool(var)) {", "     jsiConsolePrintf(\"= bool %s\\n\", jsvGetFirstChild(var)?\"true\":\"false\");", "     return;", "   }", "   if (jsvHasSingleChild(var)) {", "     JsVar *child = jsvGetFirstChild(var) ? jsvLock(jsvGetFirstChild(var)) : 0;", "     _jsvTrace(child, indent+2, baseVar, level+1);", "     jsvUnLock(child);", "   } else if (jsvHasChildren(var)) {", "     JsvIterator it;", "     jsvIteratorNew(&it, var, JSIF_DEFINED_ARRAY_ElEMENTS);", "     bool first = true;", "     while (jsvIteratorHasElement(&it) && !jspIsInterrupted()) {", "       if (first) jsiConsolePrintf(\"\\n\");", "       first = false;", "       JsVar *child = jsvIteratorGetKey(&it);", "       _jsvTrace(child, indent+2, baseVar, level+1);", "       jsvUnLock(child);", "       jsiConsolePrintf(\"\\n\");", "       jsvIteratorNext(&it);", "     }", "     jsvIteratorFree(&it);", "     if (!first)", "       for (i=0;i<indent;i++) jsiConsolePrint(\" \");", "   }", "   jsiConsolePrintf(\"%c\", endBracket);", " #endif", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" NO_INLINE JsVar *jspeArrowFunction(JsVar *funcVar, JsVar *a) {", "   assert(!a || jsvIsName(a));", "   JSP_ASSERT_MATCH(LEX_ARROW_FUNCTION);", "   funcVar = jspeAddNamedFunctionParameter(funcVar, a);", "   bool expressionOnly = lex->tk!='{';", "   jspeFunctionDefinitionInternal(funcVar, expressionOnly);", "   if (execInfo.thisVar) {", "     jsvObjectSetChild(funcVar, JSPARSE_FUNCTION_THIS_NAME, execInfo.thisVar);", "   }", "   return funcVar;", " }", " NO_INLINE JsVar *jspeExpressionOrArrowFunction() {", "   JsVar *a = 0;", "   JsVar *funcVar = 0;", "   bool allNames = true;", "   while (lex->tk!=')' && !JSP_SHOULDNT_PARSE) {", "     if (allNames && a) {", "       funcVar = jspeAddNamedFunctionParameter(funcVar, a);", "     }", "     jsvUnLock(a);", "     a = jspeAssignmentExpression();", "     if (!(jsvIsName(a) && jsvIsString(a))) allNames = false;", "     if (lex->tk!=')') JSP_MATCH_WITH_CLEANUP_AND_RETURN(',', jsvUnLock2(a,funcVar), 0);", "   }", "   JSP_MATCH_WITH_CLEANUP_AND_RETURN(')', jsvUnLock2(a,funcVar), 0);", "   if (allNames && lex->tk==LEX_ARROW_FUNCTION) {", "     funcVar = jspeArrowFunction(funcVar, a);", "     jsvUnLock(a);", "     return funcVar;", "   } else {", "     jsvUnLock(funcVar);", "     return a;", "   }", " }", " NO_INLINE JsVar *jspeClassDefinition(bool parseNamedClass) {", "   JsVar *classFunction = 0;", "   JsVar *classPrototype = 0;", "   JsVar *classInternalName = 0;", "   bool actuallyCreateClass = JSP_SHOULD_EXECUTE;", "   if (actuallyCreateClass)", "     classFunction = jsvNewWithFlags(JSV_FUNCTION);", "   if (parseNamedClass && lex->tk==LEX_ID) {", "     if (classFunction)", "       classInternalName = jslGetTokenValueAsVar(lex);", "     JSP_ASSERT_MATCH(LEX_ID);", "   }", "   if (classFunction) {", "     JsVar *prototypeName = jsvFindChildFromString(classFunction, JSPARSE_PROTOTYPE_VAR, true);", "     jspEnsureIsPrototype(classFunction, prototypeName);  ", "     classPrototype = jsvSkipName(prototypeName);", "     jsvUnLock(prototypeName);", "   }", "   if (lex->tk==LEX_R_EXTENDS) {", "     JSP_ASSERT_MATCH(LEX_R_EXTENDS);", "     JsVar *extendsFrom = actuallyCreateClass ? jsvSkipNameAndUnLock(jspGetNamedVariable(jslGetTokenValueAsString(lex))) : 0;", "     JSP_MATCH_WITH_CLEANUP_AND_RETURN(LEX_ID,jsvUnLock4(extendsFrom,classFunction,classInternalName,classPrototype),0);", "     if (classPrototype) {", "       if (jsvIsFunction(extendsFrom)) {", "         jsvObjectSetChild(classPrototype, JSPARSE_INHERITS_VAR, extendsFrom);", "         jsvObjectSetChildAndUnLock(classFunction, JSPARSE_FUNCTION_CODE_NAME, jsvNewFromString(\"if(this.__proto__.__proto__)this.__proto__.__proto__.apply(this,arguments)\"));", "       } else", "         jsExceptionHere(JSET_SYNTAXERROR, \"'extends' argument should be a function, got %t\", extendsFrom);", "     }", "     jsvUnLock(extendsFrom);", "   }", "   JSP_MATCH_WITH_CLEANUP_AND_RETURN('{',jsvUnLock3(classFunction,classInternalName,classPrototype),0);", "   while ((lex->tk==LEX_ID || lex->tk==LEX_R_STATIC) && !jspIsInterrupted()) {", "     bool isStatic = lex->tk==LEX_R_STATIC;", "     if (isStatic) JSP_ASSERT_MATCH(LEX_R_STATIC);", "     JsVar *funcName = jslGetTokenValueAsVar(lex);", "     JSP_MATCH_WITH_CLEANUP_AND_RETURN(LEX_ID,jsvUnLock3(classFunction,classInternalName,classPrototype),0);", "     JsVar *method = jspeFunctionDefinition(false);", "     if (classFunction && classPrototype) {", "       if (jsvIsStringEqual(funcName, \"get\") || jsvIsStringEqual(funcName, \"set\")) {", "         jsExceptionHere(JSET_SYNTAXERROR, \"'get' and 'set' and not supported in Espruino\");", "       } else if (jsvIsStringEqual(funcName, \"constructor\")) {", "         jswrap_function_replaceWith(classFunction, method);", "       } else {", "         funcName = jsvMakeIntoVariableName(funcName, 0);", "         jsvSetValueOfName(funcName, method);", "         jsvAddName(isStatic ? classFunction : classPrototype, funcName);", "       }", "     }", "     jsvUnLock2(method,funcName);", "   }", "   jsvUnLock(classPrototype);", "   if (classInternalName)", "     jsvObjectSetChildAndUnLock(classFunction, JSPARSE_FUNCTION_NAME_NAME, classInternalName);", "   JSP_MATCH_WITH_CLEANUP_AND_RETURN('}',jsvUnLock(classFunction),0);", "   return classFunction;", " }", " #endif", " NO_INLINE JsVar *jspeFactor() {", "   if (lex->tk==LEX_ID) {", "     JsVar *a = jspGetNamedVariable(jslGetTokenValueAsString(lex));", "     JSP_ASSERT_MATCH(LEX_ID);", " #ifndef SAVE_ON_FLASH", "     if (lex->tk==LEX_TEMPLATE_LITERAL)", "       jsExceptionHere(JSET_SYNTAXERROR, \"Tagged template literals not supported\");", "     else if (lex->tk==LEX_ARROW_FUNCTION && jsvIsName(a)) {", "       JsVar *funcVar = jspeArrowFunction(0,a);", "       jsvUnLock(a);", "       a=funcVar;", "     }", " #endif", "     return a;", "   } else if (lex->tk==LEX_INT) {", "     JsVar *v = 0;", "     if (JSP_SHOULD_EXECUTE) {", "       v = jsvNewFromLongInteger(stringToInt(jslGetTokenValueAsString(lex)));", "     }", "     JSP_ASSERT_MATCH(LEX_INT);", "     return v;", "   } else if (lex->tk==LEX_FLOAT) {", "     JsVar *v = 0;", "     if (JSP_SHOULD_EXECUTE) {", "       v = jsvNewFromFloat(stringToFloat(jslGetTokenValueAsString(lex)));", "     }", "     JSP_ASSERT_MATCH(LEX_FLOAT);", "     return v;", "   } else if (lex->tk=='(') {", "     JSP_ASSERT_MATCH('(');", "     if (!jspCheckStackPosition()) return 0;", " #ifdef SAVE_ON_FLASH", "     JsVar *a = jspeExpression();", "     if (!JSP_SHOULDNT_PARSE) JSP_MATCH_WITH_RETURN(')',a);", "     return a;", " #else", "     return jspeExpressionOrArrowFunction();", " #endif", "   } else if (lex->tk==LEX_R_TRUE) {", "     JSP_ASSERT_MATCH(LEX_R_TRUE);", "     return JSP_SHOULD_EXECUTE ? jsvNewFromBool(true) : 0;", "   } else if (lex->tk==LEX_R_FALSE) {", "     JSP_ASSERT_MATCH(LEX_R_FALSE);", "     return JSP_SHOULD_EXECUTE ? jsvNewFromBool(false) : 0;", "   } else if (lex->tk==LEX_R_NULL) {", "     JSP_ASSERT_MATCH(LEX_R_NULL);", "     return JSP_SHOULD_EXECUTE ? jsvNewWithFlags(JSV_NULL) : 0;", "   } else if (lex->tk==LEX_R_UNDEFINED) {", "     JSP_ASSERT_MATCH(LEX_R_UNDEFINED);", "     return 0;", "   } else if (lex->tk==LEX_STR) {", "     JsVar *a = 0;", "     if (JSP_SHOULD_EXECUTE)", "       a = jslGetTokenValueAsVar(lex);", "     JSP_ASSERT_MATCH(LEX_STR);", "     return a;", " #ifndef SAVE_ON_FLASH", "   } else if (lex->tk==LEX_TEMPLATE_LITERAL) {", "     return jspeTemplateLiteral();", " #endif", "   } else if (lex->tk==LEX_REGEX) {", "     JsVar *a = 0;", " #ifdef SAVE_ON_FLASH", "     jsExceptionHere(JSET_SYNTAXERROR, \"RegEx are not supported in this version of Espruino\\n\");", " #else", "     JsVar *regex = jslGetTokenValueAsVar(lex);", "     size_t regexEnd = 0, regexLen = 0;", "     JsvStringIterator it;", "     jsvStringIteratorNew(&it, regex, 0);", "     while (jsvStringIteratorHasChar(&it)) {", "       regexLen++;", "       if (jsvStringIteratorGetChar(&it)=='/')", "         regexEnd = regexLen;", "       jsvStringIteratorNext(&it);", "     }", "     jsvStringIteratorFree(&it);", "     JsVar *flags = 0;", "     if (regexEnd < regexLen)", "       flags = jsvNewFromStringVar(regex, regexEnd, JSVAPPENDSTRINGVAR_MAXLENGTH);", "     JsVar *regexSource = jsvNewFromStringVar(regex, 1, regexEnd-2);", "     a = jswrap_regexp_constructor(regexSource, flags);", "     jsvUnLock3(regex, flags, regexSource);", " #endif", "     JSP_ASSERT_MATCH(LEX_REGEX);", "     return a;", "   } else if (lex->tk=='{') {", "     if (!jspCheckStackPosition()) return 0;", "     return jspeFactorObject();", "   } else if (lex->tk=='[') {", "     if (!jspCheckStackPosition()) return 0;", "     return jspeFactorArray();", "   } else if (lex->tk==LEX_R_FUNCTION) {", "     if (!jspCheckStackPosition()) return 0;", "     JSP_ASSERT_MATCH(LEX_R_FUNCTION);", "     return jspeFunctionDefinition(true);", " #ifndef SAVE_ON_FLASH", "   } else if (lex->tk==LEX_R_CLASS) {", "     if (!jspCheckStackPosition()) return 0;", "     JSP_ASSERT_MATCH(LEX_R_CLASS);", "     return jspeClassDefinition(true);", "   } else if (lex->tk==LEX_R_SUPER) {", "     JSP_ASSERT_MATCH(LEX_R_SUPER);", "     if (jsvIsObject(execInfo.thisVar)) {", "       JsVar *proto1 = jsvObjectGetChild(execInfo.thisVar, JSPARSE_INHERITS_VAR, 0);  ", "       JsVar *proto2 = jsvIsObject(proto1) ? jsvObjectGetChild(proto1, JSPARSE_INHERITS_VAR, 0) : 0;  ", "       jsvUnLock(proto1);", "       if (!proto2) {", "         jsExceptionHere(JSET_SYNTAXERROR, \"Calling 'super' outside of class\");", "         return 0;", "       }", "       if (lex->tk=='(') return proto2;  ", "       JsVar *proto3 = jsvIsFunction(proto2) ? jsvObjectGetChild(proto2, JSPARSE_PROTOTYPE_VAR, 0) : 0;", "       jsvUnLock(proto2);", "       return proto3;", "     } else if (jsvIsFunction(execInfo.thisVar)) {", "       JsVar *proto1 = jsvObjectGetChild(execInfo.thisVar, JSPARSE_PROTOTYPE_VAR, 0);", "       JsVar *proto2 = jsvIsObject(proto1) ? jsvObjectGetChild(proto1, JSPARSE_INHERITS_VAR, 0) : 0;", "       jsvUnLock(proto1);", "       if (!proto2) {", "         jsExceptionHere(JSET_SYNTAXERROR, \"Calling 'super' outside of class\");", "         return 0;", "       }", "       return proto2;", "     }", "     jsExceptionHere(JSET_SYNTAXERROR, \"Calling 'super' outside of class\");", "     return 0;", " #endif", "   } else if (lex->tk==LEX_R_THIS) {", "     JSP_ASSERT_MATCH(LEX_R_THIS);", "     return jsvLockAgain( execInfo.thisVar ? execInfo.thisVar : execInfo.root );", "   } else if (lex->tk==LEX_R_DELETE) {", "     if (!jspCheckStackPosition()) return 0;", "     return jspeFactorDelete();", "   } else if (lex->tk==LEX_R_TYPEOF) {", "     if (!jspCheckStackPosition()) return 0;", "     return jspeFactorTypeOf();", "   } else if (lex->tk==LEX_R_VOID) {", "     if (!jspCheckStackPosition()) return 0;", "     JSP_ASSERT_MATCH(LEX_R_VOID);", "     jsvUnLock(jspeUnaryExpression());", "     return 0;", "   }", "   JSP_MATCH(LEX_EOF);", "   jsExceptionHere(JSET_SYNTAXERROR, \"Unexpected end of Input\\n\");", "   return 0;", " }", " NO_INLINE JsVar *__jspePostfixExpression(JsVar *a) {", "   while (lex->tk==LEX_PLUSPLUS || lex->tk==LEX_MINUSMINUS) {", "     int op = lex->tk;", "     JSP_ASSERT_MATCH(op);", "     if (JSP_SHOULD_EXECUTE) {", "       JsVar *one = jsvNewFromInteger(1);", "       JsVar *oldValue = jsvAsNumberAndUnLock(jsvSkipName(a));  ", "       JsVar *res = jsvMathsOpSkipNames(oldValue, one, op==LEX_PLUSPLUS ? '+' : '-');", "       jsvUnLock(one);", "       jspReplaceWith(a, res);", "       jsvUnLock(res);", "       jsvUnLock(a);", "       a = oldValue;", "     }", "   }", "   return a;", " }", " NO_INLINE JsVar *jspePostfixExpression() {", "   JsVar *a;", "   if (lex->tk==LEX_PLUSPLUS || lex->tk==LEX_MINUSMINUS) {", "     int op = lex->tk;", "     JSP_ASSERT_MATCH(op);", "     a = jspePostfixExpression();", "     if (JSP_SHOULD_EXECUTE) {", "       JsVar *one = jsvNewFromInteger(1);", "       JsVar *res = jsvMathsOpSkipNames(a, one, op==LEX_PLUSPLUS ? '+' : '-');", "       jsvUnLock(one);", "       jspReplaceWith(a, res);", "       jsvUnLock(res);", "     }", "   } else", "     a = jspeFactorFunctionCall();", "   return __jspePostfixExpression(a);", " }", " NO_INLINE JsVar *jspeUnaryExpression() {", "   if (lex->tk=='!' || lex->tk=='~' || lex->tk=='-' || lex->tk=='+') {", "     short tk = lex->tk;", "     JSP_ASSERT_MATCH(tk);", "     if (!JSP_SHOULD_EXECUTE) {", "       return jspeUnaryExpression();", "     }", "     if (tk=='!') {  ", "       return jsvNewFromBool(!jsvGetBoolAndUnLock(jsvSkipNameAndUnLock(jspeUnaryExpression())));", "     } else if (tk=='~') {  ", "       return jsvNewFromInteger(~jsvGetIntegerAndUnLock(jsvSkipNameAndUnLock(jspeUnaryExpression())));", "     } else if (tk=='-') {  ", "       return jsvNegateAndUnLock(jspeUnaryExpression());  ", "     }  else if (tk=='+') {  ", "       JsVar *v = jsvSkipNameAndUnLock(jspeUnaryExpression());", "       JsVar *r = jsvAsNumber(v);  ", "       jsvUnLock(v);", "       return r;", "     }", "     assert(0);", "     return 0;", "   } else", "     return jspePostfixExpression();", " }", " unsigned int jspeGetBinaryExpressionPrecedence(int op) {", "   switch (op) {", "   case LEX_OROR: return 1; break;", "   case LEX_ANDAND: return 2; break;", "   case '|' : return 3; break;", "   case '^' : return 4; break;", "   case '&' : return 5; break;", "   case LEX_EQUAL:", "   case LEX_NEQUAL:", "   case LEX_TYPEEQUAL:", "   case LEX_NTYPEEQUAL: return 6;", "   case LEX_LEQUAL:", "   case LEX_GEQUAL:", "   case '<':", "   case '>':", "   case LEX_R_INSTANCEOF: return 7;", "   case LEX_R_IN: return (execInfo.execute&EXEC_FOR_INIT)?0:7;", "   case LEX_LSHIFT:", "   case LEX_RSHIFT:", "   case LEX_RSHIFTUNSIGNED: return 8;", "   case '+':", "   case '-': return 9;", "   case '*':", "   case '/':", "   case '%': return 10;", "   default: return 0;", "   }", " }", " NO_INLINE JsVar *__jspeBinaryExpression(JsVar *a, unsigned int lastPrecedence) {", "   unsigned int precedence = jspeGetBinaryExpressionPrecedence(lex->tk);", "   while (precedence && precedence>lastPrecedence) {", "     int op = lex->tk;", "     JSP_ASSERT_MATCH(op);", "     if (op==LEX_ANDAND || op==LEX_OROR) {", "       bool aValue = jsvGetBoolAndUnLock(jsvSkipName(a));", "       if ((!aValue && op==LEX_ANDAND) ||", "           (aValue && op==LEX_OROR)) {", "         JSP_SAVE_EXECUTE();", "         jspSetNoExecute();", "         jsvUnLock(__jspeBinaryExpression(jspeUnaryExpression(),precedence));", "         JSP_RESTORE_EXECUTE();", "       } else {", "         jsvUnLock(a);", "         a = __jspeBinaryExpression(jspeUnaryExpression(),precedence);", "       }", "     } else {  ", "       JsVar *b = __jspeBinaryExpression(jspeUnaryExpression(),precedence);", "       if (JSP_SHOULD_EXECUTE) {", "         if (op==LEX_R_IN) {", "           JsVar *av = jsvSkipName(a);  ", "           JsVar *bv = jsvSkipName(b);  ", "           if (jsvIsArray(bv) || jsvIsObject(bv)) {  ", "             av = jsvAsArrayIndexAndUnLock(av);", "             JsVar *varFound = jspGetVarNamedField( bv, av, true);", "             jsvUnLock(a);", "             a = jsvNewFromBool(varFound!=0);", "             jsvUnLock(varFound);", "           } else { ", "             jsExceptionHere(JSET_ERROR, \"Cannot use 'in' operator to search a %t\", bv);", "             jsvUnLock(a);", "             a = 0;", "           }", "           jsvUnLock2(av, bv);", "         } else if (op==LEX_R_INSTANCEOF) {", "           bool inst = false;", "           JsVar *av = jsvSkipName(a);", "           JsVar *bv = jsvSkipName(b);", "           if (!jsvIsFunction(bv)) {", "             jsExceptionHere(JSET_ERROR, \"Expecting a function on RHS in instanceof check, got %t\", bv);", "           } else {", "             if (jsvIsObject(av) || jsvIsFunction(av)) {", "               JsVar *bproto = jspGetNamedField(bv, JSPARSE_PROTOTYPE_VAR, false);", "               JsVar *proto = jsvObjectGetChild(av, JSPARSE_INHERITS_VAR, 0);", "               while (proto) {", "                 if (proto == bproto) inst=true;", "                 JsVar *childProto = jsvObjectGetChild(proto, JSPARSE_INHERITS_VAR, 0);", "                 jsvUnLock(proto);", "                 proto = childProto;", "               }", "               if (jspIsConstructor(bv, \"Object\")) inst = true;", "               jsvUnLock(bproto);", "             }", "             if (!inst) {", "               const char *name = jswGetBasicObjectName(av);", "               if (name) {", "                 inst = jspIsConstructor(bv, name);", "               }", "               if (!inst && (jsvIsArray(av) || jsvIsArrayBuffer(av)) &&", "                   jspIsConstructor(bv, \"Object\"))", "                 inst = true;", "             }", "           }", "           jsvUnLock3(av, bv, a);", "           a = jsvNewFromBool(inst);", "         } else {   ", "           JsVar *res = jsvMathsOpSkipNames(a, b, op);", "           jsvUnLock(a); a = res;", "         }", "       }", "       jsvUnLock(b);", "     }", "     precedence = jspeGetBinaryExpressionPrecedence(lex->tk);", "   }", "   return a;", " }", " JsVar *jspeBinaryExpression() {", "   return __jspeBinaryExpression(jspeUnaryExpression(),0);", " }", " NO_INLINE JsVar *__jspeConditionalExpression(JsVar *lhs) {", "   if (lex->tk=='?') {", "     JSP_ASSERT_MATCH('?');", "     if (!JSP_SHOULD_EXECUTE) {", "       jsvUnLock(jspeAssignmentExpression());", "       JSP_MATCH(':');", "       jsvUnLock(jspeAssignmentExpression());", "     } else {", "       bool first = jsvGetBoolAndUnLock(jsvSkipName(lhs));", "       jsvUnLock(lhs);", "       if (first) {", "         lhs = jspeAssignmentExpression();", "         JSP_MATCH(':');", "         JSP_SAVE_EXECUTE();", "         jspSetNoExecute();", "         jsvUnLock(jspeAssignmentExpression());", "         JSP_RESTORE_EXECUTE();", "       } else {", "         JSP_SAVE_EXECUTE();", "         jspSetNoExecute();", "         jsvUnLock(jspeAssignmentExpression());", "         JSP_RESTORE_EXECUTE();", "         JSP_MATCH(':');", "         lhs = jspeAssignmentExpression();", "       }", "     }", "   }", "   return lhs;", " }", " JsVar *jspeConditionalExpression() {", "   return __jspeConditionalExpression(jspeBinaryExpression());", " }", " NO_INLINE JsVar *__jspeAssignmentExpression(JsVar *lhs) {", "   if (lex->tk=='=' || lex->tk==LEX_PLUSEQUAL || lex->tk==LEX_MINUSEQUAL ||", "       lex->tk==LEX_MULEQUAL || lex->tk==LEX_DIVEQUAL || lex->tk==LEX_MODEQUAL ||", "       lex->tk==LEX_ANDEQUAL || lex->tk==LEX_OREQUAL ||", "       lex->tk==LEX_XOREQUAL || lex->tk==LEX_RSHIFTEQUAL ||", "       lex->tk==LEX_LSHIFTEQUAL || lex->tk==LEX_RSHIFTUNSIGNEDEQUAL) {", "     JsVar *rhs;", "     int op = lex->tk;", "     JSP_ASSERT_MATCH(op);", "     rhs = jspeAssignmentExpression();", "     rhs = jsvSkipNameAndUnLock(rhs);  ", "      if (JSP_SHOULD_EXECUTE && lhs) {", "        if (op=='=') {", "        if (!jsvGetRefs(lhs) && jsvIsName(lhs)) {", "          if (!jsvIsArrayBufferName(lhs) && !jsvIsNewChild(lhs))", "            jsvAddName(execInfo.root, lhs);", "        }", "        jspReplaceWith(lhs, rhs);", "         jspReplaceWithOrAddToRoot(lhs, rhs);", "        } else {", "          if (op==LEX_PLUSEQUAL) op='+';", "          else if (op==LEX_MINUSEQUAL) op='-';", "         else if (op==LEX_MULEQUAL) op='*';", "         else if (op==LEX_DIVEQUAL) op='/';", "         else if (op==LEX_MODEQUAL) op='%';", "         else if (op==LEX_ANDEQUAL) op='&';", "         else if (op==LEX_OREQUAL) op='|';", "         else if (op==LEX_XOREQUAL) op='^';", "         else if (op==LEX_RSHIFTEQUAL) op=LEX_RSHIFT;", "         else if (op==LEX_LSHIFTEQUAL) op=LEX_LSHIFT;", "         else if (op==LEX_RSHIFTUNSIGNEDEQUAL) op=LEX_RSHIFTUNSIGNED;", "         if (op=='+' && jsvIsName(lhs)) {", "           JsVar *currentValue = jsvSkipName(lhs);", "           if (jsvIsString(currentValue) && !jsvIsFlatString(currentValue) && jsvGetRefs(currentValue)==1 && rhs!=currentValue) {", "             JsVar *str = jsvAsString(rhs, false);", "             jsvAppendStringVarComplete(currentValue, str);", "             jsvUnLock(str);", "             op = 0;", "           }", "           jsvUnLock(currentValue);", "         }", "         if (op) {", "           JsVar *res = jsvMathsOpSkipNames(lhs,rhs,op);", "           jspReplaceWith(lhs, res);", "           jsvUnLock(res);", "         }", "       }", "     }", "     jsvUnLock(rhs);", "   }", "   return lhs;", " }", " JsVar *jspeAssignmentExpression() {", "   return __jspeAssignmentExpression(jspeConditionalExpression());", " }", " NO_INLINE JsVar *jspeExpression() {", "   while (!JSP_SHOULDNT_PARSE) {", "     JsVar *a = jspeAssignmentExpression();", "     if (lex->tk!=',') return a;", "     jsvCheckReferenceError(a);", "     jsvUnLock(a);", "     JSP_ASSERT_MATCH(',');", "   }", "   return 0;", " }", " NO_INLINE void jspeBlockNoBrackets() {", "   if (JSP_SHOULD_EXECUTE) {", "     while (lex->tk && lex->tk!='}') {", "       JsVar *a = jspeStatement();", "       jsvCheckReferenceError(a);", "       jsvUnLock(a);", "       if (JSP_HAS_ERROR) {", "         if (lex && !(execInfo.execute&EXEC_ERROR_LINE_REPORTED)) {", "           execInfo.execute = (JsExecFlags)(execInfo.execute | EXEC_ERROR_LINE_REPORTED);", "           JsVar *stackTrace = jsvObjectGetChild(execInfo.hiddenRoot, JSPARSE_STACKTRACE_VAR, JSV_STRING_0);", "           if (stackTrace) {", "             jsvAppendPrintf(stackTrace, \"at \");", "             jspAppendStackTrace(stackTrace);", "             jsvUnLock(stackTrace);", "           }", "         }", "       }", "       if (JSP_SHOULDNT_PARSE)", "         return;", "     }", "   } else {", "     int brackets = 0;", "     while (lex->tk && (brackets || lex->tk != '}')) {", "       if (lex->tk == '{') brackets++;", "       if (lex->tk == '}') brackets--;", "       JSP_ASSERT_MATCH(lex->tk);", "     }", "   }", "   return;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int start_decoder(vorb *f)", " {", "    uint8 header[6], x,y;", "    int len,i,j,k, max_submaps = 0;", "    int longest_floorlist=0;", "    if (!start_page(f))                              return FALSE;", "    if (!(f->page_flag & PAGEFLAG_first_page))       return error(f, VORBIS_invalid_first_page);", "    if (f->page_flag & PAGEFLAG_last_page)           return error(f, VORBIS_invalid_first_page);", "    if (f->page_flag & PAGEFLAG_continued_packet)    return error(f, VORBIS_invalid_first_page);", "    if (f->segment_count != 1)                       return error(f, VORBIS_invalid_first_page);", "    if (f->segments[0] != 30) {", "       if (f->segments[0] == 64 &&", "           getn(f, header, 6) &&", "           header[0] == 'f' &&", "           header[1] == 'i' &&", "           header[2] == 's' &&", "           header[3] == 'h' &&", "           header[4] == 'e' &&", "           header[5] == 'a' &&", "           get8(f)   == 'd' &&", "           get8(f)   == '\\0')                        return error(f, VORBIS_ogg_skeleton_not_supported);", "       else", "                                                     return error(f, VORBIS_invalid_first_page);", "    }", "    if (get8(f) != VORBIS_packet_id)                 return error(f, VORBIS_invalid_first_page);", "    if (!getn(f, header, 6))                         return error(f, VORBIS_unexpected_eof);", "    if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_first_page);", "    if (get32(f) != 0)                               return error(f, VORBIS_invalid_first_page);", "    f->channels = get8(f); if (!f->channels)         return error(f, VORBIS_invalid_first_page);", "    if (f->channels > STB_VORBIS_MAX_CHANNELS)       return error(f, VORBIS_too_many_channels);", "    f->sample_rate = get32(f); if (!f->sample_rate)  return error(f, VORBIS_invalid_first_page);", "    get32(f);  ", "    get32(f);  ", "    get32(f);  ", "    x = get8(f);", "    {", "       int log0,log1;", "       log0 = x & 15;", "       log1 = x >> 4;", "       f->blocksize_0 = 1 << log0;", "       f->blocksize_1 = 1 << log1;", "       if (log0 < 6 || log0 > 13)                       return error(f, VORBIS_invalid_setup);", "       if (log1 < 6 || log1 > 13)                       return error(f, VORBIS_invalid_setup);", "       if (log0 > log1)                                 return error(f, VORBIS_invalid_setup);", "    }", "    x = get8(f);", "    if (!(x & 1))                                    return error(f, VORBIS_invalid_first_page);", "    if (!start_page(f))                              return FALSE;", "    if (!start_packet(f))                            return FALSE;", "    do {", "       len = next_segment(f);", "       skip(f, len);", "       f->bytes_in_seg = 0;", "    } while (len);", "    if (!start_packet(f))                            return FALSE;", "    #ifndef STB_VORBIS_NO_PUSHDATA_API", "    if (IS_PUSH_MODE(f)) {", "       if (!is_whole_packet_present(f, TRUE)) {", "          if (f->error == VORBIS_invalid_stream)", "             f->error = VORBIS_invalid_setup;", "          return FALSE;", "       }", "    }", "    #endif", "    crc32_init();  ", "    if (get8_packet(f) != VORBIS_packet_setup)       return error(f, VORBIS_invalid_setup);", "    for (i=0; i < 6; ++i) header[i] = get8_packet(f);", "    if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_setup);", "    f->codebook_count = get_bits(f,8) + 1;", "    f->codebooks = (Codebook *) setup_malloc(f, sizeof(*f->codebooks) * f->codebook_count);", "    if (f->codebooks == NULL)                        return error(f, VORBIS_outofmem);", "    memset(f->codebooks, 0, sizeof(*f->codebooks) * f->codebook_count);", "    for (i=0; i < f->codebook_count; ++i) {", "       uint32 *values;", "       int ordered, sorted_count;", "       int total=0;", "       uint8 *lengths;", "       Codebook *c = f->codebooks+i;", "       CHECK(f);", "       x = get_bits(f, 8); if (x != 0x42)            return error(f, VORBIS_invalid_setup);", "       x = get_bits(f, 8); if (x != 0x43)            return error(f, VORBIS_invalid_setup);", "       x = get_bits(f, 8); if (x != 0x56)            return error(f, VORBIS_invalid_setup);", "       x = get_bits(f, 8);", "       c->dimensions = (get_bits(f, 8)<<8) + x;", "       x = get_bits(f, 8);", "       y = get_bits(f, 8);", "       c->entries = (get_bits(f, 8)<<16) + (y<<8) + x;", "       ordered = get_bits(f,1);", "       c->sparse = ordered ? 0 : get_bits(f,1);", "       if (c->dimensions == 0 && c->entries != 0)    return error(f, VORBIS_invalid_setup);", "       if (c->sparse)", "          lengths = (uint8 *) setup_temp_malloc(f, c->entries);", "       else", "          lengths = c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);", "       if (!lengths) return error(f, VORBIS_outofmem);", "       if (ordered) {", "          int current_entry = 0;", "          int current_length = get_bits(f,5) + 1;", "           while (current_entry < c->entries) {", "              int limit = c->entries - current_entry;", "              int n = get_bits(f, ilog(limit));", "             if (current_length >= 32) return error(f, VORBIS_invalid_setup);", "              if (current_entry + n > (int) c->entries) { return error(f, VORBIS_invalid_setup); }", "              memset(lengths + current_entry, current_length, n);", "              current_entry += n;", "             ++current_length;", "          }", "       } else {", "          for (j=0; j < c->entries; ++j) {", "             int present = c->sparse ? get_bits(f,1) : 1;", "             if (present) {", "                lengths[j] = get_bits(f, 5) + 1;", "                ++total;", "                if (lengths[j] == 32)", "                   return error(f, VORBIS_invalid_setup);", "             } else {", "                lengths[j] = NO_CODE;", "             }", "          }", "       }", "       if (c->sparse && total >= c->entries >> 2) {", "          if (c->entries > (int) f->setup_temp_memory_required)", "             f->setup_temp_memory_required = c->entries;", "          c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);", "          if (c->codeword_lengths == NULL) return error(f, VORBIS_outofmem);", "          memcpy(c->codeword_lengths, lengths, c->entries);", "          setup_temp_free(f, lengths, c->entries);  ", "          lengths = c->codeword_lengths;", "          c->sparse = 0;", "       }", "       if (c->sparse) {", "          sorted_count = total;", "       } else {", "          sorted_count = 0;", "          #ifndef STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH", "          for (j=0; j < c->entries; ++j)", "             if (lengths[j] > STB_VORBIS_FAST_HUFFMAN_LENGTH && lengths[j] != NO_CODE)", "                ++sorted_count;", "          #endif", "       }", "       c->sorted_entries = sorted_count;", "       values = NULL;", "       CHECK(f);", "       if (!c->sparse) {", "          c->codewords = (uint32 *) setup_malloc(f, sizeof(c->codewords[0]) * c->entries);", "          if (!c->codewords)                  return error(f, VORBIS_outofmem);", "       } else {", "          unsigned int size;", "          if (c->sorted_entries) {", "             c->codeword_lengths = (uint8 *) setup_malloc(f, c->sorted_entries);", "             if (!c->codeword_lengths)           return error(f, VORBIS_outofmem);", "             c->codewords = (uint32 *) setup_temp_malloc(f, sizeof(*c->codewords) * c->sorted_entries);", "             if (!c->codewords)                  return error(f, VORBIS_outofmem);", "             values = (uint32 *) setup_temp_malloc(f, sizeof(*values) * c->sorted_entries);", "             if (!values)                        return error(f, VORBIS_outofmem);", "          }", "          size = c->entries + (sizeof(*c->codewords) + sizeof(*values)) * c->sorted_entries;", "          if (size > f->setup_temp_memory_required)", "             f->setup_temp_memory_required = size;", "       }", "       if (!compute_codewords(c, lengths, c->entries, values)) {", "          if (c->sparse) setup_temp_free(f, values, 0);", "          return error(f, VORBIS_invalid_setup);", "       }", "       if (c->sorted_entries) {", "          c->sorted_codewords = (uint32 *) setup_malloc(f, sizeof(*c->sorted_codewords) * (c->sorted_entries+1));", "          if (c->sorted_codewords == NULL) return error(f, VORBIS_outofmem);", "          c->sorted_values    = ( int   *) setup_malloc(f, sizeof(*c->sorted_values   ) * (c->sorted_entries+1));", "          if (c->sorted_values == NULL) return error(f, VORBIS_outofmem);", "          ++c->sorted_values;", "          c->sorted_values[-1] = -1;", "          compute_sorted_huffman(c, lengths, values);", "       }", "       if (c->sparse) {", "          setup_temp_free(f, values, sizeof(*values)*c->sorted_entries);", "          setup_temp_free(f, c->codewords, sizeof(*c->codewords)*c->sorted_entries);", "          setup_temp_free(f, lengths, c->entries);", "          c->codewords = NULL;", "       }", "       compute_accelerated_huffman(c);", "       CHECK(f);", "       c->lookup_type = get_bits(f, 4);", "       if (c->lookup_type > 2) return error(f, VORBIS_invalid_setup);", "       if (c->lookup_type > 0) {", "          uint16 *mults;", "          c->minimum_value = float32_unpack(get_bits(f, 32));", "          c->delta_value = float32_unpack(get_bits(f, 32));", "           c->value_bits = get_bits(f, 4)+1;", "           c->sequence_p = get_bits(f,1);", "           if (c->lookup_type == 1) {", "            c->lookup_values = lookup1_values(c->entries, c->dimensions);", "             int values = lookup1_values(c->entries, c->dimensions);", "             if (values < 0) return error(f, VORBIS_invalid_setup);", "             c->lookup_values = (uint32) values;", "           } else {", "              c->lookup_values = c->entries * c->dimensions;", "           }", "          if (c->lookup_values == 0) return error(f, VORBIS_invalid_setup);", "          mults = (uint16 *) setup_temp_malloc(f, sizeof(mults[0]) * c->lookup_values);", "          if (mults == NULL) return error(f, VORBIS_outofmem);", "          for (j=0; j < (int) c->lookup_values; ++j) {", "             int q = get_bits(f, c->value_bits);", "             if (q == EOP) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_invalid_setup); }", "             mults[j] = q;", "          }", " #ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK", "          if (c->lookup_type == 1) {", "             int len, sparse = c->sparse;", "             float last=0;", "             if (sparse) {", "                if (c->sorted_entries == 0) goto skip;", "                c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->sorted_entries * c->dimensions);", "             } else", "                c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->entries        * c->dimensions);", "             if (c->multiplicands == NULL) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }", "             len = sparse ? c->sorted_entries : c->entries;", "             for (j=0; j < len; ++j) {", "                unsigned int z = sparse ? c->sorted_values[j] : j;", "                unsigned int div=1;", "                for (k=0; k < c->dimensions; ++k) {", "                   int off = (z / div) % c->lookup_values;", "                   float val = mults[off];", "                   val = mults[off]*c->delta_value + c->minimum_value + last;", "                   c->multiplicands[j*c->dimensions + k] = val;", "                   if (c->sequence_p)", "                      last = val;", "                   if (k+1 < c->dimensions) {", "                      if (div > UINT_MAX / (unsigned int) c->lookup_values) {", "                         setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values);", "                         return error(f, VORBIS_invalid_setup);", "                      }", "                      div *= c->lookup_values;", "                   }", "                }", "             }", "             c->lookup_type = 2;", "          }", "          else", " #endif", "          {", "             float last=0;", "             CHECK(f);", "             c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->lookup_values);", "             if (c->multiplicands == NULL) { setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }", "             for (j=0; j < (int) c->lookup_values; ++j) {", "                float val = mults[j] * c->delta_value + c->minimum_value + last;", "                c->multiplicands[j] = val;", "                if (c->sequence_p)", "                   last = val;", "             }", "          }", " #ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK", "         skip:;", " #endif", "          setup_temp_free(f, mults, sizeof(mults[0])*c->lookup_values);", "          CHECK(f);", "       }", "       CHECK(f);", "    }", "    x = get_bits(f, 6) + 1;", "    for (i=0; i < x; ++i) {", "       uint32 z = get_bits(f, 16);", "       if (z != 0) return error(f, VORBIS_invalid_setup);", "    }", "    f->floor_count = get_bits(f, 6)+1;", "    f->floor_config = (Floor *)  setup_malloc(f, f->floor_count * sizeof(*f->floor_config));", "    if (f->floor_config == NULL) return error(f, VORBIS_outofmem);", "    for (i=0; i < f->floor_count; ++i) {", "       f->floor_types[i] = get_bits(f, 16);", "       if (f->floor_types[i] > 1) return error(f, VORBIS_invalid_setup);", "       if (f->floor_types[i] == 0) {", "          Floor0 *g = &f->floor_config[i].floor0;", "          g->order = get_bits(f,8);", "          g->rate = get_bits(f,16);", "          g->bark_map_size = get_bits(f,16);", "          g->amplitude_bits = get_bits(f,6);", "          g->amplitude_offset = get_bits(f,8);", "          g->number_of_books = get_bits(f,4) + 1;", "          for (j=0; j < g->number_of_books; ++j)", "             g->book_list[j] = get_bits(f,8);", "          return error(f, VORBIS_feature_not_supported);", "       } else {", "          stbv__floor_ordering p[31*8+2];", "          Floor1 *g = &f->floor_config[i].floor1;", "          int max_class = -1; ", "          g->partitions = get_bits(f, 5);", "          for (j=0; j < g->partitions; ++j) {", "             g->partition_class_list[j] = get_bits(f, 4);", "             if (g->partition_class_list[j] > max_class)", "                max_class = g->partition_class_list[j];", "          }", "          for (j=0; j <= max_class; ++j) {", "             g->class_dimensions[j] = get_bits(f, 3)+1;", "             g->class_subclasses[j] = get_bits(f, 2);", "             if (g->class_subclasses[j]) {", "                g->class_masterbooks[j] = get_bits(f, 8);", "                if (g->class_masterbooks[j] >= f->codebook_count) return error(f, VORBIS_invalid_setup);", "             }", "             for (k=0; k < 1 << g->class_subclasses[j]; ++k) {", "                g->subclass_books[j][k] = get_bits(f,8)-1;", "                if (g->subclass_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);", "             }", "          }", "          g->floor1_multiplier = get_bits(f,2)+1;", "          g->rangebits = get_bits(f,4);", "          g->Xlist[0] = 0;", "          g->Xlist[1] = 1 << g->rangebits;", "          g->values = 2;", "          for (j=0; j < g->partitions; ++j) {", "             int c = g->partition_class_list[j];", "             for (k=0; k < g->class_dimensions[c]; ++k) {", "                g->Xlist[g->values] = get_bits(f, g->rangebits);", "                ++g->values;", "             }", "          }", "          for (j=0; j < g->values; ++j) {", "             p[j].x = g->Xlist[j];", "              p[j].id = j;", "           }", "           qsort(p, g->values, sizeof(p[0]), point_compare);", "          for (j=0; j < g->values-1; ++j)", "             if (p[j].x == p[j+1].x)", "                return error(f, VORBIS_invalid_setup);", "           for (j=0; j < g->values; ++j)", "              g->sorted_order[j] = (uint8) p[j].id;", "          for (j=2; j < g->values; ++j) {", "             int low,hi;", "             neighbors(g->Xlist, j, &low,&hi);", "             g->neighbors[j][0] = low;", "             g->neighbors[j][1] = hi;", "          }", "          if (g->values > longest_floorlist)", "             longest_floorlist = g->values;", "       }", "    }", "    f->residue_count = get_bits(f, 6)+1;", "    f->residue_config = (Residue *) setup_malloc(f, f->residue_count * sizeof(f->residue_config[0]));", "    if (f->residue_config == NULL) return error(f, VORBIS_outofmem);", "    memset(f->residue_config, 0, f->residue_count * sizeof(f->residue_config[0]));", "    for (i=0; i < f->residue_count; ++i) {", "       uint8 residue_cascade[64];", "       Residue *r = f->residue_config+i;", "       f->residue_types[i] = get_bits(f, 16);", "       if (f->residue_types[i] > 2) return error(f, VORBIS_invalid_setup);", "       r->begin = get_bits(f, 24);", "       r->end = get_bits(f, 24);", "       if (r->end < r->begin) return error(f, VORBIS_invalid_setup);", "       r->part_size = get_bits(f,24)+1;", "       r->classifications = get_bits(f,6)+1;", "       r->classbook = get_bits(f,8);", "       if (r->classbook >= f->codebook_count) return error(f, VORBIS_invalid_setup);", "       for (j=0; j < r->classifications; ++j) {", "          uint8 high_bits=0;", "          uint8 low_bits=get_bits(f,3);", "          if (get_bits(f,1))", "             high_bits = get_bits(f,5);", "          residue_cascade[j] = high_bits*8 + low_bits;", "       }", "       r->residue_books = (short (*)[8]) setup_malloc(f, sizeof(r->residue_books[0]) * r->classifications);", "       if (r->residue_books == NULL) return error(f, VORBIS_outofmem);", "       for (j=0; j < r->classifications; ++j) {", "          for (k=0; k < 8; ++k) {", "             if (residue_cascade[j] & (1 << k)) {", "                r->residue_books[j][k] = get_bits(f, 8);", "                if (r->residue_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);", "             } else {", "                r->residue_books[j][k] = -1;", "             }", "          }", "       }", "       r->classdata = (uint8 **) setup_malloc(f, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);", "       if (!r->classdata) return error(f, VORBIS_outofmem);", "       memset(r->classdata, 0, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);", "       for (j=0; j < f->codebooks[r->classbook].entries; ++j) {", "          int classwords = f->codebooks[r->classbook].dimensions;", "          int temp = j;", "          r->classdata[j] = (uint8 *) setup_malloc(f, sizeof(r->classdata[j][0]) * classwords);", "          if (r->classdata[j] == NULL) return error(f, VORBIS_outofmem);", "          for (k=classwords-1; k >= 0; --k) {", "             r->classdata[j][k] = temp % r->classifications;", "             temp /= r->classifications;", "          }", "       }", "    }", "    f->mapping_count = get_bits(f,6)+1;", "    f->mapping = (Mapping *) setup_malloc(f, f->mapping_count * sizeof(*f->mapping));", "    if (f->mapping == NULL) return error(f, VORBIS_outofmem);", "    memset(f->mapping, 0, f->mapping_count * sizeof(*f->mapping));", "    for (i=0; i < f->mapping_count; ++i) {", "       Mapping *m = f->mapping + i;      ", "       int mapping_type = get_bits(f,16);", "       if (mapping_type != 0) return error(f, VORBIS_invalid_setup);", "       m->chan = (MappingChannel *) setup_malloc(f, f->channels * sizeof(*m->chan));", "       if (m->chan == NULL) return error(f, VORBIS_outofmem);", "       if (get_bits(f,1))", "          m->submaps = get_bits(f,4)+1;", "       else", "          m->submaps = 1;", "       if (m->submaps > max_submaps)", "           max_submaps = m->submaps;", "        if (get_bits(f,1)) {", "           m->coupling_steps = get_bits(f,8)+1;", "          if (m->coupling_steps > f->channels) return error(f, VORBIS_invalid_setup);", "           for (k=0; k < m->coupling_steps; ++k) {", "              m->chan[k].magnitude = get_bits(f, ilog(f->channels-1));", "              m->chan[k].angle = get_bits(f, ilog(f->channels-1));", "             if (m->chan[k].magnitude >= f->channels)        return error(f, VORBIS_invalid_setup);", "             if (m->chan[k].angle     >= f->channels)        return error(f, VORBIS_invalid_setup);", "             if (m->chan[k].magnitude == m->chan[k].angle)   return error(f, VORBIS_invalid_setup);", "          }", "       } else", "          m->coupling_steps = 0;", "       if (get_bits(f,2)) return error(f, VORBIS_invalid_setup);", "       if (m->submaps > 1) {", "          for (j=0; j < f->channels; ++j) {", "             m->chan[j].mux = get_bits(f, 4);", "             if (m->chan[j].mux >= m->submaps)                return error(f, VORBIS_invalid_setup);", "          }", "       } else", "          for (j=0; j < f->channels; ++j)", "             m->chan[j].mux = 0;", "       for (j=0; j < m->submaps; ++j) {", "          get_bits(f,8);  ", "          m->submap_floor[j] = get_bits(f,8);", "          m->submap_residue[j] = get_bits(f,8);", "          if (m->submap_floor[j] >= f->floor_count)      return error(f, VORBIS_invalid_setup);", "          if (m->submap_residue[j] >= f->residue_count)  return error(f, VORBIS_invalid_setup);", "       }", "    }", "    f->mode_count = get_bits(f, 6)+1;", "    for (i=0; i < f->mode_count; ++i) {", "       Mode *m = f->mode_config+i;", "       m->blockflag = get_bits(f,1);", "       m->windowtype = get_bits(f,16);", "       m->transformtype = get_bits(f,16);", "       m->mapping = get_bits(f,8);", "       if (m->windowtype != 0)                 return error(f, VORBIS_invalid_setup);", "       if (m->transformtype != 0)              return error(f, VORBIS_invalid_setup);", "       if (m->mapping >= f->mapping_count)     return error(f, VORBIS_invalid_setup);", "    }", "    flush_packet(f);", "    f->previous_length = 0;", "    for (i=0; i < f->channels; ++i) {", "       f->channel_buffers[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1);", "       f->previous_window[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2);", "       f->finalY[i]          = (int16 *) setup_malloc(f, sizeof(int16) * longest_floorlist);", "       if (f->channel_buffers[i] == NULL || f->previous_window[i] == NULL || f->finalY[i] == NULL) return error(f, VORBIS_outofmem);", "       memset(f->channel_buffers[i], 0, sizeof(float) * f->blocksize_1);", "       #ifdef STB_VORBIS_NO_DEFER_FLOOR", "       f->floor_buffers[i]   = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2);", "       if (f->floor_buffers[i] == NULL) return error(f, VORBIS_outofmem);", "       #endif", "    }", "    if (!init_blocksize(f, 0, f->blocksize_0)) return FALSE;", "    if (!init_blocksize(f, 1, f->blocksize_1)) return FALSE;", "    f->blocksize[0] = f->blocksize_0;", "    f->blocksize[1] = f->blocksize_1;", " #ifdef STB_VORBIS_DIVIDE_TABLE", "    if (integer_divide_table[1][1]==0)", "       for (i=0; i < DIVTAB_NUMER; ++i)", "          for (j=1; j < DIVTAB_DENOM; ++j)", "             integer_divide_table[i][j] = i / j;", " #endif", "    {", "       uint32 imdct_mem = (f->blocksize_1 * sizeof(float) >> 1);", "       uint32 classify_mem;", "       int i,max_part_read=0;", "       for (i=0; i < f->residue_count; ++i) {", "          Residue *r = f->residue_config + i;", "          unsigned int actual_size = f->blocksize_1 / 2;", "          unsigned int limit_r_begin = r->begin < actual_size ? r->begin : actual_size;", "          unsigned int limit_r_end   = r->end   < actual_size ? r->end   : actual_size;", "          int n_read = limit_r_end - limit_r_begin;", "          int part_read = n_read / r->part_size;", "          if (part_read > max_part_read)", "             max_part_read = part_read;", "       }", "       #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE", "       classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(uint8 *));", "       #else", "       classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(int *));", "       #endif", "       f->temp_memory_required = classify_mem;", "       if (imdct_mem > f->temp_memory_required)", "          f->temp_memory_required = imdct_mem;", "    }", "    f->first_decode = TRUE;", "    if (f->alloc.alloc_buffer) {", "       assert(f->temp_offset == f->alloc.alloc_buffer_length_in_bytes);", "       if (f->setup_offset + sizeof(*f) + f->temp_memory_required > (unsigned) f->temp_offset)", "          return error(f, VORBIS_outofmem);", "    }", "    f->first_audio_page_offset = stb_vorbis_get_file_offset(f);", "    return TRUE;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int read_data(void *opaque, uint8_t *buf, int buf_size)", " {", "     struct playlist *v = opaque;", "      HLSContext *c = v->parent->priv_data;", "      int ret, i;", "      int just_opened = 0;", "     int reload_count = 0;", "  restart:", "      if (!v->needed)", "         return AVERROR_EOF;", "     if (!v->input) {", "         int64_t reload_interval;", "         struct segment *seg;", "         if (v->ctx && v->ctx->nb_streams) {", "             v->needed = 0;", "             for (i = 0; i < v->n_main_streams; i++) {", "                 if (v->main_streams[i]->discard < AVDISCARD_ALL) {", "                     v->needed = 1;", "                     break;", "                 }", "             }", "         }", "         if (!v->needed) {", "             av_log(v->parent, AV_LOG_INFO, \"No longer receiving playlist %d\\n\",", "                 v->index);", "             return AVERROR_EOF;", "         }", "          reload_interval = default_reload_interval(v);", "  reload:", "         reload_count++;", "         if (reload_count > c->max_reload)", "             return AVERROR_EOF;", "          if (!v->finished &&", "              av_gettime_relative() - v->last_load_time >= reload_interval) {", "              if ((ret = parse_playlist(c, v->url, v, NULL)) < 0) {", "                 av_log(v->parent, AV_LOG_WARNING, \"Failed to reload playlist %d\\n\",", "                        v->index);", "                 return ret;", "             }", "             reload_interval = v->target_duration / 2;", "         }", "         if (v->cur_seq_no < v->start_seq_no) {", "             av_log(NULL, AV_LOG_WARNING,", "                    \"skipping %d segments ahead, expired from playlists\\n\",", "                    v->start_seq_no - v->cur_seq_no);", "             v->cur_seq_no = v->start_seq_no;", "         }", "         if (v->cur_seq_no >= v->start_seq_no + v->n_segments) {", "             if (v->finished)", "                 return AVERROR_EOF;", "             while (av_gettime_relative() - v->last_load_time < reload_interval) {", "                 if (ff_check_interrupt(c->interrupt_callback))", "                     return AVERROR_EXIT;", "                 av_usleep(100*1000);", "             }", "             goto reload;", "         }", "         seg = current_segment(v);", "         ret = update_init_section(v, seg);", "         if (ret)", "             return ret;", "         ret = open_input(c, v, seg);", "         if (ret < 0) {", "             if (ff_check_interrupt(c->interrupt_callback))", "                 return AVERROR_EXIT;", "             av_log(v->parent, AV_LOG_WARNING, \"Failed to open segment of playlist %d\\n\",", "                    v->index);", "             v->cur_seq_no += 1;", "             goto reload;", "         }", "         just_opened = 1;", "     }", "     if (v->init_sec_buf_read_offset < v->init_sec_data_len) {", "         int copy_size = FFMIN(v->init_sec_data_len - v->init_sec_buf_read_offset, buf_size);", "         memcpy(buf, v->init_sec_buf, copy_size);", "         v->init_sec_buf_read_offset += copy_size;", "         return copy_size;", "     }", "     ret = read_from_url(v, current_segment(v), buf, buf_size, READ_NORMAL);", "     if (ret > 0) {", "         if (just_opened && v->is_id3_timestamped != 0) {", "             intercept_id3(v, buf, buf_size, &ret);", "         }", "         return ret;", "     }", "     ff_format_io_close(v->parent, &v->input);", "     v->cur_seq_no++;", "     c->cur_seq_no = v->cur_seq_no;", "     goto restart;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" rar_read_ahead(struct archive_read *a, size_t min, ssize_t *avail)", " {", "   struct rar *rar = (struct rar *)(a->format->data);", "   const void *h = __archive_read_ahead(a, min, avail);", "   int ret;", "   if (avail)", "   {", "     if (a->archive.read_data_is_posix_read && *avail > (ssize_t)a->archive.read_data_requested)", "       *avail = a->archive.read_data_requested;", "     if (*avail > rar->bytes_remaining)", "       *avail = (ssize_t)rar->bytes_remaining;", "     if (*avail < 0)", "       return NULL;", "      else if (*avail == 0 && rar->main_flags & MHD_VOLUME &&", "        rar->file_flags & FHD_SPLIT_AFTER)", "      {", "       rar->filename_must_match = 1;", "        ret = archive_read_format_rar_read_header(a, a->entry);", "        if (ret == (ARCHIVE_EOF))", "        {", "          rar->has_endarc_header = 1;", "          ret = archive_read_format_rar_read_header(a, a->entry);", "        }", "       rar->filename_must_match = 0;", "        if (ret != (ARCHIVE_OK))", "          return NULL;", "        return rar_read_ahead(a, min, avail);", "     }", "   }", "   return h;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int filter_frame(AVFilterLink *inlink, AVFrame *in)", " {", "     DelogoContext *s = inlink->dst->priv;", "     AVFilterLink *outlink = inlink->dst->outputs[0];", "     const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);", "     AVFrame *out;", "     int hsub0 = desc->log2_chroma_w;", "     int vsub0 = desc->log2_chroma_h;", "     int direct = 0;", "     int plane;", "     AVRational sar;", "     if (av_frame_is_writable(in)) {", "         direct = 1;", "         out = in;", "     } else {", "         out = ff_get_video_buffer(outlink, outlink->w, outlink->h);", "         if (!out) {", "             av_frame_free(&in);", "             return AVERROR(ENOMEM);", "         }", "         av_frame_copy_props(out, in);", "     }", "     sar = in->sample_aspect_ratio;", "      if (!sar.num)", "          sar.num = sar.den = 1;", "    for (plane = 0; plane < 4 && in->data[plane]; plane++) {", "     for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++) {", "          int hsub = plane == 1 || plane == 2 ? hsub0 : 0;", "          int vsub = plane == 1 || plane == 2 ? vsub0 : 0;", "         apply_delogo(out->data[plane], out->linesize[plane],", "                      in ->data[plane], in ->linesize[plane],", "                      FF_CEIL_RSHIFT(inlink->w, hsub),", "                      FF_CEIL_RSHIFT(inlink->h, vsub),", "                      sar, s->x>>hsub, s->y>>vsub,", "                      FF_CEIL_RSHIFT(s->w + (s->x & ((1<<hsub)-1)), hsub),", "                      FF_CEIL_RSHIFT(s->h + (s->y & ((1<<vsub)-1)), vsub),", "                      s->band>>FFMIN(hsub, vsub),", "                      s->show, direct);", "     }", "     if (!direct)", "         av_frame_free(&in);", "     return ff_filter_frame(outlink, out);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" init_rc(void)", " {", "     int i;", "     struct stat st;", "     FILE *f;", "     if (rc_dir != NULL)", " \tgoto open_rc;", "     rc_dir = expandPath(RC_DIR);", "     i = strlen(rc_dir);", "     if (i > 1 && rc_dir[i - 1] == '/')", " \trc_dir[i - 1] = '\\0';", " #ifdef USE_M17N", "     display_charset_str = wc_get_ces_list();", "     document_charset_str = display_charset_str;", "     system_charset_str = display_charset_str;", " #endif", "     if (stat(rc_dir, &st) < 0) {", " \tif (errno == ENOENT) {\t ", " \t    if (do_mkdir(rc_dir, 0700) < 0) {", " \t\tgoto rc_dir_err;", " \t    }", " \t    else {", " \t\tstat(rc_dir, &st);", " \t    }", " \t}", " \telse {", " \t    goto rc_dir_err;", " \t}", "     }", "     if (!S_ISDIR(st.st_mode)) {", " \tgoto rc_dir_err;", "     }", "     if (!(st.st_mode & S_IWUSR)) {", " \tgoto rc_dir_err;", "     }", "     no_rc_dir = FALSE;", "     tmp_dir = rc_dir;", "     if (config_file == NULL)", " \tconfig_file = rcFile(CONFIG_FILE);", "     create_option_search_table();", "   open_rc:", "     if ((f = fopen(etcFile(W3MCONFIG), \"rt\")) != NULL) {", " \tinterpret_rc(f);", " \tfclose(f);", "     }", "     if ((f = fopen(confFile(CONFIG_FILE), \"rt\")) != NULL) {", " \tinterpret_rc(f);", " \tfclose(f);", "     }", "     if (config_file && (f = fopen(config_file, \"rt\")) != NULL) {", " \tinterpret_rc(f);", " \tfclose(f);", "     }", "     return;", "   rc_dir_err:", "     no_rc_dir = TRUE;", "     if (((tmp_dir = getenv(\"TMPDIR\")) == NULL || *tmp_dir == '\\0') &&", "  \t((tmp_dir = getenv(\"TMP\")) == NULL || *tmp_dir == '\\0') &&", "  \t((tmp_dir = getenv(\"TEMP\")) == NULL || *tmp_dir == '\\0'))", "  \ttmp_dir = \"/tmp\";", " #ifdef HAVE_MKDTEMP", "     tmp_dir = mkdtemp(Strnew_m_charp(tmp_dir, \"/w3m-XXXXXX\", NULL)->ptr);", "     if (tmp_dir == NULL)", " \ttmp_dir = rc_dir;", " #endif", "      create_option_search_table();", "      goto open_rc;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": [" static void oinf_entry_dump(GF_OperatingPointsInformation *ptr, FILE * trace)", " {", " \tu32 i, count;", " \tif (!ptr) {", " \t\tfprintf(trace, \"<OperatingPointsInformation scalability_mask=\\\"Multiview|Spatial scalability|Auxilary|unknown\\\" num_profile_tier_level=\\\"\\\" num_operating_points=\\\"\\\" dependency_layers=\\\"\\\">\\n\");", " \t\tfprintf(trace, \" <ProfileTierLevel general_profile_space=\\\"\\\" general_tier_flag=\\\"\\\" general_profile_idc=\\\"\\\" general_profile_compatibility_flags=\\\"\\\" general_constraint_indicator_flags=\\\"\\\" />\\n\");", " \t\tfprintf(trace, \"<OperatingPoint output_layer_set_idx=\\\"\\\" max_temporal_id=\\\"\\\" layer_count=\\\"\\\" minPicWidth=\\\"\\\" minPicHeight=\\\"\\\" maxPicWidth=\\\"\\\" maxPicHeight=\\\"\\\" maxChromaFormat=\\\"\\\" maxBitDepth=\\\"\\\" frame_rate_info_flag=\\\"\\\" bit_rate_info_flag=\\\"\\\" avgFrameRate=\\\"\\\" constantFrameRate=\\\"\\\" maxBitRate=\\\"\\\" avgBitRate=\\\"\\\"/>\\n\");", " \t\tfprintf(trace, \"<Layer dependent_layerID=\\\"\\\" num_layers_dependent_on=\\\"\\\" dependent_on_layerID=\\\"\\\" dimension_identifier=\\\"\\\"/>\\n\");", " \t\tfprintf(trace, \"</OperatingPointsInformation>\\n\");", " \t\treturn;", " \t}", " \tfprintf(trace, \"<OperatingPointsInformation\");", " \tfprintf(trace, \" scalability_mask=\\\"%u (\", ptr->scalability_mask);", " \tswitch (ptr->scalability_mask) {", " \tcase 2:", " \t\tfprintf(trace, \"Multiview\");", " \t\tbreak;", " \tcase 4:", " \t\tfprintf(trace, \"Spatial scalability\");", " \t\tbreak;", " \tcase 8:", " \t\tfprintf(trace, \"Auxilary\");", " \t\tbreak;", " \tdefault:", " \t\tfprintf(trace, \"unknown\");", " \t}", " \tfprintf(trace, \")\\\" num_profile_tier_level=\\\"%u\\\"\", gf_list_count(ptr->profile_tier_levels) );", " \tfprintf(trace, \" num_operating_points=\\\"%u\\\" dependency_layers=\\\"%u\\\"\", gf_list_count(ptr->operating_points), gf_list_count(ptr->dependency_layers));", " \tfprintf(trace, \">\\n\");", " \tcount=gf_list_count(ptr->profile_tier_levels);", " \tfor (i = 0; i < count; i++) {", " \t\tLHEVC_ProfileTierLevel *ptl = (LHEVC_ProfileTierLevel *)gf_list_get(ptr->profile_tier_levels, i);", " \t\tfprintf(trace, \" <ProfileTierLevel general_profile_space=\\\"%u\\\" general_tier_flag=\\\"%u\\\" general_profile_idc=\\\"%u\\\" general_profile_compatibility_flags=\\\"%X\\\" general_constraint_indicator_flags=\\\"\"LLX\"\\\" />\\n\", ptl->general_profile_space, ptl->general_tier_flag, ptl->general_profile_idc, ptl->general_profile_compatibility_flags, ptl->general_constraint_indicator_flags);", " \t}", " \tcount=gf_list_count(ptr->operating_points);", " \tfor (i = 0; i < count; i++) {", " \t\tLHEVC_OperatingPoint *op = (LHEVC_OperatingPoint *)gf_list_get(ptr->operating_points, i);", " \t\tfprintf(trace, \"<OperatingPoint output_layer_set_idx=\\\"%u\\\"\", op->output_layer_set_idx);", " \t\tfprintf(trace, \" max_temporal_id=\\\"%u\\\" layer_count=\\\"%u\\\"\", op->max_temporal_id, op->layer_count);", " \t\tfprintf(trace, \" minPicWidth=\\\"%u\\\" minPicHeight=\\\"%u\\\"\", op->minPicWidth, op->minPicHeight);", "  \t\tfprintf(trace, \" maxPicWidth=\\\"%u\\\" maxPicHeight=\\\"%u\\\"\", op->maxPicWidth, op->maxPicHeight);", "  \t\tfprintf(trace, \" maxChromaFormat=\\\"%u\\\" maxBitDepth=\\\"%u\\\"\", op->maxChromaFormat, op->maxBitDepth);", "  \t\tfprintf(trace, \" frame_rate_info_flag=\\\"%u\\\" bit_rate_info_flag=\\\"%u\\\"\", op->frame_rate_info_flag, op->bit_rate_info_flag);", "\t\tif (op->frame_rate_info_flag) ", " \t\tif (op->frame_rate_info_flag)", "  \t\t\tfprintf(trace, \" avgFrameRate=\\\"%u\\\" constantFrameRate=\\\"%u\\\"\", op->avgFrameRate, op->constantFrameRate);", "\t\tif (op->bit_rate_info_flag) ", " \t\tif (op->bit_rate_info_flag)", "  \t\t\tfprintf(trace, \" maxBitRate=\\\"%u\\\" avgBitRate=\\\"%u\\\"\", op->maxBitRate, op->avgBitRate);", "  \t\tfprintf(trace, \"/>\\n\");", "  \t}", " \tcount=gf_list_count(ptr->dependency_layers);", " \tfor (i = 0; i < count; i++) {", " \t\tu32 j;", " \t\tLHEVC_DependentLayer *dep = (LHEVC_DependentLayer *)gf_list_get(ptr->dependency_layers, i);", " \t\tfprintf(trace, \"<Layer dependent_layerID=\\\"%u\\\" num_layers_dependent_on=\\\"%u\\\"\", dep->dependent_layerID, dep->num_layers_dependent_on);", " \t\tif (dep->num_layers_dependent_on) {", " \t\t\tfprintf(trace, \" dependent_on_layerID=\\\"\");", " \t\t\tfor (j = 0; j < dep->num_layers_dependent_on; j++)", " \t\t\t\tfprintf(trace, \"%d \", dep->dependent_on_layerID[j]);", " \t\t\tfprintf(trace, \"\\\"\");", " \t\t}", " \t\tfprintf(trace, \" dimension_identifier=\\\"\");", " \t\tfor (j = 0; j < 16; j++)", " \t\t\tif (ptr->scalability_mask & (1 << j))", " \t\t\t\tfprintf(trace, \"%d \", dep->dimension_identifier[j]);", " \t\tfprintf(trace, \"\\\"/>\\n\");", " \t}", " \tfprintf(trace, \"</OperatingPointsInformation>\\n\");", " \treturn;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static int mem_read(jas_stream_obj_t *obj, char *buf, int cnt)", "  {", "\tint n;", " \tssize_t n;", "  \tassert(cnt >= 0);", "  \tassert(buf);", " \tJAS_DBGLOG(100, (\"mem_read(%p, %p, %d)\\n\", obj, buf, cnt));", " \tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;", " \tn = m->len_ - m->pos_;", " \tcnt = JAS_MIN(n, cnt);", " \tmemcpy(buf, &m->buf_[m->pos_], cnt);", " \tm->pos_ += cnt;", "  \treturn cnt;", "  }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  fbOver (CARD32 x, CARD32 y)", "  {", " \t\t\t\t  PicturePtr pDst,", " \t\t\t\t  INT16      xSrc,", " \t\t\t\t  INT16      ySrc,", " \t\t\t\t  INT16      xMask,", "                                   INT16      yMask,", " \t\t\t\t  INT16      xDst,", " \t\t\t\t  INT16      yDst,", " \t\t\t\t  CARD16     width,", " \t\t\t\t  CARD16     height);", " CARD32", " fbOver (CARD32 x, CARD32 y)", " {", "     CARD16  a = ~x >> 24;", "     CARD16  t;", "     CARD32  m,n,o,p;", "     m = FbOverU(x,y,0,a,t);", "     n = FbOverU(x,y,8,a,t);", "     o = FbOverU(x,y,16,a,t);", "     p = FbOverU(x,y,24,a,t);", "     return m|n|o|p;", " }", " CARD32", " fbOver24 (CARD32 x, CARD32 y)", " {", "     CARD16  a = ~x >> 24;", "     CARD16  t;", "     CARD32  m,n,o;", "     m = FbOverU(x,y,0,a,t);", "     n = FbOverU(x,y,8,a,t);", "     o = FbOverU(x,y,16,a,t);", "     return m|n|o;", " }", " CARD32", " fbIn (CARD32 x, CARD8 y)", " {", "     CARD16  a = y;", "     CARD16  t;", "     CARD32  m,n,o,p;", "     m = FbInU(x,0,a,t);", "     n = FbInU(x,8,a,t);", "     o = FbInU(x,16,a,t);", "     p = FbInU(x,24,a,t);", "     return m|n|o|p;", " }", " #define genericCombine24(a,b,c,d) (((a)*(c)+(b)*(d)))", " #define inOver0888(alpha, source, destval, dest) { \\", "  \tCARD32 dstrb=destval&0xFF00FF; CARD32 dstag=(destval>>8)&0xFF00FF; \\", "  \tCARD32 drb=((source&0xFF00FF)-dstrb)*alpha; CARD32 dag=(((source>>8)&0xFF00FF)-dstag)*alpha; \\", " \tWRITE(dest, ((((drb>>8) + dstrb) & 0x00FF00FF) | ((((dag>>8) + dstag) << 8) & 0xFF00FF00))); \\", "     }", " #define inOver0565(alpha, source, destval, dest) { \\", "  \tCARD16 dstrb = destval & 0xf81f; CARD16 dstg  = destval & 0x7e0; \\", "  \tCARD32 drb = ((source&0xf81f)-dstrb)*alpha; CARD32 dg=((source & 0x7e0)-dstg)*alpha; \\", " \tWRITE(dest, ((((drb>>5) + dstrb)&0xf81f) | (((dg>>5)  + dstg) & 0x7e0))); \\", "     }", " #define inOver2x0565(alpha, source, destval, dest) { \\", "  \tCARD32 dstrb = destval & 0x07e0f81f; CARD32 dstg  = (destval & 0xf81f07e0)>>5; \\", "  \tCARD32 drb = ((source&0x07e0f81f)-dstrb)*alpha; CARD32 dg=(((source & 0xf81f07e0)>>5)-dstg)*alpha; \\", " \tWRITE(dest, ((((drb>>5) + dstrb)&0x07e0f81f) | ((((dg>>5)  + dstg)<<5) & 0xf81f07e0))); \\", "     }", " #if IMAGE_BYTE_ORDER == LSBFirst", " #define setupPackedReader(count,temp,where,workingWhere,workingVal) count=(long)where; \\", " \t\t\t\t\ttemp=count&3; \\", " \t\t\t\t\twhere-=temp; \\", " \t\t\t\t\tworkingWhere=(CARD32 *)where; \\", "                                         workingVal=READ(workingWhere++); \\", " \t\t\t\t\tcount=4-temp; \\", " \t\t\t\t\tworkingVal>>=(8*temp)", "         #define readPacked(where,x,y,z) {if(!(x)) { (x)=4; y = READ(z++); } where=(y)&0xff; (y)>>=8; (x)--;}", " \t#define readPackedSource(where) readPacked(where,ws,workingSource,wsrc)", " \t#define readPackedDest(where) readPacked(where,wd,workingiDest,widst)", "         #define writePacked(what) workingoDest>>=8; workingoDest|=(what<<24); ww--; if(!ww) { ww=4; WRITE (wodst++, workingoDest); } ", " #else", " \t#warning \"I havn't tested fbCompositeTrans_0888xnx0888() on big endian yet!\"", " \t#define setupPackedReader(count,temp,where,workingWhere,workingVal) count=(long)where; \\", " \t\t\t\t\ttemp=count&3; \\", " \t\t\t\t\twhere-=temp; \\", " \t\t\t\t\tworkingWhere=(CARD32 *)where; \\", "                                         workingVal=READ(workingWhere++); \\", " \t\t\t\t\tcount=4-temp; \\", " \t\t\t\t\tworkingVal<<=(8*temp)", "         #define readPacked(where,x,y,z) {if(!(x)) { (x)=4; y = READ(z++); } where=(y)>>24; (y)<<=8; (x)--;}", " \t#define readPackedSource(where) readPacked(where,ws,workingSource,wsrc)", " \t#define readPackedDest(where) readPacked(where,wd,workingiDest,widst)", "         #define writePacked(what) workingoDest<<=8; workingoDest|=what; ww--; if(!ww) { ww=4; WRITE(wodst++, workingoDest); } ", " #endif", " void", " fbCompositeSolidMask_nx8x8888 (CARD8      op,", " \t\t\t       PicturePtr pSrc,", " \t\t\t       PicturePtr pMask,", " \t\t\t       PicturePtr pDst,", " \t\t\t       INT16      xSrc,", " \t\t\t       INT16      ySrc,", " \t\t\t       INT16      xMask,", " \t\t\t       INT16      yMask,", " \t\t\t       INT16      xDst,", " \t\t\t       INT16      yDst,", " \t\t\t       CARD16     width,", " \t\t\t       CARD16     height)", " {", "     CARD32\tsrc, srca;", "     CARD32\t*dstLine, *dst, d, dstMask;", "     CARD8\t*maskLine, *mask, m;", "     FbStride\tdstStride, maskStride;", "     CARD16\tw;", "     fbComposeGetSolid(pSrc, src, pDst->format);", "     dstMask = FbFullMask (pDst->pDrawable->depth);", "     srca = src >> 24;", "     if (src == 0)", " \treturn;", "     fbComposeGetStart (pDst, xDst, yDst, CARD32, dstStride, dstLine, 1);", "     fbComposeGetStart (pMask, xMask, yMask, CARD8, maskStride, maskLine, 1);", "     while (height--)", "     {", " \tdst = dstLine;", " \tdstLine += dstStride;", " \tmask = maskLine;", " \tmaskLine += maskStride;", " \tw = width;", " \twhile (w--)", " \t{", " \t    m = READ(mask++);", " \t    if (m == 0xff)", " \t    {", " \t\tif (srca == 0xff)", " \t\t    WRITE(dst, src & dstMask);", " \t\telse", " \t\t    WRITE(dst, fbOver (src, READ(dst)) & dstMask);", " \t    }", " \t    else if (m)", " \t    {", " \t\td = fbIn (src, m);", " \t\tWRITE(dst, fbOver (d, READ(dst)) & dstMask);", " \t    }", " \t    dst++;", " \t}", "     }", "     fbFinishAccess (pMask->pDrawable);", "     fbFinishAccess (pDst->pDrawable);", " }", " void", " fbCompositeSolidMask_nx8888x8888C (CARD8      op,", " \t\t\t\t   PicturePtr pSrc,", " \t\t\t\t   PicturePtr pMask,", " \t\t\t\t   PicturePtr pDst,", " \t\t\t\t   INT16      xSrc,", " \t\t\t\t   INT16      ySrc,", " \t\t\t\t   INT16      xMask,", " \t\t\t\t   INT16      yMask,", " \t\t\t\t   INT16      xDst,", " \t\t\t\t   INT16      yDst,", " \t\t\t\t   CARD16     width,", " \t\t\t\t   CARD16     height)", " {", "     CARD32\tsrc, srca;", "     CARD32\t*dstLine, *dst, d, dstMask;", "     CARD32\t*maskLine, *mask, ma;", "     FbStride\tdstStride, maskStride;", "     CARD16\tw;", "     CARD32\tm, n, o, p;", "     fbComposeGetSolid(pSrc, src, pDst->format);", "     dstMask = FbFullMask (pDst->pDrawable->depth);", "     srca = src >> 24;", "     if (src == 0)", " \treturn;", "     fbComposeGetStart (pDst, xDst, yDst, CARD32, dstStride, dstLine, 1);", "     fbComposeGetStart (pMask, xMask, yMask, CARD32, maskStride, maskLine, 1);", "     while (height--)", "     {", " \tdst = dstLine;", " \tdstLine += dstStride;", " \tmask = maskLine;", " \tmaskLine += maskStride;", " \tw = width;", " \twhile (w--)", " \t{", " \t    ma = READ(mask++);", " \t    if (ma == 0xffffffff)", " \t    {", " \t\tif (srca == 0xff)", " \t\t    WRITE(dst, src & dstMask);", " \t\telse", " \t\t    WRITE(dst, fbOver (src, READ(dst)) & dstMask);", " \t    }", " \t    else if (ma)", " \t    {", " \t\td = READ(dst);", " #define FbInOverC(src,srca,msk,dst,i,result) { \\", "     CARD16  __a = FbGet8(msk,i); \\", "     CARD32  __t, __ta; \\", "     CARD32  __i; \\", "     __t = FbIntMult (FbGet8(src,i), __a,__i); \\", "     __ta = (CARD8) ~FbIntMult (srca, __a,__i); \\", "     __t = __t + FbIntMult(FbGet8(dst,i),__ta,__i); \\", "     __t = (CARD32) (CARD8) (__t | (-(__t >> 8))); \\", "     result = __t << (i); \\", " }", " \t\tFbInOverC (src, srca, ma, d, 0, m);", " \t\tFbInOverC (src, srca, ma, d, 8, n);", " \t\tFbInOverC (src, srca, ma, d, 16, o);", " \t\tFbInOverC (src, srca, ma, d, 24, p);", " \t\tWRITE(dst, m|n|o|p);", " \t    }", " \t    dst++;", " \t}", "     }", "     fbFinishAccess (pMask->pDrawable);", "     fbFinishAccess (pDst->pDrawable);", " }", " #define srcAlphaCombine24(a,b) genericCombine24(a,b,srca,srcia)", " void", " fbCompositeSolidMask_nx8x0888 (CARD8      op,", " \t\t\t       PicturePtr pSrc,", " \t\t\t       PicturePtr pMask,", " \t\t\t       PicturePtr pDst,", " \t\t\t       INT16      xSrc,", " \t\t\t       INT16      ySrc,", " \t\t\t       INT16      xMask,", " \t\t\t       INT16      yMask,", " \t\t\t       INT16      xDst,", " \t\t\t       INT16      yDst,", " \t\t\t       CARD16     width,", " \t\t\t       CARD16     height)", " {", "     CARD32\tsrc, srca, srcia;", "     CARD8\t*dstLine, *dst, *edst;", "     CARD8\t*maskLine, *mask, m;", "     FbStride\tdstStride, maskStride;", "     CARD16\tw;", "     CARD32 rs,gs,bs,rd,gd,bd;", "     fbComposeGetSolid(pSrc, src, pDst->format);", "     srca = src >> 24;", "     srcia = 255-srca;", "     if (src == 0)", " \treturn;", "     rs=src&0xff;", "     gs=(src>>8)&0xff;", "     bs=(src>>16)&0xff;", "     fbComposeGetStart (pDst, xDst, yDst, CARD8, dstStride, dstLine, 3);", "     fbComposeGetStart (pMask, xMask, yMask, CARD8, maskStride, maskLine, 1);", "     while (height--)", "     {", " \tunsigned long wt, wd;", " \tCARD32 workingiDest;", " \tCARD32 *widst;", " \tedst = dst = dstLine;", " \tdstLine += dstStride;", " \tmask = maskLine;", " \tmaskLine += maskStride;", " \tw = width;", " #ifndef NO_MASKED_PACKED_READ", " \tsetupPackedReader(wd,wt,edst,widst,workingiDest);", " #endif", " \twhile (w--)", " \t{", " #ifndef NO_MASKED_PACKED_READ", " \t    readPackedDest(rd);", " \t    readPackedDest(gd);", " \t    readPackedDest(bd);", " #else", " \t    rd = READ(edst++);", " \t    gd = READ(edst++);", " \t    bd = READ(edst++);", " #endif", " \t    m = READ(mask++);", " \t    if (m == 0xff)", " \t    {", " \t\tif (srca == 0xff)", " \t\t{", " \t\t    WRITE(dst++, rs);", " \t\t    WRITE(dst++, gs);", " \t\t    WRITE(dst++, bs);", " \t\t}", " \t\telse", " \t\t{", " \t\t    WRITE(dst++, (srcAlphaCombine24(rs, rd)>>8));", " \t\t    WRITE(dst++, (srcAlphaCombine24(gs, gd)>>8));", " \t\t    WRITE(dst++, (srcAlphaCombine24(bs, bd)>>8));", " \t\t}", " \t    }", " \t    else if (m)", " \t    {", " \t\tint na=(srca*(int)m)>>8;", " \t\tint nia=255-na;", " \t\tWRITE(dst++, (genericCombine24(rs, rd, na, nia)>>8));", " \t\tWRITE(dst++, (genericCombine24(gs, gd, na, nia)>>8));", " \t\tWRITE(dst++, (genericCombine24(bs, bd, na, nia)>>8));", " \t    }", " \t    else", " \t    {", " \t\tdst+=3;", " \t    }", " \t}", "     }", "     fbFinishAccess (pMask->pDrawable);", "     fbFinishAccess (pDst->pDrawable);", " }", " void", " fbCompositeSolidMask_nx8x0565 (CARD8      op,", " \t\t\t\t  PicturePtr pSrc,", " \t\t\t\t  PicturePtr pMask,", " \t\t\t\t  PicturePtr pDst,", " \t\t\t\t  INT16      xSrc,", " \t\t\t\t  INT16      ySrc,", " \t\t\t\t  INT16      xMask,", " \t\t\t\t  INT16      yMask,", " \t\t\t\t  INT16      xDst,", " \t\t\t\t  INT16      yDst,", " \t\t\t\t  CARD16     width,", " \t\t\t\t  CARD16     height)", " {", "     CARD32\tsrc, srca8, srca5;", "     CARD16\t*dstLine, *dst;", "     CARD16\td;", "     CARD32\tt;", "     CARD8\t*maskLine, *mask, m;", "     FbStride\tdstStride, maskStride;", "     CARD16\tw,src16;", "     fbComposeGetSolid(pSrc, src, pDst->format);", "     if (src == 0)", " \treturn;", "     srca8 = (src >> 24);", "     srca5 = (srca8 >> 3);", "     src16 = cvt8888to0565(src);", "     fbComposeGetStart (pDst, xDst, yDst, CARD16, dstStride, dstLine, 1);", "     fbComposeGetStart (pMask, xMask, yMask, CARD8, maskStride, maskLine, 1);", "     while (height--)", "     {", " \tdst = dstLine;", " \tdstLine += dstStride;", " \tmask = maskLine;", " \tmaskLine += maskStride;", " \tw = width;", " \twhile (w--)", " \t{", " \t    m = READ(mask++);", " \t    if (m == 0)", " \t\tdst++;", " \t    else if (srca5 == (0xff >> 3))", " \t    {", " \t\tif (m == 0xff)", " \t\t    WRITE(dst++, src16);", " \t\telse ", "  \t\t{", " \t\t    d = READ(dst);", " \t\t    m >>= 3;", " \t\t    inOver0565 (m, src16, d, dst++);", "  \t\t}", " \t    }", " \t    else", " \t    {", " \t\td = READ(dst);", " \t\tif (m == 0xff) ", " \t\t{", " \t\t    t = fbOver24 (src, cvt0565to0888 (d));", " \t\t}", " \t\telse", " \t\t{", " \t\t    t = fbIn (src, m);", " \t\t    t = fbOver (t, cvt0565to0888 (d));", " \t\t}", " \t\tWRITE(dst++, cvt8888to0565 (t));", " \t    }", " \t}", "     }", "     fbFinishAccess (pMask->pDrawable);", "     fbFinishAccess (pDst->pDrawable);", " }", " static void", " fbCompositeSolidMask_nx8888x0565 (CARD8      op,", " \t\t\t\t  PicturePtr pSrc,", " \t\t\t\t  PicturePtr pMask,", " \t\t\t\t  PicturePtr pDst,", " \t\t\t\t  INT16      xSrc,", " \t\t\t\t  INT16      ySrc,", " \t\t\t\t  INT16      xMask,", " \t\t\t\t  INT16      yMask,", " \t\t\t\t  INT16      xDst,", " \t\t\t\t  INT16      yDst,", " \t\t\t\t  CARD16     width,", " \t\t\t\t  CARD16     height)", " {", "     CARD32\tsrc, srca8, srca5;", "     CARD16\t*dstLine, *dst;", "     CARD16\td;", "     CARD32\t*maskLine, *mask;", "     CARD32\tt;", "     CARD8\tm;", "     FbStride\tdstStride, maskStride;", "     CARD16\tw, src16;", "     fbComposeGetSolid(pSrc, src, pDst->format);", "     if (src == 0)", " \treturn;", "     srca8 = src >> 24;", "     srca5 = srca8 >> 3;", "     src16 = cvt8888to0565(src);", "     fbComposeGetStart (pDst, xDst, yDst, CARD16, dstStride, dstLine, 1);", "     fbComposeGetStart (pMask, xMask, yMask, CARD32, maskStride, maskLine, 1);", "     while (height--)", "     {", " \tdst = dstLine;", " \tdstLine += dstStride;", " \tmask = maskLine;", " \tmaskLine += maskStride;", " \tw = width;", " \twhile (w--)", " \t{", " \t    m = READ(mask++) >> 24;", " \t    if (m == 0)", " \t\tdst++;", " \t    else if (srca5 == (0xff >> 3))", " \t    {", " \t\tif (m == 0xff)", " \t\t    WRITE(dst++, src16);", " \t\telse", " \t\t{", " \t\t    d = READ(dst);", " \t\t    m >>= 3;", " \t\t    inOver0565 (m, src16, d, dst++);", " \t\t}", " \t    }", " \t    else", " \t    {", " \t\tif (m == 0xff) ", " \t\t{", " \t\t    d = READ(dst);", " \t\t    t = fbOver24 (src, cvt0565to0888 (d));", " \t\t    WRITE(dst++, cvt8888to0565 (t));", " \t\t}", " \t\telse", " \t\t{", " \t\t    d = READ(dst);", " \t\t    t = fbIn (src, m);", " \t\t    t = fbOver (t, cvt0565to0888 (d));", " \t\t    WRITE(dst++, cvt8888to0565 (t));", " \t\t}", " \t    }", " \t}", "     }", " }", " void", " fbCompositeSolidMask_nx8888x0565C (CARD8      op,", " \t\t\t\t   PicturePtr pSrc,", " \t\t\t\t   PicturePtr pMask,", " \t\t\t\t   PicturePtr pDst,", " \t\t\t\t   INT16      xSrc,", " \t\t\t\t   INT16      ySrc,", " \t\t\t\t   INT16      xMask,", " \t\t\t\t   INT16      yMask,", " \t\t\t\t   INT16      xDst,", " \t\t\t\t   INT16      yDst,", " \t\t\t\t   CARD16     width,", " \t\t\t\t   CARD16     height)", " {", "     CARD32\tsrc, srca;", "     CARD16\tsrc16;", "     CARD16\t*dstLine, *dst;", "     CARD32\td;", "     CARD32\t*maskLine, *mask, ma;", "     FbStride\tdstStride, maskStride;", "     CARD16\tw;", "     CARD32\tm, n, o;", "     fbComposeGetSolid(pSrc, src, pDst->format);", "     srca = src >> 24;", "     if (src == 0)", " \treturn;", "     src16 = cvt8888to0565(src);", "     fbComposeGetStart (pDst, xDst, yDst, CARD16, dstStride, dstLine, 1);", "     fbComposeGetStart (pMask, xMask, yMask, CARD32, maskStride, maskLine, 1);", "     while (height--)", "     {", " \tdst = dstLine;", " \tdstLine += dstStride;", " \tmask = maskLine;", " \tmaskLine += maskStride;", " \tw = width;", " \twhile (w--)", " \t{", " \t    ma = READ(mask++);", " \t    if (ma == 0xffffffff)", " \t    {", " \t\tif (srca == 0xff)", " \t\t{", " \t\t    WRITE(dst, src16);", " \t\t}", " \t\telse", " \t\t{", " \t\t    d = READ(dst);", " \t\t    d = fbOver24 (src, cvt0565to0888(d));", " \t\t    WRITE(dst, cvt8888to0565(d));", " \t\t}", " \t    }", " \t    else if (ma)", " \t    {", " \t\td = READ(dst);", " \t\td = cvt0565to0888(d);", " \t\tFbInOverC (src, srca, ma, d, 0, m);", " \t\tFbInOverC (src, srca, ma, d, 8, n);", " \t\tFbInOverC (src, srca, ma, d, 16, o);", " \t\td = m|n|o;", " \t\tWRITE(dst, cvt8888to0565(d));", " \t    }", " \t    dst++;", " \t}", "     }", "     fbFinishAccess (pMask->pDrawable);", "     fbFinishAccess (pDst->pDrawable);", " }", " void", " fbCompositeSrc_8888x8888 (CARD8      op,", " \t\t\t PicturePtr pSrc,", " \t\t\t PicturePtr pMask,", " \t\t\t PicturePtr pDst,", " \t\t\t INT16      xSrc,", " \t\t\t INT16      ySrc,", " \t\t\t INT16      xMask,", " \t\t\t INT16      yMask,", " \t\t\t INT16      xDst,", " \t\t\t INT16      yDst,", " \t\t\t CARD16     width,", " \t\t\t CARD16     height)", " {", "     CARD32\t*dstLine, *dst, dstMask;", "     CARD32\t*srcLine, *src, s;", "     FbStride\tdstStride, srcStride;", "     CARD8\ta;", "     CARD16\tw;", "     fbComposeGetStart (pDst, xDst, yDst, CARD32, dstStride, dstLine, 1);", "     fbComposeGetStart (pSrc, xSrc, ySrc, CARD32, srcStride, srcLine, 1);", "     dstMask = FbFullMask (pDst->pDrawable->depth);", "     while (height--)", "     {", " \tdst = dstLine;", " \tdstLine += dstStride;", " \tsrc = srcLine;", " \tsrcLine += srcStride;", " \tw = width;", " \twhile (w--)", " \t{", " \t    s = READ(src++);", " \t    a = s >> 24;", " \t    if (a == 0xff)", " \t\tWRITE(dst, s & dstMask);", " \t    else if (a)", " \t\tWRITE(dst, fbOver (s, READ(dst)) & dstMask);", " \t    dst++;", " \t}", "     }", "     fbFinishAccess (pSrc->pDrawable);", "     fbFinishAccess (pDst->pDrawable);", " }", " void", " fbCompositeSrc_8888x0888 (CARD8      op,", " \t\t\t PicturePtr pSrc,", " \t\t\t PicturePtr pMask,", " \t\t\t PicturePtr pDst,", " \t\t\t INT16      xSrc,", " \t\t\t INT16      ySrc,", " \t\t\t INT16      xMask,", " \t\t\t INT16      yMask,", " \t\t\t INT16      xDst,", " \t\t\t INT16      yDst,", " \t\t\t CARD16     width,", " \t\t\t CARD16     height)", " {", "     CARD8\t*dstLine, *dst;", "     CARD32\td;", "     CARD32\t*srcLine, *src, s;", "     CARD8\ta;", "     FbStride\tdstStride, srcStride;", "     CARD16\tw;", "     fbComposeGetStart (pDst, xDst, yDst, CARD8, dstStride, dstLine, 3);", "     fbComposeGetStart (pSrc, xSrc, ySrc, CARD32, srcStride, srcLine, 1);", "     while (height--)", "     {", " \tdst = dstLine;", " \tdstLine += dstStride;", " \tsrc = srcLine;", " \tsrcLine += srcStride;", " \tw = width;", " \twhile (w--)", " \t{", " \t    s = READ(src++);", " \t    a = s >> 24;", " \t    if (a)", " \t    {", " \t\tif (a == 0xff)", " \t\t    d = s;", " \t\telse", " \t\t    d = fbOver24 (s, Fetch24(dst));", " \t\tStore24(dst,d);", " \t    }", " \t    dst += 3;", " \t}", "     }", "     fbFinishAccess (pSrc->pDrawable);", "     fbFinishAccess (pDst->pDrawable);", " }", " void", " fbCompositeSrc_8888x0565 (CARD8      op,", " \t\t\t PicturePtr pSrc,", " \t\t\t PicturePtr pMask,", " \t\t\t PicturePtr pDst,", " \t\t\t INT16      xSrc,", " \t\t\t INT16      ySrc,", " \t\t\t INT16      xMask,", " \t\t\t INT16      yMask,", " \t\t\t INT16      xDst,", " \t\t\t INT16      yDst,", " \t\t\t CARD16     width,", " \t\t\t CARD16     height)", " {", "     CARD16\t*dstLine, *dst;", "     CARD32\td;", "     CARD32\t*srcLine, *src, s;", "     CARD8\ta;", "     FbStride\tdstStride, srcStride;", "     CARD16\tw;", "     fbComposeGetStart (pSrc, xSrc, ySrc, CARD32, srcStride, srcLine, 1);", "     fbComposeGetStart (pDst, xDst, yDst, CARD16, dstStride, dstLine, 1);", "     while (height--)", "     {", " \tdst = dstLine;", " \tdstLine += dstStride;", " \tsrc = srcLine;", " \tsrcLine += srcStride;", " \tw = width;", " \twhile (w--)", " \t{", " \t    s = READ(src++);", " \t    a = s >> 24;", " \t    if (a)", " \t    {", " \t\tif (a == 0xff)", " \t\t    d = s;", " \t\telse", " \t\t{", " \t\t    d = READ(dst);", " \t\t    d = fbOver24 (s, cvt0565to0888(d));", " \t\t}", " \t\tWRITE(dst, cvt8888to0565(d));", " \t    }", " \t    dst++;", " \t}", "     }", "     fbFinishAccess (pDst->pDrawable);", "     fbFinishAccess (pSrc->pDrawable);", " }", " void", " fbCompositeSrcAdd_8000x8000 (CARD8\top,", " \t\t\t     PicturePtr pSrc,", " \t\t\t     PicturePtr pMask,", " \t\t\t     PicturePtr pDst,", " \t\t\t     INT16      xSrc,", " \t\t\t     INT16      ySrc,", " \t\t\t     INT16      xMask,", " \t\t\t     INT16      yMask,", " \t\t\t     INT16      xDst,", " \t\t\t     INT16      yDst,", " \t\t\t     CARD16     width,", " \t\t\t     CARD16     height)", " {", "     CARD8\t*dstLine, *dst;", "     CARD8\t*srcLine, *src;", "     FbStride\tdstStride, srcStride;", "     CARD16\tw;", "     CARD8\ts, d;", "     CARD16\tt;", "     fbComposeGetStart (pSrc, xSrc, ySrc, CARD8, srcStride, srcLine, 1);", "     fbComposeGetStart (pDst, xDst, yDst, CARD8, dstStride, dstLine, 1);", "     while (height--)", "     {", " \tdst = dstLine;", " \tdstLine += dstStride;", " \tsrc = srcLine;", " \tsrcLine += srcStride;", " \tw = width;", " \twhile (w--)", " \t{", " \t    s = READ(src++);", " \t    if (s)", " \t    {", " \t\tif (s != 0xff)", " \t\t{", " \t\t    d = READ(dst);", " \t\t    t = d + s;", " \t\t    s = t | (0 - (t >> 8));", " \t\t}", " \t\tWRITE(dst, s);", " \t    }", " \t    dst++;", " \t}", "     }", "     fbFinishAccess (pDst->pDrawable);", "     fbFinishAccess (pSrc->pDrawable);", " }", " void", " fbCompositeSrcAdd_8888x8888 (CARD8\top,", " \t\t\t     PicturePtr pSrc,", " \t\t\t     PicturePtr pMask,", " \t\t\t     PicturePtr pDst,", " \t\t\t     INT16      xSrc,", " \t\t\t     INT16      ySrc,", " \t\t\t     INT16      xMask,", " \t\t\t     INT16      yMask,", " \t\t\t     INT16      xDst,", " \t\t\t     INT16      yDst,", " \t\t\t     CARD16     width,", " \t\t\t     CARD16     height)", " {", "     CARD32\t*dstLine, *dst;", "     CARD32\t*srcLine, *src;", "     FbStride\tdstStride, srcStride;", "     CARD16\tw;", "     CARD32\ts, d;", "     CARD16\tt;", "     CARD32\tm,n,o,p;", "     fbComposeGetStart (pSrc, xSrc, ySrc, CARD32, srcStride, srcLine, 1);", "     fbComposeGetStart (pDst, xDst, yDst, CARD32, dstStride, dstLine, 1);", "     while (height--)", "     {", " \tdst = dstLine;", " \tdstLine += dstStride;", " \tsrc = srcLine;", " \tsrcLine += srcStride;", " \tw = width;", " \twhile (w--)", " \t{", " \t    s = READ(src++);", " \t    if (s)", " \t    {", " \t\tif (s != 0xffffffff)", " \t\t{", " \t\t    d = READ(dst);", " \t\t    if (d)", " \t\t    {", " \t\t\tm = FbAdd(s,d,0,t);", " \t\t\tn = FbAdd(s,d,8,t);", " \t\t\to = FbAdd(s,d,16,t);", " \t\t\tp = FbAdd(s,d,24,t);", " \t\t\ts = m|n|o|p;", " \t\t    }", " \t\t}", " \t\tWRITE(dst, s);", " \t    }", " \t    dst++;", " \t}", "     }", "     fbFinishAccess (pDst->pDrawable);", "     fbFinishAccess (pSrc->pDrawable);", " }", " static void", " fbCompositeSrcAdd_8888x8x8 (CARD8      op,", " \t\t\t    PicturePtr pSrc,", " \t\t\t    PicturePtr pMask,", " \t\t\t    PicturePtr pDst,", " \t\t\t    INT16      xSrc,", " \t\t\t    INT16      ySrc,", " \t\t\t    INT16      xMask,", " \t\t\t    INT16      yMask,", " \t\t\t    INT16      xDst,", " \t\t\t    INT16      yDst,", " \t\t\t    CARD16     width,", " \t\t\t    CARD16     height)", " {", "     CARD8\t*dstLine, *dst;", "     CARD8\t*maskLine, *mask;", "     FbStride\tdstStride, maskStride;", "     CARD16\tw;", "     CARD32\tsrc;", "     CARD8\tsa;", "     fbComposeGetStart (pDst, xDst, yDst, CARD8, dstStride, dstLine, 1);", "     fbComposeGetStart (pMask, xMask, yMask, CARD8, maskStride, maskLine, 1);", "     fbComposeGetSolid (pSrc, src, pDst->format);", "     sa = (src >> 24);", "     while (height--)", "     {", " \tdst = dstLine;", " \tdstLine += dstStride;", " \tmask = maskLine;", " \tmaskLine += maskStride;", " \tw = width;", " \twhile (w--)", " \t{", " \t    CARD16\ttmp;", " \t    CARD16\ta;", " \t    CARD32\tm, d;", " \t    CARD32\tr;", " \t    a = READ(mask++);", " \t    d = READ(dst);", " \t    m = FbInU (sa, 0, a, tmp);", " \t    r = FbAdd (m, d, 0, tmp);", " \t    WRITE(dst++, r);", " \t}", "     }", "     fbFinishAccess(pDst->pDrawable);", "     fbFinishAccess(pMask->pDrawable);", " }", " void", " fbCompositeSrcAdd_1000x1000 (CARD8\top,", " \t\t\t     PicturePtr pSrc,", " \t\t\t     PicturePtr pMask,", " \t\t\t     PicturePtr pDst,", " \t\t\t     INT16      xSrc,", " \t\t\t     INT16      ySrc,", " \t\t\t     INT16      xMask,", " \t\t\t     INT16      yMask,", " \t\t\t     INT16      xDst,", " \t\t\t     INT16      yDst,", " \t\t\t     CARD16     width,", " \t\t\t     CARD16     height)", " {", "     FbBits\t*dstBits, *srcBits;", "     FbStride\tdstStride, srcStride;", "     int\t\tdstBpp, srcBpp;", "     int\t\tdstXoff, dstYoff;", "     int\t\tsrcXoff, srcYoff;", "     fbGetDrawable(pSrc->pDrawable, srcBits, srcStride, srcBpp, srcXoff, srcYoff);", "     fbGetDrawable(pDst->pDrawable, dstBits, dstStride, dstBpp, dstXoff, dstYoff);", "     fbBlt (srcBits + srcStride * (ySrc + srcYoff),", " \t   srcStride,", " \t   xSrc + srcXoff,", " \t   dstBits + dstStride * (yDst + dstYoff),", " \t   dstStride,", " \t   xDst + dstXoff,", " \t   width,", " \t   height,", " \t   GXor,", " \t   FB_ALLONES,", " \t   srcBpp,", " \t   FALSE,", " \t   FALSE);", "     fbFinishAccess(pDst->pDrawable);", "     fbFinishAccess(pSrc->pDrawable);", " }", " void", " fbCompositeSolidMask_nx1xn (CARD8      op,", " \t\t\t    PicturePtr pSrc,", " \t\t\t    PicturePtr pMask,", " \t\t\t    PicturePtr pDst,", " \t\t\t    INT16      xSrc,", " \t\t\t    INT16      ySrc,", " \t\t\t    INT16      xMask,", " \t\t\t    INT16      yMask,", " \t\t\t    INT16      xDst,", " \t\t\t    INT16      yDst,", " \t\t\t    CARD16     width,", " \t\t\t    CARD16     height)", " {", "     FbBits\t*dstBits;", "     FbStip\t*maskBits;", "     FbStride\tdstStride, maskStride;", "     int\t\tdstBpp, maskBpp;", "     int\t\tdstXoff, dstYoff;", "     int\t\tmaskXoff, maskYoff;", "     FbBits\tsrc;", "     fbComposeGetSolid(pSrc, src, pDst->format);", "     fbGetStipDrawable (pMask->pDrawable, maskBits, maskStride, maskBpp, maskXoff, maskYoff);", "     fbGetDrawable (pDst->pDrawable, dstBits, dstStride, dstBpp, dstXoff, dstYoff);", "     switch (dstBpp) {", "     case 32:", " \tbreak;", "     case 24:", " \tbreak;", "     case 16:", " \tsrc = cvt8888to0565(src);", " \tbreak;", "     }", "     src = fbReplicatePixel (src, dstBpp);", "     fbBltOne (maskBits + maskStride * (yMask + maskYoff),", " \t      maskStride,", " \t      xMask + maskXoff,", " \t      dstBits + dstStride * (yDst + dstYoff),", " \t      dstStride,", " \t      (xDst + dstXoff) * dstBpp,", " \t      dstBpp,", " \t      width * dstBpp,", " \t      height,", " \t      0x0,", " \t      src,", " \t      FB_ALLONES,", " \t      0x0);", "     fbFinishAccess (pDst->pDrawable);", "     fbFinishAccess (pMask->pDrawable);", " }", " # define mod(a,b)\t((b) == 1 ? 0 : (a) >= 0 ? (a) % (b) : (b) - (-a) % (b))", " static void", " fbCompositeSrcSrc_nxn  (CARD8\t   op,", " \t\t\tPicturePtr pSrc,", " \t\t\tPicturePtr pMask,", " \t\t\tPicturePtr pDst,", " \t\t\tINT16      xSrc,", " \t\t\tINT16      ySrc,", " \t\t\tINT16      xMask,", " \t\t\tINT16      yMask,", " \t\t\tINT16      xDst,", " \t\t\tINT16      yDst,", " \t\t\tCARD16     width,", " \t\t\tCARD16     height);", " static void", " fbCompositeTrans_0565xnx0565(CARD8      op,", " \t\t\t     PicturePtr pSrc,", " \t\t\t     PicturePtr pMask,", " \t\t\t     PicturePtr pDst,", " \t\t\t     INT16      xSrc,", " \t\t\t     INT16      ySrc,", " \t\t\t     INT16      xMask,", " \t\t\t     INT16      yMask,", " \t\t\t     INT16      xDst,", " \t\t\t     INT16      yDst,", " \t\t\t     CARD16     width,", " \t\t\t     CARD16     height)", " {", "     CARD16\t*dstLine, *dst;", "     CARD16\t*srcLine, *src;", "     FbStride\tdstStride, srcStride;", "     CARD16\tw;", "     FbBits\tmask;", "     CARD8\tmaskAlpha;", "     CARD16\ts_16, d_16;", "     CARD32\ts_32, d_32;", "     fbComposeGetSolid (pMask, mask, pDst->format);", "     maskAlpha = mask >> 27;", "     if (!maskAlpha)", " \treturn;", "     if (maskAlpha == 0xff)", "     {", " \tfbCompositeSrcSrc_nxn (PictOpSrc, pSrc, pMask, pDst,", " \t\t\t       xSrc, ySrc, xMask, yMask, xDst, yDst, ", " \t\t\t       width, height);", " \treturn;", "     }", "     fbComposeGetStart (pSrc, xSrc, ySrc, CARD16, srcStride, srcLine, 1);", "     fbComposeGetStart (pDst, xDst, yDst, CARD16, dstStride, dstLine, 1);", "     while (height--)", "     {", " \tCARD32 *isrc, *idst;", " \tdst = dstLine;", " \tdstLine += dstStride;", " \tsrc = srcLine;", " \tsrcLine += srcStride;", " \tw = width;", " \tif(((long)src&1)==1)", " \t{", " \t    s_16 = READ(src++);", " \t    d_16 = READ(dst);", " \t    inOver0565(maskAlpha, s_16, d_16, dst++);", " \t    w--;", " \t}", " \tisrc=(CARD32 *)src;", " \tif(((long)dst&1)==0)", " \t{", " \t    idst=(CARD32 *)dst;", " \t    while (w>1)", " \t    {", " \t\ts_32 = READ(isrc++);", " \t\td_32 = READ(idst);", " \t\tinOver2x0565(maskAlpha, s_32, d_32, idst++);", " \t\tw-=2;", " \t    }", " \t    dst=(CARD16 *)idst;", " \t}", " \telse", " \t{", " \t    while (w > 1)", " \t    {", " \t\ts_32 = READ(isrc++);", " #if IMAGE_BYTE_ORDER == LSBFirst", " \t\ts_16=s_32&0xffff;", " #else", " \t\ts_16=s_32>>16;", " #endif", " \t\td_16 = READ(dst);", " \t\tinOver0565 (maskAlpha, s_16, d_16, dst++);", " #if IMAGE_BYTE_ORDER == LSBFirst", " \t\ts_16=s_32>>16;", " #else", " \t\ts_16=s_32&0xffff;", " #endif", " \t\td_16 = READ(dst);", " \t\tinOver0565(maskAlpha, s_16, d_16, dst++);", " \t\tw-=2;", " \t    }", " \t}", " \tsrc=(CARD16 *)isrc;", " \tif(w!=0)", " \t{", " \t    s_16 = READ(src);", " \t    d_16 = READ(dst);", " \t    inOver0565(maskAlpha, s_16, d_16, dst);", " \t}", "     }", "     fbFinishAccess (pSrc->pDrawable);", "     fbFinishAccess (pDst->pDrawable);", " }", " #define alphamaskCombine24(a,b) genericCombine24(a,b,maskAlpha,maskiAlpha)", " static void", " fbCompositeTrans_0888xnx0888(CARD8      op,", "  \t\t\t     PicturePtr pSrc,", "  \t\t\t     PicturePtr pMask,", "  \t\t\t     PicturePtr pDst,", "  \t\t\t     INT16      xSrc,", "  \t\t\t     INT16      ySrc,", "  \t\t\t     INT16      xMask,", "  \t\t\t     INT16      yMask,", "  \t\t\t     INT16      xDst,", "  \t\t\t     INT16      yDst,", "  \t\t\t     CARD16     width,", "  \t\t\t     CARD16     height)", " {", "     CARD8\t*dstLine, *dst,*idst;", "     CARD8\t*srcLine, *src;", "     FbStride\tdstStride, srcStride;", "     CARD16\tw;", "     FbBits\tmask;", "     CARD16\tmaskAlpha,maskiAlpha;", "     fbComposeGetSolid (pMask, mask, pDst->format);", "     maskAlpha = mask >> 24;", "     maskiAlpha= 255-maskAlpha;", "     if (!maskAlpha)", "  \treturn;", "     fbComposeGetStart (pSrc, xSrc, ySrc, CARD8, srcStride, srcLine, 3);", "     fbComposeGetStart (pDst, xDst, yDst, CARD8, dstStride, dstLine, 3);", "     {", " \tunsigned long ws,wt;", " \tCARD32 workingSource;", " \tCARD32 *wsrc, *wdst, *widst;", " \tCARD32 rs, rd, nd;", " \tCARD8 *isrc;", " \tif ((((xSrc * 3) & 3) != ((xDst * 3) & 3)) ||", " \t    ((srcStride & 3) != (dstStride & 3)))", " \t{", " \t    while (height--)", " \t    {", " \t\tdst = dstLine;", " \t\tdstLine += dstStride;", " \t\tisrc = src = srcLine;", " \t\tsrcLine += srcStride;", " \t\tw = width*3;", " \t\tsetupPackedReader(ws,wt,isrc,wsrc,workingSource);", " \t\tswitch(~(long)dst&3)", " \t\t{", " \t\tcase 1:", " \t\t    readPackedSource(rs);", " \t\t    rd = READ(dst);   ", " \t\t    WRITE(dst++, alphamaskCombine24(rs, rd) >> 8);", " \t\t    w--; if(w==0) break;", " \t\tcase 2:", " \t\t    readPackedSource(rs);", " \t\t    rd = READ(dst);", " \t\t    WRITE(dst++, alphamaskCombine24(rs, rd) >> 8);", " \t\t    w--; if(w==0) break;", " \t\tcase 3:", " \t\t    readPackedSource(rs);", " \t\t    rd = READ(dst);", " \t\t    WRITE(dst++,alphamaskCombine24(rs, rd) >> 8);", " \t\t    w--; if(w==0) break;", " \t\t}", " \t\twdst=(CARD32 *)dst;", " \t\twhile (w>3)", " \t\t{", " \t\t    rs=READ(wsrc++);", " #if IMAGE_BYTE_ORDER == LSBFirst", " \t\t    rd=READ(wdst);", " \t\t    readPackedSource(nd);", " \t\t    readPackedSource(rs);", " \t\t    nd|=rs<<8;", " \t\t    readPackedSource(rs);", " \t\t    nd|=rs<<16;", " \t\t    readPackedSource(rs);", " \t\t    nd|=rs<<24;", " #else", " \t\t    readPackedSource(nd);", " \t\t    nd<<=24;", " \t\t    readPackedSource(rs);", " \t\t    nd|=rs<<16;", " \t\t    readPackedSource(rs);", " \t\t    nd|=rs<<8;", " \t\t    readPackedSource(rs);", " \t\t    nd|=rs;", " #endif", " \t\t    inOver0888(maskAlpha, nd, rd, wdst++);", " \t\t    w-=4;", " \t\t}", " \t\tsrc=(CARD8 *)wdst;", " \t\tswitch(w)", " \t\t{", " \t\tcase 3:", " \t\t    readPackedSource(rs);", " \t\t    rd=READ(dst);", " \t\t    WRITE(dst++,alphamaskCombine24(rs, rd)>>8);", " \t\tcase 2:", " \t\t    readPackedSource(rs);", " \t\t    rd = READ(dst);  ", " \t\t    WRITE(dst++, alphamaskCombine24(rs, rd)>>8);", " \t\tcase 1:", " \t\t    readPackedSource(rs);", " \t\t    rd = READ(dst);  ", " \t\t    WRITE(dst++, alphamaskCombine24(rs, rd)>>8);", " \t\t}", " \t    }", " \t}", " \telse", " \t{", " \t    while (height--)", " \t    {", " \t\tidst=dst = dstLine;", " \t\tdstLine += dstStride;", " \t\tsrc = srcLine;", " \t\tsrcLine += srcStride;", " \t\tw = width*3;", " \t\tswitch(~(long)src&3)", " \t\t{", " \t\tcase 1:", " \t\t    rd=alphamaskCombine24(READ(src++), READ(dst))>>8;", " \t\t    WRITE(dst++, rd);", " \t\t    w--; if(w==0) break;", " \t\tcase 2:", " \t\t    rd=alphamaskCombine24(READ(src++), READ(dst))>>8;", " \t\t    WRITE(dst++, rd);", " \t\t    w--; if(w==0) break;", " \t\tcase 3:", " \t\t    rd=alphamaskCombine24(READ(src++), READ(dst))>>8;", " \t\t    WRITE(dst++, rd);", " \t\t    w--; if(w==0) break;", " \t\t}", " \t\twsrc=(CARD32 *)src;", " \t\twidst=(CARD32 *)dst;", " \t\twhile(w>3)", " \t\t{", " \t\t    rs = READ(wsrc++);", " \t\t    rd = READ(widst);", " \t\t    inOver0888 (maskAlpha, rs, rd, widst++);", " \t\t    w-=4;", " \t\t}", " \t\tsrc=(CARD8 *)wsrc;", " \t\tdst=(CARD8 *)widst;", " \t\tswitch(w)", " \t\t{", " \t\tcase 3:", " \t\t    rd=alphamaskCombine24(READ(src++), READ(dst))>>8;", " \t\t    WRITE(dst++, rd);", " \t\tcase 2:", " \t\t    rd=alphamaskCombine24(READ(src++), READ(dst))>>8;", " \t\t    WRITE(dst++, rd);", " \t\tcase 1:", " \t\t    rd=alphamaskCombine24(READ(src++), READ(dst))>>8;", " \t\t    WRITE(dst++, rd);", " \t\t}", " \t    }", " \t}", "     }", " }", " static void", " fbCompositeSrcSrc_nxn  (CARD8\t   op,", " \t\t\tPicturePtr pSrc,", " \t\t\tPicturePtr pMask,", " \t\t\tPicturePtr pDst,", " \t\t\tINT16      xSrc,", " \t\t\tINT16      ySrc,", " \t\t\tINT16      xMask,", " \t\t\tINT16      yMask,", " \t\t\tINT16      xDst,", " \t\t\tINT16      yDst,", " \t\t\tCARD16     width,", " \t\t\tCARD16     height)", " {", "     FbBits\t*dst;", "     FbBits\t*src;", "     FbStride\tdstStride, srcStride;", "     int\t\tsrcXoff, srcYoff;", "     int\t\tdstXoff, dstYoff;", "     int\t\tsrcBpp;", "     int\t\tdstBpp;", "     Bool\treverse = FALSE;", "     Bool\tupsidedown = FALSE;", "     fbGetDrawable(pSrc->pDrawable,src,srcStride,srcBpp,srcXoff,srcYoff);", "     fbGetDrawable(pDst->pDrawable,dst,dstStride,dstBpp,dstXoff,dstYoff);", "     fbBlt (src + (ySrc + srcYoff) * srcStride,", " \t   srcStride,", " \t   (xSrc + srcXoff) * srcBpp,", " \t   dst + (yDst + dstYoff) * dstStride,", " \t   dstStride,", " \t   (xDst + dstXoff) * dstBpp,", " \t   (width) * dstBpp,", " \t   (height),", " \t   GXcopy,", " \t   FB_ALLONES,", " \t   dstBpp,", " \t   reverse,", " \t   upsidedown);", "     fbFinishAccess(pSrc->pDrawable);", "     fbFinishAccess(pDst->pDrawable);", " }", " #define SCANLINE_BUFFER_LENGTH 2048", " static void", " fbCompositeRectWrapper  (CARD8\t   op,", " \t\t\t PicturePtr pSrc,", " \t\t\t PicturePtr pMask,", " \t\t\t PicturePtr pDst,", " \t\t\t INT16      xSrc,", " \t\t\t INT16      ySrc,", " \t\t\t INT16      xMask,", " \t\t\t INT16      yMask,", " \t\t\t INT16      xDst,", " \t\t\t INT16      yDst,", " \t\t\t CARD16     width,", " \t\t\t CARD16     height)", " {", "     CARD32 _scanline_buffer[SCANLINE_BUFFER_LENGTH * 3];", "     CARD32 *scanline_buffer = _scanline_buffer;", "     FbComposeData data;", "     data.op = op;", "     data.src = pSrc;", "     data.mask = pMask;", "     data.dest = pDst;", "     data.xSrc = xSrc;", "     data.ySrc = ySrc;", "     data.xMask = xMask;", "  }", "  void", " fbWalkCompositeRegion (CARD8 op,", " \t\t       PicturePtr pSrc,", " \t\t       PicturePtr pMask,", " \t\t       PicturePtr pDst,", " \t\t       INT16 xSrc,", " \t\t       INT16 ySrc,", " \t\t       INT16 xMask,", " \t\t       INT16 yMask,", " \t\t       INT16 xDst,", " \t\t       INT16 yDst,", " \t\t       CARD16 width,", " \t\t       CARD16 height,", " \t\t       Bool srcRepeat,", " \t\t       Bool maskRepeat,", " \t\t       CompositeFunc compositeRect)", " {", "     RegionRec\t    region;", "     int\t\t    n;", "     BoxPtr\t    pbox;", "     int\t\t    w, h, w_this, h_this;", "     int\t\t    x_msk, y_msk, x_src, y_src, x_dst, y_dst;", "     xDst += pDst->pDrawable->x;", "     yDst += pDst->pDrawable->y;", "     if (pSrc->pDrawable)", "     {", "         xSrc += pSrc->pDrawable->x;", "         ySrc += pSrc->pDrawable->y;", "     }", "     if (pMask && pMask->pDrawable)", "     {", " \txMask += pMask->pDrawable->x;", " \tyMask += pMask->pDrawable->y;", "     }", "     if (!miComputeCompositeRegion (&region, pSrc, pMask, pDst, xSrc, ySrc,", " \t\t\t\t   xMask, yMask, xDst, yDst, width, height))", "         return;", "     n = REGION_NUM_RECTS (&region);", "     pbox = REGION_RECTS (&region);", "     while (n--)", "     {", " \th = pbox->y2 - pbox->y1;", " \ty_src = pbox->y1 - yDst + ySrc;", " \ty_msk = pbox->y1 - yDst + yMask;", " \ty_dst = pbox->y1;", " \twhile (h)", " \t{", " \t    h_this = h;", " \t    w = pbox->x2 - pbox->x1;", " \t    x_src = pbox->x1 - xDst + xSrc;", " \t    x_msk = pbox->x1 - xDst + xMask;", " \t    x_dst = pbox->x1;", " \t    if (maskRepeat)", " \t    {", " \t\ty_msk = mod (y_msk - pMask->pDrawable->y, pMask->pDrawable->height);", " \t\tif (h_this > pMask->pDrawable->height - y_msk)", " \t\t    h_this = pMask->pDrawable->height - y_msk;", " \t\ty_msk += pMask->pDrawable->y;", " \t    }", " \t    if (srcRepeat)", " \t    {", " \t\ty_src = mod (y_src - pSrc->pDrawable->y, pSrc->pDrawable->height);", " \t\tif (h_this > pSrc->pDrawable->height - y_src)", " \t\t    h_this = pSrc->pDrawable->height - y_src;", " \t\ty_src += pSrc->pDrawable->y;", " \t    }", " \t    while (w)", " \t    {", " \t\tw_this = w;", " \t\tif (maskRepeat)", " \t\t{", " \t\t    x_msk = mod (x_msk - pMask->pDrawable->x, pMask->pDrawable->width);", " \t\t    if (w_this > pMask->pDrawable->width - x_msk)", " \t\t\tw_this = pMask->pDrawable->width - x_msk;", " \t\t    x_msk += pMask->pDrawable->x;", " \t\t}", " \t\tif (srcRepeat)", " \t\t{", " \t\t    x_src = mod (x_src - pSrc->pDrawable->x, pSrc->pDrawable->width);", " \t\t    if (w_this > pSrc->pDrawable->width - x_src)", " \t\t\tw_this = pSrc->pDrawable->width - x_src;", " \t\t    x_src += pSrc->pDrawable->x;", " \t\t}", " \t\t(*compositeRect) (op, pSrc, pMask, pDst,", " \t\t\t\t  x_src, y_src, x_msk, y_msk, x_dst, y_dst,", " \t\t\t\t  w_this, h_this);", " \t\tw -= w_this;", " \t\tx_src += w_this;", " \t\tx_msk += w_this;", " \t\tx_dst += w_this;", " \t    }", " \t    h -= h_this;", " \t    y_src += h_this;", " \t    y_msk += h_this;", " \t    y_dst += h_this;", " \t}", " \tpbox++;", "     }", "     REGION_UNINIT (pDst->pDrawable->pScreen, &region);", " }", " void", "  fbComposite (CARD8      op,", "  \t     PicturePtr pSrc,", "  \t     PicturePtr pMask,", " \t\t\tcase PICT_x8r8g8b8:", " \t\t\tcase PICT_a8b8g8r8:", " \t\t\tcase PICT_x8b8g8r8:", " #ifdef USE_MMX", " \t\t\t    if (fbHaveMMX())", " \t\t\t\tfunc = fbCompositeSolidMask_nx8x8888mmx;", " \t\t\t    else", "  \t     CARD16     width,", "  \t     CARD16     height)", "  {", "    RegionRec\t    region;", "    int\t\t    n;", "    BoxPtr\t    pbox;", "    CompositeFunc   func = NULL;", "      Bool\t    srcRepeat = pSrc->pDrawable && pSrc->repeatType == RepeatNormal;", "      Bool\t    maskRepeat = FALSE;", "      Bool\t    srcTransform = pSrc->transform != 0;", " \t\t\tbreak;", "      Bool\t    srcAlphaMap = pSrc->alphaMap != 0;", "      Bool\t    maskAlphaMap = FALSE;", "      Bool\t    dstAlphaMap = pDst->alphaMap != 0;", "    int\t\t    x_msk, y_msk, x_src, y_src, x_dst, y_dst;", "    int\t\t    w, h, w_this, h_this;", "     CompositeFunc   func = NULL;", "  #ifdef USE_MMX", "      static Bool mmx_setup = FALSE;", " \t\t\t\t    func = fbCompositeSolidMask_nx8888x8888Cmmx;", " \t\t\t\telse", " #endif", "      }", "  #endif", "    xDst += pDst->pDrawable->x;", "    yDst += pDst->pDrawable->y;", "    if (pSrc->pDrawable) {", "        xSrc += pSrc->pDrawable->x;", "        ySrc += pSrc->pDrawable->y;", "    }", "      if (srcRepeat && srcTransform &&", "  \tpSrc->pDrawable->width == 1 &&", "  \tpSrc->pDrawable->height == 1)", " \t\t\t\telse", "      if (pMask && pMask->pDrawable)", "      {", "\txMask += pMask->pDrawable->x;", "\tyMask += pMask->pDrawable->y;", "  \tmaskRepeat = pMask->repeatType == RepeatNormal;", "  \tif (pMask->filter == PictFilterConvolution)", " \t\t\t}", " \t\t\telse", " \t\t\t{", " \t\t\t    switch (pDst->format) {", "                             case PICT_r5g6b5:", "                                 func = fbCompositeSolidMask_nx8888x0565;", "                                 break;", " \t\t\t    default:", " \t\t\t\tbreak;", "                             }", " \t\t\t}", " \t\t\tbreak;", " \t\t    case PICT_a8b8g8r8:", " \t\t\tif (pMask->componentAlpha) {", " \t\t\t    switch (pDst->format) {", " \t\t\t    case PICT_a8b8g8r8:", " \t\t\t    case PICT_x8b8g8r8:", " #ifdef USE_MMX", " \t\t\t\tif (fbHaveMMX())", " \t\t\t\t    func = fbCompositeSolidMask_nx8888x8888Cmmx;", " \t\t\t\telse", " #endif", " \t\t\t\t    func = fbCompositeSolidMask_nx8888x8888C;", " \t\t\t\tbreak;", " \t\t\t    case PICT_b5g6r5:", " #ifdef USE_MMX", " \t\t\t\tif (fbHaveMMX())", " \t\t\t\t    func = fbCompositeSolidMask_nx8888x0565Cmmx;", " \t\t\t\telse", " #endif", " \t\t\t\t    func = fbCompositeSolidMask_nx8888x0565C;", " \t\t\t\tbreak;", " \t\t\t    default:", " \t\t\t\tbreak;", " \t\t\t    }", " \t\t\t}", " \t\t\telse", " \t\t\t{", " \t\t\t    switch (pDst->format) {", "                             case PICT_b5g6r5:", "                                 func = fbCompositeSolidMask_nx8888x0565;", "                                 break;", " \t\t\t    default:", " \t\t\t\tbreak;", "                             }", " \t\t\t}", " \t\t\tbreak;", " \t\t    case PICT_a1:", " \t\t\tswitch (pDst->format) {", " \t\t\tcase PICT_r5g6b5:", " \t\t\tcase PICT_b5g6r5:", " \t\t\tcase PICT_r8g8b8:", " \t\t\tcase PICT_b8g8r8:", " \t\t\tcase PICT_a8r8g8b8:", " \t\t\tcase PICT_x8r8g8b8:", " \t\t\tcase PICT_a8b8g8r8:", " \t\t\tcase PICT_x8b8g8r8:", " \t\t\t{", " \t\t\t    FbBits src;", " \t\t\t    fbComposeGetSolid(pSrc, src, pDst->format);", " \t\t\t    if ((src & 0xff000000) == 0xff000000)", " \t\t\t\tfunc = fbCompositeSolidMask_nx1xn;", " \t\t\t    break;", " \t\t\t}", " \t\t\tdefault:", " \t\t\t    break;", " \t\t\t}", " \t\t\tbreak;", " \t\t    default:", " \t\t\tbreak;", " \t\t    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" yyparse (void *yyscanner, RE_LEX_ENVIRONMENT *lex_env)", " {", " int yychar;", " YY_INITIAL_VALUE (static YYSTYPE yyval_default;)", " YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);", "     int yynerrs;", "     int yystate;", "     int yyerrstatus;", "     yytype_int16 yyssa[YYINITDEPTH];", "     yytype_int16 *yyss;", "     yytype_int16 *yyssp;", "     YYSTYPE yyvsa[YYINITDEPTH];", "     YYSTYPE *yyvs;", "     YYSTYPE *yyvsp;", "     YYSIZE_T yystacksize;", "   int yyn;", "   int yyresult;", "   int yytoken = 0;", "   YYSTYPE yyval;", " #if YYERROR_VERBOSE", "   char yymsgbuf[128];", "   char *yymsg = yymsgbuf;", "   YYSIZE_T yymsg_alloc = sizeof yymsgbuf;", " #endif", " #define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))", "   int yylen = 0;", "   yyssp = yyss = yyssa;", "   yyvsp = yyvs = yyvsa;", "   yystacksize = YYINITDEPTH;", "   YYDPRINTF ((stderr, \"Starting parse\\n\"));", "   yystate = 0;", "   yyerrstatus = 0;", "   yynerrs = 0;", "   yychar = YYEMPTY;  ", "   goto yysetstate;", "  yynewstate:", "   yyssp++;", "  yysetstate:", "   *yyssp = yystate;", "   if (yyss + yystacksize - 1 <= yyssp)", "     {", "       YYSIZE_T yysize = yyssp - yyss + 1;", " #ifdef yyoverflow", "       {", "         YYSTYPE *yyvs1 = yyvs;", "         yytype_int16 *yyss1 = yyss;", "         yyoverflow (YY_(\"memory exhausted\"),", "                     &yyss1, yysize * sizeof (*yyssp),", "                     &yyvs1, yysize * sizeof (*yyvsp),", "                     &yystacksize);", "         yyss = yyss1;", "         yyvs = yyvs1;", "       }", " #else  ", " # ifndef YYSTACK_RELOCATE", "       goto yyexhaustedlab;", " # else", "       if (YYMAXDEPTH <= yystacksize)", "         goto yyexhaustedlab;", "       yystacksize *= 2;", "       if (YYMAXDEPTH < yystacksize)", "         yystacksize = YYMAXDEPTH;", "       {", "         yytype_int16 *yyss1 = yyss;", "         union yyalloc *yyptr =", "           (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));", "         if (! yyptr)", "           goto yyexhaustedlab;", "         YYSTACK_RELOCATE (yyss_alloc, yyss);", "         YYSTACK_RELOCATE (yyvs_alloc, yyvs);", " #  undef YYSTACK_RELOCATE", "         if (yyss1 != yyssa)", "           YYSTACK_FREE (yyss1);", "       }", " # endif", " #endif  ", "       yyssp = yyss + yysize - 1;", "       yyvsp = yyvs + yysize - 1;", "       YYDPRINTF ((stderr, \"Stack size increased to %lu\\n\",", "                   (unsigned long int) yystacksize));", "       if (yyss + yystacksize - 1 <= yyssp)", "         YYABORT;", "     }", "   YYDPRINTF ((stderr, \"Entering state %d\\n\", yystate));", "   if (yystate == YYFINAL)", "     YYACCEPT;", "   goto yybackup;", " yybackup:", "   yyn = yypact[yystate];", "   if (yypact_value_is_default (yyn))", "     goto yydefault;", "   if (yychar == YYEMPTY)", "     {", "       YYDPRINTF ((stderr, \"Reading a token: \"));", "       yychar = yylex (&yylval, yyscanner, lex_env);", "     }", "   if (yychar <= YYEOF)", "     {", "       yychar = yytoken = YYEOF;", "       YYDPRINTF ((stderr, \"Now at end of input.\\n\"));", "     }", "   else", "     {", "       yytoken = YYTRANSLATE (yychar);", "       YY_SYMBOL_PRINT (\"Next token is\", yytoken, &yylval, &yylloc);", "     }", "   yyn += yytoken;", "   if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)", "     goto yydefault;", "   yyn = yytable[yyn];", "   if (yyn <= 0)", "     {", "       if (yytable_value_is_error (yyn))", "         goto yyerrlab;", "       yyn = -yyn;", "       goto yyreduce;", "     }", "   if (yyerrstatus)", "     yyerrstatus--;", "   YY_SYMBOL_PRINT (\"Shifting\", yytoken, &yylval, &yylloc);", "   yychar = YYEMPTY;", "   yystate = yyn;", "   YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN", "   *++yyvsp = yylval;", "   YY_IGNORE_MAYBE_UNINITIALIZED_END", "   goto yynewstate;", " yydefault:", "   yyn = yydefact[yystate];", "   if (yyn == 0)", "     goto yyerrlab;", "   goto yyreduce;", " yyreduce:", "   yylen = yyr2[yyn];", "   yyval = yyvsp[1-yylen];", "   YY_REDUCE_PRINT (yyn);", "    switch (yyn)", "      {", "          case 2:", "#line 105 \"re_grammar.y\"  ", " #line 113 \"re_grammar.y\"  ", "      {", "          RE_AST* re_ast = yyget_extra(yyscanner);", "          re_ast->root_node = (yyvsp[0].re_node);", "        }", "#line 1340 \"re_grammar.c\"  ", " #line 1348 \"re_grammar.c\"  ", "      break;", "    case 4:", "#line 114 \"re_grammar.y\"  ", " #line 122 \"re_grammar.y\"  ", "      {", "          (yyval.re_node) = (yyvsp[0].re_node);", "        }", "#line 1348 \"re_grammar.c\"  ", " #line 1356 \"re_grammar.c\"  ", "      break;", "    case 5:", "#line 118 \"re_grammar.y\"  ", " #line 126 \"re_grammar.y\"  ", "      {", "          mark_as_not_fast_regexp();", "         incr_ast_levels();", "          (yyval.re_node) = yr_re_node_create(RE_NODE_ALT, (yyvsp[-2].re_node), (yyvsp[0].re_node));", "         DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[-2].re_node));", "         DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[0].re_node));", "          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);", "        }", "#line 1363 \"re_grammar.c\"  ", " #line 1372 \"re_grammar.c\"  ", "      break;", "    case 6:", "#line 129 \"re_grammar.y\"  ", " #line 138 \"re_grammar.y\"  ", "      {", "          RE_NODE* node;", "          mark_as_not_fast_regexp();", "         incr_ast_levels();", "          node = yr_re_node_create(RE_NODE_EMPTY, NULL, NULL);", "         DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[-1].re_node));", "         ERROR_IF(node == NULL, ERROR_INSUFFICIENT_MEMORY);", "         (yyval.re_node) = yr_re_node_create(RE_NODE_ALT, (yyvsp[-1].re_node), node);", "          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);", "        }", "#line 1382 \"re_grammar.c\"  ", " #line 1392 \"re_grammar.c\"  ", "      break;", "    case 7:", "#line 147 \"re_grammar.y\"  ", " #line 157 \"re_grammar.y\"  ", "      {", "          (yyval.re_node) = (yyvsp[0].re_node);", "        }", "#line 1390 \"re_grammar.c\"  ", " #line 1400 \"re_grammar.c\"  ", "      break;", "    case 8:", "#line 151 \"re_grammar.y\"  ", " #line 161 \"re_grammar.y\"  ", "      {", "         incr_ast_levels();", "          (yyval.re_node) = yr_re_node_create(RE_NODE_CONCAT, (yyvsp[-1].re_node), (yyvsp[0].re_node));", "          DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[-1].re_node));", "          DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[0].re_node));", "          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);", "        }", "#line 1402 \"re_grammar.c\"  ", " #line 1414 \"re_grammar.c\"  ", "      break;", "    case 9:", "#line 162 \"re_grammar.y\"  ", " #line 174 \"re_grammar.y\"  ", "      {", "          RE_AST* re_ast;", "         mark_as_not_fast_regexp();", "         re_ast = yyget_extra(yyscanner);", "         re_ast->flags |= RE_FLAGS_GREEDY;", "         (yyval.re_node) = yr_re_node_create(RE_NODE_STAR, (yyvsp[-1].re_node), NULL);", "          DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[-1].re_node));", "          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);", "        }", "#line 1420 \"re_grammar.c\"  ", " #line 1432 \"re_grammar.c\"  ", "      break;", "    case 10:", "#line 176 \"re_grammar.y\"  ", " #line 188 \"re_grammar.y\"  ", "      {", "          RE_AST* re_ast;", "         mark_as_not_fast_regexp();", "         re_ast = yyget_extra(yyscanner);", "         re_ast->flags |= RE_FLAGS_UNGREEDY;", "         (yyval.re_node) = yr_re_node_create(RE_NODE_STAR, (yyvsp[-2].re_node), NULL);", "         DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[-2].re_node));", "         ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);", "          (yyval.re_node)->greedy = FALSE;", "        }", "#line 1440 \"re_grammar.c\"  ", " #line 1452 \"re_grammar.c\"  ", "      break;", "    case 11:", "#line 192 \"re_grammar.y\"  ", " #line 204 \"re_grammar.y\"  ", "      {", "          RE_AST* re_ast;", "         mark_as_not_fast_regexp();", "         re_ast = yyget_extra(yyscanner);", "         re_ast->flags |= RE_FLAGS_GREEDY;", "         (yyval.re_node) = yr_re_node_create(RE_NODE_PLUS, (yyvsp[-1].re_node), NULL);", "          DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[-1].re_node));", "          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);", "        }", "#line 1458 \"re_grammar.c\"  ", " #line 1470 \"re_grammar.c\"  ", "      break;", "    case 12:", "#line 206 \"re_grammar.y\"  ", " #line 218 \"re_grammar.y\"  ", "      {", "          RE_AST* re_ast;", "         mark_as_not_fast_regexp();", "         re_ast = yyget_extra(yyscanner);", "         re_ast->flags |= RE_FLAGS_UNGREEDY;", "         (yyval.re_node) = yr_re_node_create(RE_NODE_PLUS, (yyvsp[-2].re_node), NULL);", "         DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[-2].re_node));", "         ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);", "          (yyval.re_node)->greedy = FALSE;", "        }", "#line 1478 \"re_grammar.c\"  ", " #line 1490 \"re_grammar.c\"  ", "      break;", "    case 13:", "#line 222 \"re_grammar.y\"  ", " #line 234 \"re_grammar.y\"  ", "      {", "          RE_AST* re_ast = yyget_extra(yyscanner);", "          re_ast->flags |= RE_FLAGS_GREEDY;", "         if ((yyvsp[-1].re_node)->type == RE_NODE_ANY)", "         {", "           (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY, NULL, NULL);", "           DESTROY_NODE_IF(TRUE, (yyvsp[-1].re_node));", "         }", "         else", "         {", "           mark_as_not_fast_regexp();", "           (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE, (yyvsp[-1].re_node), NULL);", "           DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[-1].re_node));", "         }", "         DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[-1].re_node));", "         ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);", "          (yyval.re_node)->start = 0;", "          (yyval.re_node)->end = 1;", "        }", "#line 1505 \"re_grammar.c\"  ", " #line 1517 \"re_grammar.c\"  ", "      break;", "    case 14:", "#line 245 \"re_grammar.y\"  ", " #line 257 \"re_grammar.y\"  ", "      {", "          RE_AST* re_ast = yyget_extra(yyscanner);", "          re_ast->flags |= RE_FLAGS_UNGREEDY;", "         if ((yyvsp[-2].re_node)->type == RE_NODE_ANY)", "         {", "           (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY, NULL, NULL);", "           DESTROY_NODE_IF(TRUE, (yyvsp[-2].re_node));", "         }", "         else", "         {", "           mark_as_not_fast_regexp();", "           (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE, (yyvsp[-2].re_node), NULL);", "           DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[-2].re_node));", "         }", "         DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[-2].re_node));", "         ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);", "         (yyval.re_node)->start = 0;", "          (yyval.re_node)->end = 1;", "          (yyval.re_node)->greedy = FALSE;", "        }", "#line 1533 \"re_grammar.c\"  ", " #line 1545 \"re_grammar.c\"  ", "      break;", "    case 15:", "#line 269 \"re_grammar.y\"  ", " #line 281 \"re_grammar.y\"  ", "      {", "          RE_AST* re_ast = yyget_extra(yyscanner);", "          re_ast->flags |= RE_FLAGS_GREEDY;", "         if ((yyvsp[-1].re_node)->type == RE_NODE_ANY)", "         {", "           (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY, NULL, NULL);", "           DESTROY_NODE_IF(TRUE, (yyvsp[-1].re_node));", "         }", "         else", "         {", "           mark_as_not_fast_regexp();", "           (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE, (yyvsp[-1].re_node), NULL);", "           DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[-1].re_node));", "         }", "         ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);", "          (yyval.re_node)->start = (yyvsp[0].range) & 0xFFFF;;", "          (yyval.re_node)->end = (yyvsp[0].range) >> 16;;", "        }", "#line 1559 \"re_grammar.c\"  ", " #line 1571 \"re_grammar.c\"  ", "      break;", "    case 16:", "#line 291 \"re_grammar.y\"  ", " #line 303 \"re_grammar.y\"  ", "      {", "          RE_AST* re_ast = yyget_extra(yyscanner);", "          re_ast->flags |= RE_FLAGS_UNGREEDY;", "         if ((yyvsp[-2].re_node)->type == RE_NODE_ANY)", "         {", "           (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY, NULL, NULL);", "           DESTROY_NODE_IF(TRUE, (yyvsp[-2].re_node));", "         }", "         else", "         {", "           mark_as_not_fast_regexp();", "           (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE, (yyvsp[-2].re_node), NULL);", "           DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[-2].re_node));", "         }", "         ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);", "         (yyval.re_node)->start = (yyvsp[-1].range) & 0xFFFF;;", "          (yyval.re_node)->end = (yyvsp[-1].range) >> 16;;", "          (yyval.re_node)->greedy = FALSE;", "        }", "#line 1586 \"re_grammar.c\"  ", " #line 1598 \"re_grammar.c\"  ", "      break;", "    case 17:", "#line 314 \"re_grammar.y\"  ", " #line 326 \"re_grammar.y\"  ", "      {", "          (yyval.re_node) = (yyvsp[0].re_node);", "        }", "#line 1594 \"re_grammar.c\"  ", " #line 1606 \"re_grammar.c\"  ", "      break;", "    case 18:", "#line 318 \"re_grammar.y\"  ", " #line 330 \"re_grammar.y\"  ", "      {", "          (yyval.re_node) = yr_re_node_create(RE_NODE_WORD_BOUNDARY, NULL, NULL);", "          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);", "        }", "#line 1604 \"re_grammar.c\"  ", " #line 1616 \"re_grammar.c\"  ", "      break;", "    case 19:", "#line 324 \"re_grammar.y\"  ", " #line 336 \"re_grammar.y\"  ", "      {", "          (yyval.re_node) = yr_re_node_create(RE_NODE_NON_WORD_BOUNDARY, NULL, NULL);", "          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);", "        }", "#line 1614 \"re_grammar.c\"  ", " #line 1626 \"re_grammar.c\"  ", "      break;", "    case 20:", "#line 330 \"re_grammar.y\"  ", " #line 342 \"re_grammar.y\"  ", "      {", "          (yyval.re_node) = yr_re_node_create(RE_NODE_ANCHOR_START, NULL, NULL);", "          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);", "        }", "#line 1624 \"re_grammar.c\"  ", " #line 1636 \"re_grammar.c\"  ", "      break;", "    case 21:", "#line 336 \"re_grammar.y\"  ", " #line 348 \"re_grammar.y\"  ", "      {", "          (yyval.re_node) = yr_re_node_create(RE_NODE_ANCHOR_END, NULL, NULL);", "          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);", "        }", "#line 1634 \"re_grammar.c\"  ", " #line 1646 \"re_grammar.c\"  ", "      break;", "    case 22:", "#line 345 \"re_grammar.y\"  ", " #line 357 \"re_grammar.y\"  ", "      {", "         incr_ast_levels();", "          (yyval.re_node) = (yyvsp[-1].re_node);", "        }", "#line 1642 \"re_grammar.c\"  ", " #line 1656 \"re_grammar.c\"  ", "      break;", "    case 23:", "#line 349 \"re_grammar.y\"  ", " #line 363 \"re_grammar.y\"  ", "      {", "          (yyval.re_node) = yr_re_node_create(RE_NODE_ANY, NULL, NULL);", "          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);", "        }", "#line 1652 \"re_grammar.c\"  ", " #line 1666 \"re_grammar.c\"  ", "      break;", "    case 24:", "#line 355 \"re_grammar.y\"  ", " #line 369 \"re_grammar.y\"  ", "      {", "          (yyval.re_node) = yr_re_node_create(RE_NODE_LITERAL, NULL, NULL);", "          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);", "          (yyval.re_node)->value = (yyvsp[0].integer);", "        }", "#line 1664 \"re_grammar.c\"  ", " #line 1678 \"re_grammar.c\"  ", "      break;", "    case 25:", "#line 363 \"re_grammar.y\"  ", " #line 377 \"re_grammar.y\"  ", "      {", "          (yyval.re_node) = yr_re_node_create(RE_NODE_WORD_CHAR, NULL, NULL);", "          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);", "        }", "#line 1674 \"re_grammar.c\"  ", " #line 1688 \"re_grammar.c\"  ", "      break;", "    case 26:", "#line 369 \"re_grammar.y\"  ", " #line 383 \"re_grammar.y\"  ", "      {", "          (yyval.re_node) = yr_re_node_create(RE_NODE_NON_WORD_CHAR, NULL, NULL);", "          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);", "        }", "#line 1684 \"re_grammar.c\"  ", " #line 1698 \"re_grammar.c\"  ", "      break;", "    case 27:", "#line 375 \"re_grammar.y\"  ", " #line 389 \"re_grammar.y\"  ", "      {", "          (yyval.re_node) = yr_re_node_create(RE_NODE_SPACE, NULL, NULL);", "          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);", "        }", "#line 1694 \"re_grammar.c\"  ", " #line 1708 \"re_grammar.c\"  ", "      break;", "    case 28:", "#line 381 \"re_grammar.y\"  ", " #line 395 \"re_grammar.y\"  ", "      {", "           (yyval.re_node) = yr_re_node_create(RE_NODE_NON_SPACE, NULL, NULL);", "           ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);", "        }", "#line 1704 \"re_grammar.c\"  ", " #line 1718 \"re_grammar.c\"  ", "      break;", "    case 29:", "#line 387 \"re_grammar.y\"  ", " #line 401 \"re_grammar.y\"  ", "      {", "          (yyval.re_node) = yr_re_node_create(RE_NODE_DIGIT, NULL, NULL);", "          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);", "        }", "#line 1714 \"re_grammar.c\"  ", " #line 1728 \"re_grammar.c\"  ", "      break;", "    case 30:", "#line 393 \"re_grammar.y\"  ", " #line 407 \"re_grammar.y\"  ", "      {", "          (yyval.re_node) = yr_re_node_create(RE_NODE_NON_DIGIT, NULL, NULL);", "          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);", "        }", "#line 1724 \"re_grammar.c\"  ", " #line 1738 \"re_grammar.c\"  ", "      break;", "    case 31:", "#line 399 \"re_grammar.y\"  ", " #line 413 \"re_grammar.y\"  ", "      {", "          (yyval.re_node) = yr_re_node_create(RE_NODE_CLASS, NULL, NULL);", "          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);", "          (yyval.re_node)->class_vector = (yyvsp[0].class_vector);", "        }", "#line 1736 \"re_grammar.c\"  ", " #line 1750 \"re_grammar.c\"  ", "      break;", "#line 1740 \"re_grammar.c\"  ", " #line 1754 \"re_grammar.c\"  ", "        default: break;", "      }", "   YY_SYMBOL_PRINT (\"-> $$ =\", yyr1[yyn], &yyval, &yyloc);", "   YYPOPSTACK (yylen);", "   yylen = 0;", "   YY_STACK_PRINT (yyss, yyssp);", "   *++yyvsp = yyval;", "   yyn = yyr1[yyn];", "   yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;", "   if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)", "     yystate = yytable[yystate];", "   else", "     yystate = yydefgoto[yyn - YYNTOKENS];", "   goto yynewstate;", " yyerrlab:", "   yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);", "   if (!yyerrstatus)", "     {", "       ++yynerrs;", " #if ! YYERROR_VERBOSE", "       yyerror (yyscanner, lex_env, YY_(\"syntax error\"));", " #else", " # define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \\", "                                         yyssp, yytoken)", "       {", "         char const *yymsgp = YY_(\"syntax error\");", "         int yysyntax_error_status;", "         yysyntax_error_status = YYSYNTAX_ERROR;", "         if (yysyntax_error_status == 0)", "           yymsgp = yymsg;", "         else if (yysyntax_error_status == 1)", "           {", "             if (yymsg != yymsgbuf)", "               YYSTACK_FREE (yymsg);", "             yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);", "             if (!yymsg)", "               {", "                 yymsg = yymsgbuf;", "                 yymsg_alloc = sizeof yymsgbuf;", "                 yysyntax_error_status = 2;", "               }", "             else", "               {", "                 yysyntax_error_status = YYSYNTAX_ERROR;", "                 yymsgp = yymsg;", "               }", "           }", "         yyerror (yyscanner, lex_env, yymsgp);", "         if (yysyntax_error_status == 2)", "           goto yyexhaustedlab;", "       }", " # undef YYSYNTAX_ERROR", " #endif", "     }", "   if (yyerrstatus == 3)", "     {", "       if (yychar <= YYEOF)", "         {", "           if (yychar == YYEOF)", "             YYABORT;", "         }", "       else", "         {", "           yydestruct (\"Error: discarding\",", "                       yytoken, &yylval, yyscanner, lex_env);", "           yychar = YYEMPTY;", "         }", "     }", "   goto yyerrlab1;", " yyerrorlab:", "   if (  0)", "      goto yyerrorlab;", "   YYPOPSTACK (yylen);", "   yylen = 0;", "   YY_STACK_PRINT (yyss, yyssp);", "   yystate = *yyssp;", "   goto yyerrlab1;", " yyerrlab1:", "   yyerrstatus = 3;       ", "   for (;;)", "     {", "       yyn = yypact[yystate];", "       if (!yypact_value_is_default (yyn))", "         {", "           yyn += YYTERROR;", "           if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)", "             {", "               yyn = yytable[yyn];", "               if (0 < yyn)", "                 break;", "             }", "         }", "       if (yyssp == yyss)", "         YYABORT;", "       yydestruct (\"Error: popping\",", "                   yystos[yystate], yyvsp, yyscanner, lex_env);", "       YYPOPSTACK (1);", "       yystate = *yyssp;", "       YY_STACK_PRINT (yyss, yyssp);", "     }", "   YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN", "   *++yyvsp = yylval;", "   YY_IGNORE_MAYBE_UNINITIALIZED_END", "   YY_SYMBOL_PRINT (\"Shifting\", yystos[yyn], yyvsp, yylsp);", "   yystate = yyn;", "   goto yynewstate;", " yyacceptlab:", "   yyresult = 0;", "   goto yyreturn;", " yyabortlab:", "   yyresult = 1;", "   goto yyreturn;", " #if !defined yyoverflow || YYERROR_VERBOSE", " yyexhaustedlab:", "   yyerror (yyscanner, lex_env, YY_(\"memory exhausted\"));", "   yyresult = 2;", " #endif", " yyreturn:", "   if (yychar != YYEMPTY)", "     {", "       yytoken = YYTRANSLATE (yychar);", "       yydestruct (\"Cleanup: discarding lookahead\",", "                   yytoken, &yylval, yyscanner, lex_env);", "     }", "   YYPOPSTACK (yylen);", "   YY_STACK_PRINT (yyss, yyssp);", "   while (yyssp != yyss)", "     {", "       yydestruct (\"Cleanup: popping\",", "                   yystos[*yyssp], yyvsp, yyscanner, lex_env);", "       YYPOPSTACK (1);", "     }", " #ifndef yyoverflow", "   if (yyss != yyssa)", "     YYSTACK_FREE (yyss);", " #endif", " #if YYERROR_VERBOSE", "   if (yymsg != yymsgbuf)", "     YYSTACK_FREE (yymsg);", "  #endif", "    return yyresult;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int http_read_header(URLContext *h, int *new_location)", " {", "     HTTPContext *s = h->priv_data;", "      char line[MAX_URL_SIZE];", "      int err = 0;", "    s->chunksize = -1;", "     s->chunksize = UINT64_MAX;", "      for (;;) {", "          if ((err = http_get_line(s, line, sizeof(line))) < 0)", "             return err;", "         av_log(h, AV_LOG_TRACE, \"header='%s'\\n\", line);", "         err = process_line(h, line, s->line_count, new_location);", "         if (err < 0)", "             return err;", "         if (err == 0)", "             break;", "         s->line_count++;", "     }", "     if (s->seekable == -1 && s->is_mediagateway && s->filesize == 2000000000)", "         h->is_streamed = 1;  ", "     cookie_string(s->cookie_dict, &s->cookies);", "     av_dict_free(&s->cookie_dict);", "     return err;", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" validGlxScreen(ClientPtr client, int screen, __GLXscreen **pGlxScreen, int *err)", " {", "    if (screen >= screenInfo.numScreens) {", "     if (screen < 0 || screen >= screenInfo.numScreens) {", "  \tclient->errorValue = screen;", "  \t*err = BadValue;", "  \treturn FALSE;", "     }", "     *pGlxScreen = glxGetScreen(screenInfo.screens[screen]);", "     return TRUE;", " }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static int save_dev(blkid_dev dev, FILE *file)", "  {", "  \tstruct list_head *p;", " \tif (!dev || dev->bid_name[0] != '/')", " \t\treturn 0;", " \tDBG(SAVE, ul_debug(\"device %s, type %s\", dev->bid_name, dev->bid_type ?", " \t\t   dev->bid_type : \"(null)\"));", " \tfprintf(file, \"<device DEVNO=\\\"0x%04lx\\\" TIME=\\\"%ld.%ld\\\"\",", " \t\t\t(unsigned long) dev->bid_devno,", " \t\t\t(long) dev->bid_time,", " \t\t\t(long) dev->bid_utime);", "  \tif (dev->bid_pri)", "  \t\tfprintf(file, \" PRI=\\\"%d\\\"\", dev->bid_pri);", "  \tlist_for_each(p, &dev->bid_tags) {", "  \t\tblkid_tag tag = list_entry(p, struct blkid_struct_tag, bit_tags);", "\t\tfprintf(file, \" %s=\\\"%s\\\"\", tag->bit_name,tag->bit_val);", " \t\tfputc(' ', file);\t\t\t ", " \t\tfputs(tag->bit_name, file);\t\t ", " \t\tfputc('=', file);\t\t\t ", " \t\tsave_quoted(tag->bit_val, file);\t ", "  \t}", "  \tfprintf(file, \">%s</device>\\n\", dev->bid_name);", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": [" tar_directory_for_file (GsfInfileTar *dir, const char *name, gboolean last)", " {", " \tconst char *s = name;", " \twhile (1) {", " \t\tconst char *s0 = s;", " \t\tchar *dirname;", " \t\twhile (1) {", " \t\t\tif (*s == 0) {", " \t\t\t\tif (last && s != s0)", " \t\t\t\t\tbreak;", " \t\t\t\telse", " \t\t\t\t\treturn dir;", " \t\t\t}", " \t\t\tif (*s == '/')", " \t\t\t\tbreak;", " \t\t\ts++;", " \t\t}", " \t\tdirname = g_strndup (s0, s - s0);", " \t\twhile (*s == '/')", " \t\t\ts++;", " \t\tif (strcmp (dirname, \".\") != 0) {", " \t\t\tGsfInput *subdir =", "  \t\t\t\tgsf_infile_child_by_name (GSF_INFILE (dir),", "  \t\t\t\t\t\t\t  dirname);", "  \t\t\tif (subdir) {", " \t\t\t\tdir = GSF_IS_INFILE_TAR (subdir)", " \t\t\t\t\t? GSF_INFILE_TAR (subdir)", " \t\t\t\t\t: dir;", "  \t\t\t\tg_object_unref (subdir);", "\t\t\t\tdir = GSF_INFILE_TAR (subdir);", "  \t\t\t} else", "  \t\t\t\tdir = tar_create_dir (dir, dirname);", "  \t\t}", " \t\tg_free (dirname);", " \t}", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" ProcessUDPHeader(tTcpIpPacketParsingResult _res, PVOID pIpHeader, ULONG len, USHORT ipHeaderSize)", "  {", "      tTcpIpPacketParsingResult res = _res;", "      ULONG udpDataStart = ipHeaderSize + sizeof(UDPHeader);", "    res.xxpStatus = ppresXxpIncomplete;", "      res.TcpUdp = ppresIsUDP;", "      res.XxpIpHeaderSize = udpDataStart;", "      if (len >= udpDataStart)", "      {", "          UDPHeader *pUdpHeader = (UDPHeader *)RtlOffsetToPointer(pIpHeader, ipHeaderSize);", "          USHORT datagramLength = swap_short(pUdpHeader->udp_length);", "          res.xxpStatus = ppresXxpKnown;", "         res.xxpFull = TRUE;", "          DPrintf(2, (\"udp: len %d, datagramLength %d\\n\", len, datagramLength));", "      }", "     else", "     {", "         res.xxpFull = FALSE;", "         res.xxpStatus = ppresXxpIncomplete;", "     }", "      return res;", "  }"], "ner_tags": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0]}
{"tokens": [" mcs_recv_connect_response(STREAM mcs_data)", "  {", "  \tUNUSED(mcs_data);", "  \tuint8 result;", "\tint length;", " \tuint32 length;", "  \tSTREAM s;", " \tstruct stream packet;", "  \tRD_BOOL is_fastpath;", "  \tuint8 fastpath_hdr;", " \tlogger(Protocol, Debug, \"%s()\", __func__);", " \ts = iso_recv(&is_fastpath, &fastpath_hdr);", "  \tif (s == NULL)", "  \t\treturn False;", " \tpacket = *s;", "  \tber_parse_header(s, MCS_CONNECT_RESPONSE, &length);", " \tber_parse_header(s, BER_TAG_RESULT, &length);", " \tin_uint8(s, result);", " \tif (result != 0)", " \t{", " \t\tlogger(Protocol, Error, \"mcs_recv_connect_response(), result=%d\", result);", " \t\treturn False;", " \t}", "  \tber_parse_header(s, BER_TAG_INTEGER, &length);", "  \tin_uint8s(s, length);\t ", " \tif (!s_check_rem(s, length))", " \t{", " \t\trdp_protocol_error(\"mcs_recv_connect_response(), consume connect id from stream would overrun\", &packet);", " \t}", "  \tmcs_parse_domain_params(s);", "  \tber_parse_header(s, BER_TAG_OCTET_STRING, &length);", " \tsec_process_mcs_data(s);", " \treturn s_check_end(s);", " }"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" SProcXResQueryResourceBytes (ClientPtr client)", " {", "     REQUEST(xXResQueryResourceBytesReq);", "     int c;", "     xXResResourceIdSpec *specs = (void*) ((char*) stuff + sizeof(*stuff));", "      int c;", "      xXResResourceIdSpec *specs = (void*) ((char*) stuff + sizeof(*stuff));", "    swapl(&stuff->numSpecs);", "      REQUEST_AT_LEAST_SIZE(xXResQueryResourceBytesReq);", "     swapl(&stuff->numSpecs);", "      REQUEST_FIXED_SIZE(xXResQueryResourceBytesReq,", "                         stuff->numSpecs * sizeof(specs[0]));", "     }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0]}
{"tokens": [" static void Sp_split_regexp(js_State *J)", " {", " \tjs_Regexp *re;", " \tconst char *text;", " \tint limit, len, k;", " \tconst char *p, *a, *b, *c, *e;", " \tResub m;", " \ttext = checkstring(J, 0);", " \tre = js_toregexp(J, 1);", " \tlimit = js_isdefined(J, 2) ? js_tointeger(J, 2) : 1 << 30;", " \tjs_newarray(J);", " \tlen = 0;", " \te = text + strlen(text);", "  \tif (e == text) {", "\t\tif (js_regexec(re->prog, text, &m, 0)) {", " \t\tif (js_doregexec(J, re->prog, text, &m, 0)) {", "  \t\t\tif (len == limit) return;", "  \t\t\tjs_pushliteral(J, \"\");", "  \t\t\tjs_setindex(J, -2, 0);", " \t\t}", " \t\treturn;", " \t}", "  \tp = a = text;", "  \twhile (a < e) {", "\t\tif (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))", " \t\tif (js_doregexec(J, re->prog, a, &m, a > text ? REG_NOTBOL : 0))", "  \t\t\tbreak;  ", "  \t\tb = m.sub[0].sp;", " \t\tc = m.sub[0].ep;", " \t\tif (b == p) {", " \t\t\t++a;", " \t\t\tcontinue;", " \t\t}", " \t\tif (len == limit) return;", " \t\tjs_pushlstring(J, p, b - p);", " \t\tjs_setindex(J, -2, len++);", " \t\tfor (k = 1; k < m.nsub; ++k) {", " \t\t\tif (len == limit) return;", " \t\t\tjs_pushlstring(J, m.sub[k].sp, m.sub[k].ep - m.sub[k].sp);", " \t\t\tjs_setindex(J, -2, len++);", " \t\t}", " \t\ta = p = c;", " \t}", " \tif (len == limit) return;", " \tjs_pushstring(J, p);", " \tjs_setindex(J, -2, len);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" feed_table_block_tag(struct table *tbl,", " \t\t     char *line, struct table_mode *mode, int indent, int cmd)", " {", "     int offset;", "     if (mode->indent_level <= 0 && indent == -1)", " \treturn;", "     if (mode->indent_level >= CHAR_MAX && indent == 1)", " \treturn;", "     setwidth(tbl, mode);", "     feed_table_inline_tag(tbl, line, mode, -1);", "     clearcontentssize(tbl, mode);", "     if (indent == 1) {", " \tmode->indent_level++;", " \tif (mode->indent_level <= MAX_INDENT_LEVEL)", " \t    tbl->indent += INDENT_INCR;", "     }", "     else if (indent == -1) {", " \tmode->indent_level--;", "  \tif (mode->indent_level < MAX_INDENT_LEVEL)", "  \t    tbl->indent -= INDENT_INCR;", "      }", "     if (tbl->indent < 0)", " \ttbl->indent = 0;", "      offset = tbl->indent;", "      if (cmd == HTML_DT) {", "  \tif (mode->indent_level > 0 && mode->indent_level <= MAX_INDENT_LEVEL)", "  \t    offset -= INDENT_INCR;", " \tif (offset < 0)", " \t    offset = 0;", "      }", "      if (tbl->indent > 0) {", "  \tcheck_minimum0(tbl, 0);", " \taddcontentssize(tbl, offset);", "     }", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" queryin(char *buf)", " {", " \tQPRS_STATE\tstate;", " \tint32\t\ti;", " \tltxtquery  *query;", " \tint32\t\tcommonlen;", " \tITEM\t   *ptr;", " \tNODE\t   *tmp;", " \tint32\t\tpos = 0;", " #ifdef BS_DEBUG", " \tchar\t\tpbuf[16384],", " \t\t\t   *cur;", " #endif", " \tstate.buf = buf;", " \tstate.state = WAITOPERAND;", " \tstate.count = 0;", " \tstate.num = 0;", " \tstate.str = NULL;", " \tstate.sumlen = 0;", " \tstate.lenop = 64;", " \tstate.curop = state.op = (char *) palloc(state.lenop);", " \t*(state.curop) = '\\0';", " \tmakepol(&state);", " \tif (!state.num)", " \t\tereport(ERROR,", " \t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),", "  \t\t\t\t errmsg(\"syntax error\"),", "  \t\t\t\t errdetail(\"Empty query.\")));", " \tif (LTXTQUERY_TOO_BIG(state.num, state.sumlen))", " \t\tereport(ERROR,", " \t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),", " \t\t\t\t errmsg(\"ltxtquery is too large\")));", "  \tcommonlen = COMPUTESIZE(state.num, state.sumlen);", "  \tquery = (ltxtquery *) palloc(commonlen);", "  \tSET_VARSIZE(query, commonlen);", "  \tquery->size = state.num;", " \tptr = GETQUERY(query);", " \tfor (i = 0; i < state.num; i++)", " \t{", " \t\tptr[i].type = state.str->type;", " \t\tptr[i].val = state.str->val;", " \t\tptr[i].distance = state.str->distance;", " \t\tptr[i].length = state.str->length;", " \t\tptr[i].flag = state.str->flag;", " \t\ttmp = state.str->next;", " \t\tpfree(state.str);", " \t\tstate.str = tmp;", " \t}", " \tmemcpy((void *) GETOPERAND(query), (void *) state.op, state.sumlen);", " \tpfree(state.op);", " \tpos = 0;", " \tfindoprnd(ptr, &pos);", " \treturn query;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)", " {", "  \tjp2_cmap_t *cmap = &box->data.cmap;", "  \tjp2_cmapent_t *ent;", "  \tunsigned int i;", " \tcmap->ents = 0;", "  \tcmap->numchans = (box->datalen) / 4;", "  \tif (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {", " \t\treturn -1;", " \t}", " \tfor (i = 0; i < cmap->numchans; ++i) {", " \t\tent = &cmap->ents[i];", " \t\tif (jp2_getuint16(in, &ent->cmptno) ||", " \t\t  jp2_getuint8(in, &ent->map) ||", " \t\t  jp2_getuint8(in, &ent->pcol)) {", " \t\t\treturn -1;", " \t\t}", " \t}", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" ZSTD_compressSequences_internal(seqStore_t* seqStorePtr,", "                               ZSTD_entropyCTables_t const* prevEntropy,", "                               ZSTD_entropyCTables_t* nextEntropy,", "                               ZSTD_CCtx_params const* cctxParams,", "                               void* dst, size_t dstCapacity,", "                               void* workspace, size_t wkspSize,", "                               const int bmi2)", " {", "     const int longOffsets = cctxParams->cParams.windowLog > STREAM_ACCUMULATOR_MIN;", "     ZSTD_strategy const strategy = cctxParams->cParams.strategy;", "     U32 count[MaxSeq+1];", "     FSE_CTable* CTable_LitLength = nextEntropy->fse.litlengthCTable;", "     FSE_CTable* CTable_OffsetBits = nextEntropy->fse.offcodeCTable;", "     FSE_CTable* CTable_MatchLength = nextEntropy->fse.matchlengthCTable;", "     U32 LLtype, Offtype, MLtype;    ", "     const seqDef* const sequences = seqStorePtr->sequencesStart;", "     const BYTE* const ofCodeTable = seqStorePtr->ofCode;", "     const BYTE* const llCodeTable = seqStorePtr->llCode;", "     const BYTE* const mlCodeTable = seqStorePtr->mlCode;", "     BYTE* const ostart = (BYTE*)dst;", "     BYTE* const oend = ostart + dstCapacity;", "     BYTE* op = ostart;", "     size_t const nbSeq = seqStorePtr->sequences - seqStorePtr->sequencesStart;", "     BYTE* seqHead;", "     BYTE* lastNCount = NULL;", "     ZSTD_STATIC_ASSERT(HUF_WORKSPACE_SIZE >= (1<<MAX(MLFSELog,LLFSELog)));", "     {   const BYTE* const literals = seqStorePtr->litStart;", "         size_t const litSize = seqStorePtr->lit - literals;", "         int const disableLiteralCompression = (cctxParams->cParams.strategy == ZSTD_fast) && (cctxParams->cParams.targetLength > 0);", "         size_t const cSize = ZSTD_compressLiterals(", "                                     &prevEntropy->huf, &nextEntropy->huf,", "                                     cctxParams->cParams.strategy, disableLiteralCompression,", "                                     op, dstCapacity,", "                                     literals, litSize,", "                                     workspace, wkspSize,", "                                     bmi2);", "         if (ZSTD_isError(cSize))", "           return cSize;", "         assert(cSize <= dstCapacity);", "         op += cSize;", "     }", "     if ((oend-op) < 3   + 1  ) return ERROR(dstSize_tooSmall);", "     if (nbSeq < 0x7F)", "         *op++ = (BYTE)nbSeq;", "     else if (nbSeq < LONGNBSEQ)", "         op[0] = (BYTE)((nbSeq>>8) + 0x80), op[1] = (BYTE)nbSeq, op+=2;", "     else", "         op[0]=0xFF, MEM_writeLE16(op+1, (U16)(nbSeq - LONGNBSEQ)), op+=3;", "     if (nbSeq==0) {", "         memcpy(&nextEntropy->fse, &prevEntropy->fse, sizeof(prevEntropy->fse));", "         return op - ostart;", "     }", "     seqHead = op++;", "     ZSTD_seqToCodes(seqStorePtr);", "     {   U32 max = MaxLL;", "         size_t const mostFrequent = HIST_countFast_wksp(count, &max, llCodeTable, nbSeq, workspace, wkspSize);    ", "         DEBUGLOG(5, \"Building LL table\");", "         nextEntropy->fse.litlength_repeatMode = prevEntropy->fse.litlength_repeatMode;", "         LLtype = ZSTD_selectEncodingType(&nextEntropy->fse.litlength_repeatMode, count, max, mostFrequent, nbSeq, LLFSELog, prevEntropy->fse.litlengthCTable, LL_defaultNorm, LL_defaultNormLog, ZSTD_defaultAllowed, strategy);", "         assert(set_basic < set_compressed && set_rle < set_compressed);", "         assert(!(LLtype < set_compressed && nextEntropy->fse.litlength_repeatMode != FSE_repeat_none));  ", "         {   size_t const countSize = ZSTD_buildCTable(op, oend - op, CTable_LitLength, LLFSELog, (symbolEncodingType_e)LLtype,", "                                                     count, max, llCodeTable, nbSeq, LL_defaultNorm, LL_defaultNormLog, MaxLL,", "                                                     prevEntropy->fse.litlengthCTable, sizeof(prevEntropy->fse.litlengthCTable),", "                                                     workspace, wkspSize);", "             if (ZSTD_isError(countSize)) return countSize;", "             if (LLtype == set_compressed)", "                 lastNCount = op;", "             op += countSize;", "     }   }", "     {   U32 max = MaxOff;", "         size_t const mostFrequent = HIST_countFast_wksp(count, &max, ofCodeTable, nbSeq, workspace, wkspSize);   ", "         ZSTD_defaultPolicy_e const defaultPolicy = (max <= DefaultMaxOff) ? ZSTD_defaultAllowed : ZSTD_defaultDisallowed;", "         DEBUGLOG(5, \"Building OF table\");", "         nextEntropy->fse.offcode_repeatMode = prevEntropy->fse.offcode_repeatMode;", "         Offtype = ZSTD_selectEncodingType(&nextEntropy->fse.offcode_repeatMode, count, max, mostFrequent, nbSeq, OffFSELog, prevEntropy->fse.offcodeCTable, OF_defaultNorm, OF_defaultNormLog, defaultPolicy, strategy);", "         assert(!(Offtype < set_compressed && nextEntropy->fse.offcode_repeatMode != FSE_repeat_none));  ", "         {   size_t const countSize = ZSTD_buildCTable(op, oend - op, CTable_OffsetBits, OffFSELog, (symbolEncodingType_e)Offtype,", "                                                     count, max, ofCodeTable, nbSeq, OF_defaultNorm, OF_defaultNormLog, DefaultMaxOff,", "                                                     prevEntropy->fse.offcodeCTable, sizeof(prevEntropy->fse.offcodeCTable),", "                                                     workspace, wkspSize);", "             if (ZSTD_isError(countSize)) return countSize;", "             if (Offtype == set_compressed)", "                 lastNCount = op;", "             op += countSize;", "     }   }", "      {   U32 max = MaxML;", "          size_t const mostFrequent = HIST_countFast_wksp(count, &max, mlCodeTable, nbSeq, workspace, wkspSize);    ", "        DEBUGLOG(5, \"Building ML table\");", "         DEBUGLOG(5, \"Building ML table (remaining space : %i)\", (int)(oend-op));", "          nextEntropy->fse.matchlength_repeatMode = prevEntropy->fse.matchlength_repeatMode;", "          MLtype = ZSTD_selectEncodingType(&nextEntropy->fse.matchlength_repeatMode, count, max, mostFrequent, nbSeq, MLFSELog, prevEntropy->fse.matchlengthCTable, ML_defaultNorm, ML_defaultNormLog, ZSTD_defaultAllowed, strategy);", "          assert(!(MLtype < set_compressed && nextEntropy->fse.matchlength_repeatMode != FSE_repeat_none));  ", "         {   size_t const countSize = ZSTD_buildCTable(op, oend - op, CTable_MatchLength, MLFSELog, (symbolEncodingType_e)MLtype,", "                                                     count, max, mlCodeTable, nbSeq, ML_defaultNorm, ML_defaultNormLog, MaxML,", "                                                     prevEntropy->fse.matchlengthCTable, sizeof(prevEntropy->fse.matchlengthCTable),", "                                                     workspace, wkspSize);", "             if (ZSTD_isError(countSize)) return countSize;", "             if (MLtype == set_compressed)", "                 lastNCount = op;", "             op += countSize;", "     }   }", "     *seqHead = (BYTE)((LLtype<<6) + (Offtype<<4) + (MLtype<<2));", "     {   size_t const bitstreamSize = ZSTD_encodeSequences(", "                                         op, oend - op,", "                                         CTable_MatchLength, mlCodeTable,", "                                         CTable_OffsetBits, ofCodeTable,", "                                         CTable_LitLength, llCodeTable,", "                                         sequences, nbSeq,", "                                         longOffsets, bmi2);", "         if (ZSTD_isError(bitstreamSize)) return bitstreamSize;", "         op += bitstreamSize;", "         if (lastNCount && (op - lastNCount) < 4) {", "             assert(op - lastNCount == 3);", "             DEBUGLOG(5, \"Avoiding bug in zstd decoder in versions <= 1.3.4 by \"", "                         \"emitting an uncompressed block.\");", "             return 0;", "         }", "     }", "     return op - ostart;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" gimp_write_and_read_file (Gimp     *gimp,", "                           gboolean  with_unusual_stuff,", "                           gboolean  compat_paths,", "                           gboolean  use_gimp_2_8_features)", " {", "    GimpImage           *image;", "    GimpImage           *loaded_image;", "    GimpPlugInProcedure *proc;", "  gchar               *filename;", "   gchar               *filename = NULL;", "   gint                 file_handle;", "    GFile               *file;", "   image = gimp_create_mainimage (gimp,", "                                  with_unusual_stuff,", "                                  compat_paths,", "                                  use_gimp_2_8_features);", "   gimp_assert_mainimage (image,", "                          with_unusual_stuff,", "                          compat_paths,", "                           use_gimp_2_8_features);", "  filename = g_build_filename (g_get_tmp_dir (), \"gimp-test.xcf\", NULL);", "   file_handle = g_file_open_tmp (\"gimp-test-XXXXXX.xcf\", &filename, NULL);", "   g_assert (file_handle != -1);", "   close (file_handle);", "    file = g_file_new_for_path (filename);", "    g_free (filename);", "   proc = gimp_plug_in_manager_file_procedure_find (image->gimp->plug_in_manager,", "                                                    GIMP_FILE_PROCEDURE_GROUP_SAVE,", "                                                    file,", "                                                    NULL  );", "   file_save (gimp,", "              image,", "              NULL  ,", "              file,", "              proc,", "              GIMP_RUN_NONINTERACTIVE,", "              FALSE  ,", "              FALSE  ,", "              FALSE  ,", "              NULL  );", "   loaded_image = gimp_test_load_image (image->gimp, file);", "   gimp_assert_mainimage (loaded_image,", "                          with_unusual_stuff,", "                          compat_paths,", "                          use_gimp_2_8_features);", "   g_file_delete (file, NULL, NULL);", "   g_object_unref (file);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int rpc_type_of_NPNVariable(int variable)", " {", "   int type;", "   switch (variable) {", "   case NPNVjavascriptEnabledBool:", "   case NPNVasdEnabledBool:", "    case NPNVisOfflineBool:", "    case NPNVSupportsXEmbedBool:", "    case NPNVSupportsWindowless:", "   case NPNVprivateModeBool:", "   case NPNVsupportsAdvancedKeyHandling:", "  \ttype = RPC_TYPE_BOOLEAN;", "  \tbreak;", "    case NPNVToolkit:", "   case NPNVnetscapeWindow:", " \ttype = RPC_TYPE_UINT32;", " \tbreak;", "   case NPNVWindowNPObject:", "   case NPNVPluginElementNPObject:", " \ttype = RPC_TYPE_NP_OBJECT;", " \tbreak;", "   default:", " \ttype = RPC_ERROR_GENERIC;", " \tbreak;", "   }", "   return type;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int read_escaped_char(", "     yyscan_t yyscanner,", "     uint8_t* escaped_char)", " {", "   char text[4] = {0, 0, 0, 0};", "    text[0] = '\\\\';", "    text[1] = RE_YY_INPUT(yyscanner);", "  if (text[1] == EOF)", "   if (text[1] == EOF || text[1] == 0)", "      return 0;", "    if (text[1] == 'x')", "    {", "      text[2] = RE_YY_INPUT(yyscanner);", "    if (text[2] == EOF)", "     if (!isxdigit(text[2]))", "        return 0;", "      text[3] = RE_YY_INPUT(yyscanner);", "    if (text[3] == EOF)", "     if (!isxdigit(text[3]))", "        return 0;", "    }", "   *escaped_char = escaped_char_value(text);", "   return 1;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" auth_read_binary(struct sc_card *card, unsigned int offset,", " \t\tunsigned char *buf, size_t count, unsigned long flags)", " {", " \tint rv;", " \tstruct sc_pkcs15_bignum bn[2];", " \tunsigned char *out = NULL;", " \tbn[0].data = NULL;", "  \tbn[1].data = NULL;", "  \tLOG_FUNC_CALLED(card->ctx);", " \tif (!auth_current_ef)", " \t\tLOG_TEST_RET(card->ctx, SC_ERROR_INVALID_ARGUMENTS, \"Invalid auth_current_ef\");", "  \tsc_log(card->ctx,", "  \t       \"offset %i; size %\"SC_FORMAT_LEN_SIZE_T\"u; flags 0x%lX\",", "  \t       offset, count, flags);", " \tsc_log(card->ctx,\"last selected : magic %X; ef %X\",", " \t\t\tauth_current_ef->magic, auth_current_ef->ef_structure);", " \tif (offset & ~0x7FFF)", " \t\tLOG_TEST_RET(card->ctx, SC_ERROR_INVALID_ARGUMENTS, \"Invalid file offset\");", " \tif (auth_current_ef->magic==SC_FILE_MAGIC &&", " \t\t\tauth_current_ef->ef_structure == SC_CARDCTL_OBERTHUR_KEY_RSA_PUBLIC)   {", " \t\tint jj;", " \t\tunsigned char resp[256];", " \t\tsize_t resp_len, out_len;", " \t\tstruct sc_pkcs15_pubkey_rsa key;", " \t\tresp_len = sizeof(resp);", " \t\trv = auth_read_component(card, SC_CARDCTL_OBERTHUR_KEY_RSA_PUBLIC,", " \t\t\t\t2, resp, resp_len);", " \t\tLOG_TEST_RET(card->ctx, rv, \"read component failed\");", " \t\tfor (jj=0; jj<rv && *(resp+jj)==0; jj++)", " \t\t\t;", " \t\tbn[0].data = calloc(1, rv - jj);", " \t\tif (!bn[0].data) {", " \t\t\trv = SC_ERROR_OUT_OF_MEMORY;", " \t\t\tgoto err;", " \t\t}", " \t\tbn[0].len = rv - jj;", " \t\tmemcpy(bn[0].data, resp + jj, rv - jj);", " \t\trv = auth_read_component(card, SC_CARDCTL_OBERTHUR_KEY_RSA_PUBLIC,", " \t\t\t\t1, resp, resp_len);", " \t\tLOG_TEST_GOTO_ERR(card->ctx, rv, \"Cannot read RSA public key component\");", " \t\tbn[1].data = calloc(1, rv);", " \t\tif (!bn[1].data) {", " \t\t\trv = SC_ERROR_OUT_OF_MEMORY;", " \t\t\tgoto err;", " \t\t}", " \t\tbn[1].len = rv;", " \t\tmemcpy(bn[1].data, resp, rv);", " \t\tkey.exponent = bn[0];", " \t\tkey.modulus = bn[1];", " \t\tif (sc_pkcs15_encode_pubkey_rsa(card->ctx, &key, &out, &out_len)) {", " \t\t\trv = SC_ERROR_INVALID_ASN1_OBJECT;", " \t\t\tLOG_TEST_GOTO_ERR(card->ctx, rv, \"cannot encode RSA public key\");", " \t\t}", " \t\telse {", " \t\t\trv  = out_len - offset > count ? count : out_len - offset;", " \t\t\tmemcpy(buf, out + offset, rv);", " \t\t\tsc_log_hex(card->ctx, \"write_publickey\", buf, rv);", " \t\t}", " \t}", " \telse {", " \t\trv = iso_ops->read_binary(card, offset, buf, count, 0);", " \t}", " err:", " \tfree(bn[0].data);", " \tfree(bn[1].data);", " \tfree(out);", " \tLOG_FUNC_RETURN(card->ctx, rv);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int hls_slice_header(HEVCContext *s)", " {", "     GetBitContext *gb = &s->HEVClc->gb;", "     SliceHeader *sh   = &s->sh;", "     int i, ret;", "      sh->first_slice_in_pic_flag = get_bits1(gb);", "     if (s->ref && sh->first_slice_in_pic_flag) {", "         av_log(s->avctx, AV_LOG_ERROR, \"Two slices reporting being the first in the same frame.\\n\");", "         return 1;  ", "     }", "      if ((IS_IDR(s) || IS_BLA(s)) && sh->first_slice_in_pic_flag) {", "          s->seq_decode = (s->seq_decode + 1) & 0xff;", "          s->max_ra     = INT_MAX;", "         if (IS_IDR(s))", "             ff_hevc_clear_refs(s);", "     }", "     sh->no_output_of_prior_pics_flag = 0;", "     if (IS_IRAP(s))", "         sh->no_output_of_prior_pics_flag = get_bits1(gb);", "     sh->pps_id = get_ue_golomb_long(gb);", "     if (sh->pps_id >= HEVC_MAX_PPS_COUNT || !s->ps.pps_list[sh->pps_id]) {", "         av_log(s->avctx, AV_LOG_ERROR, \"PPS id out of range: %d\\n\", sh->pps_id);", "         return AVERROR_INVALIDDATA;", "     }", "     if (!sh->first_slice_in_pic_flag &&", "         s->ps.pps != (HEVCPPS*)s->ps.pps_list[sh->pps_id]->data) {", "         av_log(s->avctx, AV_LOG_ERROR, \"PPS changed between slices.\\n\");", "         return AVERROR_INVALIDDATA;", "     }", "     s->ps.pps = (HEVCPPS*)s->ps.pps_list[sh->pps_id]->data;", "     if (s->nal_unit_type == HEVC_NAL_CRA_NUT && s->last_eos == 1)", "         sh->no_output_of_prior_pics_flag = 1;", "     if (s->ps.sps != (HEVCSPS*)s->ps.sps_list[s->ps.pps->sps_id]->data) {", "         const HEVCSPS *sps = (HEVCSPS*)s->ps.sps_list[s->ps.pps->sps_id]->data;", "         const HEVCSPS *last_sps = s->ps.sps;", "         enum AVPixelFormat pix_fmt;", "         if (last_sps && IS_IRAP(s) && s->nal_unit_type != HEVC_NAL_CRA_NUT) {", "             if (sps->width != last_sps->width || sps->height != last_sps->height ||", "                 sps->temporal_layer[sps->max_sub_layers - 1].max_dec_pic_buffering !=", "                 last_sps->temporal_layer[last_sps->max_sub_layers - 1].max_dec_pic_buffering)", "                 sh->no_output_of_prior_pics_flag = 0;", "         }", "         ff_hevc_clear_refs(s);", "         ret = set_sps(s, sps, sps->pix_fmt);", "         if (ret < 0)", "             return ret;", "         pix_fmt = get_format(s, sps);", "         if (pix_fmt < 0)", "             return pix_fmt;", "         s->avctx->pix_fmt = pix_fmt;", "         s->seq_decode = (s->seq_decode + 1) & 0xff;", "         s->max_ra     = INT_MAX;", "     }", "     sh->dependent_slice_segment_flag = 0;", "     if (!sh->first_slice_in_pic_flag) {", "         int slice_address_length;", "         if (s->ps.pps->dependent_slice_segments_enabled_flag)", "             sh->dependent_slice_segment_flag = get_bits1(gb);", "         slice_address_length = av_ceil_log2(s->ps.sps->ctb_width *", "                                             s->ps.sps->ctb_height);", "         sh->slice_segment_addr = get_bitsz(gb, slice_address_length);", "         if (sh->slice_segment_addr >= s->ps.sps->ctb_width * s->ps.sps->ctb_height) {", "             av_log(s->avctx, AV_LOG_ERROR,", "                    \"Invalid slice segment address: %u.\\n\",", "                    sh->slice_segment_addr);", "             return AVERROR_INVALIDDATA;", "         }", "         if (!sh->dependent_slice_segment_flag) {", "             sh->slice_addr = sh->slice_segment_addr;", "             s->slice_idx++;", "         }", "     } else {", "         sh->slice_segment_addr = sh->slice_addr = 0;", "         s->slice_idx           = 0;", "         s->slice_initialized   = 0;", "     }", "     if (!sh->dependent_slice_segment_flag) {", "         s->slice_initialized = 0;", "         for (i = 0; i < s->ps.pps->num_extra_slice_header_bits; i++)", "             skip_bits(gb, 1);   ", "         sh->slice_type = get_ue_golomb_long(gb);", "         if (!(sh->slice_type == HEVC_SLICE_I ||", "               sh->slice_type == HEVC_SLICE_P ||", "               sh->slice_type == HEVC_SLICE_B)) {", "             av_log(s->avctx, AV_LOG_ERROR, \"Unknown slice type: %d.\\n\",", "                    sh->slice_type);", "             return AVERROR_INVALIDDATA;", "         }", "         if (IS_IRAP(s) && sh->slice_type != HEVC_SLICE_I) {", "             av_log(s->avctx, AV_LOG_ERROR, \"Inter slices in an IRAP frame.\\n\");", "             return AVERROR_INVALIDDATA;", "         }", "         sh->pic_output_flag = 1;", "         if (s->ps.pps->output_flag_present_flag)", "             sh->pic_output_flag = get_bits1(gb);", "         if (s->ps.sps->separate_colour_plane_flag)", "             sh->colour_plane_id = get_bits(gb, 2);", "         if (!IS_IDR(s)) {", "             int poc, pos;", "             sh->pic_order_cnt_lsb = get_bits(gb, s->ps.sps->log2_max_poc_lsb);", "             poc = ff_hevc_compute_poc(s->ps.sps, s->pocTid0, sh->pic_order_cnt_lsb, s->nal_unit_type);", "             if (!sh->first_slice_in_pic_flag && poc != s->poc) {", "                 av_log(s->avctx, AV_LOG_WARNING,", "                        \"Ignoring POC change between slices: %d -> %d\\n\", s->poc, poc);", "                 if (s->avctx->err_recognition & AV_EF_EXPLODE)", "                     return AVERROR_INVALIDDATA;", "                 poc = s->poc;", "             }", "             s->poc = poc;", "             sh->short_term_ref_pic_set_sps_flag = get_bits1(gb);", "             pos = get_bits_left(gb);", "             if (!sh->short_term_ref_pic_set_sps_flag) {", "                 ret = ff_hevc_decode_short_term_rps(gb, s->avctx, &sh->slice_rps, s->ps.sps, 1);", "                 if (ret < 0)", "                     return ret;", "                 sh->short_term_rps = &sh->slice_rps;", "             } else {", "                 int numbits, rps_idx;", "                 if (!s->ps.sps->nb_st_rps) {", "                     av_log(s->avctx, AV_LOG_ERROR, \"No ref lists in the SPS.\\n\");", "                     return AVERROR_INVALIDDATA;", "                 }", "                 numbits = av_ceil_log2(s->ps.sps->nb_st_rps);", "                 rps_idx = numbits > 0 ? get_bits(gb, numbits) : 0;", "                 sh->short_term_rps = &s->ps.sps->st_rps[rps_idx];", "             }", "             sh->short_term_ref_pic_set_size = pos - get_bits_left(gb);", "             pos = get_bits_left(gb);", "             ret = decode_lt_rps(s, &sh->long_term_rps, gb);", "             if (ret < 0) {", "                 av_log(s->avctx, AV_LOG_WARNING, \"Invalid long term RPS.\\n\");", "                 if (s->avctx->err_recognition & AV_EF_EXPLODE)", "                     return AVERROR_INVALIDDATA;", "             }", "             sh->long_term_ref_pic_set_size = pos - get_bits_left(gb);", "             if (s->ps.sps->sps_temporal_mvp_enabled_flag)", "                 sh->slice_temporal_mvp_enabled_flag = get_bits1(gb);", "             else", "                 sh->slice_temporal_mvp_enabled_flag = 0;", "         } else {", "             s->sh.short_term_rps = NULL;", "             s->poc               = 0;", "         }", "         if (sh->first_slice_in_pic_flag && s->temporal_id == 0 &&", "             s->nal_unit_type != HEVC_NAL_TRAIL_N &&", "             s->nal_unit_type != HEVC_NAL_TSA_N   &&", "             s->nal_unit_type != HEVC_NAL_STSA_N  &&", "             s->nal_unit_type != HEVC_NAL_RADL_N  &&", "             s->nal_unit_type != HEVC_NAL_RADL_R  &&", "             s->nal_unit_type != HEVC_NAL_RASL_N  &&", "             s->nal_unit_type != HEVC_NAL_RASL_R)", "             s->pocTid0 = s->poc;", "         if (s->ps.sps->sao_enabled) {", "             sh->slice_sample_adaptive_offset_flag[0] = get_bits1(gb);", "             if (s->ps.sps->chroma_format_idc) {", "                 sh->slice_sample_adaptive_offset_flag[1] =", "                 sh->slice_sample_adaptive_offset_flag[2] = get_bits1(gb);", "             }", "         } else {", "             sh->slice_sample_adaptive_offset_flag[0] = 0;", "             sh->slice_sample_adaptive_offset_flag[1] = 0;", "             sh->slice_sample_adaptive_offset_flag[2] = 0;", "         }", "         sh->nb_refs[L0] = sh->nb_refs[L1] = 0;", "         if (sh->slice_type == HEVC_SLICE_P || sh->slice_type == HEVC_SLICE_B) {", "             int nb_refs;", "             sh->nb_refs[L0] = s->ps.pps->num_ref_idx_l0_default_active;", "             if (sh->slice_type == HEVC_SLICE_B)", "                 sh->nb_refs[L1] = s->ps.pps->num_ref_idx_l1_default_active;", "             if (get_bits1(gb)) {  ", "                 sh->nb_refs[L0] = get_ue_golomb_long(gb) + 1;", "                 if (sh->slice_type == HEVC_SLICE_B)", "                     sh->nb_refs[L1] = get_ue_golomb_long(gb) + 1;", "             }", "             if (sh->nb_refs[L0] > HEVC_MAX_REFS || sh->nb_refs[L1] > HEVC_MAX_REFS) {", "                 av_log(s->avctx, AV_LOG_ERROR, \"Too many refs: %d/%d.\\n\",", "                        sh->nb_refs[L0], sh->nb_refs[L1]);", "                 return AVERROR_INVALIDDATA;", "             }", "             sh->rpl_modification_flag[0] = 0;", "             sh->rpl_modification_flag[1] = 0;", "             nb_refs = ff_hevc_frame_nb_refs(s);", "             if (!nb_refs) {", "                 av_log(s->avctx, AV_LOG_ERROR, \"Zero refs for a frame with P or B slices.\\n\");", "                 return AVERROR_INVALIDDATA;", "             }", "             if (s->ps.pps->lists_modification_present_flag && nb_refs > 1) {", "                 sh->rpl_modification_flag[0] = get_bits1(gb);", "                 if (sh->rpl_modification_flag[0]) {", "                     for (i = 0; i < sh->nb_refs[L0]; i++)", "                         sh->list_entry_lx[0][i] = get_bits(gb, av_ceil_log2(nb_refs));", "                 }", "                 if (sh->slice_type == HEVC_SLICE_B) {", "                     sh->rpl_modification_flag[1] = get_bits1(gb);", "                     if (sh->rpl_modification_flag[1] == 1)", "                         for (i = 0; i < sh->nb_refs[L1]; i++)", "                             sh->list_entry_lx[1][i] = get_bits(gb, av_ceil_log2(nb_refs));", "                 }", "             }", "             if (sh->slice_type == HEVC_SLICE_B)", "                 sh->mvd_l1_zero_flag = get_bits1(gb);", "             if (s->ps.pps->cabac_init_present_flag)", "                 sh->cabac_init_flag = get_bits1(gb);", "             else", "                 sh->cabac_init_flag = 0;", "             sh->collocated_ref_idx = 0;", "             if (sh->slice_temporal_mvp_enabled_flag) {", "                 sh->collocated_list = L0;", "                 if (sh->slice_type == HEVC_SLICE_B)", "                     sh->collocated_list = !get_bits1(gb);", "                 if (sh->nb_refs[sh->collocated_list] > 1) {", "                     sh->collocated_ref_idx = get_ue_golomb_long(gb);", "                     if (sh->collocated_ref_idx >= sh->nb_refs[sh->collocated_list]) {", "                         av_log(s->avctx, AV_LOG_ERROR,", "                                \"Invalid collocated_ref_idx: %d.\\n\",", "                                sh->collocated_ref_idx);", "                         return AVERROR_INVALIDDATA;", "                     }", "                 }", "             }", "             if ((s->ps.pps->weighted_pred_flag   && sh->slice_type == HEVC_SLICE_P) ||", "                 (s->ps.pps->weighted_bipred_flag && sh->slice_type == HEVC_SLICE_B)) {", "                 int ret = pred_weight_table(s, gb);", "                 if (ret < 0)", "                     return ret;", "             }", "             sh->max_num_merge_cand = 5 - get_ue_golomb_long(gb);", "             if (sh->max_num_merge_cand < 1 || sh->max_num_merge_cand > 5) {", "                 av_log(s->avctx, AV_LOG_ERROR,", "                        \"Invalid number of merging MVP candidates: %d.\\n\",", "                        sh->max_num_merge_cand);", "                 return AVERROR_INVALIDDATA;", "             }", "         }", "         sh->slice_qp_delta = get_se_golomb(gb);", "         if (s->ps.pps->pic_slice_level_chroma_qp_offsets_present_flag) {", "             sh->slice_cb_qp_offset = get_se_golomb(gb);", "             sh->slice_cr_qp_offset = get_se_golomb(gb);", "         } else {", "             sh->slice_cb_qp_offset = 0;", "             sh->slice_cr_qp_offset = 0;", "         }", "         if (s->ps.pps->chroma_qp_offset_list_enabled_flag)", "             sh->cu_chroma_qp_offset_enabled_flag = get_bits1(gb);", "         else", "             sh->cu_chroma_qp_offset_enabled_flag = 0;", "         if (s->ps.pps->deblocking_filter_control_present_flag) {", "             int deblocking_filter_override_flag = 0;", "             if (s->ps.pps->deblocking_filter_override_enabled_flag)", "                 deblocking_filter_override_flag = get_bits1(gb);", "             if (deblocking_filter_override_flag) {", "                 sh->disable_deblocking_filter_flag = get_bits1(gb);", "                 if (!sh->disable_deblocking_filter_flag) {", "                     int beta_offset_div2 = get_se_golomb(gb);", "                     int tc_offset_div2   = get_se_golomb(gb) ;", "                     if (beta_offset_div2 < -6 || beta_offset_div2 > 6 ||", "                         tc_offset_div2   < -6 || tc_offset_div2   > 6) {", "                         av_log(s->avctx, AV_LOG_ERROR,", "                             \"Invalid deblock filter offsets: %d, %d\\n\",", "                             beta_offset_div2, tc_offset_div2);", "                         return AVERROR_INVALIDDATA;", "                     }", "                     sh->beta_offset = beta_offset_div2 * 2;", "                     sh->tc_offset   =   tc_offset_div2 * 2;", "                 }", "             } else {", "                 sh->disable_deblocking_filter_flag = s->ps.pps->disable_dbf;", "                 sh->beta_offset                    = s->ps.pps->beta_offset;", "                 sh->tc_offset                      = s->ps.pps->tc_offset;", "             }", "         } else {", "             sh->disable_deblocking_filter_flag = 0;", "             sh->beta_offset                    = 0;", "             sh->tc_offset                      = 0;", "         }", "         if (s->ps.pps->seq_loop_filter_across_slices_enabled_flag &&", "             (sh->slice_sample_adaptive_offset_flag[0] ||", "              sh->slice_sample_adaptive_offset_flag[1] ||", "              !sh->disable_deblocking_filter_flag)) {", "             sh->slice_loop_filter_across_slices_enabled_flag = get_bits1(gb);", "         } else {", "             sh->slice_loop_filter_across_slices_enabled_flag = s->ps.pps->seq_loop_filter_across_slices_enabled_flag;", "         }", "     } else if (!s->slice_initialized) {", "         av_log(s->avctx, AV_LOG_ERROR, \"Independent slice segment missing.\\n\");", "         return AVERROR_INVALIDDATA;", "     }", "     sh->num_entry_point_offsets = 0;", "     if (s->ps.pps->tiles_enabled_flag || s->ps.pps->entropy_coding_sync_enabled_flag) {", "         unsigned num_entry_point_offsets = get_ue_golomb_long(gb);", "         if (num_entry_point_offsets > get_bits_left(gb)) {", "             av_log(s->avctx, AV_LOG_ERROR, \"num_entry_point_offsets %d is invalid\\n\", num_entry_point_offsets);", "             return AVERROR_INVALIDDATA;", "         }", "         sh->num_entry_point_offsets = num_entry_point_offsets;", "         if (sh->num_entry_point_offsets > 0) {", "             int offset_len = get_ue_golomb_long(gb) + 1;", "             if (offset_len < 1 || offset_len > 32) {", "                 sh->num_entry_point_offsets = 0;", "                 av_log(s->avctx, AV_LOG_ERROR, \"offset_len %d is invalid\\n\", offset_len);", "                 return AVERROR_INVALIDDATA;", "             }", "             av_freep(&sh->entry_point_offset);", "             av_freep(&sh->offset);", "             av_freep(&sh->size);", "             sh->entry_point_offset = av_malloc_array(sh->num_entry_point_offsets, sizeof(unsigned));", "             sh->offset = av_malloc_array(sh->num_entry_point_offsets, sizeof(int));", "             sh->size = av_malloc_array(sh->num_entry_point_offsets, sizeof(int));", "             if (!sh->entry_point_offset || !sh->offset || !sh->size) {", "                 sh->num_entry_point_offsets = 0;", "                 av_log(s->avctx, AV_LOG_ERROR, \"Failed to allocate memory\\n\");", "                 return AVERROR(ENOMEM);", "             }", "             for (i = 0; i < sh->num_entry_point_offsets; i++) {", "                 unsigned val = get_bits_long(gb, offset_len);", "                 sh->entry_point_offset[i] = val + 1;  ", "             }", "             if (s->threads_number > 1 && (s->ps.pps->num_tile_rows > 1 || s->ps.pps->num_tile_columns > 1)) {", "                 s->enable_parallel_tiles = 0;  ", "                 s->threads_number = 1;", "             } else", "                 s->enable_parallel_tiles = 0;", "         } else", "             s->enable_parallel_tiles = 0;", "     }", "     if (s->ps.pps->slice_header_extension_present_flag) {", "         unsigned int length = get_ue_golomb_long(gb);", "         if (length*8LL > get_bits_left(gb)) {", "             av_log(s->avctx, AV_LOG_ERROR, \"too many slice_header_extension_data_bytes\\n\");", "             return AVERROR_INVALIDDATA;", "         }", "         for (i = 0; i < length; i++)", "             skip_bits(gb, 8);   ", "     }", "     sh->slice_qp = 26U + s->ps.pps->pic_init_qp_minus26 + sh->slice_qp_delta;", "     if (sh->slice_qp > 51 ||", "         sh->slice_qp < -s->ps.sps->qp_bd_offset) {", "         av_log(s->avctx, AV_LOG_ERROR,", "                \"The slice_qp %d is outside the valid range \"", "                \"[%d, 51].\\n\",", "                sh->slice_qp,", "                -s->ps.sps->qp_bd_offset);", "         return AVERROR_INVALIDDATA;", "     }", "     sh->slice_ctb_addr_rs = sh->slice_segment_addr;", "     if (!s->sh.slice_ctb_addr_rs && s->sh.dependent_slice_segment_flag) {", "         av_log(s->avctx, AV_LOG_ERROR, \"Impossible slice segment.\\n\");", "         return AVERROR_INVALIDDATA;", "     }", "     if (get_bits_left(gb) < 0) {", "         av_log(s->avctx, AV_LOG_ERROR,", "                \"Overread slice header by %d bits\\n\", -get_bits_left(gb));", "         return AVERROR_INVALIDDATA;", "     }", "     s->HEVClc->first_qp_group = !s->sh.dependent_slice_segment_flag;", "     if (!s->ps.pps->cu_qp_delta_enabled_flag)", "         s->HEVClc->qp_y = s->sh.slice_qp;", "     s->slice_initialized = 1;", "     s->HEVClc->tu.cu_qp_offset_cb = 0;", "     s->HEVClc->tu.cu_qp_offset_cr = 0;", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" processInternalEntity(XML_Parser parser, ENTITY *entity, XML_Bool betweenDecl) {", "   const char *textStart, *textEnd;", "   const char *next;", "   enum XML_Error result;", "   OPEN_INTERNAL_ENTITY *openEntity;", "   if (parser->m_freeInternalEntities) {", "     openEntity = parser->m_freeInternalEntities;", "     parser->m_freeInternalEntities = openEntity->next;", "   } else {", "     openEntity", "         = (OPEN_INTERNAL_ENTITY *)MALLOC(parser, sizeof(OPEN_INTERNAL_ENTITY));", "     if (! openEntity)", "       return XML_ERROR_NO_MEMORY;", "   }", "   entity->open = XML_TRUE;", "   entity->processed = 0;", "   openEntity->next = parser->m_openInternalEntities;", "   parser->m_openInternalEntities = openEntity;", "   openEntity->entity = entity;", "   openEntity->startTagLevel = parser->m_tagLevel;", "   openEntity->betweenDecl = betweenDecl;", "   openEntity->internalEventPtr = NULL;", "   openEntity->internalEventEndPtr = NULL;", "   textStart = (char *)entity->textPtr;", "   textEnd = (char *)(entity->textPtr + entity->textLen);", "   next = textStart;", " #ifdef XML_DTD", "   if (entity->is_param) {", "      int tok", "          = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);", "      result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,", "                      tok, next, &next, XML_FALSE);", "                       tok, next, &next, XML_FALSE, XML_FALSE);", "    } else", "  #endif  ", "      result = doContent(parser, parser->m_tagLevel, parser->m_internalEncoding,", "                        textStart, textEnd, &next, XML_FALSE);", "   if (result == XML_ERROR_NONE) {", "     if (textEnd != next && parser->m_parsingStatus.parsing == XML_SUSPENDED) {", "       entity->processed = (int)(next - textStart);", "       parser->m_processor = internalEntityProcessor;", "     } else {", "       entity->open = XML_FALSE;", "       parser->m_openInternalEntities = openEntity->next;", "       openEntity->next = parser->m_freeInternalEntities;", "       parser->m_freeInternalEntities = openEntity;", "     }", "   }", "   return result;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" create_bits (pixman_format_code_t format,", "              int                  width,", "              int                  height,", "              int *\t\t  rowstride_bytes,", " \t     pixman_bool_t\t  clear)", " {", "     int stride;", "     size_t buf_size;", "     int bpp;", "     bpp = PIXMAN_FORMAT_BPP (format);", "     if (_pixman_multiply_overflows_int (width, bpp))", " \treturn NULL;", "     stride = width * bpp;", "     if (_pixman_addition_overflows_int (stride, 0x1f))", " \treturn NULL;", "     stride += 0x1f;", "     stride >>= 5;", "     stride *= sizeof (uint32_t);", "      if (_pixman_multiply_overflows_size (height, stride))", "  \treturn NULL;", "    buf_size = height * stride;", "     buf_size = (size_t)height * stride;", "      if (rowstride_bytes)", "  \t*rowstride_bytes = stride;", "     if (clear)", " \treturn calloc (buf_size, 1);", "     else", " \treturn malloc (buf_size);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  int __glXDispSwap_CreateContext(__GLXclientState *cl, GLbyte *pc)", "  {", "     ClientPtr client = cl->client;", "      xGLXCreateContextReq *req = (xGLXCreateContextReq *) pc;", "      __GLX_DECLARE_SWAP_VARIABLES;", "     REQUEST_SIZE_MATCH(xGLXCreateContextReq);", "      __GLX_SWAP_SHORT(&req->length);", "      __GLX_SWAP_INT(&req->context);", "      __GLX_SWAP_INT(&req->visual);", "     return __glXDisp_CreateContext(cl, pc);", " }"], "ner_tags": [0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": [" epass2003_sm_unwrap_apdu(struct sc_card *card, struct sc_apdu *sm, struct sc_apdu *plain)", " {", " \tint r;", " \tsize_t len = 0;", " \tepass2003_exdata *exdata = NULL;", " \tif (!card->drv_data) ", " \t\treturn SC_ERROR_INVALID_ARGUMENTS;", " \texdata = (epass2003_exdata *)card->drv_data;", " \tLOG_FUNC_CALLED(card->ctx);", "  \tr = sc_check_sw(card, sm->sw1, sm->sw2);", "  \tif (r == SC_SUCCESS) {", "  \t\tif (exdata->sm) {", " \t\t\tlen = plain->resplen;", "  \t\t\tif (0 != decrypt_response(card, sm->resp, sm->resplen, plain->resp, &len))", "  \t\t\t\treturn SC_ERROR_CARD_CMD_FAILED;", "  \t\t}", " \t\telse {", " \t\t\tmemcpy(plain->resp, sm->resp, sm->resplen);", " \t\t\tlen = sm->resplen;", " \t\t}", " \t}", " \tplain->resplen = len;", " \tplain->sw1 = sm->sw1;", " \tplain->sw2 = sm->sw2;", " \tsc_log(card->ctx,", " \t       \"unwrapped APDU: resplen %\"SC_FORMAT_LEN_SIZE_T\"u, SW %02X%02X\",", " \t       plain->resplen, plain->sw1, plain->sw2);", " \tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int http_buf_read(URLContext *h, uint8_t *buf, int size)", " {", "     HTTPContext *s = h->priv_data;", "     int len;", "     len = s->buf_end - s->buf_ptr;", "     if (len > 0) {", "         if (len > size)", "             len = size;", "          memcpy(buf, s->buf_ptr, len);", "          s->buf_ptr += len;", "      } else {", "        int64_t target_end = s->end_off ? s->end_off : s->filesize;", "        if ((!s->willclose || s->chunksize < 0) &&", "            target_end >= 0 && s->off >= target_end)", "         uint64_t target_end = s->end_off ? s->end_off : s->filesize;", "         if ((!s->willclose || s->chunksize == UINT64_MAX) && s->off >= target_end)", "              return AVERROR_EOF;", "          len = ffurl_read(s->hd, buf, size);", "        if (!len && (!s->willclose || s->chunksize < 0) &&", "            target_end >= 0 && s->off < target_end) {", "         if (!len && (!s->willclose || s->chunksize == UINT64_MAX) && s->off < target_end) {", "              av_log(h, AV_LOG_ERROR,", "                   \"Stream ends prematurely at %\"PRId64\", should be %\"PRId64\"\\n\",", "                    \"Stream ends prematurely at %\"PRIu64\", should be %\"PRIu64\"\\n\",", "                     s->off, target_end", "                    );", "              return AVERROR(EIO);", "         }", "     }", "     if (len > 0) {", "         s->off += len;", "         if (s->chunksize > 0)", "             s->chunksize -= len;", "     }", "     return len;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int enum_dir(sc_path_t path, int depth)", "  {", "  \tsc_file_t *file;", "  \tint r, file_type;", "\tu8 files[SC_MAX_APDU_BUFFER_SIZE];", " \tu8 files[SC_MAX_EXT_APDU_BUFFER_SIZE];", "  \tr = sc_lock(card);", "  \tif (r == SC_SUCCESS)", " \t\tr = sc_select_file(card, &path, &file);", " \tsc_unlock(card);", " \tif (r) {", " \t\tfprintf(stderr, \"SELECT FILE failed: %s\\n\", sc_strerror(r));", " \t\treturn 1;", " \t}", " \tprint_file(card, file, &path, depth);", " \tfile_type = file->type;", " \tsc_file_free(file);", " \tif (file_type == SC_FILE_TYPE_DF) {", " \t\tint i;", " \t\tr = sc_lock(card);", " \t\tif (r == SC_SUCCESS)", " \t\t\tr = sc_list_files(card, files, sizeof(files));", " \t\tsc_unlock(card);", " \t\tif (r < 0) {", " \t\t\tfprintf(stderr, \"sc_list_files() failed: %s\\n\", sc_strerror(r));", " \t\t\treturn 1;", "  \t\t}", "  \t\tif (r == 0) {", "  \t\t\tprintf(\"Empty directory\\n\");", "\t\t} else", "\t\tfor (i = 0; i < r/2; i++) {", "\t\t\tsc_path_t tmppath;", "\t\t\tmemset(&tmppath, 0, sizeof(tmppath));", "\t\t\tmemcpy(&tmppath, &path, sizeof(path));", "\t\t\tmemcpy(tmppath.value + tmppath.len, files + 2*i, 2);", "\t\t\ttmppath.len += 2;", "\t\t\tenum_dir(tmppath, depth + 1);", " \t\t} else {", " \t\t\tfor (i = 0; i < r/2; i++) {", " \t\t\t\tsc_path_t tmppath;", " \t\t\t\tmemset(&tmppath, 0, sizeof(tmppath));", " \t\t\t\tmemcpy(&tmppath, &path, sizeof(path));", " \t\t\t\tmemcpy(tmppath.value + tmppath.len, files + 2*i, 2);", " \t\t\t\ttmppath.len += 2;", " \t\t\t\tenum_dir(tmppath, depth + 1);", " \t\t\t}", "  \t\t}", "  \t}", "  \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": ["  static int pgx_gethdr(jas_stream_t *in, pgx_hdr_t *hdr)", "  {", "  \tint c;", "\tuchar buf[2];", " \tjas_uchar buf[2];", "  \tif ((c = jas_stream_getc(in)) == EOF) {", "  \t\tgoto error;", " \t}", " \tbuf[0] = c;", " \tif ((c = jas_stream_getc(in)) == EOF) {", " \t\tgoto error;", " \t}", " \tbuf[1] = c;", " \thdr->magic = buf[0] << 8 | buf[1];", " \tif (hdr->magic != PGX_MAGIC) {", " \t\tjas_eprintf(\"invalid PGX signature\\n\");", " \t\tgoto error;", " \t}", " \tif ((c = pgx_getc(in)) == EOF || !isspace(c)) {", " \t\tgoto error;", " \t}", " \tif (pgx_getbyteorder(in, &hdr->bigendian)) {", " \t\tjas_eprintf(\"cannot get byte order\\n\");", " \t\tgoto error;", " \t}", " \tif (pgx_getsgnd(in, &hdr->sgnd)) {", " \t\tjas_eprintf(\"cannot get signedness\\n\");", " \t\tgoto error;", " \t}", " \tif (pgx_getuint32(in, &hdr->prec)) {", " \t\tjas_eprintf(\"cannot get precision\\n\");", " \t\tgoto error;", " \t}", " \tif (pgx_getuint32(in, &hdr->width)) {", " \t\tjas_eprintf(\"cannot get width\\n\");", " \t\tgoto error;", " \t}", " \tif (pgx_getuint32(in, &hdr->height)) {", " \t\tjas_eprintf(\"cannot get height\\n\");", " \t\tgoto error;", " \t}", " \treturn 0;", " error:", " \treturn -1;", " }"], "ner_tags": [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" sc_pkcs15emu_esteid_init (sc_pkcs15_card_t * p15card)", " {", " \tsc_card_t *card = p15card->card;", " \tunsigned char buff[128];", " \tint r, i;", " \tsize_t field_length = 0, modulus_length = 0;", " \tsc_path_t tmppath;", " \tset_string (&p15card->tokeninfo->label, \"ID-kaart\");", " \tset_string (&p15card->tokeninfo->manufacturer_id, \"AS Sertifitseerimiskeskus\");", " \tsc_format_path (\"3f00eeee5044\", &tmppath);", " \tr = sc_select_file (card, &tmppath, NULL);", " \tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"select esteid PD failed\");", "  \tr = sc_read_record (card, SC_ESTEID_PD_DOCUMENT_NR, buff, sizeof(buff), SC_RECORD_BY_REC_NR);", "  \tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"read document number failed\");", "\tbuff[r] = '\\0';", " \tbuff[MIN((size_t) r, (sizeof buff)-1)] = '\\0';", "  \tset_string (&p15card->tokeninfo->serial_number, (const char *) buff);", "  \tp15card->tokeninfo->flags = SC_PKCS15_TOKEN_PRN_GENERATION", " \t\t\t\t  | SC_PKCS15_TOKEN_EID_COMPLIANT", " \t\t\t\t  | SC_PKCS15_TOKEN_READONLY;", " \tfor (i = 0; i < 2; i++) {", " \t\tstatic const char *esteid_cert_names[2] = {", " \t\t\t\"Isikutuvastus\",", " \t\t\t\"Allkirjastamine\"};", " \t\tstatic char const *esteid_cert_paths[2] = {", " \t\t\t\"3f00eeeeaace\",", " \t\t\t\"3f00eeeeddce\"};", " \t\tstatic int esteid_cert_ids[2] = {1, 2};", " \t\tstruct sc_pkcs15_cert_info cert_info;", " \t\tstruct sc_pkcs15_object cert_obj;", " \t\tmemset(&cert_info, 0, sizeof(cert_info));", " \t\tmemset(&cert_obj, 0, sizeof(cert_obj));", " \t\tcert_info.id.value[0] = esteid_cert_ids[i];", " \t\tcert_info.id.len = 1;", " \t\tsc_format_path(esteid_cert_paths[i], &cert_info.path);", " \t\tstrlcpy(cert_obj.label, esteid_cert_names[i], sizeof(cert_obj.label));", " \t\tr = sc_pkcs15emu_add_x509_cert(p15card, &cert_obj, &cert_info);", " \t\tif (r < 0)", " \t\t\treturn SC_ERROR_INTERNAL;", " \t\tif (i == 0) {", " \t\t\tsc_pkcs15_cert_t *cert = NULL;", " \t\t\tr = sc_pkcs15_read_certificate(p15card, &cert_info, &cert);", " \t\t\tif (r < 0)", " \t\t\t\treturn SC_ERROR_INTERNAL;", " \t\t\tif (cert->key->algorithm == SC_ALGORITHM_EC)", " \t\t\t\tfield_length = cert->key->u.ec.params.field_length;", " \t\t\telse", " \t\t\t\tmodulus_length = cert->key->u.rsa.modulus.len * 8;", " \t\t\tif (r == SC_SUCCESS) {", " \t\t\t\tstatic const struct sc_object_id cn_oid = {{ 2, 5, 4, 3, -1 }};", " \t\t\t\tu8 *cn_name = NULL;", " \t\t\t\tsize_t cn_len = 0;", " \t\t\t\tsc_pkcs15_get_name_from_dn(card->ctx, cert->subject,", " \t\t\t\t\tcert->subject_len, &cn_oid, &cn_name, &cn_len);", " \t\t\t\tif (cn_len > 0) {", " \t\t\t\t\tchar *token_name = malloc(cn_len+1);", " \t\t\t\t\tif (token_name) {", " \t\t\t\t\t\tmemcpy(token_name, cn_name, cn_len);", " \t\t\t\t\t\ttoken_name[cn_len] = '\\0';", " \t\t\t\t\t\tset_string(&p15card->tokeninfo->label, (const char*)token_name);", " \t\t\t\t\t\tfree(token_name);", " \t\t\t\t\t}", " \t\t\t\t}", " \t\t\t\tfree(cn_name);", " \t\t\t\tsc_pkcs15_free_certificate(cert);", " \t\t\t}", " \t\t}", " \t}", " \tsc_format_path (\"3f000016\", &tmppath);", " \tr = sc_select_file (card, &tmppath, NULL);", " \tif (r < 0)", " \t\treturn SC_ERROR_INTERNAL;", " \tfor (i = 0; i < 3; i++) {", " \t\tunsigned char tries_left;", " \t\tstatic const char *esteid_pin_names[3] = {", " \t\t\t\"PIN1\",", " \t\t\t\"PIN2\",", " \t\t\t\"PUK\" };", " \t\tstatic const int esteid_pin_min[3] = {4, 5, 8};", " \t\tstatic const int esteid_pin_ref[3] = {1, 2, 0};", " \t\tstatic const int esteid_pin_authid[3] = {1, 2, 3};", " \t\tstatic const int esteid_pin_flags[3] = {0, 0, SC_PKCS15_PIN_FLAG_UNBLOCKING_PIN};", " \t\tstruct sc_pkcs15_auth_info pin_info;", " \t\tstruct sc_pkcs15_object pin_obj;", " \t\tmemset(&pin_info, 0, sizeof(pin_info));", " \t\tmemset(&pin_obj, 0, sizeof(pin_obj));", " \t\tr = sc_read_record (card, i + 1, buff, sizeof(buff), SC_RECORD_BY_REC_NR);", " \t\tif (r < 0)", " \t\t\treturn SC_ERROR_INTERNAL;", " \t\ttries_left = buff[5];", " \t\tpin_info.auth_id.len = 1;", " \t\tpin_info.auth_id.value[0] = esteid_pin_authid[i];", " \t\tpin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;", " \t\tpin_info.attrs.pin.reference = esteid_pin_ref[i];", " \t\tpin_info.attrs.pin.flags = esteid_pin_flags[i];", " \t\tpin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;", " \t\tpin_info.attrs.pin.min_length = esteid_pin_min[i];", " \t\tpin_info.attrs.pin.stored_length = 12;", " \t\tpin_info.attrs.pin.max_length = 12;", " \t\tpin_info.attrs.pin.pad_char = '\\0';", " \t\tpin_info.tries_left = (int)tries_left;", " \t\tpin_info.max_tries = 3;", " \t\tstrlcpy(pin_obj.label, esteid_pin_names[i], sizeof(pin_obj.label));", " \t\tpin_obj.flags = esteid_pin_flags[i];", " \t\tif (i < 2) {", " \t\t\tpin_obj.auth_id.len = 1;", " \t\t\tpin_obj.auth_id.value[0] = 3;", " \t\t}", " \t\tr = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);", " \t\tif (r < 0)", " \t\t\treturn SC_ERROR_INTERNAL;", " \t}", " \tfor (i = 0; i < 2; i++) {", " \t\tstatic int prkey_pin[2] = {1, 2};", " \t\tstatic const char *prkey_name[2] = {", " \t\t\t\"Isikutuvastus\",", " \t\t\t\"Allkirjastamine\"};", " \t\tstruct sc_pkcs15_prkey_info prkey_info;", " \t\tstruct sc_pkcs15_object prkey_obj;", " \t\tmemset(&prkey_info, 0, sizeof(prkey_info));", " \t\tmemset(&prkey_obj, 0, sizeof(prkey_obj));", " \t\tprkey_info.id.len = 1;", " \t\tprkey_info.id.value[0] = prkey_pin[i];", " \t\tprkey_info.native = 1;", " \t\tprkey_info.key_reference = i + 1;", " \t\tprkey_info.field_length = field_length;", " \t\tprkey_info.modulus_length = modulus_length;", " \t\tif (i == 1)", " \t\t\tprkey_info.usage = SC_PKCS15_PRKEY_USAGE_NONREPUDIATION;", " \t\telse if(field_length > 0)  ", " \t\t\tprkey_info.usage = SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_DERIVE;", " \t\telse", " \t\t\tprkey_info.usage = SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_ENCRYPT | SC_PKCS15_PRKEY_USAGE_DECRYPT;", " \t\tstrlcpy(prkey_obj.label, prkey_name[i], sizeof(prkey_obj.label));", " \t\tprkey_obj.auth_id.len = 1;", " \t\tprkey_obj.auth_id.value[0] = prkey_pin[i];", " \t\tprkey_obj.user_consent = 0;", " \t\tprkey_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE;", " \t\tif(field_length > 0)", " \t\t\tr = sc_pkcs15emu_add_ec_prkey(p15card, &prkey_obj, &prkey_info);", " \t\telse", " \t\t\tr = sc_pkcs15emu_add_rsa_prkey(p15card, &prkey_obj, &prkey_info);", " \t\tif (r < 0)", " \t\t\treturn SC_ERROR_INTERNAL;", " \t}", " \treturn SC_SUCCESS;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" SProcXSendExtensionEvent(ClientPtr client)", "  {", "      CARD32 *p;", "      int i;", "    xEvent eventT;", "     xEvent eventT = { .u.u.type = 0 };", "      xEvent *eventP;", "      EventSwapPtr proc;", "     REQUEST(xSendExtensionEventReq);", "     swaps(&stuff->length);", "     REQUEST_AT_LEAST_SIZE(xSendExtensionEventReq);", "     swapl(&stuff->destination);", "     swaps(&stuff->count);", "     if (stuff->length !=", "         bytes_to_int32(sizeof(xSendExtensionEventReq)) + stuff->count +", "         bytes_to_int32(stuff->num_events * sizeof(xEvent)))", "         return BadLength;", "     eventP = (xEvent *) &stuff[1];", "     for (i = 0; i < stuff->num_events; i++, eventP++) {", "         proc = EventSwapVector[eventP->u.u.type & 0177];", "         if (proc == NotImplemented)      ", "             return BadValue;", "         (*proc) (eventP, &eventT);", "         *eventP = eventT;", "     }", "     p = (CARD32 *) (((xEvent *) &stuff[1]) + stuff->num_events);", "     SwapLongs(p, stuff->count);", "     return (ProcXSendExtensionEvent(client));", " }"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" cleanup_pathname(struct archive_write_disk *a)", " cleanup_pathname_fsobj(char *path, int *error_number, struct archive_string *error_string, int flags)", "  {", "  \tchar *dest, *src;", "  \tchar separator = '\\0';", "\tdest = src = a->name;", " \tdest = src = path;", "  \tif (*src == '\\0') {", "\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,", "\t\t    \"Invalid empty pathname\");", " \t\tif (error_number) *error_number = ARCHIVE_ERRNO_MISC;", " \t\tif (error_string)", " \t\t    archive_string_sprintf(error_string,", " \t\t\t    \"Invalid empty pathname\");", "  \t\treturn (ARCHIVE_FAILED);", "  \t}", " #if defined(__CYGWIN__)", " \tcleanup_pathname_win(a);", "  #endif", "  \tif (*src == '/') {", "\t\tif (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {", "\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,", "\t\t\t                  \"Path is absolute\");", " \t\tif (flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {", " \t\t\tif (error_number) *error_number = ARCHIVE_ERRNO_MISC;", " \t\t\tif (error_string)", " \t\t\t    archive_string_sprintf(error_string,", " \t\t\t\t    \"Path is absolute\");", "  \t\t\treturn (ARCHIVE_FAILED);", "  \t\t}", " \t\tseparator = *src++;", " \t}", " \tfor (;;) {", " \t\tif (src[0] == '\\0') {", " \t\t\tbreak;", " \t\t} else if (src[0] == '/') {", " \t\t\tsrc++;", " \t\t\tcontinue;", " \t\t} else if (src[0] == '.') {", " \t\t\tif (src[1] == '\\0') {", " \t\t\t\tbreak;", " \t\t\t} else if (src[1] == '/') {", " \t\t\t\tsrc += 2;", " \t\t\t\tcontinue;", "  \t\t\t} else if (src[1] == '.') {", "  \t\t\t\tif (src[2] == '/' || src[2] == '\\0') {", "\t\t\t\t\tif (a->flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {", "\t\t\t\t\t\tarchive_set_error(&a->archive,", "\t\t\t\t\t\t    ARCHIVE_ERRNO_MISC,", "\t\t\t\t\t\t    \"Path contains '..'\");", " \t\t\t\t\tif (flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {", " \t\t\t\t\t\tif (error_number) *error_number = ARCHIVE_ERRNO_MISC;", " \t\t\t\t\t\tif (error_string)", " \t\t\t\t\t\t    archive_string_sprintf(error_string,", " \t\t\t\t\t\t\t    \"Path contains '..'\");", "  \t\t\t\t\t\treturn (ARCHIVE_FAILED);", "  \t\t\t\t\t}", "  \t\t\t\t}", " \t\t\t}", " \t\t}", " \t\tif (separator)", " \t\t\t*dest++ = '/';", " \t\twhile (*src != '\\0' && *src != '/') {", " \t\t\t*dest++ = *src++;", " \t\t}", " \t\tif (*src == '\\0')", " \t\t\tbreak;", " \t\tseparator = *src++;", " \t}", "\tif (dest == a->name) {", " \tif (dest == path) {", " \t\tif (separator)", " \t\t\t*dest++ = '/';", " \t\telse", " \t\t\t*dest++ = '.';", " \t}", " \t*dest = '\\0';", "  \treturn (ARCHIVE_OK);", "  }"], "ner_tags": [0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int jpc_pi_nextcprl(register jpc_pi_t *pi)", " {", " \tint rlvlno;", " \tjpc_pirlvl_t *pirlvl;", " \tjpc_pchg_t *pchg;", " \tint prchind;", " \tint prcvind;", " \tint *prclyrno;", " \tuint_fast32_t trx0;", " \tuint_fast32_t try0;", " \tuint_fast32_t r;", " \tuint_fast32_t rpx;", " \tuint_fast32_t rpy;", " \tpchg = pi->pchg;", " \tif (!pi->prgvolfirst) {", " \t\tgoto skip;", " \t} else {", " \t\tpi->prgvolfirst = 0;", " \t}", " \tfor (pi->compno = pchg->compnostart, pi->picomp =", "  \t  &pi->picomps[pi->compno]; pi->compno < JAS_CAST(int, pchg->compnoend) && pi->compno < pi->numcomps; ++pi->compno,", "  \t  ++pi->picomp) {", "  \t\tpirlvl = pi->picomp->pirlvls;", "\t\tpi->xstep = pi->picomp->hsamp * (1 << (pirlvl->prcwidthexpn +", "\t\t  pi->picomp->numrlvls - 1));", "\t\tpi->ystep = pi->picomp->vsamp * (1 << (pirlvl->prcheightexpn +", "\t\t  pi->picomp->numrlvls - 1));", " \t\tpi->xstep = pi->picomp->hsamp * (JAS_CAST(uint_fast32_t, 1) <<", " \t\t  (pirlvl->prcwidthexpn + pi->picomp->numrlvls - 1));", " \t\tpi->ystep = pi->picomp->vsamp * (JAS_CAST(uint_fast32_t, 1) <<", " \t\t  (pirlvl->prcheightexpn + pi->picomp->numrlvls - 1));", "  \t\tfor (rlvlno = 1, pirlvl = &pi->picomp->pirlvls[1];", "  \t\t  rlvlno < pi->picomp->numrlvls; ++rlvlno, ++pirlvl) {", "\t\t\tpi->xstep = JAS_MIN(pi->xstep, pi->picomp->hsamp * (1 <<", "\t\t\t  (pirlvl->prcwidthexpn + pi->picomp->numrlvls -", "\t\t\t  rlvlno - 1)));", "\t\t\tpi->ystep = JAS_MIN(pi->ystep, pi->picomp->vsamp * (1 <<", "\t\t\t  (pirlvl->prcheightexpn + pi->picomp->numrlvls -", "\t\t\t  rlvlno - 1)));", " \t\t\tpi->xstep = JAS_MIN(pi->xstep, pi->picomp->hsamp *", " \t\t\t  (JAS_CAST(uint_fast32_t, 1) << (pirlvl->prcwidthexpn +", " \t\t\t  pi->picomp->numrlvls - rlvlno - 1)));", " \t\t\tpi->ystep = JAS_MIN(pi->ystep, pi->picomp->vsamp *", " \t\t\t  (JAS_CAST(uint_fast32_t, 1) << (pirlvl->prcheightexpn +", " \t\t\t  pi->picomp->numrlvls - rlvlno - 1)));", "  \t\t}", "  \t\tfor (pi->y = pi->ystart; pi->y < pi->yend;", "  \t\t  pi->y += pi->ystep - (pi->y % pi->ystep)) {", " \t\t\tfor (pi->x = pi->xstart; pi->x < pi->xend;", " \t\t\t  pi->x += pi->xstep - (pi->x % pi->xstep)) {", " \t\t\t\tfor (pi->rlvlno = pchg->rlvlnostart,", " \t\t\t\t  pi->pirlvl = &pi->picomp->pirlvls[pi->rlvlno];", " \t\t\t\t  pi->rlvlno < pi->picomp->numrlvls && pi->rlvlno <", " \t\t\t\t  pchg->rlvlnoend; ++pi->rlvlno, ++pi->pirlvl) {", " \t\t\t\t\tif (pi->pirlvl->numprcs == 0) {", " \t\t\t\t\t\tcontinue;", " \t\t\t\t\t}", " \t\t\t\t\tr = pi->picomp->numrlvls - 1 - pi->rlvlno;", " \t\t\t\t\ttrx0 = JPC_CEILDIV(pi->xstart, pi->picomp->hsamp << r);", " \t\t\t\t\ttry0 = JPC_CEILDIV(pi->ystart, pi->picomp->vsamp << r);", " \t\t\t\t\trpx = r + pi->pirlvl->prcwidthexpn;", " \t\t\t\t\trpy = r + pi->pirlvl->prcheightexpn;", " \t\t\t\t\tif (((pi->x == pi->xstart && ((trx0 << r) % (1 << rpx))) ||", " \t\t\t\t\t  !(pi->x % (pi->picomp->hsamp << rpx))) &&", " \t\t\t\t\t  ((pi->y == pi->ystart && ((try0 << r) % (1 << rpy))) ||", " \t\t\t\t\t  !(pi->y % (pi->picomp->vsamp << rpy)))) {", " \t\t\t\t\t\tprchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x, pi->picomp->hsamp", " \t\t\t\t\t\t  << r), pi->pirlvl->prcwidthexpn) - JPC_FLOORDIVPOW2(trx0,", " \t\t\t\t\t\t  pi->pirlvl->prcwidthexpn);", " \t\t\t\t\t\tprcvind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->y, pi->picomp->vsamp", " \t\t\t\t\t\t  << r), pi->pirlvl->prcheightexpn) - JPC_FLOORDIVPOW2(try0,", " \t\t\t\t\t\t  pi->pirlvl->prcheightexpn);", " \t\t\t\t\t\tpi->prcno = prcvind *", " \t\t\t\t\t\t  pi->pirlvl->numhprcs +", " \t\t\t\t\t\t  prchind;", " \t\t\t\t\t\tassert(pi->prcno <", " \t\t\t\t\t\t  pi->pirlvl->numprcs);", " \t\t\t\t\t\tfor (pi->lyrno = 0; pi->lyrno <", " \t\t\t\t\t\t  pi->numlyrs && pi->lyrno < JAS_CAST(int, pchg->lyrnoend); ++pi->lyrno) {", " \t\t\t\t\t\t\tprclyrno = &pi->pirlvl->prclyrnos[pi->prcno];", " \t\t\t\t\t\t\tif (pi->lyrno >= *prclyrno) {", " \t\t\t\t\t\t\t\t++(*prclyrno);", " \t\t\t\t\t\t\t\treturn 0;", " \t\t\t\t\t\t\t}", " skip:", " \t\t\t\t\t\t\t;", " \t\t\t\t\t\t}", " \t\t\t\t\t}", " \t\t\t\t}", " \t\t\t}", " \t\t}", " \t}", " \treturn 1;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" read_header(struct archive_read *a, struct archive_entry *entry,", "             char head_type)", " {", "   const void *h;", "   const char *p, *endp;", "   struct rar *rar;", "   struct rar_header rar_header;", "   struct rar_file_header file_header;", "   int64_t header_size;", "   unsigned filename_size, end;", "   char *filename;", "   char *strp;", "   char packed_size[8];", "   char unp_size[8];", "   int ttime;", "   struct archive_string_conv *sconv, *fn_sconv;", "   unsigned long crc32_val;", "   int ret = (ARCHIVE_OK), ret2;", "   rar = (struct rar *)(a->format->data);", "   sconv = rar->opt_sconv;", "   if (sconv == NULL) {", "     if (!rar->init_default_conversion) {", "       rar->sconv_default =", "           archive_string_default_conversion_for_read(", "             &(a->archive));", "       rar->init_default_conversion = 1;", "     }", "     sconv = rar->sconv_default;", "   }", "   if ((h = __archive_read_ahead(a, 7, NULL)) == NULL)", "     return (ARCHIVE_FATAL);", "   p = h;", "   memcpy(&rar_header, p, sizeof(rar_header));", "   rar->file_flags = archive_le16dec(rar_header.flags);", "   header_size = archive_le16dec(rar_header.size);", "   if (header_size < (int64_t)sizeof(file_header) + 7) {", "     archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", "       \"Invalid header size\");", "     return (ARCHIVE_FATAL);", "   }", "   crc32_val = crc32(0, (const unsigned char *)p + 2, 7 - 2);", "   __archive_read_consume(a, 7);", "   if (!(rar->file_flags & FHD_SOLID))", "   {", "     rar->compression_method = 0;", "     rar->packed_size = 0;", "     rar->unp_size = 0;", "     rar->mtime = 0;", "     rar->ctime = 0;", "     rar->atime = 0;", "     rar->arctime = 0;", "     rar->mode = 0;", "     memset(&rar->salt, 0, sizeof(rar->salt));", "     rar->atime = 0;", "     rar->ansec = 0;", "     rar->ctime = 0;", "     rar->cnsec = 0;", "     rar->mtime = 0;", "     rar->mnsec = 0;", "     rar->arctime = 0;", "     rar->arcnsec = 0;", "   }", "   else", "   {", "     archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", "                       \"RAR solid archive support unavailable.\");", "     return (ARCHIVE_FATAL);", "   }", "   if ((h = __archive_read_ahead(a, (size_t)header_size - 7, NULL)) == NULL)", "     return (ARCHIVE_FATAL);", "   crc32_val = crc32(crc32_val, h, (unsigned)(header_size - 7));", "   if ((crc32_val & 0xffff) != archive_le16dec(rar_header.crc)) {", "     archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", "       \"Header CRC error\");", "     return (ARCHIVE_FATAL);", "   }", "   p = h;", "   endp = p + header_size - 7;", "   memcpy(&file_header, p, sizeof(file_header));", "   p += sizeof(file_header);", "   rar->compression_method = file_header.method;", "   ttime = archive_le32dec(file_header.file_time);", "   rar->mtime = get_time(ttime);", "   rar->file_crc = archive_le32dec(file_header.file_crc);", "   if (rar->file_flags & FHD_PASSWORD)", "   {", " \tarchive_entry_set_is_data_encrypted(entry, 1);", " \trar->has_encrypted_entries = 1;", "     archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", "                       \"RAR encryption support unavailable.\");", "   }", "   if (rar->file_flags & FHD_LARGE)", "   {", "     memcpy(packed_size, file_header.pack_size, 4);", "     memcpy(packed_size + 4, p, 4);  ", "     p += 4;", "     memcpy(unp_size, file_header.unp_size, 4);", "     memcpy(unp_size + 4, p, 4);  ", "     p += 4;", "     rar->packed_size = archive_le64dec(&packed_size);", "     rar->unp_size = archive_le64dec(&unp_size);", "   }", "   else", "   {", "     rar->packed_size = archive_le32dec(file_header.pack_size);", "     rar->unp_size = archive_le32dec(file_header.unp_size);", "   }", "   if (rar->packed_size < 0 || rar->unp_size < 0)", "   {", "     archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", "                       \"Invalid sizes specified.\");", "     return (ARCHIVE_FATAL);", "   }", "   rar->bytes_remaining = rar->packed_size;", "   if (head_type == NEWSUB_HEAD) {", "     size_t distance = p - (const char *)h;", "     header_size += rar->packed_size;", "     if ((h = __archive_read_ahead(a, (size_t)header_size - 7, NULL)) == NULL)", "         return (ARCHIVE_FATAL);", "     p = h;", "     endp = p + header_size - 7;", "     p += distance;", "   }", "   filename_size = archive_le16dec(file_header.name_size);", "   if (p + filename_size > endp) {", "     archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", "       \"Invalid filename size\");", "     return (ARCHIVE_FATAL);", "   }", "   if (rar->filename_allocated < filename_size * 2 + 2) {", "     char *newptr;", "     size_t newsize = filename_size * 2 + 2;", "     newptr = realloc(rar->filename, newsize);", "     if (newptr == NULL) {", "       archive_set_error(&a->archive, ENOMEM,", "                         \"Couldn't allocate memory.\");", "       return (ARCHIVE_FATAL);", "     }", "     rar->filename = newptr;", "     rar->filename_allocated = newsize;", "   }", "   filename = rar->filename;", "   memcpy(filename, p, filename_size);", "   filename[filename_size] = '\\0';", "   if (rar->file_flags & FHD_UNICODE)", "   {", "     if (filename_size != strlen(filename))", "     {", "       unsigned char highbyte, flagbits, flagbyte;", "       unsigned fn_end, offset;", "       end = filename_size;", "       fn_end = filename_size * 2;", "       filename_size = 0;", "       offset = (unsigned)strlen(filename) + 1;", "       highbyte = *(p + offset++);", "       flagbits = 0;", "       flagbyte = 0;", "       while (offset < end && filename_size < fn_end)", "       {", "         if (!flagbits)", "         {", "           flagbyte = *(p + offset++);", "           flagbits = 8;", "         }", "         flagbits -= 2;", "         switch((flagbyte >> flagbits) & 3)", "         {", "           case 0:", "             filename[filename_size++] = '\\0';", "             filename[filename_size++] = *(p + offset++);", "             break;", "           case 1:", "             filename[filename_size++] = highbyte;", "             filename[filename_size++] = *(p + offset++);", "             break;", "           case 2:", "             filename[filename_size++] = *(p + offset + 1);", "             filename[filename_size++] = *(p + offset);", "             offset += 2;", "             break;", "           case 3:", "           {", "             char extra, high;", "             uint8_t length = *(p + offset++);", "             if (length & 0x80) {", "               extra = *(p + offset++);", "               high = (char)highbyte;", "             } else", "               extra = high = 0;", "             length = (length & 0x7f) + 2;", "             while (length && filename_size < fn_end) {", "               unsigned cp = filename_size >> 1;", "               filename[filename_size++] = high;", "               filename[filename_size++] = p[cp] + extra;", "               length--;", "             }", "           }", "           break;", "         }", "       }", "       if (filename_size > fn_end) {", "         archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", "           \"Invalid filename\");", "          return (ARCHIVE_FATAL);", "        }", "        filename[filename_size++] = '\\0';", "      filename[filename_size++] = '\\0';", "       filename[filename_size] = '\\0';", "       if (rar->sconv_utf16be == NULL) {", "         rar->sconv_utf16be = archive_string_conversion_from_charset(", "            &a->archive, \"UTF-16BE\", 1);", "         if (rar->sconv_utf16be == NULL)", "           return (ARCHIVE_FATAL);", "       }", "       fn_sconv = rar->sconv_utf16be;", "       strp = filename;", "       while (memcmp(strp, \"\\x00\\x00\", 2))", "       {", "         if (!memcmp(strp, \"\\x00\\\\\", 2))", "           *(strp + 1) = '/';", "         strp += 2;", "       }", "       p += offset;", "     } else {", "       if (rar->sconv_utf8 == NULL) {", "         rar->sconv_utf8 = archive_string_conversion_from_charset(", "            &a->archive, \"UTF-8\", 1);", "         if (rar->sconv_utf8 == NULL)", "           return (ARCHIVE_FATAL);", "       }", "       fn_sconv = rar->sconv_utf8;", "       while ((strp = strchr(filename, '\\\\')) != NULL)", "         *strp = '/';", "       p += filename_size;", "     }", "   }", "   else", "   {", "     fn_sconv = sconv;", "     while ((strp = strchr(filename, '\\\\')) != NULL)", "       *strp = '/';", "     p += filename_size;", "   }", "   if (rar->filename_save &&", "     filename_size == rar->filename_save_size &&", "     !memcmp(rar->filename, rar->filename_save, filename_size + 1))", "   {", "     __archive_read_consume(a, header_size - 7);", "     rar->cursor++;", "     if (rar->cursor >= rar->nodes)", "     {", "       rar->nodes++;", "       if ((rar->dbo =", "         realloc(rar->dbo, sizeof(*rar->dbo) * rar->nodes)) == NULL)", "       {", "         archive_set_error(&a->archive, ENOMEM, \"Couldn't allocate memory.\");", "         return (ARCHIVE_FATAL);", "       }", "       rar->dbo[rar->cursor].header_size = header_size;", "       rar->dbo[rar->cursor].start_offset = -1;", "       rar->dbo[rar->cursor].end_offset = -1;", "     }", "     if (rar->dbo[rar->cursor].start_offset < 0)", "     {", "       rar->dbo[rar->cursor].start_offset = a->filter->position;", "       rar->dbo[rar->cursor].end_offset = rar->dbo[rar->cursor].start_offset +", "         rar->packed_size;", "     }", "     return ret;", "   }", "   rar->filename_save = (char*)realloc(rar->filename_save,", "                                       filename_size + 1);", "   memcpy(rar->filename_save, rar->filename, filename_size + 1);", "   rar->filename_save_size = filename_size;", "   free(rar->dbo);", "   if ((rar->dbo = calloc(1, sizeof(*rar->dbo))) == NULL)", "   {", "     archive_set_error(&a->archive, ENOMEM, \"Couldn't allocate memory.\");", "     return (ARCHIVE_FATAL);", "   }", "   rar->dbo[0].header_size = header_size;", "   rar->dbo[0].start_offset = -1;", "   rar->dbo[0].end_offset = -1;", "   rar->cursor = 0;", "   rar->nodes = 1;", "   if (rar->file_flags & FHD_SALT)", "   {", "     if (p + 8 > endp) {", "       archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", "         \"Invalid header size\");", "       return (ARCHIVE_FATAL);", "     }", "     memcpy(rar->salt, p, 8);", "     p += 8;", "   }", "   if (rar->file_flags & FHD_EXTTIME) {", "     if (read_exttime(p, rar, endp) < 0) {", "       archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", "         \"Invalid header size\");", "       return (ARCHIVE_FATAL);", "     }", "   }", "   __archive_read_consume(a, header_size - 7);", "   rar->dbo[0].start_offset = a->filter->position;", "   rar->dbo[0].end_offset = rar->dbo[0].start_offset + rar->packed_size;", "   switch(file_header.host_os)", "   {", "   case OS_MSDOS:", "   case OS_OS2:", "   case OS_WIN32:", "     rar->mode = archive_le32dec(file_header.file_attr);", "     if (rar->mode & FILE_ATTRIBUTE_DIRECTORY)", "       rar->mode = AE_IFDIR | S_IXUSR | S_IXGRP | S_IXOTH;", "     else", "       rar->mode = AE_IFREG;", "     rar->mode |= S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;", "     break;", "   case OS_UNIX:", "   case OS_MAC_OS:", "   case OS_BEOS:", "     rar->mode = archive_le32dec(file_header.file_attr);", "     break;", "   default:", "     archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", "                       \"Unknown file attributes from RAR file's host OS\");", "     return (ARCHIVE_FATAL);", "   }", "   rar->bytes_uncopied = rar->bytes_unconsumed = 0;", "   rar->lzss.position = rar->offset = 0;", "   rar->offset_seek = 0;", "   rar->dictionary_size = 0;", "   rar->offset_outgoing = 0;", "   rar->br.cache_avail = 0;", "   rar->br.avail_in = 0;", "   rar->crc_calculated = 0;", "   rar->entry_eof = 0;", "   rar->valid = 1;", "   rar->is_ppmd_block = 0;", "   rar->start_new_table = 1;", "   free(rar->unp_buffer);", "   rar->unp_buffer = NULL;", "   rar->unp_offset = 0;", "   rar->unp_buffer_size = UNP_BUFFER_SIZE;", "   memset(rar->lengthtable, 0, sizeof(rar->lengthtable));", "   __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context, &g_szalloc);", "   rar->ppmd_valid = rar->ppmd_eod = 0;", "   if (head_type == NEWSUB_HEAD)", "     return ret;", "   archive_entry_set_mtime(entry, rar->mtime, rar->mnsec);", "   archive_entry_set_ctime(entry, rar->ctime, rar->cnsec);", "   archive_entry_set_atime(entry, rar->atime, rar->ansec);", "   archive_entry_set_size(entry, rar->unp_size);", "   archive_entry_set_mode(entry, rar->mode);", "   if (archive_entry_copy_pathname_l(entry, filename, filename_size, fn_sconv))", "   {", "     if (errno == ENOMEM)", "     {", "       archive_set_error(&a->archive, ENOMEM,", "                         \"Can't allocate memory for Pathname\");", "       return (ARCHIVE_FATAL);", "     }", "     archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", "                       \"Pathname cannot be converted from %s to current locale.\",", "                       archive_string_conversion_charset_name(fn_sconv));", "     ret = (ARCHIVE_WARN);", "   }", "   if (((rar->mode) & AE_IFMT) == AE_IFLNK)", "   {", "     rar->bytes_remaining = 0;", "     archive_entry_set_size(entry, 0);", "     if ((ret2 = read_symlink_stored(a, entry, sconv)) < (ARCHIVE_WARN))", "       return ret2;", "     if (ret > ret2)", "       ret = ret2;", "   }", "   if (rar->bytes_remaining == 0)", "     rar->entry_eof = 1;", "   return ret;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" varbit_in(PG_FUNCTION_ARGS)", " {", " \tchar\t   *input_string = PG_GETARG_CSTRING(0);", " #ifdef NOT_USED", " \tOid\t\t\ttypelem = PG_GETARG_OID(1);", " #endif", " \tint32\t\tatttypmod = PG_GETARG_INT32(2);", " \tVarBit\t   *result;\t\t\t ", " \tchar\t   *sp;\t\t\t\t ", " \tbits8\t   *r;\t\t\t\t ", " \tint\t\t\tlen,\t\t\t ", " \t\t\t\tbitlen,\t\t\t ", " \t\t\t\tslen;\t\t\t ", " \tbool\t\tbit_not_hex;\t ", " \tint\t\t\tbc;", " \tbits8\t\tx = 0;", " \tif (input_string[0] == 'b' || input_string[0] == 'B')", " \t{", " \t\tbit_not_hex = true;", " \t\tsp = input_string + 1;", " \t}", " \telse if (input_string[0] == 'x' || input_string[0] == 'X')", " \t{", " \t\tbit_not_hex = false;", " \t\tsp = input_string + 1;", " \t}", " \telse", " \t{", " \t\tbit_not_hex = true;", "  \t\tsp = input_string;", "  \t}", " \tslen = strlen(sp);", "  \tslen = strlen(sp);", "  \tif (bit_not_hex)", "  \t\tbitlen = slen;", "  \telse", " \t{", " \t\tif (slen > VARBITMAXLEN / 4)", " \t\t\tereport(ERROR,", " \t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),", " \t\t\t\t errmsg(\"bit string length exceeds the maximum allowed (%d)\",", " \t\t\t\t\t\tVARBITMAXLEN)));", "  \t\tbitlen = slen * 4;", " \t}", " \tif (atttypmod <= 0)", " \t\tatttypmod = bitlen;", " \telse if (bitlen > atttypmod)", " \t\tereport(ERROR,", " \t\t\t\t(errcode(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),", " \t\t\t\t errmsg(\"bit string too long for type bit varying(%d)\",", " \t\t\t\t\t\tatttypmod)));", " \tlen = VARBITTOTALLEN(bitlen);", " \tresult = (VarBit *) palloc0(len);", " \tSET_VARSIZE(result, len);", " \tVARBITLEN(result) = Min(bitlen, atttypmod);", " \tr = VARBITS(result);", " \tif (bit_not_hex)", " \t{", " \t\tx = HIGHBIT;", " \t\tfor (; *sp; sp++)", " \t\t{", " \t\t\tif (*sp == '1')", " \t\t\t\t*r |= x;", " \t\t\telse if (*sp != '0')", " \t\t\t\tereport(ERROR,", " \t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),", " \t\t\t\t\t\t errmsg(\"\\\"%c\\\" is not a valid binary digit\",", " \t\t\t\t\t\t\t\t*sp)));", " \t\t\tx >>= 1;", " \t\t\tif (x == 0)", " \t\t\t{", " \t\t\t\tx = HIGHBIT;", " \t\t\t\tr++;", " \t\t\t}", " \t\t}", " \t}", " \telse", " \t{", " \t\tfor (bc = 0; *sp; sp++)", " \t\t{", " \t\t\tif (*sp >= '0' && *sp <= '9')", " \t\t\t\tx = (bits8) (*sp - '0');", " \t\t\telse if (*sp >= 'A' && *sp <= 'F')", " \t\t\t\tx = (bits8) (*sp - 'A') + 10;", " \t\t\telse if (*sp >= 'a' && *sp <= 'f')", " \t\t\t\tx = (bits8) (*sp - 'a') + 10;", " \t\t\telse", " \t\t\t\tereport(ERROR,", " \t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),", " \t\t\t\t\t\t errmsg(\"\\\"%c\\\" is not a valid hexadecimal digit\",", " \t\t\t\t\t\t\t\t*sp)));", " \t\t\tif (bc)", " \t\t\t{", " \t\t\t\t*r++ |= x;", " \t\t\t\tbc = 0;", " \t\t\t}", " \t\t\telse", " \t\t\t{", " \t\t\t\t*r = x << 4;", " \t\t\t\tbc = 1;", " \t\t\t}", " \t\t}", " \t}", " \tPG_RETURN_VARBIT_P(result);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  SProcXFixesSelectCursorInput(ClientPtr client)", "  {", "      REQUEST(xXFixesSelectCursorInputReq);", "     REQUEST_SIZE_MATCH(xXFixesSelectCursorInputReq);", "      swaps(&stuff->length);", "      swapl(&stuff->window);", "     return (*ProcXFixesVector[stuff->xfixesReqType]) (client);", " }"], "ner_tags": [0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": [" static int decode_slice_header(H264Context *h, H264Context *h0)", " {", "     unsigned int first_mb_in_slice;", "     unsigned int pps_id;", "     int ret;", "     unsigned int slice_type, tmp, i, j;", "     int last_pic_structure, last_pic_droppable;", "     int must_reinit;", "     int needs_reinit = 0;", "     int field_pic_flag, bottom_field_flag;", "     h->me.qpel_put = h->h264qpel.put_h264_qpel_pixels_tab;", "     h->me.qpel_avg = h->h264qpel.avg_h264_qpel_pixels_tab;", "     first_mb_in_slice = get_ue_golomb_long(&h->gb);", "     if (first_mb_in_slice == 0) {  ", "         if (h0->current_slice && FIELD_PICTURE(h)) {", "             field_end(h, 1);", "         }", "         h0->current_slice = 0;", "         if (!h0->first_field) {", "             if (h->cur_pic_ptr && !h->droppable) {", "                 ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,", "                                           h->picture_structure == PICT_BOTTOM_FIELD);", "             }", "             h->cur_pic_ptr = NULL;", "         }", "     }", "     slice_type = get_ue_golomb_31(&h->gb);", "     if (slice_type > 9) {", "         av_log(h->avctx, AV_LOG_ERROR,", "                \"slice type too large (%d) at %d %d\\n\",", "                slice_type, h->mb_x, h->mb_y);", "         return AVERROR_INVALIDDATA;", "     }", "     if (slice_type > 4) {", "         slice_type -= 5;", "         h->slice_type_fixed = 1;", "     } else", "         h->slice_type_fixed = 0;", "     slice_type = golomb_to_pict_type[slice_type];", "     h->slice_type     = slice_type;", "     h->slice_type_nos = slice_type & 3;", "     h->pict_type = h->slice_type;", "     pps_id = get_ue_golomb(&h->gb);", "     if (pps_id >= MAX_PPS_COUNT) {", "         av_log(h->avctx, AV_LOG_ERROR, \"pps_id %d out of range\\n\", pps_id);", "         return AVERROR_INVALIDDATA;", "     }", "     if (!h0->pps_buffers[pps_id]) {", "         av_log(h->avctx, AV_LOG_ERROR,", "                \"non-existing PPS %u referenced\\n\",", "                pps_id);", "         return AVERROR_INVALIDDATA;", "     }", "     h->pps = *h0->pps_buffers[pps_id];", "     if (!h0->sps_buffers[h->pps.sps_id]) {", "         av_log(h->avctx, AV_LOG_ERROR,", "                \"non-existing SPS %u referenced\\n\",", "                h->pps.sps_id);", "         return AVERROR_INVALIDDATA;", "     }", "     if (h->pps.sps_id != h->current_sps_id ||", "         h0->sps_buffers[h->pps.sps_id]->new) {", "         h0->sps_buffers[h->pps.sps_id]->new = 0;", "         h->current_sps_id = h->pps.sps_id;", "         h->sps            = *h0->sps_buffers[h->pps.sps_id];", "         if (h->mb_width  != h->sps.mb_width ||", "             h->mb_height != h->sps.mb_height * (2 - h->sps.frame_mbs_only_flag) ||", "             h->avctx->bits_per_raw_sample != h->sps.bit_depth_luma ||", "             h->cur_chroma_format_idc != h->sps.chroma_format_idc", "         )", "             needs_reinit = 1;", "         if (h->bit_depth_luma    != h->sps.bit_depth_luma ||", "             h->chroma_format_idc != h->sps.chroma_format_idc) {", "             h->bit_depth_luma    = h->sps.bit_depth_luma;", "             h->chroma_format_idc = h->sps.chroma_format_idc;", "             needs_reinit         = 1;", "         }", "         if ((ret = h264_set_parameter_from_sps(h)) < 0)", "             return ret;", "     }", "     h->avctx->profile = ff_h264_get_profile(&h->sps);", "     h->avctx->level   = h->sps.level_idc;", "     h->avctx->refs    = h->sps.ref_frame_count;", "     must_reinit = (h->context_initialized &&", "                     (   16*h->sps.mb_width != h->avctx->coded_width", "                      || 16*h->sps.mb_height * (2 - h->sps.frame_mbs_only_flag) != h->avctx->coded_height", "                      || h->avctx->bits_per_raw_sample != h->sps.bit_depth_luma", "                      || h->cur_chroma_format_idc != h->sps.chroma_format_idc", "                      || av_cmp_q(h->sps.sar, h->avctx->sample_aspect_ratio)", "                      || h->mb_width  != h->sps.mb_width", "                      || h->mb_height != h->sps.mb_height * (2 - h->sps.frame_mbs_only_flag)", "                     ));", "     if (h0->avctx->pix_fmt != get_pixel_format(h0, 0))", "         must_reinit = 1;", "     h->mb_width  = h->sps.mb_width;", "     h->mb_height = h->sps.mb_height * (2 - h->sps.frame_mbs_only_flag);", "     h->mb_num    = h->mb_width * h->mb_height;", "     h->mb_stride = h->mb_width + 1;", "     h->b_stride = h->mb_width * 4;", "     h->chroma_y_shift = h->sps.chroma_format_idc <= 1;  ", "     h->width  = 16 * h->mb_width;", "     h->height = 16 * h->mb_height;", "     ret = init_dimensions(h);", "     if (ret < 0)", "         return ret;", "     if (h->sps.video_signal_type_present_flag) {", "         h->avctx->color_range = h->sps.full_range>0 ? AVCOL_RANGE_JPEG", "                                                     : AVCOL_RANGE_MPEG;", "         if (h->sps.colour_description_present_flag) {", "             if (h->avctx->colorspace != h->sps.colorspace)", "                 needs_reinit = 1;", "             h->avctx->color_primaries = h->sps.color_primaries;", "             h->avctx->color_trc       = h->sps.color_trc;", "             h->avctx->colorspace      = h->sps.colorspace;", "         }", "     }", "     if (h->context_initialized &&", "         (h->width  != h->avctx->coded_width   ||", "          h->height != h->avctx->coded_height  ||", "          must_reinit ||", "          needs_reinit)) {", "         if (h != h0) {", "             av_log(h->avctx, AV_LOG_ERROR, \"changing width/height on \"", "                    \"slice %d\\n\", h0->current_slice + 1);", "             return AVERROR_INVALIDDATA;", "         }", "         flush_change(h);", "         if ((ret = get_pixel_format(h, 1)) < 0)", "             return ret;", "         h->avctx->pix_fmt = ret;", "         av_log(h->avctx, AV_LOG_INFO, \"Reinit context to %dx%d, \"", "                \"pix_fmt: %s\\n\", h->width, h->height, av_get_pix_fmt_name(h->avctx->pix_fmt));", "         if ((ret = h264_slice_header_init(h, 1)) < 0) {", "             av_log(h->avctx, AV_LOG_ERROR,", "                    \"h264_slice_header_init() failed\\n\");", "             return ret;", "         }", "     }", "     if (!h->context_initialized) {", "         if (h != h0) {", "             av_log(h->avctx, AV_LOG_ERROR,", "                    \"Cannot (re-)initialize context during parallel decoding.\\n\");", "             return AVERROR_PATCHWELCOME;", "         }", "         if ((ret = get_pixel_format(h, 1)) < 0)", "             return ret;", "         h->avctx->pix_fmt = ret;", "         if ((ret = h264_slice_header_init(h, 0)) < 0) {", "             av_log(h->avctx, AV_LOG_ERROR,", "                    \"h264_slice_header_init() failed\\n\");", "             return ret;", "         }", "     }", "     if (h == h0 && h->dequant_coeff_pps != pps_id) {", "         h->dequant_coeff_pps = pps_id;", "         init_dequant_tables(h);", "     }", "     h->frame_num = get_bits(&h->gb, h->sps.log2_max_frame_num);", "     h->mb_mbaff        = 0;", "     h->mb_aff_frame    = 0;", "     last_pic_structure = h0->picture_structure;", "     last_pic_droppable = h0->droppable;", "     h->droppable       = h->nal_ref_idc == 0;", "     if (h->sps.frame_mbs_only_flag) {", "         h->picture_structure = PICT_FRAME;", "     } else {", "         if (!h->sps.direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B) {", "             av_log(h->avctx, AV_LOG_ERROR, \"This stream was generated by a broken encoder, invalid 8x8 inference\\n\");", "             return -1;", "         }", "         field_pic_flag = get_bits1(&h->gb);", "         if (field_pic_flag) {", "             bottom_field_flag = get_bits1(&h->gb);", "             h->picture_structure = PICT_TOP_FIELD + bottom_field_flag;", "         } else {", "             h->picture_structure = PICT_FRAME;", "             h->mb_aff_frame      = h->sps.mb_aff;", "         }", "     }", "     h->mb_field_decoding_flag = h->picture_structure != PICT_FRAME;", "     if (h0->current_slice != 0) {", "         if (last_pic_structure != h->picture_structure ||", "             last_pic_droppable != h->droppable) {", "             av_log(h->avctx, AV_LOG_ERROR,", "                    \"Changing field mode (%d -> %d) between slices is not allowed\\n\",", "                    last_pic_structure, h->picture_structure);", "             h->picture_structure = last_pic_structure;", "             h->droppable         = last_pic_droppable;", "             return AVERROR_INVALIDDATA;", "         } else if (!h0->cur_pic_ptr) {", "             av_log(h->avctx, AV_LOG_ERROR,", "                    \"unset cur_pic_ptr on %d. slice\\n\",", "                    h0->current_slice + 1);", "             return AVERROR_INVALIDDATA;", "         }", "     } else {", "         if (h->frame_num != h->prev_frame_num && h->prev_frame_num >= 0) {", "             int unwrap_prev_frame_num = h->prev_frame_num;", "             int max_frame_num         = 1 << h->sps.log2_max_frame_num;", "             if (unwrap_prev_frame_num > h->frame_num)", "                 unwrap_prev_frame_num -= max_frame_num;", "             if ((h->frame_num - unwrap_prev_frame_num) > h->sps.ref_frame_count) {", "                 unwrap_prev_frame_num = (h->frame_num - h->sps.ref_frame_count) - 1;", "                 if (unwrap_prev_frame_num < 0)", "                     unwrap_prev_frame_num += max_frame_num;", "                 h->prev_frame_num = unwrap_prev_frame_num;", "             }", "         }", "         if (h0->first_field) {", "             assert(h0->cur_pic_ptr);", "             assert(h0->cur_pic_ptr->f.data[0]);", "              assert(h0->cur_pic_ptr->reference != DELAYED_PIC_REF);", "            if (!last_pic_droppable && h0->cur_pic_ptr->tf.owner == h0->avctx) {", "             if (h0->cur_pic_ptr->tf.owner == h0->avctx) {", "                  ff_thread_report_progress(&h0->cur_pic_ptr->tf, INT_MAX,", "                                            last_pic_structure == PICT_BOTTOM_FIELD);", "              }", "              if (!FIELD_PICTURE(h) || h->picture_structure == last_pic_structure) {", "                if (!last_pic_droppable && last_pic_structure != PICT_FRAME) {", "                 if (last_pic_structure != PICT_FRAME) {", "                      ff_thread_report_progress(&h0->cur_pic_ptr->tf, INT_MAX,", "                                                last_pic_structure == PICT_TOP_FIELD);", "                  }", "             } else {", "                 if (h0->cur_pic_ptr->frame_num != h->frame_num) {", "                    if (!last_pic_droppable && last_pic_structure != PICT_FRAME) {", "                     if (last_pic_structure != PICT_FRAME) {", "                          ff_thread_report_progress(&h0->cur_pic_ptr->tf, INT_MAX,", "                                                    last_pic_structure == PICT_TOP_FIELD);", "                      }", "                 } else {", "                     if (!((last_pic_structure   == PICT_TOP_FIELD &&", "                            h->picture_structure == PICT_BOTTOM_FIELD) ||", "                           (last_pic_structure   == PICT_BOTTOM_FIELD &&", "                            h->picture_structure == PICT_TOP_FIELD))) {", "                         av_log(h->avctx, AV_LOG_ERROR,", "                                \"Invalid field mode combination %d/%d\\n\",", "                                last_pic_structure, h->picture_structure);", "                         h->picture_structure = last_pic_structure;", "                         h->droppable         = last_pic_droppable;", "                         return AVERROR_INVALIDDATA;", "                     } else if (last_pic_droppable != h->droppable) {", "                         avpriv_request_sample(h->avctx,", "                                               \"Found reference and non-reference fields in the same frame, which\");", "                         h->picture_structure = last_pic_structure;", "                         h->droppable         = last_pic_droppable;", "                         return AVERROR_PATCHWELCOME;", "                     }", "                 }", "             }", "         }", "         while (h->frame_num != h->prev_frame_num && h->prev_frame_num >= 0 && !h0->first_field &&", "                h->frame_num != (h->prev_frame_num + 1) % (1 << h->sps.log2_max_frame_num)) {", "             Picture *prev = h->short_ref_count ? h->short_ref[0] : NULL;", "             av_log(h->avctx, AV_LOG_DEBUG, \"Frame num gap %d %d\\n\",", "                    h->frame_num, h->prev_frame_num);", "             if (!h->sps.gaps_in_frame_num_allowed_flag)", "                 for(i=0; i<FF_ARRAY_ELEMS(h->last_pocs); i++)", "                     h->last_pocs[i] = INT_MIN;", "             ret = h264_frame_start(h);", "             if (ret < 0)", "                 return ret;", "             h->prev_frame_num++;", "             h->prev_frame_num        %= 1 << h->sps.log2_max_frame_num;", "             h->cur_pic_ptr->frame_num = h->prev_frame_num;", "             ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, 0);", "             ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, 1);", "             ret = ff_generate_sliding_window_mmcos(h, 1);", "             if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))", "                 return ret;", "             ret = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index);", "             if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))", "                 return ret;", "             if (h->short_ref_count) {", "                 if (prev) {", "                     av_image_copy(h->short_ref[0]->f.data,", "                                   h->short_ref[0]->f.linesize,", "                                   (const uint8_t **)prev->f.data,", "                                   prev->f.linesize,", "                                   h->avctx->pix_fmt,", "                                   h->mb_width  * 16,", "                                   h->mb_height * 16);", "                     h->short_ref[0]->poc = prev->poc + 2;", "                 }", "                 h->short_ref[0]->frame_num = h->prev_frame_num;", "             }", "         }", "         if (h0->first_field) {", "             assert(h0->cur_pic_ptr);", "             assert(h0->cur_pic_ptr->f.data[0]);", "             assert(h0->cur_pic_ptr->reference != DELAYED_PIC_REF);", "             if (!FIELD_PICTURE(h) || h->picture_structure == last_pic_structure) {", "                 h0->cur_pic_ptr = NULL;", "                 h0->first_field = FIELD_PICTURE(h);", "             } else {", "                 if (h0->cur_pic_ptr->frame_num != h->frame_num) {", "                     ff_thread_report_progress(&h0->cur_pic_ptr->tf, INT_MAX,", "                                               h0->picture_structure==PICT_BOTTOM_FIELD);", "                     h0->first_field = 1;", "                     h0->cur_pic_ptr = NULL;", "                 } else {", "                     h0->first_field = 0;", "                 }", "             }", "         } else {", "             h0->first_field = FIELD_PICTURE(h);", "         }", "         if (!FIELD_PICTURE(h) || h0->first_field) {", "             if (h264_frame_start(h) < 0) {", "                 h0->first_field = 0;", "                 return AVERROR_INVALIDDATA;", "             }", "         } else {", "             release_unused_pictures(h, 0);", "         }", "         if (FIELD_PICTURE(h)) {", "             for(i = (h->picture_structure == PICT_BOTTOM_FIELD); i<h->mb_height; i++)", "                 memset(h->slice_table + i*h->mb_stride, -1, (h->mb_stride - (i+1==h->mb_height)) * sizeof(*h->slice_table));", "         } else {", "             memset(h->slice_table, -1,", "                 (h->mb_height * h->mb_stride - 1) * sizeof(*h->slice_table));", "         }", "         h0->last_slice_type = -1;", "     }", "     if (h != h0 && (ret = clone_slice(h, h0)) < 0)", "         return ret;", "     for (i = 0; i < h->slice_context_count; i++)", "         if (h->thread_context[i]) {", "             ret = alloc_scratch_buffers(h->thread_context[i], h->linesize);", "             if (ret < 0)", "                 return ret;", "         }", "     h->cur_pic_ptr->frame_num = h->frame_num;  ", "     av_assert1(h->mb_num == h->mb_width * h->mb_height);", "     if (first_mb_in_slice << FIELD_OR_MBAFF_PICTURE(h) >= h->mb_num ||", "         first_mb_in_slice >= h->mb_num) {", "         av_log(h->avctx, AV_LOG_ERROR, \"first_mb_in_slice overflow\\n\");", "         return AVERROR_INVALIDDATA;", "     }", "     h->resync_mb_x = h->mb_x =  first_mb_in_slice % h->mb_width;", "     h->resync_mb_y = h->mb_y = (first_mb_in_slice / h->mb_width) <<", "                                FIELD_OR_MBAFF_PICTURE(h);", "     if (h->picture_structure == PICT_BOTTOM_FIELD)", "         h->resync_mb_y = h->mb_y = h->mb_y + 1;", "     av_assert1(h->mb_y < h->mb_height);", "     if (h->picture_structure == PICT_FRAME) {", "         h->curr_pic_num = h->frame_num;", "         h->max_pic_num  = 1 << h->sps.log2_max_frame_num;", "     } else {", "         h->curr_pic_num = 2 * h->frame_num + 1;", "         h->max_pic_num  = 1 << (h->sps.log2_max_frame_num + 1);", "     }", "     if (h->nal_unit_type == NAL_IDR_SLICE)", "         get_ue_golomb(&h->gb);  ", "     if (h->sps.poc_type == 0) {", "         h->poc_lsb = get_bits(&h->gb, h->sps.log2_max_poc_lsb);", "         if (h->pps.pic_order_present == 1 && h->picture_structure == PICT_FRAME)", "             h->delta_poc_bottom = get_se_golomb(&h->gb);", "     }", "     if (h->sps.poc_type == 1 && !h->sps.delta_pic_order_always_zero_flag) {", "         h->delta_poc[0] = get_se_golomb(&h->gb);", "         if (h->pps.pic_order_present == 1 && h->picture_structure == PICT_FRAME)", "             h->delta_poc[1] = get_se_golomb(&h->gb);", "     }", "     ff_init_poc(h, h->cur_pic_ptr->field_poc, &h->cur_pic_ptr->poc);", "     if (h->pps.redundant_pic_cnt_present)", "         h->redundant_pic_count = get_ue_golomb(&h->gb);", "     ret = ff_set_ref_count(h);", "     if (ret < 0)", "         return ret;", "     if (slice_type != AV_PICTURE_TYPE_I &&", "         (h0->current_slice == 0 ||", "          slice_type != h0->last_slice_type ||", "          memcmp(h0->last_ref_count, h0->ref_count, sizeof(h0->ref_count)))) {", "         ff_h264_fill_default_ref_list(h);", "     }", "     if (h->slice_type_nos != AV_PICTURE_TYPE_I) {", "        ret = ff_h264_decode_ref_pic_list_reordering(h);", "        if (ret < 0) {", "            h->ref_count[1] = h->ref_count[0] = 0;", "            return ret;", "        }", "     }", "     if ((h->pps.weighted_pred && h->slice_type_nos == AV_PICTURE_TYPE_P) ||", "         (h->pps.weighted_bipred_idc == 1 &&", "          h->slice_type_nos == AV_PICTURE_TYPE_B))", "         ff_pred_weight_table(h);", "     else if (h->pps.weighted_bipred_idc == 2 &&", "              h->slice_type_nos == AV_PICTURE_TYPE_B) {", "         implicit_weight_table(h, -1);", "     } else {", "         h->use_weight = 0;", "         for (i = 0; i < 2; i++) {", "             h->luma_weight_flag[i]   = 0;", "             h->chroma_weight_flag[i] = 0;", "         }", "     }", "     if (h->nal_ref_idc) {", "         ret = ff_h264_decode_ref_pic_marking(h0, &h->gb,", "                                              !(h->avctx->active_thread_type & FF_THREAD_FRAME) ||", "                                              h0->current_slice == 0);", "         if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))", "             return AVERROR_INVALIDDATA;", "     }", "     if (FRAME_MBAFF(h)) {", "         ff_h264_fill_mbaff_ref_list(h);", "         if (h->pps.weighted_bipred_idc == 2 && h->slice_type_nos == AV_PICTURE_TYPE_B) {", "             implicit_weight_table(h, 0);", "             implicit_weight_table(h, 1);", "         }", "     }", "     if (h->slice_type_nos == AV_PICTURE_TYPE_B && !h->direct_spatial_mv_pred)", "         ff_h264_direct_dist_scale_factor(h);", "     ff_h264_direct_ref_list_init(h);", "     if (h->slice_type_nos != AV_PICTURE_TYPE_I && h->pps.cabac) {", "         tmp = get_ue_golomb_31(&h->gb);", "         if (tmp > 2) {", "             av_log(h->avctx, AV_LOG_ERROR, \"cabac_init_idc overflow\\n\");", "             return AVERROR_INVALIDDATA;", "         }", "         h->cabac_init_idc = tmp;", "     }", "     h->last_qscale_diff = 0;", "     tmp = h->pps.init_qp + get_se_golomb(&h->gb);", "     if (tmp > 51 + 6 * (h->sps.bit_depth_luma - 8)) {", "         av_log(h->avctx, AV_LOG_ERROR, \"QP %u out of range\\n\", tmp);", "         return AVERROR_INVALIDDATA;", "     }", "     h->qscale       = tmp;", "     h->chroma_qp[0] = get_chroma_qp(h, 0, h->qscale);", "     h->chroma_qp[1] = get_chroma_qp(h, 1, h->qscale);", "     if (h->slice_type == AV_PICTURE_TYPE_SP)", "         get_bits1(&h->gb);  ", "     if (h->slice_type == AV_PICTURE_TYPE_SP ||", "         h->slice_type == AV_PICTURE_TYPE_SI)", "         get_se_golomb(&h->gb);  ", "     h->deblocking_filter     = 1;", "     h->slice_alpha_c0_offset = 52;", "     h->slice_beta_offset     = 52;", "     if (h->pps.deblocking_filter_parameters_present) {", "         tmp = get_ue_golomb_31(&h->gb);", "         if (tmp > 2) {", "             av_log(h->avctx, AV_LOG_ERROR,", "                    \"deblocking_filter_idc %u out of range\\n\", tmp);", "             return AVERROR_INVALIDDATA;", "         }", "         h->deblocking_filter = tmp;", "         if (h->deblocking_filter < 2)", "             h->deblocking_filter ^= 1;   ", "         if (h->deblocking_filter) {", "             h->slice_alpha_c0_offset += get_se_golomb(&h->gb) << 1;", "             h->slice_beta_offset     += get_se_golomb(&h->gb) << 1;", "             if (h->slice_alpha_c0_offset > 104U ||", "                 h->slice_beta_offset     > 104U) {", "                 av_log(h->avctx, AV_LOG_ERROR,", "                        \"deblocking filter parameters %d %d out of range\\n\",", "                        h->slice_alpha_c0_offset, h->slice_beta_offset);", "                 return AVERROR_INVALIDDATA;", "             }", "         }", "     }", "     if (h->avctx->skip_loop_filter >= AVDISCARD_ALL ||", "         (h->avctx->skip_loop_filter >= AVDISCARD_NONKEY &&", "          h->slice_type_nos != AV_PICTURE_TYPE_I) ||", "         (h->avctx->skip_loop_filter >= AVDISCARD_BIDIR  &&", "          h->slice_type_nos == AV_PICTURE_TYPE_B) ||", "         (h->avctx->skip_loop_filter >= AVDISCARD_NONREF &&", "          h->nal_ref_idc == 0))", "         h->deblocking_filter = 0;", "     if (h->deblocking_filter == 1 && h0->max_contexts > 1) {", "         if (h->avctx->flags2 & CODEC_FLAG2_FAST) {", "             h->deblocking_filter = 2;", "         } else {", "             h0->max_contexts = 1;", "             if (!h0->single_decode_warning) {", "                 av_log(h->avctx, AV_LOG_INFO,", "                        \"Cannot parallelize deblocking type 1, decoding such frames in sequential order\\n\");", "                 h0->single_decode_warning = 1;", "             }", "             if (h != h0) {", "                 av_log(h->avctx, AV_LOG_ERROR,", "                        \"Deblocking switched inside frame.\\n\");", "                 return 1;", "             }", "         }", "     }", "     h->qp_thresh = 15 + 52 -", "                    FFMIN(h->slice_alpha_c0_offset, h->slice_beta_offset) -", "                    FFMAX3(0,", "                           h->pps.chroma_qp_index_offset[0],", "                           h->pps.chroma_qp_index_offset[1]) +", "                    6 * (h->sps.bit_depth_luma - 8);", "     h0->last_slice_type = slice_type;", "     memcpy(h0->last_ref_count, h0->ref_count, sizeof(h0->last_ref_count));", "     h->slice_num        = ++h0->current_slice;", "     if (h->slice_num)", "         h0->slice_row[(h->slice_num-1)&(MAX_SLICES-1)]= h->resync_mb_y;", "     if (   h0->slice_row[h->slice_num&(MAX_SLICES-1)] + 3 >= h->resync_mb_y", "         && h0->slice_row[h->slice_num&(MAX_SLICES-1)] <= h->resync_mb_y", "         && h->slice_num >= MAX_SLICES) {", "         av_log(h->avctx, AV_LOG_WARNING, \"Possibly too many slices (%d >= %d), increase MAX_SLICES and recompile if there are artifacts\\n\", h->slice_num, MAX_SLICES);", "     }", "     for (j = 0; j < 2; j++) {", "         int id_list[16];", "         int *ref2frm = h->ref2frm[h->slice_num & (MAX_SLICES - 1)][j];", "         for (i = 0; i < 16; i++) {", "             id_list[i] = 60;", "             if (j < h->list_count && i < h->ref_count[j] &&", "                 h->ref_list[j][i].f.buf[0]) {", "                 int k;", "                 AVBuffer *buf = h->ref_list[j][i].f.buf[0]->buffer;", "                 for (k = 0; k < h->short_ref_count; k++)", "                     if (h->short_ref[k]->f.buf[0]->buffer == buf) {", "                         id_list[i] = k;", "                         break;", "                     }", "                 for (k = 0; k < h->long_ref_count; k++)", "                     if (h->long_ref[k] && h->long_ref[k]->f.buf[0]->buffer == buf) {", "                         id_list[i] = h->short_ref_count + k;", "                         break;", "                     }", "             }", "         }", "         ref2frm[0] =", "         ref2frm[1] = -1;", "         for (i = 0; i < 16; i++)", "             ref2frm[i + 2] = 4 * id_list[i] + (h->ref_list[j][i].reference & 3);", "         ref2frm[18 + 0] =", "         ref2frm[18 + 1] = -1;", "         for (i = 16; i < 48; i++)", "             ref2frm[i + 4] = 4 * id_list[(i - 16) >> 1] +", "                              (h->ref_list[j][i].reference & 3);", "     }", "     if (h->ref_count[0]) h->er.last_pic = &h->ref_list[0][0];", "     if (h->ref_count[1]) h->er.next_pic = &h->ref_list[1][0];", "     h->er.ref_count = h->ref_count[0];", "     if (h->avctx->debug & FF_DEBUG_PICT_INFO) {", "         av_log(h->avctx, AV_LOG_DEBUG,", "                \"slice:%d %s mb:%d %c%s%s pps:%u frame:%d poc:%d/%d ref:%d/%d qp:%d loop:%d:%d:%d weight:%d%s %s\\n\",", "                h->slice_num,", "                (h->picture_structure == PICT_FRAME ? \"F\" : h->picture_structure == PICT_TOP_FIELD ? \"T\" : \"B\"),", "                first_mb_in_slice,", "                av_get_picture_type_char(h->slice_type),", "                h->slice_type_fixed ? \" fix\" : \"\",", "                h->nal_unit_type == NAL_IDR_SLICE ? \" IDR\" : \"\",", "                pps_id, h->frame_num,", "                h->cur_pic_ptr->field_poc[0],", "                h->cur_pic_ptr->field_poc[1],", "                h->ref_count[0], h->ref_count[1],", "                h->qscale,", "                h->deblocking_filter,", "                h->slice_alpha_c0_offset / 2 - 26, h->slice_beta_offset / 2 - 26,", "                h->use_weight,", "                h->use_weight == 1 && h->use_weight_chroma ? \"c\" : \"\",", "                h->slice_type == AV_PICTURE_TYPE_B ? (h->direct_spatial_mv_pred ? \"SPAT\" : \"TEMP\") : \"\");", "     }", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" XcursorCommentCreate (XcursorUInt comment_type, int length)", " {", "     XcursorComment  *comment;", "     if (length > XCURSOR_COMMENT_MAX_LEN)", " \treturn NULL;", "  {", "      XcursorComment  *comment;", "    if (length > XCURSOR_COMMENT_MAX_LEN)", "     if (length < 0 || length > XCURSOR_COMMENT_MAX_LEN)", "  \treturn NULL;", "      comment = malloc (sizeof (XcursorComment) + length + 1);", "     comment->comment[0] = '\\0';", "     return comment;", " }", " void", " XcursorCommentDestroy (XcursorComment *comment)", " {", "     free (comment);", " }", " XcursorComments *", " XcursorCommentsCreate (int size)", " {", "     XcursorComments *comments;", "     comments = malloc (sizeof (XcursorComments) +", " \t\t       size * sizeof (XcursorComment *));", "     if (!comments)", " \treturn NULL;", "     comments->ncomment = 0;", "     comments->comments = (XcursorComment **) (comments + 1);", "     return comments;", " }", " void", " XcursorCommentsDestroy (XcursorComments *comments)", " {", "     int\tn;", "     if (!comments)", "         return;", "     for (n = 0; n < comments->ncomment; n++)", " \tXcursorCommentDestroy (comments->comments[n]);", "     free (comments);", " }", " static XcursorBool", " _XcursorReadUInt (XcursorFile *file, XcursorUInt *u)", " {", "     unsigned char   bytes[4];", "     if (!file || !u)", "         return XcursorFalse;", "     if ((*file->read) (file, bytes, 4) != 4)", " \treturn XcursorFalse;", "     *u = ((bytes[0] << 0) |", " \t  (bytes[1] << 8) |", " \t  (bytes[2] << 16) |", " \t  (bytes[3] << 24));", "     return XcursorTrue;", " }", " static XcursorBool", " _XcursorReadBytes (XcursorFile *file, char *bytes, int length)", " {", "     if (!file || !bytes || (*file->read) (file, (unsigned char *) bytes, length) != length)", " \treturn XcursorFalse;", "     return XcursorTrue;", " }", " static XcursorBool", " _XcursorWriteUInt (XcursorFile *file, XcursorUInt u)", " {", "     unsigned char   bytes[4];", "     if (!file)", "         return XcursorFalse;", "     bytes[0] = u;", "     bytes[1] = u >>  8;", "     bytes[2] = u >> 16;", "     bytes[3] = u >> 24;", "     if ((*file->write) (file, bytes, 4) != 4)", " \treturn XcursorFalse;", "     return XcursorTrue;", " }", " static XcursorBool", " _XcursorWriteBytes (XcursorFile *file, char *bytes, int length)", " {", "     if (!file || !bytes || (*file->write) (file, (unsigned char *) bytes, length) != length)", " \treturn XcursorFalse;", "     return XcursorTrue;", " }", " static void", " _XcursorFileHeaderDestroy (XcursorFileHeader *fileHeader)", " {", "     free (fileHeader);", " }", " static XcursorFileHeader *", " _XcursorFileHeaderCreate (XcursorUInt ntoc)", " {", "     XcursorFileHeader\t*fileHeader;", "     if (ntoc > 0x10000)", " \treturn NULL;", "     fileHeader = malloc (sizeof (XcursorFileHeader) +", " \t\t\t ntoc * sizeof (XcursorFileToc));", "     if (!fileHeader)", " \treturn NULL;", "     fileHeader->magic = XCURSOR_MAGIC;", "     fileHeader->header = XCURSOR_FILE_HEADER_LEN;", "     fileHeader->version = XCURSOR_FILE_VERSION;", "     fileHeader->ntoc = ntoc;", "     fileHeader->tocs = (XcursorFileToc *) (fileHeader + 1);", "     return fileHeader;", " }", " static XcursorFileHeader *", " _XcursorReadFileHeader (XcursorFile *file)", " {", "     XcursorFileHeader\thead, *fileHeader;", "     XcursorUInt\t\tskip;", "     int\t\t\tn;", "     if (!file)", "         return NULL;", "     if (!_XcursorReadUInt (file, &head.magic))", " \treturn NULL;", "     if (head.magic != XCURSOR_MAGIC)", " \treturn NULL;", "     if (!_XcursorReadUInt (file, &head.header))", " \treturn NULL;", "     if (!_XcursorReadUInt (file, &head.version))", " \treturn NULL;", "     if (!_XcursorReadUInt (file, &head.ntoc))", " \treturn NULL;", "     skip = head.header - XCURSOR_FILE_HEADER_LEN;", "     if (skip)", " \tif ((*file->seek) (file, skip, SEEK_CUR) == EOF)", " \t    return NULL;", "     fileHeader = _XcursorFileHeaderCreate (head.ntoc);", "     if (!fileHeader)", " \treturn NULL;", "     fileHeader->magic = head.magic;", "     fileHeader->header = head.header;", "     fileHeader->version = head.version;", "     fileHeader->ntoc = head.ntoc;", "     for (n = 0; n < fileHeader->ntoc; n++)", "     {", " \tif (!_XcursorReadUInt (file, &fileHeader->tocs[n].type))", " \t    break;", " \tif (!_XcursorReadUInt (file, &fileHeader->tocs[n].subtype))", " \t    break;", " \tif (!_XcursorReadUInt (file, &fileHeader->tocs[n].position))", " \t    break;", "     }", "     if (n != fileHeader->ntoc)", "     {", " \t_XcursorFileHeaderDestroy (fileHeader);", " \treturn NULL;", "     }", "     return fileHeader;", " }", " static XcursorUInt", " _XcursorFileHeaderLength (XcursorFileHeader *fileHeader)", " {", "     return (XCURSOR_FILE_HEADER_LEN +", " \t    fileHeader->ntoc * XCURSOR_FILE_TOC_LEN);", " }", " static XcursorBool", " _XcursorWriteFileHeader (XcursorFile *file, XcursorFileHeader *fileHeader)", " {", "     int\ttoc;", "     if (!file || !fileHeader)", "         return XcursorFalse;", "     if (!_XcursorWriteUInt (file, fileHeader->magic))", " \treturn XcursorFalse;", "     if (!_XcursorWriteUInt (file, fileHeader->header))", " \treturn XcursorFalse;", "     if (!_XcursorWriteUInt (file, fileHeader->version))", " \treturn XcursorFalse;", "     if (!_XcursorWriteUInt (file, fileHeader->ntoc))", " \treturn XcursorFalse;", "     for (toc = 0; toc < fileHeader->ntoc; toc++)", "     {", " \tif (!_XcursorWriteUInt (file, fileHeader->tocs[toc].type))", " \t    return XcursorFalse;", " \tif (!_XcursorWriteUInt (file, fileHeader->tocs[toc].subtype))", " \t    return XcursorFalse;", " \tif (!_XcursorWriteUInt (file, fileHeader->tocs[toc].position))", " \t    return XcursorFalse;", "     }", "     return XcursorTrue;", " }", " static XcursorBool", " _XcursorSeekToToc (XcursorFile\t\t*file,", " \t\t   XcursorFileHeader\t*fileHeader,", " \t\t   int\t\t\ttoc)", " {", "     if (!file || !fileHeader || \\", "         (*file->seek) (file, fileHeader->tocs[toc].position, SEEK_SET) == EOF)", " \treturn XcursorFalse;", "     return XcursorTrue;", " }", " static XcursorBool", " _XcursorFileReadChunkHeader (XcursorFile\t*file,", " \t\t\t     XcursorFileHeader\t*fileHeader,", " \t\t\t     int\t\ttoc,", " \t\t\t     XcursorChunkHeader\t*chunkHeader)", " {", "     if (!file || !fileHeader || !chunkHeader)", "         return XcursorFalse;", "     if (!_XcursorSeekToToc (file, fileHeader, toc))", " \treturn XcursorFalse;", "     if (!_XcursorReadUInt (file, &chunkHeader->header))", " \treturn XcursorFalse;", "     if (!_XcursorReadUInt (file, &chunkHeader->type))", " \treturn XcursorFalse;", "     if (!_XcursorReadUInt (file, &chunkHeader->subtype))", " \treturn XcursorFalse;", "     if (!_XcursorReadUInt (file, &chunkHeader->version))", " \treturn XcursorFalse;", "     if (chunkHeader->type != fileHeader->tocs[toc].type ||", " \tchunkHeader->subtype != fileHeader->tocs[toc].subtype)", " \treturn XcursorFalse;", "     return XcursorTrue;", " }", " static XcursorBool", " _XcursorFileWriteChunkHeader (XcursorFile\t    *file,", " \t\t\t      XcursorFileHeader\t    *fileHeader,", " \t\t\t      int\t\t    toc,", " \t\t\t      XcursorChunkHeader    *chunkHeader)", " {", "     if (!file || !fileHeader || !chunkHeader)", "         return XcursorFalse;", "     if (!_XcursorSeekToToc (file, fileHeader, toc))", " \treturn XcursorFalse;", "     if (!_XcursorWriteUInt (file, chunkHeader->header))", " \treturn XcursorFalse;", "     if (!_XcursorWriteUInt (file, chunkHeader->type))", " \treturn XcursorFalse;", "     if (!_XcursorWriteUInt (file, chunkHeader->subtype))", " \treturn XcursorFalse;", "     if (!_XcursorWriteUInt (file, chunkHeader->version))", " \treturn XcursorFalse;", "     return XcursorTrue;", " }", " #define dist(a,b)   ((a) > (b) ? (a) - (b) : (b) - (a))", " static XcursorDim", " _XcursorFindBestSize (XcursorFileHeader *fileHeader,", " \t\t      XcursorDim\tsize,", " \t\t      int\t\t*nsizesp)", " {", "     int\t\tn;", "     int\t\tnsizes = 0;", "     XcursorDim\tbestSize = 0;", "     XcursorDim\tthisSize;", "     if (!fileHeader || !nsizesp)", "         return 0;", "     for (n = 0; n < fileHeader->ntoc; n++)", "     {", " \tif (fileHeader->tocs[n].type != XCURSOR_IMAGE_TYPE)", " \t    continue;", " \tthisSize = fileHeader->tocs[n].subtype;", " \tif (!bestSize || dist (thisSize, size) < dist (bestSize, size))", " \t{", " \t    bestSize = thisSize;", " \t    nsizes = 1;", " \t}", " \telse if (thisSize == bestSize)", " \t    nsizes++;", "     }", "     *nsizesp = nsizes;", "     return bestSize;", " }", " static int", " _XcursorFindImageToc (XcursorFileHeader\t*fileHeader,", " \t\t      XcursorDim\tsize,", " \t\t      int\t\tcount)", " {", "     int\t\t\ttoc;", "     XcursorDim\t\tthisSize;", "     if (!fileHeader)", "         return 0;", "     for (toc = 0; toc < fileHeader->ntoc; toc++)", "     {", " \tif (fileHeader->tocs[toc].type != XCURSOR_IMAGE_TYPE)", " \t    continue;", " \tthisSize = fileHeader->tocs[toc].subtype;", " \tif (thisSize != size)", " \t    continue;", " \tif (!count)", " \t    break;", " \tcount--;", "     }", "     if (toc == fileHeader->ntoc)", " \treturn -1;", "     return toc;", " }", " static XcursorImage *", " _XcursorReadImage (XcursorFile\t\t*file,", " \t\t   XcursorFileHeader\t*fileHeader,", " \t\t   int\t\t\ttoc)", " {", "     XcursorChunkHeader\tchunkHeader;", "     XcursorImage\thead;", "     XcursorImage\t*image;", "     int\t\t\tn;", "     XcursorPixel\t*p;", "     if (!file || !fileHeader)", "         return NULL;", "     if (!_XcursorFileReadChunkHeader (file, fileHeader, toc, &chunkHeader))", " \treturn NULL;", "     if (!_XcursorReadUInt (file, &head.width))", " \treturn NULL;", "     if (!_XcursorReadUInt (file, &head.height))", " \treturn NULL;", "     if (!_XcursorReadUInt (file, &head.xhot))", " \treturn NULL;", "     if (!_XcursorReadUInt (file, &head.yhot))", " \treturn NULL;", "     if (!_XcursorReadUInt (file, &head.delay))", " \treturn NULL;", "     if (head.width >= 0x10000 || head.height > 0x10000)", " \treturn NULL;", "      if (!_XcursorReadUInt (file, &head.delay))", "  \treturn NULL;", "    if (head.width >= 0x10000 || head.height > 0x10000)", "     if (head.width > XCURSOR_IMAGE_MAX_SIZE  ||", " \thead.height > XCURSOR_IMAGE_MAX_SIZE)", "  \treturn NULL;", "      if (head.width == 0 || head.height == 0)", "  \treturn NULL;", " \timage->version = chunkHeader.version;", "     image->size = chunkHeader.subtype;", "      image = XcursorImageCreate (head.width, head.height);", "     if (image == NULL)", " \treturn NULL;", "      if (chunkHeader.version < image->version)", "  \timage->version = chunkHeader.version;", "      image->size = chunkHeader.subtype;", " \t{", " \t    XcursorImageDestroy (image);", " \t    return NULL;", " \t}", " \tp++;", "     }", "     return image;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void set_fat(DOS_FS * fs, uint32_t cluster, int32_t new)", " {", "     unsigned char *data = NULL;", "     int size;", "     loff_t offs;", "     if (new == -1)", " \tnew = FAT_EOF(fs);", "     else if ((long)new == -2)", " \tnew = FAT_BAD(fs);", "     switch (fs->fat_bits) {", "     case 12:", " \tdata = fs->fat + cluster * 3 / 2;", " \toffs = fs->fat_start + cluster * 3 / 2;", " \tif (cluster & 1) {", " \t    FAT_ENTRY prevEntry;", " \t    get_fat(&prevEntry, fs->fat, cluster - 1, fs);", " \t    data[0] = ((new & 0xf) << 4) | (prevEntry.value >> 8);", "  \t    data[1] = new >> 4;", "  \t} else {", "  \t    FAT_ENTRY subseqEntry;", "\t    if (cluster != fs->clusters - 1)", " \t    if (cluster != fs->clusters + 1)", "  \t\tget_fat(&subseqEntry, fs->fat, cluster + 1, fs);", "  \t    else", "  \t\tsubseqEntry.value = 0;", " \t    data[0] = new & 0xff;", " \t    data[1] = (new >> 8) | ((0xff & subseqEntry.value) << 4);", " \t}", " \tsize = 2;", " \tbreak;", "     case 16:", " \tdata = fs->fat + cluster * 2;", " \toffs = fs->fat_start + cluster * 2;", " \t*(unsigned short *)data = htole16(new);", " \tsize = 2;", " \tbreak;", "     case 32:", " \t{", " \t    FAT_ENTRY curEntry;", " \t    get_fat(&curEntry, fs->fat, cluster, fs);", " \t    data = fs->fat + cluster * 4;", " \t    offs = fs->fat_start + cluster * 4;", " \t    *(uint32_t *)data = htole32((new & 0xfffffff) |", " \t\t\t\t\t     (curEntry.reserved << 28));", " \t    size = 4;", " \t}", " \tbreak;", "     default:", " \tdie(\"Bad FAT entry size: %d bits.\", fs->fat_bits);", "     }", "     fs_write(offs, size, data);", "     if (fs->nfats > 1) {", " \tfs_write(offs + fs->fat_size, size, data);", "     }", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int vp78_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,", "                       AVPacket *avpkt, int is_vp7)", " {", "     VP8Context *s = avctx->priv_data;", "     int ret, i, referenced, num_jobs;", "      enum AVDiscard skip_thresh;", "      VP8Frame *av_uninit(curframe), *prev_frame;", "     av_assert0(avctx->pix_fmt == AV_PIX_FMT_YUVA420P || avctx->pix_fmt == AV_PIX_FMT_YUV420P);", "      if (is_vp7)", "          ret = vp7_decode_frame_header(s, avpkt->data, avpkt->size);", "      else", "         ret = vp8_decode_frame_header(s, avpkt->data, avpkt->size);", "     if (ret < 0)", "         goto err;", "     prev_frame = s->framep[VP56_FRAME_CURRENT];", "     referenced = s->update_last || s->update_golden == VP56_FRAME_CURRENT ||", "                  s->update_altref == VP56_FRAME_CURRENT;", "     skip_thresh = !referenced ? AVDISCARD_NONREF", "                               : !s->keyframe ? AVDISCARD_NONKEY", "                                              : AVDISCARD_ALL;", "     if (avctx->skip_frame >= skip_thresh) {", "         s->invisible = 1;", "         memcpy(&s->next_framep[0], &s->framep[0], sizeof(s->framep[0]) * 4);", "         goto skip_decode;", "     }", "     s->deblock_filter = s->filter.level && avctx->skip_loop_filter < skip_thresh;", "     for (i = 0; i < 5; i++)", "         if (s->frames[i].tf.f->data[0] &&", "             &s->frames[i] != prev_frame &&", "             &s->frames[i] != s->framep[VP56_FRAME_PREVIOUS] &&", "             &s->frames[i] != s->framep[VP56_FRAME_GOLDEN]   &&", "             &s->frames[i] != s->framep[VP56_FRAME_GOLDEN2])", "             vp8_release_frame(s, &s->frames[i]);", "     curframe = s->framep[VP56_FRAME_CURRENT] = vp8_find_free_buffer(s);", "     if (!s->colorspace)", "         avctx->colorspace = AVCOL_SPC_BT470BG;", "     if (s->fullrange)", "         avctx->color_range = AVCOL_RANGE_JPEG;", "     else", "         avctx->color_range = AVCOL_RANGE_MPEG;", "     if (!s->keyframe && (!s->framep[VP56_FRAME_PREVIOUS] ||", "                          !s->framep[VP56_FRAME_GOLDEN]   ||", "                          !s->framep[VP56_FRAME_GOLDEN2])) {", "         av_log(avctx, AV_LOG_WARNING,", "                \"Discarding interframe without a prior keyframe!\\n\");", "         ret = AVERROR_INVALIDDATA;", "         goto err;", "     }", "     curframe->tf.f->key_frame = s->keyframe;", "     curframe->tf.f->pict_type = s->keyframe ? AV_PICTURE_TYPE_I", "                                             : AV_PICTURE_TYPE_P;", "     if ((ret = vp8_alloc_frame(s, curframe, referenced)) < 0)", "         goto err;", "     if (s->update_altref != VP56_FRAME_NONE)", "         s->next_framep[VP56_FRAME_GOLDEN2] = s->framep[s->update_altref];", "     else", "         s->next_framep[VP56_FRAME_GOLDEN2] = s->framep[VP56_FRAME_GOLDEN2];", "     if (s->update_golden != VP56_FRAME_NONE)", "         s->next_framep[VP56_FRAME_GOLDEN] = s->framep[s->update_golden];", "     else", "         s->next_framep[VP56_FRAME_GOLDEN] = s->framep[VP56_FRAME_GOLDEN];", "     if (s->update_last)", "         s->next_framep[VP56_FRAME_PREVIOUS] = curframe;", "     else", "         s->next_framep[VP56_FRAME_PREVIOUS] = s->framep[VP56_FRAME_PREVIOUS];", "     s->next_framep[VP56_FRAME_CURRENT] = curframe;", "     if (avctx->codec->update_thread_context)", "         ff_thread_finish_setup(avctx);", "     s->linesize   = curframe->tf.f->linesize[0];", "     s->uvlinesize = curframe->tf.f->linesize[1];", "     memset(s->top_nnz, 0, s->mb_width * sizeof(*s->top_nnz));", "     if (!s->mb_layout)", "         memset(s->macroblocks + s->mb_height * 2 - 1, 0,", "                (s->mb_width + 1) * sizeof(*s->macroblocks));", "     if (!s->mb_layout && s->keyframe)", "         memset(s->intra4x4_pred_mode_top, DC_PRED, s->mb_width * 4);", "     memset(s->ref_count, 0, sizeof(s->ref_count));", "     if (s->mb_layout == 1) {", "         if (prev_frame && s->segmentation.enabled &&", "             !s->segmentation.update_map)", "             ff_thread_await_progress(&prev_frame->tf, 1, 0);", "         if (is_vp7)", "             vp7_decode_mv_mb_modes(avctx, curframe, prev_frame);", "         else", "             vp8_decode_mv_mb_modes(avctx, curframe, prev_frame);", "     }", "     if (avctx->active_thread_type == FF_THREAD_FRAME)", "         num_jobs = 1;", "     else", "         num_jobs = FFMIN(s->num_coeff_partitions, avctx->thread_count);", "     s->num_jobs   = num_jobs;", "     s->curframe   = curframe;", "     s->prev_frame = prev_frame;", "     s->mv_bounds.mv_min.y   = -MARGIN;", "     s->mv_bounds.mv_max.y   = ((s->mb_height - 1) << 6) + MARGIN;", "     for (i = 0; i < MAX_THREADS; i++) {", "         VP8ThreadData *td = &s->thread_data[i];", "         atomic_init(&td->thread_mb_pos, 0);", "         atomic_init(&td->wait_mb_pos, INT_MAX);", "     }", "     if (is_vp7)", "         avctx->execute2(avctx, vp7_decode_mb_row_sliced, s->thread_data, NULL,", "                         num_jobs);", "     else", "         avctx->execute2(avctx, vp8_decode_mb_row_sliced, s->thread_data, NULL,", "                         num_jobs);", "     ff_thread_report_progress(&curframe->tf, INT_MAX, 0);", "     memcpy(&s->framep[0], &s->next_framep[0], sizeof(s->framep[0]) * 4);", " skip_decode:", "     if (!s->update_probabilities)", "         s->prob[0] = s->prob[1];", "     if (!s->invisible) {", "         if ((ret = av_frame_ref(data, curframe->tf.f)) < 0)", "             return ret;", "         *got_frame = 1;", "     }", "     return avpkt->size;", " err:", "     memcpy(&s->next_framep[0], &s->framep[0], sizeof(s->framep[0]) * 4);", "     return ret;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" xmlParsePEReference(xmlParserCtxtPtr ctxt)", " {", "     const xmlChar *name;", "     xmlEntityPtr entity = NULL;", "     xmlParserInputPtr input;", "     if (RAW != '%')", "         return;", "     NEXT;", "     name = xmlParseName(ctxt);", "     if (name == NULL) {", " \txmlFatalErrMsg(ctxt, XML_ERR_PEREF_NO_NAME, \"PEReference: no name\\n\");", " \treturn;", "     }", "     if (xmlParserDebugEntities)", " \txmlGenericError(xmlGenericErrorContext,", " \t\t\"PEReference: %s\\n\", name);", "     if (RAW != ';') {", " \txmlFatalErr(ctxt, XML_ERR_PEREF_SEMICOL_MISSING, NULL);", "         return;", "     }", "     NEXT;", "     ctxt->nbentities++;", "     if ((ctxt->sax != NULL) &&", " \t(ctxt->sax->getParameterEntity != NULL))", " \tentity = ctxt->sax->getParameterEntity(ctxt->userData, name);", "     if (ctxt->instate == XML_PARSER_EOF)", " \treturn;", "     if (entity == NULL) {", " \tif ((ctxt->standalone == 1) ||", " \t    ((ctxt->hasExternalSubset == 0) &&", " \t     (ctxt->hasPErefs == 0))) {", " \t    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,", " \t\t\t      \"PEReference: %%%s; not found\\n\",", " \t\t\t      name);", " \t} else {", "             if ((ctxt->validate) && (ctxt->vctxt.error != NULL)) {", "                 xmlValidityError(ctxt, XML_WAR_UNDECLARED_ENTITY,", "                                  \"PEReference: %%%s; not found\\n\",", "                                  name, NULL);", "             } else", "                 xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,", "                               \"PEReference: %%%s; not found\\n\",", "                               name, NULL);", "             ctxt->valid = 0;", " \t}", " \txmlParserEntityCheck(ctxt, 0, NULL, 0);", "     } else {", " \tif ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&", " \t    (entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {", " \t    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,", " \t\t  \"Internal: %%%s; is not a parameter entity\\n\",", " \t\t\t  name, NULL);", " \t} else {", "             xmlChar start[4];", "             xmlCharEncoding enc;", " \t    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&", " \t        ((ctxt->options & XML_PARSE_NOENT) == 0) &&", " \t\t((ctxt->options & XML_PARSE_DTDVALID) == 0) &&", " \t\t((ctxt->options & XML_PARSE_DTDLOAD) == 0) &&", " \t\t((ctxt->options & XML_PARSE_DTDATTR) == 0) &&", " \t\t(ctxt->replaceEntities == 0) &&", " \t\t(ctxt->validate == 0))", "  \t\treturn;", "  \t    input = xmlNewEntityInputStream(ctxt, entity);", "\t    if (xmlPushInput(ctxt, input) < 0)", " \t    if (xmlPushInput(ctxt, input) < 0) {", "                 xmlFreeInputStream(input);", "  \t\treturn;", "             }", "  \t    if (entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) {", "                 GROW", "                 if (ctxt->instate == XML_PARSER_EOF)", "                     return;", "                 if ((ctxt->input->end - ctxt->input->cur)>=4) {", "                     start[0] = RAW;", "                     start[1] = NXT(1);", "                     start[2] = NXT(2);", "                     start[3] = NXT(3);", "                     enc = xmlDetectCharEncoding(start, 4);", "                     if (enc != XML_CHAR_ENCODING_NONE) {", "                         xmlSwitchEncoding(ctxt, enc);", "                     }", "                 }", "                 if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) &&", "                     (IS_BLANK_CH(NXT(5)))) {", "                     xmlParseTextDecl(ctxt);", "                 }", "             }", " \t}", "     }", "     ctxt->hasPErefs = 1;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static void decode_residue(vorb *f, float *residue_buffers[], int ch, int n, int rn, uint8 *do_not_decode)", "  {", "     int i,j,pass;", "     Residue *r = f->residue_config + rn;", "     int rtype = f->residue_types[rn];", "     int c = r->classbook;", "     int classwords = f->codebooks[c].dimensions;", "   int n_read = r->end - r->begin;", "    unsigned int actual_size = rtype == 2 ? n*2 : n;", "    unsigned int limit_r_begin = (r->begin < actual_size ? r->begin : actual_size);", "    unsigned int limit_r_end   = (r->end   < actual_size ? r->end   : actual_size);", "    int n_read = limit_r_end - limit_r_begin;", "     int part_read = n_read / r->part_size;", "     int temp_alloc_point = temp_alloc_save(f);", "     #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE", "    uint8 ***part_classdata = (uint8 ***) temp_block_array(f,f->channels, part_read * sizeof(**part_classdata));", "    #else", "    int **classifications = (int **) temp_block_array(f,f->channels, part_read * sizeof(**classifications));", "    #endif", "    CHECK(f);", "    for (i=0; i < ch; ++i)", "       if (!do_not_decode[i])", "          memset(residue_buffers[i], 0, sizeof(float) * n);", "    if (rtype == 2 && ch != 1) {", "       for (j=0; j < ch; ++j)", "          if (!do_not_decode[j])", "             break;", "       if (j == ch)", "          goto done;", "       for (pass=0; pass < 8; ++pass) {", "          int pcount = 0, class_set = 0;", "          if (ch == 2) {", "             while (pcount < part_read) {", "                int z = r->begin + pcount*r->part_size;", "                int c_inter = (z & 1), p_inter = z>>1;", "                if (pass == 0) {", "                   Codebook *c = f->codebooks+r->classbook;", "                   int q;", "                   DECODE(q,f,c);", "                   if (q == EOP) goto done;", "                   #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE", "                   part_classdata[0][class_set] = r->classdata[q];", "                   #else", "                   for (i=classwords-1; i >= 0; --i) {", "                      classifications[0][i+pcount] = q % r->classifications;", "                      q /= r->classifications;", "                   }", "                   #endif", "                }", "                for (i=0; i < classwords && pcount < part_read; ++i, ++pcount) {", "                   int z = r->begin + pcount*r->part_size;", "                   #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE", "                   int c = part_classdata[0][class_set][i];", "                   #else", "                   int c = classifications[0][pcount];", "                   #endif", "                   int b = r->residue_books[c][pass];", "                   if (b >= 0) {", "                      Codebook *book = f->codebooks + b;", "                      #ifdef STB_VORBIS_DIVIDES_IN_CODEBOOK", "                      if (!codebook_decode_deinterleave_repeat(f, book, residue_buffers, ch, &c_inter, &p_inter, n, r->part_size))", "                         goto done;", "                      #else", "                      if (!codebook_decode_deinterleave_repeat(f, book, residue_buffers, ch, &c_inter, &p_inter, n, r->part_size))", "                         goto done;", "                      #endif", "                   } else {", "                      z += r->part_size;", "                      c_inter = z & 1;", "                      p_inter = z >> 1;", "                   }", "                }", "                #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE", "                ++class_set;", "                #endif", "             }", "          } else if (ch == 1) {", "             while (pcount < part_read) {", "                int z = r->begin + pcount*r->part_size;", "                int c_inter = 0, p_inter = z;", "                if (pass == 0) {", "                   Codebook *c = f->codebooks+r->classbook;", "                   int q;", "                   DECODE(q,f,c);", "                   if (q == EOP) goto done;", "                   #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE", "                   part_classdata[0][class_set] = r->classdata[q];", "                   #else", "                   for (i=classwords-1; i >= 0; --i) {", "                      classifications[0][i+pcount] = q % r->classifications;", "                      q /= r->classifications;", "                   }", "                   #endif", "                }", "                for (i=0; i < classwords && pcount < part_read; ++i, ++pcount) {", "                   int z = r->begin + pcount*r->part_size;", "                   #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE", "                   int c = part_classdata[0][class_set][i];", "                   #else", "                   int c = classifications[0][pcount];", "                   #endif", "                   int b = r->residue_books[c][pass];", "                   if (b >= 0) {", "                      Codebook *book = f->codebooks + b;", "                      if (!codebook_decode_deinterleave_repeat(f, book, residue_buffers, ch, &c_inter, &p_inter, n, r->part_size))", "                         goto done;", "                   } else {", "                      z += r->part_size;", "                      c_inter = 0;", "                      p_inter = z;", "                   }", "                }", "                #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE", "                ++class_set;", "                #endif", "             }", "          } else {", "             while (pcount < part_read) {", "                int z = r->begin + pcount*r->part_size;", "                int c_inter = z % ch, p_inter = z/ch;", "                if (pass == 0) {", "                   Codebook *c = f->codebooks+r->classbook;", "                   int q;", "                   DECODE(q,f,c);", "                   if (q == EOP) goto done;", "                   #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE", "                   part_classdata[0][class_set] = r->classdata[q];", "                   #else", "                   for (i=classwords-1; i >= 0; --i) {", "                      classifications[0][i+pcount] = q % r->classifications;", "                      q /= r->classifications;", "                   }", "                   #endif", "                }", "                for (i=0; i < classwords && pcount < part_read; ++i, ++pcount) {", "                   int z = r->begin + pcount*r->part_size;", "                   #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE", "                   int c = part_classdata[0][class_set][i];", "                   #else", "                   int c = classifications[0][pcount];", "                   #endif", "                   int b = r->residue_books[c][pass];", "                   if (b >= 0) {", "                      Codebook *book = f->codebooks + b;", "                      if (!codebook_decode_deinterleave_repeat(f, book, residue_buffers, ch, &c_inter, &p_inter, n, r->part_size))", "                         goto done;", "                   } else {", "                      z += r->part_size;", "                      c_inter = z % ch;", "                      p_inter = z / ch;", "                   }", "                }", "                #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE", "                ++class_set;", "                #endif", "             }", "          }", "       }", "       goto done;", "    }", "    CHECK(f);", "    for (pass=0; pass < 8; ++pass) {", "       int pcount = 0, class_set=0;", "       while (pcount < part_read) {", "          if (pass == 0) {", "             for (j=0; j < ch; ++j) {", "                if (!do_not_decode[j]) {", "                   Codebook *c = f->codebooks+r->classbook;", "                   int temp;", "                   DECODE(temp,f,c);", "                   if (temp == EOP) goto done;", "                   #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE", "                   part_classdata[j][class_set] = r->classdata[temp];", "                   #else", "                   for (i=classwords-1; i >= 0; --i) {", "                      classifications[j][i+pcount] = temp % r->classifications;", "                      temp /= r->classifications;", "                   }", "                   #endif", "                }", "             }", "          }", "          for (i=0; i < classwords && pcount < part_read; ++i, ++pcount) {", "             for (j=0; j < ch; ++j) {", "                if (!do_not_decode[j]) {", "                   #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE", "                   int c = part_classdata[j][class_set][i];", "                   #else", "                   int c = classifications[j][pcount];", "                   #endif", "                   int b = r->residue_books[c][pass];", "                   if (b >= 0) {", "                      float *target = residue_buffers[j];", "                      int offset = r->begin + pcount * r->part_size;", "                      int n = r->part_size;", "                      Codebook *book = f->codebooks + b;", "                      if (!residue_decode(f, book, target, offset, n, rtype))", "                         goto done;", "                   }", "                }", "             }", "          }", "          #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE", "          ++class_set;", "          #endif", "       }", "    }", "   done:", "    CHECK(f);", "    #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE", "    temp_free(f,part_classdata);", "    #else", "    temp_free(f,classifications);", "    #endif", "    temp_alloc_restore(f,temp_alloc_point);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int tcos_select_file(sc_card_t *card,", " \t\t\t    const sc_path_t *in_path,", " \t\t\t    sc_file_t **file_out)", " {", " \tsc_context_t *ctx;", " \tsc_apdu_t apdu;", " \tsc_file_t *file=NULL;", " \tu8 buf[SC_MAX_APDU_BUFFER_SIZE], pathbuf[SC_MAX_PATH_SIZE], *path = pathbuf;", " \tunsigned int i;", " \tint r, pathlen;", " \tassert(card != NULL && in_path != NULL);", " \tctx=card->ctx;", " \tmemcpy(path, in_path->value, in_path->len);", " \tpathlen = in_path->len;", " \tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0, 0x04);", " \tswitch (in_path->type) {", " \tcase SC_PATH_TYPE_FILE_ID:", " \t\tif (pathlen != 2) return SC_ERROR_INVALID_ARGUMENTS;", " \tcase SC_PATH_TYPE_FROM_CURRENT:", " \t\tapdu.p1 = 9;", " \t\tbreak;", " \tcase SC_PATH_TYPE_DF_NAME:", " \t\tapdu.p1 = 4;", " \t\tbreak;", " \tcase SC_PATH_TYPE_PATH:", " \t\tapdu.p1 = 8;", " \t\tif (pathlen >= 2 && memcmp(path, \"\\x3F\\x00\", 2) == 0) path += 2, pathlen -= 2;", " \t\tif (pathlen == 0) apdu.p1 = 0;", " \t\tbreak;", " \tcase SC_PATH_TYPE_PARENT:", " \t\tapdu.p1 = 3;", " \t\tpathlen = 0;", " \t\tbreak;", " \tdefault:", " \t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);", " \t}", " \tif( pathlen == 0 ) apdu.cse = SC_APDU_CASE_2_SHORT;", " \tapdu.lc = pathlen;", " \tapdu.data = path;", " \tapdu.datalen = pathlen;", " \tif (file_out != NULL) {", " \t\tapdu.resp = buf;", " \t\tapdu.resplen = sizeof(buf);", " \t\tapdu.le = 256;", " \t} else {", " \t\tapdu.resplen = 0;", " \t\tapdu.le = 0; ", " \t\tapdu.p2 = 0x0C; ", " \t\tapdu.cse = (pathlen == 0) ? SC_APDU_CASE_1 : SC_APDU_CASE_3_SHORT;", " \t}", " \tr = sc_transmit_apdu(card, &apdu);", " \tSC_TEST_RET(ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");", " \tr = sc_check_sw(card, apdu.sw1, apdu.sw2);", " \tif (r || file_out == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, r);", " \tif (apdu.resplen < 1 || apdu.resp[0] != 0x62){", " \t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"received invalid template %02X\\n\", apdu.resp[0]);", " \t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);", " \t}", " \tfile = sc_file_new();", " \tif (file == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_OUT_OF_MEMORY);", " \t*file_out = file;", "  \tfile->path = *in_path;", "  \tfor(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){", "\t\tint j, len=apdu.resp[i+1];", " \t\tsize_t j, len=apdu.resp[i+1];", "  \t\tunsigned char type=apdu.resp[i], *d=apdu.resp+i+2;", "  \t\tswitch (type) {", " \t\tcase 0x80:", " \t\tcase 0x81:", " \t\t\tfile->size=0;", " \t\t\tfor(j=0; j<len; ++j) file->size = (file->size<<8) | d[j];", " \t\t\tbreak;", " \t\tcase 0x82:", " \t\t\tfile->shareable = (d[0] & 0x40) ? 1 : 0;", " \t\t\tfile->ef_structure = d[0] & 7;", " \t\t\tswitch ((d[0]>>3) & 7) {", " \t\t\tcase 0: file->type = SC_FILE_TYPE_WORKING_EF; break;", " \t\t\tcase 7: file->type = SC_FILE_TYPE_DF; break;", " \t\t\tdefault:", " \t\t\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"invalid file type %02X in file descriptor\\n\", d[0]);", " \t\t\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);", " \t\t\t}", " \t\t\tbreak;", " \t\tcase 0x83:", "  \t\t\tfile->id = (d[0]<<8) | d[1];", "  \t\t\tbreak;", "  \t\tcase 0x84:", "\t\t\tmemcpy(file->name, d, len);", "\t\t\tfile->namelen = len;", " \t\t\tfile->namelen = MIN(sizeof file->name, len);", " \t\t\tmemcpy(file->name, d, file->namelen);", "  \t\t\tbreak;", "  \t\tcase 0x86:", "  \t\t\tsc_file_set_sec_attr(file, d, len); ", " \t\t\tbreak;", " \t\tdefault:", " \t\t\tif (len>0) sc_file_set_prop_attr(file, d, len); ", " \t\t}", " \t}", " \tfile->magic = SC_FILE_MAGIC;", " \tparse_sec_attr(card, file, file->sec_attr, file->sec_attr_len);", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" ProcRenderAddGlyphs (ClientPtr client)", " {", "     GlyphSetPtr     glyphSet;", "     REQUEST(xRenderAddGlyphsReq);", "     GlyphNewRec\t    glyphsLocal[NLOCALGLYPH];", "     GlyphNewPtr\t    glyphsBase, glyphs, glyph_new;", "     int\t\t    remain, nglyphs;", "     CARD32\t    *gids;", "     xGlyphInfo\t    *gi;", "     CARD8\t    *bits;", "     unsigned int    size;", "     int\t\t    err;", "     int\t\t    i, screen;", "     PicturePtr\t    pSrc = NULL, pDst = NULL;", "     PixmapPtr\t    pSrcPix = NULL, pDstPix = NULL;", "     CARD32\t    component_alpha;", "     REQUEST_AT_LEAST_SIZE(xRenderAddGlyphsReq);", "     err = dixLookupResourceByType((pointer *)&glyphSet, stuff->glyphset, GlyphSetType,", " \t\t\t    client, DixAddAccess);", "     if (err != Success)", "     {", " \tclient->errorValue = stuff->glyphset;", " \treturn err;", "     }", "     err = BadAlloc;", "     nglyphs = stuff->nglyphs;", "     if (nglyphs > UINT32_MAX / sizeof(GlyphNewRec))", " \t    return BadAlloc;", "     component_alpha = NeedsComponent (glyphSet->format->format);", "     if (nglyphs <= NLOCALGLYPH) {", " \tmemset (glyphsLocal, 0, sizeof (glyphsLocal));", " \tglyphsBase = glyphsLocal;", "     }", "     else", "     {", " \tglyphsBase = (GlyphNewPtr)calloc(nglyphs, sizeof (GlyphNewRec));", " \tif (!glyphsBase)", " \t    return BadAlloc;", "     }", "     remain = (client->req_len << 2) - sizeof (xRenderAddGlyphsReq);", "     glyphs = glyphsBase;", "     gids = (CARD32 *) (stuff + 1);", "      gi = (xGlyphInfo *) (gids + nglyphs);", "      bits = (CARD8 *) (gi + nglyphs);", "      remain -= (sizeof (CARD32) + sizeof (xGlyphInfo)) * nglyphs;", "     if (gi < stuff || gi > ((CARD32 *)stuff + client->req_len) ||", "         bits < stuff || bits > ((CARD32 *)stuff + client->req_len)) {", "         err = BadLength;", "         goto bail;", "     }", "      for (i = 0; i < nglyphs; i++)", "      {", "  \tsize_t padded_width;", " \tsize = gi[i].height * padded_width;", " \tif (remain < size)", " \t    break;", " \terr = HashGlyph (&gi[i], bits, size, glyph_new->sha1);", " \tif (err)", " \t    goto bail;", " \tglyph_new->glyph = FindGlyphByHash (glyph_new->sha1,", " \t\t\t\t\t    glyphSet->fdepth);", " \tif (glyph_new->glyph && glyph_new->glyph != DeletedGlyph)", " \t{", " \t    glyph_new->found = TRUE;", " \t}", " \telse", " \t{", " \t    GlyphPtr glyph;", " \t    glyph_new->found = FALSE;", " \t    glyph_new->glyph = glyph = AllocateGlyph (&gi[i], glyphSet->fdepth);", " \t    if (! glyph)", " \t    {", " \t\terr = BadAlloc;", " \t\tgoto bail;", " \t    }", " \t    for (screen = 0; screen < screenInfo.numScreens; screen++)", " \t    {", " \t\tint\t    width = gi[i].width;", " \t\tint\t    height = gi[i].height;", " \t\tint\t    depth = glyphSet->format->depth;", " \t\tScreenPtr   pScreen;", " \t\tint\t    error;", " \t\tif (!width || !height)", " \t\t    break;", " \t\tpScreen = screenInfo.screens[screen];", " \t\tpSrcPix = GetScratchPixmapHeader (pScreen,", " \t\t\t\t\t\t  width, height,", " \t\t\t\t\t\t  depth, depth,", " \t\t\t\t\t\t  -1, bits);", " \t\tif (! pSrcPix)", " \t\t{", " \t\t    err = BadAlloc;", " \t\t    goto bail;", " \t\t}", " \t\tpSrc = CreatePicture (0, &pSrcPix->drawable,", " \t\t\t\t      glyphSet->format, 0, NULL,", " \t\t\t\t      serverClient, &error);", " \t\tif (! pSrc)", " \t\t{", " \t\t    err = BadAlloc;", " \t\t    goto bail;", " \t\t}", " \t\tpDstPix = (pScreen->CreatePixmap) (pScreen,", " \t\t\t\t\t\t   width, height, depth,", " \t\t\t\t\t\t   CREATE_PIXMAP_USAGE_GLYPH_PICTURE);", " \t\tif (!pDstPix)", " \t\t{", " \t\t    err = BadAlloc;", " \t\t    goto bail;", " \t\t}", " \t\tGlyphPicture (glyph)[screen] = pDst =", " \t\t\tCreatePicture (0, &pDstPix->drawable,", " \t\t\t\t       glyphSet->format,", " \t\t\t\t       CPComponentAlpha, &component_alpha,", " \t\t\t\t       serverClient, &error);", " \t\t(pScreen->DestroyPixmap) (pDstPix);", " \t\tpDstPix = NULL;", " \t\tif (! pDst)", " \t\t{", " \t\t    err = BadAlloc;", " \t\t    goto bail;", " \t\t}", " \t\tCompositePicture (PictOpSrc,", " \t\t\t\t  pSrc,", " \t\t\t\t  None,", " \t\t\t\t  pDst,", " \t\t\t\t  0, 0,", " \t\t\t\t  0, 0,", " \t\t\t\t  0, 0,", " \t\t\t\t  width, height);", " \t\tFreePicture ((pointer) pSrc, 0);", " \t\tpSrc = NULL;", " \t\tFreeScratchPixmapHeader (pSrcPix);", " \t\tpSrcPix = NULL;", " \t    }", " \t    memcpy (glyph_new->glyph->sha1, glyph_new->sha1, 20);", " \t}", " \tglyph_new->id = gids[i];", " \tif (size & 3)", " \t    size += 4 - (size & 3);", " \tbits += size;", " \tremain -= size;", "     }", "     if (remain || i < nglyphs)", "     {", " \terr = BadLength;", " \tgoto bail;", "     }", "     if (!ResizeGlyphSet (glyphSet, nglyphs))", "     {", " \terr = BadAlloc;", " \tgoto bail;", "     }", "     for (i = 0; i < nglyphs; i++)", " \tAddGlyph (glyphSet, glyphs[i].glyph, glyphs[i].id);", "     if (glyphsBase != glyphsLocal)", " \tfree(glyphsBase);", "     return Success;", " bail:", "     if (pSrc)", " \tFreePicture ((pointer) pSrc, 0);", "     if (pSrcPix)", " \tFreeScratchPixmapHeader (pSrcPix);", "     for (i = 0; i < nglyphs; i++)", " \tif (glyphs[i].glyph && ! glyphs[i].found)", " \t    free(glyphs[i].glyph);", "     if (glyphsBase != glyphsLocal)", " \tfree(glyphsBase);", "     return err;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int filter_frame(AVFilterLink *inlink, AVFrame *inpic)", " {", "     KerndeintContext *kerndeint = inlink->dst->priv;", "     AVFilterLink *outlink = inlink->dst->outputs[0];", "     AVFrame *outpic;", "     const uint8_t *prvp;    ", "     const uint8_t *prvpp;   ", "     const uint8_t *prvpn;   ", "     const uint8_t *prvppp;  ", "     const uint8_t *prvpnn;  ", "     const uint8_t *prvp4p;  ", "     const uint8_t *prvp4n;  ", "     const uint8_t *srcp;    ", "     const uint8_t *srcpp;   ", "     const uint8_t *srcpn;   ", "     const uint8_t *srcppp;  ", "     const uint8_t *srcpnn;  ", "     const uint8_t *srcp3p;  ", "     const uint8_t *srcp3n;  ", "     const uint8_t *srcp4p;  ", "     const uint8_t *srcp4n;  ", "     uint8_t *dstp, *dstp_saved;", "     const uint8_t *srcp_saved;", "     int src_linesize, psrc_linesize, dst_linesize, bwidth;", "     int x, y, plane, val, hi, lo, g, h, n = kerndeint->frame++;", "     double valf;", "     const int thresh = kerndeint->thresh;", "     const int order  = kerndeint->order;", "     const int map    = kerndeint->map;", "     const int sharp  = kerndeint->sharp;", "     const int twoway = kerndeint->twoway;", "     const int is_packed_rgb = kerndeint->is_packed_rgb;", "     outpic = ff_get_video_buffer(outlink, outlink->w, outlink->h);", "     if (!outpic) {", "         av_frame_free(&inpic);", "         return AVERROR(ENOMEM);", "     }", "      av_frame_copy_props(outpic, inpic);", "      outpic->interlaced_frame = 0;", "    for (plane = 0; inpic->data[plane] && plane < 4; plane++) {", "     for (plane = 0; plane < 4 && inpic->data[plane] && inpic->linesize[plane]; plane++) {", "          h = plane == 0 ? inlink->h : FF_CEIL_RSHIFT(inlink->h, kerndeint->vsub);", "          bwidth = kerndeint->tmp_bwidth[plane];", "         srcp = srcp_saved = inpic->data[plane];", "         src_linesize      = inpic->linesize[plane];", "         psrc_linesize     = kerndeint->tmp_linesize[plane];", "         dstp = dstp_saved = outpic->data[plane];", "         dst_linesize      = outpic->linesize[plane];", "         srcp              = srcp_saved + (1 - order) * src_linesize;", "         dstp              = dstp_saved + (1 - order) * dst_linesize;", "         for (y = 0; y < h; y += 2) {", "             memcpy(dstp, srcp, bwidth);", "             srcp += 2 * src_linesize;", "             dstp += 2 * dst_linesize;", "         }", "         memcpy(dstp_saved + order            * dst_linesize, srcp_saved + (1 -     order) * src_linesize, bwidth);", "         memcpy(dstp_saved + (2 + order    )  * dst_linesize, srcp_saved + (3 -     order) * src_linesize, bwidth);", "         memcpy(dstp_saved + (h - 2 + order)  * dst_linesize, srcp_saved + (h - 1 - order) * src_linesize, bwidth);", "         memcpy(dstp_saved + (h - 4 + order)  * dst_linesize, srcp_saved + (h - 3 - order) * src_linesize, bwidth);", "         prvp   = kerndeint->tmp_data[plane] + 5 * psrc_linesize - (1 - order) * psrc_linesize;", "         prvpp  = prvp - psrc_linesize;", "         prvppp = prvp - 2 * psrc_linesize;", "         prvp4p = prvp - 4 * psrc_linesize;", "         prvpn  = prvp + psrc_linesize;", "         prvpnn = prvp + 2 * psrc_linesize;", "         prvp4n = prvp + 4 * psrc_linesize;", "         srcp   = srcp_saved + 5 * src_linesize - (1 - order) * src_linesize;", "         srcpp  = srcp - src_linesize;", "         srcppp = srcp - 2 * src_linesize;", "         srcp3p = srcp - 3 * src_linesize;", "         srcp4p = srcp - 4 * src_linesize;", "         srcpn  = srcp + src_linesize;", "         srcpnn = srcp + 2 * src_linesize;", "         srcp3n = srcp + 3 * src_linesize;", "         srcp4n = srcp + 4 * src_linesize;", "         dstp   = dstp_saved + 5 * dst_linesize - (1 - order) * dst_linesize;", "         for (y = 5 - (1 - order); y <= h - 5 - (1 - order); y += 2) {", "             for (x = 0; x < bwidth; x++) {", "                 if (thresh == 0 || n == 0 ||", "                     (abs((int)prvp[x]  - (int)srcp[x])  > thresh) ||", "                     (abs((int)prvpp[x] - (int)srcpp[x]) > thresh) ||", "                     (abs((int)prvpn[x] - (int)srcpn[x]) > thresh)) {", "                     if (map) {", "                         g = x & ~3;", "                         if (is_packed_rgb) {", "                             AV_WB32(dstp + g, 0xffffffff);", "                             x = g + 3;", "                         } else if (inlink->format == AV_PIX_FMT_YUYV422) {", "                             AV_WB32(dstp + g, 0xeb80eb80);", "                             x = g + 3;", "                         } else {", "                             dstp[x] = plane == 0 ? 235 : 128;", "                         }", "                     } else {", "                         if (is_packed_rgb) {", "                             hi = 255;", "                             lo = 0;", "                         } else if (inlink->format == AV_PIX_FMT_YUYV422) {", "                             hi = x & 1 ? 240 : 235;", "                             lo = 16;", "                         } else {", "                             hi = plane == 0 ? 235 : 240;", "                             lo = 16;", "                         }", "                         if (sharp) {", "                             if (twoway) {", "                                 valf = + 0.526 * ((int)srcpp[x] + (int)srcpn[x])", "                                     + 0.170 * ((int)srcp[x] + (int)prvp[x])", "                                     - 0.116 * ((int)srcppp[x] + (int)srcpnn[x] + (int)prvppp[x] + (int)prvpnn[x])", "                                     - 0.026 * ((int)srcp3p[x] + (int)srcp3n[x])", "                                     + 0.031 * ((int)srcp4p[x] + (int)srcp4n[x] + (int)prvp4p[x] + (int)prvp4n[x]);", "                             } else {", "                                 valf = + 0.526 * ((int)srcpp[x] + (int)srcpn[x])", "                                     + 0.170 * ((int)prvp[x])", "                                     - 0.116 * ((int)prvppp[x] + (int)prvpnn[x])", "                                     - 0.026 * ((int)srcp3p[x] + (int)srcp3n[x])", "                                     + 0.031 * ((int)prvp4p[x] + (int)prvp4p[x]);", "                             }", "                             dstp[x] = av_clip(valf, lo, hi);", "                         } else {", "                             if (twoway) {", "                                 val = (8 * ((int)srcpp[x] + (int)srcpn[x]) + 2 * ((int)srcp[x] + (int)prvp[x])", "                                        - (int)(srcppp[x]) - (int)(srcpnn[x])", "                                        - (int)(prvppp[x]) - (int)(prvpnn[x])) >> 4;", "                             } else {", "                                 val = (8 * ((int)srcpp[x] + (int)srcpn[x]) + 2 * ((int)prvp[x])", "                                        - (int)(prvppp[x]) - (int)(prvpnn[x])) >> 4;", "                             }", "                             dstp[x] = av_clip(val, lo, hi);", "                         }", "                     }", "                 } else {", "                     dstp[x] = srcp[x];", "                 }", "             }", "             prvp   += 2 * psrc_linesize;", "             prvpp  += 2 * psrc_linesize;", "             prvppp += 2 * psrc_linesize;", "             prvpn  += 2 * psrc_linesize;", "             prvpnn += 2 * psrc_linesize;", "             prvp4p += 2 * psrc_linesize;", "             prvp4n += 2 * psrc_linesize;", "             srcp   += 2 * src_linesize;", "             srcpp  += 2 * src_linesize;", "             srcppp += 2 * src_linesize;", "             srcp3p += 2 * src_linesize;", "             srcp4p += 2 * src_linesize;", "             srcpn  += 2 * src_linesize;", "             srcpnn += 2 * src_linesize;", "             srcp3n += 2 * src_linesize;", "             srcp4n += 2 * src_linesize;", "             dstp   += 2 * dst_linesize;", "         }", "         srcp = inpic->data[plane];", "         dstp = kerndeint->tmp_data[plane];", "         av_image_copy_plane(dstp, psrc_linesize, srcp, src_linesize, bwidth, h);", "     }", "     av_frame_free(&inpic);", "     return ff_filter_frame(outlink, outpic);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" DecodeTime(char *str, int *tmask, struct tm * tm, fsec_t *fsec)", " {", " \tchar\t   *cp;", " \t*tmask = DTK_TIME_M;", " \ttm->tm_hour = strtol(str, &cp, 10);", " \tif (*cp != ':')", " \t\treturn -1;", " \tstr = cp + 1;", " \ttm->tm_min = strtol(str, &cp, 10);", " \tif (*cp == '\\0')", " \t{", " \t\ttm->tm_sec = 0;", " \t\t*fsec = 0;", " \t}", " \telse if (*cp != ':')", " \t\treturn -1;", " \telse", " \t{", " \t\tstr = cp + 1;", " \t\ttm->tm_sec = strtol(str, &cp, 10);", " \t\tif (*cp == '\\0')", " \t\t\t*fsec = 0;", "  \t\telse if (*cp == '.')", "  \t\t{", "  #ifdef HAVE_INT64_TIMESTAMP", "\t\t\tchar\t\tfstr[MAXDATELEN + 1];", " \t\t\tchar\t\tfstr[7];", " \t\t\tint\t\t\ti;", " \t\t\tcp++;", "\t\t\tstrncpy(fstr, (cp + 1), 7);", "\t\t\tstrcpy(fstr + strlen(fstr), \"000000\");", "\t\t\t*(fstr + 6) = '\\0';", " \t\t\tfor (i = 0; i < 6; i++)", " \t\t\t\tfstr[i] = *cp != '\\0' ? *cp++ : '0';", " \t\t\tfstr[i] = '\\0';", "  \t\t\t*fsec = strtol(fstr, &cp, 10);", "  #else", "  \t\t\tstr = cp;", " \t\t\t*fsec = strtod(str, &cp);", " #endif", " \t\t\tif (*cp != '\\0')", " \t\t\t\treturn -1;", " \t\t}", " \t\telse", " \t\t\treturn -1;", " \t}", " #ifdef HAVE_INT64_TIMESTAMP", " \tif (tm->tm_hour < 0 || tm->tm_min < 0 || tm->tm_min > 59 ||", " \t\ttm->tm_sec < 0 || tm->tm_sec > 59 || *fsec >= USECS_PER_SEC)", " \t\treturn -1;", " #else", " \tif (tm->tm_hour < 0 || tm->tm_min < 0 || tm->tm_min > 59 ||", " \t\ttm->tm_sec < 0 || tm->tm_sec > 59 || *fsec >= 1)", " \t\treturn -1;", " #endif", " \treturn 0;", " }\t "], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" ZSTD_encodeSequences_body(", "             void* dst, size_t dstCapacity,", "             FSE_CTable const* CTable_MatchLength, BYTE const* mlCodeTable,", "             FSE_CTable const* CTable_OffsetBits, BYTE const* ofCodeTable,", "             FSE_CTable const* CTable_LitLength, BYTE const* llCodeTable,", "             seqDef const* sequences, size_t nbSeq, int longOffsets)", " {", "     BIT_CStream_t blockStream;", "     FSE_CState_t  stateMatchLength;", "     FSE_CState_t  stateOffsetBits;", "      FSE_CState_t  stateLitLength;", "      CHECK_E(BIT_initCStream(&blockStream, dst, dstCapacity), dstSize_tooSmall);  ", "     DEBUGLOG(6, \"available space for bitstream : %i  (dstCapacity=%u)\",", "                 (int)(blockStream.endPtr - blockStream.startPtr),", "                 (unsigned)dstCapacity);", "      FSE_initCState2(&stateMatchLength, CTable_MatchLength, mlCodeTable[nbSeq-1]);", "     FSE_initCState2(&stateOffsetBits,  CTable_OffsetBits,  ofCodeTable[nbSeq-1]);", "     FSE_initCState2(&stateLitLength,   CTable_LitLength,   llCodeTable[nbSeq-1]);", "     BIT_addBits(&blockStream, sequences[nbSeq-1].litLength, LL_bits[llCodeTable[nbSeq-1]]);", "     if (MEM_32bits()) BIT_flushBits(&blockStream);", "     BIT_addBits(&blockStream, sequences[nbSeq-1].matchLength, ML_bits[mlCodeTable[nbSeq-1]]);", "     if (MEM_32bits()) BIT_flushBits(&blockStream);", "     if (longOffsets) {", "         U32 const ofBits = ofCodeTable[nbSeq-1];", "         int const extraBits = ofBits - MIN(ofBits, STREAM_ACCUMULATOR_MIN-1);", "         if (extraBits) {", "             BIT_addBits(&blockStream, sequences[nbSeq-1].offset, extraBits);", "             BIT_flushBits(&blockStream);", "         }", "         BIT_addBits(&blockStream, sequences[nbSeq-1].offset >> extraBits,", "                     ofBits - extraBits);", "     } else {", "         BIT_addBits(&blockStream, sequences[nbSeq-1].offset, ofCodeTable[nbSeq-1]);", "     }", "     BIT_flushBits(&blockStream);", "     {   size_t n;", "         for (n=nbSeq-2 ; n<nbSeq ; n--) {       ", "             BYTE const llCode = llCodeTable[n];", "             BYTE const ofCode = ofCodeTable[n];", "             BYTE const mlCode = mlCodeTable[n];", "             U32  const llBits = LL_bits[llCode];", "             U32  const ofBits = ofCode;", "             U32  const mlBits = ML_bits[mlCode];", "             DEBUGLOG(6, \"encoding: litlen:%2u - matchlen:%2u - offCode:%7u\",", "                         sequences[n].litLength,", "                         sequences[n].matchLength + MINMATCH,", "                         sequences[n].offset);", "             FSE_encodeSymbol(&blockStream, &stateOffsetBits, ofCode);           ", "             FSE_encodeSymbol(&blockStream, &stateMatchLength, mlCode);          ", "             if (MEM_32bits()) BIT_flushBits(&blockStream);                   ", "             FSE_encodeSymbol(&blockStream, &stateLitLength, llCode);            ", "             if (MEM_32bits() || (ofBits+mlBits+llBits >= 64-7-(LLFSELog+MLFSELog+OffFSELog)))", "                 BIT_flushBits(&blockStream);                                 ", "             BIT_addBits(&blockStream, sequences[n].litLength, llBits);", "             if (MEM_32bits() && ((llBits+mlBits)>24)) BIT_flushBits(&blockStream);", "             BIT_addBits(&blockStream, sequences[n].matchLength, mlBits);", "             if (MEM_32bits() || (ofBits+mlBits+llBits > 56)) BIT_flushBits(&blockStream);", "             if (longOffsets) {", "                 int const extraBits = ofBits - MIN(ofBits, STREAM_ACCUMULATOR_MIN-1);", "                 if (extraBits) {", "                     BIT_addBits(&blockStream, sequences[n].offset, extraBits);", "                     BIT_flushBits(&blockStream);                             ", "                 }", "                 BIT_addBits(&blockStream, sequences[n].offset >> extraBits,", "                             ofBits - extraBits);                             ", "             } else {", "                  BIT_addBits(&blockStream, sequences[n].offset, ofBits);      ", "              }", "              BIT_flushBits(&blockStream);                                     ", "             DEBUGLOG(7, \"remaining space : %i\", (int)(blockStream.endPtr - blockStream.ptr));", "      }   }", "      DEBUGLOG(6, \"ZSTD_encodeSequences: flushing ML state with %u bits\", stateMatchLength.stateLog);", "     FSE_flushCState(&blockStream, &stateMatchLength);", "     DEBUGLOG(6, \"ZSTD_encodeSequences: flushing Off state with %u bits\", stateOffsetBits.stateLog);", "     FSE_flushCState(&blockStream, &stateOffsetBits);", "     DEBUGLOG(6, \"ZSTD_encodeSequences: flushing LL state with %u bits\", stateLitLength.stateLog);", "     FSE_flushCState(&blockStream, &stateLitLength);", "     {   size_t const streamSize = BIT_closeCStream(&blockStream);", "         if (streamSize==0) return ERROR(dstSize_tooSmall);    ", "         return streamSize;", "     }", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  void jas_matrix_clip(jas_matrix_t *matrix, jas_seqent_t minval,", "    jas_seqent_t maxval)", "  {", "\tint i;", "\tint j;", " \tjas_matind_t i;", " \tjas_matind_t j;", "  \tjas_seqent_t v;", "  \tjas_seqent_t *rowstart;", "  \tjas_seqent_t *data;", "\tint rowstep;", " \tjas_matind_t rowstep;", "  \tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {", "  \t\tassert(matrix->rows_);", " \t\trowstep = jas_matrix_rowstep(matrix);", " \t\tfor (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,", " \t\t  rowstart += rowstep) {", " \t\t\tdata = rowstart;", " \t\t\tfor (j = matrix->numcols_, data = rowstart; j > 0; --j,", " \t\t\t  ++data) {", " \t\t\t\tv = *data;", " \t\t\t\tif (v < minval) {", " \t\t\t\t\t*data = minval;", " \t\t\t\t} else if (v > maxval) {", " \t\t\t\t\t*data = maxval;", " \t\t\t\t}", " \t\t\t}", " \t\t}", " \t}", " }"], "ner_tags": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" jas_matrix_t *jas_matrix_create(int numrows, int numcols)", "  {", "  \tjas_matrix_t *matrix;", "  \tint i;", " \tsize_t size;", " \tmatrix = 0;", "  \tif (numrows < 0 || numcols < 0) {", "\t\treturn 0;", " \t\tgoto error;", "  \t}", "  \tif (!(matrix = jas_malloc(sizeof(jas_matrix_t)))) {", "\t\treturn 0;", " \t\tgoto error;", "  \t}", "  \tmatrix->flags_ = 0;", "  \tmatrix->numrows_ = numrows;", "  \tmatrix->numcols_ = numcols;", "  \tmatrix->rows_ = 0;", "  \tmatrix->maxrows_ = numrows;", "  \tmatrix->data_ = 0;", "\tmatrix->datasize_ = numrows * numcols;", " \tmatrix->datasize_ = 0;", " \tif (!jas_safe_size_mul(numrows, numcols, &size)) {", " \t\tgoto error;", " \t}", " \tmatrix->datasize_ = size;", "  \tif (matrix->maxrows_ > 0) {", "  \t\tif (!(matrix->rows_ = jas_alloc2(matrix->maxrows_,", "  \t\t  sizeof(jas_seqent_t *)))) {", "\t\t\tjas_matrix_destroy(matrix);", "\t\t\treturn 0;", " \t\t\tgoto error;", "  \t\t}", "  \t}", "  \tif (matrix->datasize_ > 0) {", "  \t\tif (!(matrix->data_ = jas_alloc2(matrix->datasize_,", "  \t\t  sizeof(jas_seqent_t)))) {", "\t\t\tjas_matrix_destroy(matrix);", "\t\t\treturn 0;", " \t\t\tgoto error;", "  \t\t}", "  \t}", " \tfor (i = 0; i < numrows; ++i) {", " \t\tmatrix->rows_[i] = &matrix->data_[i * matrix->numcols_];", " \t}", " \tfor (i = 0; i < matrix->datasize_; ++i) {", " \t\tmatrix->data_[i] = 0;", " \t}", " \tmatrix->xstart_ = 0;", " \tmatrix->ystart_ = 0;", " \tmatrix->xend_ = matrix->numcols_;", "  \tmatrix->yend_ = matrix->numrows_;", "  \treturn matrix;", " error:", " \tif (matrix) {", " \t\tjas_matrix_destroy(matrix);", " \t}", " \treturn 0;", "  }"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0]}
{"tokens": ["  static int jpg_dec_parseopts(char *optstr, jpg_dec_importopts_t *opts)", "  {", "  \tjas_tvparser_t *tvp;", "\topts->max_size = 0;", " \topts->max_samples = 64 * JAS_MEBI;", "  \tif (!(tvp = jas_tvparser_create(optstr ? optstr : \"\"))) {", "  \t\treturn -1;", " \t}", " \twhile (!jas_tvparser_next(tvp)) {", "  \t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(decopts,", "  \t\t  jas_tvparser_gettag(tvp)))->id) {", "  \t\tcase OPT_MAXSIZE:", "\t\t\topts->max_size = atoi(jas_tvparser_getval(tvp));", " \t\t\topts->max_samples = atoi(jas_tvparser_getval(tvp));", "  \t\t\tbreak;", "  \t\tdefault:", "  \t\t\tjas_eprintf(\"warning: ignoring invalid option %s\\n\",", " \t\t\t  jas_tvparser_gettag(tvp));", " \t\t\tbreak;", " \t\t}", " \t}", " \tjas_tvparser_destroy(tvp);", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int vrend_create_vertex_elements_state(struct vrend_context *ctx,", "                                        uint32_t handle,", "                                         unsigned num_elements,", "                                         const struct pipe_vertex_element *elements)", "  {", "   struct vrend_vertex_element_array *v = CALLOC_STRUCT(vrend_vertex_element_array);", "    struct vrend_vertex_element_array *v;", "     const struct util_format_description *desc;", "     GLenum type;", "     int i;", "     uint32_t ret_handle;", "   if (!v)", "      return ENOMEM;", "     if (num_elements > PIPE_MAX_ATTRIBS)", "        return EINVAL;", "    v = CALLOC_STRUCT(vrend_vertex_element_array);", "    if (!v)", "       return ENOMEM;", "     v->count = num_elements;", "     for (i = 0; i < num_elements; i++) {", "        memcpy(&v->elements[i].base, &elements[i], sizeof(struct pipe_vertex_element));", "       desc = util_format_description(elements[i].src_format);", "       if (!desc) {", "          FREE(v);", "          return EINVAL;", "       }", "       type = GL_FALSE;", "       if (desc->channel[0].type == UTIL_FORMAT_TYPE_FLOAT) {", "          if (desc->channel[0].size == 32)", "             type = GL_FLOAT;", "          else if (desc->channel[0].size == 64)", "             type = GL_DOUBLE;", "          else if (desc->channel[0].size == 16)", "             type = GL_HALF_FLOAT;", "       } else if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED &&", "                  desc->channel[0].size == 8)", "          type = GL_UNSIGNED_BYTE;", "       else if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED &&", "                desc->channel[0].size == 8)", "          type = GL_BYTE;", "       else if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED &&", "                desc->channel[0].size == 16)", "          type = GL_UNSIGNED_SHORT;", "       else if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED &&", "                desc->channel[0].size == 16)", "          type = GL_SHORT;", "       else if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED &&", "                desc->channel[0].size == 32)", "          type = GL_UNSIGNED_INT;", "       else if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED &&", "                desc->channel[0].size == 32)", "          type = GL_INT;", "       else if (elements[i].src_format == PIPE_FORMAT_R10G10B10A2_SSCALED ||", "                elements[i].src_format == PIPE_FORMAT_R10G10B10A2_SNORM ||", "                elements[i].src_format == PIPE_FORMAT_B10G10R10A2_SNORM)", "          type = GL_INT_2_10_10_10_REV;", "       else if (elements[i].src_format == PIPE_FORMAT_R10G10B10A2_USCALED ||", "                elements[i].src_format == PIPE_FORMAT_R10G10B10A2_UNORM ||", "                elements[i].src_format == PIPE_FORMAT_B10G10R10A2_UNORM)", "          type = GL_UNSIGNED_INT_2_10_10_10_REV;", "       else if (elements[i].src_format == PIPE_FORMAT_R11G11B10_FLOAT)", "          type = GL_UNSIGNED_INT_10F_11F_11F_REV;", "       if (type == GL_FALSE) {", "          report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_VERTEX_FORMAT, elements[i].src_format);", "          FREE(v);", "          return EINVAL;", "       }", "       v->elements[i].type = type;", "       if (desc->channel[0].normalized)", "          v->elements[i].norm = GL_TRUE;", "       if (desc->nr_channels == 4 && desc->swizzle[0] == UTIL_FORMAT_SWIZZLE_Z)", "          v->elements[i].nr_chan = GL_BGRA;", "       else if (elements[i].src_format == PIPE_FORMAT_R11G11B10_FLOAT)", "          v->elements[i].nr_chan = 3;", "       else", "          v->elements[i].nr_chan = desc->nr_channels;", "    }", "    if (vrend_state.have_vertex_attrib_binding) {", "       glGenVertexArrays(1, &v->id);", "       glBindVertexArray(v->id);", "       for (i = 0; i < num_elements; i++) {", "          struct vrend_vertex_element *ve = &v->elements[i];", "          if (util_format_is_pure_integer(ve->base.src_format))", "             glVertexAttribIFormat(i, ve->nr_chan, ve->type, ve->base.src_offset);", "          else", "             glVertexAttribFormat(i, ve->nr_chan, ve->type, ve->norm, ve->base.src_offset);", "          glVertexAttribBinding(i, ve->base.vertex_buffer_index);", "          glVertexBindingDivisor(i, ve->base.instance_divisor);", "          glEnableVertexAttribArray(i);", "       }", "    }", "    ret_handle = vrend_renderer_object_insert(ctx, v, sizeof(struct vrend_vertex_element), handle,", "                                              VIRGL_OBJECT_VERTEX_ELEMENTS);", "    if (!ret_handle) {", "       FREE(v);", "       return ENOMEM;", "    }", "    return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int filter_frame(AVFilterLink *inlink, AVFrame *in)", " {", "     AVFilterContext *ctx  = inlink->dst;", "     FlipContext *s     = ctx->priv;", "     AVFilterLink *outlink = ctx->outputs[0];", "     AVFrame *out;", "     uint8_t *inrow, *outrow;", "     int i, j, plane, step;", "     out = ff_get_video_buffer(outlink, outlink->w, outlink->h);", "     if (!out) {", "         av_frame_free(&in);", "         return AVERROR(ENOMEM);", "     }", "     av_frame_copy_props(out, in);", "      if (av_pix_fmt_desc_get(inlink->format)->flags & AV_PIX_FMT_FLAG_PAL)", "          memcpy(out->data[1], in->data[1], AVPALETTE_SIZE);", "    for (plane = 0; plane < 4 && in->data[plane]; plane++) {", "     for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++) {", "          const int width  = (plane == 1 || plane == 2) ? FF_CEIL_RSHIFT(inlink->w, s->hsub) : inlink->w;", "          const int height = (plane == 1 || plane == 2) ? FF_CEIL_RSHIFT(inlink->h, s->vsub) : inlink->h;", "          step = s->max_step[plane];", "         outrow = out->data[plane];", "         inrow  = in ->data[plane] + (width - 1) * step;", "         for (i = 0; i < height; i++) {", "             switch (step) {", "             case 1:", "                 for (j = 0; j < width; j++)", "                     outrow[j] = inrow[-j];", "             break;", "             case 2:", "             {", "                 uint16_t *outrow16 = (uint16_t *)outrow;", "                 uint16_t * inrow16 = (uint16_t *) inrow;", "                 for (j = 0; j < width; j++)", "                     outrow16[j] = inrow16[-j];", "             }", "             break;", "             case 3:", "             {", "                 uint8_t *in  =  inrow;", "                 uint8_t *out = outrow;", "                 for (j = 0; j < width; j++, out += 3, in -= 3) {", "                     int32_t v = AV_RB24(in);", "                     AV_WB24(out, v);", "                 }", "             }", "             break;", "             case 4:", "             {", "                 uint32_t *outrow32 = (uint32_t *)outrow;", "                 uint32_t * inrow32 = (uint32_t *) inrow;", "                 for (j = 0; j < width; j++)", "                     outrow32[j] = inrow32[-j];", "             }", "             break;", "             default:", "                 for (j = 0; j < width; j++)", "                     memcpy(outrow + j*step, inrow - j*step, step);", "             }", "             inrow  += in ->linesize[plane];", "             outrow += out->linesize[plane];", "         }", "     }", "     av_frame_free(&in);", "     return ff_filter_frame(outlink, out);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int rm_read_multi(AVFormatContext *s, AVIOContext *pb,", "                          AVStream *st, char *mime)", " {", "     int number_of_streams = avio_rb16(pb);", "     int number_of_mdpr;", "     int i, ret;", "     unsigned size2;", "     for (i = 0; i<number_of_streams; i++)", "         avio_rb16(pb);", "     number_of_mdpr = avio_rb16(pb);", "     if (number_of_mdpr != 1) {", "         avpriv_request_sample(s, \"MLTI with multiple (%d) MDPR\", number_of_mdpr);", "     }", "     for (i = 0; i < number_of_mdpr; i++) {", "         AVStream *st2;", "         if (i > 0) {", "             st2 = avformat_new_stream(s, NULL);", "             if (!st2) {", "                 ret = AVERROR(ENOMEM);", "                 return ret;", "             }", "             st2->id = st->id + (i<<16);", "             st2->codecpar->bit_rate = st->codecpar->bit_rate;", "             st2->start_time = st->start_time;", "             st2->duration   = st->duration;", "             st2->codecpar->codec_type = AVMEDIA_TYPE_DATA;", "             st2->priv_data = ff_rm_alloc_rmstream();", "             if (!st2->priv_data)", "                 return AVERROR(ENOMEM);", "         } else", "             st2 = st;", "          size2 = avio_rb32(pb);", "          ret = ff_rm_read_mdpr_codecdata(s, s->pb, st2, st2->priv_data,", "                                        size2, mime);", "                                         size2, NULL);", "          if (ret < 0)", "              return ret;", "      }", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" void CtcpHandler::handleTime(CtcpType ctcptype, const QString &prefix, const QString &target, const QString &param) {", " void CtcpHandler::handleTime(CtcpType ctcptype, const QString &prefix, const QString &target, const QString &param, QString &reply) {", "    Q_UNUSED(target)", "    if(ctcptype == CtcpQuery) {", "    if(_ignoreListManager->ctcpMatch(prefix, network()->networkName(), \"TIME\"))", "      return;", "    reply(nickFromMask(prefix), \"TIME\", QDateTime::currentDateTime().toString());", "     reply = QDateTime::currentDateTime().toString();", "      emit displayMsg(Message::Server, BufferInfo::StatusBuffer, \"\", tr(\"Received CTCP TIME request by %1\").arg(prefix));", "  }", "  else {", "   } else {", "      emit displayMsg(Message::Server, BufferInfo::StatusBuffer, \"\", tr(\"Received CTCP TIME answer from %1: %2\")", "                      .arg(nickFromMask(prefix)).arg(param));", "    }", "  }"], "ner_tags": [0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": [" static int DecodeGifImg(struct ngiflib_img * i) {", " \tstruct ngiflib_decode_context context;", " \tlong npix;", " \tu8 * stackp;", " \tu8 * stack_top;", " \tu16 clr;", " \tu16 eof;", " \tu16 free;", " \tu16 act_code = 0;", " \tu16 old_code = 0;", " \tu16 read_byt;", " \tu16 ab_prfx[4096];", " \tu8 ab_suffx[4096];", " \tu8 ab_stack[4096];", " \tu8 flags;", " \tu8 casspecial = 0;", " \tif(!i) return -1;", " \ti->posX = GetWord(i->parent);\t ", " \ti->posY = GetWord(i->parent);\t ", "  \ti->width = GetWord(i->parent);\t ", "  \ti->height = GetWord(i->parent);\t ", " \tif((i->width > i->parent->width) || (i->height > i->parent->height)) {", " #if !defined(NGIFLIB_NO_FILE)", " \t\tif(i->parent->log) fprintf(i->parent->log, \"*** ERROR *** Image bigger than global GIF canvas !\\n\");", " #endif", " \t\treturn -1;", " \t}", " \tif((i->posX + i->width) > i->parent->width) {", " #if !defined(NGIFLIB_NO_FILE)", " \t\tif(i->parent->log) fprintf(i->parent->log, \"*** WARNING *** Adjusting X position\\n\");", " #endif", " \t\ti->posX = i->parent->width - i->width;", " \t}", " \tif((i->posY + i->height) > i->parent->height) {", " #if !defined(NGIFLIB_NO_FILE)", " \t\tif(i->parent->log) fprintf(i->parent->log, \"*** WARNING *** Adjusting Y position\\n\");", " #endif", " \t\ti->posY = i->parent->height - i->height;", " \t}", "  \tcontext.Xtogo = i->width;", "  \tcontext.curY = i->posY;", "  #ifdef NGIFLIB_INDEXED_ONLY", " \t#ifdef NGIFLIB_ENABLE_CALLBACKS", " \tcontext.line_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width;", " \tcontext.frbuff_p.p8 = context.line_p.p8 + i->posX;", " \t#else", " \tcontext.frbuff_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width + i->posX;", " \t#endif  ", " #else", " \tif(i->parent->mode & NGIFLIB_MODE_INDEXED) {", " \t\t#ifdef NGIFLIB_ENABLE_CALLBACKS", " \t\tcontext.line_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width;", " \t\tcontext.frbuff_p.p8 = context.line_p.p8 + i->posX;", " \t\t#else", " \t\tcontext.frbuff_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width + i->posX;", " \t\t#endif  ", " \t} else {", " \t\t#ifdef NGIFLIB_ENABLE_CALLBACKS", " \t\tcontext.line_p.p32 = i->parent->frbuff.p32 + (u32)i->posY*i->parent->width;", " \t\tcontext.frbuff_p.p32 = context.line_p.p32 + i->posX;", " \t\t#else", " \t\tcontext.frbuff_p.p32 = i->parent->frbuff.p32 + (u32)i->posY*i->parent->width + i->posX;", " \t\t#endif  ", " \t}", " #endif  ", " \tnpix = (long)i->width * i->height;", " \tflags = GetByte(i->parent);", " \ti->interlaced = (flags & 64) >> 6;", " \tcontext.pass = i->interlaced ? 1 : 0;", " \ti->sort_flag = (flags & 32) >> 5;\t ", " \ti->localpalbits = (flags & 7) + 1;", " \tif(flags&128) {  ", " \t\tint k;", " \t\tint localpalsize = 1 << i->localpalbits;", " #if !defined(NGIFLIB_NO_FILE)", " \t\tif(i->parent && i->parent->log) fprintf(i->parent->log, \"Local palette\\n\");", " #endif  ", " \t\ti->palette = (struct ngiflib_rgb *)ngiflib_malloc(sizeof(struct ngiflib_rgb)*localpalsize);", " \t\tfor(k=0; k<localpalsize; k++) {", " \t\t\ti->palette[k].r = GetByte(i->parent);", " \t\t\ti->palette[k].g = GetByte(i->parent);", " \t\t\ti->palette[k].b = GetByte(i->parent);", " \t\t}", " #ifdef NGIFLIB_ENABLE_CALLBACKS", " \t\tif(i->parent->palette_cb) i->parent->palette_cb(i->parent, i->palette, localpalsize);", " #endif  ", " \t} else {", " \t\ti->palette = i->parent->palette;", " \t\ti->localpalbits = i->parent->imgbits;", " \t}", " \ti->ncolors = 1 << i->localpalbits;", " \ti->imgbits = GetByte(i->parent);\t ", " #if !defined(NGIFLIB_NO_FILE)", " \tif(i->parent && i->parent->log) {", " \t\tif(i->interlaced) fprintf(i->parent->log, \"interlaced \");", " \t\tfprintf(i->parent->log, \"img pos(%hu,%hu) size %hux%hu palbits=%hhu imgbits=%hhu ncolors=%hu\\n\",", " \t       i->posX, i->posY, i->width, i->height, i->localpalbits, i->imgbits, i->ncolors);", " \t}", " #endif  ", " \tif(i->imgbits==1) {\t ", " \t\ti->imgbits = 2;", " \t}", " \tclr = 1 << i->imgbits;", " \teof = clr + 1;", " \tfree = clr + 2;", " \tcontext.nbbit = i->imgbits + 1;", " \tcontext.max = clr + clr - 1;  ", " \tstackp = stack_top = ab_stack + 4096;", " \tcontext.restbits = 0;\t ", " \tcontext.restbyte = 0;\t ", " \tcontext.lbyte = 0;", " \tfor(;;) {", " \t\tact_code = GetGifWord(i, &context);", " \t\tif(act_code==eof) {", " #if !defined(NGIFLIB_NO_FILE)", " \t\t\tif(i->parent && i->parent->log) fprintf(i->parent->log, \"End of image code\\n\");", " #endif  ", " \t\t\treturn 0;", " \t\t}", " \t\tif(npix==0) {", " #if !defined(NGIFLIB_NO_FILE)", " \t\t\tif(i->parent && i->parent->log) fprintf(i->parent->log, \"assez de pixels, On se casse !\\n\");", " #endif  ", " \t\t\treturn 1;", " \t\t}\t", " \t\tif(act_code==clr) {", " #if !defined(NGIFLIB_NO_FILE)", " \t\t\tif(i->parent && i->parent->log) fprintf(i->parent->log, \"Code clear (free=%hu) npix=%ld\\n\", free, npix);", " #endif  ", " \t\t\tfree = clr + 2;", " \t\t\tcontext.nbbit = i->imgbits + 1;", " \t\t\tcontext.max = clr + clr - 1;  ", " \t\t\tact_code = GetGifWord(i, &context);", " \t\t\tcasspecial = (u8)act_code;", " \t\t\told_code = act_code;", " \t\t\tWritePixel(i, &context, casspecial); npix--;", " \t\t} else {", " \t\t\tread_byt = act_code;", " \t\t\tif(act_code >= free) {\t ", " \t\t\t\t*(--stackp) = casspecial;  ", " \t\t\t\tact_code = old_code;", " \t\t\t}", " \t\t\twhile(act_code > clr) {  ", " \t\t\t\t*(--stackp) = ab_suffx[act_code];", " \t\t\t\tact_code = ab_prfx[act_code];\t ", " \t\t\t}", " \t\t\tcasspecial = (u8)act_code;\t ", " \t\t\t*(--stackp) = casspecial;\t ", " \t\t\tWritePixels(i, &context, stackp, stack_top - stackp);\t ", " \t\t\tnpix -= (stack_top - stackp);", " \t\t\tstackp = stack_top;", " \t\t\tif(free < 4096) {  ", " \t\t\t\tab_prfx[free] = old_code;", " \t\t\t\tab_suffx[free] = (u8)act_code;", " \t\t\t\tfree++;", " \t\t\t\tif((free > context.max) && (context.nbbit < 12)) {", " \t\t\t\t\tcontext.nbbit++;\t ", " \t\t\t\t\tcontext.max += context.max + 1;", " \t\t\t\t}", " \t\t\t}", " \t\t\told_code = read_byt;", " \t\t}", " \t}", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int asf_read_marker(AVFormatContext *s, int64_t size)", " {", "     AVIOContext *pb = s->pb;", "     ASFContext *asf = s->priv_data;", "     int i, count, name_len, ret;", "     char name[1024];", "     avio_rl64(pb);             ", "     avio_rl64(pb);             ", "      count = avio_rl32(pb);     ", "      avio_rl16(pb);             ", "      name_len = avio_rl16(pb);  ", "    for (i = 0; i < name_len; i++)", "        avio_r8(pb);  ", "     avio_skip(pb, name_len);", "      for (i = 0; i < count; i++) {", "          int64_t pres_time;", "          int name_len;", "         if (avio_feof(pb))", "             return AVERROR_INVALIDDATA;", "          avio_rl64(pb);              ", "          pres_time = avio_rl64(pb);  ", "          pres_time -= asf->hdr.preroll * 10000;", "         avio_rl16(pb);              ", "         avio_rl32(pb);              ", "         avio_rl32(pb);              ", "         name_len = avio_rl32(pb);   ", "         if ((ret = avio_get_str16le(pb, name_len * 2, name,", "                                     sizeof(name))) < name_len)", "             avio_skip(pb, name_len - ret);", "         avpriv_new_chapter(s, i, (AVRational) { 1, 10000000 }, pres_time,", "                            AV_NOPTS_VALUE, name);", "     }", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static jas_image_cmpt_t *jas_image_cmpt_create(int_fast32_t tlx,", "   int_fast32_t tly, int_fast32_t hstep, int_fast32_t vstep,", "   int_fast32_t width, int_fast32_t height, uint_fast16_t depth, bool sgnd,", "   uint_fast32_t inmem)", " {", " \tjas_image_cmpt_t *cmpt;", " \tsize_t size;", " \tcmpt = 0;", " \tif (width < 0 || height < 0 || hstep <= 0 || vstep <= 0) {", " \t\tgoto error;", " \t}", " \tif (!jas_safe_intfast32_add(tlx, width, 0) ||", " \t  !jas_safe_intfast32_add(tly, height, 0)) {", " \t\tgoto error;", " \t}", " \tif (!(cmpt = jas_malloc(sizeof(jas_image_cmpt_t)))) {", " \t\tgoto error;", " \t}", " \tcmpt->type_ = JAS_IMAGE_CT_UNKNOWN;", " \tcmpt->tlx_ = tlx;", " \tcmpt->tly_ = tly;", " \tcmpt->hstep_ = hstep;", " \tcmpt->vstep_ = vstep;", " \tcmpt->width_ = width;", " \tcmpt->height_ = height;", " \tcmpt->prec_ = depth;", " \tcmpt->sgnd_ = sgnd;", " \tcmpt->stream_ = 0;", " \tcmpt->cps_ = (depth + 7) / 8;", " \tif (!jas_safe_size_mul(cmpt->width_, cmpt->height_, &size) ||", "  \t  !jas_safe_size_mul(size, cmpt->cps_, &size)) {", "  \t\tgoto error;", "  \t}", "\tcmpt->stream_ = (inmem) ? jas_stream_memopen(0, size) :", " \tcmpt->stream_ = (inmem) ? jas_stream_memopen2(0, size) :", "  \t  jas_stream_tmpfile();", "  \tif (!cmpt->stream_) {", "  \t\tgoto error;", " \t}", " \tif (jas_stream_seek(cmpt->stream_, size - 1, SEEK_SET) < 0 ||", " \t  jas_stream_putc(cmpt->stream_, 0) == EOF ||", " \t  jas_stream_seek(cmpt->stream_, 0, SEEK_SET) < 0) {", " \t\tgoto error;", " \t}", " \treturn cmpt;", " error:", " \tif (cmpt) {", " \t\tjas_image_cmpt_destroy(cmpt);", " \t}", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int gemsafe_get_cert_len(sc_card_t *card)", " {", " \tint r;", " \tu8  ibuf[GEMSAFE_MAX_OBJLEN];", " \tu8 *iptr;", " \tstruct sc_path path;", " \tstruct sc_file *file;", " \tsize_t objlen, certlen;", " \tunsigned int ind, i=0;", " \tsc_format_path(GEMSAFE_PATH, &path);", " \tr = sc_select_file(card, &path, &file);", " \tif (r != SC_SUCCESS || !file)", " \t\treturn SC_ERROR_INTERNAL;", " \tr = sc_read_binary(card, 0, ibuf, GEMSAFE_READ_QUANTUM, 0);", " \tif (r < 0)", " \t\treturn SC_ERROR_INTERNAL;", " \tobjlen = (((size_t) ibuf[0]) << 8) | ibuf[1];", " \tsc_log(card->ctx, \"Stored object is of size: %\"SC_FORMAT_LEN_SIZE_T\"u\",", " \t       objlen);", " \tif (objlen < 1 || objlen > GEMSAFE_MAX_OBJLEN) {", " \t    sc_log(card->ctx, \"Invalid object size: %\"SC_FORMAT_LEN_SIZE_T\"u\",", " \t\t   objlen);", " \t    return SC_ERROR_INTERNAL;", " \t}", "  \tind = 2;  ", "\twhile (ibuf[ind] == 0x01) {", " \twhile (ibuf[ind] == 0x01 && i < gemsafe_cert_max) {", "  \t\tif (ibuf[ind+1] == 0xFE) {", "  \t\t\tgemsafe_prkeys[i].ref = ibuf[ind+4];", "  \t\t\tsc_log(card->ctx, \"Key container %d is allocated and uses key_ref %d\",", " \t\t\t\t\ti+1, gemsafe_prkeys[i].ref);", " \t\t\tind += 9;", " \t\t}", " \t\telse {", " \t\t\tgemsafe_prkeys[i].label = NULL;", " \t\t\tgemsafe_cert[i].label = NULL;", " \t\t\tsc_log(card->ctx, \"Key container %d is unallocated\", i+1);", " \t\t\tind += 8;", " \t\t}", " \t\ti++;", " \t}", " \tfor (; i < gemsafe_cert_max; i++) {", " \t\tgemsafe_prkeys[i].label = NULL;", " \t\tgemsafe_cert[i].label = NULL;", " \t}", " \tiptr = ibuf + GEMSAFE_READ_QUANTUM;", " \twhile ((size_t)(iptr - ibuf) < objlen) {", " \t\tr = sc_read_binary(card, iptr - ibuf, iptr,", " \t\t\t\t   MIN(GEMSAFE_READ_QUANTUM, objlen - (iptr - ibuf)), 0);", " \t\tif (r < 0) {", " \t\t\tsc_log(card->ctx, \"Could not read cert object\");", " \t\t\treturn SC_ERROR_INTERNAL;", " \t\t}", " \t\tiptr += GEMSAFE_READ_QUANTUM;", " \t}", " \ti = 0;", " \twhile (ind < objlen - 1) {", " \t\tif (ibuf[ind] == 0x30 && ibuf[ind+1] == 0x82) {", " \t\t\twhile (i < gemsafe_cert_max && gemsafe_cert[i].label == NULL)", " \t\t\t\ti++;", " \t\t\tif (i == gemsafe_cert_max) {", " \t\t\t\tsc_log(card->ctx, \"Warning: Found orphaned certificate at offset %d\", ind);", " \t\t\t\treturn SC_SUCCESS;", " \t\t\t}", " \t\t\tif (ind+3 >= sizeof ibuf)", " \t\t\t\treturn SC_ERROR_INVALID_DATA;", " \t\t\tcertlen = ((((size_t) ibuf[ind+2]) << 8) | ibuf[ind+3]) + 4;", " \t\t\tsc_log(card->ctx,", " \t\t\t       \"Found certificate of key container %d at offset %d, len %\"SC_FORMAT_LEN_SIZE_T\"u\",", " \t\t\t       i+1, ind, certlen);", " \t\t\tgemsafe_cert[i].index = ind;", " \t\t\tgemsafe_cert[i].count = certlen;", " \t\t\tind += certlen;", " \t\t\ti++;", " \t\t} else", " \t\t\tind++;", " \t}", " \tfor (; i < gemsafe_cert_max; i++) {", " \t\tif (gemsafe_cert[i].label) {", " \t\t\tsc_log(card->ctx, \"Warning: Certificate of key container %d is missing\", i+1);", " \t\t\tgemsafe_prkeys[i].label = NULL;", " \t\t\tgemsafe_cert[i].label = NULL;", " \t\t}", " \t}", " \treturn SC_SUCCESS;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int parse_video_info(AVIOContext *pb, AVStream *st)", " {", "     uint16_t size_asf;  ", "     uint32_t size_bmp;  ", "     unsigned int tag;", "     st->codecpar->width  = avio_rl32(pb);", "     st->codecpar->height = avio_rl32(pb);", "     avio_skip(pb, 1);  ", "     size_asf = avio_rl16(pb);", "     tag = ff_get_bmp_header(pb, st, &size_bmp);", "     st->codecpar->codec_tag = tag;", "      st->codecpar->codec_id  = ff_codec_get_id(ff_codec_bmp_tags, tag);", "      size_bmp = FFMAX(size_asf, size_bmp);", "    if (size_bmp > BMP_HEADER_SIZE) {", "     if (size_bmp > BMP_HEADER_SIZE &&", "         size_bmp < INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE) {", "          int ret;", "          st->codecpar->extradata_size  = size_bmp - BMP_HEADER_SIZE;", "          if (!(st->codecpar->extradata = av_malloc(st->codecpar->extradata_size +", "                                                AV_INPUT_BUFFER_PADDING_SIZE))) {", "             st->codecpar->extradata_size = 0;", "             return AVERROR(ENOMEM);", "         }", "         memset(st->codecpar->extradata + st->codecpar->extradata_size , 0,", "                AV_INPUT_BUFFER_PADDING_SIZE);", "         if ((ret = avio_read(pb, st->codecpar->extradata,", "                              st->codecpar->extradata_size)) < 0)", "             return ret;", "     }", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int er_supported(ERContext *s)", "  {", "      if(s->avctx->hwaccel && s->avctx->hwaccel->decode_slice           ||", "         !s->cur_pic.f                                                  ||", "       s->cur_pic.field_picture                                       ||", "       s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO", "        s->cur_pic.field_picture", "      )", "          return 0;", "      return 1;", " }"], "ner_tags": [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": [" static float *get_window(vorb *f, int len)", " {", "     len <<= 1;", "     if (len == f->blocksize_0) return f->window[0];", "     if (len == f->blocksize_1) return f->window[1];", "   assert(0);", "     return NULL;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": [" static int dnxhd_find_frame_end(DNXHDParserContext *dctx,", "                                 const uint8_t *buf, int buf_size)", " {", "     ParseContext *pc = &dctx->pc;", "     uint64_t state = pc->state64;", "     int pic_found = pc->frame_start_found;", "     int i = 0;", "     int interlaced = dctx->interlaced;", "     int cur_field = dctx->cur_field;", "     if (!pic_found) {", "         for (i = 0; i < buf_size; i++) {", "             state = (state << 8) | buf[i];", "             if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {", "                 i++;", "                 pic_found = 1;", "                 interlaced = (state&2)>>1;  ", "                 cur_field = state&1;", "                 dctx->cur_byte = 0;", "                 dctx->remaining = 0;", "                 break;", "             }", "         }", "     }", "     if (pic_found && !dctx->remaining) {", "         if (!buf_size)  ", "             return 0;", "         for (; i < buf_size; i++) {", "             dctx->cur_byte++;", "             state = (state << 8) | buf[i];", "             if (dctx->cur_byte == 24) {", "                 dctx->h = (state >> 32) & 0xFFFF;", "             } else if (dctx->cur_byte == 26) {", "                  dctx->w = (state >> 32) & 0xFFFF;", "              } else if (dctx->cur_byte == 42) {", "                  int cid = (state >> 32) & 0xFFFFFFFF;", "                 int remaining;", "                  if (cid <= 0)", "                      continue;", "                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);", "                if (dctx->remaining <= 0) {", "                    dctx->remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);", "                    if (dctx->remaining <= 0)", "                        return dctx->remaining;", "                 remaining = avpriv_dnxhd_get_frame_size(cid);", "                 if (remaining <= 0) {", "                     remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);", "                     if (remaining <= 0)", "                         continue;", "                  }", "                 dctx->remaining = remaining;", "                  if (buf_size - i >= dctx->remaining && (!dctx->interlaced || dctx->cur_field)) {", "                      int remaining = dctx->remaining;", "                     pc->frame_start_found = 0;", "                     pc->state64 = -1;", "                     dctx->interlaced = interlaced;", "                     dctx->cur_field = 0;", "                     dctx->cur_byte = 0;", "                     dctx->remaining = 0;", "                     return remaining;", "                 } else {", "                     dctx->remaining -= buf_size;", "                 }", "             }", "         }", "     } else if (pic_found) {", "         if (dctx->remaining > buf_size) {", "             dctx->remaining -= buf_size;", "         } else {", "             int remaining = dctx->remaining;", "             pc->frame_start_found = 0;", "             pc->state64 = -1;", "             dctx->interlaced = interlaced;", "             dctx->cur_field = 0;", "             dctx->cur_byte = 0;", "             dctx->remaining = 0;", "             return remaining;", "         }", "     }", "     pc->frame_start_found = pic_found;", "     pc->state64 = state;", "     dctx->interlaced = interlaced;", "     dctx->cur_field = cur_field;", "     return END_NOT_FOUND;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" const char * util_acl_to_str(const sc_acl_entry_t *e)", " {", " \tstatic char line[80], buf[20];", " \tunsigned int acl;", " \tif (e == NULL)", " \t\treturn \"N/A\";", " \tline[0] = 0;", " \twhile (e != NULL) {", " \t\tacl = e->method;", " \t\tswitch (acl) {", " \t\tcase SC_AC_UNKNOWN:", " \t\t\treturn \"N/A\";", " \t\tcase SC_AC_NEVER:", " \t\t\treturn \"NEVR\";", " \t\tcase SC_AC_NONE:", " \t\t\treturn \"NONE\";", " \t\tcase SC_AC_CHV:", " \t\t\tstrcpy(buf, \"CHV\");", " \t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)", " \t\t\t\tsprintf(buf + 3, \"%d\", e->key_ref);", " \t\t\tbreak;", " \t\tcase SC_AC_TERM:", " \t\t\tstrcpy(buf, \"TERM\");", " \t\t\tbreak;", " \t\tcase SC_AC_PRO:", " \t\t\tstrcpy(buf, \"PROT\");", " \t\t\tbreak;", " \t\tcase SC_AC_AUT:", " \t\t\tstrcpy(buf, \"AUTH\");", " \t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)", " \t\t\t\tsprintf(buf + 4, \"%d\", e->key_ref);", " \t\t\tbreak;", " \t\tcase SC_AC_SEN:", " \t\t\tstrcpy(buf, \"Sec.Env. \");", " \t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)", " \t\t\t\tsprintf(buf + 3, \"#%d\", e->key_ref);", " \t\t\tbreak;", " \t\tcase SC_AC_SCB:", " \t\t\tstrcpy(buf, \"Sec.ControlByte \");", " \t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)", " \t\t\t\tsprintf(buf + 3, \"Ox%X\", e->key_ref);", " \t\t\tbreak;", " \t\tcase SC_AC_IDA:", " \t\t\tstrcpy(buf, \"PKCS#15 AuthID \");", " \t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)", " \t\t\t\tsprintf(buf + 3, \"#%d\", e->key_ref);", " \t\t\tbreak;", " \t\tdefault:", "  \t\t\tstrcpy(buf, \"????\");", "  \t\t\tbreak;", "  \t\t}", "\t\tstrcat(line, buf);", "\t\tstrcat(line, \" \");", " \t\tstrncat(line, buf, sizeof line);", " \t\tstrncat(line, \" \", sizeof line);", "  \t\te = e->next;", "  \t}", " \tline[(sizeof line)-1] = '\\0';  ", "  \tline[strlen(line)-1] = 0;  ", "  \treturn line;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0]}
{"tokens": ["  void jas_matrix_divpow2(jas_matrix_t *matrix, int n)", "  {", "\tint i;", "\tint j;", " \tjas_matind_t i;", " \tjas_matind_t j;", "  \tjas_seqent_t *rowstart;", "\tint rowstep;", " \tjas_matind_t rowstep;", "  \tjas_seqent_t *data;", "  \tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {", " \t\tassert(matrix->rows_);", " \t\trowstep = jas_matrix_rowstep(matrix);", " \t\tfor (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,", " \t\t  rowstart += rowstep) {", " \t\t\tfor (j = matrix->numcols_, data = rowstart; j > 0; --j,", " \t\t\t  ++data) {", " \t\t\t\t*data = (*data >= 0) ? ((*data) >> n) :", " \t\t\t\t  (-((-(*data)) >> n));", " \t\t\t}", " \t\t}", " \t}", " }"], "ner_tags": [0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int entersafe_gen_key(sc_card_t *card, sc_entersafe_gen_key_data *data)", " {", " \tint\tr;", " \tsize_t len = data->key_length >> 3;", " \tsc_apdu_t apdu;", " \tu8 rbuf[300];", " \tu8 sbuf[4],*p;", " \tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);", " \tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x22, 0x01, 0xB8);", " \tapdu.lc=0x04;", " \tsbuf[0]=0x83;", " \tsbuf[1]=0x02;", " \tsbuf[2]=data->key_id;", " \tsbuf[3]=0x2A;", " \tapdu.data = sbuf;", " \tapdu.datalen=4;", " \tapdu.lc=4;", " \tapdu.le=0;", " \tr=entersafe_transmit_apdu(card, &apdu, 0,0,0,0);", " \tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");", " \tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, sc_check_sw(card,apdu.sw1,apdu.sw2),\"EnterSafe set MSE failed\");", " \tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x46,  0x00, 0x00);", " \tapdu.le      = 0;", " \tsbuf[0] = (u8)(data->key_length >> 8);", " \tsbuf[1] = (u8)(data->key_length);", " \tapdu.data    = sbuf;", " \tapdu.lc      = 2;", " \tapdu.datalen = 2;", " \tr = entersafe_transmit_apdu(card, &apdu,0,0,0,0);", " \tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");", " \tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, sc_check_sw(card,apdu.sw1,apdu.sw2),\"EnterSafe generate keypair failed\");", " \tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xE6,  0x2A, data->key_id);", " \tapdu.cla     = 0x80;", " \tapdu.resp    = rbuf;", " \tapdu.resplen = sizeof(rbuf);", " \tapdu.le      = 256;", " \tr = entersafe_transmit_apdu(card, &apdu,0,0,0,0);", " \tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");", " \tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, sc_check_sw(card,apdu.sw1,apdu.sw2),\"EnterSafe get pukey failed\");", "  \tdata->modulus = malloc(len);", "  \tif (!data->modulus)", "\t\t SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,SC_ERROR_OUT_OF_MEMORY);", " \t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_OUT_OF_MEMORY);", "  \tp=rbuf;", "\tassert(*p=='E');", " \tif (*p!='E')", " \t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_DATA);", "  \tp+=2+p[1];", "\tassert(*p=='N');", " \tif (*p!='N')", " \t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_DATA);", "  \t++p;", "  \tif(*p++>0x80)", "  \t{", " \t\t u8 len_bytes=(*(p-1))&0x0f;", " \t\t size_t module_len=0;", " \t\t while(len_bytes!=0)", " \t\t {", " \t\t\t  module_len=module_len<<8;", " \t\t\t  module_len+=*p++;", " \t\t\t  --len_bytes;", " \t\t }", " \t}", " \tentersafe_reverse_buffer(p,len);", " \tmemcpy(data->modulus,p,len);", " \tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,SC_SUCCESS);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" JsVar *jswrap_graphics_createArrayBuffer(int width, int height, int bpp, JsVar *options) {", "   if (width<=0 || height<=0 || width>32767 || height>32767) {", "     jsExceptionHere(JSET_ERROR, \"Invalid Size\");", "     return 0;", "   }", "   if (!isValidBPP(bpp)) {", "     jsExceptionHere(JSET_ERROR, \"Invalid BPP\");", "     return 0;", "   }", "   JsVar *parent = jspNewObject(0, \"Graphics\");", "   if (!parent) return 0;  ", "   JsGraphics gfx;", "   graphicsStructInit(&gfx);", "   gfx.data.type = JSGRAPHICSTYPE_ARRAYBUFFER;", "   gfx.data.flags = JSGRAPHICSFLAGS_NONE;", "   gfx.graphicsVar = parent;", "   gfx.data.width = (unsigned short)width;", "   gfx.data.height = (unsigned short)height;", "   gfx.data.bpp = (unsigned char)bpp;", "   if (jsvIsObject(options)) {", "     if (jsvGetBoolAndUnLock(jsvObjectGetChild(options, \"zigzag\", 0)))", "       gfx.data.flags = (JsGraphicsFlags)(gfx.data.flags | JSGRAPHICSFLAGS_ARRAYBUFFER_ZIGZAG);", "     if (jsvGetBoolAndUnLock(jsvObjectGetChild(options, \"msb\", 0)))", "       gfx.data.flags = (JsGraphicsFlags)(gfx.data.flags | JSGRAPHICSFLAGS_ARRAYBUFFER_MSB);", "      if (jsvGetBoolAndUnLock(jsvObjectGetChild(options, \"vertical_byte\", 0))) {", "        if (gfx.data.bpp==1)", "          gfx.data.flags = (JsGraphicsFlags)(gfx.data.flags | JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE);", "      else", "        jsWarn(\"vertical_byte only works for 1bpp ArrayBuffers\\n\");", "       else {", "         jsExceptionHere(JSET_ERROR, \"vertical_byte only works for 1bpp ArrayBuffers\\n\");", "         return 0;", "       }", "       if (gfx.data.height&7) {", "         jsExceptionHere(JSET_ERROR, \"height must be a multiple of 8 when using vertical_byte\\n\");", "         return 0;", "       }", "      }", "      JsVar *colorv = jsvObjectGetChild(options, \"color_order\", 0);", "      if (colorv) {", "       if (jsvIsStringEqual(colorv, \"rgb\")) ;  ", "       else if (!jsvIsStringEqual(colorv, \"brg\"))", "         gfx.data.flags = (JsGraphicsFlags)(gfx.data.flags | JSGRAPHICSFLAGS_COLOR_BRG);", "       else if (!jsvIsStringEqual(colorv, \"bgr\"))", "         gfx.data.flags = (JsGraphicsFlags)(gfx.data.flags | JSGRAPHICSFLAGS_COLOR_BGR);", "       else if (!jsvIsStringEqual(colorv, \"gbr\"))", "         gfx.data.flags = (JsGraphicsFlags)(gfx.data.flags | JSGRAPHICSFLAGS_COLOR_GBR);", "       else if (!jsvIsStringEqual(colorv, \"grb\"))", "         gfx.data.flags = (JsGraphicsFlags)(gfx.data.flags | JSGRAPHICSFLAGS_COLOR_GRB);", "       else if (!jsvIsStringEqual(colorv, \"rbg\"))", "         gfx.data.flags = (JsGraphicsFlags)(gfx.data.flags | JSGRAPHICSFLAGS_COLOR_RBG);", "       else", "         jsWarn(\"color_order must be 3 characters\");", "       jsvUnLock(colorv);", "     }", "   }", "   lcdInit_ArrayBuffer(&gfx);", "   graphicsSetVar(&gfx);", "   return parent;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" size_t compile_tree(struct filter_op **fop)", " {", "    int i = 1;", "     struct filter_op *array = NULL;", "     struct unfold_elm *ue;", "   BUG_IF(tree_root == NULL);", "    if (tree_root == NULL)", "       return 0;", "     fprintf(stdout, \" Unfolding the meta-tree \");", "     fflush(stdout);", "    unfold_blk(&tree_root);", "    fprintf(stdout, \" done.\\n\\n\");", "    labels_to_offsets();", "    TAILQ_FOREACH(ue, &unfolded_tree, next) {", "       if (ue->label == 0) {", "          SAFE_REALLOC(array, i * sizeof(struct filter_op));", "          memcpy(&array[i - 1], &ue->fop, sizeof(struct filter_op));", "          i++;", "       }", "    }", "    SAFE_REALLOC(array, i * sizeof(struct filter_op));", "    array[i - 1].opcode = FOP_EXIT;", "    *fop = array;", "    return (i);", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int64_t http_seek_internal(URLContext *h, int64_t off, int whence, int force_reconnect)", "  {", "      HTTPContext *s = h->priv_data;", "      URLContext *old_hd = s->hd;", "    int64_t old_off = s->off;", "     uint64_t old_off = s->off;", "      uint8_t old_buf[BUFFER_SIZE];", "      int old_buf_size, ret;", "      AVDictionary *options = NULL;", "     if (whence == AVSEEK_SIZE)", "         return s->filesize;", "     else if (!force_reconnect &&", "               ((whence == SEEK_CUR && off == 0) ||", "                (whence == SEEK_SET && off == s->off)))", "          return s->off;", "    else if ((s->filesize == -1 && whence == SEEK_END))", "     else if ((s->filesize == UINT64_MAX && whence == SEEK_END))", "          return AVERROR(ENOSYS);", "      if (whence == SEEK_CUR)", "         off += s->off;", "     else if (whence == SEEK_END)", "         off += s->filesize;", "     else if (whence != SEEK_SET)", "         return AVERROR(EINVAL);", "     if (off < 0)", "         return AVERROR(EINVAL);", "     s->off = off;", "     if (s->off && h->is_streamed)", "         return AVERROR(ENOSYS);", "     old_buf_size = s->buf_end - s->buf_ptr;", "     memcpy(old_buf, s->buf_ptr, old_buf_size);", "     s->hd = NULL;", "     if ((ret = http_open_cnx(h, &options)) < 0) {", "         av_dict_free(&options);", "         memcpy(s->buffer, old_buf, old_buf_size);", "         s->buf_ptr = s->buffer;", "         s->buf_end = s->buffer + old_buf_size;", "         s->hd      = old_hd;", "         s->off     = old_off;", "         return ret;", "     }", "     av_dict_free(&options);", "     ffurl_close(old_hd);", "     return off;", " }"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" hstore_recv(PG_FUNCTION_ARGS)", " {", " \tint32\t\tbuflen;", " \tHStore\t   *out;", " \tPairs\t   *pairs;", " \tint32\t\ti;", " \tint32\t\tpcount;", " \tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);", " \tpcount = pq_getmsgint(buf, 4);", " \tif (pcount == 0)", " \t{", " \t\tout = hstorePairs(NULL, 0, 0);", "  \t\tPG_RETURN_POINTER(out);", "  \t}", " \tif (pcount < 0 || pcount > MaxAllocSize / sizeof(Pairs))", " \t\tereport(ERROR,", " \t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),", " \t\t\t  errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",", " \t\t\t\t\t pcount, (int) (MaxAllocSize / sizeof(Pairs)))));", "  \tpairs = palloc(pcount * sizeof(Pairs));", "  \tfor (i = 0; i < pcount; ++i)", " \t{", " \t\tint\t\t\trawlen = pq_getmsgint(buf, 4);", " \t\tint\t\t\tlen;", " \t\tif (rawlen < 0)", " \t\t\tereport(ERROR,", " \t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),", " \t\t\t\t\t errmsg(\"null value not allowed for hstore key\")));", " \t\tpairs[i].key = pq_getmsgtext(buf, rawlen, &len);", " \t\tpairs[i].keylen = hstoreCheckKeyLen(len);", " \t\tpairs[i].needfree = true;", " \t\trawlen = pq_getmsgint(buf, 4);", " \t\tif (rawlen < 0)", " \t\t{", " \t\t\tpairs[i].val = NULL;", " \t\t\tpairs[i].vallen = 0;", " \t\t\tpairs[i].isnull = true;", " \t\t}", " \t\telse", " \t\t{", " \t\t\tpairs[i].val = pq_getmsgtext(buf, rawlen, &len);", " \t\t\tpairs[i].vallen = hstoreCheckValLen(len);", " \t\t\tpairs[i].isnull = false;", " \t\t}", " \t}", " \tpcount = hstoreUniquePairs(pairs, pcount, &buflen);", " \tout = hstorePairs(pairs, pcount, buflen);", " \tPG_RETURN_POINTER(out);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int http_proxy_open(URLContext *h, const char *uri, int flags)", " {", "     HTTPContext *s = h->priv_data;", "     char hostname[1024], hoststr[1024];", "     char auth[1024], pathbuf[1024], *path;", "     char lower_url[100];", "     int port, ret = 0, attempts = 0;", "     HTTPAuthType cur_auth_type;", "     char *authstr;", "     int new_loc;", "     if( s->seekable == 1 )", "         h->is_streamed = 0;", "     else", "         h->is_streamed = 1;", "     av_url_split(NULL, 0, auth, sizeof(auth), hostname, sizeof(hostname), &port,", "                  pathbuf, sizeof(pathbuf), uri);", "     ff_url_join(hoststr, sizeof(hoststr), NULL, NULL, hostname, port, NULL);", "     path = pathbuf;", "     if (*path == '/')", "         path++;", "     ff_url_join(lower_url, sizeof(lower_url), \"tcp\", NULL, hostname, port,", "                 NULL);", " redo:", "     ret = ffurl_open_whitelist(&s->hd, lower_url, AVIO_FLAG_READ_WRITE,", "                                &h->interrupt_callback, NULL,", "                                h->protocol_whitelist, h->protocol_blacklist, h);", "     if (ret < 0)", "         return ret;", "     authstr = ff_http_auth_create_response(&s->proxy_auth_state, auth,", "                                            path, \"CONNECT\");", "     snprintf(s->buffer, sizeof(s->buffer),", "              \"CONNECT %s HTTP/1.1\\r\\n\"", "              \"Host: %s\\r\\n\"", "              \"Connection: close\\r\\n\"", "              \"%s%s\"", "              \"\\r\\n\",", "              path,", "              hoststr,", "              authstr ? \"Proxy-\" : \"\", authstr ? authstr : \"\");", "     av_freep(&authstr);", "     if ((ret = ffurl_write(s->hd, s->buffer, strlen(s->buffer))) < 0)", "         goto fail;", "      s->buf_ptr    = s->buffer;", "      s->buf_end    = s->buffer;", "      s->line_count = 0;", "    s->filesize   = -1;", "     s->filesize   = UINT64_MAX;", "      cur_auth_type = s->proxy_auth_state.auth_type;", "     ret = http_read_header(h, &new_loc);", "     if (ret < 0)", "         goto fail;", "     attempts++;", "     if (s->http_code == 407 &&", "         (cur_auth_type == HTTP_AUTH_NONE || s->proxy_auth_state.stale) &&", "         s->proxy_auth_state.auth_type != HTTP_AUTH_NONE && attempts < 2) {", "         ffurl_closep(&s->hd);", "         goto redo;", "     }", "     if (s->http_code < 400)", "         return 0;", "     ret = ff_http_averror(s->http_code, AVERROR(EIO));", " fail:", "     http_proxy_close(h);", "     return ret;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static void mpeg4_encode_gop_header(MpegEncContext *s)", "  {", "    int hours, minutes, seconds;", "     int64_t hours, minutes, seconds;", "      int64_t time;", "      put_bits(&s->pb, 16, 0);", "     put_bits(&s->pb, 16, GOP_STARTCODE);", "     time = s->current_picture_ptr->f->pts;", "     if (s->reordered_input_picture[1])", "         time = FFMIN(time, s->reordered_input_picture[1]->f->pts);", "     time = time * s->avctx->time_base.num;", "     s->last_time_base = FFUDIV(time, s->avctx->time_base.den);", "     seconds = FFUDIV(time, s->avctx->time_base.den);", "     minutes = FFUDIV(seconds, 60); seconds = FFUMOD(seconds, 60);", "     hours   = FFUDIV(minutes, 60); minutes = FFUMOD(minutes, 60);", "     hours   = FFUMOD(hours  , 24);", "     put_bits(&s->pb, 5, hours);", "     put_bits(&s->pb, 6, minutes);", "     put_bits(&s->pb, 1, 1);", "     put_bits(&s->pb, 6, seconds);", "     put_bits(&s->pb, 1, !!(s->avctx->flags & AV_CODEC_FLAG_CLOSED_GOP));", "     put_bits(&s->pb, 1, 0);   ", "     ff_mpeg4_stuffing(&s->pb);", " }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" psf_binheader_writef (SF_PRIVATE *psf, const char *format, ...)", " {\tva_list\targptr ;", " \tsf_count_t \t\tcountdata ;", " \tunsigned long \tlongdata ;", " \tunsigned int \tdata ;", " \tfloat\t\t\tfloatdata ;", " \tdouble\t\t\tdoubledata ;", " \tvoid\t\t\t*bindata ;", " \tsize_t\t\t\tsize ;", " \tchar\t\t\tc, *strptr ;", " \tint\t\t\t\tcount = 0, trunc_8to4 ;", " \ttrunc_8to4 = SF_FALSE ;", "  \tva_start (argptr, format) ;", "  \twhile ((c = *format++))", "\t{\tswitch (c)", " \t{", " \t\tif (psf->header.indx + 16 >= psf->header.len && psf_bump_header_allocation (psf, 16))", " \t\t\treturn count ;", " \t\tswitch (c)", "  \t\t{\tcase ' ' :  ", "  \t\t\t\t\tbreak ;", " \t\t\tcase 'e' :  ", " \t\t\t\t\tpsf->rwf_endian = SF_ENDIAN_LITTLE ;", " \t\t\t\t\tbreak ;", " \t\t\tcase 'E' :  ", " \t\t\t\t\tpsf->rwf_endian = SF_ENDIAN_BIG ;", " \t\t\t\t\tbreak ;", " \t\t\tcase 't' :  ", " \t\t\t\t\ttrunc_8to4 = SF_TRUE ;", " \t\t\t\t\tbreak ;", " \t\t\tcase 'T' :  ", " \t\t\t\t\ttrunc_8to4 = SF_FALSE ;", " \t\t\t\t\tbreak ;", " \t\t\tcase 'm' :", " \t\t\t\t\tdata = va_arg (argptr, unsigned int) ;", " \t\t\t\t\theader_put_marker (psf, data) ;", " \t\t\t\t\tcount += 4 ;", " \t\t\t\t\tbreak ;", " \t\t\tcase '1' :", " \t\t\t\t\tdata = va_arg (argptr, unsigned int) ;", " \t\t\t\t\theader_put_byte (psf, data) ;", " \t\t\t\t\tcount += 1 ;", " \t\t\t\t\tbreak ;", " \t\t\tcase '2' :", " \t\t\t\t\tdata = va_arg (argptr, unsigned int) ;", " \t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)", " \t\t\t\t\t{\theader_put_be_short (psf, data) ;", " \t\t\t\t\t\t}", " \t\t\t\t\telse", " \t\t\t\t\t{\theader_put_le_short (psf, data) ;", " \t\t\t\t\t\t} ;", " \t\t\t\t\tcount += 2 ;", " \t\t\t\t\tbreak ;", " \t\t\tcase '3' :  ", " \t\t\t\t\tdata = va_arg (argptr, unsigned int) ;", " \t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)", " \t\t\t\t\t{\theader_put_be_3byte (psf, data) ;", " \t\t\t\t\t\t}", " \t\t\t\t\telse", " \t\t\t\t\t{\theader_put_le_3byte (psf, data) ;", " \t\t\t\t\t\t} ;", " \t\t\t\t\tcount += 3 ;", " \t\t\t\t\tbreak ;", " \t\t\tcase '4' :", " \t\t\t\t\tdata = va_arg (argptr, unsigned int) ;", " \t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)", " \t\t\t\t\t{\theader_put_be_int (psf, data) ;", " \t\t\t\t\t\t}", " \t\t\t\t\telse", " \t\t\t\t\t{\theader_put_le_int (psf, data) ;", " \t\t\t\t\t\t} ;", " \t\t\t\t\tcount += 4 ;", " \t\t\t\t\tbreak ;", " \t\t\tcase '8' :", " \t\t\t\t\tcountdata = va_arg (argptr, sf_count_t) ;", " \t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG && trunc_8to4 == SF_FALSE)", " \t\t\t\t\t{\theader_put_be_8byte (psf, countdata) ;", " \t\t\t\t\t\tcount += 8 ;", " \t\t\t\t\t\t}", " \t\t\t\t\telse if (psf->rwf_endian == SF_ENDIAN_LITTLE && trunc_8to4 == SF_FALSE)", " \t\t\t\t\t{\theader_put_le_8byte (psf, countdata) ;", " \t\t\t\t\t\tcount += 8 ;", " \t\t\t\t\t\t}", " \t\t\t\t\telse if (psf->rwf_endian == SF_ENDIAN_BIG && trunc_8to4 == SF_TRUE)", " \t\t\t\t\t{\tlongdata = countdata & 0xFFFFFFFF ;", " \t\t\t\t\t\theader_put_be_int (psf, longdata) ;", " \t\t\t\t\t\tcount += 4 ;", " \t\t\t\t\t\t}", " \t\t\t\t\telse if (psf->rwf_endian == SF_ENDIAN_LITTLE && trunc_8to4 == SF_TRUE)", " \t\t\t\t\t{\tlongdata = countdata & 0xFFFFFFFF ;", " \t\t\t\t\t\theader_put_le_int (psf, longdata) ;", " \t\t\t\t\t\tcount += 4 ;", " \t\t\t\t\t\t}", " \t\t\t\t\tbreak ;", " \t\t\tcase 'f' :", "  \t\t\t\t\tfloatdata = (float) va_arg (argptr, double) ;", "  \t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)", "\t\t\t\t\t\tfloat32_be_write (floatdata, psf->header + psf->headindex) ;", " \t\t\t\t\t\tfloat32_be_write (floatdata, psf->header.ptr + psf->header.indx) ;", "  \t\t\t\t\telse", "\t\t\t\t\t\tfloat32_le_write (floatdata, psf->header + psf->headindex) ;", "\t\t\t\t\tpsf->headindex += 4 ;", " \t\t\t\t\t\tfloat32_le_write (floatdata, psf->header.ptr + psf->header.indx) ;", " \t\t\t\t\tpsf->header.indx += 4 ;", "  \t\t\t\t\tcount += 4 ;", "  \t\t\t\t\tbreak ;", "  \t\t\tcase 'd' :", "  \t\t\t\t\tdoubledata = va_arg (argptr, double) ;", "  \t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)", "\t\t\t\t\t\tdouble64_be_write (doubledata, psf->header + psf->headindex) ;", " \t\t\t\t\t\tdouble64_be_write (doubledata, psf->header.ptr + psf->header.indx) ;", "  \t\t\t\t\telse", "\t\t\t\t\t\tdouble64_le_write (doubledata, psf->header + psf->headindex) ;", "\t\t\t\t\tpsf->headindex += 8 ;", " \t\t\t\t\t\tdouble64_le_write (doubledata, psf->header.ptr + psf->header.indx) ;", " \t\t\t\t\tpsf->header.indx += 8 ;", "  \t\t\t\t\tcount += 8 ;", "  \t\t\t\t\tbreak ;", " \t\t\tcase 's' :", "  \t\t\t\t\tstrptr = va_arg (argptr, char *) ;", "  \t\t\t\t\tsize = strlen (strptr) + 1 ;", "  \t\t\t\t\tsize += (size & 1) ;", " \t\t\t\t\tif (psf->header.indx + (sf_count_t) size >= psf->header.len && psf_bump_header_allocation (psf, 16))", " \t\t\t\t\t\treturn count ;", "  \t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)", "  \t\t\t\t\t\theader_put_be_int (psf, size) ;", "  \t\t\t\t\telse", "  \t\t\t\t\t\theader_put_le_int (psf, size) ;", "\t\t\t\t\tmemcpy (&(psf->header [psf->headindex]), strptr, size) ;", "\t\t\t\t\tpsf->headindex += size ;", "\t\t\t\t\tpsf->header [psf->headindex - 1] = 0 ;", " \t\t\t\t\tmemcpy (&(psf->header.ptr [psf->header.indx]), strptr, size) ;", " \t\t\t\t\tpsf->header.indx += size ;", " \t\t\t\t\tpsf->header.ptr [psf->header.indx - 1] = 0 ;", "  \t\t\t\t\tcount += 4 + size ;", "  \t\t\t\t\tbreak ;", " \t\t\tcase 'S' :", "  \t\t\t\t\tstrptr = va_arg (argptr, char *) ;", "  \t\t\t\t\tsize = strlen (strptr) ;", " \t\t\t\t\tif (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))", " \t\t\t\t\t\treturn count ;", "  \t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)", "  \t\t\t\t\t\theader_put_be_int (psf, size) ;", "  \t\t\t\t\telse", "  \t\t\t\t\t\theader_put_le_int (psf, size) ;", "\t\t\t\t\tmemcpy (&(psf->header [psf->headindex]), strptr, size + 1) ;", " \t\t\t\t\tmemcpy (&(psf->header.ptr [psf->header.indx]), strptr, size + 1) ;", "  \t\t\t\t\tsize += (size & 1) ;", "\t\t\t\t\tpsf->headindex += size ;", "\t\t\t\t\tpsf->header [psf->headindex] = 0 ;", " \t\t\t\t\tpsf->header.indx += size ;", " \t\t\t\t\tpsf->header.ptr [psf->header.indx] = 0 ;", "  \t\t\t\t\tcount += 4 + size ;", "  \t\t\t\t\tbreak ;", " \t\t\tcase 'p' :", " \t\t\t\t\tstrptr = va_arg (argptr, char *) ;", "  \t\t\t\t\tsize = strlen (strptr) ;", "  \t\t\t\t\tsize = (size & 1) ? size : size + 1 ;", "  \t\t\t\t\tsize = (size > 254) ? 254 : size ;", " \t\t\t\t\tif (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))", " \t\t\t\t\t\treturn count ;", "  \t\t\t\t\theader_put_byte (psf, size) ;", "\t\t\t\t\tmemcpy (&(psf->header [psf->headindex]), strptr, size) ;", "\t\t\t\t\tpsf->headindex += size ;", " \t\t\t\t\tmemcpy (&(psf->header.ptr [psf->header.indx]), strptr, size) ;", " \t\t\t\t\tpsf->header.indx += size ;", "  \t\t\t\t\tcount += 1 + size ;", "  \t\t\t\t\tbreak ;", "  \t\t\tcase 'b' :", "  \t\t\t\t\tbindata\t= va_arg (argptr, void *) ;", "  \t\t\t\t\tsize\t= va_arg (argptr, size_t) ;", "\t\t\t\t\tif (psf->headindex + size < sizeof (psf->header))", "\t\t\t\t\t{\tmemcpy (&(psf->header [psf->headindex]), bindata, size) ;", "\t\t\t\t\t\tpsf->headindex += size ;", "\t\t\t\t\t\tcount += size ;", "\t\t\t\t\t\t} ;", " \t\t\t\t\tif (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))", " \t\t\t\t\t\treturn count ;", " \t\t\t\t\tmemcpy (&(psf->header.ptr [psf->header.indx]), bindata, size) ;", " \t\t\t\t\tpsf->header.indx += size ;", " \t\t\t\t\tcount += size ;", "  \t\t\t\t\tbreak ;", "  \t\t\tcase 'z' :", "  \t\t\t\t\tsize = va_arg (argptr, size_t) ;", " \t\t\t\t\tif (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))", " \t\t\t\t\t\treturn count ;", "  \t\t\t\t\tcount += size ;", "  \t\t\t\t\twhile (size)", "\t\t\t\t\t{\tpsf->header [psf->headindex] = 0 ;", "\t\t\t\t\t\tpsf->headindex ++ ;", " \t\t\t\t\t{\tpsf->header.ptr [psf->header.indx] = 0 ;", " \t\t\t\t\t\tpsf->header.indx ++ ;", "  \t\t\t\t\t\tsize -- ;", "  \t\t\t\t\t\t} ;", "  \t\t\t\t\tbreak ;", "  \t\t\tcase 'h' :", "  \t\t\t\t\tbindata = va_arg (argptr, void *) ;", "\t\t\t\t\tmemcpy (&(psf->header [psf->headindex]), bindata, 16) ;", "\t\t\t\t\tpsf->headindex += 16 ;", " \t\t\t\t\tmemcpy (&(psf->header.ptr [psf->header.indx]), bindata, 16) ;", " \t\t\t\t\tpsf->header.indx += 16 ;", "  \t\t\t\t\tcount += 16 ;", "  \t\t\t\t\tbreak ;", "  \t\t\tcase 'j' :\t ", "  \t\t\t\t\tsize = va_arg (argptr, size_t) ;", "\t\t\t\t\tpsf->headindex += size ;", " \t\t\t\t\tif (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))", " \t\t\t\t\t\treturn count ;", " \t\t\t\t\tpsf->header.indx += size ;", "  \t\t\t\t\tcount += size ;", "  \t\t\t\t\tbreak ;", "  \t\t\tcase 'o' :\t ", "  \t\t\t\t\tsize = va_arg (argptr, size_t) ;", "\t\t\t\t\tif (size < sizeof (psf->header))", "\t\t\t\t\t{\tpsf->headindex = size ;", "\t\t\t\t\t\tcount = 0 ;", "\t\t\t\t\t\t} ;", " \t\t\t\t\tif ((sf_count_t) size >= psf->header.len && psf_bump_header_allocation (psf, size))", " \t\t\t\t\t\treturn count ;", " \t\t\t\t\tpsf->header.indx = size ;", "  \t\t\t\t\tbreak ;", "  \t\t\tdefault :", " \t\t\t\tpsf_log_printf (psf, \"*** Invalid format specifier `%c'\\n\", c) ;", " \t\t\t\tpsf->error = SFE_INTERNAL ;", " \t\t\t\tbreak ;", " \t\t\t} ;", " \t\t} ;", " \tva_end (argptr) ;", " \treturn count ;", " }  "], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int cine_read_header(AVFormatContext *avctx)", " {", "     AVIOContext *pb = avctx->pb;", "     AVStream *st;", "     unsigned int version, compression, offImageHeader, offSetup, offImageOffsets, biBitCount, length, CFA;", "     int vflip;", "     char *description;", "     uint64_t i;", "     st = avformat_new_stream(avctx, NULL);", "     if (!st)", "         return AVERROR(ENOMEM);", "     st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;", "     st->codecpar->codec_id   = AV_CODEC_ID_RAWVIDEO;", "     st->codecpar->codec_tag  = 0;", "     avio_skip(pb, 4);  ", "     compression = avio_rl16(pb);", "     version     = avio_rl16(pb);", "     if (version != 1) {", "         avpriv_request_sample(avctx, \"unknown version %i\", version);", "         return AVERROR_INVALIDDATA;", "     }", "     avio_skip(pb, 12);  ", "     st->duration    = avio_rl32(pb);", "     offImageHeader  = avio_rl32(pb);", "     offSetup        = avio_rl32(pb);", "     offImageOffsets = avio_rl32(pb);", "     avio_skip(pb, 8);  ", "     avio_seek(pb, offImageHeader, SEEK_SET);", "     avio_skip(pb, 4);  ", "     st->codecpar->width      = avio_rl32(pb);", "     st->codecpar->height     = avio_rl32(pb);", "     if (avio_rl16(pb) != 1)  ", "         return AVERROR_INVALIDDATA;", "     biBitCount = avio_rl16(pb);", "     if (biBitCount != 8 && biBitCount != 16 && biBitCount != 24 && biBitCount != 48) {", "         avpriv_request_sample(avctx, \"unsupported biBitCount %i\", biBitCount);", "         return AVERROR_INVALIDDATA;", "     }", "     switch (avio_rl32(pb)) {", "     case BMP_RGB:", "         vflip = 0;", "         break;", "     case 0x100:  ", "         st->codecpar->codec_tag = MKTAG('B', 'I', 'T', 0);", "         vflip = 1;", "         break;", "     default:", "         avpriv_request_sample(avctx, \"unknown bitmap compression\");", "         return AVERROR_INVALIDDATA;", "     }", "     avio_skip(pb, 4);  ", "     avio_seek(pb, offSetup, SEEK_SET);", "     avio_skip(pb, 140);  ", "     if (avio_rl16(pb) != 0x5453)", "         return AVERROR_INVALIDDATA;", "     length = avio_rl16(pb);", "     if (length < 0x163C) {", "         avpriv_request_sample(avctx, \"short SETUP header\");", "         return AVERROR_INVALIDDATA;", "     }", "     avio_skip(pb, 616);  ", "     if (!avio_rl32(pb) ^ vflip) {", "         st->codecpar->extradata  = av_strdup(\"BottomUp\");", "         st->codecpar->extradata_size  = 9;", "     }", "     avio_skip(pb, 4);  ", "     avpriv_set_pts_info(st, 64, 1, avio_rl32(pb));", "     avio_skip(pb, 20);  ", "     set_metadata_int(&st->metadata, \"camera_version\", avio_rl32(pb), 0);", "     set_metadata_int(&st->metadata, \"firmware_version\", avio_rl32(pb), 0);", "     set_metadata_int(&st->metadata, \"software_version\", avio_rl32(pb), 0);", "     set_metadata_int(&st->metadata, \"recording_timezone\", avio_rl32(pb), 0);", "     CFA = avio_rl32(pb);", "     set_metadata_int(&st->metadata, \"brightness\", avio_rl32(pb), 1);", "     set_metadata_int(&st->metadata, \"contrast\", avio_rl32(pb), 1);", "     set_metadata_int(&st->metadata, \"gamma\", avio_rl32(pb), 1);", "     avio_skip(pb, 12 + 16);  ", "     set_metadata_float(&st->metadata, \"wbgain[0].r\", av_int2float(avio_rl32(pb)), 1);", "     set_metadata_float(&st->metadata, \"wbgain[0].b\", av_int2float(avio_rl32(pb)), 1);", "     avio_skip(pb, 36);  ", "     st->codecpar->bits_per_coded_sample = avio_rl32(pb);", "     if (compression == CC_RGB) {", "         if (biBitCount == 8) {", "             st->codecpar->format = AV_PIX_FMT_GRAY8;", "         } else if (biBitCount == 16) {", "             st->codecpar->format = AV_PIX_FMT_GRAY16LE;", "         } else if (biBitCount == 24) {", "             st->codecpar->format = AV_PIX_FMT_BGR24;", "         } else if (biBitCount == 48) {", "             st->codecpar->format = AV_PIX_FMT_BGR48LE;", "         } else {", "             avpriv_request_sample(avctx, \"unsupported biBitCount %i\", biBitCount);", "             return AVERROR_INVALIDDATA;", "         }", "     } else if (compression == CC_UNINT) {", "         switch (CFA & 0xFFFFFF) {", "         case CFA_BAYER:", "             if (biBitCount == 8) {", "                 st->codecpar->format = AV_PIX_FMT_BAYER_GBRG8;", "             } else if (biBitCount == 16) {", "                 st->codecpar->format = AV_PIX_FMT_BAYER_GBRG16LE;", "             } else {", "                 avpriv_request_sample(avctx, \"unsupported biBitCount %i\", biBitCount);", "                 return AVERROR_INVALIDDATA;", "             }", "             break;", "         case CFA_BAYERFLIP:", "             if (biBitCount == 8) {", "                 st->codecpar->format = AV_PIX_FMT_BAYER_RGGB8;", "             } else if (biBitCount == 16) {", "                 st->codecpar->format = AV_PIX_FMT_BAYER_RGGB16LE;", "             } else {", "                 avpriv_request_sample(avctx, \"unsupported biBitCount %i\", biBitCount);", "                 return AVERROR_INVALIDDATA;", "             }", "             break;", "         default:", "            avpriv_request_sample(avctx, \"unsupported Color Field Array (CFA) %i\", CFA & 0xFFFFFF);", "             return AVERROR_INVALIDDATA;", "         }", "     } else {  ", "         avpriv_request_sample(avctx, \"unsupported compression %i\", compression);", "         return AVERROR_INVALIDDATA;", "     }", "     avio_skip(pb, 668);  ", "     set_metadata_int(&st->metadata, \"shutter_ns\", avio_rl32(pb), 0);", "     avio_skip(pb, 24);  ", " #define DESCRIPTION_SIZE 4096", "     description = av_malloc(DESCRIPTION_SIZE + 1);", "     if (!description)", "         return AVERROR(ENOMEM);", "     i = avio_get_str(pb, DESCRIPTION_SIZE, description, DESCRIPTION_SIZE + 1);", "     if (i < DESCRIPTION_SIZE)", "         avio_skip(pb, DESCRIPTION_SIZE - i);", "     if (description[0])", "         av_dict_set(&st->metadata, \"description\", description, AV_DICT_DONT_STRDUP_VAL);", "     else", "         av_free(description);", "     avio_skip(pb, 1176);  ", "     set_metadata_int(&st->metadata, \"enable_crop\", avio_rl32(pb), 1);", "     set_metadata_int(&st->metadata, \"crop_left\", avio_rl32(pb), 1);", "     set_metadata_int(&st->metadata, \"crop_top\", avio_rl32(pb), 1);", "     set_metadata_int(&st->metadata, \"crop_right\", avio_rl32(pb), 1);", "     set_metadata_int(&st->metadata, \"crop_bottom\", avio_rl32(pb), 1);", "      avio_seek(pb, offImageOffsets, SEEK_SET);", "    for (i = 0; i < st->duration; i++)", "     for (i = 0; i < st->duration; i++) {", "         if (avio_feof(pb))", "             return AVERROR_INVALIDDATA;", "          av_add_index_entry(st, avio_rl64(pb), i, 0, 0, AVINDEX_KEYFRAME);", "     }", "      return 0;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0]}
{"tokens": [" static int insert_pin(", " \tsc_pkcs15_card_t *p15card,", " \tconst char       *path,", " \tunsigned char     id,", " \tunsigned char     auth_id,", " \tunsigned char     pin_reference,", " \tint               min_length,", " \tconst char       *label,", " \tint               pin_flags", " ){", " \tsc_card_t *card=p15card->card;", " \tsc_context_t *ctx=p15card->card->ctx;", " \tsc_file_t *f;", " \tstruct sc_pkcs15_auth_info pin_info;", " \tstruct sc_pkcs15_object pin_obj;", " \tint r;", " \tmemset(&pin_info, 0, sizeof(pin_info));", " \tpin_info.auth_id.len      = 1;", " \tpin_info.auth_id.value[0] = id;", " \tpin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;", " \tpin_info.attrs.pin.reference        = pin_reference;", " \tpin_info.attrs.pin.flags            = pin_flags;", " \tpin_info.attrs.pin.type             = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;", " \tpin_info.attrs.pin.min_length       = min_length;", " \tpin_info.attrs.pin.stored_length    = 16;", " \tpin_info.attrs.pin.max_length       = 16;", " \tpin_info.attrs.pin.pad_char         = '\\0';", " \tpin_info.logged_in = SC_PIN_STATE_UNKNOWN;", " \tsc_format_path(path, &pin_info.path);", " \tmemset(&pin_obj, 0, sizeof(pin_obj));", " \tstrlcpy(pin_obj.label, label, sizeof(pin_obj.label));", " \tpin_obj.flags            = SC_PKCS15_CO_FLAG_MODIFIABLE | SC_PKCS15_CO_FLAG_PRIVATE;", " \tpin_obj.auth_id.len      = auth_id ? 0 : 1;", " \tpin_obj.auth_id.value[0] = auth_id;", " \tif(card->type==SC_CARD_TYPE_TCOS_V3){", " \t\tunsigned char buf[256];", " \t\tint i, rec_no=0;", " \t\tif(pin_info.path.len>=2) pin_info.path.len-=2;", " \t\tsc_append_file_id(&pin_info.path, 0x5049);", " \t\tif(sc_select_file(card, &pin_info.path, NULL)!=SC_SUCCESS){", " \t\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL,", " \t\t\t\t\"Select(%s) failed\\n\",", " \t\t\t\tsc_print_path(&pin_info.path));", " \t\t\treturn 1;", " \t\t}", " \t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL,", " \t\t\t\"Searching for PIN-Ref %02X\\n\", pin_reference);", " \t\twhile((r=sc_read_record(card, ++rec_no, buf, sizeof(buf), SC_RECORD_BY_REC_NR))>0){", " \t\t\tint found=0, fbz=-1;", " \t\t\tif(buf[0]!=0xA0) continue;", " \t\t\tfor(i=2;i<buf[1]+2;i+=2+buf[i+1]){", " \t\t\t\tif(buf[i]==0x83 && buf[i+1]==1 && buf[i+2]==pin_reference) ++found;", " \t\t\t\tif(buf[i]==0x90) fbz=buf[i+1+buf[i+1]];", " \t\t\t}", " \t\t\tif(found) pin_info.tries_left=fbz;", " \t\t\tif(found) break;", " \t\t}", " \t\tif(r<=0){", " \t\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL,\"No EF_PWDD-Record found\\n\");", "  \t\t\treturn 1;", "  \t\t}", "  \t} else {", "\t\tif(sc_select_file(card, &pin_info.path, &f)!=SC_SUCCESS){", " \t\tif(sc_select_file(card, &pin_info.path, &f)!=SC_SUCCESS", " \t\t\t   \t|| !f->prop_attr || f->prop_attr_len < 4){", "  \t\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL,\"Select(%s) failed\\n\", path);", "  \t\t\treturn 1;", "  \t\t}", " \t\tpin_info.tries_left=f->prop_attr[3];", " \t\tsc_file_free(f);", " \t}", " \tr=sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);", " \tif(r!=SC_SUCCESS){", " \t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"sc_pkcs15emu_add_pin_obj(%s) failed\\n\", path);", " \t\treturn 4;", " \t}", " \tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"%s: OK, FBZ=%d\\n\", path, pin_info.tries_left);", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" ProcEstablishConnection(ClientPtr client)", " {", "     const char *reason;", "     char *auth_proto, *auth_string;", "     xConnClientPrefix *prefix;", "     REQUEST(xReq);", "      prefix = (xConnClientPrefix *) ((char *) stuff + sz_xReq);", "      auth_proto = (char *) prefix + sz_xConnClientPrefix;", "      auth_string = auth_proto + pad_to_int32(prefix->nbytesAuthProto);", "    if ((prefix->majorVersion != X_PROTOCOL) ||", "     if ((client->req_len << 2) != sz_xReq + sz_xConnClientPrefix +", " \tpad_to_int32(prefix->nbytesAuthProto) +", " \tpad_to_int32(prefix->nbytesAuthString))", "         reason = \"Bad length\";", "     else if ((prefix->majorVersion != X_PROTOCOL) ||", "          (prefix->minorVersion != X_PROTOCOL_REVISION))", "          reason = \"Protocol version mismatch\";", "      else", "     return (SendConnSetup(client, reason));", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" on_handler_appeared(GDBusConnection *connection,", " \t\t    const gchar     *name,", " \t\t    const gchar     *name_owner,", " \t\t    gpointer         user_data)", " {", " \tstruct tcmur_handler *handler = user_data;", " \tstruct dbus_info *info = handler->opaque;", "  \tif (info->register_invocation) {", "  \t\tinfo->connection = connection;", "\t\ttcmur_register_handler(handler);", " \t\ttcmur_register_dbus_handler(handler);", "  \t\tdbus_export_handler(handler, G_CALLBACK(on_dbus_check_config));", "  \t\tg_dbus_method_invocation_return_value(info->register_invocation,", "  \t\t\t    g_variant_new(\"(bs)\", TRUE, \"succeeded\"));", " \t\tinfo->register_invocation = NULL;", " \t}", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" decrypt_response(struct sc_card *card, unsigned char *in, unsigned char *out, size_t * out_len)", " decrypt_response(struct sc_card *card, unsigned char *in, size_t inlen, unsigned char *out, size_t * out_len)", "  {", "\tsize_t in_len;", " \tsize_t cipher_len;", "  \tsize_t i;", "  \tunsigned char iv[16] = { 0 };", "  \tunsigned char plaintext[4096] = { 0 };", " \tepass2003_exdata *exdata = NULL;", " \tif (!card->drv_data) ", " \t\treturn SC_ERROR_INVALID_ARGUMENTS;", " \texdata = (epass2003_exdata *)card->drv_data;", " \tif (in[0] == 0x99)", " \t\treturn 0;", "  \tif (0x01 == in[2] && 0x82 != in[1]) {", "\t\tin_len = in[1];", " \t\tcipher_len = in[1];", "  \t\ti = 3;", "  \t}", "  \telse if (0x01 == in[3] && 0x81 == in[1]) {", "\t\tin_len = in[2];", " \t\tcipher_len = in[2];", "  \t\ti = 4;", "  \t}", "  \telse if (0x01 == in[4] && 0x82 == in[1]) {", "\t\tin_len = in[2] * 0x100;", "\t\tin_len += in[3];", " \t\tcipher_len = in[2] * 0x100;", " \t\tcipher_len += in[3];", "  \t\ti = 5;", "  \t}", "  \telse {", "  \t\treturn -1;", "  \t}", " \tif (cipher_len < 2 || i+cipher_len > inlen || cipher_len > sizeof plaintext)", " \t\treturn -1;", "  \tif (KEY_TYPE_AES == exdata->smtype)", "\t\taes128_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], in_len - 1, plaintext);", " \t\taes128_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], cipher_len - 1, plaintext);", "  \telse", "\t\tdes3_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], in_len - 1, plaintext);", " \t\tdes3_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], cipher_len - 1, plaintext);", "\twhile (0x80 != plaintext[in_len - 2] && (in_len - 2 > 0))", "\t\tin_len--;", " \twhile (0x80 != plaintext[cipher_len - 2] && (cipher_len - 2 > 0))", " \t\tcipher_len--;", "\tif (2 == in_len)", " \tif (2 == cipher_len)", "  \t\treturn -1;", "\tmemcpy(out, plaintext, in_len - 2);", "\t*out_len = in_len - 2;", " \tmemcpy(out, plaintext, cipher_len - 2);", " \t*out_len = cipher_len - 2;", "  \treturn 0;", "  }"], "ner_tags": [0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0]}
{"tokens": [" static int jpc_ppm_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)", " {", " \tjpc_ppm_t *ppm = &ms->parms.ppm;", "  \tcstate = 0;", "\tif (JAS_CAST(uint, jas_stream_write(out, (char *) ppm->data, ppm->len)) != ppm->len) {", " \tif (JAS_CAST(jas_uint, jas_stream_write(out, (char *) ppm->data, ppm->len)) != ppm->len) {", "  \t\treturn -1;", "  \t}", "  \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 0, 0, 0]}
{"tokens": [" id3_skip (SF_PRIVATE * psf)", " {\tunsigned char\tbuf [10] ;", " \tmemset (buf, 0, sizeof (buf)) ;", " \tpsf_binheader_readf (psf, \"pb\", 0, buf, 10) ;", " \tif (buf [0] == 'I' && buf [1] == 'D' && buf [2] == '3')", " \t{\tint\toffset = buf [6] & 0x7f ;", " \t\toffset = (offset << 7) | (buf [7] & 0x7f) ;", " \t\toffset = (offset << 7) | (buf [8] & 0x7f) ;", " \t\toffset = (offset << 7) | (buf [9] & 0x7f) ;", " \t\tpsf_log_printf (psf, \"ID3 length : %d\\n--------------------\\n\", offset) ;", " \t\tif (offset < 0)", " \t\t\treturn 0 ;", "  \t\tpsf->fileoffset += offset + 10 ;", "\t\tpsf_binheader_readf (psf, \"p\", psf->fileoffset) ;", "\t\treturn 1 ;", " \t\tif (psf->fileoffset < psf->filelength)", " \t\t{\tpsf_binheader_readf (psf, \"p\", psf->fileoffset) ;", " \t\t\treturn 1 ;", " \t\t\t} ;", "  \t\t} ;", "  \treturn 0 ;", " }  "], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": ["  static int cg_rmdir(const char *path)", "  {", "  \tstruct fuse_context *fc = fuse_get_context();", "\tchar *fpath = NULL, *cgdir = NULL, *controller;", " \tchar *fpath = NULL, *cgdir = NULL, *controller, *next = NULL;", "  \tconst char *cgroup;", "  \tint ret;", " \tif (!fc)", " \t\treturn -EIO;", " \tcontroller = pick_controller_from_path(fc, path);", " \tif (!controller)", " \t\treturn -EINVAL;", " \tcgroup = find_cgroup_in_path(path);", " \tif (!cgroup)", " \t\treturn -EINVAL;", " \tget_cgdir_and_path(cgroup, &cgdir, &fpath);", " \tif (!fpath) {", " \t\tret = -EINVAL;", "  \t\tgoto out;", "  \t}", "\tfprintf(stderr, \"rmdir: verifying access to %s:%s (req path %s)\\n\",", "\t\t\tcontroller, cgdir, path);", " \tif (!caller_is_in_ancestor(fc->pid, controller, cgroup, &next)) {", " \t\tif (!fpath || strcmp(next, fpath) == 0)", " \t\t\tret = -EBUSY;", " \t\telse", " \t\t\tret = -ENOENT;", " \t\tgoto out;", " \t}", "  \tif (!fc_may_access(fc, controller, cgdir, NULL, O_WRONLY)) {", "  \t\tret = -EACCES;", "  \t\tgoto out;", " \t}", " \tif (!caller_is_in_ancestor(fc->pid, controller, cgroup, NULL)) {", " \t\tret = -EACCES;", " \t\tgoto out;", " \t}", " \tif (!cgfs_remove(controller, cgroup)) {", " \t\tret = -EINVAL;", " \t\tgoto out;", " \t}", " \tret = 0;", "  out:", "  \tfree(cgdir);", " \tfree(next);", "  \treturn ret;", "  }"], "ner_tags": [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": [" static void ssdp_recv(int sd)", " {", "  \tssize_t len;", "  \tstruct sockaddr sa;", "  \tsocklen_t salen;", "\tchar buf[MAX_PKT_SIZE];", " \tchar buf[MAX_PKT_SIZE + 1];", "  \tmemset(buf, 0, sizeof(buf));", "\tlen = recvfrom(sd, buf, sizeof(buf), MSG_DONTWAIT, &sa, &salen);", " \tlen = recvfrom(sd, buf, sizeof(buf) - 1, MSG_DONTWAIT, &sa, &salen);", "  \tif (len > 0) {", "\t\tbuf[len] = 0;", "  \t\tif (sa.sa_family != AF_INET)", "  \t\t\treturn;", " \t\tif (strstr(buf, \"M-SEARCH *\")) {", " \t\t\tsize_t i;", " \t\t\tchar *ptr, *type;", " \t\t\tstruct ifsock *ifs;", " \t\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)&sa;", " \t\t\tifs = find_outbound(&sa);", " \t\t\tif (!ifs) {", " \t\t\t\tlogit(LOG_DEBUG, \"No matching socket for client %s\", inet_ntoa(sin->sin_addr));", " \t\t\t\treturn;", " \t\t\t}", " \t\t\tlogit(LOG_DEBUG, \"Matching socket for client %s\", inet_ntoa(sin->sin_addr));", " \t\t\ttype = strcasestr(buf, \"\\r\\nST:\");", " \t\t\tif (!type) {", " \t\t\t\tlogit(LOG_DEBUG, \"No Search Type (ST:) found in M-SEARCH *, assuming \" SSDP_ST_ALL);", " \t\t\t\ttype = SSDP_ST_ALL;", " \t\t\t\tsend_message(ifs, type, &sa);", " \t\t\t\treturn;", " \t\t\t}", " \t\t\ttype = strchr(type, ':');", " \t\t\tif (!type)", " \t\t\t\treturn;", " \t\t\ttype++;", " \t\t\twhile (isspace(*type))", " \t\t\t\ttype++;", " \t\t\tptr = strstr(type, \"\\r\\n\");", " \t\t\tif (!ptr)", " \t\t\t\treturn;", " \t\t\t*ptr = 0;", " \t\t\tfor (i = 0; supported_types[i]; i++) {", " \t\t\t\tif (!strcmp(supported_types[i], type)) {", " \t\t\t\t\tlogit(LOG_DEBUG, \"M-SEARCH * ST: %s from %s port %d\", type,", " \t\t\t\t\t      inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));", " \t\t\t\t\tsend_message(ifs, type, &sa);", " \t\t\t\t\treturn;", " \t\t\t\t}", " \t\t\t}", " \t\t\tlogit(LOG_DEBUG, \"M-SEARCH * for unsupported ST: %s from %s\", type,", " \t\t\t      inet_ntoa(sin->sin_addr));", " \t\t}", " \t}", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" av_cold void ff_idctdsp_init(IDCTDSPContext *c, AVCodecContext *avctx)", " {", "     const unsigned high_bit_depth = avctx->bits_per_raw_sample > 8;", "     if (avctx->lowres==1) {", "         c->idct_put  = ff_jref_idct4_put;", "         c->idct_add  = ff_jref_idct4_add;", "         c->idct      = ff_j_rev_dct4;", "         c->perm_type = FF_IDCT_PERM_NONE;", "     } else if (avctx->lowres==2) {", "         c->idct_put  = ff_jref_idct2_put;", "         c->idct_add  = ff_jref_idct2_add;", "         c->idct      = ff_j_rev_dct2;", "         c->perm_type = FF_IDCT_PERM_NONE;", "     } else if (avctx->lowres==3) {", "         c->idct_put  = ff_jref_idct1_put;", "         c->idct_add  = ff_jref_idct1_add;", "         c->idct      = ff_j_rev_dct1;", "         c->perm_type = FF_IDCT_PERM_NONE;", "     } else {", "          if (avctx->bits_per_raw_sample == 10 || avctx->bits_per_raw_sample == 9) {", "            if (avctx->codec_id == AV_CODEC_ID_MPEG4 && avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO)", "             if (c->mpeg4_studio_profile)", "                  c->idct_put              = ff_simple_idct_put_int32_10bit;", "              else {", "                  c->idct_put              = ff_simple_idct_put_int16_10bit;", "                 c->idct_add              = ff_simple_idct_add_int16_10bit;", "                 c->idct                  = ff_simple_idct_int16_10bit;", "             }", "             c->perm_type             = FF_IDCT_PERM_NONE;", "         } else if (avctx->bits_per_raw_sample == 12) {", "             c->idct_put              = ff_simple_idct_put_int16_12bit;", "             c->idct_add              = ff_simple_idct_add_int16_12bit;", "             c->idct                  = ff_simple_idct_int16_12bit;", "             c->perm_type             = FF_IDCT_PERM_NONE;", "         } else {", "             if (avctx->idct_algo == FF_IDCT_INT) {", "                 c->idct_put  = ff_jref_idct_put;", "                 c->idct_add  = ff_jref_idct_add;", "                 c->idct      = ff_j_rev_dct;", "                 c->perm_type = FF_IDCT_PERM_LIBMPEG2;", " #if CONFIG_FAANIDCT", "             } else if (avctx->idct_algo == FF_IDCT_FAAN) {", "                 c->idct_put  = ff_faanidct_put;", "                 c->idct_add  = ff_faanidct_add;", "                 c->idct      = ff_faanidct;", "                 c->perm_type = FF_IDCT_PERM_NONE;", " #endif  ", "             } else {  ", "                 c->idct_put  = ff_simple_idct_put_int16_8bit;", "                 c->idct_add  = ff_simple_idct_add_int16_8bit;", "                 c->idct      = ff_simple_idct_int16_8bit;", "                 c->perm_type = FF_IDCT_PERM_NONE;", "             }", "         }", "     }", "     c->put_pixels_clamped        = ff_put_pixels_clamped_c;", "     c->put_signed_pixels_clamped = put_signed_pixels_clamped_c;", "     c->add_pixels_clamped        = ff_add_pixels_clamped_c;", "     if (CONFIG_MPEG4_DECODER && avctx->idct_algo == FF_IDCT_XVID)", "         ff_xvid_idct_init(c, avctx);", "     if (ARCH_AARCH64)", "         ff_idctdsp_init_aarch64(c, avctx, high_bit_depth);", "     if (ARCH_ALPHA)", "         ff_idctdsp_init_alpha(c, avctx, high_bit_depth);", "     if (ARCH_ARM)", "         ff_idctdsp_init_arm(c, avctx, high_bit_depth);", "     if (ARCH_PPC)", "         ff_idctdsp_init_ppc(c, avctx, high_bit_depth);", "     if (ARCH_X86)", "         ff_idctdsp_init_x86(c, avctx, high_bit_depth);", "     if (ARCH_MIPS)", "         ff_idctdsp_init_mips(c, avctx, high_bit_depth);", "     ff_init_scantable_permutation(c->idct_permutation,", "                                   c->perm_type);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int nsv_parse_NSVf_header(AVFormatContext *s)", " {", "     NSVContext *nsv = s->priv_data;", "     AVIOContext *pb = s->pb;", "     unsigned int av_unused file_size;", "     unsigned int size;", "     int64_t duration;", "     int strings_size;", "     int table_entries;", "     int table_entries_used;", "     nsv->state = NSV_UNSYNC;  ", "     size = avio_rl32(pb);", "     if (size < 28)", "         return -1;", "     nsv->NSVf_end = size;", "     file_size = (uint32_t)avio_rl32(pb);", "     av_log(s, AV_LOG_TRACE, \"NSV NSVf chunk_size %u\\n\", size);", "     av_log(s, AV_LOG_TRACE, \"NSV NSVf file_size %u\\n\", file_size);", "     nsv->duration = duration = avio_rl32(pb);  ", "     av_log(s, AV_LOG_TRACE, \"NSV NSVf duration %\"PRId64\" ms\\n\", duration);", "     strings_size = avio_rl32(pb);", "     table_entries = avio_rl32(pb);", "     table_entries_used = avio_rl32(pb);", "     av_log(s, AV_LOG_TRACE, \"NSV NSVf info-strings size: %d, table entries: %d, bis %d\\n\",", "             strings_size, table_entries, table_entries_used);", "     if (avio_feof(pb))", "         return -1;", "     av_log(s, AV_LOG_TRACE, \"NSV got header; filepos %\"PRId64\"\\n\", avio_tell(pb));", "     if (strings_size > 0) {", "         char *strings;  ", "         char *p, *endp;", "         char *token, *value;", "         char quote;", "         p = strings = av_mallocz((size_t)strings_size + 1);", "         if (!p)", "             return AVERROR(ENOMEM);", "         endp = strings + strings_size;", "         avio_read(pb, strings, strings_size);", "         while (p < endp) {", "             while (*p == ' ')", "                 p++;  ", "             if (p >= endp-2)", "                 break;", "             token = p;", "             p = strchr(p, '=');", "             if (!p || p >= endp-2)", "                 break;", "             *p++ = '\\0';", "             quote = *p++;", "             value = p;", "             p = strchr(p, quote);", "             if (!p || p >= endp)", "                 break;", "             *p++ = '\\0';", "             av_log(s, AV_LOG_TRACE, \"NSV NSVf INFO: %s='%s'\\n\", token, value);", "             av_dict_set(&s->metadata, token, value, 0);", "         }", "         av_free(strings);", "     }", "     if (avio_feof(pb))", "         return -1;", "     av_log(s, AV_LOG_TRACE, \"NSV got infos; filepos %\"PRId64\"\\n\", avio_tell(pb));", "     if (table_entries_used > 0) {", "         int i;", "         nsv->index_entries = table_entries_used;", "         if((unsigned)table_entries_used >= UINT_MAX / sizeof(uint32_t))", "             return -1;", "         nsv->nsvs_file_offset = av_malloc_array((unsigned)table_entries_used, sizeof(uint32_t));", "          if (!nsv->nsvs_file_offset)", "              return AVERROR(ENOMEM);", "        for(i=0;i<table_entries_used;i++)", "         for(i=0;i<table_entries_used;i++) {", "             if (avio_feof(pb))", "                 return AVERROR_INVALIDDATA;", "              nsv->nsvs_file_offset[i] = avio_rl32(pb) + size;", "         }", "          if(table_entries > table_entries_used &&", "             avio_rl32(pb) == MKTAG('T','O','C','2')) {", "             nsv->nsvs_timestamps = av_malloc_array((unsigned)table_entries_used, sizeof(uint32_t));", "             if (!nsv->nsvs_timestamps)", "                 return AVERROR(ENOMEM);", "             for(i=0;i<table_entries_used;i++) {", "                 nsv->nsvs_timestamps[i] = avio_rl32(pb);", "             }", "         }", "     }", "     av_log(s, AV_LOG_TRACE, \"NSV got index; filepos %\"PRId64\"\\n\", avio_tell(pb));", "     avio_seek(pb, nsv->base_offset + size, SEEK_SET);  ", "     if (avio_feof(pb))", "         return -1;", "     nsv->state = NSV_HAS_READ_NSVF;", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int g2m_init_buffers(G2MContext *c)", " {", "      int aligned_height;", "      if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) {", "        c->framebuf_stride = FFALIGN(c->width * 3, 16);", "        aligned_height     = FFALIGN(c->height,    16);", "         c->framebuf_stride = FFALIGN(c->width + 15, 16) * 3;", "         aligned_height     = c->height + 15;", "          av_free(c->framebuf);", "          c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);", "          if (!c->framebuf)", "             return AVERROR(ENOMEM);", "     }", "     if (!c->synth_tile || !c->jpeg_tile ||", "         c->old_tile_w < c->tile_width ||", "         c->old_tile_h < c->tile_height) {", "         c->tile_stride = FFALIGN(c->tile_width, 16) * 3;", "         aligned_height = FFALIGN(c->tile_height,    16);", "         av_free(c->synth_tile);", "         av_free(c->jpeg_tile);", "         av_free(c->kempf_buf);", "         av_free(c->kempf_flags);", "         c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);", "         c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);", "         c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height", "                                     + FF_INPUT_BUFFER_PADDING_SIZE);", "         c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);", "         if (!c->synth_tile || !c->jpeg_tile ||", "             !c->kempf_buf || !c->kempf_flags)", "             return AVERROR(ENOMEM);", "     }", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" GF_Err urn_Read(GF_Box *s, GF_BitStream *bs)", " {", " \tu32 i, to_read;", " \tchar *tmpName;", " \tGF_DataEntryURNBox *ptr = (GF_DataEntryURNBox *)s;", " \tif (! ptr->size ) return GF_OK;", " \tto_read = (u32) ptr->size;", " \ttmpName = (char*)gf_malloc(sizeof(char) * to_read);", " \tif (!tmpName) return GF_OUT_OF_MEM;", " \tgf_bs_read_data(bs, tmpName, to_read);", "  \ti = 0;", "\twhile ( (tmpName[i] != 0) && (i < to_read) ) {", " \twhile ( (i < to_read) && (tmpName[i] != 0) ) {", "  \t\ti++;", "  \t}", " \tif (i == to_read) {", " \t\tgf_free(tmpName);", " \t\treturn GF_ISOM_INVALID_FILE;", " \t}", " \tif (i == to_read - 1) {", " \t\tptr->nameURN = tmpName;", " \t\tptr->location = NULL;", " \t\treturn GF_OK;", " \t}", " \tptr->nameURN = (char*)gf_malloc(sizeof(char) * (i+1));", " \tif (!ptr->nameURN) {", " \t\tgf_free(tmpName);", " \t\treturn GF_OUT_OF_MEM;", " \t}", " \tptr->location = (char*)gf_malloc(sizeof(char) * (to_read - i - 1));", " \tif (!ptr->location) {", " \t\tgf_free(tmpName);", " \t\tgf_free(ptr->nameURN);", " \t\tptr->nameURN = NULL;", " \t\treturn GF_OUT_OF_MEM;", " \t}", " \tmemcpy(ptr->nameURN, tmpName, i + 1);", " \tmemcpy(ptr->location, tmpName + i + 1, (to_read - i - 1));", " \tgf_free(tmpName);", " \treturn GF_OK;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" w3m_exit(int i)", " {", " #ifdef USE_MIGEMO", "     init_migemo();\t\t ", " #endif", "     stopDownload();", "     deleteFiles();", " #ifdef USE_SSL", "     free_ssl_ctx();", " #endif", "     disconnectFTP();", " #ifdef USE_NNTP", "     disconnectNews();", "  #endif", "  #ifdef __MINGW32_VERSION", "      WSACleanup();", " #endif", " #ifdef HAVE_MKDTEMP", "     if (no_rc_dir && tmp_dir != rc_dir)", " \tif (rmdir(tmp_dir) != 0) {", " \t    fprintf(stderr, \"Can't remove temporary directory (%s)!\\n\", tmp_dir);", " \t    exit(1);", " \t}", "  #endif", "      exit(i);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": [" jas_image_t *jp2_decode(jas_stream_t *in, char *optstr)", " {", " \tjp2_box_t *box;", " \tint found;", " \tjas_image_t *image;", " \tjp2_dec_t *dec;", " \tbool samedtype;", " \tint dtype;", " \tunsigned int i;", " \tjp2_cmap_t *cmapd;", " \tjp2_pclr_t *pclrd;", " \tjp2_cdef_t *cdefd;", " \tunsigned int channo;", " \tint newcmptno;", " \tint_fast32_t *lutents;", " #if 0", " \tjp2_cdefchan_t *cdefent;", " \tint cmptno;", " #endif", " \tjp2_cmapent_t *cmapent;", " \tjas_icchdr_t icchdr;", " \tjas_iccprof_t *iccprof;", " \tdec = 0;", " \tbox = 0;", " \timage = 0;", " \tif (!(dec = jp2_dec_create())) {", " \t\tgoto error;", " \t}", " \tif (!(box = jp2_box_get(in))) {", " \t\tjas_eprintf(\"error: cannot get box\\n\");", " \t\tgoto error;", " \t}", " \tif (box->type != JP2_BOX_JP) {", " \t\tjas_eprintf(\"error: expecting signature box\\n\");", " \t\tgoto error;", " \t}", " \tif (box->data.jp.magic != JP2_JP_MAGIC) {", " \t\tjas_eprintf(\"incorrect magic number\\n\");", " \t\tgoto error;", " \t}", " \tjp2_box_destroy(box);", " \tbox = 0;", " \tif (!(box = jp2_box_get(in))) {", " \t\tgoto error;", " \t}", " \tif (box->type != JP2_BOX_FTYP) {", " \t\tjas_eprintf(\"expecting file type box\\n\");", " \t\tgoto error;", " \t}", " \tjp2_box_destroy(box);", " \tbox = 0;", " \tfound = 0;", " \twhile ((box = jp2_box_get(in))) {", " \t\tif (jas_getdbglevel() >= 1) {", " \t\t\tjas_eprintf(\"got box type %s\\n\", box->info->name);", " \t\t}", " \t\tswitch (box->type) {", " \t\tcase JP2_BOX_JP2C:", " \t\t\tfound = 1;", " \t\t\tbreak;", " \t\tcase JP2_BOX_IHDR:", " \t\t\tif (!dec->ihdr) {", " \t\t\t\tdec->ihdr = box;", " \t\t\t\tbox = 0;", " \t\t\t}", " \t\t\tbreak;", " \t\tcase JP2_BOX_BPCC:", " \t\t\tif (!dec->bpcc) {", " \t\t\t\tdec->bpcc = box;", " \t\t\t\tbox = 0;", " \t\t\t}", " \t\t\tbreak;", " \t\tcase JP2_BOX_CDEF:", " \t\t\tif (!dec->cdef) {", " \t\t\t\tdec->cdef = box;", " \t\t\t\tbox = 0;", " \t\t\t}", " \t\t\tbreak;", " \t\tcase JP2_BOX_PCLR:", " \t\t\tif (!dec->pclr) {", " \t\t\t\tdec->pclr = box;", " \t\t\t\tbox = 0;", " \t\t\t}", " \t\t\tbreak;", " \t\tcase JP2_BOX_CMAP:", " \t\t\tif (!dec->cmap) {", " \t\t\t\tdec->cmap = box;", " \t\t\t\tbox = 0;", " \t\t\t}", " \t\t\tbreak;", " \t\tcase JP2_BOX_COLR:", " \t\t\tif (!dec->colr) {", " \t\t\t\tdec->colr = box;", " \t\t\t\tbox = 0;", " \t\t\t}", " \t\t\tbreak;", " \t\t}", " \t\tif (box) {", " \t\t\tjp2_box_destroy(box);", " \t\t\tbox = 0;", " \t\t}", " \t\tif (found) {", " \t\t\tbreak;", " \t\t}", " \t}", " \tif (!found) {", " \t\tjas_eprintf(\"error: no code stream found\\n\");", " \t\tgoto error;", " \t}", " \tif (!(dec->image = jpc_decode(in, optstr))) {", " \t\tjas_eprintf(\"error: cannot decode code stream\\n\");", " \t\tgoto error;", " \t}", " \tif (!dec->ihdr) {", " \t\tjas_eprintf(\"error: missing IHDR box\\n\");", " \t\tgoto error;", " \t}", "\tif (dec->ihdr->data.ihdr.numcmpts != JAS_CAST(uint,", " \tif (dec->ihdr->data.ihdr.numcmpts != JAS_CAST(jas_uint,", "  \t  jas_image_numcmpts(dec->image))) {", "  \t\tjas_eprintf(\"warning: number of components mismatch\\n\");", "  \t}", " \tif (!jas_image_numcmpts(dec->image)) {", " \t\tjas_eprintf(\"error: no components\\n\");", " \t\tgoto error;", " \t}", "  \tsamedtype = true;", "  \tdtype = jas_image_cmptdtype(dec->image, 0);", "\tfor (i = 1; i < JAS_CAST(uint, jas_image_numcmpts(dec->image)); ++i) {", " \tfor (i = 1; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image)); ++i) {", "  \t\tif (jas_image_cmptdtype(dec->image, i) != dtype) {", "  \t\t\tsamedtype = false;", "  \t\t\tbreak;", " \t\t}", " \t}", " \tif ((samedtype && dec->ihdr->data.ihdr.bpc != JP2_DTYPETOBPC(dtype)) ||", " \t  (!samedtype && dec->ihdr->data.ihdr.bpc != JP2_IHDR_BPCNULL)) {", " \t\tjas_eprintf(\"warning: component data type mismatch\\n\");", " \t}", " \tif (dec->ihdr->data.ihdr.comptype != JP2_IHDR_COMPTYPE) {", " \t\tjas_eprintf(\"error: unsupported compression type\\n\");", " \t\tgoto error;", " \t}", "  \tif (dec->bpcc) {", "\t\tif (dec->bpcc->data.bpcc.numcmpts != JAS_CAST(uint, jas_image_numcmpts(", " \t\tif (dec->bpcc->data.bpcc.numcmpts != JAS_CAST(jas_uint, jas_image_numcmpts(", "  \t\t  dec->image))) {", "  \t\t\tjas_eprintf(\"warning: number of components mismatch\\n\");", "  \t\t}", "  \t\tif (!samedtype) {", "\t\t\tfor (i = 0; i < JAS_CAST(uint, jas_image_numcmpts(dec->image));", " \t\t\tfor (i = 0; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image));", "  \t\t\t  ++i) {", "  \t\t\t\tif (jas_image_cmptdtype(dec->image, i) !=", "  \t\t\t\t  JP2_BPCTODTYPE(dec->bpcc->data.bpcc.bpcs[i])) {", " \t\t\t\t\tjas_eprintf(\"warning: component data type mismatch\\n\");", " \t\t\t\t}", " \t\t\t}", " \t\t} else {", " \t\t\tjas_eprintf(\"warning: superfluous BPCC box\\n\");", " \t\t}", " \t}", " \tif (!dec->colr) {", " \t\tjas_eprintf(\"error: no COLR box\\n\");", " \t\tgoto error;", " \t}", " \tswitch (dec->colr->data.colr.method) {", " \tcase JP2_COLR_ENUM:", " \t\tjas_image_setclrspc(dec->image, jp2_getcs(&dec->colr->data.colr));", " \t\tbreak;", " \tcase JP2_COLR_ICC:", " \t\ticcprof = jas_iccprof_createfrombuf(dec->colr->data.colr.iccp,", " \t\t  dec->colr->data.colr.iccplen);", " \t\tif (!iccprof) {", " \t\t\tjas_eprintf(\"error: failed to parse ICC profile\\n\");", " \t\t\tgoto error;", " \t\t}", " \t\tjas_iccprof_gethdr(iccprof, &icchdr);", " \t\tjas_eprintf(\"ICC Profile CS %08x\\n\", icchdr.colorspc);", " \t\tjas_image_setclrspc(dec->image, fromiccpcs(icchdr.colorspc));", " \t\tdec->image->cmprof_ = jas_cmprof_createfromiccprof(iccprof);", " \t\tassert(dec->image->cmprof_);", " \t\tjas_iccprof_destroy(iccprof);", " \t\tbreak;", " \t}", " \tif (dec->cmap && !dec->pclr) {", " \t\tjas_eprintf(\"warning: missing PCLR box or superfluous CMAP box\\n\");", " \t\tjp2_box_destroy(dec->cmap);", " \t\tdec->cmap = 0;", " \t}", " \tif (!dec->cmap && dec->pclr) {", " \t\tjas_eprintf(\"warning: missing CMAP box or superfluous PCLR box\\n\");", " \t\tjp2_box_destroy(dec->pclr);", " \t\tdec->pclr = 0;", " \t}", "  \tdec->numchans = dec->cmap ? dec->cmap->data.cmap.numchans :", "\t  JAS_CAST(uint, jas_image_numcmpts(dec->image));", " \t  JAS_CAST(jas_uint, jas_image_numcmpts(dec->image));", "  \tif (dec->cmap) {", "  \t\tfor (i = 0; i < dec->numchans; ++i) {", "\t\t\tif (dec->cmap->data.cmap.ents[i].cmptno >= JAS_CAST(uint,", " \t\t\tif (dec->cmap->data.cmap.ents[i].cmptno >= JAS_CAST(jas_uint,", "  \t\t\t  jas_image_numcmpts(dec->image))) {", "  \t\t\t\tjas_eprintf(\"error: invalid component number in CMAP box\\n\");", "  \t\t\t\tgoto error;", " \t\t\t}", " \t\t\tif (dec->cmap->data.cmap.ents[i].pcol >=", " \t\t\t  dec->pclr->data.pclr.numchans) {", " \t\t\t\tjas_eprintf(\"error: invalid CMAP LUT index\\n\");", " \t\t\t\tgoto error;", " \t\t\t}", " \t\t}", " \t}", " \tif (!(dec->chantocmptlut = jas_alloc2(dec->numchans,", " \t  sizeof(uint_fast16_t)))) {", " \t\tjas_eprintf(\"error: no memory\\n\");", " \t\tgoto error;", " \t}", " \tif (!dec->cmap) {", " \t\tfor (i = 0; i < dec->numchans; ++i) {", " \t\t\tdec->chantocmptlut[i] = i;", " \t\t}", " \t} else {", " \t\tcmapd = &dec->cmap->data.cmap;", " \t\tpclrd = &dec->pclr->data.pclr;", " \t\tcdefd = &dec->cdef->data.cdef;", " \t\tfor (channo = 0; channo < cmapd->numchans; ++channo) {", " \t\t\tcmapent = &cmapd->ents[channo];", " \t\t\tif (cmapent->map == JP2_CMAP_DIRECT) {", " \t\t\t\tdec->chantocmptlut[channo] = channo;", " \t\t\t} else if (cmapent->map == JP2_CMAP_PALETTE) {", " \t\t\t\tlutents = jas_alloc2(pclrd->numlutents, sizeof(int_fast32_t));", " \t\t\t\tfor (i = 0; i < pclrd->numlutents; ++i) {", " \t\t\t\t\tlutents[i] = pclrd->lutdata[cmapent->pcol + i * pclrd->numchans];", " \t\t\t\t}", " \t\t\t\tnewcmptno = jas_image_numcmpts(dec->image);", " \t\t\t\tjas_image_depalettize(dec->image, cmapent->cmptno,", " \t\t\t\t  pclrd->numlutents, lutents,", " \t\t\t\t  JP2_BPCTODTYPE(pclrd->bpc[cmapent->pcol]), newcmptno);", " \t\t\t\tdec->chantocmptlut[channo] = newcmptno;", " \t\t\t\tjas_free(lutents);", " #if 0", " \t\t\t\tif (dec->cdef) {", " \t\t\t\t\tcdefent = jp2_cdef_lookup(cdefd, channo);", " \t\t\t\t\tif (!cdefent) {", " \t\t\t\t\t\tabort();", " \t\t\t\t\t}", " \t\t\t\tjas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), cdefent->type, cdefent->assoc));", " \t\t\t\t} else {", " \t\t\t\tjas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), 0, channo + 1));", " \t\t\t\t}", " #endif", " \t\t\t}", " \t\t}", " \t}", "\tfor (i = 0; i < JAS_CAST(uint, jas_image_numcmpts(dec->image)); ++i) {", " \tfor (i = 0; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image)); ++i) {", "  \t\tjas_image_setcmpttype(dec->image, i, JAS_IMAGE_CT_UNKNOWN);", "  \t}", " \tif (dec->cdef) {", " \t\tfor (i = 0; i < dec->numchans; ++i) {", " \t\t\tif (dec->cdef->data.cdef.ents[i].channo >= dec->numchans) {", " \t\t\t\tjas_eprintf(\"error: invalid channel number in CDEF box\\n\");", " \t\t\t\tgoto error;", " \t\t\t}", " \t\t\tjas_image_setcmpttype(dec->image,", " \t\t\t  dec->chantocmptlut[dec->cdef->data.cdef.ents[i].channo],", " \t\t\t  jp2_getct(jas_image_clrspc(dec->image),", " \t\t\t  dec->cdef->data.cdef.ents[i].type,", " \t\t\t  dec->cdef->data.cdef.ents[i].assoc));", " \t\t}", " \t} else {", " \t\tfor (i = 0; i < dec->numchans; ++i) {", " \t\t\tjas_image_setcmpttype(dec->image, dec->chantocmptlut[i],", " \t\t\t  jp2_getct(jas_image_clrspc(dec->image), 0, i + 1));", " \t\t}", " \t}", " \tfor (i = jas_image_numcmpts(dec->image); i > 0; --i) {", " \t\tif (jas_image_cmpttype(dec->image, i - 1) == JAS_IMAGE_CT_UNKNOWN) {", " \t\t\tjas_image_delcmpt(dec->image, i - 1);", " \t\t}", " \t}", " \tif (!jas_image_numcmpts(dec->image)) {", " \t\tjas_eprintf(\"error: no components\\n\");", " \t\tgoto error;", " \t}", " #if 0", " jas_eprintf(\"no of components is %d\\n\", jas_image_numcmpts(dec->image));", " #endif", " \timage = dec->image;", " \tdec->image = 0;", " \tjp2_dec_destroy(dec);", " \treturn image;", " error:", " \tif (box) {", " \t\tjp2_box_destroy(box);", " \t}", " \tif (dec) {", " \t\tjp2_dec_destroy(dec);", " \t}", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" archive_read_format_zip_cleanup(struct archive_read *a)", " {", " \tstruct zip *zip;", " \tstruct zip_entry *zip_entry, *next_zip_entry;", " \tzip = (struct zip *)(a->format->data);", " #ifdef HAVE_ZLIB_H", " \tif (zip->stream_valid)", "  \t\tinflateEnd(&zip->stream);", "  #endif", "#if HAVA_LZMA_H && HAVE_LIBLZMA", " #if HAVE_LZMA_H && HAVE_LIBLZMA", "      if (zip->zipx_lzma_valid) {", "  \t\tlzma_end(&zip->zipx_lzma_stream);", "  \t}", " #endif", " #ifdef HAVE_BZLIB_H", " \tif (zip->bzstream_valid) {", " \t\tBZ2_bzDecompressEnd(&zip->bzstream);", " \t}", " #endif", " \tfree(zip->uncompressed_buffer);", " \tif (zip->ppmd8_valid)", " \t\t__archive_ppmd8_functions.Ppmd8_Free(&zip->ppmd8);", " \tif (zip->zip_entries) {", " \t\tzip_entry = zip->zip_entries;", " \t\twhile (zip_entry != NULL) {", " \t\t\tnext_zip_entry = zip_entry->next;", " \t\t\tarchive_string_free(&zip_entry->rsrcname);", " \t\t\tfree(zip_entry);", " \t\t\tzip_entry = next_zip_entry;", " \t\t}", " \t}", " \tfree(zip->decrypted_buffer);", " \tif (zip->cctx_valid)", " \t\tarchive_decrypto_aes_ctr_release(&zip->cctx);", " \tif (zip->hctx_valid)", " \t\tarchive_hmac_sha1_cleanup(&zip->hctx);", " \tfree(zip->iv);", " \tfree(zip->erd);", " \tfree(zip->v_data);", " \tarchive_string_free(&zip->format_name);", " \tfree(zip);", " \t(a->format->data) = NULL;", " \treturn (ARCHIVE_OK);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int flashsv_decode_frame(AVCodecContext *avctx, void *data,", "                                 int *got_frame, AVPacket *avpkt)", " {", "     int buf_size       = avpkt->size;", "     FlashSVContext *s  = avctx->priv_data;", "     int h_blocks, v_blocks, h_part, v_part, i, j, ret;", "     GetBitContext gb;", "     int last_blockwidth = s->block_width;", "     int last_blockheight= s->block_height;", "     if (buf_size == 0)", "         return 0;", "     if (buf_size < 4)", "         return -1;", "     init_get_bits(&gb, avpkt->data, buf_size * 8);", "     s->block_width  = 16 * (get_bits(&gb,  4) + 1);", "     s->image_width  =       get_bits(&gb, 12);", "     s->block_height = 16 * (get_bits(&gb,  4) + 1);", "     s->image_height =       get_bits(&gb, 12);", "     if (   last_blockwidth != s->block_width", "         || last_blockheight!= s->block_height)", "         av_freep(&s->blocks);", "     if (s->ver == 2) {", "         skip_bits(&gb, 6);", "         if (get_bits1(&gb)) {", "             avpriv_request_sample(avctx, \"iframe\");", "             return AVERROR_PATCHWELCOME;", "         }", "         if (get_bits1(&gb)) {", "             avpriv_request_sample(avctx, \"Custom palette\");", "             return AVERROR_PATCHWELCOME;", "         }", "     }", "     h_blocks = s->image_width  / s->block_width;", "     h_part   = s->image_width  % s->block_width;", "     v_blocks = s->image_height / s->block_height;", "     v_part   = s->image_height % s->block_height;", "     if (s->block_size < s->block_width * s->block_height) {", "         int tmpblock_size = 3 * s->block_width * s->block_height;", "         s->tmpblock = av_realloc(s->tmpblock, tmpblock_size);", "         if (!s->tmpblock) {", "             av_log(avctx, AV_LOG_ERROR, \"Can't allocate decompression buffer.\\n\");", "             return AVERROR(ENOMEM);", "         }", "         if (s->ver == 2) {", "             s->deflate_block_size = calc_deflate_block_size(tmpblock_size);", "             if (s->deflate_block_size <= 0) {", "                 av_log(avctx, AV_LOG_ERROR, \"Can't determine deflate buffer size.\\n\");", "                 return -1;", "             }", "             s->deflate_block = av_realloc(s->deflate_block, s->deflate_block_size);", "             if (!s->deflate_block) {", "                 av_log(avctx, AV_LOG_ERROR, \"Can't allocate deflate buffer.\\n\");", "                 return AVERROR(ENOMEM);", "             }", "         }", "     }", "     s->block_size = s->block_width * s->block_height;", "     if (avctx->width == 0 && avctx->height == 0) {", "         avcodec_set_dimensions(avctx, s->image_width, s->image_height);", "     }", "     if (avctx->width != s->image_width || avctx->height != s->image_height) {", "         av_log(avctx, AV_LOG_ERROR,", "                \"Frame width or height differs from first frame!\\n\");", "         av_log(avctx, AV_LOG_ERROR, \"fh = %d, fv %d  vs  ch = %d, cv = %d\\n\",", "                avctx->height, avctx->width, s->image_height, s->image_width);", "         return AVERROR_INVALIDDATA;", "     }", "     s->is_keyframe = (avpkt->flags & AV_PKT_FLAG_KEY) && (s->ver == 2);", "     if (s->is_keyframe) {", "         s->keyframedata = av_realloc(s->keyframedata, avpkt->size);", "         memcpy(s->keyframedata, avpkt->data, avpkt->size);", "     }", "     if(s->ver == 2 && !s->blocks)", "         s->blocks = av_mallocz((v_blocks + !!v_part) * (h_blocks + !!h_part)", "                                 * sizeof(s->blocks[0]));", "     av_dlog(avctx, \"image: %dx%d block: %dx%d num: %dx%d part: %dx%d\\n\",", "             s->image_width, s->image_height, s->block_width, s->block_height,", "             h_blocks, v_blocks, h_part, v_part);", "     if ((ret = ff_reget_buffer(avctx, &s->frame)) < 0)", "         return ret;", "     for (j = 0; j < v_blocks + (v_part ? 1 : 0); j++) {", "         int y_pos  = j * s->block_height;  ", "         int cur_blk_height = (j < v_blocks) ? s->block_height : v_part;", "         for (i = 0; i < h_blocks + (h_part ? 1 : 0); i++) {", "             int x_pos = i * s->block_width;  ", "             int cur_blk_width = (i < h_blocks) ? s->block_width : h_part;", "             int has_diff = 0;", "             int size = get_bits(&gb, 16);", "             s->color_depth    = 0;", "             s->zlibprime_curr = 0;", "             s->zlibprime_prev = 0;", "             s->diff_start     = 0;", "             s->diff_height    = cur_blk_height;", "             if (8 * size > get_bits_left(&gb)) {", "                 av_frame_unref(&s->frame);", "                 return AVERROR_INVALIDDATA;", "             }", "             if (s->ver == 2 && size) {", "                 skip_bits(&gb, 3);", "                 s->color_depth    = get_bits(&gb, 2);", "                 has_diff          = get_bits1(&gb);", "                 s->zlibprime_curr = get_bits1(&gb);", "                 s->zlibprime_prev = get_bits1(&gb);", "                 if (s->color_depth != 0 && s->color_depth != 2) {", "                     av_log(avctx, AV_LOG_ERROR,", "                            \"%dx%d invalid color depth %d\\n\", i, j, s->color_depth);", "                     return AVERROR_INVALIDDATA;", "                 }", "                 if (has_diff) {", "                     if (!s->keyframe) {", "                         av_log(avctx, AV_LOG_ERROR,", "                                \"inter frame without keyframe\\n\");", "                         return AVERROR_INVALIDDATA;", "                      }", "                      s->diff_start  = get_bits(&gb, 8);", "                      s->diff_height = get_bits(&gb, 8);", "                     if (s->diff_start + s->diff_height > cur_blk_height) {", "                         av_log(avctx, AV_LOG_ERROR, \"Block parameters invalid\\n\");", "                         return AVERROR_INVALIDDATA;", "                     }", "                      av_log(avctx, AV_LOG_DEBUG,", "                             \"%dx%d diff start %d height %d\\n\",", "                             i, j, s->diff_start, s->diff_height);", "                     size -= 2;", "                 }", "                 if (s->zlibprime_prev)", "                     av_log(avctx, AV_LOG_DEBUG, \"%dx%d zlibprime_prev\\n\", i, j);", "                 if (s->zlibprime_curr) {", "                     int col = get_bits(&gb, 8);", "                     int row = get_bits(&gb, 8);", "                     av_log(avctx, AV_LOG_DEBUG, \"%dx%d zlibprime_curr %dx%d\\n\", i, j, col, row);", "                     size -= 2;", "                     avpriv_request_sample(avctx, \"zlibprime_curr\");", "                     return AVERROR_PATCHWELCOME;", "                 }", "                 if (!s->blocks && (s->zlibprime_curr || s->zlibprime_prev)) {", "                     av_log(avctx, AV_LOG_ERROR, \"no data available for zlib \"", "                            \"priming\\n\");", "                     return AVERROR_INVALIDDATA;", "                 }", "                 size--;  ", "             }", "             if (has_diff) {", "                 int k;", "                 int off = (s->image_height - y_pos - 1) * s->frame.linesize[0];", "                 for (k = 0; k < cur_blk_height; k++)", "                     memcpy(s->frame.data[0] + off - k*s->frame.linesize[0] + x_pos*3,", "                            s->keyframe + off - k*s->frame.linesize[0] + x_pos*3,", "                            cur_blk_width * 3);", "             }", "             if (size) {", "                 if (flashsv_decode_block(avctx, avpkt, &gb, size,", "                                          cur_blk_width, cur_blk_height,", "                                          x_pos, y_pos,", "                                          i + j * (h_blocks + !!h_part)))", "                     av_log(avctx, AV_LOG_ERROR,", "                            \"error in decompression of block %dx%d\\n\", i, j);", "             }", "         }", "     }", "     if (s->is_keyframe && s->ver == 2) {", "         if (!s->keyframe) {", "             s->keyframe = av_malloc(s->frame.linesize[0] * avctx->height);", "             if (!s->keyframe) {", "                 av_log(avctx, AV_LOG_ERROR, \"Cannot allocate image data\\n\");", "                 return AVERROR(ENOMEM);", "             }", "         }", "         memcpy(s->keyframe, s->frame.data[0], s->frame.linesize[0] * avctx->height);", "     }", "     if ((ret = av_frame_ref(data, &s->frame)) < 0)", "         return ret;", "     *got_frame = 1;", "     if ((get_bits_count(&gb) / 8) != buf_size)", "         av_log(avctx, AV_LOG_ERROR, \"buffer not fully consumed (%d != %d)\\n\",", "                buf_size, (get_bits_count(&gb) / 8));", "     return buf_size;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void CNB::DoIPHdrCSO(PVOID IpHeader, ULONG EthPayloadLength) const", "  {", "      ParaNdis_CheckSumVerifyFlat(IpHeader,", "                                  EthPayloadLength,", "                                pcrIpChecksum | pcrFixIPChecksum,", "                                 pcrIpChecksum | pcrFixIPChecksum, FALSE,", "                                  __FUNCTION__);", "  }"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 0]}
{"tokens": [" int rpc_type_of_NPPVariable(int variable)", " {", "   int type;", "   switch (variable) {", "    case NPPVpluginNameString:", "    case NPPVpluginDescriptionString:", "    case NPPVformValue:  ", "   case NPPVpluginNativeAccessibleAtkPlugId:", "  \ttype = RPC_TYPE_STRING;", "  \tbreak;", "    case NPPVpluginWindowSize:", "   case NPPVpluginTimerInterval:", " \ttype = RPC_TYPE_INT32;", " \tbreak;", "   case NPPVpluginNeedsXEmbed:", "   case NPPVpluginWindowBool:", "    case NPPVpluginTransparentBool:", "    case NPPVjavascriptPushCallerBool:", "    case NPPVpluginKeepLibraryInMemory:", "   case NPPVpluginUrlRequestsDisplayedBool:", "   case NPPVpluginWantsAllNetworkStreams:", "   case NPPVpluginCancelSrcStream:", "   case NPPVSupportsAdvancedKeyHandling:", "  \ttype = RPC_TYPE_BOOLEAN;", "  \tbreak;", "    case NPPVpluginScriptableNPObject:", " \ttype = RPC_TYPE_NP_OBJECT;", " \tbreak;", "   default:", " \ttype = RPC_ERROR_GENERIC;", " \tbreak;", "   }", "   return type;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" rtadv_read (struct thread *thread)", " {", "   int sock;", "   int len;", "   u_char buf[RTADV_MSG_SIZE];", "   struct sockaddr_in6 from;", "   ifindex_t ifindex = 0;", "   int hoplimit = -1;", "   struct zebra_vrf *zvrf = THREAD_ARG (thread);", "   sock = THREAD_FD (thread);", "   zvrf->rtadv.ra_read = NULL;", "    rtadv_event (zvrf, RTADV_READ, sock);", "  len = rtadv_recv_packet (sock, buf, BUFSIZ, &from, &ifindex, &hoplimit);", "   len = rtadv_recv_packet (sock, buf, sizeof (buf), &from, &ifindex, &hoplimit);", "    if (len < 0) ", "      {", "       zlog_warn (\"router solicitation recv failed: %s.\", safe_strerror (errno));", "       return len;", "     }", "   rtadv_process_packet (buf, (unsigned)len, ifindex, hoplimit, zvrf->vrf_id);", "   return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int mov_write_audio_tag(AVFormatContext *s, AVIOContext *pb, MOVMuxContext *mov, MOVTrack *track)", " {", "     int64_t pos = avio_tell(pb);", "     int version = 0;", "      uint32_t tag = track->tag;", "      if (track->mode == MODE_MOV) {", "        if (track->timescale > UINT16_MAX) {", "         if (track->timescale > UINT16_MAX || !track->par->channels) {", "              if (mov_get_lpcm_flags(track->par->codec_id))", "                  tag = AV_RL32(\"lpcm\");", "              version = 2;", "         } else if (track->audio_vbr || mov_pcm_le_gt16(track->par->codec_id) ||", "                    mov_pcm_be_gt16(track->par->codec_id) ||", "                    track->par->codec_id == AV_CODEC_ID_ADPCM_MS ||", "                    track->par->codec_id == AV_CODEC_ID_ADPCM_IMA_WAV ||", "                    track->par->codec_id == AV_CODEC_ID_QDM2) {", "             version = 1;", "         }", "     }", "     avio_wb32(pb, 0);  ", "     if (mov->encryption_scheme != MOV_ENC_NONE) {", "         ffio_wfourcc(pb, \"enca\");", "     } else {", "         avio_wl32(pb, tag);  ", "     }", "     avio_wb32(pb, 0);  ", "     avio_wb16(pb, 0);  ", "     avio_wb16(pb, 1);  ", "     avio_wb16(pb, version);  ", "     avio_wb16(pb, 0);  ", "     avio_wb32(pb, 0);  ", "     if (version == 2) {", "         avio_wb16(pb, 3);", "         avio_wb16(pb, 16);", "         avio_wb16(pb, 0xfffe);", "         avio_wb16(pb, 0);", "         avio_wb32(pb, 0x00010000);", "         avio_wb32(pb, 72);", "         avio_wb64(pb, av_double2int(track->par->sample_rate));", "         avio_wb32(pb, track->par->channels);", "         avio_wb32(pb, 0x7F000000);", "         avio_wb32(pb, av_get_bits_per_sample(track->par->codec_id));", "         avio_wb32(pb, mov_get_lpcm_flags(track->par->codec_id));", "         avio_wb32(pb, track->sample_size);", "         avio_wb32(pb, get_samples_per_packet(track));", "     } else {", "         if (track->mode == MODE_MOV) {", "             avio_wb16(pb, track->par->channels);", "             if (track->par->codec_id == AV_CODEC_ID_PCM_U8 ||", "                 track->par->codec_id == AV_CODEC_ID_PCM_S8)", "                 avio_wb16(pb, 8);  ", "             else if (track->par->codec_id == AV_CODEC_ID_ADPCM_G726)", "                 avio_wb16(pb, track->par->bits_per_coded_sample);", "             else", "                 avio_wb16(pb, 16);", "             avio_wb16(pb, track->audio_vbr ? -2 : 0);  ", "         } else {  ", "             if (track->par->codec_id == AV_CODEC_ID_FLAC ||", "                 track->par->codec_id == AV_CODEC_ID_OPUS) {", "                 avio_wb16(pb, track->par->channels);", "             } else {", "                 avio_wb16(pb, 2);", "             }", "             if (track->par->codec_id == AV_CODEC_ID_FLAC) {", "                 avio_wb16(pb, track->par->bits_per_raw_sample);", "             } else {", "                 avio_wb16(pb, 16);", "             }", "             avio_wb16(pb, 0);", "         }", "         avio_wb16(pb, 0);  ", "         if (track->par->codec_id == AV_CODEC_ID_OPUS)", "             avio_wb16(pb, 48000);", "         else", "             avio_wb16(pb, track->par->sample_rate <= UINT16_MAX ?", "                           track->par->sample_rate : 0);", "         avio_wb16(pb, 0);  ", "     }", "     if (version == 1) {  ", "         if (mov_pcm_le_gt16(track->par->codec_id) ||", "             mov_pcm_be_gt16(track->par->codec_id))", "             avio_wb32(pb, 1);  ", "         else", "             avio_wb32(pb, track->par->frame_size);  ", "         avio_wb32(pb, track->sample_size / track->par->channels);  ", "         avio_wb32(pb, track->sample_size);  ", "         avio_wb32(pb, 2);  ", "     }", "     if (track->mode == MODE_MOV &&", "         (track->par->codec_id == AV_CODEC_ID_AAC           ||", "          track->par->codec_id == AV_CODEC_ID_AC3           ||", "          track->par->codec_id == AV_CODEC_ID_EAC3          ||", "          track->par->codec_id == AV_CODEC_ID_AMR_NB        ||", "          track->par->codec_id == AV_CODEC_ID_ALAC          ||", "          track->par->codec_id == AV_CODEC_ID_ADPCM_MS      ||", "          track->par->codec_id == AV_CODEC_ID_ADPCM_IMA_WAV ||", "          track->par->codec_id == AV_CODEC_ID_QDM2          ||", "          (mov_pcm_le_gt16(track->par->codec_id) && version==1) ||", "          (mov_pcm_be_gt16(track->par->codec_id) && version==1)))", "         mov_write_wave_tag(s, pb, track);", "     else if (track->tag == MKTAG('m','p','4','a'))", "         mov_write_esds_tag(pb, track);", "     else if (track->par->codec_id == AV_CODEC_ID_AMR_NB)", "         mov_write_amr_tag(pb, track);", "     else if (track->par->codec_id == AV_CODEC_ID_AC3)", "         mov_write_ac3_tag(pb, track);", "     else if (track->par->codec_id == AV_CODEC_ID_EAC3)", "         mov_write_eac3_tag(pb, track);", "     else if (track->par->codec_id == AV_CODEC_ID_ALAC)", "         mov_write_extradata_tag(pb, track);", "     else if (track->par->codec_id == AV_CODEC_ID_WMAPRO)", "         mov_write_wfex_tag(s, pb, track);", "     else if (track->par->codec_id == AV_CODEC_ID_FLAC)", "         mov_write_dfla_tag(pb, track);", "     else if (track->par->codec_id == AV_CODEC_ID_OPUS)", "         mov_write_dops_tag(pb, track);", "     else if (track->vos_len > 0)", "         mov_write_glbl_tag(pb, track);", "     if (track->mode == MODE_MOV && track->par->codec_type == AVMEDIA_TYPE_AUDIO)", "         mov_write_chan_tag(s, pb, track);", "     if (mov->encryption_scheme != MOV_ENC_NONE) {", "         ff_mov_cenc_write_sinf_tag(track, pb, mov->encryption_kid);", "     }", "     return update_size(pb, pos);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int decode_studio_vop_header(Mpeg4DecContext *ctx, GetBitContext *gb)", " {", "     MpegEncContext *s = &ctx->m;", "     if (get_bits_left(gb) <= 32)", "          return 0;", "      s->partitioned_frame = 0;", "     s->interlaced_dct = 0;", "      s->decode_mb = mpeg4_decode_studio_mb;", "      decode_smpte_tc(ctx, gb);", "     skip_bits(gb, 10);  ", "     skip_bits(gb, 2);  ", "     s->pict_type = get_bits(gb, 2) + AV_PICTURE_TYPE_I;  ", "     if (get_bits1(gb)) {  ", "         skip_bits1(gb);  ", "         skip_bits1(gb);  ", "         s->progressive_frame = get_bits1(gb) ^ 1;  ", "     }", "     if (s->pict_type == AV_PICTURE_TYPE_I) {", "         if (get_bits1(gb))", "             reset_studio_dc_predictors(s);", "     }", "     if (ctx->shape != BIN_ONLY_SHAPE) {", "         s->alternate_scan = get_bits1(gb);", "         s->frame_pred_frame_dct = get_bits1(gb);", "         s->dct_precision = get_bits(gb, 2);", "         s->intra_dc_precision = get_bits(gb, 2);", "         s->q_scale_type = get_bits1(gb);", "     }", "     if (s->alternate_scan) {", "         ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable,   ff_alternate_vertical_scan);", "         ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable,   ff_alternate_vertical_scan);", "         ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_vertical_scan);", "         ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);", "     } else {", "         ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable,   ff_zigzag_direct);", "         ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable,   ff_zigzag_direct);", "         ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan);", "         ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);", "     }", "     mpeg4_load_default_matrices(s);", "     next_start_code_studio(gb);", "     extension_and_user_data(s, gb, 4);", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" char *strstr(char *s1, char *s2)", " {                                ", "     char *p;", "     int len = strlen(s2);", "      if (*s2 == '\\0')             ", "          return s1;", "    for (p = s1; (p = strchr(p, *s2)) != NULL; p = strchr(p + 1, *s2)) {", "     for (p = s1; (p = strchr(p, *s2)) != NULL; p++) {", "          if (strncmp(p, s2, len) == 0)", "              return (p);", "      }", "     return NULL;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" GF_Err tenc_dump(GF_Box *a, FILE * trace)", " {", " \tGF_TrackEncryptionBox *ptr = (GF_TrackEncryptionBox*) a;", " \tif (!a) return GF_BAD_PARAM;", " \tgf_isom_box_dump_start(a, \"TrackEncryptionBox\", trace);", " \tfprintf(trace, \"isEncrypted=\\\"%d\\\"\", ptr->isProtected);", " \tif (ptr->Per_Sample_IV_Size)", " \t\tfprintf(trace, \" IV_size=\\\"%d\\\" KID=\\\"\", ptr->Per_Sample_IV_Size);", " \telse {", " \t\tfprintf(trace, \" constant_IV_size=\\\"%d\\\" constant_IV=\\\"\", ptr->constant_IV_size);", " \t\tdump_data_hex(trace, (char *) ptr->constant_IV, ptr->constant_IV_size);", "  \t\tfprintf(trace, \"\\\"  KID=\\\"\");", "  \t}", "  \tdump_data_hex(trace, (char *) ptr->KID, 16);", "\tif (ptr->version) ", " \tif (ptr->version)", "  \t\tfprintf(trace, \"\\\" crypt_byte_block=\\\"%d\\\" skip_byte_block=\\\"%d\", ptr->crypt_byte_block, ptr->skip_byte_block);", "  \tfprintf(trace, \"\\\">\\n\");", "  \tgf_isom_box_dump_done(\"TrackEncryptionBox\", a, trace);", " \treturn GF_OK;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)", " {", " \tmuscle_private_t* priv = MUSCLE_DATA(card);", " \tmscfs_t *fs = priv->fs;", " \tint x;", " \tint count = 0;", "  \tmscfs_check_cache(priv->fs);", "  \tfor(x = 0; x < fs->cache.size; x++) {", "\t\tu8* oid= fs->cache.array[x].objectId.id;", " \t\tu8* oid = fs->cache.array[x].objectId.id;", " \t\tif (bufLen < 2)", " \t\t\tbreak;", "  \t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,", "  \t\t\t\"FILE: %02X%02X%02X%02X\\n\",", "  \t\t\toid[0],oid[1],oid[2],oid[3]);", " \t\tif(0 == memcmp(fs->currentPath, oid, 2)) {", " \t\t\tbuf[0] = oid[2];", "  \t\t\tbuf[1] = oid[3];", "  \t\t\tif(buf[0] == 0x00 && buf[1] == 0x00) continue;  ", "  \t\t\tbuf += 2;", "\t\t\tcount+=2;", " \t\t\tcount += 2;", " \t\t\tbufLen -= 2;", "  \t\t}", "  \t}", "  \treturn count;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": [" char *FLTGetIsLikeComparisonCommonExpression(FilterEncodingNode *psFilterNode)", " {", "   const size_t bufferSize = 1024;", "   char szBuffer[1024];", "   char szTmp[256];", "   char *pszValue = NULL;", "   const char *pszWild = NULL;", "   const char *pszSingle = NULL;", "   const char *pszEscape = NULL;", "   int  bCaseInsensitive = 0;", "   FEPropertyIsLike* propIsLike;", "   int nLength=0, i=0, iTmp=0;", "   if (!psFilterNode || !psFilterNode->pOther || !psFilterNode->psLeftNode || !psFilterNode->psRightNode || !psFilterNode->psRightNode->pszValue)", "     return NULL;", "   propIsLike = (FEPropertyIsLike *)psFilterNode->pOther;", "   pszWild = propIsLike->pszWildCard;", "   pszSingle = propIsLike->pszSingleChar;", "   pszEscape = propIsLike->pszEscapeChar;", "   bCaseInsensitive = propIsLike->bCaseInsensitive;", "   if (!pszWild || strlen(pszWild) == 0 || !pszSingle || strlen(pszSingle) == 0 || !pszEscape || strlen(pszEscape) == 0)", "     return NULL;", "   szBuffer[0] = '\\0';", "   sprintf(szTmp, \"%s\", \"(\\\"[\");", "   szTmp[4] = '\\0';", "   strlcat(szBuffer, szTmp, bufferSize);", "   strlcat(szBuffer, psFilterNode->psLeftNode->pszValue, bufferSize);", "   szBuffer[strlen(szBuffer)] = '\\0';", "   if (bCaseInsensitive == 1)", "     sprintf(szTmp, \"%s\", \"]\\\" ~* \\\"\");", "   else", "     sprintf(szTmp, \"%s\", \"]\\\" ~ \\\"\");", "   szTmp[7] = '\\0';", "   strlcat(szBuffer, szTmp, bufferSize);", "   szBuffer[strlen(szBuffer)] = '\\0';", "    pszValue = psFilterNode->psRightNode->pszValue;", "    nLength = strlen(pszValue);", "   if( 1 + 2 * nLength + 1 + 1 >= sizeof(szTmp) )", "       return NULL;", "    iTmp =0;", "    if (nLength > 0 && pszValue[0] != pszWild[0] && pszValue[0] != pszSingle[0] && pszValue[0] != pszEscape[0]) {", "     szTmp[iTmp]= '^';", "     iTmp++;", "   }", "   for (i=0; i<nLength; i++) {", "     if (pszValue[i] != pszWild[0] && pszValue[i] != pszSingle[0] && pszValue[i] != pszEscape[0]) {", "       szTmp[iTmp] = pszValue[i];", "       iTmp++;", "       szTmp[iTmp] = '\\0';", "     } else if (pszValue[i] == pszSingle[0]) {", "       szTmp[iTmp] = '.';", "       iTmp++;", "       szTmp[iTmp] = '\\0';", "     } else if (pszValue[i] == pszEscape[0]) {", "       szTmp[iTmp] = '\\\\';", "       iTmp++;", "       szTmp[iTmp] = '\\0';", "     } else if (pszValue[i] == pszWild[0]) {", "       szTmp[iTmp++] = '.';", "       szTmp[iTmp++] = '*';", "       szTmp[iTmp] = '\\0';", "     }", "   }", "   szTmp[iTmp] = '\"';", "   szTmp[++iTmp] = '\\0';", "   strlcat(szBuffer, szTmp, bufferSize);", "   strlcat(szBuffer, \")\", bufferSize);", "   return msStrdup(szBuffer);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  doProlog(XML_Parser parser, const ENCODING *enc, const char *s, const char *end,", "         int tok, const char *next, const char **nextPtr, XML_Bool haveMore) {", "          int tok, const char *next, const char **nextPtr, XML_Bool haveMore,", "          XML_Bool allowClosingDoctype) {", "  #ifdef XML_DTD", "    static const XML_Char externalSubsetName[] = {ASCII_HASH, '\\0'};", "  #endif  ", "   static const XML_Char atypeCDATA[]", "       = {ASCII_C, ASCII_D, ASCII_A, ASCII_T, ASCII_A, '\\0'};", "   static const XML_Char atypeID[] = {ASCII_I, ASCII_D, '\\0'};", "   static const XML_Char atypeIDREF[]", "       = {ASCII_I, ASCII_D, ASCII_R, ASCII_E, ASCII_F, '\\0'};", "   static const XML_Char atypeIDREFS[]", "       = {ASCII_I, ASCII_D, ASCII_R, ASCII_E, ASCII_F, ASCII_S, '\\0'};", "   static const XML_Char atypeENTITY[]", "       = {ASCII_E, ASCII_N, ASCII_T, ASCII_I, ASCII_T, ASCII_Y, '\\0'};", "   static const XML_Char atypeENTITIES[]", "       = {ASCII_E, ASCII_N, ASCII_T, ASCII_I, ASCII_T,", "          ASCII_I, ASCII_E, ASCII_S, '\\0'};", "   static const XML_Char atypeNMTOKEN[]", "       = {ASCII_N, ASCII_M, ASCII_T, ASCII_O, ASCII_K, ASCII_E, ASCII_N, '\\0'};", "   static const XML_Char atypeNMTOKENS[]", "       = {ASCII_N, ASCII_M, ASCII_T, ASCII_O, ASCII_K,", "          ASCII_E, ASCII_N, ASCII_S, '\\0'};", "   static const XML_Char notationPrefix[]", "       = {ASCII_N, ASCII_O, ASCII_T, ASCII_A,      ASCII_T,", "          ASCII_I, ASCII_O, ASCII_N, ASCII_LPAREN, '\\0'};", "   static const XML_Char enumValueSep[] = {ASCII_PIPE, '\\0'};", "   static const XML_Char enumValueStart[] = {ASCII_LPAREN, '\\0'};", "   DTD *const dtd = parser->m_dtd;", "   const char **eventPP;", "   const char **eventEndPP;", "   enum XML_Content_Quant quant;", "   if (enc == parser->m_encoding) {", "     eventPP = &parser->m_eventPtr;", "     eventEndPP = &parser->m_eventEndPtr;", "   } else {", "     eventPP = &(parser->m_openInternalEntities->internalEventPtr);", "     eventEndPP = &(parser->m_openInternalEntities->internalEventEndPtr);", "   }", "   for (;;) {", "     int role;", "     XML_Bool handleDefault = XML_TRUE;", "     *eventPP = s;", "     *eventEndPP = next;", "     if (tok <= 0) {", "       if (haveMore && tok != XML_TOK_INVALID) {", "         *nextPtr = s;", "         return XML_ERROR_NONE;", "       }", "       switch (tok) {", "       case XML_TOK_INVALID:", "         *eventPP = next;", "         return XML_ERROR_INVALID_TOKEN;", "       case XML_TOK_PARTIAL:", "         return XML_ERROR_UNCLOSED_TOKEN;", "       case XML_TOK_PARTIAL_CHAR:", "         return XML_ERROR_PARTIAL_CHAR;", "       case -XML_TOK_PROLOG_S:", "         tok = -tok;", "         break;", "       case XML_TOK_NONE:", " #ifdef XML_DTD", "         if (enc != parser->m_encoding", "             && ! parser->m_openInternalEntities->betweenDecl) {", "           *nextPtr = s;", "           return XML_ERROR_NONE;", "         }", "         if (parser->m_isParamEntity || enc != parser->m_encoding) {", "           if (XmlTokenRole(&parser->m_prologState, XML_TOK_NONE, end, end, enc)", "               == XML_ROLE_ERROR)", "             return XML_ERROR_INCOMPLETE_PE;", "           *nextPtr = s;", "           return XML_ERROR_NONE;", "         }", " #endif  ", "         return XML_ERROR_NO_ELEMENTS;", "       default:", "         tok = -tok;", "         next = end;", "         break;", "       }", "     }", "     role = XmlTokenRole(&parser->m_prologState, tok, s, next, enc);", "     switch (role) {", "     case XML_ROLE_XML_DECL: {", "       enum XML_Error result = processXmlDecl(parser, 0, s, next);", "       if (result != XML_ERROR_NONE)", "         return result;", "       enc = parser->m_encoding;", "       handleDefault = XML_FALSE;", "     } break;", "     case XML_ROLE_DOCTYPE_NAME:", "       if (parser->m_startDoctypeDeclHandler) {", "         parser->m_doctypeName", "             = poolStoreString(&parser->m_tempPool, enc, s, next);", "         if (! parser->m_doctypeName)", "           return XML_ERROR_NO_MEMORY;", "         poolFinish(&parser->m_tempPool);", "         parser->m_doctypePubid = NULL;", "         handleDefault = XML_FALSE;", "       }", "       parser->m_doctypeSysid = NULL;  ", "       break;", "     case XML_ROLE_DOCTYPE_INTERNAL_SUBSET:", "       if (parser->m_startDoctypeDeclHandler) {", "         parser->m_startDoctypeDeclHandler(", "             parser->m_handlerArg, parser->m_doctypeName, parser->m_doctypeSysid,", "             parser->m_doctypePubid, 1);", "         parser->m_doctypeName = NULL;", "         poolClear(&parser->m_tempPool);", "         handleDefault = XML_FALSE;", "       }", "       break;", " #ifdef XML_DTD", "     case XML_ROLE_TEXT_DECL: {", "       enum XML_Error result = processXmlDecl(parser, 1, s, next);", "       if (result != XML_ERROR_NONE)", "         return result;", "       enc = parser->m_encoding;", "       handleDefault = XML_FALSE;", "     } break;", " #endif  ", "     case XML_ROLE_DOCTYPE_PUBLIC_ID:", " #ifdef XML_DTD", "       parser->m_useForeignDTD = XML_FALSE;", "       parser->m_declEntity = (ENTITY *)lookup(", "           parser, &dtd->paramEntities, externalSubsetName, sizeof(ENTITY));", "       if (! parser->m_declEntity)", "         return XML_ERROR_NO_MEMORY;", " #endif  ", "       dtd->hasParamEntityRefs = XML_TRUE;", "       if (parser->m_startDoctypeDeclHandler) {", "         XML_Char *pubId;", "         if (! XmlIsPublicId(enc, s, next, eventPP))", "           return XML_ERROR_PUBLICID;", "         pubId = poolStoreString(&parser->m_tempPool, enc,", "                                 s + enc->minBytesPerChar,", "                                 next - enc->minBytesPerChar);", "         if (! pubId)", "           return XML_ERROR_NO_MEMORY;", "         normalizePublicId(pubId);", "         poolFinish(&parser->m_tempPool);", "         parser->m_doctypePubid = pubId;", "         handleDefault = XML_FALSE;", "         goto alreadyChecked;", "       }", "     case XML_ROLE_ENTITY_PUBLIC_ID:", "       if (! XmlIsPublicId(enc, s, next, eventPP))", "         return XML_ERROR_PUBLICID;", "     alreadyChecked:", "       if (dtd->keepProcessing && parser->m_declEntity) {", "         XML_Char *tem", "             = poolStoreString(&dtd->pool, enc, s + enc->minBytesPerChar,", "                               next - enc->minBytesPerChar);", "         if (! tem)", "           return XML_ERROR_NO_MEMORY;", "         normalizePublicId(tem);", "         parser->m_declEntity->publicId = tem;", "         poolFinish(&dtd->pool);", "         if (parser->m_entityDeclHandler && role == XML_ROLE_ENTITY_PUBLIC_ID)", "           handleDefault = XML_FALSE;", "        }", "        break;", "      case XML_ROLE_DOCTYPE_CLOSE:", "       if (allowClosingDoctype != XML_TRUE) {", "         return XML_ERROR_INVALID_TOKEN;", "       }", "        if (parser->m_doctypeName) {", "          parser->m_startDoctypeDeclHandler(", "              parser->m_handlerArg, parser->m_doctypeName, parser->m_doctypeSysid,", "             parser->m_doctypePubid, 0);", "         poolClear(&parser->m_tempPool);", "         handleDefault = XML_FALSE;", "       }", " #ifdef XML_DTD", "       if (parser->m_doctypeSysid || parser->m_useForeignDTD) {", "         XML_Bool hadParamEntityRefs = dtd->hasParamEntityRefs;", "         dtd->hasParamEntityRefs = XML_TRUE;", "         if (parser->m_paramEntityParsing", "             && parser->m_externalEntityRefHandler) {", "           ENTITY *entity = (ENTITY *)lookup(parser, &dtd->paramEntities,", "                                             externalSubsetName, sizeof(ENTITY));", "           if (! entity) {", "             return XML_ERROR_NO_MEMORY;  ", "           }", "           if (parser->m_useForeignDTD)", "             entity->base = parser->m_curBase;", "           dtd->paramEntityRead = XML_FALSE;", "           if (! parser->m_externalEntityRefHandler(", "                   parser->m_externalEntityRefHandlerArg, 0, entity->base,", "                   entity->systemId, entity->publicId))", "             return XML_ERROR_EXTERNAL_ENTITY_HANDLING;", "           if (dtd->paramEntityRead) {", "             if (! dtd->standalone && parser->m_notStandaloneHandler", "                 && ! parser->m_notStandaloneHandler(parser->m_handlerArg))", "               return XML_ERROR_NOT_STANDALONE;", "           }", "           else if (! parser->m_doctypeSysid)", "             dtd->hasParamEntityRefs = hadParamEntityRefs;", "         }", "         parser->m_useForeignDTD = XML_FALSE;", "       }", " #endif  ", "       if (parser->m_endDoctypeDeclHandler) {", "         parser->m_endDoctypeDeclHandler(parser->m_handlerArg);", "         handleDefault = XML_FALSE;", "       }", "       break;", "     case XML_ROLE_INSTANCE_START:", " #ifdef XML_DTD", "       if (parser->m_useForeignDTD) {", "         XML_Bool hadParamEntityRefs = dtd->hasParamEntityRefs;", "         dtd->hasParamEntityRefs = XML_TRUE;", "         if (parser->m_paramEntityParsing", "             && parser->m_externalEntityRefHandler) {", "           ENTITY *entity = (ENTITY *)lookup(parser, &dtd->paramEntities,", "                                             externalSubsetName, sizeof(ENTITY));", "           if (! entity)", "             return XML_ERROR_NO_MEMORY;", "           entity->base = parser->m_curBase;", "           dtd->paramEntityRead = XML_FALSE;", "           if (! parser->m_externalEntityRefHandler(", "                   parser->m_externalEntityRefHandlerArg, 0, entity->base,", "                   entity->systemId, entity->publicId))", "             return XML_ERROR_EXTERNAL_ENTITY_HANDLING;", "           if (dtd->paramEntityRead) {", "             if (! dtd->standalone && parser->m_notStandaloneHandler", "                 && ! parser->m_notStandaloneHandler(parser->m_handlerArg))", "               return XML_ERROR_NOT_STANDALONE;", "           }", "           else", "             dtd->hasParamEntityRefs = hadParamEntityRefs;", "         }", "       }", " #endif  ", "       parser->m_processor = contentProcessor;", "       return contentProcessor(parser, s, end, nextPtr);", "     case XML_ROLE_ATTLIST_ELEMENT_NAME:", "       parser->m_declElementType = getElementType(parser, enc, s, next);", "       if (! parser->m_declElementType)", "         return XML_ERROR_NO_MEMORY;", "       goto checkAttListDeclHandler;", "     case XML_ROLE_ATTRIBUTE_NAME:", "       parser->m_declAttributeId = getAttributeId(parser, enc, s, next);", "       if (! parser->m_declAttributeId)", "         return XML_ERROR_NO_MEMORY;", "       parser->m_declAttributeIsCdata = XML_FALSE;", "       parser->m_declAttributeType = NULL;", "       parser->m_declAttributeIsId = XML_FALSE;", "       goto checkAttListDeclHandler;", "     case XML_ROLE_ATTRIBUTE_TYPE_CDATA:", "       parser->m_declAttributeIsCdata = XML_TRUE;", "       parser->m_declAttributeType = atypeCDATA;", "       goto checkAttListDeclHandler;", "     case XML_ROLE_ATTRIBUTE_TYPE_ID:", "       parser->m_declAttributeIsId = XML_TRUE;", "       parser->m_declAttributeType = atypeID;", "       goto checkAttListDeclHandler;", "     case XML_ROLE_ATTRIBUTE_TYPE_IDREF:", "       parser->m_declAttributeType = atypeIDREF;", "       goto checkAttListDeclHandler;", "     case XML_ROLE_ATTRIBUTE_TYPE_IDREFS:", "       parser->m_declAttributeType = atypeIDREFS;", "       goto checkAttListDeclHandler;", "     case XML_ROLE_ATTRIBUTE_TYPE_ENTITY:", "       parser->m_declAttributeType = atypeENTITY;", "       goto checkAttListDeclHandler;", "     case XML_ROLE_ATTRIBUTE_TYPE_ENTITIES:", "       parser->m_declAttributeType = atypeENTITIES;", "       goto checkAttListDeclHandler;", "     case XML_ROLE_ATTRIBUTE_TYPE_NMTOKEN:", "       parser->m_declAttributeType = atypeNMTOKEN;", "       goto checkAttListDeclHandler;", "     case XML_ROLE_ATTRIBUTE_TYPE_NMTOKENS:", "       parser->m_declAttributeType = atypeNMTOKENS;", "     checkAttListDeclHandler:", "       if (dtd->keepProcessing && parser->m_attlistDeclHandler)", "         handleDefault = XML_FALSE;", "       break;", "     case XML_ROLE_ATTRIBUTE_ENUM_VALUE:", "     case XML_ROLE_ATTRIBUTE_NOTATION_VALUE:", "       if (dtd->keepProcessing && parser->m_attlistDeclHandler) {", "         const XML_Char *prefix;", "         if (parser->m_declAttributeType) {", "           prefix = enumValueSep;", "         } else {", "           prefix = (role == XML_ROLE_ATTRIBUTE_NOTATION_VALUE ? notationPrefix", "                                                               : enumValueStart);", "         }", "         if (! poolAppendString(&parser->m_tempPool, prefix))", "           return XML_ERROR_NO_MEMORY;", "         if (! poolAppend(&parser->m_tempPool, enc, s, next))", "           return XML_ERROR_NO_MEMORY;", "         parser->m_declAttributeType = parser->m_tempPool.start;", "         handleDefault = XML_FALSE;", "       }", "       break;", "     case XML_ROLE_IMPLIED_ATTRIBUTE_VALUE:", "     case XML_ROLE_REQUIRED_ATTRIBUTE_VALUE:", "       if (dtd->keepProcessing) {", "         if (! defineAttribute(parser->m_declElementType,", "                               parser->m_declAttributeId,", "                               parser->m_declAttributeIsCdata,", "                               parser->m_declAttributeIsId, 0, parser))", "           return XML_ERROR_NO_MEMORY;", "         if (parser->m_attlistDeclHandler && parser->m_declAttributeType) {", "           if (*parser->m_declAttributeType == XML_T(ASCII_LPAREN)", "               || (*parser->m_declAttributeType == XML_T(ASCII_N)", "                   && parser->m_declAttributeType[1] == XML_T(ASCII_O))) {", "             if (! poolAppendChar(&parser->m_tempPool, XML_T(ASCII_RPAREN))", "                 || ! poolAppendChar(&parser->m_tempPool, XML_T('\\0')))", "               return XML_ERROR_NO_MEMORY;", "             parser->m_declAttributeType = parser->m_tempPool.start;", "             poolFinish(&parser->m_tempPool);", "           }", "           *eventEndPP = s;", "           parser->m_attlistDeclHandler(", "               parser->m_handlerArg, parser->m_declElementType->name,", "               parser->m_declAttributeId->name, parser->m_declAttributeType, 0,", "               role == XML_ROLE_REQUIRED_ATTRIBUTE_VALUE);", "           poolClear(&parser->m_tempPool);", "           handleDefault = XML_FALSE;", "         }", "       }", "       break;", "     case XML_ROLE_DEFAULT_ATTRIBUTE_VALUE:", "     case XML_ROLE_FIXED_ATTRIBUTE_VALUE:", "       if (dtd->keepProcessing) {", "         const XML_Char *attVal;", "         enum XML_Error result = storeAttributeValue(", "             parser, enc, parser->m_declAttributeIsCdata,", "             s + enc->minBytesPerChar, next - enc->minBytesPerChar, &dtd->pool);", "         if (result)", "           return result;", "         attVal = poolStart(&dtd->pool);", "         poolFinish(&dtd->pool);", "         if (! defineAttribute(", "                 parser->m_declElementType, parser->m_declAttributeId,", "                 parser->m_declAttributeIsCdata, XML_FALSE, attVal, parser))", "           return XML_ERROR_NO_MEMORY;", "         if (parser->m_attlistDeclHandler && parser->m_declAttributeType) {", "           if (*parser->m_declAttributeType == XML_T(ASCII_LPAREN)", "               || (*parser->m_declAttributeType == XML_T(ASCII_N)", "                   && parser->m_declAttributeType[1] == XML_T(ASCII_O))) {", "             if (! poolAppendChar(&parser->m_tempPool, XML_T(ASCII_RPAREN))", "                 || ! poolAppendChar(&parser->m_tempPool, XML_T('\\0')))", "               return XML_ERROR_NO_MEMORY;", "             parser->m_declAttributeType = parser->m_tempPool.start;", "             poolFinish(&parser->m_tempPool);", "           }", "           *eventEndPP = s;", "           parser->m_attlistDeclHandler(", "               parser->m_handlerArg, parser->m_declElementType->name,", "               parser->m_declAttributeId->name, parser->m_declAttributeType,", "               attVal, role == XML_ROLE_FIXED_ATTRIBUTE_VALUE);", "           poolClear(&parser->m_tempPool);", "           handleDefault = XML_FALSE;", "         }", "       }", "       break;", "     case XML_ROLE_ENTITY_VALUE:", "       if (dtd->keepProcessing) {", "         enum XML_Error result = storeEntityValue(", "             parser, enc, s + enc->minBytesPerChar, next - enc->minBytesPerChar);", "         if (parser->m_declEntity) {", "           parser->m_declEntity->textPtr = poolStart(&dtd->entityValuePool);", "           parser->m_declEntity->textLen", "               = (int)(poolLength(&dtd->entityValuePool));", "           poolFinish(&dtd->entityValuePool);", "           if (parser->m_entityDeclHandler) {", "             *eventEndPP = s;", "             parser->m_entityDeclHandler(", "                 parser->m_handlerArg, parser->m_declEntity->name,", "                 parser->m_declEntity->is_param, parser->m_declEntity->textPtr,", "                 parser->m_declEntity->textLen, parser->m_curBase, 0, 0, 0);", "             handleDefault = XML_FALSE;", "           }", "         } else", "           poolDiscard(&dtd->entityValuePool);", "         if (result != XML_ERROR_NONE)", "           return result;", "       }", "       break;", "     case XML_ROLE_DOCTYPE_SYSTEM_ID:", " #ifdef XML_DTD", "       parser->m_useForeignDTD = XML_FALSE;", " #endif  ", "       dtd->hasParamEntityRefs = XML_TRUE;", "       if (parser->m_startDoctypeDeclHandler) {", "         parser->m_doctypeSysid = poolStoreString(&parser->m_tempPool, enc,", "                                                  s + enc->minBytesPerChar,", "                                                  next - enc->minBytesPerChar);", "         if (parser->m_doctypeSysid == NULL)", "           return XML_ERROR_NO_MEMORY;", "         poolFinish(&parser->m_tempPool);", "         handleDefault = XML_FALSE;", "       }", " #ifdef XML_DTD", "       else", "         parser->m_doctypeSysid = externalSubsetName;", " #endif  ", "       if (! dtd->standalone", " #ifdef XML_DTD", "           && ! parser->m_paramEntityParsing", " #endif  ", "           && parser->m_notStandaloneHandler", "           && ! parser->m_notStandaloneHandler(parser->m_handlerArg))", "         return XML_ERROR_NOT_STANDALONE;", " #ifndef XML_DTD", "       break;", " #else   ", "       if (! parser->m_declEntity) {", "         parser->m_declEntity = (ENTITY *)lookup(", "             parser, &dtd->paramEntities, externalSubsetName, sizeof(ENTITY));", "         if (! parser->m_declEntity)", "           return XML_ERROR_NO_MEMORY;", "         parser->m_declEntity->publicId = NULL;", "       }", " #endif  ", "     case XML_ROLE_ENTITY_SYSTEM_ID:", "       if (dtd->keepProcessing && parser->m_declEntity) {", "         parser->m_declEntity->systemId", "             = poolStoreString(&dtd->pool, enc, s + enc->minBytesPerChar,", "                               next - enc->minBytesPerChar);", "         if (! parser->m_declEntity->systemId)", "           return XML_ERROR_NO_MEMORY;", "         parser->m_declEntity->base = parser->m_curBase;", "         poolFinish(&dtd->pool);", "         if (parser->m_entityDeclHandler && role == XML_ROLE_ENTITY_SYSTEM_ID)", "           handleDefault = XML_FALSE;", "       }", "       break;", "     case XML_ROLE_ENTITY_COMPLETE:", "       if (dtd->keepProcessing && parser->m_declEntity", "           && parser->m_entityDeclHandler) {", "         *eventEndPP = s;", "         parser->m_entityDeclHandler(", "             parser->m_handlerArg, parser->m_declEntity->name,", "             parser->m_declEntity->is_param, 0, 0, parser->m_declEntity->base,", "             parser->m_declEntity->systemId, parser->m_declEntity->publicId, 0);", "         handleDefault = XML_FALSE;", "       }", "       break;", "     case XML_ROLE_ENTITY_NOTATION_NAME:", "       if (dtd->keepProcessing && parser->m_declEntity) {", "         parser->m_declEntity->notation", "             = poolStoreString(&dtd->pool, enc, s, next);", "         if (! parser->m_declEntity->notation)", "           return XML_ERROR_NO_MEMORY;", "         poolFinish(&dtd->pool);", "         if (parser->m_unparsedEntityDeclHandler) {", "           *eventEndPP = s;", "           parser->m_unparsedEntityDeclHandler(", "               parser->m_handlerArg, parser->m_declEntity->name,", "               parser->m_declEntity->base, parser->m_declEntity->systemId,", "               parser->m_declEntity->publicId, parser->m_declEntity->notation);", "           handleDefault = XML_FALSE;", "         } else if (parser->m_entityDeclHandler) {", "           *eventEndPP = s;", "           parser->m_entityDeclHandler(", "               parser->m_handlerArg, parser->m_declEntity->name, 0, 0, 0,", "               parser->m_declEntity->base, parser->m_declEntity->systemId,", "               parser->m_declEntity->publicId, parser->m_declEntity->notation);", "           handleDefault = XML_FALSE;", "         }", "       }", "       break;", "     case XML_ROLE_GENERAL_ENTITY_NAME: {", "       if (XmlPredefinedEntityName(enc, s, next)) {", "         parser->m_declEntity = NULL;", "         break;", "       }", "       if (dtd->keepProcessing) {", "         const XML_Char *name = poolStoreString(&dtd->pool, enc, s, next);", "         if (! name)", "           return XML_ERROR_NO_MEMORY;", "         parser->m_declEntity = (ENTITY *)lookup(parser, &dtd->generalEntities,", "                                                 name, sizeof(ENTITY));", "         if (! parser->m_declEntity)", "           return XML_ERROR_NO_MEMORY;", "         if (parser->m_declEntity->name != name) {", "           poolDiscard(&dtd->pool);", "           parser->m_declEntity = NULL;", "         } else {", "           poolFinish(&dtd->pool);", "           parser->m_declEntity->publicId = NULL;", "           parser->m_declEntity->is_param = XML_FALSE;", "           parser->m_declEntity->is_internal", "               = ! (parser->m_parentParser || parser->m_openInternalEntities);", "           if (parser->m_entityDeclHandler)", "             handleDefault = XML_FALSE;", "         }", "       } else {", "         poolDiscard(&dtd->pool);", "         parser->m_declEntity = NULL;", "       }", "     } break;", "     case XML_ROLE_PARAM_ENTITY_NAME:", " #ifdef XML_DTD", "       if (dtd->keepProcessing) {", "         const XML_Char *name = poolStoreString(&dtd->pool, enc, s, next);", "         if (! name)", "           return XML_ERROR_NO_MEMORY;", "         parser->m_declEntity = (ENTITY *)lookup(parser, &dtd->paramEntities,", "                                                 name, sizeof(ENTITY));", "         if (! parser->m_declEntity)", "           return XML_ERROR_NO_MEMORY;", "         if (parser->m_declEntity->name != name) {", "           poolDiscard(&dtd->pool);", "           parser->m_declEntity = NULL;", "         } else {", "           poolFinish(&dtd->pool);", "           parser->m_declEntity->publicId = NULL;", "           parser->m_declEntity->is_param = XML_TRUE;", "           parser->m_declEntity->is_internal", "               = ! (parser->m_parentParser || parser->m_openInternalEntities);", "           if (parser->m_entityDeclHandler)", "             handleDefault = XML_FALSE;", "         }", "       } else {", "         poolDiscard(&dtd->pool);", "         parser->m_declEntity = NULL;", "       }", " #else   ", "       parser->m_declEntity = NULL;", " #endif  ", "       break;", "     case XML_ROLE_NOTATION_NAME:", "       parser->m_declNotationPublicId = NULL;", "       parser->m_declNotationName = NULL;", "       if (parser->m_notationDeclHandler) {", "         parser->m_declNotationName", "             = poolStoreString(&parser->m_tempPool, enc, s, next);", "         if (! parser->m_declNotationName)", "           return XML_ERROR_NO_MEMORY;", "         poolFinish(&parser->m_tempPool);", "         handleDefault = XML_FALSE;", "       }", "       break;", "     case XML_ROLE_NOTATION_PUBLIC_ID:", "       if (! XmlIsPublicId(enc, s, next, eventPP))", "         return XML_ERROR_PUBLICID;", "       if (parser", "               ->m_declNotationName) {  ", "         XML_Char *tem = poolStoreString(&parser->m_tempPool, enc,", "                                         s + enc->minBytesPerChar,", "                                         next - enc->minBytesPerChar);", "         if (! tem)", "           return XML_ERROR_NO_MEMORY;", "         normalizePublicId(tem);", "         parser->m_declNotationPublicId = tem;", "         poolFinish(&parser->m_tempPool);", "         handleDefault = XML_FALSE;", "       }", "       break;", "     case XML_ROLE_NOTATION_SYSTEM_ID:", "       if (parser->m_declNotationName && parser->m_notationDeclHandler) {", "         const XML_Char *systemId = poolStoreString(&parser->m_tempPool, enc,", "                                                    s + enc->minBytesPerChar,", "                                                    next - enc->minBytesPerChar);", "         if (! systemId)", "           return XML_ERROR_NO_MEMORY;", "         *eventEndPP = s;", "         parser->m_notationDeclHandler(", "             parser->m_handlerArg, parser->m_declNotationName, parser->m_curBase,", "             systemId, parser->m_declNotationPublicId);", "         handleDefault = XML_FALSE;", "       }", "       poolClear(&parser->m_tempPool);", "       break;", "     case XML_ROLE_NOTATION_NO_SYSTEM_ID:", "       if (parser->m_declNotationPublicId && parser->m_notationDeclHandler) {", "         *eventEndPP = s;", "         parser->m_notationDeclHandler(", "             parser->m_handlerArg, parser->m_declNotationName, parser->m_curBase,", "             0, parser->m_declNotationPublicId);", "         handleDefault = XML_FALSE;", "       }", "       poolClear(&parser->m_tempPool);", "       break;", "     case XML_ROLE_ERROR:", "       switch (tok) {", "       case XML_TOK_PARAM_ENTITY_REF:", "         return XML_ERROR_PARAM_ENTITY_REF;", "       case XML_TOK_XML_DECL:", "         return XML_ERROR_MISPLACED_XML_PI;", "       default:", "         return XML_ERROR_SYNTAX;", "       }", " #ifdef XML_DTD", "     case XML_ROLE_IGNORE_SECT: {", "       enum XML_Error result;", "       if (parser->m_defaultHandler)", "         reportDefault(parser, enc, s, next);", "       handleDefault = XML_FALSE;", "       result = doIgnoreSection(parser, enc, &next, end, nextPtr, haveMore);", "       if (result != XML_ERROR_NONE)", "         return result;", "       else if (! next) {", "         parser->m_processor = ignoreSectionProcessor;", "         return result;", "       }", "     } break;", " #endif  ", "     case XML_ROLE_GROUP_OPEN:", "       if (parser->m_prologState.level >= parser->m_groupSize) {", "         if (parser->m_groupSize) {", "           {", "             char *const new_connector = (char *)REALLOC(", "                 parser, parser->m_groupConnector, parser->m_groupSize *= 2);", "             if (new_connector == NULL) {", "               parser->m_groupSize /= 2;", "               return XML_ERROR_NO_MEMORY;", "             }", "             parser->m_groupConnector = new_connector;", "           }", "           if (dtd->scaffIndex) {", "             int *const new_scaff_index = (int *)REALLOC(", "                 parser, dtd->scaffIndex, parser->m_groupSize * sizeof(int));", "             if (new_scaff_index == NULL)", "               return XML_ERROR_NO_MEMORY;", "             dtd->scaffIndex = new_scaff_index;", "           }", "         } else {", "           parser->m_groupConnector", "               = (char *)MALLOC(parser, parser->m_groupSize = 32);", "           if (! parser->m_groupConnector) {", "             parser->m_groupSize = 0;", "             return XML_ERROR_NO_MEMORY;", "           }", "         }", "       }", "       parser->m_groupConnector[parser->m_prologState.level] = 0;", "       if (dtd->in_eldecl) {", "         int myindex = nextScaffoldPart(parser);", "         if (myindex < 0)", "           return XML_ERROR_NO_MEMORY;", "         assert(dtd->scaffIndex != NULL);", "         dtd->scaffIndex[dtd->scaffLevel] = myindex;", "         dtd->scaffLevel++;", "         dtd->scaffold[myindex].type = XML_CTYPE_SEQ;", "         if (parser->m_elementDeclHandler)", "           handleDefault = XML_FALSE;", "       }", "       break;", "     case XML_ROLE_GROUP_SEQUENCE:", "       if (parser->m_groupConnector[parser->m_prologState.level] == ASCII_PIPE)", "         return XML_ERROR_SYNTAX;", "       parser->m_groupConnector[parser->m_prologState.level] = ASCII_COMMA;", "       if (dtd->in_eldecl && parser->m_elementDeclHandler)", "         handleDefault = XML_FALSE;", "       break;", "     case XML_ROLE_GROUP_CHOICE:", "       if (parser->m_groupConnector[parser->m_prologState.level] == ASCII_COMMA)", "         return XML_ERROR_SYNTAX;", "       if (dtd->in_eldecl", "           && ! parser->m_groupConnector[parser->m_prologState.level]", "           && (dtd->scaffold[dtd->scaffIndex[dtd->scaffLevel - 1]].type", "               != XML_CTYPE_MIXED)) {", "         dtd->scaffold[dtd->scaffIndex[dtd->scaffLevel - 1]].type", "             = XML_CTYPE_CHOICE;", "         if (parser->m_elementDeclHandler)", "           handleDefault = XML_FALSE;", "       }", "       parser->m_groupConnector[parser->m_prologState.level] = ASCII_PIPE;", "       break;", "     case XML_ROLE_PARAM_ENTITY_REF:", " #ifdef XML_DTD", "     case XML_ROLE_INNER_PARAM_ENTITY_REF:", "       dtd->hasParamEntityRefs = XML_TRUE;", "       if (! parser->m_paramEntityParsing)", "         dtd->keepProcessing = dtd->standalone;", "       else {", "         const XML_Char *name;", "         ENTITY *entity;", "         name = poolStoreString(&dtd->pool, enc, s + enc->minBytesPerChar,", "                                next - enc->minBytesPerChar);", "         if (! name)", "           return XML_ERROR_NO_MEMORY;", "         entity = (ENTITY *)lookup(parser, &dtd->paramEntities, name, 0);", "         poolDiscard(&dtd->pool);", "         if (parser->m_prologState.documentEntity", "             && (dtd->standalone ? ! parser->m_openInternalEntities", "                                 : ! dtd->hasParamEntityRefs)) {", "           if (! entity)", "             return XML_ERROR_UNDEFINED_ENTITY;", "           else if (! entity->is_internal) {", "             return XML_ERROR_ENTITY_DECLARED_IN_PE;  ", "           }", "         } else if (! entity) {", "           dtd->keepProcessing = dtd->standalone;", "           if ((role == XML_ROLE_PARAM_ENTITY_REF)", "               && parser->m_skippedEntityHandler) {", "             parser->m_skippedEntityHandler(parser->m_handlerArg, name, 1);", "             handleDefault = XML_FALSE;", "           }", "           break;", "         }", "         if (entity->open)", "           return XML_ERROR_RECURSIVE_ENTITY_REF;", "         if (entity->textPtr) {", "           enum XML_Error result;", "           XML_Bool betweenDecl", "               = (role == XML_ROLE_PARAM_ENTITY_REF ? XML_TRUE : XML_FALSE);", "           result = processInternalEntity(parser, entity, betweenDecl);", "           if (result != XML_ERROR_NONE)", "             return result;", "           handleDefault = XML_FALSE;", "           break;", "         }", "         if (parser->m_externalEntityRefHandler) {", "           dtd->paramEntityRead = XML_FALSE;", "           entity->open = XML_TRUE;", "           if (! parser->m_externalEntityRefHandler(", "                   parser->m_externalEntityRefHandlerArg, 0, entity->base,", "                   entity->systemId, entity->publicId)) {", "             entity->open = XML_FALSE;", "             return XML_ERROR_EXTERNAL_ENTITY_HANDLING;", "           }", "           entity->open = XML_FALSE;", "           handleDefault = XML_FALSE;", "           if (! dtd->paramEntityRead) {", "             dtd->keepProcessing = dtd->standalone;", "             break;", "           }", "         } else {", "           dtd->keepProcessing = dtd->standalone;", "           break;", "         }", "       }", " #endif  ", "       if (! dtd->standalone && parser->m_notStandaloneHandler", "           && ! parser->m_notStandaloneHandler(parser->m_handlerArg))", "         return XML_ERROR_NOT_STANDALONE;", "       break;", "     case XML_ROLE_ELEMENT_NAME:", "       if (parser->m_elementDeclHandler) {", "         parser->m_declElementType = getElementType(parser, enc, s, next);", "         if (! parser->m_declElementType)", "           return XML_ERROR_NO_MEMORY;", "         dtd->scaffLevel = 0;", "         dtd->scaffCount = 0;", "         dtd->in_eldecl = XML_TRUE;", "         handleDefault = XML_FALSE;", "       }", "       break;", "     case XML_ROLE_CONTENT_ANY:", "     case XML_ROLE_CONTENT_EMPTY:", "       if (dtd->in_eldecl) {", "         if (parser->m_elementDeclHandler) {", "           XML_Content *content", "               = (XML_Content *)MALLOC(parser, sizeof(XML_Content));", "           if (! content)", "             return XML_ERROR_NO_MEMORY;", "           content->quant = XML_CQUANT_NONE;", "           content->name = NULL;", "           content->numchildren = 0;", "           content->children = NULL;", "           content->type = ((role == XML_ROLE_CONTENT_ANY) ? XML_CTYPE_ANY", "                                                           : XML_CTYPE_EMPTY);", "           *eventEndPP = s;", "           parser->m_elementDeclHandler(", "               parser->m_handlerArg, parser->m_declElementType->name, content);", "           handleDefault = XML_FALSE;", "         }", "         dtd->in_eldecl = XML_FALSE;", "       }", "       break;", "     case XML_ROLE_CONTENT_PCDATA:", "       if (dtd->in_eldecl) {", "         dtd->scaffold[dtd->scaffIndex[dtd->scaffLevel - 1]].type", "             = XML_CTYPE_MIXED;", "         if (parser->m_elementDeclHandler)", "           handleDefault = XML_FALSE;", "       }", "       break;", "     case XML_ROLE_CONTENT_ELEMENT:", "       quant = XML_CQUANT_NONE;", "       goto elementContent;", "     case XML_ROLE_CONTENT_ELEMENT_OPT:", "       quant = XML_CQUANT_OPT;", "       goto elementContent;", "     case XML_ROLE_CONTENT_ELEMENT_REP:", "       quant = XML_CQUANT_REP;", "       goto elementContent;", "     case XML_ROLE_CONTENT_ELEMENT_PLUS:", "       quant = XML_CQUANT_PLUS;", "     elementContent:", "       if (dtd->in_eldecl) {", "         ELEMENT_TYPE *el;", "         const XML_Char *name;", "         int nameLen;", "         const char *nxt", "             = (quant == XML_CQUANT_NONE ? next : next - enc->minBytesPerChar);", "         int myindex = nextScaffoldPart(parser);", "         if (myindex < 0)", "           return XML_ERROR_NO_MEMORY;", "         dtd->scaffold[myindex].type = XML_CTYPE_NAME;", "         dtd->scaffold[myindex].quant = quant;", "         el = getElementType(parser, enc, s, nxt);", "         if (! el)", "           return XML_ERROR_NO_MEMORY;", "         name = el->name;", "         dtd->scaffold[myindex].name = name;", "         nameLen = 0;", "         for (; name[nameLen++];)", "           ;", "         dtd->contentStringLen += nameLen;", "         if (parser->m_elementDeclHandler)", "           handleDefault = XML_FALSE;", "       }", "       break;", "     case XML_ROLE_GROUP_CLOSE:", "       quant = XML_CQUANT_NONE;", "       goto closeGroup;", "     case XML_ROLE_GROUP_CLOSE_OPT:", "       quant = XML_CQUANT_OPT;", "       goto closeGroup;", "     case XML_ROLE_GROUP_CLOSE_REP:", "       quant = XML_CQUANT_REP;", "       goto closeGroup;", "     case XML_ROLE_GROUP_CLOSE_PLUS:", "       quant = XML_CQUANT_PLUS;", "     closeGroup:", "       if (dtd->in_eldecl) {", "         if (parser->m_elementDeclHandler)", "           handleDefault = XML_FALSE;", "         dtd->scaffLevel--;", "         dtd->scaffold[dtd->scaffIndex[dtd->scaffLevel]].quant = quant;", "         if (dtd->scaffLevel == 0) {", "           if (! handleDefault) {", "             XML_Content *model = build_model(parser);", "             if (! model)", "               return XML_ERROR_NO_MEMORY;", "             *eventEndPP = s;", "             parser->m_elementDeclHandler(", "                 parser->m_handlerArg, parser->m_declElementType->name, model);", "           }", "           dtd->in_eldecl = XML_FALSE;", "           dtd->contentStringLen = 0;", "         }", "       }", "       break;", "     case XML_ROLE_PI:", "       if (! reportProcessingInstruction(parser, enc, s, next))", "         return XML_ERROR_NO_MEMORY;", "       handleDefault = XML_FALSE;", "       break;", "     case XML_ROLE_COMMENT:", "       if (! reportComment(parser, enc, s, next))", "         return XML_ERROR_NO_MEMORY;", "       handleDefault = XML_FALSE;", "       break;", "     case XML_ROLE_NONE:", "       switch (tok) {", "       case XML_TOK_BOM:", "         handleDefault = XML_FALSE;", "         break;", "       }", "       break;", "     case XML_ROLE_DOCTYPE_NONE:", "       if (parser->m_startDoctypeDeclHandler)", "         handleDefault = XML_FALSE;", "       break;", "     case XML_ROLE_ENTITY_NONE:", "       if (dtd->keepProcessing && parser->m_entityDeclHandler)", "         handleDefault = XML_FALSE;", "       break;", "     case XML_ROLE_NOTATION_NONE:", "       if (parser->m_notationDeclHandler)", "         handleDefault = XML_FALSE;", "       break;", "     case XML_ROLE_ATTLIST_NONE:", "       if (dtd->keepProcessing && parser->m_attlistDeclHandler)", "         handleDefault = XML_FALSE;", "       break;", "     case XML_ROLE_ELEMENT_NONE:", "       if (parser->m_elementDeclHandler)", "         handleDefault = XML_FALSE;", "       break;", "     }  ", "     if (handleDefault && parser->m_defaultHandler)", "       reportDefault(parser, enc, s, next);", "     switch (parser->m_parsingStatus.parsing) {", "     case XML_SUSPENDED:", "       *nextPtr = next;", "       return XML_ERROR_NONE;", "     case XML_FINISHED:", "       return XML_ERROR_ABORTED;", "     default:", "       s = next;", "       tok = XmlPrologTok(enc, s, end, &next);", "     }", "   }", " }"], "ner_tags": [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" GPMF_ERR IsValidSize(GPMF_stream *ms, uint32_t size)  ", "  {", "  \tif (ms)", "  \t{", "\t\tint32_t nestsize = (int32_t)ms->nest_size[ms->nest_level];", " \t\tuint32_t nestsize = (uint32_t)ms->nest_size[ms->nest_level];", "  \t\tif (nestsize == 0 && ms->nest_level == 0)", "  \t\t\tnestsize = ms->buffer_size_longs;", " \t\tif (size + 2 <= nestsize) return GPMF_OK;", " \t}", " \treturn GPMF_ERROR_BAD_STRUCTURE;", " }"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)", " static int read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)", "  {", "      int i, j, v;", "      if (get_bits1(gb)) {", "         if (get_bits_left(gb) < 64*8)", "             return AVERROR_INVALIDDATA;", "          for (i = 0; i < 64; i++) {", "              v = get_bits(gb, 8);", "             j = s->idsp.idct_permutation[ff_zigzag_direct[i]];", "             s->intra_matrix[j]        = v;", "             s->chroma_intra_matrix[j] = v;", "         }", "      }", "      if (get_bits1(gb)) {", "         if (get_bits_left(gb) < 64*8)", "             return AVERROR_INVALIDDATA;", "          for (i = 0; i < 64; i++) {", "              get_bits(gb, 8);", "          }", "      }", "      if (get_bits1(gb)) {", "         if (get_bits_left(gb) < 64*8)", "             return AVERROR_INVALIDDATA;", "          for (i = 0; i < 64; i++) {", "              v = get_bits(gb, 8);", "             j = s->idsp.idct_permutation[ff_zigzag_direct[i]];", "             s->chroma_intra_matrix[j] = v;", "         }", "      }", "      if (get_bits1(gb)) {", "         if (get_bits_left(gb) < 64*8)", "             return AVERROR_INVALIDDATA;", "          for (i = 0; i < 64; i++) {", "              get_bits(gb, 8);", "          }", "      }", "      next_start_code_studio(gb);", "     return 0;", "  }"], "ner_tags": [0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": [" forward_search_range(regex_t* reg, const UChar* str, const UChar* end, UChar* s,", " \t\t     UChar* range, UChar** low, UChar** high, UChar** low_prev)", " {", "   UChar *p, *pprev = (UChar* )NULL;", " #ifdef ONIG_DEBUG_SEARCH", "   fprintf(stderr, \"forward_search_range: str: %d, end: %d, s: %d, range: %d\\n\",", " \t  (int )str, (int )end, (int )s, (int )range);", " #endif", "   p = s;", "   if (reg->dmin > 0) {", "     if (ONIGENC_IS_SINGLEBYTE(reg->enc)) {", "       p += reg->dmin;", "     }", "     else {", "       UChar *q = p + reg->dmin;", "       if (q >= end) return 0;  ", "       while (p < q) p += enclen(reg->enc, p);", "     }", "   }", "  retry:", "   switch (reg->optimize) {", "   case ONIG_OPTIMIZE_EXACT:", "     p = slow_search(reg->enc, reg->exact, reg->exact_end, p, end, range);", "     break;", "   case ONIG_OPTIMIZE_EXACT_IC:", "     p = slow_search_ic(reg->enc, reg->case_fold_flag,", "                        reg->exact, reg->exact_end, p, end, range);", "     break;", "   case ONIG_OPTIMIZE_EXACT_BM:", "     p = bm_search(reg, reg->exact, reg->exact_end, p, end, range);", "     break;", "   case ONIG_OPTIMIZE_EXACT_BM_NOT_REV:", "     p = bm_search_notrev(reg, reg->exact, reg->exact_end, p, end, range);", "     break;", "   case ONIG_OPTIMIZE_MAP:", "     p = map_search(reg->enc, reg->map, p, range);", "     break;", "   }", "   if (p && p < range) {", "     if (p - reg->dmin < s) {", "     retry_gate:", "       pprev = p;", "       p += enclen(reg->enc, p);", "       goto retry;", "     }", "     if (reg->sub_anchor) {", "       UChar* prev;", "       switch (reg->sub_anchor) {", "       case ANCHOR_BEGIN_LINE:", "         if (!ON_STR_BEGIN(p)) {", "           prev = onigenc_get_prev_char_head(reg->enc,", "                                             (pprev ? pprev : str), p);", "           if (!ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))", "             goto retry_gate;", "         }", "         break;", "       case ANCHOR_END_LINE:", "         if (ON_STR_END(p)) {", " #ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE", "           prev = (UChar* )onigenc_get_prev_char_head(reg->enc,", "                                                      (pprev ? pprev : str), p);", "           if (prev && ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))", "             goto retry_gate;", " #endif", "         }", "         else if (! ONIGENC_IS_MBC_NEWLINE(reg->enc, p, end)", " #ifdef USE_CRNL_AS_LINE_TERMINATOR", "                  && ! ONIGENC_IS_MBC_CRNL(reg->enc, p, end)", " #endif", "                  )", "           goto retry_gate;", "         break;", "       }", "     }", "     if (reg->dmax == 0) {", "       *low = p;", "       if (low_prev) {", "         if (*low > s)", "           *low_prev = onigenc_get_prev_char_head(reg->enc, s, p);", "         else", "           *low_prev = onigenc_get_prev_char_head(reg->enc,", "                                                  (pprev ? pprev : str), p);", "       }", "      }", "      else {", "        if (reg->dmax != ONIG_INFINITE_DISTANCE) {", "        *low = p - reg->dmax;", "        if (*low > s) {", "          *low = onigenc_get_right_adjust_char_head_with_prev(reg->enc, s,", "                                          *low, (const UChar** )low_prev);", "          if (low_prev && IS_NULL(*low_prev))", "            *low_prev = onigenc_get_prev_char_head(reg->enc,", "                                                   (pprev ? pprev : s), *low);", "         if (p - str < reg->dmax) {", "           *low = (UChar* )str;", "           if (low_prev)", "             *low_prev = onigenc_get_prev_char_head(reg->enc, str, *low);", "          }", "          else {", "          if (low_prev)", "            *low_prev = onigenc_get_prev_char_head(reg->enc,", "                                                   (pprev ? pprev : str), *low);", "           *low = p - reg->dmax;", "           if (*low > s) {", "             *low = onigenc_get_right_adjust_char_head_with_prev(reg->enc, s,", "                                                  *low, (const UChar** )low_prev);", "             if (low_prev && IS_NULL(*low_prev))", "               *low_prev = onigenc_get_prev_char_head(reg->enc,", "                                                      (pprev ? pprev : s), *low);", "           }", "           else {", "             if (low_prev)", "               *low_prev = onigenc_get_prev_char_head(reg->enc,", "                                                      (pprev ? pprev : str), *low);", "           }", "          }", "        }", "      }", "     *high = p - reg->dmin;", " #ifdef ONIG_DEBUG_SEARCH", "     fprintf(stderr,", "     \"forward_search_range success: low: %d, high: %d, dmin: %d, dmax: %d\\n\",", " \t    (int )(*low - str), (int )(*high - str), reg->dmin, reg->dmax);", " #endif", "     return 1;  ", "   }", "   return 0;  ", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" const char *string_of_NPNVariable(int variable)", " {", "   const char *str;", "   switch (variable) {", " #define _(VAL) case VAL: str = #VAL; break;", " \t_(NPNVxDisplay);", " \t_(NPNVxtAppContext);", " \t_(NPNVnetscapeWindow);", " \t_(NPNVjavascriptEnabledBool);", " \t_(NPNVasdEnabledBool);", " \t_(NPNVisOfflineBool);", " \t_(NPNVserviceManager);", " \t_(NPNVDOMElement);", " \t_(NPNVDOMWindow);", " \t_(NPNVToolkit);", " \t_(NPNVSupportsXEmbedBool);", "  \t_(NPNVWindowNPObject);", "  \t_(NPNVPluginElementNPObject);", "  \t_(NPNVSupportsWindowless);", " \t_(NPNVprivateModeBool);", " \t_(NPNVsupportsAdvancedKeyHandling);", "  #undef _", "    default:", "  \tswitch (variable & 0xff) {", " #define _(VAL, VAR) case VAL: str = #VAR; break", " \t  _(10, NPNVserviceManager);", " \t  _(11, NPNVDOMElement);", " \t  _(12, NPNVDOMWindow);", " \t  _(13, NPNVToolkit);", " #undef _", " \tdefault:", " \t  str = \"<unknown variable>\";", " \t  break;", " \t}", " \tbreak;", "   }", "   return str;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  jas_matrix_t *jas_seq2d_input(FILE *in)", "  {", "  \tjas_matrix_t *matrix;", "\tint i;", "\tint j;", " \tjas_matind_t i;", " \tjas_matind_t j;", "  \tlong x;", "\tint numrows;", "\tint numcols;", "\tint xoff;", "\tint yoff;", "\tif (fscanf(in, \"%d %d\", &xoff, &yoff) != 2)", " \tjas_matind_t numrows;", " \tjas_matind_t numcols;", " \tjas_matind_t xoff;", " \tjas_matind_t yoff;", " \tlong tmp_xoff;", " \tlong tmp_yoff;", " \tlong tmp_numrows;", " \tlong tmp_numcols;", " \tif (fscanf(in, \"%ld %ld\", &tmp_xoff, &tmp_yoff) != 2) {", "  \t\treturn 0;", "\tif (fscanf(in, \"%d %d\", &numcols, &numrows) != 2)", " \t}", " \txoff = tmp_xoff;", " \tyoff = tmp_yoff;", " \tif (fscanf(in, \"%ld %ld\", &tmp_numcols, &tmp_numrows) != 2) {", "  \t\treturn 0;", "\tif (!(matrix = jas_seq2d_create(xoff, yoff, xoff + numcols, yoff + numrows)))", " \t}", " \tnumrows = tmp_numrows;", " \tnumcols = tmp_numcols;", " \tif (!(matrix = jas_seq2d_create(xoff, yoff, xoff + numcols,", " \t  yoff + numrows))) {", "  \t\treturn 0;", " \t}", "  \tif (jas_matrix_numrows(matrix) != numrows ||", "  \t  jas_matrix_numcols(matrix) != numcols) {", " \t\tabort();", " \t}", " \tfor (i = 0; i < jas_matrix_numrows(matrix); i++) {", " \t\tfor (j = 0; j < jas_matrix_numcols(matrix); j++) {", " \t\t\tif (fscanf(in, \"%ld\", &x) != 1) {", " \t\t\t\tjas_matrix_destroy(matrix);", " \t\t\t\treturn 0;", " \t\t\t}", " \t\t\tjas_matrix_set(matrix, i, j, JAS_CAST(jas_seqent_t, x));", " \t\t}", " \t}", " \treturn matrix;", " }"], "ner_tags": [0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void jpc_qmfb_join_colgrp(jpc_fix_t *a, int numrows, int stride,", "   int parity)", " {", " \tint bufsize = JPC_CEILDIVPOW2(numrows, 1);", " \tjpc_fix_t joinbuf[QMFB_JOINBUFSIZE * JPC_QMFB_COLGRPSIZE];", " \tjpc_fix_t *buf = joinbuf;", " \tjpc_fix_t *srcptr;", " \tjpc_fix_t *dstptr;", " \tregister jpc_fix_t *srcptr2;", " \tregister jpc_fix_t *dstptr2;", " \tregister int n;", " \tregister int i;", " \tint hstartcol;", "  \tif (bufsize > QMFB_JOINBUFSIZE) {", "\t\tif (!(buf = jas_alloc3(bufsize, JPC_QMFB_COLGRPSIZE, sizeof(jpc_fix_t)))) {", " \t\tif (!(buf = jas_alloc3(bufsize, JPC_QMFB_COLGRPSIZE,", " \t\t  sizeof(jpc_fix_t)))) {", "  \t\t\tabort();", "  \t\t}", " \t}", " \thstartcol = (numrows + 1 - parity) >> 1;", " \tn = hstartcol;", " \tsrcptr = &a[0];", " \tdstptr = buf;", " \twhile (n-- > 0) {", " \t\tdstptr2 = dstptr;", " \t\tsrcptr2 = srcptr;", " \t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {", " \t\t\t*dstptr2 = *srcptr2;", " \t\t\t++dstptr2;", " \t\t\t++srcptr2;", " \t\t}", " \t\tsrcptr += stride;", " \t\tdstptr += JPC_QMFB_COLGRPSIZE;", " \t}", " \tsrcptr = &a[hstartcol * stride];", " \tdstptr = &a[(1 - parity) * stride];", " \tn = numrows - hstartcol;", " \twhile (n-- > 0) {", " \t\tdstptr2 = dstptr;", " \t\tsrcptr2 = srcptr;", " \t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {", " \t\t\t*dstptr2 = *srcptr2;", " \t\t\t++dstptr2;", " \t\t\t++srcptr2;", " \t\t}", " \t\tdstptr += 2 * stride;", " \t\tsrcptr += stride;", " \t}", " \tsrcptr = buf;", " \tdstptr = &a[parity * stride];", " \tn = hstartcol;", " \twhile (n-- > 0) {", " \t\tdstptr2 = dstptr;", " \t\tsrcptr2 = srcptr;", " \t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {", " \t\t\t*dstptr2 = *srcptr2;", " \t\t\t++dstptr2;", " \t\t\t++srcptr2;", " \t\t}", " \t\tdstptr += 2 * stride;", " \t\tsrcptr += JPC_QMFB_COLGRPSIZE;", " \t}", " \tif (buf != joinbuf) {", " \t\tjas_free(buf);", " \t}", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int main(int argc, char *argv[])", " {", "     time_t timep;", "     struct tm *timeptr;", "     char *now;", "     if (argc < 3) {", "         send_error(1);", "         return -1;", "     } else if (argc > 3) {", "         send_error(5);", "         return -1;", "     }", "     build_needs_escape();", "     if (argv[2] == NULL)", "         index_directory(argv[1], argv[1]);", "     else", "         index_directory(argv[1], argv[2]);", "     time(&timep);", " #ifdef USE_LOCALTIME", "     timeptr = localtime(&timep);", " #else", "      timeptr = gmtime(&timep);", "  #endif", "      now = strdup(asctime(timeptr));", " \tif (!now) {", " \t\treturn -1;", " \t}", "      now[strlen(now) - 1] = '\\0';", "  #ifdef USE_LOCALTIME", "      printf(\"</table>\\n<hr noshade>\\nIndex generated %s %s\\n\"", "            \"<!-- This program is part of the Boa Webserver Copyright (C) 1991-2002 http:www.boa.org -->\\n\"", "            \"</body>\\n</html>\\n\", now, TIMEZONE(timeptr));", " #else", "     printf(\"</table>\\n<hr noshade>\\nIndex generated %s UTC\\n\"", "             \"<!-- This program is part of the Boa Webserver Copyright (C) 1991-2002 http:www.boa.org -->\\n\"", "             \"</body>\\n</html>\\n\", now);", "  #endif", " \tfree(now);", "      return 0;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": [" static int asn1_decode_entry(sc_context_t *ctx,struct sc_asn1_entry *entry,", " \t\t\t     const u8 *obj, size_t objlen, int depth)", " {", " \tvoid *parm = entry->parm;", " \tint (*callback_func)(sc_context_t *nctx, void *arg, const u8 *nobj,", " \t\t\t     size_t nobjlen, int ndepth);", " \tsize_t *len = (size_t *) entry->arg;", " \tint r = 0;", " \tcallback_func = parm;", " \tsc_debug(ctx, SC_LOG_DEBUG_ASN1, \"%*.*sdecoding '%s', raw data:%s%s\\n\",", " \t\tdepth, depth, \"\", entry->name,", " \t\tsc_dump_hex(obj, objlen > 16  ? 16 : objlen),", " \t\tobjlen > 16 ? \"...\" : \"\");", " \tswitch (entry->type) {", " \tcase SC_ASN1_STRUCT:", " \t\tif (parm != NULL)", " \t\t\tr = asn1_decode(ctx, (struct sc_asn1_entry *) parm, obj,", " \t\t\t\t       objlen, NULL, NULL, 0, depth + 1);", " \t\tbreak;", " \tcase SC_ASN1_NULL:", " \t\tbreak;", " \tcase SC_ASN1_BOOLEAN:", " \t\tif (parm != NULL) {", " \t\t\tif (objlen != 1) {", " \t\t\t\tsc_debug(ctx, SC_LOG_DEBUG_ASN1,", " \t\t\t\t\t \"invalid ASN.1 object length: %\"SC_FORMAT_LEN_SIZE_T\"u\\n\",", " \t\t\t\t\t objlen);", " \t\t\t\tr = SC_ERROR_INVALID_ASN1_OBJECT;", " \t\t\t} else", " \t\t\t\t*((int *) parm) = obj[0] ? 1 : 0;", " \t\t}", " \t\tbreak;", " \tcase SC_ASN1_INTEGER:", " \tcase SC_ASN1_ENUMERATED:", " \t\tif (parm != NULL) {", " \t\t\tr = sc_asn1_decode_integer(obj, objlen, (int *) entry->parm);", " \t\t\tsc_debug(ctx, SC_LOG_DEBUG_ASN1, \"%*.*sdecoding '%s' returned %d\\n\", depth, depth, \"\",", " \t\t\t\t\tentry->name, *((int *) entry->parm));", " \t\t}", " \t\tbreak;", " \tcase SC_ASN1_BIT_STRING_NI:", " \tcase SC_ASN1_BIT_STRING:", " \t\tif (parm != NULL) {", " \t\t\tint invert = entry->type == SC_ASN1_BIT_STRING ? 1 : 0;", " \t\t\tassert(len != NULL);", " \t\t\tif (objlen < 1) {", " \t\t\t\tr = SC_ERROR_INVALID_ASN1_OBJECT;", " \t\t\t\tbreak;", " \t\t\t}", " \t\t\tif (entry->flags & SC_ASN1_ALLOC) {", " \t\t\t\tu8 **buf = (u8 **) parm;", " \t\t\t\t*buf = malloc(objlen-1);", " \t\t\t\tif (*buf == NULL) {", " \t\t\t\t\tr = SC_ERROR_OUT_OF_MEMORY;", " \t\t\t\t\tbreak;", " \t\t\t\t}", " \t\t\t\t*len = objlen-1;", " \t\t\t\tparm = *buf;", " \t\t\t}", " \t\t\tr = decode_bit_string(obj, objlen, (u8 *) parm, *len, invert);", " \t\t\tif (r >= 0) {", " \t\t\t\t*len = r;", " \t\t\t\tr = 0;", " \t\t\t}", " \t\t}", " \t\tbreak;", " \tcase SC_ASN1_BIT_FIELD:", " \t\tif (parm != NULL)", " \t\t\tr = decode_bit_field(obj, objlen, (u8 *) parm, *len);", " \t\tbreak;", " \tcase SC_ASN1_OCTET_STRING:", " \t\tif (parm != NULL) {", " \t\t\tsize_t c;", " \t\t\tassert(len != NULL);", "  \t\t\tif ((entry->flags & SC_ASN1_UNSIGNED)", "\t\t\t && obj[0] == 0x00 && objlen > 1) {", " \t\t\t\t\t&& objlen > 1 && obj[0] == 0x00) {", "  \t\t\t\tobjlen--;", "  \t\t\t\tobj++;", "  \t\t\t}", " \t\t\tif (entry->flags & SC_ASN1_ALLOC) {", " \t\t\t\tu8 **buf = (u8 **) parm;", " \t\t\t\t*buf = malloc(objlen);", " \t\t\t\tif (*buf == NULL) {", " \t\t\t\t\tr = SC_ERROR_OUT_OF_MEMORY;", " \t\t\t\t\tbreak;", " \t\t\t\t}", " \t\t\t\tc = *len = objlen;", " \t\t\t\tparm = *buf;", " \t\t\t} else", " \t\t\t\tc = objlen > *len ? *len : objlen;", " \t\t\tmemcpy(parm, obj, c);", " \t\t\t*len = c;", " \t\t}", " \t\tbreak;", " \tcase SC_ASN1_GENERALIZEDTIME:", " \t\tif (parm != NULL) {", " \t\t\tsize_t c;", " \t\t\tassert(len != NULL);", " \t\t\tif (entry->flags & SC_ASN1_ALLOC) {", " \t\t\t\tu8 **buf = (u8 **) parm;", " \t\t\t\t*buf = malloc(objlen);", " \t\t\t\tif (*buf == NULL) {", " \t\t\t\t\tr = SC_ERROR_OUT_OF_MEMORY;", " \t\t\t\t\tbreak;", " \t\t\t\t}", " \t\t\t\tc = *len = objlen;", " \t\t\t\tparm = *buf;", " \t\t\t} else", " \t\t\t\tc = objlen > *len ? *len : objlen;", " \t\t\tmemcpy(parm, obj, c);", " \t\t\t*len = c;", " \t\t}", " \t\tbreak;", " \tcase SC_ASN1_OBJECT:", " \t\tif (parm != NULL)", " \t\t\tr = sc_asn1_decode_object_id(obj, objlen, (struct sc_object_id *) parm);", " \t\tbreak;", " \tcase SC_ASN1_PRINTABLESTRING:", " \tcase SC_ASN1_UTF8STRING:", " \t\tif (parm != NULL) {", " \t\t\tassert(len != NULL);", " \t\t\tif (entry->flags & SC_ASN1_ALLOC) {", " \t\t\t\tu8 **buf = (u8 **) parm;", " \t\t\t\t*buf = malloc(objlen+1);", " \t\t\t\tif (*buf == NULL) {", " \t\t\t\t\tr = SC_ERROR_OUT_OF_MEMORY;", " \t\t\t\t\tbreak;", " \t\t\t\t}", " \t\t\t\t*len = objlen+1;", " \t\t\t\tparm = *buf;", " \t\t\t}", " \t\t\tr = sc_asn1_decode_utf8string(obj, objlen, (u8 *) parm, len);", " \t\t\tif (entry->flags & SC_ASN1_ALLOC) {", " \t\t\t\t*len -= 1;", " \t\t\t}", " \t\t}", " \t\tbreak;", " \tcase SC_ASN1_PATH:", " \t\tif (entry->parm != NULL)", " \t\t\tr = asn1_decode_path(ctx, obj, objlen, (sc_path_t *) parm, depth);", " \t\tbreak;", " \tcase SC_ASN1_PKCS15_ID:", " \t\tif (entry->parm != NULL) {", " \t\t\tstruct sc_pkcs15_id *id = (struct sc_pkcs15_id *) parm;", " \t\t\tsize_t c = objlen > sizeof(id->value) ? sizeof(id->value) : objlen;", " \t\t\tmemcpy(id->value, obj, c);", " \t\t\tid->len = c;", " \t\t}", " \t\tbreak;", " \tcase SC_ASN1_PKCS15_OBJECT:", " \t\tif (entry->parm != NULL)", " \t\t\tr = asn1_decode_p15_object(ctx, obj, objlen, (struct sc_asn1_pkcs15_object *) parm, depth);", " \t\tbreak;", " \tcase SC_ASN1_ALGORITHM_ID:", " \t\tif (entry->parm != NULL)", " \t\t\tr = sc_asn1_decode_algorithm_id(ctx, obj, objlen, (struct sc_algorithm_id *) parm, depth);", " \t\tbreak;", " \tcase SC_ASN1_SE_INFO:", " \t\tif (entry->parm != NULL)", " \t\t\tr = asn1_decode_se_info(ctx, obj, objlen, (sc_pkcs15_sec_env_info_t ***)entry->parm, len, depth);", " \t\tbreak;", " \tcase SC_ASN1_CALLBACK:", " \t\tif (entry->parm != NULL)", " \t\t\tr = callback_func(ctx, entry->arg, obj, objlen, depth);", " \t\tbreak;", " \tdefault:", " \t\tsc_debug(ctx, SC_LOG_DEBUG_ASN1, \"invalid ASN.1 type: %d\\n\", entry->type);", " \t\treturn SC_ERROR_INVALID_ASN1_OBJECT;", " \t}", " \tif (r) {", " \t\tsc_debug(ctx, SC_LOG_DEBUG_ASN1, \"decoding of ASN.1 object '%s' failed: %s\\n\", entry->name,", " \t\t      sc_strerror(r));", " \t\treturn r;", " \t}", " \tentry->flags |= SC_ASN1_PRESENT;", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  void *jas_malloc(size_t size)", "  {", "  \tvoid *result;", "\tJAS_DBGLOG(101, (\"jas_malloc called with %zu\\n\", size));", " \tJAS_DBGLOG(101, (\"jas_malloc(%zu)\\n\", size));", "  \tresult = malloc(size);", "  \tJAS_DBGLOG(100, (\"jas_malloc(%zu) -> %p\\n\", size, result));", "  \treturn result;", " }"], "ner_tags": [0, 0, 0, 1, 1, 0, 0, 0, 0]}
{"tokens": ["  static void numtostr(js_State *J, const char *fmt, int w, double n)", "  {", "\tchar buf[32], *e;", " \tchar buf[50], *e;", "  \tsprintf(buf, fmt, w, n);", "  \te = strchr(buf, 'e');", "  \tif (e) {", " \t\tint exp = atoi(e+1);", " \t\tsprintf(e, \"e%+d\", exp);", " \t}", " \tjs_pushstring(J, buf);", " }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int decode_nal_unit(HEVCContext *s, const H2645NAL *nal)", " {", "     HEVCLocalContext *lc = s->HEVClc;", "     GetBitContext *gb    = &lc->gb;", "     int ctb_addr_ts, ret;", "     *gb              = nal->gb;", "     s->nal_unit_type = nal->type;", "     s->temporal_id   = nal->temporal_id;", "     switch (s->nal_unit_type) {", "     case HEVC_NAL_VPS:", "         if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {", "             ret = s->avctx->hwaccel->decode_params(s->avctx,", "                                                    nal->type,", "                                                    nal->raw_data,", "                                                    nal->raw_size);", "             if (ret < 0)", "                 goto fail;", "         }", "         ret = ff_hevc_decode_nal_vps(gb, s->avctx, &s->ps);", "         if (ret < 0)", "             goto fail;", "         break;", "     case HEVC_NAL_SPS:", "         if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {", "             ret = s->avctx->hwaccel->decode_params(s->avctx,", "                                                    nal->type,", "                                                    nal->raw_data,", "                                                    nal->raw_size);", "             if (ret < 0)", "                 goto fail;", "         }", "         ret = ff_hevc_decode_nal_sps(gb, s->avctx, &s->ps,", "                                      s->apply_defdispwin);", "         if (ret < 0)", "             goto fail;", "         break;", "     case HEVC_NAL_PPS:", "         if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {", "             ret = s->avctx->hwaccel->decode_params(s->avctx,", "                                                    nal->type,", "                                                    nal->raw_data,", "                                                    nal->raw_size);", "             if (ret < 0)", "                 goto fail;", "         }", "         ret = ff_hevc_decode_nal_pps(gb, s->avctx, &s->ps);", "         if (ret < 0)", "             goto fail;", "         break;", "     case HEVC_NAL_SEI_PREFIX:", "     case HEVC_NAL_SEI_SUFFIX:", "         if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {", "             ret = s->avctx->hwaccel->decode_params(s->avctx,", "                                                    nal->type,", "                                                    nal->raw_data,", "                                                    nal->raw_size);", "             if (ret < 0)", "                 goto fail;", "         }", "         ret = ff_hevc_decode_nal_sei(gb, s->avctx, &s->sei, &s->ps, s->nal_unit_type);", "         if (ret < 0)", "             goto fail;", "         break;", "     case HEVC_NAL_TRAIL_R:", "     case HEVC_NAL_TRAIL_N:", "     case HEVC_NAL_TSA_N:", "     case HEVC_NAL_TSA_R:", "     case HEVC_NAL_STSA_N:", "     case HEVC_NAL_STSA_R:", "     case HEVC_NAL_BLA_W_LP:", "     case HEVC_NAL_BLA_W_RADL:", "     case HEVC_NAL_BLA_N_LP:", "     case HEVC_NAL_IDR_W_RADL:", "     case HEVC_NAL_IDR_N_LP:", "     case HEVC_NAL_CRA_NUT:", "     case HEVC_NAL_RADL_N:", "     case HEVC_NAL_RADL_R:", "     case HEVC_NAL_RASL_N:", "     case HEVC_NAL_RASL_R:", "          ret = hls_slice_header(s);", "          if (ret < 0)", "              return ret;", "         if (ret == 1) {", "             ret = AVERROR_INVALIDDATA;", "             goto fail;", "         }", "          if (", "              (s->avctx->skip_frame >= AVDISCARD_BIDIR && s->sh.slice_type == HEVC_SLICE_B) ||", "             (s->avctx->skip_frame >= AVDISCARD_NONINTRA && s->sh.slice_type != HEVC_SLICE_I) ||", "             (s->avctx->skip_frame >= AVDISCARD_NONKEY && !IS_IRAP(s))) {", "             break;", "          }", "          if (s->sh.first_slice_in_pic_flag) {", "            if (s->ref) {", "                av_log(s->avctx, AV_LOG_ERROR, \"Two slices reporting being the first in the same frame.\\n\");", "                goto fail;", "            }", "              if (s->max_ra == INT_MAX) {", "                  if (s->nal_unit_type == HEVC_NAL_CRA_NUT || IS_BLA(s)) {", "                      s->max_ra = s->poc;", "                 } else {", "                     if (IS_IDR(s))", "                         s->max_ra = INT_MIN;", "                 }", "             }", "             if ((s->nal_unit_type == HEVC_NAL_RASL_R || s->nal_unit_type == HEVC_NAL_RASL_N) &&", "                 s->poc <= s->max_ra) {", "                 s->is_decoded = 0;", "                 break;", "             } else {", "                 if (s->nal_unit_type == HEVC_NAL_RASL_R && s->poc > s->max_ra)", "                     s->max_ra = INT_MIN;", "             }", "             s->overlap ++;", "             ret = hevc_frame_start(s);", "             if (ret < 0)", "                 return ret;", "         } else if (!s->ref) {", "             av_log(s->avctx, AV_LOG_ERROR, \"First slice in a frame missing.\\n\");", "             goto fail;", "         }", "         if (s->nal_unit_type != s->first_nal_type) {", "             av_log(s->avctx, AV_LOG_ERROR,", "                    \"Non-matching NAL types of the VCL NALUs: %d %d\\n\",", "                    s->first_nal_type, s->nal_unit_type);", "             return AVERROR_INVALIDDATA;", "         }", "         if (!s->sh.dependent_slice_segment_flag &&", "             s->sh.slice_type != HEVC_SLICE_I) {", "             ret = ff_hevc_slice_rpl(s);", "             if (ret < 0) {", "                 av_log(s->avctx, AV_LOG_WARNING,", "                        \"Error constructing the reference lists for the current slice.\\n\");", "                 goto fail;", "             }", "         }", "         if (s->sh.first_slice_in_pic_flag && s->avctx->hwaccel) {", "             ret = s->avctx->hwaccel->start_frame(s->avctx, NULL, 0);", "             if (ret < 0)", "                 goto fail;", "         }", "         if (s->avctx->hwaccel) {", "             ret = s->avctx->hwaccel->decode_slice(s->avctx, nal->raw_data, nal->raw_size);", "             if (ret < 0)", "                 goto fail;", "         } else {", "             if (s->threads_number > 1 && s->sh.num_entry_point_offsets > 0)", "                 ctb_addr_ts = hls_slice_data_wpp(s, nal);", "             else", "                 ctb_addr_ts = hls_slice_data(s);", "             if (ctb_addr_ts >= (s->ps.sps->ctb_width * s->ps.sps->ctb_height)) {", "                 s->is_decoded = 1;", "             }", "             if (ctb_addr_ts < 0) {", "                 ret = ctb_addr_ts;", "                 goto fail;", "             }", "         }", "         break;", "     case HEVC_NAL_EOS_NUT:", "     case HEVC_NAL_EOB_NUT:", "         s->seq_decode = (s->seq_decode + 1) & 0xff;", "         s->max_ra     = INT_MAX;", "         break;", "     case HEVC_NAL_AUD:", "     case HEVC_NAL_FD_NUT:", "         break;", "     default:", "         av_log(s->avctx, AV_LOG_INFO,", "                \"Skipping NAL unit %d\\n\", s->nal_unit_type);", "     }", "     return 0;", " fail:", "     if (s->avctx->err_recognition & AV_EF_EXPLODE)", "         return ret;", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int decode_frame(AVCodecContext *avctx,", "                         void *data, int *got_frame,", "                         AVPacket *avpkt)", " {", "     PicContext *s = avctx->priv_data;", "     AVFrame *frame = data;", "     uint32_t *palette;", "     int bits_per_plane, bpp, etype, esize, npal, pos_after_pal;", "     int i, x, y, plane, tmp, ret, val;", "     bytestream2_init(&s->g, avpkt->data, avpkt->size);", "     if (bytestream2_get_bytes_left(&s->g) < 11)", "         return AVERROR_INVALIDDATA;", "     if (bytestream2_get_le16u(&s->g) != 0x1234)", "         return AVERROR_INVALIDDATA;", "     s->width       = bytestream2_get_le16u(&s->g);", "     s->height      = bytestream2_get_le16u(&s->g);", "     bytestream2_skip(&s->g, 4);", "     tmp            = bytestream2_get_byteu(&s->g);", "     bits_per_plane = tmp & 0xF;", "     s->nb_planes   = (tmp >> 4) + 1;", "     bpp            = bits_per_plane * s->nb_planes;", "     if (bits_per_plane > 8 || bpp < 1 || bpp > 32) {", "         avpriv_request_sample(avctx, \"Unsupported bit depth\");", "         return AVERROR_PATCHWELCOME;", "     }", "     if (bytestream2_peek_byte(&s->g) == 0xFF || bpp == 1 || bpp == 4 || bpp == 8) {", "         bytestream2_skip(&s->g, 2);", "         etype = bytestream2_get_le16(&s->g);", "         esize = bytestream2_get_le16(&s->g);", "         if (bytestream2_get_bytes_left(&s->g) < esize)", "             return AVERROR_INVALIDDATA;", "     } else {", "         etype = -1;", "         esize = 0;", "     }", "     avctx->pix_fmt = AV_PIX_FMT_PAL8;", "      if (av_image_check_size(s->width, s->height, 0, avctx) < 0)", "          return -1;", "    if (s->width != avctx->width && s->height != avctx->height) {", "     if (s->width != avctx->width || s->height != avctx->height) {", "          ret = ff_set_dimensions(avctx, s->width, s->height);", "          if (ret < 0)", "              return ret;", "     }", "     if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)", "         return ret;", "     memset(frame->data[0], 0, s->height * frame->linesize[0]);", "     frame->pict_type           = AV_PICTURE_TYPE_I;", "     frame->palette_has_changed = 1;", "     pos_after_pal = bytestream2_tell(&s->g) + esize;", "     palette = (uint32_t*)frame->data[1];", "     if (etype == 1 && esize > 1 && bytestream2_peek_byte(&s->g) < 6) {", "         int idx = bytestream2_get_byte(&s->g);", "         npal = 4;", "         for (i = 0; i < npal; i++)", "             palette[i] = ff_cga_palette[ cga_mode45_index[idx][i] ];", "     } else if (etype == 2) {", "         npal = FFMIN(esize, 16);", "         for (i = 0; i < npal; i++) {", "             int pal_idx = bytestream2_get_byte(&s->g);", "             palette[i]  = ff_cga_palette[FFMIN(pal_idx, 15)];", "         }", "     } else if (etype == 3) {", "         npal = FFMIN(esize, 16);", "         for (i = 0; i < npal; i++) {", "             int pal_idx = bytestream2_get_byte(&s->g);", "             palette[i]  = ff_ega_palette[FFMIN(pal_idx, 63)];", "         }", "     } else if (etype == 4 || etype == 5) {", "         npal = FFMIN(esize / 3, 256);", "         for (i = 0; i < npal; i++) {", "             palette[i] = bytestream2_get_be24(&s->g) << 2;", "             palette[i] |= 0xFFU << 24 | palette[i] >> 6 & 0x30303;", "         }", "     } else {", "         if (bpp == 1) {", "             npal = 2;", "             palette[0] = 0xFF000000;", "             palette[1] = 0xFFFFFFFF;", "         } else if (bpp == 2) {", "             npal = 4;", "             for (i = 0; i < npal; i++)", "                 palette[i] = ff_cga_palette[ cga_mode45_index[0][i] ];", "         } else {", "             npal = 16;", "             memcpy(palette, ff_cga_palette, npal * 4);", "         }", "     }", "     memset(palette + npal, 0, AVPALETTE_SIZE - npal * 4);", "     bytestream2_seek(&s->g, pos_after_pal, SEEK_SET);", "     val = 0;", "     y = s->height - 1;", "     if (bytestream2_get_le16(&s->g)) {", "         x = 0;", "         plane = 0;", "         while (bytestream2_get_bytes_left(&s->g) >= 6) {", "             int stop_size, marker, t1, t2;", "             t1        = bytestream2_get_bytes_left(&s->g);", "             t2        = bytestream2_get_le16(&s->g);", "             stop_size = t1 - FFMIN(t1, t2);", "             bytestream2_skip(&s->g, 2);", "             marker    = bytestream2_get_byte(&s->g);", "             while (plane < s->nb_planes &&", "                    bytestream2_get_bytes_left(&s->g) > stop_size) {", "                 int run = 1;", "                 val = bytestream2_get_byte(&s->g);", "                 if (val == marker) {", "                     run = bytestream2_get_byte(&s->g);", "                     if (run == 0)", "                         run = bytestream2_get_le16(&s->g);", "                     val = bytestream2_get_byte(&s->g);", "                 }", "                 if (!bytestream2_get_bytes_left(&s->g))", "                     break;", "                 if (bits_per_plane == 8) {", "                     picmemset_8bpp(s, frame, val, run, &x, &y);", "                     if (y < 0)", "                         goto finish;", "                 } else {", "                     picmemset(s, frame, val, run, &x, &y, &plane, bits_per_plane);", "                 }", "             }", "         }", "         if (x < avctx->width) {", "             int run = (y + 1) * avctx->width - x;", "             if (bits_per_plane == 8)", "                 picmemset_8bpp(s, frame, val, run, &x, &y);", "             else", "                 picmemset(s, frame, val, run / (8 / bits_per_plane), &x, &y, &plane, bits_per_plane);", "         }", "     } else {", "         while (y >= 0 && bytestream2_get_bytes_left(&s->g) > 0) {", "             memcpy(frame->data[0] + y * frame->linesize[0], s->g.buffer, FFMIN(avctx->width, bytestream2_get_bytes_left(&s->g)));", "             bytestream2_skip(&s->g, avctx->width);", "             y--;", "         }", "     }", " finish:", "     *got_frame      = 1;", "     return avpkt->size;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void user_login(struct mt_connection *curconn, struct mt_mactelnet_hdr *pkthdr) {", " \tstruct mt_packet pdata;", " \tunsigned char md5sum[17];", "  \tchar md5data[100];", "  \tstruct mt_credentials *user;", "  \tchar *slavename;", " \tint act_pass_len;", "  \tread_userfile();", " \tif ((user = find_user(curconn->username)) != NULL) {", " \t\tmd5_state_t state;", " #if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)", " \t\tmlock(md5data, sizeof(md5data));", " \t\tmlock(md5sum, sizeof(md5sum));", " \t\tif (user->password != NULL) {", " \t\t\tmlock(user->password, strlen(user->password));", "  \t\t}", "  #endif", " \t\tact_pass_len = strlen(user->password);", " \t\tact_pass_len = act_pass_len <= 82 ? act_pass_len : 82;", "  \t\tmd5data[0] = 0;", "\t\tstrncpy(md5data + 1, user->password, 82);", "\t\tmemcpy(md5data + 1 + strlen(user->password), curconn->pass_salt, 16);", " \t\tmemcpy(md5data + 1, user->password, act_pass_len);", " \t\tmemcpy(md5data + 1 + act_pass_len, curconn->pass_salt, 16);", "  \t\tmd5_init(&state);", "\t\tmd5_append(&state, (const md5_byte_t *)md5data, strlen(user->password) + 17);", " \t\tmd5_append(&state, (const md5_byte_t *)md5data, 1 + act_pass_len + 16);", "  \t\tmd5_finish(&state, (md5_byte_t *)md5sum + 1);", "  \t\tmd5sum[0] = 0;", " \t\tinit_packet(&pdata, MT_PTYPE_DATA, pkthdr->dstaddr, pkthdr->srcaddr, pkthdr->seskey, curconn->outcounter);", " \t\tcurconn->outcounter += add_control_packet(&pdata, MT_CPTYPE_END_AUTH, NULL, 0);", " \t\tsend_udp(curconn, &pdata);", " \t\tif (curconn->state == STATE_ACTIVE) {", " \t\t\treturn;", " \t\t}", " \t}", " \tif (user == NULL || memcmp(md5sum, curconn->trypassword, 17) != 0) {", " \t\tsyslog(LOG_NOTICE, _(\"(%d) Invalid login by %s.\"), curconn->seskey, curconn->username);", " \t\tabort_connection(curconn, pkthdr, _(\"Login failed, incorrect username or password\\r\\n\"));", " \t\treturn;", " \t}", " \tcurconn->state = STATE_ACTIVE;", " \tcurconn->terminal_mode = 1;", " \tcurconn->ptsfd = posix_openpt(O_RDWR);", " \tif (curconn->ptsfd == -1 || grantpt(curconn->ptsfd) == -1 || unlockpt(curconn->ptsfd) == -1) {", " \t\t\tsyslog(LOG_ERR, \"posix_openpt: %s\", strerror(errno));", " \t\t\tabort_connection(curconn, pkthdr, _(\"Terminal error\\r\\n\"));", " \t\t\treturn;", " \t}", " \tslavename = ptsname(curconn->ptsfd);", " \tif (slavename != NULL) {", " \t\tpid_t pid;", " \t\tstruct stat sb;", " \t\tstruct passwd *user = (struct passwd *)malloc(sizeof(struct passwd));", " \t\tstruct passwd *tmpuser=user;", " \t\tchar *buffer = malloc(1024);", " \t\tif (user == NULL || buffer == NULL) {", " \t\t\tsyslog(LOG_CRIT, _(\"(%d) Error allocating memory.\"), curconn->seskey);", " \t\t\tabort_connection(curconn, pkthdr, _(\"System error, out of memory\\r\\n\"));", " \t\t\treturn;", " \t\t}", " \t\tif (getpwnam_r(curconn->username, user, buffer, 1024, &tmpuser) != 0) {", " \t\t\tsyslog(LOG_WARNING, _(\"(%d) Login ok, but local user not accessible (%s).\"), curconn->seskey, curconn->username);", " \t\t\tabort_connection(curconn, pkthdr, _(\"Local user not accessible\\r\\n\"));", " \t\t\tfree(user);", " \t\t\tfree(buffer);", " \t\t\treturn;", " \t\t}", " \t\tchown(slavename, user->pw_uid, user->pw_gid);", " \t\tcurconn->slavefd = open(slavename, O_RDWR);", " \t\tif (curconn->slavefd == -1) {", " \t\t\tsyslog(LOG_ERR, _(\"Error opening %s: %s\"), slavename, strerror(errno));", " \t\t\tabort_connection(curconn, pkthdr, _(\"Error opening terminal\\r\\n\"));", " \t\t\tlist_remove_connection(curconn);", " \t\t\treturn;", " \t\t}", " \t\tif ((pid = fork()) == 0) {", " \t\t\tstruct net_interface *interface;", " \t\t\tuwtmp_login(curconn);", " \t\t\tsyslog(LOG_INFO, _(\"(%d) User %s logged in.\"), curconn->seskey, curconn->username);", " \t\t\tsetenv(\"USER\", user->pw_name, 1);", " \t\t\tsetenv(\"HOME\", user->pw_dir, 1);", " \t\t\tsetenv(\"SHELL\", user->pw_shell, 1);", " \t\t\tsetenv(\"TERM\", curconn->terminal_type, 1);", " \t\t\tclose(sockfd);", " \t\t\tclose(insockfd);", " \t\t\tDL_FOREACH(interfaces, interface) {", " \t\t\t\tif (interface->socketfd > 0) {", " \t\t\t\t\tclose(interface->socketfd);", " \t\t\t\t}", " \t\t\t}", " \t\t\tsetsid();", " \t\t\tfcntl (curconn->slavefd, F_SETFD, FD_CLOEXEC);", " \t\t\tclose(curconn->ptsfd);", " \t\t\tclose(0);", " \t\t\tdup(curconn->slavefd);", " \t\t\tclose(1);", " \t\t\tdup(curconn->slavefd);", " \t\t\tclose(2);", " \t\t\tdup(curconn->slavefd);", " \t\t\tioctl(0, TIOCSCTTY, 1);", " \t\t\ttcsetpgrp(0, getpid());", " \t\t\tif ((setgid(user->pw_gid) != 0) || (setuid(user->pw_uid) != 0)) {", " \t\t\t\tsyslog(LOG_ERR, _(\"(%d) Could not log in %s (%d:%d): setuid/setgid: %s\"), curconn->seskey, curconn->username, user->pw_uid, user->pw_gid, strerror(errno));", " \t\t\t\tabort_connection(curconn, pkthdr, _(\"Internal error\\r\\n\"));", " \t\t\t\texit(0);", " \t\t\t}", " \t\t\tif (stat(_PATH_NOLOGIN, &sb) == 0 && getuid() != 0) {", " \t\t\t\tsyslog(LOG_NOTICE, _(\"(%d) User %s disconnected with \" _PATH_NOLOGIN \" message.\"), curconn->seskey, curconn->username);", " \t\t\t\tdisplay_nologin();", " \t\t\t\tcurconn->state = STATE_CLOSED;", " \t\t\t\tinit_packet(&pdata, MT_PTYPE_END, pkthdr->dstaddr, pkthdr->srcaddr, pkthdr->seskey, curconn->outcounter);", " \t\t\t\tsend_udp(curconn, &pdata);", " \t\t\t\texit(0);", " \t\t\t}", " \t\t\tdisplay_motd();", " \t\t\tchdir(user->pw_dir);", " \t\t\texecl(user->pw_shell, user->pw_shell, \"-\", (char *) 0);", " \t\t\texit(0);  ", " \t\t}", " \t\tfree(user);", " \t\tfree(buffer);", " \t\tclose(curconn->slavefd);", " \t\tcurconn->pid = pid;", " \t\tset_terminal_size(curconn->ptsfd, curconn->terminal_width, curconn->terminal_height);", " \t}", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static Bool FFD_CanHandleURL(GF_InputService *plug, const char *url)", " {", " \tBool has_audio, has_video;", " \ts32 i;", "  \tAVFormatContext *ctx;", "  \tAVOutputFormat *fmt_out;", "  \tBool ret = GF_FALSE;", "\tchar *ext, szName[1000], szExt[20];", " \tchar *ext, szName[1024], szExt[20];", "  \tconst char *szExtList;", "  \tFFDemux *ffd;", "  \tif (!plug || !url)", " \t\treturn GF_FALSE;", " \tif (!strnicmp(url, \"rtsp:\", 7)) return GF_FALSE;", " \tif (!strnicmp(url, \"rtspu:\", 8)) return GF_FALSE;", " \tif (!strnicmp(url, \"rtp:\", 6)) return GF_FALSE;", " \tif (!strnicmp(url, \"plato:\", 8)) return GF_FALSE;", " \tif (!strnicmp(url, \"udp:\", 6)) return GF_FALSE;", " \tif (!strnicmp(url, \"tcp:\", 6)) return GF_FALSE;", " \tif (!strnicmp(url, \"data:\", 5)) return GF_FALSE;", "  \tffd = (FFDemux*)plug->priv;", " \tif (strlen(url) >= sizeof(szName))", " \t\treturn GF_FALSE;", "  \tstrcpy(szName, url);", "  \text = strrchr(szName, '#');", "  \tif (ext) ext[0] = 0;", " \text = strrchr(szName, '?');", " \tif (ext) ext[0] = 0;", "  \text = strrchr(szName, '.');", "  \tif (ext && strlen(ext) > 19) ext = NULL;", "\tif (ext && strlen(ext) > 1) {", " \tif (ext && strlen(ext) > 1 && strlen(ext) <= sizeof(szExt)) {", "  \t\tstrcpy(szExt, &ext[1]);", "  \t\tstrlwr(szExt);", "  #ifndef FFMPEG_DEMUX_ENABLE_MPEG2TS", " \t\tif (strstr(\"ts m2t mts dmb trp\", szExt) ) return GF_FALSE;", " #endif", " \t\tif (!strcmp(szExt, \"mp4\") || !strcmp(szExt, \"mpg4\") || !strcmp(szExt, \"m4a\") || !strcmp(szExt, \"m21\")", " \t\t        || !strcmp(szExt, \"m4v\") || !strcmp(szExt, \"m4a\")", " \t\t        || !strcmp(szExt, \"m4s\") || !strcmp(szExt, \"3gs\")", " \t\t        || !strcmp(szExt, \"3gp\") || !strcmp(szExt, \"3gpp\") || !strcmp(szExt, \"3gp2\") || !strcmp(szExt, \"3g2\")", " \t\t        || !strcmp(szExt, \"mp3\")", " \t\t        || !strcmp(szExt, \"ac3\")", " \t\t        || !strcmp(szExt, \"amr\")", " \t\t        || !strcmp(szExt, \"bt\") || !strcmp(szExt, \"wrl\") || !strcmp(szExt, \"x3dv\")", " \t\t        || !strcmp(szExt, \"xmt\") || !strcmp(szExt, \"xmta\") || !strcmp(szExt, \"x3d\")", " \t\t        || !strcmp(szExt, \"jpg\") || !strcmp(szExt, \"jpeg\") || !strcmp(szExt, \"png\")", " \t\t   ) return GF_FALSE;", " \t\t{", " \t\t\tu32 i;", " \t\t\tfor (i = 0 ; FFD_MIME_TYPES[i]; i+=3) {", " \t\t\t\tif (gf_service_check_mime_register(plug, FFD_MIME_TYPES[i], FFD_MIME_TYPES[i+1], FFD_MIME_TYPES[i+2], ext))", " \t\t\t\t\treturn GF_TRUE;", " \t\t\t}", " \t\t}", " \t}", " \tffd_parse_options(ffd, url);", " \tctx = NULL;", " \tif (open_file(&ctx, szName, NULL, ffd->options ? &ffd->options : NULL)<0) {", " \t\tAVInputFormat *av_in = NULL;", " \t\tif (ext && !strcmp(szExt, \"cmp\")) av_in = av_find_input_format(\"m4v\");", " \t\tif (open_file(&ctx, szName, av_in, ffd->options ? &ffd->options : NULL)<0) {", " \t\t\treturn GF_FALSE;", " \t\t}", " \t}", " \tif (!ctx) goto exit;", " \tif (av_find_stream_info(ctx) <0) goto exit;", " \thas_video = has_audio = GF_FALSE;", " \tfor(i = 0; i < (s32)ctx->nb_streams; i++) {", " \t\tAVCodecContext *enc = ctx->streams[i]->codec;", " \t\tswitch(enc->codec_type) {", " \t\tcase AVMEDIA_TYPE_AUDIO:", " \t\t\tif (!has_audio) has_audio = GF_TRUE;", " \t\t\tbreak;", " \t\tcase AVMEDIA_TYPE_VIDEO:", " \t\t\tif (!has_video) has_video= GF_TRUE;", " \t\t\tbreak;", " \t\tdefault:", " \t\t\tbreak;", " \t\t}", " \t}", " \tif (!has_audio && !has_video) goto exit;", " \tret = GF_TRUE;", " #if ((LIBAVFORMAT_VERSION_MAJOR == 52) && (LIBAVFORMAT_VERSION_MINOR <= 47)) || (LIBAVFORMAT_VERSION_MAJOR < 52)", " \tfmt_out = guess_stream_format(NULL, url, NULL);", " #else", " \tfmt_out = av_guess_format(NULL, url, NULL);", " #endif", " \tif (fmt_out) gf_service_register_mime(plug, fmt_out->mime_type, fmt_out->extensions, fmt_out->name);", " \telse {", " \t\text = strrchr(szName, '.');", " \t\tif (ext) {", " \t\t\tstrcpy(szExt, &ext[1]);", " \t\t\tstrlwr(szExt);", " \t\t\tszExtList = gf_modules_get_option((GF_BaseInterface *)plug, \"MimeTypes\", \"application/x-ffmpeg\");", " \t\t\tif (!szExtList) {", " \t\t\t\tgf_service_register_mime(plug, \"application/x-ffmpeg\", szExt, \"Other Movies (FFMPEG)\");", " \t\t\t} else if (!strstr(szExtList, szExt)) {", " \t\t\t\tu32 len;", " \t\t\t\tchar *buf;", " \t\t\t\tlen = (u32) (strlen(szExtList) + strlen(szExt) + 10);", " \t\t\t\tbuf = (char*)gf_malloc(sizeof(char)*len);", " \t\t\t\tsprintf(buf, \"\\\"%s \", szExt);", " \t\t\t\tstrcat(buf, &szExtList[1]);", " \t\t\t\tgf_modules_set_option((GF_BaseInterface *)plug, \"MimeTypes\", \"application/x-ffmpeg\", buf);", " \t\t\t\tgf_free(buf);", " \t\t\t}", " \t\t}", " \t}", " exit:", " #if FF_API_CLOSE_INPUT_FILE", " \tif (ctx) av_close_input_file(ctx);", " #else", " \tif (ctx) avformat_close_input(&ctx);", " #endif", " \treturn ret;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  int main(int argc, char *argv[])", "  {", "    int ret_value = 0;", "     libettercap_init();", "     ef_globals_alloc();", "     select_text_interface();", "    libettercap_ui_init();", "    fprintf(stdout, \"\\n\" EC_COLOR_BOLD \"%s %s\" EC_COLOR_END \" copyright %s %s\\n\\n\", ", "                       PROGRAM, EC_VERSION, EC_COPYRIGHT, EC_AUTHORS);", "    EF_GBL->lineno = 1;", "    parse_options(argc, argv);", "    if (EF_GBL_OPTIONS->source_file) {", "       yyin = fopen(EF_GBL_OPTIONS->source_file, \"r\");", "       if (yyin == NULL)", "          FATAL_ERROR(\"Input file not found !\");", "    } else {", "       FATAL_ERROR(\"No source file.\");", "    }", "    setbuf(yyin, NULL);", "    setbuf(stdout, NULL);", "    setbuf(stderr, NULL);", "    load_tables();", "    load_constants();", "    fprintf(stdout, \"\\n Parsing source file \\'%s\\' \", EF_GBL_OPTIONS->source_file);", "    fflush(stdout);", "    ef_debug(1, \"\\n\");", "    if (yyparse() == 0)", "       fprintf(stdout, \" done.\\n\\n\");", "    else", "        fprintf(stdout, \"\\n\\nThe script contains errors...\\n\\n\");", "   if (write_output() != E_SUCCESS)", "      FATAL_ERROR(\"Cannot write output file (%s)\", EF_GBL_OPTIONS->output_file);", "    ret_value = write_output();", "    if (ret_value == -E_NOTHANDLED)", "       FATAL_ERROR(\"Cannot write output file (%s): the filter is not correctly handled.\", EF_GBL_OPTIONS->output_file);", "    else if (ret_value == -E_INVALID)", "       FATAL_ERROR(\"Cannot write output file (%s): the filter format is not correct. \", EF_GBL_OPTIONS->output_file);", "     ef_globals_free();", "     return 0;", "  }"], "ner_tags": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": [" on_unregister_handler(TCMUService1HandlerManager1 *interface,", " \t\t      GDBusMethodInvocation *invocation,", " \t\t      gchar *subtype,", "  \t\t      gpointer user_data)", "  {", "  \tstruct tcmur_handler *handler = find_handler_by_subtype(subtype);", "\tstruct dbus_info *info = handler->opaque;", " \tstruct dbus_info *info = handler ? handler->opaque : NULL;", "  \tif (!handler) {", "  \t\tg_dbus_method_invocation_return_value(invocation,", " \t\t\tg_variant_new(\"(bs)\", FALSE,", " \t\t\t\t      \"unknown subtype\"));", " \t\treturn TRUE;", " \t}", " \tdbus_unexport_handler(handler);", " \ttcmur_unregister_handler(handler);", " \tg_bus_unwatch_name(info->watcher_id);", " \tg_free(info);", " \tg_free(handler);", " \tg_dbus_method_invocation_return_value(invocation,", " \t\tg_variant_new(\"(bs)\", TRUE, \"succeeded\"));", " \treturn TRUE;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int attribute_align_arg avcodec_open2(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options)", " {", "     int ret = 0;", "     int codec_init_ok = 0;", "     AVDictionary *tmp = NULL;", "     const AVPixFmtDescriptor *pixdesc;", "     if (avcodec_is_open(avctx))", "         return 0;", "     if ((!codec && !avctx->codec)) {", "         av_log(avctx, AV_LOG_ERROR, \"No codec provided to avcodec_open2()\\n\");", "         return AVERROR(EINVAL);", "     }", "     if ((codec && avctx->codec && codec != avctx->codec)) {", "         av_log(avctx, AV_LOG_ERROR, \"This AVCodecContext was allocated for %s, \"", "                                     \"but %s passed to avcodec_open2()\\n\", avctx->codec->name, codec->name);", "         return AVERROR(EINVAL);", "     }", "     if (!codec)", "         codec = avctx->codec;", "     if (avctx->extradata_size < 0 || avctx->extradata_size >= FF_MAX_EXTRADATA_SIZE)", "         return AVERROR(EINVAL);", "     if (options)", "         av_dict_copy(&tmp, *options, 0);", "     ff_lock_avcodec(avctx, codec);", "     avctx->internal = av_mallocz(sizeof(*avctx->internal));", "     if (!avctx->internal) {", "         ret = AVERROR(ENOMEM);", "         goto end;", "     }", "     avctx->internal->pool = av_mallocz(sizeof(*avctx->internal->pool));", "     if (!avctx->internal->pool) {", "         ret = AVERROR(ENOMEM);", "         goto free_and_end;", "     }", "     avctx->internal->to_free = av_frame_alloc();", "     if (!avctx->internal->to_free) {", "         ret = AVERROR(ENOMEM);", "         goto free_and_end;", "     }", "     avctx->internal->compat_decode_frame = av_frame_alloc();", "     if (!avctx->internal->compat_decode_frame) {", "         ret = AVERROR(ENOMEM);", "         goto free_and_end;", "     }", "     avctx->internal->buffer_frame = av_frame_alloc();", "     if (!avctx->internal->buffer_frame) {", "         ret = AVERROR(ENOMEM);", "         goto free_and_end;", "     }", "     avctx->internal->buffer_pkt = av_packet_alloc();", "     if (!avctx->internal->buffer_pkt) {", "         ret = AVERROR(ENOMEM);", "         goto free_and_end;", "     }", "     avctx->internal->ds.in_pkt = av_packet_alloc();", "     if (!avctx->internal->ds.in_pkt) {", "         ret = AVERROR(ENOMEM);", "         goto free_and_end;", "     }", "     avctx->internal->last_pkt_props = av_packet_alloc();", "     if (!avctx->internal->last_pkt_props) {", "         ret = AVERROR(ENOMEM);", "         goto free_and_end;", "     }", "     avctx->internal->skip_samples_multiplier = 1;", "     if (codec->priv_data_size > 0) {", "         if (!avctx->priv_data) {", "             avctx->priv_data = av_mallocz(codec->priv_data_size);", "             if (!avctx->priv_data) {", "                 ret = AVERROR(ENOMEM);", "                 goto end;", "             }", "             if (codec->priv_class) {", "                 *(const AVClass **)avctx->priv_data = codec->priv_class;", "                 av_opt_set_defaults(avctx->priv_data);", "             }", "         }", "         if (codec->priv_class && (ret = av_opt_set_dict(avctx->priv_data, &tmp)) < 0)", "             goto free_and_end;", "     } else {", "         avctx->priv_data = NULL;", "     }", "     if ((ret = av_opt_set_dict(avctx, &tmp)) < 0)", "         goto free_and_end;", "     if (avctx->codec_whitelist && av_match_list(codec->name, avctx->codec_whitelist, ',') <= 0) {", "         av_log(avctx, AV_LOG_ERROR, \"Codec (%s) not on whitelist \\'%s\\'\\n\", codec->name, avctx->codec_whitelist);", "         ret = AVERROR(EINVAL);", "         goto free_and_end;", "     }", "     if (!(avctx->coded_width && avctx->coded_height && avctx->width && avctx->height &&", "           (avctx->codec_id == AV_CODEC_ID_H264 || avctx->codec_id == AV_CODEC_ID_VP6F || avctx->codec_id == AV_CODEC_ID_DXV))) {", "     if (avctx->coded_width && avctx->coded_height)", "         ret = ff_set_dimensions(avctx, avctx->coded_width, avctx->coded_height);", "     else if (avctx->width && avctx->height)", "         ret = ff_set_dimensions(avctx, avctx->width, avctx->height);", "     if (ret < 0)", "         goto free_and_end;", "     }", "     if ((avctx->coded_width || avctx->coded_height || avctx->width || avctx->height)", "         && (  av_image_check_size2(avctx->coded_width, avctx->coded_height, avctx->max_pixels, AV_PIX_FMT_NONE, 0, avctx) < 0", "            || av_image_check_size2(avctx->width,       avctx->height,       avctx->max_pixels, AV_PIX_FMT_NONE, 0, avctx) < 0)) {", "         av_log(avctx, AV_LOG_WARNING, \"Ignoring invalid width/height values\\n\");", "         ff_set_dimensions(avctx, 0, 0);", "     }", "     if (avctx->width > 0 && avctx->height > 0) {", "         if (av_image_check_sar(avctx->width, avctx->height,", "                                avctx->sample_aspect_ratio) < 0) {", "             av_log(avctx, AV_LOG_WARNING, \"ignoring invalid SAR: %u/%u\\n\",", "                    avctx->sample_aspect_ratio.num,", "                    avctx->sample_aspect_ratio.den);", "             avctx->sample_aspect_ratio = (AVRational){ 0, 1 };", "         }", "     }", "     if (av_codec_is_decoder(codec))", "         av_freep(&avctx->subtitle_header);", "     if (avctx->channels > FF_SANE_NB_CHANNELS) {", "         av_log(avctx, AV_LOG_ERROR, \"Too many channels: %d\\n\", avctx->channels);", "         ret = AVERROR(EINVAL);", "         goto free_and_end;", "     }", "     avctx->codec = codec;", "     if ((avctx->codec_type == AVMEDIA_TYPE_UNKNOWN || avctx->codec_type == codec->type) &&", "         avctx->codec_id == AV_CODEC_ID_NONE) {", "         avctx->codec_type = codec->type;", "         avctx->codec_id   = codec->id;", "     }", "     if (avctx->codec_id != codec->id || (avctx->codec_type != codec->type", "                                          && avctx->codec_type != AVMEDIA_TYPE_ATTACHMENT)) {", "         av_log(avctx, AV_LOG_ERROR, \"Codec type or id mismatches\\n\");", "         ret = AVERROR(EINVAL);", "         goto free_and_end;", "     }", "     avctx->frame_number = 0;", "     avctx->codec_descriptor = avcodec_descriptor_get(avctx->codec_id);", "     if ((avctx->codec->capabilities & AV_CODEC_CAP_EXPERIMENTAL) &&", "         avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {", "         const char *codec_string = av_codec_is_encoder(codec) ? \"encoder\" : \"decoder\";", "         AVCodec *codec2;", "         av_log(avctx, AV_LOG_ERROR,", "                \"The %s '%s' is experimental but experimental codecs are not enabled, \"", "                \"add '-strict %d' if you want to use it.\\n\",", "                codec_string, codec->name, FF_COMPLIANCE_EXPERIMENTAL);", "         codec2 = av_codec_is_encoder(codec) ? avcodec_find_encoder(codec->id) : avcodec_find_decoder(codec->id);", "         if (!(codec2->capabilities & AV_CODEC_CAP_EXPERIMENTAL))", "             av_log(avctx, AV_LOG_ERROR, \"Alternatively use the non experimental %s '%s'.\\n\",", "                 codec_string, codec2->name);", "         ret = AVERROR_EXPERIMENTAL;", "         goto free_and_end;", "     }", "     if (avctx->codec_type == AVMEDIA_TYPE_AUDIO &&", "         (!avctx->time_base.num || !avctx->time_base.den)) {", "         avctx->time_base.num = 1;", "         avctx->time_base.den = avctx->sample_rate;", "     }", "     if (!HAVE_THREADS)", "         av_log(avctx, AV_LOG_WARNING, \"Warning: not compiled with thread support, using thread emulation\\n\");", "     if (CONFIG_FRAME_THREAD_ENCODER && av_codec_is_encoder(avctx->codec)) {", "         ff_unlock_avcodec(codec);  ", "         ret = ff_frame_thread_encoder_init(avctx, options ? *options : NULL);", "         ff_lock_avcodec(avctx, codec);", "         if (ret < 0)", "             goto free_and_end;", "     }", "     if (av_codec_is_decoder(avctx->codec)) {", "         ret = ff_decode_bsfs_init(avctx);", "         if (ret < 0)", "             goto free_and_end;", "     }", "     if (HAVE_THREADS", "         && !(avctx->internal->frame_thread_encoder && (avctx->active_thread_type&FF_THREAD_FRAME))) {", "         ret = ff_thread_init(avctx);", "         if (ret < 0) {", "             goto free_and_end;", "         }", "     }", "     if (!HAVE_THREADS && !(codec->capabilities & AV_CODEC_CAP_AUTO_THREADS))", "         avctx->thread_count = 1;", "     if (avctx->codec->max_lowres < avctx->lowres || avctx->lowres < 0) {", "         av_log(avctx, AV_LOG_WARNING, \"The maximum value for lowres supported by the decoder is %d\\n\",", "                avctx->codec->max_lowres);", "         avctx->lowres = avctx->codec->max_lowres;", "     }", "     if (av_codec_is_encoder(avctx->codec)) {", "         int i;", " #if FF_API_CODED_FRAME", " FF_DISABLE_DEPRECATION_WARNINGS", "         avctx->coded_frame = av_frame_alloc();", "         if (!avctx->coded_frame) {", "             ret = AVERROR(ENOMEM);", "             goto free_and_end;", "         }", " FF_ENABLE_DEPRECATION_WARNINGS", " #endif", "         if (avctx->time_base.num <= 0 || avctx->time_base.den <= 0) {", "             av_log(avctx, AV_LOG_ERROR, \"The encoder timebase is not set.\\n\");", "             ret = AVERROR(EINVAL);", "             goto free_and_end;", "         }", "         if (avctx->codec->sample_fmts) {", "             for (i = 0; avctx->codec->sample_fmts[i] != AV_SAMPLE_FMT_NONE; i++) {", "                 if (avctx->sample_fmt == avctx->codec->sample_fmts[i])", "                     break;", "                 if (avctx->channels == 1 &&", "                     av_get_planar_sample_fmt(avctx->sample_fmt) ==", "                     av_get_planar_sample_fmt(avctx->codec->sample_fmts[i])) {", "                     avctx->sample_fmt = avctx->codec->sample_fmts[i];", "                     break;", "                 }", "             }", "             if (avctx->codec->sample_fmts[i] == AV_SAMPLE_FMT_NONE) {", "                 char buf[128];", "                 snprintf(buf, sizeof(buf), \"%d\", avctx->sample_fmt);", "                 av_log(avctx, AV_LOG_ERROR, \"Specified sample format %s is invalid or not supported\\n\",", "                        (char *)av_x_if_null(av_get_sample_fmt_name(avctx->sample_fmt), buf));", "                 ret = AVERROR(EINVAL);", "                 goto free_and_end;", "             }", "         }", "         if (avctx->codec->pix_fmts) {", "             for (i = 0; avctx->codec->pix_fmts[i] != AV_PIX_FMT_NONE; i++)", "                 if (avctx->pix_fmt == avctx->codec->pix_fmts[i])", "                     break;", "             if (avctx->codec->pix_fmts[i] == AV_PIX_FMT_NONE", "                 && !((avctx->codec_id == AV_CODEC_ID_MJPEG || avctx->codec_id == AV_CODEC_ID_LJPEG)", "                      && avctx->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL)) {", "                 char buf[128];", "                 snprintf(buf, sizeof(buf), \"%d\", avctx->pix_fmt);", "                 av_log(avctx, AV_LOG_ERROR, \"Specified pixel format %s is invalid or not supported\\n\",", "                        (char *)av_x_if_null(av_get_pix_fmt_name(avctx->pix_fmt), buf));", "                 ret = AVERROR(EINVAL);", "                 goto free_and_end;", "             }", "             if (avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ420P ||", "                 avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ411P ||", "                 avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ422P ||", "                 avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ440P ||", "                 avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ444P)", "                 avctx->color_range = AVCOL_RANGE_JPEG;", "         }", "         if (avctx->codec->supported_samplerates) {", "             for (i = 0; avctx->codec->supported_samplerates[i] != 0; i++)", "                 if (avctx->sample_rate == avctx->codec->supported_samplerates[i])", "                     break;", "             if (avctx->codec->supported_samplerates[i] == 0) {", "                 av_log(avctx, AV_LOG_ERROR, \"Specified sample rate %d is not supported\\n\",", "                        avctx->sample_rate);", "                 ret = AVERROR(EINVAL);", "                 goto free_and_end;", "             }", "         }", "         if (avctx->sample_rate < 0) {", "             av_log(avctx, AV_LOG_ERROR, \"Specified sample rate %d is not supported\\n\",", "                     avctx->sample_rate);", "             ret = AVERROR(EINVAL);", "             goto free_and_end;", "         }", "         if (avctx->codec->channel_layouts) {", "             if (!avctx->channel_layout) {", "                 av_log(avctx, AV_LOG_WARNING, \"Channel layout not specified\\n\");", "             } else {", "                 for (i = 0; avctx->codec->channel_layouts[i] != 0; i++)", "                     if (avctx->channel_layout == avctx->codec->channel_layouts[i])", "                         break;", "                 if (avctx->codec->channel_layouts[i] == 0) {", "                     char buf[512];", "                     av_get_channel_layout_string(buf, sizeof(buf), -1, avctx->channel_layout);", "                     av_log(avctx, AV_LOG_ERROR, \"Specified channel layout '%s' is not supported\\n\", buf);", "                     ret = AVERROR(EINVAL);", "                     goto free_and_end;", "                 }", "             }", "         }", "         if (avctx->channel_layout && avctx->channels) {", "             int channels = av_get_channel_layout_nb_channels(avctx->channel_layout);", "             if (channels != avctx->channels) {", "                 char buf[512];", "                 av_get_channel_layout_string(buf, sizeof(buf), -1, avctx->channel_layout);", "                 av_log(avctx, AV_LOG_ERROR,", "                        \"Channel layout '%s' with %d channels does not match number of specified channels %d\\n\",", "                        buf, channels, avctx->channels);", "                 ret = AVERROR(EINVAL);", "                 goto free_and_end;", "             }", "         } else if (avctx->channel_layout) {", "             avctx->channels = av_get_channel_layout_nb_channels(avctx->channel_layout);", "         }", "         if (avctx->channels < 0) {", "             av_log(avctx, AV_LOG_ERROR, \"Specified number of channels %d is not supported\\n\",", "                     avctx->channels);", "             ret = AVERROR(EINVAL);", "             goto free_and_end;", "         }", "         if(avctx->codec_type == AVMEDIA_TYPE_VIDEO) {", "             pixdesc = av_pix_fmt_desc_get(avctx->pix_fmt);", "             if (    avctx->bits_per_raw_sample < 0", "                 || (avctx->bits_per_raw_sample > 8 && pixdesc->comp[0].depth <= 8)) {", "                 av_log(avctx, AV_LOG_WARNING, \"Specified bit depth %d not possible with the specified pixel formats depth %d\\n\",", "                     avctx->bits_per_raw_sample, pixdesc->comp[0].depth);", "                 avctx->bits_per_raw_sample = pixdesc->comp[0].depth;", "             }", "             if (avctx->width <= 0 || avctx->height <= 0) {", "                 av_log(avctx, AV_LOG_ERROR, \"dimensions not set\\n\");", "                 ret = AVERROR(EINVAL);", "                 goto free_and_end;", "             }", "         }", "         if (   (avctx->codec_type == AVMEDIA_TYPE_VIDEO || avctx->codec_type == AVMEDIA_TYPE_AUDIO)", "             && avctx->bit_rate>0 && avctx->bit_rate<1000) {", "             av_log(avctx, AV_LOG_WARNING, \"Bitrate %\"PRId64\" is extremely low, maybe you mean %\"PRId64\"k\\n\", avctx->bit_rate, avctx->bit_rate);", "         }", "         if (!avctx->rc_initial_buffer_occupancy)", "             avctx->rc_initial_buffer_occupancy = avctx->rc_buffer_size * 3LL / 4;", "         if (avctx->ticks_per_frame && avctx->time_base.num &&", "             avctx->ticks_per_frame > INT_MAX / avctx->time_base.num) {", "             av_log(avctx, AV_LOG_ERROR,", "                    \"ticks_per_frame %d too large for the timebase %d/%d.\",", "                    avctx->ticks_per_frame,", "                    avctx->time_base.num,", "                    avctx->time_base.den);", "             goto free_and_end;", "         }", "         if (avctx->hw_frames_ctx) {", "             AVHWFramesContext *frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;", "             if (frames_ctx->format != avctx->pix_fmt) {", "                 av_log(avctx, AV_LOG_ERROR,", "                        \"Mismatching AVCodecContext.pix_fmt and AVHWFramesContext.format\\n\");", "                 ret = AVERROR(EINVAL);", "                 goto free_and_end;", "             }", "             if (avctx->sw_pix_fmt != AV_PIX_FMT_NONE &&", "                 avctx->sw_pix_fmt != frames_ctx->sw_format) {", "                 av_log(avctx, AV_LOG_ERROR,", "                        \"Mismatching AVCodecContext.sw_pix_fmt (%s) \"", "                        \"and AVHWFramesContext.sw_format (%s)\\n\",", "                        av_get_pix_fmt_name(avctx->sw_pix_fmt),", "                        av_get_pix_fmt_name(frames_ctx->sw_format));", "                 ret = AVERROR(EINVAL);", "                 goto free_and_end;", "             }", "             avctx->sw_pix_fmt = frames_ctx->sw_format;", "         }", "     }", "     avctx->pts_correction_num_faulty_pts =", "     avctx->pts_correction_num_faulty_dts = 0;", "     avctx->pts_correction_last_pts =", "     avctx->pts_correction_last_dts = INT64_MIN;", "     if (   !CONFIG_GRAY && avctx->flags & AV_CODEC_FLAG_GRAY", "         && avctx->codec_descriptor->type == AVMEDIA_TYPE_VIDEO)", "         av_log(avctx, AV_LOG_WARNING,", "                \"gray decoding requested but not enabled at configuration time\\n\");", "     if (   avctx->codec->init && (!(avctx->active_thread_type&FF_THREAD_FRAME)", "         || avctx->internal->frame_thread_encoder)) {", "         ret = avctx->codec->init(avctx);", "         if (ret < 0) {", "             goto free_and_end;", "         }", "         codec_init_ok = 1;", "     }", "     ret=0;", "     if (av_codec_is_decoder(avctx->codec)) {", "         if (!avctx->bit_rate)", "             avctx->bit_rate = get_bit_rate(avctx);", "         if (avctx->channel_layout) {", "             int channels = av_get_channel_layout_nb_channels(avctx->channel_layout);", "             if (!avctx->channels)", "                 avctx->channels = channels;", "             else if (channels != avctx->channels) {", "                 char buf[512];", "                 av_get_channel_layout_string(buf, sizeof(buf), -1, avctx->channel_layout);", "                 av_log(avctx, AV_LOG_WARNING,", "                        \"Channel layout '%s' with %d channels does not match specified number of channels %d: \"", "                        \"ignoring specified channel layout\\n\",", "                        buf, channels, avctx->channels);", "                 avctx->channel_layout = 0;", "             }", "         }", "         if (avctx->channels && avctx->channels < 0 ||", "             avctx->channels > FF_SANE_NB_CHANNELS) {", "             ret = AVERROR(EINVAL);", "             goto free_and_end;", "         }", "         if (avctx->bits_per_coded_sample < 0) {", "             ret = AVERROR(EINVAL);", "             goto free_and_end;", "         }", "         if (avctx->sub_charenc) {", "             if (avctx->codec_type != AVMEDIA_TYPE_SUBTITLE) {", "                 av_log(avctx, AV_LOG_ERROR, \"Character encoding is only \"", "                        \"supported with subtitles codecs\\n\");", "                 ret = AVERROR(EINVAL);", "                 goto free_and_end;", "             } else if (avctx->codec_descriptor->props & AV_CODEC_PROP_BITMAP_SUB) {", "                 av_log(avctx, AV_LOG_WARNING, \"Codec '%s' is bitmap-based, \"", "                        \"subtitles character encoding will be ignored\\n\",", "                        avctx->codec_descriptor->name);", "                 avctx->sub_charenc_mode = FF_SUB_CHARENC_MODE_DO_NOTHING;", "             } else {", "                 if (avctx->sub_charenc_mode == FF_SUB_CHARENC_MODE_AUTOMATIC)", "                     avctx->sub_charenc_mode = FF_SUB_CHARENC_MODE_PRE_DECODER;", "                 if (avctx->sub_charenc_mode == FF_SUB_CHARENC_MODE_PRE_DECODER) {", " #if CONFIG_ICONV", "                     iconv_t cd = iconv_open(\"UTF-8\", avctx->sub_charenc);", "                     if (cd == (iconv_t)-1) {", "                         ret = AVERROR(errno);", "                         av_log(avctx, AV_LOG_ERROR, \"Unable to open iconv context \"", "                                \"with input character encoding \\\"%s\\\"\\n\", avctx->sub_charenc);", "                         goto free_and_end;", "                     }", "                     iconv_close(cd);", " #else", "                     av_log(avctx, AV_LOG_ERROR, \"Character encoding subtitles \"", "                            \"conversion needs a libavcodec built with iconv support \"", "                            \"for this codec\\n\");", "                     ret = AVERROR(ENOSYS);", "                     goto free_and_end;", " #endif", "                 }", "             }", "         }", " #if FF_API_AVCTX_TIMEBASE", "         if (avctx->framerate.num > 0 && avctx->framerate.den > 0)", "             avctx->time_base = av_inv_q(av_mul_q(avctx->framerate, (AVRational){avctx->ticks_per_frame, 1}));", " #endif", "     }", "     if (codec->priv_data_size > 0 && avctx->priv_data && codec->priv_class) {", "         av_assert0(*(const AVClass **)avctx->priv_data == codec->priv_class);", "     }", " end:", "     ff_unlock_avcodec(codec);", "     if (options) {", "         av_dict_free(options);", "         *options = tmp;", "     }", "      return ret;", "  free_and_end:", "    if (avctx->codec &&", "     if (avctx->codec && avctx->codec->close &&", "          (codec_init_ok ||", "           (avctx->codec->caps_internal & FF_CODEC_CAP_INIT_CLEANUP)))", "          avctx->codec->close(avctx);", "     if (codec->priv_class && codec->priv_data_size)", "         av_opt_free(avctx->priv_data);", "     av_opt_free(avctx);", " #if FF_API_CODED_FRAME", " FF_DISABLE_DEPRECATION_WARNINGS", "     av_frame_free(&avctx->coded_frame);", " FF_ENABLE_DEPRECATION_WARNINGS", " #endif", "     av_dict_free(&tmp);", "     av_freep(&avctx->priv_data);", "     if (avctx->internal) {", "         av_frame_free(&avctx->internal->to_free);", "         av_frame_free(&avctx->internal->compat_decode_frame);", "         av_frame_free(&avctx->internal->buffer_frame);", "         av_packet_free(&avctx->internal->buffer_pkt);", "         av_packet_free(&avctx->internal->last_pkt_props);", "         av_packet_free(&avctx->internal->ds.in_pkt);", "         ff_decode_bsfs_uninit(avctx);", "         av_freep(&avctx->internal->pool);", "     }", "     av_freep(&avctx->internal);", "     avctx->codec = NULL;", "     goto end;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  uint32_t *GetPayload(size_t handle, uint32_t *lastpayload, uint32_t index)", "  {", "  \tmp4object *mp4 = (mp4object *)handle;", " \tif (mp4 == NULL) return NULL;", " \tuint32_t *MP4buffer = NULL;", " \tif (index < mp4->indexcount && mp4->mediafp)", " \t{", " \t\tMP4buffer = (uint32_t *)realloc((void *)lastpayload, mp4->metasizes[index]);", "  \t\tif (MP4buffer)", "  \t\t{", "\t\t\tLONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);", "\t\t\tfread(MP4buffer, 1, mp4->metasizes[index], mp4->mediafp);", "\t\t\treturn MP4buffer;", " \t\t\tif (mp4->filesize > mp4->metaoffsets[index]+mp4->metasizes[index])", " \t\t\t{", " \t\t\t\tLONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);", " \t\t\t\tfread(MP4buffer, 1, mp4->metasizes[index], mp4->mediafp);", " \t\t\t\tmp4->filepos = mp4->metaoffsets[index] + mp4->metasizes[index];", " \t\t\t\treturn MP4buffer;", " \t\t\t}", "  \t\t}", "  \t}", "  \treturn NULL;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": [" static int ndp_sock_recv(struct ndp *ndp)", " {", " \tstruct ndp_msg *msg;", " \tenum ndp_msg_type msg_type;", " \tsize_t len;", " \tint err;", " \tmsg = ndp_msg_alloc();", " \tif (!msg)", " \t\treturn -ENOMEM;", "  \tlen = ndp_msg_payload_maxlen(msg);", "  \terr = myrecvfrom6(ndp->sock, msg->buf, &len, 0,", "\t\t\t  &msg->addrto, &msg->ifindex);", " \t\t\t  &msg->addrto, &msg->ifindex, &msg->hoplimit);", "  \tif (err) {", "  \t\terr(ndp, \"Failed to receive message\");", "  \t\tgoto free_msg;", "  \t}", "\tdbg(ndp, \"rcvd from: %s, ifindex: %u\",", "\t\t str_in6_addr(&msg->addrto), msg->ifindex);", " \tdbg(ndp, \"rcvd from: %s, ifindex: %u, hoplimit: %d\",", " \t\t str_in6_addr(&msg->addrto), msg->ifindex, msg->hoplimit);", " \tif (msg->hoplimit != 255) {", " \t\twarn(ndp, \"ignoring packet with bad hop limit (%d)\", msg->hoplimit);", " \t\terr = 0;", " \t\tgoto free_msg;", " \t}", "  \tif (len < sizeof(*msg->icmp6_hdr)) {", "  \t\twarn(ndp, \"rcvd icmp6 packet too short (%luB)\", len);", " \t\terr = 0;", " \t\tgoto free_msg;", " \t}", " \terr = ndp_msg_type_by_raw_type(&msg_type, msg->icmp6_hdr->icmp6_type);", " \tif (err) {", " \t\terr = 0;", " \t\tgoto free_msg;", " \t}", " \tndp_msg_init(msg, msg_type);", " \tndp_msg_payload_len_set(msg, len);", " \tif (!ndp_msg_check_valid(msg)) {", " \t\twarn(ndp, \"rcvd invalid ND message\");", " \t\terr = 0;", " \t\tgoto free_msg;", " \t}", " \tdbg(ndp, \"rcvd %s, len: %zuB\",", " \t\t ndp_msg_type_info(msg_type)->strabbr, len);", " \tif (!ndp_msg_check_opts(msg)) {", " \t\terr = 0;", " \t\tgoto free_msg;", " \t}", " \terr = ndp_call_handlers(ndp, msg);;", " free_msg:", " \tndp_msg_destroy(msg);", " \treturn err;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" devzvol_readdir(struct vnode *dvp, struct uio *uiop, struct cred *cred,", "     int *eofp, caller_context_t *ct_unused, int flags_unused)", " {", " \tstruct sdev_node *sdvp = VTOSDEV(dvp);", " \tchar *ptr;", " \tsdcmn_err13((\"zv readdir of '%s' %s'\", sdvp->sdev_path,", " \t    sdvp->sdev_name));", " \tif (strcmp(sdvp->sdev_path, ZVOL_DIR) == 0) {", " \t\tstruct vnode *vp;", " \t\trw_exit(&sdvp->sdev_contents);", " \t\t(void) devname_lookup_func(sdvp, \"dsk\", &vp, cred,", " \t\t    devzvol_create_dir, SDEV_VATTR);", " \t\tVN_RELE(vp);", " \t\t(void) devname_lookup_func(sdvp, \"rdsk\", &vp, cred,", " \t\t    devzvol_create_dir, SDEV_VATTR);", " \t\tVN_RELE(vp);", " \t\trw_enter(&sdvp->sdev_contents, RW_READER);", " \t\treturn (devname_readdir_func(dvp, uiop, cred, eofp, 0));", " \t}", " \tif (uiop->uio_offset == 0)", " \t\tdevzvol_prunedir(sdvp);", " \tptr = sdvp->sdev_path + strlen(ZVOL_DIR);", " \tif ((strcmp(ptr, \"/dsk\") == 0) || (strcmp(ptr, \"/rdsk\") == 0)) {", " \t\trw_exit(&sdvp->sdev_contents);", " \t\tdevzvol_create_pool_dirs(dvp);", " \t\trw_enter(&sdvp->sdev_contents, RW_READER);", "  \t\treturn (devname_readdir_func(dvp, uiop, cred, eofp, 0));", "  \t}", "\tptr = strchr(ptr + 1, '/') + 1;", " \tptr = strchr(ptr + 1, '/');", " \tif (ptr == NULL)", " \t\treturn (ENOENT);", " \tptr++;", "  \trw_exit(&sdvp->sdev_contents);", "  \tsdev_iter_datasets(dvp, ZFS_IOC_DATASET_LIST_NEXT, ptr);", "  \trw_enter(&sdvp->sdev_contents, RW_READER);", " \treturn (devname_readdir_func(dvp, uiop, cred, eofp, 0));", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" static int jpc_siz_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate,", "   jas_stream_t *in)", " {", " \tjpc_siz_t *siz = &ms->parms.siz;", " \tunsigned int i;", " \tuint_fast8_t tmp;", " \tcstate = 0;", " \tif (jpc_getuint16(in, &siz->caps) ||", " \t  jpc_getuint32(in, &siz->width) ||", " \t  jpc_getuint32(in, &siz->height) ||", " \t  jpc_getuint32(in, &siz->xoff) ||", " \t  jpc_getuint32(in, &siz->yoff) ||", " \t  jpc_getuint32(in, &siz->tilewidth) ||", " \t  jpc_getuint32(in, &siz->tileheight) ||", " \t  jpc_getuint32(in, &siz->tilexoff) ||", " \t  jpc_getuint32(in, &siz->tileyoff) ||", " \t  jpc_getuint16(in, &siz->numcomps)) {", " \t\treturn -1;", " \t}", " \tif (!siz->width || !siz->height || !siz->tilewidth ||", "  \t  !siz->tileheight || !siz->numcomps || siz->numcomps > 16384) {", "  \t\treturn -1;", "  \t}", " \tif (siz->tilexoff >= siz->width || siz->tileyoff >= siz->height) {", " \t\tjas_eprintf(\"all tiles are outside the image area\\n\");", " \t\treturn -1;", " \t}", "  \tif (!(siz->comps = jas_alloc2(siz->numcomps, sizeof(jpc_sizcomp_t)))) {", "  \t\treturn -1;", "  \t}", " \tfor (i = 0; i < siz->numcomps; ++i) {", " \t\tif (jpc_getuint8(in, &tmp) ||", " \t\t  jpc_getuint8(in, &siz->comps[i].hsamp) ||", " \t\t  jpc_getuint8(in, &siz->comps[i].vsamp)) {", " \t\t\tjas_free(siz->comps);", " \t\t\treturn -1;", " \t\t}", " \t\tif (siz->comps[i].hsamp == 0 || siz->comps[i].hsamp > 255) {", " \t\t\tjas_eprintf(\"invalid XRsiz value %d\\n\", siz->comps[i].hsamp);", " \t\t\tjas_free(siz->comps);", " \t\t\treturn -1;", " \t\t}", " \t\tif (siz->comps[i].vsamp == 0 || siz->comps[i].vsamp > 255) {", " \t\t\tjas_eprintf(\"invalid YRsiz value %d\\n\", siz->comps[i].vsamp);", " \t\t\tjas_free(siz->comps);", " \t\t\treturn -1;", " \t\t}", " \t\tsiz->comps[i].sgnd = (tmp >> 7) & 1;", " \t\tsiz->comps[i].prec = (tmp & 0x7f) + 1;", " \t}", " \tif (jas_stream_eof(in)) {", " \t\tjas_free(siz->comps);", " \t\treturn -1;", " \t}", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void ff_h264_free_tables(H264Context *h, int free_rbsp)", " {", "     int i;", "     H264Context *hx;", "     av_freep(&h->intra4x4_pred_mode);", "     av_freep(&h->chroma_pred_mode_table);", "     av_freep(&h->cbp_table);", "     av_freep(&h->mvd_table[0]);", "     av_freep(&h->mvd_table[1]);", "     av_freep(&h->direct_table);", "     av_freep(&h->non_zero_count);", "     av_freep(&h->slice_table_base);", "     h->slice_table = NULL;", "     av_freep(&h->list_counts);", "     av_freep(&h->mb2b_xy);", "     av_freep(&h->mb2br_xy);", "     av_buffer_pool_uninit(&h->qscale_table_pool);", "     av_buffer_pool_uninit(&h->mb_type_pool);", "     av_buffer_pool_uninit(&h->motion_val_pool);", "     av_buffer_pool_uninit(&h->ref_index_pool);", "      if (free_rbsp && h->DPB) {", "          for (i = 0; i < H264_MAX_PICTURE_COUNT; i++)", "              ff_h264_unref_picture(h, &h->DPB[i]);", "         memset(h->delayed_pic, 0, sizeof(h->delayed_pic));", "          av_freep(&h->DPB);", "      } else if (h->DPB) {", "          for (i = 0; i < H264_MAX_PICTURE_COUNT; i++)", "             h->DPB[i].needs_realloc = 1;", "     }", "     h->cur_pic_ptr = NULL;", "     for (i = 0; i < H264_MAX_THREADS; i++) {", "         hx = h->thread_context[i];", "         if (!hx)", "             continue;", "         av_freep(&hx->top_borders[1]);", "         av_freep(&hx->top_borders[0]);", "         av_freep(&hx->bipred_scratchpad);", "         av_freep(&hx->edge_emu_buffer);", "         av_freep(&hx->dc_val_base);", "         av_freep(&hx->er.mb_index2xy);", "         av_freep(&hx->er.error_status_table);", "         av_freep(&hx->er.er_temp_buffer);", "         av_freep(&hx->er.mbintra_table);", "         av_freep(&hx->er.mbskip_table);", "         if (free_rbsp) {", "             av_freep(&hx->rbsp_buffer[1]);", "             av_freep(&hx->rbsp_buffer[0]);", "             hx->rbsp_buffer_size[0] = 0;", "             hx->rbsp_buffer_size[1] = 0;", "         }", "         if (i)", "             av_freep(&h->thread_context[i]);", "     }", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" ProcScreenSaverUnsetAttributes(ClientPtr client)", " {", " #ifdef PANORAMIX", "     if (!noPanoramiXExtension) {", "         REQUEST(xScreenSaverUnsetAttributesReq);", "          PanoramiXRes *draw;", "          int rc, i;", "         REQUEST_SIZE_MATCH(xScreenSaverUnsetAttributesReq);", "          rc = dixLookupResourceByClass((void **) &draw, stuff->drawable,", "                                        XRC_DRAWABLE, client, DixWriteAccess);", "          if (rc != Success)", "         for (i = PanoramiXNumScreens - 1; i > 0; i--) {", "             stuff->drawable = draw->info[i].id;", "             ScreenSaverUnsetAttributes(client);", "         }", "         stuff->drawable = draw->info[0].id;", "     }", " #endif", "     return ScreenSaverUnsetAttributes(client);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int decode_frame_common(AVCodecContext *avctx, PNGDecContext *s,", "                                AVFrame *p, AVPacket *avpkt)", " {", "     AVDictionary *metadata  = NULL;", "     uint32_t tag, length;", "     int decode_next_dat = 0;", "     int ret;", "     for (;;) {", "         length = bytestream2_get_bytes_left(&s->gb);", "         if (length <= 0) {", "             if (avctx->codec_id == AV_CODEC_ID_PNG &&", "                 avctx->skip_frame == AVDISCARD_ALL) {", "                 av_frame_set_metadata(p, metadata);", "                 return 0;", "             }", "             if (CONFIG_APNG_DECODER && avctx->codec_id == AV_CODEC_ID_APNG && length == 0) {", "                 if (!(s->state & PNG_IDAT))", "                     return 0;", "                 else", "                     goto exit_loop;", "             }", "             av_log(avctx, AV_LOG_ERROR, \"%d bytes left\\n\", length);", "             if (   s->state & PNG_ALLIMAGE", "                 && avctx->strict_std_compliance <= FF_COMPLIANCE_NORMAL)", "                 goto exit_loop;", "             ret = AVERROR_INVALIDDATA;", "             goto fail;", "         }", "         length = bytestream2_get_be32(&s->gb);", "         if (length > 0x7fffffff || length > bytestream2_get_bytes_left(&s->gb)) {", "             av_log(avctx, AV_LOG_ERROR, \"chunk too big\\n\");", "             ret = AVERROR_INVALIDDATA;", "             goto fail;", "         }", "         tag = bytestream2_get_le32(&s->gb);", "         if (avctx->debug & FF_DEBUG_STARTCODE)", "             av_log(avctx, AV_LOG_DEBUG, \"png: tag=%c%c%c%c length=%u\\n\",", "                 (tag & 0xff),", "                 ((tag >> 8) & 0xff),", "                 ((tag >> 16) & 0xff),", "                 ((tag >> 24) & 0xff), length);", "         if (avctx->codec_id == AV_CODEC_ID_PNG &&", "             avctx->skip_frame == AVDISCARD_ALL) {", "             switch(tag) {", "             case MKTAG('I', 'H', 'D', 'R'):", "             case MKTAG('p', 'H', 'Y', 's'):", "             case MKTAG('t', 'E', 'X', 't'):", "             case MKTAG('I', 'D', 'A', 'T'):", "             case MKTAG('t', 'R', 'N', 'S'):", "                 break;", "             default:", "                 goto skip_tag;", "             }", "         }", "         switch (tag) {", "         case MKTAG('I', 'H', 'D', 'R'):", "             if ((ret = decode_ihdr_chunk(avctx, s, length)) < 0)", "                 goto fail;", "             break;", "         case MKTAG('p', 'H', 'Y', 's'):", "             if ((ret = decode_phys_chunk(avctx, s)) < 0)", "                 goto fail;", "             break;", "         case MKTAG('f', 'c', 'T', 'L'):", "             if (!CONFIG_APNG_DECODER || avctx->codec_id != AV_CODEC_ID_APNG)", "                 goto skip_tag;", "             if ((ret = decode_fctl_chunk(avctx, s, length)) < 0)", "                 goto fail;", "             decode_next_dat = 1;", "             break;", "         case MKTAG('f', 'd', 'A', 'T'):", "             if (!CONFIG_APNG_DECODER || avctx->codec_id != AV_CODEC_ID_APNG)", "                 goto skip_tag;", "             if (!decode_next_dat) {", "                 ret = AVERROR_INVALIDDATA;", "                 goto fail;", "             }", "             bytestream2_get_be32(&s->gb);", "             length -= 4;", "         case MKTAG('I', 'D', 'A', 'T'):", "             if (CONFIG_APNG_DECODER && avctx->codec_id == AV_CODEC_ID_APNG && !decode_next_dat)", "                 goto skip_tag;", "             if ((ret = decode_idat_chunk(avctx, s, length, p)) < 0)", "                 goto fail;", "             break;", "         case MKTAG('P', 'L', 'T', 'E'):", "             if (decode_plte_chunk(avctx, s, length) < 0)", "                 goto skip_tag;", "             break;", "         case MKTAG('t', 'R', 'N', 'S'):", "             if (decode_trns_chunk(avctx, s, length) < 0)", "                 goto skip_tag;", "             break;", "         case MKTAG('t', 'E', 'X', 't'):", "             if (decode_text_chunk(s, length, 0, &metadata) < 0)", "                 av_log(avctx, AV_LOG_WARNING, \"Broken tEXt chunk\\n\");", "             bytestream2_skip(&s->gb, length + 4);", "             break;", "         case MKTAG('z', 'T', 'X', 't'):", "             if (decode_text_chunk(s, length, 1, &metadata) < 0)", "                 av_log(avctx, AV_LOG_WARNING, \"Broken zTXt chunk\\n\");", "             bytestream2_skip(&s->gb, length + 4);", "             break;", "         case MKTAG('s', 'T', 'E', 'R'): {", "             int mode = bytestream2_get_byte(&s->gb);", "             AVStereo3D *stereo3d = av_stereo3d_create_side_data(p);", "             if (!stereo3d)", "                 goto fail;", "             if (mode == 0 || mode == 1) {", "                 stereo3d->type  = AV_STEREO3D_SIDEBYSIDE;", "                 stereo3d->flags = mode ? 0 : AV_STEREO3D_FLAG_INVERT;", "             } else {", "                  av_log(avctx, AV_LOG_WARNING,", "                         \"Unknown value in sTER chunk (%d)\\n\", mode);", "             }", "             bytestream2_skip(&s->gb, 4);  ", "             break;", "         }", "         case MKTAG('I', 'E', 'N', 'D'):", "             if (!(s->state & PNG_ALLIMAGE))", "                 av_log(avctx, AV_LOG_ERROR, \"IEND without all image\\n\");", "             if (!(s->state & (PNG_ALLIMAGE|PNG_IDAT))) {", "                 ret = AVERROR_INVALIDDATA;", "                 goto fail;", "             }", "             bytestream2_skip(&s->gb, 4);  ", "             goto exit_loop;", "         default:", " skip_tag:", "             bytestream2_skip(&s->gb, length + 4);", "             break;", "         }", "     }", " exit_loop:", "     if (avctx->codec_id == AV_CODEC_ID_PNG &&", "         avctx->skip_frame == AVDISCARD_ALL) {", "         av_frame_set_metadata(p, metadata);", "         return 0;", "     }", "     if (s->bits_per_pixel <= 4)", "         handle_small_bpp(s, p);", "     if (s->has_trns && s->color_type != PNG_COLOR_TYPE_PALETTE) {", "         size_t byte_depth = s->bit_depth > 8 ? 2 : 1;", "          size_t raw_bpp = s->bpp - byte_depth;", "          unsigned x, y;", "         av_assert0(s->bit_depth > 1);", "          for (y = 0; y < s->height; ++y) {", "              uint8_t *row = &s->image_buf[s->image_linesize * y];", "             for (x = s->width; x > 0; --x) {", "                 uint8_t *pixel = &row[s->bpp * (x - 1)];", "                 memmove(pixel, &row[raw_bpp * (x - 1)], raw_bpp);", "                 if (!memcmp(pixel, s->transparent_color_be, raw_bpp)) {", "                     memset(&pixel[raw_bpp], 0, byte_depth);", "                 } else {", "                     memset(&pixel[raw_bpp], 0xff, byte_depth);", "                 }", "             }", "         }", "     }", "     if (s->last_picture.f->data[0]) {", "         if (   !(avpkt->flags & AV_PKT_FLAG_KEY) && avctx->codec_tag != AV_RL32(\"MPNG\")", "             && s->last_picture.f->width == p->width", "             && s->last_picture.f->height== p->height", "             && s->last_picture.f->format== p->format", "          ) {", "             if (CONFIG_PNG_DECODER && avctx->codec_id != AV_CODEC_ID_APNG)", "                 handle_p_frame_png(s, p);", "             else if (CONFIG_APNG_DECODER &&", "                      avctx->codec_id == AV_CODEC_ID_APNG &&", "                      (ret = handle_p_frame_apng(avctx, s, p)) < 0)", "                 goto fail;", "         }", "     }", "     ff_thread_report_progress(&s->picture, INT_MAX, 0);", "     ff_thread_report_progress(&s->previous_picture, INT_MAX, 0);", "     av_frame_set_metadata(p, metadata);", "     metadata   = NULL;", "     return 0;", " fail:", "     av_dict_free(&metadata);", "     ff_thread_report_progress(&s->picture, INT_MAX, 0);", "     ff_thread_report_progress(&s->previous_picture, INT_MAX, 0);", "     return ret;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" sf_open_fd\t(int fd, int mode, SF_INFO *sfinfo, int close_desc)", " {\tSF_PRIVATE \t*psf ;", " \tif ((SF_CONTAINER (sfinfo->format)) == SF_FORMAT_SD2)", " \t{\tsf_errno = SFE_SD2_FD_DISALLOWED ;", "  \t\treturn\tNULL ;", "  \t\t} ;", "\tif ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)", " \tif ((psf = psf_allocate ()) == NULL)", "  \t{\tsf_errno = SFE_MALLOC_FAILED ;", "  \t\treturn\tNULL ;", "  \t\t} ;", " \tpsf_init_files (psf) ;", " \tcopy_filename (psf, \"\") ;", " \tpsf->file.mode = mode ;", " \tpsf_set_file (psf, fd) ;", " \tpsf->is_pipe = psf_is_pipe (psf) ;", " \tpsf->fileoffset = psf_ftell (psf) ;", " \tif (! close_desc)", " \t\tpsf->file.do_not_close_descriptor = SF_TRUE ;", " \treturn psf_open_file (psf, sfinfo) ;", " }  "], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)", " {", "  #if 0", "  \tjp2_pclr_t *pclr = &box->data.pclr;", "  #endif", "box = 0;", "out = 0;", " \tbox = 0;", " \tout = 0;", "  \treturn -1;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0]}
{"tokens": [" int mp4client_main(int argc, char **argv)", " {", " \tchar c;", " \tconst char *str;", " \tint ret_val = 0;", " \tu32 i, times[100], nb_times, dump_mode;", " \tu32 simulation_time_in_ms = 0;", " \tu32 initial_service_id = 0;", " \tBool auto_exit = GF_FALSE;", " \tBool logs_set = GF_FALSE;", " \tBool start_fs = GF_FALSE;", " \tBool use_rtix = GF_FALSE;", " \tBool pause_at_first = GF_FALSE;", " \tBool no_cfg_save = GF_FALSE;", " \tBool is_cfg_only = GF_FALSE;", " \tDouble play_from = 0;", " #ifdef GPAC_MEMORY_TRACKING", "     GF_MemTrackerType mem_track = GF_MemTrackerNone;", " #endif", " \tDouble fps = GF_IMPORT_DEFAULT_FPS;", " \tBool fill_ar, visible, do_uncache, has_command;", " \tchar *url_arg, *out_arg, *the_cfg, *rti_file, *views, *mosaic;", " \tFILE *logfile = NULL;", " \tFloat scale = 1;", " #ifndef WIN32", " \tdlopen(NULL, RTLD_NOW|RTLD_GLOBAL);", " #endif", " \tstrcpy(the_url, \".\");", " \tmemset(&user, 0, sizeof(GF_User));", " \tdump_mode = DUMP_NONE;", " \tfill_ar = visible = do_uncache = has_command = GF_FALSE;", " \turl_arg = out_arg = the_cfg = rti_file = views = mosaic = NULL;", " \tnb_times = 0;", " \ttimes[0] = 0;", " \tfor (i=1; i<(u32) argc; i++) {", " \t\tchar *arg = argv[i];", " \t\tif (!strcmp(arg, \"-c\") || !strcmp(arg, \"-cfg\")) {", " \t\t\tthe_cfg = argv[i+1];", " \t\t\ti++;", " \t\t}", " \t\telse if (!strcmp(arg, \"-mem-track\") || !strcmp(arg, \"-mem-track-stack\")) {", " #ifdef GPAC_MEMORY_TRACKING", "             mem_track = !strcmp(arg, \"-mem-track-stack\") ? GF_MemTrackerBackTrace : GF_MemTrackerSimple;", " #else", " \t\t\tfprintf(stderr, \"WARNING - GPAC not compiled with Memory Tracker - ignoring \\\"%s\\\"\\n\", arg);", " #endif", " \t\t} else if (!strcmp(arg, \"-gui\")) {", " \t\t\tgui_mode = 1;", " \t\t} else if (!strcmp(arg, \"-guid\")) {", " \t\t\tgui_mode = 2;", " \t\t} else if (!strcmp(arg, \"-h\") || !strcmp(arg, \"-help\")) {", " \t\t\tPrintUsage();", " \t\t\treturn 0;", " \t\t}", " \t}", " #ifdef GPAC_MEMORY_TRACKING", " \tgf_sys_init(mem_track);", " #else", " \tgf_sys_init(GF_MemTrackerNone);", " #endif", " \tgf_sys_set_args(argc, (const char **) argv);", " \tcfg_file = gf_cfg_init(the_cfg, NULL);", " \tif (!cfg_file) {", " \t\tfprintf(stderr, \"Error: Configuration File not found\\n\");", " \t\treturn 1;", " \t}", " \tif (gf_log_set_tools_levels( gf_cfg_get_key(cfg_file, \"General\", \"Logs\") ) != GF_OK) {", " \t\treturn 1;", " \t}", " \tif( gf_cfg_get_key(cfg_file, \"General\", \"Logs\") != NULL ) {", " \t\tlogs_set = GF_TRUE;", " \t}", " \tif (!gui_mode) {", " \t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"ForceGUI\");", " \t\tif (str && !strcmp(str, \"yes\")) gui_mode = 1;", " \t}", " \tfor (i=1; i<(u32) argc; i++) {", " \t\tchar *arg = argv[i];", " \t\tif (!strcmp(arg, \"-rti\")) {", " \t\t\trti_file = argv[i+1];", " \t\t\ti++;", " \t\t} else if (!strcmp(arg, \"-rtix\")) {", " \t\t\trti_file = argv[i+1];", " \t\t\ti++;", " \t\t\tuse_rtix = GF_TRUE;", " \t\t} else if (!stricmp(arg, \"-size\")) {", " \t\t\tif (sscanf(argv[i+1], \"%dx%d\", &forced_width, &forced_height) != 2) {", " \t\t\t\tforced_width = forced_height = 0;", " \t\t\t}", " \t\t\ti++;", " \t\t} else if (!strcmp(arg, \"-quiet\")) {", " \t\t\tbe_quiet = 1;", " \t\t} else if (!strcmp(arg, \"-strict-error\")) {", " \t\t\tgf_log_set_strict_error(1);", " \t\t} else if (!strcmp(arg, \"-log-file\") || !strcmp(arg, \"-lf\")) {", " \t\t\tlogfile = gf_fopen(argv[i+1], \"wt\");", " \t\t\tgf_log_set_callback(logfile, on_gpac_log);", " \t\t\ti++;", " \t\t} else if (!strcmp(arg, \"-logs\") ) {", " \t\t\tif (gf_log_set_tools_levels(argv[i+1]) != GF_OK) {", " \t\t\t\treturn 1;", " \t\t\t}", " \t\t\tlogs_set = GF_TRUE;", " \t\t\ti++;", " \t\t} else if (!strcmp(arg, \"-log-clock\") || !strcmp(arg, \"-lc\")) {", " \t\t\tlog_time_start = 1;", " \t\t} else if (!strcmp(arg, \"-log-utc\") || !strcmp(arg, \"-lu\")) {", " \t\t\tlog_utc_time = 1;", " \t\t}", " #if defined(__DARWIN__) || defined(__APPLE__)", " \t\telse if (!strcmp(arg, \"-thread\")) threading_flags = 0;", " #else", " \t\telse if (!strcmp(arg, \"-no-thread\")) threading_flags = GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_WINDOW_NO_THREAD;", " #endif", " \t\telse if (!strcmp(arg, \"-no-cthread\") || !strcmp(arg, \"-no-compositor-thread\")) threading_flags |= GF_TERM_NO_COMPOSITOR_THREAD;", " \t\telse if (!strcmp(arg, \"-no-audio\")) no_audio = 1;", " \t\telse if (!strcmp(arg, \"-no-regulation\")) no_regulation = 1;", " \t\telse if (!strcmp(arg, \"-fs\")) start_fs = 1;", " \t\telse if (!strcmp(arg, \"-opt\")) {", " \t\t\tset_cfg_option(argv[i+1]);", " \t\t\ti++;", " \t\t} else if (!strcmp(arg, \"-conf\")) {", " \t\t\tset_cfg_option(argv[i+1]);", " \t\t\tis_cfg_only=GF_TRUE;", " \t\t\ti++;", " \t\t}", " \t\telse if (!strcmp(arg, \"-ifce\")) {", " \t\t\tgf_cfg_set_key(cfg_file, \"Network\", \"DefaultMCastInterface\", argv[i+1]);", " \t\t\ti++;", " \t\t}", " \t\telse if (!stricmp(arg, \"-help\")) {", " \t\t\tPrintUsage();", " \t\t\treturn 1;", " \t\t}", " \t\telse if (!stricmp(arg, \"-noprog\")) {", " \t\t\tno_prog=1;", " \t\t\tgf_set_progress_callback(NULL, progress_quiet);", " \t\t}", " \t\telse if (!stricmp(arg, \"-no-save\") || !stricmp(arg, \"--no-save\")  ) {", " \t\t\tno_cfg_save=1;", " \t\t}", " \t\telse if (!stricmp(arg, \"-ntp-shift\")) {", " \t\t\ts32 shift = atoi(argv[i+1]);", " \t\t\ti++;", " \t\t\tgf_net_set_ntp_shift(shift);", " \t\t}", " \t\telse if (!stricmp(arg, \"-run-for\")) {", " \t\t\tsimulation_time_in_ms = atoi(argv[i+1]) * 1000;", " \t\t\tif (!simulation_time_in_ms)", " \t\t\t\tsimulation_time_in_ms = 1;  ", " \t\t\ti++;", " \t\t}", " \t\telse if (!strcmp(arg, \"-out\")) {", " \t\t\tout_arg = argv[i+1];", " \t\t\ti++;", " \t\t}", " \t\telse if (!stricmp(arg, \"-fps\")) {", " \t\t\tfps = atof(argv[i+1]);", " \t\t\ti++;", " \t\t} else if (!strcmp(arg, \"-avi\") || !strcmp(arg, \"-sha\")) {", " \t\t\tdump_mode &= 0xFFFF0000;", " \t\t\tif (!strcmp(arg, \"-sha\")) dump_mode |= DUMP_SHA1;", " \t\t\telse dump_mode |= DUMP_AVI;", " \t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) {", " \t\t\t\tif (!strcmp(arg, \"-avi\") && (nb_times!=2) ) {", " \t\t\t\t\tfprintf(stderr, \"Only one time arg found for -avi - check usage\\n\");", " \t\t\t\t\treturn 1;", " \t\t\t\t}", " \t\t\t\ti++;", " \t\t\t}", " \t\t} else if (!strcmp(arg, \"-rgbds\")) {  ", " \t\t\t\tdump_mode |= DUMP_RGB_DEPTH_SHAPE;", " \t\t} else if (!strcmp(arg, \"-rgbd\")) {  ", " \t\t\t\tdump_mode |= DUMP_RGB_DEPTH;", " \t\t} else if (!strcmp(arg, \"-depth\")) {", " \t\t\t\tdump_mode |= DUMP_DEPTH_ONLY;", " \t\t} else if (!strcmp(arg, \"-bmp\")) {", " \t\t\tdump_mode &= 0xFFFF0000;", " \t\t\tdump_mode |= DUMP_BMP;", " \t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;", " \t\t} else if (!strcmp(arg, \"-png\")) {", " \t\t\tdump_mode &= 0xFFFF0000;", " \t\t\tdump_mode |= DUMP_PNG;", " \t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;", " \t\t} else if (!strcmp(arg, \"-raw\")) {", " \t\t\tdump_mode &= 0xFFFF0000;", " \t\t\tdump_mode |= DUMP_RAW;", " \t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;", " \t\t} else if (!stricmp(arg, \"-scale\")) {", " \t\t\tsscanf(argv[i+1], \"%f\", &scale);", " \t\t\ti++;", " \t\t}", " \t\telse if (!strcmp(arg, \"-c\") || !strcmp(arg, \"-cfg\")) {", " \t\t\ti++;", " \t\t}", " \t\tif (!gui_mode) {", " \t\t\tif (arg[0] != '-') {", " \t\t\t\tif (url_arg) {", " \t\t\t\t\tfprintf(stderr, \"Several input URLs provided (\\\"%s\\\", \\\"%s\\\"). Check your command-line.\\n\", url_arg, arg);", " \t\t\t\t\treturn 1;", " \t\t\t\t}", " \t\t\t\turl_arg = arg;", " \t\t\t}", " \t\t\telse if (!strcmp(arg, \"-loop\")) loop_at_end = 1;", " \t\t\telse if (!strcmp(arg, \"-bench\")) bench_mode = 1;", " \t\t\telse if (!strcmp(arg, \"-vbench\")) bench_mode = 2;", " \t\t\telse if (!strcmp(arg, \"-sbench\")) bench_mode = 3;", " \t\t\telse if (!strcmp(arg, \"-no-addon\")) enable_add_ons = GF_FALSE;", " \t\t\telse if (!strcmp(arg, \"-pause\")) pause_at_first = 1;", " \t\t\telse if (!strcmp(arg, \"-play-from\")) {", " \t\t\t\tplay_from = atof((const char *) argv[i+1]);", " \t\t\t\ti++;", " \t\t\t}", " \t\t\telse if (!strcmp(arg, \"-speed\")) {", " \t\t\t\tplayback_speed = FLT2FIX( atof((const char *) argv[i+1]) );", " \t\t\t\tif (playback_speed <= 0) playback_speed = FIX_ONE;", " \t\t\t\ti++;", " \t\t\t}", " \t\t\telse if (!strcmp(arg, \"-no-wnd\")) user.init_flags |= GF_TERM_WINDOWLESS;", " \t\t\telse if (!strcmp(arg, \"-no-back\")) user.init_flags |= GF_TERM_WINDOW_TRANSPARENT;", " \t\t\telse if (!strcmp(arg, \"-align\")) {", " \t\t\t\tif (argv[i+1][0]=='m') align_mode = 1;", " \t\t\t\telse if (argv[i+1][0]=='b') align_mode = 2;", " \t\t\t\talign_mode <<= 8;", " \t\t\t\tif (argv[i+1][1]=='m') align_mode |= 1;", " \t\t\t\telse if (argv[i+1][1]=='r') align_mode |= 2;", " \t\t\t\ti++;", " \t\t\t} else if (!strcmp(arg, \"-fill\")) {", " \t\t\t\tfill_ar = GF_TRUE;", " \t\t\t} else if (!strcmp(arg, \"-show\")) {", " \t\t\t\tvisible = 1;", " \t\t\t} else if (!strcmp(arg, \"-uncache\")) {", " \t\t\t\tdo_uncache = GF_TRUE;", " \t\t\t}", " \t\t\telse if (!strcmp(arg, \"-exit\")) auto_exit = GF_TRUE;", " \t\t\telse if (!stricmp(arg, \"-views\")) {", " \t\t\t\tviews = argv[i+1];", " \t\t\t\ti++;", " \t\t\t}", " \t\t\telse if (!stricmp(arg, \"-mosaic\")) {", " \t\t\t\tmosaic = argv[i+1];", " \t\t\t\ti++;", " \t\t\t}", " \t\t\telse if (!stricmp(arg, \"-com\")) {", " \t\t\t\thas_command = GF_TRUE;", " \t\t\t\ti++;", " \t\t\t}", " \t\t\telse if (!stricmp(arg, \"-service\")) {", " \t\t\t\tinitial_service_id = atoi(argv[i+1]);", " \t\t\t\ti++;", " \t\t\t}", " \t\t}", " \t}", " \tif (is_cfg_only) {", " \t\tgf_cfg_del(cfg_file);", " \t\tfprintf(stderr, \"GPAC Config updated\\n\");", " \t\treturn 0;", " \t}", " \tif (do_uncache) {", " \t\tconst char *cache_dir = gf_cfg_get_key(cfg_file, \"General\", \"CacheDirectory\");", " \t\tdo_flatten_cache(cache_dir);", " \t\tfprintf(stderr, \"GPAC Cache dir %s flattened\\n\", cache_dir);", " \t\tgf_cfg_del(cfg_file);", " \t\treturn 0;", " \t}", " \tif (dump_mode && !url_arg ) {", " \t\tFILE *test;", " \t\turl_arg = (char *)gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\");", " \t\ttest = url_arg ? gf_fopen(url_arg, \"rt\") : NULL;", " \t\tif (!test) url_arg = NULL;", " \t\telse gf_fclose(test);", " \t\tif (!url_arg) {", " \t\t\tfprintf(stderr, \"Missing argument for dump\\n\");", " \t\t\tPrintUsage();", " \t\t\tif (logfile) gf_fclose(logfile);", " \t\t\treturn 1;", " \t\t}", " \t}", " \tif (!gui_mode && !url_arg && (gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\") != NULL)) {", " \t\tgui_mode=1;", " \t}", " #ifdef WIN32", " \tif (gui_mode==1) {", " \t\tconst char *opt;", " \t\tTCHAR buffer[1024];", " \t\tDWORD res = GetCurrentDirectory(1024, buffer);", " \t\tbuffer[res] = 0;", " \t\topt = gf_cfg_get_key(cfg_file, \"General\", \"ModulesDirectory\");", " \t\tif (strstr(opt, buffer)) {", " \t\t\tgui_mode=1;", " \t\t} else {", " \t\t\tgui_mode=2;", " \t\t}", " \t}", " #endif", " \tif (gui_mode==1) {", " \t\thide_shell(1);", " \t}", " \tif (gui_mode) {", " \t\tno_prog=1;", " \t\tgf_set_progress_callback(NULL, progress_quiet);", " \t}", " \tif (!url_arg && simulation_time_in_ms)", " \t\tsimulation_time_in_ms += gf_sys_clock();", " #if defined(__DARWIN__) || defined(__APPLE__)", " \tcarbon_init();", " #endif", " \tif (dump_mode) rti_file = NULL;", " \tif (!logs_set) {", " \t\tgf_log_set_tool_level(GF_LOG_ALL, GF_LOG_WARNING);", " \t}", " \tif (rti_file || logfile || log_utc_time || log_time_start)", " \t\tgf_log_set_callback(NULL, on_gpac_log);", " \tif (rti_file) init_rti_logs(rti_file, url_arg, use_rtix);", " \t{", " \t\tGF_SystemRTInfo rti;", " \t\tif (gf_sys_get_rti(0, &rti, 0))", " \t\t\tfprintf(stderr, \"System info: %d MB RAM - %d cores\\n\", (u32) (rti.physical_memory/1024/1024), rti.nb_cores);", " \t}", " \tif (dump_mode) {", " \t\tuser.init_flags |= GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_NO_REGULATION;", " \t\tif (!visible)", " \t\t\tuser.init_flags |= GF_TERM_INIT_HIDE;", " \t\tgf_cfg_set_key(cfg_file, \"Audio\", \"DriverName\", \"Raw Audio Output\");", " \t\tno_cfg_save=GF_TRUE;", " \t} else {", " \t\tinit_w = forced_width;", " \t\tinit_h = forced_height;", " \t}", " \tuser.modules = gf_modules_new(NULL, cfg_file);", " \tif (user.modules) i = gf_modules_get_count(user.modules);", " \tif (!i || !user.modules) {", " \t\tfprintf(stderr, \"Error: no modules found - exiting\\n\");", " \t\tif (user.modules) gf_modules_del(user.modules);", " \t\tgf_cfg_del(cfg_file);", " \t\tgf_sys_close();", " \t\tif (logfile) gf_fclose(logfile);", " \t\treturn 1;", " \t}", " \tfprintf(stderr, \"Modules Found : %d \\n\", i);", " \tstr = gf_cfg_get_key(cfg_file, \"General\", \"GPACVersion\");", " \tif (!str || strcmp(str, GPAC_FULL_VERSION)) {", " \t\tgf_cfg_del_section(cfg_file, \"PluginsCache\");", " \t\tgf_cfg_set_key(cfg_file, \"General\", \"GPACVersion\", GPAC_FULL_VERSION);", " \t}", " \tuser.config = cfg_file;", " \tuser.EventProc = GPAC_EventProc;", " \tuser.opaque = user.modules;", " \tif (threading_flags) user.init_flags |= threading_flags;", " \tif (no_audio) user.init_flags |= GF_TERM_NO_AUDIO;", " \tif (no_regulation) user.init_flags |= GF_TERM_NO_REGULATION;", " \tif (threading_flags & (GF_TERM_NO_DECODER_THREAD|GF_TERM_NO_COMPOSITOR_THREAD) ) term_step = GF_TRUE;", " \tif (dump_mode) user.init_flags |= GF_TERM_USE_AUDIO_HW_CLOCK;", " \tif (bench_mode) {", " \t\tgf_cfg_discard_changes(user.config);", " \t\tauto_exit = GF_TRUE;", " \t\tgf_cfg_set_key(user.config, \"Audio\", \"DriverName\", \"Raw Audio Output\");", " \t\tif (bench_mode!=2) {", " \t\t\tgf_cfg_set_key(user.config, \"Video\", \"DriverName\", \"Raw Video Output\");", " \t\t\tgf_cfg_set_key(user.config, \"RAWVideo\", \"RawOutput\", \"null\");", " \t\t\tgf_cfg_set_key(user.config, \"Compositor\", \"OpenGLMode\", \"disable\");", " \t\t} else {", " \t\t\tgf_cfg_set_key(user.config, \"Video\", \"DisableVSync\", \"yes\");", " \t\t}", " \t}", " \t{", " \t\tchar dim[50];", " \t\tsprintf(dim, \"%d\", forced_width);", " \t\tgf_cfg_set_key(user.config, \"Compositor\", \"DefaultWidth\", forced_width ? dim : NULL);", " \t\tsprintf(dim, \"%d\", forced_height);", " \t\tgf_cfg_set_key(user.config, \"Compositor\", \"DefaultHeight\", forced_height ? dim : NULL);", " \t}", " \tfprintf(stderr, \"Loading GPAC Terminal\\n\");", " \ti = gf_sys_clock();", " \tterm = gf_term_new(&user);", " \tif (!term) {", " \t\tfprintf(stderr, \"\\nInit error - check you have at least one video out and one rasterizer...\\nFound modules:\\n\");", " \t\tlist_modules(user.modules);", " \t\tgf_modules_del(user.modules);", " \t\tgf_cfg_discard_changes(cfg_file);", " \t\tgf_cfg_del(cfg_file);", " \t\tgf_sys_close();", " \t\tif (logfile) gf_fclose(logfile);", " \t\treturn 1;", " \t}", " \tfprintf(stderr, \"Terminal Loaded in %d ms\\n\", gf_sys_clock()-i);", " \tif (bench_mode) {", " \t\tdisplay_rti = 2;", " \t\tgf_term_set_option(term, GF_OPT_VIDEO_BENCH, (bench_mode==3) ? 2 : 1);", " \t\tif (bench_mode==1) bench_mode=2;", " \t}", " \tif (dump_mode) {", " \t\tif (fill_ar) gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);", " \t} else {", " \t\tstr = gf_cfg_get_key(cfg_file, \"Video\", \"DriverName\");", " \t\tif (!bench_mode && !strcmp(str, \"Raw Video Output\")) fprintf(stderr, \"WARNING: using raw output video (memory only) - no display used\\n\");", " \t\tstr = gf_cfg_get_key(cfg_file, \"Audio\", \"DriverName\");", " \t\tif (!str || !strcmp(str, \"No Audio Output Available\")) fprintf(stderr, \"WARNING: no audio output available - make sure no other program is locking the sound card\\n\");", " \t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"NoMIMETypeFetch\");", " \t\tno_mime_check = (str && !stricmp(str, \"yes\")) ? 1 : 0;", " \t}", " \tstr = gf_cfg_get_key(cfg_file, \"HTTPProxy\", \"Enabled\");", " \tif (str && !strcmp(str, \"yes\")) {", " \t\tstr = gf_cfg_get_key(cfg_file, \"HTTPProxy\", \"Name\");", " \t\tif (str) fprintf(stderr, \"HTTP Proxy %s enabled\\n\", str);", " \t}", " \tif (rti_file) {", " \t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"RTIRefreshPeriod\");", " \t\tif (str) {", " \t\t\trti_update_time_ms = atoi(str);", " \t\t} else {", " \t\t\tgf_cfg_set_key(cfg_file, \"General\", \"RTIRefreshPeriod\", \"200\");", " \t\t}", " \t\tUpdateRTInfo(\"At GPAC load time\\n\");", " \t}", " \tRun = 1;", " \tif (dump_mode) {", " \t\tif (!nb_times) {", " \t\t\ttimes[0] = 0;", " \t\t\tnb_times++;", " \t\t}", " \t\tret_val = dump_file(url_arg, out_arg, dump_mode, fps, forced_width, forced_height, scale, times, nb_times);", " \t\tRun = 0;", " \t}", " \telse if (views) {", " \t}", "  \telse if (!gui_mode && url_arg) {", "  \t\tchar *ext;", "\t\tstrcpy(the_url, url_arg);", " \t\tif (strlen(url_arg) >= sizeof(the_url)) {", " \t\t\tfprintf(stderr, \"Input url %s is too long, truncating to %d chars.\\n\", url_arg, (int)(sizeof(the_url) - 1));", " \t\t\tstrncpy(the_url, url_arg, sizeof(the_url)-1);", " \t\t\tthe_url[sizeof(the_url) - 1] = 0;", " \t\t}", " \t\telse {", " \t\t\tstrcpy(the_url, url_arg);", " \t\t}", "  \t\text = strrchr(the_url, '.');", "  \t\tif (ext && (!stricmp(ext, \".m3u\") || !stricmp(ext, \".pls\"))) {", "  \t\t\tGF_Err e = GF_OK;", " \t\t\tfprintf(stderr, \"Opening Playlist %s\\n\", the_url);", " \t\t\tstrcpy(pl_path, the_url);", " \t\t\tif (!strncmp(\"http:\", the_url, 5)) {", "  \t\t\t\tGF_DownloadSession *sess = gf_dm_sess_new(term->downloader, the_url, GF_NETIO_SESSION_NOT_THREADED, NULL, NULL, &e);", "  \t\t\t\tif (sess) {", "  \t\t\t\t\te = gf_dm_sess_process(sess);", "\t\t\t\t\tif (!e) strcpy(the_url, gf_dm_sess_get_cache_name(sess));", " \t\t\t\t\tif (!e) {", " \t\t\t\t\t\tstrncpy(the_url, gf_dm_sess_get_cache_name(sess), sizeof(the_url) - 1);", " \t\t\t\t\t\tthe_url[sizeof(the_cfg) - 1] = 0;", " \t\t\t\t\t}", "  \t\t\t\t\tgf_dm_sess_del(sess);", "  \t\t\t\t}", "  \t\t\t}", " \t\t\tplaylist = e ? NULL : gf_fopen(the_url, \"rt\");", " \t\t\treadonly_playlist = 1;", " \t\t\tif (playlist) {", " \t\t\t\trequest_next_playlist_item = GF_TRUE;", " \t\t\t} else {", " \t\t\t\tif (e)", " \t\t\t\t\tfprintf(stderr, \"Failed to open playlist %s: %s\\n\", the_url, gf_error_to_string(e) );", " \t\t\t\tfprintf(stderr, \"Hit 'h' for help\\n\\n\");", " \t\t\t}", " \t\t} else {", " \t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);", " \t\t\tif (pause_at_first) fprintf(stderr, \"[Status: Paused]\\n\");", " \t\t\tgf_term_connect_from_time(term, the_url, (u64) (play_from*1000), pause_at_first);", " \t\t}", " \t} else {", "  \t\tfprintf(stderr, \"Hit 'h' for help\\n\\n\");", "  \t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\");", "  \t\tif (str) {", "\t\t\tstrcpy(the_url, \"MP4Client \"GPAC_FULL_VERSION);", " \t\t\tstrncpy(the_url, \"MP4Client \"GPAC_FULL_VERSION , sizeof(the_url)-1);", " \t\t\tthe_url[sizeof(the_url) - 1] = 0;", "  \t\t\tgf_term_connect(term, str);", "  \t\t\tstartup_file = 1;", "  \t\t\tis_connected = 1;", " \t\t}", " \t}", " \tif (gui_mode==2) gui_mode=0;", " \tif (start_fs) gf_term_set_option(term, GF_OPT_FULLSCREEN, 1);", " \tif (views) {", " \t\tchar szTemp[4046];", " \t\tsprintf(szTemp, \"views:%s\", views);", " \t\tgf_term_connect(term, szTemp);", " \t}", " \tif (mosaic) {", " \t\tchar szTemp[4046];", " \t\tsprintf(szTemp, \"mosaic:%s\", mosaic);", " \t\tgf_term_connect(term, szTemp);", " \t}", " \tif (bench_mode) {", " \t\trti_update_time_ms = 500;", " \t\tbench_mode_start = gf_sys_clock();", " \t}", " \twhile (Run) {", " \t\tif ((gui_mode==1) || !gf_prompt_has_input()) {", " \t\t\tif (reload) {", " \t\t\t\treload = 0;", " \t\t\t\tgf_term_disconnect(term);", " \t\t\t\tgf_term_connect(term, startup_file ? gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\") : the_url);", " \t\t\t}", " \t\t\tif (restart && gf_term_get_option(term, GF_OPT_IS_OVER)) {", " \t\t\t\trestart = 0;", " \t\t\t\tgf_term_play_from_time(term, 0, 0);", " \t\t\t}", " \t\t\tif (request_next_playlist_item) {", " \t\t\t\tc = '\\n';", " \t\t\t\trequest_next_playlist_item = 0;", " \t\t\t\tgoto force_input;", " \t\t\t}", " \t\t\tif (has_command && is_connected) {", " \t\t\t\thas_command = GF_FALSE;", " \t\t\t\tfor (i=0; i<(u32)argc; i++) {", " \t\t\t\t\tif (!strcmp(argv[i], \"-com\")) {", " \t\t\t\t\t\tgf_term_scene_update(term, NULL, argv[i+1]);", " \t\t\t\t\t\ti++;", " \t\t\t\t\t}", " \t\t\t\t}", " \t\t\t}", " \t\t\tif (initial_service_id && is_connected) {", " \t\t\t\tGF_ObjectManager *root_od = gf_term_get_root_object(term);", " \t\t\t\tif (root_od) {", " \t\t\t\t\tgf_term_select_service(term, root_od, initial_service_id);", " \t\t\t\t\tinitial_service_id = 0;", " \t\t\t\t}", " \t\t\t}", " \t\t\tif (!use_rtix || display_rti) UpdateRTInfo(NULL);", " \t\t\tif (term_step) {", " \t\t\t\tgf_term_process_step(term);", " \t\t\t} else {", " \t\t\t\tgf_sleep(rti_update_time_ms);", " \t\t\t}", " \t\t\tif (auto_exit && eos_seen && gf_term_get_option(term, GF_OPT_IS_OVER)) {", " \t\t\t\tRun = GF_FALSE;", " \t\t\t}", " \t\t\tif (simulation_time_in_ms", " \t\t\t        && ( (gf_term_get_elapsed_time_in_ms(term)>simulation_time_in_ms) || (!url_arg && gf_sys_clock()>simulation_time_in_ms))", " \t\t\t   ) {", " \t\t\t\tRun = GF_FALSE;", " \t\t\t}", " \t\t\tcontinue;", " \t\t}", " \t\tc = gf_prompt_get_char();", " force_input:", " \t\tswitch (c) {", " \t\tcase 'q':", " \t\t{", " \t\t\tGF_Event evt;", " \t\t\tmemset(&evt, 0, sizeof(GF_Event));", " \t\t\tevt.type = GF_EVENT_QUIT;", " \t\t\tgf_term_send_event(term, &evt);", " \t\t}", " \t\tbreak;", " \t\tcase 'X':", " \t\t\texit(0);", " \t\t\tbreak;", " \t\tcase 'Q':", " \t\t\tbreak;", " \t\tcase 'o':", " \t\t\tstartup_file = 0;", " \t\t\tgf_term_disconnect(term);", " \t\t\tfprintf(stderr, \"Enter the absolute URL\\n\");", " \t\t\tif (1 > scanf(\"%s\", the_url)) {", " \t\t\t\tfprintf(stderr, \"Cannot read absolute URL, aborting\\n\");", " \t\t\t\tbreak;", " \t\t\t}", " \t\t\tif (rti_file) init_rti_logs(rti_file, the_url, use_rtix);", " \t\t\tgf_term_connect(term, the_url);", " \t\t\tbreak;", " \t\tcase 'O':", " \t\t\tgf_term_disconnect(term);", " \t\t\tfprintf(stderr, \"Enter the absolute URL to the playlist\\n\");", " \t\t\tif (1 > scanf(\"%s\", the_url)) {", " \t\t\t\tfprintf(stderr, \"Cannot read the absolute URL, aborting.\\n\");", " \t\t\t\tbreak;", " \t\t\t}", " \t\t\tplaylist = gf_fopen(the_url, \"rt\");", " \t\t\tif (playlist) {", " \t\t\t\tif (1 >\tfscanf(playlist, \"%s\", the_url)) {", " \t\t\t\t\tfprintf(stderr, \"Cannot read any URL from playlist, aborting.\\n\");", " \t\t\t\t\tgf_fclose( playlist);", " \t\t\t\t\tbreak;", " \t\t\t\t}", " \t\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);", " \t\t\t\tgf_term_connect(term, the_url);", " \t\t\t}", " \t\t\tbreak;", " \t\tcase '\\n':", " \t\tcase 'N':", " \t\t\tif (playlist) {", " \t\t\t\tint res;", " \t\t\t\tgf_term_disconnect(term);", " \t\t\t\tres = fscanf(playlist, \"%s\", the_url);", " \t\t\t\tif ((res == EOF) && loop_at_end) {", " \t\t\t\t\tfseek(playlist, 0, SEEK_SET);", " \t\t\t\t\tres = fscanf(playlist, \"%s\", the_url);", " \t\t\t\t}", " \t\t\t\tif (res == EOF) {", " \t\t\t\t\tfprintf(stderr, \"No more items - exiting\\n\");", " \t\t\t\t\tRun = 0;", " \t\t\t\t} else if (the_url[0] == '#') {", " \t\t\t\t\trequest_next_playlist_item = GF_TRUE;", " \t\t\t\t} else {", " \t\t\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);", " \t\t\t\t\tgf_term_connect_with_path(term, the_url, pl_path);", " \t\t\t\t}", " \t\t\t}", " \t\t\tbreak;", " \t\tcase 'P':", " \t\t\tif (playlist) {", " \t\t\t\tu32 count;", " \t\t\t\tgf_term_disconnect(term);", " \t\t\t\tif (1 > scanf(\"%u\", &count)) {", " \t\t\t\t\tfprintf(stderr, \"Cannot read number, aborting.\\n\");", " \t\t\t\t\tbreak;", " \t\t\t\t}", " \t\t\t\twhile (count) {", " \t\t\t\t\tif (fscanf(playlist, \"%s\", the_url)) {", " \t\t\t\t\t\tfprintf(stderr, \"Failed to read line, aborting\\n\");", " \t\t\t\t\t\tbreak;", " \t\t\t\t\t}", " \t\t\t\t\tcount--;", " \t\t\t\t}", " \t\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);", " \t\t\t\tgf_term_connect(term, the_url);", " \t\t\t}", " \t\t\tbreak;", " \t\tcase 'r':", " \t\t\tif (is_connected)", " \t\t\t\treload = 1;", " \t\t\tbreak;", " \t\tcase 'D':", " \t\t\tif (is_connected) gf_term_disconnect(term);", " \t\t\tbreak;", " \t\tcase 'p':", " \t\t\tif (is_connected) {", " \t\t\t\tBool is_pause = gf_term_get_option(term, GF_OPT_PLAY_STATE);", " \t\t\t\tfprintf(stderr, \"[Status: %s]\\n\", is_pause ? \"Playing\" : \"Paused\");", " \t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, is_pause ? GF_STATE_PLAYING : GF_STATE_PAUSED);", " \t\t\t}", " \t\t\tbreak;", " \t\tcase 's':", " \t\t\tif (is_connected) {", " \t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_STEP_PAUSE);", " \t\t\t\tfprintf(stderr, \"Step time: \");", " \t\t\t\tPrintTime(gf_term_get_time_in_ms(term));", " \t\t\t\tfprintf(stderr, \"\\n\");", " \t\t\t}", " \t\t\tbreak;", " \t\tcase 'z':", " \t\tcase 'T':", " \t\t\tif (!CanSeek || (Duration<=2000)) {", " \t\t\t\tfprintf(stderr, \"scene not seekable\\n\");", " \t\t\t} else {", " \t\t\t\tDouble res;", " \t\t\t\ts32 seekTo;", " \t\t\t\tfprintf(stderr, \"Duration: \");", " \t\t\t\tPrintTime(Duration);", " \t\t\t\tres = gf_term_get_time_in_ms(term);", " \t\t\t\tif (c=='z') {", " \t\t\t\t\tres *= 100;", " \t\t\t\t\tres /= (s64)Duration;", " \t\t\t\t\tfprintf(stderr, \" (current %.2f %%)\\nEnter Seek percentage:\\n\", res);", " \t\t\t\t\tif (scanf(\"%d\", &seekTo) == 1) {", " \t\t\t\t\t\tif (seekTo > 100) seekTo = 100;", " \t\t\t\t\t\tres = (Double)(s64)Duration;", " \t\t\t\t\t\tres /= 100;", " \t\t\t\t\t\tres *= seekTo;", " \t\t\t\t\t\tgf_term_play_from_time(term, (u64) (s64) res, 0);", " \t\t\t\t\t}", " \t\t\t\t} else {", " \t\t\t\t\tu32 r, h, m, s;", " \t\t\t\t\tfprintf(stderr, \" - Current Time: \");", " \t\t\t\t\tPrintTime((u64) res);", " \t\t\t\t\tfprintf(stderr, \"\\nEnter seek time (Format: s, m:s or h:m:s):\\n\");", " \t\t\t\t\th = m = s = 0;", " \t\t\t\t\tr =scanf(\"%d:%d:%d\", &h, &m, &s);", " \t\t\t\t\tif (r==2) {", " \t\t\t\t\t\ts = m;", " \t\t\t\t\t\tm = h;", " \t\t\t\t\t\th = 0;", " \t\t\t\t\t}", " \t\t\t\t\telse if (r==1) {", " \t\t\t\t\t\ts = h;", " \t\t\t\t\t\tm = h = 0;", " \t\t\t\t\t}", " \t\t\t\t\tif (r && (r<=3)) {", " \t\t\t\t\t\tu64 time = h*3600 + m*60 + s;", " \t\t\t\t\t\tgf_term_play_from_time(term, time*1000, 0);", " \t\t\t\t\t}", " \t\t\t\t}", " \t\t\t}", " \t\t\tbreak;", " \t\tcase 't':", " \t\t{", " \t\t\tif (is_connected) {", " \t\t\t\tfprintf(stderr, \"Current Time: \");", " \t\t\t\tPrintTime(gf_term_get_time_in_ms(term));", " \t\t\t\tfprintf(stderr, \" - Duration: \");", " \t\t\t\tPrintTime(Duration);", " \t\t\t\tfprintf(stderr, \"\\n\");", " \t\t\t}", " \t\t}", " \t\tbreak;", " \t\tcase 'w':", " \t\t\tif (is_connected) PrintWorldInfo(term);", " \t\t\tbreak;", " \t\tcase 'v':", " \t\t\tif (is_connected) PrintODList(term, NULL, 0, 0, \"Root\");", " \t\t\tbreak;", " \t\tcase 'i':", " \t\t\tif (is_connected) {", " \t\t\t\tu32 ID;", " \t\t\t\tfprintf(stderr, \"Enter OD ID (0 for main OD): \");", " \t\t\t\tfflush(stderr);", " \t\t\t\tif (scanf(\"%ud\", &ID) == 1) {", " \t\t\t\t\tViewOD(term, ID, (u32)-1, NULL);", " \t\t\t\t} else {", " \t\t\t\t\tchar str_url[GF_MAX_PATH];", " \t\t\t\t\tif (scanf(\"%s\", str_url) == 1)", " \t\t\t\t\t\tViewOD(term, 0, (u32)-1, str_url);", " \t\t\t\t}", " \t\t\t}", " \t\t\tbreak;", " \t\tcase 'j':", " \t\t\tif (is_connected) {", " \t\t\t\tu32 num;", " \t\t\t\tdo {", " \t\t\t\t\tfprintf(stderr, \"Enter OD number (0 for main OD): \");", " \t\t\t\t\tfflush(stderr);", " \t\t\t\t} while( 1 > scanf(\"%ud\", &num));", " \t\t\t\tViewOD(term, (u32)-1, num, NULL);", " \t\t\t}", " \t\t\tbreak;", " \t\tcase 'b':", " \t\t\tif (is_connected) ViewODs(term, 1);", " \t\t\tbreak;", " \t\tcase 'm':", " \t\t\tif (is_connected) ViewODs(term, 0);", " \t\t\tbreak;", " \t\tcase 'l':", " \t\t\tlist_modules(user.modules);", " \t\t\tbreak;", " \t\tcase 'n':", " \t\t\tif (is_connected) set_navigation();", " \t\t\tbreak;", " \t\tcase 'x':", " \t\t\tif (is_connected) gf_term_set_option(term, GF_OPT_NAVIGATION_TYPE, 0);", " \t\t\tbreak;", " \t\tcase 'd':", " \t\t\tif (is_connected) {", " \t\t\t\tGF_ObjectManager *odm = NULL;", " \t\t\t\tchar radname[GF_MAX_PATH], *sExt;", " \t\t\t\tGF_Err e;", " \t\t\t\tu32 i, count, odid;", " \t\t\t\tBool xml_dump, std_out;", " \t\t\t\tradname[0] = 0;", " \t\t\t\tdo {", " \t\t\t\t\tfprintf(stderr, \"Enter Inline OD ID if any or 0 : \");", " \t\t\t\t\tfflush(stderr);", " \t\t\t\t} while( 1 >  scanf(\"%ud\", &odid));", " \t\t\t\tif (odid) {", " \t\t\t\t\tGF_ObjectManager *root_odm = gf_term_get_root_object(term);", " \t\t\t\t\tif (!root_odm) break;", " \t\t\t\t\tcount = gf_term_get_object_count(term, root_odm);", " \t\t\t\t\tfor (i=0; i<count; i++) {", " \t\t\t\t\t\tGF_MediaInfo info;", " \t\t\t\t\t\todm = gf_term_get_object(term, root_odm, i);", " \t\t\t\t\t\tif (gf_term_get_object_info(term, odm, &info) == GF_OK) {", " \t\t\t\t\t\t\tif (info.od->objectDescriptorID==odid) break;", " \t\t\t\t\t\t}", " \t\t\t\t\t\todm = NULL;", " \t\t\t\t\t}", " \t\t\t\t}", " \t\t\t\tdo {", " \t\t\t\t\tfprintf(stderr, \"Enter file radical name (+\\'.x\\' for XML dumping) - \\\"std\\\" for stderr: \");", " \t\t\t\t\tfflush(stderr);", " \t\t\t\t} while( 1 > scanf(\"%s\", radname));", " \t\t\t\tsExt = strrchr(radname, '.');", " \t\t\t\txml_dump = 0;", " \t\t\t\tif (sExt) {", " \t\t\t\t\tif (!stricmp(sExt, \".x\")) xml_dump = 1;", " \t\t\t\t\tsExt[0] = 0;", " \t\t\t\t}", " \t\t\t\tstd_out = strnicmp(radname, \"std\", 3) ? 0 : 1;", " \t\t\t\te = gf_term_dump_scene(term, std_out ? NULL : radname, NULL, xml_dump, 0, odm);", " \t\t\t\tfprintf(stderr, \"Dump done (%s)\\n\", gf_error_to_string(e));", " \t\t\t}", " \t\t\tbreak;", " \t\tcase 'c':", " \t\t\tPrintGPACConfig();", " \t\t\tbreak;", " \t\tcase '3':", " \t\t{", " \t\t\tBool use_3d = !gf_term_get_option(term, GF_OPT_USE_OPENGL);", " \t\t\tif (gf_term_set_option(term, GF_OPT_USE_OPENGL, use_3d)==GF_OK) {", " \t\t\t\tfprintf(stderr, \"Using %s for 2D drawing\\n\", use_3d ? \"OpenGL\" : \"2D rasterizer\");", " \t\t\t}", " \t\t}", " \t\tbreak;", " \t\tcase 'k':", " \t\t{", " \t\t\tBool opt = gf_term_get_option(term, GF_OPT_STRESS_MODE);", " \t\t\topt = !opt;", " \t\t\tfprintf(stderr, \"Turning stress mode %s\\n\", opt ? \"on\" : \"off\");", " \t\t\tgf_term_set_option(term, GF_OPT_STRESS_MODE, opt);", " \t\t}", " \t\tbreak;", " \t\tcase '4':", " \t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_4_3);", " \t\t\tbreak;", " \t\tcase '5':", " \t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_16_9);", " \t\t\tbreak;", " \t\tcase '6':", " \t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);", " \t\t\tbreak;", " \t\tcase '7':", " \t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_KEEP);", " \t\t\tbreak;", " \t\tcase 'C':", " \t\t\tswitch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {", " \t\t\tcase GF_MEDIA_CACHE_DISABLED:", " \t\t\t\tgf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_ENABLED);", " \t\t\t\tbreak;", " \t\t\tcase GF_MEDIA_CACHE_ENABLED:", " \t\t\t\tgf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_DISABLED);", " \t\t\t\tbreak;", " \t\t\tcase GF_MEDIA_CACHE_RUNNING:", " \t\t\t\tfprintf(stderr, \"Streaming Cache is running - please stop it first\\n\");", " \t\t\t\tcontinue;", " \t\t\t}", " \t\t\tswitch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {", " \t\t\tcase GF_MEDIA_CACHE_ENABLED:", " \t\t\t\tfprintf(stderr, \"Streaming Cache Enabled\\n\");", " \t\t\t\tbreak;", " \t\t\tcase GF_MEDIA_CACHE_DISABLED:", " \t\t\t\tfprintf(stderr, \"Streaming Cache Disabled\\n\");", " \t\t\t\tbreak;", " \t\t\tcase GF_MEDIA_CACHE_RUNNING:", " \t\t\t\tfprintf(stderr, \"Streaming Cache Running\\n\");", " \t\t\t\tbreak;", " \t\t\t}", " \t\t\tbreak;", " \t\tcase 'S':", " \t\tcase 'A':", " \t\t\tif (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)==GF_MEDIA_CACHE_RUNNING) {", " \t\t\t\tgf_term_set_option(term, GF_OPT_MEDIA_CACHE, (c=='S') ? GF_MEDIA_CACHE_DISABLED : GF_MEDIA_CACHE_DISCARD);", " \t\t\t\tfprintf(stderr, \"Streaming Cache stopped\\n\");", " \t\t\t} else {", " \t\t\t\tfprintf(stderr, \"Streaming Cache not running\\n\");", " \t\t\t}", " \t\t\tbreak;", " \t\tcase 'R':", " \t\t\tdisplay_rti = !display_rti;", " \t\t\tResetCaption();", " \t\t\tbreak;", " \t\tcase 'F':", " \t\t\tif (display_rti) display_rti = 0;", " \t\t\telse display_rti = 2;", " \t\t\tResetCaption();", " \t\t\tbreak;", " \t\tcase 'u':", " \t\t{", " \t\t\tGF_Err e;", " \t\t\tchar szCom[8192];", " \t\t\tfprintf(stderr, \"Enter command to send:\\n\");", " \t\t\tfflush(stdin);", " \t\t\tszCom[0] = 0;", " \t\t\tif (1 > scanf(\"%[^\\t\\n]\", szCom)) {", " \t\t\t\tfprintf(stderr, \"Cannot read command to send, aborting.\\n\");", " \t\t\t\tbreak;", " \t\t\t}", " \t\t\te = gf_term_scene_update(term, NULL, szCom);", " \t\t\tif (e) fprintf(stderr, \"Processing command failed: %s\\n\", gf_error_to_string(e));", " \t\t}", " \t\tbreak;", " \t\tcase 'e':", " \t\t{", " \t\t\tGF_Err e;", " \t\t\tchar jsCode[8192];", " \t\t\tfprintf(stderr, \"Enter JavaScript code to evaluate:\\n\");", " \t\t\tfflush(stdin);", " \t\t\tjsCode[0] = 0;", " \t\t\tif (1 > scanf(\"%[^\\t\\n]\", jsCode)) {", " \t\t\t\tfprintf(stderr, \"Cannot read code to evaluate, aborting.\\n\");", " \t\t\t\tbreak;", " \t\t\t}", " \t\t\te = gf_term_scene_update(term, \"application/ecmascript\", jsCode);", " \t\t\tif (e) fprintf(stderr, \"Processing JS code failed: %s\\n\", gf_error_to_string(e));", " \t\t}", " \t\tbreak;", " \t\tcase 'L':", " \t\t{", " \t\t\tchar szLog[1024], *cur_logs;", " \t\t\tcur_logs = gf_log_get_tools_levels();", " \t\t\tfprintf(stderr, \"Enter new log level (current tools %s):\\n\", cur_logs);", " \t\t\tgf_free(cur_logs);", " \t\t\tif (scanf(\"%s\", szLog) < 1) {", " \t\t\t\tfprintf(stderr, \"Cannot read new log level, aborting.\\n\");", " \t\t\t\tbreak;", " \t\t\t}", " \t\t\tgf_log_modify_tools_levels(szLog);", " \t\t}", " \t\tbreak;", " \t\tcase 'g':", " \t\t{", " \t\t\tGF_SystemRTInfo rti;", " \t\t\tgf_sys_get_rti(rti_update_time_ms, &rti, 0);", " \t\t\tfprintf(stderr, \"GPAC allocated memory \"LLD\"\\n\", rti.gpac_memory);", " \t\t}", " \t\tbreak;", " \t\tcase 'M':", " \t\t{", " \t\t\tu32 size;", " \t\t\tdo {", " \t\t\t\tfprintf(stderr, \"Enter new video cache memory in kBytes (current %ud):\\n\", gf_term_get_option(term, GF_OPT_VIDEO_CACHE_SIZE));", " \t\t\t} while (1 > scanf(\"%ud\", &size));", " \t\t\tgf_term_set_option(term, GF_OPT_VIDEO_CACHE_SIZE, size);", " \t\t}", " \t\tbreak;", " \t\tcase 'H':", " \t\t{", " \t\t\tu32 http_bitrate = gf_term_get_option(term, GF_OPT_HTTP_MAX_RATE);", " \t\t\tdo {", " \t\t\t\tfprintf(stderr, \"Enter new http bitrate in bps (0 for none) - current limit: %d\\n\", http_bitrate);", " \t\t\t} while (1 > scanf(\"%ud\", &http_bitrate));", " \t\t\tgf_term_set_option(term, GF_OPT_HTTP_MAX_RATE, http_bitrate);", " \t\t}", " \t\tbreak;", " \t\tcase 'E':", " \t\t\tgf_term_set_option(term, GF_OPT_RELOAD_CONFIG, 1);", " \t\t\tbreak;", " \t\tcase 'B':", " \t\t\tswitch_bench(!bench_mode);", " \t\t\tbreak;", " \t\tcase 'Y':", " \t\t{", " \t\t\tchar szOpt[8192];", " \t\t\tfprintf(stderr, \"Enter option to set (Section:Name=Value):\\n\");", " \t\t\tfflush(stdin);", " \t\t\tszOpt[0] = 0;", " \t\t\tif (1 > scanf(\"%[^\\t\\n]\", szOpt)) {", " \t\t\t\tfprintf(stderr, \"Cannot read option\\n\");", " \t\t\t\tbreak;", " \t\t\t}", " \t\t\tset_cfg_option(szOpt);", " \t\t}", " \t\tbreak;", " \t\tcase 'Z':", " \t\t{", " \t\t\tchar szFileName[100];", " \t\t\tu32 nb_pass, nb_views, offscreen_view = 0;", " \t\t\tGF_VideoSurface fb;", " \t\t\tGF_Err e;", " \t\t\tnb_pass = 1;", " \t\t\tnb_views = gf_term_get_option(term, GF_OPT_NUM_STEREO_VIEWS);", " \t\t\tif (nb_views>1) {", " \t\t\t\tfprintf(stderr, \"Auto-stereo mode detected - type number of view to dump (0 is main output, 1 to %d offscreen view, %d for all offscreen, %d for all offscreen and main)\\n\", nb_views, nb_views+1, nb_views+2);", " \t\t\t\tif (scanf(\"%d\", &offscreen_view) != 1) {", " \t\t\t\t\toffscreen_view = 0;", " \t\t\t\t}", " \t\t\t\tif (offscreen_view==nb_views+1) {", " \t\t\t\t\toffscreen_view = 1;", " \t\t\t\t\tnb_pass = nb_views;", " \t\t\t\t}", " \t\t\t\telse if (offscreen_view==nb_views+2) {", " \t\t\t\t\toffscreen_view = 0;", " \t\t\t\t\tnb_pass = nb_views+1;", " \t\t\t\t}", " \t\t\t}", " \t\t\twhile (nb_pass) {", " \t\t\t\tnb_pass--;", " \t\t\t\tif (offscreen_view) {", " \t\t\t\t\tsprintf(szFileName, \"view%d_dump.png\", offscreen_view);", " \t\t\t\t\te = gf_term_get_offscreen_buffer(term, &fb, offscreen_view-1, 0);", " \t\t\t\t} else {", " \t\t\t\t\tsprintf(szFileName, \"gpac_video_dump_\"LLU\".png\", gf_net_get_utc() );", " \t\t\t\t\te = gf_term_get_screen_buffer(term, &fb);", " \t\t\t\t}", " \t\t\t\toffscreen_view++;", " \t\t\t\tif (e) {", " \t\t\t\t\tfprintf(stderr, \"Error dumping screen buffer %s\\n\", gf_error_to_string(e) );", " \t\t\t\t\tnb_pass = 0;", " \t\t\t\t} else {", " #ifndef GPAC_DISABLE_AV_PARSERS", " \t\t\t\t\tu32 dst_size = fb.width*fb.height*4;", " \t\t\t\t\tchar *dst = (char*)gf_malloc(sizeof(char)*dst_size);", " \t\t\t\t\te = gf_img_png_enc(fb.video_buffer, fb.width, fb.height, fb.pitch_y, fb.pixel_format, dst, &dst_size);", " \t\t\t\t\tif (e) {", " \t\t\t\t\t\tfprintf(stderr, \"Error encoding PNG %s\\n\", gf_error_to_string(e) );", " \t\t\t\t\t\tnb_pass = 0;", " \t\t\t\t\t} else {", " \t\t\t\t\t\tFILE *png = gf_fopen(szFileName, \"wb\");", " \t\t\t\t\t\tif (!png) {", " \t\t\t\t\t\t\tfprintf(stderr, \"Error writing file %s\\n\", szFileName);", " \t\t\t\t\t\t\tnb_pass = 0;", " \t\t\t\t\t\t} else {", " \t\t\t\t\t\t\tgf_fwrite(dst, dst_size, 1, png);", " \t\t\t\t\t\t\tgf_fclose(png);", " \t\t\t\t\t\t\tfprintf(stderr, \"Dump to %s\\n\", szFileName);", " \t\t\t\t\t\t}", " \t\t\t\t\t}", " \t\t\t\t\tif (dst) gf_free(dst);", " \t\t\t\t\tgf_term_release_screen_buffer(term, &fb);", " #endif  ", " \t\t\t\t}", " \t\t\t}", " \t\t\tfprintf(stderr, \"Done: %s\\n\", szFileName);", " \t\t}", " \t\tbreak;", " \t\tcase 'G':", " \t\t{", " \t\t\tGF_ObjectManager *root_od, *odm;", " \t\t\tu32 index;", " \t\t\tchar szOpt[8192];", " \t\t\tfprintf(stderr, \"Enter 0-based index of object to select or service ID:\\n\");", " \t\t\tfflush(stdin);", " \t\t\tszOpt[0] = 0;", " \t\t\tif (1 > scanf(\"%[^\\t\\n]\", szOpt)) {", " \t\t\t\tfprintf(stderr, \"Cannot read OD ID\\n\");", " \t\t\t\tbreak;", " \t\t\t}", " \t\t\tindex = atoi(szOpt);", " \t\t\todm = NULL;", " \t\t\troot_od = gf_term_get_root_object(term);", " \t\t\tif (root_od) {", " \t\t\t\tif ( gf_term_find_service(term, root_od, index)) {", " \t\t\t\t\tgf_term_select_service(term, root_od, index);", " \t\t\t\t} else {", " \t\t\t\t\tfprintf(stderr, \"Cannot find service %d - trying with object index\\n\", index);", " \t\t\t\t\todm = gf_term_get_object(term, root_od, index);", " \t\t\t\t\tif (odm) {", " \t\t\t\t\t\tgf_term_select_object(term, odm);", " \t\t\t\t\t} else {", " \t\t\t\t\t\tfprintf(stderr, \"Cannot find object at index %d\\n\", index);", " \t\t\t\t\t}", " \t\t\t\t}", " \t\t\t}", " \t\t}", " \t\tbreak;", " \t\tcase 'h':", " \t\t\tPrintHelp();", " \t\t\tbreak;", " \t\tdefault:", " \t\t\tbreak;", " \t\t}", " \t}", " \tif (bench_mode) {", " \t\tPrintAVInfo(GF_TRUE);", " \t}", " \tif (simulation_time_in_ms) {", " \t\tgf_log_set_strict_error(0);", " \t}", " \ti = gf_sys_clock();", " \tgf_term_disconnect(term);", " \tif (rti_file) UpdateRTInfo(\"Disconnected\\n\");", " \tfprintf(stderr, \"Deleting terminal... \");", " \tif (playlist) gf_fclose(playlist);", " #if defined(__DARWIN__) || defined(__APPLE__)", " \tcarbon_uninit();", " #endif", " \tgf_term_del(term);", " \tfprintf(stderr, \"done (in %d ms) - ran for %d ms\\n\", gf_sys_clock() - i, gf_sys_clock());", " \tfprintf(stderr, \"GPAC cleanup ...\\n\");", " \tgf_modules_del(user.modules);", " \tif (no_cfg_save)", " \t\tgf_cfg_discard_changes(cfg_file);", " \tgf_cfg_del(cfg_file);", " \tgf_sys_close();", " \tif (rti_logs) gf_fclose(rti_logs);", " \tif (logfile) gf_fclose(logfile);", " \tif (gui_mode) {", " \t\thide_shell(2);", " \t}", " #ifdef GPAC_MEMORY_TRACKING", " \tif (mem_track && (gf_memory_size() || gf_file_handles_count() )) {", " \t        gf_log_set_tool_level(GF_LOG_MEMORY, GF_LOG_INFO);", " \t\tgf_memory_print();", " \t\treturn 2;", " \t}", " #endif", " \treturn ret_val;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int mxf_parse_structural_metadata(MXFContext *mxf)", " {", "     MXFPackage *material_package = NULL;", "     int i, j, k, ret;", "     av_log(mxf->fc, AV_LOG_TRACE, \"metadata sets count %d\\n\", mxf->metadata_sets_count);", "     for (i = 0; i < mxf->packages_count; i++) {", "         material_package = mxf_resolve_strong_ref(mxf, &mxf->packages_refs[i], MaterialPackage);", "         if (material_package) break;", "     }", "     if (!material_package) {", "         av_log(mxf->fc, AV_LOG_ERROR, \"no material package found\\n\");", "         return AVERROR_INVALIDDATA;", "     }", "     mxf_add_umid_metadata(&mxf->fc->metadata, \"material_package_umid\", material_package);", "     if (material_package->name && material_package->name[0])", "         av_dict_set(&mxf->fc->metadata, \"material_package_name\", material_package->name, 0);", "     mxf_parse_package_comments(mxf, &mxf->fc->metadata, material_package);", "     for (i = 0; i < material_package->tracks_count; i++) {", "         MXFPackage *source_package = NULL;", "         MXFTrack *material_track = NULL;", "         MXFTrack *source_track = NULL;", "         MXFTrack *temp_track = NULL;", "         MXFDescriptor *descriptor = NULL;", "         MXFStructuralComponent *component = NULL;", "         MXFTimecodeComponent *mxf_tc = NULL;", "         UID *essence_container_ul = NULL;", "         const MXFCodecUL *codec_ul = NULL;", "         const MXFCodecUL *container_ul = NULL;", "         const MXFCodecUL *pix_fmt_ul = NULL;", "         AVStream *st;", "         AVTimecode tc;", "         int flags;", "         if (!(material_track = mxf_resolve_strong_ref(mxf, &material_package->tracks_refs[i], Track))) {", "             av_log(mxf->fc, AV_LOG_ERROR, \"could not resolve material track strong ref\\n\");", "             continue;", "         }", "         if ((component = mxf_resolve_strong_ref(mxf, &material_track->sequence_ref, TimecodeComponent))) {", "             mxf_tc = (MXFTimecodeComponent*)component;", "             flags = mxf_tc->drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0;", "             if (av_timecode_init(&tc, mxf_tc->rate, flags, mxf_tc->start_frame, mxf->fc) == 0) {", "                 mxf_add_timecode_metadata(&mxf->fc->metadata, \"timecode\", &tc);", "             }", "         }", "         if (!(material_track->sequence = mxf_resolve_strong_ref(mxf, &material_track->sequence_ref, Sequence))) {", "             av_log(mxf->fc, AV_LOG_ERROR, \"could not resolve material track sequence strong ref\\n\");", "             continue;", "         }", "         for (j = 0; j < material_track->sequence->structural_components_count; j++) {", "             component = mxf_resolve_strong_ref(mxf, &material_track->sequence->structural_components_refs[j], TimecodeComponent);", "             if (!component)", "                 continue;", "             mxf_tc = (MXFTimecodeComponent*)component;", "             flags = mxf_tc->drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0;", "             if (av_timecode_init(&tc, mxf_tc->rate, flags, mxf_tc->start_frame, mxf->fc) == 0) {", "                 mxf_add_timecode_metadata(&mxf->fc->metadata, \"timecode\", &tc);", "                 break;", "             }", "         }", "         if(material_track->sequence->structural_components_count > 1)", "             av_log(mxf->fc, AV_LOG_WARNING, \"material track %d: has %d components\\n\",", "                        material_track->track_id, material_track->sequence->structural_components_count);", "         for (j = 0; j < material_track->sequence->structural_components_count; j++) {", "             component = mxf_resolve_sourceclip(mxf, &material_track->sequence->structural_components_refs[j]);", "             if (!component)", "                 continue;", "             source_package = mxf_resolve_source_package(mxf, component->source_package_ul, component->source_package_uid);", "             if (!source_package) {", "                 av_log(mxf->fc, AV_LOG_TRACE, \"material track %d: no corresponding source package found\\n\", material_track->track_id);", "                 continue;", "             }", "             for (k = 0; k < source_package->tracks_count; k++) {", "                 if (!(temp_track = mxf_resolve_strong_ref(mxf, &source_package->tracks_refs[k], Track))) {", "                     av_log(mxf->fc, AV_LOG_ERROR, \"could not resolve source track strong ref\\n\");", "                     ret = AVERROR_INVALIDDATA;", "                     goto fail_and_free;", "                 }", "                 if (temp_track->track_id == component->source_track_id) {", "                     source_track = temp_track;", "                     break;", "                 }", "             }", "             if (!source_track) {", "                 av_log(mxf->fc, AV_LOG_ERROR, \"material track %d: no corresponding source track found\\n\", material_track->track_id);", "                 break;", "             }", "             for (k = 0; k < mxf->essence_container_data_count; k++) {", "                  MXFEssenceContainerData *essence_data;", "                  if (!(essence_data = mxf_resolve_strong_ref(mxf, &mxf->essence_container_data_refs[k], EssenceContainerData))) {", "                    av_log(mxf, AV_LOG_TRACE, \"could not resolve essence container data strong ref\\n\");", "                     av_log(mxf->fc, AV_LOG_TRACE, \"could not resolve essence container data strong ref\\n\");", "                      continue;", "                  }", "                  if (!memcmp(component->source_package_ul, essence_data->package_ul, sizeof(UID)) && !memcmp(component->source_package_uid, essence_data->package_uid, sizeof(UID))) {", "                     source_track->body_sid = essence_data->body_sid;", "                     source_track->index_sid = essence_data->index_sid;", "                     break;", "                 }", "             }", "             if(source_track && component)", "                 break;", "         }", "         if (!source_track || !component || !source_package) {", "             if((ret = mxf_add_metadata_stream(mxf, material_track)))", "                 goto fail_and_free;", "             continue;", "         }", "         if (!(source_track->sequence = mxf_resolve_strong_ref(mxf, &source_track->sequence_ref, Sequence))) {", "             av_log(mxf->fc, AV_LOG_ERROR, \"could not resolve source track sequence strong ref\\n\");", "             ret = AVERROR_INVALIDDATA;", "             goto fail_and_free;", "         }", "         if (memcmp(material_track->sequence->data_definition_ul, source_track->sequence->data_definition_ul, 16)) {", "             av_log(mxf->fc, AV_LOG_ERROR, \"material track %d: DataDefinition mismatch\\n\", material_track->track_id);", "             continue;", "         }", "         st = avformat_new_stream(mxf->fc, NULL);", "         if (!st) {", "             av_log(mxf->fc, AV_LOG_ERROR, \"could not allocate stream\\n\");", "             ret = AVERROR(ENOMEM);", "             goto fail_and_free;", "         }", "         st->id = material_track->track_id;", "         st->priv_data = source_track;", "         source_package->descriptor = mxf_resolve_strong_ref(mxf, &source_package->descriptor_ref, AnyType);", "         descriptor = mxf_resolve_multidescriptor(mxf, source_package->descriptor, source_track->track_id);", "         if (descriptor && descriptor->duration != AV_NOPTS_VALUE)", "             source_track->original_duration = st->duration = FFMIN(descriptor->duration, component->duration);", "         else", "             source_track->original_duration = st->duration = component->duration;", "         if (st->duration == -1)", "             st->duration = AV_NOPTS_VALUE;", "         st->start_time = component->start_position;", "         if (material_track->edit_rate.num <= 0 ||", "             material_track->edit_rate.den <= 0) {", "             av_log(mxf->fc, AV_LOG_WARNING,", "                    \"Invalid edit rate (%d/%d) found on stream #%d, \"", "                    \"defaulting to 25/1\\n\",", "                    material_track->edit_rate.num,", "                    material_track->edit_rate.den, st->index);", "             material_track->edit_rate = (AVRational){25, 1};", "         }", "         avpriv_set_pts_info(st, 64, material_track->edit_rate.den, material_track->edit_rate.num);", "         source_track->edit_rate = material_track->edit_rate;", "         PRINT_KEY(mxf->fc, \"data definition   ul\", source_track->sequence->data_definition_ul);", "         codec_ul = mxf_get_codec_ul(ff_mxf_data_definition_uls, &source_track->sequence->data_definition_ul);", "         st->codecpar->codec_type = codec_ul->id;", "         if (!descriptor) {", "             av_log(mxf->fc, AV_LOG_INFO, \"source track %d: stream %d, no descriptor found\\n\", source_track->track_id, st->index);", "             continue;", "         }", "         PRINT_KEY(mxf->fc, \"essence codec     ul\", descriptor->essence_codec_ul);", "         PRINT_KEY(mxf->fc, \"essence container ul\", descriptor->essence_container_ul);", "         essence_container_ul = &descriptor->essence_container_ul;", "         source_track->wrapping = (mxf->op == OPAtom) ? ClipWrapped : mxf_get_wrapping_kind(essence_container_ul);", "         if (source_track->wrapping == UnknownWrapped)", "             av_log(mxf->fc, AV_LOG_INFO, \"wrapping of stream %d is unknown\\n\", st->index);", "         if (IS_KLV_KEY(essence_container_ul, mxf_encrypted_essence_container)) {", "             av_log(mxf->fc, AV_LOG_INFO, \"broken encrypted mxf file\\n\");", "             for (k = 0; k < mxf->metadata_sets_count; k++) {", "                 MXFMetadataSet *metadata = mxf->metadata_sets[k];", "                 if (metadata->type == CryptoContext) {", "                     essence_container_ul = &((MXFCryptoContext *)metadata)->source_container_ul;", "                     break;", "                 }", "             }", "         }", "         codec_ul = mxf_get_codec_ul(ff_mxf_codec_uls, &descriptor->essence_codec_ul);", "         st->codecpar->codec_id = (enum AVCodecID)codec_ul->id;", "         if (st->codecpar->codec_id == AV_CODEC_ID_NONE) {", "             codec_ul = mxf_get_codec_ul(ff_mxf_codec_uls, &descriptor->codec_ul);", "             st->codecpar->codec_id = (enum AVCodecID)codec_ul->id;", "         }", "         av_log(mxf->fc, AV_LOG_VERBOSE, \"%s: Universal Label: \",", "                avcodec_get_name(st->codecpar->codec_id));", "         for (k = 0; k < 16; k++) {", "             av_log(mxf->fc, AV_LOG_VERBOSE, \"%.2x\",", "                    descriptor->essence_codec_ul[k]);", "             if (!(k+1 & 19) || k == 5)", "                 av_log(mxf->fc, AV_LOG_VERBOSE, \".\");", "         }", "         av_log(mxf->fc, AV_LOG_VERBOSE, \"\\n\");", "         mxf_add_umid_metadata(&st->metadata, \"file_package_umid\", source_package);", "         if (source_package->name && source_package->name[0])", "             av_dict_set(&st->metadata, \"file_package_name\", source_package->name, 0);", "         if (material_track->name && material_track->name[0])", "             av_dict_set(&st->metadata, \"track_name\", material_track->name, 0);", "         mxf_parse_physical_source_package(mxf, source_track, st);", "         if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {", "             source_track->intra_only = mxf_is_intra_only(descriptor);", "             container_ul = mxf_get_codec_ul(mxf_picture_essence_container_uls, essence_container_ul);", "             if (st->codecpar->codec_id == AV_CODEC_ID_NONE)", "                 st->codecpar->codec_id = container_ul->id;", "             st->codecpar->width = descriptor->width;", "             st->codecpar->height = descriptor->height;  ", "             switch (descriptor->frame_layout) {", "                 case FullFrame:", "                     st->codecpar->field_order = AV_FIELD_PROGRESSIVE;", "                     break;", "                 case OneField:", "                     av_log(mxf->fc, AV_LOG_INFO, \"OneField frame layout isn't currently supported\\n\");", "                     break;  ", "                 case MixedFields:", "                     break;", "                 case SegmentedFrame:", "                     st->codecpar->field_order = AV_FIELD_PROGRESSIVE;", "                 case SeparateFields:", "                     av_log(mxf->fc, AV_LOG_DEBUG, \"video_line_map: (%d, %d), field_dominance: %d\\n\",", "                            descriptor->video_line_map[0], descriptor->video_line_map[1],", "                            descriptor->field_dominance);", "                     if ((descriptor->video_line_map[0] > 0) && (descriptor->video_line_map[1] > 0)) {", "                         if ((descriptor->video_line_map[0] + descriptor->video_line_map[1]) % 2) {", "                             switch (descriptor->field_dominance) {", "                                 case MXF_FIELD_DOMINANCE_DEFAULT:", "                                 case MXF_FIELD_DOMINANCE_FF:", "                                     st->codecpar->field_order = AV_FIELD_TT;", "                                     break;", "                                 case MXF_FIELD_DOMINANCE_FL:", "                                     st->codecpar->field_order = AV_FIELD_TB;", "                                     break;", "                                 default:", "                                     avpriv_request_sample(mxf->fc,", "                                                           \"Field dominance %d support\",", "                                                           descriptor->field_dominance);", "                             }", "                         } else {", "                             switch (descriptor->field_dominance) {", "                                 case MXF_FIELD_DOMINANCE_DEFAULT:", "                                 case MXF_FIELD_DOMINANCE_FF:", "                                     st->codecpar->field_order = AV_FIELD_BB;", "                                     break;", "                                 case MXF_FIELD_DOMINANCE_FL:", "                                     st->codecpar->field_order = AV_FIELD_BT;", "                                     break;", "                                 default:", "                                     avpriv_request_sample(mxf->fc,", "                                                           \"Field dominance %d support\",", "                                                           descriptor->field_dominance);", "                             }", "                         }", "                     }", "                     st->codecpar->height *= 2;", "                     break;", "                 default:", "                     av_log(mxf->fc, AV_LOG_INFO, \"Unknown frame layout type: %d\\n\", descriptor->frame_layout);", "             }", "             if (st->codecpar->codec_id == AV_CODEC_ID_RAWVIDEO) {", "                 st->codecpar->format = descriptor->pix_fmt;", "                 if (st->codecpar->format == AV_PIX_FMT_NONE) {", "                     pix_fmt_ul = mxf_get_codec_ul(ff_mxf_pixel_format_uls,", "                                                   &descriptor->essence_codec_ul);", "                     st->codecpar->format = (enum AVPixelFormat)pix_fmt_ul->id;", "                     if (st->codecpar->format== AV_PIX_FMT_NONE) {", "                         st->codecpar->codec_tag = mxf_get_codec_ul(ff_mxf_codec_tag_uls,", "                                                                    &descriptor->essence_codec_ul)->id;", "                         if (!st->codecpar->codec_tag) {", "                             if (descriptor->horiz_subsampling == 2 &&", "                                 descriptor->vert_subsampling == 1 &&", "                                 descriptor->component_depth == 8) {", "                                 st->codecpar->format = AV_PIX_FMT_UYVY422;", "                             }", "                         }", "                     }", "                 }", "             }", "             st->need_parsing = AVSTREAM_PARSE_HEADERS;", "             if (material_track->sequence->origin) {", "                 av_dict_set_int(&st->metadata, \"material_track_origin\", material_track->sequence->origin, 0);", "             }", "             if (source_track->sequence->origin) {", "                 av_dict_set_int(&st->metadata, \"source_track_origin\", source_track->sequence->origin, 0);", "             }", "             if (descriptor->aspect_ratio.num && descriptor->aspect_ratio.den)", "                 st->display_aspect_ratio = descriptor->aspect_ratio;", "         } else if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {", "             container_ul = mxf_get_codec_ul(mxf_sound_essence_container_uls, essence_container_ul);", "             if (st->codecpar->codec_id == AV_CODEC_ID_NONE || (st->codecpar->codec_id == AV_CODEC_ID_PCM_ALAW && (enum AVCodecID)container_ul->id != AV_CODEC_ID_NONE))", "                 st->codecpar->codec_id = (enum AVCodecID)container_ul->id;", "             st->codecpar->channels = descriptor->channels;", "             st->codecpar->bits_per_coded_sample = descriptor->bits_per_sample;", "             if (descriptor->sample_rate.den > 0) {", "                 st->codecpar->sample_rate = descriptor->sample_rate.num / descriptor->sample_rate.den;", "                 avpriv_set_pts_info(st, 64, descriptor->sample_rate.den, descriptor->sample_rate.num);", "             } else {", "                 av_log(mxf->fc, AV_LOG_WARNING, \"invalid sample rate (%d/%d) \"", "                        \"found for stream #%d, time base forced to 1/48000\\n\",", "                        descriptor->sample_rate.num, descriptor->sample_rate.den,", "                        st->index);", "                 avpriv_set_pts_info(st, 64, 1, 48000);", "             }", "             if (st->duration != AV_NOPTS_VALUE)", "                 st->duration = av_rescale_q(st->duration,", "                                             av_inv_q(material_track->edit_rate),", "                                             st->time_base);", "             if (st->codecpar->codec_id == AV_CODEC_ID_PCM_S16LE) {", "                 if (descriptor->bits_per_sample > 16 && descriptor->bits_per_sample <= 24)", "                     st->codecpar->codec_id = AV_CODEC_ID_PCM_S24LE;", "                 else if (descriptor->bits_per_sample == 32)", "                     st->codecpar->codec_id = AV_CODEC_ID_PCM_S32LE;", "             } else if (st->codecpar->codec_id == AV_CODEC_ID_PCM_S16BE) {", "                 if (descriptor->bits_per_sample > 16 && descriptor->bits_per_sample <= 24)", "                     st->codecpar->codec_id = AV_CODEC_ID_PCM_S24BE;", "                 else if (descriptor->bits_per_sample == 32)", "                     st->codecpar->codec_id = AV_CODEC_ID_PCM_S32BE;", "             } else if (st->codecpar->codec_id == AV_CODEC_ID_MP2) {", "                 st->need_parsing = AVSTREAM_PARSE_FULL;", "             }", "         } else if (st->codecpar->codec_type == AVMEDIA_TYPE_DATA) {", "             enum AVMediaType type;", "             container_ul = mxf_get_codec_ul(mxf_data_essence_container_uls, essence_container_ul);", "             if (st->codecpar->codec_id == AV_CODEC_ID_NONE)", "                 st->codecpar->codec_id = container_ul->id;", "             type = avcodec_get_type(st->codecpar->codec_id);", "             if (type == AVMEDIA_TYPE_SUBTITLE)", "                 st->codecpar->codec_type = type;", "             if (container_ul->desc)", "                 av_dict_set(&st->metadata, \"data_type\", container_ul->desc, 0);", "         }", "         if (descriptor->extradata) {", "             if (!ff_alloc_extradata(st->codecpar, descriptor->extradata_size)) {", "                 memcpy(st->codecpar->extradata, descriptor->extradata, descriptor->extradata_size);", "             }", "         } else if (st->codecpar->codec_id == AV_CODEC_ID_H264) {", "             int coded_width = mxf_get_codec_ul(mxf_intra_only_picture_coded_width,", "                                                &descriptor->essence_codec_ul)->id;", "             if (coded_width)", "                 st->codecpar->width = coded_width;", "             ret = ff_generate_avci_extradata(st);", "             if (ret < 0)", "                 return ret;", "         }", "         if (st->codecpar->codec_type != AVMEDIA_TYPE_DATA && source_track->wrapping != FrameWrapped) {", "             st->need_parsing = AVSTREAM_PARSE_TIMESTAMPS;", "         }", "     }", "     ret = 0;", " fail_and_free:", "     return ret;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  void *jas_realloc(void *ptr, size_t size)", "  {", "  \tvoid *result;", "\tJAS_DBGLOG(101, (\"jas_realloc called with %x,%zu\\n\", ptr, size));", " \tJAS_DBGLOG(101, (\"jas_realloc(%x, %zu)\\n\", ptr, size));", "  \tresult = realloc(ptr, size);", "  \tJAS_DBGLOG(100, (\"jas_realloc(%p, %zu) -> %p\\n\", ptr, size, result));", "  \treturn result;", " }"], "ner_tags": [0, 0, 0, 1, 1, 0, 0, 0, 0]}
{"tokens": ["  QualifyIpPacket(IPHeader *pIpHeader, ULONG len)", "  {", "      tTcpIpPacketParsingResult res;", "     res.value = 0;", "     if (len < 4)", "     {", "         res.ipStatus = ppresNotIP;", "         return res;", "     }", "      UCHAR  ver_len = pIpHeader->v4.ip_verlen;", "      UCHAR  ip_version = (ver_len & 0xF0) >> 4;", "      USHORT ipHeaderSize = 0;", "      USHORT fullLength = 0;", "      res.value = 0;", "      if (ip_version == 4)", "      {", "         if (len < sizeof(IPv4Header))", "         {", "             res.ipStatus = ppresNotIP;", "             return res;", "         }", "          ipHeaderSize = (ver_len & 0xF) << 2;", "          fullLength = swap_short(pIpHeader->v4.ip_length);", "        DPrintf(3, (\"ip_version %d, ipHeaderSize %d, protocol %d, iplen %d\\n\",", "            ip_version, ipHeaderSize, pIpHeader->v4.ip_protocol, fullLength));", "         DPrintf(3, (\"ip_version %d, ipHeaderSize %d, protocol %d, iplen %d, L2 payload length %d\\n\",", "             ip_version, ipHeaderSize, pIpHeader->v4.ip_protocol, fullLength, len));", "          res.ipStatus = (ipHeaderSize >= sizeof(IPv4Header)) ? ppresIPV4 : ppresNotIP;", "        if (len < ipHeaderSize) res.ipCheckSum = ppresIPTooShort;", "        if (fullLength) {}", "        else", "         if (res.ipStatus == ppresNotIP)", "          {", "            DPrintf(2, (\"ip v.%d, iplen %d\\n\", ip_version, fullLength));", "             return res;", "         }", "         if (ipHeaderSize >= fullLength || len < fullLength)", "         {", "             DPrintf(2, (\"[%s] - truncated packet - ip_version %d, ipHeaderSize %d, protocol %d, iplen %d, L2 payload length %d\\n\",", "                 ip_version, ipHeaderSize, pIpHeader->v4.ip_protocol, fullLength, len));", "             res.ipCheckSum = ppresIPTooShort;", "             return res;", "          }", "      }", "      else if (ip_version == 6)", "     {", "         UCHAR nextHeader = pIpHeader->v6.ip6_next_header;", "         BOOLEAN bParsingDone = FALSE;", "         ipHeaderSize = sizeof(pIpHeader->v6);", "         res.ipStatus = ppresIPV6;", "         res.ipCheckSum = ppresCSOK;", "         fullLength = swap_short(pIpHeader->v6.ip6_payload_len);", "         fullLength += ipHeaderSize;", "         while (nextHeader != 59)", "         {", "             IPv6ExtHeader *pExt;", "             switch (nextHeader)", "             {", "                 case PROTOCOL_TCP:", "                     bParsingDone = TRUE;", "                     res.xxpStatus = ppresXxpKnown;", "                     res.TcpUdp = ppresIsTCP;", "                     res.xxpFull = len >= fullLength ? 1 : 0;", "                     res = ProcessTCPHeader(res, pIpHeader, len, ipHeaderSize);", "                     break;", "                 case PROTOCOL_UDP:", "                     bParsingDone = TRUE;", "                     res.xxpStatus = ppresXxpKnown;", "                     res.TcpUdp = ppresIsUDP;", "                     res.xxpFull = len >= fullLength ? 1 : 0;", "                     res = ProcessUDPHeader(res, pIpHeader, len, ipHeaderSize);", "                     break;", "                 case 0:", "                 case 60:", "                 case 43:", "                 case 44:", "                 case 51:", "                 case 50:", "                 case 135:", "                     if (len >= ((ULONG)ipHeaderSize + 8))", "                     {", "                         pExt = (IPv6ExtHeader *)((PUCHAR)pIpHeader + ipHeaderSize);", "                         nextHeader = pExt->ip6ext_next_header;", "                         ipHeaderSize += 8;", "                         ipHeaderSize += pExt->ip6ext_hdr_len * 8;", "                     }", "                     else", "                     {", "                         DPrintf(0, (\"[%s] ERROR: Break in the middle of ext. headers(len %d, hdr > %d)\\n\", __FUNCTION__, len, ipHeaderSize));", "                         res.ipStatus = ppresNotIP;", "                         bParsingDone = TRUE;", "                     }", "                     break;", "                 default:", "                     res.xxpStatus = ppresXxpOther;", "                     bParsingDone = TRUE;", "                     break;", "             }", "             if (bParsingDone)", "                 break;", "         }", "         if (ipHeaderSize <= MAX_SUPPORTED_IPV6_HEADERS)", "         {", "             DPrintf(3, (\"ip_version %d, ipHeaderSize %d, protocol %d, iplen %d\\n\",", "                 ip_version, ipHeaderSize, nextHeader, fullLength));", "             res.ipHeaderSize = ipHeaderSize;", "         }", "         else", "         {", "             DPrintf(0, (\"[%s] ERROR: IP chain is too large (%d)\\n\", __FUNCTION__, ipHeaderSize));", "             res.ipStatus = ppresNotIP;", "         }", "     }", "      if (res.ipStatus == ppresIPV4)", "      {", "          res.ipHeaderSize = ipHeaderSize;", "        res.xxpFull = len >= fullLength ? 1 : 0;", "          res.IsFragment = (pIpHeader->v4.ip_offset & ~0xC0) != 0;", "          switch (pIpHeader->v4.ip_protocol)", "         {", "             case PROTOCOL_TCP:", "             {", "                 res = ProcessTCPHeader(res, pIpHeader, len, ipHeaderSize);", "             }", "             break;", "         case PROTOCOL_UDP:", "             {", "                 res = ProcessUDPHeader(res, pIpHeader, len, ipHeaderSize);", "             }", "             break;", "         default:", "             res.xxpStatus = ppresXxpOther;", "             break;", "         }", "     }", "     return res;", " }"], "ner_tags": [0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int vp8_lossy_decode_frame(AVCodecContext *avctx, AVFrame *p,", "                                   int *got_frame, uint8_t *data_start,", "                                   unsigned int data_size)", " {", "     WebPContext *s = avctx->priv_data;", "     AVPacket pkt;", "     int ret;", "      if (!s->initialized) {", "          ff_vp8_decode_init(avctx);", "          s->initialized = 1;", "        if (s->has_alpha)", "            avctx->pix_fmt = AV_PIX_FMT_YUVA420P;", "      }", "     avctx->pix_fmt = s->has_alpha ? AV_PIX_FMT_YUVA420P : AV_PIX_FMT_YUV420P;", "      s->lossless = 0;", "      if (data_size > INT_MAX) {", "         av_log(avctx, AV_LOG_ERROR, \"unsupported chunk size\\n\");", "         return AVERROR_PATCHWELCOME;", "     }", "     av_init_packet(&pkt);", "     pkt.data = data_start;", "     pkt.size = data_size;", "     ret = ff_vp8_decode_frame(avctx, p, got_frame, &pkt);", "     if (ret < 0)", "         return ret;", "     update_canvas_size(avctx, avctx->width, avctx->height);", "     if (s->has_alpha) {", "         ret = vp8_lossy_decode_alpha(avctx, p, s->alpha_data,", "                                      s->alpha_data_size);", "         if (ret < 0)", "             return ret;", "     }", "     return ret;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" yyparse (void *yyscanner, YR_COMPILER* compiler)", " {", " int yychar;", " YY_INITIAL_VALUE (static YYSTYPE yyval_default;)", " YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);", "     int yynerrs;", "     int yystate;", "     int yyerrstatus;", "     yytype_int16 yyssa[YYINITDEPTH];", "     yytype_int16 *yyss;", "     yytype_int16 *yyssp;", "     YYSTYPE yyvsa[YYINITDEPTH];", "     YYSTYPE *yyvs;", "     YYSTYPE *yyvsp;", "     YYSIZE_T yystacksize;", "   int yyn;", "   int yyresult;", "   int yytoken = 0;", "   YYSTYPE yyval;", " #if YYERROR_VERBOSE", "   char yymsgbuf[128];", "   char *yymsg = yymsgbuf;", "   YYSIZE_T yymsg_alloc = sizeof yymsgbuf;", " #endif", " #define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))", "   int yylen = 0;", "   yyssp = yyss = yyssa;", "   yyvsp = yyvs = yyvsa;", "   yystacksize = YYINITDEPTH;", "   YYDPRINTF ((stderr, \"Starting parse\\n\"));", "   yystate = 0;", "   yyerrstatus = 0;", "   yynerrs = 0;", "   yychar = YYEMPTY;  ", "   goto yysetstate;", "  yynewstate:", "   yyssp++;", "  yysetstate:", "   *yyssp = yystate;", "   if (yyss + yystacksize - 1 <= yyssp)", "     {", "       YYSIZE_T yysize = yyssp - yyss + 1;", " #ifdef yyoverflow", "       {", "         YYSTYPE *yyvs1 = yyvs;", "         yytype_int16 *yyss1 = yyss;", "         yyoverflow (YY_(\"memory exhausted\"),", "                     &yyss1, yysize * sizeof (*yyssp),", "                     &yyvs1, yysize * sizeof (*yyvsp),", "                     &yystacksize);", "         yyss = yyss1;", "         yyvs = yyvs1;", "       }", " #else  ", " # ifndef YYSTACK_RELOCATE", "       goto yyexhaustedlab;", " # else", "       if (YYMAXDEPTH <= yystacksize)", "         goto yyexhaustedlab;", "       yystacksize *= 2;", "       if (YYMAXDEPTH < yystacksize)", "         yystacksize = YYMAXDEPTH;", "       {", "         yytype_int16 *yyss1 = yyss;", "         union yyalloc *yyptr =", "           (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));", "         if (! yyptr)", "           goto yyexhaustedlab;", "         YYSTACK_RELOCATE (yyss_alloc, yyss);", "         YYSTACK_RELOCATE (yyvs_alloc, yyvs);", " #  undef YYSTACK_RELOCATE", "         if (yyss1 != yyssa)", "           YYSTACK_FREE (yyss1);", "       }", " # endif", " #endif  ", "       yyssp = yyss + yysize - 1;", "       yyvsp = yyvs + yysize - 1;", "       YYDPRINTF ((stderr, \"Stack size increased to %lu\\n\",", "                   (unsigned long int) yystacksize));", "       if (yyss + yystacksize - 1 <= yyssp)", "         YYABORT;", "     }", "   YYDPRINTF ((stderr, \"Entering state %d\\n\", yystate));", "   if (yystate == YYFINAL)", "     YYACCEPT;", "   goto yybackup;", " yybackup:", "   yyn = yypact[yystate];", "   if (yypact_value_is_default (yyn))", "     goto yydefault;", "   if (yychar == YYEMPTY)", "     {", "       YYDPRINTF ((stderr, \"Reading a token: \"));", "       yychar = yylex (&yylval, yyscanner, compiler);", "     }", "   if (yychar <= YYEOF)", "     {", "       yychar = yytoken = YYEOF;", "       YYDPRINTF ((stderr, \"Now at end of input.\\n\"));", "     }", "   else", "     {", "       yytoken = YYTRANSLATE (yychar);", "       YY_SYMBOL_PRINT (\"Next token is\", yytoken, &yylval, &yylloc);", "     }", "   yyn += yytoken;", "   if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)", "     goto yydefault;", "   yyn = yytable[yyn];", "   if (yyn <= 0)", "     {", "       if (yytable_value_is_error (yyn))", "         goto yyerrlab;", "       yyn = -yyn;", "       goto yyreduce;", "     }", "   if (yyerrstatus)", "     yyerrstatus--;", "   YY_SYMBOL_PRINT (\"Shifting\", yytoken, &yylval, &yylloc);", "   yychar = YYEMPTY;", "   yystate = yyn;", "   YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN", "   *++yyvsp = yylval;", "   YY_IGNORE_MAYBE_UNINITIALIZED_END", "   goto yynewstate;", " yydefault:", "   yyn = yydefact[yystate];", "   if (yyn == 0)", "     goto yyerrlab;", "   goto yyreduce;", " yyreduce:", "   yylen = yyr2[yyn];", "   yyval = yyvsp[1-yylen];", "   YY_REDUCE_PRINT (yyn);", "   switch (yyn)", "     {", "         case 8:", " #line 230 \"grammar.y\"  ", "     {", "         int result = yr_parser_reduce_import(yyscanner, (yyvsp[0].sized_string));", "         yr_free((yyvsp[0].sized_string));", "         ERROR_IF(result != ERROR_SUCCESS);", "       }", " #line 1661 \"grammar.c\"  ", "     break;", "   case 9:", " #line 242 \"grammar.y\"  ", "     {", "         YR_RULE* rule = yr_parser_reduce_rule_declaration_phase_1(", "             yyscanner, (int32_t) (yyvsp[-2].integer), (yyvsp[0].c_string));", "         ERROR_IF(rule == NULL);", "         (yyval.rule) = rule;", "       }", " #line 1674 \"grammar.c\"  ", "     break;", "   case 10:", " #line 251 \"grammar.y\"  ", "     {", "         YR_RULE* rule = (yyvsp[-4].rule);  ", "         rule->tags = (yyvsp[-3].c_string);", "         rule->metas = (yyvsp[-1].meta);", "         rule->strings = (yyvsp[0].string);", "       }", " #line 1686 \"grammar.c\"  ", "     break;", "   case 11:", " #line 259 \"grammar.y\"  ", "     {", "         YR_RULE* rule = (yyvsp[-7].rule);  ", "         compiler->last_result = yr_parser_reduce_rule_declaration_phase_2(", "             yyscanner, rule);", "         yr_free((yyvsp[-8].c_string));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "       }", " #line 1701 \"grammar.c\"  ", "     break;", "   case 12:", " #line 274 \"grammar.y\"  ", "     {", "         (yyval.meta) = NULL;", "       }", " #line 1709 \"grammar.c\"  ", "     break;", "   case 13:", " #line 278 \"grammar.y\"  ", "     {", "         YR_META null_meta;", "         memset(&null_meta, 0xFF, sizeof(YR_META));", "         null_meta.type = META_TYPE_NULL;", "         compiler->last_result = yr_arena_write_data(", "             compiler->metas_arena,", "             &null_meta,", "             sizeof(YR_META),", "             NULL);", "         (yyval.meta) = (yyvsp[0].meta);", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "       }", " #line 1736 \"grammar.c\"  ", "     break;", "   case 14:", " #line 305 \"grammar.y\"  ", "     {", "         (yyval.string) = NULL;", "       }", " #line 1744 \"grammar.c\"  ", "     break;", "   case 15:", " #line 309 \"grammar.y\"  ", "     {", "         YR_STRING null_string;", "         memset(&null_string, 0xFF, sizeof(YR_STRING));", "         null_string.g_flags = STRING_GFLAGS_NULL;", "         compiler->last_result = yr_arena_write_data(", "             compiler->strings_arena,", "             &null_string,", "             sizeof(YR_STRING),", "             NULL);", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         (yyval.string) = (yyvsp[0].string);", "       }", " #line 1771 \"grammar.c\"  ", "     break;", "   case 17:", " #line 340 \"grammar.y\"  ", "     { (yyval.integer) = 0;  }", " #line 1777 \"grammar.c\"  ", "     break;", "   case 18:", " #line 341 \"grammar.y\"  ", "     { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }", " #line 1783 \"grammar.c\"  ", "     break;", "   case 19:", " #line 346 \"grammar.y\"  ", "     { (yyval.integer) = RULE_GFLAGS_PRIVATE; }", " #line 1789 \"grammar.c\"  ", "     break;", "   case 20:", " #line 347 \"grammar.y\"  ", "     { (yyval.integer) = RULE_GFLAGS_GLOBAL; }", " #line 1795 \"grammar.c\"  ", "     break;", "   case 21:", " #line 353 \"grammar.y\"  ", "     {", "         (yyval.c_string) = NULL;", "       }", " #line 1803 \"grammar.c\"  ", "     break;", "   case 22:", " #line 357 \"grammar.y\"  ", "     {", "         compiler->last_result = yr_arena_write_string(", "             yyget_extra(yyscanner)->sz_arena, \"\", NULL);", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         (yyval.c_string) = (yyvsp[0].c_string);", "       }", " #line 1821 \"grammar.c\"  ", "     break;", "   case 23:", " #line 375 \"grammar.y\"  ", "     {", "         char* identifier;", "         compiler->last_result = yr_arena_write_string(", "             yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), &identifier);", "         yr_free((yyvsp[0].c_string));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         (yyval.c_string) = identifier;", "       }", " #line 1838 \"grammar.c\"  ", "     break;", "   case 24:", " #line 388 \"grammar.y\"  ", "     {", "         char* tag_name = (yyvsp[-1].c_string);", "         size_t tag_length = tag_name != NULL ? strlen(tag_name) : 0;", "         while (tag_length > 0)", "         {", "           if (strcmp(tag_name, (yyvsp[0].c_string)) == 0)", "           {", "             yr_compiler_set_error_extra_info(compiler, tag_name);", "             compiler->last_result = ERROR_DUPLICATED_TAG_IDENTIFIER;", "             break;", "           }", "           tag_name = (char*) yr_arena_next_address(", "               yyget_extra(yyscanner)->sz_arena,", "               tag_name,", "               tag_length + 1);", "           tag_length = tag_name != NULL ? strlen(tag_name) : 0;", "         }", "         if (compiler->last_result == ERROR_SUCCESS)", "           compiler->last_result = yr_arena_write_string(", "               yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), NULL);", "         yr_free((yyvsp[0].c_string));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         (yyval.c_string) = (yyvsp[-1].c_string);", "       }", " #line 1874 \"grammar.c\"  ", "     break;", "   case 25:", " #line 424 \"grammar.y\"  ", "     {  (yyval.meta) = (yyvsp[0].meta); }", " #line 1880 \"grammar.c\"  ", "     break;", "   case 26:", " #line 425 \"grammar.y\"  ", "     {  (yyval.meta) = (yyvsp[-1].meta); }", " #line 1886 \"grammar.c\"  ", "     break;", "   case 27:", " #line 431 \"grammar.y\"  ", "     {", "         SIZED_STRING* sized_string = (yyvsp[0].sized_string);", "         (yyval.meta) = yr_parser_reduce_meta_declaration(", "             yyscanner,", "             META_TYPE_STRING,", "             (yyvsp[-2].c_string),", "             sized_string->c_string,", "             0);", "         yr_free((yyvsp[-2].c_string));", "         yr_free((yyvsp[0].sized_string));", "         ERROR_IF((yyval.meta) == NULL);", "       }", " #line 1906 \"grammar.c\"  ", "     break;", "   case 28:", " #line 447 \"grammar.y\"  ", "     {", "         (yyval.meta) = yr_parser_reduce_meta_declaration(", "             yyscanner,", "             META_TYPE_INTEGER,", "             (yyvsp[-2].c_string),", "             NULL,", "             (yyvsp[0].integer));", "         yr_free((yyvsp[-2].c_string));", "         ERROR_IF((yyval.meta) == NULL);", "       }", " #line 1923 \"grammar.c\"  ", "     break;", "   case 29:", " #line 460 \"grammar.y\"  ", "     {", "         (yyval.meta) = yr_parser_reduce_meta_declaration(", "             yyscanner,", "             META_TYPE_INTEGER,", "             (yyvsp[-3].c_string),", "             NULL,", "             -(yyvsp[0].integer));", "         yr_free((yyvsp[-3].c_string));", "         ERROR_IF((yyval.meta) == NULL);", "       }", " #line 1940 \"grammar.c\"  ", "     break;", "   case 30:", " #line 473 \"grammar.y\"  ", "     {", "         (yyval.meta) = yr_parser_reduce_meta_declaration(", "             yyscanner,", "             META_TYPE_BOOLEAN,", "             (yyvsp[-2].c_string),", "             NULL,", "             TRUE);", "         yr_free((yyvsp[-2].c_string));", "         ERROR_IF((yyval.meta) == NULL);", "       }", " #line 1957 \"grammar.c\"  ", "     break;", "   case 31:", " #line 486 \"grammar.y\"  ", "     {", "         (yyval.meta) = yr_parser_reduce_meta_declaration(", "             yyscanner,", "             META_TYPE_BOOLEAN,", "             (yyvsp[-2].c_string),", "             NULL,", "             FALSE);", "         yr_free((yyvsp[-2].c_string));", "         ERROR_IF((yyval.meta) == NULL);", "       }", " #line 1974 \"grammar.c\"  ", "     break;", "   case 32:", " #line 502 \"grammar.y\"  ", "     { (yyval.string) = (yyvsp[0].string); }", " #line 1980 \"grammar.c\"  ", "     break;", "   case 33:", " #line 503 \"grammar.y\"  ", "     { (yyval.string) = (yyvsp[-1].string); }", " #line 1986 \"grammar.c\"  ", "     break;", "   case 34:", " #line 509 \"grammar.y\"  ", "     {", "         compiler->error_line = yyget_lineno(yyscanner);", "       }", " #line 1994 \"grammar.c\"  ", "     break;", "   case 35:", " #line 513 \"grammar.y\"  ", "     {", "         (yyval.string) = yr_parser_reduce_string_declaration(", "             yyscanner, (int32_t) (yyvsp[0].integer), (yyvsp[-4].c_string), (yyvsp[-1].sized_string));", "         yr_free((yyvsp[-4].c_string));", "         yr_free((yyvsp[-1].sized_string));", "         ERROR_IF((yyval.string) == NULL);", "         compiler->error_line = 0;", "       }", " #line 2009 \"grammar.c\"  ", "     break;", "   case 36:", " #line 524 \"grammar.y\"  ", "     {", "         compiler->error_line = yyget_lineno(yyscanner);", "       }", " #line 2017 \"grammar.c\"  ", "     break;", "   case 37:", " #line 528 \"grammar.y\"  ", "     {", "         (yyval.string) = yr_parser_reduce_string_declaration(", "             yyscanner, (int32_t) (yyvsp[0].integer) | STRING_GFLAGS_REGEXP, (yyvsp[-4].c_string), (yyvsp[-1].sized_string));", "         yr_free((yyvsp[-4].c_string));", "         yr_free((yyvsp[-1].sized_string));", "         ERROR_IF((yyval.string) == NULL);", "         compiler->error_line = 0;", "       }", " #line 2033 \"grammar.c\"  ", "     break;", "   case 38:", " #line 540 \"grammar.y\"  ", "     {", "         (yyval.string) = yr_parser_reduce_string_declaration(", "             yyscanner, STRING_GFLAGS_HEXADECIMAL, (yyvsp[-2].c_string), (yyvsp[0].sized_string));", "         yr_free((yyvsp[-2].c_string));", "         yr_free((yyvsp[0].sized_string));", "         ERROR_IF((yyval.string) == NULL);", "       }", " #line 2047 \"grammar.c\"  ", "     break;", "   case 39:", " #line 553 \"grammar.y\"  ", "     { (yyval.integer) = 0; }", " #line 2053 \"grammar.c\"  ", "     break;", "   case 40:", " #line 554 \"grammar.y\"  ", "     { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }", " #line 2059 \"grammar.c\"  ", "     break;", "   case 41:", " #line 559 \"grammar.y\"  ", "     { (yyval.integer) = STRING_GFLAGS_WIDE; }", " #line 2065 \"grammar.c\"  ", "     break;", "   case 42:", " #line 560 \"grammar.y\"  ", "     { (yyval.integer) = STRING_GFLAGS_ASCII; }", " #line 2071 \"grammar.c\"  ", "     break;", "   case 43:", " #line 561 \"grammar.y\"  ", "     { (yyval.integer) = STRING_GFLAGS_NO_CASE; }", " #line 2077 \"grammar.c\"  ", "     break;", "   case 44:", " #line 562 \"grammar.y\"  ", "     { (yyval.integer) = STRING_GFLAGS_FULL_WORD; }", " #line 2083 \"grammar.c\"  ", "     break;", "   case 45:", " #line 568 \"grammar.y\"  ", "     {", "         int var_index = yr_parser_lookup_loop_variable(yyscanner, (yyvsp[0].c_string));", "         if (var_index >= 0)", "         {", "           compiler->last_result = yr_parser_emit_with_arg(", "               yyscanner,", "               OP_PUSH_M,", "               LOOP_LOCAL_VARS * var_index,", "               NULL,", "               NULL);", "           (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "           (yyval.expression).value.integer = UNDEFINED;", "           (yyval.expression).identifier = compiler->loop_identifier[var_index];", "         }", "         else", "         {", "           YR_OBJECT* object = (YR_OBJECT*) yr_hash_table_lookup(", "               compiler->objects_table, (yyvsp[0].c_string), NULL);", "           if (object == NULL)", "           {", "             char* ns = compiler->current_namespace->name;", "             object = (YR_OBJECT*) yr_hash_table_lookup(", "                 compiler->objects_table, (yyvsp[0].c_string), ns);", "           }", "           if (object != NULL)", "           {", "             char* id;", "             compiler->last_result = yr_arena_write_string(", "                 compiler->sz_arena, (yyvsp[0].c_string), &id);", "             if (compiler->last_result == ERROR_SUCCESS)", "               compiler->last_result = yr_parser_emit_with_arg_reloc(", "                   yyscanner,", "                   OP_OBJ_LOAD,", "                   id,", "                   NULL,", "                   NULL);", "             (yyval.expression).type = EXPRESSION_TYPE_OBJECT;", "             (yyval.expression).value.object = object;", "             (yyval.expression).identifier = object->identifier;", "           }", "           else", "           {", "             YR_RULE* rule = (YR_RULE*) yr_hash_table_lookup(", "                 compiler->rules_table,", "                 (yyvsp[0].c_string),", "                 compiler->current_namespace->name);", "             if (rule != NULL)", "             {", "               compiler->last_result = yr_parser_emit_with_arg_reloc(", "                   yyscanner,", "                   OP_PUSH_RULE,", "                   rule,", "                   NULL,", "                   NULL);", "               (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "               (yyval.expression).value.integer = UNDEFINED;", "               (yyval.expression).identifier = rule->identifier;", "             }", "             else", "             {", "               yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));", "               compiler->last_result = ERROR_UNDEFINED_IDENTIFIER;", "             }", "           }", "         }", "         yr_free((yyvsp[0].c_string));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "       }", " #line 2172 \"grammar.c\"  ", "     break;", "   case 46:", " #line 653 \"grammar.y\"  ", "     {", "         YR_OBJECT* field = NULL;", "         if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_OBJECT &&", "             (yyvsp[-2].expression).value.object->type == OBJECT_TYPE_STRUCTURE)", "         {", "           field = yr_object_lookup_field((yyvsp[-2].expression).value.object, (yyvsp[0].c_string));", "           if (field != NULL)", "           {", "             char* ident;", "             compiler->last_result = yr_arena_write_string(", "               compiler->sz_arena, (yyvsp[0].c_string), &ident);", "             if (compiler->last_result == ERROR_SUCCESS)", "               compiler->last_result = yr_parser_emit_with_arg_reloc(", "                   yyscanner,", "                   OP_OBJ_FIELD,", "                   ident,", "                   NULL,", "                   NULL);", "             (yyval.expression).type = EXPRESSION_TYPE_OBJECT;", "             (yyval.expression).value.object = field;", "             (yyval.expression).identifier = field->identifier;", "           }", "           else", "           {", "             yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));", "             compiler->last_result = ERROR_INVALID_FIELD_NAME;", "           }", "         }", "         else", "         {", "           yr_compiler_set_error_extra_info(", "               compiler, (yyvsp[-2].expression).identifier);", "           compiler->last_result = ERROR_NOT_A_STRUCTURE;", "         }", "         yr_free((yyvsp[0].c_string));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "       }", " #line 2222 \"grammar.c\"  ", "     break;", "   case 47:", " #line 699 \"grammar.y\"  ", "     {", "         YR_OBJECT_ARRAY* array;", "         YR_OBJECT_DICTIONARY* dict;", "         if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&", "             (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_ARRAY)", "         {", "           if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)", "           {", "             yr_compiler_set_error_extra_info(", "                 compiler, \"array indexes must be of integer type\");", "             compiler->last_result = ERROR_WRONG_TYPE;", "           }", "           ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "           compiler->last_result = yr_parser_emit(", "               yyscanner, OP_INDEX_ARRAY, NULL);", "           array = (YR_OBJECT_ARRAY*) (yyvsp[-3].expression).value.object;", "           (yyval.expression).type = EXPRESSION_TYPE_OBJECT;", "           (yyval.expression).value.object = array->prototype_item;", "           (yyval.expression).identifier = array->identifier;", "         }", "         else if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&", "                  (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_DICTIONARY)", "         {", "           if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_STRING)", "           {", "             yr_compiler_set_error_extra_info(", "                 compiler, \"dictionary keys must be of string type\");", "             compiler->last_result = ERROR_WRONG_TYPE;", "           }", "           ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "           compiler->last_result = yr_parser_emit(", "               yyscanner, OP_LOOKUP_DICT, NULL);", "           dict = (YR_OBJECT_DICTIONARY*) (yyvsp[-3].expression).value.object;", "           (yyval.expression).type = EXPRESSION_TYPE_OBJECT;", "           (yyval.expression).value.object = dict->prototype_item;", "           (yyval.expression).identifier = dict->identifier;", "         }", "         else", "         {", "           yr_compiler_set_error_extra_info(", "               compiler, (yyvsp[-3].expression).identifier);", "           compiler->last_result = ERROR_NOT_INDEXABLE;", "         }", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "       }", " #line 2283 \"grammar.c\"  ", "     break;", "   case 48:", " #line 757 \"grammar.y\"  ", "     {", "         YR_OBJECT_FUNCTION* function;", "         char* args_fmt;", "         if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&", "             (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_FUNCTION)", "         {", "           compiler->last_result = yr_parser_check_types(", "               compiler, (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object, (yyvsp[-1].c_string));", "           if (compiler->last_result == ERROR_SUCCESS)", "             compiler->last_result = yr_arena_write_string(", "               compiler->sz_arena, (yyvsp[-1].c_string), &args_fmt);", "           if (compiler->last_result == ERROR_SUCCESS)", "             compiler->last_result = yr_parser_emit_with_arg_reloc(", "                 yyscanner,", "                 OP_CALL,", "                 args_fmt,", "                 NULL,", "                 NULL);", "           function = (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object;", "           (yyval.expression).type = EXPRESSION_TYPE_OBJECT;", "           (yyval.expression).value.object = function->return_obj;", "           (yyval.expression).identifier = function->identifier;", "         }", "         else", "         {", "           yr_compiler_set_error_extra_info(", "               compiler, (yyvsp[-3].expression).identifier);", "           compiler->last_result = ERROR_NOT_A_FUNCTION;", "         }", "         yr_free((yyvsp[-1].c_string));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "       }", " #line 2328 \"grammar.c\"  ", "     break;", "   case 49:", " #line 801 \"grammar.y\"  ", "     { (yyval.c_string) = yr_strdup(\"\"); }", " #line 2334 \"grammar.c\"  ", "     break;", "   case 50:", " #line 802 \"grammar.y\"  ", "     { (yyval.c_string) = (yyvsp[0].c_string); }", " #line 2340 \"grammar.c\"  ", "     break;", "   case 51:", " #line 807 \"grammar.y\"  ", "     {", "         (yyval.c_string) = (char*) yr_malloc(MAX_FUNCTION_ARGS + 1);", "         switch((yyvsp[0].expression).type)", "         {", "           case EXPRESSION_TYPE_INTEGER:", "             strlcpy((yyval.c_string), \"i\", MAX_FUNCTION_ARGS);", "             break;", "           case EXPRESSION_TYPE_FLOAT:", "             strlcpy((yyval.c_string), \"f\", MAX_FUNCTION_ARGS);", "             break;", "           case EXPRESSION_TYPE_BOOLEAN:", "             strlcpy((yyval.c_string), \"b\", MAX_FUNCTION_ARGS);", "             break;", "           case EXPRESSION_TYPE_STRING:", "             strlcpy((yyval.c_string), \"s\", MAX_FUNCTION_ARGS);", "             break;", "            case EXPRESSION_TYPE_REGEXP:", "              strlcpy((yyval.c_string), \"r\", MAX_FUNCTION_ARGS);", "              break;", "           default:", "             assert(FALSE);", "          }", "          ERROR_IF((yyval.c_string) == NULL);", "        }", "#line 2369 \"grammar.c\"  ", " #line 2371 \"grammar.c\"  ", "      break;", "    case 52:", "#line 832 \"grammar.y\"  ", " #line 834 \"grammar.y\"  ", "      {", "          if (strlen((yyvsp[-2].c_string)) == MAX_FUNCTION_ARGS)", "          {", "           compiler->last_result = ERROR_TOO_MANY_ARGUMENTS;", "         }", "         else", "         {", "           switch((yyvsp[0].expression).type)", "           {", "             case EXPRESSION_TYPE_INTEGER:", "               strlcat((yyvsp[-2].c_string), \"i\", MAX_FUNCTION_ARGS);", "               break;", "             case EXPRESSION_TYPE_FLOAT:", "               strlcat((yyvsp[-2].c_string), \"f\", MAX_FUNCTION_ARGS);", "               break;", "             case EXPRESSION_TYPE_BOOLEAN:", "               strlcat((yyvsp[-2].c_string), \"b\", MAX_FUNCTION_ARGS);", "               break;", "             case EXPRESSION_TYPE_STRING:", "               strlcat((yyvsp[-2].c_string), \"s\", MAX_FUNCTION_ARGS);", "               break;", "              case EXPRESSION_TYPE_REGEXP:", "                strlcat((yyvsp[-2].c_string), \"r\", MAX_FUNCTION_ARGS);", "                break;", "             default:", "               assert(FALSE);", "            }", "          }", "          ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          (yyval.c_string) = (yyvsp[-2].c_string);", "        }", "#line 2405 \"grammar.c\"  ", " #line 2409 \"grammar.c\"  ", "      break;", "    case 53:", "#line 868 \"grammar.y\"  ", " #line 872 \"grammar.y\"  ", "      {", "          SIZED_STRING* sized_string = (yyvsp[0].sized_string);", "          RE* re;", "         RE_ERROR error;", "         int re_flags = 0;", "         if (sized_string->flags & SIZED_STRING_FLAGS_NO_CASE)", "           re_flags |= RE_FLAGS_NO_CASE;", "         if (sized_string->flags & SIZED_STRING_FLAGS_DOT_ALL)", "           re_flags |= RE_FLAGS_DOT_ALL;", "         compiler->last_result = yr_re_compile(", "             sized_string->c_string,", "             re_flags,", "             compiler->re_code_arena,", "             &re,", "             &error);", "         yr_free((yyvsp[0].sized_string));", "         if (compiler->last_result == ERROR_INVALID_REGULAR_EXPRESSION)", "           yr_compiler_set_error_extra_info(compiler, error.message);", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         if (compiler->last_result == ERROR_SUCCESS)", "           compiler->last_result = yr_parser_emit_with_arg_reloc(", "               yyscanner,", "               OP_PUSH,", "               re->root_node->forward_code,", "               NULL,", "               NULL);", "         yr_re_destroy(re);", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          (yyval.expression).type = EXPRESSION_TYPE_REGEXP;", "        }", "#line 2451 \"grammar.c\"  ", " #line 2455 \"grammar.c\"  ", "      break;", "    case 54:", "#line 914 \"grammar.y\"  ", " #line 918 \"grammar.y\"  ", "      {", "          if ((yyvsp[0].expression).type == EXPRESSION_TYPE_STRING)", "          {", "           if ((yyvsp[0].expression).value.sized_string != NULL)", "           {", "             yywarning(yyscanner,", "               \"Using literal string \\\"%s\\\" in a boolean operation.\",", "               (yyvsp[0].expression).value.sized_string->c_string);", "           }", "           compiler->last_result = yr_parser_emit(", "               yyscanner, OP_STR_TO_BOOL, NULL);", "           ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         }", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "        }", "#line 2474 \"grammar.c\"  ", " #line 2478 \"grammar.c\"  ", "      break;", "    case 55:", "#line 936 \"grammar.y\"  ", " #line 940 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_emit_with_arg(", "              yyscanner, OP_PUSH, 1, NULL, NULL);", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "        }", "#line 2487 \"grammar.c\"  ", " #line 2491 \"grammar.c\"  ", "      break;", "    case 56:", "#line 945 \"grammar.y\"  ", " #line 949 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_emit_with_arg(", "              yyscanner, OP_PUSH, 0, NULL, NULL);", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "        }", "#line 2500 \"grammar.c\"  ", " #line 2504 \"grammar.c\"  ", "      break;", "    case 57:", "#line 954 \"grammar.y\"  ", " #line 958 \"grammar.y\"  ", "      {", "          CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, \"matches\");", "          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_REGEXP, \"matches\");", "         if (compiler->last_result == ERROR_SUCCESS)", "           compiler->last_result = yr_parser_emit(", "               yyscanner,", "               OP_MATCHES,", "               NULL);", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "        }", "#line 2519 \"grammar.c\"  ", " #line 2523 \"grammar.c\"  ", "      break;", "    case 58:", "#line 969 \"grammar.y\"  ", " #line 973 \"grammar.y\"  ", "      {", "          CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, \"contains\");", "          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_STRING, \"contains\");", "         compiler->last_result = yr_parser_emit(", "             yyscanner, OP_CONTAINS, NULL);", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "        }", "#line 2535 \"grammar.c\"  ", " #line 2539 \"grammar.c\"  ", "      break;", "    case 59:", "#line 981 \"grammar.y\"  ", " #line 985 \"grammar.y\"  ", "      {", "          int result = yr_parser_reduce_string_identifier(", "              yyscanner,", "             (yyvsp[0].c_string),", "             OP_FOUND,", "             UNDEFINED);", "         yr_free((yyvsp[0].c_string));", "         ERROR_IF(result != ERROR_SUCCESS);", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "        }", "#line 2553 \"grammar.c\"  ", " #line 2557 \"grammar.c\"  ", "      break;", "    case 60:", "#line 995 \"grammar.y\"  ", " #line 999 \"grammar.y\"  ", "      {", "          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"at\");", "         compiler->last_result = yr_parser_reduce_string_identifier(", "             yyscanner, (yyvsp[-2].c_string), OP_FOUND_AT, (yyvsp[0].expression).value.integer);", "         yr_free((yyvsp[-2].c_string));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "        }", "#line 2570 \"grammar.c\"  ", " #line 2574 \"grammar.c\"  ", "      break;", "    case 61:", "#line 1008 \"grammar.y\"  ", " #line 1012 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_reduce_string_identifier(", "              yyscanner, (yyvsp[-2].c_string), OP_FOUND_IN, UNDEFINED);", "         yr_free((yyvsp[-2].c_string));", "         ERROR_IF(compiler->last_result!= ERROR_SUCCESS);", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "        }", "#line 2585 \"grammar.c\"  ", " #line 2589 \"grammar.c\"  ", "      break;", "    case 62:", "#line 1019 \"grammar.y\"  ", " #line 1023 \"grammar.y\"  ", "      {", "          if (compiler->loop_depth > 0)", "          {", "            compiler->loop_depth--;", "            compiler->loop_identifier[compiler->loop_depth] = NULL;", "          }", "         YYERROR;", "        }", "#line 2597 \"grammar.c\"  ", " #line 2603 \"grammar.c\"  ", "      break;", "    case 63:", "#line 1027 \"grammar.y\"  ", " #line 1033 \"grammar.y\"  ", "      {", "          int var_index;", "         if (compiler->loop_depth == MAX_LOOP_NESTING)", "           compiler->last_result = \\", "               ERROR_LOOP_NESTING_LIMIT_EXCEEDED;", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         var_index = yr_parser_lookup_loop_variable(", "             yyscanner, (yyvsp[-1].c_string));", "         if (var_index >= 0)", "         {", "           yr_compiler_set_error_extra_info(", "               compiler, (yyvsp[-1].c_string));", "           compiler->last_result = \\", "               ERROR_DUPLICATED_LOOP_IDENTIFIER;", "         }", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         compiler->last_result = yr_parser_emit_with_arg(", "             yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);", "          ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "        }", "#line 2631 \"grammar.c\"  ", " #line 2637 \"grammar.c\"  ", "      break;", "    case 64:", "#line 1057 \"grammar.y\"  ", " #line 1063 \"grammar.y\"  ", "      {", "          int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;", "          uint8_t* addr;", "         yr_parser_emit_with_arg(", "             yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);", "         yr_parser_emit_with_arg(", "             yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);", "         if ((yyvsp[-1].integer) == INTEGER_SET_ENUMERATION)", "         {", "           yr_parser_emit_with_arg(", "               yyscanner, OP_POP_M, mem_offset, &addr, NULL);", "         }", "         else  ", "         {", "           yr_parser_emit_with_arg(", "               yyscanner, OP_POP_M, mem_offset + 3, &addr, NULL);", "           yr_parser_emit_with_arg(", "               yyscanner, OP_POP_M, mem_offset, NULL, NULL);", "         }", "         compiler->loop_address[compiler->loop_depth] = addr;", "          compiler->loop_identifier[compiler->loop_depth] = (yyvsp[-4].c_string);", "          compiler->loop_depth++;", "        }", "#line 2670 \"grammar.c\"  ", " #line 2676 \"grammar.c\"  ", "      break;", "    case 65:", "#line 1092 \"grammar.y\"  ", " #line 1098 \"grammar.y\"  ", "      {", "          int mem_offset;", "         compiler->loop_depth--;", "         mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;", "         yr_parser_emit_with_arg(", "             yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);", "         yr_parser_emit_with_arg(", "             yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);", "         if ((yyvsp[-5].integer) == INTEGER_SET_ENUMERATION)", "         {", "           yr_parser_emit_with_arg_reloc(", "               yyscanner,", "               OP_JNUNDEF,", "               compiler->loop_address[compiler->loop_depth],", "               NULL,", "               NULL);", "         }", "         else  ", "         {", "           yr_parser_emit_with_arg(", "               yyscanner, OP_INCR_M, mem_offset, NULL, NULL);", "           yr_parser_emit_with_arg(", "               yyscanner, OP_PUSH_M, mem_offset, NULL, NULL);", "           yr_parser_emit_with_arg(", "               yyscanner, OP_PUSH_M, mem_offset + 3, NULL, NULL);", "           yr_parser_emit_with_arg_reloc(", "               yyscanner,", "               OP_JLE,", "               compiler->loop_address[compiler->loop_depth],", "               NULL,", "               NULL);", "           yr_parser_emit(yyscanner, OP_POP, NULL);", "           yr_parser_emit(yyscanner, OP_POP, NULL);", "         }", "         yr_parser_emit(yyscanner, OP_POP, NULL);", "         yr_parser_emit_with_arg(", "             yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);", "         yr_parser_emit_with_arg(", "             yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);", "         yr_parser_emit(yyscanner, OP_INT_LE, NULL);", "         compiler->loop_identifier[compiler->loop_depth] = NULL;", "         yr_free((yyvsp[-8].c_string));", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "        }", "#line 2753 \"grammar.c\"  ", " #line 2759 \"grammar.c\"  ", "      break;", "    case 66:", "#line 1171 \"grammar.y\"  ", " #line 1177 \"grammar.y\"  ", "      {", "          int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;", "          uint8_t* addr;", "         if (compiler->loop_depth == MAX_LOOP_NESTING)", "           compiler->last_result = \\", "             ERROR_LOOP_NESTING_LIMIT_EXCEEDED;", "         if (compiler->loop_for_of_mem_offset != -1)", "           compiler->last_result = \\", "             ERROR_NESTED_FOR_OF_LOOP;", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         yr_parser_emit_with_arg(", "             yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);", "         yr_parser_emit_with_arg(", "             yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);", "         yr_parser_emit_with_arg(", "             yyscanner, OP_POP_M, mem_offset, &addr, NULL);", "         compiler->loop_for_of_mem_offset = mem_offset;", "         compiler->loop_address[compiler->loop_depth] = addr;", "          compiler->loop_identifier[compiler->loop_depth] = NULL;", "          compiler->loop_depth++;", "        }", "#line 2787 \"grammar.c\"  ", " #line 2793 \"grammar.c\"  ", "      break;", "    case 67:", "#line 1201 \"grammar.y\"  ", " #line 1207 \"grammar.y\"  ", "      {", "          int mem_offset;", "         compiler->loop_depth--;", "         compiler->loop_for_of_mem_offset = -1;", "         mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;", "         yr_parser_emit_with_arg(", "             yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);", "         yr_parser_emit_with_arg(", "             yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);", "         yr_parser_emit_with_arg_reloc(", "             yyscanner,", "             OP_JNUNDEF,", "             compiler->loop_address[compiler->loop_depth],", "             NULL,", "             NULL);", "         yr_parser_emit(yyscanner, OP_POP, NULL);", "         yr_parser_emit_with_arg(", "             yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);", "         yr_parser_emit_with_arg(", "             yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);", "         yr_parser_emit(yyscanner, OP_INT_LE, NULL);", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "        }", "#line 2840 \"grammar.c\"  ", " #line 2846 \"grammar.c\"  ", "      break;", "    case 68:", "#line 1250 \"grammar.y\"  ", " #line 1256 \"grammar.y\"  ", "      {", "          yr_parser_emit(yyscanner, OP_OF, NULL);", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "        }", "#line 2850 \"grammar.c\"  ", " #line 2856 \"grammar.c\"  ", "      break;", "    case 69:", "#line 1256 \"grammar.y\"  ", " #line 1262 \"grammar.y\"  ", "      {", "          yr_parser_emit(yyscanner, OP_NOT, NULL);", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "        }", "#line 2860 \"grammar.c\"  ", " #line 2866 \"grammar.c\"  ", "      break;", "    case 70:", "#line 1262 \"grammar.y\"  ", " #line 1268 \"grammar.y\"  ", "      {", "          YR_FIXUP* fixup;", "          void* jmp_destination_addr;", "         compiler->last_result = yr_parser_emit_with_arg_reloc(", "             yyscanner,", "             OP_JFALSE,", "             0,           ", "             NULL,", "             &jmp_destination_addr);", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));", "         if (fixup == NULL)", "           compiler->last_error = ERROR_INSUFFICIENT_MEMORY;", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         fixup->address = jmp_destination_addr;", "          fixup->next = compiler->fixup_stack_head;", "          compiler->fixup_stack_head = fixup;", "        }", "#line 2890 \"grammar.c\"  ", " #line 2896 \"grammar.c\"  ", "      break;", "    case 71:", "#line 1288 \"grammar.y\"  ", " #line 1294 \"grammar.y\"  ", "      {", "          YR_FIXUP* fixup;", "          uint8_t* and_addr;", "         compiler->last_result = yr_arena_reserve_memory(", "             compiler->code_arena, 2);", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         compiler->last_result = yr_parser_emit(yyscanner, OP_AND, &and_addr);", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         fixup = compiler->fixup_stack_head;", "         *(void**)(fixup->address) = (void*)(and_addr + 1);", "         compiler->fixup_stack_head = fixup->next;", "         yr_free(fixup);", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "        }", "#line 2930 \"grammar.c\"  ", " #line 2936 \"grammar.c\"  ", "      break;", "    case 72:", "#line 1324 \"grammar.y\"  ", " #line 1330 \"grammar.y\"  ", "      {", "          YR_FIXUP* fixup;", "          void* jmp_destination_addr;", "         compiler->last_result = yr_parser_emit_with_arg_reloc(", "             yyscanner,", "             OP_JTRUE,", "             0,          ", "             NULL,", "             &jmp_destination_addr);", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));", "         if (fixup == NULL)", "           compiler->last_error = ERROR_INSUFFICIENT_MEMORY;", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         fixup->address = jmp_destination_addr;", "          fixup->next = compiler->fixup_stack_head;", "          compiler->fixup_stack_head = fixup;", "        }", "#line 2959 \"grammar.c\"  ", " #line 2965 \"grammar.c\"  ", "      break;", "    case 73:", "#line 1349 \"grammar.y\"  ", " #line 1355 \"grammar.y\"  ", "      {", "          YR_FIXUP* fixup;", "          uint8_t* or_addr;", "         compiler->last_result = yr_arena_reserve_memory(", "             compiler->code_arena, 2);", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         compiler->last_result = yr_parser_emit(yyscanner, OP_OR, &or_addr);", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         fixup = compiler->fixup_stack_head;", "         *(void**)(fixup->address) = (void*)(or_addr + 1);", "         compiler->fixup_stack_head = fixup->next;", "         yr_free(fixup);", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "        }", "#line 2999 \"grammar.c\"  ", " #line 3005 \"grammar.c\"  ", "      break;", "    case 74:", "#line 1385 \"grammar.y\"  ", " #line 1391 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_reduce_operation(", "              yyscanner, \"<\", (yyvsp[-2].expression), (yyvsp[0].expression));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "        }", "#line 3012 \"grammar.c\"  ", " #line 3018 \"grammar.c\"  ", "      break;", "    case 75:", "#line 1394 \"grammar.y\"  ", " #line 1400 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_reduce_operation(", "              yyscanner, \">\", (yyvsp[-2].expression), (yyvsp[0].expression));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "        }", "#line 3025 \"grammar.c\"  ", " #line 3031 \"grammar.c\"  ", "      break;", "    case 76:", "#line 1403 \"grammar.y\"  ", " #line 1409 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_reduce_operation(", "              yyscanner, \"<=\", (yyvsp[-2].expression), (yyvsp[0].expression));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "        }", "#line 3038 \"grammar.c\"  ", " #line 3044 \"grammar.c\"  ", "      break;", "    case 77:", "#line 1412 \"grammar.y\"  ", " #line 1418 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_reduce_operation(", "              yyscanner, \">=\", (yyvsp[-2].expression), (yyvsp[0].expression));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "        }", "#line 3051 \"grammar.c\"  ", " #line 3057 \"grammar.c\"  ", "      break;", "    case 78:", "#line 1421 \"grammar.y\"  ", " #line 1427 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_reduce_operation(", "              yyscanner, \"==\", (yyvsp[-2].expression), (yyvsp[0].expression));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "        }", "#line 3064 \"grammar.c\"  ", " #line 3070 \"grammar.c\"  ", "      break;", "    case 79:", "#line 1430 \"grammar.y\"  ", " #line 1436 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_reduce_operation(", "              yyscanner, \"!=\", (yyvsp[-2].expression), (yyvsp[0].expression));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "        }", "#line 3077 \"grammar.c\"  ", " #line 3083 \"grammar.c\"  ", "      break;", "    case 80:", "#line 1439 \"grammar.y\"  ", " #line 1445 \"grammar.y\"  ", "      {", "          (yyval.expression) = (yyvsp[0].expression);", "        }", "#line 3085 \"grammar.c\"  ", " #line 3091 \"grammar.c\"  ", "      break;", "    case 81:", "#line 1443 \"grammar.y\"  ", " #line 1449 \"grammar.y\"  ", "      {", "          (yyval.expression) = (yyvsp[-1].expression);", "        }", "#line 3093 \"grammar.c\"  ", " #line 3099 \"grammar.c\"  ", "      break;", "    case 82:", "#line 1450 \"grammar.y\"  ", " #line 1456 \"grammar.y\"  ", "      { (yyval.integer) = INTEGER_SET_ENUMERATION; }", "#line 3099 \"grammar.c\"  ", " #line 3105 \"grammar.c\"  ", "      break;", "    case 83:", "#line 1451 \"grammar.y\"  ", " #line 1457 \"grammar.y\"  ", "      { (yyval.integer) = INTEGER_SET_RANGE; }", "#line 3105 \"grammar.c\"  ", " #line 3111 \"grammar.c\"  ", "      break;", "    case 84:", "#line 1457 \"grammar.y\"  ", " #line 1463 \"grammar.y\"  ", "      {", "          if ((yyvsp[-3].expression).type != EXPRESSION_TYPE_INTEGER)", "          {", "           yr_compiler_set_error_extra_info(", "               compiler, \"wrong type for range's lower bound\");", "           compiler->last_result = ERROR_WRONG_TYPE;", "         }", "         if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)", "         {", "           yr_compiler_set_error_extra_info(", "               compiler, \"wrong type for range's upper bound\");", "           compiler->last_result = ERROR_WRONG_TYPE;", "         }", "          ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "        }", "#line 3127 \"grammar.c\"  ", " #line 3133 \"grammar.c\"  ", "      break;", "    case 85:", "#line 1479 \"grammar.y\"  ", " #line 1485 \"grammar.y\"  ", "      {", "          if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)", "          {", "           yr_compiler_set_error_extra_info(", "               compiler, \"wrong type for enumeration item\");", "           compiler->last_result = ERROR_WRONG_TYPE;", "         }", "          ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "        }", "#line 3143 \"grammar.c\"  ", " #line 3149 \"grammar.c\"  ", "      break;", "    case 86:", "#line 1491 \"grammar.y\"  ", " #line 1497 \"grammar.y\"  ", "      {", "          if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)", "          {", "           yr_compiler_set_error_extra_info(", "               compiler, \"wrong type for enumeration item\");", "           compiler->last_result = ERROR_WRONG_TYPE;", "         }", "          ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "        }", "#line 3158 \"grammar.c\"  ", " #line 3164 \"grammar.c\"  ", "      break;", "    case 87:", "#line 1506 \"grammar.y\"  ", " #line 1512 \"grammar.y\"  ", "      {", "          yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);", "        }", "#line 3167 \"grammar.c\"  ", " #line 3173 \"grammar.c\"  ", "      break;", "    case 89:", "#line 1512 \"grammar.y\"  ", " #line 1518 \"grammar.y\"  ", "      {", "          yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);", "          yr_parser_emit_pushes_for_strings(yyscanner, \"$*\");", "          ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "        }", "#line 3178 \"grammar.c\"  ", " #line 3184 \"grammar.c\"  ", "      break;", "    case 92:", "#line 1529 \"grammar.y\"  ", " #line 1535 \"grammar.y\"  ", "      {", "          yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));", "          yr_free((yyvsp[0].c_string));", "          ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "        }", "#line 3189 \"grammar.c\"  ", " #line 3195 \"grammar.c\"  ", "      break;", "    case 93:", "#line 1536 \"grammar.y\"  ", " #line 1542 \"grammar.y\"  ", "      {", "          yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));", "          yr_free((yyvsp[0].c_string));", "          ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "        }", "#line 3200 \"grammar.c\"  ", " #line 3206 \"grammar.c\"  ", "      break;", "    case 95:", "#line 1548 \"grammar.y\"  ", " #line 1554 \"grammar.y\"  ", "      {", "          yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);", "        }", "#line 3208 \"grammar.c\"  ", " #line 3214 \"grammar.c\"  ", "      break;", "    case 96:", "#line 1552 \"grammar.y\"  ", " #line 1558 \"grammar.y\"  ", "      {", "          yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);", "        }", "#line 3216 \"grammar.c\"  ", " #line 3222 \"grammar.c\"  ", "      break;", "    case 97:", "#line 1560 \"grammar.y\"  ", " #line 1566 \"grammar.y\"  ", "      {", "          (yyval.expression) = (yyvsp[-1].expression);", "        }", "#line 3224 \"grammar.c\"  ", " #line 3230 \"grammar.c\"  ", "      break;", "    case 98:", "#line 1564 \"grammar.y\"  ", " #line 1570 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_emit(", "              yyscanner, OP_FILESIZE, NULL);", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = UNDEFINED;", "        }", "#line 3238 \"grammar.c\"  ", " #line 3244 \"grammar.c\"  ", "      break;", "    case 99:", "#line 1574 \"grammar.y\"  ", " #line 1580 \"grammar.y\"  ", "      {", "          yywarning(yyscanner,", "              \"Using deprecated \\\"entrypoint\\\" keyword. Use the \\\"entry_point\\\" \"", "             \"function from PE module instead.\");", "         compiler->last_result = yr_parser_emit(", "             yyscanner, OP_ENTRYPOINT, NULL);", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = UNDEFINED;", "        }", "#line 3256 \"grammar.c\"  ", " #line 3262 \"grammar.c\"  ", "      break;", "    case 100:", "#line 1588 \"grammar.y\"  ", " #line 1594 \"grammar.y\"  ", "      {", "          CHECK_TYPE((yyvsp[-1].expression), EXPRESSION_TYPE_INTEGER, \"intXXXX or uintXXXX\");", "         compiler->last_result = yr_parser_emit(", "             yyscanner, (uint8_t) (OP_READ_INT + (yyvsp[-3].integer)), NULL);", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = UNDEFINED;", "        }", "#line 3276 \"grammar.c\"  ", " #line 3282 \"grammar.c\"  ", "      break;", "    case 101:", "#line 1604 \"grammar.y\"  ", " #line 1610 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_emit_with_arg(", "              yyscanner, OP_PUSH, (yyvsp[0].integer), NULL, NULL);", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = (yyvsp[0].integer);", "        }", "#line 3290 \"grammar.c\"  ", " #line 3296 \"grammar.c\"  ", "      break;", "    case 102:", "#line 1614 \"grammar.y\"  ", " #line 1620 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_emit_with_arg_double(", "              yyscanner, OP_PUSH, (yyvsp[0].double_), NULL, NULL);", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;", "        }", "#line 3303 \"grammar.c\"  ", " #line 3309 \"grammar.c\"  ", "      break;", "    case 103:", "#line 1623 \"grammar.y\"  ", " #line 1629 \"grammar.y\"  ", "      {", "          SIZED_STRING* sized_string;", "         compiler->last_result = yr_arena_write_data(", "             compiler->sz_arena,", "             (yyvsp[0].sized_string),", "             (yyvsp[0].sized_string)->length + sizeof(SIZED_STRING),", "             (void**) &sized_string);", "         yr_free((yyvsp[0].sized_string));", "         if (compiler->last_result == ERROR_SUCCESS)", "           compiler->last_result = yr_parser_emit_with_arg_reloc(", "               yyscanner,", "               OP_PUSH,", "               sized_string,", "               NULL,", "               NULL);", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          (yyval.expression).type = EXPRESSION_TYPE_STRING;", "          (yyval.expression).value.sized_string = sized_string;", "        }", "#line 3332 \"grammar.c\"  ", " #line 3338 \"grammar.c\"  ", "      break;", "    case 104:", "#line 1648 \"grammar.y\"  ", " #line 1654 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_reduce_string_identifier(", "              yyscanner, (yyvsp[0].c_string), OP_COUNT, UNDEFINED);", "         yr_free((yyvsp[0].c_string));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = UNDEFINED;", "        }", "#line 3348 \"grammar.c\"  ", " #line 3354 \"grammar.c\"  ", "      break;", "    case 105:", "#line 1660 \"grammar.y\"  ", " #line 1666 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_reduce_string_identifier(", "              yyscanner, (yyvsp[-3].c_string), OP_OFFSET, UNDEFINED);", "         yr_free((yyvsp[-3].c_string));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = UNDEFINED;", "        }", "#line 3364 \"grammar.c\"  ", " #line 3370 \"grammar.c\"  ", "      break;", "    case 106:", "#line 1672 \"grammar.y\"  ", " #line 1678 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_emit_with_arg(", "              yyscanner, OP_PUSH, 1, NULL, NULL);", "         if (compiler->last_result == ERROR_SUCCESS)", "           compiler->last_result = yr_parser_reduce_string_identifier(", "               yyscanner, (yyvsp[0].c_string), OP_OFFSET, UNDEFINED);", "         yr_free((yyvsp[0].c_string));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = UNDEFINED;", "        }", "#line 3384 \"grammar.c\"  ", " #line 3390 \"grammar.c\"  ", "      break;", "    case 107:", "#line 1688 \"grammar.y\"  ", " #line 1694 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_reduce_string_identifier(", "              yyscanner, (yyvsp[-3].c_string), OP_LENGTH, UNDEFINED);", "         yr_free((yyvsp[-3].c_string));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = UNDEFINED;", "        }", "#line 3400 \"grammar.c\"  ", " #line 3406 \"grammar.c\"  ", "      break;", "    case 108:", "#line 1700 \"grammar.y\"  ", " #line 1706 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_emit_with_arg(", "              yyscanner, OP_PUSH, 1, NULL, NULL);", "         if (compiler->last_result == ERROR_SUCCESS)", "           compiler->last_result = yr_parser_reduce_string_identifier(", "               yyscanner, (yyvsp[0].c_string), OP_LENGTH, UNDEFINED);", "         yr_free((yyvsp[0].c_string));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = UNDEFINED;", "        }", "#line 3420 \"grammar.c\"  ", " #line 3426 \"grammar.c\"  ", "      break;", "    case 109:", "#line 1716 \"grammar.y\"  ", " #line 1722 \"grammar.y\"  ", "      {", "          if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)   ", "          {", "           (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "           (yyval.expression).value.integer = UNDEFINED;", "         }", "         else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_BOOLEAN)   ", "         {", "           (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "           (yyval.expression).value.integer = UNDEFINED;", "         }", "         else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_OBJECT)", "         {", "           compiler->last_result = yr_parser_emit(", "               yyscanner, OP_OBJ_VALUE, NULL);", "           switch((yyvsp[0].expression).value.object->type)", "           {", "             case OBJECT_TYPE_INTEGER:", "               (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "               (yyval.expression).value.integer = UNDEFINED;", "               break;", "             case OBJECT_TYPE_FLOAT:", "               (yyval.expression).type = EXPRESSION_TYPE_FLOAT;", "               break;", "             case OBJECT_TYPE_STRING:", "               (yyval.expression).type = EXPRESSION_TYPE_STRING;", "               (yyval.expression).value.sized_string = NULL;", "               break;", "             default:", "               yr_compiler_set_error_extra_info_fmt(", "                   compiler,", "                   \"wrong usage of identifier \\\"%s\\\"\",", "                   (yyvsp[0].expression).identifier);", "               compiler->last_result = ERROR_WRONG_TYPE;", "           }", "         }", "         else", "         {", "           assert(FALSE);", "         }", "          ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "        }", "#line 3469 \"grammar.c\"  ", " #line 3475 \"grammar.c\"  ", "      break;", "    case 110:", "#line 1761 \"grammar.y\"  ", " #line 1767 \"grammar.y\"  ", "      {", "          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, \"-\");", "         if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)", "         {", "           (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "           (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?", "               UNDEFINED : -((yyvsp[0].expression).value.integer);", "           compiler->last_result = yr_parser_emit(yyscanner, OP_INT_MINUS, NULL);", "         }", "         else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_FLOAT)", "         {", "           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;", "           compiler->last_result = yr_parser_emit(yyscanner, OP_DBL_MINUS, NULL);", "         }", "          ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "        }", "#line 3492 \"grammar.c\"  ", " #line 3498 \"grammar.c\"  ", "      break;", "    case 111:", "#line 1780 \"grammar.y\"  ", " #line 1786 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_reduce_operation(", "              yyscanner, \"+\", (yyvsp[-2].expression), (yyvsp[0].expression));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&", "             (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)", "         {", "           (yyval.expression).value.integer = OPERATION(+, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);", "           (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "         }", "         else", "         {", "            (yyval.expression).type = EXPRESSION_TYPE_FLOAT;", "          }", "        }", "#line 3514 \"grammar.c\"  ", " #line 3520 \"grammar.c\"  ", "      break;", "    case 112:", "#line 1798 \"grammar.y\"  ", " #line 1804 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_reduce_operation(", "              yyscanner, \"-\", (yyvsp[-2].expression), (yyvsp[0].expression));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&", "             (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)", "         {", "           (yyval.expression).value.integer = OPERATION(-, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);", "           (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "         }", "         else", "         {", "            (yyval.expression).type = EXPRESSION_TYPE_FLOAT;", "          }", "        }", "#line 3536 \"grammar.c\"  ", " #line 3542 \"grammar.c\"  ", "      break;", "    case 113:", "#line 1816 \"grammar.y\"  ", " #line 1822 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_reduce_operation(", "              yyscanner, \"*\", (yyvsp[-2].expression), (yyvsp[0].expression));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&", "             (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)", "         {", "           (yyval.expression).value.integer = OPERATION(*, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);", "           (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "         }", "         else", "         {", "            (yyval.expression).type = EXPRESSION_TYPE_FLOAT;", "          }", "        }", "#line 3558 \"grammar.c\"  ", " #line 3564 \"grammar.c\"  ", "      break;", "    case 114:", "#line 1834 \"grammar.y\"  ", " #line 1840 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_reduce_operation(", "              yyscanner, \"\\\\\", (yyvsp[-2].expression), (yyvsp[0].expression));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&", "             (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)", "         {", "           if ((yyvsp[0].expression).value.integer != 0)", "           {", "             (yyval.expression).value.integer = OPERATION(/, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);", "             (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "           }", "           else", "           {", "             compiler->last_result = ERROR_DIVISION_BY_ZERO;", "             ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "           }", "         }", "         else", "         {", "            (yyval.expression).type = EXPRESSION_TYPE_FLOAT;", "          }", "        }", "#line 3588 \"grammar.c\"  ", " #line 3594 \"grammar.c\"  ", "      break;", "    case 115:", "#line 1860 \"grammar.y\"  ", " #line 1866 \"grammar.y\"  ", "      {", "          CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"%\");", "          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"%\");", "         yr_parser_emit(yyscanner, OP_MOD, NULL);", "         if ((yyvsp[0].expression).value.integer != 0)", "         {", "           (yyval.expression).value.integer = OPERATION(%, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);", "           (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "         }", "         else", "         {", "           compiler->last_result = ERROR_DIVISION_BY_ZERO;", "            ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          }", "        }", "#line 3610 \"grammar.c\"  ", " #line 3616 \"grammar.c\"  ", "      break;", "    case 116:", "#line 1878 \"grammar.y\"  ", " #line 1884 \"grammar.y\"  ", "      {", "          CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"^\");", "          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"^\");", "         yr_parser_emit(yyscanner, OP_BITWISE_XOR, NULL);", "          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = OPERATION(^, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);", "        }", "#line 3624 \"grammar.c\"  ", " #line 3630 \"grammar.c\"  ", "      break;", "    case 117:", "#line 1888 \"grammar.y\"  ", " #line 1894 \"grammar.y\"  ", "      {", "          CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"^\");", "          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"^\");", "         yr_parser_emit(yyscanner, OP_BITWISE_AND, NULL);", "          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = OPERATION(&, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);", "        }", "#line 3638 \"grammar.c\"  ", " #line 3644 \"grammar.c\"  ", "      break;", "    case 118:", "#line 1898 \"grammar.y\"  ", " #line 1904 \"grammar.y\"  ", "      {", "          CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"|\");", "          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"|\");", "         yr_parser_emit(yyscanner, OP_BITWISE_OR, NULL);", "          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = OPERATION(|, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);", "        }", "#line 3652 \"grammar.c\"  ", " #line 3658 \"grammar.c\"  ", "      break;", "    case 119:", "#line 1908 \"grammar.y\"  ", " #line 1914 \"grammar.y\"  ", "      {", "          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"~\");", "         yr_parser_emit(yyscanner, OP_BITWISE_NOT, NULL);", "         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?", "              UNDEFINED : ~((yyvsp[0].expression).value.integer);", "        }", "#line 3666 \"grammar.c\"  ", " #line 3672 \"grammar.c\"  ", "      break;", "    case 120:", "#line 1918 \"grammar.y\"  ", " #line 1924 \"grammar.y\"  ", "      {", "          CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"<<\");", "          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"<<\");", "         yr_parser_emit(yyscanner, OP_SHL, NULL);", "          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);", "        }", "#line 3680 \"grammar.c\"  ", " #line 3686 \"grammar.c\"  ", "      break;", "    case 121:", "#line 1928 \"grammar.y\"  ", " #line 1934 \"grammar.y\"  ", "      {", "          CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \">>\");", "          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \">>\");", "         yr_parser_emit(yyscanner, OP_SHR, NULL);", "          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = OPERATION(>>, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);", "        }", "#line 3694 \"grammar.c\"  ", " #line 3700 \"grammar.c\"  ", "      break;", "    case 122:", "#line 1938 \"grammar.y\"  ", " #line 1944 \"grammar.y\"  ", "      {", "          (yyval.expression) = (yyvsp[0].expression);", "        }", "#line 3702 \"grammar.c\"  ", " #line 3708 \"grammar.c\"  ", "      break;", "#line 3706 \"grammar.c\"  ", " #line 3712 \"grammar.c\"  ", "        default: break;", "      }", "   YY_SYMBOL_PRINT (\"-> $$ =\", yyr1[yyn], &yyval, &yyloc);", "   YYPOPSTACK (yylen);", "   yylen = 0;", "   YY_STACK_PRINT (yyss, yyssp);", "   *++yyvsp = yyval;", "   yyn = yyr1[yyn];", "   yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;", "   if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)", "     yystate = yytable[yystate];", "   else", "     yystate = yydefgoto[yyn - YYNTOKENS];", "   goto yynewstate;", " yyerrlab:", "   yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);", "   if (!yyerrstatus)", "     {", "       ++yynerrs;", " #if ! YYERROR_VERBOSE", "       yyerror (yyscanner, compiler, YY_(\"syntax error\"));", " #else", " # define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \\", "                                         yyssp, yytoken)", "       {", "         char const *yymsgp = YY_(\"syntax error\");", "         int yysyntax_error_status;", "         yysyntax_error_status = YYSYNTAX_ERROR;", "         if (yysyntax_error_status == 0)", "           yymsgp = yymsg;", "         else if (yysyntax_error_status == 1)", "           {", "             if (yymsg != yymsgbuf)", "               YYSTACK_FREE (yymsg);", "             yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);", "             if (!yymsg)", "               {", "                 yymsg = yymsgbuf;", "                 yymsg_alloc = sizeof yymsgbuf;", "                 yysyntax_error_status = 2;", "               }", "             else", "               {", "                 yysyntax_error_status = YYSYNTAX_ERROR;", "                 yymsgp = yymsg;", "               }", "           }", "         yyerror (yyscanner, compiler, yymsgp);", "         if (yysyntax_error_status == 2)", "           goto yyexhaustedlab;", "       }", " # undef YYSYNTAX_ERROR", " #endif", "     }", "   if (yyerrstatus == 3)", "     {", "       if (yychar <= YYEOF)", "         {", "           if (yychar == YYEOF)", "             YYABORT;", "         }", "       else", "         {", "           yydestruct (\"Error: discarding\",", "                       yytoken, &yylval, yyscanner, compiler);", "           yychar = YYEMPTY;", "         }", "     }", "   goto yyerrlab1;", " yyerrorlab:", "   if (  0)", "      goto yyerrorlab;", "   YYPOPSTACK (yylen);", "   yylen = 0;", "   YY_STACK_PRINT (yyss, yyssp);", "   yystate = *yyssp;", "   goto yyerrlab1;", " yyerrlab1:", "   yyerrstatus = 3;       ", "   for (;;)", "     {", "       yyn = yypact[yystate];", "       if (!yypact_value_is_default (yyn))", "         {", "           yyn += YYTERROR;", "           if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)", "             {", "               yyn = yytable[yyn];", "               if (0 < yyn)", "                 break;", "             }", "         }", "       if (yyssp == yyss)", "         YYABORT;", "       yydestruct (\"Error: popping\",", "                   yystos[yystate], yyvsp, yyscanner, compiler);", "       YYPOPSTACK (1);", "       yystate = *yyssp;", "       YY_STACK_PRINT (yyss, yyssp);", "     }", "   YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN", "   *++yyvsp = yylval;", "   YY_IGNORE_MAYBE_UNINITIALIZED_END", "   YY_SYMBOL_PRINT (\"Shifting\", yystos[yyn], yyvsp, yylsp);", "   yystate = yyn;", "   goto yynewstate;", " yyacceptlab:", "   yyresult = 0;", "   goto yyreturn;", " yyabortlab:", "   yyresult = 1;", "   goto yyreturn;", " #if !defined yyoverflow || YYERROR_VERBOSE", " yyexhaustedlab:", "   yyerror (yyscanner, compiler, YY_(\"memory exhausted\"));", "   yyresult = 2;", " #endif", " yyreturn:", "   if (yychar != YYEMPTY)", "     {", "       yytoken = YYTRANSLATE (yychar);", "       yydestruct (\"Cleanup: discarding lookahead\",", "                   yytoken, &yylval, yyscanner, compiler);", "     }", "   YYPOPSTACK (yylen);", "   YY_STACK_PRINT (yyss, yyssp);", "   while (yyssp != yyss)", "     {", "       yydestruct (\"Cleanup: popping\",", "                   yystos[*yyssp], yyvsp, yyscanner, compiler);", "       YYPOPSTACK (1);", "     }", " #ifndef yyoverflow", "   if (yyss != yyssa)", "     YYSTACK_FREE (yyss);", " #endif", " #if YYERROR_VERBOSE", "   if (yymsg != yymsgbuf)", "     YYSTACK_FREE (yymsg);", "  #endif", "    return yyresult;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  int __glXDisp_CreateContext(__GLXclientState *cl, GLbyte *pc)", "  {", "     ClientPtr client = cl->client;", "      xGLXCreateContextReq *req = (xGLXCreateContextReq *) pc;", "      __GLXconfig *config;", "      __GLXscreen *pGlxScreen;", "      int err;", "     REQUEST_SIZE_MATCH(xGLXCreateContextReq);", "      if (!validGlxScreen(cl->client, req->screen, &pGlxScreen, &err))", "  \treturn err;", "      if (!validGlxVisual(cl->client, pGlxScreen, req->visual, &config, &err))", " \t\t\t   config, pGlxScreen, req->isDirect);", " }"], "ner_tags": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": [" lquery_in(PG_FUNCTION_ARGS)", " {", " \tchar\t   *buf = (char *) PG_GETARG_POINTER(0);", " \tchar\t   *ptr;", " \tint\t\t\tnum = 0,", " \t\t\t\ttotallen = 0,", " \t\t\t\tnumOR = 0;", " \tint\t\t\tstate = LQPRS_WAITLEVEL;", " \tlquery\t   *result;", " \tnodeitem   *lptr = NULL;", " \tlquery_level *cur,", " \t\t\t   *curqlevel,", " \t\t\t   *tmpql;", " \tlquery_variant *lrptr = NULL;", " \tbool\t\thasnot = false;", " \tbool\t\twasbad = false;", " \tint\t\t\tcharlen;", " \tint\t\t\tpos = 0;", " \tptr = buf;", " \twhile (*ptr)", " \t{", " \t\tcharlen = pg_mblen(ptr);", " \t\tif (charlen == 1)", " \t\t{", " \t\t\tif (t_iseq(ptr, '.'))", " \t\t\t\tnum++;", " \t\t\telse if (t_iseq(ptr, '|'))", " \t\t\t\tnumOR++;", " \t\t}", " \t\tptr += charlen;", "  \t}", "  \tnum++;", " \tif (num > MaxAllocSize / ITEMSIZE)", " \t\tereport(ERROR,", " \t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),", " \t\t\t errmsg(\"number of levels (%d) exceeds the maximum allowed (%d)\",", " \t\t\t\t\tnum, (int) (MaxAllocSize / ITEMSIZE))));", "  \tcurqlevel = tmpql = (lquery_level *) palloc0(ITEMSIZE * num);", "  \tptr = buf;", "  \twhile (*ptr)", " \t{", " \t\tcharlen = pg_mblen(ptr);", " \t\tif (state == LQPRS_WAITLEVEL)", " \t\t{", " \t\t\tif (ISALNUM(ptr))", " \t\t\t{", " \t\t\t\tGETVAR(curqlevel) = lptr = (nodeitem *) palloc0(sizeof(nodeitem) * (numOR + 1));", " \t\t\t\tlptr->start = ptr;", " \t\t\t\tstate = LQPRS_WAITDELIM;", " \t\t\t\tcurqlevel->numvar = 1;", " \t\t\t}", " \t\t\telse if (charlen == 1 && t_iseq(ptr, '!'))", " \t\t\t{", " \t\t\t\tGETVAR(curqlevel) = lptr = (nodeitem *) palloc0(sizeof(nodeitem) * (numOR + 1));", " \t\t\t\tlptr->start = ptr + 1;", " \t\t\t\tstate = LQPRS_WAITDELIM;", " \t\t\t\tcurqlevel->numvar = 1;", " \t\t\t\tcurqlevel->flag |= LQL_NOT;", " \t\t\t\thasnot = true;", " \t\t\t}", " \t\t\telse if (charlen == 1 && t_iseq(ptr, '*'))", " \t\t\t\tstate = LQPRS_WAITOPEN;", " \t\t\telse", " \t\t\t\tUNCHAR;", " \t\t}", " \t\telse if (state == LQPRS_WAITVAR)", " \t\t{", " \t\t\tif (ISALNUM(ptr))", " \t\t\t{", " \t\t\t\tlptr++;", " \t\t\t\tlptr->start = ptr;", " \t\t\t\tstate = LQPRS_WAITDELIM;", " \t\t\t\tcurqlevel->numvar++;", " \t\t\t}", " \t\t\telse", " \t\t\t\tUNCHAR;", " \t\t}", " \t\telse if (state == LQPRS_WAITDELIM)", " \t\t{", " \t\t\tif (charlen == 1 && t_iseq(ptr, '@'))", " \t\t\t{", " \t\t\t\tif (lptr->start == ptr)", " \t\t\t\t\tUNCHAR;", " \t\t\t\tlptr->flag |= LVAR_INCASE;", " \t\t\t\tcurqlevel->flag |= LVAR_INCASE;", " \t\t\t}", " \t\t\telse if (charlen == 1 && t_iseq(ptr, '*'))", " \t\t\t{", " \t\t\t\tif (lptr->start == ptr)", " \t\t\t\t\tUNCHAR;", " \t\t\t\tlptr->flag |= LVAR_ANYEND;", " \t\t\t\tcurqlevel->flag |= LVAR_ANYEND;", " \t\t\t}", " \t\t\telse if (charlen == 1 && t_iseq(ptr, '%'))", " \t\t\t{", " \t\t\t\tif (lptr->start == ptr)", " \t\t\t\t\tUNCHAR;", " \t\t\t\tlptr->flag |= LVAR_SUBLEXEME;", " \t\t\t\tcurqlevel->flag |= LVAR_SUBLEXEME;", " \t\t\t}", " \t\t\telse if (charlen == 1 && t_iseq(ptr, '|'))", " \t\t\t{", " \t\t\t\tlptr->len = ptr - lptr->start -", " \t\t\t\t\t((lptr->flag & LVAR_SUBLEXEME) ? 1 : 0) -", " \t\t\t\t\t((lptr->flag & LVAR_INCASE) ? 1 : 0) -", " \t\t\t\t\t((lptr->flag & LVAR_ANYEND) ? 1 : 0);", " \t\t\t\tif (lptr->wlen > 255)", " \t\t\t\t\tereport(ERROR,", " \t\t\t\t\t\t\t(errcode(ERRCODE_NAME_TOO_LONG),", " \t\t\t\t\t\t\t errmsg(\"name of level is too long\"),", " \t\t\t\t\t\t\t errdetail(\"Name length is %d, must \"", " \t\t\t\t\t\t\t\t\t   \"be < 256, in position %d.\",", " \t\t\t\t\t\t\t\t\t   lptr->wlen, pos)));", " \t\t\t\tstate = LQPRS_WAITVAR;", " \t\t\t}", " \t\t\telse if (charlen == 1 && t_iseq(ptr, '.'))", " \t\t\t{", " \t\t\t\tlptr->len = ptr - lptr->start -", " \t\t\t\t\t((lptr->flag & LVAR_SUBLEXEME) ? 1 : 0) -", " \t\t\t\t\t((lptr->flag & LVAR_INCASE) ? 1 : 0) -", " \t\t\t\t\t((lptr->flag & LVAR_ANYEND) ? 1 : 0);", " \t\t\t\tif (lptr->wlen > 255)", " \t\t\t\t\tereport(ERROR,", " \t\t\t\t\t\t\t(errcode(ERRCODE_NAME_TOO_LONG),", " \t\t\t\t\t\t\t errmsg(\"name of level is too long\"),", " \t\t\t\t\t\t\t errdetail(\"Name length is %d, must \"", " \t\t\t\t\t\t\t\t\t   \"be < 256, in position %d.\",", " \t\t\t\t\t\t\t\t\t   lptr->wlen, pos)));", " \t\t\t\tstate = LQPRS_WAITLEVEL;", " \t\t\t\tcurqlevel = NEXTLEV(curqlevel);", " \t\t\t}", " \t\t\telse if (ISALNUM(ptr))", " \t\t\t{", " \t\t\t\tif (lptr->flag)", " \t\t\t\t\tUNCHAR;", " \t\t\t}", " \t\t\telse", " \t\t\t\tUNCHAR;", " \t\t}", " \t\telse if (state == LQPRS_WAITOPEN)", " \t\t{", " \t\t\tif (charlen == 1 && t_iseq(ptr, '{'))", " \t\t\t\tstate = LQPRS_WAITFNUM;", " \t\t\telse if (charlen == 1 && t_iseq(ptr, '.'))", " \t\t\t{", " \t\t\t\tcurqlevel->low = 0;", " \t\t\t\tcurqlevel->high = 0xffff;", " \t\t\t\tcurqlevel = NEXTLEV(curqlevel);", " \t\t\t\tstate = LQPRS_WAITLEVEL;", " \t\t\t}", " \t\t\telse", " \t\t\t\tUNCHAR;", " \t\t}", " \t\telse if (state == LQPRS_WAITFNUM)", " \t\t{", " \t\t\tif (charlen == 1 && t_iseq(ptr, ','))", " \t\t\t\tstate = LQPRS_WAITSNUM;", " \t\t\telse if (t_isdigit(ptr))", " \t\t\t{", " \t\t\t\tcurqlevel->low = atoi(ptr);", " \t\t\t\tstate = LQPRS_WAITND;", " \t\t\t}", " \t\t\telse", " \t\t\t\tUNCHAR;", " \t\t}", " \t\telse if (state == LQPRS_WAITSNUM)", " \t\t{", " \t\t\tif (t_isdigit(ptr))", " \t\t\t{", " \t\t\t\tcurqlevel->high = atoi(ptr);", " \t\t\t\tstate = LQPRS_WAITCLOSE;", " \t\t\t}", " \t\t\telse if (charlen == 1 && t_iseq(ptr, '}'))", " \t\t\t{", " \t\t\t\tcurqlevel->high = 0xffff;", " \t\t\t\tstate = LQPRS_WAITEND;", " \t\t\t}", " \t\t\telse", " \t\t\t\tUNCHAR;", " \t\t}", " \t\telse if (state == LQPRS_WAITCLOSE)", " \t\t{", " \t\t\tif (charlen == 1 && t_iseq(ptr, '}'))", " \t\t\t\tstate = LQPRS_WAITEND;", " \t\t\telse if (!t_isdigit(ptr))", " \t\t\t\tUNCHAR;", " \t\t}", " \t\telse if (state == LQPRS_WAITND)", " \t\t{", " \t\t\tif (charlen == 1 && t_iseq(ptr, '}'))", " \t\t\t{", " \t\t\t\tcurqlevel->high = curqlevel->low;", " \t\t\t\tstate = LQPRS_WAITEND;", " \t\t\t}", " \t\t\telse if (charlen == 1 && t_iseq(ptr, ','))", " \t\t\t\tstate = LQPRS_WAITSNUM;", " \t\t\telse if (!t_isdigit(ptr))", " \t\t\t\tUNCHAR;", " \t\t}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void vrend_renderer_context_destroy(uint32_t handle)", " {", "    struct vrend_decode_ctx *ctx;", "    bool ret;", "     if (handle >= VREND_MAX_CTX)", "        return;", "    if (handle == 0) {", "       return;", "    }", "     ctx = dec_ctx[handle];", "     if (!ctx)", "        return;", "       vrend_hw_switch_context(dec_ctx[0]->grctx, true);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" static void copy_fields(const FieldMatchContext *fm, AVFrame *dst,", "                          const AVFrame *src, int field)", "  {", "      int plane;", "    for (plane = 0; plane < 4 && src->data[plane]; plane++)", "     for (plane = 0; plane < 4 && src->data[plane] && src->linesize[plane]; plane++)", "          av_image_copy_plane(dst->data[plane] + field*dst->linesize[plane], dst->linesize[plane] << 1,", "                              src->data[plane] + field*src->linesize[plane], src->linesize[plane] << 1,", "                              get_width(fm, src, plane), get_height(fm, src, plane) / 2);", " }"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 0, 0, 0]}
{"tokens": [" static int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in)", " {", " \tjp2_pclr_t *pclr = &box->data.pclr;", " \tint lutsize;", " \tunsigned int i;", " \tunsigned int j;", "  \tint_fast32_t x;", "  \tpclr->lutdata = 0;", " \tpclr->bpc = 0;", "  \tif (jp2_getuint16(in, &pclr->numlutents) ||", "  \t  jp2_getuint8(in, &pclr->numchans)) {", " \t\treturn -1;", " \t}", " \tlutsize = pclr->numlutents * pclr->numchans;", " \tif (!(pclr->lutdata = jas_alloc2(lutsize, sizeof(int_fast32_t)))) {", " \t\treturn -1;", " \t}", " \tif (!(pclr->bpc = jas_alloc2(pclr->numchans, sizeof(uint_fast8_t)))) {", " \t\treturn -1;", " \t}", " \tfor (i = 0; i < pclr->numchans; ++i) {", " \t\tif (jp2_getuint8(in, &pclr->bpc[i])) {", " \t\t\treturn -1;", " \t\t}", " \t}", " \tfor (i = 0; i < pclr->numlutents; ++i) {", " \t\tfor (j = 0; j < pclr->numchans; ++j) {", " \t\t\tif (jp2_getint(in, (pclr->bpc[j] & 0x80) != 0,", " \t\t\t  (pclr->bpc[j] & 0x7f) + 1, &x)) {", " \t\t\t\treturn -1;", " \t\t\t}", " \t\t\tpclr->lutdata[i * pclr->numchans + j] = x;", " \t\t}", " \t}", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" rad_get_vendor_attr(u_int32_t *vendor, const void **data, size_t *len)", " rad_get_vendor_attr(u_int32_t *vendor, unsigned char *type, const void **data, size_t *len, const void *raw, size_t raw_len)", "  {", "  \tstruct vendor_attribute *attr;", "\tattr = (struct vendor_attribute *)*data;", " \tif (raw_len < sizeof(struct vendor_attribute)) {", " \t\treturn -1;", " \t}", " \tattr = (struct vendor_attribute *) raw;", "  \t*vendor = ntohl(attr->vendor_value);", " \t*type = attr->attrib_type;", "  \t*data = attr->attrib_data;", "  \t*len = attr->attrib_len - 2;", " \tif ((attr->attrib_len + 4) > raw_len) {", " \t\treturn -1;", " \t}", "  \treturn (attr->attrib_type);", "  }"], "ner_tags": [0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0]}
{"tokens": [" static int read_header(FFV1Context *f)", " {", "     uint8_t state[CONTEXT_SIZE];", "     int i, j, context_count = -1;  ", "     RangeCoder *const c = &f->slice_context[0]->c;", "      memset(state, 128, sizeof(state));", "      if (f->version < 2) {", "        int chroma_planes, chroma_h_shift, chroma_v_shift, transparency;", "         int chroma_planes, chroma_h_shift, chroma_v_shift, transparency, colorspace, bits_per_raw_sample;", "          unsigned v= get_symbol(c, state, 0);", "          if (v >= 2) {", "              av_log(f->avctx, AV_LOG_ERROR, \"invalid version %d in ver01 header\\n\", v);", "             return AVERROR_INVALIDDATA;", "         }", "         f->version = v;", "         f->ac      = f->avctx->coder_type = get_symbol(c, state, 0);", "         if (f->ac > 1) {", "             for (i = 1; i < 256; i++)", "                  f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];", "          }", "        f->colorspace = get_symbol(c, state, 0);  ", "        if (f->version > 0)", "            f->avctx->bits_per_raw_sample = get_symbol(c, state, 0);", "         colorspace     = get_symbol(c, state, 0);  ", "         bits_per_raw_sample = f->version > 0 ? get_symbol(c, state, 0) : f->avctx->bits_per_raw_sample;", "          chroma_planes  = get_rac(c, state);", "          chroma_h_shift = get_symbol(c, state, 0);", "          chroma_v_shift = get_symbol(c, state, 0);", "          transparency   = get_rac(c, state);", "          if (f->plane_count) {", "            if (   chroma_planes != f->chroma_planes", "             if (   colorspace    != f->colorspace", "                 || bits_per_raw_sample != f->avctx->bits_per_raw_sample", "                 || chroma_planes != f->chroma_planes", "                  || chroma_h_shift!= f->chroma_h_shift", "                  || chroma_v_shift!= f->chroma_v_shift", "                  || transparency  != f->transparency) {", "                 av_log(f->avctx, AV_LOG_ERROR, \"Invalid change of global parameters\\n\");", "                 return AVERROR_INVALIDDATA;", "              }", "          }", "         f->colorspace     = colorspace;", "         f->avctx->bits_per_raw_sample = bits_per_raw_sample;", "          f->chroma_planes  = chroma_planes;", "          f->chroma_h_shift = chroma_h_shift;", "          f->chroma_v_shift = chroma_v_shift;", "         f->transparency   = transparency;", "         f->plane_count    = 2 + f->transparency;", "     }", "     if (f->colorspace == 0) {", "         if (!f->transparency && !f->chroma_planes) {", "             if (f->avctx->bits_per_raw_sample <= 8)", "                 f->avctx->pix_fmt = AV_PIX_FMT_GRAY8;", "             else", "                 f->avctx->pix_fmt = AV_PIX_FMT_GRAY16;", "         } else if (f->avctx->bits_per_raw_sample<=8 && !f->transparency) {", "             switch(16 * f->chroma_h_shift + f->chroma_v_shift) {", "             case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P; break;", "             case 0x01: f->avctx->pix_fmt = AV_PIX_FMT_YUV440P; break;", "             case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P; break;", "             case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P; break;", "             case 0x20: f->avctx->pix_fmt = AV_PIX_FMT_YUV411P; break;", "             case 0x22: f->avctx->pix_fmt = AV_PIX_FMT_YUV410P; break;", "             default:", "                 av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");", "                 return AVERROR(ENOSYS);", "             }", "         } else if (f->avctx->bits_per_raw_sample <= 8 && f->transparency) {", "             switch(16*f->chroma_h_shift + f->chroma_v_shift) {", "             case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P; break;", "             case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P; break;", "             case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P; break;", "             default:", "                 av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");", "                 return AVERROR(ENOSYS);", "             }", "         } else if (f->avctx->bits_per_raw_sample == 9) {", "             f->packed_at_lsb = 1;", "             switch(16 * f->chroma_h_shift + f->chroma_v_shift) {", "             case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P9; break;", "             case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P9; break;", "             case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P9; break;", "             default:", "                 av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");", "                 return AVERROR(ENOSYS);", "             }", "         } else if (f->avctx->bits_per_raw_sample == 10) {", "             f->packed_at_lsb = 1;", "             switch(16 * f->chroma_h_shift + f->chroma_v_shift) {", "             case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P10; break;", "             case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P10; break;", "             case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P10; break;", "             default:", "                 av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");", "                 return AVERROR(ENOSYS);", "             }", "         } else {", "             switch(16 * f->chroma_h_shift + f->chroma_v_shift) {", "             case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P16; break;", "             case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P16; break;", "             case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P16; break;", "             default:", "                 av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");", "                 return AVERROR(ENOSYS);", "             }", "         }", "     } else if (f->colorspace == 1) {", "         if (f->chroma_h_shift || f->chroma_v_shift) {", "             av_log(f->avctx, AV_LOG_ERROR,", "                    \"chroma subsampling not supported in this colorspace\\n\");", "             return AVERROR(ENOSYS);", "         }", "         if (     f->avctx->bits_per_raw_sample ==  9)", "             f->avctx->pix_fmt = AV_PIX_FMT_GBRP9;", "         else if (f->avctx->bits_per_raw_sample == 10)", "             f->avctx->pix_fmt = AV_PIX_FMT_GBRP10;", "         else if (f->avctx->bits_per_raw_sample == 12)", "             f->avctx->pix_fmt = AV_PIX_FMT_GBRP12;", "         else if (f->avctx->bits_per_raw_sample == 14)", "             f->avctx->pix_fmt = AV_PIX_FMT_GBRP14;", "         else", "         if (f->transparency) f->avctx->pix_fmt = AV_PIX_FMT_RGB32;", "         else                 f->avctx->pix_fmt = AV_PIX_FMT_0RGB32;", "     } else {", "         av_log(f->avctx, AV_LOG_ERROR, \"colorspace not supported\\n\");", "         return AVERROR(ENOSYS);", "     }", "     av_dlog(f->avctx, \"%d %d %d\\n\",", "             f->chroma_h_shift, f->chroma_v_shift, f->avctx->pix_fmt);", "     if (f->version < 2) {", "         context_count = read_quant_tables(c, f->quant_table);", "         if (context_count < 0) {", "             av_log(f->avctx, AV_LOG_ERROR, \"read_quant_table error\\n\");", "             return AVERROR_INVALIDDATA;", "         }", "     } else if (f->version < 3) {", "         f->slice_count = get_symbol(c, state, 0);", "     } else {", "         const uint8_t *p = c->bytestream_end;", "         for (f->slice_count = 0;", "              f->slice_count < MAX_SLICES && 3 < p - c->bytestream_start;", "              f->slice_count++) {", "             int trailer = 3 + 5*!!f->ec;", "             int size = AV_RB24(p-trailer);", "             if (size + trailer > p - c->bytestream_start)", "                 break;", "             p -= size + trailer;", "         }", "     }", "     if (f->slice_count > (unsigned)MAX_SLICES || f->slice_count <= 0) {", "         av_log(f->avctx, AV_LOG_ERROR, \"slice count %d is invalid\\n\", f->slice_count);", "         return AVERROR_INVALIDDATA;", "     }", "     for (j = 0; j < f->slice_count; j++) {", "         FFV1Context *fs = f->slice_context[j];", "         fs->ac            = f->ac;", "         fs->packed_at_lsb = f->packed_at_lsb;", "         fs->slice_damaged = 0;", "         if (f->version == 2) {", "             fs->slice_x      =  get_symbol(c, state, 0)      * f->width ;", "             fs->slice_y      =  get_symbol(c, state, 0)      * f->height;", "             fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width  + fs->slice_x;", "             fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;", "             fs->slice_x     /= f->num_h_slices;", "             fs->slice_y     /= f->num_v_slices;", "             fs->slice_width  = fs->slice_width  / f->num_h_slices - fs->slice_x;", "             fs->slice_height = fs->slice_height / f->num_v_slices - fs->slice_y;", "             if ((unsigned)fs->slice_width  > f->width ||", "                 (unsigned)fs->slice_height > f->height)", "                 return AVERROR_INVALIDDATA;", "             if (   (unsigned)fs->slice_x + (uint64_t)fs->slice_width  > f->width", "                 || (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height)", "                 return AVERROR_INVALIDDATA;", "         }", "         for (i = 0; i < f->plane_count; i++) {", "             PlaneContext *const p = &fs->plane[i];", "             if (f->version == 2) {", "                 int idx = get_symbol(c, state, 0);", "                 if (idx > (unsigned)f->quant_table_count) {", "                     av_log(f->avctx, AV_LOG_ERROR,", "                            \"quant_table_index out of range\\n\");", "                     return AVERROR_INVALIDDATA;", "                 }", "                 p->quant_table_index = idx;", "                 memcpy(p->quant_table, f->quant_tables[idx],", "                        sizeof(p->quant_table));", "                 context_count = f->context_count[idx];", "             } else {", "                 memcpy(p->quant_table, f->quant_table, sizeof(p->quant_table));", "             }", "             if (f->version <= 2) {", "                 av_assert0(context_count >= 0);", "                 if (p->context_count < context_count) {", "                     av_freep(&p->state);", "                     av_freep(&p->vlc_state);", "                 }", "                 p->context_count = context_count;", "             }", "         }", "     }", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" match_at(regex_t* reg, const UChar* str, const UChar* end,", " #ifdef USE_MATCH_RANGE_MUST_BE_INSIDE_OF_SPECIFIED_RANGE", " \t const UChar* right_range,", " #endif", " \t const UChar* sstart, UChar* sprev, OnigMatchArg* msa)", " {", "   static UChar FinishCode[] = { OP_FINISH };", "   int i, n, num_mem, best_len, pop_level;", "   LengthType tlen, tlen2;", "   MemNumType mem;", "   RelAddrType addr;", "   UChar *s, *q, *sbegin;", "   int is_alloca;", "   char *alloc_base;", "   OnigStackType *stk_base, *stk, *stk_end;", "   OnigStackType *stkp;  ", "   OnigStackIndex si;", "   OnigStackIndex *repeat_stk;", "   OnigStackIndex *mem_start_stk, *mem_end_stk;", " #ifdef USE_COMBINATION_EXPLOSION_CHECK", "   int scv;", "   unsigned char* state_check_buff = msa->state_check_buff;", "   int num_comb_exp_check = reg->num_comb_exp_check;", " #endif", "   UChar *p = reg->p;", "   OnigOptionType option = reg->options;", "   OnigEncoding encode = reg->enc;", "   OnigCaseFoldType case_fold_flag = reg->case_fold_flag;", "   pop_level = reg->stack_pop_level;", "   num_mem = reg->num_mem;", "   STACK_INIT(INIT_MATCH_STACK_SIZE);", "   UPDATE_FOR_STACK_REALLOC;", "   for (i = 1; i <= num_mem; i++) {", "     mem_start_stk[i] = mem_end_stk[i] = INVALID_STACK_INDEX;", "   }", " #ifdef ONIG_DEBUG_MATCH", "   fprintf(stderr, \"match_at: str: %d, end: %d, start: %d, sprev: %d\\n\",", " \t  (int )str, (int )end, (int )sstart, (int )sprev);", "   fprintf(stderr, \"size: %d, start offset: %d\\n\",", " \t  (int )(end - str), (int )(sstart - str));", " #endif", "   STACK_PUSH_ENSURED(STK_ALT, FinishCode);   ", "   best_len = ONIG_MISMATCH;", "   s = (UChar* )sstart;", "   while (1) {", " #ifdef ONIG_DEBUG_MATCH", "     {", "       UChar *q, *bp, buf[50];", "       int len;", "       fprintf(stderr, \"%4d> \\\"\", (int )(s - str));", "       bp = buf;", "       for (i = 0, q = s; i < 7 && q < end; i++) {", " \tlen = enclen(encode, q);", " \twhile (len-- > 0) *bp++ = *q++;", "       }", "       if (q < end) { xmemcpy(bp, \"...\\\"\", 4); bp += 4; }", "       else         { xmemcpy(bp, \"\\\"\",    1); bp += 1; }", "       *bp = 0;", "       fputs((char* )buf, stderr);", "       for (i = 0; i < 20 - (bp - buf); i++) fputc(' ', stderr);", "       onig_print_compiled_byte_code(stderr, p, NULL, encode);", "       fprintf(stderr, \"\\n\");", "     }", " #endif", "     sbegin = s;", "     switch (*p++) {", "     case OP_END:  MOP_IN(OP_END);", "       n = s - sstart;", "       if (n > best_len) {", "         OnigRegion* region;", " #ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE", "         if (IS_FIND_LONGEST(option)) {", "           if (n > msa->best_len) {", "             msa->best_len = n;", "             msa->best_s   = (UChar* )sstart;", "           }", "           else", "             goto end_best_len;", "         }", " #endif", "         best_len = n;", "         region = msa->region;", "         if (region) {", " #ifdef USE_POSIX_API_REGION_OPTION", "           if (IS_POSIX_REGION(msa->options)) {", "             posix_regmatch_t* rmt = (posix_regmatch_t* )region;", "             rmt[0].rm_so = sstart - str;", "             rmt[0].rm_eo = s      - str;", "             for (i = 1; i <= num_mem; i++) {", "               if (mem_end_stk[i] != INVALID_STACK_INDEX) {", "                 if (BIT_STATUS_AT(reg->bt_mem_start, i))", "                   rmt[i].rm_so = STACK_AT(mem_start_stk[i])->u.mem.pstr - str;", "                 else", "                   rmt[i].rm_so = (UChar* )((void* )(mem_start_stk[i])) - str;", "                 rmt[i].rm_eo = (BIT_STATUS_AT(reg->bt_mem_end, i)", "                                 ? STACK_AT(mem_end_stk[i])->u.mem.pstr", "                                 : (UChar* )((void* )mem_end_stk[i])) - str;", "               }", "               else {", "                 rmt[i].rm_so = rmt[i].rm_eo = ONIG_REGION_NOTPOS;", "               }", "             }", "           }", "           else {", " #endif  ", "             region->beg[0] = sstart - str;", "             region->end[0] = s      - str;", "             for (i = 1; i <= num_mem; i++) {", "               if (mem_end_stk[i] != INVALID_STACK_INDEX) {", "                 if (BIT_STATUS_AT(reg->bt_mem_start, i))", "                   region->beg[i] = STACK_AT(mem_start_stk[i])->u.mem.pstr - str;", "                 else", "                   region->beg[i] = (UChar* )((void* )mem_start_stk[i]) - str;", "                 region->end[i] = (BIT_STATUS_AT(reg->bt_mem_end, i)", "                                   ? STACK_AT(mem_end_stk[i])->u.mem.pstr", "                                   : (UChar* )((void* )mem_end_stk[i])) - str;", "               }", "               else {", "                 region->beg[i] = region->end[i] = ONIG_REGION_NOTPOS;", "               }", "             }", " #ifdef USE_CAPTURE_HISTORY", "             if (reg->capture_history != 0) {", "               int r;", "               OnigCaptureTreeNode* node;", "               if (IS_NULL(region->history_root)) {", "                 region->history_root = node = history_node_new();", "                 CHECK_NULL_RETURN_MEMERR(node);", "               }", "               else {", "                 node = region->history_root;", "                 history_tree_clear(node);", "               }", "               node->group = 0;", "               node->beg   = sstart - str;", "               node->end   = s      - str;", "               stkp = stk_base;", "               r = make_capture_history_tree(region->history_root, &stkp,", "                                             stk, (UChar* )str, reg);", "               if (r < 0) {", "                 best_len = r;  ", "                 goto finish;", "               }", "             }", " #endif  ", " #ifdef USE_POSIX_API_REGION_OPTION", "           }  ", " #endif", "         }  ", "       }  ", " #ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE", "     end_best_len:", " #endif", "       MOP_OUT;", "       if (IS_FIND_CONDITION(option)) {", "         if (IS_FIND_NOT_EMPTY(option) && s == sstart) {", "           best_len = ONIG_MISMATCH;", "           goto fail;  ", "         }", "         if (IS_FIND_LONGEST(option) && DATA_ENSURE_CHECK1) {", "           goto fail;  ", "         }", "       }", "       goto finish;", "        break;", "      case OP_EXACT1:  MOP_IN(OP_EXACT1);", "#if 0", "        DATA_ENSURE(1);", "        if (*p != *s) goto fail;", "        p++; s++;", "#endif", "      if (*p != *s++) goto fail;", "      DATA_ENSURE(0);", "      p++;", "        MOP_OUT;", "        break;", "     case OP_EXACT1_IC:  MOP_IN(OP_EXACT1_IC);", "       {", "         int len;", "         UChar *q, lowbuf[ONIGENC_MBC_CASE_FOLD_MAXLEN];", "         DATA_ENSURE(1);", "         len = ONIGENC_MBC_CASE_FOLD(encode,", "                                     case_fold_flag,", "                                     &s, end, lowbuf);", "         DATA_ENSURE(0);", "         q = lowbuf;", "         while (len-- > 0) {", "           if (*p != *q) {", "             goto fail;", "           }", "           p++; q++;", "         }", "       }", "       MOP_OUT;", "       break;", "     case OP_EXACT2:  MOP_IN(OP_EXACT2);", "       DATA_ENSURE(2);", "       if (*p != *s) goto fail;", "       p++; s++;", "       if (*p != *s) goto fail;", "       sprev = s;", "       p++; s++;", "       MOP_OUT;", "       continue;", "       break;", "     case OP_EXACT3:  MOP_IN(OP_EXACT3);", "       DATA_ENSURE(3);", "       if (*p != *s) goto fail;", "       p++; s++;", "       if (*p != *s) goto fail;", "       p++; s++;", "       if (*p != *s) goto fail;", "       sprev = s;", "       p++; s++;", "       MOP_OUT;", "       continue;", "       break;", "     case OP_EXACT4:  MOP_IN(OP_EXACT4);", "       DATA_ENSURE(4);", "       if (*p != *s) goto fail;", "       p++; s++;", "       if (*p != *s) goto fail;", "       p++; s++;", "       if (*p != *s) goto fail;", "       p++; s++;", "       if (*p != *s) goto fail;", "       sprev = s;", "       p++; s++;", "       MOP_OUT;", "       continue;", "       break;", "     case OP_EXACT5:  MOP_IN(OP_EXACT5);", "       DATA_ENSURE(5);", "       if (*p != *s) goto fail;", "       p++; s++;", "       if (*p != *s) goto fail;", "       p++; s++;", "       if (*p != *s) goto fail;", "       p++; s++;", "       if (*p != *s) goto fail;", "       p++; s++;", "       if (*p != *s) goto fail;", "       sprev = s;", "       p++; s++;", "       MOP_OUT;", "       continue;", "       break;", "     case OP_EXACTN:  MOP_IN(OP_EXACTN);", "       GET_LENGTH_INC(tlen, p);", "       DATA_ENSURE(tlen);", "       while (tlen-- > 0) {", "         if (*p++ != *s++) goto fail;", "       }", "       sprev = s - 1;", "       MOP_OUT;", "       continue;", "       break;", "     case OP_EXACTN_IC:  MOP_IN(OP_EXACTN_IC);", "       {", "         int len;", "         UChar *q, *endp, lowbuf[ONIGENC_MBC_CASE_FOLD_MAXLEN];", "         GET_LENGTH_INC(tlen, p);", "         endp = p + tlen;", "         while (p < endp) {", "           sprev = s;", "           DATA_ENSURE(1);", "           len = ONIGENC_MBC_CASE_FOLD(encode,", "                                       case_fold_flag,", "                                       &s, end, lowbuf);", "           DATA_ENSURE(0);", "           q = lowbuf;", "           while (len-- > 0) {", "             if (*p != *q) goto fail;", "             p++; q++;", "           }", "         }", "       }", "       MOP_OUT;", "       continue;", "       break;", "     case OP_EXACTMB2N1:  MOP_IN(OP_EXACTMB2N1);", "       DATA_ENSURE(2);", "       if (*p != *s) goto fail;", "       p++; s++;", "       if (*p != *s) goto fail;", "       p++; s++;", "       MOP_OUT;", "       break;", "     case OP_EXACTMB2N2:  MOP_IN(OP_EXACTMB2N2);", "       DATA_ENSURE(4);", "       if (*p != *s) goto fail;", "       p++; s++;", "       if (*p != *s) goto fail;", "       p++; s++;", "       sprev = s;", "       if (*p != *s) goto fail;", "       p++; s++;", "       if (*p != *s) goto fail;", "       p++; s++;", "       MOP_OUT;", "       continue;", "       break;", "     case OP_EXACTMB2N3:  MOP_IN(OP_EXACTMB2N3);", "       DATA_ENSURE(6);", "       if (*p != *s) goto fail;", "       p++; s++;", "       if (*p != *s) goto fail;", "       p++; s++;", "       if (*p != *s) goto fail;", "       p++; s++;", "       if (*p != *s) goto fail;", "       p++; s++;", "       sprev = s;", "       if (*p != *s) goto fail;", "       p++; s++;", "       if (*p != *s) goto fail;", "       p++; s++;", "       MOP_OUT;", "       continue;", "       break;", "     case OP_EXACTMB2N:  MOP_IN(OP_EXACTMB2N);", "       GET_LENGTH_INC(tlen, p);", "       DATA_ENSURE(tlen * 2);", "       while (tlen-- > 0) {", "         if (*p != *s) goto fail;", "         p++; s++;", "         if (*p != *s) goto fail;", "         p++; s++;", "       }", "       sprev = s - 2;", "       MOP_OUT;", "       continue;", "       break;", "     case OP_EXACTMB3N:  MOP_IN(OP_EXACTMB3N);", "       GET_LENGTH_INC(tlen, p);", "       DATA_ENSURE(tlen * 3);", "       while (tlen-- > 0) {", "         if (*p != *s) goto fail;", "         p++; s++;", "         if (*p != *s) goto fail;", "         p++; s++;", "         if (*p != *s) goto fail;", "         p++; s++;", "       }", "       sprev = s - 3;", "       MOP_OUT;", "       continue;", "       break;", "     case OP_EXACTMBN:  MOP_IN(OP_EXACTMBN);", "       GET_LENGTH_INC(tlen,  p);   ", "       GET_LENGTH_INC(tlen2, p);   ", "       tlen2 *= tlen;", "       DATA_ENSURE(tlen2);", "       while (tlen2-- > 0) {", "         if (*p != *s) goto fail;", "         p++; s++;", "       }", "       sprev = s - tlen;", "       MOP_OUT;", "       continue;", "       break;", "     case OP_CCLASS:  MOP_IN(OP_CCLASS);", "       DATA_ENSURE(1);", "       if (BITSET_AT(((BitSetRef )p), *s) == 0) goto fail;", "       p += SIZE_BITSET;", "       s += enclen(encode, s);    ", "       MOP_OUT;", "       break;", "     case OP_CCLASS_MB:  MOP_IN(OP_CCLASS_MB);", "       if (! ONIGENC_IS_MBC_HEAD(encode, s)) goto fail;", "     cclass_mb:", "       GET_LENGTH_INC(tlen, p);", "       {", "         OnigCodePoint code;", "         UChar *ss;", "         int mb_len;", "         DATA_ENSURE(1);", "         mb_len = enclen(encode, s);", "         DATA_ENSURE(mb_len);", "         ss = s;", "         s += mb_len;", "         code = ONIGENC_MBC_TO_CODE(encode, ss, s);", " #ifdef PLATFORM_UNALIGNED_WORD_ACCESS", "         if (! onig_is_in_code_range(p, code)) goto fail;", " #else", "         q = p;", "         ALIGNMENT_RIGHT(q);", "         if (! onig_is_in_code_range(q, code)) goto fail;", " #endif", "       }", "       p += tlen;", "       MOP_OUT;", "       break;", "     case OP_CCLASS_MIX:  MOP_IN(OP_CCLASS_MIX);", "       DATA_ENSURE(1);", "       if (ONIGENC_IS_MBC_HEAD(encode, s)) {", "         p += SIZE_BITSET;", "         goto cclass_mb;", "       }", "       else {", "         if (BITSET_AT(((BitSetRef )p), *s) == 0)", "           goto fail;", "         p += SIZE_BITSET;", "         GET_LENGTH_INC(tlen, p);", "         p += tlen;", "         s++;", "       }", "       MOP_OUT;", "       break;", "     case OP_CCLASS_NOT:  MOP_IN(OP_CCLASS_NOT);", "       DATA_ENSURE(1);", "       if (BITSET_AT(((BitSetRef )p), *s) != 0) goto fail;", "       p += SIZE_BITSET;", "       s += enclen(encode, s);", "       MOP_OUT;", "       break;", "     case OP_CCLASS_MB_NOT:  MOP_IN(OP_CCLASS_MB_NOT);", "       DATA_ENSURE(1);", "       if (! ONIGENC_IS_MBC_HEAD(encode, s)) {", "         s++;", "         GET_LENGTH_INC(tlen, p);", "         p += tlen;", "         goto cc_mb_not_success;", "       }", "     cclass_mb_not:", "       GET_LENGTH_INC(tlen, p);", "       {", "         OnigCodePoint code;", "         UChar *ss;", "         int mb_len = enclen(encode, s);", "         if (! DATA_ENSURE_CHECK(mb_len)) {", "           DATA_ENSURE(1);", "           s = (UChar* )end;", "           p += tlen;", "           goto cc_mb_not_success;", "         }", "         ss = s;", "         s += mb_len;", "         code = ONIGENC_MBC_TO_CODE(encode, ss, s);", " #ifdef PLATFORM_UNALIGNED_WORD_ACCESS", "         if (onig_is_in_code_range(p, code)) goto fail;", " #else", "         q = p;", "         ALIGNMENT_RIGHT(q);", "         if (onig_is_in_code_range(q, code)) goto fail;", " #endif", "       }", "       p += tlen;", "     cc_mb_not_success:", "       MOP_OUT;", "       break;", "     case OP_CCLASS_MIX_NOT:  MOP_IN(OP_CCLASS_MIX_NOT);", "       DATA_ENSURE(1);", "       if (ONIGENC_IS_MBC_HEAD(encode, s)) {", "         p += SIZE_BITSET;", "         goto cclass_mb_not;", "       }", "       else {", "         if (BITSET_AT(((BitSetRef )p), *s) != 0)", "           goto fail;", "         p += SIZE_BITSET;", "         GET_LENGTH_INC(tlen, p);", "         p += tlen;", "         s++;", "       }", "       MOP_OUT;", "       break;", "     case OP_CCLASS_NODE:  MOP_IN(OP_CCLASS_NODE);", "       {", "         OnigCodePoint code;", "         void *node;", "         int mb_len;", "         UChar *ss;", "         DATA_ENSURE(1);", "         GET_POINTER_INC(node, p);", "         mb_len = enclen(encode, s);", "         ss = s;", "         s += mb_len;", "         DATA_ENSURE(0);", "         code = ONIGENC_MBC_TO_CODE(encode, ss, s);", "         if (onig_is_code_in_cc_len(mb_len, code, node) == 0) goto fail;", "       }", "       MOP_OUT;", "       break;", "     case OP_ANYCHAR:  MOP_IN(OP_ANYCHAR);", "       DATA_ENSURE(1);", "       n = enclen(encode, s);", "       DATA_ENSURE(n);", "       if (ONIGENC_IS_MBC_NEWLINE(encode, s, end)) goto fail;", "       s += n;", "       MOP_OUT;", "       break;", "     case OP_ANYCHAR_ML:  MOP_IN(OP_ANYCHAR_ML);", "       DATA_ENSURE(1);", "       n = enclen(encode, s);", "       DATA_ENSURE(n);", "       s += n;", "       MOP_OUT;", "       break;", "     case OP_ANYCHAR_STAR:  MOP_IN(OP_ANYCHAR_STAR);", "       while (DATA_ENSURE_CHECK1) {", "         STACK_PUSH_ALT(p, s, sprev);", "         n = enclen(encode, s);", "         DATA_ENSURE(n);", "         if (ONIGENC_IS_MBC_NEWLINE(encode, s, end))  goto fail;", "         sprev = s;", "         s += n;", "       }", "       MOP_OUT;", "       break;", "     case OP_ANYCHAR_ML_STAR:  MOP_IN(OP_ANYCHAR_ML_STAR);", "       while (DATA_ENSURE_CHECK1) {", "         STACK_PUSH_ALT(p, s, sprev);", "         n = enclen(encode, s);", "         if (n > 1) {", "           DATA_ENSURE(n);", "           sprev = s;", "           s += n;", "         }", "         else {", "           sprev = s;", "           s++;", "         }", "       }", "       MOP_OUT;", "       break;", "     case OP_ANYCHAR_STAR_PEEK_NEXT:  MOP_IN(OP_ANYCHAR_STAR_PEEK_NEXT);", "       while (DATA_ENSURE_CHECK1) {", "         if (*p == *s) {", "           STACK_PUSH_ALT(p + 1, s, sprev);", "         }", "         n = enclen(encode, s);", "         DATA_ENSURE(n);", "         if (ONIGENC_IS_MBC_NEWLINE(encode, s, end))  goto fail;", "         sprev = s;", "         s += n;", "       }", "       p++;", "       MOP_OUT;", "       break;", "     case OP_ANYCHAR_ML_STAR_PEEK_NEXT:MOP_IN(OP_ANYCHAR_ML_STAR_PEEK_NEXT);", "       while (DATA_ENSURE_CHECK1) {", "         if (*p == *s) {", "           STACK_PUSH_ALT(p + 1, s, sprev);", "         }", "         n = enclen(encode, s);", "         if (n > 1) {", "           DATA_ENSURE(n);", "           sprev = s;", "           s += n;", "         }", "         else {", "           sprev = s;", "           s++;", "         }", "       }", "       p++;", "       MOP_OUT;", "       break;", " #ifdef USE_COMBINATION_EXPLOSION_CHECK", "     case OP_STATE_CHECK_ANYCHAR_STAR:  MOP_IN(OP_STATE_CHECK_ANYCHAR_STAR);", "       GET_STATE_CHECK_NUM_INC(mem, p);", "       while (DATA_ENSURE_CHECK1) {", "         STATE_CHECK_VAL(scv, mem);", "         if (scv) goto fail;", "         STACK_PUSH_ALT_WITH_STATE_CHECK(p, s, sprev, mem);", "         n = enclen(encode, s);", "         DATA_ENSURE(n);", "         if (ONIGENC_IS_MBC_NEWLINE(encode, s, end))  goto fail;", "         sprev = s;", "         s += n;", "       }", "       MOP_OUT;", "       break;", "     case OP_STATE_CHECK_ANYCHAR_ML_STAR:", "       MOP_IN(OP_STATE_CHECK_ANYCHAR_ML_STAR);", "       GET_STATE_CHECK_NUM_INC(mem, p);", "       while (DATA_ENSURE_CHECK1) {", "         STATE_CHECK_VAL(scv, mem);", "         if (scv) goto fail;", "         STACK_PUSH_ALT_WITH_STATE_CHECK(p, s, sprev, mem);", "         n = enclen(encode, s);", "         if (n > 1) {", "           DATA_ENSURE(n);", "           sprev = s;", "           s += n;", "         }", "         else {", "           sprev = s;", "           s++;", "         }", "       }", "       MOP_OUT;", "       break;", " #endif  ", "     case OP_WORD:  MOP_IN(OP_WORD);", "       DATA_ENSURE(1);", "       if (! ONIGENC_IS_MBC_WORD(encode, s, end))", "         goto fail;", "       s += enclen(encode, s);", "       MOP_OUT;", "       break;", "     case OP_NOT_WORD:  MOP_IN(OP_NOT_WORD);", "       DATA_ENSURE(1);", "       if (ONIGENC_IS_MBC_WORD(encode, s, end))", "         goto fail;", "       s += enclen(encode, s);", "       MOP_OUT;", "       break;", "     case OP_WORD_BOUND:  MOP_IN(OP_WORD_BOUND);", "       if (ON_STR_BEGIN(s)) {", "         DATA_ENSURE(1);", "         if (! ONIGENC_IS_MBC_WORD(encode, s, end))", "           goto fail;", "       }", "       else if (ON_STR_END(s)) {", "         if (! ONIGENC_IS_MBC_WORD(encode, sprev, end))", "           goto fail;", "       }", "       else {", "         if (ONIGENC_IS_MBC_WORD(encode, s, end)", "             == ONIGENC_IS_MBC_WORD(encode, sprev, end))", "           goto fail;", "       }", "       MOP_OUT;", "       continue;", "       break;", "     case OP_NOT_WORD_BOUND:  MOP_IN(OP_NOT_WORD_BOUND);", "       if (ON_STR_BEGIN(s)) {", "         if (DATA_ENSURE_CHECK1 && ONIGENC_IS_MBC_WORD(encode, s, end))", "           goto fail;", "       }", "       else if (ON_STR_END(s)) {", "         if (ONIGENC_IS_MBC_WORD(encode, sprev, end))", "           goto fail;", "       }", "       else {", "         if (ONIGENC_IS_MBC_WORD(encode, s, end)", "             != ONIGENC_IS_MBC_WORD(encode, sprev, end))", "           goto fail;", "       }", "       MOP_OUT;", "       continue;", "       break;", " #ifdef USE_WORD_BEGIN_END", "     case OP_WORD_BEGIN:  MOP_IN(OP_WORD_BEGIN);", "       if (DATA_ENSURE_CHECK1 && ONIGENC_IS_MBC_WORD(encode, s, end)) {", "         if (ON_STR_BEGIN(s) || !ONIGENC_IS_MBC_WORD(encode, sprev, end)) {", "           MOP_OUT;", "           continue;", "         }", "       }", "       goto fail;", "       break;", "     case OP_WORD_END:  MOP_IN(OP_WORD_END);", "       if (!ON_STR_BEGIN(s) && ONIGENC_IS_MBC_WORD(encode, sprev, end)) {", "         if (ON_STR_END(s) || !ONIGENC_IS_MBC_WORD(encode, s, end)) {", "           MOP_OUT;", "           continue;", "         }", "       }", "       goto fail;", "       break;", " #endif", "     case OP_BEGIN_BUF:  MOP_IN(OP_BEGIN_BUF);", "       if (! ON_STR_BEGIN(s)) goto fail;", "       MOP_OUT;", "       continue;", "       break;", "     case OP_END_BUF:  MOP_IN(OP_END_BUF);", "       if (! ON_STR_END(s)) goto fail;", "       MOP_OUT;", "       continue;", "       break;", "     case OP_BEGIN_LINE:  MOP_IN(OP_BEGIN_LINE);", "       if (ON_STR_BEGIN(s)) {", "         if (IS_NOTBOL(msa->options)) goto fail;", "         MOP_OUT;", "         continue;", "       }", "       else if (ONIGENC_IS_MBC_NEWLINE(encode, sprev, end) && !ON_STR_END(s)) {", "         MOP_OUT;", "         continue;", "       }", "       goto fail;", "       break;", "     case OP_END_LINE:  MOP_IN(OP_END_LINE);", "       if (ON_STR_END(s)) {", " #ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE", "         if (IS_EMPTY_STR || !ONIGENC_IS_MBC_NEWLINE(encode, sprev, end)) {", " #endif", "           if (IS_NOTEOL(msa->options)) goto fail;", "           MOP_OUT;", "           continue;", " #ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE", "         }", " #endif", "       }", "       else if (ONIGENC_IS_MBC_NEWLINE(encode, s, end)) {", "         MOP_OUT;", "         continue;", "       }", " #ifdef USE_CRNL_AS_LINE_TERMINATOR", "       else if (ONIGENC_IS_MBC_CRNL(encode, s, end)) {", "         MOP_OUT;", "         continue;", "       }", " #endif", "       goto fail;", "       break;", "     case OP_SEMI_END_BUF:  MOP_IN(OP_SEMI_END_BUF);", "       if (ON_STR_END(s)) {", " #ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE", "         if (IS_EMPTY_STR || !ONIGENC_IS_MBC_NEWLINE(encode, sprev, end)) {", " #endif", "           if (IS_NOTEOL(msa->options)) goto fail;", "           MOP_OUT;", "           continue;", " #ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE", "         }", " #endif", "       }", "       else if (ONIGENC_IS_MBC_NEWLINE(encode, s, end) &&", "                ON_STR_END(s + enclen(encode, s))) {", "         MOP_OUT;", "         continue;", "       }", " #ifdef USE_CRNL_AS_LINE_TERMINATOR", "       else if (ONIGENC_IS_MBC_CRNL(encode, s, end)) {", "         UChar* ss = s + enclen(encode, s);", "         ss += enclen(encode, ss);", "         if (ON_STR_END(ss)) {", "           MOP_OUT;", "           continue;", "         }", "       }", " #endif", "       goto fail;", "       break;", "     case OP_BEGIN_POSITION:  MOP_IN(OP_BEGIN_POSITION);", "       if (s != msa->start)", "         goto fail;", "       MOP_OUT;", "       continue;", "       break;", "     case OP_MEMORY_START_PUSH:  MOP_IN(OP_MEMORY_START_PUSH);", "       GET_MEMNUM_INC(mem, p);", "       STACK_PUSH_MEM_START(mem, s);", "       MOP_OUT;", "       continue;", "       break;", "     case OP_MEMORY_START:  MOP_IN(OP_MEMORY_START);", "       GET_MEMNUM_INC(mem, p);", "       mem_start_stk[mem] = (OnigStackIndex )((void* )s);", "       MOP_OUT;", "       continue;", "       break;", "     case OP_MEMORY_END_PUSH:  MOP_IN(OP_MEMORY_END_PUSH);", "       GET_MEMNUM_INC(mem, p);", "       STACK_PUSH_MEM_END(mem, s);", "       MOP_OUT;", "       continue;", "       break;", "     case OP_MEMORY_END:  MOP_IN(OP_MEMORY_END);", "       GET_MEMNUM_INC(mem, p);", "       mem_end_stk[mem] = (OnigStackIndex )((void* )s);", "       MOP_OUT;", "       continue;", "       break;", " #ifdef USE_SUBEXP_CALL", "     case OP_MEMORY_END_PUSH_REC:  MOP_IN(OP_MEMORY_END_PUSH_REC);", "       GET_MEMNUM_INC(mem, p);", "       STACK_GET_MEM_START(mem, stkp);  ", "       STACK_PUSH_MEM_END(mem, s);", "       mem_start_stk[mem] = GET_STACK_INDEX(stkp);", "       MOP_OUT;", "       continue;", "       break;", "     case OP_MEMORY_END_REC:  MOP_IN(OP_MEMORY_END_REC);", "       GET_MEMNUM_INC(mem, p);", "       mem_end_stk[mem] = (OnigStackIndex )((void* )s);", "       STACK_GET_MEM_START(mem, stkp);", "       if (BIT_STATUS_AT(reg->bt_mem_start, mem))", "         mem_start_stk[mem] = GET_STACK_INDEX(stkp);", "       else", "         mem_start_stk[mem] = (OnigStackIndex )((void* )stkp->u.mem.pstr);", "       STACK_PUSH_MEM_END_MARK(mem);", "       MOP_OUT;", "       continue;", "       break;", " #endif", "     case OP_BACKREF1:  MOP_IN(OP_BACKREF1);", "       mem = 1;", "       goto backref;", "       break;", "     case OP_BACKREF2:  MOP_IN(OP_BACKREF2);", "       mem = 2;", "       goto backref;", "       break;", "     case OP_BACKREFN:  MOP_IN(OP_BACKREFN);", "       GET_MEMNUM_INC(mem, p);", "     backref:", "       {", "         int len;", "         UChar *pstart, *pend;", "         if (mem > num_mem) goto fail;", "         if (mem_end_stk[mem]   == INVALID_STACK_INDEX) goto fail;", "         if (mem_start_stk[mem] == INVALID_STACK_INDEX) goto fail;", "         if (BIT_STATUS_AT(reg->bt_mem_start, mem))", "           pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;", "         else", "           pstart = (UChar* )((void* )mem_start_stk[mem]);", "         pend = (BIT_STATUS_AT(reg->bt_mem_end, mem)", "                 ? STACK_AT(mem_end_stk[mem])->u.mem.pstr", "                 : (UChar* )((void* )mem_end_stk[mem]));", "         n = pend - pstart;", "         DATA_ENSURE(n);", "         sprev = s;", "         STRING_CMP(pstart, s, n);", "         while (sprev + (len = enclen(encode, sprev)) < s)", "           sprev += len;", "         MOP_OUT;", "         continue;", "       }", "       break;", "     case OP_BACKREFN_IC:  MOP_IN(OP_BACKREFN_IC);", "       GET_MEMNUM_INC(mem, p);", "       {", "         int len;", "         UChar *pstart, *pend;", "         if (mem > num_mem) goto fail;", "         if (mem_end_stk[mem]   == INVALID_STACK_INDEX) goto fail;", "         if (mem_start_stk[mem] == INVALID_STACK_INDEX) goto fail;", "         if (BIT_STATUS_AT(reg->bt_mem_start, mem))", "           pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;", "         else", "           pstart = (UChar* )((void* )mem_start_stk[mem]);", "         pend = (BIT_STATUS_AT(reg->bt_mem_end, mem)", "                 ? STACK_AT(mem_end_stk[mem])->u.mem.pstr", "                 : (UChar* )((void* )mem_end_stk[mem]));", "         n = pend - pstart;", "         DATA_ENSURE(n);", "         sprev = s;", "         STRING_CMP_IC(case_fold_flag, pstart, &s, n);", "         while (sprev + (len = enclen(encode, sprev)) < s)", "           sprev += len;", "         MOP_OUT;", "         continue;", "       }", "       break;", "     case OP_BACKREF_MULTI:  MOP_IN(OP_BACKREF_MULTI);", "       {", "         int len, is_fail;", "         UChar *pstart, *pend, *swork;", "         GET_LENGTH_INC(tlen, p);", "         for (i = 0; i < tlen; i++) {", "           GET_MEMNUM_INC(mem, p);", "           if (mem_end_stk[mem]   == INVALID_STACK_INDEX) continue;", "           if (mem_start_stk[mem] == INVALID_STACK_INDEX) continue;", "           if (BIT_STATUS_AT(reg->bt_mem_start, mem))", "             pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;", "           else", "             pstart = (UChar* )((void* )mem_start_stk[mem]);", "           pend = (BIT_STATUS_AT(reg->bt_mem_end, mem)", "                   ? STACK_AT(mem_end_stk[mem])->u.mem.pstr", "                   : (UChar* )((void* )mem_end_stk[mem]));", "           n = pend - pstart;", "           DATA_ENSURE(n);", "           sprev = s;", "           swork = s;", "           STRING_CMP_VALUE(pstart, swork, n, is_fail);", "           if (is_fail) continue;", "           s = swork;", "           while (sprev + (len = enclen(encode, sprev)) < s)", "             sprev += len;", "           p += (SIZE_MEMNUM * (tlen - i - 1));", "           break;  ", "         }", "         if (i == tlen) goto fail;", "         MOP_OUT;", "         continue;", "       }", "       break;", "     case OP_BACKREF_MULTI_IC:  MOP_IN(OP_BACKREF_MULTI_IC);", "       {", "         int len, is_fail;", "         UChar *pstart, *pend, *swork;", "         GET_LENGTH_INC(tlen, p);", "         for (i = 0; i < tlen; i++) {", "           GET_MEMNUM_INC(mem, p);", "           if (mem_end_stk[mem]   == INVALID_STACK_INDEX) continue;", "           if (mem_start_stk[mem] == INVALID_STACK_INDEX) continue;", "           if (BIT_STATUS_AT(reg->bt_mem_start, mem))", "             pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;", "           else", "             pstart = (UChar* )((void* )mem_start_stk[mem]);", "           pend = (BIT_STATUS_AT(reg->bt_mem_end, mem)", "                   ? STACK_AT(mem_end_stk[mem])->u.mem.pstr", "                   : (UChar* )((void* )mem_end_stk[mem]));", "           n = pend - pstart;", "           DATA_ENSURE(n);", "           sprev = s;", "           swork = s;", "           STRING_CMP_VALUE_IC(case_fold_flag, pstart, &swork, n, is_fail);", "           if (is_fail) continue;", "           s = swork;", "           while (sprev + (len = enclen(encode, sprev)) < s)", "             sprev += len;", "           p += (SIZE_MEMNUM * (tlen - i - 1));", "           break;  ", "         }", "         if (i == tlen) goto fail;", "         MOP_OUT;", "         continue;", "       }", "       break;", " #ifdef USE_BACKREF_WITH_LEVEL", "     case OP_BACKREF_WITH_LEVEL:", "       {", "         int len;", "         OnigOptionType ic;", "         LengthType level;", "         GET_OPTION_INC(ic,    p);", "         GET_LENGTH_INC(level, p);", "         GET_LENGTH_INC(tlen,  p);", "         sprev = s;", "         if (backref_match_at_nested_level(reg, stk, stk_base, ic", "                      , case_fold_flag, (int )level, (int )tlen, p, &s, end)) {", "           while (sprev + (len = enclen(encode, sprev)) < s)", "             sprev += len;", "           p += (SIZE_MEMNUM * tlen);", "         }", "         else", "           goto fail;", "         MOP_OUT;", "         continue;", "       }", "       break;", " #endif", " #if 0    ", "     case OP_SET_OPTION_PUSH:  MOP_IN(OP_SET_OPTION_PUSH);", "       GET_OPTION_INC(option, p);", "       STACK_PUSH_ALT(p, s, sprev);", "       p += SIZE_OP_SET_OPTION + SIZE_OP_FAIL;", "       MOP_OUT;", "       continue;", "       break;", "     case OP_SET_OPTION:  MOP_IN(OP_SET_OPTION);", "       GET_OPTION_INC(option, p);", "       MOP_OUT;", "       continue;", "       break;", " #endif", "     case OP_NULL_CHECK_START:  MOP_IN(OP_NULL_CHECK_START);", "       GET_MEMNUM_INC(mem, p);     ", "       STACK_PUSH_NULL_CHECK_START(mem, s);", "       MOP_OUT;", "       continue;", "       break;", "     case OP_NULL_CHECK_END:  MOP_IN(OP_NULL_CHECK_END);", "       {", "         int isnull;", "         GET_MEMNUM_INC(mem, p);  ", "         STACK_NULL_CHECK(isnull, mem, s);", "         if (isnull) {", " #ifdef ONIG_DEBUG_MATCH", "           fprintf(stderr, \"NULL_CHECK_END: skip  id:%d, s:%d\\n\",", "                   (int )mem, (int )s);", " #endif", "         null_check_found:", "           switch (*p++) {", "           case OP_JUMP:", "           case OP_PUSH:", "             p += SIZE_RELADDR;", "             break;", "           case OP_REPEAT_INC:", "           case OP_REPEAT_INC_NG:", "           case OP_REPEAT_INC_SG:", "           case OP_REPEAT_INC_NG_SG:", "             p += SIZE_MEMNUM;", "             break;", "           default:", "             goto unexpected_bytecode_error;", "             break;", "           }", "         }", "       }", "       MOP_OUT;", "       continue;", "       break;", " #ifdef USE_MONOMANIAC_CHECK_CAPTURES_IN_ENDLESS_REPEAT", "     case OP_NULL_CHECK_END_MEMST:  MOP_IN(OP_NULL_CHECK_END_MEMST);", "       {", "         int isnull;", "         GET_MEMNUM_INC(mem, p);  ", "         STACK_NULL_CHECK_MEMST(isnull, mem, s, reg);", "         if (isnull) {", " #ifdef ONIG_DEBUG_MATCH", "           fprintf(stderr, \"NULL_CHECK_END_MEMST: skip  id:%d, s:%d\\n\",", "                   (int )mem, (int )s);", " #endif", "           if (isnull == -1) goto fail;", "           goto \tnull_check_found;", "         }", "       }", "       MOP_OUT;", "       continue;", "       break;", " #endif", " #ifdef USE_SUBEXP_CALL", "     case OP_NULL_CHECK_END_MEMST_PUSH:", "       MOP_IN(OP_NULL_CHECK_END_MEMST_PUSH);", "       {", "         int isnull;", "         GET_MEMNUM_INC(mem, p);  ", " #ifdef USE_MONOMANIAC_CHECK_CAPTURES_IN_ENDLESS_REPEAT", "         STACK_NULL_CHECK_MEMST_REC(isnull, mem, s, reg);", " #else", "         STACK_NULL_CHECK_REC(isnull, mem, s);", " #endif", "         if (isnull) {", " #ifdef ONIG_DEBUG_MATCH", "           fprintf(stderr, \"NULL_CHECK_END_MEMST_PUSH: skip  id:%d, s:%d\\n\",", "                   (int )mem, (int )s);", " #endif", "           if (isnull == -1) goto fail;", "           goto \tnull_check_found;", "         }", "         else {", "           STACK_PUSH_NULL_CHECK_END(mem);", "         }", "       }", "       MOP_OUT;", "       continue;", "       break;", " #endif", "     case OP_JUMP:  MOP_IN(OP_JUMP);", "       GET_RELADDR_INC(addr, p);", "       p += addr;", "       MOP_OUT;", "       CHECK_INTERRUPT_IN_MATCH_AT;", "       continue;", "       break;", "     case OP_PUSH:  MOP_IN(OP_PUSH);", "       GET_RELADDR_INC(addr, p);", "       STACK_PUSH_ALT(p + addr, s, sprev);", "       MOP_OUT;", "       continue;", "       break;", " #ifdef USE_COMBINATION_EXPLOSION_CHECK", "     case OP_STATE_CHECK_PUSH:  MOP_IN(OP_STATE_CHECK_PUSH);", "       GET_STATE_CHECK_NUM_INC(mem, p);", "       STATE_CHECK_VAL(scv, mem);", "       if (scv) goto fail;", "       GET_RELADDR_INC(addr, p);", "       STACK_PUSH_ALT_WITH_STATE_CHECK(p + addr, s, sprev, mem);", "       MOP_OUT;", "       continue;", "       break;", "     case OP_STATE_CHECK_PUSH_OR_JUMP:  MOP_IN(OP_STATE_CHECK_PUSH_OR_JUMP);", "       GET_STATE_CHECK_NUM_INC(mem, p);", "       GET_RELADDR_INC(addr, p);", "       STATE_CHECK_VAL(scv, mem);", "       if (scv) {", "         p += addr;", "       }", "       else {", "         STACK_PUSH_ALT_WITH_STATE_CHECK(p + addr, s, sprev, mem);", "       }", "       MOP_OUT;", "       continue;", "       break;", "     case OP_STATE_CHECK:  MOP_IN(OP_STATE_CHECK);", "       GET_STATE_CHECK_NUM_INC(mem, p);", "       STATE_CHECK_VAL(scv, mem);", "       if (scv) goto fail;", "       STACK_PUSH_STATE_CHECK(s, mem);", "       MOP_OUT;", "       continue;", "       break;", " #endif  ", "     case OP_POP:  MOP_IN(OP_POP);", "       STACK_POP_ONE;", "       MOP_OUT;", "       continue;", "       break;", "     case OP_PUSH_OR_JUMP_EXACT1:  MOP_IN(OP_PUSH_OR_JUMP_EXACT1);", "       GET_RELADDR_INC(addr, p);", "       if (*p == *s && DATA_ENSURE_CHECK1) {", "         p++;", "         STACK_PUSH_ALT(p + addr, s, sprev);", "         MOP_OUT;", "         continue;", "       }", "       p += (addr + 1);", "       MOP_OUT;", "       continue;", "       break;", "     case OP_PUSH_IF_PEEK_NEXT:  MOP_IN(OP_PUSH_IF_PEEK_NEXT);", "       GET_RELADDR_INC(addr, p);", "       if (*p == *s) {", "         p++;", "         STACK_PUSH_ALT(p + addr, s, sprev);", "         MOP_OUT;", "         continue;", "       }", "       p++;", "       MOP_OUT;", "       continue;", "       break;", "     case OP_REPEAT:  MOP_IN(OP_REPEAT);", "       {", "         GET_MEMNUM_INC(mem, p);     ", "         GET_RELADDR_INC(addr, p);", "         STACK_ENSURE(1);", "         repeat_stk[mem] = GET_STACK_INDEX(stk);", "         STACK_PUSH_REPEAT(mem, p);", "         if (reg->repeat_range[mem].lower == 0) {", "           STACK_PUSH_ALT(p + addr, s, sprev);", "         }", "       }", "       MOP_OUT;", "       continue;", "       break;", "     case OP_REPEAT_NG:  MOP_IN(OP_REPEAT_NG);", "       {", "         GET_MEMNUM_INC(mem, p);     ", "         GET_RELADDR_INC(addr, p);", "         STACK_ENSURE(1);", "         repeat_stk[mem] = GET_STACK_INDEX(stk);", "         STACK_PUSH_REPEAT(mem, p);", "         if (reg->repeat_range[mem].lower == 0) {", "           STACK_PUSH_ALT(p, s, sprev);", "           p += addr;", "         }", "       }", "       MOP_OUT;", "       continue;", "       break;", "     case OP_REPEAT_INC:  MOP_IN(OP_REPEAT_INC);", "       GET_MEMNUM_INC(mem, p);  ", "       si = repeat_stk[mem];", "       stkp = STACK_AT(si);", "     repeat_inc:", "       stkp->u.repeat.count++;", "       if (stkp->u.repeat.count >= reg->repeat_range[mem].upper) {", "       }", "       else if (stkp->u.repeat.count >= reg->repeat_range[mem].lower) {", "         STACK_PUSH_ALT(p, s, sprev);", "         p = STACK_AT(si)->u.repeat.pcode;  ", "       }", "       else {", "         p = stkp->u.repeat.pcode;", "       }", "       STACK_PUSH_REPEAT_INC(si);", "       MOP_OUT;", "       CHECK_INTERRUPT_IN_MATCH_AT;", "       continue;", "       break;", "     case OP_REPEAT_INC_SG:  MOP_IN(OP_REPEAT_INC_SG);", "       GET_MEMNUM_INC(mem, p);  ", "       STACK_GET_REPEAT(mem, stkp);", "       si = GET_STACK_INDEX(stkp);", "       goto repeat_inc;", "       break;", "     case OP_REPEAT_INC_NG:  MOP_IN(OP_REPEAT_INC_NG);", "       GET_MEMNUM_INC(mem, p);  ", "       si = repeat_stk[mem];", "       stkp = STACK_AT(si);", "     repeat_inc_ng:", "       stkp->u.repeat.count++;", "       if (stkp->u.repeat.count < reg->repeat_range[mem].upper) {", "         if (stkp->u.repeat.count >= reg->repeat_range[mem].lower) {", "           UChar* pcode = stkp->u.repeat.pcode;", "           STACK_PUSH_REPEAT_INC(si);", "           STACK_PUSH_ALT(pcode, s, sprev);", "         }", "         else {", "           p = stkp->u.repeat.pcode;", "           STACK_PUSH_REPEAT_INC(si);", "         }", "       }", "       else if (stkp->u.repeat.count == reg->repeat_range[mem].upper) {", "         STACK_PUSH_REPEAT_INC(si);", "       }", "       MOP_OUT;", "       CHECK_INTERRUPT_IN_MATCH_AT;", "       continue;", "       break;", "     case OP_REPEAT_INC_NG_SG:  MOP_IN(OP_REPEAT_INC_NG_SG);", "       GET_MEMNUM_INC(mem, p);  ", "       STACK_GET_REPEAT(mem, stkp);", "       si = GET_STACK_INDEX(stkp);", "       goto repeat_inc_ng;", "       break;", "     case OP_PUSH_POS:  MOP_IN(OP_PUSH_POS);", "       STACK_PUSH_POS(s, sprev);", "       MOP_OUT;", "       continue;", "       break;", "     case OP_POP_POS:  MOP_IN(OP_POP_POS);", "       {", "         STACK_POS_END(stkp);", "         s     = stkp->u.state.pstr;", "         sprev = stkp->u.state.pstr_prev;", "       }", "       MOP_OUT;", "       continue;", "       break;", "     case OP_PUSH_POS_NOT:  MOP_IN(OP_PUSH_POS_NOT);", "       GET_RELADDR_INC(addr, p);", "       STACK_PUSH_POS_NOT(p + addr, s, sprev);", "       MOP_OUT;", "       continue;", "       break;", "     case OP_FAIL_POS:  MOP_IN(OP_FAIL_POS);", "       STACK_POP_TIL_POS_NOT;", "       goto fail;", "       break;", "     case OP_PUSH_STOP_BT:  MOP_IN(OP_PUSH_STOP_BT);", "       STACK_PUSH_STOP_BT;", "       MOP_OUT;", "       continue;", "       break;", "     case OP_POP_STOP_BT:  MOP_IN(OP_POP_STOP_BT);", "       STACK_STOP_BT_END;", "       MOP_OUT;", "       continue;", "       break;", "     case OP_LOOK_BEHIND:  MOP_IN(OP_LOOK_BEHIND);", "       GET_LENGTH_INC(tlen, p);", "       s = (UChar* )ONIGENC_STEP_BACK(encode, str, s, (int )tlen);", "       if (IS_NULL(s)) goto fail;", "       sprev = (UChar* )onigenc_get_prev_char_head(encode, str, s);", "       MOP_OUT;", "       continue;", "       break;", "     case OP_PUSH_LOOK_BEHIND_NOT:  MOP_IN(OP_PUSH_LOOK_BEHIND_NOT);", "       GET_RELADDR_INC(addr, p);", "       GET_LENGTH_INC(tlen, p);", "       q = (UChar* )ONIGENC_STEP_BACK(encode, str, s, (int )tlen);", "       if (IS_NULL(q)) {", "         p += addr;", "       }", "       else {", "         STACK_PUSH_LOOK_BEHIND_NOT(p + addr, s, sprev);", "         s = q;", "         sprev = (UChar* )onigenc_get_prev_char_head(encode, str, s);", "       }", "       MOP_OUT;", "       continue;", "       break;", "     case OP_FAIL_LOOK_BEHIND_NOT:  MOP_IN(OP_FAIL_LOOK_BEHIND_NOT);", "       STACK_POP_TIL_LOOK_BEHIND_NOT;", "       goto fail;", "       break;", " #ifdef USE_SUBEXP_CALL", "     case OP_CALL:  MOP_IN(OP_CALL);", "       GET_ABSADDR_INC(addr, p);", "       STACK_PUSH_CALL_FRAME(p);", "       p = reg->p + addr;", "       MOP_OUT;", "       continue;", "       break;", "     case OP_RETURN:  MOP_IN(OP_RETURN);", "       STACK_RETURN(p);", "       STACK_PUSH_RETURN;", "       MOP_OUT;", "       continue;", "       break;", " #endif", "     case OP_FINISH:", "       goto finish;", "       break;", "     fail:", "       MOP_OUT;", "     case OP_FAIL:  MOP_IN(OP_FAIL);", "       STACK_POP;", "       p     = stk->u.state.pcode;", "       s     = stk->u.state.pstr;", "       sprev = stk->u.state.pstr_prev;", " #ifdef USE_COMBINATION_EXPLOSION_CHECK", "       if (stk->u.state.state_check != 0) {", "         stk->type = STK_STATE_CHECK_MARK;", "         stk++;", "       }", " #endif", "       MOP_OUT;", "       continue;", "       break;", "     default:", "       goto bytecode_error;", "     }  ", "     sprev = sbegin;", "   }  ", "  finish:", "   STACK_SAVE;", "   return best_len;", " #ifdef ONIG_DEBUG", "  stack_error:", "   STACK_SAVE;", "   return ONIGERR_STACK_BUG;", " #endif", "  bytecode_error:", "   STACK_SAVE;", "   return ONIGERR_UNDEFINED_BYTECODE;", "  unexpected_bytecode_error:", "   STACK_SAVE;", "   return ONIGERR_UNEXPECTED_BYTECODE;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static size_t ZSTD_encodeSequences(", "             void* dst, size_t dstCapacity,", "             FSE_CTable const* CTable_MatchLength, BYTE const* mlCodeTable,", "             FSE_CTable const* CTable_OffsetBits, BYTE const* ofCodeTable,", "              FSE_CTable const* CTable_LitLength, BYTE const* llCodeTable,", "              seqDef const* sequences, size_t nbSeq, int longOffsets, int bmi2)", "  {", "     DEBUGLOG(5, \"ZSTD_encodeSequences: dstCapacity = %u\", (unsigned)dstCapacity);", "  #if DYNAMIC_BMI2", "      if (bmi2) {", "          return ZSTD_encodeSequences_bmi2(dst, dstCapacity,", "                                          CTable_MatchLength, mlCodeTable,", "                                          CTable_OffsetBits, ofCodeTable,", "                                          CTable_LitLength, llCodeTable,", "                                          sequences, nbSeq, longOffsets);", "     }", " #endif", "     (void)bmi2;", "     return ZSTD_encodeSequences_default(dst, dstCapacity,", "                                         CTable_MatchLength, mlCodeTable,", "                                         CTable_OffsetBits, ofCodeTable,", "                                         CTable_LitLength, llCodeTable,", "                                         sequences, nbSeq, longOffsets);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int write_output(void)", " {", "    int fd;", "    struct filter_op *fop;", "    struct filter_header fh;", "    size_t ninst, i;", "    u_char *data;", "    ninst = compile_tree(&fop);", "     if (fop == NULL)", "        return -E_NOTHANDLED;", "    if (ninst == 0)", "       return -E_INVALID;", "     fd = open(EF_GBL_OPTIONS->output_file, O_CREAT | O_RDWR | O_TRUNC | O_BINARY, 0644);", "     ON_ERROR(fd, -1, \"Can't create file %s\", EF_GBL_OPTIONS->output_file);", "    fprintf(stdout, \" Writing output to \\'%s\\' \", EF_GBL_OPTIONS->output_file);", "    fflush(stdout);", "    fh.magic = htons(EC_FILTER_MAGIC);", "    strncpy(fh.version, EC_VERSION, sizeof(fh.version));", "    fh.data = sizeof(fh);", "    data = create_data_segment(&fh, fop, ninst);", "    write(fd, &fh, sizeof(struct filter_header));", "    write(fd, data, fh.code - fh.data);", "    for (i = 0; i <= ninst; i++) {", "       print_progress_bar(&fop[i]);", "       write(fd, &fop[i], sizeof(struct filter_op));", "    }", "    close(fd);", "    fprintf(stdout, \" done.\\n\\n\");", "    fprintf(stdout, \" -> Script encoded into %d instructions.\\n\\n\", (int)(i - 1));", "    return E_SUCCESS;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int ivr_read_header(AVFormatContext *s)", " {", "     unsigned tag, type, len, tlen, value;", "     int i, j, n, count, nb_streams = 0, ret;", "     uint8_t key[256], val[256];", "     AVIOContext *pb = s->pb;", "     AVStream *st;", "     int64_t pos, offset, temp;", "     pos = avio_tell(pb);", "     tag = avio_rl32(pb);", "     if (tag == MKTAG('.','R','1','M')) {", "         if (avio_rb16(pb) != 1)", "             return AVERROR_INVALIDDATA;", "         if (avio_r8(pb) != 1)", "             return AVERROR_INVALIDDATA;", "         len = avio_rb32(pb);", "         avio_skip(pb, len);", "         avio_skip(pb, 5);", "         temp = avio_rb64(pb);", "         while (!avio_feof(pb) && temp) {", "             offset = temp;", "             temp = avio_rb64(pb);", "         }", "         avio_skip(pb, offset - avio_tell(pb));", "         if (avio_r8(pb) != 1)", "             return AVERROR_INVALIDDATA;", "         len = avio_rb32(pb);", "         avio_skip(pb, len);", "         if (avio_r8(pb) != 2)", "             return AVERROR_INVALIDDATA;", "         avio_skip(pb, 16);", "         pos = avio_tell(pb);", "         tag = avio_rl32(pb);", "     }", "     if (tag != MKTAG('.','R','E','C'))", "         return AVERROR_INVALIDDATA;", "     if (avio_r8(pb) != 0)", "         return AVERROR_INVALIDDATA;", "     count = avio_rb32(pb);", "     for (i = 0; i < count; i++) {", "         if (avio_feof(pb))", "             return AVERROR_INVALIDDATA;", "         type = avio_r8(pb);", "         tlen = avio_rb32(pb);", "         avio_get_str(pb, tlen, key, sizeof(key));", "         len = avio_rb32(pb);", "         if (type == 5) {", "             avio_get_str(pb, len, val, sizeof(val));", "              av_log(s, AV_LOG_DEBUG, \"%s = '%s'\\n\", key, val);", "          } else if (type == 4) {", "              av_log(s, AV_LOG_DEBUG, \"%s = '0x\", key);", "            for (j = 0; j < len; j++)", "             for (j = 0; j < len; j++) {", "                 if (avio_feof(pb))", "                     return AVERROR_INVALIDDATA;", "                  av_log(s, AV_LOG_DEBUG, \"%X\", avio_r8(pb));", "             }", "              av_log(s, AV_LOG_DEBUG, \"'\\n\");", "          } else if (len == 4 && type == 3 && !strncmp(key, \"StreamCount\", tlen)) {", "              nb_streams = value = avio_rb32(pb);", "         } else if (len == 4 && type == 3) {", "             value = avio_rb32(pb);", "             av_log(s, AV_LOG_DEBUG, \"%s = %d\\n\", key, value);", "         } else {", "             av_log(s, AV_LOG_DEBUG, \"Skipping unsupported key: %s\\n\", key);", "             avio_skip(pb, len);", "         }", "     }", "     for (n = 0; n < nb_streams; n++) {", "         st = avformat_new_stream(s, NULL);", "         if (!st)", "             return AVERROR(ENOMEM);", "         st->priv_data = ff_rm_alloc_rmstream();", "         if (!st->priv_data)", "             return AVERROR(ENOMEM);", "         if (avio_r8(pb) != 1)", "             return AVERROR_INVALIDDATA;", "         count = avio_rb32(pb);", "         for (i = 0; i < count; i++) {", "             if (avio_feof(pb))", "                 return AVERROR_INVALIDDATA;", "             type = avio_r8(pb);", "             tlen  = avio_rb32(pb);", "             avio_get_str(pb, tlen, key, sizeof(key));", "             len  = avio_rb32(pb);", "             if (type == 5) {", "                 avio_get_str(pb, len, val, sizeof(val));", "                 av_log(s, AV_LOG_DEBUG, \"%s = '%s'\\n\", key, val);", "             } else if (type == 4 && !strncmp(key, \"OpaqueData\", tlen)) {", "                 ret = ffio_ensure_seekback(pb, 4);", "                 if (ret < 0)", "                     return ret;", "                 if (avio_rb32(pb) == MKBETAG('M', 'L', 'T', 'I')) {", "                     ret = rm_read_multi(s, pb, st, NULL);", "                 } else {", "                     avio_seek(pb, -4, SEEK_CUR);", "                     ret = ff_rm_read_mdpr_codecdata(s, pb, st, st->priv_data, len, NULL);", "                 }", "                 if (ret < 0)", "                     return ret;", "             } else if (type == 4) {", "                 int j;", "                 av_log(s, AV_LOG_DEBUG, \"%s = '0x\", key);", "                 for (j = 0; j < len; j++)", "                     av_log(s, AV_LOG_DEBUG, \"%X\", avio_r8(pb));", "                 av_log(s, AV_LOG_DEBUG, \"'\\n\");", "             } else if (len == 4 && type == 3 && !strncmp(key, \"Duration\", tlen)) {", "                 st->duration = avio_rb32(pb);", "             } else if (len == 4 && type == 3) {", "                 value = avio_rb32(pb);", "                 av_log(s, AV_LOG_DEBUG, \"%s = %d\\n\", key, value);", "             } else {", "                 av_log(s, AV_LOG_DEBUG, \"Skipping unsupported key: %s\\n\", key);", "                 avio_skip(pb, len);", "             }", "         }", "     }", "     if (avio_r8(pb) != 6)", "         return AVERROR_INVALIDDATA;", "     avio_skip(pb, 12);", "     avio_skip(pb, avio_rb64(pb) + pos - avio_tell(s->pb));", "     if (avio_r8(pb) != 8)", "         return AVERROR_INVALIDDATA;", "     avio_skip(pb, 8);", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" jp2_box_t *jp2_box_get(jas_stream_t *in)", " {", " \tjp2_box_t *box;", " \tjp2_boxinfo_t *boxinfo;", " \tjas_stream_t *tmpstream;", " \tuint_fast32_t len;", " \tuint_fast64_t extlen;", " \tbool dataflag;", " \tbox = 0;", " \ttmpstream = 0;", " \tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {", " \t\tgoto error;", " \t}", " \tbox->ops = &jp2_boxinfo_unk.ops;", " \tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {", " \t\tgoto error;", " \t}", " \tboxinfo = jp2_boxinfolookup(box->type);", "  \tbox->info = boxinfo;", "  \tbox->ops = &boxinfo->ops;", "  \tbox->len = len;", " \tJAS_DBGLOG(10, (", " \t  \"preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n\",", " \t  '\"', boxinfo->name, '\"', box->type, box->len", " \t  ));", "  \tif (box->len == 1) {", "  \t\tif (jp2_getuint64(in, &extlen)) {", "  \t\t\tgoto error;", " \t\t}", " \t\tif (extlen > 0xffffffffUL) {", " \t\t\tjas_eprintf(\"warning: cannot handle large 64-bit box length\\n\");", " \t\t\textlen = 0xffffffffUL;", " \t\t}", " \t\tbox->len = extlen;", " \t\tbox->datalen = extlen - JP2_BOX_HDRLEN(true);", " \t} else {", " \t\tbox->datalen = box->len - JP2_BOX_HDRLEN(false);", " \t}", " \tif (box->len != 0 && box->len < 8) {", " \t\tgoto error;", " \t}", " \tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));", " \tif (dataflag) {", " \t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {", "  \t\t\tgoto error;", "  \t\t}", "  \t\tif (jas_stream_copy(tmpstream, in, box->datalen)) {", " \t\t\tbox->ops = &jp2_boxinfo_unk.ops;", "  \t\t\tjas_eprintf(\"cannot copy box data\\n\");", "  \t\t\tgoto error;", "  \t\t}", " \t\tjas_stream_rewind(tmpstream);", " \t\tif (box->ops->getdata) {", " \t\t\tif ((*box->ops->getdata)(box, tmpstream)) {", " \t\t\t\tjas_eprintf(\"cannot parse box data\\n\");", " \t\t\t\tgoto error;", " \t\t\t}", " \t\t}", " \t\tjas_stream_close(tmpstream);", " \t}", " \tif (jas_getdbglevel() >= 1) {", " \t\tjp2_box_dump(box, stderr);", " \t}", " \treturn box;", " error:", " \tif (box) {", " \t\tjp2_box_destroy(box);", " \t}", " \tif (tmpstream) {", " \t\tjas_stream_close(tmpstream);", " \t}", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void print_value(int output, int num, const char *devname,", " \t\t\tconst char *value, const char *name, size_t valsz)", " {", " \tif (output & OUTPUT_VALUE_ONLY) {", " \t\tfputs(value, stdout);", " \t\tfputc('\\n', stdout);", " \t} else if (output & OUTPUT_UDEV_LIST) {", " \t\tprint_udev_format(name, value);", " \t} else if (output & OUTPUT_EXPORT_LIST) {", " \t\tif (num == 1 && devname)", "  \t\t\tprintf(\"DEVNAME=%s\\n\", devname);", "  \t\tfputs(name, stdout);", "  \t\tfputs(\"=\", stdout);", "\t\tsafe_print(value, valsz, NULL);", " \t\tsafe_print(value, valsz, \" \\\\\\\"'$`<>\");", "  \t\tfputs(\"\\n\", stdout);", "  \t} else {", " \t\tif (num == 1 && devname)", " \t\t\tprintf(\"%s:\", devname);", "  \t\tfputs(\" \", stdout);", "  \t\tfputs(name, stdout);", "  \t\tfputs(\"=\\\"\", stdout);", "\t\tsafe_print(value, valsz, \"\\\"\");", " \t\tsafe_print(value, valsz, \"\\\"\\\\\");", "  \t\tfputs(\"\\\"\", stdout);", "  \t}", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0]}
{"tokens": [" int _yr_scan_match_callback(", "     uint8_t* match_data,", "     int32_t match_length,", "     int flags,", "     void* args)", " {", "   CALLBACK_ARGS* callback_args = (CALLBACK_ARGS*) args;", "   YR_STRING* string = callback_args->string;", "   YR_MATCH* new_match;", "   int result = ERROR_SUCCESS;", "   int tidx = callback_args->context->tidx;", "   size_t match_offset = match_data - callback_args->data;", "    match_length += callback_args->forward_matches;", "   assert(match_offset + match_length <= callback_args->data_size);", "    if (callback_args->full_word)", "    {", "      if (flags & RE_FLAGS_WIDE)", "     {", "       if (match_offset >= 2 &&", "           *(match_data - 1) == 0 &&", "           isalnum(*(match_data - 2)))", "         return ERROR_SUCCESS;", "       if (match_offset + match_length + 1 < callback_args->data_size &&", "           *(match_data + match_length + 1) == 0 &&", "           isalnum(*(match_data + match_length)))", "         return ERROR_SUCCESS;", "     }", "     else", "     {", "       if (match_offset >= 1 &&", "           isalnum(*(match_data - 1)))", "         return ERROR_SUCCESS;", "       if (match_offset + match_length < callback_args->data_size &&", "           isalnum(*(match_data + match_length)))", "         return ERROR_SUCCESS;", "     }", "   }", "   if (STRING_IS_CHAIN_PART(string))", "   {", "     result = _yr_scan_verify_chained_string_match(", "         string,", "         callback_args->context,", "         match_data,", "         callback_args->data_base,", "         match_offset,", "         match_length);", "   }", "   else", "   {", "     if (string->matches[tidx].count == 0)", "     {", "       FAIL_ON_ERROR(yr_arena_write_data(", "           callback_args->context->matching_strings_arena,", "           &string,", "           sizeof(string),", "           NULL));", "     }", "     FAIL_ON_ERROR(yr_arena_allocate_memory(", "         callback_args->context->matches_arena,", "         sizeof(YR_MATCH),", "         (void**) &new_match));", "     new_match->data_length = yr_min(match_length, MAX_MATCH_DATA);", "     FAIL_ON_ERROR(yr_arena_write_data(", "         callback_args->context->matches_arena,", "         match_data,", "         new_match->data_length,", "         (void**) &new_match->data));", "     if (result == ERROR_SUCCESS)", "     {", "       new_match->base = callback_args->data_base;", "       new_match->offset = match_offset;", "       new_match->match_length = match_length;", "       new_match->prev = NULL;", "       new_match->next = NULL;", "       FAIL_ON_ERROR(_yr_scan_add_match_to_list(", "           new_match,", "           &string->matches[tidx],", "           STRING_IS_GREEDY_REGEXP(string)));", "     }", "   }", "   return result;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" rdpdr_process(STREAM s)", " {", " \tuint32 handle;", "  \tuint16 vmin;", "  \tuint16 component;", "  \tuint16 pakid;", " \tstruct stream packet = *s;", "  \tlogger(Protocol, Debug, \"rdpdr_process()\");", " \tin_uint16(s, component);", " \tin_uint16(s, pakid);", " \tif (component == RDPDR_CTYP_CORE)", " \t{", " \t\tswitch (pakid)", " \t\t{", " \t\t\tcase PAKID_CORE_DEVICE_IOREQUEST:", " \t\t\t\trdpdr_process_irp(s);", " \t\t\t\tbreak;", " \t\t\tcase PAKID_CORE_SERVER_ANNOUNCE:", "  \t\t\t\tin_uint8s(s, 2);\t ", "  \t\t\t\tin_uint16_le(s, vmin);\t ", "  \t\t\t\tin_uint32_le(s, g_client_id);\t ", " \t\t\t\tif (!s_check(s))", " \t\t\t\t{", " \t\t\t\t\trdp_protocol_error(\"rdpdr_process(), consume of g_client_id from stream did overrun\", &packet);", " \t\t\t\t}", "  \t\t\t\tif (vmin < 0x000c)", " \t\t\t\t\tg_client_id = 0x815ed39d;\t ", " \t\t\t\tg_epoch++;", " #if WITH_SCARD", " \t\t\t\tscard_release_all_contexts();", " #endif", " \t\t\t\trdpdr_send_client_announce_reply();", " \t\t\t\trdpdr_send_client_name_request();", " \t\t\t\tbreak;", " \t\t\tcase PAKID_CORE_CLIENTID_CONFIRM:", " \t\t\t\trdpdr_send_client_device_list_announce();", " \t\t\t\tbreak;", " \t\t\tcase PAKID_CORE_DEVICE_REPLY:", " \t\t\t\tin_uint32(s, handle);", " \t\t\t\tlogger(Protocol, Debug,", " \t\t\t\t       \"rdpdr_process(), server connected to resource %d\", handle);", " \t\t\t\tbreak;", " \t\t\tcase PAKID_CORE_SERVER_CAPABILITY:", " \t\t\t\trdpdr_send_client_capability_response();", " \t\t\t\tbreak;", " \t\t\tdefault:", " \t\t\t\tlogger(Protocol, Debug,", " \t\t\t\t       \"rdpdr_process(), pakid 0x%x of component 0x%x\", pakid,", " \t\t\t\t       component);", " \t\t\t\tbreak;", " \t\t}", " \t}", " \telse if (component == RDPDR_CTYP_PRN)", " \t{", " \t\tif (pakid == PAKID_PRN_CACHE_DATA)", " \t\t\tprintercache_process(s);", " \t}", " \telse", " \t\tlogger(Protocol, Warning, \"rdpdr_process(), unhandled component 0x%x\", component);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int jas_matrix_resize(jas_matrix_t *matrix, int numrows, int numcols)", " int jas_matrix_resize(jas_matrix_t *matrix, jas_matind_t numrows,", "   jas_matind_t numcols)", "  {", "\tint size;", "\tint i;", " \tjas_matind_t size;", " \tjas_matind_t i;", "  \tsize = numrows * numcols;", "  \tif (size > matrix->datasize_ || numrows > matrix->maxrows_) {", " \t\treturn -1;", " \t}", " \tmatrix->numrows_ = numrows;", " \tmatrix->numcols_ = numcols;", " \tfor (i = 0; i < numrows; ++i) {", " \t\tmatrix->rows_[i] = &matrix->data_[numcols * i];", " \t}", " \treturn 0;", " }"], "ner_tags": [0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" fep_client_open (const char *address)", " {", "   FepClient *client;", "   struct sockaddr_un sun;", "   ssize_t sun_len;", "   int retval;", "   if (!address)", "     address = getenv (\"LIBFEP_CONTROL_SOCK\");", "   if (!address)", "     return NULL;", "   if (strlen (address) + 1 >= sizeof(sun.sun_path))", "     {", "       fep_log (FEP_LOG_LEVEL_WARNING,", " \t       \"unix domain socket path too long: %d + 1 >= %d\",", " \t       strlen (address),", " \t       sizeof (sun.sun_path));", "       free (address);", "       return NULL;", "     }", "   client = xzalloc (sizeof(FepClient));", "   client->filter_running = false;", "   client->messages = NULL;", "    memset (&sun, 0, sizeof(struct sockaddr_un));", "    sun.sun_family = AF_UNIX;", "#ifdef __linux__", "  sun.sun_path[0] = '\\0';", "  memcpy (sun.sun_path + 1, address, strlen (address));", "  sun_len = offsetof (struct sockaddr_un, sun_path) + strlen (address) + 1;", "#else", "    memcpy (sun.sun_path, address, strlen (address));", "    sun_len = sizeof (struct sockaddr_un);", "#endif", "    client->control = socket (AF_UNIX, SOCK_STREAM, 0);", "    if (client->control < 0)", "     {", "       free (client);", "       return NULL;", "     }", "   retval = connect (client->control,", " \t\t    (const struct sockaddr *) &sun,", " \t\t    sun_len);", "   if (retval < 0)", "     {", "       close (client->control);", "       free (client);", "       return NULL;", "     }", "   return client;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  void jslGetTokenString(char *str, size_t len) {", "    if (lex->tk == LEX_ID) {", "    strncpy(str, \"ID:\", len);", "    strncat(str, jslGetTokenValueAsString(), len);", "     espruino_snprintf(str, len, \"ID:%s\", jslGetTokenValueAsString());", "    } else if (lex->tk == LEX_STR) {", "    strncpy(str, \"String:'\", len);", "    strncat(str, jslGetTokenValueAsString(), len);", "    strncat(str, \"'\", len);", "     espruino_snprintf(str, len, \"String:'%s'\", jslGetTokenValueAsString());", "    } else", "      jslTokenAsString(lex->tk, str, len);", "  }"], "ner_tags": [0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": ["  char *suhosin_decrypt_single_cookie(char *name, int name_len, char *value, int value_len, char *key, char **where TSRMLS_DC)", "  {", "\tchar buffer[4096];", "    char buffer2[4096];", "      int o_name_len = name_len;", "\tchar *buf = buffer, *buf2 = buffer2, *d, *d_url;", " \tchar *buf, *buf2, *d, *d_url;", "  \tint l;", "\tif (name_len > sizeof(buffer)-2) {", "\t\tbuf = estrndup(name, name_len);", "\t} else {", "\t\tmemcpy(buf, name, name_len);", "\t\tbuf[name_len] = 0;", "\t}", " \tbuf = estrndup(name, name_len);", "  \tname_len = php_url_decode(buf, name_len);", "    normalize_varname(buf);", "    name_len = strlen(buf);", " \tnormalize_varname(buf);", " \tname_len = strlen(buf);", "  \tif (SUHOSIN_G(cookie_plainlist)) {", "  \t\tif (zend_hash_exists(SUHOSIN_G(cookie_plainlist), buf, name_len+1)) {", "  decrypt_return_plain:", "\t\t\tif (buf != buffer) {", "\t\t\t\tefree(buf);", "\t\t\t}", " \t\t\tefree(buf);", "              memcpy(*where, name, o_name_len);", "              *where += o_name_len;", "              **where = '='; *where +=1;", " \t        memcpy(*where, value, value_len);", " \t        *where += value_len;", " \t\t\treturn *where;", " \t\t}", " \t} else if (SUHOSIN_G(cookie_cryptlist)) {", " \t\tif (!zend_hash_exists(SUHOSIN_G(cookie_cryptlist), buf, name_len+1)) {", " \t\t\tgoto decrypt_return_plain;", " \t\t}", "  \t}", "\tif (strlen(value) <= sizeof(buffer2)-2) {", "\t\tmemcpy(buf2, value, value_len);", "\t\tbuf2[value_len] = 0;", "\t} else {", "\t\tbuf2 = estrndup(value, value_len);", "\t}", " \tbuf2 = estrndup(value, value_len);", "  \tvalue_len = php_url_decode(buf2, value_len);", " \td = suhosin_decrypt_string(buf2, value_len, buf, name_len, key, &l, SUHOSIN_G(cookie_checkraddr) TSRMLS_CC);", "     if (d == NULL) {", "         goto skip_cookie;", "     }", " \td_url = php_url_encode(d, l, &l);", " \tefree(d);", "     memcpy(*where, name, o_name_len);", "     *where += o_name_len;", "     **where = '=';*where += 1;", " \tmemcpy(*where, d_url, l);", "  \t*where += l;", "  \tefree(d_url);", "  skip_cookie:", "\tif (buf != buffer) {", "\t\tefree(buf);", "\t}", "\tif (buf2 != buffer2) {", "\t\tefree(buf2);", "\t}", " \tefree(buf);", " \tefree(buf2);", "  \treturn *where;", "  }"], "ner_tags": [0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0]}
{"tokens": [" NO_INLINE JsVar *jspeArrowFunction(JsVar *funcVar, JsVar *a) {", "   assert(!a || jsvIsName(a));", "   JSP_ASSERT_MATCH(LEX_ARROW_FUNCTION);", "   funcVar = jspeAddNamedFunctionParameter(funcVar, a);", "   bool expressionOnly = lex->tk!='{';", "   jspeFunctionDefinitionInternal(funcVar, expressionOnly);", "   if (execInfo.thisVar) {", "     jsvObjectSetChild(funcVar, JSPARSE_FUNCTION_THIS_NAME, execInfo.thisVar);", "   }", "   return funcVar;", " }", " NO_INLINE JsVar *jspeExpressionOrArrowFunction() {", "   JsVar *a = 0;", "   JsVar *funcVar = 0;", "   bool allNames = true;", "   while (lex->tk!=')' && !JSP_SHOULDNT_PARSE) {", "     if (allNames && a) {", "       funcVar = jspeAddNamedFunctionParameter(funcVar, a);", "     }", "     jsvUnLock(a);", "     a = jspeAssignmentExpression();", "     if (!(jsvIsName(a) && jsvIsString(a))) allNames = false;", "     if (lex->tk!=')') JSP_MATCH_WITH_CLEANUP_AND_RETURN(',', jsvUnLock2(a,funcVar), 0);", "   }", "   JSP_MATCH_WITH_CLEANUP_AND_RETURN(')', jsvUnLock2(a,funcVar), 0);", "   if (allNames && lex->tk==LEX_ARROW_FUNCTION) {", "     funcVar = jspeArrowFunction(funcVar, a);", "     jsvUnLock(a);", "     return funcVar;", "   } else {", "     jsvUnLock(funcVar);", "     return a;", "   }", " }", " NO_INLINE JsVar *jspeClassDefinition(bool parseNamedClass) {", "   JsVar *classFunction = 0;", "   JsVar *classPrototype = 0;", "   JsVar *classInternalName = 0;", "   bool actuallyCreateClass = JSP_SHOULD_EXECUTE;", "   if (actuallyCreateClass)", "     classFunction = jsvNewWithFlags(JSV_FUNCTION);", "   if (parseNamedClass && lex->tk==LEX_ID) {", "     if (classFunction)", "       classInternalName = jslGetTokenValueAsVar(lex);", "     JSP_ASSERT_MATCH(LEX_ID);", "   }", "   if (classFunction) {", "     JsVar *prototypeName = jsvFindChildFromString(classFunction, JSPARSE_PROTOTYPE_VAR, true);", "     jspEnsureIsPrototype(classFunction, prototypeName);  ", "     classPrototype = jsvSkipName(prototypeName);", "     jsvUnLock(prototypeName);", "   }", "   if (lex->tk==LEX_R_EXTENDS) {", "     JSP_ASSERT_MATCH(LEX_R_EXTENDS);", "     JsVar *extendsFrom = actuallyCreateClass ? jsvSkipNameAndUnLock(jspGetNamedVariable(jslGetTokenValueAsString(lex))) : 0;", "     JSP_MATCH_WITH_CLEANUP_AND_RETURN(LEX_ID,jsvUnLock4(extendsFrom,classFunction,classInternalName,classPrototype),0);", "     if (classPrototype) {", "       if (jsvIsFunction(extendsFrom)) {", "         jsvObjectSetChild(classPrototype, JSPARSE_INHERITS_VAR, extendsFrom);", "         jsvObjectSetChildAndUnLock(classFunction, JSPARSE_FUNCTION_CODE_NAME, jsvNewFromString(\"if(this.__proto__.__proto__)this.__proto__.__proto__.apply(this,arguments)\"));", "       } else", "         jsExceptionHere(JSET_SYNTAXERROR, \"'extends' argument should be a function, got %t\", extendsFrom);", "     }", "     jsvUnLock(extendsFrom);", "   }", "   JSP_MATCH_WITH_CLEANUP_AND_RETURN('{',jsvUnLock3(classFunction,classInternalName,classPrototype),0);", "   while ((lex->tk==LEX_ID || lex->tk==LEX_R_STATIC) && !jspIsInterrupted()) {", "     bool isStatic = lex->tk==LEX_R_STATIC;", "     if (isStatic) JSP_ASSERT_MATCH(LEX_R_STATIC);", "     JsVar *funcName = jslGetTokenValueAsVar(lex);", "     JSP_MATCH_WITH_CLEANUP_AND_RETURN(LEX_ID,jsvUnLock3(classFunction,classInternalName,classPrototype),0);", "     JsVar *method = jspeFunctionDefinition(false);", "     if (classFunction && classPrototype) {", "       if (jsvIsStringEqual(funcName, \"get\") || jsvIsStringEqual(funcName, \"set\")) {", "         jsExceptionHere(JSET_SYNTAXERROR, \"'get' and 'set' and not supported in Espruino\");", "       } else if (jsvIsStringEqual(funcName, \"constructor\")) {", "         jswrap_function_replaceWith(classFunction, method);", "       } else {", "         funcName = jsvMakeIntoVariableName(funcName, 0);", "         jsvSetValueOfName(funcName, method);", "         jsvAddName(isStatic ? classFunction : classPrototype, funcName);", "       }", "     }", "     jsvUnLock2(method,funcName);", "   }", "   jsvUnLock(classPrototype);", "   if (classInternalName)", "     jsvObjectSetChildAndUnLock(classFunction, JSPARSE_FUNCTION_NAME_NAME, classInternalName);", "   JSP_MATCH_WITH_CLEANUP_AND_RETURN('}',jsvUnLock(classFunction),0);", "   return classFunction;", " }", " #endif", " NO_INLINE JsVar *jspeFactor() {", "   if (lex->tk==LEX_ID) {", "     JsVar *a = jspGetNamedVariable(jslGetTokenValueAsString(lex));", "     JSP_ASSERT_MATCH(LEX_ID);", " #ifndef SAVE_ON_FLASH", "     if (lex->tk==LEX_TEMPLATE_LITERAL)", "       jsExceptionHere(JSET_SYNTAXERROR, \"Tagged template literals not supported\");", "     else if (lex->tk==LEX_ARROW_FUNCTION && jsvIsName(a)) {", "       JsVar *funcVar = jspeArrowFunction(0,a);", "       jsvUnLock(a);", "       a=funcVar;", "     }", " #endif", "     return a;", "   } else if (lex->tk==LEX_INT) {", "     JsVar *v = 0;", "     if (JSP_SHOULD_EXECUTE) {", "       v = jsvNewFromLongInteger(stringToInt(jslGetTokenValueAsString(lex)));", "     }", "     JSP_ASSERT_MATCH(LEX_INT);", "     return v;", "   } else if (lex->tk==LEX_FLOAT) {", "     JsVar *v = 0;", "     if (JSP_SHOULD_EXECUTE) {", "       v = jsvNewFromFloat(stringToFloat(jslGetTokenValueAsString(lex)));", "     }", "     JSP_ASSERT_MATCH(LEX_FLOAT);", "     return v;", "   } else if (lex->tk=='(') {", "     JSP_ASSERT_MATCH('(');", "     if (!jspCheckStackPosition()) return 0;", " #ifdef SAVE_ON_FLASH", "     JsVar *a = jspeExpression();", "     if (!JSP_SHOULDNT_PARSE) JSP_MATCH_WITH_RETURN(')',a);", "     return a;", " #else", "     return jspeExpressionOrArrowFunction();", " #endif", "   } else if (lex->tk==LEX_R_TRUE) {", "     JSP_ASSERT_MATCH(LEX_R_TRUE);", "     return JSP_SHOULD_EXECUTE ? jsvNewFromBool(true) : 0;", "   } else if (lex->tk==LEX_R_FALSE) {", "     JSP_ASSERT_MATCH(LEX_R_FALSE);", "     return JSP_SHOULD_EXECUTE ? jsvNewFromBool(false) : 0;", "   } else if (lex->tk==LEX_R_NULL) {", "     JSP_ASSERT_MATCH(LEX_R_NULL);", "     return JSP_SHOULD_EXECUTE ? jsvNewWithFlags(JSV_NULL) : 0;", "   } else if (lex->tk==LEX_R_UNDEFINED) {", "     JSP_ASSERT_MATCH(LEX_R_UNDEFINED);", "     return 0;", "   } else if (lex->tk==LEX_STR) {", "     JsVar *a = 0;", "     if (JSP_SHOULD_EXECUTE)", "       a = jslGetTokenValueAsVar(lex);", "     JSP_ASSERT_MATCH(LEX_STR);", "     return a;", " #ifndef SAVE_ON_FLASH", "   } else if (lex->tk==LEX_TEMPLATE_LITERAL) {", "     return jspeTemplateLiteral();", " #endif", "   } else if (lex->tk==LEX_REGEX) {", "     JsVar *a = 0;", " #ifdef SAVE_ON_FLASH", "     jsExceptionHere(JSET_SYNTAXERROR, \"RegEx are not supported in this version of Espruino\\n\");", " #else", "     JsVar *regex = jslGetTokenValueAsVar(lex);", "     size_t regexEnd = 0, regexLen = 0;", "     JsvStringIterator it;", "     jsvStringIteratorNew(&it, regex, 0);", "     while (jsvStringIteratorHasChar(&it)) {", "       regexLen++;", "       if (jsvStringIteratorGetChar(&it)=='/')", "         regexEnd = regexLen;", "       jsvStringIteratorNext(&it);", "     }", "     jsvStringIteratorFree(&it);", "     JsVar *flags = 0;", "     if (regexEnd < regexLen)", "       flags = jsvNewFromStringVar(regex, regexEnd, JSVAPPENDSTRINGVAR_MAXLENGTH);", "     JsVar *regexSource = jsvNewFromStringVar(regex, 1, regexEnd-2);", "     a = jswrap_regexp_constructor(regexSource, flags);", "     jsvUnLock3(regex, flags, regexSource);", " #endif", "     JSP_ASSERT_MATCH(LEX_REGEX);", "     return a;", "   } else if (lex->tk=='{') {", "     if (!jspCheckStackPosition()) return 0;", "     return jspeFactorObject();", "   } else if (lex->tk=='[') {", "     if (!jspCheckStackPosition()) return 0;", "     return jspeFactorArray();", "   } else if (lex->tk==LEX_R_FUNCTION) {", "     if (!jspCheckStackPosition()) return 0;", "     JSP_ASSERT_MATCH(LEX_R_FUNCTION);", "     return jspeFunctionDefinition(true);", " #ifndef SAVE_ON_FLASH", "   } else if (lex->tk==LEX_R_CLASS) {", "     if (!jspCheckStackPosition()) return 0;", "     JSP_ASSERT_MATCH(LEX_R_CLASS);", "     return jspeClassDefinition(true);", "   } else if (lex->tk==LEX_R_SUPER) {", "     JSP_ASSERT_MATCH(LEX_R_SUPER);", "     if (jsvIsObject(execInfo.thisVar)) {", "       JsVar *proto1 = jsvObjectGetChild(execInfo.thisVar, JSPARSE_INHERITS_VAR, 0);  ", "       JsVar *proto2 = jsvIsObject(proto1) ? jsvObjectGetChild(proto1, JSPARSE_INHERITS_VAR, 0) : 0;  ", "       jsvUnLock(proto1);", "       if (!proto2) {", "         jsExceptionHere(JSET_SYNTAXERROR, \"Calling 'super' outside of class\");", "         return 0;", "       }", "       if (lex->tk=='(') return proto2;  ", "       JsVar *proto3 = jsvIsFunction(proto2) ? jsvObjectGetChild(proto2, JSPARSE_PROTOTYPE_VAR, 0) : 0;", "       jsvUnLock(proto2);", "       return proto3;", "     } else if (jsvIsFunction(execInfo.thisVar)) {", "       JsVar *proto1 = jsvObjectGetChild(execInfo.thisVar, JSPARSE_PROTOTYPE_VAR, 0);", "       JsVar *proto2 = jsvIsObject(proto1) ? jsvObjectGetChild(proto1, JSPARSE_INHERITS_VAR, 0) : 0;", "       jsvUnLock(proto1);", "       if (!proto2) {", "         jsExceptionHere(JSET_SYNTAXERROR, \"Calling 'super' outside of class\");", "         return 0;", "       }", "       return proto2;", "     }", "     jsExceptionHere(JSET_SYNTAXERROR, \"Calling 'super' outside of class\");", "     return 0;", " #endif", "   } else if (lex->tk==LEX_R_THIS) {", "     JSP_ASSERT_MATCH(LEX_R_THIS);", "     return jsvLockAgain( execInfo.thisVar ? execInfo.thisVar : execInfo.root );", "   } else if (lex->tk==LEX_R_DELETE) {", "     if (!jspCheckStackPosition()) return 0;", "     return jspeFactorDelete();", "   } else if (lex->tk==LEX_R_TYPEOF) {", "      if (!jspCheckStackPosition()) return 0;", "      return jspeFactorTypeOf();", "    } else if (lex->tk==LEX_R_VOID) {", "     if (!jspCheckStackPosition()) return 0;", "      JSP_ASSERT_MATCH(LEX_R_VOID);", "      jsvUnLock(jspeUnaryExpression());", "      return 0;", "   }", "   JSP_MATCH(LEX_EOF);", "   jsExceptionHere(JSET_SYNTAXERROR, \"Unexpected end of Input\\n\");", "   return 0;", " }", " NO_INLINE JsVar *__jspePostfixExpression(JsVar *a) {", "   while (lex->tk==LEX_PLUSPLUS || lex->tk==LEX_MINUSMINUS) {", "     int op = lex->tk;", "     JSP_ASSERT_MATCH(op);", "     if (JSP_SHOULD_EXECUTE) {", "       JsVar *one = jsvNewFromInteger(1);", "       JsVar *oldValue = jsvAsNumberAndUnLock(jsvSkipName(a));  ", "       JsVar *res = jsvMathsOpSkipNames(oldValue, one, op==LEX_PLUSPLUS ? '+' : '-');", "       jsvUnLock(one);", "       jspReplaceWith(a, res);", "       jsvUnLock(res);", "       jsvUnLock(a);", "       a = oldValue;", "     }", "   }", "   return a;", " }", " NO_INLINE JsVar *jspePostfixExpression() {", "   JsVar *a;", "   if (lex->tk==LEX_PLUSPLUS || lex->tk==LEX_MINUSMINUS) {", "     int op = lex->tk;", "     JSP_ASSERT_MATCH(op);", "     a = jspePostfixExpression();", "     if (JSP_SHOULD_EXECUTE) {", "       JsVar *one = jsvNewFromInteger(1);", "       JsVar *res = jsvMathsOpSkipNames(a, one, op==LEX_PLUSPLUS ? '+' : '-');", "       jsvUnLock(one);", "       jspReplaceWith(a, res);", "       jsvUnLock(res);", "     }", "   } else", "     a = jspeFactorFunctionCall();", "   return __jspePostfixExpression(a);", " }", " NO_INLINE JsVar *jspeUnaryExpression() {", "   if (lex->tk=='!' || lex->tk=='~' || lex->tk=='-' || lex->tk=='+') {", "     short tk = lex->tk;", "     JSP_ASSERT_MATCH(tk);", "     if (!JSP_SHOULD_EXECUTE) {", "       return jspeUnaryExpression();", "     }", "     if (tk=='!') {  ", "       return jsvNewFromBool(!jsvGetBoolAndUnLock(jsvSkipNameAndUnLock(jspeUnaryExpression())));", "     } else if (tk=='~') {  ", "       return jsvNewFromInteger(~jsvGetIntegerAndUnLock(jsvSkipNameAndUnLock(jspeUnaryExpression())));", "     } else if (tk=='-') {  ", "       return jsvNegateAndUnLock(jspeUnaryExpression());  ", "     }  else if (tk=='+') {  ", "       JsVar *v = jsvSkipNameAndUnLock(jspeUnaryExpression());", "       JsVar *r = jsvAsNumber(v);  ", "       jsvUnLock(v);", "       return r;", "     }", "     assert(0);", "     return 0;", "   } else", "     return jspePostfixExpression();", " }", " unsigned int jspeGetBinaryExpressionPrecedence(int op) {", "   switch (op) {", "   case LEX_OROR: return 1; break;", "   case LEX_ANDAND: return 2; break;", "   case '|' : return 3; break;", "   case '^' : return 4; break;", "   case '&' : return 5; break;", "   case LEX_EQUAL:", "   case LEX_NEQUAL:", "   case LEX_TYPEEQUAL:", "   case LEX_NTYPEEQUAL: return 6;", "   case LEX_LEQUAL:", "   case LEX_GEQUAL:", "   case '<':", "   case '>':", "   case LEX_R_INSTANCEOF: return 7;", "   case LEX_R_IN: return (execInfo.execute&EXEC_FOR_INIT)?0:7;", "   case LEX_LSHIFT:", "   case LEX_RSHIFT:", "   case LEX_RSHIFTUNSIGNED: return 8;", "   case '+':", "   case '-': return 9;", "   case '*':", "   case '/':", "   case '%': return 10;", "   default: return 0;", "   }", " }", " NO_INLINE JsVar *__jspeBinaryExpression(JsVar *a, unsigned int lastPrecedence) {", "   unsigned int precedence = jspeGetBinaryExpressionPrecedence(lex->tk);", "   while (precedence && precedence>lastPrecedence) {", "     int op = lex->tk;", "     JSP_ASSERT_MATCH(op);", "     if (op==LEX_ANDAND || op==LEX_OROR) {", "       bool aValue = jsvGetBoolAndUnLock(jsvSkipName(a));", "       if ((!aValue && op==LEX_ANDAND) ||", "           (aValue && op==LEX_OROR)) {", "         JSP_SAVE_EXECUTE();", "         jspSetNoExecute();", "         jsvUnLock(__jspeBinaryExpression(jspeUnaryExpression(),precedence));", "         JSP_RESTORE_EXECUTE();", "       } else {", "         jsvUnLock(a);", "         a = __jspeBinaryExpression(jspeUnaryExpression(),precedence);", "       }", "     } else {  ", "       JsVar *b = __jspeBinaryExpression(jspeUnaryExpression(),precedence);", "       if (JSP_SHOULD_EXECUTE) {", "         if (op==LEX_R_IN) {", "           JsVar *av = jsvSkipName(a);  ", "           JsVar *bv = jsvSkipName(b);  ", "           if (jsvIsArray(bv) || jsvIsObject(bv)) {  ", "             av = jsvAsArrayIndexAndUnLock(av);", "             JsVar *varFound = jspGetVarNamedField( bv, av, true);", "             jsvUnLock(a);", "             a = jsvNewFromBool(varFound!=0);", "             jsvUnLock(varFound);", "           } else { ", "             jsExceptionHere(JSET_ERROR, \"Cannot use 'in' operator to search a %t\", bv);", "             jsvUnLock(a);", "             a = 0;", "           }", "           jsvUnLock2(av, bv);", "         } else if (op==LEX_R_INSTANCEOF) {", "           bool inst = false;", "           JsVar *av = jsvSkipName(a);", "           JsVar *bv = jsvSkipName(b);", "           if (!jsvIsFunction(bv)) {", "             jsExceptionHere(JSET_ERROR, \"Expecting a function on RHS in instanceof check, got %t\", bv);", "           } else {", "             if (jsvIsObject(av) || jsvIsFunction(av)) {", "               JsVar *bproto = jspGetNamedField(bv, JSPARSE_PROTOTYPE_VAR, false);", "               JsVar *proto = jsvObjectGetChild(av, JSPARSE_INHERITS_VAR, 0);", "               while (proto) {", "                 if (proto == bproto) inst=true;", "                 JsVar *childProto = jsvObjectGetChild(proto, JSPARSE_INHERITS_VAR, 0);", "                 jsvUnLock(proto);", "                 proto = childProto;", "               }", "               if (jspIsConstructor(bv, \"Object\")) inst = true;", "               jsvUnLock(bproto);", "             }", "             if (!inst) {", "               const char *name = jswGetBasicObjectName(av);", "               if (name) {", "                 inst = jspIsConstructor(bv, name);", "               }", "               if (!inst && (jsvIsArray(av) || jsvIsArrayBuffer(av)) &&", "                   jspIsConstructor(bv, \"Object\"))", "                 inst = true;", "             }", "           }", "           jsvUnLock3(av, bv, a);", "           a = jsvNewFromBool(inst);", "         } else {   ", "           JsVar *res = jsvMathsOpSkipNames(a, b, op);", "           jsvUnLock(a); a = res;", "         }", "       }", "       jsvUnLock(b);", "     }", "     precedence = jspeGetBinaryExpressionPrecedence(lex->tk);", "   }", "   return a;", " }", " JsVar *jspeBinaryExpression() {", "   return __jspeBinaryExpression(jspeUnaryExpression(),0);", " }", " NO_INLINE JsVar *__jspeConditionalExpression(JsVar *lhs) {", "   if (lex->tk=='?') {", "     JSP_ASSERT_MATCH('?');", "     if (!JSP_SHOULD_EXECUTE) {", "       jsvUnLock(jspeAssignmentExpression());", "       JSP_MATCH(':');", "       jsvUnLock(jspeAssignmentExpression());", "     } else {", "       bool first = jsvGetBoolAndUnLock(jsvSkipName(lhs));", "       jsvUnLock(lhs);", "       if (first) {", "         lhs = jspeAssignmentExpression();", "         JSP_MATCH(':');", "         JSP_SAVE_EXECUTE();", "         jspSetNoExecute();", "         jsvUnLock(jspeAssignmentExpression());", "         JSP_RESTORE_EXECUTE();", "       } else {", "         JSP_SAVE_EXECUTE();", "         jspSetNoExecute();", "         jsvUnLock(jspeAssignmentExpression());", "         JSP_RESTORE_EXECUTE();", "         JSP_MATCH(':');", "         lhs = jspeAssignmentExpression();", "       }", "     }", "   }", "   return lhs;", " }", " JsVar *jspeConditionalExpression() {", "   return __jspeConditionalExpression(jspeBinaryExpression());", " }", " NO_INLINE JsVar *__jspeAssignmentExpression(JsVar *lhs) {", "   if (lex->tk=='=' || lex->tk==LEX_PLUSEQUAL || lex->tk==LEX_MINUSEQUAL ||", "       lex->tk==LEX_MULEQUAL || lex->tk==LEX_DIVEQUAL || lex->tk==LEX_MODEQUAL ||", "       lex->tk==LEX_ANDEQUAL || lex->tk==LEX_OREQUAL ||", "       lex->tk==LEX_XOREQUAL || lex->tk==LEX_RSHIFTEQUAL ||", "       lex->tk==LEX_LSHIFTEQUAL || lex->tk==LEX_RSHIFTUNSIGNEDEQUAL) {", "     JsVar *rhs;", "     int op = lex->tk;", "     JSP_ASSERT_MATCH(op);", "     rhs = jspeAssignmentExpression();", "     rhs = jsvSkipNameAndUnLock(rhs);  ", "     if (JSP_SHOULD_EXECUTE && lhs) {", "       if (op=='=') {", "         if (!jsvGetRefs(lhs) && jsvIsName(lhs)) {", "           if (!jsvIsArrayBufferName(lhs) && !jsvIsNewChild(lhs))", "             jsvAddName(execInfo.root, lhs);", "         }", "         jspReplaceWith(lhs, rhs);", "       } else {", "         if (op==LEX_PLUSEQUAL) op='+';", "         else if (op==LEX_MINUSEQUAL) op='-';", "         else if (op==LEX_MULEQUAL) op='*';", "         else if (op==LEX_DIVEQUAL) op='/';", "         else if (op==LEX_MODEQUAL) op='%';", "         else if (op==LEX_ANDEQUAL) op='&';", "         else if (op==LEX_OREQUAL) op='|';", "         else if (op==LEX_XOREQUAL) op='^';", "         else if (op==LEX_RSHIFTEQUAL) op=LEX_RSHIFT;", "         else if (op==LEX_LSHIFTEQUAL) op=LEX_LSHIFT;", "         else if (op==LEX_RSHIFTUNSIGNEDEQUAL) op=LEX_RSHIFTUNSIGNED;", "         if (op=='+' && jsvIsName(lhs)) {", "           JsVar *currentValue = jsvSkipName(lhs);", "           if (jsvIsString(currentValue) && !jsvIsFlatString(currentValue) && jsvGetRefs(currentValue)==1 && rhs!=currentValue) {", "             JsVar *str = jsvAsString(rhs, false);", "             jsvAppendStringVarComplete(currentValue, str);", "             jsvUnLock(str);", "             op = 0;", "           }", "           jsvUnLock(currentValue);", "         }", "         if (op) {", "           JsVar *res = jsvMathsOpSkipNames(lhs,rhs,op);", "           jspReplaceWith(lhs, res);", "           jsvUnLock(res);", "         }", "       }", "     }", "     jsvUnLock(rhs);", "   }", "   return lhs;", " }", " JsVar *jspeAssignmentExpression() {", "   return __jspeAssignmentExpression(jspeConditionalExpression());", " }", " NO_INLINE JsVar *jspeExpression() {", "   while (!JSP_SHOULDNT_PARSE) {", "     JsVar *a = jspeAssignmentExpression();", "     if (lex->tk!=',') return a;", "     jsvUnLock(a);", "     JSP_ASSERT_MATCH(',');", "   }", "   return 0;", " }", " NO_INLINE void jspeBlockNoBrackets() {", "   if (JSP_SHOULD_EXECUTE) {", "     while (lex->tk && lex->tk!='}') {", "       jsvUnLock(jspeStatement());", "       if (JSP_HAS_ERROR) {", "         if (lex && !(execInfo.execute&EXEC_ERROR_LINE_REPORTED)) {", "           execInfo.execute = (JsExecFlags)(execInfo.execute | EXEC_ERROR_LINE_REPORTED);", "           JsVar *stackTrace = jsvObjectGetChild(execInfo.hiddenRoot, JSPARSE_STACKTRACE_VAR, JSV_STRING_0);", "           if (stackTrace) {", "             jsvAppendPrintf(stackTrace, \"at \");", "             jspAppendStackTrace(stackTrace);", "             jsvUnLock(stackTrace);", "           }", "         }", "       }", "       if (JSP_SHOULDNT_PARSE)", "         return;", "     }", "   } else {", "     int brackets = 0;", "     while (lex->tk && (brackets || lex->tk != '}')) {", "       if (lex->tk == '{') brackets++;", "       if (lex->tk == '}') brackets--;", "       JSP_ASSERT_MATCH(lex->tk);", "     }", "   }", "   return;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int ff_amf_get_field_value(const uint8_t *data, const uint8_t *data_end,", " static int amf_get_field_value2(GetByteContext *gb,", "                             const uint8_t *name, uint8_t *dst, int dst_size)", "  {", "      int namelen = strlen(name);", "      int len;", "    while (*data != AMF_DATA_TYPE_OBJECT && data < data_end) {", "        len = ff_amf_tag_size(data, data_end);", "        if (len < 0)", "            len = data_end - data;", "        data += len;", "     while (bytestream2_peek_byte(gb) != AMF_DATA_TYPE_OBJECT && bytestream2_get_bytes_left(gb) > 0) {", "         int ret = amf_tag_skip(gb);", "         if (ret < 0)", "             return -1;", "      }", "    if (data_end - data < 3)", "     if (bytestream2_get_bytes_left(gb) < 3)", "          return -1;", "    data++;", "     bytestream2_get_byte(gb);", "      for (;;) {", "        int size = bytestream_get_be16(&data);", "         int size = bytestream2_get_be16(gb);", "          if (!size)", "              break;", "        if (size < 0 || size >= data_end - data)", "         if (size < 0 || size >= bytestream2_get_bytes_left(gb))", "              return -1;", "        data += size;", "        if (size == namelen && !memcmp(data-size, name, namelen)) {", "            switch (*data++) {", "         bytestream2_skip(gb, size);", "         if (size == namelen && !memcmp(gb->buffer-size, name, namelen)) {", "             switch (bytestream2_get_byte(gb)) {", "              case AMF_DATA_TYPE_NUMBER:", "                snprintf(dst, dst_size, \"%g\", av_int2double(AV_RB64(data)));", "                 snprintf(dst, dst_size, \"%g\", av_int2double(bytestream2_get_be64(gb)));", "                  break;", "              case AMF_DATA_TYPE_BOOL:", "                snprintf(dst, dst_size, \"%s\", *data ? \"true\" : \"false\");", "                 snprintf(dst, dst_size, \"%s\", bytestream2_get_byte(gb) ? \"true\" : \"false\");", "                  break;", "              case AMF_DATA_TYPE_STRING:", "                len = bytestream_get_be16(&data);", "                av_strlcpy(dst, data, FFMIN(len+1, dst_size));", "                 len = bytestream2_get_be16(gb);", "                 if (dst_size < 1)", "                     return -1;", "                 if (dst_size < len + 1)", "                     len = dst_size - 1;", "                 bytestream2_get_buffer(gb, dst, len);", "                 dst[len] = 0;", "                  break;", "              default:", "                  return -1;", "              }", "              return 0;", "          }", "        len = ff_amf_tag_size(data, data_end);", "        if (len < 0 || len >= data_end - data)", "         len = amf_tag_skip(gb);", "         if (len < 0 || bytestream2_get_bytes_left(gb) <= 0)", "              return -1;", "        data += len;", "      }", "      return -1;", "  }"], "ner_tags": [0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0]}
{"tokens": [" Bool GPAC_EventProc(void *ptr, GF_Event *evt)", " {", " \tif (!term) return 0;", " \tif (gui_mode==1) {", " \t\tif (evt->type==GF_EVENT_QUIT) {", " \t\t\tRun = 0;", " \t\t} else if (evt->type==GF_EVENT_KEYDOWN) {", " \t\t\tswitch (evt->key.key_code) {", " \t\t\tcase GF_KEY_C:", " \t\t\t\tif (evt->key.flags & (GF_KEY_MOD_CTRL|GF_KEY_MOD_ALT)) {", " \t\t\t\t\thide_shell(shell_visible ? 1 : 0);", " \t\t\t\t\tif (shell_visible) gui_mode=2;", " \t\t\t\t}", " \t\t\t\tbreak;", " \t\t\tdefault:", " \t\t\t\tbreak;", " \t\t\t}", " \t\t}", " \t\treturn 0;", " \t}", " \tswitch (evt->type) {", " \tcase GF_EVENT_DURATION:", " \t\tDuration = (u64) ( 1000 * (s64) evt->duration.duration);", " \t\tCanSeek = evt->duration.can_seek;", " \t\tbreak;", " \tcase GF_EVENT_MESSAGE:", " \t{", " \t\tconst char *servName;", " \t\tif (!evt->message.service || !strcmp(evt->message.service, the_url)) {", " \t\t\tservName = \"\";", " \t\t} else if (!strnicmp(evt->message.service, \"data:\", 5)) {", " \t\t\tservName = \"(embedded data)\";", " \t\t} else {", " \t\t\tservName = evt->message.service;", " \t\t}", " \t\tif (!evt->message.message) return 0;", " \t\tif (evt->message.error) {", " \t\t\tif (!is_connected) last_error = evt->message.error;", " \t\t\tif (evt->message.error==GF_SCRIPT_INFO) {", " \t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONSOLE, (\"%s\\n\", evt->message.message));", " \t\t\t} else {", " \t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONSOLE, (\"%s %s: %s\\n\", servName, evt->message.message, gf_error_to_string(evt->message.error)));", " \t\t\t}", " \t\t} else if (!be_quiet)", " \t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONSOLE, (\"%s %s\\n\", servName, evt->message.message));", " \t}", " \tbreak;", " \tcase GF_EVENT_PROGRESS:", " \t{", " \t\tchar *szTitle = \"\";", " \t\tif (evt->progress.progress_type==0) {", " \t\t\tszTitle = \"Buffer \";", " \t\t\tif (bench_mode && (bench_mode!=3) ) {", " \t\t\t\tif (evt->progress.done >= evt->progress.total) bench_buffer = 0;", " \t\t\t\telse bench_buffer = 1 + 100*evt->progress.done / evt->progress.total;", " \t\t\t\tbreak;", " \t\t\t}", " \t\t}", " \t\telse if (evt->progress.progress_type==1) {", " \t\t\tif (bench_mode) break;", " \t\t\tszTitle = \"Download \";", " \t\t}", " \t\telse if (evt->progress.progress_type==2) szTitle = \"Import \";", " \t\tgf_set_progress(szTitle, evt->progress.done, evt->progress.total);", " \t}", " \tbreak;", " \tcase GF_EVENT_DBLCLICK:", " \t\tgf_term_set_option(term, GF_OPT_FULLSCREEN, !gf_term_get_option(term, GF_OPT_FULLSCREEN));", " \t\treturn 0;", " \tcase GF_EVENT_MOUSEDOWN:", " \t\tif (evt->mouse.button==GF_MOUSE_RIGHT) {", " \t\t\tright_down = 1;", " \t\t\tlast_x = evt->mouse.x;", " \t\t\tlast_y = evt->mouse.y;", " \t\t}", " \t\treturn 0;", " \tcase GF_EVENT_MOUSEUP:", " \t\tif (evt->mouse.button==GF_MOUSE_RIGHT) {", " \t\t\tright_down = 0;", " \t\t\tlast_x = evt->mouse.x;", " \t\t\tlast_y = evt->mouse.y;", " \t\t}", " \t\treturn 0;", " \tcase GF_EVENT_MOUSEMOVE:", " \t\tif (right_down && (user.init_flags & GF_TERM_WINDOWLESS) ) {", " \t\t\tGF_Event move;", " \t\t\tmove.move.x = evt->mouse.x - last_x;", " \t\t\tmove.move.y = last_y-evt->mouse.y;", " \t\t\tmove.type = GF_EVENT_MOVE;", " \t\t\tmove.move.relative = 1;", " \t\t\tgf_term_user_event(term, &move);", " \t\t}", " \t\treturn 0;", " \tcase GF_EVENT_KEYUP:", " \t\tswitch (evt->key.key_code) {", " \t\tcase GF_KEY_SPACE:", " \t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) switch_bench(!bench_mode);", " \t\t\tbreak;", " \t\t}", " \t\tbreak;", " \tcase GF_EVENT_KEYDOWN:", " \t\tgf_term_process_shortcut(term, evt);", " \t\tswitch (evt->key.key_code) {", " \t\tcase GF_KEY_SPACE:", " \t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) {", " \t\t\t\tif (!bench_mode) switch_bench(!bench_mode);", " \t\t\t}", " \t\t\tbreak;", " \t\tcase GF_KEY_PAGEDOWN:", " \t\tcase GF_KEY_MEDIANEXTTRACK:", " \t\t\trequest_next_playlist_item = 1;", " \t\t\tbreak;", " \t\tcase GF_KEY_MEDIAPREVIOUSTRACK:", " \t\t\tbreak;", " \t\tcase GF_KEY_ESCAPE:", " \t\t\tgf_term_set_option(term, GF_OPT_FULLSCREEN, !gf_term_get_option(term, GF_OPT_FULLSCREEN));", " \t\t\tbreak;", " \t\tcase GF_KEY_C:", " \t\t\tif (evt->key.flags & (GF_KEY_MOD_CTRL|GF_KEY_MOD_ALT)) {", " \t\t\t\thide_shell(shell_visible ? 1 : 0);", " \t\t\t\tif (!shell_visible) gui_mode=1;", " \t\t\t}", " \t\t\tbreak;", " \t\tcase GF_KEY_F:", " \t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) fprintf(stderr, \"Rendering rate: %f FPS\\n\", gf_term_get_framerate(term, 0));", " \t\t\tbreak;", " \t\tcase GF_KEY_T:", " \t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) fprintf(stderr, \"Scene Time: %f \\n\", gf_term_get_time_in_ms(term)/1000.0);", " \t\t\tbreak;", " \t\tcase GF_KEY_D:", " \t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) gf_term_set_option(term, GF_OPT_DRAW_MODE, (gf_term_get_option(term, GF_OPT_DRAW_MODE)==GF_DRAW_MODE_DEFER) ? GF_DRAW_MODE_IMMEDIATE : GF_DRAW_MODE_DEFER );", " \t\t\tbreak;", " \t\tcase GF_KEY_4:", " \t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL)", " \t\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_4_3);", " \t\t\tbreak;", " \t\tcase GF_KEY_5:", " \t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL)", " \t\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_16_9);", " \t\t\tbreak;", " \t\tcase GF_KEY_6:", " \t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL)", " \t\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);", " \t\t\tbreak;", " \t\tcase GF_KEY_7:", " \t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL)", " \t\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_KEEP);", " \t\t\tbreak;", " \t\tcase GF_KEY_O:", " \t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {", " \t\t\t\tif (gf_term_get_option(term, GF_OPT_MAIN_ADDON)) {", " \t\t\t\t\tfprintf(stderr, \"Resuming to main content\\n\");", " \t\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_PLAY_LIVE);", " \t\t\t\t} else {", " \t\t\t\t\tfprintf(stderr, \"Main addon not enabled\\n\");", " \t\t\t\t}", " \t\t\t}", " \t\t\tbreak;", " \t\tcase GF_KEY_P:", " \t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {", " \t\t\t\tu32 pause_state = gf_term_get_option(term, GF_OPT_PLAY_STATE) ;", " \t\t\t\tfprintf(stderr, \"[Status: %s]\\n\", pause_state ? \"Playing\" : \"Paused\");", " \t\t\t\tif ((pause_state == GF_STATE_PAUSED) && (evt->key.flags & GF_KEY_MOD_SHIFT)) {", " \t\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_PLAY_LIVE);", " \t\t\t\t} else {", " \t\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, (pause_state==GF_STATE_PAUSED) ? GF_STATE_PLAYING : GF_STATE_PAUSED);", " \t\t\t\t}", " \t\t\t}", " \t\t\tbreak;", " \t\tcase GF_KEY_S:", " \t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {", " \t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_STEP_PAUSE);", " \t\t\t\tfprintf(stderr, \"Step time: \");", " \t\t\t\tPrintTime(gf_term_get_time_in_ms(term));", " \t\t\t\tfprintf(stderr, \"\\n\");", " \t\t\t}", " \t\t\tbreak;", " \t\tcase GF_KEY_B:", " \t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected)", " \t\t\t\tViewODs(term, 1);", " \t\t\tbreak;", " \t\tcase GF_KEY_M:", " \t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected)", " \t\t\t\tViewODs(term, 0);", " \t\t\tbreak;", " \t\tcase GF_KEY_H:", " \t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {", " \t\t\t\tgf_term_switch_quality(term, 1);", " \t\t\t}", " \t\t\tbreak;", " \t\tcase GF_KEY_L:", " \t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {", " \t\t\t\tgf_term_switch_quality(term, 0);", " \t\t\t}", " \t\t\tbreak;", " \t\tcase GF_KEY_F5:", " \t\t\tif (is_connected)", " \t\t\t\treload = 1;", " \t\t\tbreak;", " \t\tcase GF_KEY_A:", " \t\t\taddon_visible = !addon_visible;", " \t\t\tgf_term_toggle_addons(term, addon_visible);", " \t\t\tbreak;", " \t\tcase GF_KEY_UP:", " \t\t\tif ((evt->key.flags & VK_MOD) && is_connected) {", " \t\t\t\tdo_set_speed(playback_speed * 2);", " \t\t\t}", " \t\t\tbreak;", " \t\tcase GF_KEY_DOWN:", " \t\t\tif ((evt->key.flags & VK_MOD) && is_connected) {", " \t\t\t\tdo_set_speed(playback_speed / 2);", " \t\t\t}", " \t\t\tbreak;", " \t\tcase GF_KEY_LEFT:", " \t\t\tif ((evt->key.flags & VK_MOD) && is_connected) {", " \t\t\t\tdo_set_speed(-1 * playback_speed );", " \t\t\t}", " \t\t\tbreak;", " \t\t}", " \t\tbreak;", " \tcase GF_EVENT_CONNECT:", " \t\tif (evt->connect.is_connected) {", " \t\t\tis_connected = 1;", " \t\t\tfprintf(stderr, \"Service Connected\\n\");", " \t\t\teos_seen = GF_FALSE;", " \t\t\tif (playback_speed != FIX_ONE)", " \t\t\t\tgf_term_set_speed(term, playback_speed);", " \t\t} else if (is_connected) {", " \t\t\tfprintf(stderr, \"Service %s\\n\", is_connected ? \"Disconnected\" : \"Connection Failed\");", " \t\t\tis_connected = 0;", " \t\t\tDuration = 0;", " \t\t}", " \t\tif (init_w && init_h) {", " \t\t\tgf_term_set_size(term, init_w, init_h);", " \t\t}", " \t\tResetCaption();", " \t\tbreak;", " \tcase GF_EVENT_EOS:", " \t\teos_seen = GF_TRUE;", " \t\tif (playlist) {", " \t\t\tif (Duration>1500)", " \t\t\t\trequest_next_playlist_item = GF_TRUE;", " \t\t}", " \t\telse if (loop_at_end) {", " \t\t\trestart = 1;", " \t\t}", " \t\tbreak;", " \tcase GF_EVENT_SIZE:", " \t\tif (user.init_flags & GF_TERM_WINDOWLESS) {", " \t\t\tGF_Event move;", " \t\t\tmove.type = GF_EVENT_MOVE;", " \t\t\tmove.move.align_x = align_mode & 0xFF;", " \t\t\tmove.move.align_y = (align_mode>>8) & 0xFF;", " \t\t\tmove.move.relative = 2;", " \t\t\tgf_term_user_event(term, &move);", " \t\t}", " \t\tbreak;", " \tcase GF_EVENT_SCENE_SIZE:", " \t\tif (forced_width && forced_height) {", " \t\t\tGF_Event size;", " \t\t\tsize.type = GF_EVENT_SIZE;", " \t\t\tsize.size.width = forced_width;", " \t\t\tsize.size.height = forced_height;", " \t\t\tgf_term_user_event(term, &size);", " \t\t}", " \t\tbreak;", " \tcase GF_EVENT_METADATA:", " \t\tResetCaption();", " \t\tbreak;", " \tcase GF_EVENT_RELOAD:", " \t\tif (is_connected)", " \t\t\treload = 1;", " \t\tbreak;", " \tcase GF_EVENT_DROPFILE:", " \t{", " \t\tu32 i, pos;", " \t\tif (readonly_playlist) {", " \t\t\tgf_fclose(playlist);", " \t\t\tplaylist = NULL;", " \t\t}", " \t\treadonly_playlist = 0;", " \t\tif (!playlist) {", " \t\t\treadonly_playlist = 0;", " \t\t\tplaylist = gf_temp_file_new(NULL);", " \t\t}", " \t\tpos = ftell(playlist);", " \t\ti=0;", " \t\twhile (i<evt->open_file.nb_files) {", " \t\t\tif (evt->open_file.files[i] != NULL) {", " \t\t\t\tfprintf(playlist, \"%s\\n\", evt->open_file.files[i]);", " \t\t\t}", " \t\t\ti++;", " \t\t}", " \t\tfseek(playlist, pos, SEEK_SET);", " \t\trequest_next_playlist_item = 1;", " \t}", " \treturn 1;", " \tcase GF_EVENT_QUIT:", " \t\tif (evt->message.error)  {", " \t\t\tfprintf(stderr, \"A fatal error was encoutered: %s (%s) - exiting ...\\n\", evt->message.message ? evt->message.message : \"no details\", gf_error_to_string(evt->message.error) );", " \t\t}", " \t\tRun = 0;", " \t\tbreak;", " \tcase GF_EVENT_DISCONNECT:", " \t\tgf_term_disconnect(term);", " \t\tbreak;", " \tcase GF_EVENT_MIGRATE:", " \t{", " \t}", " \tbreak;", " \tcase GF_EVENT_NAVIGATE_INFO:", " \t\tif (evt->navigate.to_url) fprintf(stderr, \"Go to URL: \\\"%s\\\"\\r\", evt->navigate.to_url);", "  \t\tbreak;", "  \tcase GF_EVENT_NAVIGATE:", "  \t\tif (gf_term_is_supported_url(term, evt->navigate.to_url, 1, no_mime_check)) {", "\t\t\tstrcpy(the_url, evt->navigate.to_url);", " \t\t\tstrncpy(the_url, evt->navigate.to_url, sizeof(the_url)-1);", " \t\t\tthe_url[sizeof(the_url) - 1] = 0;", "  \t\t\tfprintf(stderr, \"Navigating to URL %s\\n\", the_url);", "  \t\t\tgf_term_navigate_to(term, evt->navigate.to_url);", "  \t\t\treturn 1;", " \t\t} else {", " \t\t\tfprintf(stderr, \"Navigation destination not supported\\nGo to URL: %s\\n\", evt->navigate.to_url);", " \t\t}", " \t\tbreak;", " \tcase GF_EVENT_SET_CAPTION:", " \t\tgf_term_user_event(term, evt);", " \t\tbreak;", " \tcase GF_EVENT_AUTHORIZATION:", " \t{", " \t\tint maxTries = 1;", " \t\tassert( evt->type == GF_EVENT_AUTHORIZATION);", " \t\tassert( evt->auth.user);", " \t\tassert( evt->auth.password);", " \t\tassert( evt->auth.site_url);", " \t\twhile ((!strlen(evt->auth.user) || !strlen(evt->auth.password)) && (maxTries--) >= 0) {", " \t\t\tfprintf(stderr, \"**** Authorization required for site %s ****\\n\", evt->auth.site_url);", " \t\t\tfprintf(stderr, \"login   : \");", " \t\t\tread_line_input(evt->auth.user, 50, 1);", " \t\t\tfprintf(stderr, \"\\npassword: \");", " \t\t\tread_line_input(evt->auth.password, 50, 0);", " \t\t\tfprintf(stderr, \"*********\\n\");", " \t\t}", " \t\tif (maxTries < 0) {", " \t\t\tfprintf(stderr, \"**** No User or password has been filled, aborting ***\\n\");", " \t\t\treturn 0;", " \t\t}", " \t\treturn 1;", " \t}", " \tcase GF_EVENT_ADDON_DETECTED:", " \t\tif (enable_add_ons) {", " \t\t\tfprintf(stderr, \"Media Addon %s detected - enabling it\\n\", evt->addon_connect.addon_url);", " \t\t\taddon_visible = 1;", " \t\t}", " \t\treturn enable_add_ons;", " \t}", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int ndp_sock_open(struct ndp *ndp)", " {", " \tint sock;", " \tint ret;", " \tint err;", " \tint val;", " \tsock = socket(PF_INET6, SOCK_RAW, IPPROTO_ICMPV6);", " \tif (sock == -1) {", " \t\terr(ndp, \"Failed to create ICMP6 socket.\");", " \t\treturn -errno;", " \t}", " \tval = 1;", " \tret = setsockopt(sock, IPPROTO_IPV6, IPV6_RECVPKTINFO,", " \t\t\t &val, sizeof(val));", " \tif (ret == -1) {", " \t\terr(ndp, \"Failed to setsockopt IPV6_RECVPKTINFO.\");", " \t\terr = -errno;", " \t\tgoto close_sock;", " \t}", " \tval = 255;", " \tret = setsockopt(sock, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,", " \t\t\t &val, sizeof(val));", " \tif (ret == -1) {", " \t\terr(ndp, \"Failed to setsockopt IPV6_MULTICAST_HOPS.\");", " \t\terr = -errno;", "  \t\tgoto close_sock;", "  \t}", " \tval = 1;", " \tret = setsockopt(sock, IPPROTO_IPV6, IPV6_RECVHOPLIMIT,", " \t\t\t &val, sizeof(val));", " \tif (ret == -1) {", " \t\terr(ndp, \"Failed to setsockopt IPV6_RECVHOPLIMIT,.\");", " \t\terr = -errno;", " \t\tgoto close_sock;", " \t}", "  \tndp->sock = sock;", "  \treturn 0;", "  close_sock:", " \tclose(sock);", " \treturn err;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int asf_build_simple_index(AVFormatContext *s, int stream_index)", " {", "     ff_asf_guid g;", "     ASFContext *asf     = s->priv_data;", "     int64_t current_pos = avio_tell(s->pb);", "     int64_t ret;", "     if((ret = avio_seek(s->pb, asf->data_object_offset + asf->data_object_size, SEEK_SET)) < 0) {", "         return ret;", "     }", "     if ((ret = ff_get_guid(s->pb, &g)) < 0)", "         goto end;", "     while (ff_guidcmp(&g, &ff_asf_simple_index_header)) {", "         int64_t gsize = avio_rl64(s->pb);", "         if (gsize < 24 || avio_feof(s->pb)) {", "             goto end;", "         }", "         avio_skip(s->pb, gsize - 24);", "         if ((ret = ff_get_guid(s->pb, &g)) < 0)", "             goto end;", "     }", "     {", "         int64_t itime, last_pos = -1;", "         int pct, ict;", "         int i;", "         int64_t av_unused gsize = avio_rl64(s->pb);", "         if ((ret = ff_get_guid(s->pb, &g)) < 0)", "             goto end;", "         itime = avio_rl64(s->pb);", "         pct   = avio_rl32(s->pb);", "         ict   = avio_rl32(s->pb);", "         av_log(s, AV_LOG_DEBUG,", "                \"itime:0x%\"PRIx64\", pct:%d, ict:%d\\n\", itime, pct, ict);", "         for (i = 0; i < ict; i++) {", "             int pktnum        = avio_rl32(s->pb);", "             int pktct         = avio_rl16(s->pb);", "              int64_t pos       = s->internal->data_offset + s->packet_size * (int64_t)pktnum;", "              int64_t index_pts = FFMAX(av_rescale(itime, i, 10000) - asf->hdr.preroll, 0);", "             if (avio_feof(s->pb)) {", "                 ret = AVERROR_INVALIDDATA;", "                 goto end;", "             }", "              if (pos != last_pos) {", "                  av_log(s, AV_LOG_DEBUG, \"pktnum:%d, pktct:%d  pts: %\"PRId64\"\\n\",", "                         pktnum, pktct, index_pts);", "                 av_add_index_entry(s->streams[stream_index], pos, index_pts,", "                                    s->packet_size, 0, AVINDEX_KEYFRAME);", "                 last_pos = pos;", "             }", "         }", "         asf->index_read = ict > 1;", "     }", " end:", "     avio_seek(s->pb, current_pos, SEEK_SET);", "     return ret;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t *data_len)", " {", " \tstruct sc_path path;", " \tstruct sc_file *file;", " \tunsigned char *p;", " \tint ok = 0;", " \tint r;", " \tsize_t len;", " \tsc_format_path(str_path, &path);", " \tif (SC_SUCCESS != sc_select_file(card, &path, &file)) {", "  \t\tgoto err;", "  \t}", "\tlen = file ? file->size : 4096;", " \tlen = file && file->size > 0 ? file->size : 4096;", "  \tp = realloc(*data, len);", "  \tif (!p) {", "  \t\tgoto err;", " \t}", " \t*data = p;", " \t*data_len = len;", " \tr = sc_read_binary(card, 0, p, len, 0);", " \tif (r < 0)", " \t\tgoto err;", " \t*data_len = r;", " \tok = 1;", " err:", " \tsc_file_free(file);", " \treturn ok;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" header_seek (SF_PRIVATE *psf, sf_count_t position, int whence)", "  {", "  \tswitch (whence)", "  \t{\tcase SEEK_SET :", "\t\t\tif (position > SIGNED_SIZEOF (psf->header))", " \t\t\tif (psf->header.indx + position >= psf->header.len)", " \t\t\t\tpsf_bump_header_allocation (psf, position) ;", " \t\t\tif (position > psf->header.len)", "  \t\t\t{\t ", "  \t\t\t\tpsf_fseek (psf, position, whence) ;", "  \t\t\t\treturn ;", "  \t\t\t\t} ;", "\t\t\tif (position > psf->headend)", "\t\t\t\tpsf->headend += psf_fread (psf->header + psf->headend, 1, position - psf->headend, psf) ;", "\t\t\tpsf->headindex = position ;", " \t\t\tif (position > psf->header.end)", " \t\t\t\tpsf->header.end += psf_fread (psf->header.ptr + psf->header.end, 1, position - psf->header.end, psf) ;", " \t\t\tpsf->header.indx = position ;", "  \t\t\tbreak ;", "  \t\tcase SEEK_CUR :", "\t\t\tif (psf->headindex + position < 0)", " \t\t\tif (psf->header.indx + position >= psf->header.len)", " \t\t\t\tpsf_bump_header_allocation (psf, position) ;", " \t\t\tif (psf->header.indx + position < 0)", "  \t\t\t\tbreak ;", "\t\t\tif (psf->headindex >= SIGNED_SIZEOF (psf->header))", " \t\t\tif (psf->header.indx >= psf->header.len)", "  \t\t\t{\tpsf_fseek (psf, position, whence) ;", "  \t\t\t\treturn ;", "  \t\t\t\t} ;", "\t\t\tif (psf->headindex + position <= psf->headend)", "\t\t\t{\tpsf->headindex += position ;", " \t\t\tif (psf->header.indx + position <= psf->header.end)", " \t\t\t{\tpsf->header.indx += position ;", "  \t\t\t\tbreak ;", "  \t\t\t\t} ;", "\t\t\tif (psf->headindex + position > SIGNED_SIZEOF (psf->header))", " \t\t\tif (psf->header.indx + position > psf->header.len)", "  \t\t\t{\t ", "\t\t\t\tpsf->headindex = psf->headend ;", " \t\t\t\tpsf->header.indx = psf->header.end ;", "  \t\t\t\tpsf_fseek (psf, position, SEEK_CUR) ;", "  \t\t\t\tbreak ;", "  \t\t\t\t} ;", "\t\t\tpsf->headend += psf_fread (psf->header + psf->headend, 1, position - (psf->headend - psf->headindex), psf) ;", "\t\t\tpsf->headindex = psf->headend ;", " \t\t\tpsf->header.end += psf_fread (psf->header.ptr + psf->header.end, 1, position - (psf->header.end - psf->header.indx), psf) ;", " \t\t\tpsf->header.indx = psf->header.end ;", "  \t\t\tbreak ;", "  \t\tcase SEEK_END :", " \t\tdefault :", " \t\t\tpsf_log_printf (psf, \"Bad whence param in header_seek().\\n\") ;", " \t\t\tbreak ;", " \t\t} ;", " \treturn ;", " }  "], "ner_tags": [0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int xmkstemp(char **tmpname, char *dir)", " int xmkstemp(char **tmpname, const char *dir, const char *prefix)", "  {", "  \tchar *localtmp;", "\tchar *tmpenv;", " \tconst char *tmpenv;", "  \tmode_t old_mode;", "  \tint fd, rc;", "\tif (dir != NULL)", "\t\ttmpenv = dir;", "\telse", "\t\ttmpenv = getenv(\"TMPDIR\");", "\tif (tmpenv)", "\t\trc = asprintf(&localtmp, \"%s/%s.XXXXXX\", tmpenv,", "\t\t\t  program_invocation_short_name);", "\telse", "\t\trc = asprintf(&localtmp, \"%s/%s.XXXXXX\", _PATH_TMP,", "\t\t\t  program_invocation_short_name);", " \ttmpenv = dir ? dir : getenv(\"TMPDIR\");", " \tif (!tmpenv)", " \t\ttmpenv = _PATH_TMP;", " \trc = asprintf(&localtmp, \"%s/%s.XXXXXX\", tmpenv, prefix);", "  \tif (rc < 0)", "  \t\treturn -1;", " \told_mode = umask(077);", " \tfd = mkostemp(localtmp, O_RDWR|O_CREAT|O_EXCL|O_CLOEXEC);", " \tumask(old_mode);", " \tif (fd == -1) {", " \t\tfree(localtmp);", " \t\tlocaltmp = NULL;", " \t}", " \t*tmpname = localtmp;", " \treturn fd;", " }"], "ner_tags": [0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, void *yyscanner, RE_LEX_ENVIRONMENT *lex_env)", " {", "   YYUSE (yyvaluep);", "   YYUSE (yyscanner);", "   YYUSE (lex_env);", "   if (!yymsg)", "     yymsg = \"Deleting\";", "   YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);", "   YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN", "    switch (yytype)", "      {", "            case 6:  ", "#line 96 \"re_grammar.y\"  ", " #line 104 \"re_grammar.y\"  ", "        { yr_free(((*yyvaluep).class_vector)); }", "#line 1045 \"re_grammar.c\"  ", " #line 1053 \"re_grammar.c\"  ", "          break;", "      case 26:  ", "#line 97 \"re_grammar.y\"  ", " #line 105 \"re_grammar.y\"  ", "        { yr_re_node_destroy(((*yyvaluep).re_node)); }", "#line 1051 \"re_grammar.c\"  ", " #line 1059 \"re_grammar.c\"  ", "          break;", "      case 27:  ", "#line 98 \"re_grammar.y\"  ", " #line 106 \"re_grammar.y\"  ", "        { yr_re_node_destroy(((*yyvaluep).re_node)); }", "#line 1057 \"re_grammar.c\"  ", " #line 1065 \"re_grammar.c\"  ", "          break;", "      case 28:  ", "#line 99 \"re_grammar.y\"  ", " #line 107 \"re_grammar.y\"  ", "        { yr_re_node_destroy(((*yyvaluep).re_node)); }", "#line 1063 \"re_grammar.c\"  ", " #line 1071 \"re_grammar.c\"  ", "          break;", "      case 29:  ", "#line 100 \"re_grammar.y\"  ", " #line 108 \"re_grammar.y\"  ", "        { yr_re_node_destroy(((*yyvaluep).re_node)); }", "#line 1069 \"re_grammar.c\"  ", " #line 1077 \"re_grammar.c\"  ", "          break;", "       default:", "         break;", "     }", "   YY_IGNORE_MAYBE_UNINITIALIZED_END", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void ikev2_parent_outI1_continue(struct pluto_crypto_req_cont *pcrc,", " \t\t\t\t\tstruct pluto_crypto_req *r,", " \t\t\t\t\terr_t ugh)", " {", " \tstruct ke_continuation *ke = (struct ke_continuation *)pcrc;", " \tstruct msg_digest *md = ke->md;", " \tstruct state *const st = md->st;", " \tstf_status e;", " \tDBG(DBG_CONTROLMORE,", " \t    DBG_log(\"ikev2 parent outI1: calculated ke+nonce, sending I1\"));", " \tif (st == NULL) {", " \t\tloglog(RC_LOG_SERIOUS,", " \t\t       \"%s: Request was disconnected from state\",", " \t\t       __FUNCTION__);", " \t\tif (ke->md)", " \t\t\trelease_md(ke->md);", " \t\treturn;", " \t}", " \tpassert(ugh == NULL);", " \tpassert(cur_state == NULL);", " \tpassert(st != NULL);", " \tpassert(st->st_suspended_md == ke->md);", " \tset_suspended(st, NULL);  ", " \tset_cur_state(st);", " \tst->st_calculating = FALSE;", " \te = ikev2_parent_outI1_tail(pcrc, r);", " \tif (ke->md != NULL) {", " \t\tcomplete_v2_state_transition(&ke->md, e);", " \t\tif (ke->md)", " \t\t\trelease_md(ke->md);", "  \t}", "  \treset_cur_state();", "  \treset_globals();", "\tpassert(GLOBALS_ARE_RESET());", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": [" static int filter_frame(AVFilterLink *inlink, AVFrame *buf)", " {", "     AVFilterContext    *ctx = inlink->dst;", "     FPSContext           *s = ctx->priv;", "     AVFilterLink   *outlink = ctx->outputs[0];", "     int64_t delta;", "     int i, ret;", "     s->frames_in++;", "     if (s->pts == AV_NOPTS_VALUE) {", "         if (buf->pts != AV_NOPTS_VALUE) {", "             ret = write_to_fifo(s->fifo, buf);", "             if (ret < 0)", "                 return ret;", "             if (s->start_time != DBL_MAX && s->start_time != AV_NOPTS_VALUE) {", "                 double first_pts = s->start_time * AV_TIME_BASE;", "                 first_pts = FFMIN(FFMAX(first_pts, INT64_MIN), INT64_MAX);", "                 s->first_pts = s->pts = av_rescale_q(first_pts, AV_TIME_BASE_Q,", "                                                      inlink->time_base);", "                 av_log(ctx, AV_LOG_VERBOSE, \"Set first pts to (in:%\"PRId64\" out:%\"PRId64\")\\n\",", "                        s->first_pts, av_rescale_q(first_pts, AV_TIME_BASE_Q,", "                                                   outlink->time_base));", "             } else {", "                 s->first_pts = s->pts = buf->pts;", "             }", "         } else {", "             av_log(ctx, AV_LOG_WARNING, \"Discarding initial frame(s) with no \"", "                    \"timestamp.\\n\");", "             av_frame_free(&buf);", "             s->drop++;", "         }", "         return 0;", "      }", "    if (buf->pts == AV_NOPTS_VALUE) {", "     if (buf->pts == AV_NOPTS_VALUE || av_fifo_size(s->fifo) <= 0) {", "          return write_to_fifo(s->fifo, buf);", "      }", "     delta = av_rescale_q_rnd(buf->pts - s->pts, inlink->time_base,", "                              outlink->time_base, s->rounding);", "     if (delta < 1) {", "         AVFrame *tmp;", "         int drop = av_fifo_size(s->fifo)/sizeof(AVFrame*);", "         av_log(ctx, AV_LOG_DEBUG, \"Dropping %d frame(s).\\n\", drop);", "         s->drop += drop;", "         av_fifo_generic_read(s->fifo, &tmp, sizeof(tmp), NULL);", "         flush_fifo(s->fifo);", "         ret = write_to_fifo(s->fifo, tmp);", "         av_frame_free(&buf);", "         return ret;", "     }", "     for (i = 0; i < delta; i++) {", "         AVFrame *buf_out;", "         av_fifo_generic_read(s->fifo, &buf_out, sizeof(buf_out), NULL);", "         if (!av_fifo_size(s->fifo) && i < delta - 1) {", "             AVFrame *dup = av_frame_clone(buf_out);", "             av_log(ctx, AV_LOG_DEBUG, \"Duplicating frame.\\n\");", "             if (dup)", "                 ret = write_to_fifo(s->fifo, dup);", "             else", "                 ret = AVERROR(ENOMEM);", "             if (ret < 0) {", "                 av_frame_free(&buf_out);", "                 av_frame_free(&buf);", "                 return ret;", "             }", "             s->dup++;", "         }", "         buf_out->pts = av_rescale_q(s->first_pts, inlink->time_base,", "                                     outlink->time_base) + s->frames_out;", "         if ((ret = ff_filter_frame(outlink, buf_out)) < 0) {", "             av_frame_free(&buf);", "             return ret;", "         }", "         s->frames_out++;", "     }", "     flush_fifo(s->fifo);", "     ret = write_to_fifo(s->fifo, buf);", "     s->pts = s->first_pts + av_rescale_q(s->frames_out, outlink->time_base, inlink->time_base);", "     return ret;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void jas_seq2d_bindsub(jas_matrix_t *s, jas_matrix_t *s1, int xstart,", "  int ystart, int xend, int yend)", " void jas_seq2d_bindsub(jas_matrix_t *s, jas_matrix_t *s1, jas_matind_t xstart,", "   jas_matind_t ystart, jas_matind_t xend, jas_matind_t yend)", "  {", "  \tjas_matrix_bindsub(s, s1, ystart - s1->ystart_, xstart - s1->xstart_,", "  \t  yend - s1->ystart_ - 1, xend - s1->xstart_ - 1);", "  }"], "ner_tags": [0, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": [" parse_tsquery(char *buf,", " \t\t\t  PushFunction pushval,", " \t\t\t  Datum opaque,", " \t\t\t  bool isplain)", " {", " \tstruct TSQueryParserStateData state;", " \tint\t\t\ti;", " \tTSQuery\t\tquery;", " \tint\t\t\tcommonlen;", " \tQueryItem  *ptr;", " \tListCell   *cell;", " \tstate.buffer = buf;", " \tstate.buf = buf;", " \tstate.state = (isplain) ? WAITSINGLEOPERAND : WAITFIRSTOPERAND;", " \tstate.count = 0;", " \tstate.polstr = NIL;", " \tstate.valstate = init_tsvector_parser(state.buffer, true, true);", " \tstate.sumlen = 0;", " \tstate.lenop = 64;", " \tstate.curop = state.op = (char *) palloc(state.lenop);", " \t*(state.curop) = '\\0';", " \tmakepol(&state, pushval, opaque);", " \tclose_tsvector_parser(state.valstate);", " \tif (list_length(state.polstr) == 0)", " \t{", " \t\tereport(NOTICE,", " \t\t\t\t(errmsg(\"text-search query doesn't contain lexemes: \\\"%s\\\"\",", " \t\t\t\t\t\tstate.buffer)));", " \t\tquery = (TSQuery) palloc(HDRSIZETQ);", " \t\tSET_VARSIZE(query, HDRSIZETQ);", " \t\tquery->size = 0;", "  \t\treturn query;", "  \t}", " \tif (TSQUERY_TOO_BIG(list_length(state.polstr), state.sumlen))", " \t\tereport(ERROR,", " \t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),", " \t\t\t\t errmsg(\"tsquery is too large\")));", "  \tcommonlen = COMPUTESIZE(list_length(state.polstr), state.sumlen);", "  \tquery = (TSQuery) palloc0(commonlen);", "  \tSET_VARSIZE(query, commonlen);", "  \tquery->size = list_length(state.polstr);", " \tptr = GETQUERY(query);", " \ti = 0;", " \tforeach(cell, state.polstr)", " \t{", " \t\tQueryItem  *item = (QueryItem *) lfirst(cell);", " \t\tswitch (item->type)", " \t\t{", " \t\t\tcase QI_VAL:", " \t\t\t\tmemcpy(&ptr[i], item, sizeof(QueryOperand));", " \t\t\t\tbreak;", " \t\t\tcase QI_VALSTOP:", " \t\t\t\tptr[i].type = QI_VALSTOP;", " \t\t\t\tbreak;", " \t\t\tcase QI_OPR:", " \t\t\t\tmemcpy(&ptr[i], item, sizeof(QueryOperator));", " \t\t\t\tbreak;", " \t\t\tdefault:", " \t\t\t\telog(ERROR, \"unrecognized QueryItem type: %d\", item->type);", " \t\t}", " \t\ti++;", " \t}", " \tmemcpy((void *) GETOPERAND(query), (void *) state.op, state.sumlen);", " \tpfree(state.op);", " \tfindoprnd(ptr, query->size);", " \treturn query;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void ikev2_parent_inI1outR1_continue(struct pluto_crypto_req_cont *pcrc,", " \t\t\t\t\t    struct pluto_crypto_req *r,", " \t\t\t\t\t    err_t ugh)", " {", " \tstruct ke_continuation *ke = (struct ke_continuation *)pcrc;", " \tstruct msg_digest *md = ke->md;", " \tstruct state *const st = md->st;", " \tstf_status e;", " \tDBG(DBG_CONTROLMORE,", " \t    DBG_log(\"ikev2 parent inI1outR1: calculated ke+nonce, sending R1\"));", " \tif (st == NULL) {", " \t\tloglog(RC_LOG_SERIOUS,", " \t\t       \"%s: Request was disconnected from state\",", " \t\t       __FUNCTION__);", " \t\tif (ke->md)", " \t\t\trelease_md(ke->md);", " \t\treturn;", " \t}", " \tpassert(ugh == NULL);", " \tpassert(cur_state == NULL);", " \tpassert(st != NULL);", " \tpassert(st->st_suspended_md == ke->md);", " \tset_suspended(st, NULL);  ", " \tset_cur_state(st);", " \tst->st_calculating = FALSE;", " \te = ikev2_parent_inI1outR1_tail(pcrc, r);", " \tif (ke->md != NULL) {", " \t\tcomplete_v2_state_transition(&ke->md, e);", " \t\tif (ke->md)", "  \t\t\trelease_md(ke->md);", "  \t}", "  \treset_globals();", "\tpassert(GLOBALS_ARE_RESET());", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": [" hstore_from_record(PG_FUNCTION_ARGS)", " {", " \tHeapTupleHeader rec;", " \tint32\t\tbuflen;", " \tHStore\t   *out;", " \tPairs\t   *pairs;", " \tOid\t\t\ttupType;", " \tint32\t\ttupTypmod;", " \tTupleDesc\ttupdesc;", " \tHeapTupleData tuple;", " \tRecordIOData *my_extra;", " \tint\t\t\tncolumns;", " \tint\t\t\ti,", " \t\t\t\tj;", " \tDatum\t   *values;", " \tbool\t   *nulls;", " \tif (PG_ARGISNULL(0))", " \t{", " \t\tOid\t\t\targtype = get_fn_expr_argtype(fcinfo->flinfo, 0);", " \t\ttupType = argtype;", " \t\ttupTypmod = -1;", " \t\trec = NULL;", " \t}", " \telse", " \t{", " \t\trec = PG_GETARG_HEAPTUPLEHEADER(0);", " \t\ttupType = HeapTupleHeaderGetTypeId(rec);", " \t\ttupTypmod = HeapTupleHeaderGetTypMod(rec);", " \t}", " \ttupdesc = lookup_rowtype_tupdesc(tupType, tupTypmod);", " \tncolumns = tupdesc->natts;", " \tmy_extra = (RecordIOData *) fcinfo->flinfo->fn_extra;", " \tif (my_extra == NULL ||", " \t\tmy_extra->ncolumns != ncolumns)", " \t{", " \t\tfcinfo->flinfo->fn_extra =", " \t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,", " \t\t\t\t\t\t\t   sizeof(RecordIOData) - sizeof(ColumnIOData)", " \t\t\t\t\t\t\t   + ncolumns * sizeof(ColumnIOData));", " \t\tmy_extra = (RecordIOData *) fcinfo->flinfo->fn_extra;", " \t\tmy_extra->record_type = InvalidOid;", " \t\tmy_extra->record_typmod = 0;", " \t}", " \tif (my_extra->record_type != tupType ||", " \t\tmy_extra->record_typmod != tupTypmod)", " \t{", " \t\tMemSet(my_extra, 0,", " \t\t\t   sizeof(RecordIOData) - sizeof(ColumnIOData)", " \t\t\t   + ncolumns * sizeof(ColumnIOData));", " \t\tmy_extra->record_type = tupType;", " \t\tmy_extra->record_typmod = tupTypmod;", "  \t\tmy_extra->ncolumns = ncolumns;", "  \t}", " \tAssert(ncolumns <= MaxTupleAttributeNumber);\t\t ", "  \tpairs = palloc(ncolumns * sizeof(Pairs));", "  \tif (rec)", " \t{", " \t\ttuple.t_len = HeapTupleHeaderGetDatumLength(rec);", " \t\tItemPointerSetInvalid(&(tuple.t_self));", " \t\ttuple.t_tableOid = InvalidOid;", " \t\ttuple.t_data = rec;", " \t\tvalues = (Datum *) palloc(ncolumns * sizeof(Datum));", " \t\tnulls = (bool *) palloc(ncolumns * sizeof(bool));", " \t\theap_deform_tuple(&tuple, tupdesc, values, nulls);", " \t}", " \telse", " \t{", " \t\tvalues = NULL;", " \t\tnulls = NULL;", " \t}", " \tfor (i = 0, j = 0; i < ncolumns; ++i)", " \t{", " \t\tColumnIOData *column_info = &my_extra->columns[i];", " \t\tOid\t\t\tcolumn_type = tupdesc->attrs[i]->atttypid;", " \t\tchar\t   *value;", " \t\tif (tupdesc->attrs[i]->attisdropped)", " \t\t\tcontinue;", " \t\tpairs[j].key = NameStr(tupdesc->attrs[i]->attname);", " \t\tpairs[j].keylen = hstoreCheckKeyLen(strlen(NameStr(tupdesc->attrs[i]->attname)));", " \t\tif (!nulls || nulls[i])", " \t\t{", " \t\t\tpairs[j].val = NULL;", " \t\t\tpairs[j].vallen = 4;", " \t\t\tpairs[j].isnull = true;", " \t\t\tpairs[j].needfree = false;", " \t\t\t++j;", " \t\t\tcontinue;", " \t\t}", " \t\tif (column_info->column_type != column_type)", " \t\t{", " \t\t\tbool\t\ttypIsVarlena;", " \t\t\tgetTypeOutputInfo(column_type,", " \t\t\t\t\t\t\t  &column_info->typiofunc,", " \t\t\t\t\t\t\t  &typIsVarlena);", " \t\t\tfmgr_info_cxt(column_info->typiofunc, &column_info->proc,", " \t\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);", " \t\t\tcolumn_info->column_type = column_type;", " \t\t}", " \t\tvalue = OutputFunctionCall(&column_info->proc, values[i]);", " \t\tpairs[j].val = value;", " \t\tpairs[j].vallen = hstoreCheckValLen(strlen(value));", " \t\tpairs[j].isnull = false;", " \t\tpairs[j].needfree = false;", " \t\t++j;", " \t}", " \tncolumns = hstoreUniquePairs(pairs, j, &buflen);", " \tout = hstorePairs(pairs, ncolumns, buflen);", " \tReleaseTupleDesc(tupdesc);", " \tPG_RETURN_POINTER(out);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps)", " {", " \tint i;", " \tint j;", " \tint thresh;", " \tjpc_fix_t val;", " \tjpc_fix_t mag;", "  \tbool warn;", "  \tuint_fast32_t mask;", " \tif (roishift < 0) {", " \t\tjas_eprintf(\"warning: forcing negative ROI shift to zero \"", " \t\t  \"(bitstream is probably corrupt)\\n\");", " \t\troishift = 0;", " \t}", "  \tif (roishift == 0 && bgshift == 0) {", "  \t\treturn;", "  \t}", " \tthresh = 1 << roishift;", " \twarn = false;", " \tfor (i = 0; i < jas_matrix_numrows(x); ++i) {", " \t\tfor (j = 0; j < jas_matrix_numcols(x); ++j) {", " \t\t\tval = jas_matrix_get(x, i, j);", " \t\t\tmag = JAS_ABS(val);", " \t\t\tif (mag >= thresh) {", " \t\t\t\tmag >>= roishift;", " \t\t\t\tval = (val < 0) ? (-mag) : mag;", " \t\t\t\tjas_matrix_set(x, i, j, val);", "  \t\t\t} else {", "  \t\t\t\tmag <<= bgshift;", "\t\t\t\tmask = (1 << numbps) - 1;", " \t\t\t\tmask = (JAS_CAST(uint_fast32_t, 1) << numbps) - 1;", " \t\t\t\tif (mag & (~mask)) {", " \t\t\t\t\tif (!warn) {", " \t\t\t\t\t\tjas_eprintf(\"warning: possibly corrupt code stream\\n\");", " \t\t\t\t\t\twarn = true;", " \t\t\t\t\t}", " \t\t\t\t\tmag &= mask;", " \t\t\t\t}", " \t\t\t\tval = (val < 0) ? (-mag) : mag;", " \t\t\t\tjas_matrix_set(x, i, j, val);", " \t\t\t}", " \t\t}", " \t}", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int jpc_dec_tileinit(jpc_dec_t *dec, jpc_dec_tile_t *tile)", " {", " \tjpc_dec_tcomp_t *tcomp;", " \tint compno;", " \tint rlvlno;", " \tjpc_dec_rlvl_t *rlvl;", " \tjpc_dec_band_t *band;", " \tjpc_dec_prc_t *prc;", " \tint bndno;", " \tjpc_tsfb_band_t *bnd;", " \tint bandno;", " \tjpc_dec_ccp_t *ccp;", " \tint prccnt;", " \tjpc_dec_cblk_t *cblk;", " \tint cblkcnt;", " \tuint_fast32_t tlprcxstart;", " \tuint_fast32_t tlprcystart;", " \tuint_fast32_t brprcxend;", " \tuint_fast32_t brprcyend;", " \tuint_fast32_t tlcbgxstart;", " \tuint_fast32_t tlcbgystart;", " \tuint_fast32_t brcbgxend;", " \tuint_fast32_t brcbgyend;", " \tuint_fast32_t cbgxstart;", " \tuint_fast32_t cbgystart;", " \tuint_fast32_t cbgxend;", " \tuint_fast32_t cbgyend;", " \tuint_fast32_t tlcblkxstart;", " \tuint_fast32_t tlcblkystart;", " \tuint_fast32_t brcblkxend;", " \tuint_fast32_t brcblkyend;", " \tuint_fast32_t cblkxstart;", " \tuint_fast32_t cblkystart;", " \tuint_fast32_t cblkxend;", " \tuint_fast32_t cblkyend;", " \tuint_fast32_t tmpxstart;", " \tuint_fast32_t tmpystart;", "  \tuint_fast32_t tmpxend;", "  \tuint_fast32_t tmpyend;", "  \tjpc_dec_cp_t *cp;", "\tjpc_tsfb_band_t bnds[64];", " \tjpc_tsfb_band_t bnds[JPC_MAXBANDS];", "  \tjpc_pchg_t *pchg;", "  \tint pchgno;", "  \tjpc_dec_cmpt_t *cmpt;", " \tcp = tile->cp;", " \ttile->realmode = 0;", " \tif (cp->mctid == JPC_MCT_ICT) {", " \t\ttile->realmode = 1;", " \t}", " \tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <", " \t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {", " \t\tccp = &tile->cp->ccps[compno];", " \t\tif (ccp->qmfbid == JPC_COX_INS) {", " \t\t\ttile->realmode = 1;", " \t\t}", " \t\ttcomp->numrlvls = ccp->numrlvls;", " \t\tif (!(tcomp->rlvls = jas_alloc2(tcomp->numrlvls,", " \t\t  sizeof(jpc_dec_rlvl_t)))) {", " \t\t\treturn -1;", " \t\t}", " \t\tif (!(tcomp->data = jas_seq2d_create(JPC_CEILDIV(tile->xstart,", " \t\t  cmpt->hstep), JPC_CEILDIV(tile->ystart, cmpt->vstep),", " \t\t  JPC_CEILDIV(tile->xend, cmpt->hstep), JPC_CEILDIV(tile->yend,", " \t\t  cmpt->vstep)))) {", " \t\t\treturn -1;", " \t\t}", " \t\tif (!(tcomp->tsfb = jpc_cod_gettsfb(ccp->qmfbid,", " \t\t  tcomp->numrlvls - 1))) {", " \t\t\treturn -1;", " \t\t}", " \t\t{", " \t\t\tjpc_tsfb_getbands(tcomp->tsfb, jas_seq2d_xstart(tcomp->data),", " \t\t\t  jas_seq2d_ystart(tcomp->data), jas_seq2d_xend(tcomp->data),", " \t\t\t  jas_seq2d_yend(tcomp->data), bnds);", " \t\t}", " \t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls;", " \t\t  ++rlvlno, ++rlvl) {", " \t\t\trlvl->bands = 0;", " \t\t\trlvl->xstart = JPC_CEILDIVPOW2(tcomp->xstart,", " \t\t\t  tcomp->numrlvls - 1 - rlvlno);", " \t\t\trlvl->ystart = JPC_CEILDIVPOW2(tcomp->ystart,", " \t\t\t  tcomp->numrlvls - 1 - rlvlno);", " \t\t\trlvl->xend = JPC_CEILDIVPOW2(tcomp->xend,", " \t\t\t  tcomp->numrlvls - 1 - rlvlno);", " \t\t\trlvl->yend = JPC_CEILDIVPOW2(tcomp->yend,", " \t\t\t  tcomp->numrlvls - 1 - rlvlno);", " \t\t\trlvl->prcwidthexpn = ccp->prcwidthexpns[rlvlno];", " \t\t\trlvl->prcheightexpn = ccp->prcheightexpns[rlvlno];", " \t\t\ttlprcxstart = JPC_FLOORDIVPOW2(rlvl->xstart,", " \t\t\t  rlvl->prcwidthexpn) << rlvl->prcwidthexpn;", " \t\t\ttlprcystart = JPC_FLOORDIVPOW2(rlvl->ystart,", " \t\t\t  rlvl->prcheightexpn) << rlvl->prcheightexpn;", " \t\t\tbrprcxend = JPC_CEILDIVPOW2(rlvl->xend,", " \t\t\t  rlvl->prcwidthexpn) << rlvl->prcwidthexpn;", " \t\t\tbrprcyend = JPC_CEILDIVPOW2(rlvl->yend,", " \t\t\t  rlvl->prcheightexpn) << rlvl->prcheightexpn;", " \t\t\trlvl->numhprcs = (brprcxend - tlprcxstart) >>", " \t\t\t  rlvl->prcwidthexpn;", " \t\t\trlvl->numvprcs = (brprcyend - tlprcystart) >>", " \t\t\t  rlvl->prcheightexpn;", " \t\t\trlvl->numprcs = rlvl->numhprcs * rlvl->numvprcs;", " \t\t\tif (rlvl->xstart >= rlvl->xend || rlvl->ystart >= rlvl->yend) {", " \t\t\t\trlvl->bands = 0;", " \t\t\t\trlvl->numprcs = 0;", " \t\t\t\trlvl->numhprcs = 0;", " \t\t\t\trlvl->numvprcs = 0;", " \t\t\t\tcontinue;", " \t\t\t}\t", " \t\t\tif (!rlvlno) {", " \t\t\t\ttlcbgxstart = tlprcxstart;", " \t\t\t\ttlcbgystart = tlprcystart;", " \t\t\t\tbrcbgxend = brprcxend;", " \t\t\t\tbrcbgyend = brprcyend;", " \t\t\t\trlvl->cbgwidthexpn = rlvl->prcwidthexpn;", " \t\t\t\trlvl->cbgheightexpn = rlvl->prcheightexpn;", " \t\t\t} else {", " \t\t\t\ttlcbgxstart = JPC_CEILDIVPOW2(tlprcxstart, 1);", " \t\t\t\ttlcbgystart = JPC_CEILDIVPOW2(tlprcystart, 1);", " \t\t\t\tbrcbgxend = JPC_CEILDIVPOW2(brprcxend, 1);", " \t\t\t\tbrcbgyend = JPC_CEILDIVPOW2(brprcyend, 1);", " \t\t\t\trlvl->cbgwidthexpn = rlvl->prcwidthexpn - 1;", " \t\t\t\trlvl->cbgheightexpn = rlvl->prcheightexpn - 1;", " \t\t\t}", " \t\t\trlvl->cblkwidthexpn = JAS_MIN(ccp->cblkwidthexpn,", " \t\t\t  rlvl->cbgwidthexpn);", " \t\t\trlvl->cblkheightexpn = JAS_MIN(ccp->cblkheightexpn,", " \t\t\t  rlvl->cbgheightexpn);", " \t\t\trlvl->numbands = (!rlvlno) ? 1 : 3;", " \t\t\tif (!(rlvl->bands = jas_alloc2(rlvl->numbands,", " \t\t\t  sizeof(jpc_dec_band_t)))) {", " \t\t\t\treturn -1;", " \t\t\t}", " \t\t\tfor (bandno = 0, band = rlvl->bands;", " \t\t\t  bandno < rlvl->numbands; ++bandno, ++band) {", " \t\t\t\tbndno = (!rlvlno) ? 0 : (3 * (rlvlno - 1) +", " \t\t\t\t  bandno + 1);", " \t\t\t\tbnd = &bnds[bndno];", " \t\t\t\tband->orient = bnd->orient;", " \t\t\t\tband->stepsize = ccp->stepsizes[bndno];", " \t\t\t\tband->analgain = JPC_NOMINALGAIN(ccp->qmfbid,", " \t\t\t\t  tcomp->numrlvls - 1, rlvlno, band->orient);", " \t\t\t\tband->absstepsize = jpc_calcabsstepsize(band->stepsize,", " \t\t\t\t  cmpt->prec + band->analgain);", " \t\t\t\tband->numbps = ccp->numguardbits +", " \t\t\t\t  JPC_QCX_GETEXPN(band->stepsize) - 1;", " \t\t\t\tband->roishift = (ccp->roishift + band->numbps >= JPC_PREC) ?", " \t\t\t\t  (JPC_PREC - 1 - band->numbps) : ccp->roishift;", " \t\t\t\tband->data = 0;", " \t\t\t\tband->prcs = 0;", " \t\t\t\tif (bnd->xstart == bnd->xend || bnd->ystart == bnd->yend) {", " \t\t\t\t\tcontinue;", " \t\t\t\t}", " \t\t\t\tif (!(band->data = jas_seq2d_create(0, 0, 0, 0))) {", " \t\t\t\t\treturn -1;", " \t\t\t\t}", " \t\t\t\tjas_seq2d_bindsub(band->data, tcomp->data, bnd->locxstart,", " \t\t\t\t  bnd->locystart, bnd->locxend, bnd->locyend);", " \t\t\t\tjas_seq2d_setshift(band->data, bnd->xstart, bnd->ystart);", " \t\t\t\tassert(rlvl->numprcs);", " \t\t\t\tif (!(band->prcs = jas_alloc2(rlvl->numprcs,", " \t\t\t\t  sizeof(jpc_dec_prc_t)))) {", " \t\t\t\t\treturn -1;", " \t\t\t\t}", " \t\t\t\tcbgxstart = tlcbgxstart;", " \t\t\t\tcbgystart = tlcbgystart;", " \t\t\t\tfor (prccnt = rlvl->numprcs, prc = band->prcs;", " \t\t\t\t  prccnt > 0; --prccnt, ++prc) {", " \t\t\t\t\tcbgxend = cbgxstart + (1 << rlvl->cbgwidthexpn);", " \t\t\t\t\tcbgyend = cbgystart + (1 << rlvl->cbgheightexpn);", " \t\t\t\t\tprc->xstart = JAS_MAX(cbgxstart, JAS_CAST(uint_fast32_t,", " \t\t\t\t\t  jas_seq2d_xstart(band->data)));", " \t\t\t\t\tprc->ystart = JAS_MAX(cbgystart, JAS_CAST(uint_fast32_t,", " \t\t\t\t\t  jas_seq2d_ystart(band->data)));", " \t\t\t\t\tprc->xend = JAS_MIN(cbgxend, JAS_CAST(uint_fast32_t,", " \t\t\t\t\t  jas_seq2d_xend(band->data)));", " \t\t\t\t\tprc->yend = JAS_MIN(cbgyend, JAS_CAST(uint_fast32_t,", " \t\t\t\t\t  jas_seq2d_yend(band->data)));", " \t\t\t\t\tif (prc->xend > prc->xstart && prc->yend > prc->ystart) {", " \t\t\t\t\t\ttlcblkxstart = JPC_FLOORDIVPOW2(prc->xstart,", " \t\t\t\t\t\t  rlvl->cblkwidthexpn) << rlvl->cblkwidthexpn;", " \t\t\t\t\t\ttlcblkystart = JPC_FLOORDIVPOW2(prc->ystart,", " \t\t\t\t\t\t  rlvl->cblkheightexpn) << rlvl->cblkheightexpn;", " \t\t\t\t\t\tbrcblkxend = JPC_CEILDIVPOW2(prc->xend,", " \t\t\t\t\t\t  rlvl->cblkwidthexpn) << rlvl->cblkwidthexpn;", " \t\t\t\t\t\tbrcblkyend = JPC_CEILDIVPOW2(prc->yend,", " \t\t\t\t\t\t  rlvl->cblkheightexpn) << rlvl->cblkheightexpn;", " \t\t\t\t\t\tprc->numhcblks = (brcblkxend - tlcblkxstart) >>", " \t\t\t\t\t\t  rlvl->cblkwidthexpn;", " \t\t\t\t\t\tprc->numvcblks = (brcblkyend - tlcblkystart) >>", " \t\t\t\t\t\t  rlvl->cblkheightexpn;", " \t\t\t\t\t\tprc->numcblks = prc->numhcblks * prc->numvcblks;", " \t\t\t\t\t\tassert(prc->numcblks > 0);", " \t\t\t\t\t\tif (!(prc->incltagtree = jpc_tagtree_create(", " \t\t\t\t\t\t  prc->numhcblks, prc->numvcblks))) {", " \t\t\t\t\t\t\treturn -1;", " \t\t\t\t\t\t}", " \t\t\t\t\t\tif (!(prc->numimsbstagtree = jpc_tagtree_create(", " \t\t\t\t\t\t  prc->numhcblks, prc->numvcblks))) {", " \t\t\t\t\t\t\treturn -1;", " \t\t\t\t\t\t}", " \t\t\t\t\t\tif (!(prc->cblks = jas_alloc2(prc->numcblks,", " \t\t\t\t\t\t  sizeof(jpc_dec_cblk_t)))) {", " \t\t\t\t\t\t\treturn -1;", " \t\t\t\t\t\t}", " \t\t\t\t\t\tcblkxstart = cbgxstart;", " \t\t\t\t\t\tcblkystart = cbgystart;", " \t\t\t\t\t\tfor (cblkcnt = prc->numcblks, cblk = prc->cblks;", " \t\t\t\t\t\t  cblkcnt > 0;) {", " \t\t\t\t\t\t\tcblkxend = cblkxstart + (1 << rlvl->cblkwidthexpn);", " \t\t\t\t\t\t\tcblkyend = cblkystart + (1 << rlvl->cblkheightexpn);", " \t\t\t\t\t\t\ttmpxstart = JAS_MAX(cblkxstart, prc->xstart);", " \t\t\t\t\t\t\ttmpystart = JAS_MAX(cblkystart, prc->ystart);", " \t\t\t\t\t\t\ttmpxend = JAS_MIN(cblkxend, prc->xend);", " \t\t\t\t\t\t\ttmpyend = JAS_MIN(cblkyend, prc->yend);", " \t\t\t\t\t\t\tif (tmpxend > tmpxstart && tmpyend > tmpystart) {", " \t\t\t\t\t\t\t\tcblk->firstpassno = -1;", " \t\t\t\t\t\t\t\tcblk->mqdec = 0;", " \t\t\t\t\t\t\t\tcblk->nulldec = 0;", " \t\t\t\t\t\t\t\tcblk->flags = 0;", " \t\t\t\t\t\t\t\tcblk->numpasses = 0;", " \t\t\t\t\t\t\t\tcblk->segs.head = 0;", " \t\t\t\t\t\t\t\tcblk->segs.tail = 0;", " \t\t\t\t\t\t\t\tcblk->curseg = 0;", " \t\t\t\t\t\t\t\tcblk->numimsbs = 0;", " \t\t\t\t\t\t\t\tcblk->numlenbits = 3;", " \t\t\t\t\t\t\t\tcblk->flags = 0;", " \t\t\t\t\t\t\t\tif (!(cblk->data = jas_seq2d_create(0, 0, 0,", " \t\t\t\t\t\t\t\t  0))) {", " \t\t\t\t\t\t\t\t\treturn -1;", " \t\t\t\t\t\t\t\t}", " \t\t\t\t\t\t\t\tjas_seq2d_bindsub(cblk->data, band->data,", " \t\t\t\t\t\t\t\t  tmpxstart, tmpystart, tmpxend, tmpyend);", " \t\t\t\t\t\t\t\t++cblk;", " \t\t\t\t\t\t\t\t--cblkcnt;", " \t\t\t\t\t\t\t}", " \t\t\t\t\t\t\tcblkxstart += 1 << rlvl->cblkwidthexpn;", " \t\t\t\t\t\t\tif (cblkxstart >= cbgxend) {", " \t\t\t\t\t\t\t\tcblkxstart = cbgxstart;", " \t\t\t\t\t\t\t\tcblkystart += 1 << rlvl->cblkheightexpn;", " \t\t\t\t\t\t\t}", " \t\t\t\t\t\t}", " \t\t\t\t\t} else {", " \t\t\t\t\t\tprc->cblks = 0;", " \t\t\t\t\t\tprc->incltagtree = 0;", " \t\t\t\t\t\tprc->numimsbstagtree = 0;", " \t\t\t\t\t}", " \t\t\t\t\tcbgxstart += 1 << rlvl->cbgwidthexpn;", " \t\t\t\t\tif (cbgxstart >= brcbgxend) {", " \t\t\t\t\t\tcbgxstart = tlcbgxstart;", " \t\t\t\t\t\tcbgystart += 1 << rlvl->cbgheightexpn;", " \t\t\t\t\t}", " \t\t\t\t}", " \t\t\t}", " \t\t}", " \t}", " \tif (!(tile->pi = jpc_dec_pi_create(dec, tile))) {", " \t\treturn -1;", " \t}", " \tfor (pchgno = 0; pchgno < jpc_pchglist_numpchgs(tile->cp->pchglist);", " \t  ++pchgno) {", " \t\tpchg = jpc_pchg_copy(jpc_pchglist_get(tile->cp->pchglist, pchgno));", " \t\tassert(pchg);", " \t\tjpc_pi_addpchg(tile->pi, pchg);", " \t}", " \tjpc_pi_init(tile->pi);", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void parse_sec_attr_44(sc_file_t *file, const u8 *buf, size_t len)", " {", " \tconst int df_idx[8] = {\t  ", " \t\tSC_AC_OP_DELETE, SC_AC_OP_CREATE, SC_AC_OP_CREATE,", " \t\tSC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE,", " \t\tSC_AC_OP_LOCK, SC_AC_OP_DELETE, -1};", " \tconst int ef_idx[8] = {", " \t\tSC_AC_OP_READ, SC_AC_OP_UPDATE, SC_AC_OP_WRITE,", " \t\tSC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE,", " \t\t-1, SC_AC_OP_ERASE, -1};", " \tconst int efi_idx[8] = {  ", " \t\tSC_AC_OP_READ, SC_AC_OP_ERASE, SC_AC_OP_UPDATE,", " \t\tSC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE,", " \t\t-1, SC_AC_OP_ERASE, -1};", " \tu8\t\tbValue;", " \tint\t\ti;", " \tint\t\tiKeyRef = 0;", " \tint\t\tiMethod;", " \tint\t\tiPinCount;", " \tint\t\tiOffset = 0;", " \tint\t\tiOperation;", " \tconst int*\tp_idx;", "  \twhile (len > 1) {\t\t\t\t ", "  \t\tint\tiACLen   = buf[iOffset] & 0x0F;", " \t\tif ((size_t) iACLen > len)", " \t\t\tbreak;", "  \t\tiPinCount = -1;\t\t\t ", "  \t\tiMethod = SC_AC_NONE;\t\t ", " \t\tif (buf[iOffset] & 0X80) {  ", " \t\t\tint\tiParmLen = 1;\t\t\t ", " \t\t\tint\tiKeyLen  = 0;\t\t\t ", " \t\t\tif (buf[iOffset]   & 0x20) iKeyLen++;", " \t\t\tif (buf[iOffset+1] & 0x40) iParmLen++;", " \t\t\tif (buf[iOffset+1] & 0x20) iParmLen++;", " \t\t\tif (buf[iOffset+1] & 0x10) iParmLen++;", " \t\t\tif (buf[iOffset+1] & 0x08) iParmLen++;", "  \t\t\tif(iKeyLen) {", "\t\t\t\tint iSC = buf[iOffset+iACLen];", " \t\t\t\tint iSC;", " \t\t\t\tif (len < 1+iACLen)", " \t\t\t\t\tbreak;", " \t\t\t\tiSC = buf[iOffset+iACLen];", "  \t\t\t\tswitch( (iSC>>5) & 0x03 ){", "  \t\t\t\tcase 0:", " \t\t\t\t\tiMethod = SC_AC_TERM;\t\t ", " \t\t\t\t\tbreak;", " \t\t\t\tcase 1:", " \t\t\t\t\tiMethod = SC_AC_AUT;\t\t ", " \t\t\t\t\tbreak;", " \t\t\t\tcase 2:", " \t\t\t\tcase 3:", " \t\t\t\t\tiMethod = SC_AC_PRO;\t\t ", " \t\t\t\t\tbreak;", " \t\t\t\t}", " \t\t\t\tiKeyRef = iSC & 0x1F;\t\t\t ", " \t\t\t}", "  \t\t\tif (iACLen > (1+iParmLen+iKeyLen)) {   ", " \t\t\t\tif (len < 1+1+1+iParmLen)", " \t\t\t\t\tbreak;", "  \t\t\t\tiKeyRef = buf[iOffset+1+1+iParmLen];   ", "  \t\t\t\tiMethod = SC_AC_CHV;", "  \t\t\t}", " \t\t\tif (len < 1+2)", " \t\t\t\tbreak;", "  \t\t\tswitch(buf[iOffset+2]){", "  \t\t\tcase 0x2A:\t\t\t ", "  \t\t\t\tiOperation = SC_AC_OP_CRYPTO;", " \t\t\t\tbreak;", " \t\t\tcase 0x46:\t\t\t ", " \t\t\t\tiOperation = SC_AC_OP_UPDATE;", " \t\t\t\tbreak;", " \t\t\tdefault:", " \t\t\t\tiOperation = SC_AC_OP_SELECT;", " \t\t\t\tbreak;", " \t\t\t}", " \t\t\tsc_file_add_acl_entry(file, iOperation, iMethod, iKeyRef);", " \t\t}", " \t\telse {  ", " \t\t\tswitch (file->type) {", " \t\t\tcase SC_FILE_TYPE_DF:             ", " \t\t\t\tp_idx = df_idx;", " \t\t\t\tbreak;", " \t\t\tcase SC_FILE_TYPE_INTERNAL_EF:    ", " \t\t\t\tp_idx = efi_idx;", " \t\t\t\tbreak;", " \t\t\tdefault:                          ", " \t\t\t\tp_idx = ef_idx;", " \t\t\t\tbreak;", " \t\t\t}", "  \t\t\tiPinCount = iACLen - 1;\t\t", "  \t\t\tif (buf[iOffset] & 0x20) {", "\t\t\t\tint iSC = buf[iOffset + iACLen];", " \t\t\t\tint iSC;", " \t\t\t\tif (len < 1 + iACLen)", " \t\t\t\t\tbreak;", " \t\t\t\tiSC = buf[iOffset + iACLen];", "  \t\t\t\tswitch( (iSC>>5) & 0x03 ) {", "  \t\t\t\tcase 0:", " \t\t\t\t\tiMethod = SC_AC_TERM;\t\t ", " \t\t\t\t\tbreak;", " \t\t\t\tcase 1:", " \t\t\t\t\tiMethod = SC_AC_AUT;\t\t ", " \t\t\t\t\tbreak;", " \t\t\t\tcase 2:", " \t\t\t\tcase 3:", " \t\t\t\t\tiMethod = SC_AC_PRO;\t\t ", " \t\t\t\t\tbreak;", " \t\t\t\t}", " \t\t\t\tiKeyRef = iSC & 0x1F;\t\t\t ", " \t\t\t\tiPinCount--;\t\t\t\t ", " \t\t\t}", "  \t\t\tif ( iPinCount > 0 ) {", " \t\t\t\tif (len < 1 + 2)", " \t\t\t\t\tbreak;", "  \t\t\t\tiKeyRef = buf[iOffset + 2];\t ", "  \t\t\t\tiMethod = SC_AC_CHV;", "  \t\t\t}", " \t\t\tbValue = buf[iOffset + 1];", " \t\t\tfor (i = 0; i < 8; i++) {", " \t\t\t\tif((bValue & 1) && (p_idx[i] >= 0))", " \t\t\t\t\tsc_file_add_acl_entry(file, p_idx[i], iMethod, iKeyRef);", " \t\t\t\tbValue >>= 1;", " \t\t\t}", " \t\t}", " \t\tiOffset += iACLen +1;\t\t ", " \t\tlen     -= iACLen +1;", " \t}", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int filter_frame(AVFilterLink *inlink, AVFrame *in)", " {", "     GradFunContext *s = inlink->dst->priv;", "     AVFilterLink *outlink = inlink->dst->outputs[0];", "     AVFrame *out;", "     int p, direct;", "     if (av_frame_is_writable(in)) {", "         direct = 1;", "         out = in;", "     } else {", "         direct = 0;", "         out = ff_get_video_buffer(outlink, outlink->w, outlink->h);", "         if (!out) {", "             av_frame_free(&in);", "             return AVERROR(ENOMEM);", "         }", "          av_frame_copy_props(out, in);", "      }", "    for (p = 0; p < 4 && in->data[p]; p++) {", "     for (p = 0; p < 4 && in->data[p] && in->linesize[p]; p++) {", "          int w = inlink->w;", "          int h = inlink->h;", "          int r = s->radius;", "         if (p) {", "             w = s->chroma_w;", "             h = s->chroma_h;", "             r = s->chroma_r;", "         }", "         if (FFMIN(w, h) > 2 * r)", "             filter(s, out->data[p], in->data[p], w, h, out->linesize[p], in->linesize[p], r);", "         else if (out->data[p] != in->data[p])", "             av_image_copy_plane(out->data[p], out->linesize[p], in->data[p], in->linesize[p], w, h);", "     }", "     if (!direct)", "         av_frame_free(&in);", "     return ff_filter_frame(outlink, out);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" jp2_box_t *jp2_box_get(jas_stream_t *in)", " {", " \tjp2_box_t *box;", " \tjp2_boxinfo_t *boxinfo;", " \tjas_stream_t *tmpstream;", " \tuint_fast32_t len;", " \tuint_fast64_t extlen;", " \tbool dataflag;", " \tbox = 0;", " \ttmpstream = 0;", "  \tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {", "  \t\tgoto error;", "  \t}", "  \tbox->ops = &jp2_boxinfo_unk.ops;", "  \tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {", "  \t\tgoto error;", "  \t}", "  \tboxinfo = jp2_boxinfolookup(box->type);", "  \tbox->info = boxinfo;", "\tbox->ops = &boxinfo->ops;", "  \tbox->len = len;", "  \tJAS_DBGLOG(10, (", "  \t  \"preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n\",", " \t  '\"', boxinfo->name, '\"', box->type, box->len", " \t  ));", " \tif (box->len == 1) {", " \t\tif (jp2_getuint64(in, &extlen)) {", " \t\t\tgoto error;", " \t\t}", " \t\tif (extlen > 0xffffffffUL) {", " \t\t\tjas_eprintf(\"warning: cannot handle large 64-bit box length\\n\");", " \t\t\textlen = 0xffffffffUL;", " \t\t}", " \t\tbox->len = extlen;", " \t\tbox->datalen = extlen - JP2_BOX_HDRLEN(true);", " \t} else {", " \t\tbox->datalen = box->len - JP2_BOX_HDRLEN(false);", " \t}", " \tif (box->len != 0 && box->len < 8) {", " \t\tgoto error;", " \t}", " \tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));", " \tif (dataflag) {", " \t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {", "  \t\t\tgoto error;", "  \t\t}", "  \t\tif (jas_stream_copy(tmpstream, in, box->datalen)) {", "\t\t\tbox->ops = &jp2_boxinfo_unk.ops;", "  \t\t\tjas_eprintf(\"cannot copy box data\\n\");", "  \t\t\tgoto error;", "  \t\t}", "  \t\tjas_stream_rewind(tmpstream);", " \t\tbox->ops = &boxinfo->ops;", "  \t\tif (box->ops->getdata) {", "  \t\t\tif ((*box->ops->getdata)(box, tmpstream)) {", "  \t\t\t\tjas_eprintf(\"cannot parse box data\\n\");", " \t\t\t\tgoto error;", " \t\t\t}", " \t\t}", " \t\tjas_stream_close(tmpstream);", " \t}", " \tif (jas_getdbglevel() >= 1) {", " \t\tjp2_box_dump(box, stderr);", " \t}", " \treturn box;", " error:", " \tif (box) {", " \t\tjp2_box_destroy(box);", " \t}", " \tif (tmpstream) {", " \t\tjas_stream_close(tmpstream);", " \t}", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" char *FLTGetIsLikeComparisonExpression(FilterEncodingNode *psFilterNode)", " {", "   const size_t bufferSize = 1024;", "   char szBuffer[1024];", "   char szTmp[256];", "   char *pszValue = NULL;", "   const char *pszWild = NULL;", "   const char *pszSingle = NULL;", "   const char *pszEscape = NULL;", "   int  bCaseInsensitive = 0;", "   int nLength=0, i=0, iTmp=0;", "   FEPropertyIsLike* propIsLike;", "   if (!psFilterNode || !psFilterNode->pOther || !psFilterNode->psLeftNode ||", "       !psFilterNode->psRightNode || !psFilterNode->psRightNode->pszValue)", "     return NULL;", "   propIsLike = (FEPropertyIsLike *)psFilterNode->pOther;", "   pszWild = propIsLike->pszWildCard;", "   pszSingle = propIsLike->pszSingleChar;", "   pszEscape = propIsLike->pszEscapeChar;", "   bCaseInsensitive = propIsLike->bCaseInsensitive;", "   if (!pszWild || strlen(pszWild) == 0 ||", "       !pszSingle || strlen(pszSingle) == 0 ||", "       !pszEscape || strlen(pszEscape) == 0)", "     return NULL;", "   szBuffer[0] = '\\0';", "   sprintf(szTmp, \"%s\", \" (\\\"[\");", "   szTmp[4] = '\\0';", "   strlcat(szBuffer, szTmp, bufferSize);", "   strlcat(szBuffer, psFilterNode->psLeftNode->pszValue, bufferSize);", "   szBuffer[strlen(szBuffer)] = '\\0';", "   if(bCaseInsensitive == 1)", "     sprintf(szTmp, \"%s\", \"]\\\" ~* /\");", "   else", "     sprintf(szTmp, \"%s\", \"]\\\" =~ /\");", "   szTmp[7] = '\\0';", "   strlcat(szBuffer, szTmp, bufferSize);", "   szBuffer[strlen(szBuffer)] = '\\0';", "    pszValue = psFilterNode->psRightNode->pszValue;", "    nLength = strlen(pszValue);", "   if( 1 + 2 * nLength + 1 + 1 >= sizeof(szTmp) )", "       return NULL;", "    iTmp =0;", "    if (nLength > 0 && pszValue[0] != pszWild[0] &&", "       pszValue[0] != pszSingle[0] &&", "       pszValue[0] != pszEscape[0]) {", "     szTmp[iTmp]= '^';", "     iTmp++;", "   }", "   for (i=0; i<nLength; i++) {", "     if (pszValue[i] != pszWild[0] &&", "         pszValue[i] != pszSingle[0] &&", "         pszValue[i] != pszEscape[0]) {", "       szTmp[iTmp] = pszValue[i];", "       iTmp++;", "       szTmp[iTmp] = '\\0';", "     } else if  (pszValue[i] == pszSingle[0]) {", "       szTmp[iTmp] = '.';", "       iTmp++;", "       szTmp[iTmp] = '\\0';", "     } else if  (pszValue[i] == pszEscape[0]) {", "       szTmp[iTmp] = '\\\\';", "       iTmp++;", "       szTmp[iTmp] = '\\0';", "     } else if (pszValue[i] == pszWild[0]) {", "       szTmp[iTmp++] = '.';", "       szTmp[iTmp++] = '*';", "       szTmp[iTmp] = '\\0';", "     }", "   }", "   szTmp[iTmp] = '/';", "   szTmp[++iTmp] = '\\0';", "   strlcat(szBuffer, szTmp, bufferSize);", "   strlcat(szBuffer, \")\", bufferSize);", "   return msStrdup(szBuffer);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" flac_buffer_copy (SF_PRIVATE *psf)", " {\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;", " \tconst FLAC__Frame *frame = pflac->frame ;", " \tconst int32_t* const *buffer = pflac->wbuffer ;", " \tunsigned i = 0, j, offset, channels, len ;", " \tif (frame->header.blocksize > FLAC__MAX_BLOCK_SIZE)", " \t{\tpsf_log_printf (psf, \"Ooops : frame->header.blocksize (%d) > FLAC__MAX_BLOCK_SIZE (%d)\\n\", __func__, __LINE__, frame->header.blocksize, FLAC__MAX_BLOCK_SIZE) ;", " \t\tpsf->error = SFE_INTERNAL ;", " \t\treturn 0 ;", " \t\t} ;", " \tif (frame->header.channels > FLAC__MAX_CHANNELS)", " \t\tpsf_log_printf (psf, \"Ooops : frame->header.channels (%d) > FLAC__MAX_BLOCK_SIZE (%d)\\n\", __func__, __LINE__, frame->header.channels, FLAC__MAX_CHANNELS) ;", " \tchannels = SF_MIN (frame->header.channels, FLAC__MAX_CHANNELS) ;", "  \tif (pflac->ptr == NULL)", "  \t{\t ", "\t\tpflac->bufferbackup = SF_TRUE ;", "  \t\tfor (i = 0 ; i < channels ; i++)", "  \t\t{", "  \t\t\tif (pflac->rbuffer [i] == NULL)", " \t\t\t\tpflac->rbuffer [i] = calloc (FLAC__MAX_BLOCK_SIZE, sizeof (int32_t)) ;", " \t\t\tmemcpy (pflac->rbuffer [i], buffer [i], frame->header.blocksize * sizeof (int32_t)) ;", " \t\t\t} ;", " \t\tpflac->wbuffer = (const int32_t* const*) pflac->rbuffer ;", " \t\treturn 0 ;", " \t\t} ;", "  \tlen = SF_MIN (pflac->len, frame->header.blocksize) ;", " \tif (pflac->remain % channels != 0)", " \t{\tpsf_log_printf (psf, \"Error: pflac->remain %u    channels %u\\n\", pflac->remain, channels) ;", " \t\treturn 0 ;", " \t\t} ;", "  \tswitch (pflac->pcmtype)", "  \t{\tcase PFLAC_PCM_SHORT :", "  \t\t\t{\tshort *retpcm = (short*) pflac->ptr ;", " \t\t\t\tint shift = 16 - frame->header.bits_per_sample ;", " \t\t\t\tif (shift < 0)", " \t\t\t\t{\tshift = abs (shift) ;", " \t\t\t\t\tfor (i = 0 ; i < len && pflac->remain > 0 ; i++)", " \t\t\t\t\t{\toffset = pflac->pos + i * channels ;", " \t\t\t\t\t\tif (pflac->bufferpos >= frame->header.blocksize)", " \t\t\t\t\t\t\tbreak ;", " \t\t\t\t\t\tif (offset + channels > pflac->len)", " \t\t\t\t\t\t\tbreak ;", " \t\t\t\t\t\tfor (j = 0 ; j < channels ; j++)", " \t\t\t\t\t\t\tretpcm [offset + j] = buffer [j][pflac->bufferpos] >> shift ;", " \t\t\t\t\t\tpflac->remain -= channels ;", " \t\t\t\t\t\tpflac->bufferpos++ ;", " \t\t\t\t\t\t}", " \t\t\t\t\t}", " \t\t\t\telse", " \t\t\t\t{\tfor (i = 0 ; i < len && pflac->remain > 0 ; i++)", " \t\t\t\t\t{\toffset = pflac->pos + i * channels ;", " \t\t\t\t\t\tif (pflac->bufferpos >= frame->header.blocksize)", " \t\t\t\t\t\t\tbreak ;", " \t\t\t\t\t\tif (offset + channels > pflac->len)", " \t\t\t\t\t\t\tbreak ;", " \t\t\t\t\t\tfor (j = 0 ; j < channels ; j++)", " \t\t\t\t\t\t\tretpcm [offset + j] = ((uint16_t) buffer [j][pflac->bufferpos]) << shift ;", " \t\t\t\t\t\tpflac->remain -= channels ;", " \t\t\t\t\t\tpflac->bufferpos++ ;", " \t\t\t\t\t\t} ;", " \t\t\t\t\t} ;", " \t\t\t\t} ;", " \t\t\tbreak ;", " \t\tcase PFLAC_PCM_INT :", " \t\t\t{\tint *retpcm = (int*) pflac->ptr ;", " \t\t\t\tint shift = 32 - frame->header.bits_per_sample ;", " \t\t\t\tfor (i = 0 ; i < len && pflac->remain > 0 ; i++)", " \t\t\t\t{\toffset = pflac->pos + i * channels ;", " \t\t\t\t\tif (pflac->bufferpos >= frame->header.blocksize)", " \t\t\t\t\t\tbreak ;", " \t\t\t\t\tif (offset + channels > pflac->len)", " \t\t\t\t\t\tbreak ;", " \t\t\t\t\tfor (j = 0 ; j < channels ; j++)", " \t\t\t\t\t\tretpcm [offset + j] = ((uint32_t) buffer [j][pflac->bufferpos]) << shift ;", " \t\t\t\t\tpflac->remain -= channels ;", " \t\t\t\t\tpflac->bufferpos++ ;", " \t\t\t\t\t} ;", " \t\t\t\t} ;", " \t\t\tbreak ;", " \t\tcase PFLAC_PCM_FLOAT :", " \t\t\t{\tfloat *retpcm = (float*) pflac->ptr ;", " \t\t\t\tfloat norm = (psf->norm_float == SF_TRUE) ? 1.0 / (1 << (frame->header.bits_per_sample - 1)) : 1.0 ;", " \t\t\t\tfor (i = 0 ; i < len && pflac->remain > 0 ; i++)", " \t\t\t\t{\toffset = pflac->pos + i * channels ;", " \t\t\t\t\tif (pflac->bufferpos >= frame->header.blocksize)", " \t\t\t\t\t\tbreak ;", " \t\t\t\t\tif (offset + channels > pflac->len)", " \t\t\t\t\t\tbreak ;", " \t\t\t\t\tfor (j = 0 ; j < channels ; j++)", " \t\t\t\t\t\tretpcm [offset + j] = buffer [j][pflac->bufferpos] * norm ;", " \t\t\t\t\tpflac->remain -= channels ;", " \t\t\t\t\tpflac->bufferpos++ ;", " \t\t\t\t\t} ;", " \t\t\t\t} ;", " \t\t\tbreak ;", " \t\tcase PFLAC_PCM_DOUBLE :", " \t\t\t{\tdouble *retpcm = (double*) pflac->ptr ;", " \t\t\t\tdouble norm = (psf->norm_double == SF_TRUE) ? 1.0 / (1 << (frame->header.bits_per_sample - 1)) : 1.0 ;", " \t\t\t\tfor (i = 0 ; i < len && pflac->remain > 0 ; i++)", " \t\t\t\t{\toffset = pflac->pos + i * channels ;", " \t\t\t\t\tif (pflac->bufferpos >= frame->header.blocksize)", " \t\t\t\t\t\tbreak ;", " \t\t\t\t\tif (offset + channels > pflac->len)", " \t\t\t\t\t\tbreak ;", " \t\t\t\t\tfor (j = 0 ; j < channels ; j++)", " \t\t\t\t\t\tretpcm [offset + j] = buffer [j][pflac->bufferpos] * norm ;", " \t\t\t\t\tpflac->remain -= channels ;", " \t\t\t\t\tpflac->bufferpos++ ;", " \t\t\t\t\t} ;", " \t\t\t\t} ;", " \t\t\tbreak ;", " \t\tdefault :", " \t\t\treturn 0 ;", " \t\t} ;", " \toffset = i * channels ;", " \tpflac->pos += i * channels ;", " \treturn offset ;", " }  "], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int jpc_qcd_dumpparms(jpc_ms_t *ms, FILE *out)", " {", " \tjpc_qcd_t *qcd = &ms->parms.qcd;", " \tint i;", " \tfprintf(out, \"qntsty = %d; numguard = %d; numstepsizes = %d\\n\",", "  \t  (int) qcd->compparms.qntsty, qcd->compparms.numguard, qcd->compparms.numstepsizes);", "  \tfor (i = 0; i < qcd->compparms.numstepsizes; ++i) {", "  \t\tfprintf(out, \"expn[%d] = 0x%04x; mant[%d] = 0x%04x;\\n\",", "\t\t  i, (unsigned) JPC_QCX_GETEXPN(qcd->compparms.stepsizes[i]),", "\t\t  i, (unsigned) JPC_QCX_GETMANT(qcd->compparms.stepsizes[i]));", " \t\t  i, JAS_CAST(unsigned, JPC_QCX_GETEXPN(qcd->compparms.stepsizes[i])),", " \t\t  i, JAS_CAST(unsigned, JPC_QCX_GETMANT(qcd->compparms.stepsizes[i])));", "  \t}", "  \treturn 0;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": [" atol8(const char *p, size_t char_cnt)", "  {", "  \tint64_t l;", "  \tint digit;", " \tif (char_cnt == 0)", " \t\treturn (0);", "  \tl = 0;", "  \twhile (char_cnt-- > 0) {", "  \t\tif (*p >= '0' && *p <= '7')", " \t\t\tdigit = *p - '0';", " \t\telse", " \t\t\tbreak;", " \t\tp++;", " \t\tl <<= 3;", " \t\tl |= digit;", " \t}", " \treturn (l);", " }"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" process_secondary_order(STREAM s)", " {", " \tuint16 length;", "  \tuint16 flags;", "  \tuint8 type;", "  \tuint8 *next_order;", " \tstruct stream packet = *s;", "  \tin_uint16_le(s, length);", "  \tin_uint16_le(s, flags);\t ", "  \tin_uint8(s, type);", " \tif (!s_check_rem(s, length + 7))", " \t{", " \t\trdp_protocol_error(\"process_secondary_order(), next order pointer would overrun stream\", &packet);", " \t}", "  \tnext_order = s->p + (sint16) length + 7;", "  \tswitch (type)", " \t{", " \t\tcase RDP_ORDER_RAW_BMPCACHE:", " \t\t\tprocess_raw_bmpcache(s);", " \t\t\tbreak;", " \t\tcase RDP_ORDER_COLCACHE:", " \t\t\tprocess_colcache(s);", " \t\t\tbreak;", " \t\tcase RDP_ORDER_BMPCACHE:", " \t\t\tprocess_bmpcache(s);", " \t\t\tbreak;", " \t\tcase RDP_ORDER_FONTCACHE:", " \t\t\tprocess_fontcache(s);", " \t\t\tbreak;", " \t\tcase RDP_ORDER_RAW_BMPCACHE2:", " \t\t\tprocess_bmpcache2(s, flags, False);\t ", " \t\t\tbreak;", " \t\tcase RDP_ORDER_BMPCACHE2:", " \t\t\tprocess_bmpcache2(s, flags, True);\t ", " \t\t\tbreak;", " \t\tcase RDP_ORDER_BRUSHCACHE:", " \t\t\tprocess_brushcache(s, flags);", " \t\t\tbreak;", " \t\tdefault:", " \t\t\tlogger(Graphics, Warning,", " \t\t\t       \"process_secondary_order(), unhandled secondary order %d\", type);", " \t}", " \ts->p = next_order;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int jpc_enc_encodemainhdr(jpc_enc_t *enc)", " {", " \tjpc_siz_t *siz;", " \tjpc_cod_t *cod;", " \tjpc_qcd_t *qcd;", " \tint i;", " long startoff;", " long mainhdrlen;", " \tjpc_enc_cp_t *cp;", " \tjpc_qcc_t *qcc;", " \tjpc_enc_tccp_t *tccp;", " \tuint_fast16_t cmptno;", " \tjpc_tsfb_band_t bandinfos[JPC_MAXBANDS];", " \tjpc_fix_t mctsynweight;", " \tjpc_enc_tcp_t *tcp;", " \tjpc_tsfb_t *tsfb;", " \tjpc_tsfb_band_t *bandinfo;", " \tuint_fast16_t numbands;", " \tuint_fast16_t bandno;", " \tuint_fast16_t rlvlno;", " \tuint_fast16_t analgain;", " \tjpc_fix_t absstepsize;", " \tchar buf[1024];", " \tjpc_com_t *com;", " \tcp = enc->cp;", " startoff = jas_stream_getrwcount(enc->out);", " \tif (!(enc->mrk = jpc_ms_create(JPC_MS_SOC))) {", " \t\treturn -1;", " \t}", " \tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {", " \t\tjas_eprintf(\"cannot write SOC marker\\n\");", " \t\treturn -1;", " \t}", " \tjpc_ms_destroy(enc->mrk);", " \tenc->mrk = 0;", " \tif (!(enc->mrk = jpc_ms_create(JPC_MS_SIZ))) {", " \t\treturn -1;", " \t}", " \tsiz = &enc->mrk->parms.siz;", " \tsiz->caps = 0;", " \tsiz->xoff = cp->imgareatlx;", " \tsiz->yoff = cp->imgareatly;", " \tsiz->width = cp->refgrdwidth;", " \tsiz->height = cp->refgrdheight;", " \tsiz->tilexoff = cp->tilegrdoffx;", " \tsiz->tileyoff = cp->tilegrdoffy;", " \tsiz->tilewidth = cp->tilewidth;", " \tsiz->tileheight = cp->tileheight;", " \tsiz->numcomps = cp->numcmpts;", " \tsiz->comps = jas_alloc2(siz->numcomps, sizeof(jpc_sizcomp_t));", " \tassert(siz->comps);", " \tfor (i = 0; i < JAS_CAST(int, cp->numcmpts); ++i) {", " \t\tsiz->comps[i].prec = cp->ccps[i].prec;", " \t\tsiz->comps[i].sgnd = cp->ccps[i].sgnd;", " \t\tsiz->comps[i].hsamp = cp->ccps[i].sampgrdstepx;", " \t\tsiz->comps[i].vsamp = cp->ccps[i].sampgrdstepy;", " \t}", " \tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {", " \t\tjas_eprintf(\"cannot write SIZ marker\\n\");", " \t\treturn -1;", " \t}", " \tjpc_ms_destroy(enc->mrk);", " \tenc->mrk = 0;", " \tif (!(enc->mrk = jpc_ms_create(JPC_MS_COM))) {", " \t\treturn -1;", " \t}", " \tsprintf(buf, \"Creator: JasPer Version %s\", jas_getversion());", "  \tcom = &enc->mrk->parms.com;", "  \tcom->len = JAS_CAST(uint_fast16_t, strlen(buf));", "  \tcom->regid = JPC_COM_LATIN;", "\tif (!(com->data = JAS_CAST(uchar *, jas_strdup(buf)))) {", " \tif (!(com->data = JAS_CAST(jas_uchar *, jas_strdup(buf)))) {", "  \t\tabort();", "  \t}", "  \tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {", " \t\tjas_eprintf(\"cannot write COM marker\\n\");", " \t\treturn -1;", " \t}", " \tjpc_ms_destroy(enc->mrk);", " \tenc->mrk = 0;", " #if 0", " \tif (!(enc->mrk = jpc_ms_create(JPC_MS_CRG))) {", " \t\treturn -1;", " \t}", " \tcrg = &enc->mrk->parms.crg;", " \tcrg->comps = jas_alloc2(crg->numcomps, sizeof(jpc_crgcomp_t));", " \tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {", " \t\tjas_eprintf(\"cannot write CRG marker\\n\");", " \t\treturn -1;", " \t}", " \tjpc_ms_destroy(enc->mrk);", " \tenc->mrk = 0;", " #endif", " \ttcp = &cp->tcp;", " \ttccp = &cp->tccp;", " \tfor (cmptno = 0; cmptno < cp->numcmpts; ++cmptno) {", " \t\ttsfb = jpc_cod_gettsfb(tccp->qmfbid, tccp->maxrlvls - 1);", " \t\tjpc_tsfb_getbands(tsfb, 0, 0, 1 << tccp->maxrlvls, 1 << tccp->maxrlvls,", " \t\t  bandinfos);", " \t\tjpc_tsfb_destroy(tsfb);", " \t\tmctsynweight = jpc_mct_getsynweight(tcp->mctid, cmptno);", " \t\tnumbands = 3 * tccp->maxrlvls - 2;", " \t\tfor (bandno = 0, bandinfo = bandinfos; bandno < numbands;", " \t\t  ++bandno, ++bandinfo) {", " \t\t\trlvlno = (bandno) ? ((bandno - 1) / 3 + 1) : 0;", " \t\t\tanalgain = JPC_NOMINALGAIN(tccp->qmfbid, tccp->maxrlvls,", " \t\t\t  rlvlno, bandinfo->orient);", " \t\t\tif (!tcp->intmode) {", " \t\t\t\tabsstepsize = jpc_fix_div(jpc_inttofix(1 <<", " \t\t\t\t  (analgain + 1)), bandinfo->synenergywt);", " \t\t\t} else {", " \t\t\t\tabsstepsize = jpc_inttofix(1);", " \t\t\t}\t", " \t\t\tcp->ccps[cmptno].stepsizes[bandno] =", " \t\t\t  jpc_abstorelstepsize(absstepsize,", " \t\t\t  cp->ccps[cmptno].prec + analgain);", " \t\t}", " \t\tcp->ccps[cmptno].numstepsizes = numbands;", " \t}", " \tif (!(enc->mrk = jpc_ms_create(JPC_MS_COD))) {", " \t\treturn -1;", " \t}", " \tcod = &enc->mrk->parms.cod;", " \tcod->csty = cp->tccp.csty | cp->tcp.csty;", " \tcod->compparms.csty = cp->tccp.csty | cp->tcp.csty;", " \tcod->compparms.numdlvls = cp->tccp.maxrlvls - 1;", " \tcod->compparms.numrlvls = cp->tccp.maxrlvls;", " \tcod->prg = cp->tcp.prg;", " \tcod->numlyrs = cp->tcp.numlyrs;", " \tcod->compparms.cblkwidthval = JPC_COX_CBLKSIZEEXPN(cp->tccp.cblkwidthexpn);", " \tcod->compparms.cblkheightval = JPC_COX_CBLKSIZEEXPN(cp->tccp.cblkheightexpn);", " \tcod->compparms.cblksty = cp->tccp.cblksty;", " \tcod->compparms.qmfbid = cp->tccp.qmfbid;", " \tcod->mctrans = (cp->tcp.mctid != JPC_MCT_NONE);", " \tif (tccp->csty & JPC_COX_PRT) {", " \t\tfor (rlvlno = 0; rlvlno < tccp->maxrlvls; ++rlvlno) {", " \t\t\tcod->compparms.rlvls[rlvlno].parwidthval = tccp->prcwidthexpns[rlvlno];", " \t\t\tcod->compparms.rlvls[rlvlno].parheightval = tccp->prcheightexpns[rlvlno];", " \t\t}", " \t}", " \tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {", " \t\tjas_eprintf(\"cannot write COD marker\\n\");", " \t\treturn -1;", " \t}", " \tjpc_ms_destroy(enc->mrk);", " \tenc->mrk = 0;", " \tif (!(enc->mrk = jpc_ms_create(JPC_MS_QCD))) {", " \t\treturn -1;", " \t}", " \tqcd = &enc->mrk->parms.qcd;", " \tqcd->compparms.qntsty = (tccp->qmfbid == JPC_COX_INS) ?", " \t  JPC_QCX_SEQNT : JPC_QCX_NOQNT;", " \tqcd->compparms.numstepsizes = cp->ccps[0].numstepsizes;", " \tqcd->compparms.numguard = cp->tccp.numgbits;", " \tqcd->compparms.stepsizes = cp->ccps[0].stepsizes;", " \tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {", " \t\treturn -1;", " \t}", " \tqcd->compparms.stepsizes = 0;", " \tjpc_ms_destroy(enc->mrk);", " \tenc->mrk = 0;", " \ttccp = &cp->tccp;", " \tfor (cmptno = 1; cmptno < cp->numcmpts; ++cmptno) {", " \t\tif (!(enc->mrk = jpc_ms_create(JPC_MS_QCC))) {", " \t\t\treturn -1;", " \t\t}", " \t\tqcc = &enc->mrk->parms.qcc;", " \t\tqcc->compno = cmptno;", " \t\tqcc->compparms.qntsty = (tccp->qmfbid == JPC_COX_INS) ?", " \t\t  JPC_QCX_SEQNT : JPC_QCX_NOQNT;", " \t\tqcc->compparms.numstepsizes = cp->ccps[cmptno].numstepsizes;", " \t\tqcc->compparms.numguard = cp->tccp.numgbits;", " \t\tqcc->compparms.stepsizes = cp->ccps[cmptno].stepsizes;", " \t\tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {", " \t\t\treturn -1;", " \t\t}", " \t\tqcc->compparms.stepsizes = 0;", " \t\tjpc_ms_destroy(enc->mrk);", " \t\tenc->mrk = 0;", " \t}", " #define MAINTLRLEN\t2", " \tmainhdrlen = jas_stream_getrwcount(enc->out) - startoff;", " \tenc->len += mainhdrlen;", " \tif (enc->cp->totalsize != UINT_FAST32_MAX) {", " \t\tuint_fast32_t overhead;", " \t\toverhead = mainhdrlen + MAINTLRLEN;", " \t\tenc->mainbodysize = (enc->cp->totalsize >= overhead) ?", " \t\t  (enc->cp->totalsize - overhead) : 0;", " \t} else {", " \t\tenc->mainbodysize = UINT_FAST32_MAX;", " \t}", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static char *escape_pathname(const char *inp)", " {", "     const unsigned char *s;", "     char *escaped, *d;", "     if (!inp) {", "         return NULL;", "      }", "      escaped = malloc (4 * strlen(inp) + 1);", "      if (!escaped) {", "    \tperror(\"malloc\");", "\treturn NULL;", " \t\tperror(\"malloc\");", " \t\treturn NULL;", "      }", "      for (d = escaped, s = (const unsigned char *)inp; *s; s++) {", "          if (needs_escape (*s)) {", "             snprintf (d, 5, \"\\\\x%02x\", *s);", "             d += strlen (d);", "         } else {", "             *d++ = *s;", "         }", "     }", "     *d++ = '\\0';", "     return escaped;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static pfunc check_literal(struct jv_parser* p) {", "   if (p->tokenpos == 0) return 0;", "   const char* pattern = 0;", "   int plen;", "   jv v;", "   switch (p->tokenbuf[0]) {", "   case 't': pattern = \"true\"; plen = 4; v = jv_true(); break;", "   case 'f': pattern = \"false\"; plen = 5; v = jv_false(); break;", "   case 'n': pattern = \"null\"; plen = 4; v = jv_null(); break;", "   }", "   if (pattern) {", "     if (p->tokenpos != plen) return \"Invalid literal\";", "     for (int i=0; i<plen; i++)", "       if (p->tokenbuf[i] != pattern[i])", "         return \"Invalid literal\";", "      TRY(value(p, v));", "    } else {", "    p->tokenbuf[p->tokenpos] = 0;  ", "     p->tokenbuf[p->tokenpos] = 0;", "      char* end = 0;", "      double d = jvp_strtod(&p->dtoa, p->tokenbuf, &end);", "      if (end == 0 || *end != 0)", "       return \"Invalid numeric literal\";", "     TRY(value(p, jv_number(d)));", "   }", "   p->tokenpos = 0;", "   return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" read_SubStreamsInfo(struct archive_read *a, struct _7z_substream_info *ss,", "     struct _7z_folder *f, size_t numFolders)", " {", " \tconst unsigned char *p;", " \tuint64_t *usizes;", " \tsize_t unpack_streams;", " \tint type;", " \tunsigned i;", " \tuint32_t numDigests;", " \tmemset(ss, 0, sizeof(*ss));", " \tfor (i = 0; i < numFolders; i++)", " \t\tf[i].numUnpackStreams = 1;", " \tif ((p = header_bytes(a, 1)) == NULL)", " \t\treturn (-1);", " \ttype = *p;", " \tif (type == kNumUnPackStream) {", " \t\tunpack_streams = 0;", " \t\tfor (i = 0; i < numFolders; i++) {", " \t\t\tif (parse_7zip_uint64(a, &(f[i].numUnpackStreams)) < 0)", "  \t\t\t\treturn (-1);", "  \t\t\tif (UMAX_ENTRY < f[i].numUnpackStreams)", "  \t\t\t\treturn (-1);", " \t\t\tif (unpack_streams > SIZE_MAX - UMAX_ENTRY) {", " \t\t\t\treturn (-1);", " \t\t\t}", "  \t\t\tunpack_streams += (size_t)f[i].numUnpackStreams;", "  \t\t}", "  \t\tif ((p = header_bytes(a, 1)) == NULL)", " \t\t\treturn (-1);", " \t\ttype = *p;", " \t} else", " \t\tunpack_streams = numFolders;", " \tss->unpack_streams = unpack_streams;", " \tif (unpack_streams) {", " \t\tss->unpackSizes = calloc(unpack_streams,", " \t\t    sizeof(*ss->unpackSizes));", " \t\tss->digestsDefined = calloc(unpack_streams,", " \t\t    sizeof(*ss->digestsDefined));", " \t\tss->digests = calloc(unpack_streams,", " \t\t    sizeof(*ss->digests));", " \t\tif (ss->unpackSizes == NULL || ss->digestsDefined == NULL ||", " \t\t    ss->digests == NULL)", " \t\t\treturn (-1);", " \t}", " \tusizes = ss->unpackSizes;", " \tfor (i = 0; i < numFolders; i++) {", " \t\tunsigned pack;", " \t\tuint64_t sum;", " \t\tif (f[i].numUnpackStreams == 0)", " \t\t\tcontinue;", " \t\tsum = 0;", " \t\tif (type == kSize) {", " \t\t\tfor (pack = 1; pack < f[i].numUnpackStreams; pack++) {", " \t\t\t\tif (parse_7zip_uint64(a, usizes) < 0)", " \t\t\t\t\treturn (-1);", " \t\t\t\tsum += *usizes++;", " \t\t\t}", " \t\t}", " \t\t*usizes++ = folder_uncompressed_size(&f[i]) - sum;", " \t}", " \tif (type == kSize) {", " \t\tif ((p = header_bytes(a, 1)) == NULL)", " \t\t\treturn (-1);", " \t\ttype = *p;", " \t}", " \tfor (i = 0; i < unpack_streams; i++) {", " \t\tss->digestsDefined[i] = 0;", " \t\tss->digests[i] = 0;", " \t}", " \tnumDigests = 0;", " \tfor (i = 0; i < numFolders; i++) {", " \t\tif (f[i].numUnpackStreams != 1 || !f[i].digest_defined)", " \t\t\tnumDigests += (uint32_t)f[i].numUnpackStreams;", " \t}", " \tif (type == kCRC) {", " \t\tstruct _7z_digests tmpDigests;", " \t\tunsigned char *digestsDefined = ss->digestsDefined;", " \t\tuint32_t * digests = ss->digests;", " \t\tint di = 0;", " \t\tmemset(&tmpDigests, 0, sizeof(tmpDigests));", " \t\tif (read_Digests(a, &(tmpDigests), numDigests) < 0) {", " \t\t\tfree_Digest(&tmpDigests);", " \t\t\treturn (-1);", " \t\t}", " \t\tfor (i = 0; i < numFolders; i++) {", " \t\t\tif (f[i].numUnpackStreams == 1 && f[i].digest_defined) {", " \t\t\t\t*digestsDefined++ = 1;", " \t\t\t\t*digests++ = f[i].digest;", " \t\t\t} else {", " \t\t\t\tunsigned j;", " \t\t\t\tfor (j = 0; j < f[i].numUnpackStreams;", " \t\t\t\t    j++, di++) {", " \t\t\t\t\t*digestsDefined++ =", " \t\t\t\t\t    tmpDigests.defineds[di];", " \t\t\t\t\t*digests++ =", " \t\t\t\t\t    tmpDigests.digests[di];", " \t\t\t\t}", " \t\t\t}", " \t\t}", " \t\tfree_Digest(&tmpDigests);", " \t\tif ((p = header_bytes(a, 1)) == NULL)", " \t\t\treturn (-1);", " \t\ttype = *p;", " \t}", " \tif (type != kEnd)", " \t\treturn (-1);", " \treturn (0);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void jp2_box_dump(jp2_box_t *box, FILE *out)", " {", " \tjp2_boxinfo_t *boxinfo;", " \tboxinfo = jp2_boxinfolookup(box->type);", "  \tassert(boxinfo);", "  \tfprintf(out, \"JP2 box: \");", "\tfprintf(out, \"type=%c%s%c (0x%08\"PRIxFAST32\"); length=%\"PRIuFAST32\"\\n\", '\"', boxinfo->name,", "\t  '\"', box->type, box->len);", " \tfprintf(out, \"type=%c%s%c (0x%08\"PRIxFAST32\"); length=%\"PRIuFAST32\"\\n\", '\"',", " \t  boxinfo->name, '\"', box->type, box->len);", "  \tif (box->ops->dumpdata) {", "  \t\t(*box->ops->dumpdata)(box, out);", "  \t}", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": ["  int pgx_validate(jas_stream_t *in)", "  {", "\tuchar buf[PGX_MAGICLEN];", " \tjas_uchar buf[PGX_MAGICLEN];", "  \tuint_fast32_t magic;", "  \tint i;", "  \tint n;", " \tassert(JAS_STREAM_MAXPUTBACK >= PGX_MAGICLEN);", " \tif ((n = jas_stream_read(in, buf, PGX_MAGICLEN)) < 0) {", " \t\treturn -1;", " \t}", " \tfor (i = n - 1; i >= 0; --i) {", " \t\tif (jas_stream_ungetc(in, buf[i]) == EOF) {", " \t\t\treturn -1;", " \t\t}", " \t}", " \tif (n < PGX_MAGICLEN) {", " \t\treturn -1;", " \t}", " \tmagic = (buf[0] << 8) | buf[1];", " \tif (magic != PGX_MAGIC) {", " \t\treturn -1;", " \t}", " \treturn 0;", " }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void read_boot(DOS_FS * fs)", " {", "      struct boot_sector b;", "      unsigned total_sectors;", "      unsigned short logical_sector_size, sectors;", "    unsigned fat_length;", "     off_t fat_length;", "      unsigned total_fat_entries;", "      off_t data_size;", "     fs_read(0, sizeof(b), &b);", "     logical_sector_size = GET_UNALIGNED_W(b.sector_size);", "     if (!logical_sector_size)", " \tdie(\"Logical sector size is zero.\");", "     if (logical_sector_size & (SECTOR_SIZE - 1))", " \tdie(\"Logical sector size (%d bytes) is not a multiple of the physical \"", " \t    \"sector size.\", logical_sector_size);", "     fs->cluster_size = b.cluster_size * logical_sector_size;", "     if (!fs->cluster_size)", " \tdie(\"Cluster size is zero.\");", "     if (b.fats != 2 && b.fats != 1)", " \tdie(\"Currently, only 1 or 2 FATs are supported, not %d.\\n\", b.fats);", "     fs->nfats = b.fats;", "     sectors = GET_UNALIGNED_W(b.sectors);", "     total_sectors = sectors ? sectors : le32toh(b.total_sect);", "     if (verbose)", " \tprintf(\"Checking we can access the last sector of the filesystem\\n\");", "      fs_test((off_t)((total_sectors & ~1) - 1) * logical_sector_size,", "  \t    logical_sector_size);", "      fat_length = le16toh(b.fat_length) ?", "  \tle16toh(b.fat_length) : le32toh(b.fat32_length);", "     if (!fat_length)", " \tdie(\"FAT size is zero.\");", "      fs->fat_start = (off_t)le16toh(b.reserved) * logical_sector_size;", "      fs->root_start = ((off_t)le16toh(b.reserved) + b.fats * fat_length) *", "  \tlogical_sector_size;", "      fs->root_entries = GET_UNALIGNED_W(b.dir_entries);", "      fs->data_start = fs->root_start + ROUND_TO_MULTIPLE(fs->root_entries <<", "  \t\t\t\t\t\t\tMSDOS_DIR_BITS,", "  \t\t\t\t\t\t\tlogical_sector_size);", "      data_size = (off_t)total_sectors * logical_sector_size - fs->data_start;", "     if (data_size < fs->cluster_size)", " \tdie(\"Filesystem has no space for any data clusters\");", "      fs->data_clusters = data_size / fs->cluster_size;", "      fs->root_cluster = 0;\t ", "      fs->fsinfo_start = 0;\t ", "     fs->free_clusters = -1;\t ", "     if (!b.fat_length && b.fat32_length) {", " \tfs->fat_bits = 32;", " \tfs->root_cluster = le32toh(b.root_cluster);", " \tif (!fs->root_cluster && fs->root_entries)", " \t    printf(\"Warning: FAT32 root dir not in cluster chain! \"", " \t\t   \"Compatibility mode...\\n\");", " \telse if (!fs->root_cluster && !fs->root_entries)", " \t    die(\"No root directory!\");", " \telse if (fs->root_cluster && fs->root_entries)", " \t    printf(\"Warning: FAT32 root dir is in a cluster chain, but \"", " \t\t   \"a separate root dir\\n\"", " \t\t   \"  area is defined. Cannot fix this easily.\\n\");", " \tif (fs->data_clusters < FAT16_THRESHOLD)", " \t    printf(\"Warning: Filesystem is FAT32 according to fat_length \"", " \t\t   \"and fat32_length fields,\\n\"", " \t\t   \"  but has only %lu clusters, less than the required \"", " \t\t   \"minimum of %d.\\n\"", " \t\t   \"  This may lead to problems on some systems.\\n\",", " \t\t   (unsigned long)fs->data_clusters, FAT16_THRESHOLD);", " \tcheck_fat_state_bit(fs, &b);", " \tfs->backupboot_start = le16toh(b.backup_boot) * logical_sector_size;", " \tcheck_backup_boot(fs, &b, logical_sector_size);", " \tread_fsinfo(fs, &b, logical_sector_size);", "     } else if (!atari_format) {", " \tfs->fat_bits = (fs->data_clusters >= FAT12_THRESHOLD) ? 16 : 12;", " \tif (fs->data_clusters >= FAT16_THRESHOLD)", " \t    die(\"Too many clusters (%lu) for FAT16 filesystem.\", fs->data_clusters);", " \tcheck_fat_state_bit(fs, &b);", "     } else {", " \tfs->fat_bits = 16;\t ", " \tif (fs->data_clusters + 2 > fat_length * logical_sector_size * 8 / 16 ||", " \t    (total_sectors == 720 || total_sectors == 1440 ||", " \t     total_sectors == 2880))", " \t    fs->fat_bits = 12;", "     }", "     fs->eff_fat_bits = (fs->fat_bits == 32) ? 28 : fs->fat_bits;", "     fs->fat_size = fat_length * logical_sector_size;", "     fs->label = calloc(12, sizeof(uint8_t));", "     if (fs->fat_bits == 12 || fs->fat_bits == 16) {", " \tstruct boot_sector_16 *b16 = (struct boot_sector_16 *)&b;", " \tif (b16->extended_sig == 0x29)", " \t    memmove(fs->label, b16->label, 11);", " \telse", " \t    fs->label = NULL;", "     } else if (fs->fat_bits == 32) {", " \tif (b.extended_sig == 0x29)", " \t    memmove(fs->label, &b.label, 11);", " \telse", " \t    fs->label = NULL;", "     }", "     total_fat_entries = (uint64_t)fs->fat_size * 8 / fs->fat_bits;", "     if (fs->data_clusters > total_fat_entries - 2)", " \tdie(\"Filesystem has %u clusters but only space for %u FAT entries.\",", " \t    fs->data_clusters, total_fat_entries - 2);", "     if (!fs->root_entries && !fs->root_cluster)", " \tdie(\"Root directory has zero size.\");", "     if (fs->root_entries & (MSDOS_DPS - 1))", " \tdie(\"Root directory (%d entries) doesn't span an integral number of \"", " \t    \"sectors.\", fs->root_entries);", "     if (logical_sector_size & (SECTOR_SIZE - 1))", " \tdie(\"Logical sector size (%d bytes) is not a multiple of the physical \"", " \t    \"sector size.\", logical_sector_size);", " #if 0\t\t\t\t ", "     if (!atari_format && (!b.secs_track || !b.heads))", " \tdie(\"Invalid disk format in boot sector.\");", " #endif", "     if (verbose)", " \tdump_boot(fs, &b, logical_sector_size);", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  int jas_matrix_cmp(jas_matrix_t *mat0, jas_matrix_t *mat1)", "  {", "\tint i;", "\tint j;", " \tjas_matind_t i;", " \tjas_matind_t j;", "  \tif (mat0->numrows_ != mat1->numrows_ || mat0->numcols_ !=", "  \t  mat1->numcols_) {", " \t\treturn 1;", " \t}", " \tfor (i = 0; i < mat0->numrows_; i++) {", " \t\tfor (j = 0; j < mat0->numcols_; j++) {", " \t\t\tif (jas_matrix_get(mat0, i, j) != jas_matrix_get(mat1, i, j)) {", " \t\t\t\treturn 1;", " \t\t\t}", " \t\t}", " \t}", " \treturn 0;", " }"], "ner_tags": [0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  findoprnd(ITEM *ptr, int32 *pos)", "  {", " \tcheck_stack_depth();", "  #ifdef BS_DEBUG", "  \telog(DEBUG3, (ptr[*pos].type == OPR) ?", "  \t\t \"%d  %c\" : \"%d  %d\", *pos, ptr[*pos].val);", " #endif", " \tif (ptr[*pos].type == VAL)", " \t{", " \t\tptr[*pos].left = 0;", " \t\t(*pos)--;", " \t}", " \telse if (ptr[*pos].val == (int32) '!')", " \t{", " \t\tptr[*pos].left = -1;", " \t\t(*pos)--;", " \t\tfindoprnd(ptr, pos);", " \t}", " \telse", " \t{", " \t\tITEM\t   *curitem = &ptr[*pos];", " \t\tint32\t\ttmp = *pos;", " \t\t(*pos)--;", " \t\tfindoprnd(ptr, pos);", " \t\tcuritem->left = *pos - tmp;", " \t\tfindoprnd(ptr, pos);", " \t}", " }"], "ner_tags": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms)", " {", " \tjpc_siz_t *siz = &ms->parms.siz;", " \tint compno;", " \tint tileno;", " \tjpc_dec_tile_t *tile;", " \tjpc_dec_tcomp_t *tcomp;", "  \tint htileno;", "  \tint vtileno;", "  \tjpc_dec_cmpt_t *cmpt;", " \tsize_t size;", "  \tdec->xstart = siz->xoff;", "  \tdec->ystart = siz->yoff;", " \tdec->xend = siz->width;", " \tdec->yend = siz->height;", " \tdec->tilewidth = siz->tilewidth;", " \tdec->tileheight = siz->tileheight;", " \tdec->tilexoff = siz->tilexoff;", " \tdec->tileyoff = siz->tileyoff;", " \tdec->numcomps = siz->numcomps;", " \tif (!(dec->cp = jpc_dec_cp_create(dec->numcomps))) {", " \t\treturn -1;", " \t}", " \tif (!(dec->cmpts = jas_alloc2(dec->numcomps, sizeof(jpc_dec_cmpt_t)))) {", " \t\treturn -1;", " \t}", " \tfor (compno = 0, cmpt = dec->cmpts; compno < dec->numcomps; ++compno,", " \t  ++cmpt) {", " \t\tcmpt->prec = siz->comps[compno].prec;", " \t\tcmpt->sgnd = siz->comps[compno].sgnd;", " \t\tcmpt->hstep = siz->comps[compno].hsamp;", " \t\tcmpt->vstep = siz->comps[compno].vsamp;", " \t\tcmpt->width = JPC_CEILDIV(dec->xend, cmpt->hstep) -", " \t\t  JPC_CEILDIV(dec->xstart, cmpt->hstep);", " \t\tcmpt->height = JPC_CEILDIV(dec->yend, cmpt->vstep) -", " \t\t  JPC_CEILDIV(dec->ystart, cmpt->vstep);", " \t\tcmpt->hsubstep = 0;", " \t\tcmpt->vsubstep = 0;", " \t}", " \tdec->image = 0;", "  \tdec->numhtiles = JPC_CEILDIV(dec->xend - dec->tilexoff, dec->tilewidth);", "  \tdec->numvtiles = JPC_CEILDIV(dec->yend - dec->tileyoff, dec->tileheight);", "\tdec->numtiles = dec->numhtiles * dec->numvtiles;", " \tif (!jas_safe_size_mul(dec->numhtiles, dec->numvtiles, &size)) {", " \t\treturn -1;", " \t}", " \tdec->numtiles = size;", "  \tJAS_DBGLOG(10, (\"numtiles = %d; numhtiles = %d; numvtiles = %d;\\n\",", "  \t  dec->numtiles, dec->numhtiles, dec->numvtiles));", "  \tif (!(dec->tiles = jas_alloc2(dec->numtiles, sizeof(jpc_dec_tile_t)))) {", " \t\treturn -1;", " \t}", " \tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,", " \t  ++tile) {", " \t\thtileno = tileno % dec->numhtiles;", " \t\tvtileno = tileno / dec->numhtiles;", " \t\ttile->realmode = 0;", " \t\ttile->state = JPC_TILE_INIT;", " \t\ttile->xstart = JAS_MAX(dec->tilexoff + htileno * dec->tilewidth,", " \t\t  dec->xstart);", " \t\ttile->ystart = JAS_MAX(dec->tileyoff + vtileno * dec->tileheight,", " \t\t  dec->ystart);", " \t\ttile->xend = JAS_MIN(dec->tilexoff + (htileno + 1) *", " \t\t  dec->tilewidth, dec->xend);", " \t\ttile->yend = JAS_MIN(dec->tileyoff + (vtileno + 1) *", " \t\t  dec->tileheight, dec->yend);", " \t\ttile->numparts = 0;", " \t\ttile->partno = 0;", " \t\ttile->pkthdrstream = 0;", " \t\ttile->pkthdrstreampos = 0;", " \t\ttile->pptstab = 0;", " \t\ttile->cp = 0;", " \t\ttile->pi = 0;", " \t\tif (!(tile->tcomps = jas_alloc2(dec->numcomps,", " \t\t  sizeof(jpc_dec_tcomp_t)))) {", " \t\t\treturn -1;", " \t\t}", " \t\tfor (compno = 0, cmpt = dec->cmpts, tcomp = tile->tcomps;", " \t\t  compno < dec->numcomps; ++compno, ++cmpt, ++tcomp) {", " \t\t\ttcomp->rlvls = 0;", " \t\t\ttcomp->numrlvls = 0;", " \t\t\ttcomp->data = 0;", " \t\t\ttcomp->xstart = JPC_CEILDIV(tile->xstart, cmpt->hstep);", " \t\t\ttcomp->ystart = JPC_CEILDIV(tile->ystart, cmpt->vstep);", " \t\t\ttcomp->xend = JPC_CEILDIV(tile->xend, cmpt->hstep);", " \t\t\ttcomp->yend = JPC_CEILDIV(tile->yend, cmpt->vstep);", " \t\t\ttcomp->tsfb = 0;", " \t\t}", " \t}", " \tdec->pkthdrstreams = 0;", " \tdec->state = JPC_MH;", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int jpc_siz_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate,", "   jas_stream_t *in)", " {", " \tjpc_siz_t *siz = &ms->parms.siz;", " \tunsigned int i;", " \tuint_fast8_t tmp;", " \tcstate = 0;", " \tif (jpc_getuint16(in, &siz->caps) ||", " \t  jpc_getuint32(in, &siz->width) ||", " \t  jpc_getuint32(in, &siz->height) ||", " \t  jpc_getuint32(in, &siz->xoff) ||", " \t  jpc_getuint32(in, &siz->yoff) ||", " \t  jpc_getuint32(in, &siz->tilewidth) ||", " \t  jpc_getuint32(in, &siz->tileheight) ||", " \t  jpc_getuint32(in, &siz->tilexoff) ||", " \t  jpc_getuint32(in, &siz->tileyoff) ||", " \t  jpc_getuint16(in, &siz->numcomps)) {", " \t\treturn -1;", " \t}", " \tif (!siz->width || !siz->height || !siz->tilewidth ||", " \t  !siz->tileheight || !siz->numcomps) {", " \t\treturn -1;", " \t}", " \tif (!(siz->comps = jas_alloc2(siz->numcomps, sizeof(jpc_sizcomp_t)))) {", " \t\treturn -1;", " \t}", " \tfor (i = 0; i < siz->numcomps; ++i) {", " \t\tif (jpc_getuint8(in, &tmp) ||", " \t\t  jpc_getuint8(in, &siz->comps[i].hsamp) ||", " \t\t  jpc_getuint8(in, &siz->comps[i].vsamp)) {", "  \t\t\tjas_free(siz->comps);", "  \t\t\treturn -1;", "  \t\t}", " \t\tif (siz->comps[i].hsamp == 0 || siz->comps[i].hsamp > 255) {", " \t\t\tjas_eprintf(\"invalid XRsiz value %d\\n\", siz->comps[i].hsamp);", " \t\t\tjas_free(siz->comps);", " \t\t\treturn -1;", " \t\t}", " \t\tif (siz->comps[i].vsamp == 0 || siz->comps[i].vsamp > 255) {", " \t\t\tjas_eprintf(\"invalid YRsiz value %d\\n\", siz->comps[i].vsamp);", " \t\t\tjas_free(siz->comps);", " \t\t\treturn -1;", " \t\t}", "  \t\tsiz->comps[i].sgnd = (tmp >> 7) & 1;", "  \t\tsiz->comps[i].prec = (tmp & 0x7f) + 1;", "  \t}", " \tif (jas_stream_eof(in)) {", " \t\tjas_free(siz->comps);", " \t\treturn -1;", " \t}", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" parse_codes(struct archive_read *a)", " {", "   int i, j, val, n, r;", "   unsigned char bitlengths[MAX_SYMBOLS], zerocount, ppmd_flags;", "   unsigned int maxorder;", "   struct huffman_code precode;", "   struct rar *rar = (struct rar *)(a->format->data);", "   struct rar_br *br = &(rar->br);", "   free_codes(a);", "   rar_br_consume_unalined_bits(br);", "   if (!rar_br_read_ahead(a, br, 1))", "     goto truncated_data;", "   if ((rar->is_ppmd_block = rar_br_bits(br, 1)) != 0)", "   {", "     rar_br_consume(br, 1);", "     if (!rar_br_read_ahead(a, br, 7))", "       goto truncated_data;", "     ppmd_flags = rar_br_bits(br, 7);", "     rar_br_consume(br, 7);", "     if (ppmd_flags & 0x20)", "     {", "       if (!rar_br_read_ahead(a, br, 8))", "         goto truncated_data;", "       rar->dictionary_size = (rar_br_bits(br, 8) + 1) << 20;", "       rar_br_consume(br, 8);", "     }", "     if (ppmd_flags & 0x40)", "     {", "       if (!rar_br_read_ahead(a, br, 8))", "         goto truncated_data;", "       rar->ppmd_escape = rar->ppmd7_context.InitEsc = rar_br_bits(br, 8);", "       rar_br_consume(br, 8);", "     }", "     else", "       rar->ppmd_escape = 2;", "     if (ppmd_flags & 0x20)", "     {", "       maxorder = (ppmd_flags & 0x1F) + 1;", "       if(maxorder > 16)", "         maxorder = 16 + (maxorder - 16) * 3;", "       if (maxorder == 1)", "       {", "         archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", "                           \"Truncated RAR file data\");", "         return (ARCHIVE_FATAL);", "       }", "       __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context, &g_szalloc);", "       rar->bytein.a = a;", "       rar->bytein.Read = &ppmd_read;", "       __archive_ppmd7_functions.PpmdRAR_RangeDec_CreateVTable(&rar->range_dec);", "        rar->range_dec.Stream = &rar->bytein;", "        __archive_ppmd7_functions.Ppmd7_Construct(&rar->ppmd7_context);", "       if (rar->dictionary_size == 0) {", " \t      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", "                           \"Invalid zero dictionary size\");", " \t      return (ARCHIVE_FATAL);", "       }", "        if (!__archive_ppmd7_functions.Ppmd7_Alloc(&rar->ppmd7_context,", "          rar->dictionary_size, &g_szalloc))", "        {", "         archive_set_error(&a->archive, ENOMEM,", "                           \"Out of memory\");", "         return (ARCHIVE_FATAL);", "       }", "       if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec))", "       {", "         archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", "                           \"Unable to initialize PPMd range decoder\");", "         return (ARCHIVE_FATAL);", "       }", "       __archive_ppmd7_functions.Ppmd7_Init(&rar->ppmd7_context, maxorder);", "       rar->ppmd_valid = 1;", "     }", "     else", "     {", "       if (!rar->ppmd_valid) {", "         archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", "                           \"Invalid PPMd sequence\");", "         return (ARCHIVE_FATAL);", "       }", "       if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec))", "       {", "         archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", "                           \"Unable to initialize PPMd range decoder\");", "         return (ARCHIVE_FATAL);", "       }", "     }", "   }", "   else", "   {", "     rar_br_consume(br, 1);", "     if (!rar_br_read_ahead(a, br, 1))", "       goto truncated_data;", "     if (!rar_br_bits(br, 1))", "       memset(rar->lengthtable, 0, sizeof(rar->lengthtable));", "     rar_br_consume(br, 1);", "     memset(&bitlengths, 0, sizeof(bitlengths));", "     for (i = 0; i < MAX_SYMBOLS;)", "     {", "       if (!rar_br_read_ahead(a, br, 4))", "         goto truncated_data;", "       bitlengths[i++] = rar_br_bits(br, 4);", "       rar_br_consume(br, 4);", "       if (bitlengths[i-1] == 0xF)", "       {", "         if (!rar_br_read_ahead(a, br, 4))", "           goto truncated_data;", "         zerocount = rar_br_bits(br, 4);", "         rar_br_consume(br, 4);", "         if (zerocount)", "         {", "           i--;", "           for (j = 0; j < zerocount + 2 && i < MAX_SYMBOLS; j++)", "             bitlengths[i++] = 0;", "         }", "       }", "     }", "     memset(&precode, 0, sizeof(precode));", "     r = create_code(a, &precode, bitlengths, MAX_SYMBOLS, MAX_SYMBOL_LENGTH);", "     if (r != ARCHIVE_OK) {", "       free(precode.tree);", "       free(precode.table);", "       return (r);", "     }", "     for (i = 0; i < HUFFMAN_TABLE_SIZE;)", "     {", "       if ((val = read_next_symbol(a, &precode)) < 0) {", "         free(precode.tree);", "         free(precode.table);", "         return (ARCHIVE_FATAL);", "       }", "       if (val < 16)", "       {", "         rar->lengthtable[i] = (rar->lengthtable[i] + val) & 0xF;", "         i++;", "       }", "       else if (val < 18)", "       {", "         if (i == 0)", "         {", "           free(precode.tree);", "           free(precode.table);", "           archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", "                             \"Internal error extracting RAR file.\");", "           return (ARCHIVE_FATAL);", "         }", "         if(val == 16) {", "           if (!rar_br_read_ahead(a, br, 3)) {", "             free(precode.tree);", "             free(precode.table);", "             goto truncated_data;", "           }", "           n = rar_br_bits(br, 3) + 3;", "           rar_br_consume(br, 3);", "         } else {", "           if (!rar_br_read_ahead(a, br, 7)) {", "             free(precode.tree);", "             free(precode.table);", "             goto truncated_data;", "           }", "           n = rar_br_bits(br, 7) + 11;", "           rar_br_consume(br, 7);", "         }", "         for (j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++)", "         {", "           rar->lengthtable[i] = rar->lengthtable[i-1];", "           i++;", "         }", "       }", "       else", "       {", "         if(val == 18) {", "           if (!rar_br_read_ahead(a, br, 3)) {", "             free(precode.tree);", "             free(precode.table);", "             goto truncated_data;", "           }", "           n = rar_br_bits(br, 3) + 3;", "           rar_br_consume(br, 3);", "         } else {", "           if (!rar_br_read_ahead(a, br, 7)) {", "             free(precode.tree);", "             free(precode.table);", "             goto truncated_data;", "           }", "           n = rar_br_bits(br, 7) + 11;", "           rar_br_consume(br, 7);", "         }", "         for(j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++)", "           rar->lengthtable[i++] = 0;", "       }", "     }", "     free(precode.tree);", "     free(precode.table);", "     r = create_code(a, &rar->maincode, &rar->lengthtable[0], MAINCODE_SIZE,", "                 MAX_SYMBOL_LENGTH);", "     if (r != ARCHIVE_OK)", "       return (r);", "     r = create_code(a, &rar->offsetcode, &rar->lengthtable[MAINCODE_SIZE],", "                 OFFSETCODE_SIZE, MAX_SYMBOL_LENGTH);", "     if (r != ARCHIVE_OK)", "       return (r);", "     r = create_code(a, &rar->lowoffsetcode,", "                 &rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE],", "                 LOWOFFSETCODE_SIZE, MAX_SYMBOL_LENGTH);", "     if (r != ARCHIVE_OK)", "       return (r);", "     r = create_code(a, &rar->lengthcode,", "                 &rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE +", "                 LOWOFFSETCODE_SIZE], LENGTHCODE_SIZE, MAX_SYMBOL_LENGTH);", "     if (r != ARCHIVE_OK)", "       return (r);", "   }", "   if (!rar->dictionary_size || !rar->lzss.window)", "   {", "     void *new_window;", "     unsigned int new_size;", "     if (rar->unp_size >= DICTIONARY_MAX_SIZE)", "       new_size = DICTIONARY_MAX_SIZE;", "     else", "       new_size = rar_fls((unsigned int)rar->unp_size) << 1;", "     new_window = realloc(rar->lzss.window, new_size);", "     if (new_window == NULL) {", "       archive_set_error(&a->archive, ENOMEM,", "                         \"Unable to allocate memory for uncompressed data.\");", "       return (ARCHIVE_FATAL);", "     }", "     rar->lzss.window = (unsigned char *)new_window;", "     rar->dictionary_size = new_size;", "     memset(rar->lzss.window, 0, rar->dictionary_size);", "     rar->lzss.mask = rar->dictionary_size - 1;", "   }", "   rar->start_new_table = 0;", "   return (ARCHIVE_OK);", " truncated_data:", "   archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", "                     \"Truncated RAR file data\");", "   rar->valid = 0;", "   return (ARCHIVE_FATAL);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" seamless_process(STREAM s)", "  {", "  \tunsigned int pkglen;", "  \tchar *buf;", " \tstruct stream packet = *s;", " \tif (!s_check(s))", " \t{", " \t\trdp_protocol_error(\"seamless_process(), stream is in unstable state\", &packet);", " \t}", "  \tpkglen = s->end - s->p;", " \tbuf = xmalloc(pkglen + 1);", " \tSTRNCPY(buf, (char *) s->p, pkglen + 1);", " \tstr_handle_lines(buf, &seamless_rest, seamless_line_handler, NULL);", " \txfree(buf);", " }"], "ner_tags": [0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" size_t jsvGetString(const JsVar *v, char *str, size_t len) {", "   assert(len>0);", "   const char *s = jsvGetConstString(v);", "   if (s) {", "      len--;", "      int l = 0;", "    while (*s && l<len) {", "     while (s[l] && l<len) {", "        str[l] = s[l];", "        l++;", "      }", "     str[l] = 0;", "     return l;", "   } else if (jsvIsInt(v)) {", "     itostr(v->varData.integer, str, 10);", "     return strlen(str);", "   } else if (jsvIsFloat(v)) {", "     ftoa_bounded(v->varData.floating, str, len);", "     return strlen(str);", "   } else if (jsvHasCharacterData(v)) {", "     assert(!jsvIsStringExt(v));", "     size_t l = len;", "     JsvStringIterator it;", "     jsvStringIteratorNewConst(&it, v, 0);", "     while (jsvStringIteratorHasChar(&it)) {", "       if (l--<=1) {", "         *str = 0;", "         jsvStringIteratorFree(&it);", "         return len;", "       }", "       *(str++) = jsvStringIteratorGetChar(&it);", "       jsvStringIteratorNext(&it);", "     }", "     jsvStringIteratorFree(&it);", "     *str = 0;", "     return len-l;", "   } else {", "     JsVar *stringVar = jsvAsString((JsVar*)v, false);  ", "     if (stringVar) {", "       size_t l = jsvGetString(stringVar, str, len);  ", "       jsvUnLock(stringVar);", "       return l;", "     } else {", "       str[0] = 0;", "       jsExceptionHere(JSET_INTERNALERROR, \"Variable type cannot be converted to string\");", "       return 0;", "     }", "   }", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static inline ulong encode_twos_comp(long n, int prec)", " static inline jas_ulong encode_twos_comp(long n, int prec)", "  {", "\tulong result;", " \tjas_ulong result;", "  \tassert(prec >= 2);", "  \tjas_eprintf(\"warning: support for signed data is untested\\n\");", " \tif (n < 0) {", " \t\tresult = -n;", " \t\tresult = (result ^ 0xffffffffUL) + 1;", " \t\tresult &= (1 << prec) - 1;", " \t} else {", " \t\tresult = n;", " \t}", " \treturn result;", " }"], "ner_tags": [0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int mv_read_header(AVFormatContext *avctx)", " {", "     MvContext *mv = avctx->priv_data;", "     AVIOContext *pb = avctx->pb;", "     AVStream *ast = NULL, *vst = NULL;  ", "     int version, i;", "     int ret;", "     avio_skip(pb, 4);", "     version = avio_rb16(pb);", "     if (version == 2) {", "         uint64_t timestamp;", "         int v;", "         avio_skip(pb, 22);", "         ast = avformat_new_stream(avctx, NULL);", "         if (!ast)", "             return AVERROR(ENOMEM);", "         vst = avformat_new_stream(avctx, NULL);", "         if (!vst)", "             return AVERROR(ENOMEM);", "         avpriv_set_pts_info(vst, 64, 1, 15);", "         vst->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;", "         vst->avg_frame_rate    = av_inv_q(vst->time_base);", "         vst->nb_frames         = avio_rb32(pb);", "         v = avio_rb32(pb);", "         switch (v) {", "         case 1:", "             vst->codecpar->codec_id = AV_CODEC_ID_MVC1;", "             break;", "         case 2:", "             vst->codecpar->format = AV_PIX_FMT_ARGB;", "             vst->codecpar->codec_id = AV_CODEC_ID_RAWVIDEO;", "             break;", "         default:", "             avpriv_request_sample(avctx, \"Video compression %i\", v);", "             break;", "         }", "         vst->codecpar->codec_tag = 0;", "         vst->codecpar->width     = avio_rb32(pb);", "         vst->codecpar->height    = avio_rb32(pb);", "         avio_skip(pb, 12);", "         ast->codecpar->codec_type  = AVMEDIA_TYPE_AUDIO;", "         ast->nb_frames          = vst->nb_frames;", "         ast->codecpar->sample_rate = avio_rb32(pb);", "         if (ast->codecpar->sample_rate <= 0) {", "             av_log(avctx, AV_LOG_ERROR, \"Invalid sample rate %d\\n\", ast->codecpar->sample_rate);", "             return AVERROR_INVALIDDATA;", "         }", "         avpriv_set_pts_info(ast, 33, 1, ast->codecpar->sample_rate);", "         if (set_channels(avctx, ast, avio_rb32(pb)) < 0)", "             return AVERROR_INVALIDDATA;", "         v = avio_rb32(pb);", "         if (v == AUDIO_FORMAT_SIGNED) {", "             ast->codecpar->codec_id = AV_CODEC_ID_PCM_S16BE;", "         } else {", "             avpriv_request_sample(avctx, \"Audio compression (format %i)\", v);", "         }", "         avio_skip(pb, 12);", "         var_read_metadata(avctx, \"title\", 0x80);", "         var_read_metadata(avctx, \"comment\", 0x100);", "         avio_skip(pb, 0x80);", "         timestamp = 0;", "         for (i = 0; i < vst->nb_frames; i++) {", "              uint32_t pos   = avio_rb32(pb);", "              uint32_t asize = avio_rb32(pb);", "              uint32_t vsize = avio_rb32(pb);", "             if (avio_feof(pb))", "                 return AVERROR_INVALIDDATA;", "              avio_skip(pb, 8);", "              av_add_index_entry(ast, pos, timestamp, asize, 0, AVINDEX_KEYFRAME);", "              av_add_index_entry(vst, pos + asize, i, vsize, 0, AVINDEX_KEYFRAME);", "             timestamp += asize / (ast->codecpar->channels * 2);", "         }", "     } else if (!version && avio_rb16(pb) == 3) {", "         avio_skip(pb, 4);", "         if ((ret = read_table(avctx, NULL, parse_global_var)) < 0)", "             return ret;", "         if (mv->nb_audio_tracks > 1) {", "             avpriv_request_sample(avctx, \"Multiple audio streams support\");", "             return AVERROR_PATCHWELCOME;", "         } else if (mv->nb_audio_tracks) {", "             ast = avformat_new_stream(avctx, NULL);", "             if (!ast)", "                 return AVERROR(ENOMEM);", "             ast->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;", "             if ((read_table(avctx, ast, parse_audio_var)) < 0)", "                 return ret;", "             if (mv->acompression == 100 &&", "                 mv->aformat == AUDIO_FORMAT_SIGNED &&", "                 ast->codecpar->bits_per_coded_sample == 16) {", "                 ast->codecpar->codec_id = AV_CODEC_ID_PCM_S16BE;", "             } else {", "                 avpriv_request_sample(avctx,", "                                       \"Audio compression %i (format %i, sr %i)\",", "                                       mv->acompression, mv->aformat,", "                                       ast->codecpar->bits_per_coded_sample);", "                 ast->codecpar->codec_id = AV_CODEC_ID_NONE;", "             }", "             if (ast->codecpar->channels <= 0) {", "                 av_log(avctx, AV_LOG_ERROR, \"No valid channel count found.\\n\");", "                 return AVERROR_INVALIDDATA;", "             }", "         }", "         if (mv->nb_video_tracks > 1) {", "             avpriv_request_sample(avctx, \"Multiple video streams support\");", "             return AVERROR_PATCHWELCOME;", "         } else if (mv->nb_video_tracks) {", "             vst = avformat_new_stream(avctx, NULL);", "             if (!vst)", "                 return AVERROR(ENOMEM);", "             vst->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;", "             if ((ret = read_table(avctx, vst, parse_video_var))<0)", "                 return ret;", "         }", "         if (mv->nb_audio_tracks)", "             read_index(pb, ast);", "         if (mv->nb_video_tracks)", "             read_index(pb, vst);", "     } else {", "         avpriv_request_sample(avctx, \"Version %i\", version);", "         return AVERROR_PATCHWELCOME;", "     }", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int open_url(AVFormatContext *s, AVIOContext **pb, const char *url,", "                     AVDictionary *opts, AVDictionary *opts2, int *is_http)", " {", "     HLSContext *c = s->priv_data;", "     AVDictionary *tmp = NULL;", "     const char *proto_name = NULL;", "     int ret;", "     av_dict_copy(&tmp, opts, 0);", "     av_dict_copy(&tmp, opts2, 0);", "     if (av_strstart(url, \"crypto\", NULL)) {", "         if (url[6] == '+' || url[6] == ':')", "             proto_name = avio_find_protocol_name(url + 7);", "     }", "     if (!proto_name)", "         proto_name = avio_find_protocol_name(url);", "     if (!proto_name)", "          return AVERROR_INVALIDDATA;", "    if (!av_strstart(proto_name, \"http\", NULL) && !av_strstart(proto_name, \"file\", NULL))", "     if (av_strstart(proto_name, \"file\", NULL)) {", "         if (strcmp(c->allowed_extensions, \"ALL\") && !av_match_ext(url, c->allowed_extensions)) {", "             av_log(s, AV_LOG_ERROR,", "                 \"Filename extension of \\'%s\\' is not a common multimedia extension, blocked for security reasons.\\n\"", "                 \"If you wish to override this adjust allowed_extensions, you can set it to \\'ALL\\' to allow all\\n\",", "                 url);", "             return AVERROR_INVALIDDATA;", "         }", "     } else if (av_strstart(proto_name, \"http\", NULL)) {", "         ;", "     } else", "          return AVERROR_INVALIDDATA;", "      if (!strncmp(proto_name, url, strlen(proto_name)) && url[strlen(proto_name)] == ':')", "          ;", "      else if (av_strstart(url, \"crypto\", NULL) && !strncmp(proto_name, url + 7, strlen(proto_name)) && url[7 + strlen(proto_name)] == ':')", "         ;", "     else if (strcmp(proto_name, \"file\") || !strncmp(url, \"file,\", 5))", "         return AVERROR_INVALIDDATA;", "     ret = s->io_open(s, pb, url, AVIO_FLAG_READ, &tmp);", "     if (ret >= 0) {", "         char *new_cookies = NULL;", "         if (!(s->flags & AVFMT_FLAG_CUSTOM_IO))", "             av_opt_get(*pb, \"cookies\", AV_OPT_SEARCH_CHILDREN, (uint8_t**)&new_cookies);", "         if (new_cookies) {", "             av_free(c->cookies);", "             c->cookies = new_cookies;", "         }", "         av_dict_set(&opts, \"cookies\", c->cookies, 0);", "     }", "     av_dict_free(&tmp);", "     if (is_http)", "         *is_http = av_strstart(proto_name, \"http\", NULL);", "     return ret;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" PHYSICALPATH_FUNC(mod_alias_physical_handler) {", " \tplugin_data *p = p_d;", " \tint uri_len, basedir_len;", " \tchar *uri_ptr;", " \tsize_t k;", " \tif (buffer_is_empty(con->physical.path)) return HANDLER_GO_ON;", " \tmod_alias_patch_connection(srv, con, p);", " \tbasedir_len = buffer_string_length(con->physical.basedir);", " \tif ('/' == con->physical.basedir->ptr[basedir_len-1]) --basedir_len;", " \turi_len = buffer_string_length(con->physical.path) - basedir_len;", " \turi_ptr = con->physical.path->ptr + basedir_len;", " \tfor (k = 0; k < p->conf.alias->used; k++) {", " \t\tdata_string *ds = (data_string *)p->conf.alias->data[k];", " \t\tint alias_len = buffer_string_length(ds->key);", " \t\tif (alias_len > uri_len) continue;", " \t\tif (buffer_is_empty(ds->key)) continue;", " \t\tif (0 == (con->conf.force_lowercase_filenames ?", " \t\t\t\t\tstrncasecmp(uri_ptr, ds->key->ptr, alias_len) :", "  \t\t\t\t\tstrncmp(uri_ptr, ds->key->ptr, alias_len))) {", " \t\t\tif (uri_ptr[alias_len] == '.') {", " \t\t\t\tchar *s = uri_ptr + alias_len + 1;", " \t\t\t\tif (*s == '.') ++s;", " \t\t\t\tif (*s == '/' || *s == '\\0') {", " \t\t\t\t\tsize_t vlen = buffer_string_length(ds->value);", " \t\t\t\t\tif (0 != alias_len && ds->key->ptr[alias_len-1] != '/'", " \t\t\t\t\t    && 0 != vlen && ds->value->ptr[vlen-1] == '/') {", " \t\t\t\t\t\tcon->http_status = 403;", " \t\t\t\t\t\treturn HANDLER_FINISHED;", " \t\t\t\t\t}", " \t\t\t\t}", " \t\t\t}", "  \t\t\tbuffer_copy_buffer(con->physical.basedir, ds->value);", "  \t\t\tbuffer_copy_buffer(srv->tmp_buf, ds->value);", "  \t\t\tbuffer_append_string(srv->tmp_buf, uri_ptr + alias_len);", " \t\t\tbuffer_copy_buffer(con->physical.path, srv->tmp_buf);", " \t\t\treturn HANDLER_GO_ON;", " \t\t}", " \t}", " \treturn HANDLER_GO_ON;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" authentic_set_current_files(struct sc_card *card, struct sc_path *path,", " \t\tunsigned char *resp, size_t resplen, struct sc_file **file_out)", " {", " \tstruct sc_context *ctx = card->ctx;", " \tstruct sc_file *file = NULL;", " \tint rv;", " \tLOG_FUNC_CALLED(ctx);", " \tif (resplen)   {", " \t\tswitch (resp[0]) {", " \t\tcase 0x62:", " \t\tcase 0x6F:", " \t\t\tfile = sc_file_new();", " \t\t\tif (file == NULL)", " \t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);", " \t\t\tif (path)", " \t\t\t\tfile->path = *path;", " \t\t\trv = authentic_process_fci(card, file, resp, resplen);", " \t\t\tLOG_TEST_RET(ctx, rv, \"cannot set 'current file': FCI process error\");", " \t\t\tbreak;", " \t\tdefault:", " \t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED);", " \t\t}", " \t\tif (file->type == SC_FILE_TYPE_DF)   {", " \t\t\tstruct sc_path cur_df_path;", " \t\t\tmemset(&cur_df_path, 0, sizeof(cur_df_path));", " \t\t\tif (card->cache.valid && card->cache.current_df)   {", " \t\t\t\tcur_df_path = card->cache.current_df->path;", " \t\t\t\tsc_file_free(card->cache.current_df);", " \t\t\t}", " \t\t\tcard->cache.current_df = NULL;", "  \t\t\tsc_file_dup(&card->cache.current_df, file);", "  \t\t\tif (cur_df_path.len)   {", " \t\t\t\tif (cur_df_path.len + card->cache.current_df->path.len > sizeof card->cache.current_df->path.value", " \t\t\t\t\t\t|| cur_df_path.len > sizeof card->cache.current_df->path.value)", " \t\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED);", "  \t\t\t\tmemcpy(card->cache.current_df->path.value + cur_df_path.len,", "  \t\t\t\t\t\tcard->cache.current_df->path.value,", "  \t\t\t\t\t\tcard->cache.current_df->path.len);", " \t\t\t\tmemcpy(card->cache.current_df->path.value, cur_df_path.value, cur_df_path.len);", " \t\t\t\tcard->cache.current_df->path.len += cur_df_path.len;", " \t\t\t}", " \t\t\tsc_file_free(card->cache.current_ef);", " \t\t\tcard->cache.current_ef = NULL;", " \t\t\tcard->cache.valid = 1;", " \t\t}", " \t\telse   {", " \t\t\tsc_file_free(card->cache.current_ef);", " \t\t\tcard->cache.current_ef = NULL;", " \t\t\tsc_file_dup(&card->cache.current_ef, file);", " \t\t}", " \t\tif (file_out)", " \t\t\t*file_out = file;", " \t\telse", " \t\t\tsc_file_free(file);", " \t}", " \tLOG_FUNC_RETURN(ctx, SC_SUCCESS);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" ProcessTCPHeader(tTcpIpPacketParsingResult _res, PVOID pIpHeader, ULONG len, USHORT ipHeaderSize)", " {", "      ULONG tcpipDataAt;", "      tTcpIpPacketParsingResult res = _res;", "      tcpipDataAt = ipHeaderSize + sizeof(TCPHeader);", "    res.xxpStatus = ppresXxpIncomplete;", "      res.TcpUdp = ppresIsTCP;", "      if (len >= tcpipDataAt)", "      {", "          TCPHeader *pTcpHeader = (TCPHeader *)RtlOffsetToPointer(pIpHeader, ipHeaderSize);", "          res.xxpStatus = ppresXxpKnown;", "         res.xxpFull = TRUE;", "          tcpipDataAt = ipHeaderSize + TCP_HEADER_LENGTH(pTcpHeader);", "          res.XxpIpHeaderSize = tcpipDataAt;", "      }", "      else", "      {", "          DPrintf(2, (\"tcp: %d < min headers %d\\n\", len, tcpipDataAt));", "         res.xxpFull = FALSE;", "         res.xxpStatus = ppresXxpIncomplete;", "      }", "      return res;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0]}
{"tokens": [" int module_load(", "     YR_SCAN_CONTEXT* context,", "     YR_OBJECT* module_object,", "     void* module_data,", "     size_t module_data_size)", " {", "   set_integer(1, module_object, \"constants.one\");", "   set_integer(2, module_object, \"constants.two\");", "   set_string(\"foo\", module_object, \"constants.foo\");", "   set_string(\"\", module_object, \"constants.empty\");", "   set_integer(1, module_object, \"struct_array[1].i\");", "    set_integer(0, module_object, \"integer_array[%i]\", 0);", "    set_integer(1, module_object, \"integer_array[%i]\", 1);", "    set_integer(2, module_object, \"integer_array[%i]\", 2);", "   set_integer(256, module_object, \"integer_array[%i]\", 256);", "    set_string(\"foo\", module_object, \"string_array[%i]\", 0);", "    set_string(\"bar\", module_object, \"string_array[%i]\", 1);", "   set_string(\"baz\", module_object, \"string_array[%i]\", 2);", "   set_sized_string(\"foo\\0bar\", 7, module_object, \"string_array[%i]\", 3);", "   set_string(\"foo\", module_object, \"string_dict[%s]\", \"foo\");", "   set_string(\"bar\", module_object, \"string_dict[\\\"bar\\\"]\");", "   set_string(\"foo\", module_object, \"struct_dict[%s].s\", \"foo\");", "   set_integer(1, module_object, \"struct_dict[%s].i\", \"foo\");", "   return ERROR_SUCCESS;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" psf_asciiheader_printf (SF_PRIVATE *psf, const char *format, ...)", " {\tva_list\targptr ;", "  \tint\t\tmaxlen ;", "  \tchar\t*start ;", "\tmaxlen = strlen ((char*) psf->header) ;", "\tstart\t= ((char*) psf->header) + maxlen ;", "\tmaxlen\t= sizeof (psf->header) - maxlen ;", " \tmaxlen = strlen ((char*) psf->header.ptr) ;", " \tstart\t= ((char*) psf->header.ptr) + maxlen ;", " \tmaxlen\t= psf->header.len - maxlen ;", "  \tva_start (argptr, format) ;", "  \tvsnprintf (start, maxlen, format, argptr) ;", " \tva_end (argptr) ;", "  \tstart [maxlen - 1] = 0 ;", "\tpsf->headindex = strlen ((char*) psf->header) ;", " \tpsf->header.indx = strlen ((char*) psf->header.ptr) ;", "  \treturn ;", "  }  "], "ner_tags": [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0]}
{"tokens": [" iasecc_select_file(struct sc_card *card, const struct sc_path *path,", " \t\t struct sc_file **file_out)", " {", " \tstruct sc_context *ctx = card->ctx;", " \tstruct sc_path lpath;", " \tint cache_valid = card->cache.valid, df_from_cache = 0;", " \tint rv, ii;", " \tLOG_FUNC_CALLED(ctx);", " \tmemcpy(&lpath, path, sizeof(struct sc_path));", " \tif (file_out)", " \t\t*file_out = NULL;", " \tsc_log(ctx,", " \t       \"iasecc_select_file(card:%p) path.len %\"SC_FORMAT_LEN_SIZE_T\"u; path.type %i; aid_len %\"SC_FORMAT_LEN_SIZE_T\"u\",", " \t       card, path->len, path->type, path->aid.len);", "  \tsc_log(ctx, \"iasecc_select_file() path:%s\", sc_print_path(path));", "  \tsc_print_cache(card);", "\tif (lpath.len >= 2 && lpath.value[0] == 0x3F && lpath.value[1] == 0x00)   {", " \tif (path->type != SC_PATH_TYPE_DF_NAME", " \t\t\t&& lpath.len >= 2", " \t\t\t&& lpath.value[0] == 0x3F && lpath.value[1] == 0x00)   {", "  \t\tsc_log(ctx, \"EF.ATR(aid:'%s')\", card->ef_atr ? sc_dump_hex(card->ef_atr->aid.value, card->ef_atr->aid.len) : \"\");", "  \t\trv = iasecc_select_mf(card, file_out);", "  \t\tLOG_TEST_RET(ctx, rv, \"MF selection error\");", "\t\tif (lpath.len >= 2 && lpath.value[0] == 0x3F && lpath.value[1] == 0x00)\t   {", "\t\t\tmemmove(&lpath.value[0], &lpath.value[2], lpath.len - 2);", "\t\t\tlpath.len -=  2;", "\t\t}", " \t\tmemmove(&lpath.value[0], &lpath.value[2], lpath.len - 2);", " \t\tlpath.len -=  2;", "  \t}", "  \tif (lpath.aid.len)\t{", " \t\tstruct sc_file *file = NULL;", " \t\tstruct sc_path ppath;", " \t\tsc_log(ctx,", " \t\t       \"iasecc_select_file() select parent AID:%p/%\"SC_FORMAT_LEN_SIZE_T\"u\",", " \t\t       lpath.aid.value, lpath.aid.len);", " \t\tsc_log(ctx, \"iasecc_select_file() select parent AID:%s\", sc_dump_hex(lpath.aid.value, lpath.aid.len));", " \t\tmemset(&ppath, 0, sizeof(ppath));", " \t\tmemcpy(ppath.value, lpath.aid.value, lpath.aid.len);", " \t\tppath.len = lpath.aid.len;", " \t\tppath.type = SC_PATH_TYPE_DF_NAME;", " \t\tif (card->cache.valid && card->cache.current_df", " \t\t\t\t&& card->cache.current_df->path.len == lpath.aid.len", " \t\t\t\t&& !memcmp(card->cache.current_df->path.value, lpath.aid.value, lpath.aid.len))", " \t\t\tdf_from_cache = 1;", " \t\trv = iasecc_select_file(card, &ppath, &file);", " \t\tLOG_TEST_RET(ctx, rv, \"select AID path failed\");", " \t\tif (file_out)", " \t\t\t*file_out = file;", " \t\telse", " \t\t   sc_file_free(file);", " \t\tif (lpath.type == SC_PATH_TYPE_DF_NAME)", " \t\t\tlpath.type = SC_PATH_TYPE_FROM_CURRENT;", " \t}", " \tif (lpath.type == SC_PATH_TYPE_PATH)", " \t\tlpath.type = SC_PATH_TYPE_FROM_CURRENT;", " \tif (!lpath.len)", " \t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);", " \tsc_print_cache(card);", " \tif (card->cache.valid && card->cache.current_df && lpath.type == SC_PATH_TYPE_DF_NAME", " \t\t\t&& card->cache.current_df->path.len == lpath.len", " \t\t\t&& !memcmp(card->cache.current_df->path.value, lpath.value, lpath.len))   {", " \t\tsc_log(ctx, \"returns current DF path %s\", sc_print_path(&card->cache.current_df->path));", " \t\tif (file_out)   {", " \t\t\tsc_file_free(*file_out);", " \t\t\tsc_file_dup(file_out, card->cache.current_df);", " \t\t}", " \t\tsc_print_cache(card);", " \t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);", " \t}", " \tdo   {", " \t\tstruct sc_apdu apdu;", " \t\tstruct sc_file *file = NULL;", " \t\tunsigned char rbuf[SC_MAX_APDU_BUFFER_SIZE];", " \t\tint pathlen = lpath.len;", " \t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0x00, 0x00);", " \t\tif (card->type != SC_CARD_TYPE_IASECC_GEMALTO", " \t\t\t\t&& card->type != SC_CARD_TYPE_IASECC_OBERTHUR", " \t\t\t\t&& card->type != SC_CARD_TYPE_IASECC_SAGEM", " \t\t\t\t&& card->type != SC_CARD_TYPE_IASECC_AMOS", " \t\t\t\t&& card->type != SC_CARD_TYPE_IASECC_MI", " \t\t\t\t&& card->type != SC_CARD_TYPE_IASECC_MI2)", " \t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Unsupported card\");", " \t\tif (lpath.type == SC_PATH_TYPE_FILE_ID)   {", " \t\t\tapdu.p1 = 0x02;", " \t\t\tif (card->type == SC_CARD_TYPE_IASECC_OBERTHUR)   {", " \t\t\t\tapdu.p1 = 0x01;", " \t\t\t\tapdu.p2 = 0x04;", " \t\t\t}", " \t\t\tif (card->type == SC_CARD_TYPE_IASECC_AMOS)", " \t\t\t\tapdu.p2 = 0x04;", " \t\t\tif (card->type == SC_CARD_TYPE_IASECC_MI)", " \t\t\t\tapdu.p2 = 0x04;", " \t\t\tif (card->type == SC_CARD_TYPE_IASECC_MI2)", " \t\t\t\tapdu.p2 = 0x04;", " \t\t}", " \t\telse if (lpath.type == SC_PATH_TYPE_FROM_CURRENT)  {", " \t\t\tapdu.p1 = 0x09;", " \t\t\tif (card->type == SC_CARD_TYPE_IASECC_OBERTHUR)", " \t\t\t\tapdu.p2 = 0x04;", " \t\t\tif (card->type == SC_CARD_TYPE_IASECC_AMOS)", " \t\t\t\tapdu.p2 = 0x04;", " \t\t\tif (card->type == SC_CARD_TYPE_IASECC_MI)", " \t\t\t\tapdu.p2 = 0x04;", " \t\t\tif (card->type == SC_CARD_TYPE_IASECC_MI2)", " \t\t\t\tapdu.p2 = 0x04;", " \t\t}", " \t\telse if (lpath.type == SC_PATH_TYPE_PARENT)   {", " \t\t\tapdu.p1 = 0x03;", " \t\t\tpathlen = 0;", " \t\t\tapdu.cse = SC_APDU_CASE_2_SHORT;", " \t\t}", " \t\telse if (lpath.type == SC_PATH_TYPE_DF_NAME)   {", " \t\t\tapdu.p1 = 0x04;", " \t\t\tif (card->type == SC_CARD_TYPE_IASECC_AMOS)", " \t\t\t\tapdu.p2 = 0x04;", " \t\t\tif (card->type == SC_CARD_TYPE_IASECC_MI2)", " \t\t\t\tapdu.p2 = 0x04;", " \t\t}", " \t\telse   {", " \t\t\tsc_log(ctx, \"Invalid PATH type: 0x%X\", lpath.type);", " \t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"iasecc_select_file() invalid PATH type\");", " \t\t}", " \t\tfor (ii=0; ii<2; ii++)   {", " \t\t\tapdu.lc = pathlen;", " \t\t\tapdu.data = lpath.value;", " \t\t\tapdu.datalen = pathlen;", " \t\t\tapdu.resp = rbuf;", " \t\t\tapdu.resplen = sizeof(rbuf);", " \t\t\tapdu.le = 256;", " \t\t\trv = sc_transmit_apdu(card, &apdu);", " \t\t\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");", " \t\t\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);", " \t\t\tif (rv == SC_ERROR_INCORRECT_PARAMETERS &&", " \t\t\t\t\tlpath.type == SC_PATH_TYPE_DF_NAME && apdu.p2 == 0x00)   {", " \t\t\t\tapdu.p2 = 0x0C;", " \t\t\t\tcontinue;", " \t\t\t}", " \t\t\tif (ii)   {", " \t\t\t\tapdu.resplen = sizeof(rbuf);", " \t\t\t\trv = iasecc_emulate_fcp(ctx, &apdu);", " \t\t\t\tLOG_TEST_RET(ctx, rv, \"Failed to emulate DF FCP\");", " \t\t\t}", " \t\t\tbreak;", " \t\t}", " \t\tif (rv == SC_ERROR_FILE_NOT_FOUND && cache_valid && df_from_cache)   {", " \t\t\tsc_invalidate_cache(card);", " \t\t\tsc_log(ctx, \"iasecc_select_file() file not found, retry without cached DF\");", " \t\t\tif (file_out)   {", " \t\t\t\tsc_file_free(*file_out);", " \t\t\t\t*file_out = NULL;", " \t\t\t}", " \t\t\trv = iasecc_select_file(card, path, file_out);", " \t\t\tLOG_FUNC_RETURN(ctx, rv);", " \t\t}", " \t\tLOG_TEST_RET(ctx, rv, \"iasecc_select_file() check SW failed\");", " \t\tsc_log(ctx,", " \t\t       \"iasecc_select_file() apdu.resp %\"SC_FORMAT_LEN_SIZE_T\"u\",", " \t\t       apdu.resplen);", " \t\tif (apdu.resplen)   {", " \t\t\tsc_log(ctx, \"apdu.resp %02X:%02X:%02X...\", apdu.resp[0], apdu.resp[1], apdu.resp[2]);", " \t\t\tswitch (apdu.resp[0]) {", " \t\t\tcase 0x62:", " \t\t\tcase 0x6F:", " \t\t\t\tfile = sc_file_new();", " \t\t\t\tif (file == NULL)", " \t\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);", " \t\t\t\tfile->path = lpath;", " \t\t\t\trv = iasecc_process_fci(card, file, apdu.resp, apdu.resplen);", " \t\t\t\tif (rv)", " \t\t\t\t\tLOG_FUNC_RETURN(ctx, rv);", " \t\t\t\tbreak;", " \t\t\tdefault:", " \t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED);", " \t\t\t}", " \t\t\tsc_log(ctx, \"FileType %i\", file->type);", " \t\t\tif (file->type == SC_FILE_TYPE_DF)   {", " \t\t\t\tif (card->cache.valid)", " \t\t\t\t\tsc_file_free(card->cache.current_df);", " \t\t\t\tcard->cache.current_df = NULL;", " \t\t\t\tif (card->cache.valid)", " \t\t\t\t\tsc_file_free(card->cache.current_ef);", " \t\t\t\tcard->cache.current_ef = NULL;", " \t\t\t\tsc_file_dup(&card->cache.current_df, file);", " \t\t\t\tcard->cache.valid = 1;", " \t\t\t}", " \t\t\telse   {", " \t\t\t\tif (card->cache.valid)", " \t\t\t\t\tsc_file_free(card->cache.current_ef);", " \t\t\t\tcard->cache.current_ef = NULL;", " \t\t\t\tsc_file_dup(&card->cache.current_ef, file);", " \t\t\t}", " \t\t\tif (file_out)   {", " \t\t\t\tsc_file_free(*file_out);", " \t\t\t\t*file_out = file;", " \t\t\t}", " \t\t\telse   {", " \t\t\t\tsc_file_free(file);", " \t\t\t}", " \t\t}", " \t\telse if (lpath.type == SC_PATH_TYPE_DF_NAME)   {", " \t\t\tsc_file_free(card->cache.current_df);", " \t\t\tcard->cache.current_df = NULL;", " \t\t\tsc_file_free(card->cache.current_ef);", " \t\t\tcard->cache.current_ef = NULL;", " \t\t\tcard->cache.valid = 1;", " \t\t}", " \t} while(0);", " \tsc_print_cache(card);", " \tLOG_FUNC_RETURN(ctx, SC_SUCCESS);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static AVFrame *get_video_buffer(AVFilterLink *inlink, int w, int h)", " {", "     PadContext *s = inlink->dst->priv;", "     AVFrame *frame = ff_get_video_buffer(inlink->dst->outputs[0],", "                                          w + (s->w - s->in_w),", "                                          h + (s->h - s->in_h));", "     int plane;", "     if (!frame)", "         return NULL;", "      frame->width  = w;", "      frame->height = h;", "    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {", "     for (plane = 0; plane < 4 && frame->data[plane] && frame->linesize[plane]; plane++) {", "          int hsub = s->draw.hsub[plane];", "          int vsub = s->draw.vsub[plane];", "          frame->data[plane] += (s->x >> hsub) * s->draw.pixelstep[plane] +", "                               (s->y >> vsub) * frame->linesize[plane];", "     }", "     return frame;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void jpc_qmfb_split_colgrp(jpc_fix_t *a, int numrows, int stride,", "   int parity)", " {", " \tint bufsize = JPC_CEILDIVPOW2(numrows, 1);", " \tjpc_fix_t splitbuf[QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE];", " \tjpc_fix_t *buf = splitbuf;", " \tjpc_fix_t *srcptr;", " \tjpc_fix_t *dstptr;", " \tregister jpc_fix_t *srcptr2;", " \tregister jpc_fix_t *dstptr2;", "  \tregister int n;", "  \tregister int i;", "  \tint m;", "\tint hstartcol;", " \tint hstartrow;", "  \tif (bufsize > QMFB_SPLITBUFSIZE) {", "\t\tif (!(buf = jas_alloc2(bufsize, sizeof(jpc_fix_t)))) {", " \t\tif (!(buf = jas_alloc3(bufsize, JPC_QMFB_COLGRPSIZE,", " \t\t  sizeof(jpc_fix_t)))) {", "  \t\t\tabort();", "  \t\t}", "  \t}", "  \tif (numrows >= 2) {", "\t\thstartcol = (numrows + 1 - parity) >> 1;", "\t\tm = numrows - hstartcol;", " \t\thstartrow = (numrows + 1 - parity) >> 1;", " \t\tm = numrows - hstartrow;", "  \t\tn = m;", " \t\tdstptr = buf;", " \t\tsrcptr = &a[(1 - parity) * stride];", " \t\twhile (n-- > 0) {", " \t\t\tdstptr2 = dstptr;", " \t\t\tsrcptr2 = srcptr;", " \t\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {", " \t\t\t\t*dstptr2 = *srcptr2;", " \t\t\t\t++dstptr2;", " \t\t\t\t++srcptr2;", " \t\t\t}", " \t\t\tdstptr += JPC_QMFB_COLGRPSIZE;", " \t\t\tsrcptr += stride << 1;", " \t\t}", " \t\tdstptr = &a[(1 - parity) * stride];", " \t\tsrcptr = &a[(2 - parity) * stride];", " \t\tn = numrows - m - (!parity);", " \t\twhile (n-- > 0) {", " \t\t\tdstptr2 = dstptr;", " \t\t\tsrcptr2 = srcptr;", " \t\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {", " \t\t\t\t*dstptr2 = *srcptr2;", " \t\t\t\t++dstptr2;", " \t\t\t\t++srcptr2;", " \t\t\t}", " \t\t\tdstptr += stride;", "  \t\t\tsrcptr += stride << 1;", "  \t\t}", "\t\tdstptr = &a[hstartcol * stride];", " \t\tdstptr = &a[hstartrow * stride];", "  \t\tsrcptr = buf;", "  \t\tn = m;", "  \t\twhile (n-- > 0) {", " \t\t\tdstptr2 = dstptr;", " \t\t\tsrcptr2 = srcptr;", " \t\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {", " \t\t\t\t*dstptr2 = *srcptr2;", " \t\t\t\t++dstptr2;", " \t\t\t\t++srcptr2;", " \t\t\t}", " \t\t\tdstptr += stride;", " \t\t\tsrcptr += JPC_QMFB_COLGRPSIZE;", " \t\t}", " \t}", " \tif (buf != splitbuf) {", " \t\tjas_free(buf);", " \t}", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  int jas_seq2d_output(jas_matrix_t *matrix, FILE *out)", "  {", "  #define MAXLINELEN\t80", "\tint i;", "\tint j;", " \tjas_matind_t i;", " \tjas_matind_t j;", "  \tjas_seqent_t x;", "  \tchar buf[MAXLINELEN + 1];", "  \tchar sbuf[MAXLINELEN + 1];", " \tint n;", " \tfprintf(out, \"%\"PRIiFAST32\" %\"PRIiFAST32\"\\n\", jas_seq2d_xstart(matrix),", " \t  jas_seq2d_ystart(matrix));", " \tfprintf(out, \"%\"PRIiFAST32\" %\"PRIiFAST32\"\\n\", jas_matrix_numcols(matrix),", " \t  jas_matrix_numrows(matrix));", " \tbuf[0] = '\\0';", " \tfor (i = 0; i < jas_matrix_numrows(matrix); ++i) {", " \t\tfor (j = 0; j < jas_matrix_numcols(matrix); ++j) {", " \t\t\tx = jas_matrix_get(matrix, i, j);", " \t\t\tsprintf(sbuf, \"%s%4ld\", (strlen(buf) > 0) ? \" \" : \"\",", " \t\t\t  JAS_CAST(long, x));", " \t\t\tn = JAS_CAST(int, strlen(buf));", " \t\t\tif (n + JAS_CAST(int, strlen(sbuf)) > MAXLINELEN) {", " \t\t\t\tfputs(buf, out);", " \t\t\t\tfputs(\"\\n\", out);", " \t\t\t\tbuf[0] = '\\0';", " \t\t\t}", " \t\t\tstrcat(buf, sbuf);", " \t\t\tif (j == jas_matrix_numcols(matrix) - 1) {", " \t\t\t\tfputs(buf, out);", " \t\t\t\tfputs(\"\\n\", out);", " \t\t\t\tbuf[0] = '\\0';", " \t\t\t}", " \t\t}", " \t}", " \tfputs(buf, out);", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" xmlPushInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr input) {", "     int ret;", "     if (input == NULL) return(-1);", "     if (xmlParserDebugEntities) {", " \tif ((ctxt->input != NULL) && (ctxt->input->filename))", " \t    xmlGenericError(xmlGenericErrorContext,", " \t\t    \"%s(%d): \", ctxt->input->filename,", " \t\t    ctxt->input->line);", "  \txmlGenericError(xmlGenericErrorContext,", "  \t\t\"Pushing input %d : %.30s\\n\", ctxt->inputNr+1, input->cur);", "      }", "     if (((ctxt->inputNr > 40) && ((ctxt->options & XML_PARSE_HUGE) == 0)) ||", "         (ctxt->inputNr > 1024)) {", "         xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);", "         while (ctxt->inputNr > 1)", "             xmlFreeInputStream(inputPop(ctxt));", " \treturn(-1);", "     }", "      ret = inputPush(ctxt, input);", "      if (ctxt->instate == XML_PARSER_EOF)", "          return(-1);", "     GROW;", "     return(ret);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" on_handler_vanished(GDBusConnection *connection,", " \t\t    const gchar     *name,", " \t\t    gpointer         user_data)", " {", " \tstruct tcmur_handler *handler = user_data;", " \tstruct dbus_info *info = handler->opaque;", " \tif (info->register_invocation) {", " \t\tchar *reason;", " \t\treason = g_strdup_printf(\"Cannot find handler bus name: \"", " \t\t\t\t\"org.kernel.TCMUService1.HandlerManager1.%s\",", " \t\t\t\thandler->subtype);", " \t\tg_dbus_method_invocation_return_value(info->register_invocation,", "  \t\t\t    g_variant_new(\"(bs)\", FALSE, reason));", "  \t\tg_free(reason);", "  \t}", "\ttcmur_unregister_handler(handler);", " \ttcmur_unregister_dbus_handler(handler);", "  \tdbus_unexport_handler(handler);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}
{"tokens": [" int yr_re_fast_exec(", "     uint8_t* code,", "     uint8_t* input_data,", "     size_t input_forwards_size,", "     size_t input_backwards_size,", "     int flags,", "     RE_MATCH_CALLBACK_FUNC callback,", "     void* callback_args,", "     int* matches)", " {", "   RE_REPEAT_ANY_ARGS* repeat_any_args;", "   uint8_t* code_stack[MAX_FAST_RE_STACK];", "   uint8_t* input_stack[MAX_FAST_RE_STACK];", "   int matches_stack[MAX_FAST_RE_STACK];", "   uint8_t* ip = code;", "   uint8_t* input = input_data;", "   uint8_t* next_input;", "   uint8_t* next_opcode;", "   uint8_t mask;", "   uint8_t value;", "   int i;", "   int stop;", "   int input_incr;", "   int sp = 0;", "   int bytes_matched;", "   int max_bytes_matched;", "   max_bytes_matched = flags & RE_FLAGS_BACKWARDS ?", "       (int) input_backwards_size :", "       (int) input_forwards_size;", "   input_incr = flags & RE_FLAGS_BACKWARDS ? -1 : 1;", "   if (flags & RE_FLAGS_BACKWARDS)", "     input--;", "   code_stack[sp] = code;", "   input_stack[sp] = input;", "   matches_stack[sp] = 0;", "   sp++;", "   while (sp > 0)", "   {", "     sp--;", "     ip = code_stack[sp];", "     input = input_stack[sp];", "     bytes_matched = matches_stack[sp];", "     stop = FALSE;", "     while(!stop)", "     {", "       if (*ip == RE_OPCODE_MATCH)", "       {", "         if (flags & RE_FLAGS_EXHAUSTIVE)", "         {", "           FAIL_ON_ERROR(callback(", "              flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data,", "              bytes_matched,", "              flags,", "              callback_args));", "           break;", "         }", "         else", "         {", "           if (matches != NULL)", "             *matches = bytes_matched;", "           return ERROR_SUCCESS;", "         }", "       }", "       if (bytes_matched >= max_bytes_matched)", "         break;", "       switch(*ip)", "       {", "         case RE_OPCODE_LITERAL:", "           if (*input == *(ip + 1))", "           {", "             bytes_matched++;", "             input += input_incr;", "             ip += 2;", "           }", "           else", "           {", "             stop = TRUE;", "           }", "           break;", "         case RE_OPCODE_MASKED_LITERAL:", "           value = *(int16_t*)(ip + 1) & 0xFF;", "           mask = *(int16_t*)(ip + 1) >> 8;", "           if ((*input & mask) == value)", "           {", "             bytes_matched++;", "             input += input_incr;", "             ip += 3;", "           }", "           else", "           {", "             stop = TRUE;", "           }", "           break;", "         case RE_OPCODE_ANY:", "           bytes_matched++;", "           input += input_incr;", "           ip += 1;", "           break;", "         case RE_OPCODE_REPEAT_ANY_UNGREEDY:", "           repeat_any_args = (RE_REPEAT_ANY_ARGS*)(ip + 1);", "           next_opcode = ip + 1 + sizeof(RE_REPEAT_ANY_ARGS);", "            for (i = repeat_any_args->min + 1; i <= repeat_any_args->max; i++)", "            {", "            next_input = input + i * input_incr;", "              if (bytes_matched + i >= max_bytes_matched)", "                break;", "             next_input = input + i * input_incr;", "              if ( *(next_opcode) != RE_OPCODE_LITERAL ||", "                  (*(next_opcode) == RE_OPCODE_LITERAL &&", "                   *(next_opcode + 1) == *next_input))", "             {", "               if (sp >= MAX_FAST_RE_STACK)", "                 return -4;", "               code_stack[sp] = next_opcode;", "               input_stack[sp] = next_input;", "               matches_stack[sp] = bytes_matched + i;", "               sp++;", "             }", "           }", "            input += input_incr * repeat_any_args->min;", "            bytes_matched += repeat_any_args->min;", "           bytes_matched = yr_min(bytes_matched, max_bytes_matched);", "            ip = next_opcode;", "            break;", "         default:", "           assert(FALSE);", "       }", "     }", "   }", "   if (matches != NULL)", "     *matches = -1;", "   return ERROR_SUCCESS;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" ProcPanoramiXGetScreenSize(ClientPtr client)", " {", "     REQUEST(xPanoramiXGetScreenSizeReq);", "     WindowPtr pWin;", "      xPanoramiXGetScreenSizeReply rep;", "      int rc;", "     REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);", "      if (stuff->screen >= PanoramiXNumScreens)", "          return BadMatch;", "    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);", "      rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);", "      if (rc != Success)", "          return rc;", "     rep = (xPanoramiXGetScreenSizeReply) {", "         .type = X_Reply,", "         .sequenceNumber = client->sequence,", "         .length = 0,", "         .width = screenInfo.screens[stuff->screen]->width,", "         .height = screenInfo.screens[stuff->screen]->height,", "         .window = stuff->window,", "         .screen = stuff->screen", "     };", "     if (client->swapped) {", "         swaps(&rep.sequenceNumber);", "         swapl(&rep.length);", "         swapl(&rep.width);", "         swapl(&rep.height);", "         swapl(&rep.window);", "         swapl(&rep.screen);", "     }", "     WriteToClient(client, sizeof(xPanoramiXGetScreenSizeReply), &rep);", "     return Success;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int nfs_readlink_req(struct nfs_priv *npriv, struct nfs_fh *fh,", " \t\t\t    char **target)", " {", " \tuint32_t data[1024];", " \tuint32_t *p;", " \tuint32_t len;", " \tstruct packet *nfs_packet;", " \tp = &(data[0]);", " \tp = rpc_add_credentials(p);", " \tp = nfs_add_fh3(p, fh);", " \tlen = p - &(data[0]);", " \tnfs_packet = rpc_req(npriv, PROG_NFS, NFSPROC3_READLINK, data, len);", " \tif (IS_ERR(nfs_packet))", " \t\treturn PTR_ERR(nfs_packet);", " \tp = (void *)nfs_packet->data + sizeof(struct rpc_reply) + 4;", "  \tp = nfs_read_post_op_attr(p, NULL);", "  \tlen = ntoh32(net_read_uint32(p));  ", " \tlen = max_t(unsigned int, len,", " \t\t    nfs_packet->len - sizeof(struct rpc_reply) - sizeof(uint32_t));", "  \tp++;", "  \t*target = xzalloc(len + 1);", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0]}
{"tokens": [" stf_status ikev2parent_inI2outR2(struct msg_digest *md)", " {", " \tstruct state *st = md->st;", " \tDBG(DBG_CONTROLMORE,", " \t    DBG_log(", " \t\t    \"ikev2 parent inI2outR2: calculating g^{xy} in order to decrypt I2\"));", "  \tif (!md->chain[ISAKMP_NEXT_v2E]) {", "  \t\tlibreswan_log(\"R2 state should receive an encrypted payload\");", "\t\treset_globals();", " \t\treset_globals();  ", "  \t\treturn STF_FATAL;", "  \t}", " \t{", " \t\tstruct dh_continuation *dh = alloc_thing(", " \t\t\tstruct dh_continuation,", " \t\t\t\"ikev2_inI2outR2 KE\");", " \t\tstf_status e;", " \t\tdh->md = md;", " \t\tset_suspended(st, dh->md);", " \t\tpcrc_init(&dh->dh_pcrc);", " \t\tdh->dh_pcrc.pcrc_func = ikev2_parent_inI2outR2_continue;", " \t\te = start_dh_v2(&dh->dh_pcrc, st, st->st_import, RESPONDER,", " \t\t\t\tst->st_oakley.groupnum);", " \t\tif (e != STF_SUSPEND && e != STF_INLINE) {", " \t\t\tloglog(RC_CRYPTOFAILED, \"system too busy\");", " \t\t\tdelete_state(st);", " \t\t}", " \t\treset_globals();", " \t\treturn e;", " \t}", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  int jpg_validate(jas_stream_t *in)", "  {", "\tuchar buf[JPG_MAGICLEN];", " \tjas_uchar buf[JPG_MAGICLEN];", "  \tint i;", "  \tint n;", " \tassert(JAS_STREAM_MAXPUTBACK >= JPG_MAGICLEN);", " \tif ((n = jas_stream_read(in, buf, JPG_MAGICLEN)) < 0) {", " \t\treturn -1;", " \t}", " \tfor (i = n - 1; i >= 0; --i) {", " \t\tif (jas_stream_ungetc(in, buf[i]) == EOF) {", " \t\t\treturn -1;", " \t\t}", " \t}", " \tif (n < JPG_MAGICLEN) {", " \t\treturn -1;", " \t}", " \tif (buf[0] != (JPG_MAGIC >> 8) || buf[1] != (JPG_MAGIC & 0xff)) {", " \t\treturn -1;", " \t}", " \treturn 0;", " }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int mpeg4_decode_studio_block(MpegEncContext *s, int32_t block[64], int n)", " {", "     Mpeg4DecContext *ctx = s->avctx->priv_data;", "     int cc, dct_dc_size, dct_diff, code, j, idx = 1, group = 0, run = 0,", "         additional_code_len, sign, mismatch;", "     VLC *cur_vlc = &ctx->studio_intra_tab[0];", "     uint8_t *const scantable = s->intra_scantable.permutated;", "     const uint16_t *quant_matrix;", "     uint32_t flc;", "     const int min = -1 *  (1 << (s->avctx->bits_per_raw_sample + 6));", "     const int max =      ((1 << (s->avctx->bits_per_raw_sample + 6)) - 1);", "     mismatch = 1;", "     memset(block, 0, 64 * sizeof(int32_t));", "     if (n < 4) {", "         cc = 0;", "         dct_dc_size = get_vlc2(&s->gb, ctx->studio_luma_dc.table, STUDIO_INTRA_BITS, 2);", "         quant_matrix = s->intra_matrix;", "     } else {", "         cc = (n & 1) + 1;", "         if (ctx->rgb)", "             dct_dc_size = get_vlc2(&s->gb, ctx->studio_luma_dc.table, STUDIO_INTRA_BITS, 2);", "         else", "             dct_dc_size = get_vlc2(&s->gb, ctx->studio_chroma_dc.table, STUDIO_INTRA_BITS, 2);", "         quant_matrix = s->chroma_intra_matrix;", "     }", "     if (dct_dc_size < 0) {", "         av_log(s->avctx, AV_LOG_ERROR, \"illegal dct_dc_size vlc\\n\");", "         return AVERROR_INVALIDDATA;", "     } else if (dct_dc_size == 0) {", "         dct_diff = 0;", "     } else {", "         dct_diff = get_xbits(&s->gb, dct_dc_size);", "         if (dct_dc_size > 8) {", "             if(!check_marker(s->avctx, &s->gb, \"dct_dc_size > 8\"))", "                 return AVERROR_INVALIDDATA;", "         }", "     }", "     s->last_dc[cc] += dct_diff;", "     if (s->mpeg_quant)", "         block[0] = s->last_dc[cc] * (8 >> s->intra_dc_precision);", "     else", "         block[0] = s->last_dc[cc] * (8 >> s->intra_dc_precision) * (8 >> s->dct_precision);", "     block[0] = av_clip(block[0], min, max);", "     mismatch ^= block[0];", "     while (1) {", "         group = get_vlc2(&s->gb, cur_vlc->table, STUDIO_INTRA_BITS, 2);", "         if (group < 0) {", "             av_log(s->avctx, AV_LOG_ERROR, \"illegal ac coefficient group vlc\\n\");", "             return AVERROR_INVALIDDATA;", "         }", "         additional_code_len = ac_state_tab[group][0];", "         cur_vlc = &ctx->studio_intra_tab[ac_state_tab[group][1]];", "         if (group == 0) {", "             break;", "         } else if (group >= 1 && group <= 6) {", "             run = 1 << additional_code_len;", "             if (additional_code_len)", "                 run += get_bits(&s->gb, additional_code_len);", "             idx += run;", "             continue;", "         } else if (group >= 7 && group <= 12) {", "             code = get_bits(&s->gb, additional_code_len);", "             sign = code & 1;", "              code >>= 1;", "              run = (1 << (additional_code_len - 1)) + code;", "              idx += run;", "             if (idx > 63)", "                 return AVERROR_INVALIDDATA;", "              j = scantable[idx++];", "              block[j] = sign ? 1 : -1;", "          } else if (group >= 13 && group <= 20) {", "             if (idx > 63)", "                 return AVERROR_INVALIDDATA;", "              j = scantable[idx++];", "              block[j] = get_xbits(&s->gb, additional_code_len);", "          } else if (group == 21) {", "             if (idx > 63)", "                 return AVERROR_INVALIDDATA;", "              j = scantable[idx++];", "              additional_code_len = s->avctx->bits_per_raw_sample + s->dct_precision + 4;", "              flc = get_bits(&s->gb, additional_code_len);", "             if (flc >> (additional_code_len-1))", "                 block[j] = -1 * (( flc ^ ((1 << additional_code_len) -1)) + 1);", "             else", "                 block[j] = flc;", "         }", "         block[j] = ((8 * 2 * block[j] * quant_matrix[j] * s->qscale) >> s->dct_precision) / 32;", "         block[j] = av_clip(block[j], min, max);", "         mismatch ^= block[j];", "     }", "     block[63] ^= mismatch & 1;", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* serial)", " {", " \tcac_private_data_t * priv = CAC_DATA(card);", " \tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_NORMAL);", "         if (card->serialnr.len)   {", "                 *serial = card->serialnr;", "                 SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);", "          }", "  \tif (priv->cac_id_len) {", "  \t\tserial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);", "\t\tmemcpy(serial->value, priv->cac_id, priv->cac_id_len);", " \t\tmemcpy(serial->value, priv->cac_id, serial->len);", "  \t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);", "  \t}", "  \tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0]}
{"tokens": [" ProcSendEvent(ClientPtr client)", " {", "     WindowPtr pWin;", "     WindowPtr effectiveFocus = NullWindow;       ", "     DeviceIntPtr dev = PickPointer(client);", "     DeviceIntPtr keybd = GetMaster(dev, MASTER_KEYBOARD);", "     SpritePtr pSprite = dev->spriteInfo->sprite;", "     REQUEST(xSendEventReq);", "     REQUEST_SIZE_MATCH(xSendEventReq);", "     stuff->event.u.u.type &= ~(SEND_EVENT_BIT);", "     if (!((stuff->event.u.u.type > X_Reply &&", "            stuff->event.u.u.type < LASTEvent) ||", "           (stuff->event.u.u.type >= EXTENSION_EVENT_BASE &&", "            stuff->event.u.u.type < (unsigned) lastEvent))) {", "          client->errorValue = stuff->event.u.u.type;", "          return BadValue;", "      }", "     if (stuff->event.u.u.type == GenericEvent) {", "         client->errorValue = stuff->event.u.u.type;", "         return BadValue;", "     }", "      if (stuff->event.u.u.type == ClientMessage &&", "          stuff->event.u.u.detail != 8 &&", "          stuff->event.u.u.detail != 16 && stuff->event.u.u.detail != 32) {", "     }", "     if (stuff->destination == PointerWindow)", "         pWin = pSprite->win;", "     else if (stuff->destination == InputFocus) {", "         WindowPtr inputFocus = (keybd) ? keybd->focus->win : NoneWin;", "         if (inputFocus == NoneWin)", "             return Success;", "         if (inputFocus == PointerRootWin)", "             inputFocus = GetCurrentRootWindow(dev);", "         if (IsParent(inputFocus, pSprite->win)) {", "             effectiveFocus = inputFocus;", "             pWin = pSprite->win;", "         }", "         else", "             effectiveFocus = pWin = inputFocus;", "     }", "     else", "         dixLookupWindow(&pWin, stuff->destination, client, DixSendAccess);", "     if (!pWin)", "         return BadWindow;", "     if ((stuff->propagate != xFalse) && (stuff->propagate != xTrue)) {", "         client->errorValue = stuff->propagate;", "         return BadValue;", "     }", "     stuff->event.u.u.type |= SEND_EVENT_BIT;", "     if (stuff->propagate) {", "         for (; pWin; pWin = pWin->parent) {", "             if (XaceHook(XACE_SEND_ACCESS, client, NULL, pWin,", "                          &stuff->event, 1))", "                 return Success;", "             if (DeliverEventsToWindow(dev, pWin,", "                                       &stuff->event, 1, stuff->eventMask,", "                                       NullGrab))", "                 return Success;", "             if (pWin == effectiveFocus)", "                 return Success;", "             stuff->eventMask &= ~wDontPropagateMask(pWin);", "             if (!stuff->eventMask)", "                 break;", "         }", "     }", "     else if (!XaceHook(XACE_SEND_ACCESS, client, NULL, pWin, &stuff->event, 1))", "         DeliverEventsToWindow(dev, pWin, &stuff->event,", "                               1, stuff->eventMask, NullGrab);", "     return Success;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int jpc_pi_nextrpcl(register jpc_pi_t *pi)", " {", " \tint rlvlno;", " \tjpc_pirlvl_t *pirlvl;", " \tjpc_pchg_t *pchg;", " \tint prchind;", " \tint prcvind;", " \tint *prclyrno;", " \tint compno;", " \tjpc_picomp_t *picomp;", " \tint xstep;", " \tint ystep;", " \tuint_fast32_t r;", " \tuint_fast32_t rpx;", " \tuint_fast32_t rpy;", " \tuint_fast32_t trx0;", " \tuint_fast32_t try0;", " \tpchg = pi->pchg;", " \tif (!pi->prgvolfirst) {", " \t\tgoto skip;", " \t} else {", " \t\tpi->xstep = 0;", " \t\tpi->ystep = 0;", " \t\tfor (compno = 0, picomp = pi->picomps; compno < pi->numcomps;", "  \t\t  ++compno, ++picomp) {", "  \t\t\tfor (rlvlno = 0, pirlvl = picomp->pirlvls; rlvlno <", "  \t\t\t  picomp->numrlvls; ++rlvlno, ++pirlvl) {", "\t\t\t\txstep = picomp->hsamp * (1 << (pirlvl->prcwidthexpn +", "\t\t\t\t  picomp->numrlvls - rlvlno - 1));", "\t\t\t\tystep = picomp->vsamp * (1 << (pirlvl->prcheightexpn +", "\t\t\t\t  picomp->numrlvls - rlvlno - 1));", " \t\t\t\tif (pirlvl->prcwidthexpn + pi->picomp->numrlvls >", " \t\t\t\t  JAS_UINTFAST32_NUMBITS - 2 ||", " \t\t\t\t  pirlvl->prcheightexpn + pi->picomp->numrlvls >", " \t\t\t\t  JAS_UINTFAST32_NUMBITS - 2) {", " \t\t\t\t\treturn -1;", " \t\t\t\t}", " \t\t\t\txstep = picomp->hsamp * (JAS_CAST(uint_fast32_t, 1) <<", " \t\t\t\t  (pirlvl->prcwidthexpn + picomp->numrlvls - rlvlno - 1));", " \t\t\t\tystep = picomp->vsamp * (JAS_CAST(uint_fast32_t, 1) <<", " \t\t\t\t  (pirlvl->prcheightexpn + picomp->numrlvls - rlvlno - 1));", "  \t\t\t\tpi->xstep = (!pi->xstep) ? xstep : JAS_MIN(pi->xstep, xstep);", "  \t\t\t\tpi->ystep = (!pi->ystep) ? ystep : JAS_MIN(pi->ystep, ystep);", "  \t\t\t}", " \t\t}", " \t\tpi->prgvolfirst = 0;", " \t}", " \tfor (pi->rlvlno = pchg->rlvlnostart; pi->rlvlno < pchg->rlvlnoend &&", " \t  pi->rlvlno < pi->maxrlvls; ++pi->rlvlno) {", " \t\tfor (pi->y = pi->ystart; pi->y < pi->yend; pi->y +=", " \t\t  pi->ystep - (pi->y % pi->ystep)) {", " \t\t\tfor (pi->x = pi->xstart; pi->x < pi->xend; pi->x +=", " \t\t\t  pi->xstep - (pi->x % pi->xstep)) {", " \t\t\t\tfor (pi->compno = pchg->compnostart,", " \t\t\t\t  pi->picomp = &pi->picomps[pi->compno];", " \t\t\t\t  pi->compno < JAS_CAST(int, pchg->compnoend) && pi->compno <", " \t\t\t\t  pi->numcomps; ++pi->compno, ++pi->picomp) {", " \t\t\t\t\tif (pi->rlvlno >= pi->picomp->numrlvls) {", " \t\t\t\t\t\tcontinue;", " \t\t\t\t\t}", " \t\t\t\t\tpi->pirlvl = &pi->picomp->pirlvls[pi->rlvlno];", " \t\t\t\t\tif (pi->pirlvl->numprcs == 0) {", " \t\t\t\t\t\tcontinue;", " \t\t\t\t\t}", " \t\t\t\t\tr = pi->picomp->numrlvls - 1 - pi->rlvlno;", " \t\t\t\t\trpx = r + pi->pirlvl->prcwidthexpn;", "  \t\t\t\t\trpy = r + pi->pirlvl->prcheightexpn;", "  \t\t\t\t\ttrx0 = JPC_CEILDIV(pi->xstart, pi->picomp->hsamp << r);", "  \t\t\t\t\ttry0 = JPC_CEILDIV(pi->ystart, pi->picomp->vsamp << r);", "\t\t\t\t\tif (((pi->x == pi->xstart && ((trx0 << r) % (1 << rpx)))", "\t\t\t\t\t  || !(pi->x % (1 << rpx))) &&", "\t\t\t\t\t  ((pi->y == pi->ystart && ((try0 << r) % (1 << rpy)))", "\t\t\t\t\t  || !(pi->y % (1 << rpy)))) {", "\t\t\t\t\t\tprchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x, pi->picomp->hsamp", "\t\t\t\t\t\t  << r), pi->pirlvl->prcwidthexpn) - JPC_FLOORDIVPOW2(trx0,", "\t\t\t\t\t\t  pi->pirlvl->prcwidthexpn);", "\t\t\t\t\t\tprcvind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->y, pi->picomp->vsamp", "\t\t\t\t\t\t  << r), pi->pirlvl->prcheightexpn) - JPC_FLOORDIVPOW2(try0,", "\t\t\t\t\t\t  pi->pirlvl->prcheightexpn);", " \t\t\t\t\tif (((pi->x == pi->xstart &&", " \t\t\t\t\t  ((trx0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpx)))", " \t\t\t\t\t  || !(pi->x % (JAS_CAST(uint_fast32_t, 1) << rpx))) &&", " \t\t\t\t\t  ((pi->y == pi->ystart &&", " \t\t\t\t\t  ((try0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpy)))", " \t\t\t\t\t  || !(pi->y % (JAS_CAST(uint_fast32_t, 1) << rpy)))) {", " \t\t\t\t\t\tprchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x,", " \t\t\t\t\t\t  pi->picomp->hsamp << r), pi->pirlvl->prcwidthexpn) -", " \t\t\t\t\t\t  JPC_FLOORDIVPOW2(trx0, pi->pirlvl->prcwidthexpn);", " \t\t\t\t\t\tprcvind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->y,", " \t\t\t\t\t\t  pi->picomp->vsamp << r), pi->pirlvl->prcheightexpn) -", " \t\t\t\t\t\t  JPC_FLOORDIVPOW2(try0, pi->pirlvl->prcheightexpn);", "  \t\t\t\t\t\tpi->prcno = prcvind * pi->pirlvl->numhprcs + prchind;", "  \t\t\t\t\t\tassert(pi->prcno < pi->pirlvl->numprcs);", "  \t\t\t\t\t\tfor (pi->lyrno = 0; pi->lyrno <", "\t\t\t\t\t\t  pi->numlyrs && pi->lyrno < JAS_CAST(int, pchg->lyrnoend); ++pi->lyrno) {", " \t\t\t\t\t\t  pi->numlyrs && pi->lyrno < JAS_CAST(int,", " \t\t\t\t\t\t  pchg->lyrnoend); ++pi->lyrno) {", "  \t\t\t\t\t\t\tprclyrno = &pi->pirlvl->prclyrnos[pi->prcno];", "  \t\t\t\t\t\t\tif (pi->lyrno >= *prclyrno) {", "  \t\t\t\t\t\t\t\t++(*prclyrno);", " \t\t\t\t\t\t\t\treturn 0;", " \t\t\t\t\t\t\t}", " skip:", " \t\t\t\t\t\t\t;", " \t\t\t\t\t\t}", " \t\t\t\t\t}", " \t\t\t\t}", " \t\t\t}", " \t\t}", " \t}", " \treturn 1;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int http_receive_data(HTTPContext *c)", " {", "     HTTPContext *c1;", "     int len, loop_run = 0;", "     while (c->chunked_encoding && !c->chunk_size &&", "            c->buffer_end > c->buffer_ptr) {", "         len = recv(c->fd, c->buffer_ptr, 1, 0);", "         if (len < 0) {", "             if (ff_neterrno() != AVERROR(EAGAIN) &&", "                 ff_neterrno() != AVERROR(EINTR))", "                 goto fail;", "             return 0;", "         } else if (len == 0) {", "             goto fail;", "          } else if (c->buffer_ptr - c->buffer >= 2 &&", "                     !memcmp(c->buffer_ptr - 1, \"\\r\\n\", 2)) {", "              c->chunk_size = strtol(c->buffer, 0, 16);", "            if (c->chunk_size == 0)  ", "             if (c->chunk_size <= 0) {  ", "                 c->chunk_size = 0;", "                  goto fail;", "             }", "              c->buffer_ptr = c->buffer;", "              break;", "          } else if (++loop_run > 10)", "             goto fail;", "         else", "             c->buffer_ptr++;", "     }", "     if (c->buffer_end > c->buffer_ptr) {", "         len = recv(c->fd, c->buffer_ptr,", "                    FFMIN(c->chunk_size, c->buffer_end - c->buffer_ptr), 0);", "         if (len < 0) {", "             if (ff_neterrno() != AVERROR(EAGAIN) &&", "                 ff_neterrno() != AVERROR(EINTR))", "                 goto fail;", "         } else if (len == 0)", "              goto fail;", "          else {", "             av_assert0(len <= c->chunk_size);", "              c->chunk_size -= len;", "              c->buffer_ptr += len;", "              c->data_count += len;", "             update_datarate(&c->datarate, c->data_count);", "         }", "     }", "     if (c->buffer_ptr - c->buffer >= 2 && c->data_count > FFM_PACKET_SIZE) {", "         if (c->buffer[0] != 'f' ||", "             c->buffer[1] != 'm') {", "             http_log(\"Feed stream has become desynchronized -- disconnecting\\n\");", "             goto fail;", "         }", "     }", "     if (c->buffer_ptr >= c->buffer_end) {", "         FFServerStream *feed = c->stream;", "         if (c->data_count > FFM_PACKET_SIZE) {", "             if (lseek(c->feed_fd, feed->feed_write_index, SEEK_SET) == -1)", "                 http_log(\"Seek to %\"PRId64\" failed\\n\", feed->feed_write_index);", "             if (write(c->feed_fd, c->buffer, FFM_PACKET_SIZE) < 0) {", "                 http_log(\"Error writing to feed file: %s\\n\", strerror(errno));", "                 goto fail;", "             }", "             feed->feed_write_index += FFM_PACKET_SIZE;", "             if (feed->feed_write_index > c->stream->feed_size)", "                 feed->feed_size = feed->feed_write_index;", "             if (c->stream->feed_max_size &&", "                 feed->feed_write_index >= c->stream->feed_max_size)", "                 feed->feed_write_index = FFM_PACKET_SIZE;", "             if (ffm_write_write_index(c->feed_fd, feed->feed_write_index) < 0) {", "                 http_log(\"Error writing index to feed file: %s\\n\",", "                          strerror(errno));", "                 goto fail;", "             }", "             for(c1 = first_http_ctx; c1; c1 = c1->next) {", "                 if (c1->state == HTTPSTATE_WAIT_FEED &&", "                     c1->stream->feed == c->stream->feed)", "                     c1->state = HTTPSTATE_SEND_DATA;", "             }", "         } else {", "             AVFormatContext *s = avformat_alloc_context();", "             AVIOContext *pb;", "             AVInputFormat *fmt_in;", "             int i;", "             if (!s)", "                 goto fail;", "             fmt_in = av_find_input_format(feed->fmt->name);", "             if (!fmt_in)", "                 goto fail;", "             pb = avio_alloc_context(c->buffer, c->buffer_end - c->buffer,", "                                     0, NULL, NULL, NULL, NULL);", "             if (!pb)", "                 goto fail;", "             pb->seekable = 0;", "             s->pb = pb;", "             if (avformat_open_input(&s, c->stream->feed_filename, fmt_in, NULL) < 0) {", "                 av_freep(&pb);", "                 goto fail;", "             }", "             if (s->nb_streams != feed->nb_streams) {", "                 avformat_close_input(&s);", "                 av_freep(&pb);", "                 http_log(\"Feed '%s' stream number does not match registered feed\\n\",", "                          c->stream->feed_filename);", "                 goto fail;", "             }", "             for (i = 0; i < s->nb_streams; i++) {", "                 LayeredAVStream *fst = feed->streams[i];", "                 AVStream *st = s->streams[i];", "                 avcodec_parameters_to_context(fst->codec, st->codecpar);", "                 avcodec_parameters_from_context(fst->codecpar, fst->codec);", "             }", "             avformat_close_input(&s);", "             av_freep(&pb);", "         }", "         c->buffer_ptr = c->buffer;", "     }", "     return 0;", "  fail:", "     c->stream->feed_opened = 0;", "     close(c->feed_fd);", "     for(c1 = first_http_ctx; c1; c1 = c1->next) {", "         if (c1->state == HTTPSTATE_WAIT_FEED &&", "             c1->stream->feed == c->stream->feed)", "             c1->state = HTTPSTATE_SEND_DATA_TRAILER;", "     }", "     return -1;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int cac_read_binary(sc_card_t *card, unsigned int idx,", " \t\tunsigned char *buf, size_t count, unsigned long flags)", " {", " \tcac_private_data_t * priv = CAC_DATA(card);", " \tint r = 0;", " \tu8 *tl = NULL, *val = NULL;", " \tu8 *tl_ptr, *val_ptr, *tlv_ptr, *tl_start;", " \tu8 *cert_ptr;", " \tsize_t tl_len, val_len, tlv_len;", " \tsize_t len, tl_head_len, cert_len;", " \tu8 cert_type, tag;", " \tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);", " \tif (priv->cached) {", " \t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,", " \t\t\t \"returning cached value idx=%d count=%\"SC_FORMAT_LEN_SIZE_T\"u\",", " \t\t\t idx, count);", " \t\tif (idx > priv->cache_buf_len) {", " \t\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_END_REACHED);", " \t\t}", " \t\tlen = MIN(count, priv->cache_buf_len-idx);", " \t\tmemcpy(buf, &priv->cache_buf[idx], len);", " \t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, len);", " \t}", " \tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,", " \t\t \"clearing cache idx=%d count=%\"SC_FORMAT_LEN_SIZE_T\"u\",", " \t\t idx, count);", " \tif (priv->cache_buf) {", " \t\tfree(priv->cache_buf);", " \t\tpriv->cache_buf = NULL;", " \t\tpriv->cache_buf_len = 0;", " \t}", " \tif (priv->object_type <= 0)", " \t\t SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_INTERNAL);", " \tr = cac_read_file(card, CAC_FILE_TAG, &tl, &tl_len);", " \tif (r < 0)  {", " \t\tgoto done;", " \t}", " \tr = cac_read_file(card, CAC_FILE_VALUE, &val, &val_len);", " \tif (r < 0)", " \t\tgoto done;", " \tswitch (priv->object_type) {", " \tcase CAC_OBJECT_TYPE_TLV_FILE:", " \t\ttlv_len = tl_len + val_len;", " \t\tpriv->cache_buf = malloc(tlv_len);", " \t\tif (priv->cache_buf == NULL) {", " \t\t\tr = SC_ERROR_OUT_OF_MEMORY;", " \t\t\tgoto done;", " \t\t}", " \t\tpriv->cache_buf_len = tlv_len;", " \t\tfor (tl_ptr = tl, val_ptr=val, tlv_ptr = priv->cache_buf;", " \t\t\t\ttl_len >= 2 && tlv_len > 0;", " \t\t\t\tval_len -= len, tlv_len -= len, val_ptr += len, tlv_ptr += len) {", " \t\t\ttl_start = tl_ptr;", " \t\t\tif (sc_simpletlv_read_tag(&tl_ptr, tl_len, &tag, &len) != SC_SUCCESS)", " \t\t\t\tbreak;", " \t\t\ttl_head_len = (tl_ptr - tl_start);", " \t\t\tsc_simpletlv_put_tag(tag, len, tlv_ptr, tlv_len, &tlv_ptr);", " \t\t\ttlv_len -= tl_head_len;", " \t\t\ttl_len -= tl_head_len;", " \t\t\tif (val_len < len) {", " \t\t\t\tlen = val_len;", " \t\t\t}", " \t\t\tif (tlv_len < len) {", " \t\t\t\tlen = tlv_len;", " \t\t\t}", " \t\t\tmemcpy(tlv_ptr, val_ptr, len);", " \t\t}", " \t\tbreak;", " \tcase CAC_OBJECT_TYPE_CERT:", " \t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,", " \t\t\t \" obj= cert_file, val_len=%\"SC_FORMAT_LEN_SIZE_T\"u (0x%04\"SC_FORMAT_LEN_SIZE_T\"x)\",", " \t\t\t val_len, val_len);", "  \t\tcert_len = 0;", "  \t\tcert_ptr = NULL;", "  \t\tcert_type = 0;", "\t\tfor (tl_ptr = tl, val_ptr=val; tl_len >= 2;", "\t\t\t\tval_len -= len, val_ptr += len, tl_len -= tl_head_len) {", " \t\tfor (tl_ptr = tl, val_ptr = val; tl_len >= 2;", " \t\t    val_len -= len, val_ptr += len, tl_len -= tl_head_len) {", "  \t\t\ttl_start = tl_ptr;", "  \t\t\tif (sc_simpletlv_read_tag(&tl_ptr, tl_len, &tag, &len) != SC_SUCCESS)", "  \t\t\t\tbreak;", "  \t\t\ttl_head_len = tl_ptr - tl_start;", " \t\t\tif (val_len < len)", " \t\t\t\tbreak;", "  \t\t\tif (tag == CAC_TAG_CERTIFICATE) {", "  \t\t\t\tcert_len = len;", "  \t\t\t\tcert_ptr = val_ptr;", " \t\t\t}", " \t\t\tif (tag == CAC_TAG_CERTINFO) {", " \t\t\t\tif ((len >= 1) && (val_len >=1)) {", " \t\t\t\t\tcert_type = *val_ptr;", " \t\t\t\t}", " \t\t\t}", " \t\t\tif (tag == CAC_TAG_MSCUID) {", " \t\t\t\tsc_log_hex(card->ctx, \"MSCUID\", val_ptr, len);", " \t\t\t}", " \t\t\tif ((val_len < len) || (tl_len < tl_head_len)) {", " \t\t\t\tbreak;", " \t\t\t}", " \t\t}", " \t\tif ((cert_type & 0x3) == 1) {", " #ifdef ENABLE_ZLIB", " \t\t\tr = sc_decompress_alloc(&priv->cache_buf, &priv->cache_buf_len,", " \t\t\t\tcert_ptr, cert_len, COMPRESSION_AUTO);", " #else", " \t\t\tsc_log(card->ctx, \"CAC compression not supported, no zlib\");", " \t\t\tr = SC_ERROR_NOT_SUPPORTED;", " #endif", " \t\t\tif (r)", " \t\t\t\tgoto done;", " \t\t} else if (cert_len > 0) {", " \t\t\tpriv->cache_buf = malloc(cert_len);", " \t\t\tif (priv->cache_buf == NULL) {", " \t\t\t\tr = SC_ERROR_OUT_OF_MEMORY;", " \t\t\t\tgoto done;", " \t\t\t}", " \t\t\tpriv->cache_buf_len = cert_len;", " \t\t\tmemcpy(priv->cache_buf, cert_ptr, cert_len);", " \t\t} else {", " \t\t\tsc_log(card->ctx, \"Can't read zero-length certificate\");", " \t\t\tgoto done;", " \t\t}", " \t\tbreak;", " \tcase CAC_OBJECT_TYPE_GENERIC:", " \tdefault:", " \t\tsc_log(card->ctx, \"Unknown object type: %x\", priv->object_type);", " \t\tr = SC_ERROR_INTERNAL;", " \t\tgoto done;", " \t}", " \tpriv->cached = 1;", " \tlen = MIN(count, priv->cache_buf_len-idx);", " \tmemcpy(buf, &priv->cache_buf[idx], len);", " \tr = len;", " done:", " \tif (tl)", " \t\tfree(tl);", " \tif (val)", " \t\tfree(val);", " \tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, r);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static void build_l4proto_dccp(const struct nf_conntrack *ct, struct nethdr *n)", "  {", "\tct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,", "\t\t      sizeof(struct nfct_attr_grp_port));", "  \tif (!nfct_attr_is_set(ct, ATTR_DCCP_STATE))", "  \t\treturn;", " \tct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,", " \t\t      sizeof(struct nfct_attr_grp_port));", "  \tct_build_u8(ct, ATTR_DCCP_STATE, n, NTA_DCCP_STATE);", "  \tct_build_u8(ct, ATTR_DCCP_ROLE, n, NTA_DCCP_ROLE);", "  }"], "ner_tags": [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0]}
{"tokens": [" int jas_memdump(FILE *out, void *data, size_t len)", "  {", "  \tsize_t i;", "  \tsize_t j;", "\tuchar *dp;", " \tjas_uchar *dp;", "  \tdp = data;", "  \tfor (i = 0; i < len; i += 16) {", "  \t\tfprintf(out, \"%04zx:\", i);", " \t\tfor (j = 0; j < 16; ++j) {", " \t\t\tif (i + j < len) {", " \t\t\t\tfprintf(out, \" %02x\", dp[i + j]);", " \t\t\t}", " \t\t}", " \t\tfprintf(out, \"\\n\");", " \t}", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static int jas_iccgetsint32(jas_stream_t *in, jas_iccsint32_t *val)", "  {", "\tulonglong tmp;", " \tjas_ulonglong tmp;", "  \tif (jas_iccgetuint(in, 4, &tmp))", "  \t\treturn -1;", "\t*val = (tmp & 0x80000000) ? (-JAS_CAST(longlong, (((~tmp) &", "\t  0x7fffffff) + 1))) : JAS_CAST(longlong, tmp);", " \t*val = (tmp & 0x80000000) ? (-JAS_CAST(jas_longlong, (((~tmp) &", " \t  0x7fffffff) + 1))) : JAS_CAST(jas_longlong, tmp);", "  \treturn 0;", "  }"], "ner_tags": [0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0]}
{"tokens": [" read_header(struct archive_read *a, struct archive_entry *entry,", "             char head_type)", " {", "   const void *h;", "   const char *p, *endp;", "   struct rar *rar;", "   struct rar_header rar_header;", "   struct rar_file_header file_header;", "   int64_t header_size;", "   unsigned filename_size, end;", "   char *filename;", "   char *strp;", "   char packed_size[8];", "   char unp_size[8];", "   int ttime;", "   struct archive_string_conv *sconv, *fn_sconv;", "   unsigned long crc32_val;", "   int ret = (ARCHIVE_OK), ret2;", "   rar = (struct rar *)(a->format->data);", "   sconv = rar->opt_sconv;", "   if (sconv == NULL) {", "     if (!rar->init_default_conversion) {", "       rar->sconv_default =", "           archive_string_default_conversion_for_read(", "             &(a->archive));", "       rar->init_default_conversion = 1;", "     }", "     sconv = rar->sconv_default;", "   }", "   if ((h = __archive_read_ahead(a, 7, NULL)) == NULL)", "     return (ARCHIVE_FATAL);", "   p = h;", "   memcpy(&rar_header, p, sizeof(rar_header));", "   rar->file_flags = archive_le16dec(rar_header.flags);", "   header_size = archive_le16dec(rar_header.size);", "   if (header_size < (int64_t)sizeof(file_header) + 7) {", "     archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", "       \"Invalid header size\");", "     return (ARCHIVE_FATAL);", "   }", "   crc32_val = crc32(0, (const unsigned char *)p + 2, 7 - 2);", "   __archive_read_consume(a, 7);", "   if (!(rar->file_flags & FHD_SOLID))", "   {", "     rar->compression_method = 0;", "     rar->packed_size = 0;", "     rar->unp_size = 0;", "     rar->mtime = 0;", "     rar->ctime = 0;", "     rar->atime = 0;", "     rar->arctime = 0;", "     rar->mode = 0;", "     memset(&rar->salt, 0, sizeof(rar->salt));", "     rar->atime = 0;", "     rar->ansec = 0;", "     rar->ctime = 0;", "     rar->cnsec = 0;", "     rar->mtime = 0;", "     rar->mnsec = 0;", "     rar->arctime = 0;", "     rar->arcnsec = 0;", "   }", "   else", "   {", "     archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", "                       \"RAR solid archive support unavailable.\");", "     return (ARCHIVE_FATAL);", "   }", "   if ((h = __archive_read_ahead(a, (size_t)header_size - 7, NULL)) == NULL)", "     return (ARCHIVE_FATAL);", "   crc32_val = crc32(crc32_val, h, (unsigned)(header_size - 7));", "   if ((crc32_val & 0xffff) != archive_le16dec(rar_header.crc)) {", "     archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", "       \"Header CRC error\");", "     return (ARCHIVE_FATAL);", "   }", "   p = h;", "   endp = p + header_size - 7;", "   memcpy(&file_header, p, sizeof(file_header));", "   p += sizeof(file_header);", "   rar->compression_method = file_header.method;", "   ttime = archive_le32dec(file_header.file_time);", "   rar->mtime = get_time(ttime);", "   rar->file_crc = archive_le32dec(file_header.file_crc);", "   if (rar->file_flags & FHD_PASSWORD)", "   {", " \tarchive_entry_set_is_data_encrypted(entry, 1);", " \trar->has_encrypted_entries = 1;", "     archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", "                       \"RAR encryption support unavailable.\");", "   }", "   if (rar->file_flags & FHD_LARGE)", "   {", "     memcpy(packed_size, file_header.pack_size, 4);", "     memcpy(packed_size + 4, p, 4);  ", "     p += 4;", "     memcpy(unp_size, file_header.unp_size, 4);", "     memcpy(unp_size + 4, p, 4);  ", "     p += 4;", "     rar->packed_size = archive_le64dec(&packed_size);", "     rar->unp_size = archive_le64dec(&unp_size);", "   }", "   else", "   {", "     rar->packed_size = archive_le32dec(file_header.pack_size);", "     rar->unp_size = archive_le32dec(file_header.unp_size);", "   }", "   if (rar->packed_size < 0 || rar->unp_size < 0)", "   {", "     archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", "                       \"Invalid sizes specified.\");", "     return (ARCHIVE_FATAL);", "   }", "   rar->bytes_remaining = rar->packed_size;", "   if (head_type == NEWSUB_HEAD) {", "     size_t distance = p - (const char *)h;", "     header_size += rar->packed_size;", "     if ((h = __archive_read_ahead(a, (size_t)header_size - 7, NULL)) == NULL)", "         return (ARCHIVE_FATAL);", "     p = h;", "     endp = p + header_size - 7;", "     p += distance;", "   }", "   filename_size = archive_le16dec(file_header.name_size);", "   if (p + filename_size > endp) {", "     archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", "       \"Invalid filename size\");", "     return (ARCHIVE_FATAL);", "   }", "   if (rar->filename_allocated < filename_size * 2 + 2) {", "     char *newptr;", "     size_t newsize = filename_size * 2 + 2;", "     newptr = realloc(rar->filename, newsize);", "     if (newptr == NULL) {", "       archive_set_error(&a->archive, ENOMEM,", "                         \"Couldn't allocate memory.\");", "       return (ARCHIVE_FATAL);", "     }", "     rar->filename = newptr;", "     rar->filename_allocated = newsize;", "   }", "   filename = rar->filename;", "   memcpy(filename, p, filename_size);", "   filename[filename_size] = '\\0';", "   if (rar->file_flags & FHD_UNICODE)", "   {", "     if (filename_size != strlen(filename))", "     {", "       unsigned char highbyte, flagbits, flagbyte;", "       unsigned fn_end, offset;", "       end = filename_size;", "       fn_end = filename_size * 2;", "       filename_size = 0;", "       offset = (unsigned)strlen(filename) + 1;", "       highbyte = *(p + offset++);", "       flagbits = 0;", "       flagbyte = 0;", "       while (offset < end && filename_size < fn_end)", "       {", "         if (!flagbits)", "         {", "           flagbyte = *(p + offset++);", "           flagbits = 8;", "         }", "         flagbits -= 2;", "         switch((flagbyte >> flagbits) & 3)", "         {", "           case 0:", "             filename[filename_size++] = '\\0';", "             filename[filename_size++] = *(p + offset++);", "             break;", "           case 1:", "             filename[filename_size++] = highbyte;", "             filename[filename_size++] = *(p + offset++);", "             break;", "           case 2:", "             filename[filename_size++] = *(p + offset + 1);", "             filename[filename_size++] = *(p + offset);", "             offset += 2;", "             break;", "           case 3:", "           {", "             char extra, high;", "             uint8_t length = *(p + offset++);", "             if (length & 0x80) {", "               extra = *(p + offset++);", "               high = (char)highbyte;", "             } else", "               extra = high = 0;", "             length = (length & 0x7f) + 2;", "             while (length && filename_size < fn_end) {", "               unsigned cp = filename_size >> 1;", "               filename[filename_size++] = high;", "               filename[filename_size++] = p[cp] + extra;", "               length--;", "             }", "           }", "           break;", "         }", "       }", "       if (filename_size > fn_end) {", "         archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", "           \"Invalid filename\");", "         return (ARCHIVE_FATAL);", "       }", "       filename[filename_size++] = '\\0';", "       filename[filename_size] = '\\0';", "       if (rar->sconv_utf16be == NULL) {", "         rar->sconv_utf16be = archive_string_conversion_from_charset(", "            &a->archive, \"UTF-16BE\", 1);", "         if (rar->sconv_utf16be == NULL)", "           return (ARCHIVE_FATAL);", "       }", "       fn_sconv = rar->sconv_utf16be;", "       strp = filename;", "       while (memcmp(strp, \"\\x00\\x00\", 2))", "       {", "         if (!memcmp(strp, \"\\x00\\\\\", 2))", "           *(strp + 1) = '/';", "         strp += 2;", "       }", "       p += offset;", "     } else {", "       if (rar->sconv_utf8 == NULL) {", "         rar->sconv_utf8 = archive_string_conversion_from_charset(", "            &a->archive, \"UTF-8\", 1);", "         if (rar->sconv_utf8 == NULL)", "           return (ARCHIVE_FATAL);", "       }", "       fn_sconv = rar->sconv_utf8;", "       while ((strp = strchr(filename, '\\\\')) != NULL)", "         *strp = '/';", "       p += filename_size;", "     }", "   }", "   else", "   {", "     fn_sconv = sconv;", "     while ((strp = strchr(filename, '\\\\')) != NULL)", "       *strp = '/';", "     p += filename_size;", "   }", "   if (rar->filename_save &&", "     filename_size == rar->filename_save_size &&", "     !memcmp(rar->filename, rar->filename_save, filename_size + 1))", "   {", "     __archive_read_consume(a, header_size - 7);", "     rar->cursor++;", "     if (rar->cursor >= rar->nodes)", "     {", "       rar->nodes++;", "       if ((rar->dbo =", "         realloc(rar->dbo, sizeof(*rar->dbo) * rar->nodes)) == NULL)", "       {", "         archive_set_error(&a->archive, ENOMEM, \"Couldn't allocate memory.\");", "         return (ARCHIVE_FATAL);", "       }", "       rar->dbo[rar->cursor].header_size = header_size;", "       rar->dbo[rar->cursor].start_offset = -1;", "       rar->dbo[rar->cursor].end_offset = -1;", "     }", "     if (rar->dbo[rar->cursor].start_offset < 0)", "     {", "       rar->dbo[rar->cursor].start_offset = a->filter->position;", "       rar->dbo[rar->cursor].end_offset = rar->dbo[rar->cursor].start_offset +", "         rar->packed_size;", "      }", "      return ret;", "    }", "   else if (rar->filename_must_match)", "   {", "     archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", "       \"Mismatch of file parts split across multi-volume archive\");", "     return (ARCHIVE_FATAL);", "   }", "    rar->filename_save = (char*)realloc(rar->filename_save,", "                                        filename_size + 1);", "   memcpy(rar->filename_save, rar->filename, filename_size + 1);", "   rar->filename_save_size = filename_size;", "   free(rar->dbo);", "   if ((rar->dbo = calloc(1, sizeof(*rar->dbo))) == NULL)", "   {", "     archive_set_error(&a->archive, ENOMEM, \"Couldn't allocate memory.\");", "     return (ARCHIVE_FATAL);", "   }", "   rar->dbo[0].header_size = header_size;", "   rar->dbo[0].start_offset = -1;", "   rar->dbo[0].end_offset = -1;", "   rar->cursor = 0;", "   rar->nodes = 1;", "   if (rar->file_flags & FHD_SALT)", "   {", "     if (p + 8 > endp) {", "       archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", "         \"Invalid header size\");", "       return (ARCHIVE_FATAL);", "     }", "     memcpy(rar->salt, p, 8);", "     p += 8;", "   }", "   if (rar->file_flags & FHD_EXTTIME) {", "     if (read_exttime(p, rar, endp) < 0) {", "       archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", "         \"Invalid header size\");", "       return (ARCHIVE_FATAL);", "     }", "   }", "   __archive_read_consume(a, header_size - 7);", "   rar->dbo[0].start_offset = a->filter->position;", "   rar->dbo[0].end_offset = rar->dbo[0].start_offset + rar->packed_size;", "   switch(file_header.host_os)", "   {", "   case OS_MSDOS:", "   case OS_OS2:", "   case OS_WIN32:", "     rar->mode = archive_le32dec(file_header.file_attr);", "     if (rar->mode & FILE_ATTRIBUTE_DIRECTORY)", "       rar->mode = AE_IFDIR | S_IXUSR | S_IXGRP | S_IXOTH;", "     else", "       rar->mode = AE_IFREG;", "     rar->mode |= S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;", "     break;", "   case OS_UNIX:", "   case OS_MAC_OS:", "   case OS_BEOS:", "     rar->mode = archive_le32dec(file_header.file_attr);", "     break;", "   default:", "     archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", "                       \"Unknown file attributes from RAR file's host OS\");", "     return (ARCHIVE_FATAL);", "   }", "   rar->bytes_uncopied = rar->bytes_unconsumed = 0;", "   rar->lzss.position = rar->offset = 0;", "   rar->offset_seek = 0;", "   rar->dictionary_size = 0;", "   rar->offset_outgoing = 0;", "   rar->br.cache_avail = 0;", "   rar->br.avail_in = 0;", "   rar->crc_calculated = 0;", "   rar->entry_eof = 0;", "   rar->valid = 1;", "   rar->is_ppmd_block = 0;", "   rar->start_new_table = 1;", "   free(rar->unp_buffer);", "   rar->unp_buffer = NULL;", "   rar->unp_offset = 0;", "   rar->unp_buffer_size = UNP_BUFFER_SIZE;", "   memset(rar->lengthtable, 0, sizeof(rar->lengthtable));", "   __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context);", "   rar->ppmd_valid = rar->ppmd_eod = 0;", "   if (head_type == NEWSUB_HEAD)", "     return ret;", "   archive_entry_set_mtime(entry, rar->mtime, rar->mnsec);", "   archive_entry_set_ctime(entry, rar->ctime, rar->cnsec);", "   archive_entry_set_atime(entry, rar->atime, rar->ansec);", "   archive_entry_set_size(entry, rar->unp_size);", "   archive_entry_set_mode(entry, rar->mode);", "   if (archive_entry_copy_pathname_l(entry, filename, filename_size, fn_sconv))", "   {", "     if (errno == ENOMEM)", "     {", "       archive_set_error(&a->archive, ENOMEM,", "                         \"Can't allocate memory for Pathname\");", "       return (ARCHIVE_FATAL);", "     }", "     archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", "                       \"Pathname cannot be converted from %s to current locale.\",", "                       archive_string_conversion_charset_name(fn_sconv));", "     ret = (ARCHIVE_WARN);", "   }", "   if (((rar->mode) & AE_IFMT) == AE_IFLNK)", "   {", "     rar->bytes_remaining = 0;", "     archive_entry_set_size(entry, 0);", "     if ((ret2 = read_symlink_stored(a, entry, sconv)) < (ARCHIVE_WARN))", "       return ret2;", "     if (ret > ret2)", "       ret = ret2;", "   }", "   if (rar->bytes_remaining == 0)", "     rar->entry_eof = 1;", "   return ret;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  int jas_stream_pad(jas_stream_t *stream, int n, int c)", "  {", "  \tint m;", " \tif (n < 0) {", " \t\tjas_deprecated(\"negative count for jas_stream_pad\");", " \t}", "  \tm = n;", "  \tfor (m = n; m > 0; --m) {", "  \t\tif (jas_stream_putc(stream, c) == EOF)", " \t\t\treturn n - m;", " \t}", " \treturn n;", " }"], "ner_tags": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" ProcDbeGetVisualInfo(ClientPtr client)", " {", "     REQUEST(xDbeGetVisualInfoReq);", "     DbeScreenPrivPtr pDbeScreenPriv;", "     xDbeGetVisualInfoReply rep;", "     Drawable *drawables;", "     DrawablePtr *pDrawables = NULL;", "     register int i, j, rc;", "     register int count;          ", "     register int length;         ", "     ScreenPtr pScreen;", "      XdbeScreenVisualInfo *pScrVisInfo;", "      REQUEST_AT_LEAST_SIZE(xDbeGetVisualInfoReq);", "     if (stuff->n > UINT32_MAX / sizeof(CARD32))", "         return BadLength;", "     REQUEST_FIXED_SIZE(xDbeGetVisualInfoReq, stuff->n * sizeof(CARD32));", "      if (stuff->n > UINT32_MAX / sizeof(DrawablePtr))", "          return BadAlloc;", "             return BadAlloc;", "         }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": [" int m_authenticate(struct Client* cptr, struct Client* sptr, int parc, char* parv[])", " {", "   struct Client* acptr;", "   int first = 0;", "   char realhost[HOSTLEN + 3];", "   char *hoststr = (cli_sockhost(cptr) ? cli_sockhost(cptr) : cli_sock_ip(cptr));", "   if (!CapActive(cptr, CAP_SASL))", "     return 0;", "   if (parc < 2)  ", "     return need_more_params(cptr, \"AUTHENTICATE\");", "   if (strlen(parv[1]) > 400)", "     return send_reply(cptr, ERR_SASLTOOLONG);", "   if (IsSASLComplete(cptr))", "     return send_reply(cptr, ERR_SASLALREADY);", "   if (!(acptr = cli_saslagent(cptr))) {", "     if (strcmp(feature_str(FEAT_SASL_SERVER), \"*\"))", "       acptr = find_match_server((char *)feature_str(FEAT_SASL_SERVER));", "     else", "       acptr = NULL;", "   }", "   if (!acptr && strcmp(feature_str(FEAT_SASL_SERVER), \"*\"))", "     return send_reply(cptr, ERR_SASLFAIL, \": service unavailable\");", "   if (acptr && IsMe(acptr))", "     return 0;", "   if (!cli_saslcookie(cptr)) {", "     do {", "       cli_saslcookie(cptr) = ircrandom() & 0x7fffffff;", "     } while (!cli_saslcookie(cptr));", "     first = 1;", "   }", "   if (strchr(hoststr, ':') != NULL)", "     ircd_snprintf(0, realhost, sizeof(realhost), \"[%s]\", hoststr);", "   else", "     ircd_strncpy(realhost, hoststr, sizeof(realhost));", "    if (acptr) {", "      if (first) {", "       if (*parv[1] == ':' || strchr(parv[1], ' '))", " \t\treturn exit_client(cptr, sptr, sptr, \"Malformed AUTHENTICATE\");", "        if (!EmptyString(cli_sslclifp(cptr)))", "          sendcmdto_one(&me, CMD_SASL, acptr, \"%C %C!%u.%u S %s :%s\", acptr, &me,", "                        cli_fd(cptr), cli_saslcookie(cptr),", "                       parv[1], cli_sslclifp(cptr));", "       else", "         sendcmdto_one(&me, CMD_SASL, acptr, \"%C %C!%u.%u S :%s\", acptr, &me,", "                       cli_fd(cptr), cli_saslcookie(cptr), parv[1]);", "       if (feature_bool(FEAT_SASL_SENDHOST))", "         sendcmdto_one(&me, CMD_SASL, acptr, \"%C %C!%u.%u H :%s@%s:%s\", acptr, &me,", "                       cli_fd(cptr), cli_saslcookie(cptr), cli_username(cptr),", "                       realhost, cli_sock_ip(cptr));", "     } else {", "       sendcmdto_one(&me, CMD_SASL, acptr, \"%C %C!%u.%u C :%s\", acptr, &me,", "                     cli_fd(cptr), cli_saslcookie(cptr), parv[1]);", "      }", "    } else {", "      if (first) {", "       if (*parv[1] == ':' || strchr(parv[1], ' '))", "         return exit_client(cptr, sptr, sptr, \"Malformed AUTHENTICATE\");", "        if (!EmptyString(cli_sslclifp(cptr)))", "          sendcmdto_serv_butone(&me, CMD_SASL, cptr, \"* %C!%u.%u S %s :%s\", &me,", "                                cli_fd(cptr), cli_saslcookie(cptr),", "                               parv[1], cli_sslclifp(cptr));", "       else", "         sendcmdto_serv_butone(&me, CMD_SASL, cptr, \"* %C!%u.%u S :%s\", &me,", "                               cli_fd(cptr), cli_saslcookie(cptr), parv[1]);", "       if (feature_bool(FEAT_SASL_SENDHOST))", "         sendcmdto_serv_butone(&me, CMD_SASL, cptr, \"* %C!%u.%u H :%s@%s:%s\", &me,", "                               cli_fd(cptr), cli_saslcookie(cptr), cli_username(cptr),", "                               realhost, cli_sock_ip(cptr));", "     } else {", "       sendcmdto_serv_butone(&me, CMD_SASL, cptr, \"* %C!%u.%u C :%s\", &me,", "                             cli_fd(cptr), cli_saslcookie(cptr), parv[1]);", "     }", "   }", "   if (!t_active(&cli_sasltimeout(cptr)))", "     timer_add(timer_init(&cli_sasltimeout(cptr)), sasl_timeout_callback, (void*) cptr,", "               TT_RELATIVE, feature_int(FEAT_SASL_TIMEOUT));", "   return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" NO_INLINE JsVar *jspeFactor() {", "   if (lex->tk==LEX_ID) {", "     JsVar *a = jspGetNamedVariable(jslGetTokenValueAsString(lex));", "     JSP_ASSERT_MATCH(LEX_ID);", " #ifndef SAVE_ON_FLASH", "     if (lex->tk==LEX_TEMPLATE_LITERAL)", "       jsExceptionHere(JSET_SYNTAXERROR, \"Tagged template literals not supported\");", "     else if (lex->tk==LEX_ARROW_FUNCTION && jsvIsName(a)) {", "       JsVar *funcVar = jspeArrowFunction(0,a);", "       jsvUnLock(a);", "       a=funcVar;", "     }", " #endif", "     return a;", "   } else if (lex->tk==LEX_INT) {", "     JsVar *v = 0;", "     if (JSP_SHOULD_EXECUTE) {", "       v = jsvNewFromLongInteger(stringToInt(jslGetTokenValueAsString(lex)));", "     }", "     JSP_ASSERT_MATCH(LEX_INT);", "     return v;", "   } else if (lex->tk==LEX_FLOAT) {", "     JsVar *v = 0;", "     if (JSP_SHOULD_EXECUTE) {", "       v = jsvNewFromFloat(stringToFloat(jslGetTokenValueAsString(lex)));", "     }", "     JSP_ASSERT_MATCH(LEX_FLOAT);", "     return v;", "   } else if (lex->tk=='(') {", "     JSP_ASSERT_MATCH('(');", "     if (!jspCheckStackPosition()) return 0;", " #ifdef SAVE_ON_FLASH", "     JsVar *a = jspeExpression();", "     if (!JSP_SHOULDNT_PARSE) JSP_MATCH_WITH_RETURN(')',a);", "     return a;", " #else", "     return jspeExpressionOrArrowFunction();", " #endif", "   } else if (lex->tk==LEX_R_TRUE) {", "     JSP_ASSERT_MATCH(LEX_R_TRUE);", "     return JSP_SHOULD_EXECUTE ? jsvNewFromBool(true) : 0;", "   } else if (lex->tk==LEX_R_FALSE) {", "     JSP_ASSERT_MATCH(LEX_R_FALSE);", "     return JSP_SHOULD_EXECUTE ? jsvNewFromBool(false) : 0;", "   } else if (lex->tk==LEX_R_NULL) {", "     JSP_ASSERT_MATCH(LEX_R_NULL);", "     return JSP_SHOULD_EXECUTE ? jsvNewWithFlags(JSV_NULL) : 0;", "   } else if (lex->tk==LEX_R_UNDEFINED) {", "     JSP_ASSERT_MATCH(LEX_R_UNDEFINED);", "     return 0;", "   } else if (lex->tk==LEX_STR) {", "     JsVar *a = 0;", "     if (JSP_SHOULD_EXECUTE)", "       a = jslGetTokenValueAsVar(lex);", "     JSP_ASSERT_MATCH(LEX_STR);", "     return a;", " #ifndef SAVE_ON_FLASH", "   } else if (lex->tk==LEX_TEMPLATE_LITERAL) {", "     return jspeTemplateLiteral();", " #endif", "   } else if (lex->tk==LEX_REGEX) {", "     JsVar *a = 0;", " #ifdef SAVE_ON_FLASH", "     jsExceptionHere(JSET_SYNTAXERROR, \"RegEx are not supported in this version of Espruino\\n\");", " #else", "     JsVar *regex = jslGetTokenValueAsVar(lex);", "     size_t regexEnd = 0, regexLen = 0;", "     JsvStringIterator it;", "     jsvStringIteratorNew(&it, regex, 0);", "     while (jsvStringIteratorHasChar(&it)) {", "       regexLen++;", "       if (jsvStringIteratorGetChar(&it)=='/')", "         regexEnd = regexLen;", "       jsvStringIteratorNext(&it);", "     }", "     jsvStringIteratorFree(&it);", "     JsVar *flags = 0;", "     if (regexEnd < regexLen)", "       flags = jsvNewFromStringVar(regex, regexEnd, JSVAPPENDSTRINGVAR_MAXLENGTH);", "     JsVar *regexSource = jsvNewFromStringVar(regex, 1, regexEnd-2);", "     a = jswrap_regexp_constructor(regexSource, flags);", "     jsvUnLock3(regex, flags, regexSource);", " #endif", "     JSP_ASSERT_MATCH(LEX_REGEX);", "     return a;", "   } else if (lex->tk=='{') {", "     if (!jspCheckStackPosition()) return 0;", "     return jspeFactorObject();", "   } else if (lex->tk=='[') {", "     if (!jspCheckStackPosition()) return 0;", "     return jspeFactorArray();", "   } else if (lex->tk==LEX_R_FUNCTION) {", "     if (!jspCheckStackPosition()) return 0;", "     JSP_ASSERT_MATCH(LEX_R_FUNCTION);", "     return jspeFunctionDefinition(true);", " #ifndef SAVE_ON_FLASH", "   } else if (lex->tk==LEX_R_CLASS) {", "     if (!jspCheckStackPosition()) return 0;", "     JSP_ASSERT_MATCH(LEX_R_CLASS);", "     return jspeClassDefinition(true);", "   } else if (lex->tk==LEX_R_SUPER) {", "     JSP_ASSERT_MATCH(LEX_R_SUPER);", "     if (jsvIsObject(execInfo.thisVar)) {", "       JsVar *proto1 = jsvObjectGetChild(execInfo.thisVar, JSPARSE_INHERITS_VAR, 0);  ", "       JsVar *proto2 = jsvIsObject(proto1) ? jsvObjectGetChild(proto1, JSPARSE_INHERITS_VAR, 0) : 0;  ", "       jsvUnLock(proto1);", "       if (!proto2) {", "         jsExceptionHere(JSET_SYNTAXERROR, \"Calling 'super' outside of class\");", "         return 0;", "       }", "       if (lex->tk=='(') return proto2;  ", "       JsVar *proto3 = jsvIsFunction(proto2) ? jsvObjectGetChild(proto2, JSPARSE_PROTOTYPE_VAR, 0) : 0;", "       jsvUnLock(proto2);", "       return proto3;", "     } else if (jsvIsFunction(execInfo.thisVar)) {", "       JsVar *proto1 = jsvObjectGetChild(execInfo.thisVar, JSPARSE_PROTOTYPE_VAR, 0);", "       JsVar *proto2 = jsvIsObject(proto1) ? jsvObjectGetChild(proto1, JSPARSE_INHERITS_VAR, 0) : 0;", "       jsvUnLock(proto1);", "       if (!proto2) {", "         jsExceptionHere(JSET_SYNTAXERROR, \"Calling 'super' outside of class\");", "         return 0;", "       }", "       return proto2;", "     }", "     jsExceptionHere(JSET_SYNTAXERROR, \"Calling 'super' outside of class\");", "     return 0;", " #endif", "   } else if (lex->tk==LEX_R_THIS) {", "     JSP_ASSERT_MATCH(LEX_R_THIS);", "     return jsvLockAgain( execInfo.thisVar ? execInfo.thisVar : execInfo.root );", "   } else if (lex->tk==LEX_R_DELETE) {", "     if (!jspCheckStackPosition()) return 0;", "     return jspeFactorDelete();", "   } else if (lex->tk==LEX_R_TYPEOF) {", "     if (!jspCheckStackPosition()) return 0;", "     return jspeFactorTypeOf();", "   } else if (lex->tk==LEX_R_VOID) {", "     if (!jspCheckStackPosition()) return 0;", "     JSP_ASSERT_MATCH(LEX_R_VOID);", "     jsvUnLock(jspeUnaryExpression());", "     return 0;", "   }", "   JSP_MATCH(LEX_EOF);", "   jsExceptionHere(JSET_SYNTAXERROR, \"Unexpected end of Input\\n\");", "   return 0;", " }", " NO_INLINE JsVar *__jspePostfixExpression(JsVar *a) {", "   while (lex->tk==LEX_PLUSPLUS || lex->tk==LEX_MINUSMINUS) {", "     int op = lex->tk;", "     JSP_ASSERT_MATCH(op);", "     if (JSP_SHOULD_EXECUTE) {", "       JsVar *one = jsvNewFromInteger(1);", "       JsVar *oldValue = jsvAsNumberAndUnLock(jsvSkipName(a));  ", "       JsVar *res = jsvMathsOpSkipNames(oldValue, one, op==LEX_PLUSPLUS ? '+' : '-');", "       jsvUnLock(one);", "       jspReplaceWith(a, res);", "       jsvUnLock(res);", "       jsvUnLock(a);", "       a = oldValue;", "     }", "   }", "   return a;", " }", " NO_INLINE JsVar *jspePostfixExpression() {", "   JsVar *a;", "   if (lex->tk==LEX_PLUSPLUS || lex->tk==LEX_MINUSMINUS) {", "     int op = lex->tk;", "     JSP_ASSERT_MATCH(op);", "     a = jspePostfixExpression();", "     if (JSP_SHOULD_EXECUTE) {", "       JsVar *one = jsvNewFromInteger(1);", "       JsVar *res = jsvMathsOpSkipNames(a, one, op==LEX_PLUSPLUS ? '+' : '-');", "       jsvUnLock(one);", "       jspReplaceWith(a, res);", "       jsvUnLock(res);", "     }", "   } else", "     a = jspeFactorFunctionCall();", "   return __jspePostfixExpression(a);", " }", " NO_INLINE JsVar *jspeUnaryExpression() {", "   if (lex->tk=='!' || lex->tk=='~' || lex->tk=='-' || lex->tk=='+') {", "     short tk = lex->tk;", "     JSP_ASSERT_MATCH(tk);", "     if (!JSP_SHOULD_EXECUTE) {", "       return jspeUnaryExpression();", "     }", "     if (tk=='!') {  ", "       return jsvNewFromBool(!jsvGetBoolAndUnLock(jsvSkipNameAndUnLock(jspeUnaryExpression())));", "     } else if (tk=='~') {  ", "       return jsvNewFromInteger(~jsvGetIntegerAndUnLock(jsvSkipNameAndUnLock(jspeUnaryExpression())));", "     } else if (tk=='-') {  ", "       return jsvNegateAndUnLock(jspeUnaryExpression());  ", "     }  else if (tk=='+') {  ", "       JsVar *v = jsvSkipNameAndUnLock(jspeUnaryExpression());", "       JsVar *r = jsvAsNumber(v);  ", "       jsvUnLock(v);", "       return r;", "     }", "     assert(0);", "     return 0;", "   } else", "     return jspePostfixExpression();", " }", " unsigned int jspeGetBinaryExpressionPrecedence(int op) {", "   switch (op) {", "   case LEX_OROR: return 1; break;", "   case LEX_ANDAND: return 2; break;", "   case '|' : return 3; break;", "   case '^' : return 4; break;", "   case '&' : return 5; break;", "   case LEX_EQUAL:", "   case LEX_NEQUAL:", "   case LEX_TYPEEQUAL:", "   case LEX_NTYPEEQUAL: return 6;", "   case LEX_LEQUAL:", "   case LEX_GEQUAL:", "   case '<':", "   case '>':", "   case LEX_R_INSTANCEOF: return 7;", "   case LEX_R_IN: return (execInfo.execute&EXEC_FOR_INIT)?0:7;", "   case LEX_LSHIFT:", "   case LEX_RSHIFT:", "   case LEX_RSHIFTUNSIGNED: return 8;", "   case '+':", "   case '-': return 9;", "   case '*':", "   case '/':", "   case '%': return 10;", "   default: return 0;", "   }", " }", " NO_INLINE JsVar *__jspeBinaryExpression(JsVar *a, unsigned int lastPrecedence) {", "   unsigned int precedence = jspeGetBinaryExpressionPrecedence(lex->tk);", "   while (precedence && precedence>lastPrecedence) {", "     int op = lex->tk;", "     JSP_ASSERT_MATCH(op);", "     if (op==LEX_ANDAND || op==LEX_OROR) {", "       bool aValue = jsvGetBoolAndUnLock(jsvSkipName(a));", "       if ((!aValue && op==LEX_ANDAND) ||", "           (aValue && op==LEX_OROR)) {", "         JSP_SAVE_EXECUTE();", "         jspSetNoExecute();", "         jsvUnLock(__jspeBinaryExpression(jspeUnaryExpression(),precedence));", "         JSP_RESTORE_EXECUTE();", "       } else {", "         jsvUnLock(a);", "         a = __jspeBinaryExpression(jspeUnaryExpression(),precedence);", "       }", "     } else {  ", "       JsVar *b = __jspeBinaryExpression(jspeUnaryExpression(),precedence);", "       if (JSP_SHOULD_EXECUTE) {", "         if (op==LEX_R_IN) {", "           JsVar *av = jsvSkipName(a);  ", "           JsVar *bv = jsvSkipName(b);  ", "           if (jsvIsArray(bv) || jsvIsObject(bv)) {  ", "             av = jsvAsArrayIndexAndUnLock(av);", "             JsVar *varFound = jspGetVarNamedField( bv, av, true);", "             jsvUnLock(a);", "             a = jsvNewFromBool(varFound!=0);", "             jsvUnLock(varFound);", "           } else { ", "             jsExceptionHere(JSET_ERROR, \"Cannot use 'in' operator to search a %t\", bv);", "             jsvUnLock(a);", "             a = 0;", "           }", "           jsvUnLock2(av, bv);", "         } else if (op==LEX_R_INSTANCEOF) {", "           bool inst = false;", "           JsVar *av = jsvSkipName(a);", "           JsVar *bv = jsvSkipName(b);", "           if (!jsvIsFunction(bv)) {", "             jsExceptionHere(JSET_ERROR, \"Expecting a function on RHS in instanceof check, got %t\", bv);", "           } else {", "             if (jsvIsObject(av) || jsvIsFunction(av)) {", "               JsVar *bproto = jspGetNamedField(bv, JSPARSE_PROTOTYPE_VAR, false);", "               JsVar *proto = jsvObjectGetChild(av, JSPARSE_INHERITS_VAR, 0);", "               while (proto) {", "                 if (proto == bproto) inst=true;", "                 JsVar *childProto = jsvObjectGetChild(proto, JSPARSE_INHERITS_VAR, 0);", "                 jsvUnLock(proto);", "                 proto = childProto;", "               }", "               if (jspIsConstructor(bv, \"Object\")) inst = true;", "               jsvUnLock(bproto);", "             }", "             if (!inst) {", "               const char *name = jswGetBasicObjectName(av);", "               if (name) {", "                 inst = jspIsConstructor(bv, name);", "               }", "               if (!inst && (jsvIsArray(av) || jsvIsArrayBuffer(av)) &&", "                   jspIsConstructor(bv, \"Object\"))", "                 inst = true;", "             }", "           }", "           jsvUnLock3(av, bv, a);", "           a = jsvNewFromBool(inst);", "         } else {   ", "           JsVar *res = jsvMathsOpSkipNames(a, b, op);", "           jsvUnLock(a); a = res;", "         }", "       }", "       jsvUnLock(b);", "     }", "     precedence = jspeGetBinaryExpressionPrecedence(lex->tk);", "   }", "   return a;", " }", " JsVar *jspeBinaryExpression() {", "   return __jspeBinaryExpression(jspeUnaryExpression(),0);", " }", " NO_INLINE JsVar *__jspeConditionalExpression(JsVar *lhs) {", "   if (lex->tk=='?') {", "     JSP_ASSERT_MATCH('?');", "     if (!JSP_SHOULD_EXECUTE) {", "       jsvUnLock(jspeAssignmentExpression());", "       JSP_MATCH(':');", "       jsvUnLock(jspeAssignmentExpression());", "     } else {", "       bool first = jsvGetBoolAndUnLock(jsvSkipName(lhs));", "       jsvUnLock(lhs);", "       if (first) {", "         lhs = jspeAssignmentExpression();", "         JSP_MATCH(':');", "         JSP_SAVE_EXECUTE();", "         jspSetNoExecute();", "         jsvUnLock(jspeAssignmentExpression());", "         JSP_RESTORE_EXECUTE();", "       } else {", "         JSP_SAVE_EXECUTE();", "         jspSetNoExecute();", "         jsvUnLock(jspeAssignmentExpression());", "         JSP_RESTORE_EXECUTE();", "         JSP_MATCH(':');", "         lhs = jspeAssignmentExpression();", "       }", "     }", "   }", "   return lhs;", " }", " JsVar *jspeConditionalExpression() {", "   return __jspeConditionalExpression(jspeBinaryExpression());", " }", " NO_INLINE JsVar *__jspeAssignmentExpression(JsVar *lhs) {", "   if (lex->tk=='=' || lex->tk==LEX_PLUSEQUAL || lex->tk==LEX_MINUSEQUAL ||", "       lex->tk==LEX_MULEQUAL || lex->tk==LEX_DIVEQUAL || lex->tk==LEX_MODEQUAL ||", "       lex->tk==LEX_ANDEQUAL || lex->tk==LEX_OREQUAL ||", "       lex->tk==LEX_XOREQUAL || lex->tk==LEX_RSHIFTEQUAL ||", "       lex->tk==LEX_LSHIFTEQUAL || lex->tk==LEX_RSHIFTUNSIGNEDEQUAL) {", "     JsVar *rhs;", "     int op = lex->tk;", "     JSP_ASSERT_MATCH(op);", "     rhs = jspeAssignmentExpression();", "     rhs = jsvSkipNameAndUnLock(rhs);  ", "      if (JSP_SHOULD_EXECUTE && lhs) {", "        if (op=='=') {", "        if (!jsvGetRefs(lhs) && jsvIsName(lhs)) {", "          if (!jsvIsArrayBufferName(lhs) && !jsvIsNewChild(lhs))", "            jsvAddName(execInfo.root, lhs);", "        }", "        jspReplaceWith(lhs, rhs);", "         jspReplaceWithOrAddToRoot(lhs, rhs);", "        } else {", "          if (op==LEX_PLUSEQUAL) op='+';", "          else if (op==LEX_MINUSEQUAL) op='-';", "         else if (op==LEX_MULEQUAL) op='*';", "         else if (op==LEX_DIVEQUAL) op='/';", "         else if (op==LEX_MODEQUAL) op='%';", "         else if (op==LEX_ANDEQUAL) op='&';", "         else if (op==LEX_OREQUAL) op='|';", "         else if (op==LEX_XOREQUAL) op='^';", "         else if (op==LEX_RSHIFTEQUAL) op=LEX_RSHIFT;", "         else if (op==LEX_LSHIFTEQUAL) op=LEX_LSHIFT;", "         else if (op==LEX_RSHIFTUNSIGNEDEQUAL) op=LEX_RSHIFTUNSIGNED;", "         if (op=='+' && jsvIsName(lhs)) {", "           JsVar *currentValue = jsvSkipName(lhs);", "           if (jsvIsString(currentValue) && !jsvIsFlatString(currentValue) && jsvGetRefs(currentValue)==1 && rhs!=currentValue) {", "             JsVar *str = jsvAsString(rhs, false);", "             jsvAppendStringVarComplete(currentValue, str);", "             jsvUnLock(str);", "             op = 0;", "           }", "           jsvUnLock(currentValue);", "         }", "         if (op) {", "           JsVar *res = jsvMathsOpSkipNames(lhs,rhs,op);", "           jspReplaceWith(lhs, res);", "           jsvUnLock(res);", "         }", "       }", "     }", "     jsvUnLock(rhs);", "   }", "   return lhs;", " }", " JsVar *jspeAssignmentExpression() {", "   return __jspeAssignmentExpression(jspeConditionalExpression());", " }", " NO_INLINE JsVar *jspeExpression() {", "   while (!JSP_SHOULDNT_PARSE) {", "     JsVar *a = jspeAssignmentExpression();", "     if (lex->tk!=',') return a;", "     jsvCheckReferenceError(a);", "     jsvUnLock(a);", "     JSP_ASSERT_MATCH(',');", "   }", "   return 0;", " }", " NO_INLINE void jspeBlockNoBrackets() {", "   if (JSP_SHOULD_EXECUTE) {", "     while (lex->tk && lex->tk!='}') {", "       JsVar *a = jspeStatement();", "       jsvCheckReferenceError(a);", "       jsvUnLock(a);", "       if (JSP_HAS_ERROR) {", "         if (lex && !(execInfo.execute&EXEC_ERROR_LINE_REPORTED)) {", "           execInfo.execute = (JsExecFlags)(execInfo.execute | EXEC_ERROR_LINE_REPORTED);", "           JsVar *stackTrace = jsvObjectGetChild(execInfo.hiddenRoot, JSPARSE_STACKTRACE_VAR, JSV_STRING_0);", "           if (stackTrace) {", "             jsvAppendPrintf(stackTrace, \"at \");", "             jspAppendStackTrace(stackTrace);", "             jsvUnLock(stackTrace);", "           }", "         }", "       }", "       if (JSP_SHOULDNT_PARSE)", "         return;", "     }", "   } else {", "     int brackets = 0;", "     while (lex->tk && (brackets || lex->tk != '}')) {", "       if (lex->tk == '{') brackets++;", "       if (lex->tk == '}') brackets--;", "       JSP_ASSERT_MATCH(lex->tk);", "     }", "   }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int jas_stream_read(jas_stream_t *stream, void *buf, int cnt)", " {", " \tint n;", "  \tint c;", "  \tchar *bufptr;", " \tif (cnt < 0) {", " \t\tjas_deprecated(\"negative count for jas_stream_read\");", " \t}", "  \tbufptr = buf;", "  \tn = 0;", " \twhile (n < cnt) {", " \t\tif ((c = jas_stream_getc(stream)) == EOF) {", " \t\t\treturn n;", " \t\t}", " \t\t*bufptr++ = c;", " \t\t++n;", " \t}", " \treturn n;", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static uint32_t color_string_to_rgba(const char *p, int len)", " {", "     uint32_t ret = 0xFF000000;", "      const ColorEntry *entry;", "      char color_name[100];", "     len = FFMIN(FFMAX(len, 0), sizeof(color_name) - 1);", "      if (*p == '#') {", "          p++;", "          len--;", "         if (len == 3) {", "             ret |= (hex_char_to_number(p[2]) <<  4) |", "                    (hex_char_to_number(p[1]) << 12) |", "                    (hex_char_to_number(p[0]) << 20);", "         } else if (len == 4) {", "             ret  = (hex_char_to_number(p[3]) <<  4) |", "                    (hex_char_to_number(p[2]) << 12) |", "                    (hex_char_to_number(p[1]) << 20) |", "                    (hex_char_to_number(p[0]) << 28);", "         } else if (len == 6) {", "             ret |=  hex_char_to_number(p[5])        |", "                    (hex_char_to_number(p[4]) <<  4) |", "                    (hex_char_to_number(p[3]) <<  8) |", "                    (hex_char_to_number(p[2]) << 12) |", "                    (hex_char_to_number(p[1]) << 16) |", "                    (hex_char_to_number(p[0]) << 20);", "         } else if (len == 8) {", "             ret  =  hex_char_to_number(p[7])        |", "                    (hex_char_to_number(p[6]) <<  4) |", "                    (hex_char_to_number(p[5]) <<  8) |", "                    (hex_char_to_number(p[4]) << 12) |", "                    (hex_char_to_number(p[3]) << 16) |", "                    (hex_char_to_number(p[2]) << 20) |", "                    (hex_char_to_number(p[1]) << 24) |", "                    (hex_char_to_number(p[0]) << 28);", "         }", "     } else {", "         strncpy(color_name, p, len);", "         color_name[len] = '\\0';", "         entry = bsearch(color_name,", "                         color_table,", "                         FF_ARRAY_ELEMS(color_table),", "                         sizeof(ColorEntry),", "                         color_table_compare);", "         if (!entry)", "             return ret;", "         ret = entry->rgb_color;", "     }", "     return ret;", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" rdp_in_unistr(STREAM s, int in_len, char **string, uint32 * str_size)", " {", " \tstatic iconv_t icv_utf16_to_local;", "  \tsize_t ibl, obl;", "  \tchar *pin, *pout;", " \tstruct stream packet = *s;", " \tif ((in_len < 0) || ((uint32)in_len >= (RD_UINT32_MAX / 2)))", " \t{", " \t\tlogger(Protocol, Error, \"rdp_in_unistr(), length of unicode data is out of bounds.\");", " \t\tabort();", " \t}", " \tif (!s_check_rem(s, in_len))", " \t{", " \t\trdp_protocol_error(\"rdp_in_unistr(), consume of unicode data from stream would overrun\", &packet);", " \t}", "  \tif (!icv_utf16_to_local)", "  \t{", " \t\ticv_utf16_to_local = iconv_open(g_codepage, WINDOWS_CODEPAGE);", " \t\tif (icv_utf16_to_local == (iconv_t) - 1)", " \t\t{", " \t\t\tlogger(Protocol, Error, \"rdp_in_unistr(), iconv_open[%s -> %s] fail %p\",", " \t\t\t       WINDOWS_CODEPAGE, g_codepage, icv_utf16_to_local);", " \t\t\tabort();", " \t\t}", " \t}", " \tif (*string == NULL)", " \t{", " \t\t*string = xmalloc(in_len * 2);", " \t\t*str_size = in_len * 2;", " \t}", " \tibl = in_len;", " \tobl = *str_size - 1;", " \tpin = (char *) s->p;", " \tpout = *string;", " \tif (iconv(icv_utf16_to_local, (char **) &pin, &ibl, &pout, &obl) == (size_t) - 1)", " \t{", " \t\tif (errno == E2BIG)", " \t\t{", " \t\t\tlogger(Protocol, Warning,", " \t\t\t       \"rdp_in_unistr(), server sent an unexpectedly long string, truncating\");", " \t\t}", " \t\telse", " \t\t{", " \t\t\tlogger(Protocol, Warning, \"rdp_in_unistr(), iconv fail, errno %d\", errno);", " \t\t\tfree(*string);", " \t\t\t*string = NULL;", " \t\t\t*str_size = 0;", " \t\t}", " \t\tabort();", " \t}", " \ts->p += in_len;", " \t*pout = 0;", " \tif (*string)", " \t\t*str_size = pout - *string;", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" archive_acl_from_text_l(struct archive_acl *acl, const char *text,", "     int want_type, struct archive_string_conv *sc)", " {", " \tstruct {", " \t\tconst char *start;", " \t\tconst char *end;", " \t} field[6], name;", " \tconst char *s, *st;", " \tint numfields, fields, n, r, sol, ret;", " \tint type, types, tag, permset, id;", " \tsize_t len;", " \tchar sep;", " \tswitch (want_type) {", " \tcase ARCHIVE_ENTRY_ACL_TYPE_POSIX1E:", " \t\twant_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;", " \t\t__LA_FALLTHROUGH;", " \tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:", " \tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:", " \t\tnumfields = 5;", " \t\tbreak;", " \tcase ARCHIVE_ENTRY_ACL_TYPE_NFS4:", " \t\tnumfields = 6;", " \t\tbreak;", " \tdefault:", " \t\treturn (ARCHIVE_FATAL);", " \t}", " \tret = ARCHIVE_OK;", " \ttypes = 0;", " \twhile (text != NULL &&  *text != '\\0') {", " \t\tfields = 0;", " \t\tdo {", " \t\t\tconst char *start, *end;", " \t\t\tnext_field(&text, &start, &end, &sep);", " \t\t\tif (fields < numfields) {", " \t\t\t\tfield[fields].start = start;", " \t\t\t\tfield[fields].end = end;", " \t\t\t}", " \t\t\t++fields;", " \t\t} while (sep == ':');", " \t\tfor (n = fields; n < numfields; ++n)", " \t\t\tfield[n].start = field[n].end = NULL;", " \t\tif (field[0].start != NULL && *(field[0].start) == '#') {", " \t\t\tcontinue;", " \t\t}", " \t\tn = 0;", " \t\tsol = 0;", " \t\tid = -1;", " \t\tpermset = 0;", " \t\tname.start = name.end = NULL;", " \t\tif (want_type != ARCHIVE_ENTRY_ACL_TYPE_NFS4) {", " \t\t\ts = field[0].start;", " \t\t\tlen = field[0].end - field[0].start;", " \t\t\tif (*s == 'd' && (len == 1 || (len >= 7", " \t\t\t    && memcmp((s + 1), \"efault\", 6) == 0))) {", " \t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_DEFAULT;", " \t\t\t\tif (len > 7)", " \t\t\t\t\tfield[0].start += 7;", " \t\t\t\telse", " \t\t\t\t\tn = 1;", " \t\t\t} else", " \t\t\t\ttype = want_type;", " \t\t\tisint(field[n + 1].start, field[n + 1].end, &id);", " \t\t\tif (id == -1 && fields > (n + 3))", " \t\t\t\tisint(field[n + 3].start, field[n + 3].end,", " \t\t\t\t    &id);", " \t\t\ttag = 0;", " \t\t\ts = field[n].start;", "  \t\t\tst = field[n].start + 1;", "  \t\t\tlen = field[n].end - field[n].start;", " \t\t\tif (len == 0) {", " \t\t\t\tret = ARCHIVE_WARN;", " \t\t\t\tcontinue;", " \t\t\t}", "  \t\t\tswitch (*s) {", "  \t\t\tcase 'u':", "  \t\t\t\tif (len == 1 || (len == 4", " \t\t\t\t    && memcmp(st, \"ser\", 3) == 0))", " \t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER_OBJ;", " \t\t\t\tbreak;", " \t\t\tcase 'g':", " \t\t\t\tif (len == 1 || (len == 5", " \t\t\t\t    && memcmp(st, \"roup\", 4) == 0))", " \t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;", " \t\t\t\tbreak;", " \t\t\tcase 'o':", " \t\t\t\tif (len == 1 || (len == 5", " \t\t\t\t    && memcmp(st, \"ther\", 4) == 0))", " \t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_OTHER;", " \t\t\t\tbreak;", " \t\t\tcase 'm':", " \t\t\t\tif (len == 1 || (len == 4", " \t\t\t\t    && memcmp(st, \"ask\", 3) == 0))", " \t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_MASK;", " \t\t\t\tbreak;", " \t\t\tdefault:", " \t\t\t\t\tbreak;", " \t\t\t}", " \t\t\tswitch (tag) {", " \t\t\tcase ARCHIVE_ENTRY_ACL_OTHER:", " \t\t\tcase ARCHIVE_ENTRY_ACL_MASK:", " \t\t\t\tif (fields == (n + 2)", " \t\t\t\t    && field[n + 1].start < field[n + 1].end", " \t\t\t\t    && ismode(field[n + 1].start,", " \t\t\t\t    field[n + 1].end, &permset)) {", " \t\t\t\t\tsol = 1;", " \t\t\t\t} else if (fields == (n + 3) &&", " \t\t\t\t    field[n + 1].start < field[n + 1].end) {", " \t\t\t\t\tret = ARCHIVE_WARN;", " \t\t\t\t\tcontinue;", " \t\t\t\t}", " \t\t\t\tbreak;", " \t\t\tcase ARCHIVE_ENTRY_ACL_USER_OBJ:", " \t\t\tcase ARCHIVE_ENTRY_ACL_GROUP_OBJ:", " \t\t\t\tif (id != -1 ||", " \t\t\t\t    field[n + 1].start < field[n + 1].end) {", " \t\t\t\t\tname = field[n + 1];", " \t\t\t\t\tif (tag == ARCHIVE_ENTRY_ACL_USER_OBJ)", " \t\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER;", " \t\t\t\t\telse", " \t\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP;", " \t\t\t\t}", " \t\t\t\tbreak;", " \t\t\tdefault:", " \t\t\t\tret = ARCHIVE_WARN;", " \t\t\t\tcontinue;", " \t\t\t}", " \t\t\tif (permset == 0 && !ismode(field[n + 2 - sol].start,", " \t\t\t    field[n + 2 - sol].end, &permset)) {", " \t\t\t\tret = ARCHIVE_WARN;", " \t\t\t\tcontinue;", " \t\t\t}", " \t\t} else {", " \t\t\ts = field[0].start;", " \t\t\tlen = field[0].end - field[0].start;", " \t\t\ttag = 0;", " \t\t\tswitch (len) {", " \t\t\tcase 4:", " \t\t\t\tif (memcmp(s, \"user\", 4) == 0)", " \t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER;", " \t\t\t\tbreak;", " \t\t\tcase 5:", " \t\t\t\tif (memcmp(s, \"group\", 5) == 0)", " \t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP;", " \t\t\t\tbreak;", " \t\t\tcase 6:", " \t\t\t\tif (memcmp(s, \"owner@\", 6) == 0)", " \t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER_OBJ;", " \t\t\t\telse if (memcmp(s, \"group@\", 6) == 0)", " \t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;", " \t\t\t\tbreak;", " \t\t\tcase 9:", " \t\t\t\tif (memcmp(s, \"everyone@\", 9) == 0)", " \t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_EVERYONE;", " \t\t\t\tbreak;", " \t\t\tdefault:", " \t\t\t\tbreak;", " \t\t\t}", " \t\t\tif (tag == 0) {", " \t\t\t\tret = ARCHIVE_WARN;", " \t\t\t\tcontinue;", " \t\t\t} else if (tag == ARCHIVE_ENTRY_ACL_USER ||", " \t\t\t    tag == ARCHIVE_ENTRY_ACL_GROUP) {", " \t\t\t\tn = 1;", " \t\t\t\tname = field[1];", " \t\t\t\tisint(name.start, name.end, &id);", " \t\t\t} else", " \t\t\t\tn = 0;", " \t\t\tif (!is_nfs4_perms(field[1 + n].start,", " \t\t\t    field[1 + n].end, &permset)) {", " \t\t\t\tret = ARCHIVE_WARN;", " \t\t\t\tcontinue;", " \t\t\t}", " \t\t\tif (!is_nfs4_flags(field[2 + n].start,", " \t\t\t    field[2 + n].end, &permset)) {", " \t\t\t\tret = ARCHIVE_WARN;", " \t\t\t\tcontinue;", " \t\t\t}", " \t\t\ts = field[3 + n].start;", " \t\t\tlen = field[3 + n].end - field[3 + n].start;", " \t\t\ttype = 0;", " \t\t\tif (len == 4) {", " \t\t\t\tif (memcmp(s, \"deny\", 4) == 0)", " \t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_DENY;", " \t\t\t} else if (len == 5) {", " \t\t\t\tif (memcmp(s, \"allow\", 5) == 0)", " \t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_ALLOW;", " \t\t\t\telse if (memcmp(s, \"audit\", 5) == 0)", " \t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_AUDIT;", " \t\t\t\telse if (memcmp(s, \"alarm\", 5) == 0)", " \t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_ALARM;", " \t\t\t}", " \t\t\tif (type == 0) {", " \t\t\t\tret = ARCHIVE_WARN;", " \t\t\t\tcontinue;", " \t\t\t}", " \t\t\tisint(field[4 + n].start, field[4 + n].end,", " \t\t\t    &id);", " \t\t}", " \t\tr = archive_acl_add_entry_len_l(acl, type, permset,", " \t\t    tag, id, name.start, name.end - name.start, sc);", " \t\tif (r < ARCHIVE_WARN)", " \t\t\treturn (r);", " \t\tif (r != ARCHIVE_OK)", " \t\t\tret = ARCHIVE_WARN;", " \t\ttypes |= type;", " \t}", " \tarchive_acl_reset(acl, types);", " \treturn (ret);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" tChecksumCheckResult ParaNdis_CheckRxChecksum(", "                                             PARANDIS_ADAPTER *pContext,", "                                             ULONG virtioFlags,", "                                             tCompletePhysicalAddress *pPacketPages,", "                                             ULONG ulPacketLength,", "                                              ULONG ulDataOffset)", "  {", "      tOffloadSettingsFlags f = pContext->Offload.flags;", "    tChecksumCheckResult res, resIp;", "     tChecksumCheckResult res;", "      tTcpIpPacketParsingResult ppr;", "      ULONG flagsToCalculate = 0;", "      res.value = 0;", "    resIp.value = 0;", "     if (f.fRxIPChecksum) flagsToCalculate |= pcrIpChecksum;  ", "     if (!(virtioFlags & VIRTIO_NET_HDR_F_DATA_VALID))", "     {", "         if (virtioFlags & VIRTIO_NET_HDR_F_NEEDS_CSUM)", "         {", "             flagsToCalculate |= pcrFixXxpChecksum | pcrTcpChecksum | pcrUdpChecksum;", "         }", "         else", "         {", "             if (f.fRxTCPChecksum) flagsToCalculate |= pcrTcpV4Checksum;", "             if (f.fRxUDPChecksum) flagsToCalculate |= pcrUdpV4Checksum;", "             if (f.fRxTCPv6Checksum) flagsToCalculate |= pcrTcpV6Checksum;", "             if (f.fRxUDPv6Checksum) flagsToCalculate |= pcrUdpV6Checksum;", "         }", "     }", "      ppr = ParaNdis_CheckSumVerify(pPacketPages, ulPacketLength - ETH_HEADER_SIZE, ulDataOffset + ETH_HEADER_SIZE, flagsToCalculate, __FUNCTION__);", "     if (ppr.ipCheckSum == ppresIPTooShort || ppr.xxpStatus == ppresXxpIncomplete)", "     {", "         res.flags.IpOK = FALSE;", "         res.flags.IpFailed = TRUE;", "         return res;", "     }", "      if (virtioFlags & VIRTIO_NET_HDR_F_DATA_VALID)", "      {", "          pContext->extraStatistics.framesRxCSHwOK++;", "         ppr.xxpCheckSum = ppresCSOK;", "     }", "     if (ppr.ipStatus == ppresIPV4 && !ppr.IsFragment)", "     {", "         if (f.fRxIPChecksum)", "         {", "             res.flags.IpOK =  ppr.ipCheckSum == ppresCSOK;", "             res.flags.IpFailed = ppr.ipCheckSum == ppresCSBad;", "         }", "         if(ppr.xxpStatus == ppresXxpKnown)", "         {", "             if(ppr.TcpUdp == ppresIsTCP)  ", "             {", "                 if (f.fRxTCPChecksum)", "                 {", "                     res.flags.TcpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS;", "                     res.flags.TcpFailed = !res.flags.TcpOK;", "                 }", "             }", "             else  ", "             {", "                 if (f.fRxUDPChecksum)", "                 {", "                     res.flags.UdpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS;", "                     res.flags.UdpFailed = !res.flags.UdpOK;", "                 }", "             }", "         }", "     }", "     else if (ppr.ipStatus == ppresIPV6)", "     {", "         if(ppr.xxpStatus == ppresXxpKnown)", "         {", "             if(ppr.TcpUdp == ppresIsTCP)  ", "             {", "                 if (f.fRxTCPv6Checksum)", "                 {", "                     res.flags.TcpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS;", "                     res.flags.TcpFailed = !res.flags.TcpOK;", "                 }", "             }", "             else  ", "             {", "                 if (f.fRxUDPv6Checksum)", "                 {", "                     res.flags.UdpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS;", "                     res.flags.UdpFailed = !res.flags.UdpOK;", "                 }", "             }", "         }", "     }", "     return res;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int asepcos_parse_sec_attr(sc_card_t *card, sc_file_t *file, const u8 *buf,", " \tsize_t len)", " {", " \tconst u8 *p = buf;", "  \twhile (len != 0) {", "  \t\tunsigned int amode, tlen = 3;", "\t\tif (len < 5 && p[0] != 0x80 && p[1] != 0x01) {", " \t\tif (len < 5 || p[0] != 0x80 || p[1] != 0x01) {", "  \t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, \"invalid access mode encoding\");", "  \t\t\treturn SC_ERROR_INTERNAL;", "  \t\t}", " \t\tamode = p[2];", " \t\tif (p[3] == 0x90 && p[4] == 0x00) {", " \t\t\tint r = set_sec_attr(file, amode, 0, SC_AC_NONE);", " \t\t\tif (r != SC_SUCCESS) ", " \t\t\t\treturn r;", " \t\t\ttlen += 2;", " \t\t} else if (p[3] == 0x97 && p[4] == 0x00) {", " \t\t\tint r = set_sec_attr(file, amode, 0, SC_AC_NEVER);", " \t\t\tif (r != SC_SUCCESS) ", " \t\t\t\treturn r;", " \t\t\ttlen += 2;", " \t\t} else if (p[3] == 0xA0 && len >= 4U + p[4]) {", " \t\t\tint r = set_sec_attr(file, amode, p[5], SC_AC_CHV);", " \t\t\tif (r != SC_SUCCESS)", " \t\t\t\treturn r;", " \t\t\ttlen += 2 + p[4];  ", " \t\t} else if (p[3] == 0xAF && len >= 4U + p[4]) {", " \t\t\tint r = set_sec_attr(file, amode, p[5], SC_AC_CHV);", " \t\t\tif (r != SC_SUCCESS)", " \t\t\t\treturn r;", " \t\t\ttlen += 2 + p[4];\t ", " \t\t} else {", " \t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, \"invalid security condition\");", " \t\t\treturn SC_ERROR_INTERNAL;", " \t\t}", " \t\tp   += tlen;", " \t\tlen -= tlen;", " \t}", " \treturn SC_SUCCESS;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  SProcXFixesChangeSaveSet(ClientPtr client)", "  {", "      REQUEST(xXFixesChangeSaveSetReq);", "     REQUEST_SIZE_MATCH(xXFixesChangeSaveSetReq);", "      swaps(&stuff->length);", "      swapl(&stuff->window);", " }"], "ner_tags": [0, 0, 0, 1, 0, 0, 0]}
{"tokens": [" static pngquant_error rwpng_read_image24_libpng(FILE *infile, png24_image *mainprog_ptr, int verbose)", " {", "     png_structp  png_ptr = NULL;", "     png_infop    info_ptr = NULL;", "     png_size_t   rowbytes;", "     int          color_type, bit_depth;", "     png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, mainprog_ptr,", "       rwpng_error_handler, verbose ? rwpng_warning_stderr_handler : rwpng_warning_silent_handler);", "     if (!png_ptr) {", "         return PNG_OUT_OF_MEMORY_ERROR;    ", "     }", "     info_ptr = png_create_info_struct(png_ptr);", "     if (!info_ptr) {", "         png_destroy_read_struct(&png_ptr, NULL, NULL);", "         return PNG_OUT_OF_MEMORY_ERROR;    ", "     }", "     if (setjmp(mainprog_ptr->jmpbuf)) {", "         png_destroy_read_struct(&png_ptr, &info_ptr, NULL);", "         return LIBPNG_FATAL_ERROR;    ", "     }", " #if defined(PNG_SKIP_sRGB_CHECK_PROFILE) && defined(PNG_SET_OPTION_SUPPORTED)", "     png_set_option(png_ptr, PNG_SKIP_sRGB_CHECK_PROFILE, PNG_OPTION_ON);", " #endif", " #if PNG_LIBPNG_VER >= 10500 && defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)", "     png_set_keep_unknown_chunks(png_ptr, PNG_HANDLE_CHUNK_IF_SAFE, (png_const_bytep)\"pHYs\\0iTXt\\0tEXt\\0zTXt\", 4);", " #endif", "     png_set_read_user_chunk_fn(png_ptr, &mainprog_ptr->chunks, read_chunk_callback);", "     struct rwpng_read_data read_data = {infile, 0};", "     png_set_read_fn(png_ptr, &read_data, user_read_data);", "     png_read_info(png_ptr, info_ptr);   ", "      png_get_IHDR(png_ptr, info_ptr, &mainprog_ptr->width, &mainprog_ptr->height,", "                   &bit_depth, &color_type, NULL, NULL, NULL);", "    if (mainprog_ptr->width > INT_MAX/mainprog_ptr->height) {", "        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);", "        return PNG_OUT_OF_MEMORY_ERROR;   ", "    }", "     if (!(color_type & PNG_COLOR_MASK_ALPHA)) {", " #ifdef PNG_READ_FILLER_SUPPORTED", "         png_set_expand(png_ptr);", "         png_set_filler(png_ptr, 65535L, PNG_FILLER_AFTER);", " #else", "         fprintf(stderr, \"pngquant readpng:  image is neither RGBA nor GA\\n\");", "         png_destroy_read_struct(&png_ptr, &info_ptr, NULL);", "         mainprog_ptr->retval = WRONG_INPUT_COLOR_TYPE;", "         return mainprog_ptr->retval;", " #endif", "     }", "     if (bit_depth == 16) {", "         png_set_strip_16(png_ptr);", "     }", "     if (!(color_type & PNG_COLOR_MASK_COLOR)) {", "         png_set_gray_to_rgb(png_ptr);", "     }", "     double gamma = 0.45455;", "     if (png_get_valid(png_ptr, info_ptr, PNG_INFO_sRGB)) {", "         mainprog_ptr->input_color = RWPNG_SRGB;", "         mainprog_ptr->output_color = RWPNG_SRGB;", "     } else {", "         png_get_gAMA(png_ptr, info_ptr, &gamma);", "         if (gamma > 0 && gamma <= 1.0) {", "             mainprog_ptr->input_color = RWPNG_GAMA_ONLY;", "             mainprog_ptr->output_color = RWPNG_GAMA_ONLY;", "         } else {", "             fprintf(stderr, \"pngquant readpng:  ignored out-of-range gamma %f\\n\", gamma);", "             mainprog_ptr->input_color = RWPNG_NONE;", "             mainprog_ptr->output_color = RWPNG_NONE;", "             gamma = 0.45455;", "         }", "     }", "     mainprog_ptr->gamma = gamma;", "     png_set_interlace_handling(png_ptr);", "     png_read_update_info(png_ptr, info_ptr);", "      rowbytes = png_get_rowbytes(png_ptr, info_ptr);", "     if (rowbytes > INT_MAX/mainprog_ptr->height) {", "         png_destroy_read_struct(&png_ptr, &info_ptr, NULL);", "         return PNG_OUT_OF_MEMORY_ERROR;", "     }", "      if ((mainprog_ptr->rgba_data = malloc(rowbytes * mainprog_ptr->height)) == NULL) {", "          fprintf(stderr, \"pngquant readpng:  unable to allocate image data\\n\");", "          png_destroy_read_struct(&png_ptr, &info_ptr, NULL);", "         return PNG_OUT_OF_MEMORY_ERROR;", "     }", "     png_bytepp row_pointers = rwpng_create_row_pointers(info_ptr, png_ptr, mainprog_ptr->rgba_data, mainprog_ptr->height, 0);", "     png_read_image(png_ptr, row_pointers);", "     png_read_end(png_ptr, NULL);", " #if USE_LCMS", " #if PNG_LIBPNG_VER < 10500", "     png_charp ProfileData;", " #else", "     png_bytep ProfileData;", " #endif", "     png_uint_32 ProfileLen;", "     cmsHPROFILE hInProfile = NULL;", "     int COLOR_PNG = color_type & PNG_COLOR_MASK_COLOR;", "     if (png_get_iCCP(png_ptr, info_ptr, &(png_charp){0}, &(int){0}, &ProfileData, &ProfileLen)) {", "         hInProfile = cmsOpenProfileFromMem(ProfileData, ProfileLen);", "         cmsColorSpaceSignature colorspace = cmsGetColorSpace(hInProfile);", "         if (colorspace == cmsSigRgbData && COLOR_PNG) {", "             mainprog_ptr->input_color = RWPNG_ICCP;", "             mainprog_ptr->output_color = RWPNG_SRGB;", "         } else {", "             if (colorspace == cmsSigGrayData && !COLOR_PNG) {", "                 mainprog_ptr->input_color = RWPNG_ICCP_WARN_GRAY;", "                 mainprog_ptr->output_color = RWPNG_SRGB;", "             }", "             cmsCloseProfile(hInProfile);", "             hInProfile = NULL;", "         }", "     }", "     if (hInProfile == NULL && COLOR_PNG &&", "         !png_get_valid(png_ptr, info_ptr, PNG_INFO_sRGB) &&", "         png_get_valid(png_ptr, info_ptr, PNG_INFO_gAMA) &&", "         png_get_valid(png_ptr, info_ptr, PNG_INFO_cHRM)) {", "         cmsCIExyY WhitePoint;", "         cmsCIExyYTRIPLE Primaries;", "         png_get_cHRM(png_ptr, info_ptr, &WhitePoint.x, &WhitePoint.y,", "                      &Primaries.Red.x, &Primaries.Red.y,", "                      &Primaries.Green.x, &Primaries.Green.y,", "                      &Primaries.Blue.x, &Primaries.Blue.y);", "         WhitePoint.Y = Primaries.Red.Y = Primaries.Green.Y = Primaries.Blue.Y = 1.0;", "         cmsToneCurve *GammaTable[3];", "         GammaTable[0] = GammaTable[1] = GammaTable[2] = cmsBuildGamma(NULL, 1/gamma);", "         hInProfile = cmsCreateRGBProfile(&WhitePoint, &Primaries, GammaTable);", "         cmsFreeToneCurve(GammaTable[0]);", "         mainprog_ptr->input_color = RWPNG_GAMA_CHRM;", "         mainprog_ptr->output_color = RWPNG_SRGB;", "     }", "     if (hInProfile != NULL) {", "         cmsHPROFILE hOutProfile = cmsCreate_sRGBProfile();", "         cmsHTRANSFORM hTransform = cmsCreateTransform(hInProfile, TYPE_RGBA_8,", "                                                       hOutProfile, TYPE_RGBA_8,", "                                                       INTENT_PERCEPTUAL,", "                                                       omp_get_max_threads() > 1 ? cmsFLAGS_NOCACHE : 0);", "         #pragma omp parallel for \\", "             if (mainprog_ptr->height*mainprog_ptr->width > 8000) \\", "             schedule(static)", "         for (unsigned int i = 0; i < mainprog_ptr->height; i++) {", "             cmsDoTransform(hTransform, row_pointers[i],", "                                        row_pointers[i],", "                                        mainprog_ptr->width);", "         }", "         cmsDeleteTransform(hTransform);", "         cmsCloseProfile(hOutProfile);", "         cmsCloseProfile(hInProfile);", "         mainprog_ptr->gamma = 0.45455;", "     }", " #endif", "     png_destroy_read_struct(&png_ptr, &info_ptr, NULL);", "     mainprog_ptr->file_size = read_data.bytes_read;", "     mainprog_ptr->row_pointers = (unsigned char **)row_pointers;", "     return SUCCESS;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int main(void)", "  {", "  \tFILE *f;", "  \tchar *tmpname;", "\tf = xfmkstemp(&tmpname, NULL);", " \tf = xfmkstemp(&tmpname, NULL, \"test\");", "  \tunlink(tmpname);", "  \tfree(tmpname);", "  \tfclose(f);", " \treturn EXIT_FAILURE;", " }"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" int _yr_scan_verify_re_match(", "     YR_SCAN_CONTEXT* context,", "     YR_AC_MATCH* ac_match,", "     uint8_t* data,", "     size_t data_size,", "     size_t data_base,", "     size_t offset)", " {", "   CALLBACK_ARGS callback_args;", "   RE_EXEC_FUNC exec;", "   int forward_matches = -1;", "   int backward_matches = -1;", "   int flags = 0;", "   if (STRING_IS_GREEDY_REGEXP(ac_match->string))", "     flags |= RE_FLAGS_GREEDY;", "   if (STRING_IS_NO_CASE(ac_match->string))", "     flags |= RE_FLAGS_NO_CASE;", "   if (STRING_IS_DOT_ALL(ac_match->string))", "     flags |= RE_FLAGS_DOT_ALL;", "   if (STRING_IS_FAST_REGEXP(ac_match->string))", "     exec = yr_re_fast_exec;", "   else", "     exec = yr_re_exec;", "   if (STRING_IS_ASCII(ac_match->string))", "   {", "     forward_matches = exec(", "          ac_match->forward_code,", "          data + offset,", "          data_size - offset,", "        offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags,", "         offset,", "         flags,", "          NULL,", "          NULL);", "    }", "   if (STRING_IS_WIDE(ac_match->string) && forward_matches == -1)", "   {", "     flags |= RE_FLAGS_WIDE;", "     forward_matches = exec(", "          ac_match->forward_code,", "          data + offset,", "          data_size - offset,", "        offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags,", "         offset,", "         flags,", "          NULL,", "          NULL);", "    }", "   switch(forward_matches)", "   {", "     case -1:", "       return ERROR_SUCCESS;", "     case -2:", "       return ERROR_INSUFFICIENT_MEMORY;", "     case -3:", "       return ERROR_TOO_MANY_MATCHES;", "     case -4:", "       return ERROR_TOO_MANY_RE_FIBERS;", "     case -5:", "       return ERROR_INTERNAL_FATAL_ERROR;", "   }", "   if (forward_matches == 0 && ac_match->backward_code == NULL)", "     return ERROR_SUCCESS;", "   callback_args.string = ac_match->string;", "   callback_args.context = context;", "   callback_args.data = data;", "   callback_args.data_size = data_size;", "   callback_args.data_base = data_base;", "   callback_args.forward_matches = forward_matches;", "   callback_args.full_word = STRING_IS_FULL_WORD(ac_match->string);", "   if (ac_match->backward_code != NULL)", "   {", "      backward_matches = exec(", "          ac_match->backward_code,", "          data + offset,", "         data_size - offset,", "          offset,", "          flags | RE_FLAGS_BACKWARDS | RE_FLAGS_EXHAUSTIVE,", "          _yr_scan_match_callback,", "         (void*) &callback_args);", "     switch(backward_matches)", "     {", "       case -2:", "         return ERROR_INSUFFICIENT_MEMORY;", "       case -3:", "         return ERROR_TOO_MANY_MATCHES;", "       case -4:", "         return ERROR_TOO_MANY_RE_FIBERS;", "       case -5:", "         return ERROR_INTERNAL_FATAL_ERROR;", "     }", "   }", "   else", "   {", "     FAIL_ON_ERROR(_yr_scan_match_callback(", "         data + offset, 0, flags, &callback_args));", "   }", "   return ERROR_SUCCESS;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int mif_process_cmpt(mif_hdr_t *hdr, char *buf)", " {", " \tjas_tvparser_t *tvp;", " \tmif_cmpt_t *cmpt;", " \tint id;", " \tcmpt = 0;", " \ttvp = 0;", " \tif (!(cmpt = mif_cmpt_create())) {", " \t\tgoto error;", " \t}", " \tcmpt->tlx = 0;", " \tcmpt->tly = 0;", " \tcmpt->sampperx = 0;", " \tcmpt->samppery = 0;", " \tcmpt->width = 0;", " \tcmpt->height = 0;", " \tcmpt->prec = 0;", " \tcmpt->sgnd = -1;", " \tcmpt->data = 0;", " \tif (!(tvp = jas_tvparser_create(buf))) {", " \t\tgoto error;", " \t}", " \twhile (!(id = jas_tvparser_next(tvp))) {", " \t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(mif_tags,", " \t\t  jas_tvparser_gettag(tvp)))->id) {", " \t\tcase MIF_TLX:", " \t\t\tcmpt->tlx = atoi(jas_tvparser_getval(tvp));", " \t\t\tbreak;", " \t\tcase MIF_TLY:", " \t\t\tcmpt->tly = atoi(jas_tvparser_getval(tvp));", " \t\t\tbreak;", " \t\tcase MIF_WIDTH:", " \t\t\tcmpt->width = atoi(jas_tvparser_getval(tvp));", " \t\t\tbreak;", " \t\tcase MIF_HEIGHT:", " \t\t\tcmpt->height = atoi(jas_tvparser_getval(tvp));", " \t\t\tbreak;", " \t\tcase MIF_HSAMP:", " \t\t\tcmpt->sampperx = atoi(jas_tvparser_getval(tvp));", " \t\t\tbreak;", " \t\tcase MIF_VSAMP:", " \t\t\tcmpt->samppery = atoi(jas_tvparser_getval(tvp));", " \t\t\tbreak;", " \t\tcase MIF_PREC:", " \t\t\tcmpt->prec = atoi(jas_tvparser_getval(tvp));", " \t\t\tbreak;", " \t\tcase MIF_SGND:", " \t\t\tcmpt->sgnd = atoi(jas_tvparser_getval(tvp));", " \t\t\tbreak;", " \t\tcase MIF_DATA:", " \t\t\tif (!(cmpt->data = jas_strdup(jas_tvparser_getval(tvp)))) {", " \t\t\t\treturn -1;", " \t\t\t}", "  \t\t\tbreak;", "  \t\t}", "  \t}", "\tjas_tvparser_destroy(tvp);", "  \tif (!cmpt->sampperx || !cmpt->samppery) {", "  \t\tgoto error;", "  \t}", "  \tif (mif_hdr_addcmpt(hdr, hdr->numcmpts, cmpt)) {", "  \t\tgoto error;", "  \t}", " \tjas_tvparser_destroy(tvp);", "  \treturn 0;", "  error:", " \tif (cmpt) {", " \t\tmif_cmpt_destroy(cmpt);", " \t}", " \tif (tvp) {", " \t\tjas_tvparser_destroy(tvp);", " \t}", " \treturn -1;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void send_auth(char *username, char *password) {", " \tstruct mt_packet data;", " \tunsigned short width = 0;", " \tunsigned short height = 0;", "  \tchar *terminal = getenv(\"TERM\");", "  \tchar md5data[100];", "  \tunsigned char md5sum[17];", "\tint plen;", " \tint plen, act_pass_len;", "  \tmd5_state_t state;", "  #if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)", "  \tmlock(md5data, sizeof(md5data));", "  \tmlock(md5sum, sizeof(md5data));", "  #endif", " \tact_pass_len = strnlen(password, 82);", "  \tmd5data[0] = 0;", "\tstrncpy(md5data + 1, password, 82);", "\tmd5data[83] = '\\0';", "\tmemcpy(md5data + 1 + strlen(password), pass_salt, 16);", " \tmemcpy(md5data + 1, password, act_pass_len);", " \tmemcpy(md5data + 1 + act_pass_len, pass_salt, 16);", "  \tmd5_init(&state);", "\tmd5_append(&state, (const md5_byte_t *)md5data, strlen(password) + 17);", " \tmd5_append(&state, (const md5_byte_t *)md5data, 1 + act_pass_len + 16);", "  \tmd5_finish(&state, (md5_byte_t *)md5sum + 1);", "  \tmd5sum[0] = 0;", " \tinit_packet(&data, MT_PTYPE_DATA, srcmac, dstmac, sessionkey, outcounter);", " \tplen = add_control_packet(&data, MT_CPTYPE_PASSWORD, md5sum, 17);", " \tplen += add_control_packet(&data, MT_CPTYPE_USERNAME, username, strlen(username));", " \tplen += add_control_packet(&data, MT_CPTYPE_TERM_TYPE, terminal, strlen(terminal));", " \tif (is_a_tty && get_terminal_size(&width, &height) != -1) {", " \t\twidth = htole16(width);", " \t\theight = htole16(height);", " \t\tplen += add_control_packet(&data, MT_CPTYPE_TERM_WIDTH, &width, 2);", " \t\tplen += add_control_packet(&data, MT_CPTYPE_TERM_HEIGHT, &height, 2);", " \t}", " \toutcounter += plen;", " \tsend_udp(&data, 1);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int vorbis_finish_frame(stb_vorbis *f, int len, int left, int right)", " {", "    int prev,i,j;", "     if (f->previous_length) {", "        int i,j, n = f->previous_length;", "        float *w = get_window(f, n);", "       if (w == NULL) return 0;", "        for (i=0; i < f->channels; ++i) {", "           for (j=0; j < n; ++j)", "              f->channel_buffers[i][left+j] =", "                f->channel_buffers[i][left+j]*w[    j] +", "                f->previous_window[i][     j]*w[n-1-j];", "       }", "    }", "    prev = f->previous_length;", "    f->previous_length = len - right;", "    for (i=0; i < f->channels; ++i)", "       for (j=0; right+j < len; ++j)", "          f->previous_window[i][j] = f->channel_buffers[i][right+j];", "    if (!prev)", "       return 0;", "    if (len < right) right = len;", "    f->samples_output += right-left;", "    return right - left;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  jas_seq2d_t *jas_seq2d_copy(jas_seq2d_t *x)", "  {", "  \tjas_matrix_t *y;", "\tint i;", "\tint j;", " \tjas_matind_t i;", " \tjas_matind_t j;", "  \ty = jas_seq2d_create(jas_seq2d_xstart(x), jas_seq2d_ystart(x),", "  \t  jas_seq2d_xend(x), jas_seq2d_yend(x));", "  \tassert(y);", " \tfor (i = 0; i < x->numrows_; ++i) {", " \t\tfor (j = 0; j < x->numcols_; ++j) {", " \t\t\t*jas_matrix_getref(y, i, j) = jas_matrix_get(x, i, j);", " \t\t}", " \t}", " \treturn y;", " }"], "ner_tags": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int handle_eac3(MOVMuxContext *mov, AVPacket *pkt, MOVTrack *track)", " {", "     AC3HeaderInfo *hdr = NULL;", "     struct eac3_info *info;", "     int num_blocks, ret;", "     if (!track->eac3_priv && !(track->eac3_priv = av_mallocz(sizeof(*info))))", "         return AVERROR(ENOMEM);", "     info = track->eac3_priv;", "     if (avpriv_ac3_parse_header(&hdr, pkt->data, pkt->size) < 0) {", "         if (!track->entry) {", "             av_log(mov, AV_LOG_WARNING, \"Dropping invalid packet from start of the stream\\n\");", "             ret = 0;", "         } else", "             ret = AVERROR_INVALIDDATA;", "         goto end;", "     }", "     info->data_rate = FFMAX(info->data_rate, hdr->bit_rate / 1000);", "     num_blocks = hdr->num_blocks;", "     if (!info->ec3_done) {", "         if (hdr->bitstream_id <= 10 && hdr->substreamid != 0) {", "             ret = AVERROR(EINVAL);", "             goto end;", "         }", "         if (hdr->frame_type == EAC3_FRAME_TYPE_INDEPENDENT) {", "             if (hdr->substreamid > info->num_ind_sub + 1) {", "                 ret = AVERROR(EINVAL);", "                 goto end;", "             }", "              if (hdr->substreamid == info->num_ind_sub + 1) {", "                avpriv_request_sample(track->par, \"Multiple independent substreams\");", "                 avpriv_request_sample(mov->fc, \"Multiple independent substreams\");", "                  ret = AVERROR_PATCHWELCOME;", "                  goto end;", "              } else if (hdr->substreamid < info->num_ind_sub ||", "                        hdr->substreamid == 0 && info->substream[0].bsid) {", "                 info->ec3_done = 1;", "                 goto concatenate;", "             }", "         } else {", "             if (hdr->substreamid != 0) {", "                 avpriv_request_sample(mov->fc, \"Multiple non EAC3 independent substreams\");", "                 ret = AVERROR_PATCHWELCOME;", "                 goto end;", "             }", "         }", "         info->substream[hdr->substreamid].fscod = hdr->sr_code;", "         info->substream[hdr->substreamid].bsid  = hdr->bitstream_id;", "         info->substream[hdr->substreamid].bsmod = hdr->bitstream_mode;", "         info->substream[hdr->substreamid].acmod = hdr->channel_mode;", "         info->substream[hdr->substreamid].lfeon = hdr->lfe_on;", "         if (pkt->size != hdr->frame_size) {", "             int cumul_size = hdr->frame_size;", "             int parent = hdr->substreamid;", "             while (cumul_size != pkt->size) {", "                 GetBitContext gbc;", "                 int i;", "                 ret = avpriv_ac3_parse_header(&hdr, pkt->data + cumul_size, pkt->size - cumul_size);", "                 if (ret < 0)", "                     goto end;", "                 if (hdr->frame_type != EAC3_FRAME_TYPE_DEPENDENT) {", "                     ret = AVERROR(EINVAL);", "                     goto end;", "                 }", "                 info->substream[parent].num_dep_sub++;", "                 ret /= 8;", "                 init_get_bits8(&gbc, pkt->data + cumul_size + ret, pkt->size - cumul_size - ret);", "                 skip_bits(&gbc, 5);", "                 for (i = 0; i < (hdr->channel_mode ? 1 : 2); i++) {", "                     skip_bits(&gbc, 5);  ", "                     if (get_bits1(&gbc)) {", "                         skip_bits(&gbc, 8);  ", "                     }", "                 }", "                 if (get_bits1(&gbc))", "                     info->substream[parent].chan_loc |= (get_bits(&gbc, 16) >> 5) & 0x1f;", "                 else", "                     info->substream[parent].chan_loc |= hdr->channel_mode;", "                 cumul_size += hdr->frame_size;", "             }", "         }", "     }", " concatenate:", "     if (!info->num_blocks && num_blocks == 6) {", "         ret = pkt->size;", "         goto end;", "     }", "     else if (info->num_blocks + num_blocks > 6) {", "         ret = AVERROR_INVALIDDATA;", "         goto end;", "     }", "     if (!info->num_blocks) {", "         ret = av_packet_ref(&info->pkt, pkt);", "         if (!ret)", "             info->num_blocks = num_blocks;", "         goto end;", "     } else {", "         if ((ret = av_grow_packet(&info->pkt, pkt->size)) < 0)", "             goto end;", "         memcpy(info->pkt.data + info->pkt.size - pkt->size, pkt->data, pkt->size);", "         info->num_blocks += num_blocks;", "         info->pkt.duration += pkt->duration;", "         if ((ret = av_copy_packet_side_data(&info->pkt, pkt)) < 0)", "             goto end;", "         if (info->num_blocks != 6)", "             goto end;", "         av_packet_unref(pkt);", "         av_packet_move_ref(pkt, &info->pkt);", "         info->num_blocks = 0;", "     }", "     ret = pkt->size;", " end:", "     av_free(hdr);", "     return ret;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static int jas_iccgetuint64(jas_stream_t *in, jas_iccuint64_t *val)", "  {", "\tulonglong tmp;", " \tjas_ulonglong tmp;", "  \tif (jas_iccgetuint(in, 8, &tmp))", "  \t\treturn -1;", "  \t*val = tmp;", "  \treturn 0;", "  }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": ["  jas_image_t *jas_image_create0()", " {", " \tjas_image_t *image;", " \tif (!(image = jas_malloc(sizeof(jas_image_t)))) {", " \t\treturn 0;", " \t}", " \timage->tlx_ = 0;", " \timage->tly_ = 0;", " \timage->brx_ = 0;", " \timage->bry_ = 0;", " \timage->clrspc_ = JAS_CLRSPC_UNKNOWN;", "  \timage->numcmpts_ = 0;", "  \timage->maxcmpts_ = 0;", "  \timage->cmpts_ = 0;", "\timage->inmem_ = true;", "  \timage->cmprof_ = 0;", "  \treturn image;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": [" static void Sp_match(js_State *J)", " {", " \tjs_Regexp *re;", " \tconst char *text;", " \tint len;", " \tconst char *a, *b, *c, *e;", " \tResub m;", " \ttext = checkstring(J, 0);", " \tif (js_isregexp(J, 1))", " \t\tjs_copy(J, 1);", " \telse if (js_isundefined(J, 1))", " \t\tjs_newregexp(J, \"\", 0);", " \telse", " \t\tjs_newregexp(J, js_tostring(J, 1), 0);", " \tre = js_toregexp(J, -1);", " \tif (!(re->flags & JS_REGEXP_G)) {", " \t\tjs_RegExp_prototype_exec(J, re, text);", " \t\treturn;", " \t}", " \tre->last = 0;", " \tjs_newarray(J);", " \tlen = 0;", "  \ta = text;", "  \te = text + strlen(text);", "  \twhile (a <= e) {", "\t\tif (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))", " \t\tif (js_doregexec(J, re->prog, a, &m, a > text ? REG_NOTBOL : 0))", "  \t\t\tbreak;", "  \t\tb = m.sub[0].sp;", " \t\tc = m.sub[0].ep;", " \t\tjs_pushlstring(J, b, c - b);", " \t\tjs_setindex(J, -2, len++);", " \t\ta = c;", " \t\tif (c - b == 0)", " \t\t\t++a;", " \t}", " \tif (len == 0) {", " \t\tjs_pop(J, 1);", " \t\tjs_pushnull(J);", " \t}", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static boolean parse_identifier( const char **pcur, char *ret )", " static boolean parse_identifier( const char **pcur, char *ret, size_t len )", "  {", "     const char *cur = *pcur;", "     int i = 0;", "     if (is_alpha_underscore( cur )) {", "        ret[i++] = *cur++;", "      while (is_alpha_underscore( cur ) || is_digit( cur ))", "       while (is_alpha_underscore( cur ) || is_digit( cur )) {", "          if (i == len - 1)", "             return FALSE;", "           ret[i++] = *cur++;", "       }", "        ret[i++] = '\\0';", "        *pcur = cur;", "        return TRUE;", " static boolean parse_float( const char **pcur, float *val )", " {", "    const char *cur = *pcur;", "    boolean integral_part = FALSE;", "    boolean fractional_part = FALSE;", "    if (*cur == '0' && *(cur + 1) == 'x') {", "       union fi fi;", "       fi.ui = strtoul(cur, NULL, 16);", "       *val = fi.f;", "       cur += 10;", "       goto out;", "    }", "    *val = (float) atof( cur );", "    if (*cur == '-' || *cur == '+')", "       cur++;", "    if (is_digit( cur )) {", "       cur++;", "       integral_part = TRUE;", "       while (is_digit( cur ))", "          cur++;", "    }", "    if (*cur == '.') {", "       cur++;", "       if (is_digit( cur )) {", "          cur++;", "          fractional_part = TRUE;", "          while (is_digit( cur ))", "             cur++;", "       }", "    }", "    if (!integral_part && !fractional_part)", "       return FALSE;", "    if (uprcase( *cur ) == 'E') {", "       cur++;", "       if (*cur == '-' || *cur == '+')", "          cur++;", "       if (is_digit( cur )) {", "          cur++;", "          while (is_digit( cur ))", "             cur++;", "       }", "       else", "          return FALSE;", "    }", " out:", "    *pcur = cur;", "    return TRUE;", " }", " static boolean parse_double( const char **pcur, uint32_t *val0, uint32_t *val1)", " {", "    const char *cur = *pcur;", "    union {", "       double dval;", "       uint32_t uval[2];", "    } v;", "    v.dval = strtod(cur, (char**)pcur);", "    if (*pcur == cur)", "       return FALSE;", "    *val0 = v.uval[0];", "    *val1 = v.uval[1];", "    return TRUE;", " }", " struct translate_ctx", " {", "    const char *text;", "    const char *cur;", "    struct tgsi_token *tokens;", "    struct tgsi_token *tokens_cur;", "    struct tgsi_token *tokens_end;", "    struct tgsi_header *header;", "    unsigned processor : 4;", "    unsigned implied_array_size : 6;", "    unsigned num_immediates;", " };", " static void report_error(struct translate_ctx *ctx, const char *format, ...)", " {", "    va_list args;", "    int line = 1;", "    int column = 1;", "    const char *itr = ctx->text;", "    debug_printf(\"\\nTGSI asm error: \");", "    va_start(args, format);", "    _debug_vprintf(format, args);", "    va_end(args);", "    while (itr != ctx->cur) {", "       if (*itr == '\\n') {", "          column = 1;", "          ++line;", "       }", "       ++column;", "       ++itr;", "    }", "    debug_printf(\" [%d : %d] \\n\", line, column);", " }", " static boolean parse_header( struct translate_ctx *ctx )", " {", "    uint processor;", "    if (str_match_nocase_whole( &ctx->cur, \"FRAG\" ))", "       processor = TGSI_PROCESSOR_FRAGMENT;", "    else if (str_match_nocase_whole( &ctx->cur, \"VERT\" ))", "       processor = TGSI_PROCESSOR_VERTEX;", "    else if (str_match_nocase_whole( &ctx->cur, \"GEOM\" ))", "       processor = TGSI_PROCESSOR_GEOMETRY;", "    else if (str_match_nocase_whole( &ctx->cur, \"TESS_CTRL\" ))", "       processor = TGSI_PROCESSOR_TESS_CTRL;", "    else if (str_match_nocase_whole( &ctx->cur, \"TESS_EVAL\" ))", "       processor = TGSI_PROCESSOR_TESS_EVAL;", "    else if (str_match_nocase_whole( &ctx->cur, \"COMP\" ))", "       processor = TGSI_PROCESSOR_COMPUTE;", "    else {", "       report_error( ctx, \"Unknown header\" );", "       return FALSE;", "    }", "    if (ctx->tokens_cur >= ctx->tokens_end)", "       return FALSE;", "    ctx->header = (struct tgsi_header *) ctx->tokens_cur++;", "    *ctx->header = tgsi_build_header();", "    if (ctx->tokens_cur >= ctx->tokens_end)", "       return FALSE;", "    *(struct tgsi_processor *) ctx->tokens_cur++ = tgsi_build_processor( processor, ctx->header );", "    ctx->processor = processor;", "    return TRUE;", " }", " static boolean parse_label( struct translate_ctx *ctx, uint *val )", " {", "    const char *cur = ctx->cur;", "    if (parse_uint( &cur, val )) {", "       eat_opt_white( &cur );", "       if (*cur == ':') {", "          cur++;", "          ctx->cur = cur;", "          return TRUE;", "       }", "    }", "    return FALSE;", " }", " static boolean", " parse_file( const char **pcur, uint *file )", " {", "    uint i;", "    for (i = 0; i < TGSI_FILE_COUNT; i++) {", "       const char *cur = *pcur;", "       if (str_match_nocase_whole( &cur, tgsi_file_name(i) )) {", "          *pcur = cur;", "          *file = i;", "          return TRUE;", "       }", "    }", "    return FALSE;", " }", " static boolean", " parse_opt_writemask(", "    struct translate_ctx *ctx,", "    uint *writemask )", " {", "    const char *cur;", "    cur = ctx->cur;", "    eat_opt_white( &cur );", "    if (*cur == '.') {", "       cur++;", "       *writemask = TGSI_WRITEMASK_NONE;", "       eat_opt_white( &cur );", "       if (uprcase( *cur ) == 'X') {", "          cur++;", "          *writemask |= TGSI_WRITEMASK_X;", "       }", "       if (uprcase( *cur ) == 'Y') {", "          cur++;", "          *writemask |= TGSI_WRITEMASK_Y;", "       }", "       if (uprcase( *cur ) == 'Z') {", "          cur++;", "          *writemask |= TGSI_WRITEMASK_Z;", "       }", "       if (uprcase( *cur ) == 'W') {", "          cur++;", "          *writemask |= TGSI_WRITEMASK_W;", "       }", "       if (*writemask == TGSI_WRITEMASK_NONE) {", "          report_error( ctx, \"Writemask expected\" );", "          return FALSE;", "       }", "       ctx->cur = cur;", "    }", "    else {", "       *writemask = TGSI_WRITEMASK_XYZW;", "    }", "    return TRUE;", " }", " static boolean", " parse_register_file_bracket(", "    struct translate_ctx *ctx,", "    uint *file )", " {", "    if (!parse_file( &ctx->cur, file )) {", "       report_error( ctx, \"Unknown register file\" );", "       return FALSE;", "    }", "    eat_opt_white( &ctx->cur );", "    if (*ctx->cur != '[') {", "       report_error( ctx, \"Expected `['\" );", "       return FALSE;", "    }", "    ctx->cur++;", "    return TRUE;", " }", " static boolean", " parse_register_file_bracket_index(", "    struct translate_ctx *ctx,", "    uint *file,", "    int *index )", " {", "    uint uindex;", "    if (!parse_register_file_bracket( ctx, file ))", "       return FALSE;", "    eat_opt_white( &ctx->cur );", "    if (!parse_uint( &ctx->cur, &uindex )) {", "       report_error( ctx, \"Expected literal unsigned integer\" );", "       return FALSE;", "    }", "    *index = (int) uindex;", "    return TRUE;", " }", " static boolean", " parse_register_1d(struct translate_ctx *ctx,", "                   uint *file,", "                   int *index )", " {", "    if (!parse_register_file_bracket_index( ctx, file, index ))", "       return FALSE;", "    eat_opt_white( &ctx->cur );", "    if (*ctx->cur != ']') {", "       report_error( ctx, \"Expected `]'\" );", "       return FALSE;", "    }", "    ctx->cur++;", "    return TRUE;", " }", " struct parsed_bracket {", "    int index;", "    uint ind_file;", "    int ind_index;", "    uint ind_comp;", "    uint ind_array;", " };", " static boolean", " parse_register_bracket(", "    struct translate_ctx *ctx,", "    struct parsed_bracket *brackets)", " {", "    const char *cur;", "    uint uindex;", "    memset(brackets, 0, sizeof(struct parsed_bracket));", "    eat_opt_white( &ctx->cur );", "    cur = ctx->cur;", "    if (parse_file( &cur, &brackets->ind_file )) {", "       if (!parse_register_1d( ctx, &brackets->ind_file,", "                               &brackets->ind_index ))", "          return FALSE;", "       eat_opt_white( &ctx->cur );", "       if (*ctx->cur == '.') {", "          ctx->cur++;", "          eat_opt_white(&ctx->cur);", "          switch (uprcase(*ctx->cur)) {", "          case 'X':", "             brackets->ind_comp = TGSI_SWIZZLE_X;", "             break;", "          case 'Y':", "             brackets->ind_comp = TGSI_SWIZZLE_Y;", "             break;", "          case 'Z':", "             brackets->ind_comp = TGSI_SWIZZLE_Z;", "             break;", "          case 'W':", "             brackets->ind_comp = TGSI_SWIZZLE_W;", "             break;", "          default:", "             report_error(ctx, \"Expected indirect register swizzle component `x', `y', `z' or `w'\");", "             return FALSE;", "          }", "          ctx->cur++;", "          eat_opt_white(&ctx->cur);", "       }", "       if (*ctx->cur == '+' || *ctx->cur == '-')", "          parse_int( &ctx->cur, &brackets->index );", "       else", "          brackets->index = 0;", "    }", "    else {", "       if (!parse_uint( &ctx->cur, &uindex )) {", "          report_error( ctx, \"Expected literal unsigned integer\" );", "          return FALSE;", "       }", "       brackets->index = (int) uindex;", "       brackets->ind_file = TGSI_FILE_NULL;", "       brackets->ind_index = 0;", "    }", "    eat_opt_white( &ctx->cur );", "    if (*ctx->cur != ']') {", "       report_error( ctx, \"Expected `]'\" );", "       return FALSE;", "    }", "    ctx->cur++;", "    if (*ctx->cur == '(') {", "       ctx->cur++;", "       eat_opt_white( &ctx->cur );", "       if (!parse_uint( &ctx->cur, &brackets->ind_array )) {", "          report_error( ctx, \"Expected literal unsigned integer\" );", "          return FALSE;", "       }", "       eat_opt_white( &ctx->cur );", "       if (*ctx->cur != ')') {", "          report_error( ctx, \"Expected `)'\" );", "          return FALSE;", "       }", "       ctx->cur++;", "    }", "    return TRUE;", " }", " static boolean", " parse_opt_register_src_bracket(", "    struct translate_ctx *ctx,", "    struct parsed_bracket *brackets,", "    int *parsed_brackets)", " {", "    const char *cur = ctx->cur;", "    *parsed_brackets = 0;", "    eat_opt_white( &cur );", "    if (cur[0] == '[') {", "       ++cur;", "       ctx->cur = cur;", "       if (!parse_register_bracket(ctx, brackets))", "          return FALSE;", "       *parsed_brackets = 1;", "    }", "    return TRUE;", " }", " static boolean", " parse_register_src(", "    struct translate_ctx *ctx,", "    uint *file,", "    struct parsed_bracket *brackets)", " {", "    brackets->ind_comp = TGSI_SWIZZLE_X;", "    if (!parse_register_file_bracket( ctx, file ))", "       return FALSE;", "    if (!parse_register_bracket( ctx, brackets ))", "        return FALSE;", "    return TRUE;", " }", " struct parsed_dcl_bracket {", "    uint first;", "    uint last;", " };", " static boolean", " parse_register_dcl_bracket(", "    struct translate_ctx *ctx,", "    struct parsed_dcl_bracket *bracket)", " {", "    uint uindex;", "    memset(bracket, 0, sizeof(struct parsed_dcl_bracket));", "    eat_opt_white( &ctx->cur );", "    if (!parse_uint( &ctx->cur, &uindex )) {", "       if (ctx->cur[0] == ']' && ctx->implied_array_size != 0) {", "          bracket->first = 0;", "          bracket->last = ctx->implied_array_size - 1;", "          goto cleanup;", "       }", "       report_error( ctx, \"Expected literal unsigned integer\" );", "       return FALSE;", "    }", "    bracket->first = uindex;", "    eat_opt_white( &ctx->cur );", "    if (ctx->cur[0] == '.' && ctx->cur[1] == '.') {", "       uint uindex;", "       ctx->cur += 2;", "       eat_opt_white( &ctx->cur );", "       if (!parse_uint( &ctx->cur, &uindex )) {", "          report_error( ctx, \"Expected literal integer\" );", "          return FALSE;", "       }", "       bracket->last = (int) uindex;", "       eat_opt_white( &ctx->cur );", "    }", "    else {", "       bracket->last = bracket->first;", "    }", " cleanup:", "    if (*ctx->cur != ']') {", "       report_error( ctx, \"Expected `]' or `..'\" );", "       return FALSE;", "    }", "    ctx->cur++;", "    return TRUE;", " }", " static boolean", " parse_register_dcl(", "    struct translate_ctx *ctx,", "    uint *file,", "    struct parsed_dcl_bracket *brackets,", "    int *num_brackets)", " {", "    const char *cur;", "    *num_brackets = 0;", "    if (!parse_register_file_bracket( ctx, file ))", "       return FALSE;", "    if (!parse_register_dcl_bracket( ctx, &brackets[0] ))", "       return FALSE;", "    *num_brackets = 1;", "    cur = ctx->cur;", "    eat_opt_white( &cur );", "    if (cur[0] == '[') {", "       bool is_in = *file == TGSI_FILE_INPUT;", "       bool is_out = *file == TGSI_FILE_OUTPUT;", "       ++cur;", "       ctx->cur = cur;", "       if (!parse_register_dcl_bracket( ctx, &brackets[1] ))", "          return FALSE;", "       if ((ctx->processor == TGSI_PROCESSOR_GEOMETRY && is_in) ||", "           (ctx->processor == TGSI_PROCESSOR_TESS_EVAL && is_in) ||", "           (ctx->processor == TGSI_PROCESSOR_TESS_CTRL && (is_in || is_out))) {", "          brackets[0] = brackets[1];", "          *num_brackets = 1;", "       } else {", "          *num_brackets = 2;", "       }", "    }", "    return TRUE;", " }", " static boolean", " parse_register_dst(", "    struct translate_ctx *ctx,", "    uint *file,", "    struct parsed_bracket *brackets)", " {", "    brackets->ind_comp = TGSI_SWIZZLE_X;", "    if (!parse_register_file_bracket( ctx, file ))", "       return FALSE;", "    if (!parse_register_bracket( ctx, brackets ))", "        return FALSE;", "    return TRUE;", " }", " static boolean", " parse_dst_operand(", "    struct translate_ctx *ctx,", "    struct tgsi_full_dst_register *dst )", " {", "    uint file;", "    uint writemask;", "    const char *cur;", "    struct parsed_bracket bracket[2];", "    int parsed_opt_brackets;", "    if (!parse_register_dst( ctx, &file, &bracket[0] ))", "       return FALSE;", "    if (!parse_opt_register_src_bracket(ctx, &bracket[1], &parsed_opt_brackets))", "       return FALSE;", "    cur = ctx->cur;", "    eat_opt_white( &cur );", "    if (!parse_opt_writemask( ctx, &writemask ))", "       return FALSE;", "    dst->Register.File = file;", "    if (parsed_opt_brackets) {", "       dst->Register.Dimension = 1;", "       dst->Dimension.Indirect = 0;", "       dst->Dimension.Dimension = 0;", "       dst->Dimension.Index = bracket[0].index;", "       if (bracket[0].ind_file != TGSI_FILE_NULL) {", "          dst->Dimension.Indirect = 1;", "          dst->DimIndirect.File = bracket[0].ind_file;", "          dst->DimIndirect.Index = bracket[0].ind_index;", "          dst->DimIndirect.Swizzle = bracket[0].ind_comp;", "          dst->DimIndirect.ArrayID = bracket[0].ind_array;", "       }", "       bracket[0] = bracket[1];", "    }", "    dst->Register.Index = bracket[0].index;", "    dst->Register.WriteMask = writemask;", "    if (bracket[0].ind_file != TGSI_FILE_NULL) {", "       dst->Register.Indirect = 1;", "       dst->Indirect.File = bracket[0].ind_file;", "       dst->Indirect.Index = bracket[0].ind_index;", "       dst->Indirect.Swizzle = bracket[0].ind_comp;", "       dst->Indirect.ArrayID = bracket[0].ind_array;", "    }", "    return TRUE;", " }", " static boolean", " parse_optional_swizzle(", "    struct translate_ctx *ctx,", "    uint *swizzle,", "    boolean *parsed_swizzle,", "    int components)", " {", "    const char *cur = ctx->cur;", "    *parsed_swizzle = FALSE;", "    eat_opt_white( &cur );", "    if (*cur == '.') {", "       uint i;", "       cur++;", "       eat_opt_white( &cur );", "       for (i = 0; i < components; i++) {", "          if (uprcase( *cur ) == 'X')", "             swizzle[i] = TGSI_SWIZZLE_X;", "          else if (uprcase( *cur ) == 'Y')", "             swizzle[i] = TGSI_SWIZZLE_Y;", "          else if (uprcase( *cur ) == 'Z')", "             swizzle[i] = TGSI_SWIZZLE_Z;", "          else if (uprcase( *cur ) == 'W')", "             swizzle[i] = TGSI_SWIZZLE_W;", "          else {", " \t    report_error( ctx, \"Expected register swizzle component `x', `y', `z' or `w'\" );", " \t    return FALSE;", "          }", "          cur++;", "       }", "       *parsed_swizzle = TRUE;", "       ctx->cur = cur;", "    }", "    return TRUE;", " }", " static boolean", " parse_src_operand(", "    struct translate_ctx *ctx,", "    struct tgsi_full_src_register *src )", " {", "    uint file;", "    uint swizzle[4];", "    boolean parsed_swizzle;", "    struct parsed_bracket bracket[2];", "    int parsed_opt_brackets;", "    if (*ctx->cur == '-') {", "       ctx->cur++;", "       eat_opt_white( &ctx->cur );", "       src->Register.Negate = 1;", "    }", "    if (*ctx->cur == '|') {", "       ctx->cur++;", "       eat_opt_white( &ctx->cur );", "       src->Register.Absolute = 1;", "    }", "    if (!parse_register_src(ctx, &file, &bracket[0]))", "       return FALSE;", "    if (!parse_opt_register_src_bracket(ctx, &bracket[1], &parsed_opt_brackets))", "       return FALSE;", "    src->Register.File = file;", "    if (parsed_opt_brackets) {", "       src->Register.Dimension = 1;", "       src->Dimension.Indirect = 0;", "       src->Dimension.Dimension = 0;", "       src->Dimension.Index = bracket[0].index;", "       if (bracket[0].ind_file != TGSI_FILE_NULL) {", "          src->Dimension.Indirect = 1;", "          src->DimIndirect.File = bracket[0].ind_file;", "          src->DimIndirect.Index = bracket[0].ind_index;", "          src->DimIndirect.Swizzle = bracket[0].ind_comp;", "          src->DimIndirect.ArrayID = bracket[0].ind_array;", "       }", "       bracket[0] = bracket[1];", "    }", "    src->Register.Index = bracket[0].index;", "    if (bracket[0].ind_file != TGSI_FILE_NULL) {", "       src->Register.Indirect = 1;", "       src->Indirect.File = bracket[0].ind_file;", "       src->Indirect.Index = bracket[0].ind_index;", "       src->Indirect.Swizzle = bracket[0].ind_comp;", "       src->Indirect.ArrayID = bracket[0].ind_array;", "    }", "    if (parse_optional_swizzle( ctx, swizzle, &parsed_swizzle, 4 )) {", "       if (parsed_swizzle) {", "          src->Register.SwizzleX = swizzle[0];", "          src->Register.SwizzleY = swizzle[1];", "          src->Register.SwizzleZ = swizzle[2];", "          src->Register.SwizzleW = swizzle[3];", "       }", "    }", "    if (src->Register.Absolute) {", "       eat_opt_white( &ctx->cur );", "       if (*ctx->cur != '|') {", "          report_error( ctx, \"Expected `|'\" );", "          return FALSE;", "       }", "       ctx->cur++;", "    }", "    return TRUE;", " }", " static boolean", " parse_texoffset_operand(", "    struct translate_ctx *ctx,", "    struct tgsi_texture_offset *src )", " {", "    uint file;", "    uint swizzle[3];", "    boolean parsed_swizzle;", "    struct parsed_bracket bracket;", "    if (!parse_register_src(ctx, &file, &bracket))", "       return FALSE;", "    src->File = file;", "    src->Index = bracket.index;", "    if (parse_optional_swizzle( ctx, swizzle, &parsed_swizzle, 3 )) {", "       if (parsed_swizzle) {", "          src->SwizzleX = swizzle[0];", "          src->SwizzleY = swizzle[1];", "          src->SwizzleZ = swizzle[2];", "       }", "    }", "    return TRUE;", " }", " static boolean", " match_inst(const char **pcur,", "            unsigned *saturate,", "            const struct tgsi_opcode_info *info)", " {", "    const char *cur = *pcur;", "    if (str_match_nocase_whole(&cur, info->mnemonic)) {", "       *pcur = cur;", "       *saturate = 0;", "       return TRUE;", "    }", "    if (str_match_no_case(&cur, info->mnemonic)) {", "       if (str_match_nocase_whole(&cur, \"_SAT\")) {", "          *pcur = cur;", "          *saturate = 1;", "          return TRUE;", "       }", "    }", "    return FALSE;", " }", " static boolean", " parse_instruction(", "    struct translate_ctx *ctx,", "    boolean has_label )", " {", "    uint i;", "    uint saturate = 0;", "    const struct tgsi_opcode_info *info;", "    struct tgsi_full_instruction inst;", "    const char *cur;", "    uint advance;", "    inst = tgsi_default_full_instruction();", "    eat_opt_white( &ctx->cur );", "    if (*ctx->cur == '(') {", "       uint file;", "       int index;", "       uint swizzle[4];", "       boolean parsed_swizzle;", "       inst.Instruction.Predicate = 1;", "       ctx->cur++;", "       if (*ctx->cur == '!') {", "          ctx->cur++;", "          inst.Predicate.Negate = 1;", "       }", "       if (!parse_register_1d( ctx, &file, &index ))", "          return FALSE;", "       if (parse_optional_swizzle( ctx, swizzle, &parsed_swizzle, 4 )) {", "          if (parsed_swizzle) {", "             inst.Predicate.SwizzleX = swizzle[0];", "             inst.Predicate.SwizzleY = swizzle[1];", "             inst.Predicate.SwizzleZ = swizzle[2];", "             inst.Predicate.SwizzleW = swizzle[3];", "          }", "       }", "       if (*ctx->cur != ')') {", "          report_error( ctx, \"Expected `)'\" );", "          return FALSE;", "       }", "       ctx->cur++;", "    }", "    eat_opt_white( &ctx->cur );", "    for (i = 0; i < TGSI_OPCODE_LAST; i++) {", "       cur = ctx->cur;", "       info = tgsi_get_opcode_info( i );", "       if (match_inst(&cur, &saturate, info)) {", "          if (info->num_dst + info->num_src + info->is_tex == 0) {", "             ctx->cur = cur;", "             break;", "          }", "          else if (*cur == '\\0' || eat_white( &cur )) {", "             ctx->cur = cur;", "             break;", "          }", "       }", "    }", "    if (i == TGSI_OPCODE_LAST) {", "       if (has_label)", "          report_error( ctx, \"Unknown opcode\" );", "       else", "          report_error( ctx, \"Expected `DCL', `IMM' or a label\" );", "       return FALSE;", "    }", "    inst.Instruction.Opcode = i;", "    inst.Instruction.Saturate = saturate;", "    inst.Instruction.NumDstRegs = info->num_dst;", "    inst.Instruction.NumSrcRegs = info->num_src;", "    if (i >= TGSI_OPCODE_SAMPLE && i <= TGSI_OPCODE_GATHER4) {", "       inst.Instruction.Texture = 1;", "       inst.Texture.Texture = TGSI_TEXTURE_UNKNOWN;", "    }", "    for (i = 0; i < info->num_dst + info->num_src + info->is_tex; i++) {", "       if (i > 0) {", "          eat_opt_white( &ctx->cur );", "          if (*ctx->cur != ',') {", "             report_error( ctx, \"Expected `,'\" );", "             return FALSE;", "          }", "          ctx->cur++;", "          eat_opt_white( &ctx->cur );", "       }", "       if (i < info->num_dst) {", "          if (!parse_dst_operand( ctx, &inst.Dst[i] ))", "             return FALSE;", "       }", "       else if (i < info->num_dst + info->num_src) {", "          if (!parse_src_operand( ctx, &inst.Src[i - info->num_dst] ))", "             return FALSE;", "       }", "       else {", "          uint j;", "          for (j = 0; j < TGSI_TEXTURE_COUNT; j++) {", "             if (str_match_nocase_whole( &ctx->cur, tgsi_texture_names[j] )) {", "                inst.Instruction.Texture = 1;", "                inst.Texture.Texture = j;", "                break;", "             }", "          }", "          if (j == TGSI_TEXTURE_COUNT) {", "             report_error( ctx, \"Expected texture target\" );", "             return FALSE;", "          }", "       }", "    }", "    cur = ctx->cur;", "    eat_opt_white( &cur );", "    for (i = 0; inst.Instruction.Texture && *cur == ','; i++) {", "          cur++;", "          eat_opt_white( &cur );", "          ctx->cur = cur;", "          if (!parse_texoffset_operand( ctx, &inst.TexOffsets[i] ))", "             return FALSE;", "          cur = ctx->cur;", "          eat_opt_white( &cur );", "    }", "    inst.Texture.NumOffsets = i;", "    cur = ctx->cur;", "    eat_opt_white( &cur );", "    if (info->is_branch && *cur == ':') {", "       uint target;", "       cur++;", "       eat_opt_white( &cur );", "       if (!parse_uint( &cur, &target )) {", "          report_error( ctx, \"Expected a label\" );", "          return FALSE;", "       }", "       inst.Instruction.Label = 1;", "       inst.Label.Label = target;", "       ctx->cur = cur;", "    }", "    advance = tgsi_build_full_instruction(", "       &inst,", "       ctx->tokens_cur,", "       ctx->header,", "       (uint) (ctx->tokens_end - ctx->tokens_cur) );", "    if (advance == 0)", "       return FALSE;", "    ctx->tokens_cur += advance;", "    return TRUE;", " }", " static boolean parse_immediate_data(struct translate_ctx *ctx, unsigned type,", "                                     union tgsi_immediate_data *values)", " {", "    unsigned i;", "    int ret;", "    eat_opt_white( &ctx->cur );", "    if (*ctx->cur != '{') {", "       report_error( ctx, \"Expected `{'\" );", "       return FALSE;", "    }", "    ctx->cur++;", "    for (i = 0; i < 4; i++) {", "       eat_opt_white( &ctx->cur );", "       if (i > 0) {", "          if (*ctx->cur != ',') {", "             report_error( ctx, \"Expected `,'\" );", "             return FALSE;", "          }", "          ctx->cur++;", "          eat_opt_white( &ctx->cur );", "       }", "       switch (type) {", "       case TGSI_IMM_FLOAT64:", "          ret = parse_double(&ctx->cur, &values[i].Uint, &values[i+1].Uint);", "          i++;", "          break;", "       case TGSI_IMM_FLOAT32:", "          ret = parse_float(&ctx->cur, &values[i].Float);", "          break;", "       case TGSI_IMM_UINT32:", "          ret = parse_uint(&ctx->cur, &values[i].Uint);", "          break;", "       case TGSI_IMM_INT32:", "          ret = parse_int(&ctx->cur, &values[i].Int);", "          break;", "       default:", "          assert(0);", "          ret = FALSE;", "          break;", "       }", "       if (!ret) {", "          report_error( ctx, \"Expected immediate constant\" );", "          return FALSE;", "       }", "    }", "    eat_opt_white( &ctx->cur );", "    if (*ctx->cur != '}') {", "       report_error( ctx, \"Expected `}'\" );", "       return FALSE;", "    }", "    ctx->cur++;", "    return TRUE;", " }", " static boolean parse_declaration( struct translate_ctx *ctx )", " {", "    struct tgsi_full_declaration decl;", "    uint file;", "    struct parsed_dcl_bracket brackets[2];", "    int num_brackets;", "    uint writemask;", "    const char *cur, *cur2;", "    uint advance;", "    boolean is_vs_input;", "    if (!eat_white( &ctx->cur )) {", "       report_error( ctx, \"Syntax error\" );", "       return FALSE;", "    }", "    if (!parse_register_dcl( ctx, &file, brackets, &num_brackets))", "       return FALSE;", "    if (!parse_opt_writemask( ctx, &writemask ))", "       return FALSE;", "    decl = tgsi_default_full_declaration();", "    decl.Declaration.File = file;", "    decl.Declaration.UsageMask = writemask;", "    if (num_brackets == 1) {", "       decl.Range.First = brackets[0].first;", "       decl.Range.Last = brackets[0].last;", "    } else {", "       decl.Range.First = brackets[1].first;", "       decl.Range.Last = brackets[1].last;", "       decl.Declaration.Dimension = 1;", "       decl.Dim.Index2D = brackets[0].first;", "    }", "    is_vs_input = (file == TGSI_FILE_INPUT &&", "                   ctx->processor == TGSI_PROCESSOR_VERTEX);", "    cur = ctx->cur;", "    eat_opt_white( &cur );", "    if (*cur == ',') {", "       cur2 = cur;", "       cur2++;", "       eat_opt_white( &cur2 );", "       if (str_match_nocase_whole( &cur2, \"ARRAY\" )) {", "          int arrayid;", "          if (*cur2 != '(') {", "             report_error( ctx, \"Expected `('\" );", "             return FALSE;", "          }", "          cur2++;", "          eat_opt_white( &cur2 );", "          if (!parse_int( &cur2, &arrayid )) {", "             report_error( ctx, \"Expected `,'\" );", "             return FALSE;", "          }", "          eat_opt_white( &cur2 );", "          if (*cur2 != ')') {", "             report_error( ctx, \"Expected `)'\" );", "             return FALSE;", "          }", "          cur2++;", "          decl.Declaration.Array = 1;", "          decl.Array.ArrayID = arrayid;", "          ctx->cur = cur = cur2;", "       }", "    }", "    if (*cur == ',' && !is_vs_input) {", "       uint i, j;", "       cur++;", "       eat_opt_white( &cur );", "       if (file == TGSI_FILE_RESOURCE) {", "          for (i = 0; i < TGSI_TEXTURE_COUNT; i++) {", "             if (str_match_nocase_whole(&cur, tgsi_texture_names[i])) {", "                decl.Resource.Resource = i;", "                break;", "             }", "          }", "          if (i == TGSI_TEXTURE_COUNT) {", "             report_error(ctx, \"Expected texture target\");", "             return FALSE;", "          }", "          cur2 = cur;", "          eat_opt_white(&cur2);", "          while (*cur2 == ',') {", "             cur2++;", "             eat_opt_white(&cur2);", "             if (str_match_nocase_whole(&cur2, \"RAW\")) {", "                decl.Resource.Raw = 1;", "             } else if (str_match_nocase_whole(&cur2, \"WR\")) {", "                decl.Resource.Writable = 1;", "             } else {", "                break;", "             }", "             cur = cur2;", "             eat_opt_white(&cur2);", "          }", "          ctx->cur = cur;", "       } else if (file == TGSI_FILE_SAMPLER_VIEW) {", "          for (i = 0; i < TGSI_TEXTURE_COUNT; i++) {", "             if (str_match_nocase_whole(&cur, tgsi_texture_names[i])) {", "                decl.SamplerView.Resource = i;", "                break;", "             }", "          }", "          if (i == TGSI_TEXTURE_COUNT) {", "             report_error(ctx, \"Expected texture target\");", "             return FALSE;", "          }", "          eat_opt_white( &cur );", "          if (*cur != ',') {", "             report_error( ctx, \"Expected `,'\" );", "             return FALSE;", "          }", "          ++cur;", "          eat_opt_white( &cur );", "          for (j = 0; j < 4; ++j) {", "             for (i = 0; i < TGSI_RETURN_TYPE_COUNT; ++i) {", "                if (str_match_nocase_whole(&cur, tgsi_return_type_names[i])) {", "                   switch (j) {", "                   case 0:", "                      decl.SamplerView.ReturnTypeX = i;", "                      break;", "                   case 1:", "                      decl.SamplerView.ReturnTypeY = i;", "                      break;", "                   case 2:", "                      decl.SamplerView.ReturnTypeZ = i;", "                      break;", "                   case 3:", "                      decl.SamplerView.ReturnTypeW = i;", "                      break;", "                   default:", "                      assert(0);", "                   }", "                   break;", "                }", "             }", "             if (i == TGSI_RETURN_TYPE_COUNT) {", "                if (j == 0 || j >  2) {", "                   report_error(ctx, \"Expected type name\");", "                   return FALSE;", "                }", "                break;", "             } else {", "                cur2 = cur;", "                eat_opt_white( &cur2 );", "                if (*cur2 == ',') {", "                   cur2++;", "                   eat_opt_white( &cur2 );", "                   cur = cur2;", "                   continue;", "                } else", "                   break;", "             }", "          }", "          if (j < 4) {", "             decl.SamplerView.ReturnTypeY =", "                decl.SamplerView.ReturnTypeZ =", "                decl.SamplerView.ReturnTypeW =", "                decl.SamplerView.ReturnTypeX;", "          }", "          ctx->cur = cur;", "       } else {", "          if (str_match_nocase_whole(&cur, \"LOCAL\")) {", "             decl.Declaration.Local = 1;", "             ctx->cur = cur;", "          }", "          cur = ctx->cur;", "          eat_opt_white( &cur );", "          if (*cur == ',') {", "             cur++;", "             eat_opt_white( &cur );", "             for (i = 0; i < TGSI_SEMANTIC_COUNT; i++) {", "                if (str_match_nocase_whole(&cur, tgsi_semantic_names[i])) {", "                   uint index;", "                   cur2 = cur;", "                   eat_opt_white( &cur2 );", "                   if (*cur2 == '[') {", "                      cur2++;", "                      eat_opt_white( &cur2 );", "                      if (!parse_uint( &cur2, &index )) {", "                         report_error( ctx, \"Expected literal integer\" );", "                         return FALSE;", "                      }", "                      eat_opt_white( &cur2 );", "                      if (*cur2 != ']') {", "                         report_error( ctx, \"Expected `]'\" );", "                         return FALSE;", "                      }", "                      cur2++;", "                      decl.Semantic.Index = index;", "                      cur = cur2;", "                   }", "                   decl.Declaration.Semantic = 1;", "                   decl.Semantic.Name = i;", "                   ctx->cur = cur;", "                   break;", "                }", "             }", "          }", "       }", "    }", "    cur = ctx->cur;", "    eat_opt_white( &cur );", "    if (*cur == ',' && !is_vs_input) {", "       uint i;", "       cur++;", "       eat_opt_white( &cur );", "       for (i = 0; i < TGSI_INTERPOLATE_COUNT; i++) {", "          if (str_match_nocase_whole( &cur, tgsi_interpolate_names[i] )) {", "             decl.Declaration.Interpolate = 1;", "             decl.Interp.Interpolate = i;", "             ctx->cur = cur;", "             break;", "          }", "       }", "       if (i == TGSI_INTERPOLATE_COUNT) {", "          report_error( ctx, \"Expected semantic or interpolate attribute\" );", "          return FALSE;", "       }", "    }", "    cur = ctx->cur;", "    eat_opt_white( &cur );", "    if (*cur == ',' && !is_vs_input) {", "       uint i;", "       cur++;", "       eat_opt_white( &cur );", "       for (i = 0; i < TGSI_INTERPOLATE_LOC_COUNT; i++) {", "          if (str_match_nocase_whole( &cur, tgsi_interpolate_locations[i] )) {", "             decl.Interp.Location = i;", "             ctx->cur = cur;", "             break;", "          }", "       }", "    }", "    advance = tgsi_build_full_declaration(", "       &decl,", "       ctx->tokens_cur,", "       ctx->header,", "       (uint) (ctx->tokens_end - ctx->tokens_cur) );", "    if (advance == 0)", "       return FALSE;", "    ctx->tokens_cur += advance;", "    return TRUE;", " }", " static boolean parse_immediate( struct translate_ctx *ctx )", " {", "    struct tgsi_full_immediate imm;", "    uint advance;", "    int type;", "    if (*ctx->cur == '[') {", "       uint uindex;", "       ++ctx->cur;", "       eat_opt_white( &ctx->cur );", "       if (!parse_uint( &ctx->cur, &uindex )) {", "          report_error( ctx, \"Expected literal unsigned integer\" );", "          return FALSE;", "       }", "       if (uindex != ctx->num_immediates) {", "          report_error( ctx, \"Immediates must be sorted\" );", "          return FALSE;", "       }", "       eat_opt_white( &ctx->cur );", "       if (*ctx->cur != ']') {", "          report_error( ctx, \"Expected `]'\" );", "          return FALSE;", "       }", "       ctx->cur++;", "    }", "    if (!eat_white( &ctx->cur )) {", "       report_error( ctx, \"Syntax error\" );", "       return FALSE;", "    }", "    for (type = 0; type < Elements(tgsi_immediate_type_names); ++type) {", "       if (str_match_nocase_whole(&ctx->cur, tgsi_immediate_type_names[type]))", "          break;", "    }", "    if (type == Elements(tgsi_immediate_type_names)) {", "       report_error( ctx, \"Expected immediate type\" );", "       return FALSE;", "    }", "    imm = tgsi_default_full_immediate();", "    imm.Immediate.NrTokens += 4;", "    imm.Immediate.DataType = type;", "    parse_immediate_data(ctx, type, imm.u);", "    advance = tgsi_build_full_immediate(", "       &imm,", "       ctx->tokens_cur,", "       ctx->header,", "       (uint) (ctx->tokens_end - ctx->tokens_cur) );", "    if (advance == 0)", "       return FALSE;", "    ctx->tokens_cur += advance;", "    ctx->num_immediates++;", "    return TRUE;", " }", " static boolean", " parse_primitive( const char **pcur, uint *primitive )", " {", "    uint i;", "    for (i = 0; i < PIPE_PRIM_MAX; i++) {", "       const char *cur = *pcur;", "       if (str_match_nocase_whole( &cur, tgsi_primitive_names[i])) {", "          *primitive = i;", "          *pcur = cur;", "          return TRUE;", "       }", "    }", "    return FALSE;", " }", " static boolean", " parse_fs_coord_origin( const char **pcur, uint *fs_coord_origin )", " {", "    uint i;", "    for (i = 0; i < Elements(tgsi_fs_coord_origin_names); i++) {", "       const char *cur = *pcur;", "       if (str_match_nocase_whole( &cur, tgsi_fs_coord_origin_names[i])) {", "          *fs_coord_origin = i;", "          *pcur = cur;", "          return TRUE;", "       }", "    }", "    return FALSE;", " }", " static boolean", " parse_fs_coord_pixel_center( const char **pcur, uint *fs_coord_pixel_center )", " {", "    uint i;", "    for (i = 0; i < Elements(tgsi_fs_coord_pixel_center_names); i++) {", "       const char *cur = *pcur;", "       if (str_match_nocase_whole( &cur, tgsi_fs_coord_pixel_center_names[i])) {", "          *fs_coord_pixel_center = i;", "          *pcur = cur;", "          return TRUE;", "       }", "    }", "    return FALSE;", " }", " static boolean parse_property( struct translate_ctx *ctx )", " {", "    struct tgsi_full_property prop;", "    uint property_name;", "    uint values[8];", "    uint advance;", "    char id[64];", "    if (!eat_white( &ctx->cur )) {", "       report_error( ctx, \"Syntax error\" );", "       return FALSE;", "    }", "        report_error( ctx, \"Syntax error\" );", "        return FALSE;", "     }", "   if (!parse_identifier( &ctx->cur, id )) {", "    if (!parse_identifier( &ctx->cur, id, sizeof(id) )) {", "        report_error( ctx, \"Syntax error\" );", "        return FALSE;", "     }", "          break;", "       }", "    }"], "ner_tags": [0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" seamless_process_line(const char *line, void *data)", " {", " \tUNUSED(data);", " \tchar *p, *l;", " \tchar *tok1, *tok3, *tok4, *tok5, *tok6, *tok7, *tok8;", " \tunsigned long id, flags;", " \tchar *endptr;", " \tl = xstrdup(line);", " \tp = l;", " \tlogger(Core, Debug, \"seamless_process_line(), got '%s'\", p);", " \ttok1 = seamless_get_token(&p);", " \t(void) seamless_get_token(&p);", " \ttok3 = seamless_get_token(&p);", " \ttok4 = seamless_get_token(&p);", " \ttok5 = seamless_get_token(&p);", " \ttok6 = seamless_get_token(&p);", " \ttok7 = seamless_get_token(&p);", " \ttok8 = seamless_get_token(&p);", " \tif (!strcmp(\"CREATE\", tok1))", " \t{", " \t\tunsigned long group, parent;", " \t\tif (!tok6)", " \t\t\treturn False;", " \t\tid = strtoul(tok3, &endptr, 0);", " \t\tif (*endptr)", " \t\t\treturn False;", " \t\tgroup = strtoul(tok4, &endptr, 0);", " \t\tif (*endptr)", " \t\t\treturn False;", " \t\tparent = strtoul(tok5, &endptr, 0);", " \t\tif (*endptr)", " \t\t\treturn False;", " \t\tflags = strtoul(tok6, &endptr, 0);", " \t\tif (*endptr)", " \t\t\treturn False;", " \t\tui_seamless_create_window(id, group, parent, flags);", " \t}", " \telse if (!strcmp(\"DESTROY\", tok1))", " \t{", " \t\tif (!tok4)", " \t\t\treturn False;", " \t\tid = strtoul(tok3, &endptr, 0);", " \t\tif (*endptr)", " \t\t\treturn False;", " \t\tflags = strtoul(tok4, &endptr, 0);", " \t\tif (*endptr)", " \t\t\treturn False;", " \t\tui_seamless_destroy_window(id, flags);", " \t}", " \telse if (!strcmp(\"DESTROYGRP\", tok1))", " \t{", " \t\tif (!tok4)", " \t\t\treturn False;", " \t\tid = strtoul(tok3, &endptr, 0);", " \t\tif (*endptr)", " \t\t\treturn False;", " \t\tflags = strtoul(tok4, &endptr, 0);", " \t\tif (*endptr)", " \t\t\treturn False;", " \t\tui_seamless_destroy_group(id, flags);", " \t}", " \telse if (!strcmp(\"SETICON\", tok1))", " \t{", " \t\tint chunk, width, height, len;", " \t\tchar byte[3];", " \t\tif (!tok8)", " \t\t\treturn False;", " \t\tid = strtoul(tok3, &endptr, 0);", " \t\tif (*endptr)", " \t\t\treturn False;", " \t\tchunk = strtoul(tok4, &endptr, 0);", " \t\tif (*endptr)", " \t\t\treturn False;", " \t\twidth = strtoul(tok6, &endptr, 0);", " \t\tif (*endptr)", " \t\t\treturn False;", " \t\theight = strtoul(tok7, &endptr, 0);", " \t\tif (*endptr)", " \t\t\treturn False;", " \t\tbyte[2] = '\\0';", " \t\tlen = 0;", " \t\twhile (*tok8 != '\\0')", " \t\t{", " \t\t\tbyte[0] = *tok8;", " \t\t\ttok8++;", " \t\t\tif (*tok8 == '\\0')", " \t\t\t\treturn False;", " \t\t\tbyte[1] = *tok8;", " \t\t\ttok8++;", "  \t\t\ticon_buf[len] = strtol(byte, NULL, 16);", "  \t\t\tlen++;", " \t\t\tif ((size_t)len >= sizeof(icon_buf))", " \t\t\t{", " \t\t\t\tlogger(Protocol, Warning, \"seamless_process_line(), icon data would overrun icon_buf\");", " \t\t\t\tbreak;", " \t\t\t}", "  \t\t}", "  \t\tui_seamless_seticon(id, tok5, width, height, chunk, icon_buf, len);", " \t}", " \telse if (!strcmp(\"DELICON\", tok1))", " \t{", " \t\tint width, height;", " \t\tif (!tok6)", " \t\t\treturn False;", " \t\tid = strtoul(tok3, &endptr, 0);", " \t\tif (*endptr)", " \t\t\treturn False;", " \t\twidth = strtoul(tok5, &endptr, 0);", " \t\tif (*endptr)", " \t\t\treturn False;", " \t\theight = strtoul(tok6, &endptr, 0);", " \t\tif (*endptr)", " \t\t\treturn False;", " \t\tui_seamless_delicon(id, tok4, width, height);", " \t}", " \telse if (!strcmp(\"POSITION\", tok1))", " \t{", " \t\tint x, y, width, height;", " \t\tif (!tok8)", " \t\t\treturn False;", " \t\tid = strtoul(tok3, &endptr, 0);", " \t\tif (*endptr)", " \t\t\treturn False;", " \t\tx = strtol(tok4, &endptr, 0);", " \t\tif (*endptr)", " \t\t\treturn False;", " \t\ty = strtol(tok5, &endptr, 0);", " \t\tif (*endptr)", " \t\t\treturn False;", " \t\twidth = strtol(tok6, &endptr, 0);", " \t\tif (*endptr)", " \t\t\treturn False;", " \t\theight = strtol(tok7, &endptr, 0);", " \t\tif (*endptr)", " \t\t\treturn False;", " \t\tflags = strtoul(tok8, &endptr, 0);", " \t\tif (*endptr)", " \t\t\treturn False;", " \t\tui_seamless_move_window(id, x, y, width, height, flags);", " \t}", " \telse if (!strcmp(\"ZCHANGE\", tok1))", " \t{", " \t\tunsigned long behind;", " \t\tid = strtoul(tok3, &endptr, 0);", " \t\tif (*endptr)", " \t\t\treturn False;", " \t\tbehind = strtoul(tok4, &endptr, 0);", " \t\tif (*endptr)", " \t\t\treturn False;", " \t\tflags = strtoul(tok5, &endptr, 0);", " \t\tif (*endptr)", " \t\t\treturn False;", " \t\tui_seamless_restack_window(id, behind, flags);", " \t}", " \telse if (!strcmp(\"TITLE\", tok1))", " \t{", " \t\tif (!tok5)", " \t\t\treturn False;", " \t\tid = strtoul(tok3, &endptr, 0);", " \t\tif (*endptr)", " \t\t\treturn False;", " \t\tflags = strtoul(tok5, &endptr, 0);", " \t\tif (*endptr)", " \t\t\treturn False;", " \t\tui_seamless_settitle(id, tok4, flags);", " \t}", " \telse if (!strcmp(\"STATE\", tok1))", " \t{", " \t\tunsigned int state;", " \t\tif (!tok5)", " \t\t\treturn False;", " \t\tid = strtoul(tok3, &endptr, 0);", " \t\tif (*endptr)", " \t\t\treturn False;", " \t\tstate = strtoul(tok4, &endptr, 0);", " \t\tif (*endptr)", " \t\t\treturn False;", " \t\tflags = strtoul(tok5, &endptr, 0);", " \t\tif (*endptr)", " \t\t\treturn False;", " \t\tui_seamless_setstate(id, state, flags);", " \t}", " \telse if (!strcmp(\"DEBUG\", tok1))", " \t{", " \t\tlogger(Core, Debug, \"seamless_process_line(), %s\", line);", " \t}", " \telse if (!strcmp(\"SYNCBEGIN\", tok1))", " \t{", " \t\tif (!tok3)", " \t\t\treturn False;", " \t\tflags = strtoul(tok3, &endptr, 0);", " \t\tif (*endptr)", " \t\t\treturn False;", " \t\tui_seamless_syncbegin(flags);", " \t}", " \telse if (!strcmp(\"SYNCEND\", tok1))", " \t{", " \t\tif (!tok3)", " \t\t\treturn False;", " \t\tflags = strtoul(tok3, &endptr, 0);", " \t\tif (*endptr)", " \t\t\treturn False;", " \t}", " \telse if (!strcmp(\"HELLO\", tok1))", " \t{", " \t\tif (!tok3)", " \t\t\treturn False;", " \t\tflags = strtoul(tok3, &endptr, 0);", " \t\tif (*endptr)", " \t\t\treturn False;", " \t\tui_seamless_begin(! !(flags & SEAMLESSRDP_HELLO_HIDDEN));", " \t}", " \telse if (!strcmp(\"ACK\", tok1))", " \t{", " \t\tunsigned int serial;", " \t\tserial = strtoul(tok3, &endptr, 0);", " \t\tif (*endptr)", " \t\t\treturn False;", " \t\tui_seamless_ack(serial);", " \t}", " \telse if (!strcmp(\"HIDE\", tok1))", " \t{", " \t\tif (!tok3)", " \t\t\treturn False;", " \t\tflags = strtoul(tok3, &endptr, 0);", " \t\tif (*endptr)", " \t\t\treturn False;", " \t\tui_seamless_hide_desktop();", " \t}", " \telse if (!strcmp(\"UNHIDE\", tok1))", " \t{", " \t\tif (!tok3)", " \t\t\treturn False;", " \t\tflags = strtoul(tok3, &endptr, 0);", " \t\tif (*endptr)", " \t\t\treturn False;", " \t\tui_seamless_unhide_desktop();", " \t}", " \txfree(l);", " \treturn True;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  void vrend_set_framebuffer_state(struct vrend_context *ctx,", "                                 uint32_t nr_cbufs, uint32_t surf_handle[8],", "                                  uint32_t nr_cbufs, uint32_t surf_handle[PIPE_MAX_COLOR_BUFS],", "                                   uint32_t zsurf_handle)", "  {", "     struct vrend_surface *surf, *zsurf;", "    int i;", "    int old_num;", "    GLenum status;", "    GLint new_height = -1;", "    bool new_ibf = false;", "    glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, ctx->sub->fb_id);", "    if (zsurf_handle) {", "       zsurf = vrend_object_lookup(ctx->sub->object_hash, zsurf_handle, VIRGL_OBJECT_SURFACE);", "       if (!zsurf) {", "          report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_SURFACE, zsurf_handle);", "          return;", "       }", "    } else", "       zsurf = NULL;", "    if (ctx->sub->zsurf != zsurf) {", "       vrend_surface_reference(&ctx->sub->zsurf, zsurf);", "       vrend_hw_set_zsurf_texture(ctx);", "    }", "    old_num = ctx->sub->nr_cbufs;", "    ctx->sub->nr_cbufs = nr_cbufs;", "    ctx->sub->old_nr_cbufs = old_num;", "    for (i = 0; i < nr_cbufs; i++) {", "       if (surf_handle[i] != 0) {", "          surf = vrend_object_lookup(ctx->sub->object_hash, surf_handle[i], VIRGL_OBJECT_SURFACE);", "          if (!surf) {", "             report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_SURFACE, surf_handle[i]);", "             return;", "          }", "       } else", "          surf = NULL;", "       if (ctx->sub->surf[i] != surf) {", "          vrend_surface_reference(&ctx->sub->surf[i], surf);", "          vrend_hw_set_color_surface(ctx, i);", "       }", "    }", "    if (old_num > ctx->sub->nr_cbufs) {", "       for (i = ctx->sub->nr_cbufs; i < old_num; i++) {", "          vrend_surface_reference(&ctx->sub->surf[i], NULL);", "          vrend_hw_set_color_surface(ctx, i);", "       }", "    }", "    if (ctx->sub->nr_cbufs == 0 && !ctx->sub->zsurf) {", "       new_height = 0;", "       new_ibf = false;", "    } else if (ctx->sub->nr_cbufs == 0) {", "       new_height = u_minify(ctx->sub->zsurf->texture->base.height0, ctx->sub->zsurf->val0);", "       new_ibf = ctx->sub->zsurf->texture->y_0_top ? true : false;", "    }", "    else {", "       surf = NULL;", "       for (i = 0; i < ctx->sub->nr_cbufs; i++) {", "          if (ctx->sub->surf[i]) {", "             surf = ctx->sub->surf[i];", "             break;", "          }", "       }", "       if (surf == NULL) {", "          report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_SURFACE, i);", "          return;", "       }", "       new_height = u_minify(surf->texture->base.height0, surf->val0);", "       new_ibf = surf->texture->y_0_top ? true : false;", "    }", "    if (new_height != -1) {", "       if (ctx->sub->fb_height != new_height || ctx->sub->inverted_fbo_content != new_ibf) {", "          ctx->sub->fb_height = new_height;", "          ctx->sub->inverted_fbo_content = new_ibf;", "          ctx->sub->scissor_state_dirty = (1 << 0);", "          ctx->sub->viewport_state_dirty = (1 << 0);", "       }", "    }", "    vrend_hw_emit_framebuffer_state(ctx);", "    if (ctx->sub->nr_cbufs > 0 || ctx->sub->zsurf) {", "       status = glCheckFramebufferStatus(GL_FRAMEBUFFER);", "       if (status != GL_FRAMEBUFFER_COMPLETE)", "          fprintf(stderr,\"failed to complete framebuffer 0x%x %s\\n\", status, ctx->debug_name);", "    }", "    ctx->sub->shader_dirty = true;", " }"], "ner_tags": [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" auth_select_file(struct sc_card *card, const struct sc_path *in_path,", " \t\t\t\t struct sc_file **file_out)", " {", " \tstruct sc_path path;", " \tstruct sc_file *tmp_file = NULL;", " \tsize_t offs, ii;", " \tint rv;", " \tLOG_FUNC_CALLED(card->ctx);", " \tassert(card != NULL && in_path != NULL);", "  \tmemcpy(&path, in_path, sizeof(struct sc_path));", " \tif (!auth_current_df)", " \t\treturn SC_ERROR_OBJECT_NOT_FOUND;", "  \tsc_log(card->ctx, \"in_path; type=%d, path=%s, out %p\",", "  \t\t\tin_path->type, sc_print_path(in_path), file_out);", "  \tsc_log(card->ctx, \"current path; type=%d, path=%s\",", " \t\t\tauth_current_df->path.type, sc_print_path(&auth_current_df->path));", " \tif (auth_current_ef)", " \t\tsc_log(card->ctx, \"current file; type=%d, path=%s\",", " \t\t\t\tauth_current_ef->path.type, sc_print_path(&auth_current_ef->path));", " \tif (path.type == SC_PATH_TYPE_PARENT || path.type == SC_PATH_TYPE_FILE_ID)   {", " \t\tsc_file_free(auth_current_ef);", " \t\tauth_current_ef = NULL;", " \t\trv = iso_ops->select_file(card, &path, &tmp_file);", " \t\tLOG_TEST_RET(card->ctx, rv, \"select file failed\");", " \t\tif (!tmp_file)", " \t\t\treturn SC_ERROR_OBJECT_NOT_FOUND;", " \t\tif (path.type == SC_PATH_TYPE_PARENT)   {", " \t\t\tmemcpy(&tmp_file->path, &auth_current_df->path, sizeof(struct sc_path));", " \t\t\tif (tmp_file->path.len > 2)", " \t\t\t\ttmp_file->path.len -= 2;", " \t\t\tsc_file_free(auth_current_df);", " \t\t\tsc_file_dup(&auth_current_df, tmp_file);", " \t\t}", " \t\telse   {", " \t\t\tif (tmp_file->type == SC_FILE_TYPE_DF)   {", " \t\t\t\tsc_concatenate_path(&tmp_file->path, &auth_current_df->path, &path);", " \t\t\t\tsc_file_free(auth_current_df);", " \t\t\t\tsc_file_dup(&auth_current_df, tmp_file);", " \t\t\t}", " \t\t\telse   {", " \t\t\t\tsc_file_free(auth_current_ef);", " \t\t\t\tsc_file_dup(&auth_current_ef, tmp_file);", " \t\t\t\tsc_concatenate_path(&auth_current_ef->path, &auth_current_df->path, &path);", " \t\t\t}", " \t\t}", " \t\tif (file_out)", " \t\t\tsc_file_dup(file_out, tmp_file);", " \t\tsc_file_free(tmp_file);", " \t}", " \telse if (path.type == SC_PATH_TYPE_DF_NAME)   {", " \t\trv = iso_ops->select_file(card, &path, NULL);", " \t\tif (rv)   {", " \t\t\tsc_file_free(auth_current_ef);", " \t\t\tauth_current_ef = NULL;", " \t\t}", " \t\tLOG_TEST_RET(card->ctx, rv, \"select file failed\");", " \t}", " \telse   {", " \t\tfor (offs = 0; offs < path.len && offs < auth_current_df->path.len; offs += 2)", " \t\t\tif (path.value[offs] != auth_current_df->path.value[offs] ||", " \t\t\t\t\tpath.value[offs + 1] != auth_current_df->path.value[offs + 1])", " \t\t\t\tbreak;", " \t\tsc_log(card->ctx, \"offs %\"SC_FORMAT_LEN_SIZE_T\"u\", offs);", " \t\tif (offs && offs < auth_current_df->path.len)   {", " \t\t\tsize_t deep = auth_current_df->path.len - offs;", " \t\t\tsc_log(card->ctx, \"deep %\"SC_FORMAT_LEN_SIZE_T\"u\",", " \t\t\t       deep);", " \t\t\tfor (ii=0; ii<deep; ii+=2)   {", " \t\t\t\tstruct sc_path tmp_path;", " \t\t\t\tmemcpy(&tmp_path, &auth_current_df->path,  sizeof(struct sc_path));", " \t\t\t\ttmp_path.type = SC_PATH_TYPE_PARENT;", " \t\t\t\trv = auth_select_file (card, &tmp_path, file_out);", " \t\t\t\tLOG_TEST_RET(card->ctx, rv, \"select file failed\");", " \t\t\t}", " \t\t}", " \t\tif (path.len - offs > 0)   {", " \t\t\tstruct sc_path tmp_path;", " \t\t\tmemset(&tmp_path, 0, sizeof(struct sc_path));", " \t\t\ttmp_path.type = SC_PATH_TYPE_FILE_ID;", " \t\t\ttmp_path.len = 2;", " \t\t\tfor (ii=0; ii < path.len - offs; ii+=2)   {", " \t\t\t\tmemcpy(tmp_path.value, path.value + offs + ii, 2);", " \t\t\t\trv = auth_select_file(card, &tmp_path, file_out);", " \t\t\t\tLOG_TEST_RET(card->ctx, rv, \"select file failed\");", " \t\t\t}", " \t\t}", " \t\telse if (path.len - offs == 0 && file_out)  {", " \t\t\tif (sc_compare_path(&path, &auth_current_df->path))", " \t\t\t\tsc_file_dup(file_out, auth_current_df);", " \t\t\telse  if (auth_current_ef)", " \t\t\t\tsc_file_dup(file_out, auth_current_ef);", " \t\t\telse", " \t\t\t\tLOG_TEST_RET(card->ctx, SC_ERROR_INTERNAL, \"No current EF\");", " \t\t}", " \t}", " \tLOG_FUNC_RETURN(card->ctx, 0);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  void js_RegExp_prototype_exec(js_State *J, js_Regexp *re, const char *text)", "  {", " \tint result;", "  \tint i;", "  \tint opts;", "  \tResub m;", " \topts = 0;", " \tif (re->flags & JS_REGEXP_G) {", " \t\tif (re->last > strlen(text)) {", " \t\t\tre->last = 0;", " \t\t\tjs_pushnull(J);", " \t\t\treturn;", " \t\t}", " \t\tif (re->last > 0) {", " \t\t\ttext += re->last;", " \t\t\topts |= REG_NOTBOL;", "  \t\t}", "  \t}", "\tif (!js_regexec(re->prog, text, &m, opts)) {", " \tresult = js_regexec(re->prog, text, &m, opts);", " \tif (result < 0)", " \t\tjs_error(J, \"regexec failed\");", " \tif (result == 0) {", "  \t\tjs_newarray(J);", "  \t\tjs_pushstring(J, text);", "  \t\tjs_setproperty(J, -2, \"input\");", " \t\tjs_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));", " \t\tjs_setproperty(J, -2, \"index\");", " \t\tfor (i = 0; i < m.nsub; ++i) {", " \t\t\tjs_pushlstring(J, m.sub[i].sp, m.sub[i].ep - m.sub[i].sp);", " \t\t\tjs_setindex(J, -2, i);", " \t\t}", " \t\tif (re->flags & JS_REGEXP_G)", " \t\t\tre->last = re->last + (m.sub[0].ep - text);", " \t\treturn;", " \t}", " \tif (re->flags & JS_REGEXP_G)", " \t\tre->last = 0;", " \tjs_pushnull(J);", " }"], "ner_tags": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int csnmp_read_table(host_definition_t *host, data_definition_t *data) {", "   struct snmp_pdu *req;", "   struct snmp_pdu *res = NULL;", "   struct variable_list *vb;", "   const data_set_t *ds;", "   size_t oid_list_len = data->values_len + 1;", "   oid_t oid_list[oid_list_len];", "   _Bool oid_list_todo[oid_list_len];", "   int status;", "   size_t i;", "   csnmp_list_instances_t *instance_list_head;", "   csnmp_list_instances_t *instance_list_tail;", "   csnmp_table_values_t **value_list_head;", "   csnmp_table_values_t **value_list_tail;", "   DEBUG(\"snmp plugin: csnmp_read_table (host = %s, data = %s)\", host->name,", "         data->name);", "   if (host->sess_handle == NULL) {", "     DEBUG(\"snmp plugin: csnmp_read_table: host->sess_handle == NULL\");", "     return (-1);", "   }", "   ds = plugin_get_ds(data->type);", "   if (!ds) {", "     ERROR(\"snmp plugin: DataSet `%s' not defined.\", data->type);", "     return (-1);", "   }", "   if (ds->ds_num != data->values_len) {", "     ERROR(\"snmp plugin: DataSet `%s' requires %zu values, but config talks \"", "           \"about %zu\",", "           data->type, ds->ds_num, data->values_len);", "     return (-1);", "   }", "   assert(data->values_len > 0);", "   memcpy(oid_list, data->values, data->values_len * sizeof(oid_t));", "   if (data->instance.oid.oid_len > 0)", "     memcpy(oid_list + data->values_len, &data->instance.oid, sizeof(oid_t));", "   else  ", "     oid_list_len--;", "   for (i = 0; i < oid_list_len; i++)", "     oid_list_todo[i] = 1;", "   value_list_head = calloc(data->values_len, sizeof(*value_list_head));", "   value_list_tail = calloc(data->values_len, sizeof(*value_list_tail));", "   if ((value_list_head == NULL) || (value_list_tail == NULL)) {", "     ERROR(\"snmp plugin: csnmp_read_table: calloc failed.\");", "     sfree(value_list_head);", "     sfree(value_list_tail);", "     return (-1);", "   }", "   instance_list_head = NULL;", "   instance_list_tail = NULL;", "   status = 0;", "   while (status == 0) {", "     int oid_list_todo_num;", "     req = snmp_pdu_create(SNMP_MSG_GETNEXT);", "     if (req == NULL) {", "       ERROR(\"snmp plugin: snmp_pdu_create failed.\");", "       status = -1;", "       break;", "     }", "     oid_list_todo_num = 0;", "     for (i = 0; i < oid_list_len; i++) {", "       if (!oid_list_todo[i])", "         continue;", "       oid_list_todo_num++;", "       snmp_add_null_var(req, oid_list[i].oid, oid_list[i].oid_len);", "     }", "      if (oid_list_todo_num == 0) {", "        DEBUG(\"snmp plugin: all variables have left their subtree\");", "       snmp_free_pdu(req);", "        status = 0;", "        break;", "      }", "      res = NULL;", "      status = snmp_sess_synch_response(host->sess_handle, req, &res);", "      if ((status != STAT_SUCCESS) || (res == NULL)) {", "        char *errstr = NULL;", "       snmp_sess_error(host->sess_handle, NULL, NULL, &errstr);", "       c_complain(LOG_ERR, &host->complaint,", "                  \"snmp plugin: host %s: snmp_sess_synch_response failed: %s\",", "                  host->name, (errstr == NULL) ? \"Unknown problem\" : errstr);", "       if (res != NULL)", "          snmp_free_pdu(res);", "        res = NULL;", "      req = NULL;", "        sfree(errstr);", "        csnmp_host_close_session(host);", "       status = -1;", "       break;", "     }", "     status = 0;", "     assert(res != NULL);", "     c_release(LOG_INFO, &host->complaint,", "               \"snmp plugin: host %s: snmp_sess_synch_response successful.\",", "               host->name);", "     vb = res->variables;", "     if (vb == NULL) {", "       status = -1;", "       break;", "     }", "     for (vb = res->variables, i = 0; (vb != NULL);", "          vb = vb->next_variable, i++) {", "       while ((i < oid_list_len) && !oid_list_todo[i])", "         i++;", "       if ((data->instance.oid.oid_len > 0) && (i == data->values_len)) {", "         if ((vb->type == SNMP_ENDOFMIBVIEW) ||", "             (snmp_oid_ncompare(", "                  data->instance.oid.oid, data->instance.oid.oid_len, vb->name,", "                  vb->name_length, data->instance.oid.oid_len) != 0)) {", "           DEBUG(\"snmp plugin: host = %s; data = %s; Instance left its subtree.\",", "                 host->name, data->name);", "           oid_list_todo[i] = 0;", "           continue;", "         }", "         if (csnmp_instance_list_add(&instance_list_head, &instance_list_tail,", "                                     res, host, data) != 0) {", "           ERROR(\"snmp plugin: host %s: csnmp_instance_list_add failed.\",", "                 host->name);", "           status = -1;", "           break;", "         }", "       } else  ", "       {", "         csnmp_table_values_t *vt;", "         oid_t vb_name;", "         oid_t suffix;", "         int ret;", "         csnmp_oid_init(&vb_name, vb->name, vb->name_length);", "         ret = csnmp_oid_suffix(&suffix, &vb_name, data->values + i);", "         if (ret != 0) {", "           DEBUG(\"snmp plugin: host = %s; data = %s; i = %zu; \"", "                 \"Value probably left its subtree.\",", "                 host->name, data->name, i);", "           oid_list_todo[i] = 0;", "           continue;", "         }", "         if ((value_list_tail[i] != NULL) &&", "             (csnmp_oid_compare(&suffix, &value_list_tail[i]->suffix) <= 0)) {", "           DEBUG(\"snmp plugin: host = %s; data = %s; i = %zu; \"", "                 \"Suffix is not increasing.\",", "                 host->name, data->name, i);", "           oid_list_todo[i] = 0;", "           continue;", "         }", "         vt = calloc(1, sizeof(*vt));", "         if (vt == NULL) {", "           ERROR(\"snmp plugin: calloc failed.\");", "           status = -1;", "           break;", "         }", "         vt->value =", "             csnmp_value_list_to_value(vb, ds->ds[i].type, data->scale,", "                                       data->shift, host->name, data->name);", "         memcpy(&vt->suffix, &suffix, sizeof(vt->suffix));", "         vt->next = NULL;", "         if (value_list_tail[i] == NULL)", "           value_list_head[i] = vt;", "         else", "           value_list_tail[i]->next = vt;", "         value_list_tail[i] = vt;", "       }", "       memcpy(oid_list[i].oid, vb->name, sizeof(oid) * vb->name_length);", "       oid_list[i].oid_len = vb->name_length;", "     }  ", "     if (res != NULL)", "       snmp_free_pdu(res);", "     res = NULL;", "   }  ", "   if (res != NULL)", "      snmp_free_pdu(res);", "    res = NULL;", "  if (req != NULL)", "    snmp_free_pdu(req);", "  req = NULL;", "    if (status == 0)", "      csnmp_dispatch_table(host, data, instance_list_head, value_list_head);", "   while (instance_list_head != NULL) {", "     csnmp_list_instances_t *next = instance_list_head->next;", "     sfree(instance_list_head);", "     instance_list_head = next;", "   }", "   for (i = 0; i < data->values_len; i++) {", "     while (value_list_head[i] != NULL) {", "       csnmp_table_values_t *next = value_list_head[i]->next;", "       sfree(value_list_head[i]);", "       value_list_head[i] = next;", "     }", "   }", "   sfree(value_list_head);", "   sfree(value_list_tail);", "   return (0);", " }  "], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)", " {", " \tjas_image_t *image;", " \tbmp_hdr_t hdr;", " \tbmp_info_t *info;", " \tuint_fast16_t cmptno;", " \tjas_image_cmptparm_t cmptparms[3];", " \tjas_image_cmptparm_t *cmptparm;", " \tuint_fast16_t numcmpts;", " \tlong n;", " \tif (optstr) {", " \t\tjas_eprintf(\"warning: ignoring BMP decoder options\\n\");", " \t}", " \tjas_eprintf(", " \t  \"THE BMP FORMAT IS NOT FULLY SUPPORTED!\\n\"", " \t  \"THAT IS, THE JASPER SOFTWARE CANNOT DECODE ALL TYPES OF BMP DATA.\\n\"", " \t  \"IF YOU HAVE ANY PROBLEMS, PLEASE TRY CONVERTING YOUR IMAGE DATA\\n\"", " \t  \"TO THE PNM FORMAT, AND USING THIS FORMAT INSTEAD.\\n\"", " \t  );", " \tif (bmp_gethdr(in, &hdr)) {", "  \t\tjas_eprintf(\"cannot get header\\n\");", "  \t\treturn 0;", "  \t}", " \tJAS_DBGLOG(1, (", " \t  \"BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\\n\",", " \t  hdr.magic, hdr.siz, hdr.reserved1, hdr.reserved2, hdr.off", " \t  ));", "  \tif (!(info = bmp_getinfo(in))) {", "  \t\tjas_eprintf(\"cannot get info\\n\");", "  \t\treturn 0;", "  \t}", " \tJAS_DBGLOG(1,", " \t  (\"BMP information: len %d; width %d; height %d; numplanes %d; \"", " \t  \"depth %d; enctype %d; siz %d; hres %d; vres %d; numcolors %d; \"", " \t  \"mincolors %d\\n\", info->len, info->width, info->height, info->numplanes,", " \t  info->depth, info->enctype, info->siz, info->hres, info->vres,", " \t  info->numcolors, info->mincolors));", "  \tif (!bmp_issupported(&hdr, info)) {", " \t\tjas_eprintf(\"error: unsupported BMP encoding\\n\");", " \t\tbmp_info_destroy(info);", " \t\treturn 0;", " \t}", " \tif ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {", " \t\tjas_eprintf(\"error: possibly bad bitmap offset?\\n\");", " \t\treturn 0;", " \t}", " \tif (n > 0) {", " \t\tjas_eprintf(\"skipping unknown data in BMP file\\n\");", " \t\tif (bmp_gobble(in, n)) {", " \t\t\tbmp_info_destroy(info);", " \t\t\treturn 0;", " \t\t}", " \t}", " \tnumcmpts = bmp_numcmpts(info);", " \tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,", " \t  ++cmptparm) {", " \t\tcmptparm->tlx = 0;", " \t\tcmptparm->tly = 0;", " \t\tcmptparm->hstep = 1;", " \t\tcmptparm->vstep = 1;", " \t\tcmptparm->width = info->width;", " \t\tcmptparm->height = info->height;", " \t\tcmptparm->prec = 8;", " \t\tcmptparm->sgnd = false;", " \t}", " \tif (!(image = jas_image_create(numcmpts, cmptparms,", " \t  JAS_CLRSPC_UNKNOWN))) {", " \t\tbmp_info_destroy(info);", " \t\treturn 0;", " \t}", " \tif (numcmpts == 3) {", " \t\tjas_image_setclrspc(image, JAS_CLRSPC_SRGB);", " \t\tjas_image_setcmpttype(image, 0,", " \t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));", " \t\tjas_image_setcmpttype(image, 1,", " \t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));", " \t\tjas_image_setcmpttype(image, 2,", " \t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));", " \t} else {", " \t\tjas_image_setclrspc(image, JAS_CLRSPC_SGRAY);", " \t\tjas_image_setcmpttype(image, 0,", " \t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));", " \t}", " \tif (bmp_getdata(in, info, image)) {", " \t\tbmp_info_destroy(info);", " \t\tjas_image_destroy(image);", " \t\treturn 0;", " \t}", " \tbmp_info_destroy(info);", " \treturn image;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int ff_combine_frame(ParseContext *pc, int next, const uint8_t **buf, int *buf_size)", " {", "     if(pc->overread){", "         av_dlog(NULL, \"overread %d, state:%X next:%d index:%d o_index:%d\\n\",", "                 pc->overread, pc->state, next, pc->index, pc->overread_index);", "         av_dlog(NULL, \"%X %X %X %X\\n\", (*buf)[0], (*buf)[1], (*buf)[2], (*buf)[3]);", "     }", "     for(; pc->overread>0; pc->overread--){", "         pc->buffer[pc->index++]= pc->buffer[pc->overread_index++];", "     }", "     if(!*buf_size && next == END_NOT_FOUND){", "         next= 0;", "     }", "     pc->last_index= pc->index;", "      if(next == END_NOT_FOUND){", "          void* new_buffer = av_fast_realloc(pc->buffer, &pc->buffer_size, (*buf_size) + pc->index + FF_INPUT_BUFFER_PADDING_SIZE);", "        if(!new_buffer)", "         if(!new_buffer) {", "             pc->index = 0;", "              return AVERROR(ENOMEM);", "         }", "          pc->buffer = new_buffer;", "          memcpy(&pc->buffer[pc->index], *buf, *buf_size);", "          pc->index += *buf_size;", "         return -1;", "     }", "     *buf_size=", "     pc->overread_index= pc->index + next;", "      if(pc->index){", "          void* new_buffer = av_fast_realloc(pc->buffer, &pc->buffer_size, next + pc->index + FF_INPUT_BUFFER_PADDING_SIZE);", "        if(!new_buffer)", "         if(!new_buffer) {", "             pc->overread_index =", "             pc->index = 0;", "              return AVERROR(ENOMEM);", "         }", "          pc->buffer = new_buffer;", "          if (next > -FF_INPUT_BUFFER_PADDING_SIZE)", "              memcpy(&pc->buffer[pc->index], *buf,", "                    next + FF_INPUT_BUFFER_PADDING_SIZE);", "         pc->index = 0;", "         *buf= pc->buffer;", "     }", "     for(;next < 0; next++){", "         pc->state = (pc->state<<8) | pc->buffer[pc->last_index + next];", "         pc->state64 = (pc->state64<<8) | pc->buffer[pc->last_index + next];", "         pc->overread++;", "     }", "     if(pc->overread){", "         av_dlog(NULL, \"overread %d, state:%X next:%d index:%d o_index:%d\\n\",", "                 pc->overread, pc->state, next, pc->index, pc->overread_index);", "         av_dlog(NULL, \"%X %X %X %X\\n\", (*buf)[0], (*buf)[1],(*buf)[2],(*buf)[3]);", "     }", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" compile_length_bag_node(BagNode* node, regex_t* reg)", " {", "   int len;", "   int tlen;", "   if (node->type == BAG_OPTION)", "     return compile_length_option_node(node, reg);", "   if (NODE_BAG_BODY(node)) {", "     tlen = compile_length_tree(NODE_BAG_BODY(node), reg);", "     if (tlen < 0) return tlen;", "   }", "   else", "     tlen = 0;", "   switch (node->type) {", "   case BAG_MEMORY:", " #ifdef USE_CALL", "     if (node->m.regnum == 0 && NODE_IS_CALLED(node)) {", "       len = tlen + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN;", "       return len;", "     }", "     if (NODE_IS_CALLED(node)) {", "       len = SIZE_OP_MEMORY_START_PUSH + tlen", "         + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN;", "       if (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum))", "         len += (NODE_IS_RECURSION(node)", "                 ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_PUSH);", "       else", "         len += (NODE_IS_RECURSION(node)", "                 ? SIZE_OP_MEMORY_END_REC : SIZE_OP_MEMORY_END);", "     }", "     else if (NODE_IS_RECURSION(node)) {", "       len = SIZE_OP_MEMORY_START_PUSH;", "       len += tlen + (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum)", "                      ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_REC);", "     }", "     else", " #endif", "     {", "       if (MEM_STATUS_AT0(reg->bt_mem_start, node->m.regnum))", "         len = SIZE_OP_MEMORY_START_PUSH;", "       else", "         len = SIZE_OP_MEMORY_START;", "       len += tlen + (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum)", "                      ? SIZE_OP_MEMORY_END_PUSH : SIZE_OP_MEMORY_END);", "     }", "     break;", "   case BAG_STOP_BACKTRACK:", "     if (NODE_IS_STOP_BT_SIMPLE_REPEAT(node)) {", "       int v;", "       QuantNode* qn;", "       qn = QUANT_(NODE_BAG_BODY(node));", "       tlen = compile_length_tree(NODE_QUANT_BODY(qn), reg);", "       if (tlen < 0) return tlen;", "       v = onig_positive_int_multiply(qn->lower, tlen);", "       if (v < 0) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;", "       len = v + SIZE_OP_PUSH + tlen + SIZE_OP_POP_OUT + SIZE_OP_JUMP;", "     }", "     else {", "       len = SIZE_OP_ATOMIC_START + tlen + SIZE_OP_ATOMIC_END;", "     }", "     break;", "   case BAG_IF_ELSE:", "     {", "       Node* cond = NODE_BAG_BODY(node);", "       Node* Then = node->te.Then;", "       Node* Else = node->te.Else;", "       len = compile_length_tree(cond, reg);", "       if (len < 0) return len;", "       len += SIZE_OP_PUSH;", "       len += SIZE_OP_ATOMIC_START + SIZE_OP_ATOMIC_END;", "       if (IS_NOT_NULL(Then)) {", "         tlen = compile_length_tree(Then, reg);", "         if (tlen < 0) return tlen;", "          len += tlen;", "        }", "       len += SIZE_OP_JUMP + SIZE_OP_ATOMIC_END;", "        if (IS_NOT_NULL(Else)) {", "        len += SIZE_OP_JUMP;", "          tlen = compile_length_tree(Else, reg);", "          if (tlen < 0) return tlen;", "          len += tlen;", "       }", "     }", "     break;", "   case BAG_OPTION:", "     len = 0;", "     break;", "   }", "   return len;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static int myrecvfrom6(int sockfd, void *buf, size_t *buflen, int flags,", "\t\t       struct in6_addr *addr, uint32_t *ifindex)", " \t\t       struct in6_addr *addr, uint32_t *ifindex, int *hoplimit)", "  {", "  \tstruct sockaddr_in6 sin6;", "\tunsigned char cbuf[CMSG_SPACE(sizeof(struct in6_pktinfo))];", " \tunsigned char cbuf[2 * CMSG_SPACE(sizeof(struct in6_pktinfo))];", "  \tstruct iovec iovec;", "  \tstruct msghdr msghdr;", "  \tstruct cmsghdr *cmsghdr;", " \tssize_t len;", " \tiovec.iov_len = *buflen;", " \tiovec.iov_base = buf;", " \tmemset(&msghdr, 0, sizeof(msghdr));", " \tmsghdr.msg_name = &sin6;", " \tmsghdr.msg_namelen = sizeof(sin6);", " \tmsghdr.msg_iov = &iovec;", " \tmsghdr.msg_iovlen = 1;", " \tmsghdr.msg_control = cbuf;", " \tmsghdr.msg_controllen = sizeof(cbuf);", " \tlen = recvmsg(sockfd, &msghdr, flags);", " \tif (len == -1)", " \t\treturn -errno;", " \t*buflen = len;", "  \t*ifindex = sin6.sin6_scope_id;", "          for (cmsghdr = CMSG_FIRSTHDR(&msghdr); cmsghdr;", "  \t     cmsghdr = CMSG_NXTHDR(&msghdr, cmsghdr)) {", "\t\tif (cmsghdr->cmsg_level == IPPROTO_IPV6 &&", "\t\t    cmsghdr->cmsg_type == IPV6_PKTINFO &&", "\t\t    cmsghdr->cmsg_len == CMSG_LEN(sizeof(struct in6_pktinfo))) {", "\t\t\tstruct in6_pktinfo *pktinfo;", " \t\tif (cmsghdr->cmsg_level != IPPROTO_IPV6)", " \t\t\tcontinue;", " \t\tswitch(cmsghdr->cmsg_type) {", " \t\tcase IPV6_PKTINFO:", " \t\t\tif (cmsghdr->cmsg_len == CMSG_LEN(sizeof(struct in6_pktinfo))) {", " \t\t\t\tstruct in6_pktinfo *pktinfo;", " \t\t\t\tpktinfo = (struct in6_pktinfo *) CMSG_DATA(cmsghdr);", " \t\t\t\t*ifindex = pktinfo->ipi6_ifindex;", " \t\t\t}", " \t\t\tbreak;", " \t\tcase IPV6_HOPLIMIT:", " \t\t\tif (cmsghdr->cmsg_len == CMSG_LEN(sizeof(int))) {", " \t\t\t\tint *val;", "\t\t\tpktinfo = (struct in6_pktinfo *) CMSG_DATA(cmsghdr);", "\t\t\t*ifindex = pktinfo->ipi6_ifindex;", " \t\t\t\tval = (int *) CMSG_DATA(cmsghdr);", " \t\t\t\t*hoplimit = *val;", " \t\t\t}", " \t\t\tbreak;", "  \t\t}", "  \t}", "  \t*addr = sin6.sin6_addr;", " \treturn 0;", " }"], "ner_tags": [0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" static int jpc_pi_nextpcrl(register jpc_pi_t *pi)", " {", " \tint rlvlno;", " \tjpc_pirlvl_t *pirlvl;", " \tjpc_pchg_t *pchg;", " \tint prchind;", " \tint prcvind;", " \tint *prclyrno;", " \tint compno;", " \tjpc_picomp_t *picomp;", " \tint xstep;", " \tint ystep;", " \tuint_fast32_t trx0;", " \tuint_fast32_t try0;", " \tuint_fast32_t r;", " \tuint_fast32_t rpx;", " \tuint_fast32_t rpy;", " \tpchg = pi->pchg;", " \tif (!pi->prgvolfirst) {", " \t\tgoto skip;", " \t} else {", " \t\tpi->xstep = 0;", " \t\tpi->ystep = 0;", " \t\tfor (compno = 0, picomp = pi->picomps; compno < pi->numcomps;", "  \t\t  ++compno, ++picomp) {", "  \t\t\tfor (rlvlno = 0, pirlvl = picomp->pirlvls; rlvlno <", "  \t\t\t  picomp->numrlvls; ++rlvlno, ++pirlvl) {", "\t\t\t\txstep = picomp->hsamp * (1 <<", "\t\t\t\t  (pirlvl->prcwidthexpn + picomp->numrlvls -", "\t\t\t\t  rlvlno - 1));", "\t\t\t\tystep = picomp->vsamp * (1 <<", "\t\t\t\t  (pirlvl->prcheightexpn + picomp->numrlvls -", "\t\t\t\t  rlvlno - 1));", "\t\t\t\tpi->xstep = (!pi->xstep) ? xstep :", "\t\t\t\t  JAS_MIN(pi->xstep, xstep);", "\t\t\t\tpi->ystep = (!pi->ystep) ? ystep :", "\t\t\t\t  JAS_MIN(pi->ystep, ystep);", " \t\t\t\tif (pirlvl->prcwidthexpn + pi->picomp->numrlvls >", " \t\t\t\t  JAS_UINTFAST32_NUMBITS - 2 ||", " \t\t\t\t  pirlvl->prcheightexpn + pi->picomp->numrlvls >", " \t\t\t\t  JAS_UINTFAST32_NUMBITS - 2) {", " \t\t\t\t\treturn -1;", " \t\t\t\t}", " \t\t\t\txstep = picomp->hsamp * (JAS_CAST(uint_fast32_t, 1) <<", " \t\t\t\t  (pirlvl->prcwidthexpn + picomp->numrlvls - rlvlno - 1));", " \t\t\t\tystep = picomp->vsamp * (JAS_CAST(uint_fast32_t, 1) <<", " \t\t\t\t  (pirlvl->prcheightexpn + picomp->numrlvls - rlvlno - 1));", " \t\t\t\tpi->xstep = (!pi->xstep) ? xstep : JAS_MIN(pi->xstep, xstep);", " \t\t\t\tpi->ystep = (!pi->ystep) ? ystep : JAS_MIN(pi->ystep, ystep);", "  \t\t\t}", "  \t\t}", "  \t\tpi->prgvolfirst = 0;", " \t}", " \tfor (pi->y = pi->ystart; pi->y < pi->yend; pi->y += pi->ystep -", " \t  (pi->y % pi->ystep)) {", " \t\tfor (pi->x = pi->xstart; pi->x < pi->xend; pi->x += pi->xstep -", " \t\t  (pi->x % pi->xstep)) {", " \t\t\tfor (pi->compno = pchg->compnostart, pi->picomp =", " \t\t\t  &pi->picomps[pi->compno]; pi->compno < pi->numcomps", " \t\t\t  && pi->compno < JAS_CAST(int, pchg->compnoend); ++pi->compno,", " \t\t\t  ++pi->picomp) {", " \t\t\t\tfor (pi->rlvlno = pchg->rlvlnostart,", " \t\t\t\t  pi->pirlvl = &pi->picomp->pirlvls[pi->rlvlno];", " \t\t\t\t  pi->rlvlno < pi->picomp->numrlvls &&", " \t\t\t\t  pi->rlvlno < pchg->rlvlnoend; ++pi->rlvlno,", " \t\t\t\t  ++pi->pirlvl) {", " \t\t\t\t\tif (pi->pirlvl->numprcs == 0) {", " \t\t\t\t\t\tcontinue;", " \t\t\t\t\t}", " \t\t\t\t\tr = pi->picomp->numrlvls - 1 - pi->rlvlno;", " \t\t\t\t\ttrx0 = JPC_CEILDIV(pi->xstart, pi->picomp->hsamp << r);", "  \t\t\t\t\ttry0 = JPC_CEILDIV(pi->ystart, pi->picomp->vsamp << r);", "  \t\t\t\t\trpx = r + pi->pirlvl->prcwidthexpn;", "  \t\t\t\t\trpy = r + pi->pirlvl->prcheightexpn;", "\t\t\t\t\tif (((pi->x == pi->xstart && ((trx0 << r) % (1 << rpx))) ||", " \t\t\t\t\tif (((pi->x == pi->xstart &&", " \t\t\t\t\t  ((trx0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpx))) ||", "  \t\t\t\t\t  !(pi->x % (pi->picomp->hsamp << rpx))) &&", "\t\t\t\t\t  ((pi->y == pi->ystart && ((try0 << r) % (1 << rpy))) ||", " \t\t\t\t\t  ((pi->y == pi->ystart &&", " \t\t\t\t\t  ((try0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpy))) ||", "  \t\t\t\t\t  !(pi->y % (pi->picomp->vsamp << rpy)))) {", "\t\t\t\t\t\tprchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x, pi->picomp->hsamp", "\t\t\t\t\t\t  << r), pi->pirlvl->prcwidthexpn) - JPC_FLOORDIVPOW2(trx0,", "\t\t\t\t\t\t  pi->pirlvl->prcwidthexpn);", "\t\t\t\t\t\tprcvind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->y, pi->picomp->vsamp", "\t\t\t\t\t\t  << r), pi->pirlvl->prcheightexpn) - JPC_FLOORDIVPOW2(try0,", "\t\t\t\t\t\t  pi->pirlvl->prcheightexpn);", " \t\t\t\t\t\tprchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x,", " \t\t\t\t\t\t  pi->picomp->hsamp << r), pi->pirlvl->prcwidthexpn) -", " \t\t\t\t\t\t  JPC_FLOORDIVPOW2(trx0, pi->pirlvl->prcwidthexpn);", " \t\t\t\t\t\tprcvind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->y,", " \t\t\t\t\t\t  pi->picomp->vsamp << r), pi->pirlvl->prcheightexpn) -", " \t\t\t\t\t\t  JPC_FLOORDIVPOW2(try0, pi->pirlvl->prcheightexpn);", "  \t\t\t\t\t\tpi->prcno = prcvind * pi->pirlvl->numhprcs + prchind;", "  \t\t\t\t\t\tassert(pi->prcno < pi->pirlvl->numprcs);", "  \t\t\t\t\t\tfor (pi->lyrno = 0; pi->lyrno < pi->numlyrs &&", "\t\t\t\t\t\t  pi->lyrno < JAS_CAST(int, pchg->lyrnoend); ++pi->lyrno) {", " \t\t\t\t\t\t  pi->lyrno < JAS_CAST(int, pchg->lyrnoend);", " \t\t\t\t\t\t  ++pi->lyrno) {", "  \t\t\t\t\t\t\tprclyrno = &pi->pirlvl->prclyrnos[pi->prcno];", "  \t\t\t\t\t\t\tif (pi->lyrno >= *prclyrno) {", "  \t\t\t\t\t\t\t\t++(*prclyrno);", " \t\t\t\t\t\t\t\treturn 0;", " \t\t\t\t\t\t\t}", " skip:", " \t\t\t\t\t\t\t;", " \t\t\t\t\t\t}", " \t\t\t\t\t}", " \t\t\t\t}", " \t\t\t}", " \t\t}", " \t}", " \treturn 1;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  int sfgets(void)", "  {", "      struct pollfd pfd;", "      int pollret;", "      ssize_t readnb;", "      signed char seen_r = 0;", "    static size_t scanned;", "    static size_t readnbd;", "      if (scanned > (size_t) 0U) {        ", "          readnbd -= scanned;        ", "         memmove(cmd, cmd + scanned, readnbd);    ", "         scanned = (size_t) 0U;", "     }", "     pfd.fd = clientfd;", " #ifdef __APPLE_CC__", "     pfd.events = POLLIN | POLLERR | POLLHUP;", " #else", "     pfd.events = POLLIN | POLLPRI | POLLERR | POLLHUP;", " #endif", "     while (scanned < cmdsize) {", "         if (scanned >= readnbd) {       ", "             pfd.revents = 0;", "             while ((pollret = poll(&pfd, 1U, idletime * 1000UL)) < 0 &&", "                    errno == EINTR);", "             if (pollret == 0) {", "                 return -1;", "             }", "             if (pollret <= 0 ||", "                 (pfd.revents & (POLLERR | POLLHUP | POLLNVAL)) != 0) {", "                 return -2;", "             }", "             if ((pfd.revents & (POLLIN | POLLPRI)) == 0) {", "                 continue;", "             }", "             if (readnbd >= cmdsize) {", "                 break;", "             }", " #ifdef WITH_TLS", "             if (tls_cnx != NULL) {", "                 while ((readnb = SSL_read", "                         (tls_cnx, cmd + readnbd, cmdsize - readnbd))", "                        < (ssize_t) 0 && errno == EINTR);", "             } else", " #endif", "             {", "                 while ((readnb = read(clientfd, cmd + readnbd,", "                                       cmdsize - readnbd)) < (ssize_t) 0 &&", "                        errno == EINTR);", "             }", "             if (readnb <= (ssize_t) 0) {", "                 return -2;", "             }", "             readnbd += readnb;", "             if (readnbd > cmdsize) {", "                 return -2;", "             }", "         }", " #ifdef RFC_CONFORMANT_LINES", "         if (seen_r != 0) {", " #endif", "             if (cmd[scanned] == '\\n') {", " #ifndef RFC_CONFORMANT_LINES", "                 if (seen_r != 0) {", " #endif", "                     cmd[scanned - 1U] = 0;", " #ifndef RFC_CONFORMANT_LINES", "                 } else {", "                     cmd[scanned] = 0;", "                 }", " #endif", "                 if (++scanned >= readnbd) {    ", "                     scanned = readnbd = (size_t) 0U;", "                 }", "                 return 0;", "             }", "             seen_r = 0;", " #ifdef RFC_CONFORMANT_LINES", "         }", " #endif", "         if (ISCTRLCODE(cmd[scanned])) {", "             if (cmd[scanned] == '\\r') {", "                 seen_r = 1;", "             }", " #ifdef RFC_CONFORMANT_PARSER                    ", "             else if (cmd[scanned] == 0) {", "                 cmd[scanned] = '\\n';", "             }", " #else", "             cmd[scanned] = '_';                ", " #endif", "         }", "         scanned++;", "     }", "     die(421, LOG_WARNING, MSG_LINE_TOO_LONG);    ", "     return 0;                          ", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int DecodeGifImg(struct ngiflib_img * i) {", " \tstruct ngiflib_decode_context context;", " \tlong npix;", " \tu8 * stackp;", " \tu8 * stack_top;", " \tu16 clr;", " \tu16 eof;", " \tu16 free;", " \tu16 act_code = 0;", " \tu16 old_code = 0;", " \tu16 read_byt;", " \tu16 ab_prfx[4096];", " \tu8 ab_suffx[4096];", " \tu8 ab_stack[4096];", " \tu8 flags;", " \tu8 casspecial = 0;", " \tif(!i) return -1;", " \ti->posX = GetWord(i->parent);\t ", " \ti->posY = GetWord(i->parent);\t ", " \ti->width = GetWord(i->parent);\t ", " \ti->height = GetWord(i->parent);\t ", " \tif((i->width > i->parent->width) || (i->height > i->parent->height)) {", " #if !defined(NGIFLIB_NO_FILE)", " \t\tif(i->parent->log) fprintf(i->parent->log, \"*** ERROR *** Image bigger than global GIF canvas !\\n\");", " #endif", " \t\treturn -1;", " \t}", " \tif((i->posX + i->width) > i->parent->width) {", " #if !defined(NGIFLIB_NO_FILE)", " \t\tif(i->parent->log) fprintf(i->parent->log, \"*** WARNING *** Adjusting X position\\n\");", " #endif", " \t\ti->posX = i->parent->width - i->width;", " \t}", " \tif((i->posY + i->height) > i->parent->height) {", " #if !defined(NGIFLIB_NO_FILE)", " \t\tif(i->parent->log) fprintf(i->parent->log, \"*** WARNING *** Adjusting Y position\\n\");", " #endif", " \t\ti->posY = i->parent->height - i->height;", " \t}", " \tcontext.Xtogo = i->width;", " \tcontext.curY = i->posY;", " #ifdef NGIFLIB_INDEXED_ONLY", " \t#ifdef NGIFLIB_ENABLE_CALLBACKS", " \tcontext.line_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width;", " \tcontext.frbuff_p.p8 = context.line_p.p8 + i->posX;", " \t#else", " \tcontext.frbuff_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width + i->posX;", " \t#endif  ", " #else", " \tif(i->parent->mode & NGIFLIB_MODE_INDEXED) {", " \t\t#ifdef NGIFLIB_ENABLE_CALLBACKS", " \t\tcontext.line_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width;", " \t\tcontext.frbuff_p.p8 = context.line_p.p8 + i->posX;", " \t\t#else", " \t\tcontext.frbuff_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width + i->posX;", " \t\t#endif  ", " \t} else {", " \t\t#ifdef NGIFLIB_ENABLE_CALLBACKS", " \t\tcontext.line_p.p32 = i->parent->frbuff.p32 + (u32)i->posY*i->parent->width;", " \t\tcontext.frbuff_p.p32 = context.line_p.p32 + i->posX;", " \t\t#else", " \t\tcontext.frbuff_p.p32 = i->parent->frbuff.p32 + (u32)i->posY*i->parent->width + i->posX;", " \t\t#endif  ", " \t}", " #endif  ", " \tnpix = (long)i->width * i->height;", " \tflags = GetByte(i->parent);", " \ti->interlaced = (flags & 64) >> 6;", " \tcontext.pass = i->interlaced ? 1 : 0;", " \ti->sort_flag = (flags & 32) >> 5;\t ", " \ti->localpalbits = (flags & 7) + 1;", " \tif(flags&128) {  ", " \t\tint k;", " \t\tint localpalsize = 1 << i->localpalbits;", " #if !defined(NGIFLIB_NO_FILE)", " \t\tif(i->parent && i->parent->log) fprintf(i->parent->log, \"Local palette\\n\");", " #endif  ", " \t\ti->palette = (struct ngiflib_rgb *)ngiflib_malloc(sizeof(struct ngiflib_rgb)*localpalsize);", " \t\tfor(k=0; k<localpalsize; k++) {", " \t\t\ti->palette[k].r = GetByte(i->parent);", " \t\t\ti->palette[k].g = GetByte(i->parent);", " \t\t\ti->palette[k].b = GetByte(i->parent);", " \t\t}", " #ifdef NGIFLIB_ENABLE_CALLBACKS", " \t\tif(i->parent->palette_cb) i->parent->palette_cb(i->parent, i->palette, localpalsize);", " #endif  ", " \t} else {", " \t\ti->palette = i->parent->palette;", " \t\ti->localpalbits = i->parent->imgbits;", " \t}", " \ti->ncolors = 1 << i->localpalbits;", " \ti->imgbits = GetByte(i->parent);\t ", " #if !defined(NGIFLIB_NO_FILE)", " \tif(i->parent && i->parent->log) {", " \t\tif(i->interlaced) fprintf(i->parent->log, \"interlaced \");", " \t\tfprintf(i->parent->log, \"img pos(%hu,%hu) size %hux%hu palbits=%hhu imgbits=%hhu ncolors=%hu\\n\",", " \t       i->posX, i->posY, i->width, i->height, i->localpalbits, i->imgbits, i->ncolors);", " \t}", " #endif  ", " \tif(i->imgbits==1) {\t ", " \t\ti->imgbits = 2;", " \t}", " \tclr = 1 << i->imgbits;", " \teof = clr + 1;", " \tfree = clr + 2;", " \tcontext.nbbit = i->imgbits + 1;", " \tcontext.max = clr + clr - 1;  ", " \tstackp = stack_top = ab_stack + 4096;", " \tcontext.restbits = 0;\t ", " \tcontext.restbyte = 0;\t ", " \tcontext.lbyte = 0;", " \tfor(;;) {", " \t\tact_code = GetGifWord(i, &context);", " \t\tif(act_code==eof) {", " #if !defined(NGIFLIB_NO_FILE)", " \t\t\tif(i->parent && i->parent->log) fprintf(i->parent->log, \"End of image code\\n\");", " #endif  ", " \t\t\treturn 0;", " \t\t}", " \t\tif(npix==0) {", " #if !defined(NGIFLIB_NO_FILE)", " \t\t\tif(i->parent && i->parent->log) fprintf(i->parent->log, \"assez de pixels, On se casse !\\n\");", " #endif  ", " \t\t\treturn 1;", " \t\t}\t", " \t\tif(act_code==clr) {", " #if !defined(NGIFLIB_NO_FILE)", " \t\t\tif(i->parent && i->parent->log) fprintf(i->parent->log, \"Code clear (free=%hu) npix=%ld\\n\", free, npix);", " #endif  ", " \t\t\tfree = clr + 2;", " \t\t\tcontext.nbbit = i->imgbits + 1;", " \t\t\tcontext.max = clr + clr - 1;  ", "  \t\t\tact_code = GetGifWord(i, &context);", "  \t\t\tcasspecial = (u8)act_code;", "  \t\t\told_code = act_code;", "\t\t\tWritePixel(i, &context, casspecial); npix--;", " \t\t\tif(npix > 0) WritePixel(i, &context, casspecial);", " \t\t\tnpix--;", "  \t\t} else {", "  \t\t\tread_byt = act_code;", "  \t\t\tif(act_code >= free) {\t ", " \t\t\t\t*(--stackp) = casspecial;  ", " \t\t\t\tact_code = old_code;", " \t\t\t}", " \t\t\twhile(act_code > clr) {  ", " \t\t\t\t*(--stackp) = ab_suffx[act_code];", " \t\t\t\tact_code = ab_prfx[act_code];\t ", " \t\t\t}", "  \t\t\tcasspecial = (u8)act_code;\t ", "  \t\t\t*(--stackp) = casspecial;\t ", "\t\t\tWritePixels(i, &context, stackp, stack_top - stackp);\t ", " \t\t\tif(npix >= (stack_top - stackp)) {", " \t\t\t\tWritePixels(i, &context, stackp, stack_top - stackp);\t ", " \t\t\t} else if(npix > 0) {\t ", " \t\t\t\tWritePixels(i, &context, stackp, npix);", " \t\t\t}", "  \t\t\tnpix -= (stack_top - stackp);", "  \t\t\tstackp = stack_top;", " \t\t\tif(free < 4096) {  ", " \t\t\t\tab_prfx[free] = old_code;", " \t\t\t\tab_suffx[free] = (u8)act_code;", " \t\t\t\tfree++;", " \t\t\t\tif((free > context.max) && (context.nbbit < 12)) {", " \t\t\t\t\tcontext.nbbit++;\t ", " \t\t\t\t\tcontext.max += context.max + 1;", " \t\t\t\t}", " \t\t\t}", " \t\t\told_code = read_byt;", " \t\t}", " \t}", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" cssp_read_tsrequest(STREAM token, STREAM pubkey)", " {", "  \tSTREAM s;", "  \tint length;", "  \tint tagval;", " \tstruct stream packet;", "  \ts = tcp_recv(NULL, 4);", " \tif (s == NULL)", " \t\treturn False;", " \tif (s->p[0] != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))", " \t{", " \t\tlogger(Protocol, Error,", " \t\t       \"cssp_read_tsrequest(), expected BER_TAG_SEQUENCE|BER_TAG_CONSTRUCTED, got %x\",", " \t\t       s->p[0]);", " \t\treturn False;", " \t}", " \tif (s->p[1] < 0x80)", " \t\tlength = s->p[1] - 2;", " \telse if (s->p[1] == 0x81)", " \t\tlength = s->p[2] - 1;", " \telse if (s->p[1] == 0x82)", " \t\tlength = (s->p[2] << 8) | s->p[3];", " \telse", " \t\treturn False;", "  \ts = tcp_recv(s, length);", " \tpacket = *s;", "  \tif (!ber_in_header(s, &tagval, &length) ||", " \t    tagval != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))", " \t\treturn False;", "  \tif (!ber_in_header(s, &tagval, &length) ||", "  \t    tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0))", "  \t\treturn False;", " \tif (!s_check_rem(s, length))", " \t{", " \t\t rdp_protocol_error(\"cssp_read_tsrequest(), consume of version from stream would overrun\",", " \t\t\t\t    &packet);", " \t}", "  \tin_uint8s(s, length);", " \tif (token)", " \t{", " \t\tif (!ber_in_header(s, &tagval, &length)", " \t\t    || tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 1))", " \t\t\treturn False;", " \t\tif (!ber_in_header(s, &tagval, &length)", " \t\t    || tagval != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))", " \t\t\treturn False;", " \t\tif (!ber_in_header(s, &tagval, &length)", " \t\t    || tagval != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))", " \t\t\treturn False;", " \t\tif (!ber_in_header(s, &tagval, &length)", " \t\t    || tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0))", " \t\t\treturn False;", "  \t\tif (!ber_in_header(s, &tagval, &length) || tagval != BER_TAG_OCTET_STRING)", "  \t\t\treturn False;", "\t\ttoken->end = token->p = token->data;", " \t\tif (!s_check_rem(s, length))", " \t\t{", " \t\t\trdp_protocol_error(\"cssp_read_tsrequest(), consume of token from stream would overrun\",", " \t\t\t\t\t   &packet);", " \t\t}", " \t\ts_realloc(token, length);", " \t\ts_reset(token);", "  \t\tout_uint8p(token, s->p, length);", "  \t\ts_mark_end(token);", "  \t}", " \tif (pubkey)", " \t{", " \t\tif (!ber_in_header(s, &tagval, &length)", " \t\t    || tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 3))", " \t\t\treturn False;", " \t\tif (!ber_in_header(s, &tagval, &length) || tagval != BER_TAG_OCTET_STRING)", " \t\t\treturn False;", " \t\tpubkey->data = pubkey->p = s->p;", " \t\tpubkey->end = pubkey->data + length;", " \t\tpubkey->size = length;", " \t}", " \treturn True;", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" ProcXFixesCopyRegion(ClientPtr client)", " {", "      RegionPtr pSource, pDestination;", "      REQUEST(xXFixesCopyRegionReq);", "     REQUEST_SIZE_MATCH(xXFixesCopyRegionReq);", "      VERIFY_REGION(pSource, stuff->source, client, DixReadAccess);", "      VERIFY_REGION(pDestination, stuff->destination, client, DixWriteAccess);", "     if (!RegionCopy(pDestination, pSource))", "         return BadAlloc;", "     return Success;", " }"], "ner_tags": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int decode_unit(SCPRContext *s, PixelModel *pixel, unsigned step, unsigned *rval)", " {", "     GetByteContext *gb = &s->gb;", "     RangeCoder *rc = &s->rc;", "     unsigned totfr = pixel->total_freq;", "     unsigned value, x = 0, cumfr = 0, cnt_x = 0;", "     int i, j, ret, c, cnt_c;", "     if ((ret = s->get_freq(rc, totfr, &value)) < 0)", "         return ret;", "     while (x < 16) {", "         cnt_x = pixel->lookup[x];", "         if (value >= cumfr + cnt_x)", "             cumfr += cnt_x;", "         else", "             break;", "         x++;", "     }", "     c = x * 16;", "     cnt_c = 0;", "     while (c < 256) {", "         cnt_c = pixel->freq[c];", "         if (value >= cumfr + cnt_c)", "             cumfr += cnt_c;", "         else", "              break;", "          c++;", "      }", "     if (x >= 16 || c >= 256) {", "         return AVERROR_INVALIDDATA;", "     }", "      if ((ret = s->decode(gb, rc, cumfr, cnt_c, totfr)) < 0)", "          return ret;", "     pixel->freq[c] = cnt_c + step;", "     pixel->lookup[x] = cnt_x + step;", "     totfr += step;", "     if (totfr > BOT) {", "         totfr = 0;", "         for (i = 0; i < 256; i++) {", "             unsigned nc = (pixel->freq[i] >> 1) + 1;", "             pixel->freq[i] = nc;", "             totfr += nc;", "         }", "         for (i = 0; i < 16; i++) {", "             unsigned sum = 0;", "             unsigned i16_17 = i << 4;", "             for (j = 0; j < 16; j++)", "                 sum += pixel->freq[i16_17 + j];", "             pixel->lookup[i] = sum;", "         }", "     }", "     pixel->total_freq = totfr;", "     *rval = c & s->cbits;", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static int ras_getcmap(jas_stream_t *in, ras_hdr_t *hdr, ras_cmap_t *cmap)", " {", " \tint i;", " \tint j;", " \tint x;", " \tint c;", " \tint numcolors;", " \tint actualnumcolors;", " \tswitch (hdr->maptype) {", " \tcase RAS_MT_NONE:", " \t\tbreak;", " \tcase RAS_MT_EQUALRGB:", "  \t\t{", "  \t\tjas_eprintf(\"warning: palettized images not fully supported\\n\");", "  \t\tnumcolors = 1 << hdr->depth;", "\t\tassert(numcolors <= RAS_CMAP_MAXSIZ);", " \t\tif (numcolors > RAS_CMAP_MAXSIZ) {", " \t\t\treturn -1;", " \t\t}", "  \t\tactualnumcolors = hdr->maplength / 3;", "  \t\tfor (i = 0; i < numcolors; i++) {", "  \t\t\tcmap->data[i] = 0;", " \t\t}", " \t\tif ((hdr->maplength % 3) || hdr->maplength < 0 ||", " \t\t  hdr->maplength > 3 * numcolors) {", " \t\t\treturn -1;", " \t\t}", " \t\tfor (i = 0; i < 3; i++) {", " \t\t\tfor (j = 0; j < actualnumcolors; j++) {", " \t\t\t\tif ((c = jas_stream_getc(in)) == EOF) {", " \t\t\t\t\treturn -1;", " \t\t\t\t}", " \t\t\t\tx = 0;", " \t\t\t\tswitch (i) {", " \t\t\t\tcase 0:", " \t\t\t\t\tx = RAS_RED(c);", " \t\t\t\t\tbreak;", " \t\t\t\tcase 1:", " \t\t\t\t\tx = RAS_GREEN(c);", " \t\t\t\t\tbreak;", " \t\t\t\tcase 2:", " \t\t\t\t\tx = RAS_BLUE(c);", " \t\t\t\t\tbreak;", " \t\t\t\t}", " \t\t\t\tcmap->data[j] |= x;", " \t\t\t}", " \t\t}", " \t\t}", " \t\tbreak;", " \tdefault:", " \t\treturn -1;", " \t\tbreak;", " \t}", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" jas_matrix_t *jas_matrix_create(int numrows, int numcols)", " {", "  \tjas_matrix_t *matrix;", "  \tint i;", " \tif (numrows < 0 || numcols < 0) {", " \t\treturn 0;", " \t}", "  \tif (!(matrix = jas_malloc(sizeof(jas_matrix_t)))) {", "  \t\treturn 0;", "  \t}", " \tmatrix->flags_ = 0;", " \tmatrix->numrows_ = numrows;", " \tmatrix->numcols_ = numcols;", " \tmatrix->rows_ = 0;", " \tmatrix->maxrows_ = numrows;", " \tmatrix->data_ = 0;", " \tmatrix->datasize_ = numrows * numcols;", " \tif (matrix->maxrows_ > 0) {", " \t\tif (!(matrix->rows_ = jas_alloc2(matrix->maxrows_,", " \t\t  sizeof(jas_seqent_t *)))) {", " \t\t\tjas_matrix_destroy(matrix);", " \t\t\treturn 0;", " \t\t}", " \t}", " \tif (matrix->datasize_ > 0) {", " \t\tif (!(matrix->data_ = jas_alloc2(matrix->datasize_,", " \t\t  sizeof(jas_seqent_t)))) {", " \t\t\tjas_matrix_destroy(matrix);", " \t\t\treturn 0;", " \t\t}", " \t}", " \tfor (i = 0; i < numrows; ++i) {", " \t\tmatrix->rows_[i] = &matrix->data_[i * matrix->numcols_];", " \t}", " \tfor (i = 0; i < matrix->datasize_; ++i) {", " \t\tmatrix->data_[i] = 0;", " \t}", " \tmatrix->xstart_ = 0;", " \tmatrix->ystart_ = 0;", " \tmatrix->xend_ = matrix->numcols_;", " \tmatrix->yend_ = matrix->numrows_;", " \treturn matrix;", " }"], "ner_tags": [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" ProcPutImage(ClientPtr client)", " {", "     GC *pGC;", "     DrawablePtr pDraw;", "     long length;                 ", "     long lengthProto;            ", "     char *tmpImage;", "     REQUEST(xPutImageReq);", "     REQUEST_AT_LEAST_SIZE(xPutImageReq);", "     VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixWriteAccess);", "     if (stuff->format == XYBitmap) {", "         if ((stuff->depth != 1) ||", "             (stuff->leftPad >= (unsigned int) screenInfo.bitmapScanlinePad))", "             return BadMatch;", "         length = BitmapBytePad(stuff->width + stuff->leftPad);", "     }", "     else if (stuff->format == XYPixmap) {", "         if ((pDraw->depth != stuff->depth) ||", "             (stuff->leftPad >= (unsigned int) screenInfo.bitmapScanlinePad))", "             return BadMatch;", "         length = BitmapBytePad(stuff->width + stuff->leftPad);", "         length *= stuff->depth;", "     }", "     else if (stuff->format == ZPixmap) {", "         if ((pDraw->depth != stuff->depth) || (stuff->leftPad != 0))", "             return BadMatch;", "         length = PixmapBytePad(stuff->width, stuff->depth);", "     }", "     else {", "         client->errorValue = stuff->format;", "         return BadValue;", "     }", "      tmpImage = (char *) &stuff[1];", "      lengthProto = length;", "    if (lengthProto >= (INT32_MAX / stuff->height))", "     if (stuff->height != 0 && lengthProto >= (INT32_MAX / stuff->height))", "          return BadLength;", "      if ((bytes_to_int32(lengthProto * stuff->height) +", "          bytes_to_int32(sizeof(xPutImageReq))) != client->req_len)", "         return BadLength;", "     ReformatImage(tmpImage, lengthProto * stuff->height,", "                   stuff->format == ZPixmap ? BitsPerPixel(stuff->depth) : 1,", "                   ClientOrder(client));", "     (*pGC->ops->PutImage) (pDraw, pGC, stuff->depth, stuff->dstX, stuff->dstY,", "                            stuff->width, stuff->height,", "                            stuff->leftPad, stuff->format, tmpImage);", "     return Success;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" jas_image_t *jp2_decode(jas_stream_t *in, char *optstr)", " {", " \tjp2_box_t *box;", " \tint found;", " \tjas_image_t *image;", " \tjp2_dec_t *dec;", " \tbool samedtype;", " \tint dtype;", " \tunsigned int i;", " \tjp2_cmap_t *cmapd;", " \tjp2_pclr_t *pclrd;", " \tjp2_cdef_t *cdefd;", " \tunsigned int channo;", " \tint newcmptno;", " \tint_fast32_t *lutents;", " #if 0", " \tjp2_cdefchan_t *cdefent;", " \tint cmptno;", " #endif", " \tjp2_cmapent_t *cmapent;", " \tjas_icchdr_t icchdr;", " \tjas_iccprof_t *iccprof;", " \tdec = 0;", " \tbox = 0;", " \timage = 0;", " \tif (!(dec = jp2_dec_create())) {", " \t\tgoto error;", " \t}", " \tif (!(box = jp2_box_get(in))) {", " \t\tjas_eprintf(\"error: cannot get box\\n\");", " \t\tgoto error;", " \t}", " \tif (box->type != JP2_BOX_JP) {", " \t\tjas_eprintf(\"error: expecting signature box\\n\");", " \t\tgoto error;", " \t}", " \tif (box->data.jp.magic != JP2_JP_MAGIC) {", " \t\tjas_eprintf(\"incorrect magic number\\n\");", " \t\tgoto error;", " \t}", " \tjp2_box_destroy(box);", " \tbox = 0;", " \tif (!(box = jp2_box_get(in))) {", " \t\tgoto error;", " \t}", " \tif (box->type != JP2_BOX_FTYP) {", " \t\tjas_eprintf(\"expecting file type box\\n\");", " \t\tgoto error;", " \t}", " \tjp2_box_destroy(box);", " \tbox = 0;", "  \tfound = 0;", "  \twhile ((box = jp2_box_get(in))) {", "  \t\tif (jas_getdbglevel() >= 1) {", "\t\t\tjas_eprintf(\"box type %s\\n\", box->info->name);", " \t\t\tjas_eprintf(\"got box type %s\\n\", box->info->name);", "  \t\t}", "  \t\tswitch (box->type) {", "  \t\tcase JP2_BOX_JP2C:", " \t\t\tfound = 1;", " \t\t\tbreak;", " \t\tcase JP2_BOX_IHDR:", " \t\t\tif (!dec->ihdr) {", " \t\t\t\tdec->ihdr = box;", " \t\t\t\tbox = 0;", " \t\t\t}", " \t\t\tbreak;", " \t\tcase JP2_BOX_BPCC:", " \t\t\tif (!dec->bpcc) {", " \t\t\t\tdec->bpcc = box;", " \t\t\t\tbox = 0;", " \t\t\t}", " \t\t\tbreak;", " \t\tcase JP2_BOX_CDEF:", " \t\t\tif (!dec->cdef) {", " \t\t\t\tdec->cdef = box;", " \t\t\t\tbox = 0;", " \t\t\t}", " \t\t\tbreak;", " \t\tcase JP2_BOX_PCLR:", " \t\t\tif (!dec->pclr) {", " \t\t\t\tdec->pclr = box;", " \t\t\t\tbox = 0;", " \t\t\t}", " \t\t\tbreak;", " \t\tcase JP2_BOX_CMAP:", " \t\t\tif (!dec->cmap) {", " \t\t\t\tdec->cmap = box;", " \t\t\t\tbox = 0;", " \t\t\t}", " \t\t\tbreak;", " \t\tcase JP2_BOX_COLR:", " \t\t\tif (!dec->colr) {", " \t\t\t\tdec->colr = box;", " \t\t\t\tbox = 0;", " \t\t\t}", " \t\t\tbreak;", " \t\t}", " \t\tif (box) {", " \t\t\tjp2_box_destroy(box);", " \t\t\tbox = 0;", " \t\t}", " \t\tif (found) {", " \t\t\tbreak;", " \t\t}", " \t}", " \tif (!found) {", " \t\tjas_eprintf(\"error: no code stream found\\n\");", " \t\tgoto error;", " \t}", " \tif (!(dec->image = jpc_decode(in, optstr))) {", " \t\tjas_eprintf(\"error: cannot decode code stream\\n\");", " \t\tgoto error;", " \t}", " \tif (!dec->ihdr) {", " \t\tjas_eprintf(\"error: missing IHDR box\\n\");", " \t\tgoto error;", " \t}", " \tif (dec->ihdr->data.ihdr.numcmpts != JAS_CAST(uint,", " \t  jas_image_numcmpts(dec->image))) {", " \t\tjas_eprintf(\"warning: number of components mismatch\\n\");", " \t}", " \tif (!jas_image_numcmpts(dec->image)) {", " \t\tjas_eprintf(\"error: no components\\n\");", " \t\tgoto error;", " \t}", " \tsamedtype = true;", " \tdtype = jas_image_cmptdtype(dec->image, 0);", " \tfor (i = 1; i < JAS_CAST(uint, jas_image_numcmpts(dec->image)); ++i) {", " \t\tif (jas_image_cmptdtype(dec->image, i) != dtype) {", " \t\t\tsamedtype = false;", " \t\t\tbreak;", " \t\t}", " \t}", " \tif ((samedtype && dec->ihdr->data.ihdr.bpc != JP2_DTYPETOBPC(dtype)) ||", " \t  (!samedtype && dec->ihdr->data.ihdr.bpc != JP2_IHDR_BPCNULL)) {", " \t\tjas_eprintf(\"warning: component data type mismatch\\n\");", " \t}", " \tif (dec->ihdr->data.ihdr.comptype != JP2_IHDR_COMPTYPE) {", " \t\tjas_eprintf(\"error: unsupported compression type\\n\");", " \t\tgoto error;", " \t}", " \tif (dec->bpcc) {", " \t\tif (dec->bpcc->data.bpcc.numcmpts != JAS_CAST(uint, jas_image_numcmpts(", " \t\t  dec->image))) {", " \t\t\tjas_eprintf(\"warning: number of components mismatch\\n\");", " \t\t}", " \t\tif (!samedtype) {", " \t\t\tfor (i = 0; i < JAS_CAST(uint, jas_image_numcmpts(dec->image));", " \t\t\t  ++i) {", " \t\t\t\tif (jas_image_cmptdtype(dec->image, i) !=", " \t\t\t\t  JP2_BPCTODTYPE(dec->bpcc->data.bpcc.bpcs[i])) {", " \t\t\t\t\tjas_eprintf(\"warning: component data type mismatch\\n\");", " \t\t\t\t}", " \t\t\t}", " \t\t} else {", " \t\t\tjas_eprintf(\"warning: superfluous BPCC box\\n\");", " \t\t}", " \t}", " \tif (!dec->colr) {", " \t\tjas_eprintf(\"error: no COLR box\\n\");", " \t\tgoto error;", " \t}", " \tswitch (dec->colr->data.colr.method) {", " \tcase JP2_COLR_ENUM:", " \t\tjas_image_setclrspc(dec->image, jp2_getcs(&dec->colr->data.colr));", " \t\tbreak;", " \tcase JP2_COLR_ICC:", " \t\ticcprof = jas_iccprof_createfrombuf(dec->colr->data.colr.iccp,", " \t\t  dec->colr->data.colr.iccplen);", " \t\tif (!iccprof) {", " \t\t\tjas_eprintf(\"error: failed to parse ICC profile\\n\");", " \t\t\tgoto error;", " \t\t}", " \t\tjas_iccprof_gethdr(iccprof, &icchdr);", " \t\tjas_eprintf(\"ICC Profile CS %08x\\n\", icchdr.colorspc);", " \t\tjas_image_setclrspc(dec->image, fromiccpcs(icchdr.colorspc));", " \t\tdec->image->cmprof_ = jas_cmprof_createfromiccprof(iccprof);", " \t\tassert(dec->image->cmprof_);", " \t\tjas_iccprof_destroy(iccprof);", " \t\tbreak;", " \t}", " \tif (dec->cmap && !dec->pclr) {", " \t\tjas_eprintf(\"warning: missing PCLR box or superfluous CMAP box\\n\");", " \t\tjp2_box_destroy(dec->cmap);", " \t\tdec->cmap = 0;", " \t}", " \tif (!dec->cmap && dec->pclr) {", " \t\tjas_eprintf(\"warning: missing CMAP box or superfluous PCLR box\\n\");", " \t\tjp2_box_destroy(dec->pclr);", " \t\tdec->pclr = 0;", " \t}", " \tdec->numchans = dec->cmap ? dec->cmap->data.cmap.numchans :", " \t  JAS_CAST(uint, jas_image_numcmpts(dec->image));", " \tif (dec->cmap) {", " \t\tfor (i = 0; i < dec->numchans; ++i) {", " \t\t\tif (dec->cmap->data.cmap.ents[i].cmptno >= JAS_CAST(uint,", " \t\t\t  jas_image_numcmpts(dec->image))) {", " \t\t\t\tjas_eprintf(\"error: invalid component number in CMAP box\\n\");", " \t\t\t\tgoto error;", " \t\t\t}", " \t\t\tif (dec->cmap->data.cmap.ents[i].pcol >=", " \t\t\t  dec->pclr->data.pclr.numchans) {", " \t\t\t\tjas_eprintf(\"error: invalid CMAP LUT index\\n\");", " \t\t\t\tgoto error;", " \t\t\t}", " \t\t}", " \t}", " \tif (!(dec->chantocmptlut = jas_alloc2(dec->numchans,", " \t  sizeof(uint_fast16_t)))) {", " \t\tjas_eprintf(\"error: no memory\\n\");", " \t\tgoto error;", " \t}", " \tif (!dec->cmap) {", " \t\tfor (i = 0; i < dec->numchans; ++i) {", " \t\t\tdec->chantocmptlut[i] = i;", " \t\t}", " \t} else {", " \t\tcmapd = &dec->cmap->data.cmap;", " \t\tpclrd = &dec->pclr->data.pclr;", " \t\tcdefd = &dec->cdef->data.cdef;", " \t\tfor (channo = 0; channo < cmapd->numchans; ++channo) {", " \t\t\tcmapent = &cmapd->ents[channo];", " \t\t\tif (cmapent->map == JP2_CMAP_DIRECT) {", " \t\t\t\tdec->chantocmptlut[channo] = channo;", " \t\t\t} else if (cmapent->map == JP2_CMAP_PALETTE) {", " \t\t\t\tlutents = jas_alloc2(pclrd->numlutents, sizeof(int_fast32_t));", " \t\t\t\tfor (i = 0; i < pclrd->numlutents; ++i) {", " \t\t\t\t\tlutents[i] = pclrd->lutdata[cmapent->pcol + i * pclrd->numchans];", " \t\t\t\t}", " \t\t\t\tnewcmptno = jas_image_numcmpts(dec->image);", " \t\t\t\tjas_image_depalettize(dec->image, cmapent->cmptno,", " \t\t\t\t  pclrd->numlutents, lutents,", " \t\t\t\t  JP2_BPCTODTYPE(pclrd->bpc[cmapent->pcol]), newcmptno);", " \t\t\t\tdec->chantocmptlut[channo] = newcmptno;", " \t\t\t\tjas_free(lutents);", " #if 0", " \t\t\t\tif (dec->cdef) {", " \t\t\t\t\tcdefent = jp2_cdef_lookup(cdefd, channo);", " \t\t\t\t\tif (!cdefent) {", " \t\t\t\t\t\tabort();", " \t\t\t\t\t}", " \t\t\t\tjas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), cdefent->type, cdefent->assoc));", " \t\t\t\t} else {", " \t\t\t\tjas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), 0, channo + 1));", " \t\t\t\t}", " #endif", " \t\t\t}", " \t\t}", " \t}", " \tfor (i = 0; i < JAS_CAST(uint, jas_image_numcmpts(dec->image)); ++i) {", " \t\tjas_image_setcmpttype(dec->image, i, JAS_IMAGE_CT_UNKNOWN);", " \t}", " \tif (dec->cdef) {", " \t\tfor (i = 0; i < dec->numchans; ++i) {", " \t\t\tif (dec->cdef->data.cdef.ents[i].channo >= dec->numchans) {", " \t\t\t\tjas_eprintf(\"error: invalid channel number in CDEF box\\n\");", " \t\t\t\tgoto error;", " \t\t\t}", " \t\t\tjas_image_setcmpttype(dec->image,", " \t\t\t  dec->chantocmptlut[dec->cdef->data.cdef.ents[i].channo],", " \t\t\t  jp2_getct(jas_image_clrspc(dec->image),", " \t\t\t  dec->cdef->data.cdef.ents[i].type,", " \t\t\t  dec->cdef->data.cdef.ents[i].assoc));", " \t\t}", " \t} else {", " \t\tfor (i = 0; i < dec->numchans; ++i) {", " \t\t\tjas_image_setcmpttype(dec->image, dec->chantocmptlut[i],", " \t\t\t  jp2_getct(jas_image_clrspc(dec->image), 0, i + 1));", " \t\t}", " \t}", " \tfor (i = jas_image_numcmpts(dec->image); i > 0; --i) {", " \t\tif (jas_image_cmpttype(dec->image, i - 1) == JAS_IMAGE_CT_UNKNOWN) {", " \t\t\tjas_image_delcmpt(dec->image, i - 1);", " \t\t}", " \t}", " \tif (!jas_image_numcmpts(dec->image)) {", " \t\tjas_eprintf(\"error: no components\\n\");", " \t\tgoto error;", " \t}", " #if 0", " jas_eprintf(\"no of components is %d\\n\", jas_image_numcmpts(dec->image));", " #endif", " \timage = dec->image;", " \tdec->image = 0;", " \tjp2_dec_destroy(dec);", " \treturn image;", " error:", " \tif (box) {", " \t\tjp2_box_destroy(box);", " \t}", " \tif (dec) {", " \t\tjp2_dec_destroy(dec);", " \t}", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" jpc_ms_t *jpc_getms(jas_stream_t *in, jpc_cstate_t *cstate)", " {", " \tjpc_ms_t *ms;", " \tjpc_mstabent_t *mstabent;", " \tjas_stream_t *tmpstream;", " \tif (!(ms = jpc_ms_create(0))) {", " \t\treturn 0;", " \t}", " \tif (jpc_getuint16(in, &ms->id) || ms->id < JPC_MS_MIN ||", " \t  ms->id > JPC_MS_MAX) {", " \t\tjpc_ms_destroy(ms);", " \t\treturn 0;", " \t}", " \tmstabent = jpc_mstab_lookup(ms->id);", " \tms->ops = &mstabent->ops;", " \tif (JPC_MS_HASPARMS(ms->id)) {", " \t\tif (jpc_getuint16(in, &ms->len) || ms->len < 3) {", " \t\t\tjpc_ms_destroy(ms);", " \t\t\treturn 0;", " \t\t}", " \t\tms->len -= 2;", " \t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {", " \t\t\tjpc_ms_destroy(ms);", " \t\t\treturn 0;", " \t\t}", " \t\tif (jas_stream_copy(tmpstream, in, ms->len) ||", " \t\t  jas_stream_seek(tmpstream, 0, SEEK_SET) < 0) {", " \t\t\tjas_stream_close(tmpstream);", " \t\t\tjpc_ms_destroy(ms);", " \t\t\treturn 0;", " \t\t}", " \t\tif ((*ms->ops->getparms)(ms, cstate, tmpstream)) {", " \t\t\tms->ops = 0;", " \t\t\tjpc_ms_destroy(ms);", " \t\t\tjas_stream_close(tmpstream);", " \t\t\treturn 0;", " \t\t}", " \t\tif (jas_getdbglevel() > 0) {", "  \t\t\tjpc_ms_dump(ms, stderr);", "  \t\t}", "\t\tif (JAS_CAST(ulong, jas_stream_tell(tmpstream)) != ms->len) {", " \t\tif (JAS_CAST(jas_ulong, jas_stream_tell(tmpstream)) != ms->len) {", "  \t\t\tjas_eprintf(", "  \t\t\t  \"warning: trailing garbage in marker segment (%ld bytes)\\n\",", "  \t\t\t  ms->len - jas_stream_tell(tmpstream));", " \t\t}", " \t\tjas_stream_close(tmpstream);", " \t} else {", " \t\tms->len = 0;", " \t\tif (jas_getdbglevel() > 0) {", " \t\t\tjpc_ms_dump(ms, stderr);", " \t\t}", " \t}", " \tif (ms->id == JPC_MS_SIZ) {", " \t\tcstate->numcomps = ms->parms.siz.numcomps;", " \t}", " \treturn ms;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int main(int argc, char *argv[])", " {", " \tint32_t ret = GPMF_OK;", " \tGPMF_stream metadata_stream, *ms = &metadata_stream;", " \tdouble metadatalength;", " \tuint32_t *payload = NULL;  ", " \tif (argc != 2)", " \t{", " \t\tprintf(\"usage: %s <file_with_GPMF>\\n\", argv[0]);", " \t\treturn -1;", "  \t}", "  \tsize_t mp4 = OpenMP4Source(argv[1], MOV_GPMF_TRAK_TYPE, MOV_GPMF_TRAK_SUBTYPE);", " \tif (mp4 == 0)", " \t{", " \t\tprintf(\"error: %s is an invalid MP4/MOV\\n\", argv[1]);", " \t\treturn -1;", " \t}", "  \tmetadatalength = GetDuration(mp4);", " \tif (metadatalength > 0.0)", " \t{", " \t\tuint32_t index, payloads = GetNumberPayloads(mp4);", " #if 1", " \t\tif (payloads == 1)  ", " \t\t{", " \t\t\tuint32_t payloadsize = GetPayloadSize(mp4,0);", " \t\t\tpayload = GetPayload(mp4, payload, 0);", " \t\t\tif(payload == NULL)", " \t\t\t\tgoto cleanup;", " \t\t\tret = GPMF_Init(ms, payload, payloadsize);", " \t\t\tif (ret != GPMF_OK)", " \t\t\t\tgoto cleanup;", " \t\t\tret = GPMF_Validate(ms, GPMF_RECURSE_LEVELS);  ", " \t\t\tif (GPMF_OK != ret)", " \t\t\t{", " \t\t\t\tprintf(\"Invalid Structure\\n\");", " \t\t\t\tgoto cleanup;", " \t\t\t}", " \t\t\tGPMF_ResetState(ms);", " \t\t\tdo", " \t\t\t{", " \t\t\t\tPrintGPMF(ms);   ", " \t\t\t} while (GPMF_OK == GPMF_Next(ms, GPMF_RECURSE_LEVELS));", " \t\t\tGPMF_ResetState(ms);", " \t\t\tprintf(\"\\n\");", " \t\t}", " #endif", "  \t\tfor (index = 0; index < payloads; index++)", "  \t\t{", "  \t\t\tuint32_t payloadsize = GetPayloadSize(mp4, index);", "\t\t\tfloat in = 0.0, out = 0.0;  ", " \t\t\tdouble in = 0.0, out = 0.0;  ", "  \t\t\tpayload = GetPayload(mp4, payload, index);", "  \t\t\tif (payload == NULL)", "  \t\t\t\tgoto cleanup;", " \t\t\tret = GetPayloadTime(mp4, index, &in, &out);", " \t\t\tif (ret != GPMF_OK)", " \t\t\t\tgoto cleanup;", " \t\t\tret = GPMF_Init(ms, payload, payloadsize);", " \t\t\tif (ret != GPMF_OK)", " \t\t\t\tgoto cleanup;", " #if 1\t\t ", " \t\t\tif (index == 0)  ", " \t\t\t{", " \t\t\t\tret = GPMF_FindNext(ms, GPMF_KEY_STREAM, GPMF_RECURSE_LEVELS);", " \t\t\t\twhile (GPMF_OK == ret)", " \t\t\t\t{", " \t\t\t\t\tret = GPMF_SeekToSamples(ms);", " \t\t\t\t\tif (GPMF_OK == ret)  ", " \t\t\t\t\t{", " \t\t\t\t\t\tuint32_t key = GPMF_Key(ms);", " \t\t\t\t\t\tGPMF_SampleType type = GPMF_Type(ms);", " \t\t\t\t\t\tuint32_t elements = GPMF_ElementsInStruct(ms);", " \t\t\t\t\t\tuint32_t samples = GPMF_PayloadSampleCount(ms);", " \t\t\t\t\t\tif (samples)", " \t\t\t\t\t\t{", " \t\t\t\t\t\t\tprintf(\"  STRM of %c%c%c%c \", PRINTF_4CC(key));", " \t\t\t\t\t\t\tif (type == GPMF_TYPE_COMPLEX)", " \t\t\t\t\t\t\t{", " \t\t\t\t\t\t\t\tGPMF_stream find_stream;", " \t\t\t\t\t\t\t\tGPMF_CopyState(ms, &find_stream);", " \t\t\t\t\t\t\t\tif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TYPE, GPMF_CURRENT_LEVEL))", " \t\t\t\t\t\t\t\t{", " \t\t\t\t\t\t\t\t\tchar tmp[64];", " \t\t\t\t\t\t\t\t\tchar *data = (char *)GPMF_RawData(&find_stream);", " \t\t\t\t\t\t\t\t\tint size = GPMF_RawDataSize(&find_stream);", " \t\t\t\t\t\t\t\t\tif (size < sizeof(tmp))", " \t\t\t\t\t\t\t\t\t{", " \t\t\t\t\t\t\t\t\t\tmemcpy(tmp, data, size);", " \t\t\t\t\t\t\t\t\t\ttmp[size] = 0;", " \t\t\t\t\t\t\t\t\t\tprintf(\"of type %s \", tmp);", " \t\t\t\t\t\t\t\t\t}", " \t\t\t\t\t\t\t\t}", " \t\t\t\t\t\t\t}", " \t\t\t\t\t\t\telse", " \t\t\t\t\t\t\t{", " \t\t\t\t\t\t\t\tprintf(\"of type %c \", type);", " \t\t\t\t\t\t\t}", " \t\t\t\t\t\t\tprintf(\"with %d sample%s \", samples, samples > 1 ? \"s\" : \"\");", " \t\t\t\t\t\t\tif (elements > 1)", " \t\t\t\t\t\t\t\tprintf(\"-- %d elements per sample\", elements);", " \t\t\t\t\t\t\tprintf(\"\\n\");", " \t\t\t\t\t\t}", " \t\t\t\t\t\tret = GPMF_FindNext(ms, GPMF_KEY_STREAM, GPMF_RECURSE_LEVELS);", " \t\t\t\t\t}", " \t\t\t\t\telse", " \t\t\t\t\t{", " \t\t\t\t\t\tif (ret == GPMF_ERROR_BAD_STRUCTURE)  ", " \t\t\t\t\t\t{", " \t\t\t\t\t\t\tret = GPMF_Next(ms, GPMF_CURRENT_LEVEL);  ", " \t\t\t\t\t\t}", " \t\t\t\t\t}", " \t\t\t\t}", " \t\t\t\tGPMF_ResetState(ms);", " \t\t\t\tprintf(\"\\n\");", " \t\t\t}", " #endif ", " #if 1\t\t ", " \t\t\tif (index == 0)  ", " \t\t\t{", " \t\t\t\tif (GPMF_OK == GPMF_FindNext(ms, STR2FOURCC(\"GPS5\"), GPMF_RECURSE_LEVELS) ||  ", " \t\t\t\t\tGPMF_OK == GPMF_FindNext(ms, STR2FOURCC(\"GPRI\"), GPMF_RECURSE_LEVELS))    ", " \t\t\t\t{", " \t\t\t\t\tuint32_t key = GPMF_Key(ms);", " \t\t\t\t\tuint32_t samples = GPMF_Repeat(ms);", " \t\t\t\t\tuint32_t elements = GPMF_ElementsInStruct(ms);", " \t\t\t\t\tuint32_t buffersize = samples * elements * sizeof(double);", " \t\t\t\t\tGPMF_stream find_stream;", " \t\t\t\t\tdouble *ptr, *tmpbuffer = malloc(buffersize);", " \t\t\t\t\tchar units[10][6] = { \"\" };", " \t\t\t\t\tuint32_t unit_samples = 1;", " \t\t\t\t\tprintf(\"MP4 Payload time %.3f to %.3f seconds\\n\", in, out);", " \t\t\t\t\tif (tmpbuffer && samples)", " \t\t\t\t\t{", " \t\t\t\t\t\tuint32_t i, j;", " \t\t\t\t\t\tGPMF_CopyState(ms, &find_stream);", " \t\t\t\t\t\tif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_SI_UNITS, GPMF_CURRENT_LEVEL) ||", " \t\t\t\t\t\t\tGPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_UNITS, GPMF_CURRENT_LEVEL))", " \t\t\t\t\t\t{", " \t\t\t\t\t\t\tchar *data = (char *)GPMF_RawData(&find_stream);", " \t\t\t\t\t\t\tint ssize = GPMF_StructSize(&find_stream);", " \t\t\t\t\t\t\tunit_samples = GPMF_Repeat(&find_stream);", " \t\t\t\t\t\t\tfor (i = 0; i < unit_samples; i++)", " \t\t\t\t\t\t\t{", " \t\t\t\t\t\t\t\tmemcpy(units[i], data, ssize);", " \t\t\t\t\t\t\t\tunits[i][ssize] = 0;", " \t\t\t\t\t\t\t\tdata += ssize;", " \t\t\t\t\t\t\t}", " \t\t\t\t\t\t}", " \t\t\t\t\t\tGPMF_ScaledData(ms, tmpbuffer, buffersize, 0, samples, GPMF_TYPE_DOUBLE);   ", " \t\t\t\t\t\tptr = tmpbuffer;", " \t\t\t\t\t\tfor (i = 0; i < samples; i++)", " \t\t\t\t\t\t{", " \t\t\t\t\t\t\tprintf(\"%c%c%c%c \", PRINTF_4CC(key));", " \t\t\t\t\t\t\tfor (j = 0; j < elements; j++)", " \t\t\t\t\t\t\t\tprintf(\"%.3f%s, \", *ptr++, units[j%unit_samples]);", " \t\t\t\t\t\t\tprintf(\"\\n\");", " \t\t\t\t\t\t}", " \t\t\t\t\t\tfree(tmpbuffer);", " \t\t\t\t\t}", " \t\t\t\t}", " \t\t\t\tGPMF_ResetState(ms);", " \t\t\t\tprintf(\"\\n\");", " \t\t\t}", " #endif ", " \t\t}", " #if 1", " \t\twhile (GPMF_OK == GPMF_FindNext(ms, GPMF_KEY_STREAM, GPMF_RECURSE_LEVELS))", "  \t\t{", "  \t\t\tif (GPMF_OK == GPMF_SeekToSamples(ms))  ", "  \t\t\t{", " \t\t\t\tdouble in = 0.0, out = 0.0;", "  \t\t\t\tuint32_t fourcc = GPMF_Key(ms);", "\t\t\t\tdouble rate = GetGPMFSampleRate(mp4, fourcc, GPMF_SAMPLE_RATE_PRECISE); ", "\t\t\t\tprintf(\"%c%c%c%c sampling rate = %f Hz\\n\", PRINTF_4CC(fourcc), rate);", " \t\t\t\tdouble rate = GetGPMFSampleRate(mp4, fourcc, GPMF_SAMPLE_RATE_PRECISE, &in, &out); ", " \t\t\t\tprintf(\"%c%c%c%c sampling rate = %f Hz (from %f to %f)\\n\", PRINTF_4CC(fourcc), rate, in, out);", "  \t\t\t}", "  \t\t}", "  #endif", " \tcleanup:", " \t\tif (payload) FreePayload(payload); payload = NULL;", " \t\tCloseSource(mp4);", " \t}", " \treturn ret;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int mem_resize(jas_stream_memobj_t *m, int bufsize)", "  {", "  \tunsigned char *buf;", "\tassert(m->buf_);", "  \tassert(bufsize >= 0);", "\tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char)))) {", " \tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&", " \t  bufsize) {", "  \t\treturn -1;", "  \t}", "  \tm->buf_ = buf;", " \tm->bufsize_ = bufsize;", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  smb2_flush(smb_request_t *sr)", "  {", "\tsmb_ofile_t *of = NULL;", "  \tuint16_t StructSize;", "  \tuint16_t reserved1;", "  \tuint32_t reserved2;", " \tsmb2fid_t smb2fid;", " \tuint32_t status;", " \tint rc = 0;", " \trc = smb_mbc_decodef(", " \t    &sr->smb_data, \"wwlqq\",", " \t    &StructSize,\t\t ", " \t    &reserved1,\t\t\t ", " \t    &reserved2,\t\t\t ", " \t    &smb2fid.persistent,\t ", " \t    &smb2fid.temporal);\t\t ", " \tif (rc)", " \t\treturn (SDRC_ERROR);", " \tif (StructSize != 24)", " \t\treturn (SDRC_ERROR);", " \tstatus = smb2sr_lookup_fid(sr, &smb2fid);", " \tif (status) {", "  \t\tsmb2sr_put_error(sr, status);", "  \t\treturn (SDRC_SUCCESS);", "  \t}", "\tof = sr->fid_ofile;", "\tif ((of->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)", "\t\t(void) smb_fsop_commit(sr, of->f_cr, of->f_node);", " \tsmb_ofile_flush(sr, sr->fid_ofile);", " \t(void) smb_mbc_encodef(", " \t    &sr->reply, \"wwl\",", " \t    4,\t \t ", " \t    0);  \t\t ", " \treturn (SDRC_SUCCESS);", " }"], "ner_tags": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  void jslTokenAsString(int token, char *str, size_t len) {", "   assert(len>28);  ", "    if (token>32 && token<128) {", "      assert(len>=4);", "     str[0] = '\\'';", "     str[1] = (char)token;", "     str[2] = '\\'';", "     str[3] = 0;", "      return;", "    }", "    switch (token) {", "  case LEX_EOF : strncpy(str, \"EOF\", len); return;", "  case LEX_ID : strncpy(str, \"ID\", len); return;", "  case LEX_INT : strncpy(str, \"INT\", len); return;", "  case LEX_FLOAT : strncpy(str, \"FLOAT\", len); return;", "  case LEX_STR : strncpy(str, \"STRING\", len); return;", "  case LEX_UNFINISHED_STR : strncpy(str, \"UNFINISHED STRING\", len); return;", "  case LEX_TEMPLATE_LITERAL : strncpy(str, \"TEMPLATE LITERAL\", len); return;", "  case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy(str, \"UNFINISHED TEMPLATE LITERAL\", len); return;", "  case LEX_REGEX : strncpy(str, \"REGEX\", len); return;", "  case LEX_UNFINISHED_REGEX : strncpy(str, \"UNFINISHED REGEX\", len); return;", "  case LEX_UNFINISHED_COMMENT : strncpy(str, \"UNFINISHED COMMENT\", len); return;", "   case LEX_EOF : strcpy(str, \"EOF\"); return;", "   case LEX_ID : strcpy(str, \"ID\"); return;", "   case LEX_INT : strcpy(str, \"INT\"); return;", "   case LEX_FLOAT : strcpy(str, \"FLOAT\"); return;", "   case LEX_STR : strcpy(str, \"STRING\"); return;", "   case LEX_UNFINISHED_STR : strcpy(str, \"UNFINISHED STRING\"); return;", "   case LEX_TEMPLATE_LITERAL : strcpy(str, \"TEMPLATE LITERAL\"); return;", "   case LEX_UNFINISHED_TEMPLATE_LITERAL : strcpy(str, \"UNFINISHED TEMPLATE LITERAL\"); return;", "   case LEX_REGEX : strcpy(str, \"REGEX\"); return;", "   case LEX_UNFINISHED_REGEX : strcpy(str, \"UNFINISHED REGEX\"); return;", "   case LEX_UNFINISHED_COMMENT : strcpy(str, \"UNFINISHED COMMENT\"); return;", "    }", "    if (token>=_LEX_OPERATOR_START && token<_LEX_R_LIST_END) {", "      const char tokenNames[] =", "           \"==\\0\"", "           \"===\\0\"", "           \"!=\\0\"", "           \"!==\\0\"", "           \"<=\\0\"", "           \"<<\\0\"", "           \"<<=\\0\"", "           \">=\\0\"", "           \">>\\0\"", "           \">>>\\0\"", "           \">>=\\0\"", "           \">>>=\\0\"", "           \"+=\\0\"", "           \"-=\\0\"", "           \"++\\0\"", "           \"--\\0\"", "           \"*=\\0\"", "           \"/=\\0\"", "           \"%=\\0\"", "           \"&=\\0\"", "           \"&&\\0\"", "           \"|=\\0\"", "           \"||\\0\"", "           \"^=\\0\"", "           \"=>\\0\"", "           \"if\\0\"", "           \"else\\0\"", "           \"do\\0\"", "           \"while\\0\"", "           \"for\\0\"", "           \"return\\0\"", "           \"continue\\0\"", "           \"function\\0\"", "           \"return\\0\"", "           \"var\\0\"", "           \"let\\0\"", "           \"const\\0\"", "           \"this\\0\"", "           \"throw\\0\"", "           \"try\\0\"", "           \"catch\\0\"", "           \"finally\\0\"", "           \"true\\0\"", "           \"false\\0\"", "           \"null\\0\"", "           \"undefined\\0\"", "           \"new\\0\"", "           \"in\\0\"", "           \"instanceof\\0\"", "           \"switch\\0\"", "           \"case\\0\"", "           \"default\\0\"", "           \"delete\\0\"", "           \"typeof\\0\"", "           \"void\\0\"", "           \"debugger\\0\"", "           \"class\\0\"", "           \"extends\\0\"", "             \"super\\0\"", "           \"static\\0\"", "         ;", "     unsigned int p = 0;", "     int n = token-_LEX_OPERATOR_START;", "     while (n>0 && p<sizeof(tokenNames)) {", "       while (tokenNames[p] && p<sizeof(tokenNames)) p++;", "       p++;  ", "        n--;  ", "      }", "      assert(n==0);", "    strncpy(str, &tokenNames[p], len);", "     strcpy(str, &tokenNames[p]);", "      return;", "    }", "  assert(len>=10);", "    espruino_snprintf(str, len, \"?[%d]\", token);", "  }"], "ner_tags": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0]}
{"tokens": [" static int xpm_decode_frame(AVCodecContext *avctx, void *data,", "                             int *got_frame, AVPacket *avpkt)", "  {", "      XPMDecContext *x = avctx->priv_data;", "      AVFrame *p=data;", "    const uint8_t *end, *ptr = avpkt->data;", "     const uint8_t *end, *ptr;", "      int ncolors, cpp, ret, i, j;", "      int64_t size;", "      uint32_t *dst;", "      avctx->pix_fmt = AV_PIX_FMT_BGRA;", "    end = avpkt->data + avpkt->size;", "    while (memcmp(ptr, \"/* XPM */\", 9) && ptr < end - 9)", "     av_fast_padded_malloc(&x->buf, &x->buf_size, avpkt->size);", "     if (!x->buf)", "         return AVERROR(ENOMEM);", "     memcpy(x->buf, avpkt->data, avpkt->size);", "     x->buf[avpkt->size] = 0;", "     ptr = x->buf;", "     end = x->buf + avpkt->size;", "     while (end - ptr > 9 && memcmp(ptr, \"/* XPM */\", 9))", "          ptr++;", "    if (ptr >= end) {", "     if (end - ptr <= 9) {", "          av_log(avctx, AV_LOG_ERROR, \"missing signature\\n\");", "          return AVERROR_INVALIDDATA;", "      }", "     ptr += mod_strcspn(ptr, \"\\\"\");", "     if (sscanf(ptr, \"\\\"%u %u %u %u\\\",\",", "                &avctx->width, &avctx->height, &ncolors, &cpp) != 4) {", "         av_log(avctx, AV_LOG_ERROR, \"missing image parameters\\n\");", "         return AVERROR_INVALIDDATA;", "     }", "     if ((ret = ff_set_dimensions(avctx, avctx->width, avctx->height)) < 0)", "         return ret;", "     if ((ret = ff_get_buffer(avctx, p, 0)) < 0)", "         return ret;", "     if (cpp <= 0 || cpp >= 5) {", "         av_log(avctx, AV_LOG_ERROR, \"unsupported/invalid number of chars per pixel: %d\\n\", cpp);", "         return AVERROR_INVALIDDATA;", "     }", "      size = 1;", "      for (i = 0; i < cpp; i++)", "        size *= 94;", "         size *= 95;", "      if (ncolors <= 0 || ncolors > size) {", "          av_log(avctx, AV_LOG_ERROR, \"invalid number of colors: %d\\n\", ncolors);", "         return AVERROR_INVALIDDATA;", "     }", "     size *= 4;", "     av_fast_padded_malloc(&x->pixels, &x->pixels_size, size);", "     if (!x->pixels)", "          return AVERROR(ENOMEM);", "      ptr += mod_strcspn(ptr, \",\") + 1;", "     if (end - ptr < 1)", "         return AVERROR_INVALIDDATA;", "      for (i = 0; i < ncolors; i++) {", "          const uint8_t *index;", "          int len;", "          ptr += mod_strcspn(ptr, \"\\\"\") + 1;", "        if (ptr + cpp > end)", "         if (end - ptr < cpp)", "              return AVERROR_INVALIDDATA;", "          index = ptr;", "          ptr += cpp;", "         ptr = strstr(ptr, \"c \");", "         if (ptr) {", "             ptr += 2;", "         } else {", "             return AVERROR_INVALIDDATA;", "         }", "         len = strcspn(ptr, \"\\\" \");", "         if ((ret = ascii2index(index, cpp)) < 0)", "             return ret;", "          x->pixels[ret] = color_string_to_rgba(ptr, len);", "          ptr += mod_strcspn(ptr, \",\") + 1;", "         if (end - ptr < 1)", "             return AVERROR_INVALIDDATA;", "      }", "      for (i = 0; i < avctx->height; i++) {", "          dst = (uint32_t *)(p->data[0] + i * p->linesize[0]);", "         if (end - ptr < 1)", "             return AVERROR_INVALIDDATA;", "          ptr += mod_strcspn(ptr, \"\\\"\") + 1;", "         if (end - ptr < 1)", "             return AVERROR_INVALIDDATA;", "          for (j = 0; j < avctx->width; j++) {", "            if (ptr + cpp > end)", "             if (end - ptr < cpp)", "                  return AVERROR_INVALIDDATA;", "              if ((ret = ascii2index(ptr, cpp)) < 0)", "                 return ret;", "             *dst++ = x->pixels[ret];", "             ptr += cpp;", "         }", "         ptr += mod_strcspn(ptr, \",\") + 1;", "     }", "     p->key_frame = 1;", "     p->pict_type = AV_PICTURE_TYPE_I;", "     *got_frame = 1;", "     return avpkt->size;", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" yyparse (void *yyscanner, HEX_LEX_ENVIRONMENT *lex_env)", " {", " int yychar;", " YY_INITIAL_VALUE (static YYSTYPE yyval_default;)", " YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);", "     int yynerrs;", "     int yystate;", "     int yyerrstatus;", "     yytype_int16 yyssa[YYINITDEPTH];", "     yytype_int16 *yyss;", "     yytype_int16 *yyssp;", "     YYSTYPE yyvsa[YYINITDEPTH];", "     YYSTYPE *yyvs;", "     YYSTYPE *yyvsp;", "     YYSIZE_T yystacksize;", "   int yyn;", "   int yyresult;", "   int yytoken = 0;", "   YYSTYPE yyval;", " #if YYERROR_VERBOSE", "   char yymsgbuf[128];", "   char *yymsg = yymsgbuf;", "   YYSIZE_T yymsg_alloc = sizeof yymsgbuf;", " #endif", " #define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))", "   int yylen = 0;", "   yyssp = yyss = yyssa;", "   yyvsp = yyvs = yyvsa;", "   yystacksize = YYINITDEPTH;", "   YYDPRINTF ((stderr, \"Starting parse\\n\"));", "   yystate = 0;", "   yyerrstatus = 0;", "   yynerrs = 0;", "   yychar = YYEMPTY;  ", "   goto yysetstate;", "  yynewstate:", "   yyssp++;", "  yysetstate:", "   *yyssp = yystate;", "   if (yyss + yystacksize - 1 <= yyssp)", "     {", "       YYSIZE_T yysize = yyssp - yyss + 1;", " #ifdef yyoverflow", "       {", "         YYSTYPE *yyvs1 = yyvs;", "         yytype_int16 *yyss1 = yyss;", "         yyoverflow (YY_(\"memory exhausted\"),", "                     &yyss1, yysize * sizeof (*yyssp),", "                     &yyvs1, yysize * sizeof (*yyvsp),", "                     &yystacksize);", "         yyss = yyss1;", "         yyvs = yyvs1;", "       }", " #else  ", " # ifndef YYSTACK_RELOCATE", "       goto yyexhaustedlab;", " # else", "       if (YYMAXDEPTH <= yystacksize)", "         goto yyexhaustedlab;", "       yystacksize *= 2;", "       if (YYMAXDEPTH < yystacksize)", "         yystacksize = YYMAXDEPTH;", "       {", "         yytype_int16 *yyss1 = yyss;", "         union yyalloc *yyptr =", "           (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));", "         if (! yyptr)", "           goto yyexhaustedlab;", "         YYSTACK_RELOCATE (yyss_alloc, yyss);", "         YYSTACK_RELOCATE (yyvs_alloc, yyvs);", " #  undef YYSTACK_RELOCATE", "         if (yyss1 != yyssa)", "           YYSTACK_FREE (yyss1);", "       }", " # endif", " #endif  ", "       yyssp = yyss + yysize - 1;", "       yyvsp = yyvs + yysize - 1;", "       YYDPRINTF ((stderr, \"Stack size increased to %lu\\n\",", "                   (unsigned long int) yystacksize));", "       if (yyss + yystacksize - 1 <= yyssp)", "         YYABORT;", "     }", "   YYDPRINTF ((stderr, \"Entering state %d\\n\", yystate));", "   if (yystate == YYFINAL)", "     YYACCEPT;", "   goto yybackup;", " yybackup:", "   yyn = yypact[yystate];", "   if (yypact_value_is_default (yyn))", "     goto yydefault;", "   if (yychar == YYEMPTY)", "     {", "       YYDPRINTF ((stderr, \"Reading a token: \"));", "       yychar = yylex (&yylval, yyscanner, lex_env);", "     }", "   if (yychar <= YYEOF)", "     {", "       yychar = yytoken = YYEOF;", "       YYDPRINTF ((stderr, \"Now at end of input.\\n\"));", "     }", "   else", "     {", "       yytoken = YYTRANSLATE (yychar);", "       YY_SYMBOL_PRINT (\"Next token is\", yytoken, &yylval, &yylloc);", "     }", "   yyn += yytoken;", "   if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)", "     goto yydefault;", "   yyn = yytable[yyn];", "   if (yyn <= 0)", "     {", "       if (yytable_value_is_error (yyn))", "         goto yyerrlab;", "       yyn = -yyn;", "       goto yyreduce;", "     }", "   if (yyerrstatus)", "     yyerrstatus--;", "   YY_SYMBOL_PRINT (\"Shifting\", yytoken, &yylval, &yylloc);", "   yychar = YYEMPTY;", "   yystate = yyn;", "   YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN", "   *++yyvsp = yylval;", "   YY_IGNORE_MAYBE_UNINITIALIZED_END", "   goto yynewstate;", " yydefault:", "   yyn = yydefact[yystate];", "   if (yyn == 0)", "     goto yyerrlab;", "   goto yyreduce;", " yyreduce:", "   yylen = yyr2[yyn];", "   yyval = yyvsp[1-yylen];", "   YY_REDUCE_PRINT (yyn);", "    switch (yyn)", "      {", "          case 2:", "#line 106 \"hex_grammar.y\"  ", " #line 113 \"hex_grammar.y\"  ", "      {", "          RE_AST* re_ast = yyget_extra(yyscanner);", "          re_ast->root_node = (yyvsp[-1].re_node);", "        }", "#line 1330 \"hex_grammar.c\"  ", " #line 1337 \"hex_grammar.c\"  ", "      break;", "    case 3:", "#line 115 \"hex_grammar.y\"  ", " #line 122 \"hex_grammar.y\"  ", "      {", "          (yyval.re_node) = (yyvsp[0].re_node);", "        }", "#line 1338 \"hex_grammar.c\"  ", " #line 1345 \"hex_grammar.c\"  ", "      break;", "    case 4:", "#line 119 \"hex_grammar.y\"  ", " #line 126 \"hex_grammar.y\"  ", "      {", "         incr_ast_levels();", "          (yyval.re_node) = yr_re_node_create(RE_NODE_CONCAT, (yyvsp[-1].re_node), (yyvsp[0].re_node));", "          DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[-1].re_node));", "          DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[0].re_node));", "          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);", "        }", "#line 1351 \"hex_grammar.c\"  ", " #line 1360 \"hex_grammar.c\"  ", "      break;", "    case 5:", "#line 128 \"hex_grammar.y\"  ", " #line 137 \"hex_grammar.y\"  ", "      {", "          RE_NODE* new_concat;", "          RE_NODE* leftmost_concat = NULL;", "          RE_NODE* leftmost_node = (yyvsp[-1].re_node);", "         incr_ast_levels();", "          (yyval.re_node) = NULL;", "         while (leftmost_node->type == RE_NODE_CONCAT)", "         {", "           leftmost_concat = leftmost_node;", "           leftmost_node = leftmost_node->left;", "         }", "         new_concat = yr_re_node_create(", "             RE_NODE_CONCAT, (yyvsp[-2].re_node), leftmost_node);", "         if (new_concat != NULL)", "         {", "           if (leftmost_concat != NULL)", "           {", "             leftmost_concat->left = new_concat;", "             (yyval.re_node) = yr_re_node_create(RE_NODE_CONCAT, (yyvsp[-1].re_node), (yyvsp[0].re_node));", "           }", "           else", "           {", "             (yyval.re_node) = yr_re_node_create(RE_NODE_CONCAT, new_concat, (yyvsp[0].re_node));", "           }", "         }", "         DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[-2].re_node));", "         DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[-1].re_node));", "         DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[0].re_node));", "          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);", "        }", "#line 1413 \"hex_grammar.c\"  ", " #line 1424 \"hex_grammar.c\"  ", "      break;", "    case 6:", "#line 190 \"hex_grammar.y\"  ", " #line 201 \"hex_grammar.y\"  ", "      {", "          (yyval.re_node) = (yyvsp[0].re_node);", "        }", "#line 1421 \"hex_grammar.c\"  ", " #line 1432 \"hex_grammar.c\"  ", "      break;", "    case 7:", "#line 194 \"hex_grammar.y\"  ", " #line 205 \"hex_grammar.y\"  ", "      {", "         incr_ast_levels();", "          (yyval.re_node) = yr_re_node_create(RE_NODE_CONCAT, (yyvsp[-1].re_node), (yyvsp[0].re_node));", "          DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[-1].re_node));", "          DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[0].re_node));", "          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);", "        }", "#line 1434 \"hex_grammar.c\"  ", " #line 1447 \"hex_grammar.c\"  ", "      break;", "    case 8:", "#line 207 \"hex_grammar.y\"  ", " #line 220 \"hex_grammar.y\"  ", "      {", "          (yyval.re_node) = (yyvsp[0].re_node);", "        }", "#line 1442 \"hex_grammar.c\"  ", " #line 1455 \"hex_grammar.c\"  ", "      break;", "    case 9:", "#line 211 \"hex_grammar.y\"  ", " #line 224 \"hex_grammar.y\"  ", "      {", "          (yyval.re_node) = (yyvsp[0].re_node);", "          (yyval.re_node)->greedy = FALSE;", "        }", "#line 1451 \"hex_grammar.c\"  ", " #line 1464 \"hex_grammar.c\"  ", "      break;", "    case 10:", "#line 220 \"hex_grammar.y\"  ", " #line 233 \"hex_grammar.y\"  ", "      {", "          lex_env->token_count++;", "         if (lex_env->token_count > MAX_HEX_STRING_TOKENS)", "         {", "           yr_re_node_destroy((yyvsp[0].re_node));", "           yyerror(yyscanner, lex_env, \"string too long\");", "           YYABORT;", "         }", "          (yyval.re_node) = (yyvsp[0].re_node);", "        }", "#line 1468 \"hex_grammar.c\"  ", " #line 1481 \"hex_grammar.c\"  ", "      break;", "    case 11:", "#line 233 \"hex_grammar.y\"  ", " #line 246 \"hex_grammar.y\"  ", "      {", "          lex_env->inside_or++;", "        }", "#line 1476 \"hex_grammar.c\"  ", " #line 1489 \"hex_grammar.c\"  ", "      break;", "    case 12:", "#line 237 \"hex_grammar.y\"  ", " #line 250 \"hex_grammar.y\"  ", "      {", "          (yyval.re_node) = (yyvsp[-1].re_node);", "          lex_env->inside_or--;", "        }", "#line 1485 \"hex_grammar.c\"  ", " #line 1498 \"hex_grammar.c\"  ", "      break;", "    case 13:", "#line 246 \"hex_grammar.y\"  ", " #line 259 \"hex_grammar.y\"  ", "      {", "          if ((yyvsp[-1].integer) <= 0)", "          {", "           yyerror(yyscanner, lex_env, \"invalid jump length\");", "           YYABORT;", "         }", "         if (lex_env->inside_or && (yyvsp[-1].integer) > STRING_CHAINING_THRESHOLD)", "         {", "           yyerror(yyscanner, lex_env, \"jumps over \"", "               STR(STRING_CHAINING_THRESHOLD)", "               \" now allowed inside alternation (|)\");", "           YYABORT;", "         }", "         (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY, NULL, NULL);", "         ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);", "          (yyval.re_node)->start = (int) (yyvsp[-1].integer);", "          (yyval.re_node)->end = (int) (yyvsp[-1].integer);", "        }", "#line 1512 \"hex_grammar.c\"  ", " #line 1525 \"hex_grammar.c\"  ", "      break;", "    case 14:", "#line 269 \"hex_grammar.y\"  ", " #line 282 \"hex_grammar.y\"  ", "      {", "          if (lex_env->inside_or &&", "              ((yyvsp[-3].integer) > STRING_CHAINING_THRESHOLD ||", "              (yyvsp[-1].integer) > STRING_CHAINING_THRESHOLD) )", "         {", "           yyerror(yyscanner, lex_env, \"jumps over \"", "               STR(STRING_CHAINING_THRESHOLD)", "               \" now allowed inside alternation (|)\");", "           YYABORT;", "         }", "         if ((yyvsp[-3].integer) < 0 || (yyvsp[-1].integer) < 0)", "         {", "           yyerror(yyscanner, lex_env, \"invalid negative jump length\");", "           YYABORT;", "         }", "         if ((yyvsp[-3].integer) > (yyvsp[-1].integer))", "         {", "           yyerror(yyscanner, lex_env, \"invalid jump range\");", "           YYABORT;", "         }", "         (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY, NULL, NULL);", "         ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);", "          (yyval.re_node)->start = (int) (yyvsp[-3].integer);", "          (yyval.re_node)->end = (int) (yyvsp[-1].integer);", "        }", "#line 1548 \"hex_grammar.c\"  ", " #line 1561 \"hex_grammar.c\"  ", "      break;", "    case 15:", "#line 301 \"hex_grammar.y\"  ", " #line 314 \"hex_grammar.y\"  ", "      {", "          if (lex_env->inside_or)", "          {", "           yyerror(yyscanner, lex_env,", "               \"unbounded jumps not allowed inside alternation (|)\");", "           YYABORT;", "         }", "         if ((yyvsp[-2].integer) < 0)", "         {", "           yyerror(yyscanner, lex_env, \"invalid negative jump length\");", "           YYABORT;", "         }", "         (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY, NULL, NULL);", "         ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);", "          (yyval.re_node)->start = (int) (yyvsp[-2].integer);", "          (yyval.re_node)->end = INT_MAX;", "        }", "#line 1574 \"hex_grammar.c\"  ", " #line 1587 \"hex_grammar.c\"  ", "      break;", "    case 16:", "#line 323 \"hex_grammar.y\"  ", " #line 336 \"hex_grammar.y\"  ", "      {", "          if (lex_env->inside_or)", "          {", "           yyerror(yyscanner, lex_env,", "               \"unbounded jumps not allowed inside alternation (|)\");", "           YYABORT;", "         }", "         (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY, NULL, NULL);", "         ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);", "          (yyval.re_node)->start = 0;", "          (yyval.re_node)->end = INT_MAX;", "        }", "#line 1594 \"hex_grammar.c\"  ", " #line 1607 \"hex_grammar.c\"  ", "      break;", "    case 17:", "#line 343 \"hex_grammar.y\"  ", " #line 356 \"hex_grammar.y\"  ", "      {", "            (yyval.re_node) = (yyvsp[0].re_node);", "        }", "#line 1602 \"hex_grammar.c\"  ", " #line 1615 \"hex_grammar.c\"  ", "      break;", "    case 18:", "#line 347 \"hex_grammar.y\"  ", " #line 360 \"hex_grammar.y\"  ", "      {", "          mark_as_not_fast_regexp();", "         incr_ast_levels();", "          (yyval.re_node) = yr_re_node_create(RE_NODE_ALT, (yyvsp[-2].re_node), (yyvsp[0].re_node));", "         DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[-2].re_node));", "         DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[0].re_node));", "          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);", "        }", "#line 1617 \"hex_grammar.c\"  ", " #line 1631 \"hex_grammar.c\"  ", "      break;", "    case 19:", "#line 361 \"hex_grammar.y\"  ", " #line 375 \"hex_grammar.y\"  ", "      {", "          (yyval.re_node) = yr_re_node_create(RE_NODE_LITERAL, NULL, NULL);", "          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);", "          (yyval.re_node)->value = (int) (yyvsp[0].integer);", "        }", "#line 1629 \"hex_grammar.c\"  ", " #line 1643 \"hex_grammar.c\"  ", "      break;", "    case 20:", "#line 369 \"hex_grammar.y\"  ", " #line 383 \"hex_grammar.y\"  ", "      {", "          uint8_t mask = (uint8_t) ((yyvsp[0].integer) >> 8);", "         if (mask == 0x00)", "         {", "           (yyval.re_node) = yr_re_node_create(RE_NODE_ANY, NULL, NULL);", "           ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);", "         }", "         else", "         {", "           (yyval.re_node) = yr_re_node_create(RE_NODE_MASKED_LITERAL, NULL, NULL);", "           ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);", "           (yyval.re_node)->value = (yyvsp[0].integer) & 0xFF;", "            (yyval.re_node)->mask = mask;", "          }", "        }", "#line 1653 \"hex_grammar.c\"  ", " #line 1667 \"hex_grammar.c\"  ", "      break;", "#line 1657 \"hex_grammar.c\"  ", " #line 1671 \"hex_grammar.c\"  ", "        default: break;", "      }", "   YY_SYMBOL_PRINT (\"-> $$ =\", yyr1[yyn], &yyval, &yyloc);", "   YYPOPSTACK (yylen);", "   yylen = 0;", "   YY_STACK_PRINT (yyss, yyssp);", "   *++yyvsp = yyval;", "   yyn = yyr1[yyn];", "   yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;", "   if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)", "     yystate = yytable[yystate];", "   else", "     yystate = yydefgoto[yyn - YYNTOKENS];", "   goto yynewstate;", " yyerrlab:", "   yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);", "   if (!yyerrstatus)", "     {", "       ++yynerrs;", " #if ! YYERROR_VERBOSE", "       yyerror (yyscanner, lex_env, YY_(\"syntax error\"));", " #else", " # define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \\", "                                         yyssp, yytoken)", "       {", "         char const *yymsgp = YY_(\"syntax error\");", "         int yysyntax_error_status;", "         yysyntax_error_status = YYSYNTAX_ERROR;", "         if (yysyntax_error_status == 0)", "           yymsgp = yymsg;", "         else if (yysyntax_error_status == 1)", "           {", "             if (yymsg != yymsgbuf)", "               YYSTACK_FREE (yymsg);", "             yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);", "             if (!yymsg)", "               {", "                 yymsg = yymsgbuf;", "                 yymsg_alloc = sizeof yymsgbuf;", "                 yysyntax_error_status = 2;", "               }", "             else", "               {", "                 yysyntax_error_status = YYSYNTAX_ERROR;", "                 yymsgp = yymsg;", "               }", "           }", "         yyerror (yyscanner, lex_env, yymsgp);", "         if (yysyntax_error_status == 2)", "           goto yyexhaustedlab;", "       }", " # undef YYSYNTAX_ERROR", " #endif", "     }", "   if (yyerrstatus == 3)", "     {", "       if (yychar <= YYEOF)", "         {", "           if (yychar == YYEOF)", "             YYABORT;", "         }", "       else", "         {", "           yydestruct (\"Error: discarding\",", "                       yytoken, &yylval, yyscanner, lex_env);", "           yychar = YYEMPTY;", "         }", "     }", "   goto yyerrlab1;", " yyerrorlab:", "   if (  0)", "      goto yyerrorlab;", "   YYPOPSTACK (yylen);", "   yylen = 0;", "   YY_STACK_PRINT (yyss, yyssp);", "   yystate = *yyssp;", "   goto yyerrlab1;", " yyerrlab1:", "   yyerrstatus = 3;       ", "   for (;;)", "     {", "       yyn = yypact[yystate];", "       if (!yypact_value_is_default (yyn))", "         {", "           yyn += YYTERROR;", "           if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)", "             {", "               yyn = yytable[yyn];", "               if (0 < yyn)", "                 break;", "             }", "         }", "       if (yyssp == yyss)", "         YYABORT;", "       yydestruct (\"Error: popping\",", "                   yystos[yystate], yyvsp, yyscanner, lex_env);", "       YYPOPSTACK (1);", "       yystate = *yyssp;", "       YY_STACK_PRINT (yyss, yyssp);", "     }", "   YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN", "   *++yyvsp = yylval;", "   YY_IGNORE_MAYBE_UNINITIALIZED_END", "   YY_SYMBOL_PRINT (\"Shifting\", yystos[yyn], yyvsp, yylsp);", "   yystate = yyn;", "   goto yynewstate;", " yyacceptlab:", "   yyresult = 0;", "   goto yyreturn;", " yyabortlab:", "   yyresult = 1;", "   goto yyreturn;", " #if !defined yyoverflow || YYERROR_VERBOSE", " yyexhaustedlab:", "   yyerror (yyscanner, lex_env, YY_(\"memory exhausted\"));", "   yyresult = 2;", " #endif", " yyreturn:", "   if (yychar != YYEMPTY)", "     {", "       yytoken = YYTRANSLATE (yychar);", "       yydestruct (\"Cleanup: discarding lookahead\",", "                   yytoken, &yylval, yyscanner, lex_env);", "     }", "   YYPOPSTACK (yylen);", "   YY_STACK_PRINT (yyss, yyssp);", "   while (yyssp != yyss)", "     {", "       yydestruct (\"Cleanup: popping\",", "                   yystos[*yyssp], yyvsp, yyscanner, lex_env);", "       YYPOPSTACK (1);", "     }", " #ifndef yyoverflow", "   if (yyss != yyssa)", "     YYSTACK_FREE (yyss);", " #endif", " #if YYERROR_VERBOSE", "   if (yymsg != yymsgbuf)", "     YYSTACK_FREE (yymsg);", "  #endif", "    return yyresult;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" forward_search_range(regex_t* reg, const UChar* str, const UChar* end, UChar* s,", " \t\t     UChar* range, UChar** low, UChar** high, UChar** low_prev)", " {", "   UChar *p, *pprev = (UChar* )NULL;", " #ifdef ONIG_DEBUG_SEARCH", "   fprintf(stderr, \"forward_search_range: str: %d, end: %d, s: %d, range: %d\\n\",", " \t  (int )str, (int )end, (int )s, (int )range);", " #endif", "   p = s;", "   if (reg->dmin > 0) {", "     if (ONIGENC_IS_SINGLEBYTE(reg->enc)) {", "       p += reg->dmin;", "      }", "      else {", "        UChar *q = p + reg->dmin;", "       if (q >= end) return 0;  ", "        while (p < q) p += enclen(reg->enc, p);", "      }", "    }", "  retry:", "   switch (reg->optimize) {", "   case ONIG_OPTIMIZE_EXACT:", "     p = slow_search(reg->enc, reg->exact, reg->exact_end, p, end, range);", "     break;", "   case ONIG_OPTIMIZE_EXACT_IC:", "     p = slow_search_ic(reg->enc, reg->case_fold_flag,", "                        reg->exact, reg->exact_end, p, end, range);", "     break;", "   case ONIG_OPTIMIZE_EXACT_BM:", "     p = bm_search(reg, reg->exact, reg->exact_end, p, end, range);", "     break;", "   case ONIG_OPTIMIZE_EXACT_BM_NOT_REV:", "     p = bm_search_notrev(reg, reg->exact, reg->exact_end, p, end, range);", "     break;", "   case ONIG_OPTIMIZE_MAP:", "     p = map_search(reg->enc, reg->map, p, range);", "     break;", "   }", "   if (p && p < range) {", "     if (p - reg->dmin < s) {", "     retry_gate:", "       pprev = p;", "       p += enclen(reg->enc, p);", "       goto retry;", "     }", "     if (reg->sub_anchor) {", "       UChar* prev;", "       switch (reg->sub_anchor) {", "       case ANCHOR_BEGIN_LINE:", "         if (!ON_STR_BEGIN(p)) {", "           prev = onigenc_get_prev_char_head(reg->enc,", "                                             (pprev ? pprev : str), p);", "           if (!ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))", "             goto retry_gate;", "         }", "         break;", "       case ANCHOR_END_LINE:", "         if (ON_STR_END(p)) {", " #ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE", "           prev = (UChar* )onigenc_get_prev_char_head(reg->enc,", "                                                      (pprev ? pprev : str), p);", "           if (prev && ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))", "             goto retry_gate;", " #endif", "         }", "         else if (! ONIGENC_IS_MBC_NEWLINE(reg->enc, p, end)", " #ifdef USE_CRNL_AS_LINE_TERMINATOR", "                  && ! ONIGENC_IS_MBC_CRNL(reg->enc, p, end)", " #endif", "                  )", "           goto retry_gate;", "         break;", "       }", "     }", "     if (reg->dmax == 0) {", "       *low = p;", "       if (low_prev) {", "         if (*low > s)", "           *low_prev = onigenc_get_prev_char_head(reg->enc, s, p);", "         else", "           *low_prev = onigenc_get_prev_char_head(reg->enc,", "                                                  (pprev ? pprev : str), p);", "       }", "     }", "     else {", "       if (reg->dmax != ONIG_INFINITE_DISTANCE) {", "         *low = p - reg->dmax;", "         if (*low > s) {", "           *low = onigenc_get_right_adjust_char_head_with_prev(reg->enc, s,", "                                           *low, (const UChar** )low_prev);", "           if (low_prev && IS_NULL(*low_prev))", "             *low_prev = onigenc_get_prev_char_head(reg->enc,", "                                                    (pprev ? pprev : s), *low);", "         }", "         else {", "           if (low_prev)", "             *low_prev = onigenc_get_prev_char_head(reg->enc,", "                                                    (pprev ? pprev : str), *low);", "         }", "       }", "     }", "     *high = p - reg->dmin;", " #ifdef ONIG_DEBUG_SEARCH", "     fprintf(stderr,", "     \"forward_search_range success: low: %d, high: %d, dmin: %d, dmax: %d\\n\",", " \t    (int )(*low - str), (int )(*high - str), reg->dmin, reg->dmax);", " #endif", "     return 1;  ", "   }", "   return 0;  ", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static uint8_t excluded_channels(bitfile *ld, drc_info *drc)", " {", "     uint8_t i, n = 0;", "     uint8_t num_excl_chan = 7;", "     for (i = 0; i < 7; i++)", "     {", "         drc->exclude_mask[i] = faad_get1bit(ld", "             DEBUGVAR(1,103,\"excluded_channels(): exclude_mask\"));", "     }", "     n++;", "      while ((drc->additional_excluded_chns[n-1] = faad_get1bit(ld", "          DEBUGVAR(1,104,\"excluded_channels(): additional_excluded_chns\"))) == 1)", "      {", "         if (i >= MAX_CHANNELS - num_excl_chan - 7)", "             return n;", "          for (i = num_excl_chan; i < num_excl_chan+7; i++)", "          {", "              drc->exclude_mask[i] = faad_get1bit(ld", "                 DEBUGVAR(1,105,\"excluded_channels(): exclude_mask\"));", "         }", "         n++;", "         num_excl_chan += 7;", "     }", "     return n;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" ProcXIChangeHierarchy(ClientPtr client)", " {", "     xXIAnyHierarchyChangeInfo *any;", "     size_t len;\t\t\t ", "     int rc = Success;", "     int flags[MAXDEVICES] = { 0 };", "     REQUEST(xXIChangeHierarchyReq);", "     REQUEST_AT_LEAST_SIZE(xXIChangeHierarchyReq);", "      if (!stuff->num_changes)", "          return rc;", "    len = ((size_t)stuff->length << 2) - sizeof(xXIAnyHierarchyChangeInfo);", "     len = ((size_t)stuff->length << 2) - sizeof(xXIChangeHierarchyReq);", "      any = (xXIAnyHierarchyChangeInfo *) &stuff[1];", "      while (stuff->num_changes--) {", "         if (len < sizeof(xXIAnyHierarchyChangeInfo)) {", "             rc = BadLength;", "             goto unwind;", "         }", "         SWAPIF(swaps(&any->type));", "         SWAPIF(swaps(&any->length));", "         if (len < ((size_t)any->length << 2))", "             return BadLength;", " #define CHANGE_SIZE_MATCH(type) \\", "     do { \\", "         if ((len < sizeof(type)) || (any->length != (sizeof(type) >> 2))) { \\", "             rc = BadLength; \\", "             goto unwind; \\", "         } \\", "     } while(0)", "         switch (any->type) {", "         case XIAddMaster:", "         {", "             xXIAddMasterInfo *c = (xXIAddMasterInfo *) any;", "             if (len < sizeof(xXIAddMasterInfo)) {", "                 rc = BadLength;", "                 goto unwind;", "             }", "             SWAPIF(swaps(&c->name_len));", "             if (c->name_len > (len - sizeof(xXIAddMasterInfo))) {", "                 rc = BadLength;", "                 goto unwind;", "             }", "             rc = add_master(client, c, flags);", "             if (rc != Success)", "                 goto unwind;", "         }", "             break;", "         case XIRemoveMaster:", "         {", "             xXIRemoveMasterInfo *r = (xXIRemoveMasterInfo *) any;", "             CHANGE_SIZE_MATCH(xXIRemoveMasterInfo);", "             rc = remove_master(client, r, flags);", "             if (rc != Success)", "                 goto unwind;", "         }", "             break;", "         case XIDetachSlave:", "         {", "             xXIDetachSlaveInfo *c = (xXIDetachSlaveInfo *) any;", "             CHANGE_SIZE_MATCH(xXIDetachSlaveInfo);", "             rc = detach_slave(client, c, flags);", "             if (rc != Success)", "                 goto unwind;", "         }", "             break;", "         case XIAttachSlave:", "         {", "             xXIAttachSlaveInfo *c = (xXIAttachSlaveInfo *) any;", "             CHANGE_SIZE_MATCH(xXIAttachSlaveInfo);", "             rc = attach_slave(client, c, flags);", "             if (rc != Success)", "                 goto unwind;", "         }", "             break;", "         }", "         len -= any->length * 4;", "         any = (xXIAnyHierarchyChangeInfo *) ((char *) any + any->length * 4);", "     }", "  unwind:", "     XISendDeviceHierarchyEvent(flags);", "     return rc;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int filter_frame(AVFilterLink *inlink, AVFrame *frame)", " {", "     AVFilterContext *ctx = inlink->dst;", "     const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);", "      uint32_t plane_checksum[4] = {0}, checksum = 0;", "      int i, plane, vsub = desc->log2_chroma_h;", "    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {", "     for (plane = 0; plane < 4 && frame->data[plane] && frame->linesize[plane]; plane++) {", "          int64_t linesize = av_image_get_linesize(frame->format, frame->width, plane);", "          uint8_t *data = frame->data[plane];", "          int h = plane == 1 || plane == 2 ? FF_CEIL_RSHIFT(inlink->h, vsub) : inlink->h;", "         if (linesize < 0)", "             return linesize;", "         for (i = 0; i < h; i++) {", "             plane_checksum[plane] = av_adler32_update(plane_checksum[plane], data, linesize);", "             checksum = av_adler32_update(checksum, data, linesize);", "             data += frame->linesize[plane];", "         }", "     }", "     av_log(ctx, AV_LOG_INFO,", "            \"n:%\"PRId64\" pts:%s pts_time:%s pos:%\"PRId64\" \"", "            \"fmt:%s sar:%d/%d s:%dx%d i:%c iskey:%d type:%c \"", "            \"checksum:%08X plane_checksum:[%08X\",", "            inlink->frame_count,", "            av_ts2str(frame->pts), av_ts2timestr(frame->pts, &inlink->time_base), av_frame_get_pkt_pos(frame),", "            desc->name,", "            frame->sample_aspect_ratio.num, frame->sample_aspect_ratio.den,", "            frame->width, frame->height,", "            !frame->interlaced_frame ? 'P' :          ", "            frame->top_field_first   ? 'T' : 'B',     ", "            frame->key_frame,", "             av_get_picture_type_char(frame->pict_type),", "             checksum, plane_checksum[0]);", "    for (plane = 1; plane < 4 && frame->data[plane]; plane++)", "     for (plane = 1; plane < 4 && frame->data[plane] && frame->linesize[plane]; plane++)", "          av_log(ctx, AV_LOG_INFO, \" %08X\", plane_checksum[plane]);", "      av_log(ctx, AV_LOG_INFO, \"]\\n\");", "     return ff_filter_frame(inlink->dst->outputs[0], frame);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0]}
{"tokens": [" static int read_gab2_sub(AVFormatContext *s, AVStream *st, AVPacket *pkt)", " {", "     if (pkt->size >= 7 &&", "         pkt->size < INT_MAX - AVPROBE_PADDING_SIZE &&", "         !strcmp(pkt->data, \"GAB2\") && AV_RL16(pkt->data + 5) == 2) {", "         uint8_t desc[256];", "         int score      = AVPROBE_SCORE_EXTENSION, ret;", "         AVIStream *ast = st->priv_data;", "         AVInputFormat *sub_demuxer;", "         AVRational time_base;", "         int size;", "         AVIOContext *pb = avio_alloc_context(pkt->data + 7,", "                                              pkt->size - 7,", "                                              0, NULL, NULL, NULL, NULL);", "         AVProbeData pd;", "         unsigned int desc_len = avio_rl32(pb);", "         if (desc_len > pb->buf_end - pb->buf_ptr)", "             goto error;", "         ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));", "         avio_skip(pb, desc_len - ret);", "         if (*desc)", "             av_dict_set(&st->metadata, \"title\", desc, 0);", "         avio_rl16(pb);    ", "         avio_rl32(pb);    ", "         size = pb->buf_end - pb->buf_ptr;", "         pd = (AVProbeData) { .buf      = av_mallocz(size + AVPROBE_PADDING_SIZE),", "                              .buf_size = size };", "         if (!pd.buf)", "             goto error;", "         memcpy(pd.buf, pb->buf_ptr, size);", "         sub_demuxer = av_probe_input_format2(&pd, 1, &score);", "         av_freep(&pd.buf);", "          if (!sub_demuxer)", "              goto error;", "         if (strcmp(sub_demuxer->name, \"srt\") && strcmp(sub_demuxer->name, \"ass\"))", "             goto error;", "          if (!(ast->sub_ctx = avformat_alloc_context()))", "              goto error;", "         ast->sub_ctx->pb = pb;", "         if (ff_copy_whiteblacklists(ast->sub_ctx, s) < 0)", "             goto error;", "         if (!avformat_open_input(&ast->sub_ctx, \"\", sub_demuxer, NULL)) {", "             if (ast->sub_ctx->nb_streams != 1)", "                 goto error;", "             ff_read_packet(ast->sub_ctx, &ast->sub_pkt);", "             avcodec_parameters_copy(st->codecpar, ast->sub_ctx->streams[0]->codecpar);", "             time_base = ast->sub_ctx->streams[0]->time_base;", "             avpriv_set_pts_info(st, 64, time_base.num, time_base.den);", "         }", "         ast->sub_buffer = pkt->data;", "         memset(pkt, 0, sizeof(*pkt));", "         return 1;", " error:", "         av_freep(&ast->sub_ctx);", "         av_freep(&pb);", "     }", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int decode_dds1(GetByteContext *gb, uint8_t *frame, int width, int height)", " {", "     const uint8_t *frame_start = frame;", "     const uint8_t *frame_end   = frame + width * height;", "     int mask = 0x10000, bitbuf = 0;", "     int i, v, offset, count, segments;", "     segments = bytestream2_get_le16(gb);", "     while (segments--) {", "         if (bytestream2_get_bytes_left(gb) < 2)", "             return AVERROR_INVALIDDATA;", "         if (mask == 0x10000) {", "             bitbuf = bytestream2_get_le16u(gb);", "             mask = 1;", "         }", "         if (bitbuf & mask) {", "             v = bytestream2_get_le16(gb);", "             offset = (v & 0x1FFF) << 2;", "             count = ((v >> 13) + 2) << 1;", "             if (frame - frame_start < offset || frame_end - frame < count*2 + width)", "                 return AVERROR_INVALIDDATA;", "             for (i = 0; i < count; i++) {", "                 frame[0] = frame[1] =", "                 frame[width] = frame[width + 1] = frame[-offset];", "                 frame += 2;", "             }", "         } else if (bitbuf & (mask << 1)) {", "             v = bytestream2_get_le16(gb)*2;", "             if (frame - frame_end < v)", "                  return AVERROR_INVALIDDATA;", "              frame += v;", "          } else {", "            if (frame_end - frame < width + 3)", "             if (frame_end - frame < width + 4)", "                  return AVERROR_INVALIDDATA;", "              frame[0] = frame[1] =", "              frame[width] = frame[width + 1] =  bytestream2_get_byte(gb);", "             frame += 2;", "             frame[0] = frame[1] =", "             frame[width] = frame[width + 1] =  bytestream2_get_byte(gb);", "             frame += 2;", "         }", "         mask <<= 2;", "     }", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" parse_rockridge(struct archive_read *a, struct file_info *file,", "      const unsigned char *p, const unsigned char *end)", "  {", "  \tstruct iso9660 *iso9660;", " \tint entry_seen = 0;", "  \tiso9660 = (struct iso9660 *)(a->format->data);", " \twhile (p + 4 <= end   ", " \t    && p[0] >= 'A' && p[0] <= 'Z'  ", " \t    && p[1] >= 'A' && p[1] <= 'Z'  ", " \t    && p[2] >= 4  ", " \t    && p + p[2] <= end) {  ", " \t\tconst unsigned char *data = p + 4;", " \t\tint data_length = p[2] - 4;", " \t\tint version = p[3];", " \t\tswitch(p[0]) {", " \t\tcase 'C':", " \t\t\tif (p[1] == 'E') {", " \t\t\t\tif (version == 1 && data_length == 24) {", " \t\t\t\t\tint32_t location =", " \t\t\t\t\t    archive_le32dec(data);", " \t\t\t\t\tfile->ce_offset =", " \t\t\t\t\t    archive_le32dec(data+8);", " \t\t\t\t\tfile->ce_size =", " \t\t\t\t\t    archive_le32dec(data+16);", " \t\t\t\t\tif (register_CE(a, location, file)", " \t\t\t\t\t    != ARCHIVE_OK)", " \t\t\t\t\t\treturn (ARCHIVE_FATAL);", " \t\t\t\t}", " \t\t\t}", " \t\t\telse if (p[1] == 'L') {", " \t\t\t\tif (version == 1 && data_length == 8) {", " \t\t\t\t\tfile->cl_offset = (uint64_t)", " \t\t\t\t\t    iso9660->logical_block_size *", " \t\t\t\t\t    (uint64_t)archive_le32dec(data);", " \t\t\t\t\tiso9660->seenRockridge = 1;", " \t\t\t\t}", " \t\t\t}", " \t\t\tbreak;", " \t\tcase 'N':", " \t\t\tif (p[1] == 'M') {", " \t\t\t\tif (version == 1) {", " \t\t\t\t\tparse_rockridge_NM1(file,", " \t\t\t\t\t    data, data_length);", " \t\t\t\t\tiso9660->seenRockridge = 1;", " \t\t\t\t}", " \t\t\t}", " \t\t\tbreak;", " \t\tcase 'P':", " \t\t\tif (p[1] == 'N') {", " \t\t\t\tif (version == 1 && data_length == 16) {", " \t\t\t\t\tfile->rdev = toi(data,4);", " \t\t\t\t\tfile->rdev <<= 32;", " \t\t\t\t\tfile->rdev |= toi(data + 8, 4);", " \t\t\t\t\tiso9660->seenRockridge = 1;", " \t\t\t\t}", " \t\t\t}", " \t\t\telse if (p[1] == 'X') {", " \t\t\t\tif (version == 1) {", " \t\t\t\t\tif (data_length >= 8)", " \t\t\t\t\t\tfile->mode", " \t\t\t\t\t\t    = toi(data, 4);", " \t\t\t\t\tif (data_length >= 16)", " \t\t\t\t\t\tfile->nlinks", " \t\t\t\t\t\t    = toi(data + 8, 4);", " \t\t\t\t\tif (data_length >= 24)", " \t\t\t\t\t\tfile->uid", " \t\t\t\t\t\t    = toi(data + 16, 4);", " \t\t\t\t\tif (data_length >= 32)", " \t\t\t\t\t\tfile->gid", " \t\t\t\t\t\t    = toi(data + 24, 4);", " \t\t\t\t\tif (data_length >= 40)", " \t\t\t\t\t\tfile->number", " \t\t\t\t\t\t    = toi(data + 32, 4);", " \t\t\t\t\tiso9660->seenRockridge = 1;", " \t\t\t\t}", " \t\t\t}", " \t\t\tbreak;", " \t\tcase 'R':", " \t\t\tif (p[1] == 'E' && version == 1) {", " \t\t\t\tfile->re = 1;", " \t\t\t\tiso9660->seenRockridge = 1;", " \t\t\t}", " \t\t\telse if (p[1] == 'R' && version == 1) {", " \t\t\t}", " \t\t\tbreak;", " \t\tcase 'S':", " \t\t\tif (p[1] == 'L') {", " \t\t\t\tif (version == 1) {", " \t\t\t\t\tparse_rockridge_SL1(file,", " \t\t\t\t\t    data, data_length);", " \t\t\t\t\tiso9660->seenRockridge = 1;", " \t\t\t\t}", " \t\t\t}", " \t\t\telse if (p[1] == 'T'", " \t\t\t    && data_length == 0 && version == 1) {", " \t\t\t\tiso9660->seenSUSP = 0;", " \t\t\t\tiso9660->seenRockridge = 0;", " \t\t\t\treturn (ARCHIVE_OK);", " \t\t\t}", " \t\t\tbreak;", " \t\tcase 'T':", " \t\t\tif (p[1] == 'F') {", " \t\t\t\tif (version == 1) {", " \t\t\t\t\tparse_rockridge_TF1(file,", " \t\t\t\t\t    data, data_length);", " \t\t\t\t\tiso9660->seenRockridge = 1;", " \t\t\t\t}", " \t\t\t}", " \t\t\tbreak;", " \t\tcase 'Z':", " \t\t\tif (p[1] == 'F') {", " \t\t\t\tif (version == 1)", " \t\t\t\t\tparse_rockridge_ZF1(file,", " \t\t\t\t\t    data, data_length);", " \t\t\t}", " \t\t\tbreak;", " \t\tdefault:", " \t\t\tbreak;", "  \t\t}", "  \t\tp += p[2];", " \t\tentry_seen = 1;", " \t}", " \tif (entry_seen)", " \t\treturn (ARCHIVE_OK);", " \telse {", " \t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", " \t\t\t\t  \"Tried to parse Rockridge extensions, but none found\");", " \t\treturn (ARCHIVE_WARN);", "  \t}", "\treturn (ARCHIVE_OK);", "  }"], "ner_tags": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0]}
{"tokens": [" static int ras_getdatastd(jas_stream_t *in, ras_hdr_t *hdr, ras_cmap_t *cmap,", "   jas_image_t *image)", " {", " \tint pad;", " \tint nz;", " \tint z;", " \tint c;", " \tint y;", " \tint x;", " \tint v;", " \tint i;", " \tjas_matrix_t *data[3];", "  \tcmap = 0;", " \tassert(jas_image_numcmpts(image) <= 3);", " \tfor (i = 0; i < 3; ++i) {", " \t\tdata[i] = 0;", " \t}", "  \tfor (i = 0; i < jas_image_numcmpts(image); ++i) {", "\t\tdata[i] = jas_matrix_create(1, jas_image_width(image));", "\t\tassert(data[i]);", " \t\tif (!(data[i] = jas_matrix_create(1, jas_image_width(image)))) {", " \t\t\tgoto error;", " \t\t}", "  \t}", "  \tpad = RAS_ROWSIZE(hdr) - (hdr->width * hdr->depth + 7) / 8;", " \tfor (y = 0; y < hdr->height; y++) {", " \t\tnz = 0;", " \t\tz = 0;", "  \t\tfor (x = 0; x < hdr->width; x++) {", "  \t\t\twhile (nz < hdr->depth) {", "  \t\t\t\tif ((c = jas_stream_getc(in)) == EOF) {", "\t\t\t\t\treturn -1;", " \t\t\t\t\tgoto error;", "  \t\t\t\t}", "  \t\t\t\tz = (z << 8) | c;", "  \t\t\t\tnz += 8;", " \t\t\t}", " \t\t\tv = (z >> (nz - hdr->depth)) & RAS_ONES(hdr->depth);", " \t\t\tz &= RAS_ONES(nz - hdr->depth);", " \t\t\tnz -= hdr->depth;", " \t\t\tif (jas_image_numcmpts(image) == 3) {", " \t\t\t\tjas_matrix_setv(data[0], x, (RAS_GETRED(v)));", " \t\t\t\tjas_matrix_setv(data[1], x, (RAS_GETGREEN(v)));", " \t\t\t\tjas_matrix_setv(data[2], x, (RAS_GETBLUE(v)));", " \t\t\t} else {", " \t\t\t\tjas_matrix_setv(data[0], x, (v));", " \t\t\t}", "  \t\t}", "  \t\tif (pad) {", "  \t\t\tif ((c = jas_stream_getc(in)) == EOF) {", "\t\t\t\treturn -1;", " \t\t\t\tgoto error;", "  \t\t\t}", "  \t\t}", "  \t\tfor (i = 0; i < jas_image_numcmpts(image); ++i) {", "  \t\t\tif (jas_image_writecmpt(image, i, 0, y, hdr->width, 1,", "  \t\t\t  data[i])) {", "\t\t\t\treturn -1;", " \t\t\t\tgoto error;", "  \t\t\t}", "  \t\t}", "  \t}", "  \tfor (i = 0; i < jas_image_numcmpts(image); ++i) {", "  \t\tjas_matrix_destroy(data[i]);", " \t\tdata[i] = 0;", "  \t}", "  \treturn 0;", " error:", " \tfor (i = 0; i < 3; ++i) {", " \t\tif (data[i]) {", " \t\t\tjas_matrix_destroy(data[i]);", " \t\t}", " \t}", " \treturn -1;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": [" _fep_open_control_socket (Fep *fep)", " {", "   struct sockaddr_un sun;", "   char *path;", "   int fd;", "   ssize_t sun_len;", "   fd = socket (AF_UNIX, SOCK_STREAM, 0);", "   if (fd < 0)", "     {", "       perror (\"socket\");", "       return -1;", "     }", "   path = create_socket_name (\"fep-XXXXXX/control\");", "   if (strlen (path) + 1 >= sizeof(sun.sun_path))", "     {", "       fep_log (FEP_LOG_LEVEL_WARNING,", " \t       \"unix domain socket path too long: %d + 1 >= %d\",", " \t       strlen (path),", " \t       sizeof (sun.sun_path));", "       free (path);", "       return -1;", "     }", "    memset (&sun, 0, sizeof(sun));", "    sun.sun_family = AF_UNIX;", "#ifdef __linux__", "  sun.sun_path[0] = '\\0';", "  memcpy (sun.sun_path + 1, path, strlen (path));", "  sun_len = offsetof (struct sockaddr_un, sun_path) + strlen (path) + 1;", "  remove_control_socket (path);", "#else", "    memcpy (sun.sun_path, path, strlen (path));", "    sun_len = sizeof (struct sockaddr_un);", "#endif", "    if (bind (fd, (const struct sockaddr *) &sun, sun_len) < 0)", "      {", "       perror (\"bind\");", "       free (path);", "       close (fd);", "       return -1;", "     }", "   if (listen (fd, 5) < 0)", "     {", "       perror (\"listen\");", "       free (path);", "       close (fd);", "       return -1;", "     }", "   fep->server = fd;", "   fep->control_socket_path = path;", "   return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" choose_volume(struct archive_read *a, struct iso9660 *iso9660)", " {", " \tstruct file_info *file;", " \tint64_t skipsize;", " \tstruct vd *vd;", " \tconst void *block;", " \tchar seenJoliet;", " \tvd = &(iso9660->primary);", " \tif (!iso9660->opt_support_joliet)", " \t\tiso9660->seenJoliet = 0;", " \tif (iso9660->seenJoliet &&", " \t\tvd->location > iso9660->joliet.location)", "  \t\tvd = &(iso9660->joliet);", "\tskipsize = LOGICAL_BLOCK_SIZE * vd->location;", " \tskipsize = LOGICAL_BLOCK_SIZE * (int64_t)vd->location;", "  \tskipsize = __archive_read_consume(a, skipsize);", "  \tif (skipsize < 0)", "  \t\treturn ((int)skipsize);", " \tiso9660->current_position = skipsize;", " \tblock = __archive_read_ahead(a, vd->size, NULL);", " \tif (block == NULL) {", " \t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,", " \t\t    \"Failed to read full block when scanning \"", " \t\t    \"ISO9660 directory list\");", " \t\treturn (ARCHIVE_FATAL);", " \t}", " \tseenJoliet = iso9660->seenJoliet; ", " \tiso9660->seenJoliet = 0;", " \tfile = parse_file_info(a, NULL, block);", " \tif (file == NULL)", " \t\treturn (ARCHIVE_FATAL);", " \tiso9660->seenJoliet = seenJoliet;", " \tif (vd == &(iso9660->primary) && iso9660->seenRockridge", " \t    && iso9660->seenJoliet)", " \t\tiso9660->seenJoliet = 0;", " \tif (vd == &(iso9660->primary) && !iso9660->seenRockridge", "  \t    && iso9660->seenJoliet) {", "  \t\tvd = &(iso9660->joliet);", "\t\tskipsize = LOGICAL_BLOCK_SIZE * vd->location;", " \t\tskipsize = LOGICAL_BLOCK_SIZE * (int64_t)vd->location;", "  \t\tskipsize -= iso9660->current_position;", "  \t\tskipsize = __archive_read_consume(a, skipsize);", "  \t\tif (skipsize < 0)", " \t\t\treturn ((int)skipsize);", " \t\tiso9660->current_position += skipsize;", " \t\tblock = __archive_read_ahead(a, vd->size, NULL);", " \t\tif (block == NULL) {", " \t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,", " \t\t\t    \"Failed to read full block when scanning \"", " \t\t\t    \"ISO9660 directory list\");", " \t\t\treturn (ARCHIVE_FATAL);", " \t\t}", " \t\tiso9660->seenJoliet = 0;", " \t\tfile = parse_file_info(a, NULL, block);", " \t\tif (file == NULL)", " \t\t\treturn (ARCHIVE_FATAL);", " \t\tiso9660->seenJoliet = seenJoliet;", " \t}", " \tif (add_entry(a, iso9660, file) != ARCHIVE_OK)", " \t\treturn (ARCHIVE_FATAL);", " \tif (iso9660->seenRockridge) {", " \t\ta->archive.archive_format = ARCHIVE_FORMAT_ISO9660_ROCKRIDGE;", " \t\ta->archive.archive_format_name =", " \t\t    \"ISO9660 with Rockridge extensions\";", " \t}", " \treturn (ARCHIVE_OK);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int nfs_readlink_reply(unsigned char *pkt, unsigned len)", "  {", "  \tuint32_t *data;", "  \tchar *path;", "\tint rlen;", " \tunsigned int rlen;", "  \tint ret;", "  \tret = rpc_check_reply(pkt, 1);", " \tif (ret)", " \t\treturn ret;", " \tdata = (uint32_t *)(pkt + sizeof(struct rpc_reply));", " \tdata++;", "  \trlen = ntohl(net_read_uint32(data));  ", " \trlen = max_t(unsigned int, rlen,", " \t\t     len - sizeof(struct rpc_reply) - sizeof(uint32_t));", "  \tdata++;", "  \tpath = (char *)data;", " \t} else {", " \t\tmemcpy(nfs_path, path, rlen);", " \t\tnfs_path[rlen] = 0;", " \t}"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int read_part_of_packet(AVFormatContext *s, int64_t *pts,", "                                int *len, int *strid, int read_packet) {", "     AVIOContext *pb = s->pb;", "     PVAContext *pvactx = s->priv_data;", "     int syncword, streamid, reserved, flags, length, pts_flag;", "     int64_t pva_pts = AV_NOPTS_VALUE, startpos;", "     int ret;", " recover:", "     startpos = avio_tell(pb);", "     syncword = avio_rb16(pb);", "     streamid = avio_r8(pb);", "     avio_r8(pb);                ", "     reserved = avio_r8(pb);", "     flags    = avio_r8(pb);", "     length   = avio_rb16(pb);", "     pts_flag = flags & 0x10;", "     if (syncword != PVA_MAGIC) {", "         pva_log(s, AV_LOG_ERROR, \"invalid syncword\\n\");", "         return AVERROR(EIO);", "     }", "     if (streamid != PVA_VIDEO_PAYLOAD && streamid != PVA_AUDIO_PAYLOAD) {", "         pva_log(s, AV_LOG_ERROR, \"invalid streamid\\n\");", "         return AVERROR(EIO);", "     }", "     if (reserved != 0x55) {", "         pva_log(s, AV_LOG_WARNING, \"expected reserved byte to be 0x55\\n\");", "     }", "     if (length > PVA_MAX_PAYLOAD_LENGTH) {", "         pva_log(s, AV_LOG_ERROR, \"invalid payload length %u\\n\", length);", "         return AVERROR(EIO);", "     }", "     if (streamid == PVA_VIDEO_PAYLOAD && pts_flag) {", "         pva_pts = avio_rb32(pb);", "         length -= 4;", "     } else if (streamid == PVA_AUDIO_PAYLOAD) {", "         if (!pvactx->continue_pes) {", "             int pes_signal, pes_header_data_length, pes_packet_length,", "                 pes_flags;", "             unsigned char pes_header_data[256];", "             pes_signal             = avio_rb24(pb);", "             avio_r8(pb);", "             pes_packet_length      = avio_rb16(pb);", "              pes_flags              = avio_rb16(pb);", "              pes_header_data_length = avio_r8(pb);", "             if (avio_feof(pb)) {", "                 return AVERROR_EOF;", "             }", "              if (pes_signal != 1 || pes_header_data_length == 0) {", "                  pva_log(s, AV_LOG_WARNING, \"expected non empty signaled PES packet, \"", "                                            \"trying to recover\\n\");", "                 avio_skip(pb, length - 9);", "                 if (!read_packet)", "                     return AVERROR(EIO);", "                 goto recover;", "             }", "             ret = avio_read(pb, pes_header_data, pes_header_data_length);", "             if (ret != pes_header_data_length)", "                 return ret < 0 ? ret : AVERROR_INVALIDDATA;", "             length -= 9 + pes_header_data_length;", "             pes_packet_length -= 3 + pes_header_data_length;", "             pvactx->continue_pes = pes_packet_length;", "             if (pes_flags & 0x80 && (pes_header_data[0] & 0xf0) == 0x20) {", "                 if (pes_header_data_length < 5) {", "                     pva_log(s, AV_LOG_ERROR, \"header too short\\n\");", "                     avio_skip(pb, length);", "                     return AVERROR_INVALIDDATA;", "                 }", "                 pva_pts = ff_parse_pes_pts(pes_header_data);", "             }", "         }", "         pvactx->continue_pes -= length;", "         if (pvactx->continue_pes < 0) {", "             pva_log(s, AV_LOG_WARNING, \"audio data corruption\\n\");", "             pvactx->continue_pes = 0;", "         }", "     }", "     if (pva_pts != AV_NOPTS_VALUE)", "         av_add_index_entry(s->streams[streamid-1], startpos, pva_pts, 0, 0, AVINDEX_KEYFRAME);", "     *pts   = pva_pts;", "     *len   = length;", "     *strid = streamid;", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void test_burl_normalize (void) {", "     buffer *psrc = buffer_init();", "     buffer *ptmp = buffer_init();", "     int flags;", "     flags = HTTP_PARSEOPT_URL_NORMALIZE_UNRESERVED;", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"no-slash\"), CONST_STR_LEN(\"no-slash\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/\"), CONST_STR_LEN(\"/\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc\"), CONST_STR_LEN(\"/abc\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc/\"), CONST_STR_LEN(\"/abc/\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc/def\"), CONST_STR_LEN(\"/abc/def\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?\"), CONST_STR_LEN(\"/abc?\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d\"), CONST_STR_LEN(\"/abc?d\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d=\"), CONST_STR_LEN(\"/abc?d=\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d=e\"), CONST_STR_LEN(\"/abc?d=e\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d=e&\"), CONST_STR_LEN(\"/abc?d=e&\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d=e&f\"), CONST_STR_LEN(\"/abc?d=e&f\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d=e&f=g\"), CONST_STR_LEN(\"/abc?d=e&f=g\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d=e&f=g#\"), CONST_STR_LEN(\"/abc?d=e&f=g\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d=e&f=g#any\"), CONST_STR_LEN(\"/abc?d=e&f=g\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%2F\"), CONST_STR_LEN(\"/%2F\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%2f\"), CONST_STR_LEN(\"/%2F\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%20\"), CONST_STR_LEN(\"/%20\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%2b\"), CONST_STR_LEN(\"/%2B\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%2B\"), CONST_STR_LEN(\"/%2B\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%3a\"), CONST_STR_LEN(\"/%3A\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%3A\"), CONST_STR_LEN(\"/%3A\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/~test%20\u00e4_\"), CONST_STR_LEN(\"/~test%20%C3%A4_\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/\\375\"), \"\", (size_t)-2);", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/\\376\"), \"\", (size_t)-2);", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/\\377\"), \"\", (size_t)-2);", "     flags = HTTP_PARSEOPT_URL_NORMALIZE_REQUIRED;", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/\"), CONST_STR_LEN(\"/\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc\"), CONST_STR_LEN(\"/abc\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc/\"), CONST_STR_LEN(\"/abc/\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc/def\"), CONST_STR_LEN(\"/abc/def\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?\"), CONST_STR_LEN(\"/abc?\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d\"), CONST_STR_LEN(\"/abc?d\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d=\"), CONST_STR_LEN(\"/abc?d=\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d=e\"), CONST_STR_LEN(\"/abc?d=e\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d=e&\"), CONST_STR_LEN(\"/abc?d=e&\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d=e&f\"), CONST_STR_LEN(\"/abc?d=e&f\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d=e&f=g\"), CONST_STR_LEN(\"/abc?d=e&f=g\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d=e&f=g#\"), CONST_STR_LEN(\"/abc?d=e&f=g\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d=e&f=g#any\"), CONST_STR_LEN(\"/abc?d=e&f=g\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%2F\"), CONST_STR_LEN(\"/%2F\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%2f\"), CONST_STR_LEN(\"/%2F\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%20\"), CONST_STR_LEN(\"/%20\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%2b\"), CONST_STR_LEN(\"/+\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%2B\"), CONST_STR_LEN(\"/+\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%3a\"), CONST_STR_LEN(\"/:\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%3A\"), CONST_STR_LEN(\"/:\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/~test%20\u00e4_\"), CONST_STR_LEN(\"/~test%20%C3%A4_\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/\\375\"), \"\", (size_t)-2);", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/\\376\"), \"\", (size_t)-2);", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/\\377\"), \"\", (size_t)-2);", "     flags |= HTTP_PARSEOPT_URL_NORMALIZE_CTRLS_REJECT;", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/\\a\"), \"\", (size_t)-2);", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/\\t\"), \"\", (size_t)-2);", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/\\r\"), \"\", (size_t)-2);", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/\\177\"), \"\", (size_t)-2);", "   #if defined(__WIN32) || defined(__CYGWIN__)", "     flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_BACKSLASH_TRANS;", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a\\\\b\"), CONST_STR_LEN(\"/a/b\"));", "   #endif", "      flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_DECODE;", "      run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a/b?c=/\"), CONST_STR_LEN(\"/a/b?c=/\"));", "      run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a/b?c=%2f\"), CONST_STR_LEN(\"/a/b?c=/\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"%2f?\"), CONST_STR_LEN(\"/?\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%2f?\"), CONST_STR_LEN(\"?\"));", "      run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a%2fb\"), CONST_STR_LEN(\"/a/b\"));", "      run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a%2Fb\"), CONST_STR_LEN(\"/a/b\"));", "      run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a%2fb?c=/\"), CONST_STR_LEN(\"/a/b?c=/\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a%2fb?c=%2f\"), CONST_STR_LEN(\"/a/b?c=/\"));", "     flags &= ~HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_DECODE;", "     flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_REJECT;", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a%2fb\"), \"\", (size_t)-2);", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a%2Fb\"), \"\", (size_t)-2);", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a/b?c=%2f\"), CONST_STR_LEN(\"/a/b?c=/\"));", "     flags &= ~HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_REJECT;", "     flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REMOVE;", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"./a/b\"), CONST_STR_LEN(\"/a/b\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"../a/b\"), CONST_STR_LEN(\"/a/b\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a/./b\"), CONST_STR_LEN(\"/a/b\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a/../b\"), CONST_STR_LEN(\"/b\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a/b/.\"), CONST_STR_LEN(\"/a/b/\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a/b/..\"), CONST_STR_LEN(\"/a/\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a/../b/..\"), CONST_STR_LEN(\"/\"));", "     flags &= ~HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REMOVE;", "     flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REJECT;", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"./a/b\"), \"\", (size_t)-2);", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"../a/b\"), \"\", (size_t)-2);", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a/./b\"), \"\", (size_t)-2);", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a/../b\"), \"\", (size_t)-2);", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a/b/.\"), \"\", (size_t)-2);", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a/b/..\"), \"\", (size_t)-2);", "     flags &= ~HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REJECT;", "     flags |= HTTP_PARSEOPT_URL_NORMALIZE_QUERY_20_PLUS;", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a/b?c=d+e\"), CONST_STR_LEN(\"/a/b?c=d+e\"));", "     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a/b?c=d%20e\"), CONST_STR_LEN(\"/a/b?c=d+e\"));", "     flags &= ~HTTP_PARSEOPT_URL_NORMALIZE_QUERY_20_PLUS;", "     buffer_free(psrc);", "     buffer_free(ptmp);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static struct vrend_linked_shader_program *add_shader_program(struct vrend_context *ctx,", "                                                               struct vrend_shader *vs,", "                                                               struct vrend_shader *fs,", "                                                               struct vrend_shader *gs)", " {", "    struct vrend_linked_shader_program *sprog = CALLOC_STRUCT(vrend_linked_shader_program);", "    char name[16];", "    int i;", "    GLuint prog_id;", "    GLint lret;", "    int id;", "    int last_shader;", "    if (!sprog)", "       return NULL;", "    if ((gs && gs->compiled_fs_id != fs->id) ||", "        (!gs && vs->compiled_fs_id != fs->id)) {", "       bool ret;", "       if (gs)", "          vrend_patch_vertex_shader_interpolants(gs->glsl_prog,", "                                                 &gs->sel->sinfo,", "                                                 &fs->sel->sinfo, true, fs->key.flatshade);", "       else", "          vrend_patch_vertex_shader_interpolants(vs->glsl_prog,", "                                                 &vs->sel->sinfo,", "                                                 &fs->sel->sinfo, false, fs->key.flatshade);", "       ret = vrend_compile_shader(ctx, gs ? gs : vs);", "       if (ret == false) {", "          glDeleteShader(gs ? gs->id : vs->id);", "          free(sprog);", "          return NULL;", "       }", "       if (gs)", "          gs->compiled_fs_id = fs->id;", "       else", "          vs->compiled_fs_id = fs->id;", "    }", "    prog_id = glCreateProgram();", "    glAttachShader(prog_id, vs->id);", "    if (gs) {", "       if (gs->id > 0)", "          glAttachShader(prog_id, gs->id);", "       set_stream_out_varyings(prog_id, &gs->sel->sinfo);", "    }", "    else", "       set_stream_out_varyings(prog_id, &vs->sel->sinfo);", "    glAttachShader(prog_id, fs->id);", "    if (fs->sel->sinfo.num_outputs > 1) {", "       if (util_blend_state_is_dual(&ctx->sub->blend_state, 0)) {", "          glBindFragDataLocationIndexed(prog_id, 0, 0, \"fsout_c0\");", "          glBindFragDataLocationIndexed(prog_id, 0, 1, \"fsout_c1\");", "          sprog->dual_src_linked = true;", "       } else {", "          glBindFragDataLocationIndexed(prog_id, 0, 0, \"fsout_c0\");", "          glBindFragDataLocationIndexed(prog_id, 1, 0, \"fsout_c1\");", "          sprog->dual_src_linked = false;", "       }", "    } else", "       sprog->dual_src_linked = false;", "    if (vrend_state.have_vertex_attrib_binding) {", "       uint32_t mask = vs->sel->sinfo.attrib_input_mask;", "       while (mask) {", "          i = u_bit_scan(&mask);", "          snprintf(name, 10, \"in_%d\", i);", "          glBindAttribLocation(prog_id, i, name);", "       }", "    }", "    glLinkProgram(prog_id);", "    glGetProgramiv(prog_id, GL_LINK_STATUS, &lret);", "    if (lret == GL_FALSE) {", "       char infolog[65536];", "       int len;", "       glGetProgramInfoLog(prog_id, 65536, &len, infolog);", "       fprintf(stderr,\"got error linking\\n%s\\n\", infolog);", "       report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_SHADER, 0);", "       fprintf(stderr,\"vert shader: %d GLSL\\n%s\\n\", vs->id, vs->glsl_prog);", "       if (gs)", "           fprintf(stderr,\"geom shader: %d GLSL\\n%s\\n\", gs->id, gs->glsl_prog);", "        fprintf(stderr,\"frag shader: %d GLSL\\n%s\\n\", fs->id, fs->glsl_prog);", "        glDeleteProgram(prog_id);", "       free(sprog);", "        return NULL;", "     }", "    sprog->ss[PIPE_SHADER_FRAGMENT] = fs;", "    sprog->ss[PIPE_SHADER_GEOMETRY] = gs;", "    list_add(&sprog->sl[PIPE_SHADER_VERTEX], &vs->programs);", "    list_add(&sprog->sl[PIPE_SHADER_FRAGMENT], &fs->programs);", "    if (gs)", "       list_add(&sprog->sl[PIPE_SHADER_GEOMETRY], &gs->programs);", "    last_shader = gs ? PIPE_SHADER_GEOMETRY : PIPE_SHADER_FRAGMENT;", "    sprog->id = prog_id;", "    list_addtail(&sprog->head, &ctx->sub->programs);", "    if (fs->key.pstipple_tex)", "       sprog->fs_stipple_loc = glGetUniformLocation(prog_id, \"pstipple_sampler\");", "    else", "       sprog->fs_stipple_loc = -1;", "    sprog->vs_ws_adjust_loc = glGetUniformLocation(prog_id, \"winsys_adjust\");", "    for (id = PIPE_SHADER_VERTEX; id <= last_shader; id++) {", "       if (sprog->ss[id]->sel->sinfo.samplers_used_mask) {", "          uint32_t mask = sprog->ss[id]->sel->sinfo.samplers_used_mask;", "          int nsamp = util_bitcount(sprog->ss[id]->sel->sinfo.samplers_used_mask);", "          int index;", "          sprog->shadow_samp_mask[id] = sprog->ss[id]->sel->sinfo.shadow_samp_mask;", "          if (sprog->ss[id]->sel->sinfo.shadow_samp_mask) {", "             sprog->shadow_samp_mask_locs[id] = calloc(nsamp, sizeof(uint32_t));", "             sprog->shadow_samp_add_locs[id] = calloc(nsamp, sizeof(uint32_t));", "          } else {", "             sprog->shadow_samp_mask_locs[id] = sprog->shadow_samp_add_locs[id] = NULL;", "          }", "          sprog->samp_locs[id] = calloc(nsamp, sizeof(uint32_t));", "          if (sprog->samp_locs[id]) {", "             const char *prefix = pipe_shader_to_prefix(id);", "             index = 0;", "             while(mask) {", "                i = u_bit_scan(&mask);", "                snprintf(name, 10, \"%ssamp%d\", prefix, i);", "                sprog->samp_locs[id][index] = glGetUniformLocation(prog_id, name);", "                if (sprog->ss[id]->sel->sinfo.shadow_samp_mask & (1 << i)) {", "                   snprintf(name, 14, \"%sshadmask%d\", prefix, i);", "                   sprog->shadow_samp_mask_locs[id][index] = glGetUniformLocation(prog_id, name);", "                   snprintf(name, 14, \"%sshadadd%d\", prefix, i);", "                   sprog->shadow_samp_add_locs[id][index] = glGetUniformLocation(prog_id, name);", "                }", "                index++;", "             }", "          }", "       } else {", "          sprog->samp_locs[id] = NULL;", "          sprog->shadow_samp_mask_locs[id] = NULL;", "          sprog->shadow_samp_add_locs[id] = NULL;", "          sprog->shadow_samp_mask[id] = 0;", "       }", "       sprog->samplers_used_mask[id] = sprog->ss[id]->sel->sinfo.samplers_used_mask;", "    }", "    for (id = PIPE_SHADER_VERTEX; id <= last_shader; id++) {", "       if (sprog->ss[id]->sel->sinfo.num_consts) {", "          sprog->const_locs[id] = calloc(sprog->ss[id]->sel->sinfo.num_consts, sizeof(uint32_t));", "          if (sprog->const_locs[id]) {", "             const char *prefix = pipe_shader_to_prefix(id);", "             for (i = 0; i < sprog->ss[id]->sel->sinfo.num_consts; i++) {", "                snprintf(name, 16, \"%sconst0[%d]\", prefix, i);", "                sprog->const_locs[id][i] = glGetUniformLocation(prog_id, name);", "             }", "          }", "       } else", "          sprog->const_locs[id] = NULL;", "    }", "    if (!vrend_state.have_vertex_attrib_binding) {", "       if (vs->sel->sinfo.num_inputs) {", "          sprog->attrib_locs = calloc(vs->sel->sinfo.num_inputs, sizeof(uint32_t));", "          if (sprog->attrib_locs) {", "             for (i = 0; i < vs->sel->sinfo.num_inputs; i++) {", "                snprintf(name, 10, \"in_%d\", i);", "                sprog->attrib_locs[i] = glGetAttribLocation(prog_id, name);", "             }", "          }", "       } else", "          sprog->attrib_locs = NULL;", "    }", "    for (id = PIPE_SHADER_VERTEX; id <= last_shader; id++) {", "       if (sprog->ss[id]->sel->sinfo.num_ubos) {", "          const char *prefix = pipe_shader_to_prefix(id);", "          sprog->ubo_locs[id] = calloc(sprog->ss[id]->sel->sinfo.num_ubos, sizeof(uint32_t));", "          for (i = 0; i < sprog->ss[id]->sel->sinfo.num_ubos; i++) {", "             snprintf(name, 16, \"%subo%d\", prefix, i + 1);", "             sprog->ubo_locs[id][i] = glGetUniformBlockIndex(prog_id, name);", "          }", "       } else", "          sprog->ubo_locs[id] = NULL;", "    }", "    if (vs->sel->sinfo.num_ucp) {", "       for (i = 0; i < vs->sel->sinfo.num_ucp; i++) {", "          snprintf(name, 10, \"clipp[%d]\", i);", "          sprog->clip_locs[i] = glGetUniformLocation(prog_id, name);", "       }", "    }", "    return sprog;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static av_cold int xpm_decode_close(AVCodecContext *avctx)", " {", "      XPMDecContext *x = avctx->priv_data;", "      av_freep(&x->pixels);", "     av_freep(&x->buf);", "     x->buf_size = 0;", "      return 0;", "  }"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 0]}
{"tokens": [" rdpsnddbg_process(STREAM s)", " {", " \tunsigned int pkglen;", "  \tstatic char *rest = NULL;", "  \tchar *buf;", " \tif (!s_check(s))", " \t{", " \t\trdp_protocol_error(\"rdpsnddbg_process(), stream is in unstable state\", s);", " \t}", "  \tpkglen = s->end - s->p;", "  \tbuf = (char *) xmalloc(pkglen + 1);", " \tSTRNCPY(buf, (char *) s->p, pkglen + 1);", " \tstr_handle_lines(buf, &rest, rdpsnddbg_line_handler, NULL);", " \txfree(buf);", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void jslTokenAsString(int token, char *str, size_t len) {", "   if (token>32 && token<128) {", "     assert(len>=4);", "     str[0] = '\\'';", "     str[1] = (char)token;", "     str[2] = '\\'';", "     str[3] = 0;", "     return;", "   }", "   switch (token) {", "   case LEX_EOF : strncpy(str, \"EOF\", len); return;", "   case LEX_ID : strncpy(str, \"ID\", len); return;", "   case LEX_INT : strncpy(str, \"INT\", len); return;", "   case LEX_FLOAT : strncpy(str, \"FLOAT\", len); return;", "   case LEX_STR : strncpy(str, \"STRING\", len); return;", "   case LEX_UNFINISHED_STR : strncpy(str, \"UNFINISHED STRING\", len); return;", "   case LEX_TEMPLATE_LITERAL : strncpy(str, \"TEMPLATE LITERAL\", len); return;", "   case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy(str, \"UNFINISHED TEMPLATE LITERAL\", len); return;", "   case LEX_REGEX : strncpy(str, \"REGEX\", len); return;", "   case LEX_UNFINISHED_REGEX : strncpy(str, \"UNFINISHED REGEX\", len); return;", "   case LEX_UNFINISHED_COMMENT : strncpy(str, \"UNFINISHED COMMENT\", len); return;", "   }", "   if (token>=_LEX_OPERATOR_START && token<_LEX_R_LIST_END) {", "     const char tokenNames[] =", "           \"==\\0\"", "           \"===\\0\"", "           \"!=\\0\"", "           \"!==\\0\"", "           \"<=\\0\"", "           \"<<\\0\"", "           \"<<=\\0\"", "           \">=\\0\"", "           \">>\\0\"", "           \">>>\\0\"", "           \">>=\\0\"", "           \">>>=\\0\"", "           \"+=\\0\"", "           \"-=\\0\"", "           \"++\\0\"", "           \"--\\0\"", "           \"*=\\0\"", "           \"/=\\0\"", "           \"%=\\0\"", "           \"&=\\0\"", "           \"&&\\0\"", "           \"|=\\0\"", "           \"||\\0\"", "           \"^=\\0\"", "           \"=>\\0\"", "           \"if\\0\"", "           \"else\\0\"", "           \"do\\0\"", "           \"while\\0\"", "           \"for\\0\"", "           \"return\\0\"", "           \"continue\\0\"", "           \"function\\0\"", "           \"return\\0\"", "           \"var\\0\"", "           \"let\\0\"", "           \"const\\0\"", "           \"this\\0\"", "           \"throw\\0\"", "           \"try\\0\"", "           \"catch\\0\"", "           \"finally\\0\"", "           \"true\\0\"", "           \"false\\0\"", "           \"null\\0\"", "           \"undefined\\0\"", "           \"new\\0\"", "           \"in\\0\"", "           \"instanceof\\0\"", "           \"switch\\0\"", "           \"case\\0\"", "           \"default\\0\"", "           \"delete\\0\"", "           \"typeof\\0\"", "           \"void\\0\"", "           \"debugger\\0\"", "           \"class\\0\"", "           \"extends\\0\"", "             \"super\\0\"", "           \"static\\0\"", "         ;", "     unsigned int p = 0;", "     int n = token-_LEX_OPERATOR_START;", "     while (n>0 && p<sizeof(tokenNames)) {", "       while (tokenNames[p] && p<sizeof(tokenNames)) p++;", "       p++;  ", "       n--;  ", "     }", "     assert(n==0);", "     strncpy(str, &tokenNames[p], len);", "     return;", "    }", "    assert(len>=10);", "  strncpy(str, \"?[\",len);", "  itostr(token, &str[2], 10);", "  strncat(str, \"]\",len);", "   espruino_snprintf(str, len, \"?[%d]\", token);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0]}
{"tokens": [" jas_matrix_t *jas_matrix_create(int numrows, int numcols)", " jas_matrix_t *jas_matrix_create(jas_matind_t numrows, jas_matind_t numcols)", "  {", "  \tjas_matrix_t *matrix;", "\tint i;", " \tjas_matind_t i;", "  \tsize_t size;", "  \tmatrix = 0;", " \tif (numrows < 0 || numcols < 0) {", " \t\tgoto error;", " \t}", " \tif (!(matrix = jas_malloc(sizeof(jas_matrix_t)))) {", " \t\tgoto error;", " \t}", " \tmatrix->flags_ = 0;", " \tmatrix->numrows_ = numrows;", " \tmatrix->numcols_ = numcols;", " \tmatrix->rows_ = 0;", " \tmatrix->maxrows_ = numrows;", " \tmatrix->data_ = 0;", " \tmatrix->datasize_ = 0;", " \tif (!jas_safe_size_mul(numrows, numcols, &size)) {", " \t\tgoto error;", " \t}", " \tmatrix->datasize_ = size;", " \tif (matrix->maxrows_ > 0) {", " \t\tif (!(matrix->rows_ = jas_alloc2(matrix->maxrows_,", " \t\t  sizeof(jas_seqent_t *)))) {", " \t\t\tgoto error;", " \t\t}", " \t}", " \tif (matrix->datasize_ > 0) {", " \t\tif (!(matrix->data_ = jas_alloc2(matrix->datasize_,", " \t\t  sizeof(jas_seqent_t)))) {", " \t\t\tgoto error;", " \t\t}", " \t}", " \tfor (i = 0; i < numrows; ++i) {", " \t\tmatrix->rows_[i] = &matrix->data_[i * matrix->numcols_];", " \t}", " \tfor (i = 0; i < matrix->datasize_; ++i) {", " \t\tmatrix->data_[i] = 0;", " \t}", " \tmatrix->xstart_ = 0;", " \tmatrix->ystart_ = 0;", " \tmatrix->xend_ = matrix->numcols_;", " \tmatrix->yend_ = matrix->numrows_;", " \treturn matrix;", " error:", " \tif (matrix) {", " \t\tjas_matrix_destroy(matrix);", " \t}", " \treturn 0;", " }"], "ner_tags": [0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" main(int argc, char *argv[])", " {", " \tstatic char buff[16384];", " \tstruct cpio _cpio;  ", " \tstruct cpio *cpio;", " \tconst char *errmsg;", " \tint uid, gid;", " \tint opt;", " \tcpio = &_cpio;", " \tmemset(cpio, 0, sizeof(*cpio));", " \tcpio->buff = buff;", " \tcpio->buff_size = sizeof(buff);", " #if defined(HAVE_SIGACTION) && defined(SIGPIPE)", " \t{  ", " \t\tstruct sigaction sa;", " \t\tsigemptyset(&sa.sa_mask);", " \t\tsa.sa_flags = 0;", " \t\tsa.sa_handler = SIG_IGN;", " \t\tsigaction(SIGPIPE, &sa, NULL);", " \t}", " #endif", " \tlafe_setprogname(*argv, \"bsdcpio\");", " #if HAVE_SETLOCALE", " \tif (setlocale(LC_ALL, \"\") == NULL)", " \t\tlafe_warnc(0, \"Failed to set default locale\");", " #endif", " \tcpio->uid_override = -1;", " \tcpio->gid_override = -1;", " \tcpio->argv = argv;", " \tcpio->argc = argc;", " \tcpio->mode = '\\0';", " \tcpio->verbose = 0;", " \tcpio->compress = '\\0';", " \tcpio->extract_flags = ARCHIVE_EXTRACT_NO_AUTODIR;", "  \tcpio->extract_flags |= ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER;", "  \tcpio->extract_flags |= ARCHIVE_EXTRACT_SECURE_SYMLINKS;", "  \tcpio->extract_flags |= ARCHIVE_EXTRACT_SECURE_NODOTDOT;", " \tcpio->extract_flags |= ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS;", "  \tcpio->extract_flags |= ARCHIVE_EXTRACT_PERM;", "  \tcpio->extract_flags |= ARCHIVE_EXTRACT_FFLAGS;", "  \tcpio->extract_flags |= ARCHIVE_EXTRACT_ACL;", " #if !defined(_WIN32) && !defined(__CYGWIN__)", " \tif (geteuid() == 0)", " \t\tcpio->extract_flags |= ARCHIVE_EXTRACT_OWNER;", " #endif", " \tcpio->bytes_per_block = 512;", " \tcpio->filename = NULL;", " \tcpio->matching = archive_match_new();", " \tif (cpio->matching == NULL)", " \t\tlafe_errc(1, 0, \"Out of memory\");", " \twhile ((opt = cpio_getopt(cpio)) != -1) {", " \t\tswitch (opt) {", " \t\tcase '0':  ", " \t\t\tcpio->option_null = 1;", " \t\t\tbreak;", " \t\tcase 'A':  ", " \t\t\tcpio->option_append = 1;", " \t\t\tbreak;", " \t\tcase 'a':  ", " \t\t\tcpio->option_atime_restore = 1;", " \t\t\tbreak;", " \t\tcase 'B':  ", " \t\t\tcpio->bytes_per_block = 5120;", " \t\t\tbreak;", " \t\tcase OPTION_B64ENCODE:", " \t\t\tcpio->add_filter = opt;", " \t\t\tbreak;", " \t\tcase 'C':  ", " \t\t\tcpio->bytes_per_block = atoi(cpio->argument);", " \t\t\tif (cpio->bytes_per_block <= 0)", " \t\t\t\tlafe_errc(1, 0, \"Invalid blocksize %s\", cpio->argument);", " \t\t\tbreak;", " \t\tcase 'c':  ", " \t\t\tcpio->format = \"odc\";", " \t\t\tbreak;", " \t\tcase 'd':  ", " \t\t\tcpio->extract_flags &= ~ARCHIVE_EXTRACT_NO_AUTODIR;", " \t\t\tbreak;", " \t\tcase 'E':  ", " \t\t\tif (archive_match_include_pattern_from_file(", " \t\t\t    cpio->matching, cpio->argument,", " \t\t\t    cpio->option_null) != ARCHIVE_OK)", " \t\t\t\tlafe_errc(1, 0, \"Error : %s\",", " \t\t\t\t    archive_error_string(cpio->matching));", " \t\t\tbreak;", " \t\tcase 'F':  ", " \t\t\tcpio->filename = cpio->argument;", " \t\t\tbreak;", " \t\tcase 'f':  ", " \t\t\tif (archive_match_exclude_pattern(cpio->matching,", " \t\t\t    cpio->argument) != ARCHIVE_OK)", " \t\t\t\tlafe_errc(1, 0, \"Error : %s\",", " \t\t\t\t    archive_error_string(cpio->matching));", " \t\t\tbreak;", " \t\tcase OPTION_GRZIP:", " \t\t\tcpio->compress = opt;", " \t\t\tbreak;", " \t\tcase 'H':  ", " \t\t\tcpio->format = cpio->argument;", " \t\t\tbreak;", " \t\tcase 'h':", " \t\t\tlong_help();", " \t\t\tbreak;", " \t\tcase 'I':  ", " \t\t\tcpio->filename = cpio->argument;", " \t\t\tbreak;", " \t\tcase 'i':  ", " \t\t\tif (cpio->mode != '\\0')", " \t\t\t\tlafe_errc(1, 0,", " \t\t\t\t    \"Cannot use both -i and -%c\", cpio->mode);", " \t\t\tcpio->mode = opt;", " \t\t\tbreak;", " \t\tcase 'J':  ", " \t\t\tcpio->compress = opt;", " \t\t\tbreak;", " \t\tcase 'j':  ", " \t\t\tcpio->compress = opt;", " \t\t\tbreak;", "  \t\tcase OPTION_INSECURE:", "  \t\t\tcpio->extract_flags &= ~ARCHIVE_EXTRACT_SECURE_SYMLINKS;", "  \t\t\tcpio->extract_flags &= ~ARCHIVE_EXTRACT_SECURE_NODOTDOT;", " \t\t\tcpio->extract_flags &= ~ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS;", "  \t\t\tbreak;", "  \t\tcase 'L':  ", "  \t\t\tcpio->option_follow_links = 1;", " \t\t\tbreak;", " \t\tcase 'l':  ", " \t\t\tcpio->option_link = 1;", " \t\t\tbreak;", " \t\tcase OPTION_LRZIP:", " \t\tcase OPTION_LZ4:", " \t\tcase OPTION_LZMA:  ", " \t\tcase OPTION_LZOP:  ", " \t\t\tcpio->compress = opt;", " \t\t\tbreak;", " \t\tcase 'm':  ", " \t\t\tcpio->extract_flags |= ARCHIVE_EXTRACT_TIME;", " \t\t\tbreak;", " \t\tcase 'n':  ", " \t\t\tcpio->option_numeric_uid_gid = 1;", " \t\t\tbreak;", " \t\tcase OPTION_NO_PRESERVE_OWNER:  ", " \t\t\tcpio->extract_flags &= ~ARCHIVE_EXTRACT_OWNER;", " \t\t\tbreak;", " \t\tcase 'O':  ", " \t\t\tcpio->filename = cpio->argument;", " \t\t\tbreak;", " \t\tcase 'o':  ", " \t\t\tif (cpio->mode != '\\0')", " \t\t\t\tlafe_errc(1, 0,", " \t\t\t\t    \"Cannot use both -o and -%c\", cpio->mode);", " \t\t\tcpio->mode = opt;", " \t\t\tbreak;", " \t\tcase 'p':  ", " \t\t\tif (cpio->mode != '\\0')", " \t\t\t\tlafe_errc(1, 0,", " \t\t\t\t    \"Cannot use both -p and -%c\", cpio->mode);", " \t\t\tcpio->mode = opt;", " \t\t\tcpio->extract_flags &= ~ARCHIVE_EXTRACT_SECURE_NODOTDOT;", " \t\t\tbreak;", " \t\tcase OPTION_PASSPHRASE:", " \t\t\tcpio->passphrase = cpio->argument;", " \t\t\tbreak;", " \t\tcase OPTION_PRESERVE_OWNER:", " \t\t\tcpio->extract_flags |= ARCHIVE_EXTRACT_OWNER;", " \t\t\tbreak;", " \t\tcase OPTION_QUIET:  ", " \t\t\tcpio->quiet = 1;", " \t\t\tbreak;", " \t\tcase 'R':  ", " \t\t\terrmsg = owner_parse(cpio->argument, &uid, &gid);", " \t\t\tif (errmsg) {", " \t\t\t\tlafe_warnc(-1, \"%s\", errmsg);", " \t\t\t\tusage();", " \t\t\t}", " \t\t\tif (uid != -1) {", " \t\t\t\tcpio->uid_override = uid;", " \t\t\t\tcpio->uname_override = NULL;", " \t\t\t}", " \t\t\tif (gid != -1) {", " \t\t\t\tcpio->gid_override = gid;", " \t\t\t\tcpio->gname_override = NULL;", " \t\t\t}", " \t\t\tbreak;", " \t\tcase 'r':  ", " \t\t\tcpio->option_rename = 1;", " \t\t\tbreak;", " \t\tcase 't':  ", " \t\t\tcpio->option_list = 1;", " \t\t\tbreak;", " \t\tcase 'u':  ", " \t\t\tcpio->extract_flags", " \t\t\t    &= ~ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER;", " \t\t\tbreak;", " \t\tcase OPTION_UUENCODE:", " \t\t\tcpio->add_filter = opt;", " \t\t\tbreak;", " \t\tcase 'v':  ", " \t\t\tcpio->verbose++;", " \t\t\tbreak;", " \t\tcase 'V':  ", " \t\t\tcpio->dot++;", " \t\t\tbreak;", " \t\tcase OPTION_VERSION:  ", " \t\t\tversion();", " \t\t\tbreak;", " #if 0", " \t\tcase 'W':  ", " \t\t\tbreak;", " #endif", " \t\tcase 'y':  ", " \t\t\tcpio->compress = opt;", " \t\t\tbreak;", " \t\tcase 'Z':  ", " \t\t\tcpio->compress = opt;", " \t\t\tbreak;", " \t\tcase 'z':  ", " \t\t\tcpio->compress = opt;", " \t\t\tbreak;", " \t\tdefault:", " \t\t\tusage();", " \t\t}", " \t}", " \tif (cpio->option_list && cpio->mode == '\\0')", " \t\tcpio->mode = 'i';", " \tif (cpio->option_list && cpio->mode != 'i')", " \t\tlafe_errc(1, 0, \"Option -t requires -i\");", " \tif (cpio->option_numeric_uid_gid && !cpio->option_list)", " \t\tlafe_errc(1, 0, \"Option -n requires -it\");", " \tif (cpio->format != NULL && cpio->mode != 'o')", " \t\tlafe_errc(1, 0, \"Option --format requires -o\");", " \tif (cpio->option_link && cpio->mode != 'p')", " \t\tlafe_errc(1, 0, \"Option -l requires -p\");", " \tif (cpio->dot && cpio->verbose)", " \t\tcpio->dot = 0;", " \tswitch (cpio->mode) {", " \tcase 'o':", " \t\tif (cpio->format == NULL)", " \t\t\tcpio->format = \"odc\";  ", " \t\tmode_out(cpio);", " \t\tbreak;", " \tcase 'i':", " \t\twhile (*cpio->argv != NULL) {", " \t\t\tif (archive_match_include_pattern(cpio->matching,", " \t\t\t    *cpio->argv) != ARCHIVE_OK)", " \t\t\t\tlafe_errc(1, 0, \"Error : %s\",", " \t\t\t\t    archive_error_string(cpio->matching));", " \t\t\t--cpio->argc;", " \t\t\t++cpio->argv;", " \t\t}", " \t\tif (cpio->option_list)", " \t\t\tmode_list(cpio);", " \t\telse", " \t\t\tmode_in(cpio);", " \t\tbreak;", " \tcase 'p':", " \t\tif (*cpio->argv == NULL || **cpio->argv == '\\0')", " \t\t\tlafe_errc(1, 0,", " \t\t\t    \"-p mode requires a target directory\");", " \t\tmode_pass(cpio, *cpio->argv);", " \t\tbreak;", " \tdefault:", " \t\tlafe_errc(1, 0,", " \t\t    \"Must specify at least one of -i, -o, or -p\");", " \t}", " \tarchive_match_free(cpio->matching);", " \tfree_cache(cpio->gname_cache);", " \tfree_cache(cpio->uname_cache);", " \tfree(cpio->destdir);", " \tpassphrase_free(cpio->ppbuff);", " \treturn (cpio->return_value);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" ProcPseudoramiXGetScreenSize(ClientPtr client)", " {", "     REQUEST(xPanoramiXGetScreenSizeReq);", "     WindowPtr pWin;", "     xPanoramiXGetScreenSizeReply rep;", "     register int rc;", "      TRACE;", "     REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);", "      if (stuff->screen >= pseudoramiXNumScreens)", "        return BadMatch;", "    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);", "      rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);", "      if (rc != Success)", "          return rc;", "     rep.type = X_Reply;", "     rep.length = 0;", "     rep.sequenceNumber = client->sequence;", "     rep.width = pseudoramiXScreens[stuff->screen].w;", "     rep.height = pseudoramiXScreens[stuff->screen].h;", "     rep.window = stuff->window;", "     rep.screen = stuff->screen;", "     if (client->swapped) {", "         swaps(&rep.sequenceNumber);", "         swapl(&rep.length);", "         swapl(&rep.width);", "         swapl(&rep.height);", "         swapl(&rep.window);", "         swapl(&rep.screen);", "     }", "     WriteToClient(client, sizeof(xPanoramiXGetScreenSizeReply),&rep);", "     return Success;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static bool ndp_msg_check_valid(struct ndp_msg *msg)", " {", " \tsize_t len = ndp_msg_payload_len(msg);", " \tenum ndp_msg_type msg_type = ndp_msg_type(msg);", "  \tif (len < ndp_msg_type_info(msg_type)->raw_struct_size)", "  \t\treturn false;", "\treturn true;", " \tif (ndp_msg_type_info(msg_type)->addrto_validate)", " \t\treturn ndp_msg_type_info(msg_type)->addrto_validate(&msg->addrto);", " \telse", " \t\treturn true;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0]}
{"tokens": ["  int yr_re_exec(", "      uint8_t* re_code,", "      uint8_t* input_data,", "    size_t input_size,", "     size_t input_forwards_size,", "     size_t input_backwards_size,", "      int flags,", "      RE_MATCH_CALLBACK_FUNC callback,", "      void* callback_args)", " {", "   uint8_t* ip;", "   uint8_t* input;", "   uint8_t mask;", "   uint8_t value;", "   RE_FIBER_LIST fibers;", "   RE_THREAD_STORAGE* storage;", "   RE_FIBER* fiber;", "   RE_FIBER* next_fiber;", "   int error;", "   int bytes_matched;", "   int max_bytes_matched;", "   int match;", "   int character_size;", "   int input_incr;", "   int kill;", "   int action;", "   int result = -1;", "   #define ACTION_NONE       0", "   #define ACTION_CONTINUE   1", "    #define ACTION_KILL       2", "    #define ACTION_KILL_TAIL  3", "  #define prolog if (bytes_matched >= max_bytes_matched) \\", "   #define prolog { \\", "       if ((bytes_matched >= max_bytes_matched) || \\", "           (character_size == 2 && *(input + 1) != 0)) \\", "        { \\", "          action = ACTION_KILL; \\", "          break; \\", "      }", "       } \\", "     }", "  #define fail_if_error(e) switch (e) { \\", "   #define fail_if_error(e) { \\", "       switch (e) { \\", "          case ERROR_INSUFFICIENT_MEMORY: \\", "            return -2; \\", "          case ERROR_TOO_MANY_RE_FIBERS: \\", "            return -4; \\", "      }", "       } \\", "     }", "    if (_yr_re_alloc_storage(&storage) != ERROR_SUCCESS)", "      return -2;", "   if (flags & RE_FLAGS_WIDE)", "     character_size = 2;", "   else", "     character_size = 1;", "   input = input_data;", "   input_incr = character_size;", "    if (flags & RE_FLAGS_BACKWARDS)", "    {", "     max_bytes_matched = (int) yr_min(input_backwards_size, RE_SCAN_LIMIT);", "      input -= character_size;", "      input_incr = -input_incr;", "    }", "  max_bytes_matched = (int) yr_min(input_size, RE_SCAN_LIMIT);", "   else", "   {", "     max_bytes_matched = (int) yr_min(input_forwards_size, RE_SCAN_LIMIT);", "   }", "    max_bytes_matched = max_bytes_matched - max_bytes_matched % character_size;", "   bytes_matched = 0;", "   error = _yr_re_fiber_create(&storage->fiber_pool, &fiber);", "   fail_if_error(error);", "   fiber->ip = re_code;", "   fibers.head = fiber;", "   fibers.tail = fiber;", "   error = _yr_re_fiber_sync(&fibers, &storage->fiber_pool, fiber);", "   fail_if_error(error);", "   while (fibers.head != NULL)", "   {", "     fiber = fibers.head;", "     while(fiber != NULL)", "     {", "       ip = fiber->ip;", "       action = ACTION_NONE;", "       switch(*ip)", "       {", "         case RE_OPCODE_ANY:", "           prolog;", "           match = (flags & RE_FLAGS_DOT_ALL) || (*input != 0x0A);", "           action = match ? ACTION_NONE : ACTION_KILL;", "           fiber->ip += 1;", "           break;", "         case RE_OPCODE_REPEAT_ANY_GREEDY:", "         case RE_OPCODE_REPEAT_ANY_UNGREEDY:", "           prolog;", "           match = (flags & RE_FLAGS_DOT_ALL) || (*input != 0x0A);", "           action = match ? ACTION_NONE : ACTION_KILL;", "           break;", "         case RE_OPCODE_LITERAL:", "           prolog;", "           if (flags & RE_FLAGS_NO_CASE)", "             match = yr_lowercase[*input] == yr_lowercase[*(ip + 1)];", "           else", "             match = (*input == *(ip + 1));", "           action = match ? ACTION_NONE : ACTION_KILL;", "           fiber->ip += 2;", "           break;", "         case RE_OPCODE_MASKED_LITERAL:", "           prolog;", "           value = *(int16_t*)(ip + 1) & 0xFF;", "           mask = *(int16_t*)(ip + 1) >> 8;", "           match = ((*input & mask) == value);", "           action = match ? ACTION_NONE : ACTION_KILL;", "           fiber->ip += 3;", "           break;", "         case RE_OPCODE_CLASS:", "           prolog;", "           match = CHAR_IN_CLASS(*input, ip + 1);", "           if (!match && (flags & RE_FLAGS_NO_CASE))", "             match = CHAR_IN_CLASS(yr_altercase[*input], ip + 1);", "           action = match ? ACTION_NONE : ACTION_KILL;", "           fiber->ip += 33;", "           break;", "          case RE_OPCODE_WORD_CHAR:", "            prolog;", "          match = IS_WORD_CHAR(*input);", "           match = _yr_re_is_word_char(input, character_size);", "            action = match ? ACTION_NONE : ACTION_KILL;", "            fiber->ip += 1;", "            break;", "          case RE_OPCODE_NON_WORD_CHAR:", "            prolog;", "          match = !IS_WORD_CHAR(*input);", "           match = !_yr_re_is_word_char(input, character_size);", "            action = match ? ACTION_NONE : ACTION_KILL;", "            fiber->ip += 1;", "            break;", "         case RE_OPCODE_SPACE:", "         case RE_OPCODE_NON_SPACE:", "           prolog;", "           switch(*input)", "           {", "             case ' ':", "             case '\\t':", "             case '\\r':", "             case '\\n':", "             case '\\v':", "             case '\\f':", "               match = TRUE;", "               break;", "             default:", "               match = FALSE;", "           }", "           if (*ip == RE_OPCODE_NON_SPACE)", "             match = !match;", "           action = match ? ACTION_NONE : ACTION_KILL;", "           fiber->ip += 1;", "           break;", "         case RE_OPCODE_DIGIT:", "           prolog;", "           match = isdigit(*input);", "           action = match ? ACTION_NONE : ACTION_KILL;", "           fiber->ip += 1;", "           break;", "         case RE_OPCODE_NON_DIGIT:", "           prolog;", "           match = !isdigit(*input);", "           action = match ? ACTION_NONE : ACTION_KILL;", "           fiber->ip += 1;", "           break;", "          case RE_OPCODE_WORD_BOUNDARY:", "          case RE_OPCODE_NON_WORD_BOUNDARY:", "          if (bytes_matched == 0 &&", "              !(flags & RE_FLAGS_NOT_AT_START) &&", "              !(flags & RE_FLAGS_BACKWARDS))", "           if (bytes_matched == 0 && input_backwards_size < character_size)", "           {", "              match = TRUE;", "           }", "            else if (bytes_matched >= max_bytes_matched)", "           {", "              match = TRUE;", "          else if (IS_WORD_CHAR(*(input - input_incr)) != IS_WORD_CHAR(*input))", "            match = TRUE;", "           }", "            else", "            match = FALSE;", "           {", "             assert(input <  input_data + input_forwards_size);", "             assert(input >= input_data - input_backwards_size);", "             assert(input - input_incr <  input_data + input_forwards_size);", "             assert(input - input_incr >= input_data - input_backwards_size);", "             match = _yr_re_is_word_char(input, character_size) != \\", "                     _yr_re_is_word_char(input - input_incr, character_size);", "           }", "            if (*ip == RE_OPCODE_NON_WORD_BOUNDARY)", "              match = !match;", "           action = match ? ACTION_CONTINUE : ACTION_KILL;", "           fiber->ip += 1;", "           break;", "          case RE_OPCODE_MATCH_AT_START:", "            if (flags & RE_FLAGS_BACKWARDS)", "            kill = input_size > (size_t) bytes_matched;", "             kill = input_backwards_size > (size_t) bytes_matched;", "            else", "            kill = (flags & RE_FLAGS_NOT_AT_START) || (bytes_matched != 0);", "             kill = input_backwards_size > 0 || (bytes_matched != 0);", "            action = kill ? ACTION_KILL : ACTION_CONTINUE;", "            fiber->ip += 1;", "            break;", "          case RE_OPCODE_MATCH_AT_END:", "            kill = flags & RE_FLAGS_BACKWARDS ||", "                 input_size > (size_t) bytes_matched;", "                  input_forwards_size > (size_t) bytes_matched;", "            action = kill ? ACTION_KILL : ACTION_CONTINUE;", "            fiber->ip += 1;", "            break;", "         case RE_OPCODE_MATCH:", "           result = bytes_matched;", "           if (flags & RE_FLAGS_EXHAUSTIVE)", "           {", "             if (callback != NULL)", "             {", "               int cb_result;", "               if (flags & RE_FLAGS_BACKWARDS)", "                 cb_result = callback(", "                     input + character_size,", "                     bytes_matched,", "                     flags,", "                     callback_args);", "               else", "                 cb_result = callback(", "                     input_data,", "                     bytes_matched,", "                     flags,", "                     callback_args);", "               switch(cb_result)", "               {", "                 case ERROR_INSUFFICIENT_MEMORY:", "                   return -2;", "                 case ERROR_TOO_MANY_MATCHES:", "                   return -3;", "                 default:", "                   if (cb_result != ERROR_SUCCESS)", "                     return -4;", "               }", "             }", "             action = ACTION_KILL;", "           }", "           else", "           {", "             action = ACTION_KILL_TAIL;", "           }", "           break;", "         default:", "           assert(FALSE);", "       }", "       switch(action)", "       {", "         case ACTION_KILL:", "           fiber = _yr_re_fiber_kill(&fibers, &storage->fiber_pool, fiber);", "           break;", "         case ACTION_KILL_TAIL:", "           _yr_re_fiber_kill_tail(&fibers, &storage->fiber_pool, fiber);", "           fiber = NULL;", "           break;", "         case ACTION_CONTINUE:", "           error = _yr_re_fiber_sync(&fibers, &storage->fiber_pool, fiber);", "           fail_if_error(error);", "           break;", "         default:", "           next_fiber = fiber->next;", "           error = _yr_re_fiber_sync(&fibers, &storage->fiber_pool, fiber);", "           fail_if_error(error);", "           fiber = next_fiber;", "        }", "      }", "    if (flags & RE_FLAGS_WIDE &&", "        bytes_matched < max_bytes_matched &&", "        *(input + 1) != 0)", "    {", "      _yr_re_fiber_kill_all(&fibers, &storage->fiber_pool);", "    }", "      input += input_incr;", "      bytes_matched += character_size;", "     if (flags & RE_FLAGS_SCAN && bytes_matched < max_bytes_matched)", "     {", "       error = _yr_re_fiber_create(&storage->fiber_pool, &fiber);", "       fail_if_error(error);", "       fiber->ip = re_code;", "       _yr_re_fiber_append(&fibers, fiber);", "       error = _yr_re_fiber_sync(&fibers, &storage->fiber_pool, fiber);", "       fail_if_error(error);", "     }", "   }", "   return result;", " }"], "ner_tags": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" ltree_in(PG_FUNCTION_ARGS)", " {", " \tchar\t   *buf = (char *) PG_GETARG_POINTER(0);", " \tchar\t   *ptr;", " \tnodeitem   *list,", " \t\t\t   *lptr;", " \tint\t\t\tnum = 0,", " \t\t\t\ttotallen = 0;", " \tint\t\t\tstate = LTPRS_WAITNAME;", " \tltree\t   *result;", " \tltree_level *curlevel;", " \tint\t\t\tcharlen;", " \tint\t\t\tpos = 0;", " \tptr = buf;", " \twhile (*ptr)", " \t{", " \t\tcharlen = pg_mblen(ptr);", " \t\tif (charlen == 1 && t_iseq(ptr, '.'))", " \t\t\tnum++;", "  \t\tptr += charlen;", "  \t}", " \tif (num + 1 > MaxAllocSize / sizeof(nodeitem))", " \t\tereport(ERROR,", " \t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),", " \t\t\t errmsg(\"number of levels (%d) exceeds the maximum allowed (%d)\",", " \t\t\t\t\tnum + 1, (int) (MaxAllocSize / sizeof(nodeitem)))));", "  \tlist = lptr = (nodeitem *) palloc(sizeof(nodeitem) * (num + 1));", "  \tptr = buf;", "  \twhile (*ptr)", " \t{", " \t\tcharlen = pg_mblen(ptr);", " \t\tif (state == LTPRS_WAITNAME)", " \t\t{", " \t\t\tif (ISALNUM(ptr))", " \t\t\t{", " \t\t\t\tlptr->start = ptr;", " \t\t\t\tlptr->wlen = 0;", " \t\t\t\tstate = LTPRS_WAITDELIM;", " \t\t\t}", " \t\t\telse", " \t\t\t\tUNCHAR;", " \t\t}", " \t\telse if (state == LTPRS_WAITDELIM)", " \t\t{", " \t\t\tif (charlen == 1 && t_iseq(ptr, '.'))", " \t\t\t{", " \t\t\t\tlptr->len = ptr - lptr->start;", " \t\t\t\tif (lptr->wlen > 255)", " \t\t\t\t\tereport(ERROR,", " \t\t\t\t\t\t\t(errcode(ERRCODE_NAME_TOO_LONG),", " \t\t\t\t\t\t\t errmsg(\"name of level is too long\"),", " \t\t\t\t\t\t\t errdetail(\"Name length is %d, must \"", " \t\t\t\t\t\t\t\t\t   \"be < 256, in position %d.\",", " \t\t\t\t\t\t\t\t\t   lptr->wlen, pos)));", " \t\t\t\ttotallen += MAXALIGN(lptr->len + LEVEL_HDRSIZE);", " \t\t\t\tlptr++;", " \t\t\t\tstate = LTPRS_WAITNAME;", " \t\t\t}", " \t\t\telse if (!ISALNUM(ptr))", " \t\t\t\tUNCHAR;", " \t\t}", " \t\telse", " \t\t\telog(ERROR, \"internal error in parser\");", " \t\tptr += charlen;", " \t\tlptr->wlen++;", " \t\tpos++;", " \t}", " \tif (state == LTPRS_WAITDELIM)", " \t{", " \t\tlptr->len = ptr - lptr->start;", " \t\tif (lptr->wlen > 255)", " \t\t\tereport(ERROR,", " \t\t\t\t\t(errcode(ERRCODE_NAME_TOO_LONG),", " \t\t\t\t\t errmsg(\"name of level is too long\"),", " \t\t\t\t\t errdetail(\"Name length is %d, must \"", " \t\t\t\t\t\t\t   \"be < 256, in position %d.\",", " \t\t\t\t\t\t\t   lptr->wlen, pos)));", " \t\ttotallen += MAXALIGN(lptr->len + LEVEL_HDRSIZE);", " \t\tlptr++;", " \t}", " \telse if (!(state == LTPRS_WAITNAME && lptr == list))", " \t\tereport(ERROR,", " \t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),", " \t\t\t\t errmsg(\"syntax error\"),", " \t\t\t\t errdetail(\"Unexpected end of line.\")));", " \tresult = (ltree *) palloc0(LTREE_HDRSIZE + totallen);", " \tSET_VARSIZE(result, LTREE_HDRSIZE + totallen);", " \tresult->numlevel = lptr - list;", " \tcurlevel = LTREE_FIRST(result);", " \tlptr = list;", " \twhile (lptr - list < result->numlevel)", " \t{", " \t\tcurlevel->len = (uint16) lptr->len;", " \t\tmemcpy(curlevel->name, lptr->start, lptr->len);", " \t\tcurlevel = LEVEL_NEXT(curlevel);", " \t\tlptr++;", " \t}", " \tpfree(list);", " \tPG_RETURN_POINTER(result);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int ras_putdatastd(jas_stream_t *out, ras_hdr_t *hdr, jas_image_t *image,  int numcmpts, int *cmpts)", " {", " \tint rowsize;", " \tint pad;", " \tunsigned int z;", " \tint nz;", " \tint c;", " \tint x;", " \tint y;", " \tint v;", "  \tjas_matrix_t *data[3];", "  \tint i;", " \tassert(numcmpts <= 3);", " \tfor (i = 0; i < 3; ++i) {", " \t\tdata[i] = 0;", " \t}", "  \tfor (i = 0; i < numcmpts; ++i) {", "\t\tdata[i] = jas_matrix_create(jas_image_height(image), jas_image_width(image));", "\t\tassert(data[i]);", " \t\tif (!(data[i] = jas_matrix_create(jas_image_height(image),", " \t\t  jas_image_width(image)))) {", " \t\t\tgoto error;", " \t\t}", "  \t}", "  \trowsize = RAS_ROWSIZE(hdr);", " \tpad = rowsize - (hdr->width * hdr->depth + 7) / 8;", " \thdr->length = hdr->height * rowsize;", " \tfor (y = 0; y < hdr->height; y++) {", "  \t\tfor (i = 0; i < numcmpts; ++i) {", "  \t\t\tif (jas_image_readcmpt(image, cmpts[i], 0, y,", "  \t\t\t\t\tjas_image_width(image), 1, data[i])) {", "\t\t\t\treturn -1;", " \t\t\t\tgoto error;", "  \t\t\t}", "  \t\t}", "  \t\tz = 0;", " \t\tnz = 0;", " \t\tfor (x = 0; x < hdr->width; x++) {", " \t\t\tz <<= hdr->depth;", " \t\t\tif (RAS_ISRGB(hdr)) {", " \t\t\t\tv = RAS_RED((jas_matrix_getv(data[0], x))) |", " \t\t\t\t  RAS_GREEN((jas_matrix_getv(data[1], x))) |", " \t\t\t\t  RAS_BLUE((jas_matrix_getv(data[2], x)));", " \t\t\t} else {", " \t\t\t\tv = (jas_matrix_getv(data[0], x));", " \t\t\t}", " \t\t\tz |= v & RAS_ONES(hdr->depth);", " \t\t\tnz += hdr->depth;", "  \t\t\twhile (nz >= 8) {", "  \t\t\t\tc = (z >> (nz - 8)) & 0xff;", "  \t\t\t\tif (jas_stream_putc(out, c) == EOF) {", "\t\t\t\t\treturn -1;", " \t\t\t\t\tgoto error;", "  \t\t\t\t}", "  \t\t\t\tnz -= 8;", "  \t\t\t\tz &= RAS_ONES(nz);", " \t\t\t}", " \t\t}", "  \t\tif (nz > 0) {", "  \t\t\tc = (z >> (8 - nz)) & RAS_ONES(nz);", "  \t\t\tif (jas_stream_putc(out, c) == EOF) {", "\t\t\t\treturn -1;", " \t\t\t\tgoto error;", "  \t\t\t}", "  \t\t}", "  \t\tif (pad % 2) {", "  \t\t\tif (jas_stream_putc(out, 0) == EOF) {", "\t\t\t\treturn -1;", " \t\t\t\tgoto error;", "  \t\t\t}", "  \t\t}", "  \t}", "  \tfor (i = 0; i < numcmpts; ++i) {", "  \t\tjas_matrix_destroy(data[i]);", " \t\tdata[i] = 0;", "  \t}", "  \treturn 0;", " error:", " \tfor (i = 0; i < numcmpts; ++i) {", " \t\tif (data[i]) {", " \t\t\tjas_matrix_destroy(data[i]);", " \t\t}", " \t}", " \treturn -1;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": ["  int cg_mkdir(const char *path, mode_t mode)", "  {", "  \tstruct fuse_context *fc = fuse_get_context();", "\tchar *fpath = NULL, *path1, *cgdir = NULL, *controller;", " \tchar *fpath = NULL, *path1, *cgdir = NULL, *controller, *next = NULL;", "  \tconst char *cgroup;", "  \tint ret;", " \tif (!fc)", " \t\treturn -EIO;", " \tcontroller = pick_controller_from_path(fc, path);", " \tif (!controller)", " \t\treturn -EINVAL;", " \tcgroup = find_cgroup_in_path(path);", " \tif (!cgroup)", " \t\treturn -EINVAL;", " \tget_cgdir_and_path(cgroup, &cgdir, &fpath);", " \tif (!fpath)", " \t\tpath1 = \"/\";", "  \telse", "  \t\tpath1 = cgdir;", " \tif (!caller_is_in_ancestor(fc->pid, controller, path1, &next)) {", " \t\tif (fpath && strcmp(next, fpath) == 0)", " \t\t\tret = -EEXIST;", " \t\telse", " \t\t\tret = -ENOENT;", " \t\tgoto out;", " \t}", "  \tif (!fc_may_access(fc, controller, path1, NULL, O_RDWR)) {", "  \t\tret = -EACCES;", "  \t\tgoto out;", " \t}", " \tif (!caller_is_in_ancestor(fc->pid, controller, path1, NULL)) {", " \t\tret = -EACCES;", " \t\tgoto out;", " \t}", " \tret = cgfs_create(controller, cgroup, fc->uid, fc->gid);", " \tprintf(\"cgfs_create returned %d for %s %s\\n\", ret, controller, cgroup);", "  out:", "  \tfree(cgdir);", " \tfree(next);", "  \treturn ret;", "  }"], "ner_tags": [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": [" stf_status ikev2parent_inI1outR1(struct msg_digest *md)", " {", " \tstruct state *st = md->st;", " \tlset_t policy = POLICY_IKEV2_ALLOW;", " \tstruct connection *c = find_host_connection(&md->iface->ip_addr,", " \t\t\t\t\t\t    md->iface->port,", " \t\t\t\t\t\t    &md->sender,", " \t\t\t\t\t\t    md->sender_port,", " \t\t\t\t\t\t    POLICY_IKEV2_ALLOW);", " #if 0", " \tif (c == NULL) {", " \t\tpb_stream pre_sa_pbs = sa_pd->pbs;", " \t\tpolicy = preparse_isakmp_sa_body(&pre_sa_pbs);", " \t\tc = find_host_connection(&md->iface->ip_addr, pluto_port,", " \t\t\t\t\t (ip_address*)NULL, md->sender_port,", " \t\t\t\t\t policy);", " \t}", " #endif", " \tif (c == NULL) {", " \t\t{", " \t\t\tstruct connection *d;", " \t\t\td = find_host_connection(&md->iface->ip_addr,", " \t\t\t\t\t\t pluto_port,", " \t\t\t\t\t\t (ip_address*)NULL,", " \t\t\t\t\t\t md->sender_port, policy);", " \t\t\tfor (; d != NULL; d = d->hp_next) {", " \t\t\t\tif (d->kind == CK_GROUP) {", " \t\t\t\t} else {", " \t\t\t\t\tif (d->kind == CK_TEMPLATE &&", " \t\t\t\t\t    !(d->policy & POLICY_OPPO)) {", " \t\t\t\t\t\tc = d;", " \t\t\t\t\t\tbreak;", " \t\t\t\t\t}", " \t\t\t\t\tif (addrinsubnet(&md->sender,", " \t\t\t\t\t\t\t &d->spd.that.client)", " \t\t\t\t\t    &&", " \t\t\t\t\t    (c == NULL ||", " \t\t\t\t\t     !subnetinsubnet(&c->spd.that.", " \t\t\t\t\t\t\t     client,", " \t\t\t\t\t\t\t     &d->spd.that.", " \t\t\t\t\t\t\t     client)))", " \t\t\t\t\t\tc = d;", " \t\t\t\t}", " \t\t\t}", " \t\t}", " \t\tif (c == NULL) {", " \t\t\tloglog(RC_LOG_SERIOUS, \"initial parent SA message received on %s:%u\"", " \t\t\t       \" but no connection has been authorized%s%s\",", " \t\t\t       ip_str(", " \t\t\t\t       &md->iface->ip_addr),", " \t\t\t       ntohs(portof(&md->iface->ip_addr)),", " \t\t\t       (policy != LEMPTY) ? \" with policy=\" : \"\",", " \t\t\t       (policy !=", " \t\t\t\tLEMPTY) ? bitnamesof(sa_policy_bit_names,", " \t\t\t\t\t\t     policy) : \"\");", " \t\t\treturn STF_FAIL + v2N_NO_PROPOSAL_CHOSEN;", " \t\t}", " \t\tif (c->kind != CK_TEMPLATE) {", " \t\t\tloglog(RC_LOG_SERIOUS, \"initial parent SA message received on %s:%u\"", " \t\t\t       \" but \\\"%s\\\" forbids connection\",", " \t\t\t       ip_str(", " \t\t\t\t       &md->iface->ip_addr), pluto_port,", " \t\t\t       c->name);", " \t\t\treturn STF_FAIL + v2N_NO_PROPOSAL_CHOSEN;", " \t\t}", " \t\tc = rw_instantiate(c, &md->sender, NULL, NULL);", " \t} else {", " \t\tif ((c->kind == CK_TEMPLATE) && c->spd.that.virt) {", " \t\t\tDBG(DBG_CONTROL,", " \t\t\t    DBG_log(", " \t\t\t\t    \"local endpoint has virt (vnet/vhost) set without wildcards - needs instantiation\"));", " \t\t\tc = rw_instantiate(c, &md->sender, NULL, NULL);", " \t\t} else if ((c->kind == CK_TEMPLATE) &&", " \t\t\t   (c->policy & POLICY_IKEV2_ALLOW_NARROWING)) {", " \t\t\tDBG(DBG_CONTROL,", " \t\t\t    DBG_log(", " \t\t\t\t    \"local endpoint has narrowing=yes - needs instantiation\"));", " \t\t\tc = rw_instantiate(c, &md->sender, NULL, NULL);", " \t\t}", " \t}", " \tDBG_log(\"found connection: %s\\n\", c ? c->name : \"<none>\");", " \tif (!st) {", " \t\tst = new_state();", " \t\tmemcpy(st->st_icookie, md->hdr.isa_icookie, COOKIE_SIZE);", " \t\tget_cookie(FALSE, st->st_rcookie, COOKIE_SIZE, &md->sender);", " \t\tinitialize_new_state(st, c, policy, 0, NULL_FD,", " \t\t\t\t     pcim_stranger_crypto);", " \t\tst->st_ikev2 = TRUE;", " \t\tchange_state(st, STATE_PARENT_R1);", " \t\tst->st_msgid_lastack = INVALID_MSGID;", " \t\tst->st_msgid_nextuse = 0;", " \t\tmd->st = st;", " \t\tmd->from_state = STATE_IKEv2_BASE;", " \t}", " \tif (force_busy == TRUE) {", " \t\tu_char dcookie[SHA1_DIGEST_SIZE];", " \t\tchunk_t dc;", " \t\tikev2_get_dcookie( dcookie, st->st_ni, &md->sender,", " \t\t\t\t   st->st_icookie);", " \t\tdc.ptr = dcookie;", " \t\tdc.len = SHA1_DIGEST_SIZE;", " \t\tif ( md->chain[ISAKMP_NEXT_v2KE] &&", " \t\t     md->chain[ISAKMP_NEXT_v2N] &&", " \t\t     (md->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type ==", " \t\t      v2N_COOKIE)) {", " \t\t\tu_int8_t spisize;", " \t\t\tconst pb_stream *dc_pbs;", " \t\t\tchunk_t blob;", " \t\t\tDBG(DBG_CONTROLMORE,", " \t\t\t    DBG_log(\"received a DOS cookie in I1 verify it\"));", " \t\t\tspisize =", " \t\t\t\tmd->chain[ISAKMP_NEXT_v2N]->payload.v2n.", " \t\t\t\tisan_spisize;", " \t\t\tdc_pbs = &md->chain[ISAKMP_NEXT_v2N]->pbs;", " \t\t\tblob.ptr = dc_pbs->cur + spisize;", " \t\t\tblob.len = pbs_left(dc_pbs) - spisize;", " \t\t\tDBG(DBG_CONTROLMORE,", " \t\t\t    DBG_dump_chunk(\"dcookie received in I1 Packet\",", " \t\t\t\t\t   blob);", " \t\t\t    DBG_dump(\"dcookie computed\", dcookie,", " \t\t\t\t     SHA1_DIGEST_SIZE));", " \t\t\tif (memcmp(blob.ptr, dcookie, SHA1_DIGEST_SIZE) != 0) {", " \t\t\t\tlibreswan_log(", " \t\t\t\t\t\"mismatch in DOS v2N_COOKIE,send a new one\");", " \t\t\t\tSEND_NOTIFICATION_AA(v2N_COOKIE, &dc);", " \t\t\t\treturn STF_FAIL + v2N_INVALID_IKE_SPI;", " \t\t\t}", " \t\t\tDBG(DBG_CONTROLMORE,", " \t\t\t    DBG_log(\"dcookie received match with computed one\"));", " \t\t} else {", " \t\t\tDBG(DBG_CONTROLMORE,", " \t\t\t    DBG_log(", " \t\t\t\t    \"busy mode on. receieved I1 without a valid dcookie\");", " \t\t\t    DBG_log(\"send a dcookie and forget this state\"));", " \t\t\tSEND_NOTIFICATION_AA(v2N_COOKIE, &dc);", " \t\t\treturn STF_FAIL;", " \t\t}", " \t} else {", " \t\tDBG(DBG_CONTROLMORE,", " \t\t    DBG_log(\"will not send/process a dcookie\"));", " \t}", "  \t{", "  \t\tstruct ikev2_ke *ke;", " \t\tchar fromname[ADDRTOT_BUF];", " \t\taddrtot(&md->sender, 0, fromname, ADDRTOT_BUF);", " \t\tif (!md->chain[ISAKMP_NEXT_v2KE]) {", " \t\t\tif(md->chain[ISAKMP_NEXT_v2N]) {", " \t\t\t\tlibreswan_log(\"Received Notify(%d): %s\",", " \t\t\t\t\tmd->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type,", " \t\t\t\t\tenum_name(&ikev2_notify_names,", " \t\t\t\t\t\tmd->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type));", " \t\t\t}", " \t\t\tlibreswan_log(", " \t\t\t\t\"rejecting I1 from %s:%u, no KE payload present\",", " \t\t\t\tfromname, md->sender_port);", " \t\t\treturn STF_FAIL + v2N_INVALID_KE_PAYLOAD;", " \t\t}", "  \t\tke = &md->chain[ISAKMP_NEXT_v2KE]->payload.v2ke;", "  \t\tst->st_oakley.group = lookup_group(ke->isak_group);", "  \t\tif (st->st_oakley.group == NULL) {", "\t\t\tchar fromname[ADDRTOT_BUF];", "\t\t\taddrtot(&md->sender, 0, fromname, ADDRTOT_BUF);", "  \t\t\tlibreswan_log(", "  \t\t\t\t\"rejecting I1 from %s:%u, invalid DH group=%u\",", "  \t\t\t\tfromname, md->sender_port,", "  \t\t\t\tke->isak_group);", "\t\t\treturn v2N_INVALID_KE_PAYLOAD;", " \t\t\treturn STF_FAIL + v2N_INVALID_KE_PAYLOAD;", "  \t\t}", "  \t}", " \t{", " \t\tstruct ke_continuation *ke = alloc_thing(", " \t\t\tstruct ke_continuation,", " \t\t\t\"ikev2_inI1outR1 KE\");", " \t\tstf_status e;", " \t\tke->md = md;", " \t\tset_suspended(st, ke->md);", " \t\tif (!st->st_sec_in_use) {", " \t\t\tpcrc_init(&ke->ke_pcrc);", " \t\t\tke->ke_pcrc.pcrc_func =", " \t\t\t\tikev2_parent_inI1outR1_continue;", " \t\t\te = build_ke(&ke->ke_pcrc, st, st->st_oakley.group,", " \t\t\t\t     pcim_stranger_crypto);", " \t\t\tif (e != STF_SUSPEND && e != STF_INLINE) {", " \t\t\t\tloglog(RC_CRYPTOFAILED, \"system too busy\");", " \t\t\t\tdelete_state(st);", " \t\t\t}", " \t\t} else {", " \t\t\te =", " \t\t\t\tikev2_parent_inI1outR1_tail((struct", " \t\t\t\t\t\t\t     pluto_crypto_req_cont", " \t\t\t\t\t\t\t     *)ke,", " \t\t\t\t\t\t\t    NULL);", " \t\t}", " \t\treset_globals();", " \t\treturn e;", " \t}", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" GF_Err hdlr_dump(GF_Box *a, FILE * trace)", "  {", "  \tGF_HandlerBox *p = (GF_HandlerBox *)a;", "  \tgf_isom_box_dump_start(a, \"HandlerBox\", trace);", "\tif (p->nameUTF8 && (u32) p->nameUTF8[0] == strlen(p->nameUTF8+1)) {", " \tif (p->nameUTF8 && (u32) p->nameUTF8[0] == strlen(p->nameUTF8)-1) {", "  \t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8+1);", "  \t} else {", "  \t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8);", " \t}", " \tfprintf(trace, \"reserved1=\\\"%d\\\" reserved2=\\\"\", p->reserved1);", " \tdump_data(trace, (char *) p->reserved2, 12);", " \tfprintf(trace, \"\\\"\");", " \tfprintf(trace, \">\\n\");", " \tgf_isom_box_dump_done(\"HandlerBox\", a, trace);", " \treturn GF_OK;", " }"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" authentic_process_fci(struct sc_card *card, struct sc_file *file,", " \t\t const unsigned char *buf, size_t buflen)", " {", " \tstruct sc_context *ctx = card->ctx;", " \tsize_t taglen;", " \tint rv;", " \tunsigned ii;", " \tconst unsigned char *tag = NULL;", " \tunsigned char ops_DF[8] = {", " \t\tSC_AC_OP_CREATE, SC_AC_OP_DELETE, SC_AC_OP_CRYPTO, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF", " \t};", " \tunsigned char ops_EF[8] = {", " \t\tSC_AC_OP_READ, SC_AC_OP_DELETE, SC_AC_OP_UPDATE, SC_AC_OP_RESIZE, 0xFF, 0xFF, 0xFF, 0xFF", " \t};", " \tLOG_FUNC_CALLED(ctx);", " \ttag = sc_asn1_find_tag(card->ctx,  buf, buflen, 0x6F, &taglen);", " \tif (tag != NULL) {", " \t\tsc_log(ctx, \"  FCP length %\"SC_FORMAT_LEN_SIZE_T\"u\", taglen);", " \t\tbuf = tag;", " \t\tbuflen = taglen;", " \t}", " \ttag = sc_asn1_find_tag(card->ctx,  buf, buflen, 0x62, &taglen);", " \tif (tag != NULL) {", " \t\tsc_log(ctx, \"  FCP length %\"SC_FORMAT_LEN_SIZE_T\"u\", taglen);", " \t\tbuf = tag;", " \t\tbuflen = taglen;", " \t}", " \trv = iso_ops->process_fci(card, file, buf, buflen);", " \tLOG_TEST_RET(ctx, rv, \"ISO parse FCI failed\");", " \tif (!file->sec_attr_len)   {", " \t\tsc_log_hex(ctx, \"ACLs not found in data\", buf, buflen);", " \t\tsc_log(ctx, \"Path:%s; Type:%X; PathType:%X\", sc_print_path(&file->path), file->type, file->path.type);", " \t\tif (file->path.type == SC_PATH_TYPE_DF_NAME || file->type == SC_FILE_TYPE_DF)   {", " \t\t\tfile->type = SC_FILE_TYPE_DF;", " \t\t}", " \t\telse   {", " \t\t\tLOG_TEST_RET(ctx, SC_ERROR_OBJECT_NOT_FOUND, \"ACLs tag missing\");", " \t\t}", "  \t}", "  \tsc_log_hex(ctx, \"ACL data\", file->sec_attr, file->sec_attr_len);", "\tfor (ii = 0; ii < file->sec_attr_len / 2; ii++)  {", " \tfor (ii = 0; ii < file->sec_attr_len / 2 && ii < sizeof ops_DF; ii++)  {", "  \t\tunsigned char op = file->type == SC_FILE_TYPE_DF ? ops_DF[ii] : ops_EF[ii];", "  \t\tunsigned char acl = *(file->sec_attr + ii*2);", "  \t\tunsigned char cred_id = *(file->sec_attr + ii*2 + 1);", " \t\tunsigned sc = acl * 0x100 + cred_id;", " \t\tsc_log(ctx, \"ACL(%i) op 0x%X, acl %X:%X\", ii, op, acl, cred_id);", " \t\tif (op == 0xFF)", " \t\t\t;", " \t\telse if (!acl && !cred_id)", " \t\t\tsc_file_add_acl_entry(file, op, SC_AC_NONE, 0);", " \t\telse if (acl == 0xFF)", " \t\t\tsc_file_add_acl_entry(file, op, SC_AC_NEVER, 0);", " \t\telse if (acl & AUTHENTIC_AC_SM_MASK)", " \t\t\tsc_file_add_acl_entry(file, op, SC_AC_SCB, sc);", " \t\telse if (cred_id)", " \t\t\tsc_file_add_acl_entry(file, op, SC_AC_CHV, cred_id);", " \t\telse", " \t\t\tsc_file_add_acl_entry(file, op, SC_AC_NEVER, 0);", " \t}", " \tLOG_FUNC_RETURN(ctx, 0);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int start_decoder(vorb *f)", " {", "    uint8 header[6], x,y;", "    int len,i,j,k, max_submaps = 0;", "    int longest_floorlist=0;", "    if (!start_page(f))                              return FALSE;", "    if (!(f->page_flag & PAGEFLAG_first_page))       return error(f, VORBIS_invalid_first_page);", "    if (f->page_flag & PAGEFLAG_last_page)           return error(f, VORBIS_invalid_first_page);", "    if (f->page_flag & PAGEFLAG_continued_packet)    return error(f, VORBIS_invalid_first_page);", "    if (f->segment_count != 1)                       return error(f, VORBIS_invalid_first_page);", "    if (f->segments[0] != 30)                        return error(f, VORBIS_invalid_first_page);", "    if (get8(f) != VORBIS_packet_id)                 return error(f, VORBIS_invalid_first_page);", "    if (!getn(f, header, 6))                         return error(f, VORBIS_unexpected_eof);", "    if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_first_page);", "    if (get32(f) != 0)                               return error(f, VORBIS_invalid_first_page);", "    f->channels = get8(f); if (!f->channels)         return error(f, VORBIS_invalid_first_page);", "    if (f->channels > STB_VORBIS_MAX_CHANNELS)       return error(f, VORBIS_too_many_channels);", "    f->sample_rate = get32(f); if (!f->sample_rate)  return error(f, VORBIS_invalid_first_page);", "    get32(f);  ", "    get32(f);  ", "    get32(f);  ", "    x = get8(f);", "    {", "       int log0,log1;", "       log0 = x & 15;", "       log1 = x >> 4;", "       f->blocksize_0 = 1 << log0;", "       f->blocksize_1 = 1 << log1;", "       if (log0 < 6 || log0 > 13)                       return error(f, VORBIS_invalid_setup);", "       if (log1 < 6 || log1 > 13)                       return error(f, VORBIS_invalid_setup);", "       if (log0 > log1)                                 return error(f, VORBIS_invalid_setup);", "    }", "    x = get8(f);", "    if (!(x & 1))                                    return error(f, VORBIS_invalid_first_page);", "    if (!start_page(f))                              return FALSE;", "    if (!start_packet(f))                            return FALSE;", "    do {", "       len = next_segment(f);", "       skip(f, len);", "       f->bytes_in_seg = 0;", "    } while (len);", "    if (!start_packet(f))                            return FALSE;", "    #ifndef STB_VORBIS_NO_PUSHDATA_API", "    if (IS_PUSH_MODE(f)) {", "       if (!is_whole_packet_present(f, TRUE)) {", "          if (f->error == VORBIS_invalid_stream)", "             f->error = VORBIS_invalid_setup;", "          return FALSE;", "       }", "    }", "    #endif", "    crc32_init();  ", "    if (get8_packet(f) != VORBIS_packet_setup)       return error(f, VORBIS_invalid_setup);", "    for (i=0; i < 6; ++i) header[i] = get8_packet(f);", "    if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_setup);", "    f->codebook_count = get_bits(f,8) + 1;", "    f->codebooks = (Codebook *) setup_malloc(f, sizeof(*f->codebooks) * f->codebook_count);", "    if (f->codebooks == NULL)                        return error(f, VORBIS_outofmem);", "    memset(f->codebooks, 0, sizeof(*f->codebooks) * f->codebook_count);", "    for (i=0; i < f->codebook_count; ++i) {", "       uint32 *values;", "       int ordered, sorted_count;", "       int total=0;", "       uint8 *lengths;", "       Codebook *c = f->codebooks+i;", "       CHECK(f);", "       x = get_bits(f, 8); if (x != 0x42)            return error(f, VORBIS_invalid_setup);", "       x = get_bits(f, 8); if (x != 0x43)            return error(f, VORBIS_invalid_setup);", "       x = get_bits(f, 8); if (x != 0x56)            return error(f, VORBIS_invalid_setup);", "       x = get_bits(f, 8);", "       c->dimensions = (get_bits(f, 8)<<8) + x;", "       x = get_bits(f, 8);", "       y = get_bits(f, 8);", "       c->entries = (get_bits(f, 8)<<16) + (y<<8) + x;", "       ordered = get_bits(f,1);", "       c->sparse = ordered ? 0 : get_bits(f,1);", "       if (c->dimensions == 0 && c->entries != 0)    return error(f, VORBIS_invalid_setup);", "       if (c->sparse)", "          lengths = (uint8 *) setup_temp_malloc(f, c->entries);", "       else", "          lengths = c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);", "       if (!lengths) return error(f, VORBIS_outofmem);", "       if (ordered) {", "          int current_entry = 0;", "          int current_length = get_bits(f,5) + 1;", "          while (current_entry < c->entries) {", "             int limit = c->entries - current_entry;", "             int n = get_bits(f, ilog(limit));", "             if (current_entry + n > (int) c->entries) { return error(f, VORBIS_invalid_setup); }", "             memset(lengths + current_entry, current_length, n);", "             current_entry += n;", "             ++current_length;", "          }", "       } else {", "          for (j=0; j < c->entries; ++j) {", "             int present = c->sparse ? get_bits(f,1) : 1;", "             if (present) {", "                lengths[j] = get_bits(f, 5) + 1;", "                ++total;", "                if (lengths[j] == 32)", "                   return error(f, VORBIS_invalid_setup);", "             } else {", "                lengths[j] = NO_CODE;", "             }", "          }", "       }", "       if (c->sparse && total >= c->entries >> 2) {", "          if (c->entries > (int) f->setup_temp_memory_required)", "             f->setup_temp_memory_required = c->entries;", "          c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);", "          if (c->codeword_lengths == NULL) return error(f, VORBIS_outofmem);", "          memcpy(c->codeword_lengths, lengths, c->entries);", "          setup_temp_free(f, lengths, c->entries);  ", "          lengths = c->codeword_lengths;", "          c->sparse = 0;", "       }", "       if (c->sparse) {", "          sorted_count = total;", "       } else {", "          sorted_count = 0;", "          #ifndef STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH", "          for (j=0; j < c->entries; ++j)", "             if (lengths[j] > STB_VORBIS_FAST_HUFFMAN_LENGTH && lengths[j] != NO_CODE)", "                ++sorted_count;", "          #endif", "       }", "       c->sorted_entries = sorted_count;", "       values = NULL;", "       CHECK(f);", "       if (!c->sparse) {", "          c->codewords = (uint32 *) setup_malloc(f, sizeof(c->codewords[0]) * c->entries);", "          if (!c->codewords)                  return error(f, VORBIS_outofmem);", "       } else {", "          unsigned int size;", "          if (c->sorted_entries) {", "             c->codeword_lengths = (uint8 *) setup_malloc(f, c->sorted_entries);", "             if (!c->codeword_lengths)           return error(f, VORBIS_outofmem);", "             c->codewords = (uint32 *) setup_temp_malloc(f, sizeof(*c->codewords) * c->sorted_entries);", "             if (!c->codewords)                  return error(f, VORBIS_outofmem);", "             values = (uint32 *) setup_temp_malloc(f, sizeof(*values) * c->sorted_entries);", "             if (!values)                        return error(f, VORBIS_outofmem);", "          }", "          size = c->entries + (sizeof(*c->codewords) + sizeof(*values)) * c->sorted_entries;", "          if (size > f->setup_temp_memory_required)", "             f->setup_temp_memory_required = size;", "       }", "       if (!compute_codewords(c, lengths, c->entries, values)) {", "          if (c->sparse) setup_temp_free(f, values, 0);", "          return error(f, VORBIS_invalid_setup);", "       }", "       if (c->sorted_entries) {", "          c->sorted_codewords = (uint32 *) setup_malloc(f, sizeof(*c->sorted_codewords) * (c->sorted_entries+1));", "          if (c->sorted_codewords == NULL) return error(f, VORBIS_outofmem);", "          c->sorted_values    = ( int   *) setup_malloc(f, sizeof(*c->sorted_values   ) * (c->sorted_entries+1));", "          if (c->sorted_values == NULL) return error(f, VORBIS_outofmem);", "          ++c->sorted_values;", "          c->sorted_values[-1] = -1;", "          compute_sorted_huffman(c, lengths, values);", "       }", "       if (c->sparse) {", "          setup_temp_free(f, values, sizeof(*values)*c->sorted_entries);", "          setup_temp_free(f, c->codewords, sizeof(*c->codewords)*c->sorted_entries);", "          setup_temp_free(f, lengths, c->entries);", "          c->codewords = NULL;", "       }", "       compute_accelerated_huffman(c);", "       CHECK(f);", "       c->lookup_type = get_bits(f, 4);", "       if (c->lookup_type > 2) return error(f, VORBIS_invalid_setup);", "       if (c->lookup_type > 0) {", "          uint16 *mults;", "          c->minimum_value = float32_unpack(get_bits(f, 32));", "          c->delta_value = float32_unpack(get_bits(f, 32));", "          c->value_bits = get_bits(f, 4)+1;", "          c->sequence_p = get_bits(f,1);", "          if (c->lookup_type == 1) {", "             c->lookup_values = lookup1_values(c->entries, c->dimensions);", "          } else {", "             c->lookup_values = c->entries * c->dimensions;", "          }", "          if (c->lookup_values == 0) return error(f, VORBIS_invalid_setup);", "          mults = (uint16 *) setup_temp_malloc(f, sizeof(mults[0]) * c->lookup_values);", "          if (mults == NULL) return error(f, VORBIS_outofmem);", "          for (j=0; j < (int) c->lookup_values; ++j) {", "             int q = get_bits(f, c->value_bits);", "             if (q == EOP) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_invalid_setup); }", "             mults[j] = q;", "          }", " #ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK", "          if (c->lookup_type == 1) {", "             int len, sparse = c->sparse;", "             float last=0;", "             if (sparse) {", "                if (c->sorted_entries == 0) goto skip;", "                c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->sorted_entries * c->dimensions);", "             } else", "                c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->entries        * c->dimensions);", "             if (c->multiplicands == NULL) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }", "             len = sparse ? c->sorted_entries : c->entries;", "             for (j=0; j < len; ++j) {", "                unsigned int z = sparse ? c->sorted_values[j] : j;", "                unsigned int div=1;", "                for (k=0; k < c->dimensions; ++k) {", "                   int off = (z / div) % c->lookup_values;", "                   float val = mults[off];", "                   val = mults[off]*c->delta_value + c->minimum_value + last;", "                   c->multiplicands[j*c->dimensions + k] = val;", "                   if (c->sequence_p)", "                      last = val;", "                   if (k+1 < c->dimensions) {", "                      if (div > UINT_MAX / (unsigned int) c->lookup_values) {", "                         setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values);", "                         return error(f, VORBIS_invalid_setup);", "                      }", "                      div *= c->lookup_values;", "                   }", "                }", "             }", "             c->lookup_type = 2;", "          }", "          else", " #endif", "          {", "             float last=0;", "             CHECK(f);", "             c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->lookup_values);", "             if (c->multiplicands == NULL) { setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }", "             for (j=0; j < (int) c->lookup_values; ++j) {", "                float val = mults[j] * c->delta_value + c->minimum_value + last;", "                c->multiplicands[j] = val;", "                if (c->sequence_p)", "                   last = val;", "             }", "          }", " #ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK", "         skip:;", " #endif", "          setup_temp_free(f, mults, sizeof(mults[0])*c->lookup_values);", "          CHECK(f);", "       }", "       CHECK(f);", "    }", "    x = get_bits(f, 6) + 1;", "    for (i=0; i < x; ++i) {", "       uint32 z = get_bits(f, 16);", "       if (z != 0) return error(f, VORBIS_invalid_setup);", "    }", "    f->floor_count = get_bits(f, 6)+1;", "    f->floor_config = (Floor *)  setup_malloc(f, f->floor_count * sizeof(*f->floor_config));", "    if (f->floor_config == NULL) return error(f, VORBIS_outofmem);", "    for (i=0; i < f->floor_count; ++i) {", "       f->floor_types[i] = get_bits(f, 16);", "       if (f->floor_types[i] > 1) return error(f, VORBIS_invalid_setup);", "       if (f->floor_types[i] == 0) {", "          Floor0 *g = &f->floor_config[i].floor0;", "          g->order = get_bits(f,8);", "          g->rate = get_bits(f,16);", "          g->bark_map_size = get_bits(f,16);", "          g->amplitude_bits = get_bits(f,6);", "          g->amplitude_offset = get_bits(f,8);", "          g->number_of_books = get_bits(f,4) + 1;", "          for (j=0; j < g->number_of_books; ++j)", "             g->book_list[j] = get_bits(f,8);", "          return error(f, VORBIS_feature_not_supported);", "       } else {", "          stbv__floor_ordering p[31*8+2];", "          Floor1 *g = &f->floor_config[i].floor1;", "          int max_class = -1; ", "          g->partitions = get_bits(f, 5);", "          for (j=0; j < g->partitions; ++j) {", "             g->partition_class_list[j] = get_bits(f, 4);", "             if (g->partition_class_list[j] > max_class)", "                max_class = g->partition_class_list[j];", "          }", "          for (j=0; j <= max_class; ++j) {", "             g->class_dimensions[j] = get_bits(f, 3)+1;", "             g->class_subclasses[j] = get_bits(f, 2);", "             if (g->class_subclasses[j]) {", "                g->class_masterbooks[j] = get_bits(f, 8);", "                if (g->class_masterbooks[j] >= f->codebook_count) return error(f, VORBIS_invalid_setup);", "             }", "             for (k=0; k < 1 << g->class_subclasses[j]; ++k) {", "                g->subclass_books[j][k] = get_bits(f,8)-1;", "                if (g->subclass_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);", "             }", "          }", "          g->floor1_multiplier = get_bits(f,2)+1;", "          g->rangebits = get_bits(f,4);", "          g->Xlist[0] = 0;", "          g->Xlist[1] = 1 << g->rangebits;", "          g->values = 2;", "          for (j=0; j < g->partitions; ++j) {", "             int c = g->partition_class_list[j];", "             for (k=0; k < g->class_dimensions[c]; ++k) {", "                g->Xlist[g->values] = get_bits(f, g->rangebits);", "                ++g->values;", "             }", "          }", "          for (j=0; j < g->values; ++j) {", "             p[j].x = g->Xlist[j];", "             p[j].id = j;", "          }", "          qsort(p, g->values, sizeof(p[0]), point_compare);", "          for (j=0; j < g->values; ++j)", "             g->sorted_order[j] = (uint8) p[j].id;", "          for (j=2; j < g->values; ++j) {", "             int low,hi;", "             neighbors(g->Xlist, j, &low,&hi);", "             g->neighbors[j][0] = low;", "             g->neighbors[j][1] = hi;", "          }", "          if (g->values > longest_floorlist)", "             longest_floorlist = g->values;", "       }", "    }", "    f->residue_count = get_bits(f, 6)+1;", "    f->residue_config = (Residue *) setup_malloc(f, f->residue_count * sizeof(f->residue_config[0]));", "    if (f->residue_config == NULL) return error(f, VORBIS_outofmem);", "    memset(f->residue_config, 0, f->residue_count * sizeof(f->residue_config[0]));", "    for (i=0; i < f->residue_count; ++i) {", "       uint8 residue_cascade[64];", "       Residue *r = f->residue_config+i;", "       f->residue_types[i] = get_bits(f, 16);", "       if (f->residue_types[i] > 2) return error(f, VORBIS_invalid_setup);", "       r->begin = get_bits(f, 24);", "       r->end = get_bits(f, 24);", "       if (r->end < r->begin) return error(f, VORBIS_invalid_setup);", "       r->part_size = get_bits(f,24)+1;", "       r->classifications = get_bits(f,6)+1;", "       r->classbook = get_bits(f,8);", "       if (r->classbook >= f->codebook_count) return error(f, VORBIS_invalid_setup);", "       for (j=0; j < r->classifications; ++j) {", "          uint8 high_bits=0;", "          uint8 low_bits=get_bits(f,3);", "          if (get_bits(f,1))", "             high_bits = get_bits(f,5);", "          residue_cascade[j] = high_bits*8 + low_bits;", "       }", "       r->residue_books = (short (*)[8]) setup_malloc(f, sizeof(r->residue_books[0]) * r->classifications);", "       if (r->residue_books == NULL) return error(f, VORBIS_outofmem);", "       for (j=0; j < r->classifications; ++j) {", "          for (k=0; k < 8; ++k) {", "             if (residue_cascade[j] & (1 << k)) {", "                r->residue_books[j][k] = get_bits(f, 8);", "                if (r->residue_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);", "             } else {", "                r->residue_books[j][k] = -1;", "             }", "          }", "       }", "       r->classdata = (uint8 **) setup_malloc(f, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);", "       if (!r->classdata) return error(f, VORBIS_outofmem);", "       memset(r->classdata, 0, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);", "       for (j=0; j < f->codebooks[r->classbook].entries; ++j) {", "          int classwords = f->codebooks[r->classbook].dimensions;", "          int temp = j;", "          r->classdata[j] = (uint8 *) setup_malloc(f, sizeof(r->classdata[j][0]) * classwords);", "          if (r->classdata[j] == NULL) return error(f, VORBIS_outofmem);", "          for (k=classwords-1; k >= 0; --k) {", "             r->classdata[j][k] = temp % r->classifications;", "             temp /= r->classifications;", "          }", "       }", "    }", "    f->mapping_count = get_bits(f,6)+1;", "    f->mapping = (Mapping *) setup_malloc(f, f->mapping_count * sizeof(*f->mapping));", "    if (f->mapping == NULL) return error(f, VORBIS_outofmem);", "    memset(f->mapping, 0, f->mapping_count * sizeof(*f->mapping));", "    for (i=0; i < f->mapping_count; ++i) {", "       Mapping *m = f->mapping + i;      ", "       int mapping_type = get_bits(f,16);", "       if (mapping_type != 0) return error(f, VORBIS_invalid_setup);", "       m->chan = (MappingChannel *) setup_malloc(f, f->channels * sizeof(*m->chan));", "       if (m->chan == NULL) return error(f, VORBIS_outofmem);", "       if (get_bits(f,1))", "          m->submaps = get_bits(f,4)+1;", "       else", "          m->submaps = 1;", "       if (m->submaps > max_submaps)", "          max_submaps = m->submaps;", "       if (get_bits(f,1)) {", "          m->coupling_steps = get_bits(f,8)+1;", "          for (k=0; k < m->coupling_steps; ++k) {", "             m->chan[k].magnitude = get_bits(f, ilog(f->channels-1));", "             m->chan[k].angle = get_bits(f, ilog(f->channels-1));", "             if (m->chan[k].magnitude >= f->channels)        return error(f, VORBIS_invalid_setup);", "             if (m->chan[k].angle     >= f->channels)        return error(f, VORBIS_invalid_setup);", "             if (m->chan[k].magnitude == m->chan[k].angle)   return error(f, VORBIS_invalid_setup);", "          }", "       } else", "          m->coupling_steps = 0;", "       if (get_bits(f,2)) return error(f, VORBIS_invalid_setup);", "       if (m->submaps > 1) {", "          for (j=0; j < f->channels; ++j) {", "             m->chan[j].mux = get_bits(f, 4);", "             if (m->chan[j].mux >= m->submaps)                return error(f, VORBIS_invalid_setup);", "          }", "       } else", "          for (j=0; j < f->channels; ++j)", "             m->chan[j].mux = 0;", "       for (j=0; j < m->submaps; ++j) {", "          get_bits(f,8);  ", "          m->submap_floor[j] = get_bits(f,8);", "          m->submap_residue[j] = get_bits(f,8);", "          if (m->submap_floor[j] >= f->floor_count)      return error(f, VORBIS_invalid_setup);", "          if (m->submap_residue[j] >= f->residue_count)  return error(f, VORBIS_invalid_setup);", "       }", "    }", "    f->mode_count = get_bits(f, 6)+1;", "    for (i=0; i < f->mode_count; ++i) {", "       Mode *m = f->mode_config+i;", "       m->blockflag = get_bits(f,1);", "       m->windowtype = get_bits(f,16);", "       m->transformtype = get_bits(f,16);", "       m->mapping = get_bits(f,8);", "       if (m->windowtype != 0)                 return error(f, VORBIS_invalid_setup);", "       if (m->transformtype != 0)              return error(f, VORBIS_invalid_setup);", "       if (m->mapping >= f->mapping_count)     return error(f, VORBIS_invalid_setup);", "    }", "    flush_packet(f);", "    f->previous_length = 0;", "    for (i=0; i < f->channels; ++i) {", "       f->channel_buffers[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1);", "       f->previous_window[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2);", "       f->finalY[i]          = (int16 *) setup_malloc(f, sizeof(int16) * longest_floorlist);", "       if (f->channel_buffers[i] == NULL || f->previous_window[i] == NULL || f->finalY[i] == NULL) return error(f, VORBIS_outofmem);", "       #ifdef STB_VORBIS_NO_DEFER_FLOOR", "       f->floor_buffers[i]   = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2);", "       if (f->floor_buffers[i] == NULL) return error(f, VORBIS_outofmem);", "       #endif", "    }", "    if (!init_blocksize(f, 0, f->blocksize_0)) return FALSE;", "    if (!init_blocksize(f, 1, f->blocksize_1)) return FALSE;", "    f->blocksize[0] = f->blocksize_0;", "    f->blocksize[1] = f->blocksize_1;", " #ifdef STB_VORBIS_DIVIDE_TABLE", "    if (integer_divide_table[1][1]==0)", "       for (i=0; i < DIVTAB_NUMER; ++i)", "          for (j=1; j < DIVTAB_DENOM; ++j)", "             integer_divide_table[i][j] = i / j;", " #endif", "    {", "       uint32 imdct_mem = (f->blocksize_1 * sizeof(float) >> 1);", "       uint32 classify_mem;", "        int i,max_part_read=0;", "        for (i=0; i < f->residue_count; ++i) {", "           Residue *r = f->residue_config + i;", "         int n_read = r->end - r->begin;", "          unsigned int actual_size = f->blocksize_1 / 2;", "          unsigned int limit_r_begin = r->begin < actual_size ? r->begin : actual_size;", "          unsigned int limit_r_end   = r->end   < actual_size ? r->end   : actual_size;", "          int n_read = limit_r_end - limit_r_begin;", "           int part_read = n_read / r->part_size;", "           if (part_read > max_part_read)", "              max_part_read = part_read;", "       }", "       #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE", "       classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(uint8 *));", "       #else", "        classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(int *));", "        #endif", "        f->temp_memory_required = classify_mem;", "        if (imdct_mem > f->temp_memory_required)", "           f->temp_memory_required = imdct_mem;", "    }", "    f->first_decode = TRUE;", "    if (f->alloc.alloc_buffer) {", "       assert(f->temp_offset == f->alloc.alloc_buffer_length_in_bytes);", "       if (f->setup_offset + sizeof(*f) + f->temp_memory_required > (unsigned) f->temp_offset)", "          return error(f, VORBIS_outofmem);", "    }", "    f->first_audio_page_offset = stb_vorbis_get_file_offset(f);", "    return TRUE;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  void jas_matrix_setall(jas_matrix_t *matrix, jas_seqent_t val)", "  {", "\tint i;", "\tint j;", " \tjas_matind_t i;", " \tjas_matind_t j;", "  \tjas_seqent_t *rowstart;", "\tint rowstep;", " \tjas_matind_t rowstep;", "  \tjas_seqent_t *data;", "  \tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {", " \t\tassert(matrix->rows_);", " \t\trowstep = jas_matrix_rowstep(matrix);", " \t\tfor (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,", " \t\t  rowstart += rowstep) {", " \t\t\tfor (j = matrix->numcols_, data = rowstart; j > 0; --j,", " \t\t\t  ++data) {", " \t\t\t\t*data = val;", " \t\t\t}", " \t\t}", " \t}", " }"], "ner_tags": [0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  cleanup_pathname(struct archive_write_disk *a)", " {", " \tchar *dest, *src;", " \tchar separator = '\\0';", " \tdest = src = a->name;", " \tif (*src == '\\0') {", " \t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,", " \t\t    \"Invalid empty pathname\");", " \t\treturn (ARCHIVE_FAILED);", " \t}", " #if defined(__CYGWIN__)", "  \tcleanup_pathname_win(a);", "  #endif", "\tif (*src == '/')", " \tif (*src == '/') {", " \t\tif (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {", " \t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,", " \t\t\t                  \"Path is absolute\");", " \t\t\treturn (ARCHIVE_FAILED);", " \t\t}", "  \t\tseparator = *src++;", " \t}", "  \tfor (;;) {", " \t\tif (src[0] == '\\0') {", " \t\t\tbreak;", " \t\t} else if (src[0] == '/') {", " \t\t\tsrc++;", " \t\t\tcontinue;", " \t\t} else if (src[0] == '.') {", " \t\t\tif (src[1] == '\\0') {", " \t\t\t\tbreak;", " \t\t\t} else if (src[1] == '/') {", " \t\t\t\tsrc += 2;", " \t\t\t\tcontinue;", " \t\t\t} else if (src[1] == '.') {", " \t\t\t\tif (src[2] == '/' || src[2] == '\\0') {", " \t\t\t\t\tif (a->flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {", " \t\t\t\t\t\tarchive_set_error(&a->archive,", " \t\t\t\t\t\t    ARCHIVE_ERRNO_MISC,", " \t\t\t\t\t\t    \"Path contains '..'\");", " \t\t\t\t\t\treturn (ARCHIVE_FAILED);", " \t\t\t\t\t}", " \t\t\t\t}", " \t\t\t}", " \t\t}", " \t\tif (separator)", " \t\t\t*dest++ = '/';", " \t\twhile (*src != '\\0' && *src != '/') {", " \t\t\t*dest++ = *src++;", " \t\t}", " \t\tif (*src == '\\0')", " \t\t\tbreak;", " \t\tseparator = *src++;", " \t}", " \tif (dest == a->name) {", " \t\tif (separator)", " \t\t\t*dest++ = '/';", " \t\telse", " \t\t\t*dest++ = '.';", " \t}", " \t*dest = '\\0';", " \treturn (ARCHIVE_OK);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  size_t OpenMP4SourceUDTA(char *filename)", "  {", " \tmp4object *mp4 = (mp4object *)malloc(sizeof(mp4object));", " \tif (mp4 == NULL) return 0;", " \tmemset(mp4, 0, sizeof(mp4object));", " #ifdef _WINDOWS", " \tfopen_s(&mp4->mediafp, filename, \"rb\");", " #else", " \tmp4->mediafp = fopen(filename, \"rb\");", " #endif", "  \tif (mp4->mediafp)", "  \t{", "\t\tuint32_t qttag, qtsize32, len;", " \t\tuint32_t qttag, qtsize32;", " \t\tsize_t len;", "  \t\tint32_t nest = 0;", "  \t\tuint64_t nestsize[MAX_NEST_LEVEL] = { 0 };", "  \t\tuint64_t lastsize = 0, qtsize;", " \t\tdo", " \t\t{", " \t\t\tlen = fread(&qtsize32, 1, 4, mp4->mediafp);", " \t\t\tlen += fread(&qttag, 1, 4, mp4->mediafp);", " \t\t\tif (len == 8)", "  \t\t\t{", "  \t\t\t\tif (!GPMF_VALID_FOURCC(qttag))", "  \t\t\t\t{", "\t\t\t\t\tLONGSEEK(mp4->mediafp, lastsize - 8 - 8, SEEK_CUR);", " \t\t\t\t\tLongSeek(mp4, lastsize - 8 - 8);", "  \t\t\t\t\tNESTSIZE(lastsize - 8);", "  \t\t\t\t\tcontinue;", " \t\t\t\t}", " \t\t\t\tqtsize32 = BYTESWAP32(qtsize32);", " \t\t\t\tif (qtsize32 == 1)  ", " \t\t\t\t{", " \t\t\t\t\tfread(&qtsize, 1, 8, mp4->mediafp);", " \t\t\t\t\tqtsize = BYTESWAP64(qtsize) - 8;", " \t\t\t\t}", " \t\t\t\telse", " \t\t\t\t\tqtsize = qtsize32;", " \t\t\t\tnest++;", " \t\t\t\tif (qtsize < 8) break;", " \t\t\t\tif (nest >= MAX_NEST_LEVEL) break;", " \t\t\t\tnestsize[nest] = qtsize;", " \t\t\t\tlastsize = qtsize;", "  \t\t\t\tif (qttag == MAKEID('m', 'd', 'a', 't') ||", "  \t\t\t\t\tqttag == MAKEID('f', 't', 'y', 'p'))", "  \t\t\t\t{", "\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);", " \t\t\t\t\tLongSeek(mp4, qtsize - 8);", "  \t\t\t\t\tNESTSIZE(qtsize);", "  \t\t\t\t\tcontinue;", "  \t\t\t\t}", " \t\t\t\tif (qttag == MAKEID('G', 'P', 'M', 'F'))", " \t\t\t\t{", " \t\t\t\t\tmp4->videolength += 1.0;", " \t\t\t\t\tmp4->metadatalength += 1.0;", " \t\t\t\t\tmp4->indexcount = (int)mp4->metadatalength;", " \t\t\t\t\tmp4->metasizes = (uint32_t *)malloc(mp4->indexcount * 4 + 4);  memset(mp4->metasizes, 0, mp4->indexcount * 4 + 4);", " \t\t\t\t\tmp4->metaoffsets = (uint64_t *)malloc(mp4->indexcount * 8 + 8);  memset(mp4->metaoffsets, 0, mp4->indexcount * 8 + 8);", " \t\t\t\t\tmp4->metasizes[0] = (int)qtsize - 8;", " \t\t\t\t\tmp4->metaoffsets[0] = ftell(mp4->mediafp);", " \t\t\t\t\tmp4->metasize_count = 1;", " \t\t\t\t\treturn (size_t)mp4;   ", " \t\t\t\t}", "  \t\t\t\tif (qttag != MAKEID('m', 'o', 'o', 'v') &&  ", "  \t\t\t\t\tqttag != MAKEID('u', 'd', 't', 'a'))", "  \t\t\t\t{", "\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);", " \t\t\t\t\tLongSeek(mp4, qtsize - 8);", "  \t\t\t\t\tNESTSIZE(qtsize);", "  \t\t\t\t\tcontinue;", "  \t\t\t\t}", " \t\t\t\telse", " \t\t\t\t{", " \t\t\t\t\tNESTSIZE(8);", " \t\t\t\t}", " \t\t\t}", " \t\t} while (len > 0);", " \t}", " \treturn (size_t)mp4;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" inf_gtk_certificate_manager_certificate_func(InfXmppConnection* connection,", "                                              gnutls_session_t session,", "                                              InfCertificateChain* chain,", "                                              gpointer user_data)", " {", "   InfGtkCertificateManager* manager;", "   InfGtkCertificateManagerPrivate* priv;", "   InfGtkCertificateDialogFlags flags;", "   gnutls_x509_crt_t presented_cert;", "   gnutls_x509_crt_t known_cert;", "   gchar* hostname;", "   gboolean match_hostname;", "   gboolean issuer_known;", "   gnutls_x509_crt_t root_cert;", "   int ret;", "   unsigned int verify;", "   GHashTable* table;", "   gboolean cert_equal;", "   time_t expiration_time;", "   InfGtkCertificateManagerQuery* query;", "   gchar* text;", "   GtkWidget* vbox;", "   GtkWidget* label;", "   GError* error;", "   manager = INF_GTK_CERTIFICATE_MANAGER(user_data);", "   priv = INF_GTK_CERTIFICATE_MANAGER_PRIVATE(manager);", "   g_object_get(G_OBJECT(connection), \"remote-hostname\", &hostname, NULL);", "   presented_cert = inf_certificate_chain_get_own_certificate(chain);", "   match_hostname = gnutls_x509_crt_check_hostname(presented_cert, hostname);", "   ret = gnutls_certificate_verify_peers2(session, &verify);", "   error = NULL;", "   if(ret != GNUTLS_E_SUCCESS)", "     inf_gnutls_set_error(&error, ret);", "   if(error == NULL)", "   {", "     issuer_known = TRUE;", "     if(verify & GNUTLS_CERT_SIGNER_NOT_FOUND)", "     {", "       issuer_known = FALSE;", "       root_cert = inf_certificate_chain_get_root_certificate(chain);", "       ret = gnutls_x509_crt_list_verify(", "         inf_certificate_chain_get_raw(chain),", "         inf_certificate_chain_get_n_certificates(chain),", "         &root_cert,", "         1,", "         NULL,", "         0,", "         GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT,", "         &verify", "       );", "        if(ret != GNUTLS_E_SUCCESS)", "          inf_gnutls_set_error(&error, ret);", "      else if(verify & GNUTLS_CERT_INVALID)", "        inf_gnutls_certificate_verification_set_error(&error, verify);", "      }", "     if(error == NULL)", "       if(verify & GNUTLS_CERT_INVALID)", "         inf_gnutls_certificate_verification_set_error(&error, verify);", "    }", "   table = NULL;", "   if(error == NULL)", "   {", "     known_cert = NULL;", "     if(!match_hostname || !issuer_known)", "     {", "       table = inf_gtk_certificate_manager_ref_known_hosts(manager, &error);", "       if(table != NULL)", "         known_cert = g_hash_table_lookup(table, hostname);", "     }", "   }", "   flags = 0;", "   if(error == NULL)", "   {", "     if(known_cert != NULL)", "     {", "       cert_equal = inf_gtk_certificate_manager_compare_fingerprint(", "         known_cert,", "         presented_cert,", "         &error", "       );", "       if(error == NULL && cert_equal == FALSE)", "       {", "         if(!match_hostname)", "           flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_HOSTNAME_MISMATCH;", "         if(!issuer_known)", "           flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_ISSUER_NOT_KNOWN;", "         flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_UNEXPECTED;", "         expiration_time = gnutls_x509_crt_get_expiration_time(known_cert);", "         if(expiration_time != (time_t)(-1))", "         {", "           expiration_time -= INF_GTK_CERTIFICATE_MANAGER_EXPIRATION_TOLERANCE;", "           if(time(NULL) > expiration_time)", "           {", "             flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_OLD_EXPIRED;", "           }", "         }", "       }", "     }", "     else", "     {", "       if(!match_hostname)", "         flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_HOSTNAME_MISMATCH;", "       if(!issuer_known)", "         flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_ISSUER_NOT_KNOWN;", "     }", "   }", "   if(error == NULL)", "   {", "     if(flags == 0)", "     {", "       if(match_hostname && issuer_known)", "       {", "         if(table != NULL && g_hash_table_remove(table, hostname) == TRUE)", "         {", "           inf_gtk_certificate_manager_write_known_hosts_with_warning(", "             manager,", "             table", "           );", "         }", "       }", "       inf_xmpp_connection_certificate_verify_continue(connection);", "     }", "     else", "     {", "       query = g_slice_new(InfGtkCertificateManagerQuery);", "       query->manager = manager;", "       query->known_hosts = table;", "       query->connection = connection;", "       query->dialog = inf_gtk_certificate_dialog_new(", "         priv->parent_window,", "         0,", "         flags,", "         hostname,", "         chain", "       );", "       query->certificate_chain = chain;", "       table = NULL;", "       g_object_ref(query->connection);", "       inf_certificate_chain_ref(chain);", "       g_signal_connect(", "         G_OBJECT(connection),", "         \"notify::status\",", "         G_CALLBACK(inf_gtk_certificate_manager_notify_status_cb),", "         query", "       );", "       g_signal_connect(", "         G_OBJECT(query->dialog),", "         \"response\",", "         G_CALLBACK(inf_gtk_certificate_manager_response_cb),", "         query", "       );", "       gtk_dialog_add_button(", "         GTK_DIALOG(query->dialog),", "         _(\"_Cancel connection\"),", "         GTK_RESPONSE_REJECT", "       );", "       gtk_dialog_add_button(", "         GTK_DIALOG(query->dialog),", "         _(\"C_ontinue connection\"),", "         GTK_RESPONSE_ACCEPT", "       );", "       text = g_strdup_printf(", "         _(\"Do you want to continue the connection to host \\\"%s\\\"? If you \"", "           \"choose to continue, this certificate will be trusted in the \"", "           \"future when connecting to this host.\"),", "         hostname", "       );", "       label = gtk_label_new(text);", "       gtk_label_set_line_wrap(GTK_LABEL(label), TRUE);", "       gtk_label_set_line_wrap_mode(GTK_LABEL(label), PANGO_WRAP_WORD_CHAR);", "       gtk_label_set_max_width_chars(GTK_LABEL(label), 60);", "       gtk_misc_set_alignment(GTK_MISC(label), 0.0, 0.0);", "       gtk_widget_show(label);", "       g_free(text);", "       vbox = gtk_dialog_get_content_area(GTK_DIALOG(query->dialog));", "       gtk_box_pack_start(GTK_BOX(vbox), label, FALSE, FALSE, 0);", "       priv->queries = g_slist_prepend(priv->queries, query);", "       gtk_window_present(GTK_WINDOW(query->dialog));", "     }", "   }", "   else", "   {", "     inf_xmpp_connection_certificate_verify_cancel(connection, error);", "     g_error_free(error);", "   }", "   if(table != NULL) g_hash_table_unref(table);", "   g_free(hostname);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int sc_file_set_sec_attr(sc_file_t *file, const u8 *sec_attr,", " \t\t\t size_t sec_attr_len)", " {", " \tu8 *tmp;", " \tif (!sc_file_valid(file)) {", "  \t\treturn SC_ERROR_INVALID_ARGUMENTS;", "  \t}", "\tif (sec_attr == NULL) {", " \tif (sec_attr == NULL || sec_attr_len) {", "  \t\tif (file->sec_attr != NULL)", "  \t\t\tfree(file->sec_attr);", "  \t\tfile->sec_attr = NULL;", " \t\tfile->sec_attr_len = 0;", " \t\treturn 0;", " \t }", " \ttmp = (u8 *) realloc(file->sec_attr, sec_attr_len);", " \tif (!tmp) {", " \t\tif (file->sec_attr)", " \t\t\tfree(file->sec_attr);", " \t\tfile->sec_attr     = NULL;", " \t\tfile->sec_attr_len = 0;", " \t\treturn SC_ERROR_OUT_OF_MEMORY;", " \t}", " \tfile->sec_attr = tmp;", " \tmemcpy(file->sec_attr, sec_attr, sec_attr_len);", " \tfile->sec_attr_len = sec_attr_len;", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void WritePixel(struct ngiflib_img * i, struct ngiflib_decode_context * context, u8 v) {", " \tstruct ngiflib_gif * p = i->parent;", " \tif(v!=i->gce.transparent_color || !i->gce.transparent_flag) {", " #ifndef NGIFLIB_INDEXED_ONLY", " \t\tif(p->mode & NGIFLIB_MODE_INDEXED) {", " #endif  ", " \t\t\t*context->frbuff_p.p8 = v;", " #ifndef NGIFLIB_INDEXED_ONLY", " \t\t} else", " \t\t\t*context->frbuff_p.p32 =", " \t\t\t   GifIndexToTrueColor(i->palette, v);", " #endif  ", " \t}", " \tif(--(context->Xtogo) <= 0) {", " \t\t#ifdef NGIFLIB_ENABLE_CALLBACKS", " \t\tif(p->line_cb) p->line_cb(p, context->line_p, context->curY);", " \t\t#endif  ", " \t\tcontext->Xtogo = i->width;", " \t\tswitch(context->pass) {", " \t\tcase 0:", " \t\t\tcontext->curY++;", "  \t\t\tbreak;", "  \t\tcase 1:\t ", "  \t\t\tcontext->curY += 8;", "\t\t\tif(context->curY >= p->height) {", "\t\t\t\tcontext->pass++;", "\t\t\t\tcontext->curY = i->posY + 4;", "\t\t\t}", "  \t\t\tbreak;", "  \t\tcase 2:\t ", "  \t\t\tcontext->curY += 8;", "\t\t\tif(context->curY >= p->height) {", "\t\t\t\tcontext->pass++;", "\t\t\t\tcontext->curY = i->posY + 2;", "\t\t\t}", "  \t\t\tbreak;", "  \t\tcase 3:\t ", "  \t\t\tcontext->curY += 4;", "\t\t\tif(context->curY >= p->height) {", "\t\t\t\tcontext->pass++;", "\t\t\t\tcontext->curY = i->posY + 1;", "\t\t\t}", "  \t\t\tbreak;", "  \t\tcase 4:\t ", "  \t\t\tcontext->curY += 2;", "  \t\t\tbreak;", "  \t\t}", " \t\twhile(context->pass > 0 && context->pass < 4 &&", " \t\t      context->curY >= p->height) {", " \t\t\tswitch(++context->pass) {", " \t\t\tcase 2:\t ", " \t\t\t\tcontext->curY = i->posY + 4;", " \t\t\t\tbreak;", " \t\t\tcase 3:\t ", " \t\t\t\tcontext->curY = i->posY + 2;", " \t\t\t\tbreak;", " \t\t\tcase 4:\t ", " \t\t\t\tcontext->curY = i->posY + 1;", " \t\t\t\tbreak;", " \t\t\t}", " \t\t}", "  #ifndef NGIFLIB_INDEXED_ONLY", "  \t\tif(p->mode & NGIFLIB_MODE_INDEXED) {", "  #endif  ", " \t\t\t#ifdef NGIFLIB_ENABLE_CALLBACKS", " \t\t\tcontext->line_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width;", " \t\t\tcontext->frbuff_p.p8 = context->line_p.p8 + i->posX;", " \t\t\t#else", " \t\t\tcontext->frbuff_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width + i->posX;", " \t\t\t#endif  ", " #ifndef NGIFLIB_INDEXED_ONLY", " \t\t} else {", " \t\t\t#ifdef NGIFLIB_ENABLE_CALLBACKS", " \t\t\tcontext->line_p.p32 = p->frbuff.p32 + (u32)context->curY*p->width;", " \t\t\tcontext->frbuff_p.p32 = context->line_p.p32 + i->posX;", " \t\t\t#else", " \t\t\tcontext->frbuff_p.p32 = p->frbuff.p32 + (u32)context->curY*p->width + i->posX;", " \t\t\t#endif  ", " \t\t}", " #endif  ", " \t} else {", " #ifndef NGIFLIB_INDEXED_ONLY", " \t\tif(p->mode & NGIFLIB_MODE_INDEXED) {", " #endif  ", " \t\t\tcontext->frbuff_p.p8++;", " #ifndef NGIFLIB_INDEXED_ONLY", " \t\t} else {", " \t\t\tcontext->frbuff_p.p32++;", " \t\t}", " #endif  ", " \t}", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int cdxl_decode_frame(AVCodecContext *avctx, void *data,", "                              int *got_frame, AVPacket *pkt)", " {", "     CDXLVideoContext *c = avctx->priv_data;", "     AVFrame * const p = data;", "     int ret, w, h, encoding, aligned_width, buf_size = pkt->size;", "     const uint8_t *buf = pkt->data;", "     if (buf_size < 32)", "         return AVERROR_INVALIDDATA;", "     encoding        = buf[1] & 7;", "     c->format       = buf[1] & 0xE0;", "     w               = AV_RB16(&buf[14]);", "     h               = AV_RB16(&buf[16]);", "     c->bpp          = buf[19];", "     c->palette_size = AV_RB16(&buf[20]);", "     c->palette      = buf + 32;", "     c->video        = c->palette + c->palette_size;", "     c->video_size   = buf_size - c->palette_size - 32;", "     if (c->palette_size > 512)", "         return AVERROR_INVALIDDATA;", "     if (buf_size < c->palette_size + 32)", "         return AVERROR_INVALIDDATA;", "     if (c->bpp < 1)", "         return AVERROR_INVALIDDATA;", "     if (c->format != BIT_PLANAR && c->format != BIT_LINE && c->format != CHUNKY) {", "         avpriv_request_sample(avctx, \"Pixel format 0x%0x\", c->format);", "         return AVERROR_PATCHWELCOME;", "     }", "     if ((ret = ff_set_dimensions(avctx, w, h)) < 0)", "         return ret;", "     if (c->format == CHUNKY)", "         aligned_width = avctx->width;", "     else", "         aligned_width = FFALIGN(c->avctx->width, 16);", "     c->padded_bits  = aligned_width - c->avctx->width;", "     if (c->video_size < aligned_width * avctx->height * (int64_t)c->bpp / 8)", "          return AVERROR_INVALIDDATA;", "      if (!encoding && c->palette_size && c->bpp <= 8 && c->format != CHUNKY) {", "          avctx->pix_fmt = AV_PIX_FMT_PAL8;", "    } else if (encoding == 1 && (c->bpp == 6 || c->bpp == 8)) {", "     } else if (encoding == 1 && (c->bpp == 6 || c->bpp == 8) && c->format != CHUNKY) {", "          if (c->palette_size != (1 << (c->bpp - 1)))", "              return AVERROR_INVALIDDATA;", "          avctx->pix_fmt = AV_PIX_FMT_BGR24;", "     } else if (!encoding && c->bpp == 24 && c->format == CHUNKY &&", "                !c->palette_size) {", "         avctx->pix_fmt = AV_PIX_FMT_RGB24;", "     } else {", "         avpriv_request_sample(avctx, \"Encoding %d, bpp %d and format 0x%x\",", "                               encoding, c->bpp, c->format);", "         return AVERROR_PATCHWELCOME;", "     }", "     if ((ret = ff_get_buffer(avctx, p, 0)) < 0)", "         return ret;", "     p->pict_type = AV_PICTURE_TYPE_I;", "     if (encoding) {", "         av_fast_padded_malloc(&c->new_video, &c->new_video_size,", "                               h * w + AV_INPUT_BUFFER_PADDING_SIZE);", "         if (!c->new_video)", "             return AVERROR(ENOMEM);", "         if (c->bpp == 8)", "             cdxl_decode_ham8(c, p);", "         else", "             cdxl_decode_ham6(c, p);", "     } else if (avctx->pix_fmt == AV_PIX_FMT_PAL8) {", "         cdxl_decode_rgb(c, p);", "     } else {", "         cdxl_decode_raw(c, p);", "     }", "     *got_frame = 1;", "     return buf_size;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static mif_hdr_t *mif_hdr_get(jas_stream_t *in)", "  {", "\tuchar magicbuf[MIF_MAGICLEN];", " \tjas_uchar magicbuf[MIF_MAGICLEN];", "  \tchar buf[4096];", "  \tmif_hdr_t *hdr;", "  \tbool done;", " \tjas_tvparser_t *tvp;", " \tint id;", " \thdr = 0;", " \ttvp = 0;", " \tif (jas_stream_read(in, magicbuf, MIF_MAGICLEN) != MIF_MAGICLEN) {", " \t\tgoto error;", " \t}", " \tif (magicbuf[0] != (MIF_MAGIC >> 24) || magicbuf[1] != ((MIF_MAGIC >> 16) &", " \t  0xff) || magicbuf[2] != ((MIF_MAGIC >> 8) & 0xff) || magicbuf[3] !=", " \t  (MIF_MAGIC & 0xff)) {", " \t\tjas_eprintf(\"error: bad signature\\n\");", " \t\tgoto error;", " \t}", " \tif (!(hdr = mif_hdr_create(0))) {", " \t\tgoto error;", " \t}", " \tdone = false;", " \tdo {", " \t\tif (!mif_getline(in, buf, sizeof(buf))) {", " \t\t\tjas_eprintf(\"mif_getline failed\\n\");", " \t\t\tgoto error;", " \t\t}", " \t\tif (buf[0] == '\\0') {", " \t\t\tcontinue;", " \t\t}", " \t\tJAS_DBGLOG(10, (\"header line: len=%d; %s\\n\", strlen(buf), buf));", " \t\tif (!(tvp = jas_tvparser_create(buf))) {", " \t\t\tjas_eprintf(\"jas_tvparser_create failed\\n\");", " \t\t\tgoto error;", " \t\t}", " \t\tif (jas_tvparser_next(tvp)) {", " \t\t\tjas_eprintf(\"cannot get record type\\n\");", " \t\t\tgoto error;", " \t\t}", " \t\tid = jas_taginfo_nonull(jas_taginfos_lookup(mif_tags2,", " \t\t  jas_tvparser_gettag(tvp)))->id;", " \t\tjas_tvparser_destroy(tvp);", " \t\ttvp = 0;", " \t\tswitch (id) {", " \t\tcase MIF_CMPT:", " \t\t\tif (mif_process_cmpt(hdr, buf)) {", " \t\t\t\tjas_eprintf(\"cannot get component information\\n\");", " \t\t\t\tgoto error;", " \t\t\t}", " \t\t\tbreak;", " \t\tcase MIF_END:", " \t\t\tdone = 1;", " \t\t\tbreak;", " \t\tdefault:", " \t\t\tjas_eprintf(\"invalid header information: %s\\n\", buf);", " \t\t\tgoto error;", " \t\t\tbreak;", " \t\t}", " \t} while (!done);", " \treturn hdr;", " error:", " \tif (hdr) {", " \t\tmif_hdr_destroy(hdr);", " \t}", " \tif (tvp) {", " \t\tjas_tvparser_destroy(tvp);", " \t}", " \treturn 0;", " }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int get_cox(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c)", " {", "     uint8_t byte;", "     if (bytestream2_get_bytes_left(&s->g) < 5)", "         return AVERROR_INVALIDDATA;", "     c->nreslevels = bytestream2_get_byteu(&s->g) + 1;", "     if (c->nreslevels >= JPEG2000_MAX_RESLEVELS) {", "         av_log(s->avctx, AV_LOG_ERROR, \"nreslevels %d is invalid\\n\", c->nreslevels);", "          return AVERROR_INVALIDDATA;", "      }", "     if (c->nreslevels <= s->reduction_factor) {", "         av_log(s->avctx, AV_LOG_ERROR, \"reduction_factor too large for this bitstream, max is %d\\n\", c->nreslevels - 1);", "         s->reduction_factor = c->nreslevels - 1;", "         return AVERROR(EINVAL);", "     }", "    if (c->nreslevels < s->reduction_factor)", "        c->nreslevels2decode = 1;", "    else", "        c->nreslevels2decode = c->nreslevels - s->reduction_factor;", "     c->nreslevels2decode = c->nreslevels - s->reduction_factor;", "      c->log2_cblk_width  = (bytestream2_get_byteu(&s->g) & 15) + 2;  ", "      c->log2_cblk_height = (bytestream2_get_byteu(&s->g) & 15) + 2;  ", "     if (c->log2_cblk_width > 10 || c->log2_cblk_height > 10 ||", "         c->log2_cblk_width + c->log2_cblk_height > 12) {", "         av_log(s->avctx, AV_LOG_ERROR, \"cblk size invalid\\n\");", "         return AVERROR_INVALIDDATA;", "     }", "     if (c->log2_cblk_width > 6 || c->log2_cblk_height > 6) {", "         avpriv_request_sample(s->avctx, \"cblk size > 64\");", "         return AVERROR_PATCHWELCOME;", "     }", "     c->cblk_style = bytestream2_get_byteu(&s->g);", "     if (c->cblk_style != 0) {  ", "         av_log(s->avctx, AV_LOG_WARNING, \"extra cblk styles %X\\n\", c->cblk_style);", "     }", "     c->transform = bytestream2_get_byteu(&s->g);  ", "     if ((s->avctx->flags & CODEC_FLAG_BITEXACT) && (c->transform == FF_DWT97))", "         c->transform = FF_DWT97_INT;", "     if (c->csty & JPEG2000_CSTY_PREC) {", "         int i;", "         for (i = 0; i < c->nreslevels; i++) {", "             byte = bytestream2_get_byte(&s->g);", "             c->log2_prec_widths[i]  =  byte       & 0x0F;     ", "             c->log2_prec_heights[i] = (byte >> 4) & 0x0F;     ", "         }", "     } else {", "         memset(c->log2_prec_widths , 15, sizeof(c->log2_prec_widths ));", "         memset(c->log2_prec_heights, 15, sizeof(c->log2_prec_heights));", "     }", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)", "  {", "      long i;", "    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {", "     for (i = 0; i <= w - (int)sizeof(long); i += sizeof(long)) {", "          long a = *(long *)(src1 + i);", "          long b = *(long *)(src2 + i);", "          *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);", "     }", "     for (; i < w; i++)", "         dst[i] = src1[i] + src2[i];", " }"], "ner_tags": [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static void tokenadd(struct jv_parser* p, char c) {", "    assert(p->tokenpos <= p->tokenlen);", "  if (p->tokenpos == p->tokenlen) {", "   if (p->tokenpos >= (p->tokenlen - 1)) {", "      p->tokenlen = p->tokenlen*2 + 256;", "      p->tokenbuf = jv_mem_realloc(p->tokenbuf, p->tokenlen);", "    }", "   assert(p->tokenpos < p->tokenlen);", "   p->tokenbuf[p->tokenpos++] = c;", " }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" dispatch_cmd(conn c)", " {", "     int r, i, timeout = -1;", "     size_t z;", "     unsigned int count;", "     job j;", "     unsigned char type;", "     char *size_buf, *delay_buf, *ttr_buf, *pri_buf, *end_buf, *name;", "     unsigned int pri, body_size;", "     usec delay, ttr;", "     uint64_t id;", "     tube t = NULL;", "     c->cmd[c->cmd_len - 2] = '\\0';", "     if (strlen(c->cmd) != c->cmd_len - 2) {", "         return reply_msg(c, MSG_BAD_FORMAT);", "     }", "     type = which_cmd(c);", "     dprintf(\"got %s command: \\\"%s\\\"\\n\", op_names[(int) type], c->cmd);", "     switch (type) {", "     case OP_PUT:", "         r = read_pri(&pri, c->cmd + 4, &delay_buf);", "         if (r) return reply_msg(c, MSG_BAD_FORMAT);", "         r = read_delay(&delay, delay_buf, &ttr_buf);", "         if (r) return reply_msg(c, MSG_BAD_FORMAT);", "         r = read_ttr(&ttr, ttr_buf, &size_buf);", "         if (r) return reply_msg(c, MSG_BAD_FORMAT);", "         errno = 0;", "         body_size = strtoul(size_buf, &end_buf, 10);", "          if (errno) return reply_msg(c, MSG_BAD_FORMAT);", "          if (body_size > job_data_size_limit) {", "            return reply_msg(c, MSG_JOB_TOO_BIG);", "             return skip(c, body_size + 2, MSG_JOB_TOO_BIG);", "          }", "         if (end_buf[0] != '\\0') return reply_msg(c, MSG_BAD_FORMAT);", "         conn_set_producer(c);", "         c->in_job = make_job(pri, delay, ttr ? : 1, body_size + 2, c->use);", "         if (!c->in_job) {", "             twarnx(\"server error: \" MSG_OUT_OF_MEMORY);", "             return skip(c, body_size + 2, MSG_OUT_OF_MEMORY);", "         }", "         fill_extra_data(c);", "         maybe_enqueue_incoming_job(c);", "         break;", "     case OP_PEEK_READY:", "         if (c->cmd_len != CMD_PEEK_READY_LEN + 2) {", "             return reply_msg(c, MSG_BAD_FORMAT);", "         }", "         op_ct[type]++;", "         j = job_copy(pq_peek(&c->use->ready));", "         if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD);", "         reply_job(c, j, MSG_FOUND);", "         break;", "     case OP_PEEK_DELAYED:", "         if (c->cmd_len != CMD_PEEK_DELAYED_LEN + 2) {", "             return reply_msg(c, MSG_BAD_FORMAT);", "         }", "         op_ct[type]++;", "         j = job_copy(pq_peek(&c->use->delay));", "         if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD);", "         reply_job(c, j, MSG_FOUND);", "         break;", "     case OP_PEEK_BURIED:", "         if (c->cmd_len != CMD_PEEK_BURIED_LEN + 2) {", "             return reply_msg(c, MSG_BAD_FORMAT);", "         }", "         op_ct[type]++;", "         j = job_copy(buried_job_p(c->use)? j = c->use->buried.next : NULL);", "         if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD);", "         reply_job(c, j, MSG_FOUND);", "         break;", "     case OP_PEEKJOB:", "         errno = 0;", "         id = strtoull(c->cmd + CMD_PEEKJOB_LEN, &end_buf, 10);", "         if (errno) return reply_msg(c, MSG_BAD_FORMAT);", "         op_ct[type]++;", "         j = job_copy(peek_job(id));", "         if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD);", "         reply_job(c, j, MSG_FOUND);", "         break;", "     case OP_RESERVE_TIMEOUT:", "         errno = 0;", "         timeout = strtol(c->cmd + CMD_RESERVE_TIMEOUT_LEN, &end_buf, 10);", "         if (errno) return reply_msg(c, MSG_BAD_FORMAT);", "     case OP_RESERVE:  ", "         if (type == OP_RESERVE && c->cmd_len != CMD_RESERVE_LEN + 2) {", "             return reply_msg(c, MSG_BAD_FORMAT);", "         }", "         op_ct[type]++;", "         conn_set_worker(c);", "         if (conn_has_close_deadline(c) && !conn_ready(c)) {", "             return reply_msg(c, MSG_DEADLINE_SOON);", "         }", "         wait_for_job(c, timeout);", "         process_queue();", "         break;", "     case OP_DELETE:", "         errno = 0;", "         id = strtoull(c->cmd + CMD_DELETE_LEN, &end_buf, 10);", "         if (errno) return reply_msg(c, MSG_BAD_FORMAT);", "         op_ct[type]++;", "         j = job_find(id);", "         j = remove_reserved_job(c, j) ? :", "             remove_ready_job(j) ? :", "             remove_buried_job(j);", "         if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD);", "         j->state = JOB_STATE_INVALID;", "         r = binlog_write_job(j);", "         job_free(j);", "         if (!r) return reply_serr(c, MSG_INTERNAL_ERROR);", "         reply(c, MSG_DELETED, MSG_DELETED_LEN, STATE_SENDWORD);", "         break;", "     case OP_RELEASE:", "         errno = 0;", "         id = strtoull(c->cmd + CMD_RELEASE_LEN, &pri_buf, 10);", "         if (errno) return reply_msg(c, MSG_BAD_FORMAT);", "         r = read_pri(&pri, pri_buf, &delay_buf);", "         if (r) return reply_msg(c, MSG_BAD_FORMAT);", "         r = read_delay(&delay, delay_buf, NULL);", "         if (r) return reply_msg(c, MSG_BAD_FORMAT);", "         op_ct[type]++;", "         j = remove_reserved_job(c, job_find(id));", "         if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD);", "         if (delay) {", "             z = binlog_reserve_space_update(j);", "             if (!z) return reply_serr(c, MSG_OUT_OF_MEMORY);", "             j->reserved_binlog_space += z;", "         }", "         j->pri = pri;", "         j->delay = delay;", "         j->release_ct++;", "         r = enqueue_job(j, delay, !!delay);", "         if (r < 0) return reply_serr(c, MSG_INTERNAL_ERROR);", "         if (r == 1) {", "             return reply(c, MSG_RELEASED, MSG_RELEASED_LEN, STATE_SENDWORD);", "         }", "         bury_job(j, 0);", "         reply(c, MSG_BURIED, MSG_BURIED_LEN, STATE_SENDWORD);", "         break;", "     case OP_BURY:", "         errno = 0;", "         id = strtoull(c->cmd + CMD_BURY_LEN, &pri_buf, 10);", "         if (errno) return reply_msg(c, MSG_BAD_FORMAT);", "         r = read_pri(&pri, pri_buf, NULL);", "         if (r) return reply_msg(c, MSG_BAD_FORMAT);", "         op_ct[type]++;", "         j = remove_reserved_job(c, job_find(id));", "         if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD);", "         j->pri = pri;", "         r = bury_job(j, 1);", "         if (!r) return reply_serr(c, MSG_INTERNAL_ERROR);", "         reply(c, MSG_BURIED, MSG_BURIED_LEN, STATE_SENDWORD);", "         break;", "     case OP_KICK:", "         errno = 0;", "         count = strtoul(c->cmd + CMD_KICK_LEN, &end_buf, 10);", "         if (end_buf == c->cmd + CMD_KICK_LEN) {", "             return reply_msg(c, MSG_BAD_FORMAT);", "         }", "         if (errno) return reply_msg(c, MSG_BAD_FORMAT);", "         op_ct[type]++;", "         i = kick_jobs(c->use, count);", "         return reply_line(c, STATE_SENDWORD, \"KICKED %u\\r\\n\", i);", "     case OP_TOUCH:", "         errno = 0;", "         id = strtoull(c->cmd + CMD_TOUCH_LEN, &end_buf, 10);", "         if (errno) return twarn(\"strtoull\"), reply_msg(c, MSG_BAD_FORMAT);", "         op_ct[type]++;", "         j = touch_job(c, job_find(id));", "         if (j) {", "             reply(c, MSG_TOUCHED, MSG_TOUCHED_LEN, STATE_SENDWORD);", "         } else {", "             return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD);", "         }", "         break;", "     case OP_STATS:", "         if (c->cmd_len != CMD_STATS_LEN + 2) {", "             return reply_msg(c, MSG_BAD_FORMAT);", "         }", "         op_ct[type]++;", "         do_stats(c, fmt_stats, NULL);", "         break;", "     case OP_JOBSTATS:", "         errno = 0;", "         id = strtoull(c->cmd + CMD_JOBSTATS_LEN, &end_buf, 10);", "         if (errno) return reply_msg(c, MSG_BAD_FORMAT);", "         op_ct[type]++;", "         j = peek_job(id);", "         if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD);", "         if (!j->tube) return reply_serr(c, MSG_INTERNAL_ERROR);", "         do_stats(c, (fmt_fn) fmt_job_stats, j);", "         break;", "     case OP_STATS_TUBE:", "         name = c->cmd + CMD_STATS_TUBE_LEN;", "         if (!name_is_ok(name, 200)) return reply_msg(c, MSG_BAD_FORMAT);", "         op_ct[type]++;", "         t = tube_find(name);", "         if (!t) return reply_msg(c, MSG_NOTFOUND);", "         do_stats(c, (fmt_fn) fmt_stats_tube, t);", "         t = NULL;", "         break;", "     case OP_LIST_TUBES:", "         if (c->cmd_len != CMD_LIST_TUBES_LEN + 2) {", "             return reply_msg(c, MSG_BAD_FORMAT);", "         }", "         op_ct[type]++;", "         do_list_tubes(c, &tubes);", "         break;", "     case OP_LIST_TUBE_USED:", "         if (c->cmd_len != CMD_LIST_TUBE_USED_LEN + 2) {", "             return reply_msg(c, MSG_BAD_FORMAT);", "         }", "         op_ct[type]++;", "         reply_line(c, STATE_SENDWORD, \"USING %s\\r\\n\", c->use->name);", "         break;", "     case OP_LIST_TUBES_WATCHED:", "         if (c->cmd_len != CMD_LIST_TUBES_WATCHED_LEN + 2) {", "             return reply_msg(c, MSG_BAD_FORMAT);", "         }", "         op_ct[type]++;", "         do_list_tubes(c, &c->watch);", "         break;", "     case OP_USE:", "         name = c->cmd + CMD_USE_LEN;", "         if (!name_is_ok(name, 200)) return reply_msg(c, MSG_BAD_FORMAT);", "         op_ct[type]++;", "         TUBE_ASSIGN(t, tube_find_or_make(name));", "         if (!t) return reply_serr(c, MSG_OUT_OF_MEMORY);", "         c->use->using_ct--;", "         TUBE_ASSIGN(c->use, t);", "         TUBE_ASSIGN(t, NULL);", "         c->use->using_ct++;", "         reply_line(c, STATE_SENDWORD, \"USING %s\\r\\n\", c->use->name);", "         break;", "     case OP_WATCH:", "         name = c->cmd + CMD_WATCH_LEN;", "         if (!name_is_ok(name, 200)) return reply_msg(c, MSG_BAD_FORMAT);", "         op_ct[type]++;", "         TUBE_ASSIGN(t, tube_find_or_make(name));", "         if (!t) return reply_serr(c, MSG_OUT_OF_MEMORY);", "         r = 1;", "         if (!ms_contains(&c->watch, t)) r = ms_append(&c->watch, t);", "         TUBE_ASSIGN(t, NULL);", "         if (!r) return reply_serr(c, MSG_OUT_OF_MEMORY);", "         reply_line(c, STATE_SENDWORD, \"WATCHING %d\\r\\n\", c->watch.used);", "         break;", "     case OP_IGNORE:", "         name = c->cmd + CMD_IGNORE_LEN;", "         if (!name_is_ok(name, 200)) return reply_msg(c, MSG_BAD_FORMAT);", "         op_ct[type]++;", "         t = NULL;", "         for (i = 0; i < c->watch.used; i++) {", "             t = c->watch.items[i];", "             if (strncmp(t->name, name, MAX_TUBE_NAME_LEN) == 0) break;", "             t = NULL;", "         }", "         if (t && c->watch.used < 2) return reply_msg(c, MSG_NOT_IGNORED);", "         if (t) ms_remove(&c->watch, t);  ", "         t = NULL;", "         reply_line(c, STATE_SENDWORD, \"WATCHING %d\\r\\n\", c->watch.used);", "         break;", "     case OP_QUIT:", "         conn_close(c);", "         break;", "     case OP_PAUSE_TUBE:", "         op_ct[type]++;", "         r = read_tube_name(&name, c->cmd + CMD_PAUSE_TUBE_LEN, &delay_buf);", "         if (r) return reply_msg(c, MSG_BAD_FORMAT);", "         r = read_delay(&delay, delay_buf, NULL);", "         if (r) return reply_msg(c, MSG_BAD_FORMAT);", "         *delay_buf = '\\0';", "         t = tube_find(name);", "         if (!t) return reply_msg(c, MSG_NOTFOUND);", "         t->deadline_at = now_usec() + delay;", "         t->pause = delay;", "         t->stat.pause_ct++;", "         set_main_delay_timeout();", "         reply_line(c, STATE_SENDWORD, \"PAUSED\\r\\n\");", "         break;", "     default:", "         return reply_msg(c, MSG_UNKNOWN_COMMAND);", "     }", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int mp4client_main(int argc, char **argv)", " {", " \tchar c;", " \tconst char *str;", " \tint ret_val = 0;", " \tu32 i, times[100], nb_times, dump_mode;", " \tu32 simulation_time_in_ms = 0;", " \tu32 initial_service_id = 0;", " \tBool auto_exit = GF_FALSE;", " \tBool logs_set = GF_FALSE;", " \tBool start_fs = GF_FALSE;", " \tBool use_rtix = GF_FALSE;", " \tBool pause_at_first = GF_FALSE;", " \tBool no_cfg_save = GF_FALSE;", " \tBool is_cfg_only = GF_FALSE;", " \tDouble play_from = 0;", " #ifdef GPAC_MEMORY_TRACKING", "     GF_MemTrackerType mem_track = GF_MemTrackerNone;", " #endif", " \tDouble fps = GF_IMPORT_DEFAULT_FPS;", " \tBool fill_ar, visible, do_uncache, has_command;", " \tchar *url_arg, *out_arg, *the_cfg, *rti_file, *views, *mosaic;", " \tFILE *logfile = NULL;", " \tFloat scale = 1;", " #ifndef WIN32", " \tdlopen(NULL, RTLD_NOW|RTLD_GLOBAL);", " #endif", " \tstrcpy(the_url, \".\");", " \tmemset(&user, 0, sizeof(GF_User));", " \tdump_mode = DUMP_NONE;", " \tfill_ar = visible = do_uncache = has_command = GF_FALSE;", " \turl_arg = out_arg = the_cfg = rti_file = views = mosaic = NULL;", " \tnb_times = 0;", " \ttimes[0] = 0;", " \tfor (i=1; i<(u32) argc; i++) {", " \t\tchar *arg = argv[i];", " \t\tif (!strcmp(arg, \"-c\") || !strcmp(arg, \"-cfg\")) {", " \t\t\tthe_cfg = argv[i+1];", " \t\t\ti++;", " \t\t}", " \t\telse if (!strcmp(arg, \"-mem-track\") || !strcmp(arg, \"-mem-track-stack\")) {", " #ifdef GPAC_MEMORY_TRACKING", "             mem_track = !strcmp(arg, \"-mem-track-stack\") ? GF_MemTrackerBackTrace : GF_MemTrackerSimple;", " #else", " \t\t\tfprintf(stderr, \"WARNING - GPAC not compiled with Memory Tracker - ignoring \\\"%s\\\"\\n\", arg);", " #endif", " \t\t} else if (!strcmp(arg, \"-gui\")) {", " \t\t\tgui_mode = 1;", " \t\t} else if (!strcmp(arg, \"-guid\")) {", " \t\t\tgui_mode = 2;", " \t\t} else if (!strcmp(arg, \"-h\") || !strcmp(arg, \"-help\")) {", " \t\t\tPrintUsage();", " \t\t\treturn 0;", " \t\t}", " \t}", " #ifdef GPAC_MEMORY_TRACKING", " \tgf_sys_init(mem_track);", " #else", " \tgf_sys_init(GF_MemTrackerNone);", " #endif", " \tgf_sys_set_args(argc, (const char **) argv);", " \tcfg_file = gf_cfg_init(the_cfg, NULL);", " \tif (!cfg_file) {", " \t\tfprintf(stderr, \"Error: Configuration File not found\\n\");", " \t\treturn 1;", " \t}", " \tif (gf_log_set_tools_levels( gf_cfg_get_key(cfg_file, \"General\", \"Logs\") ) != GF_OK) {", " \t\treturn 1;", " \t}", " \tif( gf_cfg_get_key(cfg_file, \"General\", \"Logs\") != NULL ) {", " \t\tlogs_set = GF_TRUE;", " \t}", " \tif (!gui_mode) {", " \t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"ForceGUI\");", " \t\tif (str && !strcmp(str, \"yes\")) gui_mode = 1;", " \t}", " \tfor (i=1; i<(u32) argc; i++) {", " \t\tchar *arg = argv[i];", " \t\tif (!strcmp(arg, \"-rti\")) {", " \t\t\trti_file = argv[i+1];", " \t\t\ti++;", " \t\t} else if (!strcmp(arg, \"-rtix\")) {", " \t\t\trti_file = argv[i+1];", " \t\t\ti++;", " \t\t\tuse_rtix = GF_TRUE;", " \t\t} else if (!stricmp(arg, \"-size\")) {", " \t\t\tif (sscanf(argv[i+1], \"%dx%d\", &forced_width, &forced_height) != 2) {", " \t\t\t\tforced_width = forced_height = 0;", " \t\t\t}", " \t\t\ti++;", " \t\t} else if (!strcmp(arg, \"-quiet\")) {", " \t\t\tbe_quiet = 1;", " \t\t} else if (!strcmp(arg, \"-strict-error\")) {", " \t\t\tgf_log_set_strict_error(1);", " \t\t} else if (!strcmp(arg, \"-log-file\") || !strcmp(arg, \"-lf\")) {", " \t\t\tlogfile = gf_fopen(argv[i+1], \"wt\");", " \t\t\tgf_log_set_callback(logfile, on_gpac_log);", " \t\t\ti++;", " \t\t} else if (!strcmp(arg, \"-logs\") ) {", " \t\t\tif (gf_log_set_tools_levels(argv[i+1]) != GF_OK) {", " \t\t\t\treturn 1;", " \t\t\t}", " \t\t\tlogs_set = GF_TRUE;", " \t\t\ti++;", " \t\t} else if (!strcmp(arg, \"-log-clock\") || !strcmp(arg, \"-lc\")) {", " \t\t\tlog_time_start = 1;", " \t\t} else if (!strcmp(arg, \"-log-utc\") || !strcmp(arg, \"-lu\")) {", " \t\t\tlog_utc_time = 1;", " \t\t}", " #if defined(__DARWIN__) || defined(__APPLE__)", " \t\telse if (!strcmp(arg, \"-thread\")) threading_flags = 0;", " #else", " \t\telse if (!strcmp(arg, \"-no-thread\")) threading_flags = GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_WINDOW_NO_THREAD;", " #endif", " \t\telse if (!strcmp(arg, \"-no-cthread\") || !strcmp(arg, \"-no-compositor-thread\")) threading_flags |= GF_TERM_NO_COMPOSITOR_THREAD;", " \t\telse if (!strcmp(arg, \"-no-audio\")) no_audio = 1;", " \t\telse if (!strcmp(arg, \"-no-regulation\")) no_regulation = 1;", " \t\telse if (!strcmp(arg, \"-fs\")) start_fs = 1;", " \t\telse if (!strcmp(arg, \"-opt\")) {", " \t\t\tset_cfg_option(argv[i+1]);", " \t\t\ti++;", " \t\t} else if (!strcmp(arg, \"-conf\")) {", " \t\t\tset_cfg_option(argv[i+1]);", " \t\t\tis_cfg_only=GF_TRUE;", " \t\t\ti++;", " \t\t}", " \t\telse if (!strcmp(arg, \"-ifce\")) {", " \t\t\tgf_cfg_set_key(cfg_file, \"Network\", \"DefaultMCastInterface\", argv[i+1]);", " \t\t\ti++;", " \t\t}", " \t\telse if (!stricmp(arg, \"-help\")) {", " \t\t\tPrintUsage();", " \t\t\treturn 1;", " \t\t}", " \t\telse if (!stricmp(arg, \"-noprog\")) {", " \t\t\tno_prog=1;", " \t\t\tgf_set_progress_callback(NULL, progress_quiet);", " \t\t}", " \t\telse if (!stricmp(arg, \"-no-save\") || !stricmp(arg, \"--no-save\")  ) {", " \t\t\tno_cfg_save=1;", " \t\t}", " \t\telse if (!stricmp(arg, \"-ntp-shift\")) {", " \t\t\ts32 shift = atoi(argv[i+1]);", " \t\t\ti++;", " \t\t\tgf_net_set_ntp_shift(shift);", " \t\t}", " \t\telse if (!stricmp(arg, \"-run-for\")) {", " \t\t\tsimulation_time_in_ms = atoi(argv[i+1]) * 1000;", " \t\t\tif (!simulation_time_in_ms)", " \t\t\t\tsimulation_time_in_ms = 1;  ", " \t\t\ti++;", " \t\t}", " \t\telse if (!strcmp(arg, \"-out\")) {", " \t\t\tout_arg = argv[i+1];", " \t\t\ti++;", " \t\t}", " \t\telse if (!stricmp(arg, \"-fps\")) {", " \t\t\tfps = atof(argv[i+1]);", " \t\t\ti++;", " \t\t} else if (!strcmp(arg, \"-avi\") || !strcmp(arg, \"-sha\")) {", " \t\t\tdump_mode &= 0xFFFF0000;", " \t\t\tif (!strcmp(arg, \"-sha\")) dump_mode |= DUMP_SHA1;", " \t\t\telse dump_mode |= DUMP_AVI;", " \t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) {", " \t\t\t\tif (!strcmp(arg, \"-avi\") && (nb_times!=2) ) {", " \t\t\t\t\tfprintf(stderr, \"Only one time arg found for -avi - check usage\\n\");", " \t\t\t\t\treturn 1;", " \t\t\t\t}", " \t\t\t\ti++;", " \t\t\t}", " \t\t} else if (!strcmp(arg, \"-rgbds\")) {  ", " \t\t\t\tdump_mode |= DUMP_RGB_DEPTH_SHAPE;", " \t\t} else if (!strcmp(arg, \"-rgbd\")) {  ", " \t\t\t\tdump_mode |= DUMP_RGB_DEPTH;", " \t\t} else if (!strcmp(arg, \"-depth\")) {", " \t\t\t\tdump_mode |= DUMP_DEPTH_ONLY;", " \t\t} else if (!strcmp(arg, \"-bmp\")) {", " \t\t\tdump_mode &= 0xFFFF0000;", " \t\t\tdump_mode |= DUMP_BMP;", " \t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;", " \t\t} else if (!strcmp(arg, \"-png\")) {", " \t\t\tdump_mode &= 0xFFFF0000;", " \t\t\tdump_mode |= DUMP_PNG;", " \t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;", " \t\t} else if (!strcmp(arg, \"-raw\")) {", " \t\t\tdump_mode &= 0xFFFF0000;", " \t\t\tdump_mode |= DUMP_RAW;", " \t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;", " \t\t} else if (!stricmp(arg, \"-scale\")) {", " \t\t\tsscanf(argv[i+1], \"%f\", &scale);", " \t\t\ti++;", " \t\t}", " \t\telse if (!strcmp(arg, \"-c\") || !strcmp(arg, \"-cfg\")) {", " \t\t\ti++;", " \t\t}", " \t\tif (!gui_mode) {", " \t\t\tif (arg[0] != '-') {", " \t\t\t\tif (url_arg) {", " \t\t\t\t\tfprintf(stderr, \"Several input URLs provided (\\\"%s\\\", \\\"%s\\\"). Check your command-line.\\n\", url_arg, arg);", " \t\t\t\t\treturn 1;", " \t\t\t\t}", " \t\t\t\turl_arg = arg;", " \t\t\t}", " \t\t\telse if (!strcmp(arg, \"-loop\")) loop_at_end = 1;", " \t\t\telse if (!strcmp(arg, \"-bench\")) bench_mode = 1;", " \t\t\telse if (!strcmp(arg, \"-vbench\")) bench_mode = 2;", " \t\t\telse if (!strcmp(arg, \"-sbench\")) bench_mode = 3;", " \t\t\telse if (!strcmp(arg, \"-no-addon\")) enable_add_ons = GF_FALSE;", " \t\t\telse if (!strcmp(arg, \"-pause\")) pause_at_first = 1;", " \t\t\telse if (!strcmp(arg, \"-play-from\")) {", " \t\t\t\tplay_from = atof((const char *) argv[i+1]);", " \t\t\t\ti++;", " \t\t\t}", " \t\t\telse if (!strcmp(arg, \"-speed\")) {", " \t\t\t\tplayback_speed = FLT2FIX( atof((const char *) argv[i+1]) );", " \t\t\t\tif (playback_speed <= 0) playback_speed = FIX_ONE;", " \t\t\t\ti++;", " \t\t\t}", " \t\t\telse if (!strcmp(arg, \"-no-wnd\")) user.init_flags |= GF_TERM_WINDOWLESS;", " \t\t\telse if (!strcmp(arg, \"-no-back\")) user.init_flags |= GF_TERM_WINDOW_TRANSPARENT;", " \t\t\telse if (!strcmp(arg, \"-align\")) {", " \t\t\t\tif (argv[i+1][0]=='m') align_mode = 1;", " \t\t\t\telse if (argv[i+1][0]=='b') align_mode = 2;", " \t\t\t\talign_mode <<= 8;", " \t\t\t\tif (argv[i+1][1]=='m') align_mode |= 1;", " \t\t\t\telse if (argv[i+1][1]=='r') align_mode |= 2;", " \t\t\t\ti++;", " \t\t\t} else if (!strcmp(arg, \"-fill\")) {", " \t\t\t\tfill_ar = GF_TRUE;", " \t\t\t} else if (!strcmp(arg, \"-show\")) {", " \t\t\t\tvisible = 1;", " \t\t\t} else if (!strcmp(arg, \"-uncache\")) {", " \t\t\t\tdo_uncache = GF_TRUE;", " \t\t\t}", " \t\t\telse if (!strcmp(arg, \"-exit\")) auto_exit = GF_TRUE;", " \t\t\telse if (!stricmp(arg, \"-views\")) {", " \t\t\t\tviews = argv[i+1];", " \t\t\t\ti++;", " \t\t\t}", " \t\t\telse if (!stricmp(arg, \"-mosaic\")) {", " \t\t\t\tmosaic = argv[i+1];", " \t\t\t\ti++;", " \t\t\t}", " \t\t\telse if (!stricmp(arg, \"-com\")) {", " \t\t\t\thas_command = GF_TRUE;", " \t\t\t\ti++;", " \t\t\t}", " \t\t\telse if (!stricmp(arg, \"-service\")) {", " \t\t\t\tinitial_service_id = atoi(argv[i+1]);", " \t\t\t\ti++;", " \t\t\t}", " \t\t}", " \t}", " \tif (is_cfg_only) {", " \t\tgf_cfg_del(cfg_file);", " \t\tfprintf(stderr, \"GPAC Config updated\\n\");", " \t\treturn 0;", " \t}", " \tif (do_uncache) {", " \t\tconst char *cache_dir = gf_cfg_get_key(cfg_file, \"General\", \"CacheDirectory\");", " \t\tdo_flatten_cache(cache_dir);", " \t\tfprintf(stderr, \"GPAC Cache dir %s flattened\\n\", cache_dir);", " \t\tgf_cfg_del(cfg_file);", " \t\treturn 0;", " \t}", " \tif (dump_mode && !url_arg ) {", " \t\tFILE *test;", " \t\turl_arg = (char *)gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\");", " \t\ttest = url_arg ? gf_fopen(url_arg, \"rt\") : NULL;", " \t\tif (!test) url_arg = NULL;", " \t\telse gf_fclose(test);", " \t\tif (!url_arg) {", " \t\t\tfprintf(stderr, \"Missing argument for dump\\n\");", " \t\t\tPrintUsage();", " \t\t\tif (logfile) gf_fclose(logfile);", " \t\t\treturn 1;", " \t\t}", " \t}", " \tif (!gui_mode && !url_arg && (gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\") != NULL)) {", " \t\tgui_mode=1;", " \t}", " #ifdef WIN32", " \tif (gui_mode==1) {", " \t\tconst char *opt;", " \t\tTCHAR buffer[1024];", " \t\tDWORD res = GetCurrentDirectory(1024, buffer);", " \t\tbuffer[res] = 0;", " \t\topt = gf_cfg_get_key(cfg_file, \"General\", \"ModulesDirectory\");", " \t\tif (strstr(opt, buffer)) {", " \t\t\tgui_mode=1;", " \t\t} else {", " \t\t\tgui_mode=2;", " \t\t}", " \t}", " #endif", " \tif (gui_mode==1) {", " \t\thide_shell(1);", " \t}", " \tif (gui_mode) {", " \t\tno_prog=1;", " \t\tgf_set_progress_callback(NULL, progress_quiet);", " \t}", " \tif (!url_arg && simulation_time_in_ms)", " \t\tsimulation_time_in_ms += gf_sys_clock();", " #if defined(__DARWIN__) || defined(__APPLE__)", " \tcarbon_init();", " #endif", " \tif (dump_mode) rti_file = NULL;", " \tif (!logs_set) {", " \t\tgf_log_set_tool_level(GF_LOG_ALL, GF_LOG_WARNING);", " \t}", " \tif (rti_file || logfile || log_utc_time || log_time_start)", " \t\tgf_log_set_callback(NULL, on_gpac_log);", " \tif (rti_file) init_rti_logs(rti_file, url_arg, use_rtix);", " \t{", " \t\tGF_SystemRTInfo rti;", " \t\tif (gf_sys_get_rti(0, &rti, 0))", " \t\t\tfprintf(stderr, \"System info: %d MB RAM - %d cores\\n\", (u32) (rti.physical_memory/1024/1024), rti.nb_cores);", " \t}", " \tif (dump_mode) {", " \t\tuser.init_flags |= GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_NO_REGULATION;", " \t\tif (!visible)", " \t\t\tuser.init_flags |= GF_TERM_INIT_HIDE;", " \t\tgf_cfg_set_key(cfg_file, \"Audio\", \"DriverName\", \"Raw Audio Output\");", " \t\tno_cfg_save=GF_TRUE;", " \t} else {", " \t\tinit_w = forced_width;", " \t\tinit_h = forced_height;", " \t}", " \tuser.modules = gf_modules_new(NULL, cfg_file);", " \tif (user.modules) i = gf_modules_get_count(user.modules);", " \tif (!i || !user.modules) {", " \t\tfprintf(stderr, \"Error: no modules found - exiting\\n\");", " \t\tif (user.modules) gf_modules_del(user.modules);", " \t\tgf_cfg_del(cfg_file);", " \t\tgf_sys_close();", " \t\tif (logfile) gf_fclose(logfile);", " \t\treturn 1;", " \t}", " \tfprintf(stderr, \"Modules Found : %d \\n\", i);", " \tstr = gf_cfg_get_key(cfg_file, \"General\", \"GPACVersion\");", " \tif (!str || strcmp(str, GPAC_FULL_VERSION)) {", " \t\tgf_cfg_del_section(cfg_file, \"PluginsCache\");", " \t\tgf_cfg_set_key(cfg_file, \"General\", \"GPACVersion\", GPAC_FULL_VERSION);", " \t}", " \tuser.config = cfg_file;", " \tuser.EventProc = GPAC_EventProc;", " \tuser.opaque = user.modules;", " \tif (threading_flags) user.init_flags |= threading_flags;", " \tif (no_audio) user.init_flags |= GF_TERM_NO_AUDIO;", " \tif (no_regulation) user.init_flags |= GF_TERM_NO_REGULATION;", " \tif (threading_flags & (GF_TERM_NO_DECODER_THREAD|GF_TERM_NO_COMPOSITOR_THREAD) ) term_step = GF_TRUE;", " \tif (dump_mode) user.init_flags |= GF_TERM_USE_AUDIO_HW_CLOCK;", " \tif (bench_mode) {", " \t\tgf_cfg_discard_changes(user.config);", " \t\tauto_exit = GF_TRUE;", " \t\tgf_cfg_set_key(user.config, \"Audio\", \"DriverName\", \"Raw Audio Output\");", " \t\tif (bench_mode!=2) {", " \t\t\tgf_cfg_set_key(user.config, \"Video\", \"DriverName\", \"Raw Video Output\");", " \t\t\tgf_cfg_set_key(user.config, \"RAWVideo\", \"RawOutput\", \"null\");", " \t\t\tgf_cfg_set_key(user.config, \"Compositor\", \"OpenGLMode\", \"disable\");", " \t\t} else {", " \t\t\tgf_cfg_set_key(user.config, \"Video\", \"DisableVSync\", \"yes\");", " \t\t}", " \t}", " \t{", " \t\tchar dim[50];", " \t\tsprintf(dim, \"%d\", forced_width);", " \t\tgf_cfg_set_key(user.config, \"Compositor\", \"DefaultWidth\", forced_width ? dim : NULL);", " \t\tsprintf(dim, \"%d\", forced_height);", " \t\tgf_cfg_set_key(user.config, \"Compositor\", \"DefaultHeight\", forced_height ? dim : NULL);", " \t}", " \tfprintf(stderr, \"Loading GPAC Terminal\\n\");", " \ti = gf_sys_clock();", " \tterm = gf_term_new(&user);", " \tif (!term) {", " \t\tfprintf(stderr, \"\\nInit error - check you have at least one video out and one rasterizer...\\nFound modules:\\n\");", " \t\tlist_modules(user.modules);", " \t\tgf_modules_del(user.modules);", " \t\tgf_cfg_discard_changes(cfg_file);", " \t\tgf_cfg_del(cfg_file);", " \t\tgf_sys_close();", " \t\tif (logfile) gf_fclose(logfile);", " \t\treturn 1;", " \t}", " \tfprintf(stderr, \"Terminal Loaded in %d ms\\n\", gf_sys_clock()-i);", " \tif (bench_mode) {", " \t\tdisplay_rti = 2;", " \t\tgf_term_set_option(term, GF_OPT_VIDEO_BENCH, (bench_mode==3) ? 2 : 1);", " \t\tif (bench_mode==1) bench_mode=2;", " \t}", " \tif (dump_mode) {", " \t\tif (fill_ar) gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);", " \t} else {", " \t\tstr = gf_cfg_get_key(cfg_file, \"Video\", \"DriverName\");", " \t\tif (!bench_mode && !strcmp(str, \"Raw Video Output\")) fprintf(stderr, \"WARNING: using raw output video (memory only) - no display used\\n\");", " \t\tstr = gf_cfg_get_key(cfg_file, \"Audio\", \"DriverName\");", " \t\tif (!str || !strcmp(str, \"No Audio Output Available\")) fprintf(stderr, \"WARNING: no audio output available - make sure no other program is locking the sound card\\n\");", " \t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"NoMIMETypeFetch\");", " \t\tno_mime_check = (str && !stricmp(str, \"yes\")) ? 1 : 0;", " \t}", " \tstr = gf_cfg_get_key(cfg_file, \"HTTPProxy\", \"Enabled\");", " \tif (str && !strcmp(str, \"yes\")) {", " \t\tstr = gf_cfg_get_key(cfg_file, \"HTTPProxy\", \"Name\");", " \t\tif (str) fprintf(stderr, \"HTTP Proxy %s enabled\\n\", str);", " \t}", " \tif (rti_file) {", " \t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"RTIRefreshPeriod\");", " \t\tif (str) {", " \t\t\trti_update_time_ms = atoi(str);", " \t\t} else {", " \t\t\tgf_cfg_set_key(cfg_file, \"General\", \"RTIRefreshPeriod\", \"200\");", " \t\t}", " \t\tUpdateRTInfo(\"At GPAC load time\\n\");", " \t}", " \tRun = 1;", " \tif (dump_mode) {", " \t\tif (!nb_times) {", " \t\t\ttimes[0] = 0;", " \t\t\tnb_times++;", " \t\t}", " \t\tret_val = dump_file(url_arg, out_arg, dump_mode, fps, forced_width, forced_height, scale, times, nb_times);", " \t\tRun = 0;", " \t}", " \telse if (views) {", " \t}", " \telse if (!gui_mode && url_arg) {", " \t\tchar *ext;", " \t\tif (strlen(url_arg) >= sizeof(the_url)) {", " \t\t\tfprintf(stderr, \"Input url %s is too long, truncating to %d chars.\\n\", url_arg, (int)(sizeof(the_url) - 1));", " \t\t\tstrncpy(the_url, url_arg, sizeof(the_url)-1);", " \t\t\tthe_url[sizeof(the_url) - 1] = 0;", " \t\t}", " \t\telse {", " \t\t\tstrcpy(the_url, url_arg);", " \t\t}", " \t\text = strrchr(the_url, '.');", " \t\tif (ext && (!stricmp(ext, \".m3u\") || !stricmp(ext, \".pls\"))) {", " \t\t\tGF_Err e = GF_OK;", " \t\t\tfprintf(stderr, \"Opening Playlist %s\\n\", the_url);", " \t\t\tstrcpy(pl_path, the_url);", " \t\t\tif (!strncmp(\"http:\", the_url, 5)) {", " \t\t\t\tGF_DownloadSession *sess = gf_dm_sess_new(term->downloader, the_url, GF_NETIO_SESSION_NOT_THREADED, NULL, NULL, &e);", " \t\t\t\tif (sess) {", "  \t\t\t\t\te = gf_dm_sess_process(sess);", "  \t\t\t\t\tif (!e) {", "  \t\t\t\t\t\tstrncpy(the_url, gf_dm_sess_get_cache_name(sess), sizeof(the_url) - 1);", "\t\t\t\t\t\tthe_url[sizeof(the_cfg) - 1] = 0;", " \t\t\t\t\t\tthe_url[sizeof(the_url) - 1] = 0;", "  \t\t\t\t\t}", "  \t\t\t\t\tgf_dm_sess_del(sess);", "  \t\t\t\t}", " \t\t\t}", " \t\t\tplaylist = e ? NULL : gf_fopen(the_url, \"rt\");", " \t\t\treadonly_playlist = 1;", " \t\t\tif (playlist) {", " \t\t\t\trequest_next_playlist_item = GF_TRUE;", " \t\t\t} else {", " \t\t\t\tif (e)", " \t\t\t\t\tfprintf(stderr, \"Failed to open playlist %s: %s\\n\", the_url, gf_error_to_string(e) );", " \t\t\t\tfprintf(stderr, \"Hit 'h' for help\\n\\n\");", " \t\t\t}", " \t\t} else {", " \t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);", " \t\t\tif (pause_at_first) fprintf(stderr, \"[Status: Paused]\\n\");", " \t\t\tgf_term_connect_from_time(term, the_url, (u64) (play_from*1000), pause_at_first);", " \t\t}", " \t} else {", " \t\tfprintf(stderr, \"Hit 'h' for help\\n\\n\");", " \t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\");", " \t\tif (str) {", " \t\t\tstrncpy(the_url, \"MP4Client \"GPAC_FULL_VERSION , sizeof(the_url)-1);", " \t\t\tthe_url[sizeof(the_url) - 1] = 0;", " \t\t\tgf_term_connect(term, str);", " \t\t\tstartup_file = 1;", " \t\t\tis_connected = 1;", " \t\t}", " \t}", " \tif (gui_mode==2) gui_mode=0;", " \tif (start_fs) gf_term_set_option(term, GF_OPT_FULLSCREEN, 1);", " \tif (views) {", " \t\tchar szTemp[4046];", " \t\tsprintf(szTemp, \"views:%s\", views);", " \t\tgf_term_connect(term, szTemp);", " \t}", " \tif (mosaic) {", " \t\tchar szTemp[4046];", " \t\tsprintf(szTemp, \"mosaic:%s\", mosaic);", " \t\tgf_term_connect(term, szTemp);", " \t}", " \tif (bench_mode) {", " \t\trti_update_time_ms = 500;", " \t\tbench_mode_start = gf_sys_clock();", " \t}", " \twhile (Run) {", " \t\tif ((gui_mode==1) || !gf_prompt_has_input()) {", " \t\t\tif (reload) {", " \t\t\t\treload = 0;", " \t\t\t\tgf_term_disconnect(term);", " \t\t\t\tgf_term_connect(term, startup_file ? gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\") : the_url);", " \t\t\t}", " \t\t\tif (restart && gf_term_get_option(term, GF_OPT_IS_OVER)) {", " \t\t\t\trestart = 0;", " \t\t\t\tgf_term_play_from_time(term, 0, 0);", " \t\t\t}", " \t\t\tif (request_next_playlist_item) {", " \t\t\t\tc = '\\n';", " \t\t\t\trequest_next_playlist_item = 0;", " \t\t\t\tgoto force_input;", " \t\t\t}", " \t\t\tif (has_command && is_connected) {", " \t\t\t\thas_command = GF_FALSE;", " \t\t\t\tfor (i=0; i<(u32)argc; i++) {", " \t\t\t\t\tif (!strcmp(argv[i], \"-com\")) {", " \t\t\t\t\t\tgf_term_scene_update(term, NULL, argv[i+1]);", " \t\t\t\t\t\ti++;", " \t\t\t\t\t}", " \t\t\t\t}", " \t\t\t}", " \t\t\tif (initial_service_id && is_connected) {", " \t\t\t\tGF_ObjectManager *root_od = gf_term_get_root_object(term);", " \t\t\t\tif (root_od) {", " \t\t\t\t\tgf_term_select_service(term, root_od, initial_service_id);", " \t\t\t\t\tinitial_service_id = 0;", " \t\t\t\t}", " \t\t\t}", " \t\t\tif (!use_rtix || display_rti) UpdateRTInfo(NULL);", " \t\t\tif (term_step) {", " \t\t\t\tgf_term_process_step(term);", " \t\t\t} else {", " \t\t\t\tgf_sleep(rti_update_time_ms);", " \t\t\t}", " \t\t\tif (auto_exit && eos_seen && gf_term_get_option(term, GF_OPT_IS_OVER)) {", " \t\t\t\tRun = GF_FALSE;", " \t\t\t}", " \t\t\tif (simulation_time_in_ms", " \t\t\t        && ( (gf_term_get_elapsed_time_in_ms(term)>simulation_time_in_ms) || (!url_arg && gf_sys_clock()>simulation_time_in_ms))", " \t\t\t   ) {", " \t\t\t\tRun = GF_FALSE;", " \t\t\t}", " \t\t\tcontinue;", " \t\t}", " \t\tc = gf_prompt_get_char();", " force_input:", " \t\tswitch (c) {", " \t\tcase 'q':", " \t\t{", " \t\t\tGF_Event evt;", " \t\t\tmemset(&evt, 0, sizeof(GF_Event));", " \t\t\tevt.type = GF_EVENT_QUIT;", " \t\t\tgf_term_send_event(term, &evt);", " \t\t}", " \t\tbreak;", " \t\tcase 'X':", " \t\t\texit(0);", " \t\t\tbreak;", " \t\tcase 'Q':", " \t\t\tbreak;", " \t\tcase 'o':", " \t\t\tstartup_file = 0;", " \t\t\tgf_term_disconnect(term);", " \t\t\tfprintf(stderr, \"Enter the absolute URL\\n\");", " \t\t\tif (1 > scanf(\"%s\", the_url)) {", " \t\t\t\tfprintf(stderr, \"Cannot read absolute URL, aborting\\n\");", " \t\t\t\tbreak;", " \t\t\t}", " \t\t\tif (rti_file) init_rti_logs(rti_file, the_url, use_rtix);", " \t\t\tgf_term_connect(term, the_url);", " \t\t\tbreak;", " \t\tcase 'O':", " \t\t\tgf_term_disconnect(term);", " \t\t\tfprintf(stderr, \"Enter the absolute URL to the playlist\\n\");", " \t\t\tif (1 > scanf(\"%s\", the_url)) {", " \t\t\t\tfprintf(stderr, \"Cannot read the absolute URL, aborting.\\n\");", " \t\t\t\tbreak;", " \t\t\t}", " \t\t\tplaylist = gf_fopen(the_url, \"rt\");", " \t\t\tif (playlist) {", " \t\t\t\tif (1 >\tfscanf(playlist, \"%s\", the_url)) {", " \t\t\t\t\tfprintf(stderr, \"Cannot read any URL from playlist, aborting.\\n\");", " \t\t\t\t\tgf_fclose( playlist);", " \t\t\t\t\tbreak;", " \t\t\t\t}", " \t\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);", " \t\t\t\tgf_term_connect(term, the_url);", " \t\t\t}", " \t\t\tbreak;", " \t\tcase '\\n':", " \t\tcase 'N':", " \t\t\tif (playlist) {", " \t\t\t\tint res;", " \t\t\t\tgf_term_disconnect(term);", " \t\t\t\tres = fscanf(playlist, \"%s\", the_url);", " \t\t\t\tif ((res == EOF) && loop_at_end) {", " \t\t\t\t\tfseek(playlist, 0, SEEK_SET);", " \t\t\t\t\tres = fscanf(playlist, \"%s\", the_url);", " \t\t\t\t}", " \t\t\t\tif (res == EOF) {", " \t\t\t\t\tfprintf(stderr, \"No more items - exiting\\n\");", " \t\t\t\t\tRun = 0;", " \t\t\t\t} else if (the_url[0] == '#') {", " \t\t\t\t\trequest_next_playlist_item = GF_TRUE;", " \t\t\t\t} else {", " \t\t\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);", " \t\t\t\t\tgf_term_connect_with_path(term, the_url, pl_path);", " \t\t\t\t}", " \t\t\t}", " \t\t\tbreak;", " \t\tcase 'P':", " \t\t\tif (playlist) {", " \t\t\t\tu32 count;", " \t\t\t\tgf_term_disconnect(term);", " \t\t\t\tif (1 > scanf(\"%u\", &count)) {", " \t\t\t\t\tfprintf(stderr, \"Cannot read number, aborting.\\n\");", " \t\t\t\t\tbreak;", " \t\t\t\t}", " \t\t\t\twhile (count) {", " \t\t\t\t\tif (fscanf(playlist, \"%s\", the_url)) {", " \t\t\t\t\t\tfprintf(stderr, \"Failed to read line, aborting\\n\");", " \t\t\t\t\t\tbreak;", " \t\t\t\t\t}", " \t\t\t\t\tcount--;", " \t\t\t\t}", " \t\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);", " \t\t\t\tgf_term_connect(term, the_url);", " \t\t\t}", " \t\t\tbreak;", " \t\tcase 'r':", " \t\t\tif (is_connected)", " \t\t\t\treload = 1;", " \t\t\tbreak;", " \t\tcase 'D':", " \t\t\tif (is_connected) gf_term_disconnect(term);", " \t\t\tbreak;", " \t\tcase 'p':", " \t\t\tif (is_connected) {", " \t\t\t\tBool is_pause = gf_term_get_option(term, GF_OPT_PLAY_STATE);", " \t\t\t\tfprintf(stderr, \"[Status: %s]\\n\", is_pause ? \"Playing\" : \"Paused\");", " \t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, is_pause ? GF_STATE_PLAYING : GF_STATE_PAUSED);", " \t\t\t}", " \t\t\tbreak;", " \t\tcase 's':", " \t\t\tif (is_connected) {", " \t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_STEP_PAUSE);", " \t\t\t\tfprintf(stderr, \"Step time: \");", " \t\t\t\tPrintTime(gf_term_get_time_in_ms(term));", " \t\t\t\tfprintf(stderr, \"\\n\");", " \t\t\t}", " \t\t\tbreak;", " \t\tcase 'z':", " \t\tcase 'T':", " \t\t\tif (!CanSeek || (Duration<=2000)) {", " \t\t\t\tfprintf(stderr, \"scene not seekable\\n\");", " \t\t\t} else {", " \t\t\t\tDouble res;", " \t\t\t\ts32 seekTo;", " \t\t\t\tfprintf(stderr, \"Duration: \");", " \t\t\t\tPrintTime(Duration);", " \t\t\t\tres = gf_term_get_time_in_ms(term);", " \t\t\t\tif (c=='z') {", " \t\t\t\t\tres *= 100;", " \t\t\t\t\tres /= (s64)Duration;", " \t\t\t\t\tfprintf(stderr, \" (current %.2f %%)\\nEnter Seek percentage:\\n\", res);", " \t\t\t\t\tif (scanf(\"%d\", &seekTo) == 1) {", " \t\t\t\t\t\tif (seekTo > 100) seekTo = 100;", " \t\t\t\t\t\tres = (Double)(s64)Duration;", " \t\t\t\t\t\tres /= 100;", " \t\t\t\t\t\tres *= seekTo;", " \t\t\t\t\t\tgf_term_play_from_time(term, (u64) (s64) res, 0);", " \t\t\t\t\t}", " \t\t\t\t} else {", " \t\t\t\t\tu32 r, h, m, s;", " \t\t\t\t\tfprintf(stderr, \" - Current Time: \");", " \t\t\t\t\tPrintTime((u64) res);", " \t\t\t\t\tfprintf(stderr, \"\\nEnter seek time (Format: s, m:s or h:m:s):\\n\");", " \t\t\t\t\th = m = s = 0;", " \t\t\t\t\tr =scanf(\"%d:%d:%d\", &h, &m, &s);", " \t\t\t\t\tif (r==2) {", " \t\t\t\t\t\ts = m;", " \t\t\t\t\t\tm = h;", " \t\t\t\t\t\th = 0;", " \t\t\t\t\t}", " \t\t\t\t\telse if (r==1) {", " \t\t\t\t\t\ts = h;", " \t\t\t\t\t\tm = h = 0;", " \t\t\t\t\t}", " \t\t\t\t\tif (r && (r<=3)) {", " \t\t\t\t\t\tu64 time = h*3600 + m*60 + s;", " \t\t\t\t\t\tgf_term_play_from_time(term, time*1000, 0);", " \t\t\t\t\t}", " \t\t\t\t}", " \t\t\t}", " \t\t\tbreak;", " \t\tcase 't':", " \t\t{", " \t\t\tif (is_connected) {", " \t\t\t\tfprintf(stderr, \"Current Time: \");", " \t\t\t\tPrintTime(gf_term_get_time_in_ms(term));", " \t\t\t\tfprintf(stderr, \" - Duration: \");", " \t\t\t\tPrintTime(Duration);", " \t\t\t\tfprintf(stderr, \"\\n\");", " \t\t\t}", " \t\t}", " \t\tbreak;", " \t\tcase 'w':", " \t\t\tif (is_connected) PrintWorldInfo(term);", " \t\t\tbreak;", " \t\tcase 'v':", " \t\t\tif (is_connected) PrintODList(term, NULL, 0, 0, \"Root\");", " \t\t\tbreak;", " \t\tcase 'i':", " \t\t\tif (is_connected) {", " \t\t\t\tu32 ID;", " \t\t\t\tfprintf(stderr, \"Enter OD ID (0 for main OD): \");", " \t\t\t\tfflush(stderr);", " \t\t\t\tif (scanf(\"%ud\", &ID) == 1) {", " \t\t\t\t\tViewOD(term, ID, (u32)-1, NULL);", " \t\t\t\t} else {", " \t\t\t\t\tchar str_url[GF_MAX_PATH];", " \t\t\t\t\tif (scanf(\"%s\", str_url) == 1)", " \t\t\t\t\t\tViewOD(term, 0, (u32)-1, str_url);", " \t\t\t\t}", " \t\t\t}", " \t\t\tbreak;", " \t\tcase 'j':", " \t\t\tif (is_connected) {", " \t\t\t\tu32 num;", " \t\t\t\tdo {", " \t\t\t\t\tfprintf(stderr, \"Enter OD number (0 for main OD): \");", " \t\t\t\t\tfflush(stderr);", " \t\t\t\t} while( 1 > scanf(\"%ud\", &num));", " \t\t\t\tViewOD(term, (u32)-1, num, NULL);", " \t\t\t}", " \t\t\tbreak;", " \t\tcase 'b':", " \t\t\tif (is_connected) ViewODs(term, 1);", " \t\t\tbreak;", " \t\tcase 'm':", " \t\t\tif (is_connected) ViewODs(term, 0);", " \t\t\tbreak;", " \t\tcase 'l':", " \t\t\tlist_modules(user.modules);", " \t\t\tbreak;", " \t\tcase 'n':", " \t\t\tif (is_connected) set_navigation();", " \t\t\tbreak;", " \t\tcase 'x':", " \t\t\tif (is_connected) gf_term_set_option(term, GF_OPT_NAVIGATION_TYPE, 0);", " \t\t\tbreak;", " \t\tcase 'd':", " \t\t\tif (is_connected) {", " \t\t\t\tGF_ObjectManager *odm = NULL;", " \t\t\t\tchar radname[GF_MAX_PATH], *sExt;", " \t\t\t\tGF_Err e;", " \t\t\t\tu32 i, count, odid;", " \t\t\t\tBool xml_dump, std_out;", " \t\t\t\tradname[0] = 0;", " \t\t\t\tdo {", " \t\t\t\t\tfprintf(stderr, \"Enter Inline OD ID if any or 0 : \");", " \t\t\t\t\tfflush(stderr);", " \t\t\t\t} while( 1 >  scanf(\"%ud\", &odid));", " \t\t\t\tif (odid) {", " \t\t\t\t\tGF_ObjectManager *root_odm = gf_term_get_root_object(term);", " \t\t\t\t\tif (!root_odm) break;", " \t\t\t\t\tcount = gf_term_get_object_count(term, root_odm);", " \t\t\t\t\tfor (i=0; i<count; i++) {", " \t\t\t\t\t\tGF_MediaInfo info;", " \t\t\t\t\t\todm = gf_term_get_object(term, root_odm, i);", " \t\t\t\t\t\tif (gf_term_get_object_info(term, odm, &info) == GF_OK) {", " \t\t\t\t\t\t\tif (info.od->objectDescriptorID==odid) break;", " \t\t\t\t\t\t}", " \t\t\t\t\t\todm = NULL;", " \t\t\t\t\t}", " \t\t\t\t}", " \t\t\t\tdo {", " \t\t\t\t\tfprintf(stderr, \"Enter file radical name (+\\'.x\\' for XML dumping) - \\\"std\\\" for stderr: \");", " \t\t\t\t\tfflush(stderr);", " \t\t\t\t} while( 1 > scanf(\"%s\", radname));", " \t\t\t\tsExt = strrchr(radname, '.');", " \t\t\t\txml_dump = 0;", " \t\t\t\tif (sExt) {", " \t\t\t\t\tif (!stricmp(sExt, \".x\")) xml_dump = 1;", " \t\t\t\t\tsExt[0] = 0;", " \t\t\t\t}", " \t\t\t\tstd_out = strnicmp(radname, \"std\", 3) ? 0 : 1;", " \t\t\t\te = gf_term_dump_scene(term, std_out ? NULL : radname, NULL, xml_dump, 0, odm);", " \t\t\t\tfprintf(stderr, \"Dump done (%s)\\n\", gf_error_to_string(e));", " \t\t\t}", " \t\t\tbreak;", " \t\tcase 'c':", " \t\t\tPrintGPACConfig();", " \t\t\tbreak;", " \t\tcase '3':", " \t\t{", " \t\t\tBool use_3d = !gf_term_get_option(term, GF_OPT_USE_OPENGL);", " \t\t\tif (gf_term_set_option(term, GF_OPT_USE_OPENGL, use_3d)==GF_OK) {", " \t\t\t\tfprintf(stderr, \"Using %s for 2D drawing\\n\", use_3d ? \"OpenGL\" : \"2D rasterizer\");", " \t\t\t}", " \t\t}", " \t\tbreak;", " \t\tcase 'k':", " \t\t{", " \t\t\tBool opt = gf_term_get_option(term, GF_OPT_STRESS_MODE);", " \t\t\topt = !opt;", " \t\t\tfprintf(stderr, \"Turning stress mode %s\\n\", opt ? \"on\" : \"off\");", " \t\t\tgf_term_set_option(term, GF_OPT_STRESS_MODE, opt);", " \t\t}", " \t\tbreak;", " \t\tcase '4':", " \t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_4_3);", " \t\t\tbreak;", " \t\tcase '5':", " \t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_16_9);", " \t\t\tbreak;", " \t\tcase '6':", " \t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);", " \t\t\tbreak;", " \t\tcase '7':", " \t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_KEEP);", " \t\t\tbreak;", " \t\tcase 'C':", " \t\t\tswitch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {", " \t\t\tcase GF_MEDIA_CACHE_DISABLED:", " \t\t\t\tgf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_ENABLED);", " \t\t\t\tbreak;", " \t\t\tcase GF_MEDIA_CACHE_ENABLED:", " \t\t\t\tgf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_DISABLED);", " \t\t\t\tbreak;", " \t\t\tcase GF_MEDIA_CACHE_RUNNING:", " \t\t\t\tfprintf(stderr, \"Streaming Cache is running - please stop it first\\n\");", " \t\t\t\tcontinue;", " \t\t\t}", " \t\t\tswitch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {", " \t\t\tcase GF_MEDIA_CACHE_ENABLED:", " \t\t\t\tfprintf(stderr, \"Streaming Cache Enabled\\n\");", " \t\t\t\tbreak;", " \t\t\tcase GF_MEDIA_CACHE_DISABLED:", " \t\t\t\tfprintf(stderr, \"Streaming Cache Disabled\\n\");", " \t\t\t\tbreak;", " \t\t\tcase GF_MEDIA_CACHE_RUNNING:", " \t\t\t\tfprintf(stderr, \"Streaming Cache Running\\n\");", " \t\t\t\tbreak;", " \t\t\t}", " \t\t\tbreak;", " \t\tcase 'S':", " \t\tcase 'A':", " \t\t\tif (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)==GF_MEDIA_CACHE_RUNNING) {", " \t\t\t\tgf_term_set_option(term, GF_OPT_MEDIA_CACHE, (c=='S') ? GF_MEDIA_CACHE_DISABLED : GF_MEDIA_CACHE_DISCARD);", " \t\t\t\tfprintf(stderr, \"Streaming Cache stopped\\n\");", " \t\t\t} else {", " \t\t\t\tfprintf(stderr, \"Streaming Cache not running\\n\");", " \t\t\t}", " \t\t\tbreak;", " \t\tcase 'R':", " \t\t\tdisplay_rti = !display_rti;", " \t\t\tResetCaption();", " \t\t\tbreak;", " \t\tcase 'F':", " \t\t\tif (display_rti) display_rti = 0;", " \t\t\telse display_rti = 2;", " \t\t\tResetCaption();", " \t\t\tbreak;", " \t\tcase 'u':", " \t\t{", " \t\t\tGF_Err e;", " \t\t\tchar szCom[8192];", " \t\t\tfprintf(stderr, \"Enter command to send:\\n\");", " \t\t\tfflush(stdin);", " \t\t\tszCom[0] = 0;", " \t\t\tif (1 > scanf(\"%[^\\t\\n]\", szCom)) {", " \t\t\t\tfprintf(stderr, \"Cannot read command to send, aborting.\\n\");", " \t\t\t\tbreak;", " \t\t\t}", " \t\t\te = gf_term_scene_update(term, NULL, szCom);", " \t\t\tif (e) fprintf(stderr, \"Processing command failed: %s\\n\", gf_error_to_string(e));", " \t\t}", " \t\tbreak;", " \t\tcase 'e':", " \t\t{", " \t\t\tGF_Err e;", " \t\t\tchar jsCode[8192];", " \t\t\tfprintf(stderr, \"Enter JavaScript code to evaluate:\\n\");", " \t\t\tfflush(stdin);", " \t\t\tjsCode[0] = 0;", " \t\t\tif (1 > scanf(\"%[^\\t\\n]\", jsCode)) {", " \t\t\t\tfprintf(stderr, \"Cannot read code to evaluate, aborting.\\n\");", " \t\t\t\tbreak;", " \t\t\t}", " \t\t\te = gf_term_scene_update(term, \"application/ecmascript\", jsCode);", " \t\t\tif (e) fprintf(stderr, \"Processing JS code failed: %s\\n\", gf_error_to_string(e));", " \t\t}", " \t\tbreak;", " \t\tcase 'L':", " \t\t{", " \t\t\tchar szLog[1024], *cur_logs;", " \t\t\tcur_logs = gf_log_get_tools_levels();", " \t\t\tfprintf(stderr, \"Enter new log level (current tools %s):\\n\", cur_logs);", " \t\t\tgf_free(cur_logs);", " \t\t\tif (scanf(\"%s\", szLog) < 1) {", " \t\t\t\tfprintf(stderr, \"Cannot read new log level, aborting.\\n\");", " \t\t\t\tbreak;", " \t\t\t}", " \t\t\tgf_log_modify_tools_levels(szLog);", " \t\t}", " \t\tbreak;", " \t\tcase 'g':", " \t\t{", " \t\t\tGF_SystemRTInfo rti;", " \t\t\tgf_sys_get_rti(rti_update_time_ms, &rti, 0);", " \t\t\tfprintf(stderr, \"GPAC allocated memory \"LLD\"\\n\", rti.gpac_memory);", " \t\t}", " \t\tbreak;", " \t\tcase 'M':", " \t\t{", " \t\t\tu32 size;", " \t\t\tdo {", " \t\t\t\tfprintf(stderr, \"Enter new video cache memory in kBytes (current %ud):\\n\", gf_term_get_option(term, GF_OPT_VIDEO_CACHE_SIZE));", " \t\t\t} while (1 > scanf(\"%ud\", &size));", " \t\t\tgf_term_set_option(term, GF_OPT_VIDEO_CACHE_SIZE, size);", " \t\t}", " \t\tbreak;", " \t\tcase 'H':", " \t\t{", " \t\t\tu32 http_bitrate = gf_term_get_option(term, GF_OPT_HTTP_MAX_RATE);", " \t\t\tdo {", " \t\t\t\tfprintf(stderr, \"Enter new http bitrate in bps (0 for none) - current limit: %d\\n\", http_bitrate);", " \t\t\t} while (1 > scanf(\"%ud\", &http_bitrate));", " \t\t\tgf_term_set_option(term, GF_OPT_HTTP_MAX_RATE, http_bitrate);", " \t\t}", " \t\tbreak;", " \t\tcase 'E':", " \t\t\tgf_term_set_option(term, GF_OPT_RELOAD_CONFIG, 1);", " \t\t\tbreak;", " \t\tcase 'B':", " \t\t\tswitch_bench(!bench_mode);", " \t\t\tbreak;", " \t\tcase 'Y':", " \t\t{", " \t\t\tchar szOpt[8192];", " \t\t\tfprintf(stderr, \"Enter option to set (Section:Name=Value):\\n\");", " \t\t\tfflush(stdin);", " \t\t\tszOpt[0] = 0;", " \t\t\tif (1 > scanf(\"%[^\\t\\n]\", szOpt)) {", " \t\t\t\tfprintf(stderr, \"Cannot read option\\n\");", " \t\t\t\tbreak;", " \t\t\t}", " \t\t\tset_cfg_option(szOpt);", " \t\t}", " \t\tbreak;", " \t\tcase 'Z':", " \t\t{", " \t\t\tchar szFileName[100];", " \t\t\tu32 nb_pass, nb_views, offscreen_view = 0;", " \t\t\tGF_VideoSurface fb;", " \t\t\tGF_Err e;", " \t\t\tnb_pass = 1;", " \t\t\tnb_views = gf_term_get_option(term, GF_OPT_NUM_STEREO_VIEWS);", " \t\t\tif (nb_views>1) {", " \t\t\t\tfprintf(stderr, \"Auto-stereo mode detected - type number of view to dump (0 is main output, 1 to %d offscreen view, %d for all offscreen, %d for all offscreen and main)\\n\", nb_views, nb_views+1, nb_views+2);", " \t\t\t\tif (scanf(\"%d\", &offscreen_view) != 1) {", " \t\t\t\t\toffscreen_view = 0;", " \t\t\t\t}", " \t\t\t\tif (offscreen_view==nb_views+1) {", " \t\t\t\t\toffscreen_view = 1;", " \t\t\t\t\tnb_pass = nb_views;", " \t\t\t\t}", " \t\t\t\telse if (offscreen_view==nb_views+2) {", " \t\t\t\t\toffscreen_view = 0;", " \t\t\t\t\tnb_pass = nb_views+1;", " \t\t\t\t}", " \t\t\t}", " \t\t\twhile (nb_pass) {", " \t\t\t\tnb_pass--;", " \t\t\t\tif (offscreen_view) {", " \t\t\t\t\tsprintf(szFileName, \"view%d_dump.png\", offscreen_view);", " \t\t\t\t\te = gf_term_get_offscreen_buffer(term, &fb, offscreen_view-1, 0);", " \t\t\t\t} else {", " \t\t\t\t\tsprintf(szFileName, \"gpac_video_dump_\"LLU\".png\", gf_net_get_utc() );", " \t\t\t\t\te = gf_term_get_screen_buffer(term, &fb);", " \t\t\t\t}", " \t\t\t\toffscreen_view++;", " \t\t\t\tif (e) {", " \t\t\t\t\tfprintf(stderr, \"Error dumping screen buffer %s\\n\", gf_error_to_string(e) );", " \t\t\t\t\tnb_pass = 0;", " \t\t\t\t} else {", " #ifndef GPAC_DISABLE_AV_PARSERS", " \t\t\t\t\tu32 dst_size = fb.width*fb.height*4;", " \t\t\t\t\tchar *dst = (char*)gf_malloc(sizeof(char)*dst_size);", " \t\t\t\t\te = gf_img_png_enc(fb.video_buffer, fb.width, fb.height, fb.pitch_y, fb.pixel_format, dst, &dst_size);", " \t\t\t\t\tif (e) {", " \t\t\t\t\t\tfprintf(stderr, \"Error encoding PNG %s\\n\", gf_error_to_string(e) );", " \t\t\t\t\t\tnb_pass = 0;", " \t\t\t\t\t} else {", " \t\t\t\t\t\tFILE *png = gf_fopen(szFileName, \"wb\");", " \t\t\t\t\t\tif (!png) {", " \t\t\t\t\t\t\tfprintf(stderr, \"Error writing file %s\\n\", szFileName);", " \t\t\t\t\t\t\tnb_pass = 0;", " \t\t\t\t\t\t} else {", " \t\t\t\t\t\t\tgf_fwrite(dst, dst_size, 1, png);", " \t\t\t\t\t\t\tgf_fclose(png);", " \t\t\t\t\t\t\tfprintf(stderr, \"Dump to %s\\n\", szFileName);", " \t\t\t\t\t\t}", " \t\t\t\t\t}", " \t\t\t\t\tif (dst) gf_free(dst);", " \t\t\t\t\tgf_term_release_screen_buffer(term, &fb);", " #endif  ", " \t\t\t\t}", " \t\t\t}", " \t\t\tfprintf(stderr, \"Done: %s\\n\", szFileName);", " \t\t}", " \t\tbreak;", " \t\tcase 'G':", " \t\t{", " \t\t\tGF_ObjectManager *root_od, *odm;", " \t\t\tu32 index;", " \t\t\tchar szOpt[8192];", " \t\t\tfprintf(stderr, \"Enter 0-based index of object to select or service ID:\\n\");", " \t\t\tfflush(stdin);", " \t\t\tszOpt[0] = 0;", " \t\t\tif (1 > scanf(\"%[^\\t\\n]\", szOpt)) {", " \t\t\t\tfprintf(stderr, \"Cannot read OD ID\\n\");", " \t\t\t\tbreak;", " \t\t\t}", " \t\t\tindex = atoi(szOpt);", " \t\t\todm = NULL;", " \t\t\troot_od = gf_term_get_root_object(term);", " \t\t\tif (root_od) {", " \t\t\t\tif ( gf_term_find_service(term, root_od, index)) {", " \t\t\t\t\tgf_term_select_service(term, root_od, index);", " \t\t\t\t} else {", " \t\t\t\t\tfprintf(stderr, \"Cannot find service %d - trying with object index\\n\", index);", " \t\t\t\t\todm = gf_term_get_object(term, root_od, index);", " \t\t\t\t\tif (odm) {", " \t\t\t\t\t\tgf_term_select_object(term, odm);", " \t\t\t\t\t} else {", " \t\t\t\t\t\tfprintf(stderr, \"Cannot find object at index %d\\n\", index);", " \t\t\t\t\t}", " \t\t\t\t}", " \t\t\t}", " \t\t}", " \t\tbreak;", " \t\tcase 'h':", " \t\t\tPrintHelp();", " \t\t\tbreak;", " \t\tdefault:", " \t\t\tbreak;", " \t\t}", " \t}", " \tif (bench_mode) {", " \t\tPrintAVInfo(GF_TRUE);", " \t}", " \tif (simulation_time_in_ms) {", " \t\tgf_log_set_strict_error(0);", " \t}", " \ti = gf_sys_clock();", " \tgf_term_disconnect(term);", " \tif (rti_file) UpdateRTInfo(\"Disconnected\\n\");", " \tfprintf(stderr, \"Deleting terminal... \");", " \tif (playlist) gf_fclose(playlist);", " #if defined(__DARWIN__) || defined(__APPLE__)", " \tcarbon_uninit();", " #endif", " \tgf_term_del(term);", " \tfprintf(stderr, \"done (in %d ms) - ran for %d ms\\n\", gf_sys_clock() - i, gf_sys_clock());", " \tfprintf(stderr, \"GPAC cleanup ...\\n\");", " \tgf_modules_del(user.modules);", " \tif (no_cfg_save)", " \t\tgf_cfg_discard_changes(cfg_file);", " \tgf_cfg_del(cfg_file);", " \tgf_sys_close();", " \tif (rti_logs) gf_fclose(rti_logs);", " \tif (logfile) gf_fclose(logfile);", " \tif (gui_mode) {", " \t\thide_shell(2);", " \t}", " #ifdef GPAC_MEMORY_TRACKING", " \tif (mem_track && (gf_memory_size() || gf_file_handles_count() )) {", " \t        gf_log_set_tool_level(GF_LOG_MEMORY, GF_LOG_INFO);", " \t\tgf_memory_print();", " \t\treturn 2;", " \t}", " #endif", " \treturn ret_val;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" rdpsnd_process_training(STREAM in)", " {", "  \tuint16 tick;", "  \tuint16 packsize;", "  \tSTREAM out;", " \tstruct stream packet = *in;", " \tif (!s_check_rem(in, 4))", " \t{", " \t\trdp_protocol_error(\"rdpsnd_process_training(), consume of training data from stream would overrun\", &packet);", " \t}", "  \tin_uint16_le(in, tick);", "  \tin_uint16_le(in, packsize);", " \tlogger(Sound, Debug, \"rdpsnd_process_training(), tick=0x%04x\", (unsigned) tick);", " \tout = rdpsnd_init_packet(SNDC_TRAINING, 4);", " \tout_uint16_le(out, tick);", " \tout_uint16_le(out, packsize);", " \ts_mark_end(out);", " \trdpsnd_send(out);", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void set_cfg_option(char *opt_string)", " {", " \tchar *sep, *sep2, szSec[1024], szKey[1024], szVal[1024];", " \tsep = strchr(opt_string, ':');", " \tif (!sep) {", " \t\tfprintf(stderr, \"Badly formatted option %s - expected Section:Name=Value\\n\", opt_string);", " \t\treturn;", "  \t}", "  \t{", "  \t\tconst size_t sepIdx = sep - opt_string;", " \t\tif (sepIdx >= sizeof(szSec)) {", " \t\t\tfprintf(stderr, \"Badly formatted option %s - Section name is too long\\n\", opt_string);", " \t\t\treturn;", " \t\t}", "  \t\tstrncpy(szSec, opt_string, sepIdx);", "  \t\tszSec[sepIdx] = 0;", "  \t}", " \tsep ++;", " \tsep2 = strchr(sep, '=');", " \tif (!sep2) {", " \t\tfprintf(stderr, \"Badly formatted option %s - expected Section:Name=Value\\n\", opt_string);", " \t\treturn;", "  \t}", "  \t{", "  \t\tconst size_t sepIdx = sep2 - sep;", " \t\tif (sepIdx >= sizeof(szKey)) {", " \t\t\tfprintf(stderr, \"Badly formatted option %s - key name is too long\\n\", opt_string);", " \t\t\treturn;", " \t\t}", "  \t\tstrncpy(szKey, sep, sepIdx);", "  \t\tszKey[sepIdx] = 0;", " \t\tif (strlen(sep2 + 1) >= sizeof(szVal)) {", " \t\t\tfprintf(stderr, \"Badly formatted option %s - value is too long\\n\", opt_string);", " \t\t\treturn;", " \t\t}", "  \t\tstrcpy(szVal, sep2+1);", "  \t}", " \tif (!stricmp(szKey, \"*\")) {", " \t\tif (stricmp(szVal, \"null\")) {", " \t\t\tfprintf(stderr, \"Badly formatted option %s - expected Section:*=null\\n\", opt_string);", " \t\t\treturn;", " \t\t}", " \t\tgf_cfg_del_section(cfg_file, szSec);", " \t\treturn;", " \t}", " \tif (!stricmp(szVal, \"null\")) {", " \t\tszVal[0]=0;", " \t}", " \tgf_cfg_set_key(cfg_file, szSec, szKey, szVal[0] ? szVal : NULL);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static __forceinline void draw_line(float *output, int x0, int y0, int x1, int y1, int n)", " {", "    int dy = y1 - y0;", "    int adx = x1 - x0;", "    int ady = abs(dy);", "    int base;", "    int x=x0,y=y0;", "    int err = 0;", "    int sy;", " #ifdef STB_VORBIS_DIVIDE_TABLE", "    if (adx < DIVTAB_DENOM && ady < DIVTAB_NUMER) {", "       if (dy < 0) {", "          base = -integer_divide_table[ady][adx];", "          sy = base-1;", "       } else {", "          base =  integer_divide_table[ady][adx];", "          sy = base+1;", "       }", "    } else {", "       base = dy / adx;", "       if (dy < 0)", "          sy = base - 1;", "       else", "          sy = base+1;", "    }", " #else", "    base = dy / adx;", "    if (dy < 0)", "       sy = base - 1;", "    else", "       sy = base+1;", " #endif", "     ady -= abs(base) * adx;", "     if (x1 > n) x1 = n;", "     if (x < x1) {", "      LINE_OP(output[x], inverse_db_table[y]);", "       LINE_OP(output[x], inverse_db_table[y&255]);", "        for (++x; x < x1; ++x) {", "           err += ady;", "           if (err >= adx) {", "              err -= adx;", "              y += sy;", "           } else", "              y += base;", "         LINE_OP(output[x], inverse_db_table[y]);", "          LINE_OP(output[x], inverse_db_table[y&255]);", "        }", "     }", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0]}
{"tokens": [" Status XvMCGetDRInfo(Display *dpy, XvPortID port,", " \t\t     char **name, char **busID,", " \t\t     int *major, int *minor,", " \t\t     int *patchLevel,", " \t\t     int *isLocal)", " {", "     XExtDisplayInfo *info = xvmc_find_display(dpy);", "     xvmcGetDRInfoReply rep;", "     xvmcGetDRInfoReq  *req;", "     CARD32 magic;", " #ifdef HAVE_SHMAT", "     volatile CARD32 *shMem;", "     struct timezone here;", "     struct timeval now;", "     here.tz_minuteswest = 0;", "     here.tz_dsttime = 0;", " #endif", "     *name = NULL;", "     *busID = NULL;", "     XvMCCheckExtension (dpy, info, BadImplementation);", "     LockDisplay (dpy);", "     XvMCGetReq (GetDRInfo, req);", "     req->port = port;", "     magic = 0;", "     req->magic = 0;", " #ifdef HAVE_SHMAT", "     req->shmKey = shmget(IPC_PRIVATE, 1024, IPC_CREAT | 0600);", "     if (req->shmKey >= 0) {", " \tshMem = (CARD32 *) shmat(req->shmKey, NULL, 0);", " \tshmctl( req->shmKey, IPC_RMID, NULL);", " \tif ( shMem ) {", " \t    register volatile CARD32 *shMemC = shMem;", " \t    register int i;", " \t    gettimeofday( &now, &here);", " \t    magic = now.tv_usec & 0x000FFFFF;", " \t    req->magic = magic;", " \t    i = 1024 / sizeof(CARD32);", " \t    while(i--) {", " \t        *shMemC++ = magic;", " \t        magic = ~magic;", " \t    }", " \t} else {", " \t    req->shmKey = -1;", " \t}", "     }", " #else", "     req->shmKey = 0;", " #endif", "     if (!_XReply (dpy, (xReply *) &rep, 0, xFalse)) {", "         UnlockDisplay (dpy);", "         SyncHandle ();", " #ifdef HAVE_SHMAT", " \tif ( req->shmKey >= 0) {", " \t    shmdt( (const void *) shMem );", " \t}", " #endif", "         return -1;", "     }", " #ifdef HAVE_SHMAT", "     shmdt( (const void *) shMem );", " #endif", "     if (rep.length > 0) {", " \tunsigned long realSize = 0;", " \tchar *tmpBuf = NULL;", " \tif ((rep.length < (INT_MAX >> 2)) &&", " \t    (rep.nameLen + rep.busIDLen > rep.nameLen)) {", " \t    realSize = rep.length << 2;", " \t    if (realSize >= (rep.nameLen + rep.busIDLen)) {", " \t\ttmpBuf = Xmalloc(realSize);", " \t\t*name = Xmalloc(rep.nameLen);", " \t\t*busID = Xmalloc(rep.busIDLen);", " \t    }", " \t}", "  \tif (*name && *busID && tmpBuf) {", "  \t    _XRead(dpy, tmpBuf, realSize);", "  \t    strncpy(*name,tmpBuf,rep.nameLen);", "\t    (*name)[rep.nameLen - 1] = '\\0';", " \t    (*name)[rep.nameLen == 0 ? 0 : rep.nameLen - 1] = '\\0';", "  \t    strncpy(*busID,tmpBuf+rep.nameLen,rep.busIDLen);", "\t    (*busID)[rep.busIDLen - 1] = '\\0';", " \t    (*busID)[rep.busIDLen == 0 ? 0 : rep.busIDLen - 1] = '\\0';", "  \t    XFree(tmpBuf);", "  \t} else {", "  \t    XFree(*name);", " \t    *name = NULL;", " \t    XFree(*busID);", " \t    *busID = NULL;", " \t    XFree(tmpBuf);", " \t    _XEatDataWords(dpy, rep.length);", " \t    UnlockDisplay (dpy);", " \t    SyncHandle ();", " \t    return -1;", " \t}", "     }", "     UnlockDisplay (dpy);", "     SyncHandle ();", "     *major = rep.major;", "     *minor = rep.minor;", "     *patchLevel = rep.patchLevel;", "     *isLocal = (req->shmKey > 0) ? rep.isLocal : 1;", "     return (rep.length > 0) ? Success : BadImplementation;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int decode_cblk(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *codsty,", "                        Jpeg2000T1Context *t1, Jpeg2000Cblk *cblk,", "                        int width, int height, int bandpos)", " {", "     int passno = cblk->npasses, pass_t = 2, bpno = cblk->nonzerobits - 1, y;", "     int clnpass_cnt = 0;", "      int bpass_csty_symbol           = codsty->cblk_style & JPEG2000_CBLK_BYPASS;", "      int vert_causal_ctx_csty_symbol = codsty->cblk_style & JPEG2000_CBLK_VSC;", "     av_assert0(width  <= JPEG2000_MAX_CBLKW);", "     av_assert0(height <= JPEG2000_MAX_CBLKH);", "      for (y = 0; y < height; y++)", "          memset(t1->data[y], 0, width * sizeof(**t1->data));", "     if (!cblk->length)", "         return 0;", "     for (y = 0; y < height + 2; y++)", "         memset(t1->flags[y], 0, (width + 2) * sizeof(**t1->flags));", "     cblk->data[cblk->length] = 0xff;", "     cblk->data[cblk->length+1] = 0xff;", "     ff_mqc_initdec(&t1->mqc, cblk->data);", "     while (passno--) {", "         switch(pass_t) {", "         case 0:", "             decode_sigpass(t1, width, height, bpno + 1, bandpos,", "                            bpass_csty_symbol && (clnpass_cnt >= 4),", "                            vert_causal_ctx_csty_symbol);", "             break;", "         case 1:", "             decode_refpass(t1, width, height, bpno + 1);", "             if (bpass_csty_symbol && clnpass_cnt >= 4)", "                 ff_mqc_initdec(&t1->mqc, cblk->data);", "             break;", "         case 2:", "             decode_clnpass(s, t1, width, height, bpno + 1, bandpos,", "                            codsty->cblk_style & JPEG2000_CBLK_SEGSYM,", "                            vert_causal_ctx_csty_symbol);", "             clnpass_cnt = clnpass_cnt + 1;", "             if (bpass_csty_symbol && clnpass_cnt >= 4)", "                 ff_mqc_initdec(&t1->mqc, cblk->data);", "             break;", "         }", "         pass_t++;", "         if (pass_t == 3) {", "             bpno--;", "             pass_t = 0;", "         }", "     }", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" prologProcessor(XML_Parser parser, const char *s, const char *end,", "                 const char **nextPtr) {", "    const char *next = s;", "    int tok = XmlPrologTok(parser->m_encoding, s, end, &next);", "    return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,", "                  (XML_Bool)! parser->m_parsingStatus.finalBuffer);", "                   (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 0]}
{"tokens": ["  flac_read_loop (SF_PRIVATE *psf, unsigned len)", "  {\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;", " \tFLAC__StreamDecoderState state ;", "  \tpflac->pos = 0 ;", "  \tpflac->len = len ;", "  \tpflac->remain = len ;", " \tstate = FLAC__stream_decoder_get_state (pflac->fsd) ;", " \tif (state > FLAC__STREAM_DECODER_END_OF_STREAM)", " \t{\tpsf_log_printf (psf, \"FLAC__stream_decoder_get_state returned %s\\n\", FLAC__StreamDecoderStateString [state]) ;", " \t\tpflac->frame = NULL ;", " \t\t} ;", "  \tif (pflac->frame != NULL && pflac->bufferpos < pflac->frame->header.blocksize)", "  \t\tflac_buffer_copy (psf) ;", "  \twhile (pflac->pos < pflac->len)", "  \t{\tif (FLAC__stream_decoder_process_single (pflac->fsd) == 0)", "  \t\t\tbreak ;", "\t\tif (FLAC__stream_decoder_get_state (pflac->fsd) >= FLAC__STREAM_DECODER_END_OF_STREAM)", " \t\tstate = FLAC__stream_decoder_get_state (pflac->fsd) ;", " \t\tif (state >= FLAC__STREAM_DECODER_END_OF_STREAM)", " \t\t{\tpsf_log_printf (psf, \"FLAC__stream_decoder_get_state returned %s\\n\", FLAC__StreamDecoderStateString [state]) ;", " \t\t\tpflac->frame = NULL ;", "  \t\t\tbreak ;", " \t\t\t} ;", "  \t\t} ;", "  \tpflac->ptr = NULL ;", " \treturn pflac->pos ;", " }  "], "ner_tags": [0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0]}
{"tokens": [" int yr_execute_code(", "     YR_RULES* rules,", "     YR_SCAN_CONTEXT* context,", "     int timeout,", "     time_t start_time)", " {", "   int64_t mem[MEM_SIZE];", "   int32_t sp = 0;", "   uint8_t* ip = rules->code_start;", "   YR_VALUE args[MAX_FUNCTION_ARGS];", "   YR_VALUE *stack;", "   YR_VALUE r1;", "   YR_VALUE r2;", "   YR_VALUE r3;", "   #ifdef PROFILING_ENABLED", "   YR_RULE* current_rule = NULL;", "   #endif", "   YR_RULE* rule;", "   YR_MATCH* match;", "   YR_OBJECT_FUNCTION* function;", "   char* identifier;", "   char* args_fmt;", "   int i;", "   int found;", "   int count;", "   int result = ERROR_SUCCESS;", "   int stop = FALSE;", "   int cycle = 0;", "   int tidx = context->tidx;", "   int stack_size;", "   #ifdef PROFILING_ENABLED", "   clock_t start = clock();", "   #endif", "   yr_get_configuration(YR_CONFIG_STACK_SIZE, (void*) &stack_size);", "   stack = (YR_VALUE*) yr_malloc(stack_size * sizeof(YR_VALUE));", "   if (stack == NULL)", "     return ERROR_INSUFFICIENT_MEMORY;", "   while(!stop)", "   {", "     switch(*ip)", "     {", "       case OP_HALT:", "         assert(sp == 0);  ", "         stop = TRUE;", "         break;", "       case OP_PUSH:", "         r1.i = *(uint64_t*)(ip + 1);", "         ip += sizeof(uint64_t);", "         push(r1);", "         break;", "       case OP_POP:", "         pop(r1);", "         break;", "       case OP_CLEAR_M:", "         r1.i = *(uint64_t*)(ip + 1);", "         ip += sizeof(uint64_t);", "         mem[r1.i] = 0;", "         break;", "       case OP_ADD_M:", "         r1.i = *(uint64_t*)(ip + 1);", "         ip += sizeof(uint64_t);", "         pop(r2);", "         if (!is_undef(r2))", "           mem[r1.i] += r2.i;", "         break;", "       case OP_INCR_M:", "         r1.i = *(uint64_t*)(ip + 1);", "         ip += sizeof(uint64_t);", "         mem[r1.i]++;", "         break;", "       case OP_PUSH_M:", "         r1.i = *(uint64_t*)(ip + 1);", "         ip += sizeof(uint64_t);", "         r1.i = mem[r1.i];", "         push(r1);", "         break;", "       case OP_POP_M:", "         r1.i = *(uint64_t*)(ip + 1);", "         ip += sizeof(uint64_t);", "         pop(r2);", "         mem[r1.i] = r2.i;", "         break;", "       case OP_SWAPUNDEF:", "         r1.i = *(uint64_t*)(ip + 1);", "         ip += sizeof(uint64_t);", "         pop(r2);", "         if (is_undef(r2))", "         {", "           r1.i = mem[r1.i];", "           push(r1);", "         }", "         else", "         {", "           push(r2);", "         }", "         break;", "       case OP_JNUNDEF:", "         pop(r1);", "         push(r1);", "         ip = jmp_if(!is_undef(r1), ip);", "         break;", "       case OP_JLE:", "         pop(r2);", "         pop(r1);", "         push(r1);", "         push(r2);", "         ip = jmp_if(r1.i <= r2.i, ip);", "         break;", "       case OP_JTRUE:", "         pop(r1);", "         push(r1);", "         ip = jmp_if(!is_undef(r1) && r1.i, ip);", "         break;", "       case OP_JFALSE:", "         pop(r1);", "         push(r1);", "         ip = jmp_if(is_undef(r1) || !r1.i, ip);", "         break;", "       case OP_AND:", "         pop(r2);", "         pop(r1);", "         if (is_undef(r1) || is_undef(r2))", "           r1.i = 0;", "         else", "           r1.i = r1.i && r2.i;", "         push(r1);", "         break;", "       case OP_OR:", "         pop(r2);", "         pop(r1);", "         if (is_undef(r1))", "         {", "           push(r2);", "         }", "         else if (is_undef(r2))", "         {", "           push(r1);", "         }", "         else", "         {", "           r1.i = r1.i || r2.i;", "           push(r1);", "         }", "         break;", "       case OP_NOT:", "         pop(r1);", "         if (is_undef(r1))", "           r1.i = UNDEFINED;", "         else", "           r1.i= !r1.i;", "         push(r1);", "         break;", "       case OP_MOD:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         if (r2.i != 0)", "           r1.i = r1.i % r2.i;", "         else", "           r1.i = UNDEFINED;", "         push(r1);", "         break;", "       case OP_SHR:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.i = r1.i >> r2.i;", "         push(r1);", "         break;", "       case OP_SHL:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.i = r1.i << r2.i;", "         push(r1);", "         break;", "       case OP_BITWISE_NOT:", "         pop(r1);", "         ensure_defined(r1);", "         r1.i = ~r1.i;", "         push(r1);", "         break;", "       case OP_BITWISE_AND:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.i = r1.i & r2.i;", "         push(r1);", "         break;", "       case OP_BITWISE_OR:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.i = r1.i | r2.i;", "         push(r1);", "         break;", "       case OP_BITWISE_XOR:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.i = r1.i ^ r2.i;", "         push(r1);", "         break;", "       case OP_PUSH_RULE:", "         rule = *(YR_RULE**)(ip + 1);", "         ip += sizeof(uint64_t);", "         r1.i = rule->t_flags[tidx] & RULE_TFLAGS_MATCH ? 1 : 0;", "         push(r1);", "         break;", "       case OP_INIT_RULE:", "         #ifdef PROFILING_ENABLED", "         current_rule = *(YR_RULE**)(ip + 1);", "         #endif", "         ip += sizeof(uint64_t);", "         break;", "       case OP_MATCH_RULE:", "         pop(r1);", "         rule = *(YR_RULE**)(ip + 1);", "         ip += sizeof(uint64_t);", "         if (!is_undef(r1) && r1.i)", "           rule->t_flags[tidx] |= RULE_TFLAGS_MATCH;", "         else if (RULE_IS_GLOBAL(rule))", "           rule->ns->t_flags[tidx] |= NAMESPACE_TFLAGS_UNSATISFIED_GLOBAL;", "         #ifdef PROFILING_ENABLED", "         rule->clock_ticks += clock() - start;", "         start = clock();", "         #endif", "         break;", "       case OP_OBJ_LOAD:", "         identifier = *(char**)(ip + 1);", "         ip += sizeof(uint64_t);", "         r1.o = (YR_OBJECT*) yr_hash_table_lookup(", "             context->objects_table,", "             identifier,", "             NULL);", "         assert(r1.o != NULL);", "         push(r1);", "         break;", "       case OP_OBJ_FIELD:", "         identifier = *(char**)(ip + 1);", "         ip += sizeof(uint64_t);", "         pop(r1);", "         ensure_defined(r1);", "         r1.o = yr_object_lookup_field(r1.o, identifier);", "         assert(r1.o != NULL);", "         push(r1);", "         break;", "       case OP_OBJ_VALUE:", "         pop(r1);", "         ensure_defined(r1);", "         switch(r1.o->type)", "         {", "           case OBJECT_TYPE_INTEGER:", "             r1.i = ((YR_OBJECT_INTEGER*) r1.o)->value;", "             break;", "           case OBJECT_TYPE_FLOAT:", "             if (isnan(((YR_OBJECT_DOUBLE*) r1.o)->value))", "               r1.i = UNDEFINED;", "             else", "               r1.d = ((YR_OBJECT_DOUBLE*) r1.o)->value;", "             break;", "           case OBJECT_TYPE_STRING:", "             if (((YR_OBJECT_STRING*) r1.o)->value == NULL)", "               r1.i = UNDEFINED;", "             else", "               r1.p = ((YR_OBJECT_STRING*) r1.o)->value;", "             break;", "           default:", "             assert(FALSE);", "         }", "         push(r1);", "         break;", "       case OP_INDEX_ARRAY:", "         pop(r1);   ", "         pop(r2);   ", "         ensure_defined(r1);", "         ensure_defined(r2);", "         assert(r2.o->type == OBJECT_TYPE_ARRAY);", "         r1.o = yr_object_array_get_item(r2.o, 0, (int) r1.i);", "         if (r1.o == NULL)", "           r1.i = UNDEFINED;", "         push(r1);", "         break;", "       case OP_LOOKUP_DICT:", "         pop(r1);   ", "         pop(r2);   ", "         ensure_defined(r1);", "         ensure_defined(r2);", "         assert(r2.o->type == OBJECT_TYPE_DICTIONARY);", "         r1.o = yr_object_dict_get_item(", "             r2.o, 0, r1.ss->c_string);", "         if (r1.o == NULL)", "           r1.i = UNDEFINED;", "         push(r1);", "         break;", "       case OP_CALL:", "         args_fmt = *(char**)(ip + 1);", "         ip += sizeof(uint64_t);", "         i = (int) strlen(args_fmt);", "         count = 0;", "         while (i > 0)", "         {", "           pop(r1);", "           if (is_undef(r1))   ", "             count++;", "           args[i - 1] = r1;", "           i--;", "         }", "         pop(r2);", "         ensure_defined(r2);", "         if (count > 0)", "         {", "           r1.i = UNDEFINED;", "           push(r1);", "           break;", "         }", "         function = (YR_OBJECT_FUNCTION*) r2.o;", "         result = ERROR_INTERNAL_FATAL_ERROR;", "         for (i = 0; i < MAX_OVERLOADED_FUNCTIONS; i++)", "         {", "           if (function->prototypes[i].arguments_fmt == NULL)", "             break;", "           if (strcmp(function->prototypes[i].arguments_fmt, args_fmt) == 0)", "           {", "             result = function->prototypes[i].code(args, context, function);", "             break;", "           }", "         }", "         assert(i < MAX_OVERLOADED_FUNCTIONS);", "         if (result == ERROR_SUCCESS)", "         {", "           r1.o = function->return_obj;", "           push(r1);", "         }", "         else", "         {", "           stop = TRUE;", "         }", "         break;", "       case OP_FOUND:", "         pop(r1);", "         r1.i = r1.s->matches[tidx].tail != NULL ? 1 : 0;", "         push(r1);", "         break;", "       case OP_FOUND_AT:", "         pop(r2);", "         pop(r1);", "         if (is_undef(r1))", "         {", "           r1.i = 0;", "           push(r1);", "           break;", "         }", "         match = r2.s->matches[tidx].head;", "         r3.i = FALSE;", "         while (match != NULL)", "         {", "           if (r1.i == match->base + match->offset)", "           {", "             r3.i = TRUE;", "             break;", "           }", "           if (r1.i < match->base + match->offset)", "             break;", "           match = match->next;", "         }", "         push(r3);", "         break;", "       case OP_FOUND_IN:", "         pop(r3);", "         pop(r2);", "         pop(r1);", "         ensure_defined(r1);", "         ensure_defined(r2);", "         match = r3.s->matches[tidx].head;", "         r3.i = FALSE;", "         while (match != NULL && !r3.i)", "         {", "           if (match->base + match->offset >= r1.i &&", "               match->base + match->offset <= r2.i)", "           {", "             r3.i = TRUE;", "           }", "           if (match->base + match->offset > r2.i)", "             break;", "           match = match->next;", "         }", "         push(r3);", "         break;", "       case OP_COUNT:", "         pop(r1);", "         r1.i = r1.s->matches[tidx].count;", "         push(r1);", "         break;", "       case OP_OFFSET:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r1);", "         match = r2.s->matches[tidx].head;", "         i = 1;", "         r3.i = UNDEFINED;", "         while (match != NULL && r3.i == UNDEFINED)", "         {", "           if (r1.i == i)", "             r3.i = match->base + match->offset;", "           i++;", "           match = match->next;", "         }", "         push(r3);", "         break;", "       case OP_LENGTH:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r1);", "         match = r2.s->matches[tidx].head;", "         i = 1;", "         r3.i = UNDEFINED;", "         while (match != NULL && r3.i == UNDEFINED)", "         {", "           if (r1.i == i)", "             r3.i = match->match_length;", "           i++;", "           match = match->next;", "         }", "         push(r3);", "         break;", "       case OP_OF:", "         found = 0;", "         count = 0;", "         pop(r1);", "         while (!is_undef(r1))", "         {", "           if (r1.s->matches[tidx].tail != NULL)", "             found++;", "           count++;", "           pop(r1);", "         }", "         pop(r2);", "         if (is_undef(r2))", "           r1.i = found >= count ? 1 : 0;", "         else", "           r1.i = found >= r2.i ? 1 : 0;", "         push(r1);", "         break;", "       case OP_FILESIZE:", "         r1.i = context->file_size;", "         push(r1);", "         break;", "       case OP_ENTRYPOINT:", "         r1.i = context->entry_point;", "         push(r1);", "         break;", "       case OP_INT8:", "         pop(r1);", "         r1.i = read_int8_t_little_endian(context->iterator, (size_t) r1.i);", "         push(r1);", "         break;", "       case OP_INT16:", "         pop(r1);", "         r1.i = read_int16_t_little_endian(context->iterator, (size_t) r1.i);", "         push(r1);", "         break;", "       case OP_INT32:", "         pop(r1);", "         r1.i = read_int32_t_little_endian(context->iterator, (size_t) r1.i);", "         push(r1);", "         break;", "       case OP_UINT8:", "         pop(r1);", "         r1.i = read_uint8_t_little_endian(context->iterator, (size_t) r1.i);", "         push(r1);", "         break;", "       case OP_UINT16:", "         pop(r1);", "         r1.i = read_uint16_t_little_endian(context->iterator, (size_t) r1.i);", "         push(r1);", "         break;", "       case OP_UINT32:", "         pop(r1);", "         r1.i = read_uint32_t_little_endian(context->iterator, (size_t) r1.i);", "         push(r1);", "         break;", "       case OP_INT8BE:", "         pop(r1);", "         r1.i = read_int8_t_big_endian(context->iterator, (size_t) r1.i);", "         push(r1);", "         break;", "       case OP_INT16BE:", "         pop(r1);", "         r1.i = read_int16_t_big_endian(context->iterator, (size_t) r1.i);", "         push(r1);", "         break;", "       case OP_INT32BE:", "         pop(r1);", "         r1.i = read_int32_t_big_endian(context->iterator, (size_t) r1.i);", "         push(r1);", "         break;", "       case OP_UINT8BE:", "         pop(r1);", "         r1.i = read_uint8_t_big_endian(context->iterator, (size_t) r1.i);", "         push(r1);", "         break;", "       case OP_UINT16BE:", "         pop(r1);", "         r1.i = read_uint16_t_big_endian(context->iterator, (size_t) r1.i);", "         push(r1);", "         break;", "       case OP_UINT32BE:", "         pop(r1);", "         r1.i = read_uint32_t_big_endian(context->iterator, (size_t) r1.i);", "         push(r1);", "         break;", "       case OP_CONTAINS:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r1);", "         ensure_defined(r2);", "         r1.i = memmem(r1.ss->c_string, r1.ss->length,", "                       r2.ss->c_string, r2.ss->length) != NULL;", "         push(r1);", "         break;", "       case OP_IMPORT:", "         r1.i = *(uint64_t*)(ip + 1);", "         ip += sizeof(uint64_t);", "         result = yr_modules_load((char*) r1.p, context);", "         if (result != ERROR_SUCCESS)", "           stop = TRUE;", "         break;", "       case OP_MATCHES:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         if (r1.ss->length == 0)", "         {", "           r1.i = FALSE;", "           push(r1);", "           break;", "         }", "         r1.i = yr_re_exec(", "            (uint8_t*) r2.re->code,", "            (uint8_t*) r1.ss->c_string,", "            r1.ss->length,", "           0,", "            r2.re->flags | RE_FLAGS_SCAN,", "            NULL,", "            NULL) >= 0;", "         push(r1);", "         break;", "       case OP_INT_TO_DBL:", "         r1.i = *(uint64_t*)(ip + 1);", "         ip += sizeof(uint64_t);", "         r2 = stack[sp - r1.i];", "         if (is_undef(r2))", "           stack[sp - r1.i].i = UNDEFINED;", "         else", "           stack[sp - r1.i].d = (double) r2.i;", "         break;", "       case OP_STR_TO_BOOL:", "         pop(r1);", "         ensure_defined(r1);", "         r1.i = r1.ss->length > 0;", "         push(r1);", "         break;", "       case OP_INT_EQ:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.i = r1.i == r2.i;", "         push(r1);", "         break;", "       case OP_INT_NEQ:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.i = r1.i != r2.i;", "         push(r1);", "         break;", "       case OP_INT_LT:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.i = r1.i < r2.i;", "         push(r1);", "         break;", "       case OP_INT_GT:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.i = r1.i > r2.i;", "         push(r1);", "         break;", "       case OP_INT_LE:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.i = r1.i <= r2.i;", "         push(r1);", "         break;", "       case OP_INT_GE:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.i = r1.i >= r2.i;", "         push(r1);", "         break;", "       case OP_INT_ADD:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.i = r1.i + r2.i;", "         push(r1);", "         break;", "       case OP_INT_SUB:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.i = r1.i - r2.i;", "         push(r1);", "         break;", "       case OP_INT_MUL:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.i = r1.i * r2.i;", "         push(r1);", "         break;", "       case OP_INT_DIV:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         if (r2.i != 0)", "           r1.i = r1.i / r2.i;", "         else", "           r1.i = UNDEFINED;", "         push(r1);", "         break;", "       case OP_INT_MINUS:", "         pop(r1);", "         ensure_defined(r1);", "         r1.i = -r1.i;", "         push(r1);", "         break;", "       case OP_DBL_LT:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.i = r1.d < r2.d;", "         push(r1);", "         break;", "       case OP_DBL_GT:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.i = r1.d > r2.d;", "         push(r1);", "         break;", "       case OP_DBL_LE:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.i = r1.d <= r2.d;", "         push(r1);", "         break;", "       case OP_DBL_GE:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.i = r1.d >= r2.d;", "         push(r1);", "         break;", "       case OP_DBL_EQ:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.i = r1.d == r2.d;", "         push(r1);", "         break;", "       case OP_DBL_NEQ:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.i = r1.d != r2.d;", "         push(r1);", "         break;", "       case OP_DBL_ADD:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.d = r1.d + r2.d;", "         push(r1);", "         break;", "       case OP_DBL_SUB:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.d = r1.d - r2.d;", "         push(r1);", "         break;", "       case OP_DBL_MUL:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.d = r1.d * r2.d;", "         push(r1);", "         break;", "       case OP_DBL_DIV:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.d = r1.d / r2.d;", "         push(r1);", "         break;", "       case OP_DBL_MINUS:", "         pop(r1);", "         ensure_defined(r1);", "         r1.d = -r1.d;", "         push(r1);", "         break;", "       case OP_STR_EQ:", "       case OP_STR_NEQ:", "       case OP_STR_LT:", "       case OP_STR_LE:", "       case OP_STR_GT:", "       case OP_STR_GE:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r1);", "         ensure_defined(r2);", "         switch(*ip)", "         {", "           case OP_STR_EQ:", "             r1.i = (sized_string_cmp(r1.ss, r2.ss) == 0);", "             break;", "           case OP_STR_NEQ:", "             r1.i = (sized_string_cmp(r1.ss, r2.ss) != 0);", "             break;", "           case OP_STR_LT:", "             r1.i = (sized_string_cmp(r1.ss, r2.ss) < 0);", "             break;", "           case OP_STR_LE:", "             r1.i = (sized_string_cmp(r1.ss, r2.ss) <= 0);", "             break;", "           case OP_STR_GT:", "             r1.i = (sized_string_cmp(r1.ss, r2.ss) > 0);", "             break;", "           case OP_STR_GE:", "             r1.i = (sized_string_cmp(r1.ss, r2.ss) >= 0);", "             break;", "         }", "         push(r1);", "         break;", "       default:", "         assert(FALSE);", "     }", "     if (timeout > 0)   ", "     {", "       if (++cycle == 10)", "       {", "         if (difftime(time(NULL), start_time) > timeout)", "         {", "           #ifdef PROFILING_ENABLED", "           assert(current_rule != NULL);", "           current_rule->clock_ticks += clock() - start;", "           #endif", "           result = ERROR_SCAN_TIMEOUT;", "           stop = TRUE;", "         }", "         cycle = 0;", "       }", "     }", "     ip++;", "   }", "   yr_modules_unload_all(context);", "   yr_free(stack);", "   return result;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int handle_packet(unsigned char *data, int data_len) {", " \tstruct mt_mactelnet_hdr pkthdr;", " \tif (data_len < MT_HEADER_LEN){", " \t\treturn -1;", " \t}", " \tparse_packet(data, &pkthdr);", " \tif (pkthdr.seskey != sessionkey) {", " \t\treturn -1;", " \t}", " \tif (pkthdr.ptype == MT_PTYPE_DATA) {", " \t\tstruct mt_packet odata;", " \t\tstruct mt_mactelnet_control_hdr cpkt;", " \t\tint success = 0;", " \t\tinit_packet(&odata, MT_PTYPE_ACK, srcmac, dstmac, sessionkey, pkthdr.counter + (data_len - MT_HEADER_LEN));", " \t\tsend_udp(&odata, 0);", " \t\tif (pkthdr.counter > incounter || (incounter - pkthdr.counter) > 65535) {", " \t\t\tincounter = pkthdr.counter;", " \t\t} else {", " \t\t\treturn -1;", " \t\t}", " \t\tsuccess = parse_control_packet(data + MT_HEADER_LEN, data_len - MT_HEADER_LEN, &cpkt);", " \t\twhile (success) {", "  \t\t\tif (cpkt.cptype == MT_CPTYPE_PASSSALT) {", "\t\t\t\tmemcpy(pass_salt, cpkt.data, cpkt.length);", " \t\t\t\tif (cpkt.length != 16) {", " \t\t\t\t\tfprintf(stderr, _(\"Invalid salt length: %d (instead of 16) received from server %s\\n\"), cpkt.length, ether_ntoa((struct ether_addr *)dstmac));", " \t\t\t\t}", " \t\t\t\tmemcpy(pass_salt, cpkt.data, 16);", "  \t\t\t\tsend_auth(username, password);", "  \t\t\t}", " \t\t\telse if (cpkt.cptype == MT_CPTYPE_PLAINDATA) {", " \t\t\t\tfwrite((const void *)cpkt.data, 1, cpkt.length, stdout);", " \t\t\t}", " \t\t\telse if (cpkt.cptype == MT_CPTYPE_END_AUTH) {", " \t\t\t\tterminal_mode = 1;", " \t\t\t\tif (is_a_tty) {", " \t\t\t\t\traw_term();", " \t\t\t\t\tsetvbuf(stdin,  (char*)NULL, _IONBF, 0);", " \t\t\t\t\tsignal(SIGWINCH, sig_winch);", " \t\t\t\t}", " \t\t\t}", " \t\t\tsuccess = parse_control_packet(NULL, 0, &cpkt);", " \t\t}", " \t}", " \telse if (pkthdr.ptype == MT_PTYPE_ACK) {", " \t}", " \telse if (pkthdr.ptype == MT_PTYPE_END) {", " \t\tstruct mt_packet odata;", " \t\tinit_packet(&odata, MT_PTYPE_END, srcmac, dstmac, pkthdr.seskey, 0);", " \t\tsend_udp(&odata, 0);", " \t\tif (!quiet_mode) {", " \t\t\tfprintf(stderr, _(\"Connection closed.\\n\"));", " \t\t}", " \t\trunning = 0;", " \t} else {", " \t\tfprintf(stderr, _(\"Unhandeled packet type: %d received from server %s\\n\"), pkthdr.ptype, ether_ntoa((struct ether_addr *)dstmac));", " \t\treturn -1;", " \t}", " \treturn pkthdr.ptype;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" on_register_handler(TCMUService1HandlerManager1 *interface,", " \t\t    GDBusMethodInvocation *invocation,", " \t\t    gchar *subtype,", " \t\t    gchar *cfg_desc,", " \t\t    gpointer user_data)", " {", " \tstruct tcmur_handler *handler;", " \tstruct dbus_info *info;", " \tchar *bus_name;", " \tbus_name = g_strdup_printf(\"org.kernel.TCMUService1.HandlerManager1.%s\",", " \t\t\t\t   subtype);", " \thandler               = g_new0(struct tcmur_handler, 1);", " \thandler->subtype      = g_strdup(subtype);", " \thandler->cfg_desc     = g_strdup(cfg_desc);", " \thandler->open         = dbus_handler_open;", " \thandler->close        = dbus_handler_close;", "  \thandler->handle_cmd   = dbus_handler_handle_cmd;", "  \tinfo = g_new0(struct dbus_info, 1);", " \thandler->opaque = info;", " \thandler->_is_dbus_handler = 1;", "  \tinfo->register_invocation = invocation;", "  \tinfo->watcher_id = g_bus_watch_name(G_BUS_TYPE_SYSTEM,", "  \t\t\t\t\t    bus_name,", " \t\t\t\t\t    G_BUS_NAME_WATCHER_FLAGS_NONE,", " \t\t\t\t\t    on_handler_appeared,", " \t\t\t\t\t    on_handler_vanished,", " \t\t\t\t\t    handler,", " \t\t\t\t\t    NULL);", " \tg_free(bus_name);", " \thandler->opaque = info;", " \treturn TRUE;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)", " {", " \tjas_image_t *image;", " \tbmp_hdr_t hdr;", " \tbmp_info_t *info;", " \tuint_fast16_t cmptno;", " \tjas_image_cmptparm_t cmptparms[3];", "  \tjas_image_cmptparm_t *cmptparm;", "  \tuint_fast16_t numcmpts;", "  \tlong n;", " \tbmp_dec_importopts_t opts;", " \tsize_t num_samples;", "  \timage = 0;", "  \tinfo = 0;", "\tif (optstr) {", "\t\tjas_eprintf(\"warning: ignoring BMP decoder options\\n\");", " \tif (bmp_dec_parseopts(optstr, &opts)) {", " \t\tgoto error;", "  \t}", "  \tjas_eprintf(", " \t  \"THE BMP FORMAT IS NOT FULLY SUPPORTED!\\n\"", " \t  \"THAT IS, THE JASPER SOFTWARE CANNOT DECODE ALL TYPES OF BMP DATA.\\n\"", " \t  \"IF YOU HAVE ANY PROBLEMS, PLEASE TRY CONVERTING YOUR IMAGE DATA\\n\"", " \t  \"TO THE PNM FORMAT, AND USING THIS FORMAT INSTEAD.\\n\"", " \t  );", "  \tif (bmp_gethdr(in, &hdr)) {", "  \t\tjas_eprintf(\"cannot get header\\n\");", "  \t\tgoto error;", "  \tJAS_DBGLOG(1, (", "  \t  \"BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\\n\",", " \t  hdr.magic, hdr.siz, hdr.reserved1, hdr.reserved2, hdr.off", " \t  ));", "  \tif (!(info = bmp_getinfo(in))) {", "  \t\tjas_eprintf(\"cannot get info\\n\");", "  \t}", "  \tJAS_DBGLOG(1,", " \t  (\"BMP information: len %ld; width %ld; height %ld; numplanes %d; \"", " \t  \"depth %d; enctype %ld; siz %ld; hres %ld; vres %ld; numcolors %ld; \"", " \t  \"mincolors %ld\\n\", JAS_CAST(long, info->len),", " \t  JAS_CAST(long, info->width), JAS_CAST(long, info->height),", " \t  JAS_CAST(long, info->numplanes), JAS_CAST(long, info->depth),", " \t  JAS_CAST(long, info->enctype), JAS_CAST(long, info->siz),", " \t  JAS_CAST(long, info->hres), JAS_CAST(long, info->vres),", " \t  JAS_CAST(long, info->numcolors), JAS_CAST(long, info->mincolors)));", " \tif (info->width < 0 || info->height < 0 || info->numplanes < 0 ||", " \t  info->depth < 0 || info->siz < 0 || info->hres < 0 || info->vres < 0) {", " \t\tjas_eprintf(\"corrupt bit stream\\n\");", "  \t\tgoto error;", "  \t}", " \tif (!jas_safe_size_mul3(info->width, info->height, info->numplanes,", " \t  &num_samples)) {", " \t\tjas_eprintf(\"image size too large\\n\");", " \t\tgoto error;", " \t}", " \tif (opts.max_samples > 0 && num_samples > opts.max_samples) {", " \t\tjas_eprintf(\"maximum number of pixels exceeded (%zu)\\n\",", " \t\t  opts.max_samples);", " \t\tgoto error;", " \t}", "  \tif (!bmp_issupported(&hdr, info)) {", "  \t\tjas_eprintf(\"error: unsupported BMP encoding\\n\");", "  \t}", "  \tif ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {", "  \t\tjas_eprintf(\"error: possibly bad bitmap offset?\\n\");", "  \t\tgoto error;", "  \tif (n > 0) {", "  \t\tjas_eprintf(\"skipping unknown data in BMP file\\n\");", "  \t\tif (bmp_gobble(in, n)) {", "  \t\t}", "  \t}", " \tnumcmpts = bmp_numcmpts(info);", " \tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,", " \t  ++cmptparm) {", " \t\tcmptparm->tlx = 0;", " \t\tcmptparm->tly = 0;", " \t\tcmptparm->hstep = 1;", " \t\tcmptparm->vstep = 1;", " \t\tcmptparm->width = info->width;", " \t\tcmptparm->height = info->height;", " \t\tcmptparm->prec = 8;", " \t\tcmptparm->sgnd = false;", " \t}", "  \tif (!(image = jas_image_create(numcmpts, cmptparms,", "  \t  JAS_CLRSPC_UNKNOWN))) {", "  \t}", " \tif (numcmpts == 3) {", " \t\tjas_image_setclrspc(image, JAS_CLRSPC_SRGB);", " \t\tjas_image_setcmpttype(image, 0,", " \t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));", " \t\tjas_image_setcmpttype(image, 1,", " \t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));", " \t\tjas_image_setcmpttype(image, 2,", " \t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));", " \t} else {", " \t\tjas_image_setclrspc(image, JAS_CLRSPC_SGRAY);", " \t\tjas_image_setcmpttype(image, 0,", " \t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));", " \t}", "  \tif (bmp_getdata(in, info, image)) {", "  \t}", " \tbmp_info_destroy(info);", " \treturn image;", " error:", " \tif (info) {", " \t\tbmp_info_destroy(info);", " \t}", " \tif (image) {", " \t\tjas_image_destroy(image);", " \t}", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" scandir(const char *dir, struct dirent ***namelist,", "         int (*select) (const struct dirent *),", "         int (*compar) (const struct dirent **, const struct dirent **))", " {", "     DIR *d = opendir(dir);", "     struct dirent *current;", "     struct dirent **names;", "     int count = 0;", "     int pos = 0;", "     int result = -1;", "     if (NULL == d)", "         return -1;", "      while (NULL != readdir(d))", "          count++;", " \tclosedir(d);", "      names = malloc(sizeof (struct dirent *) * count);", " \tif (!names) ", " \t\treturn -1;", "    closedir(d);", "      d = opendir(dir);", "    if (NULL == d)", "     if (NULL == d) {", " \t\tfree(names);", "          return -1;", "     }", "      while (NULL != (current = readdir(d))) {", "          if (NULL == select || select(current)) {", "              struct dirent *copyentry = malloc(current->d_reclen);", " \t\t\tif (!copyentry)", " \t\t\t\tcontinue;", "              memcpy(copyentry, current, current->d_reclen);", "              names[pos] = copyentry;", "             pos++;", "         }", "     }", "     result = closedir(d);", "     if (pos != count)", "         names = realloc(names, sizeof (struct dirent *) * pos);", "     *namelist = names;", "     return pos;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" unicode_unfold_key(OnigCodePoint code)", " {", "   static const struct ByUnfoldKey wordlist[] =", "     {", "       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},", "       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},", "       {0xffffffff, -1, 0},", "       {0x1040a, 3267, 1},", "       {0x1e0a, 1727, 1},", "       {0x040a, 1016, 1},", "       {0x010a, 186, 1},", "       {0x1f0a, 2088, 1},", "       {0x2c0a, 2451, 1},", "       {0x0189, 619, 1},", "       {0x1f89, 134, 2},", "       {0x1f85, 154, 2},", "       {0x0389, 733, 1},", "       {0x03ff, 724, 1},", "       {0xab89, 1523, 1},", "       {0xab85, 1511, 1},", "       {0x10c89, 3384, 1},", "       {0x10c85, 3372, 1},", "       {0x1e84, 1911, 1},", "       {0x03f5, 752, 1},", "       {0x0184, 360, 1},", "       {0x1f84, 149, 2},", "       {0x2c84, 2592, 1},", "       {0x017d, 351, 1},", "       {0x1ff3, 96, 2},", "       {0xab84, 1508, 1},", "       {0xa784, 3105, 1},", "       {0x10c84, 3369, 1},", "       {0xab7d, 1487, 1},", "       {0xa77d, 1706, 1},", "       {0x1e98, 38, 2},", "       {0x0498, 1106, 1},", "       {0x0198, 375, 1},", "       {0x1f98, 169, 2},", "       {0x2c98, 2622, 1},", "       {0x0398, 762, 1},", "       {0xa684, 2940, 1},", "       {0xab98, 1568, 1},", "       {0xa798, 3123, 1},", "       {0x10c98, 3429, 1},", "       {0x050a, 1277, 1},", "       {0x1ffb, 2265, 1},", "       {0x1e96, 16, 2},", "       {0x0496, 1103, 1},", "       {0x0196, 652, 1},", "       {0x1f96, 199, 2},", "       {0x2c96, 2619, 1},", "       {0x0396, 756, 1},", "       {0xa698, 2970, 1},", "       {0xab96, 1562, 1},", "       {0xa796, 3120, 1},", "       {0x10c96, 3423, 1},", "       {0x1feb, 2259, 1},", "       {0x2ceb, 2736, 1},", "       {0x1e90, 1929, 1},", "       {0x0490, 1094, 1},", "       {0x0190, 628, 1},", "       {0x1f90, 169, 2},", "       {0x2c90, 2610, 1},", "       {0x0390, 25, 3},", "       {0xa696, 2967, 1},", "       {0xab90, 1544, 1},", "       {0xa790, 3114, 1},", "       {0x10c90, 3405, 1},", "       {0x01d7, 444, 1},", "       {0x1fd7, 31, 3},", "       {0x1ea6, 1947, 1},", "       {0x04a6, 1127, 1},", "       {0x01a6, 676, 1},", "       {0x1fa6, 239, 2},", "       {0x2ca6, 2643, 1},", "       {0x03a6, 810, 1},", "       {0xa690, 2958, 1},", "       {0xaba6, 1610, 1},", "       {0xa7a6, 3144, 1},", "       {0x10ca6, 3471, 1},", "       {0x1ea4, 1944, 1},", "       {0x04a4, 1124, 1},", "       {0x01a4, 390, 1},", "       {0x1fa4, 229, 2},", "       {0x2ca4, 2640, 1},", "       {0x03a4, 804, 1},", "       {0x10a6, 2763, 1},", "       {0xaba4, 1604, 1},", "       {0xa7a4, 3141, 1},", "       {0x10ca4, 3465, 1},", "       {0x1ea0, 1938, 1},", "       {0x04a0, 1118, 1},", "       {0x01a0, 384, 1},", "       {0x1fa0, 209, 2},", "       {0x2ca0, 2634, 1},", "       {0x03a0, 792, 1},", "       {0x10a4, 2757, 1},", "       {0xaba0, 1592, 1},", "       {0xa7a0, 3135, 1},", "       {0x10ca0, 3453, 1},", "       {0x1eb2, 1965, 1},", "       {0x04b2, 1145, 1},", "       {0x01b2, 694, 1},", "       {0x1fb2, 249, 2},", "       {0x2cb2, 2661, 1},", "       {0x03fd, 718, 1},", "       {0x10a0, 2745, 1},", "       {0xabb2, 1646, 1},", "       {0xa7b2, 703, 1},", "       {0x10cb2, 3507, 1},", "       {0x1eac, 1956, 1},", "       {0x04ac, 1136, 1},", "       {0x01ac, 396, 1},", "       {0x1fac, 229, 2},", "       {0x2cac, 2652, 1},", "       {0x0537, 1352, 1},", "       {0x10b2, 2799, 1},", "       {0xabac, 1628, 1},", "       {0xa7ac, 637, 1},", "       {0x10cac, 3489, 1},", "       {0x1eaa, 1953, 1},", "       {0x04aa, 1133, 1},", "       {0x00dd, 162, 1},", "       {0x1faa, 219, 2},", "       {0x2caa, 2649, 1},", "       {0x03aa, 824, 1},", "       {0x10ac, 2781, 1},", "       {0xabaa, 1622, 1},", "       {0xa7aa, 646, 1},", "       {0x10caa, 3483, 1},", "       {0x1ea8, 1950, 1},", "       {0x04a8, 1130, 1},", "       {0x020a, 517, 1},", "       {0x1fa8, 209, 2},", "       {0x2ca8, 2646, 1},", "       {0x03a8, 817, 1},", "       {0x10aa, 2775, 1},", "       {0xaba8, 1616, 1},", "       {0xa7a8, 3147, 1},", "       {0x10ca8, 3477, 1},", "       {0x1ea2, 1941, 1},", "       {0x04a2, 1121, 1},", "       {0x01a2, 387, 1},", "       {0x1fa2, 219, 2},", "       {0x2ca2, 2637, 1},", "       {0x118a6, 3528, 1},", "       {0x10a8, 2769, 1},", "       {0xaba2, 1598, 1},", "       {0xa7a2, 3138, 1},", "       {0x10ca2, 3459, 1},", "       {0x2ced, 2739, 1},", "       {0x1fe9, 2283, 1},", "       {0x1fe7, 47, 3},", "       {0x1eb0, 1962, 1},", "       {0x04b0, 1142, 1},", "       {0x118a4, 3522, 1},", "       {0x10a2, 2751, 1},", "       {0x2cb0, 2658, 1},", "       {0x03b0, 41, 3},", "       {0x1fe3, 41, 3},", "       {0xabb0, 1640, 1},", "       {0xa7b0, 706, 1},", "       {0x10cb0, 3501, 1},", "       {0x01d9, 447, 1},", "       {0x1fd9, 2277, 1},", "       {0x118a0, 3510, 1},", "       {0x00df, 24, 2},", "       {0x00d9, 150, 1},", "       {0xab77, 1469, 1},", "       {0x10b0, 2793, 1},", "       {0x1eae, 1959, 1},", "       {0x04ae, 1139, 1},", "       {0x01ae, 685, 1},", "       {0x1fae, 239, 2},", "       {0x2cae, 2655, 1},", "       {0x118b2, 3564, 1},", "       {0xab73, 1457, 1},", "       {0xabae, 1634, 1},", "       {0xab71, 1451, 1},", "       {0x10cae, 3495, 1},", "       {0x1e2a, 1775, 1},", "       {0x042a, 968, 1},", "       {0x012a, 234, 1},", "       {0x1f2a, 2130, 1},", "       {0x2c2a, 2547, 1},", "       {0x118ac, 3546, 1},", "       {0x10ae, 2787, 1},", "       {0x0535, 1346, 1},", "       {0xa72a, 2988, 1},", "       {0x1e9a, 0, 2},", "       {0x049a, 1109, 1},", "       {0xff37, 3225, 1},", "       {0x1f9a, 179, 2},", "       {0x2c9a, 2625, 1},", "       {0x039a, 772, 1},", "       {0x118aa, 3540, 1},", "       {0xab9a, 1574, 1},", "       {0xa79a, 3126, 1},", "       {0x10c9a, 3435, 1},", "       {0x1e94, 1935, 1},", "       {0x0494, 1100, 1},", "       {0x0194, 640, 1},", "       {0x1f94, 189, 2},", "       {0x2c94, 2616, 1},", "       {0x0394, 749, 1},", "       {0x118a8, 3534, 1},", "       {0xab94, 1556, 1},", "       {0xa69a, 2973, 1},", "       {0x10c94, 3417, 1},", "       {0x10402, 3243, 1},", "       {0x1e02, 1715, 1},", "       {0x0402, 992, 1},", "       {0x0102, 174, 1},", "       {0x0533, 1340, 1},", "       {0x2c02, 2427, 1},", "       {0x118a2, 3516, 1},", "       {0x052a, 1325, 1},", "       {0xa694, 2964, 1},", "       {0x1e92, 1932, 1},", "       {0x0492, 1097, 1},", "       {0x2165, 2307, 1},", "       {0x1f92, 179, 2},", "       {0x2c92, 2613, 1},", "       {0x0392, 742, 1},", "       {0x2161, 2295, 1},", "       {0xab92, 1550, 1},", "       {0xa792, 3117, 1},", "       {0x10c92, 3411, 1},", "       {0x118b0, 3558, 1},", "       {0x1f5f, 2199, 1},", "       {0x1e8e, 1926, 1},", "       {0x048e, 1091, 1},", "       {0x018e, 453, 1},", "       {0x1f8e, 159, 2},", "       {0x2c8e, 2607, 1},", "       {0x038e, 833, 1},", "       {0xa692, 2961, 1},", "       {0xab8e, 1538, 1},", "       {0x0055, 59, 1},", "       {0x10c8e, 3399, 1},", "       {0x1f5d, 2196, 1},", "       {0x212a, 27, 1},", "       {0x04cb, 1181, 1},", "       {0x01cb, 425, 1},", "       {0x1fcb, 2241, 1},", "       {0x118ae, 3552, 1},", "       {0x0502, 1265, 1},", "       {0x00cb, 111, 1},", "       {0xa68e, 2955, 1},", "       {0x1e8a, 1920, 1},", "       {0x048a, 1085, 1},", "       {0x018a, 622, 1},", "       {0x1f8a, 139, 2},", "       {0x2c8a, 2601, 1},", "       {0x038a, 736, 1},", "       {0x2c67, 2571, 1},", "       {0xab8a, 1526, 1},", "       {0x1e86, 1914, 1},", "       {0x10c8a, 3387, 1},", "       {0x0186, 616, 1},", "       {0x1f86, 159, 2},", "       {0x2c86, 2595, 1},", "       {0x0386, 727, 1},", "       {0xff35, 3219, 1},", "       {0xab86, 1514, 1},", "       {0xa786, 3108, 1},", "       {0x10c86, 3375, 1},", "       {0xa68a, 2949, 1},", "       {0x0555, 1442, 1},", "       {0x1ebc, 1980, 1},", "       {0x04bc, 1160, 1},", "       {0x01bc, 411, 1},", "       {0x1fbc, 62, 2},", "       {0x2cbc, 2676, 1},", "       {0x1f5b, 2193, 1},", "       {0xa686, 2943, 1},", "       {0xabbc, 1676, 1},", "       {0x1eb8, 1974, 1},", "       {0x04b8, 1154, 1},", "       {0x01b8, 408, 1},", "       {0x1fb8, 2268, 1},", "       {0x2cb8, 2670, 1},", "       {0x01db, 450, 1},", "       {0x1fdb, 2247, 1},", "       {0xabb8, 1664, 1},", "       {0x10bc, 2829, 1},", "       {0x00db, 156, 1},", "       {0x1eb6, 1971, 1},", "       {0x04b6, 1151, 1},", "       {0xff33, 3213, 1},", "       {0x1fb6, 58, 2},", "       {0x2cb6, 2667, 1},", "       {0xff2a, 3186, 1},", "       {0x10b8, 2817, 1},", "       {0xabb6, 1658, 1},", "       {0xa7b6, 3153, 1},", "       {0x10426, 3351, 1},", "       {0x1e26, 1769, 1},", "       {0x0426, 956, 1},", "       {0x0126, 228, 1},", "       {0x0053, 52, 1},", "       {0x2c26, 2535, 1},", "       {0x0057, 65, 1},", "       {0x10b6, 2811, 1},", "       {0x022a, 562, 1},", "       {0xa726, 2982, 1},", "       {0x1e2e, 1781, 1},", "       {0x042e, 980, 1},", "       {0x012e, 240, 1},", "       {0x1f2e, 2142, 1},", "       {0x2c2e, 2559, 1},", "       {0xffffffff, -1, 0},", "       {0x2167, 2313, 1},", "       {0xffffffff, -1, 0},", "       {0xa72e, 2994, 1},", "       {0x1e2c, 1778, 1},", "       {0x042c, 974, 1},", "       {0x012c, 237, 1},", "       {0x1f2c, 2136, 1},", "       {0x2c2c, 2553, 1},", "       {0x1f6f, 2223, 1},", "       {0x2c6f, 604, 1},", "       {0xabbf, 1685, 1},", "       {0xa72c, 2991, 1},", "       {0x1e28, 1772, 1},", "       {0x0428, 962, 1},", "       {0x0128, 231, 1},", "       {0x1f28, 2124, 1},", "       {0x2c28, 2541, 1},", "       {0xffffffff, -1, 0},", "       {0x0553, 1436, 1},", "       {0x10bf, 2838, 1},", "       {0xa728, 2985, 1},", "       {0x0526, 1319, 1},", "       {0x0202, 505, 1},", "       {0x1e40, 1808, 1},", "       {0x10424, 3345, 1},", "       {0x1e24, 1766, 1},", "       {0x0424, 950, 1},", "       {0x0124, 225, 1},", "       {0xffffffff, -1, 0},", "       {0x2c24, 2529, 1},", "       {0x052e, 1331, 1},", "       {0xa740, 3018, 1},", "       {0x118bc, 3594, 1},", "       {0xa724, 2979, 1},", "       {0x1ef2, 2061, 1},", "       {0x04f2, 1241, 1},", "       {0x01f2, 483, 1},", "       {0x1ff2, 257, 2},", "       {0x2cf2, 2742, 1},", "       {0x052c, 1328, 1},", "       {0x118b8, 3582, 1},", "       {0xa640, 2865, 1},", "       {0x10422, 3339, 1},", "       {0x1e22, 1763, 1},", "       {0x0422, 944, 1},", "       {0x0122, 222, 1},", "       {0x2126, 820, 1},", "       {0x2c22, 2523, 1},", "       {0x0528, 1322, 1},", "       {0x01f1, 483, 1},", "       {0x118b6, 3576, 1},", "       {0xa722, 2976, 1},", "       {0x03f1, 796, 1},", "       {0x1ebe, 1983, 1},", "       {0x04be, 1163, 1},", "       {0xfb02, 12, 2},", "       {0x1fbe, 767, 1},", "       {0x2cbe, 2679, 1},", "       {0x01b5, 405, 1},", "       {0x0540, 1379, 1},", "       {0xabbe, 1682, 1},", "       {0x0524, 1316, 1},", "       {0x00b5, 779, 1},", "       {0xabb5, 1655, 1},", "       {0x1eba, 1977, 1},", "       {0x04ba, 1157, 1},", "       {0x216f, 2337, 1},", "       {0x1fba, 2226, 1},", "       {0x2cba, 2673, 1},", "       {0x10be, 2835, 1},", "       {0x0051, 46, 1},", "       {0xabba, 1670, 1},", "       {0x10b5, 2808, 1},", "       {0x1e6e, 1878, 1},", "       {0x046e, 1055, 1},", "       {0x016e, 330, 1},", "       {0x1f6e, 2220, 1},", "       {0x2c6e, 664, 1},", "       {0x118bf, 3603, 1},", "       {0x0522, 1313, 1},", "       {0x10ba, 2823, 1},", "       {0xa76e, 3087, 1},", "       {0x1eb4, 1968, 1},", "       {0x04b4, 1148, 1},", "       {0x2c75, 2583, 1},", "       {0x1fb4, 50, 2},", "       {0x2cb4, 2664, 1},", "       {0xab75, 1463, 1},", "       {0x1ec2, 1989, 1},", "       {0xabb4, 1652, 1},", "       {0xa7b4, 3150, 1},", "       {0x1fc2, 253, 2},", "       {0x2cc2, 2685, 1},", "       {0x03c2, 800, 1},", "       {0x00c2, 83, 1},", "       {0xffffffff, -1, 0}, {0xffffffff, -1, 0},", "       {0xff26, 3174, 1},", "       {0x10b4, 2805, 1},", "       {0x1eca, 2001, 1},", "       {0x0551, 1430, 1},", "       {0x01ca, 425, 1},", "       {0x1fca, 2238, 1},", "       {0x2cca, 2697, 1},", "       {0x10c2, 2847, 1},", "       {0x00ca, 108, 1},", "       {0xff2e, 3198, 1},", "       {0x1e8c, 1923, 1},", "       {0x048c, 1088, 1},", "       {0x0226, 556, 1},", "       {0x1f8c, 149, 2},", "       {0x2c8c, 2604, 1},", "       {0x038c, 830, 1},", "       {0xffffffff, -1, 0},", "       {0xab8c, 1532, 1},", "       {0xff2c, 3192, 1},", "       {0x10c8c, 3393, 1},", "       {0x1ec4, 1992, 1},", "       {0x022e, 568, 1},", "       {0x01c4, 417, 1},", "       {0x1fc4, 54, 2},", "       {0x2cc4, 2688, 1},", "       {0xffffffff, -1, 0},", "       {0x00c4, 89, 1},", "       {0xff28, 3180, 1},", "       {0xa68c, 2952, 1},", "       {0x01cf, 432, 1},", "       {0x022c, 565, 1},", "       {0x118be, 3600, 1},", "       {0x03cf, 839, 1},", "       {0x00cf, 123, 1},", "       {0x118b5, 3573, 1},", "       {0xffffffff, -1, 0},", "       {0x10c4, 2853, 1},", "       {0x216e, 2334, 1},", "       {0x24cb, 2406, 1},", "       {0x0228, 559, 1},", "       {0xff24, 3168, 1},", "       {0xffffffff, -1, 0},", "       {0x118ba, 3588, 1},", "       {0x1efe, 2079, 1},", "       {0x04fe, 1259, 1},", "       {0x01fe, 499, 1},", "       {0x1e9e, 24, 2},", "       {0x049e, 1115, 1},", "       {0x03fe, 721, 1},", "       {0x1f9e, 199, 2},", "       {0x2c9e, 2631, 1},", "       {0x039e, 786, 1},", "       {0x0224, 553, 1},", "       {0xab9e, 1586, 1},", "       {0xa79e, 3132, 1},", "       {0x10c9e, 3447, 1},", "       {0x01f7, 414, 1},", "       {0x1ff7, 67, 3},", "       {0xff22, 3162, 1},", "       {0x03f7, 884, 1},", "       {0x118b4, 3570, 1},", "       {0x049c, 1112, 1},", "       {0x019c, 661, 1},", "       {0x1f9c, 189, 2},", "       {0x2c9c, 2628, 1},", "       {0x039c, 779, 1},", "       {0x24bc, 2361, 1},", "       {0xab9c, 1580, 1},", "       {0xa79c, 3129, 1},", "       {0x10c9c, 3441, 1},", "       {0x0222, 550, 1},", "       {0x1e7c, 1899, 1},", "       {0x047c, 1076, 1},", "       {0x1e82, 1908, 1},", "       {0x24b8, 2349, 1},", "       {0x0182, 357, 1},", "       {0x1f82, 139, 2},", "       {0x2c82, 2589, 1},", "       {0xab7c, 1484, 1},", "       {0xffffffff, -1, 0},", "       {0xab82, 1502, 1},", "       {0xa782, 3102, 1},", "       {0x10c82, 3363, 1},", "       {0x2c63, 1709, 1},", "       {0x24b6, 2343, 1},", "       {0x1e80, 1905, 1},", "       {0x0480, 1082, 1},", "       {0x1f59, 2190, 1},", "       {0x1f80, 129, 2},", "       {0x2c80, 2586, 1},", "       {0x0059, 71, 1},", "       {0xa682, 2937, 1},", "       {0xab80, 1496, 1},", "       {0xa780, 3099, 1},", "       {0x10c80, 3357, 1},", "       {0xffffffff, -1, 0},", "       {0x1e4c, 1826, 1},", "       {0x0145, 270, 1},", "       {0x014c, 279, 1},", "       {0x1f4c, 2184, 1},", "       {0x0345, 767, 1},", "       {0x0045, 12, 1},", "       {0x004c, 31, 1},", "       {0xa680, 2934, 1},", "       {0xa74c, 3036, 1},", "       {0x1e4a, 1823, 1},", "       {0x01d5, 441, 1},", "       {0x014a, 276, 1},", "       {0x1f4a, 2178, 1},", "       {0x03d5, 810, 1},", "       {0x00d5, 141, 1},", "       {0x004a, 24, 1},", "       {0x24bf, 2370, 1},", "       {0xa74a, 3033, 1},", "       {0xa64c, 2883, 1},", "       {0x1041c, 3321, 1},", "       {0x1e1c, 1754, 1},", "       {0x041c, 926, 1},", "       {0x011c, 213, 1},", "       {0x1f1c, 2118, 1},", "       {0x2c1c, 2505, 1},", "       {0xffffffff, -1, 0}, {0xffffffff, -1, 0},", "       {0xa64a, 2880, 1},", "       {0x1041a, 3315, 1},", "       {0x1e1a, 1751, 1},", "       {0x041a, 920, 1},", "       {0x011a, 210, 1},", "       {0x1f1a, 2112, 1},", "       {0x2c1a, 2499, 1},", "       {0xabbd, 1679, 1},", "       {0x0545, 1394, 1},", "       {0x054c, 1415, 1},", "       {0x10418, 3309, 1},", "       {0x1e18, 1748, 1},", "       {0x0418, 914, 1},", "       {0x0118, 207, 1},", "       {0x1f18, 2106, 1},", "       {0x2c18, 2493, 1},", "       {0x10bd, 2832, 1},", "       {0x2163, 2301, 1},", "       {0x054a, 1409, 1},", "       {0x1040e, 3279, 1},", "       {0x1e0e, 1733, 1},", "       {0x040e, 1028, 1},", "       {0x010e, 192, 1},", "       {0x1f0e, 2100, 1},", "       {0x2c0e, 2463, 1},", "       {0x1efc, 2076, 1},", "       {0x04fc, 1256, 1},", "       {0x01fc, 496, 1},", "       {0x1ffc, 96, 2},", "       {0x051c, 1304, 1},", "       {0x1040c, 3273, 1},", "       {0x1e0c, 1730, 1},", "       {0x040c, 1022, 1},", "       {0x010c, 189, 1},", "       {0x1f0c, 2094, 1},", "       {0x2c0c, 2457, 1},", "       {0x1f6d, 2217, 1},", "       {0x2c6d, 607, 1},", "       {0x051a, 1301, 1},", "       {0x24be, 2367, 1},", "       {0x10408, 3261, 1},", "       {0x1e08, 1724, 1},", "       {0x0408, 1010, 1},", "       {0x0108, 183, 1},", "       {0x1f08, 2082, 1},", "       {0x2c08, 2445, 1},", "       {0x04c9, 1178, 1},", "       {0x0518, 1298, 1},", "       {0x1fc9, 2235, 1},", "       {0xffffffff, -1, 0},", "       {0x24ba, 2355, 1},", "       {0x00c9, 105, 1},", "       {0x10416, 3303, 1},", "       {0x1e16, 1745, 1},", "       {0x0416, 908, 1},", "       {0x0116, 204, 1},", "       {0x050e, 1283, 1},", "       {0x2c16, 2487, 1},", "       {0x10414, 3297, 1},", "       {0x1e14, 1742, 1},", "       {0x0414, 902, 1},", "       {0x0114, 201, 1},", "       {0x042b, 971, 1},", "       {0x2c14, 2481, 1},", "       {0x1f2b, 2133, 1},", "       {0x2c2b, 2550, 1},", "       {0xffffffff, -1, 0},", "       {0x050c, 1280, 1},", "       {0x10406, 3255, 1},", "       {0x1e06, 1721, 1},", "       {0x0406, 1004, 1},", "       {0x0106, 180, 1},", "       {0x13fb, 1697, 1},", "       {0x2c06, 2439, 1},", "       {0x24c2, 2379, 1},", "       {0x118bd, 3597, 1},", "       {0xffffffff, -1, 0},", "       {0x0508, 1274, 1},", "       {0x10404, 3249, 1},", "       {0x1e04, 1718, 1},", "       {0x0404, 998, 1},", "       {0x0104, 177, 1},", "       {0x1f95, 194, 2},", "       {0x2c04, 2433, 1},", "       {0x0395, 752, 1},", "       {0x24ca, 2403, 1},", "       {0xab95, 1559, 1},", "       {0x0531, 1334, 1},", "       {0x10c95, 3420, 1},", "       {0x0516, 1295, 1},", "       {0x1e6c, 1875, 1},", "       {0x046c, 1052, 1},", "       {0x016c, 327, 1},", "       {0x1f6c, 2214, 1},", "       {0x216d, 2331, 1},", "       {0x0514, 1292, 1},", "       {0x0245, 697, 1},", "       {0x024c, 598, 1},", "       {0xa76c, 3084, 1},", "       {0x10400, 3237, 1},", "       {0x1e00, 1712, 1},", "       {0x0400, 986, 1},", "       {0x0100, 171, 1},", "       {0x24c4, 2385, 1},", "       {0x2c00, 2421, 1},", "       {0x0506, 1271, 1},", "       {0x024a, 595, 1},", "       {0x1fab, 224, 2},", "       {0xa66c, 2931, 1},", "       {0x03ab, 827, 1},", "       {0x24cf, 2418, 1},", "       {0xabab, 1625, 1},", "       {0xa7ab, 631, 1},", "       {0x10cab, 3486, 1},", "       {0xffffffff, -1, 0},", "       {0x0504, 1268, 1},", "       {0xffffffff, -1, 0},", "       {0x021c, 544, 1},", "       {0x01a9, 679, 1},", "       {0x1fa9, 214, 2},", "       {0x10ab, 2778, 1},", "       {0x03a9, 820, 1},", "       {0x212b, 92, 1},", "       {0xaba9, 1619, 1},", "       {0x1e88, 1917, 1},", "       {0x10ca9, 3480, 1},", "       {0x021a, 541, 1},", "       {0x1f88, 129, 2},", "       {0x2c88, 2598, 1},", "       {0x0388, 730, 1},", "       {0x13fd, 1703, 1},", "       {0xab88, 1520, 1},", "       {0x10a9, 2772, 1},", "       {0x10c88, 3381, 1},", "       {0xffffffff, -1, 0},", "       {0x0218, 538, 1},", "       {0x0500, 1262, 1},", "       {0x1f4d, 2187, 1},", "       {0x01a7, 393, 1},", "       {0x1fa7, 244, 2},", "       {0x004d, 34, 1},", "       {0x03a7, 814, 1},", "       {0xa688, 2946, 1},", "       {0xaba7, 1613, 1},", "       {0x020e, 523, 1},", "       {0x10ca7, 3474, 1},", "       {0x1e6a, 1872, 1},", "       {0x046a, 1049, 1},", "       {0x016a, 324, 1},", "       {0x1f6a, 2208, 1},", "       {0xffffffff, -1, 0},", "       {0x216c, 2328, 1},", "       {0x10a7, 2766, 1},", "       {0x01d1, 435, 1},", "       {0xa76a, 3081, 1},", "       {0x020c, 520, 1},", "       {0x03d1, 762, 1},", "       {0x00d1, 129, 1},", "       {0x1e68, 1869, 1},", "       {0x0468, 1046, 1},", "       {0x0168, 321, 1},", "       {0x1f68, 2202, 1},", "       {0xffffffff, -1, 0},", "       {0xff31, 3207, 1},", "       {0xa66a, 2928, 1},", "       {0x0208, 514, 1},", "       {0xa768, 3078, 1},", "       {0x1e64, 1863, 1},", "       {0x0464, 1040, 1},", "       {0x0164, 315, 1},", "       {0x054d, 1418, 1},", "       {0x2c64, 673, 1},", "       {0xffffffff, -1, 0},", "       {0xff2b, 3189, 1},", "       {0xffffffff, -1, 0},", "       {0xa764, 3072, 1},", "       {0xa668, 2925, 1},", "       {0x0216, 535, 1},", "       {0xffffffff, -1, 0},", "       {0x118ab, 3543, 1},", "       {0x1e62, 1860, 1},", "       {0x0462, 1037, 1},", "       {0x0162, 312, 1},", "       {0x0214, 532, 1},", "       {0x2c62, 655, 1},", "       {0xa664, 2919, 1},", "       {0x1ed2, 2013, 1},", "       {0x04d2, 1193, 1},", "       {0xa762, 3069, 1},", "       {0x1fd2, 20, 3},", "       {0x2cd2, 2709, 1},", "       {0x118a9, 3537, 1},", "       {0x00d2, 132, 1},", "       {0x0206, 511, 1},", "       {0x10420, 3333, 1},", "       {0x1e20, 1760, 1},", "       {0x0420, 938, 1},", "       {0x0120, 219, 1},", "       {0xa662, 2916, 1},", "       {0x2c20, 2517, 1},", "       {0x1e60, 1856, 1},", "       {0x0460, 1034, 1},", "       {0x0160, 309, 1},", "       {0x0204, 508, 1},", "       {0x2c60, 2562, 1},", "       {0xffffffff, -1, 0},", "       {0x24bd, 2364, 1},", "       {0x216a, 2322, 1},", "       {0xa760, 3066, 1},", "       {0xffffffff, -1, 0},", "       {0xfb16, 125, 2},", "       {0x118a7, 3531, 1},", "       {0x1efa, 2073, 1},", "       {0x04fa, 1253, 1},", "       {0x01fa, 493, 1},", "       {0x1ffa, 2262, 1},", "       {0xfb14, 109, 2},", "       {0x03fa, 887, 1},", "       {0xa660, 2913, 1},", "       {0x2168, 2316, 1},", "       {0x01b7, 700, 1},", "       {0x1fb7, 10, 3},", "       {0x1f6b, 2211, 1},", "       {0x2c6b, 2577, 1},", "       {0x0200, 502, 1},", "       {0xabb7, 1661, 1},", "       {0xfb06, 29, 2},", "       {0x1e56, 1841, 1},", "       {0x2164, 2304, 1},", "       {0x0156, 294, 1},", "       {0x1f56, 62, 3},", "       {0x0520, 1310, 1},", "       {0x004f, 40, 1},", "       {0x0056, 62, 1},", "       {0x10b7, 2814, 1},", "       {0xa756, 3051, 1},", "       {0xfb04, 5, 3},", "       {0x1e78, 1893, 1},", "       {0x0478, 1070, 1},", "       {0x0178, 168, 1},", "       {0x1e54, 1838, 1},", "       {0x2162, 2298, 1},", "       {0x0154, 291, 1},", "       {0x1f54, 57, 3},", "       {0xab78, 1472, 1},", "       {0xa656, 2898, 1},", "       {0x0054, 56, 1},", "       {0x1e52, 1835, 1},", "       {0xa754, 3048, 1},", "       {0x0152, 288, 1},", "       {0x1f52, 52, 3},", "       {0x24c9, 2400, 1},", "       {0x1e32, 1787, 1},", "       {0x0052, 49, 1},", "       {0x0132, 243, 1},", "       {0xa752, 3045, 1},", "       {0xffffffff, -1, 0},", "       {0xfb00, 4, 2},", "       {0xa654, 2895, 1},", "       {0xffffffff, -1, 0},", "       {0xa732, 2997, 1},", "       {0x2160, 2292, 1},", "       {0x054f, 1424, 1},", "       {0x0556, 1445, 1},", "       {0x1e50, 1832, 1},", "       {0xa652, 2892, 1},", "       {0x0150, 285, 1},", "       {0x1f50, 84, 2},", "       {0x017b, 348, 1},", "       {0x1e4e, 1829, 1},", "       {0x0050, 43, 1},", "       {0x014e, 282, 1},", "       {0xa750, 3042, 1},", "       {0xab7b, 1481, 1},", "       {0xa77b, 3093, 1},", "       {0x004e, 37, 1},", "       {0x0554, 1439, 1},", "       {0xa74e, 3039, 1},", "       {0x1e48, 1820, 1},", "       {0xffffffff, -1, 0},", "       {0x216b, 2325, 1},", "       {0x1f48, 2172, 1},", "       {0xa650, 2889, 1},", "       {0x0552, 1433, 1},", "       {0x0048, 21, 1},", "       {0xffffffff, -1, 0},", "       {0xa748, 3030, 1},", "       {0xa64e, 2886, 1},", "       {0x0532, 1337, 1},", "       {0x1041e, 3327, 1},", "       {0x1e1e, 1757, 1},", "       {0x041e, 932, 1},", "       {0x011e, 216, 1},", "       {0x118b7, 3579, 1},", "       {0x2c1e, 2511, 1},", "       {0xffffffff, -1, 0},", "       {0xa648, 2877, 1},", "       {0x1ff9, 2253, 1},", "       {0xffffffff, -1, 0},", "       {0x03f9, 878, 1},", "       {0x0550, 1427, 1},", "       {0x10412, 3291, 1},", "       {0x1e12, 1739, 1},", "       {0x0412, 896, 1},", "       {0x0112, 198, 1},", "       {0x054e, 1421, 1},", "       {0x2c12, 2475, 1},", "       {0x10410, 3285, 1},", "       {0x1e10, 1736, 1},", "       {0x0410, 890, 1},", "       {0x0110, 195, 1},", "       {0xffffffff, -1, 0},", "       {0x2c10, 2469, 1},", "       {0x2132, 2289, 1},", "       {0x0548, 1403, 1},", "       {0x1ef8, 2070, 1},", "       {0x04f8, 1250, 1},", "       {0x01f8, 490, 1},", "       {0x1ff8, 2250, 1},", "       {0x0220, 381, 1},", "       {0x1ee2, 2037, 1},", "       {0x04e2, 1217, 1},", "       {0x01e2, 462, 1},", "       {0x1fe2, 36, 3},", "       {0x2ce2, 2733, 1},", "       {0x03e2, 857, 1},", "       {0x051e, 1307, 1},", "       {0x1ede, 2031, 1},", "       {0x04de, 1211, 1},", "       {0x01de, 456, 1},", "       {0xffffffff, -1, 0},", "       {0x2cde, 2727, 1},", "       {0x03de, 851, 1},", "       {0x00de, 165, 1},", "       {0x1f69, 2205, 1},", "       {0x2c69, 2574, 1},", "       {0x1eda, 2025, 1},", "       {0x04da, 1205, 1},", "       {0x0512, 1289, 1},", "       {0x1fda, 2244, 1},", "       {0x2cda, 2721, 1},", "       {0x03da, 845, 1},", "       {0x00da, 153, 1},", "       {0xffffffff, -1, 0},", "       {0x0510, 1286, 1},", "       {0x1ed8, 2022, 1},", "       {0x04d8, 1202, 1},", "       {0xffffffff, -1, 0},", "       {0x1fd8, 2274, 1},", "       {0x2cd8, 2718, 1},", "       {0x03d8, 842, 1},", "       {0x00d8, 147, 1},", "       {0x1ed6, 2019, 1},", "       {0x04d6, 1199, 1},", "       {0xffffffff, -1, 0},", "       {0x1fd6, 76, 2},", "       {0x2cd6, 2715, 1},", "       {0x03d6, 792, 1},", "       {0x00d6, 144, 1},", "       {0x1ec8, 1998, 1},", "       {0xffffffff, -1, 0},", "       {0x01c8, 421, 1},", "       {0x1fc8, 2232, 1},", "       {0x2cc8, 2694, 1},", "       {0xff32, 3210, 1},", "       {0x00c8, 102, 1},", "       {0x04c7, 1175, 1},", "       {0x01c7, 421, 1},", "       {0x1fc7, 15, 3},", "       {0x1ec0, 1986, 1},", "       {0x04c0, 1187, 1},", "       {0x00c7, 99, 1},", "       {0xffffffff, -1, 0},", "       {0x2cc0, 2682, 1},", "       {0x0179, 345, 1},", "       {0x00c0, 77, 1},", "       {0x0232, 574, 1},", "       {0x01b3, 402, 1},", "       {0x1fb3, 62, 2},", "       {0xab79, 1475, 1},", "       {0xa779, 3090, 1},", "       {0x10c7, 2859, 1},", "       {0xabb3, 1649, 1},", "       {0xa7b3, 3156, 1},", "       {0x1fa5, 234, 2},", "       {0x10c0, 2841, 1},", "       {0x03a5, 807, 1},", "       {0xffffffff, -1, 0},", "       {0xaba5, 1607, 1},", "       {0x01b1, 691, 1},", "       {0x10ca5, 3468, 1},", "       {0x10b3, 2802, 1},", "       {0x2169, 2319, 1},", "       {0x024e, 601, 1},", "       {0xabb1, 1643, 1},", "       {0xa7b1, 682, 1},", "       {0x10cb1, 3504, 1},", "       {0x10a5, 2760, 1},", "       {0xffffffff, -1, 0},", "       {0x01af, 399, 1},", "       {0x1faf, 244, 2},", "       {0xffffffff, -1, 0},", "       {0x0248, 592, 1},", "       {0x10b1, 2796, 1},", "       {0xabaf, 1637, 1},", "       {0x1fad, 234, 2},", "       {0x10caf, 3498, 1},", "       {0x04cd, 1184, 1},", "       {0x01cd, 429, 1},", "       {0xabad, 1631, 1},", "       {0xa7ad, 658, 1},", "       {0x10cad, 3492, 1},", "       {0x00cd, 117, 1},", "       {0x10af, 2790, 1},", "       {0x021e, 547, 1},", "       {0x1fa3, 224, 2},", "       {0xffffffff, -1, 0},", "       {0x03a3, 800, 1},", "       {0x10ad, 2784, 1},", "       {0xaba3, 1601, 1},", "       {0xffffffff, -1, 0},", "       {0x10ca3, 3462, 1},", "       {0x10cd, 2862, 1},", "       {0x1fa1, 214, 2},", "       {0x24b7, 2346, 1},", "       {0x03a1, 796, 1},", "       {0x0212, 529, 1},", "       {0xaba1, 1595, 1},", "       {0x10a3, 2754, 1},", "       {0x10ca1, 3456, 1},", "       {0x01d3, 438, 1},", "       {0x1fd3, 25, 3},", "       {0x0210, 526, 1},", "       {0xffffffff, -1, 0},", "       {0x00d3, 135, 1},", "       {0x1e97, 34, 2},", "       {0x10a1, 2748, 1},", "       {0x0197, 649, 1},", "       {0x1f97, 204, 2},", "       {0xffffffff, -1, 0},", "       {0x0397, 759, 1},", "       {0x1041d, 3324, 1},", "       {0xab97, 1565, 1},", "       {0x041d, 929, 1},", "       {0x10c97, 3426, 1},", "       {0x1f1d, 2121, 1},", "       {0x2c1d, 2508, 1},", "       {0x1e72, 1884, 1},", "       {0x0472, 1061, 1},", "       {0x0172, 336, 1},", "       {0x118b3, 3567, 1},", "       {0x2c72, 2580, 1},", "       {0x0372, 712, 1},", "       {0x1041b, 3318, 1},", "       {0xab72, 1454, 1},", "       {0x041b, 923, 1},", "       {0x118a5, 3525, 1},", "       {0x1f1b, 2115, 1},", "       {0x2c1b, 2502, 1},", "       {0x1e70, 1881, 1},", "       {0x0470, 1058, 1},", "       {0x0170, 333, 1},", "       {0x118b1, 3561, 1},", "       {0x2c70, 610, 1},", "       {0x0370, 709, 1},", "       {0x1e46, 1817, 1},", "       {0xab70, 1448, 1},", "       {0x1e66, 1866, 1},", "       {0x0466, 1043, 1},", "       {0x0166, 318, 1},", "       {0x1e44, 1814, 1},", "       {0x0046, 15, 1},", "       {0x118af, 3555, 1},", "       {0xa746, 3027, 1},", "       {0xffffffff, -1, 0},", "       {0xa766, 3075, 1},", "       {0x0044, 9, 1},", "       {0x118ad, 3549, 1},", "       {0xa744, 3024, 1},", "       {0x1e7a, 1896, 1},", "       {0x047a, 1073, 1},", "       {0x1e3a, 1799, 1},", "       {0xffffffff, -1, 0},", "       {0xa646, 2874, 1},", "       {0x1f3a, 2154, 1},", "       {0xa666, 2922, 1},", "       {0xab7a, 1478, 1},", "       {0x118a3, 3519, 1},", "       {0xa644, 2871, 1},", "       {0xa73a, 3009, 1},", "       {0xffffffff, -1, 0},", "       {0x1ef4, 2064, 1},", "       {0x04f4, 1244, 1},", "       {0x01f4, 487, 1},", "       {0x1ff4, 101, 2},", "       {0x118a1, 3513, 1},", "       {0x03f4, 762, 1},", "       {0x1eec, 2052, 1},", "       {0x04ec, 1232, 1},", "       {0x01ec, 477, 1},", "       {0x1fec, 2286, 1},", "       {0x0546, 1397, 1},", "       {0x03ec, 872, 1},", "       {0xffffffff, -1, 0},", "       {0x013f, 261, 1},", "       {0x1f3f, 2169, 1},", "       {0x0544, 1391, 1},", "       {0x1eea, 2049, 1},", "       {0x04ea, 1229, 1},", "       {0x01ea, 474, 1},", "       {0x1fea, 2256, 1},", "       {0xffffffff, -1, 0},", "       {0x03ea, 869, 1},", "       {0x1ee8, 2046, 1},", "       {0x04e8, 1226, 1},", "       {0x01e8, 471, 1},", "       {0x1fe8, 2280, 1},", "       {0x053a, 1361, 1},", "       {0x03e8, 866, 1},", "       {0x1ee6, 2043, 1},", "       {0x04e6, 1223, 1},", "       {0x01e6, 468, 1},", "       {0x1fe6, 88, 2},", "       {0x1f4b, 2181, 1},", "       {0x03e6, 863, 1},", "       {0x1e5e, 1853, 1},", "       {0x004b, 27, 1},", "       {0x015e, 306, 1},", "       {0x2166, 2310, 1},", "       {0x1ee4, 2040, 1},", "       {0x04e4, 1220, 1},", "       {0x01e4, 465, 1},", "       {0x1fe4, 80, 2},", "       {0xa75e, 3063, 1},", "       {0x03e4, 860, 1},", "       {0x1ee0, 2034, 1},", "       {0x04e0, 1214, 1},", "       {0x01e0, 459, 1},", "       {0x053f, 1376, 1},", "       {0x2ce0, 2730, 1},", "       {0x03e0, 854, 1},", "       {0x1edc, 2028, 1},", "       {0x04dc, 1208, 1},", "       {0xa65e, 2910, 1},", "       {0xffffffff, -1, 0},", "       {0x2cdc, 2724, 1},", "       {0x03dc, 848, 1},", "       {0x00dc, 159, 1},", "       {0x1ed0, 2010, 1},", "       {0x04d0, 1190, 1},", "       {0xffffffff, -1, 0}, {0xffffffff, -1, 0},", "       {0x2cd0, 2706, 1},", "       {0x03d0, 742, 1},", "       {0x00d0, 126, 1},", "       {0x1ecc, 2004, 1},", "       {0x054b, 1412, 1},", "       {0xffffffff, -1, 0},", "       {0x1fcc, 71, 2},", "       {0x2ccc, 2700, 1},", "       {0x1ec6, 1995, 1},", "       {0x00cc, 114, 1},", "       {0xffffffff, -1, 0},", "       {0x1fc6, 67, 2},", "       {0x2cc6, 2691, 1},", "       {0x24c8, 2397, 1},", "       {0x00c6, 96, 1},", "       {0x04c5, 1172, 1},", "       {0x01c5, 417, 1},", "       {0xffffffff, -1, 0},", "       {0x1fbb, 2229, 1},", "       {0x24c7, 2394, 1},", "       {0x00c5, 92, 1},", "       {0x1fb9, 2271, 1},", "       {0xabbb, 1673, 1},", "       {0x24c0, 2373, 1},", "       {0x04c3, 1169, 1},", "       {0xabb9, 1667, 1},", "       {0x1fc3, 71, 2},", "       {0xffffffff, -1, 0}, {0xffffffff, -1, 0},", "       {0x00c3, 86, 1},", "       {0x10c5, 2856, 1},", "       {0x10bb, 2826, 1},", "       {0x1ed4, 2016, 1},", "       {0x04d4, 1196, 1},", "       {0x10b9, 2820, 1},", "       {0x13fc, 1700, 1},", "       {0x2cd4, 2712, 1},", "       {0x0246, 589, 1},", "       {0x00d4, 138, 1},", "       {0x10c3, 2850, 1},", "       {0xffffffff, -1, 0},", "       {0xff3a, 3234, 1},", "       {0x0244, 688, 1},", "       {0x019f, 670, 1},", "       {0x1f9f, 204, 2},", "       {0xffffffff, -1, 0},", "       {0x039f, 789, 1},", "       {0xffffffff, -1, 0},", "       {0xab9f, 1589, 1},", "       {0xffffffff, -1, 0},", "       {0x10c9f, 3450, 1},", "       {0x019d, 667, 1},", "       {0x1f9d, 194, 2},", "       {0x023a, 2565, 1},", "       {0x039d, 783, 1},", "       {0x1e5a, 1847, 1},", "       {0xab9d, 1583, 1},", "       {0x015a, 300, 1},", "       {0x10c9d, 3444, 1},", "       {0x1e9b, 1856, 1},", "       {0x24cd, 2412, 1},", "       {0x005a, 74, 1},", "       {0x1f9b, 184, 2},", "       {0xa75a, 3057, 1},", "       {0x039b, 776, 1},", "       {0x1ece, 2007, 1},", "       {0xab9b, 1577, 1},", "       {0x1e99, 42, 2},", "       {0x10c9b, 3438, 1},", "       {0x2cce, 2703, 1},", "       {0x1f99, 174, 2},", "       {0x00ce, 120, 1},", "       {0x0399, 767, 1},", "       {0xa65a, 2904, 1},", "       {0xab99, 1571, 1},", "       {0xffffffff, -1, 0},", "       {0x10c99, 3432, 1},", "       {0x0193, 634, 1},", "       {0x1f93, 184, 2},", "       {0x1e58, 1844, 1},", "       {0x0393, 746, 1},", "       {0x0158, 297, 1},", "       {0xab93, 1553, 1},", "       {0xffffffff, -1, 0},", "       {0x10c93, 3414, 1},", "       {0x0058, 68, 1},", "       {0x042d, 977, 1},", "       {0xa758, 3054, 1},", "       {0x1f2d, 2139, 1},", "       {0x2c2d, 2556, 1},", "       {0x118bb, 3591, 1},", "       {0x0191, 369, 1},", "       {0x1f91, 174, 2},", "       {0x118b9, 3585, 1},", "       {0x0391, 739, 1},", "       {0xffffffff, -1, 0},", "       {0xab91, 1547, 1},", "       {0xa658, 2901, 1},", "       {0x10c91, 3408, 1},", "       {0x018f, 625, 1},", "       {0x1f8f, 164, 2},", "       {0xffffffff, -1, 0},", "       {0x038f, 836, 1},", "       {0xffffffff, -1, 0},", "       {0xab8f, 1541, 1},", "       {0xffffffff, -1, 0},", "       {0x10c8f, 3402, 1},", "       {0x018b, 366, 1},", "       {0x1f8b, 144, 2},", "       {0xffffffff, -1, 0},", "       {0x0187, 363, 1},", "       {0x1f87, 164, 2},", "       {0xab8b, 1529, 1},", "       {0xa78b, 3111, 1},", "       {0x10c8b, 3390, 1},", "       {0xab87, 1517, 1},", "       {0x04c1, 1166, 1},", "       {0x10c87, 3378, 1},", "       {0x1e7e, 1902, 1},", "       {0x047e, 1079, 1},", "       {0xffffffff, -1, 0},", "       {0x00c1, 80, 1},", "       {0x2c7e, 580, 1},", "       {0xffffffff, -1, 0}, {0xffffffff, -1, 0},", "       {0xab7e, 1490, 1},", "       {0xa77e, 3096, 1},", "       {0x1e76, 1890, 1},", "       {0x0476, 1067, 1},", "       {0x0176, 342, 1},", "       {0x1e42, 1811, 1},", "       {0x10c1, 2844, 1},", "       {0x0376, 715, 1},", "       {0x1e36, 1793, 1},", "       {0xab76, 1466, 1},", "       {0x0136, 249, 1},", "       {0x0042, 3, 1},", "       {0x1e3e, 1805, 1},", "       {0xa742, 3021, 1},", "       {0x1e38, 1796, 1},", "       {0x1f3e, 2166, 1},", "       {0xa736, 3003, 1},", "       {0x1f38, 2148, 1},", "       {0xffffffff, -1, 0},", "       {0x0587, 105, 2},", "       {0xa73e, 3015, 1},", "       {0xffffffff, -1, 0},", "       {0xa738, 3006, 1},", "       {0xa642, 2868, 1},", "       {0x1e5c, 1850, 1},", "       {0x1e34, 1790, 1},", "       {0x015c, 303, 1},", "       {0x0134, 246, 1},", "       {0x1ef6, 2067, 1},", "       {0x04f6, 1247, 1},", "       {0x01f6, 372, 1},", "       {0x1ff6, 92, 2},", "       {0xa75c, 3060, 1},", "       {0xa734, 3000, 1},", "       {0x1ef0, 2058, 1},", "       {0x04f0, 1238, 1},", "       {0x01f0, 20, 2},", "       {0xffffffff, -1, 0},", "       {0x1e30, 1784, 1},", "       {0x03f0, 772, 1},", "       {0x0130, 261, 2},", "       {0x0542, 1385, 1},", "       {0xa65c, 2907, 1},", "       {0x1f83, 144, 2},", "       {0x0536, 1349, 1},", "       {0xffffffff, -1, 0}, {0xffffffff, -1, 0},", "       {0xab83, 1505, 1},", "       {0x053e, 1373, 1},", "       {0x10c83, 3366, 1},", "       {0x0538, 1355, 1},", "       {0x1eee, 2055, 1},", "       {0x04ee, 1235, 1},", "       {0x01ee, 480, 1},", "       {0x1f8d, 154, 2},", "       {0xffffffff, -1, 0},", "       {0x03ee, 875, 1},", "       {0xffffffff, -1, 0},", "       {0xab8d, 1535, 1},", "       {0xa78d, 643, 1},", "       {0x10c8d, 3396, 1},", "       {0x0534, 1343, 1},", "       {0x0181, 613, 1},", "       {0x1f81, 134, 2},", "       {0x013d, 258, 1},", "       {0x1f3d, 2163, 1},", "       {0xffffffff, -1, 0},", "       {0xab81, 1499, 1},", "       {0x017f, 52, 1},", "       {0x10c81, 3360, 1},", "       {0x2c7f, 583, 1},", "       {0x037f, 881, 1},", "       {0xff2d, 3195, 1},", "       {0xab7f, 1493, 1},", "       {0x1e74, 1887, 1},", "       {0x0474, 1064, 1},", "       {0x0174, 339, 1},", "       {0x1e3c, 1802, 1},", "       {0x0149, 46, 2},", "       {0x1f49, 2175, 1},", "       {0x1f3c, 2160, 1},", "       {0xab74, 1460, 1},", "       {0x0049, 3606, 1},", "       {0x0143, 267, 1},", "       {0x24cc, 2409, 1},", "       {0xa73c, 3012, 1},", "       {0xffffffff, -1, 0},", "       {0x0043, 6, 1},", "       {0x0141, 264, 1},", "       {0x24c6, 2391, 1},", "       {0x013b, 255, 1},", "       {0x1f3b, 2157, 1},", "       {0x0041, 0, 1},", "       {0x0139, 252, 1},", "       {0x1f39, 2151, 1},", "       {0x24c5, 2388, 1},", "       {0x24bb, 2358, 1},", "       {0x13fa, 1694, 1},", "       {0x053d, 1370, 1},", "       {0x24b9, 2352, 1},", "       {0x0429, 965, 1},", "       {0x2183, 2340, 1},", "       {0x1f29, 2127, 1},", "       {0x2c29, 2544, 1},", "       {0x24c3, 2382, 1},", "       {0x10427, 3354, 1},", "       {0x10425, 3348, 1},", "       {0x0427, 959, 1},", "       {0x0425, 953, 1},", "       {0xffffffff, -1, 0},", "       {0x2c27, 2538, 1},", "       {0x2c25, 2532, 1},", "       {0x0549, 1406, 1},", "       {0x053c, 1367, 1},", "       {0x10423, 3342, 1},", "       {0xffffffff, -1, 0},", "       {0x0423, 947, 1},", "       {0x0543, 1388, 1},", "       {0xffffffff, -1, 0},", "       {0x2c23, 2526, 1},", "       {0xff36, 3222, 1},", "       {0xffffffff, -1, 0},", "       {0x0541, 1382, 1},", "       {0x10421, 3336, 1},", "       {0x053b, 1364, 1},", "       {0x0421, 941, 1},", "       {0xff38, 3228, 1},", "       {0x0539, 1358, 1},", "       {0x2c21, 2520, 1},", "       {0x10419, 3312, 1},", "       {0x10417, 3306, 1},", "       {0x0419, 917, 1},", "       {0x0417, 911, 1},", "       {0x1f19, 2109, 1},", "       {0x2c19, 2496, 1},", "       {0x2c17, 2490, 1},", "       {0x023e, 2568, 1},", "       {0xff34, 3216, 1},", "       {0x10415, 3300, 1},", "       {0x10413, 3294, 1},", "       {0x0415, 905, 1},", "       {0x0413, 899, 1},", "       {0xffffffff, -1, 0},", "       {0x2c15, 2484, 1},", "       {0x2c13, 2478, 1},", "       {0xffffffff, -1, 0},", "       {0x24ce, 2415, 1},", "       {0x1040f, 3282, 1},", "       {0xffffffff, -1, 0},", "       {0x040f, 1031, 1},", "       {0xff30, 3204, 1},", "       {0x1f0f, 2103, 1},", "       {0x2c0f, 2466, 1},", "       {0x1040d, 3276, 1},", "       {0xffffffff, -1, 0},", "       {0x040d, 1025, 1},", "       {0x0147, 273, 1},", "       {0x1f0d, 2097, 1},", "       {0x2c0d, 2460, 1},", "       {0x1040b, 3270, 1},", "       {0x0047, 18, 1},", "       {0x040b, 1019, 1},", "       {0x0230, 571, 1},", "       {0x1f0b, 2091, 1},", "       {0x2c0b, 2454, 1},", "       {0x10409, 3264, 1},", "       {0x10405, 3252, 1},", "       {0x0409, 1013, 1},", "       {0x0405, 1001, 1},", "       {0x1f09, 2085, 1},", "       {0x2c09, 2448, 1},", "       {0x2c05, 2436, 1},", "       {0x10403, 3246, 1},", "       {0x10401, 3240, 1},", "       {0x0403, 995, 1},", "       {0x0401, 989, 1},", "       {0xffffffff, -1, 0},", "       {0x2c03, 2430, 1},", "       {0x2c01, 2424, 1},", "       {0x13f9, 1691, 1},", "       {0x042f, 983, 1},", "       {0xffffffff, -1, 0},", "       {0x1f2f, 2145, 1},", "       {0x1041f, 3330, 1},", "       {0xffffffff, -1, 0},", "       {0x041f, 935, 1},", "       {0x023d, 378, 1},", "       {0x10411, 3288, 1},", "       {0x2c1f, 2514, 1},", "       {0x0411, 893, 1},", "       {0x0547, 1400, 1},", "       {0xffffffff, -1, 0},", "       {0x2c11, 2472, 1},", "       {0x10407, 3258, 1},", "       {0xffffffff, -1, 0},", "       {0x0407, 1007, 1},", "       {0x24c1, 2376, 1},", "       {0xffffffff, -1, 0},", "       {0x2c07, 2442, 1},", "       {0xffffffff, -1, 0},", "       {0x13f8, 1688, 1},", "       {0xffffffff, -1, 0}, {0xffffffff, -1, 0},", "       {0xff39, 3231, 1},", "       {0xffffffff, -1, 0},", "       {0x0243, 354, 1},", "       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},", "       {0x0241, 586, 1},", "       {0xff29, 3183, 1},", "       {0x023b, 577, 1},", "       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},", "       {0xff27, 3177, 1},", "       {0xff25, 3171, 1},", "       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},", "       {0xffffffff, -1, 0}, {0xffffffff, -1, 0},", "       {0xff23, 3165, 1},", "       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},", "       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},", "       {0xff21, 3159, 1},", "       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},", "       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},", "       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},", "       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},", "       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},", "       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},", "       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},", "       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},", "       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},", "       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},", "       {0xffffffff, -1, 0},", "       {0xfb17, 117, 2},", "       {0xffffffff, -1, 0}, {0xffffffff, -1, 0},", "       {0xff2f, 3201, 1},", "       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},", "       {0xfb15, 113, 2},", "       {0xfb13, 121, 2},", "       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},", "       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},", "       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},", "       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},", "       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},", "       {0xffffffff, -1, 0},", "       {0xfb05, 29, 2},", "       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},", "       {0xfb03, 0, 3},", "       {0xfb01, 8, 2}", "     };", "   if (0 == 0)", "     {", "       int key = hash(&code);", "       if (key <= MAX_HASH_VALUE && key >= 0)", "          {", "            OnigCodePoint gcode = wordlist[key].code;", "          if (code == gcode)", "           if (code == gcode && wordlist[key].index >= 0)", "              return &wordlist[key];", "          }", "      }", "   return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" static int burl_normalize_2F_to_slash_fix (buffer *b, int qs, int i)", " {", "     char * const s = b->ptr;", "     const int blen = (int)buffer_string_length(b);", "     const int used = qs < 0 ? blen : qs;", "     int j = i;", "     for (; i < used; ++i, ++j) {", "         s[j] = s[i];", "         if (s[i] == '%' && s[i+1] == '2' && s[i+2] == 'F') {", "             s[j] = '/';", "             i+=2;", "          }", "      }", "      if (qs >= 0) {", "        memmove(s+j, s+qs, blen - qs);", "        j += blen - qs;", "         const int qslen = blen - qs;", "         memmove(s+j, s+qs, (size_t)qslen);", "         qs = j;", "         j += qslen;", "      }", "      buffer_string_set_length(b, j);", "      return qs;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": [" static bool do_write_pids(pid_t tpid, const char *contrl, const char *cg, const char *file, const char *buf)", " bool hostuid_to_ns(uid_t uid, pid_t pid, uid_t *answer)", " {", " \tFILE *f;", " \tchar line[400];", " \tsprintf(line, \"/proc/%d/uid_map\", pid);", " \tif ((f = fopen(line, \"r\")) == NULL) {", " \t\treturn false;", " \t}", " \t*answer = convert_id_to_ns(f, uid);", " \tfclose(f);", " \tif (*answer == -1)", " \t\treturn false;", " \treturn true;", " }", " void get_pid_creds(pid_t pid, uid_t *uid, gid_t *gid)", " {", " \tchar line[400];", " \tuid_t u;", " \tgid_t g;", " \tFILE *f;", " \t*uid = -1;", " \t*gid = -1;", " \tsprintf(line, \"/proc/%d/status\", pid);", " \tif ((f = fopen(line, \"r\")) == NULL) {", " \t\tfprintf(stderr, \"Error opening %s: %s\\n\", line, strerror(errno));", " \t\treturn;", " \t}", " \twhile (fgets(line, 400, f)) {", " \t\tif (strncmp(line, \"Uid:\", 4) == 0) {", " \t\t\tif (sscanf(line+4, \"%u\", &u) != 1) {", " \t\t\t\tfprintf(stderr, \"bad uid line for pid %u\\n\", pid);", " \t\t\t\tfclose(f);", " \t\t\t\treturn;", " \t\t\t}", " \t\t\t*uid = u;", " \t\t} else if (strncmp(line, \"Gid:\", 4) == 0) {", " \t\t\tif (sscanf(line+4, \"%u\", &g) != 1) {", " \t\t\t\tfprintf(stderr, \"bad gid line for pid %u\\n\", pid);", " \t\t\t\tfclose(f);", " \t\t\t\treturn;", " \t\t\t}", " \t\t\t*gid = g;", " \t\t}", " \t}", " \tfclose(f);", " }", " bool may_move_pid(pid_t r, uid_t r_uid, pid_t v)", " {", " \tuid_t v_uid, tmpuid;", " \tgid_t v_gid;", " \tif (r == v)", " \t\treturn true;", " \tif (r_uid == 0)", " \t\treturn true;", " \tget_pid_creds(v, &v_uid, &v_gid);", " \tif (r_uid == v_uid)", " \t\treturn true;", " \tif (hostuid_to_ns(r_uid, r, &tmpuid) && tmpuid == 0", " \t\t\t&& hostuid_to_ns(v_uid, r, &tmpuid))", " \t\treturn true;", " \treturn false;", " }", " static bool do_write_pids(pid_t tpid, uid_t tuid, const char *contrl, const char *cg,", " \t\tconst char *file, const char *buf)", "  {", "  \tint sock[2] = {-1, -1};", "  \tpid_t qpid, cpid = -1;", " \tFILE *pids_file = NULL;", " \tbool answer = false, fail = false;", " \tpids_file = open_pids_file(contrl, cg);", " \tif (!pids_file)", " \t\treturn false;", " \tif (socketpair(AF_UNIX, SOCK_DGRAM, 0, sock) < 0) {", " \t\tperror(\"socketpair\");", " \t\tgoto out;", " \t}", " \tcpid = fork();", " \tif (cpid == -1)", " \t\tgoto out;", " \tif (!cpid) {  ", " \t\tfclose(pids_file);", " \t\tpid_from_ns_wrapper(sock[1], tpid);", " \t}", " \tconst char *ptr = buf;", " \twhile (sscanf(ptr, \"%d\", &qpid) == 1) {", " \t\tstruct ucred cred;", " \t\tchar v;", " \t\tif (write(sock[0], &qpid, sizeof(qpid)) != sizeof(qpid)) {", " \t\t\tfprintf(stderr, \"%s: error writing pid to child: %s\\n\",", " \t\t\t\t__func__, strerror(errno));", " \t\t\tgoto out;", " \t\t}", "  \t\tif (recv_creds(sock[0], &cred, &v)) {", "  \t\t\tif (v == '0') {", " \t\t\t\tif (!may_move_pid(tpid, tuid, cred.pid)) {", " \t\t\t\t\tfail = true;", " \t\t\t\t\tbreak;", " \t\t\t\t}", "  \t\t\t\tif (fprintf(pids_file, \"%d\", (int) cred.pid) < 0)", "  \t\t\t\t\tfail = true;", "  \t\t\t}", " \t\t}", " \t\tptr = strchr(ptr, '\\n');", " \t\tif (!ptr)", " \t\t\tbreak;", " \t\tptr++;", " \t}", " \tqpid = -1;", " \tif (write(sock[0], &qpid ,sizeof(qpid)) != sizeof(qpid))", " \t\tfprintf(stderr, \"Warning: failed to ask child to exit\\n\");", " \tif (!fail)", " \t\tanswer = true;", " out:", " \tif (cpid != -1)", " \t\twait_for_pid(cpid);", " \tif (sock[0] != -1) {", " \t\tclose(sock[0]);", " \t\tclose(sock[1]);", " \t}", " \tif (pids_file) {", " \t\tif (fclose(pids_file) != 0)", " \t\t\tanswer = false;", " \t}", " \treturn answer;", " }"], "ner_tags": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int store_icy(URLContext *h, int size)", "  {", "      HTTPContext *s = h->priv_data;", "    int remaining = s->icy_metaint - s->icy_data_read;", "     uint64_t remaining;", "    if (remaining < 0)", "     if (s->icy_metaint < s->icy_data_read)", "          return AVERROR_INVALIDDATA;", "     remaining = s->icy_metaint - s->icy_data_read;", "      if (!remaining) {", "         uint8_t ch;", "         int len = http_read_stream_all(h, &ch, 1);", "         if (len < 0)", "             return len;", "         if (ch > 0) {", "             char data[255 * 16 + 1];", "             int ret;", "             len = ch * 16;", "             ret = http_read_stream_all(h, data, len);", "             if (ret < 0)", "                 return ret;", "             data[len + 1] = 0;", "             if ((ret = av_opt_set(s, \"icy_metadata_packet\", data, 0)) < 0)", "                 return ret;", "             update_metadata(s, data);", "         }", "         s->icy_data_read = 0;", "         remaining        = s->icy_metaint;", "     }", "     return FFMIN(size, remaining);", " }"], "ner_tags": [0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" formUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form)", " {", "     Buffer save;", "     char *p;", "     int spos, epos, rows, c_rows, pos, col = 0;", "     Line *l;", "     copyBuffer(&save, buf);", "     gotoLine(buf, a->start.line);", "     switch (form->type) {", "     case FORM_TEXTAREA:", "     case FORM_INPUT_TEXT:", "     case FORM_INPUT_FILE:", "     case FORM_INPUT_PASSWORD:", "     case FORM_INPUT_CHECKBOX:", "     case FORM_INPUT_RADIO:", " #ifdef MENU_SELECT", "     case FORM_SELECT:", " #endif\t\t\t\t ", " \tspos = a->start.pos;", " \tepos = a->end.pos;", " \tbreak;", "     default:", " \tspos = a->start.pos + 1;", " \tepos = a->end.pos - 1;", "     }", "     switch (form->type) {", "     case FORM_INPUT_CHECKBOX:", "     case FORM_INPUT_RADIO:", " \tif (buf->currentLine == NULL ||", " \t    spos >= buf->currentLine->len || spos < 0)", " \t    break;", " \tif (form->checked)", " \t    buf->currentLine->lineBuf[spos] = '*';", " \telse", " \t    buf->currentLine->lineBuf[spos] = ' ';", " \tbreak;", "     case FORM_INPUT_TEXT:", "     case FORM_INPUT_FILE:", "     case FORM_INPUT_PASSWORD:", "     case FORM_TEXTAREA:", " #ifdef MENU_SELECT", "     case FORM_SELECT:", " \tif (form->type == FORM_SELECT) {", " \t    p = form->label->ptr;", " \t    updateSelectOption(form, form->select_option);", " \t}", " \telse", " #endif\t\t\t\t ", " \t{", " \t    if (!form->value)", " \t\tbreak;", " \t    p = form->value->ptr;", " \t}", " \tl = buf->currentLine;", " \tif (!l)", " \t    break;", " \tif (form->type == FORM_TEXTAREA) {", " \t    int n = a->y - buf->currentLine->linenumber;", " \t    if (n > 0)", " \t\tfor (; l && n; l = l->prev, n--) ;", " \t    else if (n < 0)", " \t\tfor (; l && n; l = l->prev, n++) ;", " \t    if (!l)", " \t\tbreak;", " \t}", "  \trows = form->rows ? form->rows : 1;", "  \tcol = COLPOS(l, a->start.pos);", "  \tfor (c_rows = 0; c_rows < rows; c_rows++, l = l->next) {", " \t    if (l == NULL)", " \t\tbreak;", "  \t    if (rows > 1) {", "  \t\tpos = columnPos(l, col);", "  \t\ta = retrieveAnchor(buf->formitem, l->linenumber, pos);", " \t\tif (a == NULL)", " \t\t    break;", " \t\tspos = a->start.pos;", " \t\tepos = a->end.pos;", " \t    }", " \t    if (a->start.line != a->end.line || spos > epos || epos >= l->len ||", " \t\tspos < 0 || epos < 0 || COLPOS(l, epos) < col)", " \t\tbreak;", " \t    pos = form_update_line(l, &p, spos, epos, COLPOS(l, epos) - col,", " \t\t\t\t   rows > 1,", " \t\t\t\t   form->type == FORM_INPUT_PASSWORD);", " \t    if (pos != epos) {", " \t\tshiftAnchorPosition(buf->href, buf->hmarklist,", " \t\t\t\t    a->start.line, spos, pos - epos);", " \t\tshiftAnchorPosition(buf->name, buf->hmarklist,", " \t\t\t\t    a->start.line, spos, pos - epos);", " \t\tshiftAnchorPosition(buf->img, buf->hmarklist,", " \t\t\t\t    a->start.line, spos, pos - epos);", " \t\tshiftAnchorPosition(buf->formitem, buf->hmarklist,", " \t\t\t\t    a->start.line, spos, pos - epos);", " \t    }", " \t}", " \tbreak;", "     }", "     copyBuffer(buf, &save);", "     arrangeLine(buf);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void ctrycatchfinally(JF, js_Ast *trystm, js_Ast *catchvar, js_Ast *catchstm, js_Ast *finallystm)", " {", " \tint L1, L2, L3;", " \tL1 = emitjump(J, F, OP_TRY);", " \t{", " \t\tL2 = emitjump(J, F, OP_TRY);", " \t\t{", " \t\t\tcstm(J, F, finallystm);  ", " \t\t\temit(J, F, OP_THROW);  ", " \t\t}", " \t\tlabel(J, F, L2);", " \t\tif (F->strict) {", " \t\t\tcheckfutureword(J, F, catchvar);", " \t\t\tif (!strcmp(catchvar->string, \"arguments\"))", " \t\t\t\tjsC_error(J, catchvar, \"redefining 'arguments' is not allowed in strict mode\");", " \t\t\tif (!strcmp(catchvar->string, \"eval\"))", " \t\t\t\tjsC_error(J, catchvar, \"redefining 'eval' is not allowed in strict mode\");", " \t\t}", " \t\temitline(J, F, catchvar);", "  \t\temitstring(J, F, OP_CATCH, catchvar->string);", "  \t\tcstm(J, F, catchstm);", "  \t\temit(J, F, OP_ENDCATCH);", " \t\temit(J, F, OP_ENDTRY);", "  \t\tL3 = emitjump(J, F, OP_JUMP);  ", "  \t}", "  \tlabel(J, F, L1);", " \tcstm(J, F, trystm);", " \temit(J, F, OP_ENDTRY);", " \tlabel(J, F, L3);", " \tcstm(J, F, finallystm);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int cg_write(const char *path, const char *buf, size_t size, off_t offset,", " \t     struct fuse_file_info *fi)", " {", " \tstruct fuse_context *fc = fuse_get_context();", " \tchar *localbuf = NULL;", " \tstruct cgfs_files *k = NULL;", " \tstruct file_info *f = (struct file_info *)fi->fh;", " \tbool r;", " \tif (f->type != LXC_TYPE_CGFILE) {", " \t\tfprintf(stderr, \"Internal error: directory cache info used in cg_write\\n\");", " \t\treturn -EIO;", " \t}", " \tif (offset)", " \t\treturn 0;", " \tif (!fc)", " \t\treturn -EIO;", " \tlocalbuf = alloca(size+1);", " \tlocalbuf[size] = '\\0';", " \tmemcpy(localbuf, buf, size);", " \tif ((k = cgfs_get_key(f->controller, f->cgroup, f->file)) == NULL) {", " \t\tsize = -EINVAL;", " \t\tgoto out;", " \t}", " \tif (!fc_may_access(fc, f->controller, f->cgroup, f->file, O_WRONLY)) {", " \t\tsize = -EACCES;", " \t\tgoto out;", " \t}", " \tif (strcmp(f->file, \"tasks\") == 0 ||", " \t\t\tstrcmp(f->file, \"/tasks\") == 0 ||", "  \t\t\tstrcmp(f->file, \"/cgroup.procs\") == 0 ||", "  \t\t\tstrcmp(f->file, \"cgroup.procs\") == 0)", "\t\tr = do_write_pids(fc->pid, f->controller, f->cgroup, f->file, localbuf);", " \t\tr = do_write_pids(fc->pid, fc->uid, f->controller, f->cgroup, f->file, localbuf);", "  \telse", "  \t\tr = cgfs_set_value(f->controller, f->cgroup, f->file, localbuf);", " \tif (!r)", " \t\tsize = -EINVAL;", " out:", " \tfree_key(k);", " \treturn size;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" setElementTypePrefix(XML_Parser parser, ELEMENT_TYPE *elementType)", " {", "   DTD * const dtd = parser->m_dtd;   ", "   const XML_Char *name;", "   for (name = elementType->name; *name; name++) {", "     if (*name == XML_T(ASCII_COLON)) {", "       PREFIX *prefix;", "       const XML_Char *s;", "       for (s = elementType->name; s != name; s++) {", "         if (!poolAppendChar(&dtd->pool, *s))", "           return 0;", "       }", "       if (!poolAppendChar(&dtd->pool, XML_T('\\0')))", "         return 0;", "       prefix = (PREFIX *)lookup(parser, &dtd->prefixes, poolStart(&dtd->pool),", "                                 sizeof(PREFIX));", "       if (!prefix)", "         return 0;", "       if (prefix->name == poolStart(&dtd->pool))", "         poolFinish(&dtd->pool);", "        else", "          poolDiscard(&dtd->pool);", "        elementType->prefix = prefix;", "       break;", "      }", "    }", "    return 1;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": [" bit_catenate(VarBit *arg1, VarBit *arg2)", " {", " \tVarBit\t   *result;", " \tint\t\t\tbitlen1,", " \t\t\t\tbitlen2,", " \t\t\t\tbytelen,", " \t\t\t\tbit1pad,", " \t\t\t\tbit2shift;", " \tbits8\t   *pr,", " \t\t\t   *pa;", "  \tbitlen1 = VARBITLEN(arg1);", "  \tbitlen2 = VARBITLEN(arg2);", " \tif (bitlen1 > VARBITMAXLEN - bitlen2)", " \t\tereport(ERROR,", " \t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),", " \t\t\t\t errmsg(\"bit string length exceeds the maximum allowed (%d)\",", " \t\t\t\t\t\tVARBITMAXLEN)));", "  \tbytelen = VARBITTOTALLEN(bitlen1 + bitlen2);", "  \tresult = (VarBit *) palloc(bytelen);", " \tSET_VARSIZE(result, bytelen);", " \tVARBITLEN(result) = bitlen1 + bitlen2;", " \tmemcpy(VARBITS(result), VARBITS(arg1), VARBITBYTES(arg1));", " \tbit1pad = VARBITPAD(arg1);", " \tif (bit1pad == 0)", " \t{", " \t\tmemcpy(VARBITS(result) + VARBITBYTES(arg1), VARBITS(arg2),", " \t\t\t   VARBITBYTES(arg2));", " \t}", " \telse if (bitlen2 > 0)", " \t{", " \t\tbit2shift = BITS_PER_BYTE - bit1pad;", " \t\tpr = VARBITS(result) + VARBITBYTES(arg1) - 1;", " \t\tfor (pa = VARBITS(arg2); pa < VARBITEND(arg2); pa++)", " \t\t{", " \t\t\t*pr |= ((*pa >> bit2shift) & BITMASK);", " \t\t\tpr++;", " \t\t\tif (pr < VARBITEND(result))", " \t\t\t\t*pr = (*pa << bit1pad) & BITMASK;", " \t\t}", " \t}", " \treturn result;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static enum AVPixelFormat h263_get_format(AVCodecContext *avctx)", "  {", "     MpegEncContext *s = avctx->priv_data;", "      if (avctx->bits_per_raw_sample > 8) {", "        av_assert1(avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);", "         av_assert1(s->studio_profile);", "          return avctx->pix_fmt;", "      }", "     if (avctx->codec->id == AV_CODEC_ID_MSS2)", "         return AV_PIX_FMT_YUV420P;", "     if (CONFIG_GRAY && (avctx->flags & AV_CODEC_FLAG_GRAY)) {", "         if (avctx->color_range == AVCOL_RANGE_UNSPECIFIED)", "             avctx->color_range = AVCOL_RANGE_MPEG;", "         return AV_PIX_FMT_GRAY8;", "     }", "     return avctx->pix_fmt = ff_get_format(avctx, avctx->codec->pix_fmts);", " }"], "ner_tags": [0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int jpc_pi_nextcprl(register jpc_pi_t *pi)", " {", " \tint rlvlno;", " \tjpc_pirlvl_t *pirlvl;", " \tjpc_pchg_t *pchg;", " \tint prchind;", " \tint prcvind;", " \tint *prclyrno;", " \tuint_fast32_t trx0;", " \tuint_fast32_t try0;", " \tuint_fast32_t r;", " \tuint_fast32_t rpx;", " \tuint_fast32_t rpy;", " \tpchg = pi->pchg;", " \tif (!pi->prgvolfirst) {", " \t\tgoto skip;", " \t} else {", "  \t\tpi->prgvolfirst = 0;", "  \t}", "\tfor (pi->compno = pchg->compnostart, pi->picomp =", "\t  &pi->picomps[pi->compno]; pi->compno < JAS_CAST(int, pchg->compnoend) && pi->compno < pi->numcomps; ++pi->compno,", "\t  ++pi->picomp) {", " \tfor (pi->compno = pchg->compnostart, pi->picomp = &pi->picomps[pi->compno];", " \t  pi->compno < JAS_CAST(int, pchg->compnoend) && pi->compno < pi->numcomps;", " \t  ++pi->compno, ++pi->picomp) {", "  \t\tpirlvl = pi->picomp->pirlvls;", " \t\tif (pirlvl->prcwidthexpn + pi->picomp->numrlvls >", " \t\t  JAS_UINTFAST32_NUMBITS - 2 ||", " \t\t  pirlvl->prcheightexpn + pi->picomp->numrlvls >", " \t\t  JAS_UINTFAST32_NUMBITS - 2) {", " \t\t\treturn -1;", " \t\t}", "  \t\tpi->xstep = pi->picomp->hsamp * (JAS_CAST(uint_fast32_t, 1) <<", "  \t\t  (pirlvl->prcwidthexpn + pi->picomp->numrlvls - 1));", "  \t\tpi->ystep = pi->picomp->vsamp * (JAS_CAST(uint_fast32_t, 1) <<", " \t\t  (pirlvl->prcheightexpn + pi->picomp->numrlvls - 1));", " \t\tfor (rlvlno = 1, pirlvl = &pi->picomp->pirlvls[1];", " \t\t  rlvlno < pi->picomp->numrlvls; ++rlvlno, ++pirlvl) {", " \t\t\tpi->xstep = JAS_MIN(pi->xstep, pi->picomp->hsamp *", " \t\t\t  (JAS_CAST(uint_fast32_t, 1) << (pirlvl->prcwidthexpn +", " \t\t\t  pi->picomp->numrlvls - rlvlno - 1)));", " \t\t\tpi->ystep = JAS_MIN(pi->ystep, pi->picomp->vsamp *", " \t\t\t  (JAS_CAST(uint_fast32_t, 1) << (pirlvl->prcheightexpn +", " \t\t\t  pi->picomp->numrlvls - rlvlno - 1)));", " \t\t}", " \t\tfor (pi->y = pi->ystart; pi->y < pi->yend;", " \t\t  pi->y += pi->ystep - (pi->y % pi->ystep)) {", " \t\t\tfor (pi->x = pi->xstart; pi->x < pi->xend;", " \t\t\t  pi->x += pi->xstep - (pi->x % pi->xstep)) {", " \t\t\t\tfor (pi->rlvlno = pchg->rlvlnostart,", " \t\t\t\t  pi->pirlvl = &pi->picomp->pirlvls[pi->rlvlno];", " \t\t\t\t  pi->rlvlno < pi->picomp->numrlvls && pi->rlvlno <", " \t\t\t\t  pchg->rlvlnoend; ++pi->rlvlno, ++pi->pirlvl) {", " \t\t\t\t\tif (pi->pirlvl->numprcs == 0) {", " \t\t\t\t\t\tcontinue;", " \t\t\t\t\t}", " \t\t\t\t\tr = pi->picomp->numrlvls - 1 - pi->rlvlno;", " \t\t\t\t\ttrx0 = JPC_CEILDIV(pi->xstart, pi->picomp->hsamp << r);", "  \t\t\t\t\ttry0 = JPC_CEILDIV(pi->ystart, pi->picomp->vsamp << r);", "  \t\t\t\t\trpx = r + pi->pirlvl->prcwidthexpn;", "  \t\t\t\t\trpy = r + pi->pirlvl->prcheightexpn;", "\t\t\t\t\tif (((pi->x == pi->xstart && ((trx0 << r) % (1 << rpx))) ||", " \t\t\t\t\tif (((pi->x == pi->xstart &&", " \t\t\t\t\t  ((trx0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpx))) ||", "  \t\t\t\t\t  !(pi->x % (pi->picomp->hsamp << rpx))) &&", "\t\t\t\t\t  ((pi->y == pi->ystart && ((try0 << r) % (1 << rpy))) ||", " \t\t\t\t\t  ((pi->y == pi->ystart &&", " \t\t\t\t\t  ((try0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpy))) ||", "  \t\t\t\t\t  !(pi->y % (pi->picomp->vsamp << rpy)))) {", "\t\t\t\t\t\tprchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x, pi->picomp->hsamp", "\t\t\t\t\t\t  << r), pi->pirlvl->prcwidthexpn) - JPC_FLOORDIVPOW2(trx0,", "\t\t\t\t\t\t  pi->pirlvl->prcwidthexpn);", "\t\t\t\t\t\tprcvind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->y, pi->picomp->vsamp", "\t\t\t\t\t\t  << r), pi->pirlvl->prcheightexpn) - JPC_FLOORDIVPOW2(try0,", "\t\t\t\t\t\t  pi->pirlvl->prcheightexpn);", "\t\t\t\t\t\tpi->prcno = prcvind *", "\t\t\t\t\t\t  pi->pirlvl->numhprcs +", "\t\t\t\t\t\t  prchind;", "\t\t\t\t\t\tassert(pi->prcno <", "\t\t\t\t\t\t  pi->pirlvl->numprcs);", "\t\t\t\t\t\tfor (pi->lyrno = 0; pi->lyrno <", "\t\t\t\t\t\t  pi->numlyrs && pi->lyrno < JAS_CAST(int, pchg->lyrnoend); ++pi->lyrno) {", " \t\t\t\t\t\tprchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x,", " \t\t\t\t\t\t  pi->picomp->hsamp << r), pi->pirlvl->prcwidthexpn) -", " \t\t\t\t\t\t  JPC_FLOORDIVPOW2(trx0, pi->pirlvl->prcwidthexpn);", " \t\t\t\t\t\tprcvind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->y,", " \t\t\t\t\t\t  pi->picomp->vsamp << r), pi->pirlvl->prcheightexpn) -", " \t\t\t\t\t\t  JPC_FLOORDIVPOW2(try0, pi->pirlvl->prcheightexpn);", " \t\t\t\t\t\tpi->prcno = prcvind * pi->pirlvl->numhprcs + prchind;", " \t\t\t\t\t\tassert(pi->prcno < pi->pirlvl->numprcs);", " \t\t\t\t\t\tfor (pi->lyrno = 0; pi->lyrno < pi->numlyrs &&", " \t\t\t\t\t\t  pi->lyrno < JAS_CAST(int, pchg->lyrnoend);", " \t\t\t\t\t\t  ++pi->lyrno) {", "  \t\t\t\t\t\t\tprclyrno = &pi->pirlvl->prclyrnos[pi->prcno];", "  \t\t\t\t\t\t\tif (pi->lyrno >= *prclyrno) {", "  \t\t\t\t\t\t\t\t++(*prclyrno);", " \t\t\t\t\t\t\t\treturn 0;", " \t\t\t\t\t\t\t}", " skip:", " \t\t\t\t\t\t\t;", " \t\t\t\t\t\t}", " \t\t\t\t\t}", " \t\t\t\t}", " \t\t\t}", " \t\t}", " \t}", " \treturn 1;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" psf_binheader_readf (SF_PRIVATE *psf, char const *format, ...)", " {\tva_list\t\t\targptr ;", " \tsf_count_t\t\t*countptr, countdata ;", " \tunsigned char\t*ucptr, sixteen_bytes [16] ;", " \tunsigned int \t*intptr, intdata ;", " \tunsigned short\t*shortptr ;", " \tchar\t\t\t*charptr ;", "  \tfloat\t\t\t*floatptr ;", "  \tdouble\t\t\t*doubleptr ;", "  \tchar\t\t\tc ;", "\tint\t\t\t\tbyte_count = 0, count ;", " \tint\t\t\t\tbyte_count = 0, count = 0 ;", "  \tif (! format)", "  \t\treturn psf_ftell (psf) ;", "  \tva_start (argptr, format) ;", "  \twhile ((c = *format++))", "\t{\tswitch (c)", " \t{", " \t\tif (psf->header.indx + 16 >= psf->header.len && psf_bump_header_allocation (psf, 16))", " \t\t\treturn count ;", " \t\tswitch (c)", "  \t\t{\tcase 'e' :  ", "  \t\t\t\t\tpsf->rwf_endian = SF_ENDIAN_LITTLE ;", "  \t\t\t\t\tbreak ;", " \t\t\tcase 'E' :  ", " \t\t\t\t\tpsf->rwf_endian = SF_ENDIAN_BIG ;", " \t\t\t\t\tbreak ;", "  \t\t\tcase 'm' :  ", "  \t\t\t\t\tintptr = va_arg (argptr, unsigned int*) ;", " \t\t\t\t\t*intptr = 0 ;", "  \t\t\t\t\tucptr = (unsigned char*) intptr ;", "  \t\t\t\t\tbyte_count += header_read (psf, ucptr, sizeof (int)) ;", "  \t\t\t\t\t*intptr = GET_MARKER (ucptr) ;", "  \t\t\t\t\tbreak ;", "  \t\t\tcase 'h' :", "  \t\t\t\t\tintptr = va_arg (argptr, unsigned int*) ;", " \t\t\t\t\t*intptr = 0 ;", "  \t\t\t\t\tucptr = (unsigned char*) intptr ;", "  \t\t\t\t\tbyte_count += header_read (psf, sixteen_bytes, sizeof (sixteen_bytes)) ;", "  \t\t\t\t\t{\tint k ;", " \t\t\t\t\t\tintdata = 0 ;", " \t\t\t\t\t\tfor (k = 0 ; k < 16 ; k++)", " \t\t\t\t\t\t\tintdata ^= sixteen_bytes [k] << k ;", " \t\t\t\t\t\t}", " \t\t\t\t\t*intptr = intdata ;", " \t\t\t\t\tbreak ;", " \t\t\tcase '1' :", " \t\t\t\t\tcharptr = va_arg (argptr, char*) ;", " \t\t\t\t\t*charptr = 0 ;", " \t\t\t\t\tbyte_count += header_read (psf, charptr, sizeof (char)) ;", " \t\t\t\t\tbreak ;", " \t\t\tcase '2' :  ", " \t\t\t\t\tshortptr = va_arg (argptr, unsigned short*) ;", " \t\t\t\t\t*shortptr = 0 ;", " \t\t\t\t\tucptr = (unsigned char*) shortptr ;", " \t\t\t\t\tbyte_count += header_read (psf, ucptr, sizeof (short)) ;", " \t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)", " \t\t\t\t\t\t*shortptr = GET_BE_SHORT (ucptr) ;", " \t\t\t\t\telse", " \t\t\t\t\t\t*shortptr = GET_LE_SHORT (ucptr) ;", " \t\t\t\t\tbreak ;", " \t\t\tcase '3' :  ", " \t\t\t\t\tintptr = va_arg (argptr, unsigned int*) ;", " \t\t\t\t\t*intptr = 0 ;", " \t\t\t\t\tbyte_count += header_read (psf, sixteen_bytes, 3) ;", " \t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)", " \t\t\t\t\t\t*intptr = GET_BE_3BYTE (sixteen_bytes) ;", " \t\t\t\t\telse", " \t\t\t\t\t\t*intptr = GET_LE_3BYTE (sixteen_bytes) ;", " \t\t\t\t\tbreak ;", " \t\t\tcase '4' :  ", " \t\t\t\t\tintptr = va_arg (argptr, unsigned int*) ;", " \t\t\t\t\t*intptr = 0 ;", " \t\t\t\t\tucptr = (unsigned char*) intptr ;", " \t\t\t\t\tbyte_count += header_read (psf, ucptr, sizeof (int)) ;", " \t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)", " \t\t\t\t\t\t*intptr = psf_get_be32 (ucptr, 0) ;", " \t\t\t\t\telse", " \t\t\t\t\t\t*intptr = psf_get_le32 (ucptr, 0) ;", " \t\t\t\t\tbreak ;", " \t\t\tcase '8' :  ", " \t\t\t\t\tcountptr = va_arg (argptr, sf_count_t *) ;", " \t\t\t\t\t*countptr = 0 ;", " \t\t\t\t\tbyte_count += header_read (psf, sixteen_bytes, 8) ;", " \t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)", " \t\t\t\t\t\tcountdata = psf_get_be64 (sixteen_bytes, 0) ;", " \t\t\t\t\telse", " \t\t\t\t\t\tcountdata = psf_get_le64 (sixteen_bytes, 0) ;", " \t\t\t\t\t*countptr = countdata ;", " \t\t\t\t\tbreak ;", " \t\t\tcase 'f' :  ", " \t\t\t\t\tfloatptr = va_arg (argptr, float *) ;", " \t\t\t\t\t*floatptr = 0.0 ;", " \t\t\t\t\tbyte_count += header_read (psf, floatptr, sizeof (float)) ;", " \t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)", " \t\t\t\t\t\t*floatptr = float32_be_read ((unsigned char*) floatptr) ;", " \t\t\t\t\telse", " \t\t\t\t\t\t*floatptr = float32_le_read ((unsigned char*) floatptr) ;", " \t\t\t\t\tbreak ;", " \t\t\tcase 'd' :  ", " \t\t\t\t\tdoubleptr = va_arg (argptr, double *) ;", " \t\t\t\t\t*doubleptr = 0.0 ;", " \t\t\t\t\tbyte_count += header_read (psf, doubleptr, sizeof (double)) ;", " \t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)", " \t\t\t\t\t\t*doubleptr = double64_be_read ((unsigned char*) doubleptr) ;", " \t\t\t\t\telse", " \t\t\t\t\t\t*doubleptr = double64_le_read ((unsigned char*) doubleptr) ;", " \t\t\t\t\tbreak ;", " \t\t\tcase 's' :", " \t\t\t\t\tpsf_log_printf (psf, \"Format conversion 's' not implemented yet.\\n\") ;", "  \t\t\t\t\tbreak ;", "  \t\t\tcase 'b' :  ", "  \t\t\t\t\tcharptr = va_arg (argptr, char*) ;", "  \t\t\t\t\tcount = va_arg (argptr, size_t) ;", "\t\t\t\t\tif (count > 0)", "\t\t\t\t\t\tbyte_count += header_read (psf, charptr, count) ;", " \t\t\t\t\tmemset (charptr, 0, count) ;", " \t\t\t\t\tbyte_count += header_read (psf, charptr, count) ;", "  \t\t\t\t\tbreak ;", "  \t\t\tcase 'G' :", "  \t\t\t\t\tcharptr = va_arg (argptr, char*) ;", "  \t\t\t\t\tcount = va_arg (argptr, size_t) ;", "\t\t\t\t\tif (count > 0)", "\t\t\t\t\t\tbyte_count += header_gets (psf, charptr, count) ;", " \t\t\t\t\tmemset (charptr, 0, count) ;", " \t\t\t\t\tif (psf->header.indx + count >= psf->header.len && psf_bump_header_allocation (psf, count))", " \t\t\t\t\t\treturn 0 ;", " \t\t\t\t\tbyte_count += header_gets (psf, charptr, count) ;", "  \t\t\t\t\tbreak ;", "  \t\t\tcase 'z' :", "  \t\t\t\t\tpsf_log_printf (psf, \"Format conversion 'z' not implemented yet.\\n\") ;", "  \t\t\t\t\tbreak ;", "\t\t\tcase 'p' :", " \t\t\tcase 'p' :\t ", "  \t\t\t\t\tcount = va_arg (argptr, size_t) ;", "  \t\t\t\t\theader_seek (psf, count, SEEK_SET) ;", "  \t\t\t\t\tbyte_count = count ;", "  \t\t\t\t\tbreak ;", "\t\t\tcase 'j' :", " \t\t\tcase 'j' :\t ", "  \t\t\t\t\tcount = va_arg (argptr, size_t) ;", "\t\t\t\t\tif (count)", "\t\t\t\t\t{\theader_seek (psf, count, SEEK_CUR) ;", "\t\t\t\t\t\tbyte_count += count ;", "\t\t\t\t\t\t} ;", " \t\t\t\t\theader_seek (psf, count, SEEK_CUR) ;", " \t\t\t\t\tbyte_count += count ;", "  \t\t\t\t\tbreak ;", "  \t\t\tdefault :", " \t\t\t\tpsf_log_printf (psf, \"*** Invalid format specifier `%c'\\n\", c) ;", " \t\t\t\tpsf->error = SFE_INTERNAL ;", " \t\t\t\tbreak ;", " \t\t\t} ;", " \t\t} ;", " \tva_end (argptr) ;", " \treturn byte_count ;", " }  "], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int rtecp_select_file(sc_card_t *card,", " \t\tconst sc_path_t *in_path, sc_file_t **file_out)", " {", " \tsc_file_t **file_out_copy, *file;", " \tint r;", " \tassert(card && card->ctx && in_path);", " \tswitch (in_path->type)", " \t{", " \tcase SC_PATH_TYPE_DF_NAME:", " \tcase SC_PATH_TYPE_FROM_CURRENT:", " \tcase SC_PATH_TYPE_PARENT:", " \t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_NOT_SUPPORTED);", " \t}", " \tassert(iso_ops && iso_ops->select_file);", " \tfile_out_copy = file_out;", " \tr = iso_ops->select_file(card, in_path, file_out_copy);", " \tif (r || file_out_copy == NULL)", " \t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);", " \tassert(file_out_copy);", " \tfile = *file_out_copy;", " \tassert(file);", " \tif (file->sec_attr && file->sec_attr_len == SC_RTECP_SEC_ATTR_SIZE)", "  \t\tset_acl_from_sec_attr(card, file);", "  \telse", "  \t\tr = SC_ERROR_UNKNOWN_DATA_RECEIVED;", "\tif (r)", " \tif (r && !file_out)", "  \t\tsc_file_free(file);", "  \telse", "  \t{", " \t\tassert(file_out);", " \t\t*file_out = file;", " \t}", " \tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void jpc_qmfb_split_col(jpc_fix_t *a, int numrows, int stride,", "   int parity)", " {", " \tint bufsize = JPC_CEILDIVPOW2(numrows, 1);", " \tjpc_fix_t splitbuf[QMFB_SPLITBUFSIZE];", " \tjpc_fix_t *buf = splitbuf;", " \tregister jpc_fix_t *srcptr;", "  \tregister jpc_fix_t *dstptr;", "  \tregister int n;", "  \tregister int m;", "\tint hstartcol;", " \tint hstartrow;", "  \tif (bufsize > QMFB_SPLITBUFSIZE) {", " \t\tif (!(buf = jas_alloc2(bufsize, sizeof(jpc_fix_t)))) {", " \t\t\tabort();", " \t\t}", "  \t}", "  \tif (numrows >= 2) {", "\t\thstartcol = (numrows + 1 - parity) >> 1;", "\t\tm = numrows - hstartcol;", " \t\thstartrow = (numrows + 1 - parity) >> 1;", " \t\tm = numrows - hstartrow;", "  \t\tn = m;", " \t\tdstptr = buf;", " \t\tsrcptr = &a[(1 - parity) * stride];", " \t\twhile (n-- > 0) {", " \t\t\t*dstptr = *srcptr;", " \t\t\t++dstptr;", " \t\t\tsrcptr += stride << 1;", " \t\t}", " \t\tdstptr = &a[(1 - parity) * stride];", " \t\tsrcptr = &a[(2 - parity) * stride];", " \t\tn = numrows - m - (!parity);", " \t\twhile (n-- > 0) {", " \t\t\t*dstptr = *srcptr;", " \t\t\tdstptr += stride;", "  \t\t\tsrcptr += stride << 1;", "  \t\t}", "\t\tdstptr = &a[hstartcol * stride];", " \t\tdstptr = &a[hstartrow * stride];", "  \t\tsrcptr = buf;", "  \t\tn = m;", "  \t\twhile (n-- > 0) {", " \t\t\t*dstptr = *srcptr;", " \t\t\tdstptr += stride;", " \t\t\t++srcptr;", " \t\t}", " \t}", " \tif (buf != splitbuf) {", " \t\tjas_free(buf);", " \t}", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  ProcXSendExtensionEvent(ClientPtr client)", "  {", "    int ret;", "     int ret, i;", "      DeviceIntPtr dev;", "      xEvent *first;", "      XEventClass *list;", "     struct tmask tmp[EMASKSIZE];", "     REQUEST(xSendExtensionEventReq);", "     REQUEST_AT_LEAST_SIZE(xSendExtensionEventReq);", "     if (stuff->length !=", "         bytes_to_int32(sizeof(xSendExtensionEventReq)) + stuff->count +", "         (stuff->num_events * bytes_to_int32(sizeof(xEvent))))", "         return BadLength;", "     ret = dixLookupDevice(&dev, stuff->deviceid, client, DixWriteAccess);", "     if (ret != Success)", "         return ret;", "     if (stuff->num_events == 0)", "         return ret;", "      first = ((xEvent *) &stuff[1]);", "    if (!((EXTENSION_EVENT_BASE <= first->u.u.type) &&", "          (first->u.u.type < lastEvent))) {", "        client->errorValue = first->u.u.type;", "        return BadValue;", "     for (i = 0; i < stuff->num_events; i++) {", "         if (!((EXTENSION_EVENT_BASE <= first[i].u.u.type) &&", "             (first[i].u.u.type < lastEvent))) {", "             client->errorValue = first[i].u.u.type;", "             return BadValue;", "         }", "      }", "      list = (XEventClass *) (first + stuff->num_events);", "         return ret;", "     ret = (SendEvent(client, dev, stuff->destination,", "                      stuff->propagate, (xEvent *) &stuff[1],", "                      tmp[stuff->deviceid].mask, stuff->num_events));", "     return ret;", " }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)", " {", "     MpegEncContext *s = &ctx->m;", "     unsigned startcode, v;", "     int ret;", "     int vol = 0;", "     align_get_bits(gb);", "     if (!s->studio_profile && s->avctx->bits_per_raw_sample != 8)", "         s->avctx->bits_per_raw_sample = 0;", "     if (s->codec_tag == AV_RL32(\"WV1F\") && show_bits(gb, 24) == 0x575630) {", "         skip_bits(gb, 24);", "         if (get_bits(gb, 8) == 0xF0)", "             goto end;", "     }", "     startcode = 0xff;", "     for (;;) {", "         if (get_bits_count(gb) >= gb->size_in_bits) {", "             if (gb->size_in_bits == 8 &&", "                 (ctx->divx_version >= 0 || ctx->xvid_build >= 0) || s->codec_tag == AV_RL32(\"QMP4\")) {", "                 av_log(s->avctx, AV_LOG_VERBOSE, \"frame skip %d\\n\", gb->size_in_bits);", "                 return FRAME_SKIPPED;   ", "             } else", "                 return AVERROR_INVALIDDATA;   ", "         }", "         v = get_bits(gb, 8);", "         startcode = ((startcode << 8) | v) & 0xffffffff;", "         if ((startcode & 0xFFFFFF00) != 0x100)", "             continue;   ", "         if (s->avctx->debug & FF_DEBUG_STARTCODE) {", "             av_log(s->avctx, AV_LOG_DEBUG, \"startcode: %3X \", startcode);", "             if (startcode <= 0x11F)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Video Object Start\");", "             else if (startcode <= 0x12F)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Video Object Layer Start\");", "             else if (startcode <= 0x13F)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Reserved\");", "             else if (startcode <= 0x15F)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"FGS bp start\");", "             else if (startcode <= 0x1AF)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Reserved\");", "             else if (startcode == 0x1B0)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Seq Start\");", "             else if (startcode == 0x1B1)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Seq End\");", "             else if (startcode == 0x1B2)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"User Data\");", "             else if (startcode == 0x1B3)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Group of VOP start\");", "             else if (startcode == 0x1B4)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Video Session Error\");", "             else if (startcode == 0x1B5)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Start\");", "             else if (startcode == 0x1B6)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Video Object Plane start\");", "             else if (startcode == 0x1B7)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"slice start\");", "             else if (startcode == 0x1B8)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"extension start\");", "             else if (startcode == 0x1B9)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"fgs start\");", "             else if (startcode == 0x1BA)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"FBA Object start\");", "             else if (startcode == 0x1BB)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"FBA Object Plane start\");", "             else if (startcode == 0x1BC)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Mesh Object start\");", "             else if (startcode == 0x1BD)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Mesh Object Plane start\");", "             else if (startcode == 0x1BE)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Still Texture Object start\");", "             else if (startcode == 0x1BF)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Texture Spatial Layer start\");", "             else if (startcode == 0x1C0)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Texture SNR Layer start\");", "             else if (startcode == 0x1C1)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Texture Tile start\");", "             else if (startcode == 0x1C2)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Texture Shape Layer start\");", "             else if (startcode == 0x1C3)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"stuffing start\");", "             else if (startcode <= 0x1C5)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"reserved\");", "             else if (startcode <= 0x1FF)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"System start\");", "             av_log(s->avctx, AV_LOG_DEBUG, \" at %d\\n\", get_bits_count(gb));", "         }", "         if (startcode >= 0x120 && startcode <= 0x12F) {", "             if (vol) {", "                 av_log(s->avctx, AV_LOG_WARNING, \"Ignoring multiple VOL headers\\n\");", "                 continue;", "             }", "             vol++;", "             if ((ret = decode_vol_header(ctx, gb)) < 0)", "                 return ret;", "         } else if (startcode == USER_DATA_STARTCODE) {", "             decode_user_data(ctx, gb);", "         } else if (startcode == GOP_STARTCODE) {", "             mpeg4_decode_gop_header(s, gb);", "         } else if (startcode == VOS_STARTCODE) {", "             int profile, level;", "             mpeg4_decode_profile_level(s, gb, &profile, &level);", "             if (profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&", "                 (level > 0 && level < 9)) {", "                 s->studio_profile = 1;", "                 next_start_code_studio(gb);", "                 extension_and_user_data(s, gb, 0);", "             } else if (s->studio_profile) {", "                 avpriv_request_sample(s->avctx, \"Mixes studio and non studio profile\\n\");", "                 return AVERROR_PATCHWELCOME;", "             }", "             s->avctx->profile = profile;", "             s->avctx->level   = level;", "         } else if (startcode == VISUAL_OBJ_STARTCODE) {", "             if (s->studio_profile) {", "                 if ((ret = decode_studiovisualobject(ctx, gb)) < 0)", "                     return ret;", "             } else", "                 mpeg4_decode_visual_object(s, gb);", "         } else if (startcode == VOP_STARTCODE) {", "             break;", "         }", "         align_get_bits(gb);", "         startcode = 0xff;", "     }", " end:", "     if (s->avctx->flags & AV_CODEC_FLAG_LOW_DELAY)", "         s->low_delay = 1;", "      s->avctx->has_b_frames = !s->low_delay;", "      if (s->studio_profile) {", "        av_assert0(s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);", "          if (!s->avctx->bits_per_raw_sample) {", "              av_log(s->avctx, AV_LOG_ERROR, \"Missing VOL header\\n\");", "              return AVERROR_INVALIDDATA;", "         }", "         return decode_studio_vop_header(ctx, gb);", "     } else", "         return decode_vop_header(ctx, gb);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int yr_object_copy(", "     YR_OBJECT* object,", "     YR_OBJECT** object_copy)", " {", "   YR_OBJECT* copy;", "   YR_OBJECT* o;", "   YR_STRUCTURE_MEMBER* structure_member;", "   YR_OBJECT_FUNCTION* func;", "   YR_OBJECT_FUNCTION* func_copy;", "   int i;", "   *object_copy = NULL;", "   FAIL_ON_ERROR(yr_object_create(", "       object->type,", "       object->identifier,", "       NULL,", "       &copy));", "    switch(object->type)", "    {", "      case OBJECT_TYPE_INTEGER:", "      ((YR_OBJECT_INTEGER*) copy)->value = UNDEFINED;", "       ((YR_OBJECT_INTEGER*) copy)->value = ((YR_OBJECT_INTEGER*) object)->value;", "        break;", "      case OBJECT_TYPE_STRING:", "      ((YR_OBJECT_STRING*) copy)->value = NULL;", "       if (((YR_OBJECT_STRING*) object)->value != NULL)", "       {", "         ((YR_OBJECT_STRING*) copy)->value = sized_string_dup(", "             ((YR_OBJECT_STRING*) object)->value);", "       }", "       else", "       {", "         ((YR_OBJECT_STRING*) copy)->value = NULL;", "       }", "       break;", "     case OBJECT_TYPE_FLOAT:", "       ((YR_OBJECT_DOUBLE*) copy)->value = ((YR_OBJECT_DOUBLE*) object)->value;", "        break;", "      case OBJECT_TYPE_FUNCTION:", "       func = (YR_OBJECT_FUNCTION*) object;", "       func_copy = (YR_OBJECT_FUNCTION*) copy;", "       FAIL_ON_ERROR_WITH_CLEANUP(", "         yr_object_copy(func->return_obj, &func_copy->return_obj),", "         yr_object_destroy(copy));", "       for (i = 0; i < MAX_OVERLOADED_FUNCTIONS; i++)", "         func_copy->prototypes[i] = func->prototypes[i];", "       break;", "     case OBJECT_TYPE_STRUCTURE:", "       structure_member = ((YR_OBJECT_STRUCTURE*) object)->members;", "       while (structure_member != NULL)", "       {", "         FAIL_ON_ERROR_WITH_CLEANUP(", "             yr_object_copy(structure_member->object, &o),", "             yr_object_destroy(copy));", "         FAIL_ON_ERROR_WITH_CLEANUP(", "             yr_object_structure_set_member(copy, o),", "             yr_free(o);", "             yr_object_destroy(copy));", "         structure_member = structure_member->next;", "       }", "       break;", "     case OBJECT_TYPE_ARRAY:", "       yr_object_copy(", "         ((YR_OBJECT_ARRAY *) object)->prototype_item,", "         &o);", "       ((YR_OBJECT_ARRAY *)copy)->prototype_item = o;", "       break;", "     case OBJECT_TYPE_DICTIONARY:", "       yr_object_copy(", "         ((YR_OBJECT_DICTIONARY *) object)->prototype_item,", "         &o);", "       ((YR_OBJECT_DICTIONARY *)copy)->prototype_item = o;", "       break;", "     default:", "       assert(FALSE);", "   }", "   *object_copy = copy;", "   return ERROR_SUCCESS;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" tTcpIpPacketParsingResult ParaNdis_CheckSumVerify(", "                                                 tCompletePhysicalAddress *pDataPages,", "                                                 ULONG ulDataLength,", "                                                 ULONG ulStartOffset,", "                                                 ULONG flags,", "                                                 LPCSTR caller)", " {", "      IPHeader *pIpHeader = (IPHeader *) RtlOffsetToPointer(pDataPages[0].Virtual, ulStartOffset);", "      tTcpIpPacketParsingResult res = QualifyIpPacket(pIpHeader, ulDataLength);", "     if (res.ipStatus == ppresNotIP || res.ipCheckSum == ppresIPTooShort)", "         return res;", "      if (res.ipStatus == ppresIPV4)", "      {", "          if (flags & pcrIpChecksum)", "             res = VerifyIpChecksum(&pIpHeader->v4, res, (flags & pcrFixIPChecksum) != 0);", "         if(res.xxpStatus == ppresXxpKnown)", "         {", "             if (res.TcpUdp == ppresIsTCP)  ", "             {", "                 if(flags & pcrTcpV4Checksum)", "                 {", "                     res = VerifyTcpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixTcpV4Checksum));", "                 }", "             }", "             else  ", "             {", "                 if (flags & pcrUdpV4Checksum)", "                 {", "                     res = VerifyUdpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixUdpV4Checksum));", "                 }", "             }", "         }", "     }", "     else if (res.ipStatus == ppresIPV6)", "     {", "         if(res.xxpStatus == ppresXxpKnown)", "         {", "             if (res.TcpUdp == ppresIsTCP)  ", "             {", "                 if(flags & pcrTcpV6Checksum)", "                 {", "                     res = VerifyTcpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixTcpV6Checksum));", "                 }", "             }", "             else  ", "             {", "                 if (flags & pcrUdpV6Checksum)", "                 {", "                     res = VerifyUdpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixUdpV6Checksum));", "                 }", "             }", "         }", "     }", "     PrintOutParsingResult(res, 1, caller);", "     return res;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" smb_com_flush(smb_request_t *sr)", " {", " \tsmb_ofile_t\t*file;", " \tsmb_llist_t\t*flist;", " \tint\t\trc;", " \tif (smb_flush_required == 0) {", " \t\trc = smbsr_encode_empty_result(sr);", " \t\treturn ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);", " \t}", " \tif (sr->smb_fid != 0xffff) {", " \t\tsmbsr_lookup_file(sr);", " \t\tif (sr->fid_ofile == NULL) {", " \t\t\tsmbsr_error(sr, NT_STATUS_INVALID_HANDLE,", "  \t\t\t    ERRDOS, ERRbadfid);", "  \t\t\treturn (SDRC_ERROR);", "  \t\t}", "\t\tsmb_flush_file(sr, sr->fid_ofile);", " \t\tsmb_ofile_flush(sr, sr->fid_ofile);", "  \t} else {", "  \t\tflist = &sr->tid_tree->t_ofile_list;", "  \t\tsmb_llist_enter(flist, RW_READER);", "  \t\tfile = smb_llist_head(flist);", "  \t\twhile (file) {", "  \t\t\tmutex_enter(&file->f_mutex);", "\t\t\tsmb_flush_file(sr, file);", " \t\t\tsmb_ofile_flush(sr, file);", "  \t\t\tmutex_exit(&file->f_mutex);", "  \t\t\tfile = smb_llist_next(flist, file);", "  \t\t}", " \t\tsmb_llist_exit(flist);", " \t}", "  \trc = smbsr_encode_empty_result(sr);", "  \treturn ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int dnxhd_find_frame_end(DNXHDParserContext *dctx,", "                                 const uint8_t *buf, int buf_size)", " {", "     ParseContext *pc = &dctx->pc;", "     uint64_t state = pc->state64;", "     int pic_found = pc->frame_start_found;", "     int i = 0;", "     if (!pic_found) {", "         for (i = 0; i < buf_size; i++) {", "             state = (state << 8) | buf[i];", "             if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {", "                 i++;", "                 pic_found = 1;", "                 dctx->cur_byte = 0;", "                 dctx->remaining = 0;", "                 break;", "             }", "         }", "     }", "     if (pic_found && !dctx->remaining) {", "         if (!buf_size)  ", "             return 0;", "         for (; i < buf_size; i++) {", "             dctx->cur_byte++;", "             state = (state << 8) | buf[i];", "             if (dctx->cur_byte == 24) {", "                 dctx->h = (state >> 32) & 0xFFFF;", "             } else if (dctx->cur_byte == 26) {", "                  dctx->w = (state >> 32) & 0xFFFF;", "              } else if (dctx->cur_byte == 42) {", "                  int cid = (state >> 32) & 0xFFFFFFFF;", "                 int remaining;", "                  if (cid <= 0)", "                      continue;", "                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);", "                if (dctx->remaining <= 0) {", "                    dctx->remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);", "                    if (dctx->remaining <= 0)", "                        return dctx->remaining;", "                 remaining = avpriv_dnxhd_get_frame_size(cid);", "                 if (remaining <= 0) {", "                     remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);", "                     if (remaining <= 0)", "                         continue;", "                  }", "                 dctx->remaining = remaining;", "                  if (buf_size - i + 47 >= dctx->remaining) {", "                      int remaining = dctx->remaining;", "                     pc->frame_start_found = 0;", "                     pc->state64 = -1;", "                     dctx->cur_byte = 0;", "                     dctx->remaining = 0;", "                     return remaining;", "                 } else {", "                     dctx->remaining -= buf_size;", "                 }", "             }", "         }", "     } else if (pic_found) {", "         if (dctx->remaining > buf_size) {", "             dctx->remaining -= buf_size;", "         } else {", "             int remaining = dctx->remaining;", "             pc->frame_start_found = 0;", "             pc->state64 = -1;", "             dctx->cur_byte = 0;", "             dctx->remaining = 0;", "             return remaining;", "         }", "     }", "     pc->frame_start_found = pic_found;", "     pc->state64 = state;", "     return END_NOT_FOUND;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int mem_resize(jas_stream_memobj_t *m, int bufsize)", " static int mem_resize(jas_stream_memobj_t *m, size_t bufsize)", "  {", "  \tunsigned char *buf;", "\tassert(bufsize >= 0);", " \tJAS_DBGLOG(100, (\"mem_resize(%p, %zu)\\n\", m, bufsize));", " \tif (!bufsize) {", " \t\tjas_eprintf(", " \t\t  \"mem_resize was not really designed to handle a buffer of size 0\\n\"", " \t\t  \"This may not work.\\n\"", " \t\t);", " \t}", "\tJAS_DBGLOG(100, (\"mem_resize(%p, %d)\\n\", m, bufsize));", "  \tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&", "  \t  bufsize) {", "  \t\tJAS_DBGLOG(100, (\"mem_resize realloc failed\\n\"));", " \t\treturn -1;", " \t}", " \tJAS_DBGLOG(100, (\"mem_resize realloc succeeded\\n\"));", " \tm->buf_ = buf;", " \tm->bufsize_ = bufsize;", " \treturn 0;", " }"], "ner_tags": [0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" lspci_process(STREAM s)", " {", "  \tunsigned int pkglen;", "  \tstatic char *rest = NULL;", "  \tchar *buf;", " \tstruct stream packet = *s;", " \tif (!s_check(s))", " \t{", " \t\trdp_protocol_error(\"lspci_process(), stream is in unstable state\", &packet);", " \t}", "  \tpkglen = s->end - s->p;", " \tbuf = xmalloc(pkglen + 1);", " \tSTRNCPY(buf, (char *) s->p, pkglen + 1);", " \tstr_handle_lines(buf, &rest, lspci_process_line, NULL);", " \txfree(buf);", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  int pnm_validate(jas_stream_t *in)", "  {", "\tuchar buf[2];", " \tjas_uchar buf[2];", "  \tint i;", "  \tint n;", " \tassert(JAS_STREAM_MAXPUTBACK >= 2);", " \tif ((n = jas_stream_read(in, buf, 2)) < 0) {", " \t\treturn -1;", " \t}", " \tfor (i = n - 1; i >= 0; --i) {", " \t\tif (jas_stream_ungetc(in, buf[i]) == EOF) {", " \t\t\treturn -1;", " \t\t}", " \t}", " \tif (n < 2) {", " \t\treturn -1;", " \t}", " \tif (buf[0] == 'P' && isdigit(buf[1])) {", " \t\treturn 0;", " \t}", " \treturn -1;", " }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static void add_bytes_c(uint8_t *dst, uint8_t *src, int w){", "      long i;", "    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){", "     for(i=0; i<=w-(int)sizeof(long); i+=sizeof(long)){", "          long a = *(long*)(src+i);", "          long b = *(long*)(dst+i);", "          *(long*)(dst+i) = ((a&pb_7f) + (b&pb_7f)) ^ ((a^b)&pb_80);", "     }", "     for(; i<w; i++)", "         dst[i+0] += src[i+0];", " }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int jas_iccgetuint(jas_stream_t *in, int n, ulonglong *val)", " static int jas_iccgetuint(jas_stream_t *in, int n, jas_ulonglong *val)", "  {", "  \tint i;", "  \tint c;", "\tulonglong v;", " \tjas_ulonglong v;", "  \tv = 0;", "  \tfor (i = n; i > 0; --i) {", "  \t\tif ((c = jas_stream_getc(in)) == EOF)", " \t\t\treturn -1;", " \t\tv = (v << 8) | c;", " \t}", " \t*val = v;", " \treturn 0;", " }"], "ner_tags": [0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" jas_iccprof_t *jas_iccprof_createfrombuf(uchar *buf, int len)", " jas_iccprof_t *jas_iccprof_createfrombuf(jas_uchar *buf, int len)", "  {", "  \tjas_stream_t *in;", "  \tjas_iccprof_t *prof;", " \tif (!(in = jas_stream_memopen(JAS_CAST(char *, buf), len)))", " \t\tgoto error;", " \tif (!(prof = jas_iccprof_load(in)))", " \t\tgoto error;", " \tjas_stream_close(in);", " \treturn prof;", " error:", " \tif (in)", " \t\tjas_stream_close(in);", " \treturn 0;", " }"], "ner_tags": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int filter_frame(AVFilterLink *inlink, AVFrame *in)", " {", "     PadContext *s = inlink->dst->priv;", "     AVFrame *out;", "     int needs_copy = frame_needs_copy(s, in);", "     if (needs_copy) {", "         av_log(inlink->dst, AV_LOG_DEBUG, \"Direct padding impossible allocating new frame\\n\");", "         out = ff_get_video_buffer(inlink->dst->outputs[0],", "                                   FFMAX(inlink->w, s->w),", "                                   FFMAX(inlink->h, s->h));", "         if (!out) {", "             av_frame_free(&in);", "             return AVERROR(ENOMEM);", "         }", "         av_frame_copy_props(out, in);", "     } else {", "          int i;", "          out = in;", "        for (i = 0; i < 4 && out->data[i]; i++) {", "         for (i = 0; i < 4 && out->data[i] && out->linesize[i]; i++) {", "              int hsub = s->draw.hsub[i];", "              int vsub = s->draw.vsub[i];", "              out->data[i] -= (s->x >> hsub) * s->draw.pixelstep[i] +", "                             (s->y >> vsub) * out->linesize[i];", "         }", "     }", "     if (s->y) {", "         ff_fill_rectangle(&s->draw, &s->color,", "                           out->data, out->linesize,", "                           0, 0, s->w, s->y);", "     }", "     if (s->h > s->y + s->in_h) {", "         ff_fill_rectangle(&s->draw, &s->color,", "                           out->data, out->linesize,", "                           0, s->y + s->in_h, s->w, s->h - s->y - s->in_h);", "     }", "     ff_fill_rectangle(&s->draw, &s->color, out->data, out->linesize,", "                       0, s->y, s->x, in->height);", "     if (needs_copy) {", "         ff_copy_rectangle2(&s->draw,", "                           out->data, out->linesize, in->data, in->linesize,", "                           s->x, s->y, 0, 0, in->width, in->height);", "     }", "     ff_fill_rectangle(&s->draw, &s->color, out->data, out->linesize,", "                       s->x + s->in_w, s->y, s->w - s->x - s->in_w,", "                       in->height);", "     out->width  = s->w;", "     out->height = s->h;", "     if (in != out)", "         av_frame_free(&in);", "     return ff_filter_frame(inlink->dst->outputs[0], out);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int jpc_dec_tiledecode(jpc_dec_t *dec, jpc_dec_tile_t *tile)", " {", " \tint i;", " \tint j;", " \tjpc_dec_tcomp_t *tcomp;", " \tjpc_dec_rlvl_t *rlvl;", " \tjpc_dec_band_t *band;", " \tint compno;", " \tint rlvlno;", " \tint bandno;", " \tint adjust;", " \tint v;", " \tjpc_dec_ccp_t *ccp;", " \tjpc_dec_cmpt_t *cmpt;", " \tif (jpc_dec_decodecblks(dec, tile)) {", " \t\tjas_eprintf(\"jpc_dec_decodecblks failed\\n\");", " \t\treturn -1;", " \t}", " \tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;", " \t  ++compno, ++tcomp) {", " \t\tccp = &tile->cp->ccps[compno];", " \t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls;", " \t\t  ++rlvlno, ++rlvl) {", " \t\t\tif (!rlvl->bands) {", " \t\t\t\tcontinue;", " \t\t\t}", " \t\t\tfor (bandno = 0, band = rlvl->bands;", " \t\t\t  bandno < rlvl->numbands; ++bandno, ++band) {", " \t\t\t\tif (!band->data) {", " \t\t\t\t\tcontinue;", " \t\t\t\t}", " \t\t\t\tjpc_undo_roi(band->data, band->roishift, ccp->roishift -", " \t\t\t\t  band->roishift, band->numbps);", " \t\t\t\tif (tile->realmode) {", " \t\t\t\t\tjas_matrix_asl(band->data, JPC_FIX_FRACBITS);", " \t\t\t\t\tjpc_dequantize(band->data, band->absstepsize);", " \t\t\t\t}", " \t\t\t}", " \t\t}", " \t}", " \tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;", " \t  ++compno, ++tcomp) {", " \t\tccp = &tile->cp->ccps[compno];", " \t\tjpc_tsfb_synthesize(tcomp->tsfb, tcomp->data);", " \t}", " \tswitch (tile->cp->mctid) {", " \tcase JPC_MCT_RCT:", " \t\tif (dec->numcomps < 3) {", "  \t\t\tjas_eprintf(\"RCT requires at least three components\\n\");", "  \t\t\treturn -1;", "  \t\t}", " \t\tif (!jas_image_cmpt_domains_same(dec->image)) {", " \t\t\tjas_eprintf(\"RCT requires all components have the same domain\\n\");", " \t\t\treturn -1;", " \t\t}", "  \t\tjpc_irct(tile->tcomps[0].data, tile->tcomps[1].data,", "  \t\t  tile->tcomps[2].data);", "  \t\tbreak;", " \tcase JPC_MCT_ICT:", " \t\tif (dec->numcomps < 3) {", "  \t\t\tjas_eprintf(\"ICT requires at least three components\\n\");", "  \t\t\treturn -1;", "  \t\t}", " \t\tif (!jas_image_cmpt_domains_same(dec->image)) {", " \t\t\tjas_eprintf(\"RCT requires all components have the same domain\\n\");", " \t\t\treturn -1;", " \t\t}", "  \t\tjpc_iict(tile->tcomps[0].data, tile->tcomps[1].data,", "  \t\t  tile->tcomps[2].data);", "  \t\tbreak;", " \t}", " \tif (tile->realmode) {", " \t\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;", " \t\t  ++compno, ++tcomp) {", " \t\t\tfor (i = 0; i < jas_matrix_numrows(tcomp->data); ++i) {", " \t\t\t\tfor (j = 0; j < jas_matrix_numcols(tcomp->data); ++j) {", " \t\t\t\t\tv = jas_matrix_get(tcomp->data, i, j);", " \t\t\t\t\tv = jpc_fix_round(v);", " \t\t\t\t\tjas_matrix_set(tcomp->data, i, j, jpc_fixtoint(v));", " \t\t\t\t}", " \t\t\t}", " \t\t}", " \t}", " \tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <", " \t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {", " \t\tadjust = cmpt->sgnd ? 0 : (1 << (cmpt->prec - 1));", " \t\tfor (i = 0; i < jas_matrix_numrows(tcomp->data); ++i) {", " \t\t\tfor (j = 0; j < jas_matrix_numcols(tcomp->data); ++j) {", " \t\t\t\t*jas_matrix_getref(tcomp->data, i, j) += adjust;", " \t\t\t}", " \t\t}", " \t}", " \tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <", " \t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {", " \t\tjpc_fix_t mn;", " \t\tjpc_fix_t mx;", " \t\tmn = cmpt->sgnd ? (-(1 << (cmpt->prec - 1))) : (0);", " \t\tmx = cmpt->sgnd ? ((1 << (cmpt->prec - 1)) - 1) : ((1 <<", " \t\t  cmpt->prec) - 1);", " \t\tjas_matrix_clip(tcomp->data, mn, mx);", " \t}", " \tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <", " \t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {", " \t\tif (jas_image_writecmpt(dec->image, compno, tcomp->xstart -", " \t\t  JPC_CEILDIV(dec->xstart, cmpt->hstep), tcomp->ystart -", " \t\t  JPC_CEILDIV(dec->ystart, cmpt->vstep), jas_matrix_numcols(", " \t\t  tcomp->data), jas_matrix_numrows(tcomp->data), tcomp->data)) {", " \t\t\tjas_eprintf(\"write component failed\\n\");", " \t\t\treturn -1;", " \t\t}", " \t}", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int sc_pkcs15emu_sc_hsm_init (sc_pkcs15_card_t * p15card)", " {", " \tsc_card_t *card = p15card->card;", " \tsc_hsm_private_data_t *priv = (sc_hsm_private_data_t *) card->drv_data;", " \tsc_file_t *file = NULL;", " \tsc_path_t path;", " \tu8 filelist[MAX_EXT_APDU_LENGTH];", " \tint filelistlength;", " \tint r, i;", " \tsc_cvc_t devcert;", " \tstruct sc_app_info *appinfo;", " \tstruct sc_pkcs15_auth_info pin_info;", " \tstruct sc_pkcs15_object pin_obj;", " \tstruct sc_pin_cmd_data pindata;", " \tu8 efbin[1024];", " \tu8 *ptr;", " \tsize_t len;", " \tLOG_FUNC_CALLED(card->ctx);", " \tappinfo = calloc(1, sizeof(struct sc_app_info));", " \tif (appinfo == NULL) {", " \t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);", " \t}", " \tappinfo->aid = sc_hsm_aid;", " \tappinfo->ddo.aid = sc_hsm_aid;", " \tp15card->app = appinfo;", " \tsc_path_set(&path, SC_PATH_TYPE_DF_NAME, sc_hsm_aid.value, sc_hsm_aid.len, 0, 0);", " \tr = sc_select_file(card, &path, &file);", " \tLOG_TEST_RET(card->ctx, r, \"Could not select SmartCard-HSM application\");", " \tp15card->card->version.hw_major = 24;\t ", " \tp15card->card->version.hw_minor = 13;", " \tif (file && file->prop_attr && file->prop_attr_len >= 2) {", " \t\tp15card->card->version.fw_major = file->prop_attr[file->prop_attr_len - 2];", " \t\tp15card->card->version.fw_minor = file->prop_attr[file->prop_attr_len - 1];", " \t}", " \tsc_file_free(file);", " \tif (priv->EF_C_DevAut && priv->EF_C_DevAut_len) {", " \t\tptr = priv->EF_C_DevAut;", " \t\tlen = priv->EF_C_DevAut_len;", " \t} else {", " \t\tlen = sizeof efbin;", "  \t\tr = read_file(p15card, (u8 *) \"\\x2F\\x02\", efbin, &len, 1);", "  \t\tLOG_TEST_RET(card->ctx, r, \"Skipping optional EF.C_DevAut\");", "\t\tptr = realloc(priv->EF_C_DevAut, len);", "\t\tif (ptr) {", "\t\t\tmemcpy(ptr, efbin, len);", "\t\t\tpriv->EF_C_DevAut = ptr;", "\t\t\tpriv->EF_C_DevAut_len = len;", " \t\tif (len > 0) {", " \t\t\tptr = realloc(priv->EF_C_DevAut, len);", " \t\t\tif (ptr) {", " \t\t\t\tmemcpy(ptr, efbin, len);", " \t\t\t\tpriv->EF_C_DevAut = ptr;", " \t\t\t\tpriv->EF_C_DevAut_len = len;", " \t\t\t}", "  \t\t}", "  \t\tptr = efbin;", " \t}", " \tmemset(&devcert, 0 ,sizeof(devcert));", " \tr = sc_pkcs15emu_sc_hsm_decode_cvc(p15card, (const u8 **)&ptr, &len, &devcert);", " \tLOG_TEST_RET(card->ctx, r, \"Could not decode EF.C_DevAut\");", " \tsc_pkcs15emu_sc_hsm_read_tokeninfo(p15card);", " \tif (p15card->tokeninfo->label == NULL) {", " \t\tif (p15card->card->type == SC_CARD_TYPE_SC_HSM_GOID", " \t\t\t\t|| p15card->card->type == SC_CARD_TYPE_SC_HSM_SOC) {", " \t\t\tp15card->tokeninfo->label = strdup(\"GoID\");", " \t\t} else {", " \t\t\tp15card->tokeninfo->label = strdup(\"SmartCard-HSM\");", " \t\t}", " \t\tif (p15card->tokeninfo->label == NULL)", " \t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);", " \t}", " \tif ((p15card->tokeninfo->manufacturer_id != NULL) && !strcmp(\"(unknown)\", p15card->tokeninfo->manufacturer_id)) {", " \t\tfree(p15card->tokeninfo->manufacturer_id);", " \t\tp15card->tokeninfo->manufacturer_id = NULL;", " \t}", " \tif (p15card->tokeninfo->manufacturer_id == NULL) {", " \t\tif (p15card->card->type == SC_CARD_TYPE_SC_HSM_GOID", " \t\t\t\t|| p15card->card->type == SC_CARD_TYPE_SC_HSM_SOC) {", " \t\t\tp15card->tokeninfo->manufacturer_id = strdup(\"Bundesdruckerei GmbH\");", " \t\t} else {", " \t\t\tp15card->tokeninfo->manufacturer_id = strdup(\"www.CardContact.de\");", " \t\t}", " \t\tif (p15card->tokeninfo->manufacturer_id == NULL)", " \t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);", " \t}", " \tappinfo->label = strdup(p15card->tokeninfo->label);", " \tif (appinfo->label == NULL)", " \t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);", " \tlen = strnlen(devcert.chr, sizeof devcert.chr);\t\t ", " \tassert(len >= 8);", " \tlen -= 5;", " \tp15card->tokeninfo->serial_number = calloc(len + 1, 1);", " \tif (p15card->tokeninfo->serial_number == NULL)", " \t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);", " \tmemcpy(p15card->tokeninfo->serial_number, devcert.chr, len);", " \t*(p15card->tokeninfo->serial_number + len) = 0;", " \tsc_hsm_set_serialnr(card, p15card->tokeninfo->serial_number);", " \tsc_pkcs15emu_sc_hsm_free_cvc(&devcert);", " \tmemset(&pin_info, 0, sizeof(pin_info));", " \tmemset(&pin_obj, 0, sizeof(pin_obj));", " \tpin_info.auth_id.len = 1;", " \tpin_info.auth_id.value[0] = 1;", " \tpin_info.path.aid = sc_hsm_aid;", " \tpin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;", " \tpin_info.attrs.pin.reference = 0x81;", " \tpin_info.attrs.pin.flags = SC_PKCS15_PIN_FLAG_LOCAL|SC_PKCS15_PIN_FLAG_INITIALIZED|SC_PKCS15_PIN_FLAG_EXCHANGE_REF_DATA;", " \tpin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;", " \tpin_info.attrs.pin.min_length = 6;", " \tpin_info.attrs.pin.stored_length = 0;", " \tpin_info.attrs.pin.max_length = 15;", " \tpin_info.attrs.pin.pad_char = '\\0';", " \tpin_info.tries_left = 3;", " \tpin_info.max_tries = 3;", " \tpin_obj.auth_id.len = 1;", " \tpin_obj.auth_id.value[0] = 2;", " \tstrlcpy(pin_obj.label, \"UserPIN\", sizeof(pin_obj.label));", " \tpin_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE|SC_PKCS15_CO_FLAG_MODIFIABLE;", " \tr = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);", " \tif (r < 0)", " \t\tLOG_FUNC_RETURN(card->ctx, r);", " \tmemset(&pin_info, 0, sizeof(pin_info));", " \tmemset(&pin_obj, 0, sizeof(pin_obj));", " \tpin_info.auth_id.len = 1;", " \tpin_info.auth_id.value[0] = 2;", " \tpin_info.path.aid = sc_hsm_aid;", " \tpin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;", " \tpin_info.attrs.pin.reference = 0x88;", " \tpin_info.attrs.pin.flags = SC_PKCS15_PIN_FLAG_LOCAL|SC_PKCS15_PIN_FLAG_INITIALIZED|SC_PKCS15_PIN_FLAG_UNBLOCK_DISABLED|SC_PKCS15_PIN_FLAG_SO_PIN;", " \tpin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_BCD;", " \tpin_info.attrs.pin.min_length = 16;", " \tpin_info.attrs.pin.stored_length = 0;", " \tpin_info.attrs.pin.max_length = 16;", " \tpin_info.attrs.pin.pad_char = '\\0';", " \tpin_info.tries_left = 15;", " \tpin_info.max_tries = 15;", " \tstrlcpy(pin_obj.label, \"SOPIN\", sizeof(pin_obj.label));", " \tpin_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE;", " \tr = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);", " \tif (r < 0)", " \t\tLOG_FUNC_RETURN(card->ctx, r);", " \tif (card->type == SC_CARD_TYPE_SC_HSM_SOC", " \t\t\t|| card->type == SC_CARD_TYPE_SC_HSM_GOID) {", " \t\tr = SC_SUCCESS;", " \t} else {", " \t\tmemset(&pindata, 0, sizeof(pindata));", " \t\tpindata.cmd = SC_PIN_CMD_GET_INFO;", " \t\tpindata.pin_type = SC_AC_CHV;", " \t\tpindata.pin_reference = 0x85;", " \t\tr = sc_pin_cmd(card, &pindata, NULL);", " \t}", " \tif (r == SC_ERROR_DATA_OBJECT_NOT_FOUND) {", " \t\tmemset(&pindata, 0, sizeof(pindata));", " \t\tpindata.cmd = SC_PIN_CMD_GET_INFO;", " \t\tpindata.pin_type = SC_AC_CHV;", " \t\tpindata.pin_reference = 0x86;", " \t\tr = sc_pin_cmd(card, &pindata, NULL);", " \t}", " \tif ((r != SC_ERROR_DATA_OBJECT_NOT_FOUND) && (r != SC_ERROR_INCORRECT_PARAMETERS))", " \t\tcard->caps |= SC_CARD_CAP_PROTECTED_AUTHENTICATION_PATH;", " \tfilelistlength = sc_list_files(card, filelist, sizeof(filelist));", " \tLOG_TEST_RET(card->ctx, filelistlength, \"Could not enumerate file and key identifier\");", " \tfor (i = 0; i < filelistlength; i += 2) {", " \t\tswitch(filelist[i]) {", " \t\tcase KEY_PREFIX:", " \t\t\tr = sc_pkcs15emu_sc_hsm_add_prkd(p15card, filelist[i + 1]);", " \t\t\tbreak;", " \t\tcase DCOD_PREFIX:", " \t\t\tr = sc_pkcs15emu_sc_hsm_add_dcod(p15card, filelist[i + 1]);", " \t\t\tbreak;", " \t\tcase CD_PREFIX:", " \t\t\tr = sc_pkcs15emu_sc_hsm_add_cd(p15card, filelist[i + 1]);", " \t\t\tbreak;", " \t\t}", " \t\tif (r != SC_SUCCESS) {", " \t\t\tsc_log(card->ctx, \"Error %d adding elements to framework\", r);", " \t\t}", " \t}", " \tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" pgp_enumerate_blob(sc_card_t *card, pgp_blob_t *blob)", " {", " \tconst u8\t*in;", " \tint\t\tr;", " \tif (blob->files != NULL)", " \t\treturn SC_SUCCESS;", " \tif ((r = pgp_read_blob(card, blob)) < 0)", " \t\treturn r;", " \tin = blob->data;", " \twhile ((int) blob->len > (in - blob->data)) {", " \t\tunsigned int\tcla, tag, tmptag;", " \t\tsize_t\t\tlen;", "  \t\tconst u8\t*data = in;", "  \t\tpgp_blob_t\t*new;", " \t\tif (!in)", " \t\t\treturn SC_ERROR_OBJECT_NOT_VALID;", "  \t\tr = sc_asn1_read_tag(&data, blob->len - (in - blob->data),", "  \t\t\t\t\t&cla, &tag, &len);", "  \t\tif (r < 0 || data == NULL) {", " \t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,", " \t\t\t\t \"Unexpected end of contents\\n\");", "  \t\t\treturn SC_ERROR_OBJECT_NOT_VALID;", "  \t\t}", " \t\tif (data + len > blob->data + blob->len)", " \t\t\treturn SC_ERROR_OBJECT_NOT_VALID;", "  \t\tfor (tmptag = tag; tmptag > 0x0FF; tmptag >>= 8) {", "  \t\t\tcla <<= 8;", " \t\t}", " \t\ttag |= cla;", " \t\tif (tag == blob->id) {", " \t\t\tin = data;", " \t\t\tcontinue;", " \t\t}", " \t\tif ((new = pgp_new_blob(card, blob, tag, sc_file_new())) == NULL)", " \t\t\treturn SC_ERROR_OUT_OF_MEMORY;", " \t\tpgp_set_blob(new, data, len);", " \t\tin = data + len;", " \t}", " \treturn SC_SUCCESS;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)", " {", "  \tjp2_cdef_t *cdef = &box->data.cdef;", "  \tjp2_cdefchan_t *chan;", "  \tunsigned int channo;", " \tcdef->ents = 0;", "  \tif (jp2_getuint16(in, &cdef->numchans)) {", "  \t\treturn -1;", "  \t}", " \tif (!(cdef->ents = jas_alloc2(cdef->numchans, sizeof(jp2_cdefchan_t)))) {", " \t\treturn -1;", " \t}", " \tfor (channo = 0; channo < cdef->numchans; ++channo) {", " \t\tchan = &cdef->ents[channo];", " \t\tif (jp2_getuint16(in, &chan->channo) || jp2_getuint16(in, &chan->type) ||", " \t\t  jp2_getuint16(in, &chan->assoc)) {", " \t\t\treturn -1;", " \t\t}", " \t}", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int rtmp_packet_read_one_chunk(URLContext *h, RTMPPacket *p,", "                                       int chunk_size, RTMPPacket **prev_pkt_ptr,", "                                       int *nb_prev_pkt, uint8_t hdr)", " {", "     uint8_t buf[16];", "     int channel_id, timestamp, size;", "     uint32_t ts_field;  ", "     uint32_t extra = 0;", "     enum RTMPPacketType type;", "     int written = 0;", "     int ret, toread;", "     RTMPPacket *prev_pkt;", "     written++;", "     channel_id = hdr & 0x3F;", "     if (channel_id < 2) {  ", "         buf[1] = 0;", "         if (ffurl_read_complete(h, buf, channel_id + 1) != channel_id + 1)", "             return AVERROR(EIO);", "         written += channel_id + 1;", "         channel_id = AV_RL16(buf) + 64;", "     }", "     if ((ret = ff_rtmp_check_alloc_array(prev_pkt_ptr, nb_prev_pkt,", "                                          channel_id)) < 0)", "         return ret;", "     prev_pkt = *prev_pkt_ptr;", "     size  = prev_pkt[channel_id].size;", "     type  = prev_pkt[channel_id].type;", "     extra = prev_pkt[channel_id].extra;", "     hdr >>= 6;  ", "     if (hdr == RTMP_PS_ONEBYTE) {", "         ts_field = prev_pkt[channel_id].ts_field;", "     } else {", "         if (ffurl_read_complete(h, buf, 3) != 3)", "             return AVERROR(EIO);", "         written += 3;", "         ts_field = AV_RB24(buf);", "         if (hdr != RTMP_PS_FOURBYTES) {", "             if (ffurl_read_complete(h, buf, 3) != 3)", "                 return AVERROR(EIO);", "             written += 3;", "             size = AV_RB24(buf);", "             if (ffurl_read_complete(h, buf, 1) != 1)", "                 return AVERROR(EIO);", "             written++;", "             type = buf[0];", "             if (hdr == RTMP_PS_TWELVEBYTES) {", "                 if (ffurl_read_complete(h, buf, 4) != 4)", "                     return AVERROR(EIO);", "                 written += 4;", "                 extra = AV_RL32(buf);", "             }", "         }", "     }", "     if (ts_field == 0xFFFFFF) {", "         if (ffurl_read_complete(h, buf, 4) != 4)", "             return AVERROR(EIO);", "         timestamp = AV_RB32(buf);", "     } else {", "         timestamp = ts_field;", "     }", "      if (hdr != RTMP_PS_TWELVEBYTES)", "          timestamp += prev_pkt[channel_id].timestamp;", "     if (prev_pkt[channel_id].read && size != prev_pkt[channel_id].size) {", "         av_log(NULL, AV_LOG_ERROR, \"RTMP packet size mismatch %d != %d\\n\",", "                 size,", "                 prev_pkt[channel_id].size);", "         ff_rtmp_packet_destroy(&prev_pkt[channel_id]);", "         prev_pkt[channel_id].read = 0;", "     }", "      if (!prev_pkt[channel_id].read) {", "          if ((ret = ff_rtmp_packet_create(p, channel_id, type, timestamp,", "                                           size)) < 0)", "             return ret;", "         p->read = written;", "         p->offset = 0;", "         prev_pkt[channel_id].ts_field   = ts_field;", "         prev_pkt[channel_id].timestamp  = timestamp;", "     } else {", "         RTMPPacket *prev = &prev_pkt[channel_id];", "         p->data          = prev->data;", "         p->size          = prev->size;", "         p->channel_id    = prev->channel_id;", "         p->type          = prev->type;", "         p->ts_field      = prev->ts_field;", "         p->extra         = prev->extra;", "         p->offset        = prev->offset;", "         p->read          = prev->read + written;", "         p->timestamp     = prev->timestamp;", "         prev->data       = NULL;", "     }", "     p->extra = extra;", "     prev_pkt[channel_id].channel_id = channel_id;", "     prev_pkt[channel_id].type       = type;", "     prev_pkt[channel_id].size       = size;", "     prev_pkt[channel_id].extra      = extra;", "     size = size - p->offset;", "     toread = FFMIN(size, chunk_size);", "     if (ffurl_read_complete(h, p->data + p->offset, toread) != toread) {", "         ff_rtmp_packet_destroy(p);", "         return AVERROR(EIO);", "     }", "     size      -= toread;", "     p->read   += toread;", "     p->offset += toread;", "     if (size > 0) {", "        RTMPPacket *prev = &prev_pkt[channel_id];", "        prev->data = p->data;", "        prev->read = p->read;", "        prev->offset = p->offset;", "        p->data      = NULL;", "        return AVERROR(EAGAIN);", "     }", "     prev_pkt[channel_id].read = 0;  ", "     return p->read;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" Strgrow(Str x)", "  {", "      char *old = x->ptr;", "      int newlen;", "    newlen = x->length * 6 / 5;", "    if (newlen == x->length)", "     newlen = x->area_size * 6 / 5;", "     if (newlen == x->area_size)", "  \tnewlen += 2;", "      x->ptr = GC_MALLOC_ATOMIC(newlen);", "      x->area_size = newlen;", "     bcopy((void *)old, (void *)x->ptr, x->length);", "     GC_free(old);", " }"], "ner_tags": [0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static void build_l4proto_sctp(const struct nf_conntrack *ct, struct nethdr *n)", "  {", "\tct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,", "\t\t      sizeof(struct nfct_attr_grp_port));", "  \tif (!nfct_attr_is_set(ct, ATTR_SCTP_STATE))", "  \t\treturn;", " \tct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,", " \t\t      sizeof(struct nfct_attr_grp_port));", "  \tct_build_u8(ct, ATTR_SCTP_STATE, n, NTA_SCTP_STATE);", "  \tct_build_u32(ct, ATTR_SCTP_VTAG_ORIG, n, NTA_SCTP_VTAG_ORIG);", "  \tct_build_u32(ct, ATTR_SCTP_VTAG_REPL, n, NTA_SCTP_VTAG_REPL);", " }"], "ner_tags": [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0]}
{"tokens": ["  SProcXFixesQueryVersion(ClientPtr client)", "  {", "      REQUEST(xXFixesQueryVersionReq);", "     REQUEST_SIZE_MATCH(xXFixesQueryVersionReq);", "      swaps(&stuff->length);", "      swapl(&stuff->majorVersion);", "     return (*ProcXFixesVector[stuff->xfixesReqType]) (client);", " }"], "ner_tags": [0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": [" poly_in(PG_FUNCTION_ARGS)", " {", " \tchar\t   *str = PG_GETARG_CSTRING(0);", "  \tPOLYGON    *poly;", "  \tint\t\t\tnpts;", "  \tint\t\t\tsize;", " \tint\t\t\tbase_size;", "  \tint\t\t\tisopen;", "  \tchar\t   *s;", " \tif ((npts = pair_count(str, ',')) <= 0)", " \t\tereport(ERROR,", "  \t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),", "  \t\t\t  errmsg(\"invalid input syntax for type polygon: \\\"%s\\\"\", str)));", "\tsize = offsetof(POLYGON, p[0]) +sizeof(poly->p[0]) * npts;", " \tbase_size = sizeof(poly->p[0]) * npts;", " \tsize = offsetof(POLYGON, p[0]) + base_size;", " \tif (base_size / npts != sizeof(poly->p[0]) || size <= base_size)", " \t\tereport(ERROR,", " \t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),", " \t\t\t\t errmsg(\"too many points requested\")));", "  \tpoly = (POLYGON *) palloc0(size);\t ", "  \tSET_VARSIZE(poly, size);", " \tpoly->npts = npts;", " \tif ((!path_decode(FALSE, npts, str, &isopen, &s, &(poly->p[0])))", " \t\t|| (*s != '\\0'))", " \t\tereport(ERROR,", " \t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),", " \t\t\t  errmsg(\"invalid input syntax for type polygon: \\\"%s\\\"\", str)));", " \tmake_bound_box(poly);", " \tPG_RETURN_POLYGON_P(poly);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static av_cold int vqa_decode_init(AVCodecContext *avctx)", " {", "     VqaContext *s = avctx->priv_data;", "     int i, j, codebook_index, ret;", "     s->avctx = avctx;", "     avctx->pix_fmt = AV_PIX_FMT_PAL8;", "     if (s->avctx->extradata_size != VQA_HEADER_SIZE) {", "         av_log(s->avctx, AV_LOG_ERROR, \"expected extradata size of %d\\n\", VQA_HEADER_SIZE);", "         return AVERROR(EINVAL);", "     }", "     s->vqa_version = s->avctx->extradata[0];", "     switch (s->vqa_version) {", "     case 1:", "     case 2:", "         break;", "     case 3:", "         avpriv_report_missing_feature(avctx, \"VQA Version %d\", s->vqa_version);", "         return AVERROR_PATCHWELCOME;", "     default:", "         avpriv_request_sample(avctx, \"VQA Version %i\", s->vqa_version);", "         return AVERROR_PATCHWELCOME;", "      }", "      s->width = AV_RL16(&s->avctx->extradata[6]);", "      s->height = AV_RL16(&s->avctx->extradata[8]);", "    if ((ret = av_image_check_size(s->width, s->height, 0, avctx)) < 0) {", "     if ((ret = ff_set_dimensions(avctx, s->width, s->height)) < 0) {", "          s->width= s->height= 0;", "          return ret;", "      }", "     s->vector_width = s->avctx->extradata[10];", "     s->vector_height = s->avctx->extradata[11];", "     s->partial_count = s->partial_countdown = s->avctx->extradata[13];", "     if ((s->vector_width != 4) ||", "         ((s->vector_height != 2) && (s->vector_height != 4))) {", "         return AVERROR_INVALIDDATA;", "     }", "     if (s->width % s->vector_width || s->height % s->vector_height) {", "         av_log(avctx, AV_LOG_ERROR, \"Image size not multiple of block size\\n\");", "         return AVERROR_INVALIDDATA;", "     }", "     s->codebook_size = MAX_CODEBOOK_SIZE;", "     s->codebook = av_malloc(s->codebook_size);", "     if (!s->codebook)", "         goto fail;", "     s->next_codebook_buffer = av_malloc(s->codebook_size);", "     if (!s->next_codebook_buffer)", "         goto fail;", "     s->decode_buffer_size = (s->width / s->vector_width) *", "         (s->height / s->vector_height) * 2;", "     s->decode_buffer = av_mallocz(s->decode_buffer_size);", "     if (!s->decode_buffer)", "         goto fail;", "     if (s->vector_height == 4) {", "         codebook_index = 0xFF00 * 16;", "         for (i = 0; i < 256; i++)", "             for (j = 0; j < 16; j++)", "                 s->codebook[codebook_index++] = i;", "     } else {", "         codebook_index = 0xF00 * 8;", "         for (i = 0; i < 256; i++)", "             for (j = 0; j < 8; j++)", "                 s->codebook[codebook_index++] = i;", "     }", "     s->next_codebook_buffer_index = 0;", "     return 0;", " fail:", "     av_freep(&s->codebook);", "     av_freep(&s->next_codebook_buffer);", "     av_freep(&s->decode_buffer);", "     return AVERROR(ENOMEM);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" tTcpIpPacketParsingResult ParaNdis_ReviewIPPacket(PVOID buffer, ULONG size, LPCSTR caller)", " tTcpIpPacketParsingResult ParaNdis_ReviewIPPacket(PVOID buffer, ULONG size, BOOLEAN verifyLength, LPCSTR caller)", "  {", "    tTcpIpPacketParsingResult res = QualifyIpPacket((IPHeader *) buffer, size);", "     tTcpIpPacketParsingResult res = QualifyIpPacket((IPHeader *) buffer, size, verifyLength);", "      PrintOutParsingResult(res, 1, caller);", "      return res;", "  }"], "ner_tags": [0, 1, 0, 1, 1, 0, 0, 0]}
{"tokens": [" void CtcpHandler::handlePing(CtcpType ctcptype, const QString &prefix, const QString &target, const QString &param) {", " void CtcpHandler::handlePing(CtcpType ctcptype, const QString &prefix, const QString &target, const QString &param, QString &reply) {", "    Q_UNUSED(target)", "    if(ctcptype == CtcpQuery) {", "    if(_ignoreListManager->ctcpMatch(prefix, network()->networkName(), \"PING\"))", "      return;", "    reply(nickFromMask(prefix), \"PING\", param);", "     reply = param;", "      emit displayMsg(Message::Server, BufferInfo::StatusBuffer, \"\", tr(\"Received CTCP PING request from %1\").arg(prefix));", "    } else {", "     emit displayMsg(Message::Server, BufferInfo::StatusBuffer, \"\", tr(\"Received CTCP TIME request by %1\").arg(prefix));", "   }", "   else {", "     emit displayMsg(Message::Server, BufferInfo::StatusBuffer, \"\", tr(\"Received CTCP TIME answer from %1: %2\")", "    }", "  }"], "ner_tags": [0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void parser(void)", " {", "     char *arg;", " #ifndef MINIMAL", "     char *sitearg;", " #endif", " #ifdef WITH_RFC2640", "     char *narg = NULL;", " #endif", "     size_t n;", " #ifdef IMPLICIT_TLS", "     (void) tls_init_new_session();", "     data_protection_level = CPL_PRIVATE;", " #endif", "     for (;;) {", "         xferfd = -1;", "         if (state_needs_update != 0) {", "             state_needs_update = 0;", "             setprocessname(\"pure-ftpd (IDLE)\");", " #ifdef FTPWHO", "             if (shm_data_cur != NULL) {", "                 ftpwho_lock();", "                 shm_data_cur->state = FTPWHO_STATE_IDLE;", "                 *shm_data_cur->filename = 0;", "                 ftpwho_unlock();", "             }", " #endif", "         }", "         doreply();", "         alarm(idletime * 2);", "         switch (sfgets()) {", "         case -1:", " #ifdef BORING_MODE", "             die(421, LOG_INFO, MSG_TIMEOUT);", " #else", "             die(421, LOG_INFO, MSG_TIMEOUT_PARSER);", " #endif", "         case -2:", "             return;", "         }", " #ifdef DEBUG", "         if (debug != 0) {", "             addreply(0, \"%s\", cmd);", "         }", " #endif", "         n = (size_t) 0U;", "         while ((isalpha((unsigned char) cmd[n]) || cmd[n] == '@') &&", "                n < cmdsize) {", "             cmd[n] = (char) tolower((unsigned char) cmd[n]);", "             n++;", "         }", "         if (n >= cmdsize) {             ", "             die(421, LOG_WARNING, MSG_LINE_TOO_LONG);", "         }", "         if (n == (size_t) 0U) {", "             nop:", "             addreply_noformat(500, \"?\");", "             continue;", "         }", " #ifdef SKIP_COMMAND_TRAILING_SPACES        ", "         while (isspace((unsigned char) cmd[n]) && n < cmdsize) {", "             cmd[n++] = 0;", "         }", "         arg = cmd + n;        ", "         while (cmd[n] != 0 && n < cmdsize) {", "             n++;", "         }", "         n--;", "         while (isspace((unsigned char) cmd[n])) {", "             cmd[n--] = 0;", "         }", " #else", "         if (cmd[n] == 0) {", "             arg = cmd + n;", "         } else if (isspace((unsigned char) cmd[n])) {", "             cmd[n] = 0;", "             arg = cmd + n + 1;", "         } else {", "             goto nop;", "         }", " #endif", "         if (logging != 0) {", " #ifdef DEBUG", "             logfile(LOG_DEBUG, MSG_DEBUG_COMMAND \" [%s] [%s]\",", "                    cmd, arg);", " #else", "             logfile(LOG_DEBUG, MSG_DEBUG_COMMAND \" [%s] [%s]\",", "                    cmd, strcmp(cmd, \"pass\") ? arg : \"<*>\");", " #endif", "         }", " #ifdef WITH_RFC2640", "         narg = charset_client2fs(arg);", " \targ = narg;", " #endif", " #ifndef MINIMAL", "         if (!strcmp(cmd, \"noop\")) {", "             antiidle();", "             donoop();", "             goto wayout;", "         }", " #endif", "         if (!strcmp(cmd, \"user\")) {", " #ifdef WITH_TLS", "             if (enforce_tls_auth > 1 && tls_cnx == NULL) {", "                 die(421, LOG_WARNING, MSG_TLS_NEEDED);", "             }", " #endif", "             douser(arg);", "         } else if (!strcmp(cmd, \"acct\")) {", "             addreply(202, MSG_WHOAREYOU);", "         } else if (!strcmp(cmd, \"pass\")) {", "             if (guest == 0) {", "                 randomdelay();", "             }", "             dopass(arg);", "         } else if (!strcmp(cmd, \"quit\")) {", "             addreply(221, MSG_GOODBYE,", "                      (unsigned long long) ((uploaded + 1023ULL) / 1024ULL),", "                      (unsigned long long) ((downloaded + 1023ULL) / 1024ULL));", "             return;", "         } else if (!strcmp(cmd, \"syst\")) {", "             antiidle();", "             addreply_noformat(215, \"UNIX Type: L8\");", "             goto wayout;", " #ifdef WITH_TLS", "         } else if (enforce_tls_auth > 0 &&", "                    !strcmp(cmd, \"auth\") && !strcasecmp(arg, \"tls\")) {", "              addreply_noformat(234, \"AUTH TLS OK.\");", "              doreply();", "              if (tls_cnx == NULL) {", "                 flush_cmd();", "                  (void) tls_init_new_session();", "              }", "              goto wayout;", "         } else if (!strcmp(cmd, \"pbsz\")) {", "             addreply_noformat(tls_cnx == NULL ? 503 : 200, \"PBSZ=0\");", "         } else if (!strcmp(cmd, \"prot\")) {", "             if (tls_cnx == NULL) {", "                 addreply_noformat(503, MSG_PROT_BEFORE_PBSZ);", "                 goto wayout;", "             }", "             switch (*arg) {", "             case 0:", "                 addreply_noformat(503, MSG_MISSING_ARG);", "                 data_protection_level = CPL_NONE;", "                 break;", "             case 'C':", "                 if (arg[1] == 0) {", "                     addreply(200, MSG_PROT_OK, \"clear\");", "                     data_protection_level = CPL_CLEAR;", "                     break;", "                 }", "             case 'S':", "             case 'E':", "                 if (arg[1] == 0) {", "                     addreply(200, MSG_PROT_UNKNOWN_LEVEL, arg, \"private\");", "                     data_protection_level = CPL_PRIVATE;", "                     break;", "                 }", "             case 'P':", "                 if (arg[1] == 0) {", "                     addreply(200, MSG_PROT_OK, \"private\");", "                     data_protection_level = CPL_PRIVATE;", "                     break;", "                 }", "             default:", "                 addreply_noformat(534, \"Fallback to [C]\");", "                 data_protection_level = CPL_CLEAR;", "                 break;", "             }", " #endif", "         } else if (!strcmp(cmd, \"auth\") || !strcmp(cmd, \"adat\")) {", "             addreply_noformat(500, MSG_AUTH_UNIMPLEMENTED);", "         } else if (!strcmp(cmd, \"type\")) {", "             antiidle();", "             dotype(arg);", "             goto wayout;", "         } else if (!strcmp(cmd, \"mode\")) {", "             antiidle();                ", "             domode(arg);", "             goto wayout;", " #ifndef MINIMAL", "         } else if (!strcmp(cmd, \"feat\")) {", "             dofeat();", "             goto wayout;", " \t} else if (!strcmp(cmd, \"opts\")) {", " \t    doopts(arg);", " \t    goto wayout;", " #endif", "         } else if (!strcmp(cmd, \"stru\")) {", "             dostru(arg);", "             goto wayout;", " #ifndef MINIMAL", "         } else if (!strcmp(cmd, \"help\")) {", "             goto help_site;", " #endif", " #ifdef DEBUG", "         } else if (!strcmp(cmd, \"xdbg\")) {", "             debug++;", "             addreply(200, MSG_XDBG_OK, debug);", "             goto wayout;", " #endif            ", "         } else if (loggedin == 0) {            ", "             addreply_noformat(530, MSG_NOT_LOGGED_IN);", "             goto wayout;", "         } else {", "             if (!strcmp(cmd, \"cwd\") || !strcmp(cmd, \"xcwd\")) {", "                 antiidle();", "                 docwd(arg);", "                 goto wayout;", "             } else if (!strcmp(cmd, \"port\")) {", "                 doport(arg);", " #ifndef MINIMAL", "             } else if (!strcmp(cmd, \"eprt\")) {", "                 doeprt(arg);", "             } else if (!strcmp(cmd, \"esta\") &&", "                        disallow_passive == 0 &&", "                        STORAGE_FAMILY(force_passive_ip) == 0) {", "                 doesta();", "             } else if (!strcmp(cmd, \"estp\")) {", "                 doestp();", " #endif", "             } else if (disallow_passive == 0 && ", "                        (!strcmp(cmd, \"pasv\") || !strcmp(cmd, \"p@sw\"))) {", "                 dopasv(0);", "             } else if (disallow_passive == 0 && ", "                        (!strcmp(cmd, \"epsv\") && ", "                        (broken_client_compat == 0 ||", "                         STORAGE_FAMILY(ctrlconn) == AF_INET6))) {", "                 if (!strcasecmp(arg, \"all\")) {", "                     epsv_all = 1;", "                     addreply_noformat(220, MSG_ACTIVE_DISABLED);", "                 } else if (!strcmp(arg, \"2\") && !v6ready) {", "                     addreply_noformat(522, MSG_ONLY_IPV4);", "                 } else {", "                     dopasv(1);", "                 }", " #ifndef MINIMAL            ", "             } else if (disallow_passive == 0 && !strcmp(cmd, \"spsv\")) {", "                 dopasv(2);", "             } else if (!strcmp(cmd, \"allo\")) {", "                 if (*arg == 0) {", "                     addreply_noformat(501, MSG_STAT_FAILURE);", "                 } else {", "                     const off_t size = (off_t) strtoull(arg, NULL, 10);", "                     if (size < (off_t) 0) {", "                         addreply_noformat(501, MSG_STAT_FAILURE);                        ", "                     } else {", "                         doallo(size);", "                     }", "                 }", " #endif", "             } else if (!strcmp(cmd, \"pwd\") || !strcmp(cmd, \"xpwd\")) {", " #ifdef WITH_RFC2640", " \t\tchar *nwd;", " #endif", "                 antiidle();", " #ifdef WITH_RFC2640", " \t\tnwd = charset_fs2client(wd);", " \t\taddreply(257, \"\\\"%s\\\" \" MSG_IS_YOUR_CURRENT_LOCATION, nwd);", " \t\tfree(nwd);", " #else", "                 addreply(257, \"\\\"%s\\\" \" MSG_IS_YOUR_CURRENT_LOCATION, wd);", " #endif", "                 goto wayout;                ", "             } else if (!strcmp(cmd, \"cdup\") || !strcmp(cmd, \"xcup\")) {", "                 docwd(\"..\");", "             } else if (!strcmp(cmd, \"retr\")) {", "                 if (*arg != 0) {", " #ifdef WITH_TLS", "                     if (enforce_tls_auth == 3 &&", "                         data_protection_level != CPL_PRIVATE) {", "                         addreply_noformat(521, MSG_PROT_PRIVATE_NEEDED);", "                     }", "                     else", " #endif", "                     {", "                         doretr(arg);", "                     }", "                 } else {", "                     addreply_noformat(501, MSG_NO_FILE_NAME);", "                 }", "             } else if (!strcmp(cmd, \"rest\")) {", "                 antiidle();", "                 if (*arg != 0) {", "                     dorest(arg);", "                 } else {", "                     addreply_noformat(501, MSG_NO_RESTART_POINT);", "                     restartat = (off_t) 0;", "                 }", "                 goto wayout;", "             } else if (!strcmp(cmd, \"dele\")) {", "                 if (*arg != 0) {", "                     dodele(arg);", "                 } else {", "                     addreply_noformat(501, MSG_NO_FILE_NAME);", "                 }", "             } else if (!strcmp(cmd, \"stor\")) {", "                 arg = revealextraspc(arg);", "                 if (*arg != 0) {", " #ifdef WITH_TLS", "                     if (enforce_tls_auth == 3 &&", "                         data_protection_level != CPL_PRIVATE) {", "                         addreply_noformat(521, MSG_PROT_PRIVATE_NEEDED);", "                     } else ", " #endif", "                     {", "                         dostor(arg, 0, autorename);", "                     }", "                 } else {", "                     addreply_noformat(501, MSG_NO_FILE_NAME);", "                 }", "             } else if (!strcmp(cmd, \"appe\")) {", "                 arg = revealextraspc(arg);", "                 if (*arg != 0) {", " #ifdef WITH_TLS", "                     if (enforce_tls_auth == 3 &&", "                         data_protection_level != CPL_PRIVATE) {", "                         addreply_noformat(521, MSG_PROT_PRIVATE_NEEDED);", "                     } else ", " #endif", "                     {", "                         dostor(arg, 1, 0);", "                     }", "                 } else {", "                     addreply_noformat(501, MSG_NO_FILE_NAME);", "                 }", " #ifndef MINIMAL", "             } else if (!strcmp(cmd, \"stou\")) {", " #ifdef WITH_TLS", "                 if (enforce_tls_auth == 3 &&", "                     data_protection_level != CPL_PRIVATE) {", "                     addreply_noformat(521, MSG_PROT_PRIVATE_NEEDED);", "                 } else ", " #endif", "                 {", "             \t     dostou();", "                 }", " #endif", " #ifndef DISABLE_MKD_RMD", "             } else if (!strcmp(cmd, \"mkd\") || !strcmp(cmd, \"xmkd\")) {", "                 arg = revealextraspc(arg);", "                 if (*arg != 0) {", "                     domkd(arg);", "                 } else {", "                     addreply_noformat(501, MSG_NO_DIRECTORY_NAME);", "                 }", "             } else if (!strcmp(cmd, \"rmd\") || !strcmp(cmd, \"xrmd\")) {", "                 if (*arg != 0) {", "                     dormd(arg);", "                 } else {", "                     addreply_noformat(550, MSG_NO_DIRECTORY_NAME);", "                 }", " #endif", " #ifndef MINIMAL", "             } else if (!strcmp(cmd, \"stat\")) {", "                 if (*arg != 0) {", "                     modern_listings = 0;", "                     donlist(arg, 1, 1, 1, 1);", "                 } else {", "                     addreply_noformat(211, \"http:www.pureftpd.org/\");", "                 }", " #endif", "             } else if (!strcmp(cmd, \"list\")) {", " #ifndef MINIMAL", "                 modern_listings = 0;", " #endif", " #ifdef WITH_TLS", "                 if (enforce_tls_auth == 3 &&", "                     data_protection_level != CPL_PRIVATE) {", "                     addreply_noformat(521, MSG_PROT_PRIVATE_NEEDED);", "                 } else", " #endif", "                 {", "                     donlist(arg, 0, 1, 0, 1);", "                 }", "             } else if (!strcmp(cmd, \"nlst\")) {", " #ifndef MINIMAL                ", "                 modern_listings = 0;", " #endif", " #ifdef WITH_TLS", "                 if (enforce_tls_auth == 3 &&", "                     data_protection_level != CPL_PRIVATE) {", "                     addreply_noformat(521, MSG_PROT_PRIVATE_NEEDED);", "                 } else", " #endif", "                 {", "                     donlist(arg, 0, 0, 0, broken_client_compat);", "                 }", " #ifndef MINIMAL", "             } else if (!strcmp(cmd, \"mlst\")) {", " #ifdef WITH_TLS", "                 if (enforce_tls_auth == 3 &&", "                     data_protection_level != CPL_PRIVATE) {", "                     addreply_noformat(521, MSG_PROT_PRIVATE_NEEDED);", "                 } else", " #endif", "                 {", "                     domlst(*arg != 0 ? arg : \".\");", "                 }", "             } else if (!strcmp(cmd, \"mlsd\")) {", "                 modern_listings = 1;", " #ifdef WITH_TLS", "                 if (enforce_tls_auth == 3 &&", "                     data_protection_level != CPL_PRIVATE) {", "                     addreply_noformat(521, MSG_PROT_PRIVATE_NEEDED);", "                 } else", " #endif", "                 {", "                     donlist(arg, 0, 1, 1, 0);", "                 }", " #endif", "             } else if (!strcmp(cmd, \"abor\")) {", "                 addreply_noformat(226, MSG_ABOR_SUCCESS);", " #ifndef MINIMAL", "             } else if (!strcmp(cmd, \"site\")) {", "                 if ((sitearg = arg) != NULL) {", "                     while (*sitearg != 0 && !isspace((unsigned char) *sitearg)) {", "                         sitearg++;", "                     }", "                     if (*sitearg != 0) {", "                         *sitearg++ = 0;", "                     }", "                 }", "                 if (!strcasecmp(arg, \"idle\")) {", "                     if (sitearg == NULL || *sitearg == 0) {", "                         addreply_noformat(501, \"SITE IDLE: \" MSG_MISSING_ARG);", "                     } else {", "                         unsigned long int i = 0;", "                         i = strtoul(sitearg, &sitearg, 10);", "                         if (sitearg && *sitearg)", "                             addreply(501, MSG_GARBAGE_FOUND \" : %s\", sitearg);", "                         else if (i > MAX_SITE_IDLE)", "                             addreply_noformat(501, MSG_VALUE_TOO_LARGE);", "                         else {", "                             idletime = i;", "                             addreply(200, MSG_IDLE_TIME, idletime);", "                             idletime_noop = (double) idletime * 2.0;", "                         }", "                     }", "                 } else if (!strcasecmp(arg, \"time\")) {", "                     dositetime();", "                 } else if (!strcasecmp(arg, \"help\")) {", "                     help_site:", "                     addreply_noformat(214, MSG_SITE_HELP CRLF", " # ifdef WITH_DIRALIASES", "                                       \" ALIAS\" CRLF", " # endif", "                                       \" CHMOD\" CRLF \" IDLE\" CRLF \" UTIME\");", "                     addreply_noformat(214, \"Pure-FTPd - http:pureftpd.org/\");", "                 } else if (!strcasecmp(arg, \"chmod\")) {", "                     char *sitearg2;", "                     mode_t mode;", "                     parsechmod:", "                     if (sitearg == NULL || *sitearg == 0) {", "                         addreply_noformat(501, MSG_MISSING_ARG);", "                         goto chmod_wayout;", "                     }", "                     sitearg2 = sitearg;", "                     while (*sitearg2 != 0 && !isspace((unsigned char) *sitearg2)) {", "                         sitearg2++;", "                     }                    ", "                     while (*sitearg2 != 0 && isspace((unsigned char) *sitearg2)) {", "                         sitearg2++;", "                     }                    ", "                     if (*sitearg2 == 0) {", "                         addreply_noformat(550, MSG_NO_FILE_NAME);", "                         goto chmod_wayout;", "                     }", "                     mode = (mode_t) strtoul(sitearg, NULL, 8);", "                     if (mode > (mode_t) 07777) {", "                         addreply_noformat(501, MSG_BAD_CHMOD);", "                         goto chmod_wayout;", "                     }", "                     dochmod(sitearg2, mode);", "                     chmod_wayout:", "                     (void) 0;", "                 } else if (!strcasecmp(arg, \"utime\")) {", "                     char *sitearg2;", "                     if (sitearg == NULL || *sitearg == 0) {", "                         addreply_noformat(501, MSG_NO_FILE_NAME);", "                         goto utime_wayout;", "                     }\t\t    ", "                     if ((sitearg2 = strrchr(sitearg, ' ')) == NULL ||", "                         sitearg2 == sitearg) {", "                         addreply_noformat(501, MSG_MISSING_ARG);", "                         goto utime_wayout;", "                     }", "                     if (strcasecmp(sitearg2, \" UTC\") != 0) {", "                         addreply_noformat(500, \"UTC Only\");", "                         goto utime_wayout;\t\t\t", "                     }", "                     *sitearg2-- = 0;", "                     if ((sitearg2 = strrchr(sitearg, ' ')) == NULL ||", "                         sitearg2 == sitearg) {", "                         utime_no_arg:", "                         addreply_noformat(501, MSG_MISSING_ARG);", "                         goto utime_wayout;", "                     }", "                     *sitearg2-- = 0;", "                     if ((sitearg2 = strrchr(sitearg, ' ')) == NULL ||", "                         sitearg2 == sitearg) {", "                         goto utime_no_arg;", "                     }", "                     *sitearg2-- = 0;", "                     if ((sitearg2 = strrchr(sitearg, ' ')) == NULL ||", "                         sitearg2 == sitearg) {", "                         goto utime_no_arg;", "                     }", "                     *sitearg2++ = 0;", "                     if (*sitearg2 == 0) {", "                         goto utime_no_arg;\t\t\t", "                     }", "                     doutime(sitearg, sitearg2);", "                     utime_wayout:", "                     (void) 0;", " # ifdef WITH_DIRALIASES\t\t    ", "                 } else if (!strcasecmp(arg, \"alias\")) {", "                     if (sitearg == NULL || *sitearg == 0) {", "                         print_aliases();", "                     } else {", "                         const char *alias;", "                         if ((alias = lookup_alias(sitearg)) != NULL) {", "                             addreply(214, MSG_ALIASES_ALIAS, sitearg, alias);", "                         } else {", "                             addreply(502, MSG_ALIASES_UNKNOWN, sitearg);", "                         }", "                     }", " # endif", "                 } else if (*arg != 0) {", "                     addreply(500, \"SITE %s \" MSG_UNKNOWN_EXTENSION, arg);", "                 } else {", "                     addreply_noformat(500, \"SITE: \" MSG_MISSING_ARG);", "                 }", " #endif", "             } else if (!strcmp(cmd, \"mdtm\")) {", "                 domdtm(arg);", "             } else if (!strcmp(cmd, \"size\")) {", "                 dosize(arg);", " #ifndef MINIMAL", "             } else if (!strcmp(cmd, \"chmod\")) {", "                 sitearg = arg;", "                 goto parsechmod;", " #endif", "             } else if (!strcmp(cmd, \"rnfr\")) {", "                 if (*arg != 0) {", "                     dornfr(arg);", "                 } else {", "                     addreply_noformat(550, MSG_NO_FILE_NAME);", "                 }", "             } else if (!strcmp(cmd, \"rnto\")) {", "                 arg = revealextraspc(arg);", "                 if (*arg != 0) {", "                     dornto(arg);", "                 } else {", "                     addreply_noformat(550, MSG_NO_FILE_NAME);", "                 }", "             } else {", "                 addreply_noformat(500, MSG_UNKNOWN_COMMAND);", "             }", "         }", "         noopidle = (time_t) -1;", "         wayout:", " #ifdef WITH_RFC2640", "         free(narg);", "         narg = NULL;", " #endif", " #ifdef THROTTLING", "         if (throttling_delay != 0UL) {", "             usleep2(throttling_delay);", "         }", " #else", "         (void) 0;", " #endif", "     }", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int filter_frame(AVFilterLink *inlink, AVFrame *in)", " {", "     AVFilterContext *ctx = inlink->dst;", "     LutContext *s = ctx->priv;", "     AVFilterLink *outlink = ctx->outputs[0];", "     AVFrame *out;", "     uint8_t *inrow, *outrow, *inrow0, *outrow0;", "     int i, j, plane, direct = 0;", "     if (av_frame_is_writable(in)) {", "         direct = 1;", "         out = in;", "     } else {", "         out = ff_get_video_buffer(outlink, outlink->w, outlink->h);", "         if (!out) {", "             av_frame_free(&in);", "             return AVERROR(ENOMEM);", "         }", "         av_frame_copy_props(out, in);", "     }", "     if (s->is_rgb) {", "         inrow0  = in ->data[0];", "         outrow0 = out->data[0];", "         for (i = 0; i < in->height; i ++) {", "             int w = inlink->w;", "             const uint8_t (*tab)[256] = (const uint8_t (*)[256])s->lut;", "             inrow  = inrow0;", "             outrow = outrow0;", "             for (j = 0; j < w; j++) {", "                 switch (s->step) {", "                 case 4:  outrow[3] = tab[3][inrow[3]];  ", "                 case 3:  outrow[2] = tab[2][inrow[2]];  ", "                 case 2:  outrow[1] = tab[1][inrow[1]];  ", "                 default: outrow[0] = tab[0][inrow[0]];", "                 }", "                 outrow += s->step;", "                 inrow  += s->step;", "             }", "             inrow0  += in ->linesize[0];", "             outrow0 += out->linesize[0];", "          }", "      } else {", "        for (plane = 0; plane < 4 && in->data[plane]; plane++) {", "         for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++) {", "              int vsub = plane == 1 || plane == 2 ? s->vsub : 0;", "              int hsub = plane == 1 || plane == 2 ? s->hsub : 0;", "              int h = FF_CEIL_RSHIFT(inlink->h, vsub);", "             int w = FF_CEIL_RSHIFT(inlink->w, hsub);", "             inrow  = in ->data[plane];", "             outrow = out->data[plane];", "             for (i = 0; i < h; i++) {", "                 const uint8_t *tab = s->lut[plane];", "                 for (j = 0; j < w; j++)", "                     outrow[j] = tab[inrow[j]];", "                 inrow  += in ->linesize[plane];", "                 outrow += out->linesize[plane];", "             }", "         }", "     }", "     if (!direct)", "         av_frame_free(&in);", "     return ff_filter_frame(outlink, out);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int ff_mov_write_packet(AVFormatContext *s, AVPacket *pkt)", " {", "     MOVMuxContext *mov = s->priv_data;", "     AVIOContext *pb = s->pb;", "     MOVTrack *trk = &mov->tracks[pkt->stream_index];", "     AVCodecParameters *par = trk->par;", "     unsigned int samples_in_chunk = 0;", "     int size = pkt->size, ret = 0;", "     uint8_t *reformatted_data = NULL;", "     ret = check_pkt(s, pkt);", "     if (ret < 0)", "         return ret;", "     if (mov->flags & FF_MOV_FLAG_FRAGMENT) {", "         int ret;", "         if (mov->moov_written || mov->flags & FF_MOV_FLAG_EMPTY_MOOV) {", "             if (mov->frag_interleave && mov->fragments > 0) {", "                 if (trk->entry - trk->entries_flushed >= mov->frag_interleave) {", "                     if ((ret = mov_flush_fragment_interleaving(s, trk)) < 0)", "                         return ret;", "                 }", "             }", "             if (!trk->mdat_buf) {", "                 if ((ret = avio_open_dyn_buf(&trk->mdat_buf)) < 0)", "                     return ret;", "             }", "             pb = trk->mdat_buf;", "         } else {", "             if (!mov->mdat_buf) {", "                 if ((ret = avio_open_dyn_buf(&mov->mdat_buf)) < 0)", "                     return ret;", "             }", "             pb = mov->mdat_buf;", "         }", "     }", "     if (par->codec_id == AV_CODEC_ID_AMR_NB) {", "         static const uint16_t packed_size[16] =", "             {13, 14, 16, 18, 20, 21, 27, 32, 6, 0, 0, 0, 0, 0, 0, 1};", "         int len = 0;", "         while (len < size && samples_in_chunk < 100) {", "             len += packed_size[(pkt->data[len] >> 3) & 0x0F];", "             samples_in_chunk++;", "         }", "         if (samples_in_chunk > 1) {", "             av_log(s, AV_LOG_ERROR, \"fatal error, input is not a single packet, implement a AVParser for it\\n\");", "             return -1;", "         }", "     } else if (par->codec_id == AV_CODEC_ID_ADPCM_MS ||", "                par->codec_id == AV_CODEC_ID_ADPCM_IMA_WAV) {", "         samples_in_chunk = trk->par->frame_size;", "     } else if (trk->sample_size)", "         samples_in_chunk = size / trk->sample_size;", "      else", "          samples_in_chunk = 1;", "     if (samples_in_chunk < 1) {", "         av_log(s, AV_LOG_ERROR, \"fatal error, input packet contains no samples\\n\");", "         return AVERROR_PATCHWELCOME;", "     }", "      if (trk->vos_len == 0 && par->extradata_size > 0 &&", "          !TAG_IS_AVCI(trk->tag) &&", "         (par->codec_id != AV_CODEC_ID_DNXHD)) {", "         trk->vos_len  = par->extradata_size;", "         trk->vos_data = av_malloc(trk->vos_len);", "         if (!trk->vos_data) {", "             ret = AVERROR(ENOMEM);", "             goto err;", "         }", "         memcpy(trk->vos_data, par->extradata, trk->vos_len);", "     }", "     if (par->codec_id == AV_CODEC_ID_AAC && pkt->size > 2 &&", "         (AV_RB16(pkt->data) & 0xfff0) == 0xfff0) {", "         if (!s->streams[pkt->stream_index]->nb_frames) {", "             av_log(s, AV_LOG_ERROR, \"Malformed AAC bitstream detected: \"", "                    \"use the audio bitstream filter 'aac_adtstoasc' to fix it \"", "                    \"('-bsf:a aac_adtstoasc' option with ffmpeg)\\n\");", "             return -1;", "         }", "         av_log(s, AV_LOG_WARNING, \"aac bitstream error\\n\");", "     }", "     if (par->codec_id == AV_CODEC_ID_H264 && trk->vos_len > 0 && *(uint8_t *)trk->vos_data != 1 && !TAG_IS_AVCI(trk->tag)) {", "         if (trk->hint_track >= 0 && trk->hint_track < mov->nb_streams) {", "             ff_avc_parse_nal_units_buf(pkt->data, &reformatted_data,", "                                        &size);", "             avio_write(pb, reformatted_data, size);", "         } else {", "             if (trk->cenc.aes_ctr) {", "                 size = ff_mov_cenc_avc_parse_nal_units(&trk->cenc, pb, pkt->data, size);", "                 if (size < 0) {", "                     ret = size;", "                     goto err;", "                 }", "             } else {", "                 size = ff_avc_parse_nal_units(pb, pkt->data, pkt->size);", "             }", "         }", "     } else if (par->codec_id == AV_CODEC_ID_HEVC && trk->vos_len > 6 &&", "                (AV_RB24(trk->vos_data) == 1 || AV_RB32(trk->vos_data) == 1)) {", "         if (trk->hint_track >= 0 && trk->hint_track < mov->nb_streams) {", "             ff_hevc_annexb2mp4_buf(pkt->data, &reformatted_data, &size, 0, NULL);", "             avio_write(pb, reformatted_data, size);", "         } else {", "             size = ff_hevc_annexb2mp4(pb, pkt->data, pkt->size, 0, NULL);", "         }", " #if CONFIG_AC3_PARSER", "     } else if (par->codec_id == AV_CODEC_ID_EAC3) {", "         size = handle_eac3(mov, pkt, trk);", "         if (size < 0)", "             return size;", "         else if (!size)", "             goto end;", "         avio_write(pb, pkt->data, size);", " #endif", "     } else {", "         if (trk->cenc.aes_ctr) {", "             if (par->codec_id == AV_CODEC_ID_H264 && par->extradata_size > 4) {", "                 int nal_size_length = (par->extradata[4] & 0x3) + 1;", "                 ret = ff_mov_cenc_avc_write_nal_units(s, &trk->cenc, nal_size_length, pb, pkt->data, size);", "             } else {", "                 ret = ff_mov_cenc_write_packet(&trk->cenc, pb, pkt->data, size);", "             }", "             if (ret) {", "                 goto err;", "             }", "         } else {", "             avio_write(pb, pkt->data, size);", "         }", "     }", "     if ((par->codec_id == AV_CODEC_ID_DNXHD ||", "          par->codec_id == AV_CODEC_ID_AC3) && !trk->vos_len) {", "         trk->vos_len  = size;", "         trk->vos_data = av_malloc(size);", "         if (!trk->vos_data) {", "             ret = AVERROR(ENOMEM);", "             goto err;", "         }", "         memcpy(trk->vos_data, pkt->data, size);", "     }", "     if (trk->entry >= trk->cluster_capacity) {", "         unsigned new_capacity = 2 * (trk->entry + MOV_INDEX_CLUSTER_SIZE);", "         if (av_reallocp_array(&trk->cluster, new_capacity,", "                               sizeof(*trk->cluster))) {", "             ret = AVERROR(ENOMEM);", "             goto err;", "         }", "         trk->cluster_capacity = new_capacity;", "     }", "     trk->cluster[trk->entry].pos              = avio_tell(pb) - size;", "     trk->cluster[trk->entry].samples_in_chunk = samples_in_chunk;", "     trk->cluster[trk->entry].chunkNum         = 0;", "     trk->cluster[trk->entry].size             = size;", "     trk->cluster[trk->entry].entries          = samples_in_chunk;", "     trk->cluster[trk->entry].dts              = pkt->dts;", "     trk->cluster[trk->entry].pts              = pkt->pts;", "     if (!trk->entry && trk->start_dts != AV_NOPTS_VALUE) {", "         if (!trk->frag_discont) {", "             trk->cluster[trk->entry].dts = trk->start_dts + trk->track_duration;", "             if ((mov->flags & FF_MOV_FLAG_DASH && !(mov->flags & FF_MOV_FLAG_GLOBAL_SIDX)) ||", "                 mov->mode == MODE_ISM)", "                 pkt->pts = pkt->dts + trk->end_pts - trk->cluster[trk->entry].dts;", "         } else {", "             trk->frag_start = pkt->dts - trk->start_dts;", "             trk->end_pts = AV_NOPTS_VALUE;", "             trk->frag_discont = 0;", "         }", "     }", "     if (!trk->entry && trk->start_dts == AV_NOPTS_VALUE && !mov->use_editlist &&", "         s->avoid_negative_ts == AVFMT_AVOID_NEG_TS_MAKE_ZERO) {", "         trk->cluster[trk->entry].dts = trk->start_dts = 0;", "     }", "     if (trk->start_dts == AV_NOPTS_VALUE) {", "         trk->start_dts = pkt->dts;", "         if (trk->frag_discont) {", "             if (mov->use_editlist) {", "                 trk->frag_start = pkt->pts;", "                 trk->start_dts  = pkt->dts - pkt->pts;", "             } else {", "                 trk->frag_start = pkt->dts;", "                 trk->start_dts  = 0;", "             }", "             trk->frag_discont = 0;", "         } else if (pkt->dts && mov->moov_written)", "             av_log(s, AV_LOG_WARNING,", "                    \"Track %d starts with a nonzero dts %\"PRId64\", while the moov \"", "                    \"already has been written. Set the delay_moov flag to handle \"", "                    \"this case.\\n\",", "                    pkt->stream_index, pkt->dts);", "     }", "     trk->track_duration = pkt->dts - trk->start_dts + pkt->duration;", "     trk->last_sample_is_subtitle_end = 0;", "     if (pkt->pts == AV_NOPTS_VALUE) {", "         av_log(s, AV_LOG_WARNING, \"pts has no value\\n\");", "         pkt->pts = pkt->dts;", "     }", "     if (pkt->dts != pkt->pts)", "         trk->flags |= MOV_TRACK_CTTS;", "     trk->cluster[trk->entry].cts   = pkt->pts - pkt->dts;", "     trk->cluster[trk->entry].flags = 0;", "     if (trk->start_cts == AV_NOPTS_VALUE)", "         trk->start_cts = pkt->pts - pkt->dts;", "     if (trk->end_pts == AV_NOPTS_VALUE)", "         trk->end_pts = trk->cluster[trk->entry].dts +", "                        trk->cluster[trk->entry].cts + pkt->duration;", "     else", "         trk->end_pts = FFMAX(trk->end_pts, trk->cluster[trk->entry].dts +", "                                            trk->cluster[trk->entry].cts +", "                                            pkt->duration);", "     if (par->codec_id == AV_CODEC_ID_VC1) {", "         mov_parse_vc1_frame(pkt, trk);", "     } else if (pkt->flags & AV_PKT_FLAG_KEY) {", "         if (mov->mode == MODE_MOV && par->codec_id == AV_CODEC_ID_MPEG2VIDEO &&", "             trk->entry > 0) {  ", "             mov_parse_mpeg2_frame(pkt, &trk->cluster[trk->entry].flags);", "             if (trk->cluster[trk->entry].flags & MOV_PARTIAL_SYNC_SAMPLE)", "                 trk->flags |= MOV_TRACK_STPS;", "         } else {", "             trk->cluster[trk->entry].flags = MOV_SYNC_SAMPLE;", "         }", "         if (trk->cluster[trk->entry].flags & MOV_SYNC_SAMPLE)", "             trk->has_keyframes++;", "     }", "     if (pkt->flags & AV_PKT_FLAG_DISPOSABLE) {", "         trk->cluster[trk->entry].flags |= MOV_DISPOSABLE_SAMPLE;", "         trk->has_disposable++;", "     }", "     trk->entry++;", "     trk->sample_count += samples_in_chunk;", "     mov->mdat_size    += size;", "     if (trk->hint_track >= 0 && trk->hint_track < mov->nb_streams)", "         ff_mov_add_hinted_packet(s, pkt, trk->hint_track, trk->entry,", "                                  reformatted_data, size);", " end:", " err:", "     av_free(reformatted_data);", "     return ret;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int main(int argc, char *argv[])", " {", "     char buff[1024];", "     int fd, nr, nw;", "     if (argc < 2) {", "         fprintf(stderr,", "                 \"usage: %s output-filename\\n\"", "                 \"       %s |output-command\\n\"", "                 \"       %s :host:port\\n\", argv[0], argv[0], argv[0]);", "         return 1;", "     }", "     fd = open_gen_fd(argv[1]);", "     if (fd < 0) {", "         perror(\"open_gen_fd\");", "         exit(EXIT_FAILURE);", "     }", "     while ((nr = read(0, buff, sizeof (buff))) != 0) {", "         if (nr < 0) {", "             if (errno == EINTR)", "                 continue;", "             perror(\"read\");", "             exit(EXIT_FAILURE);", "         }", "         nw = write(fd, buff, nr);", "         if (nw < 0) {", "             perror(\"write\");", "              exit(EXIT_FAILURE);", "          }", "      }", " \tclose(fd);", "      return 0;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": [" static int vrend_decode_create_ve(struct vrend_decode_ctx *ctx, uint32_t handle, uint16_t length)", " {", "    struct pipe_vertex_element *ve = NULL;", "    int num_elements;", "    int i;", "    int ret;", "    if (length < 1)", "       return EINVAL;", "    if ((length - 1) % 4)", "       return EINVAL;", "    num_elements = (length - 1) / 4;", "    if (num_elements) {", "       ve = calloc(num_elements, sizeof(struct pipe_vertex_element));", "       if (!ve)", "          return ENOMEM;", "       for (i = 0; i < num_elements; i++) {", "           ve[i].src_offset = get_buf_entry(ctx, VIRGL_OBJ_VERTEX_ELEMENTS_V0_SRC_OFFSET(i));", "           ve[i].instance_divisor = get_buf_entry(ctx, VIRGL_OBJ_VERTEX_ELEMENTS_V0_INSTANCE_DIVISOR(i));", "           ve[i].vertex_buffer_index = get_buf_entry(ctx, VIRGL_OBJ_VERTEX_ELEMENTS_V0_VERTEX_BUFFER_INDEX(i));", "          if (ve[i].vertex_buffer_index >= PIPE_MAX_ATTRIBS)", "             return EINVAL;", "           ve[i].src_format = get_buf_entry(ctx, VIRGL_OBJ_VERTEX_ELEMENTS_V0_SRC_FORMAT(i));", "        }", "     }", "    return ret;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" parse_codes(struct archive_read *a)", " {", "   int i, j, val, n, r;", "   unsigned char bitlengths[MAX_SYMBOLS], zerocount, ppmd_flags;", "   unsigned int maxorder;", "   struct huffman_code precode;", "   struct rar *rar = (struct rar *)(a->format->data);", "   struct rar_br *br = &(rar->br);", "   free_codes(a);", "   rar_br_consume_unalined_bits(br);", "   if (!rar_br_read_ahead(a, br, 1))", "     goto truncated_data;", "   if ((rar->is_ppmd_block = rar_br_bits(br, 1)) != 0)", "   {", "     rar_br_consume(br, 1);", "     if (!rar_br_read_ahead(a, br, 7))", "       goto truncated_data;", "     ppmd_flags = rar_br_bits(br, 7);", "     rar_br_consume(br, 7);", "     if (ppmd_flags & 0x20)", "     {", "       if (!rar_br_read_ahead(a, br, 8))", "         goto truncated_data;", "       rar->dictionary_size = (rar_br_bits(br, 8) + 1) << 20;", "       rar_br_consume(br, 8);", "     }", "     if (ppmd_flags & 0x40)", "     {", "       if (!rar_br_read_ahead(a, br, 8))", "         goto truncated_data;", "       rar->ppmd_escape = rar->ppmd7_context.InitEsc = rar_br_bits(br, 8);", "       rar_br_consume(br, 8);", "     }", "     else", "       rar->ppmd_escape = 2;", "     if (ppmd_flags & 0x20)", "     {", "       maxorder = (ppmd_flags & 0x1F) + 1;", "       if(maxorder > 16)", "         maxorder = 16 + (maxorder - 16) * 3;", "       if (maxorder == 1)", "       {", "         archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", "                           \"Truncated RAR file data\");", "         return (ARCHIVE_FATAL);", "       }", "       __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context);", "       rar->bytein.a = a;", "       rar->bytein.Read = &ppmd_read;", "       __archive_ppmd7_functions.PpmdRAR_RangeDec_CreateVTable(&rar->range_dec);", "       rar->range_dec.Stream = &rar->bytein;", "       __archive_ppmd7_functions.Ppmd7_Construct(&rar->ppmd7_context);", "       if (rar->dictionary_size == 0) {", " \t      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", "                           \"Invalid zero dictionary size\");", " \t      return (ARCHIVE_FATAL);", "       }", "       if (!__archive_ppmd7_functions.Ppmd7_Alloc(&rar->ppmd7_context,", "         rar->dictionary_size))", "       {", "         archive_set_error(&a->archive, ENOMEM,", "                           \"Out of memory\");", "         return (ARCHIVE_FATAL);", "       }", "       if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec))", "       {", "         archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", "                           \"Unable to initialize PPMd range decoder\");", "         return (ARCHIVE_FATAL);", "       }", "       __archive_ppmd7_functions.Ppmd7_Init(&rar->ppmd7_context, maxorder);", "       rar->ppmd_valid = 1;", "     }", "     else", "     {", "       if (!rar->ppmd_valid) {", "         archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", "                           \"Invalid PPMd sequence\");", "         return (ARCHIVE_FATAL);", "       }", "       if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec))", "       {", "         archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", "                           \"Unable to initialize PPMd range decoder\");", "         return (ARCHIVE_FATAL);", "       }", "     }", "   }", "   else", "   {", "     rar_br_consume(br, 1);", "     if (!rar_br_read_ahead(a, br, 1))", "       goto truncated_data;", "     if (!rar_br_bits(br, 1))", "       memset(rar->lengthtable, 0, sizeof(rar->lengthtable));", "     rar_br_consume(br, 1);", "     memset(&bitlengths, 0, sizeof(bitlengths));", "     for (i = 0; i < MAX_SYMBOLS;)", "     {", "       if (!rar_br_read_ahead(a, br, 4))", "         goto truncated_data;", "       bitlengths[i++] = rar_br_bits(br, 4);", "       rar_br_consume(br, 4);", "       if (bitlengths[i-1] == 0xF)", "       {", "         if (!rar_br_read_ahead(a, br, 4))", "           goto truncated_data;", "         zerocount = rar_br_bits(br, 4);", "         rar_br_consume(br, 4);", "         if (zerocount)", "         {", "           i--;", "           for (j = 0; j < zerocount + 2 && i < MAX_SYMBOLS; j++)", "             bitlengths[i++] = 0;", "         }", "       }", "     }", "     memset(&precode, 0, sizeof(precode));", "     r = create_code(a, &precode, bitlengths, MAX_SYMBOLS, MAX_SYMBOL_LENGTH);", "     if (r != ARCHIVE_OK) {", "       free(precode.tree);", "       free(precode.table);", "       return (r);", "     }", "     for (i = 0; i < HUFFMAN_TABLE_SIZE;)", "     {", "       if ((val = read_next_symbol(a, &precode)) < 0) {", "         free(precode.tree);", "         free(precode.table);", "         return (ARCHIVE_FATAL);", "       }", "       if (val < 16)", "       {", "         rar->lengthtable[i] = (rar->lengthtable[i] + val) & 0xF;", "         i++;", "       }", "       else if (val < 18)", "       {", "         if (i == 0)", "         {", "           free(precode.tree);", "           free(precode.table);", "           archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", "                             \"Internal error extracting RAR file.\");", "           return (ARCHIVE_FATAL);", "         }", "         if(val == 16) {", "           if (!rar_br_read_ahead(a, br, 3)) {", "             free(precode.tree);", "             free(precode.table);", "             goto truncated_data;", "           }", "           n = rar_br_bits(br, 3) + 3;", "           rar_br_consume(br, 3);", "         } else {", "           if (!rar_br_read_ahead(a, br, 7)) {", "             free(precode.tree);", "             free(precode.table);", "             goto truncated_data;", "           }", "           n = rar_br_bits(br, 7) + 11;", "           rar_br_consume(br, 7);", "         }", "         for (j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++)", "         {", "           rar->lengthtable[i] = rar->lengthtable[i-1];", "           i++;", "         }", "       }", "       else", "       {", "         if(val == 18) {", "           if (!rar_br_read_ahead(a, br, 3)) {", "             free(precode.tree);", "             free(precode.table);", "             goto truncated_data;", "           }", "           n = rar_br_bits(br, 3) + 3;", "           rar_br_consume(br, 3);", "         } else {", "           if (!rar_br_read_ahead(a, br, 7)) {", "             free(precode.tree);", "             free(precode.table);", "             goto truncated_data;", "           }", "           n = rar_br_bits(br, 7) + 11;", "           rar_br_consume(br, 7);", "         }", "         for(j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++)", "           rar->lengthtable[i++] = 0;", "       }", "     }", "     free(precode.tree);", "     free(precode.table);", "     r = create_code(a, &rar->maincode, &rar->lengthtable[0], MAINCODE_SIZE,", "                 MAX_SYMBOL_LENGTH);", "     if (r != ARCHIVE_OK)", "       return (r);", "     r = create_code(a, &rar->offsetcode, &rar->lengthtable[MAINCODE_SIZE],", "                 OFFSETCODE_SIZE, MAX_SYMBOL_LENGTH);", "     if (r != ARCHIVE_OK)", "       return (r);", "     r = create_code(a, &rar->lowoffsetcode,", "                 &rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE],", "                 LOWOFFSETCODE_SIZE, MAX_SYMBOL_LENGTH);", "     if (r != ARCHIVE_OK)", "       return (r);", "     r = create_code(a, &rar->lengthcode,", "                 &rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE +", "                 LOWOFFSETCODE_SIZE], LENGTHCODE_SIZE, MAX_SYMBOL_LENGTH);", "     if (r != ARCHIVE_OK)", "       return (r);", "   }", "   if (!rar->dictionary_size || !rar->lzss.window)", "   {", "     void *new_window;", "     unsigned int new_size;", "     if (rar->unp_size >= DICTIONARY_MAX_SIZE)", "        new_size = DICTIONARY_MAX_SIZE;", "      else", "        new_size = rar_fls((unsigned int)rar->unp_size) << 1;", "     if (new_size == 0) {", "       archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", "                         \"Zero window size is invalid.\");", "       return (ARCHIVE_FATAL);", "     }", "      new_window = realloc(rar->lzss.window, new_size);", "      if (new_window == NULL) {", "        archive_set_error(&a->archive, ENOMEM,", "                         \"Unable to allocate memory for uncompressed data.\");", "       return (ARCHIVE_FATAL);", "     }", "     rar->lzss.window = (unsigned char *)new_window;", "     rar->dictionary_size = new_size;", "     memset(rar->lzss.window, 0, rar->dictionary_size);", "     rar->lzss.mask = rar->dictionary_size - 1;", "   }", "   rar->start_new_table = 0;", "   return (ARCHIVE_OK);", " truncated_data:", "   archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", "                     \"Truncated RAR file data\");", "   rar->valid = 0;", "   return (ARCHIVE_FATAL);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" GF_Err gf_isom_oinf_read_entry(void *entry, GF_BitStream *bs)", " {", " \tGF_OperatingPointsInformation* ptr = (GF_OperatingPointsInformation *)entry;", " \tu32 i, j, count;", " \tif (!ptr) return GF_BAD_PARAM;", " \tptr->scalability_mask = gf_bs_read_u16(bs);", " \tgf_bs_read_int(bs, 2); ", " \tcount = gf_bs_read_int(bs, 6);", " \tfor (i = 0; i < count; i++) {", " \t\tLHEVC_ProfileTierLevel *ptl;", " \t\tGF_SAFEALLOC(ptl, LHEVC_ProfileTierLevel);", " \t\tif (!ptl) return GF_OUT_OF_MEM;", " \t\tptl->general_profile_space = gf_bs_read_int(bs, 2);", " \t\tptl->general_tier_flag= gf_bs_read_int(bs, 1);", " \t\tptl->general_profile_idc = gf_bs_read_int(bs, 5);", " \t\tptl->general_profile_compatibility_flags = gf_bs_read_u32(bs);", " \t\tptl->general_constraint_indicator_flags = gf_bs_read_long_int(bs, 48);", " \t\tptl->general_level_idc = gf_bs_read_u8(bs);", " \t\tgf_list_add(ptr->profile_tier_levels, ptl);", " \t}", " \tcount = gf_bs_read_u16(bs);", " \tfor (i = 0; i < count; i++) {", " \t\tLHEVC_OperatingPoint *op;", " \t\tGF_SAFEALLOC(op, LHEVC_OperatingPoint);", " \t\tif (!op) return GF_OUT_OF_MEM;", "  \t\top->output_layer_set_idx = gf_bs_read_u16(bs);", "  \t\top->max_temporal_id = gf_bs_read_u8(bs);", "  \t\top->layer_count = gf_bs_read_u8(bs);", " \t\tif (op->layer_count > ARRAY_LENGTH(op->layers_info))", " \t\t\treturn GF_NON_COMPLIANT_BITSTREAM;", "  \t\tfor (j = 0; j < op->layer_count; j++) {", "  \t\t\top->layers_info[j].ptl_idx = gf_bs_read_u8(bs);", "  \t\t\top->layers_info[j].layer_id = gf_bs_read_int(bs, 6);", " \t\t\top->layers_info[j].is_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;", " \t\t\top->layers_info[j].is_alternate_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;", " \t\t}", " \t\top->minPicWidth = gf_bs_read_u16(bs);", " \t\top->minPicHeight = gf_bs_read_u16(bs);", " \t\top->maxPicWidth = gf_bs_read_u16(bs);", " \t\top->maxPicHeight = gf_bs_read_u16(bs);", " \t\top->maxChromaFormat = gf_bs_read_int(bs, 2);", " \t\top->maxBitDepth = gf_bs_read_int(bs, 3) + 8;", " \t\tgf_bs_read_int(bs, 1); ", " \t\top->frame_rate_info_flag = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;", " \t\top->bit_rate_info_flag = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;", " \t\tif (op->frame_rate_info_flag) {", " \t\t\top->avgFrameRate = gf_bs_read_u16(bs);", " \t\t\tgf_bs_read_int(bs, 6);  ", " \t\t\top->constantFrameRate = gf_bs_read_int(bs, 2);", " \t\t}", " \t\tif (op->bit_rate_info_flag) {", " \t\t\top->maxBitRate = gf_bs_read_u32(bs);", " \t\t\top->avgBitRate = gf_bs_read_u32(bs);", " \t\t}", " \t\tgf_list_add(ptr->operating_points, op);", " \t}", " \tcount = gf_bs_read_u8(bs);", " \tfor (i = 0; i < count; i++) {", " \t\tLHEVC_DependentLayer *dep;", " \t\tGF_SAFEALLOC(dep, LHEVC_DependentLayer);", " \t\tif (!dep) return GF_OUT_OF_MEM;", " \t\tdep->dependent_layerID = gf_bs_read_u8(bs);", " \t\tdep->num_layers_dependent_on = gf_bs_read_u8(bs);", " \t\tfor (j = 0; j < dep->num_layers_dependent_on; j++)", " \t\t\tdep->dependent_on_layerID[j] = gf_bs_read_u8(bs);", " \t\tfor (j = 0; j < 16; j++) {", " \t\t\tif (ptr->scalability_mask & (1 << j))", " \t\t\t\tdep->dimension_identifier[j] = gf_bs_read_u8(bs);", " \t\t}", " \t\tgf_list_add(ptr->dependency_layers, dep);", " \t}", " \treturn GF_OK;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void WritePixels(struct ngiflib_img * i, struct ngiflib_decode_context * context, const u8 * pixels, u16 n) {", " \tu16 tocopy;\t", " \tstruct ngiflib_gif * p = i->parent;", " \twhile(n > 0) {", " \t\ttocopy = (context->Xtogo < n) ? context->Xtogo : n;", " \t\tif(!i->gce.transparent_flag) {", " #ifndef NGIFLIB_INDEXED_ONLY", " \t\t\tif(p->mode & NGIFLIB_MODE_INDEXED) {", " #endif  ", " \t\t\t\tngiflib_memcpy(context->frbuff_p.p8, pixels, tocopy);", " \t\t\t\tpixels += tocopy;", " \t\t\t\tcontext->frbuff_p.p8 += tocopy;", " #ifndef NGIFLIB_INDEXED_ONLY", " \t\t\t} else {", " \t\t\t\tint j;", " \t\t\t\tfor(j = (int)tocopy; j > 0; j--) {", " \t\t\t\t\t*(context->frbuff_p.p32++) =", " \t\t\t\t\t   GifIndexToTrueColor(i->palette, *pixels++);", " \t\t\t\t}", " \t\t\t}", " #endif  ", " \t\t} else {", " \t\t\tint j;", " #ifndef NGIFLIB_INDEXED_ONLY", " \t\t\tif(p->mode & NGIFLIB_MODE_INDEXED) {", " #endif  ", " \t\t\t\tfor(j = (int)tocopy; j > 0; j--) {", " \t\t\t\t\tif(*pixels != i->gce.transparent_color) *context->frbuff_p.p8 = *pixels;", " \t\t\t\t\tpixels++;", " \t\t\t\t\tcontext->frbuff_p.p8++;", " \t\t\t\t}", " #ifndef NGIFLIB_INDEXED_ONLY", " \t\t\t} else {", " \t\t\t\tfor(j = (int)tocopy; j > 0; j--) {", " \t\t\t\t\tif(*pixels != i->gce.transparent_color) {", " \t\t\t\t\t\t*context->frbuff_p.p32 = GifIndexToTrueColor(i->palette, *pixels);", " \t\t\t\t\t}", " \t\t\t\t\tpixels++;", " \t\t\t\t\tcontext->frbuff_p.p32++;", " \t\t\t\t}", " \t\t\t}", " #endif  ", " \t\t}", " \t\tcontext->Xtogo -= tocopy;", " \t\tif(context->Xtogo == 0) {", " \t\t\t#ifdef NGIFLIB_ENABLE_CALLBACKS", " \t\t\tif(p->line_cb) p->line_cb(p, context->line_p, context->curY);", " \t\t\t#endif  ", " \t\t\tcontext->Xtogo = i->width;", " \t\t\tswitch(context->pass) {", " \t\t\tcase 0:", " \t\t\t\tcontext->curY++;", "  \t\t\t\tbreak;", "  \t\t\tcase 1:\t ", "  \t\t\t\tcontext->curY += 8;", "\t\t\t\tif(context->curY >= p->height) {", "\t\t\t\t\tcontext->pass++;", "\t\t\t\t\tcontext->curY = i->posY + 4;", "\t\t\t\t}", "  \t\t\t\tbreak;", "  \t\t\tcase 2:\t ", "  \t\t\t\tcontext->curY += 8;", "\t\t\t\tif(context->curY >= p->height) {", "\t\t\t\t\tcontext->pass++;", "\t\t\t\t\tcontext->curY = i->posY + 2;", "\t\t\t\t}", "  \t\t\t\tbreak;", "  \t\t\tcase 3:\t ", "  \t\t\t\tcontext->curY += 4;", "\t\t\t\tif(context->curY >= p->height) {", "\t\t\t\t\tcontext->pass++;", "\t\t\t\t\tcontext->curY = i->posY + 1;", "\t\t\t\t}", "  \t\t\t\tbreak;", "  \t\t\tcase 4:\t ", "  \t\t\t\tcontext->curY += 2;", "  \t\t\t\tbreak;", "  \t\t\t}", " \t\t\twhile(context->pass > 0 && context->pass < 4 &&", " \t\t\t      context->curY >= p->height) {", " \t\t\t\tswitch(++context->pass) {", " \t\t\t\tcase 2:\t ", " \t\t\t\t\tcontext->curY = i->posY + 4;", " \t\t\t\t\tbreak;", " \t\t\t\tcase 3:\t ", " \t\t\t\t\tcontext->curY = i->posY + 2;", " \t\t\t\t\tbreak;", " \t\t\t\tcase 4:\t ", " \t\t\t\t\tcontext->curY = i->posY + 1;", " \t\t\t\t\tbreak;", " \t\t\t\t}", " \t\t\t}", "  #ifndef NGIFLIB_INDEXED_ONLY", "  \t\t\tif(p->mode & NGIFLIB_MODE_INDEXED) {", "  #endif  ", " \t\t\t\t#ifdef NGIFLIB_ENABLE_CALLBACKS", " \t\t\t\tcontext->line_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width;", " \t\t\t\tcontext->frbuff_p.p8 = context->line_p.p8 + i->posX;", " \t\t\t\t#else", " \t\t\t\tcontext->frbuff_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width + i->posX;", " \t\t\t\t#endif  ", " #ifndef NGIFLIB_INDEXED_ONLY", " \t\t\t} else {", " \t\t\t\t#ifdef NGIFLIB_ENABLE_CALLBACKS", " \t\t\t\tcontext->line_p.p32 = p->frbuff.p32 + (u32)context->curY*p->width;", " \t\t\t\tcontext->frbuff_p.p32 = context->line_p.p32 + i->posX;", " \t\t\t\t#else", " \t\t\t\tcontext->frbuff_p.p32 = p->frbuff.p32 + (u32)context->curY*p->width + i->posX;", " \t\t\t\t#endif  ", " \t\t\t}", " #endif  ", " \t\t}", " \t\tn -= tocopy;", " \t}", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void jpc_qmfb_split_colres(jpc_fix_t *a, int numrows, int numcols,", "   int stride, int parity)", " {", " \tint bufsize = JPC_CEILDIVPOW2(numrows, 1);", " \tjpc_fix_t splitbuf[QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE];", " \tjpc_fix_t *buf = splitbuf;", " \tjpc_fix_t *srcptr;", " \tjpc_fix_t *dstptr;", " \tregister jpc_fix_t *srcptr2;", " \tregister jpc_fix_t *dstptr2;", " \tregister int n;", " \tregister int i;", " \tint m;", " \tint hstartcol;", "  \tif (bufsize > QMFB_SPLITBUFSIZE) {", "\t\tif (!(buf = jas_alloc2(bufsize, sizeof(jpc_fix_t)))) {", " \t\tif (!(buf = jas_alloc3(bufsize, numcols, sizeof(jpc_fix_t)))) {", "  \t\t\tabort();", "  \t\t}", " \t}", " \tif (numrows >= 2) {", " \t\thstartcol = (numrows + 1 - parity) >> 1;", " \t\tm = numrows - hstartcol;", " \t\tn = m;", " \t\tdstptr = buf;", " \t\tsrcptr = &a[(1 - parity) * stride];", " \t\twhile (n-- > 0) {", " \t\t\tdstptr2 = dstptr;", " \t\t\tsrcptr2 = srcptr;", " \t\t\tfor (i = 0; i < numcols; ++i) {", " \t\t\t\t*dstptr2 = *srcptr2;", " \t\t\t\t++dstptr2;", " \t\t\t\t++srcptr2;", " \t\t\t}", " \t\t\tdstptr += numcols;", " \t\t\tsrcptr += stride << 1;", " \t\t}", " \t\tdstptr = &a[(1 - parity) * stride];", " \t\tsrcptr = &a[(2 - parity) * stride];", " \t\tn = numrows - m - (!parity);", " \t\twhile (n-- > 0) {", " \t\t\tdstptr2 = dstptr;", " \t\t\tsrcptr2 = srcptr;", " \t\t\tfor (i = 0; i < numcols; ++i) {", " \t\t\t\t*dstptr2 = *srcptr2;", " \t\t\t\t++dstptr2;", " \t\t\t\t++srcptr2;", " \t\t\t}", " \t\t\tdstptr += stride;", " \t\t\tsrcptr += stride << 1;", " \t\t}", " \t\tdstptr = &a[hstartcol * stride];", " \t\tsrcptr = buf;", " \t\tn = m;", " \t\twhile (n-- > 0) {", " \t\t\tdstptr2 = dstptr;", " \t\t\tsrcptr2 = srcptr;", " \t\t\tfor (i = 0; i < numcols; ++i) {", " \t\t\t\t*dstptr2 = *srcptr2;", " \t\t\t\t++dstptr2;", " \t\t\t\t++srcptr2;", " \t\t\t}", " \t\t\tdstptr += stride;", " \t\t\tsrcptr += numcols;", " \t\t}", " \t}", " \tif (buf != splitbuf) {", " \t\tjas_free(buf);", " \t}", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void Rp_test(js_State *J)", "  {", "  \tjs_Regexp *re;", "  \tconst char *text;", " \tint result;", "  \tint opts;", "  \tResub m;", " \tre = js_toregexp(J, 0);", " \ttext = js_tostring(J, 1);", " \topts = 0;", " \tif (re->flags & JS_REGEXP_G) {", " \t\tif (re->last > strlen(text)) {", " \t\t\tre->last = 0;", " \t\t\tjs_pushboolean(J, 0);", " \t\t\treturn;", " \t\t}", " \t\tif (re->last > 0) {", " \t\t\ttext += re->last;", " \t\t\topts |= REG_NOTBOL;", "  \t\t}", "  \t}", "\tif (!js_regexec(re->prog, text, &m, opts)) {", " \tresult = js_regexec(re->prog, text, &m, opts);", " \tif (result < 0)", " \t\tjs_error(J, \"regexec failed\");", " \tif (result == 0) {", "  \t\tif (re->flags & JS_REGEXP_G)", "  \t\t\tre->last = re->last + (m.sub[0].ep - text);", "  \t\tjs_pushboolean(J, 1);", " \t\treturn;", " \t}", " \tif (re->flags & JS_REGEXP_G)", " \t\tre->last = 0;", " \tjs_pushboolean(J, 0);", " }"], "ner_tags": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void faad_resetbits(bitfile *ld, int bits)", " {", "     uint32_t tmp;", "      int words = bits >> 5;", "      int remainder = bits & 0x1F;", "    ld->bytes_left = ld->buffer_size - words*4;", "     if (ld->buffer_size < words * 4)", "         ld->bytes_left = 0;", "     else", "         ld->bytes_left = ld->buffer_size - words*4;", "      if (ld->bytes_left >= 4)", "      {", "         tmp = getdword(&ld->start[words]);", "         ld->bytes_left -= 4;", "     } else {", "         tmp = getdword_n(&ld->start[words], ld->bytes_left);", "         ld->bytes_left = 0;", "     }", "     ld->bufa = tmp;", "     if (ld->bytes_left >= 4)", "     {", "         tmp = getdword(&ld->start[words+1]);", "         ld->bytes_left -= 4;", "     } else {", "         tmp = getdword_n(&ld->start[words+1], ld->bytes_left);", "         ld->bytes_left = 0;", "     }", "     ld->bufb = tmp;", "     ld->bits_left = 32 - remainder;", "     ld->tail = &ld->start[words+2];", "     ld->error = 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int ape_decode_frame(AVCodecContext *avctx, void *data,", "                             int *got_frame_ptr, AVPacket *avpkt)", " {", "     AVFrame *frame     = data;", "     const uint8_t *buf = avpkt->data;", "     APEContext *s = avctx->priv_data;", "     uint8_t *sample8;", "     int16_t *sample16;", "      int32_t *sample24;", "      int i, ch, ret;", "      int blockstodecode;", "     uint64_t decoded_buffer_size;", "     av_assert0(s->samples >= 0);", "     if(!s->samples){", "         uint32_t nblocks, offset;", "         int buf_size;", "         if (!avpkt->size) {", "             *got_frame_ptr = 0;", "             return 0;", "         }", "         if (avpkt->size < 8) {", "             av_log(avctx, AV_LOG_ERROR, \"Packet is too small\\n\");", "             return AVERROR_INVALIDDATA;", "         }", "         buf_size = avpkt->size & ~3;", "         if (buf_size != avpkt->size) {", "             av_log(avctx, AV_LOG_WARNING, \"packet size is not a multiple of 4. \"", "                    \"extra bytes at the end will be skipped.\\n\");", "         }", "         if (s->fileversion < 3950)  ", "             buf_size += 2;", "         av_fast_padded_malloc(&s->data, &s->data_size, buf_size);", "         if (!s->data)", "             return AVERROR(ENOMEM);", "         s->bdsp.bswap_buf((uint32_t *) s->data, (const uint32_t *) buf,", "                           buf_size >> 2);", "         memset(s->data + (buf_size & ~3), 0, buf_size & 3);", "         s->ptr = s->data;", "         s->data_end = s->data + buf_size;", "         nblocks = bytestream_get_be32(&s->ptr);", "         offset  = bytestream_get_be32(&s->ptr);", "         if (s->fileversion >= 3900) {", "             if (offset > 3) {", "                 av_log(avctx, AV_LOG_ERROR, \"Incorrect offset passed\\n\");", "                 s->data = NULL;", "                 return AVERROR_INVALIDDATA;", "             }", "             if (s->data_end - s->ptr < offset) {", "                 av_log(avctx, AV_LOG_ERROR, \"Packet is too small\\n\");", "                 return AVERROR_INVALIDDATA;", "             }", "             s->ptr += offset;", "         } else {", "             if ((ret = init_get_bits8(&s->gb, s->ptr, s->data_end - s->ptr)) < 0)", "                 return ret;", "             if (s->fileversion > 3800)", "                 skip_bits_long(&s->gb, offset * 8);", "             else", "                  skip_bits_long(&s->gb, offset);", "          }", "        if (!nblocks || nblocks > INT_MAX) {", "         if (!nblocks || nblocks > INT_MAX / 2 / sizeof(*s->decoded_buffer) - 8) {", "              av_log(avctx, AV_LOG_ERROR, \"Invalid sample count: %\"PRIu32\".\\n\",", "                     nblocks);", "              return AVERROR_INVALIDDATA;", "         }", "         if (init_frame_decoder(s) < 0) {", "             av_log(avctx, AV_LOG_ERROR, \"Error reading frame header\\n\");", "             return AVERROR_INVALIDDATA;", "         }", "         s->samples = nblocks;", "     }", "     if (!s->data) {", "         *got_frame_ptr = 0;", "         return avpkt->size;", "     }", "     blockstodecode = FFMIN(s->blocks_per_loop, s->samples);", "     if (s->fileversion < 3930)", "          blockstodecode = s->samples;", "    av_fast_malloc(&s->decoded_buffer, &s->decoded_size,", "                   2 * FFALIGN(blockstodecode, 8) * sizeof(*s->decoded_buffer));", "     decoded_buffer_size = 2LL * FFALIGN(blockstodecode, 8) * sizeof(*s->decoded_buffer);", "     av_assert0(decoded_buffer_size <= INT_MAX);", "     av_fast_malloc(&s->decoded_buffer, &s->decoded_size, decoded_buffer_size);", "      if (!s->decoded_buffer)", "          return AVERROR(ENOMEM);", "      memset(s->decoded_buffer, 0, s->decoded_size);", "     s->decoded[0] = s->decoded_buffer;", "     s->decoded[1] = s->decoded_buffer + FFALIGN(blockstodecode, 8);", "     frame->nb_samples = blockstodecode;", "     if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)", "         return ret;", "     s->error=0;", "     if ((s->channels == 1) || (s->frameflags & APE_FRAMECODE_PSEUDO_STEREO))", "         ape_unpack_mono(s, blockstodecode);", "     else", "         ape_unpack_stereo(s, blockstodecode);", "     emms_c();", "     if (s->error) {", "         s->samples=0;", "         av_log(avctx, AV_LOG_ERROR, \"Error decoding frame\\n\");", "         return AVERROR_INVALIDDATA;", "     }", "     switch (s->bps) {", "     case 8:", "         for (ch = 0; ch < s->channels; ch++) {", "             sample8 = (uint8_t *)frame->data[ch];", "             for (i = 0; i < blockstodecode; i++)", "                 *sample8++ = (s->decoded[ch][i] + 0x80) & 0xff;", "         }", "         break;", "     case 16:", "         for (ch = 0; ch < s->channels; ch++) {", "             sample16 = (int16_t *)frame->data[ch];", "             for (i = 0; i < blockstodecode; i++)", "                 *sample16++ = s->decoded[ch][i];", "         }", "         break;", "     case 24:", "         for (ch = 0; ch < s->channels; ch++) {", "             sample24 = (int32_t *)frame->data[ch];", "             for (i = 0; i < blockstodecode; i++)", "                 *sample24++ = s->decoded[ch][i] << 8;", "         }", "         break;", "     }", "     s->samples -= blockstodecode;", "     *got_frame_ptr = 1;", "     return !s->samples ? avpkt->size : 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" g_NPN_GetValue(NPP instance, NPNVariable variable, void *value)", " {", "   D(bug(\"NPN_GetValue instance=%p, variable=%d [%s]\\n\", instance, variable, string_of_NPNVariable(variable)));", "   if (!thread_check()) {", " \tnpw_printf(\"WARNING: NPN_GetValue not called from the main thread\\n\");", " \treturn NPERR_INVALID_INSTANCE_ERROR;", "   }", "   PluginInstance *plugin = NULL;", "   if (instance)", " \tplugin = PLUGIN_INSTANCE(instance);", "   switch (variable) {", "   case NPNVxDisplay:", " \t*(void **)value = x_display;", " \tbreak;", "   case NPNVxtAppContext:", " \t*(void **)value = XtDisplayToApplicationContext(x_display);", " \tbreak;", "   case NPNVToolkit:", " \t*(NPNToolkitType *)value = NPW_TOOLKIT;", " \tbreak;", " #if USE_XPCOM", "   case NPNVserviceManager: {", " \tnsIServiceManager *sm;", " \tint ret = NS_GetServiceManager(&sm);", " \tif (NS_FAILED(ret)) {", " \t  npw_printf(\"WARNING: NS_GetServiceManager failed\\n\");", " \t  return NPERR_GENERIC_ERROR;", " \t}", " \t*(nsIServiceManager **)value = sm;", " \tbreak;", "   }", "   case NPNVDOMWindow:", "   case NPNVDOMElement:", " \tnpw_printf(\"WARNING: %s is not supported by NPN_GetValue()\\n\", string_of_NPNVariable(variable));", " \treturn NPERR_INVALID_PARAM;", " #endif", "   case NPNVnetscapeWindow:", " \tif (plugin == NULL) {", " \t  npw_printf(\"ERROR: NPNVnetscapeWindow requires a non NULL instance\\n\");", " \t  return NPERR_INVALID_INSTANCE_ERROR;", " \t}", " \tif (plugin->browser_toplevel == NULL) {", " \t  GdkNativeWindow netscape_xid = None;", " \t  NPError error = g_NPN_GetValue_real(instance, variable, &netscape_xid);", " \t  if (error != NPERR_NO_ERROR)", " \t\treturn error;", " \t  if (netscape_xid == None)", " \t\treturn NPERR_GENERIC_ERROR;", " \t  plugin->browser_toplevel = gdk_window_foreign_new(netscape_xid);", " \t  if (plugin->browser_toplevel == NULL)", " \t\treturn NPERR_GENERIC_ERROR;", " \t}", " \t*((GdkNativeWindow *)value) = GDK_WINDOW_XWINDOW(plugin->browser_toplevel);", " \tbreak;", " #if ALLOW_WINDOWLESS_PLUGINS", "   case NPNVSupportsWindowless:", " #endif", "    case NPNVSupportsXEmbedBool:", "    case NPNVWindowNPObject:", "    case NPNVPluginElementNPObject:", "   case NPNVprivateModeBool:", "   case NPNVsupportsAdvancedKeyHandling:", "  \treturn g_NPN_GetValue_real(instance, variable, value);", "    default:", "  \tswitch (variable & 0xff) {", " \tcase 13:  ", " \t  if (NPW_TOOLKIT == NPNVGtk2) {", " \t\t*(NPNToolkitType *)value = NPW_TOOLKIT;", " \t\treturn NPERR_NO_ERROR;", " \t  }", " \t  break;", " \t}", " \tD(bug(\"WARNING: unhandled variable %d (%s) in NPN_GetValue()\\n\", variable, string_of_NPNVariable(variable)));", " \treturn NPERR_INVALID_PARAM;", "   }", "   return NPERR_NO_ERROR;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" create_filesystem_object(struct archive_write_disk *a)", " {", "  \tconst char *linkname;", "  \tmode_t final_mode, mode;", "  \tint r;", " \tchar *linkname_copy;\t ", " \tstruct archive_string error_string;", " \tint error_number;", " \tlinkname = archive_entry_hardlink(a->entry);", " \tif (linkname != NULL) {", "  #if !HAVE_LINK", "  \t\treturn (EPERM);", "  #else", " \t\tarchive_string_init(&error_string);", " \t\tlinkname_copy = strdup(linkname);", " \t\tif (linkname_copy == NULL) {", " \t\t    return (EPERM);", " \t\t}", " \t\tr = cleanup_pathname_fsobj(linkname_copy, &error_number, &error_string, a->flags);", " \t\tif (r != ARCHIVE_OK) {", " \t\t\tarchive_set_error(&a->archive, error_number, \"%s\", error_string.s);", " \t\t\tfree(linkname_copy);", " \t\t\treturn (EPERM);", " \t\t}", " \t\tr = check_symlinks_fsobj(linkname_copy, &error_number, &error_string, a->flags);", " \t\tif (r != ARCHIVE_OK) {", " \t\t\tarchive_set_error(&a->archive, error_number, \"%s\", error_string.s);", " \t\t\tfree(linkname_copy);", " \t\t\treturn (EPERM);", " \t\t}", " \t\tfree(linkname_copy);", "  \t\tr = link(linkname, a->name) ? errno : 0;", " \t\tif (r == 0 && a->filesize <= 0) {", " \t\t\ta->todo = 0;", " \t\t\ta->deferred = 0;", " \t\t} else if (r == 0 && a->filesize > 0) {", " \t\t\ta->fd = open(a->name,", " \t\t\t\t     O_WRONLY | O_TRUNC | O_BINARY | O_CLOEXEC);", " \t\t\t__archive_ensure_cloexec_flag(a->fd);", " \t\t\tif (a->fd < 0)", " \t\t\t\tr = errno;", " \t\t}", " \t\treturn (r);", " #endif", " \t}", " \tlinkname = archive_entry_symlink(a->entry);", " \tif (linkname != NULL) {", " #if HAVE_SYMLINK", " \t\treturn symlink(linkname, a->name) ? errno : 0;", " #else", " \t\treturn (EPERM);", " #endif", " \t}", " \tfinal_mode = a->mode & 07777;", " \tmode = final_mode & 0777 & ~a->user_umask;", " \tswitch (a->mode & AE_IFMT) {", " \tdefault:", " \tcase AE_IFREG:", " \t\ta->fd = open(a->name,", " \t\t    O_WRONLY | O_CREAT | O_EXCL | O_BINARY | O_CLOEXEC, mode);", " \t\t__archive_ensure_cloexec_flag(a->fd);", " \t\tr = (a->fd < 0);", " \t\tbreak;", " \tcase AE_IFCHR:", " #ifdef HAVE_MKNOD", " \t\tr = mknod(a->name, mode | S_IFCHR,", " \t\t    archive_entry_rdev(a->entry));", " \t\tbreak;", " #else", " \t\treturn (EINVAL);", " #endif  ", " \tcase AE_IFBLK:", " #ifdef HAVE_MKNOD", " \t\tr = mknod(a->name, mode | S_IFBLK,", " \t\t    archive_entry_rdev(a->entry));", " \t\tbreak;", " #else", " \t\treturn (EINVAL);", " #endif  ", " \tcase AE_IFDIR:", " \t\tmode = (mode | MINIMUM_DIR_MODE) & MAXIMUM_DIR_MODE;", " \t\tr = mkdir(a->name, mode);", " \t\tif (r == 0) {", " \t\t\ta->deferred |= (a->todo & TODO_TIMES);", " \t\t\ta->todo &= ~TODO_TIMES;", " \t\t\tif ((mode != final_mode)", " \t\t\t    || (a->flags & ARCHIVE_EXTRACT_PERM))", " \t\t\t\ta->deferred |= (a->todo & TODO_MODE);", " \t\t\ta->todo &= ~TODO_MODE;", " \t\t}", " \t\tbreak;", " \tcase AE_IFIFO:", " #ifdef HAVE_MKFIFO", " \t\tr = mkfifo(a->name, mode);", " \t\tbreak;", " #else", " \t\treturn (EINVAL);", " #endif  ", " \t}", " \tif (r)", " \t\treturn (errno);", " \tif (mode == final_mode)", " \t\ta->todo &= ~TODO_MODE;", " \treturn (0);", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static char *get_pid_environ_val(pid_t pid,char *val){", "  char temp[500];", "   int temp_size = 500;", "   char *temp = malloc(temp_size);", "    int i=0;", "    int foundit=0;", "    FILE *fp;", "   sprintf(temp,\"/proc/%d/environ\",pid);", "   fp=fopen(temp,\"r\");", "   if(fp==NULL)", "     return NULL;", "    for(;;){", "     if (i >= temp_size) {", "       temp_size *= 2;", "       temp = realloc(temp, temp_size);", "     }", "      temp[i]=fgetc(fp);    ", "      if(foundit==1 && (temp[i]==0 || temp[i]=='\\0' || temp[i]==EOF)){", "       char *ret;", "       temp[i]=0;", "       ret=malloc(strlen(temp)+10);", "       sprintf(ret,\"%s\",temp);", "       fclose(fp);", "       return ret;", "     }", "     switch(temp[i]){", "     case EOF:", "       fclose(fp);", "       return NULL;", "     case '=':", "       temp[i]=0;", "       if(!strcmp(temp,val)){", " \tfoundit=1;", "       }", "       i=0;", "       break;", "     case '\\0':", "       i=0;", "       break;", "     default:", "       i++;", "     }", "   }", " }"], "ner_tags": [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" epass2003_sm_unwrap_apdu(struct sc_card *card, struct sc_apdu *sm, struct sc_apdu *plain)", " {", " \tint r;", " \tsize_t len = 0;", " \tepass2003_exdata *exdata = NULL;", " \tif (!card->drv_data) ", " \t\treturn SC_ERROR_INVALID_ARGUMENTS;", " \texdata = (epass2003_exdata *)card->drv_data;", " \tLOG_FUNC_CALLED(card->ctx);", "  \tr = sc_check_sw(card, sm->sw1, sm->sw2);", "  \tif (r == SC_SUCCESS) {", "  \t\tif (exdata->sm) {", "\t\t\tif (0 != decrypt_response(card, sm->resp, plain->resp, &len))", " \t\t\tif (0 != decrypt_response(card, sm->resp, sm->resplen, plain->resp, &len))", "  \t\t\t\treturn SC_ERROR_CARD_CMD_FAILED;", "  \t\t}", "  \t\telse {", " \t\t\tmemcpy(plain->resp, sm->resp, sm->resplen);", " \t\t\tlen = sm->resplen;", " \t\t}", " \t}", " \tplain->resplen = len;", " \tplain->sw1 = sm->sw1;", " \tplain->sw2 = sm->sw2;", " \tsc_log(card->ctx,", " \t       \"unwrapped APDU: resplen %\"SC_FORMAT_LEN_SIZE_T\"u, SW %02X%02X\",", " \t       plain->resplen, plain->sw1, plain->sw2);", " \tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void dump_boot(DOS_FS * fs, struct boot_sector *b, unsigned lss)", " {", "     unsigned short sectors;", "     printf(\"Boot sector contents:\\n\");", "     if (!atari_format) {", " \tchar id[9];", " \tstrncpy(id, (const char *)b->system_id, 8);", " \tid[8] = 0;", " \tprintf(\"System ID \\\"%s\\\"\\n\", id);", "     } else {", " \tprintf(\"Serial number 0x%x\\n\",", " \t       b->system_id[5] | (b->system_id[6] << 8) | (b->", " \t\t\t\t\t\t\t   system_id[7] << 16));", "     }", "     printf(\"Media byte 0x%02x (%s)\\n\", b->media, get_media_descr(b->media));", "     printf(\"%10d bytes per logical sector\\n\", GET_UNALIGNED_W(b->sector_size));", "     printf(\"%10d bytes per cluster\\n\", fs->cluster_size);", "     printf(\"%10d reserved sector%s\\n\", le16toh(b->reserved),", " \t   le16toh(b->reserved) == 1 ? \"\" : \"s\");", "     printf(\"First FAT starts at byte %llu (sector %llu)\\n\",", "  \t   (unsigned long long)fs->fat_start,", "  \t   (unsigned long long)fs->fat_start / lss);", "      printf(\"%10d FATs, %d bit entries\\n\", b->fats, fs->fat_bits);", "    printf(\"%10d bytes per FAT (= %u sectors)\\n\", fs->fat_size,", "\t   fs->fat_size / lss);", "     printf(\"%10lld bytes per FAT (= %llu sectors)\\n\", (long long)fs->fat_size,", " \t   (long long)fs->fat_size / lss);", "      if (!fs->root_cluster) {", "  \tprintf(\"Root directory starts at byte %llu (sector %llu)\\n\",", "  \t       (unsigned long long)fs->root_start,", " \t       (unsigned long long)fs->root_start / lss);", " \tprintf(\"%10d root directory entries\\n\", fs->root_entries);", "     } else {", " \tprintf(\"Root directory start at cluster %lu (arbitrary size)\\n\",", " \t       (unsigned long)fs->root_cluster);", "     }", "     printf(\"Data area starts at byte %llu (sector %llu)\\n\",", " \t   (unsigned long long)fs->data_start,", " \t   (unsigned long long)fs->data_start / lss);", "     printf(\"%10lu data clusters (%llu bytes)\\n\",", " \t   (unsigned long)fs->data_clusters,", " \t   (unsigned long long)fs->data_clusters * fs->cluster_size);", "     printf(\"%u sectors/track, %u heads\\n\", le16toh(b->secs_track),", " \t   le16toh(b->heads));", "     printf(\"%10u hidden sectors\\n\", atari_format ?", " \t   (((unsigned char *)&b->hidden)[0] |", " \t    ((unsigned char *)&b->hidden)[1] << 8) : le32toh(b->hidden));", "     sectors = GET_UNALIGNED_W(b->sectors);", "     printf(\"%10u sectors total\\n\", sectors ? sectors : le32toh(b->total_sect));", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int read_header(FFV1Context *f)", " {", "     uint8_t state[CONTEXT_SIZE];", "     int i, j, context_count = -1;  ", "     RangeCoder *const c = &f->slice_context[0]->c;", "      memset(state, 128, sizeof(state));", "      if (f->version < 2) {", "         int chroma_planes, chroma_h_shift, chroma_v_shift, transparency;", "          unsigned v= get_symbol(c, state, 0);", "          if (v >= 2) {", "              av_log(f->avctx, AV_LOG_ERROR, \"invalid version %d in ver01 header\\n\", v);", "             return AVERROR_INVALIDDATA;", "         }", "         f->version = v;", "         f->ac      = f->avctx->coder_type = get_symbol(c, state, 0);", "         if (f->ac > 1) {", "             for (i = 1; i < 256; i++)", "                 f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];", "         }", "         f->colorspace = get_symbol(c, state, 0);  ", "          if (f->version > 0)", "              f->avctx->bits_per_raw_sample = get_symbol(c, state, 0);", "        f->chroma_planes  = get_rac(c, state);", "        f->chroma_h_shift = get_symbol(c, state, 0);", "        f->chroma_v_shift = get_symbol(c, state, 0);", "        f->transparency   = get_rac(c, state);", "         chroma_planes  = get_rac(c, state);", "         chroma_h_shift = get_symbol(c, state, 0);", "         chroma_v_shift = get_symbol(c, state, 0);", "         transparency   = get_rac(c, state);", "         if (f->plane_count) {", "             if (   chroma_planes != f->chroma_planes", "                 || chroma_h_shift!= f->chroma_h_shift", "                 || chroma_v_shift!= f->chroma_v_shift", "                 || transparency  != f->transparency) {", "                 av_log(f->avctx, AV_LOG_ERROR, \"Invalid change of global parameters\\n\");", "                 return AVERROR_INVALIDDATA;", "             }", "         }", "         f->chroma_planes  = chroma_planes;", "         f->chroma_h_shift = chroma_h_shift;", "         f->chroma_v_shift = chroma_v_shift;", "         f->transparency   = transparency;", "          f->plane_count    = 2 + f->transparency;", "      }", "     if (f->colorspace == 0) {", "         if (!f->transparency && !f->chroma_planes) {", "             if (f->avctx->bits_per_raw_sample <= 8)", "                 f->avctx->pix_fmt = AV_PIX_FMT_GRAY8;", "             else", "                 f->avctx->pix_fmt = AV_PIX_FMT_GRAY16;", "         } else if (f->avctx->bits_per_raw_sample<=8 && !f->transparency) {", "             switch(16 * f->chroma_h_shift + f->chroma_v_shift) {", "             case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P; break;", "             case 0x01: f->avctx->pix_fmt = AV_PIX_FMT_YUV440P; break;", "             case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P; break;", "             case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P; break;", "             case 0x20: f->avctx->pix_fmt = AV_PIX_FMT_YUV411P; break;", "             case 0x22: f->avctx->pix_fmt = AV_PIX_FMT_YUV410P; break;", "             default:", "                 av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");", "                 return AVERROR(ENOSYS);", "             }", "         } else if (f->avctx->bits_per_raw_sample <= 8 && f->transparency) {", "             switch(16*f->chroma_h_shift + f->chroma_v_shift) {", "             case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P; break;", "             case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P; break;", "             case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P; break;", "             default:", "                 av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");", "                 return AVERROR(ENOSYS);", "             }", "         } else if (f->avctx->bits_per_raw_sample == 9) {", "             f->packed_at_lsb = 1;", "             switch(16 * f->chroma_h_shift + f->chroma_v_shift) {", "             case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P9; break;", "             case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P9; break;", "             case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P9; break;", "             default:", "                 av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");", "                 return AVERROR(ENOSYS);", "             }", "         } else if (f->avctx->bits_per_raw_sample == 10) {", "             f->packed_at_lsb = 1;", "             switch(16 * f->chroma_h_shift + f->chroma_v_shift) {", "             case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P10; break;", "             case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P10; break;", "             case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P10; break;", "             default:", "                 av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");", "                 return AVERROR(ENOSYS);", "             }", "         } else {", "             switch(16 * f->chroma_h_shift + f->chroma_v_shift) {", "             case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P16; break;", "             case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P16; break;", "             case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P16; break;", "             default:", "                 av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");", "                 return AVERROR(ENOSYS);", "             }", "         }", "     } else if (f->colorspace == 1) {", "         if (f->chroma_h_shift || f->chroma_v_shift) {", "             av_log(f->avctx, AV_LOG_ERROR,", "                    \"chroma subsampling not supported in this colorspace\\n\");", "             return AVERROR(ENOSYS);", "         }", "         if (     f->avctx->bits_per_raw_sample ==  9)", "             f->avctx->pix_fmt = AV_PIX_FMT_GBRP9;", "         else if (f->avctx->bits_per_raw_sample == 10)", "             f->avctx->pix_fmt = AV_PIX_FMT_GBRP10;", "         else if (f->avctx->bits_per_raw_sample == 12)", "             f->avctx->pix_fmt = AV_PIX_FMT_GBRP12;", "         else if (f->avctx->bits_per_raw_sample == 14)", "             f->avctx->pix_fmt = AV_PIX_FMT_GBRP14;", "         else", "         if (f->transparency) f->avctx->pix_fmt = AV_PIX_FMT_RGB32;", "         else                 f->avctx->pix_fmt = AV_PIX_FMT_0RGB32;", "     } else {", "         av_log(f->avctx, AV_LOG_ERROR, \"colorspace not supported\\n\");", "         return AVERROR(ENOSYS);", "     }", "     av_dlog(f->avctx, \"%d %d %d\\n\",", "             f->chroma_h_shift, f->chroma_v_shift, f->avctx->pix_fmt);", "     if (f->version < 2) {", "         context_count = read_quant_tables(c, f->quant_table);", "         if (context_count < 0) {", "             av_log(f->avctx, AV_LOG_ERROR, \"read_quant_table error\\n\");", "             return AVERROR_INVALIDDATA;", "         }", "     } else if (f->version < 3) {", "         f->slice_count = get_symbol(c, state, 0);", "     } else {", "         const uint8_t *p = c->bytestream_end;", "         for (f->slice_count = 0;", "              f->slice_count < MAX_SLICES && 3 < p - c->bytestream_start;", "              f->slice_count++) {", "             int trailer = 3 + 5*!!f->ec;", "             int size = AV_RB24(p-trailer);", "             if (size + trailer > p - c->bytestream_start)", "                 break;", "             p -= size + trailer;", "         }", "     }", "     if (f->slice_count > (unsigned)MAX_SLICES || f->slice_count <= 0) {", "         av_log(f->avctx, AV_LOG_ERROR, \"slice count %d is invalid\\n\", f->slice_count);", "         return AVERROR_INVALIDDATA;", "     }", "     for (j = 0; j < f->slice_count; j++) {", "         FFV1Context *fs = f->slice_context[j];", "         fs->ac            = f->ac;", "         fs->packed_at_lsb = f->packed_at_lsb;", "         fs->slice_damaged = 0;", "         if (f->version == 2) {", "             fs->slice_x      =  get_symbol(c, state, 0)      * f->width ;", "             fs->slice_y      =  get_symbol(c, state, 0)      * f->height;", "             fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width  + fs->slice_x;", "             fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;", "             fs->slice_x     /= f->num_h_slices;", "             fs->slice_y     /= f->num_v_slices;", "             fs->slice_width  = fs->slice_width  / f->num_h_slices - fs->slice_x;", "             fs->slice_height = fs->slice_height / f->num_v_slices - fs->slice_y;", "             if ((unsigned)fs->slice_width  > f->width ||", "                 (unsigned)fs->slice_height > f->height)", "                 return AVERROR_INVALIDDATA;", "             if (   (unsigned)fs->slice_x + (uint64_t)fs->slice_width  > f->width", "                 || (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height)", "                 return AVERROR_INVALIDDATA;", "         }", "         for (i = 0; i < f->plane_count; i++) {", "             PlaneContext *const p = &fs->plane[i];", "             if (f->version == 2) {", "                 int idx = get_symbol(c, state, 0);", "                 if (idx > (unsigned)f->quant_table_count) {", "                     av_log(f->avctx, AV_LOG_ERROR,", "                            \"quant_table_index out of range\\n\");", "                     return AVERROR_INVALIDDATA;", "                 }", "                 p->quant_table_index = idx;", "                 memcpy(p->quant_table, f->quant_tables[idx],", "                        sizeof(p->quant_table));", "                 context_count = f->context_count[idx];", "             } else {", "                 memcpy(p->quant_table, f->quant_table, sizeof(p->quant_table));", "             }", "             if (f->version <= 2) {", "                 av_assert0(context_count >= 0);", "                 if (p->context_count < context_count) {", "                     av_freep(&p->state);", "                     av_freep(&p->vlc_state);", "                 }", "                 p->context_count = context_count;", "             }", "         }", "     }", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  char *suhosin_encrypt_single_cookie(char *name, int name_len, char *value, int value_len, char *key TSRMLS_DC)", "  {", "\tchar buffer[4096];", "    char buffer2[4096];", "\tchar *buf = buffer, *buf2 = buffer2, *d, *d_url;", "    int l;", "\tif (name_len > sizeof(buffer)-2) {", "\t\tbuf = estrndup(name, name_len);", "\t} else {", "\t\tmemcpy(buf, name, name_len);", "\t\tbuf[name_len] = 0;", "\t}", " \tchar *buf, *buf2, *d, *d_url;", " \tint l;", " \tbuf = estrndup(name, name_len);", "  \tname_len = php_url_decode(buf, name_len);", "    normalize_varname(buf);", "    name_len = strlen(buf);", " \tnormalize_varname(buf);", " \tname_len = strlen(buf);", "  \tif (SUHOSIN_G(cookie_plainlist)) {", "  \t\tif (zend_hash_exists(SUHOSIN_G(cookie_plainlist), buf, name_len+1)) {", "  encrypt_return_plain:", "\t\t\tif (buf != buffer) {", "\t\t\t\tefree(buf);", "\t\t\t}", " \t\t\tefree(buf);", "  \t\t\treturn estrndup(value, value_len);", "  \t\t}", "  \t} else if (SUHOSIN_G(cookie_cryptlist)) {", " \t\tif (!zend_hash_exists(SUHOSIN_G(cookie_cryptlist), buf, name_len+1)) {", " \t\t\tgoto encrypt_return_plain;", "  \t\t}", "  \t}", "\tif (strlen(value) <= sizeof(buffer2)-2) {", "\t\tmemcpy(buf2, value, value_len);", "\t\tbuf2[value_len] = 0;", "\t} else {", "\t\tbuf2 = estrndup(value, value_len);", "\t}", " \tbuf2 = estrndup(value, value_len);", "  \tvalue_len = php_url_decode(buf2, value_len);", "  \td = suhosin_encrypt_string(buf2, value_len, buf, name_len, key TSRMLS_CC);", "  \td_url = php_url_encode(d, strlen(d), &l);", "  \tefree(d);", "    if (buf != buffer) {", "\t\tefree(buf);", "\t}", "    if (buf2 != buffer2) {", "\t\tefree(buf2);", "\t}", " \tefree(buf);", " \tefree(buf2);", "  \treturn d_url;", "  }"], "ner_tags": [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0]}
{"tokens": [" int main(int argc, char **argv)", " {", " \tint fmtid;", " \tint id;", " \tchar *infile;", " \tjas_stream_t *instream;", " \tjas_image_t *image;", " \tint width;", " \tint height;", " \tint depth;", "  \tint numcmpts;", "  \tint verbose;", "  \tchar *fmtname;", " \tint debug;", "  \tif (jas_init()) {", "  \t\tabort();", " \t}", " \tcmdname = argv[0];", "  \tinfile = 0;", "  \tverbose = 0;", " \tdebug = 0;", "  \twhile ((id = jas_getopt(argc, argv, opts)) >= 0) {", " \t\tswitch (id) {", " \t\tcase OPT_VERBOSE:", " \t\t\tverbose = 1;", " \t\t\tbreak;", " \t\tcase OPT_VERSION:", "  \t\t\tprintf(\"%s\\n\", JAS_VERSION);", "  \t\t\texit(EXIT_SUCCESS);", "  \t\t\tbreak;", " \t\tcase OPT_DEBUG:", " \t\t\tdebug = atoi(jas_optarg);", " \t\t\tbreak;", "  \t\tcase OPT_INFILE:", "  \t\t\tinfile = jas_optarg;", "  \t\t\tbreak;", " \t\tcase OPT_HELP:", " \t\tdefault:", " \t\t\tusage();", " \t\t\tbreak;", "  \t\t}", "  \t}", " \tjas_setdbglevel(debug);", "  \tif (infile) {", " \t\tif (!(instream = jas_stream_fopen(infile, \"rb\"))) {", " \t\t\tfprintf(stderr, \"cannot open input image file %s\\n\", infile);", " \t\t\texit(EXIT_FAILURE);", " \t\t}", " \t} else {", " \t\tif (!(instream = jas_stream_fdopen(0, \"rb\"))) {", " \t\t\tfprintf(stderr, \"cannot open standard input\\n\");", " \t\t\texit(EXIT_FAILURE);", " \t\t}", " \t}", " \tif ((fmtid = jas_image_getfmt(instream)) < 0) {", " \t\tfprintf(stderr, \"unknown image format\\n\");", " \t}", "  \tif (!(image = jas_image_decode(instream, fmtid, 0))) {", " \t\tjas_stream_close(instream);", "  \t\tfprintf(stderr, \"cannot load image\\n\");", "  \t\treturn EXIT_FAILURE;", "  \t}", " \tjas_stream_close(instream);", " \tnumcmpts = jas_image_numcmpts(image);", " \twidth = jas_image_cmptwidth(image, 0);", " \theight = jas_image_cmptheight(image, 0);", " \tdepth = jas_image_cmptprec(image, 0);", " \tif (!(fmtname = jas_image_fmttostr(fmtid))) {", " \t\tabort();", " \t}", " \tprintf(\"%s %d %d %d %d %ld\\n\", fmtname, numcmpts, width, height, depth, (long) jas_image_rawsize(image));", " \tjas_image_destroy(image);", " \tjas_image_clearfmts();", " \treturn EXIT_SUCCESS;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int process_line(URLContext *h, char *line, int line_count,", "                         int *new_location)", " {", "     HTTPContext *s = h->priv_data;", "     const char *auto_method =  h->flags & AVIO_FLAG_READ ? \"POST\" : \"GET\";", "     char *tag, *p, *end, *method, *resource, *version;", "     int ret;", "     if (line[0] == '\\0') {", "         s->end_header = 1;", "         return 0;", "     }", "     p = line;", "     if (line_count == 0) {", "         if (s->is_connected_server) {", "             method = p;", "             while (*p && !av_isspace(*p))", "                 p++;", "             *(p++) = '\\0';", "             av_log(h, AV_LOG_TRACE, \"Received method: %s\\n\", method);", "             if (s->method) {", "                 if (av_strcasecmp(s->method, method)) {", "                     av_log(h, AV_LOG_ERROR, \"Received and expected HTTP method do not match. (%s expected, %s received)\\n\",", "                            s->method, method);", "                     return ff_http_averror(400, AVERROR(EIO));", "                 }", "             } else {", "                 av_log(h, AV_LOG_TRACE, \"Autodetected %s HTTP method\\n\", auto_method);", "                 if (av_strcasecmp(auto_method, method)) {", "                     av_log(h, AV_LOG_ERROR, \"Received and autodetected HTTP method did not match \"", "                            \"(%s autodetected %s received)\\n\", auto_method, method);", "                     return ff_http_averror(400, AVERROR(EIO));", "                 }", "                 if (!(s->method = av_strdup(method)))", "                     return AVERROR(ENOMEM);", "             }", "             while (av_isspace(*p))", "                 p++;", "             resource = p;", "             while (!av_isspace(*p))", "                 p++;", "             *(p++) = '\\0';", "             av_log(h, AV_LOG_TRACE, \"Requested resource: %s\\n\", resource);", "             if (!(s->resource = av_strdup(resource)))", "                 return AVERROR(ENOMEM);", "             while (av_isspace(*p))", "                 p++;", "             version = p;", "             while (*p && !av_isspace(*p))", "                 p++;", "             *p = '\\0';", "             if (av_strncasecmp(version, \"HTTP/\", 5)) {", "                 av_log(h, AV_LOG_ERROR, \"Malformed HTTP version string.\\n\");", "                 return ff_http_averror(400, AVERROR(EIO));", "             }", "             av_log(h, AV_LOG_TRACE, \"HTTP version string: %s\\n\", version);", "         } else {", "             while (!av_isspace(*p) && *p != '\\0')", "                 p++;", "             while (av_isspace(*p))", "                 p++;", "             s->http_code = strtol(p, &end, 10);", "             av_log(h, AV_LOG_TRACE, \"http_code=%d\\n\", s->http_code);", "             if ((ret = check_http_code(h, s->http_code, end)) < 0)", "                 return ret;", "         }", "     } else {", "         while (*p != '\\0' && *p != ':')", "             p++;", "         if (*p != ':')", "             return 1;", "         *p  = '\\0';", "         tag = line;", "         p++;", "         while (av_isspace(*p))", "             p++;", "         if (!av_strcasecmp(tag, \"Location\")) {", "              if ((ret = parse_location(s, p)) < 0)", "                  return ret;", "              *new_location = 1;", "        } else if (!av_strcasecmp(tag, \"Content-Length\") && s->filesize == -1) {", "            s->filesize = strtoll(p, NULL, 10);", "         } else if (!av_strcasecmp(tag, \"Content-Length\") &&", "                    s->filesize == UINT64_MAX) {", "             s->filesize = strtoull(p, NULL, 10);", "          } else if (!av_strcasecmp(tag, \"Content-Range\")) {", "              parse_content_range(h, p);", "          } else if (!av_strcasecmp(tag, \"Accept-Ranges\") &&", "                    !strncmp(p, \"bytes\", 5) &&", "                    s->seekable == -1) {", "              h->is_streamed = 0;", "          } else if (!av_strcasecmp(tag, \"Transfer-Encoding\") &&", "                     !av_strncasecmp(p, \"chunked\", 7)) {", "            s->filesize  = -1;", "             s->filesize  = UINT64_MAX;", "              s->chunksize = 0;", "          } else if (!av_strcasecmp(tag, \"WWW-Authenticate\")) {", "              ff_http_auth_handle_header(&s->auth_state, tag, p);", "         } else if (!av_strcasecmp(tag, \"Authentication-Info\")) {", "             ff_http_auth_handle_header(&s->auth_state, tag, p);", "         } else if (!av_strcasecmp(tag, \"Proxy-Authenticate\")) {", "             ff_http_auth_handle_header(&s->proxy_auth_state, tag, p);", "         } else if (!av_strcasecmp(tag, \"Connection\")) {", "             if (!strcmp(p, \"close\"))", "                 s->willclose = 1;", "         } else if (!av_strcasecmp(tag, \"Server\")) {", "             if (!av_strcasecmp(p, \"AkamaiGHost\")) {", "                 s->is_akamai = 1;", "             } else if (!av_strncasecmp(p, \"MediaGateway\", 12)) {", "                 s->is_mediagateway = 1;", "             }", "         } else if (!av_strcasecmp(tag, \"Content-Type\")) {", "             av_free(s->mime_type);", "             s->mime_type = av_strdup(p);", "         } else if (!av_strcasecmp(tag, \"Set-Cookie\")) {", "              if (parse_cookie(s, p, &s->cookie_dict))", "                  av_log(h, AV_LOG_WARNING, \"Unable to parse '%s'\\n\", p);", "          } else if (!av_strcasecmp(tag, \"Icy-MetaInt\")) {", "            s->icy_metaint = strtoll(p, NULL, 10);", "             s->icy_metaint = strtoull(p, NULL, 10);", "          } else if (!av_strncasecmp(tag, \"Icy-\", 4)) {", "              if ((ret = parse_icy(s, tag, p)) < 0)", "                  return ret;", "         } else if (!av_strcasecmp(tag, \"Content-Encoding\")) {", "             if ((ret = parse_content_encoding(h, p)) < 0)", "                 return ret;", "         }", "     }", "     return 1;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" CMD_FUNC(m_authenticate)", " {", " \taClient *agent_p = NULL;", " \tif (!SASL_SERVER || !MyConnect(sptr) || BadPtr(parv[1]) || !CHECKPROTO(sptr, PROTO_SASL))", " \t\treturn 0;", " \tif (sptr->local->sasl_complete)", " \t{", " \t\tsendto_one(sptr, err_str(ERR_SASLALREADY), me.name, BadPtr(sptr->name) ? \"*\" : sptr->name);", "  \t\treturn 0;", "  \t}", " \tif ((parv[1][0] == ':') || strchr(parv[1], ' '))", " \t{", " \t\tsendto_one(sptr, err_str(ERR_CANNOTDOCOMMAND), me.name, \"*\", \"AUTHENTICATE\", \"Invalid parameter\");", " \t\treturn 0;", " \t}", "  \tif (strlen(parv[1]) > 400)", "  \t{", "  \t\tsendto_one(sptr, err_str(ERR_SASLTOOLONG), me.name, BadPtr(sptr->name) ? \"*\" : sptr->name);", " \t\treturn 0;", " \t}", " \tif (*sptr->local->sasl_agent)", " \t\tagent_p = find_client(sptr->local->sasl_agent, NULL);", " \tif (agent_p == NULL)", " \t{", " \t\tchar *addr = BadPtr(sptr->ip) ? \"0\" : sptr->ip;", " \t\tchar *certfp = moddata_client_get(sptr, \"certfp\");", " \t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s H %s %s\",", " \t\t    me.name, SASL_SERVER, encode_puid(sptr), addr, addr);", " \t\tif (certfp)", " \t\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s S %s %s\",", " \t\t\t    me.name, SASL_SERVER, encode_puid(sptr), parv[1], certfp);", " \t\telse", " \t\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s S %s\",", " \t\t\t    me.name, SASL_SERVER, encode_puid(sptr), parv[1]);", " \t}", " \telse", " \t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s C %s\",", " \t\t    me.name, AGENT_SID(agent_p), encode_puid(sptr), parv[1]);", " \tsptr->local->sasl_out++;", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int ape_read_header(AVFormatContext * s, AVFormatParameters * ap)", " {", "     AVIOContext *pb = s->pb;", "     APEContext *ape = s->priv_data;", "     AVStream *st;", "     uint32_t tag;", "     int i;", "     int total_blocks;", "     int64_t pts;", "     ape->junklength = 0;", "     tag = avio_rl32(pb);", "     if (tag != MKTAG('M', 'A', 'C', ' '))", "         return -1;", "     ape->fileversion = avio_rl16(pb);", "     if (ape->fileversion < APE_MIN_VERSION || ape->fileversion > APE_MAX_VERSION) {", "         av_log(s, AV_LOG_ERROR, \"Unsupported file version - %d.%02d\\n\", ape->fileversion / 1000, (ape->fileversion % 1000) / 10);", "         return -1;", "     }", "     if (ape->fileversion >= 3980) {", "         ape->padding1             = avio_rl16(pb);", "         ape->descriptorlength     = avio_rl32(pb);", "         ape->headerlength         = avio_rl32(pb);", "         ape->seektablelength      = avio_rl32(pb);", "         ape->wavheaderlength      = avio_rl32(pb);", "         ape->audiodatalength      = avio_rl32(pb);", "         ape->audiodatalength_high = avio_rl32(pb);", "         ape->wavtaillength        = avio_rl32(pb);", "         avio_read(pb, ape->md5, 16);", "         if (ape->descriptorlength > 52)", "             avio_seek(pb, ape->descriptorlength - 52, SEEK_CUR);", "         ape->compressiontype      = avio_rl16(pb);", "         ape->formatflags          = avio_rl16(pb);", "         ape->blocksperframe       = avio_rl32(pb);", "         ape->finalframeblocks     = avio_rl32(pb);", "         ape->totalframes          = avio_rl32(pb);", "         ape->bps                  = avio_rl16(pb);", "         ape->channels             = avio_rl16(pb);", "         ape->samplerate           = avio_rl32(pb);", "     } else {", "         ape->descriptorlength = 0;", "         ape->headerlength = 32;", "         ape->compressiontype      = avio_rl16(pb);", "         ape->formatflags          = avio_rl16(pb);", "         ape->channels             = avio_rl16(pb);", "         ape->samplerate           = avio_rl32(pb);", "         ape->wavheaderlength      = avio_rl32(pb);", "         ape->wavtaillength        = avio_rl32(pb);", "         ape->totalframes          = avio_rl32(pb);", "         ape->finalframeblocks     = avio_rl32(pb);", "         if (ape->formatflags & MAC_FORMAT_FLAG_HAS_PEAK_LEVEL) {", "             avio_seek(pb, 4, SEEK_CUR);  ", "             ape->headerlength += 4;", "         }", "         if (ape->formatflags & MAC_FORMAT_FLAG_HAS_SEEK_ELEMENTS) {", "             ape->seektablelength = avio_rl32(pb);", "             ape->headerlength += 4;", "             ape->seektablelength *= sizeof(int32_t);", "         } else", "             ape->seektablelength = ape->totalframes * sizeof(int32_t);", "         if (ape->formatflags & MAC_FORMAT_FLAG_8_BIT)", "             ape->bps = 8;", "         else if (ape->formatflags & MAC_FORMAT_FLAG_24_BIT)", "             ape->bps = 24;", "         else", "             ape->bps = 16;", "         if (ape->fileversion >= 3950)", "             ape->blocksperframe = 73728 * 4;", "         else if (ape->fileversion >= 3900 || (ape->fileversion >= 3800  && ape->compressiontype >= 4000))", "             ape->blocksperframe = 73728;", "         else", "             ape->blocksperframe = 9216;", "         if (!(ape->formatflags & MAC_FORMAT_FLAG_CREATE_WAV_HEADER))", "              avio_seek(pb, ape->wavheaderlength, SEEK_CUR);", "      }", "     if(!ape->totalframes){", "         av_log(s, AV_LOG_ERROR, \"No frames in the file!\\n\");", "         return AVERROR(EINVAL);", "     }", "      if(ape->totalframes > UINT_MAX / sizeof(APEFrame)){", "          av_log(s, AV_LOG_ERROR, \"Too many frames: %d\\n\", ape->totalframes);", "          return -1;", "     }", "     ape->frames       = av_malloc(ape->totalframes * sizeof(APEFrame));", "     if(!ape->frames)", "         return AVERROR(ENOMEM);", "     ape->firstframe   = ape->junklength + ape->descriptorlength + ape->headerlength + ape->seektablelength + ape->wavheaderlength;", "     ape->currentframe = 0;", "     ape->totalsamples = ape->finalframeblocks;", "     if (ape->totalframes > 1)", "         ape->totalsamples += ape->blocksperframe * (ape->totalframes - 1);", "     if (ape->seektablelength > 0) {", "         ape->seektable = av_malloc(ape->seektablelength);", "         for (i = 0; i < ape->seektablelength / sizeof(uint32_t); i++)", "             ape->seektable[i] = avio_rl32(pb);", "     }", "     ape->frames[0].pos     = ape->firstframe;", "     ape->frames[0].nblocks = ape->blocksperframe;", "     ape->frames[0].skip    = 0;", "     for (i = 1; i < ape->totalframes; i++) {", "         ape->frames[i].pos      = ape->seektable[i];  ", "         ape->frames[i].nblocks  = ape->blocksperframe;", "         ape->frames[i - 1].size = ape->frames[i].pos - ape->frames[i - 1].pos;", "         ape->frames[i].skip     = (ape->frames[i].pos - ape->frames[0].pos) & 3;", "     }", "     ape->frames[ape->totalframes - 1].size    = ape->finalframeblocks * 4;", "     ape->frames[ape->totalframes - 1].nblocks = ape->finalframeblocks;", "     for (i = 0; i < ape->totalframes; i++) {", "         if(ape->frames[i].skip){", "             ape->frames[i].pos  -= ape->frames[i].skip;", "             ape->frames[i].size += ape->frames[i].skip;", "         }", "         ape->frames[i].size = (ape->frames[i].size + 3) & ~3;", "     }", "     ape_dumpinfo(s, ape);", "     if (!url_is_streamed(pb)) {", "         ff_ape_parse_tag(s);", "         avio_seek(pb, 0, SEEK_SET);", "     }", "     av_log(s, AV_LOG_DEBUG, \"Decoding file - v%d.%02d, compression level %d\\n\", ape->fileversion / 1000, (ape->fileversion % 1000) / 10, ape->compressiontype);", "     st = av_new_stream(s, 0);", "     if (!st)", "         return -1;", "     total_blocks = (ape->totalframes == 0) ? 0 : ((ape->totalframes - 1) * ape->blocksperframe) + ape->finalframeblocks;", "     st->codec->codec_type      = AVMEDIA_TYPE_AUDIO;", "     st->codec->codec_id        = CODEC_ID_APE;", "     st->codec->codec_tag       = MKTAG('A', 'P', 'E', ' ');", "     st->codec->channels        = ape->channels;", "     st->codec->sample_rate     = ape->samplerate;", "     st->codec->bits_per_coded_sample = ape->bps;", "     st->codec->frame_size      = MAC_SUBFRAME_SIZE;", "     st->nb_frames = ape->totalframes;", "     st->start_time = 0;", "     st->duration  = total_blocks / MAC_SUBFRAME_SIZE;", "     av_set_pts_info(st, 64, MAC_SUBFRAME_SIZE, ape->samplerate);", "     st->codec->extradata = av_malloc(APE_EXTRADATA_SIZE);", "     st->codec->extradata_size = APE_EXTRADATA_SIZE;", "     AV_WL16(st->codec->extradata + 0, ape->fileversion);", "     AV_WL16(st->codec->extradata + 2, ape->compressiontype);", "     AV_WL16(st->codec->extradata + 4, ape->formatflags);", "     pts = 0;", "     for (i = 0; i < ape->totalframes; i++) {", "         ape->frames[i].pts = pts;", "         av_add_index_entry(st, ape->frames[i].pos, ape->frames[i].pts, 0, 0, AVINDEX_KEYFRAME);", "         pts += ape->blocksperframe / MAC_SUBFRAME_SIZE;", "     }", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" process_plane(uint8 * in, int width, int height, uint8 * out, int size)", " {", " \tUNUSED(size);", " \tint indexw;", " \tint indexh;", " \tint code;", " \tint collen;", " \tint replen;", " \tint color;", " \tint x;", " \tint revcode;", " \tuint8 * last_line;", " \tuint8 * this_line;", " \tuint8 * org_in;", " \tuint8 * org_out;", " \torg_in = in;", " \torg_out = out;", " \tlast_line = 0;", " \tindexh = 0;", " \twhile (indexh < height)", " \t{", " \t\tout = (org_out + width * height * 4) - ((indexh + 1) * width * 4);", " \t\tcolor = 0;", " \t\tthis_line = out;", " \t\tindexw = 0;", " \t\tif (last_line == 0)", " \t\t{", " \t\t\twhile (indexw < width)", " \t\t\t{", " \t\t\t\tcode = CVAL(in);", " \t\t\t\treplen = code & 0xf;", " \t\t\t\tcollen = (code >> 4) & 0xf;", " \t\t\t\trevcode = (replen << 4) | collen;", " \t\t\t\tif ((revcode <= 47) && (revcode >= 16))", " \t\t\t\t{", "  \t\t\t\t\treplen = revcode;", "  \t\t\t\t\tcollen = 0;", "  \t\t\t\t}", "\t\t\t\twhile (collen > 0)", " \t\t\t\twhile (indexw < width && collen > 0)", "  \t\t\t\t{", "  \t\t\t\t\tcolor = CVAL(in);", "  \t\t\t\t\t*out = color;", "  \t\t\t\t\tout += 4;", "  \t\t\t\t\tindexw++;", "  \t\t\t\t\tcollen--;", "  \t\t\t\t}", "\t\t\t\twhile (replen > 0)", " \t\t\t\twhile (indexw < width && replen > 0)", "  \t\t\t\t{", "  \t\t\t\t\t*out = color;", "  \t\t\t\t\tout += 4;", " \t\t\t\t\tindexw++;", " \t\t\t\t\treplen--;", " \t\t\t\t}", " \t\t\t}", " \t\t}", " \t\telse", " \t\t{", " \t\t\twhile (indexw < width)", " \t\t\t{", " \t\t\t\tcode = CVAL(in);", " \t\t\t\treplen = code & 0xf;", " \t\t\t\tcollen = (code >> 4) & 0xf;", " \t\t\t\trevcode = (replen << 4) | collen;", " \t\t\t\tif ((revcode <= 47) && (revcode >= 16))", " \t\t\t\t{", "  \t\t\t\t\treplen = revcode;", "  \t\t\t\t\tcollen = 0;", "  \t\t\t\t}", "\t\t\t\twhile (collen > 0)", " \t\t\t\twhile (indexw < width && collen > 0)", "  \t\t\t\t{", "  \t\t\t\t\tx = CVAL(in);", "  \t\t\t\t\tif (x & 1)", " \t\t\t\t\t{", " \t\t\t\t\t\tx = x >> 1;", " \t\t\t\t\t\tx = x + 1;", " \t\t\t\t\t\tcolor = -x;", " \t\t\t\t\t}", " \t\t\t\t\telse", " \t\t\t\t\t{", " \t\t\t\t\t\tx = x >> 1;", " \t\t\t\t\t\tcolor = x;", " \t\t\t\t\t}", " \t\t\t\t\tx = last_line[indexw * 4] + color;", " \t\t\t\t\t*out = x;", " \t\t\t\t\tout += 4;", "  \t\t\t\t\tindexw++;", "  \t\t\t\t\tcollen--;", "  \t\t\t\t}", "\t\t\t\twhile (replen > 0)", " \t\t\t\twhile (indexw < width && replen > 0)", "  \t\t\t\t{", "  \t\t\t\t\tx = last_line[indexw * 4] + color;", "  \t\t\t\t\t*out = x;", " \t\t\t\t\tout += 4;", " \t\t\t\t\tindexw++;", " \t\t\t\t\treplen--;", " \t\t\t\t}", " \t\t\t}", " \t\t}", " \t\tindexh++;", " \t\tlast_line = this_line;", " \t}", " \treturn (int) (in - org_in);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" PGTYPESdate_from_asc(char *str, char **endptr)", " {", " \tdate\t\tdDate;", " \tfsec_t\t\tfsec;", " \tstruct tm\ttt,", " \t\t\t   *tm = &tt;", " \tint\t\t\tdtype;", "  \tint\t\t\tnf;", "  \tchar\t   *field[MAXDATEFIELDS];", "  \tint\t\t\tftype[MAXDATEFIELDS];", "\tchar\t\tlowstr[MAXDATELEN + 1];", " \tchar\t\tlowstr[MAXDATELEN + MAXDATEFIELDS];", "  \tchar\t   *realptr;", "  \tchar\t  **ptr = (endptr != NULL) ? endptr : &realptr;", "  \tbool\t\tEuroDates = FALSE;", "  \terrno = 0;", "\tif (strlen(str) >= sizeof(lowstr))", " \tif (strlen(str) > MAXDATELEN)", "  \t{", "  \t\terrno = PGTYPES_DATE_BAD_DATE;", "  \t\treturn INT_MIN;", " \t}", " \tif (ParseDateTime(str, lowstr, field, ftype, &nf, ptr) != 0 ||", " \t\tDecodeDateTime(field, ftype, nf, &dtype, tm, &fsec, EuroDates) != 0)", " \t{", " \t\terrno = PGTYPES_DATE_BAD_DATE;", " \t\treturn INT_MIN;", " \t}", " \tswitch (dtype)", " \t{", " \t\tcase DTK_DATE:", " \t\t\tbreak;", " \t\tcase DTK_EPOCH:", " \t\t\tif (GetEpochTime(tm) < 0)", " \t\t\t{", " \t\t\t\terrno = PGTYPES_DATE_BAD_DATE;", " \t\t\t\treturn INT_MIN;", " \t\t\t}", " \t\t\tbreak;", " \t\tdefault:", " \t\t\terrno = PGTYPES_DATE_BAD_DATE;", " \t\t\treturn INT_MIN;", " \t}", " \tdDate = (date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - date2j(2000, 1, 1));", " \treturn dDate;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int parse_token(char **name, char **value, char **cp)", " {", " \tchar *end;", " \tif (!name || !value || !cp)", " \t\treturn -BLKID_ERR_PARAM;", " \tif (!(*value = strchr(*cp, '=')))", " \t\treturn 0;", " \t**value = '\\0';", " \t*name = strip_line(*cp);", "  \t*value = skip_over_blank(*value + 1);", "  \tif (**value == '\"') {", "\t\tend = strchr(*value + 1, '\"');", "\t\tif (!end) {", " \t\tchar *p = end = *value + 1;", " \t\twhile (*p) {", " \t\t\tif (*p == '\\\\') {", " \t\t\t\tp++;", " \t\t\t\t*end = *p;", " \t\t\t} else {", " \t\t\t\t*end = *p;", " \t\t\t\tif (*p == '\"')", " \t\t\t\t\tbreak;", " \t\t\t}", " \t\t\tp++;", " \t\t\tend++;", " \t\t}", " \t\tif (*end != '\"') {", "  \t\t\tDBG(READ, ul_debug(\"unbalanced quotes at: %s\", *value));", "  \t\t\t*cp = *value;", "  \t\t\treturn -BLKID_ERR_CACHE;", "  \t\t}", "  \t\t(*value)++;", "  \t\t*end = '\\0';", "\t\tend++;", " \t\tend = ++p;", "  \t} else {", "  \t\tend = skip_over_word(*value);", "  \t\tif (*end) {", " \t\t\t*end = '\\0';", " \t\t\tend++;", " \t\t}", " \t}", " \t*cp = end;", " \treturn 1;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int ff_h263_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,", "                          AVPacket *avpkt)", " {", "     const uint8_t *buf = avpkt->data;", "     int buf_size       = avpkt->size;", "     MpegEncContext *s  = avctx->priv_data;", "     int ret;", "     int slice_ret = 0;", "     AVFrame *pict = data;", "     if (buf_size == 0) {", "         if (s->low_delay == 0 && s->next_picture_ptr) {", "             if ((ret = av_frame_ref(pict, s->next_picture_ptr->f)) < 0)", "                 return ret;", "             s->next_picture_ptr = NULL;", "             *got_frame = 1;", "         }", "         return 0;", "     }", "     if (s->avctx->flags & AV_CODEC_FLAG_TRUNCATED) {", "         int next;", "         if (CONFIG_MPEG4_DECODER && s->codec_id == AV_CODEC_ID_MPEG4) {", "             next = ff_mpeg4_find_frame_end(&s->parse_context, buf, buf_size);", "         } else if (CONFIG_H263_DECODER && s->codec_id == AV_CODEC_ID_H263) {", "             next = ff_h263_find_frame_end(&s->parse_context, buf, buf_size);", "         } else if (CONFIG_H263P_DECODER && s->codec_id == AV_CODEC_ID_H263P) {", "             next = ff_h263_find_frame_end(&s->parse_context, buf, buf_size);", "         } else {", "             av_log(s->avctx, AV_LOG_ERROR,", "                    \"this codec does not support truncated bitstreams\\n\");", "             return AVERROR(ENOSYS);", "         }", "         if (ff_combine_frame(&s->parse_context, next, (const uint8_t **)&buf,", "                              &buf_size) < 0)", "             return buf_size;", "     }", " retry:", "     if (s->divx_packed && s->bitstream_buffer_size) {", "         int i;", "         for(i=0; i < buf_size-3; i++) {", "             if (buf[i]==0 && buf[i+1]==0 && buf[i+2]==1) {", "                 if (buf[i+3]==0xB0) {", "                     av_log(s->avctx, AV_LOG_WARNING, \"Discarding excessive bitstream in packed xvid\\n\");", "                     s->bitstream_buffer_size = 0;", "                 }", "                 break;", "             }", "         }", "     }", "     if (s->bitstream_buffer_size && (s->divx_packed || buf_size <= MAX_NVOP_SIZE))  ", "         ret = init_get_bits8(&s->gb, s->bitstream_buffer,", "                              s->bitstream_buffer_size);", "     else", "         ret = init_get_bits8(&s->gb, buf, buf_size);", "     s->bitstream_buffer_size = 0;", "     if (ret < 0)", "         return ret;", "     if (!s->context_initialized)", "         ff_mpv_idct_init(s);", "     if (CONFIG_WMV2_DECODER && s->msmpeg4_version == 5) {", "         ret = ff_wmv2_decode_picture_header(s);", "     } else if (CONFIG_MSMPEG4_DECODER && s->msmpeg4_version) {", "         ret = ff_msmpeg4_decode_picture_header(s);", "     } else if (CONFIG_MPEG4_DECODER && avctx->codec_id == AV_CODEC_ID_MPEG4) {", "         if (s->avctx->extradata_size && s->picture_number == 0) {", "             GetBitContext gb;", "             if (init_get_bits8(&gb, s->avctx->extradata, s->avctx->extradata_size) >= 0 )", "                 ff_mpeg4_decode_picture_header(avctx->priv_data, &gb);", "         }", "         ret = ff_mpeg4_decode_picture_header(avctx->priv_data, &s->gb);", "     } else if (CONFIG_H263I_DECODER && s->codec_id == AV_CODEC_ID_H263I) {", "         ret = ff_intel_h263_decode_picture_header(s);", "     } else if (CONFIG_FLV_DECODER && s->h263_flv) {", "         ret = ff_flv_decode_picture_header(s);", "     } else {", "         ret = ff_h263_decode_picture_header(s);", "     }", "     if (ret < 0 || ret == FRAME_SKIPPED) {", "         if (   s->width  != avctx->coded_width", "             || s->height != avctx->coded_height) {", "                 av_log(s->avctx, AV_LOG_WARNING, \"Reverting picture dimensions change due to header decoding failure\\n\");", "                 s->width = avctx->coded_width;", "                 s->height= avctx->coded_height;", "         }", "     }", "     if (ret == FRAME_SKIPPED)", "         return get_consumed_bytes(s, buf_size);", "     if (ret < 0) {", "         av_log(s->avctx, AV_LOG_ERROR, \"header damaged\\n\");", "         return ret;", "     }", "     if (!s->context_initialized) {", "         avctx->pix_fmt = h263_get_format(avctx);", "         if ((ret = ff_mpv_common_init(s)) < 0)", "             return ret;", "     }", "     if (!s->current_picture_ptr || s->current_picture_ptr->f->data[0]) {", "         int i = ff_find_unused_picture(s->avctx, s->picture, 0);", "         if (i < 0)", "             return i;", "         s->current_picture_ptr = &s->picture[i];", "     }", "     avctx->has_b_frames = !s->low_delay;", "     if (CONFIG_MPEG4_DECODER && avctx->codec_id == AV_CODEC_ID_MPEG4) {", "         if (ff_mpeg4_workaround_bugs(avctx) == 1)", "             goto retry;", "         if (s->studio_profile != (s->idsp.idct == NULL))", "             ff_mpv_idct_init(s);", "     }", "     if (s->width  != avctx->coded_width  ||", "         s->height != avctx->coded_height ||", "         s->context_reinit) {", "         s->context_reinit = 0;", "         ret = ff_set_dimensions(avctx, s->width, s->height);", "         if (ret < 0)", "             return ret;", "         ff_set_sar(avctx, avctx->sample_aspect_ratio);", "         if ((ret = ff_mpv_common_frame_size_change(s)))", "             return ret;", "         if (avctx->pix_fmt != h263_get_format(avctx)) {", "             av_log(avctx, AV_LOG_ERROR, \"format change not supported\\n\");", "             avctx->pix_fmt = AV_PIX_FMT_NONE;", "             return AVERROR_UNKNOWN;", "         }", "     }", "     if (s->codec_id == AV_CODEC_ID_H263  ||", "         s->codec_id == AV_CODEC_ID_H263P ||", "         s->codec_id == AV_CODEC_ID_H263I)", "         s->gob_index = H263_GOB_HEIGHT(s->height);", "     s->current_picture.f->pict_type = s->pict_type;", "     s->current_picture.f->key_frame = s->pict_type == AV_PICTURE_TYPE_I;", "     if (!s->last_picture_ptr &&", "         (s->pict_type == AV_PICTURE_TYPE_B || s->droppable))", "         return get_consumed_bytes(s, buf_size);", "     if ((avctx->skip_frame >= AVDISCARD_NONREF &&", "          s->pict_type == AV_PICTURE_TYPE_B)    ||", "         (avctx->skip_frame >= AVDISCARD_NONKEY &&", "          s->pict_type != AV_PICTURE_TYPE_I)    ||", "         avctx->skip_frame >= AVDISCARD_ALL)", "         return get_consumed_bytes(s, buf_size);", "     if (s->next_p_frame_damaged) {", "         if (s->pict_type == AV_PICTURE_TYPE_B)", "             return get_consumed_bytes(s, buf_size);", "         else", "             s->next_p_frame_damaged = 0;", "     }", "     if ((!s->no_rounding) || s->pict_type == AV_PICTURE_TYPE_B) {", "         s->me.qpel_put = s->qdsp.put_qpel_pixels_tab;", "         s->me.qpel_avg = s->qdsp.avg_qpel_pixels_tab;", "     } else {", "         s->me.qpel_put = s->qdsp.put_no_rnd_qpel_pixels_tab;", "         s->me.qpel_avg = s->qdsp.avg_qpel_pixels_tab;", "     }", "     if ((ret = ff_mpv_frame_start(s, avctx)) < 0)", "         return ret;", "     if (!s->divx_packed)", "         ff_thread_finish_setup(avctx);", "     if (avctx->hwaccel) {", "         ret = avctx->hwaccel->start_frame(avctx, s->gb.buffer,", "                                           s->gb.buffer_end - s->gb.buffer);", "         if (ret < 0 )", "             return ret;", "     }", "     ff_mpeg_er_frame_start(s);", "     if (CONFIG_WMV2_DECODER && s->msmpeg4_version == 5) {", "         ret = ff_wmv2_decode_secondary_picture_header(s);", "         if (ret < 0)", "             return ret;", "         if (ret == 1)", "             goto frame_end;", "     }", "     s->mb_x = 0;", "     s->mb_y = 0;", "     slice_ret = decode_slice(s);", "     while (s->mb_y < s->mb_height) {", "         if (s->msmpeg4_version) {", "             if (s->slice_height == 0 || s->mb_x != 0 || slice_ret < 0 ||", "                 (s->mb_y % s->slice_height) != 0 || get_bits_left(&s->gb) < 0)", "                 break;", "         } else {", "             int prev_x = s->mb_x, prev_y = s->mb_y;", "             if (ff_h263_resync(s) < 0)", "                 break;", "             if (prev_y * s->mb_width + prev_x < s->mb_y * s->mb_width + s->mb_x)", "                 s->er.error_occurred = 1;", "         }", "         if (s->msmpeg4_version < 4 && s->h263_pred)", "             ff_mpeg4_clean_buffers(s);", "         if (decode_slice(s) < 0)", "             slice_ret = AVERROR_INVALIDDATA;", "     }", "     if (s->msmpeg4_version && s->msmpeg4_version < 4 &&", "         s->pict_type == AV_PICTURE_TYPE_I)", "         if (!CONFIG_MSMPEG4_DECODER ||", "             ff_msmpeg4_decode_ext_header(s, buf_size) < 0)", "             s->er.error_status_table[s->mb_num - 1] = ER_MB_ERROR;", "      av_assert1(s->bitstream_buffer_size == 0);", "  frame_end:", "    ff_er_frame_end(&s->er);", "     if (!s->studio_profile)", "         ff_er_frame_end(&s->er);", "      if (avctx->hwaccel) {", "          ret = avctx->hwaccel->end_frame(avctx);", "         if (ret < 0)", "             return ret;", "     }", "     ff_mpv_frame_end(s);", "     if (CONFIG_MPEG4_DECODER && avctx->codec_id == AV_CODEC_ID_MPEG4)", "         ff_mpeg4_frame_end(avctx, buf, buf_size);", "     if (!s->divx_packed && avctx->hwaccel)", "         ff_thread_finish_setup(avctx);", "     av_assert1(s->current_picture.f->pict_type == s->current_picture_ptr->f->pict_type);", "     av_assert1(s->current_picture.f->pict_type == s->pict_type);", "     if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay) {", "         if ((ret = av_frame_ref(pict, s->current_picture_ptr->f)) < 0)", "             return ret;", "         ff_print_debug_info(s, s->current_picture_ptr, pict);", "         ff_mpv_export_qp_table(s, pict, s->current_picture_ptr, FF_QSCALE_TYPE_MPEG1);", "     } else if (s->last_picture_ptr) {", "         if ((ret = av_frame_ref(pict, s->last_picture_ptr->f)) < 0)", "             return ret;", "         ff_print_debug_info(s, s->last_picture_ptr, pict);", "         ff_mpv_export_qp_table(s, pict, s->last_picture_ptr, FF_QSCALE_TYPE_MPEG1);", "     }", "     if (s->last_picture_ptr || s->low_delay) {", "         if (   pict->format == AV_PIX_FMT_YUV420P", "             && (s->codec_tag == AV_RL32(\"GEOV\") || s->codec_tag == AV_RL32(\"GEOX\"))) {", "             int x, y, p;", "             av_frame_make_writable(pict);", "             for (p=0; p<3; p++) {", "                 int w = AV_CEIL_RSHIFT(pict-> width, !!p);", "                 int h = AV_CEIL_RSHIFT(pict->height, !!p);", "                 int linesize = pict->linesize[p];", "                 for (y=0; y<(h>>1); y++)", "                     for (x=0; x<w; x++)", "                         FFSWAP(int,", "                                pict->data[p][x + y*linesize],", "                                pict->data[p][x + (h-1-y)*linesize]);", "             }", "         }", "         *got_frame = 1;", "     }", "     if (slice_ret < 0 && (avctx->err_recognition & AV_EF_EXPLODE))", "         return slice_ret;", "     else", "         return get_consumed_bytes(s, buf_size);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int filter_frame(AVFilterLink *inlink, AVFrame *frame)", " {", "     AVFilterContext   *ctx     = inlink->dst;", "     FieldOrderContext *s       = ctx->priv;", "     AVFilterLink      *outlink = ctx->outputs[0];", "     int h, plane, line_step, line_size, line;", "     uint8_t *data;", "     if (!frame->interlaced_frame ||", "         frame->top_field_first == s->dst_tff)", "         return ff_filter_frame(outlink, frame);", "     av_dlog(ctx,", "              \"picture will move %s one line\\n\",", "              s->dst_tff ? \"up\" : \"down\");", "      h = frame->height;", "    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {", "     for (plane = 0; plane < 4 && frame->data[plane] && frame->linesize[plane]; plane++) {", "          line_step = frame->linesize[plane];", "          line_size = s->line_size[plane];", "          data = frame->data[plane];", "         if (s->dst_tff) {", "             for (line = 0; line < h; line++) {", "                 if (1 + line < frame->height) {", "                     memcpy(data, data + line_step, line_size);", "                 } else {", "                     memcpy(data, data - line_step - line_step, line_size);", "                 }", "                 data += line_step;", "             }", "         } else {", "             data += (h - 1) * line_step;", "             for (line = h - 1; line >= 0 ; line--) {", "                 if (line > 0) {", "                     memcpy(data, data - line_step, line_size);", "                 } else {", "                     memcpy(data, data + line_step + line_step, line_size);", "                 }", "                 data -= line_step;", "             }", "         }", "     }", "     frame->top_field_first = s->dst_tff;", "     return ff_filter_frame(outlink, frame);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" get_uncompressed_data(struct archive_read *a, const void **buff, size_t size,", "     size_t minimum)", " {", " \tstruct _7zip *zip = (struct _7zip *)a->format->data;", " \tssize_t bytes_avail;", "  \tif (zip->codec == _7Z_COPY && zip->codec2 == (unsigned long)-1) {", "\t\t*buff = __archive_read_ahead(a, 1, &bytes_avail);", " \t\t*buff = __archive_read_ahead(a, minimum, &bytes_avail);", "  \t\tif (bytes_avail <= 0) {", "  \t\t\tarchive_set_error(&a->archive,", "  \t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,", " \t\t\t    \"Truncated 7-Zip file data\");", " \t\t\treturn (ARCHIVE_FATAL);", " \t\t}", " \t\tif ((size_t)bytes_avail >", " \t\t    zip->uncompressed_buffer_bytes_remaining)", " \t\t\tbytes_avail = (ssize_t)", " \t\t\t    zip->uncompressed_buffer_bytes_remaining;", " \t\tif ((size_t)bytes_avail > size)", " \t\t\tbytes_avail = (ssize_t)size;", " \t\tzip->pack_stream_bytes_unconsumed = bytes_avail;", " \t} else if (zip->uncompressed_buffer_pointer == NULL) {", " \t\tarchive_set_error(&(a->archive),", " \t\t    ARCHIVE_ERRNO_MISC, \"Damaged 7-Zip archive\");", " \t\treturn (ARCHIVE_FATAL);", " \t} else {", " \t\tif (minimum > zip->uncompressed_buffer_bytes_remaining) {", " \t\t\tif (extract_pack_stream(a, minimum) < 0)", " \t\t\t\treturn (ARCHIVE_FATAL);", " \t\t}", " \t\tif (size > zip->uncompressed_buffer_bytes_remaining)", " \t\t\tbytes_avail = (ssize_t)", " \t\t\t    zip->uncompressed_buffer_bytes_remaining;", " \t\telse", " \t\t\tbytes_avail = (ssize_t)size;", " \t\t*buff = zip->uncompressed_buffer_pointer;", " \t\tzip->uncompressed_buffer_pointer += bytes_avail;", " \t}", " \tzip->uncompressed_buffer_bytes_remaining -= bytes_avail;", " \treturn (bytes_avail);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int mxf_read_index_entry_array(AVIOContext *pb, MXFIndexTableSegment *segment)", " {", "     int i, length;", "      segment->nb_index_entries = avio_rb32(pb);", "      length = avio_rb32(pb);", "     if(segment->nb_index_entries && length < 11)", "         return AVERROR_INVALIDDATA;", "      if (!(segment->temporal_offset_entries=av_calloc(segment->nb_index_entries, sizeof(*segment->temporal_offset_entries))) ||", "          !(segment->flag_entries          = av_calloc(segment->nb_index_entries, sizeof(*segment->flag_entries))) ||", "         !(segment->stream_offset_entries = av_calloc(segment->nb_index_entries, sizeof(*segment->stream_offset_entries)))) {", "         av_freep(&segment->temporal_offset_entries);", "         av_freep(&segment->flag_entries);", "         return AVERROR(ENOMEM);", "      }", "      for (i = 0; i < segment->nb_index_entries; i++) {", "         if(avio_feof(pb))", "             return AVERROR_INVALIDDATA;", "          segment->temporal_offset_entries[i] = avio_r8(pb);", "          avio_r8(pb);                                         ", "          segment->flag_entries[i] = avio_r8(pb);", "         segment->stream_offset_entries[i] = avio_rb64(pb);", "         avio_skip(pb, length - 11);", "     }", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, void *yyscanner, HEX_LEX_ENVIRONMENT *lex_env)", " {", "   YYUSE (yyvaluep);", "   YYUSE (yyscanner);", "   YYUSE (lex_env);", "   if (!yymsg)", "     yymsg = \"Deleting\";", "   YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);", "   YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN", "    switch (yytype)", "      {", "            case 16:  ", "#line 94 \"hex_grammar.y\"  ", " #line 101 \"hex_grammar.y\"  ", "        { yr_re_node_destroy(((*yyvaluep).re_node)); }", "#line 1023 \"hex_grammar.c\"  ", " #line 1030 \"hex_grammar.c\"  ", "          break;", "      case 17:  ", "#line 95 \"hex_grammar.y\"  ", " #line 102 \"hex_grammar.y\"  ", "        { yr_re_node_destroy(((*yyvaluep).re_node)); }", "#line 1029 \"hex_grammar.c\"  ", " #line 1036 \"hex_grammar.c\"  ", "          break;", "      case 18:  ", "#line 96 \"hex_grammar.y\"  ", " #line 103 \"hex_grammar.y\"  ", "        { yr_re_node_destroy(((*yyvaluep).re_node)); }", "#line 1035 \"hex_grammar.c\"  ", " #line 1042 \"hex_grammar.c\"  ", "          break;", "      case 19:  ", "#line 97 \"hex_grammar.y\"  ", " #line 104 \"hex_grammar.y\"  ", "        { yr_re_node_destroy(((*yyvaluep).re_node)); }", "#line 1041 \"hex_grammar.c\"  ", " #line 1048 \"hex_grammar.c\"  ", "          break;", "      case 21:  ", "#line 100 \"hex_grammar.y\"  ", " #line 107 \"hex_grammar.y\"  ", "        { yr_re_node_destroy(((*yyvaluep).re_node)); }", "#line 1047 \"hex_grammar.c\"  ", " #line 1054 \"hex_grammar.c\"  ", "          break;", "      case 22:  ", "#line 99 \"hex_grammar.y\"  ", " #line 106 \"hex_grammar.y\"  ", "        { yr_re_node_destroy(((*yyvaluep).re_node)); }", "#line 1053 \"hex_grammar.c\"  ", " #line 1060 \"hex_grammar.c\"  ", "          break;", "      case 23:  ", "#line 98 \"hex_grammar.y\"  ", " #line 105 \"hex_grammar.y\"  ", "        { yr_re_node_destroy(((*yyvaluep).re_node)); }", "#line 1059 \"hex_grammar.c\"  ", " #line 1066 \"hex_grammar.c\"  ", "          break;", "       default:", "         break;", "     }", "   YY_IGNORE_MAYBE_UNINITIALIZED_END", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static long mem_seek(jas_stream_obj_t *obj, long offset, int origin)", "  {", "  \tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;", "\tlong newpos;", " \tsize_t newpos;", "  \tJAS_DBGLOG(100, (\"mem_seek(%p, %ld, %d)\\n\", obj, offset, origin));", "  \tswitch (origin) {", " \tcase SEEK_SET:", " \t\tnewpos = offset;", " \t\tbreak;", " \tcase SEEK_END:", " \t\tnewpos = m->len_ - offset;", " \t\tbreak;", " \tcase SEEK_CUR:", " \t\tnewpos = m->pos_ + offset;", " \t\tbreak;", " \tdefault:", " \t\tabort();", " \t\tbreak;", " \t}", " \tif (newpos < 0) {", " \t\treturn -1;", " \t}", " \tm->pos_ = newpos;", " \treturn m->pos_;", " }"], "ner_tags": [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int main(int argc, char **argv)", " {", " \tint fmtid;", " \tint id;", " \tchar *infile;", " \tjas_stream_t *instream;", " \tjas_image_t *image;", " \tint width;", " \tint height;", " \tint depth;", " \tint numcmpts;", " \tint verbose;", "  \tchar *fmtname;", "  \tint debug;", "  \tsize_t max_mem;", " \tsize_t max_samples;", " \tchar optstr[32];", "  \tif (jas_init()) {", "  \t\tabort();", "  \t}", "  \tcmdname = argv[0];", " \tmax_samples = 64 * JAS_MEBI;", "  \tinfile = 0;", "  \tverbose = 0;", "  \tdebug = 0;", " #if defined(JAS_DEFAULT_MAX_MEM_USAGE)", " \tmax_mem = JAS_DEFAULT_MAX_MEM_USAGE;", " #endif", " \twhile ((id = jas_getopt(argc, argv, opts)) >= 0) {", " \t\tswitch (id) {", " \t\tcase OPT_VERBOSE:", " \t\t\tverbose = 1;", " \t\t\tbreak;", " \t\tcase OPT_VERSION:", " \t\t\tprintf(\"%s\\n\", JAS_VERSION);", " \t\t\texit(EXIT_SUCCESS);", " \t\t\tbreak;", " \t\tcase OPT_DEBUG:", " \t\t\tdebug = atoi(jas_optarg);", " \t\t\tbreak;", "  \t\tcase OPT_INFILE:", "  \t\t\tinfile = jas_optarg;", "  \t\t\tbreak;", " \t\tcase OPT_MAXSAMPLES:", " \t\t\tmax_samples = strtoull(jas_optarg, 0, 10);", " \t\t\tbreak;", "  \t\tcase OPT_MAXMEM:", "  \t\t\tmax_mem = strtoull(jas_optarg, 0, 10);", "  \t\t\tbreak;", " \t\tcase OPT_HELP:", " \t\tdefault:", " \t\t\tusage();", " \t\t\tbreak;", " \t\t}", " \t}", " \tjas_setdbglevel(debug);", " #if defined(JAS_DEFAULT_MAX_MEM_USAGE)", " \tjas_set_max_mem_usage(max_mem);", " #endif", " \tif (infile) {", " \t\tif (!(instream = jas_stream_fopen(infile, \"rb\"))) {", " \t\t\tfprintf(stderr, \"cannot open input image file %s\\n\", infile);", " \t\t\texit(EXIT_FAILURE);", " \t\t}", " \t} else {", " \t\tif (!(instream = jas_stream_fdopen(0, \"rb\"))) {", " \t\t\tfprintf(stderr, \"cannot open standard input\\n\");", " \t\t\texit(EXIT_FAILURE);", " \t\t}", " \t}", " \tif ((fmtid = jas_image_getfmt(instream)) < 0) {", "  \t\tfprintf(stderr, \"unknown image format\\n\");", "  \t}", " \tsnprintf(optstr, sizeof(optstr), \"max_samples=%-zu\", max_samples);", "\tif (!(image = jas_image_decode(instream, fmtid, 0))) {", " \tif (!(image = jas_image_decode(instream, fmtid, optstr))) {", "  \t\tjas_stream_close(instream);", "  \t\tfprintf(stderr, \"cannot load image\\n\");", "  \t\treturn EXIT_FAILURE;", " \t}", "  \tjas_stream_close(instream);", " \tif (!(fmtname = jas_image_fmttostr(fmtid))) {", " \t\tjas_eprintf(\"format name lookup failed\\n\");", " \t\treturn EXIT_FAILURE;", " \t}", "  \tif (!(numcmpts = jas_image_numcmpts(image))) {", "  \t\tfprintf(stderr, \"warning: image has no components\\n\");", "  \t}", " \tif (numcmpts) {", " \t\twidth = jas_image_cmptwidth(image, 0);", " \t\theight = jas_image_cmptheight(image, 0);", " \t\tdepth = jas_image_cmptprec(image, 0);", " \t} else {", " \t\twidth = 0;", "  \t\theight = 0;", "  \t\tdepth = 0;", "  \t}", "\tif (!(fmtname = jas_image_fmttostr(fmtid))) {", "\t\tabort();", "\t}", "\tprintf(\"%s %d %d %d %d %ld\\n\", fmtname, numcmpts, width, height, depth, (long) jas_image_rawsize(image));", " \tprintf(\"%s %d %d %d %d %ld\\n\", fmtname, numcmpts, width, height, depth,", " \t  JAS_CAST(long, jas_image_rawsize(image)));", "  \tjas_image_destroy(image);", "  \tjas_image_clearfmts();", " \treturn EXIT_SUCCESS;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": [" NO_INLINE JsVar *jspeFactor() {", "   if (lex->tk==LEX_ID) {", "     JsVar *a = jspGetNamedVariable(jslGetTokenValueAsString(lex));", "     JSP_ASSERT_MATCH(LEX_ID);", " #ifndef SAVE_ON_FLASH", "     if (lex->tk==LEX_TEMPLATE_LITERAL)", "       jsExceptionHere(JSET_SYNTAXERROR, \"Tagged template literals not supported\");", "     else if (lex->tk==LEX_ARROW_FUNCTION && jsvIsName(a)) {", "       JsVar *funcVar = jspeArrowFunction(0,a);", "       jsvUnLock(a);", "       a=funcVar;", "     }", " #endif", "     return a;", "   } else if (lex->tk==LEX_INT) {", "     JsVar *v = 0;", "     if (JSP_SHOULD_EXECUTE) {", "       v = jsvNewFromLongInteger(stringToInt(jslGetTokenValueAsString(lex)));", "     }", "     JSP_ASSERT_MATCH(LEX_INT);", "     return v;", "   } else if (lex->tk==LEX_FLOAT) {", "     JsVar *v = 0;", "     if (JSP_SHOULD_EXECUTE) {", "       v = jsvNewFromFloat(stringToFloat(jslGetTokenValueAsString(lex)));", "     }", "     JSP_ASSERT_MATCH(LEX_FLOAT);", "     return v;", "   } else if (lex->tk=='(') {", "     JSP_ASSERT_MATCH('(');", "     if (!jspCheckStackPosition()) return 0;", " #ifdef SAVE_ON_FLASH", "     JsVar *a = jspeExpression();", "     if (!JSP_SHOULDNT_PARSE) JSP_MATCH_WITH_RETURN(')',a);", "     return a;", " #else", "     return jspeExpressionOrArrowFunction();", " #endif", "   } else if (lex->tk==LEX_R_TRUE) {", "     JSP_ASSERT_MATCH(LEX_R_TRUE);", "     return JSP_SHOULD_EXECUTE ? jsvNewFromBool(true) : 0;", "   } else if (lex->tk==LEX_R_FALSE) {", "     JSP_ASSERT_MATCH(LEX_R_FALSE);", "     return JSP_SHOULD_EXECUTE ? jsvNewFromBool(false) : 0;", "   } else if (lex->tk==LEX_R_NULL) {", "     JSP_ASSERT_MATCH(LEX_R_NULL);", "     return JSP_SHOULD_EXECUTE ? jsvNewWithFlags(JSV_NULL) : 0;", "   } else if (lex->tk==LEX_R_UNDEFINED) {", "     JSP_ASSERT_MATCH(LEX_R_UNDEFINED);", "     return 0;", "   } else if (lex->tk==LEX_STR) {", "     JsVar *a = 0;", "     if (JSP_SHOULD_EXECUTE)", "       a = jslGetTokenValueAsVar(lex);", "     JSP_ASSERT_MATCH(LEX_STR);", "     return a;", " #ifndef SAVE_ON_FLASH", "   } else if (lex->tk==LEX_TEMPLATE_LITERAL) {", "     return jspeTemplateLiteral();", " #endif", "   } else if (lex->tk==LEX_REGEX) {", "     JsVar *a = 0;", " #ifdef SAVE_ON_FLASH", "     jsExceptionHere(JSET_SYNTAXERROR, \"RegEx are not supported in this version of Espruino\\n\");", " #else", "     JsVar *regex = jslGetTokenValueAsVar(lex);", "     size_t regexEnd = 0, regexLen = 0;", "     JsvStringIterator it;", "     jsvStringIteratorNew(&it, regex, 0);", "     while (jsvStringIteratorHasChar(&it)) {", "       regexLen++;", "       if (jsvStringIteratorGetChar(&it)=='/')", "         regexEnd = regexLen;", "       jsvStringIteratorNext(&it);", "     }", "     jsvStringIteratorFree(&it);", "     JsVar *flags = 0;", "     if (regexEnd < regexLen)", "       flags = jsvNewFromStringVar(regex, regexEnd, JSVAPPENDSTRINGVAR_MAXLENGTH);", "     JsVar *regexSource = jsvNewFromStringVar(regex, 1, regexEnd-2);", "     a = jswrap_regexp_constructor(regexSource, flags);", "     jsvUnLock3(regex, flags, regexSource);", " #endif", "     JSP_ASSERT_MATCH(LEX_REGEX);", "     return a;", "   } else if (lex->tk=='{') {", "     if (!jspCheckStackPosition()) return 0;", "     return jspeFactorObject();", "   } else if (lex->tk=='[') {", "     if (!jspCheckStackPosition()) return 0;", "     return jspeFactorArray();", "   } else if (lex->tk==LEX_R_FUNCTION) {", "     if (!jspCheckStackPosition()) return 0;", "     JSP_ASSERT_MATCH(LEX_R_FUNCTION);", "     return jspeFunctionDefinition(true);", " #ifndef SAVE_ON_FLASH", "   } else if (lex->tk==LEX_R_CLASS) {", "     if (!jspCheckStackPosition()) return 0;", "     JSP_ASSERT_MATCH(LEX_R_CLASS);", "     return jspeClassDefinition(true);", "   } else if (lex->tk==LEX_R_SUPER) {", "     JSP_ASSERT_MATCH(LEX_R_SUPER);", "     if (jsvIsObject(execInfo.thisVar)) {", "       JsVar *proto1 = jsvObjectGetChild(execInfo.thisVar, JSPARSE_INHERITS_VAR, 0);  ", "       JsVar *proto2 = jsvIsObject(proto1) ? jsvObjectGetChild(proto1, JSPARSE_INHERITS_VAR, 0) : 0;  ", "       jsvUnLock(proto1);", "       if (!proto2) {", "         jsExceptionHere(JSET_SYNTAXERROR, \"Calling 'super' outside of class\");", "         return 0;", "       }", "       if (lex->tk=='(') return proto2;  ", "       JsVar *proto3 = jsvIsFunction(proto2) ? jsvObjectGetChild(proto2, JSPARSE_PROTOTYPE_VAR, 0) : 0;", "       jsvUnLock(proto2);", "       return proto3;", "     } else if (jsvIsFunction(execInfo.thisVar)) {", "       JsVar *proto1 = jsvObjectGetChild(execInfo.thisVar, JSPARSE_PROTOTYPE_VAR, 0);", "       JsVar *proto2 = jsvIsObject(proto1) ? jsvObjectGetChild(proto1, JSPARSE_INHERITS_VAR, 0) : 0;", "       jsvUnLock(proto1);", "       if (!proto2) {", "         jsExceptionHere(JSET_SYNTAXERROR, \"Calling 'super' outside of class\");", "         return 0;", "       }", "       return proto2;", "     }", "     jsExceptionHere(JSET_SYNTAXERROR, \"Calling 'super' outside of class\");", "     return 0;", " #endif", "   } else if (lex->tk==LEX_R_THIS) {", "     JSP_ASSERT_MATCH(LEX_R_THIS);", "     return jsvLockAgain( execInfo.thisVar ? execInfo.thisVar : execInfo.root );", "   } else if (lex->tk==LEX_R_DELETE) {", "     if (!jspCheckStackPosition()) return 0;", "     return jspeFactorDelete();", "   } else if (lex->tk==LEX_R_TYPEOF) {", "      if (!jspCheckStackPosition()) return 0;", "      return jspeFactorTypeOf();", "    } else if (lex->tk==LEX_R_VOID) {", "     if (!jspCheckStackPosition()) return 0;", "      JSP_ASSERT_MATCH(LEX_R_VOID);", "      jsvUnLock(jspeUnaryExpression());", "      return 0;", "   }", "   JSP_MATCH(LEX_EOF);", "   jsExceptionHere(JSET_SYNTAXERROR, \"Unexpected end of Input\\n\");", "   return 0;", " }", " NO_INLINE JsVar *__jspePostfixExpression(JsVar *a) {", "   while (lex->tk==LEX_PLUSPLUS || lex->tk==LEX_MINUSMINUS) {", "     int op = lex->tk;", "     JSP_ASSERT_MATCH(op);", "     if (JSP_SHOULD_EXECUTE) {", "       JsVar *one = jsvNewFromInteger(1);", "       JsVar *oldValue = jsvAsNumberAndUnLock(jsvSkipName(a));  ", "       JsVar *res = jsvMathsOpSkipNames(oldValue, one, op==LEX_PLUSPLUS ? '+' : '-');", "       jsvUnLock(one);", "       jspReplaceWith(a, res);", "       jsvUnLock(res);", "       jsvUnLock(a);", "       a = oldValue;", "     }", "   }", "   return a;", " }", " NO_INLINE JsVar *jspePostfixExpression() {", "   JsVar *a;", "   if (lex->tk==LEX_PLUSPLUS || lex->tk==LEX_MINUSMINUS) {", "     int op = lex->tk;", "     JSP_ASSERT_MATCH(op);", "     a = jspePostfixExpression();", "     if (JSP_SHOULD_EXECUTE) {", "       JsVar *one = jsvNewFromInteger(1);", "       JsVar *res = jsvMathsOpSkipNames(a, one, op==LEX_PLUSPLUS ? '+' : '-');", "       jsvUnLock(one);", "       jspReplaceWith(a, res);", "       jsvUnLock(res);", "     }", "   } else", "     a = jspeFactorFunctionCall();", "   return __jspePostfixExpression(a);", " }", " NO_INLINE JsVar *jspeUnaryExpression() {", "   if (lex->tk=='!' || lex->tk=='~' || lex->tk=='-' || lex->tk=='+') {", "     short tk = lex->tk;", "     JSP_ASSERT_MATCH(tk);", "     if (!JSP_SHOULD_EXECUTE) {", "       return jspeUnaryExpression();", "     }", "     if (tk=='!') {  ", "       return jsvNewFromBool(!jsvGetBoolAndUnLock(jsvSkipNameAndUnLock(jspeUnaryExpression())));", "     } else if (tk=='~') {  ", "       return jsvNewFromInteger(~jsvGetIntegerAndUnLock(jsvSkipNameAndUnLock(jspeUnaryExpression())));", "     } else if (tk=='-') {  ", "       return jsvNegateAndUnLock(jspeUnaryExpression());  ", "     }  else if (tk=='+') {  ", "       JsVar *v = jsvSkipNameAndUnLock(jspeUnaryExpression());", "       JsVar *r = jsvAsNumber(v);  ", "       jsvUnLock(v);", "       return r;", "     }", "     assert(0);", "     return 0;", "   } else", "     return jspePostfixExpression();", " }", " unsigned int jspeGetBinaryExpressionPrecedence(int op) {", "   switch (op) {", "   case LEX_OROR: return 1; break;", "   case LEX_ANDAND: return 2; break;", "   case '|' : return 3; break;", "   case '^' : return 4; break;", "   case '&' : return 5; break;", "   case LEX_EQUAL:", "   case LEX_NEQUAL:", "   case LEX_TYPEEQUAL:", "   case LEX_NTYPEEQUAL: return 6;", "   case LEX_LEQUAL:", "   case LEX_GEQUAL:", "   case '<':", "   case '>':", "   case LEX_R_INSTANCEOF: return 7;", "   case LEX_R_IN: return (execInfo.execute&EXEC_FOR_INIT)?0:7;", "   case LEX_LSHIFT:", "   case LEX_RSHIFT:", "   case LEX_RSHIFTUNSIGNED: return 8;", "   case '+':", "   case '-': return 9;", "   case '*':", "   case '/':", "   case '%': return 10;", "   default: return 0;", "   }", " }", " NO_INLINE JsVar *__jspeBinaryExpression(JsVar *a, unsigned int lastPrecedence) {", "   unsigned int precedence = jspeGetBinaryExpressionPrecedence(lex->tk);", "   while (precedence && precedence>lastPrecedence) {", "     int op = lex->tk;", "     JSP_ASSERT_MATCH(op);", "     if (op==LEX_ANDAND || op==LEX_OROR) {", "       bool aValue = jsvGetBoolAndUnLock(jsvSkipName(a));", "       if ((!aValue && op==LEX_ANDAND) ||", "           (aValue && op==LEX_OROR)) {", "         JSP_SAVE_EXECUTE();", "         jspSetNoExecute();", "         jsvUnLock(__jspeBinaryExpression(jspeUnaryExpression(),precedence));", "         JSP_RESTORE_EXECUTE();", "       } else {", "         jsvUnLock(a);", "         a = __jspeBinaryExpression(jspeUnaryExpression(),precedence);", "       }", "     } else {  ", "       JsVar *b = __jspeBinaryExpression(jspeUnaryExpression(),precedence);", "       if (JSP_SHOULD_EXECUTE) {", "         if (op==LEX_R_IN) {", "           JsVar *av = jsvSkipName(a);  ", "           JsVar *bv = jsvSkipName(b);  ", "           if (jsvIsArray(bv) || jsvIsObject(bv)) {  ", "             av = jsvAsArrayIndexAndUnLock(av);", "             JsVar *varFound = jspGetVarNamedField( bv, av, true);", "             jsvUnLock(a);", "             a = jsvNewFromBool(varFound!=0);", "             jsvUnLock(varFound);", "           } else { ", "             jsExceptionHere(JSET_ERROR, \"Cannot use 'in' operator to search a %t\", bv);", "             jsvUnLock(a);", "             a = 0;", "           }", "           jsvUnLock2(av, bv);", "         } else if (op==LEX_R_INSTANCEOF) {", "           bool inst = false;", "           JsVar *av = jsvSkipName(a);", "           JsVar *bv = jsvSkipName(b);", "           if (!jsvIsFunction(bv)) {", "             jsExceptionHere(JSET_ERROR, \"Expecting a function on RHS in instanceof check, got %t\", bv);", "           } else {", "             if (jsvIsObject(av) || jsvIsFunction(av)) {", "               JsVar *bproto = jspGetNamedField(bv, JSPARSE_PROTOTYPE_VAR, false);", "               JsVar *proto = jsvObjectGetChild(av, JSPARSE_INHERITS_VAR, 0);", "               while (proto) {", "                 if (proto == bproto) inst=true;", "                 JsVar *childProto = jsvObjectGetChild(proto, JSPARSE_INHERITS_VAR, 0);", "                 jsvUnLock(proto);", "                 proto = childProto;", "               }", "               if (jspIsConstructor(bv, \"Object\")) inst = true;", "               jsvUnLock(bproto);", "             }", "             if (!inst) {", "               const char *name = jswGetBasicObjectName(av);", "               if (name) {", "                 inst = jspIsConstructor(bv, name);", "               }", "               if (!inst && (jsvIsArray(av) || jsvIsArrayBuffer(av)) &&", "                   jspIsConstructor(bv, \"Object\"))", "                 inst = true;", "             }", "           }", "           jsvUnLock3(av, bv, a);", "           a = jsvNewFromBool(inst);", "         } else {   ", "           JsVar *res = jsvMathsOpSkipNames(a, b, op);", "           jsvUnLock(a); a = res;", "         }", "       }", "       jsvUnLock(b);", "     }", "     precedence = jspeGetBinaryExpressionPrecedence(lex->tk);", "   }", "   return a;", " }", " JsVar *jspeBinaryExpression() {", "   return __jspeBinaryExpression(jspeUnaryExpression(),0);", " }", " NO_INLINE JsVar *__jspeConditionalExpression(JsVar *lhs) {", "   if (lex->tk=='?') {", "     JSP_ASSERT_MATCH('?');", "     if (!JSP_SHOULD_EXECUTE) {", "       jsvUnLock(jspeAssignmentExpression());", "       JSP_MATCH(':');", "       jsvUnLock(jspeAssignmentExpression());", "     } else {", "       bool first = jsvGetBoolAndUnLock(jsvSkipName(lhs));", "       jsvUnLock(lhs);", "       if (first) {", "         lhs = jspeAssignmentExpression();", "         JSP_MATCH(':');", "         JSP_SAVE_EXECUTE();", "         jspSetNoExecute();", "         jsvUnLock(jspeAssignmentExpression());", "         JSP_RESTORE_EXECUTE();", "       } else {", "         JSP_SAVE_EXECUTE();", "         jspSetNoExecute();", "         jsvUnLock(jspeAssignmentExpression());", "         JSP_RESTORE_EXECUTE();", "         JSP_MATCH(':');", "         lhs = jspeAssignmentExpression();", "       }", "     }", "   }", "   return lhs;", " }", " JsVar *jspeConditionalExpression() {", "   return __jspeConditionalExpression(jspeBinaryExpression());", " }", " NO_INLINE JsVar *__jspeAssignmentExpression(JsVar *lhs) {", "   if (lex->tk=='=' || lex->tk==LEX_PLUSEQUAL || lex->tk==LEX_MINUSEQUAL ||", "       lex->tk==LEX_MULEQUAL || lex->tk==LEX_DIVEQUAL || lex->tk==LEX_MODEQUAL ||", "       lex->tk==LEX_ANDEQUAL || lex->tk==LEX_OREQUAL ||", "       lex->tk==LEX_XOREQUAL || lex->tk==LEX_RSHIFTEQUAL ||", "       lex->tk==LEX_LSHIFTEQUAL || lex->tk==LEX_RSHIFTUNSIGNEDEQUAL) {", "     JsVar *rhs;", "     int op = lex->tk;", "     JSP_ASSERT_MATCH(op);", "     rhs = jspeAssignmentExpression();", "     rhs = jsvSkipNameAndUnLock(rhs);  ", "     if (JSP_SHOULD_EXECUTE && lhs) {", "       if (op=='=') {", "         if (!jsvGetRefs(lhs) && jsvIsName(lhs)) {", "           if (!jsvIsArrayBufferName(lhs) && !jsvIsNewChild(lhs))", "             jsvAddName(execInfo.root, lhs);", "         }", "         jspReplaceWith(lhs, rhs);", "       } else {", "         if (op==LEX_PLUSEQUAL) op='+';", "         else if (op==LEX_MINUSEQUAL) op='-';", "         else if (op==LEX_MULEQUAL) op='*';", "         else if (op==LEX_DIVEQUAL) op='/';", "         else if (op==LEX_MODEQUAL) op='%';", "         else if (op==LEX_ANDEQUAL) op='&';", "         else if (op==LEX_OREQUAL) op='|';", "         else if (op==LEX_XOREQUAL) op='^';", "         else if (op==LEX_RSHIFTEQUAL) op=LEX_RSHIFT;", "         else if (op==LEX_LSHIFTEQUAL) op=LEX_LSHIFT;", "         else if (op==LEX_RSHIFTUNSIGNEDEQUAL) op=LEX_RSHIFTUNSIGNED;", "         if (op=='+' && jsvIsName(lhs)) {", "           JsVar *currentValue = jsvSkipName(lhs);", "           if (jsvIsString(currentValue) && !jsvIsFlatString(currentValue) && jsvGetRefs(currentValue)==1 && rhs!=currentValue) {", "             JsVar *str = jsvAsString(rhs, false);", "             jsvAppendStringVarComplete(currentValue, str);", "             jsvUnLock(str);", "             op = 0;", "           }", "           jsvUnLock(currentValue);", "         }", "         if (op) {", "           JsVar *res = jsvMathsOpSkipNames(lhs,rhs,op);", "           jspReplaceWith(lhs, res);", "           jsvUnLock(res);", "         }", "       }", "     }", "     jsvUnLock(rhs);", "   }", "   return lhs;", " }", " JsVar *jspeAssignmentExpression() {", "   return __jspeAssignmentExpression(jspeConditionalExpression());", " }", " NO_INLINE JsVar *jspeExpression() {", "   while (!JSP_SHOULDNT_PARSE) {", "     JsVar *a = jspeAssignmentExpression();", "     if (lex->tk!=',') return a;", "     jsvUnLock(a);", "     JSP_ASSERT_MATCH(',');", "   }", "   return 0;", " }", " NO_INLINE void jspeBlockNoBrackets() {", "   if (JSP_SHOULD_EXECUTE) {", "     while (lex->tk && lex->tk!='}') {", "       jsvUnLock(jspeStatement());", "       if (JSP_HAS_ERROR) {", "         if (lex && !(execInfo.execute&EXEC_ERROR_LINE_REPORTED)) {", "           execInfo.execute = (JsExecFlags)(execInfo.execute | EXEC_ERROR_LINE_REPORTED);", "           JsVar *stackTrace = jsvObjectGetChild(execInfo.hiddenRoot, JSPARSE_STACKTRACE_VAR, JSV_STRING_0);", "           if (stackTrace) {", "             jsvAppendPrintf(stackTrace, \"at \");", "             jspAppendStackTrace(stackTrace);", "             jsvUnLock(stackTrace);", "           }", "         }", "       }", "       if (JSP_SHOULDNT_PARSE)", "         return;", "     }", "   } else {", "     int brackets = 0;", "     while (lex->tk && (brackets || lex->tk != '}')) {", "       if (lex->tk == '{') brackets++;", "       if (lex->tk == '}') brackets--;", "       JSP_ASSERT_MATCH(lex->tk);", "     }", "   }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static int mem_write(jas_stream_obj_t *obj, char *buf, int cnt)", "  {", "\tint n;", " \tsize_t n;", "  \tint ret;", "  \tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;", "\tlong newbufsize;", "\tlong newpos;", " \tsize_t newbufsize;", " \tsize_t newpos;", "  \tassert(buf);", "  \tassert(cnt >= 0);", " \tJAS_DBGLOG(100, (\"mem_write(%p, %p, %d)\\n\", obj, buf, cnt));", " \tnewpos = m->pos_ + cnt;", "  \tif (newpos > m->bufsize_ && m->growable_) {", "  \t\tnewbufsize = m->bufsize_;", "  \t\twhile (newbufsize < newpos) {", "\t\t\tnewbufsize <<= 1;", "\t\t\tassert(newbufsize >= 0);", " \t\t\tif (!jas_safe_size_mul(newbufsize, 2, &newbufsize)) {", " \t\t\t\tJAS_DBGLOG(100, (\"new buffer size would cause overflow\\n\"));", " \t\t\t\treturn -1;", " \t\t\t}", "  \t\t}", "\t\tJAS_DBGLOG(100, (\"mem_write resizing from %d to %z\\n\", m->bufsize_,", " \t\tJAS_DBGLOG(100, (\"mem_write resizing from %d to %zu\\n\", m->bufsize_,", "  \t\t  newbufsize));", "\t\tJAS_DBGLOG(100, (\"mem_write resizing from %d to %ul\\n\", m->bufsize_,", "\t\t  JAS_CAST(unsigned long, newbufsize)));", " \t\tassert(newbufsize > 0);", "  \t\tif (mem_resize(m, newbufsize)) {", "  \t\t\treturn -1;", "  \t\t}", " \t}", " \tif (m->pos_ > m->len_) {", " \t\tn = JAS_MIN(m->pos_, m->bufsize_) - m->len_;", " \t\tif (n > 0) {", " \t\t\tmemset(&m->buf_[m->len_], 0, n);", " \t\t\tm->len_ += n;", " \t\t}", " \t\tif (m->pos_ != m->len_) {", " \t\t\treturn 0;", " \t\t}", " \t}", " \tn = m->bufsize_ - m->pos_;", " \tret = JAS_MIN(n, cnt);", " \tif (ret > 0) {", " \t\tmemcpy(&m->buf_[m->pos_], buf, ret);", " \t\tm->pos_ += ret;", " \t}", " \tif (m->pos_ > m->len_) {", " \t\tm->len_ = m->pos_;", " \t}", " \tassert(ret == cnt);", " \treturn ret;", " }"], "ner_tags": [0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" sf_open_virtual\t(SF_VIRTUAL_IO *sfvirtual, int mode, SF_INFO *sfinfo, void *user_data)", " {\tSF_PRIVATE \t*psf ;", " \tif (sfvirtual->get_filelen == NULL || sfvirtual->seek == NULL || sfvirtual->tell == NULL)", " \t{\tsf_errno = SFE_BAD_VIRTUAL_IO ;", " \t\tsnprintf (sf_parselog, sizeof (sf_parselog), \"Bad vio_get_filelen / vio_seek / vio_tell in SF_VIRTUAL_IO struct.\\n\") ;", " \t\treturn NULL ;", " \t\t} ;", " \tif ((mode == SFM_READ || mode == SFM_RDWR) && sfvirtual->read == NULL)", " \t{\tsf_errno = SFE_BAD_VIRTUAL_IO ;", " \t\tsnprintf (sf_parselog, sizeof (sf_parselog), \"Bad vio_read in SF_VIRTUAL_IO struct.\\n\") ;", " \t\treturn NULL ;", " \t\t} ;", " \tif ((mode == SFM_WRITE || mode == SFM_RDWR) && sfvirtual->write == NULL)", " \t{\tsf_errno = SFE_BAD_VIRTUAL_IO ;", " \t\tsnprintf (sf_parselog, sizeof (sf_parselog), \"Bad vio_write in SF_VIRTUAL_IO struct.\\n\") ;", "  \t\treturn NULL ;", "  \t\t} ;", "\tif ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)", " \tif ((psf = psf_allocate ()) == NULL)", "  \t{\tsf_errno = SFE_MALLOC_FAILED ;", "  \t\treturn\tNULL ;", "  \t\t} ;", " \tpsf_init_files (psf) ;", " \tpsf->virtual_io = SF_TRUE ;", " \tpsf->vio = *sfvirtual ;", " \tpsf->vio_user_data = user_data ;", " \tpsf->file.mode = mode ;", " \treturn psf_open_file (psf, sfinfo) ;", " }  "], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void gmc_mmx(uint8_t *dst, uint8_t *src,", "                     int stride, int h, int ox, int oy,", "                     int dxx, int dxy, int dyx, int dyy,", "                     int shift, int r, int width, int height)", " {", "     const int w    = 8;", "     const int ix   = ox  >> (16 + shift);", "     const int iy   = oy  >> (16 + shift);", "     const int oxs  = ox  >> 4;", "     const int oys  = oy  >> 4;", "     const int dxxs = dxx >> 4;", "     const int dxys = dxy >> 4;", "     const int dyxs = dyx >> 4;", "     const int dyys = dyy >> 4;", "     const uint16_t r4[4]   = { r, r, r, r };", "     const uint16_t dxy4[4] = { dxys, dxys, dxys, dxys };", "     const uint16_t dyy4[4] = { dyys, dyys, dyys, dyys };", "     const uint64_t shift2  = 2 * shift;", " #define MAX_STRIDE 4096U", " #define MAX_H 8U", "     uint8_t edge_buf[(MAX_H + 1) * MAX_STRIDE];", "     int x, y;", "     const int dxw = (dxx - (1 << (16 + shift))) * (w - 1);", "      const int dyh = (dyy - (1 << (16 + shift))) * (h - 1);", "      const int dxh = dxy * (h - 1);", "      const int dyw = dyx * (w - 1);", "    int need_emu  =  (unsigned) ix >= width  - w ||", "                     (unsigned) iy >= height - h;", "     int need_emu  =  (unsigned) ix >= width  - w || width < w ||", "                      (unsigned) iy >= height - h || height< h", "                      ;", "      if (  ", "          ((ox ^ (ox + dxw)) | (ox ^ (ox + dxh)) | (ox ^ (ox + dxw + dxh)) |", "          (oy ^ (oy + dyw)) | (oy ^ (oy + dyh)) | (oy ^ (oy + dyw + dyh))) >> (16 + shift) ||", "         (dxx | dxy | dyx | dyy) & 15 ||", "         (need_emu && (h > MAX_H || stride > MAX_STRIDE))) {", "         ff_gmc_c(dst, src, stride, h, ox, oy, dxx, dxy, dyx, dyy,", "                  shift, r, width, height);", "         return;", "     }", "     src += ix + iy * stride;", "     if (need_emu) {", "         ff_emulated_edge_mc_8(edge_buf, src, stride, stride, w + 1, h + 1, ix, iy, width, height);", "         src = edge_buf;", "     }", "     __asm__ volatile (", "         \"movd         %0, %%mm6         \\n\\t\"", "         \"pxor      %%mm7, %%mm7         \\n\\t\"", "         \"punpcklwd %%mm6, %%mm6         \\n\\t\"", "         \"punpcklwd %%mm6, %%mm6         \\n\\t\"", "         :: \"r\" (1 << shift));", "     for (x = 0; x < w; x += 4) {", "         uint16_t dx4[4] = { oxs - dxys + dxxs * (x + 0),", "                             oxs - dxys + dxxs * (x + 1),", "                             oxs - dxys + dxxs * (x + 2),", "                             oxs - dxys + dxxs * (x + 3) };", "         uint16_t dy4[4] = { oys - dyys + dyxs * (x + 0),", "                             oys - dyys + dyxs * (x + 1),", "                             oys - dyys + dyxs * (x + 2),", "                             oys - dyys + dyxs * (x + 3) };", "         for (y = 0; y < h; y++) {", "             __asm__ volatile (", "                 \"movq      %0, %%mm4    \\n\\t\"", "                 \"movq      %1, %%mm5    \\n\\t\"", "                 \"paddw     %2, %%mm4    \\n\\t\"", "                 \"paddw     %3, %%mm5    \\n\\t\"", "                 \"movq   %%mm4, %0       \\n\\t\"", "                 \"movq   %%mm5, %1       \\n\\t\"", "                 \"psrlw    $12, %%mm4    \\n\\t\"", "                 \"psrlw    $12, %%mm5    \\n\\t\"", "                 : \"+m\" (*dx4), \"+m\" (*dy4)", "                 : \"m\" (*dxy4), \"m\" (*dyy4));", "             __asm__ volatile (", "                 \"movq      %%mm6, %%mm2 \\n\\t\"", "                 \"movq      %%mm6, %%mm1 \\n\\t\"", "                 \"psubw     %%mm4, %%mm2 \\n\\t\"", "                 \"psubw     %%mm5, %%mm1 \\n\\t\"", "                 \"movq      %%mm2, %%mm0 \\n\\t\"", "                 \"movq      %%mm4, %%mm3 \\n\\t\"", "                 \"pmullw    %%mm1, %%mm0 \\n\\t\"  ", "                 \"pmullw    %%mm5, %%mm3 \\n\\t\"  ", "                 \"pmullw    %%mm5, %%mm2 \\n\\t\"  ", "                 \"pmullw    %%mm4, %%mm1 \\n\\t\"  ", "                 \"movd         %4, %%mm5 \\n\\t\"", "                 \"movd         %3, %%mm4 \\n\\t\"", "                 \"punpcklbw %%mm7, %%mm5 \\n\\t\"", "                 \"punpcklbw %%mm7, %%mm4 \\n\\t\"", "                 \"pmullw    %%mm5, %%mm3 \\n\\t\"  ", "                 \"pmullw    %%mm4, %%mm2 \\n\\t\"  ", "                 \"movd         %2, %%mm5 \\n\\t\"", "                 \"movd         %1, %%mm4 \\n\\t\"", "                 \"punpcklbw %%mm7, %%mm5 \\n\\t\"", "                 \"punpcklbw %%mm7, %%mm4 \\n\\t\"", "                 \"pmullw    %%mm5, %%mm1 \\n\\t\"  ", "                 \"pmullw    %%mm4, %%mm0 \\n\\t\"  ", "                 \"paddw        %5, %%mm1 \\n\\t\"", "                 \"paddw     %%mm3, %%mm2 \\n\\t\"", "                 \"paddw     %%mm1, %%mm0 \\n\\t\"", "                 \"paddw     %%mm2, %%mm0 \\n\\t\"", "                 \"psrlw        %6, %%mm0 \\n\\t\"", "                 \"packuswb  %%mm0, %%mm0 \\n\\t\"", "                 \"movd      %%mm0, %0    \\n\\t\"", "                 : \"=m\" (dst[x + y * stride])", "                 : \"m\" (src[0]), \"m\" (src[1]),", "                   \"m\" (src[stride]), \"m\" (src[stride + 1]),", "                   \"m\" (*r4), \"m\" (shift2));", "             src += stride;", "         }", "         src += 4 - h * stride;", "     }", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int vrend_create_vertex_elements_state(struct vrend_context *ctx,", "                                        uint32_t handle,", "                                        unsigned num_elements,", "                                        const struct pipe_vertex_element *elements)", " {", "    struct vrend_vertex_element_array *v = CALLOC_STRUCT(vrend_vertex_element_array);", "    const struct util_format_description *desc;", "    GLenum type;", "    int i;", "    uint32_t ret_handle;", "     if (!v)", "        return ENOMEM;", "    if (num_elements > PIPE_MAX_ATTRIBS)", "       return EINVAL;", "     v->count = num_elements;", "     for (i = 0; i < num_elements; i++) {", "        memcpy(&v->elements[i].base, &elements[i], sizeof(struct pipe_vertex_element));", "          FREE(v);", "          return EINVAL;", "       }", "       type = GL_FALSE;", "       if (desc->channel[0].type == UTIL_FORMAT_TYPE_FLOAT) {", "          if (desc->channel[0].size == 32)", "             type = GL_FLOAT;", "          else if (desc->channel[0].size == 64)", "             type = GL_DOUBLE;", "          else if (desc->channel[0].size == 16)", "             type = GL_HALF_FLOAT;", "       } else if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED &&", "                  desc->channel[0].size == 8)", "          type = GL_UNSIGNED_BYTE;", "       else if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED &&", "                desc->channel[0].size == 8)", "          type = GL_BYTE;", "       else if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED &&", "                desc->channel[0].size == 16)", "          type = GL_UNSIGNED_SHORT;", "       else if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED &&", "                desc->channel[0].size == 16)", "          type = GL_SHORT;", "       else if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED &&", "                desc->channel[0].size == 32)", "          type = GL_UNSIGNED_INT;", "       else if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED &&", "                desc->channel[0].size == 32)", "          type = GL_INT;", "       else if (elements[i].src_format == PIPE_FORMAT_R10G10B10A2_SSCALED ||", "                elements[i].src_format == PIPE_FORMAT_R10G10B10A2_SNORM ||", "                elements[i].src_format == PIPE_FORMAT_B10G10R10A2_SNORM)", "          type = GL_INT_2_10_10_10_REV;", "       else if (elements[i].src_format == PIPE_FORMAT_R10G10B10A2_USCALED ||", "                elements[i].src_format == PIPE_FORMAT_R10G10B10A2_UNORM ||", "                elements[i].src_format == PIPE_FORMAT_B10G10R10A2_UNORM)", "          type = GL_UNSIGNED_INT_2_10_10_10_REV;", "       else if (elements[i].src_format == PIPE_FORMAT_R11G11B10_FLOAT)", "          type = GL_UNSIGNED_INT_10F_11F_11F_REV;", "       if (type == GL_FALSE) {", "          report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_VERTEX_FORMAT, elements[i].src_format);", "          FREE(v);", "          return EINVAL;", "       }", "       v->elements[i].type = type;", "       if (desc->channel[0].normalized)", "          v->elements[i].norm = GL_TRUE;", "       if (desc->nr_channels == 4 && desc->swizzle[0] == UTIL_FORMAT_SWIZZLE_Z)", "          v->elements[i].nr_chan = GL_BGRA;", "       else if (elements[i].src_format == PIPE_FORMAT_R11G11B10_FLOAT)", "          v->elements[i].nr_chan = 3;", "       else", "          v->elements[i].nr_chan = desc->nr_channels;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static inline long decode_twos_comp(ulong c, int prec)", " static inline long decode_twos_comp(jas_ulong c, int prec)", "  {", "  \tlong result;", "  \tassert(prec >= 2);", " \tjas_eprintf(\"warning: support for signed data is untested\\n\");", " \tresult = (c & ((1 << (prec - 1)) - 1)) - (c & (1 << (prec - 1)));", "  \treturn result;", "  }"], "ner_tags": [0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void CtcpHandler::handleVersion(CtcpType ctcptype, const QString &prefix, const QString &target, const QString &param) {", " void CtcpHandler::handleVersion(CtcpType ctcptype, const QString &prefix, const QString &target, const QString &param, QString &reply) {", "    Q_UNUSED(target)", "    if(ctcptype == CtcpQuery) {", "    if(_ignoreListManager->ctcpMatch(prefix, network()->networkName(), \"VERSION\"))", "      return;", "    reply(nickFromMask(prefix), \"VERSION\", QString(\"Quassel IRC %1 (built on %2) -- http:www.quassel-irc.org\")", "          .arg(Quassel::buildInfo().plainVersionString)", "          .arg(Quassel::buildInfo().buildDate));", "     reply = QString(\"Quassel IRC %1 (built on %2) -- http:www.quassel-irc.org\").arg(Quassel::buildInfo().plainVersionString).arg(Quassel::buildInfo().buildDate);", "      emit displayMsg(Message::Server, BufferInfo::StatusBuffer, \"\", tr(\"Received CTCP VERSION request by %1\").arg(prefix));", "    } else {", "       str.append(tr(\" with arguments: %1\").arg(param));", "     emit displayMsg(Message::Error, BufferInfo::StatusBuffer, \"\", str);", "    }", "  }"], "ner_tags": [0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int itacns_add_data_files(sc_pkcs15_card_t *p15card)", " {", " \tconst size_t array_size =", " \t\tsizeof(itacns_data_files)/sizeof(itacns_data_files[0]);", " \tunsigned int i;", " \tint rv;", " \tsc_pkcs15_data_t *p15_personaldata = NULL;", " \tsc_pkcs15_data_info_t dinfo;", " \tstruct sc_pkcs15_object *objs[32];", " \tstruct sc_pkcs15_data_info *cinfo;", " \tfor(i=0; i < array_size; i++) {", " \t\tsc_path_t path;", " \t\tsc_pkcs15_data_info_t data;", " \t\tsc_pkcs15_object_t    obj;", " \t\tif (itacns_data_files[i].cie_only &&", " \t\t\tp15card->card->type != SC_CARD_TYPE_ITACNS_CIE_V2)", " \t\t\tcontinue;", " \t\tsc_format_path(itacns_data_files[i].path, &path);", " \t\tmemset(&data, 0, sizeof(data));", " \t\tmemset(&obj, 0, sizeof(obj));", " \t\tstrlcpy(data.app_label, itacns_data_files[i].label,", " \t\t\tsizeof(data.app_label));", " \t\tstrlcpy(obj.label, itacns_data_files[i].label,", " \t\t\tsizeof(obj.label));", " \t\tdata.path = path;", " \t\trv = sc_pkcs15emu_add_data_object(p15card, &obj, &data);", " \t\tSC_TEST_RET(p15card->card->ctx, SC_LOG_DEBUG_NORMAL, rv,", " \t\t\t\"Could not add data file\");", " \t}", " \tmemset(&dinfo, 0, sizeof(dinfo));", " \tstrcpy(dinfo.app_label, \"EF_DatiPersonali\");", " \trv = sc_pkcs15_get_objects(p15card, SC_PKCS15_TYPE_DATA_OBJECT,", " \t\tobjs, 32);", " \tif(rv < 0) {", " \t\tsc_debug(p15card->card->ctx, SC_LOG_DEBUG_NORMAL,", " \t\t\t\"Data enumeration failed\");", " \t\treturn SC_SUCCESS;", " \t}", " \tfor(i=0; i<32; i++) {", " \t\tcinfo = (struct sc_pkcs15_data_info *) objs[i]->data;", " \t\tif(!strcmp(\"EF_DatiPersonali\", objs[i]->label))", " \t\t\tbreak;", " \t}", " \tif(i>=32) {", " \t\tsc_debug(p15card->card->ctx, SC_LOG_DEBUG_NORMAL,", " \t\t\t\"Could not find EF_DatiPersonali: \"", " \t\t\t\"keeping generic card name\");", " \t\treturn SC_SUCCESS;", " \t}", " \trv = sc_pkcs15_read_data_object(p15card, cinfo, &p15_personaldata);", " \tif (rv) {", "  \t\tsc_debug(p15card->card->ctx, SC_LOG_DEBUG_NORMAL,", "  \t\t\t\"Could not read EF_DatiPersonali: \"", "  \t\t\t\"keeping generic card name\");", " \t\treturn SC_SUCCESS;", "  \t}", "  \t{", " \t\tchar fullname[160];", " \t\tif(get_name_from_EF_DatiPersonali(p15_personaldata->data,", " \t\t\tfullname, sizeof(fullname))) {", " \t\t\tsc_debug(p15card->card->ctx, SC_LOG_DEBUG_NORMAL,", " \t\t\t\t\"Could not parse EF_DatiPersonali: \"", " \t\t\t\t\"keeping generic card name\");", " \t\t\tsc_pkcs15_free_data_object(p15_personaldata);", " \t\t\treturn SC_SUCCESS;", " \t\t}", " \t\tset_string(&p15card->tokeninfo->label, fullname);", " \t}", " \tsc_pkcs15_free_data_object(p15_personaldata);", " \treturn SC_SUCCESS;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" virDomainGetTime(virDomainPtr dom,", "                  long long *seconds,", "                  unsigned int *nseconds,", "                  unsigned int flags)", " {", "     VIR_DOMAIN_DEBUG(dom, \"seconds=%p, nseconds=%p, flags=%x\",", "                      seconds, nseconds, flags);", "      virResetLastError();", "      virCheckDomainReturn(dom, -1);", "     virCheckReadOnlyGoto(dom->conn->flags, error);", "      if (dom->conn->driver->domainGetTime) {", "          int ret = dom->conn->driver->domainGetTime(dom, seconds,", "                                                    nseconds, flags);", "         if (ret < 0)", "             goto error;", "         return ret;", "     }", "     virReportUnsupportedError();", "  error:", "     virDispatchError(dom->conn);", "     return -1;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" hstore_from_arrays(PG_FUNCTION_ARGS)", " {", " \tint32\t\tbuflen;", " \tHStore\t   *out;", " \tPairs\t   *pairs;", " \tDatum\t   *key_datums;", " \tbool\t   *key_nulls;", " \tint\t\t\tkey_count;", " \tDatum\t   *value_datums;", " \tbool\t   *value_nulls;", " \tint\t\t\tvalue_count;", " \tArrayType  *key_array;", " \tArrayType  *value_array;", " \tint\t\t\ti;", " \tif (PG_ARGISNULL(0))", " \t\tPG_RETURN_NULL();", " \tkey_array = PG_GETARG_ARRAYTYPE_P(0);", " \tAssert(ARR_ELEMTYPE(key_array) == TEXTOID);", " \tif (ARR_NDIM(key_array) > 1)", " \t\tereport(ERROR,", " \t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),", " \t\t\t\t errmsg(\"wrong number of array subscripts\")));", " \tdeconstruct_array(key_array,", "  \t\t\t\t\t  TEXTOID, -1, false, 'i',", "  \t\t\t\t\t  &key_datums, &key_nulls, &key_count);", " \tif (key_count > MaxAllocSize / sizeof(Pairs))", " \t\tereport(ERROR,", " \t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),", " \t\t\t  errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",", " \t\t\t\t\t key_count, (int) (MaxAllocSize / sizeof(Pairs)))));", "  \tif (PG_ARGISNULL(1))", " \t{", " \t\tvalue_array = NULL;", " \t\tvalue_count = key_count;", " \t\tvalue_datums = NULL;", " \t\tvalue_nulls = NULL;", " \t}", " \telse", " \t{", " \t\tvalue_array = PG_GETARG_ARRAYTYPE_P(1);", " \t\tAssert(ARR_ELEMTYPE(value_array) == TEXTOID);", " \t\tif (ARR_NDIM(value_array) > 1)", " \t\t\tereport(ERROR,", " \t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),", " \t\t\t\t\t errmsg(\"wrong number of array subscripts\")));", " \t\tif ((ARR_NDIM(key_array) > 0 || ARR_NDIM(value_array) > 0) &&", " \t\t\t(ARR_NDIM(key_array) != ARR_NDIM(value_array) ||", " \t\t\t ARR_DIMS(key_array)[0] != ARR_DIMS(value_array)[0] ||", " \t\t\t ARR_LBOUND(key_array)[0] != ARR_LBOUND(value_array)[0]))", " \t\t\tereport(ERROR,", " \t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),", " \t\t\t\t\t errmsg(\"arrays must have same bounds\")));", " \t\tdeconstruct_array(value_array,", " \t\t\t\t\t\t  TEXTOID, -1, false, 'i',", " \t\t\t\t\t\t  &value_datums, &value_nulls, &value_count);", " \t\tAssert(key_count == value_count);", " \t}", " \tpairs = palloc(key_count * sizeof(Pairs));", " \tfor (i = 0; i < key_count; ++i)", " \t{", " \t\tif (key_nulls[i])", " \t\t\tereport(ERROR,", " \t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),", " \t\t\t\t\t errmsg(\"null value not allowed for hstore key\")));", " \t\tif (!value_nulls || value_nulls[i])", " \t\t{", " \t\t\tpairs[i].key = VARDATA_ANY(key_datums[i]);", " \t\t\tpairs[i].val = NULL;", " \t\t\tpairs[i].keylen = hstoreCheckKeyLen(VARSIZE_ANY_EXHDR(key_datums[i]));", " \t\t\tpairs[i].vallen = 4;", " \t\t\tpairs[i].isnull = true;", " \t\t\tpairs[i].needfree = false;", " \t\t}", " \t\telse", " \t\t{", " \t\t\tpairs[i].key = VARDATA_ANY(key_datums[i]);", " \t\t\tpairs[i].val = VARDATA_ANY(value_datums[i]);", " \t\t\tpairs[i].keylen = hstoreCheckKeyLen(VARSIZE_ANY_EXHDR(key_datums[i]));", " \t\t\tpairs[i].vallen = hstoreCheckValLen(VARSIZE_ANY_EXHDR(value_datums[i]));", " \t\t\tpairs[i].isnull = false;", " \t\t\tpairs[i].needfree = false;", " \t\t}", " \t}", " \tkey_count = hstoreUniquePairs(pairs, key_count, &buflen);", " \tout = hstorePairs(pairs, key_count, buflen);", " \tPG_RETURN_POINTER(out);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int ff_mms_asf_header_parser(MMSContext *mms)", " {", "     uint8_t *p = mms->asf_header;", "     uint8_t *end;", "     int flags, stream_id;", "     mms->stream_num = 0;", "     if (mms->asf_header_size < sizeof(ff_asf_guid) * 2 + 22 ||", "         memcmp(p, ff_asf_header, sizeof(ff_asf_guid))) {", "         av_log(NULL, AV_LOG_ERROR,", "                \"Corrupt stream (invalid ASF header, size=%d)\\n\",", "                mms->asf_header_size);", "         return AVERROR_INVALIDDATA;", "     }", "     end = mms->asf_header + mms->asf_header_size;", "     p += sizeof(ff_asf_guid) + 14;", "     while(end - p >= sizeof(ff_asf_guid) + 8) {", "         uint64_t chunksize;", "         if (!memcmp(p, ff_asf_data_header, sizeof(ff_asf_guid))) {", "             chunksize = 50;  ", "         } else {", "             chunksize = AV_RL64(p + sizeof(ff_asf_guid));", "         }", "         if (!chunksize || chunksize > end - p) {", "             av_log(NULL, AV_LOG_ERROR,", "                    \"Corrupt stream (header chunksize %\"PRId64\" is invalid)\\n\",", "                    chunksize);", "             return AVERROR_INVALIDDATA;", "         }", "         if (!memcmp(p, ff_asf_file_header, sizeof(ff_asf_guid))) {", "             if (end - p > sizeof(ff_asf_guid) * 2 + 68) {", "                 mms->asf_packet_len = AV_RL32(p + sizeof(ff_asf_guid) * 2 + 64);", "                 if (mms->asf_packet_len <= 0 || mms->asf_packet_len > sizeof(mms->in_buffer)) {", "                     av_log(NULL, AV_LOG_ERROR,", "                            \"Corrupt stream (too large pkt_len %d)\\n\",", "                            mms->asf_packet_len);", "                     return AVERROR_INVALIDDATA;", "                  }", "              }", "          } else if (!memcmp(p, ff_asf_stream_header, sizeof(ff_asf_guid))) {", "            flags     = AV_RL16(p + sizeof(ff_asf_guid)*3 + 24);", "            stream_id = flags & 0x7F;", "            if (mms->stream_num < MMS_MAX_STREAMS &&", "                    46 + mms->stream_num * 6 < sizeof(mms->out_buffer)) {", "                mms->streams = av_fast_realloc(mms->streams,", "                                   &mms->nb_streams_allocated,", "                                   (mms->stream_num + 1) * sizeof(MMSStream));", "                if (!mms->streams)", "                    return AVERROR(ENOMEM);", "                mms->streams[mms->stream_num].id = stream_id;", "                mms->stream_num++;", "            } else {", "                av_log(NULL, AV_LOG_ERROR,", "                       \"Corrupt stream (too many A/V streams)\\n\");", "                return AVERROR_INVALIDDATA;", "             if (end - p >= (sizeof(ff_asf_guid) * 3 + 26)) {", "                 flags     = AV_RL16(p + sizeof(ff_asf_guid)*3 + 24);", "                 stream_id = flags & 0x7F;", "                 if (mms->stream_num < MMS_MAX_STREAMS &&", "                         46 + mms->stream_num * 6 < sizeof(mms->out_buffer)) {", "                     mms->streams = av_fast_realloc(mms->streams,", "                                        &mms->nb_streams_allocated,", "                                        (mms->stream_num + 1) * sizeof(MMSStream));", "                     if (!mms->streams)", "                         return AVERROR(ENOMEM);", "                     mms->streams[mms->stream_num].id = stream_id;", "                     mms->stream_num++;", "                 } else {", "                     av_log(NULL, AV_LOG_ERROR,", "                            \"Corrupt stream (too many A/V streams)\\n\");", "                     return AVERROR_INVALIDDATA;", "                 }", "              }", "          } else if (!memcmp(p, ff_asf_ext_stream_header, sizeof(ff_asf_guid))) {", "              if (end - p >= 88) {", "                 int stream_count = AV_RL16(p + 84), ext_len_count = AV_RL16(p + 86);", "                 uint64_t skip_bytes = 88;", "                 while (stream_count--) {", "                     if (end - p < skip_bytes + 4) {", "                         av_log(NULL, AV_LOG_ERROR,", "                                \"Corrupt stream (next stream name length is not in the buffer)\\n\");", "                         return AVERROR_INVALIDDATA;", "                     }", "                     skip_bytes += 4 + AV_RL16(p + skip_bytes + 2);", "                 }", "                 while (ext_len_count--) {", "                     if (end - p < skip_bytes + 22) {", "                         av_log(NULL, AV_LOG_ERROR,", "                                \"Corrupt stream (next extension system info length is not in the buffer)\\n\");", "                         return AVERROR_INVALIDDATA;", "                     }", "                     skip_bytes += 22 + AV_RL32(p + skip_bytes + 18);", "                 }", "                 if (end - p < skip_bytes) {", "                     av_log(NULL, AV_LOG_ERROR,", "                            \"Corrupt stream (the last extension system info length is invalid)\\n\");", "                     return AVERROR_INVALIDDATA;", "                 }", "                 if (chunksize - skip_bytes > 24)", "                     chunksize = skip_bytes;", "              }", "          } else if (!memcmp(p, ff_asf_head1_guid, sizeof(ff_asf_guid))) {", "              chunksize = 46;  ", "             if (chunksize > end - p) {", "                 av_log(NULL, AV_LOG_ERROR,", "                     \"Corrupt stream (header chunksize %\"PRId64\" is invalid)\\n\",", "                     chunksize);", "                 return AVERROR_INVALIDDATA;", "             }", "          }", "          p += chunksize;", "      }", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" _warc_read(struct archive_read *a, const void **buf, size_t *bsz, int64_t *off)", " {", " \tstruct warc_s *w = a->format->data;", " \tconst char *rab;", " \tssize_t nrd;", " \tif (w->cntoff >= w->cntlen) {", " \teof:", " \t\t*buf = NULL;", " \t\t*bsz = 0U;", " \t\t*off = w->cntoff + 4U ;", " \t\tw->unconsumed = 0U;", "  \t\treturn (ARCHIVE_EOF);", "  \t}", " \tif (w->unconsumed) {", " \t\t__archive_read_consume(a, w->unconsumed);", " \t\tw->unconsumed = 0U;", " \t}", "  \trab = __archive_read_ahead(a, 1U, &nrd);", "  \tif (nrd < 0) {", "  \t\t*bsz = 0U;", " \t\treturn (int)nrd;", " \t} else if (nrd == 0) {", " \t\tgoto eof;", " \t} else if ((size_t)nrd > w->cntlen - w->cntoff) {", " \t\tnrd = w->cntlen - w->cntoff;", " \t}", " \t*off = w->cntoff;", " \t*bsz = nrd;", " \t*buf = rab;", " \tw->cntoff += nrd;", " \tw->unconsumed = (size_t)nrd;", " \treturn (ARCHIVE_OK);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" size_t jsuGetFreeStack() {", " #ifdef ARM", "   void *frame = __builtin_frame_address(0);", "   size_t stackPos = (size_t)((char*)frame);", "   size_t stackEnd = (size_t)((char*)&LINKER_END_VAR);", "   if (stackPos < stackEnd) return 0;  ", "   return  stackPos - stackEnd;", " #elif defined(LINUX)", "    char ptr;  ", "    extern void *STACK_BASE;", "    uint32_t count =  (uint32_t)((size_t)STACK_BASE - (size_t)&ptr);", "  return 1000000 - count;  ", "   const uint32_t max_stack = 1000000;  ", "   if (count>max_stack) return 0;", "   return max_stack - count;", "  #else", "    return 1000000;  ", " #endif", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": [" void * adminchild(struct clientparam* param) {", "  int i, res;", "  char * buf;", "  char username[256];", "   char *sb;", "   char *req = NULL;", "   struct printparam pp;", " int contentlen = 0;", "  unsigned contentlen = 0;", "   int isform = 0;", "   pp.inbuf = 0;", "  pp.cp = param;", "  buf = myalloc(LINESIZE);", "  if(!buf) {RETURN(555);}", "  i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, LINESIZE - 1, '\\n', conf.timeouts[STRING_S]);", "  if(i<5 || ((buf[0]!='G' || buf[1]!='E' || buf[2]!='T' || buf[3]!=' ' || buf[4]!='/') && ", " \t   (buf[0]!='P' || buf[1]!='O' || buf[2]!='S' || buf[3]!='T' || buf[4]!=' ' || buf[5]!='/')))", "  {", " \tRETURN(701);", "  }", "  buf[i] = 0;", "  sb = strchr(buf+5, ' ');", "  if(!sb){", " \tRETURN(702);", "  }", "  *sb = 0;", "  req = mystrdup(buf + ((*buf == 'P')? 6 : 5));", "  while((i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, LINESIZE - 1, '\\n', conf.timeouts[STRING_S])) > 2){", " \tbuf[i] = 0;", " \tif(i > 19 && (!strncasecmp(buf, \"authorization\", 13))){", " \t\tsb = strchr(buf, ':');", " \t\tif(!sb)continue;", " \t\t++sb;", " \t\twhile(isspace(*sb))sb++;", " \t\tif(!*sb || strncasecmp(sb, \"basic\", 5)){", " \t\t\tcontinue;", " \t\t}", " \t\tsb+=5;", " \t\twhile(isspace(*sb))sb++;", " \t\ti = de64((unsigned char *)sb, (unsigned char *)username, 255);", " \t\tif(i<=0)continue;", " \t\tusername[i] = 0;", " \t\tsb = strchr((char *)username, ':');", " \t\tif(sb){", " \t\t\t*sb = 0;", " \t\t\tif(param->password)myfree(param->password);", " \t\t\tparam->password = (unsigned char *)mystrdup(sb+1);", " \t\t}", " \t\tif(param->username) myfree(param->username);", " \t\tparam->username = (unsigned char *)mystrdup(username);", " \t\tcontinue;", " \t}", "  \telse if(i > 15 && (!strncasecmp(buf, \"content-length:\", 15))){", "  \t\tsb = buf + 15;", "  \t\twhile(isspace(*sb))sb++;", "\t\tcontentlen = atoi(sb);", " \t\tsscanf(sb, \"%u\", &contentlen);", " \t\tif(contentlen > LINESIZE*1024) contentlen = 0;", "  \t}", "  \telse if(i > 13 && (!strncasecmp(buf, \"content-type:\", 13))){", "  \t\tsb = buf + 13;", " \t\twhile(isspace(*sb))sb++;", " \t\tif(!strncasecmp(sb, \"x-www-form-urlencoded\", 21)) isform = 1;", " \t}", "  }", "  param->operation = ADMIN;", "  if(isform && contentlen) {", " \tprintstr(&pp, \"HTTP/1.0 100 Continue\\r\\n\\r\\n\");", " \tstdpr(&pp, NULL, 0);", "  }", "  res = (*param->srv->authfunc)(param);", "  if(res && res != 10) {", " \tprintstr(&pp, authreq);", " \tRETURN(res);", "  }", "  if(param->srv->singlepacket || param->redirected){", " \tif(*req == 'C') req[1] = 0;", " \telse *req = 0;", "  }", "  sprintf(buf, ok, conf.stringtable?(char *)conf.stringtable[2]:\"3proxy\", conf.stringtable?(char *)conf.stringtable[2]:\"3[APA3A] tiny proxy\", conf.stringtable?(char *)conf.stringtable[3]:\"\");", "  if(*req != 'S') printstr(&pp, buf);", "  switch(*req){", " \tcase 'C':", " \t\tprintstr(&pp, counters);", " \t\t{", " \t\t\tstruct trafcount *cp; ", " \t\t\tint num = 0;", " \t\t\tfor(cp = conf.trafcounter; cp; cp = cp->next, num++){", " \t\t\t int inbuf = 0;", " \t\t\t if(cp->ace && (param->srv->singlepacket || param->redirected)){", " \t\t\t\tif(!ACLmatches(cp->ace, param))continue;", " \t\t\t }", " \t\t\t if(req[1] == 'S' && atoi(req+2) == num) cp->disabled=0;", " \t\t\t if(req[1] == 'D' && atoi(req+2) == num) cp->disabled=1;", " \t\t\t inbuf += sprintf(buf,\t\"<tr>\"", " \t\t\t\t\t\t\"<td>%s</td><td><A HREF=\\'/C%c%d\\'>%s</A></td><td>\",", " \t\t\t\t\t\t(cp->comment)?cp->comment:\"&nbsp;\",", " \t\t\t\t\t\t(cp->disabled)?'S':'D',", " \t\t\t\t\t\tnum,", " \t\t\t\t\t\t(cp->disabled)?\"NO\":\"YES\"", " \t\t\t\t\t);", " \t\t\t if(!cp->ace || !cp->ace->users){", " \t\t\t\tinbuf += sprintf(buf+inbuf, \"<center>ANY</center>\");", " \t\t\t }", " \t\t\t else {", " \t\t\t\tinbuf += printuserlist(buf+inbuf, LINESIZE-800, cp->ace->users, \",<br />\\r\\n\");", " \t\t\t }", " \t\t\t inbuf += sprintf(buf+inbuf, \"</td><td>\");", " \t\t\t if(!cp->ace || !cp->ace->src){", " \t\t\t\tinbuf += sprintf(buf+inbuf, \"<center>ANY</center>\");", " \t\t\t }", " \t\t\t else {", " \t\t\t\tinbuf += printiplist(buf+inbuf, LINESIZE-512, cp->ace->src, \",<br />\\r\\n\");", " \t\t\t }", " \t\t\t inbuf += sprintf(buf+inbuf, \"</td><td>\");", " \t\t\t if(!cp->ace || !cp->ace->dst){", " \t\t\t\tinbuf += sprintf(buf+inbuf, \"<center>ANY</center>\");", " \t\t\t }", " \t\t\t else {", " \t\t\t\tinbuf += printiplist(buf+inbuf, LINESIZE-512, cp->ace->dst, \",<br />\\r\\n\");", " \t\t\t }", " \t\t\t inbuf += sprintf(buf+inbuf, \"</td><td>\");", " \t\t\t if(!cp->ace || !cp->ace->ports){", " \t\t\t\tinbuf += sprintf(buf+inbuf, \"<center>ANY</center>\");", " \t\t\t }", " \t\t\t else {", " \t\t\t\tinbuf += printportlist(buf+inbuf, LINESIZE-128, cp->ace->ports, \",<br />\\r\\n\");", " \t\t\t }", " \t\t\t if(cp->type == NONE) {", " \t\t\t  inbuf += sprintf(buf+inbuf,\t", " \t\t\t\t\t\"</td><td colspan=\\'6\\' align=\\'center\\'>exclude from limitation</td></tr>\\r\\n\"", " \t\t\t\t );", " \t\t\t }", " \t\t\t else {", " \t\t\t  inbuf += sprintf(buf+inbuf,\t", " \t\t\t\t\t\"</td><td>%\"PRINTF_INT64_MODIFIER\"u</td>\"", " \t\t\t\t\t\"<td>MB%s</td>\"", " \t\t\t\t\t\"<td>%\"PRINTF_INT64_MODIFIER\"u</td>\"", " \t\t\t\t\t\"<td>%s</td>\",", " \t\t\t\t cp->traflim64 / (1024 * 1024),", " \t\t\t\t rotations[cp->type],", " \t\t\t\t cp->traf64,", " \t\t\t\t cp->cleared?ctime(&cp->cleared):\"never\"", " \t\t\t\t);", " \t\t\t inbuf += sprintf(buf + inbuf,", " \t\t\t\t\t\"<td>%s</td>\"", " \t\t\t\t\t\"<td>%i</td>\"", " \t\t\t\t\t\"</tr>\\r\\n\",", " \t\t\t\t cp->updated?ctime(&cp->updated):\"never\",", " \t\t\t\t cp->number", " \t\t\t\t);", " \t\t\t }", " \t\t\t printstr(&pp, buf);", " \t\t\t}", " \t\t}", " \t\tprintstr(&pp, counterstail);", " \t\tbreak;", " \tcase 'R':", " \t\tconf.needreload = 1;", " \t\tprintstr(&pp, \"<h3>Reload scheduled</h3>\");", " \t\tbreak;", " \tcase 'S':", " \t\t{", " \t\t\tif(req[1] == 'X'){", " \t\t\t\tprintstr(&pp, style);", " \t\t\t\tbreak;", " \t\t\t}", " \t\t\tprintstr(&pp, xml);", " \t\t\tprintval(conf.services, TYPE_SERVER, 0, &pp);", " \t\t\tprintstr(&pp, postxml);", " \t\t}", " \t\t\tbreak;", " \tcase 'F':", " \t\t{", " \t\t\tFILE *fp;", " \t\t\tchar buf[256];", " \t\t\tfp = confopen();", " \t\t\tif(!fp){", " \t\t\t\tprintstr(&pp, \"<h3><font color=\\\"red\\\">Failed to open config file</font></h3>\");", "  \t\t\t\tbreak;", "  \t\t\t}", "  \t\t\t\tprintstr(&pp, \"<h3>Please be careful editing config file remotely</h3>\");", "\t\t\t\tprintstr(&pp, \"<form method=\\\"POST\\\" action=\\\"/U\\\"><textarea cols=\\\"80\\\" rows=\\\"30\\\" name=\\\"conffile\\\">\");", " \t\t\t\tprintstr(&pp, \"<form method=\\\"POST\\\" action=\\\"/U\\\" enctype=\\\"application/x-www-form-urlencoded\\\"><textarea cols=\\\"80\\\" rows=\\\"30\\\" name=\\\"conffile\\\">\");", "  \t\t\t\twhile(fgets(buf, 256, fp)){", "  \t\t\t\t\tprintstr(&pp, buf);", "  \t\t\t\t}", " \t\t\t\tif(!writable) fclose(fp);", " \t\t\t\tprintstr(&pp, \"</textarea><br><input type=\\\"Submit\\\"></form>\");", " \t\t\tbreak;", "  \t\t}", "  \tcase 'U':", "  \t\t{", "\t\t\tint l=0;", " \t\t\tunsigned l=0;", "  \t\t\tint error = 0;", "\t\t\tif(!writable || fseek(writable, 0, 0)){", " \t\t\tif(!writable || !contentlen || fseek(writable, 0, 0)){", "  \t\t\t\terror = 1;", "  \t\t\t}", "\t\t\twhile((i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, LINESIZE - 1, '+', conf.timeouts[STRING_S])) > 0){", " \t\t\twhile(l < contentlen && (i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, (contentlen - l) > LINESIZE - 1?LINESIZE - 1:contentlen - l, '+', conf.timeouts[STRING_S])) > 0){", "  \t\t\t\tif(i > (contentlen - l)) i = (contentlen - l);", "\t\t\t\tbuf[i] = 0;", "  \t\t\t\tif(!l){", "\t\t\t\t\tif(strncasecmp(buf, \"conffile=\", 9)) error = 1;", " \t\t\t\t\tif(i<9 || strncasecmp(buf, \"conffile=\", 9)) error = 1;", "  \t\t\t\t}", "  \t\t\t\tif(!error){", " \t\t\t\t\tbuf[i] = 0;", "  \t\t\t\t\tdecodeurl((unsigned char *)buf, 1);", "  \t\t\t\t\tfprintf(writable, \"%s\", l? buf : buf + 9);", "  \t\t\t\t}", "  \t\t\t\tl += i;", "\t\t\t\tif(l >= contentlen) break;", "  \t\t\t}", "  \t\t\tif(writable && !error){", "  \t\t\t\tfflush(writable);", " #ifndef _WINCE", " \t\t\t\tftruncate(fileno(writable), ftell(writable));", " #endif", " \t\t\t}", " \t\t\tprintstr(&pp, error?    \"<h3><font color=\\\"red\\\">Config file is not writable</font></h3>Make sure you have \\\"writable\\\" command in configuration file\":", " \t\t\t\t\t\t\"<h3>Configuration updated</h3>\");", " \t\t}", " \t\tbreak;", " \tdefault:", " \t\tprintstr(&pp, (char *)conf.stringtable[WEBBANNERS]);", " \t\tbreak;", "  }", "  if(*req != 'S') printstr(&pp, tail);", " CLEANRET:", "  printstr(&pp, NULL);", "  if(buf) myfree(buf);", "  (*param->srv->logfunc)(param, (unsigned char *)req);", "  if(req)myfree(req);", "  freeparam(param);", "  return (NULL);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" QualifyIpPacket(IPHeader *pIpHeader, ULONG len)", " QualifyIpPacket(IPHeader *pIpHeader, ULONG len, BOOLEAN verifyLength)", "  {", "      tTcpIpPacketParsingResult res;", "      res.value = 0;", "     if (len < 4)", "     {", "         res.ipStatus = ppresNotIP;", "         return res;", "     }", "     UCHAR  ver_len = pIpHeader->v4.ip_verlen;", "     UCHAR  ip_version = (ver_len & 0xF0) >> 4;", "     USHORT ipHeaderSize = 0;", "     USHORT fullLength = 0;", "     res.value = 0;", "     if (ip_version == 4)", "     {", "         if (len < sizeof(IPv4Header))", "         {", "             res.ipStatus = ppresNotIP;", "             return res;", "         }", "         ipHeaderSize = (ver_len & 0xF) << 2;", "         fullLength = swap_short(pIpHeader->v4.ip_length);", "         DPrintf(3, (\"ip_version %d, ipHeaderSize %d, protocol %d, iplen %d, L2 payload length %d\\n\",", "             ip_version, ipHeaderSize, pIpHeader->v4.ip_protocol, fullLength, len));", "         res.ipStatus = (ipHeaderSize >= sizeof(IPv4Header)) ? ppresIPV4 : ppresNotIP;", "         if (res.ipStatus == ppresNotIP)", "         {", "              return res;", "          }", "        if (ipHeaderSize >= fullLength || len < fullLength)", "         if (ipHeaderSize >= fullLength || ( verifyLength && len < fullLength))", "          {", "            DPrintf(2, (\"[%s] - truncated packet - ip_version %d, ipHeaderSize %d, protocol %d, iplen %d, L2 payload length %d\\n\", __FUNCTION__,", "                ip_version, ipHeaderSize, pIpHeader->v4.ip_protocol, fullLength, len));", "             DPrintf(2, (\"[%s] - truncated packet - ip_version %d, ipHeaderSize %d, protocol %d, iplen %d, L2 payload length %d, verify = %s\\n\", __FUNCTION__,", "                 ip_version, ipHeaderSize, pIpHeader->v4.ip_protocol, fullLength, len, (verifyLength ? \"true\" : \"false\")));", "              res.ipCheckSum = ppresIPTooShort;", "              return res;", "          }", "     }", "     else if (ip_version == 6)", "     {", "         if (len < sizeof(IPv6Header))", "         {", "             res.ipStatus = ppresNotIP;", "             return res;", "         }", "         UCHAR nextHeader = pIpHeader->v6.ip6_next_header;", "         BOOLEAN bParsingDone = FALSE;", "         ipHeaderSize = sizeof(pIpHeader->v6);", "         res.ipStatus = ppresIPV6;", "          res.ipCheckSum = ppresCSOK;", "          fullLength = swap_short(pIpHeader->v6.ip6_payload_len);", "          fullLength += ipHeaderSize;", "        if (len < fullLength)", "         if (verifyLength && (len < fullLength))", "          {", "              res.ipStatus = ppresNotIP;", "              return res;", "         }", "         while (nextHeader != 59)", "         {", "             IPv6ExtHeader *pExt;", "             switch (nextHeader)", "             {", "                 case PROTOCOL_TCP:", "                     bParsingDone = TRUE;", "                     res.xxpStatus = ppresXxpKnown;", "                     res.TcpUdp = ppresIsTCP;", "                     res.xxpFull = len >= fullLength ? 1 : 0;", "                     res = ProcessTCPHeader(res, pIpHeader, len, ipHeaderSize);", "                     break;", "                 case PROTOCOL_UDP:", "                     bParsingDone = TRUE;", "                     res.xxpStatus = ppresXxpKnown;", "                     res.TcpUdp = ppresIsUDP;", "                     res.xxpFull = len >= fullLength ? 1 : 0;", "                     res = ProcessUDPHeader(res, pIpHeader, len, ipHeaderSize);", "                     break;", "                 case 0:", "                 case 60:", "                 case 43:", "                 case 44:", "                 case 51:", "                 case 50:", "                 case 135:", "                     if (len >= ((ULONG)ipHeaderSize + 8))", "                     {", "                         pExt = (IPv6ExtHeader *)((PUCHAR)pIpHeader + ipHeaderSize);", "                         nextHeader = pExt->ip6ext_next_header;", "                         ipHeaderSize += 8;", "                         ipHeaderSize += pExt->ip6ext_hdr_len * 8;", "                     }", "                     else", "                     {", "                         DPrintf(0, (\"[%s] ERROR: Break in the middle of ext. headers(len %d, hdr > %d)\\n\", __FUNCTION__, len, ipHeaderSize));", "                         res.ipStatus = ppresNotIP;", "                         bParsingDone = TRUE;", "                     }", "                     break;", "                 default:", "                     res.xxpStatus = ppresXxpOther;", "                     bParsingDone = TRUE;", "                     break;", "             }", "             if (bParsingDone)", "                 break;", "         }", "         if (ipHeaderSize <= MAX_SUPPORTED_IPV6_HEADERS)", "         {", "             DPrintf(3, (\"ip_version %d, ipHeaderSize %d, protocol %d, iplen %d\\n\",", "                 ip_version, ipHeaderSize, nextHeader, fullLength));", "             res.ipHeaderSize = ipHeaderSize;", "         }", "         else", "         {", "             DPrintf(0, (\"[%s] ERROR: IP chain is too large (%d)\\n\", __FUNCTION__, ipHeaderSize));", "             res.ipStatus = ppresNotIP;", "         }", "     }", "     if (res.ipStatus == ppresIPV4)", "     {", "         res.ipHeaderSize = ipHeaderSize;", "         res.IsFragment = (pIpHeader->v4.ip_offset & ~0xC0) != 0;", "         switch (pIpHeader->v4.ip_protocol)", "         {", "             case PROTOCOL_TCP:", "             {", "                 res = ProcessTCPHeader(res, pIpHeader, len, ipHeaderSize);", "             }", "             break;", "         case PROTOCOL_UDP:", "             {", "                 res = ProcessUDPHeader(res, pIpHeader, len, ipHeaderSize);", "             }", "             break;", "         default:", "             res.xxpStatus = ppresXxpOther;", "             break;", "         }", "     }", "     return res;", " }"], "ner_tags": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int putint(jas_stream_t *out, int sgnd, int prec, long val)", " {", "  \tint n;", "  \tint c;", "  \tbool s;", "\tulong tmp;", " \tjas_ulong tmp;", "  \tassert((!sgnd && prec >= 1) || (sgnd && prec >= 2));", "  \tif (sgnd) {", "  \t\tval = encode_twos_comp(val, prec);", " \t}", " \tassert(val >= 0);", " \tval &= (1 << prec) - 1;", " \tn = (prec + 7) / 8;", " \twhile (--n >= 0) {", " \t\tc = (val >> (n * 8)) & 0xff;", " \t\tif (jas_stream_putc(out, c) != c)", " \t\t\treturn -1;", " \t}", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" sec_recv(RD_BOOL * is_fastpath)", " {", " \tuint8 fastpath_hdr, fastpath_flags;", "  \tuint16 sec_flags;", "  \tuint16 channel;", "  \tSTREAM s;", " \tstruct stream packet;", "  \twhile ((s = mcs_recv(&channel, is_fastpath, &fastpath_hdr)) != NULL)", "  \t{", " \t\tpacket = *s;", "  \t\tif (*is_fastpath == True)", "  \t\t{", "  \t\t\tfastpath_flags = (fastpath_hdr & 0xC0) >> 6;", "  \t\t\tif (fastpath_flags & FASTPATH_OUTPUT_ENCRYPTED)", "  \t\t\t{", " \t\t\t\tif (!s_check_rem(s, 8)) {", " \t\t\t\t\trdp_protocol_error(\"sec_recv(), consume fastpath signature from stream would overrun\", &packet);", " \t\t\t\t}", "  \t\t\t\tin_uint8s(s, 8);\t ", "  \t\t\t\tsec_decrypt(s->p, s->end - s->p);", "  \t\t\t}", " \t\t\treturn s;", " \t\t}", " \t\tif (g_encryption || (!g_licence_issued && !g_licence_error_result))", " \t\t{", " \t\t\tin_uint16_le(s, sec_flags);", " \t\t\tin_uint8s(s, 2);\t ", " \t\t\tif (g_encryption)", "  \t\t\t{", "  \t\t\t\tif (sec_flags & SEC_ENCRYPT)", "  \t\t\t\t{", " \t\t\t\t\tif (!s_check_rem(s, 8)) {", " \t\t\t\t\t\trdp_protocol_error(\"sec_recv(), consume encrypt signature from stream would overrun\", &packet);", " \t\t\t\t\t}", "  \t\t\t\t\tin_uint8s(s, 8);\t ", "  \t\t\t\t\tsec_decrypt(s->p, s->end - s->p);", "  \t\t\t\t}", " \t\t\t\tif (sec_flags & SEC_LICENSE_PKT)", " \t\t\t\t{", " \t\t\t\t\tlicence_process(s);", " \t\t\t\t\tcontinue;", " \t\t\t\t}", " \t\t\t\tif (sec_flags & SEC_REDIRECTION_PKT)", "  \t\t\t\t{", "  \t\t\t\t\tuint8 swapbyte;", " \t\t\t\t\tif (!s_check_rem(s, 8)) {", " \t\t\t\t\t\trdp_protocol_error(\"sec_recv(), consume redirect signature from stream would overrun\", &packet);", " \t\t\t\t\t}", "  \t\t\t\t\tin_uint8s(s, 8);\t ", "  \t\t\t\t\tsec_decrypt(s->p, s->end - s->p);", " \t\t\t\t\tif (s->p[0] == 0 && s->p[1] == 4)", " \t\t\t\t\t{", " \t\t\t\t\t\tswapbyte = s->p[0];", " \t\t\t\t\t\ts->p[0] = s->p[2];", " \t\t\t\t\t\ts->p[2] = swapbyte;", " \t\t\t\t\t\tswapbyte = s->p[1];", " \t\t\t\t\t\ts->p[1] = s->p[3];", " \t\t\t\t\t\ts->p[3] = swapbyte;", " \t\t\t\t\t\tswapbyte = s->p[2];", " \t\t\t\t\t\ts->p[2] = s->p[3];", " \t\t\t\t\t\ts->p[3] = swapbyte;", " \t\t\t\t\t}", " \t\t\t\t}", " \t\t\t}", " \t\t\telse", " \t\t\t{", " \t\t\t\tif (sec_flags & SEC_LICENSE_PKT)", " \t\t\t\t{", " \t\t\t\t\tlicence_process(s);", " \t\t\t\t\tcontinue;", " \t\t\t\t}", " \t\t\t\ts->p -= 4;", " \t\t\t}", " \t\t}", " \t\tif (channel != MCS_GLOBAL_CHANNEL)", " \t\t{", " \t\t\tchannel_process(s, channel);", " \t\t\tcontinue;", " \t\t}", " \t\treturn s;", " \t}", " \treturn NULL;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int get_cox(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c)", " {", "     uint8_t byte;", "     if (bytestream2_get_bytes_left(&s->g) < 5)", "         return AVERROR_INVALIDDATA;", "     c->nreslevels = bytestream2_get_byteu(&s->g) + 1;", "     if (c->nreslevels >= JPEG2000_MAX_RESLEVELS) {", "         av_log(s->avctx, AV_LOG_ERROR, \"nreslevels %d is invalid\\n\", c->nreslevels);", "         return AVERROR_INVALIDDATA;", "     }", "     if (c->nreslevels < s->reduction_factor)", "         c->nreslevels2decode = 1;", "     else", "         c->nreslevels2decode = c->nreslevels - s->reduction_factor;", "     c->log2_cblk_width  = (bytestream2_get_byteu(&s->g) & 15) + 2;  ", "     c->log2_cblk_height = (bytestream2_get_byteu(&s->g) & 15) + 2;  ", "     if (c->log2_cblk_width > 10 || c->log2_cblk_height > 10 ||", "         c->log2_cblk_width + c->log2_cblk_height > 12) {", "         av_log(s->avctx, AV_LOG_ERROR, \"cblk size invalid\\n\");", "          return AVERROR_INVALIDDATA;", "      }", "     if (c->log2_cblk_width > 6 || c->log2_cblk_height > 6) {", "         avpriv_request_sample(s->avctx, \"cblk size > 64\");", "         return AVERROR_PATCHWELCOME;", "     }", "      c->cblk_style = bytestream2_get_byteu(&s->g);", "      if (c->cblk_style != 0) {  ", "          av_log(s->avctx, AV_LOG_WARNING, \"extra cblk styles %X\\n\", c->cblk_style);", "     }", "     c->transform = bytestream2_get_byteu(&s->g);  ", "     if ((s->avctx->flags & CODEC_FLAG_BITEXACT) && (c->transform == FF_DWT97))", "         c->transform = FF_DWT97_INT;", "     if (c->csty & JPEG2000_CSTY_PREC) {", "         int i;", "         for (i = 0; i < c->nreslevels; i++) {", "             byte = bytestream2_get_byte(&s->g);", "             c->log2_prec_widths[i]  =  byte       & 0x0F;     ", "             c->log2_prec_heights[i] = (byte >> 4) & 0x0F;     ", "         }", "     } else {", "         memset(c->log2_prec_widths , 15, sizeof(c->log2_prec_widths ));", "         memset(c->log2_prec_heights, 15, sizeof(c->log2_prec_heights));", "     }", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" DecodeNumberField(int len, char *str, int fmask,", " \t\t\t\t  int *tmask, struct tm * tm, fsec_t *fsec, int *is2digits)", " {", " \tchar\t   *cp;", "  \tif ((cp = strchr(str, '.')) != NULL)", "  \t{", "  #ifdef HAVE_INT64_TIMESTAMP", "\t\tchar\t\tfstr[MAXDATELEN + 1];", " \t\tchar\t\tfstr[7];", " \t\tint\t\t\ti;", " \t\tcp++;", "\t\tstrcpy(fstr, (cp + 1));", "\t\tstrcpy(fstr + strlen(fstr), \"000000\");", "\t\t*(fstr + 6) = '\\0';", " \t\tfor (i = 0; i < 6; i++)", " \t\t\tfstr[i] = *cp != '\\0' ? *cp++ : '0';", " \t\tfstr[i] = '\\0';", "  \t\t*fsec = strtol(fstr, NULL, 10);", "  #else", "  \t\t*fsec = strtod(cp, NULL);", " #endif", " \t\t*cp = '\\0';", " \t\tlen = strlen(str);", " \t}", " \telse if ((fmask & DTK_DATE_M) != DTK_DATE_M)", " \t{", " \t\tif (len == 8)", " \t\t{", " \t\t\t*tmask = DTK_DATE_M;", " \t\t\ttm->tm_mday = atoi(str + 6);", " \t\t\t*(str + 6) = '\\0';", " \t\t\ttm->tm_mon = atoi(str + 4);", " \t\t\t*(str + 4) = '\\0';", " \t\t\ttm->tm_year = atoi(str + 0);", " \t\t\treturn DTK_DATE;", " \t\t}", " \t\telse if (len == 6)", " \t\t{", " \t\t\t*tmask = DTK_DATE_M;", " \t\t\ttm->tm_mday = atoi(str + 4);", " \t\t\t*(str + 4) = '\\0';", " \t\t\ttm->tm_mon = atoi(str + 2);", " \t\t\t*(str + 2) = '\\0';", " \t\t\ttm->tm_year = atoi(str + 0);", " \t\t\t*is2digits = TRUE;", " \t\t\treturn DTK_DATE;", " \t\t}", " \t\telse if (len == 5)", " \t\t{", " \t\t\t*tmask = DTK_DATE_M;", " \t\t\ttm->tm_mday = atoi(str + 2);", " \t\t\t*(str + 2) = '\\0';", " \t\t\ttm->tm_mon = 1;", " \t\t\ttm->tm_year = atoi(str + 0);", " \t\t\t*is2digits = TRUE;", " \t\t\treturn DTK_DATE;", " \t\t}", " \t}", " \tif ((fmask & DTK_TIME_M) != DTK_TIME_M)", " \t{", " \t\tif (len == 6)", " \t\t{", " \t\t\t*tmask = DTK_TIME_M;", " \t\t\ttm->tm_sec = atoi(str + 4);", " \t\t\t*(str + 4) = '\\0';", " \t\t\ttm->tm_min = atoi(str + 2);", " \t\t\t*(str + 2) = '\\0';", " \t\t\ttm->tm_hour = atoi(str + 0);", " \t\t\treturn DTK_TIME;", " \t\t}", " \t\telse if (len == 4)", " \t\t{", " \t\t\t*tmask = DTK_TIME_M;", " \t\t\ttm->tm_sec = 0;", " \t\t\ttm->tm_min = atoi(str + 2);", " \t\t\t*(str + 2) = '\\0';", " \t\t\ttm->tm_hour = atoi(str + 0);", " \t\t\treturn DTK_TIME;", " \t\t}", " \t}", " \treturn -1;", " }\t "], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" SafeAlphaCompositeSolidMask_nx8x8888(", "     CARD8      op,", "     PicturePtr pSrc,", "     PicturePtr pMask,", "     PicturePtr pDst,", "     INT16      xSrc,", "     INT16      ySrc,", "     INT16      xMask,", "     INT16      yMask,", "     INT16      xDst,", "     INT16      yDst,", "     CARD16     width,", "     CARD16     height)", " {", "     CARD32\tsrc, srca;", "     CARD32\t*dstLine, *dst, d, dstMask;", "     CARD8\t*maskLine, *mask, m;", "     FbStride\tdstStride, maskStride;", "     CARD16\tw;", "     fbComposeGetSolid(pSrc, src, pDst->format);", "     dstMask = FbFullMask (pDst->pDrawable->depth);", "     srca = src >> 24;", "     if (src == 0)", " \treturn;", "     fbComposeGetStart (pDst, xDst, yDst, CARD32, dstStride, dstLine, 1);", "     fbComposeGetStart (pMask, xMask, yMask, CARD8, maskStride, maskLine, 1);", "     if (dstMask == FB_ALLONES && pDst->pDrawable->bitsPerPixel == 32 &&", "         width * height > rootless_CompositePixels_threshold &&", "         SCREENREC(pDst->pDrawable->pScreen)->imp->CompositePixels)", "     {", " \tvoid *srcp[2], *destp[2];", " \tunsigned int dest_rowbytes[2];", " \tunsigned int fn;", " \tsrcp[0] = &src; srcp[1] = &src;", " \tdestp[0] = dstLine; destp[1] = dstLine;", " \tdest_rowbytes[0] = dstStride * 4; dest_rowbytes[1] = dest_rowbytes[0];", " \tfn = RL_COMPOSITE_FUNCTION(RL_COMPOSITE_OVER, RL_DEPTH_ARGB8888,", "                                    RL_DEPTH_A8, RL_DEPTH_ARGB8888);", " \tif (SCREENREC(pDst->pDrawable->pScreen)->imp->CompositePixels(", "                 width, height, fn, srcp, NULL,", "                 maskLine, maskStride,", "                 destp, dest_rowbytes) == Success)", " \t{", " \t    return;", " \t}", "     }", "     while (height--)", "     {", " \tdst = dstLine;", " \tdstLine += dstStride;", " \tmask = maskLine;", " \tmaskLine += maskStride;", " \tw = width;", " \twhile (w--)", " \t{", "  }", "  void", "SafeAlphaComposite (CARD8      op,", "    PicturePtr      pSrc,", "    PicturePtr      pMask,", "    PicturePtr      pDst,", "    INT16           xSrc,", "    INT16           ySrc,", "    INT16           xMask,", "    INT16           yMask,", "    INT16           xDst,", "    INT16           yDst,", "    CARD16          width,", "    CARD16          height)", " SafeAlphaComposite (CARD8           op,", " \t\t    PicturePtr      pSrc,", " \t\t    PicturePtr      pMask,", " \t\t    PicturePtr      pDst,", " \t\t    INT16           xSrc,", " \t\t    INT16           ySrc,", " \t\t    INT16           xMask,", " \t\t    INT16           yMask,", " \t\t    INT16           xDst,", " \t\t    INT16           yDst,", " \t\t    CARD16          width,", " \t\t    CARD16          height)", "  {", "    RegionRec\t    region;", "    int\t\t    n;", "    BoxPtr\t    pbox;", "    CompositeFunc   func = 0;", "    Bool\t    srcRepeat = pSrc->repeat;", "    Bool\t    maskRepeat = FALSE;", "    Bool            srcAlphaMap = pSrc->alphaMap != 0;", "    Bool\t    maskAlphaMap = FALSE;", "    Bool            dstAlphaMap = pDst->alphaMap != 0;", "    int\t\t    x_msk, y_msk, x_src, y_src, x_dst, y_dst;", "    int\t\t    w, h, w_this, h_this;", "    int\t\t    dstDepth = pDst->pDrawable->depth;", "    int\t\t    oldFormat = pDst->format;", "    xDst += pDst->pDrawable->x;", "    yDst += pDst->pDrawable->y;", "    xSrc += pSrc->pDrawable->x;", "    ySrc += pSrc->pDrawable->y;", "    if (pMask)", "    {", "\txMask += pMask->pDrawable->x;", "\tyMask += pMask->pDrawable->y;", "\tmaskRepeat = pMask->repeat;", "\tmaskAlphaMap = pMask->alphaMap != 0;", "    }", "     int oldDepth = pDst->pDrawable->depth;", "     int oldFormat = pDst->format;", "     int\t\t    n;", "      {", "          pDst->format = PICT_a8r8g8b8;", "      }", "    if (!pSrc->transform && !(pMask && pMask->transform))", "    if (!maskAlphaMap && !srcAlphaMap && !dstAlphaMap)", "    switch (op) {", "    case PictOpSrc:", "#ifdef USE_MMX", "\tif (!pMask && pSrc->format == pDst->format &&", "\t    pSrc->pDrawable != pDst->pDrawable)", "\t{", "\t    func = fbCompositeCopyAreammx;", "\t}", "#endif", "\tbreak;", "    case PictOpOver:", "\tif (pMask)", "\t{", "\t    if (srcRepeat && ", "\t\tpSrc->pDrawable->width == 1 &&", "\t\tpSrc->pDrawable->height == 1)", "\t    {", "\t\tsrcRepeat = FALSE;", "\t\tif (PICT_FORMAT_COLOR(pSrc->format)) {", "\t\t    switch (pMask->format) {", "\t\t    case PICT_a8:", "\t\t\tswitch (pDst->format) {", "\t\t\tcase PICT_r5g6b5:", "\t\t\tcase PICT_b5g6r5:", "#ifdef USE_MMX", "\t\t\t    if (fbHaveMMX())", "\t\t\t\tfunc = fbCompositeSolidMask_nx8x0565mmx;", "\t\t\t    else", "#endif", "\t\t\t    func = fbCompositeSolidMask_nx8x0565;", "\t\t\t    break;", "\t\t\tcase PICT_r8g8b8:", "\t\t\tcase PICT_b8g8r8:", "\t\t\t    func = fbCompositeSolidMask_nx8x0888;", "\t\t\t    break;", "\t\t\tcase PICT_a8r8g8b8:", "\t\t\tcase PICT_x8r8g8b8:", "\t\t\tcase PICT_a8b8g8r8:", "\t\t\tcase PICT_x8b8g8r8:", "\t\t\t    func = SafeAlphaCompositeSolidMask_nx8x8888;", "\t\t\t    break;", "\t\t\t}", "\t\t\tbreak;", "\t\t    case PICT_a8r8g8b8:", "\t\t\tif (pMask->componentAlpha) {", "\t\t\t    switch (pDst->format) {", "\t\t\t    case PICT_a8r8g8b8:", "\t\t\t    case PICT_x8r8g8b8:", "#ifdef USE_MMX", "\t\t\t\tif (fbHaveMMX())", "\t\t\t\t    func = fbCompositeSolidMask_nx8888x8888Cmmx;", "\t\t\t\telse", "#endif", "\t\t\t\tfunc = fbCompositeSolidMask_nx8888x8888C;", "\t\t\t\tbreak;", "\t\t\t    case PICT_r5g6b5:", "#ifdef USE_MMX", "\t\t\t\tif (fbHaveMMX())", "\t\t\t\t    func = fbCompositeSolidMask_nx8888x0565Cmmx;", "\t\t\t\telse", "#endif", "\t\t\t\tfunc = fbCompositeSolidMask_nx8888x0565C;", "\t\t\t\tbreak;", "\t\t\t    }", "\t\t\t}", "\t\t\tbreak;", "\t\t    case PICT_a8b8g8r8:", "\t\t\tif (pMask->componentAlpha) {", "\t\t\t    switch (pDst->format) {", "\t\t\t    case PICT_a8b8g8r8:", "\t\t\t    case PICT_x8b8g8r8:", "#ifdef USE_MMX", "\t\t\t\tif (fbHaveMMX())", "\t\t\t\t    func = fbCompositeSolidMask_nx8888x8888Cmmx;", "\t\t\t\telse", "#endif", "\t\t\t\tfunc = fbCompositeSolidMask_nx8888x8888C;", "\t\t\t\tbreak;", "\t\t\t    case PICT_b5g6r5:", "#ifdef USE_MMX", "\t\t\t\tif (fbHaveMMX())", "\t\t\t\t    func = fbCompositeSolidMask_nx8888x0565Cmmx;", "\t\t\t\telse", "#endif", "\t\t\t\tfunc = fbCompositeSolidMask_nx8888x0565C;", "\t\t\t\tbreak;", "\t\t\t    }", "\t\t\t}", "\t\t\tbreak;", "\t\t    case PICT_a1:", "\t\t\tswitch (pDst->format) {", "\t\t\tcase PICT_r5g6b5:", "\t\t\tcase PICT_b5g6r5:", "\t\t\tcase PICT_r8g8b8:", "\t\t\tcase PICT_b8g8r8:", "\t\t\tcase PICT_a8r8g8b8:", "\t\t\tcase PICT_x8r8g8b8:", "\t\t\tcase PICT_a8b8g8r8:", "\t\t\tcase PICT_x8b8g8r8:", "\t\t\t    func = fbCompositeSolidMask_nx1xn;", "\t\t\t    break;", "\t\t\t}", "\t\t\tbreak;", "\t\t    }", "\t\t}", "\t    }", "\t    else  ", "\t    {", "\t\tif (pSrc->pDrawable == pMask->pDrawable &&", "\t\t    xSrc == xMask && ySrc == yMask &&", "\t\t    !pMask->componentAlpha)", "\t\t{", "\t\t    switch (pSrc->format) {", "\t\t    case PICT_x8b8g8r8:", "\t\t\tswitch (pMask->format) {", "\t\t\tcase PICT_a8r8g8b8:", "\t\t\tcase PICT_a8b8g8r8:", "\t\t\t    switch (pDst->format) {", "\t\t\t    case PICT_a8r8g8b8:", "\t\t\t    case PICT_x8r8g8b8:", "#ifdef USE_MMX", "\t\t\t\tif (fbHaveMMX())", "\t\t\t\t    func = fbCompositeSrc_8888RevNPx8888mmx;", "#endif", "\t\t\t\tbreak;", "\t\t\t    case PICT_r5g6b5:", "#ifdef USE_MMX", "\t\t\t\tif (fbHaveMMX())", "\t\t\t\t    func = fbCompositeSrc_8888RevNPx0565mmx;", "#endif", "\t\t\t\tbreak;", "\t\t\t    }", "\t\t\t    break;", "\t\t\t}", "\t\t\tbreak;", "\t\t    case PICT_x8r8g8b8:", "\t\t\tswitch (pMask->format) {", "\t\t\tcase PICT_a8r8g8b8:", "\t\t\tcase PICT_a8b8g8r8:", "\t\t\t    switch (pDst->format) {", "\t\t\t    case PICT_a8b8g8r8:", "\t\t\t    case PICT_x8b8g8r8:", "#ifdef USE_MMX", "\t\t\t\tif (fbHaveMMX())", "\t\t\t\t    func = fbCompositeSrc_8888RevNPx8888mmx;", "#endif", "\t\t\t\tbreak;", "\t\t\t    case PICT_r5g6b5:", "#ifdef USE_MMX", "\t\t\t\tif (fbHaveMMX())", "\t\t\t\t    func = fbCompositeSrc_8888RevNPx0565mmx;", "#endif", "\t\t\t\tbreak;", "\t\t\t    }", "\t\t\t    break;", "\t\t\t}", "\t\t\tbreak;", "\t\t    }", "\t\t    break;", "\t}", "\telse", "\t{", "\t\t    if (maskRepeat &&", "\t\t\tpMask->pDrawable->width == 1 &&", "\t\t\tpMask->pDrawable->height == 1)", "\t\t    {", "\t\t\tif (pSrc->format == PICT_x8r8g8b8 &&", "\t\t\t    pDst->format == PICT_x8r8g8b8 &&", "\t\t\t    pMask->format == PICT_a8)", "\t\t\t{", "#ifdef USE_MMX", "\t\t\t    if (fbHaveMMX())", "\t\t\t\tfunc = fbCompositeSrc_8888x8x8888mmx;", "#endif", "\t\t\t}", "\t\t    }", "\t\t}", "\t    }", "\t}", "\telse  ", "\t{", "\t    if (srcRepeat &&", "\t\tpSrc->pDrawable->width == 1 &&", "\t\tpSrc->pDrawable->height == 1)", "\t    {", "\t    switch (pSrc->format) {", "\t    case PICT_a8r8g8b8:", "\t\t    switch (pDst->format) {", "\t\t    case PICT_a8r8g8b8:", "\t    case PICT_x8r8g8b8:", "#ifdef USE_MMX", "\t\t\tif (fbHaveMMX())", "\t\t\t{", "\t\t\t    srcRepeat = FALSE;", "\t\t\t    func = fbCompositeSolid_nx8888mmx;", "\t\t\t}", "#endif", "\t\t\tbreak;", "\t\t    case PICT_r5g6b5:", "#ifdef USE_MMX", "\t\t\tif (fbHaveMMX())", "\t\t\t{", "\t\t\t    srcRepeat = FALSE;", "\t\t\t    func = fbCompositeSolid_nx0565mmx;", "\t\t\t}", "#endif", "\t\t\tbreak;", "\t\t    }", "\t\t    break;", "\t\t}", "\t    }", "\t    else", "\t    {", "\t\tswitch (pSrc->format) {", "\t\tcase PICT_a8r8g8b8:", "\t\tswitch (pDst->format) {", "\t\tcase PICT_a8r8g8b8:", "\t\tcase PICT_x8r8g8b8:", "#ifdef USE_MMX", "\t\t\tif (fbHaveMMX())", "\t\t\t    func = fbCompositeSrc_8888x8888mmx;", "\t\t\telse", "#endif", "\t\t    func = fbCompositeSrc_8888x8888;", "\t\t    break;", "\t\tcase PICT_r8g8b8:", "\t\t    func = fbCompositeSrc_8888x0888;", "\t\t    break;", "\t\tcase PICT_r5g6b5:", "\t\t    func = fbCompositeSrc_8888x0565;", "\t\t    break;", "\t\t}", "\t\tbreak;", "\t\tcase PICT_x8r8g8b8:", "\t\t    switch (pDst->format) {", "\t\t    case PICT_a8r8g8b8:", "\t\t    case PICT_x8r8g8b8:", "#ifdef USE_MMX", "\t\t\tif (fbHaveMMX())", "\t\t\t    func = fbCompositeCopyAreammx;", "#endif", "\t\t\tbreak;", "\t\t    }", "\t\tcase PICT_x8b8g8r8:", "\t\t    switch (pDst->format) {", "\t    case PICT_a8b8g8r8:", "\t    case PICT_x8b8g8r8:", "#ifdef USE_MMX", "\t\t\tif (fbHaveMMX())", "\t\t\t    func = fbCompositeCopyAreammx;", "#endif", "\t\t\tbreak;", "\t\t    }", "\t\t    break;", "\t\tcase PICT_a8b8g8r8:", "\t\tswitch (pDst->format) {", "\t\tcase PICT_a8b8g8r8:", "\t\tcase PICT_x8b8g8r8:", "#ifdef USE_MMX", "\t\t\tif (fbHaveMMX())", "\t\t\t    func = fbCompositeSrc_8888x8888mmx;", "\t\t\telse", "#endif", "\t\t    func = fbCompositeSrc_8888x8888;", "\t\t    break;", "\t\tcase PICT_b8g8r8:", "\t\t    func = fbCompositeSrc_8888x0888;", "\t\t    break;", "\t\tcase PICT_b5g6r5:", "\t\t    func = fbCompositeSrc_8888x0565;", "\t\t    break;", "\t\t}", "\t\tbreak;", "\t    case PICT_r5g6b5:", "\t\tswitch (pDst->format) {", "\t\tcase PICT_r5g6b5:", "\t\t    func = fbCompositeSrc_0565x0565;", "\t\t    break;", "\t\t}", "\t\tbreak;", "\t    case PICT_b5g6r5:", "\t\tswitch (pDst->format) {", "\t\tcase PICT_b5g6r5:", "\t\t    func = fbCompositeSrc_0565x0565;", "\t\t    break;", "\t\t}", "\t\tbreak;", "\t    }", "\t}", "\t}", "\tbreak;", "    case PictOpAdd:", "\tif (pMask == 0)", "\t{", "\t    switch (pSrc->format) {", "\t    case PICT_a8r8g8b8:", "\t\tswitch (pDst->format) {", "\t\tcase PICT_a8r8g8b8:", "#ifdef USE_MMX", "\t\t    if (fbHaveMMX())", "\t\t\tfunc = fbCompositeSrcAdd_8888x8888mmx;", "\t\t    else", "#endif", "\t\t    func = fbCompositeSrcAdd_8888x8888;", "\t\t    break;", "\t\t}", "\t\tbreak;", "\t    case PICT_a8b8g8r8:", "\t\tswitch (pDst->format) {", "\t\tcase PICT_a8b8g8r8:", "#ifdef USE_MMX", "\t\t    if (fbHaveMMX())", "\t\t\tfunc = fbCompositeSrcAdd_8888x8888mmx;", "\t\t    else", "#endif", "\t\t    func = fbCompositeSrcAdd_8888x8888;", "\t\t    break;", "\t\t}", "\t\tbreak;", "\t    case PICT_a8:", "\t\tswitch (pDst->format) {", "\t\tcase PICT_a8:", "#ifdef USE_MMX", "\t\t    if (fbHaveMMX())", "\t\t\tfunc = fbCompositeSrcAdd_8000x8000mmx;", "\t\t    else", "#endif", "\t\t    func = fbCompositeSrcAdd_8000x8000;", "\t\t    break;", "\t\t}", "\t\tbreak;", "\t    case PICT_a1:", "\t\tswitch (pDst->format) {", "\t\tcase PICT_a1:", "\t\t    func = fbCompositeSrcAdd_1000x1000;", "\t\t    break;", "\t\t}", "\t\tbreak;", "\t    }", "\t}", "\tbreak;", "    }", "    if (!func) {", "        fbCompositeGeneral(op, pSrc, pMask, pDst, xSrc, ySrc, xMask, yMask, xDst, yDst, width, height);", "        pDst->pDrawable->depth = dstDepth;", "        pDst->format = oldFormat;", "        return;", "     if (pSrc->pDrawable && pMask->pDrawable &&", " \t!pSrc->transform && !pMask->transform &&", " \t!pSrc->alphaMap && !pMask->alphaMap &&", " \t!pMask->repeat && !pMask->componentAlpha && !pDst->alphaMap &&", " \tpMask->format == PICT_a8 &&", " \tpSrc->repeatType == RepeatNormal && ", " \tpSrc->pDrawable->width == 1 &&", " \tpSrc->pDrawable->height == 1 &&", " \t(pDst->format == PICT_a8r8g8b8 ||", " \t pDst->format == PICT_x8r8g8b8 ||", " \t pDst->format == PICT_a8b8g8r8 ||", " \t pDst->format == PICT_x8b8g8r8))", "     {", " \tfbWalkCompositeRegion (op, pSrc, pMask, pDst,", " \t\t\t       xSrc, ySrc, xMask, yMask, xDst, yDst,", " \t\t\t       width, height,", " \t\t\t       TRUE  ,", " \t\t\t       FALSE  ,", " \t\t\t       SafeAlphaCompositeSolidMask_nx8x8888);", "      }", "    if (!miComputeCompositeRegion (&region,", " \t\t\t\t   pSrc,", " \t\t\t\t   pMask,", " \t\t\t\t   pDst,", " \t\t\t\t   xSrc,", " \t\t\t\t   ySrc,", " \t\t\t\t   xMask,", " \t\t\t\t   yMask,", " \t\t\t\t   xDst,", " \t\t\t\t   yDst,", " \t\t\t\t   width,", "                                   height))", "        return;", "    n = REGION_NUM_RECTS (&region);", "    pbox = REGION_RECTS (&region);", "    while (n--)", "     else", "      {", "\th = pbox->y2 - pbox->y1;", "\ty_src = pbox->y1 - yDst + ySrc;", "\ty_msk = pbox->y1 - yDst + yMask;", "\ty_dst = pbox->y1;", "\twhile (h)", "\t{", "\t    h_this = h;", "\t    w = pbox->x2 - pbox->x1;", "\t    x_src = pbox->x1 - xDst + xSrc;", "\t    x_msk = pbox->x1 - xDst + xMask;", "\t    x_dst = pbox->x1;", "\t    if (maskRepeat)", "\t    {", "\t\ty_msk = mod (y_msk, pMask->pDrawable->height);", "\t\tif (h_this > pMask->pDrawable->height - y_msk)", "\t\t    h_this = pMask->pDrawable->height - y_msk;", "\t    }", "\t    if (srcRepeat)", "\t    {", "\t\ty_src = mod (y_src, pSrc->pDrawable->height);", "\t\tif (h_this > pSrc->pDrawable->height - y_src)", "\t\t    h_this = pSrc->pDrawable->height - y_src;", "\t    }", "\t    while (w)", "\t    {", "\t\tw_this = w;", "\t\tif (maskRepeat)", "\t\t{", "\t\t    x_msk = mod (x_msk, pMask->pDrawable->width);", "\t\t    if (w_this > pMask->pDrawable->width - x_msk)", "\t\t\tw_this = pMask->pDrawable->width - x_msk;", "\t\t}", "\t\tif (srcRepeat)", "\t\t{", "\t\t    x_src = mod (x_src, pSrc->pDrawable->width);", "\t\t    if (w_this > pSrc->pDrawable->width - x_src)", "\t\t\tw_this = pSrc->pDrawable->width - x_src;", "\t\t}", "\t\t(*func) (op, pSrc, pMask, pDst,", "\t\t\t x_src, y_src, x_msk, y_msk, x_dst, y_dst,", "\t\t\t w_this, h_this);", "\t\tw -= w_this;", "\t\tx_src += w_this;", "\t\tx_msk += w_this;", "\t\tx_dst += w_this;", "\t    }", "\t    h -= h_this;", "\t    y_src += h_this;", "\t    y_msk += h_this;", "\t    y_dst += h_this;", "\t}", "\tpbox++;", " \tfbComposite (op, pSrc, pMask, pDst,", " \t\t     xSrc, ySrc, xMask, yMask, xDst, yDst, width, height);", "      }", "    REGION_UNINIT (pDst->pDrawable->pScreen, &region);", "    pDst->pDrawable->depth = dstDepth;", "     pDst->pDrawable->depth = oldDepth;", "      pDst->format = oldFormat;", "  }", "     }", "     if (oldFormat == PICT_x8r8g8b8)", "     {", "         pDst->format = PICT_a8r8g8b8;", "     }", "     if (!pSrc->transform && !(pMask && pMask->transform))", "     if (!maskAlphaMap && !srcAlphaMap && !dstAlphaMap)", "     switch (op) {", "     case PictOpSrc:", " #ifdef USE_MMX", " \tif (!pMask && pSrc->format == pDst->format &&", " \t    pSrc->pDrawable != pDst->pDrawable)", " \t{", " \t    func = fbCompositeCopyAreammx;", " \t}", " #endif", " \tbreak;", "     case PictOpOver:", " \tif (pMask)", " \t{", " \t    if (srcRepeat && ", " \t\tpSrc->pDrawable->width == 1 &&", " \t\tpSrc->pDrawable->height == 1)", " \t    {", " \t\tsrcRepeat = FALSE;", " \t\tif (PICT_FORMAT_COLOR(pSrc->format)) {", " \t\t    switch (pMask->format) {", " \t\t    case PICT_a8:", " \t\t\tswitch (pDst->format) {", " \t\t\tcase PICT_r5g6b5:", " \t\t\tcase PICT_b5g6r5:", " #ifdef USE_MMX", " \t\t\t    if (fbHaveMMX())", " \t\t\t\tfunc = fbCompositeSolidMask_nx8x0565mmx;", " \t\t\t    else", " #endif", " \t\t\t    func = fbCompositeSolidMask_nx8x0565;", " \t\t\t    break;", " \t\t\tcase PICT_r8g8b8:", " \t\t\tcase PICT_b8g8r8:", " \t\t\t    func = fbCompositeSolidMask_nx8x0888;", " \t\t\t    break;", " \t\t\tcase PICT_a8r8g8b8:", " \t\t\tcase PICT_x8r8g8b8:", " \t\t\tcase PICT_a8b8g8r8:", " \t\t\tcase PICT_x8b8g8r8:", " \t\t\t    func = SafeAlphaCompositeSolidMask_nx8x8888;", " \t\t\t    break;", " \t\t\t}", " \t\t\tbreak;", " \t\t    case PICT_a8r8g8b8:", " \t\t\tif (pMask->componentAlpha) {", " \t\t\t    switch (pDst->format) {", " \t\t\t    case PICT_a8r8g8b8:", " \t\t\t    case PICT_x8r8g8b8:", " #ifdef USE_MMX", " \t\t\t\tif (fbHaveMMX())", " \t\t\t\t    func = fbCompositeSolidMask_nx8888x8888Cmmx;", " \t\t\t\telse", " #endif", " \t\t\t\tfunc = fbCompositeSolidMask_nx8888x8888C;", " \t\t\t\tbreak;", " \t\t\t    case PICT_r5g6b5:", " #ifdef USE_MMX", " \t\t\t\tif (fbHaveMMX())", " \t\t\t\t    func = fbCompositeSolidMask_nx8888x0565Cmmx;", " \t\t\t\telse", " #endif", " \t\t\t\tfunc = fbCompositeSolidMask_nx8888x0565C;", " \t\t\t\tbreak;", " \t\t\t    }", " \t\t\t}", " \t\t\tbreak;", " \t\t    case PICT_a8b8g8r8:", " \t\t\tif (pMask->componentAlpha) {", " \t\t\t    switch (pDst->format) {", " \t\t\t    case PICT_a8b8g8r8:", " \t\t\t    case PICT_x8b8g8r8:", " #ifdef USE_MMX", " \t\t\t\tif (fbHaveMMX())", " \t\t\t\t    func = fbCompositeSolidMask_nx8888x8888Cmmx;", " \t\t\t\telse", " #endif", " \t\t\t\tfunc = fbCompositeSolidMask_nx8888x8888C;", " \t\t\t\tbreak;", " \t\t\t    case PICT_b5g6r5:", " #ifdef USE_MMX", " \t\t\t\tif (fbHaveMMX())", " \t\t\t\t    func = fbCompositeSolidMask_nx8888x0565Cmmx;", " \t\t\t\telse", " #endif", " \t\t\t\tfunc = fbCompositeSolidMask_nx8888x0565C;", " \t\t\t\tbreak;", " \t\t\t    }", " \t\t\t}", " \t\t\tbreak;", " \t\t    case PICT_a1:", " \t\t\tswitch (pDst->format) {", " \t\t\tcase PICT_r5g6b5:", " \t\t\tcase PICT_b5g6r5:", " \t\t\tcase PICT_r8g8b8:", " \t\t\tcase PICT_b8g8r8:", " \t\t\tcase PICT_a8r8g8b8:", " \t\t\tcase PICT_x8r8g8b8:", " \t\t\tcase PICT_a8b8g8r8:", " \t\t\tcase PICT_x8b8g8r8:", " \t\t\t    func = fbCompositeSolidMask_nx1xn;", " \t\t\t    break;", " \t\t\t}", " \t\t\tbreak;", " \t\t    }", " \t\t}", " \t    }", " \t    else  ", " \t    {", " \t\tif (pSrc->pDrawable == pMask->pDrawable &&", " \t\t    xSrc == xMask && ySrc == yMask &&", " \t\t    !pMask->componentAlpha)", " \t\t{", " \t\t    switch (pSrc->format) {", " \t\t    case PICT_x8b8g8r8:", " \t\t\tswitch (pMask->format) {", " \t\t\tcase PICT_a8r8g8b8:", " \t\t\tcase PICT_a8b8g8r8:", " \t\t\t    switch (pDst->format) {", " \t\t\t    case PICT_a8r8g8b8:", " \t\t\t    case PICT_x8r8g8b8:", " #ifdef USE_MMX", " \t\t\t\tif (fbHaveMMX())", " \t\t\t\t    func = fbCompositeSrc_8888RevNPx8888mmx;", " #endif", " \t\t\t\tbreak;", " \t\t\t    case PICT_r5g6b5:", " #ifdef USE_MMX", " \t\t\t\tif (fbHaveMMX())", " \t\t\t\t    func = fbCompositeSrc_8888RevNPx0565mmx;", " #endif", " \t\t\t\tbreak;", " \t\t\t    }", " \t\t\t    break;", " \t\t\t}", " \t\t\tbreak;", " \t\t    case PICT_x8r8g8b8:", " \t\t\tswitch (pMask->format) {", " \t\t\tcase PICT_a8r8g8b8:", " \t\t\tcase PICT_a8b8g8r8:", " \t\t\t    switch (pDst->format) {", " \t\t\t    case PICT_a8b8g8r8:", " \t\t\t    case PICT_x8b8g8r8:", " #ifdef USE_MMX", " \t\t\t\tif (fbHaveMMX())", " \t\t\t\t    func = fbCompositeSrc_8888RevNPx8888mmx;", " #endif", " \t\t\t\tbreak;", " \t\t\t    case PICT_r5g6b5:", " #ifdef USE_MMX", " \t\t\t\tif (fbHaveMMX())", " \t\t\t\t    func = fbCompositeSrc_8888RevNPx0565mmx;", " #endif", " \t\t\t\tbreak;", " \t\t\t    }", " \t\t\t    break;", " \t\t\t}", " \t\t\tbreak;", " \t\t    }", " \t\t    break;", " \t}", " \telse", " \t{", " \t\t    if (maskRepeat &&", " \t\t\tpMask->pDrawable->width == 1 &&", " \t\t\tpMask->pDrawable->height == 1)", " \t\t    {", " \t\t\tif (pSrc->format == PICT_x8r8g8b8 &&", " \t\t\t    pDst->format == PICT_x8r8g8b8 &&", " \t\t\t    pMask->format == PICT_a8)", " \t\t\t{", " #ifdef USE_MMX", " \t\t\t    if (fbHaveMMX())", " \t\t\t\tfunc = fbCompositeSrc_8888x8x8888mmx;", " #endif", " \t\t\t}", " \t\t    }", " \t\t}", " \t    }", " \t}", " \telse  ", " \t{", " \t    if (srcRepeat &&", " \t\tpSrc->pDrawable->width == 1 &&", " \t\tpSrc->pDrawable->height == 1)", " \t    {", " \t    switch (pSrc->format) {", " \t    case PICT_a8r8g8b8:", " \t\t    switch (pDst->format) {", " \t\t    case PICT_a8r8g8b8:", " \t    case PICT_x8r8g8b8:", " #ifdef USE_MMX", " \t\t\tif (fbHaveMMX())", " \t\t\t{", " \t\t\t    srcRepeat = FALSE;", " \t\t\t    func = fbCompositeSolid_nx8888mmx;", " \t\t\t}", " #endif", " \t\t\tbreak;", " \t\t    case PICT_r5g6b5:", " #ifdef USE_MMX", " \t\t\tif (fbHaveMMX())", " \t\t\t{", " \t\t\t    srcRepeat = FALSE;", " \t\t\t    func = fbCompositeSolid_nx0565mmx;", " \t\t\t}", " #endif", " \t\t\tbreak;", " \t\t    }", " \t\t    break;", " \t\t}", " \t    }", " \t    else", " \t    {", " \t\tswitch (pSrc->format) {", " \t\tcase PICT_a8r8g8b8:", " \t\tswitch (pDst->format) {", " \t\tcase PICT_a8r8g8b8:", " \t\tcase PICT_x8r8g8b8:", " #ifdef USE_MMX", " \t\t\tif (fbHaveMMX())", " \t\t\t    func = fbCompositeSrc_8888x8888mmx;", " \t\t\telse", " #endif", " \t\t    func = fbCompositeSrc_8888x8888;", " \t\t    break;", " \t\tcase PICT_r8g8b8:", " \t\t    func = fbCompositeSrc_8888x0888;", " \t\t    break;", " \t\tcase PICT_r5g6b5:", " \t\t    func = fbCompositeSrc_8888x0565;", " \t\t    break;", " \t\t}", " \t\tbreak;", " \t\tcase PICT_x8r8g8b8:", " \t\t    switch (pDst->format) {", " \t\t    case PICT_a8r8g8b8:", " \t\t    case PICT_x8r8g8b8:", " #ifdef USE_MMX", " \t\t\tif (fbHaveMMX())", " \t\t\t    func = fbCompositeCopyAreammx;", " #endif", " \t\t\tbreak;", " \t\t    }", " \t\tcase PICT_x8b8g8r8:", " \t\t    switch (pDst->format) {", " \t    case PICT_a8b8g8r8:", " \t    case PICT_x8b8g8r8:", " #ifdef USE_MMX", " \t\t\tif (fbHaveMMX())", " \t\t\t    func = fbCompositeCopyAreammx;", " #endif", " \t\t\tbreak;", " \t\t    }", " \t\t    break;", " \t\tcase PICT_a8b8g8r8:", " \t\tswitch (pDst->format) {", " \t\tcase PICT_a8b8g8r8:", " \t\tcase PICT_x8b8g8r8:", " #ifdef USE_MMX", " \t\t\tif (fbHaveMMX())", " \t\t\t    func = fbCompositeSrc_8888x8888mmx;", " \t\t\telse", " #endif", " \t\t    func = fbCompositeSrc_8888x8888;", " \t\t    break;", " \t\tcase PICT_b8g8r8:", " \t\t    func = fbCompositeSrc_8888x0888;", " \t\t    break;", " \t\tcase PICT_b5g6r5:", " \t\t    func = fbCompositeSrc_8888x0565;", " \t\t    break;", " \t\t}", " \t\tbreak;", " \t    case PICT_r5g6b5:", " \t\tswitch (pDst->format) {", " \t\tcase PICT_r5g6b5:", " \t\t    func = fbCompositeSrc_0565x0565;", " \t\t    break;", " \t\t}", " \t\tbreak;", " \t    case PICT_b5g6r5:", " \t\tswitch (pDst->format) {", " \t\tcase PICT_b5g6r5:", " \t\t    func = fbCompositeSrc_0565x0565;", " \t\t    break;", " \t\t}", " \t\tbreak;", " \t    }", " \t}", " \t}", " \tbreak;", "     case PictOpAdd:", " \tif (pMask == 0)", " \t{", " \t    switch (pSrc->format) {", " \t    case PICT_a8r8g8b8:", " \t\tswitch (pDst->format) {", " \t\tcase PICT_a8r8g8b8:", " #ifdef USE_MMX", " \t\t    if (fbHaveMMX())", " \t\t\tfunc = fbCompositeSrcAdd_8888x8888mmx;", " \t\t    else", " #endif", " \t\t    func = fbCompositeSrcAdd_8888x8888;", " \t\t    break;", " \t\t}", " \t\tbreak;", " \t    case PICT_a8b8g8r8:", " \t\tswitch (pDst->format) {", " \t\tcase PICT_a8b8g8r8:", " #ifdef USE_MMX", " \t\t    if (fbHaveMMX())", " \t\t\tfunc = fbCompositeSrcAdd_8888x8888mmx;", " \t\t    else", " #endif", " \t\t    func = fbCompositeSrcAdd_8888x8888;", " \t\t    break;", " \t\t}", " \t\tbreak;", " \t    case PICT_a8:", " \t\tswitch (pDst->format) {", " \t\tcase PICT_a8:", " #ifdef USE_MMX", " \t\t    if (fbHaveMMX())", " \t\t\tfunc = fbCompositeSrcAdd_8000x8000mmx;", " \t\t    else", " #endif", " \t\t    func = fbCompositeSrcAdd_8000x8000;", " \t\t    break;", " \t\t}", " \t\tbreak;", " \t    case PICT_a1:", " \t\tswitch (pDst->format) {", " \t\tcase PICT_a1:", " \t\t    func = fbCompositeSrcAdd_1000x1000;", " \t\t    break;", " \t\t}", " \t\tbreak;", " \t    }", " \t}", " \tbreak;", "     }", "     if (!func) {", "         fbCompositeGeneral(op, pSrc, pMask, pDst, xSrc, ySrc, xMask, yMask, xDst, yDst, width, height);", "         pDst->pDrawable->depth = dstDepth;", "         pDst->format = oldFormat;", "         return;", "     }", "     if (!miComputeCompositeRegion (&region,", "  \t\t\t\t   pSrc,", "  \t\t\t\t   pMask,", "  \t\t\t\t   pDst,", "  \t\t\t\t   xSrc,", "  \t\t\t\t   ySrc,", "  \t\t\t\t   xMask,", "  \t\t\t\t   yMask,", "  \t\t\t\t   xDst,", "  \t\t\t\t   yDst,", "  \t\t\t\t   width,", "                                    height))", "         return;", "     n = REGION_NUM_RECTS (&region);", "     pbox = REGION_RECTS (&region);", "     while (n--)", "     {", " \th = pbox->y2 - pbox->y1;", " \ty_src = pbox->y1 - yDst + ySrc;", " \ty_msk = pbox->y1 - yDst + yMask;", " \ty_dst = pbox->y1;", " \twhile (h)", " \t{", " \t    h_this = h;", " \t    w = pbox->x2 - pbox->x1;", " \t    x_src = pbox->x1 - xDst + xSrc;", " \t    x_msk = pbox->x1 - xDst + xMask;", " \t    x_dst = pbox->x1;", " \t    if (maskRepeat)", " \t    {", " \t\ty_msk = mod (y_msk, pMask->pDrawable->height);", " \t\tif (h_this > pMask->pDrawable->height - y_msk)", " \t\t    h_this = pMask->pDrawable->height - y_msk;", " \t    }", " \t    if (srcRepeat)", " \t    {", " \t\ty_src = mod (y_src, pSrc->pDrawable->height);", " \t\tif (h_this > pSrc->pDrawable->height - y_src)", " \t\t    h_this = pSrc->pDrawable->height - y_src;", " \t    }", " \t    while (w)", " \t    {", " \t\tw_this = w;", " \t\tif (maskRepeat)", " \t\t{", " \t\t    x_msk = mod (x_msk, pMask->pDrawable->width);", " \t\t    if (w_this > pMask->pDrawable->width - x_msk)", " \t\t\tw_this = pMask->pDrawable->width - x_msk;", " \t\t}", " \t\tif (srcRepeat)", " \t\t{", " \t\t    x_src = mod (x_src, pSrc->pDrawable->width);", " \t\t    if (w_this > pSrc->pDrawable->width - x_src)", " \t\t\tw_this = pSrc->pDrawable->width - x_src;", " \t\t}", " \t\t(*func) (op, pSrc, pMask, pDst,", " \t\t\t x_src, y_src, x_msk, y_msk, x_dst, y_dst,", " \t\t\t w_this, h_this);", " \t\tw -= w_this;", " \t\tx_src += w_this;", " \t\tx_msk += w_this;", " \t\tx_dst += w_this;", " \t    }", " \t    h -= h_this;", " \t    y_src += h_this;", " \t    y_msk += h_this;", " \t    y_dst += h_this;", " \t}", " \tpbox++;", "     }", "     REGION_UNINIT (pDst->pDrawable->pScreen, &region);", "     pDst->pDrawable->depth = dstDepth;", "     pDst->format = oldFormat;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int get_siz(Jpeg2000DecoderContext *s)", " {", "     int i;", "     int ncomponents;", "     uint32_t log2_chroma_wh = 0;", "     const enum AVPixelFormat *possible_fmts = NULL;", "     int possible_fmts_nb = 0;", "     if (bytestream2_get_bytes_left(&s->g) < 36)", "         return AVERROR_INVALIDDATA;", "     s->avctx->profile = bytestream2_get_be16u(&s->g);  ", "     s->width          = bytestream2_get_be32u(&s->g);  ", "     s->height         = bytestream2_get_be32u(&s->g);  ", "     s->image_offset_x = bytestream2_get_be32u(&s->g);  ", "     s->image_offset_y = bytestream2_get_be32u(&s->g);  ", "     s->tile_width     = bytestream2_get_be32u(&s->g);  ", "     s->tile_height    = bytestream2_get_be32u(&s->g);  ", "     s->tile_offset_x  = bytestream2_get_be32u(&s->g);  ", "      s->tile_offset_y  = bytestream2_get_be32u(&s->g);  ", "      ncomponents       = bytestream2_get_be16u(&s->g);  ", "     if (s->image_offset_x || s->image_offset_y) {", "         avpriv_request_sample(s->avctx, \"Support for image offsets\");", "         return AVERROR_PATCHWELCOME;", "     }", "      if (ncomponents <= 0) {", "          av_log(s->avctx, AV_LOG_ERROR, \"Invalid number of components: %d\\n\",", "                 s->ncomponents);", "         return AVERROR_INVALIDDATA;", "     }", "     if (ncomponents > 4) {", "         avpriv_request_sample(s->avctx, \"Support for %d components\",", "                               s->ncomponents);", "         return AVERROR_PATCHWELCOME;", "     }", "     s->ncomponents = ncomponents;", "     if (s->tile_width <= 0 || s->tile_height <= 0) {", "         av_log(s->avctx, AV_LOG_ERROR, \"Invalid tile dimension %dx%d.\\n\",", "                s->tile_width, s->tile_height);", "         return AVERROR_INVALIDDATA;", "     }", "     if (bytestream2_get_bytes_left(&s->g) < 3 * s->ncomponents)", "         return AVERROR_INVALIDDATA;", "     for (i = 0; i < s->ncomponents; i++) {  ", "         uint8_t x    = bytestream2_get_byteu(&s->g);", "         s->cbps[i]   = (x & 0x7f) + 1;", "         s->precision = FFMAX(s->cbps[i], s->precision);", "         s->sgnd[i]   = !!(x & 0x80);", "         s->cdx[i]    = bytestream2_get_byteu(&s->g);", "         s->cdy[i]    = bytestream2_get_byteu(&s->g);", "         if (   !s->cdx[i] || s->cdx[i] == 3 || s->cdx[i] > 4", "             || !s->cdy[i] || s->cdy[i] == 3 || s->cdy[i] > 4) {", "             av_log(s->avctx, AV_LOG_ERROR, \"Invalid sample separation %d/%d\\n\", s->cdx[i], s->cdy[i]);", "             return AVERROR_INVALIDDATA;", "         }", "         log2_chroma_wh |= s->cdy[i] >> 1 << i * 4 | s->cdx[i] >> 1 << i * 4 + 2;", "     }", "     s->numXtiles = ff_jpeg2000_ceildiv(s->width  - s->tile_offset_x, s->tile_width);", "     s->numYtiles = ff_jpeg2000_ceildiv(s->height - s->tile_offset_y, s->tile_height);", "     if (s->numXtiles * (uint64_t)s->numYtiles > INT_MAX/sizeof(*s->tile)) {", "         s->numXtiles = s->numYtiles = 0;", "         return AVERROR(EINVAL);", "     }", "     s->tile = av_mallocz_array(s->numXtiles * s->numYtiles, sizeof(*s->tile));", "     if (!s->tile) {", "         s->numXtiles = s->numYtiles = 0;", "         return AVERROR(ENOMEM);", "     }", "     for (i = 0; i < s->numXtiles * s->numYtiles; i++) {", "         Jpeg2000Tile *tile = s->tile + i;", "         tile->comp = av_mallocz(s->ncomponents * sizeof(*tile->comp));", "         if (!tile->comp)", "             return AVERROR(ENOMEM);", "     }", "     s->avctx->width  = ff_jpeg2000_ceildivpow2(s->width  - s->image_offset_x,", "                                                s->reduction_factor);", "     s->avctx->height = ff_jpeg2000_ceildivpow2(s->height - s->image_offset_y,", "                                                s->reduction_factor);", "     if (s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_2K ||", "         s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_4K) {", "         possible_fmts = xyz_pix_fmts;", "         possible_fmts_nb = FF_ARRAY_ELEMS(xyz_pix_fmts);", "     } else {", "         switch (s->colour_space) {", "         case 16:", "             possible_fmts = rgb_pix_fmts;", "             possible_fmts_nb = FF_ARRAY_ELEMS(rgb_pix_fmts);", "             break;", "         case 17:", "             possible_fmts = gray_pix_fmts;", "             possible_fmts_nb = FF_ARRAY_ELEMS(gray_pix_fmts);", "             break;", "         case 18:", "             possible_fmts = yuv_pix_fmts;", "             possible_fmts_nb = FF_ARRAY_ELEMS(yuv_pix_fmts);", "             break;", "         default:", "             possible_fmts = all_pix_fmts;", "             possible_fmts_nb = FF_ARRAY_ELEMS(all_pix_fmts);", "             break;", "         }", "     }", "     for (i = 0; i < possible_fmts_nb; ++i) {", "         if (pix_fmt_match(possible_fmts[i], ncomponents, s->precision, log2_chroma_wh, s->pal8)) {", "             s->avctx->pix_fmt = possible_fmts[i];", "             break;", "         }", "     }", "     if (s->avctx->pix_fmt == AV_PIX_FMT_NONE) {", "         av_log(s->avctx, AV_LOG_ERROR,", "                \"Unknown pix_fmt, profile: %d, colour_space: %d, \"", "                \"components: %d, precision: %d, \"", "                \"cdx[1]: %d, cdy[1]: %d, cdx[2]: %d, cdy[2]: %d\\n\",", "                s->avctx->profile, s->colour_space, ncomponents, s->precision,", "                ncomponents > 2 ? s->cdx[1] : 0,", "                ncomponents > 2 ? s->cdy[1] : 0,", "                ncomponents > 2 ? s->cdx[2] : 0,", "                ncomponents > 2 ? s->cdy[2] : 0);", "     }", "     s->avctx->bits_per_raw_sample = s->precision;", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,", "                 OnigCompileInfo* ci, OnigErrorInfo* einfo)", " {", "   int r;", "   UChar *cpat, *cpat_end;", "    if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;", "    if (ci->pattern_enc != ci->target_enc) {", "    r = conv_encoding(ci->pattern_enc, ci->target_enc, pattern, pattern_end,", "                      &cpat, &cpat_end);", "    if (r != 0) return r;", "     return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION;", "    }", "    else {", "      cpat     = (UChar* )pattern;", "     cpat_end = (UChar* )pattern_end;", "   }", "   *reg = (regex_t* )xmalloc(sizeof(regex_t));", "   if (IS_NULL(*reg)) {", "     r = ONIGERR_MEMORY;", "     goto err2;", "   }", "   r = onig_reg_init(*reg, ci->option, ci->case_fold_flag, ci->target_enc,", "                     ci->syntax);", "   if (r != 0) goto err;", "   r = onig_compile(*reg, cpat, cpat_end, einfo);", "   if (r != 0) {", "   err:", "     onig_free(*reg);", "     *reg = NULL;", "   }", "  err2:", "   if (cpat != pattern) xfree(cpat);", "   return r;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,", "                                 AVFrame *picture)", " {", "     int compno, reslevelno, bandno;", "     int x, y;", "     uint8_t *line;", "     Jpeg2000T1Context t1;", "     for (compno = 0; compno < s->ncomponents; compno++) {", "         Jpeg2000Component *comp     = tile->comp + compno;", "         Jpeg2000CodingStyle *codsty = tile->codsty + compno;", "         for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) {", "             Jpeg2000ResLevel *rlevel = comp->reslevel + reslevelno;", "             for (bandno = 0; bandno < rlevel->nbands; bandno++) {", "                 int nb_precincts, precno;", "                 Jpeg2000Band *band = rlevel->band + bandno;", "                 int cblkno = 0, bandpos;", "                 bandpos = bandno + (reslevelno > 0);", "                 if (band->coord[0][0] == band->coord[0][1] ||", "                     band->coord[1][0] == band->coord[1][1])", "                     continue;", "                 nb_precincts = rlevel->num_precincts_x * rlevel->num_precincts_y;", "                 for (precno = 0; precno < nb_precincts; precno++) {", "                     Jpeg2000Prec *prec = band->prec + precno;", "                     for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) {", "                         int x, y;", "                         Jpeg2000Cblk *cblk = prec->cblk + cblkno;", "                         decode_cblk(s, codsty, &t1, cblk,", "                                     cblk->coord[0][1] - cblk->coord[0][0],", "                                     cblk->coord[1][1] - cblk->coord[1][0],", "                                     bandpos);", "                         x = cblk->coord[0][0];", "                         y = cblk->coord[1][0];", "                         if (codsty->transform == FF_DWT97)", "                             dequantization_float(x, y, cblk, comp, &t1, band);", "                         else", "                             dequantization_int(x, y, cblk, comp, &t1, band);", "                    }  ", "                 }  ", "             }  ", "         }  ", "         ff_dwt_decode(&comp->dwt, codsty->transform == FF_DWT97 ? (void*)comp->f_data : (void*)comp->i_data);", "     }  ", "     if (tile->codsty[0].mct)", "         mct_decode(s, tile);", "     if (s->cdef[0] < 0) {", "         for (x = 0; x < s->ncomponents; x++)", "             s->cdef[x] = x + 1;", "         if ((s->ncomponents & 1) == 0)", "             s->cdef[s->ncomponents-1] = 0;", "     }", "     if (s->precision <= 8) {", "         for (compno = 0; compno < s->ncomponents; compno++) {", "             Jpeg2000Component *comp = tile->comp + compno;", "             Jpeg2000CodingStyle *codsty = tile->codsty + compno;", "             float *datap = comp->f_data;", "             int32_t *i_datap = comp->i_data;", "             int cbps = s->cbps[compno];", "             int w = tile->comp[compno].coord[0][1] - s->image_offset_x;", "             int planar = !!picture->data[2];", "             int pixelsize = planar ? 1 : s->ncomponents;", "             int plane = 0;", "             if (planar)", "                 plane = s->cdef[compno] ? s->cdef[compno]-1 : (s->ncomponents-1);", "              y    = tile->comp[compno].coord[1][0] - s->image_offset_y;", "            line = picture->data[plane] + y * picture->linesize[plane];", "             line = picture->data[plane] + y / s->cdy[compno] * picture->linesize[plane];", "              for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {", "                  uint8_t *dst;", "                  x   = tile->comp[compno].coord[0][0] - s->image_offset_x;", "                dst = line + x * pixelsize + compno*!planar;", "                 dst = line + x / s->cdx[compno] * pixelsize + compno*!planar;", "                  if (codsty->transform == FF_DWT97) {", "                      for (; x < w; x += s->cdx[compno]) {", "                         int val = lrintf(*datap) + (1 << (cbps - 1));", "                         val = av_clip(val, 0, (1 << cbps) - 1);", "                         *dst = val << (8 - cbps);", "                         datap++;", "                         dst += pixelsize;", "                     }", "                 } else {", "                     for (; x < w; x += s->cdx[compno]) {", "                         int val = *i_datap + (1 << (cbps - 1));", "                         val = av_clip(val, 0, (1 << cbps) - 1);", "                         *dst = val << (8 - cbps);", "                         i_datap++;", "                         dst += pixelsize;", "                     }", "                 }", "                 line += picture->linesize[plane];", "             }", "         }", "     } else {", "         for (compno = 0; compno < s->ncomponents; compno++) {", "             Jpeg2000Component *comp = tile->comp + compno;", "             Jpeg2000CodingStyle *codsty = tile->codsty + compno;", "             float *datap = comp->f_data;", "             int32_t *i_datap = comp->i_data;", "             uint16_t *linel;", "             int cbps = s->cbps[compno];", "             int w = tile->comp[compno].coord[0][1] - s->image_offset_x;", "             int planar = !!picture->data[2];", "             int pixelsize = planar ? 1 : s->ncomponents;", "             int plane = 0;", "             if (planar)", "                  plane = s->cdef[compno] ? s->cdef[compno]-1 : (s->ncomponents-1);", "              y     = tile->comp[compno].coord[1][0] - s->image_offset_y;", "            linel = (uint16_t *)picture->data[plane] + y * (picture->linesize[plane] >> 1);", "             linel = (uint16_t *)picture->data[plane] + y / s->cdy[compno] * (picture->linesize[plane] >> 1);", "              for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {", "                  uint16_t *dst;", "                  x   = tile->comp[compno].coord[0][0] - s->image_offset_x;", "                dst = linel + (x * pixelsize + compno*!planar);", "                 dst = linel + (x / s->cdx[compno] * pixelsize + compno*!planar);", "                  if (codsty->transform == FF_DWT97) {", "                      for (; x < w; x += s-> cdx[compno]) {", "                          int  val = lrintf(*datap) + (1 << (cbps - 1));", "                         val = av_clip(val, 0, (1 << cbps) - 1);", "                         *dst = val << (16 - cbps);", "                         datap++;", "                         dst += pixelsize;", "                     }", "                 } else {", "                     for (; x < w; x += s-> cdx[compno]) {", "                         int val = *i_datap + (1 << (cbps - 1));", "                         val = av_clip(val, 0, (1 << cbps) - 1);", "                         *dst = val << (16 - cbps);", "                         i_datap++;", "                         dst += pixelsize;", "                     }", "                 }", "                 linel += picture->linesize[plane] >> 1;", "             }", "         }", "     }", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int msPostGISLayerSetTimeFilter(layerObj *lp, const char *timestring, const char *timefield)", " {", "   char **atimes, **aranges = NULL;", "   int numtimes=0,i=0,numranges=0;", "   size_t buffer_size = 512;", "   char buffer[512], bufferTmp[512];", "   buffer[0] = '\\0';", "   bufferTmp[0] = '\\0';", "    if (!lp || !timestring || !timefield)", "      return MS_FALSE;", "   if( strchr(timestring,'\\'') || strchr(timestring, '\\\\') ) {", "      msSetError(MS_MISCERR, \"Invalid time filter.\", \"msPostGISLayerSetTimeFilter()\");", "      return MS_FALSE;", "   }", "    if (strstr(timestring, \",\") == NULL &&", "        strstr(timestring, \"/\") == NULL) {  ", "     createPostgresTimeCompareSimple(timefield, timestring, buffer, buffer_size);", "   } else {", "     atimes = msStringSplit (timestring, ',', &numtimes);", "     if (atimes == NULL || numtimes < 1)", "       return MS_FALSE;", "     strlcat(buffer, \"(\", buffer_size);", "     for(i=0; i<numtimes; i++) {", "       if(i!=0) {", "         strlcat(buffer, \" OR \", buffer_size);", "       }", "       strlcat(buffer, \"(\", buffer_size);", "       aranges = msStringSplit(atimes[i],  '/', &numranges);", "       if(!aranges) return MS_FALSE;", "       if(numranges == 1) {", "         createPostgresTimeCompareSimple(timefield, atimes[i], bufferTmp, buffer_size);", "         strlcat(buffer, bufferTmp, buffer_size);", "       } else if(numranges == 2) {", "         createPostgresTimeCompareRange(timefield, aranges[0], aranges[1], bufferTmp, buffer_size);", "         strlcat(buffer, bufferTmp, buffer_size);", "       } else {", "         return MS_FALSE;", "       }", "       msFreeCharArray(aranges, numranges);", "       strlcat(buffer, \")\", buffer_size);", "     }", "     strlcat(buffer, \")\", buffer_size);", "     msFreeCharArray(atimes, numtimes);", "   }", "   if(!*buffer) {", "     return MS_FALSE;", "   }", "   if(lp->filteritem) free(lp->filteritem);", "   lp->filteritem = msStrdup(timefield);", "   if (&lp->filter) {", "     if (lp->filter.type == MS_EXPRESSION) {", "       snprintf(bufferTmp, buffer_size, \"(%s) and %s\", lp->filter.string, buffer);", "       loadExpressionString(&lp->filter, bufferTmp);", "     } else {", "       freeExpression(&lp->filter);", "       loadExpressionString(&lp->filter, buffer);", "     }", "   }", "   return MS_TRUE;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  mcs_parse_domain_params(STREAM s)", "  {", "\tint length;", " \tuint32 length;", " \tstruct stream packet = *s;", "  \tber_parse_header(s, MCS_TAG_DOMAIN_PARAMS, &length);", " \tif (!s_check_rem(s, length))", " \t{", " \t\trdp_protocol_error(\"mcs_parse_domain_params(), consume domain params from stream would overrun\", &packet);", " \t}", "  \tin_uint8s(s, length);", "  \treturn s_check(s);", " }"], "ner_tags": [0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": [" LockServer(void)", " {", "   char tmp[PATH_MAX], pid_str[12];", "   int lfd, i, haslock, l_pid, t;", "   char *tmppath = NULL;", "   int len;", "   char port[20];", "   if (nolock) return;", "   tmppath = LOCK_DIR;", "   sprintf(port, \"%d\", atoi(display));", "   len = strlen(LOCK_PREFIX) > strlen(LOCK_TMP_PREFIX) ? strlen(LOCK_PREFIX) :", " \t\t\t\t\t\tstrlen(LOCK_TMP_PREFIX);", "   len += strlen(tmppath) + strlen(port) + strlen(LOCK_SUFFIX) + 1;", "   if (len > sizeof(LockFile))", "     FatalError(\"Display name `%s' is too long\\n\", port);", "   (void)sprintf(tmp, \"%s\" LOCK_TMP_PREFIX \"%s\" LOCK_SUFFIX, tmppath, port);", "   (void)sprintf(LockFile, \"%s\" LOCK_PREFIX \"%s\" LOCK_SUFFIX, tmppath, port);", "   StillLocking = TRUE;", "   i = 0;", "   do {", "     i++;", "     lfd = open(tmp, O_CREAT | O_EXCL | O_WRONLY, 0644);", "     if (lfd < 0)", "        sleep(2);", "     else", "        break;", "   } while (i < 3);", "   if (lfd < 0) {", "     unlink(tmp);", "     i = 0;", "     do {", "       i++;", "       lfd = open(tmp, O_CREAT | O_EXCL | O_WRONLY, 0644);", "       if (lfd < 0)", "          sleep(2);", "       else", "          break;", "     } while (i < 3);", "   }", "   if (lfd < 0)", "     FatalError(\"Could not create lock file in %s\\n\", tmp);", "   (void) sprintf(pid_str, \"%10ld\\n\", (long)getpid());", "   (void) write(lfd, pid_str, 11);", "   (void) chmod(tmp, 0444);", "   (void) close(lfd);", "   i = 0;", "   haslock = 0;", "   while ((!haslock) && (i++ < 3)) {", "     haslock = (link(tmp,LockFile) == 0);", "     if (haslock) {", "       break;", "     }", "     else {", "      lfd = open(LockFile, O_RDONLY);", "       lfd = open(LockFile, O_RDONLY|O_NOFOLLOW);", "        if (lfd < 0) {", "          unlink(tmp);", "          FatalError(\"Can't read lock file %s\\n\", LockFile);", "       }", "       pid_str[0] = '\\0';", "       if (read(lfd, pid_str, 11) != 11) {", "         unlink(LockFile);", "         close(lfd);", "         continue;", "       }", "       pid_str[11] = '\\0';", "       sscanf(pid_str, \"%d\", &l_pid);", "       close(lfd);", "       errno = 0;", "       t = kill(l_pid, 0);", "       if ((t< 0) && (errno == ESRCH)) {", "         unlink(LockFile);", "         continue;", "       }", "       else if (((t < 0) && (errno == EPERM)) || (t == 0)) {", "         unlink(tmp);", " \tFatalError(\"Server is already active for display %s\\n%s %s\\n%s\\n\",", " \t\t   port, \"\\tIf this server is no longer running, remove\",", " \t\t   LockFile, \"\\tand start again.\");", "       }", "     }", "   }", "   unlink(tmp);", "   if (!haslock)", "     FatalError(\"Could not create server lock file: %s\\n\", LockFile);", "   StillLocking = FALSE;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" ber_parse_header(STREAM s, int tagval, int *length)", " ber_parse_header(STREAM s, int tagval, uint32 *length)", "  {", "  \tint tag, len;", " \tif (tagval > 0xff)", " \t{", " \t\tin_uint16_be(s, tag);", " \t}", " \telse", " \t{", " \t\tin_uint8(s, tag);", " \t}", " \tif (tag != tagval)", " \t{", " \t\tlogger(Core, Error, \"ber_parse_header(), expected tag %d, got %d\", tagval, tag);", " \t\treturn False;", " \t}", " \tin_uint8(s, len);", " \tif (len & 0x80)", " \t{", " \t\tlen &= ~0x80;", " \t\t*length = 0;", " \t\twhile (len--)", " \t\t\tnext_be(s, *length);", " \t}", " \telse", " \t\t*length = len;", " \treturn s_check(s);", " }"], "ner_tags": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int yr_execute_code(", "     YR_RULES* rules,", "     YR_SCAN_CONTEXT* context,", "     int timeout,", "     time_t start_time)", " {", "   int64_t mem[MEM_SIZE];", "   int32_t sp = 0;", "   uint8_t* ip = rules->code_start;", "   YR_VALUE args[MAX_FUNCTION_ARGS];", "   YR_VALUE *stack;", "   YR_VALUE r1;", "   YR_VALUE r2;", "   YR_VALUE r3;", "   #ifdef PROFILING_ENABLED", "   YR_RULE* current_rule = NULL;", "   #endif", "    YR_RULE* rule;", "    YR_MATCH* match;", "    YR_OBJECT_FUNCTION* function;", "   YR_OBJECT** obj_ptr;", "   YR_ARENA* obj_arena;", "    char* identifier;", "    char* args_fmt;", "   int i;", "   int found;", "   int count;", "   int result = ERROR_SUCCESS;", "   int stop = FALSE;", "   int cycle = 0;", "   int tidx = context->tidx;", "   int stack_size;", "   #ifdef PROFILING_ENABLED", "   clock_t start = clock();", "   #endif", "   yr_get_configuration(YR_CONFIG_STACK_SIZE, (void*) &stack_size);", "   stack = (YR_VALUE*) yr_malloc(stack_size * sizeof(YR_VALUE));", "    if (stack == NULL)", "      return ERROR_INSUFFICIENT_MEMORY;", "   FAIL_ON_ERROR_WITH_CLEANUP(", "       yr_arena_create(1024, 0, &obj_arena),", "       yr_free(stack));", "    while(!stop)", "    {", "      switch(*ip)", "     {", "       case OP_NOP:", "         break;", "       case OP_HALT:", "         assert(sp == 0);  ", "         stop = TRUE;", "         break;", "       case OP_PUSH:", "         r1.i = *(uint64_t*)(ip + 1);", "         ip += sizeof(uint64_t);", "         push(r1);", "         break;", "       case OP_POP:", "         pop(r1);", "         break;", "       case OP_CLEAR_M:", "         r1.i = *(uint64_t*)(ip + 1);", "         ip += sizeof(uint64_t);", "         mem[r1.i] = 0;", "         break;", "       case OP_ADD_M:", "         r1.i = *(uint64_t*)(ip + 1);", "         ip += sizeof(uint64_t);", "         pop(r2);", "         if (!is_undef(r2))", "           mem[r1.i] += r2.i;", "         break;", "       case OP_INCR_M:", "         r1.i = *(uint64_t*)(ip + 1);", "         ip += sizeof(uint64_t);", "         mem[r1.i]++;", "         break;", "       case OP_PUSH_M:", "         r1.i = *(uint64_t*)(ip + 1);", "         ip += sizeof(uint64_t);", "         r1.i = mem[r1.i];", "         push(r1);", "         break;", "       case OP_POP_M:", "         r1.i = *(uint64_t*)(ip + 1);", "         ip += sizeof(uint64_t);", "         pop(r2);", "         mem[r1.i] = r2.i;", "         break;", "       case OP_SWAPUNDEF:", "         r1.i = *(uint64_t*)(ip + 1);", "         ip += sizeof(uint64_t);", "         pop(r2);", "         if (is_undef(r2))", "         {", "           r1.i = mem[r1.i];", "           push(r1);", "         }", "         else", "         {", "           push(r2);", "         }", "         break;", "       case OP_JNUNDEF:", "         pop(r1);", "         push(r1);", "         ip = jmp_if(!is_undef(r1), ip);", "         break;", "       case OP_JLE:", "         pop(r2);", "         pop(r1);", "         push(r1);", "         push(r2);", "         ip = jmp_if(r1.i <= r2.i, ip);", "         break;", "       case OP_JTRUE:", "         pop(r1);", "         push(r1);", "         ip = jmp_if(!is_undef(r1) && r1.i, ip);", "         break;", "       case OP_JFALSE:", "         pop(r1);", "         push(r1);", "         ip = jmp_if(is_undef(r1) || !r1.i, ip);", "         break;", "       case OP_AND:", "         pop(r2);", "         pop(r1);", "         if (is_undef(r1) || is_undef(r2))", "           r1.i = 0;", "         else", "           r1.i = r1.i && r2.i;", "         push(r1);", "         break;", "       case OP_OR:", "         pop(r2);", "         pop(r1);", "         if (is_undef(r1))", "         {", "           push(r2);", "         }", "         else if (is_undef(r2))", "         {", "           push(r1);", "         }", "         else", "         {", "           r1.i = r1.i || r2.i;", "           push(r1);", "         }", "         break;", "       case OP_NOT:", "         pop(r1);", "         if (is_undef(r1))", "           r1.i = UNDEFINED;", "         else", "           r1.i= !r1.i;", "         push(r1);", "         break;", "       case OP_MOD:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         if (r2.i != 0)", "           r1.i = r1.i % r2.i;", "         else", "           r1.i = UNDEFINED;", "         push(r1);", "         break;", "       case OP_SHR:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.i = r1.i >> r2.i;", "         push(r1);", "         break;", "       case OP_SHL:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.i = r1.i << r2.i;", "         push(r1);", "         break;", "       case OP_BITWISE_NOT:", "         pop(r1);", "         ensure_defined(r1);", "         r1.i = ~r1.i;", "         push(r1);", "         break;", "       case OP_BITWISE_AND:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.i = r1.i & r2.i;", "         push(r1);", "         break;", "       case OP_BITWISE_OR:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.i = r1.i | r2.i;", "         push(r1);", "         break;", "       case OP_BITWISE_XOR:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.i = r1.i ^ r2.i;", "         push(r1);", "         break;", "       case OP_PUSH_RULE:", "         rule = *(YR_RULE**)(ip + 1);", "         ip += sizeof(uint64_t);", "         r1.i = rule->t_flags[tidx] & RULE_TFLAGS_MATCH ? 1 : 0;", "         push(r1);", "         break;", "       case OP_INIT_RULE:", "         #ifdef PROFILING_ENABLED", "         current_rule = *(YR_RULE**)(ip + 1);", "         #endif", "         ip += sizeof(uint64_t);", "         break;", "       case OP_MATCH_RULE:", "         pop(r1);", "         rule = *(YR_RULE**)(ip + 1);", "         ip += sizeof(uint64_t);", "         if (!is_undef(r1) && r1.i)", "           rule->t_flags[tidx] |= RULE_TFLAGS_MATCH;", "         else if (RULE_IS_GLOBAL(rule))", "           rule->ns->t_flags[tidx] |= NAMESPACE_TFLAGS_UNSATISFIED_GLOBAL;", "         #ifdef PROFILING_ENABLED", "          rule->clock_ticks += clock() - start;", "          start = clock();", "          #endif", "         assert(sp == 0);", "          break;", "        case OP_OBJ_LOAD:", "         identifier = *(char**)(ip + 1);", "         ip += sizeof(uint64_t);", "         r1.o = (YR_OBJECT*) yr_hash_table_lookup(", "             context->objects_table,", "             identifier,", "             NULL);", "         assert(r1.o != NULL);", "         push(r1);", "         break;", "       case OP_OBJ_FIELD:", "         identifier = *(char**)(ip + 1);", "         ip += sizeof(uint64_t);", "         pop(r1);", "         ensure_defined(r1);", "         r1.o = yr_object_lookup_field(r1.o, identifier);", "         assert(r1.o != NULL);", "         push(r1);", "         break;", "       case OP_OBJ_VALUE:", "         pop(r1);", "         ensure_defined(r1);", "         switch(r1.o->type)", "         {", "           case OBJECT_TYPE_INTEGER:", "             r1.i = ((YR_OBJECT_INTEGER*) r1.o)->value;", "             break;", "           case OBJECT_TYPE_FLOAT:", "             if (isnan(((YR_OBJECT_DOUBLE*) r1.o)->value))", "               r1.i = UNDEFINED;", "             else", "               r1.d = ((YR_OBJECT_DOUBLE*) r1.o)->value;", "             break;", "           case OBJECT_TYPE_STRING:", "             if (((YR_OBJECT_STRING*) r1.o)->value == NULL)", "               r1.i = UNDEFINED;", "             else", "               r1.p = ((YR_OBJECT_STRING*) r1.o)->value;", "             break;", "           default:", "             assert(FALSE);", "         }", "         push(r1);", "         break;", "       case OP_INDEX_ARRAY:", "         pop(r1);   ", "         pop(r2);   ", "         ensure_defined(r1);", "         ensure_defined(r2);", "         assert(r2.o->type == OBJECT_TYPE_ARRAY);", "         r1.o = yr_object_array_get_item(r2.o, 0, (int) r1.i);", "         if (r1.o == NULL)", "           r1.i = UNDEFINED;", "         push(r1);", "         break;", "       case OP_LOOKUP_DICT:", "         pop(r1);   ", "         pop(r2);   ", "         ensure_defined(r1);", "         ensure_defined(r2);", "         assert(r2.o->type == OBJECT_TYPE_DICTIONARY);", "         r1.o = yr_object_dict_get_item(", "             r2.o, 0, r1.ss->c_string);", "         if (r1.o == NULL)", "           r1.i = UNDEFINED;", "         push(r1);", "         break;", "       case OP_CALL:", "         args_fmt = *(char**)(ip + 1);", "         ip += sizeof(uint64_t);", "         i = (int) strlen(args_fmt);", "         count = 0;", "         while (i > 0)", "         {", "           pop(r1);", "           if (is_undef(r1))   ", "             count++;", "           args[i - 1] = r1;", "           i--;", "         }", "         pop(r2);", "         ensure_defined(r2);", "         if (count > 0)", "         {", "           r1.i = UNDEFINED;", "           push(r1);", "           break;", "         }", "         function = (YR_OBJECT_FUNCTION*) r2.o;", "         result = ERROR_INTERNAL_FATAL_ERROR;", "         for (i = 0; i < MAX_OVERLOADED_FUNCTIONS; i++)", "         {", "           if (function->prototypes[i].arguments_fmt == NULL)", "             break;", "           if (strcmp(function->prototypes[i].arguments_fmt, args_fmt) == 0)", "           {", "             result = function->prototypes[i].code(args, context, function);", "             break;", "            }", "          }", "          assert(i < MAX_OVERLOADED_FUNCTIONS);", "          if (result == ERROR_SUCCESS)", "        {", "          r1.o = function->return_obj;", "          push(r1);", "        }", "        else", "        {", "          stop = TRUE;", "        }", "           result = yr_object_copy(function->return_obj, &r1.o);", "         if (result == ERROR_SUCCESS)", "           result = yr_arena_write_data(obj_arena, &r1.o, sizeof(r1.o), NULL);", "         stop = (result != ERROR_SUCCESS);", "         push(r1);", "          break;", "        case OP_FOUND:", "         pop(r1);", "         r1.i = r1.s->matches[tidx].tail != NULL ? 1 : 0;", "         push(r1);", "         break;", "       case OP_FOUND_AT:", "         pop(r2);", "         pop(r1);", "         if (is_undef(r1))", "         {", "           r1.i = 0;", "           push(r1);", "           break;", "         }", "         match = r2.s->matches[tidx].head;", "         r3.i = FALSE;", "         while (match != NULL)", "         {", "           if (r1.i == match->base + match->offset)", "           {", "             r3.i = TRUE;", "             break;", "           }", "           if (r1.i < match->base + match->offset)", "             break;", "           match = match->next;", "         }", "         push(r3);", "         break;", "       case OP_FOUND_IN:", "         pop(r3);", "         pop(r2);", "         pop(r1);", "         ensure_defined(r1);", "         ensure_defined(r2);", "         match = r3.s->matches[tidx].head;", "         r3.i = FALSE;", "         while (match != NULL && !r3.i)", "         {", "           if (match->base + match->offset >= r1.i &&", "               match->base + match->offset <= r2.i)", "           {", "             r3.i = TRUE;", "           }", "           if (match->base + match->offset > r2.i)", "             break;", "           match = match->next;", "         }", "         push(r3);", "         break;", "       case OP_COUNT:", "         pop(r1);", "         r1.i = r1.s->matches[tidx].count;", "         push(r1);", "         break;", "       case OP_OFFSET:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r1);", "         match = r2.s->matches[tidx].head;", "         i = 1;", "         r3.i = UNDEFINED;", "         while (match != NULL && r3.i == UNDEFINED)", "         {", "           if (r1.i == i)", "             r3.i = match->base + match->offset;", "           i++;", "           match = match->next;", "         }", "         push(r3);", "         break;", "       case OP_LENGTH:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r1);", "         match = r2.s->matches[tidx].head;", "         i = 1;", "         r3.i = UNDEFINED;", "         while (match != NULL && r3.i == UNDEFINED)", "         {", "           if (r1.i == i)", "             r3.i = match->match_length;", "           i++;", "           match = match->next;", "         }", "         push(r3);", "         break;", "       case OP_OF:", "         found = 0;", "         count = 0;", "         pop(r1);", "         while (!is_undef(r1))", "         {", "           if (r1.s->matches[tidx].tail != NULL)", "             found++;", "           count++;", "           pop(r1);", "         }", "         pop(r2);", "         if (is_undef(r2))", "           r1.i = found >= count ? 1 : 0;", "         else", "           r1.i = found >= r2.i ? 1 : 0;", "         push(r1);", "         break;", "       case OP_FILESIZE:", "         r1.i = context->file_size;", "         push(r1);", "         break;", "       case OP_ENTRYPOINT:", "         r1.i = context->entry_point;", "         push(r1);", "         break;", "       case OP_INT8:", "         pop(r1);", "         r1.i = read_int8_t_little_endian(context->iterator, (size_t) r1.i);", "         push(r1);", "         break;", "       case OP_INT16:", "         pop(r1);", "         r1.i = read_int16_t_little_endian(context->iterator, (size_t) r1.i);", "         push(r1);", "         break;", "       case OP_INT32:", "         pop(r1);", "         r1.i = read_int32_t_little_endian(context->iterator, (size_t) r1.i);", "         push(r1);", "         break;", "       case OP_UINT8:", "         pop(r1);", "         r1.i = read_uint8_t_little_endian(context->iterator, (size_t) r1.i);", "         push(r1);", "         break;", "       case OP_UINT16:", "         pop(r1);", "         r1.i = read_uint16_t_little_endian(context->iterator, (size_t) r1.i);", "         push(r1);", "         break;", "       case OP_UINT32:", "         pop(r1);", "         r1.i = read_uint32_t_little_endian(context->iterator, (size_t) r1.i);", "         push(r1);", "         break;", "       case OP_INT8BE:", "         pop(r1);", "         r1.i = read_int8_t_big_endian(context->iterator, (size_t) r1.i);", "         push(r1);", "         break;", "       case OP_INT16BE:", "         pop(r1);", "         r1.i = read_int16_t_big_endian(context->iterator, (size_t) r1.i);", "         push(r1);", "         break;", "       case OP_INT32BE:", "         pop(r1);", "         r1.i = read_int32_t_big_endian(context->iterator, (size_t) r1.i);", "         push(r1);", "         break;", "       case OP_UINT8BE:", "         pop(r1);", "         r1.i = read_uint8_t_big_endian(context->iterator, (size_t) r1.i);", "         push(r1);", "         break;", "       case OP_UINT16BE:", "         pop(r1);", "         r1.i = read_uint16_t_big_endian(context->iterator, (size_t) r1.i);", "         push(r1);", "         break;", "       case OP_UINT32BE:", "         pop(r1);", "         r1.i = read_uint32_t_big_endian(context->iterator, (size_t) r1.i);", "         push(r1);", "         break;", "       case OP_CONTAINS:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r1);", "         ensure_defined(r2);", "         r1.i = memmem(r1.ss->c_string, r1.ss->length,", "                       r2.ss->c_string, r2.ss->length) != NULL;", "         push(r1);", "         break;", "       case OP_IMPORT:", "         r1.i = *(uint64_t*)(ip + 1);", "         ip += sizeof(uint64_t);", "         result = yr_modules_load((char*) r1.p, context);", "         if (result != ERROR_SUCCESS)", "           stop = TRUE;", "         break;", "       case OP_MATCHES:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         if (r1.ss->length == 0)", "         {", "           r1.i = FALSE;", "           push(r1);", "           break;", "         }", "         result = yr_re_exec(", "           (uint8_t*) r2.re->code,", "           (uint8_t*) r1.ss->c_string,", "           r1.ss->length,", "           0,", "           r2.re->flags | RE_FLAGS_SCAN,", "           NULL,", "           NULL,", "           &found);", "         if (result != ERROR_SUCCESS)", "           stop = TRUE;", "         r1.i = found >= 0;", "         push(r1);", "         break;", "       case OP_INT_TO_DBL:", "         r1.i = *(uint64_t*)(ip + 1);", "         ip += sizeof(uint64_t);", "         r2 = stack[sp - r1.i];", "         if (is_undef(r2))", "           stack[sp - r1.i].i = UNDEFINED;", "         else", "           stack[sp - r1.i].d = (double) r2.i;", "         break;", "       case OP_STR_TO_BOOL:", "         pop(r1);", "         ensure_defined(r1);", "         r1.i = r1.ss->length > 0;", "         push(r1);", "         break;", "       case OP_INT_EQ:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.i = r1.i == r2.i;", "         push(r1);", "         break;", "       case OP_INT_NEQ:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.i = r1.i != r2.i;", "         push(r1);", "         break;", "       case OP_INT_LT:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.i = r1.i < r2.i;", "         push(r1);", "         break;", "       case OP_INT_GT:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.i = r1.i > r2.i;", "         push(r1);", "         break;", "       case OP_INT_LE:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.i = r1.i <= r2.i;", "         push(r1);", "         break;", "       case OP_INT_GE:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.i = r1.i >= r2.i;", "         push(r1);", "         break;", "       case OP_INT_ADD:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.i = r1.i + r2.i;", "         push(r1);", "         break;", "       case OP_INT_SUB:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.i = r1.i - r2.i;", "         push(r1);", "         break;", "       case OP_INT_MUL:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.i = r1.i * r2.i;", "         push(r1);", "         break;", "       case OP_INT_DIV:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         if (r2.i != 0)", "           r1.i = r1.i / r2.i;", "         else", "           r1.i = UNDEFINED;", "         push(r1);", "         break;", "       case OP_INT_MINUS:", "         pop(r1);", "         ensure_defined(r1);", "         r1.i = -r1.i;", "         push(r1);", "         break;", "       case OP_DBL_LT:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.i = r1.d < r2.d;", "         push(r1);", "         break;", "       case OP_DBL_GT:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.i = r1.d > r2.d;", "         push(r1);", "         break;", "       case OP_DBL_LE:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.i = r1.d <= r2.d;", "         push(r1);", "         break;", "       case OP_DBL_GE:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.i = r1.d >= r2.d;", "         push(r1);", "         break;", "       case OP_DBL_EQ:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.i = r1.d == r2.d;", "         push(r1);", "         break;", "       case OP_DBL_NEQ:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.i = r1.d != r2.d;", "         push(r1);", "         break;", "       case OP_DBL_ADD:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.d = r1.d + r2.d;", "         push(r1);", "         break;", "       case OP_DBL_SUB:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.d = r1.d - r2.d;", "         push(r1);", "         break;", "       case OP_DBL_MUL:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.d = r1.d * r2.d;", "         push(r1);", "         break;", "       case OP_DBL_DIV:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r2);", "         ensure_defined(r1);", "         r1.d = r1.d / r2.d;", "         push(r1);", "         break;", "       case OP_DBL_MINUS:", "         pop(r1);", "         ensure_defined(r1);", "         r1.d = -r1.d;", "         push(r1);", "         break;", "       case OP_STR_EQ:", "       case OP_STR_NEQ:", "       case OP_STR_LT:", "       case OP_STR_LE:", "       case OP_STR_GT:", "       case OP_STR_GE:", "         pop(r2);", "         pop(r1);", "         ensure_defined(r1);", "         ensure_defined(r2);", "         switch(*ip)", "         {", "           case OP_STR_EQ:", "             r1.i = (sized_string_cmp(r1.ss, r2.ss) == 0);", "             break;", "           case OP_STR_NEQ:", "             r1.i = (sized_string_cmp(r1.ss, r2.ss) != 0);", "             break;", "           case OP_STR_LT:", "             r1.i = (sized_string_cmp(r1.ss, r2.ss) < 0);", "             break;", "           case OP_STR_LE:", "             r1.i = (sized_string_cmp(r1.ss, r2.ss) <= 0);", "             break;", "           case OP_STR_GT:", "             r1.i = (sized_string_cmp(r1.ss, r2.ss) > 0);", "             break;", "           case OP_STR_GE:", "             r1.i = (sized_string_cmp(r1.ss, r2.ss) >= 0);", "             break;", "         }", "         push(r1);", "         break;", "       default:", "         assert(FALSE);", "     }", "     if (timeout > 0)   ", "     {", "       if (++cycle == 10)", "       {", "         if (difftime(time(NULL), start_time) > timeout)", "         {", "           #ifdef PROFILING_ENABLED", "           assert(current_rule != NULL);", "           current_rule->clock_ticks += clock() - start;", "           #endif", "           result = ERROR_SCAN_TIMEOUT;", "           stop = TRUE;", "         }", "         cycle = 0;", "       }", "     }", "      ip++;", "    }", "   obj_ptr = (YR_OBJECT**) yr_arena_base_address(obj_arena);", "   while (obj_ptr != NULL)", "   {", "     yr_object_destroy(*obj_ptr);", "     obj_ptr = (YR_OBJECT**) yr_arena_next_address(", "         obj_arena, obj_ptr, sizeof(YR_OBJECT*));", "   }", "   yr_arena_destroy(obj_arena);", "    yr_modules_unload_all(context);", "    yr_free(stack);", "   return result;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": [" int jas_stream_write(jas_stream_t *stream, const void *buf, int cnt)", " {", "  \tint n;", "  \tconst char *bufptr;", " \tif (cnt < 0) {", " \t\tjas_deprecated(\"negative count for jas_stream_write\");", " \t}", "  \tbufptr = buf;", "  \tn = 0;", " \twhile (n < cnt) {", " \t\tif (jas_stream_putc(stream, *bufptr) == EOF) {", " \t\t\treturn n;", " \t\t}", " \t\t++bufptr;", " \t\t++n;", " \t}", " \treturn n;", " }"], "ner_tags": [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" tPacketIndicationType ParaNdis_PrepareReceivedPacket(", "     PARANDIS_ADAPTER *pContext,", "     pRxNetDescriptor pBuffersDesc,", "     PUINT            pnCoalescedSegmentsCount)", " {", "     PMDL pMDL = pBuffersDesc->Holder;", "     PNET_BUFFER_LIST pNBL = NULL;", "     *pnCoalescedSegmentsCount = 1;", "     if (pMDL)", "     {", "         ULONG nBytesStripped = 0;", "         PNET_PACKET_INFO pPacketInfo = &pBuffersDesc->PacketInfo;", "         if (pContext->ulPriorityVlanSetting && pPacketInfo->hasVlanHeader)", "         {", "             nBytesStripped = ParaNdis_StripVlanHeaderMoveHead(pPacketInfo);", "         }", "         ParaNdis_PadPacketToMinimalLength(pPacketInfo);", "         ParaNdis_AdjustRxBufferHolderLength(pBuffersDesc, nBytesStripped);", "         pNBL = NdisAllocateNetBufferAndNetBufferList(pContext->BufferListsPool, 0, 0, pMDL, nBytesStripped, pPacketInfo->dataLength);", "         if (pNBL)", "         {", "             virtio_net_hdr_basic *pHeader = (virtio_net_hdr_basic *) pBuffersDesc->PhysicalPages[0].Virtual;", "             tChecksumCheckResult csRes;", "             pNBL->SourceHandle = pContext->MiniportHandle;", "             NBLSetRSSInfo(pContext, pNBL, pPacketInfo);", "             NBLSet8021QInfo(pContext, pNBL, pPacketInfo);", "             pNBL->MiniportReserved[0] = pBuffersDesc;", " #if PARANDIS_SUPPORT_RSC", "             if(pHeader->gso_type != VIRTIO_NET_HDR_GSO_NONE)", "             {", "                 *pnCoalescedSegmentsCount = PktGetTCPCoalescedSegmentsCount(pPacketInfo, pContext->MaxPacketSize.nMaxDataSize);", "                 NBLSetRSCInfo(pContext, pNBL, pPacketInfo, *pnCoalescedSegmentsCount);", "             }", "             else", " #endif", "             {", "                 csRes = ParaNdis_CheckRxChecksum(", "                     pContext,", "                      pHeader->flags,", "                      &pBuffersDesc->PhysicalPages[PARANDIS_FIRST_RX_DATA_PAGE],", "                      pPacketInfo->dataLength,", "                    nBytesStripped);", "                     nBytesStripped, TRUE);", "                  if (csRes.value)", "                  {", "                      NDIS_TCP_IP_CHECKSUM_NET_BUFFER_LIST_INFO qCSInfo;", "                     qCSInfo.Value = NULL;", "                     qCSInfo.Receive.IpChecksumFailed = csRes.flags.IpFailed;", "                     qCSInfo.Receive.IpChecksumSucceeded = csRes.flags.IpOK;", "                     qCSInfo.Receive.TcpChecksumFailed = csRes.flags.TcpFailed;", "                     qCSInfo.Receive.TcpChecksumSucceeded = csRes.flags.TcpOK;", "                     qCSInfo.Receive.UdpChecksumFailed = csRes.flags.UdpFailed;", "                     qCSInfo.Receive.UdpChecksumSucceeded = csRes.flags.UdpOK;", "                     NET_BUFFER_LIST_INFO(pNBL, TcpIpChecksumNetBufferListInfo) = qCSInfo.Value;", "                     DPrintf(1, (\"Reporting CS %X->%X\\n\", csRes.value, (ULONG)(ULONG_PTR)qCSInfo.Value));", "                 }", "             }", "             pNBL->Status = NDIS_STATUS_SUCCESS;", " #if defined(ENABLE_HISTORY_LOG)", "             {", "                 tTcpIpPacketParsingResult packetReview = ParaNdis_CheckSumVerify(", "                     RtlOffsetToPointer(pPacketInfo->headersBuffer, ETH_HEADER_SIZE),", "                     pPacketInfo->dataLength,", "                     pcrIpChecksum | pcrTcpChecksum | pcrUdpChecksum,", "                     __FUNCTION__", "                     );", "                 ParaNdis_DebugHistory(pContext, hopPacketReceived, pNBL, pPacketInfo->dataLength, (ULONG)(ULONG_PTR)qInfo.Value, packetReview.value);", "             }", " #endif", "         }", "     }", "     return pNBL;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" ProcRenderSetPictureFilter(ClientPtr client)", " {", "     REQUEST(xRenderSetPictureFilterReq);", "     PicturePtr pPicture;", "     int result;", "     xFixed *params;", "     int nparams;", "     char *name;", "     REQUEST_AT_LEAST_SIZE(xRenderSetPictureFilterReq);", "     VERIFY_PICTURE(pPicture, stuff->picture, client, DixSetAttrAccess);", "      name = (char *) (stuff + 1);", "      params = (xFixed *) (name + pad_to_int32(stuff->nbytes));", "      nparams = ((xFixed *) stuff + client->req_len) - params;", "     if (nparams < 0)", " \treturn BadLength;", "      result = SetPictureFilter(pPicture, name, stuff->nbytes, params, nparams);", "      return result;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0]}
{"tokens": [" jas_matrix_t *jas_seq2d_create(int xstart, int ystart, int xend, int yend)", " jas_matrix_t *jas_seq2d_create(jas_matind_t xstart, jas_matind_t ystart,", "   jas_matind_t xend, jas_matind_t yend)", "  {", "  \tjas_matrix_t *matrix;", "  \tassert(xstart <= xend && ystart <= yend);", " \tif (!(matrix = jas_matrix_create(yend - ystart, xend - xstart))) {", " \t\treturn 0;", " \t}", " \tmatrix->xstart_ = xstart;", " \tmatrix->ystart_ = ystart;", " \tmatrix->xend_ = xend;", " \tmatrix->yend_ = yend;", "  \treturn matrix;", "  }"], "ner_tags": [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" tChecksumCheckResult ParaNdis_CheckRxChecksum(", "                                             PARANDIS_ADAPTER *pContext,", "                                              ULONG virtioFlags,", "                                              tCompletePhysicalAddress *pPacketPages,", "                                              ULONG ulPacketLength,", "                                            ULONG ulDataOffset)", "                                             ULONG ulDataOffset,", "                                             BOOLEAN verifyLength)", "  {", "      tOffloadSettingsFlags f = pContext->Offload.flags;", "      tChecksumCheckResult res;", "     tTcpIpPacketParsingResult ppr;", "     ULONG flagsToCalculate = 0;", "     res.value = 0;", "     if (f.fRxIPChecksum) flagsToCalculate |= pcrIpChecksum;  ", "     if (!(virtioFlags & VIRTIO_NET_HDR_F_DATA_VALID))", "     {", "         if (virtioFlags & VIRTIO_NET_HDR_F_NEEDS_CSUM)", "         {", "             flagsToCalculate |= pcrFixXxpChecksum | pcrTcpChecksum | pcrUdpChecksum;", "         }", "         else", "         {", "             if (f.fRxTCPChecksum) flagsToCalculate |= pcrTcpV4Checksum;", "             if (f.fRxUDPChecksum) flagsToCalculate |= pcrUdpV4Checksum;", "             if (f.fRxTCPv6Checksum) flagsToCalculate |= pcrTcpV6Checksum;", "             if (f.fRxUDPv6Checksum) flagsToCalculate |= pcrUdpV6Checksum;", "          }", "      }", "    ppr = ParaNdis_CheckSumVerify(pPacketPages, ulPacketLength - ETH_HEADER_SIZE, ulDataOffset + ETH_HEADER_SIZE, flagsToCalculate, __FUNCTION__);", "     ppr = ParaNdis_CheckSumVerify(pPacketPages, ulPacketLength - ETH_HEADER_SIZE, ulDataOffset + ETH_HEADER_SIZE, flagsToCalculate,", "         verifyLength, __FUNCTION__);", "      if (ppr.ipCheckSum == ppresIPTooShort || ppr.xxpStatus == ppresXxpIncomplete)", "      {", "         res.flags.IpOK = FALSE;", "         res.flags.IpFailed = TRUE;", "         return res;", "     }", "     if (virtioFlags & VIRTIO_NET_HDR_F_DATA_VALID)", "     {", "         pContext->extraStatistics.framesRxCSHwOK++;", "         ppr.xxpCheckSum = ppresCSOK;", "     }", "     if (ppr.ipStatus == ppresIPV4 && !ppr.IsFragment)", "     {", "         if (f.fRxIPChecksum)", "         {", "             res.flags.IpOK =  ppr.ipCheckSum == ppresCSOK;", "             res.flags.IpFailed = ppr.ipCheckSum == ppresCSBad;", "         }", "         if(ppr.xxpStatus == ppresXxpKnown)", "         {", "             if(ppr.TcpUdp == ppresIsTCP)  ", "             {", "                 if (f.fRxTCPChecksum)", "                 {", "                     res.flags.TcpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS;", "                     res.flags.TcpFailed = !res.flags.TcpOK;", "                 }", "             }", "             else  ", "             {", "                 if (f.fRxUDPChecksum)", "                 {", "                     res.flags.UdpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS;", "                     res.flags.UdpFailed = !res.flags.UdpOK;", "                 }", "             }", "         }", "     }", "     else if (ppr.ipStatus == ppresIPV6)", "     {", "         if(ppr.xxpStatus == ppresXxpKnown)", "         {", "             if(ppr.TcpUdp == ppresIsTCP)  ", "             {", "                 if (f.fRxTCPv6Checksum)", "                 {", "                     res.flags.TcpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS;", "                     res.flags.TcpFailed = !res.flags.TcpOK;", "                 }", "             }", "             else  ", "             {", "                 if (f.fRxUDPv6Checksum)", "                 {", "                     res.flags.UdpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS;", "                     res.flags.UdpFailed = !res.flags.UdpOK;", "                 }", "             }", "         }", "     }", "     return res;", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" GF_Err cat_multiple_files(GF_ISOFile *dest, char *fileName, u32 import_flags, Double force_fps, u32 frames_per_sample, char *tmp_dir, Bool force_cat, Bool align_timelines, Bool allow_add_in_command)", " {", " \tCATEnum cat_enum;", " \tchar *sep;", " \tcat_enum.dest = dest;", " \tcat_enum.import_flags = import_flags;", " \tcat_enum.force_fps = force_fps;", " \tcat_enum.frames_per_sample = frames_per_sample;", " \tcat_enum.tmp_dir = tmp_dir;", " \tcat_enum.force_cat = force_cat;", "  \tcat_enum.align_timelines = align_timelines;", "  \tcat_enum.allow_add_in_command = allow_add_in_command;", " \tif (strlen(fileName) >= sizeof(cat_enum.szPath)) {", " \t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"File name %s is too long.\\n\", fileName));", " \t\treturn GF_NOT_SUPPORTED;", " \t}", "  \tstrcpy(cat_enum.szPath, fileName);", "  \tsep = strrchr(cat_enum.szPath, GF_PATH_SEPARATOR);", "  \tif (!sep) sep = strrchr(cat_enum.szPath, '/');", "  \tif (!sep) {", "  \t\tstrcpy(cat_enum.szPath, \".\");", " \t\tif (strlen(fileName) >= sizeof(cat_enum.szRad1)) {", " \t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"File name %s is too long.\\n\", fileName));", " \t\t\treturn GF_NOT_SUPPORTED;", " \t\t}", "  \t\tstrcpy(cat_enum.szRad1, fileName);", "  \t} else {", " \t\tif (strlen(sep + 1) >= sizeof(cat_enum.szRad1)) {", " \t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"File name %s is too long.\\n\", (sep + 1)));", " \t\t\treturn GF_NOT_SUPPORTED;", " \t\t}", "  \t\tstrcpy(cat_enum.szRad1, sep+1);", "  \t\tsep[0] = 0;", "  \t}", "  \tsep = strchr(cat_enum.szRad1, '*');", " \tif (strlen(sep + 1) >= sizeof(cat_enum.szRad2)) {", " \t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"File name %s is too long.\\n\", (sep + 1)));", " \t\treturn GF_NOT_SUPPORTED;", " \t}", "  \tstrcpy(cat_enum.szRad2, sep+1);", "  \tsep[0] = 0;", "  \tsep = strchr(cat_enum.szRad2, '%');", "  \tif (!sep) sep = strchr(cat_enum.szRad2, '#');", "  \tif (!sep) sep = strchr(cat_enum.szRad2, ':');", "  \tstrcpy(cat_enum.szOpt, \"\");", "  \tif (sep) {", " \t\tif (strlen(sep) >= sizeof(cat_enum.szOpt)) {", " \t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Invalid option: %s.\\n\", sep));", " \t\t\treturn GF_NOT_SUPPORTED;", " \t\t}", "  \t\tstrcpy(cat_enum.szOpt, sep);", "  \t\tsep[0] = 0;", "  \t}", " \treturn gf_enum_directory(cat_enum.szPath, 0, cat_enumerate, &cat_enum, NULL);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" void vrend_clear(struct vrend_context *ctx,", "                  unsigned buffers,", "                  const union pipe_color_union *color,", "                  double depth, unsigned stencil)", " {", "    GLbitfield bits = 0;", "    if (ctx->in_error)", "       return;", "    if (ctx->ctx_switch_pending)", "       vrend_finish_context_switch(ctx);", "    glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, ctx->sub->fb_id);", "    vrend_update_frontface_state(ctx);", "    if (ctx->sub->stencil_state_dirty)", "       vrend_update_stencil_state(ctx);", "    if (ctx->sub->scissor_state_dirty)", "       vrend_update_scissor_state(ctx);", "    if (ctx->sub->viewport_state_dirty)", "       vrend_update_viewport_state(ctx);", "    vrend_use_program(ctx, 0);", "    if (buffers & PIPE_CLEAR_COLOR) {", "       if (ctx->sub->nr_cbufs && ctx->sub->surf[0] && vrend_format_is_emulated_alpha(ctx->sub->surf[0]->format)) {", "          glClearColor(color->f[3], 0.0, 0.0, 0.0);", "       } else {", "          glClearColor(color->f[0], color->f[1], color->f[2], color->f[3]);", "       }", "    }", "    if (buffers & PIPE_CLEAR_DEPTH) {", "       glDepthMask(GL_TRUE);", "       glClearDepth(depth);", "    }", "    if (buffers & PIPE_CLEAR_STENCIL)", "       glClearStencil(stencil);", "    if (buffers & PIPE_CLEAR_COLOR) {", "       uint32_t mask = 0;", "       int i;", "       for (i = 0; i < ctx->sub->nr_cbufs; i++) {", "          if (ctx->sub->surf[i])", "             mask |= (1 << i);", "       }", "       if (mask != (buffers >> 2)) {", "           mask = buffers >> 2;", "           while (mask) {", "              i = u_bit_scan(&mask);", "            if (util_format_is_pure_uint(ctx->sub->surf[i]->format))", "             if (i < PIPE_MAX_COLOR_BUFS && ctx->sub->surf[i] && util_format_is_pure_uint(ctx->sub->surf[i] && ctx->sub->surf[i]->format))", "                 glClearBufferuiv(GL_COLOR,", "                                  i, (GLuint *)color);", "            else if (util_format_is_pure_sint(ctx->sub->surf[i]->format))", "             else if (i < PIPE_MAX_COLOR_BUFS && ctx->sub->surf[i] && util_format_is_pure_sint(ctx->sub->surf[i] && ctx->sub->surf[i]->format))", "                 glClearBufferiv(GL_COLOR,", "                                  i, (GLint *)color);", "              else", "                glClearBufferfv(GL_COLOR,", "                                 i, (GLfloat *)color);", "          }", "       }", "       else", "          bits |= GL_COLOR_BUFFER_BIT;", "    }", "    if (buffers & PIPE_CLEAR_DEPTH)", "       bits |= GL_DEPTH_BUFFER_BIT;", "    if (buffers & PIPE_CLEAR_STENCIL)", "       bits |= GL_STENCIL_BUFFER_BIT;", "    if (bits)", "       glClear(bits);", "    if (buffers & PIPE_CLEAR_DEPTH)", "       if (!ctx->sub->dsa_state.depth.writemask)", "          glDepthMask(GL_FALSE);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int jpc_bitstream_putbits(jpc_bitstream_t *bitstream, int n, long v)", " {", " \tint m;", "\tassert(n >= 0 && n < 32);", " \tif (n < 0 || n >= 32) {", " \t\treturn EOF;", " \t}", "  \tassert(!(v & (~JAS_ONES(n))));", " \tm = n - 1;", " \twhile (--n >= 0) {", " \t\tif (jpc_bitstream_putbit(bitstream, (v >> m) & 1) == EOF) {", " \t\t\treturn EOF;", " \t\t}", " \t\tv <<= 1;", " \t}", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" ProcXFixesSetCursorName(ClientPtr client)", " {", "     CursorPtr pCursor;", "     char *tchar;", "     REQUEST(xXFixesSetCursorNameReq);", "      REQUEST(xXFixesSetCursorNameReq);", "      Atom atom;", "    REQUEST_AT_LEAST_SIZE(xXFixesSetCursorNameReq);", "     REQUEST_FIXED_SIZE(xXFixesSetCursorNameReq, stuff->nbytes);", "      VERIFY_CURSOR(pCursor, stuff->cursor, client, DixSetAttrAccess);", "      tchar = (char *) &stuff[1];", "      atom = MakeAtom(tchar, stuff->nbytes, TRUE);", "         return BadAlloc;", "     pCursor->name = atom;", "     return Success;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  findoprnd(ITEM *ptr, int32 *pos)", "  {", " \tcheck_stack_depth();", "  \tif (ptr[*pos].type == VAL || ptr[*pos].type == VALTRUE)", "  \t{", "  \t\tptr[*pos].left = 0;", " \t\t(*pos)++;", " \t}", " \telse if (ptr[*pos].val == (int32) '!')", " \t{", " \t\tptr[*pos].left = 1;", " \t\t(*pos)++;", " \t\tfindoprnd(ptr, pos);", " \t}", " \telse", " \t{", " \t\tITEM\t   *curitem = &ptr[*pos];", " \t\tint32\t\ttmp = *pos;", " \t\t(*pos)++;", " \t\tfindoprnd(ptr, pos);", " \t\tcuritem->left = *pos - tmp;", " \t\tfindoprnd(ptr, pos);", " \t}", " }"], "ner_tags": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void avcodec_align_dimensions2(AVCodecContext *s, int *width, int *height,", "                                int linesize_align[AV_NUM_DATA_POINTERS])", " {", "     int i;", "     int w_align = 1;", "     int h_align = 1;", "     AVPixFmtDescriptor const *desc = av_pix_fmt_desc_get(s->pix_fmt);", "     if (desc) {", "         w_align = 1 << desc->log2_chroma_w;", "         h_align = 1 << desc->log2_chroma_h;", "     }", "     switch (s->pix_fmt) {", "     case AV_PIX_FMT_YUV420P:", "     case AV_PIX_FMT_YUYV422:", "     case AV_PIX_FMT_YVYU422:", "     case AV_PIX_FMT_UYVY422:", "     case AV_PIX_FMT_YUV422P:", "     case AV_PIX_FMT_YUV440P:", "     case AV_PIX_FMT_YUV444P:", "     case AV_PIX_FMT_GBRP:", "     case AV_PIX_FMT_GBRAP:", "     case AV_PIX_FMT_GRAY8:", "     case AV_PIX_FMT_GRAY16BE:", "     case AV_PIX_FMT_GRAY16LE:", "     case AV_PIX_FMT_YUVJ420P:", "     case AV_PIX_FMT_YUVJ422P:", "     case AV_PIX_FMT_YUVJ440P:", "     case AV_PIX_FMT_YUVJ444P:", "     case AV_PIX_FMT_YUVA420P:", "     case AV_PIX_FMT_YUVA422P:", "     case AV_PIX_FMT_YUVA444P:", "     case AV_PIX_FMT_YUV420P9LE:", "     case AV_PIX_FMT_YUV420P9BE:", "     case AV_PIX_FMT_YUV420P10LE:", "     case AV_PIX_FMT_YUV420P10BE:", "     case AV_PIX_FMT_YUV420P12LE:", "     case AV_PIX_FMT_YUV420P12BE:", "     case AV_PIX_FMT_YUV420P14LE:", "     case AV_PIX_FMT_YUV420P14BE:", "     case AV_PIX_FMT_YUV420P16LE:", "     case AV_PIX_FMT_YUV420P16BE:", "     case AV_PIX_FMT_YUVA420P9LE:", "     case AV_PIX_FMT_YUVA420P9BE:", "     case AV_PIX_FMT_YUVA420P10LE:", "     case AV_PIX_FMT_YUVA420P10BE:", "     case AV_PIX_FMT_YUVA420P16LE:", "     case AV_PIX_FMT_YUVA420P16BE:", "     case AV_PIX_FMT_YUV422P9LE:", "     case AV_PIX_FMT_YUV422P9BE:", "     case AV_PIX_FMT_YUV422P10LE:", "     case AV_PIX_FMT_YUV422P10BE:", "     case AV_PIX_FMT_YUV422P12LE:", "     case AV_PIX_FMT_YUV422P12BE:", "     case AV_PIX_FMT_YUV422P14LE:", "     case AV_PIX_FMT_YUV422P14BE:", "     case AV_PIX_FMT_YUV422P16LE:", "     case AV_PIX_FMT_YUV422P16BE:", "     case AV_PIX_FMT_YUVA422P9LE:", "     case AV_PIX_FMT_YUVA422P9BE:", "     case AV_PIX_FMT_YUVA422P10LE:", "     case AV_PIX_FMT_YUVA422P10BE:", "     case AV_PIX_FMT_YUVA422P16LE:", "     case AV_PIX_FMT_YUVA422P16BE:", "     case AV_PIX_FMT_YUV440P10LE:", "     case AV_PIX_FMT_YUV440P10BE:", "     case AV_PIX_FMT_YUV440P12LE:", "     case AV_PIX_FMT_YUV440P12BE:", "     case AV_PIX_FMT_YUV444P9LE:", "     case AV_PIX_FMT_YUV444P9BE:", "     case AV_PIX_FMT_YUV444P10LE:", "     case AV_PIX_FMT_YUV444P10BE:", "     case AV_PIX_FMT_YUV444P12LE:", "     case AV_PIX_FMT_YUV444P12BE:", "     case AV_PIX_FMT_YUV444P14LE:", "     case AV_PIX_FMT_YUV444P14BE:", "     case AV_PIX_FMT_YUV444P16LE:", "     case AV_PIX_FMT_YUV444P16BE:", "     case AV_PIX_FMT_YUVA444P9LE:", "     case AV_PIX_FMT_YUVA444P9BE:", "     case AV_PIX_FMT_YUVA444P10LE:", "     case AV_PIX_FMT_YUVA444P10BE:", "     case AV_PIX_FMT_YUVA444P16LE:", "     case AV_PIX_FMT_YUVA444P16BE:", "     case AV_PIX_FMT_GBRP9LE:", "     case AV_PIX_FMT_GBRP9BE:", "     case AV_PIX_FMT_GBRP10LE:", "     case AV_PIX_FMT_GBRP10BE:", "     case AV_PIX_FMT_GBRP12LE:", "     case AV_PIX_FMT_GBRP12BE:", "     case AV_PIX_FMT_GBRP14LE:", "     case AV_PIX_FMT_GBRP14BE:", "     case AV_PIX_FMT_GBRP16LE:", "     case AV_PIX_FMT_GBRP16BE:", "     case AV_PIX_FMT_GBRAP12LE:", "     case AV_PIX_FMT_GBRAP12BE:", "     case AV_PIX_FMT_GBRAP16LE:", "     case AV_PIX_FMT_GBRAP16BE:", "         w_align = 16;  ", "         h_align = 16 * 2;  ", "         break;", "     case AV_PIX_FMT_YUV411P:", "     case AV_PIX_FMT_YUVJ411P:", "     case AV_PIX_FMT_UYYVYY411:", "         w_align = 32;", "         h_align = 16 * 2;", "         break;", "     case AV_PIX_FMT_YUV410P:", "         if (s->codec_id == AV_CODEC_ID_SVQ1) {", "             w_align = 64;", "             h_align = 64;", "         }", "         break;", "     case AV_PIX_FMT_RGB555:", "         if (s->codec_id == AV_CODEC_ID_RPZA) {", "              w_align = 4;", "              h_align = 4;", "          }", "         if (s->codec_id == AV_CODEC_ID_INTERPLAY_VIDEO) {", "             w_align = 8;", "             h_align = 8;", "         }", "          break;", "      case AV_PIX_FMT_PAL8:", "      case AV_PIX_FMT_BGR8:", "     case AV_PIX_FMT_RGB8:", "         if (s->codec_id == AV_CODEC_ID_SMC ||", "             s->codec_id == AV_CODEC_ID_CINEPAK) {", "              w_align = 4;", "              h_align = 4;", "          }", "        if (s->codec_id == AV_CODEC_ID_JV) {", "         if (s->codec_id == AV_CODEC_ID_JV ||", "             s->codec_id == AV_CODEC_ID_INTERPLAY_VIDEO) {", "              w_align = 8;", "              h_align = 8;", "          }", "         break;", "     case AV_PIX_FMT_BGR24:", "         if ((s->codec_id == AV_CODEC_ID_MSZH) ||", "             (s->codec_id == AV_CODEC_ID_ZLIB)) {", "             w_align = 4;", "             h_align = 4;", "         }", "         break;", "     case AV_PIX_FMT_RGB24:", "         if (s->codec_id == AV_CODEC_ID_CINEPAK) {", "             w_align = 4;", "             h_align = 4;", "         }", "         break;", "     default:", "         break;", "     }", "     if (s->codec_id == AV_CODEC_ID_IFF_ILBM) {", "         w_align = FFMAX(w_align, 8);", "     }", "     *width  = FFALIGN(*width, w_align);", "     *height = FFALIGN(*height, h_align);", "     if (s->codec_id == AV_CODEC_ID_H264 || s->lowres) {", "         *height += 2;", "         *width = FFMAX(*width, 32);", "     }", "     for (i = 0; i < 4; i++)", "         linesize_align[i] = STRIDE_ALIGN;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" read_Header(struct archive_read *a, struct _7z_header_info *h,", "     int check_header_id)", " {", " \tstruct _7zip *zip = (struct _7zip *)a->format->data;", " \tconst unsigned char *p;", " \tstruct _7z_folder *folders;", " \tstruct _7z_stream_info *si = &(zip->si);", " \tstruct _7zip_entry *entries;", " \tuint32_t folderIndex, indexInFolder;", " \tunsigned i;", " \tint eindex, empty_streams, sindex;", " \tif (check_header_id) {", " \t\tif ((p = header_bytes(a, 1)) == NULL)", " \t\t\treturn (-1);", " \t\tif (*p != kHeader)", " \t\t\treturn (-1);", " \t}", " \tif ((p = header_bytes(a, 1)) == NULL)", " \t\treturn (-1);", " \tif (*p == kArchiveProperties) {", " \t\tfor (;;) {", " \t\t\tuint64_t size;", " \t\t\tif ((p = header_bytes(a, 1)) == NULL)", " \t\t\t\treturn (-1);", " \t\t\tif (*p == 0)", " \t\t\t\tbreak;", " \t\t\tif (parse_7zip_uint64(a, &size) < 0)", " \t\t\t\treturn (-1);", " \t\t}", " \t\tif ((p = header_bytes(a, 1)) == NULL)", " \t\t\treturn (-1);", " \t}", " \tif (*p == kMainStreamsInfo) {", " \t\tif (read_StreamsInfo(a, &(zip->si)) < 0)", " \t\t\treturn (-1);", " \t\tif ((p = header_bytes(a, 1)) == NULL)", " \t\t\treturn (-1);", " \t}", " \tif (*p == kEnd)", " \t\treturn (0);", " \tif (*p != kFilesInfo)", " \t\treturn (-1);", " \tif (parse_7zip_uint64(a, &(zip->numFiles)) < 0)", " \t\treturn (-1);", " \tif (UMAX_ENTRY < zip->numFiles)", " \t\treturn (-1);", " \tzip->entries = calloc((size_t)zip->numFiles, sizeof(*zip->entries));", " \tif (zip->entries == NULL)", " \t\treturn (-1);", " \tentries = zip->entries;", " \tempty_streams = 0;", " \tfor (;;) {", " \t\tint type;", " \t\tuint64_t size;", " \t\tsize_t ll;", " \t\tif ((p = header_bytes(a, 1)) == NULL)", " \t\t\treturn (-1);", " \t\ttype = *p;", " \t\tif (type == kEnd)", " \t\t\tbreak;", " \t\tif (parse_7zip_uint64(a, &size) < 0)", " \t\t\treturn (-1);", " \t\tif (zip->header_bytes_remaining < size)", " \t\t\treturn (-1);", " \t\tll = (size_t)size;", "  \t\tswitch (type) {", "  \t\tcase kEmptyStream:", " \t\t\tif (h->emptyStreamBools != NULL)", " \t\t\t\treturn (-1);", "  \t\t\th->emptyStreamBools = calloc((size_t)zip->numFiles,", "  \t\t\t    sizeof(*h->emptyStreamBools));", "  \t\t\tif (h->emptyStreamBools == NULL)", " \t\t\t\treturn (-1);", " \t\t\tif (read_Bools(", " \t\t\t    a, h->emptyStreamBools, (size_t)zip->numFiles) < 0)", " \t\t\t\treturn (-1);", " \t\t\tempty_streams = 0;", " \t\t\tfor (i = 0; i < zip->numFiles; i++) {", " \t\t\t\tif (h->emptyStreamBools[i])", " \t\t\t\t\tempty_streams++;", " \t\t\t}", " \t\t\tbreak;", " \t\tcase kEmptyFile:", " \t\t\tif (empty_streams <= 0) {", " \t\t\t\tif (header_bytes(a, ll) == NULL)", "  \t\t\t\t\treturn (-1);", "  \t\t\t\tbreak;", "  \t\t\t}", " \t\t\tif (h->emptyFileBools != NULL)", " \t\t\t\treturn (-1);", "  \t\t\th->emptyFileBools = calloc(empty_streams,", "  \t\t\t    sizeof(*h->emptyFileBools));", "  \t\t\tif (h->emptyFileBools == NULL)", " \t\t\t\treturn (-1);", " \t\t\tif (read_Bools(a, h->emptyFileBools, empty_streams) < 0)", " \t\t\t\treturn (-1);", " \t\t\tbreak;", " \t\tcase kAnti:", " \t\t\tif (empty_streams <= 0) {", " \t\t\t\tif (header_bytes(a, ll) == NULL)", "  \t\t\t\t\treturn (-1);", "  \t\t\t\tbreak;", "  \t\t\t}", " \t\t\tif (h->antiBools != NULL)", " \t\t\t\treturn (-1);", "  \t\t\th->antiBools = calloc(empty_streams,", "  \t\t\t    sizeof(*h->antiBools));", "  \t\t\tif (h->antiBools == NULL)", " \t\t\t\treturn (-1);", " \t\t\tif (read_Bools(a, h->antiBools, empty_streams) < 0)", " \t\t\t\treturn (-1);", " \t\t\tbreak;", " \t\tcase kCTime:", " \t\tcase kATime:", " \t\tcase kMTime:", " \t\t\tif (read_Times(a, h, type) < 0)", " \t\t\t\treturn (-1);", " \t\t\tbreak;", " \t\tcase kName:", " \t\t{", " \t\t\tunsigned char *np;", " \t\t\tsize_t nl, nb;", " \t\t\tif ((p = header_bytes(a, 1)) == NULL)", " \t\t\t\treturn (-1);", " \t\t\tll--;", "  \t\t\tif ((ll & 1) || ll < zip->numFiles * 4)", "  \t\t\t\treturn (-1);", " \t\t\tif (zip->entry_names != NULL)", " \t\t\t\treturn (-1);", "  \t\t\tzip->entry_names = malloc(ll);", "  \t\t\tif (zip->entry_names == NULL)", "  \t\t\t\treturn (-1);", " \t\t\tnp = zip->entry_names;", " \t\t\tnb = ll;", " \t\t\twhile (nb) {", " \t\t\t\tsize_t b;", " \t\t\t\tif (nb > UBUFF_SIZE)", " \t\t\t\t\tb = UBUFF_SIZE;", " \t\t\t\telse", " \t\t\t\t\tb = nb;", " \t\t\t\tif ((p = header_bytes(a, b)) == NULL)", " \t\t\t\t\treturn (-1);", " \t\t\t\tmemcpy(np, p, b);", " \t\t\t\tnp += b;", " \t\t\t\tnb -= b;", " \t\t\t}", " \t\t\tnp = zip->entry_names;", " \t\t\tnl = ll;", " \t\t\tfor (i = 0; i < zip->numFiles; i++) {", " \t\t\t\tentries[i].utf16name = np;", " #if defined(_WIN32) && !defined(__CYGWIN__) && defined(_DEBUG)", " \t\t\t\tentries[i].wname = (wchar_t *)np;", " #endif", " \t\t\t\twhile (nl >= 2 && (np[0] || np[1])) {", " \t\t\t\t\tnp += 2;", " \t\t\t\t\tnl -= 2;", " \t\t\t\t}", " \t\t\t\tif (nl < 2)", " \t\t\t\t\treturn (-1); ", " \t\t\t\tentries[i].name_len = np - entries[i].utf16name;", " \t\t\t\tnp += 2;", " \t\t\t\tnl -= 2;", " \t\t\t}", " \t\t\tbreak;", " \t\t}", " \t\tcase kAttributes:", " \t\t{", " \t\t\tint allAreDefined;", "  \t\t\tif ((p = header_bytes(a, 2)) == NULL)", "  \t\t\t\treturn (-1);", "  \t\t\tallAreDefined = *p;", " \t\t\tif (h->attrBools != NULL)", " \t\t\t\treturn (-1);", "  \t\t\th->attrBools = calloc((size_t)zip->numFiles,", "  \t\t\t    sizeof(*h->attrBools));", "  \t\t\tif (h->attrBools == NULL)", " \t\t\t\treturn (-1);", " \t\t\tif (allAreDefined)", " \t\t\t\tmemset(h->attrBools, 1, (size_t)zip->numFiles);", " \t\t\telse {", " \t\t\t\tif (read_Bools(a, h->attrBools,", " \t\t\t\t      (size_t)zip->numFiles) < 0)", " \t\t\t\t\treturn (-1);", " \t\t\t}", " \t\t\tfor (i = 0; i < zip->numFiles; i++) {", " \t\t\t\tif (h->attrBools[i]) {", " \t\t\t\t\tif ((p = header_bytes(a, 4)) == NULL)", " \t\t\t\t\t\treturn (-1);", " \t\t\t\t\tentries[i].attr = archive_le32dec(p);", " \t\t\t\t}", " \t\t\t}", " \t\t\tbreak;", " \t\t}", " \t\tcase kDummy:", " \t\t\tif (ll == 0)", " \t\t\t\tbreak;", " \t\tdefault:", " \t\t\tif (header_bytes(a, ll) == NULL)", " \t\t\t\treturn (-1);", " \t\t\tbreak;", " \t\t}", " \t}", " \tfolders = si->ci.folders;", " \teindex = sindex = 0;", " \tfolderIndex = indexInFolder = 0;", " \tfor (i = 0; i < zip->numFiles; i++) {", " \t\tif (h->emptyStreamBools == NULL || h->emptyStreamBools[i] == 0)", " \t\t\tentries[i].flg |= HAS_STREAM;", " \t\tentries[i].mode = entries[i].attr >> 16;", " \t\tif (entries[i].flg & HAS_STREAM) {", " \t\t\tif ((size_t)sindex >= si->ss.unpack_streams)", " \t\t\t\treturn (-1);", " \t\t\tif (entries[i].mode == 0)", " \t\t\t\tentries[i].mode = AE_IFREG | 0666;", " \t\t\tif (si->ss.digestsDefined[sindex])", " \t\t\t\tentries[i].flg |= CRC32_IS_SET;", " \t\t\tentries[i].ssIndex = sindex;", " \t\t\tsindex++;", " \t\t} else {", " \t\t\tint dir;", " \t\t\tif (h->emptyFileBools == NULL)", " \t\t\t\tdir = 1;", " \t\t\telse {", " \t\t\t\tif (h->emptyFileBools[eindex])", " \t\t\t\t\tdir = 0;", " \t\t\t\telse", " \t\t\t\t\tdir = 1;", " \t\t\t\teindex++;", " \t\t\t}", " \t\t\tif (entries[i].mode == 0) {", " \t\t\t\tif (dir)", " \t\t\t\t\tentries[i].mode = AE_IFDIR | 0777;", " \t\t\t\telse", " \t\t\t\t\tentries[i].mode = AE_IFREG | 0666;", " \t\t\t} else if (dir &&", " \t\t\t    (entries[i].mode & AE_IFMT) != AE_IFDIR) {", " \t\t\t\tentries[i].mode &= ~AE_IFMT;", " \t\t\t\tentries[i].mode |= AE_IFDIR;", " \t\t\t}", " \t\t\tif ((entries[i].mode & AE_IFMT) == AE_IFDIR &&", " \t\t\t    entries[i].name_len >= 2 &&", " \t\t\t    (entries[i].utf16name[entries[i].name_len-2] != '/' ||", " \t\t\t     entries[i].utf16name[entries[i].name_len-1] != 0)) {", " \t\t\t\tentries[i].utf16name[entries[i].name_len] = '/';", " \t\t\t\tentries[i].utf16name[entries[i].name_len+1] = 0;", " \t\t\t\tentries[i].name_len += 2;", " \t\t\t}", " \t\t\tentries[i].ssIndex = -1;", " \t\t}", " \t\tif (entries[i].attr & 0x01)", " \t\t\tentries[i].mode &= ~0222; ", " \t\tif ((entries[i].flg & HAS_STREAM) == 0 && indexInFolder == 0) {", " \t\t\tentries[i].folderIndex = -1;", " \t\t\tcontinue;", " \t\t}", " \t\tif (indexInFolder == 0) {", " \t\t\tfor (;;) {", " \t\t\t\tif (folderIndex >= si->ci.numFolders)", " \t\t\t\t\treturn (-1);", " \t\t\t\tif (folders[folderIndex].numUnpackStreams)", " \t\t\t\t\tbreak;", " \t\t\t\tfolderIndex++;", " \t\t\t}", " \t\t}", " \t\tentries[i].folderIndex = folderIndex;", " \t\tif ((entries[i].flg & HAS_STREAM) == 0)", " \t\t\tcontinue;", " \t\tindexInFolder++;", " \t\tif (indexInFolder >= folders[folderIndex].numUnpackStreams) {", " \t\t\tfolderIndex++;", " \t\t\tindexInFolder = 0;", " \t\t}", " \t}", " \treturn (0);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int filter_frame(AVFilterLink *inlink, AVFrame *in)", " {", "     unsigned x, y;", "     AVFilterContext *ctx = inlink->dst;", "     VignetteContext *s = ctx->priv;", "     AVFilterLink *outlink = inlink->dst->outputs[0];", "     AVFrame *out;", "     out = ff_get_video_buffer(outlink, outlink->w, outlink->h);", "     if (!out) {", "         av_frame_free(&in);", "         return AVERROR(ENOMEM);", "     }", "     av_frame_copy_props(out, in);", "     if (s->eval_mode == EVAL_MODE_FRAME)", "         update_context(s, inlink, in);", "     if (s->desc->flags & AV_PIX_FMT_FLAG_RGB) {", "         uint8_t       *dst = out->data[0];", "         const uint8_t *src = in ->data[0];", "         const float *fmap = s->fmap;", "         const int dst_linesize = out->linesize[0];", "         const int src_linesize = in ->linesize[0];", "         const int fmap_linesize = s->fmap_linesize;", "         for (y = 0; y < inlink->h; y++) {", "             uint8_t       *dstp = dst;", "             const uint8_t *srcp = src;", "             for (x = 0; x < inlink->w; x++, dstp += 3, srcp += 3) {", "                 const float f = fmap[x];", "                 dstp[0] = av_clip_uint8(srcp[0] * f + get_dither_value(s));", "                 dstp[1] = av_clip_uint8(srcp[1] * f + get_dither_value(s));", "                 dstp[2] = av_clip_uint8(srcp[2] * f + get_dither_value(s));", "             }", "             dst += dst_linesize;", "             src += src_linesize;", "             fmap += fmap_linesize;", "         }", "      } else {", "          int plane;", "        for (plane = 0; plane < 4 && in->data[plane]; plane++) {", "         for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++) {", "              uint8_t       *dst = out->data[plane];", "              const uint8_t *src = in ->data[plane];", "              const float *fmap = s->fmap;", "             const int dst_linesize = out->linesize[plane];", "             const int src_linesize = in ->linesize[plane];", "             const int fmap_linesize = s->fmap_linesize;", "             const int chroma = plane == 1 || plane == 2;", "             const int hsub = chroma ? s->desc->log2_chroma_w : 0;", "             const int vsub = chroma ? s->desc->log2_chroma_h : 0;", "             const int w = FF_CEIL_RSHIFT(inlink->w, hsub);", "             const int h = FF_CEIL_RSHIFT(inlink->h, vsub);", "             for (y = 0; y < h; y++) {", "                 uint8_t *dstp = dst;", "                 const uint8_t *srcp = src;", "                 for (x = 0; x < w; x++) {", "                     const double dv = get_dither_value(s);", "                     if (chroma) *dstp++ = av_clip_uint8(fmap[x << hsub] * (*srcp++ - 127) + 127 + dv);", "                     else        *dstp++ = av_clip_uint8(fmap[x        ] *  *srcp++              + dv);", "                 }", "                 dst += dst_linesize;", "                 src += src_linesize;", "                 fmap += fmap_linesize << vsub;", "             }", "         }", "     }", "     return ff_filter_frame(outlink, out);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void jas_stream_initbuf(jas_stream_t *stream, int bufmode, char *buf,", "   int bufsize)", " {", " \tassert(!stream->bufbase_);", " \tif (bufmode != JAS_STREAM_UNBUF) {", " \t\tif (!buf) {", " \t\t\tif ((stream->bufbase_ = jas_malloc(JAS_STREAM_BUFSIZE +", " \t\t\t  JAS_STREAM_MAXPUTBACK))) {", " \t\t\t\tstream->bufmode_ |= JAS_STREAM_FREEBUF;", " \t\t\t\tstream->bufsize_ = JAS_STREAM_BUFSIZE;", " \t\t\t} else {", " \t\t\t\tstream->bufbase_ = stream->tinybuf_;", " \t\t\t\tstream->bufsize_ = 1;", " \t\t\t}", " \t\t} else {", "  \t\t\tassert(bufsize > JAS_STREAM_MAXPUTBACK);", "\t\t\tstream->bufbase_ = JAS_CAST(uchar *, buf);", " \t\t\tstream->bufbase_ = JAS_CAST(jas_uchar *, buf);", "  \t\t\tstream->bufsize_ = bufsize - JAS_STREAM_MAXPUTBACK;", "  \t\t}", "  \t} else {", " \t\tassert(!buf);", " \t\tstream->bufbase_ = stream->tinybuf_;", " \t\tstream->bufsize_ = 1;", " \t}", " \tstream->bufstart_ = &stream->bufbase_[JAS_STREAM_MAXPUTBACK];", " \tstream->ptr_ = stream->bufstart_;", " \tstream->cnt_ = 0;", " \tstream->bufmode_ |= bufmode & JAS_STREAM_BUFMODEMASK;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" parse_instruction(", "    struct translate_ctx *ctx,", "    boolean has_label )", " {", "    uint i;", "    uint saturate = 0;", "    const struct tgsi_opcode_info *info;", "    struct tgsi_full_instruction inst;", "    const char *cur;", "    uint advance;", "    inst = tgsi_default_full_instruction();", "    eat_opt_white( &ctx->cur );", "    if (*ctx->cur == '(') {", "       uint file;", "       int index;", "       uint swizzle[4];", "       boolean parsed_swizzle;", "       inst.Instruction.Predicate = 1;", "       ctx->cur++;", "       if (*ctx->cur == '!') {", "          ctx->cur++;", "          inst.Predicate.Negate = 1;", "       }", "       if (!parse_register_1d( ctx, &file, &index ))", "          return FALSE;", "       if (parse_optional_swizzle( ctx, swizzle, &parsed_swizzle, 4 )) {", "          if (parsed_swizzle) {", "             inst.Predicate.SwizzleX = swizzle[0];", "             inst.Predicate.SwizzleY = swizzle[1];", "             inst.Predicate.SwizzleZ = swizzle[2];", "             inst.Predicate.SwizzleW = swizzle[3];", "          }", "       }", "       if (*ctx->cur != ')') {", "          report_error( ctx, \"Expected `)'\" );", "          return FALSE;", "       }", "       ctx->cur++;", "    }", "    eat_opt_white( &ctx->cur );", "    for (i = 0; i < TGSI_OPCODE_LAST; i++) {", "       cur = ctx->cur;", "       info = tgsi_get_opcode_info( i );", "       if (match_inst(&cur, &saturate, info)) {", "          if (info->num_dst + info->num_src + info->is_tex == 0) {", "             ctx->cur = cur;", "             break;", "          }", "          else if (*cur == '\\0' || eat_white( &cur )) {", "             ctx->cur = cur;", "             break;", "          }", "       }", "    }", "    if (i == TGSI_OPCODE_LAST) {", "       if (has_label)", "          report_error( ctx, \"Unknown opcode\" );", "       else", "          report_error( ctx, \"Expected `DCL', `IMM' or a label\" );", "       return FALSE;", "    }", "    inst.Instruction.Opcode = i;", "    inst.Instruction.Saturate = saturate;", "    inst.Instruction.NumDstRegs = info->num_dst;", "    inst.Instruction.NumSrcRegs = info->num_src;", "    if (i >= TGSI_OPCODE_SAMPLE && i <= TGSI_OPCODE_GATHER4) {", "       inst.Instruction.Texture = 1;", "       inst.Texture.Texture = TGSI_TEXTURE_UNKNOWN;", "    }", "    for (i = 0; i < info->num_dst + info->num_src + info->is_tex; i++) {", "       if (i > 0) {", "          eat_opt_white( &ctx->cur );", "          if (*ctx->cur != ',') {", "             report_error( ctx, \"Expected `,'\" );", "             return FALSE;", "          }", "          ctx->cur++;", "          eat_opt_white( &ctx->cur );", "       }", "       if (i < info->num_dst) {", "          if (!parse_dst_operand( ctx, &inst.Dst[i] ))", "             return FALSE;", "       }", "       else if (i < info->num_dst + info->num_src) {", "          if (!parse_src_operand( ctx, &inst.Src[i - info->num_dst] ))", "             return FALSE;", "       }", "       else {", "          uint j;", "          for (j = 0; j < TGSI_TEXTURE_COUNT; j++) {", "             if (str_match_nocase_whole( &ctx->cur, tgsi_texture_names[j] )) {", "                inst.Instruction.Texture = 1;", "                inst.Texture.Texture = j;", "                break;", "             }", "          }", "          if (j == TGSI_TEXTURE_COUNT) {", "             report_error( ctx, \"Expected texture target\" );", "             return FALSE;", "          }", "       }", "    }", "     cur = ctx->cur;", "     eat_opt_white( &cur );", "   for (i = 0; inst.Instruction.Texture && *cur == ','; i++) {", "    for (i = 0; inst.Instruction.Texture && *cur == ',' && i < TGSI_FULL_MAX_TEX_OFFSETS; i++) {", "           cur++;", "           eat_opt_white( &cur );", "           ctx->cur = cur;", "          if (!parse_texoffset_operand( ctx, &inst.TexOffsets[i] ))", "             return FALSE;", "          cur = ctx->cur;", "          eat_opt_white( &cur );", "    }", "    inst.Texture.NumOffsets = i;", "    cur = ctx->cur;", "    eat_opt_white( &cur );", "    if (info->is_branch && *cur == ':') {", "       uint target;", "       cur++;", "       eat_opt_white( &cur );", "       if (!parse_uint( &cur, &target )) {", "          report_error( ctx, \"Expected a label\" );", "          return FALSE;", "       }", "       inst.Instruction.Label = 1;", "       inst.Label.Label = target;", "       ctx->cur = cur;", "    }", "    advance = tgsi_build_full_instruction(", "       &inst,", "       ctx->tokens_cur,", "       ctx->header,", "       (uint) (ctx->tokens_end - ctx->tokens_cur) );", "    if (advance == 0)", "       return FALSE;", "    ctx->tokens_cur += advance;", "    return TRUE;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int av_reallocp_array(void *ptr, size_t nmemb, size_t size)", "  {", "      void **ptrptr = ptr;", "      *ptrptr = av_realloc_f(*ptrptr, nmemb, size);", "    if (!*ptrptr && !(nmemb && size))", "     if (!*ptrptr && nmemb && size)", "          return AVERROR(ENOMEM);", "      return 0;", "  }"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 0, 0]}
{"tokens": [" compile_bag_node(BagNode* node, regex_t* reg, ScanEnv* env)", " {", "   int r, len;", "   switch (node->type) {", "   case BAG_MEMORY:", "     r = compile_bag_memory_node(node, reg, env);", "     break;", "   case BAG_OPTION:", "     r = compile_option_node(node, reg, env);", "     break;", "   case BAG_STOP_BACKTRACK:", "     if (NODE_IS_STOP_BT_SIMPLE_REPEAT(node)) {", "       QuantNode* qn = QUANT_(NODE_BAG_BODY(node));", "       r = compile_tree_n_times(NODE_QUANT_BODY(qn), qn->lower, reg, env);", "       if (r != 0) return r;", "       len = compile_length_tree(NODE_QUANT_BODY(qn), reg);", "       if (len < 0) return len;", "       r = add_op(reg, OP_PUSH);", "       if (r != 0) return r;", "       COP(reg)->push.addr = SIZE_INC_OP + len + SIZE_OP_POP_OUT + SIZE_OP_JUMP;", "       r = compile_tree(NODE_QUANT_BODY(qn), reg, env);", "       if (r != 0) return r;", "       r = add_op(reg, OP_POP_OUT);", "       if (r != 0) return r;", "       r = add_op(reg, OP_JUMP);", "       if (r != 0) return r;", "       COP(reg)->jump.addr = -((int )SIZE_OP_PUSH + len + (int )SIZE_OP_POP_OUT);", "     }", "     else {", "       r = add_op(reg, OP_ATOMIC_START);", "       if (r != 0) return r;", "       r = compile_tree(NODE_BAG_BODY(node), reg, env);", "       if (r != 0) return r;", "       r = add_op(reg, OP_ATOMIC_END);", "     }", "     break;", "    case BAG_IF_ELSE:", "      {", "      int cond_len, then_len, jump_len;", "       int cond_len, then_len, else_len, jump_len;", "        Node* cond = NODE_BAG_BODY(node);", "        Node* Then = node->te.Then;", "        Node* Else = node->te.Else;", "       r = add_op(reg, OP_ATOMIC_START);", "       if (r != 0) return r;", "       cond_len = compile_length_tree(cond, reg);", "       if (cond_len < 0) return cond_len;", "       if (IS_NOT_NULL(Then)) {", "         then_len = compile_length_tree(Then, reg);", "         if (then_len < 0) return then_len;", "       }", "        else", "          then_len = 0;", "      jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END;", "      if (IS_NOT_NULL(Else)) jump_len += SIZE_OP_JUMP;", "       jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END + SIZE_OP_JUMP;", "        r = add_op(reg, OP_PUSH);", "        if (r != 0) return r;", "       COP(reg)->push.addr = SIZE_INC_OP + jump_len;", "       r = compile_tree(cond, reg, env);", "       if (r != 0) return r;", "       r = add_op(reg, OP_ATOMIC_END);", "       if (r != 0) return r;", "       if (IS_NOT_NULL(Then)) {", "         r = compile_tree(Then, reg, env);", "         if (r != 0) return r;", "        }", "        if (IS_NOT_NULL(Else)) {", "        int else_len = compile_length_tree(Else, reg);", "        r = add_op(reg, OP_JUMP);", "        if (r != 0) return r;", "        COP(reg)->jump.addr = else_len + SIZE_INC_OP;", "         else_len = compile_length_tree(Else, reg);", "         if (else_len < 0) return else_len;", "       }", "       else", "         else_len = 0;", "       r = add_op(reg, OP_JUMP);", "       if (r != 0) return r;", "       COP(reg)->jump.addr = SIZE_OP_ATOMIC_END + else_len + SIZE_INC_OP;", "       r = add_op(reg, OP_ATOMIC_END);", "       if (r != 0) return r;", "       if (IS_NOT_NULL(Else)) {", "          r = compile_tree(Else, reg, env);", "        }", "      }", "     break;", "   }", "   return r;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int http_open(URLContext *h, const char *uri, int flags,", "                      AVDictionary **options)", " {", "     HTTPContext *s = h->priv_data;", "     int ret;", "     if( s->seekable == 1 )", "         h->is_streamed = 0;", "      else", "          h->is_streamed = 1;", "    s->filesize = -1;", "     s->filesize = UINT64_MAX;", "      s->location = av_strdup(uri);", "      if (!s->location)", "          return AVERROR(ENOMEM);", "     if (options)", "         av_dict_copy(&s->chained_options, *options, 0);", "     if (s->headers) {", "         int len = strlen(s->headers);", "         if (len < 2 || strcmp(\"\\r\\n\", s->headers + len - 2)) {", "             av_log(h, AV_LOG_WARNING,", "                    \"No trailing CRLF found in HTTP header.\\n\");", "             ret = av_reallocp(&s->headers, len + 3);", "             if (ret < 0)", "                 return ret;", "             s->headers[len]     = '\\r';", "             s->headers[len + 1] = '\\n';", "             s->headers[len + 2] = '\\0';", "         }", "     }", "     if (s->listen) {", "         return http_listen(h, uri, flags, options);", "     }", "     ret = http_open_cnx(h, options);", "     if (ret < 0)", "         av_dict_free(&s->chained_options);", "     return ret;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int http_connect(URLContext *h, const char *path, const char *local_path,", "                         const char *hoststr, const char *auth,", "                         const char *proxyauth, int *new_location)", " {", "     HTTPContext *s = h->priv_data;", "      int post, err;", "      char headers[HTTP_HEADERS_SIZE] = \"\";", "      char *authstr = NULL, *proxyauthstr = NULL;", "    int64_t off = s->off;", "     uint64_t off = s->off;", "      int len = 0;", "      const char *method;", "      int send_expect_100 = 0;", "     post = h->flags & AVIO_FLAG_WRITE;", "     if (s->post_data) {", "         post            = 1;", "         s->chunked_post = 0;", "     }", "     if (s->method)", "         method = s->method;", "     else", "         method = post ? \"POST\" : \"GET\";", "     authstr      = ff_http_auth_create_response(&s->auth_state, auth,", "                                                 local_path, method);", "     proxyauthstr = ff_http_auth_create_response(&s->proxy_auth_state, proxyauth,", "                                                 local_path, method);", "     if (post && !s->post_data) {", "         send_expect_100 = s->send_expect_100;", "         if (auth && *auth &&", "             s->auth_state.auth_type == HTTP_AUTH_NONE &&", "             s->http_code != 401)", "             send_expect_100 = 1;", "     }", " #if FF_API_HTTP_USER_AGENT", "     if (strcmp(s->user_agent_deprecated, DEFAULT_USER_AGENT)) {", "         av_log(s, AV_LOG_WARNING, \"the user-agent option is deprecated, please use user_agent option\\n\");", "         s->user_agent = av_strdup(s->user_agent_deprecated);", "     }", " #endif", "     if (!has_header(s->headers, \"\\r\\nUser-Agent: \"))", "         len += av_strlcatf(headers + len, sizeof(headers) - len,", "                            \"User-Agent: %s\\r\\n\", s->user_agent);", "     if (!has_header(s->headers, \"\\r\\nAccept: \"))", "         len += av_strlcpy(headers + len, \"Accept: */*\\r\\n\",", "                           sizeof(headers) - len);", "      if (!has_header(s->headers, \"\\r\\nRange: \") && !post && (s->off > 0 || s->end_off || s->seekable == -1)) {", "          len += av_strlcatf(headers + len, sizeof(headers) - len,", "                           \"Range: bytes=%\"PRId64\"-\", s->off);", "                            \"Range: bytes=%\"PRIu64\"-\", s->off);", "          if (s->end_off)", "              len += av_strlcatf(headers + len, sizeof(headers) - len,", "                                 \"%\"PRId64, s->end_off - 1);", "         len += av_strlcpy(headers + len, \"\\r\\n\",", "                           sizeof(headers) - len);", "     }", "     if (send_expect_100 && !has_header(s->headers, \"\\r\\nExpect: \"))", "         len += av_strlcatf(headers + len, sizeof(headers) - len,", "                            \"Expect: 100-continue\\r\\n\");", "     if (!has_header(s->headers, \"\\r\\nConnection: \")) {", "         if (s->multiple_requests)", "             len += av_strlcpy(headers + len, \"Connection: keep-alive\\r\\n\",", "                               sizeof(headers) - len);", "         else", "             len += av_strlcpy(headers + len, \"Connection: close\\r\\n\",", "                               sizeof(headers) - len);", "     }", "     if (!has_header(s->headers, \"\\r\\nHost: \"))", "         len += av_strlcatf(headers + len, sizeof(headers) - len,", "                            \"Host: %s\\r\\n\", hoststr);", "     if (!has_header(s->headers, \"\\r\\nContent-Length: \") && s->post_data)", "         len += av_strlcatf(headers + len, sizeof(headers) - len,", "                            \"Content-Length: %d\\r\\n\", s->post_datalen);", "     if (!has_header(s->headers, \"\\r\\nContent-Type: \") && s->content_type)", "         len += av_strlcatf(headers + len, sizeof(headers) - len,", "                            \"Content-Type: %s\\r\\n\", s->content_type);", "     if (!has_header(s->headers, \"\\r\\nCookie: \") && s->cookies) {", "         char *cookies = NULL;", "         if (!get_cookies(s, &cookies, path, hoststr) && cookies) {", "             len += av_strlcatf(headers + len, sizeof(headers) - len,", "                                \"Cookie: %s\\r\\n\", cookies);", "             av_free(cookies);", "         }", "     }", "     if (!has_header(s->headers, \"\\r\\nIcy-MetaData: \") && s->icy)", "         len += av_strlcatf(headers + len, sizeof(headers) - len,", "                            \"Icy-MetaData: %d\\r\\n\", 1);", "     if (s->headers)", "         av_strlcpy(headers + len, s->headers, sizeof(headers) - len);", "     snprintf(s->buffer, sizeof(s->buffer),", "              \"%s %s HTTP/1.1\\r\\n\"", "              \"%s\"", "              \"%s\"", "              \"%s\"", "              \"%s%s\"", "              \"\\r\\n\",", "              method,", "              path,", "              post && s->chunked_post ? \"Transfer-Encoding: chunked\\r\\n\" : \"\",", "              headers,", "              authstr ? authstr : \"\",", "              proxyauthstr ? \"Proxy-\" : \"\", proxyauthstr ? proxyauthstr : \"\");", "     av_log(h, AV_LOG_DEBUG, \"request: %s\\n\", s->buffer);", "     if ((err = ffurl_write(s->hd, s->buffer, strlen(s->buffer))) < 0)", "         goto done;", "     if (s->post_data)", "         if ((err = ffurl_write(s->hd, s->post_data, s->post_datalen)) < 0)", "             goto done;", "     s->buf_ptr          = s->buffer;", "     s->buf_end          = s->buffer;", "      s->line_count       = 0;", "      s->off              = 0;", "      s->icy_data_read    = 0;", "    s->filesize         = -1;", "     s->filesize         = UINT64_MAX;", "      s->willclose        = 0;", "      s->end_chunked_post = 0;", "      s->end_header       = 0;", "     if (post && !s->post_data && !send_expect_100) {", "         s->http_code = 200;", "         err = 0;", "         goto done;", "     }", "     err = http_read_header(h, new_location);", "     if (err < 0)", "         goto done;", "     if (*new_location)", "         s->off = off;", "     err = (off == s->off) ? 0 : -1;", " done:", "     av_freep(&authstr);", "     av_freep(&proxyauthstr);", "     return err;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int jpc_pi_nextrlcp(register jpc_pi_t *pi)", " {", " \tjpc_pchg_t *pchg;", " \tint *prclyrno;", " \tpchg = pi->pchg;", " \tif (!pi->prgvolfirst) {", " \t\tassert(pi->prcno < pi->pirlvl->numprcs);", " \t\tprclyrno = &pi->pirlvl->prclyrnos[pi->prcno];", " \t\tgoto skip;", " \t} else {", " \t\tpi->prgvolfirst = 0;", " \t}", " \tfor (pi->rlvlno = pchg->rlvlnostart; pi->rlvlno < pi->maxrlvls &&", " \t  pi->rlvlno < pchg->rlvlnoend; ++pi->rlvlno) {", " \t\tfor (pi->lyrno = 0; pi->lyrno < pi->numlyrs && pi->lyrno <", "  \t\t  JAS_CAST(int, pchg->lyrnoend); ++pi->lyrno) {", "  \t\t\tfor (pi->compno = pchg->compnostart, pi->picomp =", "  \t\t\t  &pi->picomps[pi->compno]; pi->compno < pi->numcomps &&", "\t\t\t  pi->compno < JAS_CAST(int, pchg->compnoend); ++pi->compno, ++pi->picomp) {", " \t\t\t  pi->compno < JAS_CAST(int, pchg->compnoend); ++pi->compno,", " \t\t\t  ++pi->picomp) {", "  \t\t\t\tif (pi->rlvlno >= pi->picomp->numrlvls) {", "  \t\t\t\t\tcontinue;", "  \t\t\t\t}", " \t\t\t\tpi->pirlvl = &pi->picomp->pirlvls[pi->rlvlno];", " \t\t\t\tfor (pi->prcno = 0, prclyrno = pi->pirlvl->prclyrnos;", " \t\t\t\t  pi->prcno < pi->pirlvl->numprcs; ++pi->prcno, ++prclyrno) {", " \t\t\t\t\tif (pi->lyrno >= *prclyrno) {", " \t\t\t\t\t\t*prclyrno = pi->lyrno;", " \t\t\t\t\t\t++(*prclyrno);", " \t\t\t\t\t\treturn 0;", " \t\t\t\t\t}", " skip:", " \t\t\t\t\t;", " \t\t\t\t}", " \t\t\t}", " \t\t}", " \t}", " \treturn 1;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" long jpc_bitstream_getbits(jpc_bitstream_t *bitstream, int n)", " {", " \tlong v;", " \tint u;", "\tassert(n >= 0 && n < 32);", " \tif (n < 0 || n >= 32) {", " \t\treturn -1;", " \t}", "  \tv = 0;", " \twhile (--n >= 0) {", " \t\tif ((u = jpc_bitstream_getbit(bitstream)) < 0) {", " \t\t\treturn -1;", " \t\t}", " \t\tv = (v << 1) | u;", " \t}", " \treturn v;", " }"], "ner_tags": [0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int cdxl_decode_frame(AVCodecContext *avctx, void *data,", "                              int *got_frame, AVPacket *pkt)", " {", "     CDXLVideoContext *c = avctx->priv_data;", "     AVFrame * const p = data;", "     int ret, w, h, encoding, aligned_width, buf_size = pkt->size;", "     const uint8_t *buf = pkt->data;", "     if (buf_size < 32)", "         return AVERROR_INVALIDDATA;", "     encoding        = buf[1] & 7;", "     c->format       = buf[1] & 0xE0;", "     w               = AV_RB16(&buf[14]);", "     h               = AV_RB16(&buf[16]);", "     c->bpp          = buf[19];", "     c->palette_size = AV_RB16(&buf[20]);", "     c->palette      = buf + 32;", "     c->video        = c->palette + c->palette_size;", "     c->video_size   = buf_size - c->palette_size - 32;", "     if (c->palette_size > 512)", "         return AVERROR_INVALIDDATA;", "     if (buf_size < c->palette_size + 32)", "         return AVERROR_INVALIDDATA;", "     if (c->bpp < 1)", "         return AVERROR_INVALIDDATA;", "     if (c->format != BIT_PLANAR && c->format != BIT_LINE && c->format != CHUNKY) {", "         avpriv_request_sample(avctx, \"Pixel format 0x%0x\", c->format);", "         return AVERROR_PATCHWELCOME;", "     }", "     if ((ret = ff_set_dimensions(avctx, w, h)) < 0)", "         return ret;", "     if (c->format == CHUNKY)", "         aligned_width = avctx->width;", "     else", "         aligned_width = FFALIGN(c->avctx->width, 16);", "      c->padded_bits  = aligned_width - c->avctx->width;", "      if (c->video_size < aligned_width * avctx->height * (int64_t)c->bpp / 8)", "          return AVERROR_INVALIDDATA;", "    if (!encoding && c->palette_size && c->bpp <= 8) {", "     if (!encoding && c->palette_size && c->bpp <= 8 && c->format != CHUNKY) {", "          avctx->pix_fmt = AV_PIX_FMT_PAL8;", "      } else if (encoding == 1 && (c->bpp == 6 || c->bpp == 8)) {", "          if (c->palette_size != (1 << (c->bpp - 1)))", "             return AVERROR_INVALIDDATA;", "         avctx->pix_fmt = AV_PIX_FMT_BGR24;", "     } else if (!encoding && c->bpp == 24 && c->format == CHUNKY &&", "                !c->palette_size) {", "         avctx->pix_fmt = AV_PIX_FMT_RGB24;", "     } else {", "         avpriv_request_sample(avctx, \"Encoding %d, bpp %d and format 0x%x\",", "                               encoding, c->bpp, c->format);", "         return AVERROR_PATCHWELCOME;", "     }", "     if ((ret = ff_get_buffer(avctx, p, 0)) < 0)", "         return ret;", "     p->pict_type = AV_PICTURE_TYPE_I;", "     if (encoding) {", "         av_fast_padded_malloc(&c->new_video, &c->new_video_size,", "                               h * w + AV_INPUT_BUFFER_PADDING_SIZE);", "         if (!c->new_video)", "             return AVERROR(ENOMEM);", "         if (c->bpp == 8)", "             cdxl_decode_ham8(c, p);", "         else", "             cdxl_decode_ham6(c, p);", "     } else if (avctx->pix_fmt == AV_PIX_FMT_PAL8) {", "         cdxl_decode_rgb(c, p);", "     } else {", "         cdxl_decode_raw(c, p);", "     }", "     *got_frame = 1;", "     return buf_size;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" jas_image_t *jpg_decode(jas_stream_t *in, char *optstr)", " {", " \tstruct jpeg_decompress_struct cinfo;", " \tstruct jpeg_error_mgr jerr;", " \tFILE *input_file;", " \tjpg_dest_t dest_mgr_buf;", " \tjpg_dest_t *dest_mgr = &dest_mgr_buf;", " \tJDIMENSION num_scanlines;", "  \tjas_image_t *image;", "  \tint ret;", "  \tjpg_dec_importopts_t opts;", "\tsize_t size;", " \tsize_t num_samples;", " \tJAS_DBGLOG(100, (\"jpg_decode(%p, \\\"%s\\\")\\n\", in, optstr));", "  \tif (jpg_dec_parseopts(optstr, &opts)) {", "  \t\tgoto error;", " \t}", " \tmemset(&cinfo, 0, sizeof(struct jpeg_decompress_struct));", " \tmemset(dest_mgr, 0, sizeof(jpg_dest_t));", " \tdest_mgr->data = 0;", " \timage = 0;", " \tinput_file = 0;", " \tif (!(input_file = tmpfile())) {", " \t\tjas_eprintf(\"cannot make temporary file\\n\");", " \t\tgoto error;", " \t}", " \tif (jpg_copystreamtofile(input_file, in)) {", " \t\tjas_eprintf(\"cannot copy stream\\n\");", " \t\tgoto error;", " \t}", " \trewind(input_file);", " \tJAS_DBGLOG(10, (\"jpeg_std_error(%p)\\n\", &jerr));", " \tcinfo.err = jpeg_std_error(&jerr);", " \tJAS_DBGLOG(10, (\"jpeg_create_decompress(%p)\\n\", &cinfo));", " \tjpeg_create_decompress(&cinfo);", " \tJAS_DBGLOG(10, (\"jpeg_stdio_src(%p, %p)\\n\", &cinfo, input_file));", " \tjpeg_stdio_src(&cinfo, input_file);", " \tJAS_DBGLOG(10, (\"jpeg_read_header(%p, TRUE)\\n\", &cinfo));", " \tret = jpeg_read_header(&cinfo, TRUE);", " \tJAS_DBGLOG(10, (\"jpeg_read_header return value %d\\n\", ret));", " \tif (ret != JPEG_HEADER_OK) {", " \t\tjas_eprintf(\"jpeg_read_header did not return JPEG_HEADER_OK\\n\");", " \t}", " \tJAS_DBGLOG(10, (", " \t  \"header: image_width %d; image_height %d; num_components %d\\n\",", "  \t  cinfo.image_width, cinfo.image_height, cinfo.num_components)", "  \t  );", " \tif (opts.max_samples > 0) {", " \t\tif (!jas_safe_size_mul3(cinfo.image_width, cinfo.image_height,", " \t\t  cinfo.num_components, &num_samples)) {", " \t\t\tgoto error;", " \t\t}", " \t\tif (num_samples > opts.max_samples) {", " \t\t\tjas_eprintf(\"image is too large (%zu > %zu)\\n\", num_samples,", " \t\t\t  opts.max_samples);", " \t\t\tgoto error;", " \t\t}", " \t}", "  \tJAS_DBGLOG(10, (\"jpeg_start_decompress(%p)\\n\", &cinfo));", "  \tret = jpeg_start_decompress(&cinfo);", " \tJAS_DBGLOG(10, (\"jpeg_start_decompress return value %d\\n\", ret));", " \tJAS_DBGLOG(10, (", " \t  \"header: output_width %d; output_height %d; output_components %d\\n\",", "  \t  cinfo.output_width, cinfo.output_height, cinfo.output_components)", "  \t  );", "\tif (opts.max_size) {", "\t\tif (!jas_safe_size_mul(cinfo.output_width, cinfo.output_height,", "\t\t  &size) ||", "\t\t  !jas_safe_size_mul(size, cinfo.output_components, &size)) {", "\t\t\tgoto error;", "\t\t}", "\t\tif (size > opts.max_size) {", "\t\t\tjas_eprintf(\"image is too large\\n\");", "\t\t\tgoto error;", "\t\t}", "\t}", "  \tif (!(image = jpg_mkimage(&cinfo))) {", "  \t\tjas_eprintf(\"jpg_mkimage failed\\n\");", " \t\tgoto error;", " \t}", " \tdest_mgr->image = image;", " \tif (!(dest_mgr->data = jas_matrix_create(1, cinfo.output_width))) {", " \t\tjas_eprintf(\"jas_matrix_create failed\\n\");", " \t\tgoto error;", " \t}", " \tdest_mgr->start_output = jpg_start_output;", " \tdest_mgr->put_pixel_rows = jpg_put_pixel_rows;", " \tdest_mgr->finish_output = jpg_finish_output;", "     dest_mgr->buffer = (*cinfo.mem->alloc_sarray)", "       ((j_common_ptr) &cinfo, JPOOL_IMAGE,", "        cinfo.output_width * cinfo.output_components, (JDIMENSION) 1);", " \tdest_mgr->buffer_height = 1;", " \tdest_mgr->error = 0;", " \t(*dest_mgr->start_output)(&cinfo, dest_mgr);", " \twhile (cinfo.output_scanline < cinfo.output_height) {", " \t\tJAS_DBGLOG(10, (\"jpeg_read_scanlines(%p, %p, %lu)\\n\", &cinfo,", " \t\t  dest_mgr->buffer, JAS_CAST(unsigned long, dest_mgr->buffer_height)));", " \t\tnum_scanlines = jpeg_read_scanlines(&cinfo, dest_mgr->buffer,", " \t\t  dest_mgr->buffer_height);", " \t\tJAS_DBGLOG(10, (\"jpeg_read_scanlines return value %lu\\n\",", " \t\t  JAS_CAST(unsigned long, num_scanlines)));", " \t\t(*dest_mgr->put_pixel_rows)(&cinfo, dest_mgr, num_scanlines);", " \t}", " \t(*dest_mgr->finish_output)(&cinfo, dest_mgr);", " \tJAS_DBGLOG(10, (\"jpeg_finish_decompress(%p)\\n\", &cinfo));", " \tjpeg_finish_decompress(&cinfo);", " \tJAS_DBGLOG(10, (\"jpeg_destroy_decompress(%p)\\n\", &cinfo));", " \tjpeg_destroy_decompress(&cinfo);", " \tjas_matrix_destroy(dest_mgr->data);", " \tJAS_DBGLOG(10, (\"fclose(%p)\\n\", input_file));", " \tfclose(input_file);", " \tinput_file = 0;", " \tif (dest_mgr->error) {", " \t\tjas_eprintf(\"error during decoding\\n\");", " \t\tgoto error;", " \t}", " \treturn image;", " error:", " \tif (dest_mgr->data) {", " \t\tjas_matrix_destroy(dest_mgr->data);", " \t}", " \tif (image) {", " \t\tjas_image_destroy(image);", " \t}", " \tif (input_file) {", " \t\tfclose(input_file);", " \t}", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int fuzzerTests(U32 seed, U32 nbTests, unsigned startTest, U32 const maxDurationS, double compressibility, int bigTests)", " {", "     static const U32 maxSrcLog = 23;", "     static const U32 maxSampleLog = 22;", "     size_t const srcBufferSize = (size_t)1<<maxSrcLog;", "     size_t const dstBufferSize = (size_t)1<<maxSampleLog;", "     size_t const cBufferSize   = ZSTD_compressBound(dstBufferSize);", "     BYTE* cNoiseBuffer[5];", "     BYTE* const cBuffer = (BYTE*) malloc (cBufferSize);", "     BYTE* const dstBuffer = (BYTE*) malloc (dstBufferSize);", "     BYTE* const mirrorBuffer = (BYTE*) malloc (dstBufferSize);", "     ZSTD_CCtx* const refCtx = ZSTD_createCCtx();", "     ZSTD_CCtx* const ctx = ZSTD_createCCtx();", "     ZSTD_DCtx* const dctx = ZSTD_createDCtx();", "     U32 result = 0;", "     U32 testNb = 0;", "     U32 coreSeed = seed;", "     UTIL_time_t const startClock = UTIL_getTime();", "     U64 const maxClockSpan = maxDurationS * SEC_TO_MICRO;", "     int const cLevelLimiter = bigTests ? 3 : 2;", "     cNoiseBuffer[0] = (BYTE*)malloc (srcBufferSize);", "     cNoiseBuffer[1] = (BYTE*)malloc (srcBufferSize);", "     cNoiseBuffer[2] = (BYTE*)malloc (srcBufferSize);", "     cNoiseBuffer[3] = (BYTE*)malloc (srcBufferSize);", "     cNoiseBuffer[4] = (BYTE*)malloc (srcBufferSize);", "     CHECK (!cNoiseBuffer[0] || !cNoiseBuffer[1] || !cNoiseBuffer[2] || !cNoiseBuffer[3] || !cNoiseBuffer[4]", "            || !dstBuffer || !mirrorBuffer || !cBuffer || !refCtx || !ctx || !dctx,", "            \"Not enough memory, fuzzer tests cancelled\");", "     RDG_genBuffer(cNoiseBuffer[0], srcBufferSize, 0.00, 0., coreSeed);     ", "     RDG_genBuffer(cNoiseBuffer[1], srcBufferSize, 0.05, 0., coreSeed);     ", "     RDG_genBuffer(cNoiseBuffer[2], srcBufferSize, compressibility, 0., coreSeed);", "     RDG_genBuffer(cNoiseBuffer[3], srcBufferSize, 0.95, 0., coreSeed);     ", "     RDG_genBuffer(cNoiseBuffer[4], srcBufferSize, 1.00, 0., coreSeed);     ", "     for (testNb=1; testNb < startTest; testNb++) FUZ_rand(&coreSeed);", "     for ( ; (testNb <= nbTests) || (UTIL_clockSpanMicro(startClock) < maxClockSpan); testNb++ ) {", "         BYTE* srcBuffer;    ", "         U32 lseed;", "         size_t sampleSize, maxTestSize, totalTestSize;", "         size_t cSize, totalCSize, totalGenSize;", "         U64 crcOrig;", "         BYTE* sampleBuffer;", "         const BYTE* dict;", "         size_t dictSize;", "         if (nbTests >= testNb) { DISPLAYUPDATE(2, \"\\r%6u/%6u    \", testNb, nbTests); }", "         else { DISPLAYUPDATE(2, \"\\r%6u          \", testNb); }", "         FUZ_rand(&coreSeed);", "         { U32 const prime1 = 2654435761U; lseed = coreSeed ^ prime1; }", "         {   U32 buffNb = FUZ_rand(&lseed) & 0x7F;", "             if (buffNb & 7) buffNb=2;    ", "             else {", "                 buffNb >>= 3;", "                 if (buffNb & 7) {", "                     const U32 tnb[2] = { 1, 3 };    ", "                     buffNb = tnb[buffNb >> 3];", "                 } else {", "                     const U32 tnb[2] = { 0, 4 };    ", "                     buffNb = tnb[buffNb >> 3];", "             }   }", "             srcBuffer = cNoiseBuffer[buffNb];", "         }", "         sampleSize = FUZ_randomLength(&lseed, maxSampleLog);", "         sampleBuffer = (BYTE*)malloc(sampleSize);", "         CHECK(sampleBuffer==NULL, \"not enough memory for sample buffer\");", "         { size_t const sampleStart = FUZ_rand(&lseed) % (srcBufferSize - sampleSize);", "           memcpy(sampleBuffer, srcBuffer + sampleStart, sampleSize); }", "         crcOrig = XXH64(sampleBuffer, sampleSize, 0);", "         {   int const cLevelPositive =", "                     ( FUZ_rand(&lseed) %", "                      (ZSTD_maxCLevel() - (FUZ_highbit32((U32)sampleSize) / cLevelLimiter)) )", "                     + 1;", "             int const cLevel = ((FUZ_rand(&lseed) & 15) == 3) ?", "                              - (int)((FUZ_rand(&lseed) & 7) + 1) :    ", "                              cLevelPositive;", "             DISPLAYLEVEL(5, \"fuzzer t%u: Simple compression test (level %i) \\n\", testNb, cLevel);", "             cSize = ZSTD_compressCCtx(ctx, cBuffer, cBufferSize, sampleBuffer, sampleSize, cLevel);", "              CHECK(ZSTD_isError(cSize), \"ZSTD_compressCCtx failed : %s\", ZSTD_getErrorName(cSize));", "            if (cSize > 3) {", "                const size_t missing = (FUZ_rand(&lseed) % (cSize-2)) + 1;    ", "             assert(cSize > 3);", "             {   const size_t missing = (FUZ_rand(&lseed) % (cSize-2)) + 1;", "                  const size_t tooSmallSize = cSize - missing;", "                  const U32 endMark = 0x4DC2B1A9;", "                  memcpy(dstBuffer+tooSmallSize, &endMark, 4);", "                 DISPLAYLEVEL(5, \"fuzzer t%u: compress into too small buffer of size %u (missing %u bytes) \\n\",", "                             testNb, (unsigned)tooSmallSize, (unsigned)missing);", "                  { size_t const errorCode = ZSTD_compressCCtx(ctx, dstBuffer, tooSmallSize, sampleBuffer, sampleSize, cLevel);", "                    CHECK(!ZSTD_isError(errorCode), \"ZSTD_compressCCtx should have failed ! (buffer too small : %u < %u)\", (U32)tooSmallSize, (U32)cSize); }", "                  { U32 endCheck; memcpy(&endCheck, dstBuffer+tooSmallSize, 4);", "                  CHECK(endCheck != endMark, \"ZSTD_compressCCtx : dst buffer overflow\"); }", "                   CHECK(endCheck != endMark, \"ZSTD_compressCCtx : dst buffer overflow  (check.%08X != %08X.mark)\", endCheck, endMark); }", "          }   }", "         {   ZSTD_frameHeader zfh;", "             CHECK_Z( ZSTD_getFrameHeader(&zfh, cBuffer, cSize) );", "             CHECK(zfh.frameContentSize != sampleSize, \"Frame content size incorrect\");", "         }", "         {   unsigned long long const rSize = ZSTD_findDecompressedSize(cBuffer, cSize);", "             CHECK(rSize != sampleSize, \"decompressed size incorrect\");", "         }", "         DISPLAYLEVEL(5, \"fuzzer t%u: simple decompression test \\n\", testNb);", "         {   size_t const margin = (FUZ_rand(&lseed) & 1) ? 0 : (FUZ_rand(&lseed) & 31) + 1;", "             size_t const dSize = ZSTD_decompress(dstBuffer, sampleSize + margin, cBuffer, cSize);", "             CHECK(dSize != sampleSize, \"ZSTD_decompress failed (%s) (srcSize : %u ; cSize : %u)\", ZSTD_getErrorName(dSize), (U32)sampleSize, (U32)cSize);", "             {   U64 const crcDest = XXH64(dstBuffer, sampleSize, 0);", "                 CHECK(crcOrig != crcDest, \"decompression result corrupted (pos %u / %u)\", (U32)findDiff(sampleBuffer, dstBuffer, sampleSize), (U32)sampleSize);", "         }   }", "         free(sampleBuffer);    ", "         DISPLAYLEVEL(5, \"fuzzer t%u: decompression of truncated source \\n\", testNb);", "         {   size_t const missing = (FUZ_rand(&lseed) % (cSize-2)) + 1;    ", "             size_t const tooSmallSize = cSize - missing;", "             void* cBufferTooSmall = malloc(tooSmallSize);    ", "             CHECK(cBufferTooSmall == NULL, \"not enough memory !\");", "             memcpy(cBufferTooSmall, cBuffer, tooSmallSize);", "             { size_t const errorCode = ZSTD_decompress(dstBuffer, dstBufferSize, cBufferTooSmall, tooSmallSize);", "               CHECK(!ZSTD_isError(errorCode), \"ZSTD_decompress should have failed ! (truncated src buffer)\"); }", "             free(cBufferTooSmall);", "         }", "         DISPLAYLEVEL(5, \"fuzzer t%u: decompress into too small dst buffer \\n\", testNb);", "         if (sampleSize > 3) {", "             size_t const missing = (FUZ_rand(&lseed) % (sampleSize-2)) + 1;    ", "             size_t const tooSmallSize = sampleSize - missing;", "             static const BYTE token = 0xA9;", "             dstBuffer[tooSmallSize] = token;", "             { size_t const errorCode = ZSTD_decompress(dstBuffer, tooSmallSize, cBuffer, cSize);", "               CHECK(!ZSTD_isError(errorCode), \"ZSTD_decompress should have failed : %u > %u (dst buffer too small)\", (U32)errorCode, (U32)tooSmallSize); }", "             CHECK(dstBuffer[tooSmallSize] != token, \"ZSTD_decompress : dst buffer overflow\");", "         }", "         if (cSize > 6) {", "             {   U32 const maxNbBits = FUZ_highbit32((U32)(cSize-4));", "                 size_t pos = 4;    ", "                 for (;;) {", "                     {   U32 const nbBits = FUZ_rand(&lseed) % maxNbBits;", "                         size_t const mask = (1<<nbBits) - 1;", "                         size_t const skipLength = FUZ_rand(&lseed) & mask;", "                         pos += skipLength;", "                     }", "                     if (pos >= cSize) break;", "                     {   U32 const nbBitsCodes = FUZ_rand(&lseed) % maxNbBits;", "                         U32 const nbBits = nbBitsCodes ? nbBitsCodes-1 : 0;", "                         size_t const mask = (1<<nbBits) - 1;", "                         size_t const rNoiseLength = (FUZ_rand(&lseed) & mask) + 1;", "                         size_t const noiseLength = MIN(rNoiseLength, cSize-pos);", "                         size_t const noiseStart = FUZ_rand(&lseed) % (srcBufferSize - noiseLength);", "                         memcpy(cBuffer + pos, srcBuffer + noiseStart, noiseLength);", "                         pos += noiseLength;", "             }   }   }", "             DISPLAYLEVEL(5, \"fuzzer t%u: decompress noisy source \\n\", testNb);", "             {   U32 const endMark = 0xA9B1C3D6;", "                 memcpy(dstBuffer+sampleSize, &endMark, 4);", "                 {   size_t const decompressResult = ZSTD_decompress(dstBuffer, sampleSize, cBuffer, cSize);", "                     CHECK((!ZSTD_isError(decompressResult)) && (decompressResult>sampleSize),", "                           \"ZSTD_decompress on noisy src : result is too large : %u > %u (dst buffer)\", (U32)decompressResult, (U32)sampleSize);", "                 }", "                 {   U32 endCheck; memcpy(&endCheck, dstBuffer+sampleSize, 4);", "                     CHECK(endMark!=endCheck, \"ZSTD_decompress on noisy src : dst buffer overflow\");", "         }   }   }    ", "         DISPLAYLEVEL(5, \"fuzzer t%u: Bufferless streaming compression test \\n\", testNb);", "         {   U32 const testLog = FUZ_rand(&lseed) % maxSrcLog;", "             U32 const dictLog = FUZ_rand(&lseed) % maxSrcLog;", "             int const cLevel = (FUZ_rand(&lseed) %", "                                 (ZSTD_maxCLevel() -", "                                  (MAX(testLog, dictLog) / cLevelLimiter))) +", "                                1;", "             maxTestSize = FUZ_rLogLength(&lseed, testLog);", "             if (maxTestSize >= dstBufferSize) maxTestSize = dstBufferSize-1;", "             dictSize = FUZ_rLogLength(&lseed, dictLog);    ", "             dict = srcBuffer + (FUZ_rand(&lseed) % (srcBufferSize - dictSize));", "             DISPLAYLEVEL(6, \"fuzzer t%u: Compressing up to <=%u bytes at level %i with dictionary size %u \\n\",", "                             testNb, (U32)maxTestSize, cLevel, (U32)dictSize);", "             if (FUZ_rand(&lseed) & 0xF) {", "                 CHECK_Z ( ZSTD_compressBegin_usingDict(refCtx, dict, dictSize, cLevel) );", "             } else {", "                 ZSTD_compressionParameters const cPar = ZSTD_getCParams(cLevel, ZSTD_CONTENTSIZE_UNKNOWN, dictSize);", "                 ZSTD_frameParameters const fPar = { FUZ_rand(&lseed)&1  ,", "                                                     !(FUZ_rand(&lseed)&3)  ,", "                                                     0   };    ", "                 ZSTD_parameters const p = FUZ_makeParams(cPar, fPar);", "                 CHECK_Z ( ZSTD_compressBegin_advanced(refCtx, dict, dictSize, p, 0) );", "             }", "             CHECK_Z( ZSTD_copyCCtx(ctx, refCtx, 0) );", "         }", "         {   U32 const nbChunks = (FUZ_rand(&lseed) & 127) + 2;", "             U32 n;", "             XXH64_state_t xxhState;", "             XXH64_reset(&xxhState, 0);", "             for (totalTestSize=0, cSize=0, n=0 ; n<nbChunks ; n++) {", "                 size_t const segmentSize = FUZ_randomLength(&lseed, maxSampleLog);", "                 size_t const segmentStart = FUZ_rand(&lseed) % (srcBufferSize - segmentSize);", "                 if (cBufferSize-cSize < ZSTD_compressBound(segmentSize)) break;    ", "                 if (totalTestSize+segmentSize > maxTestSize) break;", "                 {   size_t const compressResult = ZSTD_compressContinue(ctx, cBuffer+cSize, cBufferSize-cSize, srcBuffer+segmentStart, segmentSize);", "                     CHECK (ZSTD_isError(compressResult), \"multi-segments compression error : %s\", ZSTD_getErrorName(compressResult));", "                     cSize += compressResult;", "                 }", "                 XXH64_update(&xxhState, srcBuffer+segmentStart, segmentSize);", "                 memcpy(mirrorBuffer + totalTestSize, srcBuffer+segmentStart, segmentSize);", "                 totalTestSize += segmentSize;", "             }", "             {   size_t const flushResult = ZSTD_compressEnd(ctx, cBuffer+cSize, cBufferSize-cSize, NULL, 0);", "                 CHECK (ZSTD_isError(flushResult), \"multi-segments epilogue error : %s\", ZSTD_getErrorName(flushResult));", "                 cSize += flushResult;", "             }", "             crcOrig = XXH64_digest(&xxhState);", "         }", "         DISPLAYLEVEL(5, \"fuzzer t%u: Bufferless streaming decompression test \\n\", testNb);", "         {   ZSTD_frameHeader zfh;", "             CHECK( ZSTD_getFrameHeader(&zfh, cBuffer, ZSTD_frameHeaderSize_max),", "                   \"ZSTD_getFrameHeader(): error retrieving frame information\");", "             {   size_t const roundBuffSize = ZSTD_decodingBufferSize_min(zfh.windowSize, zfh.frameContentSize);", "                 CHECK_Z(roundBuffSize);", "                 CHECK((roundBuffSize > totalTestSize) && (zfh.frameContentSize!=ZSTD_CONTENTSIZE_UNKNOWN),", "                       \"ZSTD_decodingBufferSize_min() requires more memory (%u) than necessary (%u)\",", "                       (U32)roundBuffSize, (U32)totalTestSize );", "         }   }", "         if (dictSize<8) dictSize=0, dict=NULL;    ", "         CHECK_Z( ZSTD_decompressBegin_usingDict(dctx, dict, dictSize) );", "         totalCSize = 0;", "         totalGenSize = 0;", "         while (totalCSize < cSize) {", "             size_t const inSize = ZSTD_nextSrcSizeToDecompress(dctx);", "             size_t const genSize = ZSTD_decompressContinue(dctx, dstBuffer+totalGenSize, dstBufferSize-totalGenSize, cBuffer+totalCSize, inSize);", "             CHECK (ZSTD_isError(genSize), \"ZSTD_decompressContinue error : %s\", ZSTD_getErrorName(genSize));", "             totalGenSize += genSize;", "             totalCSize += inSize;", "         }", "         CHECK (ZSTD_nextSrcSizeToDecompress(dctx) != 0, \"frame not fully decoded\");", "         CHECK (totalGenSize != totalTestSize, \"streaming decompressed data : wrong size\")", "         CHECK (totalCSize != cSize, \"compressed data should be fully read\")", "         {   U64 const crcDest = XXH64(dstBuffer, totalTestSize, 0);", "             CHECK(crcOrig != crcDest, \"streaming decompressed data corrupted (pos %u / %u)\",", "                 (U32)findDiff(mirrorBuffer, dstBuffer, totalTestSize), (U32)totalTestSize);", "         }", "     }    ", "     DISPLAY(\"\\r%u fuzzer tests completed   \\n\", testNb-1);", " _cleanup:", "     ZSTD_freeCCtx(refCtx);", "     ZSTD_freeCCtx(ctx);", "     ZSTD_freeDCtx(dctx);", "     free(cNoiseBuffer[0]);", "     free(cNoiseBuffer[1]);", "     free(cNoiseBuffer[2]);", "     free(cNoiseBuffer[3]);", "     free(cNoiseBuffer[4]);", "     free(cBuffer);", "     free(dstBuffer);", "     free(mirrorBuffer);", "     return result;", " _output_error:", "     result = 1;", "     goto _cleanup;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int jpc_dec_decodepkts(jpc_dec_t *dec, jas_stream_t *pkthdrstream, jas_stream_t *in)", " {", " \tjpc_dec_tile_t *tile;", " \tjpc_pi_t *pi;", " \tint ret;", "  \ttile = dec->curtile;", "  \tpi = tile->pi;", "  \tfor (;;) {", "if (!tile->pkthdrstream || jas_stream_peekc(tile->pkthdrstream) == EOF) {", "\t\tswitch (jpc_dec_lookahead(in)) {", "\t\tcase JPC_MS_EOC:", "\t\tcase JPC_MS_SOT:", "\t\t\treturn 0;", "\t\t\tbreak;", "\t\tcase JPC_MS_SOP:", "\t\tcase JPC_MS_EPH:", "\t\tcase 0:", "\t\t\tbreak;", "\t\tdefault:", "\t\t\treturn -1;", "\t\t\tbreak;", " \t\tif (!tile->pkthdrstream || jas_stream_peekc(tile->pkthdrstream) == EOF) {", " \t\t\tswitch (jpc_dec_lookahead(in)) {", " \t\t\tcase JPC_MS_EOC:", " \t\t\tcase JPC_MS_SOT:", " \t\t\t\treturn 0;", " \t\t\t\tbreak;", " \t\t\tcase JPC_MS_SOP:", " \t\t\tcase JPC_MS_EPH:", " \t\t\tcase 0:", " \t\t\t\tbreak;", " \t\t\tdefault:", " \t\t\t\treturn -1;", " \t\t\t\tbreak;", " \t\t\t}", "  \t\t}", "}", "  \t\tif ((ret = jpc_pi_next(pi))) {", "  \t\t\treturn ret;", "  \t\t}", "if (dec->maxpkts >= 0 && dec->numpkts >= dec->maxpkts) {", "\tjas_eprintf(\"warning: stopping decode prematurely as requested\\n\");", "\treturn 0;", "}", " \t\tif (dec->maxpkts >= 0 && dec->numpkts >= dec->maxpkts) {", " \t\t\tjas_eprintf(\"warning: stopping decode prematurely as requested\\n\");", " \t\t\treturn 0;", " \t\t}", "  \t\tif (jas_getdbglevel() >= 1) {", "  \t\t\tjas_eprintf(\"packet offset=%08ld prg=%d cmptno=%02d \"", "  \t\t\t  \"rlvlno=%02d prcno=%03d lyrno=%02d\\n\", (long)", "  \t\t\t  jas_stream_getrwcount(in), jpc_pi_prg(pi), jpc_pi_cmptno(pi),", "  \t\t\t  jpc_pi_rlvlno(pi), jpc_pi_prcno(pi), jpc_pi_lyrno(pi));", "  \t\t}", "\t\tif (jpc_dec_decodepkt(dec, pkthdrstream, in, jpc_pi_cmptno(pi), jpc_pi_rlvlno(pi),", "\t\t  jpc_pi_prcno(pi), jpc_pi_lyrno(pi))) {", " \t\tif (jpc_dec_decodepkt(dec, pkthdrstream, in, jpc_pi_cmptno(pi),", " \t\t  jpc_pi_rlvlno(pi), jpc_pi_prcno(pi), jpc_pi_lyrno(pi))) {", "  \t\t\treturn -1;", "  \t\t}", "++dec->numpkts;", " \t\t++dec->numpkts;", "  \t}", "  \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0]}
{"tokens": [" SProcXFixesCreatePointerBarrier(ClientPtr client)", " {", "     REQUEST(xXFixesCreatePointerBarrierReq);", "     int i;", "      int i;", "      CARD16 *in_devices = (CARD16 *) &stuff[1];", "     REQUEST_AT_LEAST_SIZE(xXFixesCreatePointerBarrierReq);", "      swaps(&stuff->length);", "      swaps(&stuff->num_devices);", "      REQUEST_FIXED_SIZE(xXFixesCreatePointerBarrierReq, pad_to_int32(stuff->num_devices));", "     swaps(&stuff->x1);", "     swaps(&stuff->y1);", "     swaps(&stuff->x2);", "     swaps(&stuff->y2);", "     swapl(&stuff->directions);", "     for (i = 0; i < stuff->num_devices; i++) {", "         swaps(in_devices + i);", "     }", "     return ProcXFixesVector[stuff->xfixesReqType] (client);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int jpc_pi_nextrpcl(register jpc_pi_t *pi)", " {", " \tint rlvlno;", " \tjpc_pirlvl_t *pirlvl;", " \tjpc_pchg_t *pchg;", " \tint prchind;", " \tint prcvind;", " \tint *prclyrno;", " \tint compno;", " \tjpc_picomp_t *picomp;", " \tint xstep;", " \tint ystep;", " \tuint_fast32_t r;", " \tuint_fast32_t rpx;", " \tuint_fast32_t rpy;", " \tuint_fast32_t trx0;", " \tuint_fast32_t try0;", " \tpchg = pi->pchg;", " \tif (!pi->prgvolfirst) {", " \t\tgoto skip;", " \t} else {", " \t\tpi->xstep = 0;", " \t\tpi->ystep = 0;", " \t\tfor (compno = 0, picomp = pi->picomps; compno < pi->numcomps;", " \t\t  ++compno, ++picomp) {", "  \t\t\tfor (rlvlno = 0, pirlvl = picomp->pirlvls; rlvlno <", "  \t\t\t  picomp->numrlvls; ++rlvlno, ++pirlvl) {", "\t\t\t\tif (pirlvl->prcwidthexpn + pi->picomp->numrlvls >", " \t\t\t\tif (pirlvl->prcwidthexpn + picomp->numrlvls >", "  \t\t\t\t  JAS_UINTFAST32_NUMBITS - 2 ||", "\t\t\t\t  pirlvl->prcheightexpn + pi->picomp->numrlvls >", " \t\t\t\t  pirlvl->prcheightexpn + picomp->numrlvls >", "  \t\t\t\t  JAS_UINTFAST32_NUMBITS - 2) {", "  \t\t\t\t\treturn -1;", "  \t\t\t\t}", " \t\t\t\txstep = picomp->hsamp * (JAS_CAST(uint_fast32_t, 1) <<", " \t\t\t\t  (pirlvl->prcwidthexpn + picomp->numrlvls - rlvlno - 1));", " \t\t\t\tystep = picomp->vsamp * (JAS_CAST(uint_fast32_t, 1) <<", " \t\t\t\t  (pirlvl->prcheightexpn + picomp->numrlvls - rlvlno - 1));", " \t\t\t\tpi->xstep = (!pi->xstep) ? xstep : JAS_MIN(pi->xstep, xstep);", " \t\t\t\tpi->ystep = (!pi->ystep) ? ystep : JAS_MIN(pi->ystep, ystep);", " \t\t\t}", " \t\t}", " \t\tpi->prgvolfirst = 0;", " \t}", " \tfor (pi->rlvlno = pchg->rlvlnostart; pi->rlvlno < pchg->rlvlnoend &&", " \t  pi->rlvlno < pi->maxrlvls; ++pi->rlvlno) {", " \t\tfor (pi->y = pi->ystart; pi->y < pi->yend; pi->y +=", " \t\t  pi->ystep - (pi->y % pi->ystep)) {", " \t\t\tfor (pi->x = pi->xstart; pi->x < pi->xend; pi->x +=", " \t\t\t  pi->xstep - (pi->x % pi->xstep)) {", " \t\t\t\tfor (pi->compno = pchg->compnostart,", " \t\t\t\t  pi->picomp = &pi->picomps[pi->compno];", " \t\t\t\t  pi->compno < JAS_CAST(int, pchg->compnoend) && pi->compno <", " \t\t\t\t  pi->numcomps; ++pi->compno, ++pi->picomp) {", " \t\t\t\t\tif (pi->rlvlno >= pi->picomp->numrlvls) {", " \t\t\t\t\t\tcontinue;", " \t\t\t\t\t}", " \t\t\t\t\tpi->pirlvl = &pi->picomp->pirlvls[pi->rlvlno];", " \t\t\t\t\tif (pi->pirlvl->numprcs == 0) {", " \t\t\t\t\t\tcontinue;", " \t\t\t\t\t}", " \t\t\t\t\tr = pi->picomp->numrlvls - 1 - pi->rlvlno;", " \t\t\t\t\trpx = r + pi->pirlvl->prcwidthexpn;", " \t\t\t\t\trpy = r + pi->pirlvl->prcheightexpn;", " \t\t\t\t\ttrx0 = JPC_CEILDIV(pi->xstart, pi->picomp->hsamp << r);", " \t\t\t\t\ttry0 = JPC_CEILDIV(pi->ystart, pi->picomp->vsamp << r);", " \t\t\t\t\tif (((pi->x == pi->xstart &&", " \t\t\t\t\t  ((trx0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpx)))", " \t\t\t\t\t  || !(pi->x % (JAS_CAST(uint_fast32_t, 1) << rpx))) &&", " \t\t\t\t\t  ((pi->y == pi->ystart &&", " \t\t\t\t\t  ((try0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpy)))", " \t\t\t\t\t  || !(pi->y % (JAS_CAST(uint_fast32_t, 1) << rpy)))) {", " \t\t\t\t\t\tprchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x,", " \t\t\t\t\t\t  pi->picomp->hsamp << r), pi->pirlvl->prcwidthexpn) -", " \t\t\t\t\t\t  JPC_FLOORDIVPOW2(trx0, pi->pirlvl->prcwidthexpn);", " \t\t\t\t\t\tprcvind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->y,", " \t\t\t\t\t\t  pi->picomp->vsamp << r), pi->pirlvl->prcheightexpn) -", " \t\t\t\t\t\t  JPC_FLOORDIVPOW2(try0, pi->pirlvl->prcheightexpn);", " \t\t\t\t\t\tpi->prcno = prcvind * pi->pirlvl->numhprcs + prchind;", " \t\t\t\t\t\tassert(pi->prcno < pi->pirlvl->numprcs);", " \t\t\t\t\t\tfor (pi->lyrno = 0; pi->lyrno <", " \t\t\t\t\t\t  pi->numlyrs && pi->lyrno < JAS_CAST(int,", " \t\t\t\t\t\t  pchg->lyrnoend); ++pi->lyrno) {", " \t\t\t\t\t\t\tprclyrno = &pi->pirlvl->prclyrnos[pi->prcno];", " \t\t\t\t\t\t\tif (pi->lyrno >= *prclyrno) {", " \t\t\t\t\t\t\t\t++(*prclyrno);", " \t\t\t\t\t\t\t\treturn 0;", " \t\t\t\t\t\t\t}", " skip:", " \t\t\t\t\t\t\t;", " \t\t\t\t\t\t}", " \t\t\t\t\t}", " \t\t\t\t}", " \t\t\t}", " \t\t}", " \t}", " \treturn 1;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" path_in(PG_FUNCTION_ARGS)", " {", " \tchar\t   *str = PG_GETARG_CSTRING(0);", " \tPATH\t   *path;", " \tint\t\t\tisopen;", "  \tchar\t   *s;", "  \tint\t\t\tnpts;", "  \tint\t\t\tsize;", " \tint\t\t\tbase_size;", "  \tint\t\t\tdepth = 0;", "  \tif ((npts = pair_count(str, ',')) <= 0)", " \t\tereport(ERROR,", " \t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),", " \t\t\t\t errmsg(\"invalid input syntax for type path: \\\"%s\\\"\", str)));", " \ts = str;", " \twhile (isspace((unsigned char) *s))", " \t\ts++;", " \tif ((*s == LDELIM) && (strrchr(s, LDELIM) == s))", " \t{", " \t\ts++;", "  \t\tdepth++;", "  \t}", "\tsize = offsetof(PATH, p[0]) +sizeof(path->p[0]) * npts;", " \tbase_size = sizeof(path->p[0]) * npts;", " \tsize = offsetof(PATH, p[0]) + base_size;", " \tif (base_size / npts != sizeof(path->p[0]) || size <= base_size)", " \t\tereport(ERROR,", " \t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),", " \t\t\t\t errmsg(\"too many points requested\")));", "  \tpath = (PATH *) palloc(size);", "  \tSET_VARSIZE(path, size);", " \tpath->npts = npts;", " \tif ((!path_decode(TRUE, npts, s, &isopen, &s, &(path->p[0])))", " \t&& (!((depth == 0) && (*s == '\\0'))) && !((depth >= 1) && (*s == RDELIM)))", " \t\tereport(ERROR,", " \t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),", " \t\t\t\t errmsg(\"invalid input syntax for type path: \\\"%s\\\"\", str)));", " \tpath->closed = (!isopen);", " \tpath->dummy = 0;", " \tPG_RETURN_PATH_P(path);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  void jas_matrix_asr(jas_matrix_t *matrix, int n)", "  {", "\tint i;", "\tint j;", " \tjas_matind_t i;", " \tjas_matind_t j;", "  \tjas_seqent_t *rowstart;", "\tint rowstep;", " \tjas_matind_t rowstep;", "  \tjas_seqent_t *data;", "  \tassert(n >= 0);", " \tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {", " \t\tassert(matrix->rows_);", " \t\trowstep = jas_matrix_rowstep(matrix);", " \t\tfor (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,", " \t\t  rowstart += rowstep) {", " \t\t\tfor (j = matrix->numcols_, data = rowstart; j > 0; --j,", " \t\t\t  ++data) {", " \t\t\t\t*data = jas_seqent_asr(*data, n);", " \t\t\t}", " \t\t}", " \t}", " }"], "ner_tags": [0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  header_gets (SF_PRIVATE *psf, char *ptr, int bufsize)", "  {\tint\t\tk ;", " \tif (psf->header.indx + bufsize >= psf->header.len && psf_bump_header_allocation (psf, bufsize))", " \t\treturn 0 ;", "  \tfor (k = 0 ; k < bufsize - 1 ; k++)", "\t{\tif (psf->headindex < psf->headend)", "\t\t{\tptr [k] = psf->header [psf->headindex] ;", "\t\t\tpsf->headindex ++ ;", " \t{\tif (psf->header.indx < psf->header.end)", " \t\t{\tptr [k] = psf->header.ptr [psf->header.indx] ;", " \t\t\tpsf->header.indx ++ ;", "  \t\t\t}", "  \t\telse", "\t\t{\tpsf->headend += psf_fread (psf->header + psf->headend, 1, 1, psf) ;", "\t\t\tptr [k] = psf->header [psf->headindex] ;", "\t\t\tpsf->headindex = psf->headend ;", " \t\t{\tpsf->header.end += psf_fread (psf->header.ptr + psf->header.end, 1, 1, psf) ;", " \t\t\tptr [k] = psf->header.ptr [psf->header.indx] ;", " \t\t\tpsf->header.indx = psf->header.end ;", "  \t\t\t} ;", "  \t\tif (ptr [k] == '\\n')", " \t\t\tbreak ;", " \t\t} ;", " \tptr [k] = 0 ;", " \treturn k ;", " }  "], "ner_tags": [0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" hstoreArrayToPairs(ArrayType *a, int *npairs)", " {", " \tDatum\t   *key_datums;", " \tbool\t   *key_nulls;", " \tint\t\t\tkey_count;", " \tPairs\t   *key_pairs;", " \tint\t\t\tbufsiz;", " \tint\t\t\ti,", " \t\t\t\tj;", " \tdeconstruct_array(a,", " \t\t\t\t\t  TEXTOID, -1, false, 'i',", " \t\t\t\t\t  &key_datums, &key_nulls, &key_count);", " \tif (key_count == 0)", " \t{", " \t\t*npairs = 0;", "  \t\treturn NULL;", "  \t}", " \tif (key_count > MaxAllocSize / sizeof(Pairs))", " \t\tereport(ERROR,", " \t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),", " \t\t\t  errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",", " \t\t\t\t\t key_count, (int) (MaxAllocSize / sizeof(Pairs)))));", "  \tkey_pairs = palloc(sizeof(Pairs) * key_count);", "  \tfor (i = 0, j = 0; i < key_count; i++)", " \t{", " \t\tif (!key_nulls[i])", " \t\t{", " \t\t\tkey_pairs[j].key = VARDATA(key_datums[i]);", " \t\t\tkey_pairs[j].keylen = VARSIZE(key_datums[i]) - VARHDRSZ;", " \t\t\tkey_pairs[j].val = NULL;", " \t\t\tkey_pairs[j].vallen = 0;", " \t\t\tkey_pairs[j].needfree = 0;", " \t\t\tkey_pairs[j].isnull = 1;", " \t\t\tj++;", " \t\t}", " \t}", " \t*npairs = hstoreUniquePairs(key_pairs, j, &bufsiz);", " \treturn key_pairs;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" LockServer(void)", " {", "   char tmp[PATH_MAX], pid_str[12];", "   int lfd, i, haslock, l_pid, t;", "   char *tmppath = NULL;", "   int len;", "   char port[20];", "   if (nolock) return;", "   tmppath = LOCK_DIR;", "   sprintf(port, \"%d\", atoi(display));", "   len = strlen(LOCK_PREFIX) > strlen(LOCK_TMP_PREFIX) ? strlen(LOCK_PREFIX) :", " \t\t\t\t\t\tstrlen(LOCK_TMP_PREFIX);", "   len += strlen(tmppath) + strlen(port) + strlen(LOCK_SUFFIX) + 1;", "   if (len > sizeof(LockFile))", "     FatalError(\"Display name `%s' is too long\\n\", port);", "   (void)sprintf(tmp, \"%s\" LOCK_TMP_PREFIX \"%s\" LOCK_SUFFIX, tmppath, port);", "   (void)sprintf(LockFile, \"%s\" LOCK_PREFIX \"%s\" LOCK_SUFFIX, tmppath, port);", "   StillLocking = TRUE;", "   i = 0;", "   do {", "     i++;", "     lfd = open(tmp, O_CREAT | O_EXCL | O_WRONLY, 0644);", "     if (lfd < 0)", "        sleep(2);", "     else", "        break;", "   } while (i < 3);", "   if (lfd < 0) {", "     unlink(tmp);", "     i = 0;", "     do {", "       i++;", "       lfd = open(tmp, O_CREAT | O_EXCL | O_WRONLY, 0644);", "       if (lfd < 0)", "          sleep(2);", "       else", "          break;", "     } while (i < 3);", "   }", "   if (lfd < 0)", "      FatalError(\"Could not create lock file in %s\\n\", tmp);", "    (void) sprintf(pid_str, \"%10ld\\n\", (long)getpid());", "    (void) write(lfd, pid_str, 11);", "  (void) chmod(tmp, 0444);", "   (void) fchmod(lfd, 0444);", "    (void) close(lfd);", "   i = 0;", "   haslock = 0;", "   while ((!haslock) && (i++ < 3)) {", "     haslock = (link(tmp,LockFile) == 0);", "     if (haslock) {", "       break;", "     }", "     else {", "       lfd = open(LockFile, O_RDONLY|O_NOFOLLOW);", "       if (lfd < 0) {", "         unlink(tmp);", "         FatalError(\"Can't read lock file %s\\n\", LockFile);", "       }", "       pid_str[0] = '\\0';", "       if (read(lfd, pid_str, 11) != 11) {", "         unlink(LockFile);", "         close(lfd);", "         continue;", "       }", "       pid_str[11] = '\\0';", "       sscanf(pid_str, \"%d\", &l_pid);", "       close(lfd);", "       errno = 0;", "       t = kill(l_pid, 0);", "       if ((t< 0) && (errno == ESRCH)) {", "         unlink(LockFile);", "         continue;", "       }", "       else if (((t < 0) && (errno == EPERM)) || (t == 0)) {", "         unlink(tmp);", " \tFatalError(\"Server is already active for display %s\\n%s %s\\n%s\\n\",", " \t\t   port, \"\\tIf this server is no longer running, remove\",", " \t\t   LockFile, \"\\tand start again.\");", "       }", "     }", "   }", "   unlink(tmp);", "   if (!haslock)", "     FatalError(\"Could not create server lock file: %s\\n\", LockFile);", "   StillLocking = FALSE;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int lookup1_values(int entries, int dim)", " {", "     int r = (int) floor(exp((float) log((float) entries) / dim));", "     if ((int) floor(pow((float) r+1, dim)) <= entries)    ", "        ++r;                                               ", "   assert(pow((float) r+1, dim) > entries);", "   assert((int) floor(pow((float) r, dim)) <= entries);  ", "    if (pow((float) r+1, dim) <= entries)", "       return -1;", "    if ((int) floor(pow((float) r, dim)) > entries)", "       return -1;", "     return r;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0]}
{"tokens": [" static int mov_read_dref(MOVContext *c, AVIOContext *pb, MOVAtom atom)", " {", "     AVStream *st;", "     MOVStreamContext *sc;", "     int entries, i, j;", "     if (c->fc->nb_streams < 1)", "         return 0;", "     st = c->fc->streams[c->fc->nb_streams-1];", "     sc = st->priv_data;", "     avio_rb32(pb);  ", "     entries = avio_rb32(pb);", "      if (entries >= UINT_MAX / sizeof(*sc->drefs))", "          return AVERROR_INVALIDDATA;", "      av_free(sc->drefs);", "     sc->drefs_count = 0;", "      sc->drefs = av_mallocz(entries * sizeof(*sc->drefs));", "      if (!sc->drefs)", "          return AVERROR(ENOMEM);", "     sc->drefs_count = entries;", "     for (i = 0; i < sc->drefs_count; i++) {", "         MOVDref *dref = &sc->drefs[i];", "         uint32_t size = avio_rb32(pb);", "         int64_t next = avio_tell(pb) + size - 4;", "         if (size < 12)", "             return AVERROR_INVALIDDATA;", "         dref->type = avio_rl32(pb);", "         avio_rb32(pb);  ", "         av_dlog(c->fc, \"type %.4s size %d\\n\", (char*)&dref->type, size);", "         if (dref->type == MKTAG('a','l','i','s') && size > 150) {", "             uint16_t volume_len, len;", "             int16_t type;", "             avio_skip(pb, 10);", "             volume_len = avio_r8(pb);", "             volume_len = FFMIN(volume_len, 27);", "             avio_read(pb, dref->volume, 27);", "             dref->volume[volume_len] = 0;", "             av_log(c->fc, AV_LOG_DEBUG, \"volume %s, len %d\\n\", dref->volume, volume_len);", "             avio_skip(pb, 12);", "             len = avio_r8(pb);", "             len = FFMIN(len, 63);", "             avio_read(pb, dref->filename, 63);", "             dref->filename[len] = 0;", "             av_log(c->fc, AV_LOG_DEBUG, \"filename %s, len %d\\n\", dref->filename, len);", "             avio_skip(pb, 16);", "             dref->nlvl_from = avio_rb16(pb);", "             dref->nlvl_to   = avio_rb16(pb);", "             av_log(c->fc, AV_LOG_DEBUG, \"nlvl from %d, nlvl to %d\\n\",", "                    dref->nlvl_from, dref->nlvl_to);", "             avio_skip(pb, 16);", "             for (type = 0; type != -1 && avio_tell(pb) < next; ) {", "                 if(url_feof(pb))", "                     return AVERROR_EOF;", "                 type = avio_rb16(pb);", "                 len = avio_rb16(pb);", "                 av_log(c->fc, AV_LOG_DEBUG, \"type %d, len %d\\n\", type, len);", "                 if (len&1)", "                     len += 1;", "                 if (type == 2) {  ", "                     av_free(dref->path);", "                     dref->path = av_mallocz(len+1);", "                     if (!dref->path)", "                         return AVERROR(ENOMEM);", "                     avio_read(pb, dref->path, len);", "                     if (len > volume_len && !strncmp(dref->path, dref->volume, volume_len)) {", "                         len -= volume_len;", "                         memmove(dref->path, dref->path+volume_len, len);", "                         dref->path[len] = 0;", "                     }", "                     for (j = 0; j < len; j++)", "                         if (dref->path[j] == ':')", "                             dref->path[j] = '/';", "                     av_log(c->fc, AV_LOG_DEBUG, \"path %s\\n\", dref->path);", "                 } else if (type == 0) {  ", "                     av_free(dref->dir);", "                     dref->dir = av_malloc(len+1);", "                     if (!dref->dir)", "                         return AVERROR(ENOMEM);", "                     avio_read(pb, dref->dir, len);", "                     dref->dir[len] = 0;", "                     for (j = 0; j < len; j++)", "                         if (dref->dir[j] == ':')", "                             dref->dir[j] = '/';", "                     av_log(c->fc, AV_LOG_DEBUG, \"dir %s\\n\", dref->dir);", "                 } else", "                     avio_skip(pb, len);", "             }", "         }", "         avio_seek(pb, next, SEEK_SET);", "     }", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int xwd_decode_frame(AVCodecContext *avctx, void *data,", "                             int *got_frame, AVPacket *avpkt)", " {", "     AVFrame *p = data;", "     const uint8_t *buf = avpkt->data;", "     int i, ret, buf_size = avpkt->size;", "     uint32_t version, header_size, vclass, ncolors;", "     uint32_t xoffset, be, bpp, lsize, rsize;", "     uint32_t pixformat, pixdepth, bunit, bitorder, bpad;", "     uint32_t rgb[3];", "     uint8_t *ptr;", "     GetByteContext gb;", "     if (buf_size < XWD_HEADER_SIZE)", "         return AVERROR_INVALIDDATA;", "     bytestream2_init(&gb, buf, buf_size);", "     header_size = bytestream2_get_be32u(&gb);", "     version = bytestream2_get_be32u(&gb);", "     if (version != XWD_VERSION) {", "         av_log(avctx, AV_LOG_ERROR, \"unsupported version\\n\");", "         return AVERROR_INVALIDDATA;", "     }", "     if (buf_size < header_size || header_size < XWD_HEADER_SIZE) {", "         av_log(avctx, AV_LOG_ERROR, \"invalid header size\\n\");", "         return AVERROR_INVALIDDATA;", "     }", "     pixformat     = bytestream2_get_be32u(&gb);", "     pixdepth      = bytestream2_get_be32u(&gb);", "     avctx->width  = bytestream2_get_be32u(&gb);", "     avctx->height = bytestream2_get_be32u(&gb);", "     xoffset       = bytestream2_get_be32u(&gb);", "     be            = bytestream2_get_be32u(&gb);", "     bunit         = bytestream2_get_be32u(&gb);", "     bitorder      = bytestream2_get_be32u(&gb);", "     bpad          = bytestream2_get_be32u(&gb);", "     bpp           = bytestream2_get_be32u(&gb);", "     lsize         = bytestream2_get_be32u(&gb);", "     vclass        = bytestream2_get_be32u(&gb);", "     rgb[0]        = bytestream2_get_be32u(&gb);", "     rgb[1]        = bytestream2_get_be32u(&gb);", "     rgb[2]        = bytestream2_get_be32u(&gb);", "     bytestream2_skipu(&gb, 8);", "     ncolors       = bytestream2_get_be32u(&gb);", "     bytestream2_skipu(&gb, header_size - (XWD_HEADER_SIZE - 20));", "     av_log(avctx, AV_LOG_DEBUG,", "            \"pixformat %\"PRIu32\", pixdepth %\"PRIu32\", bunit %\"PRIu32\", bitorder %\"PRIu32\", bpad %\"PRIu32\"\\n\",", "            pixformat, pixdepth, bunit, bitorder, bpad);", "     av_log(avctx, AV_LOG_DEBUG,", "            \"vclass %\"PRIu32\", ncolors %\"PRIu32\", bpp %\"PRIu32\", be %\"PRIu32\", lsize %\"PRIu32\", xoffset %\"PRIu32\"\\n\",", "            vclass, ncolors, bpp, be, lsize, xoffset);", "     av_log(avctx, AV_LOG_DEBUG,", "            \"red %0\"PRIx32\", green %0\"PRIx32\", blue %0\"PRIx32\"\\n\",", "            rgb[0], rgb[1], rgb[2]);", "     if (pixformat > XWD_Z_PIXMAP) {", "         av_log(avctx, AV_LOG_ERROR, \"invalid pixmap format\\n\");", "         return AVERROR_INVALIDDATA;", "     }", "     if (pixdepth == 0 || pixdepth > 32) {", "         av_log(avctx, AV_LOG_ERROR, \"invalid pixmap depth\\n\");", "         return AVERROR_INVALIDDATA;", "     }", "     if (xoffset) {", "         avpriv_request_sample(avctx, \"xoffset %\"PRIu32\"\", xoffset);", "         return AVERROR_PATCHWELCOME;", "     }", "     if (be > 1) {", "         av_log(avctx, AV_LOG_ERROR, \"invalid byte order\\n\");", "         return AVERROR_INVALIDDATA;", "     }", "     if (bitorder > 1) {", "         av_log(avctx, AV_LOG_ERROR, \"invalid bitmap bit order\\n\");", "         return AVERROR_INVALIDDATA;", "     }", "     if (bunit != 8 && bunit != 16 && bunit != 32) {", "         av_log(avctx, AV_LOG_ERROR, \"invalid bitmap unit\\n\");", "         return AVERROR_INVALIDDATA;", "     }", "     if (bpad != 8 && bpad != 16 && bpad != 32) {", "         av_log(avctx, AV_LOG_ERROR, \"invalid bitmap scan-line pad\\n\");", "         return AVERROR_INVALIDDATA;", "     }", "     if (bpp == 0 || bpp > 32) {", "         av_log(avctx, AV_LOG_ERROR, \"invalid bits per pixel\\n\");", "         return AVERROR_INVALIDDATA;", "     }", "     if (ncolors > 256) {", "         av_log(avctx, AV_LOG_ERROR, \"invalid number of entries in colormap\\n\");", "         return AVERROR_INVALIDDATA;", "     }", "     if ((ret = av_image_check_size(avctx->width, avctx->height, 0, NULL)) < 0)", "         return ret;", "     rsize = FFALIGN(avctx->width * bpp, bpad) / 8;", "     if (lsize < rsize) {", "         av_log(avctx, AV_LOG_ERROR, \"invalid bytes per scan-line\\n\");", "         return AVERROR_INVALIDDATA;", "     }", "     if (bytestream2_get_bytes_left(&gb) < ncolors * XWD_CMAP_SIZE + (uint64_t)avctx->height * lsize) {", "         av_log(avctx, AV_LOG_ERROR, \"input buffer too small\\n\");", "         return AVERROR_INVALIDDATA;", "     }", "     if (pixformat != XWD_Z_PIXMAP) {", "         avpriv_report_missing_feature(avctx, \"Pixmap format %\"PRIu32, pixformat);", "         return AVERROR_PATCHWELCOME;", "     }", "     avctx->pix_fmt = AV_PIX_FMT_NONE;", "     switch (vclass) {", "     case XWD_STATIC_GRAY:", "      case XWD_GRAY_SCALE:", "          if (bpp != 1 && bpp != 8)", "              return AVERROR_INVALIDDATA;", "        if (pixdepth == 1) {", "         if (bpp == 1 && pixdepth == 1) {", "              avctx->pix_fmt = AV_PIX_FMT_MONOWHITE;", "        } else if (pixdepth == 8) {", "         } else if (bpp == 8 && pixdepth == 8) {", "              avctx->pix_fmt = AV_PIX_FMT_GRAY8;", "          }", "          break;", "     case XWD_STATIC_COLOR:", "     case XWD_PSEUDO_COLOR:", "         if (bpp == 8)", "             avctx->pix_fmt = AV_PIX_FMT_PAL8;", "         break;", "     case XWD_TRUE_COLOR:", "     case XWD_DIRECT_COLOR:", "         if (bpp != 16 && bpp != 24 && bpp != 32)", "             return AVERROR_INVALIDDATA;", "         if (bpp == 16 && pixdepth == 15) {", "             if (rgb[0] == 0x7C00 && rgb[1] == 0x3E0 && rgb[2] == 0x1F)", "                 avctx->pix_fmt = be ? AV_PIX_FMT_RGB555BE : AV_PIX_FMT_RGB555LE;", "             else if (rgb[0] == 0x1F && rgb[1] == 0x3E0 && rgb[2] == 0x7C00)", "                 avctx->pix_fmt = be ? AV_PIX_FMT_BGR555BE : AV_PIX_FMT_BGR555LE;", "         } else if (bpp == 16 && pixdepth == 16) {", "             if (rgb[0] == 0xF800 && rgb[1] == 0x7E0 && rgb[2] == 0x1F)", "                 avctx->pix_fmt = be ? AV_PIX_FMT_RGB565BE : AV_PIX_FMT_RGB565LE;", "             else if (rgb[0] == 0x1F && rgb[1] == 0x7E0 && rgb[2] == 0xF800)", "                 avctx->pix_fmt = be ? AV_PIX_FMT_BGR565BE : AV_PIX_FMT_BGR565LE;", "         } else if (bpp == 24) {", "             if (rgb[0] == 0xFF0000 && rgb[1] == 0xFF00 && rgb[2] == 0xFF)", "                 avctx->pix_fmt = be ? AV_PIX_FMT_RGB24 : AV_PIX_FMT_BGR24;", "             else if (rgb[0] == 0xFF && rgb[1] == 0xFF00 && rgb[2] == 0xFF0000)", "                 avctx->pix_fmt = be ? AV_PIX_FMT_BGR24 : AV_PIX_FMT_RGB24;", "         } else if (bpp == 32) {", "             if (rgb[0] == 0xFF0000 && rgb[1] == 0xFF00 && rgb[2] == 0xFF)", "                 avctx->pix_fmt = be ? AV_PIX_FMT_ARGB : AV_PIX_FMT_BGRA;", "             else if (rgb[0] == 0xFF && rgb[1] == 0xFF00 && rgb[2] == 0xFF0000)", "                 avctx->pix_fmt = be ? AV_PIX_FMT_ABGR : AV_PIX_FMT_RGBA;", "         }", "         bytestream2_skipu(&gb, ncolors * XWD_CMAP_SIZE);", "         break;", "     default:", "         av_log(avctx, AV_LOG_ERROR, \"invalid visual class\\n\");", "         return AVERROR_INVALIDDATA;", "     }", "     if (avctx->pix_fmt == AV_PIX_FMT_NONE) {", "         avpriv_request_sample(avctx,", "                               \"Unknown file: bpp %\"PRIu32\", pixdepth %\"PRIu32\", vclass %\"PRIu32\"\",", "                               bpp, pixdepth, vclass);", "         return AVERROR_PATCHWELCOME;", "     }", "     if ((ret = ff_get_buffer(avctx, p, 0)) < 0)", "         return ret;", "     p->key_frame = 1;", "     p->pict_type = AV_PICTURE_TYPE_I;", "     if (avctx->pix_fmt == AV_PIX_FMT_PAL8) {", "         uint32_t *dst = (uint32_t *)p->data[1];", "         uint8_t red, green, blue;", "         for (i = 0; i < ncolors; i++) {", "             bytestream2_skipu(&gb, 4);  ", "             red    = bytestream2_get_byteu(&gb);", "             bytestream2_skipu(&gb, 1);", "             green  = bytestream2_get_byteu(&gb);", "             bytestream2_skipu(&gb, 1);", "             blue   = bytestream2_get_byteu(&gb);", "             bytestream2_skipu(&gb, 3);  ", "             dst[i] = red << 16 | green << 8 | blue;", "         }", "     }", "     ptr = p->data[0];", "     for (i = 0; i < avctx->height; i++) {", "         bytestream2_get_bufferu(&gb, ptr, rsize);", "         bytestream2_skipu(&gb, lsize - rsize);", "         ptr += p->linesize[0];", "     }", "     *got_frame       = 1;", "     return buf_size;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)", " {", "     MpegEncContext *s = &ctx->m;", "     unsigned startcode, v;", "     int ret;", "     int vol = 0;", "     align_get_bits(gb);", "     if (!s->studio_profile && s->avctx->bits_per_raw_sample != 8)", "         s->avctx->bits_per_raw_sample = 0;", "     if (s->codec_tag == AV_RL32(\"WV1F\") && show_bits(gb, 24) == 0x575630) {", "         skip_bits(gb, 24);", "         if (get_bits(gb, 8) == 0xF0)", "             goto end;", "     }", "     startcode = 0xff;", "     for (;;) {", "         if (get_bits_count(gb) >= gb->size_in_bits) {", "             if (gb->size_in_bits == 8 &&", "                 (ctx->divx_version >= 0 || ctx->xvid_build >= 0) || s->codec_tag == AV_RL32(\"QMP4\")) {", "                 av_log(s->avctx, AV_LOG_VERBOSE, \"frame skip %d\\n\", gb->size_in_bits);", "                 return FRAME_SKIPPED;   ", "             } else", "                 return AVERROR_INVALIDDATA;   ", "         }", "         v = get_bits(gb, 8);", "         startcode = ((startcode << 8) | v) & 0xffffffff;", "         if ((startcode & 0xFFFFFF00) != 0x100)", "             continue;   ", "         if (s->avctx->debug & FF_DEBUG_STARTCODE) {", "             av_log(s->avctx, AV_LOG_DEBUG, \"startcode: %3X \", startcode);", "             if (startcode <= 0x11F)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Video Object Start\");", "             else if (startcode <= 0x12F)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Video Object Layer Start\");", "             else if (startcode <= 0x13F)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Reserved\");", "             else if (startcode <= 0x15F)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"FGS bp start\");", "             else if (startcode <= 0x1AF)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Reserved\");", "             else if (startcode == 0x1B0)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Seq Start\");", "             else if (startcode == 0x1B1)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Seq End\");", "             else if (startcode == 0x1B2)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"User Data\");", "             else if (startcode == 0x1B3)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Group of VOP start\");", "             else if (startcode == 0x1B4)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Video Session Error\");", "             else if (startcode == 0x1B5)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Start\");", "             else if (startcode == 0x1B6)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Video Object Plane start\");", "             else if (startcode == 0x1B7)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"slice start\");", "             else if (startcode == 0x1B8)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"extension start\");", "             else if (startcode == 0x1B9)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"fgs start\");", "             else if (startcode == 0x1BA)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"FBA Object start\");", "             else if (startcode == 0x1BB)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"FBA Object Plane start\");", "             else if (startcode == 0x1BC)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Mesh Object start\");", "             else if (startcode == 0x1BD)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Mesh Object Plane start\");", "             else if (startcode == 0x1BE)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Still Texture Object start\");", "             else if (startcode == 0x1BF)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Texture Spatial Layer start\");", "             else if (startcode == 0x1C0)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Texture SNR Layer start\");", "             else if (startcode == 0x1C1)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Texture Tile start\");", "             else if (startcode == 0x1C2)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Texture Shape Layer start\");", "             else if (startcode == 0x1C3)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"stuffing start\");", "             else if (startcode <= 0x1C5)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"reserved\");", "             else if (startcode <= 0x1FF)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"System start\");", "             av_log(s->avctx, AV_LOG_DEBUG, \" at %d\\n\", get_bits_count(gb));", "         }", "         if (startcode >= 0x120 && startcode <= 0x12F) {", "             if (vol) {", "                 av_log(s->avctx, AV_LOG_WARNING, \"Ignoring multiple VOL headers\\n\");", "                 continue;", "             }", "             vol++;", "             if ((ret = decode_vol_header(ctx, gb)) < 0)", "                 return ret;", "         } else if (startcode == USER_DATA_STARTCODE) {", "             decode_user_data(ctx, gb);", "          } else if (startcode == GOP_STARTCODE) {", "              mpeg4_decode_gop_header(s, gb);", "          } else if (startcode == VOS_STARTCODE) {", "            mpeg4_decode_profile_level(s, gb);", "            if (s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&", "                (s->avctx->level > 0 && s->avctx->level < 9)) {", "             int profile, level;", "             mpeg4_decode_profile_level(s, gb, &profile, &level);", "             if (profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&", "                 (level > 0 && level < 9)) {", "                  s->studio_profile = 1;", "                  next_start_code_studio(gb);", "                  extension_and_user_data(s, gb, 0);", "             } else if (s->studio_profile) {", "                 avpriv_request_sample(s->avctx, \"Mixes studio and non studio profile\\n\");", "                 return AVERROR_PATCHWELCOME;", "              }", "             s->avctx->profile = profile;", "             s->avctx->level   = level;", "          } else if (startcode == VISUAL_OBJ_STARTCODE) {", "              if (s->studio_profile) {", "                  if ((ret = decode_studiovisualobject(ctx, gb)) < 0)", "                     return ret;", "             } else", "                 mpeg4_decode_visual_object(s, gb);", "         } else if (startcode == VOP_STARTCODE) {", "             break;", "         }", "         align_get_bits(gb);", "         startcode = 0xff;", "     }", " end:", "     if (s->avctx->flags & AV_CODEC_FLAG_LOW_DELAY)", "         s->low_delay = 1;", "      s->avctx->has_b_frames = !s->low_delay;", "      if (s->studio_profile) {", "         av_assert0(s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);", "          if (!s->avctx->bits_per_raw_sample) {", "              av_log(s->avctx, AV_LOG_ERROR, \"Missing VOL header\\n\");", "              return AVERROR_INVALIDDATA;", "         }", "         return decode_studio_vop_header(ctx, gb);", "     } else", "         return decode_vop_header(ctx, gb);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" bit_in(PG_FUNCTION_ARGS)", " {", " \tchar\t   *input_string = PG_GETARG_CSTRING(0);", " #ifdef NOT_USED", " \tOid\t\t\ttypelem = PG_GETARG_OID(1);", " #endif", " \tint32\t\tatttypmod = PG_GETARG_INT32(2);", " \tVarBit\t   *result;\t\t\t ", " \tchar\t   *sp;\t\t\t\t ", " \tbits8\t   *r;\t\t\t\t ", " \tint\t\t\tlen,\t\t\t ", " \t\t\t\tbitlen,\t\t\t ", " \t\t\t\tslen;\t\t\t ", " \tbool\t\tbit_not_hex;\t ", " \tint\t\t\tbc;", " \tbits8\t\tx = 0;", " \tif (input_string[0] == 'b' || input_string[0] == 'B')", " \t{", " \t\tbit_not_hex = true;", " \t\tsp = input_string + 1;", " \t}", " \telse if (input_string[0] == 'x' || input_string[0] == 'X')", " \t{", " \t\tbit_not_hex = false;", " \t\tsp = input_string + 1;", " \t}", " \telse", " \t{", " \t\tbit_not_hex = true;", "  \t\tsp = input_string;", "  \t}", " \tslen = strlen(sp);", "  \tslen = strlen(sp);", "  \tif (bit_not_hex)", "  \t\tbitlen = slen;", "  \telse", " \t{", " \t\tif (slen > VARBITMAXLEN / 4)", " \t\t\tereport(ERROR,", " \t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),", " \t\t\t\t errmsg(\"bit string length exceeds the maximum allowed (%d)\",", " \t\t\t\t\t\tVARBITMAXLEN)));", "  \t\tbitlen = slen * 4;", " \t}", " \tif (atttypmod <= 0)", " \t\tatttypmod = bitlen;", " \telse if (bitlen != atttypmod)", " \t\tereport(ERROR,", " \t\t\t\t(errcode(ERRCODE_STRING_DATA_LENGTH_MISMATCH),", " \t\t\t\t errmsg(\"bit string length %d does not match type bit(%d)\",", " \t\t\t\t\t\tbitlen, atttypmod)));", " \tlen = VARBITTOTALLEN(atttypmod);", " \tresult = (VarBit *) palloc0(len);", " \tSET_VARSIZE(result, len);", " \tVARBITLEN(result) = atttypmod;", " \tr = VARBITS(result);", " \tif (bit_not_hex)", " \t{", " \t\tx = HIGHBIT;", " \t\tfor (; *sp; sp++)", " \t\t{", " \t\t\tif (*sp == '1')", " \t\t\t\t*r |= x;", " \t\t\telse if (*sp != '0')", " \t\t\t\tereport(ERROR,", " \t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),", " \t\t\t\t\t\t errmsg(\"\\\"%c\\\" is not a valid binary digit\",", " \t\t\t\t\t\t\t\t*sp)));", " \t\t\tx >>= 1;", " \t\t\tif (x == 0)", " \t\t\t{", " \t\t\t\tx = HIGHBIT;", " \t\t\t\tr++;", " \t\t\t}", " \t\t}", " \t}", " \telse", " \t{", " \t\tfor (bc = 0; *sp; sp++)", " \t\t{", " \t\t\tif (*sp >= '0' && *sp <= '9')", " \t\t\t\tx = (bits8) (*sp - '0');", " \t\t\telse if (*sp >= 'A' && *sp <= 'F')", " \t\t\t\tx = (bits8) (*sp - 'A') + 10;", " \t\t\telse if (*sp >= 'a' && *sp <= 'f')", " \t\t\t\tx = (bits8) (*sp - 'a') + 10;", " \t\t\telse", " \t\t\t\tereport(ERROR,", " \t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),", " \t\t\t\t\t\t errmsg(\"\\\"%c\\\" is not a valid hexadecimal digit\",", " \t\t\t\t\t\t\t\t*sp)));", " \t\t\tif (bc)", " \t\t\t{", " \t\t\t\t*r++ |= x;", " \t\t\t\tbc = 0;", " \t\t\t}", " \t\t\telse", " \t\t\t{", " \t\t\t\t*r = x << 4;", " \t\t\t\tbc = 1;", " \t\t\t}", " \t\t}", " \t}", " \tPG_RETURN_VARBIT_P(result);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int insert_key(", " \tsc_pkcs15_card_t *p15card,", " \tconst char       *path,", " \tunsigned char     id,", " \tunsigned char     key_reference,", " \tint               key_length,", " \tunsigned char     auth_id,", " \tconst char       *label", " ){", " \tsc_card_t *card=p15card->card;", " \tsc_context_t *ctx=p15card->card->ctx;", " \tsc_file_t *f;", " \tstruct sc_pkcs15_prkey_info prkey_info;", " \tstruct sc_pkcs15_object prkey_obj;", " \tint r, can_sign, can_crypt;", " \tmemset(&prkey_info, 0, sizeof(prkey_info));", " \tprkey_info.id.len         = 1;", " \tprkey_info.id.value[0]    = id;", " \tprkey_info.native         = 1;", " \tprkey_info.key_reference  = key_reference;", " \tprkey_info.modulus_length = key_length;", " \tsc_format_path(path, &prkey_info.path);", " \tmemset(&prkey_obj, 0, sizeof(prkey_obj));", " \tstrlcpy(prkey_obj.label, label, sizeof(prkey_obj.label));", " \tprkey_obj.flags            = SC_PKCS15_CO_FLAG_PRIVATE;", " \tprkey_obj.auth_id.len      = 1;", " \tprkey_obj.auth_id.value[0] = auth_id;", " \tcan_sign=can_crypt=0;", " \tif(card->type==SC_CARD_TYPE_TCOS_V3){", " \t\tunsigned char buf[256];", "  \t\tint i, rec_no=0;", "  \t\tif(prkey_info.path.len>=2) prkey_info.path.len-=2;", "  \t\tsc_append_file_id(&prkey_info.path, 0x5349);", "\t\tif(sc_select_file(card, &prkey_info.path, NULL)!=SC_SUCCESS){", " \t\tif(sc_select_file(card, &prkey_info.path, NULL)!=SC_SUCCESS || !f->prop_attr){", "  \t\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL,", "  \t\t\t\t\"Select(%s) failed\\n\",", "  \t\t\t\tsc_print_path(&prkey_info.path));", " \t\t\treturn 1;", " \t\t}", " \t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL,", " \t\t\t\"Searching for Key-Ref %02X\\n\", key_reference);", " \t\twhile((r=sc_read_record(card, ++rec_no, buf, sizeof(buf), SC_RECORD_BY_REC_NR))>0){", " \t\t\tint found=0;", " \t\t\tif(buf[0]!=0xA0) continue;", " \t\t\tfor(i=2;i<buf[1]+2;i+=2+buf[i+1]){", " \t\t\t\tif(buf[i]==0x83 && buf[i+1]==1 && buf[i+2]==key_reference) ++found;", " \t\t\t}", " \t\t\tif(found) break;", " \t\t}", " \t\tif(r<=0){", " \t\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL,\"No EF_KEYD-Record found\\n\");", " \t\t\treturn 1;", " \t\t}", " \t\tfor(i=0;i<r;i+=2+buf[i+1]){", " \t\t\tif(buf[i]==0xB6) can_sign++;", "  \t\t\tif(buf[i]==0xB8) can_crypt++;", "  \t\t}", "  \t} else {", "\t\tif(sc_select_file(card, &prkey_info.path, &f)!=SC_SUCCESS){", " \t\tif(sc_select_file(card, &prkey_info.path, &f)!=SC_SUCCESS", " \t\t\t   \t|| !f->prop_attr || f->prop_attr_len < 2){", "  \t\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL,", "  \t\t\t\t\"Select(%s) failed\\n\",", "  \t\t\t\tsc_print_path(&prkey_info.path));", " \t\t\treturn 1;", " \t\t}", " \t\tif (f->prop_attr[1] & 0x04) can_crypt=1;", " \t\tif (f->prop_attr[1] & 0x08) can_sign=1;", " \t\tsc_file_free(f);", " \t}", " \tprkey_info.usage= SC_PKCS15_PRKEY_USAGE_SIGN;", " \tif(can_crypt) prkey_info.usage |= SC_PKCS15_PRKEY_USAGE_ENCRYPT|SC_PKCS15_PRKEY_USAGE_DECRYPT;", " \tif(can_sign) prkey_info.usage |= SC_PKCS15_PRKEY_USAGE_NONREPUDIATION;", " \tr=sc_pkcs15emu_add_rsa_prkey(p15card, &prkey_obj, &prkey_info);", " \tif(r!=SC_SUCCESS){", " \t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"sc_pkcs15emu_add_rsa_prkey(%s) failed\\n\", path);", " \t\treturn 4;", " \t}", " \tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"%s: OK%s%s\\n\", path, can_sign ? \", Sign\" : \"\", can_crypt ? \", Crypt\" : \"\");", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)", " {", " \tjas_image_t *image;", " \tbmp_hdr_t hdr;", " \tbmp_info_t *info;", " \tuint_fast16_t cmptno;", " \tjas_image_cmptparm_t cmptparms[3];", " \tjas_image_cmptparm_t *cmptparm;", "  \tuint_fast16_t numcmpts;", "  \tlong n;", " \timage = 0;", " \tinfo = 0;", "  \tif (optstr) {", "  \t\tjas_eprintf(\"warning: ignoring BMP decoder options\\n\");", "  \t}", " \tjas_eprintf(", " \t  \"THE BMP FORMAT IS NOT FULLY SUPPORTED!\\n\"", " \t  \"THAT IS, THE JASPER SOFTWARE CANNOT DECODE ALL TYPES OF BMP DATA.\\n\"", " \t  \"IF YOU HAVE ANY PROBLEMS, PLEASE TRY CONVERTING YOUR IMAGE DATA\\n\"", " \t  \"TO THE PNM FORMAT, AND USING THIS FORMAT INSTEAD.\\n\"", " \t  );", "  \tif (bmp_gethdr(in, &hdr)) {", "  \t\tjas_eprintf(\"cannot get header\\n\");", "\t\treturn 0;", " \t\tgoto error;", "  \t}", "  \tJAS_DBGLOG(1, (", "  \t  \"BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\\n\",", " \t  hdr.magic, hdr.siz, hdr.reserved1, hdr.reserved2, hdr.off", " \t  ));", "  \tif (!(info = bmp_getinfo(in))) {", "  \t\tjas_eprintf(\"cannot get info\\n\");", "\t\treturn 0;", " \t\tgoto error;", "  \t}", "  \tJAS_DBGLOG(1,", "\t  (\"BMP information: len %d; width %d; height %d; numplanes %d; \"", "\t  \"depth %d; enctype %d; siz %d; hres %d; vres %d; numcolors %d; \"", "\t  \"mincolors %d\\n\", info->len, info->width, info->height, info->numplanes,", "\t  info->depth, info->enctype, info->siz, info->hres, info->vres,", "\t  info->numcolors, info->mincolors));", " \t  (\"BMP information: len %ld; width %ld; height %ld; numplanes %d; \"", " \t  \"depth %d; enctype %ld; siz %ld; hres %ld; vres %ld; numcolors %ld; \"", " \t  \"mincolors %ld\\n\", JAS_CAST(long, info->len),", " \t  JAS_CAST(long, info->width), JAS_CAST(long, info->height),", " \t  JAS_CAST(long, info->numplanes), JAS_CAST(long, info->depth),", " \t  JAS_CAST(long, info->enctype), JAS_CAST(long, info->siz),", " \t  JAS_CAST(long, info->hres), JAS_CAST(long, info->vres),", " \t  JAS_CAST(long, info->numcolors), JAS_CAST(long, info->mincolors)));", " \tif (info->width < 0 || info->height < 0 || info->numplanes < 0 ||", " \t  info->depth < 0 || info->siz < 0 || info->hres < 0 || info->vres < 0) {", " \t\tjas_eprintf(\"corrupt bit stream\\n\");", " \t\tgoto error;", " \t}", "  \tif (!bmp_issupported(&hdr, info)) {", "  \t\tjas_eprintf(\"error: unsupported BMP encoding\\n\");", "\t\tbmp_info_destroy(info);", "\t\treturn 0;", " \t\tgoto error;", "  \t}", "  \tif ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {", "  \t\tjas_eprintf(\"error: possibly bad bitmap offset?\\n\");", "\t\treturn 0;", " \t\tgoto error;", "  \t}", "  \tif (n > 0) {", "  \t\tjas_eprintf(\"skipping unknown data in BMP file\\n\");", "  \t\tif (bmp_gobble(in, n)) {", "\t\t\tbmp_info_destroy(info);", "\t\t\treturn 0;", " \t\t\tgoto error;", "  \t\t}", "  \t}", " \tnumcmpts = bmp_numcmpts(info);", " \tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,", " \t  ++cmptparm) {", " \t\tcmptparm->tlx = 0;", " \t\tcmptparm->tly = 0;", " \t\tcmptparm->hstep = 1;", " \t\tcmptparm->vstep = 1;", " \t\tcmptparm->width = info->width;", " \t\tcmptparm->height = info->height;", " \t\tcmptparm->prec = 8;", " \t\tcmptparm->sgnd = false;", " \t}", "  \tif (!(image = jas_image_create(numcmpts, cmptparms,", "  \t  JAS_CLRSPC_UNKNOWN))) {", "\t\tbmp_info_destroy(info);", "\t\treturn 0;", " \t\tgoto error;", "  \t}", "  \tif (numcmpts == 3) {", " \t\tjas_image_setclrspc(image, JAS_CLRSPC_SRGB);", " \t\tjas_image_setcmpttype(image, 0,", " \t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));", " \t\tjas_image_setcmpttype(image, 1,", " \t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));", " \t\tjas_image_setcmpttype(image, 2,", " \t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));", " \t} else {", " \t\tjas_image_setclrspc(image, JAS_CLRSPC_SGRAY);", " \t\tjas_image_setcmpttype(image, 0,", " \t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));", " \t}", "  \tif (bmp_getdata(in, info, image)) {", "\t\tbmp_info_destroy(info);", "\t\tjas_image_destroy(image);", "\t\treturn 0;", " \t\tgoto error;", "  \t}", "  \tbmp_info_destroy(info);", "  \treturn image;", " error:", " \tif (info) {", " \t\tbmp_info_destroy(info);", " \t}", " \tif (image) {", " \t\tjas_image_destroy(image);", " \t}", " \treturn 0;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": [" tTcpIpPacketParsingResult ParaNdis_CheckSumVerify(", "                                                 tCompletePhysicalAddress *pDataPages,", "                                                  ULONG ulDataLength,", "                                                  ULONG ulStartOffset,", "                                                  ULONG flags,", "                                                 BOOLEAN verifyLength,", "                                                  LPCSTR caller)", "  {", "      IPHeader *pIpHeader = (IPHeader *) RtlOffsetToPointer(pDataPages[0].Virtual, ulStartOffset);", "    tTcpIpPacketParsingResult res = QualifyIpPacket(pIpHeader, ulDataLength);", "     tTcpIpPacketParsingResult res = QualifyIpPacket(pIpHeader, ulDataLength, verifyLength);", "      if (res.ipStatus == ppresNotIP || res.ipCheckSum == ppresIPTooShort)", "          return res;", "     if (res.ipStatus == ppresIPV4)", "     {", "         if (flags & pcrIpChecksum)", "             res = VerifyIpChecksum(&pIpHeader->v4, res, (flags & pcrFixIPChecksum) != 0);", "         if(res.xxpStatus == ppresXxpKnown)", "         {", "             if (res.TcpUdp == ppresIsTCP)  ", "             {", "                 if(flags & pcrTcpV4Checksum)", "                 {", "                     res = VerifyTcpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixTcpV4Checksum));", "                 }", "             }", "             else  ", "             {", "                 if (flags & pcrUdpV4Checksum)", "                 {", "                     res = VerifyUdpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixUdpV4Checksum));", "                 }", "             }", "         }", "     }", "     else if (res.ipStatus == ppresIPV6)", "     {", "         if(res.xxpStatus == ppresXxpKnown)", "         {", "             if (res.TcpUdp == ppresIsTCP)  ", "             {", "                 if(flags & pcrTcpV6Checksum)", "                 {", "                     res = VerifyTcpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixTcpV6Checksum));", "                 }", "             }", "             else  ", "             {", "                 if (flags & pcrUdpV6Checksum)", "                 {", "                     res = VerifyUdpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixUdpV6Checksum));", "                 }", "             }", "         }", "     }", "     PrintOutParsingResult(res, 1, caller);", "      return res;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int mpeg4_decode_profile_level(MpegEncContext *s, GetBitContext *gb)", " static int mpeg4_decode_profile_level(MpegEncContext *s, GetBitContext *gb, int *profile, int *level)", "  {", "    s->avctx->profile = get_bits(gb, 4);", "    s->avctx->level   = get_bits(gb, 4);", "     *profile = get_bits(gb, 4);", "     *level   = get_bits(gb, 4);", "    if (s->avctx->profile == 0 && s->avctx->level == 8) {", "        s->avctx->level = 0;", "     if (*profile == 0 && *level == 8) {", "         *level = 0;", "      }", "      return 0;", " }"], "ner_tags": [0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": [" static int jpc_ppm_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)", " {", " \tjpc_ppm_t *ppm = &ms->parms.ppm;", " \tcstate = 0;", " \tppm->data = 0;", " \tif (ms->len < 1) {", " \t\tgoto error;", " \t}", " \tif (jpc_getuint8(in, &ppm->ind)) {", " \t\tgoto error;", " \t}", " \tppm->len = ms->len - 1;", " \tif (ppm->len > 0) {", "  \t\tif (!(ppm->data = jas_malloc(ppm->len))) {", "  \t\t\tgoto error;", "  \t\t}", "\t\tif (JAS_CAST(uint, jas_stream_read(in, ppm->data, ppm->len)) != ppm->len) {", " \t\tif (JAS_CAST(jas_uint, jas_stream_read(in, ppm->data, ppm->len)) != ppm->len) {", "  \t\t\tgoto error;", "  \t\t}", "  \t} else {", " \t\tppm->data = 0;", " \t}", " \treturn 0;", " error:", " \tjpc_ppm_destroyparms(ms);", " \treturn -1;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void gitn_box_del(GF_Box *s)", "{", "u32 i;", "GroupIdToNameBox *ptr = (GroupIdToNameBox *)s;", "if (ptr == NULL) return;", "for (i=0; i<ptr->nb_entries; i++) {", "if (ptr->entries[i].name) gf_free(ptr->entries[i].name);", "}", "if (ptr->entries) gf_free(ptr->entries);", "gf_free(ptr);", "}"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0]}
{"tokens": ["static GF_Err av1dmx_parse_flush_sample(GF_Filter *filter, GF_AV1DmxCtx *ctx)", "{", "u32 pck_size;", "GF_FilterPacket *pck;", "u8 *output;", "gf_bs_get_content_no_truncate(ctx->state.bs, &ctx->state.frame_obus, &pck_size, &ctx->state.frame_obus_alloc);", "if (!pck_size) {", "GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1Dmx] no frame OBU, skipping OBU\\n\"));", "return GF_OK;", "}", "pck = gf_filter_pck_new_alloc(ctx->opid, pck_size, &output);", "if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, pck);", "gf_filter_pck_set_cts(pck, ctx->cts);", "gf_filter_pck_set_sap(pck, ctx->state.frame_state.key_frame ? GF_FILTER_SAP_1 : 0);", "memcpy(output, ctx->state.frame_obus, pck_size);", "if (ctx->deps) {", "u8 flags = 0;", "flags = ( ctx->state.frame_state.key_frame) ? 2 : 1;", "flags <<= 2;", "flags |= ctx->state.frame_state.refresh_frame_flags ? 1 : 2;", "flags <<= 2;", "gf_filter_pck_set_dependency_flags(pck, flags);", "}", "gf_filter_pck_send(pck);", "av1dmx_update_cts(ctx);", "gf_av1_reset_state(&ctx->state, GF_FALSE);", "return GF_OK;", "}"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["Fraction::Fraction(int32_t num,int32_t den)", "{", "int32_t g = gcd(num, den);", "if (num == std::numeric_limits<int32_t>::min() && g == -1) {", "num++;", "}", "if (den == std::numeric_limits<int32_t>::min() && g == -1) {", "den++;", "}", "numerator = num / g;", "denominator = den / g;", "while (denominator > MAX_FRACTION_DENOMINATOR) {", "numerator >>= 1;", "denominator >>= 1;", "}", "}"], "ner_tags": [0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0]}
{"tokens": ["void sqlite3CreateView(", "Parse *pParse,", "Token *pBegin,", "Token *pName1,", "Token *pName2,", "ExprList *pCNames,", "Select *pSelect,", "int isTemp,", "int noErr", "){", "Table *p;", "int n;", "const char *z;", "Token sEnd;", "DbFixer sFix;", "Token *pName = 0;", "int iDb;", "sqlite3 *db = pParse->db;", "if( pParse->nVar>0 ){", "sqlite3ErrorMsg(pParse, \"parameters are not allowed in views\");", "goto create_view_fail;", "}", "sqlite3StartTable(pParse, pName1, pName2, isTemp, 1, 0, noErr);", "p = pParse->pNewTable;", "if( p==0 || pParse->nErr ) goto create_view_fail;", "sqlite3TwoPartName(pParse, pName1, pName2, &pName);", "iDb = sqlite3SchemaToIndex(db, p->pSchema);", "sqlite3FixInit(&sFix, pParse, iDb, \"view\", pName);", "if( sqlite3FixSelect(&sFix, pSelect) ) goto create_view_fail;", "if( IN_RENAME_OBJECT ){", "p->pSelect = pSelect;", "pSelect = 0;", "}else{", "p->pSelect = sqlite3SelectDup(db, pSelect, EXPRDUP_REDUCE);", "}", "p->pCheck = sqlite3ExprListDup(db, pCNames, EXPRDUP_REDUCE);", "if( db->mallocFailed ) goto create_view_fail;", "sEnd = pParse->sLastToken;", "assert( sEnd.z[0]!=0 || sEnd.n==0 );", "if( sEnd.z[0]!=';' ){", "sEnd.z += sEnd.n;", "}", "sEnd.n = 0;", "n = (int)(sEnd.z - pBegin->z);", "assert( n>0 );", "z = pBegin->z;", "while( sqlite3Isspace(z[n-1]) ){ n--; }", "sEnd.z = &z[n-1];", "sEnd.n = 1;", "sqlite3EndTable(pParse, 0, &sEnd, 0, 0);", "create_view_fail:", "sqlite3SelectDelete(db, pSelect);", "if( IN_RENAME_OBJECT ){", "sqlite3RenameExprlistUnmap(pParse, pCNames);", "}", "sqlite3ExprListDelete(db, pCNames);", "return;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void TestGatherNd(int* param_dims, const ParamType* param_data, int* index_dims,", "const IndexType* index_data, int* output_dims,", "ParamType* output_data,", "const ParamType* expected_output_data) {", "TfLiteIntArray* pdims = IntArrayFromInts(param_dims);", "TfLiteIntArray* idims = IntArrayFromInts(index_dims);", "TfLiteIntArray* odims = IntArrayFromInts(output_dims);", "constexpr int inputs_size = 2;", "constexpr int outputs_size = 1;", "constexpr int tensors_size = inputs_size + outputs_size;", "TfLiteTensor tensors[tensors_size] = {", "CreateTensor(param_data, pdims),", "CreateTensor(index_data, idims),", "CreateTensor(output_data, odims),", "};", "int inputs_array_data[] = {2, 0, 1};", "TfLiteIntArray* inputs_array = IntArrayFromInts(inputs_array_data);", "int outputs_array_data[] = {1, 2};", "TfLiteIntArray* outputs_array = IntArrayFromInts(outputs_array_data);", "const TfLiteRegistration registration = Register_GATHER_ND();", "micro::KernelRunner runner(registration, tensors, tensors_size, inputs_array,", "outputs_array,                  nullptr);", "TF_LITE_MICRO_EXPECT_EQ(kTfLiteOk, runner.InitAndPrepare());", "TF_LITE_MICRO_EXPECT_EQ(kTfLiteOk, runner.Invoke());", "TfLiteTensor* actual_output_tensor = &tensors[2];", "TfLiteIntArray* actual_output_dims = actual_output_tensor->dims;", "const int output_size = ElementCount(*actual_output_dims);", "for (int i = 0; i < output_size; ++i) {", "TF_LITE_MICRO_EXPECT_EQ(expected_output_data[i], output_data[i]);", "}", "}"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0]}
{"tokens": ["int secure_decrypt(void *data, unsigned int data_length, int is_signed)", "{", "at91_aes_key_size_t key_size;", "unsigned int cmac_key[8], cipher_key[8];", "unsigned int iv[AT91_AES_IV_SIZE_WORD];", "unsigned int computed_cmac[AT91_AES_BLOCK_SIZE_WORD];", "unsigned int fixed_length;", "const unsigned int *cmac;", "int rc = -1;", "init_keys(&key_size, cipher_key, cmac_key, iv);", "at91_aes_init();", "if (is_signed) {", "if (at91_aes_cmac(data_length, data, computed_cmac,", "key_size, cmac_key))", "goto exit;", "fixed_length = at91_aes_roundup(data_length);", "cmac = (const unsigned int *)((char *)data + fixed_length);", "if (!consttime_memequal(cmac, computed_cmac, AT91_AES_BLOCK_SIZE_BYTE))", "goto exit;", "}", "if (at91_aes_cbc(data_length, data, data, 0,", "key_size, cipher_key, iv))", "goto exit;", "rc = 0;", "exit:", "at91_aes_cleanup();", "memset(cmac_key, 0, sizeof(cmac_key));", "memset(cipher_key, 0, sizeof(cipher_key));", "memset(iv, 0, sizeof(iv));", "return rc;", "}"], "ner_tags": [0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0]}
{"tokens": ["PackLinuxElf64::invert_pt_dynamic(Elf64_Dyn const *dynp)", "{", "if (dt_table[Elf64_Dyn::DT_NULL]) {", "return;", "}", "Elf64_Dyn const *const dynp0 = dynp;", "unsigned ndx = 1+ 0;", "if (dynp)", "for (; ; ++ndx, ++dynp) {", "upx_uint64_t const d_tag = get_te64(&dynp->d_tag);", "if (d_tag>>32) {", "char msg[50]; snprintf(msg, sizeof(msg),", "\"bad Elf64_Dyn[%d].d_tag %#lx\", -1+ ndx, (long unsigned)d_tag);", "throwCantPack(msg);", "}", "if (d_tag < DT_NUM) {", "if (Elf64_Dyn::DT_NEEDED != d_tag", "&&  dt_table[d_tag]", "&&    get_te64(&dynp->d_val)", "!= get_te64(&dynp0[-1+ dt_table[d_tag]].d_val)) {", "char msg[50]; snprintf(msg, sizeof(msg),", "\"duplicate DT_%#x: [%#x] [%#x]\",", "(unsigned)d_tag, -1+ dt_table[d_tag], -1+ ndx);", "throwCantPack(msg);", "}", "dt_table[d_tag] = ndx;", "}", "if (Elf64_Dyn::DT_NULL == d_tag) {", "break;", "}", "}", "upx_dt_init = 0;", "if (dt_table[Elf64_Dyn::DT_INIT])          upx_dt_init = Elf64_Dyn::DT_INIT;", "else if (dt_table[Elf64_Dyn::DT_PREINIT_ARRAY]) upx_dt_init = Elf64_Dyn::DT_PREINIT_ARRAY;", "else if (dt_table[Elf64_Dyn::DT_INIT_ARRAY])    upx_dt_init = Elf64_Dyn::DT_INIT_ARRAY;", "unsigned const z_str = dt_table[Elf64_Dyn::DT_STRSZ];", "if (z_str) {", "strtab_end = get_te64(&dynp0[-1+ z_str].d_val);", "if ((u64_t)file_size <= strtab_end) {", "char msg[50]; snprintf(msg, sizeof(msg),", "\"bad DT_STRSZ %#x\", strtab_end);", "throwCantPack(msg);", "}", "}", "unsigned const x_sym = dt_table[Elf64_Dyn::DT_SYMTAB];", "unsigned const x_str = dt_table[Elf64_Dyn::DT_STRTAB];", "if (x_sym && x_str) {", "upx_uint64_t const v_sym = get_te64(&dynp0[-1+ x_sym].d_val);", "upx_uint64_t const v_str = get_te64(&dynp0[-1+ x_str].d_val);", "unsigned const  z_sym = dt_table[Elf64_Dyn::DT_SYMENT];", "unsigned const sz_sym = !z_sym ? sizeof(Elf64_Sym)", ": get_te64(&dynp0[-1+ z_sym].d_val);", "if (sz_sym < sizeof(Elf64_Sym)) {", "char msg[50]; snprintf(msg, sizeof(msg),", "\"bad DT_SYMENT %x\", sz_sym);", "throwCantPack(msg);", "}", "if (v_sym < v_str) {", "symnum_end = (v_str - v_sym) / sz_sym;", "}", "if (symnum_end < 1) {", "throwCantPack(\"bad DT_SYMTAB\");", "}", "}", "unsigned const v_hsh = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH);", "if (v_hsh && file_image) {", "hashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_HASH);", "if (!hashtab) {", "char msg[40]; snprintf(msg, sizeof(msg),", "\"bad DT_HASH %#x\", v_hsh);", "throwCantPack(msg);", "}", "unsigned const nbucket = get_te32(&hashtab[0]);", "unsigned const *const buckets = &hashtab[2];", "unsigned const *const chains = &buckets[nbucket]; (void)chains;", "unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);", "if (!nbucket", "|| (nbucket>>31) || (file_size/sizeof(unsigned)) <= (2*nbucket)", "|| ((v_hsh < v_sym) && (v_sym - v_hsh) < (sizeof(unsigned)*2", "+ sizeof(*buckets)*nbucket", "+ sizeof(*chains) *nbucket", "))", ") {", "char msg[90]; snprintf(msg, sizeof(msg),", "\"bad DT_HASH nbucket=%#x  len=%#x\",", "nbucket, (v_sym - v_hsh));", "throwCantPack(msg);", "}", "}", "unsigned const v_gsh = elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH);", "if (v_gsh && file_image) {", "gashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_GNU_HASH);", "if (!gashtab) {", "char msg[40]; snprintf(msg, sizeof(msg),", "\"bad DT_GNU_HASH %#x\", v_gsh);", "throwCantPack(msg);", "}", "unsigned const n_bucket = get_te32(&gashtab[0]);", "unsigned const n_bitmask = get_te32(&gashtab[2]);", "unsigned const gnu_shift = get_te32(&gashtab[3]);", "upx_uint64_t const *const bitmask = (upx_uint64_t const *)(void const *)&gashtab[4];", "unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask];", "unsigned     const *const hasharr = &buckets[n_bucket]; (void)hasharr;", "upx_uint64_t const v_sym = get_te64(&dynp0[-1+ x_sym].d_val);", "if (!n_bucket || !n_bitmask", "|| (-1+ n_bitmask) & n_bitmask", "|| 8*sizeof(upx_uint64_t) <= gnu_shift", "|| (n_bucket>>30)", "|| (n_bitmask>>30)", "|| (file_size/sizeof(unsigned)) <= ((sizeof(*bitmask)/sizeof(unsigned))*n_bitmask + 2*n_bucket)", "|| ((v_gsh < v_sym) && (v_sym - v_gsh) < (sizeof(unsigned)*4", "+ sizeof(*bitmask)*n_bitmask", "+ sizeof(*buckets)*n_bucket", "+ sizeof(*hasharr)*n_bucket", "))", ") {", "char msg[90]; snprintf(msg, sizeof(msg),", "\"bad DT_GNU_HASH n_bucket=%#x  n_bitmask=%#x  len=%#lx\",", "n_bucket, n_bitmask, (long unsigned)(v_sym - v_gsh));", "throwCantPack(msg);", "}", "}", "unsigned const e_shstrndx = get_te16(&ehdri.e_shstrndx);", "if (e_shnum <= e_shstrndx", "&&  !(0==e_shnum && 0==e_shstrndx) ) {", "char msg[40]; snprintf(msg, sizeof(msg),", "\"bad .e_shstrndx %d >= .e_shnum %d\", e_shstrndx, e_shnum);", "throwCantPack(msg);", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["sc_pkcs15emu_oberthur_add_data(struct sc_pkcs15_card *p15card,", "unsigned int file_id, unsigned int size, int private)", "{", "struct sc_context *ctx = p15card->card->ctx;", "struct sc_pkcs15_data_info dinfo;", "struct sc_pkcs15_object dobj;", "unsigned flags;", "unsigned char *info_blob = NULL, *label = NULL, *app = NULL, *oid = NULL;", "size_t info_len, label_len, app_len, oid_len, offs;", "char ch_tmp[0x100];", "int rv;", "SC_FUNC_CALLED(ctx, SC_LOG_DEBUG_VERBOSE);", "sc_log(ctx, \"Add data(file-id:%04X,size:%i,is-private:%i)\", file_id, size, private);", "memset(&dinfo, 0, sizeof(dinfo));", "memset(&dobj, 0, sizeof(dobj));", "snprintf(ch_tmp, sizeof(ch_tmp), \"%s%04X\", private ? AWP_OBJECTS_DF_PRV : AWP_OBJECTS_DF_PUB, file_id | 0x100);", "rv = sc_oberthur_read_file(p15card, ch_tmp, &info_blob, &info_len, 1);", "LOG_TEST_RET(ctx, rv, \"Failed to add data: read oberthur file error\");", "if (info_len < 2) {", "free(info_blob);", "LOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add certificate: no 'tag'\");", "}", "flags = *(info_blob + 0) * 0x100 + *(info_blob + 1);", "offs = 2;", "if (offs + 2 > info_len) {", "free(info_blob);", "LOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add data: no 'label'\");", "}", "label = info_blob + offs + 2;", "label_len = *(info_blob + offs + 1) + *(info_blob + offs) * 0x100;", "if (offs + 2 + label_len > info_len) {", "free(info_blob);", "LOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Invalid length of 'label' received\");", "}", "if (label_len > sizeof(dobj.label) - 1)", "label_len = sizeof(dobj.label) - 1;", "offs += 2 + *(info_blob + offs + 1);", "if (offs + 2 > info_len) {", "free(info_blob);", "LOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add data: no 'application'\");", "}", "app = info_blob + offs + 2;", "app_len = *(info_blob + offs + 1) + *(info_blob + offs) * 0x100;", "if (offs + 2 + app_len > info_len) {", "free(info_blob);", "LOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Invalid length of 'application' received\");", "}", "if (app_len > sizeof(dinfo.app_label) - 1)", "app_len = sizeof(dinfo.app_label) - 1;", "offs += 2 + app_len;", "if (offs + 2 > info_len) {", "free(info_blob);", "LOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add data: no 'OID'\");", "}", "oid_len = *(info_blob + offs + 1) + *(info_blob + offs) * 0x100;", "if (offs + 2 + oid_len > info_len) {", "free(info_blob);", "LOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Invalid length of 'oid' received\");", "}", "if (oid_len)   {", "oid = info_blob + offs + 2;", "if (*oid != 0x06 || (*(oid + 1) != oid_len - 2)) {", "free(info_blob);", "LOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add data: invalid 'OID' format\");", "}", "oid += 2;", "oid_len -= 2;", "}", "snprintf(ch_tmp, sizeof(ch_tmp), \"%s%04X\", private ? AWP_OBJECTS_DF_PRV : AWP_OBJECTS_DF_PUB, file_id);", "sc_format_path(ch_tmp, &dinfo.path);", "memcpy(dobj.label, label, label_len);", "memcpy(dinfo.app_label, app, app_len);", "if (oid_len)", "sc_asn1_decode_object_id(oid, oid_len, &dinfo.app_oid);", "if (flags & OBERTHUR_ATTR_MODIFIABLE)", "dobj.flags |= SC_PKCS15_CO_FLAG_MODIFIABLE;", "if (private)   {", "dobj.auth_id.len = sizeof(PinDomainID) > sizeof(dobj.auth_id.value)", "? sizeof(dobj.auth_id.value) : sizeof(PinDomainID);", "memcpy(dobj.auth_id.value, PinDomainID, dobj.auth_id.len);", "dobj.flags |= SC_PKCS15_CO_FLAG_PRIVATE;", "}", "rv = sc_pkcs15emu_add_data_object(p15card, &dobj, &dinfo);", "free(info_blob);", "LOG_FUNC_RETURN(p15card->card->ctx, rv);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["s32 vvc_parse_picture_header(GF_BitStream *bs, VVCState *vvc, VVCSliceInfo *si)", "{", "u32 pps_id;", "si->irap_or_gdr_pic = gf_bs_read_int_log(bs, 1, \"irap_or_gdr_pic\");", "si->non_ref_pic = gf_bs_read_int_log(bs, 1, \"non_ref_pic\");", "if (si->irap_or_gdr_pic)", "si->gdr_pic = gf_bs_read_int_log(bs, 1, \"gdr_pic\");", "if ((si->inter_slice_allowed_flag = gf_bs_read_int_log(bs, 1, \"inter_slice_allowed_flag\")))", "si->intra_slice_allowed_flag = gf_bs_read_int_log(bs, 1, \"intra_slice_allowed_flag\");", "pps_id = gf_bs_read_ue_log(bs, \"pps_id\");", "if (pps_id >= 64)", "return -1;", "si->pps = &vvc->pps[pps_id];", "si->sps = &vvc->sps[si->pps->sps_id];", "si->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, \"poc_lsb\");", "si->recovery_point_valid = 0;", "si->gdr_recovery_count = 0;", "if (si->gdr_pic) {", "si->recovery_point_valid = 1;", "si->gdr_recovery_count = gf_bs_read_ue_log(bs, \"gdr_recovery_count\");", "}", "gf_bs_read_int_log(bs, si->sps->ph_num_extra_bits, \"ph_extra_bits\");", "if (si->sps->poc_msb_cycle_flag) {", "if ( (si->poc_msb_cycle_present_flag = gf_bs_read_int_log(bs, 1, \"poc_msb_cycle_present_flag\"))) {", "si->poc_msb_cycle = gf_bs_read_int_log(bs, si->sps->poc_msb_cycle_len, \"poc_msb_cycle\");", "}", "}", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["qemuProcessHandleMonitorEOF(qemuMonitorPtr mon,", "virDomainObjPtr vm,", "void *opaque)", "{", "virQEMUDriverPtr driver = opaque;", "qemuDomainObjPrivatePtr priv;", "struct qemuProcessEvent *processEvent;", "virObjectLock(vm);", "VIR_DEBUG(\"Received EOF on %p '%s'\", vm, vm->def->name);", "priv = vm->privateData;", "if (priv->beingDestroyed) {", "VIR_DEBUG(\"Domain is being destroyed, EOF is expected\");", "goto cleanup;", "}", "processEvent = g_new0(struct qemuProcessEvent, 1);", "processEvent->eventType = QEMU_PROCESS_EVENT_MONITOR_EOF;", "processEvent->vm = virObjectRef(vm);", "if (virThreadPoolSendJob(driver->workerPool, 0, processEvent) < 0) {", "virObjectUnref(vm);", "qemuProcessEventFree(processEvent);", "goto cleanup;", "}", "qemuMonitorUnregister(mon);", "qemuDomainDestroyNamespace(driver, vm);", "cleanup:", "virObjectUnlock(vm);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0]}
{"tokens": ["void zipfileStep(sqlite3_context *pCtx, int nVal, sqlite3_value **apVal){", "ZipfileCtx *p;", "ZipfileEntry e;", "sqlite3_value *pName = 0;", "sqlite3_value *pMode = 0;", "sqlite3_value *pMtime = 0;", "sqlite3_value *pData = 0;", "sqlite3_value *pMethod = 0;", "int bIsDir = 0;", "u32 mode;", "int rc = SQLITE_OK;", "char *zErr = 0;", "int iMethod = -1;", "const u8 *aData = 0;", "int nData = 0;", "int szUncompressed = 0;", "u8 *aFree = 0;", "u32 iCrc32 = 0;", "char *zName = 0;", "int nName = 0;", "char *zFree = 0;", "int nByte;", "memset(&e, 0, sizeof(e));", "p = (ZipfileCtx*)sqlite3_aggregate_context(pCtx, sizeof(ZipfileCtx));", "if( p==0 ) return;", "if( nVal!=2 && nVal!=4 && nVal!=5 ){", "zErr = sqlite3_mprintf(\"wrong number of arguments to function zipfile()\");", "rc = SQLITE_ERROR;", "goto zipfile_step_out;", "}", "pName = apVal[0];", "if( nVal==2 ){", "pData = apVal[1];", "}else{", "pMode = apVal[1];", "pMtime = apVal[2];", "pData = apVal[3];", "if( nVal==5 ){", "pMethod = apVal[4];", "}", "}", "zName = (char*)sqlite3_value_text(pName);", "nName = sqlite3_value_bytes(pName);", "if( zName==0 ){", "zErr = sqlite3_mprintf(\"first argument to zipfile() must be non-NULL\");", "rc = SQLITE_ERROR;", "goto zipfile_step_out;", "}", "if( pMethod && SQLITE_NULL!=sqlite3_value_type(pMethod) ){", "iMethod = (int)sqlite3_value_int64(pMethod);", "if( iMethod!=0 && iMethod!=8 ){", "zErr = sqlite3_mprintf(\"illegal method value: %d\", iMethod);", "rc = SQLITE_ERROR;", "goto zipfile_step_out;", "}", "}", "if( sqlite3_value_type(pData)==SQLITE_NULL ){", "bIsDir = 1;", "iMethod = 0;", "}else{", "aData = sqlite3_value_blob(pData);", "szUncompressed = nData = sqlite3_value_bytes(pData);", "iCrc32 = crc32(0, aData, nData);", "if( iMethod<0 || iMethod==8 ){", "int nOut = 0;", "rc = zipfileDeflate(aData, nData, &aFree, &nOut, &zErr);", "if( rc!=SQLITE_OK ){", "goto zipfile_step_out;", "}", "if( iMethod==8 || nOut<nData ){", "aData = aFree;", "nData = nOut;", "iMethod = 8;", "}else{", "iMethod = 0;", "}", "}", "}", "rc = zipfileGetMode(pMode, bIsDir, &mode, &zErr);", "if( rc ) goto zipfile_step_out;", "e.mUnixTime = zipfileGetTime(pMtime);", "if( bIsDir==0 ){", "if( zName[nName-1]=='/' ){", "zErr = sqlite3_mprintf(\"non-directory name must not end with /\");", "rc = SQLITE_ERROR;", "goto zipfile_step_out;", "}", "}else{", "if( zName[nName-1]!='/' ){", "zName = zFree = sqlite3_mprintf(\"%s/\", zName);", "nName++;", "if( zName==0 ){", "rc = SQLITE_NOMEM;", "goto zipfile_step_out;", "}", "}else{", "while( nName>1 && zName[nName-2]=='/' ) nName--;", "}", "}", "e.cds.iVersionMadeBy = ZIPFILE_NEWENTRY_MADEBY;", "e.cds.iVersionExtract = ZIPFILE_NEWENTRY_REQUIRED;", "e.cds.flags = ZIPFILE_NEWENTRY_FLAGS;", "e.cds.iCompression = (u16)iMethod;", "zipfileMtimeToDos(&e.cds, (u32)e.mUnixTime);", "e.cds.crc32 = iCrc32;", "e.cds.szCompressed = nData;", "e.cds.szUncompressed = szUncompressed;", "e.cds.iExternalAttr = (mode<<16);", "e.cds.iOffset = p->body.n;", "e.cds.nFile = (u16)nName;", "e.cds.zFile = zName;", "nByte = ZIPFILE_LFH_FIXED_SZ + e.cds.nFile + 9;", "if( (rc = zipfileBufferGrow(&p->body, nByte)) ) goto zipfile_step_out;", "p->body.n += zipfileSerializeLFH(&e, &p->body.a[p->body.n]);", "if( nData>0 ){", "if( (rc = zipfileBufferGrow(&p->body, nData)) ) goto zipfile_step_out;", "memcpy(&p->body.a[p->body.n], aData, nData);", "p->body.n += nData;", "}", "nByte = ZIPFILE_CDS_FIXED_SZ + e.cds.nFile + 9;", "if( (rc = zipfileBufferGrow(&p->cds, nByte)) ) goto zipfile_step_out;", "p->cds.n += zipfileSerializeCDS(&e, &p->cds.a[p->cds.n]);", "p->nEntry++;", "zipfile_step_out:", "sqlite3_free(aFree);", "sqlite3_free(zFree);", "if( rc ){", "if( zErr ){", "sqlite3_result_error(pCtx, zErr, -1);", "}else{", "sqlite3_result_error_code(pCtx, rc);", "}", "}", "sqlite3_free(zErr);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["uint32_t *GetPayload(size_t handle, uint32_t *lastpayload, uint32_t index)", "{", "mp4object *mp4 = (mp4object *)handle;", "if (mp4 == NULL) return NULL;", "uint32_t *MP4buffer = NULL;", "if (index < mp4->indexcount && mp4->mediafp)", "{", "MP4buffer = (uint32_t *)realloc((void *)lastpayload, mp4->metasizes[index]);", "if (MP4buffer)", "{", "LONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);", "fread(MP4buffer, 1, mp4->metasizes[index], mp4->mediafp);", "return MP4buffer;", "}", "}", "return NULL;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": ["static void* swoole_unserialize_object(void *buffer, zval *return_value, zend_uchar bucket_len, zval *args, long flag)", "{", "zval property;", "uint32_t arr_num = 0;", "size_t name_len = *((unsigned short*) buffer);", "if (!name_len)", "{", "php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"illegal unserialize data\");", "return NULL;", "}", "buffer += 2;", "zend_string *class_name;", "if (flag == UNSERIALIZE_OBJECT_TO_STDCLASS)", "{", "class_name = swoole_string_init(ZEND_STRL(\"StdClass\"));", "}", "else", "{", "class_name = swoole_string_init((char*) buffer, name_len);", "}", "buffer += name_len;", "zend_class_entry *ce = swoole_try_get_ce(class_name);", "swoole_string_release(class_name);", "if (!ce)", "{", "return NULL;", "}", "buffer = get_array_real_len(buffer, bucket_len, &arr_num);", "buffer = swoole_unserialize_arr(buffer, &property, arr_num, flag);", "object_init_ex(return_value, ce);", "zval *data,*d;", "zend_string *key;", "zend_ulong index;", "ZEND_HASH_FOREACH_KEY_VAL(Z_ARRVAL(property), index, key, data)", "{", "const char *prop_name, *tmp;", "size_t prop_len;", "if (key)", "{", "if ((d = zend_hash_find(Z_OBJPROP_P(return_value), key)) != NULL)", "{", "if (Z_TYPE_P(d) == IS_INDIRECT)", "{", "d = Z_INDIRECT_P(d);", "}", "zval_dtor(d);", "ZVAL_COPY(d, data);", "}", "else", "{", "zend_unmangle_property_name_ex(key, &tmp, &prop_name, &prop_len);", "zend_update_property(ce, return_value, prop_name, prop_len, data);", "}", "}", "else", "{", "zend_hash_next_index_insert(Z_OBJPROP_P(return_value), data);", "}", "}", "ZEND_HASH_FOREACH_END();", "zval_dtor(&property);", "if (ce->constructor)", "{", "}", "if (zend_hash_str_exists(&ce->function_table, ZEND_STRL(\"__wakeup\")))", "{", "zval ret, wakeup;", "zend_string *fname = swoole_string_init(ZEND_STRL(\"__wakeup\"));", "Z_STR(wakeup) = fname;", "Z_TYPE_INFO(wakeup) = IS_STRING_EX;", "call_user_function_ex(CG(function_table), return_value, &wakeup, &ret, 0, NULL, 1, NULL);", "swoole_string_release(fname);", "zval_ptr_dtor(&ret);", "}", "return buffer;", "}"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["bool PamBackend::start(const QString &user) {", "bool result;", "QString service = QStringLiteral(\"sddm\");", "if (user == QStringLiteral(\"sddm\") && m_greeter)", "service = QStringLiteral(\"sddm-greeter\");", "else if (m_app->session()->path().isEmpty())", "service = QStringLiteral(\"sddm-check\");", "else if (m_autologin)", "service = QStringLiteral(\"sddm-autologin\");", "result = m_pam->start(service, user);", "if (!result)", "m_app->error(m_pam->errorString(), Auth::ERROR_INTERNAL);", "return result;", "}"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static s32 gf_hevc_read_sps_bs_internal(GF_BitStream *bs, HEVCState *hevc, u8 layer_id, u32 *vui_flag_pos)", "{", "s32 vps_id, sps_id = -1;", "u32 i, nb_CTUs, depth;", "HEVC_SPS *sps;", "HEVC_VPS *vps;", "HEVC_ProfileTierLevel ptl;", "Bool multiLayerExtSpsFlag;", "u8 sps_ext_or_max_sub_layers_minus1, max_sub_layers_minus1;", "if (vui_flag_pos) *vui_flag_pos = 0;", "vps_id = gf_bs_read_int_log(bs, 4, \"vps_id\");", "if (vps_id >= 16) {", "return -1;", "}", "memset(&ptl, 0, sizeof(ptl));", "max_sub_layers_minus1 = 0;", "sps_ext_or_max_sub_layers_minus1 = 0;", "if (layer_id == 0)", "max_sub_layers_minus1 = gf_bs_read_int_log(bs, 3, \"max_sub_layers_minus1\");", "else", "sps_ext_or_max_sub_layers_minus1 = gf_bs_read_int_log(bs, 3, \"sps_ext_or_max_sub_layers_minus1\");", "multiLayerExtSpsFlag = (layer_id != 0) && (sps_ext_or_max_sub_layers_minus1 == 7);", "if (!multiLayerExtSpsFlag) {", "gf_bs_read_int_log(bs, 1, \"temporal_id_nesting_flag\");", "hevc_profile_tier_level(bs, 1, max_sub_layers_minus1, &ptl, 0);", "}", "sps_id = gf_bs_read_ue_log(bs, \"sps_id\");", "if ((sps_id < 0) || (sps_id >= 16)) {", "return -1;", "}", "sps = &hevc->sps[sps_id];", "if (!sps->state) {", "sps->state = 1;", "sps->id = sps_id;", "sps->vps_id = vps_id;", "}", "sps->ptl = ptl;", "vps = &hevc->vps[vps_id];", "sps->max_sub_layers_minus1 = 0;", "sps->sps_ext_or_max_sub_layers_minus1 = 0;", "sps->colour_primaries = 2;", "sps->transfer_characteristic = 2;", "sps->matrix_coeffs = 2;", "if (multiLayerExtSpsFlag) {", "sps->update_rep_format_flag = gf_bs_read_int_log(bs, 1, \"update_rep_format_flag\");", "if (sps->update_rep_format_flag) {", "sps->rep_format_idx = gf_bs_read_int_log(bs, 8, \"rep_format_idx\");", "}", "else {", "sps->rep_format_idx = vps->rep_format_idx[layer_id];", "}", "sps->width = vps->rep_formats[sps->rep_format_idx].pic_width_luma_samples;", "sps->height = vps->rep_formats[sps->rep_format_idx].pic_height_luma_samples;", "sps->chroma_format_idc = vps->rep_formats[sps->rep_format_idx].chroma_format_idc;", "sps->bit_depth_luma = vps->rep_formats[sps->rep_format_idx].bit_depth_luma;", "sps->bit_depth_chroma = vps->rep_formats[sps->rep_format_idx].bit_depth_chroma;", "sps->separate_colour_plane_flag = vps->rep_formats[sps->rep_format_idx].separate_colour_plane_flag;", "sps->ptl = vps->ext_ptl[0];", "}", "else {", "sps->chroma_format_idc = gf_bs_read_ue_log(bs, \"chroma_format_idc\");", "if (sps->chroma_format_idc == 3)", "sps->separate_colour_plane_flag = gf_bs_read_int_log(bs, 1, \"separate_colour_plane_flag\");", "sps->width = gf_bs_read_ue_log(bs, \"width\");", "sps->height = gf_bs_read_ue_log(bs, \"height\");", "if ((sps->cw_flag = gf_bs_read_int_log(bs, 1, \"conformance_window_flag\"))) {", "u32 SubWidthC, SubHeightC;", "if (sps->chroma_format_idc == 1) {", "SubWidthC = SubHeightC = 2;", "}", "else if (sps->chroma_format_idc == 2) {", "SubWidthC = 2;", "SubHeightC = 1;", "}", "else {", "SubWidthC = SubHeightC = 1;", "}", "sps->cw_left = gf_bs_read_ue_log(bs, \"conformance_window_left\");", "sps->cw_right = gf_bs_read_ue_log(bs, \"conformance_window_right\");", "sps->cw_top = gf_bs_read_ue_log(bs, \"conformance_window_top\");", "sps->cw_bottom = gf_bs_read_ue_log(bs, \"conformance_window_bottom\");", "sps->width -= SubWidthC * (sps->cw_left + sps->cw_right);", "sps->height -= SubHeightC * (sps->cw_top + sps->cw_bottom);", "}", "sps->bit_depth_luma = 8 + gf_bs_read_ue_log(bs, \"bit_depth_luma_minus8\");", "sps->bit_depth_chroma = 8 + gf_bs_read_ue_log(bs, \"bit_depth_chroma_minus8\");", "}", "sps->log2_max_pic_order_cnt_lsb = 4 + gf_bs_read_ue_log(bs, \"log2_max_pic_order_cnt_lsb_minus4\");", "if (!multiLayerExtSpsFlag) {", "sps->sub_layer_ordering_info_present_flag = gf_bs_read_int_log(bs, 1, \"sub_layer_ordering_info_present_flag\");", "for (i = sps->sub_layer_ordering_info_present_flag ? 0 : sps->max_sub_layers_minus1; i <= sps->max_sub_layers_minus1; i++) {", "gf_bs_read_ue_log_idx(bs, \"max_dec_pic_buffering\", i);", "gf_bs_read_ue_log_idx(bs, \"num_reorder_pics\", i);", "gf_bs_read_ue_log_idx(bs, \"max_latency_increase\", i);", "}", "}", "sps->log2_min_luma_coding_block_size = 3 + gf_bs_read_ue_log(bs, \"log2_min_luma_coding_block_size_minus3\");", "sps->log2_diff_max_min_luma_coding_block_size = gf_bs_read_ue_log(bs, \"log2_diff_max_min_luma_coding_block_size\");", "sps->max_CU_width = (1 << (sps->log2_min_luma_coding_block_size + sps->log2_diff_max_min_luma_coding_block_size));", "sps->max_CU_height = (1 << (sps->log2_min_luma_coding_block_size + sps->log2_diff_max_min_luma_coding_block_size));", "sps->log2_min_transform_block_size = 2 + gf_bs_read_ue_log(bs, \"log2_min_transform_block_size_minus2\");", "sps->log2_max_transform_block_size = sps->log2_min_transform_block_size  + gf_bs_read_ue_log(bs, \"log2_max_transform_block_size\");", "depth = 0;", "sps->max_transform_hierarchy_depth_inter = gf_bs_read_ue_log(bs, \"max_transform_hierarchy_depth_inter\");", "sps->max_transform_hierarchy_depth_intra = gf_bs_read_ue_log(bs, \"max_transform_hierarchy_depth_intra\");", "while ((u32)(sps->max_CU_width >> sps->log2_diff_max_min_luma_coding_block_size) > (u32)(1 << (sps->log2_min_transform_block_size + depth)))", "{", "depth++;", "}", "sps->max_CU_depth = sps->log2_diff_max_min_luma_coding_block_size + depth;", "nb_CTUs = ((sps->width + sps->max_CU_width - 1) / sps->max_CU_width) * ((sps->height + sps->max_CU_height - 1) / sps->max_CU_height);", "sps->bitsSliceSegmentAddress = 0;", "while (nb_CTUs > (u32)(1 << sps->bitsSliceSegmentAddress)) {", "sps->bitsSliceSegmentAddress++;", "}", "sps->scaling_list_enable_flag = gf_bs_read_int_log(bs, 1, \"scaling_list_enable_flag\");", "if (sps->scaling_list_enable_flag) {", "sps->infer_scaling_list_flag = 0;", "sps->scaling_list_ref_layer_id = 0;", "if (multiLayerExtSpsFlag) {", "sps->infer_scaling_list_flag = gf_bs_read_int_log(bs, 1, \"infer_scaling_list_flag\");", "}", "if (sps->infer_scaling_list_flag) {", "sps->scaling_list_ref_layer_id = gf_bs_read_int_log(bs, 6, \"scaling_list_ref_layer_id\");", "}", "else {", "sps->scaling_list_data_present_flag = gf_bs_read_int_log(bs, 1, \"scaling_list_data_present_flag\");", "if (sps->scaling_list_data_present_flag) {", "hevc_scaling_list_data(bs);", "}", "}", "}", "sps->asymmetric_motion_partitions_enabled_flag = gf_bs_read_int_log(bs, 1, \"asymmetric_motion_partitions_enabled_flag\");", "sps->sample_adaptive_offset_enabled_flag = gf_bs_read_int_log(bs, 1, \"sample_adaptive_offset_enabled_flag\");", "if ( (sps->pcm_enabled_flag = gf_bs_read_int_log(bs, 1, \"pcm_enabled_flag\")) ) {", "sps->pcm_sample_bit_depth_luma_minus1 = gf_bs_read_int_log(bs, 4, \"pcm_sample_bit_depth_luma_minus1\");", "sps->pcm_sample_bit_depth_chroma_minus1 = gf_bs_read_int_log(bs, 4, \"pcm_sample_bit_depth_chroma_minus1\");", "sps->log2_min_pcm_luma_coding_block_size_minus3 = gf_bs_read_ue_log(bs, \"log2_min_pcm_luma_coding_block_size_minus3\");", "sps->log2_diff_max_min_pcm_luma_coding_block_size = gf_bs_read_ue_log(bs, \"log2_diff_max_min_pcm_luma_coding_block_size\");", "sps->pcm_loop_filter_disable_flag = gf_bs_read_int_log(bs, 1, \"pcm_loop_filter_disable_flag\");", "}", "sps->num_short_term_ref_pic_sets = gf_bs_read_ue_log(bs, \"num_short_term_ref_pic_sets\");", "if (sps->num_short_term_ref_pic_sets > 64) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Invalid number of short term reference picture sets %d\\n\", sps->num_short_term_ref_pic_sets));", "return -1;", "}", "for (i = 0; i < sps->num_short_term_ref_pic_sets; i++) {", "Bool ret = hevc_parse_short_term_ref_pic_set(bs, sps, i);", "if (!ret) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Invalid short_term_ref_pic_set\\n\"));", "return -1;", "}", "}", "sps->long_term_ref_pics_present_flag = gf_bs_read_int_log(bs, 1, \"long_term_ref_pics_present_flag\");", "if (sps->long_term_ref_pics_present_flag) {", "sps->num_long_term_ref_pic_sps = gf_bs_read_ue_log(bs, \"num_long_term_ref_pic_sps\");", "for (i = 0; i < sps->num_long_term_ref_pic_sps; i++) {", "gf_bs_read_int_log_idx(bs, sps->log2_max_pic_order_cnt_lsb, \"lt_ref_pic_poc_lsb_sps\", i);", "gf_bs_read_int_log_idx(bs, 1, \"used_by_curr_pic_lt_sps_flag\", i);", "}", "}", "sps->temporal_mvp_enable_flag = gf_bs_read_int_log(bs, 1, \"temporal_mvp_enable_flag\");", "sps->strong_intra_smoothing_enable_flag = gf_bs_read_int_log(bs, 1, \"strong_intra_smoothing_enable_flag\");", "if (vui_flag_pos)", "*vui_flag_pos = (u32)gf_bs_get_bit_offset(bs);", "if ((sps->vui_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_parameters_present_flag\")) ) {", "sps->aspect_ratio_info_present_flag = gf_bs_read_int_log(bs, 1, \"aspect_ratio_info_present_flag\");", "if (sps->aspect_ratio_info_present_flag) {", "sps->sar_idc = gf_bs_read_int_log(bs, 8, \"aspect_ratio_idc\");", "if (sps->sar_idc == 255) {", "sps->sar_width = gf_bs_read_int_log(bs, 16, \"aspect_ratio_width\");", "sps->sar_height = gf_bs_read_int_log(bs, 16, \"aspect_ratio_height\");", "}", "else if (sps->sar_idc < 17) {", "sps->sar_width = hevc_sar[sps->sar_idc].w;", "sps->sar_height = hevc_sar[sps->sar_idc].h;", "}", "}", "if ((sps->overscan_info_present = gf_bs_read_int_log(bs, 1, \"overscan_info_present\")))", "sps->overscan_appropriate = gf_bs_read_int_log(bs, 1, \"overscan_appropriate\");", "sps->video_signal_type_present_flag = gf_bs_read_int_log(bs, 1, \"video_signal_type_present_flag\");", "if (sps->video_signal_type_present_flag) {", "sps->video_format = gf_bs_read_int_log(bs, 3, \"video_format\");", "sps->video_full_range_flag = gf_bs_read_int_log(bs, 1, \"video_full_range_flag\");", "if ((sps->colour_description_present_flag = gf_bs_read_int_log(bs, 1, \"colour_description_present_flag\"))) {", "sps->colour_primaries = gf_bs_read_int_log(bs, 8, \"colour_primaries\");", "sps->transfer_characteristic = gf_bs_read_int_log(bs, 8, \"transfer_characteristic\");", "sps->matrix_coeffs = gf_bs_read_int_log(bs, 8, \"matrix_coefficients\");", "}", "}", "if ((sps->chroma_loc_info_present_flag = gf_bs_read_int_log(bs, 1, \"chroma_loc_info_present_flag\"))) {", "sps->chroma_sample_loc_type_top_field = gf_bs_read_ue_log(bs, \"chroma_sample_loc_type_top_field\");", "sps->chroma_sample_loc_type_bottom_field = gf_bs_read_ue_log(bs, \"chroma_sample_loc_type_bottom_field\");", "}", "sps->neutra_chroma_indication_flag = gf_bs_read_int_log(bs, 1, \"neutra_chroma_indication_flag\");", "sps->field_seq_flag = gf_bs_read_int_log(bs, 1, \"field_seq_flag\");", "sps->frame_field_info_present_flag = gf_bs_read_int_log(bs, 1, \"frame_field_info_present_flag\");", "if ((sps->default_display_window_flag = gf_bs_read_int_log(bs, 1, \"default_display_window_flag\"))) {", "sps->left_offset = gf_bs_read_ue_log(bs, \"display_window_left_offset\");", "sps->right_offset = gf_bs_read_ue_log(bs, \"display_window_right_offset\");", "sps->top_offset = gf_bs_read_ue_log(bs, \"display_window_top_offset\");", "sps->bottom_offset = gf_bs_read_ue_log(bs, \"display_window_bottom_offset\");", "}", "sps->has_timing_info = gf_bs_read_int_log(bs, 1, \"has_timing_info\");", "if (sps->has_timing_info) {", "sps->num_units_in_tick = gf_bs_read_int_log(bs, 32, \"num_units_in_tick\");", "sps->time_scale = gf_bs_read_int_log(bs, 32, \"time_scale\");", "sps->poc_proportional_to_timing_flag = gf_bs_read_int_log(bs, 1, \"poc_proportional_to_timing_flag\");", "if (sps->poc_proportional_to_timing_flag)", "sps->num_ticks_poc_diff_one_minus1 = gf_bs_read_ue_log(bs, \"num_ticks_poc_diff_one_minus1\");", "if ((sps->hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"hrd_parameters_present_flag\"))) {", "return sps_id;", "}", "}", "if (gf_bs_read_int_log(bs, 1, \"bitstream_restriction_flag\")) {", "gf_bs_read_int_log(bs, 1, \"tiles_fixed_structure_flag\");", "gf_bs_read_int_log(bs, 1, \"motion_vectors_over_pic_boundaries_flag\");", "gf_bs_read_int_log(bs, 1, \"restricted_ref_pic_lists_flag\");", "gf_bs_read_ue_log(bs, \"min_spatial_segmentation_idc\");", "gf_bs_read_ue_log(bs, \"max_bytes_per_pic_denom\");", "gf_bs_read_ue_log(bs, \"max_bits_per_min_cu_denom\");", "gf_bs_read_ue_log(bs, \"log2_max_mv_length_horizontal\");", "gf_bs_read_ue_log(bs, \"log2_max_mv_length_vertical\");", "}", "}", "if (gf_bs_read_int_log(bs, 1, \"sps_extension_flag\")) {", "#if 0", "while (gf_bs_available(bs)) {", "gf_bs_read_int(bs, 1);", "}", "#endif", "}", "return sps_id;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["bit_in(PG_FUNCTION_ARGS)", "{", "char    *input_string = PG_GETARG_CSTRING(0);", "#ifdef NOT_USED", "Oid   typelem = PG_GETARG_OID(1);", "#endif", "int32  atttypmod = PG_GETARG_INT32(2);", "VarBit    *result;", "char    *sp;", "bits8    *r;", "int   len,", "bitlen,", "slen;", "bool  bit_not_hex;", "int   bc;", "bits8  x = 0;", "if (input_string[0] == 'b' || input_string[0] == 'B')", "{", "bit_not_hex = true;", "sp = input_string + 1;", "}", "else if (input_string[0] == 'x' || input_string[0] == 'X')", "{", "bit_not_hex = false;", "sp = input_string + 1;", "}", "else", "{", "bit_not_hex = true;", "sp = input_string;", "}", "slen = strlen(sp);", "if (bit_not_hex)", "bitlen = slen;", "else", "bitlen = slen * 4;", "if (atttypmod <= 0)", "atttypmod = bitlen;", "else if (bitlen != atttypmod)", "ereport(ERROR,", "(errcode(ERRCODE_STRING_DATA_LENGTH_MISMATCH),", "errmsg(\"bit string length %d does not match type bit(%d)\",", "bitlen, atttypmod)));", "len = VARBITTOTALLEN(atttypmod);", "result = (VarBit *) palloc0(len);", "SET_VARSIZE(result, len);", "VARBITLEN(result) = atttypmod;", "r = VARBITS(result);", "if (bit_not_hex)", "{", "x = HIGHBIT;", "for (; *sp; sp++)", "{", "if (*sp == '1')", "*r |= x;", "else if (*sp != '0')", "ereport(ERROR,", "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),", "errmsg(\"\\\"%c\\\" is not a valid binary digit\",", "*sp)));", "x >>= 1;", "if (x == 0)", "{", "x = HIGHBIT;", "r++;", "}", "}", "}", "else", "{", "for (bc = 0; *sp; sp++)", "{", "if (*sp >= '0' && *sp <= '9')", "x = (bits8) (*sp - '0');", "else if (*sp >= 'A' && *sp <= 'F')", "x = (bits8) (*sp - 'A') + 10;", "else if (*sp >= 'a' && *sp <= 'f')", "x = (bits8) (*sp - 'a') + 10;", "else", "ereport(ERROR,", "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),", "errmsg(\"\\\"%c\\\" is not a valid hexadecimal digit\",", "*sp)));", "if (bc)", "{", "*r++ |= x;", "bc = 0;", "}", "else", "{", "*r = x << 4;", "bc = 1;", "}", "}", "}", "PG_RETURN_VARBIT_P(result);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static void gf_m2ts_process_pmt(GF_M2TS_Demuxer *ts, GF_M2TS_SECTION_ES *pmt, GF_List *sections, u8 table_id, u16 ex_table_id, u8 version_number, u8 last_section_number, u32 status)", "{", "u32 info_length, pos, desc_len, evt_type, nb_es,i;", "u32 nb_sections;", "u32 data_size;", "u32 nb_hevc, nb_hevc_temp, nb_shvc, nb_shvc_temp, nb_mhvc, nb_mhvc_temp;", "unsigned char *data;", "GF_M2TS_Section *section;", "GF_Err e = GF_OK;", "if (!(status&GF_M2TS_TABLE_END)) return;", "nb_es = 0;", "if ((status&GF_M2TS_TABLE_REPEAT) && !(status&GF_M2TS_TABLE_UPDATE))  {", "if (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_PMT_REPEAT, pmt->program);", "return;", "}", "if (pmt->sec->demux_restarted) {", "pmt->sec->demux_restarted = 0;", "return;", "}", "GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PMT Found or updated\\n\"));", "nb_sections = gf_list_count(sections);", "if (nb_sections > 1) {", "GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"PMT on multiple sections not supported\\n\"));", "}", "section = (GF_M2TS_Section *)gf_list_get(sections, 0);", "data = section->data;", "data_size = section->data_size;", "pmt->program->pcr_pid = ((data[0] & 0x1f) << 8) | data[1];", "info_length = ((data[2]&0xf)<<8) | data[3];", "if (info_length != 0) {", "u8 tag, len;", "u32 first_loop_len = 0;", "tag = data[4];", "len = data[5];", "while (info_length > first_loop_len) {", "if (tag == GF_M2TS_MPEG4_IOD_DESCRIPTOR) {", "u32 size;", "GF_BitStream *iod_bs;", "iod_bs = gf_bs_new((char *)data+8, len-2, GF_BITSTREAM_READ);", "if (pmt->program->pmt_iod) gf_odf_desc_del((GF_Descriptor *)pmt->program->pmt_iod);", "e = gf_odf_parse_descriptor(iod_bs , (GF_Descriptor **) &pmt->program->pmt_iod, &size);", "gf_bs_del(iod_bs );", "if (e==GF_OK) {", "if (pmt->program->pmt_iod) pmt->program->pmt_iod->ServiceID = pmt->program->number;", "if (!gf_list_count(pmt->program->pmt_iod->ESDescriptors)) {", "gf_odf_desc_del((GF_Descriptor *)pmt->program->pmt_iod);", "pmt->program->pmt_iod = NULL;", "}", "}", "} else if (tag == GF_M2TS_METADATA_POINTER_DESCRIPTOR) {", "GF_BitStream *metadatapd_bs;", "GF_M2TS_MetadataPointerDescriptor *metapd;", "metadatapd_bs = gf_bs_new((char *)data+6, len, GF_BITSTREAM_READ);", "metapd = gf_m2ts_read_metadata_pointer_descriptor(metadatapd_bs, len);", "gf_bs_del(metadatapd_bs);", "if (metapd->application_format_identifier == GF_M2TS_META_ID3 &&", "metapd->format_identifier == GF_M2TS_META_ID3 &&", "metapd->carriage_flag == METADATA_CARRIAGE_SAME_TS) {", "pmt->program->metadata_pointer_descriptor = metapd;", "} else {", "gf_m2ts_metadata_pointer_descriptor_del(metapd);", "}", "} else {", "GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Skipping descriptor (0x%x) and others not supported\\n\", tag));", "}", "first_loop_len += 2 + len;", "}", "}", "if (data_size <= 4 + info_length) return;", "data += 4 + info_length;", "data_size -= 4 + info_length;", "pos = 0;", "for(i=0; i<gf_list_count(ts->programs); i++) {", "GF_M2TS_Program *prog = (GF_M2TS_Program *)gf_list_get(ts->programs,i);", "if(prog->pmt_pid == pmt->pid) {", "break;", "}", "}", "nb_hevc = nb_hevc_temp = nb_shvc = nb_shvc_temp = nb_mhvc = nb_mhvc_temp = 0;", "while (pos<data_size) {", "GF_M2TS_PES *pes = NULL;", "GF_M2TS_SECTION_ES *ses = NULL;", "GF_M2TS_ES *es = NULL;", "Bool inherit_pcr = 0;", "u32 pid, stream_type, reg_desc_format;", "stream_type = data[0];", "pid = ((data[1] & 0x1f) << 8) | data[2];", "desc_len = ((data[3] & 0xf) << 8) | data[4];", "GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"stream_type :%d \\n\",stream_type));", "switch (stream_type) {", "case GF_M2TS_VIDEO_MPEG1:", "case GF_M2TS_VIDEO_MPEG2:", "case GF_M2TS_VIDEO_DCII:", "case GF_M2TS_VIDEO_MPEG4:", "case GF_M2TS_SYSTEMS_MPEG4_PES:", "case GF_M2TS_VIDEO_H264:", "case GF_M2TS_VIDEO_SVC:", "case GF_M2TS_VIDEO_MVCD:", "case GF_M2TS_VIDEO_HEVC:", "case GF_M2TS_VIDEO_HEVC_MCTS:", "case GF_M2TS_VIDEO_HEVC_TEMPORAL:", "case GF_M2TS_VIDEO_SHVC:", "case GF_M2TS_VIDEO_SHVC_TEMPORAL:", "case GF_M2TS_VIDEO_MHVC:", "case GF_M2TS_VIDEO_MHVC_TEMPORAL:", "inherit_pcr = 1;", "case GF_M2TS_AUDIO_MPEG1:", "case GF_M2TS_AUDIO_MPEG2:", "case GF_M2TS_AUDIO_AAC:", "case GF_M2TS_AUDIO_LATM_AAC:", "case GF_M2TS_AUDIO_AC3:", "case GF_M2TS_AUDIO_DTS:", "case GF_M2TS_MHAS_MAIN:", "case GF_M2TS_MHAS_AUX:", "case GF_M2TS_SUBTITLE_DVB:", "case GF_M2TS_METADATA_PES:", "GF_SAFEALLOC(pes, GF_M2TS_PES);", "if (!pes) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG2TS] Failed to allocate ES for pid %d\\n\", pid));", "return;", "}", "pes->cc = -1;", "pes->flags = GF_M2TS_ES_IS_PES;", "if (inherit_pcr)", "pes->flags |= GF_M2TS_INHERIT_PCR;", "es = (GF_M2TS_ES *)pes;", "break;", "case GF_M2TS_PRIVATE_DATA:", "GF_SAFEALLOC(pes, GF_M2TS_PES);", "if (!pes) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG2TS] Failed to allocate ES for pid %d\\n\", pid));", "return;", "}", "pes->cc = -1;", "pes->flags = GF_M2TS_ES_IS_PES;", "es = (GF_M2TS_ES *)pes;", "break;", "case GF_M2TS_SYSTEMS_MPEG4_SECTIONS:", "GF_SAFEALLOC(ses, GF_M2TS_SECTION_ES);", "if (!ses) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG2TS] Failed to allocate ES for pid %d\\n\", pid));", "return;", "}", "es = (GF_M2TS_ES *)ses;", "es->flags |= GF_M2TS_ES_IS_SECTION;", "if (stream_type == GF_M2TS_SYSTEMS_MPEG4_SECTIONS) {", "ses->sec = gf_m2ts_section_filter_new(gf_m2ts_process_mpeg4section, 0);", "if (!pmt->program->additional_ods) {", "pmt->program->additional_ods = gf_list_new();", "ts->has_4on2 = 1;", "}", "}", "break;", "case GF_M2TS_13818_6_ANNEX_A:", "case GF_M2TS_13818_6_ANNEX_B:", "case GF_M2TS_13818_6_ANNEX_C:", "case GF_M2TS_13818_6_ANNEX_D:", "case GF_M2TS_PRIVATE_SECTION:", "case GF_M2TS_QUALITY_SEC:", "case GF_M2TS_MORE_SEC:", "GF_SAFEALLOC(ses, GF_M2TS_SECTION_ES);", "if (!ses) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG2TS] Failed to allocate ES for pid %d\\n\", pid));", "return;", "}", "es = (GF_M2TS_ES *)ses;", "es->flags |= GF_M2TS_ES_IS_SECTION;", "es->pid = pid;", "es->service_id = pmt->program->number;", "if (stream_type == GF_M2TS_PRIVATE_SECTION) {", "GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"AIT sections on pid %d\\n\", pid));", "} else if (stream_type == GF_M2TS_QUALITY_SEC) {", "GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"Quality metadata sections on pid %d\\n\", pid));", "} else if (stream_type == GF_M2TS_MORE_SEC) {", "GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"MORE sections on pid %d\\n\", pid));", "} else {", "GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"stream type DSM CC user private sections on pid %d \\n\", pid));", "}", "ses->sec = gf_m2ts_section_filter_new(NULL, 1);", "break;", "case GF_M2TS_MPE_SECTIONS:", "if (! ts->prefix_present) {", "GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"stream type MPE found : pid = %d \\n\", pid));", "#ifdef GPAC_ENABLE_MPE", "es = gf_dvb_mpe_section_new();", "if (es->flags & GF_M2TS_ES_IS_SECTION) {", "((GF_M2TS_SECTION_ES*)es)->sec = gf_m2ts_section_filter_new(NULL, 1);", "}", "#endif", "break;", "}", "default:", "GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Stream type (0x%x) for PID %d not supported\\n\", stream_type, pid ) );", "break;", "}", "if (es) {", "es->stream_type = (stream_type==GF_M2TS_PRIVATE_DATA) ? 0 : stream_type;", "es->program = pmt->program;", "es->pid = pid;", "es->component_tag = -1;", "}", "pos += 5;", "data += 5;", "while (desc_len) {", "u8 tag = data[0];", "u32 len = data[1];", "if (es) {", "switch (tag) {", "case GF_M2TS_ISO_639_LANGUAGE_DESCRIPTOR:", "if (pes)", "pes->lang = GF_4CC(' ', data[2], data[3], data[4]);", "break;", "case GF_M2TS_MPEG4_SL_DESCRIPTOR:", "es->mpeg4_es_id = ( (u32) data[2] & 0x1f) << 8  | data[3];", "es->flags |= GF_M2TS_ES_IS_SL;", "break;", "case GF_M2TS_REGISTRATION_DESCRIPTOR:", "reg_desc_format = GF_4CC(data[2], data[3], data[4], data[5]);", "switch (reg_desc_format) {", "case GF_M2TS_RA_STREAM_AC3:", "es->stream_type = GF_M2TS_AUDIO_AC3;", "break;", "case GF_M2TS_RA_STREAM_VC1:", "es->stream_type = GF_M2TS_VIDEO_VC1;", "break;", "case GF_M2TS_RA_STREAM_GPAC:", "if (len==8) {", "es->stream_type = GF_4CC(data[6], data[7], data[8], data[9]);", "es->flags |= GF_M2TS_GPAC_CODEC_ID;", "break;", "}", "default:", "GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"Unknown registration descriptor %s\\n\", gf_4cc_to_str(reg_desc_format) ));", "break;", "}", "break;", "case GF_M2TS_DVB_EAC3_DESCRIPTOR:", "es->stream_type = GF_M2TS_AUDIO_EC3;", "break;", "case GF_M2TS_DVB_DATA_BROADCAST_ID_DESCRIPTOR:", "{", "u32 id = data[2]<<8 | data[3];", "if ((id == 0xB) && ses && !ses->sec) {", "ses->sec = gf_m2ts_section_filter_new(NULL, 1);", "}", "}", "break;", "case GF_M2TS_DVB_SUBTITLING_DESCRIPTOR:", "if (pes) {", "pes->sub.language[0] = data[2];", "pes->sub.language[1] = data[3];", "pes->sub.language[2] = data[4];", "pes->sub.type = data[5];", "pes->sub.composition_page_id = (data[6]<<8) | data[7];", "pes->sub.ancillary_page_id = (data[8]<<8) | data[9];", "}", "es->stream_type = GF_M2TS_DVB_SUBTITLE;", "break;", "case GF_M2TS_DVB_STREAM_IDENTIFIER_DESCRIPTOR:", "{", "es->component_tag = data[2];", "GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"Component Tag: %d on Program %d\\n\", es->component_tag, es->program->number));", "}", "break;", "case GF_M2TS_DVB_TELETEXT_DESCRIPTOR:", "es->stream_type = GF_M2TS_DVB_TELETEXT;", "break;", "case GF_M2TS_DVB_VBI_DATA_DESCRIPTOR:", "es->stream_type = GF_M2TS_DVB_VBI;", "break;", "case GF_M2TS_HIERARCHY_DESCRIPTOR:", "if (pes) {", "u8 hierarchy_embedded_layer_index;", "GF_BitStream *hbs = gf_bs_new((const char *)data, data_size, GF_BITSTREAM_READ);", "gf_bs_read_int(hbs, 16);", "gf_bs_read_int(hbs, 1);", "gf_bs_read_int(hbs, 1);", "gf_bs_read_int(hbs, 1);", "gf_bs_read_int(hbs, 1);", "gf_bs_read_int(hbs, 4);", "gf_bs_read_int(hbs, 2);", "gf_bs_read_int(hbs, 6);", "gf_bs_read_int(hbs, 1);", "gf_bs_read_int(hbs, 1);", "hierarchy_embedded_layer_index = gf_bs_read_int(hbs, 6);", "gf_bs_read_int(hbs, 2);", "gf_bs_read_int(hbs, 6);", "gf_bs_del(hbs);", "pes->depends_on_pid = 1+hierarchy_embedded_layer_index;", "}", "break;", "case GF_M2TS_METADATA_DESCRIPTOR:", "{", "GF_BitStream *metadatad_bs;", "GF_M2TS_MetadataDescriptor *metad;", "metadatad_bs = gf_bs_new((char *)data+2, len, GF_BITSTREAM_READ);", "metad = gf_m2ts_read_metadata_descriptor(metadatad_bs, len);", "gf_bs_del(metadatad_bs);", "if (metad->application_format_identifier == GF_M2TS_META_ID3 &&", "metad->format_identifier == GF_M2TS_META_ID3) {", "if (pes) {", "pes->metadata_descriptor = metad;", "pes->stream_type = GF_M2TS_METADATA_ID3_HLS;", "}", "} else {", "gf_m2ts_metadata_descriptor_del(metad);", "}", "}", "break;", "default:", "GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] skipping descriptor (0x%x) not supported\\n\", tag));", "break;", "}", "}", "data += len+2;", "pos += len+2;", "if (desc_len < len+2) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Invalid PMT es descriptor size for PID %d\\n\", pid ) );", "break;", "}", "desc_len-=len+2;", "}", "if (es && !es->stream_type) {", "gf_free(es);", "es = NULL;", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Private Stream type (0x%x) for PID %d not supported\\n\", stream_type, pid ) );", "}", "if (!es) continue;", "if (ts->ess[pid]) {", "if (status & GF_M2TS_TABLE_FOUND) {", "GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d reused across programs %d and %d, not completely supported\\n\", pid, ts->ess[pid]->program->number, es->program->number ) );", "gf_list_add(pmt->program->streams, es);", "if (!(es->flags & GF_M2TS_ES_IS_SECTION) ) gf_m2ts_set_pes_framing(pes, GF_M2TS_PES_FRAMING_SKIP);", "nb_es++;", "es = NULL;", "}", "else {", "GF_M2TS_ES *o_es = ts->ess[es->pid];", "if ((o_es->stream_type == es->stream_type)", "&& ((o_es->flags & GF_M2TS_ES_STATIC_FLAGS_MASK) == (es->flags & GF_M2TS_ES_STATIC_FLAGS_MASK))", "&& (o_es->mpeg4_es_id == es->mpeg4_es_id)", "&& ((o_es->flags & GF_M2TS_ES_IS_SECTION) || ((GF_M2TS_PES *)o_es)->lang == ((GF_M2TS_PES *)es)->lang)", ") {", "gf_free(es);", "es = NULL;", "} else {", "gf_m2ts_es_del(o_es, ts);", "ts->ess[es->pid] = NULL;", "}", "}", "}", "if (es) {", "ts->ess[es->pid] = es;", "gf_list_add(pmt->program->streams, es);", "if (!(es->flags & GF_M2TS_ES_IS_SECTION) ) gf_m2ts_set_pes_framing(pes, GF_M2TS_PES_FRAMING_SKIP);", "nb_es++;", "}", "if (es->stream_type == GF_M2TS_VIDEO_HEVC) nb_hevc++;", "else if (es->stream_type == GF_M2TS_VIDEO_HEVC_TEMPORAL) nb_hevc_temp++;", "else if (es->stream_type == GF_M2TS_VIDEO_SHVC) nb_shvc++;", "else if (es->stream_type == GF_M2TS_VIDEO_SHVC_TEMPORAL) nb_shvc_temp++;", "else if (es->stream_type == GF_M2TS_VIDEO_MHVC) nb_mhvc++;", "else if (es->stream_type == GF_M2TS_VIDEO_MHVC_TEMPORAL) nb_mhvc_temp++;", "}", "if (nb_hevc_temp + nb_shvc + nb_shvc_temp + nb_mhvc+ nb_mhvc_temp) {", "for (i=0; i<gf_list_count(pmt->program->streams); i++) {", "GF_M2TS_PES *es = (GF_M2TS_PES *)gf_list_get(pmt->program->streams, i);", "if ( !(es->flags & GF_M2TS_ES_IS_PES)) continue;", "if (es->depends_on_pid) continue;", "switch (es->stream_type) {", "case GF_M2TS_VIDEO_HEVC_TEMPORAL:", "es->depends_on_pid = 1;", "break;", "case GF_M2TS_VIDEO_SHVC:", "if (!nb_hevc_temp) es->depends_on_pid = 1;", "else es->depends_on_pid = 2;", "break;", "case GF_M2TS_VIDEO_SHVC_TEMPORAL:", "es->depends_on_pid = 3;", "break;", "case GF_M2TS_VIDEO_MHVC:", "if (!nb_hevc_temp) es->depends_on_pid = 1;", "else es->depends_on_pid = 2;", "break;", "case GF_M2TS_VIDEO_MHVC_TEMPORAL:", "if (!nb_hevc_temp) es->depends_on_pid = 2;", "else es->depends_on_pid = 3;", "break;", "}", "}", "}", "if (nb_es) {", "u32 i;", "for (i=0; i<gf_list_count(pmt->program->streams); i++) {", "GF_M2TS_PES *an_es = NULL;", "GF_M2TS_PES *es = (GF_M2TS_PES *)gf_list_get(pmt->program->streams, i);", "if ( !(es->flags & GF_M2TS_ES_IS_PES)) continue;", "if (!es->depends_on_pid) continue;", "an_es =  (GF_M2TS_PES *)gf_list_get(pmt->program->streams, es->depends_on_pid);", "if (an_es) {", "es->depends_on_pid = an_es->pid;", "} else {", "GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[M2TS] Wrong dependency index in hierarchy descriptor, assuming non-scalable stream\\n\"));", "es->depends_on_pid = 0;", "}", "}", "evt_type = (status&GF_M2TS_TABLE_FOUND) ? GF_M2TS_EVT_PMT_FOUND : GF_M2TS_EVT_PMT_UPDATE;", "if (ts->on_event) ts->on_event(ts, evt_type, pmt->program);", "} else {", "if (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_PMT_REPEAT, pmt->program);", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["sf_flac_write_callback (const FLAC__StreamDecoder * UNUSED (decoder), const FLAC__Frame *frame, const int32_t * const buffer [], void *client_data)", "{ SF_PRIVATE *psf = (SF_PRIVATE*) client_data ;", "FLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;", "pflac->frame = frame ;", "pflac->bufferpos = 0 ;", "pflac->bufferbackup = SF_FALSE ;", "pflac->wbuffer = buffer ;", "flac_buffer_copy (psf) ;", "return FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE ;", "}"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["int ras_validate(jas_stream_t *in)", "{", "uchar buf[RAS_MAGICLEN];", "int i;", "int n;", "uint_fast32_t magic;", "assert(JAS_STREAM_MAXPUTBACK >= RAS_MAGICLEN);", "if ((n = jas_stream_read(in, buf, RAS_MAGICLEN)) < 0) {", "return -1;", "}", "for (i = n - 1; i >= 0; --i) {", "if (jas_stream_ungetc(in, buf[i]) == EOF) {", "return -1;", "}", "}", "if (n < RAS_MAGICLEN) {", "return -1;", "}", "magic = (JAS_CAST(uint_fast32_t, buf[0]) << 24) |", "(JAS_CAST(uint_fast32_t, buf[1]) << 16) |", "(JAS_CAST(uint_fast32_t, buf[2]) << 8) |", "buf[3];", "if (magic != RAS_MAGIC) {", "return -1;", "}", "return 0;", "}"], "ner_tags": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["GF_Err abst_box_read(GF_Box *s, GF_BitStream *bs)", "{", "GF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;", "int i;", "u32 tmp_strsize;", "char *tmp_str;", "GF_Err e;", "ISOM_DECREASE_SIZE(ptr, 25)", "ptr->bootstrapinfo_version = gf_bs_read_u32(bs);", "ptr->profile = gf_bs_read_int(bs, 2);", "ptr->live = gf_bs_read_int(bs, 1);", "ptr->update = gf_bs_read_int(bs, 1);", "ptr->reserved = gf_bs_read_int(bs, 4);", "ptr->time_scale = gf_bs_read_u32(bs);", "ptr->current_media_time = gf_bs_read_u64(bs);", "ptr->smpte_time_code_offset = gf_bs_read_u64(bs);", "i=0;", "if (ptr->size<8) return GF_ISOM_INVALID_FILE;", "tmp_strsize =(u32)ptr->size-8;", "tmp_str = gf_malloc(sizeof(char)*tmp_strsize);", "if (!tmp_str) return GF_OUT_OF_MEM;", "memset(tmp_str, 0, sizeof(char)*tmp_strsize);", "while (tmp_strsize) {", "ISOM_DECREASE_SIZE(ptr, 1)", "tmp_str[i] = gf_bs_read_u8(bs);", "tmp_strsize--;", "if (!tmp_str[i])", "break;", "i++;", "}", "if (i) {", "ptr->movie_identifier = gf_strdup(tmp_str);", "}", "ISOM_DECREASE_SIZE(ptr, 1)", "ptr->server_entry_count = gf_bs_read_u8(bs);", "for (i=0; i<ptr->server_entry_count; i++) {", "int j=0;", "tmp_strsize=(u32)ptr->size;", "while (tmp_strsize) {", "ISOM_DECREASE_SIZE(ptr, 1)", "tmp_str[j] = gf_bs_read_u8(bs);", "tmp_strsize--;", "if (!tmp_str[j])", "break;", "j++;", "}", "if (j) {", "gf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);", "}", "}", "ISOM_DECREASE_SIZE(ptr, 1)", "ptr->quality_entry_count = gf_bs_read_u8(bs);", "for (i=0; i<ptr->quality_entry_count; i++) {", "int j=0;", "tmp_strsize=(u32)ptr->size;", "while (tmp_strsize) {", "ISOM_DECREASE_SIZE(ptr, 1)", "tmp_str[j] = gf_bs_read_u8(bs);", "tmp_strsize--;", "if (!tmp_str[j])", "break;", "j++;", "}", "if (j) {", "gf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);", "}", "}", "i=0;", "tmp_strsize=(u32)ptr->size;", "while (tmp_strsize) {", "ISOM_DECREASE_SIZE(ptr, 1)", "tmp_str[i] = gf_bs_read_u8(bs);", "tmp_strsize--;", "if (!tmp_str[i])", "break;", "i++;", "}", "if (i) {", "ptr->drm_data = gf_strdup(tmp_str);", "}", "i=0;", "tmp_strsize=(u32)ptr->size;", "while (tmp_strsize) {", "ISOM_DECREASE_SIZE(ptr, 1)", "tmp_str[i] = gf_bs_read_u8(bs);", "tmp_strsize--;", "if (!tmp_str[i])", "break;", "i++;", "}", "if (i) {", "ptr->meta_data = gf_strdup(tmp_str);", "}", "ISOM_DECREASE_SIZE(ptr, 1)", "ptr->segment_run_table_count = gf_bs_read_u8(bs);", "for (i=0; i<ptr->segment_run_table_count; i++) {", "GF_AdobeSegmentRunTableBox *asrt = NULL;", "e = gf_isom_box_parse((GF_Box **)&asrt, bs);", "if (e) {", "if (asrt) gf_isom_box_del((GF_Box*)asrt);", "gf_free(tmp_str);", "return e;", "}", "gf_list_add(ptr->segment_run_table_entries, asrt);", "}", "ISOM_DECREASE_SIZE(ptr, 1)", "ptr->fragment_run_table_count = gf_bs_read_u8(bs);", "for (i=0; i<ptr->fragment_run_table_count; i++) {", "GF_AdobeFragmentRunTableBox *afrt = NULL;", "e = gf_isom_box_parse((GF_Box **)&afrt, bs);", "if (e) {", "if (afrt) gf_isom_box_del((GF_Box*)afrt);", "gf_free(tmp_str);", "return e;", "}", "gf_list_add(ptr->fragment_run_table_entries, afrt);", "}", "gf_free(tmp_str);", "return GF_OK;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["GF_Err ilst_item_box_read(GF_Box *s,GF_BitStream *bs)", "{", "GF_Err e;", "u32 sub_type;", "GF_Box *a = NULL;", "GF_ListItemBox *ptr = (GF_ListItemBox *)s;", "sub_type = gf_bs_peek_bits(bs, 32, 4);", "if (sub_type == GF_ISOM_BOX_TYPE_DATA ) {", "e = gf_isom_box_parse(&a, bs);", "if (!e && ptr->size < a->size) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isom] not enough bytes in box %s: %d left, reading %d (file %s, line %d)\\n\", gf_4cc_to_str(ptr->type), ptr->size, a->size, __FILE__, __LINE__ ));", "e = GF_ISOM_INVALID_FILE;", "}", "if (e) {", "if (a) gf_isom_box_del(a);", "return e;", "}", "ISOM_DECREASE_SIZE(ptr, a->size);", "if (a && ptr->data) gf_isom_box_del_parent(&ptr->child_boxes, (GF_Box *) ptr->data);", "if (a && a->size > 4 && a->type != GF_ISOM_BOX_TYPE_VOID) {", "ptr->data = (GF_DataBox *)a;", "if (!ptr->child_boxes) ptr->child_boxes = gf_list_new();", "gf_list_add(ptr->child_boxes, ptr->data);", "} else {", "ptr->data = NULL;", "gf_isom_box_del(a);", "}", "}", "else {", "u64 pos = gf_bs_get_position(bs);", "u64 prev_size = s->size;", "e = gf_isom_box_array_read(s, bs, NULL);", "if (e==GF_OK) return GF_OK;", "gf_isom_box_array_del(s->child_boxes);", "s->child_boxes=NULL;", "gf_bs_seek(bs, pos);", "s->size = prev_size;", "ptr->data = (GF_DataBox *)gf_isom_box_new_parent(&ptr->child_boxes, GF_ISOM_BOX_TYPE_DATA);", "ptr->data->qt_style = GF_TRUE;", "ISOM_DECREASE_SIZE(ptr, 2);", "ptr->data->dataSize = gf_bs_read_u16(bs);", "gf_bs_read_u16(bs);", "ptr->data->data = (char *) gf_malloc(sizeof(char)*(ptr->data->dataSize + 1));", "gf_bs_read_data(bs, ptr->data->data, ptr->data->dataSize);", "ptr->data->data[ptr->data->dataSize] = 0;", "ISOM_DECREASE_SIZE(ptr, ptr->data->dataSize);", "}", "return GF_OK;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int idprime_get_token_name(sc_card_t* card, char** tname)", "{", "idprime_private_data_t * priv = card->drv_data;", "sc_path_t tinfo_path = {\"\\x00\\x00\", 2, 0, 0, SC_PATH_TYPE_PATH, {\"\", 0}};", "sc_file_t *file = NULL;", "u8 buf[2];", "int r;", "LOG_FUNC_CALLED(card->ctx);", "if (tname == NULL) {", "LOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);", "}", "if (!priv->tinfo_present) {", "LOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);", "}", "memcpy(tinfo_path.value, priv->tinfo_df, 2);", "r = iso_ops->select_file(card, &tinfo_path, &file);", "if (r != SC_SUCCESS || file->size == 0) {", "sc_file_free(file);", "LOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);", "}", "r = iso_ops->read_binary(card, 0, buf, 2, 0);", "if (r < 2 || buf[1] > file->size) {", "sc_file_free(file);", "LOG_FUNC_RETURN(card->ctx, r);", "}", "sc_file_free(file);", "*tname = malloc(buf[1]);", "if (*tname == NULL) {", "LOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);", "}", "r = iso_ops->read_binary(card, 2, (unsigned char *)*tname, buf[1], 0);", "if (r < 1) {", "free(*tname);", "LOG_FUNC_RETURN(card->ctx, r);", "}", "if ((*tname)[r-1] != '\\0') {", "(*tname)[r-1] = '\\0';", "}", "LOG_FUNC_RETURN(card->ctx, SC_SUCCESS);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0]}
{"tokens": ["GF_Err gf_hinter_track_process(GF_RTPHinter *tkHint)", "{", "GF_Err e;", "u32 i, descIndex, duration;", "u64 ts;", "u8 PadBits;", "GF_Fraction ft;", "GF_ISOSample *samp;", "tkHint->HintSample = tkHint->RTPTime = 0;", "tkHint->TotalSample = gf_isom_get_sample_count(tkHint->file, tkHint->TrackNum);", "ft.num = tkHint->rtp_p->sl_config.timestampResolution;", "ft.den = tkHint->OrigTimeScale;", "e = GF_OK;", "for (i=0; i<tkHint->TotalSample; i++) {", "samp = gf_isom_get_sample(tkHint->file, tkHint->TrackNum, i+1, &descIndex);", "if (!samp) return gf_isom_last_error(tkHint->file);", "tkHint->CurrentSample = i + 1;", "if (samp->IsRAP==RAP_REDUNDANT) {", "tkHint->rtp_p->sl_header.AU_sequenceNumber -= 1;", "samp->IsRAP = RAP;", "}", "ts = ft.num * (samp->DTS+samp->CTS_Offset) / ft.den;", "tkHint->rtp_p->sl_header.compositionTimeStamp = ts;", "ts = ft.num * samp->DTS / ft.den;", "tkHint->rtp_p->sl_header.decodingTimeStamp = ts;", "tkHint->rtp_p->sl_header.randomAccessPointFlag = samp->IsRAP;", "tkHint->base_offset_in_sample = 0;", "if (tkHint->rtp_p->slMap.IV_length) {", "GF_ISMASample *s = gf_isom_get_ismacryp_sample(tkHint->file, tkHint->TrackNum, samp, descIndex);", "if (s->flags & GF_ISOM_ISMA_USE_SEL_ENC) tkHint->base_offset_in_sample += 1;", "if (s->flags & GF_ISOM_ISMA_IS_ENCRYPTED) tkHint->base_offset_in_sample += s->IV_length + s->KI_length;", "gf_free(samp->data);", "samp->data = s->data;", "samp->dataLength = s->dataLength;", "gf_rtp_builder_set_cryp_info(tkHint->rtp_p, s->IV, (char*)s->key_indicator, (s->flags & GF_ISOM_ISMA_IS_ENCRYPTED) ? 1 : 0);", "s->data = NULL;", "s->dataLength = 0;", "gf_isom_ismacryp_delete_sample(s);", "}", "if (tkHint->rtp_p->sl_config.usePaddingFlag) {", "gf_isom_get_sample_padding_bits(tkHint->file, tkHint->TrackNum, i+1, &PadBits);", "tkHint->rtp_p->sl_header.paddingBits = PadBits;", "} else {", "tkHint->rtp_p->sl_header.paddingBits = 0;", "}", "duration = gf_isom_get_sample_duration(tkHint->file, tkHint->TrackNum, i+1);", "if (tkHint->avc_nalu_size) {", "u32 v, size;", "u32 remain = samp->dataLength;", "char *ptr = samp->data;", "tkHint->rtp_p->sl_header.accessUnitStartFlag = 1;", "tkHint->rtp_p->sl_header.accessUnitEndFlag = 0;", "while (remain) {", "size = 0;", "v = tkHint->avc_nalu_size;", "if (v>remain) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[rtp hinter] Broken AVC nalu encapsulation: NALU size length is %d but only %d bytes left in sample %d\\n\", v, remain, tkHint->CurrentSample));", "break;", "}", "while (v) {", "size |= (u8) *ptr;", "ptr++;", "remain--;", "v-=1;", "if (v) size<<=8;", "}", "tkHint->base_offset_in_sample = samp->dataLength-remain;", "if (remain < size) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[rtp hinter] Broken AVC nalu encapsulation: NALU size is %d but only %d bytes left in sample %d\\n\", size, remain, tkHint->CurrentSample));", "break;", "}", "remain -= size;", "tkHint->rtp_p->sl_header.accessUnitEndFlag = remain ? 0 : 1;", "e = gf_rtp_builder_process(tkHint->rtp_p, ptr, size, (u8) !remain, samp->dataLength, duration, (u8) (descIndex + GF_RTP_TX3G_SIDX_OFFSET) );", "ptr += size;", "tkHint->rtp_p->sl_header.accessUnitStartFlag = 0;", "}", "} else {", "e = gf_rtp_builder_process(tkHint->rtp_p, samp->data, samp->dataLength, 1, samp->dataLength, duration, (u8) (descIndex + GF_RTP_TX3G_SIDX_OFFSET) );", "}", "tkHint->rtp_p->sl_header.packetSequenceNumber += 1;", "gf_set_progress(\"Hinting\", tkHint->CurrentSample, tkHint->TotalSample);", "tkHint->rtp_p->sl_header.AU_sequenceNumber += 1;", "gf_isom_sample_del(&samp);", "if (e) return e;", "}", "gf_rtp_builder_process(tkHint->rtp_p, NULL, 0, 1, 0, 0, 0);", "gf_isom_end_hint_sample(tkHint->file, tkHint->HintTrack, (u8) tkHint->SampleIsRAP);", "return GF_OK;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["int sqlite3WindowRewrite(Parse *pParse, Select *p){", "int rc = SQLITE_OK;", "if( p->pWin && p->pPrior==0 && (p->selFlags & SF_WinRewrite)==0 ){", "Vdbe *v = sqlite3GetVdbe(pParse);", "sqlite3 *db = pParse->db;", "Select *pSub = 0;", "SrcList *pSrc = p->pSrc;", "Expr *pWhere = p->pWhere;", "ExprList *pGroupBy = p->pGroupBy;", "Expr *pHaving = p->pHaving;", "ExprList *pSort = 0;", "ExprList *pSublist = 0;", "Window *pMWin = p->pWin;", "Window *pWin;", "Table *pTab;", "pTab = sqlite3DbMallocZero(db, sizeof(Table));", "if( pTab==0 ){", "return SQLITE_NOMEM;", "}", "p->pSrc = 0;", "p->pWhere = 0;", "p->pGroupBy = 0;", "p->pHaving = 0;", "p->selFlags &= ~SF_Aggregate;", "p->selFlags |= SF_WinRewrite;", "pSort = sqlite3ExprListDup(db, pMWin->pPartition, 0);", "pSort = exprListAppendList(pParse, pSort, pMWin->pOrderBy, 1);", "if( pSort && p->pOrderBy && p->pOrderBy->nExpr<=pSort->nExpr ){", "int nSave = pSort->nExpr;", "pSort->nExpr = p->pOrderBy->nExpr;", "if( sqlite3ExprListCompare(pSort, p->pOrderBy, -1)==0 ){", "sqlite3ExprListDelete(db, p->pOrderBy);", "p->pOrderBy = 0;", "}", "pSort->nExpr = nSave;", "}", "pMWin->iEphCsr = pParse->nTab++;", "pParse->nTab += 3;", "selectWindowRewriteEList(pParse, pMWin, pSrc, p->pEList, pTab, &pSublist);", "selectWindowRewriteEList(pParse, pMWin, pSrc, p->pOrderBy, pTab, &pSublist);", "pMWin->nBufferCol = (pSublist ? pSublist->nExpr : 0);", "pSublist = exprListAppendList(pParse, pSublist, pMWin->pPartition, 0);", "pSublist = exprListAppendList(pParse, pSublist, pMWin->pOrderBy, 0);", "for(pWin=pMWin; pWin; pWin=pWin->pNextWin){", "ExprList *pArgs = pWin->pOwner->x.pList;", "if( pWin->pFunc->funcFlags & SQLITE_FUNC_SUBTYPE ){", "selectWindowRewriteEList(pParse, pMWin, pSrc, pArgs, pTab, &pSublist);", "pWin->iArgCol = (pSublist ? pSublist->nExpr : 0);", "pWin->bExprArgs = 1;", "}else{", "pWin->iArgCol = (pSublist ? pSublist->nExpr : 0);", "pSublist = exprListAppendList(pParse, pSublist, pArgs, 0);", "}", "if( pWin->pFilter ){", "Expr *pFilter = sqlite3ExprDup(db, pWin->pFilter, 0);", "pSublist = sqlite3ExprListAppend(pParse, pSublist, pFilter);", "}", "pWin->regAccum = ++pParse->nMem;", "pWin->regResult = ++pParse->nMem;", "sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regAccum);", "}", "if( pSublist==0 ){", "pSublist = sqlite3ExprListAppend(pParse, 0,", "sqlite3Expr(db, TK_INTEGER, \"0\")", ");", "}", "pSub = sqlite3SelectNew(", "pParse, pSublist, pSrc, pWhere, pGroupBy, pHaving, pSort, 0, 0", ");", "p->pSrc = sqlite3SrcListAppend(pParse, 0, 0, 0);", "if( p->pSrc ){", "Table *pTab2;", "p->pSrc->a[0].pSelect = pSub;", "sqlite3SrcListAssignCursors(pParse, p->pSrc);", "pSub->selFlags |= SF_Expanded;", "pTab2 = sqlite3ResultSetOfSelect(pParse, pSub, SQLITE_AFF_NONE);", "if( pTab2==0 ){", "rc = SQLITE_NOMEM;", "}else{", "memcpy(pTab, pTab2, sizeof(Table));", "pTab->tabFlags |= TF_Ephemeral;", "p->pSrc->a[0].pTab = pTab;", "pTab = pTab2;", "}", "sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pMWin->iEphCsr, pSublist->nExpr);", "sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+1, pMWin->iEphCsr);", "sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+2, pMWin->iEphCsr);", "sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+3, pMWin->iEphCsr);", "}else{", "sqlite3SelectDelete(db, pSub);", "}", "if( db->mallocFailed ) rc = SQLITE_NOMEM;", "sqlite3DbFree(db, pTab);", "}", "return rc;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["auto uncomp = output_buffer.make_fragmented_temporary_buffer(uncomp_len, fragmented_temporary_buffer::default_fragment_size, [&] (bytes_mutable_view out) {", "auto ret = LZ4_decompress_safe(reinterpret_cast<const char*>(in.data()), reinterpret_cast<char*>(out.data()),", "in.size(), out.size());", "if (ret < 0) {", "throw std::runtime_error(\"CQL frame LZ4 uncompression failure\");", "}", "return out.size();", "});"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["static int jpc_siz_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate,", "jas_stream_t *in)", "{", "jpc_siz_t *siz = &ms->parms.siz;", "unsigned int i;", "uint_fast8_t tmp;", "cstate = 0;", "if (jpc_getuint16(in, &siz->caps) ||", "jpc_getuint32(in, &siz->width) ||", "jpc_getuint32(in, &siz->height) ||", "jpc_getuint32(in, &siz->xoff) ||", "jpc_getuint32(in, &siz->yoff) ||", "jpc_getuint32(in, &siz->tilewidth) ||", "jpc_getuint32(in, &siz->tileheight) ||", "jpc_getuint32(in, &siz->tilexoff) ||", "jpc_getuint32(in, &siz->tileyoff) ||", "jpc_getuint16(in, &siz->numcomps)) {", "return -1;", "}", "if (!siz->width || !siz->height || !siz->tilewidth ||", "!siz->tileheight || !siz->numcomps || siz->numcomps > 16384) {", "return -1;", "}", "if (siz->tilexoff >= siz->width || siz->tileyoff >= siz->height) {", "jas_eprintf(\"all tiles are outside the image area\\n\");", "return -1;", "}", "if (!(siz->comps = jas_alloc2(siz->numcomps, sizeof(jpc_sizcomp_t)))) {", "return -1;", "}", "for (i = 0; i < siz->numcomps; ++i) {", "if (jpc_getuint8(in, &tmp) ||", "jpc_getuint8(in, &siz->comps[i].hsamp) ||", "jpc_getuint8(in, &siz->comps[i].vsamp)) {", "jas_free(siz->comps);", "return -1;", "}", "if (siz->comps[i].hsamp == 0 || siz->comps[i].hsamp > 255) {", "jas_eprintf(\"invalid XRsiz value %d\\n\", siz->comps[i].hsamp);", "jas_free(siz->comps);", "return -1;", "}", "if (siz->comps[i].vsamp == 0 || siz->comps[i].vsamp > 255) {", "jas_eprintf(\"invalid YRsiz value %d\\n\", siz->comps[i].vsamp);", "jas_free(siz->comps);", "return -1;", "}", "siz->comps[i].sgnd = (tmp >> 7) & 1;", "siz->comps[i].prec = (tmp & 0x7f) + 1;", "}", "if (jas_stream_eof(in)) {", "jas_free(siz->comps);", "return -1;", "}", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0]}
{"tokens": ["void SFS_Expression(ScriptParser *parser)", "{", "u32 val = gf_bs_read_int(parser->bs, NUMBITS_EXPR_TYPE);", "if (parser->codec->LastError) return;", "switch(val) {", "case ET_CURVED_EXPR:", "SFS_AddString(parser, \"(\");", "SFS_CompoundExpression(parser);", "SFS_AddString(parser, \")\");", "break;", "case ET_NEGATIVE:", "SFS_AddString(parser, \"-\");", "SFS_Expression(parser);", "break;", "case ET_NOT:", "SFS_AddString(parser, \"!\");", "SFS_Expression(parser);", "break;", "case ET_ONESCOMP:", "SFS_AddString(parser, \"~\");", "SFS_Expression(parser);", "break;", "case ET_INCREMENT:", "SFS_AddString(parser, \"++\");", "SFS_Expression(parser);", "break;", "case ET_DECREMENT:", "SFS_AddString(parser, \"--\");", "SFS_Expression(parser);", "break;", "case ET_POST_INCREMENT:", "SFS_Expression(parser);", "SFS_AddString(parser, \"++\");", "break;", "case ET_POST_DECREMENT:", "SFS_Expression(parser);", "SFS_AddString(parser, \"--\");", "break;", "case ET_CONDTEST:", "SFS_Expression(parser);", "SFS_AddString(parser, \" ? \");", "SFS_Expression(parser);", "SFS_AddString(parser, \" : \");", "SFS_Expression(parser);", "break;", "case ET_STRING:", "SFS_AddString(parser, \"'\");", "SFS_GetString(parser);", "SFS_AddString(parser, \"'\");", "break;", "case ET_NUMBER:", "SFS_GetNumber(parser);", "break;", "case ET_IDENTIFIER:", "SFS_Identifier(parser);", "break;", "case ET_FUNCTION_CALL:", "SFS_FunctionCall(parser);", "break;", "case ET_NEW:", "SFS_NewObject(parser);", "break;", "case ET_OBJECT_MEMBER_ACCESS:", "SFS_ObjectMemberAccess(parser);", "break;", "case ET_OBJECT_METHOD_CALL:", "SFS_ObjectMethodCall(parser);", "break;", "case ET_ARRAY_DEREFERENCE:", "SFS_ArrayDeref(parser);", "break;", "case ET_MULTIPLY:", "SFS_Expression(parser);", "SFS_AddString(parser, \"*\");", "SFS_Expression(parser);", "break;", "case ET_DIVIDE:", "SFS_Expression(parser);", "SFS_AddString(parser, \"/\");", "SFS_Expression(parser);", "break;", "case ET_MOD:", "SFS_Expression(parser);", "SFS_AddString(parser, \"%\");", "SFS_Expression(parser);", "break;", "case ET_PLUS:", "SFS_Expression(parser);", "SFS_AddString(parser, \"+\");", "SFS_Expression(parser);", "break;", "case ET_MINUS:", "SFS_Expression(parser);", "SFS_AddString(parser, \"-\");", "SFS_Expression(parser);", "break;", "case ET_LSHIFT:", "SFS_Expression(parser);", "SFS_AddString(parser, \"<<\");", "SFS_Expression(parser);", "break;", "case ET_RSHIFT:", "SFS_Expression(parser);", "SFS_AddString(parser, \">>\");", "SFS_Expression(parser);", "break;", "case ET_RSHIFTFILL:", "SFS_Expression(parser);", "SFS_AddString(parser, \">>>\");", "SFS_Expression(parser);", "break;", "case ET_AND:", "SFS_Expression(parser);", "SFS_AddString(parser, \"&\");", "SFS_Expression(parser);", "break;", "case ET_XOR:", "SFS_Expression(parser);", "SFS_AddString(parser, \"^\");", "SFS_Expression(parser);", "break;", "case ET_OR:", "SFS_Expression(parser);", "SFS_AddString(parser, \"|\");", "SFS_Expression(parser);", "break;", "case ET_LT:", "SFS_Expression(parser);", "SFS_AddString(parser, \"<\");", "SFS_Expression(parser);", "break;", "case ET_LE:", "SFS_Expression(parser);", "SFS_AddString(parser, \"<=\");", "SFS_Expression(parser);", "break;", "case ET_GT:", "SFS_Expression(parser);", "SFS_AddString(parser, \">\");", "SFS_Expression(parser);", "break;", "case ET_GE:", "SFS_Expression(parser);", "SFS_AddString(parser, \">=\");", "SFS_Expression(parser);", "break;", "case ET_EQ:", "SFS_Expression(parser);", "SFS_AddString(parser, \"==\");", "SFS_Expression(parser);", "break;", "case ET_NE:", "SFS_Expression(parser);", "SFS_AddString(parser, \"!=\");", "SFS_Expression(parser);", "break;", "case ET_LAND:", "SFS_Expression(parser);", "SFS_AddString(parser, \"&&\");", "SFS_Expression(parser);", "break;", "case ET_LOR:", "SFS_Expression(parser);", "SFS_AddString(parser, \"||\");", "SFS_Expression(parser);", "break;", "case ET_ASSIGN:", "SFS_Expression(parser);", "SFS_AddString(parser, \"=\");", "SFS_Expression(parser);", "break;", "case ET_PLUSEQ:", "SFS_Expression(parser);", "SFS_AddString(parser, \"+=\");", "SFS_Expression(parser);", "break;", "case ET_MINUSEQ:", "SFS_Expression(parser);", "SFS_AddString(parser, \"-=\");", "SFS_Expression(parser);", "break;", "case ET_MULTIPLYEQ:", "SFS_Expression(parser);", "SFS_AddString(parser, \"*=\");", "SFS_Expression(parser);", "break;", "case ET_DIVIDEEQ:", "SFS_Expression(parser);", "SFS_AddString(parser, \"/=\");", "SFS_Expression(parser);", "break;", "case ET_MODEQ:", "SFS_Expression(parser);", "SFS_AddString(parser, \"%=\");", "SFS_Expression(parser);", "break;", "case ET_LSHIFTEQ:", "SFS_Expression(parser);", "SFS_AddString(parser, \"<<=\");", "SFS_Expression(parser);", "break;", "case ET_RSHIFTEQ:", "SFS_Expression(parser);", "SFS_AddString(parser, \">>=\");", "SFS_Expression(parser);", "break;", "case ET_RSHIFTFILLEQ:", "SFS_Expression(parser);", "SFS_AddString(parser, \">>>=\");", "SFS_Expression(parser);", "break;", "case ET_ANDEQ:", "SFS_Expression(parser);", "SFS_AddString(parser, \"&=\");", "SFS_Expression(parser);", "break;", "case ET_XOREQ:", "SFS_Expression(parser);", "SFS_AddString(parser, \"^=\");", "SFS_Expression(parser);", "break;", "case ET_OREQ:", "SFS_Expression(parser);", "SFS_AddString(parser, \"|=\");", "SFS_Expression(parser);", "break;", "case ET_BOOLEAN:", "SFS_GetBoolean(parser);", "break;", "case ET_VAR:", "SFS_AddString(parser, \"var \");", "SFS_Arguments(parser, GF_TRUE);", "break;", "case ET_FUNCTION_ASSIGN:", "SFS_AddString(parser, \"function \");", "SFS_Arguments(parser, GF_FALSE);", "SFS_StatementBlock(parser, GF_TRUE);", "break;", "default:", "parser->codec->LastError = GF_NON_COMPLIANT_BITSTREAM;", "break;", "}", "}"], "ner_tags": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["static void WritePixel(struct ngiflib_img * i, struct ngiflib_decode_context * context, u8 v) {", "struct ngiflib_gif * p = i->parent;", "if(v!=i->gce.transparent_color || !i->gce.transparent_flag) {", "#ifndef NGIFLIB_INDEXED_ONLY", "if(p->mode & NGIFLIB_MODE_INDEXED) {", "#endif /* NGIFLIB_INDEXED_ONLY */", "*context->frbuff_p.p8 = v;", "#ifndef NGIFLIB_INDEXED_ONLY", "} else", "*context->frbuff_p.p32 =", "GifIndexToTrueColor(i->palette, v);", "#endif /* NGIFLIB_INDEXED_ONLY */", "}", "if(--(context->Xtogo) <= 0) {", "#ifdef NGIFLIB_ENABLE_CALLBACKS", "if(p->line_cb) p->line_cb(p, context->line_p, context->curY);", "#endif /* NGIFLIB_ENABLE_CALLBACKS */", "context->Xtogo = i->width;", "switch(context->pass) {", "case 0:", "context->curY++;", "break;", "case 1:", "context->curY += 8;", "if(context->curY >= p->height) {", "context->pass++;", "context->curY = i->posY + 4;", "}", "break;", "case 2:", "context->curY += 8;", "if(context->curY >= p->height) {", "context->pass++;", "context->curY = i->posY + 2;", "}", "break;", "case 3:", "context->curY += 4;", "if(context->curY >= p->height) {", "context->pass++;", "context->curY = i->posY + 1;", "}", "break;", "case 4:", "context->curY += 2;", "break;", "}", "#ifndef NGIFLIB_INDEXED_ONLY", "if(p->mode & NGIFLIB_MODE_INDEXED) {", "#endif /* NGIFLIB_INDEXED_ONLY */", "#ifdef NGIFLIB_ENABLE_CALLBACKS", "context->line_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width;", "context->frbuff_p.p8 = context->line_p.p8 + i->posX;", "#else", "context->frbuff_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width + i->posX;", "#endif /* NGIFLIB_ENABLE_CALLBACKS */", "#ifndef NGIFLIB_INDEXED_ONLY", "} else {", "#ifdef NGIFLIB_ENABLE_CALLBACKS", "context->line_p.p32 = p->frbuff.p32 + (u32)context->curY*p->width;", "context->frbuff_p.p32 = context->line_p.p32 + i->posX;", "#else", "context->frbuff_p.p32 = p->frbuff.p32 + (u32)context->curY*p->width + i->posX;", "#endif /* NGIFLIB_ENABLE_CALLBACKS */", "}", "#endif /* NGIFLIB_INDEXED_ONLY */", "} else {", "#ifndef NGIFLIB_INDEXED_ONLY", "if(p->mode & NGIFLIB_MODE_INDEXED) {", "#endif /* NGIFLIB_INDEXED_ONLY */", "context->frbuff_p.p8++;", "#ifndef NGIFLIB_INDEXED_ONLY", "} else {", "context->frbuff_p.p32++;", "}", "#endif /* NGIFLIB_INDEXED_ONLY */", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["exif_mnote_data_canon_load (ExifMnoteData *ne,", "const unsigned char *buf, unsigned int buf_size)", "{", "ExifMnoteDataCanon *n = (ExifMnoteDataCanon *) ne;", "ExifShort c;", "size_t i, tcount, o, datao;", "if (!n || !buf || !buf_size) {", "exif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,", "\"ExifMnoteCanon\", \"Short MakerNote\");", "return;", "}", "datao = 6 + n->offset;", "if (CHECKOVERFLOW(datao, buf_size, 2)) {", "exif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,", "\"ExifMnoteCanon\", \"Short MakerNote\");", "return;", "}", "c = exif_get_short (buf + datao, n->order);", "datao += 2;", "exif_mnote_data_canon_clear (n);", "n->entries = exif_mem_alloc (ne->mem, sizeof (MnoteCanonEntry) * c);", "if (!n->entries) {", "EXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteCanon\", sizeof (MnoteCanonEntry) * c);", "return;", "}", "tcount = 0;", "for (i = c, o = datao; i; --i, o += 12) {", "size_t s;", "memset(&n->entries[tcount], 0, sizeof(MnoteCanonEntry));", "if (CHECKOVERFLOW(o,buf_size,12)) {", "exif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,", "\"ExifMnoteCanon\", \"Short MakerNote\");", "break;", "}", "n->entries[tcount].tag        = exif_get_short (buf + o, n->order);", "n->entries[tcount].format     = exif_get_short (buf + o + 2, n->order);", "n->entries[tcount].components = exif_get_long (buf + o + 4, n->order);", "n->entries[tcount].order      = n->order;", "exif_log (ne->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteCanon\",", "\"Loading entry 0x%x ('%s')...\", n->entries[tcount].tag,", "mnote_canon_tag_get_name (n->entries[tcount].tag));", "if ( exif_format_get_size (n->entries[tcount].format) &&", "buf_size / exif_format_get_size (n->entries[tcount].format) < n->entries[tcount].components", ") {", "exif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,", "\"ExifMnoteCanon\", \"Tag size overflow detected (%u * %lu)\", exif_format_get_size (n->entries[tcount].format), n->entries[tcount].components);", "continue;", "}", "s = exif_format_get_size (n->entries[tcount].format) *", "n->entries[tcount].components;", "n->entries[tcount].size = s;", "if (!s) {", "exif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,", "\"ExifMnoteCanon\",", "\"Invalid zero-length tag size\");", "continue;", "} else {", "size_t dataofs = o + 8;", "if (s > 4) dataofs = exif_get_long (buf + dataofs, n->order) + 6;", "if (CHECKOVERFLOW(dataofs, buf_size, s)) {", "exif_log (ne->log, EXIF_LOG_CODE_DEBUG,", "\"ExifMnoteCanon\",", "\"Tag data past end of buffer (%u > %u)\",", "(unsigned)(dataofs + s), buf_size);", "continue;", "}", "n->entries[tcount].data = exif_mem_alloc (ne->mem, s);", "if (!n->entries[tcount].data) {", "EXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteCanon\", s);", "continue;", "}", "memcpy (n->entries[tcount].data, buf + dataofs, s);", "}", "++tcount;", "}", "n->count = tcount;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["exif_mnote_data_pentax_load (ExifMnoteData *en,", "const unsigned char *buf, unsigned int buf_size)", "{", "ExifMnoteDataPentax *n = (ExifMnoteDataPentax *) en;", "size_t i, tcount, o, datao, base = 0;", "ExifShort c;", "if (!n || !buf || !buf_size) {", "exif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,", "\"ExifMnoteDataPentax\", \"Short MakerNote\");", "return;", "}", "datao = 6 + n->offset;", "if ((datao + 8 < datao) || (datao + 8 < 8) || (datao + 8 > buf_size)) {", "exif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,", "\"ExifMnoteDataPentax\", \"Short MakerNote\");", "return;", "}", "if (!memcmp(buf + datao, \"AOC\", 4)) {", "if ((buf[datao + 4] == 'I') && (buf[datao + 5] == 'I')) {", "n->version = pentaxV3;", "n->order = EXIF_BYTE_ORDER_INTEL;", "} else if ((buf[datao + 4] == 'M') && (buf[datao + 5] == 'M')) {", "n->version = pentaxV3;", "n->order = EXIF_BYTE_ORDER_MOTOROLA;", "} else {", "n->version = pentaxV2;", "}", "exif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataPentax\",", "\"Parsing Pentax maker note v%d...\", (int)n->version);", "datao += 4 + 2;", "base = MNOTE_PENTAX2_TAG_BASE;", "} else if (!memcmp(buf + datao, \"QVC\", 4)) {", "exif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataPentax\",", "\"Parsing Casio maker note v2...\");", "n->version = casioV2;", "base = MNOTE_CASIO2_TAG_BASE;", "datao += 4 + 2;", "} else {", "exif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataPentax\",", "\"Parsing Pentax maker note v1...\");", "n->version = pentaxV1;", "}", "c = exif_get_short (buf + datao, n->order);", "datao += 2;", "exif_mnote_data_pentax_clear (n);", "n->entries = exif_mem_alloc (en->mem, sizeof (MnotePentaxEntry) * c);", "if (!n->entries) {", "EXIF_LOG_NO_MEMORY(en->log, \"ExifMnoteDataPentax\", sizeof (MnotePentaxEntry) * c);", "return;", "}", "tcount = 0;", "for (i = c, o = datao; i; --i, o += 12) {", "size_t s;", "if ((o + 12 < o) || (o + 12 < 12) || (o + 12 > buf_size)) {", "exif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,", "\"ExifMnoteDataPentax\", \"Short MakerNote\");", "break;", "}", "n->entries[tcount].tag        = exif_get_short (buf + o + 0, n->order) + base;", "n->entries[tcount].format     = exif_get_short (buf + o + 2, n->order);", "n->entries[tcount].components = exif_get_long  (buf + o + 4, n->order);", "n->entries[tcount].order      = n->order;", "exif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnotePentax\",", "\"Loading entry 0x%x ('%s')...\", n->entries[tcount].tag,", "mnote_pentax_tag_get_name (n->entries[tcount].tag));", "s = exif_format_get_size (n->entries[tcount].format) *", "n->entries[tcount].components;", "n->entries[tcount].size = s;", "if (s) {", "size_t dataofs = o + 8;", "if (s > 4)", "dataofs = exif_get_long (buf + dataofs, n->order) + 6;", "if ((dataofs + s < dataofs) || (dataofs + s < s) ||", "(dataofs + s > buf_size)) {", "exif_log (en->log, EXIF_LOG_CODE_DEBUG,", "\"ExifMnoteDataPentax\", \"Tag data past end \"", "\"of buffer (%u > %u)\", (unsigned)(dataofs + s), buf_size);", "continue;", "}", "n->entries[tcount].data = exif_mem_alloc (en->mem, s);", "if (!n->entries[tcount].data) {", "EXIF_LOG_NO_MEMORY(en->log, \"ExifMnoteDataPentax\", s);", "continue;", "}", "memcpy (n->entries[tcount].data, buf + dataofs, s);", "}", "++tcount;", "}", "n->count = tcount;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["double GetGPMFSampleRate(size_t handle, uint32_t fourcc, uint32_t flags)", "{", "mp4object *mp4 = (mp4object *)handle;", "if (mp4 == NULL) return 0.0;", "GPMF_stream metadata_stream, *ms = &metadata_stream;", "uint32_t teststart = 0;", "uint32_t testend = mp4->indexcount;", "double rate = 0.0;", "if (mp4->indexcount < 1)", "return 0.0;", "if (mp4->indexcount > 3)", "{", "teststart++;", "testend--;", "}", "uint32_t *payload = GetPayload(handle, NULL, teststart);", "uint32_t payloadsize = GetPayloadSize(handle, teststart);", "int32_t ret = GPMF_Init(ms, payload, payloadsize);", "if (ret != GPMF_OK)", "goto cleanup;", "{", "uint32_t startsamples = 0;", "uint32_t endsamples = 0;", "uint32_t missing_samples = 0;", "while (ret == GPMF_OK && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))", "{", "missing_samples = 1;", "teststart++;", "payload = GetPayload(handle, payload, teststart);", "payloadsize = GetPayloadSize(handle, teststart);", "ret = GPMF_Init(ms, payload, payloadsize);", "}", "if (missing_samples)", "{", "teststart++;", "payload = GetPayload(handle, payload, teststart);", "payloadsize = GetPayloadSize(handle, teststart);", "ret = GPMF_Init(ms, payload, payloadsize);", "}", "if (ret == GPMF_OK)", "{", "uint32_t samples = GPMF_Repeat(ms);", "GPMF_stream find_stream;", "GPMF_CopyState(ms, &find_stream);", "if (!(flags & GPMF_SAMPLE_RATE_PRECISE) && GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))", "{", "startsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream)) - samples;", "payload = GetPayload(handle, payload, testend);", "payloadsize = GetPayloadSize(handle, testend);", "ret = GPMF_Init(ms, payload, payloadsize);", "if (ret != GPMF_OK)", "goto cleanup;", "if (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))", "{", "GPMF_CopyState(ms, &find_stream);", "if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))", "{", "endsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream));", "rate = (double)(endsamples - startsamples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);", "goto cleanup;", "}", "}", "rate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);", "}", "else", "{", "uint32_t payloadpos = 0, payloadcount = 0;", "double slope, top = 0.0, bot = 0.0, meanX = 0, meanY = 0;", "uint32_t *repeatarray = malloc(mp4->indexcount * 4 + 4);", "memset(repeatarray, 0, mp4->indexcount * 4 + 4);", "samples = 0;", "for (payloadpos = teststart; payloadpos < testend; payloadcount++, payloadpos++)", "{", "payload = GetPayload(handle, payload, payloadpos);", "payloadsize = GetPayloadSize(handle, payloadpos);", "ret = GPMF_Init(ms, payload, payloadsize);", "if (ret != GPMF_OK)", "goto cleanup;", "if (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))", "{", "GPMF_stream find_stream2;", "GPMF_CopyState(ms, &find_stream2);", "if (GPMF_OK == GPMF_FindNext(&find_stream2, fourcc, GPMF_CURRENT_LEVEL))", "{", "if (repeatarray)", "{", "float in, out;", "do", "{", "samples++;", "} while (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_CURRENT_LEVEL));", "repeatarray[payloadpos] = samples;", "meanY += (double)samples;", "GetPayloadTime(handle, payloadpos, &in, &out);", "meanX += out;", "}", "}", "else", "{", "uint32_t repeat = GPMF_Repeat(ms);", "samples += repeat;", "if (repeatarray)", "{", "float in, out;", "repeatarray[payloadpos] = samples;", "meanY += (double)samples;", "GetPayloadTime(handle, payloadpos, &in, &out);", "meanX += out;", "}", "}", "}", "}", "if (repeatarray)", "{", "meanY /= (double)payloadcount;", "meanX /= (double)payloadcount;", "for (payloadpos = teststart; payloadpos < testend; payloadpos++)", "{", "float in, out;", "GetPayloadTime(handle, payloadpos, &in, &out);", "top += ((double)out - meanX)*((double)repeatarray[payloadpos] - meanY);", "bot += ((double)out - meanX)*((double)out - meanX);", "}", "slope = top / bot;", "#if 0", "{", "double intercept;", "intercept = meanY - slope*meanX;", "printf(\"%c%c%c%c start offset = %f (%.3fms)\\n\", PRINTF_4CC(fourcc), intercept, 1000.0 * intercept / slope);", "}", "#endif", "rate = slope;", "}", "else", "{", "rate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);", "}", "free(repeatarray);", "goto cleanup;", "}", "}", "}", "cleanup:", "if (payload)", "{", "FreePayload(payload);", "payload = NULL;", "}", "return rate;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["xmlValidCtxtNormalizeAttributeValue(xmlValidCtxtPtr ctxt, xmlDocPtr doc,", "xmlNodePtr elem, const xmlChar *name, const xmlChar *value) {", "xmlChar *ret, *dst;", "const xmlChar *src;", "xmlAttributePtr attrDecl = NULL;", "int extsubset = 0;", "if (doc == NULL) return(NULL);", "if (elem == NULL) return(NULL);", "if (name == NULL) return(NULL);", "if (value == NULL) return(NULL);", "if ((elem->ns != NULL) && (elem->ns->prefix != NULL)) {", "xmlChar fn[50];", "xmlChar *fullname;", "fullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);", "if (fullname == NULL)", "return(NULL);", "attrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullname, name);", "if ((attrDecl == NULL) && (doc->extSubset != NULL)) {", "attrDecl = xmlGetDtdAttrDesc(doc->extSubset, fullname, name);", "if (attrDecl != NULL)", "extsubset = 1;", "}", "if ((fullname != fn) && (fullname != elem->name))", "xmlFree(fullname);", "}", "if ((attrDecl == NULL) && (doc->intSubset != NULL))", "attrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, name);", "if ((attrDecl == NULL) && (doc->extSubset != NULL)) {", "attrDecl = xmlGetDtdAttrDesc(doc->extSubset, elem->name, name);", "if (attrDecl != NULL)", "extsubset = 1;", "}", "if (attrDecl == NULL)", "return(NULL);", "if (attrDecl->atype == XML_ATTRIBUTE_CDATA)", "return(NULL);", "ret = xmlStrdup(value);", "if (ret == NULL)", "return(NULL);", "src = value;", "dst = ret;", "while (*src == 0x20) src++;", "while (*src != 0) {", "if (*src == 0x20) {", "while (*src == 0x20) src++;", "if (*src != 0)", "*dst++ = 0x20;", "} else {", "*dst++ = *src++;", "}", "}", "*dst = 0;", "if ((doc->standalone) && (extsubset == 1) && (!xmlStrEqual(value, ret))) {", "xmlErrValidNode(ctxt, elem, XML_DTD_NOT_STANDALONE,", "\"standalone: %s on %s value had to be normalized based on external subset declaration\\n\",", "name, elem->name, NULL);", "ctxt->valid = 0;", "}", "return(ret);", "}"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int vorbis_finish_frame(stb_vorbis *f, int len, int left, int right)", "{", "int prev,i,j;", "if (f->previous_length) {", "int i,j, n = f->previous_length;", "float *w = get_window(f, n);", "for (i=0; i < f->channels; ++i) {", "for (j=0; j < n; ++j)", "f->channel_buffers[i][left+j] =", "f->channel_buffers[i][left+j]*w[    j] +", "f->previous_window[i][     j]*w[n-1-j];", "}", "}", "prev = f->previous_length;", "f->previous_length = len - right;", "for (i=0; i < f->channels; ++i)", "for (j=0; right+j < len; ++j)", "f->previous_window[i][j] = f->channel_buffers[i][right+j];", "if (!prev)", "return 0;", "if (len < right) right = len;", "f->samples_output += right-left;", "return right - left;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int cac_cac1_get_certificate(sc_card_t *card, u8 **out_buf, size_t *out_len)", "{", "u8 buf[CAC_MAX_SIZE];", "u8 *out_ptr;", "size_t size = 0;", "size_t left = 0;", "size_t len, next_len;", "sc_apdu_t apdu;", "int r = SC_SUCCESS;", "SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);", "size = left = *out_buf ? *out_len : sizeof(buf);", "out_ptr = *out_buf ? *out_buf : buf;", "sc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, CAC_INS_GET_CERTIFICATE, 0, 0 );", "next_len = MIN(left, 100);", "for (; left > 0; left -= len, out_ptr += len) {", "len = next_len;", "apdu.resp = out_ptr;", "apdu.le = len;", "apdu.resplen = left;", "r = sc_transmit_apdu(card, &apdu);", "if (r < 0) {", "break;", "}", "if (apdu.resplen == 0) {", "r = SC_ERROR_INTERNAL;", "break;", "}", "if (apdu.sw1 != 0x63 || apdu.sw2 < 1)  {", "r = sc_check_sw(card, apdu.sw1, apdu.sw2);", "left -= len;", "break;", "}", "next_len = MIN(left, apdu.sw2);", "}", "if (r < 0) {", "SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);", "}", "r = size - left;", "if (*out_buf == NULL) {", "*out_buf = malloc(r);", "if (*out_buf == NULL) {", "SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,", "SC_ERROR_OUT_OF_MEMORY);", "}", "memcpy(*out_buf, buf, r);", "}", "*out_len = r;", "SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["archive_wstring_append_from_mbs(struct archive_wstring *dest,", "const char *p, size_t len)", "{", "size_t r;", "int ret_val = 0;", "size_t wcs_length = len;", "size_t mbs_length = len;", "const char *mbs = p;", "wchar_t *wcs;", "#if HAVE_MBRTOWC", "mbstate_t shift_state;", "memset(&shift_state, 0, sizeof(shift_state));", "#endif", "if (NULL == archive_wstring_ensure(dest, dest->length + wcs_length + 1))", "return (-1);", "wcs = dest->s + dest->length;", "while (*mbs && mbs_length > 0) {", "if (wcs_length == 0) {", "dest->length = wcs - dest->s;", "dest->s[dest->length] = L'\\0';", "wcs_length = mbs_length;", "if (NULL == archive_wstring_ensure(dest,", "dest->length + wcs_length + 1))", "return (-1);", "wcs = dest->s + dest->length;", "}", "#if HAVE_MBRTOWC", "r = mbrtowc(wcs, mbs, wcs_length, &shift_state);", "#else", "r = mbtowc(wcs, mbs, wcs_length);", "#endif", "if (r == (size_t)-1 || r == (size_t)-2) {", "ret_val = -1;", "if (errno == EILSEQ) {", "++mbs;", "--mbs_length;", "continue;", "} else", "break;", "}", "if (r == 0 || r > mbs_length)", "break;", "wcs++;", "wcs_length--;", "mbs += r;", "mbs_length -= r;", "}", "dest->length = wcs - dest->s;", "dest->s[dest->length] = L'\\0';", "return (ret_val);", "}"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static void WritePixels(struct ngiflib_img * i, struct ngiflib_decode_context * context, const u8 * pixels, u16 n) {", "u16 tocopy;", "struct ngiflib_gif * p = i->parent;", "while(n > 0) {", "tocopy = (context->Xtogo < n) ? context->Xtogo : n;", "if(!i->gce.transparent_flag) {", "#ifndef NGIFLIB_INDEXED_ONLY", "if(p->mode & NGIFLIB_MODE_INDEXED) {", "#endif /* NGIFLIB_INDEXED_ONLY */", "ngiflib_memcpy(context->frbuff_p.p8, pixels, tocopy);", "pixels += tocopy;", "context->frbuff_p.p8 += tocopy;", "#ifndef NGIFLIB_INDEXED_ONLY", "} else {", "int j;", "for(j = (int)tocopy; j > 0; j--) {", "*(context->frbuff_p.p32++) =", "GifIndexToTrueColor(i->palette, *pixels++);", "}", "}", "#endif /* NGIFLIB_INDEXED_ONLY */", "} else {", "int j;", "#ifndef NGIFLIB_INDEXED_ONLY", "if(p->mode & NGIFLIB_MODE_INDEXED) {", "#endif /* NGIFLIB_INDEXED_ONLY */", "for(j = (int)tocopy; j > 0; j--) {", "if(*pixels != i->gce.transparent_color) *context->frbuff_p.p8 = *pixels;", "pixels++;", "context->frbuff_p.p8++;", "}", "#ifndef NGIFLIB_INDEXED_ONLY", "} else {", "for(j = (int)tocopy; j > 0; j--) {", "if(*pixels != i->gce.transparent_color) {", "*context->frbuff_p.p32 = GifIndexToTrueColor(i->palette, *pixels);", "}", "pixels++;", "context->frbuff_p.p32++;", "}", "}", "#endif /* NGIFLIB_INDEXED_ONLY */", "}", "context->Xtogo -= tocopy;", "if(context->Xtogo == 0) {", "#ifdef NGIFLIB_ENABLE_CALLBACKS", "if(p->line_cb) p->line_cb(p, context->line_p, context->curY);", "#endif /* NGIFLIB_ENABLE_CALLBACKS */", "context->Xtogo = i->width;", "switch(context->pass) {", "case 0:", "context->curY++;", "break;", "case 1:", "context->curY += 8;", "if(context->curY >= p->height) {", "context->pass++;", "context->curY = i->posY + 4;", "}", "break;", "case 2:", "context->curY += 8;", "if(context->curY >= p->height) {", "context->pass++;", "context->curY = i->posY + 2;", "}", "break;", "case 3:", "context->curY += 4;", "if(context->curY >= p->height) {", "context->pass++;", "context->curY = i->posY + 1;", "}", "break;", "case 4:", "context->curY += 2;", "break;", "}", "#ifndef NGIFLIB_INDEXED_ONLY", "if(p->mode & NGIFLIB_MODE_INDEXED) {", "#endif /* NGIFLIB_INDEXED_ONLY */", "#ifdef NGIFLIB_ENABLE_CALLBACKS", "context->line_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width;", "context->frbuff_p.p8 = context->line_p.p8 + i->posX;", "#else", "context->frbuff_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width + i->posX;", "#endif /* NGIFLIB_ENABLE_CALLBACKS */", "#ifndef NGIFLIB_INDEXED_ONLY", "} else {", "#ifdef NGIFLIB_ENABLE_CALLBACKS", "context->line_p.p32 = p->frbuff.p32 + (u32)context->curY*p->width;", "context->frbuff_p.p32 = context->line_p.p32 + i->posX;", "#else", "context->frbuff_p.p32 = p->frbuff.p32 + (u32)context->curY*p->width + i->posX;", "#endif /* NGIFLIB_ENABLE_CALLBACKS */", "}", "#endif /* NGIFLIB_INDEXED_ONLY */", "}", "n -= tocopy;", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["GF_Err MergeTrack(GF_TrackBox *trak, GF_TrackFragmentBox *traf, GF_MovieFragmentBox *moof_box, u64 moof_offset, s32 compressed_diff, u64 *cumulated_offset, Bool is_first_merge)", "{", "u32 i, j, chunk_size, track_num;", "u64 base_offset, data_offset, traf_duration;", "u32 def_duration, DescIndex, def_size, def_flags;", "u32 duration, size, flags, prev_trun_data_offset, sample_index;", "u8 pad, sync;", "u16 degr;", "Bool first_samp_in_traf=GF_TRUE;", "Bool store_traf_map=GF_FALSE;", "u8 *moof_template=NULL;", "u32 moof_template_size=0;", "Bool is_seg_start = GF_FALSE;", "u64 seg_start=0, sidx_start=0, sidx_end=0, frag_start=0, last_dts=0;", "GF_TrackFragmentRunBox *trun;", "GF_TrunEntry *ent;", "#ifdef GF_ENABLE_CTRN", "GF_TrackFragmentBox *traf_ref = NULL;", "#endif", "GF_Err stbl_AppendTime(GF_SampleTableBox *stbl, u32 duration, u32 nb_pack);", "GF_Err stbl_AppendSize(GF_SampleTableBox *stbl, u32 size, u32 nb_pack);", "GF_Err stbl_AppendChunk(GF_SampleTableBox *stbl, u64 offset);", "GF_Err stbl_AppendSampleToChunk(GF_SampleTableBox *stbl, u32 DescIndex, u32 samplesInChunk);", "GF_Err stbl_AppendCTSOffset(GF_SampleTableBox *stbl, s32 CTSOffset);", "GF_Err stbl_AppendRAP(GF_SampleTableBox *stbl, u8 isRap);", "GF_Err stbl_AppendPadding(GF_SampleTableBox *stbl, u8 padding);", "GF_Err stbl_AppendDegradation(GF_SampleTableBox *stbl, u16 DegradationPriority);", "if (trak->Header->trackID != traf->tfhd->trackID) return GF_OK;", "if (!trak->Media->information->sampleTable", "|| !trak->Media->information->sampleTable->SampleSize", "|| !trak->Media->information->sampleTable->TimeToSample", "|| !trak->Media->information->sampleTable->SampleToChunk", "|| !trak->Media->information->sampleTable->ChunkOffset", ") {", "return GF_ISOM_INVALID_FILE;", "}", "if (!traf->trex->track)", "traf->trex->track = trak;", "DescIndex = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_DESC) ? traf->tfhd->sample_desc_index : traf->trex->def_sample_desc_index;", "if (!DescIndex) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] default sample description set to 0, likely broken ! Fixing to 1\\n\" ));", "DescIndex = 1;", "} else if (DescIndex > gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes)) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] default sample description set to %d but only %d sample description(s), likely broken ! Fixing to 1\\n\", DescIndex, gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes)));", "DescIndex = 1;", "}", "#ifdef GF_ENABLE_CTRN", "if (traf->trex->inherit_from_traf_id) {", "u32 traf_count = gf_list_count(moof_box->TrackList);", "for (i=0; i<traf_count; i++) {", "GF_TrackFragmentBox *atraf = gf_list_get(moof_box->TrackList, i);", "if (atraf->tfhd && atraf->tfhd->trackID==traf->trex->inherit_from_traf_id) {", "traf_ref = atraf;", "break;", "}", "}", "}", "#endif", "def_duration = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_DUR) ? traf->tfhd->def_sample_duration : traf->trex->def_sample_duration;", "def_size = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_SIZE) ? traf->tfhd->def_sample_size : traf->trex->def_sample_size;", "def_flags = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_FLAGS) ? traf->tfhd->def_sample_flags : traf->trex->def_sample_flags;", "base_offset = moof_offset;", "if (traf->tfhd->flags & GF_ISOM_TRAF_BASE_OFFSET)", "base_offset = traf->tfhd->base_data_offset;", "else if (!(traf->tfhd->flags & GF_ISOM_MOOF_BASE_OFFSET))", "base_offset = *cumulated_offset;", "chunk_size = 0;", "prev_trun_data_offset = 0;", "data_offset = 0;", "traf_duration = 0;", "if (traf->tfdt && is_first_merge) {", "#ifndef GPAC_DISABLE_LOG", "if (trak->moov->mov->NextMoofNumber && trak->present_in_scalable_segment && trak->sample_count_at_seg_start && (trak->dts_at_seg_start != traf->tfdt->baseMediaDecodeTime)) {", "s32 drift = (s32) ((s64) traf->tfdt->baseMediaDecodeTime - (s64)trak->dts_at_seg_start);", "if (drift<0)  {", "GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Warning: TFDT timing \"LLD\" less than cumulated timing \"LLD\" - using tfdt\\n\", traf->tfdt->baseMediaDecodeTime, trak->dts_at_seg_start ));", "} else {", "GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[iso file] TFDT timing \"LLD\" higher than cumulated timing \"LLD\" (last sample got extended in duration)\\n\", traf->tfdt->baseMediaDecodeTime, trak->dts_at_seg_start ));", "}", "}", "#endif", "trak->dts_at_seg_start = traf->tfdt->baseMediaDecodeTime;", "}", "else if (traf->tfxd) {", "trak->dts_at_seg_start = traf->tfxd->absolute_time_in_track_timescale;", "}", "if (traf->tfxd) {", "trak->last_tfxd_value = traf->tfxd->absolute_time_in_track_timescale;", "trak->last_tfxd_value += traf->tfxd->fragment_duration_in_track_timescale;", "}", "if (traf->tfrf) {", "if (trak->tfrf) gf_isom_box_del_parent(&trak->child_boxes, (GF_Box *)trak->tfrf);", "trak->tfrf = traf->tfrf;", "gf_list_del_item(traf->child_boxes, traf->tfrf);", "gf_list_add(trak->child_boxes, trak->tfrf);", "}", "if (trak->moov->mov->signal_frag_bounds) {", "store_traf_map = GF_TRUE;", "if (is_first_merge) {", "GF_MovieFragmentBox *moof_clone = NULL;", "gf_isom_box_freeze_order((GF_Box *)moof_box);", "gf_isom_clone_box((GF_Box *)moof_box, (GF_Box **)&moof_clone);", "if (moof_clone) {", "GF_BitStream *bs;", "for (i=0; i<gf_list_count(moof_clone->TrackList); i++) {", "GF_TrackFragmentBox *traf_clone = gf_list_get(moof_clone->TrackList, i);", "gf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->TrackRuns);", "gf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sampleGroups);", "gf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sampleGroupsDescription);", "gf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sub_samples);", "gf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sai_offsets);", "gf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sai_sizes);", "if (traf_clone->sample_encryption) {", "gf_isom_box_del_parent(&traf_clone->child_boxes, (GF_Box *) traf_clone->sample_encryption);", "traf_clone->sample_encryption = NULL;", "}", "if (traf_clone->sdtp) {", "gf_isom_box_del_parent(&traf_clone->child_boxes, (GF_Box *) traf_clone->sdtp);", "traf_clone->sdtp = NULL;", "}", "}", "gf_isom_box_size((GF_Box *)moof_clone);", "bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);", "if (trak->moov->mov->seg_styp) {", "gf_isom_box_size(trak->moov->mov->seg_styp);", "gf_isom_box_write(trak->moov->mov->seg_styp, bs);", "}", "if (trak->moov->mov->root_sidx) {", "gf_isom_box_size((GF_Box *)trak->moov->mov->root_sidx);", "gf_isom_box_write((GF_Box *)trak->moov->mov->root_sidx, bs);", "}", "if (trak->moov->mov->seg_ssix) {", "gf_isom_box_size(trak->moov->mov->seg_ssix);", "gf_isom_box_write(trak->moov->mov->seg_ssix, bs);", "}", "gf_isom_box_write((GF_Box *)moof_clone, bs);", "gf_isom_box_del((GF_Box*)moof_clone);", "gf_bs_get_content(bs, &moof_template, &moof_template_size);", "gf_bs_del(bs);", "}", "}", "if (trak->moov->mov->seg_styp) {", "is_seg_start = GF_TRUE;", "seg_start = trak->moov->mov->styp_start_offset;", "}", "if (trak->moov->mov->root_sidx) {", "is_seg_start = GF_TRUE;", "sidx_start = trak->moov->mov->sidx_start_offset;", "sidx_end = trak->moov->mov->sidx_end_offset;", "if (! seg_start || (sidx_start<seg_start))", "seg_start = sidx_start;", "}", "frag_start = trak->moov->mov->current_top_box_start;", "}", "else if (trak->moov->mov->store_traf_map) {", "store_traf_map = GF_TRUE;", "}", "sample_index = 0;", "i=0;", "while ((trun = (GF_TrackFragmentRunBox *)gf_list_enum(traf->TrackRuns, &i))) {", "for (j=0; j<trun->sample_count; j++) {", "GF_Err e;", "s32 cts_offset=0;", "if (j<trun->nb_samples) {", "ent = &trun->samples[j];", "} else {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Track %d doesn't have enough trun entries (%d) compared to sample count (%d) in run\\n\", traf->trex->trackID, trun->nb_samples, trun->sample_count ));", "break;", "}", "size = def_size;", "duration = def_duration;", "flags = def_flags;", "cts_offset = ent->CTS_Offset;", "#ifdef GF_ENABLE_CTRN", "if (trun->use_ctrn) {", "if (!j && (trun->ctrn_flags & GF_ISOM_CTRN_FIRST_SAMPLE) ) {", "if (trun->ctrn_first_dur) duration = ent->Duration;", "if (trun->ctrn_first_size) size = ent->size;", "if (trun->ctrn_first_ctts) flags = ent->flags;", "} else {", "if (trun->ctrn_dur) duration = ent->Duration;", "if (trun->ctrn_size) size = ent->size;", "if (trun->ctrn_sample_flags) flags = ent->flags;", "}", "if (trun->ctrn_flags & 0xF0) {", "GF_TrunEntry *ref_entry;", "if (!traf_ref) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Track %d use traf inheritance to track ID %d but reference traf not found\\n\", traf->trex->trackID, traf->trex->inherit_from_traf_id ));", "break;", "}", "ref_entry = traf_get_sample_entry(traf_ref, sample_index);", "if (!ref_entry) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Track %d use traf inheritance but sample %d not found in reference traf\\n\", traf->trex->trackID, sample_index+1 ));", "break;", "}", "if (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_DUR)", "duration = ref_entry->Duration;", "if (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_SIZE)", "size = ref_entry->size;", "if (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_FLAGS)", "flags = ref_entry->flags;", "if (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_CTSO)", "cts_offset = ref_entry->CTS_Offset;", "}", "} else", "#endif", "{", "if (trun->flags & GF_ISOM_TRUN_DURATION) duration = ent->Duration;", "if (trun->flags & GF_ISOM_TRUN_SIZE) size = ent->size;", "if (trun->flags & GF_ISOM_TRUN_FLAGS) {", "flags = ent->flags;", "} else if (!j && (trun->flags & GF_ISOM_TRUN_FIRST_FLAG)) {", "flags = trun->first_sample_flags;", "}", "}", "sample_index++;", "ent->size = size;", "ent->Duration = duration;", "ent->flags = flags;", "ent->CTS_Offset = cts_offset;", "last_dts += duration;", "if (!trak->Media->information->sampleTable->SampleSize) {", "trak->Media->information->sampleTable->SampleSize = (GF_SampleSizeBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STSZ);", "if (!trak->Media->information->sampleTable->SampleSize)", "return GF_OUT_OF_MEM;", "}", "e = stbl_AppendSize(trak->Media->information->sampleTable, size, ent->nb_pack);", "if (e) return e;", "if (!trak->Media->information->sampleTable->TimeToSample) {", "trak->Media->information->sampleTable->TimeToSample = (GF_TimeToSampleBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STTS);", "if (!trak->Media->information->sampleTable->TimeToSample)", "return GF_OUT_OF_MEM;", "}", "e = stbl_AppendTime(trak->Media->information->sampleTable, duration, ent->nb_pack);", "if (e) return e;", "if (!j) {", "u64 final_offset;", "data_offset = base_offset;", "if (trun->flags & GF_ISOM_TRUN_DATA_OFFSET) {", "data_offset += trun->data_offset;", "chunk_size = 0;", "prev_trun_data_offset = trun->data_offset;", "if (trun->data_offset>=0) {", "data_offset -= compressed_diff;", "prev_trun_data_offset -= compressed_diff;", "}", "}", "else if (prev_trun_data_offset) {", "data_offset += prev_trun_data_offset + chunk_size;", "}", "else {", "data_offset += chunk_size;", "if ((i==1) && (trun->data_offset>=0)) {", "data_offset -= compressed_diff;", "}", "}", "final_offset = data_offset;", "if (trak->moov->compressed_diff) {", "final_offset += trak->moov->compressed_diff;", "}", "if (!trak->Media->information->sampleTable->ChunkOffset) {", "trak->Media->information->sampleTable->ChunkOffset = gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STCO);", "if (!trak->Media->information->sampleTable->ChunkOffset)", "return GF_OUT_OF_MEM;", "}", "e = stbl_AppendChunk(trak->Media->information->sampleTable, final_offset);", "if (e) return e;", "if (!trak->Media->information->sampleTable->SampleToChunk) {", "trak->Media->information->sampleTable->SampleToChunk = (GF_SampleToChunkBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STSC);", "if (!trak->Media->information->sampleTable->SampleToChunk)", "return GF_OUT_OF_MEM;", "}", "e = stbl_AppendSampleToChunk(trak->Media->information->sampleTable,", "DescIndex, trun->sample_count);", "if (e) return e;", "}", "chunk_size += size;", "if (store_traf_map && first_samp_in_traf) {", "first_samp_in_traf = GF_FALSE;", "e = stbl_AppendTrafMap(trak->Media->information->sampleTable, is_seg_start, seg_start, frag_start, moof_template, moof_template_size, sidx_start, sidx_end);", "if (e) return e;", "moof_template = NULL;", "moof_template_size = 0;", "}", "if (ent->nb_pack>1) {", "j+= ent->nb_pack-1;", "traf_duration += ent->nb_pack*duration;", "continue;", "}", "traf_duration += duration;", "e = stbl_AppendCTSOffset(trak->Media->information->sampleTable, cts_offset);", "if (e) return e;", "sync = GF_ISOM_GET_FRAG_SYNC(flags);", "if (trak->Media->information->sampleTable->no_sync_found && sync) {", "trak->Media->information->sampleTable->no_sync_found = 0;", "}", "e = stbl_AppendRAP(trak->Media->information->sampleTable, sync);", "if (e) return e;", "pad = GF_ISOM_GET_FRAG_PAD(flags);", "if (pad) {", "e = stbl_AppendPadding(trak->Media->information->sampleTable, pad);", "if (e) return e;", "}", "degr = GF_ISOM_GET_FRAG_DEG(flags);", "if (degr) {", "e = stbl_AppendDegradation(trak->Media->information->sampleTable, degr);", "if (e) return e;", "}", "e = stbl_AppendDependencyType(trak->Media->information->sampleTable, GF_ISOM_GET_FRAG_LEAD(flags), GF_ISOM_GET_FRAG_DEPENDS(flags), GF_ISOM_GET_FRAG_DEPENDED(flags), GF_ISOM_GET_FRAG_REDUNDANT(flags));", "if (e) return e;", "}", "}", "if (trak->moov->mov->is_smooth && !traf->tfdt && !traf->tfxd) {", "if (is_first_merge)", "trak->dts_at_seg_start = trak->dts_at_next_seg_start;", "trak->dts_at_next_seg_start += last_dts;", "}", "if (traf_duration && trak->editBox && trak->editBox->editList) {", "for (i=0; i<gf_list_count(trak->editBox->editList->entryList); i++) {", "GF_EdtsEntry *edts_e = gf_list_get(trak->editBox->editList->entryList, i);", "if (edts_e->was_empty_dur) {", "u64 extend_dur = traf_duration;", "extend_dur *= trak->moov->mvhd->timeScale;", "extend_dur /= trak->Media->mediaHeader->timeScale;", "edts_e->segmentDuration += extend_dur;", "}", "else if (!edts_e->segmentDuration) {", "edts_e->was_empty_dur = GF_TRUE;", "if ((s64) traf_duration > edts_e->mediaTime)", "traf_duration -= edts_e->mediaTime;", "else", "traf_duration = 0;", "edts_e->segmentDuration = traf_duration;", "edts_e->segmentDuration *= trak->moov->mvhd->timeScale;", "edts_e->segmentDuration /= trak->Media->mediaHeader->timeScale;", "}", "}", "}", "*cumulated_offset = data_offset + chunk_size;", "if (traf->sampleGroups) {", "GF_List *groups;", "GF_List *groupDescs;", "Bool is_identical_sgpd = GF_TRUE;", "u32 *new_idx = NULL, new_idx_count=0;", "if (!trak->Media->information->sampleTable->sampleGroups)", "trak->Media->information->sampleTable->sampleGroups = gf_list_new();", "if (!trak->Media->information->sampleTable->sampleGroupsDescription)", "trak->Media->information->sampleTable->sampleGroupsDescription = gf_list_new();", "groupDescs = trak->Media->information->sampleTable->sampleGroupsDescription;", "for (i=0; i<gf_list_count(traf->sampleGroupsDescription); i++) {", "GF_SampleGroupDescriptionBox *new_sgdesc = NULL;", "GF_SampleGroupDescriptionBox *sgdesc = gf_list_get(traf->sampleGroupsDescription, i);", "for (j=0; j<gf_list_count(groupDescs); j++) {", "new_sgdesc = gf_list_get(groupDescs, j);", "if (new_sgdesc->grouping_type==sgdesc->grouping_type) break;", "new_sgdesc = NULL;", "}", "if (!new_sgdesc) {", "gf_list_add(groupDescs, sgdesc);", "gf_list_add(trak->Media->information->sampleTable->child_boxes, sgdesc);", "gf_list_rem(traf->sampleGroupsDescription, i);", "gf_list_del_item(traf->child_boxes, sgdesc);", "i--;", "}", "else {", "u32 count;", "is_identical_sgpd = gf_isom_is_identical_sgpd(new_sgdesc, sgdesc, 0);", "if (is_identical_sgpd)", "continue;", "new_idx_count = gf_list_count(sgdesc->group_descriptions);", "new_idx = (u32 *)gf_malloc(new_idx_count * sizeof(u32));", "if (!new_idx) return GF_OUT_OF_MEM;", "count = 0;", "while (gf_list_count(sgdesc->group_descriptions)) {", "void *sgpd_entry = gf_list_get(sgdesc->group_descriptions, 0);", "Bool new_entry = GF_TRUE;", "for (j = 0; j < gf_list_count(new_sgdesc->group_descriptions); j++) {", "void *ptr = gf_list_get(new_sgdesc->group_descriptions, j);", "if (gf_isom_is_identical_sgpd(sgpd_entry, ptr, new_sgdesc->grouping_type)) {", "new_idx[count] = j + 1;", "count ++;", "new_entry = GF_FALSE;", "gf_free(sgpd_entry);", "break;", "}", "}", "if (new_entry) {", "gf_list_add(new_sgdesc->group_descriptions, sgpd_entry);", "new_idx[count] = gf_list_count(new_sgdesc->group_descriptions);", "count ++;", "}", "gf_list_rem(sgdesc->group_descriptions, 0);", "}", "}", "}", "groups = trak->Media->information->sampleTable->sampleGroups;", "for (i=0; i<gf_list_count(traf->sampleGroups); i++) {", "GF_SampleGroupBox *stbl_group = NULL;", "GF_SampleGroupBox *frag_group = gf_list_get(traf->sampleGroups, i);", "for (j=0; j<gf_list_count(groups); j++) {", "stbl_group = gf_list_get(groups, j);", "if ((frag_group->grouping_type==stbl_group->grouping_type) && (frag_group->grouping_type_parameter==stbl_group->grouping_type_parameter))", "break;", "stbl_group = NULL;", "}", "if (!stbl_group) {", "stbl_group = (GF_SampleGroupBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_SBGP);", "if (!stbl_group) return GF_OUT_OF_MEM;", "stbl_group->grouping_type = frag_group->grouping_type;", "stbl_group->grouping_type_parameter = frag_group->grouping_type_parameter;", "stbl_group->version = frag_group->version;", "gf_list_add(groups, stbl_group);", "}", "if (is_identical_sgpd) {", "for (j = 0; j < frag_group->entry_count; j++)", "frag_group->sample_entries[j].group_description_index &= 0x0FFFF;", "if (frag_group->entry_count && stbl_group->entry_count &&", "(frag_group->sample_entries[0].group_description_index==stbl_group->sample_entries[stbl_group->entry_count-1].group_description_index)", ") {", "stbl_group->sample_entries[stbl_group->entry_count - 1].sample_count += frag_group->sample_entries[0].sample_count;", "if (frag_group->entry_count>1) {", "stbl_group->sample_entries = gf_realloc(stbl_group->sample_entries, sizeof(GF_SampleGroupEntry) * (stbl_group->entry_count + frag_group->entry_count - 1));", "memcpy(&stbl_group->sample_entries[stbl_group->entry_count], &frag_group->sample_entries[1], sizeof(GF_SampleGroupEntry) * (frag_group->entry_count - 1));", "stbl_group->entry_count += frag_group->entry_count - 1;", "}", "} else {", "stbl_group->sample_entries = gf_realloc(stbl_group->sample_entries, sizeof(GF_SampleGroupEntry) * (stbl_group->entry_count + frag_group->entry_count));", "memcpy(&stbl_group->sample_entries[stbl_group->entry_count], &frag_group->sample_entries[0], sizeof(GF_SampleGroupEntry) * frag_group->entry_count);", "stbl_group->entry_count += frag_group->entry_count;", "}", "} else {", "stbl_group->sample_entries = gf_realloc(stbl_group->sample_entries, sizeof(GF_SampleGroupEntry) * (stbl_group->entry_count + frag_group->entry_count));", "for (j = 0; j < frag_group->entry_count; j++) {", "u32 sgidx = frag_group->sample_entries[j].group_description_index;", "if (sgidx > 0x10000) {", "sgidx -= 0x10001;", "if (sgidx>=new_idx_count) {", "GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isobmf] corrupted sample group index in fragment %d but only %d group descriptions in fragment\\n\", sgidx, new_idx_count));", "} else {", "frag_group->sample_entries[j].group_description_index = new_idx[sgidx];", "}", "}", "}", "memcpy(&stbl_group->sample_entries[stbl_group->entry_count], &frag_group->sample_entries[0], sizeof(GF_SampleGroupEntry) * frag_group->entry_count);", "stbl_group->entry_count += frag_group->entry_count;", "}", "}", "if (new_idx) gf_free(new_idx);", "}", "track_num = gf_isom_get_tracknum_from_id(trak->moov, trak->Header->trackID);", "if (gf_isom_is_cenc_media(trak->moov->mov, track_num, DescIndex)", "|| traf->sample_encryption) {", "GF_SampleEncryptionBox *senc = NULL;", "u32 scheme_type;", "gf_isom_get_cenc_info(trak->moov->mov, track_num, DescIndex, NULL, &scheme_type, NULL);", "if (traf->sample_encryption) {", "for (i = 0; i < gf_list_count(trak->Media->information->sampleTable->child_boxes); i++) {", "GF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->child_boxes, i);", "if (a->type != traf->sample_encryption->type) continue;", "if ((a->type ==GF_ISOM_BOX_TYPE_UUID) && (((GF_UUIDBox *)a)->internal_4cc == GF_ISOM_BOX_UUID_PSEC)) {", "senc = (GF_SampleEncryptionBox *)a;", "break;", "}", "else if (a->type ==GF_ISOM_BOX_TYPE_SENC) {", "senc = (GF_SampleEncryptionBox *)a;", "break;", "}", "}", "if (!senc && trak->sample_encryption)", "senc = trak->sample_encryption;", "if (!senc) {", "if (traf->sample_encryption->piff_type==1) {", "senc = (GF_SampleEncryptionBox *)gf_isom_create_piff_psec_box(1, 0x2, 0, 0, NULL);", "} else {", "senc = gf_isom_create_samp_enc_box(1, 0x2);", "}", "if (!trak->Media->information->sampleTable->child_boxes) trak->Media->information->sampleTable->child_boxes = gf_list_new();", "trak->sample_encryption = senc;", "if (!trak->child_boxes) trak->child_boxes = gf_list_new();", "gf_list_add(trak->child_boxes, senc);", "}", "}", "if (gf_isom_cenc_has_saiz_saio_traf(traf, scheme_type)) {", "u32 nb_saio;", "u32 aux_info_type;", "u64 offset;", "GF_Err e;", "Bool is_encrypted;", "GF_SampleAuxiliaryInfoOffsetBox *saio = NULL;", "GF_SampleAuxiliaryInfoSizeBox *saiz = NULL;", "offset = nb_saio = 0;", "for (i = 0; i < gf_list_count(traf->sai_offsets); i++) {", "saio = (GF_SampleAuxiliaryInfoOffsetBox *)gf_list_get(traf->sai_offsets, i);", "aux_info_type = saio->aux_info_type;", "if (!aux_info_type) aux_info_type = scheme_type;", "if ((aux_info_type == GF_ISOM_CENC_SCHEME) || (aux_info_type == GF_ISOM_CBC_SCHEME) ||", "(aux_info_type == GF_ISOM_CENS_SCHEME) || (aux_info_type == GF_ISOM_CBCS_SCHEME) ||", "(gf_list_count(traf->sai_offsets) == 1)) {", "offset = saio->offsets[0] + moof_offset;", "nb_saio = saio->entry_count;", "break;", "}", "}", "for (i = 0; i < gf_list_count(traf->sai_sizes); i++) {", "saiz = (GF_SampleAuxiliaryInfoSizeBox *)gf_list_get(traf->sai_sizes, i);", "aux_info_type = saiz->aux_info_type;", "if (!aux_info_type) aux_info_type = scheme_type;", "if ((aux_info_type == GF_ISOM_CENC_SCHEME) || (aux_info_type == GF_ISOM_CBC_SCHEME) ||", "(aux_info_type == GF_ISOM_CENS_SCHEME) || (aux_info_type == GF_ISOM_CBCS_SCHEME) ||", "(gf_list_count(traf->sai_sizes) == 1)) {", "break;", "}", "}", "if (saiz && saio && senc) {", "for (i = 0; i < saiz->sample_count; i++) {", "GF_CENCSampleAuxInfo *sai;", "const u8 *key_info=NULL;", "u32 key_info_size;", "u64 cur_position;", "if (nb_saio != 1)", "offset = saio->offsets[i] + moof_offset;", "size = saiz->default_sample_info_size ? saiz->default_sample_info_size : saiz->sample_info_size[i];", "cur_position = gf_bs_get_position(trak->moov->mov->movieFileMap->bs);", "gf_bs_seek(trak->moov->mov->movieFileMap->bs, offset);", "GF_SAFEALLOC(sai, GF_CENCSampleAuxInfo);", "if (!sai) return GF_OUT_OF_MEM;", "e = gf_isom_get_sample_cenc_info_internal(trak, traf, senc, i+1, &is_encrypted, NULL, NULL, &key_info, &key_info_size);", "if (e) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isobmf] could not get cenc info for sample %d: %s\\n\", i+1, gf_error_to_string(e) ));", "return e;", "}", "if (is_encrypted) {", "sai->cenc_data_size = size;", "sai->cenc_data = gf_malloc(sizeof(u8)*size);", "if (!sai->cenc_data) return GF_OUT_OF_MEM;", "gf_bs_read_data(trak->moov->mov->movieFileMap->bs, sai->cenc_data, sai->cenc_data_size);", "} else {", "sai->isNotProtected=1;", "}", "if (key_info) {", "if (!key_info[0]) {", "if (size > key_info[3])", "senc->flags = 0x00000002;", "}", "else {", "senc->flags = 0x00000002;", "}", "}", "gf_bs_seek(trak->moov->mov->movieFileMap->bs, cur_position);", "gf_list_add(senc->samp_aux_info, sai);", "e = gf_isom_cenc_merge_saiz_saio(senc, trak->Media->information->sampleTable, offset, size);", "if (e) return e;", "if (nb_saio == 1)", "offset += size;", "}", "}", "} else if (traf->sample_encryption) {", "senc_Parse(trak->moov->mov->movieFileMap->bs, trak, traf, traf->sample_encryption);", "trak->sample_encryption->AlgorithmID = traf->sample_encryption->AlgorithmID;", "if (!trak->sample_encryption->IV_size)", "trak->sample_encryption->IV_size = traf->sample_encryption->IV_size;", "if (!trak->sample_encryption->samp_aux_info) trak->sample_encryption->samp_aux_info = gf_list_new();", "gf_list_transfer(trak->sample_encryption->samp_aux_info, traf->sample_encryption->samp_aux_info);", "if (traf->sample_encryption->flags & 0x00000002)", "trak->sample_encryption->flags |= 0x00000002;", "}", "}", "return GF_OK;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["int imap_open_connection (IMAP_DATA* idata)", "{", "if (mutt_socket_open (idata->conn) < 0)", "return -1;", "idata->state = IMAP_CONNECTED;", "if (imap_cmd_step (idata) != IMAP_CMD_OK)", "{", "imap_close_connection (idata);", "return -1;", "}", "if (ascii_strncasecmp (\"* OK\", idata->buf, 4) == 0)", "{", "if (ascii_strncasecmp (\"* OK [CAPABILITY\", idata->buf, 16)", "&& imap_check_capabilities (idata))", "goto bail;", "#if defined(USE_SSL)", "if (!idata->conn->ssf && (option(OPTSSLFORCETLS) ||", "mutt_bit_isset (idata->capabilities, STARTTLS)))", "{", "int rc;", "if (option(OPTSSLFORCETLS))", "rc = MUTT_YES;", "else if ((rc = query_quadoption (OPT_SSLSTARTTLS,", "_(\"Secure connection with TLS?\"))) == -1)", "goto err_close_conn;", "if (rc == MUTT_YES)", "{", "if ((rc = imap_exec (idata, \"STARTTLS\", IMAP_CMD_FAIL_OK)) == -1)", "goto bail;", "if (rc != -2)", "{", "if (mutt_ssl_starttls (idata->conn))", "{", "mutt_error (_(\"Could not negotiate TLS connection\"));", "mutt_sleep (1);", "goto err_close_conn;", "}", "else", "{", "if (imap_exec (idata, \"CAPABILITY\", 0))", "goto bail;", "}", "}", "}", "}", "if (option(OPTSSLFORCETLS) && ! idata->conn->ssf)", "{", "mutt_error _(\"Encrypted connection unavailable\");", "mutt_sleep (1);", "goto err_close_conn;", "}", "#endif", "}", "else if (ascii_strncasecmp (\"* PREAUTH\", idata->buf, 9) == 0)", "{", "idata->state = IMAP_AUTHENTICATED;", "if (imap_check_capabilities (idata) != 0)", "goto bail;", "FREE (&idata->capstr);", "}", "else", "{", "imap_error (\"imap_open_connection()\", idata->buf);", "goto bail;", "}", "return 0;", "#if defined(USE_SSL)", "err_close_conn:", "imap_close_connection (idata);", "#endif", "bail:", "FREE (&idata->capstr);", "return -1;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["iasecc_process_fci(struct sc_card *card, struct sc_file *file,", "const unsigned char *buf, size_t buflen)", "{", "struct sc_context *ctx = card->ctx;", "size_t taglen;", "int rv, ii, offs;", "const unsigned char *acls = NULL, *tag = NULL;", "unsigned char mask;", "unsigned char ops_DF[7] = {", "SC_AC_OP_DELETE, 0xFF, SC_AC_OP_ACTIVATE, SC_AC_OP_DEACTIVATE, 0xFF, SC_AC_OP_CREATE, 0xFF", "};", "unsigned char ops_EF[7] = {", "SC_AC_OP_DELETE, 0xFF, SC_AC_OP_ACTIVATE, SC_AC_OP_DEACTIVATE, 0xFF, SC_AC_OP_UPDATE, SC_AC_OP_READ", "};", "LOG_FUNC_CALLED(ctx);", "tag = sc_asn1_find_tag(ctx,  buf, buflen, 0x6F, &taglen);", "sc_log(ctx, \"processing FCI: 0x6F tag %p\", tag);", "if (tag != NULL) {", "sc_log(ctx, \"  FCP length %\"SC_FORMAT_LEN_SIZE_T\"u\", taglen);", "buf = tag;", "buflen = taglen;", "}", "tag = sc_asn1_find_tag(ctx,  buf, buflen, 0x62, &taglen);", "sc_log(ctx, \"processing FCI: 0x62 tag %p\", tag);", "if (tag != NULL) {", "sc_log(ctx, \"  FCP length %\"SC_FORMAT_LEN_SIZE_T\"u\", taglen);", "buf = tag;", "buflen = taglen;", "}", "rv = iso_ops->process_fci(card, file, buf, buflen);", "LOG_TEST_RET(ctx, rv, \"ISO parse FCI failed\");", "sc_log(ctx, \"iasecc_process_fci() type %i; let's parse file ACLs\", file->type);", "tag = sc_asn1_find_tag(ctx, buf, buflen, IASECC_DOCP_TAG_ACLS, &taglen);", "if (tag)", "acls = sc_asn1_find_tag(ctx, tag, taglen, IASECC_DOCP_TAG_ACLS_CONTACT, &taglen);", "else", "acls = sc_asn1_find_tag(ctx, buf, buflen, IASECC_DOCP_TAG_ACLS_CONTACT, &taglen);", "if (!acls)   {", "sc_log(ctx,", "\"ACLs not found in data(%\"SC_FORMAT_LEN_SIZE_T\"u) %s\",", "buflen, sc_dump_hex(buf, buflen));", "LOG_TEST_RET(ctx, SC_ERROR_OBJECT_NOT_FOUND, \"ACLs tag missing\");", "}", "sc_log(ctx, \"ACLs(%\"SC_FORMAT_LEN_SIZE_T\"u) '%s'\", taglen,", "sc_dump_hex(acls, taglen));", "mask = 0x40, offs = 1;", "for (ii = 0; ii < 7; ii++, mask /= 2)  {", "unsigned char op = file->type == SC_FILE_TYPE_DF ? ops_DF[ii] : ops_EF[ii];", "if (!(mask & acls[0]))", "continue;", "sc_log(ctx, \"ACLs mask 0x%X, offs %i, op 0x%X, acls[offs] 0x%X\", mask, offs, op, acls[offs]);", "if (op == 0xFF)   {", ";", "}", "else if (acls[offs] == 0)   {", "sc_file_add_acl_entry(file, op, SC_AC_NONE, 0);", "}", "else if (acls[offs] == 0xFF)   {", "sc_file_add_acl_entry(file, op, SC_AC_NEVER, 0);", "}", "else if ((acls[offs] & IASECC_SCB_METHOD_MASK) == IASECC_SCB_METHOD_USER_AUTH)   {", "sc_file_add_acl_entry(file, op, SC_AC_SEN, acls[offs] & IASECC_SCB_METHOD_MASK_REF);", "}", "else if (acls[offs] & IASECC_SCB_METHOD_MASK)   {", "sc_file_add_acl_entry(file, op, SC_AC_SCB, acls[offs]);", "}", "else   {", "sc_log(ctx, \"Warning: non supported SCB method: %X\", acls[offs]);", "sc_file_add_acl_entry(file, op, SC_AC_NEVER, 0);", "}", "offs++;", "}", "LOG_FUNC_RETURN(ctx, 0);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static s32 gf_avc_read_sps_bs_internal(GF_BitStream *bs, AVCState *avc, u32 subseq_sps, u32 *vui_flag_pos, u32 nal_hdr)", "{", "AVC_SPS *sps;", "s32 mb_width, mb_height, sps_id = -1;", "u32 profile_idc, level_idc, pcomp, i, chroma_format_idc, cl = 0, cr = 0, ct = 0, cb = 0, luma_bd, chroma_bd;", "u8 separate_colour_plane_flag = 0;", "if (!vui_flag_pos) {", "gf_bs_enable_emulation_byte_removal(bs, GF_TRUE);", "}", "if (!bs) {", "return -1;", "}", "if (!nal_hdr) {", "gf_bs_read_int_log(bs, 1, \"forbidden_zero_bit\");", "gf_bs_read_int_log(bs, 2, \"nal_ref_idc\");", "gf_bs_read_int_log(bs, 5, \"nal_unit_type\");", "}", "profile_idc = gf_bs_read_int_log(bs, 8, \"profile_idc\");", "pcomp = gf_bs_read_int_log(bs, 8, \"profile_compatibility\");", "if (pcomp & 0x3)", "return -1;", "level_idc = gf_bs_read_int_log(bs, 8, \"level_idc\");", "sps_id = gf_bs_read_ue_log(bs, \"sps_id\") + GF_SVC_SSPS_ID_SHIFT * subseq_sps;", "if ((sps_id < 0) || (sps_id >= 32)) {", "return -1;", "}", "luma_bd = chroma_bd = 0;", "sps = &avc->sps[sps_id];", "chroma_format_idc = sps->ChromaArrayType = 1;", "sps->state |= subseq_sps ? AVC_SUBSPS_PARSED : AVC_SPS_PARSED;", "switch (profile_idc) {", "case 100:", "case 110:", "case 122:", "case 244:", "case 44:", "if (pcomp & 0xE0)", "return -1;", "case 83:", "case 86:", "case 118:", "case 128:", "chroma_format_idc = gf_bs_read_ue_log(bs, \"chroma_format_idc\");", "sps->ChromaArrayType = chroma_format_idc;", "if (chroma_format_idc == 3) {", "separate_colour_plane_flag = gf_bs_read_int_log(bs, 1, \"separate_colour_plane_flag\");", "if (separate_colour_plane_flag) sps->ChromaArrayType = 0;", "}", "luma_bd = gf_bs_read_ue_log(bs, \"luma_bit_depth\");", "chroma_bd = gf_bs_read_ue_log(bs, \"chroma_bit_depth\");", "gf_bs_read_int_log(bs, 1, \"qpprime_y_zero_transform_bypass_flag\");", "if (gf_bs_read_int_log(bs, 1, \"seq_scaling_matrix_present_flag\")) {", "u32 k;", "for (k = 0; k < 8; k++) {", "if (gf_bs_read_int_log_idx(bs, 1, \"seq_scaling_list_present_flag\", k)) {", "u32 z, last = 8, next = 8;", "u32 sl = k < 6 ? 16 : 64;", "for (z = 0; z < sl; z++) {", "if (next) {", "s32 delta = gf_bs_read_se(bs);", "next = (last + delta + 256) % 256;", "}", "last = next ? next : last;", "}", "}", "}", "}", "break;", "}", "sps->profile_idc = profile_idc;", "sps->level_idc = level_idc;", "sps->prof_compat = pcomp;", "sps->log2_max_frame_num = gf_bs_read_ue_log(bs, \"log2_max_frame_num\") + 4;", "sps->poc_type = gf_bs_read_ue_log(bs, \"poc_type\");", "sps->chroma_format = chroma_format_idc;", "sps->luma_bit_depth_m8 = luma_bd;", "sps->chroma_bit_depth_m8 = chroma_bd;", "if (sps->poc_type == 0) {", "sps->log2_max_poc_lsb = gf_bs_read_ue_log(bs, \"log2_max_poc_lsb\") + 4;", "}", "else if (sps->poc_type == 1) {", "sps->delta_pic_order_always_zero_flag = gf_bs_read_int_log(bs, 1, \"delta_pic_order_always_zero_flag\");", "sps->offset_for_non_ref_pic = gf_bs_read_se_log(bs, \"offset_for_non_ref_pic\");", "sps->offset_for_top_to_bottom_field = gf_bs_read_se_log(bs, \"offset_for_top_to_bottom_field\");", "sps->poc_cycle_length = gf_bs_read_ue_log(bs, \"poc_cycle_length\");", "if (sps->poc_cycle_length > GF_ARRAY_LENGTH(sps->offset_for_ref_frame)) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[avc-h264] offset_for_ref_frame overflow from poc_cycle_length\\n\"));", "return -1;", "}", "for (i = 0; i < sps->poc_cycle_length; i++)", "sps->offset_for_ref_frame[i] = gf_bs_read_se_log_idx(bs, \"offset_for_ref_frame\", i);", "}", "if (sps->poc_type > 2) {", "return -1;", "}", "sps->max_num_ref_frames = gf_bs_read_ue_log(bs, \"max_num_ref_frames\");", "sps->gaps_in_frame_num_value_allowed_flag = gf_bs_read_int_log(bs, 1, \"gaps_in_frame_num_value_allowed_flag\");", "mb_width = gf_bs_read_ue_log(bs, \"pic_width_in_mbs_minus1\") + 1;", "mb_height = gf_bs_read_ue_log(bs, \"pic_height_in_map_units_minus1\") + 1;", "sps->frame_mbs_only_flag = gf_bs_read_int_log(bs, 1, \"frame_mbs_only_flag\");", "sps->width = mb_width * 16;", "sps->height = (2 - sps->frame_mbs_only_flag) * mb_height * 16;", "if (!sps->frame_mbs_only_flag) sps->mb_adaptive_frame_field_flag = gf_bs_read_int_log(bs, 1, \"mb_adaptive_frame_field_flag\");", "gf_bs_read_int_log(bs, 1, \"direct_8x8_inference_flag\");", "if (gf_bs_read_int_log(bs, 1, \"frame_cropping_flag\")) {", "int CropUnitX, CropUnitY, SubWidthC = -1, SubHeightC = -1;", "if (chroma_format_idc == 1) {", "SubWidthC = 2; SubHeightC = 2;", "}", "else if (chroma_format_idc == 2) {", "SubWidthC = 2; SubHeightC = 1;", "}", "else if ((chroma_format_idc == 3) && (separate_colour_plane_flag == 0)) {", "SubWidthC = 1; SubHeightC = 1;", "}", "if (sps->ChromaArrayType == 0) {", "assert(SubWidthC == -1);", "CropUnitX = 1;", "CropUnitY = 2 - sps->frame_mbs_only_flag;", "}", "else {", "CropUnitX = SubWidthC;", "CropUnitY = SubHeightC * (2 - sps->frame_mbs_only_flag);", "}", "cl = gf_bs_read_ue_log(bs, \"frame_crop_left_offset\");", "cr = gf_bs_read_ue_log(bs, \"frame_crop_right_offset\");", "ct = gf_bs_read_ue_log(bs, \"frame_crop_top_offset\");", "cb = gf_bs_read_ue_log(bs, \"frame_crop_bottom_offset\");", "sps->width -= CropUnitX * (cl + cr);", "sps->height -= CropUnitY * (ct + cb);", "cl *= CropUnitX;", "cr *= CropUnitX;", "ct *= CropUnitY;", "cb *= CropUnitY;", "}", "sps->crop.left = cl;", "sps->crop.right = cr;", "sps->crop.top = ct;", "sps->crop.bottom = cb;", "if (vui_flag_pos) {", "*vui_flag_pos = (u32)gf_bs_get_bit_offset(bs);", "}", "sps->vui_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_parameters_present_flag\");", "if (sps->vui_parameters_present_flag) {", "sps->vui.aspect_ratio_info_present_flag = gf_bs_read_int_log(bs, 1, \"aspect_ratio_info_present_flag\");", "if (sps->vui.aspect_ratio_info_present_flag) {", "s32 aspect_ratio_idc = gf_bs_read_int_log(bs, 8, \"aspect_ratio_idc\");", "if (aspect_ratio_idc == 255) {", "sps->vui.par_num = gf_bs_read_int_log(bs, 16, \"aspect_ratio_num\");", "sps->vui.par_den = gf_bs_read_int_log(bs, 16, \"aspect_ratio_den\");", "}", "else if (aspect_ratio_idc < GF_ARRAY_LENGTH(avc_hevc_sar) ) {", "sps->vui.par_num = avc_hevc_sar[aspect_ratio_idc].w;", "sps->vui.par_den = avc_hevc_sar[aspect_ratio_idc].h;", "}", "else {", "GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] Unknown aspect_ratio_idc: your video may have a wrong aspect ratio. Contact the GPAC team!\\n\"));", "}", "}", "sps->vui.overscan_info_present_flag = gf_bs_read_int_log(bs, 1, \"overscan_info_present_flag\");", "if (sps->vui.overscan_info_present_flag)", "gf_bs_read_int_log(bs, 1, \"overscan_appropriate_flag\");", "sps->vui.video_format = 5;", "sps->vui.colour_primaries = 2;", "sps->vui.transfer_characteristics = 2;", "sps->vui.matrix_coefficients = 2;", "sps->vui.video_signal_type_present_flag = gf_bs_read_int_log(bs, 1, \"video_signal_type_present_flag\");", "if (sps->vui.video_signal_type_present_flag) {", "sps->vui.video_format = gf_bs_read_int_log(bs, 3, \"video_format\");", "sps->vui.video_full_range_flag = gf_bs_read_int_log(bs, 1, \"video_full_range_flag\");", "sps->vui.colour_description_present_flag = gf_bs_read_int_log(bs, 1, \"colour_description_present_flag\");", "if (sps->vui.colour_description_present_flag) {", "sps->vui.colour_primaries = gf_bs_read_int_log(bs, 8, \"colour_primaries\");", "sps->vui.transfer_characteristics = gf_bs_read_int_log(bs, 8, \"transfer_characteristics\");", "sps->vui.matrix_coefficients = gf_bs_read_int_log(bs, 8, \"matrix_coefficients\");", "}", "}", "if (gf_bs_read_int_log(bs, 1, \"chroma_location_info_present_flag\")) {", "gf_bs_read_ue_log(bs, \"chroma_sample_location_type_top_field\");", "gf_bs_read_ue_log(bs, \"chroma_sample_location_type_bottom_field\");", "}", "sps->vui.timing_info_present_flag = gf_bs_read_int_log(bs, 1, \"timing_info_present_flag\");", "if (sps->vui.timing_info_present_flag) {", "sps->vui.num_units_in_tick = gf_bs_read_int_log(bs, 32, \"num_units_in_tick\");", "sps->vui.time_scale = gf_bs_read_int_log(bs, 32, \"time_scale\");", "sps->vui.fixed_frame_rate_flag = gf_bs_read_int_log(bs, 1, \"fixed_frame_rate_flag\");", "}", "sps->vui.nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"nal_hrd_parameters_present_flag\");", "if (sps->vui.nal_hrd_parameters_present_flag)", "avc_parse_hrd_parameters(bs, &sps->vui.hrd);", "sps->vui.vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vcl_hrd_parameters_present_flag\");", "if (sps->vui.vcl_hrd_parameters_present_flag)", "avc_parse_hrd_parameters(bs, &sps->vui.hrd);", "if (sps->vui.nal_hrd_parameters_present_flag || sps->vui.vcl_hrd_parameters_present_flag)", "sps->vui.low_delay_hrd_flag = gf_bs_read_int_log(bs, 1, \"low_delay_hrd_flag\");", "sps->vui.pic_struct_present_flag = gf_bs_read_int_log(bs, 1, \"pic_struct_present_flag\");", "}", "if (subseq_sps) {", "if ((profile_idc == 83) || (profile_idc == 86)) {", "u8 extended_spatial_scalability_idc;", "gf_bs_read_int_log(bs, 1, \"inter_layer_deblocking_filter_control_present_flag\");", "extended_spatial_scalability_idc = gf_bs_read_int_log(bs, 2, \"extended_spatial_scalability_idc\");", "if (sps->ChromaArrayType == 1 || sps->ChromaArrayType == 2) {", "gf_bs_read_int_log(bs, 1, \"chroma_phase_x_plus1_flag\");", "}", "if (sps->ChromaArrayType == 1) {", "gf_bs_read_int_log(bs, 2, \"chroma_phase_y_plus1\");", "}", "if (extended_spatial_scalability_idc == 1) {", "if (sps->ChromaArrayType > 0) {", "gf_bs_read_int_log(bs, 1, \"seq_ref_layer_chroma_phase_x_plus1_flag\");", "gf_bs_read_int_log(bs, 2, \"seq_ref_layer_chroma_phase_y_plus1\");", "}", "gf_bs_read_se_log(bs, \"seq_scaled_ref_layer_left_offset\");", "gf_bs_read_se_log(bs, \"seq_scaled_ref_layer_top_offset\");", "gf_bs_read_se_log(bs, \"seq_scaled_ref_layer_right_offset\");", "gf_bs_read_se_log(bs, \"seq_scaled_ref_layer_bottom_offset\");", "}", "if (gf_bs_read_int_log(bs, 1, \"seq_tcoeff_level_prediction_flag\")) {", "gf_bs_read_int_log(bs, 1, \"adaptive_tcoeff_level_prediction_flag\");", "}", "gf_bs_read_int_log(bs, 1, \"slice_header_restriction_flag\");", "if (gf_bs_read_int_log(bs, 1, \"svc_vui_parameters_present\")) {", "u32 vui_ext_num_entries_minus1 = gf_bs_read_ue_log(bs, \"vui_ext_num_entries_minus1\");", "for (i = 0; i <= vui_ext_num_entries_minus1; i++) {", "u8 vui_ext_nal_hrd_parameters_present_flag, vui_ext_vcl_hrd_parameters_present_flag, vui_ext_timing_info_present_flag;", "gf_bs_read_int_log(bs, 3, \"vui_ext_dependency_id\");", "gf_bs_read_int_log(bs, 4, \"vui_ext_quality_id\");", "gf_bs_read_int_log(bs, 3, \"vui_ext_temporal_id\");", "vui_ext_timing_info_present_flag = gf_bs_read_int_log(bs, 1, \"vui_ext_timing_info_present_flag\");", "if (vui_ext_timing_info_present_flag) {", "gf_bs_read_int_log(bs, 32, \"vui_ext_num_units_in_tick\");", "gf_bs_read_int_log(bs, 32, \"vui_ext_time_scale\");", "gf_bs_read_int_log(bs, 1, \"vui_ext_fixed_frame_rate_flag\");", "}", "vui_ext_nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_ext_nal_hrd_parameters_present_flag\");", "if (vui_ext_nal_hrd_parameters_present_flag) {", "}", "vui_ext_vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_ext_vcl_hrd_parameters_present_flag\");", "if (vui_ext_vcl_hrd_parameters_present_flag) {", "}", "if (vui_ext_nal_hrd_parameters_present_flag || vui_ext_vcl_hrd_parameters_present_flag) {", "gf_bs_read_int_log(bs, 1, \"vui_ext_low_delay_hrd_flag\");", "}", "gf_bs_read_int_log(bs, 1, \"vui_ext_pic_struct_present_flag\");", "}", "}", "}", "else if ((profile_idc == 118) || (profile_idc == 128)) {", "GF_LOG(GF_LOG_INFO, GF_LOG_CODING, (\"[avc-h264] MVC parsing not implemented - skipping parsing end of Subset SPS\\n\"));", "return sps_id;", "}", "if (gf_bs_read_int_log(bs, 1, \"additional_extension2\")) {", "GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] skipping parsing end of Subset SPS (additional_extension2)\\n\"));", "return sps_id;", "}", "}", "return sps_id;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["GF_Err stbl_AddSize(GF_SampleSizeBox *stsz, u32 sampleNumber, u32 size, u32 nb_pack_samples)", "{", "u32 i, k;", "u32 *newSizes;", "if (!stsz               || !sampleNumber) return GF_BAD_PARAM;", "if (sampleNumber > stsz->sampleCount + 1) return GF_BAD_PARAM;", "if (!nb_pack_samples) nb_pack_samples = 1;", "else if (nb_pack_samples>1)", "size /= nb_pack_samples;", "if (stsz->sizes == NULL) {", "if (! stsz->sampleCount && (stsz->type != GF_ISOM_BOX_TYPE_STZ2) ) {", "stsz->sampleCount = nb_pack_samples;", "stsz->sampleSize = size;", "return GF_OK;", "}", "if (stsz->sampleSize == size) {", "stsz->sampleCount += nb_pack_samples;", "return GF_OK;", "}", "if (nb_pack_samples>1) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Inserting packed samples with different sizes is not yet supported\\n\" ));", "return GF_NOT_SUPPORTED;", "}", "stsz->sizes = (u32*)gf_malloc(sizeof(u32) * (stsz->sampleCount + 1));", "if (!stsz->sizes) return GF_OUT_OF_MEM;", "stsz->alloc_size = stsz->sampleCount + 1;", "k = 0;", "for (i = 0 ; i < stsz->sampleCount; i++) {", "if (i + 1 == sampleNumber) {", "stsz->sizes[i + k] = size;", "k = 1;", "}", "stsz->sizes[i+k] = stsz->sampleSize;", "}", "if (stsz->sampleCount + 1 == sampleNumber) {", "stsz->sizes[stsz->sampleCount] = size;", "}", "stsz->sampleSize = 0;", "stsz->sampleCount++;", "return GF_OK;", "}", "if (stsz->sampleCount + 1 == sampleNumber) {", "if (!stsz->alloc_size) stsz->alloc_size = stsz->sampleCount;", "if (stsz->sampleCount == stsz->alloc_size) {", "ALLOC_INC(stsz->alloc_size);", "stsz->sizes = gf_realloc(stsz->sizes, sizeof(u32)*(stsz->alloc_size) );", "if (!stsz->sizes) return GF_OUT_OF_MEM;", "memset(&stsz->sizes[stsz->sampleCount], 0, sizeof(u32)*(stsz->alloc_size - stsz->sampleCount) );", "}", "stsz->sizes[stsz->sampleCount] = size;", "} else {", "newSizes = (u32*)gf_malloc(sizeof(u32)*(1 + stsz->sampleCount) );", "if (!newSizes) return GF_OUT_OF_MEM;", "k = 0;", "for (i = 0; i < stsz->sampleCount; i++) {", "if (i + 1 == sampleNumber) {", "newSizes[i + k] = size;", "k = 1;", "}", "newSizes[i + k] = stsz->sizes[i];", "}", "gf_free(stsz->sizes);", "stsz->sizes = newSizes;", "stsz->alloc_size = 1 + stsz->sampleCount;", "}", "stsz->sampleCount++;", "return GF_OK;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int start_decoder(vorb *f)", "{", "uint8 header[6], x,y;", "int len,i,j,k, max_submaps = 0;", "int longest_floorlist=0;", "if (!start_page(f))                              return FALSE;", "if (!(f->page_flag & PAGEFLAG_first_page))       return error(f, VORBIS_invalid_first_page);", "if (f->page_flag & PAGEFLAG_last_page)           return error(f, VORBIS_invalid_first_page);", "if (f->page_flag & PAGEFLAG_continued_packet)    return error(f, VORBIS_invalid_first_page);", "if (f->segment_count != 1)                       return error(f, VORBIS_invalid_first_page);", "if (f->segments[0] != 30) {", "if (f->segments[0] == 64 &&", "getn(f, header, 6) &&", "header[0] == 'f' &&", "header[1] == 'i' &&", "header[2] == 's' &&", "header[3] == 'h' &&", "header[4] == 'e' &&", "header[5] == 'a' &&", "get8(f)   == 'd' &&", "get8(f)   == '\\0')                        return error(f, VORBIS_ogg_skeleton_not_supported);", "else", "return error(f, VORBIS_invalid_first_page);", "}", "if (get8(f) != VORBIS_packet_id)                 return error(f, VORBIS_invalid_first_page);", "if (!getn(f, header, 6))                         return error(f, VORBIS_unexpected_eof);", "if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_first_page);", "if (get32(f) != 0)                               return error(f, VORBIS_invalid_first_page);", "f->channels = get8(f); if (!f->channels)         return error(f, VORBIS_invalid_first_page);", "if (f->channels > STB_VORBIS_MAX_CHANNELS)       return error(f, VORBIS_too_many_channels);", "f->sample_rate = get32(f); if (!f->sample_rate)  return error(f, VORBIS_invalid_first_page);", "get32(f);", "get32(f);", "get32(f);", "x = get8(f);", "{", "int log0,log1;", "log0 = x & 15;", "log1 = x >> 4;", "f->blocksize_0 = 1 << log0;", "f->blocksize_1 = 1 << log1;", "if (log0 < 6 || log0 > 13)                       return error(f, VORBIS_invalid_setup);", "if (log1 < 6 || log1 > 13)                       return error(f, VORBIS_invalid_setup);", "if (log0 > log1)                                 return error(f, VORBIS_invalid_setup);", "}", "x = get8(f);", "if (!(x & 1))                                    return error(f, VORBIS_invalid_first_page);", "if (!start_page(f))                              return FALSE;", "if (!start_packet(f))                            return FALSE;", "do {", "len = next_segment(f);", "skip(f, len);", "f->bytes_in_seg = 0;", "} while (len);", "if (!start_packet(f))                            return FALSE;", "#ifndef STB_VORBIS_NO_PUSHDATA_API", "if (IS_PUSH_MODE(f)) {", "if (!is_whole_packet_present(f, TRUE)) {", "if (f->error == VORBIS_invalid_stream)", "f->error = VORBIS_invalid_setup;", "return FALSE;", "}", "}", "#endif", "crc32_init();", "if (get8_packet(f) != VORBIS_packet_setup)       return error(f, VORBIS_invalid_setup);", "for (i=0; i < 6; ++i) header[i] = get8_packet(f);", "if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_setup);", "f->codebook_count = get_bits(f,8) + 1;", "f->codebooks = (Codebook *) setup_malloc(f, sizeof(*f->codebooks) * f->codebook_count);", "if (f->codebooks == NULL)                        return error(f, VORBIS_outofmem);", "memset(f->codebooks, 0, sizeof(*f->codebooks) * f->codebook_count);", "for (i=0; i < f->codebook_count; ++i) {", "uint32 *values;", "int ordered, sorted_count;", "int total=0;", "uint8 *lengths;", "Codebook *c = f->codebooks+i;", "CHECK(f);", "x = get_bits(f, 8); if (x != 0x42)            return error(f, VORBIS_invalid_setup);", "x = get_bits(f, 8); if (x != 0x43)            return error(f, VORBIS_invalid_setup);", "x = get_bits(f, 8); if (x != 0x56)            return error(f, VORBIS_invalid_setup);", "x = get_bits(f, 8);", "c->dimensions = (get_bits(f, 8)<<8) + x;", "x = get_bits(f, 8);", "y = get_bits(f, 8);", "c->entries = (get_bits(f, 8)<<16) + (y<<8) + x;", "ordered = get_bits(f,1);", "c->sparse = ordered ? 0 : get_bits(f,1);", "if (c->dimensions == 0 && c->entries != 0)    return error(f, VORBIS_invalid_setup);", "if (c->sparse)", "lengths = (uint8 *) setup_temp_malloc(f, c->entries);", "else", "lengths = c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);", "if (!lengths) return error(f, VORBIS_outofmem);", "if (ordered) {", "int current_entry = 0;", "int current_length = get_bits(f,5) + 1;", "while (current_entry < c->entries) {", "int limit = c->entries - current_entry;", "int n = get_bits(f, ilog(limit));", "if (current_entry + n > (int) c->entries) { return error(f, VORBIS_invalid_setup); }", "memset(lengths + current_entry, current_length, n);", "current_entry += n;", "++current_length;", "}", "} else {", "for (j=0; j < c->entries; ++j) {", "int present = c->sparse ? get_bits(f,1) : 1;", "if (present) {", "lengths[j] = get_bits(f, 5) + 1;", "++total;", "if (lengths[j] == 32)", "return error(f, VORBIS_invalid_setup);", "} else {", "lengths[j] = NO_CODE;", "}", "}", "}", "if (c->sparse && total >= c->entries >> 2) {", "if (c->entries > (int) f->setup_temp_memory_required)", "f->setup_temp_memory_required = c->entries;", "c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);", "if (c->codeword_lengths == NULL) return error(f, VORBIS_outofmem);", "memcpy(c->codeword_lengths, lengths, c->entries);", "setup_temp_free(f, lengths, c->entries);", "lengths = c->codeword_lengths;", "c->sparse = 0;", "}", "if (c->sparse) {", "sorted_count = total;", "} else {", "sorted_count = 0;", "#ifndef STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH", "for (j=0; j < c->entries; ++j)", "if (lengths[j] > STB_VORBIS_FAST_HUFFMAN_LENGTH && lengths[j] != NO_CODE)", "++sorted_count;", "#endif", "}", "c->sorted_entries = sorted_count;", "values = NULL;", "CHECK(f);", "if (!c->sparse) {", "c->codewords = (uint32 *) setup_malloc(f, sizeof(c->codewords[0]) * c->entries);", "if (!c->codewords)                  return error(f, VORBIS_outofmem);", "} else {", "unsigned int size;", "if (c->sorted_entries) {", "c->codeword_lengths = (uint8 *) setup_malloc(f, c->sorted_entries);", "if (!c->codeword_lengths)           return error(f, VORBIS_outofmem);", "c->codewords = (uint32 *) setup_temp_malloc(f, sizeof(*c->codewords) * c->sorted_entries);", "if (!c->codewords)                  return error(f, VORBIS_outofmem);", "values = (uint32 *) setup_temp_malloc(f, sizeof(*values) * c->sorted_entries);", "if (!values)                        return error(f, VORBIS_outofmem);", "}", "size = c->entries + (sizeof(*c->codewords) + sizeof(*values)) * c->sorted_entries;", "if (size > f->setup_temp_memory_required)", "f->setup_temp_memory_required = size;", "}", "if (!compute_codewords(c, lengths, c->entries, values)) {", "if (c->sparse) setup_temp_free(f, values, 0);", "return error(f, VORBIS_invalid_setup);", "}", "if (c->sorted_entries) {", "c->sorted_codewords = (uint32 *) setup_malloc(f, sizeof(*c->sorted_codewords) * (c->sorted_entries+1));", "if (c->sorted_codewords == NULL) return error(f, VORBIS_outofmem);", "c->sorted_values    = ( int   *) setup_malloc(f, sizeof(*c->sorted_values   ) * (c->sorted_entries+1));", "if (c->sorted_values == NULL) return error(f, VORBIS_outofmem);", "++c->sorted_values;", "c->sorted_values[-1] = -1;", "compute_sorted_huffman(c, lengths, values);", "}", "if (c->sparse) {", "setup_temp_free(f, values, sizeof(*values)*c->sorted_entries);", "setup_temp_free(f, c->codewords, sizeof(*c->codewords)*c->sorted_entries);", "setup_temp_free(f, lengths, c->entries);", "c->codewords = NULL;", "}", "compute_accelerated_huffman(c);", "CHECK(f);", "c->lookup_type = get_bits(f, 4);", "if (c->lookup_type > 2) return error(f, VORBIS_invalid_setup);", "if (c->lookup_type > 0) {", "uint16 *mults;", "c->minimum_value = float32_unpack(get_bits(f, 32));", "c->delta_value = float32_unpack(get_bits(f, 32));", "c->value_bits = get_bits(f, 4)+1;", "c->sequence_p = get_bits(f,1);", "if (c->lookup_type == 1) {", "c->lookup_values = lookup1_values(c->entries, c->dimensions);", "} else {", "c->lookup_values = c->entries * c->dimensions;", "}", "if (c->lookup_values == 0) return error(f, VORBIS_invalid_setup);", "mults = (uint16 *) setup_temp_malloc(f, sizeof(mults[0]) * c->lookup_values);", "if (mults == NULL) return error(f, VORBIS_outofmem);", "for (j=0; j < (int) c->lookup_values; ++j) {", "int q = get_bits(f, c->value_bits);", "if (q == EOP) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_invalid_setup); }", "mults[j] = q;", "}", "#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK", "if (c->lookup_type == 1) {", "int len, sparse = c->sparse;", "float last=0;", "if (sparse) {", "if (c->sorted_entries == 0) goto skip;", "c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->sorted_entries * c->dimensions);", "} else", "c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->entries        * c->dimensions);", "if (c->multiplicands == NULL) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }", "len = sparse ? c->sorted_entries : c->entries;", "for (j=0; j < len; ++j) {", "unsigned int z = sparse ? c->sorted_values[j] : j;", "unsigned int div=1;", "for (k=0; k < c->dimensions; ++k) {", "int off = (z / div) % c->lookup_values;", "float val = mults[off];", "val = mults[off]*c->delta_value + c->minimum_value + last;", "c->multiplicands[j*c->dimensions + k] = val;", "if (c->sequence_p)", "last = val;", "if (k+1 < c->dimensions) {", "if (div > UINT_MAX / (unsigned int) c->lookup_values) {", "setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values);", "return error(f, VORBIS_invalid_setup);", "}", "div *= c->lookup_values;", "}", "}", "}", "c->lookup_type = 2;", "}", "else", "#endif", "{", "float last=0;", "CHECK(f);", "c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->lookup_values);", "if (c->multiplicands == NULL) { setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }", "for (j=0; j < (int) c->lookup_values; ++j) {", "float val = mults[j] * c->delta_value + c->minimum_value + last;", "c->multiplicands[j] = val;", "if (c->sequence_p)", "last = val;", "}", "}", "#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK", "skip:;", "#endif", "setup_temp_free(f, mults, sizeof(mults[0])*c->lookup_values);", "CHECK(f);", "}", "CHECK(f);", "}", "x = get_bits(f, 6) + 1;", "for (i=0; i < x; ++i) {", "uint32 z = get_bits(f, 16);", "if (z != 0) return error(f, VORBIS_invalid_setup);", "}", "f->floor_count = get_bits(f, 6)+1;", "f->floor_config = (Floor *)  setup_malloc(f, f->floor_count * sizeof(*f->floor_config));", "if (f->floor_config == NULL) return error(f, VORBIS_outofmem);", "for (i=0; i < f->floor_count; ++i) {", "f->floor_types[i] = get_bits(f, 16);", "if (f->floor_types[i] > 1) return error(f, VORBIS_invalid_setup);", "if (f->floor_types[i] == 0) {", "Floor0 *g = &f->floor_config[i].floor0;", "g->order = get_bits(f,8);", "g->rate = get_bits(f,16);", "g->bark_map_size = get_bits(f,16);", "g->amplitude_bits = get_bits(f,6);", "g->amplitude_offset = get_bits(f,8);", "g->number_of_books = get_bits(f,4) + 1;", "for (j=0; j < g->number_of_books; ++j)", "g->book_list[j] = get_bits(f,8);", "return error(f, VORBIS_feature_not_supported);", "} else {", "stbv__floor_ordering p[31*8+2];", "Floor1 *g = &f->floor_config[i].floor1;", "int max_class = -1;", "g->partitions = get_bits(f, 5);", "for (j=0; j < g->partitions; ++j) {", "g->partition_class_list[j] = get_bits(f, 4);", "if (g->partition_class_list[j] > max_class)", "max_class = g->partition_class_list[j];", "}", "for (j=0; j <= max_class; ++j) {", "g->class_dimensions[j] = get_bits(f, 3)+1;", "g->class_subclasses[j] = get_bits(f, 2);", "if (g->class_subclasses[j]) {", "g->class_masterbooks[j] = get_bits(f, 8);", "if (g->class_masterbooks[j] >= f->codebook_count) return error(f, VORBIS_invalid_setup);", "}", "for (k=0; k < 1 << g->class_subclasses[j]; ++k) {", "g->subclass_books[j][k] = get_bits(f,8)-1;", "if (g->subclass_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);", "}", "}", "g->floor1_multiplier = get_bits(f,2)+1;", "g->rangebits = get_bits(f,4);", "g->Xlist[0] = 0;", "g->Xlist[1] = 1 << g->rangebits;", "g->values = 2;", "for (j=0; j < g->partitions; ++j) {", "int c = g->partition_class_list[j];", "for (k=0; k < g->class_dimensions[c]; ++k) {", "g->Xlist[g->values] = get_bits(f, g->rangebits);", "++g->values;", "}", "}", "for (j=0; j < g->values; ++j) {", "p[j].x = g->Xlist[j];", "p[j].id = j;", "}", "qsort(p, g->values, sizeof(p[0]), point_compare);", "for (j=0; j < g->values; ++j)", "g->sorted_order[j] = (uint8) p[j].id;", "for (j=2; j < g->values; ++j) {", "int low,hi;", "neighbors(g->Xlist, j, &low,&hi);", "g->neighbors[j][0] = low;", "g->neighbors[j][1] = hi;", "}", "if (g->values > longest_floorlist)", "longest_floorlist = g->values;", "}", "}", "f->residue_count = get_bits(f, 6)+1;", "f->residue_config = (Residue *) setup_malloc(f, f->residue_count * sizeof(f->residue_config[0]));", "if (f->residue_config == NULL) return error(f, VORBIS_outofmem);", "memset(f->residue_config, 0, f->residue_count * sizeof(f->residue_config[0]));", "for (i=0; i < f->residue_count; ++i) {", "uint8 residue_cascade[64];", "Residue *r = f->residue_config+i;", "f->residue_types[i] = get_bits(f, 16);", "if (f->residue_types[i] > 2) return error(f, VORBIS_invalid_setup);", "r->begin = get_bits(f, 24);", "r->end = get_bits(f, 24);", "if (r->end < r->begin) return error(f, VORBIS_invalid_setup);", "r->part_size = get_bits(f,24)+1;", "r->classifications = get_bits(f,6)+1;", "r->classbook = get_bits(f,8);", "if (r->classbook >= f->codebook_count) return error(f, VORBIS_invalid_setup);", "for (j=0; j < r->classifications; ++j) {", "uint8 high_bits=0;", "uint8 low_bits=get_bits(f,3);", "if (get_bits(f,1))", "high_bits = get_bits(f,5);", "residue_cascade[j] = high_bits*8 + low_bits;", "}", "r->residue_books = (short (*)[8]) setup_malloc(f, sizeof(r->residue_books[0]) * r->classifications);", "if (r->residue_books == NULL) return error(f, VORBIS_outofmem);", "for (j=0; j < r->classifications; ++j) {", "for (k=0; k < 8; ++k) {", "if (residue_cascade[j] & (1 << k)) {", "r->residue_books[j][k] = get_bits(f, 8);", "if (r->residue_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);", "} else {", "r->residue_books[j][k] = -1;", "}", "}", "}", "r->classdata = (uint8 **) setup_malloc(f, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);", "if (!r->classdata) return error(f, VORBIS_outofmem);", "memset(r->classdata, 0, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);", "for (j=0; j < f->codebooks[r->classbook].entries; ++j) {", "int classwords = f->codebooks[r->classbook].dimensions;", "int temp = j;", "r->classdata[j] = (uint8 *) setup_malloc(f, sizeof(r->classdata[j][0]) * classwords);", "if (r->classdata[j] == NULL) return error(f, VORBIS_outofmem);", "for (k=classwords-1; k >= 0; --k) {", "r->classdata[j][k] = temp % r->classifications;", "temp /= r->classifications;", "}", "}", "}", "f->mapping_count = get_bits(f,6)+1;", "f->mapping = (Mapping *) setup_malloc(f, f->mapping_count * sizeof(*f->mapping));", "if (f->mapping == NULL) return error(f, VORBIS_outofmem);", "memset(f->mapping, 0, f->mapping_count * sizeof(*f->mapping));", "for (i=0; i < f->mapping_count; ++i) {", "Mapping *m = f->mapping + i;", "int mapping_type = get_bits(f,16);", "if (mapping_type != 0) return error(f, VORBIS_invalid_setup);", "m->chan = (MappingChannel *) setup_malloc(f, f->channels * sizeof(*m->chan));", "if (m->chan == NULL) return error(f, VORBIS_outofmem);", "if (get_bits(f,1))", "m->submaps = get_bits(f,4)+1;", "else", "m->submaps = 1;", "if (m->submaps > max_submaps)", "max_submaps = m->submaps;", "if (get_bits(f,1)) {", "m->coupling_steps = get_bits(f,8)+1;", "for (k=0; k < m->coupling_steps; ++k) {", "m->chan[k].magnitude = get_bits(f, ilog(f->channels-1));", "m->chan[k].angle = get_bits(f, ilog(f->channels-1));", "if (m->chan[k].magnitude >= f->channels)        return error(f, VORBIS_invalid_setup);", "if (m->chan[k].angle     >= f->channels)        return error(f, VORBIS_invalid_setup);", "if (m->chan[k].magnitude == m->chan[k].angle)   return error(f, VORBIS_invalid_setup);", "}", "} else", "m->coupling_steps = 0;", "if (get_bits(f,2)) return error(f, VORBIS_invalid_setup);", "if (m->submaps > 1) {", "for (j=0; j < f->channels; ++j) {", "m->chan[j].mux = get_bits(f, 4);", "if (m->chan[j].mux >= m->submaps)                return error(f, VORBIS_invalid_setup);", "}", "} else", "for (j=0; j < f->channels; ++j)", "m->chan[j].mux = 0;", "for (j=0; j < m->submaps; ++j) {", "get_bits(f,8);", "m->submap_floor[j] = get_bits(f,8);", "m->submap_residue[j] = get_bits(f,8);", "if (m->submap_floor[j] >= f->floor_count)      return error(f, VORBIS_invalid_setup);", "if (m->submap_residue[j] >= f->residue_count)  return error(f, VORBIS_invalid_setup);", "}", "}", "f->mode_count = get_bits(f, 6)+1;", "for (i=0; i < f->mode_count; ++i) {", "Mode *m = f->mode_config+i;", "m->blockflag = get_bits(f,1);", "m->windowtype = get_bits(f,16);", "m->transformtype = get_bits(f,16);", "m->mapping = get_bits(f,8);", "if (m->windowtype != 0)                 return error(f, VORBIS_invalid_setup);", "if (m->transformtype != 0)              return error(f, VORBIS_invalid_setup);", "if (m->mapping >= f->mapping_count)     return error(f, VORBIS_invalid_setup);", "}", "flush_packet(f);", "f->previous_length = 0;", "for (i=0; i < f->channels; ++i) {", "f->channel_buffers[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1);", "f->previous_window[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2);", "f->finalY[i]          = (int16 *) setup_malloc(f, sizeof(int16) * longest_floorlist);", "if (f->channel_buffers[i] == NULL || f->previous_window[i] == NULL || f->finalY[i] == NULL) return error(f, VORBIS_outofmem);", "memset(f->channel_buffers[i], 0, sizeof(float) * f->blocksize_1);", "#ifdef STB_VORBIS_NO_DEFER_FLOOR", "f->floor_buffers[i]   = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2);", "if (f->floor_buffers[i] == NULL) return error(f, VORBIS_outofmem);", "#endif", "}", "if (!init_blocksize(f, 0, f->blocksize_0)) return FALSE;", "if (!init_blocksize(f, 1, f->blocksize_1)) return FALSE;", "f->blocksize[0] = f->blocksize_0;", "f->blocksize[1] = f->blocksize_1;", "#ifdef STB_VORBIS_DIVIDE_TABLE", "if (integer_divide_table[1][1]==0)", "for (i=0; i < DIVTAB_NUMER; ++i)", "for (j=1; j < DIVTAB_DENOM; ++j)", "integer_divide_table[i][j] = i / j;", "#endif", "{", "uint32 imdct_mem = (f->blocksize_1 * sizeof(float) >> 1);", "uint32 classify_mem;", "int i,max_part_read=0;", "for (i=0; i < f->residue_count; ++i) {", "Residue *r = f->residue_config + i;", "unsigned int actual_size = f->blocksize_1 / 2;", "unsigned int limit_r_begin = r->begin < actual_size ? r->begin : actual_size;", "unsigned int limit_r_end   = r->end   < actual_size ? r->end   : actual_size;", "int n_read = limit_r_end - limit_r_begin;", "int part_read = n_read / r->part_size;", "if (part_read > max_part_read)", "max_part_read = part_read;", "}", "#ifndef STB_VORBIS_DIVIDES_IN_RESIDUE", "classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(uint8 *));", "#else", "classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(int *));", "#endif", "f->temp_memory_required = classify_mem;", "if (imdct_mem > f->temp_memory_required)", "f->temp_memory_required = imdct_mem;", "}", "f->first_decode = TRUE;", "if (f->alloc.alloc_buffer) {", "assert(f->temp_offset == f->alloc.alloc_buffer_length_in_bytes);", "if (f->setup_offset + sizeof(*f) + f->temp_memory_required > (unsigned) f->temp_offset)", "return error(f, VORBIS_outofmem);", "}", "f->first_audio_page_offset = stb_vorbis_get_file_offset(f);", "return TRUE;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["GF_Descriptor *gf_isom_get_root_od(GF_ISOFile *movie)", "{", "GF_Descriptor *desc;", "GF_ObjectDescriptor *od;", "GF_InitialObjectDescriptor *iod;", "GF_IsomObjectDescriptor *isom_od;", "GF_IsomInitialObjectDescriptor *isom_iod;", "GF_ESD *esd;", "GF_ES_ID_Inc *inc;", "u32 i;", "u8 useIOD;", "if (!movie || !movie->moov) return NULL;", "if (!movie->moov->iods) return NULL;", "if (movie->disable_odf_translate) {", "movie->LastError = gf_odf_desc_copy((GF_Descriptor *) movie->moov->iods->descriptor, &desc);", "if (movie->LastError) return NULL;", "return desc;", "}", "od = NULL;", "iod = NULL;", "switch (movie->moov->iods->descriptor->tag) {", "case GF_ODF_ISOM_OD_TAG:", "od = (GF_ObjectDescriptor*)gf_malloc(sizeof(GF_ObjectDescriptor));", "if (!od) return NULL;", "memset(od, 0, sizeof(GF_ObjectDescriptor));", "od->ESDescriptors = gf_list_new();", "useIOD = 0;", "break;", "case GF_ODF_ISOM_IOD_TAG:", "iod = (GF_InitialObjectDescriptor*)gf_malloc(sizeof(GF_InitialObjectDescriptor));", "if (!iod) return NULL;", "memset(iod, 0, sizeof(GF_InitialObjectDescriptor));", "iod->ESDescriptors = gf_list_new();", "useIOD = 1;", "break;", "default:", "return NULL;", "}", "movie->LastError = gf_odf_desc_copy((GF_Descriptor *) movie->moov->iods->descriptor, &desc);", "if (movie->LastError) return NULL;", "if (!useIOD) {", "isom_od = (GF_IsomObjectDescriptor *)desc;", "od->objectDescriptorID = isom_od->objectDescriptorID;", "od->extensionDescriptors = isom_od->extensionDescriptors;", "isom_od->extensionDescriptors = NULL;", "od->IPMP_Descriptors = isom_od->IPMP_Descriptors;", "isom_od->IPMP_Descriptors = NULL;", "od->OCIDescriptors = isom_od->OCIDescriptors;", "isom_od->OCIDescriptors = NULL;", "od->URLString = isom_od->URLString;", "isom_od->URLString = NULL;", "od->tag = GF_ODF_OD_TAG;", "i=0;", "while ((inc = (GF_ES_ID_Inc*)gf_list_enum(isom_od->ES_ID_IncDescriptors, &i))) {", "movie->LastError = GetESDForTime(movie->moov, inc->trackID, 0, &esd);", "if (!movie->LastError) movie->LastError = gf_list_add(od->ESDescriptors, esd);", "if (movie->LastError) {", "gf_odf_desc_del(desc);", "gf_odf_desc_del((GF_Descriptor *) od);", "return NULL;", "}", "}", "gf_odf_desc_del(desc);", "return (GF_Descriptor *)od;", "} else {", "isom_iod = (GF_IsomInitialObjectDescriptor *)desc;", "iod->objectDescriptorID = isom_iod->objectDescriptorID;", "iod->extensionDescriptors = isom_iod->extensionDescriptors;", "isom_iod->extensionDescriptors = NULL;", "iod->IPMP_Descriptors = isom_iod->IPMP_Descriptors;", "isom_iod->IPMP_Descriptors = NULL;", "iod->OCIDescriptors = isom_iod->OCIDescriptors;", "isom_iod->OCIDescriptors = NULL;", "iod->URLString = isom_iod->URLString;", "isom_iod->URLString = NULL;", "iod->tag = GF_ODF_IOD_TAG;", "iod->audio_profileAndLevel = isom_iod->audio_profileAndLevel;", "iod->graphics_profileAndLevel = isom_iod->graphics_profileAndLevel;", "iod->inlineProfileFlag = isom_iod->inlineProfileFlag;", "iod->OD_profileAndLevel = isom_iod->OD_profileAndLevel;", "iod->scene_profileAndLevel = isom_iod->scene_profileAndLevel;", "iod->visual_profileAndLevel = isom_iod->visual_profileAndLevel;", "iod->IPMPToolList = isom_iod->IPMPToolList;", "isom_iod->IPMPToolList = NULL;", "i=0;", "while ((inc = (GF_ES_ID_Inc*)gf_list_enum(isom_iod->ES_ID_IncDescriptors, &i))) {", "movie->LastError = GetESDForTime(movie->moov, inc->trackID, 0, &esd);", "if (!movie->LastError) movie->LastError = gf_list_add(iod->ESDescriptors, esd);", "if (movie->LastError) {", "gf_odf_desc_del(desc);", "gf_odf_desc_del((GF_Descriptor *) iod);", "return NULL;", "}", "}", "gf_odf_desc_del(desc);", "return (GF_Descriptor *)iod;", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["PackLinuxElf32::elf_find_dynamic(unsigned int key) const", "{", "Elf32_Dyn const *dynp= dynseg;", "if (dynp)", "for (; (unsigned)((char const *)dynp - (char const *)dynseg) < sz_dynseg", "&& Elf32_Dyn::DT_NULL!=dynp->d_tag; ++dynp) if (get_te32(&dynp->d_tag)==key) {", "unsigned const t= elf_get_offset_from_address(get_te32(&dynp->d_val));", "if (t) {", "return t + file_image;", "}", "break;", "}", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static Fixed lsr_translate_coords(GF_LASeRCodec *lsr, u32 val, u32 nb_bits)", "{", "#ifdef GPAC_FIXED_POINT", "if (val >> (nb_bits-1) ) {", "s32 neg = (s32) val - (1<<nb_bits);", "if (neg < -FIX_ONE / 2)", "return 2 * gf_divfix(INT2FIX(neg/2), lsr->res_factor);", "return gf_divfix(INT2FIX(neg), lsr->res_factor);", "} else {", "if (val > FIX_ONE / 2)", "return 2 * gf_divfix(INT2FIX(val/2), lsr->res_factor);", "return gf_divfix(INT2FIX(val), lsr->res_factor);", "}", "#else", "if (val >> (nb_bits-1) ) {", "s32 neg = (s32) val - (1<<nb_bits);", "return gf_divfix(INT2FIX(neg), lsr->res_factor);", "} else {", "return gf_divfix(INT2FIX(val), lsr->res_factor);", "}", "#endif", "}"], "ner_tags": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["GF_Err trak_box_size(GF_Box *s)", "{", "u32 pos=0;", "GF_TrackBox *ptr = (GF_TrackBox *)s;", "if (ptr->sample_encryption && ptr->sample_encryption->load_needed) {", "GF_Err e = senc_Parse(ptr->moov->mov->movieFileMap->bs, ptr, NULL, ptr->sample_encryption);", "if (e) return e;", "}", "gf_isom_check_position(s, (GF_Box *)ptr->Header, &pos);", "gf_isom_check_position(s, (GF_Box *)ptr->Aperture, &pos);", "gf_isom_check_position(s, (GF_Box *)ptr->References, &pos);", "gf_isom_check_position(s, (GF_Box *)ptr->editBox, &pos);", "gf_isom_check_position(s, (GF_Box *)ptr->Media, &pos);", "gf_isom_check_position(s, (GF_Box *)ptr->meta, &pos);", "gf_isom_check_position(s, (GF_Box *)ptr->groups, &pos);", "gf_isom_check_position(s, (GF_Box *)ptr->udta, &pos);", "return GF_OK;", "}"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static s32 avc_parse_slice(GF_BitStream *bs, AVCState *avc, Bool svc_idr_flag, AVCSliceInfo *si)", "{", "s32 pps_id, num_ref_idx_l0_active_minus1 = 0, num_ref_idx_l1_active_minus1 = 0;", "gf_bs_read_ue_log(bs, \"first_mb_in_slice\");", "si->slice_type = gf_bs_read_ue_log(bs, \"slice_type\");", "if (si->slice_type > 9) return -1;", "pps_id = gf_bs_read_ue_log(bs, \"pps_id\");", "if (pps_id > 255) return -1;", "si->pps = &avc->pps[pps_id];", "if (!si->pps->slice_group_count) return -2;", "si->sps = &avc->sps[si->pps->sps_id];", "if (!si->sps->log2_max_frame_num) return -2;", "avc->sps_active_idx = si->pps->sps_id;", "avc->pps_active_idx = pps_id;", "si->frame_num = gf_bs_read_int_log(bs, si->sps->log2_max_frame_num, \"frame_num\");", "si->field_pic_flag = 0;", "si->bottom_field_flag = 0;", "if (!si->sps->frame_mbs_only_flag) {", "si->field_pic_flag = gf_bs_read_int_log(bs, 1, \"field_pic_flag\");", "if (si->field_pic_flag)", "si->bottom_field_flag = gf_bs_read_int_log(bs, 1, \"bottom_field_flag\");", "}", "if ((si->nal_unit_type == GF_AVC_NALU_IDR_SLICE) || svc_idr_flag)", "si->idr_pic_id = gf_bs_read_ue_log(bs, \"idr_pic_id\");", "if (si->sps->poc_type == 0) {", "si->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, \"poc_lsb\");", "if (si->pps->pic_order_present && !si->field_pic_flag) {", "si->delta_poc_bottom = gf_bs_read_se_log(bs, \"poc_lsb\");", "}", "}", "else if ((si->sps->poc_type == 1) && !si->sps->delta_pic_order_always_zero_flag) {", "si->delta_poc[0] = gf_bs_read_se_log(bs, \"delta_poc0\");", "if ((si->pps->pic_order_present == 1) && !si->field_pic_flag)", "si->delta_poc[1] = gf_bs_read_se_log(bs, \"delta_poc1\");", "}", "if (si->pps->redundant_pic_cnt_present) {", "si->redundant_pic_cnt = gf_bs_read_ue_log(bs, \"redundant_pic_cnt\");", "}", "if (si->slice_type % 5 == GF_AVC_TYPE_B) {", "gf_bs_read_int_log(bs, 1, \"direct_spatial_mv_pred_flag\");", "}", "num_ref_idx_l0_active_minus1 = si->pps->num_ref_idx_l0_default_active_minus1;", "num_ref_idx_l1_active_minus1 = si->pps->num_ref_idx_l1_default_active_minus1;", "if (si->slice_type % 5 == GF_AVC_TYPE_P || si->slice_type % 5 == GF_AVC_TYPE_SP || si->slice_type % 5 == GF_AVC_TYPE_B) {", "Bool num_ref_idx_active_override_flag = gf_bs_read_int_log(bs, 1, \"num_ref_idx_active_override_flag\");", "if (num_ref_idx_active_override_flag) {", "num_ref_idx_l0_active_minus1 = gf_bs_read_ue_log(bs, \"num_ref_idx_l0_active_minus1\");", "if (si->slice_type % 5 == GF_AVC_TYPE_B) {", "num_ref_idx_l1_active_minus1 = gf_bs_read_ue_log(bs, \"num_ref_idx_l1_active_minus1\");", "}", "}", "}", "if (si->nal_unit_type == 20 || si->nal_unit_type == 21) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[avc-h264] unimplemented ref_pic_list_mvc_modification() in slide header\\n\"));", "assert(0);", "return -1;", "}", "else {", "ref_pic_list_modification(bs, si->slice_type);", "}", "if ((si->pps->weighted_pred_flag && (si->slice_type % 5 == GF_AVC_TYPE_P || si->slice_type % 5 == GF_AVC_TYPE_SP))", "|| (si->pps->weighted_bipred_idc == 1 && si->slice_type % 5 == GF_AVC_TYPE_B)) {", "pred_weight_table(bs, si->slice_type, si->sps->ChromaArrayType, num_ref_idx_l0_active_minus1, num_ref_idx_l1_active_minus1);", "}", "if (si->nal_ref_idc != 0) {", "dec_ref_pic_marking(bs, (si->nal_unit_type == GF_AVC_NALU_IDR_SLICE));", "}", "if (si->pps->entropy_coding_mode_flag && si->slice_type % 5 != GF_AVC_TYPE_I && si->slice_type % 5 != GF_AVC_TYPE_SI) {", "gf_bs_read_ue_log(bs, \"cabac_init_idc\");", "}", "gf_bs_read_se(bs);", "if (si->slice_type % 5 == GF_AVC_TYPE_SP || si->slice_type % 5 == GF_AVC_TYPE_SI) {", "if (si->slice_type % 5 == GF_AVC_TYPE_SP) {", "gf_bs_read_int_log(bs, 1, \"sp_for_switch_flag\");", "}", "gf_bs_read_se_log(bs, \"slice_qs_delta\");", "}", "if (si->pps->deblocking_filter_control_present_flag) {", "if (gf_bs_read_ue_log(bs, \"disable_deblocking_filter_idc\") != 1) {", "gf_bs_read_se_log(bs, \"slice_alpha_c0_offset_div2\");", "gf_bs_read_se_log(bs, \"slice_beta_offset_div2\");", "}", "}", "if (si->pps->slice_group_count > 1 && si->pps->mb_slice_group_map_type >= 3 && si->pps->mb_slice_group_map_type <= 5) {", "gf_bs_read_int_log(bs, (u32)ceil(log1p((si->pps->pic_size_in_map_units_minus1 + 1) / (si->pps->slice_group_change_rate_minus1 + 1) ) / log(2)), \"slice_group_change_cycle\");", "}", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["exif_data_load_data_entry (ExifData *data, ExifEntry *entry,", "const unsigned char *d,", "unsigned int size, unsigned int offset)", "{", "unsigned int s, doff;", "entry->tag        = exif_get_short (d + offset + 0, data->priv->order);", "entry->format     = exif_get_short (d + offset + 2, data->priv->order);", "entry->components = exif_get_long  (d + offset + 4, data->priv->order);", "exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",", "\"Loading entry 0x%x ('%s')...\", entry->tag,", "exif_tag_get_name (entry->tag));", "s = exif_format_get_size(entry->format) * entry->components;", "if ((s < entry->components) || (s == 0)){", "return 0;", "}", "if (s > 4)", "doff = exif_get_long (d + offset + 8, data->priv->order);", "else", "doff = offset + 8;", "if ((doff + s < doff) || (doff + s < s) || (doff + s > size)) {", "exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",", "\"Tag data past end of buffer (%u > %u)\", doff+s, size);", "return 0;", "}", "entry->data = exif_data_alloc (data, s);", "if (entry->data) {", "entry->size = s;", "memcpy (entry->data, d + doff, s);", "} else {", "EXIF_LOG_NO_MEMORY(data->priv->log, \"ExifData\", s);", "return 0;", "}", "if (entry->tag == EXIF_TAG_MAKER_NOTE) {", "if (!entry->data) {", "exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",", "\"MakerNote found with empty data\");", "} else if (entry->size > 6) {", "exif_log (data->priv->log,", "EXIF_LOG_CODE_DEBUG, \"ExifData\",", "\"MakerNote found (%02x %02x %02x %02x \"", "\"%02x %02x %02x...).\",", "entry->data[0], entry->data[1], entry->data[2],", "entry->data[3], entry->data[4], entry->data[5],", "entry->data[6]);", "}", "data->priv->offset_mnote = doff;", "}", "return 1;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["char *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicode_type)", "{", "u32 i, j, len;", "char *sOK;", "char szLineConv[1024];", "unsigned short *sptr;", "memset(szLine, 0, sizeof(char)*lineSize);", "sOK = gf_fgets(szLine, lineSize, txt_in);", "if (!sOK) return NULL;", "if (unicode_type<=1) {", "j=0;", "len = (u32) strlen(szLine);", "for (i=0; i<len; i++) {", "if (!unicode_type && (szLine[i] & 0x80)) {", "if ((szLine[i+1] & 0xc0) != 0x80) {", "szLineConv[j] = 0xc0 | ( (szLine[i] >> 6) & 0x3 );", "j++;", "szLine[i] &= 0xbf;", "}", "else if ( (szLine[i] & 0xe0) == 0xc0) {", "szLineConv[j] = szLine[i];", "i++;", "j++;", "}", "else if ( (szLine[i] & 0xf0) == 0xe0) {", "szLineConv[j] = szLine[i];", "i++;", "j++;", "szLineConv[j] = szLine[i];", "i++;", "j++;", "}", "else if ( (szLine[i] & 0xf8) == 0xf0) {", "szLineConv[j] = szLine[i];", "i++;", "j++;", "szLineConv[j] = szLine[i];", "i++;", "j++;", "szLineConv[j] = szLine[i];", "i++;", "j++;", "} else {", "i+=1;", "continue;", "}", "}", "szLineConv[j] = szLine[i];", "j++;", "}", "szLineConv[j] = 0;", "strcpy(szLine, szLineConv);", "return sOK;", "}", "#ifdef GPAC_BIG_ENDIAN", "if (unicode_type==3)", "#else", "if (unicode_type==2)", "#endif", "{", "i=0;", "while (1) {", "char c;", "if (!szLine[i] && !szLine[i+1]) break;", "c = szLine[i+1];", "szLine[i+1] = szLine[i];", "szLine[i] = c;", "i+=2;", "}", "}", "sptr = (u16 *)szLine;", "i = (u32) gf_utf8_wcstombs(szLineConv, 1024, (const unsigned short **) &sptr);", "szLineConv[i] = 0;", "strcpy(szLine, szLineConv);", "if (unicode_type==3) gf_fgetc(txt_in);", "return sOK;", "}"], "ner_tags": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["GF_Err afra_box_read(GF_Box *s, GF_BitStream *bs)", "{", "unsigned int i;", "GF_AdobeFragRandomAccessBox *ptr = (GF_AdobeFragRandomAccessBox *)s;", "ISOM_DECREASE_SIZE(ptr, 9)", "ptr->long_ids = gf_bs_read_int(bs, 1);", "ptr->long_offsets = gf_bs_read_int(bs, 1);", "ptr->global_entries = gf_bs_read_int(bs, 1);", "ptr->reserved = gf_bs_read_int(bs, 5);", "ptr->time_scale = gf_bs_read_u32(bs);", "ptr->entry_count = gf_bs_read_u32(bs);", "if (ptr->size / ( (ptr->long_offsets ? 16 : 12) ) < ptr->entry_count)", "return GF_ISOM_INVALID_FILE;", "for (i=0; i<ptr->entry_count; i++) {", "GF_AfraEntry *ae = gf_malloc(sizeof(GF_AfraEntry));", "if (!ae) return GF_OUT_OF_MEM;", "ISOM_DECREASE_SIZE(ptr, 8)", "ae->time = gf_bs_read_u64(bs);", "if (ptr->long_offsets) {", "ISOM_DECREASE_SIZE(ptr, 8)", "ae->offset = gf_bs_read_u64(bs);", "} else {", "ISOM_DECREASE_SIZE(ptr, 4)", "ae->offset = gf_bs_read_u32(bs);", "}", "gf_list_insert(ptr->local_access_entries, ae, i);", "}", "if (ptr->global_entries) {", "ISOM_DECREASE_SIZE(ptr, 4)", "ptr->global_entry_count = gf_bs_read_u32(bs);", "for (i=0; i<ptr->global_entry_count; i++) {", "GF_GlobalAfraEntry *ae = gf_malloc(sizeof(GF_GlobalAfraEntry));", "if (!ae) return GF_OUT_OF_MEM;", "ISOM_DECREASE_SIZE(ptr, 8)", "ae->time = gf_bs_read_u64(bs);", "if (ptr->long_ids) {", "ISOM_DECREASE_SIZE(ptr, 8)", "ae->segment = gf_bs_read_u32(bs);", "ae->fragment = gf_bs_read_u32(bs);", "} else {", "ISOM_DECREASE_SIZE(ptr, 4)", "ae->segment = gf_bs_read_u16(bs);", "ae->fragment = gf_bs_read_u16(bs);", "}", "if (ptr->long_offsets) {", "ISOM_DECREASE_SIZE(ptr, 16)", "ae->afra_offset = gf_bs_read_u64(bs);", "ae->offset_from_afra = gf_bs_read_u64(bs);", "} else {", "ISOM_DECREASE_SIZE(ptr, 8)", "ae->afra_offset = gf_bs_read_u32(bs);", "ae->offset_from_afra = gf_bs_read_u32(bs);", "}", "gf_list_insert(ptr->global_access_entries, ae, i);", "}", "}", "return GF_OK;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["void RemoteFsDevice::load()", "{", "if (RemoteFsDevice::constSambaAvahiProtocol==details.url.scheme()) {", "Avahi::self();", "QUrlQuery q(details.url);", "if (q.hasQueryItem(constServiceNameQuery)) {", "details.serviceName=q.queryItemValue(constServiceNameQuery);", "}", "if (!details.serviceName.isEmpty()) {", "AvahiService *srv=Avahi::self()->getService(details.serviceName);", "if (!srv || srv->getHost().isEmpty()) {", "sub=tr(\"Not Available\");", "} else {", "sub=tr(\"Available\");", "}", "}", "connect(Avahi::self(), SIGNAL(serviceAdded(QString)), SLOT(serviceAdded(QString)));", "connect(Avahi::self(), SIGNAL(serviceRemoved(QString)), SLOT(serviceRemoved(QString)));", "}", "if (isConnected()) {", "setAudioFolder();", "readOpts(settingsFileName(), opts, true);", "rescan(false);", "}", "}"], "ner_tags": [0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["set_acl(struct archive *a, int fd, const char *name,", "struct archive_acl *abstract_acl,", "int ae_requested_type, const char *tname)", "{", "aclent_t  *aclent;", "#if ARCHIVE_ACL_SUNOS_NFS4", "ace_t   *ace;", "#endif", "int   cmd, e, r;", "void   *aclp;", "int   ret;", "int   ae_type, ae_permset, ae_tag, ae_id;", "int   perm_map_size;", "const acl_perm_map_t *perm_map;", "uid_t   ae_uid;", "gid_t   ae_gid;", "const char *ae_name;", "int   entries;", "int   i;", "ret = ARCHIVE_OK;", "entries = archive_acl_reset(abstract_acl, ae_requested_type);", "if (entries == 0)", "return (ARCHIVE_OK);", "switch (ae_requested_type) {", "case ARCHIVE_ENTRY_ACL_TYPE_POSIX1E:", "cmd = SETACL;", "aclp = malloc(entries * sizeof(aclent_t));", "break;", "#if ARCHIVE_ACL_SUNOS_NFS4", "case ARCHIVE_ENTRY_ACL_TYPE_NFS4:", "cmd = ACE_SETACL;", "aclp = malloc(entries * sizeof(ace_t));", "break;", "#endif", "default:", "errno = ENOENT;", "archive_set_error(a, errno, \"Unsupported ACL type\");", "return (ARCHIVE_FAILED);", "}", "if (aclp == NULL) {", "archive_set_error(a, errno,", "\"Can't allocate memory for acl buffer\");", "return (ARCHIVE_FAILED);", "}", "e = 0;", "while (archive_acl_next(a, abstract_acl, ae_requested_type, &ae_type,", "&ae_permset, &ae_tag, &ae_id, &ae_name) == ARCHIVE_OK) {", "aclent = NULL;", "#if ARCHIVE_ACL_SUNOS_NFS4", "ace = NULL;", "#endif", "if (cmd == SETACL) {", "aclent = &((aclent_t *)aclp)[e];", "aclent->a_id = -1;", "aclent->a_type = 0;", "aclent->a_perm = 0;", "}", "#if ARCHIVE_ACL_SUNOS_NFS4", "else {", "ace = &((ace_t *)aclp)[e];", "ace->a_who = -1;", "ace->a_access_mask = 0;", "ace->a_flags = 0;", "}", "#endif\t/* ARCHIVE_ACL_SUNOS_NFS4 */", "switch (ae_tag) {", "case ARCHIVE_ENTRY_ACL_USER:", "ae_uid = archive_write_disk_uid(a, ae_name, ae_id);", "if (aclent != NULL) {", "aclent->a_id = ae_uid;", "aclent->a_type |= USER;", "}", "#if ARCHIVE_ACL_SUNOS_NFS4", "else {", "ace->a_who = ae_uid;", "}", "#endif", "break;", "case ARCHIVE_ENTRY_ACL_GROUP:", "ae_gid = archive_write_disk_gid(a, ae_name, ae_id);", "if (aclent != NULL) {", "aclent->a_id = ae_gid;", "aclent->a_type |= GROUP;", "}", "#if ARCHIVE_ACL_SUNOS_NFS4", "else {", "ace->a_who = ae_gid;", "ace->a_flags |= ACE_IDENTIFIER_GROUP;", "}", "#endif", "break;", "case ARCHIVE_ENTRY_ACL_USER_OBJ:", "if (aclent != NULL)", "aclent->a_type |= USER_OBJ;", "#if ARCHIVE_ACL_SUNOS_NFS4", "else {", "ace->a_flags |= ACE_OWNER;", "}", "#endif", "break;", "case ARCHIVE_ENTRY_ACL_GROUP_OBJ:", "if (aclent != NULL)", "aclent->a_type |= GROUP_OBJ;", "#if ARCHIVE_ACL_SUNOS_NFS4", "else {", "ace->a_flags |= ACE_GROUP;", "ace->a_flags |= ACE_IDENTIFIER_GROUP;", "}", "#endif", "break;", "case ARCHIVE_ENTRY_ACL_MASK:", "if (aclent != NULL)", "aclent->a_type |= CLASS_OBJ;", "break;", "case ARCHIVE_ENTRY_ACL_OTHER:", "if (aclent != NULL)", "aclent->a_type |= OTHER_OBJ;", "break;", "#if ARCHIVE_ACL_SUNOS_NFS4", "case ARCHIVE_ENTRY_ACL_EVERYONE:", "if (ace != NULL)", "ace->a_flags |= ACE_EVERYONE;", "break;", "#endif", "default:", "archive_set_error(a, ARCHIVE_ERRNO_MISC,", "\"Unsupported ACL tag\");", "ret = ARCHIVE_FAILED;", "goto exit_free;", "}", "r = 0;", "switch (ae_type) {", "#if ARCHIVE_ACL_SUNOS_NFS4", "case ARCHIVE_ENTRY_ACL_TYPE_ALLOW:", "if (ace != NULL)", "ace->a_type = ACE_ACCESS_ALLOWED_ACE_TYPE;", "else", "r = -1;", "break;", "case ARCHIVE_ENTRY_ACL_TYPE_DENY:", "if (ace != NULL)", "ace->a_type = ACE_ACCESS_DENIED_ACE_TYPE;", "else", "r = -1;", "break;", "case ARCHIVE_ENTRY_ACL_TYPE_AUDIT:", "if (ace != NULL)", "ace->a_type = ACE_SYSTEM_AUDIT_ACE_TYPE;", "else", "r = -1;", "break;", "case ARCHIVE_ENTRY_ACL_TYPE_ALARM:", "if (ace != NULL)", "ace->a_type = ACE_SYSTEM_ALARM_ACE_TYPE;", "else", "r = -1;", "break;", "#endif", "case ARCHIVE_ENTRY_ACL_TYPE_ACCESS:", "if (aclent == NULL)", "r = -1;", "break;", "case ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:", "if (aclent != NULL)", "aclent->a_type |= ACL_DEFAULT;", "else", "r = -1;", "break;", "default:", "archive_set_error(a, ARCHIVE_ERRNO_MISC,", "\"Unsupported ACL entry type\");", "ret = ARCHIVE_FAILED;", "goto exit_free;", "}", "if (r != 0) {", "errno = EINVAL;", "archive_set_error(a, errno,", "\"Failed to set ACL entry type\");", "ret = ARCHIVE_FAILED;", "goto exit_free;", "}", "#if ARCHIVE_ACL_SUNOS_NFS4", "if (ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_NFS4) {", "perm_map_size = acl_nfs4_perm_map_size;", "perm_map = acl_nfs4_perm_map;", "} else {", "#endif", "perm_map_size = acl_posix_perm_map_size;", "perm_map = acl_posix_perm_map;", "#if ARCHIVE_ACL_SUNOS_NFS4", "}", "#endif", "for (i = 0; i < perm_map_size; ++i) {", "if (ae_permset & perm_map[i].a_perm) {", "#if ARCHIVE_ACL_SUNOS_NFS4", "if (ae_requested_type ==", "ARCHIVE_ENTRY_ACL_TYPE_NFS4)", "ace->a_access_mask |=", "perm_map[i].p_perm;", "else", "#endif", "aclent->a_perm |= perm_map[i].p_perm;", "}", "}", "#if ARCHIVE_ACL_SUNOS_NFS4", "if (ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_NFS4) {", "for (i = 0; i < acl_nfs4_flag_map_size; ++i) {", "if (ae_permset & acl_nfs4_flag_map[i].a_perm) {", "ace->a_flags |=", "acl_nfs4_flag_map[i].p_perm;", "}", "}", "}", "#endif", "e++;", "}", "if (fd >= 0) {", "if (facl(fd, cmd, entries, aclp) == 0)", "ret = ARCHIVE_OK;", "else {", "if (errno == EOPNOTSUPP) {", "ret = ARCHIVE_OK;", "} else {", "archive_set_error(a, errno,", "\"Failed to set acl on fd: %s\", tname);", "ret = ARCHIVE_WARN;", "}", "}", "} else if (acl(name, cmd, entries, aclp) != 0) {", "if (errno == EOPNOTSUPP) {", "ret = ARCHIVE_OK;", "} else {", "archive_set_error(a, errno, \"Failed to set acl: %s\",", "tname);", "ret = ARCHIVE_WARN;", "}", "}", "exit_free:", "free(aclp);", "return (ret);", "}"], "ner_tags": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["int amqp_handle_input(amqp_connection_state_t state, amqp_bytes_t received_data,", "amqp_frame_t *decoded_frame) {", "size_t bytes_consumed;", "void *raw_frame;", "decoded_frame->frame_type = 0;", "if (received_data.len == 0) {", "return AMQP_STATUS_OK;", "}", "if (state->state == CONNECTION_STATE_IDLE) {", "state->state = CONNECTION_STATE_HEADER;", "}", "bytes_consumed = consume_data(state, &received_data);", "if (state->inbound_offset < state->target_size) {", "return (int)bytes_consumed;", "}", "raw_frame = state->inbound_buffer.bytes;", "switch (state->state) {", "case CONNECTION_STATE_INITIAL:", "if (memcmp(raw_frame, \"AMQP\", 4) == 0) {", "decoded_frame->frame_type = AMQP_PSEUDOFRAME_PROTOCOL_HEADER;", "decoded_frame->channel = 0;", "decoded_frame->payload.protocol_header.transport_high =", "amqp_d8(amqp_offset(raw_frame, 4));", "decoded_frame->payload.protocol_header.transport_low =", "amqp_d8(amqp_offset(raw_frame, 5));", "decoded_frame->payload.protocol_header.protocol_version_major =", "amqp_d8(amqp_offset(raw_frame, 6));", "decoded_frame->payload.protocol_header.protocol_version_minor =", "amqp_d8(amqp_offset(raw_frame, 7));", "return_to_idle(state);", "return (int)bytes_consumed;", "}", "case CONNECTION_STATE_HEADER: {", "amqp_channel_t channel;", "amqp_pool_t *channel_pool;", "channel = amqp_d16(amqp_offset(raw_frame, 1));", "state->target_size =", "amqp_d32(amqp_offset(raw_frame, 3)) + HEADER_SIZE + FOOTER_SIZE;", "if ((size_t)state->frame_max < state->target_size) {", "return AMQP_STATUS_BAD_AMQP_DATA;", "}", "channel_pool = amqp_get_or_create_channel_pool(state, channel);", "if (NULL == channel_pool) {", "return AMQP_STATUS_NO_MEMORY;", "}", "amqp_pool_alloc_bytes(channel_pool, state->target_size,", "&state->inbound_buffer);", "if (NULL == state->inbound_buffer.bytes) {", "return AMQP_STATUS_NO_MEMORY;", "}", "memcpy(state->inbound_buffer.bytes, state->header_buffer, HEADER_SIZE);", "raw_frame = state->inbound_buffer.bytes;", "state->state = CONNECTION_STATE_BODY;", "bytes_consumed += consume_data(state, &received_data);", "if (state->inbound_offset < state->target_size) {", "return (int)bytes_consumed;", "}", "}", "case CONNECTION_STATE_BODY: {", "amqp_bytes_t encoded;", "int res;", "amqp_pool_t *channel_pool;", "if (amqp_d8(amqp_offset(raw_frame, state->target_size - 1)) !=", "AMQP_FRAME_END) {", "return AMQP_STATUS_BAD_AMQP_DATA;", "}", "decoded_frame->frame_type = amqp_d8(amqp_offset(raw_frame, 0));", "decoded_frame->channel = amqp_d16(amqp_offset(raw_frame, 1));", "channel_pool =", "amqp_get_or_create_channel_pool(state, decoded_frame->channel);", "if (NULL == channel_pool) {", "return AMQP_STATUS_NO_MEMORY;", "}", "switch (decoded_frame->frame_type) {", "case AMQP_FRAME_METHOD:", "decoded_frame->payload.method.id =", "amqp_d32(amqp_offset(raw_frame, HEADER_SIZE));", "encoded.bytes = amqp_offset(raw_frame, HEADER_SIZE + 4);", "encoded.len = state->target_size - HEADER_SIZE - 4 - FOOTER_SIZE;", "res = amqp_decode_method(decoded_frame->payload.method.id,", "channel_pool, encoded,", "&decoded_frame->payload.method.decoded);", "if (res < 0) {", "return res;", "}", "break;", "case AMQP_FRAME_HEADER:", "decoded_frame->payload.properties.class_id =", "amqp_d16(amqp_offset(raw_frame, HEADER_SIZE));", "decoded_frame->payload.properties.body_size =", "amqp_d64(amqp_offset(raw_frame, HEADER_SIZE + 4));", "encoded.bytes = amqp_offset(raw_frame, HEADER_SIZE + 12);", "encoded.len = state->target_size - HEADER_SIZE - 12 - FOOTER_SIZE;", "decoded_frame->payload.properties.raw = encoded;", "res = amqp_decode_properties(", "decoded_frame->payload.properties.class_id, channel_pool, encoded,", "&decoded_frame->payload.properties.decoded);", "if (res < 0) {", "return res;", "}", "break;", "case AMQP_FRAME_BODY:", "decoded_frame->payload.body_fragment.len =", "state->target_size - HEADER_SIZE - FOOTER_SIZE;", "decoded_frame->payload.body_fragment.bytes =", "amqp_offset(raw_frame, HEADER_SIZE);", "break;", "case AMQP_FRAME_HEARTBEAT:", "break;", "default:", "decoded_frame->frame_type = 0;", "break;", "}", "return_to_idle(state);", "return (int)bytes_consumed;", "}", "default:", "amqp_abort(\"Internal error: invalid amqp_connection_state_t->state %d\",", "state->state);", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static void swoole_serialize_arr(seriaString *buffer, zend_array *zvalue)", "{", "zval *data;", "zend_string *key;", "zend_ulong index;", "swPoolstr *swStr = NULL;", "zend_uchar is_pack = zvalue->u.flags & HASH_FLAG_PACKED;", "ZEND_HASH_FOREACH_KEY_VAL(zvalue, index, key, data)", "{", "SBucketType type = {0};", "type.data_type = Z_TYPE_P(data);", "size_t p = buffer->offset;", "if (is_pack && zvalue->nNextFreeElement == zvalue->nNumOfElements)", "{", "type.key_type = KEY_TYPE_INDEX;", "type.key_len = 0;", "SERIA_SET_ENTRY_TYPE(buffer, type);", "}", "else", "{", "if (key)", "{", "type.key_type = KEY_TYPE_STRING;", "if ((swStr = swoole_mini_filter_find(key)))", "{", "type.key_len = 3;", "SERIA_SET_ENTRY_TYPE(buffer, type);", "if (swStr->offset & 4)", "{", "SERIA_SET_ENTRY_SIZE4(buffer, swStr->offset);", "}", "else", "{", "SERIA_SET_ENTRY_SHORT(buffer, swStr->offset);", "}", "}", "else", "{", "if (key->len <= 0xff)", "{", "type.key_len = 1;", "SERIA_SET_ENTRY_TYPE(buffer, type);", "swoole_mini_filter_add(key, buffer->offset, 1);", "SERIA_SET_ENTRY_TYPE(buffer, key->len);", "swoole_string_cpy(buffer, key->val, key->len);", "}", "else if (key->len <= 0xffff)", "{", "type.key_len = 2;", "SERIA_SET_ENTRY_TYPE(buffer, type);", "swoole_mini_filter_add(key, buffer->offset, 2);", "SERIA_SET_ENTRY_SHORT(buffer, key->len);", "swoole_string_cpy(buffer, key->val, key->len);", "}", "else", "{", "type.key_len = 0;", "SERIA_SET_ENTRY_TYPE(buffer, type);", "swoole_mini_filter_add(key, buffer->offset, 3);", "swoole_string_cpy(buffer, key + XtOffsetOf(zend_string, len), sizeof (size_t) + key->len);", "}", "}", "}", "else", "{", "type.key_type = KEY_TYPE_INDEX;", "if (index <= 0xff)", "{", "type.key_len = 1;", "SERIA_SET_ENTRY_TYPE(buffer, type);", "SERIA_SET_ENTRY_TYPE(buffer, index);", "}", "else if (index <= 0xffff)", "{", "type.key_len = 2;", "SERIA_SET_ENTRY_TYPE(buffer, type);", "SERIA_SET_ENTRY_SHORT(buffer, index);", "}", "else", "{", "type.key_len = 3;", "SERIA_SET_ENTRY_TYPE(buffer, type);", "SERIA_SET_ENTRY_ULONG(buffer, index);", "}", "}", "}", "try_again:", "switch (Z_TYPE_P(data))", "{", "case IS_STRING:", "{", "if ((swStr = swoole_mini_filter_find(Z_STR_P(data))))", "{", "((SBucketType*) (buffer->buffer + p))->data_len = 3;", "if (swStr->offset & 4)", "{", "SERIA_SET_ENTRY_SIZE4(buffer, swStr->offset);", "}", "else", "{", "SERIA_SET_ENTRY_SHORT(buffer, swStr->offset);", "}", "}", "else", "{", "if (Z_STRLEN_P(data) <= 0xff)", "{", "((SBucketType*) (buffer->buffer + p))->data_len = 1;", "swoole_mini_filter_add(Z_STR_P(data), buffer->offset, 1);", "SERIA_SET_ENTRY_TYPE(buffer, Z_STRLEN_P(data));", "swoole_string_cpy(buffer, Z_STRVAL_P(data), Z_STRLEN_P(data));", "}", "else if (Z_STRLEN_P(data) <= 0xffff)", "{", "((SBucketType*) (buffer->buffer + p))->data_len = 2;", "swoole_mini_filter_add(Z_STR_P(data), buffer->offset, 2);", "SERIA_SET_ENTRY_SHORT(buffer, Z_STRLEN_P(data));", "swoole_string_cpy(buffer, Z_STRVAL_P(data), Z_STRLEN_P(data));", "}", "else", "{", "((SBucketType*) (buffer->buffer + p))->data_len = 0;", "swoole_mini_filter_add(Z_STR_P(data), buffer->offset, 3);", "swoole_string_cpy(buffer, (char*) Z_STR_P(data) + XtOffsetOf(zend_string, len), sizeof (size_t) + Z_STRLEN_P(data));", "}", "}", "break;", "}", "case IS_LONG:", "{", "SBucketType* long_type = (SBucketType*) (buffer->buffer + p);", "swoole_serialize_long(buffer, data, long_type);", "break;", "}", "case IS_DOUBLE:", "swoole_set_zend_value(buffer, &(data->value));", "break;", "case IS_REFERENCE:", "data = Z_REFVAL_P(data);", "((SBucketType*) (buffer->buffer + p))->data_type = Z_TYPE_P(data);", "goto try_again;", "break;", "case IS_ARRAY:", "{", "zend_array *ht = Z_ARRVAL_P(data);", "if (GC_IS_RECURSIVE(ht))", "{", "((SBucketType*) (buffer->buffer + p))->data_type = IS_NULL;", "php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"the array has cycle ref\");", "}", "else", "{", "seria_array_type(ht, buffer, p, buffer->offset);", "if (ZEND_HASH_APPLY_PROTECTION(ht))", "{", "GC_PROTECT_RECURSION(ht);", "swoole_serialize_arr(buffer, ht);", "GC_UNPROTECT_RECURSION(ht);", "}", "else", "{", "swoole_serialize_arr(buffer, ht);", "}", "}", "break;", "}", "case IS_INDIRECT:", "data = Z_INDIRECT_P(data);", "zend_uchar type = Z_TYPE_P(data);", "((SBucketType*) (buffer->buffer + p))->data_type = (type == IS_UNDEF ? IS_NULL : type);", "goto try_again;", "break;", "case IS_OBJECT:", "{", "((SBucketType*) (buffer->buffer + p))->data_type = IS_UNDEF;", "if (ZEND_HASH_APPLY_PROTECTION(Z_OBJPROP_P(data)))", "{", "GC_PROTECT_RECURSION(Z_OBJPROP_P(data));", "swoole_serialize_object(buffer, data, p);", "GC_UNPROTECT_RECURSION(Z_OBJPROP_P(data));", "}", "else", "{", "swoole_serialize_object(buffer, data, p);", "}", "break;", "}", "default:", "break;", "}", "}", "ZEND_HASH_FOREACH_END();", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int parse_playlist(HLSContext *c, const char *url,", "struct playlist *pls, AVIOContext *in)", "{", "int ret = 0, is_segment = 0, is_variant = 0;", "int64_t duration = 0;", "enum KeyType key_type = KEY_NONE;", "uint8_t iv[16] = \"\";", "int has_iv = 0;", "char key[MAX_URL_SIZE] = \"\";", "char line[MAX_URL_SIZE];", "const char *ptr;", "int close_in = 0;", "int64_t seg_offset = 0;", "int64_t seg_size = -1;", "uint8_t *new_url = NULL;", "struct variant_info variant_info;", "char tmp_str[MAX_URL_SIZE];", "struct segment *cur_init_section = NULL;", "if (!in) {", "#if 1", "AVDictionary *opts = NULL;", "close_in = 1;", "av_dict_set(&opts, \"seekable\", \"0\", 0);", "av_dict_set(&opts, \"user-agent\", c->user_agent, 0);", "av_dict_set(&opts, \"cookies\", c->cookies, 0);", "av_dict_set(&opts, \"headers\", c->headers, 0);", "ret = avio_open2(&in, url, AVIO_FLAG_READ,", "c->interrupt_callback, &opts);", "av_dict_free(&opts);", "if (ret < 0)", "return ret;", "#else", "ret = open_in(c, &in, url);", "if (ret < 0)", "return ret;", "close_in = 1;", "#endif", "}", "if (av_opt_get(in, \"location\", AV_OPT_SEARCH_CHILDREN, &new_url) >= 0)", "url = new_url;", "read_chomp_line(in, line, sizeof(line));", "if (strcmp(line, \"#EXTM3U\")) {", "ret = AVERROR_INVALIDDATA;", "goto fail;", "}", "if (pls) {", "free_segment_list(pls);", "pls->finished = 0;", "pls->type = PLS_TYPE_UNSPECIFIED;", "}", "while (!avio_feof(in)) {", "read_chomp_line(in, line, sizeof(line));", "if (av_strstart(line, \"#EXT-X-STREAM-INF:\", &ptr)) {", "is_variant = 1;", "memset(&variant_info, 0, sizeof(variant_info));", "ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_variant_args,", "&variant_info);", "} else if (av_strstart(line, \"#EXT-X-KEY:\", &ptr)) {", "struct key_info info = {{0}};", "ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_key_args,", "&info);", "key_type = KEY_NONE;", "has_iv = 0;", "if (!strcmp(info.method, \"AES-128\"))", "key_type = KEY_AES_128;", "if (!strcmp(info.method, \"SAMPLE-AES\"))", "key_type = KEY_SAMPLE_AES;", "if (!strncmp(info.iv, \"0x\", 2) || !strncmp(info.iv, \"0X\", 2)) {", "ff_hex_to_data(iv, info.iv + 2);", "has_iv = 1;", "}", "av_strlcpy(key, info.uri, sizeof(key));", "} else if (av_strstart(line, \"#EXT-X-MEDIA:\", &ptr)) {", "struct rendition_info info = {{0}};", "ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_rendition_args,", "&info);", "new_rendition(c, &info, url);", "} else if (av_strstart(line, \"#EXT-X-TARGETDURATION:\", &ptr)) {", "ret = ensure_playlist(c, &pls, url);", "if (ret < 0)", "goto fail;", "pls->target_duration = atoi(ptr) * AV_TIME_BASE;", "} else if (av_strstart(line, \"#EXT-X-MEDIA-SEQUENCE:\", &ptr)) {", "ret = ensure_playlist(c, &pls, url);", "if (ret < 0)", "goto fail;", "pls->start_seq_no = atoi(ptr);", "} else if (av_strstart(line, \"#EXT-X-PLAYLIST-TYPE:\", &ptr)) {", "ret = ensure_playlist(c, &pls, url);", "if (ret < 0)", "goto fail;", "if (!strcmp(ptr, \"EVENT\"))", "pls->type = PLS_TYPE_EVENT;", "else if (!strcmp(ptr, \"VOD\"))", "pls->type = PLS_TYPE_VOD;", "} else if (av_strstart(line, \"#EXT-X-MAP:\", &ptr)) {", "struct init_section_info info = {{0}};", "ret = ensure_playlist(c, &pls, url);", "if (ret < 0)", "goto fail;", "ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_init_section_args,", "&info);", "cur_init_section = new_init_section(pls, &info, url);", "} else if (av_strstart(line, \"#EXT-X-ENDLIST\", &ptr)) {", "if (pls)", "pls->finished = 1;", "} else if (av_strstart(line, \"#EXTINF:\", &ptr)) {", "is_segment = 1;", "duration   = atof(ptr) * AV_TIME_BASE;", "} else if (av_strstart(line, \"#EXT-X-BYTERANGE:\", &ptr)) {", "seg_size = atoi(ptr);", "ptr = strchr(ptr, '@');", "if (ptr)", "seg_offset = atoi(ptr+1);", "} else if (av_strstart(line, \"#\", NULL)) {", "continue;", "} else if (line[0]) {", "if (is_variant) {", "if (!new_variant(c, &variant_info, line, url)) {", "ret = AVERROR(ENOMEM);", "goto fail;", "}", "is_variant = 0;", "}", "if (is_segment) {", "struct segment *seg;", "if (!pls) {", "if (!new_variant(c, 0, url, NULL)) {", "ret = AVERROR(ENOMEM);", "goto fail;", "}", "pls = c->playlists[c->n_playlists - 1];", "}", "seg = av_malloc(sizeof(struct segment));", "if (!seg) {", "ret = AVERROR(ENOMEM);", "goto fail;", "}", "seg->duration = duration;", "seg->key_type = key_type;", "if (has_iv) {", "memcpy(seg->iv, iv, sizeof(iv));", "} else {", "int seq = pls->start_seq_no + pls->n_segments;", "memset(seg->iv, 0, sizeof(seg->iv));", "AV_WB32(seg->iv + 12, seq);", "}", "if (key_type != KEY_NONE) {", "ff_make_absolute_url(tmp_str, sizeof(tmp_str), url, key);", "seg->key = av_strdup(tmp_str);", "if (!seg->key) {", "av_free(seg);", "ret = AVERROR(ENOMEM);", "goto fail;", "}", "} else {", "seg->key = NULL;", "}", "ff_make_absolute_url(tmp_str, sizeof(tmp_str), url, line);", "seg->url = av_strdup(tmp_str);", "if (!seg->url) {", "av_free(seg->key);", "av_free(seg);", "ret = AVERROR(ENOMEM);", "goto fail;", "}", "dynarray_add(&pls->segments, &pls->n_segments, seg);", "is_segment = 0;", "seg->size = seg_size;", "if (seg_size >= 0) {", "seg->url_offset = seg_offset;", "seg_offset += seg_size;", "seg_size = -1;", "} else {", "seg->url_offset = 0;", "seg_offset = 0;", "}", "seg->init_section = cur_init_section;", "}", "}", "}", "if (pls)", "pls->last_load_time = av_gettime_relative();", "fail:", "av_free(new_url);", "if (close_in)", "avio_close(in);", "return ret;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["varbit_in(PG_FUNCTION_ARGS)", "{", "char    *input_string = PG_GETARG_CSTRING(0);", "#ifdef NOT_USED", "Oid   typelem = PG_GETARG_OID(1);", "#endif", "int32  atttypmod = PG_GETARG_INT32(2);", "VarBit    *result;", "char    *sp;", "bits8    *r;", "int   len,", "bitlen,", "slen;", "bool  bit_not_hex;", "int   bc;", "bits8  x = 0;", "if (input_string[0] == 'b' || input_string[0] == 'B')", "{", "bit_not_hex = true;", "sp = input_string + 1;", "}", "else if (input_string[0] == 'x' || input_string[0] == 'X')", "{", "bit_not_hex = false;", "sp = input_string + 1;", "}", "else", "{", "bit_not_hex = true;", "sp = input_string;", "}", "slen = strlen(sp);", "if (bit_not_hex)", "bitlen = slen;", "else", "bitlen = slen * 4;", "if (atttypmod <= 0)", "atttypmod = bitlen;", "else if (bitlen > atttypmod)", "ereport(ERROR,", "(errcode(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),", "errmsg(\"bit string too long for type bit varying(%d)\",", "atttypmod)));", "len = VARBITTOTALLEN(bitlen);", "result = (VarBit *) palloc0(len);", "SET_VARSIZE(result, len);", "VARBITLEN(result) = Min(bitlen, atttypmod);", "r = VARBITS(result);", "if (bit_not_hex)", "{", "x = HIGHBIT;", "for (; *sp; sp++)", "{", "if (*sp == '1')", "*r |= x;", "else if (*sp != '0')", "ereport(ERROR,", "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),", "errmsg(\"\\\"%c\\\" is not a valid binary digit\",", "*sp)));", "x >>= 1;", "if (x == 0)", "{", "x = HIGHBIT;", "r++;", "}", "}", "}", "else", "{", "for (bc = 0; *sp; sp++)", "{", "if (*sp >= '0' && *sp <= '9')", "x = (bits8) (*sp - '0');", "else if (*sp >= 'A' && *sp <= 'F')", "x = (bits8) (*sp - 'A') + 10;", "else if (*sp >= 'a' && *sp <= 'f')", "x = (bits8) (*sp - 'a') + 10;", "else", "ereport(ERROR,", "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),", "errmsg(\"\\\"%c\\\" is not a valid hexadecimal digit\",", "*sp)));", "if (bc)", "{", "*r++ |= x;", "bc = 0;", "}", "else", "{", "*r = x << 4;", "bc = 1;", "}", "}", "}", "PG_RETURN_VARBIT_P(result);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static void gf_dump_vrml_field(GF_SceneDumper *sdump, GF_Node *node, GF_FieldInfo field)", "{", "u32 i, sf_type;", "Bool needs_field_container;", "GF_ChildNodeItem *list;", "void *slot_ptr;", "switch (field.fieldType) {", "case GF_SG_VRML_SFNODE:", "assert ( *(GF_Node **)field.far_ptr);", "if (sdump->XMLDump) {", "if (!sdump->X3DDump) {", "StartElement(sdump, (char *) field.name);", "EndElementHeader(sdump, 1);", "sdump->indent++;", "}", "} else {", "StartAttribute(sdump, field.name);", "}", "gf_dump_vrml_node(sdump, *(GF_Node **)field.far_ptr, 0, NULL);", "if (sdump->XMLDump) {", "if (!sdump->X3DDump) {", "sdump->indent--;", "EndElement(sdump, (char *) field.name, 1);", "}", "} else {", "EndAttribute(sdump);", "}", "return;", "case GF_SG_VRML_MFNODE:", "needs_field_container = 0;", "if (sdump->XMLDump && sdump->X3DDump) {", "u32 count, nb_ndt;", "GF_FieldInfo info;", "if (!strcmp(field.name, \"children\")) {", "needs_field_container = 0;", "} else {", "nb_ndt = 0;", "count = gf_node_get_field_count(node);", "for (i=0; i<count; i++) {", "gf_node_get_field(node, i, &info);", "if ((info.eventType==GF_SG_EVENT_IN) || (info.eventType==GF_SG_EVENT_OUT)) continue;", "if (info.NDTtype==field.NDTtype) nb_ndt++;", "}", "needs_field_container = (nb_ndt>1) ? 1 : 0;", "}", "}", "#ifndef GPAC_DISABLE_X3D", "if (!sdump->X3DDump) {", "if (gf_node_get_tag(node)==TAG_X3D_Switch) field.name = \"choice\";", "}", "#endif", "list = * ((GF_ChildNodeItem **) field.far_ptr);", "assert(list);", "if (!sdump->XMLDump || !sdump->X3DDump) StartList(sdump, field.name);", "sdump->indent++;", "while (list) {", "gf_dump_vrml_node(sdump, list->node, 1, needs_field_container ? (char *) field.name : NULL);", "list = list->next;", "}", "sdump->indent--;", "if (!sdump->XMLDump || !sdump->X3DDump) EndList(sdump, field.name);", "return;", "case GF_SG_VRML_SFCOMMANDBUFFER:", "{", "SFCommandBuffer *cb = (SFCommandBuffer *)field.far_ptr;", "StartElement(sdump, (char *) field.name);", "EndElementHeader(sdump, 1);", "sdump->indent++;", "if (!gf_list_count(cb->commandList)) {", "if (sdump->trace && cb->bufferSize) {", "if (sdump->XMLDump) gf_fprintf(sdump->trace, \"<!--SFCommandBuffer cannot be dumped while playing - use MP4Box instead-->\\n\");", "else gf_fprintf(sdump->trace, \"#SFCommandBuffer cannot be dumped while playing - use MP4Box instead\\n\");", "}", "} else {", "gf_sm_dump_command_list(sdump, cb->commandList, sdump->indent, 0);", "}", "sdump->indent--;", "EndElement(sdump, (char *) field.name, 1);", "}", "return;", "case GF_SG_VRML_MFATTRREF:", "if (sdump->XMLDump) {", "MFAttrRef *ar = (MFAttrRef *)field.far_ptr;", "StartElement(sdump, (char *) field.name);", "EndElementHeader(sdump, 1);", "sdump->indent++;", "for (i=0; i<ar->count; i++) {", "if (ar->vals[i].node) {", "GF_FieldInfo pinfo;", "DUMP_IND(sdump);", "gf_node_get_field(ar->vals[i].node, ar->vals[i].fieldIndex, &pinfo);", "gf_fprintf(sdump->trace, \"<store node=\\\"\");", "scene_dump_vrml_id(sdump, ar->vals[i].node);", "gf_fprintf(sdump->trace, \"\\\" field=\\\"%s\\\"/>\\n\", pinfo.name);", "}", "}", "sdump->indent--;", "EndElement(sdump, (char *) field.name, 1);", "return;", "}", "break;", "}", "if (gf_sg_vrml_is_sf_field(field.fieldType)) {", "StartAttribute(sdump, field.name);", "gf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, node);", "EndAttribute(sdump);", "} else {", "GenMFField *mffield = (GenMFField *) field.far_ptr;", "sf_type = gf_sg_vrml_get_sf_type(field.fieldType);", "if (sdump->XMLDump && sdump->X3DDump) {", "switch (sf_type) {", "case GF_SG_VRML_SFSTRING:", "case GF_SG_VRML_SFSCRIPT:", "case GF_SG_VRML_SFURL:", "gf_fprintf(sdump->trace, \" %s=\\'\", (char *) field.name);", "break;", "default:", "StartAttribute(sdump, field.name);", "break;", "}", "} else {", "StartAttribute(sdump, field.name);", "}", "if (!sdump->XMLDump) gf_fprintf(sdump->trace, \"[\");", "if (mffield) {", "for (i=0; i<mffield->count; i++) {", "if (i) gf_fprintf(sdump->trace, \" \");", "gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);", "gf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, node);", "}", "}", "if (!sdump->XMLDump) gf_fprintf(sdump->trace, \"]\");", "if (sdump->XMLDump && sdump->X3DDump) {", "switch (sf_type) {", "case GF_SG_VRML_SFSTRING:", "case GF_SG_VRML_SFSCRIPT:", "case GF_SG_VRML_SFURL:", "gf_fprintf(sdump->trace, \"\\'\");", "break;", "default:", "EndAttribute(sdump);", "break;", "}", "} else {", "EndAttribute(sdump);", "}", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int build_open_gop_key_points(AVStream *st)", "{", "int k;", "int sample_id = 0;", "uint32_t cra_index;", "MOVStreamContext *sc = st->priv_data;", "if (st->codecpar->codec_id != AV_CODEC_ID_HEVC || !sc->sync_group_count)", "return 0;", "sc->sample_offsets_count = 0;", "for (uint32_t i = 0; i < sc->ctts_count; i++)", "sc->sample_offsets_count += sc->ctts_data[i].count;", "av_freep(&sc->sample_offsets);", "sc->sample_offsets = av_calloc(sc->sample_offsets_count, sizeof(*sc->sample_offsets));", "if (!sc->sample_offsets)", "return AVERROR(ENOMEM);", "k = 0;", "for (uint32_t i = 0; i < sc->ctts_count; i++)", "for (int j = 0; j < sc->ctts_data[i].count; j++)", "sc->sample_offsets[k++] = sc->ctts_data[i].duration;", "cra_index = get_sgpd_sync_index(sc, HEVC_NAL_CRA_NUT);", "if (!cra_index)", "return 0;", "sc->open_key_samples_count = 0;", "for (uint32_t i = 0; i < sc->sync_group_count; i++)", "if (sc->sync_group[i].index == cra_index)", "sc->open_key_samples_count += sc->sync_group[i].count;", "av_freep(&sc->open_key_samples);", "sc->open_key_samples = av_calloc(sc->open_key_samples_count, sizeof(*sc->open_key_samples));", "if (!sc->open_key_samples)", "return AVERROR(ENOMEM);", "k = 0;", "for (uint32_t i = 0; i < sc->sync_group_count; i++) {", "const MOVSbgp *sg = &sc->sync_group[i];", "if (sg->index == cra_index)", "for (uint32_t j = 0; j < sg->count; j++)", "sc->open_key_samples[k++] = sample_id;", "sample_id += sg->count;", "}", "sc->min_sample_duration = UINT_MAX;", "for (uint32_t i = 0; i < sc->stts_count; i++)", "sc->min_sample_duration = FFMIN(sc->min_sample_duration, sc->stts_data[i].duration);", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void RemoteFsDevice::mount()", "{", "if (details.isLocalFile()) {", "return;", "}", "if (isConnected() || proc) {", "return;", "}", "if (messageSent) {", "return;", "}", "if (constSambaAvahiProtocol==details.url.scheme()) {", "Details det=details;", "AvahiService *srv=Avahi::self()->getService(det.serviceName);", "if (!srv || srv->getHost().isEmpty() || 0==srv->getPort()) {", "emit error(tr(\"Failed to resolve connection details for %1\").arg(details.name));", "return;", "}", "if (constPromptPassword==det.url.password()) {", "bool ok=false;", "QString passwd=InputDialog::getPassword(QString(), &ok, QApplication::activeWindow());", "if (!ok) {", "return;", "}", "det.url.setPassword(passwd);", "}", "det.url.setScheme(constSambaProtocol);", "det.url.setHost(srv->getHost());", "det.url.setPort(srv->getPort());", "mounter()->mount(det.url.toString(), mountPoint(details, true), getuid(), getgid(), getpid());", "setStatusMessage(tr(\"Connecting...\"));", "messageSent=true;", "return;", "}", "if (constSambaProtocol==details.url.scheme()) {", "Details det=details;", "if (constPromptPassword==det.url.password()) {", "bool ok=false;", "QString passwd=InputDialog::getPassword(QString(), &ok, QApplication::activeWindow());", "if (!ok) {", "return;", "}", "det.url.setPassword(passwd);", "}", "mounter()->mount(det.url.toString(), mountPoint(details, true), getuid(), getgid(), getpid());", "setStatusMessage(tr(\"Connecting...\"));", "messageSent=true;", "return;", "}", "QString cmd;", "QStringList args;", "QString askPass;", "if (!details.isLocalFile() && !details.isEmpty()) {", "bool needAskPass=!details.extraOptions.contains(\"IdentityFile=\");", "if (needAskPass) {", "QStringList askPassList;", "if (Utils::KDE==Utils::currentDe()) {", "askPassList << QLatin1String(\"ksshaskpass\") << QLatin1String(\"ssh-askpass\") << QLatin1String(\"ssh-askpass-gnome\");", "} else {", "askPassList << QLatin1String(\"ssh-askpass-gnome\") << QLatin1String(\"ssh-askpass\") << QLatin1String(\"ksshaskpass\");", "}", "for (const QString &ap: askPassList) {", "askPass=Utils::findExe(ap);", "if (!askPass.isEmpty()) {", "break;", "}", "}", "if (askPass.isEmpty()) {", "emit error(tr(\"No suitable ssh-askpass application installed! This is required for entering passwords.\"));", "return;", "}", "}", "QString sshfs=Utils::findExe(\"sshfs\");", "if (sshfs.isEmpty()) {", "emit error(tr(\"\\\"sshfs\\\" is not installed!\"));", "return;", "}", "cmd=Utils::findExe(\"setsid\");", "if (!cmd.isEmpty()) {", "QString mp=mountPoint(details, true);", "if (mp.isEmpty()) {", "emit error(\"Failed to determine mount point\");", "}", "if (!QDir(mp).entryList(QDir::NoDot|QDir::NoDotDot|QDir::AllEntries|QDir::Hidden).isEmpty()) {", "emit error(tr(\"Mount point (\\\"%1\\\") is not empty!\").arg(mp));", "return;", "}", "args << sshfs << details.url.userName()+QChar('@')+details.url.host()+QChar(':')+details.url.path()<< QLatin1String(\"-p\")", "<< QString::number(details.url.port()) << mountPoint(details, true)", "<< QLatin1String(\"-o\") << QLatin1String(\"ServerAliveInterval=15\");", "if (!details.extraOptions.isEmpty()) {", "args << details.extraOptions.split(' ', QString::SkipEmptyParts);", "}", "} else {", "emit error(tr(\"\\\"sshfs\\\" is not installed!\").replace(\"sshfs\", \"setsid\"));", "}", "}", "if (!cmd.isEmpty()) {", "setStatusMessage(tr(\"Connecting...\"));", "proc=new QProcess(this);", "proc->setProperty(\"mount\", true);", "if (!askPass.isEmpty()) {", "QProcessEnvironment env = QProcessEnvironment::systemEnvironment();", "env.insert(\"SSH_ASKPASS\", askPass);", "proc->setProcessEnvironment(env);", "}", "connect(proc, SIGNAL(finished(int)), SLOT(procFinished(int)));", "proc->start(cmd, args, QIODevice::ReadOnly);", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static inline bool isValid(const RemoteFsDevice::Details &d)", "{", "return d.isLocalFile() || RemoteFsDevice::constSshfsProtocol==d.url.scheme() ||", "RemoteFsDevice::constSambaProtocol==d.url.scheme() || RemoteFsDevice::constSambaAvahiProtocol==d.url.scheme();", "}"], "ner_tags": [0, 0, 1, 1, 0]}
{"tokens": ["GF_AV1Config *gf_odf_av1_cfg_read_bs_size(GF_BitStream *bs, u32 size)", "{", "#ifndef GPAC_DISABLE_AV_PARSERS", "AV1State state;", "u8 reserved;", "GF_AV1Config *cfg;", "if (!size) size = (u32) gf_bs_available(bs);", "if (!size) return NULL;", "cfg = gf_odf_av1_cfg_new();", "gf_av1_init_state(&state);", "state.config = cfg;", "cfg->marker = gf_bs_read_int(bs, 1);", "cfg->version = gf_bs_read_int(bs, 7);", "cfg->seq_profile = gf_bs_read_int(bs, 3);", "cfg->seq_level_idx_0 = gf_bs_read_int(bs, 5);", "cfg->seq_tier_0 = gf_bs_read_int(bs, 1);", "cfg->high_bitdepth = gf_bs_read_int(bs, 1);", "cfg->twelve_bit = gf_bs_read_int(bs, 1);", "cfg->monochrome = gf_bs_read_int(bs, 1);", "cfg->chroma_subsampling_x = gf_bs_read_int(bs, 1);", "cfg->chroma_subsampling_y = gf_bs_read_int(bs, 1);", "cfg->chroma_sample_position = gf_bs_read_int(bs, 2);", "reserved = gf_bs_read_int(bs, 3);", "if (reserved != 0 || cfg->marker != 1 || cfg->version != 1) {", "GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1] wrong avcC reserved %d / marker %d / version %d expecting 0 1 1\\n\", reserved, cfg->marker, cfg->version));", "gf_odf_av1_cfg_del(cfg);", "return NULL;", "}", "cfg->initial_presentation_delay_present = gf_bs_read_int(bs, 1);", "if (cfg->initial_presentation_delay_present) {", "cfg->initial_presentation_delay_minus_one = gf_bs_read_int(bs, 4);", "} else {", "gf_bs_read_int(bs, 4);", "cfg->initial_presentation_delay_minus_one = 0;", "}", "size -= 4;", "while (size) {", "u64 pos, obu_size;", "ObuType obu_type;", "GF_AV1_OBUArrayEntry *a;", "pos = gf_bs_get_position(bs);", "obu_size = 0;", "if (gf_av1_parse_obu(bs, &obu_type, &obu_size, NULL, &state) != GF_OK) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[AV1] could not parse AV1 OBU at position \"LLU\". Leaving parsing.\\n\", pos));", "break;", "}", "assert(obu_size == gf_bs_get_position(bs) - pos);", "GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1] parsed AV1 OBU type=%u size=\"LLU\" at position \"LLU\".\\n\", obu_type, obu_size, pos));", "if (!av1_is_obu_header(obu_type)) {", "GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1] AV1 unexpected OBU type=%u size=\"LLU\" found at position \"LLU\". Forwarding.\\n\", pos));", "}", "GF_SAFEALLOC(a, GF_AV1_OBUArrayEntry);", "if (!a) break;", "a->obu = gf_malloc((size_t)obu_size);", "if (!a->obu) {", "gf_free(a);", "break;", "}", "gf_bs_seek(bs, pos);", "gf_bs_read_data(bs, (char *) a->obu, (u32)obu_size);", "a->obu_length = obu_size;", "a->obu_type = obu_type;", "gf_list_add(cfg->obu_array, a);", "if (size<obu_size) {", "GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[AV1] AV1 config misses %d bytes to fit the entire OBU\\n\", obu_size - size));", "break;", "}", "size -= (u32) obu_size;", "}", "gf_av1_reset_state(& state, GF_TRUE);", "return cfg;", "#else", "return NULL;", "#endif", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["void SFS_Params(ScriptParser *parser)", "{", "u32 val;", "if (parser->codec->LastError) return;", "val = gf_bs_read_int(parser->bs, 1);", "while (val) {", "SFS_Expression(parser);", "val = gf_bs_read_int(parser->bs, 1);", "if(val) SFS_AddString(parser, \",\");", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["static GF_Err gf_media_export_filters(GF_MediaExporter *dumper)", "{", "char *args, szSubArgs[1024], szExt[30];", "GF_Filter *file_out, *reframer, *remux=NULL, *src_filter;", "GF_FilterSession *fsess;", "GF_Err e = GF_OK;", "u32 codec_id=0;", "u32 sample_count=0;", "Bool skip_write_filter = GF_FALSE;", "Bool ext_forced = GF_FALSE;", "Bool use_dynext = GF_FALSE;", "args = NULL;", "strcpy(szExt, \"\");", "if (dumper->trackID && dumper->file) {", "u32 msubtype = 0;", "u32 mtype = 0;", "u32 afmt = 0;", "GF_PixelFormat pfmt = 0;", "GF_ESD *esd;", "const char *export_ext = dumper->out_name ? gf_file_ext_start(dumper->out_name) : NULL;", "u32 track_num = gf_isom_get_track_by_id(dumper->file, dumper->trackID);", "if (!track_num) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] No tracks with ID %d in file\\n\", dumper->trackID));", "return GF_BAD_PARAM;", "}", "esd = gf_media_map_esd(dumper->file, track_num, 0);", "sample_count = gf_isom_get_sample_count(dumper->file, dumper->trackID);", "if (esd) {", "if (esd->decoderConfig->objectTypeIndication<GF_CODECID_LAST_MPEG4_MAPPING) {", "codec_id = gf_codecid_from_oti(esd->decoderConfig->streamType, esd->decoderConfig->objectTypeIndication);", "#ifndef GPAC_DISABLE_AV_PARSERS", "if (esd->decoderConfig->decoderSpecificInfo && (codec_id==GF_CODECID_AAC_MPEG4)) {", "GF_M4ADecSpecInfo acfg;", "gf_m4a_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &acfg);", "if (acfg.base_object_type == GF_M4A_USAC)", "codec_id = GF_CODECID_USAC;", "}", "#endif", "} else {", "codec_id = esd->decoderConfig->objectTypeIndication;", "}", "}", "if (!codec_id) {", "msubtype = gf_isom_get_media_subtype(dumper->file, track_num, 1);", "codec_id = gf_codec_id_from_isobmf(msubtype);", "}", "mtype = gf_isom_get_media_type(dumper->file, track_num);", "if (!codec_id) {", "pfmt = gf_pixel_fmt_from_qt_type(msubtype);", "if (pfmt) codec_id = GF_CODECID_RAW;", "}", "if (!codec_id) {", "strcpy(szExt, gf_4cc_to_str(msubtype));", "ext_forced = GF_TRUE;", "} else if (codec_id==GF_CODECID_RAW) {", "switch (mtype) {", "case GF_ISOM_MEDIA_VISUAL:", "case GF_ISOM_MEDIA_AUXV:", "case GF_ISOM_MEDIA_PICT:", "if (pfmt)", "strcpy(szExt, gf_pixel_fmt_sname(pfmt));", "break;", "case GF_ISOM_MEDIA_AUDIO:", "afmt = gf_audio_fmt_from_isobmf(msubtype);", "if (afmt)", "strcpy(szExt, gf_audio_fmt_name(afmt));", "break;", "default:", "strcpy(szExt, gf_4cc_to_str(msubtype));", "break;", "}", "} else {", "const char *sname = gf_codecid_file_ext(codec_id);", "if (export_ext && strstr(sname, export_ext+1)) {", "szExt[0]=0;", "} else {", "char *sep;", "strncpy(szExt, sname, 29);", "szExt[29]=0;", "sep = strchr(szExt, '|');", "if (sep) sep[0] = 0;", "}", "}", "switch (mtype) {", "case GF_ISOM_MEDIA_VISUAL:", "case GF_ISOM_MEDIA_AUXV:", "case GF_ISOM_MEDIA_PICT:", "case GF_ISOM_MEDIA_AUDIO:", "skip_write_filter = codec_id ? GF_TRUE : GF_FALSE;", "break;", "default:", "switch (codec_id) {", "case GF_CODECID_WEBVTT:", "skip_write_filter = GF_TRUE;", "break;", "case GF_CODECID_META_TEXT:", "case GF_CODECID_META_XML:", "case GF_CODECID_SUBS_TEXT:", "case GF_CODECID_SUBS_XML:", "case GF_CODECID_SIMPLE_TEXT:", "szExt[0] = 0;", "use_dynext = GF_TRUE;", "break;", "}", "break;", "}", "if ((codec_id==GF_CODECID_VORBIS) || (codec_id==GF_CODECID_THEORA) || (codec_id==GF_CODECID_OPUS)) {", "char *outname = dumper->out_name;", "if (outname && !strcmp(outname, \"std\")) outname=NULL;", "if (esd) gf_odf_desc_del((GF_Descriptor *) esd);", "#ifndef GPAC_DISABLE_AV_PARSERS", "return gf_dump_to_ogg(dumper, outname, track_num);", "#else", "return GF_NOT_SUPPORTED;", "#endif", "}", "if (codec_id==GF_CODECID_SUBPIC) {", "#ifndef GPAC_DISABLE_AV_PARSERS", "char *dsi = NULL;", "u32 dsi_size = 0;", "if (esd && esd->decoderConfig && esd->decoderConfig->decoderSpecificInfo) {", "dsi = esd->decoderConfig->decoderSpecificInfo->data;", "dsi_size = esd->decoderConfig->decoderSpecificInfo->dataLength;", "}", "e = gf_dump_to_vobsub(dumper, dumper->out_name, track_num, dsi, dsi_size);", "#else", "e = GF_NOT_SUPPORTED;", "#endif", "if (esd) gf_odf_desc_del((GF_Descriptor *) esd);", "return e;", "}", "if (esd) gf_odf_desc_del((GF_Descriptor *) esd);", "} else {", "const char *export_ext = dumper->out_name ? gf_file_ext_start(dumper->out_name) : NULL;", "skip_write_filter = GF_TRUE;", "if (!export_ext)", "use_dynext = GF_TRUE;", "}", "fsess = gf_fs_new_defaults(0);", "if (!fsess) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Failed to create filter session\\n\"));", "return GF_OUT_OF_MEM;", "}", "file_out = NULL;", "args = NULL;", "if (dumper->flags & GF_EXPORT_REMUX) {", "file_out = gf_fs_load_destination(fsess, dumper->out_name, NULL, NULL, &e);", "if (!file_out) {", "gf_fs_del(fsess);", "GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot open destination %s\\n\", dumper->out_name));", "return e;", "}", "}", "else if (!dumper->dump_file) {", "Bool no_ext = (dumper->flags & GF_EXPORT_NO_FILE_EXT) ? GF_TRUE : GF_FALSE;", "char *ext = gf_file_ext_start(dumper->out_name);", "e = gf_dynstrcat(&args, \"fout:dst=\", NULL);", "e |= gf_dynstrcat(&args, dumper->out_name, NULL);", "if (dumper->flags & GF_EXPORT_NHNT) {", "strcpy(szExt, \"nhnt\");", "e |= gf_dynstrcat(&args, \":clone\", NULL);", "no_ext = GF_TRUE;", "if (!ext)", "e |= gf_dynstrcat(&args, \":dynext\", NULL);", "} else if (dumper->flags & GF_EXPORT_NHML) {", "strcpy(szExt, \"nhml\");", "e |= gf_dynstrcat(&args, \":clone\", NULL);", "no_ext = GF_TRUE;", "if (!ext)", "e |= gf_dynstrcat(&args, \":dynext\", NULL);", "}", "if (dumper->flags & GF_EXPORT_RAW_SAMPLES) {", "if (!dumper->sample_num) {", "ext = gf_file_ext_start(args);", "if (ext) ext[0] = 0;", "if (sample_count>=1000) {", "e |= gf_dynstrcat(&args, \"_$num%08d$\", NULL);", "} else if (sample_count) {", "e |= gf_dynstrcat(&args, \"_$num%03d$\", NULL);", "} else {", "e |= gf_dynstrcat(&args, \"_$num$\", NULL);", "}", "ext = gf_file_ext_start(dumper->out_name);", "if (ext) e |= gf_dynstrcat(&args, ext, NULL);", "}", "e |= gf_dynstrcat(&args, \":dynext\", NULL);", "} else if (dumper->trackID && strlen(szExt) ) {", "if (!no_ext && !gf_file_ext_start(dumper->out_name)) {", "if (args) gf_free(args);", "args=NULL;", "e = gf_dynstrcat(&args, \"fout:dst=\", NULL);", "e |= gf_dynstrcat(&args, dumper->out_name, NULL);", "e |= gf_dynstrcat(&args, szExt, \".\");", "} else {", "e |= gf_dynstrcat(&args, \":ext=\", NULL);", "e |= gf_dynstrcat(&args, szExt, NULL);", "}", "} else if ((dumper->trackID || dumper->track_type) && use_dynext) {", "e |= gf_dynstrcat(&args, \":dynext\", NULL);", "}", "if (e) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load arguments for output file dumper\\n\"));", "if (args) gf_free(args);", "gf_fs_del(fsess);", "return e;", "}", "file_out = gf_fs_load_filter(fsess, args, &e);", "if (!file_out) {", "gf_fs_del(fsess);", "if (args) gf_free(args);", "GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load output file dumper\\n\"));", "return e;", "}", "}", "if (args) gf_free(args);", "args = NULL;", "if (dumper->flags & GF_EXPORT_RAW_SAMPLES) {", "e = gf_dynstrcat(&args, \"writegen:frame\", NULL);", "if (dumper->sample_num) {", "sprintf(szSubArgs, \":sstart=%d:send=%d\", dumper->sample_num, dumper->sample_num);", "e |= gf_dynstrcat(&args, szSubArgs, NULL);", "}", "remux = e ? NULL : gf_fs_load_filter(fsess, args, &e);", "if (!remux || e) {", "gf_fs_del(fsess);", "GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load stream->file filter\\n\"));", "if (args) gf_free(args);", "return e ? e : GF_FILTER_NOT_FOUND;", "}", "}", "else if (dumper->flags & GF_EXPORT_NHNT) {", "remux = gf_fs_load_filter(fsess, \"nhntw:exporter\", &e);", "if (!remux) {", "gf_fs_del(fsess);", "GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load NHNT write filter\\n\"));", "return e;", "}", "}", "else if (dumper->flags & GF_EXPORT_NHML) {", "e = gf_dynstrcat(&args, \"nhmlw:exporter:name=\", NULL);", "e |= gf_dynstrcat(&args, dumper->out_name, NULL);", "if (dumper->flags & GF_EXPORT_NHML_FULL)", "e |= gf_dynstrcat(&args, \":pckp\", NULL);", "if (dumper->dump_file) {", "sprintf(szSubArgs, \":nhmlonly:filep=%p\", dumper->dump_file);", "e |= gf_dynstrcat(&args, szSubArgs, NULL);", "}", "remux = e ? NULL : gf_fs_load_filter(fsess, args, &e);", "if (!remux || e) {", "gf_fs_del(fsess);", "if (args) gf_free(args);", "GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load NHML write filter\\n\"));", "return e ? e : GF_FILTER_NOT_FOUND;", "}", "} else if (!skip_write_filter) {", "e = gf_dynstrcat(&args, \"writegen:exporter\", NULL);", "if (ext_forced) {", "e |= gf_dynstrcat(&args, \":#Extension=\", NULL);", "e |= gf_dynstrcat(&args, szExt, NULL);", "}", "remux = e ? NULL : gf_fs_load_filter(fsess, args, &e);", "if (!remux) {", "gf_fs_del(fsess);", "if (args) gf_free(args);", "GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load stream->file filter\\n\"));", "return e;", "}", "}", "if (args) gf_free(args);", "args = NULL;", "e = gf_dynstrcat(&args, \"reframer:SID=1\", NULL);", "if (dumper->trackID) {", "sprintf(szSubArgs, \"#PID=%d\", dumper->trackID);", "e |= gf_dynstrcat(&args, szSubArgs, NULL);", "}", "e |= gf_dynstrcat(&args, \":exporter\", NULL);", "if (dumper->flags & GF_EXPORT_SVC_LAYER)", "e |= gf_dynstrcat(&args, \":extract=layer\", NULL);", "if (dumper->flags & GF_EXPORT_WEBVTT_NOMERGE)", "e |= gf_dynstrcat(&args, \":merge\", NULL);", "reframer = gf_fs_load_filter(fsess, args, &e);", "if (!reframer || e) {", "gf_fs_del(fsess);", "if (args) gf_free(args);", "GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load reframer filter\\n\"));", "return e ? e : GF_FILTER_NOT_FOUND;", "}", "if (args) gf_free(args);", "args = NULL;", "if (dumper->file) {", "e = gf_dynstrcat(&args, \"mp4dmx:FID=1:noedit:alltk:allt\", NULL);", "if (!e) {", "sprintf(szSubArgs, \":mov=%p\", dumper->file);", "e = gf_dynstrcat(&args, szSubArgs, NULL);", "}", "src_filter = gf_fs_load_filter(fsess, args, &e);", "gf_free(args);", "args = NULL;", "} else {", "src_filter = gf_fs_load_source(fsess, dumper->in_name, \"FID=1:noedit:alltk:allt\", NULL, &e);", "}", "if (!src_filter || e) {", "gf_fs_del(fsess);", "GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load filter for input file \\\"%s\\\": %s\\n\", dumper->in_name, gf_error_to_string(e) ));", "return e;", "}", "if (dumper->track_type) {", "const char *mtype = (dumper->track_type==1) ? \"video\" : \"audio\";", "if (dumper->trackID) {", "sprintf(szSubArgs, \"%s%d\", mtype, dumper->trackID);", "} else {", "sprintf(szSubArgs, \"%s\", mtype);", "}", "}", "else if (dumper->trackID) {", "sprintf(szSubArgs, \"PID=%d\", dumper->trackID);", "}", "if (remux) {", "gf_filter_set_source(file_out, remux, (dumper->trackID || dumper->track_type) ? szSubArgs : NULL);", "gf_filter_set_source(remux, reframer, (dumper->trackID || dumper->track_type) ? szSubArgs : NULL);", "} else {", "gf_filter_set_source(file_out, reframer, (dumper->trackID || dumper->track_type) ? szSubArgs : NULL);", "}", "e = gf_fs_run(fsess);", "if (e>GF_OK) e = GF_OK;", "if (!e) e = gf_fs_get_last_connect_error(fsess);", "if (!e) e = gf_fs_get_last_process_error(fsess);", "if (!e) {", "if (dumper->file)", "gf_fs_print_unused_args(fsess, NULL);", "else", "gf_fs_print_unused_args(fsess, \"alltk,allt,noedit\");", "}", "gf_fs_print_non_connected(fsess);", "if (dumper->print_stats_graph & 1) gf_fs_print_stats(fsess);", "if (dumper->print_stats_graph & 2) gf_fs_print_connections(fsess);", "gf_fs_del(fsess);", "return e;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static s32 gf_hevc_read_vps_bs_internal(GF_BitStream *bs, HEVCState *hevc, Bool stop_at_vps_ext)", "{", "u8 vps_sub_layer_ordering_info_present_flag, vps_extension_flag;", "u32 i, j;", "s32 vps_id;", "HEVC_VPS *vps;", "u8 layer_id_included_flag[MAX_LHVC_LAYERS][64];", "vps_id = gf_bs_read_int_log(bs, 4, \"vps_id\");", "if (vps_id >= 16) return -1;", "vps = &hevc->vps[vps_id];", "vps->bit_pos_vps_extensions = -1;", "if (!vps->state) {", "vps->id = vps_id;", "vps->state = 1;", "}", "vps->base_layer_internal_flag = gf_bs_read_int_log(bs, 1, \"base_layer_internal_flag\");", "vps->base_layer_available_flag = gf_bs_read_int_log(bs, 1, \"base_layer_available_flag\");", "vps->max_layers = 1 + gf_bs_read_int_log(bs, 6, \"max_layers_minus1\");", "if (vps->max_layers > MAX_LHVC_LAYERS) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] sorry, %d layers in VPS but only %d supported\\n\", vps->max_layers, MAX_LHVC_LAYERS));", "return -1;", "}", "vps->max_sub_layers = gf_bs_read_int_log(bs, 3, \"max_sub_layers_minus1\") + 1;", "vps->temporal_id_nesting = gf_bs_read_int_log(bs, 1, \"temporal_id_nesting\");", "gf_bs_read_int_log(bs, 16, \"vps_reserved_ffff_16bits\");", "hevc_profile_tier_level(bs, 1, vps->max_sub_layers - 1, &vps->ptl, 0);", "vps_sub_layer_ordering_info_present_flag = gf_bs_read_int_log(bs, 1, \"vps_sub_layer_ordering_info_present_flag\");", "for (i = (vps_sub_layer_ordering_info_present_flag ? 0 : vps->max_sub_layers - 1); i < vps->max_sub_layers; i++) {", "gf_bs_read_ue_log_idx(bs, \"vps_max_dec_pic_buffering_minus1\", i);", "gf_bs_read_ue_log_idx(bs, \"vps_max_num_reorder_pics\", i);", "gf_bs_read_ue_log_idx(bs, \"vps_max_latency_increase_plus1\", i);", "}", "vps->max_layer_id = gf_bs_read_int_log(bs, 6, \"max_layer_id\");", "if (vps->max_layer_id > MAX_LHVC_LAYERS) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] VPS max layer ID %u but GPAC only supports %u\\n\", vps->max_layer_id, MAX_LHVC_LAYERS));", "return -1;", "}", "vps->num_layer_sets = gf_bs_read_ue_log(bs, \"num_layer_sets_minus1\") + 1;", "if (vps->num_layer_sets > MAX_LHVC_LAYERS) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Wrong number of layer sets in VPS %d\\n\", vps->num_layer_sets));", "return -1;", "}", "for (i = 1; i < vps->num_layer_sets; i++) {", "for (j = 0; j <= vps->max_layer_id; j++) {", "layer_id_included_flag[i][j] = gf_bs_read_int_log_idx2(bs, 1, \"layer_id_included_flag\", i, j);", "}", "}", "vps->num_layers_in_id_list[0] = 1;", "for (i = 1; i < vps->num_layer_sets; i++) {", "u32 n, m;", "n = 0;", "for (m = 0; m <= vps->max_layer_id; m++) {", "if (layer_id_included_flag[i][m]) {", "vps->LayerSetLayerIdList[i][n++] = m;", "if (vps->LayerSetLayerIdListMax[i] < m)", "vps->LayerSetLayerIdListMax[i] = m;", "}", "}", "vps->num_layers_in_id_list[i] = n;", "}", "if (gf_bs_read_int_log(bs, 1, \"vps_timing_info_present_flag\")) {", "u32 vps_num_hrd_parameters;", "gf_bs_read_int_log(bs, 32, \"vps_num_units_in_tick\");", "gf_bs_read_int_log(bs, 32, \"vps_time_scale\");", "if (gf_bs_read_int_log(bs, 1, \"vps_poc_proportional_to_timing_flag\")) {", "gf_bs_read_ue_log(bs, \"vps_num_ticks_poc_diff_one_minus1\");", "}", "vps_num_hrd_parameters = gf_bs_read_ue_log(bs, \"vps_num_hrd_parameters\");", "for (i = 0; i < vps_num_hrd_parameters; i++) {", "Bool cprms_present_flag = GF_TRUE;", "gf_bs_read_ue_log_idx(bs, \"hrd_layer_set_idx\", i);", "if (i > 0)", "cprms_present_flag = gf_bs_read_int_log(bs, 1, \"cprms_present_flag\");", "hevc_parse_hrd_parameters(bs, cprms_present_flag, vps->max_sub_layers - 1, i);", "}", "}", "if (stop_at_vps_ext) {", "return vps_id;", "}", "vps_extension_flag = gf_bs_read_int_log(bs, 1, \"vps_extension_flag\");", "if (vps_extension_flag) {", "Bool res;", "gf_bs_align(bs);", "res = hevc_parse_vps_extension(vps, bs);", "if (res != GF_TRUE) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Failed to parse VPS extensions\\n\"));", "return -1;", "}", "if (gf_bs_read_int_log(bs, 1, \"vps_extension2_flag\")) {", "#if 0", "while (gf_bs_available(bs)) {", "gf_bs_read_int(bs, 1);", "}", "#endif", "}", "}", "return vps_id;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void TRI_InitV8ServerUtils(v8::Isolate* isolate) {", "TRI_AddGlobalFunctionVocbase(isolate,", "TRI_V8_ASCII_STRING(isolate, \"SYS_CLUSTER_API_JWT_POLICY\"), JS_ClusterApiJwtPolicy, true);", "TRI_AddGlobalFunctionVocbase(isolate,", "TRI_V8_ASCII_STRING(isolate, \"SYS_IS_FOXX_API_DISABLED\"), JS_IsFoxxApiDisabled, true);", "TRI_AddGlobalFunctionVocbase(isolate,", "TRI_V8_ASCII_STRING(isolate, \"SYS_IS_FOXX_STORE_DISABLED\"), JS_IsFoxxStoreDisabled, true);", "TRI_AddGlobalFunctionVocbase(isolate,", "TRI_V8_ASCII_STRING(isolate, \"SYS_RUN_IN_RESTRICTED_CONTEXT\"), JS_RunInRestrictedContext, true);", "TRI_AddGlobalFunctionVocbase(isolate,", "TRI_V8_ASCII_STRING(isolate,", "\"SYS_CREATE_HOTBACKUP\"),", "JS_CreateHotbackup);", "TRI_AddGlobalFunctionVocbase(isolate,", "TRI_V8_ASCII_STRING(isolate,", "\"SYS_DEBUG_CLEAR_FAILAT\"),", "JS_DebugClearFailAt);", "#ifdef ARANGODB_ENABLE_FAILURE_TESTS", "TRI_AddGlobalFunctionVocbase(", "isolate, TRI_V8_ASCII_STRING(isolate, \"SYS_DEBUG_TERMINATE\"), JS_DebugTerminate);", "TRI_AddGlobalFunctionVocbase(isolate,", "TRI_V8_ASCII_STRING(isolate,", "\"SYS_DEBUG_SET_FAILAT\"),", "JS_DebugSetFailAt);", "TRI_AddGlobalFunctionVocbase(isolate,", "TRI_V8_ASCII_STRING(isolate,", "\"SYS_DEBUG_REMOVE_FAILAT\"),", "JS_DebugRemoveFailAt);", "TRI_AddGlobalFunctionVocbase(isolate,", "TRI_V8_ASCII_STRING(isolate,", "\"SYS_DEBUG_SHOULD_FAILAT\"),", "JS_DebugShouldFailAt);", "#endif", "TRI_GET_GLOBALS();", "FoxxFeature& foxxFeature = v8g->_server.getFeature<FoxxFeature>();", "isolate->GetCurrentContext()", "->Global()", "->DefineOwnProperty(", "TRI_IGETC, TRI_V8_ASCII_STRING(isolate, \"FOXX_QUEUES_POLL_INTERVAL\"),", "v8::Number::New(isolate, foxxFeature.pollInterval()), v8::ReadOnly)", ".FromMaybe(false);", "isolate->GetCurrentContext()", "->Global()", "->DefineOwnProperty(", "TRI_IGETC,", "TRI_V8_ASCII_STRING(isolate, \"FOXX_STARTUP_WAIT_FOR_SELF_HEAL\"),", "v8::Boolean::New(isolate, foxxFeature.startupWaitForSelfHeal()), v8::ReadOnly)", ".FromMaybe(false);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int get_prop(int fd, uint32_t client_id, const char *name, void **value, size_t *size) {", "size_t msg_size = sizeof(struct vbg_ioctl_hgcm_call) + 4 * sizeof(struct vmmdev_hgcm_function_parameter64);", "struct vbg_ioctl_hgcm_call _cleanup_free_ *msg = calloc(1, msg_size);", "init_header(&msg->hdr, msg_size - sizeof(msg->hdr), msg_size - sizeof(msg->hdr));", "msg->client_id = client_id;", "msg->function = 1;", "msg->timeout_ms = -1;", "msg->interruptible = 1;", "msg->parm_count = 4;", "char ch;", "struct vmmdev_hgcm_function_parameter64 *params = (void *) (msg + 1);", "params[0].type = VMMDEV_HGCM_PARM_TYPE_LINADDR_IN;", "params[0].u.pointer.size = strlen(name) + 1;", "params[0].u.pointer.u.linear_addr = (uintptr_t) name;", "params[1].type = VMMDEV_HGCM_PARM_TYPE_LINADDR;", "params[1].u.pointer.size = 1;", "params[1].u.pointer.u.linear_addr = (uintptr_t) &ch;", "params[2].type = VMMDEV_HGCM_PARM_TYPE_64BIT;", "params[3].type = VMMDEV_HGCM_PARM_TYPE_32BIT;", "if (ioctl(fd, VBG_IOCTL_HGCM_CALL_64(msg_size), msg)) {", "return VERR_GENERAL_FAILURE;", "}", "switch (msg->hdr.rc) {", "case VINF_SUCCESS:", "case VERR_BUFFER_OVERFLOW:", ";", "size_t buf_size = params[3].u.value32;", "void _cleanup_free_ *buf = malloc(buf_size);", "params[1].u.pointer.size = buf_size;", "params[1].u.pointer.u.linear_addr = (uintptr_t) buf;", "if (ioctl(fd, VBG_IOCTL_HGCM_CALL_64(msg_size), msg)) {", "return VERR_GENERAL_FAILURE;", "}", "if (msg->hdr.rc != VINF_SUCCESS) {", "return msg->hdr.rc;", "}", "*value = buf;", "buf = NULL;", "*size = buf_size;", "return VINF_SUCCESS;", "case VERR_NOT_FOUND:", "*value = NULL;", "*size = 0;", "return VINF_SUCCESS;", "default:", "return msg->hdr.rc;", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["exif_mnote_data_pentax_load (ExifMnoteData *en,", "const unsigned char *buf, unsigned int buf_size)", "{", "ExifMnoteDataPentax *n = (ExifMnoteDataPentax *) en;", "size_t i, tcount, o, datao, base = 0;", "ExifShort c;", "if (!n || !buf || !buf_size) {", "exif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,", "\"ExifMnoteDataPentax\", \"Short MakerNote\");", "return;", "}", "datao = 6 + n->offset;", "if (CHECKOVERFLOW(datao, buf_size, 8)) {", "exif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,", "\"ExifMnoteDataPentax\", \"Short MakerNote\");", "return;", "}", "if (!memcmp(buf + datao, \"AOC\", 4)) {", "if ((buf[datao + 4] == 'I') && (buf[datao + 5] == 'I')) {", "n->version = pentaxV3;", "n->order = EXIF_BYTE_ORDER_INTEL;", "} else if ((buf[datao + 4] == 'M') && (buf[datao + 5] == 'M')) {", "n->version = pentaxV3;", "n->order = EXIF_BYTE_ORDER_MOTOROLA;", "} else {", "n->version = pentaxV2;", "}", "exif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataPentax\",", "\"Parsing Pentax maker note v%d...\", (int)n->version);", "datao += 4 + 2;", "base = MNOTE_PENTAX2_TAG_BASE;", "} else if (!memcmp(buf + datao, \"QVC\", 4)) {", "exif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataPentax\",", "\"Parsing Casio maker note v2...\");", "n->version = casioV2;", "base = MNOTE_CASIO2_TAG_BASE;", "datao += 4 + 2;", "} else {", "exif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataPentax\",", "\"Parsing Pentax maker note v1...\");", "n->version = pentaxV1;", "}", "c = exif_get_short (buf + datao, n->order);", "datao += 2;", "exif_mnote_data_pentax_clear (n);", "n->entries = exif_mem_alloc (en->mem, sizeof (MnotePentaxEntry) * c);", "if (!n->entries) {", "EXIF_LOG_NO_MEMORY(en->log, \"ExifMnoteDataPentax\", sizeof (MnotePentaxEntry) * c);", "return;", "}", "tcount = 0;", "for (i = c, o = datao; i; --i, o += 12) {", "size_t s;", "if (CHECKOVERFLOW(o,buf_size,12)) {", "exif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,", "\"ExifMnoteDataPentax\", \"Short MakerNote\");", "break;", "}", "n->entries[tcount].tag        = exif_get_short (buf + o + 0, n->order) + base;", "n->entries[tcount].format     = exif_get_short (buf + o + 2, n->order);", "n->entries[tcount].components = exif_get_long  (buf + o + 4, n->order);", "n->entries[tcount].order      = n->order;", "exif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnotePentax\",", "\"Loading entry 0x%x ('%s')...\", n->entries[tcount].tag,", "mnote_pentax_tag_get_name (n->entries[tcount].tag));", "if ( exif_format_get_size (n->entries[tcount].format) &&", "buf_size / exif_format_get_size (n->entries[tcount].format) < n->entries[tcount].components", ") {", "exif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,", "\"ExifMnoteDataPentax\", \"Tag size overflow detected (%u * %lu)\", exif_format_get_size (n->entries[tcount].format), n->entries[tcount].components);", "break;", "}", "s = exif_format_get_size (n->entries[tcount].format) *", "n->entries[tcount].components;", "n->entries[tcount].size = s;", "if (s) {", "size_t dataofs = o + 8;", "if (s > 4)", "dataofs = exif_get_long (buf + dataofs, n->order) + 6;", "if (CHECKOVERFLOW(dataofs, buf_size, s)) {", "exif_log (en->log, EXIF_LOG_CODE_DEBUG,", "\"ExifMnoteDataPentax\", \"Tag data past end \"", "\"of buffer (%u > %u)\", (unsigned)(dataofs + s), buf_size);", "continue;", "}", "n->entries[tcount].data = exif_mem_alloc (en->mem, s);", "if (!n->entries[tcount].data) {", "EXIF_LOG_NO_MEMORY(en->log, \"ExifMnoteDataPentax\", s);", "continue;", "}", "memcpy (n->entries[tcount].data, buf + dataofs, s);", "}", "++tcount;", "}", "n->count = tcount;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void dostor(char *name, const int append, const int autorename)", "{", "ULHandler ulhandler;", "int f;", "const char *ul_name = NULL;", "const char *atomic_file = NULL;", "off_t filesize = (off_t) 0U;", "struct stat st;", "double started = 0.0;", "signed char overwrite = 0;", "int overflow = 0;", "int ret = -1;", "off_t max_filesize = (off_t) -1;", "#ifdef QUOTAS", "Quota quota;", "#endif", "const char *name2 = NULL;", "if (type < 1 || (type == 1 && restartat > (off_t) 1)) {", "addreply_noformat(503, MSG_NO_ASCII_RESUME);", "goto end;", "}", "#ifndef ANON_CAN_RESUME", "if (guest != 0 && anon_noupload != 0) {", "addreply_noformat(550, MSG_ANON_CANT_OVERWRITE);", "goto end;", "}", "#endif", "if (ul_check_free_space(name, -1.0) == 0) {", "addreply_noformat(552, MSG_NO_DISK_SPACE);", "goto end;", "}", "if (checknamesanity(name, dot_write_ok) != 0) {", "addreply(553, MSG_SANITY_FILE_FAILURE, name);", "goto end;", "}", "if (autorename != 0) {", "no_truncate = 1;", "}", "if (restartat > (off_t) 0 || no_truncate != 0) {", "if ((atomic_file = get_atomic_file(name)) == NULL) {", "addreply(553, MSG_SANITY_FILE_FAILURE, name);", "goto end;", "}", "if (restartat > (off_t) 0 &&", "rename(name, atomic_file) != 0 && errno != ENOENT) {", "error(553, MSG_RENAME_FAILURE);", "atomic_file = NULL;", "goto end;", "}", "}", "if (atomic_file != NULL) {", "ul_name = atomic_file;", "} else {", "ul_name = name;", "}", "if (atomic_file == NULL &&", "(f = open(ul_name, O_WRONLY | O_NOFOLLOW)) != -1) {", "overwrite++;", "} else if ((f = open(ul_name, O_CREAT | O_WRONLY | O_NOFOLLOW,", "(mode_t) 0777 & ~u_mask)) == -1) {", "error(553, MSG_OPEN_FAILURE2);", "goto end;", "}", "if (fstat(f, &st) < 0) {", "(void) close(f);", "error(553, MSG_STAT_FAILURE2);", "goto end;", "}", "if (!S_ISREG(st.st_mode)) {", "(void) close(f);", "addreply_noformat(550, MSG_NOT_REGULAR_FILE);", "goto end;", "}", "alarm(MAX_SESSION_XFER_IDLE);", "if (st.st_size > (off_t) 0) {", "#ifndef ANON_CAN_RESUME", "if (guest != 0) {", "addreply_noformat(550, MSG_ANON_CANT_OVERWRITE);", "(void) close(f);", "goto end;", "}", "#endif", "if (append != 0) {", "restartat = st.st_size;", "}", "} else {", "restartat = (off_t) 0;", "}", "if (restartat > st.st_size) {", "restartat = st.st_size;", "}", "if (restartat > (off_t) 0 && lseek(f, restartat, SEEK_SET) < (off_t) 0) {", "(void) close(f);", "error(451, \"seek\");", "goto end;", "}", "if (restartat < st.st_size) {", "if (ftruncate(f, restartat) < 0) {", "(void) close(f);", "error(451, \"ftruncate\");", "goto end;", "}", "#ifdef QUOTAS", "if (restartat != st.st_size) {", "(void) quota_update(NULL, 0LL,", "(long long) (restartat - st.st_size),", "&overflow);", "}", "#endif", "}", "#ifdef QUOTAS", "if (quota_update(&quota, 0LL, 0LL, &overflow) == 0 &&", "(overflow > 0 || quota.files >= user_quota_files ||", "quota.size > user_quota_size ||", "(max_filesize >= (off_t) 0 &&", "(max_filesize = user_quota_size - quota.size) < (off_t) 0))) {", "overflow = 1;", "(void) close(f);", "goto afterquota;", "}", "#endif", "opendata();", "if (xferfd == -1) {", "(void) close(f);", "goto end;", "}", "doreply();", "# ifdef WITH_TLS", "if (data_protection_level == CPL_PRIVATE) {", "tls_init_data_session(xferfd, passive);", "}", "# endif", "state_needs_update = 1;", "setprocessname(\"pure-ftpd (UPLOAD)\");", "filesize = restartat;", "#ifdef FTPWHO", "if (shm_data_cur != NULL) {", "const size_t sl = strlen(name);", "ftpwho_lock();", "shm_data_cur->state = FTPWHO_STATE_UPLOAD;", "shm_data_cur->download_total_size = (off_t) 0U;", "shm_data_cur->download_current_size = (off_t) filesize;", "shm_data_cur->restartat = restartat;", "(void) time(&shm_data_cur->xfer_date);", "if (sl < sizeof shm_data_cur->filename) {", "memcpy(shm_data_cur->filename, name, sl);", "shm_data_cur->filename[sl] = 0;", "} else {", "memcpy(shm_data_cur->filename,", "&name[sl - sizeof shm_data_cur->filename - 1U],", "sizeof shm_data_cur->filename);", "}", "ftpwho_unlock();", "}", "#endif", "started = get_usec_time();", "if (ul_init(&ulhandler, clientfd, tls_cnx, xferfd, name, f, tls_data_cnx,", "restartat, type == 1, throttling_bandwidth_ul,", "max_filesize) == 0) {", "ret = ul_send(&ulhandler);", "ul_exit(&ulhandler);", "} else {", "ret = -1;", "}", "(void) close(f);", "closedata();", "#ifdef SHOW_REAL_DISK_SPACE", "if (FSTATFS(f, &statfsbuf) == 0) {", "double space;", "space = (double) STATFS_BAVAIL(statfsbuf) *", "(double) STATFS_FRSIZE(statfsbuf);", "if (space > 524288.0) {", "addreply(0, MSG_SPACE_FREE_M, space / 1048576.0);", "} else {", "addreply(0, MSG_SPACE_FREE_K, space / 1024.0);", "}", "}", "#endif", "uploaded += (unsigned long long) ulhandler.total_uploaded;", "{", "off_t atomic_file_size;", "off_t original_file_size;", "int files_count;", "if (overwrite == 0) {", "files_count = 1;", "} else {", "files_count = 0;", "}", "if (autorename != 0 && restartat == (off_t) 0) {", "if ((atomic_file_size = get_file_size(atomic_file)) < (off_t) 0) {", "goto afterquota;", "}", "if (tryautorename(atomic_file, name, &name2) != 0) {", "error(553, MSG_RENAME_FAILURE);", "goto afterquota;", "} else {", "#ifdef QUOTAS", "ul_quota_update(name2 ? name2 : name, 1, atomic_file_size);", "#endif", "atomic_file = NULL;", "}", "} else if (atomic_file != NULL) {", "if ((atomic_file_size = get_file_size(atomic_file)) < (off_t) 0) {", "goto afterquota;", "}", "if ((original_file_size = get_file_size(name)) < (off_t) 0 ||", "restartat > original_file_size) {", "original_file_size = restartat;", "}", "if (rename(atomic_file, name) != 0) {", "error(553, MSG_RENAME_FAILURE);", "goto afterquota;", "} else {", "#ifdef QUOTAS", "overflow = ul_quota_update", "(name, files_count, atomic_file_size - original_file_size);", "#endif", "atomic_file = NULL;", "}", "} else {", "#ifdef QUOTAS", "overflow = ul_quota_update", "(name, files_count, ulhandler.total_uploaded);", "#endif", "}", "}", "afterquota:", "if (overflow > 0) {", "addreply(552, MSG_QUOTA_EXCEEDED, name);", "} else {", "if (ret == 0) {", "addreply_noformat(226, MSG_TRANSFER_SUCCESSFUL);", "} else {", "addreply_noformat(451, MSG_ABORTED);", "}", "displayrate(MSG_UPLOADED, ulhandler.total_uploaded, started,", "name2 ? name2 : name, 1);", "}", "end:", "restartat = (off_t) 0;", "if (atomic_file != NULL) {", "unlink(atomic_file);", "atomic_file = NULL;", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["next_state_class(CClassNode* cc, OnigCodePoint* vs, enum CCVALTYPE* type,", "enum CCSTATE* state, ScanEnv* env)", "{", "int r;", "if (*state == CCS_RANGE)", "return ONIGERR_CHAR_CLASS_VALUE_AT_END_OF_RANGE;", "if (*state == CCS_VALUE && *type != CCV_CLASS) {", "if (*type == CCV_SB)", "BITSET_SET_BIT(cc->bs, (int )(*vs));", "else if (*type == CCV_CODE_POINT) {", "r = add_code_range(&(cc->mbuf), env, *vs, *vs);", "if (r < 0) return r;", "}", "}", "*state = CCS_VALUE;", "*type  = CCV_CLASS;", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["srs_timestamp_check(srs_t *srs, const char *stamp)", "{", "const char *sp;", "char  *bp;", "int    off;", "time_t   now;", "time_t   then;", "then = 0;", "for (sp = stamp; *sp; sp++) {", "bp = strchr(SRS_TIME_BASECHARS, toupper(*sp));", "if (bp == NULL)", "return SRS_EBADTIMESTAMPCHAR;", "off = bp - SRS_TIME_BASECHARS;", "then = (then << SRS_TIME_BASEBITS) | off;", "}", "time(&now);", "now = (now / SRS_TIME_PRECISION) % SRS_TIME_SLOTS;", "while (now < then)", "now = now + SRS_TIME_SLOTS;", "if (now <= then + srs->maxage)", "return SRS_SUCCESS;", "return SRS_ETIMESTAMPOUTOFDATE;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static SQInteger thread_call(HSQUIRRELVM v)", "{", "SQObjectPtr o = stack_get(v,1);", "if(sq_type(o) == OT_THREAD) {", "SQInteger nparams = sq_gettop(v);", "_thread(o)->Push(_thread(o)->_roottable);", "for(SQInteger i = 2; i<(nparams+1); i++)", "sq_move(_thread(o),v,i);", "if(SQ_SUCCEEDED(sq_call(_thread(o),nparams,SQTrue,SQTrue))) {", "sq_move(v,_thread(o),-1);", "sq_pop(_thread(o),1);", "return 1;", "}", "v->_lasterror = _thread(o)->_lasterror;", "return SQ_ERROR;", "}", "return sq_throwerror(v,_SC(\"wrong parameter\"));", "}"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["PHPAPI int php_swoole_unserialize(void *buffer, size_t len, zval *return_value, zval *object_args, long flag)", "{", "SBucketType type = *(SBucketType*) (buffer);", "zend_uchar real_type = type.data_type;", "buffer += sizeof (SBucketType);", "switch (real_type)", "{", "case IS_NULL:", "case IS_TRUE:", "case IS_FALSE:", "Z_TYPE_INFO_P(return_value) = real_type;", "break;", "case IS_LONG:", "swoole_unserialize_long(buffer, return_value, type);", "Z_TYPE_INFO_P(return_value) = real_type;", "break;", "case IS_DOUBLE:", "swoole_unserialize_raw(buffer, return_value);", "Z_TYPE_INFO_P(return_value) = real_type;", "break;", "case IS_STRING:", "len -= sizeof (SBucketType);", "zend_string *str = swoole_unserialize_string(buffer, len);", "ZVAL_STR(return_value, str);", "break;", "case IS_ARRAY:", "{", "if (swoole_seria_check_eof(buffer, len) < 0)", "{", "php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"detect the error eof\");", "return SW_FALSE;", "}", "unser_start = buffer - sizeof (SBucketType);", "uint32_t num = 0;", "buffer = get_array_real_len(buffer, type.data_len, &num);", "if (!swoole_unserialize_arr(buffer, return_value, num, flag))", "{", "return SW_FALSE;", "}", "break;", "}", "case IS_UNDEF:", "if (swoole_seria_check_eof(buffer, len) < 0)", "{", "php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"detect the error eof\");", "return SW_FALSE;", "}", "unser_start = buffer - sizeof (SBucketType);", "if (!swoole_unserialize_object(buffer, return_value, type.data_len, object_args, flag))", "{", "return SW_FALSE;", "}", "break;", "default:", "php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"the type is not supported by swoole serialize.\");", "return SW_FALSE;", "}", "return SW_TRUE;", "}"], "ner_tags": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["archive_string_append_from_wcs(struct archive_string *as,", "const wchar_t *w, size_t len)", "{", "int n, ret_val = 0;", "char *p;", "char *end;", "#if HAVE_WCRTOMB", "mbstate_t shift_state;", "memset(&shift_state, 0, sizeof(shift_state));", "#else", "wctomb(NULL, L'\\0');", "#endif", "if (archive_string_ensure(as, as->length + len + 1) == NULL)", "return (-1);", "p = as->s + as->length;", "end = as->s + as->buffer_length - MB_CUR_MAX -1;", "while (*w != L'\\0' && len > 0) {", "if (p >= end) {", "as->length = p - as->s;", "as->s[as->length] = '\\0';", "if (archive_string_ensure(as,", "as->length + len * 2 + 1) == NULL)", "return (-1);", "p = as->s + as->length;", "end = as->s + as->buffer_length - MB_CUR_MAX -1;", "}", "#if HAVE_WCRTOMB", "n = wcrtomb(p, *w++, &shift_state);", "#else", "n = wctomb(p, *w++);", "#endif", "if (n == -1) {", "if (errno == EILSEQ) {", "*p++ = '?';", "ret_val = -1;", "} else {", "ret_val = -1;", "break;", "}", "} else", "p += n;", "len--;", "}", "as->length = p - as->s;", "as->s[as->length] = '\\0';", "return (ret_val);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame,", "AVPacket *avpkt)", "{", "const uint8_t *buf = avpkt->data;", "int buf_size = avpkt->size;", "UtvideoContext *c = avctx->priv_data;", "int i, j;", "const uint8_t *plane_start[5];", "int plane_size, max_slice_size = 0, slice_start, slice_end, slice_size;", "int ret;", "GetByteContext gb;", "ThreadFrame frame = { .f = data };", "if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0)", "return ret;", "bytestream2_init(&gb, buf, buf_size);", "if (c->pro) {", "if (bytestream2_get_bytes_left(&gb) < c->frame_info_size) {", "av_log(avctx, AV_LOG_ERROR, \"Not enough data for frame information\\n\");", "return AVERROR_INVALIDDATA;", "}", "c->frame_info = bytestream2_get_le32u(&gb);", "c->slices = ((c->frame_info >> 16) & 0xff) + 1;", "for (i = 0; i < c->planes; i++) {", "plane_start[i] = gb.buffer;", "if (bytestream2_get_bytes_left(&gb) < 1024 + 4 * c->slices) {", "av_log(avctx, AV_LOG_ERROR, \"Insufficient data for a plane\\n\");", "return AVERROR_INVALIDDATA;", "}", "slice_start = 0;", "slice_end   = 0;", "for (j = 0; j < c->slices; j++) {", "slice_end   = bytestream2_get_le32u(&gb);", "if (slice_end < 0 || slice_end < slice_start ||", "bytestream2_get_bytes_left(&gb) < slice_end) {", "av_log(avctx, AV_LOG_ERROR, \"Incorrect slice size\\n\");", "return AVERROR_INVALIDDATA;", "}", "slice_size  = slice_end - slice_start;", "slice_start = slice_end;", "max_slice_size = FFMAX(max_slice_size, slice_size);", "}", "plane_size = slice_end;", "bytestream2_skipu(&gb, plane_size);", "bytestream2_skipu(&gb, 1024);", "}", "plane_start[c->planes] = gb.buffer;", "} else {", "for (i = 0; i < c->planes; i++) {", "plane_start[i] = gb.buffer;", "if (bytestream2_get_bytes_left(&gb) < 256 + 4 * c->slices) {", "av_log(avctx, AV_LOG_ERROR, \"Insufficient data for a plane\\n\");", "return AVERROR_INVALIDDATA;", "}", "bytestream2_skipu(&gb, 256);", "slice_start = 0;", "slice_end   = 0;", "for (j = 0; j < c->slices; j++) {", "slice_end   = bytestream2_get_le32u(&gb);", "if (slice_end < 0 || slice_end < slice_start ||", "bytestream2_get_bytes_left(&gb) < slice_end) {", "av_log(avctx, AV_LOG_ERROR, \"Incorrect slice size\\n\");", "return AVERROR_INVALIDDATA;", "}", "slice_size  = slice_end - slice_start;", "slice_start = slice_end;", "max_slice_size = FFMAX(max_slice_size, slice_size);", "}", "plane_size = slice_end;", "bytestream2_skipu(&gb, plane_size);", "}", "plane_start[c->planes] = gb.buffer;", "if (bytestream2_get_bytes_left(&gb) < c->frame_info_size) {", "av_log(avctx, AV_LOG_ERROR, \"Not enough data for frame information\\n\");", "return AVERROR_INVALIDDATA;", "}", "c->frame_info = bytestream2_get_le32u(&gb);", "}", "av_log(avctx, AV_LOG_DEBUG, \"frame information flags %\"PRIX32\"\\n\",", "c->frame_info);", "c->frame_pred = (c->frame_info >> 8) & 3;", "if (c->frame_pred == PRED_GRADIENT) {", "avpriv_request_sample(avctx, \"Frame with gradient prediction\");", "return AVERROR_PATCHWELCOME;", "}", "av_fast_malloc(&c->slice_bits, &c->slice_bits_size,", "max_slice_size + AV_INPUT_BUFFER_PADDING_SIZE);", "if (!c->slice_bits) {", "av_log(avctx, AV_LOG_ERROR, \"Cannot allocate temporary buffer\\n\");", "return AVERROR(ENOMEM);", "}", "switch (c->avctx->pix_fmt) {", "case AV_PIX_FMT_RGB24:", "case AV_PIX_FMT_RGBA:", "for (i = 0; i < c->planes; i++) {", "ret = decode_plane(c, i, frame.f->data[0] + ff_ut_rgb_order[i],", "c->planes, frame.f->linesize[0], avctx->width,", "avctx->height, plane_start[i],", "c->frame_pred == PRED_LEFT);", "if (ret)", "return ret;", "if (c->frame_pred == PRED_MEDIAN) {", "if (!c->interlaced) {", "restore_median(frame.f->data[0] + ff_ut_rgb_order[i],", "c->planes, frame.f->linesize[0], avctx->width,", "avctx->height, c->slices, 0);", "} else {", "restore_median_il(frame.f->data[0] + ff_ut_rgb_order[i],", "c->planes, frame.f->linesize[0],", "avctx->width, avctx->height, c->slices,", "0);", "}", "}", "}", "restore_rgb_planes(frame.f->data[0], c->planes, frame.f->linesize[0],", "avctx->width, avctx->height);", "break;", "case AV_PIX_FMT_GBRAP10:", "case AV_PIX_FMT_GBRP10:", "for (i = 0; i < c->planes; i++) {", "ret = decode_plane10(c, i, (uint16_t *)frame.f->data[i], 1,", "frame.f->linesize[i] / 2, avctx->width,", "avctx->height, plane_start[i],", "plane_start[i + 1] - 1024,", "c->frame_pred == PRED_LEFT);", "if (ret)", "return ret;", "}", "restore_rgb_planes10(frame.f, avctx->width, avctx->height);", "break;", "case AV_PIX_FMT_YUV420P:", "for (i = 0; i < 3; i++) {", "ret = decode_plane(c, i, frame.f->data[i], 1, frame.f->linesize[i],", "avctx->width >> !!i, avctx->height >> !!i,", "plane_start[i], c->frame_pred == PRED_LEFT);", "if (ret)", "return ret;", "if (c->frame_pred == PRED_MEDIAN) {", "if (!c->interlaced) {", "restore_median(frame.f->data[i], 1, frame.f->linesize[i],", "avctx->width >> !!i, avctx->height >> !!i,", "c->slices, !i);", "} else {", "restore_median_il(frame.f->data[i], 1, frame.f->linesize[i],", "avctx->width  >> !!i,", "avctx->height >> !!i,", "c->slices, !i);", "}", "}", "}", "break;", "case AV_PIX_FMT_YUV422P:", "for (i = 0; i < 3; i++) {", "ret = decode_plane(c, i, frame.f->data[i], 1, frame.f->linesize[i],", "avctx->width >> !!i, avctx->height,", "plane_start[i], c->frame_pred == PRED_LEFT);", "if (ret)", "return ret;", "if (c->frame_pred == PRED_MEDIAN) {", "if (!c->interlaced) {", "restore_median(frame.f->data[i], 1, frame.f->linesize[i],", "avctx->width >> !!i, avctx->height,", "c->slices, 0);", "} else {", "restore_median_il(frame.f->data[i], 1, frame.f->linesize[i],", "avctx->width >> !!i, avctx->height,", "c->slices, 0);", "}", "}", "}", "break;", "case AV_PIX_FMT_YUV444P:", "for (i = 0; i < 3; i++) {", "ret = decode_plane(c, i, frame.f->data[i], 1, frame.f->linesize[i],", "avctx->width, avctx->height,", "plane_start[i], c->frame_pred == PRED_LEFT);", "if (ret)", "return ret;", "if (c->frame_pred == PRED_MEDIAN) {", "if (!c->interlaced) {", "restore_median(frame.f->data[i], 1, frame.f->linesize[i],", "avctx->width, avctx->height,", "c->slices, 0);", "} else {", "restore_median_il(frame.f->data[i], 1, frame.f->linesize[i],", "avctx->width, avctx->height,", "c->slices, 0);", "}", "}", "}", "break;", "case AV_PIX_FMT_YUV422P10:", "for (i = 0; i < 3; i++) {", "ret = decode_plane10(c, i, (uint16_t *)frame.f->data[i], 1, frame.f->linesize[i] / 2,", "avctx->width >> !!i, avctx->height,", "plane_start[i], plane_start[i + 1] - 1024, c->frame_pred == PRED_LEFT);", "if (ret)", "return ret;", "}", "break;", "}", "frame.f->key_frame = 1;", "frame.f->pict_type = AV_PICTURE_TYPE_I;", "frame.f->interlaced_frame = !!c->interlaced;", "*got_frame = 1;", "return buf_size;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void sqlite3Pragma(", "Parse *pParse,", "Token *pId1,", "Token *pId2,", "Token *pValue,", "int minusFlag", "){", "char *zLeft = 0;", "char *zRight = 0;", "const char *zDb = 0;", "Token *pId;", "char *aFcntl[4];", "int iDb;", "int rc;", "sqlite3 *db = pParse->db;", "Db *pDb;", "Vdbe *v = sqlite3GetVdbe(pParse);", "const PragmaName *pPragma;", "if( v==0 ) return;", "sqlite3VdbeRunOnlyOnce(v);", "pParse->nMem = 2;", "iDb = sqlite3TwoPartName(pParse, pId1, pId2, &pId);", "if( iDb<0 ) return;", "pDb = &db->aDb[iDb];", "if( iDb==1 && sqlite3OpenTempDatabase(pParse) ){", "return;", "}", "zLeft = sqlite3NameFromToken(db, pId);", "if( !zLeft ) return;", "if( minusFlag ){", "zRight = sqlite3MPrintf(db, \"-%T\", pValue);", "}else{", "zRight = sqlite3NameFromToken(db, pValue);", "}", "assert( pId2 );", "zDb = pId2->n>0 ? pDb->zDbSName : 0;", "if( sqlite3AuthCheck(pParse, SQLITE_PRAGMA, zLeft, zRight, zDb) ){", "goto pragma_out;", "}", "aFcntl[0] = 0;", "aFcntl[1] = zLeft;", "aFcntl[2] = zRight;", "aFcntl[3] = 0;", "db->busyHandler.nBusy = 0;", "rc = sqlite3_file_control(db, zDb, SQLITE_FCNTL_PRAGMA, (void*)aFcntl);", "if( rc==SQLITE_OK ){", "sqlite3VdbeSetNumCols(v, 1);", "sqlite3VdbeSetColName(v, 0, COLNAME_NAME, aFcntl[0], SQLITE_TRANSIENT);", "returnSingleText(v, aFcntl[0]);", "sqlite3_free(aFcntl[0]);", "goto pragma_out;", "}", "if( rc!=SQLITE_NOTFOUND ){", "if( aFcntl[0] ){", "sqlite3ErrorMsg(pParse, \"%s\", aFcntl[0]);", "sqlite3_free(aFcntl[0]);", "}", "pParse->nErr++;", "pParse->rc = rc;", "goto pragma_out;", "}", "pPragma = pragmaLocate(zLeft);", "if( pPragma==0 ) goto pragma_out;", "if( (pPragma->mPragFlg & PragFlg_NeedSchema)!=0 ){", "if( sqlite3ReadSchema(pParse) ) goto pragma_out;", "}", "if( (pPragma->mPragFlg & PragFlg_NoColumns)==0", "&& ((pPragma->mPragFlg & PragFlg_NoColumns1)==0 || zRight==0)", "){", "setPragmaResultColumnNames(v, pPragma);", "}", "switch( pPragma->ePragTyp ){", "#if !defined(SQLITE_OMIT_PAGER_PRAGMAS) && !defined(SQLITE_OMIT_DEPRECATED)", "case PragTyp_DEFAULT_CACHE_SIZE: {", "static const int iLn = VDBE_OFFSET_LINENO(2);", "static const VdbeOpList getCacheSize[] = {", "{ OP_Transaction, 0, 0,        0},", "{ OP_ReadCookie,  0, 1,        BTREE_DEFAULT_CACHE_SIZE},", "{ OP_IfPos,       1, 8,        0},", "{ OP_Integer,     0, 2,        0},", "{ OP_Subtract,    1, 2,        1},", "{ OP_IfPos,       1, 8,        0},", "{ OP_Integer,     0, 1,        0},", "{ OP_Noop,        0, 0,        0},", "{ OP_ResultRow,   1, 1,        0},", "};", "VdbeOp *aOp;", "sqlite3VdbeUsesBtree(v, iDb);", "if( !zRight ){", "pParse->nMem += 2;", "sqlite3VdbeVerifyNoMallocRequired(v, ArraySize(getCacheSize));", "aOp = sqlite3VdbeAddOpList(v, ArraySize(getCacheSize), getCacheSize, iLn);", "if( ONLY_IF_REALLOC_STRESS(aOp==0) ) break;", "aOp[0].p1 = iDb;", "aOp[1].p1 = iDb;", "aOp[6].p1 = SQLITE_DEFAULT_CACHE_SIZE;", "}else{", "int size = sqlite3AbsInt32(sqlite3Atoi(zRight));", "sqlite3BeginWriteOperation(pParse, 0, iDb);", "sqlite3VdbeAddOp3(v, OP_SetCookie, iDb, BTREE_DEFAULT_CACHE_SIZE, size);", "assert( sqlite3SchemaMutexHeld(db, iDb, 0) );", "pDb->pSchema->cache_size = size;", "sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size);", "}", "break;", "}", "#endif /* !SQLITE_OMIT_PAGER_PRAGMAS && !SQLITE_OMIT_DEPRECATED */", "#if !defined(SQLITE_OMIT_PAGER_PRAGMAS)", "case PragTyp_PAGE_SIZE: {", "Btree *pBt = pDb->pBt;", "assert( pBt!=0 );", "if( !zRight ){", "int size = ALWAYS(pBt) ? sqlite3BtreeGetPageSize(pBt) : 0;", "returnSingleInt(v, size);", "}else{", "db->nextPagesize = sqlite3Atoi(zRight);", "if( SQLITE_NOMEM==sqlite3BtreeSetPageSize(pBt, db->nextPagesize,-1,0) ){", "sqlite3OomFault(db);", "}", "}", "break;", "}", "case PragTyp_SECURE_DELETE: {", "Btree *pBt = pDb->pBt;", "int b = -1;", "assert( pBt!=0 );", "if( zRight ){", "if( sqlite3_stricmp(zRight, \"fast\")==0 ){", "b = 2;", "}else{", "b = sqlite3GetBoolean(zRight, 0);", "}", "}", "if( pId2->n==0 && b>=0 ){", "int ii;", "for(ii=0; ii<db->nDb; ii++){", "sqlite3BtreeSecureDelete(db->aDb[ii].pBt, b);", "}", "}", "b = sqlite3BtreeSecureDelete(pBt, b);", "returnSingleInt(v, b);", "break;", "}", "case PragTyp_PAGE_COUNT: {", "int iReg;", "sqlite3CodeVerifySchema(pParse, iDb);", "iReg = ++pParse->nMem;", "if( sqlite3Tolower(zLeft[0])=='p' ){", "sqlite3VdbeAddOp2(v, OP_Pagecount, iDb, iReg);", "}else{", "sqlite3VdbeAddOp3(v, OP_MaxPgcnt, iDb, iReg,", "sqlite3AbsInt32(sqlite3Atoi(zRight)));", "}", "sqlite3VdbeAddOp2(v, OP_ResultRow, iReg, 1);", "break;", "}", "case PragTyp_LOCKING_MODE: {", "const char *zRet = \"normal\";", "int eMode = getLockingMode(zRight);", "if( pId2->n==0 && eMode==PAGER_LOCKINGMODE_QUERY ){", "eMode = db->dfltLockMode;", "}else{", "Pager *pPager;", "if( pId2->n==0 ){", "int ii;", "assert(pDb==&db->aDb[0]);", "for(ii=2; ii<db->nDb; ii++){", "pPager = sqlite3BtreePager(db->aDb[ii].pBt);", "sqlite3PagerLockingMode(pPager, eMode);", "}", "db->dfltLockMode = (u8)eMode;", "}", "pPager = sqlite3BtreePager(pDb->pBt);", "eMode = sqlite3PagerLockingMode(pPager, eMode);", "}", "assert( eMode==PAGER_LOCKINGMODE_NORMAL", "|| eMode==PAGER_LOCKINGMODE_EXCLUSIVE );", "if( eMode==PAGER_LOCKINGMODE_EXCLUSIVE ){", "zRet = \"exclusive\";", "}", "returnSingleText(v, zRet);", "break;", "}", "case PragTyp_JOURNAL_MODE: {", "int eMode;", "int ii;", "if( zRight==0 ){", "eMode = PAGER_JOURNALMODE_QUERY;", "}else{", "const char *zMode;", "int n = sqlite3Strlen30(zRight);", "for(eMode=0; (zMode = sqlite3JournalModename(eMode))!=0; eMode++){", "if( sqlite3StrNICmp(zRight, zMode, n)==0 ) break;", "}", "if( !zMode ){", "eMode = PAGER_JOURNALMODE_QUERY;", "}", "if( eMode==PAGER_JOURNALMODE_OFF && (db->flags & SQLITE_Defensive)!=0 ){", "eMode = PAGER_JOURNALMODE_QUERY;", "}", "}", "if( eMode==PAGER_JOURNALMODE_QUERY && pId2->n==0 ){", "iDb = 0;", "pId2->n = 1;", "}", "for(ii=db->nDb-1; ii>=0; ii--){", "if( db->aDb[ii].pBt && (ii==iDb || pId2->n==0) ){", "sqlite3VdbeUsesBtree(v, ii);", "sqlite3VdbeAddOp3(v, OP_JournalMode, ii, 1, eMode);", "}", "}", "sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 1);", "break;", "}", "case PragTyp_JOURNAL_SIZE_LIMIT: {", "Pager *pPager = sqlite3BtreePager(pDb->pBt);", "i64 iLimit = -2;", "if( zRight ){", "sqlite3DecOrHexToI64(zRight, &iLimit);", "if( iLimit<-1 ) iLimit = -1;", "}", "iLimit = sqlite3PagerJournalSizeLimit(pPager, iLimit);", "returnSingleInt(v, iLimit);", "break;", "}", "#endif /* SQLITE_OMIT_PAGER_PRAGMAS */", "#ifndef SQLITE_OMIT_AUTOVACUUM", "case PragTyp_AUTO_VACUUM: {", "Btree *pBt = pDb->pBt;", "assert( pBt!=0 );", "if( !zRight ){", "returnSingleInt(v, sqlite3BtreeGetAutoVacuum(pBt));", "}else{", "int eAuto = getAutoVacuum(zRight);", "assert( eAuto>=0 && eAuto<=2 );", "db->nextAutovac = (u8)eAuto;", "rc = sqlite3BtreeSetAutoVacuum(pBt, eAuto);", "if( rc==SQLITE_OK && (eAuto==1 || eAuto==2) ){", "static const int iLn = VDBE_OFFSET_LINENO(2);", "static const VdbeOpList setMeta6[] = {", "{ OP_Transaction,    0,         1,                 0},", "{ OP_ReadCookie,     0,         1,         BTREE_LARGEST_ROOT_PAGE},", "{ OP_If,             1,         0,                 0},", "{ OP_Halt,           SQLITE_OK, OE_Abort,          0},", "{ OP_SetCookie,      0,         BTREE_INCR_VACUUM, 0},", "};", "VdbeOp *aOp;", "int iAddr = sqlite3VdbeCurrentAddr(v);", "sqlite3VdbeVerifyNoMallocRequired(v, ArraySize(setMeta6));", "aOp = sqlite3VdbeAddOpList(v, ArraySize(setMeta6), setMeta6, iLn);", "if( ONLY_IF_REALLOC_STRESS(aOp==0) ) break;", "aOp[0].p1 = iDb;", "aOp[1].p1 = iDb;", "aOp[2].p2 = iAddr+4;", "aOp[4].p1 = iDb;", "aOp[4].p3 = eAuto - 1;", "sqlite3VdbeUsesBtree(v, iDb);", "}", "}", "break;", "}", "#endif", "#ifndef SQLITE_OMIT_AUTOVACUUM", "case PragTyp_INCREMENTAL_VACUUM: {", "int iLimit, addr;", "if( zRight==0 || !sqlite3GetInt32(zRight, &iLimit) || iLimit<=0 ){", "iLimit = 0x7fffffff;", "}", "sqlite3BeginWriteOperation(pParse, 0, iDb);", "sqlite3VdbeAddOp2(v, OP_Integer, iLimit, 1);", "addr = sqlite3VdbeAddOp1(v, OP_IncrVacuum, iDb); VdbeCoverage(v);", "sqlite3VdbeAddOp1(v, OP_ResultRow, 1);", "sqlite3VdbeAddOp2(v, OP_AddImm, 1, -1);", "sqlite3VdbeAddOp2(v, OP_IfPos, 1, addr); VdbeCoverage(v);", "sqlite3VdbeJumpHere(v, addr);", "break;", "}", "#endif", "#ifndef SQLITE_OMIT_PAGER_PRAGMAS", "case PragTyp_CACHE_SIZE: {", "assert( sqlite3SchemaMutexHeld(db, iDb, 0) );", "if( !zRight ){", "returnSingleInt(v, pDb->pSchema->cache_size);", "}else{", "int size = sqlite3Atoi(zRight);", "pDb->pSchema->cache_size = size;", "sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size);", "}", "break;", "}", "case PragTyp_CACHE_SPILL: {", "assert( sqlite3SchemaMutexHeld(db, iDb, 0) );", "if( !zRight ){", "returnSingleInt(v,", "(db->flags & SQLITE_CacheSpill)==0 ? 0 :", "sqlite3BtreeSetSpillSize(pDb->pBt,0));", "}else{", "int size = 1;", "if( sqlite3GetInt32(zRight, &size) ){", "sqlite3BtreeSetSpillSize(pDb->pBt, size);", "}", "if( sqlite3GetBoolean(zRight, size!=0) ){", "db->flags |= SQLITE_CacheSpill;", "}else{", "db->flags &= ~(u64)SQLITE_CacheSpill;", "}", "setAllPagerFlags(db);", "}", "break;", "}", "case PragTyp_MMAP_SIZE: {", "sqlite3_int64 sz;", "#if SQLITE_MAX_MMAP_SIZE>0", "assert( sqlite3SchemaMutexHeld(db, iDb, 0) );", "if( zRight ){", "int ii;", "sqlite3DecOrHexToI64(zRight, &sz);", "if( sz<0 ) sz = sqlite3GlobalConfig.szMmap;", "if( pId2->n==0 ) db->szMmap = sz;", "for(ii=db->nDb-1; ii>=0; ii--){", "if( db->aDb[ii].pBt && (ii==iDb || pId2->n==0) ){", "sqlite3BtreeSetMmapLimit(db->aDb[ii].pBt, sz);", "}", "}", "}", "sz = -1;", "rc = sqlite3_file_control(db, zDb, SQLITE_FCNTL_MMAP_SIZE, &sz);", "#else", "sz = 0;", "rc = SQLITE_OK;", "#endif", "if( rc==SQLITE_OK ){", "returnSingleInt(v, sz);", "}else if( rc!=SQLITE_NOTFOUND ){", "pParse->nErr++;", "pParse->rc = rc;", "}", "break;", "}", "case PragTyp_TEMP_STORE: {", "if( !zRight ){", "returnSingleInt(v, db->temp_store);", "}else{", "changeTempStorage(pParse, zRight);", "}", "break;", "}", "case PragTyp_TEMP_STORE_DIRECTORY: {", "if( !zRight ){", "returnSingleText(v, sqlite3_temp_directory);", "}else{", "#ifndef SQLITE_OMIT_WSD", "if( zRight[0] ){", "int res;", "rc = sqlite3OsAccess(db->pVfs, zRight, SQLITE_ACCESS_READWRITE, &res);", "if( rc!=SQLITE_OK || res==0 ){", "sqlite3ErrorMsg(pParse, \"not a writable directory\");", "goto pragma_out;", "}", "}", "if( SQLITE_TEMP_STORE==0", "|| (SQLITE_TEMP_STORE==1 && db->temp_store<=1)", "|| (SQLITE_TEMP_STORE==2 && db->temp_store==1)", "){", "invalidateTempStorage(pParse);", "}", "sqlite3_free(sqlite3_temp_directory);", "if( zRight[0] ){", "sqlite3_temp_directory = sqlite3_mprintf(\"%s\", zRight);", "}else{", "sqlite3_temp_directory = 0;", "}", "#endif /* SQLITE_OMIT_WSD */", "}", "break;", "}", "#if SQLITE_OS_WIN", "case PragTyp_DATA_STORE_DIRECTORY: {", "if( !zRight ){", "returnSingleText(v, sqlite3_data_directory);", "}else{", "#ifndef SQLITE_OMIT_WSD", "if( zRight[0] ){", "int res;", "rc = sqlite3OsAccess(db->pVfs, zRight, SQLITE_ACCESS_READWRITE, &res);", "if( rc!=SQLITE_OK || res==0 ){", "sqlite3ErrorMsg(pParse, \"not a writable directory\");", "goto pragma_out;", "}", "}", "sqlite3_free(sqlite3_data_directory);", "if( zRight[0] ){", "sqlite3_data_directory = sqlite3_mprintf(\"%s\", zRight);", "}else{", "sqlite3_data_directory = 0;", "}", "#endif /* SQLITE_OMIT_WSD */", "}", "break;", "}", "#endif", "#if SQLITE_ENABLE_LOCKING_STYLE", "case PragTyp_LOCK_PROXY_FILE: {", "if( !zRight ){", "Pager *pPager = sqlite3BtreePager(pDb->pBt);", "char *proxy_file_path = NULL;", "sqlite3_file *pFile = sqlite3PagerFile(pPager);", "sqlite3OsFileControlHint(pFile, SQLITE_GET_LOCKPROXYFILE,", "&proxy_file_path);", "returnSingleText(v, proxy_file_path);", "}else{", "Pager *pPager = sqlite3BtreePager(pDb->pBt);", "sqlite3_file *pFile = sqlite3PagerFile(pPager);", "int res;", "if( zRight[0] ){", "res=sqlite3OsFileControl(pFile, SQLITE_SET_LOCKPROXYFILE,", "zRight);", "} else {", "res=sqlite3OsFileControl(pFile, SQLITE_SET_LOCKPROXYFILE,", "NULL);", "}", "if( res!=SQLITE_OK ){", "sqlite3ErrorMsg(pParse, \"failed to set lock proxy file\");", "goto pragma_out;", "}", "}", "break;", "}", "#endif /* SQLITE_ENABLE_LOCKING_STYLE */      ", "case PragTyp_SYNCHRONOUS: {", "if( !zRight ){", "returnSingleInt(v, pDb->safety_level-1);", "}else{", "if( !db->autoCommit ){", "sqlite3ErrorMsg(pParse,", "\"Safety level may not be changed inside a transaction\");", "}else if( iDb!=1 ){", "int iLevel = (getSafetyLevel(zRight,0,1)+1) & PAGER_SYNCHRONOUS_MASK;", "if( iLevel==0 ) iLevel = 1;", "pDb->safety_level = iLevel;", "pDb->bSyncSet = 1;", "setAllPagerFlags(db);", "}", "}", "break;", "}", "#endif /* SQLITE_OMIT_PAGER_PRAGMAS */", "#ifndef SQLITE_OMIT_FLAG_PRAGMAS", "case PragTyp_FLAG: {", "if( zRight==0 ){", "setPragmaResultColumnNames(v, pPragma);", "returnSingleInt(v, (db->flags & pPragma->iArg)!=0 );", "}else{", "u64 mask = pPragma->iArg;", "if( db->autoCommit==0 ){", "mask &= ~(SQLITE_ForeignKeys);", "}", "#if SQLITE_USER_AUTHENTICATION", "if( db->auth.authLevel==UAUTH_User ){", "mask &= ~(SQLITE_WriteSchema);", "}", "#endif", "if( sqlite3GetBoolean(zRight, 0) ){", "db->flags |= mask;", "}else{", "db->flags &= ~mask;", "if( mask==SQLITE_DeferFKs ) db->nDeferredImmCons = 0;", "}", "sqlite3VdbeAddOp0(v, OP_Expire);", "setAllPagerFlags(db);", "}", "break;", "}", "#endif /* SQLITE_OMIT_FLAG_PRAGMAS */", "#ifndef SQLITE_OMIT_SCHEMA_PRAGMAS", "case PragTyp_TABLE_INFO: if( zRight ){", "Table *pTab;", "pTab = sqlite3LocateTable(pParse, LOCATE_NOERR, zRight, zDb);", "if( pTab ){", "int iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);", "int i, k;", "int nHidden = 0;", "Column *pCol;", "Index *pPk = sqlite3PrimaryKeyIndex(pTab);", "pParse->nMem = 7;", "sqlite3CodeVerifySchema(pParse, iTabDb);", "sqlite3ViewGetColumnNames(pParse, pTab);", "for(i=0, pCol=pTab->aCol; i<pTab->nCol; i++, pCol++){", "int isHidden = 0;", "if( pCol->colFlags & COLFLAG_NOINSERT ){", "if( pPragma->iArg==0 ){", "nHidden++;", "continue;", "}", "if( pCol->colFlags & COLFLAG_VIRTUAL ){", "isHidden = 2;", "}else if( pCol->colFlags & COLFLAG_STORED ){", "isHidden = 3;", "}else{ assert( pCol->colFlags & COLFLAG_HIDDEN );", "isHidden = 1;", "}", "}", "if( (pCol->colFlags & COLFLAG_PRIMKEY)==0 ){", "k = 0;", "}else if( pPk==0 ){", "k = 1;", "}else{", "for(k=1; k<=pTab->nCol && pPk->aiColumn[k-1]!=i; k++){}", "}", "assert( pCol->pDflt==0 || pCol->pDflt->op==TK_SPAN || isHidden>=2 );", "sqlite3VdbeMultiLoad(v, 1, pPragma->iArg ? \"issisii\" : \"issisi\",", "i-nHidden,", "pCol->zName,", "sqlite3ColumnType(pCol,\"\"),", "pCol->notNull ? 1 : 0,", "pCol->pDflt && isHidden<2 ? pCol->pDflt->u.zToken : 0,", "k,", "isHidden);", "}", "}", "}", "break;", "#ifdef SQLITE_DEBUG", "case PragTyp_STATS: {", "Index *pIdx;", "HashElem *i;", "pParse->nMem = 5;", "sqlite3CodeVerifySchema(pParse, iDb);", "for(i=sqliteHashFirst(&pDb->pSchema->tblHash); i; i=sqliteHashNext(i)){", "Table *pTab = sqliteHashData(i);", "sqlite3VdbeMultiLoad(v, 1, \"ssiii\",", "pTab->zName,", "0,", "pTab->szTabRow,", "pTab->nRowLogEst,", "pTab->tabFlags);", "for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){", "sqlite3VdbeMultiLoad(v, 2, \"siiiX\",", "pIdx->zName,", "pIdx->szIdxRow,", "pIdx->aiRowLogEst[0],", "pIdx->hasStat1);", "sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 5);", "}", "}", "}", "break;", "#endif", "case PragTyp_INDEX_INFO: if( zRight ){", "Index *pIdx;", "Table *pTab;", "pIdx = sqlite3FindIndex(db, zRight, zDb);", "if( pIdx==0 ){", "pTab = sqlite3LocateTable(pParse, LOCATE_NOERR, zRight, zDb);", "if( pTab && !HasRowid(pTab) ){", "pIdx = sqlite3PrimaryKeyIndex(pTab);", "}", "}", "if( pIdx ){", "int iIdxDb = sqlite3SchemaToIndex(db, pIdx->pSchema);", "int i;", "int mx;", "if( pPragma->iArg ){", "mx = pIdx->nColumn;", "pParse->nMem = 6;", "}else{", "mx = pIdx->nKeyCol;", "pParse->nMem = 3;", "}", "pTab = pIdx->pTable;", "sqlite3CodeVerifySchema(pParse, iIdxDb);", "assert( pParse->nMem<=pPragma->nPragCName );", "for(i=0; i<mx; i++){", "i16 cnum = pIdx->aiColumn[i];", "sqlite3VdbeMultiLoad(v, 1, \"iisX\", i, cnum,", "cnum<0 ? 0 : pTab->aCol[cnum].zName);", "if( pPragma->iArg ){", "sqlite3VdbeMultiLoad(v, 4, \"isiX\",", "pIdx->aSortOrder[i],", "pIdx->azColl[i],", "i<pIdx->nKeyCol);", "}", "sqlite3VdbeAddOp2(v, OP_ResultRow, 1, pParse->nMem);", "}", "}", "}", "break;", "case PragTyp_INDEX_LIST: if( zRight ){", "Index *pIdx;", "Table *pTab;", "int i;", "pTab = sqlite3FindTable(db, zRight, zDb);", "if( pTab ){", "int iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);", "pParse->nMem = 5;", "sqlite3CodeVerifySchema(pParse, iTabDb);", "for(pIdx=pTab->pIndex, i=0; pIdx; pIdx=pIdx->pNext, i++){", "const char *azOrigin[] = { \"c\", \"u\", \"pk\" };", "sqlite3VdbeMultiLoad(v, 1, \"isisi\",", "i,", "pIdx->zName,", "IsUniqueIndex(pIdx),", "azOrigin[pIdx->idxType],", "pIdx->pPartIdxWhere!=0);", "}", "}", "}", "break;", "case PragTyp_DATABASE_LIST: {", "int i;", "pParse->nMem = 3;", "for(i=0; i<db->nDb; i++){", "if( db->aDb[i].pBt==0 ) continue;", "assert( db->aDb[i].zDbSName!=0 );", "sqlite3VdbeMultiLoad(v, 1, \"iss\",", "i,", "db->aDb[i].zDbSName,", "sqlite3BtreeGetFilename(db->aDb[i].pBt));", "}", "}", "break;", "case PragTyp_COLLATION_LIST: {", "int i = 0;", "HashElem *p;", "pParse->nMem = 2;", "for(p=sqliteHashFirst(&db->aCollSeq); p; p=sqliteHashNext(p)){", "CollSeq *pColl = (CollSeq *)sqliteHashData(p);", "sqlite3VdbeMultiLoad(v, 1, \"is\", i++, pColl->zName);", "}", "}", "break;", "#ifndef SQLITE_OMIT_INTROSPECTION_PRAGMAS", "case PragTyp_FUNCTION_LIST: {", "int i;", "HashElem *j;", "FuncDef *p;", "pParse->nMem = 2;", "for(i=0; i<SQLITE_FUNC_HASH_SZ; i++){", "for(p=sqlite3BuiltinFunctions.a[i]; p; p=p->u.pHash ){", "if( p->funcFlags & SQLITE_FUNC_INTERNAL ) continue;", "sqlite3VdbeMultiLoad(v, 1, \"si\", p->zName, 1);", "}", "}", "for(j=sqliteHashFirst(&db->aFunc); j; j=sqliteHashNext(j)){", "p = (FuncDef*)sqliteHashData(j);", "sqlite3VdbeMultiLoad(v, 1, \"si\", p->zName, 0);", "}", "}", "break;", "#ifndef SQLITE_OMIT_VIRTUALTABLE", "case PragTyp_MODULE_LIST: {", "HashElem *j;", "pParse->nMem = 1;", "for(j=sqliteHashFirst(&db->aModule); j; j=sqliteHashNext(j)){", "Module *pMod = (Module*)sqliteHashData(j);", "sqlite3VdbeMultiLoad(v, 1, \"s\", pMod->zName);", "}", "}", "break;", "#endif /* SQLITE_OMIT_VIRTUALTABLE */", "case PragTyp_PRAGMA_LIST: {", "int i;", "for(i=0; i<ArraySize(aPragmaName); i++){", "sqlite3VdbeMultiLoad(v, 1, \"s\", aPragmaName[i].zName);", "}", "}", "break;", "#endif /* SQLITE_INTROSPECTION_PRAGMAS */", "#endif /* SQLITE_OMIT_SCHEMA_PRAGMAS */", "#ifndef SQLITE_OMIT_FOREIGN_KEY", "case PragTyp_FOREIGN_KEY_LIST: if( zRight ){", "FKey *pFK;", "Table *pTab;", "pTab = sqlite3FindTable(db, zRight, zDb);", "if( pTab ){", "pFK = pTab->pFKey;", "if( pFK ){", "int iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);", "int i = 0;", "pParse->nMem = 8;", "sqlite3CodeVerifySchema(pParse, iTabDb);", "while(pFK){", "int j;", "for(j=0; j<pFK->nCol; j++){", "sqlite3VdbeMultiLoad(v, 1, \"iissssss\",", "i,", "j,", "pFK->zTo,", "pTab->aCol[pFK->aCol[j].iFrom].zName,", "pFK->aCol[j].zCol,", "actionName(pFK->aAction[1]),", "actionName(pFK->aAction[0]),", "\"NONE\");", "}", "++i;", "pFK = pFK->pNextFrom;", "}", "}", "}", "}", "break;", "#endif /* !defined(SQLITE_OMIT_FOREIGN_KEY) */", "#ifndef SQLITE_OMIT_FOREIGN_KEY", "#ifndef SQLITE_OMIT_TRIGGER", "case PragTyp_FOREIGN_KEY_CHECK: {", "FKey *pFK;", "Table *pTab;", "Table *pParent;", "Index *pIdx;", "int i;", "int j;", "HashElem *k;", "int x;", "int regResult;", "int regKey;", "int regRow;", "int addrTop;", "int addrOk;", "int *aiCols;", "regResult = pParse->nMem+1;", "pParse->nMem += 4;", "regKey = ++pParse->nMem;", "regRow = ++pParse->nMem;", "k = sqliteHashFirst(&db->aDb[iDb].pSchema->tblHash);", "while( k ){", "int iTabDb;", "if( zRight ){", "pTab = sqlite3LocateTable(pParse, 0, zRight, zDb);", "k = 0;", "}else{", "pTab = (Table*)sqliteHashData(k);", "k = sqliteHashNext(k);", "}", "if( pTab==0 || pTab->pFKey==0 ) continue;", "iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);", "sqlite3CodeVerifySchema(pParse, iTabDb);", "sqlite3TableLock(pParse, iTabDb, pTab->tnum, 0, pTab->zName);", "if( pTab->nCol+regRow>pParse->nMem ) pParse->nMem = pTab->nCol + regRow;", "sqlite3OpenTable(pParse, 0, iTabDb, pTab, OP_OpenRead);", "sqlite3VdbeLoadString(v, regResult, pTab->zName);", "for(i=1, pFK=pTab->pFKey; pFK; i++, pFK=pFK->pNextFrom){", "pParent = sqlite3FindTable(db, pFK->zTo, zDb);", "if( pParent==0 ) continue;", "pIdx = 0;", "sqlite3TableLock(pParse, iTabDb, pParent->tnum, 0, pParent->zName);", "x = sqlite3FkLocateIndex(pParse, pParent, pFK, &pIdx, 0);", "if( x==0 ){", "if( pIdx==0 ){", "sqlite3OpenTable(pParse, i, iTabDb, pParent, OP_OpenRead);", "}else{", "sqlite3VdbeAddOp3(v, OP_OpenRead, i, pIdx->tnum, iTabDb);", "sqlite3VdbeSetP4KeyInfo(pParse, pIdx);", "}", "}else{", "k = 0;", "break;", "}", "}", "assert( pParse->nErr>0 || pFK==0 );", "if( pFK ) break;", "if( pParse->nTab<i ) pParse->nTab = i;", "addrTop = sqlite3VdbeAddOp1(v, OP_Rewind, 0); VdbeCoverage(v);", "for(i=1, pFK=pTab->pFKey; pFK; i++, pFK=pFK->pNextFrom){", "pParent = sqlite3FindTable(db, pFK->zTo, zDb);", "pIdx = 0;", "aiCols = 0;", "if( pParent ){", "x = sqlite3FkLocateIndex(pParse, pParent, pFK, &pIdx, &aiCols);", "assert( x==0 );", "}", "addrOk = sqlite3VdbeMakeLabel(pParse);", "for(j=0; j<pFK->nCol; j++){", "int iCol = aiCols ? aiCols[j] : pFK->aCol[j].iFrom;", "sqlite3ExprCodeGetColumnOfTable(v, pTab, 0, iCol, regRow+j);", "sqlite3VdbeAddOp2(v, OP_IsNull, regRow+j, addrOk); VdbeCoverage(v);", "}", "if( pIdx ){", "sqlite3VdbeAddOp4(v, OP_MakeRecord, regRow, pFK->nCol, regKey,", "sqlite3IndexAffinityStr(db,pIdx), pFK->nCol);", "sqlite3VdbeAddOp4Int(v, OP_Found, i, addrOk, regKey, 0);", "VdbeCoverage(v);", "}else if( pParent ){", "int jmp = sqlite3VdbeCurrentAddr(v)+2;", "sqlite3VdbeAddOp3(v, OP_SeekRowid, i, jmp, regRow); VdbeCoverage(v);", "sqlite3VdbeGoto(v, addrOk);", "assert( pFK->nCol==1 );", "}", "if( HasRowid(pTab) ){", "sqlite3VdbeAddOp2(v, OP_Rowid, 0, regResult+1);", "}else{", "sqlite3VdbeAddOp2(v, OP_Null, 0, regResult+1);", "}", "sqlite3VdbeMultiLoad(v, regResult+2, \"siX\", pFK->zTo, i-1);", "sqlite3VdbeAddOp2(v, OP_ResultRow, regResult, 4);", "sqlite3VdbeResolveLabel(v, addrOk);", "sqlite3DbFree(db, aiCols);", "}", "sqlite3VdbeAddOp2(v, OP_Next, 0, addrTop+1); VdbeCoverage(v);", "sqlite3VdbeJumpHere(v, addrTop);", "}", "}", "break;", "#endif /* !defined(SQLITE_OMIT_TRIGGER) */", "#endif /* !defined(SQLITE_OMIT_FOREIGN_KEY) */", "#ifndef SQLITE_OMIT_CASE_SENSITIVE_LIKE_PRAGMA", "case PragTyp_CASE_SENSITIVE_LIKE: {", "if( zRight ){", "sqlite3RegisterLikeFunctions(db, sqlite3GetBoolean(zRight, 0));", "}", "}", "break;", "#endif /* SQLITE_OMIT_CASE_SENSITIVE_LIKE_PRAGMA */", "#ifndef SQLITE_INTEGRITY_CHECK_ERROR_MAX", "# define SQLITE_INTEGRITY_CHECK_ERROR_MAX 100", "#endif", "#ifndef SQLITE_OMIT_INTEGRITY_CHECK", "case PragTyp_INTEGRITY_CHECK: {", "int i, j, addr, mxErr;", "int isQuick = (sqlite3Tolower(zLeft[0])=='q');", "assert( iDb>=0 );", "assert( iDb==0 || pId2->z );", "if( pId2->z==0 ) iDb = -1;", "pParse->nMem = 6;", "mxErr = SQLITE_INTEGRITY_CHECK_ERROR_MAX;", "if( zRight ){", "sqlite3GetInt32(zRight, &mxErr);", "if( mxErr<=0 ){", "mxErr = SQLITE_INTEGRITY_CHECK_ERROR_MAX;", "}", "}", "sqlite3VdbeAddOp2(v, OP_Integer, mxErr-1, 1);", "for(i=0; i<db->nDb; i++){", "HashElem *x;", "Hash *pTbls;", "int *aRoot;", "int cnt = 0;", "int mxIdx = 0;", "if( OMIT_TEMPDB && i==1 ) continue;", "if( iDb>=0 && i!=iDb ) continue;", "sqlite3CodeVerifySchema(pParse, i);", "assert( sqlite3SchemaMutexHeld(db, i, 0) );", "pTbls = &db->aDb[i].pSchema->tblHash;", "for(cnt=0, x=sqliteHashFirst(pTbls); x; x=sqliteHashNext(x)){", "Table *pTab = sqliteHashData(x);", "Index *pIdx;", "int nIdx;", "if( HasRowid(pTab) ) cnt++;", "for(nIdx=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, nIdx++){ cnt++; }", "if( nIdx>mxIdx ) mxIdx = nIdx;", "}", "aRoot = sqlite3DbMallocRawNN(db, sizeof(int)*(cnt+1));", "if( aRoot==0 ) break;", "for(cnt=0, x=sqliteHashFirst(pTbls); x; x=sqliteHashNext(x)){", "Table *pTab = sqliteHashData(x);", "Index *pIdx;", "if( HasRowid(pTab) ) aRoot[++cnt] = pTab->tnum;", "for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){", "aRoot[++cnt] = pIdx->tnum;", "}", "}", "aRoot[0] = cnt;", "pParse->nMem = MAX( pParse->nMem, 8+mxIdx );", "sqlite3ClearTempRegCache(pParse);", "sqlite3VdbeAddOp4(v, OP_IntegrityCk, 2, cnt, 1, (char*)aRoot,P4_INTARRAY);", "sqlite3VdbeChangeP5(v, (u8)i);", "addr = sqlite3VdbeAddOp1(v, OP_IsNull, 2); VdbeCoverage(v);", "sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0,", "sqlite3MPrintf(db, \"*** in database %s ***\\n\", db->aDb[i].zDbSName),", "P4_DYNAMIC);", "sqlite3VdbeAddOp3(v, OP_Concat, 2, 3, 3);", "integrityCheckResultRow(v);", "sqlite3VdbeJumpHere(v, addr);", "for(x=sqliteHashFirst(pTbls); x; x=sqliteHashNext(x)){", "Table *pTab = sqliteHashData(x);", "Index *pIdx, *pPk;", "Index *pPrior = 0;", "int loopTop;", "int iDataCur, iIdxCur;", "int r1 = -1;", "if( pTab->tnum<1 ) continue;", "pPk = HasRowid(pTab) ? 0 : sqlite3PrimaryKeyIndex(pTab);", "sqlite3OpenTableAndIndices(pParse, pTab, OP_OpenRead, 0,", "1, 0, &iDataCur, &iIdxCur);", "sqlite3VdbeAddOp2(v, OP_Integer, 0, 7);", "for(j=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, j++){", "sqlite3VdbeAddOp2(v, OP_Integer, 0, 8+j);", "}", "assert( pParse->nMem>=8+j );", "assert( sqlite3NoTempsInRange(pParse,1,7+j) );", "sqlite3VdbeAddOp2(v, OP_Rewind, iDataCur, 0); VdbeCoverage(v);", "loopTop = sqlite3VdbeAddOp2(v, OP_AddImm, 7, 1);", "if( !isQuick ){", "sqlite3VdbeAddOp3(v, OP_Column, iDataCur, pTab->nNVCol-1,3);", "sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);", "}", "for(j=0; j<pTab->nCol; j++){", "char *zErr;", "int jmp2;", "if( j==pTab->iPKey ) continue;", "if( pTab->aCol[j].notNull==0 ) continue;", "sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, j, 3);", "sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);", "jmp2 = sqlite3VdbeAddOp1(v, OP_NotNull, 3); VdbeCoverage(v);", "zErr = sqlite3MPrintf(db, \"NULL value in %s.%s\", pTab->zName,", "pTab->aCol[j].zName);", "sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0, zErr, P4_DYNAMIC);", "integrityCheckResultRow(v);", "sqlite3VdbeJumpHere(v, jmp2);", "}", "if( pTab->pCheck && (db->flags & SQLITE_IgnoreChecks)==0 ){", "ExprList *pCheck = sqlite3ExprListDup(db, pTab->pCheck, 0);", "if( db->mallocFailed==0 ){", "int addrCkFault = sqlite3VdbeMakeLabel(pParse);", "int addrCkOk = sqlite3VdbeMakeLabel(pParse);", "char *zErr;", "int k;", "pParse->iSelfTab = iDataCur + 1;", "for(k=pCheck->nExpr-1; k>0; k--){", "sqlite3ExprIfFalse(pParse, pCheck->a[k].pExpr, addrCkFault, 0);", "}", "sqlite3ExprIfTrue(pParse, pCheck->a[0].pExpr, addrCkOk,", "SQLITE_JUMPIFNULL);", "sqlite3VdbeResolveLabel(v, addrCkFault);", "pParse->iSelfTab = 0;", "zErr = sqlite3MPrintf(db, \"CHECK constraint failed in %s\",", "pTab->zName);", "sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0, zErr, P4_DYNAMIC);", "integrityCheckResultRow(v);", "sqlite3VdbeResolveLabel(v, addrCkOk);", "}", "sqlite3ExprListDelete(db, pCheck);", "}", "if( !isQuick ){", "for(j=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, j++){", "int jmp2, jmp3, jmp4, jmp5;", "int ckUniq = sqlite3VdbeMakeLabel(pParse);", "if( pPk==pIdx ) continue;", "r1 = sqlite3GenerateIndexKey(pParse, pIdx, iDataCur, 0, 0, &jmp3,", "pPrior, r1);", "pPrior = pIdx;", "sqlite3VdbeAddOp2(v, OP_AddImm, 8+j, 1);", "jmp2 = sqlite3VdbeAddOp4Int(v, OP_Found, iIdxCur+j, ckUniq, r1,", "pIdx->nColumn); VdbeCoverage(v);", "sqlite3VdbeLoadString(v, 3, \"row \");", "sqlite3VdbeAddOp3(v, OP_Concat, 7, 3, 3);", "sqlite3VdbeLoadString(v, 4, \" missing from index \");", "sqlite3VdbeAddOp3(v, OP_Concat, 4, 3, 3);", "jmp5 = sqlite3VdbeLoadString(v, 4, pIdx->zName);", "sqlite3VdbeAddOp3(v, OP_Concat, 4, 3, 3);", "jmp4 = integrityCheckResultRow(v);", "sqlite3VdbeJumpHere(v, jmp2);", "if( IsUniqueIndex(pIdx) ){", "int uniqOk = sqlite3VdbeMakeLabel(pParse);", "int jmp6;", "int kk;", "for(kk=0; kk<pIdx->nKeyCol; kk++){", "int iCol = pIdx->aiColumn[kk];", "assert( iCol!=XN_ROWID && iCol<pTab->nCol );", "if( iCol>=0 && pTab->aCol[iCol].notNull ) continue;", "sqlite3VdbeAddOp2(v, OP_IsNull, r1+kk, uniqOk);", "VdbeCoverage(v);", "}", "jmp6 = sqlite3VdbeAddOp1(v, OP_Next, iIdxCur+j); VdbeCoverage(v);", "sqlite3VdbeGoto(v, uniqOk);", "sqlite3VdbeJumpHere(v, jmp6);", "sqlite3VdbeAddOp4Int(v, OP_IdxGT, iIdxCur+j, uniqOk, r1,", "pIdx->nKeyCol); VdbeCoverage(v);", "sqlite3VdbeLoadString(v, 3, \"non-unique entry in index \");", "sqlite3VdbeGoto(v, jmp5);", "sqlite3VdbeResolveLabel(v, uniqOk);", "}", "sqlite3VdbeJumpHere(v, jmp4);", "sqlite3ResolvePartIdxLabel(pParse, jmp3);", "}", "}", "sqlite3VdbeAddOp2(v, OP_Next, iDataCur, loopTop); VdbeCoverage(v);", "sqlite3VdbeJumpHere(v, loopTop-1);", "#ifndef SQLITE_OMIT_BTREECOUNT", "if( !isQuick ){", "sqlite3VdbeLoadString(v, 2, \"wrong # of entries in index \");", "for(j=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, j++){", "if( pPk==pIdx ) continue;", "sqlite3VdbeAddOp2(v, OP_Count, iIdxCur+j, 3);", "addr = sqlite3VdbeAddOp3(v, OP_Eq, 8+j, 0, 3); VdbeCoverage(v);", "sqlite3VdbeChangeP5(v, SQLITE_NOTNULL);", "sqlite3VdbeLoadString(v, 4, pIdx->zName);", "sqlite3VdbeAddOp3(v, OP_Concat, 4, 2, 3);", "integrityCheckResultRow(v);", "sqlite3VdbeJumpHere(v, addr);", "}", "}", "#endif /* SQLITE_OMIT_BTREECOUNT */", "}", "}", "{", "static const int iLn = VDBE_OFFSET_LINENO(2);", "static const VdbeOpList endCode[] = {", "{ OP_AddImm,      1, 0,        0},", "{ OP_IfNotZero,   1, 4,        0},", "{ OP_String8,     0, 3,        0},", "{ OP_ResultRow,   3, 1,        0},", "{ OP_Halt,        0, 0,        0},", "{ OP_String8,     0, 3,        0},", "{ OP_Goto,        0, 3,        0},", "};", "VdbeOp *aOp;", "aOp = sqlite3VdbeAddOpList(v, ArraySize(endCode), endCode, iLn);", "if( aOp ){", "aOp[0].p2 = 1-mxErr;", "aOp[2].p4type = P4_STATIC;", "aOp[2].p4.z = \"ok\";", "aOp[5].p4type = P4_STATIC;", "aOp[5].p4.z = (char*)sqlite3ErrStr(SQLITE_CORRUPT);", "}", "sqlite3VdbeChangeP3(v, 0, sqlite3VdbeCurrentAddr(v)-2);", "}", "}", "break;", "#endif /* SQLITE_OMIT_INTEGRITY_CHECK */", "#ifndef SQLITE_OMIT_UTF16", "case PragTyp_ENCODING: {", "static const struct EncName {", "char *zName;", "u8 enc;", "} encnames[] = {", "{ \"UTF8\",     SQLITE_UTF8        },", "{ \"UTF-8\",    SQLITE_UTF8        },", "{ \"UTF-16le\", SQLITE_UTF16LE     },", "{ \"UTF-16be\", SQLITE_UTF16BE     },", "{ \"UTF16le\",  SQLITE_UTF16LE     },", "{ \"UTF16be\",  SQLITE_UTF16BE     },", "{ \"UTF-16\",   0                  },", "{ \"UTF16\",    0                  },", "{ 0, 0 }", "};", "const struct EncName *pEnc;", "if( !zRight ){", "if( sqlite3ReadSchema(pParse) ) goto pragma_out;", "assert( encnames[SQLITE_UTF8].enc==SQLITE_UTF8 );", "assert( encnames[SQLITE_UTF16LE].enc==SQLITE_UTF16LE );", "assert( encnames[SQLITE_UTF16BE].enc==SQLITE_UTF16BE );", "returnSingleText(v, encnames[ENC(pParse->db)].zName);", "}else{", "if(", "!(DbHasProperty(db, 0, DB_SchemaLoaded)) ||", "DbHasProperty(db, 0, DB_Empty)", "){", "for(pEnc=&encnames[0]; pEnc->zName; pEnc++){", "if( 0==sqlite3StrICmp(zRight, pEnc->zName) ){", "SCHEMA_ENC(db) = ENC(db) =", "pEnc->enc ? pEnc->enc : SQLITE_UTF16NATIVE;", "break;", "}", "}", "if( !pEnc->zName ){", "sqlite3ErrorMsg(pParse, \"unsupported encoding: %s\", zRight);", "}", "}", "}", "}", "break;", "#endif /* SQLITE_OMIT_UTF16 */", "#ifndef SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS", "case PragTyp_HEADER_VALUE: {", "int iCookie = pPragma->iArg;", "sqlite3VdbeUsesBtree(v, iDb);", "if( zRight && (pPragma->mPragFlg & PragFlg_ReadOnly)==0 ){", "static const VdbeOpList setCookie[] = {", "{ OP_Transaction,    0,  1,  0},", "{ OP_SetCookie,      0,  0,  0},", "};", "VdbeOp *aOp;", "sqlite3VdbeVerifyNoMallocRequired(v, ArraySize(setCookie));", "aOp = sqlite3VdbeAddOpList(v, ArraySize(setCookie), setCookie, 0);", "if( ONLY_IF_REALLOC_STRESS(aOp==0) ) break;", "aOp[0].p1 = iDb;", "aOp[1].p1 = iDb;", "aOp[1].p2 = iCookie;", "aOp[1].p3 = sqlite3Atoi(zRight);", "}else{", "static const VdbeOpList readCookie[] = {", "{ OP_Transaction,     0,  0,  0},", "{ OP_ReadCookie,      0,  1,  0},", "{ OP_ResultRow,       1,  1,  0}", "};", "VdbeOp *aOp;", "sqlite3VdbeVerifyNoMallocRequired(v, ArraySize(readCookie));", "aOp = sqlite3VdbeAddOpList(v, ArraySize(readCookie),readCookie,0);", "if( ONLY_IF_REALLOC_STRESS(aOp==0) ) break;", "aOp[0].p1 = iDb;", "aOp[1].p1 = iDb;", "aOp[1].p3 = iCookie;", "sqlite3VdbeReusable(v);", "}", "}", "break;", "#endif /* SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS */", "#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS", "case PragTyp_COMPILE_OPTIONS: {", "int i = 0;", "const char *zOpt;", "pParse->nMem = 1;", "while( (zOpt = sqlite3_compileoption_get(i++))!=0 ){", "sqlite3VdbeLoadString(v, 1, zOpt);", "sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 1);", "}", "sqlite3VdbeReusable(v);", "}", "break;", "#endif /* SQLITE_OMIT_COMPILEOPTION_DIAGS */", "#ifndef SQLITE_OMIT_WAL", "case PragTyp_WAL_CHECKPOINT: {", "int iBt = (pId2->z?iDb:SQLITE_MAX_ATTACHED);", "int eMode = SQLITE_CHECKPOINT_PASSIVE;", "if( zRight ){", "if( sqlite3StrICmp(zRight, \"full\")==0 ){", "eMode = SQLITE_CHECKPOINT_FULL;", "}else if( sqlite3StrICmp(zRight, \"restart\")==0 ){", "eMode = SQLITE_CHECKPOINT_RESTART;", "}else if( sqlite3StrICmp(zRight, \"truncate\")==0 ){", "eMode = SQLITE_CHECKPOINT_TRUNCATE;", "}", "}", "pParse->nMem = 3;", "sqlite3VdbeAddOp3(v, OP_Checkpoint, iBt, eMode, 1);", "sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 3);", "}", "break;", "case PragTyp_WAL_AUTOCHECKPOINT: {", "if( zRight ){", "sqlite3_wal_autocheckpoint(db, sqlite3Atoi(zRight));", "}", "returnSingleInt(v,", "db->xWalCallback==sqlite3WalDefaultHook ?", "SQLITE_PTR_TO_INT(db->pWalArg) : 0);", "}", "break;", "#endif", "case PragTyp_SHRINK_MEMORY: {", "sqlite3_db_release_memory(db);", "break;", "}", "case PragTyp_OPTIMIZE: {", "int iDbLast;", "int iTabCur;", "HashElem *k;", "Schema *pSchema;", "Table *pTab;", "Index *pIdx;", "LogEst szThreshold;", "char *zSubSql;", "u32 opMask;", "if( zRight ){", "opMask = (u32)sqlite3Atoi(zRight);", "if( (opMask & 0x02)==0 ) break;", "}else{", "opMask = 0xfffe;", "}", "iTabCur = pParse->nTab++;", "for(iDbLast = zDb?iDb:db->nDb-1; iDb<=iDbLast; iDb++){", "if( iDb==1 ) continue;", "sqlite3CodeVerifySchema(pParse, iDb);", "pSchema = db->aDb[iDb].pSchema;", "for(k=sqliteHashFirst(&pSchema->tblHash); k; k=sqliteHashNext(k)){", "pTab = (Table*)sqliteHashData(k);", "if( (pTab->tabFlags & TF_StatsUsed)==0 ) continue;", "szThreshold = pTab->nRowLogEst + 46; assert( sqlite3LogEst(25)==46 );", "for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){", "if( !pIdx->hasStat1 ){", "szThreshold = 0;", "break;", "}", "}", "if( szThreshold ){", "sqlite3OpenTable(pParse, iTabCur, iDb, pTab, OP_OpenRead);", "sqlite3VdbeAddOp3(v, OP_IfSmaller, iTabCur,", "sqlite3VdbeCurrentAddr(v)+2+(opMask&1), szThreshold);", "VdbeCoverage(v);", "}", "zSubSql = sqlite3MPrintf(db, \"ANALYZE \\\"%w\\\".\\\"%w\\\"\",", "db->aDb[iDb].zDbSName, pTab->zName);", "if( opMask & 0x01 ){", "int r1 = sqlite3GetTempReg(pParse);", "sqlite3VdbeAddOp4(v, OP_String8, 0, r1, 0, zSubSql, P4_DYNAMIC);", "sqlite3VdbeAddOp2(v, OP_ResultRow, r1, 1);", "}else{", "sqlite3VdbeAddOp4(v, OP_SqlExec, 0, 0, 0, zSubSql, P4_DYNAMIC);", "}", "}", "}", "sqlite3VdbeAddOp0(v, OP_Expire);", "break;", "}", "default: {", "assert( pPragma->ePragTyp==PragTyp_BUSY_TIMEOUT );", "if( zRight ){", "sqlite3_busy_timeout(db, sqlite3Atoi(zRight));", "}", "returnSingleInt(v, db->busyTimeout);", "break;", "}", "case PragTyp_SOFT_HEAP_LIMIT: {", "sqlite3_int64 N;", "if( zRight && sqlite3DecOrHexToI64(zRight, &N)==SQLITE_OK ){", "sqlite3_soft_heap_limit64(N);", "}", "returnSingleInt(v, sqlite3_soft_heap_limit64(-1));", "break;", "}", "case PragTyp_HARD_HEAP_LIMIT: {", "sqlite3_int64 N;", "if( zRight && sqlite3DecOrHexToI64(zRight, &N)==SQLITE_OK ){", "sqlite3_int64 iPrior = sqlite3_hard_heap_limit64(-1);", "if( N>0 && (iPrior==0 || iPrior>N) ) sqlite3_hard_heap_limit64(N);", "}", "returnSingleInt(v, sqlite3_hard_heap_limit64(-1));", "break;", "}", "case PragTyp_THREADS: {", "sqlite3_int64 N;", "if( zRight", "&& sqlite3DecOrHexToI64(zRight, &N)==SQLITE_OK", "&& N>=0", "){", "sqlite3_limit(db, SQLITE_LIMIT_WORKER_THREADS, (int)(N&0x7fffffff));", "}", "returnSingleInt(v, sqlite3_limit(db, SQLITE_LIMIT_WORKER_THREADS, -1));", "break;", "}", "#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)", "case PragTyp_LOCK_STATUS: {", "static const char *const azLockName[] = {", "\"unlocked\", \"shared\", \"reserved\", \"pending\", \"exclusive\"", "};", "int i;", "pParse->nMem = 2;", "for(i=0; i<db->nDb; i++){", "Btree *pBt;", "const char *zState = \"unknown\";", "int j;", "if( db->aDb[i].zDbSName==0 ) continue;", "pBt = db->aDb[i].pBt;", "if( pBt==0 || sqlite3BtreePager(pBt)==0 ){", "zState = \"closed\";", "}else if( sqlite3_file_control(db, i ? db->aDb[i].zDbSName : 0,", "SQLITE_FCNTL_LOCKSTATE, &j)==SQLITE_OK ){", "zState = azLockName[j];", "}", "sqlite3VdbeMultiLoad(v, 1, \"ss\", db->aDb[i].zDbSName, zState);", "}", "break;", "}", "#endif", "#ifdef SQLITE_HAS_CODEC", "case PragTyp_KEY: {", "if( zRight ){", "char zBuf[40];", "const char *zKey = zRight;", "int n;", "if( pPragma->iArg==2 || pPragma->iArg==3 ){", "u8 iByte;", "int i;", "for(i=0, iByte=0; i<sizeof(zBuf)*2 && sqlite3Isxdigit(zRight[i]); i++){", "iByte = (iByte<<4) + sqlite3HexToInt(zRight[i]);", "if( (i&1)!=0 ) zBuf[i/2] = iByte;", "}", "zKey = zBuf;", "n = i/2;", "}else{", "n = pPragma->iArg<4 ? sqlite3Strlen30(zRight) : -1;", "}", "if( (pPragma->iArg & 1)==0 ){", "rc = sqlite3_key_v2(db, zDb, zKey, n);", "}else{", "rc = sqlite3_rekey_v2(db, zDb, zKey, n);", "}", "if( rc==SQLITE_OK && n!=0 ){", "sqlite3VdbeSetNumCols(v, 1);", "sqlite3VdbeSetColName(v, 0, COLNAME_NAME, \"ok\", SQLITE_STATIC);", "returnSingleText(v, \"ok\");", "}", "}", "break;", "}", "#endif", "#if defined(SQLITE_HAS_CODEC) || defined(SQLITE_ENABLE_CEROD)", "case PragTyp_ACTIVATE_EXTENSIONS: if( zRight ){", "#ifdef SQLITE_HAS_CODEC", "if( sqlite3StrNICmp(zRight, \"see-\", 4)==0 ){", "sqlite3_activate_see(&zRight[4]);", "}", "#endif", "#ifdef SQLITE_ENABLE_CEROD", "if( sqlite3StrNICmp(zRight, \"cerod-\", 6)==0 ){", "sqlite3_activate_cerod(&zRight[6]);", "}", "#endif", "}", "break;", "#endif", "}", "if( (pPragma->mPragFlg & PragFlg_NoColumns1) && zRight ){", "sqlite3VdbeVerifyNoResultRow(v);", "}", "pragma_out:", "sqlite3DbFree(db, zLeft);", "sqlite3DbFree(db, zRight);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["idn2_to_ascii_4i (const uint32_t * input, size_t inlen, char * output, int flags)", "{", "uint32_t *input_u32;", "uint8_t *input_u8, *output_u8;", "size_t length;", "int rc;", "if (!input)", "{", "if (output)", "*output = 0;", "return IDN2_OK;", "}", "input_u32 = (uint32_t *) malloc ((inlen + 1) * sizeof(uint32_t));", "if (!input_u32)", "return IDN2_MALLOC;", "u32_cpy (input_u32, input, inlen);", "input_u32[inlen] = 0;", "input_u8 = u32_to_u8 (input_u32, inlen + 1, NULL, &length);", "free (input_u32);", "if (!input_u8)", "{", "if (errno == ENOMEM)", "return IDN2_MALLOC;", "return IDN2_ENCODING_ERROR;", "}", "rc = idn2_lookup_u8 (input_u8, &output_u8, flags);", "free (input_u8);", "if (rc == IDN2_OK)", "{", "if (output)", "strcpy (output, (const char *) output_u8);", "free(output_u8);", "}", "return rc;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0]}
{"tokens": ["GF_Err stbl_GetSampleInfos(GF_SampleTableBox *stbl, u32 sampleNumber, u64 *offset, u32 *chunkNumber, u32 *descIndex, GF_StscEntry **out_ent)", "{", "GF_Err e;", "u32 i, k, offsetInChunk, size, chunk_num;", "GF_ChunkOffsetBox *stco;", "GF_ChunkLargeOffsetBox *co64;", "GF_StscEntry *ent;", "(*offset) = 0;", "(*chunkNumber) = (*descIndex) = 0;", "if (out_ent) (*out_ent) = NULL;", "if (!stbl || !sampleNumber) return GF_BAD_PARAM;", "if (!stbl->ChunkOffset || !stbl->SampleToChunk || !stbl->SampleSize) return GF_ISOM_INVALID_FILE;", "if (stbl->SampleSize && stbl->SampleToChunk->nb_entries == stbl->SampleSize->sampleCount) {", "ent = &stbl->SampleToChunk->entries[sampleNumber-1];", "if (!ent) return GF_BAD_PARAM;", "(*descIndex) = ent->sampleDescriptionIndex;", "(*chunkNumber) = sampleNumber;", "if (out_ent) *out_ent = ent;", "if ( stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {", "stco = (GF_ChunkOffsetBox *)stbl->ChunkOffset;", "if (!stco->offsets) return GF_ISOM_INVALID_FILE;", "(*offset) = (u64) stco->offsets[sampleNumber - 1];", "} else {", "co64 = (GF_ChunkLargeOffsetBox *)stbl->ChunkOffset;", "if (!co64->offsets) return GF_ISOM_INVALID_FILE;", "(*offset) = co64->offsets[sampleNumber - 1];", "}", "return GF_OK;", "}", "if (stbl->SampleToChunk->firstSampleInCurrentChunk &&", "(stbl->SampleToChunk->firstSampleInCurrentChunk <= sampleNumber)) {", "i = stbl->SampleToChunk->currentIndex;", "ent = &stbl->SampleToChunk->entries[stbl->SampleToChunk->currentIndex];", "GetGhostNum(ent, i, stbl->SampleToChunk->nb_entries, stbl);", "k = stbl->SampleToChunk->currentChunk;", "}", "else {", "i = 0;", "stbl->SampleToChunk->currentIndex = 0;", "stbl->SampleToChunk->currentChunk = 1;", "stbl->SampleToChunk->ghostNumber = 1;", "stbl->SampleToChunk->firstSampleInCurrentChunk = 1;", "ent = &stbl->SampleToChunk->entries[0];", "GetGhostNum(ent, 0, stbl->SampleToChunk->nb_entries, stbl);", "k = stbl->SampleToChunk->currentChunk;", "}", "for (; i < stbl->SampleToChunk->nb_entries; i++) {", "assert(stbl->SampleToChunk->firstSampleInCurrentChunk <= sampleNumber);", "if (k > stbl->SampleToChunk->ghostNumber) {", "return GF_ISOM_INVALID_FILE;", "}", "u32 max_chunks_in_entry = stbl->SampleToChunk->ghostNumber - k;", "u32 nb_chunks_for_sample = sampleNumber - stbl->SampleToChunk->firstSampleInCurrentChunk;", "if (ent->samplesPerChunk)", "nb_chunks_for_sample /= ent->samplesPerChunk;", "if (", "(nb_chunks_for_sample <= max_chunks_in_entry)", "&& (stbl->SampleToChunk->firstSampleInCurrentChunk + (nb_chunks_for_sample+1) * ent->samplesPerChunk > sampleNumber)", ") {", "stbl->SampleToChunk->firstSampleInCurrentChunk += nb_chunks_for_sample * ent->samplesPerChunk;", "stbl->SampleToChunk->currentChunk += nb_chunks_for_sample;", "goto sample_found;", "}", "max_chunks_in_entry += 1;", "stbl->SampleToChunk->firstSampleInCurrentChunk += max_chunks_in_entry * ent->samplesPerChunk;", "stbl->SampleToChunk->currentChunk += max_chunks_in_entry;", "if (i+1 != stbl->SampleToChunk->nb_entries) {", "ent = &stbl->SampleToChunk->entries[i+1];", "GetGhostNum(ent, i+1, stbl->SampleToChunk->nb_entries, stbl);", "stbl->SampleToChunk->currentIndex = i+1;", "stbl->SampleToChunk->currentChunk = 1;", "k = 1;", "}", "}", "return GF_ISOM_INVALID_FILE;", "sample_found:", "(*descIndex) = ent->sampleDescriptionIndex;", "(*chunkNumber) = chunk_num = ent->firstChunk + stbl->SampleToChunk->currentChunk - 1;", "if (out_ent) *out_ent = ent;", "if (! *chunkNumber)", "return GF_ISOM_INVALID_FILE;", "offsetInChunk = 0;", "if (stbl->SampleSize && stbl->SampleSize->sampleSize) {", "u32 diff = sampleNumber - stbl->SampleToChunk->firstSampleInCurrentChunk;", "offsetInChunk += diff * stbl->SampleSize->sampleSize;", "} else if ((stbl->r_last_chunk_num == chunk_num) && (stbl->r_last_sample_num == sampleNumber)) {", "offsetInChunk = stbl->r_last_offset_in_chunk;", "} else if ((stbl->r_last_chunk_num == chunk_num) && (stbl->r_last_sample_num + 1 == sampleNumber)) {", "e = stbl_GetSampleSize(stbl->SampleSize, stbl->r_last_sample_num, &size);", "if (e) return e;", "stbl->r_last_offset_in_chunk += size;", "stbl->r_last_sample_num = sampleNumber;", "offsetInChunk = stbl->r_last_offset_in_chunk;", "} else {", "for (i = stbl->SampleToChunk->firstSampleInCurrentChunk; i < sampleNumber; i++) {", "e = stbl_GetSampleSize(stbl->SampleSize, i, &size);", "if (e) return e;", "offsetInChunk += size;", "}", "stbl->r_last_chunk_num = chunk_num;", "stbl->r_last_sample_num = sampleNumber;", "stbl->r_last_offset_in_chunk = offsetInChunk;", "}", "if ( stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {", "stco = (GF_ChunkOffsetBox *)stbl->ChunkOffset;", "if (stco->nb_entries < (*chunkNumber) ) return GF_ISOM_INVALID_FILE;", "(*offset) = (u64) stco->offsets[(*chunkNumber) - 1] + (u64) offsetInChunk;", "} else {", "co64 = (GF_ChunkLargeOffsetBox *)stbl->ChunkOffset;", "if (co64->nb_entries < (*chunkNumber) ) return GF_ISOM_INVALID_FILE;", "(*offset) = co64->offsets[(*chunkNumber) - 1] + (u64) offsetInChunk;", "}", "return GF_OK;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static void handle_PORT(ctrl_t *ctrl, char *str)", "{", "int a, b, c, d, e, f;", "char addr[INET_ADDRSTRLEN];", "struct sockaddr_in sin;", "if (ctrl->data_sd > 0) {", "uev_io_stop(&ctrl->data_watcher);", "close(ctrl->data_sd);", "ctrl->data_sd = -1;", "}", "sscanf(str, \"%d,%d,%d,%d,%d,%d\", &a, &b, &c, &d, &e, &f);", "sprintf(addr, \"%d.%d.%d.%d\", a, b, c, d);", "if (!inet_aton(addr, &(sin.sin_addr))) {", "ERR(0, \"Invalid address '%s' given to PORT command\", addr);", "send_msg(ctrl->sd, \"500 Illegal PORT command.\\r\\n\");", "return;", "}", "strlcpy(ctrl->data_address, addr, sizeof(ctrl->data_address));", "ctrl->data_port = e * 256 + f;", "DBG(\"Client PORT command accepted for %s:%d\", ctrl->data_address, ctrl->data_port);", "send_msg(ctrl->sd, \"200 PORT command successful.\\r\\n\");", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int whereIndexExprTransColumn(Walker *p, Expr *pExpr){", "if( pExpr->op==TK_COLUMN ){", "IdxExprTrans *pX = p->u.pIdxTrans;", "if( pExpr->iTable==pX->iTabCur && pExpr->iColumn==pX->iTabCol ){", "pExpr->iTable = pX->iIdxCur;", "pExpr->iColumn = pX->iIdxCol;", "pExpr->y.pTab = 0;", "}", "}", "return WRC_Continue;", "}"], "ner_tags": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["parse_char_class(Node** np, PToken* tok, UChar** src, UChar* end, ScanEnv* env)", "{", "int r, neg, len, fetched, and_start;", "OnigCodePoint v, vs;", "UChar *p;", "Node* node;", "CClassNode *cc, *prev_cc;", "CClassNode work_cc;", "enum CCSTATE state;", "enum CCVALTYPE val_type, in_type;", "int val_israw, in_israw;", "*np = NULL_NODE;", "env->parse_depth++;", "if (env->parse_depth > ParseDepthLimit)", "return ONIGERR_PARSE_DEPTH_LIMIT_OVER;", "prev_cc = (CClassNode* )NULL;", "r = fetch_token_in_cc(tok, src, end, env);", "if (r == TK_CHAR && tok->u.c == '^' && tok->escaped == 0) {", "neg = 1;", "r = fetch_token_in_cc(tok, src, end, env);", "}", "else {", "neg = 0;", "}", "if (r < 0) return r;", "if (r == TK_CC_CLOSE) {", "if (! code_exist_check((OnigCodePoint )']',", "*src, env->pattern_end, 1, env))", "return ONIGERR_EMPTY_CHAR_CLASS;", "CC_ESC_WARN(env, (UChar* )\"]\");", "r = tok->type = TK_CHAR;", "}", "*np = node = node_new_cclass();", "CHECK_NULL_RETURN_MEMERR(node);", "cc = CCLASS_(node);", "and_start = 0;", "state = CCS_START;", "p = *src;", "while (r != TK_CC_CLOSE) {", "fetched = 0;", "switch (r) {", "case TK_CHAR:", "any_char_in:", "len = ONIGENC_CODE_TO_MBCLEN(env->enc, tok->u.c);", "if (len > 1) {", "in_type = CCV_CODE_POINT;", "}", "else if (len < 0) {", "r = len;", "goto err;", "}", "else {", "in_type = CCV_SB;", "}", "v = (OnigCodePoint )tok->u.c;", "in_israw = 0;", "goto val_entry2;", "break;", "case TK_RAW_BYTE:", "if (! ONIGENC_IS_SINGLEBYTE(env->enc) && tok->base != 0) {", "int i, j;", "UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN];", "UChar* bufe = buf + ONIGENC_CODE_TO_MBC_MAXLEN;", "UChar* psave = p;", "int base = tok->base;", "buf[0] = tok->u.c;", "for (i = 1; i < ONIGENC_MBC_MAXLEN(env->enc); i++) {", "r = fetch_token_in_cc(tok, &p, end, env);", "if (r < 0) goto err;", "if (r != TK_RAW_BYTE || tok->base != base) {", "fetched = 1;", "break;", "}", "buf[i] = tok->u.c;", "}", "if (i < ONIGENC_MBC_MINLEN(env->enc)) {", "r = ONIGERR_TOO_SHORT_MULTI_BYTE_STRING;", "goto err;", "}", "for (j = i; j < ONIGENC_CODE_TO_MBC_MAXLEN; j++) buf[j] = '\\0';", "len = enclen(env->enc, buf);", "if (i < len) {", "r = ONIGERR_TOO_SHORT_MULTI_BYTE_STRING;", "goto err;", "}", "else if (i > len) {", "p = psave;", "for (i = 1; i < len; i++) {", "r = fetch_token_in_cc(tok, &p, end, env);", "}", "fetched = 0;", "}", "if (i == 1) {", "v = (OnigCodePoint )buf[0];", "goto raw_single;", "}", "else {", "v = ONIGENC_MBC_TO_CODE(env->enc, buf, bufe);", "in_type = CCV_CODE_POINT;", "}", "}", "else {", "v = (OnigCodePoint )tok->u.c;", "raw_single:", "in_type = CCV_SB;", "}", "in_israw = 1;", "goto val_entry2;", "break;", "case TK_CODE_POINT:", "v = tok->u.code;", "in_israw = 1;", "val_entry:", "len = ONIGENC_CODE_TO_MBCLEN(env->enc, v);", "if (len < 0) {", "r = len;", "goto err;", "}", "in_type = (len == 1 ? CCV_SB : CCV_CODE_POINT);", "val_entry2:", "r = next_state_val(cc, &vs, v, &val_israw, in_israw, in_type, &val_type,", "&state, env);", "if (r != 0) goto err;", "break;", "case TK_POSIX_BRACKET_OPEN:", "r = parse_posix_bracket(cc, &p, end, env);", "if (r < 0) goto err;", "if (r == 1) {", "CC_ESC_WARN(env, (UChar* )\"[\");", "p = tok->backp;", "v = (OnigCodePoint )tok->u.c;", "in_israw = 0;", "goto val_entry;", "}", "goto next_class;", "break;", "case TK_CHAR_TYPE:", "r = add_ctype_to_cc(cc, tok->u.prop.ctype, tok->u.prop.not, env);", "if (r != 0) goto err;", "next_class:", "r = next_state_class(cc, &vs, &val_type, &state, env);", "if (r != 0) goto err;", "break;", "case TK_CHAR_PROPERTY:", "{", "int ctype = fetch_char_property_to_ctype(&p, end, env);", "if (ctype < 0) {", "r = ctype;", "goto err;", "}", "r = add_ctype_to_cc(cc, ctype, tok->u.prop.not, env);", "if (r != 0) goto err;", "goto next_class;", "}", "break;", "case TK_CC_RANGE:", "if (state == CCS_VALUE) {", "r = fetch_token_in_cc(tok, &p, end, env);", "if (r < 0) goto err;", "fetched = 1;", "if (r == TK_CC_CLOSE) {", "range_end_val:", "v = (OnigCodePoint )'-';", "in_israw = 0;", "goto val_entry;", "}", "else if (r == TK_CC_AND) {", "CC_ESC_WARN(env, (UChar* )\"-\");", "goto range_end_val;", "}", "if (val_type == CCV_CLASS) {", "r = ONIGERR_UNMATCHED_RANGE_SPECIFIER_IN_CHAR_CLASS;", "goto err;", "}", "state = CCS_RANGE;", "}", "else if (state == CCS_START) {", "v = (OnigCodePoint )tok->u.c;", "in_israw = 0;", "r = fetch_token_in_cc(tok, &p, end, env);", "if (r < 0) goto err;", "fetched = 1;", "if (r == TK_CC_RANGE || and_start != 0)", "CC_ESC_WARN(env, (UChar* )\"-\");", "goto val_entry;", "}", "else if (state == CCS_RANGE) {", "CC_ESC_WARN(env, (UChar* )\"-\");", "goto any_char_in;", "}", "else {", "r = fetch_token_in_cc(tok, &p, end, env);", "if (r < 0) goto err;", "fetched = 1;", "if (r == TK_CC_CLOSE) goto range_end_val;", "else if (r == TK_CC_AND) {", "CC_ESC_WARN(env, (UChar* )\"-\");", "goto range_end_val;", "}", "if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_DOUBLE_RANGE_OP_IN_CC)) {", "CC_ESC_WARN(env, (UChar* )\"-\");", "goto range_end_val;", "}", "r = ONIGERR_UNMATCHED_RANGE_SPECIFIER_IN_CHAR_CLASS;", "goto err;", "}", "break;", "case TK_CC_CC_OPEN:", "{", "Node *anode;", "CClassNode* acc;", "r = parse_char_class(&anode, tok, &p, end, env);", "if (r != 0) {", "onig_node_free(anode);", "goto cc_open_err;", "}", "acc = CCLASS_(anode);", "r = or_cclass(cc, acc, env->enc);", "onig_node_free(anode);", "cc_open_err:", "if (r != 0) goto err;", "}", "break;", "case TK_CC_AND:", "{", "if (state == CCS_VALUE) {", "r = next_state_val(cc, &vs, 0, &val_israw, 0, val_type,", "&val_type, &state, env);", "if (r != 0) goto err;", "}", "and_start = 1;", "state = CCS_START;", "if (IS_NOT_NULL(prev_cc)) {", "r = and_cclass(prev_cc, cc, env->enc);", "if (r != 0) goto err;", "bbuf_free(cc->mbuf);", "}", "else {", "prev_cc = cc;", "cc = &work_cc;", "}", "initialize_cclass(cc);", "}", "break;", "case TK_EOT:", "r = ONIGERR_PREMATURE_END_OF_CHAR_CLASS;", "goto err;", "break;", "default:", "r = ONIGERR_PARSER_BUG;", "goto err;", "break;", "}", "if (fetched)", "r = tok->type;", "else {", "r = fetch_token_in_cc(tok, &p, end, env);", "if (r < 0) goto err;", "}", "}", "if (state == CCS_VALUE) {", "r = next_state_val(cc, &vs, 0, &val_israw, 0, val_type,", "&val_type, &state, env);", "if (r != 0) goto err;", "}", "if (IS_NOT_NULL(prev_cc)) {", "r = and_cclass(prev_cc, cc, env->enc);", "if (r != 0) goto err;", "bbuf_free(cc->mbuf);", "cc = prev_cc;", "}", "if (neg != 0)", "NCCLASS_SET_NOT(cc);", "else", "NCCLASS_CLEAR_NOT(cc);", "if (IS_NCCLASS_NOT(cc) &&", "IS_SYNTAX_BV(env->syntax, ONIG_SYN_NOT_NEWLINE_IN_NEGATIVE_CC)) {", "int is_empty = (IS_NULL(cc->mbuf) ? 1 : 0);", "if (is_empty != 0)", "BITSET_IS_EMPTY(cc->bs, is_empty);", "if (is_empty == 0) {", "#define NEWLINE_CODE    0x0a", "if (ONIGENC_IS_CODE_NEWLINE(env->enc, NEWLINE_CODE)) {", "if (ONIGENC_CODE_TO_MBCLEN(env->enc, NEWLINE_CODE) == 1)", "BITSET_SET_BIT(cc->bs, NEWLINE_CODE);", "else", "add_code_range(&(cc->mbuf), env, NEWLINE_CODE, NEWLINE_CODE);", "}", "}", "}", "*src = p;", "env->parse_depth--;", "return 0;", "err:", "if (cc != CCLASS_(*np))", "bbuf_free(cc->mbuf);", "return r;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["sd_markdown_new(", "unsigned int extensions,", "size_t max_nesting,", "size_t max_table_cols,", "const struct sd_callbacks *callbacks,", "void *opaque)", "{", "struct sd_markdown *md = NULL;", "assert(max_nesting > 0 && max_table_cols > 0 && callbacks);", "md = malloc(sizeof(struct sd_markdown));", "if (!md)", "return NULL;", "memcpy(&md->cb, callbacks, sizeof(struct sd_callbacks));", "stack_init(&md->work_bufs[BUFFER_BLOCK], 4);", "stack_init(&md->work_bufs[BUFFER_SPAN], 8);", "memset(md->active_char, 0x0, 256);", "if (md->cb.emphasis || md->cb.double_emphasis || md->cb.triple_emphasis) {", "md->active_char['*'] = MD_CHAR_EMPHASIS;", "md->active_char['_'] = MD_CHAR_EMPHASIS;", "md->active_char['>'] = MD_CHAR_EMPHASIS;", "if (extensions & MKDEXT_STRIKETHROUGH)", "md->active_char['~'] = MD_CHAR_EMPHASIS;", "}", "if (md->cb.codespan)", "md->active_char['`'] = MD_CHAR_CODESPAN;", "if (md->cb.linebreak)", "md->active_char['\\n'] = MD_CHAR_LINEBREAK;", "if (md->cb.image || md->cb.link)", "md->active_char['['] = MD_CHAR_LINK;", "md->active_char['<'] = MD_CHAR_LANGLE;", "md->active_char['\\\\'] = MD_CHAR_ESCAPE;", "md->active_char['&'] = MD_CHAR_ENTITITY;", "if (extensions & MKDEXT_AUTOLINK) {", "if (!(extensions & MKDEXT_NO_EMAIL_AUTOLINK))", "md->active_char['@'] = MD_CHAR_AUTOLINK_EMAIL;", "md->active_char[':'] = MD_CHAR_AUTOLINK_URL;", "md->active_char['w'] = MD_CHAR_AUTOLINK_WWW;", "md->active_char['/'] = MD_CHAR_AUTOLINK_SUBREDDIT_OR_USERNAME;", "}", "if (extensions & MKDEXT_SUPERSCRIPT)", "md->active_char['^'] = MD_CHAR_SUPERSCRIPT;", "md->ext_flags = extensions;", "md->opaque = opaque;", "md->max_nesting = max_nesting;", "md->max_table_cols = max_table_cols;", "md->in_link_body = 0;", "return md;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["archive_write_disk_set_acls(struct archive *a, int fd, const char *name,", "struct archive_acl *abstract_acl, __LA_MODE_T mode)", "{", "int  ret = ARCHIVE_OK;", "(void)mode;", "if ((archive_acl_types(abstract_acl)", "& ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {", "ret = set_acl(a, fd, name, abstract_acl,", "ARCHIVE_ENTRY_ACL_TYPE_POSIX1E, \"posix1e\");", "return (ret);", "}", "#if ARCHIVE_ACL_SUNOS_NFS4", "else if ((archive_acl_types(abstract_acl) &", "ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {", "ret = set_acl(a, fd, name, abstract_acl,", "ARCHIVE_ENTRY_ACL_TYPE_NFS4, \"nfs4\");", "}", "#endif", "return (ret);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["GF_Err gf_isom_get_text_description(GF_ISOFile *movie, u32 trackNumber, u32 descriptionIndex, GF_TextSampleDescriptor **out_desc)", "{", "GF_TrackBox *trak;", "u32 i;", "Bool is_qt_text = GF_FALSE;", "GF_Tx3gSampleEntryBox *txt;", "if (!descriptionIndex || !out_desc) return GF_BAD_PARAM;", "trak = gf_isom_get_track_from_file(movie, trackNumber);", "if (!trak || !trak->Media) return GF_BAD_PARAM;", "switch (trak->Media->handler->handlerType) {", "case GF_ISOM_MEDIA_TEXT:", "case GF_ISOM_MEDIA_SUBT:", "break;", "default:", "return GF_BAD_PARAM;", "}", "txt = (GF_Tx3gSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, descriptionIndex - 1);", "if (!txt) return GF_BAD_PARAM;", "switch (txt->type) {", "case GF_ISOM_BOX_TYPE_TX3G:", "break;", "case GF_ISOM_BOX_TYPE_TEXT:", "is_qt_text = GF_TRUE;", "break;", "default:", "return GF_BAD_PARAM;", "}", "(*out_desc) = (GF_TextSampleDescriptor *) gf_odf_desc_new(GF_ODF_TX3G_TAG);", "if (! (*out_desc) ) return GF_OUT_OF_MEM;", "(*out_desc)->back_color = txt->back_color;", "(*out_desc)->default_pos = txt->default_box;", "(*out_desc)->default_style = txt->default_style;", "(*out_desc)->displayFlags = txt->displayFlags;", "(*out_desc)->vert_justif = txt->vertical_justification;", "(*out_desc)->horiz_justif = txt->horizontal_justification;", "if (is_qt_text) {", "GF_TextSampleEntryBox *qt_txt = (GF_TextSampleEntryBox *) txt;", "if (qt_txt->textName) {", "(*out_desc)->font_count = 1;", "(*out_desc)->fonts = (GF_FontRecord *) gf_malloc(sizeof(GF_FontRecord));", "(*out_desc)->fonts[0].fontName = gf_strdup(qt_txt->textName);", "}", "} else {", "(*out_desc)->font_count = txt->font_table->entry_count;", "(*out_desc)->fonts = (GF_FontRecord *) gf_malloc(sizeof(GF_FontRecord) * txt->font_table->entry_count);", "for (i=0; i<txt->font_table->entry_count; i++) {", "(*out_desc)->fonts[i].fontID = txt->font_table->fonts[i].fontID;", "if (txt->font_table->fonts[i].fontName)", "(*out_desc)->fonts[i].fontName = gf_strdup(txt->font_table->fonts[i].fontName);", "}", "}", "return GF_OK;", "}"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["str_lower_case_match(OnigEncoding enc, int case_fold_flag,", "const UChar* t, const UChar* tend,", "const UChar* p, const UChar* end)", "{", "int lowlen;", "UChar *q, lowbuf[ONIGENC_MBC_CASE_FOLD_MAXLEN];", "while (t < tend) {", "lowlen = ONIGENC_MBC_CASE_FOLD(enc, case_fold_flag, &p, end, lowbuf);", "q = lowbuf;", "while (lowlen > 0) {", "if (*t++ != *q++) return 0;", "lowlen--;", "}", "}", "return 1;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["void SFS_ObjectMethodCall(ScriptParser *parser)", "{", "if (parser->codec->LastError) return;", "SFS_Expression(parser);", "SFS_AddString(parser, \".\");", "SFS_Identifier(parser);", "SFS_AddString(parser, \"(\");", "SFS_Params(parser);", "SFS_AddString(parser, \")\");", "}"], "ner_tags": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["parse_user_name(char *user_input, char **ret_username)", "{", "register char *ptr;", "register int index = 0;", "char username[PAM_MAX_RESP_SIZE];", "*ret_username = NULL;", "bzero((void *)username, PAM_MAX_RESP_SIZE);", "ptr = user_input;", "while ((*ptr == ' ') || (*ptr == '\\t'))", "ptr++;", "if (*ptr == '\\0') {", "return (PAM_BUF_ERR);", "}", "while (*ptr != '\\0') {", "if ((*ptr == ' ') || (*ptr == '\\t'))", "break;", "else {", "username[index] = *ptr;", "index++;", "ptr++;", "}", "}", "if ((*ret_username = malloc(index + 1)) == NULL)", "return (PAM_BUF_ERR);", "(void) strcpy(*ret_username, username);", "return (PAM_SUCCESS);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0]}
{"tokens": ["GF_Err Media_CheckDataEntry(GF_MediaBox *mdia, u32 dataEntryIndex)", "{", "GF_DataEntryURLBox *entry;", "GF_DataMap *map;", "GF_Err e;", "if (!mdia || !dataEntryIndex || dataEntryIndex > gf_list_count(mdia->information->dataInformation->dref->child_boxes)) return GF_BAD_PARAM;", "entry = (GF_DataEntryURLBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataEntryIndex - 1);", "if (!entry) return GF_ISOM_INVALID_FILE;", "if (entry->flags == 1) return GF_OK;", "if (entry->type == GF_ISOM_BOX_TYPE_URN) return GF_NOT_SUPPORTED;", "if (mdia->mediaTrack->moov->mov->openMode == GF_ISOM_OPEN_WRITE) {", "e = gf_isom_datamap_new(entry->location, NULL, GF_ISOM_DATA_MAP_READ, &map);", "} else {", "e = gf_isom_datamap_new(entry->location, mdia->mediaTrack->moov->mov->fileName, GF_ISOM_DATA_MAP_READ, &map);", "}", "if (e) return e;", "gf_isom_datamap_del(map);", "return GF_OK;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void fmtutil_macbitmap_read_pixmap_only_fields(deark *c, dbuf *f, struct fmtutil_macbitmap_info *bi,", "i64 pos)", "{", "i64 pixmap_version;", "i64 pack_size;", "i64 plane_bytes;", "i64 n;", "de_dbg(c, \"additional PixMap header fields, at %d\", (int)pos);", "de_dbg_indent(c, 1);", "pixmap_version = dbuf_getu16be(f, pos+0);", "de_dbg(c, \"pixmap version: %d\", (int)pixmap_version);", "bi->packing_type = dbuf_getu16be(f, pos+2);", "de_dbg(c, \"packing type: %d\", (int)bi->packing_type);", "pack_size = dbuf_getu32be(f, pos+4);", "de_dbg(c, \"pixel data length: %d\", (int)pack_size);", "bi->hdpi = pict_read_fixed(f, pos+8);", "bi->vdpi = pict_read_fixed(f, pos+12);", "de_dbg(c, \"dpi: %.2f\"DE_CHAR_TIMES\"%.2f\", bi->hdpi, bi->vdpi);", "bi->pixeltype = dbuf_getu16be(f, pos+16);", "bi->pixelsize = dbuf_getu16be(f, pos+18);", "bi->cmpcount = dbuf_getu16be(f, pos+20);", "bi->cmpsize = dbuf_getu16be(f, pos+22);", "de_dbg(c, \"pixel type=%d, bits/pixel=%d, components/pixel=%d, bits/comp=%d\",", "(int)bi->pixeltype, (int)bi->pixelsize, (int)bi->cmpcount, (int)bi->cmpsize);", "bi->pdwidth = (bi->rowbytes*8)/bi->pixelsize;", "if(bi->pdwidth < bi->npwidth) {", "bi->pdwidth = bi->npwidth;", "}", "plane_bytes = dbuf_getu32be(f, pos+24);", "de_dbg(c, \"plane bytes: %d\", (int)plane_bytes);", "bi->pmTable = (u32)dbuf_getu32be(f, pos+28);", "de_dbg(c, \"pmTable: 0x%08x\", (unsigned int)bi->pmTable);", "n = dbuf_getu32be(f, pos+32);", "de_dbg(c, \"pmReserved: 0x%08x\", (unsigned int)n);", "de_dbg_indent(c, -1);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void CleanWriters(GF_List *writers)", "{", "while (gf_list_count(writers)) {", "TrackWriter *writer = (TrackWriter*)gf_list_get(writers, 0);", "gf_isom_box_del(writer->stco);", "gf_isom_box_del((GF_Box *)writer->stsc);", "gf_free(writer);", "gf_list_rem(writers, 0);", "}", "}"], "ner_tags": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["sonmp_decode(struct lldpd *cfg, char *frame, int s,", "struct lldpd_hardware *hardware,", "struct lldpd_chassis **newchassis, struct lldpd_port **newport)", "{", "const u_int8_t mcastaddr[] = SONMP_MULTICAST_ADDR;", "struct lldpd_chassis *chassis;", "struct lldpd_port *port;", "struct lldpd_mgmt *mgmt;", "int length, i;", "u_int8_t *pos;", "u_int8_t seg[3], rchassis;", "struct in_addr address;", "log_debug(\"sonmp\", \"decode SONMP PDU from %s\",", "hardware->h_ifname);", "if ((chassis = calloc(1, sizeof(struct lldpd_chassis))) == NULL) {", "log_warn(\"sonmp\", \"failed to allocate remote chassis\");", "return -1;", "}", "TAILQ_INIT(&chassis->c_mgmt);", "if ((port = calloc(1, sizeof(struct lldpd_port))) == NULL) {", "log_warn(\"sonmp\", \"failed to allocate remote port\");", "free(chassis);", "return -1;", "}", "#ifdef ENABLE_DOT1", "TAILQ_INIT(&port->p_vlans);", "#endif", "length = s;", "pos = (u_int8_t*)frame;", "if (length < SONMP_SIZE) {", "log_warnx(\"sonmp\", \"too short SONMP frame received on %s\", hardware->h_ifname);", "goto malformed;", "}", "if (PEEK_CMP(mcastaddr, sizeof(mcastaddr)) != 0)", "goto malformed;", "PEEK_DISCARD(ETHER_ADDR_LEN); PEEK_DISCARD_UINT16;", "PEEK_DISCARD(6);", "if (PEEK_UINT16 != LLC_PID_SONMP_HELLO) {", "log_debug(\"sonmp\", \"incorrect LLC protocol ID received for SONMP on %s\",", "hardware->h_ifname);", "goto malformed;", "}", "chassis->c_id_subtype = LLDP_CHASSISID_SUBTYPE_ADDR;", "if ((chassis->c_id = calloc(1, sizeof(struct in_addr) + 1)) == NULL) {", "log_warn(\"sonmp\", \"unable to allocate memory for chassis id on %s\",", "hardware->h_ifname);", "goto malformed;", "}", "chassis->c_id_len = sizeof(struct in_addr) + 1;", "chassis->c_id[0] = 1;", "PEEK_BYTES(&address, sizeof(struct in_addr));", "memcpy(chassis->c_id + 1, &address, sizeof(struct in_addr));", "if (asprintf(&chassis->c_name, \"%s\", inet_ntoa(address)) == -1) {", "log_warnx(\"sonmp\", \"unable to write chassis name for %s\",", "hardware->h_ifname);", "goto malformed;", "}", "PEEK_BYTES(seg, sizeof(seg));", "rchassis = PEEK_UINT8;", "for (i=0; sonmp_chassis_types[i].type != 0; i++) {", "if (sonmp_chassis_types[i].type == rchassis)", "break;", "}", "if (asprintf(&chassis->c_descr, \"%s\",", "sonmp_chassis_types[i].description) == -1) {", "log_warnx(\"sonmp\", \"unable to write chassis description for %s\",", "hardware->h_ifname);", "goto malformed;", "}", "mgmt = lldpd_alloc_mgmt(LLDPD_AF_IPV4, &address, sizeof(struct in_addr), 0);", "if (mgmt == NULL) {", "assert(errno == ENOMEM);", "log_warn(\"sonmp\", \"unable to allocate memory for management address\");", "goto malformed;", "}", "TAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt, m_entries);", "chassis->c_ttl = cfg?(cfg->g_config.c_tx_interval * cfg->g_config.c_tx_hold):", "LLDPD_TTL;", "port->p_id_subtype = LLDP_PORTID_SUBTYPE_LOCAL;", "if (asprintf(&port->p_id, \"%02x-%02x-%02x\",", "seg[0], seg[1], seg[2]) == -1) {", "log_warn(\"sonmp\", \"unable to allocate memory for port id on %s\",", "hardware->h_ifname);", "goto malformed;", "}", "port->p_id_len = strlen(port->p_id);", "if ((seg[0] == 0) && (seg[1] == 0)) {", "if (asprintf(&port->p_descr, \"port %d\",", "seg[2]) == -1) {", "log_warnx(\"sonmp\", \"unable to write port description for %s\",", "hardware->h_ifname);", "goto malformed;", "}", "} else if (seg[0] == 0) {", "if (asprintf(&port->p_descr, \"port %d/%d\",", "seg[1], seg[2]) == -1) {", "log_warnx(\"sonmp\", \"unable to write port description for %s\",", "hardware->h_ifname);", "goto malformed;", "}", "} else {", "if (asprintf(&port->p_descr, \"port %x:%x:%x\",", "seg[0], seg[1], seg[2]) == -1) {", "log_warnx(\"sonmp\", \"unable to write port description for %s\",", "hardware->h_ifname);", "goto malformed;", "}", "}", "*newchassis = chassis;", "*newport = port;", "return 1;", "malformed:", "lldpd_chassis_cleanup(chassis, 1);", "lldpd_port_cleanup(port, 1);", "free(port);", "return -1;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["GF_Err iloc_box_read(GF_Box *s, GF_BitStream *bs)", "{", "u32 item_count, extent_count, i, j;", "GF_ItemLocationBox *ptr = (GF_ItemLocationBox *)s;", "ISOM_DECREASE_SIZE(ptr, 2)", "ptr->offset_size = gf_bs_read_int(bs, 4);", "ptr->length_size = gf_bs_read_int(bs, 4);", "ptr->base_offset_size = gf_bs_read_int(bs, 4);", "if (ptr->version == 1 || ptr->version == 2) {", "ptr->index_size = gf_bs_read_int(bs, 4);", "} else {", "gf_bs_read_int(bs, 4);", "}", "if (ptr->version < 2) {", "ISOM_DECREASE_SIZE(ptr, 2)", "item_count = gf_bs_read_u16(bs);", "} else {", "ISOM_DECREASE_SIZE(ptr, 4)", "item_count = gf_bs_read_u32(bs);", "}", "for (i = 0; i < item_count; i++) {", "GF_ItemLocationEntry *location_entry = (GF_ItemLocationEntry *)gf_malloc(sizeof(GF_ItemLocationEntry));", "if (!location_entry) return GF_OUT_OF_MEM;", "gf_list_add(ptr->location_entries, location_entry);", "if (ptr->version < 2) {", "ISOM_DECREASE_SIZE(ptr, 2)", "location_entry->item_ID = gf_bs_read_u16(bs);", "} else {", "ISOM_DECREASE_SIZE(ptr, 4)", "location_entry->item_ID = gf_bs_read_u32(bs);", "}", "if (ptr->version == 1 || ptr->version == 2) {", "ISOM_DECREASE_SIZE(ptr, 2)", "location_entry->construction_method = gf_bs_read_u16(bs);", "}", "else {", "location_entry->construction_method = 0;", "}", "ISOM_DECREASE_SIZE(ptr, (2 + ptr->base_offset_size) )", "location_entry->data_reference_index = gf_bs_read_u16(bs);", "location_entry->base_offset = gf_bs_read_int(bs, 8*ptr->base_offset_size);", "#ifndef GPAC_DISABLE_ISOM_WRITE", "location_entry->original_base_offset = location_entry->base_offset;", "#endif", "ISOM_DECREASE_SIZE(ptr, 2)", "extent_count = gf_bs_read_u16(bs);", "location_entry->extent_entries = gf_list_new();", "for (j = 0; j < extent_count; j++) {", "GF_ItemExtentEntry *extent_entry = (GF_ItemExtentEntry *)gf_malloc(sizeof(GF_ItemExtentEntry));", "if (!extent_entry) return GF_OUT_OF_MEM;", "gf_list_add(location_entry->extent_entries, extent_entry);", "if ((ptr->version == 1 || ptr->version == 2) && ptr->index_size > 0) {", "ISOM_DECREASE_SIZE(ptr, ptr->index_size)", "extent_entry->extent_index = gf_bs_read_int(bs, 8 * ptr->index_size);", "}", "else {", "extent_entry->extent_index = 0;", "}", "ISOM_DECREASE_SIZE(ptr, (ptr->offset_size+ptr->length_size) )", "extent_entry->extent_offset = gf_bs_read_int(bs, 8*ptr->offset_size);", "extent_entry->extent_length = gf_bs_read_int(bs, 8*ptr->length_size);", "#ifndef GPAC_DISABLE_ISOM_WRITE", "extent_entry->original_extent_offset = extent_entry->extent_offset;", "#endif", "}", "}", "return GF_OK;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["GF_Err mpgviddmx_process(GF_Filter *filter)", "{", "GF_MPGVidDmxCtx *ctx = gf_filter_get_udta(filter);", "GF_FilterPacket *pck, *dst_pck;", "u64 byte_offset;", "s64 vosh_start = -1;", "s64 vosh_end = -1;", "GF_Err e;", "char *data;", "u8 *start;", "u32 pck_size;", "s32 remain;", "if (!ctx->duration.num)", "mpgviddmx_check_dur(filter, ctx);", "pck = gf_filter_pid_get_packet(ctx->ipid);", "if (!pck) {", "if (gf_filter_pid_is_eos(ctx->ipid)) {", "mpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_TRUE);", "if (ctx->opid)", "gf_filter_pid_set_eos(ctx->opid);", "if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);", "ctx->src_pck = NULL;", "return GF_EOS;", "}", "return GF_OK;", "}", "data = (char *) gf_filter_pck_get_data(pck, &pck_size);", "byte_offset = gf_filter_pck_get_byte_offset(pck);", "start = data;", "remain = pck_size;", "if (!ctx->resume_from && ctx->timescale) {", "u64 ts = gf_filter_pck_get_cts(pck);", "if (ts != GF_FILTER_NO_TS) {", "if (!ctx->cts || !ctx->recompute_cts)", "ctx->cts = ts;", "}", "ts = gf_filter_pck_get_dts(pck);", "if (ts != GF_FILTER_NO_TS) {", "if (!ctx->dts || !ctx->recompute_cts)", "ctx->dts = ts;", "if (!ctx->prev_dts) ctx->prev_dts = ts;", "else if (ctx->prev_dts != ts) {", "u64 diff = ts;", "diff -= ctx->prev_dts;", "if (!ctx->cur_fps.den) ctx->cur_fps.den = (u32) diff;", "else if (ctx->cur_fps.den > diff)", "ctx->cur_fps.den = (u32) diff;", "}", "}", "gf_filter_pck_get_framing(pck, &ctx->input_is_au_start, &ctx->input_is_au_end);", "if (ctx->recompute_cts) ctx->input_is_au_start = GF_FALSE;", "if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);", "ctx->src_pck = pck;", "gf_filter_pck_ref_props(&ctx->src_pck);", "}", "if (!ctx->resume_from && ctx->hdr_store_size) {", "if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size) {", "ctx->hdr_store_alloc = ctx->hdr_store_size + pck_size;", "ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);", "}", "memcpy(ctx->hdr_store + ctx->hdr_store_size, data, sizeof(char)*pck_size);", "if (byte_offset != GF_FILTER_NO_BO) {", "if (byte_offset >= ctx->hdr_store_size)", "byte_offset -= ctx->hdr_store_size;", "else", "byte_offset = GF_FILTER_NO_BO;", "}", "ctx->hdr_store_size += pck_size;", "start = data = ctx->hdr_store;", "remain = pck_size = ctx->hdr_store_size;", "}", "if (ctx->resume_from) {", "if (gf_filter_pid_would_block(ctx->opid))", "return GF_OK;", "if (ctx->hdr_store_size) {", "assert(ctx->resume_from <= ctx->hdr_store_size);", "start = data = ctx->hdr_store + ctx->resume_from;", "remain = pck_size = ctx->hdr_store_size - ctx->resume_from;", "} else {", "assert(remain >= (s32) ctx->resume_from);", "start += ctx->resume_from;", "remain -= ctx->resume_from;", "}", "ctx->resume_from = 0;", "}", "if (!ctx->bs) {", "ctx->bs = gf_bs_new(start, remain, GF_BITSTREAM_READ);", "} else {", "gf_bs_reassign_buffer(ctx->bs, start, remain);", "}", "if (!ctx->vparser) {", "ctx->vparser = gf_m4v_parser_bs_new(ctx->bs, ctx->is_mpg12);", "}", "while (remain) {", "Bool full_frame;", "u8 *pck_data;", "s32 current;", "u8 sc_type, forced_sc_type=0;", "Bool sc_type_forced = GF_FALSE;", "Bool skip_pck = GF_FALSE;", "u8 ftype;", "u32 tinc;", "u64 size=0;", "u64 fstart;", "Bool is_coded;", "u32 bytes_from_store = 0;", "u32 hdr_offset = 0;", "Bool copy_last_bytes = GF_FALSE;", "if (remain<5) {", "memcpy(ctx->hdr_store, start, remain);", "ctx->bytes_in_header = remain;", "break;", "}", "current = -1;", "if (ctx->bytes_in_header) {", "memcpy(ctx->hdr_store + ctx->bytes_in_header, start, 8 - ctx->bytes_in_header);", "current = mpgviddmx_next_start_code(ctx->hdr_store, 8);", "if ((current<0) || (current >= (s32) ctx->bytes_in_header) )  {", "if (ctx->opid) {", "dst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header, &pck_data);", "if (!dst_pck) return GF_OUT_OF_MEM;", "if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);", "gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);", "gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);", "memcpy(pck_data, ctx->hdr_store, ctx->bytes_in_header);", "gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);", "if (byte_offset != GF_FILTER_NO_BO) {", "gf_filter_pck_set_byte_offset(dst_pck, byte_offset - ctx->bytes_in_header);", "}", "mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);", "}", "if (current<0) current = -1;", "else current -= ctx->bytes_in_header;", "ctx->bytes_in_header = 0;", "} else {", "hdr_offset = 4 - ctx->bytes_in_header + current;", "bytes_from_store = ctx->bytes_in_header;", "ctx->bytes_in_header = 0;", "if (!hdr_offset) {", "forced_sc_type = ctx->hdr_store[current+3];", "} else {", "forced_sc_type = start[hdr_offset-1];", "}", "sc_type_forced = GF_TRUE;", "}", "}", "if (current == -1) {", "current = mpgviddmx_next_start_code(start, remain);", "if (current<0) {", "u8 b3, b2, b1;", "if (! ctx->frame_started) {", "GF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[MPGVid] no start code in block and no frame started, discarding data\\n\" ));", "break;", "}", "size = remain;", "b3 = start[remain-3];", "b2 = start[remain-2];", "b1 = start[remain-1];", "if (!b1 || !b2 || !b3) {", "copy_last_bytes = GF_TRUE;", "assert(size >= 3);", "size -= 3;", "ctx->bytes_in_header = 3;", "}", "dst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data);", "if (!dst_pck) return GF_OUT_OF_MEM;", "if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);", "memcpy(pck_data, start, (size_t) size);", "gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);", "gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);", "gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);", "if (byte_offset != GF_FILTER_NO_BO) {", "gf_filter_pck_set_byte_offset(dst_pck, byte_offset);", "}", "mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);", "if (copy_last_bytes) {", "memcpy(ctx->hdr_store, start+remain-3, 3);", "}", "break;", "}", "}", "assert(current>=0);", "if ((vosh_start>=0) && current) {", "assert(remain>=current);", "start += current;", "remain -= current;", "current = 0;", "}", "if (!ctx->opid && current) {", "assert(remain>=current);", "start += current;", "remain -= current;", "current = 0;", "}", "if (current>0) {", "dst_pck = gf_filter_pck_new_alloc(ctx->opid, current, &pck_data);", "if (!dst_pck) return GF_OUT_OF_MEM;", "if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);", "gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);", "gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);", "gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_TRUE);", "if (bytes_from_store) {", "if (byte_offset != GF_FILTER_NO_BO) {", "gf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store);", "}", "assert(bytes_from_store>=(u32) current);", "bytes_from_store -= current;", "memcpy(pck_data, ctx->hdr_store, current);", "} else {", "if (byte_offset != GF_FILTER_NO_BO) {", "gf_filter_pck_set_byte_offset(dst_pck, byte_offset);", "}", "memcpy(pck_data, start, current);", "assert(remain>=current);", "start += current;", "remain -= current;", "current = 0;", "}", "gf_filter_pck_set_carousel_version(dst_pck, 1);", "mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);", "}", "if (sc_type_forced) {", "gf_bs_reassign_buffer(ctx->bs, start + hdr_offset, remain - hdr_offset);", "sc_type = forced_sc_type;", "} else {", "gf_bs_reassign_buffer(ctx->bs, start, remain);", "gf_bs_read_int(ctx->bs, 24);", "sc_type = gf_bs_read_int(ctx->bs, 8);", "}", "if (ctx->is_mpg12) {", "switch (sc_type) {", "case M2V_SEQ_START_CODE:", "case M2V_EXT_START_CODE:", "gf_bs_reassign_buffer(ctx->bs, start, remain);", "e = gf_m4v_parse_config(ctx->vparser, &ctx->dsi);", "if (e==GF_EOS) {", "if (vosh_start<0) vosh_start = 0;", "if (data == ctx->hdr_store) {", "memmove(ctx->hdr_store, start, remain);", "ctx->hdr_store_size = remain;", "} else {", "if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {", "ctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - vosh_start);", "ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);", "}", "memcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );", "ctx->hdr_store_size += pck_size - (u32) vosh_start;", "}", "gf_filter_pid_drop_packet(ctx->ipid);", "return GF_OK;", "} else if (e != GF_OK) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MPGVid] Failed to parse VOS header: %s\\n\", gf_error_to_string(e) ));", "} else {", "mpgviddmx_check_pid(filter, ctx, 0, NULL);", "}", "break;", "case M2V_PIC_START_CODE:", "break;", "default:", "break;", "}", "} else {", "u8 PL;", "switch (sc_type) {", "case M4V_VOS_START_CODE:", "ctx->dsi.VideoPL = (u8) gf_bs_read_u8(ctx->bs);", "vosh_start = start - (u8 *)data;", "skip_pck = GF_TRUE;", "assert(remain>=5);", "start += 5;", "remain -= 5;", "break;", "case M4V_VOL_START_CODE:", "gf_bs_reassign_buffer(ctx->bs, start, remain);", "PL = ctx->dsi.VideoPL;", "e = gf_m4v_parse_config(ctx->vparser, &ctx->dsi);", "ctx->dsi.VideoPL = PL;", "if (e==GF_EOS) {", "if (vosh_start<0) vosh_start = 0;", "if (data == ctx->hdr_store) {", "memmove(ctx->hdr_store, start, remain);", "ctx->hdr_store_size = remain;", "} else {", "if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {", "ctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - (u32) vosh_start);", "ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);", "}", "memcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );", "ctx->hdr_store_size += pck_size - (u32) vosh_start;", "}", "gf_filter_pid_drop_packet(ctx->ipid);", "return GF_OK;", "} else if (e != GF_OK) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MPGVid] Failed to parse VOS header: %s\\n\", gf_error_to_string(e) ));", "} else {", "u32 obj_size = (u32) gf_m4v_get_object_start(ctx->vparser);", "if (vosh_start<0) vosh_start = 0;", "vosh_end = start - (u8 *)data + obj_size;", "vosh_end -= vosh_start;", "mpgviddmx_check_pid(filter, ctx,(u32)  vosh_end, data+vosh_start);", "skip_pck = GF_TRUE;", "assert(remain>=(s32) obj_size);", "start += obj_size;", "remain -= obj_size;", "}", "break;", "case M4V_VOP_START_CODE:", "case M4V_GOV_START_CODE:", "break;", "case M4V_VO_START_CODE:", "case M4V_VISOBJ_START_CODE:", "default:", "if (vosh_start>=0) {", "skip_pck = GF_TRUE;", "assert(remain>=4);", "start += 4;", "remain -= 4;", "}", "break;", "}", "}", "if (skip_pck) {", "continue;", "}", "if (!ctx->opid) {", "assert(remain>=4);", "start += 4;", "remain -= 4;", "continue;", "}", "if (!ctx->is_playing) {", "ctx->resume_from = (u32) ((char *)start -  (char *)data);", "return GF_OK;", "}", "ctx->hdr_store_size = 0;", "if (ctx->in_seek) {", "u64 nb_frames_at_seek = (u64) (ctx->start_range * ctx->cur_fps.num);", "if (ctx->cts + ctx->cur_fps.den >= nb_frames_at_seek) {", "ctx->in_seek = GF_FALSE;", "}", "}", "if (remain<5)", "continue;", "gf_m4v_parser_reset(ctx->vparser, sc_type_forced ? forced_sc_type + 1 : 0);", "size = 0;", "e = gf_m4v_parse_frame(ctx->vparser, &ctx->dsi, &ftype, &tinc, &size, &fstart, &is_coded);", "if (bytes_from_store) {", "size += bytes_from_store + hdr_offset;", "}", "if ((e == GF_EOS) && !ctx->input_is_au_end) {", "u8 b3 = start[remain-3];", "u8 b2 = start[remain-2];", "u8 b1 = start[remain-1];", "if (!b1 || !b2 || !b3) {", "copy_last_bytes = GF_TRUE;", "assert(size >= 3);", "size -= 3;", "ctx->bytes_in_header = 3;", "}", "full_frame = GF_FALSE;", "} else {", "full_frame = GF_TRUE;", "}", "if (!is_coded) {", "if (ctx->forced_packed && ctx->b_frames) {", "ctx->is_packed = GF_TRUE;", "assert(remain>=size);", "start += size;", "remain -= (s32) size;", "continue;", "}", "if (ctx->vfr) {", "ctx->is_vfr = GF_TRUE;", "mpgviddmx_update_time(ctx);", "assert(remain>=size);", "start += size;", "remain -= (s32) size;", "continue;", "}", "}", "if (ftype==2) {", "ctx->b_frames++;", "ctx->nb_b++;", "} else {", "mpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_FALSE);", "ctx->last_ref_cts = ctx->cts;", "if (ctx->max_b < ctx->b_frames) ctx->max_b = ctx->b_frames;", "ctx->b_frames = 0;", "if (ftype)", "ctx->nb_p++;", "else", "ctx->nb_i++;", "}", "ctx->nb_frames++;", "dst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data);", "if (!dst_pck) return GF_OUT_OF_MEM;", "if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);", "if (bytes_from_store) {", "memcpy(pck_data, ctx->hdr_store+current, bytes_from_store);", "assert(size >= bytes_from_store);", "size -= bytes_from_store;", "if (byte_offset != GF_FILTER_NO_BO) {", "gf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store);", "}", "memcpy(pck_data + bytes_from_store, start, (size_t) size);", "} else {", "memcpy(pck_data, start, (size_t) size);", "if (byte_offset != GF_FILTER_NO_BO) {", "gf_filter_pck_set_byte_offset(dst_pck, byte_offset + start - (u8 *) data);", "}", "}", "assert(pck_data[0] == 0);", "assert(pck_data[1] == 0);", "assert(pck_data[2] == 0x01);", "gf_filter_pck_set_framing(dst_pck, GF_TRUE, (full_frame || ctx->input_is_au_end) ? GF_TRUE : GF_FALSE);", "gf_filter_pck_set_cts(dst_pck, ctx->cts);", "gf_filter_pck_set_dts(dst_pck, ctx->dts);", "if (ctx->input_is_au_start) {", "ctx->input_is_au_start = GF_FALSE;", "} else {", "gf_filter_pck_set_carousel_version(dst_pck, 1);", "}", "gf_filter_pck_set_sap(dst_pck, ftype ? GF_FILTER_SAP_NONE : GF_FILTER_SAP_1);", "gf_filter_pck_set_duration(dst_pck, ctx->cur_fps.den);", "if (ctx->in_seek) gf_filter_pck_set_seek_flag(dst_pck, GF_TRUE);", "ctx->frame_started = GF_TRUE;", "mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);", "mpgviddmx_update_time(ctx);", "if (!full_frame) {", "if (copy_last_bytes) {", "memcpy(ctx->hdr_store, start+remain-3, 3);", "}", "break;", "}", "assert(remain>=size);", "start += size;", "remain -= (s32) size;", "}", "gf_filter_pid_drop_packet(ctx->ipid);", "return GF_OK;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["int sc_pkcs15_decode_prkdf_entry(struct sc_pkcs15_card *p15card,", "struct sc_pkcs15_object *obj,", "const u8 ** buf, size_t *buflen)", "{", "sc_context_t *ctx = p15card->card->ctx;", "struct sc_pkcs15_prkey_info info;", "int r, i, gostr3410_params[3];", "struct sc_pkcs15_keyinfo_gostparams *keyinfo_gostparams;", "size_t usage_len = sizeof(info.usage);", "size_t af_len = sizeof(info.access_flags);", "struct sc_asn1_entry asn1_com_key_attr[C_ASN1_COM_KEY_ATTR_SIZE];", "struct sc_asn1_entry asn1_com_prkey_attr[C_ASN1_COM_PRKEY_ATTR_SIZE];", "struct sc_asn1_entry asn1_rsakey_attr[C_ASN1_RSAKEY_ATTR_SIZE];", "struct sc_asn1_entry asn1_prk_rsa_attr[C_ASN1_PRK_RSA_ATTR_SIZE];", "struct sc_asn1_entry asn1_dsakey_attr[C_ASN1_DSAKEY_ATTR_SIZE];", "struct sc_asn1_entry asn1_prk_dsa_attr[C_ASN1_PRK_DSA_ATTR_SIZE];", "struct sc_asn1_entry asn1_dsakey_i_p_attr[C_ASN1_DSAKEY_I_P_ATTR_SIZE];", "struct sc_asn1_entry asn1_dsakey_value_attr[C_ASN1_DSAKEY_VALUE_ATTR_SIZE];", "struct sc_asn1_entry asn1_gostr3410key_attr[C_ASN1_GOSTR3410KEY_ATTR_SIZE];", "struct sc_asn1_entry asn1_prk_gostr3410_attr[C_ASN1_PRK_GOSTR3410_ATTR_SIZE];", "struct sc_asn1_entry asn1_ecckey_attr[C_ASN1_ECCKEY_ATTR];", "struct sc_asn1_entry asn1_prk_ecc_attr[C_ASN1_PRK_ECC_ATTR];", "struct sc_asn1_entry asn1_prkey[C_ASN1_PRKEY_SIZE];", "struct sc_asn1_entry asn1_supported_algorithms[C_ASN1_SUPPORTED_ALGORITHMS_SIZE];", "struct sc_asn1_pkcs15_object rsa_prkey_obj = {obj, asn1_com_key_attr, asn1_com_prkey_attr, asn1_prk_rsa_attr};", "struct sc_asn1_pkcs15_object dsa_prkey_obj = {obj, asn1_com_key_attr, asn1_com_prkey_attr, asn1_prk_dsa_attr};", "struct sc_asn1_pkcs15_object gostr3410_prkey_obj = {obj, asn1_com_key_attr, asn1_com_prkey_attr, asn1_prk_gostr3410_attr};", "struct sc_asn1_pkcs15_object ecc_prkey_obj = { obj, asn1_com_key_attr, asn1_com_prkey_attr, asn1_prk_ecc_attr };", "sc_copy_asn1_entry(c_asn1_prkey, asn1_prkey);", "sc_copy_asn1_entry(c_asn1_supported_algorithms, asn1_supported_algorithms);", "sc_copy_asn1_entry(c_asn1_prk_rsa_attr, asn1_prk_rsa_attr);", "sc_copy_asn1_entry(c_asn1_rsakey_attr, asn1_rsakey_attr);", "sc_copy_asn1_entry(c_asn1_prk_dsa_attr, asn1_prk_dsa_attr);", "sc_copy_asn1_entry(c_asn1_dsakey_attr, asn1_dsakey_attr);", "sc_copy_asn1_entry(c_asn1_dsakey_value_attr, asn1_dsakey_value_attr);", "sc_copy_asn1_entry(c_asn1_dsakey_i_p_attr, asn1_dsakey_i_p_attr);", "sc_copy_asn1_entry(c_asn1_prk_gostr3410_attr, asn1_prk_gostr3410_attr);", "sc_copy_asn1_entry(c_asn1_gostr3410key_attr, asn1_gostr3410key_attr);", "sc_copy_asn1_entry(c_asn1_prk_ecc_attr, asn1_prk_ecc_attr);", "sc_copy_asn1_entry(c_asn1_ecckey_attr, asn1_ecckey_attr);", "sc_copy_asn1_entry(c_asn1_com_prkey_attr, asn1_com_prkey_attr);", "sc_copy_asn1_entry(c_asn1_com_key_attr, asn1_com_key_attr);", "sc_format_asn1_entry(asn1_prkey + 0, &rsa_prkey_obj, NULL, 0);", "sc_format_asn1_entry(asn1_prkey + 1, &ecc_prkey_obj, NULL, 0);", "sc_format_asn1_entry(asn1_prkey + 2, &dsa_prkey_obj, NULL, 0);", "sc_format_asn1_entry(asn1_prkey + 3, &gostr3410_prkey_obj, NULL, 0);", "sc_format_asn1_entry(asn1_prk_rsa_attr + 0, asn1_rsakey_attr, NULL, 0);", "sc_format_asn1_entry(asn1_prk_dsa_attr + 0, asn1_dsakey_attr, NULL, 0);", "sc_format_asn1_entry(asn1_prk_gostr3410_attr + 0, asn1_gostr3410key_attr, NULL, 0);", "sc_format_asn1_entry(asn1_prk_ecc_attr + 0, asn1_ecckey_attr, NULL, 0);", "sc_format_asn1_entry(asn1_rsakey_attr + 0, &info.path, NULL, 0);", "sc_format_asn1_entry(asn1_rsakey_attr + 1, &info.modulus_length, NULL, 0);", "sc_format_asn1_entry(asn1_dsakey_attr + 0, asn1_dsakey_value_attr, NULL, 0);", "sc_format_asn1_entry(asn1_dsakey_value_attr + 0, &info.path, NULL, 0);", "sc_format_asn1_entry(asn1_dsakey_value_attr + 1, asn1_dsakey_i_p_attr, NULL, 0);", "sc_format_asn1_entry(asn1_dsakey_i_p_attr + 0, &info.path, NULL, 0);", "sc_format_asn1_entry(asn1_gostr3410key_attr + 0, &info.path, NULL, 0);", "sc_format_asn1_entry(asn1_gostr3410key_attr + 1, &gostr3410_params[0], NULL, 0);", "sc_format_asn1_entry(asn1_gostr3410key_attr + 2, &gostr3410_params[1], NULL, 0);", "sc_format_asn1_entry(asn1_gostr3410key_attr + 3, &gostr3410_params[2], NULL, 0);", "sc_format_asn1_entry(asn1_ecckey_attr + 0, &info.path, NULL, 0);", "sc_format_asn1_entry(asn1_ecckey_attr + 1, &info.field_length, NULL, 0);", "sc_format_asn1_entry(asn1_com_key_attr + 0, &info.id, NULL, 0);", "sc_format_asn1_entry(asn1_com_key_attr + 1, &info.usage, &usage_len, 0);", "sc_format_asn1_entry(asn1_com_key_attr + 2, &info.native, NULL, 0);", "sc_format_asn1_entry(asn1_com_key_attr + 3, &info.access_flags, &af_len, 0);", "sc_format_asn1_entry(asn1_com_key_attr + 4, &info.key_reference, NULL, 0);", "for (i=0; i<SC_MAX_SUPPORTED_ALGORITHMS && (asn1_supported_algorithms + i)->name; i++)", "sc_format_asn1_entry(asn1_supported_algorithms + i, &info.algo_refs[i], NULL, 0);", "sc_format_asn1_entry(asn1_com_key_attr + 5, asn1_supported_algorithms, NULL, 0);", "sc_format_asn1_entry(asn1_com_prkey_attr + 0, &info.subject.value, &info.subject.len, 0);", "memset(&info, 0, sizeof(info));", "info.key_reference = -1;", "info.native = 1;", "memset(gostr3410_params, 0, sizeof(gostr3410_params));", "r = sc_asn1_decode_choice(ctx, asn1_prkey, *buf, *buflen, buf, buflen);", "if (r < 0) {", "if (asn1_com_prkey_attr->flags & SC_ASN1_PRESENT &&", "asn1_com_prkey_attr[0].flags & SC_ASN1_PRESENT) {", "free(asn1_com_prkey_attr[0].parm);", "}", "}", "if (r == SC_ERROR_ASN1_END_OF_CONTENTS)", "return r;", "LOG_TEST_RET(ctx, r, \"PrKey DF ASN.1 decoding failed\");", "if (asn1_prkey[0].flags & SC_ASN1_PRESENT) {", "obj->type = SC_PKCS15_TYPE_PRKEY_RSA;", "}", "else if (asn1_prkey[1].flags & SC_ASN1_PRESENT) {", "obj->type = SC_PKCS15_TYPE_PRKEY_EC;", "}", "else if (asn1_prkey[2].flags & SC_ASN1_PRESENT) {", "obj->type = SC_PKCS15_TYPE_PRKEY_DSA;", "if (asn1_dsakey_i_p_attr[0].flags & SC_ASN1_PRESENT)", "info.path.type = SC_PATH_TYPE_PATH_PROT;", "}", "else if (asn1_prkey[3].flags & SC_ASN1_PRESENT) {", "obj->type = SC_PKCS15_TYPE_PRKEY_GOSTR3410;", "assert(info.modulus_length == 0);", "info.modulus_length = SC_PKCS15_GOSTR3410_KEYSIZE;", "assert(info.params.len == 0);", "info.params.len = sizeof(struct sc_pkcs15_keyinfo_gostparams);", "info.params.data = malloc(info.params.len);", "if (info.params.data == NULL)", "LOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);", "assert(sizeof(*keyinfo_gostparams) == info.params.len);", "keyinfo_gostparams = info.params.data;", "keyinfo_gostparams->gostr3410 = gostr3410_params[0];", "keyinfo_gostparams->gostr3411 = gostr3410_params[1];", "keyinfo_gostparams->gost28147 = gostr3410_params[2];", "}", "else {", "sc_log(ctx, \"Neither RSA or DSA or GOSTR3410 or ECC key in PrKDF entry.\");", "LOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_ASN1_OBJECT);", "}", "if (!p15card->app || !p15card->app->ddo.aid.len)   {", "r = sc_pkcs15_make_absolute_path(&p15card->file_app->path, &info.path);", "if (r < 0) {", "sc_pkcs15_free_key_params(&info.params);", "return r;", "}", "}", "else   {", "info.path.aid = p15card->app->ddo.aid;", "}", "sc_log(ctx, \"PrivKey path '%s'\", sc_print_path(&info.path));", "if (info.key_reference < -1)", "info.key_reference += 256;", "if ((obj->flags & SC_PKCS15_CO_FLAG_PRIVATE) && (obj->auth_id.len == 0)) {", "sc_log(ctx, \"Private key %s has no auth ID - checking AccessControlRules\",", "sc_pkcs15_print_id(&info.id));", "for (i = 0; i < SC_PKCS15_MAX_ACCESS_RULES; i++) {", "if (obj->access_rules[i].access_mode &", "(SC_PKCS15_ACCESS_RULE_MODE_EXECUTE |", "SC_PKCS15_ACCESS_RULE_MODE_PSO_CDS |", "SC_PKCS15_ACCESS_RULE_MODE_PSO_DECRYPT |", "SC_PKCS15_ACCESS_RULE_MODE_INT_AUTH)) {", "if (obj->access_rules[i].auth_id.len != 0) {", "obj->auth_id = obj->access_rules[i].auth_id;", "sc_log(ctx, \"Auth ID found - %s\",", "sc_pkcs15_print_id(&obj->auth_id));", "break;", "}", "}", "}", "if (i == SC_PKCS15_MAX_ACCESS_RULES)", "sc_log(ctx, \"Warning: No auth ID found\");", "}", "obj->data = malloc(sizeof(info));", "if (obj->data == NULL) {", "sc_pkcs15_free_key_params(&info.params);", "LOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);", "}", "memcpy(obj->data, &info, sizeof(info));", "sc_log(ctx, \"Key Subject %s\", sc_dump_hex(info.subject.value, info.subject.len));", "sc_log(ctx, \"Key path %s\", sc_print_path(&info.path));", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void SFS_ArrayDeref(ScriptParser *parser)", "{", "if (parser->codec->LastError) return;", "SFS_Expression(parser);", "SFS_AddString(parser, \"[\");", "SFS_CompoundExpression(parser);", "SFS_AddString(parser, \"]\");", "}"], "ner_tags": [0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["GF_Err infe_box_read(GF_Box *s, GF_BitStream *bs)", "{", "char *buf;", "u32 buf_len, i, string_len, string_start;", "GF_ItemInfoEntryBox *ptr = (GF_ItemInfoEntryBox *)s;", "ISOM_DECREASE_SIZE(ptr, 4);", "ptr->item_ID = gf_bs_read_u16(bs);", "ptr->item_protection_index = gf_bs_read_u16(bs);", "if (ptr->version == 2) {", "ISOM_DECREASE_SIZE(ptr, 4);", "ptr->item_type = gf_bs_read_u32(bs);", "}", "buf_len = (u32) (ptr->size);", "buf = (char*)gf_malloc(buf_len);", "if (!buf) return GF_OUT_OF_MEM;", "if (buf_len != gf_bs_read_data(bs, buf, buf_len)) {", "gf_free(buf);", "return GF_ISOM_INVALID_FILE;", "}", "string_len = 1;", "string_start = 0;", "for (i = 0; i < buf_len; i++) {", "if (buf[i] == 0) {", "if (!ptr->item_name) {", "ptr->item_name = (char*)gf_malloc(sizeof(char)*string_len);", "if (!ptr->item_name) return GF_OUT_OF_MEM;", "memcpy(ptr->item_name, buf+string_start, string_len);", "} else if (!ptr->content_type) {", "ptr->content_type = (char*)gf_malloc(sizeof(char)*string_len);", "if (!ptr->content_type) return GF_OUT_OF_MEM;", "memcpy(ptr->content_type, buf+string_start, string_len);", "} else {", "ptr->content_encoding = (char*)gf_malloc(sizeof(char)*string_len);", "if (!ptr->content_encoding) return GF_OUT_OF_MEM;", "memcpy(ptr->content_encoding, buf+string_start, string_len);", "}", "string_start += string_len;", "string_len = 0;", "if (ptr->content_encoding && ptr->version == 1) {", "break;", "}", "}", "string_len++;", "}", "gf_free(buf);", "if (!ptr->item_name || (!ptr->content_type && ptr->version < 2)) {", "GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isoff] Infe without name or content type !\\n\"));", "}", "return GF_OK;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static void labeljumps(JF, js_JumpList *jump, int baddr, int caddr)", "{", "while (jump) {", "if (jump->type == STM_BREAK)", "labelto(J, F, jump->inst, baddr);", "if (jump->type == STM_CONTINUE)", "labelto(J, F, jump->inst, caddr);", "jump = jump->next;", "}", "}"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 1, 0, 0]}
{"tokens": ["static void nhmldump_send_header(GF_NHMLDumpCtx *ctx)", "{", "GF_FilterPacket *dst_pck;", "char nhml[1024];", "u32 size;", "u8 *output;", "const GF_PropertyValue *p;", "ctx->szRootName = \"NHNTStream\";", "if (ctx->dims) {", "ctx->szRootName = \"DIMSStream\";", "}", "if (!ctx->filep) {", "sprintf(nhml, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n\");", "gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));", "}", "sprintf(nhml, \"<%s version=\\\"1.0\\\" \", ctx->szRootName);", "gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));", "NHML_PRINT_UINT(GF_PROP_PID_ID, NULL, \"trackID\")", "NHML_PRINT_UINT(GF_PROP_PID_TIMESCALE, NULL, \"timeScale\")", "p = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_IN_IOD);", "if (p && p->value.boolean) {", "sprintf(nhml, \"inRootOD=\\\"yes\\\" \");", "gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));", "}", "if (ctx->oti && (ctx->oti<GF_CODECID_LAST_MPEG4_MAPPING)) {", "sprintf(nhml, \"streamType=\\\"%d\\\" objectTypeIndication=\\\"%d\\\" \", ctx->streamtype, ctx->oti);", "gf_bs_write_data(ctx->bs_w, nhml, (u32)strlen(nhml));", "} else {", "p = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_SUBTYPE);", "if (p) {", "sprintf(nhml, \"%s=\\\"%s\\\" \", \"mediaType\", gf_4cc_to_str(p->value.uint));", "gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));", "NHML_PRINT_4CC(GF_PROP_PID_ISOM_SUBTYPE, \"mediaSubType\", \"mediaSubType\")", "} else {", "NHML_PRINT_4CC(GF_PROP_PID_CODECID, NULL, \"codecID\")", "}", "}", "if (ctx->w && ctx->h) {", "switch (ctx->streamtype) {", "case GF_STREAM_VISUAL:", "case GF_STREAM_SCENE:", "sprintf(nhml, \"width=\\\"%d\\\" height=\\\"%d\\\" \", ctx->w, ctx->h);", "gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));", "break;", "default:", "break;", "}", "}", "else if (ctx->sr && ctx->chan) {", "sprintf(nhml, \"sampleRate=\\\"%d\\\" numChannels=\\\"%d\\\" \", ctx->sr, ctx->chan);", "gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));", "sprintf(nhml, \"sampleRate=\\\"%d\\\" numChannels=\\\"%d\\\" \", ctx->sr, ctx->chan);", "gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));", "p = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_AUDIO_FORMAT);", "sprintf(nhml, \"bitsPerSample=\\\"%d\\\" \", gf_audio_fmt_bit_depth(p->value.uint));", "gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));", "}", "NHML_PRINT_4CC(0, \"codec_vendor\", \"codecVendor\")", "NHML_PRINT_UINT(0, \"codec_version\", \"codecVersion\")", "NHML_PRINT_UINT(0, \"codec_revision\", \"codecRevision\")", "NHML_PRINT_STRING(0, \"compressor_name\", \"compressorName\")", "NHML_PRINT_UINT(0, \"temporal_quality\", \"temporalQuality\")", "NHML_PRINT_UINT(0, \"spatial_quality\", \"spatialQuality\")", "NHML_PRINT_UINT(0, \"hres\", \"horizontalResolution\")", "NHML_PRINT_UINT(0, \"vres\", \"verticalResolution\")", "NHML_PRINT_UINT(GF_PROP_PID_BIT_DEPTH_Y, NULL, \"bitDepth\")", "NHML_PRINT_STRING(0, \"meta:xmlns\", \"xml_namespace\")", "NHML_PRINT_STRING(0, \"meta:schemaloc\", \"xml_schema_location\")", "NHML_PRINT_STRING(0, \"meta:mime\", \"mime_type\")", "NHML_PRINT_STRING(0, \"meta:config\", \"config\")", "NHML_PRINT_STRING(0, \"meta:aux_mimes\", \"aux_mime_type\")", "if (ctx->codecid == GF_CODECID_DIMS) {", "if (gf_filter_pid_get_property_str(ctx->ipid, \"meta:xmlns\")==NULL) {", "sprintf(nhml, \"xmlns=\\\"http:www.3gpp.org/richmedia\\\" \");", "gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));", "}", "NHML_PRINT_UINT(0, \"dims:profile\", \"profile\")", "NHML_PRINT_UINT(0, \"dims:level\", \"level\")", "NHML_PRINT_UINT(0, \"dims:pathComponents\", \"pathComponents\")", "p = gf_filter_pid_get_property_str(ctx->ipid, \"dims:fullRequestHost\");", "if (p) {", "sprintf(nhml, \"useFullRequestHost=\\\"%s\\\" \", p->value.boolean ? \"yes\" : \"no\");", "gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));", "}", "p = gf_filter_pid_get_property_str(ctx->ipid, \"dims:streamType\");", "if (p) {", "sprintf(nhml, \"stream_type=\\\"%s\\\" \", p->value.boolean ? \"primary\" : \"secondary\");", "gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));", "}", "p = gf_filter_pid_get_property_str(ctx->ipid, \"dims:redundant\");", "if (p) {", "sprintf(nhml, \"contains_redundant=\\\"%s\\\" \", (p->value.uint==1) ? \"main\" : ((p->value.uint==1) ? \"redundant\" : \"main+redundant\") );", "gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));", "}", "NHML_PRINT_UINT(0, \"dims:scriptTypes\", \"scriptTypes\")", "}", "if (ctx->opid_info) {", "sprintf(nhml, \"specificInfoFile=\\\"%s\\\" \", gf_file_basename(ctx->info_file) );", "gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));", "dst_pck = gf_filter_pck_new_shared(ctx->opid_info, ctx->dcfg, ctx->dcfg_size, NULL);", "gf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);", "gf_filter_pck_set_readonly(dst_pck);", "gf_filter_pck_send(dst_pck);", "}", "NHML_PRINT_STRING(0, \"meta:encoding\", \"encoding\")", "NHML_PRINT_STRING(0, \"meta:contentEncoding\", \"content_encoding\")", "ctx->uncompress = GF_FALSE;", "if (p) {", "if (!strcmp(p->value.string, \"deflate\")) ctx->uncompress = GF_TRUE;", "else {", "GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[NHMLMx] content_encoding %s not supported\\n\", p->value.string ));", "}", "}", "if (ctx->opid_mdia) {", "sprintf(nhml, \"baseMediaFile=\\\"%s\\\" \", gf_file_basename(ctx->media_file) );", "gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));", "}", "sprintf(nhml, \">\\n\");", "gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));", "gf_bs_get_content_no_truncate(ctx->bs_w, &ctx->nhml_buffer, &size, &ctx->nhml_buffer_size);", "if (ctx->filep) {", "gf_fwrite(ctx->nhml_buffer, size, ctx->filep);", "return;", "}", "dst_pck = gf_filter_pck_new_alloc(ctx->opid_nhml, size, &output);", "memcpy(output, ctx->nhml_buffer, size);", "gf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_FALSE);", "gf_filter_pck_send(dst_pck);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static void *gp_worker_main(void *pvt)", "{", "struct gp_thread *t = (struct gp_thread *)pvt;", "struct gp_query *q = NULL;", "char dummy = 0;", "int ret;", "while (!t->pool->shutdown) {", "gp_debug_set_conn_id(0);", "pthread_mutex_lock(&t->cond_mutex);", "while (t->query == NULL) {", "pthread_cond_wait(&t->cond_wakeup, &t->cond_mutex);", "if (t->pool->shutdown) {", "pthread_exit(NULL);", "}", "}", "q = t->query;", "t->query = NULL;", "pthread_mutex_unlock(&t->cond_mutex);", "gp_debug_set_conn_id(gp_conn_get_cid(q->conn));", "GPDEBUGN(3, \"[status] Handling query input: %p (%zu)\\n\", q->buffer,", "q->buflen);", "gp_handle_query(t->pool, q);", "GPDEBUGN(3 ,\"[status] Handling query output: %p (%zu)\\n\", q->buffer,", "q->buflen);", "pthread_mutex_lock(&t->pool->lock);", "q->next = t->pool->reply_list;", "t->pool->reply_list = q;", "if (!t->pool->shutdown) {", "LIST_DEL(t->pool->busy_list, t);", "LIST_ADD(t->pool->free_list, t);", "}", "pthread_mutex_unlock(&t->pool->lock);", "ret = write(t->pool->sig_pipe[1], &dummy, 1);", "if (ret == -1) {", "GPERROR(\"Failed to signal dispatcher!\");", "}", "}", "pthread_exit(NULL);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int cbs_av1_read_uvlc(CodedBitstreamContext *ctx, GetBitContext *gbc,", "const char *name, uint32_t *write_to,", "uint32_t range_min, uint32_t range_max)", "{", "uint32_t value;", "int position, zeroes, i, j;", "char bits[65];", "if (ctx->trace_enable)", "position = get_bits_count(gbc);", "zeroes = i = 0;", "while (1) {", "if (get_bits_left(gbc) < zeroes + 1) {", "av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid uvlc code at \"", "\"%s: bitstream ended.\\n\", name);", "return AVERROR_INVALIDDATA;", "}", "if (get_bits1(gbc)) {", "bits[i++] = '1';", "break;", "} else {", "bits[i++] = '0';", "++zeroes;", "}", "}", "if (zeroes >= 32) {", "value = MAX_UINT_BITS(32);", "} else {", "value = get_bits_long(gbc, zeroes);", "for (j = 0; j < zeroes; j++)", "bits[i++] = (value >> (zeroes - j - 1) & 1) ? '1' : '0';", "value += (1 << zeroes) - 1;", "}", "if (ctx->trace_enable) {", "bits[i] = 0;", "ff_cbs_trace_syntax_element(ctx, position, name, NULL,", "bits, value);", "}", "if (value < range_min || value > range_max) {", "av_log(ctx->log_ctx, AV_LOG_ERROR, \"%s out of range: \"", "\"%\"PRIu32\", but must be in [%\"PRIu32\",%\"PRIu32\"].\\n\",", "name, value, range_min, range_max);", "return AVERROR_INVALIDDATA;", "}", "*write_to = value;", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["int   MirrorJob::Do()", "{", "int  res;", "int  m=STALL;", "FileInfo *file;", "Job  *j;", "switch(state)", "{", "case(INITIAL_STATE):", "remove_this_source_dir=(remove_source_dirs && source_dir.last_char()!='/');", "if(!strcmp(target_dir,\".\") || !strcmp(target_dir,\"..\") || (FlagSet(SCAN_ALL_FIRST) && parent_mirror))", "create_target_dir=false;", "source_session->Chdir(source_dir);", "source_redirections=0;", "source_session->Roll();", "set_state(CHANGING_DIR_SOURCE);", "m=MOVED;", "case(CHANGING_DIR_SOURCE):", "HandleChdir(source_session,source_redirections);", "if(state!=CHANGING_DIR_SOURCE)", "return MOVED;", "if(source_session->IsOpen())", "return m;", "source_dir.set(source_session->GetCwd().GetDirectory());", "pre_MAKE_TARGET_DIR:", "{", "if(!create_target_dir)", "goto pre_CHANGING_DIR_TARGET;", "if(target_is_local)", "{", "struct stat st;", "if((FlagSet(RETR_SYMLINKS)?stat:lstat)(target_dir,&st)!=-1)", "{", "if(S_ISDIR(st.st_mode))", "{", "if(!script_only && (st.st_mode!=(st.st_mode|0700)))", "chmod(target_dir,st.st_mode|0700);", "create_target_dir=false;", "goto pre_CHANGING_DIR_TARGET;", "}", "else", "{", "Report(_(\"Removing old local file `%s'\"),target_dir.get());", "if(script)", "{", "ArgV args(\"rm\");", "args.Append(target_session->GetFileURL(target_dir));", "xstring_ca cmd(args.CombineQuoted());", "fprintf(script,\"%s\\n\",cmd.get());", "}", "if(!script_only)", "{", "if(remove(target_dir)==-1)", "eprintf(\"mirror: remove(%s): %s\\n\",target_dir.get(),strerror(errno));", "}", "}", "}", "}", "if(FlagSet(DEPTH_FIRST))", "goto pre_GETTING_LIST_INFO;", "if(target_relative_dir)", "Report(_(\"Making directory `%s'\"),target_relative_dir.get());", "bool mkdir_p=(parent_mirror==0 || parent_mirror->create_target_dir);", "if(script)", "{", "ArgV args(\"mkdir\");", "if(mkdir_p)", "args.Append(\"-p\");", "args.Append(target_session->GetFileURL(target_dir));", "xstring_ca cmd(args.CombineQuoted());", "fprintf(script,\"%s\\n\",cmd.get());", "if(script_only)", "goto pre_CHANGING_DIR_TARGET;", "}", "target_session->Mkdir(target_dir,mkdir_p);", "set_state(MAKE_TARGET_DIR);", "m=MOVED;", "}", "case(MAKE_TARGET_DIR):", "res=target_session->Done();", "if(res==FA::IN_PROGRESS)", "return m;", "target_session->Close();", "create_target_dir=false;", "pre_CHANGING_DIR_TARGET:", "target_session->Chdir(target_dir);", "target_redirections=0;", "target_session->Roll();", "set_state(CHANGING_DIR_TARGET);", "m=MOVED;", "case(CHANGING_DIR_TARGET):", "HandleChdir(target_session,target_redirections);", "if(state!=CHANGING_DIR_TARGET)", "return MOVED;", "if(target_session->IsOpen())", "return m;", "create_target_dir=false;", "target_dir.set(target_session->GetCwd().GetDirectory());", "pre_GETTING_LIST_INFO:", "set_state(GETTING_LIST_INFO);", "m=MOVED;", "if(!source_set)", "HandleListInfoCreation(source_session,source_list_info,source_relative_dir);", "if(!target_set && !create_target_dir", "&& (!FlagSet(DEPTH_FIRST) || FlagSet(ONLY_EXISTING))", "&& !(FlagSet(TARGET_FLAT) && parent_mirror))", "HandleListInfoCreation(target_session,target_list_info,target_relative_dir);", "if(state!=GETTING_LIST_INFO)", "{", "source_list_info=0;", "target_list_info=0;", "}", "return m;", "case(GETTING_LIST_INFO):", "HandleListInfo(source_list_info,source_set);", "HandleListInfo(target_list_info,target_set,&target_set_excluded);", "if(state!=GETTING_LIST_INFO)", "return MOVED;", "if(source_list_info || target_list_info)", "return m;", "MirrorFinished();", "if(FlagSet(DEPTH_FIRST) && source_set && !target_set)", "{", "InitSets();", "to_transfer->Unsort();", "to_transfer->SubtractNotDirs();", "goto pre_WAITING_FOR_TRANSFER;", "}", "if(parent_mirror)", "stats.dirs++;", "if(FlagSet(SCAN_ALL_FIRST) && parent_mirror)", "{", "source_set->PrependPath(source_relative_dir);", "if(root_mirror->source_set_recursive)", "root_mirror->source_set_recursive->Merge(source_set);", "else", "root_mirror->source_set_recursive=source_set.borrow();", "if(target_set) {", "target_set->PrependPath(target_relative_dir);", "if(root_mirror->target_set_recursive)", "root_mirror->target_set_recursive->Merge(target_set);", "else", "root_mirror->target_set_recursive=target_set.borrow();", "}", "if(target_set_excluded) {", "target_set_excluded->PrependPath(target_relative_dir);", "if(root_mirror->target_set_excluded)", "root_mirror->target_set_excluded->Merge(target_set_excluded);", "else", "root_mirror->target_set_excluded=target_set_excluded.borrow();", "}", "root_mirror->stats.dirs++;", "transfer_count++;", "goto pre_DONE;", "}", "if(source_set_recursive) {", "source_set->Merge(source_set_recursive);", "source_set_recursive=0;", "}", "if(target_set_recursive) {", "target_set->Merge(target_set_recursive);", "target_set_recursive=0;", "}", "InitSets();", "to_transfer->CountBytes(&bytes_to_transfer);", "if(parent_mirror)", "parent_mirror->AddBytesToTransfer(bytes_to_transfer);", "to_rm->Count(&stats.del_dirs,&stats.del_files,&stats.del_symlinks,&stats.del_files);", "to_rm->rewind();", "to_rm_mismatched->Count(&stats.del_dirs,&stats.del_files,&stats.del_symlinks,&stats.del_files);", "to_rm_mismatched->rewind();", "target_set->Merge(target_set_excluded);", "target_set_excluded=0;", "set_state(TARGET_REMOVE_OLD_FIRST);", "goto TARGET_REMOVE_OLD_FIRST_label;", "pre_TARGET_MKDIR:", "if(!to_mkdir)", "goto pre_WAITING_FOR_TRANSFER;", "to_mkdir->rewind();", "set_state(TARGET_MKDIR);", "m=MOVED;", "case(TARGET_MKDIR):", "while((j=FindDoneAwaitedJob())!=0)", "{", "JobFinished(j);", "m=MOVED;", "}", "if(max_error_count>0 && stats.error_count>=max_error_count)", "goto pre_FINISHING;", "while(transfer_count<parallel && state==TARGET_MKDIR)", "{", "file=to_mkdir->curr();", "if(!file)", "goto pre_WAITING_FOR_TRANSFER;", "to_mkdir->next();", "if(!file->TypeIs(file->DIRECTORY))", "continue;", "if(script)", "fprintf(script,\"mkdir %s\\n\",target_session->GetFileURL(file->name).get());", "if(!script_only)", "{", "ArgV *a=new ArgV(\"mkdir\");", "a->Append(file->name);", "mkdirJob *mkj=new mkdirJob(target_session->Clone(),a);", "a->CombineTo(mkj->cmdline);", "JobStarted(mkj);", "m=MOVED;", "}", "}", "break;", "pre_WAITING_FOR_TRANSFER:", "to_transfer->rewind();", "set_state(WAITING_FOR_TRANSFER);", "m=MOVED;", "case(WAITING_FOR_TRANSFER):", "while((j=FindDoneAwaitedJob())!=0)", "{", "TransferFinished(j);", "m=MOVED;", "}", "if(max_error_count>0 && stats.error_count>=max_error_count)", "goto pre_FINISHING;", "while(transfer_count<parallel && state==WAITING_FOR_TRANSFER)", "{", "file=to_transfer->curr();", "if(!file)", "{", "if(waiting_num>0)", "break;", "if(FlagSet(DEPTH_FIRST))", "{", "SetFlags(DEPTH_FIRST,false);", "SetFlags(NO_RECURSION,true);", "if(FlagSet(NO_EMPTY_DIRS) && stats.dirs==0 && only_dirs)", "goto pre_FINISHING_FIX_LOCAL;", "MirrorStarted();", "goto pre_MAKE_TARGET_DIR;", "}", "goto pre_TARGET_REMOVE_OLD;", "}", "HandleFile(file);", "to_transfer->next();", "m=MOVED;", "}", "break;", "pre_TARGET_REMOVE_OLD:", "if(FlagSet(REMOVE_FIRST))", "goto pre_TARGET_CHMOD;", "set_state(TARGET_REMOVE_OLD);", "m=MOVED;", "case(TARGET_REMOVE_OLD):", "case(TARGET_REMOVE_OLD_FIRST):", "TARGET_REMOVE_OLD_FIRST_label:", "while((j=FindDoneAwaitedJob())!=0)", "{", "JobFinished(j);", "m=MOVED;", "}", "if(max_error_count>0 && stats.error_count>=max_error_count)", "goto pre_FINISHING;", "while(transfer_count<parallel && (state==TARGET_REMOVE_OLD || state==TARGET_REMOVE_OLD_FIRST))", "{", "file=0;", "if(!file && state==TARGET_REMOVE_OLD_FIRST)", "{", "file=to_rm_mismatched->curr();", "to_rm_mismatched->next();", "}", "if(!file && (state==TARGET_REMOVE_OLD || FlagSet(REMOVE_FIRST)))", "{", "file=to_rm->curr();", "to_rm->next();", "}", "if(!file)", "{", "if(waiting_num>0)", "break;", "if(state==TARGET_REMOVE_OLD)", "goto pre_TARGET_CHMOD;", "goto pre_TARGET_MKDIR;", "}", "if(!FlagSet(DELETE))", "{", "if(FlagSet(REPORT_NOT_DELETED))", "{", "const char *target_name_rel=dir_file(target_relative_dir,file->name);", "if(file->TypeIs(file->DIRECTORY))", "Report(_(\"Old directory `%s' is not removed\"),target_name_rel);", "else", "Report(_(\"Old file `%s' is not removed\"),target_name_rel);", "}", "continue;", "}", "if(script)", "{", "ArgV args(\"rm\");", "if(file->TypeIs(file->DIRECTORY))", "{", "if(recursion_mode==RECURSION_NEVER)", "args.setarg(0,\"rmdir\");", "else", "args.Append(\"-r\");", "}", "args.Append(target_session->GetFileURL(file->name));", "xstring_ca cmd(args.CombineQuoted());", "fprintf(script,\"%s\\n\",cmd.get());", "}", "if(!script_only)", "{", "ArgV *args=new ArgV(\"rm\");", "args->Append(file->name);", "args->seek(1);", "rmJob *j=new rmJob(target_session->Clone(),args);", "args->CombineTo(j->cmdline);", "JobStarted(j);", "if(file->TypeIs(file->DIRECTORY))", "{", "if(recursion_mode==RECURSION_NEVER)", "{", "args->setarg(0,\"rmdir\");", "j->Rmdir();", "}", "else", "j->Recurse();", "}", "}", "const char *target_name_rel=dir_file(target_relative_dir,file->name);", "if(file->TypeIs(file->DIRECTORY))", "Report(_(\"Removing old directory `%s'\"),target_name_rel);", "else", "Report(_(\"Removing old file `%s'\"),target_name_rel);", "}", "break;", "pre_TARGET_CHMOD:", "if(FlagSet(NO_PERMS))", "goto pre_FINISHING_FIX_LOCAL;", "to_transfer->rewind();", "if(FlagSet(TARGET_FLAT))", "to_transfer->Sort(FileSet::BYNAME_FLAT);", "set_state(TARGET_CHMOD);", "m=MOVED;", "case(TARGET_CHMOD):", "while((j=FindDoneAwaitedJob())!=0)", "{", "JobFinished(j);", "m=MOVED;", "}", "if(max_error_count>0 && stats.error_count>=max_error_count)", "goto pre_FINISHING;", "while(transfer_count<parallel && state==TARGET_CHMOD)", "{", "file=to_transfer->curr();", "if(!file)", "goto pre_FINISHING_FIX_LOCAL;", "to_transfer->next();", "if(file->TypeIs(file->SYMLINK))", "continue;", "if(!file->Has(file->MODE))", "continue;", "mode_t mode_mask=get_mode_mask();", "mode_t def_mode=(file->TypeIs(file->DIRECTORY)?0775:0664)&~mode_mask;", "if(target_is_local && file->mode==def_mode)", "{", "struct stat st;", "if(!target_is_local || lstat(dir_file(target_dir,file->name),&st)==-1)", "continue;", "if((st.st_mode&07777)==(file->mode&~mode_mask))", "continue;", "}", "FileInfo *target=target_set->FindByName(file->name);", "if(target && target->filetype==file->DIRECTORY && file->filetype==file->DIRECTORY", "&& target->mode==(file->mode&~mode_mask) && (target->mode&0200))", "continue;", "if(script)", "{", "ArgV args(\"chmod\");", "args.Append(xstring::format(\"%03lo\",(unsigned long)(file->mode&~mode_mask)));", "args.Append(target_session->GetFileURL(file->name));", "xstring_ca cmd(args.CombineQuoted());", "fprintf(script,\"%s\\n\",cmd.get());", "}", "if(!script_only)", "{", "ArgV *a=new ArgV(\"chmod\");", "a->Append(file->name);", "a->seek(1);", "ChmodJob *cj=new ChmodJob(target_session->Clone(),", "file->mode&~mode_mask,a);", "a->CombineTo(cj->cmdline);", "if(!verbose_report)", "cj->BeQuiet();", "JobStarted(cj);", "m=MOVED;", "}", "}", "break;", "pre_FINISHING_FIX_LOCAL:", "if(target_is_local && !script_only)", "{", "const bool flat=FlagSet(TARGET_FLAT);", "to_transfer->Sort(FileSet::BYNAME_FLAT);", "to_transfer->LocalUtime(target_dir,              true,flat);", "if(FlagSet(ALLOW_CHOWN))", "to_transfer->LocalChown(target_dir,flat);", "if(!FlagSet(NO_PERMS) && same)", "same->LocalChmod(target_dir,get_mode_mask(),flat);", "if(FlagSet(ALLOW_CHOWN) && same)", "same->LocalChown(target_dir,flat);", "}", "if(remove_source_files && (same || to_rm_src))", "goto pre_SOURCE_REMOVING_SAME;", "pre_FINISHING:", "set_state(FINISHING);", "m=MOVED;", "case(FINISHING):", "while((j=FindDoneAwaitedJob())!=0)", "{", "JobFinished(j);", "m=MOVED;", "}", "if(waiting_num>0)", "break;", "if(remove_this_source_dir) {", "remove_this_source_dir=false;", "if(script)", "{", "ArgV args(\"rmdir\");", "args.Append(source_session->GetFileURL(source_dir));", "xstring_ca cmd(args.CombineQuoted());", "fprintf(script,\"%s\\n\",cmd.get());", "}", "if(!script_only)", "{", "ArgV *args=new ArgV(\"rmdir\");", "args->Append(source_dir);", "args->seek(1);", "rmJob *j=new rmJob(source_session->Clone(),args);", "args->CombineTo(j->cmdline);", "j->Rmdir();", "JobStarted(j);", "}", "if(source_relative_dir)", "Report(_(\"Removing source directory `%s'\"),source_relative_dir.get());", "m=MOVED;", "break;", "}", "transfer_count++;", "if(parent_mirror)", "parent_mirror->stats.Add(stats);", "else", "{", "if(stats.HaveSomethingDone(flags) && on_change)", "{", "CmdExec *exec=new CmdExec(source_session->Clone(),0);", "AddWaiting(exec);", "exec->FeedCmd(on_change);", "exec->FeedCmd(\"\\n\");", "set_state(LAST_EXEC);", "break;", "}", "}", "goto pre_DONE;", "pre_SOURCE_REMOVING_SAME:", "if(!same)", "same=to_rm_src.borrow();", "else if(to_rm_src)", "same->Merge(to_rm_src);", "same->rewind();", "set_state(SOURCE_REMOVING_SAME);", "m=MOVED;", "case(SOURCE_REMOVING_SAME):", "while((j=FindDoneAwaitedJob())!=0)", "{", "JobFinished(j);", "m=MOVED;", "}", "if(max_error_count>0 && stats.error_count>=max_error_count)", "goto pre_FINISHING;", "while(transfer_count<parallel && state==SOURCE_REMOVING_SAME)", "{", "file=same->curr();", "same->next();", "if(!file)", "goto pre_FINISHING;", "if(file->TypeIs(file->DIRECTORY))", "continue;", "if(script)", "{", "ArgV args(\"rm\");", "args.Append(source_session->GetFileURL(file->name));", "xstring_ca cmd(args.CombineQuoted());", "fprintf(script,\"%s\\n\",cmd.get());", "}", "if(!script_only)", "{", "ArgV *args=new ArgV(\"rm\");", "args->Append(file->name);", "args->seek(1);", "rmJob *j=new rmJob(source_session->Clone(),args);", "args->CombineTo(j->cmdline);", "JobStarted(j);", "}", "const char *source_name_rel=dir_file(source_relative_dir,file->name);", "Report(_(\"Removing source file `%s'\"),source_name_rel);", "}", "break;", "case(LAST_EXEC):", "while((j=FindDoneAwaitedJob())!=0)", "{", "RemoveWaiting(j);", "Delete(j);", "m=MOVED;", "}", "if(waiting_num>0)", "break;", "pre_DONE:", "set_state(DONE);", "m=MOVED;", "bytes_transferred=0;", "if(!parent_mirror && FlagSet(LOOP) && stats.HaveSomethingDone(flags) && !stats.error_count)", "{", "PrintStatus(0,\"\");", "printf(_(\"Retrying mirror...\\n\"));", "stats.Reset();", "source_set=0;", "target_set=0;", "goto pre_GETTING_LIST_INFO;", "}", "case(DONE):", "break;", "}", "if(transfer_count<parallel && parent_mirror)", "m|=parent_mirror->Roll();", "return m;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["switchGroup(uid_t uid, const struct passwd *userInfo, gid_t gid) {", "if (userInfo != NULL) {", "bool setgroupsCalled = false;", "#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__)", "#ifdef __APPLE__", "int groups[1024];", "int ngroups = sizeof(groups) / sizeof(int);", "#else", "gid_t groups[1024];", "int ngroups = sizeof(groups) / sizeof(gid_t);", "#endif", "boost::scoped_array<gid_t> gidset;", "int ret = getgrouplist(userInfo->pw_name, gid,", "groups, &ngroups);", "if (ret == -1) {", "int e = errno;", "fprintf(stderr, \"ERROR: getgrouplist(%s, %d) failed: %s (errno=%d)\\n\",", "userInfo->pw_name, (int) gid, strerror(e), e);", "exit(1);", "}", "if (ngroups <= NGROUPS_MAX) {", "setgroupsCalled = true;", "gidset.reset(new gid_t[ngroups]);", "if (setgroups(ngroups, gidset.get()) == -1) {", "int e = errno;", "fprintf(stderr, \"ERROR: setgroups(%d, ...) failed: %s (errno=%d)\\n\",", "ngroups, strerror(e), e);", "exit(1);", "}", "}", "#endif", "if (!setgroupsCalled && initgroups(userInfo->pw_name, gid) == -1) {", "int e = errno;", "fprintf(stderr, \"ERROR: initgroups(%s, %d) failed: %s (errno=%d)\\n\",", "userInfo->pw_name, (int) gid, strerror(e), e);", "exit(1);", "}", "}", "if (setgid(gid) == -1) {", "int e = errno;", "fprintf(stderr, \"ERROR: setgid(%d) failed: %s (errno=%d)\\n\",", "(int) gid, strerror(e), e);", "exit(1);", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["GF_Err gf_sm_load_init(GF_SceneLoader *load)", "{", "GF_Err e = GF_NOT_SUPPORTED;", "char *ext, szExt[50];", "if (!load || (!load->ctx && !load->scene_graph)", "#ifndef GPAC_DISABLE_ISOM", "|| (!load->fileName && !load->isom && !(load->flags & GF_SM_LOAD_FOR_PLAYBACK) )", "#endif", ") return GF_BAD_PARAM;", "if (!load->type) {", "#ifndef GPAC_DISABLE_ISOM", "if (load->isom) {", "load->type = GF_SM_LOAD_MP4;", "} else", "#endif", "{", "ext = (char *)strrchr(load->fileName, '.');", "if (!ext) return GF_NOT_SUPPORTED;", "if (!stricmp(ext, \".gz\")) {", "char *anext;", "ext[0] = 0;", "anext = (char *)strrchr(load->fileName, '.');", "ext[0] = '.';", "ext = anext;", "}", "strcpy(szExt, &ext[1]);", "strlwr(szExt);", "if (strstr(szExt, \"bt\")) load->type = GF_SM_LOAD_BT;", "else if (strstr(szExt, \"wrl\")) load->type = GF_SM_LOAD_VRML;", "else if (strstr(szExt, \"x3dv\")) load->type = GF_SM_LOAD_X3DV;", "#ifndef GPAC_DISABLE_LOADER_XMT", "else if (strstr(szExt, \"xmt\") || strstr(szExt, \"xmta\")) load->type = GF_SM_LOAD_XMTA;", "else if (strstr(szExt, \"x3d\")) load->type = GF_SM_LOAD_X3D;", "#endif", "else if (strstr(szExt, \"swf\")) load->type = GF_SM_LOAD_SWF;", "else if (strstr(szExt, \"mov\")) load->type = GF_SM_LOAD_QT;", "else if (strstr(szExt, \"svg\")) load->type = GF_SM_LOAD_SVG;", "else if (strstr(szExt, \"xsr\")) load->type = GF_SM_LOAD_XSR;", "else if (strstr(szExt, \"xbl\")) load->type = GF_SM_LOAD_XBL;", "else if (strstr(szExt, \"xml\")) {", "char *rtype = gf_xml_get_root_type(load->fileName, &e);", "if (rtype) {", "if (!strcmp(rtype, \"SAFSession\")) load->type = GF_SM_LOAD_XSR;", "else if (!strcmp(rtype, \"XMT-A\")) load->type = GF_SM_LOAD_XMTA;", "else if (!strcmp(rtype, \"X3D\")) load->type = GF_SM_LOAD_X3D;", "else if (!strcmp(rtype, \"bindings\")) load->type = GF_SM_LOAD_XBL;", "gf_free(rtype);", "}", "}", "}", "}", "if (!load->type) return e;", "if (!load->scene_graph) load->scene_graph = load->ctx->scene_graph;", "switch (load->type) {", "#ifndef GPAC_DISABLE_LOADER_BT", "case GF_SM_LOAD_BT:", "case GF_SM_LOAD_VRML:", "case GF_SM_LOAD_X3DV:", "return gf_sm_load_init_bt(load);", "#endif", "#ifndef GPAC_DISABLE_LOADER_XMT", "case GF_SM_LOAD_XMTA:", "case GF_SM_LOAD_X3D:", "return gf_sm_load_init_xmt(load);", "#endif", "#ifndef GPAC_DISABLE_SVG", "case GF_SM_LOAD_SVG:", "case GF_SM_LOAD_XSR:", "case GF_SM_LOAD_DIMS:", "return gf_sm_load_init_svg(load);", "case GF_SM_LOAD_XBL:", "e = gf_sm_load_init_xbl(load);", "load->process = gf_sm_load_run_xbl;", "load->done = gf_sm_load_done_xbl;", "return e;", "#endif", "#ifndef GPAC_DISABLE_SWF_IMPORT", "case GF_SM_LOAD_SWF:", "return gf_sm_load_init_swf(load);", "#endif", "#ifndef GPAC_DISABLE_LOADER_ISOM", "case GF_SM_LOAD_MP4:", "return gf_sm_load_init_isom(load);", "#endif", "#ifndef GPAC_DISABLE_QTVR", "case GF_SM_LOAD_QT:", "return gf_sm_load_init_qt(load);", "#endif", "default:", "return GF_NOT_SUPPORTED;", "}", "return GF_NOT_SUPPORTED;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static void get_sem_elements(struct sem_data *p)", "{", "size_t i;", "if (!p || !p->sem_nsems || p->sem_perm.id < 0)", "return;", "p->elements = xcalloc(p->sem_nsems, sizeof(struct sem_elem));", "for (i = 0; i < p->sem_nsems; i++) {", "struct sem_elem *e = &p->elements[i];", "union semun arg = { .val = 0 };", "e->semval = semctl(p->sem_perm.id, i, GETVAL, arg);", "if (e->semval < 0)", "err(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETVAL)\");", "e->ncount = semctl(p->sem_perm.id, i, GETNCNT, arg);", "if (e->ncount < 0)", "err(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETNCNT)\");", "e->zcount = semctl(p->sem_perm.id, i, GETZCNT, arg);", "if (e->zcount < 0)", "err(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETZCNT)\");", "e->pid = semctl(p->sem_perm.id, i, GETPID, arg);", "if (e->pid < 0)", "err(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETPID)\");", "}", "}"], "ner_tags": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["int secure_decrypt(void *data, unsigned int data_length, int is_signed)", "{", "at91_aes_key_size_t key_size;", "unsigned int cmac_key[8], cipher_key[8];", "unsigned int iv[AT91_AES_IV_SIZE_WORD];", "unsigned int computed_cmac[AT91_AES_BLOCK_SIZE_WORD];", "unsigned int fixed_length;", "const unsigned int *cmac;", "int rc = -1;", "init_keys(&key_size, cipher_key, cmac_key, iv);", "at91_aes_init();", "if (is_signed) {", "if (at91_aes_cmac(data_length, data, computed_cmac,", "key_size, cmac_key))", "goto exit;", "fixed_length = at91_aes_roundup(data_length);", "cmac = (const unsigned int *)((char *)data + fixed_length);", "if (memcmp(cmac, computed_cmac, AT91_AES_BLOCK_SIZE_BYTE))", "goto exit;", "}", "if (at91_aes_cbc(data_length, data, data, 0,", "key_size, cipher_key, iv))", "goto exit;", "rc = 0;", "exit:", "at91_aes_cleanup();", "memset(cmac_key, 0, sizeof(cmac_key));", "memset(cipher_key, 0, sizeof(cipher_key));", "memset(iv, 0, sizeof(iv));", "return rc;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void jsvRemoveChild(JsVar *parent, JsVar *child) {", "assert(jsvHasChildren(parent));", "assert(jsvIsName(child));", "JsVarRef childref = jsvGetRef(child);", "bool wasChild = false;", "if (jsvGetFirstChild(parent) == childref) {", "jsvSetFirstChild(parent, jsvGetNextSibling(child));", "wasChild = true;", "}", "if (jsvGetLastChild(parent) == childref) {", "jsvSetLastChild(parent, jsvGetPrevSibling(child));", "wasChild = true;", "if (jsvIsArray(parent)) {", "JsVarInt l = 0;", "if (jsvGetLastChild(parent))", "l = jsvGetIntegerAndUnLock(jsvLock(jsvGetLastChild(parent)))+1;", "jsvSetArrayLength(parent, l, false);", "}", "}", "if (jsvGetPrevSibling(child)) {", "JsVar *v = jsvLock(jsvGetPrevSibling(child));", "assert(jsvGetNextSibling(v) == jsvGetRef(child));", "jsvSetNextSibling(v, jsvGetNextSibling(child));", "jsvUnLock(v);", "wasChild = true;", "}", "if (jsvGetNextSibling(child)) {", "JsVar *v = jsvLock(jsvGetNextSibling(child));", "assert(jsvGetPrevSibling(v) == jsvGetRef(child));", "jsvSetPrevSibling(v, jsvGetPrevSibling(child));", "jsvUnLock(v);", "wasChild = true;", "}", "jsvSetPrevSibling(child, 0);", "jsvSetNextSibling(child, 0);", "if (wasChild)", "jsvUnRef(child);", "}"], "ner_tags": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["parse_tag(char **s, int internal)", "{", "struct parsed_tag *tag = NULL;", "int tag_id;", "char tagname[MAX_TAG_LEN], attrname[MAX_TAG_LEN];", "char *p, *q;", "int i, attr_id = 0, nattr;", "q = (*s) + 1;", "p = tagname;", "if (*q == '/') {", "*(p++) = *(q++);", "SKIP_BLANKS(q);", "}", "while (*q && !IS_SPACE(*q) && !(tagname[0] != '/' && *q == '/') &&", "*q != '>' && p - tagname < MAX_TAG_LEN - 1) {", "*(p++) = TOLOWER(*q);", "q++;", "}", "*p = '\\0';", "while (*q && !IS_SPACE(*q) && !(tagname[0] != '/' && *q == '/') &&", "*q != '>')", "q++;", "tag_id = getHash_si(&tagtable, tagname, HTML_UNKNOWN);", "if (tag_id == HTML_UNKNOWN ||", "(!internal && TagMAP[tag_id].flag & TFLG_INT))", "goto skip_parse_tagarg;", "tag = New(struct parsed_tag);", "bzero(tag, sizeof(struct parsed_tag));", "tag->tagid = tag_id;", "if ((nattr = TagMAP[tag_id].max_attribute) > 0) {", "tag->attrid = NewAtom_N(unsigned char, nattr);", "tag->value = New_N(char *, nattr);", "tag->map = NewAtom_N(unsigned char, MAX_TAGATTR);", "memset(tag->map, MAX_TAGATTR, MAX_TAGATTR);", "memset(tag->attrid, ATTR_UNKNOWN, nattr);", "for (i = 0; i < nattr; i++)", "tag->map[TagMAP[tag_id].accept_attribute[i]] = i;", "}", "SKIP_BLANKS(q);", "while (1) {", "Str value = NULL, value_tmp = NULL;", "if (*q == '>' || *q == '\\0')", "goto done_parse_tag;", "p = attrname;", "while (*q && *q != '=' && !IS_SPACE(*q) &&", "*q != '>' && p - attrname < MAX_TAG_LEN - 1) {", "*(p++) = TOLOWER(*q);", "q++;", "}", "*p = '\\0';", "while (*q && *q != '=' && !IS_SPACE(*q) && *q != '>')", "q++;", "SKIP_BLANKS(q);", "if (*q == '=') {", "value_tmp = Strnew();", "q++;", "SKIP_BLANKS(q);", "if (*q == '\"') {", "q++;", "while (*q && *q != '\"') {", "Strcat_char(value_tmp, *q);", "if (!tag->need_reconstruct && is_html_quote(*q))", "tag->need_reconstruct = TRUE;", "q++;", "}", "if (*q == '\"')", "q++;", "}", "else if (*q == '\\'') {", "q++;", "while (*q && *q != '\\'') {", "Strcat_char(value_tmp, *q);", "if (!tag->need_reconstruct && is_html_quote(*q))", "tag->need_reconstruct = TRUE;", "q++;", "}", "if (*q == '\\'')", "q++;", "}", "else if (*q) {", "while (*q && !IS_SPACE(*q) && *q != '>') {", "Strcat_char(value_tmp, *q);", "if (!tag->need_reconstruct && is_html_quote(*q))", "tag->need_reconstruct = TRUE;", "q++;", "}", "}", "}", "for (i = 0; i < nattr; i++) {", "if ((tag)->attrid[i] == ATTR_UNKNOWN &&", "strcmp(AttrMAP[TagMAP[tag_id].accept_attribute[i]].name,", "attrname) == 0) {", "attr_id = TagMAP[tag_id].accept_attribute[i];", "break;", "}", "}", "if (value_tmp) {", "int j, hidden=FALSE;", "for (j=0; j<i; j++) {", "if (tag->attrid[j] == ATTR_TYPE &&", "tag->value[j] &&", "strcmp(\"hidden\",tag->value[j]) == 0) {", "hidden=TRUE;", "break;", "}", "}", "if ((tag_id == HTML_INPUT || tag_id == HTML_INPUT_ALT) &&", "attr_id == ATTR_VALUE && hidden) {", "value = value_tmp;", "} else {", "char *x;", "value = Strnew();", "for (x = value_tmp->ptr; *x; x++) {", "if (*x != '\\n')", "Strcat_char(value, *x);", "}", "}", "}", "if (i != nattr) {", "if (!internal &&", "((AttrMAP[attr_id].flag & AFLG_INT) ||", "(value && AttrMAP[attr_id].vtype == VTYPE_METHOD &&", "!strcasecmp(value->ptr, \"internal\")))) {", "tag->need_reconstruct = TRUE;", "continue;", "}", "tag->attrid[i] = attr_id;", "if (value)", "tag->value[i] = html_unquote(value->ptr);", "else", "tag->value[i] = NULL;", "}", "else {", "tag->need_reconstruct = TRUE;", "}", "}", "skip_parse_tagarg:", "while (*q != '>' && *q)", "q++;", "done_parse_tag:", "if (*q == '>')", "q++;", "*s = q;", "return tag;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["GF_Err adts_dmx_process(GF_Filter *filter)", "{", "GF_ADTSDmxCtx *ctx = gf_filter_get_udta(filter);", "GF_FilterPacket *pck, *dst_pck;", "u8 *data, *output;", "u8 *start;", "u32 pck_size, remain, prev_pck_size;", "u64 cts = GF_FILTER_NO_TS;", "if (!ctx->duration.num)", "adts_dmx_check_dur(filter, ctx);", "if (ctx->opid && !ctx->is_playing)", "return GF_OK;", "pck = gf_filter_pid_get_packet(ctx->ipid);", "if (!pck) {", "if (gf_filter_pid_is_eos(ctx->ipid)) {", "if (!ctx->adts_buffer_size) {", "if (ctx->opid)", "gf_filter_pid_set_eos(ctx->opid);", "if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);", "ctx->src_pck = NULL;", "return GF_EOS;", "}", "} else {", "return GF_OK;", "}", "}", "prev_pck_size = ctx->adts_buffer_size;", "if (pck && !ctx->resume_from) {", "data = (char *) gf_filter_pck_get_data(pck, &pck_size);", "if (!pck_size) {", "gf_filter_pid_drop_packet(ctx->ipid);", "return GF_OK;", "}", "if (ctx->byte_offset != GF_FILTER_NO_BO) {", "u64 byte_offset = gf_filter_pck_get_byte_offset(pck);", "if (!ctx->adts_buffer_size) {", "ctx->byte_offset = byte_offset;", "} else if (ctx->byte_offset + ctx->adts_buffer_size != byte_offset) {", "ctx->byte_offset = GF_FILTER_NO_BO;", "if ((byte_offset != GF_FILTER_NO_BO) && (byte_offset>ctx->adts_buffer_size) ) {", "ctx->byte_offset = byte_offset - ctx->adts_buffer_size;", "}", "}", "}", "if (ctx->adts_buffer_size + pck_size > ctx->adts_buffer_alloc) {", "ctx->adts_buffer_alloc = ctx->adts_buffer_size + pck_size;", "ctx->adts_buffer = gf_realloc(ctx->adts_buffer, ctx->adts_buffer_alloc);", "}", "memcpy(ctx->adts_buffer + ctx->adts_buffer_size, data, pck_size);", "ctx->adts_buffer_size += pck_size;", "}", "if (ctx->timescale && pck) {", "cts = gf_filter_pck_get_cts(pck);", "}", "if (cts == GF_FILTER_NO_TS) {", "prev_pck_size = 0;", "}", "remain = ctx->adts_buffer_size;", "start = ctx->adts_buffer;", "if (ctx->resume_from) {", "start += ctx->resume_from - 1;", "remain -= ctx->resume_from - 1;", "ctx->resume_from = 0;", "}", "while (remain) {", "u8 *sync;", "u32 sync_pos, size, offset, bytes_to_drop=0, nb_blocks_per_frame;", "if (!ctx->tag_size && (remain>3)) {", "if (start[0] == 'I' && start[1] == 'D' && start[2] == '3') {", "if (remain<10)", "return GF_OK;", "ctx->tag_size = ((start[9] & 0x7f) + ((start[8] & 0x7f) << 7) + ((start[7] & 0x7f) << 14) + ((start[6] & 0x7f) << 21));", "bytes_to_drop = 10;", "if (ctx->id3_buffer_alloc < ctx->tag_size+10) {", "ctx->id3_buffer = gf_realloc(ctx->id3_buffer, ctx->tag_size+10);", "ctx->id3_buffer_alloc = ctx->tag_size+10;", "}", "memcpy(ctx->id3_buffer, start, 10);", "ctx->id3_buffer_size = 10;", "goto drop_byte;", "}", "}", "if (ctx->tag_size) {", "if (ctx->tag_size>remain) {", "bytes_to_drop = remain;", "ctx->tag_size-=remain;", "} else {", "bytes_to_drop = ctx->tag_size;", "ctx->tag_size = 0;", "}", "memcpy(ctx->id3_buffer + ctx->id3_buffer_size, start, bytes_to_drop);", "ctx->id3_buffer_size += bytes_to_drop;", "if (!ctx->tag_size && ctx->opid) {", "id3dmx_flush(filter, ctx->id3_buffer, ctx->id3_buffer_size, ctx->opid, ctx->expart ? &ctx->vpid : NULL);", "ctx->id3_buffer_size = 0;", "}", "goto drop_byte;", "}", "sync = memchr(start, 0xFF, remain);", "sync_pos = (u32) (sync ? sync - start : remain);", "if (remain - sync_pos < 7) {", "break;", "}", "if ((sync[1] & 0xF0) != 0xF0) {", "GF_LOG(ctx->nb_frames ? GF_LOG_WARNING : GF_LOG_DEBUG, GF_LOG_PARSER, (\"[ADTSDmx] invalid ADTS sync bytes, resyncing\\n\"));", "ctx->nb_frames = 0;", "goto drop_byte;", "}", "if (!ctx->bs) {", "ctx->bs = gf_bs_new(sync + 1, remain - sync_pos - 1, GF_BITSTREAM_READ);", "} else {", "gf_bs_reassign_buffer(ctx->bs, sync + 1, remain - sync_pos - 1);", "}", "gf_bs_read_int(ctx->bs, 4);", "ctx->hdr.is_mp2 = (Bool)gf_bs_read_int(ctx->bs, 1);", "ctx->hdr.is_mp2 = 0;", "gf_bs_read_int(ctx->bs, 2);", "ctx->hdr.no_crc = (Bool)gf_bs_read_int(ctx->bs, 1);", "ctx->hdr.profile = 1 + gf_bs_read_int(ctx->bs, 2);", "ctx->hdr.sr_idx = gf_bs_read_int(ctx->bs, 4);", "gf_bs_read_int(ctx->bs, 1);", "ctx->hdr.nb_ch = gf_bs_read_int(ctx->bs, 3);", "gf_bs_read_int(ctx->bs, 4);", "ctx->hdr.frame_size = gf_bs_read_int(ctx->bs, 13);", "gf_bs_read_int(ctx->bs, 11);", "nb_blocks_per_frame = gf_bs_read_int(ctx->bs, 2);", "ctx->hdr.hdr_size = 7;", "if (!ctx->hdr.no_crc) {", "u32 skip;", "if (!nb_blocks_per_frame) {", "skip = 2;", "} else {", "skip = 2 + 2*nb_blocks_per_frame;", "}", "ctx->hdr.hdr_size += skip;", "gf_bs_skip_bytes(ctx->bs, skip);", "}", "if (!ctx->hdr.frame_size || !GF_M4ASampleRates[ctx->hdr.sr_idx]) {", "GF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[ADTSDmx] Invalid ADTS frame header, resyncing\\n\"));", "ctx->nb_frames = 0;", "goto drop_byte;", "}", "if ((nb_blocks_per_frame>2) || (nb_blocks_per_frame && ctx->hdr.nb_ch)) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[ADTSDmx] Unsupported multi-block ADTS frame header - patch welcome\\n\"));", "ctx->nb_frames = 0;", "goto drop_byte;", "} else if (!nb_blocks_per_frame) {", "if (ctx->aacchcfg<0)", "ctx->hdr.nb_ch = -ctx->aacchcfg;", "else if (!ctx->hdr.nb_ch)", "ctx->hdr.nb_ch = ctx->aacchcfg;", "if (!ctx->hdr.nb_ch) {", "GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[ADTSDmx] Missing channel configuration in ADTS frame header, defaulting to stereo - use `--aacchcfg` to force config\\n\"));", "ctx->hdr.nb_ch = ctx->aacchcfg = 2;", "}", "}", "if (nb_blocks_per_frame==2) {", "u32 pos = (u32) gf_bs_get_position(ctx->bs);", "gf_m4a_parse_program_config_element(ctx->bs, &ctx->acfg);", "if (!ctx->hdr.no_crc)", "gf_bs_skip_bytes(ctx->bs, 2);", "ctx->hdr.hdr_size += (u32) gf_bs_get_position(ctx->bs) - pos;", "}", "if (ctx->hdr.nb_ch==7)", "ctx->hdr.nb_ch = 8;", "if (ctx->hdr.frame_size + 1 < remain) {", "u32 next_frame = ctx->hdr.frame_size;", "if ((sync[next_frame] !=0xFF) || ((sync[next_frame+1] & 0xF0) !=0xF0) ) {", "GF_LOG(ctx->nb_frames ? GF_LOG_WARNING : GF_LOG_DEBUG, GF_LOG_PARSER, (\"[ADTSDmx] invalid next ADTS frame sync, resyncing\\n\"));", "ctx->nb_frames = 0;", "goto drop_byte;", "}", "}", "else if (pck) {", "if (ctx->timescale && !prev_pck_size &&  (cts != GF_FILTER_NO_TS) ) {", "ctx->cts = cts;", "}", "break;", "}", "adts_dmx_check_pid(filter, ctx);", "if (!ctx->is_playing) {", "ctx->resume_from = 1 + ctx->adts_buffer_size - remain;", "return GF_OK;", "}", "ctx->nb_frames++;", "size = ctx->hdr.frame_size - ctx->hdr.hdr_size;", "offset = ctx->hdr.hdr_size;", "if ((nb_blocks_per_frame==2) && !ctx->hdr.no_crc)", "size -= 2;", "if (ctx->in_seek) {", "u64 nb_samples_at_seek = (u64) (ctx->start_range * GF_M4ASampleRates[ctx->sr_idx]);", "if (ctx->cts + ctx->dts_inc >= nb_samples_at_seek) {", "ctx->in_seek = GF_FALSE;", "}", "}", "bytes_to_drop = ctx->hdr.frame_size;", "if (ctx->timescale && !prev_pck_size &&  (cts != GF_FILTER_NO_TS) ) {", "ctx->cts = cts;", "cts = GF_FILTER_NO_TS;", "}", "if (!ctx->in_seek) {", "dst_pck = gf_filter_pck_new_alloc(ctx->opid, size, &output);", "if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);", "memcpy(output, sync + offset, size);", "gf_filter_pck_set_dts(dst_pck, ctx->cts);", "gf_filter_pck_set_cts(dst_pck, ctx->cts);", "gf_filter_pck_set_duration(dst_pck, ctx->dts_inc);", "gf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);", "gf_filter_pck_set_sap(dst_pck, GF_FILTER_SAP_1);", "if (ctx->byte_offset != GF_FILTER_NO_BO) {", "gf_filter_pck_set_byte_offset(dst_pck, ctx->byte_offset + ctx->hdr.hdr_size);", "}", "gf_filter_pck_send(dst_pck);", "}", "adts_dmx_update_cts(ctx);", "if (bytes_to_drop>remain) {", "GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[ADTSDmx] truncated ADTS frame!\\n\"));", "bytes_to_drop=remain;", "}", "drop_byte:", "if (!bytes_to_drop) {", "bytes_to_drop = 1;", "}", "start += bytes_to_drop;", "remain -= bytes_to_drop;", "if (prev_pck_size) {", "if (prev_pck_size > bytes_to_drop) prev_pck_size -= bytes_to_drop;", "else {", "prev_pck_size=0;", "if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);", "ctx->src_pck = pck;", "if (pck)", "gf_filter_pck_ref_props(&ctx->src_pck);", "}", "}", "if (ctx->byte_offset != GF_FILTER_NO_BO)", "ctx->byte_offset += bytes_to_drop;", "}", "if (!pck) {", "ctx->adts_buffer_size = 0;", "return adts_dmx_process(filter);", "} else {", "if (remain) {", "memmove(ctx->adts_buffer, start, remain);", "}", "ctx->adts_buffer_size = remain;", "gf_filter_pid_drop_packet(ctx->ipid);", "}", "return GF_OK;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static inline bool isMountable(const RemoteFsDevice::Details &d)", "{", "return RemoteFsDevice::constSshfsProtocol==d.url.scheme() ||", "RemoteFsDevice::constSambaProtocol==d.url.scheme() || RemoteFsDevice::constSambaAvahiProtocol==d.url.scheme();", "}"], "ner_tags": [0, 0, 1, 1, 0]}
{"tokens": ["int ff_htmlmarkup_to_ass(void *log_ctx, AVBPrint *dst, const char *in)", "{", "char *param, buffer[128], tmp[128];", "int len, tag_close, sptr = 1, line_start = 1, an = 0, end = 0;", "SrtStack stack[16];", "int closing_brace_missing = 0;", "stack[0].tag[0] = 0;", "strcpy(stack[0].param[PARAM_SIZE],  \"{\\\\fs}\");", "strcpy(stack[0].param[PARAM_COLOR], \"{\\\\c}\");", "strcpy(stack[0].param[PARAM_FACE],  \"{\\\\fn}\");", "for (; !end && *in; in++) {", "switch (*in) {", "case '\\r':", "break;", "case '\\n':", "if (line_start) {", "end = 1;", "break;", "}", "rstrip_spaces_buf(dst);", "av_bprintf(dst, \"\\\\N\");", "line_start = 1;", "break;", "case ' ':", "if (!line_start)", "av_bprint_chars(dst, *in, 1);", "break;", "case '{':", "len = 0;", "an += sscanf(in, \"{\\\\an%*1u}%n\", &len) >= 0 && len > 0;", "if (!closing_brace_missing) {", "if (   (an != 1 && in[1] == '\\\\')", "|| (in[1] && strchr(\"CcFfoPSsYy\", in[1]) && in[2] == ':')) {", "char *bracep = strchr(in+2, '}');", "if (bracep) {", "in = bracep;", "break;", "} else", "closing_brace_missing = 1;", "}", "}", "av_bprint_chars(dst, *in, 1);", "break;", "case '<':", "tag_close = in[1] == '/';", "len = 0;", "if (sscanf(in+tag_close+1, \"%127[^<>]>%n\", buffer, &len) >= 1 && len > 0) {", "const char *tagname = buffer;", "while (*tagname == ' ')", "tagname++;", "if ((param = strchr(tagname, ' ')))", "*param++ = 0;", "if ((!tag_close && sptr < FF_ARRAY_ELEMS(stack) && *tagname) ||", "( tag_close && sptr > 0 && !strcmp(stack[sptr-1].tag, tagname))) {", "int i, j, unknown = 0;", "in += len + tag_close;", "if (!tag_close)", "memset(stack+sptr, 0, sizeof(*stack));", "if (!strcmp(tagname, \"font\")) {", "if (tag_close) {", "for (i=PARAM_NUMBER-1; i>=0; i--)", "if (stack[sptr-1].param[i][0])", "for (j=sptr-2; j>=0; j--)", "if (stack[j].param[i][0]) {", "av_bprintf(dst, \"%s\", stack[j].param[i]);", "break;", "}", "} else {", "while (param) {", "if (!strncmp(param, \"size=\", 5)) {", "unsigned font_size;", "param += 5 + (param[5] == '\"');", "if (sscanf(param, \"%u\", &font_size) == 1) {", "snprintf(stack[sptr].param[PARAM_SIZE],", "sizeof(stack[0].param[PARAM_SIZE]),", "\"{\\\\fs%u}\", font_size);", "}", "} else if (!strncmp(param, \"color=\", 6)) {", "param += 6 + (param[6] == '\"');", "snprintf(stack[sptr].param[PARAM_COLOR],", "sizeof(stack[0].param[PARAM_COLOR]),", "\"{\\\\c&H%X&}\",", "html_color_parse(log_ctx, param));", "} else if (!strncmp(param, \"face=\", 5)) {", "param += 5 + (param[5] == '\"');", "len = strcspn(param,", "param[-1] == '\"' ? \"\\\"\" :\" \");", "av_strlcpy(tmp, param,", "FFMIN(sizeof(tmp), len+1));", "param += len;", "snprintf(stack[sptr].param[PARAM_FACE],", "sizeof(stack[0].param[PARAM_FACE]),", "\"{\\\\fn%s}\", tmp);", "}", "if ((param = strchr(param, ' ')))", "param++;", "}", "for (i=0; i<PARAM_NUMBER; i++)", "if (stack[sptr].param[i][0])", "av_bprintf(dst, \"%s\", stack[sptr].param[i]);", "}", "} else if (tagname[0] && !tagname[1] && strspn(tagname, \"bisu\") == 1) {", "av_bprintf(dst, \"{\\\\%c%d}\", tagname[0], !tag_close);", "} else {", "unknown = 1;", "snprintf(tmp, sizeof(tmp), \"</%s>\", tagname);", "}", "if (tag_close) {", "sptr--;", "} else if (unknown && !strstr(in, tmp)) {", "in -= len + tag_close;", "av_bprint_chars(dst, *in, 1);", "} else", "av_strlcpy(stack[sptr++].tag, tagname,", "sizeof(stack[0].tag));", "break;", "}", "}", "default:", "av_bprint_chars(dst, *in, 1);", "break;", "}", "if (*in != ' ' && *in != '\\r' && *in != '\\n')", "line_start = 0;", "}", "if (!av_bprint_is_complete(dst))", "return AVERROR(ENOMEM);", "while (dst->len >= 2 && !strncmp(&dst->str[dst->len - 2], \"\\\\N\", 2))", "dst->len -= 2;", "dst->str[dst->len] = 0;", "rstrip_spaces_buf(dst);", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int multiSelect(", "Parse *pParse,", "Select *p,", "SelectDest *pDest", "){", "int rc = SQLITE_OK;", "Select *pPrior;", "Vdbe *v;", "SelectDest dest;", "Select *pDelete = 0;", "sqlite3 *db;", "assert( p && p->pPrior );", "assert( (p->selFlags & SF_Recursive)==0 || p->op==TK_ALL || p->op==TK_UNION );", "assert( p->selFlags & SF_Compound );", "db = pParse->db;", "pPrior = p->pPrior;", "dest = *pDest;", "if( pPrior->pOrderBy || pPrior->pLimit ){", "sqlite3ErrorMsg(pParse,\"%s clause should come after %s not before\",", "pPrior->pOrderBy!=0 ? \"ORDER BY\" : \"LIMIT\", selectOpName(p->op));", "rc = 1;", "goto multi_select_end;", "}", "v = sqlite3GetVdbe(pParse);", "assert( v!=0 );", "if( dest.eDest==SRT_EphemTab ){", "assert( p->pEList );", "sqlite3VdbeAddOp2(v, OP_OpenEphemeral, dest.iSDParm, p->pEList->nExpr);", "dest.eDest = SRT_Table;", "}", "if( p->selFlags & SF_MultiValue ){", "rc = multiSelectValues(pParse, p, &dest);", "if( rc>=0 ) goto multi_select_end;", "rc = SQLITE_OK;", "}", "assert( p->pEList && pPrior->pEList );", "assert( p->pEList->nExpr==pPrior->pEList->nExpr );", "#ifndef SQLITE_OMIT_CTE", "if( p->selFlags & SF_Recursive ){", "generateWithRecursiveQuery(pParse, p, &dest);", "}else", "#endif", "if( p->pOrderBy ){", "return multiSelectOrderBy(pParse, p, pDest);", "}else{", "#ifndef SQLITE_OMIT_EXPLAIN", "if( pPrior->pPrior==0 ){", "ExplainQueryPlan((pParse, 1, \"COMPOUND QUERY\"));", "ExplainQueryPlan((pParse, 1, \"LEFT-MOST SUBQUERY\"));", "}", "#endif", "switch( p->op ){", "case TK_ALL: {", "int addr = 0;", "int nLimit;", "assert( !pPrior->pLimit );", "pPrior->iLimit = p->iLimit;", "pPrior->iOffset = p->iOffset;", "pPrior->pLimit = p->pLimit;", "rc = sqlite3Select(pParse, pPrior, &dest);", "p->pLimit = 0;", "if( rc ){", "goto multi_select_end;", "}", "p->pPrior = 0;", "p->iLimit = pPrior->iLimit;", "p->iOffset = pPrior->iOffset;", "if( p->iLimit ){", "addr = sqlite3VdbeAddOp1(v, OP_IfNot, p->iLimit); VdbeCoverage(v);", "VdbeComment((v, \"Jump ahead if LIMIT reached\"));", "if( p->iOffset ){", "sqlite3VdbeAddOp3(v, OP_OffsetLimit,", "p->iLimit, p->iOffset+1, p->iOffset);", "}", "}", "ExplainQueryPlan((pParse, 1, \"UNION ALL\"));", "rc = sqlite3Select(pParse, p, &dest);", "testcase( rc!=SQLITE_OK );", "pDelete = p->pPrior;", "p->pPrior = pPrior;", "p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);", "if( pPrior->pLimit", "&& sqlite3ExprIsInteger(pPrior->pLimit->pLeft, &nLimit)", "&& nLimit>0 && p->nSelectRow > sqlite3LogEst((u64)nLimit)", "){", "p->nSelectRow = sqlite3LogEst((u64)nLimit);", "}", "if( addr ){", "sqlite3VdbeJumpHere(v, addr);", "}", "break;", "}", "case TK_EXCEPT:", "case TK_UNION: {", "int unionTab;", "u8 op = 0;", "int priorOp;", "Expr *pLimit;", "int addr;", "SelectDest uniondest;", "testcase( p->op==TK_EXCEPT );", "testcase( p->op==TK_UNION );", "priorOp = SRT_Union;", "if( dest.eDest==priorOp ){", "assert( p->pLimit==0 );", "unionTab = dest.iSDParm;", "}else{", "unionTab = pParse->nTab++;", "assert( p->pOrderBy==0 );", "addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, unionTab, 0);", "assert( p->addrOpenEphm[0] == -1 );", "p->addrOpenEphm[0] = addr;", "findRightmost(p)->selFlags |= SF_UsesEphemeral;", "assert( p->pEList );", "}", "assert( !pPrior->pOrderBy );", "sqlite3SelectDestInit(&uniondest, priorOp, unionTab);", "rc = sqlite3Select(pParse, pPrior, &uniondest);", "if( rc ){", "goto multi_select_end;", "}", "if( p->op==TK_EXCEPT ){", "op = SRT_Except;", "}else{", "assert( p->op==TK_UNION );", "op = SRT_Union;", "}", "p->pPrior = 0;", "pLimit = p->pLimit;", "p->pLimit = 0;", "uniondest.eDest = op;", "ExplainQueryPlan((pParse, 1, \"%s USING TEMP B-TREE\",", "selectOpName(p->op)));", "rc = sqlite3Select(pParse, p, &uniondest);", "testcase( rc!=SQLITE_OK );", "sqlite3ExprListDelete(db, p->pOrderBy);", "pDelete = p->pPrior;", "p->pPrior = pPrior;", "p->pOrderBy = 0;", "if( p->op==TK_UNION ){", "p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);", "}", "sqlite3ExprDelete(db, p->pLimit);", "p->pLimit = pLimit;", "p->iLimit = 0;", "p->iOffset = 0;", "assert( unionTab==dest.iSDParm || dest.eDest!=priorOp );", "if( dest.eDest!=priorOp ){", "int iCont, iBreak, iStart;", "assert( p->pEList );", "iBreak = sqlite3VdbeMakeLabel(pParse);", "iCont = sqlite3VdbeMakeLabel(pParse);", "computeLimitRegisters(pParse, p, iBreak);", "sqlite3VdbeAddOp2(v, OP_Rewind, unionTab, iBreak); VdbeCoverage(v);", "iStart = sqlite3VdbeCurrentAddr(v);", "selectInnerLoop(pParse, p, unionTab,", "0, 0, &dest, iCont, iBreak);", "sqlite3VdbeResolveLabel(v, iCont);", "sqlite3VdbeAddOp2(v, OP_Next, unionTab, iStart); VdbeCoverage(v);", "sqlite3VdbeResolveLabel(v, iBreak);", "sqlite3VdbeAddOp2(v, OP_Close, unionTab, 0);", "}", "break;", "}", "default: assert( p->op==TK_INTERSECT ); {", "int tab1, tab2;", "int iCont, iBreak, iStart;", "Expr *pLimit;", "int addr;", "SelectDest intersectdest;", "int r1;", "tab1 = pParse->nTab++;", "tab2 = pParse->nTab++;", "assert( p->pOrderBy==0 );", "addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, tab1, 0);", "assert( p->addrOpenEphm[0] == -1 );", "p->addrOpenEphm[0] = addr;", "findRightmost(p)->selFlags |= SF_UsesEphemeral;", "assert( p->pEList );", "sqlite3SelectDestInit(&intersectdest, SRT_Union, tab1);", "rc = sqlite3Select(pParse, pPrior, &intersectdest);", "if( rc ){", "goto multi_select_end;", "}", "addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, tab2, 0);", "assert( p->addrOpenEphm[1] == -1 );", "p->addrOpenEphm[1] = addr;", "p->pPrior = 0;", "pLimit = p->pLimit;", "p->pLimit = 0;", "intersectdest.iSDParm = tab2;", "ExplainQueryPlan((pParse, 1, \"%s USING TEMP B-TREE\",", "selectOpName(p->op)));", "rc = sqlite3Select(pParse, p, &intersectdest);", "testcase( rc!=SQLITE_OK );", "pDelete = p->pPrior;", "p->pPrior = pPrior;", "if( p->nSelectRow>pPrior->nSelectRow ){", "p->nSelectRow = pPrior->nSelectRow;", "}", "sqlite3ExprDelete(db, p->pLimit);", "p->pLimit = pLimit;", "assert( p->pEList );", "iBreak = sqlite3VdbeMakeLabel(pParse);", "iCont = sqlite3VdbeMakeLabel(pParse);", "computeLimitRegisters(pParse, p, iBreak);", "sqlite3VdbeAddOp2(v, OP_Rewind, tab1, iBreak); VdbeCoverage(v);", "r1 = sqlite3GetTempReg(pParse);", "iStart = sqlite3VdbeAddOp2(v, OP_RowData, tab1, r1);", "sqlite3VdbeAddOp4Int(v, OP_NotFound, tab2, iCont, r1, 0);", "VdbeCoverage(v);", "sqlite3ReleaseTempReg(pParse, r1);", "selectInnerLoop(pParse, p, tab1,", "0, 0, &dest, iCont, iBreak);", "sqlite3VdbeResolveLabel(v, iCont);", "sqlite3VdbeAddOp2(v, OP_Next, tab1, iStart); VdbeCoverage(v);", "sqlite3VdbeResolveLabel(v, iBreak);", "sqlite3VdbeAddOp2(v, OP_Close, tab2, 0);", "sqlite3VdbeAddOp2(v, OP_Close, tab1, 0);", "break;", "}", "}", "#ifndef SQLITE_OMIT_EXPLAIN", "if( p->pNext==0 ){", "ExplainQueryPlanPop(pParse);", "}", "#endif", "}", "if( p->selFlags & SF_UsesEphemeral ){", "int i;", "KeyInfo *pKeyInfo;", "Select *pLoop;", "CollSeq **apColl;", "int nCol;", "assert( p->pNext==0 );", "nCol = p->pEList->nExpr;", "pKeyInfo = sqlite3KeyInfoAlloc(db, nCol, 1);", "if( !pKeyInfo ){", "rc = SQLITE_NOMEM_BKPT;", "goto multi_select_end;", "}", "for(i=0, apColl=pKeyInfo->aColl; i<nCol; i++, apColl++){", "*apColl = multiSelectCollSeq(pParse, p, i);", "if( 0==*apColl ){", "*apColl = db->pDfltColl;", "}", "}", "for(pLoop=p; pLoop; pLoop=pLoop->pPrior){", "for(i=0; i<2; i++){", "int addr = pLoop->addrOpenEphm[i];", "if( addr<0 ){", "assert( pLoop->addrOpenEphm[1]<0 );", "break;", "}", "sqlite3VdbeChangeP2(v, addr, nCol);", "sqlite3VdbeChangeP4(v, addr, (char*)sqlite3KeyInfoRef(pKeyInfo),", "P4_KEYINFO);", "pLoop->addrOpenEphm[i] = -1;", "}", "}", "sqlite3KeyInfoUnref(pKeyInfo);", "}", "multi_select_end:", "pDest->iSdst = dest.iSdst;", "pDest->nSdst = dest.nSdst;", "sqlite3SelectDelete(db, pDelete);", "return rc;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int jpc_siz_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate,", "jas_stream_t *in)", "{", "jpc_siz_t *siz = &ms->parms.siz;", "unsigned int i;", "uint_fast8_t tmp;", "cstate = 0;", "if (jpc_getuint16(in, &siz->caps) ||", "jpc_getuint32(in, &siz->width) ||", "jpc_getuint32(in, &siz->height) ||", "jpc_getuint32(in, &siz->xoff) ||", "jpc_getuint32(in, &siz->yoff) ||", "jpc_getuint32(in, &siz->tilewidth) ||", "jpc_getuint32(in, &siz->tileheight) ||", "jpc_getuint32(in, &siz->tilexoff) ||", "jpc_getuint32(in, &siz->tileyoff) ||", "jpc_getuint16(in, &siz->numcomps)) {", "return -1;", "}", "if (!siz->width || !siz->height || !siz->tilewidth ||", "!siz->tileheight || !siz->numcomps) {", "return -1;", "}", "if (!(siz->comps = jas_alloc2(siz->numcomps, sizeof(jpc_sizcomp_t)))) {", "return -1;", "}", "for (i = 0; i < siz->numcomps; ++i) {", "if (jpc_getuint8(in, &tmp) ||", "jpc_getuint8(in, &siz->comps[i].hsamp) ||", "jpc_getuint8(in, &siz->comps[i].vsamp)) {", "jas_free(siz->comps);", "return -1;", "}", "siz->comps[i].sgnd = (tmp >> 7) & 1;", "siz->comps[i].prec = (tmp & 0x7f) + 1;", "}", "if (jas_stream_eof(in)) {", "jas_free(siz->comps);", "return -1;", "}", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["ngx_gmtime(time_t t, ngx_tm_t *tp)", "{", "ngx_int_t   yday;", "ngx_uint_t  sec, min, hour, mday, mon, year, wday, days, leap;", "if (t < 0) {", "t = 0;", "}", "days = t / 86400;", "sec = t % 86400;", "wday = (4 + days) % 7;", "hour = sec / 3600;", "sec %= 3600;", "min = sec / 60;", "sec %= 60;", "days = days - (31 + 28) + 719527;", "year = (days + 2) * 400 / (365 * 400 + 100 - 4 + 1);", "yday = days - (365 * year + year / 4 - year / 100 + year / 400);", "if (yday < 0) {", "leap = (year % 4 == 0) && (year % 100 || (year % 400 == 0));", "yday = 365 + leap + yday;", "year--;", "}", "mon = (yday + 31) * 10 / 306;", "mday = yday - (367 * mon / 12 - 30) + 1;", "if (yday >= 306) {", "year++;", "mon -= 10;", "} else {", "mon += 2;", "}", "tp->ngx_tm_sec = (ngx_tm_sec_t) sec;", "tp->ngx_tm_min = (ngx_tm_min_t) min;", "tp->ngx_tm_hour = (ngx_tm_hour_t) hour;", "tp->ngx_tm_mday = (ngx_tm_mday_t) mday;", "tp->ngx_tm_mon = (ngx_tm_mon_t) mon;", "tp->ngx_tm_year = (ngx_tm_year_t) year;", "tp->ngx_tm_wday = (ngx_tm_wday_t) wday;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static s32 svc_parse_slice(GF_BitStream *bs, AVCState *avc, AVCSliceInfo *si)", "{", "s32 pps_id;", "gf_bs_read_ue_log(bs, \"first_mb_in_slice\");", "si->slice_type = gf_bs_read_ue_log(bs, \"slice_type\");", "if (si->slice_type > 9) return -1;", "pps_id = gf_bs_read_ue_log(bs, \"pps_id\");", "if (pps_id > 255)", "return -1;", "si->pps = &avc->pps[pps_id];", "si->pps->id = pps_id;", "if (!si->pps->slice_group_count)", "return -2;", "si->sps = &avc->sps[si->pps->sps_id + GF_SVC_SSPS_ID_SHIFT];", "if (!si->sps->log2_max_frame_num)", "return -2;", "si->frame_num = gf_bs_read_int_log(bs, si->sps->log2_max_frame_num, \"frame_num\");", "si->field_pic_flag = 0;", "if (si->sps->frame_mbs_only_flag) {", "}", "else {", "si->field_pic_flag = gf_bs_read_int_log(bs, 1, \"field_pic_flag\");", "if (si->field_pic_flag) si->bottom_field_flag = gf_bs_read_int_log(bs, 1, \"bottom_field_flag\");", "}", "if (si->nal_unit_type == GF_AVC_NALU_IDR_SLICE || si->NalHeader.idr_pic_flag)", "si->idr_pic_id = gf_bs_read_ue_log(bs, \"idr_pic_id\");", "if (si->sps->poc_type == 0) {", "si->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, \"poc_lsb\");", "if (si->pps->pic_order_present && !si->field_pic_flag) {", "si->delta_poc_bottom = gf_bs_read_se_log(bs, \"delta_poc_bottom\");", "}", "}", "else if ((si->sps->poc_type == 1) && !si->sps->delta_pic_order_always_zero_flag) {", "si->delta_poc[0] = gf_bs_read_se_log(bs, \"delta_poc0\");", "if ((si->pps->pic_order_present == 1) && !si->field_pic_flag)", "si->delta_poc[1] = gf_bs_read_se_log(bs, \"delta_poc1\");", "}", "if (si->pps->redundant_pic_cnt_present) {", "si->redundant_pic_cnt = gf_bs_read_ue_log(bs, \"redundant_pic_cnt\");", "}", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["int ff_htmlmarkup_to_ass(void *log_ctx, AVBPrint *dst, const char *in)", "{", "char *param, buffer[128], tmp[128];", "int len, tag_close, sptr = 1, line_start = 1, an = 0, end = 0;", "SrtStack stack[16];", "int closing_brace_missing = 0;", "stack[0].tag[0] = 0;", "strcpy(stack[0].param[PARAM_SIZE],  \"{\\\\fs}\");", "strcpy(stack[0].param[PARAM_COLOR], \"{\\\\c}\");", "strcpy(stack[0].param[PARAM_FACE],  \"{\\\\fn}\");", "for (; !end && *in; in++) {", "switch (*in) {", "case '\\r':", "break;", "case '\\n':", "if (line_start) {", "end = 1;", "break;", "}", "rstrip_spaces_buf(dst);", "av_bprintf(dst, \"\\\\N\");", "line_start = 1;", "break;", "case ' ':", "if (!line_start)", "av_bprint_chars(dst, *in, 1);", "break;", "case '{':", "len = 0;", "an += sscanf(in, \"{\\\\an%*1u}%n\", &len) >= 0 && len > 0;", "if (!closing_brace_missing) {", "if (   (an != 1 && in[1] == '\\\\')", "|| (in[1] && strchr(\"CcFfoPSsYy\", in[1]) && in[2] == ':')) {", "char *bracep = strchr(in+2, '}');", "if (bracep) {", "in = bracep;", "break;", "} else", "closing_brace_missing = 1;", "}", "}", "av_bprint_chars(dst, *in, 1);", "break;", "case '<':", "tag_close = in[1] == '/';", "len = 0;", "if (scantag(in+tag_close+1, buffer, &len) && len > 0) {", "const char *tagname = buffer;", "while (*tagname == ' ')", "tagname++;", "if ((param = strchr(tagname, ' ')))", "*param++ = 0;", "if ((!tag_close && sptr < FF_ARRAY_ELEMS(stack) && *tagname) ||", "( tag_close && sptr > 0 && !strcmp(stack[sptr-1].tag, tagname))) {", "int i, j, unknown = 0;", "in += len + tag_close;", "if (!tag_close)", "memset(stack+sptr, 0, sizeof(*stack));", "if (!strcmp(tagname, \"font\")) {", "if (tag_close) {", "for (i=PARAM_NUMBER-1; i>=0; i--)", "if (stack[sptr-1].param[i][0])", "for (j=sptr-2; j>=0; j--)", "if (stack[j].param[i][0]) {", "av_bprintf(dst, \"%s\", stack[j].param[i]);", "break;", "}", "} else {", "while (param) {", "if (!strncmp(param, \"size=\", 5)) {", "unsigned font_size;", "param += 5 + (param[5] == '\"');", "if (sscanf(param, \"%u\", &font_size) == 1) {", "snprintf(stack[sptr].param[PARAM_SIZE],", "sizeof(stack[0].param[PARAM_SIZE]),", "\"{\\\\fs%u}\", font_size);", "}", "} else if (!strncmp(param, \"color=\", 6)) {", "param += 6 + (param[6] == '\"');", "snprintf(stack[sptr].param[PARAM_COLOR],", "sizeof(stack[0].param[PARAM_COLOR]),", "\"{\\\\c&H%X&}\",", "html_color_parse(log_ctx, param));", "} else if (!strncmp(param, \"face=\", 5)) {", "param += 5 + (param[5] == '\"');", "len = strcspn(param,", "param[-1] == '\"' ? \"\\\"\" :\" \");", "av_strlcpy(tmp, param,", "FFMIN(sizeof(tmp), len+1));", "param += len;", "snprintf(stack[sptr].param[PARAM_FACE],", "sizeof(stack[0].param[PARAM_FACE]),", "\"{\\\\fn%s}\", tmp);", "}", "if ((param = strchr(param, ' ')))", "param++;", "}", "for (i=0; i<PARAM_NUMBER; i++)", "if (stack[sptr].param[i][0])", "av_bprintf(dst, \"%s\", stack[sptr].param[i]);", "}", "} else if (tagname[0] && !tagname[1] && strspn(tagname, \"bisu\") == 1) {", "av_bprintf(dst, \"{\\\\%c%d}\", tagname[0], !tag_close);", "} else {", "unknown = 1;", "snprintf(tmp, sizeof(tmp), \"</%s>\", tagname);", "}", "if (tag_close) {", "sptr--;", "} else if (unknown && !strstr(in, tmp)) {", "in -= len + tag_close;", "av_bprint_chars(dst, *in, 1);", "} else", "av_strlcpy(stack[sptr++].tag, tagname,", "sizeof(stack[0].tag));", "break;", "}", "}", "default:", "av_bprint_chars(dst, *in, 1);", "break;", "}", "if (*in != ' ' && *in != '\\r' && *in != '\\n')", "line_start = 0;", "}", "if (!av_bprint_is_complete(dst))", "return AVERROR(ENOMEM);", "while (dst->len >= 2 && !strncmp(&dst->str[dst->len - 2], \"\\\\N\", 2))", "dst->len -= 2;", "dst->str[dst->len] = 0;", "rstrip_spaces_buf(dst);", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["GF_Err abst_box_read(GF_Box *s, GF_BitStream *bs)", "{", "GF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;", "int i;", "u32 tmp_strsize;", "char *tmp_str;", "Bool zfound=GF_FALSE;", "GF_Err e;", "ISOM_DECREASE_SIZE(ptr, 25)", "ptr->bootstrapinfo_version = gf_bs_read_u32(bs);", "ptr->profile = gf_bs_read_int(bs, 2);", "ptr->live = gf_bs_read_int(bs, 1);", "ptr->update = gf_bs_read_int(bs, 1);", "ptr->reserved = gf_bs_read_int(bs, 4);", "ptr->time_scale = gf_bs_read_u32(bs);", "ptr->current_media_time = gf_bs_read_u64(bs);", "ptr->smpte_time_code_offset = gf_bs_read_u64(bs);", "i=0;", "if (ptr->size<8) return GF_ISOM_INVALID_FILE;", "tmp_strsize =(u32)ptr->size;", "tmp_str = gf_malloc(sizeof(char)*tmp_strsize);", "if (!tmp_str) return GF_OUT_OF_MEM;", "memset(tmp_str, 0, sizeof(char)*tmp_strsize);", "while (tmp_strsize) {", "ISOM_DECREASE_SIZE(ptr, 1)", "tmp_str[i] = gf_bs_read_u8(bs);", "tmp_strsize--;", "if (!tmp_str[i]) {", "zfound = GF_TRUE;", "break;", "}", "i++;", "}", "if (!zfound)", "return GF_ISOM_INVALID_FILE;", "if (i) {", "ptr->movie_identifier = gf_strdup(tmp_str);", "}", "ISOM_DECREASE_SIZE(ptr, 1)", "ptr->server_entry_count = gf_bs_read_u8(bs);", "for (i=0; i<ptr->server_entry_count; i++) {", "int j=0;", "zfound = GF_FALSE;", "tmp_strsize=(u32)ptr->size;", "while (tmp_strsize) {", "ISOM_DECREASE_SIZE(ptr, 1)", "tmp_str[j] = gf_bs_read_u8(bs);", "tmp_strsize--;", "if (!tmp_str[j]) {", "zfound = GF_TRUE;", "break;", "}", "j++;", "}", "if (!zfound)", "return GF_ISOM_INVALID_FILE;", "if (j) {", "gf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);", "}", "}", "ISOM_DECREASE_SIZE(ptr, 1)", "ptr->quality_entry_count = gf_bs_read_u8(bs);", "for (i=0; i<ptr->quality_entry_count; i++) {", "int j=0;", "zfound = GF_FALSE;", "tmp_strsize=(u32)ptr->size;", "while (tmp_strsize) {", "ISOM_DECREASE_SIZE(ptr, 1)", "tmp_str[j] = gf_bs_read_u8(bs);", "tmp_strsize--;", "if (!tmp_str[j]) {", "zfound = GF_TRUE;", "break;", "}", "j++;", "}", "if (!zfound)", "return GF_ISOM_INVALID_FILE;", "if (j) {", "gf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);", "}", "}", "i=0;", "tmp_strsize=(u32)ptr->size;", "zfound = GF_FALSE;", "while (tmp_strsize) {", "ISOM_DECREASE_SIZE(ptr, 1)", "tmp_str[i] = gf_bs_read_u8(bs);", "tmp_strsize--;", "if (!tmp_str[i]) {", "zfound = GF_TRUE;", "break;", "}", "i++;", "}", "if (!zfound)", "return GF_ISOM_INVALID_FILE;", "if (i) {", "ptr->drm_data = gf_strdup(tmp_str);", "}", "i=0;", "tmp_strsize=(u32)ptr->size;", "zfound = GF_FALSE;", "while (tmp_strsize) {", "ISOM_DECREASE_SIZE(ptr, 1)", "tmp_str[i] = gf_bs_read_u8(bs);", "tmp_strsize--;", "if (!tmp_str[i]) {", "zfound = GF_TRUE;", "break;", "}", "i++;", "}", "if (!zfound)", "return GF_ISOM_INVALID_FILE;", "if (i) {", "ptr->meta_data = gf_strdup(tmp_str);", "}", "ISOM_DECREASE_SIZE(ptr, 1)", "ptr->segment_run_table_count = gf_bs_read_u8(bs);", "for (i=0; i<ptr->segment_run_table_count; i++) {", "GF_AdobeSegmentRunTableBox *asrt = NULL;", "e = gf_isom_box_parse((GF_Box **)&asrt, bs);", "if (e) {", "if (asrt) gf_isom_box_del((GF_Box*)asrt);", "gf_free(tmp_str);", "return e;", "}", "gf_list_add(ptr->segment_run_table_entries, asrt);", "}", "ISOM_DECREASE_SIZE(ptr, 1)", "ptr->fragment_run_table_count = gf_bs_read_u8(bs);", "for (i=0; i<ptr->fragment_run_table_count; i++) {", "GF_AdobeFragmentRunTableBox *afrt = NULL;", "e = gf_isom_box_parse((GF_Box **)&afrt, bs);", "if (e) {", "if (afrt) gf_isom_box_del((GF_Box*)afrt);", "gf_free(tmp_str);", "return e;", "}", "gf_list_add(ptr->fragment_run_table_entries, afrt);", "}", "gf_free(tmp_str);", "return GF_OK;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0]}
{"tokens": ["strncat_from_utf8_libarchive2(struct archive_string *as,", "const void *_p, size_t len, struct archive_string_conv *sc)", "{", "const char *s;", "int n;", "char *p;", "char *end;", "uint32_t unicode;", "#if HAVE_WCRTOMB", "mbstate_t shift_state;", "memset(&shift_state, 0, sizeof(shift_state));", "#else", "wctomb(NULL, L'\\0');", "#endif", "(void)sc;", "if (archive_string_ensure(as, as->length + len + 1) == NULL)", "return (-1);", "s = (const char *)_p;", "p = as->s + as->length;", "end = as->s + as->buffer_length - MB_CUR_MAX -1;", "while ((n = _utf8_to_unicode(&unicode, s, len)) != 0) {", "wchar_t wc;", "if (p >= end) {", "as->length = p - as->s;", "if (archive_string_ensure(as,", "as->length + len * 2 + 1) == NULL)", "return (-1);", "p = as->s + as->length;", "end = as->s + as->buffer_length - MB_CUR_MAX -1;", "}", "if (n < 0) {", "n *= -1;", "wc = L'?';", "} else", "wc = (wchar_t)unicode;", "s += n;", "len -= n;", "#if HAVE_WCRTOMB", "n = (int)wcrtomb(p, wc, &shift_state);", "#else", "n = (int)wctomb(p, wc);", "#endif", "if (n == -1)", "return (-1);", "p += n;", "}", "as->length = p - as->s;", "as->s[as->length] = '\\0';", "return (0);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["hash_link_ref(const uint8_t *link_ref, size_t length)", "{", "size_t i;", "unsigned int hash = 0;", "for (i = 0; i < length; ++i)", "hash = tolower(link_ref[i]) + (hash << 6) + (hash << 16) - hash;", "return hash;", "}"], "ner_tags": [0, 0, 1, 1, 1, 1, 1, 0]}
{"tokens": ["int avi_parse_input_file(avi_t *AVI, int getIndex)", "{", "int i, rate, scale, idx_type;", "s64 n;", "unsigned char *hdrl_data;", "u64 header_offset=0;", "int hdrl_len=0;", "int nvi, nai[AVI_MAX_TRACKS], ioff;", "u64 tot[AVI_MAX_TRACKS];", "u32 j;", "int lasttag = 0;", "int vids_strh_seen = 0;", "int vids_strf_seen = 0;", "int auds_strh_seen = 0;", "int num_stream = 0;", "char data[256];", "s64 oldpos=-1, newpos=-1;", "int aud_chunks = 0;", "if (!AVI) {", "AVI_errno = AVI_ERR_OPEN;", "return 0;", "}", "if (avi_read(AVI->fdes,data,12) != 12 )", "ERR_EXIT(AVI_ERR_READ)", "if (strnicmp(data  ,\"RIFF\",4) !=0 || strnicmp(data+8,\"AVI \",4) !=0 )", "ERR_EXIT(AVI_ERR_NO_AVI)", "hdrl_data = 0;", "while(1)", "{", "if( avi_read(AVI->fdes,data,8) != 8 ) break;", "newpos = gf_ftell(AVI->fdes);", "if(oldpos==newpos) {", "return -1;", "}", "oldpos=newpos;", "n = str2ulong((unsigned char *)data+4);", "n = PAD_EVEN(n);", "if(strnicmp(data,\"LIST\",4) == 0)", "{", "if( avi_read(AVI->fdes,data,4) != 4 ) ERR_EXIT(AVI_ERR_READ)", "n -= 4;", "if(strnicmp(data,\"hdrl\",4) == 0)", "{", "hdrl_len = (u32) n;", "hdrl_data = (unsigned char *) gf_malloc((u32)n);", "if(hdrl_data==0) ERR_EXIT(AVI_ERR_NO_MEM);", "header_offset = gf_ftell(AVI->fdes);", "if( avi_read(AVI->fdes,(char *)hdrl_data, (u32) n) != n ) ERR_EXIT(AVI_ERR_READ)", "}", "else if(strnicmp(data,\"movi\",4) == 0)", "{", "AVI->movi_start = gf_ftell(AVI->fdes);", "if (gf_fseek(AVI->fdes,n,SEEK_CUR)==(u64)-1) break;", "}", "else if (gf_fseek(AVI->fdes,n,SEEK_CUR)==(u64)-1) break;", "}", "else if(strnicmp(data,\"idx1\",4) == 0)", "{", "AVI->n_idx = AVI->max_idx = (u32) (n/16);", "AVI->idx = (unsigned  char((*)[16]) ) gf_malloc((u32)n);", "if(AVI->idx==0) ERR_EXIT(AVI_ERR_NO_MEM)", "if(avi_read(AVI->fdes, (char *) AVI->idx, (u32) n) != n ) {", "gf_free( AVI->idx);", "AVI->idx=NULL;", "AVI->n_idx = 0;", "}", "}", "else", "gf_fseek(AVI->fdes,n,SEEK_CUR);", "}", "if(!hdrl_data      ) ERR_EXIT(AVI_ERR_NO_HDRL)", "if(!AVI->movi_start) ERR_EXIT(AVI_ERR_NO_MOVI)", "for(i=0; i<hdrl_len;)", "{", "#ifdef DEBUG_ODML", "GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] TAG %c%c%c%c\\n\", (hdrl_data+i)[0], (hdrl_data+i)[1], (hdrl_data+i)[2], (hdrl_data+i)[3]));", "#endif", "if(strnicmp((char *)hdrl_data+i,\"LIST\",4)==0) {", "i+= 12;", "continue;", "}", "n = str2ulong(hdrl_data+i+4);", "n = PAD_EVEN(n);", "if(strnicmp((char *)hdrl_data+i,\"strh\",4)==0)", "{", "i += 8;", "#ifdef DEBUG_ODML", "GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] TAG   %c%c%c%c\\n\", (hdrl_data+i)[0], (hdrl_data+i)[1], (hdrl_data+i)[2], (hdrl_data+i)[3]));", "#endif", "if(strnicmp((char *)hdrl_data+i,\"vids\",4) == 0 && !vids_strh_seen)", "{", "memcpy(AVI->compressor,hdrl_data+i+4,4);", "AVI->compressor[4] = 0;", "AVI->v_codech_off = header_offset + i+4;", "scale = str2ulong(hdrl_data+i+20);", "rate  = str2ulong(hdrl_data+i+24);", "if(scale!=0) AVI->fps = (double)rate/(double)scale;", "AVI->video_frames = str2ulong(hdrl_data+i+32);", "AVI->video_strn = num_stream;", "AVI->max_len = 0;", "vids_strh_seen = 1;", "lasttag = 1;", "memcpy(&AVI->video_stream_header, hdrl_data + i,", "sizeof(alAVISTREAMHEADER));", "}", "else if (strnicmp ((char *)hdrl_data+i,\"auds\",4) ==0 && ! auds_strh_seen)", "{", "AVI->aptr=AVI->anum;", "++AVI->anum;", "if(AVI->anum > AVI_MAX_TRACKS) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] error - only %d audio tracks supported\\n\", AVI_MAX_TRACKS));", "return(-1);", "}", "AVI->track[AVI->aptr].audio_bytes = str2ulong(hdrl_data+i+32)*avi_sampsize(AVI, 0);", "AVI->track[AVI->aptr].audio_strn = num_stream;", "AVI->track[AVI->aptr].a_vbr = !str2ulong(hdrl_data+i+44);", "AVI->track[AVI->aptr].padrate = str2ulong(hdrl_data+i+24);", "memcpy(&AVI->stream_headers[AVI->aptr], hdrl_data + i,", "sizeof(alAVISTREAMHEADER));", "lasttag = 2;", "AVI->track[AVI->aptr].a_codech_off = header_offset + i;", "}", "else if (strnicmp ((char*)hdrl_data+i,\"iavs\",4) ==0 && ! auds_strh_seen) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] AVILIB: error - DV AVI Type 1 no supported\\n\"));", "return (-1);", "}", "else", "lasttag = 0;", "num_stream++;", "}", "else if(strnicmp((char*)hdrl_data+i,\"dmlh\",4) == 0) {", "AVI->total_frames = str2ulong(hdrl_data+i+8);", "#ifdef DEBUG_ODML", "GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] real number of frames %d\\n\", AVI->total_frames));", "#endif", "i += 8;", "}", "else if(strnicmp((char *)hdrl_data+i,\"strf\",4)==0)", "{", "i += 8;", "if(lasttag == 1)", "{", "alBITMAPINFOHEADER bih;", "memcpy(&bih, hdrl_data + i, sizeof(alBITMAPINFOHEADER));", "AVI->bitmap_info_header = (alBITMAPINFOHEADER *)", "gf_malloc(str2ulong((unsigned char *)&bih.bi_size));", "if (AVI->bitmap_info_header != NULL)", "memcpy(AVI->bitmap_info_header, hdrl_data + i,", "str2ulong((unsigned char *)&bih.bi_size));", "AVI->width  = str2ulong(hdrl_data+i+4);", "AVI->height = str2ulong(hdrl_data+i+8);", "vids_strf_seen = 1;", "AVI->v_codecf_off = header_offset + i+16;", "memcpy(AVI->compressor2, hdrl_data+i+16, 4);", "AVI->compressor2[4] = 0;", "if (n>40) {", "AVI->extradata_size = (u32) (n - 40);", "AVI->extradata = gf_malloc(sizeof(u8)* AVI->extradata_size);", "memcpy(AVI->extradata, hdrl_data + i + 40, AVI->extradata_size);", "}", "}", "else if(lasttag == 2)", "{", "alWAVEFORMATEX *wfe;", "char *nwfe;", "int wfes;", "if ((u32) (hdrl_len - i) < sizeof(alWAVEFORMATEX))", "wfes = hdrl_len - i;", "else", "wfes = sizeof(alWAVEFORMATEX);", "wfe = (alWAVEFORMATEX *)gf_malloc(sizeof(alWAVEFORMATEX));", "if (wfe != NULL) {", "memset(wfe, 0, sizeof(alWAVEFORMATEX));", "memcpy(wfe, hdrl_data + i, wfes);", "if (str2ushort((unsigned char *)&wfe->cb_size) != 0) {", "nwfe = (char *)", "gf_realloc(wfe, sizeof(alWAVEFORMATEX) +", "str2ushort((unsigned char *)&wfe->cb_size));", "if (nwfe != 0) {", "s64 lpos = gf_ftell(AVI->fdes);", "gf_fseek(AVI->fdes, header_offset + i + sizeof(alWAVEFORMATEX),", "SEEK_SET);", "wfe = (alWAVEFORMATEX *)nwfe;", "nwfe = &nwfe[sizeof(alWAVEFORMATEX)];", "avi_read(AVI->fdes, nwfe,", "str2ushort((unsigned char *)&wfe->cb_size));", "gf_fseek(AVI->fdes, lpos, SEEK_SET);", "}", "}", "AVI->wave_format_ex[AVI->aptr] = wfe;", "}", "AVI->track[AVI->aptr].a_fmt   = str2ushort(hdrl_data+i  );", "AVI->track[AVI->aptr].a_codecf_off = header_offset + i;", "AVI->track[AVI->aptr].a_chans = str2ushort(hdrl_data+i+2);", "AVI->track[AVI->aptr].a_rate  = str2ulong (hdrl_data+i+4);", "AVI->track[AVI->aptr].mp3rate = 8*str2ulong(hdrl_data+i+8)/1000;", "AVI->track[AVI->aptr].a_bits  = str2ushort(hdrl_data+i+14);", "}", "}", "else if(strnicmp((char*)hdrl_data+i,\"indx\",4) == 0) {", "char *a;", "if(lasttag == 1)", "{", "a = (char*)hdrl_data+i;", "AVI->video_superindex = (avisuperindex_chunk *) gf_malloc (sizeof (avisuperindex_chunk));", "memset(AVI->video_superindex, 0, sizeof (avisuperindex_chunk));", "memcpy (AVI->video_superindex->fcc, a, 4);", "a += 4;", "AVI->video_superindex->dwSize = str2ulong((unsigned char *)a);", "a += 4;", "AVI->video_superindex->wLongsPerEntry = str2ushort((unsigned char *)a);", "a += 2;", "AVI->video_superindex->bIndexSubType = *a;", "a += 1;", "AVI->video_superindex->bIndexType = *a;", "a += 1;", "AVI->video_superindex->nEntriesInUse = str2ulong((unsigned char *)a);", "a += 4;", "memcpy (AVI->video_superindex->dwChunkId, a, 4);", "a += 4;", "a += 4;", "a += 4;", "a += 4;", "if (AVI->video_superindex->bIndexSubType != 0) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] Invalid Header, bIndexSubType != 0\\n\"));", "}", "AVI->video_superindex->aIndex = (avisuperindex_entry*)", "gf_malloc (AVI->video_superindex->wLongsPerEntry * AVI->video_superindex->nEntriesInUse * sizeof (u32));", "for (j=0; j<AVI->video_superindex->nEntriesInUse; ++j) {", "AVI->video_superindex->aIndex[j].qwOffset = str2ullong ((unsigned char*)a);", "a += 8;", "AVI->video_superindex->aIndex[j].dwSize = str2ulong ((unsigned char*)a);", "a += 4;", "AVI->video_superindex->aIndex[j].dwDuration = str2ulong ((unsigned char*)a);", "a += 4;", "#ifdef DEBUG_ODML", "GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d] 0x%llx 0x%lx %lu\\n\", j,", "(unsigned int long)AVI->video_superindex->aIndex[j].qwOffset,", "(unsigned long)AVI->video_superindex->aIndex[j].dwSize,", "(unsigned long)AVI->video_superindex->aIndex[j].dwDuration));", "#endif", "}", "#ifdef DEBUG_ODML", "GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] FOURCC \\\"%c%c%c%c\\\"\\n\", AVI->video_superindex->fcc[0], AVI->video_superindex->fcc[1],", "AVI->video_superindex->fcc[2], AVI->video_superindex->fcc[3]));", "GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] LEN \\\"%ld\\\"\\n\", (long)AVI->video_superindex->dwSize));", "GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] wLongsPerEntry \\\"%d\\\"\\n\", AVI->video_superindex->wLongsPerEntry));", "GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] bIndexSubType \\\"%d\\\"\\n\", AVI->video_superindex->bIndexSubType));", "GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] bIndexType \\\"%d\\\"\\n\", AVI->video_superindex->bIndexType));", "GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] nEntriesInUse \\\"%ld\\\"\\n\", (long)AVI->video_superindex->nEntriesInUse));", "GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] dwChunkId \\\"%c%c%c%c\\\"\\n\", AVI->video_superindex->dwChunkId[0], AVI->video_superindex->dwChunkId[1],", "AVI->video_superindex->dwChunkId[2], AVI->video_superindex->dwChunkId[3]));", "#endif", "AVI->is_opendml = 1;", "}", "else if(lasttag == 2)", "{", "a = (char*) hdrl_data+i;", "AVI->track[AVI->aptr].audio_superindex = (avisuperindex_chunk *) gf_malloc (sizeof (avisuperindex_chunk));", "memcpy (AVI->track[AVI->aptr].audio_superindex->fcc, a, 4);", "a += 4;", "AVI->track[AVI->aptr].audio_superindex->dwSize = str2ulong((unsigned char*)a);", "a += 4;", "AVI->track[AVI->aptr].audio_superindex->wLongsPerEntry = str2ushort((unsigned char*)a);", "a += 2;", "AVI->track[AVI->aptr].audio_superindex->bIndexSubType = *a;", "a += 1;", "AVI->track[AVI->aptr].audio_superindex->bIndexType = *a;", "a += 1;", "AVI->track[AVI->aptr].audio_superindex->nEntriesInUse = str2ulong((unsigned char*)a);", "a += 4;", "memcpy (AVI->track[AVI->aptr].audio_superindex->dwChunkId, a, 4);", "a += 4;", "a += 4;", "a += 4;", "a += 4;", "if (AVI->track[AVI->aptr].audio_superindex->bIndexSubType != 0) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] Invalid Header, bIndexSubType != 0\\n\"));", "}", "AVI->track[AVI->aptr].audio_superindex->aIndex = (avisuperindex_entry*)", "gf_malloc (AVI->track[AVI->aptr].audio_superindex->wLongsPerEntry *", "AVI->track[AVI->aptr].audio_superindex->nEntriesInUse * sizeof (u32));", "for (j=0; j<AVI->track[AVI->aptr].audio_superindex->nEntriesInUse; ++j) {", "AVI->track[AVI->aptr].audio_superindex->aIndex[j].qwOffset = str2ullong ((unsigned char*)a);", "a += 8;", "AVI->track[AVI->aptr].audio_superindex->aIndex[j].dwSize = str2ulong ((unsigned char*)a);", "a += 4;", "AVI->track[AVI->aptr].audio_superindex->aIndex[j].dwDuration = str2ulong ((unsigned char*)a);", "a += 4;", "#ifdef DEBUG_ODML", "GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d] 0x%llx 0x%lx %lu\\n\", j,", "(unsigned int long)AVI->track[AVI->aptr].audio_superindex->aIndex[j].qwOffset,", "(unsigned long)AVI->track[AVI->aptr].audio_superindex->aIndex[j].dwSize,", "(unsigned long)AVI->track[AVI->aptr].audio_superindex->aIndex[j].dwDuration));", "#endif", "}", "AVI->track[AVI->aptr].audio_superindex->stdindex = NULL;", "#ifdef DEBUG_ODML", "GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] FOURCC \\\"%.4s\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->fcc));", "GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] LEN \\\"%ld\\\"\\n\", (long)AVI->track[AVI->aptr].audio_superindex->dwSize));", "GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] wLongsPerEntry \\\"%d\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->wLongsPerEntry));", "GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] bIndexSubType \\\"%d\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->bIndexSubType));", "GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] bIndexType \\\"%d\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->bIndexType));", "GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] nEntriesInUse \\\"%ld\\\"\\n\", (long)AVI->track[AVI->aptr].audio_superindex->nEntriesInUse));", "GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] dwChunkId \\\"%.4s\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->dwChunkId[0]));", "#endif", "}", "i += 8;", "}", "else if((strnicmp((char*)hdrl_data+i,\"JUNK\",4) == 0) ||", "(strnicmp((char*)hdrl_data+i,\"strn\",4) == 0) ||", "(strnicmp((char*)hdrl_data+i,\"vprp\",4) == 0)) {", "i += 8;", "} else", "{", "i += 8;", "lasttag = 0;", "}", "i += (u32) n;", "}", "gf_free(hdrl_data);", "if(!vids_strh_seen || !vids_strf_seen) ERR_EXIT(AVI_ERR_NO_VIDS)", "AVI->video_tag[0] = AVI->video_strn/10 + '0';", "AVI->video_tag[1] = AVI->video_strn%10 + '0';", "AVI->video_tag[2] = 'd';", "AVI->video_tag[3] = 'b';", "if(!AVI->track[0].a_chans) AVI->track[0].audio_strn = 99;", "{", "int tk=0;", "for(j=0; j<AVI->anum+1; ++j) {", "if (j == AVI->video_strn) continue;", "AVI->track[tk].audio_tag[0] = j/10 + '0';", "AVI->track[tk].audio_tag[1] = j%10 + '0';", "AVI->track[tk].audio_tag[2] = 'w';", "AVI->track[tk].audio_tag[3] = 'b';", "++tk;", "}", "}", "gf_fseek(AVI->fdes,AVI->movi_start,SEEK_SET);", "if(!getIndex) return(0);", "idx_type = 0;", "if(AVI->idx)", "{", "s64 pos, len;", "for(i=0; i<AVI->n_idx; i++)", "if( strnicmp((char *)AVI->idx[i],(char *)AVI->video_tag,3)==0 ) break;", "if(i>=AVI->n_idx) ERR_EXIT(AVI_ERR_NO_VIDS)", "pos = str2ulong(AVI->idx[i]+ 8);", "len = str2ulong(AVI->idx[i]+12);", "gf_fseek(AVI->fdes,pos,SEEK_SET);", "if(avi_read(AVI->fdes,data,8)!=8) ERR_EXIT(AVI_ERR_READ)", "if( strnicmp(data,(char *)AVI->idx[i],4)==0 && str2ulong((unsigned char *)data+4)==len )", "{", "idx_type = 1;", "}", "else", "{", "gf_fseek(AVI->fdes,pos+AVI->movi_start-4,SEEK_SET);", "if(avi_read(AVI->fdes,data,8)!=8) ERR_EXIT(AVI_ERR_READ)", "if( strnicmp(data,(char *)AVI->idx[i],4)==0 && str2ulong((unsigned char *)data+4)==len )", "{", "idx_type = 2;", "}", "}", "}", "if(idx_type == 0 && !AVI->is_opendml && !AVI->total_frames)", "{", "gf_fseek(AVI->fdes, AVI->movi_start, SEEK_SET);", "AVI->n_idx = 0;", "while(1)", "{", "if( avi_read(AVI->fdes,data,8) != 8 ) break;", "n = str2ulong((unsigned char *)data+4);", "if(strnicmp(data,\"LIST\",4)==0)", "{", "gf_fseek(AVI->fdes,4,SEEK_CUR);", "continue;", "}", "if( ( (data[2]=='d' || data[2]=='D') &&", "(data[3]=='b' || data[3]=='B' || data[3]=='c' || data[3]=='C') )", "|| ( (data[2]=='w' || data[2]=='W') &&", "(data[3]=='b' || data[3]=='B') ) )", "{", "u64 __pos = gf_ftell(AVI->fdes) - 8;", "avi_add_index_entry(AVI,(unsigned char *)data,0,__pos,n);", "}", "gf_fseek(AVI->fdes,PAD_EVEN(n),SEEK_CUR);", "}", "idx_type = 1;", "}", "if (AVI->is_opendml) {", "u64 offset = 0;", "hdrl_len = 4+4+2+1+1+4+4+8+4;", "char *en, *chunk_start;", "int k = 0;", "u32 audtr = 0;", "u32 nrEntries = 0;", "AVI->video_index = NULL;", "nvi = 0;", "for(audtr=0; audtr<AVI->anum; ++audtr) {", "nai[audtr] = 0;", "tot[audtr] = 0;", "}", "for (j=0; j<AVI->video_superindex->nEntriesInUse; j++) {", "chunk_start = en = (char*) gf_malloc ((u32) (AVI->video_superindex->aIndex[j].dwSize+hdrl_len) );", "if (gf_fseek(AVI->fdes, AVI->video_superindex->aIndex[j].qwOffset, SEEK_SET) == (u64)-1) {", "gf_free(chunk_start);", "continue;", "}", "if (avi_read(AVI->fdes, en, (u32) (AVI->video_superindex->aIndex[j].dwSize+hdrl_len) ) <= 0) {", "gf_free(chunk_start);", "continue;", "}", "nrEntries = str2ulong((unsigned char*)en + 12);", "#ifdef DEBUG_ODML", "#endif", "offset = str2ullong((unsigned char*)en + 20);", "en += hdrl_len;", "nvi += nrEntries;", "AVI->video_index = (video_index_entry *) gf_realloc (AVI->video_index, nvi * sizeof (video_index_entry));", "if (!AVI->video_index) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] out of mem (size = %ld)\\n\", nvi * sizeof (video_index_entry)));", "exit(1);", "}", "while (k < nvi) {", "AVI->video_index[k].pos = offset + str2ulong((unsigned char*)en);", "en += 4;", "AVI->video_index[k].len = str2ulong_len((unsigned char*)en);", "AVI->video_index[k].key = str2ulong_key((unsigned char*)en);", "en += 4;", "if (AVI->video_index[k].pos-offset == 0 && AVI->video_index[k].len == 0) {", "k--;", "nvi--;", "}", "#ifdef DEBUG_ODML", "#endif", "k++;", "}", "gf_free(chunk_start);", "}", "AVI->video_frames = nvi;", "if (AVI->video_frames == 0) {", "AVI->is_opendml=0;", "goto multiple_riff;", "}", "for(audtr=0; audtr<AVI->anum; ++audtr) {", "k = 0;", "if (!AVI->track[audtr].audio_superindex) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] (%s) cannot read audio index for track %d\\n\", __FILE__, audtr));", "continue;", "}", "for (j=0; j<AVI->track[audtr].audio_superindex->nEntriesInUse; j++) {", "chunk_start = en = (char*)gf_malloc ((u32) (AVI->track[audtr].audio_superindex->aIndex[j].dwSize+hdrl_len));", "if (gf_fseek(AVI->fdes, AVI->track[audtr].audio_superindex->aIndex[j].qwOffset, SEEK_SET) == (u64)-1) {", "gf_free(chunk_start);", "continue;", "}", "if (avi_read(AVI->fdes, en, (u32) (AVI->track[audtr].audio_superindex->aIndex[j].dwSize+hdrl_len)) <= 0) {", "gf_free(chunk_start);", "continue;", "}", "nrEntries = str2ulong((unsigned char*)en + 12);", "#ifdef DEBUG_ODML", "#endif", "offset = str2ullong((unsigned char*)en + 20);", "en += hdrl_len;", "nai[audtr] += nrEntries;", "AVI->track[audtr].audio_index = (audio_index_entry *) gf_realloc (AVI->track[audtr].audio_index, nai[audtr] * sizeof (audio_index_entry));", "while (k < nai[audtr]) {", "AVI->track[audtr].audio_index[k].pos = offset + str2ulong((unsigned char*)en);", "en += 4;", "AVI->track[audtr].audio_index[k].len = str2ulong_len((unsigned char*)en);", "en += 4;", "AVI->track[audtr].audio_index[k].tot = tot[audtr];", "tot[audtr] += AVI->track[audtr].audio_index[k].len;", "#ifdef DEBUG_ODML", "#endif", "++k;", "}", "gf_free(chunk_start);", "}", "AVI->track[audtr].audio_chunks = nai[audtr];", "AVI->track[audtr].audio_bytes = tot[audtr];", "}", "}", "else if (AVI->total_frames && !AVI->is_opendml && idx_type==0) {", "multiple_riff:", "gf_fseek(AVI->fdes, AVI->movi_start, SEEK_SET);", "AVI->n_idx = 0;", "GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] Reconstructing index...\"));", "nvi = AVI->video_frames = AVI->total_frames;", "nai[0] = AVI->track[0].audio_chunks = AVI->total_frames;", "for(j=1; j<AVI->anum; ++j) AVI->track[j].audio_chunks = 0;", "AVI->video_index = (video_index_entry *) gf_malloc(nvi*sizeof(video_index_entry));", "if(AVI->video_index==0) ERR_EXIT(AVI_ERR_NO_MEM);", "for(j=0; j<AVI->anum; ++j) {", "if(AVI->track[j].audio_chunks) {", "AVI->track[j].audio_index = (audio_index_entry *) gf_malloc((nai[j]+1)*sizeof(audio_index_entry));", "memset(AVI->track[j].audio_index, 0, (nai[j]+1)*(sizeof(audio_index_entry)));", "if(AVI->track[j].audio_index==0) ERR_EXIT(AVI_ERR_NO_MEM);", "}", "}", "nvi = 0;", "for(j=0; j<AVI->anum; ++j) {", "nai[j] = 0;", "tot[j] = 0;", "}", "aud_chunks = AVI->total_frames;", "while(1)", "{", "if (nvi >= AVI->total_frames) break;", "if( avi_read(AVI->fdes,data,8) != 8 ) break;", "n = str2ulong((unsigned char *)data+4);", "j=0;", "if (aud_chunks - nai[j] -1 <= 0) {", "aud_chunks += AVI->total_frames;", "AVI->track[j].audio_index = (audio_index_entry *)", "gf_realloc( AVI->track[j].audio_index, (aud_chunks+1)*sizeof(audio_index_entry));", "if (!AVI->track[j].audio_index) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] Internal error in avilib -- no mem\\n\"));", "AVI_errno = AVI_ERR_NO_MEM;", "return -1;", "}", "}", "if(", "(data[0]=='0' || data[1]=='0') &&", "(data[2]=='d' || data[2]=='D') &&", "(data[3]=='b' || data[3]=='B' || data[3]=='c' || data[3]=='C') ) {", "AVI->video_index[nvi].key = 0x0;", "AVI->video_index[nvi].pos = gf_ftell(AVI->fdes);", "AVI->video_index[nvi].len = (u32) n;", "nvi++;", "gf_fseek(AVI->fdes,PAD_EVEN(n),SEEK_CUR);", "}", "else if(", "(data[0]=='0' || data[1]=='1') &&", "(data[2]=='w' || data[2]=='W') &&", "(data[3]=='b' || data[3]=='B') ) {", "AVI->track[j].audio_index[nai[j]].pos = gf_ftell(AVI->fdes);", "AVI->track[j].audio_index[nai[j]].len = (u32) n;", "AVI->track[j].audio_index[nai[j]].tot = tot[j];", "tot[j] += AVI->track[j].audio_index[nai[j]].len;", "nai[j]++;", "gf_fseek(AVI->fdes,PAD_EVEN(n),SEEK_CUR);", "}", "else {", "gf_fseek(AVI->fdes,-4,SEEK_CUR);", "}", "}", "if (nvi < AVI->total_frames) {", "GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[avilib] Uh? Some frames seems missing (%ld/%d)\\n\",", "nvi,  AVI->total_frames));", "}", "AVI->video_frames = nvi;", "AVI->track[0].audio_chunks = nai[0];", "for(j=0; j<AVI->anum; ++j) AVI->track[j].audio_bytes = tot[j];", "GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] done. nvi=%ld nai=%ld tot=%ld\\n\", nvi, nai[0], tot[0]));", "}", "else", "{", "nvi = 0;", "for(j=0; j<AVI->anum; ++j) nai[j] = 0;", "for(i=0; i<AVI->n_idx; i++) {", "if(strnicmp((char *)AVI->idx[i],AVI->video_tag,3) == 0) nvi++;", "for(j=0; j<AVI->anum; ++j) if(strnicmp((char *)AVI->idx[i], AVI->track[j].audio_tag,4) == 0) nai[j]++;", "}", "AVI->video_frames = nvi;", "for(j=0; j<AVI->anum; ++j) AVI->track[j].audio_chunks = nai[j];", "if(AVI->video_frames==0) ERR_EXIT(AVI_ERR_NO_VIDS);", "AVI->video_index = (video_index_entry *) gf_malloc(nvi*sizeof(video_index_entry));", "if(AVI->video_index==0) ERR_EXIT(AVI_ERR_NO_MEM);", "for(j=0; j<AVI->anum; ++j) {", "if(AVI->track[j].audio_chunks) {", "AVI->track[j].audio_index = (audio_index_entry *) gf_malloc((nai[j]+1)*sizeof(audio_index_entry));", "memset(AVI->track[j].audio_index, 0, (nai[j]+1)*(sizeof(audio_index_entry)));", "if(AVI->track[j].audio_index==0) ERR_EXIT(AVI_ERR_NO_MEM);", "}", "}", "nvi = 0;", "for(j=0; j<AVI->anum; ++j) {", "nai[j] = 0;", "tot[j] = 0;", "}", "ioff = idx_type == 1 ? 8 : (u32)AVI->movi_start+4;", "for(i=0; i<AVI->n_idx; i++) {", "if(strnicmp((char *)AVI->idx[i],AVI->video_tag,3) == 0) {", "AVI->video_index[nvi].key = str2ulong(AVI->idx[i]+ 4);", "AVI->video_index[nvi].pos = str2ulong(AVI->idx[i]+ 8)+ioff;", "AVI->video_index[nvi].len = str2ulong(AVI->idx[i]+12);", "nvi++;", "}", "for(j=0; j<AVI->anum; ++j) {", "if(strnicmp((char *)AVI->idx[i],AVI->track[j].audio_tag,4) == 0) {", "AVI->track[j].audio_index[nai[j]].pos = str2ulong(AVI->idx[i]+ 8)+ioff;", "AVI->track[j].audio_index[nai[j]].len = str2ulong(AVI->idx[i]+12);", "AVI->track[j].audio_index[nai[j]].tot = tot[j];", "tot[j] += AVI->track[j].audio_index[nai[j]].len;", "nai[j]++;", "}", "}", "}", "for(j=0; j<AVI->anum; ++j) AVI->track[j].audio_bytes = tot[j];", "}", "gf_fseek(AVI->fdes,AVI->movi_start,SEEK_SET);", "AVI->video_pos = 0;", "return(0);", "}"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static void show_frame(WriterContext *w, AVFrame *frame, AVStream *stream,", "AVFormatContext *fmt_ctx)", "{", "AVBPrint pbuf;", "char val_str[128];", "const char *s;", "int i;", "av_bprint_init(&pbuf, 1, AV_BPRINT_SIZE_UNLIMITED);", "writer_print_section_header(w, SECTION_ID_FRAME);", "s = av_get_media_type_string(stream->codecpar->codec_type);", "if (s) print_str    (\"media_type\", s);", "else   print_str_opt(\"media_type\", \"unknown\");", "print_int(\"stream_index\",           stream->index);", "print_int(\"key_frame\",              frame->key_frame);", "print_ts  (\"pkt_pts\",               frame->pts);", "print_time(\"pkt_pts_time\",          frame->pts, &stream->time_base);", "print_ts  (\"pkt_dts\",               frame->pkt_dts);", "print_time(\"pkt_dts_time\",          frame->pkt_dts, &stream->time_base);", "print_ts  (\"best_effort_timestamp\", frame->best_effort_timestamp);", "print_time(\"best_effort_timestamp_time\", frame->best_effort_timestamp, &stream->time_base);", "print_duration_ts  (\"pkt_duration\",      frame->pkt_duration);", "print_duration_time(\"pkt_duration_time\", frame->pkt_duration, &stream->time_base);", "if (frame->pkt_pos != -1) print_fmt    (\"pkt_pos\", \"%\"PRId64, frame->pkt_pos);", "else                      print_str_opt(\"pkt_pos\", \"N/A\");", "if (frame->pkt_size != -1) print_val    (\"pkt_size\", frame->pkt_size, unit_byte_str);", "else                       print_str_opt(\"pkt_size\", \"N/A\");", "switch (stream->codecpar->codec_type) {", "AVRational sar;", "case AVMEDIA_TYPE_VIDEO:", "print_int(\"width\",                  frame->width);", "print_int(\"height\",                 frame->height);", "s = av_get_pix_fmt_name(frame->format);", "if (s) print_str    (\"pix_fmt\", s);", "else   print_str_opt(\"pix_fmt\", \"unknown\");", "sar = av_guess_sample_aspect_ratio(fmt_ctx, stream, frame);", "if (sar.num) {", "print_q(\"sample_aspect_ratio\", sar, ':');", "} else {", "print_str_opt(\"sample_aspect_ratio\", \"N/A\");", "}", "print_fmt(\"pict_type\",              \"%c\", av_get_picture_type_char(frame->pict_type));", "print_int(\"coded_picture_number\",   frame->coded_picture_number);", "print_int(\"display_picture_number\", frame->display_picture_number);", "print_int(\"interlaced_frame\",       frame->interlaced_frame);", "print_int(\"top_field_first\",        frame->top_field_first);", "print_int(\"repeat_pict\",            frame->repeat_pict);", "if (frame->color_range != AVCOL_RANGE_UNSPECIFIED)", "print_str(\"color_range\", av_color_range_name(frame->color_range));", "else", "print_str_opt(\"color_range\", av_color_range_name(frame->color_range));", "if (frame->colorspace != AVCOL_SPC_UNSPECIFIED)", "print_str(\"color_space\", av_color_space_name(frame->colorspace));", "else", "print_str_opt(\"color_space\", av_color_space_name(frame->colorspace));", "if (frame->color_primaries != AVCOL_PRI_UNSPECIFIED)", "print_str(\"color_primaries\", av_color_primaries_name(frame->color_primaries));", "else", "print_str_opt(\"color_primaries\", av_color_primaries_name(frame->color_primaries));", "if (frame->color_trc != AVCOL_TRC_UNSPECIFIED)", "print_str(\"color_transfer\", av_color_transfer_name(frame->color_trc));", "else", "print_str_opt(\"color_transfer\", av_color_transfer_name(frame->color_trc));", "if (frame->chroma_location != AVCHROMA_LOC_UNSPECIFIED)", "print_str(\"chroma_location\", av_chroma_location_name(frame->chroma_location));", "else", "print_str_opt(\"chroma_location\", av_chroma_location_name(frame->chroma_location));", "break;", "case AVMEDIA_TYPE_AUDIO:", "s = av_get_sample_fmt_name(frame->format);", "if (s) print_str    (\"sample_fmt\", s);", "else   print_str_opt(\"sample_fmt\", \"unknown\");", "print_int(\"nb_samples\",         frame->nb_samples);", "print_int(\"channels\", frame->channels);", "if (frame->channel_layout) {", "av_bprint_clear(&pbuf);", "av_bprint_channel_layout(&pbuf, frame->channels,", "frame->channel_layout);", "print_str    (\"channel_layout\", pbuf.str);", "} else", "print_str_opt(\"channel_layout\", \"unknown\");", "break;", "}", "if (do_show_frame_tags)", "show_tags(w, frame->metadata, SECTION_ID_FRAME_TAGS);", "if (do_show_log)", "show_log(w, SECTION_ID_FRAME_LOGS, SECTION_ID_FRAME_LOG, do_show_log);", "if (frame->nb_side_data) {", "writer_print_section_header(w, SECTION_ID_FRAME_SIDE_DATA_LIST);", "for (i = 0; i < frame->nb_side_data; i++) {", "AVFrameSideData *sd = frame->side_data[i];", "const char *name;", "writer_print_section_header(w, SECTION_ID_FRAME_SIDE_DATA);", "name = av_frame_side_data_name(sd->type);", "print_str(\"side_data_type\", name ? name : \"unknown\");", "if (sd->type == AV_FRAME_DATA_DISPLAYMATRIX && sd->size >= 9*4) {", "writer_print_integers(w, \"displaymatrix\", sd->data, 9, \" %11d\", 3, 4, 1);", "print_int(\"rotation\", av_display_rotation_get((int32_t *)sd->data));", "} else if (sd->type == AV_FRAME_DATA_GOP_TIMECODE && sd->size >= 8) {", "char tcbuf[AV_TIMECODE_STR_SIZE];", "av_timecode_make_mpeg_tc_string(tcbuf, *(int64_t *)(sd->data));", "print_str(\"timecode\", tcbuf);", "} else if (sd->type == AV_FRAME_DATA_MASTERING_DISPLAY_METADATA) {", "AVMasteringDisplayMetadata *metadata = (AVMasteringDisplayMetadata *)sd->data;", "if (metadata->has_primaries) {", "print_q(\"red_x\", metadata->display_primaries[0][0], '/');", "print_q(\"red_y\", metadata->display_primaries[0][1], '/');", "print_q(\"green_x\", metadata->display_primaries[1][0], '/');", "print_q(\"green_y\", metadata->display_primaries[1][1], '/');", "print_q(\"blue_x\", metadata->display_primaries[2][0], '/');", "print_q(\"blue_y\", metadata->display_primaries[2][1], '/');", "print_q(\"white_point_x\", metadata->white_point[0], '/');", "print_q(\"white_point_y\", metadata->white_point[1], '/');", "}", "if (metadata->has_luminance) {", "print_q(\"min_luminance\", metadata->min_luminance, '/');", "print_q(\"max_luminance\", metadata->max_luminance, '/');", "}", "} else if (sd->type == AV_FRAME_DATA_CONTENT_LIGHT_LEVEL) {", "AVContentLightMetadata *metadata = (AVContentLightMetadata *)sd->data;", "print_int(\"max_content\", metadata->MaxCLL);", "print_int(\"max_average\", metadata->MaxFALL);", "} else if (sd->type == AV_FRAME_DATA_ICC_PROFILE) {", "AVDictionaryEntry *tag = av_dict_get(sd->metadata, \"name\", NULL, AV_DICT_MATCH_CASE);", "if (tag)", "print_str(tag->key, tag->value);", "print_int(\"size\", sd->size);", "}", "writer_print_section_footer(w);", "}", "writer_print_section_footer(w);", "}", "writer_print_section_footer(w);", "av_bprint_finalize(&pbuf, NULL);", "fflush(stdout);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["RemoteFsDevice::RemoteFsDevice(MusicLibraryModel *m, const DeviceOptions &options, const Details &d)", ": FsDevice(m, d.name, createUdi(d.name))", ", mountToken(0)", ", currentMountStatus(false)", ", details(d)", ", proc(0)", ", mounterIface(0)", ", messageSent(false)", "{", "opts=options;", "load();", "mount();", "icn=MonoIcon::icon(details.isLocalFile()", "? FontAwesome::foldero", ": constSshfsProtocol==details.url.scheme()", "? FontAwesome::linux_os", ": FontAwesome::windows, Utils::monoIconColor());", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["bool SQClass::NewSlot(SQSharedState *ss,const SQObjectPtr &key,const SQObjectPtr &val,bool bstatic)", "{", "SQObjectPtr temp;", "bool belongs_to_static_table = sq_type(val) == OT_CLOSURE || sq_type(val) == OT_NATIVECLOSURE || bstatic;", "if(_locked && !belongs_to_static_table)", "return false;", "if(_members->Get(key,temp) && _isfield(temp))", "{", "_defaultvalues[_member_idx(temp)].val = val;", "return true;", "}", "if(belongs_to_static_table) {", "SQInteger mmidx;", "if((sq_type(val) == OT_CLOSURE || sq_type(val) == OT_NATIVECLOSURE) &&", "(mmidx = ss->GetMetaMethodIdxByName(key)) != -1) {", "_metamethods[mmidx] = val;", "}", "else {", "SQObjectPtr theval = val;", "if(_base && sq_type(val) == OT_CLOSURE) {", "theval = _closure(val)->Clone();", "_closure(theval)->_base = _base;", "__ObjAddRef(_base);", "}", "if(sq_type(temp) == OT_NULL) {", "bool isconstructor;", "SQVM::IsEqual(ss->_constructoridx, key, isconstructor);", "if(isconstructor) {", "_constructoridx = (SQInteger)_methods.size();", "}", "SQClassMember m;", "m.val = theval;", "_members->NewSlot(key,SQObjectPtr(_make_method_idx(_methods.size())));", "_methods.push_back(m);", "}", "else {", "_methods[_member_idx(temp)].val = theval;", "}", "}", "return true;", "}", "SQClassMember m;", "m.val = val;", "_members->NewSlot(key,SQObjectPtr(_make_field_idx(_defaultvalues.size())));", "_defaultvalues.push_back(m);", "return true;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["GF_Err url_box_read(GF_Box *s, GF_BitStream *bs)", "{", "GF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;", "if (ptr->size) {", "ptr->location = (char*)gf_malloc((u32) ptr->size);", "if (! ptr->location) return GF_OUT_OF_MEM;", "gf_bs_read_data(bs, ptr->location, (u32)ptr->size);", "}", "return GF_OK;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["add_link_ref(", "struct link_ref **references,", "const uint8_t *name, size_t name_size)", "{", "struct link_ref *ref = calloc(1, sizeof(struct link_ref));", "if (!ref)", "return NULL;", "ref->id = hash_link_ref(name, name_size);", "ref->next = references[ref->id % REF_TABLE_SIZE];", "references[ref->id % REF_TABLE_SIZE] = ref;", "return ref;", "}"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0]}
{"tokens": ["int main(int argc, char *argv[])", "{", "bool lrzcat = false, compat = false, recurse = false;", "bool options_file = false, conf_file_compression_set = false;", "struct timeval start_time, end_time;", "struct sigaction handler;", "double seconds,total_time;", "bool nice_set = false;", "int c, i;", "int hours,minutes;", "extern int optind;", "char *eptr, *av;", "char *endptr = NULL;", "control = &base_control;", "initialise_control(control);", "av = basename(argv[0]);", "if (!strcmp(av, \"lrunzip\"))", "control->flags |= FLAG_DECOMPRESS;", "else if (!strcmp(av, \"lrzcat\")) {", "control->flags |= FLAG_DECOMPRESS | FLAG_STDOUT;", "lrzcat = true;", "} else if (!strcmp(av, \"lrz\")) {", "control->flags &= ~FLAG_SHOW_PROGRESS;", "control->flags &= ~FLAG_KEEP_FILES;", "compat = true;", "long_options[1].name = \"stdout\";", "long_options[11].name = \"keep\";", "}", "CrcGenerateTable();", "eptr = getenv(\"LRZIP\");", "if (eptr == NULL)", "options_file = read_config(control);", "else if (!strstr(eptr,\"NOCONFIG\"))", "options_file = read_config(control);", "if (options_file && (control->flags & FLAG_NOT_LZMA))", "conf_file_compression_set = true;", "while ((c = getopt_long(argc, argv, compat ? coptions : loptions, long_options, &i)) != -1) {", "switch (c) {", "case 'b':", "case 'g':", "case 'l':", "case 'n':", "case 'z':", "if ((control->flags & FLAG_NOT_LZMA) && conf_file_compression_set == false)", "failure(\"Can only use one of -l, -b, -g, -z or -n\\n\");", "control->flags &= ~FLAG_NOT_LZMA;", "if (c == 'b')", "control->flags |= FLAG_BZIP2_COMPRESS;", "else if (c == 'g')", "control->flags |= FLAG_ZLIB_COMPRESS;", "else if (c == 'l')", "control->flags |= FLAG_LZO_COMPRESS;", "else if (c == 'n')", "control->flags |= FLAG_NO_COMPRESS;", "else if (c == 'z')", "control->flags |= FLAG_ZPAQ_COMPRESS;", "conf_file_compression_set = false;", "break;", "case '/':", "control->flags &= ~FLAG_NOT_LZMA;", "break;", "case 'c':", "if (compat) {", "control->flags |= FLAG_KEEP_FILES;", "set_stdout(control);", "break;", "}", "case 'C':", "control->flags |= FLAG_CHECK;", "control->flags |= FLAG_HASH;", "break;", "case 'd':", "control->flags |= FLAG_DECOMPRESS;", "break;", "case 'D':", "control->flags &= ~FLAG_KEEP_FILES;", "break;", "case 'e':", "control->flags |= FLAG_ENCRYPT;", "control->passphrase = optarg;", "break;", "case 'f':", "control->flags |= FLAG_FORCE_REPLACE;", "break;", "case 'h':", "usage(compat);", "exit(0);", "break;", "case 'H':", "control->flags |= FLAG_HASH;", "break;", "case 'i':", "control->flags |= FLAG_INFO;", "control->flags &= ~FLAG_DECOMPRESS;", "break;", "case 'k':", "if (compat) {", "control->flags |= FLAG_KEEP_FILES;", "break;", "}", "case 'K':", "control->flags |= FLAG_KEEP_BROKEN;", "break;", "case 'L':", "if (compat) {", "license();", "exit(0);", "}", "control->compression_level = strtol(optarg, &endptr, 10);", "if (control->compression_level < 1 || control->compression_level > 9)", "failure(\"Invalid compression level (must be 1-9)\\n\");", "if (*endptr)", "failure(\"Extra characters after compression level: \\'%s\\'\\n\", endptr);", "break;", "case 'm':", "control->ramsize = strtol(optarg, &endptr, 10) * 1024 * 1024 * 100;", "if (*endptr)", "failure(\"Extra characters after ramsize: \\'%s\\'\\n\", endptr);", "break;", "case 'N':", "nice_set = true;", "control->nice_val = strtol(optarg, &endptr, 10);", "if (control->nice_val < PRIO_MIN || control->nice_val > PRIO_MAX)", "failure(\"Invalid nice value (must be %d...%d)\\n\", PRIO_MIN, PRIO_MAX);", "if (*endptr)", "failure(\"Extra characters after nice level: \\'%s\\'\\n\", endptr);", "break;", "case 'o':", "if (control->outdir)", "failure(\"Cannot have -o and -O together\\n\");", "if (unlikely(STDOUT))", "failure(\"Cannot specify an output filename when outputting to stdout\\n\");", "control->outname = optarg;", "control->suffix = \"\";", "break;", "case 'O':", "if (control->outname)", "failure(\"Cannot have options -o and -O together\\n\");", "if (unlikely(STDOUT))", "failure(\"Cannot specify an output directory when outputting to stdout\\n\");", "control->outdir = malloc(strlen(optarg) + 2);", "if (control->outdir == NULL)", "fatal(\"Failed to allocate for outdir\\n\");", "strcpy(control->outdir,optarg);", "if (strcmp(optarg+strlen(optarg) - 1, \"/\"))", "strcat(control->outdir, \"/\");", "break;", "case 'p':", "control->threads = strtol(optarg, &endptr, 10);", "if (control->threads < 1)", "failure(\"Must have at least one thread\\n\");", "if (*endptr)", "failure(\"Extra characters after number of threads: \\'%s\\'\\n\", endptr);", "break;", "case 'P':", "control->flags |= FLAG_SHOW_PROGRESS;", "break;", "case 'q':", "control->flags &= ~FLAG_SHOW_PROGRESS;", "break;", "case 'r':", "recurse = true;", "break;", "case 'S':", "if (control->outname)", "failure(\"Specified output filename already, can't specify an extension.\\n\");", "if (unlikely(STDOUT))", "failure(\"Cannot specify a filename suffix when outputting to stdout\\n\");", "control->suffix = optarg;", "break;", "case 't':", "if (control->outname)", "failure(\"Cannot specify an output file name when just testing.\\n\");", "if (compat)", "control->flags |= FLAG_KEEP_FILES;", "if (!KEEP_FILES)", "failure(\"Doubt that you want to delete a file when just testing.\\n\");", "control->flags |= FLAG_TEST_ONLY;", "break;", "case 'T':", "control->flags &= ~FLAG_THRESHOLD;", "break;", "case 'U':", "control->flags |= FLAG_UNLIMITED;", "break;", "case 'v':", "if (!(control->flags & FLAG_SHOW_PROGRESS))", "control->flags |= FLAG_SHOW_PROGRESS;", "else if (!(control->flags & FLAG_VERBOSITY) && !(control->flags & FLAG_VERBOSITY_MAX))", "control->flags |= FLAG_VERBOSITY;", "else if ((control->flags & FLAG_VERBOSITY)) {", "control->flags &= ~FLAG_VERBOSITY;", "control->flags |= FLAG_VERBOSITY_MAX;", "}", "break;", "case 'V':", "control->msgout = stdout;", "print_output(\"lrzip version %s\\n\", PACKAGE_VERSION);", "exit(0);", "break;", "case 'w':", "control->window = strtol(optarg, &endptr, 10);", "if (control->window < 1)", "failure(\"Window must be positive\\n\");", "if (*endptr)", "failure(\"Extra characters after window size: \\'%s\\'\\n\", endptr);", "break;", "case '1':", "case '2':", "case '3':", "case '4':", "case '5':", "case '6':", "case '7':", "case '8':", "case '9':", "control->compression_level = c - '0';", "break;", "default:", "usage(compat);", "return 2;", "}", "}", "argc -= optind;", "argv += optind;", "if (control->outname) {", "if (argc > 1)", "failure(\"Cannot specify output filename with more than 1 file\\n\");", "if (recurse)", "failure(\"Cannot specify output filename with recursive\\n\");", "}", "if (VERBOSE && !SHOW_PROGRESS) {", "print_err(\"Cannot have -v and -q options. -v wins.\\n\");", "control->flags |= FLAG_SHOW_PROGRESS;", "}", "if (UNLIMITED && control->window) {", "print_err(\"If -U used, cannot specify a window size with -w.\\n\");", "control->window = 0;", "}", "if (argc < 1)", "control->flags |= FLAG_STDIN;", "if (UNLIMITED && STDIN) {", "print_err(\"Cannot have -U and stdin, unlimited mode disabled.\\n\");", "control->flags &= ~FLAG_UNLIMITED;", "}", "setup_overhead(control);", "control->current_priority = getpriority(PRIO_PROCESS, 0);", "if (nice_set) {", "if (!NO_COMPRESS) {", "if (unlikely(setpriority(PRIO_PROCESS, 0, control->nice_val/2) == -1)) {", "print_err(\"Warning, unable to set nice value %d...Resetting to %d\\n\",", "control->nice_val, control->current_priority);", "setpriority(PRIO_PROCESS, 0, (control->nice_val=control->current_priority));", "}", "} else {", "if (unlikely(setpriority(PRIO_PROCESS, 0, control->nice_val) == -1)) {", "print_err(\"Warning, unable to set nice value %d...Resetting to %d\\n\",", "control->nice_val, control->current_priority);", "setpriority(PRIO_PROCESS, 0, (control->nice_val=control->current_priority));", "}", "}", "}", "for (i = 0; i <= argc; i++) {", "char *dirlist = NULL, *infile = NULL;", "int direntries = 0, curentry = 0;", "if (i < argc)", "infile = argv[i];", "else if (!(i == 0 && STDIN))", "break;", "if (infile) {", "if ((strcmp(infile, \"-\") == 0))", "control->flags |= FLAG_STDIN;", "else {", "bool isdir = false;", "struct stat istat;", "if (unlikely(stat(infile, &istat)))", "failure(\"Failed to stat %s\\n\", infile);", "isdir = S_ISDIR(istat.st_mode);", "if (!recurse && (isdir || !S_ISREG(istat.st_mode))) {", "failure(\"lrzip only works directly on regular FILES.\\n\"", "\"Use -r recursive, lrztar or pipe through tar for compressing directories.\\n\");", "}", "if (recurse && !isdir)", "failure(\"%s not a directory, -r recursive needs a directory\\n\", infile);", "}", "}", "if (recurse) {", "if (unlikely(STDIN || STDOUT))", "failure(\"Cannot use -r recursive with STDIO\\n\");", "recurse_dirlist(infile, &dirlist, &direntries);", "}", "if (INFO && STDIN)", "failure(\"Will not get file info from STDIN\\n\");", "recursion:", "if (recurse) {", "if (curentry >= direntries) {", "infile = NULL;", "continue;", "}", "infile = dirlist + MAX_PATH_LEN * curentry++;", "}", "control->infile = infile;", "if ((control->outname && (strcmp(control->outname, \"-\") == 0)) ||", "(!control->outname && STDIN) || lrzcat)", "set_stdout(control);", "if (lrzcat) {", "control->msgout = stderr;", "control->outFILE = stdout;", "register_outputfile(control, control->msgout);", "}", "if (!STDOUT) {", "control->msgout = stdout;", "register_outputfile(control, control->msgout);", "}", "if (STDIN)", "control->inFILE = stdin;", "sigemptyset(&handler.sa_mask);", "handler.sa_flags = 0;", "handler.sa_handler = &sighandler;", "sigaction(SIGTERM, &handler, 0);", "sigaction(SIGINT, &handler, 0);", "if (!FORCE_REPLACE) {", "if (STDIN && isatty(fileno((FILE *)stdin))) {", "print_err(\"Will not read stdin from a terminal. Use -f to override.\\n\");", "usage(compat);", "exit (1);", "}", "if (!TEST_ONLY && STDOUT && isatty(fileno((FILE *)stdout)) && !compat) {", "print_err(\"Will not write stdout to a terminal. Use -f to override.\\n\");", "usage(compat);", "exit (1);", "}", "}", "if (CHECK_FILE) {", "if (!DECOMPRESS) {", "print_err(\"Can only check file written on decompression.\\n\");", "control->flags &= ~FLAG_CHECK;", "} else if (STDOUT) {", "print_err(\"Can't check file written when writing to stdout. Checking disabled.\\n\");", "control->flags &= ~FLAG_CHECK;", "}", "}", "setup_ram(control);", "show_summary();", "gettimeofday(&start_time, NULL);", "if (unlikely((STDIN || STDOUT) && ENCRYPT))", "failure(\"Unable to work from STDIO while reading password\\n\");", "memcpy(&local_control, &base_control, sizeof(rzip_control));", "if (DECOMPRESS || TEST_ONLY)", "decompress_file(&local_control);", "else if (INFO)", "get_fileinfo(&local_control);", "else", "compress_file(&local_control);", "gettimeofday(&end_time, NULL);", "total_time = (end_time.tv_sec + (double)end_time.tv_usec / 1000000) -", "(start_time.tv_sec + (double)start_time.tv_usec / 1000000);", "hours = (int)total_time / 3600;", "minutes = (int)(total_time / 60) % 60;", "seconds = total_time - hours * 3600 - minutes * 60;", "if (!INFO)", "print_progress(\"Total time: %02d:%02d:%05.2f\\n\", hours, minutes, seconds);", "if (recurse)", "goto recursion;", "}", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["GF_Err tenc_box_read(GF_Box *s, GF_BitStream *bs)", "{", "u8 iv_size;", "GF_TrackEncryptionBox *ptr = (GF_TrackEncryptionBox*)s;", "ISOM_DECREASE_SIZE(ptr, 3);", "gf_bs_read_u8(bs);", "if (!ptr->version) {", "gf_bs_read_u8(bs);", "} else {", "ptr->crypt_byte_block = gf_bs_read_int(bs, 4);", "ptr->skip_byte_block = gf_bs_read_int(bs, 4);", "}", "ptr->isProtected = gf_bs_read_u8(bs);", "ISOM_DECREASE_SIZE(ptr, 17);", "ptr->key_info[0] = 0;", "ptr->key_info[1] = 0;", "ptr->key_info[2] = 0;", "ptr->key_info[3] = iv_size = gf_bs_read_u8(bs);", "gf_bs_read_data(bs, ptr->key_info+4, 16);", "if (!iv_size && ptr->isProtected) {", "ISOM_DECREASE_SIZE(ptr, 1);", "iv_size = ptr->key_info[20] = gf_bs_read_u8(bs);", "ISOM_DECREASE_SIZE(ptr, ptr->key_info[20]);", "gf_bs_read_data(bs, ptr->key_info+21, iv_size);", "}", "return GF_OK;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0]}
{"tokens": ["GF_Err BD_DecMFFieldVec(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field, Bool is_mem_com)", "{", "GF_Err e;", "u32 NbBits, nbFields;", "u32 i;", "GF_ChildNodeItem *last;", "u8 qp_local, qp_on, initial_qp;", "GF_FieldInfo sffield;", "memset(&sffield, 0, sizeof(GF_FieldInfo));", "sffield.fieldIndex = field->fieldIndex;", "sffield.fieldType = gf_sg_vrml_get_sf_type(field->fieldType);", "sffield.NDTtype = field->NDTtype;", "sffield.name = field->name;", "initial_qp = qp_local = qp_on = 0;", "NbBits = gf_bs_read_int(bs, 5);", "nbFields = gf_bs_read_int(bs, NbBits);", "if (codec->ActiveQP) {", "initial_qp = 1;", "gf_bifs_dec_qp14_set_length(codec, nbFields);", "}", "if (field->fieldType != GF_SG_VRML_MFNODE) {", "e = gf_sg_vrml_mf_alloc(field->far_ptr, field->fieldType, nbFields);", "if (e) return e;", "for (i=0; i<nbFields; i++) {", "e = gf_sg_vrml_mf_get_item(field->far_ptr, field->fieldType, & sffield.far_ptr, i);", "if (e) return e;", "e = gf_bifs_dec_sf_field(codec, bs, node, &sffield, GF_FALSE);", "if (e) return e;", "}", "} else {", "last = NULL;", "for (i=0; i<nbFields; i++) {", "GF_Node *new_node = gf_bifs_dec_node(codec, bs, field->NDTtype);", "if (new_node) {", "e = gf_node_register(new_node, is_mem_com ? NULL : node);", "if (e) return e;", "if (node) {", "if (gf_node_get_tag(new_node) == TAG_MPEG4_QuantizationParameter) {", "qp_local = ((M_QuantizationParameter *)new_node)->isLocal;", "if (qp_on) gf_bifs_dec_qp_remove(codec, GF_FALSE);", "e = gf_bifs_dec_qp_set(codec, new_node);", "if (e) return e;", "qp_on = 1;", "if (qp_local) qp_local = 2;", "if (codec->force_keep_qp) {", "e = gf_node_list_add_child_last(field->far_ptr, new_node, &last);", "if (e) return e;", "} else {", "gf_node_register(new_node, NULL);", "gf_node_unregister(new_node, node);", "}", "} else {", "e = gf_node_list_add_child_last(field->far_ptr, new_node, &last);", "if (e) return e;", "}", "}", "else if (codec->pCurrentProto) {", "e = gf_node_list_add_child_last( (GF_ChildNodeItem **)field->far_ptr, new_node, &last);", "if (e) return e;", "}", "} else {", "return codec->LastError ? codec->LastError : GF_NON_COMPLIANT_BITSTREAM;", "}", "}", "if (qp_on && qp_local) {", "if (qp_local == 2) {", "} else {", "gf_bifs_dec_qp_remove(codec, initial_qp);", "}", "}", "}", "if (qp_on) gf_bifs_dec_qp_remove(codec, GF_TRUE);", "return GF_OK;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0]}
{"tokens": ["GF_Err xtra_box_read(GF_Box *s, GF_BitStream *bs)", "{", "GF_XtraBox *ptr = (GF_XtraBox *)s;", "while (ptr->size) {", "GF_XtraTag *tag;", "u32 prop_type = 0;", "char *data=NULL, *data2=NULL;", "ISOM_DECREASE_SIZE_NO_ERR(ptr, 8)", "s32 tag_size = gf_bs_read_u32(bs);", "u32 name_size = gf_bs_read_u32(bs);", "if (tag_size < 8) return GF_ISOM_INVALID_FILE;", "tag_size -= 8;", "if ((tag_size>ptr->size) || (name_size>ptr->size)) {", "return GF_ISOM_INVALID_FILE;", "}", "ISOM_DECREASE_SIZE_NO_ERR(ptr, 10)", "ISOM_DECREASE_SIZE_NO_ERR(ptr, name_size)", "data = gf_malloc(sizeof(char) * (name_size+1));", "gf_bs_read_data(bs, data, name_size);", "data[name_size] = 0;", "tag_size-=name_size;", "u32 flags = gf_bs_read_u32(bs);", "u32 prop_size = gf_bs_read_u32(bs);", "tag_size-=8;", "if (prop_size>4) {", "tag_size-=2;", "prop_type = gf_bs_read_u16(bs);", "prop_size -= 6;", "ISOM_DECREASE_SIZE_NO_ERR(ptr, prop_size)", "data2 = gf_malloc(sizeof(char) * (prop_size+2));", "gf_bs_read_data(bs, data2, prop_size);", "data2[prop_size] = 0;", "data2[prop_size+1] = 0;", "tag_size-=prop_size;", "} else {", "prop_size = 0;", "}", "GF_SAFEALLOC(tag, GF_XtraTag)", "tag->flags = flags;", "tag->name = data;", "tag->prop_size = prop_size;", "tag->prop_value = data2;", "tag->prop_type = prop_type;", "gf_list_add(ptr->tags, tag);", "if (tag_size) {", "GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isom] invalid tag size in Xtra !\\n\"));", "}", "}", "return GF_OK;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["GF_Err SetupWriters(MovieWriter *mw, GF_List *writers, u8 interleaving)", "{", "u32 i, trackCount;", "TrackWriter *writer;", "GF_TrackBox *trak;", "GF_ISOFile *movie = mw->movie;", "mw->total_samples = mw->nb_done = 0;", "if (!movie->moov) return GF_OK;", "trackCount = gf_list_count(movie->moov->trackList);", "for (i = 0; i < trackCount; i++) {", "trak = gf_isom_get_track(movie->moov, i+1);", "GF_SAFEALLOC(writer, TrackWriter);", "if (!writer) goto exit;", "writer->sampleNumber = 1;", "writer->mdia = trak->Media;", "writer->stbl = trak->Media->information->sampleTable;", "writer->timeScale = trak->Media->mediaHeader->timeScale;", "writer->all_dref_mode = Media_SelfContainedType(writer->mdia);", "if (trak->sample_encryption)", "writer->prevent_dispatch = GF_TRUE;", "writer->isDone = 0;", "writer->DTSprev = 0;", "writer->chunkDur = 0;", "writer->chunkSize = 0;", "writer->constant_size = writer->constant_dur = 0;", "if (writer->stbl->SampleSize->sampleSize)", "writer->constant_size = writer->stbl->SampleSize->sampleSize;", "if (writer->stbl->TimeToSample->nb_entries==1) {", "writer->constant_dur = writer->stbl->TimeToSample->entries[0].sampleDelta;", "if (writer->constant_dur>1) writer->constant_dur = 0;", "}", "if (!writer->constant_dur || !writer->constant_size || (writer->constant_size>=10))", "writer->constant_size = writer->constant_dur = 0;", "writer->stsc = (GF_SampleToChunkBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_STSC);", "if (!writer->stsc) return GF_OUT_OF_MEM;", "if (writer->stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {", "writer->stco = gf_isom_box_new(GF_ISOM_BOX_TYPE_STCO);", "} else {", "writer->stco = gf_isom_box_new(GF_ISOM_BOX_TYPE_CO64);", "}", "if (!writer->stco) return GF_OUT_OF_MEM;", "if (interleaving) writer->stbl->MaxSamplePerChunk = 0;", "if (Media_IsSelfContained(writer->mdia, 1))", "mw->total_samples += writer->stbl->SampleSize->sampleCount;", "if (movie->storageMode != GF_ISOM_STORE_INTERLEAVED) {", "gf_list_add(writers, writer);", "} else {", "if (writer->mdia->information->InfoHeader && writer->mdia->information->InfoHeader->type == GF_ISOM_BOX_TYPE_SMHD) {", "gf_list_add(writers, writer);", "} else {", "gf_list_insert(writers, writer, 0);", "}", "}", "if (movie->sample_groups_in_traf && trak->Media->information->sampleTable) {", "gf_isom_box_array_del_parent(&trak->Media->information->sampleTable->child_boxes, trak->Media->information->sampleTable->sampleGroupsDescription);", "trak->Media->information->sampleTable->sampleGroupsDescription = NULL;", "}", "}", "return GF_OK;", "exit:", "CleanWriters(writers);", "return GF_OUT_OF_MEM;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int zipfileUpdate(", "sqlite3_vtab *pVtab,", "int nVal,", "sqlite3_value **apVal,", "sqlite_int64 *pRowid", "){", "ZipfileTab *pTab = (ZipfileTab*)pVtab;", "int rc = SQLITE_OK;", "ZipfileEntry *pNew = 0;", "u32 mode = 0;", "u32 mTime = 0;", "i64 sz = 0;", "const char *zPath = 0;", "int nPath = 0;", "const u8 *pData = 0;", "int nData = 0;", "int iMethod = 0;", "u8 *pFree = 0;", "char *zFree = 0;", "ZipfileEntry *pOld = 0;", "ZipfileEntry *pOld2 = 0;", "int bUpdate = 0;", "int bIsDir = 0;", "u32 iCrc32 = 0;", "if( pTab->pWriteFd==0 ){", "rc = zipfileBegin(pVtab);", "if( rc!=SQLITE_OK ) return rc;", "}", "if( sqlite3_value_type(apVal[0])!=SQLITE_NULL ){", "const char *zDelete = (const char*)sqlite3_value_text(apVal[0]);", "int nDelete = (int)strlen(zDelete);", "if( nVal>1 ){", "const char *zUpdate = (const char*)sqlite3_value_text(apVal[1]);", "if( zUpdate && zipfileComparePath(zUpdate, zDelete, nDelete)!=0 ){", "bUpdate = 1;", "}", "}", "for(pOld=pTab->pFirstEntry; 1; pOld=pOld->pNext){", "if( zipfileComparePath(pOld->cds.zFile, zDelete, nDelete)==0 ){", "break;", "}", "assert( pOld->pNext );", "}", "}", "if( nVal>1 ){", "if( sqlite3_value_type(apVal[5])!=SQLITE_NULL ){", "zipfileTableErr(pTab, \"sz must be NULL\");", "rc = SQLITE_CONSTRAINT;", "}", "if( sqlite3_value_type(apVal[6])!=SQLITE_NULL ){", "zipfileTableErr(pTab, \"rawdata must be NULL\");", "rc = SQLITE_CONSTRAINT;", "}", "if( rc==SQLITE_OK ){", "if( sqlite3_value_type(apVal[7])==SQLITE_NULL ){", "bIsDir = 1;", "}else{", "const u8 *aIn = sqlite3_value_blob(apVal[7]);", "int nIn = sqlite3_value_bytes(apVal[7]);", "int bAuto = sqlite3_value_type(apVal[8])==SQLITE_NULL;", "iMethod = sqlite3_value_int(apVal[8]);", "sz = nIn;", "pData = aIn;", "nData = nIn;", "if( iMethod!=0 && iMethod!=8 ){", "zipfileTableErr(pTab, \"unknown compression method: %d\", iMethod);", "rc = SQLITE_CONSTRAINT;", "}else{", "if( bAuto || iMethod ){", "int nCmp;", "rc = zipfileDeflate(aIn, nIn, &pFree, &nCmp, &pTab->base.zErrMsg);", "if( rc==SQLITE_OK ){", "if( iMethod || nCmp<nIn ){", "iMethod = 8;", "pData = pFree;", "nData = nCmp;", "}", "}", "}", "iCrc32 = crc32(0, aIn, nIn);", "}", "}", "}", "if( rc==SQLITE_OK ){", "rc = zipfileGetMode(apVal[3], bIsDir, &mode, &pTab->base.zErrMsg);", "}", "if( rc==SQLITE_OK ){", "zPath = (const char*)sqlite3_value_text(apVal[2]);", "if( zPath==0 ) zPath = \"\";", "nPath = (int)strlen(zPath);", "mTime = zipfileGetTime(apVal[4]);", "}", "if( rc==SQLITE_OK && bIsDir ){", "if( zPath[nPath-1]!='/' ){", "zFree = sqlite3_mprintf(\"%s/\", zPath);", "if( zFree==0 ){ rc = SQLITE_NOMEM; }", "zPath = (const char*)zFree;", "nPath++;", "}", "}", "if( (pOld==0 || bUpdate) && rc==SQLITE_OK ){", "ZipfileEntry *p;", "for(p=pTab->pFirstEntry; p; p=p->pNext){", "if( zipfileComparePath(p->cds.zFile, zPath, nPath)==0 ){", "switch( sqlite3_vtab_on_conflict(pTab->db) ){", "case SQLITE_IGNORE: {", "goto zipfile_update_done;", "}", "case SQLITE_REPLACE: {", "pOld2 = p;", "break;", "}", "default: {", "zipfileTableErr(pTab, \"duplicate name: \\\"%s\\\"\", zPath);", "rc = SQLITE_CONSTRAINT;", "break;", "}", "}", "break;", "}", "}", "}", "if( rc==SQLITE_OK ){", "pNew = zipfileNewEntry(zPath);", "if( pNew==0 ){", "rc = SQLITE_NOMEM;", "}else{", "pNew->cds.iVersionMadeBy = ZIPFILE_NEWENTRY_MADEBY;", "pNew->cds.iVersionExtract = ZIPFILE_NEWENTRY_REQUIRED;", "pNew->cds.flags = ZIPFILE_NEWENTRY_FLAGS;", "pNew->cds.iCompression = (u16)iMethod;", "zipfileMtimeToDos(&pNew->cds, mTime);", "pNew->cds.crc32 = iCrc32;", "pNew->cds.szCompressed = nData;", "pNew->cds.szUncompressed = (u32)sz;", "pNew->cds.iExternalAttr = (mode<<16);", "pNew->cds.iOffset = (u32)pTab->szCurrent;", "pNew->cds.nFile = (u16)nPath;", "pNew->mUnixTime = (u32)mTime;", "rc = zipfileAppendEntry(pTab, pNew, pData, nData);", "zipfileAddEntry(pTab, pOld, pNew);", "}", "}", "}", "if( rc==SQLITE_OK && (pOld || pOld2) ){", "ZipfileCsr *pCsr;", "for(pCsr=pTab->pCsrList; pCsr; pCsr=pCsr->pCsrNext){", "if( pCsr->pCurrent && (pCsr->pCurrent==pOld || pCsr->pCurrent==pOld2) ){", "pCsr->pCurrent = pCsr->pCurrent->pNext;", "pCsr->bNoop = 1;", "}", "}", "zipfileRemoveEntryFromList(pTab, pOld);", "zipfileRemoveEntryFromList(pTab, pOld2);", "}", "zipfile_update_done:", "sqlite3_free(pFree);", "sqlite3_free(zFree);", "return rc;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["uint32_t GetPayloadTime(size_t handle, uint32_t index, float *in, float *out)", "{", "mp4object *mp4 = (mp4object *)handle;", "if (mp4 == NULL) return 0;", "if (mp4->metaoffsets == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in == NULL || out == NULL) return 1;", "*in = (float)((double)index * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);", "*out = (float)((double)(index + 1) * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);", "return 0;", "}"], "ner_tags": [0, 0, 0, 1, 1, 1, 1, 1, 0]}
{"tokens": ["bool PackLinuxElf32::calls_crt1(Elf32_Rel const *rel, int sz)", "{", "if (!dynsym || !dynstr) {", "return false;", "}", "for (unsigned relnum= 0; 0 < sz; (sz -= sizeof(Elf32_Rel)), ++rel, ++relnum) {", "unsigned const symnum = get_te32(&rel->r_info) >> 8;", "char const *const symnam = get_dynsym_name(symnum, relnum);", "if (0==strcmp(symnam, \"__libc_start_main\")", "||  0==strcmp(symnam, \"__libc_init\")", "||  0==strcmp(symnam, \"__uClibc_main\")", "||  0==strcmp(symnam, \"__uClibc_start_main\"))", "return true;", "}", "return false;", "}"], "ner_tags": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["PackLinuxElf32::invert_pt_dynamic(Elf32_Dyn const *dynp)", "{", "if (dt_table[Elf32_Dyn::DT_NULL]) {", "return;", "}", "Elf32_Dyn const *const dynp0 = dynp;", "unsigned ndx = 1+ 0;", "if (dynp)", "for (; ; ++ndx, ++dynp) {", "unsigned const d_tag = get_te32(&dynp->d_tag);", "if (d_tag < DT_NUM) {", "dt_table[d_tag] = ndx;", "}", "if (Elf32_Dyn::DT_NULL == d_tag) {", "break;", "}", "}", "upx_dt_init = 0;", "if (dt_table[Elf32_Dyn::DT_INIT])          upx_dt_init = Elf32_Dyn::DT_INIT;", "else if (dt_table[Elf32_Dyn::DT_PREINIT_ARRAY]) upx_dt_init = Elf32_Dyn::DT_PREINIT_ARRAY;", "else if (dt_table[Elf32_Dyn::DT_INIT_ARRAY])    upx_dt_init = Elf32_Dyn::DT_INIT_ARRAY;", "unsigned const z_str = dt_table[Elf32_Dyn::DT_STRSZ];", "if (z_str) {", "strtab_end = get_te32(&dynp0[-1+ z_str].d_val);", "if ((u32_t)file_size <= strtab_end) {", "char msg[50]; snprintf(msg, sizeof(msg),", "\"bad DT_STRSZ %#x\", strtab_end);", "throwCantPack(msg);", "}", "}", "unsigned const x_sym = dt_table[Elf32_Dyn::DT_SYMTAB];", "unsigned const x_str = dt_table[Elf32_Dyn::DT_STRTAB];", "if (x_sym && x_str) {", "upx_uint32_t const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);", "upx_uint32_t const v_str = get_te32(&dynp0[-1+ x_str].d_val);", "unsigned const  z_sym = dt_table[Elf32_Dyn::DT_SYMENT];", "unsigned const sz_sym = !z_sym ? sizeof(Elf32_Sym)", ": get_te32(&dynp0[-1+ z_sym].d_val);", "if (v_sym < v_str) {", "symnum_end = (v_str - v_sym) / sz_sym;", "}", "}", "unsigned const v_hsh = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH);", "if (v_hsh && file_image) {", "hashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_HASH);", "unsigned const nbucket = get_te32(&hashtab[0]);", "unsigned const *const buckets = &hashtab[2];", "unsigned const *const chains = &buckets[nbucket]; (void)chains;", "unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);", "if (!nbucket", "|| (nbucket>>31) || (file_size/sizeof(unsigned)) <= (2*nbucket)", "|| ((v_hsh < v_sym) && (v_sym - v_hsh) < (sizeof(unsigned)*2", "+ sizeof(*buckets)*nbucket", "+ sizeof(*chains) *nbucket", "))", ") {", "char msg[90]; snprintf(msg, sizeof(msg),", "\"bad DT_HASH nbucket=%#x  len=%#x\",", "nbucket, (v_sym - v_hsh));", "throwCantPack(msg);", "}", "}", "unsigned const v_gsh = elf_unsigned_dynamic(Elf32_Dyn::DT_GNU_HASH);", "if (v_gsh && file_image) {", "gashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_GNU_HASH);", "unsigned const n_bucket = get_te32(&gashtab[0]);", "unsigned const n_bitmask = get_te32(&gashtab[2]);", "unsigned const gnu_shift = get_te32(&gashtab[3]);", "unsigned const *const bitmask = (unsigned const *)(void const *)&gashtab[4];", "unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask];", "unsigned     const *const hasharr = &buckets[n_bucket]; (void)hasharr;", "unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);", "if (!n_bucket || !n_bitmask", "|| (-1+ n_bitmask) & n_bitmask", "|| 8*sizeof(unsigned) <= gnu_shift", "|| (n_bucket>>30)", "|| (n_bitmask>>30)", "|| (file_size / sizeof(unsigned)) <= (n_bitmask + 2*n_bucket)", "|| ((v_gsh < v_sym) && (v_sym - v_gsh) < (sizeof(unsigned)*4", "+ sizeof(*bitmask)*n_bitmask", "+ sizeof(*buckets)*n_bucket", "+ sizeof(*hasharr)*n_bucket", "))", ") {", "char msg[90]; snprintf(msg, sizeof(msg),", "\"bad DT_GNU_HASH n_bucket=%#x  n_bitmask=%#x  len=%#x\",", "n_bucket, n_bitmask, v_sym - v_gsh);", "throwCantPack(msg);", "}", "}", "unsigned const e_shstrndx = get_te16(&ehdri.e_shstrndx);", "if (e_shnum <= e_shstrndx", "&&  !(0==e_shnum && 0==e_shstrndx) ) {", "char msg[40]; snprintf(msg, sizeof(msg),", "\"bad .e_shstrndx %d >= .e_shnum %d\", e_shstrndx, e_shnum);", "throwCantPack(msg);", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["bit_catenate(VarBit *arg1, VarBit *arg2)", "{", "VarBit    *result;", "int   bitlen1,", "bitlen2,", "bytelen,", "bit1pad,", "bit2shift;", "bits8    *pr,", "*pa;", "bitlen1 = VARBITLEN(arg1);", "bitlen2 = VARBITLEN(arg2);", "bytelen = VARBITTOTALLEN(bitlen1 + bitlen2);", "result = (VarBit *) palloc(bytelen);", "SET_VARSIZE(result, bytelen);", "VARBITLEN(result) = bitlen1 + bitlen2;", "memcpy(VARBITS(result), VARBITS(arg1), VARBITBYTES(arg1));", "bit1pad = VARBITPAD(arg1);", "if (bit1pad == 0)", "{", "memcpy(VARBITS(result) + VARBITBYTES(arg1), VARBITS(arg2),", "VARBITBYTES(arg2));", "}", "else if (bitlen2 > 0)", "{", "bit2shift = BITS_PER_BYTE - bit1pad;", "pr = VARBITS(result) + VARBITBYTES(arg1) - 1;", "for (pa = VARBITS(arg2); pa < VARBITEND(arg2); pa++)", "{", "*pr |= ((*pa >> bit2shift) & BITMASK);", "pr++;", "if (pr < VARBITEND(result))", "*pr = (*pa << bit1pad) & BITMASK;", "}", "}", "return result;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int open_cred_file(char *file_name,", "struct parsed_mount_info *parsed_info)", "{", "char *line_buf = NULL;", "char *temp_val = NULL;", "FILE *fs = NULL;", "int i;", "const int line_buf_size = 4096;", "const int min_non_white = 10;", "i = toggle_dac_capability(0, 1);", "if (i)", "goto return_i;", "i = access(file_name, R_OK);", "if (i) {", "toggle_dac_capability(0, 0);", "i = errno;", "goto return_i;", "}", "fs = fopen(file_name, \"r\");", "if (fs == NULL) {", "toggle_dac_capability(0, 0);", "i = errno;", "goto return_i;", "}", "i = toggle_dac_capability(0, 0);", "if (i)", "goto return_i;", "line_buf = (char *)malloc(line_buf_size);", "if (line_buf == NULL) {", "i = EX_SYSERR;", "goto return_i;", "}", "while (fgets(line_buf, line_buf_size, fs)) {", "for (i = 0; i < line_buf_size - min_non_white + 1; i++) {", "if ((line_buf[i] != ' ') && (line_buf[i] != '\\t'))", "break;", "}", "null_terminate_endl(line_buf);", "switch (parse_cred_line(line_buf + i, &temp_val)) {", "case CRED_USER:", "strlcpy(parsed_info->username, temp_val,", "sizeof(parsed_info->username));", "parsed_info->got_user = 1;", "break;", "case CRED_PASS:", "i = set_password(parsed_info, temp_val);", "if (i)", "goto return_i;", "break;", "case CRED_DOM:", "if (parsed_info->verboseflag)", "fprintf(stderr, \"domain=%s\\n\",", "temp_val);", "strlcpy(parsed_info->domain, temp_val,", "sizeof(parsed_info->domain));", "break;", "case CRED_UNPARSEABLE:", "if (parsed_info->verboseflag)", "fprintf(stderr, \"Credential formatted \"", "\"incorrectly: %s\\n\",", "temp_val ? temp_val : \"(null)\");", "break;", "}", "}", "i = 0;", "return_i:", "if (fs != NULL)", "fclose(fs);", "if (line_buf != NULL)", "memset(line_buf, 0, line_buf_size);", "free(line_buf);", "return i;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void gf_isom_cenc_get_default_info_internal(GF_TrackBox *trak, u32 sampleDescriptionIndex, u32 *container_type, Bool *default_IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size)", "{", "GF_ProtectionSchemeInfoBox *sinf;", "if (default_IsEncrypted) *default_IsEncrypted = GF_FALSE;", "if (crypt_byte_block) *crypt_byte_block = 0;", "if (skip_byte_block) *skip_byte_block = 0;", "if (container_type) *container_type = 0;", "if (key_info) *key_info = NULL;", "if (key_info_size) *key_info_size = 0;", "sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CENC_SCHEME, NULL);", "if (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CBC_SCHEME, NULL);", "if (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CENS_SCHEME, NULL);", "if (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CBCS_SCHEME, NULL);", "if (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_PIFF_SCHEME, NULL);", "if (!sinf) {", "u32 i, nb_stsd = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);", "for (i=0; i<nb_stsd; i++) {", "GF_ProtectionSchemeInfoBox *a_sinf;", "GF_SampleEntryBox *sentry=NULL;", "if (i+1==sampleDescriptionIndex) continue;", "sentry = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, i);", "a_sinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(sentry->child_boxes, GF_ISOM_BOX_TYPE_SINF);", "if (!a_sinf) continue;", "return;", "}", "}", "if (sinf && sinf->info && sinf->info->tenc) {", "if (default_IsEncrypted) *default_IsEncrypted = sinf->info->tenc->isProtected;", "if (crypt_byte_block) *crypt_byte_block = sinf->info->tenc->crypt_byte_block;", "if (skip_byte_block) *skip_byte_block = sinf->info->tenc->skip_byte_block;", "if (key_info) *key_info = sinf->info->tenc->key_info;", "if (key_info_size) {", "*key_info_size = 20;", "if (!sinf->info->tenc->key_info[3])", "*key_info_size += 1 + sinf->info->tenc->key_info[20];", "}", "if (container_type) *container_type = GF_ISOM_BOX_TYPE_SENC;", "} else if (sinf && sinf->info && sinf->info->piff_tenc) {", "if (default_IsEncrypted) *default_IsEncrypted = GF_TRUE;", "if (key_info) *key_info = sinf->info->piff_tenc->key_info;", "if (key_info_size) *key_info_size = 19;", "if (container_type) *container_type = GF_ISOM_BOX_UUID_PSEC;", "} else {", "u32 i, count = 0;", "GF_CENCSampleEncryptionGroupEntry *seig_entry = NULL;", "if (!trak->moov->mov->is_smooth)", "count = gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription);", "for (i=0; i<count; i++) {", "GF_SampleGroupDescriptionBox *sgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, i);", "if (sgdesc->grouping_type!=GF_ISOM_SAMPLE_GROUP_SEIG) continue;", "if (sgdesc->default_description_index)", "seig_entry = gf_list_get(sgdesc->group_descriptions, sgdesc->default_description_index-1);", "else", "seig_entry = gf_list_get(sgdesc->group_descriptions, 0);", "if (!seig_entry->key_info[0])", "seig_entry = NULL;", "break;", "}", "if (seig_entry) {", "if (default_IsEncrypted) *default_IsEncrypted = seig_entry->IsProtected;", "if (crypt_byte_block) *crypt_byte_block = seig_entry->crypt_byte_block;", "if (skip_byte_block) *skip_byte_block = seig_entry->skip_byte_block;", "if (key_info) *key_info = seig_entry->key_info;", "if (key_info_size) *key_info_size = seig_entry->key_info_size;", "if (container_type) *container_type = GF_ISOM_BOX_TYPE_SENC;", "} else {", "if (! trak->moov->mov->is_smooth ) {", "trak->moov->mov->is_smooth = GF_TRUE;", "GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] senc box without tenc, assuming MS smooth+piff\\n\"));", "}", "if (default_IsEncrypted) *default_IsEncrypted = GF_TRUE;", "if (container_type) *container_type = GF_ISOM_BOX_UUID_PSEC;", "}", "}", "if (container_type && trak->sample_encryption) {", "if (trak->sample_encryption->type == GF_ISOM_BOX_TYPE_SENC) *container_type = GF_ISOM_BOX_TYPE_SENC;", "else if (trak->sample_encryption->type == GF_ISOM_BOX_TYPE_UUID) *container_type = ((GF_UUIDBox*)trak->sample_encryption)->internal_4cc;", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static s32 gf_media_vvc_read_sps_bs_internal(GF_BitStream *bs, VVCState *vvc, u8 layer_id, u32 *vui_flag_pos)", "{", "s32 vps_id, sps_id;", "u32 i, CtbSizeY;", "VVC_SPS *sps;", "u8 sps_ptl_dpb_hrd_params_present_flag;", "if (vui_flag_pos) *vui_flag_pos = 0;", "sps_id = gf_bs_read_int_log(bs, 4, \"sps_id\");", "if (sps_id >= 16) {", "return -1;", "}", "vps_id = gf_bs_read_int_log(bs, 4, \"vps_id\");", "if (vps_id >= 16) {", "return -1;", "}", "if (!vps_id && !vvc->vps[0].state) {", "vvc->vps[0].state = 1;", "vvc->vps[0].num_ptl = 1;", "vvc->vps[0].max_layers = 1;", "vvc->vps[0].all_layers_independent = 1;", "}", "sps = &vvc->sps[sps_id];", "if (!sps->state) {", "sps->state = 1;", "sps->id = sps_id;", "sps->vps_id = vps_id;", "}", "sps->max_sublayers = 1 + gf_bs_read_int_log(bs, 3, \"max_sublayers_minus1\");", "sps->chroma_format_idc = gf_bs_read_int_log(bs, 2, \"chroma_format_idc\");", "sps->log2_ctu_size = 5 + gf_bs_read_int_log(bs, 2, \"log2_ctu_size_minus5\");", "CtbSizeY = 1<<sps->log2_ctu_size;", "sps_ptl_dpb_hrd_params_present_flag = gf_bs_read_int_log(bs, 1, \"sps_ptl_dpb_hrd_params_present_flag\");", "if (sps_ptl_dpb_hrd_params_present_flag) {", "VVC_ProfileTierLevel ptl, *p_ptl;", "if (sps->vps_id) {", "p_ptl = &ptl;", "} else {", "p_ptl = &vvc->vps[0].ptl[0];", "}", "memset(p_ptl, 0, sizeof(VVC_ProfileTierLevel));", "p_ptl->pt_present = 1;", "p_ptl->ptl_max_tid = sps->max_sublayers;", "vvc_profile_tier_level(bs, p_ptl, 0);", "}", "sps->gdr_enabled = gf_bs_read_int_log(bs, 1, \"gdr_enabled\");", "sps->ref_pic_resampling = gf_bs_read_int_log(bs, 1, \"ref_pic_resampling\");", "if (sps->ref_pic_resampling)", "sps->res_change_in_clvs = gf_bs_read_int_log(bs, 1, \"res_change_in_clvs\");", "sps->width = gf_bs_read_ue_log(bs, \"width\");", "sps->height = gf_bs_read_ue_log(bs, \"height\");", "sps->conf_window = gf_bs_read_int_log(bs, 1, \"conformance_window_present_flag\");", "if (sps->conf_window) {", "sps->cw_left = gf_bs_read_ue_log(bs, \"conformance_window_left\");", "sps->cw_right = gf_bs_read_ue_log(bs, \"conformance_window_right\");", "sps->cw_top = gf_bs_read_ue_log(bs, \"conformance_window_top\");", "sps->cw_bottom = gf_bs_read_ue_log(bs, \"conformance_window_bottom\");", "}", "sps->subpic_info_present = gf_bs_read_int_log(bs, 1, \"subpic_info_present\");", "if (sps->subpic_info_present) {", "sps->nb_subpics = 1 + gf_bs_read_ue_log(bs, \"nb_subpics_minus1\");", "if (sps->nb_subpics>1) {", "u32 tmpWidthVal, tmpHeightVal;", "sps->independent_subpic_flags = gf_bs_read_int_log(bs, 1, \"independent_subpic_flags\");", "sps->subpic_same_size = gf_bs_read_int_log(bs, 1, \"subpic_same_size\");", "tmpWidthVal = (sps->width + CtbSizeY-1) / CtbSizeY;", "tmpWidthVal = gf_get_bit_size(tmpWidthVal);", "tmpHeightVal = (sps->height + CtbSizeY-1) / CtbSizeY;", "tmpHeightVal = gf_get_bit_size(tmpHeightVal);", "for (i=0; i<sps->nb_subpics; i++) {", "if( !sps->subpic_same_size || !i) {", "if (i && (sps->width > CtbSizeY))", "gf_bs_read_int_log(bs, tmpWidthVal, \"subpic_ctu_top_left_x\");", "if (i && (sps->height > CtbSizeY))", "gf_bs_read_int_log(bs, tmpHeightVal, \"subpic_ctu_top_left_y\");", "if ((i+1 < sps->nb_subpics) && (sps->width > CtbSizeY))", "gf_bs_read_int_log(bs, tmpWidthVal, \"subpic_width_minus1\");", "if ((i+1 < sps->nb_subpics) && (sps->height > CtbSizeY))", "gf_bs_read_int_log(bs, tmpHeightVal, \"subpic_height_minus1\");", "}", "if (!sps->independent_subpic_flags) {", "gf_bs_read_int_log(bs, 1, \"subpic_treated_as_pic_flag\");", "gf_bs_read_int_log(bs, 1, \"loop_filter_across_subpic_enabled_flag\");", "}", "}", "sps->subpicid_len = gf_bs_read_ue_log(bs, \"subpic_id_len_minus1\") + 1;", "sps->subpicid_mapping_explicit = gf_bs_read_int_log(bs, 1, \"subpic_id_mapping_explicitly_signalled_flag\");", "if (sps->subpicid_mapping_explicit) {", "sps->subpicid_mapping_present = gf_bs_read_int_log(bs, 1, \"subpic_id_mapping_present_flag\");", "if (sps->subpicid_mapping_present) {", "for (i=0; i<sps->nb_subpics; i++) {", "gf_bs_read_ue_log(bs, \"subpic_id\");", "}", "}", "}", "}", "}", "sps->bitdepth = gf_bs_read_ue_log(bs, \"bitdepth_minus8\") + 8;", "gf_bs_read_int_log(bs, 1, \"entropy_coding_sync_enabled_flag\");", "gf_bs_read_int_log(bs, 1, \"entry_point_offsets_present_flag\");", "sps->log2_max_poc_lsb = 4 + gf_bs_read_int_log(bs, 4, \"log2_max_poc_lsb_minus4\");", "if ((sps->poc_msb_cycle_flag = gf_bs_read_int_log(bs, 1, \"poc_msb_cycle_flag\")))", "sps->poc_msb_cycle_len = 1 + gf_bs_read_ue_log(bs, \"poc_msb_cycle_len_minus1\");", "u8 sps_num_extra_ph_bits = 8 * gf_bs_read_int_log(bs, 2, \"sps_num_extra_ph_bytes\");", "for (i=0; i<sps_num_extra_ph_bits; i++) {", "if (gf_bs_read_int_log_idx(bs, 1, \"extra_ph_bit_present_flag\", 1))", "sps->ph_num_extra_bits++;", "}", "u8 sps_num_extra_sh_bits = 8 * gf_bs_read_int_log(bs, 2, \"num_extra_sh_bytes\");", "for (i=0; i<sps_num_extra_sh_bits; i++) {", "if (gf_bs_read_int_log_idx(bs, 1, \"extra_sh_bit_present_flag\", i))", "sps->sh_num_extra_bits++;", "}", "if (sps_ptl_dpb_hrd_params_present_flag) {", "u8 sps_sublayer_dpb_params_flag = 0;", "if (sps->max_sublayers>1) {", "sps_sublayer_dpb_params_flag = gf_bs_read_int_log(bs, 1, \"sps_sublayer_dpb_params_flag\");", "}", "for (i=(sps_sublayer_dpb_params_flag ? 0 : sps->max_sublayers-1); i < sps->max_sublayers; i++ ) {", "gf_bs_read_ue_log_idx(bs, \"dpb_max_dec_pic_buffering_minus1\", i);", "gf_bs_read_ue_log_idx(bs, \"dpb_max_num_reorder_pics\", i);", "gf_bs_read_ue_log_idx(bs, \"dpb_max_latency_increase_plus1\", i);", "}", "}", "gf_bs_read_ue_log(bs, \"sps_log2_min_luma_coding_block_size_minus2\");", "gf_bs_read_int_log(bs, 1, \"sps_partition_constraints_override_enabled_flag\");", "gf_bs_read_ue_log(bs, \"sps_log2_min_luma_coding_block_size_minus2\");", "u8 sps_max_mtt_hierarchy_depth_intra_slice_luma = gf_bs_read_ue_log(bs, \"sps_max_mtt_hierarchy_depth_intra_slice_luma\");", "if (sps_max_mtt_hierarchy_depth_intra_slice_luma != 0) {", "gf_bs_read_ue_log(bs, \"sps_log2_diff_max_bt_min_qt_intra_slice_luma\");", "gf_bs_read_ue_log(bs, \"sps_log2_diff_max_tt_min_qt_intra_slice_luma\");", "}", "u8 sps_qtbtt_dual_tree_intra_flag = 0;", "if (sps->chroma_format_idc) {", "sps_qtbtt_dual_tree_intra_flag = gf_bs_read_int_log(bs, 1, \"sps_qtbtt_dual_tree_intra_flag\");", "}", "if (sps_qtbtt_dual_tree_intra_flag) {", "gf_bs_read_ue_log(bs, \"sps_log2_diff_min_qt_min_cb_intra_slice_chroma\");", "u8 sps_max_mtt_hierarchy_depth_intra_slice_chroma = gf_bs_read_ue_log(bs, \"sps_max_mtt_hierarchy_depth_intra_slice_chroma\");", "if( sps_max_mtt_hierarchy_depth_intra_slice_chroma != 0) {", "gf_bs_read_ue_log(bs, \"sps_log2_diff_max_bt_min_qt_intra_slice_chroma\");", "gf_bs_read_ue_log(bs, \"sps_log2_diff_max_tt_min_qt_intra_slice_chroma\");", "}", "}", "gf_bs_read_ue_log(bs, \"sps_log2_diff_min_qt_min_cb_inter_slice\");", "u8 sps_max_mtt_hierarchy_depth_inter_slice = gf_bs_read_ue_log(bs, \"sps_max_mtt_hierarchy_depth_inter_slice\");", "if (sps_max_mtt_hierarchy_depth_inter_slice != 0) {", "gf_bs_read_ue_log(bs, \"sps_log2_diff_max_bt_min_qt_inter_slice\");", "gf_bs_read_ue_log(bs, \"sps_log2_diff_max_tt_min_qt_inter_slice\");", "}", "if (CtbSizeY > 32) {", "gf_bs_read_int_log(bs, 1, \"sps_max_luma_transform_size_64_flag\");", "}", "u8 sps_transform_skip_enabled_flag = gf_bs_read_int_log(bs, 1, \"sps_transform_skip_enabled_flag\");", "if (sps_transform_skip_enabled_flag) {", "gf_bs_read_ue_log(bs, \"sps_log2_transform_skip_max_size_minus2\");", "gf_bs_read_int_log(bs, 1, \"sps_bdpcm_enabled_flag\");", "}", "if (gf_bs_read_int_log(bs, 1, \"sps_mts_enabled_flag\")) {", "gf_bs_read_int_log(bs, 1, \"sps_explicit_mts_intra_enabled_flag\");", "gf_bs_read_int_log(bs, 1, \"sps_explicit_mts_inter_enabled_flag\");", "}", "gf_bs_read_int_log(bs, 1, \"sps_lfnst_enabled_flag\");", "if (sps->chroma_format_idc) {", "u8 sps_joint_cbcr_enabled_flag = gf_bs_read_int_log(bs, 1, \"sps_joint_cbcr_enabled_flag\");", "u8 sps_same_qp_table_for_chroma_flag = gf_bs_read_int_log(bs, 1, \"sps_same_qp_table_for_chroma_flag\");", "u32 numQpTables = sps_same_qp_table_for_chroma_flag ? 1 : (sps_joint_cbcr_enabled_flag ? 3 : 2);", "for (i=0; i<numQpTables; i++) {", "gf_bs_read_se_log_idx(bs, \"sps_qp_table_start_minus26\", i);", "u32 j, sps_num_points_in_qp_table = 1 + gf_bs_read_ue_log_idx(bs, \"sps_num_points_in_qp_table_minus1\", i);", "for (j=0; j<sps_num_points_in_qp_table; j++) {", "gf_bs_read_ue_log_idx2(bs, \"sps_delta_qp_in_val_minus1\", i, j);", "gf_bs_read_ue_log_idx2(bs, \"sps_delta_qp_diff_val\", i, j);", "}", "}", "}", "gf_bs_read_int_log(bs, 1, \"sps_sao_enabled_flag\");", "sps->alf_enabled_flag = gf_bs_read_int_log(bs, 1, \"sps_alf_enabled_flag\");", "if (sps->alf_enabled_flag && sps->chroma_format_idc) {", "gf_bs_read_int_log(bs, 1, \"sps_ccalf_enabled_flag\");", "}", "return sps_id;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["av_cold int ff_vc2enc_init_transforms(VC2TransformContext *s, int p_width, int p_height)", "{", "s->vc2_subband_dwt[VC2_TRANSFORM_9_7]    = vc2_subband_dwt_97;", "s->vc2_subband_dwt[VC2_TRANSFORM_5_3]    = vc2_subband_dwt_53;", "s->buffer = av_malloc(2*p_width*p_height*sizeof(dwtcoef));", "if (!s->buffer)", "return 1;", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 1, 0, 0, 1, 0]}
{"tokens": ["static int selectExpander(Walker *pWalker, Select *p){", "Parse *pParse = pWalker->pParse;", "int i, j, k;", "SrcList *pTabList;", "ExprList *pEList;", "struct SrcList_item *pFrom;", "sqlite3 *db = pParse->db;", "Expr *pE, *pRight, *pExpr;", "u16 selFlags = p->selFlags;", "u32 elistFlags = 0;", "p->selFlags |= SF_Expanded;", "if( db->mallocFailed  ){", "return WRC_Abort;", "}", "assert( p->pSrc!=0 );", "if( (selFlags & SF_Expanded)!=0 ){", "return WRC_Prune;", "}", "if( pWalker->eCode ){", "p->selId = ++pParse->nSelect;", "}", "pTabList = p->pSrc;", "pEList = p->pEList;", "sqlite3WithPush(pParse, p->pWith, 0);", "sqlite3SrcListAssignCursors(pParse, pTabList);", "for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){", "Table *pTab;", "assert( pFrom->fg.isRecursive==0 || pFrom->pTab!=0 );", "if( pFrom->fg.isRecursive ) continue;", "assert( pFrom->pTab==0 );", "#ifndef SQLITE_OMIT_CTE", "if( withExpand(pWalker, pFrom) ) return WRC_Abort;", "if( pFrom->pTab ) {} else", "#endif", "if( pFrom->zName==0 ){", "#ifndef SQLITE_OMIT_SUBQUERY", "Select *pSel = pFrom->pSelect;", "assert( pSel!=0 );", "assert( pFrom->pTab==0 );", "if( sqlite3WalkSelect(pWalker, pSel) ) return WRC_Abort;", "if( sqlite3ExpandSubquery(pParse, pFrom) ) return WRC_Abort;", "#endif", "}else{", "assert( pFrom->pTab==0 );", "pFrom->pTab = pTab = sqlite3LocateTableItem(pParse, 0, pFrom);", "if( pTab==0 ) return WRC_Abort;", "if( pTab->nTabRef>=0xffff ){", "sqlite3ErrorMsg(pParse, \"too many references to \\\"%s\\\": max 65535\",", "pTab->zName);", "pFrom->pTab = 0;", "return WRC_Abort;", "}", "pTab->nTabRef++;", "if( !IsVirtual(pTab) && cannotBeFunction(pParse, pFrom) ){", "return WRC_Abort;", "}", "#if !defined(SQLITE_OMIT_VIEW) || !defined (SQLITE_OMIT_VIRTUALTABLE)", "if( IsVirtual(pTab) || pTab->pSelect ){", "i16 nCol;", "u8 eCodeOrig = pWalker->eCode;", "if( sqlite3ViewGetColumnNames(pParse, pTab) ) return WRC_Abort;", "assert( pFrom->pSelect==0 );", "if( pTab->pSelect && (db->flags & SQLITE_EnableView)==0 ){", "sqlite3ErrorMsg(pParse, \"access to view \\\"%s\\\" prohibited\",", "pTab->zName);", "}", "pFrom->pSelect = sqlite3SelectDup(db, pTab->pSelect, 0);", "nCol = pTab->nCol;", "pTab->nCol = -1;", "pWalker->eCode = 1;", "sqlite3WalkSelect(pWalker, pFrom->pSelect);", "pWalker->eCode = eCodeOrig;", "pTab->nCol = nCol;", "}", "#endif", "}", "if( sqlite3IndexedByLookup(pParse, pFrom) ){", "return WRC_Abort;", "}", "}", "if( db->mallocFailed || sqliteProcessJoin(pParse, p) ){", "return WRC_Abort;", "}", "for(k=0; k<pEList->nExpr; k++){", "pE = pEList->a[k].pExpr;", "if( pE->op==TK_ASTERISK ) break;", "assert( pE->op!=TK_DOT || pE->pRight!=0 );", "assert( pE->op!=TK_DOT || (pE->pLeft!=0 && pE->pLeft->op==TK_ID) );", "if( pE->op==TK_DOT && pE->pRight->op==TK_ASTERISK ) break;", "elistFlags |= pE->flags;", "}", "if( k<pEList->nExpr ){", "struct ExprList_item *a = pEList->a;", "ExprList *pNew = 0;", "int flags = pParse->db->flags;", "int longNames = (flags & SQLITE_FullColNames)!=0", "&& (flags & SQLITE_ShortColNames)==0;", "for(k=0; k<pEList->nExpr; k++){", "pE = a[k].pExpr;", "elistFlags |= pE->flags;", "pRight = pE->pRight;", "assert( pE->op!=TK_DOT || pRight!=0 );", "if( pE->op!=TK_ASTERISK", "&& (pE->op!=TK_DOT || pRight->op!=TK_ASTERISK)", "){", "pNew = sqlite3ExprListAppend(pParse, pNew, a[k].pExpr);", "if( pNew ){", "pNew->a[pNew->nExpr-1].zName = a[k].zName;", "pNew->a[pNew->nExpr-1].zSpan = a[k].zSpan;", "a[k].zName = 0;", "a[k].zSpan = 0;", "}", "a[k].pExpr = 0;", "}else{", "int tableSeen = 0;", "char *zTName = 0;", "if( pE->op==TK_DOT ){", "assert( pE->pLeft!=0 );", "assert( !ExprHasProperty(pE->pLeft, EP_IntValue) );", "zTName = pE->pLeft->u.zToken;", "}", "for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){", "Table *pTab = pFrom->pTab;", "Select *pSub = pFrom->pSelect;", "char *zTabName = pFrom->zAlias;", "const char *zSchemaName = 0;", "int iDb;", "if( zTabName==0 ){", "zTabName = pTab->zName;", "}", "if( db->mallocFailed ) break;", "if( pSub==0 || (pSub->selFlags & SF_NestedFrom)==0 ){", "pSub = 0;", "if( zTName && sqlite3StrICmp(zTName, zTabName)!=0 ){", "continue;", "}", "iDb = sqlite3SchemaToIndex(db, pTab->pSchema);", "zSchemaName = iDb>=0 ? db->aDb[iDb].zDbSName : \"*\";", "}", "for(j=0; j<pTab->nCol; j++){", "char *zName = pTab->aCol[j].zName;", "char *zColname;", "char *zToFree;", "Token sColname;", "assert( zName );", "if( zTName && pSub", "&& sqlite3MatchSpanName(pSub->pEList->a[j].zSpan, 0, zTName, 0)==0", "){", "continue;", "}", "if( (p->selFlags & SF_IncludeHidden)==0", "&& IsHiddenColumn(&pTab->aCol[j])", "){", "continue;", "}", "tableSeen = 1;", "if( i>0 && zTName==0 ){", "if( (pFrom->fg.jointype & JT_NATURAL)!=0", "&& tableAndColumnIndex(pTabList, i, zName, 0, 0)", "){", "continue;", "}", "if( sqlite3IdListIndex(pFrom->pUsing, zName)>=0 ){", "continue;", "}", "}", "pRight = sqlite3Expr(db, TK_ID, zName);", "zColname = zName;", "zToFree = 0;", "if( longNames || pTabList->nSrc>1 ){", "Expr *pLeft;", "pLeft = sqlite3Expr(db, TK_ID, zTabName);", "pExpr = sqlite3PExpr(pParse, TK_DOT, pLeft, pRight);", "if( zSchemaName ){", "pLeft = sqlite3Expr(db, TK_ID, zSchemaName);", "pExpr = sqlite3PExpr(pParse, TK_DOT, pLeft, pExpr);", "}", "if( longNames ){", "zColname = sqlite3MPrintf(db, \"%s.%s\", zTabName, zName);", "zToFree = zColname;", "}", "}else{", "pExpr = pRight;", "}", "pNew = sqlite3ExprListAppend(pParse, pNew, pExpr);", "sqlite3TokenInit(&sColname, zColname);", "sqlite3ExprListSetName(pParse, pNew, &sColname, 0);", "if( pNew && (p->selFlags & SF_NestedFrom)!=0 ){", "struct ExprList_item *pX = &pNew->a[pNew->nExpr-1];", "if( pSub ){", "pX->zSpan = sqlite3DbStrDup(db, pSub->pEList->a[j].zSpan);", "testcase( pX->zSpan==0 );", "}else{", "pX->zSpan = sqlite3MPrintf(db, \"%s.%s.%s\",", "zSchemaName, zTabName, zColname);", "testcase( pX->zSpan==0 );", "}", "pX->bSpanIsTab = 1;", "}", "sqlite3DbFree(db, zToFree);", "}", "}", "if( !tableSeen ){", "if( zTName ){", "sqlite3ErrorMsg(pParse, \"no such table: %s\", zTName);", "}else{", "sqlite3ErrorMsg(pParse, \"no tables specified\");", "}", "}", "}", "}", "sqlite3ExprListDelete(db, pEList);", "p->pEList = pNew;", "}", "if( p->pEList ){", "if( p->pEList->nExpr>db->aLimit[SQLITE_LIMIT_COLUMN] ){", "sqlite3ErrorMsg(pParse, \"too many columns in result set\");", "return WRC_Abort;", "}", "if( (elistFlags & (EP_HasFunc|EP_Subquery))!=0 ){", "p->selFlags |= SF_ComplexResult;", "}", "}", "return WRC_Continue;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["GF_AV1Config *gf_isom_av1_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)", "{", "GF_TrackBox *trak;", "GF_MPEGVisualSampleEntryBox *entry;", "if (gf_isom_get_reference_count(the_file, trackNumber, GF_ISOM_REF_TBAS)) {", "u32 ref_track;", "GF_Err e = gf_isom_get_reference(the_file, trackNumber, GF_ISOM_REF_TBAS, 1, &ref_track);", "if (e == GF_OK) {", "trackNumber = ref_track;", "}", "}", "trak = gf_isom_get_track_from_file(the_file, trackNumber);", "if (!trak || !trak->Media || !DescriptionIndex) return NULL;", "entry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex - 1);", "if (!entry || !entry->av1_config) return NULL;", "return AV1_DuplicateConfig(entry->av1_config->config);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["GF_Err gf_bifs_dec_sf_field(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field, Bool is_mem_com)", "{", "GF_Err e;", "GF_Node *new_node;", "u32 size, length, w, h, i;", "char *buffer;", "if (codec->ActiveQP && node) {", "e = gf_bifs_dec_unquant_field(codec, bs, node, field);", "if (e != GF_EOS) return e;", "}", "switch (field->fieldType) {", "case GF_SG_VRML_SFBOOL:", "* ((SFBool *) field->far_ptr) = (SFBool) gf_bs_read_int(bs, 1);", "break;", "case GF_SG_VRML_SFCOLOR:", "((SFColor *)field->far_ptr)->red = BD_ReadSFFloat(codec, bs);", "((SFColor *)field->far_ptr)->green = BD_ReadSFFloat(codec, bs);", "((SFColor *)field->far_ptr)->blue = BD_ReadSFFloat(codec, bs);", "break;", "case GF_SG_VRML_SFFLOAT:", "*((SFFloat *)field->far_ptr) = BD_ReadSFFloat(codec, bs);", "break;", "case GF_SG_VRML_SFINT32:", "*((SFInt32 *)field->far_ptr) = (s32) gf_bs_read_int(bs, 32);", "break;", "case GF_SG_VRML_SFTIME:", "*((SFTime *)field->far_ptr) = gf_bs_read_double(bs);", "if (node) BD_CheckSFTimeOffset(codec, node, field);", "break;", "case GF_SG_VRML_SFVEC2F:", "((SFVec2f *)field->far_ptr)->x = BD_ReadSFFloat(codec, bs);", "((SFVec2f *)field->far_ptr)->y = BD_ReadSFFloat(codec, bs);", "break;", "case GF_SG_VRML_SFVEC3F:", "((SFVec3f *)field->far_ptr)->x = BD_ReadSFFloat(codec, bs);", "((SFVec3f *)field->far_ptr)->y = BD_ReadSFFloat(codec, bs);", "((SFVec3f *)field->far_ptr)->z = BD_ReadSFFloat(codec, bs);", "break;", "case GF_SG_VRML_SFROTATION:", "((SFRotation *)field->far_ptr)->x = BD_ReadSFFloat(codec, bs);", "((SFRotation *)field->far_ptr)->y = BD_ReadSFFloat(codec, bs);", "((SFRotation *)field->far_ptr)->z = BD_ReadSFFloat(codec, bs);", "((SFRotation *)field->far_ptr)->q = BD_ReadSFFloat(codec, bs);", "break;", "case GF_SG_VRML_SFSTRING:", "size = gf_bs_read_int(bs, 5);", "length = gf_bs_read_int(bs, size);", "if (gf_bs_available(bs) < length) return GF_NON_COMPLIANT_BITSTREAM;", "if (node && (node->sgprivate->tag==TAG_MPEG4_CacheTexture) && (field->fieldIndex<=2)) {", "M_CacheTexture *ct = (M_CacheTexture *) node;", "ct->data_len = length;", "if (ct->data) gf_free(ct->data);", "ct->data = (u8*)gf_malloc(sizeof(char)*length);", "gf_bs_read_data(bs, (char*)ct->data, length);", "} else if (node && (node->sgprivate->tag==TAG_MPEG4_BitWrapper) ) {", "M_BitWrapper *bw = (M_BitWrapper*) node;", "if (bw->buffer.buffer) gf_free(bw->buffer.buffer);", "bw->buffer_len = length;", "bw->buffer.buffer = (char*)gf_malloc(sizeof(char)*length);", "gf_bs_read_data(bs, (char*)bw->buffer.buffer, length);", "} else {", "if ( ((SFString *)field->far_ptr)->buffer ) gf_free( ((SFString *)field->far_ptr)->buffer);", "((SFString *)field->far_ptr)->buffer = (char *)gf_malloc(sizeof(char)*(length+1));", "memset(((SFString *)field->far_ptr)->buffer , 0, length+1);", "for (i=0; i<length; i++) {", "((SFString *)field->far_ptr)->buffer[i] = gf_bs_read_int(bs, 8);", "}", "}", "break;", "case GF_SG_VRML_SFURL:", "{", "SFURL *url = (SFURL *) field->far_ptr;", "size = gf_bs_read_int(bs, 1);", "if (size) {", "if (url->url) gf_free(url->url );", "url->url = NULL;", "length = gf_bs_read_int(bs, 10);", "url->OD_ID = length;", "} else {", "if ( url->OD_ID ) url->OD_ID = (u32) -1;", "size = gf_bs_read_int(bs, 5);", "length = gf_bs_read_int(bs, size);", "if (gf_bs_available(bs) < length) return GF_NON_COMPLIANT_BITSTREAM;", "buffer = NULL;", "if (length) {", "buffer = (char *)gf_malloc(sizeof(char)*(length+1));", "memset(buffer, 0, length+1);", "for (i=0; i<length; i++) buffer[i] = gf_bs_read_int(bs, 8);", "}", "if (url->url) gf_free( url->url);", "if (buffer && strlen(buffer)) {", "url->url = buffer;", "} else {", "gf_free(buffer);", "url->url = NULL;", "}", "}", "}", "break;", "case GF_SG_VRML_SFIMAGE:", "if (((SFImage *)field->far_ptr)->pixels) {", "gf_free(((SFImage *)field->far_ptr)->pixels);", "((SFImage *)field->far_ptr)->pixels = NULL;", "}", "w = gf_bs_read_int(bs, 12);", "h = gf_bs_read_int(bs, 12);", "length = gf_bs_read_int(bs, 2);", "if (length > 3) length = 3;", "length += 1;", "size = w * h * length;", "if (gf_bs_available(bs) < size) return GF_NON_COMPLIANT_BITSTREAM;", "((SFImage *)field->far_ptr)->width = w;", "((SFImage *)field->far_ptr)->height = h;", "((SFImage *)field->far_ptr)->numComponents = length;", "((SFImage *)field->far_ptr)->pixels = (unsigned char *)gf_malloc(sizeof(char)*size);", "for (i=0; i<size; i++) {", "((SFImage *)field->far_ptr)->pixels[i] = gf_bs_read_int(bs, 8);", "}", "break;", "case GF_SG_VRML_SFCOMMANDBUFFER:", "{", "SFCommandBuffer *sfcb = (SFCommandBuffer *)field->far_ptr;", "if (!node) return GF_BAD_PARAM;", "if (sfcb->buffer) {", "gf_free(sfcb->buffer);", "sfcb->buffer = NULL;", "}", "while (gf_list_count(sfcb->commandList)) {", "GF_Command *com = (GF_Command*)gf_list_get(sfcb->commandList, 0);", "gf_list_rem(sfcb->commandList, 0);", "gf_sg_command_del(com);", "}", "size = gf_bs_read_int(bs, 5);", "length = gf_bs_read_int(bs, size);", "if (gf_bs_available(bs) < length) return GF_NON_COMPLIANT_BITSTREAM;", "sfcb->bufferSize = length;", "if (length) {", "sfcb->buffer = (unsigned char *)gf_malloc(sizeof(char)*(length));", "for (i=0; i<length; i++) {", "sfcb->buffer[i] = gf_bs_read_int(bs, 8);", "}", "}", "SFCommandBufferChanged(codec, node);", "if (codec->dec_memory_mode || (node->sgprivate->tag==TAG_MPEG4_InputSensor)) {", "CommandBufferItem *cbi = (CommandBufferItem *)gf_malloc(sizeof(CommandBufferItem));", "cbi->node = node;", "gf_node_register(cbi->node, NULL);", "cbi->cb = sfcb;", "gf_list_add(codec->command_buffers, cbi);", "}", "}", "break;", "case GF_SG_VRML_SFNODE:", "if (!is_mem_com) {", "GF_Node *old_node = *((GF_Node **) field->far_ptr);", "if (old_node != NULL) {", "u32 i, count = gf_list_count(codec->command_buffers);", "for (i=0; i<count; i++) {", "CommandBufferItem *cbi = (CommandBufferItem*) gf_list_get(codec->command_buffers, i);", "if (cbi->node == old_node) {", "gf_list_rem(codec->command_buffers, i);", "i--;", "count--;", "gf_node_unregister(cbi->node, NULL);", "gf_free(cbi);", "}", "}", "gf_node_unregister(old_node, node);", "*((GF_Node **) field->far_ptr) = NULL;", "}", "}", "new_node = gf_bifs_dec_node(codec, bs, field->NDTtype);", "if (new_node) {", "e = gf_node_register(new_node, is_mem_com ? NULL : node);", "if (e) return e;", "}", "*((GF_Node **) field->far_ptr) = new_node;", "break;", "case GF_SG_VRML_SFSCRIPT:", "#ifdef GPAC_HAS_QJS", "codec->LastError = node ? SFScript_Parse(codec, (SFScript*)field->far_ptr, bs, node) : GF_NON_COMPLIANT_BITSTREAM;", "#else", "return GF_NOT_SUPPORTED;", "#endif", "break;", "case GF_SG_VRML_SFATTRREF:", "{", "SFAttrRef *ar = (SFAttrRef *)field->far_ptr;", "u32 nodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);", "ar->node = gf_sg_find_node(codec->current_graph, nodeID);", "if (!ar->node) {", "} else {", "u32 nbBitsDEF = gf_get_bit_size(gf_node_get_num_fields_in_mode(ar->node, GF_SG_FIELD_CODING_DEF) - 1);", "u32 field_ref = gf_bs_read_int(bs, nbBitsDEF);", "codec->LastError = gf_bifs_get_field_index(ar->node, field_ref, GF_SG_FIELD_CODING_DEF, &ar->fieldIndex);", "}", "}", "break;", "default:", "return GF_NON_COMPLIANT_BITSTREAM;", "}", "return codec->LastError;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["ctcompare(const char *a,", "const char *b)", "{", "int result = 0;", "while (*a && *b)", "{", "result |= *a ^ *b;", "a ++;", "b ++;", "}", "return (result);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["coolkey_add_object(coolkey_private_data_t *priv, unsigned long object_id, const u8 *object_data, size_t object_length, int add_v1_record)", "{", "sc_cardctl_coolkey_object_t new_object;", "int r;", "memset(&new_object, 0, sizeof(new_object));", "new_object.path = coolkey_template_path;", "new_object.path.len = 4;", "ulong2bebytes(new_object.path.value, object_id);", "new_object.id = object_id;", "new_object.length = object_length;", "if (object_data) {", "new_object.data = malloc(object_length + add_v1_record);", "if (new_object.data == NULL) {", "return SC_ERROR_OUT_OF_MEMORY;", "}", "if (add_v1_record) {", "new_object.data[0] = COOLKEY_V1_OBJECT;", "new_object.length++;", "}", "memcpy(&new_object.data[add_v1_record], object_data, object_length);", "}", "r = coolkey_add_object_to_list(&priv->objects_list, &new_object);", "if (r != SC_SUCCESS) {", "free(new_object.data);", "new_object.data = NULL;", "}", "return r;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["PackLinuxElf64::invert_pt_dynamic(Elf64_Dyn const *dynp)", "{", "if (dt_table[Elf64_Dyn::DT_NULL]) {", "return;", "}", "Elf64_Dyn const *const dynp0 = dynp;", "unsigned ndx = 1+ 0;", "if (dynp)", "for (; ; ++ndx, ++dynp) {", "upx_uint64_t const d_tag = get_te64(&dynp->d_tag);", "if (d_tag>>32) {", "char msg[50]; snprintf(msg, sizeof(msg),", "\"bad Elf64_Dyn[%d].d_tag %#lx\", -1+ ndx, (long unsigned)d_tag);", "throwCantPack(msg);", "}", "if (d_tag < DT_NUM) {", "if (Elf64_Dyn::DT_NEEDED != d_tag", "&&  dt_table[d_tag]", "&&    get_te64(&dynp->d_val)", "!= get_te64(&dynp0[-1+ dt_table[d_tag]].d_val)) {", "char msg[50]; snprintf(msg, sizeof(msg),", "\"duplicate DT_%#x: [%#x] [%#x]\",", "(unsigned)d_tag, -1+ dt_table[d_tag], -1+ ndx);", "throwCantPack(msg);", "}", "dt_table[d_tag] = ndx;", "}", "if (Elf64_Dyn::DT_NULL == d_tag) {", "break;", "}", "}", "upx_dt_init = 0;", "if (dt_table[Elf64_Dyn::DT_INIT])          upx_dt_init = Elf64_Dyn::DT_INIT;", "else if (dt_table[Elf64_Dyn::DT_PREINIT_ARRAY]) upx_dt_init = Elf64_Dyn::DT_PREINIT_ARRAY;", "else if (dt_table[Elf64_Dyn::DT_INIT_ARRAY])    upx_dt_init = Elf64_Dyn::DT_INIT_ARRAY;", "unsigned const z_str = dt_table[Elf64_Dyn::DT_STRSZ];", "if (z_str) {", "strtab_end = get_te64(&dynp0[-1+ z_str].d_val);", "if ((u64_t)file_size <= strtab_end) {", "char msg[50]; snprintf(msg, sizeof(msg),", "\"bad DT_STRSZ %#x\", strtab_end);", "throwCantPack(msg);", "}", "}", "unsigned const x_sym = dt_table[Elf64_Dyn::DT_SYMTAB];", "unsigned const x_str = dt_table[Elf64_Dyn::DT_STRTAB];", "if (x_sym && x_str) {", "upx_uint64_t const v_sym = get_te64(&dynp0[-1+ x_sym].d_val);", "upx_uint64_t const v_str = get_te64(&dynp0[-1+ x_str].d_val);", "unsigned const  z_sym = dt_table[Elf64_Dyn::DT_SYMENT];", "unsigned const sz_sym = !z_sym ? sizeof(Elf64_Sym)", ": get_te64(&dynp0[-1+ z_sym].d_val);", "if (v_sym < v_str) {", "symnum_end = (v_str - v_sym) / sz_sym;", "}", "}", "unsigned const v_hsh = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH);", "if (v_hsh && file_image) {", "hashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_HASH);", "if (!hashtab) {", "char msg[40]; snprintf(msg, sizeof(msg),", "\"bad DT_HASH %#x\", v_hsh);", "throwCantPack(msg);", "}", "unsigned const nbucket = get_te32(&hashtab[0]);", "unsigned const *const buckets = &hashtab[2];", "unsigned const *const chains = &buckets[nbucket]; (void)chains;", "unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);", "if (!nbucket", "|| (nbucket>>31) || (file_size/sizeof(unsigned)) <= (2*nbucket)", "|| ((v_hsh < v_sym) && (v_sym - v_hsh) < (sizeof(unsigned)*2", "+ sizeof(*buckets)*nbucket", "+ sizeof(*chains) *nbucket", "))", ") {", "char msg[90]; snprintf(msg, sizeof(msg),", "\"bad DT_HASH nbucket=%#x  len=%#x\",", "nbucket, (v_sym - v_hsh));", "throwCantPack(msg);", "}", "}", "unsigned const v_gsh = elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH);", "if (v_gsh && file_image) {", "gashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_GNU_HASH);", "if (!gashtab) {", "char msg[40]; snprintf(msg, sizeof(msg),", "\"bad DT_GNU_HASH %#x\", v_gsh);", "throwCantPack(msg);", "}", "unsigned const n_bucket = get_te32(&gashtab[0]);", "unsigned const n_bitmask = get_te32(&gashtab[2]);", "unsigned const gnu_shift = get_te32(&gashtab[3]);", "upx_uint64_t const *const bitmask = (upx_uint64_t const *)(void const *)&gashtab[4];", "unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask];", "unsigned     const *const hasharr = &buckets[n_bucket]; (void)hasharr;", "upx_uint64_t const v_sym = get_te64(&dynp0[-1+ x_sym].d_val);", "if (!n_bucket || !n_bitmask", "|| (-1+ n_bitmask) & n_bitmask", "|| 8*sizeof(upx_uint64_t) <= gnu_shift", "|| (n_bucket>>30)", "|| (n_bitmask>>30)", "|| (file_size/sizeof(unsigned)) <= ((sizeof(*bitmask)/sizeof(unsigned))*n_bitmask + 2*n_bucket)", "|| ((v_gsh < v_sym) && (v_sym - v_gsh) < (sizeof(unsigned)*4", "+ sizeof(*bitmask)*n_bitmask", "+ sizeof(*buckets)*n_bucket", "+ sizeof(*hasharr)*n_bucket", "))", ") {", "char msg[90]; snprintf(msg, sizeof(msg),", "\"bad DT_GNU_HASH n_bucket=%#x  n_bitmask=%#x  len=%#lx\",", "n_bucket, n_bitmask, (long unsigned)(v_sym - v_gsh));", "throwCantPack(msg);", "}", "}", "unsigned const e_shstrndx = get_te16(&ehdri.e_shstrndx);", "if (e_shnum <= e_shstrndx", "&&  !(0==e_shnum && 0==e_shstrndx) ) {", "char msg[40]; snprintf(msg, sizeof(msg),", "\"bad .e_shstrndx %d >= .e_shnum %d\", e_shstrndx, e_shnum);", "throwCantPack(msg);", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["GF_Err gf_hinter_finalize(GF_ISOFile *file, GF_SDP_IODProfile IOD_Profile, u32 bandwidth)", "{", "u32 i, sceneT, odT, descIndex, size, size64;", "GF_InitialObjectDescriptor *iod;", "GF_SLConfig slc;", "GF_ISOSample *samp;", "Bool remove_ocr;", "u8 *buffer;", "char buf64[5000], sdpLine[5100];", "gf_isom_sdp_clean(file);", "if (bandwidth) {", "sprintf(buf64, \"b=AS:%d\", bandwidth);", "gf_isom_sdp_add_line(file, buf64);", "}", "if (gf_sys_is_test_mode()) {", "sprintf(buf64, \"a=x-copyright: %s\", \"MP4/3GP File hinted with GPAC - (c) Telecom ParisTech (http:gpac.io)\");", "} else {", "sprintf(buf64, \"a=x-copyright: MP4/3GP File hinted with GPAC %s - %s\", gf_gpac_version(), gf_gpac_copyright() );", "}", "gf_isom_sdp_add_line(file, buf64);", "if (IOD_Profile == GF_SDP_IOD_NONE) return GF_OK;", "odT = sceneT = 0;", "for (i=0; i<gf_isom_get_track_count(file); i++) {", "if (!gf_isom_is_track_in_root_od(file, i+1)) continue;", "switch (gf_isom_get_media_type(file,i+1)) {", "case GF_ISOM_MEDIA_OD:", "odT = i+1;", "break;", "case GF_ISOM_MEDIA_SCENE:", "sceneT = i+1;", "break;", "}", "}", "remove_ocr = 0;", "if (IOD_Profile == GF_SDP_IOD_ISMA_STRICT) {", "IOD_Profile = GF_SDP_IOD_ISMA;", "remove_ocr = 1;", "}", "if ( (IOD_Profile == GF_SDP_IOD_ISMA) && !sceneT ) return GF_BAD_PARAM;", "iod = (GF_InitialObjectDescriptor *) gf_isom_get_root_od(file);", "if (!iod) return GF_NOT_SUPPORTED;", "if (IOD_Profile == GF_SDP_IOD_ISMA) {", "GF_ESD *esd;", "Bool is_ok = 1;", "while (gf_list_count(iod->ESDescriptors)) {", "esd = (GF_ESD*)gf_list_get(iod->ESDescriptors, 0);", "gf_odf_desc_del((GF_Descriptor *) esd);", "gf_list_rem(iod->ESDescriptors, 0);", "}", "if (odT) {", "esd = gf_isom_get_esd(file, odT, 1);", "if (gf_isom_get_sample_count(file, odT)==1) {", "samp = gf_isom_get_sample(file, odT, 1, &descIndex);", "if (samp && gf_hinter_can_embbed_data(samp->data, samp->dataLength, GF_STREAM_OD)) {", "InitSL_NULL(&slc);", "slc.predefined = 0;", "slc.hasRandomAccessUnitsOnlyFlag = 1;", "slc.timeScale = slc.timestampResolution = gf_isom_get_media_timescale(file, odT);", "slc.OCRResolution = 1000;", "slc.startCTS = samp->DTS+samp->CTS_Offset;", "slc.startDTS = samp->DTS;", "gf_isom_set_extraction_slc(file, odT, 1, &slc);", "size64 = gf_base64_encode(samp->data, samp->dataLength, buf64, 2000);", "buf64[size64] = 0;", "sprintf(sdpLine, \"data:application/mpeg4-od-au;base64,%s\", buf64);", "esd->decoderConfig->avgBitrate = 0;", "esd->decoderConfig->bufferSizeDB = samp->dataLength;", "esd->decoderConfig->maxBitrate = 0;", "size64 = (u32) strlen(sdpLine)+1;", "esd->URLString = (char*)gf_malloc(sizeof(char) * size64);", "strcpy(esd->URLString, sdpLine);", "} else {", "GF_LOG(GF_LOG_WARNING, GF_LOG_RTP, (\"[rtp hinter] OD sample too large to be embedded in IOD - ISMA disabled\\n\"));", "is_ok = 0;", "}", "gf_isom_sample_del(&samp);", "}", "if (remove_ocr) esd->OCRESID = 0;", "else if (esd->OCRESID == esd->ESID) esd->OCRESID = 0;", "gf_list_add(iod->ESDescriptors, esd);", "}", "esd = gf_isom_get_esd(file, sceneT, 1);", "if (gf_isom_get_sample_count(file, sceneT)==1) {", "samp = gf_isom_get_sample(file, sceneT, 1, &descIndex);", "if (gf_hinter_can_embbed_data(samp->data, samp->dataLength, GF_STREAM_SCENE)) {", "slc.timeScale = slc.timestampResolution = gf_isom_get_media_timescale(file, sceneT);", "slc.OCRResolution = 1000;", "slc.startCTS = samp->DTS+samp->CTS_Offset;", "slc.startDTS = samp->DTS;", "gf_isom_set_extraction_slc(file, sceneT, 1, &slc);", "size64 = gf_base64_encode(samp->data, samp->dataLength, buf64, 2000);", "buf64[size64] = 0;", "sprintf(sdpLine, \"data:application/mpeg4-bifs-au;base64,%s\", buf64);", "esd->decoderConfig->avgBitrate = 0;", "esd->decoderConfig->bufferSizeDB = samp->dataLength;", "esd->decoderConfig->maxBitrate = 0;", "esd->URLString = (char*)gf_malloc(sizeof(char) * (strlen(sdpLine)+1));", "strcpy(esd->URLString, sdpLine);", "} else {", "GF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[rtp hinter] Scene description sample too large to be embedded in IOD - ISMA disabled\\n\"));", "is_ok = 0;", "}", "gf_isom_sample_del(&samp);", "}", "if (remove_ocr) esd->OCRESID = 0;", "else if (esd->OCRESID == esd->ESID) esd->OCRESID = 0;", "gf_list_add(iod->ESDescriptors, esd);", "if (is_ok) {", "u32 has_a, has_v, has_i_a, has_i_v;", "has_a = has_v = has_i_a = has_i_v = 0;", "for (i=0; i<gf_isom_get_track_count(file); i++) {", "esd = gf_isom_get_esd(file, i+1, 1);", "if (!esd) continue;", "if (esd->decoderConfig->streamType==GF_STREAM_VISUAL) {", "if (esd->decoderConfig->objectTypeIndication==GF_CODECID_MPEG4_PART2) has_i_v ++;", "else has_v++;", "} else if (esd->decoderConfig->streamType==GF_STREAM_AUDIO) {", "if (esd->decoderConfig->objectTypeIndication==GF_CODECID_AAC_MPEG4) has_i_a ++;", "else has_a++;", "}", "gf_odf_desc_del((GF_Descriptor *)esd);", "}", "if (!has_v && !has_a && (has_i_v<=1) && (has_i_a<=1)) {", "sprintf(sdpLine, \"a=isma-compliance:1,1.0,1\");", "gf_isom_sdp_add_line(file, sdpLine);", "}", "}", "}", "buffer = NULL;", "size = 0;", "gf_odf_desc_write((GF_Descriptor *) iod, &buffer, &size);", "gf_odf_desc_del((GF_Descriptor *)iod);", "size64 = gf_base64_encode(buffer, size, buf64, 2000);", "buf64[size64] = 0;", "gf_free(buffer);", "sprintf(sdpLine, \"a=mpeg4-iod:\\\"data:application/mpeg4-iod;base64,%s\\\"\", buf64);", "gf_isom_sdp_add_line(file, sdpLine);", "return GF_OK;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["int af_get_page(AFFILE *af,int64_t pagenum,unsigned char *data,size_t *bytes)", "{", "uint32_t arg=0;", "size_t page_len=0;", "if (af_trace){", "fprintf(af_trace,\"af_get_page(%p,pagenum=%\" I64d \",buf=%p,bytes=%u)\\n\",af,pagenum,data,(int)*bytes);", "}", "int r = af_get_page_raw(af,pagenum,&arg,0,&page_len);", "if(r){", "if(data && (af->openmode & AF_BADBLOCK_FILL) && errno == ENOENT)", "{", "for(size_t i = 0;i <= af->image_pagesize - af->image_sectorsize;", "i+= af->image_sectorsize){", "memcpy(data+i,af->badflag,af->image_sectorsize);", "af->bytes_memcpy += af->image_sectorsize;", "}", "r = 0;", "}", "return r;", "}", "uint32_t pageflag = 0;", "if((arg & AF_PAGE_COMPRESSED)==0){", "if(data==0){", "if(bytes) *bytes = page_len;", "return 0;", "}", "int ret = af_get_page_raw(af,pagenum,&pageflag,data,bytes);", "if(*bytes > page_len) *bytes = page_len;", "if(ret!=0) return ret;", "}", "else {", "unsigned char *compressed_data = (unsigned char *)malloc(page_len);", "size_t compressed_data_len = page_len;", "if(compressed_data==0){", "return -2;", "}", "if(af_get_page_raw(af,pagenum,&pageflag,compressed_data,&compressed_data_len)){", "free(compressed_data);", "return -3;", "}", "int res = -1;", "bool free_data = false;", "if(data==0){", "data = (unsigned char *)malloc(af->image_pagesize);", "free_data = true;", "*bytes = af->image_pagesize;", "}", "switch((pageflag & AF_PAGE_COMP_ALG_MASK)){", "case AF_PAGE_COMP_ALG_ZERO:", "if(compressed_data_len != 4){", "(*af->error_reporter)(\"ALG_ZERO compressed data is %d bytes, expected 4.\",compressed_data_len);", "break;", "}", "memset(data,0,af->image_pagesize);", "*bytes = ntohl(*(long *)compressed_data);", "res = 0;", "break;", "case AF_PAGE_COMP_ALG_ZLIB:", "res = uncompress(data,(uLongf *)bytes,compressed_data,compressed_data_len);", "switch(res){", "case Z_OK:", "break;", "case Z_ERRNO:", "(*af->error_reporter)(\"Z_ERRNOR decompressing segment %\" I64d,pagenum);", "case Z_STREAM_ERROR:", "(*af->error_reporter)(\"Z_STREAM_ERROR decompressing segment %\" I64d,pagenum);", "case Z_DATA_ERROR:", "(*af->error_reporter)(\"Z_DATA_ERROR decompressing segment %\" I64d,pagenum);", "case Z_MEM_ERROR:", "(*af->error_reporter)(\"Z_MEM_ERROR decompressing segment %\" I64d,pagenum);", "case Z_BUF_ERROR:", "(*af->error_reporter)(\"Z_BUF_ERROR decompressing segment %\" I64d,pagenum);", "case Z_VERSION_ERROR:", "(*af->error_reporter)(\"Z_VERSION_ERROR decompressing segment %\" I64d,pagenum);", "default:", "(*af->error_reporter)(\"uncompress returned an invalid value in get_segment\");", "}", "break;", "#ifdef USE_LZMA", "case AF_PAGE_COMP_ALG_LZMA:", "res = lzma_uncompress(data,bytes,compressed_data,compressed_data_len);", "if (af_trace) fprintf(af_trace,\"   LZMA decompressed page %\" I64d \". %d bytes => %u bytes\\n\",", "pagenum,(int)compressed_data_len,(int)*bytes);", "switch(res){", "case 0:break;", "case 1:(*af->error_reporter)(\"LZMA header error decompressing segment %\" I64d \"\\n\",pagenum);", "break;", "case 2:(*af->error_reporter)(\"LZMA memory error decompressing segment %\" I64d \"\\n\",pagenum);", "break;", "}", "break;", "#endif", "default:", "(*af->error_reporter)(\"Unknown compression algorithm 0x%d\",", "pageflag & AF_PAGE_COMP_ALG_MASK);", "break;", "}", "if(free_data){", "free(data);", "data = 0;", "}", "free(compressed_data);", "af->pages_decompressed++;", "if(res!=Z_OK) return -1;", "}", "if(data && (af->image_pagesize > af->image_sectorsize)){", "const int SECTOR_SIZE = af->image_sectorsize;", "size_t bytes_left_in_sector = (SECTOR_SIZE - (*bytes % SECTOR_SIZE)) % SECTOR_SIZE;", "for(size_t i=0;i<bytes_left_in_sector;i++){", "data[*bytes + i] = 0;", "}", "size_t end_of_data = *bytes + bytes_left_in_sector;", "for(size_t i = end_of_data; i <= af->image_pagesize-SECTOR_SIZE; i+=SECTOR_SIZE){", "memcpy(data+i,af->badflag,SECTOR_SIZE);", "af->bytes_memcpy += SECTOR_SIZE;", "}", "}", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["Error HeifContext::get_id_of_non_virtual_child_image(heif_item_id id, heif_item_id& out) const", "{", "std::string image_type = m_heif_file->get_item_type(id);", "if (image_type==\"grid\" ||", "image_type==\"iden\" ||", "image_type==\"iovl\") {", "auto iref_box = m_heif_file->get_iref_box();", "std::vector<heif_item_id> image_references = iref_box->get_references(id, fourcc(\"dimg\"));", "if (image_references.empty()) {", "return Error(heif_error_Invalid_input,", "heif_suberror_No_item_data,", "\"Derived image does not reference any other image items\");", "}", "else {", "return get_id_of_non_virtual_child_image(image_references[0], out);", "}", "}", "else {", "out = id;", "return Error::Ok;", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["exif_data_load_data_content (ExifData *data, ExifIfd ifd,", "const unsigned char *d,", "unsigned int ds, unsigned int offset, unsigned int recursion_depth)", "{", "ExifLong o, thumbnail_offset = 0, thumbnail_length = 0;", "ExifShort n;", "ExifEntry *entry;", "unsigned int i;", "ExifTag tag;", "if (!data || !data->priv)", "return;", "if ((((int)ifd) < 0) || ( ((int)ifd) >= EXIF_IFD_COUNT))", "return;", "if (recursion_depth > 12) {", "exif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA, \"ExifData\",", "\"Deep recursion detected!\");", "return;", "}", "if ((offset + 2 < offset) || (offset + 2 < 2) || (offset + 2 > ds)) {", "exif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA, \"ExifData\",", "\"Tag data past end of buffer (%u > %u)\", offset+2, ds);", "return;", "}", "n = exif_get_short (d + offset, data->priv->order);", "exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",", "\"Loading %hu entries...\", n);", "offset += 2;", "if (offset + 12 * n > ds) {", "n = (ds - offset) / 12;", "exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",", "\"Short data; only loading %hu entries...\", n);", "}", "for (i = 0; i < n; i++) {", "tag = exif_get_short (d + offset + 12 * i, data->priv->order);", "switch (tag) {", "case EXIF_TAG_EXIF_IFD_POINTER:", "case EXIF_TAG_GPS_INFO_IFD_POINTER:", "case EXIF_TAG_INTEROPERABILITY_IFD_POINTER:", "case EXIF_TAG_JPEG_INTERCHANGE_FORMAT_LENGTH:", "case EXIF_TAG_JPEG_INTERCHANGE_FORMAT:", "o = exif_get_long (d + offset + 12 * i + 8,", "data->priv->order);", "exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",", "\"Sub-IFD entry 0x%x ('%s') at %u.\", tag,", "exif_tag_get_name(tag), o);", "switch (tag) {", "case EXIF_TAG_EXIF_IFD_POINTER:", "CHECK_REC (EXIF_IFD_EXIF);", "exif_data_load_data_content (data, EXIF_IFD_EXIF, d, ds, o, recursion_depth + 1);", "break;", "case EXIF_TAG_GPS_INFO_IFD_POINTER:", "CHECK_REC (EXIF_IFD_GPS);", "exif_data_load_data_content (data, EXIF_IFD_GPS, d, ds, o, recursion_depth + 1);", "break;", "case EXIF_TAG_INTEROPERABILITY_IFD_POINTER:", "CHECK_REC (EXIF_IFD_INTEROPERABILITY);", "exif_data_load_data_content (data, EXIF_IFD_INTEROPERABILITY, d, ds, o, recursion_depth + 1);", "break;", "case EXIF_TAG_JPEG_INTERCHANGE_FORMAT:", "thumbnail_offset = o;", "if (thumbnail_offset && thumbnail_length)", "exif_data_load_data_thumbnail (data, d,", "ds, thumbnail_offset,", "thumbnail_length);", "break;", "case EXIF_TAG_JPEG_INTERCHANGE_FORMAT_LENGTH:", "thumbnail_length = o;", "if (thumbnail_offset && thumbnail_length)", "exif_data_load_data_thumbnail (data, d,", "ds, thumbnail_offset,", "thumbnail_length);", "break;", "default:", "return;", "}", "break;", "default:", "if (!exif_tag_get_name_in_ifd (tag, ifd)) {", "if (!memcmp (d + offset + 12 * i, \"\\0\\0\\0\\0\", 4)) {", "exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",", "\"Skipping empty entry at position %u in '%s'.\", i,", "exif_ifd_get_name (ifd));", "break;", "}", "exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",", "\"Unknown tag 0x%04x (entry %u in '%s'). Please report this tag \"", "\"to <libexif-devel@lists.sourceforge.net>.\", tag, i,", "exif_ifd_get_name (ifd));", "if (data->priv->options & EXIF_DATA_OPTION_IGNORE_UNKNOWN_TAGS)", "break;", "}", "entry = exif_entry_new_mem (data->priv->mem);", "if (!entry) {", "exif_log (data->priv->log, EXIF_LOG_CODE_NO_MEMORY, \"ExifData\",", "\"Could not allocate memory\");", "return;", "}", "if (exif_data_load_data_entry (data, entry, d, ds,", "offset + 12 * i))", "exif_content_add_entry (data->ifd[ifd], entry);", "exif_entry_unref (entry);", "break;", "}", "}", "}"], "ner_tags": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int decode_frame(AVCodecContext *avctx, void *data,", "int *got_frame, AVPacket *avpkt)", "{", "EXRContext *s = avctx->priv_data;", "ThreadFrame frame = { .f = data };", "AVFrame *picture = data;", "uint8_t *ptr;", "int i, y, ret, ymax;", "int planes;", "int out_line_size;", "int nb_blocks;", "uint64_t start_offset_table;", "uint64_t start_next_scanline;", "PutByteContext offset_table_writer;", "bytestream2_init(&s->gb, avpkt->data, avpkt->size);", "if ((ret = decode_header(s, picture)) < 0)", "return ret;", "switch (s->pixel_type) {", "case EXR_FLOAT:", "case EXR_HALF:", "if (s->channel_offsets[3] >= 0) {", "if (!s->is_luma) {", "avctx->pix_fmt = AV_PIX_FMT_GBRAPF32;", "} else {", "avctx->pix_fmt = AV_PIX_FMT_GBRAPF32;", "}", "} else {", "if (!s->is_luma) {", "avctx->pix_fmt = AV_PIX_FMT_GBRPF32;", "} else {", "avctx->pix_fmt = AV_PIX_FMT_GRAYF32;", "}", "}", "break;", "case EXR_UINT:", "if (s->channel_offsets[3] >= 0) {", "if (!s->is_luma) {", "avctx->pix_fmt = AV_PIX_FMT_RGBA64;", "} else {", "avctx->pix_fmt = AV_PIX_FMT_YA16;", "}", "} else {", "if (!s->is_luma) {", "avctx->pix_fmt = AV_PIX_FMT_RGB48;", "} else {", "avctx->pix_fmt = AV_PIX_FMT_GRAY16;", "}", "}", "break;", "default:", "av_log(avctx, AV_LOG_ERROR, \"Missing channel list.\\n\");", "return AVERROR_INVALIDDATA;", "}", "if (s->apply_trc_type != AVCOL_TRC_UNSPECIFIED)", "avctx->color_trc = s->apply_trc_type;", "switch (s->compression) {", "case EXR_RAW:", "case EXR_RLE:", "case EXR_ZIP1:", "s->scan_lines_per_block = 1;", "break;", "case EXR_PXR24:", "case EXR_ZIP16:", "s->scan_lines_per_block = 16;", "break;", "case EXR_PIZ:", "case EXR_B44:", "case EXR_B44A:", "s->scan_lines_per_block = 32;", "break;", "default:", "avpriv_report_missing_feature(avctx, \"Compression %d\", s->compression);", "return AVERROR_PATCHWELCOME;", "}", "if (s->xmin > s->xmax  || s->ymin > s->ymax ||", "s->ydelta == 0xFFFFFFFF || s->xdelta == 0xFFFFFFFF) {", "av_log(avctx, AV_LOG_ERROR, \"Wrong or missing size information.\\n\");", "return AVERROR_INVALIDDATA;", "}", "if ((ret = ff_set_dimensions(avctx, s->w, s->h)) < 0)", "return ret;", "s->desc          = av_pix_fmt_desc_get(avctx->pix_fmt);", "if (!s->desc)", "return AVERROR_INVALIDDATA;", "if (s->desc->flags & AV_PIX_FMT_FLAG_FLOAT) {", "planes           = s->desc->nb_components;", "out_line_size    = avctx->width * 4;", "} else {", "planes           = 1;", "out_line_size    = avctx->width * 2 * s->desc->nb_components;", "}", "if (s->is_tile) {", "nb_blocks = ((s->xdelta + s->tile_attr.xSize - 1) / s->tile_attr.xSize) *", "((s->ydelta + s->tile_attr.ySize - 1) / s->tile_attr.ySize);", "} else {", "nb_blocks = (s->ydelta + s->scan_lines_per_block - 1) /", "s->scan_lines_per_block;", "}", "if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0)", "return ret;", "if (bytestream2_get_bytes_left(&s->gb)/8 < nb_blocks)", "return AVERROR_INVALIDDATA;", "if (!s->is_tile && bytestream2_peek_le64(&s->gb) == 0) {", "av_log(s->avctx, AV_LOG_DEBUG, \"recreating invalid scanline offset table\\n\");", "start_offset_table = bytestream2_tell(&s->gb);", "start_next_scanline = start_offset_table + nb_blocks * 8;", "bytestream2_init_writer(&offset_table_writer, &avpkt->data[start_offset_table], nb_blocks * 8);", "for (y = 0; y < nb_blocks; y++) {", "bytestream2_put_le64(&offset_table_writer, start_next_scanline);", "bytestream2_seek(&s->gb, start_next_scanline + 4, SEEK_SET);", "start_next_scanline += (bytestream2_get_le32(&s->gb) + 8);", "}", "bytestream2_seek(&s->gb, start_offset_table, SEEK_SET);", "}", "s->buf      = avpkt->data;", "s->buf_size = avpkt->size;", "for (i = 0; i < planes; i++) {", "ptr = picture->data[i];", "for (y = 0; y < FFMIN(s->ymin, s->h); y++) {", "memset(ptr, 0, out_line_size);", "ptr += picture->linesize[i];", "}", "}", "s->picture = picture;", "avctx->execute2(avctx, decode_block, s->thread_data, NULL, nb_blocks);", "ymax = FFMAX(0, s->ymax + 1);", "for (i = 0; i < planes; i++) {", "ptr = picture->data[i] + (ymax * picture->linesize[i]);", "for (y = ymax; y < avctx->height; y++) {", "memset(ptr, 0, out_line_size);", "ptr += picture->linesize[i];", "}", "}", "picture->pict_type = AV_PICTURE_TYPE_I;", "*got_frame = 1;", "return avpkt->size;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["return _buffer_reader.read_exactly(_read_buf, length).then([this] (fragmented_temporary_buffer buf) {", "auto linearization_buffer = bytes_ostream();", "int32_t uncomp_len = request_reader(buf.get_istream(), linearization_buffer).read_int();", "if (uncomp_len < 0) {", "throw std::runtime_error(\"CQL frame uncompressed length is negative: \" + std::to_string(uncomp_len));", "}", "buf.remove_prefix(4);", "auto in = input_buffer.get_linearized_view(fragmented_temporary_buffer::view(buf));", "auto uncomp = output_buffer.make_fragmented_temporary_buffer(uncomp_len, fragmented_temporary_buffer::default_fragment_size, [&] (bytes_mutable_view out) {", "auto ret = LZ4_decompress_safe(reinterpret_cast<const char*>(in.data()), reinterpret_cast<char*>(out.data()),", "in.size(), out.size());", "if (ret < 0) {", "throw std::runtime_error(\"CQL frame LZ4 uncompression failure\");", "}", "return out.size();", "});", "on_compression_buffer_use();", "return uncomp;", "});"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["static u8 BS_ReadByte(GF_BitStream *bs)", "{", "Bool is_eos;", "if (bs->bsmode == GF_BITSTREAM_READ) {", "u8 res;", "if (bs->position >= bs->size) {", "if (bs->EndOfStream) bs->EndOfStream(bs->par);", "if (!bs->overflow_state) bs->overflow_state = 1;", "return 0;", "}", "res = bs->original[bs->position++];", "if (bs->remove_emul_prevention_byte) {", "if ((bs->nb_zeros==2) && (res==0x03) && (bs->position<bs->size) && (bs->original[bs->position]<0x04)) {", "bs->nb_zeros = 0;", "res = bs->original[bs->position++];", "}", "if (!res) bs->nb_zeros++;", "else bs->nb_zeros = 0;", "}", "return res;", "}", "if (bs->cache_write)", "bs_flush_write_cache(bs);", "is_eos = gf_feof(bs->stream);", "if (!is_eos || bs->cache_read) {", "u8 res;", "Bool loc_eos=GF_FALSE;", "assert(bs->position<=bs->size);", "bs->position++;", "res = gf_bs_load_byte(bs, &loc_eos);", "if (loc_eos) goto bs_eof;", "if (bs->remove_emul_prevention_byte) {", "if ((bs->nb_zeros==2) && (res==0x03) && (bs->position<bs->size)) {", "u8 next = gf_bs_load_byte(bs, &loc_eos);", "if (next < 0x04) {", "bs->nb_zeros = 0;", "res = next;", "bs->position++;", "} else {", "gf_bs_seek(bs, bs->position);", "}", "}", "if (!res) bs->nb_zeros++;", "else bs->nb_zeros = 0;", "}", "return res;", "}", "bs_eof:", "if (bs->EndOfStream) {", "bs->EndOfStream(bs->par);", "if (!bs->overflow_state) bs->overflow_state = 1;", "} else {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[BS] Attempt to overread bitstream\\n\"));", "}", "assert(bs->position <= 1+bs->size);", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["GF_RTPHinter *gf_hinter_track_new(GF_ISOFile *file, u32 TrackNum,", "u32 Path_MTU, u32 max_ptime, u32 default_rtp_rate, u32 flags, u8 PayloadID,", "Bool copy_media, u32 InterleaveGroupID, u8 InterleaveGroupPriority, GF_Err *e)", "{", "GF_SLConfig my_sl;", "u32 descIndex, MinSize, MaxSize, avgTS, streamType, codecid, const_dur, nb_ch, maxDTSDelta;", "u8 OfficialPayloadID;", "u32 TrackMediaSubType, TrackMediaType, hintType, nbEdts, required_rate, force_dts_delta, avc_nalu_size, PL_ID, bandwidth, IV_length, KI_length;", "const char *url, *urn;", "char *mpeg4mode;", "Bool is_crypted, has_mpeg4_mapping;", "GF_RTPHinter *tmp;", "GF_ESD *esd;", "*e = GF_BAD_PARAM;", "if (!file || !TrackNum || !gf_isom_get_track_id(file, TrackNum)) return NULL;", "if (!gf_isom_get_sample_count(file, TrackNum)) {", "*e = GF_OK;", "return NULL;", "}", "*e = GF_NOT_SUPPORTED;", "nbEdts = gf_isom_get_edits_count(file, TrackNum);", "if (nbEdts>1) {", "u64 et, sd, mt;", "GF_ISOEditType em;", "gf_isom_get_edit(file, TrackNum, 1, &et, &sd, &mt, &em);", "if ((nbEdts>2) || (em!=GF_ISOM_EDIT_EMPTY)) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[rtp hinter] Cannot hint track whith EditList\\n\"));", "return NULL;", "}", "}", "if (nbEdts) gf_isom_remove_edits(file, TrackNum);", "if (!gf_isom_is_track_enabled(file, TrackNum)) return NULL;", "PL_ID = 0;", "OfficialPayloadID = 0;", "force_dts_delta = 0;", "streamType = 0;", "mpeg4mode = NULL;", "required_rate = 0;", "is_crypted = 0;", "IV_length = KI_length = 0;", "codecid = 0;", "nb_ch = 0;", "avc_nalu_size = 0;", "has_mpeg4_mapping = 1;", "const_dur = 0;", "bandwidth=0;", "TrackMediaType = gf_isom_get_media_type(file, TrackNum);", "if (!default_rtp_rate) default_rtp_rate = 90000;", "if ( (TrackMediaType==GF_ISOM_MEDIA_TEXT) || (TrackMediaType==GF_ISOM_MEDIA_SUBT)) {", "hintType = GF_RTP_PAYT_3GPP_TEXT;", "codecid = GF_CODECID_TEXT_MPEG4;", "streamType = GF_STREAM_TEXT;", "PL_ID = 0x10;", "} else {", "if (gf_isom_get_sample_description_count(file, TrackNum) > 1) return NULL;", "TrackMediaSubType = gf_isom_get_media_subtype(file, TrackNum, 1);", "switch (TrackMediaSubType) {", "case GF_ISOM_SUBTYPE_MPEG4_CRYP:", "is_crypted = 1;", "case GF_ISOM_SUBTYPE_MPEG4:", "esd = gf_isom_get_esd(file, TrackNum, 1);", "hintType = GF_RTP_PAYT_MPEG4;", "if (esd && esd->decoderConfig) {", "streamType = esd->decoderConfig->streamType;", "codecid = esd->decoderConfig->objectTypeIndication;", "if (esd->URLString) hintType = 0;", "if ((streamType==GF_STREAM_AUDIO)", "&& esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data", "&& ((codecid==GF_CODECID_AAC_MPEG4) || (codecid==GF_CODECID_AAC_MPEG2_MP) || (codecid==GF_CODECID_AAC_MPEG2_LCP) || (codecid==GF_CODECID_AAC_MPEG2_SSRP)) ) {", "u32 sample_rate;", "GF_M4ADecSpecInfo a_cfg;", "gf_m4a_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &a_cfg);", "nb_ch = a_cfg.nb_chan;", "sample_rate = a_cfg.base_sr;", "PL_ID = a_cfg.audioPL;", "switch (a_cfg.base_object_type) {", "case GF_M4A_AAC_MAIN:", "case GF_M4A_AAC_LC:", "if (flags & GP_RTP_PCK_USE_LATM_AAC) {", "hintType = GF_RTP_PAYT_LATM;", "break;", "}", "case GF_M4A_AAC_SBR:", "case GF_M4A_AAC_PS:", "case GF_M4A_AAC_LTP:", "case GF_M4A_AAC_SCALABLE:", "case GF_M4A_ER_AAC_LC:", "case GF_M4A_ER_AAC_LTP:", "case GF_M4A_ER_AAC_SCALABLE:", "mpeg4mode = \"AAC\";", "break;", "case GF_M4A_CELP:", "case GF_M4A_ER_CELP:", "mpeg4mode = \"CELP\";", "break;", "}", "required_rate = sample_rate;", "}", "else if ((streamType==GF_STREAM_AUDIO) && ((codecid==GF_CODECID_MPEG2_PART3) || (codecid==GF_CODECID_MPEG_AUDIO))) {", "GF_ISOSample *samp = NULL;", "if (!is_crypted)", "samp = gf_isom_get_sample(file, TrackNum, 1, NULL);", "if (samp && (samp->dataLength>3)) {", "u32 hdr = GF_4CC((u32)samp->data[0], (u8)samp->data[1], (u8)samp->data[2], (u8)samp->data[3]);", "nb_ch = gf_mp3_num_channels(hdr);", "hintType = GF_RTP_PAYT_MPEG12_AUDIO;", "OfficialPayloadID = 14;", "required_rate = 90000;", "}", "else {", "u32 sample_rate;", "gf_isom_get_audio_info(file, TrackNum, 1, &sample_rate, &nb_ch, NULL);", "required_rate = sample_rate;", "}", "if (samp)", "gf_isom_sample_del(&samp);", "}", "else if ((streamType==GF_STREAM_AUDIO) && (codecid==GF_CODECID_QCELP)) {", "hintType = GF_RTP_PAYT_QCELP;", "OfficialPayloadID = 12;", "required_rate = 8000;", "streamType = GF_STREAM_AUDIO;", "nb_ch = 1;", "}", "else if ((streamType==GF_STREAM_AUDIO) && ((codecid==GF_CODECID_EVRC) || (codecid==GF_CODECID_SMV)) ) {", "hintType = GF_RTP_PAYT_EVRC_SMV;", "required_rate = 8000;", "streamType = GF_STREAM_AUDIO;", "nb_ch = 1;", "}", "else if (streamType==GF_STREAM_VISUAL) {", "if ((codecid==GF_CODECID_MPEG4_PART2) && esd->decoderConfig->decoderSpecificInfo) {", "GF_M4VDecSpecInfo dsi;", "gf_m4v_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &dsi);", "PL_ID = dsi.VideoPL;", "}", "if ( ((codecid>=GF_CODECID_MPEG2_SIMPLE) && (codecid<=GF_CODECID_MPEG2_422)) || (codecid==GF_CODECID_MPEG1)) {", "if (!is_crypted) {", "hintType = GF_RTP_PAYT_MPEG12_VIDEO;", "OfficialPayloadID = 32;", "}", "}", "if (is_crypted) {", "if (codecid==GF_CODECID_MPEG4_PART2) force_dts_delta = 22;", "else if ((codecid==GF_CODECID_AVC) || (codecid==GF_CODECID_SVC)) {", "flags &= ~GP_RTP_PCK_USE_MULTI;", "force_dts_delta = 22;", "}", "flags |= GP_RTP_PCK_SIGNAL_RAP | GP_RTP_PCK_SIGNAL_TS;", "}", "required_rate = default_rtp_rate;", "}", "else if (gf_isom_has_sync_shadows(file, TrackNum) || gf_isom_has_sample_dependency(file, TrackNum)) {", "flags |= GP_RTP_PCK_SYSTEMS_CAROUSEL;", "}", "gf_odf_desc_del((GF_Descriptor*)esd);", "}", "break;", "case GF_ISOM_SUBTYPE_3GP_H263:", "hintType = GF_RTP_PAYT_H263;", "required_rate = 90000;", "streamType = GF_STREAM_VISUAL;", "OfficialPayloadID = 34;", "codecid = GF_CODECID_MPEG4_PART2;", "PL_ID = 0x01;", "break;", "case GF_ISOM_SUBTYPE_3GP_AMR:", "required_rate = 8000;", "hintType = GF_RTP_PAYT_AMR;", "streamType = GF_STREAM_AUDIO;", "has_mpeg4_mapping = 0;", "nb_ch = 1;", "break;", "case GF_ISOM_SUBTYPE_3GP_AMR_WB:", "required_rate = 16000;", "hintType = GF_RTP_PAYT_AMR_WB;", "streamType = GF_STREAM_AUDIO;", "has_mpeg4_mapping = 0;", "nb_ch = 1;", "break;", "case GF_ISOM_SUBTYPE_AVC_H264:", "case GF_ISOM_SUBTYPE_AVC2_H264:", "case GF_ISOM_SUBTYPE_AVC3_H264:", "case GF_ISOM_SUBTYPE_AVC4_H264:", "case GF_ISOM_SUBTYPE_SVC_H264:", "case GF_ISOM_SUBTYPE_MVC_H264:", "{", "GF_AVCConfig *avcc = gf_isom_avc_config_get(file, TrackNum, 1);", "GF_AVCConfig *svcc = gf_isom_svc_config_get(file, TrackNum, 1);", "GF_AVCConfig *mvcc = gf_isom_mvc_config_get(file, TrackNum, 1);", "if (!avcc && !svcc && !mvcc) {", "*e = GF_NON_COMPLIANT_BITSTREAM;", "return NULL;", "}", "required_rate = 90000;", "hintType = GF_RTP_PAYT_H264_AVC;", "if (TrackMediaSubType==GF_ISOM_SUBTYPE_SVC_H264)", "hintType = GF_RTP_PAYT_H264_SVC;", "else if (TrackMediaSubType==GF_ISOM_SUBTYPE_MVC_H264)", "hintType = GF_RTP_PAYT_H264_SVC;", "streamType = GF_STREAM_VISUAL;", "avc_nalu_size = avcc ? avcc->nal_unit_size : svcc ? svcc->nal_unit_size : mvcc->nal_unit_size;", "codecid = GF_CODECID_AVC;", "PL_ID = 0x0F;", "gf_odf_avc_cfg_del(avcc);", "gf_odf_avc_cfg_del(svcc);", "}", "break;", "case GF_ISOM_SUBTYPE_HVC1:", "case GF_ISOM_SUBTYPE_HEV1:", "case GF_ISOM_SUBTYPE_HVC2:", "case GF_ISOM_SUBTYPE_HEV2:", "{", "GF_HEVCConfig *hevcc = gf_isom_hevc_config_get(file, TrackNum, 1);", "if (!hevcc) {", "*e = GF_NON_COMPLIANT_BITSTREAM;", "return NULL;", "}", "required_rate = 90000;", "hintType = GF_RTP_PAYT_HEVC;", "streamType = GF_STREAM_VISUAL;", "avc_nalu_size = hevcc->nal_unit_size;", "codecid = GF_CODECID_HEVC;", "PL_ID = 0x0F;", "flags |= GP_RTP_PCK_USE_MULTI;", "gf_odf_hevc_cfg_del(hevcc);", "break;", "}", "break;", "case GF_ISOM_SUBTYPE_3GP_QCELP:", "required_rate = 8000;", "hintType = GF_RTP_PAYT_QCELP;", "streamType = GF_STREAM_AUDIO;", "codecid = GF_CODECID_QCELP;", "OfficialPayloadID = 12;", "nb_ch = 1;", "break;", "case GF_ISOM_SUBTYPE_3GP_EVRC:", "case GF_ISOM_SUBTYPE_3GP_SMV:", "required_rate = 8000;", "hintType = GF_RTP_PAYT_EVRC_SMV;", "streamType = GF_STREAM_AUDIO;", "codecid = (TrackMediaSubType==GF_ISOM_SUBTYPE_3GP_EVRC) ? GF_CODECID_EVRC : GF_CODECID_SMV;", "nb_ch = 1;", "break;", "case GF_ISOM_SUBTYPE_3GP_DIMS:", "#if GPAC_ENABLE_3GPP_DIMS_RTP", "hintType = GF_RTP_PAYT_3GPP_DIMS;", "streamType = GF_STREAM_SCENE;", "#else", "hintType = 0;", "GF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[RTP Packetizer] 3GPP DIMS over RTP disabled in build\\n\", streamType));", "#endif", "break;", "case GF_ISOM_SUBTYPE_AC3:", "hintType = GF_RTP_PAYT_AC3;", "streamType = GF_STREAM_AUDIO;", "gf_isom_get_audio_info(file, TrackNum, 1, NULL, &nb_ch, NULL);", "break;", "case GF_ISOM_SUBTYPE_MP3:", "{", "GF_ISOSample *samp = gf_isom_get_sample(file, TrackNum, 1, NULL);", "if (samp && (samp->dataLength>3)) {", "u32 hdr = GF_4CC((u32)samp->data[0], (u8)samp->data[1], (u8)samp->data[2], (u8)samp->data[3]);", "nb_ch = gf_mp3_num_channels(hdr);", "} else {", "u32 bps;", "gf_isom_get_audio_info(file, TrackNum, 1, &required_rate, &nb_ch, &bps);", "}", "hintType = GF_RTP_PAYT_MPEG12_AUDIO;", "OfficialPayloadID = 14;", "required_rate = 90000;", "if (samp)", "gf_isom_sample_del(&samp);", "}", "break;", "default:", "hintType = 0;", "break;", "}", "}", "if (!hintType) return NULL;", "gf_isom_get_data_reference(file, TrackNum, 1, &url, &urn);", "if (url || urn) return NULL;", "*e = GF_OUT_OF_MEM;", "GF_SAFEALLOC(tmp, GF_RTPHinter);", "if (!tmp) return NULL;", "if (has_mpeg4_mapping && (flags & GP_RTP_PCK_FORCE_MPEG4)) {", "hintType = GF_RTP_PAYT_MPEG4;", "avc_nalu_size = 0;", "}", "else if (OfficialPayloadID && (flags & GP_RTP_PCK_USE_STATIC_ID) ) {", "PayloadID = OfficialPayloadID;", "}", "tmp->file = file;", "tmp->TrackNum = TrackNum;", "tmp->avc_nalu_size = avc_nalu_size;", "tmp->nb_chan = nb_ch;", "tmp->has_ctts = gf_isom_has_time_offset(file, TrackNum);", "gf_media_get_sample_average_infos(file, TrackNum, &MinSize, &MaxSize, &avgTS, &maxDTSDelta, &const_dur, &bandwidth);", "if (flags & GP_RTP_PCK_SYSTEMS_CAROUSEL) {", "flags |= GP_RTP_PCK_SIGNAL_RAP;", "}", "if (flags & GP_RTP_PCK_USE_MULTI) {", "if (MinSize != MaxSize) flags |= GP_RTP_PCK_SIGNAL_SIZE;", "if (!const_dur) flags |= GP_RTP_PCK_SIGNAL_TS;", "}", "if (tmp->has_ctts) flags |= GP_RTP_PCK_SIGNAL_TS;", "InitSL_RTP(&my_sl);", "my_sl.timestampResolution = gf_isom_get_media_timescale(file, TrackNum);", "if (required_rate) {", "Double sc = required_rate;", "sc /= my_sl.timestampResolution;", "maxDTSDelta = (u32) (maxDTSDelta*sc);", "my_sl.timestampResolution = required_rate;", "}", "max_ptime = (u32) (max_ptime * my_sl.timestampResolution / 1000);", "my_sl.AUSeqNumLength = gf_get_bit_size(gf_isom_get_sample_count(file, TrackNum));", "if (my_sl.AUSeqNumLength>16) my_sl.AUSeqNumLength=16;", "my_sl.CUDuration = const_dur;", "if (gf_isom_has_sync_points(file, TrackNum)) {", "my_sl.useRandomAccessPointFlag = 1;", "} else {", "my_sl.useRandomAccessPointFlag = 0;", "my_sl.hasRandomAccessUnitsOnlyFlag = 1;", "}", "if (is_crypted) {", "Bool use_sel_enc;", "gf_isom_get_ismacryp_info(file, TrackNum, 1, NULL, NULL, NULL, NULL, NULL, &use_sel_enc, &IV_length, &KI_length);", "if (use_sel_enc) flags |= GP_RTP_PCK_SELECTIVE_ENCRYPTION;", "}", "tmp->OrigTimeScale = gf_isom_get_media_timescale(file, TrackNum);", "tmp->rtp_p = gf_rtp_builder_new(hintType, &my_sl, flags, tmp,", "MP4T_OnNewPacket, MP4T_OnPacketDone,", "copy_media ? NULL : MP4T_OnDataRef,", "MP4T_OnData);", "gf_rtp_builder_init(tmp->rtp_p, PayloadID, Path_MTU, max_ptime,", "streamType, codecid, PL_ID, MinSize, MaxSize, avgTS, maxDTSDelta, IV_length, KI_length, mpeg4mode);", "if (force_dts_delta) tmp->rtp_p->slMap.DTSDeltaLength = force_dts_delta;", "tmp->TrackID = gf_isom_get_track_id(file, TrackNum);", "tmp->HintID = tmp->TrackID + 65535;", "while (gf_isom_get_track_by_id(file, tmp->HintID)) tmp->HintID++;", "tmp->HintTrack = gf_isom_new_track(file, tmp->HintID, GF_ISOM_MEDIA_HINT, my_sl.timestampResolution);", "gf_isom_setup_hint_track(file, tmp->HintTrack, GF_ISOM_HINT_RTP);", "gf_isom_new_hint_description(file, tmp->HintTrack, -1, -1, 0, &descIndex);", "gf_isom_rtp_set_timescale(file, tmp->HintTrack, descIndex, my_sl.timestampResolution);", "if (hintType==GF_RTP_PAYT_MPEG4) {", "tmp->rtp_p->slMap.CodecID = codecid;", "gf_isom_set_extraction_slc(file, TrackNum, 1, &my_sl);", "}", "tmp->bandwidth = bandwidth;", "gf_isom_set_track_interleaving_group(file, TrackNum, InterleaveGroupID);", "if (!copy_media) {", "gf_isom_set_track_interleaving_group(file, tmp->HintTrack, InterleaveGroupID);", "} else {", "gf_isom_set_track_interleaving_group(file, tmp->HintTrack, InterleaveGroupID + OFFSET_HINT_GROUP_ID);", "}", "InterleaveGroupPriority*=2;", "gf_isom_set_track_priority_in_group(file, TrackNum, InterleaveGroupPriority+1);", "gf_isom_set_track_priority_in_group(file, tmp->HintTrack, InterleaveGroupPriority);", "#if 0", "#endif", "*e = GF_OK;", "return tmp;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["new_fixup(struct archive_write_disk *a, const char *pathname)", "{", "struct fixup_entry *fe;", "fe = (struct fixup_entry *)calloc(1, sizeof(struct fixup_entry));", "if (fe == NULL) {", "archive_set_error(&a->archive, ENOMEM,", "\"Can't allocate memory for a fixup\");", "return (NULL);", "}", "fe->next = a->fixup_list;", "a->fixup_list = fe;", "fe->fixup = 0;", "fe->name = strdup(pathname);", "return (fe);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["disable_priv_mode ()", "{", "int e;", "if (setuid (current_user.uid) < 0)", "{", "e = errno;", "sys_error (_(\"cannot set uid to %d: effective uid %d\"), current_user.uid, current_user.euid);", "#if defined (EXIT_ON_SETUID_FAILURE)", "if (e == EAGAIN)", "exit (e);", "#endif", "}", "if (setgid (current_user.gid) < 0)", "sys_error (_(\"cannot set gid to %d: effective gid %d\"), current_user.gid, current_user.egid);", "current_user.euid = current_user.uid;", "current_user.egid = current_user.gid;", "}"], "ner_tags": [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0]}
{"tokens": ["inline void FurnaceGUI::patternRow(int i, bool isPlaying, float lineHeight, int chans, int ord, const DivPattern** patCache) {", "static char id[32];", "bool selectedRow=(i>=sel1.y && i<=sel2.y);", "ImGui::TableNextRow(0,lineHeight);", "ImGui::TableNextColumn();", "float cursorPosY=ImGui::GetCursorPos().y-ImGui::GetScrollY();", "if (cursorPosY<-lineHeight || cursorPosY>ImGui::GetWindowSize().y) {", "return;", "}", "if (ord<0 || ord>=e->song.ordersLen) {", "return;", "}", "if (i<0 || i>=e->song.patLen) {", "return;", "}", "bool isPushing=false;", "ImVec4 activeColor=uiColors[GUI_COLOR_PATTERN_ACTIVE];", "ImVec4 inactiveColor=uiColors[GUI_COLOR_PATTERN_INACTIVE];", "ImVec4 rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX];", "if (e->song.hilightB>0 && !(i%e->song.hilightB)) {", "activeColor=uiColors[GUI_COLOR_PATTERN_ACTIVE_HI2];", "inactiveColor=uiColors[GUI_COLOR_PATTERN_INACTIVE_HI2];", "rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX_HI2];", "} else if (e->song.hilightA>0 && !(i%e->song.hilightA)) {", "activeColor=uiColors[GUI_COLOR_PATTERN_ACTIVE_HI1];", "inactiveColor=uiColors[GUI_COLOR_PATTERN_INACTIVE_HI1];", "rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX_HI1];", "}", "if (settings.overflowHighlight) {", "if (edit && cursor.y==i) {", "ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_EDITING]));", "} else if (isPlaying && oldRow==i) {", "ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_PLAY_HEAD]));", "} else if (e->song.hilightB>0 && !(i%e->song.hilightB)) {", "ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_2]));", "} else if (e->song.hilightA>0 && !(i%e->song.hilightA)) {", "ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_1]));", "}", "} else {", "isPushing=true;", "if (edit && cursor.y==i) {", "ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_EDITING]));", "} else if (isPlaying && oldRow==i) {", "ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_PLAY_HEAD]));", "} else if (e->song.hilightB>0 && !(i%e->song.hilightB)) {", "ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_2]));", "} else if (e->song.hilightA>0 && !(i%e->song.hilightA)) {", "ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_1]));", "} else {", "isPushing=false;", "}", "}", "if (settings.patRowsBase==1) {", "ImGui::TextColored(rowIndexColor,\" %.2X \",i);", "} else {", "ImGui::TextColored(rowIndexColor,\"%3d \",i);", "}", "for (int j=0; j<chans; j++) {", "if (!e->song.chanShow[j]) {", "patChanX[j]=ImGui::GetCursorPosX();", "continue;", "}", "int chanVolMax=e->getMaxVolumeChan(j);", "if (chanVolMax<1) chanVolMax=1;", "const DivPattern* pat=patCache[j];", "ImGui::TableNextColumn();", "patChanX[j]=ImGui::GetCursorPosX();", "int sel1XSum=sel1.xCoarse*32+sel1.xFine;", "int sel2XSum=sel2.xCoarse*32+sel2.xFine;", "int j32=j*32;", "bool selectedNote=selectedRow && (j32>=sel1XSum && j32<=sel2XSum);", "bool selectedIns=selectedRow && (j32+1>=sel1XSum && j32+1<=sel2XSum);", "bool selectedVol=selectedRow && (j32+2>=sel1XSum && j32+2<=sel2XSum);", "bool cursorNote=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==0);", "bool cursorIns=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==1);", "bool cursorVol=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==2);", "sprintf(id,\"%s##PN_%d_%d\",noteName(pat->data[i][0],pat->data[i][1]),i,j);", "if (pat->data[i][0]==0 && pat->data[i][1]==0) {", "ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);", "} else {", "ImGui::PushStyleColor(ImGuiCol_Text,activeColor);", "}", "if (cursorNote) {", "ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);", "ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);", "ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);", "ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,threeChars);", "demandX=ImGui::GetCursorPosX();", "ImGui::PopStyleColor(3);", "} else {", "if (selectedNote) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);", "ImGui::Selectable(id,isPushing || selectedNote,ImGuiSelectableFlags_NoPadWithHalfSpacing,threeChars);", "if (selectedNote) ImGui::PopStyleColor();", "}", "if (ImGui::IsItemClicked()) {", "startSelection(j,0,i);", "}", "if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {", "updateSelection(j,0,i);", "}", "ImGui::PopStyleColor();", "if (!e->song.chanCollapse[j]) {", "if (pat->data[i][2]==-1) {", "ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);", "sprintf(id,\"..##PI_%d_%d\",i,j);", "} else {", "if (pat->data[i][2]<0 || pat->data[i][2]>=e->song.insLen) {", "ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_INS_ERROR]);", "} else {", "DivInstrumentType t=e->song.ins[pat->data[i][2]]->type;", "if (t!=DIV_INS_AMIGA && t!=e->getPreferInsType(j)) {", "ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_INS_WARN]);", "} else {", "ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_INS]);", "}", "}", "sprintf(id,\"%.2X##PI_%d_%d\",pat->data[i][2],i,j);", "}", "ImGui::SameLine(0.0f,0.0f);", "if (cursorIns) {", "ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);", "ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);", "ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);", "ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);", "demandX=ImGui::GetCursorPosX();", "ImGui::PopStyleColor(3);", "} else {", "if (selectedIns) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);", "ImGui::Selectable(id,isPushing || selectedIns,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);", "if (selectedIns) ImGui::PopStyleColor();", "}", "if (ImGui::IsItemClicked()) {", "startSelection(j,1,i);", "}", "if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {", "updateSelection(j,1,i);", "}", "ImGui::PopStyleColor();", "if (pat->data[i][3]==-1) {", "sprintf(id,\"..##PV_%d_%d\",i,j);", "ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);", "} else {", "int volColor=(pat->data[i][3]*127)/chanVolMax;", "if (volColor>127) volColor=127;", "if (volColor<0) volColor=0;", "sprintf(id,\"%.2X##PV_%d_%d\",pat->data[i][3],i,j);", "ImGui::PushStyleColor(ImGuiCol_Text,volColors[volColor]);", "}", "ImGui::SameLine(0.0f,0.0f);", "if (cursorVol) {", "ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);", "ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);", "ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);", "ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);", "demandX=ImGui::GetCursorPosX();", "ImGui::PopStyleColor(3);", "} else {", "if (selectedVol) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);", "ImGui::Selectable(id,isPushing || selectedVol,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);", "if (selectedVol) ImGui::PopStyleColor();", "}", "if (ImGui::IsItemClicked()) {", "startSelection(j,2,i);", "}", "if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {", "updateSelection(j,2,i);", "}", "ImGui::PopStyleColor();", "for (int k=0; k<e->song.pat[j].effectRows; k++) {", "int index=4+(k<<1);", "bool selectedEffect=selectedRow && (j32+index-1>=sel1XSum && j32+index-1<=sel2XSum);", "bool selectedEffectVal=selectedRow && (j32+index>=sel1XSum && j32+index<=sel2XSum);", "bool cursorEffect=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==index-1);", "bool cursorEffectVal=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==index);", "if (pat->data[i][index]==-1) {", "sprintf(id,\"..##PE%d_%d_%d\",k,i,j);", "ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);", "} else {", "sprintf(id,\"%.2X##PE%d_%d_%d\",pat->data[i][index],k,i,j);", "if (pat->data[i][index]<0x10) {", "ImGui::PushStyleColor(ImGuiCol_Text,uiColors[fxColors[pat->data[i][index]]]);", "} else if (pat->data[i][index]<0x20) {", "ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);", "} else if (pat->data[i][index]<0x30) {", "ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_SECONDARY]);", "} else if (pat->data[i][index]<0x48) {", "ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);", "} else if (pat->data[i][index]<0x90) {", "ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);", "} else if (pat->data[i][index]<0xa0) {", "ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_MISC]);", "} else if (pat->data[i][index]<0xc0) {", "ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);", "} else if (pat->data[i][index]<0xd0) {", "ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SPEED]);", "} else if (pat->data[i][index]<0xe0) {", "ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);", "} else {", "ImGui::PushStyleColor(ImGuiCol_Text,uiColors[extFxColors[pat->data[i][index]-0xe0]]);", "}", "}", "ImGui::SameLine(0.0f,0.0f);", "if (cursorEffect) {", "ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);", "ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);", "ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);", "ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);", "demandX=ImGui::GetCursorPosX();", "ImGui::PopStyleColor(3);", "} else {", "if (selectedEffect) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);", "ImGui::Selectable(id,isPushing || selectedEffect,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);", "if (selectedEffect) ImGui::PopStyleColor();", "}", "if (ImGui::IsItemClicked()) {", "startSelection(j,index-1,i);", "}", "if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {", "updateSelection(j,index-1,i);", "}", "if (pat->data[i][index+1]==-1) {", "sprintf(id,\"..##PF%d_%d_%d\",k,i,j);", "} else {", "sprintf(id,\"%.2X##PF%d_%d_%d\",pat->data[i][index+1],k,i,j);", "}", "ImGui::SameLine(0.0f,0.0f);", "if (cursorEffectVal) {", "ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);", "ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);", "ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);", "ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);", "demandX=ImGui::GetCursorPosX();", "ImGui::PopStyleColor(3);", "} else {", "if (selectedEffectVal) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);", "ImGui::Selectable(id,isPushing || selectedEffectVal,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);", "if (selectedEffectVal) ImGui::PopStyleColor();", "}", "if (ImGui::IsItemClicked()) {", "startSelection(j,index,i);", "}", "if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {", "updateSelection(j,index,i);", "}", "ImGui::PopStyleColor();", "}", "}", "}", "if (isPushing) {", "ImGui::PopStyleColor();", "}", "ImGui::TableNextColumn();", "patChanX[chans]=ImGui::GetCursorPosX();", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["int sqlite3Select(", "Parse *pParse,", "Select *p,", "SelectDest *pDest", "){", "int i, j;", "WhereInfo *pWInfo;", "Vdbe *v;", "int isAgg;", "ExprList *pEList = 0;", "SrcList *pTabList;", "Expr *pWhere;", "ExprList *pGroupBy;", "Expr *pHaving;", "int rc = 1;", "DistinctCtx sDistinct;", "SortCtx sSort;", "AggInfo sAggInfo;", "int iEnd;", "sqlite3 *db;", "ExprList *pMinMaxOrderBy = 0;", "u8 minMaxFlag;", "db = pParse->db;", "v = sqlite3GetVdbe(pParse);", "if( p==0 || db->mallocFailed || pParse->nErr ){", "return 1;", "}", "if( sqlite3AuthCheck(pParse, SQLITE_SELECT, 0, 0, 0) ) return 1;", "memset(&sAggInfo, 0, sizeof(sAggInfo));", "#if SELECTTRACE_ENABLED", "SELECTTRACE(1,pParse,p, (\"begin processing:\\n\", pParse->addrExplain));", "if( sqlite3SelectTrace & 0x100 ){", "sqlite3TreeViewSelect(0, p, 0);", "}", "#endif", "assert( p->pOrderBy==0 || pDest->eDest!=SRT_DistFifo );", "assert( p->pOrderBy==0 || pDest->eDest!=SRT_Fifo );", "assert( p->pOrderBy==0 || pDest->eDest!=SRT_DistQueue );", "assert( p->pOrderBy==0 || pDest->eDest!=SRT_Queue );", "if( IgnorableOrderby(pDest) ){", "assert(pDest->eDest==SRT_Exists || pDest->eDest==SRT_Union ||", "pDest->eDest==SRT_Except || pDest->eDest==SRT_Discard ||", "pDest->eDest==SRT_Queue  || pDest->eDest==SRT_DistFifo ||", "pDest->eDest==SRT_DistQueue || pDest->eDest==SRT_Fifo);", "sqlite3ExprListDelete(db, p->pOrderBy);", "p->pOrderBy = 0;", "p->selFlags &= ~SF_Distinct;", "}", "sqlite3SelectPrep(pParse, p, 0);", "if( pParse->nErr || db->mallocFailed ){", "goto select_end;", "}", "assert( p->pEList!=0 );", "#if SELECTTRACE_ENABLED", "if( sqlite3SelectTrace & 0x104 ){", "SELECTTRACE(0x104,pParse,p, (\"after name resolution:\\n\"));", "sqlite3TreeViewSelect(0, p, 0);", "}", "#endif", "if( pDest->eDest==SRT_Output ){", "generateColumnNames(pParse, p);", "}", "#ifndef SQLITE_OMIT_WINDOWFUNC", "if( sqlite3WindowRewrite(pParse, p) ){", "goto select_end;", "}", "#if SELECTTRACE_ENABLED", "if( p->pWin && (sqlite3SelectTrace & 0x108)!=0 ){", "SELECTTRACE(0x104,pParse,p, (\"after window rewrite:\\n\"));", "sqlite3TreeViewSelect(0, p, 0);", "}", "#endif", "#endif /* SQLITE_OMIT_WINDOWFUNC */", "pTabList = p->pSrc;", "isAgg = (p->selFlags & SF_Aggregate)!=0;", "memset(&sSort, 0, sizeof(sSort));", "sSort.pOrderBy = p->pOrderBy;", "#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)", "for(i=0; !p->pPrior && i<pTabList->nSrc; i++){", "struct SrcList_item *pItem = &pTabList->a[i];", "Select *pSub = pItem->pSelect;", "Table *pTab = pItem->pTab;", "if( (pItem->fg.jointype & JT_LEFT)!=0", "&& sqlite3ExprImpliesNonNullRow(p->pWhere, pItem->iCursor)", "&& OptimizationEnabled(db, SQLITE_SimplifyJoin)", "){", "SELECTTRACE(0x100,pParse,p,", "(\"LEFT-JOIN simplifies to JOIN on term %d\\n\",i));", "pItem->fg.jointype &= ~(JT_LEFT|JT_OUTER);", "unsetJoinExpr(p->pWhere, pItem->iCursor);", "}", "if( pSub==0 ) continue;", "if( pTab->nCol!=pSub->pEList->nExpr ){", "sqlite3ErrorMsg(pParse, \"expected %d columns for '%s' but got %d\",", "pTab->nCol, pTab->zName, pSub->pEList->nExpr);", "goto select_end;", "}", "if( (pSub->selFlags & SF_Aggregate)!=0 ) continue;", "assert( pSub->pGroupBy==0 );", "if( pSub->pOrderBy!=0", "&& i==0", "&& (p->selFlags & SF_ComplexResult)!=0", "&& (pTabList->nSrc==1", "|| (pTabList->a[1].fg.jointype&(JT_LEFT|JT_CROSS))!=0)", "){", "continue;", "}", "if( flattenSubquery(pParse, p, i, isAgg) ){", "if( pParse->nErr ) goto select_end;", "i = -1;", "}", "pTabList = p->pSrc;", "if( db->mallocFailed ) goto select_end;", "if( !IgnorableOrderby(pDest) ){", "sSort.pOrderBy = p->pOrderBy;", "}", "}", "#endif", "#ifndef SQLITE_OMIT_COMPOUND_SELECT", "if( p->pPrior ){", "rc = multiSelect(pParse, p, pDest);", "#if SELECTTRACE_ENABLED", "SELECTTRACE(0x1,pParse,p,(\"end compound-select processing\\n\"));", "if( (sqlite3SelectTrace & 0x2000)!=0 && ExplainQueryPlanParent(pParse)==0 ){", "sqlite3TreeViewSelect(0, p, 0);", "}", "#endif", "if( p->pNext==0 ) ExplainQueryPlanPop(pParse);", "return rc;", "}", "#endif", "if( pTabList->nSrc>1", "&& OptimizationEnabled(db, SQLITE_PropagateConst)", "&& propagateConstants(pParse, p)", "){", "#if SELECTTRACE_ENABLED", "if( sqlite3SelectTrace & 0x100 ){", "SELECTTRACE(0x100,pParse,p,(\"After constant propagation:\\n\"));", "sqlite3TreeViewSelect(0, p, 0);", "}", "#endif", "}else{", "SELECTTRACE(0x100,pParse,p,(\"Constant propagation not helpful\\n\"));", "}", "#ifdef SQLITE_COUNTOFVIEW_OPTIMIZATION", "if( OptimizationEnabled(db, SQLITE_QueryFlattener|SQLITE_CountOfView)", "&& countOfViewOptimization(pParse, p)", "){", "if( db->mallocFailed ) goto select_end;", "pEList = p->pEList;", "pTabList = p->pSrc;", "}", "#endif", "for(i=0; i<pTabList->nSrc; i++){", "struct SrcList_item *pItem = &pTabList->a[i];", "SelectDest dest;", "Select *pSub;", "#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)", "const char *zSavedAuthContext;", "#endif", "if( pItem->colUsed==0 && pItem->zName!=0 ){", "sqlite3AuthCheck(pParse, SQLITE_READ, pItem->zName, \"\", pItem->zDatabase);", "}", "#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)", "pSub = pItem->pSelect;", "if( pSub==0 ) continue;", "testcase( pItem->addrFillSub!=0 );", "pParse->nHeight += sqlite3SelectExprHeight(p);", "if( OptimizationEnabled(db, SQLITE_PushDown)", "&& pushDownWhereTerms(pParse, pSub, p->pWhere, pItem->iCursor,", "(pItem->fg.jointype & JT_OUTER)!=0)", "){", "#if SELECTTRACE_ENABLED", "if( sqlite3SelectTrace & 0x100 ){", "SELECTTRACE(0x100,pParse,p,", "(\"After WHERE-clause push-down into subquery %d:\\n\", pSub->selId));", "sqlite3TreeViewSelect(0, p, 0);", "}", "#endif", "}else{", "SELECTTRACE(0x100,pParse,p,(\"Push-down not possible\\n\"));", "}", "zSavedAuthContext = pParse->zAuthContext;", "pParse->zAuthContext = pItem->zName;", "if( i==0", "&& (pTabList->nSrc==1", "|| (pTabList->a[1].fg.jointype&(JT_LEFT|JT_CROSS))!=0)", "){", "int addrTop = sqlite3VdbeCurrentAddr(v)+1;", "pItem->regReturn = ++pParse->nMem;", "sqlite3VdbeAddOp3(v, OP_InitCoroutine, pItem->regReturn, 0, addrTop);", "VdbeComment((v, \"%s\", pItem->pTab->zName));", "pItem->addrFillSub = addrTop;", "sqlite3SelectDestInit(&dest, SRT_Coroutine, pItem->regReturn);", "ExplainQueryPlan((pParse, 1, \"CO-ROUTINE %u\", pSub->selId));", "sqlite3Select(pParse, pSub, &dest);", "pItem->pTab->nRowLogEst = pSub->nSelectRow;", "pItem->fg.viaCoroutine = 1;", "pItem->regResult = dest.iSdst;", "sqlite3VdbeEndCoroutine(v, pItem->regReturn);", "sqlite3VdbeJumpHere(v, addrTop-1);", "sqlite3ClearTempRegCache(pParse);", "}else{", "int topAddr;", "int onceAddr = 0;", "int retAddr;", "struct SrcList_item *pPrior;", "testcase( pItem->addrFillSub==0 );", "pItem->regReturn = ++pParse->nMem;", "topAddr = sqlite3VdbeAddOp2(v, OP_Integer, 0, pItem->regReturn);", "pItem->addrFillSub = topAddr+1;", "if( pItem->fg.isCorrelated==0 ){", "onceAddr = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);", "VdbeComment((v, \"materialize \\\"%s\\\"\", pItem->pTab->zName));", "}else{", "VdbeNoopComment((v, \"materialize \\\"%s\\\"\", pItem->pTab->zName));", "}", "pPrior = isSelfJoinView(pTabList, pItem);", "if( pPrior ){", "sqlite3VdbeAddOp2(v, OP_OpenDup, pItem->iCursor, pPrior->iCursor);", "assert( pPrior->pSelect!=0 );", "pSub->nSelectRow = pPrior->pSelect->nSelectRow;", "}else{", "sqlite3SelectDestInit(&dest, SRT_EphemTab, pItem->iCursor);", "ExplainQueryPlan((pParse, 1, \"MATERIALIZE %u\", pSub->selId));", "sqlite3Select(pParse, pSub, &dest);", "}", "pItem->pTab->nRowLogEst = pSub->nSelectRow;", "if( onceAddr ) sqlite3VdbeJumpHere(v, onceAddr);", "retAddr = sqlite3VdbeAddOp1(v, OP_Return, pItem->regReturn);", "VdbeComment((v, \"end %s\", pItem->pTab->zName));", "sqlite3VdbeChangeP1(v, topAddr, retAddr);", "sqlite3ClearTempRegCache(pParse);", "}", "if( db->mallocFailed ) goto select_end;", "pParse->nHeight -= sqlite3SelectExprHeight(p);", "pParse->zAuthContext = zSavedAuthContext;", "#endif", "}", "pEList = p->pEList;", "pWhere = p->pWhere;", "pGroupBy = p->pGroupBy;", "pHaving = p->pHaving;", "sDistinct.isTnct = (p->selFlags & SF_Distinct)!=0;", "#if SELECTTRACE_ENABLED", "if( sqlite3SelectTrace & 0x400 ){", "SELECTTRACE(0x400,pParse,p,(\"After all FROM-clause analysis:\\n\"));", "sqlite3TreeViewSelect(0, p, 0);", "}", "#endif", "if( (p->selFlags & (SF_Distinct|SF_Aggregate))==SF_Distinct", "&& sqlite3ExprListCompare(sSort.pOrderBy, pEList, -1)==0", "){", "p->selFlags &= ~SF_Distinct;", "pGroupBy = p->pGroupBy = sqlite3ExprListDup(db, pEList, 0);", "assert( sDistinct.isTnct );", "#if SELECTTRACE_ENABLED", "if( sqlite3SelectTrace & 0x400 ){", "SELECTTRACE(0x400,pParse,p,(\"Transform DISTINCT into GROUP BY:\\n\"));", "sqlite3TreeViewSelect(0, p, 0);", "}", "#endif", "}", "if( sSort.pOrderBy ){", "KeyInfo *pKeyInfo;", "pKeyInfo = sqlite3KeyInfoFromExprList(", "pParse, sSort.pOrderBy, 0, pEList->nExpr);", "sSort.iECursor = pParse->nTab++;", "sSort.addrSortIndex =", "sqlite3VdbeAddOp4(v, OP_OpenEphemeral,", "sSort.iECursor, sSort.pOrderBy->nExpr+1+pEList->nExpr, 0,", "(char*)pKeyInfo, P4_KEYINFO", ");", "}else{", "sSort.addrSortIndex = -1;", "}", "if( pDest->eDest==SRT_EphemTab ){", "sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pDest->iSDParm, pEList->nExpr);", "}", "iEnd = sqlite3VdbeMakeLabel(pParse);", "if( (p->selFlags & SF_FixedLimit)==0 ){", "p->nSelectRow = 320;", "}", "computeLimitRegisters(pParse, p, iEnd);", "if( p->iLimit==0 && sSort.addrSortIndex>=0 ){", "sqlite3VdbeChangeOpcode(v, sSort.addrSortIndex, OP_SorterOpen);", "sSort.sortFlags |= SORTFLAG_UseSorter;", "}", "if( p->selFlags & SF_Distinct ){", "sDistinct.tabTnct = pParse->nTab++;", "sDistinct.addrTnct = sqlite3VdbeAddOp4(v, OP_OpenEphemeral,", "sDistinct.tabTnct, 0, 0,", "(char*)sqlite3KeyInfoFromExprList(pParse, p->pEList,0,0),", "P4_KEYINFO);", "sqlite3VdbeChangeP5(v, BTREE_UNORDERED);", "sDistinct.eTnctType = WHERE_DISTINCT_UNORDERED;", "}else{", "sDistinct.eTnctType = WHERE_DISTINCT_NOOP;", "}", "if( !isAgg && pGroupBy==0 ){", "u16 wctrlFlags = (sDistinct.isTnct ? WHERE_WANT_DISTINCT : 0)", "| (p->selFlags & SF_FixedLimit);", "#ifndef SQLITE_OMIT_WINDOWFUNC", "Window *pWin = p->pWin;", "if( pWin ){", "sqlite3WindowCodeInit(pParse, pWin);", "}", "#endif", "assert( WHERE_USE_LIMIT==SF_FixedLimit );", "SELECTTRACE(1,pParse,p,(\"WhereBegin\\n\"));", "pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, sSort.pOrderBy,", "p->pEList, wctrlFlags, p->nSelectRow);", "if( pWInfo==0 ) goto select_end;", "if( sqlite3WhereOutputRowCount(pWInfo) < p->nSelectRow ){", "p->nSelectRow = sqlite3WhereOutputRowCount(pWInfo);", "}", "if( sDistinct.isTnct && sqlite3WhereIsDistinct(pWInfo) ){", "sDistinct.eTnctType = sqlite3WhereIsDistinct(pWInfo);", "}", "if( sSort.pOrderBy ){", "sSort.nOBSat = sqlite3WhereIsOrdered(pWInfo);", "sSort.labelOBLopt = sqlite3WhereOrderByLimitOptLabel(pWInfo);", "if( sSort.nOBSat==sSort.pOrderBy->nExpr ){", "sSort.pOrderBy = 0;", "}", "}", "if( sSort.addrSortIndex>=0 && sSort.pOrderBy==0 ){", "sqlite3VdbeChangeToNoop(v, sSort.addrSortIndex);", "}", "assert( p->pEList==pEList );", "#ifndef SQLITE_OMIT_WINDOWFUNC", "if( pWin ){", "int addrGosub = sqlite3VdbeMakeLabel(pParse);", "int iCont = sqlite3VdbeMakeLabel(pParse);", "int iBreak = sqlite3VdbeMakeLabel(pParse);", "int regGosub = ++pParse->nMem;", "sqlite3WindowCodeStep(pParse, p, pWInfo, regGosub, addrGosub);", "sqlite3VdbeAddOp2(v, OP_Goto, 0, iBreak);", "sqlite3VdbeResolveLabel(v, addrGosub);", "VdbeNoopComment((v, \"inner-loop subroutine\"));", "sSort.labelOBLopt = 0;", "selectInnerLoop(pParse, p, -1, &sSort, &sDistinct, pDest, iCont, iBreak);", "sqlite3VdbeResolveLabel(v, iCont);", "sqlite3VdbeAddOp1(v, OP_Return, regGosub);", "VdbeComment((v, \"end inner-loop subroutine\"));", "sqlite3VdbeResolveLabel(v, iBreak);", "}else", "#endif /* SQLITE_OMIT_WINDOWFUNC */", "{", "selectInnerLoop(pParse, p, -1, &sSort, &sDistinct, pDest,", "sqlite3WhereContinueLabel(pWInfo),", "sqlite3WhereBreakLabel(pWInfo));", "sqlite3WhereEnd(pWInfo);", "}", "}else{", "NameContext sNC;", "int iAMem;", "int iBMem;", "int iUseFlag;", "int iAbortFlag;", "int groupBySort;", "int addrEnd;", "int sortPTab = 0;", "int sortOut = 0;", "int orderByGrp = 0;", "if( pGroupBy ){", "int k;", "struct ExprList_item *pItem;", "for(k=p->pEList->nExpr, pItem=p->pEList->a; k>0; k--, pItem++){", "pItem->u.x.iAlias = 0;", "}", "for(k=pGroupBy->nExpr, pItem=pGroupBy->a; k>0; k--, pItem++){", "pItem->u.x.iAlias = 0;", "}", "assert( 66==sqlite3LogEst(100) );", "if( p->nSelectRow>66 ) p->nSelectRow = 66;", "if( sSort.pOrderBy && pGroupBy->nExpr==sSort.pOrderBy->nExpr ){", "int ii;", "for(ii=0; ii<pGroupBy->nExpr; ii++){", "u8 sortFlags = sSort.pOrderBy->a[ii].sortFlags & KEYINFO_ORDER_DESC;", "pGroupBy->a[ii].sortFlags = sortFlags;", "}", "if( sqlite3ExprListCompare(pGroupBy, sSort.pOrderBy, -1)==0 ){", "orderByGrp = 1;", "}", "}", "}else{", "assert( 0==sqlite3LogEst(1) );", "p->nSelectRow = 0;", "}", "addrEnd = sqlite3VdbeMakeLabel(pParse);", "memset(&sNC, 0, sizeof(sNC));", "sNC.pParse = pParse;", "sNC.pSrcList = pTabList;", "sNC.uNC.pAggInfo = &sAggInfo;", "VVA_ONLY( sNC.ncFlags = NC_UAggInfo; )", "sAggInfo.mnReg = pParse->nMem+1;", "sAggInfo.nSortingColumn = pGroupBy ? pGroupBy->nExpr : 0;", "sAggInfo.pGroupBy = pGroupBy;", "sqlite3ExprAnalyzeAggList(&sNC, pEList);", "sqlite3ExprAnalyzeAggList(&sNC, sSort.pOrderBy);", "if( pHaving ){", "if( pGroupBy ){", "assert( pWhere==p->pWhere );", "assert( pHaving==p->pHaving );", "assert( pGroupBy==p->pGroupBy );", "havingToWhere(pParse, p);", "pWhere = p->pWhere;", "}", "sqlite3ExprAnalyzeAggregates(&sNC, pHaving);", "}", "sAggInfo.nAccumulator = sAggInfo.nColumn;", "if( p->pGroupBy==0 && p->pHaving==0 && sAggInfo.nFunc==1 ){", "minMaxFlag = minMaxQuery(db, sAggInfo.aFunc[0].pExpr, &pMinMaxOrderBy);", "}else{", "minMaxFlag = WHERE_ORDERBY_NORMAL;", "}", "for(i=0; i<sAggInfo.nFunc; i++){", "Expr *pExpr = sAggInfo.aFunc[i].pExpr;", "assert( !ExprHasProperty(pExpr, EP_xIsSelect) );", "sNC.ncFlags |= NC_InAggFunc;", "sqlite3ExprAnalyzeAggList(&sNC, pExpr->x.pList);", "#ifndef SQLITE_OMIT_WINDOWFUNC", "assert( !IsWindowFunc(pExpr) );", "if( ExprHasProperty(pExpr, EP_WinFunc) ){", "sqlite3ExprAnalyzeAggregates(&sNC, pExpr->y.pWin->pFilter);", "}", "#endif", "sNC.ncFlags &= ~NC_InAggFunc;", "}", "sAggInfo.mxReg = pParse->nMem;", "if( db->mallocFailed ) goto select_end;", "#if SELECTTRACE_ENABLED", "if( sqlite3SelectTrace & 0x400 ){", "int ii;", "SELECTTRACE(0x400,pParse,p,(\"After aggregate analysis:\\n\"));", "sqlite3TreeViewSelect(0, p, 0);", "for(ii=0; ii<sAggInfo.nColumn; ii++){", "sqlite3DebugPrintf(\"agg-column[%d] iMem=%d\\n\",", "ii, sAggInfo.aCol[ii].iMem);", "sqlite3TreeViewExpr(0, sAggInfo.aCol[ii].pExpr, 0);", "}", "for(ii=0; ii<sAggInfo.nFunc; ii++){", "sqlite3DebugPrintf(\"agg-func[%d]: iMem=%d\\n\",", "ii, sAggInfo.aFunc[ii].iMem);", "sqlite3TreeViewExpr(0, sAggInfo.aFunc[ii].pExpr, 0);", "}", "}", "#endif", "if( pGroupBy ){", "KeyInfo *pKeyInfo;", "int addr1;", "int addrOutputRow;", "int regOutputRow;", "int addrSetAbort;", "int addrTopOfLoop;", "int addrSortingIdx;", "int addrReset;", "int regReset;", "sAggInfo.sortingIdx = pParse->nTab++;", "pKeyInfo = sqlite3KeyInfoFromExprList(pParse,pGroupBy,0,sAggInfo.nColumn);", "addrSortingIdx = sqlite3VdbeAddOp4(v, OP_SorterOpen,", "sAggInfo.sortingIdx, sAggInfo.nSortingColumn,", "0, (char*)pKeyInfo, P4_KEYINFO);", "iUseFlag = ++pParse->nMem;", "iAbortFlag = ++pParse->nMem;", "regOutputRow = ++pParse->nMem;", "addrOutputRow = sqlite3VdbeMakeLabel(pParse);", "regReset = ++pParse->nMem;", "addrReset = sqlite3VdbeMakeLabel(pParse);", "iAMem = pParse->nMem + 1;", "pParse->nMem += pGroupBy->nExpr;", "iBMem = pParse->nMem + 1;", "pParse->nMem += pGroupBy->nExpr;", "sqlite3VdbeAddOp2(v, OP_Integer, 0, iAbortFlag);", "VdbeComment((v, \"clear abort flag\"));", "sqlite3VdbeAddOp3(v, OP_Null, 0, iAMem, iAMem+pGroupBy->nExpr-1);", "sqlite3VdbeAddOp2(v, OP_Gosub, regReset, addrReset);", "SELECTTRACE(1,pParse,p,(\"WhereBegin\\n\"));", "pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pGroupBy, 0,", "WHERE_GROUPBY | (orderByGrp ? WHERE_SORTBYGROUP : 0), 0", ");", "if( pWInfo==0 ) goto select_end;", "if( sqlite3WhereIsOrdered(pWInfo)==pGroupBy->nExpr ){", "groupBySort = 0;", "}else{", "int regBase;", "int regRecord;", "int nCol;", "int nGroupBy;", "explainTempTable(pParse,", "(sDistinct.isTnct && (p->selFlags&SF_Distinct)==0) ?", "\"DISTINCT\" : \"GROUP BY\");", "groupBySort = 1;", "nGroupBy = pGroupBy->nExpr;", "nCol = nGroupBy;", "j = nGroupBy;", "for(i=0; i<sAggInfo.nColumn; i++){", "if( sAggInfo.aCol[i].iSorterColumn>=j ){", "nCol++;", "j++;", "}", "}", "regBase = sqlite3GetTempRange(pParse, nCol);", "sqlite3ExprCodeExprList(pParse, pGroupBy, regBase, 0, 0);", "j = nGroupBy;", "for(i=0; i<sAggInfo.nColumn; i++){", "struct AggInfo_col *pCol = &sAggInfo.aCol[i];", "if( pCol->iSorterColumn>=j ){", "int r1 = j + regBase;", "sqlite3ExprCodeGetColumnOfTable(v,", "pCol->pTab, pCol->iTable, pCol->iColumn, r1);", "j++;", "}", "}", "regRecord = sqlite3GetTempReg(pParse);", "sqlite3VdbeAddOp3(v, OP_MakeRecord, regBase, nCol, regRecord);", "sqlite3VdbeAddOp2(v, OP_SorterInsert, sAggInfo.sortingIdx, regRecord);", "sqlite3ReleaseTempReg(pParse, regRecord);", "sqlite3ReleaseTempRange(pParse, regBase, nCol);", "sqlite3WhereEnd(pWInfo);", "sAggInfo.sortingIdxPTab = sortPTab = pParse->nTab++;", "sortOut = sqlite3GetTempReg(pParse);", "sqlite3VdbeAddOp3(v, OP_OpenPseudo, sortPTab, sortOut, nCol);", "sqlite3VdbeAddOp2(v, OP_SorterSort, sAggInfo.sortingIdx, addrEnd);", "VdbeComment((v, \"GROUP BY sort\")); VdbeCoverage(v);", "sAggInfo.useSortingIdx = 1;", "}", "if( orderByGrp && OptimizationEnabled(db, SQLITE_GroupByOrder)", "&& (groupBySort || sqlite3WhereIsSorted(pWInfo))", "){", "sSort.pOrderBy = 0;", "sqlite3VdbeChangeToNoop(v, sSort.addrSortIndex);", "}", "addrTopOfLoop = sqlite3VdbeCurrentAddr(v);", "if( groupBySort ){", "sqlite3VdbeAddOp3(v, OP_SorterData, sAggInfo.sortingIdx,", "sortOut, sortPTab);", "}", "for(j=0; j<pGroupBy->nExpr; j++){", "if( groupBySort ){", "sqlite3VdbeAddOp3(v, OP_Column, sortPTab, j, iBMem+j);", "}else{", "sAggInfo.directMode = 1;", "sqlite3ExprCode(pParse, pGroupBy->a[j].pExpr, iBMem+j);", "}", "}", "sqlite3VdbeAddOp4(v, OP_Compare, iAMem, iBMem, pGroupBy->nExpr,", "(char*)sqlite3KeyInfoRef(pKeyInfo), P4_KEYINFO);", "addr1 = sqlite3VdbeCurrentAddr(v);", "sqlite3VdbeAddOp3(v, OP_Jump, addr1+1, 0, addr1+1); VdbeCoverage(v);", "sqlite3ExprCodeMove(pParse, iBMem, iAMem, pGroupBy->nExpr);", "sqlite3VdbeAddOp2(v, OP_Gosub, regOutputRow, addrOutputRow);", "VdbeComment((v, \"output one row\"));", "sqlite3VdbeAddOp2(v, OP_IfPos, iAbortFlag, addrEnd); VdbeCoverage(v);", "VdbeComment((v, \"check abort flag\"));", "sqlite3VdbeAddOp2(v, OP_Gosub, regReset, addrReset);", "VdbeComment((v, \"reset accumulator\"));", "sqlite3VdbeJumpHere(v, addr1);", "updateAccumulator(pParse, iUseFlag, &sAggInfo);", "sqlite3VdbeAddOp2(v, OP_Integer, 1, iUseFlag);", "VdbeComment((v, \"indicate data in accumulator\"));", "if( groupBySort ){", "sqlite3VdbeAddOp2(v, OP_SorterNext, sAggInfo.sortingIdx, addrTopOfLoop);", "VdbeCoverage(v);", "}else{", "sqlite3WhereEnd(pWInfo);", "sqlite3VdbeChangeToNoop(v, addrSortingIdx);", "}", "sqlite3VdbeAddOp2(v, OP_Gosub, regOutputRow, addrOutputRow);", "VdbeComment((v, \"output final row\"));", "sqlite3VdbeGoto(v, addrEnd);", "addrSetAbort = sqlite3VdbeCurrentAddr(v);", "sqlite3VdbeAddOp2(v, OP_Integer, 1, iAbortFlag);", "VdbeComment((v, \"set abort flag\"));", "sqlite3VdbeAddOp1(v, OP_Return, regOutputRow);", "sqlite3VdbeResolveLabel(v, addrOutputRow);", "addrOutputRow = sqlite3VdbeCurrentAddr(v);", "sqlite3VdbeAddOp2(v, OP_IfPos, iUseFlag, addrOutputRow+2);", "VdbeCoverage(v);", "VdbeComment((v, \"Groupby result generator entry point\"));", "sqlite3VdbeAddOp1(v, OP_Return, regOutputRow);", "finalizeAggFunctions(pParse, &sAggInfo);", "sqlite3ExprIfFalse(pParse, pHaving, addrOutputRow+1, SQLITE_JUMPIFNULL);", "selectInnerLoop(pParse, p, -1, &sSort,", "&sDistinct, pDest,", "addrOutputRow+1, addrSetAbort);", "sqlite3VdbeAddOp1(v, OP_Return, regOutputRow);", "VdbeComment((v, \"end groupby result generator\"));", "sqlite3VdbeResolveLabel(v, addrReset);", "resetAccumulator(pParse, &sAggInfo);", "sqlite3VdbeAddOp2(v, OP_Integer, 0, iUseFlag);", "VdbeComment((v, \"indicate accumulator empty\"));", "sqlite3VdbeAddOp1(v, OP_Return, regReset);", "}", "else {", "#ifndef SQLITE_OMIT_BTREECOUNT", "Table *pTab;", "if( (pTab = isSimpleCount(p, &sAggInfo))!=0 ){", "const int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);", "const int iCsr = pParse->nTab++;", "Index *pIdx;", "KeyInfo *pKeyInfo = 0;", "Index *pBest = 0;", "int iRoot = pTab->tnum;", "sqlite3CodeVerifySchema(pParse, iDb);", "sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);", "if( !HasRowid(pTab) ) pBest = sqlite3PrimaryKeyIndex(pTab);", "for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){", "if( pIdx->bUnordered==0", "&& pIdx->szIdxRow<pTab->szTabRow", "&& pIdx->pPartIdxWhere==0", "&& (!pBest || pIdx->szIdxRow<pBest->szIdxRow)", "){", "pBest = pIdx;", "}", "}", "if( pBest ){", "iRoot = pBest->tnum;", "pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pBest);", "}", "sqlite3VdbeAddOp4Int(v, OP_OpenRead, iCsr, iRoot, iDb, 1);", "if( pKeyInfo ){", "sqlite3VdbeChangeP4(v, -1, (char *)pKeyInfo, P4_KEYINFO);", "}", "sqlite3VdbeAddOp2(v, OP_Count, iCsr, sAggInfo.aFunc[0].iMem);", "sqlite3VdbeAddOp1(v, OP_Close, iCsr);", "explainSimpleCount(pParse, pTab, pBest);", "}else", "#endif /* SQLITE_OMIT_BTREECOUNT */", "{", "int regAcc = 0;", "if( sAggInfo.nAccumulator ){", "for(i=0; i<sAggInfo.nFunc; i++){", "if( ExprHasProperty(sAggInfo.aFunc[i].pExpr, EP_WinFunc) ) continue;", "if( sAggInfo.aFunc[i].pFunc->funcFlags&SQLITE_FUNC_NEEDCOLL ) break;", "}", "if( i==sAggInfo.nFunc ){", "regAcc = ++pParse->nMem;", "sqlite3VdbeAddOp2(v, OP_Integer, 0, regAcc);", "}", "}", "assert( p->pGroupBy==0 );", "resetAccumulator(pParse, &sAggInfo);", "assert( minMaxFlag==WHERE_ORDERBY_NORMAL || pMinMaxOrderBy!=0 );", "assert( pMinMaxOrderBy==0 || pMinMaxOrderBy->nExpr==1 );", "SELECTTRACE(1,pParse,p,(\"WhereBegin\\n\"));", "pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pMinMaxOrderBy,", "0, minMaxFlag, 0);", "if( pWInfo==0 ){", "goto select_end;", "}", "updateAccumulator(pParse, regAcc, &sAggInfo);", "if( regAcc ) sqlite3VdbeAddOp2(v, OP_Integer, 1, regAcc);", "if( sqlite3WhereIsOrdered(pWInfo)>0 ){", "sqlite3VdbeGoto(v, sqlite3WhereBreakLabel(pWInfo));", "VdbeComment((v, \"%s() by index\",", "(minMaxFlag==WHERE_ORDERBY_MIN?\"min\":\"max\")));", "}", "sqlite3WhereEnd(pWInfo);", "finalizeAggFunctions(pParse, &sAggInfo);", "}", "sSort.pOrderBy = 0;", "sqlite3ExprIfFalse(pParse, pHaving, addrEnd, SQLITE_JUMPIFNULL);", "selectInnerLoop(pParse, p, -1, 0, 0,", "pDest, addrEnd, addrEnd);", "}", "sqlite3VdbeResolveLabel(v, addrEnd);", "}", "if( sDistinct.eTnctType==WHERE_DISTINCT_UNORDERED ){", "explainTempTable(pParse, \"DISTINCT\");", "}", "if( sSort.pOrderBy ){", "explainTempTable(pParse,", "sSort.nOBSat>0 ? \"RIGHT PART OF ORDER BY\":\"ORDER BY\");", "assert( p->pEList==pEList );", "generateSortTail(pParse, p, &sSort, pEList->nExpr, pDest);", "}", "sqlite3VdbeResolveLabel(v, iEnd);", "rc = (pParse->nErr>0);", "select_end:", "sqlite3ExprListDelete(db, pMinMaxOrderBy);", "sqlite3DbFree(db, sAggInfo.aCol);", "sqlite3DbFree(db, sAggInfo.aFunc);", "#if SELECTTRACE_ENABLED", "SELECTTRACE(0x1,pParse,p,(\"end processing\\n\"));", "if( (sqlite3SelectTrace & 0x2000)!=0 && ExplainQueryPlanParent(pParse)==0 ){", "sqlite3TreeViewSelect(0, p, 0);", "}", "#endif", "ExplainQueryPlanPop(pParse);", "return rc;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["flac_read_loop (SF_PRIVATE *psf, unsigned len)", "{ FLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;", "pflac->pos = 0 ;", "pflac->len = len ;", "pflac->remain = len ;", "if (pflac->frame != NULL && pflac->bufferpos < pflac->frame->header.blocksize)", "flac_buffer_copy (psf) ;", "while (pflac->pos < pflac->len)", "{ if (FLAC__stream_decoder_process_single (pflac->fsd) == 0)", "break ;", "if (FLAC__stream_decoder_get_state (pflac->fsd) >= FLAC__STREAM_DECODER_END_OF_STREAM)", "break ;", "} ;", "pflac->ptr = NULL ;", "return pflac->pos ;", "}"], "ner_tags": [0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0]}
{"tokens": ["GF_Err Media_RewriteODFrame(GF_MediaBox *mdia, GF_ISOSample *sample)", "{", "GF_Err e;", "GF_ODCodec *ODdecode;", "GF_ODCodec *ODencode;", "GF_ODCom *com;", "GF_ESDUpdate *esdU, *esdU2;", "GF_ESDRemove *esdR, *esdR2;", "GF_ODUpdate *odU, *odU2;", "GF_ObjectDescriptor *od;", "GF_IsomObjectDescriptor *isom_od;", "GF_ESD *esd;", "GF_ES_ID_Ref *ref;", "GF_Descriptor *desc;", "GF_TrackReferenceTypeBox *mpod;", "u32 i, j, skipped;", "if (!mdia || !sample || !sample->data || !sample->dataLength) return GF_BAD_PARAM;", "mpod = NULL;", "e = Track_FindRef(mdia->mediaTrack, GF_ISOM_BOX_TYPE_MPOD, &mpod);", "if (e) return e;", "if (!mpod || !mpod->trackIDs) return GF_OK;", "ODdecode = gf_odf_codec_new();", "if (!ODdecode) return GF_OUT_OF_MEM;", "ODencode = gf_odf_codec_new();", "if (!ODencode) {", "gf_odf_codec_del(ODdecode);", "return GF_OUT_OF_MEM;", "}", "e = gf_odf_codec_set_au(ODdecode, sample->data, sample->dataLength);", "if (e) goto err_exit;", "e = gf_odf_codec_decode(ODdecode);", "if (e) goto err_exit;", "while (1) {", "com = gf_odf_codec_get_com(ODdecode);", "if (!com) break;", "switch (com->tag) {", "case GF_ODF_OD_UPDATE_TAG:", "odU = (GF_ODUpdate *) com;", "odU2 = (GF_ODUpdate *) gf_odf_com_new(GF_ODF_OD_UPDATE_TAG);", "i=0;", "while ((desc = (GF_Descriptor*)gf_list_enum(odU->objectDescriptors, &i))) {", "switch (desc->tag) {", "case GF_ODF_OD_TAG:", "case GF_ODF_ISOM_OD_TAG:", "case GF_ODF_ISOM_IOD_TAG:", "break;", "default:", "return GF_ISOM_INVALID_FILE;", "}", "e = gf_odf_desc_copy(desc, (GF_Descriptor **)&isom_od);", "if (e) goto err_exit;", "if (desc->tag == GF_ODF_ISOM_IOD_TAG) {", "od = (GF_ObjectDescriptor *) gf_malloc(sizeof(GF_InitialObjectDescriptor));", "} else {", "od = (GF_ObjectDescriptor *) gf_malloc(sizeof(GF_ObjectDescriptor));", "}", "if (!od) {", "e = GF_OUT_OF_MEM;", "goto err_exit;", "}", "od->ESDescriptors = gf_list_new();", "od->objectDescriptorID = isom_od->objectDescriptorID;", "od->tag = GF_ODF_OD_TAG;", "od->URLString = isom_od->URLString;", "isom_od->URLString = NULL;", "od->extensionDescriptors = isom_od->extensionDescriptors;", "isom_od->extensionDescriptors = NULL;", "od->IPMP_Descriptors = isom_od->IPMP_Descriptors;", "isom_od->IPMP_Descriptors = NULL;", "od->OCIDescriptors = isom_od->OCIDescriptors;", "isom_od->OCIDescriptors = NULL;", "if (isom_od->tag == GF_ODF_ISOM_IOD_TAG) {", "((GF_InitialObjectDescriptor *)od)->audio_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->audio_profileAndLevel;", "((GF_InitialObjectDescriptor *)od)->inlineProfileFlag = ((GF_IsomInitialObjectDescriptor *)isom_od)->inlineProfileFlag;", "((GF_InitialObjectDescriptor *)od)->graphics_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->graphics_profileAndLevel;", "((GF_InitialObjectDescriptor *)od)->OD_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->OD_profileAndLevel;", "((GF_InitialObjectDescriptor *)od)->scene_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->scene_profileAndLevel;", "((GF_InitialObjectDescriptor *)od)->visual_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->visual_profileAndLevel;", "((GF_InitialObjectDescriptor *)od)->IPMPToolList = ((GF_IsomInitialObjectDescriptor *)isom_od)->IPMPToolList;", "((GF_IsomInitialObjectDescriptor *)isom_od)->IPMPToolList = NULL;", "}", "j=0;", "while ((ref = (GF_ES_ID_Ref*)gf_list_enum(isom_od->ES_ID_RefDescriptors, &j))) {", "if (!mpod->trackIDs || gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1]) == NULL) continue;", "e = GetESDForTime(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1], sample->DTS, &esd);", "if (!e) e = gf_odf_desc_add_desc((GF_Descriptor *) od, (GF_Descriptor *) esd);", "if (e) {", "gf_odf_desc_del((GF_Descriptor *)od);", "gf_odf_com_del((GF_ODCom **)&odU2);", "gf_odf_desc_del((GF_Descriptor *)isom_od);", "gf_odf_com_del((GF_ODCom **)&odU);", "goto err_exit;", "}", "}", "gf_odf_desc_del((GF_Descriptor *)isom_od);", "gf_list_add(odU2->objectDescriptors, od);", "}", "gf_odf_com_del((GF_ODCom **)&odU);", "gf_odf_codec_add_com(ODencode, (GF_ODCom *)odU2);", "break;", "case GF_ODF_ESD_UPDATE_TAG:", "esdU = (GF_ESDUpdate *) com;", "esdU2 = (GF_ESDUpdate *) gf_odf_com_new(GF_ODF_ESD_UPDATE_TAG);", "esdU2->ODID = esdU->ODID;", "i=0;", "while ((ref = (GF_ES_ID_Ref*)gf_list_enum(esdU->ESDescriptors, &i))) {", "if (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1]) == NULL) continue;", "e = GetESDForTime(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1], sample->DTS, &esd);", "if (e) goto err_exit;", "gf_list_add(esdU2->ESDescriptors, esd);", "}", "gf_odf_com_del((GF_ODCom **)&esdU);", "gf_odf_codec_add_com(ODencode, (GF_ODCom *)esdU2);", "break;", "case GF_ODF_ESD_REMOVE_REF_TAG:", "esdR = (GF_ESDRemove *) com;", "esdR2 = (GF_ESDRemove *) gf_odf_com_new(GF_ODF_ESD_REMOVE_TAG);", "esdR2->ODID = esdR->ODID;", "esdR2->NbESDs = esdR->NbESDs;", "esdR2->ES_ID = (unsigned short*)gf_malloc(sizeof(u32) * esdR->NbESDs);", "if (!esdR2->ES_ID) {", "e = GF_OUT_OF_MEM;", "goto err_exit;", "}", "skipped = 0;", "for (i = 0; i < esdR->NbESDs; i++) {", "if (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[esdR->ES_ID[i] - 1]) == NULL) {", "skipped ++;", "} else {", "esdR2->ES_ID[i - skipped] = mpod->trackIDs[esdR->ES_ID[i] - 1];", "}", "}", "if (skipped && (skipped != esdR2->NbESDs) ) {", "esdR2->NbESDs -= skipped;", "esdR2->ES_ID = (unsigned short*)gf_realloc(esdR2->ES_ID, sizeof(u32) * esdR2->NbESDs);", "}", "gf_odf_com_del((GF_ODCom **)&esdR);", "gf_odf_codec_add_com(ODencode, (GF_ODCom *)esdR2);", "break;", "default:", "e = gf_odf_codec_add_com(ODencode, com);", "if (e) goto err_exit;", "}", "}", "e = gf_odf_codec_encode(ODencode, 1);", "if (e) goto err_exit;", "gf_free(sample->data);", "sample->data = NULL;", "sample->dataLength = 0;", "e = gf_odf_codec_get_au(ODencode, &sample->data, &sample->dataLength);", "err_exit:", "gf_odf_codec_del(ODdecode);", "gf_odf_codec_del(ODencode);", "return e;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int parse_line(char *p)", "{", "struct SYMBOL *s;", "char *q, c;", "char *dot = NULL;", "struct SYMBOL *last_note_sav = NULL;", "struct decos dc_sav;", "int i, flags, flags_sav = 0, slur;", "static char qtb[10] = {0, 1, 3, 2, 3, 0, 2, 0, 3, 0};", "colnum = 0;", "switch (*p) {", "case '\\0':", "switch (parse.abc_state) {", "case ABC_S_GLOBAL:", "if (parse.last_sym", "&& parse.last_sym->abc_type != ABC_T_NULL)", "abc_new(ABC_T_NULL, NULL);", "case ABC_S_HEAD:", "return 0;", "}", "return 1;", "case '%':", "if (p[1] == '%') {", "s = abc_new(ABC_T_PSCOM, p);", "p += 2;", "if (strncasecmp(p, \"decoration \", 11) == 0) {", "p += 11;", "while (isspace((unsigned char) *p))", "p++;", "switch (*p) {", "case '!':", "char_tb['!'] = CHAR_DECOS;", "char_tb['+'] = CHAR_BAD;", "break;", "case '+':", "char_tb['+'] = CHAR_DECOS;", "char_tb['!'] = CHAR_BAD;", "break;", "}", "return 0;", "}", "if (strncasecmp(p, \"linebreak \", 10) == 0) {", "for (i = 0; i < sizeof char_tb; i++) {", "if (char_tb[i] == CHAR_LINEBREAK)", "char_tb[i] = i != '!' ?", "CHAR_BAD :", "CHAR_DECOS;", "}", "p += 10;", "for (;;) {", "while (isspace((unsigned char) *p))", "p++;", "if (*p == '\\0')", "break;", "switch (*p) {", "case '!':", "case '$':", "case '*':", "case ';':", "case '?':", "case '@':", "char_tb[(unsigned char) *p++]", "= CHAR_LINEBREAK;", "break;", "case '<':", "if (strncmp(p, \"<none>\", 6) == 0)", "return 0;", "if (strncmp(p, \"<EOL>\", 5) == 0) {", "char_tb['\\n'] = CHAR_LINEBREAK;", "p += 5;", "break;", "}", "default:", "if (strcmp(p, \"lock\") != 0)", "syntax(\"Invalid character in %%%%linebreak\",", "p);", "return 0;", "}", "}", "return 0;", "}", "if (strncasecmp(p, \"microscale \", 11) == 0) {", "int v;", "p += 11;", "while (isspace((unsigned char) *p))", "p++;", "sscanf(p, \"%d\", &v);", "if (v < 4 || v >= 256 || v & 1)", "syntax(\"Invalid value in %%microscale\", p);", "else", "microscale = v;", "return 0;", "}", "if (strncasecmp(p, \"user \", 5) == 0) {", "p += 5;", "while (isspace((unsigned char) *p))", "p++;", "get_user(p, s);", "return 0;", "}", "return 0;", "}", "case '\\\\':", "return 0;", "}", "if (p[1] == ':'", "&& *p != '|' && *p != ':') {", "int new_tune;", "new_tune = parse_info(p);", "if (*p != 'V'", "|| parse.abc_state != ABC_S_TUNE)", "return new_tune;", "c = p[strlen(p) - 1];", "if (c != '|' && c != ']')", "return new_tune;", "while (!isspace((unsigned char) *p) && *p != '\\0')", "p++;", "while (isspace((unsigned char) *p))", "p++;", "}", "if (parse.abc_state != ABC_S_TUNE)", "return 0;", "flags = 0;", "if (parse.abc_vers <= (2 << 16))", "lyric_started = 0;", "deco_start = deco_cont = NULL;", "slur = 0;", "while (*p != '\\0') {", "colnum = p - abc_line;", "switch (char_tb[(unsigned char) *p++]) {", "case CHAR_GCHORD:", "if (flags & ABC_F_GRACE)", "goto bad_char;", "p = parse_gchord(p);", "break;", "case CHAR_GR_ST:", "if (flags & ABC_F_GRACE)", "goto bad_char;", "last_note_sav = curvoice->last_note;", "curvoice->last_note = NULL;", "memcpy(&dc_sav, &dc, sizeof dc);", "dc.n = 0;", "flags_sav = flags;", "flags = ABC_F_GRACE;", "if (*p == '/') {", "flags |= ABC_F_SAPPO;", "p++;", "}", "break;", "case CHAR_GR_EN:", "if (!(flags & ABC_F_GRACE))", "goto bad_char;", "parse.last_sym->flags |= ABC_F_GR_END;", "if (dc.n != 0)", "syntax(\"Decoration ignored\", p);", "curvoice->last_note = last_note_sav;", "memcpy(&dc, &dc_sav, sizeof dc);", "flags = flags_sav;", "break;", "case CHAR_DECOS:", "if (p[-1] == '!'", "&& char_tb['\\n'] == CHAR_LINEBREAK", "&& check_nl(p)) {", "s = abc_new(ABC_T_EOLN, NULL);", "s->u.eoln.type = 2;", "break;", "}", "case CHAR_DECO:", "if (p[-1] == '.') {", "if (*p == '(' || *p == '-') {", "dot = p;", "break;", "}", "}", "p = parse_deco(p - 1, &dc, -1);", "break;", "case CHAR_LINEBREAK:", "s = abc_new(ABC_T_EOLN, NULL);", "break;", "case CHAR_NOTE:", "p = parse_note(p - 1, flags);", "flags &= ABC_F_GRACE;", "parse.last_sym->u.note.slur_st = slur;", "slur = 0;", "if (parse.last_sym->u.note.notes[0].len > 0)", "curvoice->last_note = parse.last_sym;", "break;", "case CHAR_SLASH:", "if (flags & ABC_F_GRACE)", "goto bad_char;", "if (char_tb[(unsigned char) p[-1]] != CHAR_BAR)", "goto bad_char;", "q = p;", "while (*q == '/')", "q++;", "if (char_tb[(unsigned char) *q] != CHAR_BAR)", "goto bad_char;", "s = abc_new(ABC_T_MREP, NULL);", "s->u.bar.type = 0;", "s->u.bar.len = q - p + 1;", "syntax(\"Non standard measure repeat syntax\", p - 1);", "p = q;", "break;", "case CHAR_BSLASH:", "if (*p == '\\0')", "break;", "syntax(\"'\\\\' ignored\", p - 1);", "break;", "case CHAR_OBRA:", "if (*p == '|' || *p == ']' || *p == ':'", "|| isdigit((unsigned char) *p) || *p == '\"'", "|| *p == ' ') {", "if (flags & ABC_F_GRACE)", "goto bad_char;", "p = parse_bar(p);", "break;", "}", "if (p[1] != ':') {", "p = parse_note(p - 1, flags);", "flags &= ABC_F_GRACE;", "parse.last_sym->u.note.slur_st = slur;", "slur = 0;", "curvoice->last_note = parse.last_sym;", "break;", "}", "#if 0", "if (flags & ABC_F_GRACE)", "goto bad_char;", "#endif", "while (p[2] == ' ') {", "p[2] = ':';", "p[1] = *p;", "p++;", "}", "c = ']';", "q = p;", "while (*p != '\\0' && *p != c)", "p++;", "if (*p == '\\0') {", "syntax(\"Escape sequence [..] not closed\", q);", "c = '\\0';", "} else {", "*p = '\\0';", "}", "parse_info(q);", "*p = c;", "if (c != '\\0')", "p++;", "break;", "case CHAR_BAR:", "if (flags & ABC_F_GRACE)", "goto bad_char;", "p = parse_bar(p);", "break;", "case CHAR_OPAR:", "if (*p > '0' && *p <= '9') {", "int pplet, qplet, rplet;", "pplet = strtol(p, &q, 10);", "p = q;", "if ((unsigned) pplet < sizeof qtb / sizeof qtb[0])", "qplet = qtb[pplet];", "else", "qplet = qtb[0];", "rplet = pplet;", "if (*p == ':') {", "p++;", "if (isdigit((unsigned char) *p)) {", "qplet = strtol(p, &q, 10);", "p = q;", "}", "if (*p == ':') {", "p++;", "if (isdigit((unsigned char) *p)) {", "rplet = strtol(p, &q, 10);", "p = q;", "}", "}", "}", "if (rplet < 1) {", "syntax(\"Invalid 'r' in tuplet\", p);", "break;", "}", "if (pplet >= 128 || qplet >= 128 || rplet >= 128) {", "syntax(\"Invalid 'p:q:r' in tuplet\", p);", "break;", "}", "if (qplet == 0)", "qplet = meter % 3 == 0 ? 3 : 2;", "s = abc_new(ABC_T_TUPLET, NULL);", "s->u.tuplet.p_plet = pplet;", "s->u.tuplet.q_plet = qplet;", "s->u.tuplet.r_plet = rplet;", "s->flags |= flags;", "break;", "}", "if (*p == '&') {", "if (flags & ABC_F_GRACE)", "goto bad_char;", "p++;", "if (vover != 0) {", "syntax(\"Nested voice overlay\", p - 1);", "break;", "}", "s = abc_new(ABC_T_V_OVER, NULL);", "s->u.v_over.type = V_OVER_S;", "s->u.v_over.voice = curvoice - voice_tb;", "vover = -1;", "break;", "}", "slur <<= 4;", "if (p == dot + 1 && dc.n == 0)", "slur |= SL_DOTTED;", "switch (*p) {", "case '\\'':", "slur += SL_ABOVE;", "p++;", "break;", "case ',':", "slur += SL_BELOW;", "p++;", "break;", "default:", "slur += SL_AUTO;", "break;", "}", "break;", "case CHAR_CPAR:", "switch (parse.last_sym->abc_type) {", "case ABC_T_NOTE:", "case ABC_T_REST:", "break;", "default:", "goto bad_char;", "}", "parse.last_sym->u.note.slur_end++;", "break;", "case CHAR_VOV:", "if (flags & ABC_F_GRACE)", "goto bad_char;", "if (*p != ')'", "|| vover == 0) {", "if (!curvoice->last_note) {", "syntax(\"Bad start of voice overlay\", p);", "break;", "}", "s = abc_new(ABC_T_V_OVER, NULL);", "vover_new();", "s->u.v_over.voice = curvoice - voice_tb;", "if (vover == 0)", "vover = 1;", "break;", "}", "p++;", "vover = 0;", "s = abc_new(ABC_T_V_OVER, NULL);", "s->u.v_over.type = V_OVER_E;", "s->u.v_over.voice = curvoice->mvoice;", "curvoice->last_note = NULL;", "curvoice = &voice_tb[curvoice->mvoice];", "break;", "case CHAR_SPAC:", "flags |= ABC_F_SPACE;", "break;", "case CHAR_MINUS: {", "int tie_pos;", "if (!curvoice->last_note", "|| curvoice->last_note->abc_type != ABC_T_NOTE)", "goto bad_char;", "if (p == dot + 1 && dc.n == 0)", "tie_pos = SL_DOTTED;", "else", "tie_pos = 0;", "switch (*p) {", "case '\\'':", "tie_pos += SL_ABOVE;", "p++;", "break;", "case ',':", "tie_pos += SL_BELOW;", "p++;", "break;", "default:", "tie_pos += SL_AUTO;", "break;", "}", "for (i = 0; i <= curvoice->last_note->nhd; i++) {", "if (curvoice->last_note->u.note.notes[i].ti1 == 0)", "curvoice->last_note->u.note.notes[i].ti1 = tie_pos;", "else if (curvoice->last_note->nhd == 0)", "syntax(\"Too many ties\", p);", "}", "break;", "}", "case CHAR_BRHY:", "if (!curvoice->last_note)", "goto bad_char;", "i = 1;", "while (*p == p[-1]) {", "i++;", "p++;", "}", "if (i > 3) {", "syntax(\"Bad broken rhythm\", p - 1);", "i = 3;", "}", "if (p[-1] == '<')", "i = -i;", "broken_rhythm(curvoice->last_note, i);", "curvoice->last_note->u.note.brhythm = i;", "break;", "case CHAR_IGN:", "break;", "default:", "bad_char:", "syntax((flags & ABC_F_GRACE)", "? \"Bad character in grace note sequence\"", ": \"Bad character\",", "p - 1);", "break;", "}", "}", "if (flags & ABC_F_GRACE) {", "syntax(\"EOLN in grace note sequence\", p - 1);", "if (curvoice->last_note)", "curvoice->last_note->flags |= ABC_F_GR_END;", "curvoice->last_note = last_note_sav;", "memcpy(&dc, &dc_sav, sizeof dc);", "}", "s = abc_new(ABC_T_EOLN, NULL);", "if (flags & ABC_F_SPACE)", "s->flags |= ABC_F_SPACE;", "if (p[-1] == '\\\\'", "|| char_tb['\\n'] != CHAR_LINEBREAK)", "s->u.eoln.type = 1;", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void naludmx_create_avc_decoder_config(GF_NALUDmxCtx *ctx, u8 **dsi, u32 *dsi_size, u8 **dsi_enh, u32 *dsi_enh_size, u32 *max_width, u32 *max_height, u32 *max_enh_width, u32 *max_enh_height, GF_Fraction *sar)", "{", "u32 i, count;", "Bool first = GF_TRUE;", "Bool first_svc = GF_TRUE;", "GF_AVCConfig *cfg;", "GF_AVCConfig *avcc;", "GF_AVCConfig *svcc;", "u32 max_w, max_h, max_ew, max_eh;", "max_w = max_h = max_ew = max_eh = 0;", "sar->num = sar->den = 0;", "avcc = gf_odf_avc_cfg_new();", "svcc = gf_odf_avc_cfg_new();", "avcc->nal_unit_size = ctx->nal_length;", "svcc->nal_unit_size = ctx->nal_length;", "ctx->is_mvc = GF_FALSE;", "count = gf_list_count(ctx->sps);", "for (i=0; i<count; i++) {", "Bool is_svc = GF_FALSE;", "GF_NALUFFParam *sl = gf_list_get(ctx->sps, i);", "AVC_SPS *sps = &ctx->avc_state->sps[sl->id];", "u32 nal_type = sl->data[0] & 0x1F;", "if ((sps->profile_idc == 118) || (sps->profile_idc == 128)) {", "ctx->is_mvc = GF_TRUE;", "}", "if (ctx->explicit) {", "cfg = svcc;", "} else if (nal_type == GF_AVC_NALU_SVC_SUBSEQ_PARAM) {", "cfg = svcc;", "is_svc = GF_TRUE;", "} else {", "cfg = avcc;", "}", "if (first || (is_svc && first_svc) ) {", "cfg->configurationVersion = 1;", "cfg->profile_compatibility = sps->prof_compat;", "cfg->AVCProfileIndication = sps->profile_idc;", "cfg->AVCLevelIndication = sps->level_idc;", "cfg->chroma_format = sps->chroma_format;", "cfg->luma_bit_depth = 8 + sps->luma_bit_depth_m8;", "cfg->chroma_bit_depth = 8 + sps->chroma_bit_depth_m8;", "if (!gf_avc_is_rext_profile(cfg->AVCProfileIndication)", "&& ((cfg->chroma_format>1) || (cfg->luma_bit_depth>8) || (cfg->chroma_bit_depth>8))", ") {", "if ((cfg->luma_bit_depth>8) || (cfg->chroma_bit_depth>8)) {", "cfg->AVCProfileIndication = 110;", "} else {", "cfg->AVCProfileIndication = (cfg->chroma_format==3) ? 244 : 122;", "}", "}", "if (sps->vui_parameters_present_flag && sps->vui.par_num && sps->vui.par_den) {", "sar->num = sps->vui.par_num;", "sar->den = sps->vui.par_den;", "}", "ctx->interlaced = sps->frame_mbs_only_flag ? GF_FALSE : GF_TRUE;", "if (first && (!ctx->fps.num || !ctx->fps.den) && sps->vui.timing_info_present_flag", "&& (sps->vui.time_scale <= 1000*sps->vui.num_units_in_tick)", ") {", "u8 DeltaTfiDivisorIdx;", "if (!sps->vui.pic_struct_present_flag) {", "DeltaTfiDivisorIdx = 1 + (1 - ctx->avc_state->s_info.field_pic_flag);", "} else {", "if (!ctx->avc_state->sei.pic_timing.pic_struct)", "DeltaTfiDivisorIdx = 2;", "else if (ctx->avc_state->sei.pic_timing.pic_struct == 8)", "DeltaTfiDivisorIdx = 6;", "else", "DeltaTfiDivisorIdx = (ctx->avc_state->sei.pic_timing.pic_struct+1) / 2;", "}", "if (!ctx->timescale) {", "ctx->cur_fps.num = 2 * sps->vui.time_scale;", "ctx->cur_fps.den =  2 * sps->vui.num_units_in_tick * DeltaTfiDivisorIdx;", "if (!ctx->fps.num && ctx->dts==ctx->fps.den)", "ctx->dts = ctx->cur_fps.den;", "}", "if (! sps->vui.fixed_frame_rate_flag)", "GF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (\"[%s] Possible Variable Frame Rate: VUI \\\"fixed_frame_rate_flag\\\" absent\\n\", ctx->log_name));", "}", "ctx->fps = ctx->cur_fps;", "}", "first = GF_FALSE;", "if (is_svc) {", "first_svc = GF_FALSE;", "if (sps->width > max_ew) max_ew = sps->width;", "if (sps->height > max_eh) max_eh = sps->height;", "} else {", "if (sps->width > max_w) max_w = sps->width;", "if (sps->height > max_h) max_h = sps->height;", "}", "if (!ctx->analyze)", "gf_list_add(cfg->sequenceParameterSets, sl);", "}", "cfg = ctx->explicit ? svcc : avcc;", "count = gf_list_count(ctx->sps_ext);", "for (i=0; i<count; i++) {", "GF_NALUFFParam *sl = gf_list_get(ctx->sps_ext, i);", "if (!cfg->sequenceParameterSetExtensions) cfg->sequenceParameterSetExtensions = gf_list_new();", "if (!ctx->analyze)", "gf_list_add(cfg->sequenceParameterSetExtensions, sl);", "}", "cfg = ctx->explicit ? svcc : avcc;", "count = gf_list_count(ctx->pps);", "for (i=0; i<count; i++) {", "GF_NALUFFParam *sl = gf_list_get(ctx->pps, i);", "if (!ctx->analyze)", "gf_list_add(cfg->pictureParameterSets, sl);", "}", "cfg = svcc;", "count = gf_list_count(ctx->pps_svc);", "for (i=0; i<count; i++) {", "GF_NALUFFParam *sl = gf_list_get(ctx->pps_svc, i);", "if (!ctx->analyze)", "gf_list_add(cfg->pictureParameterSets, sl);", "}", "*dsi = *dsi_enh = NULL;", "*dsi_size = *dsi_enh_size = 0;", "if (ctx->explicit) {", "gf_odf_avc_cfg_write(svcc, dsi, dsi_size);", "} else {", "gf_odf_avc_cfg_write(avcc, dsi, dsi_size);", "if (gf_list_count(svcc->sequenceParameterSets) || svcc->sequenceParameterSetExtensions) {", "gf_odf_avc_cfg_write(svcc, dsi_enh, dsi_enh_size);", "}", "}", "gf_list_reset(avcc->sequenceParameterSets);", "gf_list_reset(avcc->sequenceParameterSetExtensions);", "gf_list_reset(avcc->pictureParameterSets);", "gf_list_reset(svcc->sequenceParameterSets);", "gf_list_reset(svcc->sequenceParameterSetExtensions);", "gf_list_reset(svcc->pictureParameterSets);", "gf_odf_avc_cfg_del(avcc);", "gf_odf_avc_cfg_del(svcc);", "*max_width = max_w;", "*max_height = max_h;", "*max_enh_width = max_ew;", "*max_enh_height = max_eh;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void gf_av1_reset_state(AV1State *state, Bool is_destroy)", "{", "GF_List *l1, *l2;", "if (state->frame_state.header_obus) {", "while (gf_list_count(state->frame_state.header_obus)) {", "GF_AV1_OBUArrayEntry *a = (GF_AV1_OBUArrayEntry*)gf_list_pop_back(state->frame_state.header_obus);", "if (a->obu) gf_free(a->obu);", "gf_free(a);", "}", "}", "if (state->frame_state.frame_obus) {", "while (gf_list_count(state->frame_state.frame_obus)) {", "GF_AV1_OBUArrayEntry *a = (GF_AV1_OBUArrayEntry*)gf_list_pop_back(state->frame_state.frame_obus);", "if (a->obu) gf_free(a->obu);", "gf_free(a);", "}", "}", "l1 = state->frame_state.frame_obus;", "l2 = state->frame_state.header_obus;", "memset(&state->frame_state, 0, sizeof(AV1StateFrame));", "state->frame_state.is_first_frame = GF_TRUE;", "if (is_destroy) {", "gf_list_del(l1);", "gf_list_del(l2);", "if (state->bs) {", "if (gf_bs_get_position(state->bs)) {", "u32 size;", "gf_bs_get_content_no_truncate(state->bs, &state->frame_obus, &size, &state->frame_obus_alloc);", "}", "gf_bs_del(state->bs);", "}", "state->bs = NULL;", "}", "else {", "state->frame_state.frame_obus = l1;", "state->frame_state.header_obus = l2;", "if (state->bs)", "gf_bs_seek(state->bs, 0);", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static void do_iccprofile_item(deark *c, lctx *d, i64 pos, i64 len)", "{", "i64 selector;", "i64 data_len;", "if(len<4) return;", "selector = de_getu32be(pos);", "data_len = len-4;", "de_dbg(c, \"ICC profile segment, selector=%d, data len=%d\", (int)selector,", "(int)data_len);", "if(selector!=1) {", "dbuf_close(d->iccprofile_file);", "d->iccprofile_file = NULL;", "}", "if(selector==0) {", "d->iccprofile_file = dbuf_create_output_file(c, \"icc\", NULL, DE_CREATEFLAG_IS_AUX);", "}", "if(selector==0 || selector==1) {", "dbuf_copy(c->infile, pos+4, data_len, d->iccprofile_file);", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["static void gf_m2ts_process_pat(GF_M2TS_Demuxer *ts, GF_M2TS_SECTION_ES *ses, GF_List *sections, u8 table_id, u16 ex_table_id, u8 version_number, u8 last_section_number, u32 status)", "{", "GF_M2TS_Program *prog;", "GF_M2TS_SECTION_ES *pmt;", "u32 i, nb_progs, evt_type;", "u32 nb_sections;", "u32 data_size;", "unsigned char *data;", "GF_M2TS_Section *section;", "if (!(status&GF_M2TS_TABLE_END)) return;", "if (status&GF_M2TS_TABLE_REPEAT) {", "if (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_PAT_REPEAT, NULL);", "return;", "}", "nb_sections = gf_list_count(sections);", "if (nb_sections > 1) {", "GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"PAT on multiple sections not supported\\n\"));", "}", "section = (GF_M2TS_Section *)gf_list_get(sections, 0);", "data = section->data;", "data_size = section->data_size;", "if (!(status&GF_M2TS_TABLE_UPDATE) && gf_list_count(ts->programs)) {", "if (ts->pat->demux_restarted) {", "ts->pat->demux_restarted = 0;", "} else {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Multiple different PAT on single TS found, ignoring new PAT declaration (table id %d - extended table id %d)\\n\", table_id, ex_table_id));", "}", "return;", "}", "nb_progs = data_size / 4;", "for (i=0; i<nb_progs; i++) {", "u16 number, pid;", "number = (data[0]<<8) | data[1];", "pid = (data[2]&0x1f)<<8 | data[3];", "data += 4;", "if (number==0) {", "if (!ts->nit) {", "ts->nit = gf_m2ts_section_filter_new(gf_m2ts_process_nit, 0);", "}", "} else {", "GF_SAFEALLOC(prog, GF_M2TS_Program);", "if (!prog) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Fail to allocate program for pid %d\\n\", pid));", "return;", "}", "prog->streams = gf_list_new();", "prog->pmt_pid = pid;", "prog->number = number;", "prog->ts = ts;", "gf_list_add(ts->programs, prog);", "GF_SAFEALLOC(pmt, GF_M2TS_SECTION_ES);", "if (!pmt) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Fail to allocate pmt filter for pid %d\\n\", pid));", "return;", "}", "pmt->flags = GF_M2TS_ES_IS_SECTION;", "gf_list_add(prog->streams, pmt);", "pmt->pid = prog->pmt_pid;", "pmt->program = prog;", "ts->ess[pmt->pid] = (GF_M2TS_ES *)pmt;", "pmt->sec = gf_m2ts_section_filter_new(gf_m2ts_process_pmt, 0);", "}", "}", "evt_type = (status&GF_M2TS_TABLE_UPDATE) ? GF_M2TS_EVT_PAT_UPDATE : GF_M2TS_EVT_PAT_FOUND;", "if (ts->on_event) ts->on_event(ts, evt_type, NULL);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static s32 gf_avc_read_sps_bs_internal(GF_BitStream *bs, AVCState *avc, u32 subseq_sps, u32 *vui_flag_pos, u32 nal_hdr)", "{", "AVC_SPS *sps;", "s32 mb_width, mb_height, sps_id = -1;", "u32 profile_idc, level_idc, pcomp, i, chroma_format_idc, cl = 0, cr = 0, ct = 0, cb = 0, luma_bd, chroma_bd;", "u8 separate_colour_plane_flag = 0;", "if (!vui_flag_pos) {", "gf_bs_enable_emulation_byte_removal(bs, GF_TRUE);", "}", "if (!bs) {", "return -1;", "}", "if (!nal_hdr) {", "gf_bs_read_int_log(bs, 1, \"forbidden_zero_bit\");", "gf_bs_read_int_log(bs, 2, \"nal_ref_idc\");", "gf_bs_read_int_log(bs, 5, \"nal_unit_type\");", "}", "profile_idc = gf_bs_read_int_log(bs, 8, \"profile_idc\");", "pcomp = gf_bs_read_int_log(bs, 8, \"profile_compatibility\");", "if (pcomp & 0x3)", "return -1;", "level_idc = gf_bs_read_int_log(bs, 8, \"level_idc\");", "sps_id = gf_bs_read_ue_log(bs, \"sps_id\") + GF_SVC_SSPS_ID_SHIFT * subseq_sps;", "if (sps_id >= 32) {", "return -1;", "}", "if (sps_id < 0) {", "return -1;", "}", "luma_bd = chroma_bd = 0;", "sps = &avc->sps[sps_id];", "chroma_format_idc = sps->ChromaArrayType = 1;", "sps->state |= subseq_sps ? AVC_SUBSPS_PARSED : AVC_SPS_PARSED;", "switch (profile_idc) {", "case 100:", "case 110:", "case 122:", "case 244:", "case 44:", "if (pcomp & 0xE0)", "return -1;", "case 83:", "case 86:", "case 118:", "case 128:", "chroma_format_idc = gf_bs_read_ue_log(bs, \"chroma_format_idc\");", "sps->ChromaArrayType = chroma_format_idc;", "if (chroma_format_idc == 3) {", "separate_colour_plane_flag = gf_bs_read_int_log(bs, 1, \"separate_colour_plane_flag\");", "if (separate_colour_plane_flag) sps->ChromaArrayType = 0;", "}", "luma_bd = gf_bs_read_ue_log(bs, \"luma_bit_depth\");", "chroma_bd = gf_bs_read_ue_log(bs, \"chroma_bit_depth\");", "gf_bs_read_int_log(bs, 1, \"qpprime_y_zero_transform_bypass_flag\");", "if (gf_bs_read_int_log(bs, 1, \"seq_scaling_matrix_present_flag\")) {", "u32 k;", "for (k = 0; k < 8; k++) {", "if (gf_bs_read_int_log_idx(bs, 1, \"seq_scaling_list_present_flag\", k)) {", "u32 z, last = 8, next = 8;", "u32 sl = k < 6 ? 16 : 64;", "for (z = 0; z < sl; z++) {", "if (next) {", "s32 delta = gf_bs_read_se(bs);", "next = (last + delta + 256) % 256;", "}", "last = next ? next : last;", "}", "}", "}", "}", "break;", "}", "sps->profile_idc = profile_idc;", "sps->level_idc = level_idc;", "sps->prof_compat = pcomp;", "sps->log2_max_frame_num = gf_bs_read_ue_log(bs, \"log2_max_frame_num\") + 4;", "sps->poc_type = gf_bs_read_ue_log(bs, \"poc_type\");", "sps->chroma_format = chroma_format_idc;", "sps->luma_bit_depth_m8 = luma_bd;", "sps->chroma_bit_depth_m8 = chroma_bd;", "if (sps->poc_type == 0) {", "sps->log2_max_poc_lsb = gf_bs_read_ue_log(bs, \"log2_max_poc_lsb\") + 4;", "}", "else if (sps->poc_type == 1) {", "sps->delta_pic_order_always_zero_flag = gf_bs_read_int_log(bs, 1, \"delta_pic_order_always_zero_flag\");", "sps->offset_for_non_ref_pic = gf_bs_read_se_log(bs, \"offset_for_non_ref_pic\");", "sps->offset_for_top_to_bottom_field = gf_bs_read_se_log(bs, \"offset_for_top_to_bottom_field\");", "sps->poc_cycle_length = gf_bs_read_ue_log(bs, \"poc_cycle_length\");", "if (sps->poc_cycle_length > GF_ARRAY_LENGTH(sps->offset_for_ref_frame)) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[avc-h264] offset_for_ref_frame overflow from poc_cycle_length\\n\"));", "return -1;", "}", "for (i = 0; i < sps->poc_cycle_length; i++)", "sps->offset_for_ref_frame[i] = gf_bs_read_se_log_idx(bs, \"offset_for_ref_frame\", i);", "}", "if (sps->poc_type > 2) {", "return -1;", "}", "sps->max_num_ref_frames = gf_bs_read_ue_log(bs, \"max_num_ref_frames\");", "sps->gaps_in_frame_num_value_allowed_flag = gf_bs_read_int_log(bs, 1, \"gaps_in_frame_num_value_allowed_flag\");", "mb_width = gf_bs_read_ue_log(bs, \"pic_width_in_mbs_minus1\") + 1;", "mb_height = gf_bs_read_ue_log(bs, \"pic_height_in_map_units_minus1\") + 1;", "sps->frame_mbs_only_flag = gf_bs_read_int_log(bs, 1, \"frame_mbs_only_flag\");", "sps->width = mb_width * 16;", "sps->height = (2 - sps->frame_mbs_only_flag) * mb_height * 16;", "if (!sps->frame_mbs_only_flag) sps->mb_adaptive_frame_field_flag = gf_bs_read_int_log(bs, 1, \"mb_adaptive_frame_field_flag\");", "gf_bs_read_int_log(bs, 1, \"direct_8x8_inference_flag\");", "if (gf_bs_read_int_log(bs, 1, \"frame_cropping_flag\")) {", "int CropUnitX, CropUnitY, SubWidthC = -1, SubHeightC = -1;", "if (chroma_format_idc == 1) {", "SubWidthC = 2; SubHeightC = 2;", "}", "else if (chroma_format_idc == 2) {", "SubWidthC = 2; SubHeightC = 1;", "}", "else if ((chroma_format_idc == 3) && (separate_colour_plane_flag == 0)) {", "SubWidthC = 1; SubHeightC = 1;", "}", "if (sps->ChromaArrayType == 0) {", "assert(SubWidthC == -1);", "CropUnitX = 1;", "CropUnitY = 2 - sps->frame_mbs_only_flag;", "}", "else {", "CropUnitX = SubWidthC;", "CropUnitY = SubHeightC * (2 - sps->frame_mbs_only_flag);", "}", "cl = gf_bs_read_ue_log(bs, \"frame_crop_left_offset\");", "cr = gf_bs_read_ue_log(bs, \"frame_crop_right_offset\");", "ct = gf_bs_read_ue_log(bs, \"frame_crop_top_offset\");", "cb = gf_bs_read_ue_log(bs, \"frame_crop_bottom_offset\");", "sps->width -= CropUnitX * (cl + cr);", "sps->height -= CropUnitY * (ct + cb);", "cl *= CropUnitX;", "cr *= CropUnitX;", "ct *= CropUnitY;", "cb *= CropUnitY;", "}", "sps->crop.left = cl;", "sps->crop.right = cr;", "sps->crop.top = ct;", "sps->crop.bottom = cb;", "if (vui_flag_pos) {", "*vui_flag_pos = (u32)gf_bs_get_bit_offset(bs);", "}", "sps->vui_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_parameters_present_flag\");", "if (sps->vui_parameters_present_flag) {", "sps->vui.aspect_ratio_info_present_flag = gf_bs_read_int_log(bs, 1, \"aspect_ratio_info_present_flag\");", "if (sps->vui.aspect_ratio_info_present_flag) {", "s32 aspect_ratio_idc = gf_bs_read_int_log(bs, 8, \"aspect_ratio_idc\");", "if (aspect_ratio_idc == 255) {", "sps->vui.par_num = gf_bs_read_int_log(bs, 16, \"aspect_ratio_num\");", "sps->vui.par_den = gf_bs_read_int_log(bs, 16, \"aspect_ratio_den\");", "}", "else if (aspect_ratio_idc < GF_ARRAY_LENGTH(avc_hevc_sar) ) {", "sps->vui.par_num = avc_hevc_sar[aspect_ratio_idc].w;", "sps->vui.par_den = avc_hevc_sar[aspect_ratio_idc].h;", "}", "else {", "GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] Unknown aspect_ratio_idc: your video may have a wrong aspect ratio. Contact the GPAC team!\\n\"));", "}", "}", "sps->vui.overscan_info_present_flag = gf_bs_read_int_log(bs, 1, \"overscan_info_present_flag\");", "if (sps->vui.overscan_info_present_flag)", "gf_bs_read_int_log(bs, 1, \"overscan_appropriate_flag\");", "sps->vui.video_format = 5;", "sps->vui.colour_primaries = 2;", "sps->vui.transfer_characteristics = 2;", "sps->vui.matrix_coefficients = 2;", "sps->vui.video_signal_type_present_flag = gf_bs_read_int_log(bs, 1, \"video_signal_type_present_flag\");", "if (sps->vui.video_signal_type_present_flag) {", "sps->vui.video_format = gf_bs_read_int_log(bs, 3, \"video_format\");", "sps->vui.video_full_range_flag = gf_bs_read_int_log(bs, 1, \"video_full_range_flag\");", "sps->vui.colour_description_present_flag = gf_bs_read_int_log(bs, 1, \"colour_description_present_flag\");", "if (sps->vui.colour_description_present_flag) {", "sps->vui.colour_primaries = gf_bs_read_int_log(bs, 8, \"colour_primaries\");", "sps->vui.transfer_characteristics = gf_bs_read_int_log(bs, 8, \"transfer_characteristics\");", "sps->vui.matrix_coefficients = gf_bs_read_int_log(bs, 8, \"matrix_coefficients\");", "}", "}", "if (gf_bs_read_int_log(bs, 1, \"chroma_location_info_present_flag\")) {", "gf_bs_read_ue_log(bs, \"chroma_sample_location_type_top_field\");", "gf_bs_read_ue_log(bs, \"chroma_sample_location_type_bottom_field\");", "}", "sps->vui.timing_info_present_flag = gf_bs_read_int_log(bs, 1, \"timing_info_present_flag\");", "if (sps->vui.timing_info_present_flag) {", "sps->vui.num_units_in_tick = gf_bs_read_int_log(bs, 32, \"num_units_in_tick\");", "sps->vui.time_scale = gf_bs_read_int_log(bs, 32, \"time_scale\");", "sps->vui.fixed_frame_rate_flag = gf_bs_read_int_log(bs, 1, \"fixed_frame_rate_flag\");", "}", "sps->vui.nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"nal_hrd_parameters_present_flag\");", "if (sps->vui.nal_hrd_parameters_present_flag)", "avc_parse_hrd_parameters(bs, &sps->vui.hrd);", "sps->vui.vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vcl_hrd_parameters_present_flag\");", "if (sps->vui.vcl_hrd_parameters_present_flag)", "avc_parse_hrd_parameters(bs, &sps->vui.hrd);", "if (sps->vui.nal_hrd_parameters_present_flag || sps->vui.vcl_hrd_parameters_present_flag)", "sps->vui.low_delay_hrd_flag = gf_bs_read_int_log(bs, 1, \"low_delay_hrd_flag\");", "sps->vui.pic_struct_present_flag = gf_bs_read_int_log(bs, 1, \"pic_struct_present_flag\");", "}", "if (subseq_sps) {", "if ((profile_idc == 83) || (profile_idc == 86)) {", "u8 extended_spatial_scalability_idc;", "gf_bs_read_int_log(bs, 1, \"inter_layer_deblocking_filter_control_present_flag\");", "extended_spatial_scalability_idc = gf_bs_read_int_log(bs, 2, \"extended_spatial_scalability_idc\");", "if (sps->ChromaArrayType == 1 || sps->ChromaArrayType == 2) {", "gf_bs_read_int_log(bs, 1, \"chroma_phase_x_plus1_flag\");", "}", "if (sps->ChromaArrayType == 1) {", "gf_bs_read_int_log(bs, 2, \"chroma_phase_y_plus1\");", "}", "if (extended_spatial_scalability_idc == 1) {", "if (sps->ChromaArrayType > 0) {", "gf_bs_read_int_log(bs, 1, \"seq_ref_layer_chroma_phase_x_plus1_flag\");", "gf_bs_read_int_log(bs, 2, \"seq_ref_layer_chroma_phase_y_plus1\");", "}", "gf_bs_read_se_log(bs, \"seq_scaled_ref_layer_left_offset\");", "gf_bs_read_se_log(bs, \"seq_scaled_ref_layer_top_offset\");", "gf_bs_read_se_log(bs, \"seq_scaled_ref_layer_right_offset\");", "gf_bs_read_se_log(bs, \"seq_scaled_ref_layer_bottom_offset\");", "}", "if (gf_bs_read_int_log(bs, 1, \"seq_tcoeff_level_prediction_flag\")) {", "gf_bs_read_int_log(bs, 1, \"adaptive_tcoeff_level_prediction_flag\");", "}", "gf_bs_read_int_log(bs, 1, \"slice_header_restriction_flag\");", "if (gf_bs_read_int_log(bs, 1, \"svc_vui_parameters_present\")) {", "u32 vui_ext_num_entries_minus1 = gf_bs_read_ue_log(bs, \"vui_ext_num_entries_minus1\");", "for (i = 0; i <= vui_ext_num_entries_minus1; i++) {", "u8 vui_ext_nal_hrd_parameters_present_flag, vui_ext_vcl_hrd_parameters_present_flag, vui_ext_timing_info_present_flag;", "gf_bs_read_int_log(bs, 3, \"vui_ext_dependency_id\");", "gf_bs_read_int_log(bs, 4, \"vui_ext_quality_id\");", "gf_bs_read_int_log(bs, 3, \"vui_ext_temporal_id\");", "vui_ext_timing_info_present_flag = gf_bs_read_int_log(bs, 1, \"vui_ext_timing_info_present_flag\");", "if (vui_ext_timing_info_present_flag) {", "gf_bs_read_int_log(bs, 32, \"vui_ext_num_units_in_tick\");", "gf_bs_read_int_log(bs, 32, \"vui_ext_time_scale\");", "gf_bs_read_int_log(bs, 1, \"vui_ext_fixed_frame_rate_flag\");", "}", "vui_ext_nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_ext_nal_hrd_parameters_present_flag\");", "if (vui_ext_nal_hrd_parameters_present_flag) {", "}", "vui_ext_vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_ext_vcl_hrd_parameters_present_flag\");", "if (vui_ext_vcl_hrd_parameters_present_flag) {", "}", "if (vui_ext_nal_hrd_parameters_present_flag || vui_ext_vcl_hrd_parameters_present_flag) {", "gf_bs_read_int_log(bs, 1, \"vui_ext_low_delay_hrd_flag\");", "}", "gf_bs_read_int_log(bs, 1, \"vui_ext_pic_struct_present_flag\");", "}", "}", "}", "else if ((profile_idc == 118) || (profile_idc == 128)) {", "GF_LOG(GF_LOG_INFO, GF_LOG_CODING, (\"[avc-h264] MVC parsing not implemented - skipping parsing end of Subset SPS\\n\"));", "return sps_id;", "}", "if (gf_bs_read_int_log(bs, 1, \"additional_extension2\")) {", "GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] skipping parsing end of Subset SPS (additional_extension2)\\n\"));", "return sps_id;", "}", "}", "return sps_id;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void process_packet_tail(struct msg_digest *md)", "{", "struct state *st = md->st;", "enum state_kind from_state = md->v1_from_state;", "const struct state_v1_microcode *smc = md->smc;", "bool new_iv_set = md->new_iv_set;", "bool self_delete = FALSE;", "if (md->hdr.isa_flags & ISAKMP_FLAGS_v1_ENCRYPTION) {", "endpoint_buf b;", "dbg(\"received encrypted packet from %s\", str_endpoint(&md->sender, &b));", "if (st == NULL) {", "libreswan_log(", "\"discarding encrypted message for an unknown ISAKMP SA\");", "return;", "}", "if (st->st_skeyid_e_nss == NULL) {", "loglog(RC_LOG_SERIOUS,", "\"discarding encrypted message because we haven't yet negotiated keying material\");", "return;", "}", "md->encrypted = TRUE;", "const struct encrypt_desc *e = st->st_oakley.ta_encrypt;", "if (pbs_left(&md->message_pbs) % e->enc_blocksize != 0) {", "loglog(RC_LOG_SERIOUS, \"malformed message: not a multiple of encryption blocksize\");", "return;", "}", "md->raw_packet = clone_bytes_as_chunk(md->packet_pbs.start,", "pbs_room(&md->packet_pbs),", "\"raw packet\");", "if (!new_iv_set) {", "if (st->st_v1_iv.len == 0) {", "init_phase2_iv(st, &md->hdr.isa_msgid);", "} else {", "restore_new_iv(st, st->st_v1_iv);", "}", "}", "passert(st->st_v1_new_iv.len >= e->enc_blocksize);", "st->st_v1_new_iv.len = e->enc_blocksize;", "if (DBGP(DBG_CRYPT)) {", "DBG_log(\"decrypting %u bytes using algorithm %s\",", "(unsigned) pbs_left(&md->message_pbs),", "st->st_oakley.ta_encrypt->common.fqn);", "DBG_dump_hunk(\"IV before:\", st->st_v1_new_iv);", "}", "e->encrypt_ops->do_crypt(e, md->message_pbs.cur,", "pbs_left(&md->message_pbs),", "st->st_enc_key_nss,", "st->st_v1_new_iv.ptr, FALSE);", "if (DBGP(DBG_CRYPT)) {", "DBG_dump_hunk(\"IV after:\", st->st_v1_new_iv);", "DBG_log(\"decrypted payload (starts at offset %td):\",", "md->message_pbs.cur - md->message_pbs.roof);", "DBG_dump(NULL, md->message_pbs.start,", "md->message_pbs.roof - md->message_pbs.start);", "}", "} else {", "if (smc->flags & SMF_INPUT_ENCRYPTED) {", "loglog(RC_LOG_SERIOUS,", "\"packet rejected: should have been encrypted\");", "SEND_NOTIFICATION(INVALID_FLAGS);", "return;", "}", "}", "{", "enum next_payload_types_ikev1 np = md->hdr.isa_np;", "lset_t needed = smc->req_payloads;", "const char *excuse =", "LIN(SMF_PSK_AUTH | SMF_FIRST_ENCRYPTED_INPUT,", "smc->flags) ?", "\"probable authentication failure (mismatch of preshared secrets?): \"", ":", "\"\";", "while (np != ISAKMP_NEXT_NONE) {", "struct_desc *sd = v1_payload_desc(np);", "if (md->digest_roof >= elemsof(md->digest)) {", "loglog(RC_LOG_SERIOUS,", "\"more than %zu payloads in message; ignored\",", "elemsof(md->digest));", "if (!md->encrypted) {", "SEND_NOTIFICATION(PAYLOAD_MALFORMED);", "}", "return;", "}", "struct payload_digest *const pd = md->digest + md->digest_roof;", "if (st != NULL && st->st_connection != NULL &&", "(st->st_connection->policy & POLICY_AGGRESSIVE) == LEMPTY)", "{", "switch (np) {", "case ISAKMP_NEXT_NATD_RFC:", "case ISAKMP_NEXT_NATOA_RFC:", "if ((st->hidden_variables.st_nat_traversal & NAT_T_WITH_RFC_VALUES) == LEMPTY) {", "DBG(DBG_NATT,", "DBG_log(\"st_nat_traversal was: %s\",", "bitnamesof(natt_bit_names,", "st->hidden_variables.st_nat_traversal)));", "sd = NULL;", "}", "break;", "default:", "break;", "}", "}", "if (sd == NULL) {", "switch (np) {", "case ISAKMP_NEXT_ID:", "sd = (IS_PHASE1(from_state) ||", "IS_PHASE15(from_state)) ?", "&isakmp_identification_desc :", "&isakmp_ipsec_identification_desc;", "break;", "case ISAKMP_NEXT_NATD_DRAFTS:", "np = ISAKMP_NEXT_NATD_RFC;", "sd = &isakmp_nat_d_drafts;", "break;", "case ISAKMP_NEXT_NATOA_DRAFTS:", "np = ISAKMP_NEXT_NATOA_RFC;", "sd = &isakmp_nat_oa_drafts;", "break;", "case ISAKMP_NEXT_SAK:", "loglog(RC_LOG_SERIOUS,", "\"%smessage with unsupported payload ISAKMP_NEXT_SAK (or ISAKMP_NEXT_NATD_BADDRAFTS) ignored\",", "excuse);", "if (!in_struct(&pd->payload, &isakmp_ignore_desc, &md->message_pbs,", "&pd->pbs)) {", "loglog(RC_LOG_SERIOUS,", "\"%smalformed payload in packet\",", "excuse);", "if (!md->encrypted) {", "SEND_NOTIFICATION(PAYLOAD_MALFORMED);", "}", "return;", "}", "np = pd->payload.generic.isag_np;", "continue;", "default:", "loglog(RC_LOG_SERIOUS,", "\"%smessage ignored because it contains an unknown or unexpected payload type (%s) at the outermost level\",", "excuse,", "enum_show(&ikev1_payload_names, np));", "if (!md->encrypted) {", "SEND_NOTIFICATION(INVALID_PAYLOAD_TYPE);", "}", "return;", "}", "passert(sd != NULL);", "}", "passert(np < LELEM_ROOF);", "{", "lset_t s = LELEM(np);", "if (LDISJOINT(s,", "needed | smc->opt_payloads |", "LELEM(ISAKMP_NEXT_VID) |", "LELEM(ISAKMP_NEXT_N) |", "LELEM(ISAKMP_NEXT_D) |", "LELEM(ISAKMP_NEXT_CR) |", "LELEM(ISAKMP_NEXT_CERT))) {", "loglog(RC_LOG_SERIOUS,", "\"%smessage ignored because it contains a payload type (%s) unexpected by state %s\",", "excuse,", "enum_show(&ikev1_payload_names, np),", "st->st_state->name);", "if (!md->encrypted) {", "SEND_NOTIFICATION(INVALID_PAYLOAD_TYPE);", "}", "return;", "}", "DBG(DBG_PARSING,", "DBG_log(\"got payload 0x%\" PRIxLSET\"  (%s) needed: 0x%\" PRIxLSET \" opt: 0x%\" PRIxLSET,", "s, enum_show(&ikev1_payload_names, np),", "needed, smc->opt_payloads));", "needed &= ~s;", "}", "pd->payload_type = np;", "if (!in_struct(&pd->payload, sd, &md->message_pbs,", "&pd->pbs)) {", "loglog(RC_LOG_SERIOUS,", "\"%smalformed payload in packet\",", "excuse);", "if (!md->encrypted) {", "SEND_NOTIFICATION(PAYLOAD_MALFORMED);", "}", "return;", "}", "switch (np) {", "case ISAKMP_NEXT_ID:", "case ISAKMP_NEXT_NATOA_RFC:", "DBG(DBG_PARSING,", "DBG_dump(\"     obj: \", pd->pbs.cur,", "pbs_left(&pd->pbs)));", "break;", "default:", "break;", "}", "{", "passert(np < elemsof(md->chain));", "struct payload_digest **p = &md->chain[np];", "while (*p != NULL)", "p = &(*p)->next;", "*p = pd;", "pd->next = NULL;", "}", "np = pd->payload.generic.isag_np;", "md->digest_roof++;", "excuse = \"\";", "}", "DBG(DBG_PARSING, {", "if (pbs_left(&md->message_pbs) != 0)", "DBG_log(\"removing %d bytes of padding\",", "(int) pbs_left(&md->message_pbs));", "});", "md->message_pbs.roof = md->message_pbs.cur;", "if (needed != 0) {", "loglog(RC_LOG_SERIOUS,", "\"message for %s is missing payloads %s\",", "finite_states[from_state]->name,", "bitnamesof(payload_name_ikev1, needed));", "if (!md->encrypted) {", "SEND_NOTIFICATION(PAYLOAD_MALFORMED);", "}", "return;", "}", "}", "if (!check_v1_HASH(smc->hash_type, smc->message, st, md)) {", "return;", "}", "if (IS_PHASE1(from_state) || IS_PHASE15(from_state)) {", "if (md->chain[ISAKMP_NEXT_SA] != NULL &&", "md->hdr.isa_np != ISAKMP_NEXT_SA) {", "loglog(RC_LOG_SERIOUS,", "\"malformed Phase 1 message: does not start with an SA payload\");", "if (!md->encrypted) {", "SEND_NOTIFICATION(PAYLOAD_MALFORMED);", "}", "return;", "}", "} else if (IS_QUICK(from_state)) {", "if (md->hdr.isa_np != ISAKMP_NEXT_HASH) {", "loglog(RC_LOG_SERIOUS,", "\"malformed Quick Mode message: does not start with a HASH payload\");", "if (!md->encrypted) {", "SEND_NOTIFICATION(PAYLOAD_MALFORMED);", "}", "return;", "}", "{", "struct payload_digest *p;", "int i;", "p = md->chain[ISAKMP_NEXT_SA];", "i = 1;", "while (p != NULL) {", "if (p != &md->digest[i]) {", "loglog(RC_LOG_SERIOUS,", "\"malformed Quick Mode message: SA payload is in wrong position\");", "if (!md->encrypted) {", "SEND_NOTIFICATION(PAYLOAD_MALFORMED);", "}", "return;", "}", "p = p->next;", "i++;", "}", "}", "{", "struct payload_digest *id = md->chain[ISAKMP_NEXT_ID];", "if (id != NULL) {", "if (id->next == NULL ||", "id->next->next != NULL) {", "loglog(RC_LOG_SERIOUS,", "\"malformed Quick Mode message: if any ID payload is present, there must be exactly two\");", "SEND_NOTIFICATION(PAYLOAD_MALFORMED);", "return;", "}", "if (id + 1 != id->next) {", "loglog(RC_LOG_SERIOUS,", "\"malformed Quick Mode message: the ID payloads are not adjacent\");", "SEND_NOTIFICATION(PAYLOAD_MALFORMED);", "return;", "}", "}", "}", "}", "{", "struct payload_digest *p = md->chain[ISAKMP_NEXT_N];", "while (p != NULL) {", "switch (p->payload.notification.isan_type) {", "case R_U_THERE:", "case R_U_THERE_ACK:", "case ISAKMP_N_CISCO_LOAD_BALANCE:", "case PAYLOAD_MALFORMED:", "case INVALID_MESSAGE_ID:", "case IPSEC_RESPONDER_LIFETIME:", "if (md->hdr.isa_xchg == ISAKMP_XCHG_INFO) {", "break;", "}", "default:", "if (st == NULL) {", "DBG(DBG_CONTROL, DBG_log(", "\"ignoring informational payload %s, no corresponding state\",", "enum_show(& ikev1_notify_names,", "p->payload.notification.isan_type)));", "} else {", "loglog(RC_LOG_SERIOUS,", "\"ignoring informational payload %s, msgid=%08\" PRIx32 \", length=%d\",", "enum_show(&ikev1_notify_names,", "p->payload.notification.isan_type),", "st->st_v1_msgid.id,", "p->payload.notification.isan_length);", "DBG_dump_pbs(&p->pbs);", "}", "}", "if (DBGP(DBG_BASE)) {", "DBG_dump(\"info:\", p->pbs.cur,", "pbs_left(&p->pbs));", "}", "p = p->next;", "}", "p = md->chain[ISAKMP_NEXT_D];", "while (p != NULL) {", "self_delete |= accept_delete(md, p);", "if (DBGP(DBG_BASE)) {", "DBG_dump(\"del:\", p->pbs.cur,", "pbs_left(&p->pbs));", "}", "if (md->st != st) {", "pexpect(md->st == NULL);", "dbg(\"zapping ST as accept_delete() zapped MD.ST\");", "st = md->st;", "}", "p = p->next;", "}", "p = md->chain[ISAKMP_NEXT_VID];", "while (p != NULL) {", "handle_vendorid(md, (char *)p->pbs.cur,", "pbs_left(&p->pbs), FALSE);", "p = p->next;", "}", "}", "if (self_delete) {", "accept_self_delete(md);", "st = md->st;", "}", "pexpect(st == md->st);", "statetime_t start = statetime_start(md->st);", "complete_v1_state_transition(md, smc->processor(st, md));", "statetime_stop(&start, \"%s()\", __func__);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void CtcpParser::query(CoreNetwork *net, const QString &bufname, const QString &ctcpTag, const QString &message)", "{", "QList<QByteArray> params;", "params << net->serverEncode(bufname) << lowLevelQuote(pack(net->serverEncode(ctcpTag), net->userEncode(bufname, message)));", "static const char *splitter = \" .,-!?\";", "int maxSplitPos = message.count();", "int splitPos = maxSplitPos;", "int overrun = net->userInputHandler()->lastParamOverrun(\"PRIVMSG\", params);", "if (overrun) {", "maxSplitPos = message.count() - overrun -2;", "splitPos = -1;", "for (const char *splitChar = splitter; *splitChar != 0; splitChar++) {", "splitPos = qMax(splitPos, message.lastIndexOf(*splitChar, maxSplitPos) + 1);", "}", "if (splitPos <= 0 || splitPos > maxSplitPos)", "splitPos = maxSplitPos;", "params = params.mid(0, 1) <<  lowLevelQuote(pack(net->serverEncode(ctcpTag), net->userEncode(bufname, message.left(splitPos))));", "}", "net->putCmd(\"PRIVMSG\", params);", "if (splitPos < message.count())", "query(net, bufname, ctcpTag, message.mid(splitPos));", "}"], "ner_tags": [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0]}
{"tokens": ["static void naludmx_queue_param_set(GF_NALUDmxCtx *ctx, char *data, u32 size, u32 ps_type, s32 ps_id)", "{", "GF_List *list = NULL, *alt_list = NULL;", "GF_NALUFFParam *sl;", "u32 i, count;", "u32 crc = gf_crc_32(data, size);", "if (ctx->codecid==GF_CODECID_HEVC) {", "switch (ps_type) {", "case GF_HEVC_NALU_VID_PARAM:", "if (!ctx->vps) ctx->vps = gf_list_new();", "list = ctx->vps;", "break;", "case GF_HEVC_NALU_SEQ_PARAM:", "list = ctx->sps;", "break;", "case GF_HEVC_NALU_PIC_PARAM:", "list = ctx->pps;", "break;", "default:", "assert(0);", "return;", "}", "} else if (ctx->codecid==GF_CODECID_VVC) {", "switch (ps_type) {", "case GF_VVC_NALU_VID_PARAM:", "if (!ctx->vps) ctx->vps = gf_list_new();", "list = ctx->vps;", "break;", "case GF_VVC_NALU_SEQ_PARAM:", "list = ctx->sps;", "break;", "case GF_VVC_NALU_PIC_PARAM:", "list = ctx->pps;", "break;", "case GF_VVC_NALU_DEC_PARAM:", "if (!ctx->vvc_dci) ctx->vvc_dci = gf_list_new();", "list = ctx->vvc_dci;", "break;", "case GF_VVC_NALU_APS_PREFIX:", "if (!ctx->vvc_aps_pre) ctx->vvc_aps_pre = gf_list_new();", "list = ctx->vvc_aps_pre;", "break;", "default:", "assert(0);", "return;", "}", "} else {", "switch (ps_type) {", "case GF_AVC_NALU_SVC_SUBSEQ_PARAM:", "case GF_AVC_NALU_SEQ_PARAM:", "list = ctx->sps;", "break;", "case GF_AVC_NALU_PIC_PARAM:", "list = ctx->pps;", "alt_list = ctx->pps_svc;", "break;", "case GF_AVC_NALU_SEQ_PARAM_EXT:", "if (!ctx->sps_ext) ctx->sps_ext = gf_list_new();", "list = ctx->sps_ext;", "break;", "default:", "assert(0);", "return;", "}", "}", "sl = NULL;", "count = gf_list_count(list);", "for (i=0; i<count; i++) {", "sl = gf_list_get(list, i);", "if (sl->id != ps_id) {", "sl = NULL;", "continue;", "}", "if (sl->crc == crc) return;", "break;", "}", "if (!sl && alt_list) {", "count = gf_list_count(alt_list);", "for (i=0; i<count; i++) {", "sl = gf_list_get(alt_list, i);", "if (sl->id != ps_id) {", "sl = NULL;", "continue;", "}", "if (sl->crc == crc) return;", "break;", "}", "}", "if (sl) {", "sl->data = gf_realloc(sl->data, size);", "memcpy(sl->data, data, size);", "sl->size = size;", "sl->crc = crc;", "ctx->ps_modified = GF_TRUE;", "return;", "}", "GF_SAFEALLOC(sl, GF_NALUFFParam);", "if (!sl) return;", "sl->data = gf_malloc(sizeof(char) * size);", "if (!sl->data) {", "gf_free(sl);", "return;", "}", "memcpy(sl->data, data, size);", "sl->size = size;", "sl->id = ps_id;", "sl->crc = crc;", "ctx->ps_modified = GF_TRUE;", "gf_list_add(list, sl);", "}"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int adts_decode_extradata(AVFormatContext *s, ADTSContext *adts, const uint8_t *buf, int size)", "{", "GetBitContext gb;", "PutBitContext pb;", "MPEG4AudioConfig m4ac;", "int off;", "init_get_bits(&gb, buf, size * 8);", "off = avpriv_mpeg4audio_get_config2(&m4ac, buf, size, 1, s);", "if (off < 0)", "return off;", "skip_bits_long(&gb, off);", "adts->objecttype        = m4ac.object_type - 1;", "adts->sample_rate_index = m4ac.sampling_index;", "adts->channel_conf      = m4ac.chan_config;", "if (adts->objecttype > 3U) {", "av_log(s, AV_LOG_ERROR, \"MPEG-4 AOT %d is not allowed in ADTS\\n\", adts->objecttype+1);", "return AVERROR_INVALIDDATA;", "}", "if (adts->sample_rate_index == 15) {", "av_log(s, AV_LOG_ERROR, \"Escape sample rate index illegal in ADTS\\n\");", "return AVERROR_INVALIDDATA;", "}", "if (get_bits(&gb, 1)) {", "av_log(s, AV_LOG_ERROR, \"960/120 MDCT window is not allowed in ADTS\\n\");", "return AVERROR_INVALIDDATA;", "}", "if (get_bits(&gb, 1)) {", "av_log(s, AV_LOG_ERROR, \"Scalable configurations are not allowed in ADTS\\n\");", "return AVERROR_INVALIDDATA;", "}", "if (get_bits(&gb, 1)) {", "av_log(s, AV_LOG_ERROR, \"Extension flag is not allowed in ADTS\\n\");", "return AVERROR_INVALIDDATA;", "}", "if (!adts->channel_conf) {", "init_put_bits(&pb, adts->pce_data, MAX_PCE_SIZE);", "put_bits(&pb, 3, 5);", "adts->pce_size = (ff_copy_pce_data(&pb, &gb) + 3) / 8;", "flush_put_bits(&pb);", "}", "adts->write_adts = 1;", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int cbs_jpeg_split_fragment(CodedBitstreamContext *ctx,", "CodedBitstreamFragment *frag,", "int header)", "{", "AVBufferRef *data_ref;", "uint8_t *data;", "size_t data_size;", "int unit, start, end, marker, next_start, next_marker;", "int err, i, j, length;", "if (frag->data_size < 4) {", "return AVERROR_INVALIDDATA;", "}", "for (i = 0; i + 1 < frag->data_size && frag->data[i] != 0xff; i++);", "if (i > 0) {", "av_log(ctx->log_ctx, AV_LOG_WARNING, \"Discarding %d bytes at \"", "\"beginning of image.\\n\", i);", "}", "for (++i; i + 1 < frag->data_size && frag->data[i] == 0xff; i++);", "if (i + 1 >= frag->data_size && frag->data[i]) {", "av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"", "\"no SOI marker found.\\n\");", "return AVERROR_INVALIDDATA;", "}", "marker = frag->data[i];", "if (marker != JPEG_MARKER_SOI) {", "av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: first \"", "\"marker is %02x, should be SOI.\\n\", marker);", "return AVERROR_INVALIDDATA;", "}", "for (++i; i + 1 < frag->data_size && frag->data[i] == 0xff; i++);", "if (i + 1 >= frag->data_size) {", "av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"", "\"no image content found.\\n\");", "return AVERROR_INVALIDDATA;", "}", "marker = frag->data[i];", "start  = i + 1;", "for (unit = 0;; unit++) {", "if (marker == JPEG_MARKER_EOI) {", "break;", "} else if (marker == JPEG_MARKER_SOS) {", "for (i = start; i + 1 < frag->data_size; i++) {", "if (frag->data[i] != 0xff)", "continue;", "end = i;", "for (++i; i + 1 < frag->data_size &&", "frag->data[i] == 0xff; i++);", "if (i + 1 >= frag->data_size) {", "next_marker = -1;", "} else {", "if (frag->data[i] == 0x00)", "continue;", "next_marker = frag->data[i];", "next_start  = i + 1;", "}", "break;", "}", "} else {", "i = start;", "if (i + 2 > frag->data_size) {", "av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"", "\"truncated at %02x marker.\\n\", marker);", "return AVERROR_INVALIDDATA;", "}", "length = AV_RB16(frag->data + i);", "if (i + length > frag->data_size) {", "av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"", "\"truncated at %02x marker segment.\\n\", marker);", "return AVERROR_INVALIDDATA;", "}", "end = start + length;", "i = end;", "if (frag->data[i] != 0xff) {", "next_marker = -1;", "} else {", "for (++i; i + 1 < frag->data_size &&", "frag->data[i] == 0xff; i++);", "if (i + 1 >= frag->data_size) {", "next_marker = -1;", "} else {", "next_marker = frag->data[i];", "next_start  = i + 1;", "}", "}", "}", "if (marker == JPEG_MARKER_SOS) {", "length = AV_RB16(frag->data + start);", "data_ref = NULL;", "data     = av_malloc(end - start +", "AV_INPUT_BUFFER_PADDING_SIZE);", "if (!data)", "return AVERROR(ENOMEM);", "memcpy(data, frag->data + start, length);", "for (i = start + length, j = length; i < end; i++, j++) {", "if (frag->data[i] == 0xff) {", "while (frag->data[i] == 0xff)", "++i;", "data[j] = 0xff;", "} else {", "data[j] = frag->data[i];", "}", "}", "data_size = j;", "memset(data + data_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);", "} else {", "data      = frag->data + start;", "data_size = end - start;", "data_ref  = frag->data_ref;", "}", "err = ff_cbs_insert_unit_data(ctx, frag, unit, marker,", "data, data_size, data_ref);", "if (err < 0) {", "if (!data_ref)", "av_freep(&data);", "return err;", "}", "if (next_marker == -1)", "break;", "marker = next_marker;", "start  = next_start;", "}", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["ProcessStartupPacket(Port *port, bool ssl_done, bool gss_done)", "{", "int32  len;", "char    *buf;", "ProtocolVersion proto;", "MemoryContext oldcontext;", "pq_startmsgread();", "if (pq_getbytes((char *) &len, 1) == EOF)", "{", "return STATUS_ERROR;", "}", "if (pq_getbytes(((char *) &len) + 1, 3) == EOF)", "{", "if (!ssl_done && !gss_done)", "ereport(COMMERROR,", "(errcode(ERRCODE_PROTOCOL_VIOLATION),", "errmsg(\"incomplete startup packet\")));", "return STATUS_ERROR;", "}", "len = pg_ntoh32(len);", "len -= 4;", "if (len < (int32) sizeof(ProtocolVersion) ||", "len > MAX_STARTUP_PACKET_LENGTH)", "{", "ereport(COMMERROR,", "(errcode(ERRCODE_PROTOCOL_VIOLATION),", "errmsg(\"invalid length of startup packet\")));", "return STATUS_ERROR;", "}", "buf = palloc(len + 1);", "buf[len] = '\\0';", "if (pq_getbytes(buf, len) == EOF)", "{", "ereport(COMMERROR,", "(errcode(ERRCODE_PROTOCOL_VIOLATION),", "errmsg(\"incomplete startup packet\")));", "return STATUS_ERROR;", "}", "pq_endmsgread();", "port->proto = proto = pg_ntoh32(*((ProtocolVersion *) buf));", "if (proto == CANCEL_REQUEST_CODE)", "{", "processCancelRequest(port, buf);", "return STATUS_ERROR;", "}", "if (proto == NEGOTIATE_SSL_CODE && !ssl_done)", "{", "char  SSLok;", "#ifdef USE_SSL", "if (!LoadedSSL || IS_AF_UNIX(port->laddr.addr.ss_family))", "SSLok = 'N';", "else", "SSLok = 'S';", "#else", "SSLok = 'N';", "#endif", "retry1:", "if (send(port->sock, &SSLok, 1, 0) != 1)", "{", "if (errno == EINTR)", "goto retry1;", "ereport(COMMERROR,", "(errcode_for_socket_access(),", "errmsg(\"failed to send SSL negotiation response: %m\")));", "return STATUS_ERROR;", "}", "#ifdef USE_SSL", "if (SSLok == 'S' && secure_open_server(port) == -1)", "return STATUS_ERROR;", "#endif", "return ProcessStartupPacket(port, true, SSLok == 'S');", "}", "else if (proto == NEGOTIATE_GSS_CODE && !gss_done)", "{", "char  GSSok = 'N';", "#ifdef ENABLE_GSS", "if (!IS_AF_UNIX(port->laddr.addr.ss_family))", "GSSok = 'G';", "#endif", "while (send(port->sock, &GSSok, 1, 0) != 1)", "{", "if (errno == EINTR)", "continue;", "ereport(COMMERROR,", "(errcode_for_socket_access(),", "errmsg(\"failed to send GSSAPI negotiation response: %m\")));", "return STATUS_ERROR;", "}", "#ifdef ENABLE_GSS", "if (GSSok == 'G' && secure_open_gssapi(port) == -1)", "return STATUS_ERROR;", "#endif", "return ProcessStartupPacket(port, GSSok == 'G', true);", "}", "FrontendProtocol = proto;", "if (PG_PROTOCOL_MAJOR(proto) < PG_PROTOCOL_MAJOR(PG_PROTOCOL_EARLIEST) ||", "PG_PROTOCOL_MAJOR(proto) > PG_PROTOCOL_MAJOR(PG_PROTOCOL_LATEST))", "ereport(FATAL,", "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),", "errmsg(\"unsupported frontend protocol %u.%u: server supports %u.0 to %u.%u\",", "PG_PROTOCOL_MAJOR(proto), PG_PROTOCOL_MINOR(proto),", "PG_PROTOCOL_MAJOR(PG_PROTOCOL_EARLIEST),", "PG_PROTOCOL_MAJOR(PG_PROTOCOL_LATEST),", "PG_PROTOCOL_MINOR(PG_PROTOCOL_LATEST))));", "oldcontext = MemoryContextSwitchTo(TopMemoryContext);", "{", "int32  offset = sizeof(ProtocolVersion);", "List    *unrecognized_protocol_options = NIL;", "port->guc_options = NIL;", "while (offset < len)", "{", "char    *nameptr = buf + offset;", "int32  valoffset;", "char    *valptr;", "if (*nameptr == '\\0')", "break;", "valoffset = offset + strlen(nameptr) + 1;", "if (valoffset >= len)", "break;", "valptr = buf + valoffset;", "if (strcmp(nameptr, \"database\") == 0)", "port->database_name = pstrdup(valptr);", "else if (strcmp(nameptr, \"user\") == 0)", "port->user_name = pstrdup(valptr);", "else if (strcmp(nameptr, \"options\") == 0)", "port->cmdline_options = pstrdup(valptr);", "else if (strcmp(nameptr, \"replication\") == 0)", "{", "if (strcmp(valptr, \"database\") == 0)", "{", "am_walsender = true;", "am_db_walsender = true;", "}", "else if (!parse_bool(valptr, &am_walsender))", "ereport(FATAL,", "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),", "errmsg(\"invalid value for parameter \\\"%s\\\": \\\"%s\\\"\",", "\"replication\",", "valptr),", "errhint(\"Valid values are: \\\"false\\\", 0, \\\"true\\\", 1, \\\"database\\\".\")));", "}", "else if (strncmp(nameptr, \"_pq_.\", 5) == 0)", "{", "unrecognized_protocol_options =", "lappend(unrecognized_protocol_options, pstrdup(nameptr));", "}", "else", "{", "port->guc_options = lappend(port->guc_options,", "pstrdup(nameptr));", "port->guc_options = lappend(port->guc_options,", "pstrdup(valptr));", "if (strcmp(nameptr, \"application_name\") == 0)", "{", "char    *tmp_app_name = pstrdup(valptr);", "pg_clean_ascii(tmp_app_name);", "port->application_name = tmp_app_name;", "}", "}", "offset = valoffset + strlen(valptr) + 1;", "}", "if (offset != len - 1)", "ereport(FATAL,", "(errcode(ERRCODE_PROTOCOL_VIOLATION),", "errmsg(\"invalid startup packet layout: expected terminator as last byte\")));", "if (PG_PROTOCOL_MINOR(proto) > PG_PROTOCOL_MINOR(PG_PROTOCOL_LATEST) ||", "unrecognized_protocol_options != NIL)", "SendNegotiateProtocolVersion(unrecognized_protocol_options);", "}", "if (port->user_name == NULL || port->user_name[0] == '\\0')", "ereport(FATAL,", "(errcode(ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION),", "errmsg(\"no PostgreSQL user name specified in startup packet\")));", "if (port->database_name == NULL || port->database_name[0] == '\\0')", "port->database_name = pstrdup(port->user_name);", "if (Db_user_namespace)", "{", "if (strchr(port->user_name, '@') ==", "port->user_name + strlen(port->user_name) - 1)", "*strchr(port->user_name, '@') = '\\0';", "else", "{", "port->user_name = psprintf(\"%s@%s\", port->user_name, port->database_name);", "}", "}", "if (strlen(port->database_name) >= NAMEDATALEN)", "port->database_name[NAMEDATALEN - 1] = '\\0';", "if (strlen(port->user_name) >= NAMEDATALEN)", "port->user_name[NAMEDATALEN - 1] = '\\0';", "if (am_walsender)", "MyBackendType = B_WAL_SENDER;", "else", "MyBackendType = B_BACKEND;", "if (am_walsender && !am_db_walsender)", "port->database_name[0] = '\\0';", "MemoryContextSwitchTo(oldcontext);", "switch (port->canAcceptConnections)", "{", "case CAC_STARTUP:", "ereport(FATAL,", "(errcode(ERRCODE_CANNOT_CONNECT_NOW),", "errmsg(\"the database system is starting up\")));", "break;", "case CAC_NOTCONSISTENT:", "if (EnableHotStandby)", "ereport(FATAL,", "(errcode(ERRCODE_CANNOT_CONNECT_NOW),", "errmsg(\"the database system is not yet accepting connections\"),", "errdetail(\"Consistent recovery state has not been yet reached.\")));", "else", "ereport(FATAL,", "(errcode(ERRCODE_CANNOT_CONNECT_NOW),", "errmsg(\"the database system is not accepting connections\"),", "errdetail(\"Hot standby mode is disabled.\")));", "break;", "case CAC_SHUTDOWN:", "ereport(FATAL,", "(errcode(ERRCODE_CANNOT_CONNECT_NOW),", "errmsg(\"the database system is shutting down\")));", "break;", "case CAC_RECOVERY:", "ereport(FATAL,", "(errcode(ERRCODE_CANNOT_CONNECT_NOW),", "errmsg(\"the database system is in recovery mode\")));", "break;", "case CAC_TOOMANY:", "ereport(FATAL,", "(errcode(ERRCODE_TOO_MANY_CONNECTIONS),", "errmsg(\"sorry, too many clients already\")));", "break;", "case CAC_SUPERUSER:", "break;", "case CAC_OK:", "break;", "}", "return STATUS_OK;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int show_stream(WriterContext *w, AVFormatContext *fmt_ctx, int stream_idx, InputStream *ist, int in_program)", "{", "AVStream *stream = ist->st;", "AVCodecParameters *par;", "AVCodecContext *dec_ctx;", "char val_str[128];", "const char *s;", "AVRational sar, dar;", "AVBPrint pbuf;", "const AVCodecDescriptor *cd;", "int ret = 0;", "const char *profile = NULL;", "av_bprint_init(&pbuf, 1, AV_BPRINT_SIZE_UNLIMITED);", "writer_print_section_header(w, in_program ? SECTION_ID_PROGRAM_STREAM : SECTION_ID_STREAM);", "print_int(\"index\", stream->index);", "par     = stream->codecpar;", "dec_ctx = ist->dec_ctx;", "if (cd = avcodec_descriptor_get(par->codec_id)) {", "print_str(\"codec_name\", cd->name);", "if (!do_bitexact) {", "print_str(\"codec_long_name\",", "cd->long_name ? cd->long_name : \"unknown\");", "}", "} else {", "print_str_opt(\"codec_name\", \"unknown\");", "if (!do_bitexact) {", "print_str_opt(\"codec_long_name\", \"unknown\");", "}", "}", "if (!do_bitexact && (profile = avcodec_profile_name(par->codec_id, par->profile)))", "print_str(\"profile\", profile);", "else {", "if (par->profile != FF_PROFILE_UNKNOWN) {", "char profile_num[12];", "snprintf(profile_num, sizeof(profile_num), \"%d\", par->profile);", "print_str(\"profile\", profile_num);", "} else", "print_str_opt(\"profile\", \"unknown\");", "}", "s = av_get_media_type_string(par->codec_type);", "if (s) print_str    (\"codec_type\", s);", "else   print_str_opt(\"codec_type\", \"unknown\");", "#if FF_API_LAVF_AVCTX", "if (dec_ctx)", "print_q(\"codec_time_base\", dec_ctx->time_base, '/');", "#endif", "print_str(\"codec_tag_string\",    av_fourcc2str(par->codec_tag));", "print_fmt(\"codec_tag\", \"0x%04\"PRIx32, par->codec_tag);", "switch (par->codec_type) {", "case AVMEDIA_TYPE_VIDEO:", "print_int(\"width\",        par->width);", "print_int(\"height\",       par->height);", "if (dec_ctx) {", "print_int(\"coded_width\",  dec_ctx->coded_width);", "print_int(\"coded_height\", dec_ctx->coded_height);", "}", "print_int(\"has_b_frames\", par->video_delay);", "sar = av_guess_sample_aspect_ratio(fmt_ctx, stream, NULL);", "if (sar.den) {", "print_q(\"sample_aspect_ratio\", sar, ':');", "av_reduce(&dar.num, &dar.den,", "par->width  * sar.num,", "par->height * sar.den,", "1024*1024);", "print_q(\"display_aspect_ratio\", dar, ':');", "} else {", "print_str_opt(\"sample_aspect_ratio\", \"N/A\");", "print_str_opt(\"display_aspect_ratio\", \"N/A\");", "}", "s = av_get_pix_fmt_name(par->format);", "if (s) print_str    (\"pix_fmt\", s);", "else   print_str_opt(\"pix_fmt\", \"unknown\");", "print_int(\"level\",   par->level);", "if (par->color_range != AVCOL_RANGE_UNSPECIFIED)", "print_str    (\"color_range\", av_color_range_name(par->color_range));", "else", "print_str_opt(\"color_range\", \"N/A\");", "if (par->color_space != AVCOL_SPC_UNSPECIFIED)", "print_str(\"color_space\", av_color_space_name(par->color_space));", "else", "print_str_opt(\"color_space\", av_color_space_name(par->color_space));", "if (par->color_trc != AVCOL_TRC_UNSPECIFIED)", "print_str(\"color_transfer\", av_color_transfer_name(par->color_trc));", "else", "print_str_opt(\"color_transfer\", av_color_transfer_name(par->color_trc));", "if (par->color_primaries != AVCOL_PRI_UNSPECIFIED)", "print_str(\"color_primaries\", av_color_primaries_name(par->color_primaries));", "else", "print_str_opt(\"color_primaries\", av_color_primaries_name(par->color_primaries));", "if (par->chroma_location != AVCHROMA_LOC_UNSPECIFIED)", "print_str(\"chroma_location\", av_chroma_location_name(par->chroma_location));", "else", "print_str_opt(\"chroma_location\", av_chroma_location_name(par->chroma_location));", "if (par->field_order == AV_FIELD_PROGRESSIVE)", "print_str(\"field_order\", \"progressive\");", "else if (par->field_order == AV_FIELD_TT)", "print_str(\"field_order\", \"tt\");", "else if (par->field_order == AV_FIELD_BB)", "print_str(\"field_order\", \"bb\");", "else if (par->field_order == AV_FIELD_TB)", "print_str(\"field_order\", \"tb\");", "else if (par->field_order == AV_FIELD_BT)", "print_str(\"field_order\", \"bt\");", "else", "print_str_opt(\"field_order\", \"unknown\");", "#if FF_API_PRIVATE_OPT", "if (dec_ctx && dec_ctx->timecode_frame_start >= 0) {", "char tcbuf[AV_TIMECODE_STR_SIZE];", "av_timecode_make_mpeg_tc_string(tcbuf, dec_ctx->timecode_frame_start);", "print_str(\"timecode\", tcbuf);", "} else {", "print_str_opt(\"timecode\", \"N/A\");", "}", "#endif", "if (dec_ctx)", "print_int(\"refs\", dec_ctx->refs);", "break;", "case AVMEDIA_TYPE_AUDIO:", "s = av_get_sample_fmt_name(par->format);", "if (s) print_str    (\"sample_fmt\", s);", "else   print_str_opt(\"sample_fmt\", \"unknown\");", "print_val(\"sample_rate\",     par->sample_rate, unit_hertz_str);", "print_int(\"channels\",        par->channels);", "if (par->channel_layout) {", "av_bprint_clear(&pbuf);", "av_bprint_channel_layout(&pbuf, par->channels, par->channel_layout);", "print_str    (\"channel_layout\", pbuf.str);", "} else {", "print_str_opt(\"channel_layout\", \"unknown\");", "}", "print_int(\"bits_per_sample\", av_get_bits_per_sample(par->codec_id));", "break;", "case AVMEDIA_TYPE_SUBTITLE:", "if (par->width)", "print_int(\"width\",       par->width);", "else", "print_str_opt(\"width\",   \"N/A\");", "if (par->height)", "print_int(\"height\",      par->height);", "else", "print_str_opt(\"height\",  \"N/A\");", "break;", "}", "if (dec_ctx && dec_ctx->codec && dec_ctx->codec->priv_class && show_private_data) {", "const AVOption *opt = NULL;", "while (opt = av_opt_next(dec_ctx->priv_data,opt)) {", "uint8_t *str;", "if (opt->flags) continue;", "if (av_opt_get(dec_ctx->priv_data, opt->name, 0, &str) >= 0) {", "print_str(opt->name, str);", "av_free(str);", "}", "}", "}", "if (fmt_ctx->iformat->flags & AVFMT_SHOW_IDS) print_fmt    (\"id\", \"0x%x\", stream->id);", "else                                          print_str_opt(\"id\", \"N/A\");", "print_q(\"r_frame_rate\",   stream->r_frame_rate,   '/');", "print_q(\"avg_frame_rate\", stream->avg_frame_rate, '/');", "print_q(\"time_base\",      stream->time_base,      '/');", "print_ts  (\"start_pts\",   stream->start_time);", "print_time(\"start_time\",  stream->start_time, &stream->time_base);", "print_ts  (\"duration_ts\", stream->duration);", "print_time(\"duration\",    stream->duration, &stream->time_base);", "if (par->bit_rate > 0)     print_val    (\"bit_rate\", par->bit_rate, unit_bit_per_second_str);", "else                       print_str_opt(\"bit_rate\", \"N/A\");", "#if FF_API_LAVF_AVCTX", "if (stream->codec->rc_max_rate > 0) print_val (\"max_bit_rate\", stream->codec->rc_max_rate, unit_bit_per_second_str);", "else                                print_str_opt(\"max_bit_rate\", \"N/A\");", "#endif", "if (dec_ctx && dec_ctx->bits_per_raw_sample > 0) print_fmt(\"bits_per_raw_sample\", \"%d\", dec_ctx->bits_per_raw_sample);", "else                                             print_str_opt(\"bits_per_raw_sample\", \"N/A\");", "if (stream->nb_frames) print_fmt    (\"nb_frames\", \"%\"PRId64, stream->nb_frames);", "else                   print_str_opt(\"nb_frames\", \"N/A\");", "if (nb_streams_frames[stream_idx])  print_fmt    (\"nb_read_frames\", \"%\"PRIu64, nb_streams_frames[stream_idx]);", "else                                print_str_opt(\"nb_read_frames\", \"N/A\");", "if (nb_streams_packets[stream_idx]) print_fmt    (\"nb_read_packets\", \"%\"PRIu64, nb_streams_packets[stream_idx]);", "else                                print_str_opt(\"nb_read_packets\", \"N/A\");", "if (do_show_data)", "writer_print_data(w, \"extradata\", par->extradata,", "par->extradata_size);", "writer_print_data_hash(w, \"extradata_hash\", par->extradata,", "par->extradata_size);", "#define PRINT_DISPOSITION(flagname, name) do {                                \\", "        print_int(name, !!(stream->disposition & AV_DISPOSITION_##flagname)); \\", "    } while (0)", "if (do_show_stream_disposition) {", "writer_print_section_header(w, in_program ? SECTION_ID_PROGRAM_STREAM_DISPOSITION : SECTION_ID_STREAM_DISPOSITION);", "PRINT_DISPOSITION(DEFAULT,          \"default\");", "PRINT_DISPOSITION(DUB,              \"dub\");", "PRINT_DISPOSITION(ORIGINAL,         \"original\");", "PRINT_DISPOSITION(COMMENT,          \"comment\");", "PRINT_DISPOSITION(LYRICS,           \"lyrics\");", "PRINT_DISPOSITION(KARAOKE,          \"karaoke\");", "PRINT_DISPOSITION(FORCED,           \"forced\");", "PRINT_DISPOSITION(HEARING_IMPAIRED, \"hearing_impaired\");", "PRINT_DISPOSITION(VISUAL_IMPAIRED,  \"visual_impaired\");", "PRINT_DISPOSITION(CLEAN_EFFECTS,    \"clean_effects\");", "PRINT_DISPOSITION(ATTACHED_PIC,     \"attached_pic\");", "PRINT_DISPOSITION(TIMED_THUMBNAILS, \"timed_thumbnails\");", "writer_print_section_footer(w);", "}", "if (do_show_stream_tags)", "ret = show_tags(w, stream->metadata, in_program ? SECTION_ID_PROGRAM_STREAM_TAGS : SECTION_ID_STREAM_TAGS);", "if (stream->nb_side_data) {", "print_pkt_side_data(w, stream->codecpar, stream->side_data, stream->nb_side_data,", "SECTION_ID_STREAM_SIDE_DATA_LIST,", "SECTION_ID_STREAM_SIDE_DATA);", "}", "writer_print_section_footer(w);", "av_bprint_finalize(&pbuf, NULL);", "fflush(stdout);", "return ret;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)", "{", "mp4object *mp4 = (mp4object *)malloc(sizeof(mp4object));", "if (mp4 == NULL) return 0;", "memset(mp4, 0, sizeof(mp4object));", "#ifdef _WINDOWS", "fopen_s(&mp4->mediafp, filename, \"rb\");", "#else", "mp4->mediafp = fopen(filename, \"rb\");", "#endif", "if (mp4->mediafp)", "{", "uint32_t qttag, qtsize32, skip, type = 0, subtype = 0, num;", "size_t len;", "int32_t nest = 0;", "uint64_t nestsize[MAX_NEST_LEVEL] = { 0 };", "uint64_t lastsize = 0, qtsize;", "do", "{", "len = fread(&qtsize32, 1, 4, mp4->mediafp);", "len += fread(&qttag, 1, 4, mp4->mediafp);", "if (len == 8)", "{", "if (!VALID_FOURCC(qttag))", "{", "LONGSEEK(mp4->mediafp, lastsize - 8 - 8, SEEK_CUR);", "NESTSIZE(lastsize - 8);", "continue;", "}", "qtsize32 = BYTESWAP32(qtsize32);", "if (qtsize32 == 1)", "{", "fread(&qtsize, 1, 8, mp4->mediafp);", "qtsize = BYTESWAP64(qtsize) - 8;", "}", "else", "qtsize = qtsize32;", "nest++;", "if (qtsize < 8) break;", "if (nest >= MAX_NEST_LEVEL) break;", "nestsize[nest] = qtsize;", "lastsize = qtsize;", "#if PRINT_MP4_STRUCTURE\t", "for (int i = 1; i < nest; i++) printf(\"    \");", "printf(\"%c%c%c%c (%lld)\\n\", (qttag & 0xff), ((qttag >> 8) & 0xff), ((qttag >> 16) & 0xff), ((qttag >> 24) & 0xff), qtsize);", "if (qttag == MAKEID('m', 'd', 'a', 't') ||", "qttag == MAKEID('f', 't', 'y', 'p') ||", "qttag == MAKEID('u', 'd', 't', 'a'))", "{", "LONGSEEK(mediafp, qtsize - 8, SEEK_CUR);", "NESTSIZE(qtsize);", "continue;", "}", "#else", "if (qttag != MAKEID('m', 'o', 'o', 'v') &&", "qttag != MAKEID('m', 'v', 'h', 'd') &&", "qttag != MAKEID('t', 'r', 'a', 'k') &&", "qttag != MAKEID('m', 'd', 'i', 'a') &&", "qttag != MAKEID('m', 'd', 'h', 'd') &&", "qttag != MAKEID('m', 'i', 'n', 'f') &&", "qttag != MAKEID('g', 'm', 'i', 'n') &&", "qttag != MAKEID('d', 'i', 'n', 'f') &&", "qttag != MAKEID('a', 'l', 'i', 's') &&", "qttag != MAKEID('s', 't', 's', 'd') &&", "qttag != MAKEID('a', 'l', 'i', 's') &&", "qttag != MAKEID('a', 'l', 'i', 's') &&", "qttag != MAKEID('s', 't', 'b', 'l') &&", "qttag != MAKEID('s', 't', 't', 's') &&", "qttag != MAKEID('s', 't', 's', 'c') &&", "qttag != MAKEID('s', 't', 's', 'z') &&", "qttag != MAKEID('s', 't', 'c', 'o') &&", "qttag != MAKEID('c', 'o', '6', '4') &&", "qttag != MAKEID('h', 'd', 'l', 'r'))", "{", "LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);", "NESTSIZE(qtsize);", "}", "else", "#endif", "if (qttag == MAKEID('m', 'v', 'h', 'd'))", "{", "len = fread(&skip, 1, 4, mp4->mediafp);", "len += fread(&skip, 1, 4, mp4->mediafp);", "len += fread(&skip, 1, 4, mp4->mediafp);", "len += fread(&mp4->clockdemon, 1, 4, mp4->mediafp); mp4->clockdemon = BYTESWAP32(mp4->clockdemon);", "len += fread(&mp4->clockcount, 1, 4, mp4->mediafp); mp4->clockcount = BYTESWAP32(mp4->clockcount);", "LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);", "NESTSIZE(qtsize);", "}", "else if (qttag == MAKEID('m', 'd', 'h', 'd'))", "{", "media_header md;", "len = fread(&md, 1, sizeof(md), mp4->mediafp);", "if (len == sizeof(md))", "{", "md.creation_time = BYTESWAP32(md.creation_time);", "md.modification_time = BYTESWAP32(md.modification_time);", "md.time_scale = BYTESWAP32(md.time_scale);", "md.duration = BYTESWAP32(md.duration);", "mp4->trak_clockdemon = md.time_scale;", "mp4->trak_clockcount = md.duration;", "if (mp4->videolength == 0.0)", "{", "mp4->videolength = (float)((double)mp4->trak_clockcount / (double)mp4->trak_clockdemon);", "}", "}", "LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);", "NESTSIZE(qtsize);", "}", "else if (qttag == MAKEID('h', 'd', 'l', 'r'))", "{", "uint32_t temp;", "len = fread(&skip, 1, 4, mp4->mediafp);", "len += fread(&skip, 1, 4, mp4->mediafp);", "len += fread(&temp, 1, 4, mp4->mediafp);", "if (temp != MAKEID('a', 'l', 'i', 's'))", "type = temp;", "LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);", "NESTSIZE(qtsize);", "}", "else if (qttag == MAKEID('s', 't', 's', 'd'))", "{", "if (type == traktype)", "{", "len = fread(&skip, 1, 4, mp4->mediafp);", "len += fread(&skip, 1, 4, mp4->mediafp);", "len += fread(&skip, 1, 4, mp4->mediafp);", "len += fread(&subtype, 1, 4, mp4->mediafp);", "if (len == 16)", "{", "if (subtype != traksubtype)", "{", "type = 0;", "}", "}", "LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);", "}", "else", "LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);", "NESTSIZE(qtsize);", "}", "else if (qttag == MAKEID('s', 't', 's', 'c'))", "{", "if (type == traktype)", "{", "len = fread(&skip, 1, 4, mp4->mediafp);", "len += fread(&num, 1, 4, mp4->mediafp);", "num = BYTESWAP32(num);", "if (num * 12 <= qtsize - 8 - len)", "{", "mp4->metastsc_count = num;", "if (mp4->metastsc) free(mp4->metastsc);", "mp4->metastsc = (SampleToChunk *)malloc(num * 12);", "if (mp4->metastsc)", "{", "uint32_t total_stsc = num;", "len += fread(mp4->metastsc, 1, num * sizeof(SampleToChunk), mp4->mediafp);", "do", "{", "num--;", "mp4->metastsc[num].chunk_num = BYTESWAP32(mp4->metastsc[num].chunk_num);", "mp4->metastsc[num].samples = BYTESWAP32(mp4->metastsc[num].samples);", "mp4->metastsc[num].id = BYTESWAP32(mp4->metastsc[num].id);", "} while (num > 0);", "}", "if (mp4->metastsc_count == 1 && mp4->metastsc[0].samples == 1)", "{", "if (mp4->metastsc) free(mp4->metastsc);", "mp4->metastsc = NULL;", "mp4->metastsc_count = 0;", "}", "}", "LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);", "}", "else", "LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);", "NESTSIZE(qtsize);", "}", "else if (qttag == MAKEID('s', 't', 's', 'z'))", "{", "if (type == traktype)", "{", "uint32_t equalsamplesize;", "len = fread(&skip, 1, 4, mp4->mediafp);", "len += fread(&equalsamplesize, 1, 4, mp4->mediafp);", "len += fread(&num, 1, 4, mp4->mediafp);", "num = BYTESWAP32(num);", "if (num * 4 <= qtsize - 8 - len)", "{", "mp4->metasize_count = num;", "if (mp4->metasizes) free(mp4->metasizes);", "mp4->metasizes = (uint32_t *)malloc(num * 4);", "if (mp4->metasizes)", "{", "if (equalsamplesize == 0)", "{", "len += fread(mp4->metasizes, 1, num * 4, mp4->mediafp);", "do", "{", "num--;", "mp4->metasizes[num] = BYTESWAP32(mp4->metasizes[num]);", "} while (num > 0);", "}", "else", "{", "equalsamplesize = BYTESWAP32(equalsamplesize);", "do", "{", "num--;", "mp4->metasizes[num] = equalsamplesize;", "} while (num > 0);", "}", "}", "}", "LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);", "}", "else", "LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);", "NESTSIZE(qtsize);", "}", "else if (qttag == MAKEID('s', 't', 'c', 'o'))", "{", "if (type == traktype)", "{", "len = fread(&skip, 1, 4, mp4->mediafp);", "len += fread(&num, 1, 4, mp4->mediafp);", "num = BYTESWAP32(num);", "if (num * 4 <= qtsize - 8 - len)", "{", "if (mp4->metastsc_count > 0 && num != mp4->metasize_count)", "{", "mp4->indexcount = mp4->metasize_count;", "if (mp4->metaoffsets) free(mp4->metaoffsets);", "mp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);", "if (mp4->metaoffsets)", "{", "uint32_t *metaoffsets32 = NULL;", "metaoffsets32 = (uint32_t *)malloc(num * 4);", "if (metaoffsets32)", "{", "uint64_t fileoffset = 0;", "int stsc_pos = 0;", "int stco_pos = 0;", "int repeat = 1;", "len += fread(metaoffsets32, 1, num * 4, mp4->mediafp);", "do", "{", "num--;", "metaoffsets32[num] = BYTESWAP32(metaoffsets32[num]);", "} while (num > 0);", "mp4->metaoffsets[0] = fileoffset = metaoffsets32[stco_pos];", "num = 1;", "while (num < mp4->metasize_count)", "{", "if (stsc_pos + 1 < (int)mp4->metastsc_count && num == stsc_pos)", "{", "stco_pos++; stsc_pos++;", "fileoffset = (uint64_t)metaoffsets32[stco_pos];", "repeat = 1;", "}", "else if (repeat == mp4->metastsc[stsc_pos].samples)", "{", "stco_pos++;", "fileoffset = (uint64_t)metaoffsets32[stco_pos];", "repeat = 1;", "}", "else", "{", "fileoffset += (uint64_t)mp4->metasizes[num - 1];", "repeat++;", "}", "mp4->metaoffsets[num] = fileoffset;", "num++;", "}", "if (mp4->metastsc) free(mp4->metastsc);", "mp4->metastsc = NULL;", "mp4->metastsc_count = 0;", "free(metaoffsets32);", "}", "}", "}", "else", "{", "mp4->indexcount = num;", "if (mp4->metaoffsets) free(mp4->metaoffsets);", "mp4->metaoffsets = (uint64_t *)malloc(num * 8);", "if (mp4->metaoffsets)", "{", "uint32_t *metaoffsets32 = NULL;", "metaoffsets32 = (uint32_t *)malloc(num * 4);", "if (metaoffsets32)", "{", "size_t readlen = fread(metaoffsets32, 1, num * 4, mp4->mediafp);", "len += readlen;", "do", "{", "num--;", "mp4->metaoffsets[num] = BYTESWAP32(metaoffsets32[num]);", "} while (num > 0);", "free(metaoffsets32);", "}", "}", "}", "}", "LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);", "}", "else", "LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);", "NESTSIZE(qtsize);", "}", "else if (qttag == MAKEID('c', 'o', '6', '4'))", "{", "if (type == traktype)", "{", "len = fread(&skip, 1, 4, mp4->mediafp);", "len += fread(&num, 1, 4, mp4->mediafp);", "num = BYTESWAP32(num);", "if (num * 8 <= qtsize - 8 - len)", "{", "if (mp4->metastsc_count > 0 && num != mp4->metasize_count)", "{", "mp4->indexcount = mp4->metasize_count;", "if (mp4->metaoffsets) free(mp4->metaoffsets);", "mp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);", "if (mp4->metaoffsets)", "{", "uint64_t *metaoffsets64 = NULL;", "metaoffsets64 = (uint64_t *)malloc(num * 8);", "if (metaoffsets64)", "{", "uint64_t fileoffset = 0;", "int stsc_pos = 0;", "int stco_pos = 0;", "len += fread(metaoffsets64, 1, num * 8, mp4->mediafp);", "do", "{", "num--;", "metaoffsets64[num] = BYTESWAP64(metaoffsets64[num]);", "} while (num > 0);", "fileoffset = metaoffsets64[0];", "mp4->metaoffsets[0] = fileoffset;", "num = 1;", "while (num < mp4->metasize_count)", "{", "if (num != mp4->metastsc[stsc_pos].chunk_num - 1 && 0 == (num - (mp4->metastsc[stsc_pos].chunk_num - 1)) % mp4->metastsc[stsc_pos].samples)", "{", "stco_pos++;", "fileoffset = (uint64_t)metaoffsets64[stco_pos];", "}", "else", "{", "fileoffset += (uint64_t)mp4->metasizes[num - 1];", "}", "mp4->metaoffsets[num] = fileoffset;", "num++;", "}", "if (mp4->metastsc) free(mp4->metastsc);", "mp4->metastsc = NULL;", "mp4->metastsc_count = 0;", "free(metaoffsets64);", "}", "}", "}", "else", "{", "mp4->indexcount = num;", "if (mp4->metaoffsets) free(mp4->metaoffsets);", "mp4->metaoffsets = (uint64_t *)malloc(num * 8);", "if (mp4->metaoffsets)", "{", "len += fread(mp4->metaoffsets, 1, num * 8, mp4->mediafp);", "do", "{", "num--;", "mp4->metaoffsets[num] = BYTESWAP64(mp4->metaoffsets[num]);", "} while (num > 0);", "}", "}", "}", "LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);", "}", "else", "LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);", "NESTSIZE(qtsize);", "}", "else if (qttag == MAKEID('s', 't', 't', 's'))", "{", "if (type == traktype)", "{", "uint32_t totaldur = 0, samples = 0;", "int32_t entries = 0;", "len = fread(&skip, 1, 4, mp4->mediafp);", "len += fread(&num, 1, 4, mp4->mediafp);", "num = BYTESWAP32(num);", "if (num * 8 <= qtsize - 8 - len)", "{", "entries = num;", "mp4->meta_clockdemon = mp4->trak_clockdemon;", "mp4->meta_clockcount = mp4->trak_clockcount;", "while (entries > 0)", "{", "int32_t samplecount;", "int32_t duration;", "len += fread(&samplecount, 1, 4, mp4->mediafp);", "samplecount = BYTESWAP32(samplecount);", "len += fread(&duration, 1, 4, mp4->mediafp);", "duration = BYTESWAP32(duration);", "samples += samplecount;", "entries--;", "totaldur += duration;", "mp4->metadatalength += (double)((double)samplecount * (double)duration / (double)mp4->meta_clockdemon);", "}", "mp4->basemetadataduration = mp4->metadatalength * (double)mp4->meta_clockdemon / (double)samples;", "}", "LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);", "}", "else", "LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);", "NESTSIZE(qtsize);", "}", "else", "{", "NESTSIZE(8);", "}", "}", "else", "{", "break;", "}", "} while (len > 0);", "}", "else", "{", "free(mp4);", "mp4 = NULL;", "}", "return (size_t)mp4;", "}"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int flattenSubquery(", "Parse *pParse,", "Select *p,", "int iFrom,", "int isAgg", "){", "const char *zSavedAuthContext = pParse->zAuthContext;", "Select *pParent;", "Select *pSub;", "Select *pSub1;", "SrcList *pSrc;", "SrcList *pSubSrc;", "int iParent;", "int iNewParent = -1;", "int isLeftJoin = 0;", "int i;", "Expr *pWhere;", "struct SrcList_item *pSubitem;", "sqlite3 *db = pParse->db;", "assert( p!=0 );", "assert( p->pPrior==0 );", "if( OptimizationDisabled(db, SQLITE_QueryFlattener) ) return 0;", "pSrc = p->pSrc;", "assert( pSrc && iFrom>=0 && iFrom<pSrc->nSrc );", "pSubitem = &pSrc->a[iFrom];", "iParent = pSubitem->iCursor;", "pSub = pSubitem->pSelect;", "assert( pSub!=0 );", "#ifndef SQLITE_OMIT_WINDOWFUNC", "if( p->pWin || pSub->pWin ) return 0;", "#endif", "pSubSrc = pSub->pSrc;", "assert( pSubSrc );", "if( pSub->pLimit && p->pLimit ) return 0;", "if( pSub->pLimit && pSub->pLimit->pRight ) return 0;", "if( (p->selFlags & SF_Compound)!=0 && pSub->pLimit ){", "return 0;", "}", "if( pSubSrc->nSrc==0 ) return 0;", "if( pSub->selFlags & SF_Distinct ) return 0;", "if( pSub->pLimit && (pSrc->nSrc>1 || isAgg) ){", "return 0;", "}", "if( p->pOrderBy && pSub->pOrderBy ){", "return 0;", "}", "if( isAgg && pSub->pOrderBy ) return 0;", "if( pSub->pLimit && p->pWhere ) return 0;", "if( pSub->pLimit && (p->selFlags & SF_Distinct)!=0 ){", "return 0;", "}", "if( pSub->selFlags & (SF_Recursive) ){", "return 0;", "}", "if( (pSubitem->fg.jointype & JT_OUTER)!=0 ){", "isLeftJoin = 1;", "if( pSubSrc->nSrc>1 || isAgg || IsVirtual(pSubSrc->a[0].pTab) ){", "return 0;", "}", "}", "#ifdef SQLITE_EXTRA_IFNULLROW", "else if( iFrom>0 && !isAgg ){", "isLeftJoin = -1;", "}", "#endif", "if( pSub->pPrior ){", "if( pSub->pOrderBy ){", "return 0;", "}", "if( isAgg || (p->selFlags & SF_Distinct)!=0 || pSrc->nSrc!=1 ){", "return 0;", "}", "for(pSub1=pSub; pSub1; pSub1=pSub1->pPrior){", "testcase( (pSub1->selFlags & (SF_Distinct|SF_Aggregate))==SF_Distinct );", "testcase( (pSub1->selFlags & (SF_Distinct|SF_Aggregate))==SF_Aggregate );", "assert( pSub->pSrc!=0 );", "assert( pSub->pEList->nExpr==pSub1->pEList->nExpr );", "if( (pSub1->selFlags & (SF_Distinct|SF_Aggregate))!=0", "|| (pSub1->pPrior && pSub1->op!=TK_ALL)", "|| pSub1->pSrc->nSrc<1", "){", "return 0;", "}", "testcase( pSub1->pSrc->nSrc>1 );", "}", "if( p->pOrderBy ){", "int ii;", "for(ii=0; ii<p->pOrderBy->nExpr; ii++){", "if( p->pOrderBy->a[ii].u.x.iOrderByCol==0 ) return 0;", "}", "}", "}", "assert( (p->selFlags & SF_Recursive)==0 || pSub->pPrior==0 );", "SELECTTRACE(1,pParse,p,(\"flatten %u.%p from term %d\\n\",", "pSub->selId, pSub, iFrom));", "pParse->zAuthContext = pSubitem->zName;", "TESTONLY(i =) sqlite3AuthCheck(pParse, SQLITE_SELECT, 0, 0, 0);", "testcase( i==SQLITE_DENY );", "pParse->zAuthContext = zSavedAuthContext;", "for(pSub=pSub->pPrior; pSub; pSub=pSub->pPrior){", "Select *pNew;", "ExprList *pOrderBy = p->pOrderBy;", "Expr *pLimit = p->pLimit;", "Select *pPrior = p->pPrior;", "p->pOrderBy = 0;", "p->pSrc = 0;", "p->pPrior = 0;", "p->pLimit = 0;", "pNew = sqlite3SelectDup(db, p, 0);", "p->pLimit = pLimit;", "p->pOrderBy = pOrderBy;", "p->pSrc = pSrc;", "p->op = TK_ALL;", "if( pNew==0 ){", "p->pPrior = pPrior;", "}else{", "pNew->pPrior = pPrior;", "if( pPrior ) pPrior->pNext = pNew;", "pNew->pNext = p;", "p->pPrior = pNew;", "SELECTTRACE(2,pParse,p,(\"compound-subquery flattener\"", "\" creates %u as peer\\n\",pNew->selId));", "}", "if( db->mallocFailed ) return 1;", "}", "pSub = pSub1 = pSubitem->pSelect;", "sqlite3DbFree(db, pSubitem->zDatabase);", "sqlite3DbFree(db, pSubitem->zName);", "sqlite3DbFree(db, pSubitem->zAlias);", "pSubitem->zDatabase = 0;", "pSubitem->zName = 0;", "pSubitem->zAlias = 0;", "pSubitem->pSelect = 0;", "if( ALWAYS(pSubitem->pTab!=0) ){", "Table *pTabToDel = pSubitem->pTab;", "if( pTabToDel->nTabRef==1 ){", "Parse *pToplevel = sqlite3ParseToplevel(pParse);", "pTabToDel->pNextZombie = pToplevel->pZombieTab;", "pToplevel->pZombieTab = pTabToDel;", "}else{", "pTabToDel->nTabRef--;", "}", "pSubitem->pTab = 0;", "}", "for(pParent=p; pParent; pParent=pParent->pPrior, pSub=pSub->pPrior){", "int nSubSrc;", "u8 jointype = 0;", "assert( pSub!=0 );", "pSubSrc = pSub->pSrc;", "nSubSrc = pSubSrc->nSrc;", "pSrc = pParent->pSrc;", "if( pSrc ){", "assert( pParent==p );", "jointype = pSubitem->fg.jointype;", "}else{", "assert( pParent!=p );", "pSrc = sqlite3SrcListAppend(pParse, 0, 0, 0);", "if( pSrc==0 ) break;", "pParent->pSrc = pSrc;", "}", "if( nSubSrc>1 ){", "pSrc = sqlite3SrcListEnlarge(pParse, pSrc, nSubSrc-1,iFrom+1);", "if( pSrc==0 ) break;", "pParent->pSrc = pSrc;", "}", "for(i=0; i<nSubSrc; i++){", "sqlite3IdListDelete(db, pSrc->a[i+iFrom].pUsing);", "assert( pSrc->a[i+iFrom].fg.isTabFunc==0 );", "pSrc->a[i+iFrom] = pSubSrc->a[i];", "iNewParent = pSubSrc->a[i].iCursor;", "memset(&pSubSrc->a[i], 0, sizeof(pSubSrc->a[i]));", "}", "pSrc->a[iFrom].fg.jointype = jointype;", "if( pSub->pOrderBy ){", "ExprList *pOrderBy = pSub->pOrderBy;", "for(i=0; i<pOrderBy->nExpr; i++){", "pOrderBy->a[i].u.x.iOrderByCol = 0;", "}", "assert( pParent->pOrderBy==0 );", "pParent->pOrderBy = pOrderBy;", "pSub->pOrderBy = 0;", "}", "pWhere = pSub->pWhere;", "pSub->pWhere = 0;", "if( isLeftJoin>0 ){", "sqlite3SetJoinExpr(pWhere, iNewParent);", "}", "pParent->pWhere = sqlite3ExprAnd(pParse, pWhere, pParent->pWhere);", "if( db->mallocFailed==0 ){", "SubstContext x;", "x.pParse = pParse;", "x.iTable = iParent;", "x.iNewTable = iNewParent;", "x.isLeftJoin = isLeftJoin;", "x.pEList = pSub->pEList;", "substSelect(&x, pParent, 0);", "}", "pParent->selFlags |= pSub->selFlags & SF_Compound;", "assert( (pSub->selFlags & SF_Distinct)==0 );", "if( pSub->pLimit ){", "pParent->pLimit = pSub->pLimit;", "pSub->pLimit = 0;", "}", "}", "sqlite3SelectDelete(db, pSub1);", "#if SELECTTRACE_ENABLED", "if( sqlite3SelectTrace & 0x100 ){", "SELECTTRACE(0x100,pParse,p,(\"After flattening:\\n\"));", "sqlite3TreeViewSelect(0, p, 0);", "}", "#endif", "return 1;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["int PackLinuxElf64::canUnpack()", "{", "if (super::canUnpack()) {", "return true;", "}", "if (Elf64_Ehdr::ET_DYN==get_te16(&ehdri.e_type)) {", "PackLinuxElf64help1(fi);", "Elf64_Phdr const *phdr = phdri, *last_LOAD = nullptr;", "for (unsigned j = 0; j < e_phnum; ++phdr, ++j)", "if (Elf64_Phdr::PT_LOAD==get_te32(&phdr->p_type)) {", "last_LOAD = phdr;", "}", "if (!last_LOAD)", "return false;", "off_t offset = get_te64(&last_LOAD->p_offset);", "unsigned filesz = get_te64(&last_LOAD->p_filesz);", "fi->seek(filesz+offset, SEEK_SET);", "MemBuffer buf(32 + sizeof(overlay_offset));", "fi->readx(buf, buf.getSize());", "return PackUnix::find_overlay_offset(buf);", "}", "return false;", "}"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["static __forceinline void draw_line(float *output, int x0, int y0, int x1, int y1, int n)", "{", "int dy = y1 - y0;", "int adx = x1 - x0;", "int ady = abs(dy);", "int base;", "int x=x0,y=y0;", "int err = 0;", "int sy;", "#ifdef STB_VORBIS_DIVIDE_TABLE", "if (adx < DIVTAB_DENOM && ady < DIVTAB_NUMER) {", "if (dy < 0) {", "base = -integer_divide_table[ady][adx];", "sy = base-1;", "} else {", "base =  integer_divide_table[ady][adx];", "sy = base+1;", "}", "} else {", "base = dy / adx;", "if (dy < 0)", "sy = base - 1;", "else", "sy = base+1;", "}", "#else", "base = dy / adx;", "if (dy < 0)", "sy = base - 1;", "else", "sy = base+1;", "#endif", "ady -= abs(base) * adx;", "if (x1 > n) x1 = n;", "if (x < x1) {", "LINE_OP(output[x], inverse_db_table[y]);", "for (++x; x < x1; ++x) {", "err += ady;", "if (err >= adx) {", "err -= adx;", "y += sy;", "} else", "y += base;", "LINE_OP(output[x], inverse_db_table[y]);", "}", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["GF_RTPHinter *gf_hinter_track_new(GF_ISOFile *file, u32 TrackNum,", "u32 Path_MTU, u32 max_ptime, u32 default_rtp_rate, u32 flags, u8 PayloadID,", "Bool copy_media, u32 InterleaveGroupID, u8 InterleaveGroupPriority, GF_Err *e)", "{", "GF_SLConfig my_sl;", "u32 descIndex, MinSize, MaxSize, avgTS, streamType, codecid, const_dur, nb_ch, maxDTSDelta;", "u8 OfficialPayloadID;", "u32 TrackMediaSubType, TrackMediaType, hintType, nbEdts, required_rate, force_dts_delta, avc_nalu_size, PL_ID, bandwidth, IV_length, KI_length;", "const char *url, *urn;", "char *mpeg4mode;", "Bool is_crypted, has_mpeg4_mapping;", "GF_RTPHinter *tmp;", "GF_ESD *esd;", "*e = GF_BAD_PARAM;", "if (!file || !TrackNum || !gf_isom_get_track_id(file, TrackNum)) return NULL;", "if (!gf_isom_get_sample_count(file, TrackNum)) {", "*e = GF_OK;", "return NULL;", "}", "*e = GF_NOT_SUPPORTED;", "nbEdts = gf_isom_get_edits_count(file, TrackNum);", "if (nbEdts>1) {", "u64 et, sd, mt;", "GF_ISOEditType em;", "gf_isom_get_edit(file, TrackNum, 1, &et, &sd, &mt, &em);", "if ((nbEdts>2) || (em!=GF_ISOM_EDIT_EMPTY)) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[rtp hinter] Cannot hint track whith EditList\\n\"));", "return NULL;", "}", "}", "if (nbEdts) gf_isom_remove_edits(file, TrackNum);", "if (!gf_isom_is_track_enabled(file, TrackNum)) return NULL;", "PL_ID = 0;", "OfficialPayloadID = 0;", "force_dts_delta = 0;", "streamType = 0;", "mpeg4mode = NULL;", "required_rate = 0;", "is_crypted = 0;", "IV_length = KI_length = 0;", "codecid = 0;", "nb_ch = 0;", "avc_nalu_size = 0;", "has_mpeg4_mapping = 1;", "const_dur = 0;", "bandwidth=0;", "TrackMediaType = gf_isom_get_media_type(file, TrackNum);", "if (!default_rtp_rate) default_rtp_rate = 90000;", "if ( (TrackMediaType==GF_ISOM_MEDIA_TEXT) || (TrackMediaType==GF_ISOM_MEDIA_SUBT)) {", "hintType = GF_RTP_PAYT_3GPP_TEXT;", "codecid = GF_CODECID_TEXT_MPEG4;", "streamType = GF_STREAM_TEXT;", "PL_ID = 0x10;", "} else {", "if (gf_isom_get_sample_description_count(file, TrackNum) > 1) return NULL;", "TrackMediaSubType = gf_isom_get_media_subtype(file, TrackNum, 1);", "switch (TrackMediaSubType) {", "case GF_ISOM_SUBTYPE_MPEG4_CRYP:", "is_crypted = 1;", "case GF_ISOM_SUBTYPE_MPEG4:", "esd = gf_isom_get_esd(file, TrackNum, 1);", "hintType = GF_RTP_PAYT_MPEG4;", "if (esd && esd->decoderConfig) {", "streamType = esd->decoderConfig->streamType;", "codecid = esd->decoderConfig->objectTypeIndication;", "if (esd->URLString) hintType = 0;", "if ((streamType==GF_STREAM_AUDIO)", "&& esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data", "&& ((codecid==GF_CODECID_AAC_MPEG4) || (codecid==GF_CODECID_AAC_MPEG2_MP) || (codecid==GF_CODECID_AAC_MPEG2_LCP) || (codecid==GF_CODECID_AAC_MPEG2_SSRP)) ) {", "u32 sample_rate;", "GF_M4ADecSpecInfo a_cfg;", "gf_m4a_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &a_cfg);", "nb_ch = a_cfg.nb_chan;", "sample_rate = a_cfg.base_sr;", "PL_ID = a_cfg.audioPL;", "switch (a_cfg.base_object_type) {", "case GF_M4A_AAC_MAIN:", "case GF_M4A_AAC_LC:", "if (flags & GP_RTP_PCK_USE_LATM_AAC) {", "hintType = GF_RTP_PAYT_LATM;", "break;", "}", "case GF_M4A_AAC_SBR:", "case GF_M4A_AAC_PS:", "case GF_M4A_AAC_LTP:", "case GF_M4A_AAC_SCALABLE:", "case GF_M4A_ER_AAC_LC:", "case GF_M4A_ER_AAC_LTP:", "case GF_M4A_ER_AAC_SCALABLE:", "mpeg4mode = \"AAC\";", "break;", "case GF_M4A_CELP:", "case GF_M4A_ER_CELP:", "mpeg4mode = \"CELP\";", "break;", "}", "required_rate = sample_rate;", "}", "else if ((streamType==GF_STREAM_AUDIO) && ((codecid==GF_CODECID_MPEG2_PART3) || (codecid==GF_CODECID_MPEG_AUDIO))) {", "GF_ISOSample *samp = NULL;", "if (!is_crypted)", "samp = gf_isom_get_sample(file, TrackNum, 1, NULL);", "if (samp && (samp->dataLength>3)) {", "u32 hdr = GF_4CC((u32)samp->data[0], (u8)samp->data[1], (u8)samp->data[2], (u8)samp->data[3]);", "nb_ch = gf_mp3_num_channels(hdr);", "hintType = GF_RTP_PAYT_MPEG12_AUDIO;", "OfficialPayloadID = 14;", "required_rate = 90000;", "}", "else {", "u32 sample_rate;", "gf_isom_get_audio_info(file, TrackNum, 1, &sample_rate, &nb_ch, NULL);", "required_rate = sample_rate;", "}", "if (samp)", "gf_isom_sample_del(&samp);", "}", "else if ((streamType==GF_STREAM_AUDIO) && (codecid==GF_CODECID_QCELP)) {", "hintType = GF_RTP_PAYT_QCELP;", "OfficialPayloadID = 12;", "required_rate = 8000;", "streamType = GF_STREAM_AUDIO;", "nb_ch = 1;", "}", "else if ((streamType==GF_STREAM_AUDIO) && ((codecid==GF_CODECID_EVRC) || (codecid==GF_CODECID_SMV)) ) {", "hintType = GF_RTP_PAYT_EVRC_SMV;", "required_rate = 8000;", "streamType = GF_STREAM_AUDIO;", "nb_ch = 1;", "}", "else if (streamType==GF_STREAM_VISUAL) {", "if ((codecid==GF_CODECID_MPEG4_PART2) && esd->decoderConfig->decoderSpecificInfo) {", "GF_M4VDecSpecInfo dsi;", "gf_m4v_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &dsi);", "PL_ID = dsi.VideoPL;", "}", "if ( ((codecid>=GF_CODECID_MPEG2_SIMPLE) && (codecid<=GF_CODECID_MPEG2_422)) || (codecid==GF_CODECID_MPEG1)) {", "if (!is_crypted) {", "hintType = GF_RTP_PAYT_MPEG12_VIDEO;", "OfficialPayloadID = 32;", "}", "}", "if (is_crypted) {", "if (codecid==GF_CODECID_MPEG4_PART2) force_dts_delta = 22;", "else if ((codecid==GF_CODECID_AVC) || (codecid==GF_CODECID_SVC)) {", "flags &= ~GP_RTP_PCK_USE_MULTI;", "force_dts_delta = 22;", "}", "flags |= GP_RTP_PCK_SIGNAL_RAP | GP_RTP_PCK_SIGNAL_TS;", "}", "required_rate = default_rtp_rate;", "}", "else if (gf_isom_has_sync_shadows(file, TrackNum) || gf_isom_has_sample_dependency(file, TrackNum)) {", "flags |= GP_RTP_PCK_SYSTEMS_CAROUSEL;", "}", "gf_odf_desc_del((GF_Descriptor*)esd);", "}", "break;", "case GF_ISOM_SUBTYPE_3GP_H263:", "hintType = GF_RTP_PAYT_H263;", "required_rate = 90000;", "streamType = GF_STREAM_VISUAL;", "OfficialPayloadID = 34;", "codecid = GF_CODECID_MPEG4_PART2;", "PL_ID = 0x01;", "break;", "case GF_ISOM_SUBTYPE_3GP_AMR:", "required_rate = 8000;", "hintType = GF_RTP_PAYT_AMR;", "streamType = GF_STREAM_AUDIO;", "has_mpeg4_mapping = 0;", "nb_ch = 1;", "break;", "case GF_ISOM_SUBTYPE_3GP_AMR_WB:", "required_rate = 16000;", "hintType = GF_RTP_PAYT_AMR_WB;", "streamType = GF_STREAM_AUDIO;", "has_mpeg4_mapping = 0;", "nb_ch = 1;", "break;", "case GF_ISOM_SUBTYPE_AVC_H264:", "case GF_ISOM_SUBTYPE_AVC2_H264:", "case GF_ISOM_SUBTYPE_AVC3_H264:", "case GF_ISOM_SUBTYPE_AVC4_H264:", "case GF_ISOM_SUBTYPE_SVC_H264:", "case GF_ISOM_SUBTYPE_MVC_H264:", "{", "GF_AVCConfig *avcc = gf_isom_avc_config_get(file, TrackNum, 1);", "GF_AVCConfig *svcc = gf_isom_svc_config_get(file, TrackNum, 1);", "GF_AVCConfig *mvcc = gf_isom_mvc_config_get(file, TrackNum, 1);", "if (!avcc && !svcc && !mvcc) {", "*e = GF_NON_COMPLIANT_BITSTREAM;", "return NULL;", "}", "required_rate = 90000;", "hintType = GF_RTP_PAYT_H264_AVC;", "if (TrackMediaSubType==GF_ISOM_SUBTYPE_SVC_H264)", "hintType = GF_RTP_PAYT_H264_SVC;", "else if (TrackMediaSubType==GF_ISOM_SUBTYPE_MVC_H264)", "hintType = GF_RTP_PAYT_H264_SVC;", "streamType = GF_STREAM_VISUAL;", "avc_nalu_size = avcc ? avcc->nal_unit_size : svcc ? svcc->nal_unit_size : mvcc->nal_unit_size;", "codecid = GF_CODECID_AVC;", "PL_ID = 0x0F;", "gf_odf_avc_cfg_del(avcc);", "gf_odf_avc_cfg_del(svcc);", "}", "break;", "case GF_ISOM_SUBTYPE_HVC1:", "case GF_ISOM_SUBTYPE_HEV1:", "case GF_ISOM_SUBTYPE_HVC2:", "case GF_ISOM_SUBTYPE_HEV2:", "{", "GF_HEVCConfig *hevcc = gf_isom_hevc_config_get(file, TrackNum, 1);", "if (!hevcc) {", "*e = GF_NON_COMPLIANT_BITSTREAM;", "return NULL;", "}", "required_rate = 90000;", "hintType = GF_RTP_PAYT_HEVC;", "streamType = GF_STREAM_VISUAL;", "avc_nalu_size = hevcc->nal_unit_size;", "codecid = GF_CODECID_HEVC;", "PL_ID = 0x0F;", "flags |= GP_RTP_PCK_USE_MULTI;", "gf_odf_hevc_cfg_del(hevcc);", "break;", "}", "break;", "case GF_ISOM_SUBTYPE_3GP_QCELP:", "required_rate = 8000;", "hintType = GF_RTP_PAYT_QCELP;", "streamType = GF_STREAM_AUDIO;", "codecid = GF_CODECID_QCELP;", "OfficialPayloadID = 12;", "nb_ch = 1;", "break;", "case GF_ISOM_SUBTYPE_3GP_EVRC:", "case GF_ISOM_SUBTYPE_3GP_SMV:", "required_rate = 8000;", "hintType = GF_RTP_PAYT_EVRC_SMV;", "streamType = GF_STREAM_AUDIO;", "codecid = (TrackMediaSubType==GF_ISOM_SUBTYPE_3GP_EVRC) ? GF_CODECID_EVRC : GF_CODECID_SMV;", "nb_ch = 1;", "break;", "case GF_ISOM_SUBTYPE_3GP_DIMS:", "#if GPAC_ENABLE_3GPP_DIMS_RTP", "hintType = GF_RTP_PAYT_3GPP_DIMS;", "streamType = GF_STREAM_SCENE;", "#else", "hintType = 0;", "GF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[RTP Packetizer] 3GPP DIMS over RTP disabled in build\\n\", streamType));", "#endif", "break;", "case GF_ISOM_SUBTYPE_AC3:", "hintType = GF_RTP_PAYT_AC3;", "streamType = GF_STREAM_AUDIO;", "gf_isom_get_audio_info(file, TrackNum, 1, NULL, &nb_ch, NULL);", "break;", "case GF_ISOM_SUBTYPE_MP3:", "{", "GF_ISOSample *samp = gf_isom_get_sample(file, TrackNum, 1, NULL);", "if (samp && (samp->dataLength>3)) {", "u32 hdr = GF_4CC((u32)samp->data[0], (u8)samp->data[1], (u8)samp->data[2], (u8)samp->data[3]);", "nb_ch = gf_mp3_num_channels(hdr);", "} else {", "u32 bps;", "gf_isom_get_audio_info(file, TrackNum, 1, &required_rate, &nb_ch, &bps);", "}", "hintType = GF_RTP_PAYT_MPEG12_AUDIO;", "OfficialPayloadID = 14;", "required_rate = 90000;", "if (samp)", "gf_isom_sample_del(&samp);", "}", "break;", "default:", "hintType = 0;", "break;", "}", "}", "if (!hintType) return NULL;", "gf_isom_get_data_reference(file, TrackNum, 1, &url, &urn);", "if (url || urn) return NULL;", "*e = GF_OUT_OF_MEM;", "GF_SAFEALLOC(tmp, GF_RTPHinter);", "if (!tmp) return NULL;", "if (has_mpeg4_mapping && (flags & GP_RTP_PCK_FORCE_MPEG4)) {", "hintType = GF_RTP_PAYT_MPEG4;", "avc_nalu_size = 0;", "}", "else if (OfficialPayloadID && (flags & GP_RTP_PCK_USE_STATIC_ID) ) {", "PayloadID = OfficialPayloadID;", "}", "tmp->file = file;", "tmp->TrackNum = TrackNum;", "tmp->avc_nalu_size = avc_nalu_size;", "tmp->nb_chan = nb_ch;", "tmp->has_ctts = gf_isom_has_time_offset(file, TrackNum);", "gf_media_get_sample_average_infos(file, TrackNum, &MinSize, &MaxSize, &avgTS, &maxDTSDelta, &const_dur, &bandwidth);", "if (flags & GP_RTP_PCK_SYSTEMS_CAROUSEL) {", "flags |= GP_RTP_PCK_SIGNAL_RAP;", "}", "if (flags & GP_RTP_PCK_USE_MULTI) {", "if (MinSize != MaxSize) flags |= GP_RTP_PCK_SIGNAL_SIZE;", "if (!const_dur) flags |= GP_RTP_PCK_SIGNAL_TS;", "}", "if (tmp->has_ctts) flags |= GP_RTP_PCK_SIGNAL_TS;", "InitSL_RTP(&my_sl);", "my_sl.timestampResolution = gf_isom_get_media_timescale(file, TrackNum);", "if (required_rate) {", "Double sc = required_rate;", "sc /= my_sl.timestampResolution;", "maxDTSDelta = (u32) (maxDTSDelta*sc);", "my_sl.timestampResolution = required_rate;", "}", "max_ptime = (u32) (max_ptime * my_sl.timestampResolution / 1000);", "my_sl.AUSeqNumLength = gf_get_bit_size(gf_isom_get_sample_count(file, TrackNum));", "if (my_sl.AUSeqNumLength>16) my_sl.AUSeqNumLength=16;", "my_sl.CUDuration = const_dur;", "if (gf_isom_has_sync_points(file, TrackNum)) {", "my_sl.useRandomAccessPointFlag = 1;", "} else {", "my_sl.useRandomAccessPointFlag = 0;", "my_sl.hasRandomAccessUnitsOnlyFlag = 1;", "}", "if (is_crypted) {", "Bool use_sel_enc;", "gf_isom_get_ismacryp_info(file, TrackNum, 1, NULL, NULL, NULL, NULL, NULL, &use_sel_enc, &IV_length, &KI_length);", "if (use_sel_enc) flags |= GP_RTP_PCK_SELECTIVE_ENCRYPTION;", "}", "tmp->OrigTimeScale = gf_isom_get_media_timescale(file, TrackNum);", "tmp->rtp_p = gf_rtp_builder_new(hintType, &my_sl, flags, tmp,", "MP4T_OnNewPacket, MP4T_OnPacketDone,", "copy_media ? NULL : MP4T_OnDataRef,", "MP4T_OnData);", "gf_rtp_builder_init(tmp->rtp_p, PayloadID, Path_MTU, max_ptime,", "streamType, codecid, PL_ID, MinSize, MaxSize, avgTS, maxDTSDelta, IV_length, KI_length, mpeg4mode);", "if (force_dts_delta) tmp->rtp_p->slMap.DTSDeltaLength = force_dts_delta;", "tmp->TrackID = gf_isom_get_track_id(file, TrackNum);", "tmp->HintID = tmp->TrackID + 65535;", "while (gf_isom_get_track_by_id(file, tmp->HintID)) tmp->HintID++;", "tmp->HintTrack = gf_isom_new_track(file, tmp->HintID, GF_ISOM_MEDIA_HINT, my_sl.timestampResolution);", "gf_isom_setup_hint_track(file, tmp->HintTrack, GF_ISOM_HINT_RTP);", "gf_isom_new_hint_description(file, tmp->HintTrack, -1, -1, 0, &descIndex);", "gf_isom_rtp_set_timescale(file, tmp->HintTrack, descIndex, my_sl.timestampResolution);", "if (hintType==GF_RTP_PAYT_MPEG4) {", "tmp->rtp_p->slMap.CodecID = codecid;", "*e = gf_isom_set_extraction_slc(file, TrackNum, 1, &my_sl);", "if (*e) {", "gf_hinter_track_del(tmp);", "return NULL;", "}", "}", "tmp->bandwidth = bandwidth;", "gf_isom_set_track_interleaving_group(file, TrackNum, InterleaveGroupID);", "if (!copy_media) {", "gf_isom_set_track_interleaving_group(file, tmp->HintTrack, InterleaveGroupID);", "} else {", "gf_isom_set_track_interleaving_group(file, tmp->HintTrack, InterleaveGroupID + OFFSET_HINT_GROUP_ID);", "}", "InterleaveGroupPriority*=2;", "gf_isom_set_track_priority_in_group(file, TrackNum, InterleaveGroupPriority+1);", "gf_isom_set_track_priority_in_group(file, tmp->HintTrack, InterleaveGroupPriority);", "*e = GF_OK;", "return tmp;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["GF_Err stbl_AppendTime(GF_SampleTableBox *stbl, u32 duration, u32 nb_pack)", "{", "GF_TimeToSampleBox *stts = stbl->TimeToSample;", "if (!nb_pack) nb_pack = 1;", "if (stts->nb_entries) {", "if (stts->entries[stts->nb_entries-1].sampleDelta == duration) {", "stts->entries[stts->nb_entries-1].sampleCount += nb_pack;", "return GF_OK;", "}", "}", "if (stts->nb_entries==stts->alloc_size) {", "ALLOC_INC(stts->alloc_size);", "stts->entries = gf_realloc(stts->entries, sizeof(GF_SttsEntry)*stts->alloc_size);", "if (!stts->entries) return GF_OUT_OF_MEM;", "memset(&stts->entries[stts->nb_entries], 0, sizeof(GF_SttsEntry)*(stts->alloc_size-stts->nb_entries) );", "}", "stts->entries[stts->nb_entries].sampleCount = nb_pack;", "stts->entries[stts->nb_entries].sampleDelta = duration;", "stts->nb_entries++;", "if (stts->max_ts_delta < duration ) stts->max_ts_delta = duration;", "return GF_OK;", "}"], "ner_tags": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static void gf_isom_write_tx3g(GF_Tx3gSampleEntryBox *a, GF_BitStream *bs, u32 sidx, u32 sidx_offset)", "{", "u32 size, j, fount_count;", "Bool is_qt_text = (a->type==GF_ISOM_BOX_TYPE_TEXT) ? GF_TRUE : GF_FALSE;", "const char *qt_fontname = NULL;", "void gpp_write_rgba(GF_BitStream *bs, u32 col);", "void gpp_write_box(GF_BitStream *bs, GF_BoxRecord *rec);", "void gpp_write_style(GF_BitStream *bs, GF_StyleRecord *rec);", "if (sidx_offset) gf_bs_write_u8(bs, sidx + sidx_offset);", "size = 8 + 18 + 8 + 12;", "size += 8 + 2;", "fount_count = 0;", "if (is_qt_text) {", "GF_TextSampleEntryBox *qt = (GF_TextSampleEntryBox *)a;", "if (qt->textName) {", "qt_fontname = qt->textName;", "fount_count = 1;", "}", "} else {", "if (a->font_table) {", "fount_count = a->font_table->entry_count;", "for (j=0; j<fount_count; j++) {", "size += 3;", "if (a->font_table->fonts[j].fontName) size += (u32) strlen(a->font_table->fonts[j].fontName);", "}", "}", "}", "gf_bs_write_u32(bs, size);", "gf_bs_write_u32(bs, a->type);", "gf_bs_write_data(bs, a->reserved, 6);", "gf_bs_write_u16(bs, a->dataReferenceIndex);", "gf_bs_write_u32(bs, a->displayFlags);", "gf_bs_write_u8(bs, a->horizontal_justification);", "gf_bs_write_u8(bs, a->vertical_justification);", "gpp_write_rgba(bs, a->back_color);", "gpp_write_box(bs, &a->default_box);", "gpp_write_style(bs, &a->default_style);", "size -= (8 + 18 + 8 + 12);", "gf_bs_write_u32(bs, size);", "gf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_FTAB);", "gf_bs_write_u16(bs, fount_count);", "for (j=0; j<fount_count; j++) {", "if (is_qt_text) {", "gf_bs_write_u16(bs, 0);", "if (qt_fontname) {", "u32 len = (u32) strlen(qt_fontname);", "gf_bs_write_u8(bs, len);", "gf_bs_write_data(bs, qt_fontname, len);", "} else {", "gf_bs_write_u8(bs, 0);", "}", "} else {", "gf_bs_write_u16(bs, a->font_table->fonts[j].fontID);", "if (a->font_table->fonts[j].fontName) {", "u32 len = (u32) strlen(a->font_table->fonts[j].fontName);", "gf_bs_write_u8(bs, len);", "gf_bs_write_data(bs, a->font_table->fonts[j].fontName, len);", "} else {", "gf_bs_write_u8(bs, 0);", "}", "}", "}", "}"], "ner_tags": [0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["QByteArray Cipher::blowfishECB(QByteArray cipherText, bool direction)", "{", "QCA::Initializer init;", "QByteArray temp = cipherText;", "if (direction)", "{", "while ((temp.length() % 8) != 0) temp.append('\\0');", "}", "else", "{", "temp = b64ToByte(temp);", "while ((temp.length() % 8) != 0) temp.append('\\0');", "}", "QCA::Direction dir = (direction) ? QCA::Encode : QCA::Decode;", "QCA::Cipher cipher(m_type, QCA::Cipher::ECB, QCA::Cipher::NoPadding, dir, m_key);", "QByteArray temp2 = cipher.update(QCA::MemoryRegion(temp)).toByteArray();", "temp2 += cipher.final().toByteArray();", "if (!cipher.ok())", "return cipherText;", "if (direction)", "temp2 = byteToB64(temp2);", "return temp2;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0]}
{"tokens": ["static int dnxhd_init_vlc(DNXHDContext *ctx, uint32_t cid, int bitdepth)", "{", "if (cid != ctx->cid) {", "const CIDEntry *cid_table = ff_dnxhd_get_cid_table(cid);", "if (!cid_table) {", "av_log(ctx->avctx, AV_LOG_ERROR, \"unsupported cid %\"PRIu32\"\\n\", cid);", "return AVERROR(ENOSYS);", "}", "if (cid_table->bit_depth != bitdepth &&", "cid_table->bit_depth != DNXHD_VARIABLE) {", "av_log(ctx->avctx, AV_LOG_ERROR, \"bit depth mismatches %d %d\\n\",", "cid_table->bit_depth, bitdepth);", "return AVERROR_INVALIDDATA;", "}", "ctx->cid_table = cid_table;", "av_log(ctx->avctx, AV_LOG_VERBOSE, \"Profile cid %\"PRIu32\".\\n\", cid);", "ff_free_vlc(&ctx->ac_vlc);", "ff_free_vlc(&ctx->dc_vlc);", "ff_free_vlc(&ctx->run_vlc);", "init_vlc(&ctx->ac_vlc, DNXHD_VLC_BITS, 257,", "ctx->cid_table->ac_bits, 1, 1,", "ctx->cid_table->ac_codes, 2, 2, 0);", "init_vlc(&ctx->dc_vlc, DNXHD_DC_VLC_BITS, bitdepth > 8 ? 14 : 12,", "ctx->cid_table->dc_bits, 1, 1,", "ctx->cid_table->dc_codes, 1, 1, 0);", "init_vlc(&ctx->run_vlc, DNXHD_VLC_BITS, 62,", "ctx->cid_table->run_bits, 1, 1,", "ctx->cid_table->run_codes, 2, 2, 0);", "ctx->cid = cid;", "}", "return 0;", "}"], "ner_tags": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0]}
{"tokens": ["static int zipfileUpdate(", "sqlite3_vtab *pVtab,", "int nVal,", "sqlite3_value **apVal,", "sqlite_int64 *pRowid", "){", "ZipfileTab *pTab = (ZipfileTab*)pVtab;", "int rc = SQLITE_OK;", "ZipfileEntry *pNew = 0;", "u32 mode = 0;", "u32 mTime = 0;", "i64 sz = 0;", "const char *zPath = 0;", "int nPath = 0;", "const u8 *pData = 0;", "int nData = 0;", "int iMethod = 0;", "u8 *pFree = 0;", "char *zFree = 0;", "ZipfileEntry *pOld = 0;", "ZipfileEntry *pOld2 = 0;", "int bUpdate = 0;", "int bIsDir = 0;", "u32 iCrc32 = 0;", "if( pTab->pWriteFd==0 ){", "rc = zipfileBegin(pVtab);", "if( rc!=SQLITE_OK ) return rc;", "}", "if( sqlite3_value_type(apVal[0])!=SQLITE_NULL ){", "const char *zDelete = (const char*)sqlite3_value_text(apVal[0]);", "int nDelete = (int)strlen(zDelete);", "if( nVal>1 ){", "const char *zUpdate = (const char*)sqlite3_value_text(apVal[1]);", "if( zUpdate && zipfileComparePath(zUpdate, zDelete, nDelete)!=0 ){", "bUpdate = 1;", "}", "}", "for(pOld=pTab->pFirstEntry; 1; pOld=pOld->pNext){", "if( zipfileComparePath(pOld->cds.zFile, zDelete, nDelete)==0 ){", "break;", "}", "assert( pOld->pNext );", "}", "}", "if( nVal>1 ){", "if( sqlite3_value_type(apVal[5])!=SQLITE_NULL ){", "zipfileTableErr(pTab, \"sz must be NULL\");", "rc = SQLITE_CONSTRAINT;", "}", "if( sqlite3_value_type(apVal[6])!=SQLITE_NULL ){", "zipfileTableErr(pTab, \"rawdata must be NULL\");", "rc = SQLITE_CONSTRAINT;", "}", "if( rc==SQLITE_OK ){", "if( sqlite3_value_type(apVal[7])==SQLITE_NULL ){", "bIsDir = 1;", "}else{", "const u8 *aIn = sqlite3_value_blob(apVal[7]);", "int nIn = sqlite3_value_bytes(apVal[7]);", "int bAuto = sqlite3_value_type(apVal[8])==SQLITE_NULL;", "iMethod = sqlite3_value_int(apVal[8]);", "sz = nIn;", "pData = aIn;", "nData = nIn;", "if( iMethod!=0 && iMethod!=8 ){", "zipfileTableErr(pTab, \"unknown compression method: %d\", iMethod);", "rc = SQLITE_CONSTRAINT;", "}else{", "if( bAuto || iMethod ){", "int nCmp;", "rc = zipfileDeflate(aIn, nIn, &pFree, &nCmp, &pTab->base.zErrMsg);", "if( rc==SQLITE_OK ){", "if( iMethod || nCmp<nIn ){", "iMethod = 8;", "pData = pFree;", "nData = nCmp;", "}", "}", "}", "iCrc32 = crc32(0, aIn, nIn);", "}", "}", "}", "if( rc==SQLITE_OK ){", "rc = zipfileGetMode(apVal[3], bIsDir, &mode, &pTab->base.zErrMsg);", "}", "if( rc==SQLITE_OK ){", "zPath = (const char*)sqlite3_value_text(apVal[2]);", "nPath = (int)strlen(zPath);", "mTime = zipfileGetTime(apVal[4]);", "}", "if( rc==SQLITE_OK && bIsDir ){", "if( zPath[nPath-1]!='/' ){", "zFree = sqlite3_mprintf(\"%s/\", zPath);", "if( zFree==0 ){ rc = SQLITE_NOMEM; }", "zPath = (const char*)zFree;", "nPath++;", "}", "}", "if( (pOld==0 || bUpdate) && rc==SQLITE_OK ){", "ZipfileEntry *p;", "for(p=pTab->pFirstEntry; p; p=p->pNext){", "if( zipfileComparePath(p->cds.zFile, zPath, nPath)==0 ){", "switch( sqlite3_vtab_on_conflict(pTab->db) ){", "case SQLITE_IGNORE: {", "goto zipfile_update_done;", "}", "case SQLITE_REPLACE: {", "pOld2 = p;", "break;", "}", "default: {", "zipfileTableErr(pTab, \"duplicate name: \\\"%s\\\"\", zPath);", "rc = SQLITE_CONSTRAINT;", "break;", "}", "}", "break;", "}", "}", "}", "if( rc==SQLITE_OK ){", "pNew = zipfileNewEntry(zPath);", "if( pNew==0 ){", "rc = SQLITE_NOMEM;", "}else{", "pNew->cds.iVersionMadeBy = ZIPFILE_NEWENTRY_MADEBY;", "pNew->cds.iVersionExtract = ZIPFILE_NEWENTRY_REQUIRED;", "pNew->cds.flags = ZIPFILE_NEWENTRY_FLAGS;", "pNew->cds.iCompression = (u16)iMethod;", "zipfileMtimeToDos(&pNew->cds, mTime);", "pNew->cds.crc32 = iCrc32;", "pNew->cds.szCompressed = nData;", "pNew->cds.szUncompressed = (u32)sz;", "pNew->cds.iExternalAttr = (mode<<16);", "pNew->cds.iOffset = (u32)pTab->szCurrent;", "pNew->cds.nFile = (u16)nPath;", "pNew->mUnixTime = (u32)mTime;", "rc = zipfileAppendEntry(pTab, pNew, pData, nData);", "zipfileAddEntry(pTab, pOld, pNew);", "}", "}", "}", "if( rc==SQLITE_OK && (pOld || pOld2) ){", "ZipfileCsr *pCsr;", "for(pCsr=pTab->pCsrList; pCsr; pCsr=pCsr->pCsrNext){", "if( pCsr->pCurrent && (pCsr->pCurrent==pOld || pCsr->pCurrent==pOld2) ){", "pCsr->pCurrent = pCsr->pCurrent->pNext;", "pCsr->bNoop = 1;", "}", "}", "zipfileRemoveEntryFromList(pTab, pOld);", "zipfileRemoveEntryFromList(pTab, pOld2);", "}", "zipfile_update_done:", "sqlite3_free(pFree);", "sqlite3_free(zFree);", "return rc;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static GF_Err BM_ParseGlobalQuantizer(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)", "{", "GF_Node *node;", "GF_Command *com;", "GF_CommandField *inf;", "node = gf_bifs_dec_node(codec, bs, NDT_SFWorldNode);", "if (!node) return GF_NON_COMPLIANT_BITSTREAM;", "if (codec->scenegraph->global_qp) {", "gf_node_unregister(codec->scenegraph->global_qp, NULL);", "}", "codec->ActiveQP = NULL;", "codec->scenegraph->global_qp = NULL;", "if (gf_node_get_tag(node) != TAG_MPEG4_QuantizationParameter) {", "gf_node_unregister(node, NULL);", "return GF_NON_COMPLIANT_BITSTREAM;", "}", "codec->ActiveQP = (M_QuantizationParameter *) node;", "codec->ActiveQP->isLocal = 0;", "codec->scenegraph->global_qp = node;", "node->sgprivate->num_instances = 2;", "com = gf_sg_command_new(codec->current_graph, GF_SG_GLOBAL_QUANTIZER);", "inf = gf_sg_command_field_new(com);", "inf->new_node = node;", "inf->field_ptr = &inf->new_node;", "inf->fieldType = GF_SG_VRML_SFNODE;", "gf_list_add(com_list, com);", "return GF_OK;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static float *get_window(vorb *f, int len)", "{", "len <<= 1;", "if (len == f->blocksize_0) return f->window[0];", "if (len == f->blocksize_1) return f->window[1];", "assert(0);", "return NULL;", "}"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["char *compose_path(ctrl_t *ctrl, char *path)", "{", "struct stat st;", "static char rpath[PATH_MAX];", "char *name, *ptr;", "char dir[PATH_MAX] = { 0 };", "strlcpy(dir, ctrl->cwd, sizeof(dir));", "DBG(\"Compose path from cwd: %s, arg: %s\", ctrl->cwd, path ?: \"\");", "if (!path || !strlen(path))", "goto check;", "if (path) {", "if (path[0] != '/') {", "if (dir[strlen(dir) - 1] != '/')", "strlcat(dir, \"/\", sizeof(dir));", "}", "strlcat(dir, path, sizeof(dir));", "}", "check:", "while ((ptr = strstr(dir, \"\")))", "memmove(ptr, &ptr[1], strlen(&ptr[1]) + 1);", "if (!chrooted) {", "size_t len = strlen(home);", "DBG(\"Server path from CWD: %s\", dir);", "if (len > 0 && home[len - 1] == '/')", "len--;", "memmove(dir + len, dir, strlen(dir) + 1);", "memcpy(dir, home, len);", "DBG(\"Resulting non-chroot path: %s\", dir);", "}", "if (!stat(dir, &st) && S_ISDIR(st.st_mode)) {", "if (!realpath(dir, rpath))", "return NULL;", "} else {", "name = basename(path);", "ptr = dirname(dir);", "memset(rpath, 0, sizeof(rpath));", "if (!realpath(ptr, rpath)) {", "INFO(\"Failed realpath(%s): %m\", ptr);", "return NULL;", "}", "if (rpath[1] != 0)", "strlcat(rpath, \"/\", sizeof(rpath));", "strlcat(rpath, name, sizeof(rpath));", "}", "if (!chrooted && strncmp(dir, home, strlen(home))) {", "DBG(\"Failed non-chroot dir:%s vs home:%s\", dir, home);", "return NULL;", "}", "return rpath;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["find_link_ref(struct link_ref **references, uint8_t *name, size_t length)", "{", "unsigned int hash = hash_link_ref(name, length);", "struct link_ref *ref = NULL;", "ref = references[hash % REF_TABLE_SIZE];", "while (ref != NULL) {", "if (ref->id == hash)", "return ref;", "ref = ref->next;", "}", "return NULL;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0]}
{"tokens": ["GF_Err SFScript_Parse(GF_BifsDecoder *codec, SFScript *script_field, GF_BitStream *bs, GF_Node *n)", "{", "GF_Err e;", "u32 i, count, nbBits;", "char *ptr;", "ScriptParser parser;", "e = GF_OK;", "if (gf_node_get_tag(n) != TAG_MPEG4_Script) return GF_NON_COMPLIANT_BITSTREAM;", "parser.codec = codec;", "parser.script = n;", "parser.bs = bs;", "parser.length = 500;", "parser.string = (char *) gf_malloc(sizeof(char)* parser.length);", "parser.string[0] = 0;", "parser.identifiers = gf_list_new();", "parser.new_line = (char *) (codec->dec_memory_mode ? \"\\n\" : NULL);", "parser.indent = 0;", "if (gf_bs_read_int(bs, 1)) {", "while (!gf_bs_read_int(bs, 1)) {", "e = ParseScriptField(&parser);", "if (e) goto exit;", "}", "} else {", "nbBits = gf_bs_read_int(bs, 4);", "count = gf_bs_read_int(bs, nbBits);", "for (i=0; i<count; i++) {", "e = ParseScriptField(&parser);", "if (e) goto exit;", "}", "}", "gf_bs_read_int(bs, 1);", "SFS_AddString(&parser, \"javascript:\");", "SFS_AddString(&parser, parser.new_line);", "while (gf_bs_read_int(bs, 1)) {", "SFS_AddString(&parser, \"function \");", "SFS_Identifier(&parser);", "SFS_Arguments(&parser, GF_FALSE);", "SFS_Space(&parser);", "SFS_StatementBlock(&parser, GF_TRUE);", "SFS_Line(&parser);", "}", "SFS_Line(&parser);", "if (script_field->script_text) gf_free(script_field->script_text);", "script_field->script_text = (char *) gf_strdup(parser.string);", "exit:", "while (gf_list_count(parser.identifiers)) {", "ptr = (char *)gf_list_get(parser.identifiers, 0);", "gf_free(ptr);", "gf_list_rem(parser.identifiers, 0);", "}", "gf_list_del(parser.identifiers);", "if (parser.string) gf_free(parser.string);", "return e;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["char *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicode_type)", "{", "u32 i, j, len;", "char *sOK;", "char szLineConv[1024];", "unsigned short *sptr;", "memset(szLine, 0, sizeof(char)*lineSize);", "sOK = fgets(szLine, lineSize, txt_in);", "if (!sOK) return NULL;", "if (unicode_type<=1) {", "j=0;", "len = (u32) strlen(szLine);", "for (i=0; i<len; i++) {", "if (!unicode_type && (szLine[i] & 0x80)) {", "if ((szLine[i+1] & 0xc0) != 0x80) {", "szLineConv[j] = 0xc0 | ( (szLine[i] >> 6) & 0x3 );", "j++;", "szLine[i] &= 0xbf;", "}", "else if ( (szLine[i] & 0xe0) == 0xc0) {", "szLineConv[j] = szLine[i];", "i++;", "j++;", "}", "else if ( (szLine[i] & 0xf0) == 0xe0) {", "szLineConv[j] = szLine[i];", "i++;", "j++;", "szLineConv[j] = szLine[i];", "i++;", "j++;", "}", "else if ( (szLine[i] & 0xf8) == 0xf0) {", "szLineConv[j] = szLine[i];", "i++;", "j++;", "szLineConv[j] = szLine[i];", "i++;", "j++;", "szLineConv[j] = szLine[i];", "i++;", "j++;", "} else {", "i+=1;", "continue;", "}", "}", "szLineConv[j] = szLine[i];", "j++;", "}", "szLineConv[j] = 0;", "strcpy(szLine, szLineConv);", "return sOK;", "}", "#ifdef GPAC_BIG_ENDIAN", "if (unicode_type==3) {", "#else", "if (unicode_type==2) {", "#endif", "i=0;", "while (1) {", "char c;", "if (!szLine[i] && !szLine[i+1]) break;", "c = szLine[i+1];", "szLine[i+1] = szLine[i];", "szLine[i] = c;", "i+=2;", "}", "}", "sptr = (u16 *)szLine;", "i = (u32) gf_utf8_wcstombs(szLineConv, 1024, (const unsigned short **) &sptr);", "szLineConv[i] = 0;", "strcpy(szLine, szLineConv);", "if (unicode_type==3) fgetc(txt_in);", "return sOK;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["Expression_Obj Parser::parse_value()", "{", "lex< css_comments >(false);", "if (lex< ampersand >())", "{", "if (match< ampersand >()) {", "warning(\"In Sass, \\\"&&\\\" means two copies of the parent selector. You probably want to use \\\"and\\\" instead.\", pstate);", "}", "return SASS_MEMORY_NEW(Parent_Selector, pstate); }", "if (lex< kwd_important >())", "{ return SASS_MEMORY_NEW(String_Constant, pstate, \"!important\"); }", "if (lex< sequence < percentage, lookahead < number > > >())", "{ return lexed_percentage(lexed); }", "if (lex< sequence < number, lookahead< sequence < op, number > > > >())", "{ return lexed_number(lexed); }", "if (lex< sequence < quoted_string, lookahead < exactly <'-'> > > >())", "{ return parse_string(); }", "if (const char* stop = peek< value_schema >())", "{ return parse_value_schema(stop); }", "if (lex< quoted_string >())", "{ return parse_string(); }", "if (lex< kwd_true >())", "{ return SASS_MEMORY_NEW(Boolean, pstate, true); }", "if (lex< kwd_false >())", "{ return SASS_MEMORY_NEW(Boolean, pstate, false); }", "if (lex< kwd_null >())", "{ return SASS_MEMORY_NEW(Null, pstate); }", "if (lex< identifier >()) {", "return color_or_string(lexed);", "}", "if (lex< percentage >())", "{ return lexed_percentage(lexed); }", "if (lex< sequence < alternatives< hex, hex0 >, negate < exactly<'-'> > > >())", "{ return lexed_hex_color(lexed); }", "if (lex< hexa >())", "{", "std::string s = lexed.to_string();", "deprecated(", "\"The value \\\"\"+s+\"\\\" is currently parsed as a string, but it will be parsed as a color in\",", "\"future versions of Sass. Use \\\"unquote('\"+s+\"')\\\" to continue parsing it as a string.\",", "true, pstate", ");", "return SASS_MEMORY_NEW(String_Quoted, pstate, lexed);", "}", "if (lex< sequence < exactly <'#'>, identifier > >())", "{ return SASS_MEMORY_NEW(String_Quoted, pstate, lexed); }", "if (lex< sequence< dimension, optional< sequence< exactly<'-'>, lookahead< alternatives < space > > > > > >())", "{ return lexed_dimension(lexed); }", "if (lex< sequence< static_component, one_plus< strict_identifier > > >())", "{ return SASS_MEMORY_NEW(String_Constant, pstate, lexed); }", "if (lex< number >())", "{ return lexed_number(lexed); }", "if (lex< variable >())", "{ return SASS_MEMORY_NEW(Variable, pstate, Util::normalize_underscores(lexed)); }", "if (lex< sequence< exactly<'%'>, optional< percentage > > >())", "{ return SASS_MEMORY_NEW(String_Constant, pstate, lexed); }", "css_error(\"Invalid CSS\", \" after \", \": expected expression (e.g. 1px, bold), was \");", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0]}
{"tokens": ["void CoreAuthHandler::onReadyRead()", "{", "if (socket()->bytesAvailable() < 4)", "return;", "if (_peer)", "return;", "if (!_magicReceived) {", "quint32 magic;", "socket()->peek((char*)&magic, 4);", "magic = qFromBigEndian<quint32>(magic);", "if ((magic & 0xffffff00) != Protocol::magic) {", "qDebug() << \"Legacy client detected, switching to compatibility mode\";", "_legacy = true;", "RemotePeer *peer = PeerFactory::createPeer(PeerFactory::ProtoDescriptor(Protocol::LegacyProtocol, 0), this, socket(), Compressor::NoCompression, this);", "connect(peer, SIGNAL(protocolVersionMismatch(int,int)), SLOT(onProtocolVersionMismatch(int,int)));", "setPeer(peer);", "return;", "}", "_magicReceived = true;", "quint8 features = magic & 0xff;", "if (Core::sslSupported() && (features & Protocol::Encryption))", "_connectionFeatures |= Protocol::Encryption;", "if (features & Protocol::Compression)", "_connectionFeatures |= Protocol::Compression;", "socket()->read((char*)&magic, 4);", "}", "while (socket()->bytesAvailable() >= 4) {", "quint32 data;", "socket()->read((char*)&data, 4);", "data = qFromBigEndian<quint32>(data);", "Protocol::Type type = static_cast<Protocol::Type>(data & 0xff);", "quint16 protoFeatures = static_cast<quint16>(data>>8 & 0xffff);", "_supportedProtos.append(PeerFactory::ProtoDescriptor(type, protoFeatures));", "if (data >= 0x80000000) {", "Compressor::CompressionLevel level;", "if (_connectionFeatures & Protocol::Compression)", "level = Compressor::BestCompression;", "else", "level = Compressor::NoCompression;", "RemotePeer *peer = PeerFactory::createPeer(_supportedProtos, this, socket(), level, this);", "if (peer->protocol() == Protocol::LegacyProtocol) {", "_legacy = true;", "connect(peer, SIGNAL(protocolVersionMismatch(int,int)), SLOT(onProtocolVersionMismatch(int,int)));", "}", "setPeer(peer);", "quint32 reply = peer->protocol() | peer->enabledFeatures()<<8 | _connectionFeatures<<24;", "reply = qToBigEndian<quint32>(reply);", "socket()->write((char*)&reply, 4);", "socket()->flush();", "if (!_legacy && (_connectionFeatures & Protocol::Encryption))", "startSsl();", "return;", "}", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["Status DecodeImageAPNG(Span<const uint8_t> bytes, ThreadPool* pool,", "CodecInOut* io) {", "Reader r;", "unsigned int id, i, j, w, h, w0, h0, x0, y0;", "unsigned int delay_num, delay_den, dop, bop, rowbytes, imagesize;", "unsigned char sig[8];", "png_structp png_ptr;", "png_infop info_ptr;", "CHUNK chunk;", "CHUNK chunkIHDR;", "std::vector<CHUNK> chunksInfo;", "bool isAnimated = false;", "bool skipFirst = false;", "bool hasInfo = false;", "bool all_dispose_bg = true;", "APNGFrame frameRaw = {};", "r = {bytes.data(), bytes.data() + bytes.size()};", "unsigned char png_signature[8] = {137, 80, 78, 71, 13, 10, 26, 10};", "if (r.Read(sig, 8) || memcmp(sig, png_signature, 8) != 0) {", "return false;", "}", "id = read_chunk(&r, &chunkIHDR);", "io->frames.clear();", "io->dec_pixels = 0;", "io->metadata.m.SetUintSamples(8);", "io->metadata.m.SetAlphaBits(8);", "io->metadata.m.color_encoding =", "ColorEncoding::SRGB();", "(void)io->dec_hints.Foreach(", "[](const std::string& key, const std::string&          ) {", "JXL_WARNING(\"APNG decoder ignoring %s hint\", key.c_str());", "return true;", "});", "bool errorstate = true;", "if (id == kId_IHDR && chunkIHDR.size == 25) {", "w0 = w = png_get_uint_32(chunkIHDR.p + 8);", "h0 = h = png_get_uint_32(chunkIHDR.p + 12);", "if (w > cMaxPNGSize || h > cMaxPNGSize) {", "return false;", "}", "x0 = 0;", "y0 = 0;", "delay_num = 1;", "delay_den = 10;", "dop = 0;", "bop = 0;", "rowbytes = w * 4;", "imagesize = h * rowbytes;", "frameRaw.p = new unsigned char[imagesize];", "frameRaw.rows = new png_bytep[h * sizeof(png_bytep)];", "for (j = 0; j < h; j++) frameRaw.rows[j] = frameRaw.p + j * rowbytes;", "if (!processing_start(png_ptr, info_ptr, (void*)&frameRaw, hasInfo,", "chunkIHDR, chunksInfo)) {", "bool last_base_was_none = true;", "while (!r.Eof()) {", "id = read_chunk(&r, &chunk);", "if (!id) break;", "JXL_ASSERT(chunk.p != nullptr);", "if (id == kId_acTL && !hasInfo && !isAnimated) {", "isAnimated = true;", "skipFirst = true;", "io->metadata.m.have_animation = true;", "io->metadata.m.animation.tps_numerator = 1000;", "} else if (id == kId_IEND ||", "(id == kId_fcTL && (!hasInfo || isAnimated))) {", "if (hasInfo) {", "if (!processing_finish(png_ptr, info_ptr)) {", "ImageBundle bundle(&io->metadata.m);", "bundle.duration = delay_num * 1000 / delay_den;", "bundle.origin.x0 = x0;", "bundle.origin.y0 = y0;", "if (last_base_was_none && !all_dispose_bg &&", "(x0 != 0 || y0 != 0 || w0 != w || h0 != h || bop != 0)) {", "return JXL_FAILURE(", "\"APNG with dispose-to-0 is not supported for non-full or \"", "\"blended frames\");", "}", "switch (dop) {", "case 0:", "bundle.use_for_next_frame = true;", "last_base_was_none = false;", "all_dispose_bg = false;", "break;", "case 2:", "bundle.use_for_next_frame = false;", "all_dispose_bg = false;", "break;", "default:", "bundle.use_for_next_frame = false;", "last_base_was_none = true;", "}", "bundle.blend = bop != 0;", "io->dec_pixels += w0 * h0;", "Image3F sub_frame(w0, h0);", "ImageF sub_frame_alpha(w0, h0);", "for (size_t y = 0; y < h0; ++y) {", "float* const JXL_RESTRICT row_r = sub_frame.PlaneRow(0, y);", "float* const JXL_RESTRICT row_g = sub_frame.PlaneRow(1, y);", "float* const JXL_RESTRICT row_b = sub_frame.PlaneRow(2, y);", "float* const JXL_RESTRICT row_alpha = sub_frame_alpha.Row(y);", "uint8_t* const f = frameRaw.rows[y];", "for (size_t x = 0; x < w0; ++x) {", "if (f[4 * x + 3] == 0) {", "row_alpha[x] = 0;", "row_r[x] = 0;", "row_g[x] = 0;", "row_b[x] = 0;", "continue;", "}", "row_r[x] = f[4 * x + 0] * (1.f / 255);", "row_g[x] = f[4 * x + 1] * (1.f / 255);", "row_b[x] = f[4 * x + 2] * (1.f / 255);", "row_alpha[x] = f[4 * x + 3] * (1.f / 255);", "}", "}", "bundle.SetFromImage(std::move(sub_frame), ColorEncoding::SRGB());", "bundle.SetAlpha(std::move(sub_frame_alpha),", "false);", "io->frames.push_back(std::move(bundle));", "} else {", "delete[] chunk.p;", "break;", "}", "}", "if (id == kId_IEND) {", "errorstate = false;", "break;", "}", "w0 = png_get_uint_32(chunk.p + 12);", "h0 = png_get_uint_32(chunk.p + 16);", "x0 = png_get_uint_32(chunk.p + 20);", "y0 = png_get_uint_32(chunk.p + 24);", "delay_num = png_get_uint_16(chunk.p + 28);", "delay_den = png_get_uint_16(chunk.p + 30);", "dop = chunk.p[32];", "bop = chunk.p[33];", "if (w0 > cMaxPNGSize || h0 > cMaxPNGSize || x0 > cMaxPNGSize ||", "y0 > cMaxPNGSize || x0 + w0 > w || y0 + h0 > h || dop > 2 ||", "bop > 1) {", "delete[] chunk.p;", "break;", "}", "if (hasInfo) {", "memcpy(chunkIHDR.p + 8, chunk.p + 12, 8);", "if (processing_start(png_ptr, info_ptr, (void*)&frameRaw, hasInfo,", "chunkIHDR, chunksInfo)) {", "delete[] chunk.p;", "break;", "}", "} else", "skipFirst = false;", "if (io->frames.size() == (skipFirst ? 1 : 0)) {", "bop = 0;", "if (dop == 2) dop = 1;", "}", "} else if (id == kId_IDAT) {", "hasInfo = true;", "if (processing_data(png_ptr, info_ptr, chunk.p, chunk.size)) {", "delete[] chunk.p;", "break;", "}", "} else if (id == kId_fdAT && isAnimated) {", "png_save_uint_32(chunk.p + 4, chunk.size - 16);", "memcpy(chunk.p + 8, \"IDAT\", 4);", "if (processing_data(png_ptr, info_ptr, chunk.p + 4, chunk.size - 4)) {", "delete[] chunk.p;", "break;", "}", "} else if (!isAbc(chunk.p[4]) || !isAbc(chunk.p[5]) ||", "!isAbc(chunk.p[6]) || !isAbc(chunk.p[7])) {", "delete[] chunk.p;", "break;", "} else if (!hasInfo) {", "if (processing_data(png_ptr, info_ptr, chunk.p, chunk.size)) {", "delete[] chunk.p;", "break;", "}", "chunksInfo.push_back(chunk);", "continue;", "}", "delete[] chunk.p;", "}", "}", "delete[] frameRaw.rows;", "delete[] frameRaw.p;", "}", "for (i = 0; i < chunksInfo.size(); i++) delete[] chunksInfo[i].p;", "chunksInfo.clear();", "delete[] chunkIHDR.p;", "if (errorstate) return false;", "SetIntensityTarget(io);", "return true;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static void gf_dump_vrml_dyn_field(GF_SceneDumper *sdump, GF_Node *node, GF_FieldInfo field, Bool has_sublist)", "{", "u32 i, sf_type;", "void *slot_ptr;", "if (gf_sg_vrml_is_sf_field(field.fieldType)) {", "DUMP_IND(sdump);", "if (sdump->XMLDump) {", "if (sdump->X3DDump) {", "gf_fprintf(sdump->trace, \"<field name=\\\"%s\\\" type=\\\"%s\\\" accessType=\\\"%s\\\"\",", "field.name, gf_sg_vrml_get_field_type_name(field.fieldType), gf_sg_vrml_get_event_type_name(field.eventType, 1));", "} else {", "gf_fprintf(sdump->trace, \"<field name=\\\"%s\\\" type=\\\"%s\\\" vrml97Hint=\\\"%s\\\"\",", "field.name, GetXMTFieldTypeName(field.fieldType), gf_sg_vrml_get_event_type_name(field.eventType, 0));", "}", "if ((field.eventType == GF_SG_EVENT_FIELD) || (field.eventType == GF_SG_EVENT_EXPOSED_FIELD)) {", "if (field.fieldType == GF_SG_VRML_SFNODE) {", "if (!sdump->X3DDump) {", "gf_fprintf(sdump->trace, \">\\n\");", "sdump->indent++;", "gf_fprintf(sdump->trace, \"<node>\");", "gf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL);", "gf_fprintf(sdump->trace, \"</node>\");", "sdump->indent--;", "if (!has_sublist)", "gf_fprintf(sdump->trace, \"</field>\\n\");", "} else {", "if (field.far_ptr) {", "gf_fprintf(sdump->trace, \">\\n\");", "gf_dump_vrml_node(sdump, *(GF_Node **)field.far_ptr, 0, NULL);", "gf_fprintf(sdump->trace, \"</field>\\n\");", "} else {", "gf_fprintf(sdump->trace, \"/>\\n\");", "}", "}", "DUMP_IND(sdump);", "} else {", "if (sdump->X3DDump) {", "gf_fprintf(sdump->trace, \" value=\\\"\");", "} else {", "gf_fprintf(sdump->trace, \" %s=\\\"\", GetXMTFieldTypeValueName(field.fieldType));", "}", "if (field.far_ptr)", "gf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, node);", "if (has_sublist)", "gf_fprintf(sdump->trace, \"\\\">\\n\");", "else", "gf_fprintf(sdump->trace, \"\\\"/>\\n\");", "}", "} else {", "gf_fprintf(sdump->trace, \"/>\\n\");", "}", "} else {", "gf_fprintf(sdump->trace, \"%s %s %s\", gf_sg_vrml_get_event_type_name(field.eventType, sdump->X3DDump), gf_sg_vrml_get_field_type_name(field.fieldType), field.name);", "if ((field.eventType==GF_SG_EVENT_FIELD) || (field.eventType==GF_SG_EVENT_EXPOSED_FIELD)) {", "gf_fprintf(sdump->trace, \" \");", "if (field.fieldType == GF_SG_VRML_SFNODE) {", "gf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL);", "} else if (field.far_ptr) {", "gf_dump_vrml_simple_field(sdump, field, node);", "}", "}", "gf_fprintf(sdump->trace, \"\\n\");", "}", "} else if (field.far_ptr) {", "GenMFField *mffield = (GenMFField *) field.far_ptr;", "sf_type = gf_sg_vrml_get_sf_type(field.fieldType);", "DUMP_IND(sdump);", "if (!sdump->XMLDump) {", "gf_fprintf(sdump->trace, \"%s %s %s\", gf_sg_vrml_get_event_type_name(field.eventType, sdump->X3DDump), gf_sg_vrml_get_field_type_name(field.fieldType), field.name);", "if ((field.eventType==GF_SG_EVENT_FIELD) || (field.eventType==GF_SG_EVENT_EXPOSED_FIELD)) {", "gf_fprintf(sdump->trace, \" [\");", "if (sf_type == GF_SG_VRML_SFNODE) {", "GF_ChildNodeItem *l = *(GF_ChildNodeItem **)field.far_ptr;", "gf_fprintf(sdump->trace, \"\\n\");", "sdump->indent++;", "while (l) {", "gf_dump_vrml_node(sdump, l->node, 1, NULL);", "l = l->next;", "}", "sdump->indent--;", "DUMP_IND(sdump);", "} else {", "for (i=0; i<mffield->count; i++) {", "if (i) gf_fprintf(sdump->trace, \" \");", "if (field.fieldType != GF_SG_VRML_MFNODE) {", "gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);", "gf_dump_vrml_sffield(sdump, sf_type, slot_ptr, (mffield->count>1) ? 1 : 0, node);", "}", "}", "}", "gf_fprintf(sdump->trace, \"]\");", "}", "gf_fprintf(sdump->trace, \"\\n\");", "} else {", "if (sdump->X3DDump) {", "gf_fprintf(sdump->trace, \"<field name=\\\"%s\\\" type=\\\"%s\\\" accessType=\\\"%s\\\"\",", "field.name, gf_sg_vrml_get_field_type_name(field.fieldType), gf_sg_vrml_get_event_type_name(field.eventType, 1));", "} else {", "gf_fprintf(sdump->trace, \"<field name=\\\"%s\\\" type=\\\"%s\\\" vrml97Hint=\\\"%s\\\"\",", "field.name, GetXMTFieldTypeName(field.fieldType), gf_sg_vrml_get_event_type_name(field.eventType, 0));", "}", "if ((field.eventType==GF_SG_EVENT_FIELD) || (field.eventType==GF_SG_EVENT_EXPOSED_FIELD)) {", "if (sf_type == GF_SG_VRML_SFNODE) {", "GF_ChildNodeItem *list = *(GF_ChildNodeItem **)field.far_ptr;", "gf_fprintf(sdump->trace, \">\\n\");", "sdump->indent++;", "if (!sdump->X3DDump) gf_fprintf(sdump->trace, \"<nodes>\");", "while (list) {", "gf_dump_vrml_node(sdump, list->node, 1, NULL);", "list = list->next;", "}", "if (!sdump->X3DDump) gf_fprintf(sdump->trace, \"</nodes>\");", "sdump->indent++;", "DUMP_IND(sdump);", "if (!has_sublist)", "gf_fprintf(sdump->trace, \"</field>\\n\");", "} else {", "if (sdump->X3DDump) {", "gf_fprintf(sdump->trace, \" value=\\\"\");", "} else {", "gf_fprintf(sdump->trace, \" %s=\\\"\", GetXMTFieldTypeValueName(field.fieldType));", "}", "for (i=0; i<mffield->count; i++) {", "if (i) gf_fprintf(sdump->trace, \" \");", "if (field.fieldType != GF_SG_VRML_MFNODE) {", "gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);", "gf_dump_vrml_sffield(sdump, sf_type, slot_ptr, (mffield->count>1) ? 1 : 0, node);", "}", "}", "if (has_sublist)", "gf_fprintf(sdump->trace, \"\\\">\\n\");", "else", "gf_fprintf(sdump->trace, \"\\\"/>\\n\");", "}", "} else {", "gf_fprintf(sdump->trace, \"/>\\n\");", "}", "}", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["GF_Err stbl_AddChunkOffset(GF_MediaBox *mdia, u32 sampleNumber, u32 StreamDescIndex, u64 offset, u32 nb_pack_samples)", "{", "GF_SampleTableBox *stbl;", "GF_ChunkOffsetBox *stco;", "GF_SampleToChunkBox *stsc;", "GF_ChunkLargeOffsetBox *co64;", "GF_StscEntry *ent;", "u32 i, k, *newOff, new_chunk_idx=0;", "u64 *newLarge;", "s32 insert_idx = -1;", "stbl = mdia->information->sampleTable;", "stsc = stbl->SampleToChunk;", "if (!nb_pack_samples)", "nb_pack_samples = 1;", "if (!stsc->nb_entries || (stsc->nb_entries + 2 >= stsc->alloc_size)) {", "if (!stsc->alloc_size) stsc->alloc_size = 1;", "ALLOC_INC(stsc->alloc_size);", "stsc->entries = gf_realloc(stsc->entries, sizeof(GF_StscEntry)*stsc->alloc_size);", "if (!stsc->entries) return GF_OUT_OF_MEM;", "memset(&stsc->entries[stsc->nb_entries], 0, sizeof(GF_StscEntry)*(stsc->alloc_size-stsc->nb_entries) );", "}", "if (sampleNumber == stsc->w_lastSampleNumber + 1) {", "ent = &stsc->entries[stsc->nb_entries];", "stsc->w_lastChunkNumber ++;", "ent->firstChunk = stsc->w_lastChunkNumber;", "if (stsc->nb_entries) stsc->entries[stsc->nb_entries-1].nextChunk = stsc->w_lastChunkNumber;", "new_chunk_idx = stsc->w_lastChunkNumber;", "stsc->w_lastSampleNumber = sampleNumber + nb_pack_samples-1;", "stsc->nb_entries += 1;", "} else {", "u32 cur_samp = 1;", "u32 samples_in_next_entry = 0;", "u32 next_entry_first_chunk = 1;", "for (i=0; i<stsc->nb_entries; i++) {", "u32 nb_chunks = 1;", "ent = &stsc->entries[i];", "if (i+1<stsc->nb_entries) nb_chunks = stsc->entries[i+1].firstChunk - ent->firstChunk;", "for (k=0; k<nb_chunks; k++) {", "if ((cur_samp <= sampleNumber) && (ent->samplesPerChunk + cur_samp > sampleNumber)) {", "insert_idx = i;", "if (sampleNumber>cur_samp) {", "samples_in_next_entry = ent->samplesPerChunk - (sampleNumber-cur_samp);", "ent->samplesPerChunk = sampleNumber-cur_samp;", "}", "break;", "}", "cur_samp += ent->samplesPerChunk;", "next_entry_first_chunk++;", "}", "if (insert_idx>=0) break;", "}", "if (samples_in_next_entry) {", "memmove(&stsc->entries[insert_idx+3], &stsc->entries[insert_idx+1], sizeof(GF_StscEntry)*(stsc->nb_entries - insert_idx - 1));", "ent = &stsc->entries[insert_idx];", "stsc->entries[insert_idx+2] = *ent;", "stsc->entries[insert_idx+2].samplesPerChunk = samples_in_next_entry;", "stsc->entries[insert_idx+2].firstChunk = next_entry_first_chunk + 1;", "ent = &stsc->entries[insert_idx+1];", "ent->firstChunk = next_entry_first_chunk;", "stsc->nb_entries += 2;", "} else {", "if (insert_idx<0) {", "ent = &stsc->entries[stsc->nb_entries];", "insert_idx = stsc->nb_entries;", "} else {", "memmove(&stsc->entries[insert_idx+1], &stsc->entries[insert_idx], sizeof(GF_StscEntry)*(stsc->nb_entries+1-insert_idx));", "ent = &stsc->entries[insert_idx+1];", "}", "ent->firstChunk = next_entry_first_chunk;", "stsc->nb_entries += 1;", "}", "new_chunk_idx = next_entry_first_chunk;", "}", "ent->isEdited = (Media_IsSelfContained(mdia, StreamDescIndex)) ? 1 : 0;", "ent->sampleDescriptionIndex = StreamDescIndex;", "ent->samplesPerChunk = nb_pack_samples;", "ent->nextChunk = ent->firstChunk+1;", "if (sampleNumber + nb_pack_samples - 1 == stsc->w_lastSampleNumber) {", "if (stsc->nb_entries)", "stsc->entries[stsc->nb_entries-1].nextChunk = ent->firstChunk;", "stbl->SampleToChunk->currentIndex = stsc->nb_entries-1;", "stbl->SampleToChunk->firstSampleInCurrentChunk = sampleNumber;", "stbl->SampleToChunk->currentChunk = stsc->w_lastChunkNumber;", "stbl->SampleToChunk->ghostNumber = 1;", "} else {", "for (i = insert_idx+1; i<stsc->nb_entries+1; i++) {", "stsc->entries[i].firstChunk++;", "if (i+1<stsc->nb_entries)", "stsc->entries[i-1].nextChunk = stsc->entries[i].firstChunk;", "}", "}", "if (stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {", "stco = (GF_ChunkOffsetBox *)stbl->ChunkOffset;", "if (offset > 0xFFFFFFFF) {", "co64 = (GF_ChunkLargeOffsetBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_CO64);", "if (!co64) return GF_OUT_OF_MEM;", "co64->nb_entries = stco->nb_entries + 1;", "co64->alloc_size = co64->nb_entries;", "co64->offsets = (u64*)gf_malloc(sizeof(u64) * co64->nb_entries);", "if (!co64->offsets) return GF_OUT_OF_MEM;", "k = 0;", "for (i=0; i<stco->nb_entries; i++) {", "if (i + 1 == new_chunk_idx) {", "co64->offsets[i] = offset;", "k = 1;", "}", "co64->offsets[i+k] = (u64) stco->offsets[i];", "}", "if (!k) co64->offsets[co64->nb_entries - 1] = offset;", "gf_isom_box_del_parent(&stbl->child_boxes, stbl->ChunkOffset);", "stbl->ChunkOffset = (GF_Box *) co64;", "} else {", "if (new_chunk_idx > stco->nb_entries) {", "if (!stco->alloc_size) stco->alloc_size = stco->nb_entries;", "if (stco->nb_entries == stco->alloc_size) {", "ALLOC_INC(stco->alloc_size);", "stco->offsets = (u32*)gf_realloc(stco->offsets, sizeof(u32) * stco->alloc_size);", "if (!stco->offsets) return GF_OUT_OF_MEM;", "memset(&stco->offsets[stco->nb_entries], 0, sizeof(u32) * (stco->alloc_size-stco->nb_entries) );", "}", "stco->offsets[stco->nb_entries] = (u32) offset;", "stco->nb_entries += 1;", "} else {", "newOff = (u32*)gf_malloc(sizeof(u32) * (stco->nb_entries + 1));", "if (!newOff) return GF_OUT_OF_MEM;", "k=0;", "for (i=0; i<stco->nb_entries; i++) {", "if (i+1 == new_chunk_idx) {", "newOff[i] = (u32) offset;", "k=1;", "}", "newOff[i+k] = stco->offsets[i];", "}", "gf_free(stco->offsets);", "stco->offsets = newOff;", "stco->nb_entries ++;", "stco->alloc_size = stco->nb_entries;", "}", "}", "} else {", "co64 = (GF_ChunkLargeOffsetBox *)stbl->ChunkOffset;", "if (sampleNumber > co64->nb_entries) {", "if (!co64->alloc_size) co64->alloc_size = co64->nb_entries;", "if (co64->nb_entries == co64->alloc_size) {", "ALLOC_INC(co64->alloc_size);", "co64->offsets = (u64*)gf_realloc(co64->offsets, sizeof(u64) * co64->alloc_size);", "if (!co64->offsets) return GF_OUT_OF_MEM;", "memset(&co64->offsets[co64->nb_entries], 0, sizeof(u64) * (co64->alloc_size - co64->nb_entries) );", "}", "co64->offsets[co64->nb_entries] = offset;", "co64->nb_entries += 1;", "} else {", "newLarge = (u64*)gf_malloc(sizeof(u64) * (co64->nb_entries + 1));", "if (!newLarge) return GF_OUT_OF_MEM;", "k=0;", "for (i=0; i<co64->nb_entries; i++) {", "if (i+1 == new_chunk_idx) {", "newLarge[i] = offset;", "k=1;", "}", "newLarge[i+k] = co64->offsets[i];", "}", "gf_free(co64->offsets);", "co64->offsets = newLarge;", "co64->nb_entries++;", "co64->alloc_size++;", "}", "}", "return GF_OK;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int vidioc_querycap(struct file *file, void *priv,", "struct v4l2_capability *cap)", "{", "struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);", "int labellen = (sizeof(cap->card) < sizeof(dev->card_label)) ?", "sizeof(cap->card) :", "sizeof(dev->card_label);", "int device_nr =", "((struct v4l2loopback_private *)video_get_drvdata(dev->vdev))", "->device_nr;", "__u32 capabilities = V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;", "strlcpy(cap->driver, \"v4l2 loopback\", sizeof(cap->driver));", "snprintf(cap->card, labellen, dev->card_label);", "snprintf(cap->bus_info, sizeof(cap->bus_info),", "\"platform:v4l2loopback-%03d\", device_nr);", "#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 1, 0)", "cap->version = V4L2LOOPBACK_VERSION_CODE;", "#endif", "#ifdef V4L2_CAP_VIDEO_M2M", "capabilities |= V4L2_CAP_VIDEO_M2M;", "#endif /* V4L2_CAP_VIDEO_M2M */", "if (dev->announce_all_caps) {", "capabilities |= V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_OUTPUT;", "} else {", "if (dev->ready_for_capture) {", "capabilities |= V4L2_CAP_VIDEO_CAPTURE;", "}", "if (dev->ready_for_output) {", "capabilities |= V4L2_CAP_VIDEO_OUTPUT;", "}", "}", "#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)", "dev->vdev->device_caps =", "#endif /* >=linux-4.7.0 */", "cap->device_caps = cap->capabilities = capabilities;", "#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0)", "cap->capabilities |= V4L2_CAP_DEVICE_CAPS;", "#endif", "memset(cap->reserved, 0, sizeof(cap->reserved));", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["PackLinuxElf64::invert_pt_dynamic(Elf64_Dyn const *dynp)", "{", "if (dt_table[Elf64_Dyn::DT_NULL]) {", "return;", "}", "Elf64_Dyn const *const dynp0 = dynp;", "unsigned ndx = 1+ 0;", "if (dynp)", "for (; ; ++ndx, ++dynp) {", "upx_uint64_t const d_tag = get_te64(&dynp->d_tag);", "if (d_tag>>32) {", "char msg[50]; snprintf(msg, sizeof(msg),", "\"bad Elf64_Dyn[%d].d_tag %#lx\", -1+ ndx, (long unsigned)d_tag);", "throwCantPack(msg);", "}", "if (d_tag < DT_NUM) {", "dt_table[d_tag] = ndx;", "}", "if (Elf64_Dyn::DT_NULL == d_tag) {", "break;", "}", "}", "upx_dt_init = 0;", "if (dt_table[Elf64_Dyn::DT_INIT])          upx_dt_init = Elf64_Dyn::DT_INIT;", "else if (dt_table[Elf64_Dyn::DT_PREINIT_ARRAY]) upx_dt_init = Elf64_Dyn::DT_PREINIT_ARRAY;", "else if (dt_table[Elf64_Dyn::DT_INIT_ARRAY])    upx_dt_init = Elf64_Dyn::DT_INIT_ARRAY;", "unsigned const z_str = dt_table[Elf64_Dyn::DT_STRSZ];", "if (z_str) {", "strtab_end = get_te64(&dynp0[-1+ z_str].d_val);", "if ((u64_t)file_size <= strtab_end) {", "char msg[50]; snprintf(msg, sizeof(msg),", "\"bad DT_STRSZ %#x\", strtab_end);", "throwCantPack(msg);", "}", "}", "unsigned const x_sym = dt_table[Elf64_Dyn::DT_SYMTAB];", "unsigned const x_str = dt_table[Elf64_Dyn::DT_STRTAB];", "if (x_sym && x_str) {", "upx_uint64_t const v_sym = get_te64(&dynp0[-1+ x_sym].d_val);", "upx_uint64_t const v_str = get_te64(&dynp0[-1+ x_str].d_val);", "unsigned const  z_sym = dt_table[Elf64_Dyn::DT_SYMENT];", "unsigned const sz_sym = !z_sym ? sizeof(Elf64_Sym)", ": get_te64(&dynp0[-1+ z_sym].d_val);", "if (v_sym < v_str) {", "symnum_end = (v_str - v_sym) / sz_sym;", "}", "}", "unsigned const v_hsh = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH);", "if (v_hsh && file_image) {", "hashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_HASH);", "unsigned const nbucket = get_te32(&hashtab[0]);", "unsigned const *const buckets = &hashtab[2];", "unsigned const *const chains = &buckets[nbucket]; (void)chains;", "unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);", "if (!nbucket", "|| (nbucket>>31) || (file_size/sizeof(unsigned)) <= (2*nbucket)", "|| ((v_hsh < v_sym) && (v_sym - v_hsh) < (sizeof(unsigned)*2", "+ sizeof(*buckets)*nbucket", "+ sizeof(*chains) *nbucket", "))", ") {", "char msg[90]; snprintf(msg, sizeof(msg),", "\"bad DT_HASH nbucket=%#x  len=%#x\",", "nbucket, (v_sym - v_hsh));", "throwCantPack(msg);", "}", "}", "unsigned const v_gsh = elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH);", "if (v_gsh && file_image) {", "gashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_GNU_HASH);", "unsigned const n_bucket = get_te32(&gashtab[0]);", "unsigned const n_bitmask = get_te32(&gashtab[2]);", "unsigned const gnu_shift = get_te32(&gashtab[3]);", "upx_uint64_t const *const bitmask = (upx_uint64_t const *)(void const *)&gashtab[4];", "unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask];", "unsigned     const *const hasharr = &buckets[n_bucket]; (void)hasharr;", "upx_uint64_t const v_sym = get_te64(&dynp0[-1+ x_sym].d_val);", "if (!n_bucket || !n_bitmask", "|| (-1+ n_bitmask) & n_bitmask", "|| 8*sizeof(upx_uint64_t) <= gnu_shift", "|| (n_bucket>>30)", "|| (n_bitmask>>30)", "|| (file_size/sizeof(unsigned)) <= ((sizeof(*bitmask)/sizeof(unsigned))*n_bitmask + 2*n_bucket)", "|| ((v_gsh < v_sym) && (v_sym - v_gsh) < (sizeof(unsigned)*4", "+ sizeof(*bitmask)*n_bitmask", "+ sizeof(*buckets)*n_bucket", "+ sizeof(*hasharr)*n_bucket", "))", ") {", "char msg[90]; snprintf(msg, sizeof(msg),", "\"bad DT_GNU_HASH n_bucket=%#x  n_bitmask=%#x  len=%#lx\",", "n_bucket, n_bitmask, (long unsigned)(v_sym - v_gsh));", "throwCantPack(msg);", "}", "}", "unsigned const e_shstrndx = get_te16(&ehdri.e_shstrndx);", "if (e_shnum <= e_shstrndx", "&&  !(0==e_shnum && 0==e_shstrndx) ) {", "char msg[40]; snprintf(msg, sizeof(msg),", "\"bad .e_shstrndx %d >= .e_shnum %d\", e_shstrndx, e_shnum);", "throwCantPack(msg);", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["flac_buffer_copy (SF_PRIVATE *psf)", "{ FLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;", "const FLAC__Frame *frame = pflac->frame ;", "const int32_t* const *buffer = pflac->wbuffer ;", "unsigned i = 0, j, offset, channels, len ;", "if (frame->header.blocksize > FLAC__MAX_BLOCK_SIZE)", "{ psf_log_printf (psf, \"Ooops : frame->header.blocksize (%d) > FLAC__MAX_BLOCK_SIZE (%d)\\n\", __func__, __LINE__, frame->header.blocksize, FLAC__MAX_BLOCK_SIZE) ;", "psf->error = SFE_INTERNAL ;", "return 0 ;", "} ;", "if (frame->header.channels > FLAC__MAX_CHANNELS)", "psf_log_printf (psf, \"Ooops : frame->header.channels (%d) > FLAC__MAX_BLOCK_SIZE (%d)\\n\", __func__, __LINE__, frame->header.channels, FLAC__MAX_CHANNELS) ;", "channels = SF_MIN (frame->header.channels, FLAC__MAX_CHANNELS) ;", "if (pflac->ptr == NULL)", "{", "pflac->bufferbackup = SF_TRUE ;", "for (i = 0 ; i < channels ; i++)", "{", "if (pflac->rbuffer [i] == NULL)", "pflac->rbuffer [i] = calloc (FLAC__MAX_BLOCK_SIZE, sizeof (int32_t)) ;", "memcpy (pflac->rbuffer [i], buffer [i], frame->header.blocksize * sizeof (int32_t)) ;", "} ;", "pflac->wbuffer = (const int32_t* const*) pflac->rbuffer ;", "return 0 ;", "} ;", "len = SF_MIN (pflac->len, frame->header.blocksize) ;", "switch (pflac->pcmtype)", "{ case PFLAC_PCM_SHORT :", "{ short *retpcm = (short*) pflac->ptr ;", "int shift = 16 - frame->header.bits_per_sample ;", "if (shift < 0)", "{ shift = abs (shift) ;", "for (i = 0 ; i < len && pflac->remain > 0 ; i++)", "{ offset = pflac->pos + i * channels ;", "if (pflac->bufferpos >= frame->header.blocksize)", "break ;", "if (offset + channels > pflac->len)", "break ;", "for (j = 0 ; j < channels ; j++)", "retpcm [offset + j] = buffer [j][pflac->bufferpos] >> shift ;", "pflac->remain -= channels ;", "pflac->bufferpos++ ;", "}", "}", "else", "{ for (i = 0 ; i < len && pflac->remain > 0 ; i++)", "{ offset = pflac->pos + i * channels ;", "if (pflac->bufferpos >= frame->header.blocksize)", "break ;", "if (offset + channels > pflac->len)", "break ;", "for (j = 0 ; j < channels ; j++)", "retpcm [offset + j] = ((uint16_t) buffer [j][pflac->bufferpos]) << shift ;", "pflac->remain -= channels ;", "pflac->bufferpos++ ;", "} ;", "} ;", "} ;", "break ;", "case PFLAC_PCM_INT :", "{ int *retpcm = (int*) pflac->ptr ;", "int shift = 32 - frame->header.bits_per_sample ;", "for (i = 0 ; i < len && pflac->remain > 0 ; i++)", "{ offset = pflac->pos + i * channels ;", "if (pflac->bufferpos >= frame->header.blocksize)", "break ;", "if (offset + channels > pflac->len)", "break ;", "for (j = 0 ; j < channels ; j++)", "retpcm [offset + j] = ((uint32_t) buffer [j][pflac->bufferpos]) << shift ;", "pflac->remain -= channels ;", "pflac->bufferpos++ ;", "} ;", "} ;", "break ;", "case PFLAC_PCM_FLOAT :", "{ float *retpcm = (float*) pflac->ptr ;", "float norm = (psf->norm_float == SF_TRUE) ? 1.0 / (1 << (frame->header.bits_per_sample - 1)) : 1.0 ;", "for (i = 0 ; i < len && pflac->remain > 0 ; i++)", "{ offset = pflac->pos + i * channels ;", "if (pflac->bufferpos >= frame->header.blocksize)", "break ;", "if (offset + channels > pflac->len)", "break ;", "for (j = 0 ; j < channels ; j++)", "retpcm [offset + j] = buffer [j][pflac->bufferpos] * norm ;", "pflac->remain -= channels ;", "pflac->bufferpos++ ;", "} ;", "} ;", "break ;", "case PFLAC_PCM_DOUBLE :", "{ double *retpcm = (double*) pflac->ptr ;", "double norm = (psf->norm_double == SF_TRUE) ? 1.0 / (1 << (frame->header.bits_per_sample - 1)) : 1.0 ;", "for (i = 0 ; i < len && pflac->remain > 0 ; i++)", "{ offset = pflac->pos + i * channels ;", "if (pflac->bufferpos >= frame->header.blocksize)", "break ;", "if (offset + channels > pflac->len)", "break ;", "for (j = 0 ; j < channels ; j++)", "retpcm [offset + j] = buffer [j][pflac->bufferpos] * norm ;", "pflac->remain -= channels ;", "pflac->bufferpos++ ;", "} ;", "} ;", "break ;", "default :", "return 0 ;", "} ;", "offset = i * channels ;", "pflac->pos += i * channels ;", "return offset ;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["int PackLinuxElf32::canUnpack()", "{", "if (super::canUnpack()) {", "return true;", "}", "if (Elf32_Ehdr::ET_DYN==get_te16(&ehdri.e_type)) {", "PackLinuxElf32help1(fi);", "}", "return false;", "}"], "ner_tags": [0, 0, 1, 1, 0, 1, 0, 0, 1, 0]}
{"tokens": ["size_t OpenMP4SourceUDTA(char *filename)", "{", "mp4object *mp4 = (mp4object *)malloc(sizeof(mp4object));", "if (mp4 == NULL) return 0;", "memset(mp4, 0, sizeof(mp4object));", "#ifdef _WINDOWS", "fopen_s(&mp4->mediafp, filename, \"rb\");", "#else", "mp4->mediafp = fopen(filename, \"rb\");", "#endif", "if (mp4->mediafp)", "{", "uint32_t qttag, qtsize32, len;", "int32_t nest = 0;", "uint64_t nestsize[MAX_NEST_LEVEL] = { 0 };", "uint64_t lastsize = 0, qtsize;", "do", "{", "len = fread(&qtsize32, 1, 4, mp4->mediafp);", "len += fread(&qttag, 1, 4, mp4->mediafp);", "if (len == 8)", "{", "if (!GPMF_VALID_FOURCC(qttag))", "{", "LONGSEEK(mp4->mediafp, lastsize - 8 - 8, SEEK_CUR);", "NESTSIZE(lastsize - 8);", "continue;", "}", "qtsize32 = BYTESWAP32(qtsize32);", "if (qtsize32 == 1)", "{", "fread(&qtsize, 1, 8, mp4->mediafp);", "qtsize = BYTESWAP64(qtsize) - 8;", "}", "else", "qtsize = qtsize32;", "nest++;", "if (qtsize < 8) break;", "if (nest >= MAX_NEST_LEVEL) break;", "nestsize[nest] = qtsize;", "lastsize = qtsize;", "if (qttag == MAKEID('m', 'd', 'a', 't') ||", "qttag == MAKEID('f', 't', 'y', 'p'))", "{", "LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);", "NESTSIZE(qtsize);", "continue;", "}", "if (qttag == MAKEID('G', 'P', 'M', 'F'))", "{", "mp4->videolength += 1.0;", "mp4->metadatalength += 1.0;", "mp4->indexcount = (int)mp4->metadatalength;", "mp4->metasizes = (uint32_t *)malloc(mp4->indexcount * 4 + 4);  memset(mp4->metasizes, 0, mp4->indexcount * 4 + 4);", "mp4->metaoffsets = (uint64_t *)malloc(mp4->indexcount * 8 + 8);  memset(mp4->metaoffsets, 0, mp4->indexcount * 8 + 8);", "mp4->metasizes[0] = (int)qtsize - 8;", "mp4->metaoffsets[0] = ftell(mp4->mediafp);", "mp4->metasize_count = 1;", "return (size_t)mp4;", "}", "if (qttag != MAKEID('m', 'o', 'o', 'v') &&", "qttag != MAKEID('u', 'd', 't', 'a'))", "{", "LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);", "NESTSIZE(qtsize);", "continue;", "}", "else", "{", "NESTSIZE(8);", "}", "}", "} while (len > 0);", "}", "return (size_t)mp4;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["Error HeifContext::interpret_heif_file()", "{", "m_all_images.clear();", "m_top_level_images.clear();", "m_primary_image.reset();", "std::vector<heif_item_id> image_IDs = m_heif_file->get_item_IDs();", "bool primary_is_grid = false;", "for (heif_item_id id : image_IDs) {", "auto infe_box = m_heif_file->get_infe_box(id);", "if (!infe_box) {", "continue;", "}", "if (item_type_is_image(infe_box->get_item_type())) {", "auto image = std::make_shared<Image>(this, id);", "m_all_images.insert(std::make_pair(id, image));", "if (!infe_box->is_hidden_item()) {", "if (id==m_heif_file->get_primary_image_ID()) {", "image->set_primary(true);", "m_primary_image = image;", "primary_is_grid = infe_box->get_item_type() == \"grid\";", "}", "m_top_level_images.push_back(image);", "}", "}", "}", "if (!m_primary_image) {", "return Error(heif_error_Invalid_input,", "heif_suberror_Nonexisting_item_referenced,", "\"'pitm' box references a non-existing image\");", "}", "auto iref_box = m_heif_file->get_iref_box();", "if (iref_box) {", "for (auto& pair : m_all_images) {", "auto& image = pair.second;", "std::vector<Box_iref::Reference> references = iref_box->get_references_from(image->get_id());", "for (const Box_iref::Reference& ref : references) {", "uint32_t type = ref.header.get_short_type();", "if (type==fourcc(\"thmb\")) {", "std::vector<heif_item_id> refs = ref.to_item_ID;", "if (refs.size() != 1) {", "return Error(heif_error_Invalid_input,", "heif_suberror_Unspecified,", "\"Too many thumbnail references\");", "}", "image->set_is_thumbnail_of(refs[0]);", "auto master_iter = m_all_images.find(refs[0]);", "if (master_iter == m_all_images.end()) {", "return Error(heif_error_Invalid_input,", "heif_suberror_Nonexisting_item_referenced,", "\"Thumbnail references a non-existing image\");", "}", "if (master_iter->second->is_thumbnail()) {", "return Error(heif_error_Invalid_input,", "heif_suberror_Nonexisting_item_referenced,", "\"Thumbnail references another thumbnail\");", "}", "if (image.get() == master_iter->second.get()) {", "return Error(heif_error_Invalid_input,", "heif_suberror_Nonexisting_item_referenced,", "\"Recursive thumbnail image detected\");", "}", "master_iter->second->add_thumbnail(image);", "remove_top_level_image(image);", "}", "else if (type==fourcc(\"auxl\")) {", "std::vector<Box_ipco::Property> properties;", "Error err = m_heif_file->get_properties(image->get_id(), properties);", "if (err) {", "return err;", "}", "std::shared_ptr<Box_auxC> auxC_property;", "for (const auto& property : properties) {", "auto auxC = std::dynamic_pointer_cast<Box_auxC>(property.property);", "if (auxC) {", "auxC_property = auxC;", "}", "}", "if (!auxC_property) {", "std::stringstream sstr;", "sstr << \"No auxC property for image \" << image->get_id();", "return Error(heif_error_Invalid_input,", "heif_suberror_Auxiliary_image_type_unspecified,", "sstr.str());", "}", "std::vector<heif_item_id> refs = ref.to_item_ID;", "if (refs.size() != 1) {", "return Error(heif_error_Invalid_input,", "heif_suberror_Unspecified,", "\"Too many auxiliary image references\");", "}", "if (auxC_property->get_aux_type() == \"urn:mpeg:avc:2015:auxid:1\" ||", "auxC_property->get_aux_type() == \"urn:mpeg:hevc:2015:auxid:1\") {", "image->set_is_alpha_channel_of(refs[0]);", "auto master_iter = m_all_images.find(refs[0]);", "if (image.get() == master_iter->second.get()) {", "return Error(heif_error_Invalid_input,", "heif_suberror_Nonexisting_item_referenced,", "\"Recursive alpha image detected\");", "}", "master_iter->second->set_alpha_channel(image);", "}", "if (auxC_property->get_aux_type() == \"urn:mpeg:hevc:2015:auxid:2\") {", "image->set_is_depth_channel_of(refs[0]);", "auto master_iter = m_all_images.find(refs[0]);", "if (image.get() == master_iter->second.get()) {", "return Error(heif_error_Invalid_input,", "heif_suberror_Nonexisting_item_referenced,", "\"Recursive depth image detected\");", "}", "master_iter->second->set_depth_channel(image);", "auto subtypes = auxC_property->get_subtypes();", "std::vector<std::shared_ptr<SEIMessage>> sei_messages;", "Error err = decode_hevc_aux_sei_messages(subtypes, sei_messages);", "for (auto& msg : sei_messages) {", "auto depth_msg = std::dynamic_pointer_cast<SEIMessage_depth_representation_info>(msg);", "if (depth_msg) {", "image->set_depth_representation_info(*depth_msg);", "}", "}", "}", "remove_top_level_image(image);", "}", "else {", "}", "}", "}", "}", "for (auto& pair : m_all_images) {", "auto& image = pair.second;", "std::shared_ptr<Box_infe> infe = m_heif_file->get_infe_box(image->get_id());", "if (infe->get_item_type() == \"hvc1\") {", "auto ipma = m_heif_file->get_ipma_box();", "auto ipco = m_heif_file->get_ipco_box();", "if (!ipco->get_property_for_item_ID(image->get_id(), ipma, fourcc(\"hvcC\"))) {", "return Error(heif_error_Invalid_input,", "heif_suberror_No_hvcC_box,", "\"No hvcC property in hvc1 type image\");", "}", "}", "}", "for (auto& pair : m_all_images) {", "auto& image = pair.second;", "std::vector<Box_ipco::Property> properties;", "Error err = m_heif_file->get_properties(pair.first, properties);", "if (err) {", "return err;", "}", "bool ispe_read = false;", "bool primary_colr_set = false;", "for (const auto& prop : properties) {", "auto ispe = std::dynamic_pointer_cast<Box_ispe>(prop.property);", "if (ispe) {", "uint32_t width = ispe->get_width();", "uint32_t height = ispe->get_height();", "if (width  >= static_cast<uint32_t>(MAX_IMAGE_WIDTH) ||", "height >= static_cast<uint32_t>(MAX_IMAGE_HEIGHT)) {", "std::stringstream sstr;", "sstr << \"Image size \" << width << \"x\" << height << \" exceeds the maximum image size \"", "<< MAX_IMAGE_WIDTH << \"x\" << MAX_IMAGE_HEIGHT << \"\\n\";", "return Error(heif_error_Memory_allocation_error,", "heif_suberror_Security_limit_exceeded,", "sstr.str());", "}", "image->set_resolution(width, height);", "image->set_ispe_resolution(width, height);", "ispe_read = true;", "}", "if (ispe_read) {", "auto clap = std::dynamic_pointer_cast<Box_clap>(prop.property);", "if (clap) {", "image->set_resolution( clap->get_width_rounded(),", "clap->get_height_rounded() );", "}", "auto irot = std::dynamic_pointer_cast<Box_irot>(prop.property);", "if (irot) {", "if (irot->get_rotation()==90 ||", "irot->get_rotation()==270) {", "image->set_resolution( image->get_height(),", "image->get_width() );", "}", "}", "}", "auto colr = std::dynamic_pointer_cast<Box_colr>(prop.property);", "if (colr) {", "auto profile = colr->get_color_profile();", "image->set_color_profile(profile);", "const bool is_grid_item = !image->is_primary() && !image->is_alpha_channel() && !image->is_depth_channel();", "if (primary_is_grid &&", "!primary_colr_set &&", "is_grid_item) {", "m_primary_image->set_color_profile(profile);", "primary_colr_set = true;", "}", "}", "}", "}", "for (heif_item_id id : image_IDs) {", "std::string item_type    = m_heif_file->get_item_type(id);", "std::string content_type = m_heif_file->get_content_type(id);", "if (item_type == \"Exif\" ||", "(item_type==\"mime\" && content_type==\"application/rdf+xml\")) {", "std::shared_ptr<ImageMetadata> metadata = std::make_shared<ImageMetadata>();", "metadata->item_id = id;", "metadata->item_type = item_type;", "metadata->content_type = content_type;", "Error err = m_heif_file->get_compressed_image_data(id, &(metadata->m_data));", "if (err) {", "return err;", "}", "if (iref_box) {", "std::vector<Box_iref::Reference> references = iref_box->get_references_from(id);", "for (const auto& ref : references) {", "if (ref.header.get_short_type() == fourcc(\"cdsc\")) {", "std::vector<uint32_t> refs = ref.to_item_ID;", "if (refs.size() != 1) {", "return Error(heif_error_Invalid_input,", "heif_suberror_Unspecified,", "\"Exif data not correctly assigned to image\");", "}", "uint32_t exif_image_id = refs[0];", "auto img_iter = m_all_images.find(exif_image_id);", "if (img_iter == m_all_images.end()) {", "return Error(heif_error_Invalid_input,", "heif_suberror_Nonexisting_item_referenced,", "\"Exif data assigned to non-existing image\");", "}", "img_iter->second->add_metadata(metadata);", "}", "}", "}", "}", "}", "return Error::Ok;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["GF_Err mpgviddmx_process(GF_Filter *filter)", "{", "GF_MPGVidDmxCtx *ctx = gf_filter_get_udta(filter);", "GF_FilterPacket *pck, *dst_pck;", "u64 byte_offset;", "s64 vosh_start = -1;", "s64 vosh_end = -1;", "GF_Err e;", "char *data;", "u8 *start;", "u32 pck_size;", "s32 remain;", "if (!ctx->duration.num)", "mpgviddmx_check_dur(filter, ctx);", "pck = gf_filter_pid_get_packet(ctx->ipid);", "if (!pck) {", "if (gf_filter_pid_is_eos(ctx->ipid)) {", "mpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_TRUE);", "if (ctx->opid)", "gf_filter_pid_set_eos(ctx->opid);", "if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);", "ctx->src_pck = NULL;", "return GF_EOS;", "}", "return GF_OK;", "}", "data = (char *) gf_filter_pck_get_data(pck, &pck_size);", "byte_offset = gf_filter_pck_get_byte_offset(pck);", "start = data;", "remain = pck_size;", "if (!ctx->resume_from && ctx->timescale) {", "u64 ts = gf_filter_pck_get_cts(pck);", "if (ts != GF_FILTER_NO_TS) {", "if (!ctx->cts || !ctx->recompute_cts)", "ctx->cts = ts;", "}", "ts = gf_filter_pck_get_dts(pck);", "if (ts != GF_FILTER_NO_TS) {", "if (!ctx->dts || !ctx->recompute_cts)", "ctx->dts = ts;", "if (!ctx->prev_dts) ctx->prev_dts = ts;", "else if (ctx->prev_dts != ts) {", "u64 diff = ts;", "diff -= ctx->prev_dts;", "if (!ctx->cur_fps.den) ctx->cur_fps.den = (u32) diff;", "else if (ctx->cur_fps.den > diff)", "ctx->cur_fps.den = (u32) diff;", "}", "}", "gf_filter_pck_get_framing(pck, &ctx->input_is_au_start, &ctx->input_is_au_end);", "if (ctx->recompute_cts) ctx->input_is_au_start = GF_FALSE;", "if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);", "ctx->src_pck = pck;", "gf_filter_pck_ref_props(&ctx->src_pck);", "}", "if (!ctx->resume_from && ctx->hdr_store_size) {", "if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size) {", "ctx->hdr_store_alloc = ctx->hdr_store_size + pck_size;", "ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);", "}", "memcpy(ctx->hdr_store + ctx->hdr_store_size, data, sizeof(char)*pck_size);", "if (byte_offset != GF_FILTER_NO_BO) {", "if (byte_offset >= ctx->hdr_store_size)", "byte_offset -= ctx->hdr_store_size;", "else", "byte_offset = GF_FILTER_NO_BO;", "}", "ctx->hdr_store_size += pck_size;", "start = data = ctx->hdr_store;", "remain = pck_size = ctx->hdr_store_size;", "}", "if (ctx->resume_from) {", "if (gf_filter_pid_would_block(ctx->opid))", "return GF_OK;", "if (ctx->hdr_store_size) {", "assert(ctx->resume_from <= ctx->hdr_store_size);", "start = data = ctx->hdr_store + ctx->resume_from;", "remain = pck_size = ctx->hdr_store_size - ctx->resume_from;", "} else {", "assert(remain >= (s32) ctx->resume_from);", "start += ctx->resume_from;", "remain -= ctx->resume_from;", "}", "ctx->resume_from = 0;", "}", "if (!ctx->bs) {", "ctx->bs = gf_bs_new(start, remain, GF_BITSTREAM_READ);", "} else {", "gf_bs_reassign_buffer(ctx->bs, start, remain);", "}", "if (!ctx->vparser) {", "ctx->vparser = gf_m4v_parser_bs_new(ctx->bs, ctx->is_mpg12);", "}", "while (remain) {", "Bool full_frame;", "u8 *pck_data;", "s32 current;", "u8 sc_type, forced_sc_type=0;", "Bool sc_type_forced = GF_FALSE;", "Bool skip_pck = GF_FALSE;", "u8 ftype;", "u32 tinc;", "u64 size=0;", "u64 fstart;", "Bool is_coded;", "u32 bytes_from_store = 0;", "u32 hdr_offset = 0;", "Bool copy_last_bytes = GF_FALSE;", "if (remain<5) {", "memcpy(ctx->hdr_store, start, remain);", "ctx->bytes_in_header = remain;", "break;", "}", "current = -1;", "if (ctx->bytes_in_header) {", "memcpy(ctx->hdr_store + ctx->bytes_in_header, start, 8 - ctx->bytes_in_header);", "current = mpgviddmx_next_start_code(ctx->hdr_store, 8);", "if ((current<0) || (current >= (s32) ctx->bytes_in_header) )  {", "if (ctx->opid) {", "dst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header, &pck_data);", "if (!dst_pck) return GF_OUT_OF_MEM;", "if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);", "gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);", "gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);", "memcpy(pck_data, ctx->hdr_store, ctx->bytes_in_header);", "gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);", "if (byte_offset != GF_FILTER_NO_BO) {", "gf_filter_pck_set_byte_offset(dst_pck, byte_offset - ctx->bytes_in_header);", "}", "mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);", "}", "if (current<0) current = -1;", "else current -= ctx->bytes_in_header;", "ctx->bytes_in_header = 0;", "} else {", "hdr_offset = 4 - ctx->bytes_in_header + current;", "bytes_from_store = ctx->bytes_in_header;", "ctx->bytes_in_header = 0;", "if (!hdr_offset) {", "forced_sc_type = ctx->hdr_store[current+3];", "} else {", "forced_sc_type = start[hdr_offset-1];", "}", "sc_type_forced = GF_TRUE;", "}", "}", "if (current == -1) {", "current = mpgviddmx_next_start_code(start, remain);", "if (current<0) {", "u8 b3, b2, b1;", "if (! ctx->frame_started) {", "GF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[MPGVid] no start code in block and no frame started, discarding data\\n\" ));", "break;", "}", "size = remain;", "b3 = start[remain-3];", "b2 = start[remain-2];", "b1 = start[remain-1];", "if (!b1 || !b2 || !b3) {", "copy_last_bytes = GF_TRUE;", "assert(size >= 3);", "size -= 3;", "ctx->bytes_in_header = 3;", "}", "dst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data);", "if (!dst_pck) return GF_OUT_OF_MEM;", "if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);", "memcpy(pck_data, start, (size_t) size);", "gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);", "gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);", "gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);", "if (byte_offset != GF_FILTER_NO_BO) {", "gf_filter_pck_set_byte_offset(dst_pck, byte_offset);", "}", "mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);", "if (copy_last_bytes) {", "memcpy(ctx->hdr_store, start+remain-3, 3);", "}", "break;", "}", "}", "assert(current>=0);", "if ((vosh_start>=0) && current) {", "assert(remain>=current);", "start += current;", "remain -= current;", "current = 0;", "}", "if (!ctx->opid && current) {", "assert(remain>=current);", "start += current;", "remain -= current;", "current = 0;", "}", "if (current>0) {", "dst_pck = gf_filter_pck_new_alloc(ctx->opid, current, &pck_data);", "if (!dst_pck) return GF_OUT_OF_MEM;", "if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);", "gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);", "gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);", "gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_TRUE);", "if (bytes_from_store) {", "if (byte_offset != GF_FILTER_NO_BO) {", "gf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store);", "}", "assert(bytes_from_store>=(u32) current);", "bytes_from_store -= current;", "memcpy(pck_data, ctx->hdr_store, current);", "} else {", "if (byte_offset != GF_FILTER_NO_BO) {", "gf_filter_pck_set_byte_offset(dst_pck, byte_offset);", "}", "memcpy(pck_data, start, current);", "assert(remain>=current);", "start += current;", "remain -= current;", "current = 0;", "}", "gf_filter_pck_set_carousel_version(dst_pck, 1);", "mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);", "}", "if (sc_type_forced) {", "gf_bs_reassign_buffer(ctx->bs, start + hdr_offset, remain - hdr_offset);", "sc_type = forced_sc_type;", "} else {", "gf_bs_reassign_buffer(ctx->bs, start, remain);", "gf_bs_read_int(ctx->bs, 24);", "sc_type = gf_bs_read_int(ctx->bs, 8);", "}", "if (ctx->is_mpg12) {", "switch (sc_type) {", "case M2V_SEQ_START_CODE:", "case M2V_EXT_START_CODE:", "gf_bs_reassign_buffer(ctx->bs, start, remain);", "e = gf_m4v_parse_config(ctx->vparser, &ctx->dsi);", "if (e==GF_EOS) {", "if (vosh_start<0) vosh_start = 0;", "if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {", "ctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - vosh_start);", "ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);", "}", "memcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );", "ctx->hdr_store_size += pck_size - (u32) vosh_start;", "gf_filter_pid_drop_packet(ctx->ipid);", "return GF_OK;", "} else if (e != GF_OK) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MPGVid] Failed to parse VOS header: %s\\n\", gf_error_to_string(e) ));", "} else {", "mpgviddmx_check_pid(filter, ctx, 0, NULL);", "}", "break;", "case M2V_PIC_START_CODE:", "break;", "default:", "break;", "}", "} else {", "u8 PL;", "switch (sc_type) {", "case M4V_VOS_START_CODE:", "ctx->dsi.VideoPL = (u8) gf_bs_read_u8(ctx->bs);", "vosh_start = start - (u8 *)data;", "skip_pck = GF_TRUE;", "assert(remain>=5);", "start += 5;", "remain -= 5;", "break;", "case M4V_VOL_START_CODE:", "gf_bs_reassign_buffer(ctx->bs, start, remain);", "PL = ctx->dsi.VideoPL;", "e = gf_m4v_parse_config(ctx->vparser, &ctx->dsi);", "ctx->dsi.VideoPL = PL;", "if (e==GF_EOS) {", "if (vosh_start<0) vosh_start = 0;", "if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {", "ctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - (u32) vosh_start);", "ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);", "}", "memcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );", "ctx->hdr_store_size += pck_size - (u32) vosh_start;", "gf_filter_pid_drop_packet(ctx->ipid);", "return GF_OK;", "} else if (e != GF_OK) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MPGVid] Failed to parse VOS header: %s\\n\", gf_error_to_string(e) ));", "} else {", "u32 obj_size = (u32) gf_m4v_get_object_start(ctx->vparser);", "if (vosh_start<0) vosh_start = 0;", "vosh_end = start - (u8 *)data + obj_size;", "vosh_end -= vosh_start;", "mpgviddmx_check_pid(filter, ctx,(u32)  vosh_end, data+vosh_start);", "skip_pck = GF_TRUE;", "assert(remain>=(s32) obj_size);", "start += obj_size;", "remain -= obj_size;", "}", "break;", "case M4V_VOP_START_CODE:", "case M4V_GOV_START_CODE:", "break;", "case M4V_VO_START_CODE:", "case M4V_VISOBJ_START_CODE:", "default:", "if (vosh_start>=0) {", "skip_pck = GF_TRUE;", "assert(remain>=4);", "start += 4;", "remain -= 4;", "}", "break;", "}", "}", "if (skip_pck) {", "continue;", "}", "if (!ctx->opid) {", "assert(remain>=4);", "start += 4;", "remain -= 4;", "continue;", "}", "if (!ctx->is_playing) {", "ctx->resume_from = (u32) ((char *)start -  (char *)data);", "return GF_OK;", "}", "ctx->hdr_store_size = 0;", "if (ctx->in_seek) {", "u64 nb_frames_at_seek = (u64) (ctx->start_range * ctx->cur_fps.num);", "if (ctx->cts + ctx->cur_fps.den >= nb_frames_at_seek) {", "ctx->in_seek = GF_FALSE;", "}", "}", "if (remain<5)", "continue;", "gf_m4v_parser_reset(ctx->vparser, sc_type_forced ? forced_sc_type + 1 : 0);", "size = 0;", "e = gf_m4v_parse_frame(ctx->vparser, &ctx->dsi, &ftype, &tinc, &size, &fstart, &is_coded);", "if (bytes_from_store) {", "size += bytes_from_store + hdr_offset;", "}", "if ((e == GF_EOS) && !ctx->input_is_au_end) {", "u8 b3 = start[remain-3];", "u8 b2 = start[remain-2];", "u8 b1 = start[remain-1];", "if (!b1 || !b2 || !b3) {", "copy_last_bytes = GF_TRUE;", "assert(size >= 3);", "size -= 3;", "ctx->bytes_in_header = 3;", "}", "full_frame = GF_FALSE;", "} else {", "full_frame = GF_TRUE;", "}", "if (!is_coded) {", "if (ctx->forced_packed && ctx->b_frames) {", "ctx->is_packed = GF_TRUE;", "assert(remain>=size);", "start += size;", "remain -= (s32) size;", "continue;", "}", "if (ctx->vfr) {", "ctx->is_vfr = GF_TRUE;", "mpgviddmx_update_time(ctx);", "assert(remain>=size);", "start += size;", "remain -= (s32) size;", "continue;", "}", "}", "if (ftype==2) {", "ctx->b_frames++;", "ctx->nb_b++;", "} else {", "mpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_FALSE);", "ctx->last_ref_cts = ctx->cts;", "if (ctx->max_b < ctx->b_frames) ctx->max_b = ctx->b_frames;", "ctx->b_frames = 0;", "if (ftype)", "ctx->nb_p++;", "else", "ctx->nb_i++;", "}", "ctx->nb_frames++;", "dst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data);", "if (!dst_pck) return GF_OUT_OF_MEM;", "if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);", "if (bytes_from_store) {", "memcpy(pck_data, ctx->hdr_store+current, bytes_from_store);", "assert(size >= bytes_from_store);", "size -= bytes_from_store;", "if (byte_offset != GF_FILTER_NO_BO) {", "gf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store);", "}", "memcpy(pck_data + bytes_from_store, start, (size_t) size);", "} else {", "memcpy(pck_data, start, (size_t) size);", "if (byte_offset != GF_FILTER_NO_BO) {", "gf_filter_pck_set_byte_offset(dst_pck, byte_offset + start - (u8 *) data);", "}", "}", "assert(pck_data[0] == 0);", "assert(pck_data[1] == 0);", "assert(pck_data[2] == 0x01);", "gf_filter_pck_set_framing(dst_pck, GF_TRUE, (full_frame || ctx->input_is_au_end) ? GF_TRUE : GF_FALSE);", "gf_filter_pck_set_cts(dst_pck, ctx->cts);", "gf_filter_pck_set_dts(dst_pck, ctx->dts);", "if (ctx->input_is_au_start) {", "ctx->input_is_au_start = GF_FALSE;", "} else {", "gf_filter_pck_set_carousel_version(dst_pck, 1);", "}", "gf_filter_pck_set_sap(dst_pck, ftype ? GF_FILTER_SAP_NONE : GF_FILTER_SAP_1);", "gf_filter_pck_set_duration(dst_pck, ctx->cur_fps.den);", "if (ctx->in_seek) gf_filter_pck_set_seek_flag(dst_pck, GF_TRUE);", "ctx->frame_started = GF_TRUE;", "mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);", "mpgviddmx_update_time(ctx);", "if (!full_frame) {", "if (copy_last_bytes) {", "memcpy(ctx->hdr_store, start+remain-3, 3);", "}", "break;", "}", "assert(remain>=size);", "start += size;", "remain -= (s32) size;", "}", "gf_filter_pid_drop_packet(ctx->ipid);", "return GF_OK;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void isor_reader_get_sample(ISOMChannel *ch)", "{", "GF_Err e;", "u32 sample_desc_index;", "if (ch->sample) return;", "if (ch->next_track) {", "ch->track = ch->next_track;", "ch->next_track = 0;", "}", "if (ch->to_init) {", "init_reader(ch);", "sample_desc_index = ch->last_sample_desc_index;", "} else if (ch->speed < 0) {", "if (ch->last_state == GF_EOS) {", "ch->sample = NULL;", "return;", "}", "if (ch->static_sample->IsRAP) {", "ch->last_rap_sample_time = ch->sample_time;", "}", "e = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + 1, &sample_desc_index, GF_ISOM_SEARCH_FORWARD, &ch->static_sample, &ch->sample_num, NULL);", "if ((e==GF_EOS) || (ch->static_sample->IsRAP)) {", "if (!ch->last_rap_sample_time) {", "e = GF_EOS;", "} else {", "e = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->last_rap_sample_time - 1, &sample_desc_index, GF_ISOM_SEARCH_SYNC_BACKWARD, &ch->static_sample, &ch->sample_num, NULL);", "}", "}", "if (e) {", "if ((e==GF_EOS) && !ch->owner->frag_type) {", "ch->last_state = GF_EOS;", "}", "ch->sample = NULL;", "return;", "}", "ch->sample = ch->static_sample;", "if (ch->sample->DTS == ch->sample_time) {", "if (!ch->owner->frag_type) {", "ch->last_state = GF_EOS;", "}", "}", "if (ch->sample) {", "ch->sample_time = ch->sample->DTS;", "}", "} else if (ch->has_edit_list) {", "u32 prev_sample = ch->sample_num;", "e = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + 1, &sample_desc_index, GF_ISOM_SEARCH_FORWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);", "if (e == GF_OK) {", "ch->sample = ch->static_sample;", "if (ch->edit_sync_frame) {", "ch->edit_sync_frame++;", "if (ch->edit_sync_frame < ch->sample_num) {", "ch->sample = gf_isom_get_sample_ex(ch->owner->mov, ch->track, ch->edit_sync_frame, &sample_desc_index, ch->static_sample, &ch->sample_data_offset);", "ch->sample->DTS = ch->sample_time;", "ch->sample->CTS_Offset = 0;", "} else {", "ch->edit_sync_frame = 0;", "if (ch->sample) ch->sample_time = ch->sample->DTS;", "}", "} else {", "if (prev_sample == ch->sample_num) {", "if (ch->owner->frag_type && (ch->sample_num==gf_isom_get_sample_count(ch->owner->mov, ch->track))) {", "ch->sample = NULL;", "} else {", "u32 sample_num = ch->sample_num ? ch->sample_num : 1;", "if (sample_num >= gf_isom_get_sample_count(ch->owner->mov, ch->track) ) {", "} else {", "u32 time_diff = gf_isom_get_sample_duration(ch->owner->mov, ch->track, sample_num);", "e = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + time_diff, &sample_desc_index, GF_ISOM_SEARCH_FORWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);", "if (e==GF_OK) {", "if (ch->sample_num == prev_sample) {", "ch->sample_time += time_diff;", "ch->sample = NULL;", "return;", "} else {", "ch->sample = ch->static_sample;", "}", "}", "}", "}", "}", "if (ch->sample && !ch->sample->IsRAP && ch->has_rap && (ch->sample_num != prev_sample+1)) {", "GF_ISOSample *found = ch->static_sample;", "u32 samp_num = ch->sample_num;", "ch->sample = NULL;", "e = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + 1, &sample_desc_index, GF_ISOM_SEARCH_SYNC_BACKWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);", "if (e == GF_OK) ch->sample = ch->static_sample;", "if (!ch->sample || !ch->sample->data) {", "ch->sample = ch->static_sample = found;", "ch->sample_time = ch->sample->DTS;", "ch->sample_num = samp_num;", "} else {", "ch->sample = ch->static_sample;", "ch->edit_sync_frame = ch->sample_num;", "ch->sample->DTS = ch->sample_time;", "ch->sample->CTS_Offset = 0;", "}", "} else {", "if (ch->sample) ch->sample_time = ch->sample->DTS;", "}", "}", "}", "} else {", "Bool do_fetch = GF_TRUE;", "ch->sample_num++;", "if (ch->sap_only) {", "Bool is_rap = gf_isom_get_sample_sync(ch->owner->mov, ch->track, ch->sample_num);", "if (!is_rap) {", "GF_ISOSampleRollType roll_type;", "gf_isom_get_sample_rap_roll_info(ch->owner->mov, ch->track, ch->sample_num, &is_rap, &roll_type, NULL);", "if (roll_type) is_rap = GF_TRUE;", "}", "if (!is_rap) {", "do_fetch = GF_FALSE;", "} else if (ch->sap_only==2) {", "ch->sap_only = 0;", "}", "}", "if (do_fetch) {", "if (ch->owner->nodata) {", "ch->sample = gf_isom_get_sample_info_ex(ch->owner->mov, ch->track, ch->sample_num, &sample_desc_index, &ch->sample_data_offset, ch->static_sample);", "} else {", "ch->sample = gf_isom_get_sample_ex(ch->owner->mov, ch->track, ch->sample_num, &sample_desc_index, ch->static_sample, &ch->sample_data_offset);", "}", "if (ch->sample && (ch->sample->IsRAP==RAP_REDUNDANT)) {", "ch->sample = NULL;", "ch->sample_num++;", "isor_reader_get_sample(ch);", "return;", "}", "}", "}", "if (ch->sample && ch->sample->IsRAP && ch->next_track) {", "ch->track = ch->next_track;", "ch->next_track = 0;", "ch->sample = NULL;", "isor_reader_get_sample(ch);", "return;", "}", "if (!ch->sample) {", "u32 sample_count = gf_isom_get_sample_count(ch->owner->mov, ch->track);", "ch->sample_data_offset = 0;", "if (gf_isom_get_missing_bytes(ch->owner->mov, ch->track)) {", "ch->last_state = GF_ISOM_INCOMPLETE_FILE;", "if (ch->owner->mem_load_mode==2)", "ch->owner->force_fetch = GF_TRUE;", "if (!ch->owner->input_loaded) {", "ch->last_state = GF_OK;", "if (!ch->has_edit_list && ch->sample_num)", "ch->sample_num--;", "} else {", "if (ch->sample_num >= gf_isom_get_sample_count(ch->owner->mov, ch->track)) {", "ch->last_state = GF_EOS;", "}", "}", "}", "else if (!ch->sample_num", "|| ((ch->speed >= 0) && (ch->sample_num >= sample_count))", "|| ((ch->speed < 0) && (ch->sample_time == gf_isom_get_current_tfdt(ch->owner->mov, ch->track) ))", ") {", "if (ch->owner->frag_type==1) {", "if (ch->sample_num) ch->sample_num--;", "ch->last_state = GF_EOS;", "} else if (ch->last_state != GF_EOS) {", "GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[IsoMedia] Track #%d end of stream reached\\n\", ch->track));", "ch->last_state = GF_EOS;", "if (ch->sample_num>sample_count) ch->sample_num = sample_count;", "} else {", "if (ch->sample_num>sample_count) ch->sample_num = sample_count;", "}", "} else {", "e = gf_isom_last_error(ch->owner->mov);", "GF_LOG((e==GF_ISOM_INCOMPLETE_FILE) ? GF_LOG_DEBUG : GF_LOG_WARNING, GF_LOG_DASH, (\"[IsoMedia] Track #%d fail to fetch sample %d / %d: %s\\n\", ch->track, ch->sample_num, gf_isom_get_sample_count(ch->owner->mov, ch->track), gf_error_to_string(e) ));", "}", "return;", "}", "if (sample_desc_index != ch->last_sample_desc_index) {", "if (!ch->owner->stsd) {", "if (!ch->last_sample_desc_index && (sample_desc_index==1)) {", "} else {", "ch->needs_pid_reconfig = GF_TRUE;", "}", "}", "ch->last_sample_desc_index = sample_desc_index;", "}", "ch->last_state = GF_OK;", "ch->au_duration = gf_isom_get_sample_duration(ch->owner->mov, ch->track, ch->sample_num);", "ch->sap_3 = GF_FALSE;", "ch->sap_4_type = 0;", "ch->roll = 0;", "ch->set_disc = ch->owner->clock_discontinuity ? 2 : 0;", "ch->owner->clock_discontinuity = 0;", "if (ch->sample) {", "gf_isom_get_sample_rap_roll_info(ch->owner->mov, ch->track, ch->sample_num, &ch->sap_3, &ch->sap_4_type, &ch->roll);", "if ((ch->speed < 0) || (ch->start <= ch->sample->DTS + ch->sample->CTS_Offset)) {", "ch->dts = ch->sample->DTS;", "ch->cts = ch->sample->DTS + ch->sample->CTS_Offset;", "ch->seek_flag = 0;", "} else {", "ch->cts = ch->start;", "ch->seek_flag = 1;", "ch->dts = ch->start;", "}", "if (ch->end && (ch->end < ch->sample->DTS + ch->sample->CTS_Offset + ch->au_duration)) {", "GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[IsoMedia] End of Channel \"LLD\" (CTS \"LLD\")\\n\", ch->end, ch->sample->DTS + ch->sample->CTS_Offset));", "ch->sample = NULL;", "ch->last_state = GF_EOS;", "ch->playing = 2;", "return;", "}", "}", "if (ch->owner->last_sender_ntp && ch->cts==ch->owner->cts_for_last_sender_ntp) {", "ch->sender_ntp = ch->owner->last_sender_ntp;", "ch->ntp_at_server_ntp = ch->owner->ntp_at_last_sender_ntp;", "} else if (ch->owner->last_sender_ntp && ch->dts==ch->owner->cts_for_last_sender_ntp) {", "ch->sender_ntp = ch->owner->last_sender_ntp;", "ch->ntp_at_server_ntp = ch->owner->ntp_at_last_sender_ntp;", "} else {", "ch->sender_ntp = ch->ntp_at_server_ntp = 0;", "}", "if (!ch->sample_num) return;", "gf_isom_get_sample_flags(ch->owner->mov, ch->track, ch->sample_num, &ch->isLeading, &ch->dependsOn, &ch->dependedOn, &ch->redundant);", "if (ch->is_encrypted) {", "if (gf_isom_is_cenc_media(ch->owner->mov, ch->track, ch->last_sample_desc_index)) {", "isor_update_cenc_info(ch, GF_FALSE);", "} else if (gf_isom_is_media_encrypted(ch->owner->mov, ch->track, ch->last_sample_desc_index)) {", "ch->pck_encrypted = GF_TRUE;", "} else {", "ch->pck_encrypted = GF_FALSE;", "}", "}", "if (ch->sample && ch->sample->nb_pack)", "ch->sample_num += ch->sample->nb_pack-1;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["handle_add_command(GraphicsManager *self, const GraphicsCommand *g, const uint8_t *payload, bool *is_dirty, uint32_t iid) {", "#define ABRT(code, ...) { set_add_response(#code, __VA_ARGS__); self->loading_image = 0; if (img) img->data_loaded = false; return NULL; }", "#define MAX_DATA_SZ (4u * 100000000u)", "has_add_respose = false;", "bool existing, init_img = true;", "Image *img = NULL;", "unsigned char tt = g->transmission_type ? g->transmission_type : 'd';", "enum FORMATS { RGB=24, RGBA=32, PNG=100 };", "uint32_t fmt = g->format ? g->format : RGBA;", "if (tt == 'd' && self->loading_image) init_img = false;", "if (init_img) {", "self->last_init_graphics_command = *g;", "self->last_init_graphics_command.id = iid;", "self->loading_image = 0;", "if (g->data_width > 10000 || g->data_height > 10000) ABRT(EINVAL, \"Image too large\");", "remove_images(self, add_trim_predicate, 0);", "img = find_or_create_image(self, iid, &existing);", "if (existing) {", "free_load_data(&img->load_data);", "img->data_loaded = false;", "free_refs_data(img);", "*is_dirty = true;", "self->layers_dirty = true;", "} else {", "img->internal_id = internal_id_counter++;", "img->client_id = iid;", "}", "img->atime = monotonic(); img->used_storage = 0;", "img->width = g->data_width; img->height = g->data_height;", "switch(fmt) {", "case PNG:", "if (g->data_sz > MAX_DATA_SZ) ABRT(EINVAL, \"PNG data size too large\");", "img->load_data.is_4byte_aligned = true;", "img->load_data.is_opaque = false;", "img->load_data.data_sz = g->data_sz ? g->data_sz : 1024 * 100;", "break;", "case RGB:", "case RGBA:", "img->load_data.data_sz = (size_t)g->data_width * g->data_height * (fmt / 8);", "if (!img->load_data.data_sz) ABRT(EINVAL, \"Zero width/height not allowed\");", "img->load_data.is_4byte_aligned = fmt == RGBA || (img->width % 4 == 0);", "img->load_data.is_opaque = fmt == RGB;", "break;", "default:", "ABRT(EINVAL, \"Unknown image format: %u\", fmt);", "}", "if (tt == 'd') {", "if (g->more) self->loading_image = img->internal_id;", "img->load_data.buf_capacity = img->load_data.data_sz + (g->compressed ? 1024 : 10);", "img->load_data.buf = malloc(img->load_data.buf_capacity);", "img->load_data.buf_used = 0;", "if (img->load_data.buf == NULL) {", "ABRT(ENOMEM, \"Out of memory\");", "img->load_data.buf_capacity = 0; img->load_data.buf_used = 0;", "}", "}", "} else {", "self->last_init_graphics_command.more = g->more;", "self->last_init_graphics_command.payload_sz = g->payload_sz;", "g = &self->last_init_graphics_command;", "tt = g->transmission_type ? g->transmission_type : 'd';", "fmt = g->format ? g->format : RGBA;", "img = img_by_internal_id(self, self->loading_image);", "if (img == NULL) {", "self->loading_image = 0;", "ABRT(EILSEQ, \"More payload loading refers to non-existent image\");", "}", "}", "int fd;", "static char fname[2056] = {0};", "switch(tt) {", "case 'd':", "if (img->load_data.buf_capacity - img->load_data.buf_used < g->payload_sz) {", "if (img->load_data.buf_used + g->payload_sz > MAX_DATA_SZ || fmt != PNG) ABRT(EFBIG, \"Too much data\");", "img->load_data.buf_capacity = MIN(2 * img->load_data.buf_capacity, MAX_DATA_SZ);", "img->load_data.buf = realloc(img->load_data.buf, img->load_data.buf_capacity);", "if (img->load_data.buf == NULL) {", "ABRT(ENOMEM, \"Out of memory\");", "img->load_data.buf_capacity = 0; img->load_data.buf_used = 0;", "}", "}", "memcpy(img->load_data.buf + img->load_data.buf_used, payload, g->payload_sz);", "img->load_data.buf_used += g->payload_sz;", "if (!g->more) { img->data_loaded = true; self->loading_image = 0; }", "break;", "case 'f':", "case 't':", "case 's':", "if (g->payload_sz > 2048) ABRT(EINVAL, \"Filename too long\");", "snprintf(fname, sizeof(fname)/sizeof(fname[0]), \"%.*s\", (int)g->payload_sz, payload);", "if (tt == 's') fd = shm_open(fname, O_RDONLY, 0);", "else fd = open(fname, O_CLOEXEC | O_RDONLY);", "if (fd == -1) ABRT(EBADF, \"Failed to open file %s for graphics transmission with error: [%d] %s\", fname, errno, strerror(errno));", "img->data_loaded = mmap_img_file(self, img, fd, g->data_sz, g->data_offset);", "safe_close(fd, __FILE__, __LINE__);", "if (tt == 't') {", "if (global_state.boss) { call_boss(safe_delete_temp_file, \"s\", fname); }", "else unlink(fname);", "}", "else if (tt == 's') shm_unlink(fname);", "break;", "default:", "ABRT(EINVAL, \"Unknown transmission type: %c\", g->transmission_type);", "}", "if (!img->data_loaded) return NULL;", "self->loading_image = 0;", "bool needs_processing = g->compressed || fmt == PNG;", "if (needs_processing) {", "uint8_t *buf; size_t bufsz;", "#define IB { if (img->load_data.buf) { buf = img->load_data.buf; bufsz = img->load_data.buf_used; } else { buf = img->load_data.mapped_file; bufsz = img->load_data.mapped_file_sz; } }", "switch(g->compressed) {", "case 'z':", "IB;", "if (!inflate_zlib(self, img, buf, bufsz)) {", "img->data_loaded = false; return NULL;", "}", "break;", "case 0:", "break;", "default:", "ABRT(EINVAL, \"Unknown image compression: %c\", g->compressed);", "}", "switch(fmt) {", "case PNG:", "IB;", "if (!inflate_png(self, img, buf, bufsz)) {", "img->data_loaded = false; return NULL;", "}", "break;", "default: break;", "}", "#undef IB", "img->load_data.data = img->load_data.buf;", "if (img->load_data.buf_used < img->load_data.data_sz) {", "ABRT(ENODATA, \"Insufficient image data: %zu < %zu\", img->load_data.buf_used, img->load_data.data_sz);", "}", "if (img->load_data.mapped_file) {", "munmap(img->load_data.mapped_file, img->load_data.mapped_file_sz);", "img->load_data.mapped_file = NULL; img->load_data.mapped_file_sz = 0;", "}", "} else {", "if (tt == 'd') {", "if (img->load_data.buf_used < img->load_data.data_sz) {", "ABRT(ENODATA, \"Insufficient image data: %zu < %zu\",  img->load_data.buf_used, img->load_data.data_sz);", "} else img->load_data.data = img->load_data.buf;", "} else {", "if (img->load_data.mapped_file_sz < img->load_data.data_sz) {", "ABRT(ENODATA, \"Insufficient image data: %zu < %zu\",  img->load_data.mapped_file_sz, img->load_data.data_sz);", "} else img->load_data.data = img->load_data.mapped_file;", "}", "}", "size_t required_sz = (size_t)(img->load_data.is_opaque ? 3 : 4) * img->width * img->height;", "if (img->load_data.data_sz != required_sz) ABRT(EINVAL, \"Image dimensions: %ux%u do not match data size: %zu, expected size: %zu\", img->width, img->height, img->load_data.data_sz, required_sz);", "if (LIKELY(img->data_loaded && send_to_gpu)) {", "send_image_to_gpu(&img->texture_id, img->load_data.data, img->width, img->height, img->load_data.is_opaque, img->load_data.is_4byte_aligned, false, REPEAT_CLAMP);", "free_load_data(&img->load_data);", "self->used_storage += required_sz;", "img->used_storage = required_sz;", "}", "return img;", "#undef MAX_DATA_SZ", "#undef ABRT", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int v4l2_loopback_add(struct v4l2_loopback_config *conf, int *ret_nr)", "{", "struct v4l2_loopback_device *dev;", "struct v4l2_ctrl_handler *hdl;", "struct v4l2loopback_private *vdev_priv = NULL;", "int err = -ENOMEM;", "int _max_width = DEFAULT_FROM_CONF(", "max_width, < V4L2LOOPBACK_SIZE_MIN_WIDTH, max_width);", "int _max_height = DEFAULT_FROM_CONF(", "max_height, < V4L2LOOPBACK_SIZE_MIN_HEIGHT, max_height);", "bool _announce_all_caps = (conf && conf->announce_all_caps >= 0) ?", "(conf->announce_all_caps) :", "V4L2LOOPBACK_DEFAULT_EXCLUSIVECAPS;", "int _max_buffers = DEFAULT_FROM_CONF(max_buffers, <= 0, max_buffers);", "int _max_openers = DEFAULT_FROM_CONF(max_openers, <= 0, max_openers);", "int nr = -1;", "_announce_all_caps = (!!_announce_all_caps);", "if (conf) {", "if (conf->capture_nr >= 0 &&", "conf->output_nr == conf->capture_nr) {", "nr = conf->capture_nr;", "} else if (conf->capture_nr < 0 && conf->output_nr < 0) {", "nr = -1;", "} else if (conf->capture_nr < 0) {", "nr = conf->output_nr;", "} else if (conf->output_nr < 0) {", "nr = conf->capture_nr;", "} else {", "printk(KERN_ERR", "\"split OUTPUT and CAPTURE devices not yet supported.\");", "printk(KERN_INFO", "\"both devices must have the same number (%d != %d).\",", "conf->output_nr, conf->capture_nr);", "return -EINVAL;", "}", "}", "if (idr_find(&v4l2loopback_index_idr, nr))", "return -EEXIST;", "dprintk(\"creating v4l2loopback-device #%d\\n\", nr);", "dev = kzalloc(sizeof(*dev), GFP_KERNEL);", "if (!dev)", "return -ENOMEM;", "if (nr >= 0) {", "err = idr_alloc(&v4l2loopback_index_idr, dev, nr, nr + 1,", "GFP_KERNEL);", "if (err == -ENOSPC)", "err = -EEXIST;", "} else {", "err = idr_alloc(&v4l2loopback_index_idr, dev, 0, 0, GFP_KERNEL);", "}", "if (err < 0)", "goto out_free_dev;", "nr = err;", "err = -ENOMEM;", "if (conf && conf->card_label && *(conf->card_label)) {", "snprintf(dev->card_label, sizeof(dev->card_label), \"%s\",", "conf->card_label);", "} else {", "snprintf(dev->card_label, sizeof(dev->card_label),", "\"Dummy video device (0x%04X)\", nr);", "}", "snprintf(dev->v4l2_dev.name, sizeof(dev->v4l2_dev.name),", "\"v4l2loopback-%03d\", nr);", "err = v4l2_device_register(NULL, &dev->v4l2_dev);", "if (err)", "goto out_free_idr;", "MARK();", "dev->vdev = video_device_alloc();", "if (dev->vdev == NULL) {", "err = -ENOMEM;", "goto out_unregister;", "}", "vdev_priv = kzalloc(sizeof(struct v4l2loopback_private), GFP_KERNEL);", "if (vdev_priv == NULL) {", "err = -ENOMEM;", "goto out_unregister;", "}", "video_set_drvdata(dev->vdev, vdev_priv);", "if (video_get_drvdata(dev->vdev) == NULL) {", "err = -ENOMEM;", "goto out_unregister;", "}", "MARK();", "snprintf(dev->vdev->name, sizeof(dev->vdev->name), dev->card_label);", "vdev_priv->device_nr = nr;", "init_vdev(dev->vdev, nr);", "dev->vdev->v4l2_dev = &dev->v4l2_dev;", "init_capture_param(&dev->capture_param);", "err = set_timeperframe(dev, &dev->capture_param.timeperframe);", "if (err)", "goto out_unregister;", "dev->keep_format = 0;", "dev->sustain_framerate = 0;", "dev->announce_all_caps = _announce_all_caps;", "dev->max_width = _max_width;", "dev->max_height = _max_height;", "dev->max_openers = _max_openers;", "dev->buffers_number = dev->used_buffers = _max_buffers;", "dev->write_position = 0;", "MARK();", "spin_lock_init(&dev->lock);", "INIT_LIST_HEAD(&dev->outbufs_list);", "if (list_empty(&dev->outbufs_list)) {", "int i;", "for (i = 0; i < dev->used_buffers; ++i)", "list_add_tail(&dev->buffers[i].list_head,", "&dev->outbufs_list);", "}", "memset(dev->bufpos2index, 0, sizeof(dev->bufpos2index));", "atomic_set(&dev->open_count, 0);", "dev->ready_for_capture = 0;", "dev->ready_for_output = 1;", "dev->buffer_size = 0;", "dev->image = NULL;", "dev->imagesize = 0;", "#ifdef HAVE_TIMER_SETUP", "timer_setup(&dev->sustain_timer, sustain_timer_clb, 0);", "timer_setup(&dev->timeout_timer, timeout_timer_clb, 0);", "#else", "setup_timer(&dev->sustain_timer, sustain_timer_clb, nr);", "setup_timer(&dev->timeout_timer, timeout_timer_clb, nr);", "#endif", "dev->reread_count = 0;", "dev->timeout_jiffies = 0;", "dev->timeout_image = NULL;", "dev->timeout_happened = 0;", "hdl = &dev->ctrl_handler;", "err = v4l2_ctrl_handler_init(hdl, 4);", "if (err)", "goto out_unregister;", "v4l2_ctrl_new_custom(hdl, &v4l2loopback_ctrl_keepformat, NULL);", "v4l2_ctrl_new_custom(hdl, &v4l2loopback_ctrl_sustainframerate, NULL);", "v4l2_ctrl_new_custom(hdl, &v4l2loopback_ctrl_timeout, NULL);", "v4l2_ctrl_new_custom(hdl, &v4l2loopback_ctrl_timeoutimageio, NULL);", "if (hdl->error) {", "err = hdl->error;", "goto out_free_handler;", "}", "dev->v4l2_dev.ctrl_handler = hdl;", "err = v4l2_ctrl_handler_setup(hdl);", "if (err)", "goto out_free_handler;", "dev->pix_format.width = 0;", "dev->pix_format.height = 0;", "dev->pix_format.pixelformat = formats[0].fourcc;", "dev->pix_format.colorspace =", "V4L2_COLORSPACE_SRGB;", "dev->pix_format.field = V4L2_FIELD_NONE;", "dev->buffer_size = PAGE_ALIGN(dev->pix_format.sizeimage);", "dprintk(\"buffer_size = %ld (=%d)\\n\", dev->buffer_size,", "dev->pix_format.sizeimage);", "if (dev->buffer_size && ((err = allocate_buffers(dev)) < 0))", "goto out_free_handler;", "init_waitqueue_head(&dev->read_event);", "if (video_register_device(dev->vdev, VFL_TYPE_VIDEO, nr) < 0) {", "printk(KERN_ERR", "\"v4l2loopback: failed video_register_device()\\n\");", "err = -EFAULT;", "goto out_free_device;", "}", "v4l2loopback_create_sysfs(dev->vdev);", "MARK();", "if (ret_nr)", "*ret_nr = dev->vdev->num;", "return 0;", "out_free_device:", "video_device_release(dev->vdev);", "out_free_handler:", "v4l2_ctrl_handler_free(&dev->ctrl_handler);", "out_unregister:", "video_set_drvdata(dev->vdev, NULL);", "if (vdev_priv != NULL)", "kfree(vdev_priv);", "v4l2_device_unregister(&dev->v4l2_dev);", "out_free_idr:", "idr_remove(&v4l2loopback_index_idr, nr);", "out_free_dev:", "kfree(dev);", "return err;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["FUNC_DECODER(dissector_postgresql)", "{", "DECLARE_DISP_PTR(ptr);", "struct ec_session *s = NULL;", "void *ident = NULL;", "char tmp[MAX_ASCII_ADDR_LEN];", "struct postgresql_status *conn_status;", "(void) DECODE_DATA;", "(void) DECODE_DATALEN;", "(void) DECODED_LEN;", "if (FROM_CLIENT(\"postgresql\", PACKET)) {", "if (PACKET->DATA.len < 4)", "return NULL;", "dissect_create_ident(&ident, PACKET, DISSECT_CODE(dissector_postgresql));", "if (session_get(&s, ident, DISSECT_IDENT_LEN) == -ENOTFOUND) {", "unsigned char *u = memmem(ptr, PACKET->DATA.len, \"user\", 4);", "unsigned char *d = memmem(ptr, PACKET->DATA.len, \"database\", 8);", "if (!memcmp(ptr + 4, \"\\x00\\x03\\x00\\x00\", 4) && u && d) {", "dissect_create_session(&s, PACKET, DISSECT_CODE(dissector_postgresql));", "SAFE_CALLOC(s->data, 1, sizeof(struct postgresql_status));", "conn_status = (struct postgresql_status *) s->data;", "conn_status->status = WAIT_AUTH;", "strncpy((char*)conn_status->user, (char*)(u + 5), 65);", "conn_status->user[64] = 0;", "strncpy((char*)conn_status->database, (char*)(d + 9), 65);", "conn_status->database[64] = 0;", "session_put(s);", "}", "} else {", "conn_status = (struct postgresql_status *) s->data;", "if (conn_status->status == WAIT_RESPONSE) {", "if (ptr[0] == 'p' && conn_status->type == MD5) {", "DEBUG_MSG(\"\\tDissector_postgresql RESPONSE type is MD5\");", "if(memcmp(ptr + 1, \"\\x00\\x00\\x00\\x28\", 4)) {", "DEBUG_MSG(\"\\tDissector_postgresql BUG, expected length is 40\");", "return NULL;", "}", "if (PACKET->DATA.len < 40) {", "DEBUG_MSG(\"\\tDissector_postgresql BUG, expected length is 40\");", "return NULL;", "}", "memcpy(conn_status->hash, ptr + 5 + 3, 32);", "conn_status->hash[32] = 0;", "DISSECT_MSG(\"%s:$postgres$%s*%s*%s:%s:%d\\n\", conn_status->user, conn_status->user, conn_status->salt, conn_status->hash, ip_addr_ntoa(&PACKET->L3.dst, tmp), ntohs(PACKET->L4.dst));", "dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));", "}", "else if (ptr[0] == 'p' && conn_status->type == CT) {", "int length;", "DEBUG_MSG(\"\\tDissector_postgresql RESPONSE type is clear-text!\");", "GET_ULONG_BE(length, ptr, 1);", "strncpy((char*)conn_status->password, (char*)(ptr + 5), length - 4);", "conn_status->password[length - 4] = 0;", "DISSECT_MSG(\"PostgreSQL credentials:%s-%d:%s:%s\\n\", ip_addr_ntoa(&PACKET->L3.dst, tmp), ntohs(PACKET->L4.dst), conn_status->user, conn_status->password);", "dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));", "}", "}", "}", "} else {", "if (PACKET->DATA.len < 9)", "return NULL;", "dissect_create_ident(&ident, PACKET, DISSECT_CODE(dissector_postgresql));", "if (session_get(&s, ident, DISSECT_IDENT_LEN) == ESUCCESS) {", "conn_status = (struct postgresql_status *) s->data;", "if (conn_status->status == WAIT_AUTH &&", "ptr[0] == 'R' && !memcmp(ptr + 1, \"\\x00\\x00\\x00\\x0c\", 4)  &&", "!memcmp(ptr + 5, \"\\x00\\x00\\x00\\x05\", 4)) {", "conn_status->status = WAIT_RESPONSE;", "conn_status->type = MD5;", "DEBUG_MSG(\"\\tDissector_postgresql AUTH type is MD5\");", "hex_encode(ptr + 9, 4, conn_status->salt);", "}", "else if (conn_status->status == WAIT_AUTH &&", "ptr[0] == 'R' && !memcmp(ptr + 1, \"\\x00\\x00\\x00\\x08\", 4)  &&", "!memcmp(ptr + 5, \"\\x00\\x00\\x00\\x03\", 4)) {", "conn_status->status = WAIT_RESPONSE;", "conn_status->type = CT;", "DEBUG_MSG(\"\\tDissector_postgresql AUTH type is clear-text!\");", "}", "}", "}", "SAFE_FREE(ident);", "return NULL;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["GF_Err gf_isom_box_parse_ex(GF_Box **outBox, GF_BitStream *bs, u32 parent_type, Bool is_root_box)", "{", "u32 type, uuid_type, hdr_size;", "u64 size, start, payload_start, end;", "char uuid[16];", "GF_Err e;", "GF_Box *newBox;", "Bool skip_logs = gf_bs_get_cookie(bs) ? GF_TRUE : GF_FALSE;", "Bool is_special = GF_TRUE;", "if ((bs == NULL) || (outBox == NULL) ) return GF_BAD_PARAM;", "*outBox = NULL;", "if (gf_bs_available(bs) < 8) {", "return GF_ISOM_INCOMPLETE_FILE;", "}", "start = gf_bs_get_position(bs);", "uuid_type = 0;", "size = (u64) gf_bs_read_u32(bs);", "hdr_size = 4;", "if ((size >= 2) && (size <= 4)) {", "size = 4;", "type = GF_ISOM_BOX_TYPE_VOID;", "} else {", "type = gf_bs_read_u32(bs);", "hdr_size += 4;", "if (type == GF_ISOM_BOX_TYPE_TOTL)", "size = 12;", "if (!size) {", "if (is_root_box) {", "if (!skip_logs) {", "GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Warning Read Box type %s (0x%08X) size 0 reading till the end of file\\n\", gf_4cc_to_str(type), type));", "}", "size = gf_bs_available(bs) + 8;", "} else {", "if (!skip_logs) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read Box type %s (0x%08X) at position \"LLU\" has size 0 but is not at root/file level, skipping\\n\", gf_4cc_to_str(type), type, start));", "}", "return GF_OK;", "}", "}", "}", "memset(uuid, 0, 16);", "if (type == GF_ISOM_BOX_TYPE_UUID ) {", "if (gf_bs_available(bs) < 16) {", "return GF_ISOM_INCOMPLETE_FILE;", "}", "gf_bs_read_data(bs, uuid, 16);", "hdr_size += 16;", "uuid_type = gf_isom_solve_uuid_box(uuid);", "}", "if (size == 1) {", "if (gf_bs_available(bs) < 8) {", "return GF_ISOM_INCOMPLETE_FILE;", "}", "size = gf_bs_read_u64(bs);", "hdr_size += 8;", "}", "GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Read Box type %s size \"LLD\" start \"LLD\"\\n\", gf_4cc_to_str(type), LLD_CAST size, LLD_CAST start));", "if ( size < hdr_size ) {", "GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box size \"LLD\" less than box header size %d\\n\", LLD_CAST size, hdr_size));", "return GF_ISOM_INVALID_FILE;", "}", "if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TREF)) {", "newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFT);", "if (!newBox) return GF_OUT_OF_MEM;", "((GF_TrackReferenceTypeBox*)newBox)->reference_type = type;", "} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_IREF)) {", "newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFI);", "if (!newBox) return GF_OUT_OF_MEM;", "((GF_ItemReferenceTypeBox*)newBox)->reference_type = type;", "} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TRGR)) {", "newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_TRGT);", "if (!newBox) return GF_OUT_OF_MEM;", "((GF_TrackGroupTypeBox*)newBox)->group_type = type;", "} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_GRPL)) {", "newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_GRPT);", "if (!newBox) return GF_OUT_OF_MEM;", "((GF_EntityToGroupTypeBox*)newBox)->grouping_type = type;", "} else {", "is_special = GF_FALSE;", "newBox = gf_isom_box_new_ex(uuid_type ? uuid_type : type, parent_type, skip_logs, is_root_box);", "if (!newBox) return GF_OUT_OF_MEM;", "}", "if (type==GF_ISOM_BOX_TYPE_UUID && !is_special) {", "memcpy(((GF_UUIDBox *)newBox)->uuid, uuid, 16);", "((GF_UUIDBox *)newBox)->internal_4cc = uuid_type;", "}", "if (!newBox->type) newBox->type = type;", "payload_start = gf_bs_get_position(bs);", "retry_unknown_box:", "end = gf_bs_available(bs);", "if (size - hdr_size > end ) {", "newBox->size = size - hdr_size - end;", "*outBox = newBox;", "return GF_ISOM_INCOMPLETE_FILE;", "}", "newBox->size = size - hdr_size;", "if (newBox->size) {", "e = gf_isom_full_box_read(newBox, bs);", "if (!e) e = gf_isom_box_read(newBox, bs);", "newBox->size = size;", "end = gf_bs_get_position(bs);", "} else {", "newBox->size = size;", "e = GF_OK;", "end = gf_bs_get_position(bs);", "}", "if (e && (e != GF_ISOM_INCOMPLETE_FILE)) {", "gf_isom_box_del(newBox);", "*outBox = NULL;", "if (parent_type==GF_ISOM_BOX_TYPE_STSD) {", "newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_UNKNOWN);", "((GF_UnknownBox *)newBox)->original_4cc = type;", "newBox->size = size;", "gf_bs_seek(bs, payload_start);", "goto retry_unknown_box;", "}", "if (!skip_logs) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read Box \\\"%s\\\" (start \"LLU\") failed (%s) - skipping\\n\", gf_4cc_to_str(type), start, gf_error_to_string(e)));", "}", "return e;", "}", "if (end-start > size) {", "if (!skip_logs) {", "GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" size \"LLU\" (start \"LLU\") invalid (read \"LLU\")\\n\", gf_4cc_to_str(type), LLU_CAST size, start, LLU_CAST (end-start) ));", "}", "gf_bs_seek(bs, start+size);", "} else if (end-start < size) {", "u32 to_skip = (u32) (size-(end-start));", "if (!skip_logs) {", "if ((to_skip!=4) || gf_bs_peek_bits(bs, 32, 0)) {", "GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" (start \"LLU\") has %u extra bytes\\n\", gf_4cc_to_str(type), start, to_skip));", "}", "}", "gf_bs_skip_bytes(bs, to_skip);", "}", "*outBox = newBox;", "return e;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void DumpTrackInfo(GF_ISOFile *file, GF_ISOTrackID trackID, Bool full_dump, Bool is_track_num, Bool dump_m4sys)", "{", "char szCodec[RFC6381_CODEC_NAME_SIZE_MAX];", "Double scale, max_rate, rate;", "Bool is_od_track = 0;", "u32 trackNum, i, j, ts, mtype, msub_type, timescale, sr, nb_ch, count, alt_group, nb_groups, nb_edits, cdur, csize, bps, pfmt, codecid;", "u64 time_slice, dur, size;", "s32 cts_shift;", "GF_ESD *esd;", "char szDur[50];", "char *lang;", "if (!is_track_num) {", "trackNum = gf_isom_get_track_by_id(file, trackID);", "} else {", "trackNum = trackID;", "trackID = gf_isom_get_track_id(file, trackNum);", "}", "if (!trackNum) {", "M4_LOG(GF_LOG_ERROR, (\"No track with ID %d found\\n\", trackID));", "return;", "}", "timescale = gf_isom_get_media_timescale(file, trackNum);", "fprintf(stderr, \"# Track %d Info - ID %d - TimeScale %d\\n\", trackNum, trackID, timescale);", "dur = gf_isom_get_media_original_duration(file, trackNum);", "size = gf_isom_get_media_duration(file, trackNum);", "fprintf(stderr, \"Media Duration %s \", format_duration(dur, timescale, szDur));", "if (dur != size)", "fprintf(stderr, \" (recomputed %s)\", format_duration(size, timescale, szDur));", "fprintf(stderr, \"\\n\");", "if (gf_isom_check_data_reference(file, trackNum, 1) != GF_OK) {", "M4_LOG(GF_LOG_WARNING, (\"Track uses external data reference not supported by GPAC!\\n\"));", "}", "nb_edits = gf_isom_get_edits_count(file, trackNum);", "if (nb_edits)", "fprintf(stderr, \"Track has %d edits: track duration is %s\\n\", nb_edits, format_duration(gf_isom_get_track_duration(file, trackNum), gf_isom_get_timescale(file), szDur));", "cts_shift = gf_isom_get_composition_offset_shift(file, trackNum);", "if (cts_shift)", "fprintf(stderr, \"Track composition offset shift (negative CTS offset): %d\\n\", cts_shift);", "if (gf_isom_is_track_in_root_od(file, trackNum) ) fprintf(stderr, \"Track is present in Root OD\\n\");", "if (!gf_isom_is_track_enabled(file, trackNum))  fprintf(stderr, \"Track is disabled\\n\");", "gf_isom_get_media_language(file, trackNum, &lang);", "fprintf(stderr, \"Media Info: Language \\\"%s (%s)\\\" - \", GetLanguage(lang), lang );", "gf_free(lang);", "mtype = gf_isom_get_media_type(file, trackNum);", "fprintf(stderr, \"Type \\\"%s:\", gf_4cc_to_str(mtype));", "msub_type = gf_isom_get_mpeg4_subtype(file, trackNum, 1);", "if (!msub_type) msub_type = gf_isom_get_media_subtype(file, trackNum, 1);", "fprintf(stderr, \"%s\\\" - %d samples\\n\", gf_4cc_to_str(msub_type), gf_isom_get_sample_count(file, trackNum));", "pfmt = gf_pixel_fmt_from_qt_type(msub_type);", "codecid = gf_codec_id_from_isobmf(msub_type);", "count = gf_isom_get_track_kind_count(file, trackNum);", "for (i = 0; i < count; i++) {", "char *kind_scheme, *kind_value;", "gf_isom_get_track_kind(file, trackNum, i, &kind_scheme, &kind_value);", "fprintf(stderr, \"Kind: %s - %s\\n\", kind_scheme ? kind_scheme : \"null\", kind_value ? kind_value : \"null\");", "if (kind_scheme) gf_free(kind_scheme);", "if (kind_value) gf_free(kind_value);", "}", "if (gf_isom_is_track_fragmented(file, trackID) ) {", "u32 defaultDuration, defaultSize, defaultDescriptionIndex, defaultRandomAccess;", "u8 defaultPadding;", "u16 defaultDegradationPriority;", "u32 frag_samples;", "u64 frag_duration;", "gf_isom_get_fragmented_samples_info(file, trackID, &frag_samples, &frag_duration);", "fprintf(stderr, \"Fragmented track: %d samples - Media Duration %s\\n\", frag_samples, format_duration(frag_duration, timescale, szDur));", "gf_isom_get_fragment_defaults(file, trackNum, &defaultDuration, &defaultSize, &defaultDescriptionIndex, &defaultRandomAccess, &defaultPadding, &defaultDegradationPriority);", "fprintf(stderr, \"Fragment sample defaults: duration %d size %d stsd %d sync %d padding %d degradation_priority %d\\n\",", "defaultDuration, defaultSize, defaultDescriptionIndex, defaultRandomAccess,", "(u32) defaultPadding, (u32) defaultDegradationPriority", ");", "}", "if (!gf_isom_is_self_contained(file, trackNum, 1)) {", "const char *url, *urn;", "gf_isom_get_data_reference(file, trackNum, 1, &url, &urn);", "fprintf(stderr, \"Media Data Location: %s\\n\", url ? url : urn);", "}", "if (full_dump) {", "const char *handler_name;", "gf_isom_get_handler_name(file, trackNum, &handler_name);", "fprintf(stderr, \"Handler name: %s\\n\", handler_name);", "}", "print_udta(file, trackNum, GF_FALSE);", "if (gf_isom_is_video_handler_type(mtype) ) {", "s32 tx, ty;", "u32 w, h;", "u16 bit_depth;", "gf_isom_get_visual_info(file, trackNum, 1, &w, &h);", "gf_isom_get_visual_bit_depth(file, trackNum, 1, &bit_depth);", "fprintf(stderr, \"Visual Sample Entry Info: width=%d height=%d (depth=%d bits)\\n\", w, h, (int)bit_depth);", "gf_isom_get_track_layout_info(file, trackNum, &w, &h, &tx, &ty, NULL);", "fprintf(stderr, \"Visual Track layout: x=%d y=%d width=%d height=%d\\n\", tx, ty, w, h);", "}", "gf_isom_get_audio_info(file, trackNum, 1, &sr, &nb_ch, &bps);", "gf_isom_set_nalu_extract_mode(file, trackNum, GF_ISOM_NALU_EXTRACT_INSPECT);", "msub_type = gf_isom_get_media_subtype(file, trackNum, 1);", "if (msub_type==GF_ISOM_SUBTYPE_MPEG4_CRYP)", "gf_isom_get_original_format_type(file, trackNum, 1, &msub_type);", "if ((msub_type==GF_ISOM_SUBTYPE_MPEG4)", "|| (msub_type==GF_ISOM_SUBTYPE_AVC_H264)", "|| (msub_type==GF_ISOM_SUBTYPE_AVC2_H264)", "|| (msub_type==GF_ISOM_SUBTYPE_AVC3_H264)", "|| (msub_type==GF_ISOM_SUBTYPE_AVC4_H264)", "|| (msub_type==GF_ISOM_SUBTYPE_SVC_H264)", "|| (msub_type==GF_ISOM_SUBTYPE_MVC_H264)", "|| (msub_type==GF_ISOM_SUBTYPE_LSR1)", "|| (msub_type==GF_ISOM_SUBTYPE_HVC1)", "|| (msub_type==GF_ISOM_SUBTYPE_HEV1)", "|| (msub_type==GF_ISOM_SUBTYPE_HVC2)", "|| (msub_type==GF_ISOM_SUBTYPE_HEV2)", "|| (msub_type==GF_ISOM_SUBTYPE_LHV1)", "|| (msub_type==GF_ISOM_SUBTYPE_LHE1)", "|| (msub_type==GF_ISOM_SUBTYPE_HVT1)", ")  {", "esd = gf_isom_get_esd(file, trackNum, 1);", "if (!esd || !esd->decoderConfig) {", "M4_LOG(GF_LOG_WARNING, (\"WARNING: Broken MPEG-4 Track\\n\"));", "if (esd) gf_odf_desc_del((GF_Descriptor *)esd);", "} else {", "const char *st = gf_stream_type_name(esd->decoderConfig->streamType);", "if (dump_m4sys) {", "if (st) {", "fprintf(stderr, \"MPEG-4 Config%s%s Stream - ObjectTypeIndication 0x%02x\\n\",", "full_dump ? \"\\n\\t\" : \": \", st, esd->decoderConfig->objectTypeIndication);", "} else {", "fprintf(stderr, \"MPEG-4 Config%sStream Type 0x%02x - ObjectTypeIndication 0x%02x\\n\",", "full_dump ? \"\\n\\t\" : \": \", esd->decoderConfig->streamType, esd->decoderConfig->objectTypeIndication);", "}", "}", "if (esd->decoderConfig->streamType==GF_STREAM_OD)", "is_od_track=1;", "if (esd->decoderConfig->streamType==GF_STREAM_VISUAL) {", "u32 w, h;", "u16 rvc_predef;", "w = h = 0;", "if (esd->decoderConfig->objectTypeIndication==GF_CODECID_MPEG4_PART2) {", "#ifndef GPAC_DISABLE_AV_PARSERS", "if (!esd->decoderConfig->decoderSpecificInfo) {", "#else", "gf_isom_get_visual_info(file, trackNum, 1, &w, &h);", "fprintf(stderr, \"MPEG-4 Visual Size %d x %d\\n\", w, h);", "#endif", "M4_LOG(GF_LOG_WARNING, (\"Non-compliant MPEG-4 Visual track: video_object_layer infos not found in sample description\\n\"));", "#ifndef GPAC_DISABLE_AV_PARSERS", "} else {", "GF_M4VDecSpecInfo dsi;", "gf_m4v_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &dsi);", "if (full_dump) fprintf(stderr, \"\\t\");", "w = dsi.width;", "h = dsi.height;", "fprintf(stderr, \"MPEG-4 Visual Size %d x %d - %s\\n\", w, h, gf_m4v_get_profile_name(dsi.VideoPL));", "if (dsi.par_den && dsi.par_num) {", "u32 tw, th;", "gf_isom_get_track_layout_info(file, trackNum, &tw, &th, NULL, NULL, NULL);", "fprintf(stderr, \"Pixel Aspect Ratio %d:%d - Indicated track size %d x %d\\n\", dsi.par_num, dsi.par_den, tw, th);", "}", "}", "#endif", "} else if (gf_isom_get_avc_svc_type(file, trackNum, 1) != GF_ISOM_AVCTYPE_NONE) {", "GF_AVCConfig *avccfg, *svccfg, *mvccfg;", "gf_isom_get_visual_info(file, trackNum, 1, &w, &h);", "if (full_dump) fprintf(stderr, \"\\t\");", "fprintf(stderr, \"AVC/H264 Video - Visual Size %d x %d\\n\", w, h);", "avccfg = gf_isom_avc_config_get(file, trackNum, 1);", "svccfg = gf_isom_svc_config_get(file, trackNum, 1);", "mvccfg = gf_isom_mvc_config_get(file, trackNum, 1);", "if (!avccfg && !svccfg && !mvccfg) {", "M4_LOG(GF_LOG_ERROR, (\"\\tNon-compliant AVC track: SPS/PPS not found in sample description\\n\"));", "} else if (avccfg) {", "fprintf(stderr, \"\\tAVC Info: %d SPS - %d PPS\", gf_list_count(avccfg->sequenceParameterSets) , gf_list_count(avccfg->pictureParameterSets) );", "fprintf(stderr, \" - Profile %s @ Level %g\\n\", gf_avc_get_profile_name(avccfg->AVCProfileIndication), ((Double)avccfg->AVCLevelIndication)/10.0 );", "fprintf(stderr, \"\\tNAL Unit length bits: %d\\n\", 8*avccfg->nal_unit_size);", "#ifndef GPAC_DISABLE_AV_PARSERS", "for (i=0; i<gf_list_count(avccfg->sequenceParameterSets); i++) {", "s32 par_n, par_d;", "GF_NALUFFParam *slc = gf_list_get(avccfg->sequenceParameterSets, i);", "gf_avc_get_sps_info(slc->data, slc->size, NULL, NULL, NULL, &par_n, &par_d);", "if ((par_n>0) && (par_d>0)) {", "u32 tw, th;", "gf_isom_get_track_layout_info(file, trackNum, &tw, &th, NULL, NULL, NULL);", "fprintf(stderr, \"\\tPixel Aspect Ratio %d:%d - Indicated track size %d x %d\\n\", par_n, par_d, tw, th);", "}", "if (!full_dump) break;", "}", "#endif", "if (avccfg->chroma_bit_depth) {", "fprintf(stderr, \"\\tChroma format %s - Luma bit depth %d - chroma bit depth %d\\n\", gf_avc_hevc_get_chroma_format_name(avccfg->chroma_format), avccfg->luma_bit_depth, avccfg->chroma_bit_depth);", "}", "print_config_hash(avccfg->sequenceParameterSets, \"SPS\");", "print_config_hash(avccfg->pictureParameterSets, \"PPS\");", "gf_odf_avc_cfg_del(avccfg);", "}", "if (svccfg) {", "fprintf(stderr, \"\\n\\tSVC Info: %d SPS - %d PPS - Profile %s @ Level %g\\n\", gf_list_count(svccfg->sequenceParameterSets) , gf_list_count(svccfg->pictureParameterSets), gf_avc_get_profile_name(svccfg->AVCProfileIndication), ((Double)svccfg->AVCLevelIndication)/10.0 );", "fprintf(stderr, \"\\tSVC NAL Unit length bits: %d\\n\", 8*svccfg->nal_unit_size);", "#ifndef GPAC_DISABLE_AV_PARSERS", "for (i=0; i<gf_list_count(svccfg->sequenceParameterSets); i++) {", "GF_NALUFFParam *slc = gf_list_get(svccfg->sequenceParameterSets, i);", "if (slc) {", "s32 par_n, par_d;", "u32 s_w, s_h, sps_id;", "gf_avc_get_sps_info(slc->data, slc->size, &sps_id, &s_w, &s_h, &par_n, &par_d);", "fprintf(stderr, \"\\t\\tSPS ID %d - Visual Size %d x %d\\n\", sps_id, s_w, s_h);", "if ((par_n>0) && (par_d>0)) {", "u32 tw, th;", "gf_isom_get_track_layout_info(file, trackNum, &tw, &th, NULL, NULL, NULL);", "fprintf(stderr, \"\\tPixel Aspect Ratio %d:%d - Indicated track size %d x %d\\n\", par_n, par_d, tw, th);", "}", "}", "}", "#endif", "print_config_hash(svccfg->sequenceParameterSets, \"SPS\");", "print_config_hash(svccfg->pictureParameterSets, \"PPS\");", "print_config_hash(svccfg->sequenceParameterSetExtensions, \"SPSEx\");", "gf_odf_avc_cfg_del(svccfg);", "}", "if (mvccfg) {", "fprintf(stderr, \"\\n\\tMVC Info: %d SPS - %d PPS - Profile %s @ Level %g\\n\", gf_list_count(mvccfg->sequenceParameterSets) , gf_list_count(mvccfg->pictureParameterSets), gf_avc_get_profile_name(mvccfg->AVCProfileIndication), ((Double)mvccfg->AVCLevelIndication)/10.0 );", "fprintf(stderr, \"\\tMVC NAL Unit length bits: %d\\n\", 8*mvccfg->nal_unit_size);", "#ifndef GPAC_DISABLE_AV_PARSERS", "for (i=0; i<gf_list_count(mvccfg->sequenceParameterSets); i++) {", "GF_NALUFFParam *slc = gf_list_get(mvccfg->sequenceParameterSets, i);", "if (slc) {", "u32 s_w, s_h, sps_id;", "s32 par_n, par_d;", "gf_avc_get_sps_info(slc->data, slc->size, &sps_id, &s_w, &s_h, &par_n, &par_d);", "fprintf(stderr, \"\\t\\tSPS ID %d - Visual Size %d x %d\\n\", sps_id, s_w, s_h);", "if ((par_n>0) && (par_d>0)) {", "u32 tw, th;", "gf_isom_get_track_layout_info(file, trackNum, &tw, &th, NULL, NULL, NULL);", "fprintf(stderr, \"\\tPixel Aspect Ratio %d:%d - Indicated track size %d x %d\\n\", par_n, par_d, tw, th);", "}", "}", "}", "#endif", "print_config_hash(mvccfg->sequenceParameterSets, \"SPS\");", "print_config_hash(mvccfg->pictureParameterSets, \"PPS\");", "gf_odf_avc_cfg_del(mvccfg);", "}", "} else if ((esd->decoderConfig->objectTypeIndication==GF_CODECID_HEVC)", "|| (esd->decoderConfig->objectTypeIndication==GF_CODECID_LHVC)", ") {", "GF_HEVCConfig *hevccfg, *lhvccfg;", "GF_OperatingPointsInformation *oinf;", "#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_HEVC)", "HEVCState hevc_state;", "memset(&hevc_state, 0, sizeof(HEVCState));", "hevc_state.sps_active_idx = -1;", "#endif", "gf_isom_get_visual_info(file, trackNum, 1, &w, &h);", "if (full_dump) fprintf(stderr, \"\\t\");", "fprintf(stderr, \"HEVC Video - Visual Size %d x %d\\n\", w, h);", "hevccfg = gf_isom_hevc_config_get(file, trackNum, 1);", "lhvccfg = gf_isom_lhvc_config_get(file, trackNum, 1);", "if (msub_type==GF_ISOM_SUBTYPE_HVT1) {", "const u8 *data;", "u32 tsize;", "u32  is_default, tx,ty,tw,th, id, independent;", "Bool full_frame;", "if (gf_isom_get_tile_info(file, trackNum, 1, &is_default, &id, &independent, &full_frame, &tx, &ty, &tw, &th)) {", "fprintf(stderr, \"\\tHEVC Tile - ID %d independent %d (x,y,w,h)=%d,%d,%d,%d \\n\", id, independent, tx, ty, tw, th);", "} else if (gf_isom_get_sample_group_info(file, trackNum, 1, GF_ISOM_SAMPLE_GROUP_TRIF, &is_default, &data, &tsize)) {", "fprintf(stderr, \"\\tHEVC Tile track containing a tile set\\n\");", "} else {", "fprintf(stderr, \"\\tHEVC Tile track without tiling info\\n\");", "}", "} else if (!hevccfg && !lhvccfg) {", "M4_LOG(GF_LOG_ERROR, (\"\\tNon-compliant HEVC track: No hvcC or shcC found in sample description\\n\"));", "}", "if (gf_isom_get_reference_count(file, trackNum, GF_ISOM_REF_SABT)) {", "fprintf(stderr, \"\\tHEVC Tile base track\\n\");", "}", "if (hevccfg) {", "dump_hevc_track_info(file, trackNum, hevccfg", "#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_HEVC)", ", &hevc_state", "#endif", ");", "gf_odf_hevc_cfg_del(hevccfg);", "fprintf(stderr, \"\\n\");", "}", "if (lhvccfg) {", "dump_hevc_track_info(file, trackNum, lhvccfg", "#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_HEVC)", ", &hevc_state", "#endif", ");", "gf_odf_hevc_cfg_del(lhvccfg);", "}", "if (gf_isom_get_oinf_info(file, trackNum, &oinf)) {", "fprintf(stderr, \"\\n\\tOperating Points Information -\");", "fprintf(stderr, \" scalability_mask %d (\", oinf->scalability_mask);", "switch (oinf->scalability_mask) {", "case 2:", "fprintf(stderr, \"Multiview\");", "break;", "case 4:", "fprintf(stderr, \"Spatial scalability\");", "break;", "case 8:", "fprintf(stderr, \"Auxilary\");", "break;", "default:", "fprintf(stderr, \"unknown\");", "}", "fprintf(stderr, \") num_profile_tier_level %d \", gf_list_count(oinf->profile_tier_levels) );", "fprintf(stderr, \" num_operating_points %d dependency layers %d \\n\", gf_list_count(oinf->operating_points), gf_list_count(oinf->dependency_layers) );", "}", "}", "else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_THEORA) {", "char *szName;", "gf_isom_get_visual_info(file, trackNum, 1, &w, &h);", "if (full_dump) fprintf(stderr, \"\\t\");", "if (!strnicmp((char *) &esd->decoderConfig->decoderSpecificInfo->data[3], \"theora\", 6)) szName = \"Theora\";", "else szName = \"Unknown\";", "fprintf(stderr, \"Ogg/%s video / GPAC Mux  - Visual Size %d x %d\\n\", szName, w, h);", "}", "else {", "u32 codec_id = gf_codecid_from_oti(GF_STREAM_VISUAL, esd->decoderConfig->objectTypeIndication);", "if (codec_id) {", "gf_isom_get_visual_info(file, trackNum, 1, &w, &h);", "fprintf(stderr, \"%s - Visual Size %d x %d\\n\", gf_codecid_name(codec_id), w, h);", "}", "}", "if (!w || !h) {", "gf_isom_get_visual_info(file, trackNum, 1, &w, &h);", "if (full_dump) fprintf(stderr, \"\\t\");", "fprintf(stderr, \"Visual Size %d x %d\\n\", w, h);", "}", "if (gf_isom_get_rvc_config(file, trackNum, 1, &rvc_predef, NULL, NULL, NULL)==GF_OK) {", "fprintf(stderr, \"Has RVC signaled - Predefined configuration %d\\n\", rvc_predef);", "}", "} else if (esd->decoderConfig->streamType==GF_STREAM_AUDIO) {", "#ifndef GPAC_DISABLE_AV_PARSERS", "GF_M4ADecSpecInfo a_cfg;", "GF_Err e;", "u32 oti;", "#endif", "u32 codec_id;", "Bool is_mp2 = GF_FALSE;", "switch (esd->decoderConfig->objectTypeIndication) {", "case GF_CODECID_AAC_MPEG2_MP:", "case GF_CODECID_AAC_MPEG2_LCP:", "case GF_CODECID_AAC_MPEG2_SSRP:", "is_mp2 = GF_TRUE;", "case GF_CODECID_AAC_MPEG4:", "#ifndef GPAC_DISABLE_AV_PARSERS", "if (!esd->decoderConfig->decoderSpecificInfo)", "e = GF_NON_COMPLIANT_BITSTREAM;", "else", "e = gf_m4a_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &a_cfg);", "if (full_dump) fprintf(stderr, \"\\t\");", "if (e) {", "M4_LOG(GF_LOG_ERROR, (\"Corrupted AAC Config\\n\"));", "} else {", "char *signaling = \"implicit\";", "char *heaac = \"\";", "if (!is_mp2 && a_cfg.has_sbr) {", "if (a_cfg.has_ps) heaac = \"(HE-AAC v2) \";", "else heaac = \"(HE-AAC v1) \";", "}", "if (a_cfg.base_object_type==2) {", "if (a_cfg.has_ps || a_cfg.has_sbr)", "signaling = \"backward compatible\";", "} else {", "signaling = \"hierarchical\";", "}", "fprintf(stderr, \"%s (AOT=%d %s) %s- %d Channel(s) - SampleRate %d\", gf_m4a_object_type_name(a_cfg.base_object_type), a_cfg.base_object_type, signaling, heaac, a_cfg.nb_chan, a_cfg.base_sr);", "if (is_mp2) fprintf(stderr, \" (MPEG-2 Signaling)\");", "if (a_cfg.has_sbr) fprintf(stderr, \" - SBR: SampleRate %d Type %s\", a_cfg.sbr_sr, gf_m4a_object_type_name(a_cfg.sbr_object_type));", "if (a_cfg.has_ps) fprintf(stderr, \" - PS\");", "fprintf(stderr, \"\\n\");", "}", "#else", "fprintf(stderr, \"MPEG-2/4 Audio - %d Channels - SampleRate %d\\n\", nb_ch, sr);", "#endif", "break;", "case GF_CODECID_MPEG2_PART3:", "case GF_CODECID_MPEG_AUDIO:", "if (msub_type == GF_ISOM_SUBTYPE_MPEG4_CRYP) {", "fprintf(stderr, \"MPEG-1/2 Audio - %d Channels - SampleRate %d\\n\", nb_ch, sr);", "} else {", "#ifndef GPAC_DISABLE_AV_PARSERS", "GF_ISOSample *samp = gf_isom_get_sample(file, trackNum, 1, &oti);", "if (samp) {", "u32 mhdr = GF_4CC((u8)samp->data[0], (u8)samp->data[1], (u8)samp->data[2], (u8)samp->data[3]);", "if (full_dump) fprintf(stderr, \"\\t\");", "fprintf(stderr, \"%s Audio - %d Channel(s) - SampleRate %d - Layer %d\\n\",", "gf_mp3_version_name(mhdr),", "gf_mp3_num_channels(mhdr),", "gf_mp3_sampling_rate(mhdr),", "gf_mp3_layer(mhdr)", ");", "gf_isom_sample_del(&samp);", "} else {", "M4_LOG(GF_LOG_ERROR, (\"Error fetching sample: %s\\n\", gf_error_to_string(gf_isom_last_error(file)) ));", "}", "#else", "fprintf(stderr, \"MPEG-1/2 Audio - %d Channels - SampleRate %d\\n\", nb_ch, sr);", "#endif", "}", "break;", "case GF_CODECID_EVRC:", "fprintf(stderr, \"EVRC Audio - Sample Rate 8000 - 1 channel\\n\");", "break;", "case GF_CODECID_SMV:", "fprintf(stderr, \"SMV Audio - Sample Rate 8000 - 1 channel\\n\");", "break;", "case GF_CODECID_QCELP:", "fprintf(stderr, \"QCELP Audio - Sample Rate 8000 - 1 channel\\n\");", "break;", "case GF_CODECID_EVRC_PV:", "if (esd->decoderConfig->decoderSpecificInfo && (esd->decoderConfig->decoderSpecificInfo->dataLength==8)", "&& !strnicmp((char *)esd->decoderConfig->decoderSpecificInfo->data, \"pvmm\", 4)) {", "if (full_dump) fprintf(stderr, \"\\t\");", "fprintf(stderr, \"EVRC Audio (PacketVideo Mux) - Sample Rate 8000 - 1 channel\\n\");", "}", "break;", "default:", "codec_id = gf_codecid_from_oti(GF_STREAM_AUDIO, esd->decoderConfig->objectTypeIndication);", "if (codec_id) {", "fprintf(stderr, \"%s - Sample Rate %d - %d channel(s)\\n\", gf_codecid_name(codec_id), sr, nb_ch);", "}", "break;", "}", "}", "else if (esd->decoderConfig->streamType==GF_STREAM_SCENE) {", "if (esd->decoderConfig->objectTypeIndication<=4) {", "GF_BIFSConfig *b_cfg = gf_odf_get_bifs_config(esd->decoderConfig->decoderSpecificInfo, esd->decoderConfig->objectTypeIndication);", "fprintf(stderr, \"BIFS Scene description - %s stream\\n\", b_cfg->elementaryMasks ? \"Animation\" : \"Command\");", "if (full_dump && !b_cfg->elementaryMasks) {", "fprintf(stderr, \"\\tWidth %d Height %d Pixel Metrics %s\\n\", b_cfg->pixelWidth, b_cfg->pixelHeight, b_cfg->pixelMetrics ? \"yes\" : \"no\");", "}", "gf_odf_desc_del((GF_Descriptor *)b_cfg);", "} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_AFX) {", "u8 tag = esd->decoderConfig->decoderSpecificInfo ? esd->decoderConfig->decoderSpecificInfo->data[0] : 0xFF;", "const char *afxtype = gf_stream_type_afx_name(tag);", "fprintf(stderr, \"AFX Stream - type %s (%d)\\n\", afxtype, tag);", "} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_FONT) {", "fprintf(stderr, \"Font Data stream\\n\");", "} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_LASER) {", "GF_LASERConfig l_cfg;", "gf_odf_get_laser_config(esd->decoderConfig->decoderSpecificInfo, &l_cfg);", "fprintf(stderr, \"LASER Stream - %s\\n\", l_cfg.newSceneIndicator ? \"Full Scene\" : \"Scene Segment\");", "} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_TEXT_MPEG4) {", "fprintf(stderr, \"MPEG-4 Streaming Text stream\\n\");", "} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_SYNTHESIZED_TEXTURE) {", "fprintf(stderr, \"Synthetized Texture stream stream\\n\");", "} else {", "M4_LOG(GF_LOG_WARNING, (\"Unknown Systems stream OTI %d\\n\", esd->decoderConfig->objectTypeIndication));", "}", "}", "if (!full_dump) {", "if (dump_m4sys) {", "if (!esd->OCRESID || (esd->OCRESID == esd->ESID))", "fprintf(stderr, \"Self-synchronized\\n\");", "else", "fprintf(stderr, \"Synchronized on stream %d\\n\", esd->OCRESID);", "}", "} else {", "fprintf(stderr, \"\\tDecoding Buffer size %d - Bitrate: avg %d - max %d kbps\\n\", esd->decoderConfig->bufferSizeDB, esd->decoderConfig->avgBitrate/1000, esd->decoderConfig->maxBitrate/1000);", "if (esd->dependsOnESID)", "fprintf(stderr, \"\\tDepends on stream %d for decoding\\n\", esd->dependsOnESID);", "else", "fprintf(stderr, \"\\tNo stream dependencies for decoding\\n\");", "fprintf(stderr, \"\\tStreamPriority %d\\n\", esd->streamPriority);", "if (esd->URLString) fprintf(stderr, \"\\tRemote Data Source %s\\n\", esd->URLString);", "}", "gf_odf_desc_del((GF_Descriptor *) esd);", "}", "} else if (msub_type == GF_ISOM_SUBTYPE_AV01) {", "GF_AV1Config *av1c;", "u32 w, h;", "gf_isom_get_visual_info(file, trackNum, 1, &w, &h);", "fprintf(stderr, \"\\tAOM AV1 stream - Resolution %d x %d\\n\", w, h);", "av1c = gf_isom_av1_config_get(file, trackNum, 1);", "fprintf(stderr, \"\\tversion=%u, profile=%u, level_idx0=%u, tier=%u\\n\", (u32)av1c->version, (u32)av1c->seq_profile, (u32)av1c->seq_level_idx_0, (u32)av1c->seq_tier_0);", "fprintf(stderr, \"\\thigh_bitdepth=%u, twelve_bit=%u, monochrome=%u\\n\", (u32)av1c->high_bitdepth, (u32)av1c->twelve_bit, (u32)av1c->monochrome);", "fprintf(stderr, \"\\tchroma: subsampling_x=%u, subsampling_y=%u, sample_position=%u\\n\", (u32)av1c->chroma_subsampling_x, (u32)av1c->chroma_subsampling_y, (u32)av1c->chroma_sample_position);", "if (av1c->initial_presentation_delay_present)", "fprintf(stderr, \"\\tInitial presentation delay %u\\n\", (u32) av1c->initial_presentation_delay_minus_one+1);", "count = gf_list_count(av1c->obu_array);", "for (i=0; i<count; i++) {", "u8 hash[20];", "GF_AV1_OBUArrayEntry *obu = gf_list_get(av1c->obu_array, i);", "gf_sha1_csum((u8*)obu->obu, (u32)obu->obu_length, hash);", "fprintf(stderr, \"\\tOBU#%d %s hash: \", i+1, gf_av1_get_obu_name(obu->obu_type) );", "for (j=0; j<20; j++) fprintf(stderr, \"%02X\", hash[j]);", "fprintf(stderr, \"\\n\");", "}", "gf_odf_av1_cfg_del(av1c);", "} else if (msub_type == GF_ISOM_SUBTYPE_3GP_H263) {", "u32 w, h;", "gf_isom_get_visual_info(file, trackNum, 1, &w, &h);", "fprintf(stderr, \"\\t3GPP H263 stream - Resolution %d x %d\\n\", w, h);", "} else if (msub_type == GF_ISOM_SUBTYPE_MJP2) {", "u32 w, h;", "gf_isom_get_visual_info(file, trackNum, 1, &w, &h);", "fprintf(stderr, \"\\tMotionJPEG2000 stream - Resolution %d x %d\\n\", w, h);", "} else if ((msub_type == GF_ISOM_SUBTYPE_3GP_AMR) || (msub_type == GF_ISOM_SUBTYPE_3GP_AMR_WB)) {", "fprintf(stderr, \"\\t3GPP AMR%s stream - Sample Rate %d - %d channel(s) %d bps\\n\", (msub_type == GF_ISOM_SUBTYPE_3GP_AMR_WB) ? \" Wide Band\" : \"\", sr, nb_ch, (u32) bps);", "} else if (msub_type == GF_ISOM_SUBTYPE_3GP_EVRC) {", "fprintf(stderr, \"\\t3GPP EVRC stream - Sample Rate %d - %d channel(s) %d bps\\n\", sr, nb_ch, (u32) bps);", "} else if (msub_type == GF_ISOM_SUBTYPE_3GP_QCELP) {", "fprintf(stderr, \"\\t3GPP QCELP stream - Sample Rate %d - %d channel(s) %d bps\\n\", sr, nb_ch, (u32) bps);", "} else if (msub_type == GF_ISOM_SUBTYPE_MP3) {", "fprintf(stderr, \"\\tMPEG 1/2 Audio stream - Sample Rate %d - %d channel(s) %d bps\\n\", sr, nb_ch, (u32) bps);", "} else if ((msub_type == GF_ISOM_SUBTYPE_AC3) || (msub_type == GF_ISOM_SUBTYPE_EC3)) {", "u32 br = 0;", "const char *lfe = \"\";", "Bool is_ec3 = (msub_type == GF_ISOM_SUBTYPE_EC3) ? GF_TRUE : GF_FALSE;", "#ifndef GPAC_DISABLE_AV_PARSERS", "GF_AC3Config *ac3 = gf_isom_ac3_config_get(file, trackNum, 1);", "if (ac3) {", "nb_ch = gf_ac3_get_channels(ac3->streams[0].acmod);", "for (i=0; i<ac3->streams[0].nb_dep_sub; ++i) {", "assert(ac3->streams[0].nb_dep_sub == 1);", "nb_ch += gf_ac3_get_channels(ac3->streams[0].chan_loc);", "}", "if (ac3->streams[0].lfon) lfe = \".1\";", "br = ac3->is_ec3 ? ac3->brcode : gf_ac3_get_bitrate(ac3->brcode);", "is_ec3 = ac3->is_ec3;", "gf_free(ac3);", "}", "#endif", "fprintf(stderr, \"\\t%s stream - Sample Rate %d - %d%s channel(s) - bitrate %d\\n\", is_ec3 ? \"EC-3\" : \"AC-3\", sr, nb_ch, lfe, br);", "} else if (msub_type == GF_ISOM_SUBTYPE_3GP_SMV) {", "fprintf(stderr, \"\\t3GPP SMV stream - Sample Rate %d - %d channel(s) %d bits per samples\\n\", sr, nb_ch, (u32) bps);", "} else if (msub_type == GF_ISOM_SUBTYPE_3GP_DIMS) {", "u32 w, h;", "GF_DIMSDescription dims;", "gf_isom_get_visual_info(file, trackNum, 1, &w, &h);", "gf_isom_get_dims_description(file, trackNum, 1, &dims);", "fprintf(stderr, \"\\t3GPP DIMS stream - size %d x %d - Profile %d - Level %d\\n\", w, h, dims.profile, dims.level);", "fprintf(stderr, \"\\tpathComponents: %d - useFullRequestHost: %s\\n\", dims.pathComponents, dims.fullRequestHost ? \"yes\" : \"no\");", "fprintf(stderr, \"\\tstream type: %s - redundant: %s\\n\", dims.streamType ? \"primary\" : \"secondary\", (dims.containsRedundant==1) ? \"main\" : ((dims.containsRedundant==2) ? \"redundant\" : \"main+redundant\") );", "if (dims.textEncoding[0]) fprintf(stderr, \"\\ttext encoding %s\\n\", dims.textEncoding);", "if (dims.contentEncoding[0]) fprintf(stderr, \"\\tcontent encoding %s\\n\", dims.contentEncoding);", "if (dims.content_script_types) fprintf(stderr, \"\\tscript languages %s\\n\", dims.content_script_types);", "} else if (mtype==GF_ISOM_MEDIA_HINT) {", "u32 refTrack;", "s32 refCount = gf_isom_get_reference_count(file, trackNum, GF_ISOM_REF_HINT);", "if (refCount>0) {", "fprintf(stderr, \"Streaming Hint Track for track%s \", (refCount>1) ? \"s\" :\"\");", "for (i=0; i<(u32) refCount; i++) {", "gf_isom_get_reference(file, trackNum, GF_ISOM_REF_HINT, i+1, &refTrack);", "if (i) fprintf(stderr, \" - \");", "fprintf(stderr, \"ID %d\", gf_isom_get_track_id(file, refTrack));", "}", "fprintf(stderr, \"\\n\");", "} else {", "fprintf(stderr, \"Streaming Hint Track (no refs)\\n\");", "}", "#ifndef GPAC_DISABLE_ISOM_HINTING", "refCount = gf_isom_get_payt_count(file, trackNum);", "if (refCount>0) {", "for (i=0; i<(u32) refCount; i++) {", "const char *name = gf_isom_get_payt_info(file, trackNum, i+1, &refTrack);", "fprintf(stderr, \"\\tPayload ID %d: type %s\\n\", refTrack, name);", "}", "}", "#endif", "} else if (mtype==GF_ISOM_MEDIA_FLASH) {", "fprintf(stderr, \"Macromedia Flash Movie\\n\");", "} else if ((mtype==GF_ISOM_MEDIA_TEXT) || (mtype==GF_ISOM_MEDIA_SUBT) || (mtype==GF_ISOM_MEDIA_MPEG_SUBT)) {", "u32 w, h;", "s16 l;", "s32 tx, ty;", "const char *content_encoding = NULL;", "const char *mime = NULL;", "const char *config  = NULL;", "const char *_namespace = NULL;", "const char *schema_loc = NULL;", "const char *auxiliary_mimes = NULL;", "gf_isom_get_track_layout_info(file, trackNum, &w, &h, &tx, &ty, &l);", "if (msub_type == GF_ISOM_SUBTYPE_SBTT) {", "gf_isom_stxt_get_description(file, trackNum, 1, &mime, &content_encoding, &config);", "fprintf(stderr, \"Textual Subtitle Stream \");", "fprintf(stderr, \"- mime %s\", mime);", "if (content_encoding != NULL) {", "fprintf(stderr, \" - encoding %s\", content_encoding);", "}", "if (config != NULL) {", "fprintf(stderr, \" - %d bytes config\", (u32) strlen(config));", "}", "} else if (msub_type == GF_ISOM_SUBTYPE_STXT) {", "gf_isom_stxt_get_description(file, trackNum, 1, &mime, &content_encoding, &config);", "fprintf(stderr, \"Simple Timed Text Stream \");", "fprintf(stderr, \"- mime %s\", mime);", "if (content_encoding != NULL) {", "fprintf(stderr, \" - encoding %s\", content_encoding);", "}", "if (config != NULL) {", "fprintf(stderr, \" - %d bytes config\", (u32) strlen(config));", "}", "} else if (msub_type == GF_ISOM_SUBTYPE_STPP) {", "gf_isom_xml_subtitle_get_description(file, trackNum, 1, &_namespace, &schema_loc, &auxiliary_mimes);", "fprintf(stderr, \"XML Subtitle Stream \");", "fprintf(stderr, \"- namespace %s\", _namespace);", "if (schema_loc != NULL) {", "fprintf(stderr, \" - schema-location %s\", schema_loc);", "}", "if (auxiliary_mimes != NULL) {", "fprintf(stderr, \" - auxiliary-mime-types %s\", auxiliary_mimes);", "}", "} else {", "fprintf(stderr, \"Unknown Text Stream\");", "}", "fprintf(stderr, \"\\n Size %d x %d - Translation X=%d Y=%d - Layer %d\\n\", w, h, tx, ty, l);", "} else if (mtype == GF_ISOM_MEDIA_META) {", "const char *content_encoding = NULL;", "if (msub_type == GF_ISOM_SUBTYPE_METT) {", "const char *mime = NULL;", "const char *config  = NULL;", "gf_isom_stxt_get_description(file, trackNum, 1, &mime, &content_encoding, &config);", "fprintf(stderr, \"Textual Metadata Stream - mime %s\", mime);", "if (content_encoding != NULL) {", "fprintf(stderr, \" - encoding %s\", content_encoding);", "}", "if (config != NULL) {", "fprintf(stderr, \" - %d bytes config\", (u32) strlen(config));", "}", "fprintf(stderr, \"\\n\");", "} else if (msub_type == GF_ISOM_SUBTYPE_METX) {", "const char *_namespace = NULL;", "const char *schema_loc = NULL;", "gf_isom_get_xml_metadata_description(file, trackNum, 1, &_namespace, &schema_loc, &content_encoding);", "fprintf(stderr, \"XML Metadata Stream - namespace %s\", _namespace);", "if (content_encoding != NULL) {", "fprintf(stderr, \" - encoding %s\", content_encoding);", "}", "if (schema_loc != NULL) {", "fprintf(stderr, \" - schema-location %s\", schema_loc);", "}", "fprintf(stderr, \"\\n\");", "} else {", "fprintf(stderr, \"Unknown Metadata Stream\\n\");", "}", "} else if ((msub_type==GF_ISOM_SUBTYPE_VVC1) || (msub_type==GF_ISOM_SUBTYPE_VVI1)) {", "GF_VVCConfig *vvccfg;", "u32 w, h;", "#if !defined(GPAC_DISABLE_AV_PARSERS)", "VVCState *vvc_state;", "GF_SAFEALLOC(vvc_state, VVCState);", "if (vvc_state) vvc_state->sps_active_idx = -1;", "#endif", "gf_isom_get_visual_info(file, trackNum, 1, &w, &h);", "if (full_dump) fprintf(stderr, \"\\t\");", "fprintf(stderr, \"VVC Video - Visual Size %d x %d\\n\", w, h);", "vvccfg = gf_isom_vvc_config_get(file, trackNum, 1);", "if (!vvccfg) {", "M4_LOG(GF_LOG_ERROR, (\"Non-compliant VVC track: No vvcC found in sample description\\n\"));", "} else {", "dump_vvc_track_info(file, trackNum, vvccfg", "#if !defined(GPAC_DISABLE_AV_PARSERS)", ", vvc_state", "#endif", ");", "gf_odf_vvc_cfg_del(vvccfg);", "fprintf(stderr, \"\\n\");", "}", "#if !defined(GPAC_DISABLE_AV_PARSERS)", "if (vvc_state) gf_free(vvc_state);", "#endif", "} else if ((msub_type == GF_ISOM_SUBTYPE_MH3D_MHA1) || (msub_type == GF_ISOM_SUBTYPE_MH3D_MHA2)", "|| (msub_type == GF_ISOM_SUBTYPE_MH3D_MHM1) || (msub_type == GF_ISOM_SUBTYPE_MH3D_MHM2)", ") {", "const u8 *compat_profiles;", "u32 nb_compat_profiles;", "Bool valid = GF_FALSE;", "Bool allow_inband = GF_FALSE;", "if ( (msub_type == GF_ISOM_SUBTYPE_MH3D_MHM1) || (msub_type == GF_ISOM_SUBTYPE_MH3D_MHM2))", "allow_inband = GF_TRUE;", "fprintf(stderr, \"\\tMPEG-H Audio stream - Sample Rate %d\\n\", sr);", "esd = gf_media_map_esd(file, trackNum, 1);", "if (!esd || !esd->decoderConfig || !esd->decoderConfig->decoderSpecificInfo", "|| !esd->decoderConfig->decoderSpecificInfo->data", ") {", "if (allow_inband) {", "GF_ISOSample *samp = gf_isom_get_sample(file, trackNum, 1, NULL);", "if (samp) {", "u64 ch_layout=0;", "s32 PL = gf_mpegh_get_mhas_pl(samp->data, samp->dataLength, &ch_layout);", "if (PL>=0) {", "fprintf(stderr, \"\\tProfileLevelIndication: 0x%02X\", PL);", "if (ch_layout)", "fprintf(stderr, \" - Reference Channel Layout %s\", gf_audio_fmt_get_layout_name(ch_layout) );", "fprintf(stderr, \"\\n\");", "}", "gf_isom_sample_del(&samp);", "}", "valid = GF_TRUE;", "}", "} else if (esd->decoderConfig->decoderSpecificInfo->dataLength>=5) {", "fprintf(stderr, \"\\tProfileLevelIndication: 0x%02X - Reference Channel Layout %s\\n\", esd->decoderConfig->decoderSpecificInfo->data[1]", ", gf_audio_fmt_get_layout_name_from_cicp(esd->decoderConfig->decoderSpecificInfo->data[2])", ");", "valid = GF_TRUE;", "}", "if (!valid) {", "M4_LOG(GF_LOG_ERROR, (\"Invalid MPEG-H audio config\\n\"));", "}", "if (esd) gf_odf_desc_del((GF_Descriptor *)esd);", "compat_profiles = gf_isom_get_mpegh_compatible_profiles(file, trackNum, 1, &nb_compat_profiles);", "for (i=0; i<nb_compat_profiles; i++) {", "if (!i)", "fprintf(stderr, \"\\tCompatible profiles:\");", "fprintf(stderr, \" 0x%02X\", compat_profiles[i]);", "}", "if (i) fprintf(stderr, \"\\n\");", "} else if (msub_type==GF_ISOM_SUBTYPE_MLPA) {", "u32 fmt, prate;", "if (gf_isom_truehd_config_get(file, trackNum, 1, &fmt, &prate) != GF_OK) {", "fprintf(stderr, \"\\tInvalid TrueHD audio config\\n\");", "}", "fprintf(stderr, \"TrueHD Audio stream - Sample Rate %u - channels %u - format %u peak rate %u\\n\", sr, nb_ch, fmt, prate);", "} else if (codecid) {", "if (gf_isom_is_video_handler_type(mtype) ) {", "u32 w, h;", "gf_isom_get_visual_info(file, trackNum, 1, &w, &h);", "fprintf(stderr, \"%s - Resolution %d x %d\\n\", gf_codecid_name(codecid), w, h);", "} else if (mtype==GF_ISOM_MEDIA_AUDIO) {", "gf_isom_get_audio_info(file, trackNum, 1, &sr, &nb_ch, NULL);", "fprintf(stderr, \"%s - Sample Rate %d - %d channel(s)\\n\", gf_codecid_name(codecid), sr, nb_ch);", "} else {", "fprintf(stderr, \"%s\\n\", gf_codecid_name(codecid) );", "}", "} else if (pfmt) {", "u32 w, h;", "gf_isom_get_visual_info(file, trackNum, 1, &w, &h);", "fprintf(stderr, \"Raw video %s - Resolution %d x %d\\n\", gf_pixel_fmt_name(pfmt), w, h);", "} else if (msub_type==GF_QT_SUBTYPE_TMCD) {", "u32 stsd_idx;", "GF_ISOSample *sample = gf_isom_get_sample(file, trackNum, 1, &stsd_idx);", "fprintf(stderr, \"Time Code stream\\n\");", "if (sample) {", "char szTimecode[100];", "u32 tmcd_flags, tmcd_num, tmcd_den, tmcd_fpt;", "gf_isom_get_tmcd_config(file, trackNum, stsd_idx, &tmcd_flags, &tmcd_num, &tmcd_den, &tmcd_fpt);", "gf_inspect_format_timecode(sample->data, sample->dataLength, tmcd_flags, tmcd_num, tmcd_den, tmcd_fpt, szTimecode);", "gf_isom_sample_del(&sample);", "fprintf(stderr, \"\\tFirst timecode: %s\\n\", szTimecode);", "}", "} else {", "GF_GenericSampleDescription *udesc;", "udesc = gf_isom_get_generic_sample_description(file, trackNum, 1);", "if (udesc) {", "if (gf_isom_is_video_handler_type(mtype) ) {", "fprintf(stderr, \"%s - Compressor \\\"%s\\\" - Resolution %d x %d\\n\",", "( (mtype == GF_ISOM_MEDIA_VISUAL ? \"Visual\" : \"Auxiliary Video\") ),", "udesc->compressor_name, udesc->width, udesc->height);", "} else if (mtype==GF_ISOM_MEDIA_AUDIO) {", "fprintf(stderr, \"Audio - Sample Rate %d - %d channel(s)\\n\", udesc->samplerate, udesc->nb_channels);", "} else {", "fprintf(stderr, \"Unknown media type\\n\");", "}", "if (udesc->vendor_code)", "fprintf(stderr, \"\\tVendor code \\\"%s\\\" - Version %d - revision %d\\n\", gf_4cc_to_str(udesc->vendor_code), udesc->version, udesc->revision);", "if (udesc->extension_buf) {", "fprintf(stderr, \"\\tCodec configuration data size: %d bytes\\n\", udesc->extension_buf_size);", "gf_free(udesc->extension_buf);", "}", "gf_free(udesc);", "} else {", "fprintf(stderr, \"Unknown track type\\n\");", "}", "}", "if (gf_isom_is_track_encrypted(file, trackNum)) {", "const char *scheme_URI, *KMS_URI;", "u32 scheme_type, version;", "u32 IV_size;", "Bool use_sel_enc;", "if (gf_isom_is_ismacryp_media(file, trackNum, 1)) {", "gf_isom_get_ismacryp_info(file, trackNum, 1, NULL, &scheme_type, &version, &scheme_URI, &KMS_URI, &use_sel_enc, &IV_size, NULL);", "fprintf(stderr, \"\\n\\tProtected by ISMA E&A scheme %s (version %d)\\n\", gf_4cc_to_str(scheme_type), version);", "if (scheme_URI) fprintf(stderr, \"scheme location: %s\\n\", scheme_URI);", "if (KMS_URI) {", "if (!strnicmp(KMS_URI, \"(key)\", 5)) fprintf(stderr, \"\\tKMS location: key in file\\n\");", "else fprintf(stderr, \"\\tKMS location: %s\\n\", KMS_URI);", "}", "fprintf(stderr, \"\\tSelective Encryption: %s\\n\", use_sel_enc ? \"Yes\" : \"No\");", "if (IV_size) fprintf(stderr, \"\\tInitialization Vector size: %d bits\\n\", IV_size*8);", "} else if (gf_isom_is_omadrm_media(file, trackNum, 1)) {", "const char *textHdrs;", "u32 enc_type, hdr_len;", "u64 orig_len;", "gf_isom_get_omadrm_info(file, trackNum, 1, NULL, &scheme_type, &version, &scheme_URI, &KMS_URI, &textHdrs, &hdr_len, &orig_len, &enc_type, &use_sel_enc, &IV_size, NULL);", "fprintf(stderr, \"\\n\\tProtected by OMA DRM scheme %s (version %d)\\n\", gf_4cc_to_str(scheme_type), version);", "fprintf(stderr, \"\\tRights Issuer: %s\\n\", KMS_URI);", "fprintf(stderr, \"\\tContent ID: %s\\n\", scheme_URI);", "if (textHdrs) {", "u32 offset;", "const char *start = textHdrs;", "fprintf(stderr, \"\\tOMA Textual Headers:\\n\");", "i=0;", "offset=0;", "while (i<hdr_len) {", "if (start[i]==0) {", "fprintf(stderr, \"\\t\\t%s\\n\", start+offset);", "offset=i+1;", "}", "i++;", "}", "fprintf(stderr, \"\\\\tt%s\\n\", start+offset);", "}", "if (orig_len) fprintf(stderr, \"\\tOriginal media size \"LLD\"\\n\", orig_len);", "fprintf(stderr, \"\\tEncryption algorithm %s\\n\", (enc_type==1) ? \"AEA 128 CBC\" : (enc_type ? \"AEA 128 CTR\" : \"None\"));", "fprintf(stderr, \"\\tSelective Encryption: %s\\n\", use_sel_enc ? \"Yes\" : \"No\");", "if (IV_size) fprintf(stderr, \"\\tInitialization Vector size: %d bits\\n\", IV_size*8);", "} else if(gf_isom_is_cenc_media(file, trackNum, 1)) {", "const u8 *def_key;", "u32 def_key_size;", "Bool IsEncrypted;", "u8 crypt_byte_block, skip_byte_block;", "IV_size = 0;", "gf_isom_get_cenc_info(file, trackNum, 1, NULL, &scheme_type, &version);", "gf_isom_cenc_get_default_info(file, trackNum, 1, NULL, &IsEncrypted, &crypt_byte_block, &skip_byte_block, &def_key, &def_key_size);", "fprintf(stderr, \"\\n\\tProtected by CENC scheme %s version 0x%08X\", gf_4cc_to_str(scheme_type), version);", "if (crypt_byte_block && skip_byte_block)", "fprintf(stderr, \" - Pattern %d:%d\", (u32) skip_byte_block, (u32) crypt_byte_block);", "if (def_key && def_key[0])", "fprintf(stderr, \" - MultiKey\");", "fprintf(stderr, \"\\n\");", "dump_key_info(def_key, def_key_size, IsEncrypted);", "} else if(gf_isom_is_adobe_protection_media(file, trackNum, 1)) {", "gf_isom_get_adobe_protection_info(file, trackNum, 1, NULL, &scheme_type, &version, NULL);", "fprintf(stderr, \"\\nProtected by Adobe scheme %s (version %d)\\n\", gf_4cc_to_str(scheme_type), version);", "} else {", "fprintf(stderr, \"\\nProtected by unknown scheme %s\\n\", gf_4cc_to_str(gf_isom_is_media_encrypted(file, trackNum, 0) ));", "}", "fprintf(stderr, \"\\n\");", "}", "if ( gf_media_get_rfc_6381_codec_name(file, trackNum, szCodec, GF_FALSE, GF_FALSE) == GF_OK) {", "fprintf(stderr, \"\\tRFC6381 Codec Parameters: %s\\n\", szCodec);", "}", "DumpMetaItem(file, 0, trackNum, \"\\tTrack Meta\");", "gf_isom_get_track_switch_group_count(file, trackNum, &alt_group, &nb_groups);", "if (alt_group) {", "fprintf(stderr, \"Alternate Group ID %d\\n\", alt_group);", "for (i=0; i<nb_groups; i++) {", "u32 nb_crit, switchGroupID;", "const u32 *criterias = gf_isom_get_track_switch_parameter(file, trackNum, i+1, &switchGroupID, &nb_crit);", "if (!nb_crit) {", "fprintf(stderr, \"\\tNo criteria in %s group\\n\", switchGroupID ? \"switch\" : \"alternate\");", "} else {", "if (switchGroupID) {", "fprintf(stderr, \"\\tSwitchGroup ID %d criterias: \", switchGroupID);", "} else {", "fprintf(stderr, \"\\tAlternate Group criterias: \");", "}", "for (j=0; j<nb_crit; j++) {", "if (j) fprintf(stderr, \" \");", "fprintf(stderr, \"%s\", gf_4cc_to_str(criterias[j]) );", "}", "fprintf(stderr, \"\\n\");", "}", "}", "}", "switch (gf_isom_has_sync_points(file, trackNum)) {", "case 0:", "fprintf(stderr, \"\\tAll samples are sync\\n\");", "break;", "case 1:", "{", "u32 nb_sync = gf_isom_get_sync_point_count(file, trackNum) - 1;", "if (! nb_sync) {", "fprintf(stderr, \"\\tOnly one sync sample\\n\");", "} else {", "fprintf(stderr, \"\\tAverage GOP length: %d samples\\n\", gf_isom_get_sample_count(file, trackNum) / nb_sync);", "}", "}", "break;", "case 2:", "fprintf(stderr, \"\\tNo sync sample found\\n\");", "break;", "}", "fprintf(stderr, \"\\tMax sample duration: %d / %d\\n\", gf_isom_get_max_sample_delta(file, trackNum), timescale);", "if (!full_dump) {", "fprintf(stderr, \"\\n\");", "return;", "}", "dur = size = 0;", "max_rate = rate = 0;", "time_slice = 0;", "ts = gf_isom_get_media_timescale(file, trackNum);", "csize = gf_isom_get_constant_sample_size(file, trackNum);", "cdur = gf_isom_get_constant_sample_duration(file, trackNum);", "count = gf_isom_get_sample_count(file, trackNum);", "if (csize && cdur) {", "size = count * csize;", "dur = cdur * count;", "} else {", "for (j=0; j<count; j++) {", "GF_ISOSample *samp;", "if (is_od_track) {", "samp = gf_isom_get_sample(file, trackNum, j+1, NULL);", "} else {", "samp = gf_isom_get_sample_info(file, trackNum, j+1, NULL, NULL);", "}", "if (!samp) {", "M4_LOG(GF_LOG_ERROR, (\"Failed to fetch sample %d\\n\", j+1));", "return;", "}", "dur = samp->DTS+samp->CTS_Offset;", "size += samp->dataLength;", "rate += samp->dataLength;", "if (samp->DTS - time_slice > ts) {", "Double max_tmp = rate * ts / (samp->DTS - time_slice);", "if (max_rate < max_tmp )", "max_rate = max_tmp;", "rate = 0;", "time_slice = samp->DTS;", "}", "gf_isom_sample_del(&samp);", "}", "}", "fprintf(stderr, \"\\nComputed info from media:\\n\");", "if (csize && cdur) {", "fprintf(stderr, \"\\tConstant sample size %d bytes and dur %d / %d\\n\", csize, cdur, ts);", "}", "scale = 1000.0 / ts;", "dur = (u64) (scale * dur);", "fprintf(stderr, \"\\tTotal size \"LLU\" bytes - Total samples duration \"LLU\" ms\\n\", size, dur);", "if (!dur) {", "fprintf(stderr, \"\\n\");", "return;", "}", "rate = 8000.0 * size / dur;", "if (!max_rate)", "max_rate = rate;", "else", "max_rate *= 8.0;", "if (rate >= 1500) {", "fprintf(stderr, \"\\tAverage rate %.2f kbps - Max Rate %.2f kbps\\n\", rate/1000, max_rate/1000);", "} else {", "fprintf(stderr, \"\\tAverage rate %.2f bps - Max Rate %.2f bps\\n\", rate, max_rate);", "}", "{", "u32 dmin, dmax, davg, smin, smax, savg;", "gf_isom_get_chunks_infos(file, trackNum, &dmin, &davg, &dmax, &smin, &savg, &smax);", "fprintf(stderr, \"\\tChunk durations: min %d ms - max %d ms - average %d ms\\n\", (1000*dmin)/ts, (1000*dmax)/ts, (1000*davg)/ts);", "fprintf(stderr, \"\\tChunk sizes (bytes): min %d - max %d - average %d\\n\", smin, smax, savg);", "}", "fprintf(stderr, \"\\n\");", "count = gf_isom_get_chapter_count(file, trackNum);", "if (count) {", "const char *name;", "u64 time;", "fprintf(stderr, \"\\nChapters:\\n\");", "for (j=0; j<count; j++) {", "gf_isom_get_chapter(file, trackNum, j+1, &time, &name);", "fprintf(stderr, \"\\tChapter #%d - %s - \\\"%s\\\"\\n\", j+1, format_duration(time, 1000, szDur), name);", "}", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static void parse_sec_attr_44(sc_file_t *file, const u8 *buf, size_t len)", "{", "const int df_idx[8] = {", "SC_AC_OP_DELETE, SC_AC_OP_CREATE, SC_AC_OP_CREATE,", "SC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE,", "SC_AC_OP_LOCK, SC_AC_OP_DELETE, -1};", "const int ef_idx[8] = {", "SC_AC_OP_READ, SC_AC_OP_UPDATE, SC_AC_OP_WRITE,", "SC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE,", "-1, SC_AC_OP_ERASE, -1};", "const int efi_idx[8] = {", "SC_AC_OP_READ, SC_AC_OP_ERASE, SC_AC_OP_UPDATE,", "SC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE,", "-1, SC_AC_OP_ERASE, -1};", "u8  bValue;", "int  i;", "int  iKeyRef = 0;", "int  iMethod;", "int  iPinCount;", "int  iOffset = 0;", "int  iOperation;", "const int* p_idx;", "while (len > 1) {", "size_t iACLen   = buf[iOffset] & 0x0F;", "if (iACLen > len)", "break;", "iMethod = SC_AC_NONE;", "if (buf[iOffset] & 0X80) {", "size_t iParmLen = 1;", "size_t iKeyLen  = 0;", "if (buf[iOffset]   & 0x20) iKeyLen++;", "if (buf[iOffset+1] & 0x40) iParmLen++;", "if (buf[iOffset+1] & 0x20) iParmLen++;", "if (buf[iOffset+1] & 0x10) iParmLen++;", "if (buf[iOffset+1] & 0x08) iParmLen++;", "if(iKeyLen) {", "int iSC;", "if (len < 1+(size_t)iACLen)", "break;", "iSC = buf[iOffset+iACLen];", "switch( (iSC>>5) & 0x03 ){", "case 0:", "iMethod = SC_AC_TERM;", "break;", "case 1:", "iMethod = SC_AC_AUT;", "break;", "case 2:", "case 3:", "iMethod = SC_AC_PRO;", "break;", "}", "iKeyRef = iSC & 0x1F;", "}", "if (iACLen > (1+iParmLen+iKeyLen)) {", "if (len < 1+1+1+(size_t)iParmLen)", "break;", "iKeyRef = buf[iOffset+1+1+iParmLen];", "iMethod = SC_AC_CHV;", "}", "if (len < 1+2)", "break;", "switch(buf[iOffset+2]){", "case 0x2A:", "iOperation = SC_AC_OP_CRYPTO;", "break;", "case 0x46:", "iOperation = SC_AC_OP_UPDATE;", "break;", "default:", "iOperation = SC_AC_OP_SELECT;", "break;", "}", "sc_file_add_acl_entry(file, iOperation, iMethod, iKeyRef);", "}", "else {", "switch (file->type) {", "case SC_FILE_TYPE_DF:", "p_idx = df_idx;", "break;", "case SC_FILE_TYPE_INTERNAL_EF:", "p_idx = efi_idx;", "break;", "default:", "p_idx = ef_idx;", "break;", "}", "iPinCount = iACLen - 1;", "if (buf[iOffset] & 0x20) {", "int iSC;", "if (len < 1 + (size_t)iACLen)", "break;", "iSC = buf[iOffset + iACLen];", "switch( (iSC>>5) & 0x03 ) {", "case 0:", "iMethod = SC_AC_TERM;", "break;", "case 1:", "iMethod = SC_AC_AUT;", "break;", "case 2:", "case 3:", "iMethod = SC_AC_PRO;", "break;", "}", "iKeyRef = iSC & 0x1F;", "iPinCount--;", "}", "if ( iPinCount > 0 ) {", "if (len < 1 + 2)", "break;", "iKeyRef = buf[iOffset + 2];", "iMethod = SC_AC_CHV;", "}", "bValue = buf[iOffset + 1];", "for (i = 0; i < 8; i++) {", "if((bValue & 1) && (p_idx[i] >= 0))", "sc_file_add_acl_entry(file, p_idx[i], iMethod, iKeyRef);", "bValue >>= 1;", "}", "}", "iOffset += iACLen +1;", "len     -= iACLen +1;", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["lldp_decode(struct lldpd *cfg, char *frame, int s,", "struct lldpd_hardware *hardware,", "struct lldpd_chassis **newchassis, struct lldpd_port **newport)", "{", "struct lldpd_chassis *chassis;", "struct lldpd_port *port;", "const char lldpaddr[] = LLDP_MULTICAST_ADDR;", "const char dot1[] = LLDP_TLV_ORG_DOT1;", "const char dot3[] = LLDP_TLV_ORG_DOT3;", "const char med[] = LLDP_TLV_ORG_MED;", "const char dcbx[] = LLDP_TLV_ORG_DCBX;", "unsigned char orgid[3];", "int length, gotend = 0, ttl_received = 0;", "int tlv_size, tlv_type, tlv_subtype;", "u_int8_t *pos, *tlv;", "char *b;", "#ifdef ENABLE_DOT1", "struct lldpd_vlan *vlan = NULL;", "int vlan_len;", "struct lldpd_ppvid *ppvid;", "struct lldpd_pi *pi = NULL;", "#endif", "struct lldpd_mgmt *mgmt;", "int af;", "u_int8_t addr_str_length, addr_str_buffer[32];", "u_int8_t addr_family, addr_length, *addr_ptr, iface_subtype;", "u_int32_t iface_number, iface;", "#ifdef ENABLE_CUSTOM", "struct lldpd_custom *custom = NULL;", "#endif", "log_debug(\"lldp\", \"receive LLDP PDU on %s\",", "hardware->h_ifname);", "if ((chassis = calloc(1, sizeof(struct lldpd_chassis))) == NULL) {", "log_warn(\"lldp\", \"failed to allocate remote chassis\");", "return -1;", "}", "TAILQ_INIT(&chassis->c_mgmt);", "if ((port = calloc(1, sizeof(struct lldpd_port))) == NULL) {", "log_warn(\"lldp\", \"failed to allocate remote port\");", "free(chassis);", "return -1;", "}", "#ifdef ENABLE_DOT1", "TAILQ_INIT(&port->p_vlans);", "TAILQ_INIT(&port->p_ppvids);", "TAILQ_INIT(&port->p_pids);", "#endif", "#ifdef ENABLE_CUSTOM", "TAILQ_INIT(&port->p_custom_list);", "#endif", "length = s;", "pos = (u_int8_t*)frame;", "if (length < 2*ETHER_ADDR_LEN + sizeof(u_int16_t)) {", "log_warnx(\"lldp\", \"too short frame received on %s\", hardware->h_ifname);", "goto malformed;", "}", "if (PEEK_CMP(lldpaddr, ETHER_ADDR_LEN) != 0) {", "log_info(\"lldp\", \"frame not targeted at LLDP multicast address received on %s\",", "hardware->h_ifname);", "goto malformed;", "}", "PEEK_DISCARD(ETHER_ADDR_LEN);", "if (PEEK_UINT16 != ETHERTYPE_LLDP) {", "log_info(\"lldp\", \"non LLDP frame received on %s\",", "hardware->h_ifname);", "goto malformed;", "}", "while (length && (!gotend)) {", "if (length < 2) {", "log_warnx(\"lldp\", \"tlv header too short received on %s\",", "hardware->h_ifname);", "goto malformed;", "}", "tlv_size = PEEK_UINT16;", "tlv_type = tlv_size >> 9;", "tlv_size = tlv_size & 0x1ff;", "(void)PEEK_SAVE(tlv);", "if (length < tlv_size) {", "log_warnx(\"lldp\", \"frame too short for tlv received on %s\",", "hardware->h_ifname);", "goto malformed;", "}", "switch (tlv_type) {", "case LLDP_TLV_END:", "if (tlv_size != 0) {", "log_warnx(\"lldp\", \"lldp end received with size not null on %s\",", "hardware->h_ifname);", "goto malformed;", "}", "if (length)", "log_debug(\"lldp\", \"extra data after lldp end on %s\",", "hardware->h_ifname);", "gotend = 1;", "break;", "case LLDP_TLV_CHASSIS_ID:", "case LLDP_TLV_PORT_ID:", "CHECK_TLV_SIZE(2, \"Port Id\");", "tlv_subtype = PEEK_UINT8;", "if ((tlv_subtype == 0) || (tlv_subtype > 7)) {", "log_warnx(\"lldp\", \"unknown subtype for tlv id received on %s\",", "hardware->h_ifname);", "goto malformed;", "}", "if ((b = (char *)calloc(1, tlv_size - 1)) == NULL) {", "log_warn(\"lldp\", \"unable to allocate memory for id tlv \"", "\"received on %s\",", "hardware->h_ifname);", "goto malformed;", "}", "PEEK_BYTES(b, tlv_size - 1);", "if (tlv_type == LLDP_TLV_PORT_ID) {", "port->p_id_subtype = tlv_subtype;", "port->p_id = b;", "port->p_id_len = tlv_size - 1;", "} else {", "chassis->c_id_subtype = tlv_subtype;", "chassis->c_id = b;", "chassis->c_id_len = tlv_size - 1;", "}", "break;", "case LLDP_TLV_TTL:", "CHECK_TLV_SIZE(2, \"TTL\");", "chassis->c_ttl = PEEK_UINT16;", "ttl_received = 1;", "break;", "case LLDP_TLV_PORT_DESCR:", "case LLDP_TLV_SYSTEM_NAME:", "case LLDP_TLV_SYSTEM_DESCR:", "if (tlv_size < 1) {", "log_debug(\"lldp\", \"empty tlv received on %s\",", "hardware->h_ifname);", "break;", "}", "if ((b = (char *)calloc(1, tlv_size + 1)) == NULL) {", "log_warn(\"lldp\", \"unable to allocate memory for string tlv \"", "\"received on %s\",", "hardware->h_ifname);", "goto malformed;", "}", "PEEK_BYTES(b, tlv_size);", "if (tlv_type == LLDP_TLV_PORT_DESCR)", "port->p_descr = b;", "else if (tlv_type == LLDP_TLV_SYSTEM_NAME)", "chassis->c_name = b;", "else chassis->c_descr = b;", "break;", "case LLDP_TLV_SYSTEM_CAP:", "CHECK_TLV_SIZE(4, \"System capabilities\");", "chassis->c_cap_available = PEEK_UINT16;", "chassis->c_cap_enabled = PEEK_UINT16;", "break;", "case LLDP_TLV_MGMT_ADDR:", "CHECK_TLV_SIZE(1, \"Management address\");", "addr_str_length = PEEK_UINT8;", "CHECK_TLV_SIZE(1 + addr_str_length, \"Management address\");", "PEEK_BYTES(addr_str_buffer, addr_str_length);", "addr_length = addr_str_length - 1;", "addr_family = addr_str_buffer[0];", "addr_ptr = &addr_str_buffer[1];", "CHECK_TLV_SIZE(1 + addr_str_length + 5, \"Management address\");", "iface_subtype = PEEK_UINT8;", "iface_number = PEEK_UINT32;", "af = lldpd_af_from_lldp_proto(addr_family);", "if (af == LLDPD_AF_UNSPEC)", "break;", "if (iface_subtype == LLDP_MGMT_IFACE_IFINDEX)", "iface = iface_number;", "else", "iface = 0;", "mgmt = lldpd_alloc_mgmt(af, addr_ptr, addr_length, iface);", "if (mgmt == NULL) {", "assert(errno == ENOMEM);", "log_warn(\"lldp\", \"unable to allocate memory \"", "\"for management address\");", "goto malformed;", "}", "TAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt, m_entries);", "break;", "case LLDP_TLV_ORG:", "CHECK_TLV_SIZE(4, \"Organisational\");", "PEEK_BYTES(orgid, sizeof(orgid));", "tlv_subtype = PEEK_UINT8;", "if (memcmp(dot1, orgid, sizeof(orgid)) == 0) {", "#ifndef ENABLE_DOT1", "hardware->h_rx_unrecognized_cnt++;", "#else", "switch (tlv_subtype) {", "case LLDP_TLV_DOT1_VLANNAME:", "CHECK_TLV_SIZE(7, \"VLAN\");", "if ((vlan = (struct lldpd_vlan *)calloc(1,", "sizeof(struct lldpd_vlan))) == NULL) {", "log_warn(\"lldp\", \"unable to alloc vlan \"", "\"structure for \"", "\"tlv received on %s\",", "hardware->h_ifname);", "goto malformed;", "}", "vlan->v_vid = PEEK_UINT16;", "vlan_len = PEEK_UINT8;", "CHECK_TLV_SIZE(7 + vlan_len, \"VLAN\");", "if ((vlan->v_name =", "(char *)calloc(1, vlan_len + 1)) == NULL) {", "log_warn(\"lldp\", \"unable to alloc vlan name for \"", "\"tlv received on %s\",", "hardware->h_ifname);", "goto malformed;", "}", "PEEK_BYTES(vlan->v_name, vlan_len);", "TAILQ_INSERT_TAIL(&port->p_vlans,", "vlan, v_entries);", "vlan = NULL;", "break;", "case LLDP_TLV_DOT1_PVID:", "CHECK_TLV_SIZE(6, \"PVID\");", "port->p_pvid = PEEK_UINT16;", "break;", "case LLDP_TLV_DOT1_PPVID:", "CHECK_TLV_SIZE(7, \"PPVID\");", "if ((ppvid = (struct lldpd_ppvid *)calloc(1,", "sizeof(struct lldpd_ppvid))) == NULL) {", "log_warn(\"lldp\", \"unable to alloc ppvid \"", "\"structure for \"", "\"tlv received on %s\",", "hardware->h_ifname);", "goto malformed;", "}", "ppvid->p_cap_status = PEEK_UINT8;", "ppvid->p_ppvid = PEEK_UINT16;", "TAILQ_INSERT_TAIL(&port->p_ppvids,", "ppvid, p_entries);", "break;", "case LLDP_TLV_DOT1_PI:", "CHECK_TLV_SIZE(5, \"PI\");", "if ((pi = (struct lldpd_pi *)calloc(1,", "sizeof(struct lldpd_pi))) == NULL) {", "log_warn(\"lldp\", \"unable to alloc PI \"", "\"structure for \"", "\"tlv received on %s\",", "hardware->h_ifname);", "goto malformed;", "}", "pi->p_pi_len = PEEK_UINT8;", "CHECK_TLV_SIZE(5 + pi->p_pi_len, \"PI\");", "if ((pi->p_pi =", "(char *)calloc(1, pi->p_pi_len)) == NULL) {", "log_warn(\"lldp\", \"unable to alloc pid name for \"", "\"tlv received on %s\",", "hardware->h_ifname);", "goto malformed;", "}", "PEEK_BYTES(pi->p_pi, pi->p_pi_len);", "TAILQ_INSERT_TAIL(&port->p_pids,", "pi, p_entries);", "pi = NULL;", "break;", "default:", "hardware->h_rx_unrecognized_cnt++;", "}", "#endif", "} else if (memcmp(dot3, orgid, sizeof(orgid)) == 0) {", "#ifndef ENABLE_DOT3", "hardware->h_rx_unrecognized_cnt++;", "#else", "switch (tlv_subtype) {", "case LLDP_TLV_DOT3_MAC:", "CHECK_TLV_SIZE(9, \"MAC/PHY\");", "port->p_macphy.autoneg_support = PEEK_UINT8;", "port->p_macphy.autoneg_enabled =", "(port->p_macphy.autoneg_support & 0x2) >> 1;", "port->p_macphy.autoneg_support =", "port->p_macphy.autoneg_support & 0x1;", "port->p_macphy.autoneg_advertised =", "PEEK_UINT16;", "port->p_macphy.mau_type = PEEK_UINT16;", "break;", "case LLDP_TLV_DOT3_LA:", "CHECK_TLV_SIZE(9, \"Link aggregation\");", "PEEK_DISCARD_UINT8;", "port->p_aggregid = PEEK_UINT32;", "break;", "case LLDP_TLV_DOT3_MFS:", "CHECK_TLV_SIZE(6, \"MFS\");", "port->p_mfs = PEEK_UINT16;", "break;", "case LLDP_TLV_DOT3_POWER:", "CHECK_TLV_SIZE(7, \"Power\");", "port->p_power.devicetype = PEEK_UINT8;", "port->p_power.supported =", "(port->p_power.devicetype & 0x2) >> 1;", "port->p_power.enabled =", "(port->p_power.devicetype & 0x4) >> 2;", "port->p_power.paircontrol =", "(port->p_power.devicetype & 0x8) >> 3;", "port->p_power.devicetype =", "(port->p_power.devicetype & 0x1)?", "LLDP_DOT3_POWER_PSE:LLDP_DOT3_POWER_PD;", "port->p_power.pairs = PEEK_UINT8;", "port->p_power.class = PEEK_UINT8;", "if (tlv_size >= 12) {", "port->p_power.powertype = PEEK_UINT8;", "port->p_power.source =", "(port->p_power.powertype & (1<<5 | 1<<4)) >> 4;", "port->p_power.priority =", "(port->p_power.powertype & (1<<1 | 1<<0));", "port->p_power.powertype =", "(port->p_power.powertype & (1<<7))?", "LLDP_DOT3_POWER_8023AT_TYPE1:", "LLDP_DOT3_POWER_8023AT_TYPE2;", "port->p_power.requested = PEEK_UINT16;", "port->p_power.allocated = PEEK_UINT16;", "} else", "port->p_power.powertype =", "LLDP_DOT3_POWER_8023AT_OFF;", "break;", "default:", "hardware->h_rx_unrecognized_cnt++;", "}", "#endif", "} else if (memcmp(med, orgid, sizeof(orgid)) == 0) {", "#ifndef ENABLE_LLDPMED", "hardware->h_rx_unrecognized_cnt++;", "#else", "u_int32_t policy;", "unsigned loctype;", "unsigned power;", "switch (tlv_subtype) {", "case LLDP_TLV_MED_CAP:", "CHECK_TLV_SIZE(7, \"LLDP-MED capabilities\");", "chassis->c_med_cap_available = PEEK_UINT16;", "chassis->c_med_type = PEEK_UINT8;", "port->p_med_cap_enabled |=", "LLDP_MED_CAP_CAP;", "break;", "case LLDP_TLV_MED_POLICY:", "CHECK_TLV_SIZE(8, \"LLDP-MED policy\");", "policy = PEEK_UINT32;", "if (((policy >> 24) < 1) ||", "((policy >> 24) > LLDP_MED_APPTYPE_LAST)) {", "log_info(\"lldp\", \"unknown policy field %d \"", "\"received on %s\",", "policy,", "hardware->h_ifname);", "break;", "}", "port->p_med_policy[(policy >> 24) - 1].type =", "(policy >> 24);", "port->p_med_policy[(policy >> 24) - 1].unknown =", "((policy & 0x800000) != 0);", "port->p_med_policy[(policy >> 24) - 1].tagged =", "((policy & 0x400000) != 0);", "port->p_med_policy[(policy >> 24) - 1].vid =", "(policy & 0x001FFE00) >> 9;", "port->p_med_policy[(policy >> 24) - 1].priority =", "(policy & 0x1C0) >> 6;", "port->p_med_policy[(policy >> 24) - 1].dscp =", "policy & 0x3F;", "port->p_med_cap_enabled |=", "LLDP_MED_CAP_POLICY;", "break;", "case LLDP_TLV_MED_LOCATION:", "CHECK_TLV_SIZE(5, \"LLDP-MED Location\");", "loctype = PEEK_UINT8;", "if ((loctype < 1) ||", "(loctype > LLDP_MED_LOCFORMAT_LAST)) {", "log_info(\"lldp\", \"unknown location type \"", "\"received on %s\",", "hardware->h_ifname);", "break;", "}", "if ((port->p_med_location[loctype - 1].data =", "(char*)malloc(tlv_size - 5)) == NULL) {", "log_warn(\"lldp\", \"unable to allocate memory \"", "\"for LLDP-MED location for \"", "\"frame received on %s\",", "hardware->h_ifname);", "goto malformed;", "}", "PEEK_BYTES(port->p_med_location[loctype - 1].data,", "tlv_size - 5);", "port->p_med_location[loctype - 1].data_len =", "tlv_size - 5;", "port->p_med_location[loctype - 1].format = loctype;", "port->p_med_cap_enabled |=", "LLDP_MED_CAP_LOCATION;", "break;", "case LLDP_TLV_MED_MDI:", "CHECK_TLV_SIZE(7, \"LLDP-MED PoE-MDI\");", "power = PEEK_UINT8;", "switch (power & 0xC0) {", "case 0x0:", "port->p_med_power.devicetype = LLDP_MED_POW_TYPE_PSE;", "port->p_med_cap_enabled |=", "LLDP_MED_CAP_MDI_PSE;", "switch (power & 0x30) {", "case 0x0:", "port->p_med_power.source =", "LLDP_MED_POW_SOURCE_UNKNOWN;", "break;", "case 0x10:", "port->p_med_power.source =", "LLDP_MED_POW_SOURCE_PRIMARY;", "break;", "case 0x20:", "port->p_med_power.source =", "LLDP_MED_POW_SOURCE_BACKUP;", "break;", "default:", "port->p_med_power.source =", "LLDP_MED_POW_SOURCE_RESERVED;", "}", "break;", "case 0x40:", "port->p_med_power.devicetype = LLDP_MED_POW_TYPE_PD;", "port->p_med_cap_enabled |=", "LLDP_MED_CAP_MDI_PD;", "switch (power & 0x30) {", "case 0x0:", "port->p_med_power.source =", "LLDP_MED_POW_SOURCE_UNKNOWN;", "break;", "case 0x10:", "port->p_med_power.source =", "LLDP_MED_POW_SOURCE_PSE;", "break;", "case 0x20:", "port->p_med_power.source =", "LLDP_MED_POW_SOURCE_LOCAL;", "break;", "default:", "port->p_med_power.source =", "LLDP_MED_POW_SOURCE_BOTH;", "}", "break;", "default:", "port->p_med_power.devicetype =", "LLDP_MED_POW_TYPE_RESERVED;", "}", "if ((power & 0x0F) > LLDP_MED_POW_PRIO_LOW)", "port->p_med_power.priority =", "LLDP_MED_POW_PRIO_UNKNOWN;", "else", "port->p_med_power.priority =", "power & 0x0F;", "port->p_med_power.val = PEEK_UINT16;", "break;", "case LLDP_TLV_MED_IV_HW:", "case LLDP_TLV_MED_IV_SW:", "case LLDP_TLV_MED_IV_FW:", "case LLDP_TLV_MED_IV_SN:", "case LLDP_TLV_MED_IV_MANUF:", "case LLDP_TLV_MED_IV_MODEL:", "case LLDP_TLV_MED_IV_ASSET:", "if (tlv_size <= 4)", "b = NULL;", "else {", "if ((b = (char*)malloc(tlv_size - 3)) ==", "NULL) {", "log_warn(\"lldp\", \"unable to allocate \"", "\"memory for LLDP-MED \"", "\"inventory for frame \"", "\"received on %s\",", "hardware->h_ifname);", "goto malformed;", "}", "PEEK_BYTES(b, tlv_size - 4);", "b[tlv_size - 4] = '\\0';", "}", "switch (tlv_subtype) {", "case LLDP_TLV_MED_IV_HW:", "chassis->c_med_hw = b;", "break;", "case LLDP_TLV_MED_IV_FW:", "chassis->c_med_fw = b;", "break;", "case LLDP_TLV_MED_IV_SW:", "chassis->c_med_sw = b;", "break;", "case LLDP_TLV_MED_IV_SN:", "chassis->c_med_sn = b;", "break;", "case LLDP_TLV_MED_IV_MANUF:", "chassis->c_med_manuf = b;", "break;", "case LLDP_TLV_MED_IV_MODEL:", "chassis->c_med_model = b;", "break;", "case LLDP_TLV_MED_IV_ASSET:", "chassis->c_med_asset = b;", "break;", "}", "port->p_med_cap_enabled |=", "LLDP_MED_CAP_IV;", "break;", "default:", "hardware->h_rx_unrecognized_cnt++;", "}", "#endif /* ENABLE_LLDPMED */", "} else if (memcmp(dcbx, orgid, sizeof(orgid)) == 0) {", "log_debug(\"lldp\", \"unsupported DCBX tlv received on %s - ignore\",", "hardware->h_ifname);", "hardware->h_rx_unrecognized_cnt++;", "} else {", "log_debug(\"lldp\", \"unknown org tlv [%02x:%02x:%02x] received on %s\",", "orgid[0], orgid[1], orgid[2],", "hardware->h_ifname);", "hardware->h_rx_unrecognized_cnt++;", "#ifdef ENABLE_CUSTOM", "custom = (struct lldpd_custom*)calloc(1, sizeof(struct lldpd_custom));", "if (!custom) {", "log_warn(\"lldp\",", "\"unable to allocate memory for custom TLV\");", "goto malformed;", "}", "custom->oui_info_len = tlv_size > 4 ? tlv_size - 4 : 0;", "memcpy(custom->oui, orgid, sizeof(custom->oui));", "custom->subtype = tlv_subtype;", "if (custom->oui_info_len > 0) {", "custom->oui_info = malloc(custom->oui_info_len);", "if (!custom->oui_info) {", "log_warn(\"lldp\",", "\"unable to allocate memory for custom TLV data\");", "goto malformed;", "}", "PEEK_BYTES(custom->oui_info, custom->oui_info_len);", "}", "TAILQ_INSERT_TAIL(&port->p_custom_list, custom, next);", "custom = NULL;", "#endif", "}", "break;", "default:", "log_warnx(\"lldp\", \"unknown tlv (%d) received on %s\",", "tlv_type, hardware->h_ifname);", "goto malformed;", "}", "if (pos > tlv + tlv_size) {", "log_warnx(\"lldp\", \"BUG: already past TLV!\");", "goto malformed;", "}", "PEEK_DISCARD(tlv + tlv_size - pos);", "}", "if ((chassis->c_id == NULL) ||", "(port->p_id == NULL) ||", "(!ttl_received) ||", "(gotend == 0)) {", "log_warnx(\"lldp\", \"some mandatory tlv are missing for frame received on %s\",", "hardware->h_ifname);", "goto malformed;", "}", "*newchassis = chassis;", "*newport = port;", "return 1;", "malformed:", "#ifdef ENABLE_CUSTOM", "free(custom);", "#endif", "#ifdef ENABLE_DOT1", "free(vlan);", "free(pi);", "#endif", "lldpd_chassis_cleanup(chassis, 1);", "lldpd_port_cleanup(port, 1);", "free(port);", "return -1;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["is_ref(const uint8_t *data, size_t beg, size_t end, size_t *last, struct link_ref **refs)", "{", "size_t i = 0;", "size_t id_offset, id_end;", "size_t link_offset, link_end;", "size_t title_offset, title_end;", "size_t line_end;", "if (beg + 3 >= end) return 0;", "if (data[beg] == ' ') { i = 1;", "if (data[beg + 1] == ' ') { i = 2;", "if (data[beg + 2] == ' ') { i = 3;", "if (data[beg + 3] == ' ') return 0; } } }", "i += beg;", "if (data[i] != '[') return 0;", "i++;", "id_offset = i;", "while (i < end && data[i] != '\\n' && data[i] != '\\r' && data[i] != ']')", "i++;", "if (i >= end || data[i] != ']') return 0;", "id_end = i;", "i++;", "if (i >= end || data[i] != ':') return 0;", "i++;", "while (i < end && data[i] == ' ') i++;", "if (i < end && (data[i] == '\\n' || data[i] == '\\r')) {", "i++;", "if (i < end && data[i] == '\\r' && data[i - 1] == '\\n') i++; }", "while (i < end && data[i] == ' ') i++;", "if (i >= end) return 0;", "if (data[i] == '<')", "i++;", "link_offset = i;", "while (i < end && data[i] != ' ' && data[i] != '\\n' && data[i] != '\\r')", "i++;", "if (data[i - 1] == '>') link_end = i - 1;", "else link_end = i;", "while (i < end && data[i] == ' ') i++;", "if (i < end && data[i] != '\\n' && data[i] != '\\r'", "&& data[i] != '\\'' && data[i] != '\"' && data[i] != '(')", "return 0;", "line_end = 0;", "if (i >= end || data[i] == '\\r' || data[i] == '\\n') line_end = i;", "if (i + 1 < end && data[i] == '\\n' && data[i + 1] == '\\r')", "line_end = i + 1;", "if (line_end) {", "i = line_end + 1;", "while (i < end && data[i] == ' ') i++; }", "title_offset = title_end = 0;", "if (i + 1 < end", "&& (data[i] == '\\'' || data[i] == '\"' || data[i] == '(')) {", "i++;", "title_offset = i;", "while (i < end && data[i] != '\\n' && data[i] != '\\r') i++;", "if (i + 1 < end && data[i] == '\\n' && data[i + 1] == '\\r')", "title_end = i + 1;", "else title_end = i;", "i -= 1;", "while (i > title_offset && data[i] == ' ')", "i -= 1;", "if (i > title_offset", "&& (data[i] == '\\'' || data[i] == '\"' || data[i] == ')')) {", "line_end = title_end;", "title_end = i; } }", "if (!line_end || link_end == link_offset)", "return 0;", "if (last)", "*last = line_end;", "if (refs) {", "struct link_ref *ref;", "ref = add_link_ref(refs, data + id_offset, id_end - id_offset);", "if (!ref)", "return 0;", "ref->link = bufnew(link_end - link_offset);", "bufput(ref->link, data + link_offset, link_end - link_offset);", "if (title_end > title_offset) {", "ref->title = bufnew(title_end - title_offset);", "bufput(ref->title, data + title_offset, title_end - title_offset);", "}", "}", "return 1;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["int main(int argc, char *argv[])", "{", "int result;", "int infoOnly = 0;", "int writeToStdio = 0;", "int readFromStdin = 0;", "int object_type = LC;", "int def_srate = 0;", "int downMatrix = 0;", "int format = 1;", "int outputFormat = FAAD_FMT_16BIT;", "int outfile_set = 0;", "int adts_out = 0;", "int old_format = 0;", "int showHelp = 0;", "int mp4file = 0;", "int noGapless = 0;", "char *fnp;", "char aacFileName[255];", "char audioFileName[255];", "char adtsFileName[255];", "unsigned char header[8];", "float length = 0;", "FILE *hMP4File;", "#ifdef _WIN32", "long begin;", "#else", "clock_t begin;", "#endif", "unsigned long cap = NeAACDecGetCapabilities();", "progName = argv[0];", "while (1) {", "int c = -1;", "int option_index = 0;", "static struct option long_options[] = {", "{ \"quiet\",      0, 0, 'q' },", "{ \"outfile\",    0, 0, 'o' },", "{ \"adtsout\",    0, 0, 'a' },", "{ \"oldformat\",  0, 0, 't' },", "{ \"format\",     0, 0, 'f' },", "{ \"bits\",       0, 0, 'b' },", "{ \"samplerate\", 0, 0, 's' },", "{ \"objecttype\", 0, 0, 'l' },", "{ \"downmix\",    0, 0, 'd' },", "{ \"info\",       0, 0, 'i' },", "{ \"stdio\",      0, 0, 'w' },", "{ \"stdio\",      0, 0, 'g' },", "{ \"help\",       0, 0, 'h' },", "{ 0, 0, 0, 0 }", "};", "c = getopt_long(argc, argv, \"o:a:s:f:b:l:wgdhitq\",", "long_options, &option_index);", "if (c == -1)", "break;", "switch (c) {", "case 'o':", "if (optarg)", "{", "outfile_set = 1;", "strcpy(audioFileName, optarg);", "}", "break;", "case 'a':", "if (optarg)", "{", "adts_out = 1;", "strcpy(adtsFileName, optarg);", "}", "break;", "case 's':", "if (optarg)", "{", "char dr[10];", "if (sscanf(optarg, \"%s\", dr) < 1) {", "def_srate = 0;", "} else {", "def_srate = atoi(dr);", "}", "}", "break;", "case 'f':", "if (optarg)", "{", "char dr[10];", "if (sscanf(optarg, \"%s\", dr) < 1)", "{", "format = 1;", "} else {", "format = atoi(dr);", "if ((format < 1) || (format > 2))", "showHelp = 1;", "}", "}", "break;", "case 'b':", "if (optarg)", "{", "char dr[10];", "if (sscanf(optarg, \"%s\", dr) < 1)", "{", "outputFormat = FAAD_FMT_16BIT;", "} else {", "outputFormat = atoi(dr);", "if ((outputFormat < 1) || (outputFormat > 5))", "showHelp = 1;", "}", "}", "break;", "case 'l':", "if (optarg)", "{", "char dr[10];", "if (sscanf(optarg, \"%s\", dr) < 1)", "{", "object_type = LC;", "} else {", "object_type = atoi(dr);", "if ((object_type != LC) &&", "(object_type != MAIN) &&", "(object_type != LTP) &&", "(object_type != LD))", "{", "showHelp = 1;", "}", "}", "}", "break;", "case 't':", "old_format = 1;", "break;", "case 'd':", "downMatrix = 1;", "break;", "case 'w':", "writeToStdio = 1;", "break;", "case 'g':", "noGapless = 1;", "break;", "case 'i':", "infoOnly = 1;", "break;", "case 'h':", "showHelp = 1;", "break;", "case 'q':", "quiet = 1;", "break;", "default:", "break;", "}", "}", "faad_fprintf(stderr, \" *********** Ahead Software MPEG-4 AAC Decoder V%s ******************\\n\\n\", FAAD2_VERSION);", "faad_fprintf(stderr, \" Build: %s\\n\", __DATE__);", "faad_fprintf(stderr, \" Copyright 2002-2004: Ahead Software AG\\n\");", "faad_fprintf(stderr, \" http:www.audiocoding.com\\n\");", "if (cap & FIXED_POINT_CAP)", "faad_fprintf(stderr, \" Fixed point version\\n\");", "else", "faad_fprintf(stderr, \" Floating point version\\n\");", "faad_fprintf(stderr, \"\\n\");", "faad_fprintf(stderr, \" This program is free software; you can redistribute it and/or modify\\n\");", "faad_fprintf(stderr, \" it under the terms of the GNU General Public License.\\n\");", "faad_fprintf(stderr, \"\\n\");", "faad_fprintf(stderr, \" **************************************************************************\\n\\n\");", "if (((argc - optind) < 1) || showHelp)", "{", "usage();", "return 1;", "}", "#if 0", "if (writeToStdio == 1)", "{", "format = 2;", "}", "#endif", "strcpy(aacFileName, argv[optind]);", "#ifdef _WIN32", "begin = GetTickCount();", "#else", "begin = clock();", "#endif", "if(!writeToStdio && !outfile_set)", "{", "strcpy(audioFileName, aacFileName);", "fnp = (char *)strrchr(audioFileName,'.');", "if (fnp)", "fnp[0] = '\\0';", "strcat(audioFileName, file_ext[format]);", "}", "if (0 == strcmp(aacFileName, \"-\")) {", "faad_fprintf(stderr, \"Reading from stdin: %s\\n\", aacFileName);", "readFromStdin = 1;", "hMP4File  = stdin;", "#ifdef _WIN32", "setmode(fileno(stdin), O_BINARY);", "#endif", "} else {", "mp4file = 0;", "hMP4File = fopen(aacFileName, \"rb\");", "if (!hMP4File)", "{", "faad_fprintf(stderr, \"Error opening file: %s\\n\", aacFileName);", "return 1;", "}", "}", "fread(header, 1, 8, hMP4File);", "if (! readFromStdin )", "fclose(hMP4File);", "if (header[4] == 'f' && header[5] == 't' && header[6] == 'y' && header[7] == 'p')", "mp4file = 1;", "if (mp4file)", "{", "result = decodeMP4file(aacFileName, audioFileName, adtsFileName, writeToStdio,", "outputFormat, format, downMatrix, noGapless, infoOnly, adts_out, &length);", "} else {", "if (readFromStdin == 1) {", "ungetc(header[7],hMP4File);", "ungetc(header[6],hMP4File);", "ungetc(header[5],hMP4File);", "ungetc(header[4],hMP4File);", "ungetc(header[3],hMP4File);", "ungetc(header[2],hMP4File);", "ungetc(header[1],hMP4File);", "ungetc(header[0],hMP4File);", "}", "result = decodeAACfile(aacFileName, audioFileName, adtsFileName, writeToStdio,", "def_srate, object_type, outputFormat, format, downMatrix, infoOnly, adts_out,", "old_format, &length);", "}", "if (!result && !infoOnly)", "{", "#ifdef _WIN32", "float dec_length = (float)(GetTickCount()-begin)/1000.0;", "SetConsoleTitle(\"FAAD\");", "#else", "float dec_length = (float)(clock() - begin)/(float)CLOCKS_PER_SEC;", "#endif", "faad_fprintf(stderr, \"Decoding %s took: %5.2f sec. %5.2fx real-time.\\n\", aacFileName,", "dec_length, length/dec_length);", "}", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["static void* swoole_unserialize_arr(void *buffer, zval *zvalue, uint32_t nNumOfElements, long flag)", "{", "zend_ulong h, nIndex, max_index = 0;", "uint32_t size = cp_zend_hash_check_size(nNumOfElements);", "if (!size)", "{", "return NULL;", "}", "if (!buffer)", "{", "php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"illegal unserialize data\");", "return NULL;", "}", "ZVAL_NEW_ARR(zvalue);", "zend_array *ht = Z_ARR_P(zvalue);", "ht->nTableSize = size;", "ht->nNumUsed = nNumOfElements;", "ht->nNumOfElements = nNumOfElements;", "ht->nNextFreeElement = 0;", "#ifdef HASH_FLAG_APPLY_PROTECTION", "ht->u.flags = HASH_FLAG_APPLY_PROTECTION;", "#endif", "ht->nTableMask = -(ht->nTableSize);", "ht->pDestructor = ZVAL_PTR_DTOR;", "GC_SET_REFCOUNT(ht, 1);", "GC_TYPE_INFO(ht) = IS_ARRAY;", "HT_SET_DATA_ADDR(ht, emalloc(HT_SIZE(ht)));", "ht->u.flags |= HASH_FLAG_INITIALIZED;", "int ht_hash_size = HT_HASH_SIZE((ht)->nTableMask);", "if (ht_hash_size <= 0)", "{", "php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"illegal unserialize data\");", "return NULL;", "}", "HT_HASH_RESET(ht);", "int idx;", "Bucket *p;", "for(idx = 0; idx < nNumOfElements; idx++)", "{", "if (!buffer)", "{", "php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"illegal array unserialize data\");", "return NULL;", "}", "SBucketType type = *((SBucketType*) buffer);", "buffer += sizeof (SBucketType);", "p = ht->arData + idx;", "if (type.key_type == KEY_TYPE_STRING)", "{", "size_t key_len;", "if (type.key_len == 3)", "{", "void *str_pool_addr = get_pack_string_len_addr(&buffer, &key_len);", "p->key = zend_string_init((char*) str_pool_addr, key_len, 0);", "h = zend_inline_hash_func((char*) str_pool_addr, key_len);", "p->key->h = p->h = h;", "}", "else", "{", "if (type.key_len == 1)", "{", "key_len = *((zend_uchar*) buffer);", "buffer += sizeof (zend_uchar);", "}", "else if (type.key_len == 2)", "{", "key_len = *((unsigned short*) buffer);", "buffer += sizeof (unsigned short);", "}", "else", "{", "key_len = *((size_t*) buffer);", "buffer += sizeof (size_t);", "}", "p->key = zend_string_init((char*) buffer, key_len, 0);", "h = zend_inline_hash_func((char*) buffer, key_len);", "buffer += key_len;", "p->key->h = p->h = h;", "}", "}", "else", "{", "if (type.key_len == 0)", "{", "h = p->h = idx;", "p->key = NULL;", "max_index = p->h + 1;", "}", "else", "{", "if (type.key_len == 1)", "{", "h = *((zend_uchar*) buffer);", "buffer += sizeof (zend_uchar);", "}", "else if (type.key_len == 2)", "{", "h = *((unsigned short*) buffer);", "buffer += sizeof (unsigned short);", "}", "else", "{", "h = *((zend_ulong*) buffer);", "buffer += sizeof (zend_ulong);", "}", "p->h = h;", "p->key = NULL;", "if (h >= max_index)", "{", "max_index = h + 1;", "}", "}", "}", "nIndex = h | ht->nTableMask;", "Z_NEXT(p->val) = HT_HASH(ht, nIndex);", "HT_HASH(ht, nIndex) = HT_IDX_TO_HASH(idx);", "p->val.u1.v.type = type.data_type;", "Z_TYPE_FLAGS(p->val) = 0;", "if (type.data_type == IS_STRING)", "{", "size_t data_len;", "if (type.data_len == 3)", "{", "void *str_pool_addr = get_pack_string_len_addr(&buffer, &data_len);", "p->val.value.str = zend_string_init((char*) str_pool_addr, data_len, 0);", "}", "else", "{", "if (type.data_len == 1)", "{", "data_len = *((zend_uchar*) buffer);", "buffer += sizeof (zend_uchar);", "}", "else if (type.data_len == 2)", "{", "data_len = *((unsigned short*) buffer);", "buffer += sizeof (unsigned short);", "}", "else", "{", "data_len = *((size_t*) buffer);", "buffer += sizeof (size_t);", "}", "p->val.value.str = zend_string_init((char*) buffer, data_len, 0);", "buffer += data_len;", "}", "Z_TYPE_INFO(p->val) = IS_STRING_EX;", "}", "else if (type.data_type == IS_ARRAY)", "{", "uint32_t num = 0;", "buffer = get_array_real_len(buffer, type.data_len, &num);", "buffer = swoole_unserialize_arr(buffer, &p->val, num, flag);", "}", "else if (type.data_type == IS_LONG)", "{", "buffer = swoole_unserialize_long(buffer, &p->val, type);", "}", "else if (type.data_type == IS_DOUBLE)", "{", "p->val.value = *((zend_value*) buffer);", "buffer += sizeof (zend_value);", "}", "else if (type.data_type == IS_UNDEF)", "{", "buffer = swoole_unserialize_object(buffer, &p->val, type.data_len, NULL, flag);", "Z_TYPE_INFO(p->val) = IS_OBJECT_EX;", "}", "}", "ht->nNextFreeElement = max_index;", "return buffer;", "}"], "ner_tags": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["static void gf_dump_vrml_simple_field(GF_SceneDumper *sdump, GF_FieldInfo field, GF_Node *parent)", "{", "u32 i, sf_type;", "GF_ChildNodeItem *list;", "void *slot_ptr;", "switch (field.fieldType) {", "case GF_SG_VRML_SFNODE:", "assert ( *(GF_Node **)field.far_ptr);", "gf_dump_vrml_node(sdump, *(GF_Node **)field.far_ptr, 0, NULL);", "return;", "case GF_SG_VRML_MFNODE:", "list = * ((GF_ChildNodeItem **) field.far_ptr);", "assert( list );", "sdump->indent++;", "while (list) {", "gf_dump_vrml_node(sdump, list->node, 1, NULL);", "list = list->next;", "}", "sdump->indent--;", "return;", "case GF_SG_VRML_SFCOMMANDBUFFER:", "return;", "}", "if (gf_sg_vrml_is_sf_field(field.fieldType)) {", "if (sdump->XMLDump) StartAttribute(sdump, \"value\");", "gf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, parent);", "if (sdump->XMLDump) EndAttribute(sdump);", "} else {", "GenMFField *mffield;", "mffield = (GenMFField *) field.far_ptr;", "sf_type = gf_sg_vrml_get_sf_type(field.fieldType);", "if (!sdump->XMLDump) {", "gf_fprintf(sdump->trace, \"[\");", "} else if (sf_type==GF_SG_VRML_SFSTRING) {", "gf_fprintf(sdump->trace, \" value=\\'\");", "} else {", "StartAttribute(sdump, \"value\");", "}", "for (i=0; i<mffield->count; i++) {", "if (i) gf_fprintf(sdump->trace, \" \");", "gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);", "gf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, parent);", "}", "if (!sdump->XMLDump) {", "gf_fprintf(sdump->trace, \"]\");", "} else if (sf_type==GF_SG_VRML_SFSTRING) {", "gf_fprintf(sdump->trace, \"\\'\");", "} else {", "EndAttribute(sdump);", "}", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["RemoteFsDevice::RemoteFsDevice(MusicLibraryModel *m, const Details &d)", ": FsDevice(m, d.name, createUdi(d.name))", ", mountToken(0)", ", currentMountStatus(false)", ", details(d)", ", proc(0)", ", mounterIface(0)", ", messageSent(false)", "{", "setup();", "icn=MonoIcon::icon(details.isLocalFile()", "? FontAwesome::foldero", ": constSshfsProtocol==details.url.scheme()", "? FontAwesome::linux_os", ": FontAwesome::windows, Utils::monoIconColor());", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["u32 GetHintFormat(GF_TrackBox *trak)", "{", "GF_HintMediaHeaderBox *hmhd = (GF_HintMediaHeaderBox *)trak->Media->information->InfoHeader;", "if (hmhd->type != GF_ISOM_BOX_TYPE_HMHD)", "return 0;", "if (!hmhd || !hmhd->subType) {", "GF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);", "if (!hmhd) return a ? a->type : 0;", "if (a) hmhd->subType = a->type;", "return hmhd->subType;", "}", "return hmhd->subType;", "}"], "ner_tags": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static s32 gf_media_vvc_read_vps_bs_internal(GF_BitStream *bs, VVCState *vvc, Bool stop_at_vps_ext)", "{", "u32 i, j;", "s32 vps_id;", "VVC_VPS *vps;", "Bool vps_default_ptl_dpb_hrd_max_tid_flag=0;", "vps_id = gf_bs_read_int_log(bs, 4, \"vps_id\");", "if (vps_id >= 16) return -1;", "if (!vps_id) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] VPS ID 0 is forbidden\\n\"));", "return -1;", "}", "vps = &vvc->vps[vps_id];", "if (!vps->state) {", "vps->id = vps_id;", "vps->state = 1;", "}", "vps->max_layers = 1 + gf_bs_read_int_log(bs, 6, \"max_layers\");", "if (vps->max_layers > MAX_LHVC_LAYERS) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] sorry, %d layers in VPS but only %d supported\\n\", vps->max_layers, MAX_LHVC_LAYERS));", "return -1;", "}", "vps->max_sub_layers = gf_bs_read_int_log(bs, 3, \"max_sub_layers_minus1\") + 1;", "if ((vps->max_layers>1) && (vps->max_sub_layers>1))", "vps_default_ptl_dpb_hrd_max_tid_flag = gf_bs_read_int_log(bs, 1, \"vps_default_ptl_dpb_hrd_max_tid_flag\");", "if (vps->max_layers>1)", "vps->all_layers_independent = gf_bs_read_int_log(bs, 1, \"all_layers_independent\");", "for (i=0; i<vps->max_layers; i++) {", "u32 layer_id = gf_bs_read_int_log_idx(bs, 6, \"layer_id\", i);", "if (layer_id>vps->max_layer_id) vps->max_layer_id = layer_id;", "if (i && !vps->all_layers_independent) {", "Bool layer_indep = gf_bs_read_int_log_idx(bs, 1, \"layer_independent\", i);", "if (!layer_indep) {", "Bool vps_max_tid_ref_present_flag = gf_bs_read_int_log_idx(bs, 1, \"vps_max_tid_ref_present_flag\", i);", "for (j=0; j<i; j++) {", "Bool vps_direct_ref_layer_flag = gf_bs_read_int_log_idx2(bs, 1, \"vps_direct_ref_layer_flag\", i, j);", "if (vps_max_tid_ref_present_flag && vps_direct_ref_layer_flag) {", "gf_bs_read_int_log_idx2(bs, 3, \"vps_max_tid_il_ref_pics_plus1\", i, j);", "}", "}", "}", "}", "}", "vps->num_ptl = 1;", "if (vps->max_layers > 1) {", "if (vps->all_layers_independent) {", "vps->each_layer_is_ols = gf_bs_read_int_log(bs, 1, \"each_layer_is_ols\");", "}", "if (!vps->each_layer_is_ols) {", "u32 vps_ols_mode_idc = 2;", "if (!vps->all_layers_independent) {", "vps_ols_mode_idc = gf_bs_read_int_log(bs, 2, \"vps_ols_mode_idc\");", "}", "if (vps_ols_mode_idc==2) {", "u8 vps_num_output_layer_sets = 2 + gf_bs_read_int_log(bs, 8, \"vps_num_output_layer_sets_minus2\");", "for (i=0; i<vps_num_output_layer_sets; i++) {", "for (j=0; j<vps->max_layers; j++) {", "gf_bs_read_int_log_idx2(bs, 1, \"vps_ols_output_layer_flag\", i, j);", "}", "}", "}", "}", "vps->num_ptl = 1 + gf_bs_read_int_log(bs, 8, \"num_ptl_minus1\");", "}", "vps->ptl[0].pt_present = 1;", "for (i=0; i<vps->num_ptl; i++) {", "if (i)", "vps->ptl[i].pt_present = gf_bs_read_int_log_idx(bs, 1, \"pt_present\", i);", "if (!vps_default_ptl_dpb_hrd_max_tid_flag)", "vps->ptl[i].ptl_max_tid = gf_bs_read_int_log_idx(bs, 3, \"ptl_max_tid\", i);", "else", "vps->ptl[i].ptl_max_tid = vps->max_sub_layers - 1;;", "}", "gf_bs_align(bs);", "for (i=0; i<vps->num_ptl; i++) {", "vvc_profile_tier_level(bs, &vps->ptl[i], i);", "}", "return vps_id;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["s32 hevc_parse_slice_segment(GF_BitStream *bs, HEVCState *hevc, HEVCSliceInfo *si)", "{", "u32 i, j;", "u32 num_ref_idx_l0_active = 0, num_ref_idx_l1_active = 0;", "HEVC_PPS *pps;", "HEVC_SPS *sps;", "s32 pps_id;", "Bool RapPicFlag = GF_FALSE;", "Bool IDRPicFlag = GF_FALSE;", "si->first_slice_segment_in_pic_flag = gf_bs_read_int_log(bs, 1, \"first_slice_segment_in_pic_flag\");", "switch (si->nal_unit_type) {", "case GF_HEVC_NALU_SLICE_IDR_W_DLP:", "case GF_HEVC_NALU_SLICE_IDR_N_LP:", "IDRPicFlag = GF_TRUE;", "RapPicFlag = GF_TRUE;", "break;", "case GF_HEVC_NALU_SLICE_BLA_W_LP:", "case GF_HEVC_NALU_SLICE_BLA_W_DLP:", "case GF_HEVC_NALU_SLICE_BLA_N_LP:", "case GF_HEVC_NALU_SLICE_CRA:", "RapPicFlag = GF_TRUE;", "break;", "}", "if (RapPicFlag) {", "gf_bs_read_int_log(bs, 1, \"no_output_of_prior_pics_flag\");", "}", "pps_id = gf_bs_read_ue_log(bs, \"pps_id\");", "if (pps_id >= 64)", "return -1;", "pps = &hevc->pps[pps_id];", "sps = &hevc->sps[pps->sps_id];", "si->sps = sps;", "si->pps = pps;", "if (!si->first_slice_segment_in_pic_flag && pps->dependent_slice_segments_enabled_flag) {", "si->dependent_slice_segment_flag = gf_bs_read_int_log(bs, 1, \"dependent_slice_segment_flag\");", "}", "else {", "si->dependent_slice_segment_flag = GF_FALSE;", "}", "if (!si->first_slice_segment_in_pic_flag) {", "si->slice_segment_address = gf_bs_read_int_log(bs, sps->bitsSliceSegmentAddress, \"slice_segment_address\");", "}", "else {", "si->slice_segment_address = 0;", "}", "if (!si->dependent_slice_segment_flag) {", "Bool deblocking_filter_override_flag = 0;", "Bool slice_temporal_mvp_enabled_flag = 0;", "Bool slice_sao_luma_flag = 0;", "Bool slice_sao_chroma_flag = 0;", "Bool slice_deblocking_filter_disabled_flag = 0;", "gf_bs_read_int_log(bs, pps->num_extra_slice_header_bits, \"slice_reserved_undetermined_flag\");", "si->slice_type = gf_bs_read_ue_log(bs, \"slice_type\");", "if (pps->output_flag_present_flag)", "gf_bs_read_int_log(bs, 1, \"pic_output_flag\");", "if (sps->separate_colour_plane_flag == 1)", "gf_bs_read_int_log(bs, 2, \"colour_plane_id\");", "if (IDRPicFlag) {", "si->poc_lsb = 0;", "if (!hevc->full_slice_header_parse) return 0;", "}", "else {", "si->poc_lsb = gf_bs_read_int_log(bs, sps->log2_max_pic_order_cnt_lsb, \"poc_lsb\");", "if (!hevc->full_slice_header_parse) return 0;", "if (gf_bs_read_int_log(bs, 1, \"short_term_ref_pic_set_sps_flag\") == 0) {", "Bool ret = hevc_parse_short_term_ref_pic_set(bs, sps, sps->num_short_term_ref_pic_sets);", "if (!ret)", "return -1;", "}", "else if (sps->num_short_term_ref_pic_sets > 1) {", "u32 numbits = 0;", "while ((u32)(1 << numbits) < sps->num_short_term_ref_pic_sets)", "numbits++;", "if (numbits > 0)", "gf_bs_read_int_log(bs, numbits, \"short_term_ref_pic_set_idx\");", "}", "if (sps->long_term_ref_pics_present_flag) {", "u8 DeltaPocMsbCycleLt[32];", "u32 num_long_term_sps = 0;", "u32 num_long_term_pics = 0;", "memset(DeltaPocMsbCycleLt, 0, sizeof(u8) * 32);", "if (sps->num_long_term_ref_pic_sps > 0) {", "num_long_term_sps = gf_bs_read_ue_log(bs, \"num_long_term_sps\");", "}", "num_long_term_pics = gf_bs_read_ue_log(bs, \"num_long_term_pics\");", "for (i = 0; i < num_long_term_sps + num_long_term_pics; i++) {", "if (i < num_long_term_sps) {", "if (sps->num_long_term_ref_pic_sps > 1)", "gf_bs_read_int_log_idx(bs, gf_get_bit_size(sps->num_long_term_ref_pic_sps), \"lt_idx_sps\", i);", "}", "else {", "gf_bs_read_int_log_idx(bs, sps->log2_max_pic_order_cnt_lsb, \"PocLsbLt\", i);", "gf_bs_read_int_log_idx(bs, 1, \"UsedByCurrPicLt\", i);", "}", "if (gf_bs_read_int_log_idx(bs, 1, \"delta_poc_msb_present_flag\", i)) {", "if (i == 0 || i == num_long_term_sps)", "DeltaPocMsbCycleLt[i] = gf_bs_read_ue_log_idx(bs, \"DeltaPocMsbCycleLt\", i);", "else", "DeltaPocMsbCycleLt[i] = gf_bs_read_ue_log_idx(bs, \"DeltaPocMsbCycleLt\", i) + DeltaPocMsbCycleLt[i - 1];", "}", "}", "}", "if (sps->temporal_mvp_enable_flag)", "slice_temporal_mvp_enabled_flag = gf_bs_read_int_log(bs, 1, \"slice_temporal_mvp_enabled_flag\");", "}", "if (sps->sample_adaptive_offset_enabled_flag) {", "u32 ChromaArrayType = sps->separate_colour_plane_flag ? 0 : sps->chroma_format_idc;", "slice_sao_luma_flag = gf_bs_read_int_log(bs, 1, \"slice_sao_luma_flag\");", "if (ChromaArrayType != 0)", "slice_sao_chroma_flag = gf_bs_read_int_log(bs, 1, \"slice_sao_chroma_flag\");", "}", "if (si->slice_type == GF_HEVC_SLICE_TYPE_P || si->slice_type == GF_HEVC_SLICE_TYPE_B) {", "num_ref_idx_l0_active = pps->num_ref_idx_l0_default_active;", "num_ref_idx_l1_active = 0;", "if (si->slice_type == GF_HEVC_SLICE_TYPE_B)", "num_ref_idx_l1_active = pps->num_ref_idx_l1_default_active;", "if (gf_bs_read_int_log(bs, 1, \"num_ref_idx_active_override_flag\")) {", "num_ref_idx_l0_active = 1 + gf_bs_read_ue_log(bs, \"num_ref_idx_l0_active\");", "if (si->slice_type == GF_HEVC_SLICE_TYPE_B)", "num_ref_idx_l1_active = 1 + gf_bs_read_ue_log(bs, \"num_ref_idx_l1_active\");", "}", "if (pps->lists_modification_present_flag                                 ) {", "if (!ref_pic_lists_modification(bs, si->slice_type, num_ref_idx_l0_active, num_ref_idx_l1_active)) {", "GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[hevc] ref_pic_lists_modification( ) not implemented\\n\"));", "return -1;", "}", "}", "if (si->slice_type == GF_HEVC_SLICE_TYPE_B)", "gf_bs_read_int_log(bs, 1, \"mvd_l1_zero_flag\");", "if (pps->cabac_init_present_flag)", "gf_bs_read_int_log(bs, 1, \"cabac_init_flag\");", "if (slice_temporal_mvp_enabled_flag) {", "Bool collocated_from_l0_flag = 1;", "if (si->slice_type == GF_HEVC_SLICE_TYPE_B)", "collocated_from_l0_flag = gf_bs_read_int_log(bs, 1, \"collocated_from_l0_flag\");", "if ((collocated_from_l0_flag && (num_ref_idx_l0_active > 1))", "|| (!collocated_from_l0_flag && (num_ref_idx_l1_active > 1))", ") {", "gf_bs_read_ue_log(bs, \"collocated_ref_idx\");", "}", "}", "if ((pps->weighted_pred_flag && si->slice_type == GF_HEVC_SLICE_TYPE_P)", "|| (pps->weighted_bipred_flag && si->slice_type == GF_HEVC_SLICE_TYPE_B)", ") {", "hevc_pred_weight_table(bs, hevc, si, pps, sps, num_ref_idx_l0_active, num_ref_idx_l1_active);", "}", "gf_bs_read_ue_log(bs, \"five_minus_max_num_merge_cand\");", "}", "si->slice_qp_delta_start_bits = (s32) (gf_bs_get_position(bs) - 1) * 8 + gf_bs_get_bit_position(bs);", "si->slice_qp_delta = gf_bs_read_se_log(bs, \"slice_qp_delta\");", "if (pps->slice_chroma_qp_offsets_present_flag) {", "gf_bs_read_se_log(bs, \"slice_cb_qp_offset\");", "gf_bs_read_se_log(bs, \"slice_cr_qp_offset\");", "}", "if (pps->deblocking_filter_override_enabled_flag) {", "deblocking_filter_override_flag = gf_bs_read_int_log(bs, 1, \"deblocking_filter_override_flag\");", "}", "if (deblocking_filter_override_flag) {", "slice_deblocking_filter_disabled_flag = gf_bs_read_int_log(bs, 1, \"slice_deblocking_filter_disabled_flag\");", "if (!slice_deblocking_filter_disabled_flag) {", "gf_bs_read_se_log(bs, \"slice_beta_offset_div2\");", "gf_bs_read_se_log(bs, \"slice_tc_offset_div2\");", "}", "}", "if (pps->loop_filter_across_slices_enabled_flag", "&& (slice_sao_luma_flag || slice_sao_chroma_flag || !slice_deblocking_filter_disabled_flag)", ") {", "gf_bs_read_int_log(bs, 1, \"slice_loop_filter_across_slices_enabled_flag\");", "}", "}", "else {", "if (!hevc->full_slice_header_parse) return 0;", "}", "si->entry_point_start_bits = ((u32)gf_bs_get_position(bs) - 1) * 8 + gf_bs_get_bit_position(bs);", "if (pps->tiles_enabled_flag || pps->entropy_coding_sync_enabled_flag) {", "u32 num_entry_point_offsets = gf_bs_read_ue_log(bs, \"num_entry_point_offsets\");", "if (num_entry_point_offsets > 0) {", "u32 offset = gf_bs_read_ue_log(bs, \"offset\") + 1;", "u32 segments = offset >> 4;", "s32 remain = (offset & 15);", "for (i = 0; i < num_entry_point_offsets; i++) {", "for (j = 0; j < segments; j++) {", "gf_bs_read_int(bs, 16);", "}", "if (remain) {", "gf_bs_read_int(bs, remain);", "}", "}", "}", "}", "if (pps->slice_segment_header_extension_present_flag) {", "u32 size_ext = gf_bs_read_ue_log(bs, \"size_ext\");", "while (size_ext) {", "gf_bs_read_int(bs, 8);", "size_ext--;", "}", "}", "si->header_size_bits = (gf_bs_get_position(bs) - 1) * 8 + gf_bs_get_bit_position(bs);", "if (gf_bs_read_int_log(bs, 1, \"byte_align\") == 0) {", "GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"Error parsing slice header: byte_align not found at end of header !\\n\"));", "}", "gf_bs_align(bs);", "si->payload_start_offset = (s32)gf_bs_get_position(bs);", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void ServerFeature::collectOptions(std::shared_ptr<ProgramOptions> options) {", "options->addOption(\"--console\", \"start a JavaScript emergency console\",", "new BooleanParameter(&_console));", "options->addSection(\"server\", \"server features\");", "options->addOption(\"--server.rest-server\", \"start a rest-server\",", "new BooleanParameter(&_restServer),", "arangodb::options::makeDefaultFlags(arangodb::options::Flags::Hidden));", "options->addOption(\"--server.validate-utf8-strings\", \"perform UTF-8 string validation for incoming JSON and VelocyPack data\",", "new BooleanParameter(&_validateUtf8Strings),", "arangodb::options::makeDefaultFlags(arangodb::options::Flags::Hidden)).setIntroducedIn(30700);", "options->addOption(\"--javascript.script\", \"run scripts and exit\",", "new VectorParameter<StringParameter>(&_scripts));", "#if _WIN32", "options->addOption(\"--console.code-page\",", "\"Windows code page to use; defaults to UTF8\",", "new UInt16Parameter(&_codePage),", "arangodb::options::makeDefaultFlags(arangodb::options::Flags::Hidden));", "#endif", "options->addSection(\"vst\", \"VelocyStream protocol\", \"\", true, true);", "options->addObsoleteOption(\"--vst.maxsize\", \"maximal size (in bytes) \"", "\"for a VelocyPack chunk\", true);", "options->addObsoleteOption(", "\"--server.session-timeout\",", "\"timeout of web interface server sessions (in seconds)\", true);", "options->addSection(\"wal\", \"WAL of the MMFiles engine\", \"\", true, true);", "options->addObsoleteOption(\"--wal.allow-oversize-entries\",", "\"allow entries that are bigger than '--wal.logfile-size'\", false);", "options->addObsoleteOption(\"--wal.use-mlock\",", "\"mlock WAL logfiles in memory (may require elevated privileges or limits)\", false);", "options->addObsoleteOption(\"--wal.directory\", \"logfile directory\", true);", "options->addObsoleteOption(\"--wal.historic-logfiles\", \"maximum number of historic logfiles to keep after collection\", true);", "options->addObsoleteOption(\"--wal.ignore-logfile-errors\",", "\"ignore logfile errors. this will read recoverable data from corrupted logfiles but ignore any unrecoverable data\", false);", "options->addObsoleteOption(\"--wal.ignore-recovery-errors\", \"continue recovery even if re-applying operations fails\", false);", "options->addObsoleteOption(\"--wal.flush-timeout\", \"flush timeout (in milliseconds)\", true);", "options->addObsoleteOption(\"--wal.logfile-size\", \"size of each logfile (in bytes)\", true);", "options->addObsoleteOption(\"--wal.open-logfiles\", \"maximum number of parallel open logfiles\", true);", "options->addObsoleteOption(\"--wal.reserve-logfiles\", \"maximum number of reserve logfiles to maintain\", true);", "options->addObsoleteOption(\"--wal.slots\", \"number of logfile slots to use\", true);", "options->addObsoleteOption(\"--wal.sync-interval\", \"interval for automatic, non-requested disk syncs (in milliseconds)\", true);", "options->addObsoleteOption(\"--wal.throttle-when-pending\",", "\"throttle writes when at least this many operations are waiting for collection (set to 0 to deactivate write-throttling)\", true);", "options->addObsoleteOption(\"--wal.throttle-wait\", \"maximum wait time per operation when write-throttled (in milliseconds)\", true);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["GF_Err HintFile(GF_ISOFile *file, u32 MTUSize, u32 max_ptime, u32 rtp_rate, u32 base_flags, Bool copy_data, Bool interleave, Bool regular_iod, Bool single_group, Bool hint_no_offset)", "{", "GF_ESD *esd;", "GF_InitialObjectDescriptor *iod;", "u32 i, val, res, streamType;", "u32 sl_mode, prev_ocr, single_ocr, nb_done, tot_bw, bw, flags, spec_type;", "GF_Err e;", "char szPayload[30];", "GF_RTPHinter *hinter;", "Bool copy, has_iod, single_av;", "u8 init_payt = BASE_PAYT;", "u32 mtype;", "GF_SDP_IODProfile iod_mode = GF_SDP_IOD_NONE;", "u32 media_group = 0;", "u8 media_prio = 0;", "tot_bw = 0;", "prev_ocr = 0;", "single_ocr = 1;", "has_iod = 1;", "iod = (GF_InitialObjectDescriptor *) gf_isom_get_root_od(file);", "if (!iod) has_iod = 0;", "else {", "if (!gf_list_count(iod->ESDescriptors)) has_iod = 0;", "gf_odf_desc_del((GF_Descriptor *) iod);", "}", "spec_type = gf_isom_guess_specification(file);", "single_av = single_group ? 1 : gf_isom_is_single_av(file);", "for (i=0; i<gf_isom_get_track_count(file); i++) {", "res = gf_isom_get_media_type(file, i+1);", "if ((res==GF_ISOM_MEDIA_SCENE) || (res==GF_ISOM_MEDIA_OD)) {", "if (gf_isom_is_track_in_root_od(file, i+1)) {", "gf_isom_set_default_sync_track(file, i+1);", "break;", "}", "}", "}", "nb_done = 0;", "for (i=0; i<gf_isom_get_track_count(file); i++) {", "sl_mode = base_flags;", "copy = copy_data;", "if (!gf_isom_get_sample_count(file, i+1)) continue;", "if (!gf_isom_is_track_enabled(file, i+1)) {", "M4_LOG(GF_LOG_INFO, (\"Track ID %d disabled - skipping hint\\n\", gf_isom_get_track_id(file, i+1) ));", "continue;", "}", "mtype = gf_isom_get_media_type(file, i+1);", "switch (mtype) {", "case GF_ISOM_MEDIA_VISUAL:", "if (single_av) {", "media_group = 2;", "media_prio = 2;", "}", "break;", "case GF_ISOM_MEDIA_AUXV:", "if (single_av) {", "media_group = 2;", "media_prio = 3;", "}", "break;", "case GF_ISOM_MEDIA_PICT:", "if (single_av) {", "media_group = 2;", "media_prio = 4;", "}", "break;", "case GF_ISOM_MEDIA_AUDIO:", "if (single_av) {", "media_group = 2;", "media_prio = 1;", "}", "break;", "case GF_ISOM_MEDIA_HINT:", "continue;", "default:", "if (spec_type==GF_ISOM_BRAND_ISMA) continue;", "}", "mtype = gf_isom_get_media_subtype(file, i+1, 1);", "if ((mtype==GF_ISOM_SUBTYPE_MPEG4) || (mtype==GF_ISOM_SUBTYPE_MPEG4_CRYP) ) mtype = gf_isom_get_mpeg4_subtype(file, i+1, 1);", "if (!single_av) {", "media_group ++;", "media_prio = 1;", "}", "streamType = 0;", "esd = gf_isom_get_esd(file, i+1, 1);", "if (esd) {", "streamType = esd->decoderConfig->streamType;", "if (!prev_ocr) {", "prev_ocr = esd->OCRESID;", "if (!esd->OCRESID) prev_ocr = esd->ESID;", "} else if (esd->OCRESID && prev_ocr != esd->OCRESID) {", "single_ocr = 0;", "}", "if (streamType==1) copy = 1;", "}", "gf_odf_desc_del((GF_Descriptor *) esd);", "if (!regular_iod && gf_isom_is_track_in_root_od(file, i+1)) {", "if (gf_isom_get_sample_count(file, i+1)==1) {", "GF_ISOSample *samp = gf_isom_get_sample(file, i+1, 1, &val);", "if (streamType) {", "res = gf_hinter_can_embbed_data(samp->data, samp->dataLength, streamType);", "} else {", "res = 0;", "}", "if (samp) gf_isom_sample_del(&samp);", "if (res) continue;", "}", "}", "if (interleave) sl_mode |= GP_RTP_PCK_USE_INTERLEAVING;", "hinter = gf_hinter_track_new(file, i+1, MTUSize, max_ptime, rtp_rate, sl_mode, init_payt, copy, media_group, media_prio, &e);", "if (!hinter) {", "if (e) {", "M4_LOG(nb_done ? GF_LOG_WARNING : GF_LOG_ERROR, (\"Cannot create hinter (%s)\\n\", gf_error_to_string(e) ));", "if (!nb_done) return e;", "}", "continue;", "}", "if (hint_no_offset)", "gf_hinter_track_force_no_offsets(hinter);", "bw = gf_hinter_track_get_bandwidth(hinter);", "tot_bw += bw;", "flags = gf_hinter_track_get_flags(hinter);", "gf_isom_set_nalu_extract_mode(file, i+1, GF_ISOM_NALU_EXTRACT_LAYER_ONLY);", "gf_hinter_track_get_payload_name(hinter, szPayload);", "M4_LOG(GF_LOG_INFO, (\"Hinting track ID %d - Type \\\"%s:%s\\\" (%s) - BW %d kbps\\n\", gf_isom_get_track_id(file, i+1), gf_4cc_to_str(mtype), gf_4cc_to_str(mtype), szPayload, bw));", "if (flags & GP_RTP_PCK_SYSTEMS_CAROUSEL) M4_LOG(GF_LOG_INFO, (\"\\tMPEG-4 Systems stream carousel enabled\\n\"));", "e = gf_hinter_track_process(hinter);", "if (!e) e = gf_hinter_track_finalize(hinter, has_iod);", "gf_hinter_track_del(hinter);", "if (e) {", "M4_LOG(GF_LOG_ERROR, (\"Error while hinting (%s)\\n\", gf_error_to_string(e)));", "if (!nb_done) return e;", "}", "init_payt++;", "nb_done ++;", "}", "if (has_iod) {", "iod_mode = GF_SDP_IOD_ISMA;", "if (regular_iod) iod_mode = GF_SDP_IOD_REGULAR;", "} else {", "iod_mode = GF_SDP_IOD_NONE;", "}", "gf_hinter_finalize(file, iod_mode, tot_bw);", "if (!single_ocr)", "M4_LOG(GF_LOG_WARNING, (\"Warning: at least 2 timelines found in the file\\nThis may not be supported by servers/players\\n\\n\"));", "return GF_OK;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["int secure_check(void *data)", "{", "const at91_secure_header_t *header;", "void *file;", "if (secure_decrypt(data, sizeof(*header), 0))", "return -1;", "header = (const at91_secure_header_t *)data;", "if (header->magic != AT91_SECURE_MAGIC)", "return -1;", "file = (unsigned char *)data + sizeof(*header);", "return secure_decrypt(file, header->file_size, 1);", "}"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0]}
{"tokens": ["fetch_token(OnigToken* tok, UChar** src, UChar* end, ScanEnv* env)", "{", "int r, num;", "OnigCodePoint c;", "OnigEncoding enc = env->enc;", "OnigSyntaxType* syn = env->syntax;", "UChar* prev;", "UChar* p = *src;", "PFETCH_READY;", "start:", "if (PEND) {", "tok->type = TK_EOT;", "return tok->type;", "}", "tok->type  = TK_STRING;", "tok->base  = 0;", "tok->backp = p;", "PFETCH(c);", "if (IS_MC_ESC_CODE(c, syn)) {", "if (PEND) return ONIGERR_END_PATTERN_AT_ESCAPE;", "tok->backp = p;", "PFETCH(c);", "tok->u.c = c;", "tok->escaped = 1;", "switch (c) {", "case '*':", "if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_ASTERISK_ZERO_INF)) break;", "tok->type = TK_OP_REPEAT;", "tok->u.repeat.lower = 0;", "tok->u.repeat.upper = REPEAT_INFINITE;", "goto greedy_check;", "break;", "case '+':", "if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_PLUS_ONE_INF)) break;", "tok->type = TK_OP_REPEAT;", "tok->u.repeat.lower = 1;", "tok->u.repeat.upper = REPEAT_INFINITE;", "goto greedy_check;", "break;", "case '?':", "if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_QMARK_ZERO_ONE)) break;", "tok->type = TK_OP_REPEAT;", "tok->u.repeat.lower = 0;", "tok->u.repeat.upper = 1;", "greedy_check:", "if (!PEND && PPEEK_IS('?') &&", "IS_SYNTAX_OP(syn, ONIG_SYN_OP_QMARK_NON_GREEDY)) {", "PFETCH(c);", "tok->u.repeat.greedy     = 0;", "tok->u.repeat.possessive = 0;", "}", "else {", "possessive_check:", "if (!PEND && PPEEK_IS('+') &&", "((IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_PLUS_POSSESSIVE_REPEAT) &&", "tok->type != TK_INTERVAL)  ||", "(IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_PLUS_POSSESSIVE_INTERVAL) &&", "tok->type == TK_INTERVAL))) {", "PFETCH(c);", "tok->u.repeat.greedy     = 1;", "tok->u.repeat.possessive = 1;", "}", "else {", "tok->u.repeat.greedy     = 1;", "tok->u.repeat.possessive = 0;", "}", "}", "break;", "case '{':", "if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_BRACE_INTERVAL)) break;", "r = fetch_range_quantifier(&p, end, tok, env);", "if (r < 0) return r;", "if (r == 0) goto greedy_check;", "else if (r == 2) {", "if (IS_SYNTAX_BV(syn, ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY))", "goto possessive_check;", "goto greedy_check;", "}", "break;", "case '|':", "if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_VBAR_ALT)) break;", "tok->type = TK_ALT;", "break;", "case '(':", "if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LPAREN_SUBEXP)) break;", "tok->type = TK_SUBEXP_OPEN;", "break;", "case ')':", "if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LPAREN_SUBEXP)) break;", "tok->type = TK_SUBEXP_CLOSE;", "break;", "case 'w':", "if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_W_WORD)) break;", "tok->type = TK_CHAR_TYPE;", "tok->u.prop.ctype = ONIGENC_CTYPE_WORD;", "tok->u.prop.not   = 0;", "break;", "case 'W':", "if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_W_WORD)) break;", "tok->type = TK_CHAR_TYPE;", "tok->u.prop.ctype = ONIGENC_CTYPE_WORD;", "tok->u.prop.not   = 1;", "break;", "case 'b':", "if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_B_WORD_BOUND)) break;", "tok->type = TK_ANCHOR;", "tok->u.anchor = ANCHOR_WORD_BOUND;", "break;", "case 'B':", "if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_B_WORD_BOUND)) break;", "tok->type = TK_ANCHOR;", "tok->u.anchor = ANCHOR_NOT_WORD_BOUND;", "break;", "#ifdef USE_WORD_BEGIN_END", "case '<':", "if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END)) break;", "tok->type = TK_ANCHOR;", "tok->u.anchor = ANCHOR_WORD_BEGIN;", "break;", "case '>':", "if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END)) break;", "tok->type = TK_ANCHOR;", "tok->u.anchor = ANCHOR_WORD_END;", "break;", "#endif", "case 's':", "if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_S_WHITE_SPACE)) break;", "tok->type = TK_CHAR_TYPE;", "tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;", "tok->u.prop.not   = 0;", "break;", "case 'S':", "if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_S_WHITE_SPACE)) break;", "tok->type = TK_CHAR_TYPE;", "tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;", "tok->u.prop.not   = 1;", "break;", "case 'd':", "if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_D_DIGIT)) break;", "tok->type = TK_CHAR_TYPE;", "tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;", "tok->u.prop.not   = 0;", "break;", "case 'D':", "if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_D_DIGIT)) break;", "tok->type = TK_CHAR_TYPE;", "tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;", "tok->u.prop.not   = 1;", "break;", "case 'h':", "if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;", "tok->type = TK_CHAR_TYPE;", "tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;", "tok->u.prop.not   = 0;", "break;", "case 'H':", "if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;", "tok->type = TK_CHAR_TYPE;", "tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;", "tok->u.prop.not   = 1;", "break;", "case 'A':", "if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR)) break;", "begin_buf:", "tok->type = TK_ANCHOR;", "tok->u.subtype = ANCHOR_BEGIN_BUF;", "break;", "case 'Z':", "if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR)) break;", "tok->type = TK_ANCHOR;", "tok->u.subtype = ANCHOR_SEMI_END_BUF;", "break;", "case 'z':", "if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR)) break;", "end_buf:", "tok->type = TK_ANCHOR;", "tok->u.subtype = ANCHOR_END_BUF;", "break;", "case 'G':", "if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_CAPITAL_G_BEGIN_ANCHOR)) break;", "tok->type = TK_ANCHOR;", "tok->u.subtype = ANCHOR_BEGIN_POSITION;", "break;", "case '`':", "if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR)) break;", "goto begin_buf;", "break;", "case '\\'':", "if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR)) break;", "goto end_buf;", "break;", "case 'x':", "if (PEND) break;", "prev = p;", "if (PPEEK_IS('{') && IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_BRACE_HEX8)) {", "PINC;", "num = scan_unsigned_hexadecimal_number(&p, end, 8, enc);", "if (num < 0) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;", "if (!PEND) {", "if (ONIGENC_IS_CODE_XDIGIT(enc, PPEEK))", "return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE;", "}", "if ((p > prev + enclen(enc, prev)) && !PEND && PPEEK_IS('}')) {", "PINC;", "tok->type   = TK_CODE_POINT;", "tok->u.code = (OnigCodePoint )num;", "}", "else {", "p = prev;", "}", "}", "else if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_HEX2)) {", "num = scan_unsigned_hexadecimal_number(&p, end, 2, enc);", "if (num < 0) return ONIGERR_TOO_BIG_NUMBER;", "if (p == prev) {", "num = 0;", "}", "tok->type = TK_RAW_BYTE;", "tok->base = 16;", "tok->u.c  = num;", "}", "break;", "case 'u':", "if (PEND) break;", "prev = p;", "if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_U_HEX4)) {", "num = scan_unsigned_hexadecimal_number(&p, end, 4, enc);", "if (num < 0) return ONIGERR_TOO_BIG_NUMBER;", "if (p == prev) {", "num = 0;", "}", "tok->type   = TK_CODE_POINT;", "tok->base   = 16;", "tok->u.code = (OnigCodePoint )num;", "}", "break;", "case '1': case '2': case '3': case '4':", "case '5': case '6': case '7': case '8': case '9':", "PUNFETCH;", "prev = p;", "num = onig_scan_unsigned_number(&p, end, enc);", "if (num < 0 || num > ONIG_MAX_BACKREF_NUM) {", "goto skip_backref;", "}", "if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_DECIMAL_BACKREF) &&", "(num <= env->num_mem || num <= 9)) {", "if (IS_SYNTAX_BV(syn, ONIG_SYN_STRICT_CHECK_BACKREF)) {", "if (num > env->num_mem || IS_NULL(SCANENV_MEM_NODES(env)[num]))", "return ONIGERR_INVALID_BACKREF;", "}", "tok->type = TK_BACKREF;", "tok->u.backref.num     = 1;", "tok->u.backref.ref1    = num;", "tok->u.backref.by_name = 0;", "#ifdef USE_BACKREF_WITH_LEVEL", "tok->u.backref.exist_level = 0;", "#endif", "break;", "}", "skip_backref:", "if (c == '8' || c == '9') {", "p = prev; PINC;", "break;", "}", "p = prev;", "case '0':", "if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_OCTAL3)) {", "prev = p;", "num = scan_unsigned_octal_number(&p, end, (c == '0' ? 2:3), enc);", "if (num < 0) return ONIGERR_TOO_BIG_NUMBER;", "if (p == prev) {", "num = 0;", "}", "tok->type = TK_RAW_BYTE;", "tok->base = 8;", "tok->u.c  = num;", "}", "else if (c != '0') {", "PINC;", "}", "break;", "#ifdef USE_NAMED_GROUP", "case 'k':", "if (!PEND && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_K_NAMED_BACKREF)) {", "PFETCH(c);", "if (c == '<' || c == '\\'') {", "UChar* name_end;", "int* backs;", "int back_num;", "prev = p;", "#ifdef USE_BACKREF_WITH_LEVEL", "name_end = NULL_UCHARP;", "r = fetch_name_with_level((OnigCodePoint )c, &p, end, &name_end,", "env, &back_num, &tok->u.backref.level);", "if (r == 1) tok->u.backref.exist_level = 1;", "else        tok->u.backref.exist_level = 0;", "#else", "r = fetch_name(&p, end, &name_end, env, &back_num, 1);", "#endif", "if (r < 0) return r;", "if (back_num != 0) {", "if (back_num < 0) {", "back_num = BACKREF_REL_TO_ABS(back_num, env);", "if (back_num <= 0)", "return ONIGERR_INVALID_BACKREF;", "}", "if (IS_SYNTAX_BV(syn, ONIG_SYN_STRICT_CHECK_BACKREF)) {", "if (back_num > env->num_mem ||", "IS_NULL(SCANENV_MEM_NODES(env)[back_num]))", "return ONIGERR_INVALID_BACKREF;", "}", "tok->type = TK_BACKREF;", "tok->u.backref.by_name = 0;", "tok->u.backref.num  = 1;", "tok->u.backref.ref1 = back_num;", "}", "else {", "num = onig_name_to_group_numbers(env->reg, prev, name_end, &backs);", "if (num <= 0) {", "onig_scan_env_set_error_string(env,", "ONIGERR_UNDEFINED_NAME_REFERENCE, prev, name_end);", "return ONIGERR_UNDEFINED_NAME_REFERENCE;", "}", "if (IS_SYNTAX_BV(syn, ONIG_SYN_STRICT_CHECK_BACKREF)) {", "int i;", "for (i = 0; i < num; i++) {", "if (backs[i] > env->num_mem ||", "IS_NULL(SCANENV_MEM_NODES(env)[backs[i]]))", "return ONIGERR_INVALID_BACKREF;", "}", "}", "tok->type = TK_BACKREF;", "tok->u.backref.by_name = 1;", "if (num == 1) {", "tok->u.backref.num  = 1;", "tok->u.backref.ref1 = backs[0];", "}", "else {", "tok->u.backref.num  = num;", "tok->u.backref.refs = backs;", "}", "}", "}", "else", "PUNFETCH;", "}", "break;", "#endif", "#ifdef USE_SUBEXP_CALL", "case 'g':", "if (!PEND && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_G_SUBEXP_CALL)) {", "PFETCH(c);", "if (c == '<' || c == '\\'') {", "int gnum;", "UChar* name_end;", "prev = p;", "r = fetch_name((OnigCodePoint )c, &p, end, &name_end, env, &gnum, 1);", "if (r < 0) return r;", "tok->type = TK_CALL;", "tok->u.call.name     = prev;", "tok->u.call.name_end = name_end;", "tok->u.call.gnum     = gnum;", "}", "else", "PUNFETCH;", "}", "break;", "#endif", "case 'Q':", "if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_CAPITAL_Q_QUOTE)) {", "tok->type = TK_QUOTE_OPEN;", "}", "break;", "case 'p':", "case 'P':", "if (!PEND && PPEEK_IS('{') &&", "IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY)) {", "PINC;", "tok->type = TK_CHAR_PROPERTY;", "tok->u.prop.not = (c == 'P' ? 1 : 0);", "if (!PEND &&", "IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT)) {", "PFETCH(c);", "if (c == '^') {", "tok->u.prop.not = (tok->u.prop.not == 0 ? 1 : 0);", "}", "else", "PUNFETCH;", "}", "}", "break;", "default:", "{", "OnigCodePoint c2;", "PUNFETCH;", "num = fetch_escaped_value(&p, end, env, &c2);", "if (num < 0) return num;", "if (tok->u.c != c2) {", "tok->type = TK_CODE_POINT;", "tok->u.code = c2;", "}", "else {", "p = tok->backp + enclen(enc, tok->backp);", "}", "}", "break;", "}", "}", "else {", "tok->u.c = c;", "tok->escaped = 0;", "#ifdef USE_VARIABLE_META_CHARS", "if ((c != ONIG_INEFFECTIVE_META_CHAR) &&", "IS_SYNTAX_OP(syn, ONIG_SYN_OP_VARIABLE_META_CHARACTERS)) {", "if (c == MC_ANYCHAR(syn))", "goto any_char;", "else if (c == MC_ANYTIME(syn))", "goto anytime;", "else if (c == MC_ZERO_OR_ONE_TIME(syn))", "goto zero_or_one_time;", "else if (c == MC_ONE_OR_MORE_TIME(syn))", "goto one_or_more_time;", "else if (c == MC_ANYCHAR_ANYTIME(syn)) {", "tok->type = TK_ANYCHAR_ANYTIME;", "goto out;", "}", "}", "#endif", "switch (c) {", "case '.':", "if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_DOT_ANYCHAR)) break;", "#ifdef USE_VARIABLE_META_CHARS", "any_char:", "#endif", "tok->type = TK_ANYCHAR;", "break;", "case '*':", "if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ASTERISK_ZERO_INF)) break;", "#ifdef USE_VARIABLE_META_CHARS", "anytime:", "#endif", "tok->type = TK_OP_REPEAT;", "tok->u.repeat.lower = 0;", "tok->u.repeat.upper = REPEAT_INFINITE;", "goto greedy_check;", "break;", "case '+':", "if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_PLUS_ONE_INF)) break;", "#ifdef USE_VARIABLE_META_CHARS", "one_or_more_time:", "#endif", "tok->type = TK_OP_REPEAT;", "tok->u.repeat.lower = 1;", "tok->u.repeat.upper = REPEAT_INFINITE;", "goto greedy_check;", "break;", "case '?':", "if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_QMARK_ZERO_ONE)) break;", "#ifdef USE_VARIABLE_META_CHARS", "zero_or_one_time:", "#endif", "tok->type = TK_OP_REPEAT;", "tok->u.repeat.lower = 0;", "tok->u.repeat.upper = 1;", "goto greedy_check;", "break;", "case '{':", "if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_BRACE_INTERVAL)) break;", "r = fetch_range_quantifier(&p, end, tok, env);", "if (r < 0) return r;", "if (r == 0) goto greedy_check;", "else if (r == 2) {", "if (IS_SYNTAX_BV(syn, ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY))", "goto possessive_check;", "goto greedy_check;", "}", "break;", "case '|':", "if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_VBAR_ALT)) break;", "tok->type = TK_ALT;", "break;", "case '(':", "if (!PEND && PPEEK_IS('?') &&", "IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_QMARK_GROUP_EFFECT)) {", "PINC;", "if (!PEND && PPEEK_IS('#')) {", "PFETCH(c);", "while (1) {", "if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;", "PFETCH(c);", "if (c == MC_ESC(syn)) {", "if (!PEND) PFETCH(c);", "}", "else {", "if (c == ')') break;", "}", "}", "goto start;", "}", "PUNFETCH;", "}", "if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LPAREN_SUBEXP)) break;", "tok->type = TK_SUBEXP_OPEN;", "break;", "case ')':", "if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LPAREN_SUBEXP)) break;", "tok->type = TK_SUBEXP_CLOSE;", "break;", "case '^':", "if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LINE_ANCHOR)) break;", "tok->type = TK_ANCHOR;", "tok->u.subtype = (IS_SINGLELINE(env->option)", "? ANCHOR_BEGIN_BUF : ANCHOR_BEGIN_LINE);", "break;", "case '$':", "if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LINE_ANCHOR)) break;", "tok->type = TK_ANCHOR;", "tok->u.subtype = (IS_SINGLELINE(env->option)", "? ANCHOR_SEMI_END_BUF : ANCHOR_END_LINE);", "break;", "case '[':", "if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_BRACKET_CC)) break;", "tok->type = TK_CC_OPEN;", "break;", "case ']':", "if (*src > env->pattern)", "CLOSE_BRACKET_WITHOUT_ESC_WARN(env, (UChar* )\"]\");", "break;", "case '#':", "if (IS_EXTEND(env->option)) {", "while (!PEND) {", "PFETCH(c);", "if (ONIGENC_IS_CODE_NEWLINE(enc, c))", "break;", "}", "goto start;", "break;", "}", "break;", "case ' ': case '\\t': case '\\n': case '\\r': case '\\f':", "if (IS_EXTEND(env->option))", "goto start;", "break;", "default:", "break;", "}", "}", "#ifdef USE_VARIABLE_META_CHARS", "out:", "#endif", "*src = p;", "return tok->type;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["future<fragmented_temporary_buffer> cql_server::connection::read_and_decompress_frame(size_t length, uint8_t flags)", "{", "using namespace compression_buffers;", "if (flags & cql_frame_flags::compression) {", "if (_compression == cql_compression::lz4) {", "if (length < 4) {", "throw std::runtime_error(fmt::format(\"CQL frame truncated: expected to have at least 4 bytes, got {}\", length));", "}", "return _buffer_reader.read_exactly(_read_buf, length).then([this] (fragmented_temporary_buffer buf) {", "auto linearization_buffer = bytes_ostream();", "int32_t uncomp_len = request_reader(buf.get_istream(), linearization_buffer).read_int();", "if (uncomp_len < 0) {", "throw std::runtime_error(\"CQL frame uncompressed length is negative: \" + std::to_string(uncomp_len));", "}", "buf.remove_prefix(4);", "auto in = input_buffer.get_linearized_view(fragmented_temporary_buffer::view(buf));", "auto uncomp = output_buffer.make_fragmented_temporary_buffer(uncomp_len, fragmented_temporary_buffer::default_fragment_size, [&] (bytes_mutable_view out) {", "auto ret = LZ4_decompress_safe(reinterpret_cast<const char*>(in.data()), reinterpret_cast<char*>(out.data()),", "in.size(), out.size());", "if (ret < 0) {", "throw std::runtime_error(\"CQL frame LZ4 uncompression failure\");", "}", "return out.size();", "});", "on_compression_buffer_use();", "return uncomp;", "});", "} else if (_compression == cql_compression::snappy) {", "return _buffer_reader.read_exactly(_read_buf, length).then([this] (fragmented_temporary_buffer buf) {", "auto in = input_buffer.get_linearized_view(fragmented_temporary_buffer::view(buf));", "size_t uncomp_len;", "if (snappy_uncompressed_length(reinterpret_cast<const char*>(in.data()), in.size(), &uncomp_len) != SNAPPY_OK) {", "throw std::runtime_error(\"CQL frame Snappy uncompressed size is unknown\");", "}", "auto uncomp = output_buffer.make_fragmented_temporary_buffer(uncomp_len, fragmented_temporary_buffer::default_fragment_size, [&] (bytes_mutable_view out) {", "size_t output_len = out.size();", "if (snappy_uncompress(reinterpret_cast<const char*>(in.data()), in.size(), reinterpret_cast<char*>(out.data()), &output_len) != SNAPPY_OK) {", "throw std::runtime_error(\"CQL frame Snappy uncompression failure\");", "}", "return output_len;", "});", "on_compression_buffer_use();", "return uncomp;", "});", "} else {", "throw exceptions::protocol_exception(format(\"Unknown compression algorithm\"));", "}", "}", "return _buffer_reader.read_exactly(_read_buf, length);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["GF_Err abst_box_read(GF_Box *s, GF_BitStream *bs)", "{", "GF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;", "int i;", "u32 tmp_strsize;", "char *tmp_str;", "GF_Err e;", "ISOM_DECREASE_SIZE(ptr, 25)", "ptr->bootstrapinfo_version = gf_bs_read_u32(bs);", "ptr->profile = gf_bs_read_int(bs, 2);", "ptr->live = gf_bs_read_int(bs, 1);", "ptr->update = gf_bs_read_int(bs, 1);", "ptr->reserved = gf_bs_read_int(bs, 4);", "ptr->time_scale = gf_bs_read_u32(bs);", "ptr->current_media_time = gf_bs_read_u64(bs);", "ptr->smpte_time_code_offset = gf_bs_read_u64(bs);", "i=0;", "if (ptr->size<8) return GF_ISOM_INVALID_FILE;", "tmp_strsize =(u32)ptr->size-8;", "tmp_str = gf_malloc(sizeof(char)*tmp_strsize);", "if (!tmp_str) return GF_OUT_OF_MEM;", "memset(tmp_str, 0, sizeof(char)*tmp_strsize);", "while (tmp_strsize) {", "tmp_str[i] = gf_bs_read_u8(bs);", "tmp_strsize--;", "if (!tmp_str[i])", "break;", "i++;", "}", "if (i) {", "ptr->movie_identifier = gf_strdup(tmp_str);", "}", "ptr->server_entry_count = gf_bs_read_u8(bs);", "for (i=0; i<ptr->server_entry_count; i++) {", "int j=0;", "tmp_strsize=(u32)ptr->size-8;", "while (tmp_strsize) {", "tmp_str[j] = gf_bs_read_u8(bs);", "tmp_strsize--;", "if (!tmp_str[j])", "break;", "j++;", "}", "if (j) {", "gf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);", "}", "}", "ptr->quality_entry_count = gf_bs_read_u8(bs);", "for (i=0; i<ptr->quality_entry_count; i++) {", "int j=0;", "tmp_strsize=(u32)ptr->size-8;", "while (tmp_strsize) {", "tmp_str[j] = gf_bs_read_u8(bs);", "tmp_strsize--;", "if (!tmp_str[j])", "break;", "j++;", "}", "if (j) {", "gf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);", "}", "}", "i=0;", "tmp_strsize=(u32)ptr->size-8;", "while (tmp_strsize) {", "tmp_str[i] = gf_bs_read_u8(bs);", "tmp_strsize--;", "if (!tmp_str[i])", "break;", "i++;", "}", "if (i) {", "ptr->drm_data = gf_strdup(tmp_str);", "}", "i=0;", "tmp_strsize=(u32)ptr->size-8;", "while (tmp_strsize) {", "tmp_str[i] = gf_bs_read_u8(bs);", "tmp_strsize--;", "if (!tmp_str[i])", "break;", "i++;", "}", "if (i) {", "ptr->meta_data = gf_strdup(tmp_str);", "}", "ptr->segment_run_table_count = gf_bs_read_u8(bs);", "for (i=0; i<ptr->segment_run_table_count; i++) {", "GF_AdobeSegmentRunTableBox *asrt = NULL;", "e = gf_isom_box_parse((GF_Box **)&asrt, bs);", "if (e) {", "if (asrt) gf_isom_box_del((GF_Box*)asrt);", "gf_free(tmp_str);", "return e;", "}", "gf_list_add(ptr->segment_run_table_entries, asrt);", "}", "ptr->fragment_run_table_count = gf_bs_read_u8(bs);", "for (i=0; i<ptr->fragment_run_table_count; i++) {", "GF_AdobeFragmentRunTableBox *afrt = NULL;", "e = gf_isom_box_parse((GF_Box **)&afrt, bs);", "if (e) {", "if (afrt) gf_isom_box_del((GF_Box*)afrt);", "gf_free(tmp_str);", "return e;", "}", "gf_list_add(ptr->fragment_run_table_entries, afrt);", "}", "gf_free(tmp_str);", "return GF_OK;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["GF_Err stbl_AppendSize(GF_SampleTableBox *stbl, u32 size, u32 nb_pack)", "{", "u32 i;", "if (!nb_pack) nb_pack = 1;", "if (!stbl->SampleSize->sampleCount) {", "stbl->SampleSize->sampleSize = size;", "stbl->SampleSize->sampleCount += nb_pack;", "return GF_OK;", "}", "if (stbl->SampleSize->sampleSize && (stbl->SampleSize->sampleSize==size)) {", "stbl->SampleSize->sampleCount += nb_pack;", "return GF_OK;", "}", "if (!stbl->SampleSize->sizes || (stbl->SampleSize->sampleCount+nb_pack > stbl->SampleSize->alloc_size)) {", "Bool init_table = (stbl->SampleSize->sizes==NULL) ? 1 : 0;", "ALLOC_INC(stbl->SampleSize->alloc_size);", "if (stbl->SampleSize->sampleCount+nb_pack > stbl->SampleSize->alloc_size)", "stbl->SampleSize->alloc_size = stbl->SampleSize->sampleCount+nb_pack;", "stbl->SampleSize->sizes = (u32 *)gf_realloc(stbl->SampleSize->sizes, sizeof(u32)*stbl->SampleSize->alloc_size);", "if (!stbl->SampleSize->sizes) return GF_OUT_OF_MEM;", "memset(&stbl->SampleSize->sizes[stbl->SampleSize->sampleCount], 0, sizeof(u32) * (stbl->SampleSize->alloc_size - stbl->SampleSize->sampleCount) );", "if (init_table) {", "for (i=0; i<stbl->SampleSize->sampleCount; i++)", "stbl->SampleSize->sizes[i] = stbl->SampleSize->sampleSize;", "}", "}", "stbl->SampleSize->sampleSize = 0;", "for (i=0; i<nb_pack; i++) {", "stbl->SampleSize->sizes[stbl->SampleSize->sampleCount+i] = size;", "}", "stbl->SampleSize->sampleCount += nb_pack;", "if (size > stbl->SampleSize->max_size)", "stbl->SampleSize->max_size = size;", "stbl->SampleSize->total_size += size;", "stbl->SampleSize->total_samples += nb_pack;", "return GF_OK;", "}"], "ner_tags": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["PackLinuxElf32::invert_pt_dynamic(Elf32_Dyn const *dynp)", "{", "if (dt_table[Elf32_Dyn::DT_NULL]) {", "return;", "}", "Elf32_Dyn const *const dynp0 = dynp;", "unsigned ndx = 1+ 0;", "if (dynp)", "for (; ; ++ndx, ++dynp) {", "unsigned const d_tag = get_te32(&dynp->d_tag);", "if (d_tag < DT_NUM) {", "if (Elf32_Dyn::DT_NEEDED != d_tag", "&&  dt_table[d_tag]", "&&    get_te32(&dynp->d_val)", "!= get_te32(&dynp0[-1+ dt_table[d_tag]].d_val)) {", "char msg[50]; snprintf(msg, sizeof(msg),", "\"duplicate DT_%#x: [%#x] [%#x]\",", "d_tag, -1+ dt_table[d_tag], -1+ ndx);", "throwCantPack(msg);", "}", "dt_table[d_tag] = ndx;", "}", "if (Elf32_Dyn::DT_NULL == d_tag) {", "break;", "}", "}", "upx_dt_init = 0;", "if (dt_table[Elf32_Dyn::DT_INIT])          upx_dt_init = Elf32_Dyn::DT_INIT;", "else if (dt_table[Elf32_Dyn::DT_PREINIT_ARRAY]) upx_dt_init = Elf32_Dyn::DT_PREINIT_ARRAY;", "else if (dt_table[Elf32_Dyn::DT_INIT_ARRAY])    upx_dt_init = Elf32_Dyn::DT_INIT_ARRAY;", "unsigned const z_str = dt_table[Elf32_Dyn::DT_STRSZ];", "if (z_str) {", "strtab_end = get_te32(&dynp0[-1+ z_str].d_val);", "if ((u32_t)file_size <= strtab_end) {", "char msg[50]; snprintf(msg, sizeof(msg),", "\"bad DT_STRSZ %#x\", strtab_end);", "throwCantPack(msg);", "}", "}", "unsigned const x_sym = dt_table[Elf32_Dyn::DT_SYMTAB];", "unsigned const x_str = dt_table[Elf32_Dyn::DT_STRTAB];", "if (x_sym && x_str) {", "upx_uint32_t const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);", "upx_uint32_t const v_str = get_te32(&dynp0[-1+ x_str].d_val);", "unsigned const  z_sym = dt_table[Elf32_Dyn::DT_SYMENT];", "unsigned const sz_sym = !z_sym ? sizeof(Elf32_Sym)", ": get_te32(&dynp0[-1+ z_sym].d_val);", "if (v_sym < v_str) {", "symnum_end = (v_str - v_sym) / sz_sym;", "}", "}", "unsigned const v_hsh = elf_unsigned_dynamic(Elf32_Dyn::DT_HASH);", "if (v_hsh && file_image) {", "hashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_HASH);", "if (!hashtab) {", "char msg[40]; snprintf(msg, sizeof(msg),", "\"bad DT_HASH %#x\", v_hsh);", "throwCantPack(msg);", "}", "unsigned const nbucket = get_te32(&hashtab[0]);", "unsigned const *const buckets = &hashtab[2];", "unsigned const *const chains = &buckets[nbucket]; (void)chains;", "unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);", "if (!nbucket", "|| (nbucket>>31) || (file_size/sizeof(unsigned)) <= (2*nbucket)", "|| ((v_hsh < v_sym) && (v_sym - v_hsh) < (sizeof(unsigned)*2", "+ sizeof(*buckets)*nbucket", "+ sizeof(*chains) *nbucket", "))", ") {", "char msg[90]; snprintf(msg, sizeof(msg),", "\"bad DT_HASH nbucket=%#x  len=%#x\",", "nbucket, (v_sym - v_hsh));", "throwCantPack(msg);", "}", "}", "unsigned const v_gsh = elf_unsigned_dynamic(Elf32_Dyn::DT_GNU_HASH);", "if (v_gsh && file_image) {", "gashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_GNU_HASH);", "if (!gashtab) {", "char msg[40]; snprintf(msg, sizeof(msg),", "\"bad DT_GNU_HASH %#x\", v_gsh);", "throwCantPack(msg);", "}", "unsigned const n_bucket = get_te32(&gashtab[0]);", "unsigned const n_bitmask = get_te32(&gashtab[2]);", "unsigned const gnu_shift = get_te32(&gashtab[3]);", "unsigned const *const bitmask = (unsigned const *)(void const *)&gashtab[4];", "unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask];", "unsigned     const *const hasharr = &buckets[n_bucket]; (void)hasharr;", "unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);", "if (!n_bucket || !n_bitmask", "|| (-1+ n_bitmask) & n_bitmask", "|| 8*sizeof(unsigned) <= gnu_shift", "|| (n_bucket>>30)", "|| (n_bitmask>>30)", "|| (file_size / sizeof(unsigned)) <= (n_bitmask + 2*n_bucket)", "|| ((v_gsh < v_sym) && (v_sym - v_gsh) < (sizeof(unsigned)*4", "+ sizeof(*bitmask)*n_bitmask", "+ sizeof(*buckets)*n_bucket", "+ sizeof(*hasharr)*n_bucket", "))", ") {", "char msg[90]; snprintf(msg, sizeof(msg),", "\"bad DT_GNU_HASH n_bucket=%#x  n_bitmask=%#x  len=%#x\",", "n_bucket, n_bitmask, v_sym - v_gsh);", "throwCantPack(msg);", "}", "}", "unsigned const e_shstrndx = get_te16(&ehdri.e_shstrndx);", "if (e_shnum <= e_shstrndx", "&&  !(0==e_shnum && 0==e_shstrndx) ) {", "char msg[40]; snprintf(msg, sizeof(msg),", "\"bad .e_shstrndx %d >= .e_shnum %d\", e_shstrndx, e_shnum);", "throwCantPack(msg);", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["bool PackLinuxElf64::calls_crt1(Elf64_Rela const *rela, int sz)", "{", "if (!dynsym || !dynstr) {", "return false;", "}", "for (unsigned relnum= 0; 0 < sz; (sz -= sizeof(Elf64_Rela)), ++rela, ++relnum) {", "unsigned const symnum = get_te64(&rela->r_info) >> 32;", "char const *const symnam = get_dynsym_name(symnum, relnum);", "if (0==strcmp(symnam, \"__libc_start_main\")", "||  0==strcmp(symnam, \"__libc_init\")", "||  0==strcmp(symnam, \"__uClibc_main\")", "||  0==strcmp(symnam, \"__uClibc_start_main\"))", "return true;", "}", "return false;", "}"], "ner_tags": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static void get_over(struct SYMBOL *s)", "{", "struct VOICE_S *p_voice, *p_voice2, *p_voice3;", "int range, voice, voice2, voice3;", "static char tx_wrong_dur[] = \"Wrong duration in voice overlay\";", "static char txt_no_note[] = \"No note in voice overlay\";", "p_voice = curvoice;", "if (p_voice->ignore)", "return;", "if (s->abc_type == ABC_T_BAR", "|| s->u.v_over.type == V_OVER_E)  {", "if (!p_voice->last_sym) {", "error(1, s, txt_no_note);", "return;", "}", "p_voice->last_sym->sflags |= S_BEAM_END;", "over_bar = 0;", "if (over_time < 0) {", "error(1, s, \"Erroneous end of voice overlap\");", "return;", "}", "if (p_voice->time != over_mxtime)", "error(1, s, tx_wrong_dur);", "curvoice = &voice_tb[over_voice];", "over_mxtime = 0;", "over_voice = -1;", "over_time = -1;", "return;", "}", "if (s->u.v_over.type == V_OVER_S) {", "over_voice = p_voice - voice_tb;", "over_time = p_voice->time;", "return;", "}", "if (!p_voice->last_sym) {", "error(1, s, txt_no_note);", "return;", "}", "p_voice->last_sym->sflags |= S_BEAM_END;", "voice2 = s->u.v_over.voice;", "p_voice2 = &voice_tb[voice2];", "if (parsys->voice[voice2].range < 0) {", "int clone;", "if (cfmt.abc2pscompat) {", "error(1, s, \"Cannot have %%%%abc2pscompat\");", "cfmt.abc2pscompat = 0;", "}", "clone = p_voice->clone >= 0;", "p_voice2->id[0] = '&';", "p_voice2->id[1] = '\\0';", "p_voice2->second = 1;", "parsys->voice[voice2].second = 1;", "p_voice2->scale = p_voice->scale;", "p_voice2->octave = p_voice->octave;", "p_voice2->transpose = p_voice->transpose;", "memcpy(&p_voice2->key, &p_voice->key,", "sizeof p_voice2->key);", "memcpy(&p_voice2->ckey, &p_voice->ckey,", "sizeof p_voice2->ckey);", "memcpy(&p_voice2->okey, &p_voice->okey,", "sizeof p_voice2->okey);", "p_voice2->posit = p_voice->posit;", "p_voice2->staff = p_voice->staff;", "p_voice2->cstaff = p_voice->cstaff;", "p_voice2->color = p_voice->color;", "p_voice2->map_name = p_voice->map_name;", "range = parsys->voice[p_voice - voice_tb].range;", "for (voice = 0; voice < MAXVOICE; voice++) {", "if (parsys->voice[voice].range > range)", "parsys->voice[voice].range += clone + 1;", "}", "parsys->voice[voice2].range = range + 1;", "voice_link(p_voice2);", "if (clone) {", "for (voice3 = MAXVOICE; --voice3 >= 0; ) {", "if (parsys->voice[voice3].range < 0)", "break;", "}", "if (voice3 > 0) {", "p_voice3 = &voice_tb[voice3];", "strcpy(p_voice3->id, p_voice2->id);", "p_voice3->second = 1;", "parsys->voice[voice3].second = 1;", "p_voice3->scale = voice_tb[p_voice->clone].scale;", "parsys->voice[voice3].range = range + 2;", "voice_link(p_voice3);", "p_voice2->clone = voice3;", "} else {", "error(1, s,", "\"Too many voices for overlay cloning\");", "}", "}", "}", "voice = p_voice - voice_tb;", "if (over_time < 0) {", "int time;", "over_bar = 1;", "over_mxtime = p_voice->time;", "over_voice = voice;", "time = p_voice2->time;", "for (s = p_voice->last_sym;      ; s = s->prev) {", "if (s->type == BAR", "|| s->time <= time)", "break;", "}", "over_time = s->time;", "} else {", "if (over_mxtime == 0)", "over_mxtime = p_voice->time;", "else if (p_voice->time != over_mxtime)", "error(1, s, tx_wrong_dur);", "}", "p_voice2->time = over_time;", "curvoice = p_voice2;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static s32 gf_hevc_read_pps_bs_internal(GF_BitStream *bs, HEVCState *hevc)", "{", "u32 i;", "s32 pps_id;", "HEVC_PPS *pps;", "pps_id = gf_bs_read_ue_log(bs, \"pps_id\");", "if ((pps_id < 0) || (pps_id >= 64)) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] wrong PPS ID %d in PPS\\n\", pps_id));", "return -1;", "}", "pps = &hevc->pps[pps_id];", "if (!pps->state) {", "pps->id = pps_id;", "pps->state = 1;", "}", "pps->sps_id = gf_bs_read_ue_log(bs, \"sps_id\");", "if (pps->sps_id >= 16) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] wrong SPS ID %d in PPS\\n\", pps->sps_id));", "pps->sps_id=0;", "return -1;", "}", "hevc->sps_active_idx = pps->sps_id;", "pps->dependent_slice_segments_enabled_flag = gf_bs_read_int_log(bs, 1, \"dependent_slice_segments_enabled_flag\");", "pps->output_flag_present_flag = gf_bs_read_int_log(bs, 1, \"output_flag_present_flag\");", "pps->num_extra_slice_header_bits = gf_bs_read_int_log(bs, 3, \"num_extra_slice_header_bits\");", "pps->sign_data_hiding_flag = gf_bs_read_int_log(bs, 1, \"sign_data_hiding_flag\");", "pps->cabac_init_present_flag = gf_bs_read_int_log(bs, 1, \"cabac_init_present_flag\");", "pps->num_ref_idx_l0_default_active = 1 + gf_bs_read_ue_log(bs, \"num_ref_idx_l0_default_active\");", "pps->num_ref_idx_l1_default_active = 1 + gf_bs_read_ue_log(bs, \"num_ref_idx_l1_default_active\");", "pps->pic_init_qp_minus26 = gf_bs_read_se_log(bs, \"pic_init_qp_minus26\");", "pps->constrained_intra_pred_flag = gf_bs_read_int_log(bs, 1, \"constrained_intra_pred_flag\");", "pps->transform_skip_enabled_flag = gf_bs_read_int_log(bs, 1, \"transform_skip_enabled_flag\");", "if ((pps->cu_qp_delta_enabled_flag = gf_bs_read_int_log(bs, 1, \"cu_qp_delta_enabled_flag\")))", "pps->diff_cu_qp_delta_depth = gf_bs_read_ue_log(bs, \"diff_cu_qp_delta_depth\");", "pps->pic_cb_qp_offset = gf_bs_read_se_log(bs, \"pic_cb_qp_offset\");", "pps->pic_cr_qp_offset = gf_bs_read_se_log(bs, \"pic_cr_qp_offset\");", "pps->slice_chroma_qp_offsets_present_flag = gf_bs_read_int_log(bs, 1, \"slice_chroma_qp_offsets_present_flag\");", "pps->weighted_pred_flag = gf_bs_read_int_log(bs, 1, \"weighted_pred_flag\");", "pps->weighted_bipred_flag = gf_bs_read_int_log(bs, 1, \"weighted_bipred_flag\");", "pps->transquant_bypass_enable_flag = gf_bs_read_int_log(bs, 1, \"transquant_bypass_enable_flag\");", "pps->tiles_enabled_flag = gf_bs_read_int_log(bs, 1, \"tiles_enabled_flag\");", "pps->entropy_coding_sync_enabled_flag = gf_bs_read_int_log(bs, 1, \"entropy_coding_sync_enabled_flag\");", "if (pps->tiles_enabled_flag) {", "pps->num_tile_columns = 1 + gf_bs_read_ue_log(bs, \"num_tile_columns_minus1\");", "pps->num_tile_rows = 1 + gf_bs_read_ue_log(bs, \"num_tile_rows_minus1\");", "pps->uniform_spacing_flag = gf_bs_read_int_log(bs, 1, \"uniform_spacing_flag\");", "if (!pps->uniform_spacing_flag) {", "for (i = 0; i < pps->num_tile_columns - 1; i++) {", "pps->column_width[i] = 1 + gf_bs_read_ue_log_idx(bs, \"column_width_minus1\", i);", "}", "for (i = 0; i < pps->num_tile_rows - 1; i++) {", "pps->row_height[i] = 1 + gf_bs_read_ue_log_idx(bs, \"row_height_minus1\", i);", "}", "}", "pps->loop_filter_across_tiles_enabled_flag = gf_bs_read_int_log(bs, 1, \"loop_filter_across_tiles_enabled_flag\");", "}", "pps->loop_filter_across_slices_enabled_flag = gf_bs_read_int_log(bs, 1, \"loop_filter_across_slices_enabled_flag\");", "if ((pps->deblocking_filter_control_present_flag = gf_bs_read_int_log(bs, 1, \"deblocking_filter_control_present_flag\"))) {", "pps->deblocking_filter_override_enabled_flag = gf_bs_read_int_log(bs, 1, \"deblocking_filter_override_enabled_flag\");", "if (! (pps->pic_disable_deblocking_filter_flag = gf_bs_read_int_log(bs, 1, \"pic_disable_deblocking_filter_flag\"))) {", "pps->beta_offset_div2 = gf_bs_read_se_log(bs, \"beta_offset_div2\");", "pps->tc_offset_div2 = gf_bs_read_se_log(bs, \"tc_offset_div2\");", "}", "}", "if ((pps->pic_scaling_list_data_present_flag = gf_bs_read_int_log(bs, 1, \"pic_scaling_list_data_present_flag\"))) {", "hevc_scaling_list_data(bs);", "}", "pps->lists_modification_present_flag = gf_bs_read_int_log(bs, 1, \"lists_modification_present_flag\");", "pps->log2_parallel_merge_level_minus2 = gf_bs_read_ue_log(bs, \"log2_parallel_merge_level_minus2\");", "pps->slice_segment_header_extension_present_flag = gf_bs_read_int_log(bs, 1, \"slice_segment_header_extension_present_flag\");", "if (gf_bs_read_int_log(bs, 1, \"pps_extension_flag\")) {", "#if 0", "while (gf_bs_available(bs)) {", "gf_bs_read_int(bs, 1);", "}", "#endif", "}", "return pps_id;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["int main(int argc, char **argv)", "{", "int opt, timeout = 1800, family = AF_UNSPEC, hashlength = 0, hashmin = 0;", "int daemonize = FALSE, always_rewrite = FALSE;", "char *listen_addr = NULL, *forward_service = NULL, *reverse_service = NULL,", "*user = NULL, *domain = NULL, *chroot_dir = NULL;", "char separator = '=';", "char *secret_file = NULL, *pid_file = NULL;", "FILE *pf = NULL, *sf = NULL;", "struct passwd *pwd = NULL;", "char secretbuf[1024], *secret = NULL;", "char *tmp;", "time_t now;", "srs_t *srs;", "const char **excludes;", "size_t s1 = 0, s2 = 1;", "struct pollfd fds[4];", "size_t socket_count = 0, sc;", "int sockets[4] = {-1, -1, -1, -1};", "handle_t handler[4] = {0, 0, 0, 0};", "int fd, maxfd;", "excludes = (const char **)calloc(1, sizeof(char *));", "tmp = strrchr(argv[0], '/');", "if (tmp)", "self = strdup(tmp + 1);", "else", "self = strdup(argv[0]);", "while ((opt = getopt(argc, argv, \"46d:a:l:f:r:s:n:N:u:t:p:c:X::ADhev\"))", "!= -1)", "{", "switch (opt)", "{", "case '?':", "return EXIT_FAILURE;", "case '4':", "family = AF_INET;", "break;", "case '6':", "family = AF_INET6;", "break;", "case 'd':", "domain = strdup(optarg);", "break;", "case 'a':", "separator = *optarg;", "break;", "case 'l':", "listen_addr = strdup(optarg);", "break;", "case 'f':", "forward_service = strdup(optarg);", "break;", "case 'r':", "reverse_service = strdup(optarg);", "break;", "case 't':", "timeout = atoi(optarg);", "break;", "case 's':", "secret_file = strdup(optarg);", "break;", "case 'n':", "hashlength = atoi(optarg);", "break;", "case 'N':", "hashmin = atoi(optarg);", "break;", "case 'p':", "pid_file = strdup(optarg);", "break;", "case 'u':", "user = strdup(optarg);", "break;", "case 'c':", "chroot_dir = strdup(optarg);", "break;", "case 'D':", "daemonize = TRUE;", "break;", "case 'A':", "always_rewrite = TRUE;", "break;", "case 'h':", "show_help();", "return EXIT_SUCCESS;", "case 'X':", "if (optarg != NULL)", "{", "tmp = strtok(optarg, \",; \\t\\r\\n\");", "while (tmp)", "{", "if (s1 + 1 >= s2)", "{", "s2 *= 2;", "excludes = (const char **)realloc(", "excludes, s2 * sizeof(char *));", "if (excludes == NULL)", "{", "fprintf(stderr, \"%s: Out of memory\\n\\n\", self);", "return EXIT_FAILURE;", "}", "}", "excludes[s1++] = strdup(tmp);", "tmp = strtok(NULL, \",; \\t\\r\\n\");", "}", "excludes[s1] = NULL;", "}", "break;", "case 'e':", "if (getenv(\"SRS_DOMAIN\") != NULL)", "domain = strdup(getenv(\"SRS_DOMAIN\"));", "if (getenv(\"SRS_SEPARATOR\") != NULL)", "separator = *getenv(\"SRS_SEPARATOR\");", "if (getenv(\"SRS_HASHLENGTH\") != NULL)", "hashlength = atoi(getenv(\"SRS_HASHLENGTH\"));", "if (getenv(\"SRS_HASHMIN\") != NULL)", "hashmin = atoi(getenv(\"SRS_HASHMIN\"));", "if (getenv(\"SRS_FORWARD_PORT\") != NULL)", "forward_service = strdup(getenv(\"SRS_FORWARD_PORT\"));", "if (getenv(\"SRS_REVERSE_PORT\") != NULL)", "reverse_service = strdup(getenv(\"SRS_REVERSE_PORT\"));", "if (getenv(\"SRS_TIMEOUT\") != NULL)", "timeout = atoi(getenv(\"SRS_TIMEOUT\"));", "if (getenv(\"SRS_SECRET\") != NULL)", "secret_file = strdup(getenv(\"SRS_SECRET\"));", "if (getenv(\"SRS_PID_FILE\") != NULL)", "pid_file = strdup(getenv(\"SRS_PID_FILE\"));", "if (getenv(\"RUN_AS\") != NULL)", "user = strdup(getenv(\"RUN_AS\"));", "if (getenv(\"CHROOT\") != NULL)", "chroot_dir = strdup(getenv(\"CHROOT\"));", "if (getenv(\"SRS_EXCLUDE_DOMAINS\") != NULL)", "{", "tmp = strtok(getenv(\"SRS_EXCLUDE_DOMAINS\"), \",; \\t\\r\\n\");", "while (tmp)", "{", "if (s1 + 1 >= s2)", "{", "s2 *= 2;", "excludes = (const char **)realloc(", "excludes, s2 * sizeof(char *));", "if (excludes == NULL)", "{", "fprintf(stderr, \"%s: Out of memory\\n\\n\", self);", "return EXIT_FAILURE;", "}", "}", "excludes[s1++] = strdup(tmp);", "tmp = strtok(NULL, \",; \\t\\r\\n\");", "}", "excludes[s1] = NULL;", "}", "break;", "case 'v':", "fprintf(stdout, \"%s\\n\", POSTSRSD_VERSION);", "return EXIT_SUCCESS;", "}", "}", "if (optind < argc)", "{", "fprintf(stderr, \"%s: extra argument on command line: %s\\n\", self,", "argv[optind]);", "return EXIT_FAILURE;", "}", "if (domain == NULL || *domain == 0)", "{", "fprintf(stderr, \"%s: You must set a home domain (-d)\\n\", self);", "return EXIT_FAILURE;", "}", "if (separator != '=' && separator != '+' && separator != '-')", "{", "fprintf(stderr, \"%s: SRS separator character must be one of '=+-'\\n\",", "self);", "return EXIT_FAILURE;", "}", "if (forward_service == NULL)", "forward_service = strdup(\"10001\");", "if (reverse_service == NULL)", "reverse_service = strdup(\"10002\");", "maxfd = sysconf(_SC_OPEN_MAX);", "for (fd = 3; fd < maxfd; fd++)", "close(fd);", "if (pid_file)", "{", "pf = fopen(pid_file, \"w\");", "if (pf == NULL)", "{", "fprintf(stderr, \"%s: Cannot write PID: %s\\n\\n\", self, pid_file);", "return EXIT_FAILURE;", "}", "}", "if (secret_file != NULL)", "{", "sf = fopen(secret_file, \"rb\");", "if (sf == NULL)", "{", "fprintf(stderr, \"%s: Cannot open file with secret: %s\\n\", self,", "secret_file);", "return EXIT_FAILURE;", "}", "}", "else", "{", "fprintf(stderr, \"%s: You must set a secret (-s)\\n\", self);", "return EXIT_FAILURE;", "}", "sc = bind_service(listen_addr, forward_service, family,", "&sockets[socket_count], 4 - socket_count);", "if (sc == 0)", "return EXIT_FAILURE;", "while (sc-- > 0)", "handler[socket_count++] = handle_forward;", "free(forward_service);", "sc = bind_service(listen_addr, reverse_service, family,", "&sockets[socket_count], 4 - socket_count);", "if (sc == 0)", "return EXIT_FAILURE;", "while (sc-- > 0)", "handler[socket_count++] = handle_reverse;", "free(reverse_service);", "openlog(self, LOG_PID | LOG_NDELAY, LOG_MAIL);", "now = time(NULL);", "localtime(&now);", "if (user)", "{", "errno = 0;", "pwd = getpwnam(user);", "if (pwd == NULL)", "{", "if (errno != 0)", "fprintf(stderr, \"%s: Failed to lookup user: %s\\n\", self,", "strerror(errno));", "else", "fprintf(stderr, \"%s: No such user: %s\\n\", self, user);", "return EXIT_FAILURE;", "}", "}", "if (chroot_dir)", "{", "if (chdir(chroot_dir) < 0)", "{", "fprintf(stderr, \"%s: Cannot change to chroot: %s\\n\", self,", "strerror(errno));", "return EXIT_FAILURE;", "}", "if (chroot(chroot_dir) < 0)", "{", "fprintf(stderr, \"%s: Failed to enable chroot: %s\\n\", self,", "strerror(errno));", "return EXIT_FAILURE;", "}", "}", "if (pwd)", "{", "if (setgid(pwd->pw_gid) < 0)", "{", "fprintf(stderr, \"%s: Failed to switch group id: %s\\n\", self,", "strerror(errno));", "return EXIT_FAILURE;", "}", "if (setuid(pwd->pw_uid) < 0)", "{", "fprintf(stderr, \"%s: Failed to switch user id: %s\\n\", self,", "strerror(errno));", "return EXIT_FAILURE;", "}", "}", "if (daemonize)", "{", "close(0);", "close(1);", "close(2);", "if (fork() != 0)", "return EXIT_SUCCESS;", "setsid();", "if (fork() != 0)", "return EXIT_SUCCESS;", "}", "if (pf)", "{", "fprintf(pf, \"%d\", (int)getpid());", "fclose(pf);", "}", "srs = srs_new();", "while ((secret = fgets(secretbuf, sizeof(secretbuf), sf)))", "{", "secret = strtok(secret, \"\\r\\n\");", "if (secret)", "srs_add_secret(srs, secret);", "}", "fclose(sf);", "srs_set_alwaysrewrite(srs, always_rewrite);", "srs_set_separator(srs, separator);", "if (hashlength)", "srs_set_hashlength(srs, hashlength);", "if (hashmin)", "srs_set_hashmin(srs, hashmin);", "for (sc = 0; sc < socket_count; ++sc)", "{", "fds[sc].fd = sockets[sc];", "fds[sc].events = POLLIN;", "}", "while (TRUE)", "{", "int conn;", "FILE *fp;", "char linebuf[1024], *line;", "char keybuf[1024], *key;", "if (poll(fds, socket_count, 1000) < 0)", "{", "if (errno == EINTR)", "continue;", "if (daemonize)", "syslog(LOG_MAIL | LOG_ERR, \"Poll failure: %s\", strerror(errno));", "else", "fprintf(stderr, \"%s: Poll failure: %s\\n\", self,", "strerror(errno));", "return EXIT_FAILURE;", "}", "for (sc = 0; sc < socket_count; ++sc)", "{", "if (fds[sc].revents)", "{", "conn = accept(fds[sc].fd, NULL, NULL);", "if (conn < 0)", "continue;", "if (fork() == 0)", "{", "int i;", "for (i = 0; i < socket_count; ++i)", "close(sockets[i]);", "fp = fdopen(conn, \"r+\");", "if (fp == NULL)", "exit(EXIT_FAILURE);", "fds[0].fd = conn;", "fds[0].events = POLLIN;", "if (poll(fds, 1, timeout * 1000) <= 0)", "return EXIT_FAILURE;", "line = fgets(linebuf, sizeof(linebuf), fp);", "while (line)", "{", "fseek(fp, 0, SEEK_CUR);", "char *token;", "token = strtok(line, \" \\r\\n\");", "if (token == NULL || strcmp(token, \"get\") != 0)", "{", "fprintf(fp, \"500 Invalid request\\n\");", "fflush(fp);", "return EXIT_FAILURE;", "}", "token = strtok(NULL, \"\\r\\n\");", "if (!token)", "{", "fprintf(fp, \"500 Invalid request\\n\");", "fflush(fp);", "return EXIT_FAILURE;", "}", "key = url_decode(keybuf, sizeof(keybuf), token);", "if (!key)", "{", "fprintf(fp, \"500 Invalid request\\n\");", "fflush(fp);", "return EXIT_FAILURE;", "}", "handler[sc](srs, fp, key, domain, excludes);", "fflush(fp);", "if (poll(fds, 1, timeout * 1000) <= 0)", "break;", "line = fgets(linebuf, sizeof(linebuf), fp);", "}", "fclose(fp);", "return EXIT_SUCCESS;", "}", "close(conn);", "}", "}", "waitpid(-1, NULL, WNOHANG);", "}", "return EXIT_SUCCESS;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["int flb_parser_json_do(struct flb_parser *parser,", "const char *in_buf, size_t in_size,", "void **out_buf, size_t *out_size,", "struct flb_time *out_time)", "{", "int i;", "int skip;", "int ret;", "int slen;", "int root_type;", "int records;", "double tmfrac = 0;", "char *mp_buf = NULL;", "char *time_key;", "char *tmp_out_buf = NULL;", "char tmp[255];", "size_t tmp_out_size = 0;", "size_t off = 0;", "size_t map_size;", "size_t mp_size;", "size_t len;", "msgpack_sbuffer mp_sbuf;", "msgpack_packer  mp_pck;", "msgpack_unpacked result;", "msgpack_object map;", "msgpack_object *k = NULL;", "msgpack_object *v = NULL;", "time_t time_lookup;", "struct tm tm = {0};", "struct flb_time *t;", "ret = flb_pack_json_recs(in_buf, in_size, &mp_buf, &mp_size, &root_type,", "&records);", "if (ret != 0) {", "return -1;", "}", "if (records != 1) {", "flb_free(mp_buf);", "return -1;", "}", "msgpack_unpacked_init(&result);", "if (msgpack_unpack_next(&result, mp_buf, mp_size, &off) == MSGPACK_UNPACK_SUCCESS) {", "map = result.data;", "if (map.type != MSGPACK_OBJECT_MAP) {", "flb_free(mp_buf);", "msgpack_unpacked_destroy(&result);", "return -1;", "}", "}", "else {", "if (mp_size > 0) {", "flb_free(mp_buf);", "}", "msgpack_unpacked_destroy(&result);", "return -1;", "}", "tmp_out_buf = mp_buf;", "tmp_out_size = mp_size;", "if (parser->decoders) {", "ret = flb_parser_decoder_do(parser->decoders,", "mp_buf, mp_size,", "&tmp_out_buf, &tmp_out_size);", "if (ret == 0) {", "off = 0;", "msgpack_unpacked_destroy(&result);", "msgpack_unpacked_init(&result);", "msgpack_unpack_next(&result, tmp_out_buf, tmp_out_size, &off);", "map = result.data;", "}", "}", "*out_buf = tmp_out_buf;", "*out_size = tmp_out_size;", "if (mp_buf != tmp_out_buf) {", "flb_free(mp_buf);", "}", "if (!parser->time_fmt) {", "msgpack_unpacked_destroy(&result);", "return *out_size;", "}", "if (parser->time_key) {", "time_key = parser->time_key;", "}", "else {", "time_key = \"time\";", "}", "slen = strlen(time_key);", "map_size = map.via.map.size;", "skip = map_size;", "for (i = 0; i < map_size; i++) {", "k = &map.via.map.ptr[i].key;", "v = &map.via.map.ptr[i].val;", "if (k->via.str.size != slen) {", "continue;", "}", "if (k->via.str.ptr == NULL) {", "flb_free(mp_buf);", "*out_buf = NULL;", "msgpack_unpacked_destroy(&result);", "return -1;", "}", "if (strncmp(k->via.str.ptr, time_key, k->via.str.size) == 0) {", "if (parser->time_keep == FLB_FALSE) {", "skip = i;", "break;", "}", "else {", "skip = -1;", "}", "break;", "}", "k = NULL;", "v = NULL;", "}", "if (i >= map_size || !k || !v) {", "msgpack_unpacked_destroy(&result);", "return *out_size;", "}", "if (v->type != MSGPACK_OBJECT_STR) {", "msgpack_unpacked_destroy(&result);", "return *out_size;", "}", "ret = flb_parser_time_lookup(v->via.str.ptr, v->via.str.size,", "0, parser, &tm, &tmfrac);", "if (ret == -1) {", "len = v->via.str.size;", "if (len > sizeof(tmp) - 1) {", "len = sizeof(tmp) - 1;", "}", "memcpy(tmp, v->via.str.ptr, len);", "tmp[len] = '\\0';", "flb_warn(\"[parser:%s] invalid time format %s for '%s'\",", "parser->name, parser->time_fmt_full, tmp);", "time_lookup = 0;", "}", "else {", "time_lookup = flb_parser_tm2time(&tm);", "}", "msgpack_sbuffer_init(&mp_sbuf);", "msgpack_packer_init(&mp_pck, &mp_sbuf, msgpack_sbuffer_write);", "if (parser->time_keep == FLB_FALSE) {", "msgpack_pack_map(&mp_pck, map_size - 1);", "}", "else {", "msgpack_pack_map(&mp_pck, map_size);", "}", "for (i = 0; i < map_size; i++) {", "if (i == skip) {", "continue;", "}", "msgpack_pack_object(&mp_pck, map.via.map.ptr[i].key);", "msgpack_pack_object(&mp_pck, map.via.map.ptr[i].val);", "}", "flb_free(tmp_out_buf);", "*out_buf = mp_sbuf.data;", "*out_size = mp_sbuf.size;", "t = out_time;", "t->tm.tv_sec  = time_lookup;", "t->tm.tv_nsec = (tmfrac * 1000000000);", "msgpack_unpacked_destroy(&result);", "return *out_size;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void dump_isom_sdp(GF_ISOFile *file, char *inName, Bool is_final_name)", "{", "const char *sdp;", "u32 size, i;", "FILE *dump;", "if (inName) {", "char szBuf[1024];", "strcpy(szBuf, inName);", "if (!is_final_name) {", "char *ext = strchr(szBuf, '.');", "if (ext) ext[0] = 0;", "strcat(szBuf, \"_sdp.txt\");", "}", "dump = gf_fopen(szBuf, \"wt\");", "if (!dump) {", "fprintf(stderr, \"Failed to open %s for dumping\\n\", szBuf);", "return;", "}", "} else {", "dump = stdout;", "fprintf(dump, \"* File SDP content *\\n\\n\");", "}", "gf_isom_sdp_get(file, &sdp, &size);", "fprintf(dump, \"%s\", sdp);", "fprintf(dump, \"\\r\\n\");", "for (i=0; i<gf_isom_get_track_count(file); i++) {", "if (gf_isom_get_media_type(file, i+1) != GF_ISOM_MEDIA_HINT) continue;", "gf_isom_sdp_track_get(file, i+1, &sdp, &size);", "fprintf(dump, \"%s\", sdp);", "}", "fprintf(dump, \"\\n\\n\");", "if (inName) gf_fclose(dump);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["u32 gf_bs_read_ue_log_idx3(GF_BitStream *bs, const char *fname, s32 idx1, s32 idx2, s32 idx3)", "{", "u32 val=0, code;", "s32 nb_lead = -1;", "u32 bits = 0;", "for (code=0; !code; nb_lead++) {", "if (nb_lead>=32) {", "if (!gf_bs_available(bs)) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Core] exp-golomb read failed, not enough bits in bitstream !\\n\"));", "} else {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Core] corrupted exp-golomb code, %d leading zeros, max 31 allowed !\\n\", nb_lead));", "}", "return 0;", "}", "code = gf_bs_read_int(bs, 1);", "bits++;", "}", "if (nb_lead) {", "u32 leads=1;", "val = gf_bs_read_int(bs, nb_lead);", "leads <<= nb_lead;", "leads -= 1;", "val += leads;", "bits += nb_lead;", "}", "if (fname) {", "gf_bs_log_idx(bs, bits, fname, val, idx1, idx2, idx3);", "}", "return val;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["xmlAddID(xmlValidCtxtPtr ctxt, xmlDocPtr doc, const xmlChar *value,", "xmlAttrPtr attr) {", "xmlIDPtr ret;", "xmlIDTablePtr table;", "if (doc == NULL) {", "return(NULL);", "}", "if (value == NULL) {", "return(NULL);", "}", "if (attr == NULL) {", "return(NULL);", "}", "table = (xmlIDTablePtr) doc->ids;", "if (table == NULL)  {", "doc->ids = table = xmlHashCreateDict(0, doc->dict);", "}", "if (table == NULL) {", "xmlVErrMemory(ctxt,", "\"xmlAddID: Table creation failed!\\n\");", "return(NULL);", "}", "ret = (xmlIDPtr) xmlMalloc(sizeof(xmlID));", "if (ret == NULL) {", "xmlVErrMemory(ctxt, \"malloc failed\");", "return(NULL);", "}", "ret->value = xmlStrdup(value);", "ret->doc = doc;", "if ((ctxt != NULL) && (ctxt->vstateNr != 0)) {", "if (doc->dict != NULL)", "ret->name = xmlDictLookup(doc->dict, attr->name, -1);", "else", "ret->name = xmlStrdup(attr->name);", "ret->attr = NULL;", "} else {", "ret->attr = attr;", "ret->name = NULL;", "}", "ret->lineno = xmlGetLineNo(attr->parent);", "if (xmlHashAddEntry(table, value, ret) < 0) {", "#ifdef LIBXML_VALID_ENABLED", "if (ctxt != NULL) {", "xmlErrValidNode(ctxt, attr->parent, XML_DTD_ID_REDEFINED,", "\"ID %s already defined\\n\", value, NULL, NULL);", "}", "#endif /* LIBXML_VALID_ENABLED */", "xmlFreeID(ret);", "return(NULL);", "}", "if (attr != NULL)", "attr->atype = XML_ATTRIBUTE_ID;", "return(ret);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["_archive_write_disk_close(struct archive *_a)", "{", "struct archive_write_disk *a = (struct archive_write_disk *)_a;", "struct fixup_entry *next, *p;", "int fd, ret;", "archive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,", "ARCHIVE_STATE_HEADER | ARCHIVE_STATE_DATA,", "\"archive_write_disk_close\");", "ret = _archive_write_disk_finish_entry(&a->archive);", "p = sort_dir_list(a->fixup_list);", "while (p != NULL) {", "fd = -1;", "a->pst = NULL;", "if (p->fixup &", "(TODO_TIMES | TODO_MODE_BASE | TODO_ACLS | TODO_FFLAGS)) {", "fd = open(p->name,", "O_WRONLY | O_BINARY | O_NOFOLLOW | O_CLOEXEC);", "}", "if (p->fixup & TODO_TIMES) {", "set_times(a, fd, p->mode, p->name,", "p->atime, p->atime_nanos,", "p->birthtime, p->birthtime_nanos,", "p->mtime, p->mtime_nanos,", "p->ctime, p->ctime_nanos);", "}", "if (p->fixup & TODO_MODE_BASE) {", "#ifdef HAVE_FCHMOD", "if (fd >= 0)", "fchmod(fd, p->mode);", "else", "#endif", "chmod(p->name, p->mode);", "}", "if (p->fixup & TODO_ACLS)", "archive_write_disk_set_acls(&a->archive, fd,", "p->name, &p->acl, p->mode);", "if (p->fixup & TODO_FFLAGS)", "set_fflags_platform(a, fd, p->name,", "p->mode, p->fflags_set, 0);", "if (p->fixup & TODO_MAC_METADATA)", "set_mac_metadata(a, p->name, p->mac_metadata,", "p->mac_metadata_size);", "next = p->next;", "archive_acl_clear(&p->acl);", "free(p->mac_metadata);", "free(p->name);", "if (fd >= 0)", "close(fd);", "free(p);", "p = next;", "}", "a->fixup_list = NULL;", "return (ret);", "}"], "ner_tags": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int track_header(VividasDemuxContext *viv, AVFormatContext *s,  uint8_t *buf, int size)", "{", "int i, j, ret;", "int64_t off;", "int val_1;", "int num_video;", "AVIOContext pb0, *pb = &pb0;", "ffio_init_context(pb, buf, size, 0, NULL, NULL, NULL, NULL);", "ffio_read_varlen(pb);", "avio_r8(pb);", "val_1 = ffio_read_varlen(pb);", "for (i=0;i<val_1;i++) {", "int c = avio_r8(pb);", "if (avio_feof(pb))", "return AVERROR_EOF;", "for (j=0;j<c;j++) {", "if (avio_feof(pb))", "return AVERROR_EOF;", "avio_r8(pb);", "avio_r8(pb);", "}", "}", "avio_r8(pb);", "off = avio_tell(pb);", "off += ffio_read_varlen(pb);", "avio_r8(pb);", "num_video = avio_r8(pb);", "avio_seek(pb, off, SEEK_SET);", "if (num_video != 1) {", "av_log(s, AV_LOG_ERROR, \"number of video tracks %d is not 1\\n\", num_video);", "return AVERROR_PATCHWELCOME;", "}", "for (i = 0; i < num_video; i++) {", "AVStream *st = avformat_new_stream(s, NULL);", "int num, den;", "if (!st)", "return AVERROR(ENOMEM);", "st->id = i;", "st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;", "st->codecpar->codec_id = AV_CODEC_ID_VP6;", "off = avio_tell(pb);", "off += ffio_read_varlen(pb);", "avio_r8(pb);", "avio_r8(pb);", "num = avio_rl32(pb);", "den = avio_rl32(pb);", "avpriv_set_pts_info(st, 64, num, den);", "st->nb_frames = avio_rl32(pb);", "st->codecpar->width = avio_rl16(pb);", "st->codecpar->height = avio_rl16(pb);", "avio_r8(pb);", "avio_rl32(pb);", "avio_seek(pb, off, SEEK_SET);", "}", "off = avio_tell(pb);", "off += ffio_read_varlen(pb);", "avio_r8(pb);", "viv->num_audio = avio_r8(pb);", "avio_seek(pb, off, SEEK_SET);", "if (viv->num_audio != 1)", "av_log(s, AV_LOG_WARNING, \"number of audio tracks %d is not 1\\n\", viv->num_audio);", "for(i=0;i<viv->num_audio;i++) {", "int q;", "AVStream *st = avformat_new_stream(s, NULL);", "if (!st)", "return AVERROR(ENOMEM);", "st->id = num_video + i;", "st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;", "st->codecpar->codec_id = AV_CODEC_ID_VORBIS;", "off = avio_tell(pb);", "off += ffio_read_varlen(pb);", "avio_r8(pb);", "avio_r8(pb);", "avio_rl16(pb);", "st->codecpar->channels = avio_rl16(pb);", "st->codecpar->sample_rate = avio_rl32(pb);", "avio_seek(pb, 10, SEEK_CUR);", "q = avio_r8(pb);", "avio_seek(pb, q, SEEK_CUR);", "avio_r8(pb);", "if (avio_tell(pb) < off) {", "int num_data;", "int xd_size = 0;", "int data_len[256];", "int offset = 1;", "uint8_t *p;", "ffio_read_varlen(pb);", "avio_r8(pb);", "ffio_read_varlen(pb);", "num_data = avio_r8(pb);", "for (j = 0; j < num_data; j++) {", "uint64_t len = ffio_read_varlen(pb);", "if (len > INT_MAX/2 - xd_size) {", "return AVERROR_INVALIDDATA;", "}", "data_len[j] = len;", "xd_size += len;", "}", "ret = ff_alloc_extradata(st->codecpar, 64 + xd_size + xd_size / 255);", "if (ret < 0)", "return ret;", "p = st->codecpar->extradata;", "p[0] = 2;", "for (j = 0; j < num_data - 1; j++) {", "unsigned delta = av_xiphlacing(&p[offset], data_len[j]);", "if (delta > data_len[j]) {", "return AVERROR_INVALIDDATA;", "}", "offset += delta;", "}", "for (j = 0; j < num_data; j++) {", "int ret = avio_read(pb, &p[offset], data_len[j]);", "if (ret < data_len[j]) {", "st->codecpar->extradata_size = 0;", "av_freep(&st->codecpar->extradata);", "break;", "}", "offset += data_len[j];", "}", "if (offset < st->codecpar->extradata_size)", "st->codecpar->extradata_size = offset;", "}", "}", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static s32 gf_avc_read_pps_bs_internal(GF_BitStream *bs, AVCState *avc, u32 nal_hdr)", "{", "s32 pps_id;", "AVC_PPS *pps;", "gf_bs_enable_emulation_byte_removal(bs, GF_TRUE);", "if (!nal_hdr) {", "gf_bs_read_int_log(bs, 1, \"forbidden_zero_bit\");", "gf_bs_read_int_log(bs, 2, \"nal_ref_idc\");", "gf_bs_read_int_log(bs, 5, \"nal_unit_type\");", "}", "pps_id = gf_bs_read_ue_log(bs, \"pps_id\");", "if (pps_id >= 255) {", "return -1;", "}", "pps = &avc->pps[pps_id];", "pps->id = pps_id;", "if (!pps->status) pps->status = 1;", "pps->sps_id = gf_bs_read_ue_log(bs, \"sps_id\");", "if (pps->sps_id >= 32) {", "pps->sps_id = 0;", "return -1;", "}", "if (!avc->sps[pps->sps_id].state && !avc->sps[pps->sps_id + GF_SVC_SSPS_ID_SHIFT].state) {", "return -1;", "}", "avc->pps_active_idx = pps->id;", "avc->sps_active_idx = pps->sps_id;", "pps->entropy_coding_mode_flag = gf_bs_read_int_log(bs, 1, \"entropy_coding_mode_flag\");", "pps->pic_order_present = gf_bs_read_int_log(bs, 1, \"pic_order_present\");", "pps->slice_group_count = gf_bs_read_ue_log(bs, \"slice_group_count_minus1\") + 1;", "if (pps->slice_group_count > 1) {", "u32 iGroup;", "pps->mb_slice_group_map_type = gf_bs_read_ue_log(bs, \"mb_slice_group_map_type\");", "if (pps->mb_slice_group_map_type == 0) {", "for (iGroup = 0; iGroup <= pps->slice_group_count - 1; iGroup++)", "gf_bs_read_ue_log_idx(bs, \"run_length_minus1\", iGroup);", "}", "else if (pps->mb_slice_group_map_type == 2) {", "for (iGroup = 0; iGroup < pps->slice_group_count - 1; iGroup++) {", "gf_bs_read_ue_log_idx(bs, \"top_left\", iGroup);", "gf_bs_read_ue_log_idx(bs, \"bottom_right\", iGroup);", "}", "}", "else if (pps->mb_slice_group_map_type == 3 || pps->mb_slice_group_map_type == 4 || pps->mb_slice_group_map_type == 5) {", "gf_bs_read_int_log(bs, 1, \"slice_group_change_direction_flag\");", "gf_bs_read_ue_log(bs, \"slice_group_change_rate_minus1\");", "}", "else if (pps->mb_slice_group_map_type == 6) {", "u32 i;", "pps->pic_size_in_map_units_minus1 = gf_bs_read_ue_log(bs, \"pic_size_in_map_units_minus1\");", "for (i = 0; i <= pps->pic_size_in_map_units_minus1; i++) {", "gf_bs_read_int_log_idx(bs, (u32)ceil(log(pps->slice_group_count) / log(2)), \"slice_group_id\", i);", "}", "}", "}", "pps->num_ref_idx_l0_default_active_minus1 = gf_bs_read_ue_log(bs, \"num_ref_idx_l0_default_active_minus1\");", "pps->num_ref_idx_l1_default_active_minus1 = gf_bs_read_ue_log(bs, \"num_ref_idx_l1_default_active_minus1\");", "pps->weighted_pred_flag = gf_bs_read_int_log(bs, 1, \"weighted_pred_flag\");", "gf_bs_read_int_log(bs, 2, \"weighted_bipred_idc\");", "gf_bs_read_se_log(bs, \"init_qp_minus26\");", "gf_bs_read_se_log(bs, \"init_qs_minus26\");", "gf_bs_read_se_log(bs, \"chroma_qp_index_offset\");", "pps->deblocking_filter_control_present_flag = gf_bs_read_int_log(bs, 1, \"deblocking_filter_control_present_flag\");", "gf_bs_read_int_log(bs, 1, \"constrained_intra_pred\");", "pps->redundant_pic_cnt_present = gf_bs_read_int_log(bs, 1, \"redundant_pic_cnt_present\");", "return pps_id;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["exif_data_load_data_thumbnail (ExifData *data, const unsigned char *d,", "unsigned int ds, ExifLong o, ExifLong s)", "{", "if ((o + s < o) || (o + s < s) || (o + s > ds) || (o > ds)) {", "exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",", "\"Bogus thumbnail offset (%u) or size (%u).\",", "o, s);", "return;", "}", "if (data->data)", "exif_mem_free (data->priv->mem, data->data);", "if (!(data->data = exif_data_alloc (data, s))) {", "EXIF_LOG_NO_MEMORY (data->priv->log, \"ExifData\", s);", "data->size = 0;", "return;", "}", "data->size = s;", "memcpy (data->data, d + o, s);", "}"], "ner_tags": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int tcos_decipher(sc_card_t *card, const u8 * crgram, size_t crgram_len, u8 * out, size_t outlen)", "{", "sc_context_t *ctx;", "sc_apdu_t apdu;", "u8 rbuf[SC_MAX_APDU_BUFFER_SIZE];", "u8 sbuf[SC_MAX_APDU_BUFFER_SIZE];", "tcos_data *data;", "int tcos3, r;", "assert(card != NULL && crgram != NULL && out != NULL);", "ctx = card->ctx;", "tcos3=(card->type==SC_CARD_TYPE_TCOS_V3);", "data=(tcos_data *)card->drv_data;", "LOG_FUNC_CALLED(ctx);", "sc_log(ctx,", "\"TCOS3:%d PKCS1:%d\\n\",tcos3,", "!!(data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1));", "sc_format_apdu(card, &apdu, crgram_len>255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT, 0x2A, 0x80, 0x86);", "apdu.resp = rbuf;", "apdu.resplen = sizeof(rbuf);", "apdu.le = crgram_len;", "apdu.data = sbuf;", "apdu.lc = apdu.datalen = crgram_len+1;", "sbuf[0] = tcos3 ? 0x00 : ((data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1) ? 0x81 : 0x02);", "memcpy(sbuf+1, crgram, crgram_len);", "r = sc_transmit_apdu(card, &apdu);", "LOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");", "if (apdu.sw1==0x90 && apdu.sw2==0x00) {", "size_t len= (apdu.resplen>outlen) ? outlen : apdu.resplen;", "unsigned int offset=0;", "if(tcos3 && (data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1) && apdu.resp[0]==0 && apdu.resp[1]==2) {", "offset=2; while(offset<len && apdu.resp[offset]!=0) ++offset;", "offset=(offset<len-1) ? offset+1 : 0;", "}", "memcpy(out, apdu.resp+offset, len-offset);", "SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, len-offset);", "}", "SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, sc_check_sw(card, apdu.sw1, apdu.sw2));", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["PackLinuxElf32::invert_pt_dynamic(Elf32_Dyn const *dynp)", "{", "if (dt_table[Elf32_Dyn::DT_NULL]) {", "return;", "}", "Elf32_Dyn const *const dynp0 = dynp;", "unsigned ndx = 1+ 0;", "if (dynp)", "for (; ; ++ndx, ++dynp) {", "unsigned const d_tag = get_te32(&dynp->d_tag);", "if (d_tag < DT_NUM) {", "if (Elf32_Dyn::DT_NEEDED != d_tag", "&&  dt_table[d_tag]", "&&    get_te32(&dynp->d_val)", "!= get_te32(&dynp0[-1+ dt_table[d_tag]].d_val)) {", "char msg[50]; snprintf(msg, sizeof(msg),", "\"duplicate DT_%#x: [%#x] [%#x]\",", "d_tag, -1+ dt_table[d_tag], -1+ ndx);", "throwCantPack(msg);", "}", "dt_table[d_tag] = ndx;", "}", "if (Elf32_Dyn::DT_NULL == d_tag) {", "break;", "}", "}", "upx_dt_init = 0;", "if (dt_table[Elf32_Dyn::DT_INIT])          upx_dt_init = Elf32_Dyn::DT_INIT;", "else if (dt_table[Elf32_Dyn::DT_PREINIT_ARRAY]) upx_dt_init = Elf32_Dyn::DT_PREINIT_ARRAY;", "else if (dt_table[Elf32_Dyn::DT_INIT_ARRAY])    upx_dt_init = Elf32_Dyn::DT_INIT_ARRAY;", "unsigned const z_str = dt_table[Elf32_Dyn::DT_STRSZ];", "if (z_str) {", "strtab_end = get_te32(&dynp0[-1+ z_str].d_val);", "if ((u32_t)file_size <= strtab_end) {", "char msg[50]; snprintf(msg, sizeof(msg),", "\"bad DT_STRSZ %#x\", strtab_end);", "throwCantPack(msg);", "}", "}", "unsigned const x_sym = dt_table[Elf32_Dyn::DT_SYMTAB];", "unsigned const x_str = dt_table[Elf32_Dyn::DT_STRTAB];", "if (x_sym && x_str) {", "upx_uint32_t const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);", "upx_uint32_t const v_str = get_te32(&dynp0[-1+ x_str].d_val);", "unsigned const  z_sym = dt_table[Elf32_Dyn::DT_SYMENT];", "unsigned const sz_sym = !z_sym ? sizeof(Elf32_Sym)", ": get_te32(&dynp0[-1+ z_sym].d_val);", "if (sz_sym < sizeof(Elf32_Sym)) {", "char msg[50]; snprintf(msg, sizeof(msg),", "\"bad DT_SYMENT %x\", sz_sym);", "throwCantPack(msg);", "}", "if (v_sym < v_str) {", "symnum_end = (v_str - v_sym) / sz_sym;", "}", "if (symnum_end < 1) {", "throwCantPack(\"bad DT_SYMTAB\");", "}", "}", "unsigned const v_hsh = elf_unsigned_dynamic(Elf32_Dyn::DT_HASH);", "if (v_hsh && file_image) {", "hashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_HASH);", "if (!hashtab) {", "char msg[40]; snprintf(msg, sizeof(msg),", "\"bad DT_HASH %#x\", v_hsh);", "throwCantPack(msg);", "}", "unsigned const nbucket = get_te32(&hashtab[0]);", "unsigned const *const buckets = &hashtab[2];", "unsigned const *const chains = &buckets[nbucket]; (void)chains;", "unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);", "if (!nbucket", "|| (nbucket>>31) || (file_size/sizeof(unsigned)) <= (2*nbucket)", "|| ((v_hsh < v_sym) && (v_sym - v_hsh) < (sizeof(unsigned)*2", "+ sizeof(*buckets)*nbucket", "+ sizeof(*chains) *nbucket", "))", ") {", "char msg[90]; snprintf(msg, sizeof(msg),", "\"bad DT_HASH nbucket=%#x  len=%#x\",", "nbucket, (v_sym - v_hsh));", "throwCantPack(msg);", "}", "}", "unsigned const v_gsh = elf_unsigned_dynamic(Elf32_Dyn::DT_GNU_HASH);", "if (v_gsh && file_image) {", "gashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_GNU_HASH);", "if (!gashtab) {", "char msg[40]; snprintf(msg, sizeof(msg),", "\"bad DT_GNU_HASH %#x\", v_gsh);", "throwCantPack(msg);", "}", "unsigned const n_bucket = get_te32(&gashtab[0]);", "unsigned const n_bitmask = get_te32(&gashtab[2]);", "unsigned const gnu_shift = get_te32(&gashtab[3]);", "unsigned const *const bitmask = (unsigned const *)(void const *)&gashtab[4];", "unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask];", "unsigned     const *const hasharr = &buckets[n_bucket]; (void)hasharr;", "unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);", "if (!n_bucket || !n_bitmask", "|| (-1+ n_bitmask) & n_bitmask", "|| 8*sizeof(unsigned) <= gnu_shift", "|| (n_bucket>>30)", "|| (n_bitmask>>30)", "|| (file_size / sizeof(unsigned)) <= (n_bitmask + 2*n_bucket)", "|| ((v_gsh < v_sym) && (v_sym - v_gsh) < (sizeof(unsigned)*4", "+ sizeof(*bitmask)*n_bitmask", "+ sizeof(*buckets)*n_bucket", "+ sizeof(*hasharr)*n_bucket", "))", ") {", "char msg[90]; snprintf(msg, sizeof(msg),", "\"bad DT_GNU_HASH n_bucket=%#x  n_bitmask=%#x  len=%#x\",", "n_bucket, n_bitmask, v_sym - v_gsh);", "throwCantPack(msg);", "}", "}", "unsigned const e_shstrndx = get_te16(&ehdri.e_shstrndx);", "if (e_shnum <= e_shstrndx", "&&  !(0==e_shnum && 0==e_shstrndx) ) {", "char msg[40]; snprintf(msg, sizeof(msg),", "\"bad .e_shstrndx %d >= .e_shnum %d\", e_shstrndx, e_shnum);", "throwCantPack(msg);", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["sc_oberthur_read_file(struct sc_pkcs15_card *p15card, const char *in_path,", "unsigned char **out, size_t *out_len,", "int verify_pin)", "{", "struct sc_context *ctx = p15card->card->ctx;", "struct sc_card *card = p15card->card;", "struct sc_file *file = NULL;", "struct sc_path path;", "size_t sz;", "int rv;", "LOG_FUNC_CALLED(ctx);", "if (!in_path || !out || !out_len)", "LOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Cannot read oberthur file\");", "sc_log(ctx, \"read file '%s'; verify_pin:%i\", in_path, verify_pin);", "*out = NULL;", "*out_len = 0;", "sc_format_path(in_path, &path);", "rv = sc_select_file(card, &path, &file);", "if (rv != SC_SUCCESS) {", "sc_file_free(file);", "LOG_TEST_RET(ctx, rv, \"Cannot select oberthur file to read\");", "}", "if (file->ef_structure == SC_FILE_EF_TRANSPARENT)", "sz = file->size;", "else", "sz = (file->record_length + 2) * file->record_count;", "*out = calloc(sz, 1);", "if (*out == NULL) {", "sc_file_free(file);", "LOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"Cannot read oberthur file\");", "}", "if (file->ef_structure == SC_FILE_EF_TRANSPARENT)   {", "rv = sc_read_binary(card, 0, *out, sz, 0);", "}", "else {", "int rec;", "int offs = 0;", "int rec_len = file->record_length;", "for (rec = 1; ; rec++)   {", "rv = sc_read_record(card, rec, *out + offs + 2, rec_len, SC_RECORD_BY_REC_NR);", "if (rv == SC_ERROR_RECORD_NOT_FOUND)   {", "rv = 0;", "break;", "}", "else if (rv < 0)   {", "break;", "}", "rec_len = rv;", "*(*out + offs) = 'R';", "*(*out + offs + 1) = rv;", "offs += rv + 2;", "}", "sz = offs;", "}", "sc_log(ctx, \"read oberthur file result %i\", rv);", "if (verify_pin && rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)   {", "struct sc_pkcs15_object *objs[0x10], *pin_obj = NULL;", "const struct sc_acl_entry *acl = sc_file_get_acl_entry(file, SC_AC_OP_READ);", "int ii;", "rv = sc_pkcs15_get_objects(p15card, SC_PKCS15_TYPE_AUTH_PIN, objs, 0x10);", "if (rv != SC_SUCCESS) {", "sc_file_free(file);", "LOG_TEST_RET(ctx, rv, \"Cannot read oberthur file: get AUTH objects error\");", "}", "for (ii=0; ii<rv; ii++)   {", "struct sc_pkcs15_auth_info *auth_info = (struct sc_pkcs15_auth_info *) objs[ii]->data;", "sc_log(ctx, \"compare PIN/ACL refs:%i/%i, method:%i/%i\",", "auth_info->attrs.pin.reference, acl->key_ref, auth_info->auth_method, acl->method);", "if (auth_info->attrs.pin.reference == (int)acl->key_ref && auth_info->auth_method == (unsigned)acl->method)   {", "pin_obj = objs[ii];", "break;", "}", "}", "if (!pin_obj || !pin_obj->content.value)    {", "rv = SC_ERROR_SECURITY_STATUS_NOT_SATISFIED;", "}", "else    {", "rv = sc_pkcs15_verify_pin(p15card, pin_obj, pin_obj->content.value, pin_obj->content.len);", "if (!rv)", "rv = sc_oberthur_read_file(p15card, in_path, out, out_len, 0);", "}", "};", "sc_file_free(file);", "if (rv < 0)   {", "free(*out);", "*out = NULL;", "*out_len = 0;", "}", "*out_len = sz;", "LOG_FUNC_RETURN(ctx, rv);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["int flb_gzip_compress(void *in_data, size_t in_len,", "void **out_data, size_t *out_len)", "{", "int flush;", "int status;", "int footer_start;", "uint8_t *pb;", "size_t out_size;", "void *out_buf;", "z_stream strm;", "mz_ulong crc;", "out_size = in_len + 32;", "out_buf = flb_malloc(out_size);", "if (!out_buf) {", "flb_errno();", "flb_error(\"[gzip] could not allocate outgoing buffer\");", "return -1;", "}", "memset(&strm, '\\0', sizeof(strm));", "strm.zalloc    = Z_NULL;", "strm.zfree     = Z_NULL;", "strm.opaque    = Z_NULL;", "strm.next_in   = in_data;", "strm.avail_in  = in_len;", "strm.total_out = 0;", "deflateInit2(&strm, Z_DEFAULT_COMPRESSION,", "Z_DEFLATED, -Z_DEFAULT_WINDOW_BITS, 9, Z_DEFAULT_STRATEGY);", "gzip_header(out_buf);", "pb = (uint8_t *) out_buf + FLB_GZIP_HEADER_OFFSET;", "flush = Z_NO_FLUSH;", "while (1) {", "strm.next_out  = pb + strm.total_out;", "strm.avail_out = out_size - (pb - (uint8_t *) out_buf);", "if (strm.avail_in == 0) {", "flush = Z_FINISH;", "}", "status = deflate(&strm, flush);", "if (status == Z_STREAM_END) {", "break;", "}", "else if (status != Z_OK) {", "deflateEnd(&strm);", "return -1;", "}", "}", "if (deflateEnd(&strm) != Z_OK) {", "flb_free(out_buf);", "return -1;", "}", "*out_len = strm.total_out;", "footer_start = FLB_GZIP_HEADER_OFFSET + *out_len;", "pb = (uint8_t *) out_buf + footer_start;", "crc = mz_crc32(MZ_CRC32_INIT, in_data, in_len);", "*pb++ = crc & 0xFF;", "*pb++ = (crc >> 8) & 0xFF;", "*pb++ = (crc >> 16) & 0xFF;", "*pb++ = (crc >> 24) & 0xFF;", "*pb++ = in_len & 0xFF;", "*pb++ = (in_len >> 8) & 0xFF;", "*pb++ = (in_len >> 16) & 0xFF;", "*pb++ = (in_len >> 24) & 0xFF;", "*out_len += FLB_GZIP_HEADER_OFFSET + 8;", "*out_data = out_buf;", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["sec_decrypt(uint8 * data, int length)", "{", "if (g_sec_decrypt_use_count == 4096)", "{", "sec_update(g_sec_decrypt_key, g_sec_decrypt_update_key);", "rdssl_rc4_set_key(&g_rc4_decrypt_key, g_sec_decrypt_key, g_rc4_key_len);", "g_sec_decrypt_use_count = 0;", "}", "rdssl_rc4_crypt(&g_rc4_decrypt_key, data, data, length);", "g_sec_decrypt_use_count++;", "}"], "ner_tags": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static GF_Err gf_isom_parse_movie_boxes_internal(GF_ISOFile *mov, u32 *boxType, u64 *bytesMissing, Bool progressive_mode)", "{", "GF_Box *a;", "u64 totSize, mdat_end=0;", "GF_Err e = GF_OK;", "#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS", "if (mov->single_moof_mode && mov->single_moof_state == 2) {", "return e;", "}", "totSize = mov->current_top_box_start;", "if (mov->bytes_removed) {", "assert(totSize >= mov->bytes_removed);", "totSize -= mov->bytes_removed;", "}", "gf_bs_seek(mov->movieFileMap->bs, totSize);", "#endif", "while (gf_bs_available(mov->movieFileMap->bs)) {", "*bytesMissing = 0;", "#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS", "mov->current_top_box_start = gf_bs_get_position(mov->movieFileMap->bs) + mov->bytes_removed;", "GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Parsing a top-level box at position %d\\n\", mov->current_top_box_start));", "#endif", "e = gf_isom_parse_root_box(&a, mov->movieFileMap->bs, boxType, bytesMissing, progressive_mode);", "if (e >= 0) {", "} else if (e == GF_ISOM_INCOMPLETE_FILE) {", "if (mov->openMode != GF_ISOM_OPEN_READ) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Incomplete MDAT while file is not read-only\\n\"));", "return GF_ISOM_INVALID_FILE;", "}", "if ((mov->openMode == GF_ISOM_OPEN_READ) && !progressive_mode) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Incomplete file while reading for dump - aborting parsing\\n\"));", "break;", "}", "return e;", "} else {", "return e;", "}", "switch (a->type) {", "case GF_ISOM_BOX_TYPE_MOOV:", "if (mov->moov) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate MOOV detected!\\n\"));", "gf_isom_box_del(a);", "return GF_ISOM_INVALID_FILE;", "}", "mov->moov = (GF_MovieBox *)a;", "mov->original_moov_offset = mov->current_top_box_start;", "mov->moov->mov = mov;", "#ifndef GPAC_DISABLE_ISOM_FRAGMENTS", "if (mov->moov->mvex) mov->moov->mvex->mov = mov;", "#ifdef GF_ENABLE_CTRN", "if (! (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {", "gf_isom_setup_traf_inheritance(mov);", "}", "#endif", "#endif", "e = gf_list_add(mov->TopBoxes, a);", "if (e) return e;", "totSize += a->size;", "if (!mov->moov->mvhd) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MovieHeaderBox\\n\"));", "return GF_ISOM_INVALID_FILE;", "}", "if (mov->meta) {", "gf_isom_meta_restore_items_ref(mov, mov->meta);", "}", "if (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {", "u32 k;", "for (k=0; k<gf_list_count(mov->moov->trackList); k++) {", "GF_TrackBox *trak = (GF_TrackBox *)gf_list_get(mov->moov->trackList, k);", "if (trak->sample_encryption) {", "e = senc_Parse(mov->movieFileMap->bs, trak, NULL, trak->sample_encryption);", "if (e) return e;", "}", "}", "} else {", "u32 k;", "for (k=0; k<gf_list_count(mov->moov->trackList); k++) {", "GF_TrackBox *trak = (GF_TrackBox *)gf_list_get(mov->moov->trackList, k);", "if (trak->Media->information->sampleTable->sampleGroups) {", "convert_compact_sample_groups(trak->Media->information->sampleTable->child_boxes, trak->Media->information->sampleTable->sampleGroups);", "}", "}", "}", "if (mdat_end && mov->signal_frag_bounds && !(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) ) {", "gf_isom_push_mdat_end(mov, mdat_end);", "mdat_end=0;", "}", "break;", "case GF_ISOM_BOX_TYPE_META:", "if (mov->meta) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate META detected!\\n\"));", "gf_isom_box_del(a);", "return GF_ISOM_INVALID_FILE;", "}", "mov->meta = (GF_MetaBox *)a;", "mov->original_meta_offset = mov->current_top_box_start;", "e = gf_list_add(mov->TopBoxes, a);", "if (e) {", "return e;", "}", "totSize += a->size;", "if (mov->moov) {", "gf_isom_meta_restore_items_ref(mov, mov->meta);", "}", "break;", "case GF_ISOM_BOX_TYPE_MDAT:", "if (!mov->first_data_toplevel_offset) {", "mov->first_data_toplevel_offset = mov->current_top_box_start;", "mov->first_data_toplevel_size = a->size;", "}", "totSize += a->size;", "if (mov->openMode == GF_ISOM_OPEN_READ) {", "if (!mov->mdat) {", "mov->mdat = (GF_MediaDataBox *) a;", "e = gf_list_add(mov->TopBoxes, mov->mdat);", "if (e) {", "return e;", "}", "}", "#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS", "else if (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) gf_list_add(mov->TopBoxes, a);", "#endif", "else gf_isom_box_del(a);", "if (mov->signal_frag_bounds && !(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) ) {", "mdat_end = gf_bs_get_position(mov->movieFileMap->bs);", "if (mov->moov) {", "gf_isom_push_mdat_end(mov, mdat_end);", "mdat_end=0;", "}", "}", "}", "else if (!mov->mdat && (mov->openMode != GF_ISOM_OPEN_READ) && (mov->openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS)) {", "gf_isom_box_del(a);", "mov->mdat = (GF_MediaDataBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MDAT);", "if (!mov->mdat) return GF_OUT_OF_MEM;", "e = gf_list_add(mov->TopBoxes, mov->mdat);", "if (e) {", "return e;", "}", "} else {", "gf_isom_box_del(a);", "}", "break;", "case GF_ISOM_BOX_TYPE_FTYP:", "if (mov->brand) {", "gf_isom_box_del(a);", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate 'ftyp' detected!\\n\"));", "return GF_ISOM_INVALID_FILE;", "}", "mov->brand = (GF_FileTypeBox *)a;", "totSize += a->size;", "e = gf_list_add(mov->TopBoxes, a);", "if (e) return e;", "break;", "case GF_ISOM_BOX_TYPE_OTYP:", "if (mov->otyp) {", "gf_isom_box_del(a);", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate 'otyp' detected!\\n\"));", "return GF_ISOM_INVALID_FILE;", "}", "if (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {", "mov->otyp = (GF_Box *)a;", "totSize += a->size;", "e = gf_list_add(mov->TopBoxes, a);", "if (e) return e;", "} else {", "GF_FileTypeBox *brand = (GF_FileTypeBox *) gf_isom_box_find_child(a->child_boxes, GF_ISOM_BOX_TYPE_FTYP);", "if (brand) {", "s32 pos;", "gf_list_del_item(a->child_boxes, brand);", "pos = gf_list_del_item(mov->TopBoxes, mov->brand);", "gf_isom_box_del((GF_Box *) mov->brand);", "mov->brand = brand;", "if (pos<0) pos=0;", "gf_list_insert(mov->TopBoxes, brand, pos);", "}", "}", "break;", "case GF_ISOM_BOX_TYPE_PDIN:", "if (mov->pdin) {", "gf_isom_box_del(a);", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate 'pdin'' detected!\\n\"));", "return GF_ISOM_INVALID_FILE;", "}", "mov->pdin = (GF_ProgressiveDownloadBox *) a;", "totSize += a->size;", "e = gf_list_add(mov->TopBoxes, a);", "if (e) return e;", "break;", "#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS", "case GF_ISOM_BOX_TYPE_STYP:", "{", "u32 brand = ((GF_FileTypeBox *)a)->majorBrand;", "switch (brand) {", "case GF_ISOM_BRAND_SISX:", "case GF_ISOM_BRAND_RISX:", "case GF_ISOM_BRAND_SSSS:", "mov->is_index_segment = GF_TRUE;", "break;", "default:", "break;", "}", "}", "case GF_ISOM_BOX_TYPE_SIDX:", "case GF_ISOM_BOX_TYPE_SSIX:", "if (mov->moov && !mov->first_data_toplevel_offset) {", "mov->first_data_toplevel_offset = mov->current_top_box_start;", "mov->first_data_toplevel_size = a->size;", "}", "totSize += a->size;", "if (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {", "e = gf_list_add(mov->TopBoxes, a);", "if (e) return e;", "} else if (mov->signal_frag_bounds && !(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)  && (mov->openMode!=GF_ISOM_OPEN_KEEP_FRAGMENTS)", ") {", "if (a->type==GF_ISOM_BOX_TYPE_SIDX) {", "if (mov->root_sidx) gf_isom_box_del( (GF_Box *) mov->root_sidx);", "mov->root_sidx = (GF_SegmentIndexBox *) a;", "mov->sidx_start_offset = mov->current_top_box_start;", "mov->sidx_end_offset = gf_bs_get_position(mov->movieFileMap->bs);", "}", "else if (a->type==GF_ISOM_BOX_TYPE_STYP) {", "mov->styp_start_offset = mov->current_top_box_start;", "if (mov->seg_styp) gf_isom_box_del(mov->seg_styp);", "mov->seg_styp = a;", "} else if (a->type==GF_ISOM_BOX_TYPE_SSIX) {", "if (mov->seg_ssix) gf_isom_box_del(mov->seg_ssix);", "mov->seg_ssix = a;", "} else {", "gf_isom_box_del(a);", "}", "gf_isom_push_mdat_end(mov, mov->current_top_box_start);", "} else if (!mov->NextMoofNumber && (a->type==GF_ISOM_BOX_TYPE_SIDX)) {", "if (mov->main_sidx) gf_isom_box_del( (GF_Box *) mov->main_sidx);", "mov->main_sidx = (GF_SegmentIndexBox *) a;", "mov->main_sidx_end_pos = mov->current_top_box_start + a->size;", "} else {", "gf_isom_box_del(a);", "}", "break;", "case GF_ISOM_BOX_TYPE_MOOF:", "gf_isom_disable_inplace_rewrite(mov);", "if (!mov->moov) {", "GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Movie fragment but no moov (yet) - possibly broken parsing!\\n\"));", "}", "if (mov->single_moof_mode) {", "mov->single_moof_state++;", "if (mov->single_moof_state > 1) {", "gf_isom_box_del(a);", "return GF_OK;", "}", "}", "((GF_MovieFragmentBox *)a)->mov = mov;", "totSize += a->size;", "mov->moof = (GF_MovieFragmentBox *) a;", "FixTrackID(mov);", "if (! (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {", "FixSDTPInTRAF(mov->moof);", "} else {", "u32 k;", "for (k=0; k<gf_list_count(mov->moof->TrackList); k++) {", "GF_TrackFragmentBox *traf = (GF_TrackFragmentBox *)gf_list_get(mov->moof->TrackList, k);", "if (traf->sampleGroups) {", "convert_compact_sample_groups(traf->child_boxes, traf->sampleGroups);", "}", "}", "}", "if (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {", "u32 k;", "gf_list_add(mov->TopBoxes, a);", "if (mov->moov) {", "for (k=0; k<gf_list_count(mov->moof->TrackList); k++) {", "GF_TrackFragmentBox *traf = gf_list_get(mov->moof->TrackList, k);", "if (traf->tfhd && mov->moov->mvex && mov->moov->mvex->TrackExList) {", "GF_TrackBox *trak = gf_isom_get_track_from_id(mov->moov, traf->tfhd->trackID);", "u32 j=0;", "while ((traf->trex = (GF_TrackExtendsBox*)gf_list_enum(mov->moov->mvex->TrackExList, &j))) {", "if (traf->trex->trackID == traf->tfhd->trackID) {", "if (!traf->trex->track) traf->trex->track = trak;", "break;", "}", "traf->trex = NULL;", "}", "}", "if (traf->trex && traf->tfhd && traf->trex->track && traf->sample_encryption) {", "GF_TrackBox *trak = GetTrackbyID(mov->moov, traf->tfhd->trackID);", "trak->current_traf_stsd_idx = traf->tfhd->sample_desc_index ? traf->tfhd->sample_desc_index : traf->trex->def_sample_desc_index;", "e = senc_Parse(mov->movieFileMap->bs, trak, traf, traf->sample_encryption);", "if (e) return e;", "trak->current_traf_stsd_idx = 0;", "}", "}", "} else {", "for (k=0; k<gf_list_count(mov->moof->TrackList); k++) {", "GF_TrackFragmentBox *traf = gf_list_get(mov->moof->TrackList, k);", "if (traf->sample_encryption) {", "e = senc_Parse(mov->movieFileMap->bs, NULL, traf, traf->sample_encryption);", "if (e) return e;", "}", "}", "}", "} else if (mov->openMode==GF_ISOM_OPEN_KEEP_FRAGMENTS) {", "mov->NextMoofNumber = mov->moof->mfhd->sequence_number+1;", "mov->moof = NULL;", "gf_isom_box_del(a);", "} else {", "e = MergeFragment((GF_MovieFragmentBox *)a, mov);", "gf_isom_box_del(a);", "if (e) return e;", "}", "if (mov->root_sidx) {", "gf_isom_box_del((GF_Box *) mov->root_sidx);", "mov->root_sidx = NULL;", "}", "if (mov->root_ssix) {", "gf_isom_box_del(mov->seg_ssix);", "mov->root_ssix = NULL;", "}", "if (mov->seg_styp) {", "gf_isom_box_del(mov->seg_styp);", "mov->seg_styp = NULL;", "}", "mov->sidx_start_offset = 0;", "mov->sidx_end_offset = 0;", "mov->styp_start_offset = 0;", "break;", "#endif", "case GF_ISOM_BOX_TYPE_UNKNOWN:", "{", "GF_UnknownBox *box = (GF_UnknownBox*)a;", "if (box->original_4cc == GF_ISOM_BOX_TYPE_JP) {", "u8 *c = (u8 *) box->data;", "if ((box->dataSize==4) && (GF_4CC(c[0],c[1],c[2],c[3])==(u32)0x0D0A870A))", "mov->is_jp2 = 1;", "gf_isom_box_del(a);", "} else {", "e = gf_list_add(mov->TopBoxes, a);", "if (e) return e;", "}", "}", "break;", "case GF_ISOM_BOX_TYPE_PRFT:", "#ifndef GPAC_DISABLE_ISOM_FRAGMENTS", "if (!(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {", "if (mov->last_producer_ref_time)", "gf_isom_box_del(a);", "else", "mov->last_producer_ref_time = (GF_ProducerReferenceTimeBox *)a;", "break;", "}", "#endif", "default:", "totSize += a->size;", "e = gf_list_add(mov->TopBoxes, a);", "if (e) return e;", "break;", "}", "#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS", "mov->current_top_box_start = gf_bs_get_position(mov->movieFileMap->bs) + mov->bytes_removed;", "#endif", "}", "if (!mov->moov && !mov->meta", "#ifndef GPAC_DISABLE_ISOM_FRAGMENTS", "&& !mov->moof && !mov->is_index_segment", "#endif", ") {", "return GF_ISOM_INCOMPLETE_FILE;", "}", "if (!gf_opts_get_bool(\"core\", \"no-check\")) {", "if (mov->moov && !mov->moov->mvhd) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MVHD in MOOV!\\n\"));", "return GF_ISOM_INVALID_FILE;", "}", "if (mov->meta && !mov->meta->handler) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing handler in META!\\n\"));", "return GF_ISOM_INVALID_FILE;", "}", "}", "#ifndef GPAC_DISABLE_ISOM_WRITE", "if (mov->moov) {", "mov->interleavingTime = mov->moov->mvhd->timeScale;", "#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS", "if ((mov->openMode > GF_ISOM_OPEN_READ) && (mov->openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS) && mov->moov->mvex) {", "gf_isom_box_del_parent(&mov->moov->child_boxes, (GF_Box *)mov->moov->mvex);", "mov->moov->mvex = NULL;", "}", "#endif", "}", "if (!mov->mdat && (mov->openMode != GF_ISOM_OPEN_READ) && (mov->openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS)) {", "mov->mdat = (GF_MediaDataBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MDAT);", "if (!mov->mdat) return GF_OUT_OF_MEM;", "e = gf_list_add(mov->TopBoxes, mov->mdat);", "if (e) return e;", "}", "#endif /*GPAC_DISABLE_ISOM_WRITE*/", "return GF_OK;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static ExprList *exprListAppendList(", "Parse *pParse,", "ExprList *pList,", "ExprList *pAppend,", "int bIntToNull", "){", "if( pAppend ){", "int i;", "int nInit = pList ? pList->nExpr : 0;", "for(i=0; i<pAppend->nExpr; i++){", "Expr *pDup = sqlite3ExprDup(pParse->db, pAppend->a[i].pExpr, 0);", "if( bIntToNull && pDup && pDup->op==TK_INTEGER ){", "pDup->op = TK_NULL;", "pDup->flags &= ~(EP_IntValue|EP_IsTrue|EP_IsFalse);", "}", "pList = sqlite3ExprListAppend(pParse, pList, pDup);", "if( pList ) pList->a[nInit+i].sortFlags = pAppend->a[i].sortFlags;", "}", "}", "return pList;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["NO_INLINE JsVar *jspeStatement() {", "#ifdef USE_DEBUGGER", "if (execInfo.execute&EXEC_DEBUGGER_NEXT_LINE &&", "lex->tk!=';' &&", "JSP_SHOULD_EXECUTE) {", "lex->tokenLastStart = jsvStringIteratorGetIndex(&lex->tokenStart.it)-1;", "jsiDebuggerLoop();", "}", "#endif", "if (lex->tk==LEX_ID ||", "lex->tk==LEX_INT ||", "lex->tk==LEX_FLOAT ||", "lex->tk==LEX_STR ||", "lex->tk==LEX_TEMPLATE_LITERAL ||", "lex->tk==LEX_REGEX ||", "lex->tk==LEX_R_NEW ||", "lex->tk==LEX_R_NULL ||", "lex->tk==LEX_R_UNDEFINED ||", "lex->tk==LEX_R_TRUE ||", "lex->tk==LEX_R_FALSE ||", "lex->tk==LEX_R_THIS ||", "lex->tk==LEX_R_DELETE ||", "lex->tk==LEX_R_TYPEOF ||", "lex->tk==LEX_R_VOID ||", "lex->tk==LEX_R_SUPER ||", "lex->tk==LEX_PLUSPLUS ||", "lex->tk==LEX_MINUSMINUS ||", "lex->tk=='!' ||", "lex->tk=='-' ||", "lex->tk=='+' ||", "lex->tk=='~' ||", "lex->tk=='[' ||", "lex->tk=='(') {", "return jspeExpression();", "} else if (lex->tk=='{') {", "jspeBlock();", "return 0;", "} else if (lex->tk==';') {", "JSP_ASSERT_MATCH(';');", "return 0;", "} else if (lex->tk==LEX_R_VAR ||", "lex->tk==LEX_R_LET ||", "lex->tk==LEX_R_CONST) {", "return jspeStatementVar();", "} else if (lex->tk==LEX_R_IF) {", "return jspeStatementIf();", "} else if (lex->tk==LEX_R_DO) {", "return jspeStatementDoOrWhile(false);", "} else if (lex->tk==LEX_R_WHILE) {", "return jspeStatementDoOrWhile(true);", "} else if (lex->tk==LEX_R_FOR) {", "return jspeStatementFor();", "} else if (lex->tk==LEX_R_TRY) {", "return jspeStatementTry();", "} else if (lex->tk==LEX_R_RETURN) {", "return jspeStatementReturn();", "} else if (lex->tk==LEX_R_THROW) {", "return jspeStatementThrow();", "} else if (lex->tk==LEX_R_FUNCTION) {", "return jspeStatementFunctionDecl(false              );", "#ifndef SAVE_ON_FLASH", "} else if (lex->tk==LEX_R_CLASS) {", "return jspeStatementFunctionDecl(true           );", "#endif", "} else if (lex->tk==LEX_R_CONTINUE) {", "JSP_ASSERT_MATCH(LEX_R_CONTINUE);", "if (JSP_SHOULD_EXECUTE) {", "if (!(execInfo.execute & EXEC_IN_LOOP))", "jsExceptionHere(JSET_SYNTAXERROR, \"CONTINUE statement outside of FOR or WHILE loop\");", "else", "execInfo.execute = (execInfo.execute & (JsExecFlags)~EXEC_RUN_MASK) | EXEC_CONTINUE;", "}", "} else if (lex->tk==LEX_R_BREAK) {", "JSP_ASSERT_MATCH(LEX_R_BREAK);", "if (JSP_SHOULD_EXECUTE) {", "if (!(execInfo.execute & (EXEC_IN_LOOP|EXEC_IN_SWITCH)))", "jsExceptionHere(JSET_SYNTAXERROR, \"BREAK statement outside of SWITCH, FOR or WHILE loop\");", "else", "execInfo.execute = (execInfo.execute & (JsExecFlags)~EXEC_RUN_MASK) | EXEC_BREAK;", "}", "} else if (lex->tk==LEX_R_SWITCH) {", "return jspeStatementSwitch();", "} else if (lex->tk==LEX_R_DEBUGGER) {", "JSP_ASSERT_MATCH(LEX_R_DEBUGGER);", "#ifdef USE_DEBUGGER", "if (JSP_SHOULD_EXECUTE)", "jsiDebuggerLoop();", "#endif", "} else JSP_MATCH(LEX_EOF);", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["exif_data_load_data (ExifData *data, const unsigned char *d_orig,", "unsigned int ds)", "{", "unsigned int l;", "ExifLong offset;", "ExifShort n;", "const unsigned char *d = d_orig;", "unsigned int len, fullds;", "if (!data || !data->priv || !d || !ds)", "return;", "exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",", "\"Parsing %i byte(s) EXIF data...\\n\", ds);", "if (ds < 6) {", "LOG_TOO_SMALL;", "return;", "}", "if (!memcmp (d, ExifHeader, 6)) {", "exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",", "\"Found EXIF header at start.\");", "} else {", "while (ds >= 3) {", "while (ds && (d[0] == 0xff)) {", "d++;", "ds--;", "}", "if (ds && d[0] == JPEG_MARKER_SOI) {", "d++;", "ds--;", "continue;", "}", "if (ds && d[0] == JPEG_MARKER_APP1)", "break;", "if (ds >= 3 && d[0] >= 0xe0 && d[0] <= 0xef) {", "d++;", "ds--;", "l = (d[0] << 8) | d[1];", "if (l > ds)", "return;", "d += l;", "ds -= l;", "continue;", "}", "exif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA,", "\"ExifData\", _(\"EXIF marker not found.\"));", "return;", "}", "if (ds < 3) {", "LOG_TOO_SMALL;", "return;", "}", "d++;", "ds--;", "len = (d[0] << 8) | d[1];", "exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",", "\"We have to deal with %i byte(s) of EXIF data.\",", "len);", "d += 2;", "ds -= 2;", "}", "if (ds < 6) {", "LOG_TOO_SMALL;", "return;", "}", "if (memcmp (d, ExifHeader, 6)) {", "exif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA,", "\"ExifData\", _(\"EXIF header not found.\"));", "return;", "}", "exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",", "\"Found EXIF header.\");", "if (ds < 14)", "return;", "fullds = ds;", "if (ds > 0xfffe)", "ds = 0xfffe;", "if (!memcmp (d + 6, \"II\", 2))", "data->priv->order = EXIF_BYTE_ORDER_INTEL;", "else if (!memcmp (d + 6, \"MM\", 2))", "data->priv->order = EXIF_BYTE_ORDER_MOTOROLA;", "else {", "exif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA,", "\"ExifData\", _(\"Unknown encoding.\"));", "return;", "}", "if (exif_get_short (d + 8, data->priv->order) != 0x002a)", "return;", "offset = exif_get_long (d + 10, data->priv->order);", "exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",", "\"IFD 0 at %i.\", (int) offset);", "if (offset > ds || offset + 6 + 2 > ds)", "return;", "exif_data_load_data_content (data, EXIF_IFD_0, d + 6, ds - 6, offset, 0);", "n = exif_get_short (d + 6 + offset, data->priv->order);", "if (offset + 6 + 2 + 12 * n + 4 > ds)", "return;", "offset = exif_get_long (d + 6 + offset + 2 + 12 * n, data->priv->order);", "if (offset) {", "exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",", "\"IFD 1 at %i.\", (int) offset);", "if (offset > ds || offset + 6 > ds) {", "exif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA,", "\"ExifData\", \"Bogus offset of IFD1.\");", "} else {", "exif_data_load_data_content (data, EXIF_IFD_1, d + 6, ds - 6, offset, 0);", "}", "}", "interpret_maker_note(data, d, fullds);", "if (data->priv->options & EXIF_DATA_OPTION_FOLLOW_SPECIFICATION)", "exif_data_fix (data);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["int sqlite3CheckObjectName(", "Parse *pParse,", "const char *zName,", "const char *zType,", "const char *zTblName", "){", "sqlite3 *db = pParse->db;", "if( sqlite3WritableSchema(db) || db->init.imposterTable ){", "return SQLITE_OK;", "}", "if( db->init.busy ){", "if( sqlite3_stricmp(zType, db->init.azInit[0])", "|| sqlite3_stricmp(zName, db->init.azInit[1])", "|| sqlite3_stricmp(zTblName, db->init.azInit[2])", "){", "if( sqlite3Config.bExtraSchemaChecks ){", "sqlite3ErrorMsg(pParse, \"\");", "return SQLITE_ERROR;", "}", "}", "}else{", "if( pParse->nested==0", "&& 0==sqlite3StrNICmp(zName, \"sqlite_\", 7)", "){", "sqlite3ErrorMsg(pParse, \"object name reserved for internal use: %s\",", "zName);", "return SQLITE_ERROR;", "}", "}", "return SQLITE_OK;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": [" static void ikev2_parent_inI2outR2_continue(struct pluto_crypto_req_cont *pcrc,", " \t\t\t\t\t    struct pluto_crypto_req *r,", " \t\t\t\t\t    err_t ugh)", " {", " \tstruct dh_continuation *dh = (struct dh_continuation *)pcrc;", " \tstruct msg_digest *md = dh->md;", " \tstruct state *const st = md->st;", " \tstf_status e;", " \tDBG(DBG_CONTROLMORE,", " \t    DBG_log(\"ikev2 parent inI2outR2: calculating g^{xy}, sending R2\"));", " \tif (st == NULL) {", " \t\tloglog(RC_LOG_SERIOUS,", " \t\t       \"%s: Request was disconnected from state\",", " \t\t       __FUNCTION__);", " \t\tif (dh->md)", " \t\t\trelease_md(dh->md);", " \t\treturn;", " \t}", " \tpassert(ugh == NULL);", " \tpassert(cur_state == NULL);", " \tpassert(st != NULL);", " \tpassert(st->st_suspended_md == dh->md);", " \tset_suspended(st, NULL);  ", " \tset_cur_state(st);", " \tst->st_calculating = FALSE;", " \te = ikev2_parent_inI2outR2_tail(pcrc, r);", " \tif ( e > STF_FAIL) {", " \t\tint v2_notify_num = e - STF_FAIL;", " \t\tDBG_log(", " \t\t\t\"ikev2_parent_inI2outR2_tail returned STF_FAIL with %s\",", " \t\t\tenum_name(&ikev2_notify_names, v2_notify_num));", " \t} else if ( e != STF_OK) {", " \t\tDBG_log(\"ikev2_parent_inI2outR2_tail returned %s\",", " \t\t\tenum_name(&stfstatus_name, e));", " \t}", " \tif (dh->md != NULL) {", " \t\tcomplete_v2_state_transition(&dh->md, e);", " \t\tif (dh->md)", "  \t\t\trelease_md(dh->md);", "  \t}", "  \treset_globals();", "\tpassert(GLOBALS_ARE_RESET());", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": [" zip_read_mac_metadata(struct archive_read *a, struct archive_entry *entry,", "     struct zip_entry *rsrc)", " {", " \tstruct zip *zip = (struct zip *)a->format->data;", " \tunsigned char *metadata, *mp;", " \tint64_t offset = archive_filter_bytes(&a->archive, 0);", " \tsize_t remaining_bytes, metadata_bytes;", " \tssize_t hsize;", " \tint ret = ARCHIVE_OK, eof;", "  \tswitch(rsrc->compression) {", "  \tcase 0:   ", " \t\tif (rsrc->uncompressed_size != rsrc->compressed_size) {", " \t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", " \t\t\t    \"Malformed OS X metadata entry: inconsistent size\");", " \t\t\treturn (ARCHIVE_FATAL);", " \t\t}", "  #ifdef HAVE_ZLIB_H", "  \tcase 8:  ", "  #endif", " \t\tbreak;", " \tdefault:  ", " \t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", " \t\t    \"Unsupported ZIP compression method (%s)\",", " \t\t    compression_name(rsrc->compression));", " \t\treturn (ARCHIVE_WARN);", " \t}", " \tif (rsrc->uncompressed_size > (4 * 1024 * 1024)) {", " \t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", " \t\t    \"Mac metadata is too large: %jd > 4M bytes\",", "  \t\t    (intmax_t)rsrc->uncompressed_size);", "  \t\treturn (ARCHIVE_WARN);", "  \t}", " \tif (rsrc->compressed_size > (4 * 1024 * 1024)) {", " \t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", " \t\t    \"Mac metadata is too large: %jd > 4M bytes\",", " \t\t    (intmax_t)rsrc->compressed_size);", " \t\treturn (ARCHIVE_WARN);", " \t}", "  \tmetadata = malloc((size_t)rsrc->uncompressed_size);", "  \tif (metadata == NULL) {", " \t\tarchive_set_error(&a->archive, ENOMEM,", " \t\t    \"Can't allocate memory for Mac metadata\");", " \t\treturn (ARCHIVE_FATAL);", " \t}", " \tif (offset < rsrc->local_header_offset)", " \t\t__archive_read_consume(a, rsrc->local_header_offset - offset);", " \telse if (offset != rsrc->local_header_offset) {", " \t\t__archive_read_seek(a, rsrc->local_header_offset, SEEK_SET);", " \t}", " \thsize = zip_get_local_file_header_size(a, 0);", " \t__archive_read_consume(a, hsize);", " \tremaining_bytes = (size_t)rsrc->compressed_size;", " \tmetadata_bytes = (size_t)rsrc->uncompressed_size;", " \tmp = metadata;", " \teof = 0;", " \twhile (!eof && remaining_bytes) {", " \t\tconst unsigned char *p;", " \t\tssize_t bytes_avail;", " \t\tsize_t bytes_used;", " \t\tp = __archive_read_ahead(a, 1, &bytes_avail);", " \t\tif (p == NULL) {", " \t\t\tarchive_set_error(&a->archive,", " \t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,", " \t\t\t    \"Truncated ZIP file header\");", " \t\t\tret = ARCHIVE_WARN;", " \t\t\tgoto exit_mac_metadata;", " \t\t}", " \t\tif ((size_t)bytes_avail > remaining_bytes)", "  \t\t\tbytes_avail = remaining_bytes;", "  \t\tswitch(rsrc->compression) {", "  \t\tcase 0:   ", " \t\t\tif ((size_t)bytes_avail > metadata_bytes)", " \t\t\t\tbytes_avail = metadata_bytes;", "  \t\t\tmemcpy(mp, p, bytes_avail);", "  \t\t\tbytes_used = (size_t)bytes_avail;", "  \t\t\tmetadata_bytes -= bytes_used;", " \t\t\tmp += bytes_used;", " \t\t\tif (metadata_bytes == 0)", " \t\t\t\teof = 1;", " \t\t\tbreak;", " #ifdef HAVE_ZLIB_H", " \t\tcase 8:  ", " \t\t{", " \t\t\tint r;", " \t\t\tret = zip_deflate_init(a, zip);", " \t\t\tif (ret != ARCHIVE_OK)", " \t\t\t\tgoto exit_mac_metadata;", " \t\t\tzip->stream.next_in =", " \t\t\t    (Bytef *)(uintptr_t)(const void *)p;", " \t\t\tzip->stream.avail_in = (uInt)bytes_avail;", " \t\t\tzip->stream.total_in = 0;", " \t\t\tzip->stream.next_out = mp;", " \t\t\tzip->stream.avail_out = (uInt)metadata_bytes;", " \t\t\tzip->stream.total_out = 0;", " \t\t\tr = inflate(&zip->stream, 0);", " \t\t\tswitch (r) {", " \t\t\tcase Z_OK:", " \t\t\t\tbreak;", " \t\t\tcase Z_STREAM_END:", " \t\t\t\teof = 1;", " \t\t\t\tbreak;", " \t\t\tcase Z_MEM_ERROR:", " \t\t\t\tarchive_set_error(&a->archive, ENOMEM,", " \t\t\t\t    \"Out of memory for ZIP decompression\");", " \t\t\t\tret = ARCHIVE_FATAL;", " \t\t\t\tgoto exit_mac_metadata;", " \t\t\tdefault:", " \t\t\t\tarchive_set_error(&a->archive,", " \t\t\t\t    ARCHIVE_ERRNO_MISC,", " \t\t\t\t    \"ZIP decompression failed (%d)\", r);", " \t\t\t\tret = ARCHIVE_FATAL;", " \t\t\t\tgoto exit_mac_metadata;", " \t\t\t}", " \t\t\tbytes_used = zip->stream.total_in;", " \t\t\tmetadata_bytes -= zip->stream.total_out;", " \t\t\tmp += zip->stream.total_out;", " \t\t\tbreak;", " \t\t}", " #endif", " \t\tdefault:", " \t\t\tbytes_used = 0;", " \t\t\tbreak;", " \t\t}", " \t\t__archive_read_consume(a, bytes_used);", " \t\tremaining_bytes -= bytes_used;", " \t}", " \tarchive_entry_copy_mac_metadata(entry, metadata,", " \t    (size_t)rsrc->uncompressed_size - metadata_bytes);", " exit_mac_metadata:", " \t__archive_read_seek(a, offset, SEEK_SET);", " \tzip->decompress_init = 0;", " \tfree(metadata);", " \treturn (ret);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void diff_bytes_c(uint8_t *dst, const uint8_t *src1, const uint8_t *src2, int w){", "     long i;", " #if !HAVE_FAST_UNALIGNED", "     if((long)src2 & (sizeof(long)-1)){", "         for(i=0; i+7<w; i+=8){", "             dst[i+0] = src1[i+0]-src2[i+0];", "             dst[i+1] = src1[i+1]-src2[i+1];", "             dst[i+2] = src1[i+2]-src2[i+2];", "             dst[i+3] = src1[i+3]-src2[i+3];", "             dst[i+4] = src1[i+4]-src2[i+4];", "             dst[i+5] = src1[i+5]-src2[i+5];", "             dst[i+6] = src1[i+6]-src2[i+6];", "             dst[i+7] = src1[i+7]-src2[i+7];", "          }", "      }else", "  #endif", "    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){", "     for(i=0; i<=w-(int)sizeof(long); i+=sizeof(long)){", "          long a = *(long*)(src1+i);", "          long b = *(long*)(src2+i);", "          *(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);", "     }", "     for(; i<w; i++)", "         dst[i+0] = src1[i+0]-src2[i+0];", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void vrend_renderer_init_blit_ctx(struct vrend_blitter_ctx *blit_ctx)", " {", "    struct virgl_gl_ctx_param ctx_params;", "    int i;", "    if (blit_ctx->initialised) {", "       vrend_clicbs->make_current(0, blit_ctx->gl_context);", "        return;", "     }", "    blit_ctx->initialised = true;", "     ctx_params.shared = true;", "     ctx_params.major_ver = VREND_GL_VER_MAJOR;", "     ctx_params.minor_ver = VREND_GL_VER_MINOR;", "    vrend_clicbs->make_current(0, blit_ctx->gl_context);", "    glGenVertexArrays(1, &blit_ctx->vaoid);", "    glGenFramebuffers(1, &blit_ctx->fb_id);", "    glGenBuffers(1, &blit_ctx->vbo_id);", "    blit_build_vs_passthrough(blit_ctx);", "    for (i = 0; i < 4; i++)", "       blit_ctx->vertices[i][0][3] = 1;  ", "    glBindVertexArray(blit_ctx->vaoid);", "    glBindBuffer(GL_ARRAY_BUFFER, blit_ctx->vbo_id);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int handle_eac3(MOVMuxContext *mov, AVPacket *pkt, MOVTrack *track)", " {", "     AC3HeaderInfo *hdr = NULL;", "     struct eac3_info *info;", "     int num_blocks, ret;", "     if (!track->eac3_priv && !(track->eac3_priv = av_mallocz(sizeof(*info))))", "         return AVERROR(ENOMEM);", "     info = track->eac3_priv;", "     if (avpriv_ac3_parse_header(&hdr, pkt->data, pkt->size) < 0) {", "         if (!track->entry) {", "             av_log(mov, AV_LOG_WARNING, \"Dropping invalid packet from start of the stream\\n\");", "             ret = 0;", "         } else", "             ret = AVERROR_INVALIDDATA;", "         goto end;", "     }", "     info->data_rate = FFMAX(info->data_rate, hdr->bit_rate / 1000);", "     num_blocks = hdr->num_blocks;", "     if (!info->ec3_done) {", "         if (hdr->bitstream_id <= 10 && hdr->substreamid != 0) {", "             ret = AVERROR(EINVAL);", "             goto end;", "         }", "         if (hdr->frame_type == EAC3_FRAME_TYPE_INDEPENDENT) {", "             if (hdr->substreamid > info->num_ind_sub + 1) {", "                 ret = AVERROR(EINVAL);", "                 goto end;", "             }", "             if (hdr->substreamid == info->num_ind_sub + 1) {", "                 avpriv_request_sample(track->par, \"Multiple independent substreams\");", "                 ret = AVERROR_PATCHWELCOME;", "                 goto end;", "             } else if (hdr->substreamid < info->num_ind_sub ||", "                        hdr->substreamid == 0 && info->substream[0].bsid) {", "                  info->ec3_done = 1;", "                  goto concatenate;", "              }", "         } else {", "             if (hdr->substreamid != 0) {", "                 avpriv_request_sample(mov->fc, \"Multiple non EAC3 independent substreams\");", "                 ret = AVERROR_PATCHWELCOME;", "                 goto end;", "             }", "          }", "         info->substream[hdr->substreamid].fscod = hdr->sr_code;", "         info->substream[hdr->substreamid].bsid  = hdr->bitstream_id;", "         info->substream[hdr->substreamid].bsmod = hdr->bitstream_mode;", "         info->substream[hdr->substreamid].acmod = hdr->channel_mode;", "         info->substream[hdr->substreamid].lfeon = hdr->lfe_on;", "         if (pkt->size != hdr->frame_size) {", "             int cumul_size = hdr->frame_size;", "             int parent = hdr->substreamid;", "             while (cumul_size != pkt->size) {", "                 GetBitContext gbc;", "                 int i;", "                 ret = avpriv_ac3_parse_header(&hdr, pkt->data + cumul_size, pkt->size - cumul_size);", "                 if (ret < 0)", "                     goto end;", "                 if (hdr->frame_type != EAC3_FRAME_TYPE_DEPENDENT) {", "                     ret = AVERROR(EINVAL);", "                     goto end;", "                 }", "                 info->substream[parent].num_dep_sub++;", "                 ret /= 8;", "                 init_get_bits8(&gbc, pkt->data + cumul_size + ret, pkt->size - cumul_size - ret);", "                 skip_bits(&gbc, 5);", "                 for (i = 0; i < (hdr->channel_mode ? 1 : 2); i++) {", "                     skip_bits(&gbc, 5);  ", "                     if (get_bits1(&gbc)) {", "                         skip_bits(&gbc, 8);  ", "                     }", "                 }", "                 if (get_bits1(&gbc))", "                     info->substream[parent].chan_loc |= (get_bits(&gbc, 16) >> 5) & 0x1f;", "                 else", "                     info->substream[parent].chan_loc |= hdr->channel_mode;", "                 cumul_size += hdr->frame_size;", "             }", "         }", "     }", " concatenate:", "     if (!info->num_blocks && num_blocks == 6) {", "         ret = pkt->size;", "         goto end;", "     }", "     else if (info->num_blocks + num_blocks > 6) {", "         ret = AVERROR_INVALIDDATA;", "         goto end;", "     }", "     if (!info->num_blocks) {", "         ret = av_packet_ref(&info->pkt, pkt);", "         if (!ret)", "             info->num_blocks = num_blocks;", "         goto end;", "     } else {", "         if ((ret = av_grow_packet(&info->pkt, pkt->size)) < 0)", "             goto end;", "         memcpy(info->pkt.data + info->pkt.size - pkt->size, pkt->data, pkt->size);", "         info->num_blocks += num_blocks;", "         info->pkt.duration += pkt->duration;", "         if ((ret = av_copy_packet_side_data(&info->pkt, pkt)) < 0)", "             goto end;", "         if (info->num_blocks != 6)", "             goto end;", "         av_packet_unref(pkt);", "         av_packet_move_ref(pkt, &info->pkt);", "         info->num_blocks = 0;", "     }", "     ret = pkt->size;", " end:", "     av_free(hdr);", "     return ret;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" USHORT CNB::QueryL4HeaderOffset(PVOID PacketData, ULONG IpHeaderOffset) const", "  {", "      USHORT Res;", "      auto ppr = ParaNdis_ReviewIPPacket(RtlOffsetToPointer(PacketData, IpHeaderOffset),", "                                       GetDataLength(), __FUNCTION__);", "                                        GetDataLength(), FALSE, __FUNCTION__);", "      if (ppr.ipStatus != ppresNotIP)", "      {", "          Res = static_cast<USHORT>(IpHeaderOffset + ppr.ipHeaderSize);", "     }", "     else", "     {", "         DPrintf(0, (\"[%s] ERROR: NOT an IP packet - expected troubles!\\n\", __FUNCTION__));", "         Res = 0;", "     }", "     return Res;", " }"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int jas_iccputsint(jas_stream_t *out, int n, longlong val)", " static int jas_iccputsint(jas_stream_t *out, int n, jas_longlong val)", "  {", "\tulonglong tmp;", " \tjas_ulonglong tmp;", "  \ttmp = (val < 0) ? (abort(), 0) : val;", "  \treturn jas_iccputuint(out, n, tmp);", "  }"], "ner_tags": [0, 1, 0, 1, 1, 0, 0, 0]}
{"tokens": [" static int read_public_key(RSA *rsa)", " {", " \tint r;", " \tsc_path_t path;", " \tsc_file_t *file;", " \tu8 buf[2048], *p = buf;", " \tsize_t bufsize, keysize;", " \tr = select_app_df();", " \tif (r)", " \t\treturn 1;", " \tsc_format_path(\"I1012\", &path);", " \tr = sc_select_file(card, &path, &file);", " \tif (r) {", "  \t\tfprintf(stderr, \"Unable to select public key file: %s\\n\", sc_strerror(r));", "  \t\treturn 2;", "  \t}", "\tbufsize = file->size;", " \tbufsize = MIN(file->size, sizeof buf);", "  \tsc_file_free(file);", "  \tr = sc_read_binary(card, 0, buf, bufsize, 0);", "  \tif (r < 0) {", " \t\tfprintf(stderr, \"Unable to read public key file: %s\\n\", sc_strerror(r));", " \t\treturn 2;", " \t}", " \tbufsize = r;", " \tdo {", " \t\tif (bufsize < 4)", " \t\t\treturn 3;", " \t\tkeysize = (p[0] << 8) | p[1];", " \t\tif (keysize == 0)", " \t\t\tbreak;", " \t\tif (keysize < 3)", " \t\t\treturn 3;", " \t\tif (p[2] == opt_key_num)", " \t\t\tbreak;", " \t\tp += keysize;", " \t\tbufsize -= keysize;", " \t} while (1);", " \tif (keysize == 0) {", " \t\tprintf(\"Key number %d not found.\\n\", opt_key_num);", " \t\treturn 2;", " \t}", " \treturn parse_public_key(p, keysize, rsa);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int jas_iccputuint(jas_stream_t *out, int n, ulonglong val)", " static int jas_iccputuint(jas_stream_t *out, int n, jas_ulonglong val)", "  {", "  \tint i;", "  \tint c;", " \tfor (i = n; i > 0; --i) {", " \t\tc = (val >> (8 * (i - 1))) & 0xff;", " \t\tif (jas_stream_putc(out, c) == EOF)", " \t\t\treturn -1;", " \t}", "  \treturn 0;", "  }"], "ner_tags": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" initpyfribidi (void)", " init_pyfribidi (void)", "  {", "\tPyObject *module;", "\tmodule = Py_InitModule3 (\"pyfribidi\", PyfribidiMethods,", "\t\t\t\t _pyfribidi__doc__);", "         PyObject *module = Py_InitModule (\"_pyfribidi\", PyfribidiMethods);", "  \tPyModule_AddIntConstant (module, \"RTL\", (long) FRIBIDI_TYPE_RTL);", "  \tPyModule_AddIntConstant (module, \"LTR\", (long) FRIBIDI_TYPE_LTR);", "  \tPyModule_AddIntConstant (module, \"ON\", (long) FRIBIDI_TYPE_ON);", "\tPyModule_AddStringConstant (module, \"__author__\",", "\t\t\t\t    \"Yaacov Zamir and Nir Soffer\");", "  }"], "ner_tags": [0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0]}
{"tokens": [" static void Sp_replace_regexp(js_State *J)", " {", " \tjs_Regexp *re;", " \tconst char *source, *s, *r;", " \tjs_Buffer *sb = NULL;", " \tint n, x;", " \tResub m;", "  \tsource = checkstring(J, 0);", "  \tre = js_toregexp(J, 1);", "\tif (js_regexec(re->prog, source, &m, 0)) {", " \tif (js_doregexec(J, re->prog, source, &m, 0)) {", "  \t\tjs_copy(J, 0);", "  \t\treturn;", "  \t}", " \tre->last = 0;", " loop:", " \ts = m.sub[0].sp;", " \tn = m.sub[0].ep - m.sub[0].sp;", " \tif (js_iscallable(J, 2)) {", " \t\tjs_copy(J, 2);", " \t\tjs_pushundefined(J);", " \t\tfor (x = 0; m.sub[x].sp; ++x)  ", " \t\t\tjs_pushlstring(J, m.sub[x].sp, m.sub[x].ep - m.sub[x].sp);", " \t\tjs_pushnumber(J, s - source);  ", " \t\tjs_copy(J, 0);  ", " \t\tjs_call(J, 2 + x);", " \t\tr = js_tostring(J, -1);", " \t\tjs_putm(J, &sb, source, s);", " \t\tjs_puts(J, &sb, r);", " \t\tjs_pop(J, 1);", " \t} else {", " \t\tr = js_tostring(J, 2);", " \t\tjs_putm(J, &sb, source, s);", " \t\twhile (*r) {", " \t\t\tif (*r == '$') {", " \t\t\t\tswitch (*(++r)) {", " \t\t\t\tcase 0: --r;  ", " \t\t\t\tcase '$': js_putc(J, &sb, '$'); break;", " \t\t\t\tcase '`': js_putm(J, &sb, source, s); break;", " \t\t\t\tcase '\\'': js_puts(J, &sb, s + n); break;", " \t\t\t\tcase '&':", " \t\t\t\t\tjs_putm(J, &sb, s, s + n);", " \t\t\t\t\tbreak;", " \t\t\t\tcase '0': case '1': case '2': case '3': case '4':", " \t\t\t\tcase '5': case '6': case '7': case '8': case '9':", " \t\t\t\t\tx = *r - '0';", " \t\t\t\t\tif (r[1] >= '0' && r[1] <= '9')", " \t\t\t\t\t\tx = x * 10 + *(++r) - '0';", " \t\t\t\t\tif (x > 0 && x < m.nsub) {", " \t\t\t\t\t\tjs_putm(J, &sb, m.sub[x].sp, m.sub[x].ep);", " \t\t\t\t\t} else {", " \t\t\t\t\t\tjs_putc(J, &sb, '$');", " \t\t\t\t\t\tif (x > 10) {", " \t\t\t\t\t\t\tjs_putc(J, &sb, '0' + x / 10);", " \t\t\t\t\t\t\tjs_putc(J, &sb, '0' + x % 10);", " \t\t\t\t\t\t} else {", " \t\t\t\t\t\t\tjs_putc(J, &sb, '0' + x);", " \t\t\t\t\t\t}", " \t\t\t\t\t}", " \t\t\t\t\tbreak;", " \t\t\t\tdefault:", " \t\t\t\t\tjs_putc(J, &sb, '$');", " \t\t\t\t\tjs_putc(J, &sb, *r);", " \t\t\t\t\tbreak;", " \t\t\t\t}", " \t\t\t\t++r;", " \t\t\t} else {", " \t\t\t\tjs_putc(J, &sb, *r++);", " \t\t\t}", " \t\t}", " \t}", " \tif (re->flags & JS_REGEXP_G) {", " \t\tsource = m.sub[0].ep;", " \t\tif (n == 0) {", " \t\t\tif (*source)", " \t\t\t\tjs_putc(J, &sb, *source++);", "  \t\t\telse", "  \t\t\t\tgoto end;", "  \t\t}", "\t\tif (!js_regexec(re->prog, source, &m, REG_NOTBOL))", " \t\tif (!js_doregexec(J, re->prog, source, &m, REG_NOTBOL))", "  \t\t\tgoto loop;", "  \t}", " end:", " \tjs_puts(J, &sb, s + n);", " \tjs_putc(J, &sb, 0);", " \tif (js_try(J)) {", " \t\tjs_free(J, sb);", " \t\tjs_throw(J);", " \t}", " \tjs_pushstring(J, sb ? sb->s : \"\");", " \tjs_endtry(J);", " \tjs_free(J, sb);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int dnxhd_find_frame_end(DNXHDParserContext *dctx,", "                                 const uint8_t *buf, int buf_size)", " {", "     ParseContext *pc = &dctx->pc;", "     uint64_t state = pc->state64;", "     int pic_found = pc->frame_start_found;", "     int i = 0;", "     if (!pic_found) {", "         for (i = 0; i < buf_size; i++) {", "             state = (state << 8) | buf[i];", "             if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {", "                 i++;", "                 pic_found = 1;", "                 dctx->cur_byte = 0;", "                 dctx->remaining = 0;", "                 break;", "             }", "         }", "     }", "     if (pic_found && !dctx->remaining) {", "         if (!buf_size)  ", "             return 0;", "         for (; i < buf_size; i++) {", "             dctx->cur_byte++;", "             state = (state << 8) | buf[i];", "             if (dctx->cur_byte == 24) {", "                 dctx->h = (state >> 32) & 0xFFFF;", "             } else if (dctx->cur_byte == 26) {", "                  dctx->w = (state >> 32) & 0xFFFF;", "              } else if (dctx->cur_byte == 42) {", "                  int cid = (state >> 32) & 0xFFFFFFFF;", "                 int remaining;", "                  if (cid <= 0)", "                      continue;", "                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);", "                if (dctx->remaining <= 0) {", "                    dctx->remaining = ff_dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);", "                    if (dctx->remaining <= 0)", "                        return dctx->remaining;", "                 remaining = avpriv_dnxhd_get_frame_size(cid);", "                 if (remaining <= 0) {", "                     remaining = ff_dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);", "                     if (remaining <= 0)", "                         continue;", "                  }", "                 dctx->remaining = remaining;", "                  if (buf_size - i + 47 >= dctx->remaining) {", "                      int remaining = dctx->remaining;", "                     pc->frame_start_found = 0;", "                     pc->state64 = -1;", "                     dctx->cur_byte = 0;", "                     dctx->remaining = 0;", "                     return remaining;", "                 } else {", "                     dctx->remaining -= buf_size;", "                 }", "             }", "         }", "     } else if (pic_found) {", "         if (dctx->remaining > buf_size) {", "             dctx->remaining -= buf_size;", "         } else {", "             int remaining = dctx->remaining;", "             pc->frame_start_found = 0;", "             pc->state64 = -1;", "             dctx->cur_byte = 0;", "             dctx->remaining = 0;", "             return remaining;", "         }", "     }", "     pc->frame_start_found = pic_found;", "     pc->state64 = state;", "     return END_NOT_FOUND;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int vrend_create_shader(struct vrend_context *ctx,", "                         uint32_t handle,", "                         const struct pipe_stream_output_info *so_info,", "                         const char *shd_text, uint32_t offlen, uint32_t num_tokens,", "                         uint32_t type, uint32_t pkt_length)", " {", "    struct vrend_shader_selector *sel = NULL;", "    int ret_handle;", "    bool new_shader = true, long_shader = false;", "    bool finished = false;", "    int ret;", "    if (type > PIPE_SHADER_GEOMETRY)", "       return EINVAL;", "    if (offlen & VIRGL_OBJ_SHADER_OFFSET_CONT)", "       new_shader = false;", "    else if (((offlen + 3) / 4) > pkt_length)", "       long_shader = true;", "    if (ctx->sub->long_shader_in_progress_handle[type]) {", "       if (new_shader == true)", "          return EINVAL;", "       if (handle != ctx->sub->long_shader_in_progress_handle[type])", "          return EINVAL;", "    }", "    if (new_shader) {", "      sel = vrend_create_shader_state(ctx, so_info, type);", "      if (sel == NULL)", "        return ENOMEM;", "      if (long_shader) {", "         sel->buf_len = ((offlen + 3) / 4) * 4;  ", "         sel->tmp_buf = malloc(sel->buf_len);", "         if (!sel->tmp_buf) {", "            ret = ENOMEM;", "            goto error;", "         }", "         memcpy(sel->tmp_buf, shd_text, pkt_length * 4);", "         sel->buf_offset = pkt_length * 4;", "         ctx->sub->long_shader_in_progress_handle[type] = handle;", "      } else", "         finished = true;", "    } else {", "       sel = vrend_object_lookup(ctx->sub->object_hash, handle, VIRGL_OBJECT_SHADER);", "       if (!sel) {", "          fprintf(stderr, \"got continuation without original shader %d\\n\", handle);", "          ret = EINVAL;", "          goto error;", "       }", "       offlen &= ~VIRGL_OBJ_SHADER_OFFSET_CONT;", "       if (offlen != sel->buf_offset) {", "          fprintf(stderr, \"Got mismatched shader continuation %d vs %d\\n\",", "                  offlen, sel->buf_offset);", "           ret = EINVAL;", "           goto error;", "        }", "       if (pkt_length * 4 < pkt_length ||", "           pkt_length * 4 + sel->buf_offset < pkt_length * 4 ||", "           pkt_length * 4 + sel->buf_offset < sel->buf_offset) {", "             ret = EINVAL;", "             goto error;", "           }", "        if ((pkt_length * 4 + sel->buf_offset) > sel->buf_len) {", "           fprintf(stderr, \"Got too large shader continuation %d vs %d\\n\",", "                   pkt_length * 4 + sel->buf_offset, sel->buf_len);", "          shd_text = sel->tmp_buf;", "       }", "    }", "    if (finished) {", "       struct tgsi_token *tokens;", "       tokens = calloc(num_tokens + 10, sizeof(struct tgsi_token));", "       if (!tokens) {", "          ret = ENOMEM;", "          goto error;", "       }", "       if (vrend_dump_shaders)", "          fprintf(stderr,\"shader\\n%s\\n\", shd_text);", "       if (!tgsi_text_translate((const char *)shd_text, tokens, num_tokens + 10)) {", "          free(tokens);", "          ret = EINVAL;", "          goto error;", "       }", "       if (vrend_finish_shader(ctx, sel, tokens)) {", "          free(tokens);", "          ret = EINVAL;", "          goto error;", "       } else {", "          free(sel->tmp_buf);", "          sel->tmp_buf = NULL;", "       }", "       free(tokens);", "       ctx->sub->long_shader_in_progress_handle[type] = 0;", "    }", "    if (new_shader) {", "       ret_handle = vrend_renderer_object_insert(ctx, sel, sizeof(*sel), handle, VIRGL_OBJECT_SHADER);", "       if (ret_handle == 0) {", "          ret = ENOMEM;", "          goto error;", "       }", "    }", "    return 0;", " error:", "    if (new_shader)", "       vrend_destroy_shader_selector(sel);", "    else", "       vrend_renderer_object_destroy(ctx, handle);", "    return ret;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int yr_re_ast_create(", "     RE_AST** re_ast)", " {", "   *re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));", "   if (*re_ast == NULL)", "      return ERROR_INSUFFICIENT_MEMORY;", "    (*re_ast)->flags = 0;", "   (*re_ast)->levels = 0;", "    (*re_ast)->root_node = NULL;", "    return ERROR_SUCCESS;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["  header_read (SF_PRIVATE *psf, void *ptr, int bytes)", "  {\tint count = 0 ;", "\tif (psf->headindex >= SIGNED_SIZEOF (psf->header))", "\t\treturn psf_fread (ptr, 1, bytes, psf) ;", "\tif (psf->headindex + bytes > SIGNED_SIZEOF (psf->header))", "\t{\tint most ;", " \tif (psf->header.indx + bytes >= psf->header.len && psf_bump_header_allocation (psf, bytes))", " \t\treturn count ;", "\t\tmost = SIGNED_SIZEOF (psf->header) - psf->headend ;", "\t\tpsf_fread (psf->header + psf->headend, 1, most, psf) ;", "\t\tmemcpy (ptr, psf->header + psf->headend, most) ;", "\t\tpsf->headend = psf->headindex += most ;", "\t\tpsf_fread ((char *) ptr + most, bytes - most, 1, psf) ;", "\t\treturn bytes ;", "\t\t} ;", "\tif (psf->headindex + bytes > psf->headend)", "\t{\tcount = psf_fread (psf->header + psf->headend, 1, bytes - (psf->headend - psf->headindex), psf) ;", "\t\tif (count != bytes - (int) (psf->headend - psf->headindex))", " \tif (psf->header.indx + bytes > psf->header.end)", " \t{\tcount = psf_fread (psf->header.ptr + psf->header.end, 1, bytes - (psf->header.end - psf->header.indx), psf) ;", " \t\tif (count != bytes - (int) (psf->header.end - psf->header.indx))", "  \t\t{\tpsf_log_printf (psf, \"Error : psf_fread returned short count.\\n\") ;", "  \t\t\treturn count ;", "  \t\t\t} ;", "\t\tpsf->headend += count ;", " \t\tpsf->header.end += count ;", "  \t\t} ;", "\tmemcpy (ptr, psf->header + psf->headindex, bytes) ;", "\tpsf->headindex += bytes ;", " \tmemcpy (ptr, psf->header.ptr + psf->header.indx, bytes) ;", " \tpsf->header.indx += bytes ;", "  \treturn bytes ;", "  }  "], "ner_tags": [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0]}
{"tokens": [" construct_mac_tlv(struct sc_card *card, unsigned char *apdu_buf, size_t data_tlv_len, size_t le_tlv_len,", " \t\tunsigned char *mac_tlv, size_t * mac_tlv_len, const unsigned char key_type)", " {", " \tsize_t block_size = (KEY_TYPE_AES == key_type ? 16 : 8);", " \tunsigned char mac[4096] = { 0 };", " \tsize_t mac_len;", " \tunsigned char icv[16] = { 0 };", " \tint i = (KEY_TYPE_AES == key_type ? 15 : 7);", " \tepass2003_exdata *exdata = NULL;", " \tif (!card->drv_data) ", " \t\treturn SC_ERROR_INVALID_ARGUMENTS;", " \texdata = (epass2003_exdata *)card->drv_data;", " \tif (0 == data_tlv_len && 0 == le_tlv_len) {", " \t\tmac_len = block_size;", " \t}", " \telse {", " \t\t*(apdu_buf + block_size + data_tlv_len + le_tlv_len) = 0x80;", " \t\tif ((data_tlv_len + le_tlv_len + 1) % block_size)", " \t\t\tmac_len = (((data_tlv_len + le_tlv_len + 1) / block_size) +", " \t\t\t\t\t1) * block_size + block_size;", " \t\telse", " \t\t\tmac_len = data_tlv_len + le_tlv_len + 1 + block_size;", " \t\tmemset((apdu_buf + block_size + data_tlv_len + le_tlv_len + 1),", " \t\t       0, (mac_len - (data_tlv_len + le_tlv_len + 1)));", " \t}", " \tfor (; i >= 0; i--) {", " \t\tif (exdata->icv_mac[i] == 0xff) {", " \t\t\texdata->icv_mac[i] = 0;", " \t\t}", " \t\telse {", " \t\t\texdata->icv_mac[i]++;", " \t\t\tbreak;", " \t\t}", " \t}", " \tmemset(icv, 0, sizeof(icv));", " \tmemcpy(icv, exdata->icv_mac, 16);", " \tif (KEY_TYPE_AES == key_type) {", " \t\taes128_encrypt_cbc(exdata->sk_mac, 16, icv, apdu_buf, mac_len, mac);", "  \t\tmemcpy(mac_tlv + 2, &mac[mac_len - 16], 8);", "  \t}", "  \telse {", "\t\tunsigned char iv[8] = { 0 };", " \t\tunsigned char iv[EVP_MAX_IV_LENGTH] = { 0 };", "  \t\tunsigned char tmp[8] = { 0 };", "  \t\tdes_encrypt_cbc(exdata->sk_mac, 8, icv, apdu_buf, mac_len, mac);", "  \t\tdes_decrypt_cbc(&exdata->sk_mac[8], 8, iv, &mac[mac_len - 8], 8, tmp);", "\t\tmemset(iv, 0x00, 8);", " \t\tmemset(iv, 0x00, sizeof iv);", "  \t\tdes_encrypt_cbc(exdata->sk_mac, 8, iv, tmp, 8, mac_tlv + 2);", "  \t}", " \t*mac_tlv_len = 2 + 8;", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" static int cg_open(const char *path, struct fuse_file_info *fi)", " {", " \tconst char *cgroup;", " \tchar *fpath = NULL, *path1, *path2, * cgdir = NULL, *controller;", " \tstruct cgfs_files *k = NULL;", " \tstruct file_info *file_info;", " \tstruct fuse_context *fc = fuse_get_context();", " \tint ret;", " \tif (!fc)", " \t\treturn -EIO;", " \tcontroller = pick_controller_from_path(fc, path);", " \tif (!controller)", " \t\treturn -EIO;", " \tcgroup = find_cgroup_in_path(path);", " \tif (!cgroup)", " \t\treturn -EINVAL;", " \tget_cgdir_and_path(cgroup, &cgdir, &fpath);", " \tif (!fpath) {", " \t\tpath1 = \"/\";", " \t\tpath2 = cgdir;", " \t} else {", " \t\tpath1 = cgdir;", " \t\tpath2 = fpath;", " \t}", " \tk = cgfs_get_key(controller, path1, path2);", " \tif (!k) {", " \t\tret = -EINVAL;", " \t\tgoto out;", "  \t}", "  \tfree_key(k);", " \tif (!caller_may_see_dir(fc->pid, controller, path1)) {", " \t\tret = -ENOENT;", " \t\tgoto out;", " \t}", "  \tif (!fc_may_access(fc, controller, path1, path2, fi->flags)) {", "  \t\tret = -EACCES;", " \t\tgoto out;", " \t}", " \tfile_info = malloc(sizeof(*file_info));", " \tif (!file_info) {", " \t\tret = -ENOMEM;", " \t\tgoto out;", " \t}", " \tfile_info->controller = must_copy_string(controller);", " \tfile_info->cgroup = must_copy_string(path1);", " \tfile_info->file = must_copy_string(path2);", " \tfile_info->type = LXC_TYPE_CGFILE;", " \tfile_info->buf = NULL;", " \tfile_info->buflen = 0;", " \tfi->fh = (unsigned long)file_info;", " \tret = 0;", " out:", " \tfree(cgdir);", " \treturn ret;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  choose_filters(struct archive_read *a)", "  {", "\tint number_bidders, i, bid, best_bid;", " \tint number_bidders, i, bid, best_bid, n;", "  \tstruct archive_read_filter_bidder *bidder, *best_bidder;", "  \tstruct archive_read_filter *filter;", "  \tssize_t avail;", "  \tint r;", "\tfor (;;) {", " \tfor (n = 0; n < 25; ++n) {", "  \t\tnumber_bidders = sizeof(a->bidders) / sizeof(a->bidders[0]);", "  \t\tbest_bid = 0;", " \t\tbest_bidder = NULL;", " \t\tbidder = a->bidders;", " \t\tfor (i = 0; i < number_bidders; i++, bidder++) {", " \t\t\tif (bidder->bid != NULL) {", " \t\t\t\tbid = (bidder->bid)(bidder, a->filter);", " \t\t\t\tif (bid > best_bid) {", " \t\t\t\t\tbest_bid = bid;", " \t\t\t\t\tbest_bidder = bidder;", " \t\t\t\t}", " \t\t\t}", " \t\t}", " \t\tif (best_bidder == NULL) {", " \t\t\t__archive_read_filter_ahead(a->filter, 1, &avail);", " \t\t\tif (avail < 0) {", " \t\t\t\t__archive_read_close_filters(a);", " \t\t\t\t__archive_read_free_filters(a);", " \t\t\t\treturn (ARCHIVE_FATAL);", " \t\t\t}", " \t\t\ta->archive.compression_name = a->filter->name;", " \t\t\ta->archive.compression_code = a->filter->code;", " \t\t\treturn (ARCHIVE_OK);", " \t\t}", " \t\tfilter", " \t\t    = (struct archive_read_filter *)calloc(1, sizeof(*filter));", " \t\tif (filter == NULL)", " \t\t\treturn (ARCHIVE_FATAL);", " \t\tfilter->bidder = best_bidder;", " \t\tfilter->archive = a;", " \t\tfilter->upstream = a->filter;", " \t\ta->filter = filter;", " \t\tr = (best_bidder->init)(a->filter);", " \t\tif (r != ARCHIVE_OK) {", " \t\t\t__archive_read_close_filters(a);", " \t\t\t__archive_read_free_filters(a);", "  \t\t\treturn (ARCHIVE_FATAL);", "  \t\t}", "  \t}", " \tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", " \t    \"Input requires too many filters for decoding\");", " \treturn (ARCHIVE_FATAL);", "  }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0]}
{"tokens": [" GF_Err gf_sm_load_init(GF_SceneLoader *load)", " {", " \tGF_Err e = GF_NOT_SUPPORTED;", " \tchar *ext, szExt[50];", " \tif (!load || (!load->ctx && !load->scene_graph)", " #ifndef GPAC_DISABLE_ISOM", " \t        || (!load->fileName && !load->isom && !(load->flags & GF_SM_LOAD_FOR_PLAYBACK) )", " #endif", " \t   ) return GF_BAD_PARAM;", " \tif (!load->type) {", " #ifndef GPAC_DISABLE_ISOM", " \t\tif (load->isom) {", " \t\t\tload->type = GF_SM_LOAD_MP4;", " \t\t} else", " #endif", " \t\t{", " \t\t\text = (char *)strrchr(load->fileName, '.');", " \t\t\tif (!ext) return GF_NOT_SUPPORTED;", " \t\t\tif (!stricmp(ext, \".gz\")) {", " \t\t\t\tchar *anext;", " \t\t\t\text[0] = 0;", " \t\t\t\tanext = (char *)strrchr(load->fileName, '.');", "  \t\t\t\text[0] = '.';", "  \t\t\t\text = anext;", "  \t\t\t}", " \t\t\tif (strlen(ext) < 2 || strlen(ext) > sizeof(szExt)) {", " \t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_SCENE, (\"[Scene Manager] invalid extension in file name %s\\n\", load->fileName));", " \t\t\t\treturn GF_NOT_SUPPORTED;", " \t\t\t}", "  \t\t\tstrcpy(szExt, &ext[1]);", "  \t\t\tstrlwr(szExt);", "  \t\t\tif (strstr(szExt, \"bt\")) load->type = GF_SM_LOAD_BT;", " \t\t\telse if (strstr(szExt, \"wrl\")) load->type = GF_SM_LOAD_VRML;", " \t\t\telse if (strstr(szExt, \"x3dv\")) load->type = GF_SM_LOAD_X3DV;", " #ifndef GPAC_DISABLE_LOADER_XMT", " \t\t\telse if (strstr(szExt, \"xmt\") || strstr(szExt, \"xmta\")) load->type = GF_SM_LOAD_XMTA;", " \t\t\telse if (strstr(szExt, \"x3d\")) load->type = GF_SM_LOAD_X3D;", " #endif", " \t\t\telse if (strstr(szExt, \"swf\")) load->type = GF_SM_LOAD_SWF;", " \t\t\telse if (strstr(szExt, \"mov\")) load->type = GF_SM_LOAD_QT;", " \t\t\telse if (strstr(szExt, \"svg\")) load->type = GF_SM_LOAD_SVG;", " \t\t\telse if (strstr(szExt, \"xsr\")) load->type = GF_SM_LOAD_XSR;", " \t\t\telse if (strstr(szExt, \"xbl\")) load->type = GF_SM_LOAD_XBL;", " \t\t\telse if (strstr(szExt, \"xml\")) {", " \t\t\t\tchar *rtype = gf_xml_get_root_type(load->fileName, &e);", " \t\t\t\tif (rtype) {", " \t\t\t\t\tif (!strcmp(rtype, \"SAFSession\")) load->type = GF_SM_LOAD_XSR;", " \t\t\t\t\telse if (!strcmp(rtype, \"XMT-A\")) load->type = GF_SM_LOAD_XMTA;", " \t\t\t\t\telse if (!strcmp(rtype, \"X3D\")) load->type = GF_SM_LOAD_X3D;", " \t\t\t\t\telse if (!strcmp(rtype, \"bindings\")) load->type = GF_SM_LOAD_XBL;", " \t\t\t\t\tgf_free(rtype);", " \t\t\t\t}", " \t\t\t}", " \t\t}", " \t}", " \tif (!load->type) return e;", " \tif (!load->scene_graph) load->scene_graph = load->ctx->scene_graph;", " \tswitch (load->type) {", " #ifndef GPAC_DISABLE_LOADER_BT", " \tcase GF_SM_LOAD_BT:", " \tcase GF_SM_LOAD_VRML:", " \tcase GF_SM_LOAD_X3DV:", " \t\treturn gf_sm_load_init_bt(load);", " #endif", " #ifndef GPAC_DISABLE_LOADER_XMT", " \tcase GF_SM_LOAD_XMTA:", " \tcase GF_SM_LOAD_X3D:", " \t\treturn gf_sm_load_init_xmt(load);", " #endif", " #ifndef GPAC_DISABLE_SVG", " \tcase GF_SM_LOAD_SVG:", " \tcase GF_SM_LOAD_XSR:", " \tcase GF_SM_LOAD_DIMS:", " \t\treturn gf_sm_load_init_svg(load);", " \tcase GF_SM_LOAD_XBL:", " \t\te = gf_sm_load_init_xbl(load);", " \t\tload->process = gf_sm_load_run_xbl;", " \t\tload->done = gf_sm_load_done_xbl;", " \t\treturn e;", " #endif", " #ifndef GPAC_DISABLE_SWF_IMPORT", " \tcase GF_SM_LOAD_SWF:", " \t\treturn gf_sm_load_init_swf(load);", " #endif", " #ifndef GPAC_DISABLE_LOADER_ISOM", " \tcase GF_SM_LOAD_MP4:", " \t\treturn gf_sm_load_init_isom(load);", " #endif", " #ifndef GPAC_DISABLE_QTVR", " \tcase GF_SM_LOAD_QT:", " \t\treturn gf_sm_load_init_qt(load);", " #endif", " \tdefault:", " \t\treturn GF_NOT_SUPPORTED;", " \t}", " \treturn GF_NOT_SUPPORTED;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int read_tfra(MOVContext *mov, AVIOContext *f)", " {", "     MOVFragmentIndex* index = NULL;", "     int version, fieldlength, i, j;", "     int64_t pos = avio_tell(f);", "     uint32_t size = avio_rb32(f);", "     void *tmp;", "     if (avio_rb32(f) != MKBETAG('t', 'f', 'r', 'a')) {", "         return 1;", "     }", "     av_log(mov->fc, AV_LOG_VERBOSE, \"found tfra\\n\");", "     index = av_mallocz(sizeof(MOVFragmentIndex));", "     if (!index) {", "         return AVERROR(ENOMEM);", "     }", "     tmp = av_realloc_array(mov->fragment_index_data,", "                            mov->fragment_index_count + 1,", "                            sizeof(MOVFragmentIndex*));", "     if (!tmp) {", "         av_freep(&index);", "         return AVERROR(ENOMEM);", "     }", "     mov->fragment_index_data = tmp;", "     mov->fragment_index_data[mov->fragment_index_count++] = index;", "     version = avio_r8(f);", "     avio_rb24(f);", "     index->track_id = avio_rb32(f);", "     fieldlength = avio_rb32(f);", "     index->item_count = avio_rb32(f);", "     index->items = av_mallocz_array(", "             index->item_count, sizeof(MOVFragmentIndexItem));", "     if (!index->items) {", "         index->item_count = 0;", "         return AVERROR(ENOMEM);", "      }", "      for (i = 0; i < index->item_count; i++) {", "          int64_t time, offset;", "         if (avio_feof(f)) {", "             index->item_count = 0;", "             av_freep(&index->items);", "             return AVERROR_INVALIDDATA;", "         }", "          if (version == 1) {", "              time   = avio_rb64(f);", "              offset = avio_rb64(f);", "         } else {", "             time   = avio_rb32(f);", "             offset = avio_rb32(f);", "         }", "         index->items[i].time = time;", "         index->items[i].moof_offset = offset;", "         for (j = 0; j < ((fieldlength >> 4) & 3) + 1; j++)", "             avio_r8(f);", "         for (j = 0; j < ((fieldlength >> 2) & 3) + 1; j++)", "             avio_r8(f);", "         for (j = 0; j < ((fieldlength >> 0) & 3) + 1; j++)", "             avio_r8(f);", "     }", "     avio_seek(f, pos + size, SEEK_SET);", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int decode_bit_string(const u8 * inbuf, size_t inlen, void *outbuf,", " \t\t\t     size_t outlen, int invert)", "  {", "  \tconst u8 *in = inbuf;", "  \tu8 *out = (u8 *) outbuf;", "\tint zero_bits = *in & 0x07;", "\tsize_t octets_left = inlen - 1;", "  \tint i, count = 0;", " \tint zero_bits;", " \tsize_t octets_left;", "\tmemset(outbuf, 0, outlen);", "\tin++;", "  \tif (outlen < octets_left)", "  \t\treturn SC_ERROR_BUFFER_TOO_SMALL;", "  \tif (inlen < 1)", "  \t\treturn SC_ERROR_INVALID_ASN1_OBJECT;", " \tzero_bits = *in & 0x07;", " \toctets_left = inlen - 1;", " \tin++;", " \tmemset(outbuf, 0, outlen);", "  \twhile (octets_left) {", " \t\tint bits_to_go;", " \t\t*out = 0;", " \t\tif (octets_left == 1)", " \t\t\tbits_to_go = 8 - zero_bits;", " \t\telse", " \t\t\tbits_to_go = 8;", " \t\tif (invert)", " \t\t\tfor (i = 0; i < bits_to_go; i++) {", " \t\t\t\t*out |= ((*in >> (7 - i)) & 1) << i;", " \t\t\t}", " \t\telse {", " \t\t\t*out = *in;", " \t\t}", " \t\tout++;", " \t\tin++;", " \t\toctets_left--;", " \t\tcount++;", " \t}", " \treturn (count * 8) - zero_bits;", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static void build_l4proto_icmp(const struct nf_conntrack *ct, struct nethdr *n)", "  {", " \tif (!nfct_attr_is_set(ct, ATTR_ICMP_TYPE))", " \t\treturn;", "  \tct_build_u8(ct, ATTR_ICMP_TYPE, n, NTA_ICMP_TYPE);", "  \tct_build_u8(ct, ATTR_ICMP_CODE, n, NTA_ICMP_CODE);", "  \tct_build_u16(ct, ATTR_ICMP_ID, n, NTA_ICMP_ID);", " \tct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,", " \t\t      sizeof(struct nfct_attr_grp_port));", " }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int aa_read_header(AVFormatContext *s)", " {", "     int i, j, idx, largest_idx = -1;", "     uint32_t nkey, nval, toc_size, npairs, header_seed = 0, start;", "     char key[128], val[128], codec_name[64] = {0};", "     uint8_t output[24], dst[8], src[8];", "     int64_t largest_size = -1, current_size = -1, chapter_pos;", "     struct toc_entry {", "         uint32_t offset;", "         uint32_t size;", "     } TOC[MAX_TOC_ENTRIES];", "     uint32_t header_key_part[4];", "     uint8_t header_key[16] = {0};", "      AADemuxContext *c = s->priv_data;", "      AVIOContext *pb = s->pb;", "      AVStream *st;", "     int ret;", "      avio_skip(pb, 4);  ", "     avio_skip(pb, 4);  ", "     toc_size = avio_rb32(pb);  ", "     avio_skip(pb, 4);  ", "     if (toc_size > MAX_TOC_ENTRIES)", "         return AVERROR_INVALIDDATA;", "     for (i = 0; i < toc_size; i++) {  ", "         avio_skip(pb, 4);  ", "         TOC[i].offset = avio_rb32(pb);  ", "         TOC[i].size = avio_rb32(pb);  ", "     }", "     avio_skip(pb, 24);  ", "     npairs = avio_rb32(pb);  ", "     if (npairs > MAX_DICTIONARY_ENTRIES)", "         return AVERROR_INVALIDDATA;", "     for (i = 0; i < npairs; i++) {", "         memset(val, 0, sizeof(val));", "         memset(key, 0, sizeof(key));", "         avio_skip(pb, 1);  ", "         nkey = avio_rb32(pb);  ", "         nval = avio_rb32(pb);  ", "         avio_get_str(pb, nkey, key, sizeof(key));", "         avio_get_str(pb, nval, val, sizeof(val));", "         if (!strcmp(key, \"codec\")) {", "             av_log(s, AV_LOG_DEBUG, \"Codec is <%s>\\n\", val);", "             strncpy(codec_name, val, sizeof(codec_name) - 1);", "         } else if (!strcmp(key, \"HeaderSeed\")) {", "             av_log(s, AV_LOG_DEBUG, \"HeaderSeed is <%s>\\n\", val);", "              header_seed = atoi(val);", "          } else if (!strcmp(key, \"HeaderKey\")) {  ", "              av_log(s, AV_LOG_DEBUG, \"HeaderKey is <%s>\\n\", val);", "            sscanf(val, \"%\"SCNu32\"%\"SCNu32\"%\"SCNu32\"%\"SCNu32,", "             ret = sscanf(val, \"%\"SCNu32\"%\"SCNu32\"%\"SCNu32\"%\"SCNu32,", "                     &header_key_part[0], &header_key_part[1], &header_key_part[2], &header_key_part[3]);", "             if (ret != 4)", "                 return AVERROR_INVALIDDATA;", "              for (idx = 0; idx < 4; idx++) {", "                  AV_WB32(&header_key[idx * 4], header_key_part[idx]);  ", "              }", "             av_log(s, AV_LOG_DEBUG, \"Processed HeaderKey is \");", "             for (i = 0; i < 16; i++)", "                 av_log(s, AV_LOG_DEBUG, \"%02x\", header_key[i]);", "             av_log(s, AV_LOG_DEBUG, \"\\n\");", "         } else {", "             av_dict_set(&s->metadata, key, val, 0);", "         }", "     }", "     if (c->aa_fixed_key_len != 16) {", "         av_log(s, AV_LOG_ERROR, \"aa_fixed_key value needs to be 16 bytes!\\n\");", "         return AVERROR(EINVAL);", "     }", "     if ((c->codec_second_size = get_second_size(codec_name)) == -1) {", "         av_log(s, AV_LOG_ERROR, \"unknown codec <%s>!\\n\", codec_name);", "         return AVERROR(EINVAL);", "     }", "     c->tea_ctx = av_tea_alloc();", "     if (!c->tea_ctx)", "         return AVERROR(ENOMEM);", "     av_tea_init(c->tea_ctx, c->aa_fixed_key, 16);", "     output[0] = output[1] = 0;  ", "     memcpy(output + 2, header_key, 16);", "     idx = 0;", "     for (i = 0; i < 3; i++) {  ", "         AV_WB32(src, header_seed);", "         AV_WB32(src + 4, header_seed + 1);", "         header_seed += 2;", "         av_tea_crypt(c->tea_ctx, dst, src, 1, NULL, 0);  ", "         for (j = 0; j < TEA_BLOCK_SIZE && idx < 18; j+=1, idx+=1) {", "             output[idx] = output[idx] ^ dst[j];", "         }", "     }", "     memcpy(c->file_key, output + 2, 16);  ", "     av_log(s, AV_LOG_DEBUG, \"File key is \");", "     for (i = 0; i < 16; i++)", "         av_log(s, AV_LOG_DEBUG, \"%02x\", c->file_key[i]);", "     av_log(s, AV_LOG_DEBUG, \"\\n\");", "     st = avformat_new_stream(s, NULL);", "     if (!st) {", "         av_freep(&c->tea_ctx);", "         return AVERROR(ENOMEM);", "     }", "     st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;", "     if (!strcmp(codec_name, \"mp332\")) {", "         st->codecpar->codec_id = AV_CODEC_ID_MP3;", "         st->codecpar->sample_rate = 22050;", "         st->need_parsing = AVSTREAM_PARSE_FULL_RAW;", "         avpriv_set_pts_info(st, 64, 8, 32000 * TIMEPREC);", "     } else if (!strcmp(codec_name, \"acelp85\")) {", "         st->codecpar->codec_id = AV_CODEC_ID_SIPR;", "         st->codecpar->block_align = 19;", "         st->codecpar->channels = 1;", "         st->codecpar->sample_rate = 8500;", "         st->codecpar->bit_rate = 8500;", "         st->need_parsing = AVSTREAM_PARSE_FULL_RAW;", "         avpriv_set_pts_info(st, 64, 8, 8500 * TIMEPREC);", "     } else if (!strcmp(codec_name, \"acelp16\")) {", "         st->codecpar->codec_id = AV_CODEC_ID_SIPR;", "         st->codecpar->block_align = 20;", "         st->codecpar->channels = 1;", "         st->codecpar->sample_rate = 16000;", "         st->codecpar->bit_rate = 16000;", "         st->need_parsing = AVSTREAM_PARSE_FULL_RAW;", "         avpriv_set_pts_info(st, 64, 8, 16000 * TIMEPREC);", "     }", "     for (i = 1; i < toc_size; i++) {  ", "         current_size = TOC[i].size;", "         if (current_size > largest_size) {", "             largest_idx = i;", "             largest_size = current_size;", "         }", "     }", "     start = TOC[largest_idx].offset;", "     avio_seek(pb, start, SEEK_SET);", "     st->start_time = 0;", "     c->content_start = start;", "     c->content_end = start + largest_size;", "     while ((chapter_pos = avio_tell(pb)) >= 0 && chapter_pos < c->content_end) {", "         int chapter_idx = s->nb_chapters;", "         uint32_t chapter_size = avio_rb32(pb);", "         if (chapter_size == 0) break;", "         chapter_pos -= start + CHAPTER_HEADER_SIZE * chapter_idx;", "         avio_skip(pb, 4 + chapter_size);", "         if (!avpriv_new_chapter(s, chapter_idx, st->time_base,", "             chapter_pos * TIMEPREC, (chapter_pos + chapter_size) * TIMEPREC, NULL))", "                 return AVERROR(ENOMEM);", "     }", "     st->duration = (largest_size - CHAPTER_HEADER_SIZE * s->nb_chapters) * TIMEPREC;", "     ff_update_cur_dts(s, st, 0);", "     avio_seek(pb, start, SEEK_SET);", "     c->current_chapter_size = 0;", "     c->seek_offset = 0;", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int sc_asn1_read_tag(const u8 ** buf, size_t buflen, unsigned int *cla_out,", " \t\t     unsigned int *tag_out, size_t *taglen)", " {", " \tconst u8 *p = *buf;", " \tsize_t left = buflen, len;", " \tunsigned int cla, tag, i;", " \tif (left < 2)", " \t\treturn SC_ERROR_INVALID_ASN1_OBJECT;", " \t*buf = NULL;", " \tif (*p == 0xff || *p == 0) {", " \t\t*taglen = 0;", " \t\t*tag_out = SC_ASN1_TAG_EOC;", " \t\treturn SC_SUCCESS;", " \t}", " \tcla = (*p & SC_ASN1_TAG_CLASS) | (*p & SC_ASN1_TAG_CONSTRUCTED);", " \ttag = *p & SC_ASN1_TAG_PRIMITIVE;", " \tp++;", " \tleft--;", " \tif (tag == SC_ASN1_TAG_PRIMITIVE) {", " \t\tsize_t n = SC_ASN1_TAGNUM_SIZE - 1;", " \t\twhile (left-- != 0 && n != 0) {", " \t\t\ttag <<= 8;", " \t\t\ttag |= *p;", " \t\t\tif ((*p++ & 0x80) == 0)", " \t\t\t\tbreak;", " \t\t\tn--;", " \t\t}", " \t\tif (left == 0 || n == 0)", " \t\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;", " \t}", "  \tlen = *p & 0x7f;", "  \tif (*p++ & 0x80) {", "  \t\tunsigned int a = 0;", " \t\tleft--;", "  \t\tif (len > 4 || len > left)", "  \t\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;", "  \t\tleft -= len;", " \t\tfor (i = 0; i < len; i++) {", " \t\t\ta <<= 8;", " \t\t\ta |= *p;", " \t\t\tp++;", " \t\t}", " \t\tlen = a;", " \t}", " \t*cla_out = cla;", " \t*tag_out = tag;", " \t*taglen = len;", " \t*buf = p;", " \tif (len > left)", " \t\treturn SC_ERROR_ASN1_END_OF_CONTENTS;", " \treturn SC_SUCCESS;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  av_cold void ff_mpv_idct_init(MpegEncContext *s)", "  {", "     if (s->codec_id == AV_CODEC_ID_MPEG4)", "         s->idsp.mpeg4_studio_profile = s->studio_profile;", "      ff_idctdsp_init(&s->idsp, s->avctx);", "     if (s->alternate_scan) {", "         ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_alternate_vertical_scan);", "         ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_alternate_vertical_scan);", "     } else {", "         ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_zigzag_direct);", "         ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_zigzag_direct);", "     }", "     ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan);", "     ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);", " }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" atol10(const char *p, size_t char_cnt)", " {", "  \tuint64_t l;", "  \tint digit;", " \tif (char_cnt == 0)", " \t\treturn (0);", "  \tl = 0;", "  \tdigit = *p - '0';", "  \twhile (digit >= 0 && digit < 10  && char_cnt-- > 0) {", " \t\tl = (l * 10) + digit;", " \t\tdigit = *++p - '0';", " \t}", " \treturn (l);", " }"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" txid_current_snapshot(PG_FUNCTION_ARGS)", " {", " \tTxidSnapshot *snap;", " \tuint32\t\tnxip,", " \t\t\t\ti,", " \t\t\t\tsize;", " \tTxidEpoch\tstate;", " \tSnapshot\tcur;", " \tcur = GetActiveSnapshot();", " \tif (cur == NULL)", " \t\telog(ERROR, \"no active snapshot set\");", "  \tload_xid_epoch(&state);", " \tStaticAssertStmt(MAX_BACKENDS * 2 <= TXID_SNAPSHOT_MAX_NXIP,", " \t\t\t\t\t \"possible overflow in txid_current_snapshot()\");", "  \tnxip = cur->xcnt;", "  \tsize = TXID_SNAPSHOT_SIZE(nxip);", " \tsnap = palloc(size);", " \tSET_VARSIZE(snap, size);", " \tsnap->xmin = convert_xid(cur->xmin, &state);", " \tsnap->xmax = convert_xid(cur->xmax, &state);", " \tsnap->nxip = nxip;", " \tfor (i = 0; i < nxip; i++)", " \t\tsnap->xip[i] = convert_xid(cur->xip[i], &state);", " \tsort_snapshot(snap);", " \tPG_RETURN_POINTER(snap);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  int mif_validate(jas_stream_t *in)", "  {", "\tuchar buf[MIF_MAGICLEN];", " \tjas_uchar buf[MIF_MAGICLEN];", "  \tuint_fast32_t magic;", "  \tint i;", "  \tint n;", " \tassert(JAS_STREAM_MAXPUTBACK >= MIF_MAGICLEN);", " \tif ((n = jas_stream_read(in, buf, MIF_MAGICLEN)) < 0) {", " \t\treturn -1;", " \t}", " \tfor (i = n - 1; i >= 0; --i) {", " \t\tif (jas_stream_ungetc(in, buf[i]) == EOF) {", " \t\t\treturn -1;", " \t\t}", " \t}", " \tif (n < MIF_MAGICLEN) {", " \t\treturn -1;", " \t}", " \tmagic = (JAS_CAST(uint_fast32_t, buf[0]) << 24) |", " \t  (JAS_CAST(uint_fast32_t, buf[1]) << 16) |", " \t  (JAS_CAST(uint_fast32_t, buf[2]) << 8) |", " \t  buf[3];", " \tif (magic != MIF_MAGIC) {", " \t\treturn -1;", " \t}", " \treturn 0;", " }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void CtcpHandler::parse(Message::Type messageType, const QString &prefix, const QString &target, const QByteArray &message) {", "   QByteArray ctcp;", "   QByteArray dequotedMessage = lowLevelDequote(message);", "   CtcpType ctcptype = messageType == Message::Notice", "     ? CtcpReply", "     : CtcpQuery;", "   Message::Flags flags = (messageType == Message::Notice && !network()->isChannelName(target))", "     ? Message::Redirected", "     : Message::None;", "    int xdelimPos = -1;", "    int xdelimEndPos = -1;", "    int spacePos = -1;", "   QList<QByteArray> replies;", "    while((xdelimPos = dequotedMessage.indexOf(XDELIM)) != -1) {", "      if(xdelimPos > 0)", "        displayMsg(messageType, target, userDecode(target, dequotedMessage.left(xdelimPos)), prefix, flags);", "     xdelimEndPos = dequotedMessage.indexOf(XDELIM, xdelimPos + 1);", "     if(xdelimEndPos == -1) {", "       xdelimEndPos = dequotedMessage.count();", "     }", "     ctcp = xdelimDequote(dequotedMessage.mid(xdelimPos + 1, xdelimEndPos - xdelimPos - 1));", "     dequotedMessage = dequotedMessage.mid(xdelimEndPos + 1);", "     QString ctcpcmd = userDecode(target, ctcp.left(spacePos));", "     QString ctcpparam = userDecode(target, ctcp.mid(spacePos + 1));", "     spacePos = ctcp.indexOf(' ');", "     if(spacePos != -1) {", "       ctcpcmd = userDecode(target, ctcp.left(spacePos));", "       ctcpparam = userDecode(target, ctcp.mid(spacePos + 1));", "     } else {", "       ctcpcmd = userDecode(target, ctcp);", "       ctcpparam = QString();", "        ctcpparam = QString();", "      }", "    handle(ctcpcmd, Q_ARG(CtcpType, ctcptype), Q_ARG(QString, prefix), Q_ARG(QString, target), Q_ARG(QString, ctcpparam));", "     if(!_ignoreListManager->ctcpMatch(prefix, network()->networkName(), ctcpcmd.toUpper())) {", "       QString reply_;", "       handle(ctcpcmd, Q_ARG(CtcpType, ctcptype), Q_ARG(QString, prefix), Q_ARG(QString, target), Q_ARG(QString, ctcpparam), Q_ARG(QString, reply_));", "       if(ctcptype == CtcpQuery && !reply_.isNull()) {", "         replies << lowLevelQuote(pack(serverEncode(ctcpcmd), userEncode(nickFromMask(prefix), reply_)));", "       }", "     }", "   }", "   if(ctcptype == CtcpQuery && !replies.isEmpty()) {", "     packedReply(nickFromMask(prefix), replies);", "    }", "    if(!dequotedMessage.isEmpty())", " void CtcpHandler::query(const QString &bufname, const QString &ctcpTag, const QString &message) {", "   QList<QByteArray> params;", "   params << serverEncode(bufname) << lowLevelQuote(pack(serverEncode(ctcpTag), userEncode(bufname, message)));", "   emit putCmd(\"PRIVMSG\", params);", " }", " void CtcpHandler::reply(const QString &bufname, const QString &ctcpTag, const QString &message) {", "   QList<QByteArray> params;", "   params << serverEncode(bufname) << lowLevelQuote(pack(serverEncode(ctcpTag), userEncode(bufname, message)));", "   emit putCmd(\"NOTICE\", params);", " }", " void CtcpHandler::handleAction(CtcpType ctcptype, const QString &prefix, const QString &target, const QString &param) {", "   Q_UNUSED(ctcptype)", "   emit displayMsg(Message::Action, typeByTarget(target), target, param, prefix);", " }", "    emit putCmd(\"NOTICE\", params);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int filter_frame(AVFilterLink *inlink, AVFrame *in)", " {", "     AVFilterContext *ctx = inlink->dst;", "     BoxBlurContext *s = ctx->priv;", "     AVFilterLink *outlink = inlink->dst->outputs[0];", "     AVFrame *out;", "     int plane;", "     int cw = FF_CEIL_RSHIFT(inlink->w, s->hsub), ch = FF_CEIL_RSHIFT(in->height, s->vsub);", "     int w[4] = { inlink->w, cw, cw, inlink->w };", "     int h[4] = { in->height, ch, ch, in->height };", "     out = ff_get_video_buffer(outlink, outlink->w, outlink->h);", "     if (!out) {", "         av_frame_free(&in);", "         return AVERROR(ENOMEM);", "      }", "      av_frame_copy_props(out, in);", "    for (plane = 0; in->data[plane] && plane < 4; plane++)", "     for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++)", "          hblur(out->data[plane], out->linesize[plane],", "                in ->data[plane], in ->linesize[plane],", "                w[plane], h[plane], s->radius[plane], s->power[plane],", "                s->temp);", "    for (plane = 0; in->data[plane] && plane < 4; plane++)", "     for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++)", "          vblur(out->data[plane], out->linesize[plane],", "                out->data[plane], out->linesize[plane],", "                w[plane], h[plane], s->radius[plane], s->power[plane],", "               s->temp);", "     av_frame_free(&in);", "     return ff_filter_frame(outlink, out);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  void add_param_to_argv(char *parsestart, int line)", "  {", "\tint quote_open = 0, escaped = 0, param_len = 0;", "\tchar param_buffer[1024], *curchar;", " \tint quote_open = 0, escaped = 0;", " \tstruct xt_param_buf param = {};", " \tchar *curchar;", " \t\t\tparam_buffer[param_len++] = *curchar;", " \t\t\tif (param_len >= sizeof(param_buffer))", " \t\t\t\txtables_error(PARAMETER_PROBLEM,", "  \t\tcase ' ':", "  \t\tcase '\\t':", "  \t\tcase '\\n':", "\t\t\tif (!param_len) {", " \t\t\tif (!param.len) {", "  \t\t\t\tcontinue;", "  \t\t\t}", "  \t\t\tbreak;", "  \t\tdefault:", "\t\t\tparam_buffer[param_len++] = *curchar;", "\t\t\tif (param_len >= sizeof(param_buffer))", "\t\t\t\txtables_error(PARAMETER_PROBLEM,", "\t\t\t\t\t      \"Parameter too long!\");", " \t\t\tadd_param(&param, curchar);", "  \t\t\tcontinue;", "  \t\t}", "\t\tparam_buffer[param_len] = '\\0';", " \t\tparam.buffer[param.len] = '\\0';", "\t\tif ((param_buffer[0] == '-' &&", "\t\t     param_buffer[1] != '-' &&", "\t\t     strchr(param_buffer, 't')) ||", "\t\t    (!strncmp(param_buffer, \"--t\", 3) &&", "\t\t     !strncmp(param_buffer, \"--table\", strlen(param_buffer)))) {", " \t\tif ((param.buffer[0] == '-' &&", " \t\t     param.buffer[1] != '-' &&", " \t\t     strchr(param.buffer, 't')) ||", " \t\t    (!strncmp(param.buffer, \"--t\", 3) &&", " \t\t     !strncmp(param.buffer, \"--table\", strlen(param.buffer)))) {", "  \t\t\txtables_error(PARAMETER_PROBLEM,", "  \t\t\t\t      \"The -t option (seen in line %u) cannot be used in %s.\\n\",", "  \t\t\t\t      line, xt_params->program_name);", "  \t\t}", "\t\tadd_argv(param_buffer, 0);", "\t\tparam_len = 0;", " \t\tadd_argv(param.buffer, 0);", " \t\tparam.len = 0;", "  \t}"], "ner_tags": [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0]}
{"tokens": ["  int jpc_tsfb_synthesize(jpc_tsfb_t *tsfb, jas_seq2d_t *a)", "  {", "\treturn (tsfb->numlvls > 0) ? jpc_tsfb_synthesize2(tsfb,", " \treturn (tsfb->numlvls > 0 && jas_seq2d_size(a)) ?", " \t  jpc_tsfb_synthesize2(tsfb,", "  \t  jas_seq2d_getref(a, jas_seq2d_xstart(a), jas_seq2d_ystart(a)),", "  \t  jas_seq2d_xstart(a), jas_seq2d_ystart(a), jas_seq2d_width(a),", "  \t  jas_seq2d_height(a), jas_seq2d_rowstep(a), tsfb->numlvls - 1) : 0;", " }"], "ner_tags": [0, 0, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": [" static int bmp_getint32(jas_stream_t *in, int_fast32_t *val)", " {", " \tint n;", " \tuint_fast32_t v;", " \tint c;", " \tfor (n = 4, v = 0;;) {", "  \t\tif ((c = jas_stream_getc(in)) == EOF) {", "  \t\t\treturn -1;", "  \t\t}", "\t\tv |= (c << 24);", " \t\tv |= (JAS_CAST(uint_fast32_t, c) << 24);", "  \t\tif (--n <= 0) {", "  \t\t\tbreak;", "  \t\t}", " \t\tv >>= 8;", " \t}", " \tif (val) {", " \t\t*val = v;", " \t}", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" yyparse (void *yyscanner, YR_COMPILER* compiler)", " {", " int yychar;", " YY_INITIAL_VALUE (static YYSTYPE yyval_default;)", " YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);", "     int yynerrs;", "     int yystate;", "     int yyerrstatus;", "     yytype_int16 yyssa[YYINITDEPTH];", "     yytype_int16 *yyss;", "     yytype_int16 *yyssp;", "     YYSTYPE yyvsa[YYINITDEPTH];", "     YYSTYPE *yyvs;", "     YYSTYPE *yyvsp;", "     YYSIZE_T yystacksize;", "   int yyn;", "   int yyresult;", "   int yytoken = 0;", "   YYSTYPE yyval;", " #if YYERROR_VERBOSE", "   char yymsgbuf[128];", "   char *yymsg = yymsgbuf;", "   YYSIZE_T yymsg_alloc = sizeof yymsgbuf;", " #endif", " #define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))", "   int yylen = 0;", "   yyssp = yyss = yyssa;", "   yyvsp = yyvs = yyvsa;", "   yystacksize = YYINITDEPTH;", "   YYDPRINTF ((stderr, \"Starting parse\\n\"));", "   yystate = 0;", "   yyerrstatus = 0;", "   yynerrs = 0;", "   yychar = YYEMPTY;  ", "   goto yysetstate;", "  yynewstate:", "   yyssp++;", "  yysetstate:", "   *yyssp = yystate;", "   if (yyss + yystacksize - 1 <= yyssp)", "     {", "       YYSIZE_T yysize = yyssp - yyss + 1;", " #ifdef yyoverflow", "       {", "         YYSTYPE *yyvs1 = yyvs;", "         yytype_int16 *yyss1 = yyss;", "         yyoverflow (YY_(\"memory exhausted\"),", "                     &yyss1, yysize * sizeof (*yyssp),", "                     &yyvs1, yysize * sizeof (*yyvsp),", "                     &yystacksize);", "         yyss = yyss1;", "         yyvs = yyvs1;", "       }", " #else  ", " # ifndef YYSTACK_RELOCATE", "       goto yyexhaustedlab;", " # else", "       if (YYMAXDEPTH <= yystacksize)", "         goto yyexhaustedlab;", "       yystacksize *= 2;", "       if (YYMAXDEPTH < yystacksize)", "         yystacksize = YYMAXDEPTH;", "       {", "         yytype_int16 *yyss1 = yyss;", "         union yyalloc *yyptr =", "           (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));", "         if (! yyptr)", "           goto yyexhaustedlab;", "         YYSTACK_RELOCATE (yyss_alloc, yyss);", "         YYSTACK_RELOCATE (yyvs_alloc, yyvs);", " #  undef YYSTACK_RELOCATE", "         if (yyss1 != yyssa)", "           YYSTACK_FREE (yyss1);", "       }", " # endif", " #endif  ", "       yyssp = yyss + yysize - 1;", "       yyvsp = yyvs + yysize - 1;", "       YYDPRINTF ((stderr, \"Stack size increased to %lu\\n\",", "                   (unsigned long int) yystacksize));", "       if (yyss + yystacksize - 1 <= yyssp)", "         YYABORT;", "     }", "   YYDPRINTF ((stderr, \"Entering state %d\\n\", yystate));", "   if (yystate == YYFINAL)", "     YYACCEPT;", "   goto yybackup;", " yybackup:", "   yyn = yypact[yystate];", "   if (yypact_value_is_default (yyn))", "     goto yydefault;", "   if (yychar == YYEMPTY)", "     {", "       YYDPRINTF ((stderr, \"Reading a token: \"));", "       yychar = yylex (&yylval, yyscanner, compiler);", "     }", "   if (yychar <= YYEOF)", "     {", "       yychar = yytoken = YYEOF;", "       YYDPRINTF ((stderr, \"Now at end of input.\\n\"));", "     }", "   else", "     {", "       yytoken = YYTRANSLATE (yychar);", "       YY_SYMBOL_PRINT (\"Next token is\", yytoken, &yylval, &yylloc);", "     }", "   yyn += yytoken;", "   if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)", "     goto yydefault;", "   yyn = yytable[yyn];", "   if (yyn <= 0)", "     {", "       if (yytable_value_is_error (yyn))", "         goto yyerrlab;", "       yyn = -yyn;", "       goto yyreduce;", "     }", "   if (yyerrstatus)", "     yyerrstatus--;", "   YY_SYMBOL_PRINT (\"Shifting\", yytoken, &yylval, &yylloc);", "   yychar = YYEMPTY;", "   yystate = yyn;", "   YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN", "   *++yyvsp = yylval;", "   YY_IGNORE_MAYBE_UNINITIALIZED_END", "   goto yynewstate;", " yydefault:", "   yyn = yydefact[yystate];", "   if (yyn == 0)", "     goto yyerrlab;", "   goto yyreduce;", " yyreduce:", "   yylen = yyr2[yyn];", "   yyval = yyvsp[1-yylen];", "   YY_REDUCE_PRINT (yyn);", "   switch (yyn)", "     {", "         case 8:", " #line 230 \"grammar.y\"  ", "     {", "         int result = yr_parser_reduce_import(yyscanner, (yyvsp[0].sized_string));", "         yr_free((yyvsp[0].sized_string));", "         ERROR_IF(result != ERROR_SUCCESS);", "       }", " #line 1661 \"grammar.c\"  ", "     break;", "   case 9:", " #line 242 \"grammar.y\"  ", "     {", "         YR_RULE* rule = yr_parser_reduce_rule_declaration_phase_1(", "             yyscanner, (int32_t) (yyvsp[-2].integer), (yyvsp[0].c_string));", "         ERROR_IF(rule == NULL);", "         (yyval.rule) = rule;", "       }", " #line 1674 \"grammar.c\"  ", "     break;", "   case 10:", " #line 251 \"grammar.y\"  ", "     {", "         YR_RULE* rule = (yyvsp[-4].rule);  ", "         rule->tags = (yyvsp[-3].c_string);", "         rule->metas = (yyvsp[-1].meta);", "         rule->strings = (yyvsp[0].string);", "       }", " #line 1686 \"grammar.c\"  ", "     break;", "   case 11:", " #line 259 \"grammar.y\"  ", "     {", "         YR_RULE* rule = (yyvsp[-7].rule);  ", "         compiler->last_result = yr_parser_reduce_rule_declaration_phase_2(", "             yyscanner, rule);", "         yr_free((yyvsp[-8].c_string));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "       }", " #line 1701 \"grammar.c\"  ", "     break;", "   case 12:", " #line 274 \"grammar.y\"  ", "     {", "         (yyval.meta) = NULL;", "       }", " #line 1709 \"grammar.c\"  ", "     break;", "   case 13:", " #line 278 \"grammar.y\"  ", "     {", "         YR_META null_meta;", "         memset(&null_meta, 0xFF, sizeof(YR_META));", "         null_meta.type = META_TYPE_NULL;", "         compiler->last_result = yr_arena_write_data(", "             compiler->metas_arena,", "             &null_meta,", "             sizeof(YR_META),", "             NULL);", "         (yyval.meta) = (yyvsp[0].meta);", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "       }", " #line 1736 \"grammar.c\"  ", "     break;", "   case 14:", " #line 305 \"grammar.y\"  ", "     {", "         (yyval.string) = NULL;", "       }", " #line 1744 \"grammar.c\"  ", "     break;", "   case 15:", " #line 309 \"grammar.y\"  ", "     {", "         YR_STRING null_string;", "         memset(&null_string, 0xFF, sizeof(YR_STRING));", "         null_string.g_flags = STRING_GFLAGS_NULL;", "         compiler->last_result = yr_arena_write_data(", "             compiler->strings_arena,", "             &null_string,", "             sizeof(YR_STRING),", "             NULL);", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         (yyval.string) = (yyvsp[0].string);", "       }", " #line 1771 \"grammar.c\"  ", "     break;", "   case 17:", " #line 340 \"grammar.y\"  ", "     { (yyval.integer) = 0;  }", " #line 1777 \"grammar.c\"  ", "     break;", "   case 18:", " #line 341 \"grammar.y\"  ", "     { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }", " #line 1783 \"grammar.c\"  ", "     break;", "   case 19:", " #line 346 \"grammar.y\"  ", "     { (yyval.integer) = RULE_GFLAGS_PRIVATE; }", " #line 1789 \"grammar.c\"  ", "     break;", "   case 20:", " #line 347 \"grammar.y\"  ", "     { (yyval.integer) = RULE_GFLAGS_GLOBAL; }", " #line 1795 \"grammar.c\"  ", "     break;", "   case 21:", " #line 353 \"grammar.y\"  ", "     {", "         (yyval.c_string) = NULL;", "       }", " #line 1803 \"grammar.c\"  ", "     break;", "   case 22:", " #line 357 \"grammar.y\"  ", "     {", "         compiler->last_result = yr_arena_write_string(", "             yyget_extra(yyscanner)->sz_arena, \"\", NULL);", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         (yyval.c_string) = (yyvsp[0].c_string);", "       }", " #line 1821 \"grammar.c\"  ", "     break;", "   case 23:", " #line 375 \"grammar.y\"  ", "     {", "         char* identifier;", "         compiler->last_result = yr_arena_write_string(", "             yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), &identifier);", "         yr_free((yyvsp[0].c_string));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         (yyval.c_string) = identifier;", "       }", " #line 1838 \"grammar.c\"  ", "     break;", "   case 24:", " #line 388 \"grammar.y\"  ", "     {", "         char* tag_name = (yyvsp[-1].c_string);", "         size_t tag_length = tag_name != NULL ? strlen(tag_name) : 0;", "         while (tag_length > 0)", "         {", "           if (strcmp(tag_name, (yyvsp[0].c_string)) == 0)", "           {", "             yr_compiler_set_error_extra_info(compiler, tag_name);", "             compiler->last_result = ERROR_DUPLICATED_TAG_IDENTIFIER;", "             break;", "           }", "           tag_name = (char*) yr_arena_next_address(", "               yyget_extra(yyscanner)->sz_arena,", "               tag_name,", "               tag_length + 1);", "           tag_length = tag_name != NULL ? strlen(tag_name) : 0;", "         }", "         if (compiler->last_result == ERROR_SUCCESS)", "           compiler->last_result = yr_arena_write_string(", "               yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), NULL);", "         yr_free((yyvsp[0].c_string));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         (yyval.c_string) = (yyvsp[-1].c_string);", "       }", " #line 1874 \"grammar.c\"  ", "     break;", "   case 25:", " #line 424 \"grammar.y\"  ", "     {  (yyval.meta) = (yyvsp[0].meta); }", " #line 1880 \"grammar.c\"  ", "     break;", "   case 26:", " #line 425 \"grammar.y\"  ", "     {  (yyval.meta) = (yyvsp[-1].meta); }", " #line 1886 \"grammar.c\"  ", "     break;", "   case 27:", " #line 431 \"grammar.y\"  ", "     {", "         SIZED_STRING* sized_string = (yyvsp[0].sized_string);", "         (yyval.meta) = yr_parser_reduce_meta_declaration(", "             yyscanner,", "             META_TYPE_STRING,", "             (yyvsp[-2].c_string),", "             sized_string->c_string,", "             0);", "         yr_free((yyvsp[-2].c_string));", "         yr_free((yyvsp[0].sized_string));", "         ERROR_IF((yyval.meta) == NULL);", "       }", " #line 1906 \"grammar.c\"  ", "     break;", "   case 28:", " #line 447 \"grammar.y\"  ", "     {", "         (yyval.meta) = yr_parser_reduce_meta_declaration(", "             yyscanner,", "             META_TYPE_INTEGER,", "             (yyvsp[-2].c_string),", "             NULL,", "             (yyvsp[0].integer));", "         yr_free((yyvsp[-2].c_string));", "         ERROR_IF((yyval.meta) == NULL);", "       }", " #line 1923 \"grammar.c\"  ", "     break;", "   case 29:", " #line 460 \"grammar.y\"  ", "     {", "         (yyval.meta) = yr_parser_reduce_meta_declaration(", "             yyscanner,", "             META_TYPE_INTEGER,", "             (yyvsp[-3].c_string),", "             NULL,", "             -(yyvsp[0].integer));", "         yr_free((yyvsp[-3].c_string));", "         ERROR_IF((yyval.meta) == NULL);", "       }", " #line 1940 \"grammar.c\"  ", "     break;", "   case 30:", " #line 473 \"grammar.y\"  ", "     {", "         (yyval.meta) = yr_parser_reduce_meta_declaration(", "             yyscanner,", "             META_TYPE_BOOLEAN,", "             (yyvsp[-2].c_string),", "             NULL,", "             TRUE);", "         yr_free((yyvsp[-2].c_string));", "         ERROR_IF((yyval.meta) == NULL);", "       }", " #line 1957 \"grammar.c\"  ", "     break;", "   case 31:", " #line 486 \"grammar.y\"  ", "     {", "         (yyval.meta) = yr_parser_reduce_meta_declaration(", "             yyscanner,", "             META_TYPE_BOOLEAN,", "             (yyvsp[-2].c_string),", "             NULL,", "             FALSE);", "         yr_free((yyvsp[-2].c_string));", "         ERROR_IF((yyval.meta) == NULL);", "       }", " #line 1974 \"grammar.c\"  ", "     break;", "   case 32:", " #line 502 \"grammar.y\"  ", "     { (yyval.string) = (yyvsp[0].string); }", " #line 1980 \"grammar.c\"  ", "     break;", "   case 33:", " #line 503 \"grammar.y\"  ", "     { (yyval.string) = (yyvsp[-1].string); }", " #line 1986 \"grammar.c\"  ", "     break;", "   case 34:", " #line 509 \"grammar.y\"  ", "     {", "         compiler->error_line = yyget_lineno(yyscanner);", "       }", " #line 1994 \"grammar.c\"  ", "     break;", "   case 35:", " #line 513 \"grammar.y\"  ", "     {", "         (yyval.string) = yr_parser_reduce_string_declaration(", "             yyscanner, (int32_t) (yyvsp[0].integer), (yyvsp[-4].c_string), (yyvsp[-1].sized_string));", "         yr_free((yyvsp[-4].c_string));", "         yr_free((yyvsp[-1].sized_string));", "         ERROR_IF((yyval.string) == NULL);", "         compiler->error_line = 0;", "       }", " #line 2009 \"grammar.c\"  ", "     break;", "   case 36:", " #line 524 \"grammar.y\"  ", "     {", "         compiler->error_line = yyget_lineno(yyscanner);", "       }", " #line 2017 \"grammar.c\"  ", "     break;", "   case 37:", " #line 528 \"grammar.y\"  ", "     {", "         (yyval.string) = yr_parser_reduce_string_declaration(", "             yyscanner, (int32_t) (yyvsp[0].integer) | STRING_GFLAGS_REGEXP, (yyvsp[-4].c_string), (yyvsp[-1].sized_string));", "         yr_free((yyvsp[-4].c_string));", "         yr_free((yyvsp[-1].sized_string));", "         ERROR_IF((yyval.string) == NULL);", "         compiler->error_line = 0;", "       }", " #line 2033 \"grammar.c\"  ", "     break;", "   case 38:", " #line 540 \"grammar.y\"  ", "     {", "         (yyval.string) = yr_parser_reduce_string_declaration(", "             yyscanner, STRING_GFLAGS_HEXADECIMAL, (yyvsp[-2].c_string), (yyvsp[0].sized_string));", "         yr_free((yyvsp[-2].c_string));", "         yr_free((yyvsp[0].sized_string));", "         ERROR_IF((yyval.string) == NULL);", "       }", " #line 2047 \"grammar.c\"  ", "     break;", "   case 39:", " #line 553 \"grammar.y\"  ", "     { (yyval.integer) = 0; }", " #line 2053 \"grammar.c\"  ", "     break;", "   case 40:", " #line 554 \"grammar.y\"  ", "     { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }", " #line 2059 \"grammar.c\"  ", "     break;", "   case 41:", " #line 559 \"grammar.y\"  ", "     { (yyval.integer) = STRING_GFLAGS_WIDE; }", " #line 2065 \"grammar.c\"  ", "     break;", "   case 42:", " #line 560 \"grammar.y\"  ", "     { (yyval.integer) = STRING_GFLAGS_ASCII; }", " #line 2071 \"grammar.c\"  ", "     break;", "   case 43:", " #line 561 \"grammar.y\"  ", "     { (yyval.integer) = STRING_GFLAGS_NO_CASE; }", " #line 2077 \"grammar.c\"  ", "     break;", "   case 44:", " #line 562 \"grammar.y\"  ", "     { (yyval.integer) = STRING_GFLAGS_FULL_WORD; }", " #line 2083 \"grammar.c\"  ", "     break;", "   case 45:", " #line 568 \"grammar.y\"  ", "     {", "         int var_index = yr_parser_lookup_loop_variable(yyscanner, (yyvsp[0].c_string));", "         if (var_index >= 0)", "         {", "           compiler->last_result = yr_parser_emit_with_arg(", "               yyscanner,", "               OP_PUSH_M,", "               LOOP_LOCAL_VARS * var_index,", "               NULL,", "               NULL);", "           (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "           (yyval.expression).value.integer = UNDEFINED;", "           (yyval.expression).identifier = compiler->loop_identifier[var_index];", "         }", "         else", "         {", "           YR_OBJECT* object = (YR_OBJECT*) yr_hash_table_lookup(", "               compiler->objects_table, (yyvsp[0].c_string), NULL);", "           if (object == NULL)", "           {", "             char* ns = compiler->current_namespace->name;", "             object = (YR_OBJECT*) yr_hash_table_lookup(", "                 compiler->objects_table, (yyvsp[0].c_string), ns);", "           }", "           if (object != NULL)", "           {", "             char* id;", "             compiler->last_result = yr_arena_write_string(", "                 compiler->sz_arena, (yyvsp[0].c_string), &id);", "             if (compiler->last_result == ERROR_SUCCESS)", "               compiler->last_result = yr_parser_emit_with_arg_reloc(", "                   yyscanner,", "                   OP_OBJ_LOAD,", "                   id,", "                   NULL,", "                   NULL);", "             (yyval.expression).type = EXPRESSION_TYPE_OBJECT;", "             (yyval.expression).value.object = object;", "             (yyval.expression).identifier = object->identifier;", "           }", "           else", "           {", "             YR_RULE* rule = (YR_RULE*) yr_hash_table_lookup(", "                 compiler->rules_table,", "                 (yyvsp[0].c_string),", "                 compiler->current_namespace->name);", "             if (rule != NULL)", "             {", "               compiler->last_result = yr_parser_emit_with_arg_reloc(", "                   yyscanner,", "                   OP_PUSH_RULE,", "                   rule,", "                   NULL,", "                   NULL);", "               (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "               (yyval.expression).value.integer = UNDEFINED;", "               (yyval.expression).identifier = rule->identifier;", "             }", "             else", "             {", "               yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));", "               compiler->last_result = ERROR_UNDEFINED_IDENTIFIER;", "             }", "           }", "         }", "         yr_free((yyvsp[0].c_string));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "       }", " #line 2172 \"grammar.c\"  ", "     break;", "   case 46:", " #line 653 \"grammar.y\"  ", "     {", "         YR_OBJECT* field = NULL;", "         if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_OBJECT &&", "             (yyvsp[-2].expression).value.object->type == OBJECT_TYPE_STRUCTURE)", "         {", "           field = yr_object_lookup_field((yyvsp[-2].expression).value.object, (yyvsp[0].c_string));", "           if (field != NULL)", "           {", "             char* ident;", "             compiler->last_result = yr_arena_write_string(", "               compiler->sz_arena, (yyvsp[0].c_string), &ident);", "             if (compiler->last_result == ERROR_SUCCESS)", "               compiler->last_result = yr_parser_emit_with_arg_reloc(", "                   yyscanner,", "                   OP_OBJ_FIELD,", "                   ident,", "                   NULL,", "                   NULL);", "             (yyval.expression).type = EXPRESSION_TYPE_OBJECT;", "             (yyval.expression).value.object = field;", "             (yyval.expression).identifier = field->identifier;", "           }", "           else", "           {", "             yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));", "             compiler->last_result = ERROR_INVALID_FIELD_NAME;", "           }", "         }", "         else", "         {", "           yr_compiler_set_error_extra_info(", "               compiler, (yyvsp[-2].expression).identifier);", "           compiler->last_result = ERROR_NOT_A_STRUCTURE;", "         }", "         yr_free((yyvsp[0].c_string));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "       }", " #line 2222 \"grammar.c\"  ", "     break;", "   case 47:", " #line 699 \"grammar.y\"  ", "     {", "         YR_OBJECT_ARRAY* array;", "         YR_OBJECT_DICTIONARY* dict;", "         if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&", "             (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_ARRAY)", "         {", "           if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)", "           {", "             yr_compiler_set_error_extra_info(", "                 compiler, \"array indexes must be of integer type\");", "             compiler->last_result = ERROR_WRONG_TYPE;", "           }", "           ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "           compiler->last_result = yr_parser_emit(", "               yyscanner, OP_INDEX_ARRAY, NULL);", "           array = (YR_OBJECT_ARRAY*) (yyvsp[-3].expression).value.object;", "           (yyval.expression).type = EXPRESSION_TYPE_OBJECT;", "           (yyval.expression).value.object = array->prototype_item;", "           (yyval.expression).identifier = array->identifier;", "         }", "         else if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&", "                  (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_DICTIONARY)", "         {", "           if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_STRING)", "           {", "             yr_compiler_set_error_extra_info(", "                 compiler, \"dictionary keys must be of string type\");", "             compiler->last_result = ERROR_WRONG_TYPE;", "           }", "           ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "           compiler->last_result = yr_parser_emit(", "               yyscanner, OP_LOOKUP_DICT, NULL);", "           dict = (YR_OBJECT_DICTIONARY*) (yyvsp[-3].expression).value.object;", "           (yyval.expression).type = EXPRESSION_TYPE_OBJECT;", "           (yyval.expression).value.object = dict->prototype_item;", "           (yyval.expression).identifier = dict->identifier;", "         }", "         else", "         {", "           yr_compiler_set_error_extra_info(", "               compiler, (yyvsp[-3].expression).identifier);", "           compiler->last_result = ERROR_NOT_INDEXABLE;", "         }", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "       }", " #line 2283 \"grammar.c\"  ", "     break;", "   case 48:", " #line 757 \"grammar.y\"  ", "     {", "         YR_OBJECT_FUNCTION* function;", "         char* args_fmt;", "         if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&", "             (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_FUNCTION)", "         {", "           compiler->last_result = yr_parser_check_types(", "               compiler, (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object, (yyvsp[-1].c_string));", "           if (compiler->last_result == ERROR_SUCCESS)", "             compiler->last_result = yr_arena_write_string(", "               compiler->sz_arena, (yyvsp[-1].c_string), &args_fmt);", "           if (compiler->last_result == ERROR_SUCCESS)", "             compiler->last_result = yr_parser_emit_with_arg_reloc(", "                 yyscanner,", "                 OP_CALL,", "                 args_fmt,", "                 NULL,", "                 NULL);", "           function = (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object;", "           (yyval.expression).type = EXPRESSION_TYPE_OBJECT;", "           (yyval.expression).value.object = function->return_obj;", "           (yyval.expression).identifier = function->identifier;", "         }", "         else", "         {", "           yr_compiler_set_error_extra_info(", "               compiler, (yyvsp[-3].expression).identifier);", "           compiler->last_result = ERROR_NOT_A_FUNCTION;", "         }", "         yr_free((yyvsp[-1].c_string));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "       }", " #line 2328 \"grammar.c\"  ", "     break;", "   case 49:", " #line 801 \"grammar.y\"  ", "     { (yyval.c_string) = yr_strdup(\"\"); }", " #line 2334 \"grammar.c\"  ", "     break;", "   case 50:", " #line 802 \"grammar.y\"  ", "     { (yyval.c_string) = (yyvsp[0].c_string); }", " #line 2340 \"grammar.c\"  ", "     break;", "   case 51:", " #line 807 \"grammar.y\"  ", "     {", "         (yyval.c_string) = (char*) yr_malloc(MAX_FUNCTION_ARGS + 1);", "         switch((yyvsp[0].expression).type)", "         {", "           case EXPRESSION_TYPE_INTEGER:", "             strlcpy((yyval.c_string), \"i\", MAX_FUNCTION_ARGS);", "             break;", "           case EXPRESSION_TYPE_FLOAT:", "             strlcpy((yyval.c_string), \"f\", MAX_FUNCTION_ARGS);", "             break;", "           case EXPRESSION_TYPE_BOOLEAN:", "             strlcpy((yyval.c_string), \"b\", MAX_FUNCTION_ARGS);", "             break;", "           case EXPRESSION_TYPE_STRING:", "             strlcpy((yyval.c_string), \"s\", MAX_FUNCTION_ARGS);", "             break;", "           case EXPRESSION_TYPE_REGEXP:", "             strlcpy((yyval.c_string), \"r\", MAX_FUNCTION_ARGS);", "             break;", "         }", "         ERROR_IF((yyval.c_string) == NULL);", "       }", " #line 2369 \"grammar.c\"  ", "     break;", "   case 52:", " #line 832 \"grammar.y\"  ", "     {", "         if (strlen((yyvsp[-2].c_string)) == MAX_FUNCTION_ARGS)", "         {", "           compiler->last_result = ERROR_TOO_MANY_ARGUMENTS;", "         }", "         else", "         {", "           switch((yyvsp[0].expression).type)", "           {", "             case EXPRESSION_TYPE_INTEGER:", "               strlcat((yyvsp[-2].c_string), \"i\", MAX_FUNCTION_ARGS);", "               break;", "             case EXPRESSION_TYPE_FLOAT:", "               strlcat((yyvsp[-2].c_string), \"f\", MAX_FUNCTION_ARGS);", "               break;", "             case EXPRESSION_TYPE_BOOLEAN:", "               strlcat((yyvsp[-2].c_string), \"b\", MAX_FUNCTION_ARGS);", "               break;", "             case EXPRESSION_TYPE_STRING:", "               strlcat((yyvsp[-2].c_string), \"s\", MAX_FUNCTION_ARGS);", "               break;", "             case EXPRESSION_TYPE_REGEXP:", "               strlcat((yyvsp[-2].c_string), \"r\", MAX_FUNCTION_ARGS);", "               break;", "           }", "         }", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         (yyval.c_string) = (yyvsp[-2].c_string);", "       }", " #line 2405 \"grammar.c\"  ", "     break;", "   case 53:", " #line 868 \"grammar.y\"  ", "     {", "         SIZED_STRING* sized_string = (yyvsp[0].sized_string);", "         RE* re;", "         RE_ERROR error;", "         int re_flags = 0;", "         if (sized_string->flags & SIZED_STRING_FLAGS_NO_CASE)", "           re_flags |= RE_FLAGS_NO_CASE;", "         if (sized_string->flags & SIZED_STRING_FLAGS_DOT_ALL)", "           re_flags |= RE_FLAGS_DOT_ALL;", "         compiler->last_result = yr_re_compile(", "             sized_string->c_string,", "             re_flags,", "             compiler->re_code_arena,", "             &re,", "             &error);", "         yr_free((yyvsp[0].sized_string));", "         if (compiler->last_result == ERROR_INVALID_REGULAR_EXPRESSION)", "           yr_compiler_set_error_extra_info(compiler, error.message);", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         if (compiler->last_result == ERROR_SUCCESS)", "           compiler->last_result = yr_parser_emit_with_arg_reloc(", "               yyscanner,", "               OP_PUSH,", "               re->root_node->forward_code,", "               NULL,", "               NULL);", "         yr_re_destroy(re);", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         (yyval.expression).type = EXPRESSION_TYPE_REGEXP;", "       }", " #line 2451 \"grammar.c\"  ", "     break;", "   case 54:", " #line 914 \"grammar.y\"  ", "     {", "         if ((yyvsp[0].expression).type == EXPRESSION_TYPE_STRING)", "         {", "           if ((yyvsp[0].expression).value.sized_string != NULL)", "           {", "             yywarning(yyscanner,", "               \"Using literal string \\\"%s\\\" in a boolean operation.\",", "               (yyvsp[0].expression).value.sized_string->c_string);", "           }", "           compiler->last_result = yr_parser_emit(", "               yyscanner, OP_STR_TO_BOOL, NULL);", "           ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         }", "         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "       }", " #line 2474 \"grammar.c\"  ", "     break;", "   case 55:", " #line 936 \"grammar.y\"  ", "     {", "         compiler->last_result = yr_parser_emit_with_arg(", "             yyscanner, OP_PUSH, 1, NULL, NULL);", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "       }", " #line 2487 \"grammar.c\"  ", "     break;", "   case 56:", " #line 945 \"grammar.y\"  ", "     {", "         compiler->last_result = yr_parser_emit_with_arg(", "             yyscanner, OP_PUSH, 0, NULL, NULL);", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "       }", " #line 2500 \"grammar.c\"  ", "     break;", "   case 57:", " #line 954 \"grammar.y\"  ", "     {", "         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, \"matches\");", "         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_REGEXP, \"matches\");", "         if (compiler->last_result == ERROR_SUCCESS)", "           compiler->last_result = yr_parser_emit(", "               yyscanner,", "               OP_MATCHES,", "               NULL);", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "       }", " #line 2519 \"grammar.c\"  ", "     break;", "   case 58:", " #line 969 \"grammar.y\"  ", "     {", "         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, \"contains\");", "         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_STRING, \"contains\");", "         compiler->last_result = yr_parser_emit(", "             yyscanner, OP_CONTAINS, NULL);", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "       }", " #line 2535 \"grammar.c\"  ", "     break;", "   case 59:", " #line 981 \"grammar.y\"  ", "     {", "         int result = yr_parser_reduce_string_identifier(", "             yyscanner,", "             (yyvsp[0].c_string),", "             OP_FOUND,", "             UNDEFINED);", "         yr_free((yyvsp[0].c_string));", "         ERROR_IF(result != ERROR_SUCCESS);", "         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "       }", " #line 2553 \"grammar.c\"  ", "     break;", "   case 60:", " #line 995 \"grammar.y\"  ", "     {", "         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"at\");", "         compiler->last_result = yr_parser_reduce_string_identifier(", "             yyscanner, (yyvsp[-2].c_string), OP_FOUND_AT, (yyvsp[0].expression).value.integer);", "         yr_free((yyvsp[-2].c_string));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "       }", " #line 2570 \"grammar.c\"  ", "     break;", "   case 61:", " #line 1008 \"grammar.y\"  ", "     {", "         compiler->last_result = yr_parser_reduce_string_identifier(", "             yyscanner, (yyvsp[-2].c_string), OP_FOUND_IN, UNDEFINED);", "         yr_free((yyvsp[-2].c_string));", "         ERROR_IF(compiler->last_result!= ERROR_SUCCESS);", "         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "       }", " #line 2585 \"grammar.c\"  ", "     break;", "    case 62:", "  #line 1019 \"grammar.y\"  ", "     {", "         compiler->loop_depth--;", "         compiler->loop_identifier[compiler->loop_depth] = NULL;", "       }", " #line 2594 \"grammar.c\"  ", "     break;", "   case 63:", " #line 1024 \"grammar.y\"  ", "      {", "          int var_index;", "         if (compiler->loop_depth == MAX_LOOP_NESTING)", "           compiler->last_result = \\", "               ERROR_LOOP_NESTING_LIMIT_EXCEEDED;", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         var_index = yr_parser_lookup_loop_variable(", "             yyscanner, (yyvsp[-1].c_string));", "         if (var_index >= 0)", "         {", "           yr_compiler_set_error_extra_info(", "               compiler, (yyvsp[-1].c_string));", "           compiler->last_result = \\", "               ERROR_DUPLICATED_LOOP_IDENTIFIER;", "         }", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         compiler->last_result = yr_parser_emit_with_arg(", "             yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);", "          ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "        }", "#line 2619 \"grammar.c\"  ", " #line 2628 \"grammar.c\"  ", "      break;", "  case 63:", "#line 1049 \"grammar.y\"  ", "   case 64:", " #line 1054 \"grammar.y\"  ", "      {", "          int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;", "          uint8_t* addr;", "         yr_parser_emit_with_arg(", "             yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);", "         yr_parser_emit_with_arg(", "             yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);", "         if ((yyvsp[-1].integer) == INTEGER_SET_ENUMERATION)", "         {", "           yr_parser_emit_with_arg(", "               yyscanner, OP_POP_M, mem_offset, &addr, NULL);", "         }", "         else  ", "         {", "           yr_parser_emit_with_arg(", "               yyscanner, OP_POP_M, mem_offset + 3, &addr, NULL);", "           yr_parser_emit_with_arg(", "               yyscanner, OP_POP_M, mem_offset, NULL, NULL);", "         }", "         compiler->loop_address[compiler->loop_depth] = addr;", "          compiler->loop_identifier[compiler->loop_depth] = (yyvsp[-4].c_string);", "          compiler->loop_depth++;", "        }", "#line 2658 \"grammar.c\"  ", " #line 2667 \"grammar.c\"  ", "      break;", "  case 64:", "#line 1084 \"grammar.y\"  ", "   case 65:", " #line 1089 \"grammar.y\"  ", "      {", "          int mem_offset;", "         compiler->loop_depth--;", "         mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;", "         yr_parser_emit_with_arg(", "             yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);", "         yr_parser_emit_with_arg(", "             yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);", "         if ((yyvsp[-5].integer) == INTEGER_SET_ENUMERATION)", "         {", "           yr_parser_emit_with_arg_reloc(", "               yyscanner,", "               OP_JNUNDEF,", "               compiler->loop_address[compiler->loop_depth],", "               NULL,", "               NULL);", "         }", "         else  ", "         {", "           yr_parser_emit_with_arg(", "               yyscanner, OP_INCR_M, mem_offset, NULL, NULL);", "           yr_parser_emit_with_arg(", "               yyscanner, OP_PUSH_M, mem_offset, NULL, NULL);", "           yr_parser_emit_with_arg(", "               yyscanner, OP_PUSH_M, mem_offset + 3, NULL, NULL);", "           yr_parser_emit_with_arg_reloc(", "               yyscanner,", "               OP_JLE,", "               compiler->loop_address[compiler->loop_depth],", "               NULL,", "               NULL);", "           yr_parser_emit(yyscanner, OP_POP, NULL);", "           yr_parser_emit(yyscanner, OP_POP, NULL);", "         }", "         yr_parser_emit(yyscanner, OP_POP, NULL);", "         yr_parser_emit_with_arg(", "             yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);", "         yr_parser_emit_with_arg(", "             yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);", "         yr_parser_emit(yyscanner, OP_INT_LE, NULL);", "         compiler->loop_identifier[compiler->loop_depth] = NULL;", "         yr_free((yyvsp[-8].c_string));", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "        }", "#line 2741 \"grammar.c\"  ", " #line 2750 \"grammar.c\"  ", "      break;", "  case 65:", "#line 1163 \"grammar.y\"  ", "   case 66:", " #line 1168 \"grammar.y\"  ", "      {", "          int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;", "          uint8_t* addr;", "         if (compiler->loop_depth == MAX_LOOP_NESTING)", "           compiler->last_result = \\", "             ERROR_LOOP_NESTING_LIMIT_EXCEEDED;", "         if (compiler->loop_for_of_mem_offset != -1)", "           compiler->last_result = \\", "             ERROR_NESTED_FOR_OF_LOOP;", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         yr_parser_emit_with_arg(", "             yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);", "         yr_parser_emit_with_arg(", "             yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);", "         yr_parser_emit_with_arg(", "             yyscanner, OP_POP_M, mem_offset, &addr, NULL);", "         compiler->loop_for_of_mem_offset = mem_offset;", "         compiler->loop_address[compiler->loop_depth] = addr;", "          compiler->loop_identifier[compiler->loop_depth] = NULL;", "          compiler->loop_depth++;", "        }", "#line 2775 \"grammar.c\"  ", " #line 2784 \"grammar.c\"  ", "      break;", "  case 66:", "#line 1193 \"grammar.y\"  ", "   case 67:", " #line 1198 \"grammar.y\"  ", "      {", "          int mem_offset;", "         compiler->loop_depth--;", "         compiler->loop_for_of_mem_offset = -1;", "         mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;", "         yr_parser_emit_with_arg(", "             yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);", "         yr_parser_emit_with_arg(", "             yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);", "         yr_parser_emit_with_arg_reloc(", "             yyscanner,", "             OP_JNUNDEF,", "             compiler->loop_address[compiler->loop_depth],", "             NULL,", "             NULL);", "         yr_parser_emit(yyscanner, OP_POP, NULL);", "         yr_parser_emit_with_arg(", "             yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);", "         yr_parser_emit_with_arg(", "             yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);", "         yr_parser_emit(yyscanner, OP_INT_LE, NULL);", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "        }", "#line 2828 \"grammar.c\"  ", " #line 2837 \"grammar.c\"  ", "      break;", "  case 67:", "#line 1242 \"grammar.y\"  ", "   case 68:", " #line 1247 \"grammar.y\"  ", "      {", "          yr_parser_emit(yyscanner, OP_OF, NULL);", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "        }", "#line 2838 \"grammar.c\"  ", " #line 2847 \"grammar.c\"  ", "      break;", "  case 68:", "#line 1248 \"grammar.y\"  ", "   case 69:", " #line 1253 \"grammar.y\"  ", "      {", "          yr_parser_emit(yyscanner, OP_NOT, NULL);", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "        }", "#line 2848 \"grammar.c\"  ", " #line 2857 \"grammar.c\"  ", "      break;", "  case 69:", "#line 1254 \"grammar.y\"  ", "   case 70:", " #line 1259 \"grammar.y\"  ", "      {", "          YR_FIXUP* fixup;", "          void* jmp_destination_addr;", "         compiler->last_result = yr_parser_emit_with_arg_reloc(", "             yyscanner,", "             OP_JFALSE,", "             0,           ", "             NULL,", "             &jmp_destination_addr);", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));", "         if (fixup == NULL)", "           compiler->last_error = ERROR_INSUFFICIENT_MEMORY;", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         fixup->address = jmp_destination_addr;", "          fixup->next = compiler->fixup_stack_head;", "          compiler->fixup_stack_head = fixup;", "        }", "#line 2878 \"grammar.c\"  ", " #line 2887 \"grammar.c\"  ", "      break;", "  case 70:", "#line 1280 \"grammar.y\"  ", "   case 71:", " #line 1285 \"grammar.y\"  ", "      {", "          YR_FIXUP* fixup;", "          uint8_t* and_addr;", "         compiler->last_result = yr_arena_reserve_memory(", "             compiler->code_arena, 2);", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         compiler->last_result = yr_parser_emit(yyscanner, OP_AND, &and_addr);", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         fixup = compiler->fixup_stack_head;", "         *(void**)(fixup->address) = (void*)(and_addr + 1);", "         compiler->fixup_stack_head = fixup->next;", "         yr_free(fixup);", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "        }", "#line 2918 \"grammar.c\"  ", " #line 2927 \"grammar.c\"  ", "      break;", "  case 71:", "#line 1316 \"grammar.y\"  ", "   case 72:", " #line 1321 \"grammar.y\"  ", "      {", "          YR_FIXUP* fixup;", "          void* jmp_destination_addr;", "         compiler->last_result = yr_parser_emit_with_arg_reloc(", "             yyscanner,", "             OP_JTRUE,", "             0,          ", "             NULL,", "             &jmp_destination_addr);", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));", "         if (fixup == NULL)", "           compiler->last_error = ERROR_INSUFFICIENT_MEMORY;", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         fixup->address = jmp_destination_addr;", "          fixup->next = compiler->fixup_stack_head;", "          compiler->fixup_stack_head = fixup;", "        }", "#line 2947 \"grammar.c\"  ", " #line 2956 \"grammar.c\"  ", "      break;", "  case 72:", "#line 1341 \"grammar.y\"  ", "   case 73:", " #line 1346 \"grammar.y\"  ", "      {", "          YR_FIXUP* fixup;", "          uint8_t* or_addr;", "         compiler->last_result = yr_arena_reserve_memory(", "             compiler->code_arena, 2);", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         compiler->last_result = yr_parser_emit(yyscanner, OP_OR, &or_addr);", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         fixup = compiler->fixup_stack_head;", "         *(void**)(fixup->address) = (void*)(or_addr + 1);", "         compiler->fixup_stack_head = fixup->next;", "         yr_free(fixup);", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "        }", "#line 2987 \"grammar.c\"  ", " #line 2996 \"grammar.c\"  ", "      break;", "  case 73:", "#line 1377 \"grammar.y\"  ", "   case 74:", " #line 1382 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_reduce_operation(", "              yyscanner, \"<\", (yyvsp[-2].expression), (yyvsp[0].expression));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "        }", "#line 3000 \"grammar.c\"  ", " #line 3009 \"grammar.c\"  ", "      break;", "  case 74:", "#line 1386 \"grammar.y\"  ", "   case 75:", " #line 1391 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_reduce_operation(", "              yyscanner, \">\", (yyvsp[-2].expression), (yyvsp[0].expression));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "        }", "#line 3013 \"grammar.c\"  ", " #line 3022 \"grammar.c\"  ", "      break;", "  case 75:", "#line 1395 \"grammar.y\"  ", "   case 76:", " #line 1400 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_reduce_operation(", "              yyscanner, \"<=\", (yyvsp[-2].expression), (yyvsp[0].expression));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "        }", "#line 3026 \"grammar.c\"  ", " #line 3035 \"grammar.c\"  ", "      break;", "  case 76:", "#line 1404 \"grammar.y\"  ", "   case 77:", " #line 1409 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_reduce_operation(", "              yyscanner, \">=\", (yyvsp[-2].expression), (yyvsp[0].expression));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "        }", "#line 3039 \"grammar.c\"  ", " #line 3048 \"grammar.c\"  ", "      break;", "  case 77:", "#line 1413 \"grammar.y\"  ", "   case 78:", " #line 1418 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_reduce_operation(", "              yyscanner, \"==\", (yyvsp[-2].expression), (yyvsp[0].expression));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "        }", "#line 3052 \"grammar.c\"  ", " #line 3061 \"grammar.c\"  ", "      break;", "  case 78:", "#line 1422 \"grammar.y\"  ", "   case 79:", " #line 1427 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_reduce_operation(", "              yyscanner, \"!=\", (yyvsp[-2].expression), (yyvsp[0].expression));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "        }", "#line 3065 \"grammar.c\"  ", " #line 3074 \"grammar.c\"  ", "      break;", "  case 79:", "#line 1431 \"grammar.y\"  ", "   case 80:", " #line 1436 \"grammar.y\"  ", "      {", "          (yyval.expression) = (yyvsp[0].expression);", "        }", "#line 3073 \"grammar.c\"  ", " #line 3082 \"grammar.c\"  ", "      break;", "  case 80:", "#line 1435 \"grammar.y\"  ", "   case 81:", " #line 1440 \"grammar.y\"  ", "      {", "          (yyval.expression) = (yyvsp[-1].expression);", "        }", "#line 3081 \"grammar.c\"  ", " #line 3090 \"grammar.c\"  ", "      break;", "  case 81:", "#line 1442 \"grammar.y\"  ", "   case 82:", " #line 1447 \"grammar.y\"  ", "      { (yyval.integer) = INTEGER_SET_ENUMERATION; }", "#line 3087 \"grammar.c\"  ", " #line 3096 \"grammar.c\"  ", "      break;", "  case 82:", "#line 1443 \"grammar.y\"  ", "   case 83:", " #line 1448 \"grammar.y\"  ", "      { (yyval.integer) = INTEGER_SET_RANGE; }", "#line 3093 \"grammar.c\"  ", " #line 3102 \"grammar.c\"  ", "      break;", "  case 83:", "#line 1449 \"grammar.y\"  ", "   case 84:", " #line 1454 \"grammar.y\"  ", "      {", "          if ((yyvsp[-3].expression).type != EXPRESSION_TYPE_INTEGER)", "          {", "           yr_compiler_set_error_extra_info(", "               compiler, \"wrong type for range's lower bound\");", "           compiler->last_result = ERROR_WRONG_TYPE;", "         }", "         if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)", "         {", "           yr_compiler_set_error_extra_info(", "               compiler, \"wrong type for range's upper bound\");", "           compiler->last_result = ERROR_WRONG_TYPE;", "         }", "          ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "        }", "#line 3115 \"grammar.c\"  ", " #line 3124 \"grammar.c\"  ", "      break;", "  case 84:", "#line 1471 \"grammar.y\"  ", "   case 85:", " #line 1476 \"grammar.y\"  ", "      {", "          if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)", "          {", "           yr_compiler_set_error_extra_info(", "               compiler, \"wrong type for enumeration item\");", "           compiler->last_result = ERROR_WRONG_TYPE;", "         }", "          ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "        }", "#line 3131 \"grammar.c\"  ", " #line 3140 \"grammar.c\"  ", "      break;", "  case 85:", "#line 1483 \"grammar.y\"  ", "   case 86:", " #line 1488 \"grammar.y\"  ", "      {", "          if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)", "          {", "           yr_compiler_set_error_extra_info(", "               compiler, \"wrong type for enumeration item\");", "           compiler->last_result = ERROR_WRONG_TYPE;", "         }", "          ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "        }", "#line 3146 \"grammar.c\"  ", " #line 3155 \"grammar.c\"  ", "      break;", "  case 86:", "#line 1498 \"grammar.y\"  ", "   case 87:", " #line 1503 \"grammar.y\"  ", "      {", "          yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);", "        }", "#line 3155 \"grammar.c\"  ", " #line 3164 \"grammar.c\"  ", "      break;", "  case 88:", "#line 1504 \"grammar.y\"  ", "   case 89:", " #line 1509 \"grammar.y\"  ", "      {", "          yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);", "          yr_parser_emit_pushes_for_strings(yyscanner, \"$*\");", "          ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "        }", "#line 3166 \"grammar.c\"  ", " #line 3175 \"grammar.c\"  ", "      break;", "  case 91:", "#line 1521 \"grammar.y\"  ", "   case 92:", " #line 1526 \"grammar.y\"  ", "      {", "          yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));", "          yr_free((yyvsp[0].c_string));", "          ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "        }", "#line 3177 \"grammar.c\"  ", " #line 3186 \"grammar.c\"  ", "      break;", "  case 92:", "#line 1528 \"grammar.y\"  ", "   case 93:", " #line 1533 \"grammar.y\"  ", "      {", "          yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));", "          yr_free((yyvsp[0].c_string));", "          ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "        }", "#line 3188 \"grammar.c\"  ", " #line 3197 \"grammar.c\"  ", "      break;", "  case 94:", "#line 1540 \"grammar.y\"  ", "   case 95:", " #line 1545 \"grammar.y\"  ", "      {", "          yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);", "        }", "#line 3196 \"grammar.c\"  ", " #line 3205 \"grammar.c\"  ", "      break;", "  case 95:", "#line 1544 \"grammar.y\"  ", "   case 96:", " #line 1549 \"grammar.y\"  ", "      {", "          yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);", "        }", "#line 3204 \"grammar.c\"  ", " #line 3213 \"grammar.c\"  ", "      break;", "  case 96:", "#line 1552 \"grammar.y\"  ", "   case 97:", " #line 1557 \"grammar.y\"  ", "      {", "          (yyval.expression) = (yyvsp[-1].expression);", "        }", "#line 3212 \"grammar.c\"  ", " #line 3221 \"grammar.c\"  ", "      break;", "  case 97:", "#line 1556 \"grammar.y\"  ", "   case 98:", " #line 1561 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_emit(", "              yyscanner, OP_FILESIZE, NULL);", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = UNDEFINED;", "        }", "#line 3226 \"grammar.c\"  ", " #line 3235 \"grammar.c\"  ", "      break;", "  case 98:", "#line 1566 \"grammar.y\"  ", "   case 99:", " #line 1571 \"grammar.y\"  ", "      {", "          yywarning(yyscanner,", "              \"Using deprecated \\\"entrypoint\\\" keyword. Use the \\\"entry_point\\\" \"", "             \"function from PE module instead.\");", "         compiler->last_result = yr_parser_emit(", "             yyscanner, OP_ENTRYPOINT, NULL);", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = UNDEFINED;", "        }", "#line 3244 \"grammar.c\"  ", " #line 3253 \"grammar.c\"  ", "      break;", "  case 99:", "#line 1580 \"grammar.y\"  ", "   case 100:", " #line 1585 \"grammar.y\"  ", "      {", "          CHECK_TYPE((yyvsp[-1].expression), EXPRESSION_TYPE_INTEGER, \"intXXXX or uintXXXX\");", "         compiler->last_result = yr_parser_emit(", "             yyscanner, (uint8_t) (OP_READ_INT + (yyvsp[-3].integer)), NULL);", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = UNDEFINED;", "        }", "#line 3264 \"grammar.c\"  ", " #line 3273 \"grammar.c\"  ", "      break;", "  case 100:", "#line 1596 \"grammar.y\"  ", "   case 101:", " #line 1601 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_emit_with_arg(", "              yyscanner, OP_PUSH, (yyvsp[0].integer), NULL, NULL);", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = (yyvsp[0].integer);", "        }", "#line 3278 \"grammar.c\"  ", " #line 3287 \"grammar.c\"  ", "      break;", "  case 101:", "#line 1606 \"grammar.y\"  ", "   case 102:", " #line 1611 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_emit_with_arg_double(", "              yyscanner, OP_PUSH, (yyvsp[0].double_), NULL, NULL);", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;", "        }", "#line 3291 \"grammar.c\"  ", " #line 3300 \"grammar.c\"  ", "      break;", "  case 102:", "#line 1615 \"grammar.y\"  ", "   case 103:", " #line 1620 \"grammar.y\"  ", "      {", "          SIZED_STRING* sized_string;", "         compiler->last_result = yr_arena_write_data(", "             compiler->sz_arena,", "             (yyvsp[0].sized_string),", "             (yyvsp[0].sized_string)->length + sizeof(SIZED_STRING),", "             (void**) &sized_string);", "         yr_free((yyvsp[0].sized_string));", "         if (compiler->last_result == ERROR_SUCCESS)", "           compiler->last_result = yr_parser_emit_with_arg_reloc(", "               yyscanner,", "               OP_PUSH,", "               sized_string,", "               NULL,", "               NULL);", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          (yyval.expression).type = EXPRESSION_TYPE_STRING;", "          (yyval.expression).value.sized_string = sized_string;", "        }", "#line 3320 \"grammar.c\"  ", " #line 3329 \"grammar.c\"  ", "      break;", "  case 103:", "#line 1640 \"grammar.y\"  ", "   case 104:", " #line 1645 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_reduce_string_identifier(", "              yyscanner, (yyvsp[0].c_string), OP_COUNT, UNDEFINED);", "         yr_free((yyvsp[0].c_string));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = UNDEFINED;", "        }", "#line 3336 \"grammar.c\"  ", " #line 3345 \"grammar.c\"  ", "      break;", "  case 104:", "#line 1652 \"grammar.y\"  ", "   case 105:", " #line 1657 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_reduce_string_identifier(", "              yyscanner, (yyvsp[-3].c_string), OP_OFFSET, UNDEFINED);", "         yr_free((yyvsp[-3].c_string));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = UNDEFINED;", "        }", "#line 3352 \"grammar.c\"  ", " #line 3361 \"grammar.c\"  ", "      break;", "  case 105:", "#line 1664 \"grammar.y\"  ", "   case 106:", " #line 1669 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_emit_with_arg(", "              yyscanner, OP_PUSH, 1, NULL, NULL);", "         if (compiler->last_result == ERROR_SUCCESS)", "           compiler->last_result = yr_parser_reduce_string_identifier(", "               yyscanner, (yyvsp[0].c_string), OP_OFFSET, UNDEFINED);", "         yr_free((yyvsp[0].c_string));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = UNDEFINED;", "        }", "#line 3372 \"grammar.c\"  ", " #line 3381 \"grammar.c\"  ", "      break;", "  case 106:", "#line 1680 \"grammar.y\"  ", "   case 107:", " #line 1685 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_reduce_string_identifier(", "              yyscanner, (yyvsp[-3].c_string), OP_LENGTH, UNDEFINED);", "         yr_free((yyvsp[-3].c_string));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = UNDEFINED;", "        }", "#line 3388 \"grammar.c\"  ", " #line 3397 \"grammar.c\"  ", "      break;", "  case 107:", "#line 1692 \"grammar.y\"  ", "   case 108:", " #line 1697 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_emit_with_arg(", "              yyscanner, OP_PUSH, 1, NULL, NULL);", "         if (compiler->last_result == ERROR_SUCCESS)", "           compiler->last_result = yr_parser_reduce_string_identifier(", "               yyscanner, (yyvsp[0].c_string), OP_LENGTH, UNDEFINED);", "         yr_free((yyvsp[0].c_string));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = UNDEFINED;", "        }", "#line 3408 \"grammar.c\"  ", " #line 3417 \"grammar.c\"  ", "      break;", "  case 108:", "#line 1708 \"grammar.y\"  ", "   case 109:", " #line 1713 \"grammar.y\"  ", "      {", "          if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)   ", "          {", "           (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "           (yyval.expression).value.integer = UNDEFINED;", "         }", "         else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_BOOLEAN)   ", "         {", "           (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "           (yyval.expression).value.integer = UNDEFINED;", "         }", "         else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_OBJECT)", "         {", "           compiler->last_result = yr_parser_emit(", "               yyscanner, OP_OBJ_VALUE, NULL);", "           switch((yyvsp[0].expression).value.object->type)", "           {", "             case OBJECT_TYPE_INTEGER:", "               (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "               (yyval.expression).value.integer = UNDEFINED;", "               break;", "             case OBJECT_TYPE_FLOAT:", "               (yyval.expression).type = EXPRESSION_TYPE_FLOAT;", "               break;", "             case OBJECT_TYPE_STRING:", "               (yyval.expression).type = EXPRESSION_TYPE_STRING;", "               (yyval.expression).value.sized_string = NULL;", "               break;", "             default:", "               yr_compiler_set_error_extra_info_fmt(", "                   compiler,", "                   \"wrong usage of identifier \\\"%s\\\"\",", "                   (yyvsp[0].expression).identifier);", "               compiler->last_result = ERROR_WRONG_TYPE;", "           }", "         }", "         else", "         {", "           assert(FALSE);", "         }", "          ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "        }", "#line 3457 \"grammar.c\"  ", " #line 3466 \"grammar.c\"  ", "      break;", "  case 109:", "#line 1753 \"grammar.y\"  ", "   case 110:", " #line 1758 \"grammar.y\"  ", "      {", "          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, \"-\");", "         if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)", "         {", "           (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "           (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?", "               UNDEFINED : -((yyvsp[0].expression).value.integer);", "           compiler->last_result = yr_parser_emit(yyscanner, OP_INT_MINUS, NULL);", "         }", "         else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_FLOAT)", "         {", "           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;", "           compiler->last_result = yr_parser_emit(yyscanner, OP_DBL_MINUS, NULL);", "         }", "          ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "        }", "#line 3480 \"grammar.c\"  ", " #line 3489 \"grammar.c\"  ", "      break;", "  case 110:", "#line 1772 \"grammar.y\"  ", "   case 111:", " #line 1777 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_reduce_operation(", "              yyscanner, \"+\", (yyvsp[-2].expression), (yyvsp[0].expression));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&", "             (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)", "         {", "           (yyval.expression).value.integer = OPERATION(+, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);", "           (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "         }", "         else", "         {", "            (yyval.expression).type = EXPRESSION_TYPE_FLOAT;", "          }", "        }", "#line 3502 \"grammar.c\"  ", " #line 3511 \"grammar.c\"  ", "      break;", "  case 111:", "#line 1790 \"grammar.y\"  ", "   case 112:", " #line 1795 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_reduce_operation(", "              yyscanner, \"-\", (yyvsp[-2].expression), (yyvsp[0].expression));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&", "             (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)", "         {", "           (yyval.expression).value.integer = OPERATION(-, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);", "           (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "         }", "         else", "         {", "            (yyval.expression).type = EXPRESSION_TYPE_FLOAT;", "          }", "        }", "#line 3524 \"grammar.c\"  ", " #line 3533 \"grammar.c\"  ", "      break;", "  case 112:", "#line 1808 \"grammar.y\"  ", "   case 113:", " #line 1813 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_reduce_operation(", "              yyscanner, \"*\", (yyvsp[-2].expression), (yyvsp[0].expression));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&", "             (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)", "         {", "           (yyval.expression).value.integer = OPERATION(*, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);", "           (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "         }", "         else", "         {", "            (yyval.expression).type = EXPRESSION_TYPE_FLOAT;", "          }", "        }", "#line 3546 \"grammar.c\"  ", " #line 3555 \"grammar.c\"  ", "      break;", "  case 113:", "#line 1826 \"grammar.y\"  ", "   case 114:", " #line 1831 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_reduce_operation(", "              yyscanner, \"\\\\\", (yyvsp[-2].expression), (yyvsp[0].expression));", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&", "             (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)", "         {", "           if ((yyvsp[0].expression).value.integer != 0)", "           {", "             (yyval.expression).value.integer = OPERATION(/, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);", "             (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "           }", "           else", "           {", "             compiler->last_result = ERROR_DIVISION_BY_ZERO;", "             ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "           }", "         }", "         else", "         {", "            (yyval.expression).type = EXPRESSION_TYPE_FLOAT;", "          }", "        }", "#line 3576 \"grammar.c\"  ", " #line 3585 \"grammar.c\"  ", "      break;", "  case 114:", "#line 1852 \"grammar.y\"  ", "   case 115:", " #line 1857 \"grammar.y\"  ", "      {", "          CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"%\");", "          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"%\");", "         yr_parser_emit(yyscanner, OP_MOD, NULL);", "         if ((yyvsp[0].expression).value.integer != 0)", "         {", "           (yyval.expression).value.integer = OPERATION(%, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);", "           (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "         }", "         else", "         {", "           compiler->last_result = ERROR_DIVISION_BY_ZERO;", "            ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          }", "        }", "#line 3598 \"grammar.c\"  ", " #line 3607 \"grammar.c\"  ", "      break;", "  case 115:", "#line 1870 \"grammar.y\"  ", "   case 116:", " #line 1875 \"grammar.y\"  ", "      {", "          CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"^\");", "          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"^\");", "         yr_parser_emit(yyscanner, OP_BITWISE_XOR, NULL);", "          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = OPERATION(^, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);", "        }", "#line 3612 \"grammar.c\"  ", " #line 3621 \"grammar.c\"  ", "      break;", "  case 116:", "#line 1880 \"grammar.y\"  ", "   case 117:", " #line 1885 \"grammar.y\"  ", "      {", "          CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"^\");", "          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"^\");", "         yr_parser_emit(yyscanner, OP_BITWISE_AND, NULL);", "          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = OPERATION(&, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);", "        }", "#line 3626 \"grammar.c\"  ", " #line 3635 \"grammar.c\"  ", "      break;", "  case 117:", "#line 1890 \"grammar.y\"  ", "   case 118:", " #line 1895 \"grammar.y\"  ", "      {", "          CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"|\");", "          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"|\");", "         yr_parser_emit(yyscanner, OP_BITWISE_OR, NULL);", "          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = OPERATION(|, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);", "        }", "#line 3640 \"grammar.c\"  ", " #line 3649 \"grammar.c\"  ", "      break;", "  case 118:", "#line 1900 \"grammar.y\"  ", "   case 119:", " #line 1905 \"grammar.y\"  ", "      {", "          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"~\");", "         yr_parser_emit(yyscanner, OP_BITWISE_NOT, NULL);", "         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?", "              UNDEFINED : ~((yyvsp[0].expression).value.integer);", "        }", "#line 3654 \"grammar.c\"  ", " #line 3663 \"grammar.c\"  ", "      break;", "  case 119:", "#line 1910 \"grammar.y\"  ", "   case 120:", " #line 1915 \"grammar.y\"  ", "      {", "          CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"<<\");", "          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"<<\");", "         yr_parser_emit(yyscanner, OP_SHL, NULL);", "          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);", "        }", "#line 3668 \"grammar.c\"  ", " #line 3677 \"grammar.c\"  ", "      break;", "  case 120:", "#line 1920 \"grammar.y\"  ", "   case 121:", " #line 1925 \"grammar.y\"  ", "      {", "          CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \">>\");", "          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \">>\");", "         yr_parser_emit(yyscanner, OP_SHR, NULL);", "          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = OPERATION(>>, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);", "        }", "#line 3682 \"grammar.c\"  ", " #line 3691 \"grammar.c\"  ", "      break;", "  case 121:", "#line 1930 \"grammar.y\"  ", "   case 122:", " #line 1935 \"grammar.y\"  ", "      {", "          (yyval.expression) = (yyvsp[0].expression);", "        }", "#line 3690 \"grammar.c\"  ", " #line 3699 \"grammar.c\"  ", "      break;", "#line 3694 \"grammar.c\"  ", " #line 3703 \"grammar.c\"  ", "        default: break;", "      }", "   YY_SYMBOL_PRINT (\"-> $$ =\", yyr1[yyn], &yyval, &yyloc);", "   YYPOPSTACK (yylen);", "   yylen = 0;", "   YY_STACK_PRINT (yyss, yyssp);", "   *++yyvsp = yyval;", "   yyn = yyr1[yyn];", "   yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;", "   if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)", "     yystate = yytable[yystate];", "   else", "     yystate = yydefgoto[yyn - YYNTOKENS];", "   goto yynewstate;", " yyerrlab:", "   yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);", "   if (!yyerrstatus)", "     {", "       ++yynerrs;", " #if ! YYERROR_VERBOSE", "       yyerror (yyscanner, compiler, YY_(\"syntax error\"));", " #else", " # define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \\", "                                         yyssp, yytoken)", "       {", "         char const *yymsgp = YY_(\"syntax error\");", "         int yysyntax_error_status;", "         yysyntax_error_status = YYSYNTAX_ERROR;", "         if (yysyntax_error_status == 0)", "           yymsgp = yymsg;", "         else if (yysyntax_error_status == 1)", "           {", "             if (yymsg != yymsgbuf)", "               YYSTACK_FREE (yymsg);", "             yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);", "             if (!yymsg)", "               {", "                 yymsg = yymsgbuf;", "                 yymsg_alloc = sizeof yymsgbuf;", "                 yysyntax_error_status = 2;", "               }", "             else", "               {", "                 yysyntax_error_status = YYSYNTAX_ERROR;", "                 yymsgp = yymsg;", "               }", "           }", "         yyerror (yyscanner, compiler, yymsgp);", "         if (yysyntax_error_status == 2)", "           goto yyexhaustedlab;", "       }", " # undef YYSYNTAX_ERROR", " #endif", "     }", "   if (yyerrstatus == 3)", "     {", "       if (yychar <= YYEOF)", "         {", "           if (yychar == YYEOF)", "             YYABORT;", "         }", "       else", "         {", "           yydestruct (\"Error: discarding\",", "                       yytoken, &yylval, yyscanner, compiler);", "           yychar = YYEMPTY;", "         }", "     }", "   goto yyerrlab1;", " yyerrorlab:", "   if (  0)", "      goto yyerrorlab;", "   YYPOPSTACK (yylen);", "   yylen = 0;", "   YY_STACK_PRINT (yyss, yyssp);", "   yystate = *yyssp;", "   goto yyerrlab1;", " yyerrlab1:", "   yyerrstatus = 3;       ", "   for (;;)", "     {", "       yyn = yypact[yystate];", "       if (!yypact_value_is_default (yyn))", "         {", "           yyn += YYTERROR;", "           if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)", "             {", "               yyn = yytable[yyn];", "               if (0 < yyn)", "                 break;", "             }", "         }", "       if (yyssp == yyss)", "         YYABORT;", "       yydestruct (\"Error: popping\",", "                   yystos[yystate], yyvsp, yyscanner, compiler);", "       YYPOPSTACK (1);", "       yystate = *yyssp;", "       YY_STACK_PRINT (yyss, yyssp);", "     }", "   YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN", "   *++yyvsp = yylval;", "   YY_IGNORE_MAYBE_UNINITIALIZED_END", "   YY_SYMBOL_PRINT (\"Shifting\", yystos[yyn], yyvsp, yylsp);", "   yystate = yyn;", "   goto yynewstate;", " yyacceptlab:", "   yyresult = 0;", "   goto yyreturn;", " yyabortlab:", "   yyresult = 1;", "   goto yyreturn;", " #if !defined yyoverflow || YYERROR_VERBOSE", " yyexhaustedlab:", "   yyerror (yyscanner, compiler, YY_(\"memory exhausted\"));", "   yyresult = 2;", " #endif", " yyreturn:", "   if (yychar != YYEMPTY)", "     {", "       yytoken = YYTRANSLATE (yychar);", "       yydestruct (\"Cleanup: discarding lookahead\",", "                   yytoken, &yylval, yyscanner, compiler);", "     }", "   YYPOPSTACK (yylen);", "   YY_STACK_PRINT (yyss, yyssp);", "   while (yyssp != yyss)", "     {", "       yydestruct (\"Cleanup: popping\",", "                   yystos[*yyssp], yyvsp, yyscanner, compiler);", "       YYPOPSTACK (1);", "     }", " #ifndef yyoverflow", "   if (yyss != yyssa)", "     YYSTACK_FREE (yyss);", " #endif", " #if YYERROR_VERBOSE", "   if (yymsg != yymsgbuf)", "     YYSTACK_FREE (yymsg);", "  #endif", "    return yyresult;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void set_own_dir(const char *argv0) {", " \tsize_t l = strlen(argv0);", "  \twhile(l && argv0[l - 1] != '/')", "  \t\tl--;", "  \tif(l == 0)", " #ifdef SUPER_SECURE", " \t\tmemcpy(own_dir, \"/dev/null/\", 2);", " #else", "  \t\tmemcpy(own_dir, \".\", 2);", " #endif", "  \telse {", "  \t\tmemcpy(own_dir, argv0, l - 1);", "  \t\town_dir[l] = 0;", " \t}", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": [" static int parse_packet (sockent_t *se,  ", " \t\tvoid *buffer, size_t buffer_size, int flags,", " \t\tconst char *username)", " {", " \tint status;", " \tvalue_list_t vl = VALUE_LIST_INIT;", " \tnotification_t n;", " #if HAVE_LIBGCRYPT", " \tint packet_was_signed = (flags & PP_SIGNED);", "         int packet_was_encrypted = (flags & PP_ENCRYPTED);", " \tint printed_ignore_warning = 0;", " #endif  ", " \tmemset (&vl, '\\0', sizeof (vl));", " \tmemset (&n, '\\0', sizeof (n));", " \tstatus = 0;", " \twhile ((status == 0) && (0 < buffer_size)", " \t\t\t&& ((unsigned int) buffer_size > sizeof (part_header_t)))", " \t{", " \t\tuint16_t pkg_length;", " \t\tuint16_t pkg_type;", " \t\tmemcpy ((void *) &pkg_type,", " \t\t\t\t(void *) buffer,", " \t\t\t\tsizeof (pkg_type));", " \t\tmemcpy ((void *) &pkg_length,", " \t\t\t\t(void *) (buffer + sizeof (pkg_type)),", " \t\t\t\tsizeof (pkg_length));", " \t\tpkg_length = ntohs (pkg_length);", " \t\tpkg_type = ntohs (pkg_type);", " \t\tif (pkg_length > buffer_size)", " \t\t\tbreak;", " \t\tif (pkg_length < (2 * sizeof (uint16_t)))", " \t\t\tbreak;", " \t\tif (pkg_type == TYPE_ENCR_AES256)", " \t\t{", " \t\t\tstatus = parse_part_encr_aes256 (se,", " \t\t\t\t\t&buffer, &buffer_size, flags);", " \t\t\tif (status != 0)", " \t\t\t{", " \t\t\t\tERROR (\"network plugin: Decrypting AES256 \"", " \t\t\t\t\t\t\"part failed \"", " \t\t\t\t\t\t\"with status %i.\", status);", " \t\t\t\tbreak;", " \t\t\t}", " \t\t}", " #if HAVE_LIBGCRYPT", " \t\telse if ((se->data.server.security_level == SECURITY_LEVEL_ENCRYPT)", " \t\t\t\t&& (packet_was_encrypted == 0))", " \t\t{", " \t\t\tif (printed_ignore_warning == 0)", " \t\t\t{", " \t\t\t\tINFO (\"network plugin: Unencrypted packet or \"", " \t\t\t\t\t\t\"part has been ignored.\");", "  \t\t\t\tprinted_ignore_warning = 1;", "  \t\t\t}", "  \t\t\tbuffer = ((char *) buffer) + pkg_length;", " \t\t\tbuffer_size -= (size_t) pkg_length;", "  \t\t\tcontinue;", "  \t\t}", "  #endif  ", " \t\telse if (pkg_type == TYPE_SIGN_SHA256)", " \t\t{", " \t\t\tstatus = parse_part_sign_sha256 (se,", "                                         &buffer, &buffer_size, flags);", " \t\t\tif (status != 0)", " \t\t\t{", " \t\t\t\tERROR (\"network plugin: Verifying HMAC-SHA-256 \"", " \t\t\t\t\t\t\"signature failed \"", " \t\t\t\t\t\t\"with status %i.\", status);", " \t\t\t\tbreak;", " \t\t\t}", " \t\t}", " #if HAVE_LIBGCRYPT", " \t\telse if ((se->data.server.security_level == SECURITY_LEVEL_SIGN)", " \t\t\t\t&& (packet_was_encrypted == 0)", " \t\t\t\t&& (packet_was_signed == 0))", " \t\t{", " \t\t\tif (printed_ignore_warning == 0)", " \t\t\t{", " \t\t\t\tINFO (\"network plugin: Unsigned packet or \"", " \t\t\t\t\t\t\"part has been ignored.\");", "  \t\t\t\tprinted_ignore_warning = 1;", "  \t\t\t}", "  \t\t\tbuffer = ((char *) buffer) + pkg_length;", " \t\t\tbuffer_size -= (size_t) pkg_length;", "  \t\t\tcontinue;", "  \t\t}", "  #endif  ", " \t\telse if (pkg_type == TYPE_VALUES)", " \t\t{", " \t\t\tstatus = parse_part_values (&buffer, &buffer_size,", " \t\t\t\t\t&vl.values, &vl.values_len);", " \t\t\tif (status != 0)", " \t\t\t\tbreak;", " \t\t\tnetwork_dispatch_values (&vl, username);", " \t\t\tsfree (vl.values);", " \t\t}", " \t\telse if (pkg_type == TYPE_TIME)", " \t\t{", " \t\t\tuint64_t tmp = 0;", " \t\t\tstatus = parse_part_number (&buffer, &buffer_size,", " \t\t\t\t\t&tmp);", " \t\t\tif (status == 0)", " \t\t\t{", " \t\t\t\tvl.time = TIME_T_TO_CDTIME_T (tmp);", " \t\t\t\tn.time  = TIME_T_TO_CDTIME_T (tmp);", " \t\t\t}", " \t\t}", " \t\telse if (pkg_type == TYPE_TIME_HR)", " \t\t{", " \t\t\tuint64_t tmp = 0;", " \t\t\tstatus = parse_part_number (&buffer, &buffer_size,", " \t\t\t\t\t&tmp);", " \t\t\tif (status == 0)", " \t\t\t{", " \t\t\t\tvl.time = (cdtime_t) tmp;", " \t\t\t\tn.time  = (cdtime_t) tmp;", " \t\t\t}", " \t\t}", " \t\telse if (pkg_type == TYPE_INTERVAL)", " \t\t{", " \t\t\tuint64_t tmp = 0;", " \t\t\tstatus = parse_part_number (&buffer, &buffer_size,", " \t\t\t\t\t&tmp);", " \t\t\tif (status == 0)", " \t\t\t\tvl.interval = TIME_T_TO_CDTIME_T (tmp);", " \t\t}", " \t\telse if (pkg_type == TYPE_INTERVAL_HR)", " \t\t{", " \t\t\tuint64_t tmp = 0;", " \t\t\tstatus = parse_part_number (&buffer, &buffer_size,", " \t\t\t\t\t&tmp);", " \t\t\tif (status == 0)", " \t\t\t\tvl.interval = (cdtime_t) tmp;", " \t\t}", " \t\telse if (pkg_type == TYPE_HOST)", " \t\t{", " \t\t\tstatus = parse_part_string (&buffer, &buffer_size,", " \t\t\t\t\tvl.host, sizeof (vl.host));", " \t\t\tif (status == 0)", " \t\t\t\tsstrncpy (n.host, vl.host, sizeof (n.host));", " \t\t}", " \t\telse if (pkg_type == TYPE_PLUGIN)", " \t\t{", " \t\t\tstatus = parse_part_string (&buffer, &buffer_size,", " \t\t\t\t\tvl.plugin, sizeof (vl.plugin));", " \t\t\tif (status == 0)", " \t\t\t\tsstrncpy (n.plugin, vl.plugin,", " \t\t\t\t\t\tsizeof (n.plugin));", " \t\t}", " \t\telse if (pkg_type == TYPE_PLUGIN_INSTANCE)", " \t\t{", " \t\t\tstatus = parse_part_string (&buffer, &buffer_size,", " \t\t\t\t\tvl.plugin_instance,", " \t\t\t\t\tsizeof (vl.plugin_instance));", " \t\t\tif (status == 0)", " \t\t\t\tsstrncpy (n.plugin_instance,", " \t\t\t\t\t\tvl.plugin_instance,", " \t\t\t\t\t\tsizeof (n.plugin_instance));", " \t\t}", " \t\telse if (pkg_type == TYPE_TYPE)", " \t\t{", " \t\t\tstatus = parse_part_string (&buffer, &buffer_size,", " \t\t\t\t\tvl.type, sizeof (vl.type));", " \t\t\tif (status == 0)", " \t\t\t\tsstrncpy (n.type, vl.type, sizeof (n.type));", " \t\t}", " \t\telse if (pkg_type == TYPE_TYPE_INSTANCE)", " \t\t{", " \t\t\tstatus = parse_part_string (&buffer, &buffer_size,", " \t\t\t\t\tvl.type_instance,", " \t\t\t\t\tsizeof (vl.type_instance));", " \t\t\tif (status == 0)", " \t\t\t\tsstrncpy (n.type_instance, vl.type_instance,", " \t\t\t\t\t\tsizeof (n.type_instance));", " \t\t}", " \t\telse if (pkg_type == TYPE_MESSAGE)", " \t\t{", " \t\t\tstatus = parse_part_string (&buffer, &buffer_size,", " \t\t\t\t\tn.message, sizeof (n.message));", " \t\t\tif (status != 0)", " \t\t\t{", " \t\t\t}", " \t\t\telse if ((n.severity != NOTIF_FAILURE)", " \t\t\t\t\t&& (n.severity != NOTIF_WARNING)", " \t\t\t\t\t&& (n.severity != NOTIF_OKAY))", " \t\t\t{", " \t\t\t\tINFO (\"network plugin: \"", " \t\t\t\t\t\t\"Ignoring notification with \"", " \t\t\t\t\t\t\"unknown severity %i.\",", " \t\t\t\t\t\tn.severity);", " \t\t\t}", " \t\t\telse if (n.time <= 0)", " \t\t\t{", " \t\t\t\tINFO (\"network plugin: \"", " \t\t\t\t\t\t\"Ignoring notification with \"", " \t\t\t\t\t\t\"time == 0.\");", " \t\t\t}", " \t\t\telse if (strlen (n.message) <= 0)", " \t\t\t{", " \t\t\t\tINFO (\"network plugin: \"", " \t\t\t\t\t\t\"Ignoring notification with \"", " \t\t\t\t\t\t\"an empty message.\");", " \t\t\t}", " \t\t\telse", " \t\t\t{", " \t\t\t\tnetwork_dispatch_notification (&n);", " \t\t\t}", " \t\t}", " \t\telse if (pkg_type == TYPE_SEVERITY)", " \t\t{", " \t\t\tuint64_t tmp = 0;", " \t\t\tstatus = parse_part_number (&buffer, &buffer_size,", " \t\t\t\t\t&tmp);", " \t\t\tif (status == 0)", " \t\t\t\tn.severity = (int) tmp;", " \t\t}", " \t\telse", " \t\t{", "  \t\t\tDEBUG (\"network plugin: parse_packet: Unknown part\"", "  \t\t\t\t\t\" type: 0x%04hx\", pkg_type);", "  \t\t\tbuffer = ((char *) buffer) + pkg_length;", " \t\t\tbuffer_size -= (size_t) pkg_length;", "  \t\t}", "  \t}  ", " \tif (status == 0 && buffer_size > 0)", " \t\tWARNING (\"network plugin: parse_packet: Received truncated \"", " \t\t\t\t\"packet, try increasing `MaxPacketSize'\");", " \treturn (status);", " }  "], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void parse_content_range(URLContext *h, const char *p)", " {", "     HTTPContext *s = h->priv_data;", "     const char *slash;", "      if (!strncmp(p, \"bytes \", 6)) {", "          p     += 6;", "        s->off = strtoll(p, NULL, 10);", "         s->off = strtoull(p, NULL, 10);", "          if ((slash = strchr(p, '/')) && strlen(slash) > 0)", "            s->filesize = strtoll(slash + 1, NULL, 10);", "             s->filesize = strtoull(slash + 1, NULL, 10);", "      }", "      if (s->seekable == -1 && (!s->is_akamai || s->filesize != 2147483647))", "          h->is_streamed = 0;  ", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0]}
{"tokens": [" int yr_re_match(", "     RE* re,", "     const char* target)", " {", "   return yr_re_exec(", "        re->code,", "        (uint8_t*) target,", "        strlen(target),", "       0,", "        re->flags | RE_FLAGS_SCAN,", "        NULL,", "        NULL);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": [" safe_fprintf(FILE *f, const char *fmt, ...)", " {", " \tchar fmtbuff_stack[256];  ", " \tchar outbuff[256];  ", " \tchar *fmtbuff_heap;  ", " \tchar *fmtbuff;   ", " \tint fmtbuff_length;", " \tint length, n;", " \tva_list ap;", " \tconst char *p;", " \tunsigned i;", " \twchar_t wc;", " \tchar try_wc;", " \tfmtbuff_heap = NULL;", " \tfmtbuff_length = sizeof(fmtbuff_stack);", " \tfmtbuff = fmtbuff_stack;", " \tva_start(ap, fmt);", " \tlength = vsnprintf(fmtbuff, fmtbuff_length, fmt, ap);", " \tva_end(ap);", " \twhile (length < 0 || length >= fmtbuff_length) {", " \t\tif (length >= fmtbuff_length)", " \t\t\tfmtbuff_length = length+1;", " \t\telse if (fmtbuff_length < 8192)", " \t\t\tfmtbuff_length *= 2;", " \t\telse if (fmtbuff_length < 1000000)", " \t\t\tfmtbuff_length += fmtbuff_length / 4;", " \t\telse {", " \t\t\tlength = fmtbuff_length;", " \t\t\tfmtbuff_heap[length-1] = '\\0';", " \t\t\tbreak;", " \t\t}", " \t\tfree(fmtbuff_heap);", " \t\tfmtbuff_heap = malloc(fmtbuff_length);", " \t\tif (fmtbuff_heap != NULL) {", " \t\t\tfmtbuff = fmtbuff_heap;", " \t\t\tva_start(ap, fmt);", " \t\t\tlength = vsnprintf(fmtbuff, fmtbuff_length, fmt, ap);", " \t\t\tva_end(ap);", " \t\t} else {", " \t\t\tlength = sizeof(fmtbuff_stack) - 1;", " \t\t\tbreak;", " \t\t}", " \t}", " \tif (mbtowc(NULL, NULL, 1) == -1) {  ", " \t\tfree(fmtbuff_heap);", " \t\treturn;", " \t}", " \tp = fmtbuff;", " \ti = 0;", " \ttry_wc = 1;", " \twhile (*p != '\\0') {", " \t\tif (try_wc && (n = mbtowc(&wc, p, length)) != -1) {", " \t\t\tlength -= n;", " \t\t\tif (iswprint(wc) && wc != L'\\\\') {", " \t\t\t\twhile (n-- > 0)", " \t\t\t\t\toutbuff[i++] = *p++;", " \t\t\t} else {", " \t\t\t\twhile (n-- > 0)", " \t\t\t\t\ti += (unsigned)bsdtar_expand_char(", " \t\t\t\t\t    outbuff, i, *p++);", " \t\t\t}", " \t\t} else {", " \t\t\ti += (unsigned)bsdtar_expand_char(outbuff, i, *p++);", " \t\t\ttry_wc = 0;", "  \t\t}", "\t\tif (i > (sizeof(outbuff) - 20)) {", " \t\tif (i > (sizeof(outbuff) - 128)) {", "  \t\t\toutbuff[i] = '\\0';", "  \t\t\tfprintf(f, \"%s\", outbuff);", "  \t\t\ti = 0;", " \t\t}", " \t}", " \toutbuff[i] = '\\0';", " \tfprintf(f, \"%s\", outbuff);", " \tfree(fmtbuff_heap);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" QTN2QT(QTNode *in)", " {", " \tTSQuery\t\tout;", " \tint\t\t\tlen;", " \tint\t\t\tsumlen = 0,", " \t\t\t\tnnode = 0;", "  \tQTN2QTState state;", "  \tcntsize(in, &sumlen, &nnode);", " \tif (TSQUERY_TOO_BIG(nnode, sumlen))", " \t\tereport(ERROR,", " \t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),", " \t\t\t\t errmsg(\"tsquery is too large\")));", "  \tlen = COMPUTESIZE(nnode, sumlen);", "  \tout = (TSQuery) palloc0(len);", " \tSET_VARSIZE(out, len);", " \tout->size = nnode;", " \tstate.curitem = GETQUERY(out);", " \tstate.operand = state.curoperand = GETOPERAND(out);", " \tfillQT(&state, in);", " \treturn out;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  PHP_FUNCTION(radius_get_vendor_attr)", "  {", "\tint res;", "\tconst void *data;", " \tconst void *data, *raw;", "  \tint len;", "  \tu_int32_t vendor;", " \tunsigned char type;", " \tsize_t data_len;", "\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &data, &len) == FAILURE) {", " \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &raw, &len) == FAILURE) {", "  \t\treturn;", "  \t}", "\tres = rad_get_vendor_attr(&vendor, &data, (size_t *) &len);", "\tif (res == -1) {", " \tif (rad_get_vendor_attr(&vendor, &type, &data, &data_len, raw, len) == -1) {", "  \t\tRETURN_FALSE;", "  \t} else {", "  \t\tarray_init(return_value);", "\t\tadd_assoc_long(return_value, \"attr\", res);", " \t\tadd_assoc_long(return_value, \"attr\", type);", "  \t\tadd_assoc_long(return_value, \"vendor\", vendor);", "\t\tadd_assoc_stringl(return_value, \"data\", (char *) data, len, 1);", " \t\tadd_assoc_stringl(return_value, \"data\", (char *) data, data_len, 1);", "  \t\treturn;", "  \t}", "  }"], "ner_tags": [0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0]}
{"tokens": [" static int flv_write_packet(AVFormatContext *s, AVPacket *pkt)", " {", "     AVIOContext *pb      = s->pb;", "     AVCodecParameters *par = s->streams[pkt->stream_index]->codecpar;", "     FLVContext *flv      = s->priv_data;", "     FLVStreamContext *sc = s->streams[pkt->stream_index]->priv_data;", "     unsigned ts;", "     int size = pkt->size;", "     uint8_t *data = NULL;", "      int flags = -1, flags_size, ret;", "      int64_t cur_offset = avio_tell(pb);", "     if (par->codec_type == AVMEDIA_TYPE_AUDIO && !pkt->size) {", "         av_log(s, AV_LOG_WARNING, \"Empty audio Packet\\n\");", "         return AVERROR(EINVAL);", "     }", "      if (par->codec_id == AV_CODEC_ID_VP6F || par->codec_id == AV_CODEC_ID_VP6A ||", "          par->codec_id == AV_CODEC_ID_VP6  || par->codec_id == AV_CODEC_ID_AAC)", "          flags_size = 2;", "     else if (par->codec_id == AV_CODEC_ID_H264 || par->codec_id == AV_CODEC_ID_MPEG4)", "         flags_size = 5;", "     else", "         flags_size = 1;", "     if (par->codec_id == AV_CODEC_ID_AAC || par->codec_id == AV_CODEC_ID_H264", "             || par->codec_id == AV_CODEC_ID_MPEG4) {", "         int side_size = 0;", "         uint8_t *side = av_packet_get_side_data(pkt, AV_PKT_DATA_NEW_EXTRADATA, &side_size);", "         if (side && side_size > 0 && (side_size != par->extradata_size || memcmp(side, par->extradata, side_size))) {", "             av_free(par->extradata);", "             par->extradata = av_mallocz(side_size + AV_INPUT_BUFFER_PADDING_SIZE);", "             if (!par->extradata) {", "                 par->extradata_size = 0;", "                 return AVERROR(ENOMEM);", "             }", "             memcpy(par->extradata, side, side_size);", "             par->extradata_size = side_size;", "             flv_write_codec_header(s, par, pkt->dts);", "         }", "     }", "     if (flv->delay == AV_NOPTS_VALUE)", "         flv->delay = -pkt->dts;", "     if (pkt->dts < -flv->delay) {", "         av_log(s, AV_LOG_WARNING,", "                \"Packets are not in the proper order with respect to DTS\\n\");", "         return AVERROR(EINVAL);", "     }", "     ts = pkt->dts;", "     if (s->event_flags & AVSTREAM_EVENT_FLAG_METADATA_UPDATED) {", "         write_metadata(s, ts);", "         s->event_flags &= ~AVSTREAM_EVENT_FLAG_METADATA_UPDATED;", "     }", "     avio_write_marker(pb, av_rescale(ts, AV_TIME_BASE, 1000),", "                       pkt->flags & AV_PKT_FLAG_KEY && (flv->video_par ? par->codec_type == AVMEDIA_TYPE_VIDEO : 1) ? AVIO_DATA_MARKER_SYNC_POINT : AVIO_DATA_MARKER_BOUNDARY_POINT);", "     switch (par->codec_type) {", "     case AVMEDIA_TYPE_VIDEO:", "         avio_w8(pb, FLV_TAG_TYPE_VIDEO);", "         flags = ff_codec_get_tag(flv_video_codec_ids, par->codec_id);", "         flags |= pkt->flags & AV_PKT_FLAG_KEY ? FLV_FRAME_KEY : FLV_FRAME_INTER;", "         break;", "     case AVMEDIA_TYPE_AUDIO:", "         flags = get_audio_flags(s, par);", "         av_assert0(size);", "         avio_w8(pb, FLV_TAG_TYPE_AUDIO);", "         break;", "     case AVMEDIA_TYPE_SUBTITLE:", "     case AVMEDIA_TYPE_DATA:", "         avio_w8(pb, FLV_TAG_TYPE_META);", "         break;", "     default:", "         return AVERROR(EINVAL);", "     }", "     if (par->codec_id == AV_CODEC_ID_H264 || par->codec_id == AV_CODEC_ID_MPEG4) {", "         if (par->extradata_size > 0 && *(uint8_t*)par->extradata != 1)", "             if ((ret = ff_avc_parse_nal_units_buf(pkt->data, &data, &size)) < 0)", "                 return ret;", "     } else if (par->codec_id == AV_CODEC_ID_AAC && pkt->size > 2 &&", "                (AV_RB16(pkt->data) & 0xfff0) == 0xfff0) {", "         if (!s->streams[pkt->stream_index]->nb_frames) {", "         av_log(s, AV_LOG_ERROR, \"Malformed AAC bitstream detected: \"", "                \"use the audio bitstream filter 'aac_adtstoasc' to fix it \"", "                \"('-bsf:a aac_adtstoasc' option with ffmpeg)\\n\");", "         return AVERROR_INVALIDDATA;", "         }", "         av_log(s, AV_LOG_WARNING, \"aac bitstream error\\n\");", "     }", "     if (par->codec_id == AV_CODEC_ID_SPEEX && ts - sc->last_ts > 160)", "         av_log(s, AV_LOG_WARNING, \"Warning: Speex stream has more than \"", "                                   \"8 frames per packet. Adobe Flash \"", "                                   \"Player cannot handle this!\\n\");", "     if (sc->last_ts < ts)", "         sc->last_ts = ts;", "     if (size + flags_size >= 1<<24) {", "         av_log(s, AV_LOG_ERROR, \"Too large packet with size %u >= %u\\n\",", "                size + flags_size, 1<<24);", "         return AVERROR(EINVAL);", "     }", "     avio_wb24(pb, size + flags_size);", "     put_timestamp(pb, ts);", "     avio_wb24(pb, flv->reserved);", "     if (par->codec_type == AVMEDIA_TYPE_DATA ||", "         par->codec_type == AVMEDIA_TYPE_SUBTITLE ) {", "         int data_size;", "         int64_t metadata_size_pos = avio_tell(pb);", "         if (par->codec_id == AV_CODEC_ID_TEXT) {", "             avio_w8(pb, AMF_DATA_TYPE_STRING);", "             put_amf_string(pb, \"onTextData\");", "             avio_w8(pb, AMF_DATA_TYPE_MIXEDARRAY);", "             avio_wb32(pb, 2);", "             put_amf_string(pb, \"type\");", "             avio_w8(pb, AMF_DATA_TYPE_STRING);", "             put_amf_string(pb, \"Text\");", "             put_amf_string(pb, \"text\");", "             avio_w8(pb, AMF_DATA_TYPE_STRING);", "             put_amf_string(pb, pkt->data);", "             put_amf_string(pb, \"\");", "             avio_w8(pb, AMF_END_OF_OBJECT);", "         } else {", "             avio_write(pb, data ? data : pkt->data, size);", "         }", "         data_size = avio_tell(pb) - metadata_size_pos;", "         avio_seek(pb, metadata_size_pos - 10, SEEK_SET);", "         avio_wb24(pb, data_size);", "         avio_seek(pb, data_size + 10 - 3, SEEK_CUR);", "         avio_wb32(pb, data_size + 11);", "     } else {", "         av_assert1(flags>=0);", "         avio_w8(pb,flags);", "         if (par->codec_id == AV_CODEC_ID_VP6)", "             avio_w8(pb,0);", "         if (par->codec_id == AV_CODEC_ID_VP6F || par->codec_id == AV_CODEC_ID_VP6A) {", "             if (par->extradata_size)", "                 avio_w8(pb, par->extradata[0]);", "             else", "                 avio_w8(pb, ((FFALIGN(par->width,  16) - par->width) << 4) |", "                              (FFALIGN(par->height, 16) - par->height));", "         } else if (par->codec_id == AV_CODEC_ID_AAC)", "             avio_w8(pb, 1);  ", "         else if (par->codec_id == AV_CODEC_ID_H264 || par->codec_id == AV_CODEC_ID_MPEG4) {", "             avio_w8(pb, 1);  ", "             avio_wb24(pb, pkt->pts - pkt->dts);", "         }", "         avio_write(pb, data ? data : pkt->data, size);", "         avio_wb32(pb, size + flags_size + 11);  ", "         flv->duration = FFMAX(flv->duration,", "                               pkt->pts + flv->delay + pkt->duration);", "     }", "     if (flv->flags & FLV_ADD_KEYFRAME_INDEX) {", "         switch (par->codec_type) {", "             case AVMEDIA_TYPE_VIDEO:", "                 flv->videosize += (avio_tell(pb) - cur_offset);", "                 flv->lasttimestamp = flv->acurframeindex / flv->framerate;", "                 if (pkt->flags & AV_PKT_FLAG_KEY) {", "                     double ts = flv->acurframeindex / flv->framerate;", "                     int64_t pos = cur_offset;", "                     flv->lastkeyframetimestamp = flv->acurframeindex / flv->framerate;", "                     flv->lastkeyframelocation = pos;", "                     flv_append_keyframe_info(s, flv, ts, pos);", "                 }", "                 flv->acurframeindex++;", "                 break;", "             case AVMEDIA_TYPE_AUDIO:", "                 flv->audiosize += (avio_tell(pb) - cur_offset);", "                 break;", "             default:", "                 av_log(s, AV_LOG_WARNING, \"par->codec_type is type = [%d]\\n\", par->codec_type);", "                 break;", "         }", "     }", "     av_free(data);", "     return pb->error;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" parse_device(dev_t *pdev, struct archive *a, char *val)", " {", " #define MAX_PACK_ARGS 3", " \tunsigned long numbers[MAX_PACK_ARGS];", " \tchar *p, *dev;", " \tint argc;", " \tpack_t *pack;", " \tdev_t result;", " \tconst char *error = NULL;", " \tmemset(pdev, 0, sizeof(*pdev));", " \tif ((dev = strchr(val, ',')) != NULL) {", " \t\t*dev++ = '\\0';", " \t\tif ((pack = pack_find(val)) == NULL) {", " \t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,", " \t\t\t    \"Unknown format `%s'\", val);", " \t\t\treturn ARCHIVE_WARN;", " \t\t}", " \t\targc = 0;", " \t\twhile ((p = la_strsep(&dev, \",\")) != NULL) {", " \t\t\tif (*p == '\\0') {", " \t\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,", "  \t\t\t\t    \"Missing number\");", "  \t\t\t\treturn ARCHIVE_WARN;", "  \t\t\t}", "\t\t\tnumbers[argc++] = (unsigned long)mtree_atol(&p);", "\t\t\tif (argc > MAX_PACK_ARGS) {", " \t\t\tif (argc >= MAX_PACK_ARGS) {", "  \t\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,", "  \t\t\t\t    \"Too many arguments\");", "  \t\t\t\treturn ARCHIVE_WARN;", "  \t\t\t}", " \t\t\tnumbers[argc++] = (unsigned long)mtree_atol(&p);", "  \t\t}", "  \t\tif (argc < 2) {", "  \t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,", " \t\t\t    \"Not enough arguments\");", " \t\t\treturn ARCHIVE_WARN;", " \t\t}", " \t\tresult = (*pack)(argc, numbers, &error);", " \t\tif (error != NULL) {", " \t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,", " \t\t\t    \"%s\", error);", " \t\t\treturn ARCHIVE_WARN;", " \t\t}", " \t} else {", " \t\tresult = (dev_t)mtree_atol(&val);", " \t}", " \t*pdev = result;", " \treturn ARCHIVE_OK;", " #undef MAX_PACK_ARGS", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int jp2_box_put(jp2_box_t *box, jas_stream_t *out)", " {", " \tjas_stream_t *tmpstream;", " \tbool extlen;", " \tbool dataflag;", " \ttmpstream = 0;", " \tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));", " \tif (dataflag) {", " \t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {", " \t\t\tgoto error;", " \t\t}", " \t\tif (box->ops->putdata) {", " \t\t\tif ((*box->ops->putdata)(box, tmpstream)) {", " \t\t\t\tgoto error;", " \t\t\t}", " \t\t}", " \t\tbox->len = jas_stream_tell(tmpstream) + JP2_BOX_HDRLEN(false);", " \t\tjas_stream_rewind(tmpstream);", " \t}", " \textlen = (box->len >= (((uint_fast64_t)1) << 32)) != 0;", " \tif (jp2_putuint32(out, extlen ? 1 : box->len)) {", " \t\tgoto error;", " \t}", " \tif (jp2_putuint32(out, box->type)) {", " \t\tgoto error;", " \t}", " \tif (extlen) {", " \t\tif (jp2_putuint64(out, box->len)) {", " \t\t\tgoto error;", " \t\t}", "  \t}", "  \tif (dataflag) {", "\t\tif (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) {", " \t\tif (jas_stream_copy(out, tmpstream, box->len -", " \t\t  JP2_BOX_HDRLEN(false))) {", " \t\t\tjas_eprintf(\"cannot copy box data\\n\");", "  \t\t\tgoto error;", "  \t\t}", "  \t\tjas_stream_close(tmpstream);", " \t}", " \treturn 0;", " error:", " \tif (tmpstream) {", " \t\tjas_stream_close(tmpstream);", " \t}", " \treturn -1;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int decompress_i(AVCodecContext *avctx, uint32_t *dst, int linesize)", " {", "     SCPRContext *s = avctx->priv_data;", "     GetByteContext *gb = &s->gb;", "     int cx = 0, cx1 = 0, k = 0, clr = 0;", "     int run, r, g, b, off, y = 0, x = 0, z, ret;", "     unsigned backstep = linesize - avctx->width;", "     const int cxshift = s->cxshift;", "     unsigned lx, ly, ptype;", "     reinit_tables(s);", "     bytestream2_skip(gb, 2);", "     init_rangecoder(&s->rc, gb);", "     while (k < avctx->width + 1) {", "         ret = decode_unit(s, &s->pixel_model[0][cx + cx1], 400, &r);", "         if (ret < 0)", "             return ret;", "         cx1 = (cx << 6) & 0xFC0;", "         cx = r >> cxshift;", "         ret = decode_unit(s, &s->pixel_model[1][cx + cx1], 400, &g);", "         if (ret < 0)", "             return ret;", "         cx1 = (cx << 6) & 0xFC0;", "         cx = g >> cxshift;", "         ret = decode_unit(s, &s->pixel_model[2][cx + cx1], 400, &b);", "         if (ret < 0)", "             return ret;", "         cx1 = (cx << 6) & 0xFC0;", "         cx = b >> cxshift;", "         ret = decode_value(s, s->run_model[0], 256, 400, &run);", "         if (ret < 0)", "             return ret;", "          clr = (b << 16) + (g << 8) + r;", "          k += run;", "          while (run-- > 0) {", "             if (y >= avctx->height)", "                 return AVERROR_INVALIDDATA;", "              dst[y * linesize + x] = clr;", "              lx = x;", "              ly = y;", "             x++;", "             if (x >= avctx->width) {", "                 x = 0;", "                 y++;", "             }", "         }", "     }", "     off = -linesize - 1;", "     ptype = 0;", "     while (x < avctx->width && y < avctx->height) {", "         ret = decode_value(s, s->op_model[ptype], 6, 1000, &ptype);", "         if (ret < 0)", "             return ret;", "         if (ptype == 0) {", "             ret = decode_unit(s, &s->pixel_model[0][cx + cx1], 400, &r);", "             if (ret < 0)", "                 return ret;", "             cx1 = (cx << 6) & 0xFC0;", "             cx = r >> cxshift;", "             ret = decode_unit(s, &s->pixel_model[1][cx + cx1], 400, &g);", "             if (ret < 0)", "                 return ret;", "             cx1 = (cx << 6) & 0xFC0;", "             cx = g >> cxshift;", "             ret = decode_unit(s, &s->pixel_model[2][cx + cx1], 400, &b);", "             if (ret < 0)", "                 return ret;", "             clr = (b << 16) + (g << 8) + r;", "         }", "         if (ptype > 5)", "             return AVERROR_INVALIDDATA;", "         ret = decode_value(s, s->run_model[ptype], 256, 400, &run);", "         if (ret < 0)", "             return ret;", "         switch (ptype) {", "         case 0:", "             while (run-- > 0) {", "                 if (y >= avctx->height)", "                     return AVERROR_INVALIDDATA;", "                 dst[y * linesize + x] = clr;", "                 lx = x;", "                 ly = y;", "                 x++;", "                 if (x >= avctx->width) {", "                     x = 0;", "                     y++;", "                 }", "             }", "             break;", "         case 1:", "             while (run-- > 0) {", "                 if (y >= avctx->height)", "                     return AVERROR_INVALIDDATA;", "                 dst[y * linesize + x] = dst[ly * linesize + lx];", "                 lx = x;", "                 ly = y;", "                 x++;", "                 if (x >= avctx->width) {", "                     x = 0;", "                     y++;", "                 }", "             }", "             clr = dst[ly * linesize + lx];", "             break;", "         case 2:", "             while (run-- > 0) {", "                 if (y < 1 || y >= avctx->height)", "                     return AVERROR_INVALIDDATA;", "                 clr = dst[y * linesize + x + off + 1];", "                 dst[y * linesize + x] = clr;", "                 lx = x;", "                 ly = y;", "                 x++;", "                 if (x >= avctx->width) {", "                     x = 0;", "                     y++;", "                 }", "             }", "             break;", "         case 4:", "             while (run-- > 0) {", "                 uint8_t *odst = (uint8_t *)dst;", "                 if (y < 1 || y >= avctx->height ||", "                     (y == 1 && x == 0))", "                     return AVERROR_INVALIDDATA;", "                 if (x == 0) {", "                     z = backstep;", "                 } else {", "                     z = 0;", "                 }", "                 r = odst[(ly * linesize + lx) * 4] +", "                     odst[((y * linesize + x) + off - z) * 4 + 4] -", "                     odst[((y * linesize + x) + off - z) * 4];", "                 g = odst[(ly * linesize + lx) * 4 + 1] +", "                     odst[((y * linesize + x) + off - z) * 4 + 5] -", "                     odst[((y * linesize + x) + off - z) * 4 + 1];", "                 b = odst[(ly * linesize + lx) * 4 + 2] +", "                     odst[((y * linesize + x) + off - z) * 4 + 6] -", "                     odst[((y * linesize + x) + off - z) * 4 + 2];", "                 clr = ((b & 0xFF) << 16) + ((g & 0xFF) << 8) + (r & 0xFF);", "                 dst[y * linesize + x] = clr;", "                 lx = x;", "                 ly = y;", "                 x++;", "                 if (x >= avctx->width) {", "                     x = 0;", "                     y++;", "                 }", "             }", "             break;", "         case 5:", "             while (run-- > 0) {", "                 if (y < 1 || y >= avctx->height ||", "                     (y == 1 && x == 0))", "                     return AVERROR_INVALIDDATA;", "                 if (x == 0) {", "                     z = backstep;", "                 } else {", "                     z = 0;", "                 }", "                 clr = dst[y * linesize + x + off - z];", "                 dst[y * linesize + x] = clr;", "                 lx = x;", "                 ly = y;", "                 x++;", "                 if (x >= avctx->width) {", "                     x = 0;", "                     y++;", "                 }", "             }", "             break;", "         }", "         if (avctx->bits_per_coded_sample == 16) {", "             cx1 = (clr & 0x3F00) >> 2;", "             cx = (clr & 0xFFFFFF) >> 16;", "         } else {", "             cx1 = (clr & 0xFC00) >> 4;", "             cx = (clr & 0xFFFFFF) >> 18;", "         }", "     }", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int kempf_decode_tile(G2MContext *c, int tile_x, int tile_y,", "                              const uint8_t *src, int src_size)", " {", "     int width, height;", "     int hdr, zsize, npal, tidx = -1, ret;", "     int i, j;", "     const uint8_t *src_end = src + src_size;", "     uint8_t pal[768], transp[3];", "     uLongf dlen = (c->tile_width + 1) * c->tile_height;", "     int sub_type;", "     int nblocks, cblocks, bstride;", "     int bits, bitbuf, coded;", "     uint8_t *dst = c->framebuf + tile_x * c->tile_width * 3 +", "                    tile_y * c->tile_height * c->framebuf_stride;", "     if (src_size < 2)", "         return AVERROR_INVALIDDATA;", "     width  = FFMIN(c->width  - tile_x * c->tile_width,  c->tile_width);", "     height = FFMIN(c->height - tile_y * c->tile_height, c->tile_height);", "     hdr = *src++;", "     sub_type = hdr >> 5;", "     if (sub_type == 0) {", "         int j;", "         memcpy(transp, src, 3);", "         src += 3;", "         for (j = 0; j < height; j++, dst += c->framebuf_stride)", "             for (i = 0; i < width; i++)", "                 memcpy(dst + i * 3, transp, 3);", "         return 0;", "     } else if (sub_type == 1) {", "         return jpg_decode_data(&c->jc, width, height, src, src_end - src,", "                                dst, c->framebuf_stride, NULL, 0, 0, 0);", "     }", "     if (sub_type != 2) {", "         memcpy(transp, src, 3);", "         src += 3;", "     }", "     npal = *src++ + 1;", "     memcpy(pal, src, npal * 3); src += npal * 3;", "     if (sub_type != 2) {", "         for (i = 0; i < npal; i++) {", "             if (!memcmp(pal + i * 3, transp, 3)) {", "                tidx = i;", "                break;", "             }", "         }", "     }", "     if (src_end - src < 2)", "          return 0;", "      zsize = (src[0] << 8) | src[1]; src += 2;", "    if (src_end - src < zsize)", "     if (src_end - src < zsize + (sub_type != 2))", "          return AVERROR_INVALIDDATA;", "      ret = uncompress(c->kempf_buf, &dlen, src, zsize);", "     if (ret)", "         return AVERROR_INVALIDDATA;", "     src += zsize;", "     if (sub_type == 2) {", "         kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride,", "                           NULL, 0, width, height, pal, npal, tidx);", "         return 0;", "     }", "     nblocks = *src++ + 1;", "     cblocks = 0;", "     bstride = FFALIGN(width, 16) >> 4;", "     bits = 0;", "      for (i = 0; i < (FFALIGN(height, 16) >> 4); i++) {", "          for (j = 0; j < (FFALIGN(width, 16) >> 4); j++) {", "              if (!bits) {", "                 if (src >= src_end)", "                     return AVERROR_INVALIDDATA;", "                  bitbuf = *src++;", "                  bits   = 8;", "              }", "             coded = bitbuf & 1;", "             bits--;", "             bitbuf >>= 1;", "             cblocks += coded;", "             if (cblocks > nblocks)", "                 return AVERROR_INVALIDDATA;", "             c->kempf_flags[j + i * bstride] = coded;", "         }", "     }", "     memset(c->jpeg_tile, 0, c->tile_stride * height);", "     jpg_decode_data(&c->jc, width, height, src, src_end - src,", "                     c->jpeg_tile, c->tile_stride,", "                     c->kempf_flags, bstride, nblocks, 0);", "     kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride,", "                       c->jpeg_tile, c->tile_stride,", "                       width, height, pal, npal, tidx);", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int g2m_init_buffers(G2MContext *c)", " {", "     int aligned_height;", "     if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) {", "         c->framebuf_stride = FFALIGN(c->width * 3, 16);", "         aligned_height     = FFALIGN(c->height,    16);", "         av_free(c->framebuf);", "         c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);", "         if (!c->framebuf)", "             return AVERROR(ENOMEM);", "     }", "      if (!c->synth_tile || !c->jpeg_tile ||", "          c->old_tile_w < c->tile_width ||", "          c->old_tile_h < c->tile_height) {", "        c->tile_stride = FFALIGN(c->tile_width * 3, 16);", "         c->tile_stride = FFALIGN(c->tile_width, 16) * 3;", "          aligned_height = FFALIGN(c->tile_height,    16);", "          av_free(c->synth_tile);", "          av_free(c->jpeg_tile);", "         av_free(c->kempf_buf);", "         av_free(c->kempf_flags);", "         c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);", "         c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);", "         c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height", "                                     + FF_INPUT_BUFFER_PADDING_SIZE);", "         c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);", "         if (!c->synth_tile || !c->jpeg_tile ||", "             !c->kempf_buf || !c->kempf_flags)", "             return AVERROR(ENOMEM);", "     }", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" m_authenticate(struct Client *client_p, struct Client *source_p,", " \tint parc, const char *parv[])", " {", " \tstruct Client *agent_p = NULL;", " \tstruct Client *saslserv_p = NULL;", " \tif(!IsCapable(source_p, CLICAP_SASL))", " \t\treturn 0;", " \tif (strlen(client_p->id) == 3)", " \t{", " \t\texit_client(client_p, client_p, client_p, \"Mixing client and server protocol\");", "  \t\treturn 0;", "  \t}", " \tif (*parv[1] == ':' || strchr(parv[1], ' '))", " \t{", " \t\texit_client(client_p, client_p, client_p, \"Malformed AUTHENTICATE\");", " \t\treturn 0;", " \t}", "  \tsaslserv_p = find_named_client(ConfigFileEntry.sasl_service);", "  \tif (saslserv_p == NULL || !IsService(saslserv_p))", "  \t{", " \t\tsendto_one(source_p, form_str(ERR_SASLABORTED), me.name, EmptyString(source_p->name) ? \"*\" : source_p->name);", " \t\treturn 0;", " \t}", " \tif(source_p->localClient->sasl_complete)", " \t{", " \t\t*source_p->localClient->sasl_agent = '\\0';", " \t\tsource_p->localClient->sasl_complete = 0;", " \t}", " \tif(strlen(parv[1]) > 400)", " \t{", " \t\tsendto_one(source_p, form_str(ERR_SASLTOOLONG), me.name, EmptyString(source_p->name) ? \"*\" : source_p->name);", " \t\treturn 0;", " \t}", " \tif(!*source_p->id)", " \t{", " \t\tstrcpy(source_p->id, generate_uid());", " \t\tadd_to_id_hash(source_p->id, source_p);", " \t}", " \tif(*source_p->localClient->sasl_agent)", " \t\tagent_p = find_id(source_p->localClient->sasl_agent);", " \tif(agent_p == NULL)", " \t{", " \t\tsendto_one(saslserv_p, \":%s ENCAP %s SASL %s %s H %s %s\",", " \t\t\t\t\tme.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,", " \t\t\t\t\tsource_p->host, source_p->sockhost);", " \t\tif (!strcmp(parv[1], \"EXTERNAL\") && source_p->certfp != NULL)", " \t\t\tsendto_one(saslserv_p, \":%s ENCAP %s SASL %s %s S %s %s\",", " \t\t\t\t\t\tme.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,", " \t\t\t\t\t\tparv[1], source_p->certfp);", " \t\telse", " \t\t\tsendto_one(saslserv_p, \":%s ENCAP %s SASL %s %s S %s\",", " \t\t\t\t\t\tme.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,", " \t\t\t\t\t\tparv[1]);", " \t\trb_strlcpy(source_p->localClient->sasl_agent, saslserv_p->id, IDLEN);", " \t}", " \telse", " \t\tsendto_one(agent_p, \":%s ENCAP %s SASL %s %s C %s\",", " \t\t\t\tme.id, agent_p->servptr->name, source_p->id, agent_p->id,", " \t\t\t\tparv[1]);", " \tsource_p->localClient->sasl_out++;", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" GF_Err gf_bin128_parse(const char *string, bin128 value)", " {", " \tu32 len;", " \tu32\ti=0;", " \tif (!strnicmp(string, \"0x\", 2)) string += 2;", " \tlen = (u32) strlen(string);", " \tif (len >= 32) {", " \t\tu32 j;", " \t\tfor (j=0; j<len; j+=2) {", " \t\t\tu32 v;", " \t\t\tchar szV[5];", " \t\t\twhile (string[j] && !isalnum(string[j]))", " \t\t\t\tj++;", " \t\t\tif (!string[j])", " \t\t\t\tbreak;", " \t\t\tsprintf(szV, \"%c%c\", string[j], string[j+1]);", "  \t\t\tsscanf(szV, \"%x\", &v);", "  \t\t\tvalue[i] = v;", "  \t\t\ti++;", " \t\t\tif (i > 15) {", " \t\t\t\ti++;", " \t\t\t\tbreak;", " \t\t\t}", "  \t\t}", "  \t}", "  \tif (i != 16) {", " \t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[CORE] 128bit blob is not 16-bytes long: %s\\n\", string));", " \t\treturn GF_BAD_PARAM;", " \t}", " \treturn GF_OK;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static int jas_iccgetuint32(jas_stream_t *in, jas_iccuint32_t *val)", "  {", "\tulonglong tmp;", " \tjas_ulonglong tmp;", "  \tif (jas_iccgetuint(in, 4, &tmp))", "  \t\treturn -1;", "  \t*val = tmp;", " \treturn 0;", " }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" psf_fwrite (const void *ptr, sf_count_t bytes, sf_count_t items, SF_PRIVATE *psf)", "  {\tsf_count_t total = 0 ;", "  \tssize_t\tcount ;", " \tif (bytes == 0 || items == 0)", " \t\treturn 0 ;", "  \tif (psf->virtual_io)", "  \t\treturn psf->vio.write (ptr, bytes*items, psf->vio_user_data) / bytes ;", " \titems *= bytes ;", " \tif (items <= 0)", " \t\treturn 0 ;", " \twhile (items > 0)", " \t{\t ", " \t\tcount = (items > SENSIBLE_SIZE) ? SENSIBLE_SIZE : items ;", " \t\tcount = write (psf->file.filedes, ((const char*) ptr) + total, count) ;", " \t\tif (count == -1)", " \t\t{\tif (errno == EINTR)", " \t\t\t\tcontinue ;", " \t\t\tpsf_log_syserr (psf, errno) ;", " \t\t\tbreak ;", " \t\t\t} ;", " \t\tif (count == 0)", " \t\t\tbreak ;", " \t\ttotal += count ;", " \t\titems -= count ;", " \t\t} ;", " \tif (psf->is_pipe)", " \t\tpsf->pipeoffset += total ;", " \treturn total / bytes ;", " }  "], "ner_tags": [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" create_watching_parent (void)", " {", "   pid_t child;", "   sigset_t ourset;", "   struct sigaction oldact[3];", "   int status = 0;", "   int retval;", "   retval = pam_open_session (pamh, 0);", "   if (is_pam_failure(retval))", "     {", "       cleanup_pam (retval);", "       errx (EXIT_FAILURE, _(\"cannot open session: %s\"),", " \t     pam_strerror (pamh, retval));", "     }", "   else", "     _pam_session_opened = 1;", "   memset(oldact, 0, sizeof(oldact));", "   child = fork ();", "   if (child == (pid_t) -1)", "     {", "       cleanup_pam (PAM_ABORT);", "       err (EXIT_FAILURE, _(\"cannot create child process\"));", "     }", "   if (child == 0)", "     return;", "   if (chdir (\"/\") != 0)", "     warn (_(\"cannot change directory to %s\"), \"/\");", "   sigfillset (&ourset);", "   if (sigprocmask (SIG_BLOCK, &ourset, NULL))", "     {", "       warn (_(\"cannot block signals\"));", "       caught_signal = true;", "     }", "   if (!caught_signal)", "     {", "       struct sigaction action;", "       action.sa_handler = su_catch_sig;", "       sigemptyset (&action.sa_mask);", "       action.sa_flags = 0;", "       sigemptyset (&ourset);", "     if (!same_session)", "       {", "         if (sigaddset(&ourset, SIGINT) || sigaddset(&ourset, SIGQUIT))", "           {", "             warn (_(\"cannot set signal handler\"));", "             caught_signal = true;", "           }", "       }", "     if (!caught_signal && (sigaddset(&ourset, SIGTERM)", "                     || sigaddset(&ourset, SIGALRM)", "                     || sigaction(SIGTERM, &action, &oldact[0])", "                     || sigprocmask(SIG_UNBLOCK, &ourset, NULL))) {", " \t  warn (_(\"cannot set signal handler\"));", " \t  caught_signal = true;", " \t}", "     if (!caught_signal && !same_session && (sigaction(SIGINT, &action, &oldact[1])", "                                      || sigaction(SIGQUIT, &action, &oldact[2])))", "       {", "         warn (_(\"cannot set signal handler\"));", "         caught_signal = true;", "       }", "     }", "   if (!caught_signal)", "     {", "       pid_t pid;", "       for (;;)", " \t{", " \t  pid = waitpid (child, &status, WUNTRACED);", " \t  if (pid != (pid_t)-1 && WIFSTOPPED (status))", " \t    {", " \t      kill (getpid (), SIGSTOP);", " \t      kill (pid, SIGCONT);", " \t    }", " \t  else", " \t    break;", " \t}", "       if (pid != (pid_t)-1)", "         {", "           if (WIFSIGNALED (status))", "             {", "               fprintf (stderr, \"%s%s\\n\", strsignal (WTERMSIG (status)),", "                        WCOREDUMP (status) ? _(\" (core dumped)\") : \"\");", "               status = WTERMSIG (status) + 128;", "              }", "            else", "              status = WEXITSTATUS (status);", " \t  child = (pid_t) -1;", "          }", "        else if (caught_signal)", "          status = caught_signal + 128;", "       else", "         status = 1;", "     }", "    else", "      status = 1;", "  if (caught_signal)", "   if (caught_signal && child != (pid_t)-1)", "      {", "        fprintf (stderr, _(\"\\nSession terminated, killing shell...\"));", "        kill (child, SIGTERM);", "     }", "   cleanup_pam (PAM_SUCCESS);", "    if (caught_signal)", "      {", "      sleep (2);", "      kill (child, SIGKILL);", "      fprintf (stderr, _(\" ...killed.\\n\"));", "       if (child != (pid_t)-1)", " \t{", " \t  sleep (2);", " \t  kill (child, SIGKILL);", " \t  fprintf (stderr, _(\" ...killed.\\n\"));", " \t}", "       switch (caught_signal) {", "         case SIGTERM:", "           sigaction(SIGTERM, &oldact[0], NULL);", "           break;", "         case SIGINT:", "           sigaction(SIGINT, &oldact[1], NULL);", "           break;", "         case SIGQUIT:", "           sigaction(SIGQUIT, &oldact[2], NULL);", "           break;", "         default:", "           caught_signal = SIGKILL;", "           break;", "       }", "       kill(getpid(), caught_signal);", "     }", "   exit (status);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" sd2_parse_rsrc_fork (SF_PRIVATE *psf)", " {\tSD2_RSRC rsrc ;", " \tint k, marker, error = 0 ;", " \tpsf_use_rsrc (psf, SF_TRUE) ;", " \tmemset (&rsrc, 0, sizeof (rsrc)) ;", " \trsrc.rsrc_len = psf_get_filelen (psf) ;", " \tpsf_log_printf (psf, \"Resource length : %d (0x%04X)\\n\", rsrc.rsrc_len, rsrc.rsrc_len) ;", " \tif (rsrc.rsrc_len > SIGNED_SIZEOF (psf->header))", " \t{\trsrc.rsrc_data = calloc (1, rsrc.rsrc_len) ;", " \t\trsrc.need_to_free_rsrc_data = SF_TRUE ;", " \t\t}", " \telse", " \t{", " \t\trsrc.rsrc_data = psf->header ;", " \t\trsrc.need_to_free_rsrc_data = SF_FALSE ;", " \t\t} ;", " \tpsf_fread (rsrc.rsrc_data, rsrc.rsrc_len, 1, psf) ;", " \tpsf->headindex = psf->headend = rsrc.rsrc_len ;", " \trsrc.data_offset = read_rsrc_int (&rsrc, 0) ;", " \trsrc.map_offset = read_rsrc_int (&rsrc, 4) ;", " \trsrc.data_length = read_rsrc_int (&rsrc, 8) ;", " \trsrc.map_length = read_rsrc_int (&rsrc, 12) ;", " \tif (rsrc.data_offset == 0x51607 && rsrc.map_offset == 0x20000)", " \t{\tpsf_log_printf (psf, \"Trying offset of 0x52 bytes.\\n\") ;", " \t\trsrc.data_offset = read_rsrc_int (&rsrc, 0x52 + 0) + 0x52 ;", " \t\trsrc.map_offset = read_rsrc_int (&rsrc, 0x52 + 4) + 0x52 ;", " \t\trsrc.data_length = read_rsrc_int (&rsrc, 0x52 + 8) ;", " \t\trsrc.map_length = read_rsrc_int (&rsrc, 0x52 + 12) ;", " \t\t} ;", " \tpsf_log_printf (psf, \"  data offset : 0x%04X\\n  map  offset : 0x%04X\\n\"", " \t\t\t\t\"  data length : 0x%04X\\n  map  length : 0x%04X\\n\",", " \t\t\t\trsrc.data_offset, rsrc.map_offset, rsrc.data_length, rsrc.map_length) ;", " \tif (rsrc.data_offset > rsrc.rsrc_len)", " \t{\tpsf_log_printf (psf, \"Error : rsrc.data_offset (%d, 0x%x) > len\\n\", rsrc.data_offset, rsrc.data_offset) ;", " \t\terror = SFE_SD2_BAD_DATA_OFFSET ;", " \t\tgoto parse_rsrc_fork_cleanup ;", " \t\t} ;", " \tif (rsrc.map_offset > rsrc.rsrc_len)", " \t{\tpsf_log_printf (psf, \"Error : rsrc.map_offset > len\\n\") ;", " \t\terror = SFE_SD2_BAD_MAP_OFFSET ;", " \t\tgoto parse_rsrc_fork_cleanup ;", " \t\t} ;", " \tif (rsrc.data_length > rsrc.rsrc_len)", " \t{\tpsf_log_printf (psf, \"Error : rsrc.data_length > len\\n\") ;", " \t\terror = SFE_SD2_BAD_DATA_LENGTH ;", " \t\tgoto parse_rsrc_fork_cleanup ;", " \t\t} ;", " \tif (rsrc.map_length > rsrc.rsrc_len)", " \t{\tpsf_log_printf (psf, \"Error : rsrc.map_length > len\\n\") ;", " \t\terror = SFE_SD2_BAD_MAP_LENGTH ;", " \t\tgoto parse_rsrc_fork_cleanup ;", " \t\t} ;", " \tif (rsrc.data_offset + rsrc.data_length != rsrc.map_offset || rsrc.map_offset + rsrc.map_length != rsrc.rsrc_len)", " \t{\tpsf_log_printf (psf, \"Error : This does not look like a MacOSX resource fork.\\n\") ;", " \t\terror = SFE_SD2_BAD_RSRC ;", " \t\tgoto parse_rsrc_fork_cleanup ;", " \t\t} ;", " \tif (rsrc.map_offset + 28 >= rsrc.rsrc_len)", " \t{\tpsf_log_printf (psf, \"Bad map offset (%d + 28 > %d).\\n\", rsrc.map_offset, rsrc.rsrc_len) ;", " \t\terror = SFE_SD2_BAD_RSRC ;", " \t\tgoto parse_rsrc_fork_cleanup ;", " \t\t} ;", " \trsrc.string_offset = rsrc.map_offset + read_rsrc_short (&rsrc, rsrc.map_offset + 26) ;", " \tif (rsrc.string_offset > rsrc.rsrc_len)", " \t{\tpsf_log_printf (psf, \"Bad string offset (%d).\\n\", rsrc.string_offset) ;", " \t\terror = SFE_SD2_BAD_RSRC ;", " \t\tgoto parse_rsrc_fork_cleanup ;", " \t\t} ;", "  \trsrc.type_offset = rsrc.map_offset + 30 ;", " \tif (rsrc.map_offset + 28 > rsrc.rsrc_len)", " \t{\tpsf_log_printf (psf, \"Bad map offset.\\n\") ;", " \t\tgoto parse_rsrc_fork_cleanup ;", " \t\t} ;", "  \trsrc.type_count = read_rsrc_short (&rsrc, rsrc.map_offset + 28) + 1 ;", "  \tif (rsrc.type_count < 1)", "  \t{\tpsf_log_printf (psf, \"Bad type count.\\n\") ;", " \t\terror = SFE_SD2_BAD_RSRC ;", " \t\tgoto parse_rsrc_fork_cleanup ;", " \t\t} ;", " \trsrc.item_offset = rsrc.type_offset + rsrc.type_count * 8 ;", " \tif (rsrc.item_offset < 0 || rsrc.item_offset > rsrc.rsrc_len)", " \t{\tpsf_log_printf (psf, \"Bad item offset (%d).\\n\", rsrc.item_offset) ;", " \t\terror = SFE_SD2_BAD_RSRC ;", " \t\tgoto parse_rsrc_fork_cleanup ;", " \t\t} ;", "  \trsrc.str_index = -1 ;", "  \tfor (k = 0 ; k < rsrc.type_count ; k ++)", "\t{\tmarker = read_rsrc_marker (&rsrc, rsrc.type_offset + k * 8) ;", " \t{\tif (rsrc.type_offset + k * 8 > rsrc.rsrc_len)", " \t\t{\tpsf_log_printf (psf, \"Bad rsrc marker.\\n\") ;", " \t\t\tgoto parse_rsrc_fork_cleanup ;", " \t\t\t} ;", " \t\tmarker = read_rsrc_marker (&rsrc, rsrc.type_offset + k * 8) ;", "  \t\tif (marker == STR_MARKER)", "  \t\t{\trsrc.str_index = k ;", " \t\t\trsrc.str_count = read_rsrc_short (&rsrc, rsrc.type_offset + k * 8 + 4) + 1 ;", " \t\t\terror = parse_str_rsrc (psf, &rsrc) ;", " \t\t\tgoto parse_rsrc_fork_cleanup ;", " \t\t\t} ;", " \t\t} ;", " \tpsf_log_printf (psf, \"No 'STR ' resource.\\n\") ;", " \terror = SFE_SD2_BAD_RSRC ;", " parse_rsrc_fork_cleanup :", " \tpsf_use_rsrc (psf, SF_FALSE) ;", " \tif (rsrc.need_to_free_rsrc_data)", " \t\tfree (rsrc.rsrc_data) ;", " \treturn error ;", " }  "], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  sec_decrypt(uint8 * data, int length)", "  {", " \tif (length <= 0)", " \t\treturn;", "  \tif (g_sec_decrypt_use_count == 4096)", "  \t{", "  \t\tsec_update(g_sec_decrypt_key, g_sec_decrypt_update_key);", " \t\trdssl_rc4_set_key(&g_rc4_decrypt_key, g_sec_decrypt_key, g_rc4_key_len);", " \t\tg_sec_decrypt_use_count = 0;", " \t}", " \trdssl_rc4_crypt(&g_rc4_decrypt_key, data, data, length);", " \tg_sec_decrypt_use_count++;", " }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" on_unregister_handler(TCMUService1HandlerManager1 *interface,", " \t\t      GDBusMethodInvocation *invocation,", " \t\t      gchar *subtype,", " \t\t      gpointer user_data)", " {", " \tstruct tcmur_handler *handler = find_handler_by_subtype(subtype);", " \tstruct dbus_info *info = handler ? handler->opaque : NULL;", " \tif (!handler) {", " \t\tg_dbus_method_invocation_return_value(invocation,", " \t\t\tg_variant_new(\"(bs)\", FALSE,", "  \t\t\t\t      \"unknown subtype\"));", "  \t\treturn TRUE;", "  \t}", " \telse if (handler->_is_dbus_handler != 1) {", " \t\tg_dbus_method_invocation_return_value(invocation,", " \t\t\tg_variant_new(\"(bs)\", FALSE,", " \t\t\t\t      \"cannot unregister internal handler\"));", " \t\treturn TRUE;", " \t}", "  \tdbus_unexport_handler(handler);", "\ttcmur_unregister_handler(handler);", " \ttcmur_unregister_dbus_handler(handler);", "  \tg_bus_unwatch_name(info->watcher_id);", "  \tg_free(info);", "  \tg_free(handler);", " \tg_dbus_method_invocation_return_value(invocation,", " \t\tg_variant_new(\"(bs)\", TRUE, \"succeeded\"));", " \treturn TRUE;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" FUNC_DECODER(dissector_postgresql)", " {", "    DECLARE_DISP_PTR(ptr);", "    struct ec_session *s = NULL;", "    void *ident = NULL;", "    char tmp[MAX_ASCII_ADDR_LEN];", "    struct postgresql_status *conn_status;", "    (void) DECODE_DATA; ", "    (void) DECODE_DATALEN;", "    (void) DECODED_LEN;", "    if (FROM_CLIENT(\"postgresql\", PACKET)) {", "       if (PACKET->DATA.len < 4)", "          return NULL;", "       dissect_create_ident(&ident, PACKET, DISSECT_CODE(dissector_postgresql));", "       if (session_get(&s, ident, DISSECT_IDENT_LEN) == -ENOTFOUND) {", "          unsigned char *u = memmem(ptr, PACKET->DATA.len, \"user\", 4);", "          unsigned char *d = memmem(ptr, PACKET->DATA.len, \"database\", 8);", "          if (!memcmp(ptr + 4, \"\\x00\\x03\\x00\\x00\", 4) && u && d) {", "             dissect_create_session(&s, PACKET, DISSECT_CODE(dissector_postgresql));", "             SAFE_CALLOC(s->data, 1, sizeof(struct postgresql_status));", "             conn_status = (struct postgresql_status *) s->data;", "             conn_status->status = WAIT_AUTH;", "             strncpy((char*)conn_status->user, (char*)(u + 5), 65);", "             conn_status->user[64] = 0;", "             strncpy((char*)conn_status->database, (char*)(d + 9), 65);", "             conn_status->database[64] = 0;", "             session_put(s);", "          }", "       } else {", "          conn_status = (struct postgresql_status *) s->data;", "          if (conn_status->status == WAIT_RESPONSE) {", "             if (ptr[0] == 'p' && conn_status->type == MD5) {", "                DEBUG_MSG(\"\\tDissector_postgresql RESPONSE type is MD5\");", "                if(memcmp(ptr + 1, \"\\x00\\x00\\x00\\x28\", 4)) {", "                   DEBUG_MSG(\"\\tDissector_postgresql BUG, expected length is 40\");", "                   return NULL;", "                }", "                if (PACKET->DATA.len < 40) {", "                   DEBUG_MSG(\"\\tDissector_postgresql BUG, expected length is 40\");", "                   return NULL;", "                }", "                memcpy(conn_status->hash, ptr + 5 + 3, 32);", "                conn_status->hash[32] = 0;", "                DISSECT_MSG(\"%s:$postgres$%s*%s*%s:%s:%d\\n\", conn_status->user, conn_status->user, conn_status->salt, conn_status->hash, ip_addr_ntoa(&PACKET->L3.dst, tmp), ntohs(PACKET->L4.dst));", "                dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));", "             }", "             else if (ptr[0] == 'p' && conn_status->type == CT) {", "                 int length;", "                 DEBUG_MSG(\"\\tDissector_postgresql RESPONSE type is clear-text!\");", "                 GET_ULONG_BE(length, ptr, 1);", "               strncpy((char*)conn_status->password, (char*)(ptr + 5), length - 4);", "               conn_status->password[length - 4] = 0;", "                length -= 4;", "                if (length < 0 || length > 65 || PACKET->DATA.len < length+5) {", "                    dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));", "                    return NULL;", "                }", "                snprintf((char*)conn_status->password, length+1, \"%s\", (char*)(ptr + 5));", "                 DISSECT_MSG(\"PostgreSQL credentials:%s-%d:%s:%s\\n\", ip_addr_ntoa(&PACKET->L3.dst, tmp), ntohs(PACKET->L4.dst), conn_status->user, conn_status->password);", "                 dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));", "              }", "          }", "       }", "    } else {  ", "       if (PACKET->DATA.len < 9)", "          return NULL;", "       dissect_create_ident(&ident, PACKET, DISSECT_CODE(dissector_postgresql));", "       if (session_get(&s, ident, DISSECT_IDENT_LEN) == ESUCCESS) {", "          conn_status = (struct postgresql_status *) s->data;", "          if (conn_status->status == WAIT_AUTH &&", "                ptr[0] == 'R' && !memcmp(ptr + 1, \"\\x00\\x00\\x00\\x0c\", 4)  &&", "                !memcmp(ptr + 5, \"\\x00\\x00\\x00\\x05\", 4)) {", "             conn_status->status = WAIT_RESPONSE;", "             conn_status->type = MD5;", "             DEBUG_MSG(\"\\tDissector_postgresql AUTH type is MD5\");", "             hex_encode(ptr + 9, 4, conn_status->salt);  ", "          }", "          else if (conn_status->status == WAIT_AUTH &&", "                ptr[0] == 'R' && !memcmp(ptr + 1, \"\\x00\\x00\\x00\\x08\", 4)  &&", "                !memcmp(ptr + 5, \"\\x00\\x00\\x00\\x03\", 4)) {", "             conn_status->status = WAIT_RESPONSE;", "             conn_status->type = CT;", "             DEBUG_MSG(\"\\tDissector_postgresql AUTH type is clear-text!\");", "          }", "       }", "    }", "    SAFE_FREE(ident);", "    return NULL;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  int ras_validate(jas_stream_t *in)", "  {", "\tuchar buf[RAS_MAGICLEN];", " \tjas_uchar buf[RAS_MAGICLEN];", "  \tint i;", "  \tint n;", "  \tuint_fast32_t magic;", " \tassert(JAS_STREAM_MAXPUTBACK >= RAS_MAGICLEN);", " \tif ((n = jas_stream_read(in, buf, RAS_MAGICLEN)) < 0) {", " \t\treturn -1;", " \t}", " \tfor (i = n - 1; i >= 0; --i) {", " \t\tif (jas_stream_ungetc(in, buf[i]) == EOF) {", " \t\t\treturn -1;", " \t\t}", " \t}", " \tif (n < RAS_MAGICLEN) {", " \t\treturn -1;", " \t}", " \tmagic = (JAS_CAST(uint_fast32_t, buf[0]) << 24) |", " \t  (JAS_CAST(uint_fast32_t, buf[1]) << 16) |", " \t  (JAS_CAST(uint_fast32_t, buf[2]) << 8) |", " \t  buf[3];", " \tif (magic != RAS_MAGIC) {", " \t\treturn -1;", " \t}", " \treturn 0;", " }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" iasecc_get_serialnr(struct sc_card *card, struct sc_serial_number *serial)", " {", " \tstruct sc_context *ctx = card->ctx;", " \tstruct sc_iin *iin = &card->serialnr.iin;", " \tstruct sc_apdu apdu;", " \tunsigned char rbuf[0xC0];", " \tsize_t ii, offs;", " \tint rv;", " \tLOG_FUNC_CALLED(ctx);", " \tif (card->serialnr.len)", " \t\tgoto end;", " \tmemset(&card->serialnr, 0, sizeof(card->serialnr));", " \tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xB0, 0x80 | IASECC_SFI_EF_SN, 0);", " \tapdu.le = sizeof(rbuf);", " \tapdu.resp = rbuf;", " \tapdu.resplen = sizeof(rbuf);", " \trv = sc_transmit_apdu(card, &apdu);", " \tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");", " \trv = sc_check_sw(card, apdu.sw1, apdu.sw2);", " \tLOG_TEST_RET(ctx, rv, \"Get 'serial number' data failed\");", " \tif (rbuf[0] != ISO7812_PAN_SN_TAG)", " \t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"serial number parse error\");", " \tiin->mii = (rbuf[2] >> 4) & 0x0F;", " \tiin->country = 0;", " \tfor (ii=5; ii<8; ii++)   {", " \t\tiin->country *= 10;", " \t\tiin->country += (rbuf[ii/2] >> ((ii & 0x01) ? 0 : 4)) & 0x0F;", " \t}", " \tiin->issuer_id = 0;", " \tfor (ii=8; ii<10; ii++)   {", " \t\tiin->issuer_id *= 10;", " \t\tiin->issuer_id += (rbuf[ii/2] >> (ii & 0x01 ? 0 : 4)) & 0x0F;", " \t}", " \toffs = rbuf[1] > 8 ? rbuf[1] - 8 : 0;", "  \tif (card->type == SC_CARD_TYPE_IASECC_SAGEM)   {", "\t\tfor (ii=0; ii < rbuf[1] - offs; ii++)", " \t\tfor (ii=0; (ii < rbuf[1] - offs) && (ii + offs + 2 < sizeof(rbuf)); ii++)", "  \t\t\t*(card->serialnr.value + ii) = ((rbuf[ii + offs + 1] & 0x0F) << 4)", "  \t\t\t\t+ ((rbuf[ii + offs + 2] & 0xF0) >> 4) ;", "  \t\tcard->serialnr.len = ii;", " \t}", " \telse   {", " \t\tfor (ii=0; ii < rbuf[1] - offs; ii++)", " \t\t\t*(card->serialnr.value + ii) = rbuf[ii + offs + 2];", " \t\tcard->serialnr.len = ii;", " \t}", " \tdo  {", " \t\tchar txt[0x200];", " \t\tfor (ii=0;ii<card->serialnr.len;ii++)", " \t\t\tsprintf(txt + ii*2, \"%02X\", *(card->serialnr.value + ii));", " \t\tsc_log(ctx, \"serial number '%s'; mii %i; country %i; issuer_id %li\", txt, iin->mii, iin->country, iin->issuer_id);", " \t} while(0);", " end:", " \tif (serial)", " \t\tmemcpy(serial, &card->serialnr, sizeof(*serial));", " \tLOG_FUNC_RETURN(ctx, SC_SUCCESS);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void Sp_search(js_State *J)", " {", " \tjs_Regexp *re;", " \tconst char *text;", " \tResub m;", " \ttext = checkstring(J, 0);", " \tif (js_isregexp(J, 1))", " \t\tjs_copy(J, 1);", " \telse if (js_isundefined(J, 1))", " \t\tjs_newregexp(J, \"\", 0);", " \telse", " \t\tjs_newregexp(J, js_tostring(J, 1), 0);", "  \tre = js_toregexp(J, -1);", "\tif (!js_regexec(re->prog, text, &m, 0))", " \tif (!js_doregexec(J, re->prog, text, &m, 0))", "  \t\tjs_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));", "  \telse", "  \t\tjs_pushnumber(J, -1);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0]}
{"tokens": [" aiff_read_chanmap (SF_PRIVATE * psf, unsigned dword)", " {\tconst AIFF_CAF_CHANNEL_MAP * map_info ;", " \tunsigned channel_bitmap, channel_decriptions, bytesread ;", " \tint layout_tag ;", " \tbytesread = psf_binheader_readf (psf, \"444\", &layout_tag, &channel_bitmap, &channel_decriptions) ;", " \tif ((map_info = aiff_caf_of_channel_layout_tag (layout_tag)) == NULL)", " \t\treturn 0 ;", " \tpsf_log_printf (psf, \"  Tag    : %x\\n\", layout_tag) ;", " \tif (map_info)", " \t\tpsf_log_printf (psf, \"  Layout : %s\\n\", map_info->name) ;", " \tif (bytesread < dword)", "  \t\tpsf_binheader_readf (psf, \"j\", dword - bytesread) ;", "  \tif (map_info->channel_map != NULL)", "\t{\tsize_t chanmap_size = psf->sf.channels * sizeof (psf->channel_map [0]) ;", " \t{\tsize_t chanmap_size = SF_MIN (psf->sf.channels, layout_tag & 0xffff) * sizeof (psf->channel_map [0]) ;", "  \t\tfree (psf->channel_map) ;", " \t\tif ((psf->channel_map = malloc (chanmap_size)) == NULL)", " \t\t\treturn SFE_MALLOC_FAILED ;", " \t\tmemcpy (psf->channel_map, map_info->channel_map, chanmap_size) ;", " \t\t} ;", " \treturn 0 ;", " }  "], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int mxf_read_primer_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)", " {", "     MXFContext *mxf = arg;", "     int item_num = avio_rb32(pb);", "     int item_len = avio_rb32(pb);", "     if (item_len != 18) {", "          avpriv_request_sample(pb, \"Primer pack item length %d\", item_len);", "          return AVERROR_PATCHWELCOME;", "      }", "    if (item_num > 65536) {", "     if (item_num > 65536 || item_num < 0) {", "          av_log(mxf->fc, AV_LOG_ERROR, \"item_num %d is too large\\n\", item_num);", "          return AVERROR_INVALIDDATA;", "      }", "     if (mxf->local_tags)", "         av_log(mxf->fc, AV_LOG_VERBOSE, \"Multiple primer packs\\n\");", "     av_free(mxf->local_tags);", "     mxf->local_tags_count = 0;", "     mxf->local_tags = av_calloc(item_num, item_len);", "     if (!mxf->local_tags)", "         return AVERROR(ENOMEM);", "     mxf->local_tags_count = item_num;", "     avio_read(pb, mxf->local_tags, item_num*item_len);", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["GF_Err gf_isom_oinf_read_entry(void *entry, GF_BitStream *bs)", "{", "GF_OperatingPointsInformation* ptr = (GF_OperatingPointsInformation *)entry;", "u32 i, j, count;", "if (!ptr) return GF_BAD_PARAM;", "ptr->scalability_mask = gf_bs_read_u16(bs);", "gf_bs_read_int(bs, 2);", "count = gf_bs_read_int(bs, 6);", "for (i = 0; i < count; i++) {", "LHEVC_ProfileTierLevel *ptl;", "GF_SAFEALLOC(ptl, LHEVC_ProfileTierLevel);", "if (!ptl) return GF_OUT_OF_MEM;", "ptl->general_profile_space = gf_bs_read_int(bs, 2);", "ptl->general_tier_flag= gf_bs_read_int(bs, 1);", "ptl->general_profile_idc = gf_bs_read_int(bs, 5);", "ptl->general_profile_compatibility_flags = gf_bs_read_u32(bs);", "ptl->general_constraint_indicator_flags = gf_bs_read_long_int(bs, 48);", "ptl->general_level_idc = gf_bs_read_u8(bs);", "gf_list_add(ptr->profile_tier_levels, ptl);", "}", "count = gf_bs_read_u16(bs);", "for (i = 0; i < count; i++) {", "LHEVC_OperatingPoint *op;", "GF_SAFEALLOC(op, LHEVC_OperatingPoint);", "if (!op) return GF_OUT_OF_MEM;", "op->output_layer_set_idx = gf_bs_read_u16(bs);", "op->max_temporal_id = gf_bs_read_u8(bs);", "op->layer_count = gf_bs_read_u8(bs);", "if (op->layer_count > GF_ARRAY_LENGTH(op->layers_info))", "return GF_NON_COMPLIANT_BITSTREAM;", "for (j = 0; j < op->layer_count; j++) {", "op->layers_info[j].ptl_idx = gf_bs_read_u8(bs);", "op->layers_info[j].layer_id = gf_bs_read_int(bs, 6);", "op->layers_info[j].is_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;", "op->layers_info[j].is_alternate_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;", "}", "op->minPicWidth = gf_bs_read_u16(bs);", "op->minPicHeight = gf_bs_read_u16(bs);", "op->maxPicWidth = gf_bs_read_u16(bs);", "op->maxPicHeight = gf_bs_read_u16(bs);", "op->maxChromaFormat = gf_bs_read_int(bs, 2);", "op->maxBitDepth = gf_bs_read_int(bs, 3) + 8;", "gf_bs_read_int(bs, 1);", "op->frame_rate_info_flag = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;", "op->bit_rate_info_flag = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;", "if (op->frame_rate_info_flag) {", "op->avgFrameRate = gf_bs_read_u16(bs);", "gf_bs_read_int(bs, 6);", "op->constantFrameRate = gf_bs_read_int(bs, 2);", "}", "if (op->bit_rate_info_flag) {", "op->maxBitRate = gf_bs_read_u32(bs);", "op->avgBitRate = gf_bs_read_u32(bs);", "}", "gf_list_add(ptr->operating_points, op);", "}", "count = gf_bs_read_u8(bs);", "for (i = 0; i < count; i++) {", "LHEVC_DependentLayer *dep;", "GF_SAFEALLOC(dep, LHEVC_DependentLayer);", "if (!dep) return GF_OUT_OF_MEM;", "dep->dependent_layerID = gf_bs_read_u8(bs);", "dep->num_layers_dependent_on = gf_bs_read_u8(bs);", "if (dep->num_layers_dependent_on > GF_ARRAY_LENGTH(dep->dependent_on_layerID)) {", "gf_free(dep);", "return GF_NON_COMPLIANT_BITSTREAM;", "}", "for (j = 0; j < dep->num_layers_dependent_on; j++)", "dep->dependent_on_layerID[j] = gf_bs_read_u8(bs);", "for (j = 0; j < 16; j++) {", "if (ptr->scalability_mask & (1 << j))", "dep->dimension_identifier[j] = gf_bs_read_u8(bs);", "}", "gf_list_add(ptr->dependency_layers, dep);", "}", "return GF_OK;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int lookup1_values(int entries, int dim)", "{", "int r = (int) floor(exp((float) log((float) entries) / dim));", "if ((int) floor(pow((float) r+1, dim)) <= entries)", "++r;", "assert(pow((float) r+1, dim) > entries);", "assert((int) floor(pow((float) r, dim)) <= entries);", "return r;", "}"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 0, 0]}
{"tokens": ["const char * util_acl_to_str(const sc_acl_entry_t *e)", "{", "static char line[80], buf[20];", "unsigned int acl;", "if (e == NULL)", "return \"N/A\";", "line[0] = 0;", "while (e != NULL) {", "acl = e->method;", "switch (acl) {", "case SC_AC_UNKNOWN:", "return \"N/A\";", "case SC_AC_NEVER:", "return \"NEVR\";", "case SC_AC_NONE:", "return \"NONE\";", "case SC_AC_CHV:", "strcpy(buf, \"CHV\");", "if (e->key_ref != SC_AC_KEY_REF_NONE)", "sprintf(buf + 3, \"%d\", e->key_ref);", "break;", "case SC_AC_TERM:", "strcpy(buf, \"TERM\");", "break;", "case SC_AC_PRO:", "strcpy(buf, \"PROT\");", "break;", "case SC_AC_AUT:", "strcpy(buf, \"AUTH\");", "if (e->key_ref != SC_AC_KEY_REF_NONE)", "sprintf(buf + 4, \"%d\", e->key_ref);", "break;", "case SC_AC_SEN:", "strcpy(buf, \"Sec.Env. \");", "if (e->key_ref != SC_AC_KEY_REF_NONE)", "sprintf(buf + 3, \"#%d\", e->key_ref);", "break;", "case SC_AC_SCB:", "strcpy(buf, \"Sec.ControlByte \");", "if (e->key_ref != SC_AC_KEY_REF_NONE)", "sprintf(buf + 3, \"Ox%X\", e->key_ref);", "break;", "case SC_AC_IDA:", "strcpy(buf, \"PKCS#15 AuthID \");", "if (e->key_ref != SC_AC_KEY_REF_NONE)", "sprintf(buf + 3, \"#%d\", e->key_ref);", "break;", "default:", "strcpy(buf, \"????\");", "break;", "}", "strcat(line, buf);", "strcat(line, \" \");", "e = e->next;", "}", "line[strlen(line)-1] = 0;", "return line;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0]}
{"tokens": ["free_link_refs(struct link_ref **references)", "{", "size_t i;", "for (i = 0; i < REF_TABLE_SIZE; ++i) {", "struct link_ref *r = references[i];", "struct link_ref *next;", "while (r) {", "next = r->next;", "bufrelease(r->link);", "bufrelease(r->title);", "free(r);", "r = next;", "}", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void RemoteFsDevice::unmount()", "{", "if (details.isLocalFile()) {", "return;", "}", "if (!isConnected() || proc) {", "return;", "}", "if (messageSent) {", "return;", "}", "if (constSambaProtocol==details.url.scheme() || constSambaAvahiProtocol==details.url.scheme()) {", "mounter()->umount(mountPoint(details, false), getpid());", "setStatusMessage(tr(\"Disconnecting...\"));", "messageSent=true;", "return;", "}", "QString cmd;", "QStringList args;", "if (!details.isLocalFile()) {", "QString mp=mountPoint(details, false);", "if (!mp.isEmpty()) {", "cmd=Utils::findExe(\"fusermount\");", "if (!cmd.isEmpty()) {", "args << QLatin1String(\"-u\") << QLatin1String(\"-z\") << mp;", "} else {", "emit error(tr(\"\\\"fusermount\\\" is not installed!\"));", "}", "}", "}", "if (!cmd.isEmpty()) {", "setStatusMessage(tr(\"Disconnecting...\"));", "proc=new QProcess(this);", "proc->setProperty(\"unmount\", true);", "connect(proc, SIGNAL(finished(int)), SLOT(procFinished(int)));", "proc->start(cmd, args, QIODevice::ReadOnly);", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int shm_create(XShmSegmentInfo *shm, XImage **ximg_ptr, int w, int h,", "char *name) {", "XImage *xim;", "static int reported_flip = 0;", "int db = 0;", "shm->shmid = -1;", "shm->shmaddr = (char *) -1;", "*ximg_ptr = NULL;", "if (nofb) {", "return 1;", "}", "X_LOCK;", "if (! using_shm || xform24to32 || raw_fb) {", "xim = XCreateImage_wr(dpy, default_visual, depth, ZPixmap,", "0, NULL, w, h, raw_fb ? 32 : BitmapPad(dpy), 0);", "X_UNLOCK;", "if (xim == NULL) {", "rfbErr(\"XCreateImage(%s) failed.\\n\", name);", "if (quiet) {", "fprintf(stderr, \"XCreateImage(%s) failed.\\n\",", "name);", "}", "return 0;", "}", "if (db) fprintf(stderr, \"shm_create simple %d %d\\t%p %s\\n\", w, h, (void *)xim, name);", "xim->data = (char *) malloc(xim->bytes_per_line * xim->height);", "if (xim->data == NULL) {", "rfbErr(\"XCreateImage(%s) data malloc failed.\\n\", name);", "if (quiet) {", "fprintf(stderr, \"XCreateImage(%s) data malloc\"", "\" failed.\\n\", name);", "}", "return 0;", "}", "if (flip_byte_order) {", "char *order = flip_ximage_byte_order(xim);", "if (! reported_flip && ! quiet) {", "rfbLog(\"Changing XImage byte order\"", "\" to %s\\n\", order);", "reported_flip = 1;", "}", "}", "*ximg_ptr = xim;", "return 1;", "}", "if (! dpy) {", "X_UNLOCK;", "return 0;", "}", "xim = XShmCreateImage_wr(dpy, default_visual, depth, ZPixmap, NULL,", "shm, w, h);", "if (xim == NULL) {", "rfbErr(\"XShmCreateImage(%s) failed.\\n\", name);", "if (quiet) {", "fprintf(stderr, \"XShmCreateImage(%s) failed.\\n\", name);", "}", "X_UNLOCK;", "return 0;", "}", "*ximg_ptr = xim;", "#if HAVE_XSHM", "shm->shmid = shmget(IPC_PRIVATE,", "xim->bytes_per_line * xim->height, IPC_CREAT | 0777);", "if (shm->shmid == -1) {", "rfbErr(\"shmget(%s) failed.\\n\", name);", "rfbLogPerror(\"shmget\");", "XDestroyImage(xim);", "*ximg_ptr = NULL;", "X_UNLOCK;", "return 0;", "}", "shm->shmaddr = xim->data = (char *) shmat(shm->shmid, 0, 0);", "if (shm->shmaddr == (char *)-1) {", "rfbErr(\"shmat(%s) failed.\\n\", name);", "rfbLogPerror(\"shmat\");", "XDestroyImage(xim);", "*ximg_ptr = NULL;", "shmctl(shm->shmid, IPC_RMID, 0);", "shm->shmid = -1;", "X_UNLOCK;", "return 0;", "}", "shm->readOnly = False;", "if (! XShmAttach_wr(dpy, shm)) {", "rfbErr(\"XShmAttach(%s) failed.\\n\", name);", "XDestroyImage(xim);", "*ximg_ptr = NULL;", "shmdt(shm->shmaddr);", "shm->shmaddr = (char *) -1;", "shmctl(shm->shmid, IPC_RMID, 0);", "shm->shmid = -1;", "X_UNLOCK;", "return 0;", "}", "#endif", "X_UNLOCK;", "return 1;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["s32 gf_avc_parse_nalu(GF_BitStream *bs, AVCState *avc)", "{", "u8 idr_flag;", "s32 slice, ret;", "u32 nal_hdr;", "AVCSliceInfo n_state;", "gf_bs_enable_emulation_byte_removal(bs, GF_TRUE);", "nal_hdr = gf_bs_read_u8(bs);", "slice = 0;", "memcpy(&n_state, &avc->s_info, sizeof(AVCSliceInfo));", "avc->last_nal_type_parsed = n_state.nal_unit_type = nal_hdr & 0x1F;", "n_state.nal_ref_idc = (nal_hdr >> 5) & 0x3;", "idr_flag = 0;", "switch (n_state.nal_unit_type) {", "case GF_AVC_NALU_ACCESS_UNIT:", "case GF_AVC_NALU_END_OF_SEQ:", "case GF_AVC_NALU_END_OF_STREAM:", "ret = 1;", "break;", "case GF_AVC_NALU_SVC_SLICE:", "SVC_ReadNal_header_extension(bs, &n_state.NalHeader);", "svc_parse_slice(bs, avc, &n_state);", "if (avc->s_info.nal_ref_idc) {", "n_state.poc_lsb_prev = avc->s_info.poc_lsb;", "n_state.poc_msb_prev = avc->s_info.poc_msb;", "}", "avc_compute_poc(&n_state);", "if (avc->s_info.poc != n_state.poc) {", "memcpy(&avc->s_info, &n_state, sizeof(AVCSliceInfo));", "return 1;", "}", "memcpy(&avc->s_info, &n_state, sizeof(AVCSliceInfo));", "return 0;", "case GF_AVC_NALU_SVC_PREFIX_NALU:", "SVC_ReadNal_header_extension(bs, &n_state.NalHeader);", "return 0;", "case GF_AVC_NALU_IDR_SLICE:", "case GF_AVC_NALU_NON_IDR_SLICE:", "case GF_AVC_NALU_DP_A_SLICE:", "case GF_AVC_NALU_DP_B_SLICE:", "case GF_AVC_NALU_DP_C_SLICE:", "slice = 1;", "ret = avc_parse_slice(bs, avc, idr_flag, &n_state);", "if (ret < 0) return ret;", "ret = 0;", "if (", "((avc->s_info.nal_unit_type > GF_AVC_NALU_IDR_SLICE) || (avc->s_info.nal_unit_type < GF_AVC_NALU_NON_IDR_SLICE))", "&& (avc->s_info.nal_unit_type != GF_AVC_NALU_SVC_SLICE)", ") {", "break;", "}", "if (avc->s_info.frame_num != n_state.frame_num) {", "ret = 1;", "break;", "}", "if (avc->s_info.field_pic_flag != n_state.field_pic_flag) {", "ret = 1;", "break;", "}", "if ((avc->s_info.nal_ref_idc != n_state.nal_ref_idc) &&", "(!avc->s_info.nal_ref_idc || !n_state.nal_ref_idc)) {", "ret = 1;", "break;", "}", "assert(avc->s_info.sps);", "if (avc->s_info.sps->poc_type == n_state.sps->poc_type) {", "if (!avc->s_info.sps->poc_type) {", "if (!n_state.bottom_field_flag && (avc->s_info.poc_lsb != n_state.poc_lsb)) {", "ret = 1;", "break;", "}", "if (avc->s_info.delta_poc_bottom != n_state.delta_poc_bottom) {", "ret = 1;", "break;", "}", "}", "else if (avc->s_info.sps->poc_type == 1) {", "if (avc->s_info.delta_poc[0] != n_state.delta_poc[0]) {", "ret = 1;", "break;", "}", "if (avc->s_info.delta_poc[1] != n_state.delta_poc[1]) {", "ret = 1;", "break;", "}", "}", "}", "if (n_state.nal_unit_type == GF_AVC_NALU_IDR_SLICE) {", "if (avc->s_info.nal_unit_type != GF_AVC_NALU_IDR_SLICE) {", "ret = 1;", "break;", "}", "else if (avc->s_info.idr_pic_id != n_state.idr_pic_id) {", "ret = 1;", "break;", "}", "}", "break;", "case GF_AVC_NALU_SEQ_PARAM:", "avc->last_ps_idx = gf_avc_read_sps_bs_internal(bs, avc, 0, NULL, nal_hdr);", "if (avc->last_ps_idx < 0) return -1;", "return 0;", "case GF_AVC_NALU_PIC_PARAM:", "avc->last_ps_idx = gf_avc_read_pps_bs_internal(bs, avc, nal_hdr);", "if (avc->last_ps_idx < 0) return -1;", "return 0;", "case GF_AVC_NALU_SVC_SUBSEQ_PARAM:", "avc->last_ps_idx = gf_avc_read_sps_bs_internal(bs, avc, 1, NULL, nal_hdr);", "if (avc->last_ps_idx < 0) return -1;", "return 0;", "case GF_AVC_NALU_SEQ_PARAM_EXT:", "avc->last_ps_idx = (s32) gf_bs_read_ue(bs);", "if (avc->last_ps_idx < 0) return -1;", "return 0;", "case GF_AVC_NALU_SEI:", "case GF_AVC_NALU_FILLER_DATA:", "return 0;", "default:", "if (avc->s_info.nal_unit_type <= GF_AVC_NALU_IDR_SLICE) ret = 1;", "else if ((nal_hdr & 0x1F) == GF_AVC_NALU_SEI && avc->s_info.nal_unit_type == GF_AVC_NALU_SVC_SLICE)", "ret = 1;", "else if ((nal_hdr & 0x1F) == GF_AVC_NALU_SEQ_PARAM && avc->s_info.nal_unit_type == GF_AVC_NALU_SVC_SLICE)", "ret = 1;", "else", "ret = 0;", "break;", "}", "if (ret && avc->s_info.sps) {", "n_state.frame_num_offset_prev = avc->s_info.frame_num_offset;", "if ((avc->s_info.sps->poc_type != 2) || (avc->s_info.nal_ref_idc != 0))", "n_state.frame_num_prev = avc->s_info.frame_num;", "if (avc->s_info.nal_ref_idc) {", "n_state.poc_lsb_prev = avc->s_info.poc_lsb;", "n_state.poc_msb_prev = avc->s_info.poc_msb;", "}", "}", "if (slice)", "avc_compute_poc(&n_state);", "memcpy(&avc->s_info, &n_state, sizeof(AVCSliceInfo));", "return ret;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["sec_recv(RD_BOOL * is_fastpath)", "{", "uint8 fastpath_hdr, fastpath_flags;", "uint16 sec_flags;", "uint16 channel;", "STREAM s;", "while ((s = mcs_recv(&channel, is_fastpath, &fastpath_hdr)) != NULL)", "{", "if (*is_fastpath == True)", "{", "fastpath_flags = (fastpath_hdr & 0xC0) >> 6;", "if (fastpath_flags & FASTPATH_OUTPUT_ENCRYPTED)", "{", "in_uint8s(s, 8);", "sec_decrypt(s->p, s->end - s->p);", "}", "return s;", "}", "if (g_encryption || (!g_licence_issued && !g_licence_error_result))", "{", "in_uint16_le(s, sec_flags);", "in_uint8s(s, 2);", "if (g_encryption)", "{", "if (sec_flags & SEC_ENCRYPT)", "{", "in_uint8s(s, 8);", "sec_decrypt(s->p, s->end - s->p);", "}", "if (sec_flags & SEC_LICENSE_PKT)", "{", "licence_process(s);", "continue;", "}", "if (sec_flags & SEC_REDIRECTION_PKT)", "{", "uint8 swapbyte;", "in_uint8s(s, 8);", "sec_decrypt(s->p, s->end - s->p);", "if (s->p[0] == 0 && s->p[1] == 4)", "{", "swapbyte = s->p[0];", "s->p[0] = s->p[2];", "s->p[2] = swapbyte;", "swapbyte = s->p[1];", "s->p[1] = s->p[3];", "s->p[3] = swapbyte;", "swapbyte = s->p[2];", "s->p[2] = s->p[3];", "s->p[3] = swapbyte;", "}", "}", "}", "else", "{", "if (sec_flags & SEC_LICENSE_PKT)", "{", "licence_process(s);", "continue;", "}", "s->p -= 4;", "}", "}", "if (channel != MCS_GLOBAL_CHANNEL)", "{", "channel_process(s, channel);", "continue;", "}", "return s;", "}", "return NULL;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["xmlRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {", "xmlIDTablePtr table;", "xmlIDPtr id;", "xmlChar *ID;", "if (doc == NULL) return(-1);", "if (attr == NULL) return(-1);", "table = (xmlIDTablePtr) doc->ids;", "if (table == NULL)", "return(-1);", "ID = xmlNodeListGetString(doc, attr->children, 1);", "if (ID == NULL)", "return(-1);", "id = xmlHashLookup(table, ID);", "if (id == NULL || id->attr != attr) {", "xmlFree(ID);", "return(-1);", "}", "xmlHashRemoveEntry(table, ID, xmlFreeIDTableEntry);", "xmlFree(ID);", "attr->atype = 0;", "return(0);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static bool MR_primality_test(UnsignedBigInteger n, const Vector<UnsignedBigInteger, 256>& tests)", "{", "ASSERT(!(n < 4));", "auto predecessor = n.minus({ 1 });", "auto d = predecessor;", "size_t r = 0;", "{", "auto div_result = d.divided_by(2);", "while (div_result.remainder == 0) {", "d = div_result.quotient;", "div_result = d.divided_by(2);", "++r;", "}", "}", "if (r == 0) {", "return n == 2;", "}", "for (auto a : tests) {", "ASSERT(a < n);", "auto x = ModularPower(a, d, n);", "if (x == 1 || x == predecessor)", "continue;", "bool skip_this_witness = false;", "for (size_t i = 0; i < r - 1; ++i) {", "x = ModularPower(x, 2, n);", "if (x == predecessor) {", "skip_this_witness = true;", "break;", "}", "}", "if (skip_this_witness)", "continue;", "return false;", "}", "return true;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["PackLinuxElf64::elf_find_dynamic(unsigned int key) const", "{", "Elf64_Dyn const *dynp= dynseg;", "if (dynp)", "for (; (unsigned)((char const *)dynp - (char const *)dynseg) < sz_dynseg", "&& Elf64_Dyn::DT_NULL!=dynp->d_tag; ++dynp) if (get_te64(&dynp->d_tag)==key) {", "upx_uint64_t const t= elf_get_offset_from_address(get_te64(&dynp->d_val));", "if (t) {", "return &((unsigned char const *)file_image)[(size_t)t];", "}", "break;", "}", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": ["_forceinline void Unpack::CopyString(uint Length,uint Distance)", "{", "size_t SrcPtr=UnpPtr-Distance;", "if (SrcPtr<MaxWinSize-MAX_LZ_MATCH && UnpPtr<MaxWinSize-MAX_LZ_MATCH)", "{", "byte *Src=Window+SrcPtr;", "byte *Dest=Window+UnpPtr;", "UnpPtr+=Length;", "#ifdef FAST_MEMCPY", "if (Distance<Length)", "#endif", "while (Length>=8)", "{", "Dest[0]=Src[0];", "Dest[1]=Src[1];", "Dest[2]=Src[2];", "Dest[3]=Src[3];", "Dest[4]=Src[4];", "Dest[5]=Src[5];", "Dest[6]=Src[6];", "Dest[7]=Src[7];", "Src+=8;", "Dest+=8;", "Length-=8;", "}", "#ifdef FAST_MEMCPY", "else", "while (Length>=8)", "{", "memcpy(Dest,Src,8);", "Src+=8;", "Dest+=8;", "Length-=8;", "}", "#endif", "if (Length>0) { Dest[0]=Src[0];", "if (Length>1) { Dest[1]=Src[1];", "if (Length>2) { Dest[2]=Src[2];", "if (Length>3) { Dest[3]=Src[3];", "if (Length>4) { Dest[4]=Src[4];", "if (Length>5) { Dest[5]=Src[5];", "if (Length>6) { Dest[6]=Src[6]; } } } } } } }", "}", "else", "while (Length-- > 0)", "{", "Window[UnpPtr]=Window[SrcPtr++ & MaxWinMask];", "UnpPtr=(UnpPtr+1) & MaxWinMask;", "}", "}"], "ner_tags": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["PQconnectPoll(PGconn *conn)", "{", "bool  reset_connection_state_machine = false;", "bool  need_new_connection = false;", "PGresult   *res;", "char  sebuf[PG_STRERROR_R_BUFLEN];", "int   optval;", "if (conn == NULL)", "return PGRES_POLLING_FAILED;", "switch (conn->status)", "{", "case CONNECTION_BAD:", "return PGRES_POLLING_FAILED;", "case CONNECTION_OK:", "return PGRES_POLLING_OK;", "case CONNECTION_AWAITING_RESPONSE:", "case CONNECTION_AUTH_OK:", "case CONNECTION_CHECK_WRITABLE:", "case CONNECTION_CONSUME:", "case CONNECTION_CHECK_STANDBY:", "{", "int   n = pqReadData(conn);", "if (n < 0)", "goto error_return;", "if (n == 0)", "return PGRES_POLLING_READING;", "break;", "}", "case CONNECTION_STARTED:", "case CONNECTION_MADE:", "break;", "case CONNECTION_SSL_STARTUP:", "case CONNECTION_NEEDED:", "case CONNECTION_GSS_STARTUP:", "case CONNECTION_CHECK_TARGET:", "break;", "default:", "appendPQExpBufferStr(&conn->errorMessage,", "libpq_gettext(\"invalid connection state, probably indicative of memory corruption\\n\"));", "goto error_return;", "}", "keep_going:", "if (conn->try_next_addr)", "{", "if (conn->addr_cur && conn->addr_cur->ai_next)", "{", "conn->addr_cur = conn->addr_cur->ai_next;", "reset_connection_state_machine = true;", "}", "else", "conn->try_next_host = true;", "conn->try_next_addr = false;", "}", "if (conn->try_next_host)", "{", "pg_conn_host *ch;", "struct addrinfo hint;", "int   thisport;", "int   ret;", "char  portstr[MAXPGPATH];", "if (conn->whichhost + 1 < conn->nconnhost)", "conn->whichhost++;", "else", "{", "if (conn->target_server_type == SERVER_TYPE_PREFER_STANDBY &&", "conn->nconnhost > 0)", "{", "conn->target_server_type = SERVER_TYPE_PREFER_STANDBY_PASS2;", "conn->whichhost = 0;", "}", "else", "goto error_return;", "}", "release_conn_addrinfo(conn);", "ch = &conn->connhost[conn->whichhost];", "MemSet(&hint, 0, sizeof(hint));", "hint.ai_socktype = SOCK_STREAM;", "conn->addrlist_family = hint.ai_family = AF_UNSPEC;", "if (ch->port == NULL || ch->port[0] == '\\0')", "thisport = DEF_PGPORT;", "else", "{", "if (!parse_int_param(ch->port, &thisport, conn, \"port\"))", "goto error_return;", "if (thisport < 1 || thisport > 65535)", "{", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"invalid port number: \\\"%s\\\"\\n\"),", "ch->port);", "goto keep_going;", "}", "}", "snprintf(portstr, sizeof(portstr), \"%d\", thisport);", "switch (ch->type)", "{", "case CHT_HOST_NAME:", "ret = pg_getaddrinfo_all(ch->host, portstr, &hint,", "&conn->addrlist);", "if (ret || !conn->addrlist)", "{", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"could not translate host name \\\"%s\\\" to address: %s\\n\"),", "ch->host, gai_strerror(ret));", "goto keep_going;", "}", "break;", "case CHT_HOST_ADDRESS:", "hint.ai_flags = AI_NUMERICHOST;", "ret = pg_getaddrinfo_all(ch->hostaddr, portstr, &hint,", "&conn->addrlist);", "if (ret || !conn->addrlist)", "{", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"could not parse network address \\\"%s\\\": %s\\n\"),", "ch->hostaddr, gai_strerror(ret));", "goto keep_going;", "}", "break;", "case CHT_UNIX_SOCKET:", "#ifdef HAVE_UNIX_SOCKETS", "conn->addrlist_family = hint.ai_family = AF_UNIX;", "UNIXSOCK_PATH(portstr, thisport, ch->host);", "if (strlen(portstr) >= UNIXSOCK_PATH_BUFLEN)", "{", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"Unix-domain socket path \\\"%s\\\" is too long (maximum %d bytes)\\n\"),", "portstr,", "(int) (UNIXSOCK_PATH_BUFLEN - 1));", "goto keep_going;", "}", "ret = pg_getaddrinfo_all(NULL, portstr, &hint,", "&conn->addrlist);", "if (ret || !conn->addrlist)", "{", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"could not translate Unix-domain socket path \\\"%s\\\" to address: %s\\n\"),", "portstr, gai_strerror(ret));", "goto keep_going;", "}", "#else", "Assert(false);", "#endif", "break;", "}", "conn->addr_cur = conn->addrlist;", "reset_connection_state_machine = true;", "conn->try_next_host = false;", "}", "if (reset_connection_state_machine)", "{", "conn->pversion = PG_PROTOCOL(3, 0);", "conn->send_appname = true;", "#ifdef USE_SSL", "conn->allow_ssl_try = (conn->sslmode[0] != 'd');", "conn->wait_ssl_try = (conn->sslmode[0] == 'a');", "#endif", "#ifdef ENABLE_GSS", "conn->try_gss = (conn->gssencmode[0] != 'd');", "#endif", "reset_connection_state_machine = false;", "need_new_connection = true;", "}", "if (need_new_connection)", "{", "pqDropConnection(conn, true);", "pqDropServerData(conn);", "conn->asyncStatus = PGASYNC_IDLE;", "conn->xactStatus = PQTRANS_IDLE;", "conn->pipelineStatus = PQ_PIPELINE_OFF;", "pqClearAsyncResult(conn);", "conn->status = CONNECTION_NEEDED;", "need_new_connection = false;", "}", "switch (conn->status)", "{", "case CONNECTION_NEEDED:", "{", "{", "struct addrinfo *addr_cur = conn->addr_cur;", "char  host_addr[NI_MAXHOST];", "if (addr_cur == NULL)", "{", "conn->try_next_host = true;", "goto keep_going;", "}", "memcpy(&conn->raddr.addr, addr_cur->ai_addr,", "addr_cur->ai_addrlen);", "conn->raddr.salen = addr_cur->ai_addrlen;", "if (conn->connip != NULL)", "{", "free(conn->connip);", "conn->connip = NULL;", "}", "getHostaddr(conn, host_addr, NI_MAXHOST);", "if (host_addr[0])", "conn->connip = strdup(host_addr);", "conn->sock = socket(addr_cur->ai_family, SOCK_STREAM, 0);", "if (conn->sock == PGINVALID_SOCKET)", "{", "int   errorno = SOCK_ERRNO;", "if (addr_cur->ai_next != NULL ||", "conn->whichhost + 1 < conn->nconnhost)", "{", "conn->try_next_addr = true;", "goto keep_going;", "}", "emitHostIdentityInfo(conn, host_addr);", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"could not create socket: %s\\n\"),", "SOCK_STRERROR(errorno, sebuf, sizeof(sebuf)));", "goto error_return;", "}", "emitHostIdentityInfo(conn, host_addr);", "if (!IS_AF_UNIX(addr_cur->ai_family))", "{", "if (!connectNoDelay(conn))", "{", "conn->try_next_addr = true;", "goto keep_going;", "}", "}", "if (!pg_set_noblock(conn->sock))", "{", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"could not set socket to nonblocking mode: %s\\n\"),", "SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));", "conn->try_next_addr = true;", "goto keep_going;", "}", "#ifdef F_SETFD", "if (fcntl(conn->sock, F_SETFD, FD_CLOEXEC) == -1)", "{", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"could not set socket to close-on-exec mode: %s\\n\"),", "SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));", "conn->try_next_addr = true;", "goto keep_going;", "}", "#endif\t\t\t\t\t\t\t/* F_SETFD */", "if (!IS_AF_UNIX(addr_cur->ai_family))", "{", "#ifndef WIN32", "int   on = 1;", "#endif", "int   usekeepalives = useKeepalives(conn);", "int   err = 0;", "if (usekeepalives < 0)", "{", "appendPQExpBufferStr(&conn->errorMessage,", "libpq_gettext(\"keepalives parameter must be an integer\\n\"));", "err = 1;", "}", "else if (usekeepalives == 0)", "{", "}", "#ifndef WIN32", "else if (setsockopt(conn->sock,", "SOL_SOCKET, SO_KEEPALIVE,", "(char *) &on, sizeof(on)) < 0)", "{", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"%s(%s) failed: %s\\n\"),", "\"setsockopt\",", "\"SO_KEEPALIVE\",", "SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));", "err = 1;", "}", "else if (!setKeepalivesIdle(conn)", "|| !setKeepalivesInterval(conn)", "|| !setKeepalivesCount(conn))", "err = 1;", "#else\t\t\t\t\t\t\t/* WIN32 */", "#ifdef SIO_KEEPALIVE_VALS", "else if (!setKeepalivesWin32(conn))", "err = 1;", "#endif\t\t\t\t\t\t\t/* SIO_KEEPALIVE_VALS */", "#endif\t\t\t\t\t\t\t/* WIN32 */", "else if (!setTCPUserTimeout(conn))", "err = 1;", "if (err)", "{", "conn->try_next_addr = true;", "goto keep_going;", "}", "}", "conn->sigpipe_so = false;", "#ifdef MSG_NOSIGNAL", "conn->sigpipe_flag = true;", "#else", "conn->sigpipe_flag = false;", "#endif\t\t\t\t\t\t\t/* MSG_NOSIGNAL */", "#ifdef SO_NOSIGPIPE", "optval = 1;", "if (setsockopt(conn->sock, SOL_SOCKET, SO_NOSIGPIPE,", "(char *) &optval, sizeof(optval)) == 0)", "{", "conn->sigpipe_so = true;", "conn->sigpipe_flag = false;", "}", "#endif\t\t\t\t\t\t\t/* SO_NOSIGPIPE */", "if (connect(conn->sock, addr_cur->ai_addr,", "addr_cur->ai_addrlen) < 0)", "{", "if (SOCK_ERRNO == EINPROGRESS ||", "#ifdef WIN32", "SOCK_ERRNO == EWOULDBLOCK ||", "#endif", "SOCK_ERRNO == EINTR)", "{", "conn->status = CONNECTION_STARTED;", "return PGRES_POLLING_WRITING;", "}", "}", "else", "{", "conn->status = CONNECTION_STARTED;", "goto keep_going;", "}", "connectFailureMessage(conn, SOCK_ERRNO);", "conn->try_next_addr = true;", "goto keep_going;", "}", "}", "case CONNECTION_STARTED:", "{", "ACCEPT_TYPE_ARG3 optlen = sizeof(optval);", "if (getsockopt(conn->sock, SOL_SOCKET, SO_ERROR,", "(char *) &optval, &optlen) == -1)", "{", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"could not get socket error status: %s\\n\"),", "SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));", "goto error_return;", "}", "else if (optval != 0)", "{", "connectFailureMessage(conn, optval);", "conn->try_next_addr = true;", "goto keep_going;", "}", "conn->laddr.salen = sizeof(conn->laddr.addr);", "if (getsockname(conn->sock,", "(struct sockaddr *) &conn->laddr.addr,", "&conn->laddr.salen) < 0)", "{", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"could not get client address from socket: %s\\n\"),", "SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));", "goto error_return;", "}", "conn->status = CONNECTION_MADE;", "return PGRES_POLLING_WRITING;", "}", "case CONNECTION_MADE:", "{", "char    *startpacket;", "int   packetlen;", "if (conn->requirepeer && conn->requirepeer[0] &&", "IS_AF_UNIX(conn->raddr.addr.ss_family))", "{", "#ifndef WIN32", "char  pwdbuf[BUFSIZ];", "struct passwd pass_buf;", "struct passwd *pass;", "int   passerr;", "#endif", "uid_t  uid;", "gid_t  gid;", "errno = 0;", "if (getpeereid(conn->sock, &uid, &gid) != 0)", "{", "if (errno == ENOSYS)", "appendPQExpBufferStr(&conn->errorMessage,", "libpq_gettext(\"requirepeer parameter is not supported on this platform\\n\"));", "else", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"could not get peer credentials: %s\\n\"),", "strerror_r(errno, sebuf, sizeof(sebuf)));", "goto error_return;", "}", "#ifndef WIN32", "passerr = pqGetpwuid(uid, &pass_buf, pwdbuf, sizeof(pwdbuf), &pass);", "if (pass == NULL)", "{", "if (passerr != 0)", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"could not look up local user ID %d: %s\\n\"),", "(int) uid,", "strerror_r(passerr, sebuf, sizeof(sebuf)));", "else", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"local user with ID %d does not exist\\n\"),", "(int) uid);", "goto error_return;", "}", "if (strcmp(pass->pw_name, conn->requirepeer) != 0)", "{", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"requirepeer specifies \\\"%s\\\", but actual peer user name is \\\"%s\\\"\\n\"),", "conn->requirepeer, pass->pw_name);", "goto error_return;", "}", "#else\t\t\t\t\t\t\t/* WIN32 */", "Assert(false);", "#endif\t\t\t\t\t\t\t/* WIN32 */", "}", "if (IS_AF_UNIX(conn->raddr.addr.ss_family))", "{", "#ifdef USE_SSL", "conn->allow_ssl_try = false;", "#endif", "#ifdef ENABLE_GSS", "conn->try_gss = false;", "#endif", "}", "#ifdef ENABLE_GSS", "if (conn->try_gss && !conn->gctx)", "conn->try_gss = pg_GSS_have_cred_cache(&conn->gcred);", "if (conn->try_gss && !conn->gctx)", "{", "ProtocolVersion pv = pg_hton32(NEGOTIATE_GSS_CODE);", "if (pqPacketSend(conn, 0, &pv, sizeof(pv)) != STATUS_OK)", "{", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"could not send GSSAPI negotiation packet: %s\\n\"),", "SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));", "goto error_return;", "}", "conn->status = CONNECTION_GSS_STARTUP;", "return PGRES_POLLING_READING;", "}", "else if (!conn->gctx && conn->gssencmode[0] == 'r')", "{", "appendPQExpBufferStr(&conn->errorMessage,", "libpq_gettext(\"GSSAPI encryption required but was impossible (possibly no credential cache, no server support, or using a local socket)\\n\"));", "goto error_return;", "}", "#endif", "#ifdef USE_SSL", "if (pqsecure_initialize(conn, false, true) < 0)", "goto error_return;", "if (conn->allow_ssl_try && !conn->wait_ssl_try &&", "!conn->ssl_in_use", "#ifdef ENABLE_GSS", "&& !conn->gssenc", "#endif", ")", "{", "ProtocolVersion pv;", "pv = pg_hton32(NEGOTIATE_SSL_CODE);", "if (pqPacketSend(conn, 0, &pv, sizeof(pv)) != STATUS_OK)", "{", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"could not send SSL negotiation packet: %s\\n\"),", "SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));", "goto error_return;", "}", "conn->status = CONNECTION_SSL_STARTUP;", "return PGRES_POLLING_READING;", "}", "#endif\t\t\t\t\t\t\t/* USE_SSL */", "startpacket = pqBuildStartupPacket3(conn, &packetlen,", "EnvironmentOptions);", "if (!startpacket)", "{", "appendPQExpBufferStr(&conn->errorMessage,", "libpq_gettext(\"out of memory\\n\"));", "goto error_return;", "}", "if (pqPacketSend(conn, 0, startpacket, packetlen) != STATUS_OK)", "{", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"could not send startup packet: %s\\n\"),", "SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));", "free(startpacket);", "goto error_return;", "}", "free(startpacket);", "conn->status = CONNECTION_AWAITING_RESPONSE;", "return PGRES_POLLING_READING;", "}", "case CONNECTION_SSL_STARTUP:", "{", "#ifdef USE_SSL", "PostgresPollingStatusType pollres;", "if (!conn->ssl_in_use)", "{", "char  SSLok;", "int   rdresult;", "rdresult = pqReadData(conn);", "if (rdresult < 0)", "{", "goto error_return;", "}", "if (rdresult == 0)", "{", "return PGRES_POLLING_READING;", "}", "if (pqGetc(&SSLok, conn) < 0)", "{", "return PGRES_POLLING_READING;", "}", "if (SSLok == 'S')", "{", "conn->inStart = conn->inCursor;", "if (pqsecure_initialize(conn, true, false) != 0)", "goto error_return;", "}", "else if (SSLok == 'N')", "{", "conn->inStart = conn->inCursor;", "if (conn->sslmode[0] == 'r' ||", "conn->sslmode[0] == 'v')", "{", "appendPQExpBufferStr(&conn->errorMessage,", "libpq_gettext(\"server does not support SSL, but SSL was required\\n\"));", "goto error_return;", "}", "conn->allow_ssl_try = false;", "conn->status = CONNECTION_MADE;", "return PGRES_POLLING_WRITING;", "}", "else if (SSLok == 'E')", "{", "conn->status = CONNECTION_AWAITING_RESPONSE;", "goto keep_going;", "}", "else", "{", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"received invalid response to SSL negotiation: %c\\n\"),", "SSLok);", "goto error_return;", "}", "}", "pollres = pqsecure_open_client(conn);", "if (pollres == PGRES_POLLING_OK)", "{", "conn->status = CONNECTION_MADE;", "return PGRES_POLLING_WRITING;", "}", "if (pollres == PGRES_POLLING_FAILED)", "{", "if (conn->sslmode[0] == 'p'", "&& conn->allow_ssl_try", "&& !conn->wait_ssl_try)", "{", "conn->allow_ssl_try = false;", "need_new_connection = true;", "goto keep_going;", "}", "goto error_return;", "}", "return pollres;", "#else\t\t\t\t\t\t\t/* !USE_SSL */", "goto error_return;", "#endif\t\t\t\t\t\t\t/* USE_SSL */", "}", "case CONNECTION_GSS_STARTUP:", "{", "#ifdef ENABLE_GSS", "PostgresPollingStatusType pollres;", "if (conn->try_gss && !conn->gctx)", "{", "char  gss_ok;", "int   rdresult = pqReadData(conn);", "if (rdresult < 0)", "goto error_return;", "else if (rdresult == 0)", "return PGRES_POLLING_READING;", "if (pqGetc(&gss_ok, conn) < 0)", "return PGRES_POLLING_READING;", "if (gss_ok == 'E')", "{", "conn->try_gss = false;", "need_new_connection = true;", "goto keep_going;", "}", "conn->inStart = conn->inCursor;", "if (gss_ok == 'N')", "{", "if (conn->gssencmode[0] == 'r')", "{", "appendPQExpBufferStr(&conn->errorMessage,", "libpq_gettext(\"server doesn't support GSSAPI encryption, but it was required\\n\"));", "goto error_return;", "}", "conn->try_gss = false;", "conn->status = CONNECTION_MADE;", "return PGRES_POLLING_WRITING;", "}", "else if (gss_ok != 'G')", "{", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"received invalid response to GSSAPI negotiation: %c\\n\"),", "gss_ok);", "goto error_return;", "}", "}", "pollres = pqsecure_open_gss(conn);", "if (pollres == PGRES_POLLING_OK)", "{", "conn->status = CONNECTION_MADE;", "return PGRES_POLLING_WRITING;", "}", "else if (pollres == PGRES_POLLING_FAILED &&", "conn->gssencmode[0] == 'p')", "{", "conn->try_gss = false;", "need_new_connection = true;", "goto keep_going;", "}", "return pollres;", "#else\t\t\t\t\t\t\t/* !ENABLE_GSS */", "goto error_return;", "#endif\t\t\t\t\t\t\t/* ENABLE_GSS */", "}", "case CONNECTION_AWAITING_RESPONSE:", "{", "char  beresp;", "int   msgLength;", "int   avail;", "AuthRequest areq;", "int   res;", "conn->inCursor = conn->inStart;", "if (pqGetc(&beresp, conn))", "{", "return PGRES_POLLING_READING;", "}", "if (!(beresp == 'R' || beresp == 'E'))", "{", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"expected authentication request from server, but received %c\\n\"),", "beresp);", "goto error_return;", "}", "if (pqGetInt(&msgLength, 4, conn))", "{", "return PGRES_POLLING_READING;", "}", "if (beresp == 'R' && (msgLength < 8 || msgLength > 2000))", "{", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"expected authentication request from server, but received %c\\n\"),", "beresp);", "goto error_return;", "}", "if (beresp == 'E' && (msgLength < 8 || msgLength > 30000))", "{", "conn->inCursor = conn->inStart + 1;", "if (pqGets_append(&conn->errorMessage, conn))", "{", "return PGRES_POLLING_READING;", "}", "conn->inStart = conn->inCursor;", "if (conn->errorMessage.len == 0 ||", "conn->errorMessage.data[conn->errorMessage.len - 1] != '\\n')", "{", "appendPQExpBufferChar(&conn->errorMessage, '\\n');", "}", "goto error_return;", "}", "msgLength -= 4;", "avail = conn->inEnd - conn->inCursor;", "if (avail < msgLength)", "{", "if (pqCheckInBufferSpace(conn->inCursor + (size_t) msgLength,", "conn))", "goto error_return;", "return PGRES_POLLING_READING;", "}", "if (beresp == 'E')", "{", "if (pqGetErrorNotice3(conn, true))", "{", "return PGRES_POLLING_READING;", "}", "conn->inStart = conn->inCursor;", "if (strcmp(conn->last_sqlstate,", "ERRCODE_CANNOT_CONNECT_NOW) == 0)", "{", "conn->try_next_host = true;", "goto keep_going;", "}", "pgpassfileWarning(conn);", "#ifdef ENABLE_GSS", "if (conn->gssenc && conn->gssencmode[0] == 'p')", "{", "conn->try_gss = false;", "need_new_connection = true;", "goto keep_going;", "}", "#endif", "#ifdef USE_SSL", "if (conn->sslmode[0] == 'a'", "&& !conn->ssl_in_use", "&& conn->allow_ssl_try", "&& conn->wait_ssl_try)", "{", "conn->wait_ssl_try = false;", "need_new_connection = true;", "goto keep_going;", "}", "if (conn->sslmode[0] == 'p'", "&& conn->ssl_in_use", "&& conn->allow_ssl_try", "&& !conn->wait_ssl_try)", "{", "conn->allow_ssl_try = false;", "need_new_connection = true;", "goto keep_going;", "}", "#endif", "goto error_return;", "}", "conn->auth_req_received = true;", "if (pqGetInt((int *) &areq, 4, conn))", "{", "return PGRES_POLLING_READING;", "}", "msgLength -= 4;", "res = pg_fe_sendauth(areq, msgLength, conn);", "conn->inStart = conn->inCursor;", "if (res != STATUS_OK)", "goto error_return;", "if (pqFlush(conn))", "goto error_return;", "if (areq == AUTH_REQ_OK)", "{", "conn->status = CONNECTION_AUTH_OK;", "conn->asyncStatus = PGASYNC_BUSY;", "}", "goto keep_going;", "}", "case CONNECTION_AUTH_OK:", "{", "if (PQisBusy(conn))", "return PGRES_POLLING_READING;", "res = PQgetResult(conn);", "if (res)", "{", "if (res->resultStatus != PGRES_FATAL_ERROR)", "appendPQExpBufferStr(&conn->errorMessage,", "libpq_gettext(\"unexpected message from server during startup\\n\"));", "else if (conn->send_appname &&", "(conn->appname || conn->fbappname))", "{", "const char *sqlstate;", "sqlstate = PQresultErrorField(res, PG_DIAG_SQLSTATE);", "if (sqlstate &&", "strcmp(sqlstate, ERRCODE_APPNAME_UNKNOWN) == 0)", "{", "PQclear(res);", "conn->send_appname = false;", "need_new_connection = true;", "goto keep_going;", "}", "}", "if (conn->errorMessage.len <= 0 ||", "conn->errorMessage.data[conn->errorMessage.len - 1] != '\\n')", "appendPQExpBufferChar(&conn->errorMessage, '\\n');", "PQclear(res);", "goto error_return;", "}", "conn->status = CONNECTION_CHECK_TARGET;", "goto keep_going;", "}", "case CONNECTION_CHECK_TARGET:", "{", "if (conn->target_server_type == SERVER_TYPE_READ_WRITE ||", "conn->target_server_type == SERVER_TYPE_READ_ONLY)", "{", "bool  read_only_server;", "if (conn->default_transaction_read_only == PG_BOOL_UNKNOWN ||", "conn->in_hot_standby == PG_BOOL_UNKNOWN)", "{", "conn->status = CONNECTION_OK;", "if (!PQsendQueryContinue(conn,", "\"SHOW transaction_read_only\"))", "goto error_return;", "conn->status = CONNECTION_CHECK_WRITABLE;", "return PGRES_POLLING_READING;", "}", "read_only_server =", "(conn->default_transaction_read_only == PG_BOOL_YES ||", "conn->in_hot_standby == PG_BOOL_YES);", "if ((conn->target_server_type == SERVER_TYPE_READ_WRITE) ?", "read_only_server : !read_only_server)", "{", "if (conn->target_server_type == SERVER_TYPE_READ_WRITE)", "appendPQExpBufferStr(&conn->errorMessage,", "libpq_gettext(\"session is read-only\\n\"));", "else", "appendPQExpBufferStr(&conn->errorMessage,", "libpq_gettext(\"session is not read-only\\n\"));", "conn->status = CONNECTION_OK;", "sendTerminateConn(conn);", "conn->try_next_host = true;", "goto keep_going;", "}", "}", "else if (conn->target_server_type == SERVER_TYPE_PRIMARY ||", "conn->target_server_type == SERVER_TYPE_STANDBY ||", "conn->target_server_type == SERVER_TYPE_PREFER_STANDBY)", "{", "if (conn->sversion < 90000)", "conn->in_hot_standby = PG_BOOL_NO;", "if (conn->in_hot_standby == PG_BOOL_UNKNOWN)", "{", "conn->status = CONNECTION_OK;", "if (!PQsendQueryContinue(conn,", "\"SELECT pg_catalog.pg_is_in_recovery()\"))", "goto error_return;", "conn->status = CONNECTION_CHECK_STANDBY;", "return PGRES_POLLING_READING;", "}", "if ((conn->target_server_type == SERVER_TYPE_PRIMARY) ?", "(conn->in_hot_standby == PG_BOOL_YES) :", "(conn->in_hot_standby == PG_BOOL_NO))", "{", "if (conn->target_server_type == SERVER_TYPE_PRIMARY)", "appendPQExpBufferStr(&conn->errorMessage,", "libpq_gettext(\"server is in hot standby mode\\n\"));", "else", "appendPQExpBufferStr(&conn->errorMessage,", "libpq_gettext(\"server is not in hot standby mode\\n\"));", "conn->status = CONNECTION_OK;", "sendTerminateConn(conn);", "conn->try_next_host = true;", "goto keep_going;", "}", "}", "release_conn_addrinfo(conn);", "resetPQExpBuffer(&conn->errorMessage);", "conn->status = CONNECTION_OK;", "return PGRES_POLLING_OK;", "}", "case CONNECTION_CONSUME:", "{", "conn->status = CONNECTION_OK;", "if (!PQconsumeInput(conn))", "goto error_return;", "if (PQisBusy(conn))", "{", "conn->status = CONNECTION_CONSUME;", "return PGRES_POLLING_READING;", "}", "res = PQgetResult(conn);", "if (res != NULL)", "{", "PQclear(res);", "conn->status = CONNECTION_CONSUME;", "return PGRES_POLLING_READING;", "}", "conn->status = CONNECTION_CHECK_TARGET;", "goto keep_going;", "}", "case CONNECTION_CHECK_WRITABLE:", "{", "conn->status = CONNECTION_OK;", "if (!PQconsumeInput(conn))", "goto error_return;", "if (PQisBusy(conn))", "{", "conn->status = CONNECTION_CHECK_WRITABLE;", "return PGRES_POLLING_READING;", "}", "res = PQgetResult(conn);", "if (res && PQresultStatus(res) == PGRES_TUPLES_OK &&", "PQntuples(res) == 1)", "{", "char    *val = PQgetvalue(res, 0, 0);", "if (strncmp(val, \"on\", 2) == 0)", "{", "conn->default_transaction_read_only = PG_BOOL_YES;", "conn->in_hot_standby = PG_BOOL_YES;", "}", "else", "{", "conn->default_transaction_read_only = PG_BOOL_NO;", "conn->in_hot_standby = PG_BOOL_NO;", "}", "PQclear(res);", "conn->status = CONNECTION_CONSUME;", "goto keep_going;", "}", "if (res)", "PQclear(res);", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"\\\"%s\\\" failed\\n\"),", "\"SHOW transaction_read_only\");", "conn->status = CONNECTION_OK;", "sendTerminateConn(conn);", "conn->try_next_host = true;", "goto keep_going;", "}", "case CONNECTION_CHECK_STANDBY:", "{", "conn->status = CONNECTION_OK;", "if (!PQconsumeInput(conn))", "goto error_return;", "if (PQisBusy(conn))", "{", "conn->status = CONNECTION_CHECK_STANDBY;", "return PGRES_POLLING_READING;", "}", "res = PQgetResult(conn);", "if (res && PQresultStatus(res) == PGRES_TUPLES_OK &&", "PQntuples(res) == 1)", "{", "char    *val = PQgetvalue(res, 0, 0);", "if (strncmp(val, \"t\", 1) == 0)", "conn->in_hot_standby = PG_BOOL_YES;", "else", "conn->in_hot_standby = PG_BOOL_NO;", "PQclear(res);", "conn->status = CONNECTION_CONSUME;", "goto keep_going;", "}", "if (res)", "PQclear(res);", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"\\\"%s\\\" failed\\n\"),", "\"SELECT pg_is_in_recovery()\");", "conn->status = CONNECTION_OK;", "sendTerminateConn(conn);", "conn->try_next_host = true;", "goto keep_going;", "}", "default:", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"invalid connection state %d, \"", "\"probably indicative of memory corruption\\n\"),", "conn->status);", "goto error_return;", "}", "error_return:", "conn->status = CONNECTION_BAD;", "return PGRES_POLLING_FAILED;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void pointZZ_pAdd(PointZZ_p * rop, const PointZZ_p * op1, const PointZZ_p * op2, const CurveZZ_p * curve) {", "mpz_t xdiff, ydiff, lambda;", "mpz_inits(xdiff, ydiff, lambda, NULL);", "mpz_sub(ydiff, op2->y, op1->y);", "mpz_sub(xdiff, op2->x, op1->x);", "mpz_invert(xdiff, xdiff, curve->p);", "mpz_mul(lambda, ydiff, xdiff);", "mpz_mod(lambda, lambda, curve->p);", "mpz_mul(rop->x, lambda, lambda);", "mpz_sub(rop->x, rop->x, op1->x);", "mpz_sub(rop->x, rop->x, op2->x);", "mpz_mod(rop->x, rop->x, curve->p);", "mpz_sub(rop->y, op1->x, rop->x);", "mpz_mul(rop->y, lambda, rop->y);", "mpz_sub(rop->y, rop->y, op1->y);", "mpz_mod(rop->y, rop->y, curve->p);", "mpz_clears(xdiff, ydiff, lambda, NULL);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["void jsvAddName(JsVar *parent, JsVar *namedChild) {", "namedChild = jsvRef(namedChild);", "assert(jsvIsName(namedChild));", "if (jsvIsArray(parent) && jsvIsInt(namedChild)) {", "JsVarInt index = namedChild->varData.integer;", "if (index >= jsvGetArrayLength(parent)) {", "jsvSetArrayLength(parent, index + 1, false);", "}", "}", "if (jsvGetLastChild(parent)) {", "JsVar *insertAfter = jsvLock(jsvGetLastChild(parent));", "if (jsvIsArray(parent)) {", "while (insertAfter && jsvCompareInteger(namedChild, insertAfter)<0) {", "JsVarRef prev = jsvGetPrevSibling(insertAfter);", "jsvUnLock(insertAfter);", "insertAfter = jsvLockSafe(prev);", "}", "}", "if (insertAfter) {", "if (jsvGetNextSibling(insertAfter)) {", "JsVar *insertBefore = jsvLock(jsvGetNextSibling(insertAfter));", "jsvSetPrevSibling(insertBefore, jsvGetRef(namedChild));", "jsvSetNextSibling(namedChild, jsvGetRef(insertBefore));", "jsvUnLock(insertBefore);", "} else {", "jsvSetLastChild(parent, jsvGetRef(namedChild));", "}", "jsvSetNextSibling(insertAfter, jsvGetRef(namedChild));", "jsvSetPrevSibling(namedChild, jsvGetRef(insertAfter));", "jsvUnLock(insertAfter);", "} else {", "JsVar *firstChild = jsvLock(jsvGetFirstChild(parent));", "jsvSetPrevSibling(firstChild, jsvGetRef(namedChild));", "jsvUnLock(firstChild);", "jsvSetNextSibling(namedChild, jsvGetFirstChild(parent));", "jsvSetFirstChild(parent, jsvGetRef(namedChild));", "}", "} else {", "JsVarRef r = jsvGetRef(namedChild);", "jsvSetFirstChild(parent, r);", "jsvSetLastChild(parent, r);", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["GF_Err abst_box_read(GF_Box *s, GF_BitStream *bs)", "{", "GF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;", "int i;", "u32 tmp_strsize;", "char *tmp_str;", "GF_Err e;", "ISOM_DECREASE_SIZE(ptr, 25)", "ptr->bootstrapinfo_version = gf_bs_read_u32(bs);", "ptr->profile = gf_bs_read_int(bs, 2);", "ptr->live = gf_bs_read_int(bs, 1);", "ptr->update = gf_bs_read_int(bs, 1);", "ptr->reserved = gf_bs_read_int(bs, 4);", "ptr->time_scale = gf_bs_read_u32(bs);", "ptr->current_media_time = gf_bs_read_u64(bs);", "ptr->smpte_time_code_offset = gf_bs_read_u64(bs);", "i=0;", "if (ptr->size<8) return GF_ISOM_INVALID_FILE;", "tmp_strsize =(u32)ptr->size;", "tmp_str = gf_malloc(sizeof(char)*tmp_strsize);", "if (!tmp_str) return GF_OUT_OF_MEM;", "memset(tmp_str, 0, sizeof(char)*tmp_strsize);", "while (tmp_strsize) {", "ISOM_DECREASE_SIZE(ptr, 1)", "tmp_str[i] = gf_bs_read_u8(bs);", "tmp_strsize--;", "if (!tmp_str[i])", "break;", "i++;", "}", "if (i) {", "ptr->movie_identifier = gf_strdup(tmp_str);", "}", "ISOM_DECREASE_SIZE(ptr, 1)", "ptr->server_entry_count = gf_bs_read_u8(bs);", "for (i=0; i<ptr->server_entry_count; i++) {", "int j=0;", "tmp_strsize=(u32)ptr->size;", "while (tmp_strsize) {", "ISOM_DECREASE_SIZE(ptr, 1)", "tmp_str[j] = gf_bs_read_u8(bs);", "tmp_strsize--;", "if (!tmp_str[j])", "break;", "j++;", "}", "if (j) {", "gf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);", "}", "}", "ISOM_DECREASE_SIZE(ptr, 1)", "ptr->quality_entry_count = gf_bs_read_u8(bs);", "for (i=0; i<ptr->quality_entry_count; i++) {", "int j=0;", "tmp_strsize=(u32)ptr->size;", "while (tmp_strsize) {", "ISOM_DECREASE_SIZE(ptr, 1)", "tmp_str[j] = gf_bs_read_u8(bs);", "tmp_strsize--;", "if (!tmp_str[j])", "break;", "j++;", "}", "if (j) {", "gf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);", "}", "}", "i=0;", "tmp_strsize=(u32)ptr->size;", "while (tmp_strsize) {", "ISOM_DECREASE_SIZE(ptr, 1)", "tmp_str[i] = gf_bs_read_u8(bs);", "tmp_strsize--;", "if (!tmp_str[i])", "break;", "i++;", "}", "if (i) {", "ptr->drm_data = gf_strdup(tmp_str);", "}", "i=0;", "tmp_strsize=(u32)ptr->size;", "while (tmp_strsize) {", "ISOM_DECREASE_SIZE(ptr, 1)", "tmp_str[i] = gf_bs_read_u8(bs);", "tmp_strsize--;", "if (!tmp_str[i])", "break;", "i++;", "}", "if (i) {", "ptr->meta_data = gf_strdup(tmp_str);", "}", "ISOM_DECREASE_SIZE(ptr, 1)", "ptr->segment_run_table_count = gf_bs_read_u8(bs);", "for (i=0; i<ptr->segment_run_table_count; i++) {", "GF_AdobeSegmentRunTableBox *asrt = NULL;", "e = gf_isom_box_parse((GF_Box **)&asrt, bs);", "if (e) {", "if (asrt) gf_isom_box_del((GF_Box*)asrt);", "gf_free(tmp_str);", "return e;", "}", "gf_list_add(ptr->segment_run_table_entries, asrt);", "}", "ISOM_DECREASE_SIZE(ptr, 1)", "ptr->fragment_run_table_count = gf_bs_read_u8(bs);", "for (i=0; i<ptr->fragment_run_table_count; i++) {", "GF_AdobeFragmentRunTableBox *afrt = NULL;", "e = gf_isom_box_parse((GF_Box **)&afrt, bs);", "if (e) {", "if (afrt) gf_isom_box_del((GF_Box*)afrt);", "gf_free(tmp_str);", "return e;", "}", "gf_list_add(ptr->fragment_run_table_entries, afrt);", "}", "gf_free(tmp_str);", "return GF_OK;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["u32 gf_bs_read_ue_log_idx3(GF_BitStream *bs, const char *fname, s32 idx1, s32 idx2, s32 idx3)", "{", "u32 val=0, code;", "s32 nb_lead = -1;", "u32 bits = 0;", "for (code=0; !code; nb_lead++) {", "if (nb_lead>=32) {", "if (!gf_bs_available(bs)) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Core] exp-golomb read failed, not enough bits in bitstream !\\n\"));", "} else {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Core] corrupted exp-golomb code, %d leading zeros, max 31 allowed !\\n\", nb_lead));", "}", "return 0;", "}", "code = gf_bs_read_int(bs, 1);", "bits++;", "}", "if (nb_lead) {", "val = gf_bs_read_int(bs, nb_lead);", "val += (1 << nb_lead) - 1;", "bits += nb_lead;", "}", "if (fname) {", "gf_bs_log_idx(bs, bits, fname, val, idx1, idx2, idx3);", "}", "return val;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static char *parse_note(char *p,", "int flags)", "{", "struct SYMBOL *s;", "char *q;", "int pit = 0, len, acc, nostem, chord, j, m, n;", "if (flags & ABC_F_GRACE) {", "s = abc_new(ABC_T_NOTE, NULL);", "} else {", "s = abc_new(ABC_T_NOTE, gchord);", "if (gchord)", "gchord = NULL;", "}", "s->flags |= flags;", "s->u.note.notes[0].color = -1;", "if (!lyric_started) {", "lyric_started = 1;", "s->flags |= ABC_F_LYRIC_START;", "}", "if (*p != 'X' && *p != 'Z'", "&& !(flags & ABC_F_GRACE)) {", "if (!deco_start)", "deco_start = s;", "}", "chord = 0;", "switch (*p) {", "case 'X':", "s->flags |= ABC_F_INVIS;", "case 'Z':", "s->abc_type = ABC_T_MREST;", "p++;", "len = 1;", "if (isdigit((unsigned char) *p)) {", "len = strtol(p, &q, 10);", "if (len == 0 || len > 100) {", "syntax(\"Bad number of measures\", p);", "len = 1;", "}", "p = q;", "}", "s->u.bar.type = 0;", "s->u.bar.len = len;", "goto add_deco;", "case 'y':", "s->abc_type = ABC_T_REST;", "s->flags |= ABC_F_INVIS;", "p++;", "if (isdigit((unsigned char) *p)", "|| *p == '-') {", "s->u.note.notes[0].shhd = strtol(p, &q, 10);", "p = q;", "} else {", "s->u.note.notes[0].shhd = 10;", "}", "goto add_deco;", "case 'x':", "s->flags |= ABC_F_INVIS;", "case 'z':", "s->abc_type = ABC_T_REST;", "p = parse_len(p + 1, ulen, &len);", "s->u.note.notes[0].len = len;", "goto do_brhythm;", "case '[':", "chord = 1;", "p++;", "break;", "}", "q = p;", "m = 0;", "nostem = 0;", "for (;;) {", "if (chord) {", "if (m >= MAXHD) {", "syntax(\"Too many notes in chord\", p);", "m--;", "}", "n = 0;", "if (*p == '.') {", "n = SL_DOTTED;", "p++;", "}", "if (*p == '(') {", "p++;", "switch (*p) {", "case '\\'':", "n += SL_ABOVE;", "p++;", "break;", "case ',':", "n += SL_BELOW;", "p++;", "break;", "default:", "n += SL_AUTO;", "break;", "}", "s->u.note.notes[m].sl1 = (s->u.note.notes[m].sl1 << 3)", "+ n;", "}", "}", "p = parse_deco(p, &dc, m);", "p = parse_acc_pit(p, &pit, &acc);", "if (*p == '0') {", "nostem = 1;", "p++;", "}", "p = parse_len(p, (flags & ABC_F_GRACE) ?", "BASE_LEN / 8 :", "ulen,", "&len);", "s->u.note.notes[m].pit = pit;", "s->pits[m] = pit;", "s->u.note.notes[m].len = len;", "s->u.note.notes[m].acc = acc;", "s->u.note.notes[m].color = -1;", "if (chord) {", "for (;;) {", "if (*p == '.') {", "if (p[1] != '-')", "break;", "p++;", "}", "if (*p == '-') {", "switch (p[1]) {", "case '\\'':", "s->u.note.notes[m].ti1 = SL_ABOVE;", "p++;", "break;", "case ',':", "s->u.note.notes[m].ti1 = SL_BELOW;", "p++;", "break;", "default:", "s->u.note.notes[m].ti1 = SL_AUTO;", "break;", "}", "} else if (*p == ')') {", "s->u.note.notes[m].sl2++;", "} else {", "break;", "}", "p++;", "}", "}", "if (acc >= 0)", "m++;", "if (!chord)", "break;", "if (*p == ']') {", "p++;", "if (*p == '0') {", "nostem = 1;", "p++;", "}", "if (*p == '/' || isdigit((unsigned char) *p)) {", "p = parse_len(p, ulen, &len);", "for (j = 0; j < m; j++) {", "s->u.note.notes[j].len =", "len * s->u.note.notes[j].len / ulen;", "}", "}", "break;", "}", "if (*p == '\\0') {", "syntax(\"Chord not closed\", q);", "break;", "}", "}", "if (nostem)", "s->flags |= ABC_F_STEMLESS;", "if (m == 0)", "goto err;", "s->u.note.microscale = microscale;", "s->nhd = m - 1;", "do_brhythm:", "if (curvoice->last_note", "&& curvoice->last_note->u.note.brhythm != 0)", "broken_rhythm(s, -curvoice->last_note->u.note.brhythm);", "add_deco:", "if (dc.n > 0) {", "memcpy(s->abc_type != ABC_T_MREST ? &s->u.note.dc", ": &s->u.bar.dc,", "&dc, sizeof dc);", "dc.n = 0;", "}", "if (s->abc_type != ABC_T_NOTE && (flags & ABC_F_GRACE)) {", "syntax(\"Not a note in grace note sequence\", p);", "goto err;", "}", "return p;", "err:", "if ((parse.last_sym = s->abc_prev) == NULL) {", "parse.first_sym = NULL;", "} else {", "s->abc_prev->abc_next = NULL;", "s->abc_prev->flags |= (s->flags & ABC_F_ERROR);", "}", "return p;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int insert_pin(", "sc_pkcs15_card_t *p15card,", "const char       *path,", "unsigned char     id,", "unsigned char     auth_id,", "unsigned char     pin_reference,", "int               min_length,", "const char       *label,", "int               pin_flags", "){", "sc_card_t *card=p15card->card;", "sc_context_t *ctx=p15card->card->ctx;", "sc_file_t *f = NULL;", "struct sc_pkcs15_auth_info pin_info;", "struct sc_pkcs15_object pin_obj;", "int r;", "memset(&pin_info, 0, sizeof(pin_info));", "pin_info.auth_id.len      = 1;", "pin_info.auth_id.value[0] = id;", "pin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;", "pin_info.attrs.pin.reference        = pin_reference;", "pin_info.attrs.pin.flags            = pin_flags;", "pin_info.attrs.pin.type             = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;", "pin_info.attrs.pin.min_length       = min_length;", "pin_info.attrs.pin.stored_length    = 16;", "pin_info.attrs.pin.max_length       = 16;", "pin_info.attrs.pin.pad_char         = '\\0';", "pin_info.logged_in = SC_PIN_STATE_UNKNOWN;", "sc_format_path(path, &pin_info.path);", "memset(&pin_obj, 0, sizeof(pin_obj));", "strlcpy(pin_obj.label, label, sizeof(pin_obj.label));", "pin_obj.flags            = SC_PKCS15_CO_FLAG_MODIFIABLE | SC_PKCS15_CO_FLAG_PRIVATE;", "pin_obj.auth_id.len      = auth_id ? 0 : 1;", "pin_obj.auth_id.value[0] = auth_id;", "if(card->type == SC_CARD_TYPE_TCOS_V3) {", "unsigned char buf[256];", "int i, rec_no=0;", "if (pin_info.path.len >= 2) {", "pin_info.path.len -= 2;", "}", "sc_append_file_id(&pin_info.path, 0x5049);", "if (sc_select_file(card, &pin_info.path, NULL) != SC_SUCCESS) {", "sc_log(ctx,", "\"Select(%s) failed\\n\",", "sc_print_path(&pin_info.path));", "return 1;", "}", "sc_log(ctx,", "\"Searching for PIN-Ref %02X\\n\", pin_reference);", "while ((r = sc_read_record(card, ++rec_no, buf, sizeof(buf), SC_RECORD_BY_REC_NR)) > 0) {", "int found = 0, fbz = -1;", "if (buf[0] != 0xA0)", "continue;", "for (i = 2; i < buf[1] + 2; i += 2 + buf[i + 1]) {", "if (buf[i] == 0x83 && buf[i + 1] == 1 && buf[i + 2] == pin_reference) {", "++found;", "}", "if (buf[i] == 0x90) {", "fbz = buf[i + 1 + buf[i + 1]];", "}", "}", "if (found) {", "pin_info.tries_left = fbz;", "break;", "}", "}", "if (r <= 0) {", "sc_log(ctx, \"No EF_PWDD-Record found\\n\");", "return 1;", "}", "} else {", "if (sc_select_file(card, &pin_info.path, &f) != SC_SUCCESS", "|| !f->prop_attr || f->prop_attr_len < 4){", "sc_log(ctx, \"Select(%s) failed\\n\", path);", "sc_file_free(f);", "return 1;", "}", "pin_info.tries_left = f->prop_attr[3];", "sc_file_free(f);", "}", "r=sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);", "if(r!=SC_SUCCESS){", "sc_log(ctx,  \"sc_pkcs15emu_add_pin_obj(%s) failed\\n\", path);", "return 4;", "}", "sc_log(ctx,  \"%s: OK, FBZ=%d\\n\", path, pin_info.tries_left);", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["int __close_fd_get_file(unsigned int fd, struct file **res)", "{", "struct files_struct *files = current->files;", "struct file *file;", "struct fdtable *fdt;", "spin_lock(&files->file_lock);", "fdt = files_fdtable(files);", "if (fd >= fdt->max_fds)", "goto out_unlock;", "file = fdt->fd[fd];", "if (!file)", "goto out_unlock;", "rcu_assign_pointer(fdt->fd[fd], NULL);", "__put_unused_fd(files, fd);", "spin_unlock(&files->file_lock);", "get_file(file);", "*res = file;", "return filp_close(file, files);", "out_unlock:", "spin_unlock(&files->file_lock);", "*res = NULL;", "return -ENOENT;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["static int dwa_uncompress(EXRContext *s, const uint8_t *src, int compressed_size,", "int uncompressed_size, EXRThreadData *td)", "{", "int64_t version, lo_usize, lo_size;", "int64_t ac_size, dc_size, rle_usize, rle_csize, rle_raw_size;", "int64_t ac_count, dc_count, ac_compression;", "const int dc_w = td->xsize >> 3;", "const int dc_h = td->ysize >> 3;", "GetByteContext gb, agb;", "int skip, ret;", "if (compressed_size <= 88)", "return AVERROR_INVALIDDATA;", "version = AV_RL64(src + 0);", "if (version != 2)", "return AVERROR_INVALIDDATA;", "lo_usize = AV_RL64(src + 8);", "lo_size = AV_RL64(src + 16);", "ac_size = AV_RL64(src + 24);", "dc_size = AV_RL64(src + 32);", "rle_csize = AV_RL64(src + 40);", "rle_usize = AV_RL64(src + 48);", "rle_raw_size = AV_RL64(src + 56);", "ac_count = AV_RL64(src + 64);", "dc_count = AV_RL64(src + 72);", "ac_compression = AV_RL64(src + 80);", "if (compressed_size < 88LL + lo_size + ac_size + dc_size + rle_csize)", "return AVERROR_INVALIDDATA;", "bytestream2_init(&gb, src + 88, compressed_size - 88);", "skip = bytestream2_get_le16(&gb);", "if (skip < 2)", "return AVERROR_INVALIDDATA;", "bytestream2_skip(&gb, skip - 2);", "if (lo_size > 0) {", "if (lo_usize > uncompressed_size)", "return AVERROR_INVALIDDATA;", "bytestream2_skip(&gb, lo_size);", "}", "if (ac_size > 0) {", "unsigned long dest_len = ac_count * 2LL;", "GetByteContext agb = gb;", "if (ac_count > 3LL * td->xsize * s->scan_lines_per_block)", "return AVERROR_INVALIDDATA;", "av_fast_padded_malloc(&td->ac_data, &td->ac_size, dest_len);", "if (!td->ac_data)", "return AVERROR(ENOMEM);", "switch (ac_compression) {", "case 0:", "ret = huf_uncompress(s, td, &agb, (int16_t *)td->ac_data, ac_count);", "if (ret < 0)", "return ret;", "break;", "case 1:", "if (uncompress(td->ac_data, &dest_len, agb.buffer, ac_size) != Z_OK ||", "dest_len != ac_count * 2LL)", "return AVERROR_INVALIDDATA;", "break;", "default:", "return AVERROR_INVALIDDATA;", "}", "bytestream2_skip(&gb, ac_size);", "}", "if (dc_size > 0) {", "unsigned long dest_len = dc_count * 2LL;", "GetByteContext agb = gb;", "if (dc_count > (6LL * td->xsize * td->ysize + 63) / 64)", "return AVERROR_INVALIDDATA;", "av_fast_padded_malloc(&td->dc_data, &td->dc_size, FFALIGN(dest_len, 64) * 2);", "if (!td->dc_data)", "return AVERROR(ENOMEM);", "if (uncompress(td->dc_data + FFALIGN(dest_len, 64), &dest_len, agb.buffer, dc_size) != Z_OK ||", "(dest_len != dc_count * 2LL))", "return AVERROR_INVALIDDATA;", "s->dsp.predictor(td->dc_data + FFALIGN(dest_len, 64), dest_len);", "s->dsp.reorder_pixels(td->dc_data, td->dc_data + FFALIGN(dest_len, 64), dest_len);", "bytestream2_skip(&gb, dc_size);", "}", "if (rle_raw_size > 0 && rle_csize > 0 && rle_usize > 0) {", "unsigned long dest_len = rle_usize;", "av_fast_padded_malloc(&td->rle_data, &td->rle_size, rle_usize);", "if (!td->rle_data)", "return AVERROR(ENOMEM);", "av_fast_padded_malloc(&td->rle_raw_data, &td->rle_raw_size, rle_raw_size);", "if (!td->rle_raw_data)", "return AVERROR(ENOMEM);", "if (uncompress(td->rle_data, &dest_len, gb.buffer, rle_csize) != Z_OK ||", "(dest_len != rle_usize))", "return AVERROR_INVALIDDATA;", "ret = rle(td->rle_raw_data, td->rle_data, rle_usize, rle_raw_size);", "if (ret < 0)", "return ret;", "bytestream2_skip(&gb, rle_csize);", "}", "bytestream2_init(&agb, td->ac_data, ac_count * 2);", "for (int y = 0; y < td->ysize; y += 8) {", "for (int x = 0; x < td->xsize; x += 8) {", "memset(td->block, 0, sizeof(td->block));", "for (int j = 0; j < 3; j++) {", "float *block = td->block[j];", "const int idx = (x >> 3) + (y >> 3) * dc_w + dc_w * dc_h * j;", "uint16_t *dc = (uint16_t *)td->dc_data;", "union av_intfloat32 dc_val;", "dc_val.i = half2float(dc[idx], s->mantissatable,", "s->exponenttable, s->offsettable);", "block[0] = dc_val.f;", "ac_uncompress(s, &agb, block);", "dct_inverse(block);", "}", "{", "const float scale = s->pixel_type == EXR_FLOAT ? 2.f : 1.f;", "const int o = s->nb_channels == 4;", "float *bo = ((float *)td->uncompressed_data) +", "y * td->xsize * s->nb_channels + td->xsize * (o + 0) + x;", "float *go = ((float *)td->uncompressed_data) +", "y * td->xsize * s->nb_channels + td->xsize * (o + 1) + x;", "float *ro = ((float *)td->uncompressed_data) +", "y * td->xsize * s->nb_channels + td->xsize * (o + 2) + x;", "float *yb = td->block[0];", "float *ub = td->block[1];", "float *vb = td->block[2];", "for (int yy = 0; yy < 8; yy++) {", "for (int xx = 0; xx < 8; xx++) {", "const int idx = xx + yy * 8;", "convert(yb[idx], ub[idx], vb[idx], &bo[xx], &go[xx], &ro[xx]);", "bo[xx] = to_linear(bo[xx], scale);", "go[xx] = to_linear(go[xx], scale);", "ro[xx] = to_linear(ro[xx], scale);", "}", "bo += td->xsize * s->nb_channels;", "go += td->xsize * s->nb_channels;", "ro += td->xsize * s->nb_channels;", "}", "}", "}", "}", "if (s->nb_channels < 4)", "return 0;", "for (int y = 0; y < td->ysize && td->rle_raw_data; y++) {", "uint32_t *ao = ((uint32_t *)td->uncompressed_data) + y * td->xsize * s->nb_channels;", "uint8_t *ai0 = td->rle_raw_data + y * td->xsize;", "uint8_t *ai1 = td->rle_raw_data + y * td->xsize + rle_raw_size / 2;", "for (int x = 0; x < td->xsize; x++) {", "uint16_t ha = ai0[x] | (ai1[x] << 8);", "ao[x] = half2float(ha, s->mantissatable, s->exponenttable, s->offsettable);", "}", "}", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["xmlValidNormalizeAttributeValue(xmlDocPtr doc, xmlNodePtr elem,", "const xmlChar *name, const xmlChar *value) {", "xmlChar *ret, *dst;", "const xmlChar *src;", "xmlAttributePtr attrDecl = NULL;", "if (doc == NULL) return(NULL);", "if (elem == NULL) return(NULL);", "if (name == NULL) return(NULL);", "if (value == NULL) return(NULL);", "if ((elem->ns != NULL) && (elem->ns->prefix != NULL)) {", "xmlChar fn[50];", "xmlChar *fullname;", "fullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);", "if (fullname == NULL)", "return(NULL);", "if ((fullname != fn) && (fullname != elem->name))", "xmlFree(fullname);", "}", "attrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, name);", "if ((attrDecl == NULL) && (doc->extSubset != NULL))", "attrDecl = xmlGetDtdAttrDesc(doc->extSubset, elem->name, name);", "if (attrDecl == NULL)", "return(NULL);", "if (attrDecl->atype == XML_ATTRIBUTE_CDATA)", "return(NULL);", "ret = xmlStrdup(value);", "if (ret == NULL)", "return(NULL);", "src = value;", "dst = ret;", "while (*src == 0x20) src++;", "while (*src != 0) {", "if (*src == 0x20) {", "while (*src == 0x20) src++;", "if (*src != 0)", "*dst++ = 0x20;", "} else {", "*dst++ = *src++;", "}", "}", "*dst = 0;", "return(ret);", "}"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0]}
{"tokens": ["jbig2_image_compose(Jbig2Ctx *ctx, Jbig2Image *dst, Jbig2Image *src, int x, int y, Jbig2ComposeOp op)", "{", "uint32_t w, h;", "uint32_t shift;", "uint32_t leftbyte;", "uint8_t *ss;", "uint8_t *dd;", "uint8_t leftmask, rightmask;", "int early = x >= 0;", "int late;", "uint32_t bytewidth;", "uint32_t syoffset = 0;", "if (src == NULL)", "return 0;", "w = src->width;", "h = src->height;", "shift = (x & 7);", "ss = src->data - early;", "if (x < 0) {", "if (w < (uint32_t) -x)", "w = 0;", "else", "w += x;", "ss += (-x-1)>>3;", "x = 0;", "}", "if (y < 0) {", "if (h < (uint32_t) -y)", "h = 0;", "else", "h += y;", "syoffset = -y * src->stride;", "y = 0;", "}", "if ((uint32_t)x + w > dst->width)", "{", "if (dst->width < (uint32_t)x)", "w = 0;", "else", "w = dst->width - x;", "}", "if ((uint32_t)y + h > dst->height)", "{", "if (dst->height < (uint32_t)y)", "h = 0;", "else", "h = dst->height - y;", "}", "#ifdef JBIG2_DEBUG", "jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, \"compositing %dx%d at (%d, %d) after clipping\", w, h, x, y);", "#endif", "if ((w <= 0) || (h <= 0)) {", "#ifdef JBIG2_DEBUG", "jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, \"zero clipping region\");", "#endif", "return 0;", "}", "leftbyte = (uint32_t) x >> 3;", "dd = dst->data + y * dst->stride + leftbyte;", "bytewidth = (((uint32_t) x + w - 1) >> 3) - leftbyte + 1;", "leftmask = 255>>(x&7);", "rightmask = (((x+w)&7) == 0) ? 255 : ~(255>>((x+w)&7));", "if (bytewidth == 1)", "leftmask &= rightmask;", "late = (ss + bytewidth >= src->data + ((src->width+7)>>3));", "ss += syoffset;", "switch(op)", "{", "case JBIG2_COMPOSE_OR:", "jbig2_image_compose_opt_OR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);", "break;", "case JBIG2_COMPOSE_AND:", "jbig2_image_compose_opt_AND(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);", "break;", "case JBIG2_COMPOSE_XOR:", "jbig2_image_compose_opt_XOR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);", "break;", "case JBIG2_COMPOSE_XNOR:", "jbig2_image_compose_opt_XNOR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);", "break;", "case JBIG2_COMPOSE_REPLACE:", "jbig2_image_compose_opt_REPLACE(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);", "break;", "}", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["GF_Err gf_hinter_track_finalize(GF_RTPHinter *tkHint, Bool AddSystemInfo)", "{", "u32 Width, Height;", "GF_ESD *esd;", "char sdpLine[20000];", "char mediaName[30], payloadName[30];", "u32 mtype;", "Width = Height = 0;", "gf_isom_sdp_clean_track(tkHint->file, tkHint->TrackNum);", "mtype = gf_isom_get_media_type(tkHint->file, tkHint->TrackNum);", "if (gf_isom_is_video_handler_type(mtype))", "gf_isom_get_visual_info(tkHint->file, tkHint->TrackNum, 1, &Width, &Height);", "gf_rtp_builder_get_payload_name(tkHint->rtp_p, payloadName, mediaName);", "sprintf(sdpLine, \"m=%s 0 RTP/%s %d\", mediaName, tkHint->rtp_p->slMap.IV_length ? \"SAVP\" : \"AVP\", tkHint->rtp_p->PayloadType);", "gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);", "if (tkHint->bandwidth) {", "sprintf(sdpLine, \"b=AS:%d\", tkHint->bandwidth);", "gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);", "}", "if (tkHint->nb_chan) {", "sprintf(sdpLine, \"a=rtpmap:%d %s/%d/%d\", tkHint->rtp_p->PayloadType, payloadName, tkHint->rtp_p->sl_config.timestampResolution, tkHint->nb_chan);", "} else {", "sprintf(sdpLine, \"a=rtpmap:%d %s/%d\", tkHint->rtp_p->PayloadType, payloadName, tkHint->rtp_p->sl_config.timestampResolution);", "}", "gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);", "if (AddSystemInfo) {", "sprintf(sdpLine, \"a=mpeg4-esid:%d\", gf_isom_get_track_id(tkHint->file, tkHint->TrackNum));", "gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);", "}", "sprintf(sdpLine, \"a=control:trackID=%d\", gf_isom_get_track_id(tkHint->file, tkHint->HintTrack));", "gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);", "if (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_H263) {", "sprintf(sdpLine, \"a=cliprect:0,0,%d,%d\", Height, Width);", "gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);", "}", "else if ((tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_AMR) || (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_AMR_WB)) {", "sprintf(sdpLine, \"a=fmtp:%d octet-align=1\", tkHint->rtp_p->PayloadType);", "gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);", "}", "else if (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_3GPP_TEXT) {", "u32 w, h, i, m_w, m_h;", "s32 tx, ty;", "s16 l;", "gf_isom_get_track_layout_info(tkHint->file, tkHint->TrackNum, &w, &h, &tx, &ty, &l);", "m_w = w;", "m_h = h;", "for (i=0; i<gf_isom_get_track_count(tkHint->file); i++) {", "switch (gf_isom_get_media_type(tkHint->file, i+1)) {", "case GF_ISOM_MEDIA_SCENE:", "case GF_ISOM_MEDIA_VISUAL:", "case GF_ISOM_MEDIA_AUXV:", "case GF_ISOM_MEDIA_PICT:", "gf_isom_get_track_layout_info(tkHint->file, i+1, &w, &h, &tx, &ty, &l);", "if (w>m_w) m_w = w;", "if (h>m_h) m_h = h;", "break;", "default:", "break;", "}", "}", "gf_media_format_ttxt_sdp(tkHint->rtp_p, payloadName, sdpLine, w, h, tx, ty, l, m_w, m_h, NULL);", "strcat(sdpLine, \"; tx3g=\");", "for (i=0; i<gf_isom_get_sample_description_count(tkHint->file, tkHint->TrackNum); i++) {", "u8 *tx3g;", "char buffer[2000];", "u32 tx3g_len, len;", "gf_isom_text_get_encoded_tx3g(tkHint->file, tkHint->TrackNum, i+1, GF_RTP_TX3G_SIDX_OFFSET, &tx3g, &tx3g_len);", "len = gf_base64_encode(tx3g, tx3g_len, buffer, 2000);", "gf_free(tx3g);", "buffer[len] = 0;", "if (i) strcat(sdpLine, \", \");", "strcat(sdpLine, buffer);", "}", "gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);", "}", "else if ((tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_EVRC_SMV) && (tkHint->rtp_p->auh_size>1)) {", "sprintf(sdpLine, \"a=fmtp:%d maxptime=%d\", tkHint->rtp_p->PayloadType, tkHint->rtp_p->auh_size*20);", "gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);", "}", "else if ((tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_H264_AVC) || (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_H264_SVC))  {", "GF_AVCConfig *avcc = gf_isom_avc_config_get(tkHint->file, tkHint->TrackNum, 1);", "GF_AVCConfig *svcc = gf_isom_svc_config_get(tkHint->file, tkHint->TrackNum, 1);", "if (avcc) {", "sprintf(sdpLine, \"a=fmtp:%d profile-level-id=%02X%02X%02X; packetization-mode=1\", tkHint->rtp_p->PayloadType, avcc->AVCProfileIndication, avcc->profile_compatibility, avcc->AVCLevelIndication);", "} else {", "sprintf(sdpLine, \"a=fmtp:%d profile-level-id=%02X%02X%02X; packetization-mode=1\", tkHint->rtp_p->PayloadType, svcc->AVCProfileIndication, svcc->profile_compatibility, svcc->AVCLevelIndication);", "}", "write_avc_config(sdpLine, avcc, svcc);", "gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);", "gf_odf_avc_cfg_del(avcc);", "gf_odf_avc_cfg_del(svcc);", "}", "else if (tkHint->rtp_p->rtp_payt==GF_RTP_PAYT_MPEG4) {", "esd = gf_isom_get_esd(tkHint->file, tkHint->TrackNum, 1);", "if (esd && esd->decoderConfig && esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data) {", "gf_rtp_builder_format_sdp(tkHint->rtp_p, payloadName, sdpLine, esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength);", "} else {", "gf_rtp_builder_format_sdp(tkHint->rtp_p, payloadName, sdpLine, NULL, 0);", "}", "if (esd) gf_odf_desc_del((GF_Descriptor *)esd);", "if (tkHint->rtp_p->slMap.IV_length) {", "const char *kms;", "gf_isom_get_ismacryp_info(tkHint->file, tkHint->TrackNum, 1, NULL, NULL, NULL, NULL, &kms, NULL, NULL, NULL);", "if (!strnicmp(kms, \"(key)\", 5) || !strnicmp(kms, \"(ipmp)\", 6) || !strnicmp(kms, \"(uri)\", 5)) {", "strcat(sdpLine, \"; ISMACrypKey=\");", "} else {", "strcat(sdpLine, \"; ISMACrypKey=(uri)\");", "}", "strcat(sdpLine, kms);", "}", "gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);", "}", "else if (tkHint->rtp_p->rtp_payt==GF_RTP_PAYT_LATM) {", "GF_BitStream *bs;", "u8 *config_bytes;", "u32 config_size;", "bs = gf_bs_new(NULL, 32, GF_BITSTREAM_WRITE);", "gf_bs_write_int(bs, 0, 1);", "gf_bs_write_int(bs, 1, 1);", "gf_bs_write_int(bs, 0, 6);", "gf_bs_write_int(bs, 0, 4);", "gf_bs_write_int(bs, 0, 3);", "esd = gf_isom_get_esd(tkHint->file, tkHint->TrackNum, 1);", "if (esd && esd->decoderConfig && esd->decoderConfig->decoderSpecificInfo) {", "gf_bs_write_data(bs, esd->decoderConfig->decoderSpecificInfo->data, MIN(esd->decoderConfig->decoderSpecificInfo->dataLength, 2) );", "}", "if (esd) gf_odf_desc_del((GF_Descriptor *)esd);", "gf_bs_write_int(bs, 0, 3);", "gf_bs_write_int(bs, 0xff, 8);", "gf_bs_write_int(bs, 0, 1);", "gf_bs_write_int(bs, 0, 1);", "gf_bs_get_content(bs, &config_bytes, &config_size);", "gf_bs_del(bs);", "gf_rtp_builder_format_sdp(tkHint->rtp_p, payloadName, sdpLine, config_bytes, config_size);", "gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);", "gf_free(config_bytes);", "}", "#if GPAC_ENABLE_3GPP_DIMS_RTP", "else if (tkHint->rtp_p->rtp_payt==GF_RTP_PAYT_3GPP_DIMS) {", "GF_DIMSDescription dims;", "gf_isom_get_visual_info(tkHint->file, tkHint->TrackNum, 1, &Width, &Height);", "gf_isom_get_dims_description(tkHint->file, tkHint->TrackNum, 1, &dims);", "sprintf(sdpLine, \"a=fmtp:%d Version-profile=%d\", tkHint->rtp_p->PayloadType, dims.profile);", "if (! dims.fullRequestHost) {", "char fmt[200];", "strcat(sdpLine, \";useFullRequestHost=0\");", "sprintf(fmt, \";pathComponents=%d\", dims.pathComponents);", "strcat(sdpLine, fmt);", "}", "if (!dims.streamType) strcat(sdpLine, \";stream-type=secondary\");", "if (dims.containsRedundant == 1) strcat(sdpLine, \";contains-redundant=main\");", "else if (dims.containsRedundant == 2) strcat(sdpLine, \";contains-redundant=redundant\");", "if (dims.textEncoding && strlen(dims.textEncoding)) {", "strcat(sdpLine, \";text-encoding=\");", "strcat(sdpLine, dims.textEncoding);", "}", "if (dims.contentEncoding && strlen(dims.contentEncoding)) {", "strcat(sdpLine, \";content-coding=\");", "strcat(sdpLine, dims.contentEncoding);", "}", "if (dims.contentEncoding && dims.content_script_types && strlen(dims.content_script_types) ) {", "strcat(sdpLine, \";content-script-types=\");", "strcat(sdpLine, dims.contentEncoding);", "}", "gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);", "}", "#endif", "if (Width && Height) {", "sprintf(sdpLine, \"a=framesize:%d %d-%d\", tkHint->rtp_p->PayloadType, Width, Height);", "gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);", "}", "esd = gf_isom_get_esd(tkHint->file, tkHint->TrackNum, 1);", "if (esd && esd->decoderConfig && (esd->decoderConfig->rvc_config || esd->decoderConfig->predefined_rvc_config)) {", "if (esd->decoderConfig->predefined_rvc_config) {", "sprintf(sdpLine, \"a=rvc-config-predef:%d\", esd->decoderConfig->predefined_rvc_config);", "} else {", "if ((esd->decoderConfig->objectTypeIndication==GF_CODECID_AVC) || (esd->decoderConfig->objectTypeIndication==GF_CODECID_SVC)) {", "sprintf(sdpLine, \"a=rvc-config:%s\", \"http:download.tsi.telecom-paristech.fr/gpac/RVC/rvc_config_avc.xml\");", "} else {", "sprintf(sdpLine, \"a=rvc-config:%s\", \"http:download.tsi.telecom-paristech.fr/gpac/RVC/rvc_config_sp.xml\");", "}", "}", "gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);", "}", "if (esd) gf_odf_desc_del((GF_Descriptor *)esd);", "gf_isom_set_track_enabled(tkHint->file, tkHint->HintTrack, GF_TRUE);", "return GF_OK;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static void gf_dump_vrml_proto_field(GF_SceneDumper *sdump, GF_Node *node, GF_FieldInfo field)", "{", "u32 i, sf_type;", "void *slot_ptr;", "DUMP_IND(sdump);", "gf_fprintf(sdump->trace, \"<fieldValue name=\\\"%s\\\" \", field.name);", "if (gf_sg_vrml_is_sf_field(field.fieldType)) {", "if (field.fieldType == GF_SG_VRML_SFNODE) {", "gf_fprintf(sdump->trace, \">\\n\");", "sdump->indent++;", "if (!sdump->X3DDump) gf_fprintf(sdump->trace, \"<node>\");", "gf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL);", "if (!sdump->X3DDump) gf_fprintf(sdump->trace, \"</node>\");", "sdump->indent--;", "DUMP_IND(sdump);", "gf_fprintf(sdump->trace, \"</fieldValue>\\n\");", "} else {", "if (sdump->X3DDump) {", "gf_fprintf(sdump->trace, \" value=\\\"\");", "} else {", "gf_fprintf(sdump->trace, \" %s=\\\"\", GetXMTFieldTypeValueName(field.fieldType));", "}", "gf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, node);", "gf_fprintf(sdump->trace, \"\\\"/>\\n\");", "}", "} else {", "GenMFField *mffield = (GenMFField *) field.far_ptr;", "sf_type = gf_sg_vrml_get_sf_type(field.fieldType);", "if ((field.eventType==GF_SG_EVENT_FIELD) || (field.eventType==GF_SG_EVENT_EXPOSED_FIELD)) {", "if (sf_type == GF_SG_VRML_SFNODE) {", "GF_ChildNodeItem *list = *(GF_ChildNodeItem **)field.far_ptr;", "gf_fprintf(sdump->trace, \">\\n\");", "sdump->indent++;", "if (!sdump->X3DDump) gf_fprintf(sdump->trace, \"<nodes>\");", "while (list) {", "gf_dump_vrml_node(sdump, list->node, 1, NULL);", "list = list->next;", "}", "if (!sdump->X3DDump) gf_fprintf(sdump->trace, \"</nodes>\");", "sdump->indent--;", "DUMP_IND(sdump);", "gf_fprintf(sdump->trace, \"</fieldValue>\\n\");", "} else {", "if (sdump->X3DDump) {", "gf_fprintf(sdump->trace, \" value=\\\"\");", "} else {", "gf_fprintf(sdump->trace, \" %s=\\\"\", GetXMTFieldTypeValueName(field.fieldType));", "}", "if (mffield) {", "for (i=0; i<mffield->count; i++) {", "if (i) gf_fprintf(sdump->trace, \" \");", "if (field.fieldType != GF_SG_VRML_MFNODE) {", "gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);", "gf_dump_vrml_sffield(sdump, sf_type, slot_ptr, (mffield->count>1) ? 1 : 0, node);", "}", "}", "}", "gf_fprintf(sdump->trace, \"\\\"/>\\n\");", "}", "}", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["Controller::constructHeaderForSessionProtocol(Request *req, char * restrict buffer,", "unsigned int &size, const SessionProtocolWorkingState &state, string delta_monotonic)", "{", "char *pos = buffer;", "const char *end = buffer + size;", "pos += sizeof(boost::uint32_t);", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"REQUEST_URI\"));", "pos = appendData(pos, end, req->path.start->data, req->path.size);", "pos = appendData(pos, end, \"\", 1);", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"PATH_INFO\"));", "pos = appendData(pos, end, state.path.data(), state.path.size());", "pos = appendData(pos, end, \"\", 1);", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"SCRIPT_NAME\"));", "if (state.hasBaseURI) {", "pos = appendData(pos, end, req->options.baseURI);", "pos = appendData(pos, end, \"\", 1);", "} else {", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"\"));", "}", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"QUERY_STRING\"));", "pos = appendData(pos, end, state.queryString.data(), state.queryString.size());", "pos = appendData(pos, end, \"\", 1);", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"REQUEST_METHOD\"));", "pos = appendData(pos, end, state.methodStr);", "pos = appendData(pos, end, \"\", 1);", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"SERVER_NAME\"));", "pos = appendData(pos, end, state.serverName);", "pos = appendData(pos, end, \"\", 1);", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"SERVER_PORT\"));", "pos = appendData(pos, end, state.serverPort);", "pos = appendData(pos, end, \"\", 1);", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"SERVER_SOFTWARE\"));", "pos = appendData(pos, end, serverSoftware);", "pos = appendData(pos, end, \"\", 1);", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"SERVER_PROTOCOL\"));", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"HTTP/1.1\"));", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"REMOTE_ADDR\"));", "if (state.remoteAddr != NULL) {", "pos = appendData(pos, end, state.remoteAddr);", "pos = appendData(pos, end, \"\", 1);", "} else {", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"127.0.0.1\"));", "}", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"REMOTE_PORT\"));", "if (state.remotePort != NULL) {", "pos = appendData(pos, end, state.remotePort);", "pos = appendData(pos, end, \"\", 1);", "} else {", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"0\"));", "}", "if (state.remoteUser != NULL) {", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"REMOTE_USER\"));", "pos = appendData(pos, end, state.remoteUser);", "pos = appendData(pos, end, \"\", 1);", "}", "if (state.contentType != NULL) {", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"CONTENT_TYPE\"));", "pos = appendData(pos, end, state.contentType);", "pos = appendData(pos, end, \"\", 1);", "}", "if (state.contentLength != NULL) {", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"CONTENT_LENGTH\"));", "pos = appendData(pos, end, state.contentLength);", "pos = appendData(pos, end, \"\", 1);", "}", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"PASSENGER_CONNECT_PASSWORD\"));", "pos = appendData(pos, end, req->session->getApiKey().toStaticString());", "pos = appendData(pos, end, \"\", 1);", "if (req->https) {", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"HTTPS\"));", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"on\"));", "}", "if (req->options.analytics) {", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"PASSENGER_TXN_ID\"));", "pos = appendData(pos, end, req->options.transaction->getTxnId());", "pos = appendData(pos, end, \"\", 1);", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"PASSENGER_DELTA_MONOTONIC\"));", "pos = appendData(pos, end, delta_monotonic);", "pos = appendData(pos, end, \"\", 1);", "}", "if (req->upgraded()) {", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"HTTP_CONNECTION\"));", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"upgrade\"));", "}", "ServerKit::HeaderTable::Iterator it(req->headers);", "while (*it != NULL) {", "if ((it->header->hash == HTTP_CONTENT_LENGTH.hash()", "|| it->header->hash == HTTP_CONTENT_TYPE.hash()", "|| it->header->hash == HTTP_CONNECTION.hash())", "&& (psg_lstr_cmp(&it->header->key, P_STATIC_STRING(\"content-type\"))", "|| psg_lstr_cmp(&it->header->key, P_STATIC_STRING(\"content-length\"))", "|| psg_lstr_cmp(&it->header->key, P_STATIC_STRING(\"connection\"))))", "{", "it.next();", "continue;", "}", "pos = appendData(pos, end, P_STATIC_STRING(\"HTTP_\"));", "const LString::Part *part = it->header->key.start;", "while (part != NULL) {", "char *start = pos;", "pos = appendData(pos, end, part->data, part->size);", "httpHeaderToScgiUpperCase((unsigned char *) start, pos - start);", "part = part->next;", "}", "pos = appendData(pos, end, \"\", 1);", "part = it->header->val.start;", "while (part != NULL) {", "pos = appendData(pos, end, part->data, part->size);", "part = part->next;", "}", "pos = appendData(pos, end, \"\", 1);", "it.next();", "}", "if (state.environmentVariablesData != NULL) {", "pos = appendData(pos, end, state.environmentVariablesData, state.environmentVariablesSize);", "}", "Uint32Message::generate(buffer, pos - buffer - sizeof(boost::uint32_t));", "size = pos - buffer;", "return pos < end;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void sqlite3EndTable(", "Parse *pParse,", "Token *pCons,", "Token *pEnd,", "u8 tabOpts,", "Select *pSelect", "){", "Table *p;", "sqlite3 *db = pParse->db;", "int iDb;", "Index *pIdx;", "if( pEnd==0 && pSelect==0 ){", "return;", "}", "assert( !db->mallocFailed );", "p = pParse->pNewTable;", "if( p==0 ) return;", "if( pSelect==0 && isShadowTableName(db, p->zName) ){", "p->tabFlags |= TF_Shadow;", "}", "if( db->init.busy ){", "if( pSelect ){", "sqlite3ErrorMsg(pParse, \"\");", "return;", "}", "p->tnum = db->init.newTnum;", "if( p->tnum==1 ) p->tabFlags |= TF_Readonly;", "}", "assert( (p->tabFlags & TF_HasPrimaryKey)==0", "|| p->iPKey>=0 || sqlite3PrimaryKeyIndex(p)!=0 );", "assert( (p->tabFlags & TF_HasPrimaryKey)!=0", "|| (p->iPKey<0 && sqlite3PrimaryKeyIndex(p)==0) );", "if( tabOpts & TF_WithoutRowid ){", "if( (p->tabFlags & TF_Autoincrement) ){", "sqlite3ErrorMsg(pParse,", "\"AUTOINCREMENT not allowed on WITHOUT ROWID tables\");", "return;", "}", "if( (p->tabFlags & TF_HasPrimaryKey)==0 ){", "sqlite3ErrorMsg(pParse, \"PRIMARY KEY missing on table %s\", p->zName);", "return;", "}", "p->tabFlags |= TF_WithoutRowid | TF_NoVisibleRowid;", "convertToWithoutRowidTable(pParse, p);", "}", "iDb = sqlite3SchemaToIndex(db, p->pSchema);", "#ifndef SQLITE_OMIT_CHECK", "if( p->pCheck ){", "sqlite3ResolveSelfReference(pParse, p, NC_IsCheck, 0, p->pCheck);", "}", "#endif /* !defined(SQLITE_OMIT_CHECK) */", "#ifndef SQLITE_OMIT_GENERATED_COLUMNS", "if( p->tabFlags & TF_HasGenerated ){", "int ii, nNG = 0;", "testcase( p->tabFlags & TF_HasVirtual );", "testcase( p->tabFlags & TF_HasStored );", "for(ii=0; ii<p->nCol; ii++){", "u32 colFlags = p->aCol[ii].colFlags;", "if( (colFlags & COLFLAG_GENERATED)!=0 ){", "testcase( colFlags & COLFLAG_VIRTUAL );", "testcase( colFlags & COLFLAG_STORED );", "sqlite3ResolveSelfReference(pParse, p, NC_GenCol,", "p->aCol[ii].pDflt, 0);", "}else{", "nNG++;", "}", "}", "if( nNG==0 ){", "sqlite3ErrorMsg(pParse, \"must have at least one non-generated column\");", "return;", "}", "}", "#endif", "estimateTableWidth(p);", "for(pIdx=p->pIndex; pIdx; pIdx=pIdx->pNext){", "estimateIndexWidth(pIdx);", "}", "if( !db->init.busy ){", "int n;", "Vdbe *v;", "char *zType;", "char *zType2;", "char *zStmt;", "v = sqlite3GetVdbe(pParse);", "if( NEVER(v==0) ) return;", "sqlite3VdbeAddOp1(v, OP_Close, 0);", "if( p->pSelect==0 ){", "zType = \"table\";", "zType2 = \"TABLE\";", "#ifndef SQLITE_OMIT_VIEW", "}else{", "zType = \"view\";", "zType2 = \"VIEW\";", "#endif", "}", "if( pSelect ){", "SelectDest dest;", "int regYield;", "int addrTop;", "int regRec;", "int regRowid;", "int addrInsLoop;", "Table *pSelTab;", "regYield = ++pParse->nMem;", "regRec = ++pParse->nMem;", "regRowid = ++pParse->nMem;", "assert(pParse->nTab==1);", "sqlite3MayAbort(pParse);", "sqlite3VdbeAddOp3(v, OP_OpenWrite, 1, pParse->regRoot, iDb);", "sqlite3VdbeChangeP5(v, OPFLAG_P2ISREG);", "pParse->nTab = 2;", "addrTop = sqlite3VdbeCurrentAddr(v) + 1;", "sqlite3VdbeAddOp3(v, OP_InitCoroutine, regYield, 0, addrTop);", "if( pParse->nErr ) return;", "pSelTab = sqlite3ResultSetOfSelect(pParse, pSelect, SQLITE_AFF_BLOB);", "if( pSelTab==0 ) return;", "assert( p->aCol==0 );", "p->nCol = p->nNVCol = pSelTab->nCol;", "p->aCol = pSelTab->aCol;", "pSelTab->nCol = 0;", "pSelTab->aCol = 0;", "sqlite3DeleteTable(db, pSelTab);", "sqlite3SelectDestInit(&dest, SRT_Coroutine, regYield);", "sqlite3Select(pParse, pSelect, &dest);", "if( pParse->nErr ) return;", "sqlite3VdbeEndCoroutine(v, regYield);", "sqlite3VdbeJumpHere(v, addrTop - 1);", "addrInsLoop = sqlite3VdbeAddOp1(v, OP_Yield, dest.iSDParm);", "VdbeCoverage(v);", "sqlite3VdbeAddOp3(v, OP_MakeRecord, dest.iSdst, dest.nSdst, regRec);", "sqlite3TableAffinity(v, p, 0);", "sqlite3VdbeAddOp2(v, OP_NewRowid, 1, regRowid);", "sqlite3VdbeAddOp3(v, OP_Insert, 1, regRec, regRowid);", "sqlite3VdbeGoto(v, addrInsLoop);", "sqlite3VdbeJumpHere(v, addrInsLoop);", "sqlite3VdbeAddOp1(v, OP_Close, 1);", "}", "if( pSelect ){", "zStmt = createTableStmt(db, p);", "}else{", "Token *pEnd2 = tabOpts ? &pParse->sLastToken : pEnd;", "n = (int)(pEnd2->z - pParse->sNameToken.z);", "if( pEnd2->z[0]!=';' ) n += pEnd2->n;", "zStmt = sqlite3MPrintf(db,", "\"CREATE %s %.*s\", zType2, n, pParse->sNameToken.z", ");", "}", "sqlite3NestedParse(pParse,", "\"UPDATE %Q.%s \"", "\"SET type='%s', name=%Q, tbl_name=%Q, rootpage=#%d, sql=%Q \"", "\"WHERE rowid=#%d\",", "db->aDb[iDb].zDbSName, MASTER_NAME,", "zType,", "p->zName,", "p->zName,", "pParse->regRoot,", "zStmt,", "pParse->regRowid", ");", "sqlite3DbFree(db, zStmt);", "sqlite3ChangeCookie(pParse, iDb);", "#ifndef SQLITE_OMIT_AUTOINCREMENT", "if( (p->tabFlags & TF_Autoincrement)!=0 ){", "Db *pDb = &db->aDb[iDb];", "assert( sqlite3SchemaMutexHeld(db, iDb, 0) );", "if( pDb->pSchema->pSeqTab==0 ){", "sqlite3NestedParse(pParse,", "\"CREATE TABLE %Q.sqlite_sequence(name,seq)\",", "pDb->zDbSName", ");", "}", "}", "#endif", "sqlite3VdbeAddParseSchemaOp(v, iDb,", "sqlite3MPrintf(db, \"tbl_name='%q' AND type!='trigger'\", p->zName));", "}", "if( db->init.busy ){", "Table *pOld;", "Schema *pSchema = p->pSchema;", "assert( sqlite3SchemaMutexHeld(db, iDb, 0) );", "pOld = sqlite3HashInsert(&pSchema->tblHash, p->zName, p);", "if( pOld ){", "assert( p==pOld );", "sqlite3OomFault(db);", "return;", "}", "pParse->pNewTable = 0;", "db->mDbFlags |= DBFLAG_SchemaChange;", "#ifndef SQLITE_OMIT_ALTERTABLE", "if( !p->pSelect ){", "const char *zName = (const char *)pParse->sNameToken.z;", "int nName;", "assert( !pSelect && pCons && pEnd );", "if( pCons->z==0 ){", "pCons = pEnd;", "}", "nName = (int)((const char *)pCons->z - zName);", "p->addColOffset = 13 + sqlite3Utf8CharLen(zName, nName);", "}", "#endif", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["sc_oberthur_read_file(struct sc_pkcs15_card *p15card, const char *in_path,", "unsigned char **out, size_t *out_len,", "int verify_pin)", "{", "struct sc_context *ctx = p15card->card->ctx;", "struct sc_card *card = p15card->card;", "struct sc_file *file = NULL;", "struct sc_path path;", "size_t sz;", "int rv;", "LOG_FUNC_CALLED(ctx);", "if (!in_path || !out || !out_len)", "LOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Cannot read oberthur file\");", "sc_log(ctx, \"read file '%s'; verify_pin:%i\", in_path, verify_pin);", "*out = NULL;", "*out_len = 0;", "sc_format_path(in_path, &path);", "rv = sc_select_file(card, &path, &file);", "if (rv != SC_SUCCESS) {", "sc_file_free(file);", "LOG_TEST_RET(ctx, rv, \"Cannot select oberthur file to read\");", "}", "if (file->ef_structure == SC_FILE_EF_TRANSPARENT)", "sz = file->size;", "else", "sz = (file->record_length + 2) * file->record_count;", "*out = calloc(sz, 1);", "if (*out == NULL) {", "sc_file_free(file);", "LOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"Cannot read oberthur file\");", "}", "if (file->ef_structure == SC_FILE_EF_TRANSPARENT)   {", "rv = sc_read_binary(card, 0, *out, sz, 0);", "}", "else {", "size_t rec;", "size_t offs = 0;", "size_t rec_len = file->record_length;", "for (rec = 1; ; rec++)   {", "if (rec > file->record_count) {", "rv = 0;", "break;", "}", "rv = sc_read_record(card, rec, *out + offs + 2, rec_len, SC_RECORD_BY_REC_NR);", "if (rv == SC_ERROR_RECORD_NOT_FOUND)   {", "rv = 0;", "break;", "}", "else if (rv < 0)   {", "break;", "}", "rec_len = rv;", "*(*out + offs) = 'R';", "*(*out + offs + 1) = rv;", "offs += rv + 2;", "}", "sz = offs;", "}", "sc_log(ctx, \"read oberthur file result %i\", rv);", "if (verify_pin && rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)   {", "struct sc_pkcs15_object *objs[0x10], *pin_obj = NULL;", "const struct sc_acl_entry *acl = sc_file_get_acl_entry(file, SC_AC_OP_READ);", "int ii;", "if (acl == NULL) {", "sc_file_free(file);", "free(*out);", "*out = NULL;", "LOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_DATA);", "}", "rv = sc_pkcs15_get_objects(p15card, SC_PKCS15_TYPE_AUTH_PIN, objs, 0x10);", "if (rv != SC_SUCCESS) {", "sc_file_free(file);", "free(*out);", "*out = NULL;", "LOG_TEST_RET(ctx, rv, \"Cannot read oberthur file: get AUTH objects error\");", "}", "for (ii=0; ii<rv; ii++)   {", "struct sc_pkcs15_auth_info *auth_info = (struct sc_pkcs15_auth_info *) objs[ii]->data;", "sc_log(ctx, \"compare PIN/ACL refs:%i/%i, method:%i/%i\",", "auth_info->attrs.pin.reference, acl->key_ref, auth_info->auth_method, acl->method);", "if (auth_info->attrs.pin.reference == (int)acl->key_ref && auth_info->auth_method == (unsigned)acl->method)   {", "pin_obj = objs[ii];", "break;", "}", "}", "if (!pin_obj || !pin_obj->content.value)    {", "rv = SC_ERROR_SECURITY_STATUS_NOT_SATISFIED;", "}", "else    {", "rv = sc_pkcs15_verify_pin(p15card, pin_obj, pin_obj->content.value, pin_obj->content.len);", "if (!rv)", "rv = sc_oberthur_read_file(p15card, in_path, out, out_len, 0);", "}", "}", "sc_file_free(file);", "if (rv < 0)   {", "free(*out);", "*out = NULL;", "*out_len = 0;", "}", "*out_len = sz;", "LOG_FUNC_RETURN(ctx, rv);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["GF_Err latm_dmx_process(GF_Filter *filter)", "{", "GF_LATMDmxCtx *ctx = gf_filter_get_udta(filter);", "GF_FilterPacket *pck, *dst_pck;", "u32 pos;", "u8 *data, *output;", "u32 pck_size, prev_pck_size;", "u64 cts = GF_FILTER_NO_TS;", "if (ctx->in_error)", "return ctx->in_error;", "if (!ctx->duration.num)", "latm_dmx_check_dur(filter, ctx);", "if (ctx->opid && !ctx->is_playing)", "return GF_OK;", "pck = gf_filter_pid_get_packet(ctx->ipid);", "if (!pck) {", "if (gf_filter_pid_is_eos(ctx->ipid)) {", "if (!ctx->latm_buffer_size) {", "if (ctx->opid)", "gf_filter_pid_set_eos(ctx->opid);", "if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);", "ctx->src_pck = NULL;", "return GF_EOS;", "}", "} else {", "return GF_OK;", "}", "}", "data = (char *) gf_filter_pck_get_data(pck, &pck_size);", "if (ctx->timescale && pck) {", "cts = gf_filter_pck_get_cts(pck);", "}", "prev_pck_size = ctx->latm_buffer_size;", "if (pck && !ctx->resume_from) {", "if (ctx->latm_buffer_size + pck_size > ctx->latm_buffer_alloc) {", "ctx->latm_buffer_alloc = ctx->latm_buffer_size + pck_size;", "ctx->latm_buffer = gf_realloc(ctx->latm_buffer, ctx->latm_buffer_alloc);", "}", "memcpy(ctx->latm_buffer + ctx->latm_buffer_size, data, pck_size);", "ctx->latm_buffer_size += pck_size;", "}", "if (!ctx->bs) ctx->bs = gf_bs_new(ctx->latm_buffer, ctx->latm_buffer_size, GF_BITSTREAM_READ);", "else gf_bs_reassign_buffer(ctx->bs, ctx->latm_buffer, ctx->latm_buffer_size);", "if (ctx->resume_from) {", "gf_bs_seek(ctx->bs, ctx->resume_from-1);", "ctx->resume_from = 0;", "}", "if (cts == GF_FILTER_NO_TS)", "prev_pck_size = 0;", "while (1) {", "pos = (u32) gf_bs_get_position(ctx->bs);", "u8 latm_buffer[4096];", "u32 latm_frame_size = 4096;", "if (!latm_dmx_sync_frame_bs(ctx->bs,&ctx->acfg, &latm_frame_size, latm_buffer, NULL)) break;", "if (ctx->in_seek) {", "u64 nb_samples_at_seek = (u64) (ctx->start_range * GF_M4ASampleRates[ctx->sr_idx]);", "if (ctx->cts + ctx->dts_inc >= nb_samples_at_seek) {", "ctx->in_seek = GF_FALSE;", "}", "}", "latm_dmx_check_pid(filter, ctx);", "if (!ctx->is_playing) {", "ctx->resume_from = pos+1;", "return GF_OK;", "}", "if (!ctx->in_seek) {", "GF_FilterSAPType sap = GF_FILTER_SAP_1;", "dst_pck = gf_filter_pck_new_alloc(ctx->opid, latm_frame_size, &output);", "if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);", "memcpy(output, latm_buffer, latm_frame_size);", "gf_filter_pck_set_cts(dst_pck, ctx->cts);", "gf_filter_pck_set_duration(dst_pck, ctx->dts_inc);", "gf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);", "if (ctx->acfg.base_object_type==GF_CODECID_USAC) {", "if (latm_frame_size && (output[0] & 0x80) && !ctx->prev_sap) {", "sap = GF_FILTER_SAP_1;", "ctx->prev_sap = GF_TRUE;", "} else {", "sap = GF_FILTER_SAP_NONE;", "ctx->prev_sap = GF_FALSE;", "}", "}", "gf_filter_pck_set_sap(dst_pck, sap);", "gf_filter_pck_send(dst_pck);", "}", "latm_dmx_update_cts(ctx);", "if (prev_pck_size) {", "pos = (u32) gf_bs_get_position(ctx->bs);", "if (prev_pck_size<=pos) {", "prev_pck_size=0;", "if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);", "ctx->src_pck = pck;", "if (pck)", "gf_filter_pck_ref_props(&ctx->src_pck);", "}", "}", "}", "if (pck) {", "pos = (u32) gf_bs_get_position(ctx->bs);", "assert(ctx->latm_buffer_size >= pos);", "memmove(ctx->latm_buffer, ctx->latm_buffer+pos, ctx->latm_buffer_size - pos);", "ctx->latm_buffer_size -= pos;", "gf_filter_pid_drop_packet(ctx->ipid);", "assert(!ctx->resume_from);", "} else {", "ctx->latm_buffer_size = 0;", "return latm_dmx_process(filter);", "}", "return GF_OK;", "}"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static s32 gf_media_vvc_read_pps_bs_internal(GF_BitStream *bs, VVCState *vvc)", "{", "u32 i;", "s32 pps_id;", "VVC_PPS *pps;", "pps_id = gf_bs_read_int_log(bs, 6, \"pps_id\");", "if ((pps_id < 0) || (pps_id >= 64)) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] wrong PPS ID %d in PPS\\n\", pps_id));", "return -1;", "}", "pps = &vvc->pps[pps_id];", "if (!pps->state) {", "pps->id = pps_id;", "pps->state = 1;", "}", "pps->sps_id = gf_bs_read_int_log(bs, 4, \"sps_id\");", "if (pps->sps_id >= 16) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] wrong SPS ID %d in PPS\\n\", pps->sps_id));", "pps->sps_id=0;", "return -1;", "}", "vvc->sps_active_idx = pps->sps_id;", "pps->mixed_nal_types = gf_bs_read_int_log(bs, 1, \"mixed_nal_types\");", "pps->width = gf_bs_read_ue_log(bs, \"width\");", "pps->height = gf_bs_read_ue_log(bs, \"height\");", "pps->conf_window = gf_bs_read_int_log(bs, 1, \"conformance_window_flag\");", "if (pps->conf_window) {", "pps->cw_left = gf_bs_read_ue_log(bs, \"conf_win_left_offset\");", "pps->cw_right = gf_bs_read_ue_log(bs, \"conf_win_right_offset\");", "pps->cw_top = gf_bs_read_ue_log(bs, \"conf_win_top_offset\");", "pps->cw_bottom = gf_bs_read_ue_log(bs, \"conf_win_bottom_offset\");", "}", "if (gf_bs_read_int_log(bs, 1, \"scaling_window_explicit_signalling_flag\")) {", "gf_bs_read_se_log(bs, \"scaling_win_left_offset\");", "gf_bs_read_se_log(bs, \"scaling_win_right_offset\");", "gf_bs_read_se_log(bs, \"scaling_win_top_offset\");", "gf_bs_read_se_log(bs, \"scaling_win_bottom_offset\");", "}", "pps->output_flag_present_flag = gf_bs_read_int_log(bs, 1, \"output_flag_present_flag\");", "pps->no_pic_partition_flag = gf_bs_read_int_log(bs, 1, \"no_pic_partition_flag\");", "pps->subpic_id_mapping_present_flag = gf_bs_read_int_log(bs, 1, \"subpic_id_mapping_present_flag\");", "if (pps->subpic_id_mapping_present_flag) {", "u32 pps_subpic_id_len, pps_num_subpics=0;", "if (!pps->no_pic_partition_flag) {", "pps_num_subpics = 1+gf_bs_read_ue_log(bs, \"pps_num_subpics_minus1\");", "}", "pps_subpic_id_len = 1 + gf_bs_read_ue(bs);", "for (i=0; i<pps_num_subpics; i++) {", "gf_bs_read_int_log_idx(bs, pps_subpic_id_len, \"subpic_id\", i);", "}", "}", "if (!pps->no_pic_partition_flag) {", "gf_bs_read_int_log(bs, 2, \"pps_log2_ctu_size_minus5\");", "u32 num_exp_tile_columns = 1 + gf_bs_read_ue_log(bs, \"num_exp_tile_columns_minus1\");", "u32 num_exp_tile_rows = 1 + gf_bs_read_ue_log(bs, \"num_exp_tile_rows_minus1\");", "for (i=0; i<num_exp_tile_columns; i++)", "gf_bs_read_ue_log_idx(bs, \"tile_column_width_minus1\", i);", "for (i=0; i<num_exp_tile_rows; i++)", "gf_bs_read_ue_log_idx(bs, \"tile_row_height_minus1\", i);", "return pps_id;", "}", "return pps_id;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static void listdir(unsigned int depth, int f, void * const tls_fd,", "const char *name)", "{", "PureFileInfo *dir;", "char *names;", "PureFileInfo *s;", "PureFileInfo *r;", "int d;", "if (depth >= max_ls_depth || matches >= max_ls_files) {", "return;", "}", "if ((dir = sreaddir(&names)) == NULL) {", "addreply(226, MSG_CANT_READ_FILE, name);", "return;", "}", "s = dir;", "while (s->name_offset != (size_t) -1) {", "d = 0;", "if (FI_NAME(s)[0] != '.') {", "d = listfile(s, NULL);", "} else if (opt_a) {", "if (FI_NAME(s)[1] == 0 ||", "(FI_NAME(s)[1] == '.' && FI_NAME(s)[2] == 0)) {", "listfile(s, NULL);", "} else {", "d = listfile(s, NULL);", "}", "}", "if (!d) {", "s->name_offset = (size_t) -1;", "}", "s++;", "}", "outputfiles(f, tls_fd);", "r = dir;", "while (opt_R && r != s) {", "if (r->name_offset != (size_t) -1 && !chdir(FI_NAME(r))) {", "char *alloca_subdir;", "const size_t sizeof_subdir = PATH_MAX + 1U;", "if ((alloca_subdir = ALLOCA(sizeof_subdir)) == NULL) {", "goto toomany;", "}", "if (SNCHECK(snprintf(alloca_subdir, sizeof_subdir, \"%s/%s\",", "name, FI_NAME(r)), sizeof_subdir)) {", "goto nolist;", "}", "wrstr(f, tls_fd, \"\\r\\n\\r\\n\");", "wrstr(f, tls_fd, alloca_subdir);", "wrstr(f, tls_fd, \":\\r\\n\\r\\n\");", "listdir(depth + 1U, f, tls_fd, alloca_subdir);", "nolist:", "ALLOCA_FREE(alloca_subdir);", "if (matches >= max_ls_files) {", "goto toomany;", "}", "if (chdir(\"..\")) {", "if (chdir(wd) || chdir(name)) {", "die(421, LOG_ERR, \"chdir: %s\", strerror(errno));", "}", "}", "}", "r++;", "}", "toomany:", "free(names);", "free(dir);", "names = NULL;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["GF_Err diST_box_read(GF_Box *s, GF_BitStream *bs)", "{", "u32 i;", "char str[1024];", "GF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s;", "i=0;", "str[0]=0;", "while (1) {", "str[i] = gf_bs_read_u8(bs);", "if (!str[i]) break;", "i++;", "}", "ISOM_DECREASE_SIZE(p, i);", "p->content_script_types = gf_strdup(str);", "return GF_OK;", "}"], "ner_tags": [0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0]}
{"tokens": ["static void cstm(JF, js_Ast *stm)", "{", "js_Ast *target;", "int loop, cont, then, end;", "emitline(J, F, stm);", "switch (stm->type) {", "case AST_FUNDEC:", "break;", "case STM_BLOCK:", "cstmlist(J, F, stm->a);", "break;", "case STM_EMPTY:", "if (F->script) {", "emitline(J, F, stm);", "emit(J, F, OP_POP);", "emit(J, F, OP_UNDEF);", "}", "break;", "case STM_VAR:", "cvarinit(J, F, stm->a);", "break;", "case STM_IF:", "if (stm->c) {", "cexp(J, F, stm->a);", "emitline(J, F, stm);", "then = emitjump(J, F, OP_JTRUE);", "cstm(J, F, stm->c);", "emitline(J, F, stm);", "end = emitjump(J, F, OP_JUMP);", "label(J, F, then);", "cstm(J, F, stm->b);", "label(J, F, end);", "} else {", "cexp(J, F, stm->a);", "emitline(J, F, stm);", "end = emitjump(J, F, OP_JFALSE);", "cstm(J, F, stm->b);", "label(J, F, end);", "}", "break;", "case STM_DO:", "loop = here(J, F);", "cstm(J, F, stm->a);", "cont = here(J, F);", "cexp(J, F, stm->b);", "emitline(J, F, stm);", "emitjumpto(J, F, OP_JTRUE, loop);", "labeljumps(J, F, stm->jumps, here(J,F), cont);", "break;", "case STM_WHILE:", "loop = here(J, F);", "cexp(J, F, stm->a);", "emitline(J, F, stm);", "end = emitjump(J, F, OP_JFALSE);", "cstm(J, F, stm->b);", "emitline(J, F, stm);", "emitjumpto(J, F, OP_JUMP, loop);", "label(J, F, end);", "labeljumps(J, F, stm->jumps, here(J,F), loop);", "break;", "case STM_FOR:", "case STM_FOR_VAR:", "if (stm->type == STM_FOR_VAR) {", "cvarinit(J, F, stm->a);", "} else {", "if (stm->a) {", "cexp(J, F, stm->a);", "emit(J, F, OP_POP);", "}", "}", "loop = here(J, F);", "if (stm->b) {", "cexp(J, F, stm->b);", "emitline(J, F, stm);", "end = emitjump(J, F, OP_JFALSE);", "} else {", "end = 0;", "}", "cstm(J, F, stm->d);", "cont = here(J, F);", "if (stm->c) {", "cexp(J, F, stm->c);", "emit(J, F, OP_POP);", "}", "emitline(J, F, stm);", "emitjumpto(J, F, OP_JUMP, loop);", "if (end)", "label(J, F, end);", "labeljumps(J, F, stm->jumps, here(J,F), cont);", "break;", "case STM_FOR_IN:", "case STM_FOR_IN_VAR:", "cexp(J, F, stm->b);", "emitline(J, F, stm);", "emit(J, F, OP_ITERATOR);", "loop = here(J, F);", "{", "emitline(J, F, stm);", "emit(J, F, OP_NEXTITER);", "end = emitjump(J, F, OP_JFALSE);", "cassignforin(J, F, stm);", "if (F->script) {", "emit(J, F, OP_ROT2);", "cstm(J, F, stm->c);", "emit(J, F, OP_ROT2);", "} else {", "cstm(J, F, stm->c);", "}", "emitline(J, F, stm);", "emitjumpto(J, F, OP_JUMP, loop);", "}", "label(J, F, end);", "labeljumps(J, F, stm->jumps, here(J,F), loop);", "break;", "case STM_SWITCH:", "cswitch(J, F, stm->a, stm->b);", "labeljumps(J, F, stm->jumps, here(J,F), 0);", "break;", "case STM_LABEL:", "cstm(J, F, stm->b);", "while (stm->type == STM_LABEL)", "stm = stm->b;", "if (!isloop(stm->type) && stm->type != STM_SWITCH)", "labeljumps(J, F, stm->jumps, here(J,F), 0);", "break;", "case STM_BREAK:", "if (stm->a) {", "checkfutureword(J, F, stm->a);", "target = breaktarget(J, F, stm->parent, stm->a->string);", "if (!target)", "jsC_error(J, stm, \"break label '%s' not found\", stm->a->string);", "} else {", "target = breaktarget(J, F, stm->parent, NULL);", "if (!target)", "jsC_error(J, stm, \"unlabelled break must be inside loop or switch\");", "}", "cexit(J, F, STM_BREAK, stm, target);", "emitline(J, F, stm);", "addjump(J, F, STM_BREAK, target, emitjump(J, F, OP_JUMP));", "break;", "case STM_CONTINUE:", "if (stm->a) {", "checkfutureword(J, F, stm->a);", "target = continuetarget(J, F, stm->parent, stm->a->string);", "if (!target)", "jsC_error(J, stm, \"continue label '%s' not found\", stm->a->string);", "} else {", "target = continuetarget(J, F, stm->parent, NULL);", "if (!target)", "jsC_error(J, stm, \"continue must be inside loop\");", "}", "cexit(J, F, STM_CONTINUE, stm, target);", "emitline(J, F, stm);", "addjump(J, F, STM_CONTINUE, target, emitjump(J, F, OP_JUMP));", "break;", "case STM_RETURN:", "if (stm->a)", "cexp(J, F, stm->a);", "else", "emit(J, F, OP_UNDEF);", "target = returntarget(J, F, stm->parent);", "if (!target)", "jsC_error(J, stm, \"return not in function\");", "cexit(J, F, STM_RETURN, stm, target);", "emitline(J, F, stm);", "emit(J, F, OP_RETURN);", "break;", "case STM_THROW:", "cexp(J, F, stm->a);", "emitline(J, F, stm);", "emit(J, F, OP_THROW);", "break;", "case STM_WITH:", "F->lightweight = 0;", "if (F->strict)", "jsC_error(J, stm->a, \"'with' statements are not allowed in strict mode\");", "cexp(J, F, stm->a);", "emitline(J, F, stm);", "emit(J, F, OP_WITH);", "cstm(J, F, stm->b);", "emitline(J, F, stm);", "emit(J, F, OP_ENDWITH);", "break;", "case STM_TRY:", "emitline(J, F, stm);", "if (stm->b && stm->c) {", "F->lightweight = 0;", "if (stm->d)", "ctrycatchfinally(J, F, stm->a, stm->b, stm->c, stm->d);", "else", "ctrycatch(J, F, stm->a, stm->b, stm->c);", "} else {", "ctryfinally(J, F, stm->a, stm->d);", "}", "break;", "case STM_DEBUGGER:", "emitline(J, F, stm);", "emit(J, F, OP_DEBUGGER);", "break;", "default:", "if (F->script) {", "emitline(J, F, stm);", "emit(J, F, OP_POP);", "cexp(J, F, stm);", "} else {", "cexp(J, F, stm);", "emitline(J, F, stm);", "emit(J, F, OP_POP);", "}", "break;", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int read_header(FFV1Context *f)", "{", "uint8_t state[CONTEXT_SIZE];", "int i, j, context_count = -1;", "RangeCoder *const c = &f->slice_context[0]->c;", "memset(state, 128, sizeof(state));", "if (f->version < 2) {", "int chroma_planes, chroma_h_shift, chroma_v_shift, transparency, colorspace, bits_per_raw_sample;", "unsigned v= get_symbol(c, state, 0);", "if (v >= 2) {", "av_log(f->avctx, AV_LOG_ERROR, \"invalid version %d in ver01 header\\n\", v);", "return AVERROR_INVALIDDATA;", "}", "f->version = v;", "f->ac      = f->avctx->coder_type = get_symbol(c, state, 0);", "if (f->ac > 1) {", "for (i = 1; i < 256; i++)", "f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];", "}", "colorspace          = get_symbol(c, state, 0);", "bits_per_raw_sample = f->version > 0 ? get_symbol(c, state, 0) : f->avctx->bits_per_raw_sample;", "chroma_planes       = get_rac(c, state);", "chroma_h_shift      = get_symbol(c, state, 0);", "chroma_v_shift      = get_symbol(c, state, 0);", "transparency        = get_rac(c, state);", "if (f->plane_count) {", "if (colorspace          != f->colorspace                 ||", "bits_per_raw_sample != f->avctx->bits_per_raw_sample ||", "chroma_planes       != f->chroma_planes              ||", "chroma_h_shift      != f->chroma_h_shift             ||", "chroma_v_shift      != f->chroma_v_shift             ||", "transparency        != f->transparency) {", "av_log(f->avctx, AV_LOG_ERROR, \"Invalid change of global parameters\\n\");", "return AVERROR_INVALIDDATA;", "}", "}", "if (chroma_h_shift > 4U || chroma_v_shift > 4U) {", "av_log(f->avctx, AV_LOG_ERROR, \"chroma shift parameters %d %d are invalid\\n\",", "chroma_h_shift, chroma_v_shift);", "return AVERROR_INVALIDDATA;", "}", "f->colorspace                 = colorspace;", "f->avctx->bits_per_raw_sample = bits_per_raw_sample;", "f->chroma_planes              = chroma_planes;", "f->chroma_h_shift             = chroma_h_shift;", "f->chroma_v_shift             = chroma_v_shift;", "f->transparency               = transparency;", "f->plane_count    = 2 + f->transparency;", "}", "if (f->colorspace == 0) {", "if (f->avctx->skip_alpha) f->transparency = 0;", "if (!f->transparency && !f->chroma_planes) {", "if (f->avctx->bits_per_raw_sample <= 8)", "f->avctx->pix_fmt = AV_PIX_FMT_GRAY8;", "else", "f->avctx->pix_fmt = AV_PIX_FMT_GRAY16;", "} else if (f->avctx->bits_per_raw_sample<=8 && !f->transparency) {", "switch(16 * f->chroma_h_shift + f->chroma_v_shift) {", "case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P; break;", "case 0x01: f->avctx->pix_fmt = AV_PIX_FMT_YUV440P; break;", "case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P; break;", "case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P; break;", "case 0x20: f->avctx->pix_fmt = AV_PIX_FMT_YUV411P; break;", "case 0x22: f->avctx->pix_fmt = AV_PIX_FMT_YUV410P; break;", "}", "} else if (f->avctx->bits_per_raw_sample <= 8 && f->transparency) {", "switch(16*f->chroma_h_shift + f->chroma_v_shift) {", "case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P; break;", "case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P; break;", "case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P; break;", "}", "} else if (f->avctx->bits_per_raw_sample == 9 && !f->transparency) {", "f->packed_at_lsb = 1;", "switch(16 * f->chroma_h_shift + f->chroma_v_shift) {", "case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P9; break;", "case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P9; break;", "case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P9; break;", "}", "} else if (f->avctx->bits_per_raw_sample == 9 && f->transparency) {", "f->packed_at_lsb = 1;", "switch(16 * f->chroma_h_shift + f->chroma_v_shift) {", "case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P9; break;", "case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P9; break;", "case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P9; break;", "}", "} else if (f->avctx->bits_per_raw_sample == 10 && !f->transparency) {", "f->packed_at_lsb = 1;", "switch(16 * f->chroma_h_shift + f->chroma_v_shift) {", "case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P10; break;", "case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P10; break;", "case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P10; break;", "}", "} else if (f->avctx->bits_per_raw_sample == 10 && f->transparency) {", "f->packed_at_lsb = 1;", "switch(16 * f->chroma_h_shift + f->chroma_v_shift) {", "case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P10; break;", "case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P10; break;", "case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P10; break;", "}", "} else if (f->avctx->bits_per_raw_sample == 16 && !f->transparency){", "switch(16 * f->chroma_h_shift + f->chroma_v_shift) {", "case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P16; break;", "case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P16; break;", "case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P16; break;", "}", "} else if (f->avctx->bits_per_raw_sample == 16 && f->transparency){", "switch(16 * f->chroma_h_shift + f->chroma_v_shift) {", "case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P16; break;", "case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P16; break;", "case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P16; break;", "}", "}", "} else if (f->colorspace == 1) {", "if (f->chroma_h_shift || f->chroma_v_shift) {", "av_log(f->avctx, AV_LOG_ERROR,", "\"chroma subsampling not supported in this colorspace\\n\");", "return AVERROR(ENOSYS);", "}", "if (     f->avctx->bits_per_raw_sample ==  9)", "f->avctx->pix_fmt = AV_PIX_FMT_GBRP9;", "else if (f->avctx->bits_per_raw_sample == 10)", "f->avctx->pix_fmt = AV_PIX_FMT_GBRP10;", "else if (f->avctx->bits_per_raw_sample == 12)", "f->avctx->pix_fmt = AV_PIX_FMT_GBRP12;", "else if (f->avctx->bits_per_raw_sample == 14)", "f->avctx->pix_fmt = AV_PIX_FMT_GBRP14;", "else", "if (f->transparency) f->avctx->pix_fmt = AV_PIX_FMT_RGB32;", "else                 f->avctx->pix_fmt = AV_PIX_FMT_0RGB32;", "} else {", "av_log(f->avctx, AV_LOG_ERROR, \"colorspace not supported\\n\");", "return AVERROR(ENOSYS);", "}", "if (f->avctx->pix_fmt == AV_PIX_FMT_NONE) {", "av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");", "return AVERROR(ENOSYS);", "}", "av_dlog(f->avctx, \"%d %d %d\\n\",", "f->chroma_h_shift, f->chroma_v_shift, f->avctx->pix_fmt);", "if (f->version < 2) {", "context_count = read_quant_tables(c, f->quant_table);", "if (context_count < 0) {", "av_log(f->avctx, AV_LOG_ERROR, \"read_quant_table error\\n\");", "return AVERROR_INVALIDDATA;", "}", "f->slice_count = f->max_slice_count;", "} else if (f->version < 3) {", "f->slice_count = get_symbol(c, state, 0);", "} else {", "const uint8_t *p = c->bytestream_end;", "for (f->slice_count = 0;", "f->slice_count < MAX_SLICES && 3 < p - c->bytestream_start;", "f->slice_count++) {", "int trailer = 3 + 5*!!f->ec;", "int size = AV_RB24(p-trailer);", "if (size + trailer > p - c->bytestream_start)", "break;", "p -= size + trailer;", "}", "}", "if (f->slice_count > (unsigned)MAX_SLICES || f->slice_count <= 0 || f->slice_count > f->max_slice_count) {", "av_log(f->avctx, AV_LOG_ERROR, \"slice count %d is invalid (max=%d)\\n\", f->slice_count, f->max_slice_count);", "return AVERROR_INVALIDDATA;", "}", "for (j = 0; j < f->slice_count; j++) {", "FFV1Context *fs = f->slice_context[j];", "fs->ac            = f->ac;", "fs->packed_at_lsb = f->packed_at_lsb;", "fs->slice_damaged = 0;", "if (f->version == 2) {", "fs->slice_x      =  get_symbol(c, state, 0)      * f->width ;", "fs->slice_y      =  get_symbol(c, state, 0)      * f->height;", "fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width  + fs->slice_x;", "fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;", "fs->slice_x     /= f->num_h_slices;", "fs->slice_y     /= f->num_v_slices;", "fs->slice_width  = fs->slice_width  / f->num_h_slices - fs->slice_x;", "fs->slice_height = fs->slice_height / f->num_v_slices - fs->slice_y;", "if ((unsigned)fs->slice_width  > f->width ||", "(unsigned)fs->slice_height > f->height)", "return AVERROR_INVALIDDATA;", "if (   (unsigned)fs->slice_x + (uint64_t)fs->slice_width  > f->width", "|| (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height)", "return AVERROR_INVALIDDATA;", "}", "for (i = 0; i < f->plane_count; i++) {", "PlaneContext *const p = &fs->plane[i];", "if (f->version == 2) {", "int idx = get_symbol(c, state, 0);", "if (idx > (unsigned)f->quant_table_count) {", "av_log(f->avctx, AV_LOG_ERROR,", "\"quant_table_index out of range\\n\");", "return AVERROR_INVALIDDATA;", "}", "p->quant_table_index = idx;", "memcpy(p->quant_table, f->quant_tables[idx],", "sizeof(p->quant_table));", "context_count = f->context_count[idx];", "} else {", "memcpy(p->quant_table, f->quant_table, sizeof(p->quant_table));", "}", "if (f->version <= 2) {", "av_assert0(context_count >= 0);", "if (p->context_count < context_count) {", "av_freep(&p->state);", "av_freep(&p->vlc_state);", "}", "p->context_count = context_count;", "}", "}", "}", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["parse_exp(Node** np, PToken* tok, int term, UChar** src, UChar* end,", "ScanEnv* env, int group_head)", "{", "int r, len, group = 0;", "Node* qn;", "Node** tp;", "*np = NULL;", "if (tok->type == (enum TokenSyms )term)", "goto end_of_token;", "switch (tok->type) {", "case TK_ALT:", "case TK_EOT:", "end_of_token:", "*np = node_new_empty();", "CHECK_NULL_RETURN_MEMERR(*np);", "return tok->type;", "break;", "case TK_SUBEXP_OPEN:", "r = parse_bag(np, tok, TK_SUBEXP_CLOSE, src, end, env);", "if (r < 0) return r;", "if (r == 1) {", "if (group_head == 0)", "group = 1;", "else {", "Node* target = *np;", "*np = node_new_group(target);", "if (IS_NULL(*np)) {", "onig_node_free(target);", "return ONIGERR_MEMORY;", "}", "group = 2;", "}", "}", "else if (r == 2) {", "Node* target;", "OnigOptionType prev = env->options;", "env->options = BAG_(*np)->o.options;", "r = fetch_token(tok, src, end, env);", "if (r < 0) return r;", "r = parse_subexp(&target, tok, term, src, end, env, 0);", "env->options = prev;", "if (r < 0) {", "onig_node_free(target);", "return r;", "}", "NODE_BODY(*np) = target;", "return tok->type;", "}", "break;", "case TK_SUBEXP_CLOSE:", "if (! IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_UNMATCHED_CLOSE_SUBEXP))", "return ONIGERR_UNMATCHED_CLOSE_PARENTHESIS;", "if (tok->escaped) goto tk_raw_byte;", "else goto tk_byte;", "break;", "case TK_STRING:", "tk_byte:", "{", "*np = node_new_str(tok->backp, *src);", "CHECK_NULL_RETURN_MEMERR(*np);", "while (1) {", "r = fetch_token(tok, src, end, env);", "if (r < 0) return r;", "if (r != TK_STRING) break;", "r = onig_node_str_cat(*np, tok->backp, *src);", "if (r < 0) return r;", "}", "string_end:", "tp = np;", "goto repeat;", "}", "break;", "case TK_RAW_BYTE:", "tk_raw_byte:", "{", "*np = node_new_str_raw_char((UChar )tok->u.c);", "CHECK_NULL_RETURN_MEMERR(*np);", "len = 1;", "while (1) {", "if (len >= ONIGENC_MBC_MINLEN(env->enc)) {", "if (len == enclen(env->enc, STR_(*np)->s)) {", "r = fetch_token(tok, src, end, env);", "goto tk_raw_byte_end;", "}", "}", "r = fetch_token(tok, src, end, env);", "if (r < 0) return r;", "if (r != TK_RAW_BYTE)", "return ONIGERR_TOO_SHORT_MULTI_BYTE_STRING;", "r = node_str_cat_char(*np, (UChar )tok->u.c);", "if (r < 0) return r;", "len++;", "}", "tk_raw_byte_end:", "if (! ONIGENC_IS_VALID_MBC_STRING(env->enc, STR_(*np)->s, STR_(*np)->end))", "return ONIGERR_INVALID_WIDE_CHAR_VALUE;", "NODE_STRING_CLEAR_RAW(*np);", "goto string_end;", "}", "break;", "case TK_CODE_POINT:", "{", "UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN];", "len = ONIGENC_CODE_TO_MBC(env->enc, tok->u.code, buf);", "if (len < 0) return len;", "#ifdef NUMBERED_CHAR_IS_NOT_CASE_AMBIG", "*np = node_new_str_raw(buf, buf + len);", "#else", "*np = node_new_str(buf, buf + len);", "#endif", "CHECK_NULL_RETURN_MEMERR(*np);", "}", "break;", "case TK_QUOTE_OPEN:", "{", "OnigCodePoint end_op[2];", "UChar *qstart, *qend, *nextp;", "end_op[0] = (OnigCodePoint )MC_ESC(env->syntax);", "end_op[1] = (OnigCodePoint )'E';", "qstart = *src;", "qend = find_str_position(end_op, 2, qstart, end, &nextp, env->enc);", "if (IS_NULL(qend)) {", "nextp = qend = end;", "}", "*np = node_new_str(qstart, qend);", "CHECK_NULL_RETURN_MEMERR(*np);", "*src = nextp;", "}", "break;", "case TK_CHAR_TYPE:", "{", "switch (tok->u.prop.ctype) {", "case ONIGENC_CTYPE_WORD:", "*np = node_new_ctype(tok->u.prop.ctype, tok->u.prop.not, env->options);", "CHECK_NULL_RETURN_MEMERR(*np);", "break;", "case ONIGENC_CTYPE_SPACE:", "case ONIGENC_CTYPE_DIGIT:", "case ONIGENC_CTYPE_XDIGIT:", "{", "CClassNode* cc;", "*np = node_new_cclass();", "CHECK_NULL_RETURN_MEMERR(*np);", "cc = CCLASS_(*np);", "add_ctype_to_cc(cc, tok->u.prop.ctype, 0, env);", "if (tok->u.prop.not != 0) NCCLASS_SET_NOT(cc);", "}", "break;", "default:", "return ONIGERR_PARSER_BUG;", "break;", "}", "}", "break;", "case TK_CHAR_PROPERTY:", "r = parse_char_property(np, tok, src, end, env);", "if (r != 0) return r;", "break;", "case TK_CC_OPEN:", "{", "CClassNode* cc;", "r = parse_char_class(np, tok, src, end, env);", "if (r != 0) return r;", "cc = CCLASS_(*np);", "if (IS_IGNORECASE(env->options)) {", "IApplyCaseFoldArg iarg;", "iarg.env      = env;", "iarg.cc       = cc;", "iarg.alt_root = NULL_NODE;", "iarg.ptail    = &(iarg.alt_root);", "r = ONIGENC_APPLY_ALL_CASE_FOLD(env->enc, env->case_fold_flag,", "i_apply_case_fold, &iarg);", "if (r != 0) {", "onig_node_free(iarg.alt_root);", "return r;", "}", "if (IS_NOT_NULL(iarg.alt_root)) {", "Node* work = onig_node_new_alt(*np, iarg.alt_root);", "if (IS_NULL(work)) {", "onig_node_free(iarg.alt_root);", "return ONIGERR_MEMORY;", "}", "*np = work;", "}", "}", "}", "break;", "case TK_ANYCHAR:", "*np = node_new_anychar();", "CHECK_NULL_RETURN_MEMERR(*np);", "break;", "case TK_ANYCHAR_ANYTIME:", "*np = node_new_anychar();", "CHECK_NULL_RETURN_MEMERR(*np);", "qn = node_new_quantifier(0, INFINITE_REPEAT, 0);", "CHECK_NULL_RETURN_MEMERR(qn);", "NODE_BODY(qn) = *np;", "*np = qn;", "break;", "case TK_BACKREF:", "len = tok->u.backref.num;", "*np = node_new_backref(len,", "(len > 1 ? tok->u.backref.refs : &(tok->u.backref.ref1)),", "tok->u.backref.by_name,", "#ifdef USE_BACKREF_WITH_LEVEL", "tok->u.backref.exist_level,", "tok->u.backref.level,", "#endif", "env);", "CHECK_NULL_RETURN_MEMERR(*np);", "break;", "#ifdef USE_CALL", "case TK_CALL:", "{", "int gnum = tok->u.call.gnum;", "*np = node_new_call(tok->u.call.name, tok->u.call.name_end,", "gnum, tok->u.call.by_number);", "CHECK_NULL_RETURN_MEMERR(*np);", "env->num_call++;", "if (tok->u.call.by_number != 0 && gnum == 0) {", "env->has_call_zero = 1;", "}", "}", "break;", "#endif", "case TK_ANCHOR:", "{", "int ascii_mode =", "IS_WORD_ASCII(env->options) && IS_WORD_ANCHOR_TYPE(tok->u.anchor) ? 1 : 0;", "*np = onig_node_new_anchor(tok->u.anchor, ascii_mode);", "CHECK_NULL_RETURN_MEMERR(*np);", "}", "break;", "case TK_REPEAT:", "case TK_INTERVAL:", "if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_CONTEXT_INDEP_REPEAT_OPS)) {", "if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_CONTEXT_INVALID_REPEAT_OPS))", "return ONIGERR_TARGET_OF_REPEAT_OPERATOR_NOT_SPECIFIED;", "else {", "*np = node_new_empty();", "CHECK_NULL_RETURN_MEMERR(*np);", "}", "}", "else {", "goto tk_byte;", "}", "break;", "case TK_KEEP:", "r = node_new_keep(np, env);", "if (r < 0) return r;", "break;", "case TK_GENERAL_NEWLINE:", "r = node_new_general_newline(np, env);", "if (r < 0) return r;", "break;", "case TK_NO_NEWLINE:", "r = node_new_no_newline(np, env);", "if (r < 0) return r;", "break;", "case TK_TRUE_ANYCHAR:", "r = node_new_true_anychar(np, env);", "if (r < 0) return r;", "break;", "case TK_TEXT_SEGMENT:", "r = make_text_segment(np, env);", "if (r < 0) return r;", "break;", "default:", "return ONIGERR_PARSER_BUG;", "break;", "}", "{", "tp = np;", "re_entry:", "r = fetch_token(tok, src, end, env);", "if (r < 0) return r;", "repeat:", "if (r == TK_REPEAT || r == TK_INTERVAL) {", "Node* target;", "if (is_invalid_quantifier_target(*tp))", "return ONIGERR_TARGET_OF_REPEAT_OPERATOR_INVALID;", "qn = node_new_quantifier(tok->u.repeat.lower, tok->u.repeat.upper,", "r == TK_INTERVAL);", "CHECK_NULL_RETURN_MEMERR(qn);", "QUANT_(qn)->greedy = tok->u.repeat.greedy;", "if (group == 2) {", "target = node_drop_group(*tp);", "*tp = NULL_NODE;", "}", "else {", "target = *tp;", "}", "r = set_quantifier(qn, target, group, env);", "if (r < 0) {", "onig_node_free(qn);", "return r;", "}", "if (tok->u.repeat.possessive != 0) {", "Node* en;", "en = node_new_bag(BAG_STOP_BACKTRACK);", "if (IS_NULL(en)) {", "onig_node_free(qn);", "return ONIGERR_MEMORY;", "}", "NODE_BODY(en) = qn;", "qn = en;", "}", "if (r == 0) {", "*tp = qn;", "}", "else if (r == 1) {", "onig_node_free(qn);", "*tp = target;", "}", "else if (r == 2) {", "Node *tmp;", "*tp = node_new_list(*tp, NULL);", "if (IS_NULL(*tp)) {", "onig_node_free(qn);", "return ONIGERR_MEMORY;", "}", "tmp = NODE_CDR(*tp) = node_new_list(qn, NULL);", "if (IS_NULL(tmp)) {", "onig_node_free(qn);", "return ONIGERR_MEMORY;", "}", "tp = &(NODE_CAR(tmp));", "}", "group = 0;", "goto re_entry;", "}", "}", "return r;", "}"], "ner_tags": [0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["double GetGPMFSampleRateAndTimes(size_t handle, GPMF_stream *gs, double rate, uint32_t index, double *in, double *out)", "{", "mp4object *mp4 = (mp4object *)handle;", "if (mp4 == NULL) return 0.0;", "uint32_t key, insamples;", "uint32_t repeat, outsamples;", "GPMF_stream find_stream;", "if (gs == NULL || mp4->metaoffsets == 0 || mp4->indexcount == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in == NULL || out == NULL) return 0.0;", "key = GPMF_Key(gs);", "repeat = GPMF_Repeat(gs);", "if (rate == 0.0)", "rate = GetGPMFSampleRate(handle, key, GPMF_SAMPLE_RATE_FAST);", "if (rate == 0.0)", "{", "*in = *out = 0.0;", "return 0.0;", "}", "GPMF_CopyState(gs, &find_stream);", "if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))", "{", "outsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream));", "insamples = outsamples - repeat;", "*in = ((double)insamples / (double)rate);", "*out = ((double)outsamples / (double)rate);", "}", "else", "{", "*in = ((double)index * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);", "*out = ((double)(index + 1) * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);", "}", "return rate;", "}"], "ner_tags": [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0]}
{"tokens": ["fetch_token_in_cc(OnigToken* tok, UChar** src, UChar* end, ScanEnv* env)", "{", "int num;", "OnigCodePoint c, c2;", "OnigSyntaxType* syn = env->syntax;", "OnigEncoding enc = env->enc;", "UChar* prev;", "UChar* p = *src;", "PFETCH_READY;", "if (PEND) {", "tok->type = TK_EOT;", "return tok->type;", "}", "PFETCH(c);", "tok->type = TK_CHAR;", "tok->base = 0;", "tok->u.c  = c;", "tok->escaped = 0;", "if (c == ']') {", "tok->type = TK_CC_CLOSE;", "}", "else if (c == '-') {", "tok->type = TK_CC_RANGE;", "}", "else if (c == MC_ESC(syn)) {", "if (! IS_SYNTAX_BV(syn, ONIG_SYN_BACKSLASH_ESCAPE_IN_CC))", "goto end;", "if (PEND) return ONIGERR_END_PATTERN_AT_ESCAPE;", "PFETCH(c);", "tok->escaped = 1;", "tok->u.c = c;", "switch (c) {", "case 'w':", "tok->type = TK_CHAR_TYPE;", "tok->u.prop.ctype = ONIGENC_CTYPE_WORD;", "tok->u.prop.not   = 0;", "break;", "case 'W':", "tok->type = TK_CHAR_TYPE;", "tok->u.prop.ctype = ONIGENC_CTYPE_WORD;", "tok->u.prop.not   = 1;", "break;", "case 'd':", "tok->type = TK_CHAR_TYPE;", "tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;", "tok->u.prop.not   = 0;", "break;", "case 'D':", "tok->type = TK_CHAR_TYPE;", "tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;", "tok->u.prop.not   = 1;", "break;", "case 's':", "tok->type = TK_CHAR_TYPE;", "tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;", "tok->u.prop.not   = 0;", "break;", "case 'S':", "tok->type = TK_CHAR_TYPE;", "tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;", "tok->u.prop.not   = 1;", "break;", "case 'h':", "if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;", "tok->type = TK_CHAR_TYPE;", "tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;", "tok->u.prop.not   = 0;", "break;", "case 'H':", "if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;", "tok->type = TK_CHAR_TYPE;", "tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;", "tok->u.prop.not   = 1;", "break;", "case 'p':", "case 'P':", "if (PEND) break;", "c2 = PPEEK;", "if (c2 == '{' &&", "IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY)) {", "PINC;", "tok->type = TK_CHAR_PROPERTY;", "tok->u.prop.not = (c == 'P' ? 1 : 0);", "if (!PEND && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT)) {", "PFETCH(c2);", "if (c2 == '^') {", "tok->u.prop.not = (tok->u.prop.not == 0 ? 1 : 0);", "}", "else", "PUNFETCH;", "}", "}", "break;", "case 'x':", "if (PEND) break;", "prev = p;", "if (PPEEK_IS('{') && IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_BRACE_HEX8)) {", "PINC;", "num = scan_unsigned_hexadecimal_number(&p, end, 8, enc);", "if (num < 0) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;", "if (!PEND) {", "c2 = PPEEK;", "if (ONIGENC_IS_CODE_XDIGIT(enc, c2))", "return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE;", "}", "if (p > prev + enclen(enc, prev) && !PEND && (PPEEK_IS('}'))) {", "PINC;", "tok->type   = TK_CODE_POINT;", "tok->base   = 16;", "tok->u.code = (OnigCodePoint )num;", "}", "else {", "p = prev;", "}", "}", "else if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_HEX2)) {", "num = scan_unsigned_hexadecimal_number(&p, end, 2, enc);", "if (num < 0) return ONIGERR_TOO_BIG_NUMBER;", "if (p == prev) {", "num = 0;", "}", "tok->type = TK_RAW_BYTE;", "tok->base = 16;", "tok->u.c  = num;", "}", "break;", "case 'u':", "if (PEND) break;", "prev = p;", "if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_U_HEX4)) {", "num = scan_unsigned_hexadecimal_number(&p, end, 4, enc);", "if (num < 0) return ONIGERR_TOO_BIG_NUMBER;", "if (p == prev) {", "num = 0;", "}", "tok->type   = TK_CODE_POINT;", "tok->base   = 16;", "tok->u.code = (OnigCodePoint )num;", "}", "break;", "case '0':", "case '1': case '2': case '3': case '4': case '5': case '6': case '7':", "if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_OCTAL3)) {", "PUNFETCH;", "prev = p;", "num = scan_unsigned_octal_number(&p, end, 3, enc);", "if (num < 0) return ONIGERR_TOO_BIG_NUMBER;", "if (p == prev) {", "num = 0;", "}", "tok->type = TK_RAW_BYTE;", "tok->base = 8;", "tok->u.c  = num;", "}", "break;", "default:", "PUNFETCH;", "num = fetch_escaped_value(&p, end, env, &c2);", "if (num < 0) return num;", "if (tok->u.c != c2) {", "tok->u.code = c2;", "tok->type   = TK_CODE_POINT;", "}", "break;", "}", "}", "else if (c == '[') {", "if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_POSIX_BRACKET) && (PPEEK_IS(':'))) {", "OnigCodePoint send[] = { (OnigCodePoint )':', (OnigCodePoint )']' };", "tok->backp = p;", "PINC;", "if (str_exist_check_with_esc(send, 2, p, end,", "(OnigCodePoint )']', enc, syn)) {", "tok->type = TK_POSIX_BRACKET_OPEN;", "}", "else {", "PUNFETCH;", "goto cc_in_cc;", "}", "}", "else {", "cc_in_cc:", "if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_CCLASS_SET_OP)) {", "tok->type = TK_CC_CC_OPEN;", "}", "else {", "CC_ESC_WARN(env, (UChar* )\"[\");", "}", "}", "}", "else if (c == '&') {", "if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_CCLASS_SET_OP) &&", "!PEND && (PPEEK_IS('&'))) {", "PINC;", "tok->type = TK_CC_AND;", "}", "}", "end:", "*src = p;", "return tok->type;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static Bool hevc_parse_vps_extension(HEVC_VPS *vps, GF_BitStream *bs)", "{", "u8 splitting_flag, vps_nuh_layer_id_present_flag, view_id_len;", "u32 i, j, num_scalability_types, num_add_olss, num_add_layer_set, num_indepentdent_layers, nb_bits, default_output_layer_idc = 0;", "u8 dimension_id_len[16], dim_bit_offset[16];", "u8                          NumLayerSets,                                           rep_format_idx_present_flag, ols_ids_to_ls_idx;", "u8 layer_set_idx_for_ols_minus1[MAX_LHVC_LAYERS];", "u8 nb_output_layers_in_output_layer_set[MAX_LHVC_LAYERS + 1];", "u8 ols_highest_output_layer_id[MAX_LHVC_LAYERS + 1];", "u32 k, d, r, p, iNuhLId, jNuhLId;", "u8 num_direct_ref_layers[64], num_pred_layers[64], num_layers_in_tree_partition[MAX_LHVC_LAYERS];", "u8 dependency_flag[MAX_LHVC_LAYERS][MAX_LHVC_LAYERS], id_pred_layers[64][MAX_LHVC_LAYERS];", "u8 layer_id_in_list_flag[64];", "Bool OutputLayerFlag[MAX_LHVC_LAYERS][MAX_LHVC_LAYERS];", "vps->vps_extension_found = 1;", "if ((vps->max_layers > 1) && vps->base_layer_internal_flag)", "hevc_profile_tier_level(bs, 0, vps->max_sub_layers - 1, &vps->ext_ptl[0], 0);", "splitting_flag = gf_bs_read_int_log(bs, 1, \"splitting_flag\");", "num_scalability_types = 0;", "for (i = 0; i < 16; i++) {", "vps->scalability_mask[i] = gf_bs_read_int_log_idx(bs, 1, \"scalability_mask\", i);", "num_scalability_types += vps->scalability_mask[i];", "}", "if (num_scalability_types >= 16) {", "num_scalability_types = 16;", "}", "dimension_id_len[0] = 0;", "for (i = 0; i < (num_scalability_types - splitting_flag); i++) {", "dimension_id_len[i] = 1 + gf_bs_read_int_log_idx(bs, 3, \"dimension_id_len_minus1\", i);", "}", "if (splitting_flag) {", "for (i = 0; i < num_scalability_types; i++) {", "dim_bit_offset[i] = 0;", "for (j = 0; j < i; j++)", "dim_bit_offset[i] += dimension_id_len[j];", "}", "dimension_id_len[num_scalability_types - 1] = 1 + (5 - dim_bit_offset[num_scalability_types - 1]);", "dim_bit_offset[num_scalability_types] = 6;", "}", "vps_nuh_layer_id_present_flag = gf_bs_read_int_log(bs, 1, \"vps_nuh_layer_id_present_flag\");", "vps->layer_id_in_nuh[0] = 0;", "vps->layer_id_in_vps[0] = 0;", "for (i = 1; i < vps->max_layers; i++) {", "if (vps_nuh_layer_id_present_flag) {", "vps->layer_id_in_nuh[i] = gf_bs_read_int_log_idx(bs, 6, \"layer_id_in_nuh\", i);", "}", "else {", "vps->layer_id_in_nuh[i] = i;", "}", "vps->layer_id_in_vps[vps->layer_id_in_nuh[i]] = i;", "if (!splitting_flag) {", "for (j = 0; j < num_scalability_types; j++) {", "vps->dimension_id[i][j] = gf_bs_read_int_log_idx2(bs, dimension_id_len[j], \"dimension_id\", i, j);", "}", "}", "}", "if (splitting_flag) {", "for (i = 0; i < vps->max_layers; i++)", "for (j = 0; j < num_scalability_types; j++)", "vps->dimension_id[i][j] = ((vps->layer_id_in_nuh[i] & ((1 << dim_bit_offset[j + 1]) - 1)) >> dim_bit_offset[j]);", "}", "else {", "for (j = 0; j < num_scalability_types; j++)", "vps->dimension_id[0][j] = 0;", "}", "view_id_len = gf_bs_read_int_log(bs, 4, \"view_id_len\");", "if (view_id_len > 0) {", "for (i = 0; i < lhvc_get_num_views(vps); i++) {", "gf_bs_read_int_log_idx(bs, view_id_len, \"view_id_val\", i);", "}", "}", "for (i = 1; i < vps->max_layers; i++) {", "for (j = 0; j < i; j++) {", "vps->direct_dependency_flag[i][j] = gf_bs_read_int_log_idx(bs, 1, \"direct_dependency_flag\", i);", "}", "}", "for (i = 0; i < MAX_LHVC_LAYERS; i++) {", "if (i >= vps->max_layers) break;", "for (j = 0; j < vps->max_layers; j++) {", "dependency_flag[i][j] = vps->direct_dependency_flag[i][j];", "for (k = 0; k < i; k++)", "if (vps->direct_dependency_flag[i][k] && vps->direct_dependency_flag[k][j])", "dependency_flag[i][j] = 1;", "}", "}", "for (i = 0; i < vps->max_layers; i++) {", "iNuhLId = vps->layer_id_in_nuh[i];", "d = r = p = 0;", "for (j = 0; j < vps->max_layers; j++) {", "jNuhLId = vps->layer_id_in_nuh[j];", "if (vps->direct_dependency_flag[i][j]) {", "d++;", "}", "if (dependency_flag[i][j]) {", "r++;", "}", "if (dependency_flag[j][i])", "id_pred_layers[iNuhLId][p++] = jNuhLId;", "}", "num_direct_ref_layers[iNuhLId] = d;", "num_pred_layers[iNuhLId] = p;", "}", "memset(layer_id_in_list_flag, 0, 64 * sizeof(u8));", "k = 0;", "for (i = 0; i < vps->max_layers; i++) {", "iNuhLId = vps->layer_id_in_nuh[i];", "if (!num_direct_ref_layers[iNuhLId]) {", "u32 h = 1;", "for (j = 0; j < num_pred_layers[iNuhLId]; j++) {", "u32 predLId = id_pred_layers[iNuhLId][j];", "if (!layer_id_in_list_flag[predLId]) {", "layer_id_in_list_flag[predLId] = 1;", "}", "}", "num_layers_in_tree_partition[k++] = h;", "}", "}", "num_indepentdent_layers = k;", "num_add_layer_set = 0;", "if (num_indepentdent_layers > 1)", "num_add_layer_set = gf_bs_read_ue_log(bs, \"num_add_layer_set\");", "for (i = 0; i < num_add_layer_set; i++)", "for (j = 1; j < num_indepentdent_layers; j++) {", "nb_bits = 1;", "while ((1 << nb_bits) < (num_layers_in_tree_partition[j] + 1))", "nb_bits++;", "gf_bs_read_int_log_idx2(bs, nb_bits, \"highest_layer_idx_plus1\", i, j);", "}", "if (gf_bs_read_int_log(bs, 1, \"vps_sub_layers_max_minus1_present_flag\")) {", "for (i = 0; i < vps->max_layers; i++) {", "gf_bs_read_int_log_idx(bs, 3, \"sub_layers_vps_max_minus1\", i);", "}", "}", "if (gf_bs_read_int_log(bs, 1, \"max_tid_ref_present_flag\")) {", "for (i = 0; i < (vps->max_layers - 1); i++) {", "for (j = i + 1; j < vps->max_layers; j++) {", "if (vps->direct_dependency_flag[j][i])", "gf_bs_read_int_log_idx2(bs, 3, \"max_tid_il_ref_pics_plus1\", i, j);", "}", "}", "}", "gf_bs_read_int_log(bs, 1, \"default_ref_layers_active_flag\");", "vps->num_profile_tier_level = 1 + gf_bs_read_ue_log(bs, \"num_profile_tier_level\");", "if (vps->num_profile_tier_level > MAX_LHVC_LAYERS) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Wrong number of PTLs in VPS %d\\n\", vps->num_profile_tier_level));", "vps->num_profile_tier_level = 1;", "return GF_FALSE;", "}", "for (i = vps->base_layer_internal_flag ? 2 : 1; i < vps->num_profile_tier_level; i++) {", "Bool vps_profile_present_flag = gf_bs_read_int_log_idx(bs, 1, \"vps_profile_present_flag\", i);", "hevc_profile_tier_level(bs, vps_profile_present_flag, vps->max_sub_layers - 1, &vps->ext_ptl[i - 1], i-1);", "}", "NumLayerSets = vps->num_layer_sets + num_add_layer_set;", "num_add_olss = 0;", "if (NumLayerSets > 1) {", "num_add_olss = gf_bs_read_ue_log(bs, \"num_add_olss\");", "default_output_layer_idc = gf_bs_read_int_log(bs, 2, \"default_output_layer_idc\");", "default_output_layer_idc = default_output_layer_idc < 2 ? default_output_layer_idc : 2;", "}", "vps->num_output_layer_sets = num_add_olss + NumLayerSets;", "layer_set_idx_for_ols_minus1[0] = 1;", "vps->output_layer_flag[0][0] = 1;", "for (i = 0; i < vps->num_output_layer_sets; i++) {", "if ((NumLayerSets > 2) && (i >= NumLayerSets)) {", "nb_bits = 1;", "while ((1 << nb_bits) < (NumLayerSets - 1))", "nb_bits++;", "layer_set_idx_for_ols_minus1[i] = gf_bs_read_int_log_idx(bs, nb_bits, \"layer_set_idx_for_ols_minus1\", i);", "}", "else", "layer_set_idx_for_ols_minus1[i] = 0;", "ols_ids_to_ls_idx = i < NumLayerSets ? i : layer_set_idx_for_ols_minus1[i] + 1;", "if ((i > (vps->num_layer_sets - 1)) || (default_output_layer_idc == 2)) {", "for (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++)", "vps->output_layer_flag[i][j] = gf_bs_read_int_log_idx2(bs, 1, \"output_layer_flag\", i, j);", "}", "if ((default_output_layer_idc == 0) || (default_output_layer_idc == 1)) {", "for (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {", "if ((default_output_layer_idc == 0) || (vps->LayerSetLayerIdList[i][j] == vps->LayerSetLayerIdListMax[i]))", "OutputLayerFlag[i][j] = GF_TRUE;", "else", "OutputLayerFlag[i][j] = GF_FALSE;", "}", "}", "for (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {", "if (OutputLayerFlag[i][j]) {", "u32 curLayerID;", "vps->necessary_layers_flag[i][j] = GF_TRUE;", "curLayerID = vps->LayerSetLayerIdList[i][j];", "for (k = 0; k < j; k++) {", "u32 refLayerId = vps->LayerSetLayerIdList[i][k];", "if (dependency_flag[vps->layer_id_in_vps[curLayerID]][vps->layer_id_in_vps[refLayerId]])", "vps->necessary_layers_flag[i][k] = GF_TRUE;", "}", "}", "}", "vps->num_necessary_layers[i] = 0;", "for (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {", "if (vps->necessary_layers_flag[i][j])", "vps->num_necessary_layers[i] += 1;", "}", "if (i == 0) {", "if (vps->base_layer_internal_flag) {", "if (vps->max_layers > 1)", "vps->profile_tier_level_idx[0][0] = 1;", "else", "vps->profile_tier_level_idx[0][0] = 0;", "}", "continue;", "}", "nb_bits = 1;", "while ((u32)(1 << nb_bits) < vps->num_profile_tier_level)", "nb_bits++;", "for (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++)", "if (vps->necessary_layers_flag[i][j] && vps->num_profile_tier_level)", "vps->profile_tier_level_idx[i][j] = gf_bs_read_int_log_idx2(bs, nb_bits, \"profile_tier_level_idx\", i, j);", "else", "vps->profile_tier_level_idx[i][j] = 0;", "nb_output_layers_in_output_layer_set[i] = 0;", "for (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {", "nb_output_layers_in_output_layer_set[i] += OutputLayerFlag[i][j];", "if (OutputLayerFlag[i][j]) {", "ols_highest_output_layer_id[i] = vps->LayerSetLayerIdList[ols_ids_to_ls_idx][j];", "}", "}", "if (nb_output_layers_in_output_layer_set[i] == 1 && ols_highest_output_layer_id[i] > 0)", "vps->alt_output_layer_flag[i] = gf_bs_read_int_log_idx(bs, 1, \"alt_output_layer_flag\", i);", "}", "vps->num_rep_formats = 1 + gf_bs_read_ue_log(bs, \"num_rep_formats_minus1\");", "if (vps->num_rep_formats > 16) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Wrong number of rep formats in VPS %d\\n\", vps->num_rep_formats));", "vps->num_rep_formats = 0;", "return GF_FALSE;", "}", "for (i = 0; i < vps->num_rep_formats; i++) {", "lhvc_parse_rep_format(&vps->rep_formats[i], bs, i);", "}", "if (vps->num_rep_formats > 1)", "rep_format_idx_present_flag = gf_bs_read_int_log(bs, 1, \"rep_format_idx_present_flag\");", "else", "rep_format_idx_present_flag = 0;", "vps->rep_format_idx[0] = 0;", "nb_bits = 1;", "while ((u32)(1 << nb_bits) < vps->num_rep_formats)", "nb_bits++;", "for (i = vps->base_layer_internal_flag ? 1 : 0; i < vps->max_layers; i++) {", "if (rep_format_idx_present_flag) {", "vps->rep_format_idx[i] = gf_bs_read_int_log_idx(bs, nb_bits, \"rep_format_idx\", i);", "}", "else {", "vps->rep_format_idx[i] = i < vps->num_rep_formats - 1 ? i : vps->num_rep_formats - 1;", "}", "}", "return GF_TRUE;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int bmp_validate(jas_stream_t *in)", "  {", "  \tint n;", "  \tint i;", "\tuchar buf[2];", " \tjas_uchar buf[2];", "  \tassert(JAS_STREAM_MAXPUTBACK >= 2);", " \tif ((n = jas_stream_read(in, (char *) buf, 2)) < 0) {", " \t\treturn -1;", " \t}", " \tfor (i = n - 1; i >= 0; --i) {", " \t\tif (jas_stream_ungetc(in, buf[i]) == EOF) {", " \t\t\treturn -1;", " \t\t}", " \t}", " \tif (n < 2) {", " \t\treturn -1;", " \t}", " \tif (buf[0] == (BMP_MAGIC & 0xff) && buf[1] == (BMP_MAGIC >> 8)) {", " \t\treturn 0;", " \t}", " \treturn -1;", " }"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static void build_l4proto_tcp(const struct nf_conntrack *ct, struct nethdr *n)", "  {", "\tct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,", "\t\t      sizeof(struct nfct_attr_grp_port));", "  \tif (!nfct_attr_is_set(ct, ATTR_TCP_STATE))", "  \t\treturn;", " \tct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,", " \t\t      sizeof(struct nfct_attr_grp_port));", "  \tct_build_u8(ct, ATTR_TCP_STATE, n, NTA_TCP_STATE);", "  \tif (CONFIG(sync).tcp_window_tracking) {", "  \t\tct_build_u8(ct, ATTR_TCP_WSCALE_ORIG, n, NTA_TCP_WSCALE_ORIG);", " \t\tct_build_u8(ct, ATTR_TCP_WSCALE_REPL, n, NTA_TCP_WSCALE_REPL);", " \t}", " }"], "ner_tags": [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" hstore_from_array(PG_FUNCTION_ARGS)", " {", " \tArrayType  *in_array = PG_GETARG_ARRAYTYPE_P(0);", " \tint\t\t\tndims = ARR_NDIM(in_array);", " \tint\t\t\tcount;", " \tint32\t\tbuflen;", " \tHStore\t   *out;", " \tPairs\t   *pairs;", " \tDatum\t   *in_datums;", " \tbool\t   *in_nulls;", " \tint\t\t\tin_count;", " \tint\t\t\ti;", " \tAssert(ARR_ELEMTYPE(in_array) == TEXTOID);", " \tswitch (ndims)", " \t{", " \t\tcase 0:", " \t\t\tout = hstorePairs(NULL, 0, 0);", " \t\t\tPG_RETURN_POINTER(out);", " \t\tcase 1:", " \t\t\tif ((ARR_DIMS(in_array)[0]) % 2)", " \t\t\t\tereport(ERROR,", " \t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),", " \t\t\t\t\t\t errmsg(\"array must have even number of elements\")));", " \t\t\tbreak;", " \t\tcase 2:", " \t\t\tif ((ARR_DIMS(in_array)[1]) != 2)", " \t\t\t\tereport(ERROR,", " \t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),", " \t\t\t\t\t\t errmsg(\"array must have two columns\")));", " \t\t\tbreak;", " \t\tdefault:", " \t\t\tereport(ERROR,", " \t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),", " \t\t\t\t\t errmsg(\"wrong number of array subscripts\")));", " \t}", " \tdeconstruct_array(in_array,", " \t\t\t\t\t  TEXTOID, -1, false, 'i',", " \t\t\t\t\t  &in_datums, &in_nulls, &in_count);", "  \tcount = in_count / 2;", " \tif (count > MaxAllocSize / sizeof(Pairs))", " \t\tereport(ERROR,", " \t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),", " \t\t\t  errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",", " \t\t\t\t\t count, (int) (MaxAllocSize / sizeof(Pairs)))));", "  \tpairs = palloc(count * sizeof(Pairs));", "  \tfor (i = 0; i < count; ++i)", " \t{", " \t\tif (in_nulls[i * 2])", " \t\t\tereport(ERROR,", " \t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),", " \t\t\t\t\t errmsg(\"null value not allowed for hstore key\")));", " \t\tif (in_nulls[i * 2 + 1])", " \t\t{", " \t\t\tpairs[i].key = VARDATA_ANY(in_datums[i * 2]);", " \t\t\tpairs[i].val = NULL;", " \t\t\tpairs[i].keylen = hstoreCheckKeyLen(VARSIZE_ANY_EXHDR(in_datums[i * 2]));", " \t\t\tpairs[i].vallen = 4;", " \t\t\tpairs[i].isnull = true;", " \t\t\tpairs[i].needfree = false;", " \t\t}", " \t\telse", " \t\t{", " \t\t\tpairs[i].key = VARDATA_ANY(in_datums[i * 2]);", " \t\t\tpairs[i].val = VARDATA_ANY(in_datums[i * 2 + 1]);", " \t\t\tpairs[i].keylen = hstoreCheckKeyLen(VARSIZE_ANY_EXHDR(in_datums[i * 2]));", " \t\t\tpairs[i].vallen = hstoreCheckValLen(VARSIZE_ANY_EXHDR(in_datums[i * 2 + 1]));", " \t\t\tpairs[i].isnull = false;", " \t\t\tpairs[i].needfree = false;", " \t\t}", " \t}", " \tcount = hstoreUniquePairs(pairs, count, &buflen);", " \tout = hstorePairs(pairs, count, buflen);", " \tPG_RETURN_POINTER(out);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" psf_close (SF_PRIVATE *psf)", " {\tuint32_t k ;", " \tint\terror = 0 ;", " \tif (psf->codec_close)", " \t{\terror = psf->codec_close (psf) ;", " \t\tpsf->codec_close = NULL ;", " \t\t} ;", " \tif (psf->container_close)", " \t\terror = psf->container_close (psf) ;", " \terror = psf_fclose (psf) ;", "  \tpsf_close_rsrc (psf) ;", " \tfree (psf->header.ptr) ;", "  \tfree (psf->container_data) ;", "  \tfree (psf->codec_data) ;", "  \tfree (psf->interleave) ;", " \tfree (psf->dither) ;", " \tfree (psf->peak_info) ;", " \tfree (psf->broadcast_16k) ;", " \tfree (psf->loop_info) ;", " \tfree (psf->instrument) ;", " \tfree (psf->cues) ;", " \tfree (psf->channel_map) ;", " \tfree (psf->format_desc) ;", " \tfree (psf->strings.storage) ;", " \tif (psf->wchunks.chunks)", " \t\tfor (k = 0 ; k < psf->wchunks.used ; k++)", " \t\t\tfree (psf->wchunks.chunks [k].data) ;", " \tfree (psf->rchunks.chunks) ;", " \tfree (psf->wchunks.chunks) ;", " \tfree (psf->iterator) ;", " \tfree (psf->cart_16k) ;", " \tmemset (psf, 0, sizeof (SF_PRIVATE)) ;", " \tfree (psf) ;", " \treturn error ;", " }  "], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" ZSTD_buildCTable(void* dst, size_t dstCapacity,", "                 FSE_CTable* nextCTable, U32 FSELog, symbolEncodingType_e type,", "                 U32* count, U32 max,", "                 const BYTE* codeTable, size_t nbSeq,", "                 const S16* defaultNorm, U32 defaultNormLog, U32 defaultMax,", "                 const FSE_CTable* prevCTable, size_t prevCTableSize,", "                 void* workspace, size_t workspaceSize)", "  {", "      BYTE* op = (BYTE*)dst;", "      const BYTE* const oend = op + dstCapacity;", "     DEBUGLOG(6, \"ZSTD_buildCTable (dstCapacity=%u)\", (unsigned)dstCapacity);", "      switch (type) {", "      case set_rle:", "        *op = codeTable[0];", "          CHECK_F(FSE_buildCTable_rle(nextCTable, (BYTE)max));", "         if (dstCapacity==0) return ERROR(dstSize_tooSmall);", "         *op = codeTable[0];", "          return 1;", "      case set_repeat:", "          memcpy(nextCTable, prevCTable, prevCTableSize);", "         return 0;", "     case set_basic:", "         CHECK_F(FSE_buildCTable_wksp(nextCTable, defaultNorm, defaultMax, defaultNormLog, workspace, workspaceSize));   ", "         return 0;", "     case set_compressed: {", "         S16 norm[MaxSeq + 1];", "         size_t nbSeq_1 = nbSeq;", "         const U32 tableLog = FSE_optimalTableLog(FSELog, nbSeq, max);", "         if (count[codeTable[nbSeq-1]] > 1) {", "             count[codeTable[nbSeq-1]]--;", "             nbSeq_1--;", "         }", "         assert(nbSeq_1 > 1);", "         CHECK_F(FSE_normalizeCount(norm, tableLog, count, nbSeq_1, max));", "         {   size_t const NCountSize = FSE_writeNCount(op, oend - op, norm, max, tableLog);    ", "             if (FSE_isError(NCountSize)) return NCountSize;", "             CHECK_F(FSE_buildCTable_wksp(nextCTable, norm, max, tableLog, workspace, workspaceSize));", "             return NCountSize;", "         }", "     }", "     default: return assert(0), ERROR(GENERIC);", "     }", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  void jas_matrix_asl(jas_matrix_t *matrix, int n)", "  {", "\tint i;", "\tint j;", " \tjas_matind_t i;", " \tjas_matind_t j;", "  \tjas_seqent_t *rowstart;", "\tint rowstep;", " \tjas_matind_t rowstep;", "  \tjas_seqent_t *data;", "  \tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {", " \t\tassert(matrix->rows_);", " \t\trowstep = jas_matrix_rowstep(matrix);", " \t\tfor (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,", " \t\t  rowstart += rowstep) {", " \t\t\tfor (j = matrix->numcols_, data = rowstart; j > 0; --j,", " \t\t\t  ++data) {", " \t\t\t\t*data = jas_seqent_asl(*data, n);", " \t\t\t}", " \t\t}", " \t}", " }"], "ner_tags": [0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" GF_Err dinf_Read(GF_Box *s, GF_BitStream *bs)", " {", " \tGF_Err e = gf_isom_box_array_read(s, bs, dinf_AddBox);", " \tif (e) {", "  \t\treturn e;", "  \t}", "  \tif (!((GF_DataInformationBox *)s)->dref) {", " \t\tGF_Box* dref;", "  \t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing dref box in dinf\\n\"));", "\t\t((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);", " \t\tdref = gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);", " \t\t((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)dref;", " \t\tgf_isom_box_add_for_dump_mode(s, dref);", "  \t}", "  \treturn GF_OK;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": [" jp2_box_t *jp2_box_create(int type)", " jp2_box_t *jp2_box_create0()", "  {", "  \tjp2_box_t *box;", "\tjp2_boxinfo_t *boxinfo;", "  \tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {", "  \t\treturn 0;", "  \t}", "  \tmemset(box, 0, sizeof(jp2_box_t));", " \tbox->type = 0;", " \tbox->len = 0;", " \tbox->ops = &jp2_boxinfo_unk.ops;", " \treturn box;", " }", " jp2_box_t *jp2_box_create(int type)", " {", " \tjp2_box_t *box;", " \tjp2_boxinfo_t *boxinfo;", " \tif (!(box = jp2_box_create0())) {", " \t\treturn 0;", " \t}", "  \tbox->type = type;", "  \tbox->len = 0;", "  \tif (!(boxinfo = jp2_boxinfolookup(type))) {", " \t\treturn 0;", " \t}", " \tbox->info = boxinfo;", " \tbox->ops = &boxinfo->ops;", " \treturn box;", " }"], "ner_tags": [0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" decrypt_response(struct sc_card *card, unsigned char *in, size_t inlen, unsigned char *out, size_t * out_len)", " {", " \tsize_t cipher_len;", " \tsize_t i;", " \tunsigned char iv[16] = { 0 };", " \tunsigned char plaintext[4096] = { 0 };", " \tepass2003_exdata *exdata = NULL;", " \tif (!card->drv_data) ", " \t\treturn SC_ERROR_INVALID_ARGUMENTS;", " \texdata = (epass2003_exdata *)card->drv_data;", " \tif (in[0] == 0x99)", " \t\treturn 0;", " \tif (0x01 == in[2] && 0x82 != in[1]) {", " \t\tcipher_len = in[1];", " \t\ti = 3;", " \t}", " \telse if (0x01 == in[3] && 0x81 == in[1]) {", " \t\tcipher_len = in[2];", " \t\ti = 4;", " \t}", " \telse if (0x01 == in[4] && 0x82 == in[1]) {", " \t\tcipher_len = in[2] * 0x100;", " \t\tcipher_len += in[3];", " \t\ti = 5;", " \t}", " \telse {", " \t\treturn -1;", " \t}", " \tif (cipher_len < 2 || i+cipher_len > inlen || cipher_len > sizeof plaintext)", " \t\treturn -1;", " \tif (KEY_TYPE_AES == exdata->smtype)", " \t\taes128_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], cipher_len - 1, plaintext);", " \telse", " \t\tdes3_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], cipher_len - 1, plaintext);", "  \twhile (0x80 != plaintext[cipher_len - 2] && (cipher_len - 2 > 0))", "  \t\tcipher_len--;", "\tif (2 == cipher_len)", " \tif (2 == cipher_len || *out_len < cipher_len - 2)", "  \t\treturn -1;", "  \tmemcpy(out, plaintext, cipher_len - 2);", " \t*out_len = cipher_len - 2;", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" static int dnxhd_decode_header(DNXHDContext *ctx, AVFrame *frame,", "                                const uint8_t *buf, int buf_size,", "                                int first_field)", " {", "     int i, cid, ret;", "     int old_bit_depth = ctx->bit_depth, bitdepth;", "     uint64_t header_prefix;", "     if (buf_size < 0x280) {", "         av_log(ctx->avctx, AV_LOG_ERROR,", "                \"buffer too small (%d < 640).\\n\", buf_size);", "         return AVERROR_INVALIDDATA;", "     }", "     header_prefix = ff_dnxhd_parse_header_prefix(buf);", "     if (header_prefix == 0) {", "         av_log(ctx->avctx, AV_LOG_ERROR,", "                \"unknown header 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X\\n\",", "                buf[0], buf[1], buf[2], buf[3], buf[4]);", "         return AVERROR_INVALIDDATA;", "     }", "     if (buf[5] & 2) {  ", "         ctx->cur_field = buf[5] & 1;", "         frame->interlaced_frame = 1;", "         frame->top_field_first  = first_field ^ ctx->cur_field;", "         av_log(ctx->avctx, AV_LOG_DEBUG,", "                \"interlaced %d, cur field %d\\n\", buf[5] & 3, ctx->cur_field);", "     } else {", "         ctx->cur_field = 0;", "     }", "     ctx->mbaff = (buf[0x6] >> 5) & 1;", "     ctx->height = AV_RB16(buf + 0x18);", "     ctx->width  = AV_RB16(buf + 0x1a);", "     switch(buf[0x21] >> 5) {", "     case 1: bitdepth = 8; break;", "     case 2: bitdepth = 10; break;", "     case 3: bitdepth = 12; break;", "     default:", "         av_log(ctx->avctx, AV_LOG_ERROR,", "                \"Unknown bitdepth indicator (%d)\\n\", buf[0x21] >> 5);", "         return AVERROR_INVALIDDATA;", "     }", "     cid = AV_RB32(buf + 0x28);", "     ctx->avctx->profile = dnxhd_get_profile(cid);", "     if ((ret = dnxhd_init_vlc(ctx, cid, bitdepth)) < 0)", "         return ret;", "     if (ctx->mbaff && ctx->cid_table->cid != 1260)", "         av_log(ctx->avctx, AV_LOG_WARNING,", "                \"Adaptive MB interlace flag in an unsupported profile.\\n\");", "     ctx->act = buf[0x2C] & 7;", "     if (ctx->act && ctx->cid_table->cid != 1256 && ctx->cid_table->cid != 1270)", "         av_log(ctx->avctx, AV_LOG_WARNING,", "                \"Adaptive color transform in an unsupported profile.\\n\");", "     ctx->is_444 = (buf[0x2C] >> 6) & 1;", "     if (ctx->is_444) {", "         if (bitdepth == 8) {", "             avpriv_request_sample(ctx->avctx, \"4:4:4 8 bits\");", "             return AVERROR_INVALIDDATA;", "         } else if (bitdepth == 10) {", "             ctx->decode_dct_block = dnxhd_decode_dct_block_10_444;", "             ctx->pix_fmt = ctx->act ? AV_PIX_FMT_YUV444P10", "                                     : AV_PIX_FMT_GBRP10;", "         } else {", "             ctx->decode_dct_block = dnxhd_decode_dct_block_12_444;", "             ctx->pix_fmt = ctx->act ? AV_PIX_FMT_YUV444P12", "                                     : AV_PIX_FMT_GBRP12;", "         }", "     } else if (bitdepth == 12) {", "         ctx->decode_dct_block = dnxhd_decode_dct_block_12;", "         ctx->pix_fmt = AV_PIX_FMT_YUV422P12;", "     } else if (bitdepth == 10) {", "         if (ctx->avctx->profile == FF_PROFILE_DNXHR_HQX)", "             ctx->decode_dct_block = dnxhd_decode_dct_block_10_444;", "         else", "             ctx->decode_dct_block = dnxhd_decode_dct_block_10;", "         ctx->pix_fmt = AV_PIX_FMT_YUV422P10;", "     } else {", "         ctx->decode_dct_block = dnxhd_decode_dct_block_8;", "         ctx->pix_fmt = AV_PIX_FMT_YUV422P;", "     }", "     ctx->avctx->bits_per_raw_sample = ctx->bit_depth = bitdepth;", "     if (ctx->bit_depth != old_bit_depth) {", "         ff_blockdsp_init(&ctx->bdsp, ctx->avctx);", "         ff_idctdsp_init(&ctx->idsp, ctx->avctx);", "         ff_init_scantable(ctx->idsp.idct_permutation, &ctx->scantable,", "                           ff_zigzag_direct);", "     }", "     if (ctx->width != ctx->cid_table->width &&", "         ctx->cid_table->width != DNXHD_VARIABLE) {", "         av_reduce(&ctx->avctx->sample_aspect_ratio.num,", "                   &ctx->avctx->sample_aspect_ratio.den,", "                   ctx->width, ctx->cid_table->width, 255);", "         ctx->width = ctx->cid_table->width;", "     }", "     if (buf_size < ctx->cid_table->coding_unit_size) {", "         av_log(ctx->avctx, AV_LOG_ERROR, \"incorrect frame size (%d < %u).\\n\",", "                buf_size, ctx->cid_table->coding_unit_size);", "         return AVERROR_INVALIDDATA;", "     }", "     ctx->mb_width  = (ctx->width + 15)>> 4;", "     ctx->mb_height = AV_RB16(buf + 0x16c);", "     if ((ctx->height + 15) >> 4 == ctx->mb_height && frame->interlaced_frame)", "         ctx->height <<= 1;", "     av_log(ctx->avctx, AV_LOG_VERBOSE, \"%dx%d, 4:%s %d bits, MBAFF=%d ACT=%d\\n\",", "            ctx->width, ctx->height, ctx->is_444 ? \"4:4\" : \"2:2\",", "            ctx->bit_depth, ctx->mbaff, ctx->act);", "      if (ctx->mb_height > 68 && ff_dnxhd_check_header_prefix_hr(header_prefix)) {", "          ctx->data_offset = 0x170 + (ctx->mb_height << 2);", "      } else {", "        if (ctx->mb_height > 68 ||", "            (ctx->mb_height << frame->interlaced_frame) > (ctx->height + 15) >> 4) {", "         if (ctx->mb_height > 68) {", "              av_log(ctx->avctx, AV_LOG_ERROR,", "                     \"mb height too big: %d\\n\", ctx->mb_height);", "              return AVERROR_INVALIDDATA;", "          }", "          ctx->data_offset = 0x280;", "      }", "     if ((ctx->mb_height << frame->interlaced_frame) > (ctx->height + 15) >> 4) {", "         av_log(ctx->avctx, AV_LOG_ERROR,", "                 \"mb height too big: %d\\n\", ctx->mb_height);", "         return AVERROR_INVALIDDATA;", "     }", "      if (buf_size < ctx->data_offset) {", "          av_log(ctx->avctx, AV_LOG_ERROR,", "                \"buffer too small (%d < %d).\\n\", buf_size, ctx->data_offset);", "         return AVERROR_INVALIDDATA;", "     }", "     if (ctx->mb_height > FF_ARRAY_ELEMS(ctx->mb_scan_index)) {", "         av_log(ctx->avctx, AV_LOG_ERROR,", "                \"mb_height too big (%d > %\"SIZE_SPECIFIER\").\\n\", ctx->mb_height, FF_ARRAY_ELEMS(ctx->mb_scan_index));", "         return AVERROR_INVALIDDATA;", "     }", "     for (i = 0; i < ctx->mb_height; i++) {", "         ctx->mb_scan_index[i] = AV_RB32(buf + 0x170 + (i << 2));", "         ff_dlog(ctx->avctx, \"mb scan index %d, pos %d: %\"PRIu32\"\\n\",", "                 i, 0x170 + (i << 2), ctx->mb_scan_index[i]);", "         if (buf_size - ctx->data_offset < ctx->mb_scan_index[i]) {", "             av_log(ctx->avctx, AV_LOG_ERROR,", "                    \"invalid mb scan index (%\"PRIu32\" vs %u).\\n\",", "                    ctx->mb_scan_index[i], buf_size - ctx->data_offset);", "             return AVERROR_INVALIDDATA;", "         }", "     }", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int cg_getattr(const char *path, struct stat *sb)", " {", " \tstruct timespec now;", " \tstruct fuse_context *fc = fuse_get_context();", " \tchar * cgdir = NULL;", " \tchar *fpath = NULL, *path1, *path2;", " \tstruct cgfs_files *k = NULL;", " \tconst char *cgroup;", " \tconst char *controller = NULL;", " \tint ret = -ENOENT;", " \tif (!fc)", " \t\treturn -EIO;", " \tmemset(sb, 0, sizeof(struct stat));", " \tif (clock_gettime(CLOCK_REALTIME, &now) < 0)", " \t\treturn -EINVAL;", " \tsb->st_uid = sb->st_gid = 0;", " \tsb->st_atim = sb->st_mtim = sb->st_ctim = now;", " \tsb->st_size = 0;", " \tif (strcmp(path, \"/cgroup\") == 0) {", " \t\tsb->st_mode = S_IFDIR | 00755;", " \t\tsb->st_nlink = 2;", " \t\treturn 0;", " \t}", " \tcontroller = pick_controller_from_path(fc, path);", " \tif (!controller)", " \t\treturn -EIO;", " \tcgroup = find_cgroup_in_path(path);", " \tif (!cgroup) {", " \t\tsb->st_mode = S_IFDIR | 00755;", " \t\tsb->st_nlink = 2;", " \t\treturn 0;", " \t}", " \tget_cgdir_and_path(cgroup, &cgdir, &fpath);", " \tif (!fpath) {", " \t\tpath1 = \"/\";", " \t\tpath2 = cgdir;", " \t} else {", " \t\tpath1 = cgdir;", " \t\tpath2 = fpath;", " \t}", "  \tif (is_child_cgroup(controller, path1, path2)) {", " \t\tif (!caller_may_see_dir(fc->pid, controller, cgroup)) {", " \t\t\tret = -ENOENT;", " \t\t\tgoto out;", " \t\t}", "  \t\tif (!caller_is_in_ancestor(fc->pid, controller, cgroup, NULL)) {", "  \t\t\tsb->st_mode = S_IFDIR | 00555;", " \t\t\tsb->st_nlink = 2;", " \t\t\tret = 0;", " \t\t\tgoto out;", " \t\t}", " \t\tif (!fc_may_access(fc, controller, cgroup, NULL, O_RDONLY)) {", " \t\t\tret = -EACCES;", " \t\t\tgoto out;", " \t\t}", " \t\tsb->st_mode = S_IFDIR | 00755;", " \t\tk = cgfs_get_key(controller, cgroup, \"tasks\");", " \t\tif (!k) {", " \t\t\tsb->st_uid = sb->st_gid = 0;", " \t\t} else {", " \t\t\tsb->st_uid = k->uid;", " \t\t\tsb->st_gid = k->gid;", " \t\t}", " \t\tfree_key(k);", " \t\tsb->st_nlink = 2;", " \t\tret = 0;", " \t\tgoto out;", " \t}", " \tif ((k = cgfs_get_key(controller, path1, path2)) != NULL) {", " \t\tsb->st_mode = S_IFREG | k->mode;", " \t\tsb->st_nlink = 1;", " \t\tsb->st_uid = k->uid;", " \t\tsb->st_gid = k->gid;", " \t\tsb->st_size = 0;", " \t\tfree_key(k);", " \t\tif (!caller_is_in_ancestor(fc->pid, controller, path1, NULL)) {", " \t\t\tret = -ENOENT;", " \t\t\tgoto out;", " \t\t}", " \t\tif (!fc_may_access(fc, controller, path1, path2, O_RDONLY)) {", " \t\t\tret = -EACCES;", " \t\t\tgoto out;", " \t\t}", " \t\tret = 0;", " \t}", " out:", " \tfree(cgdir);", " \treturn ret;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static av_cold int rl2_read_header(AVFormatContext *s)", " {", "     AVIOContext *pb = s->pb;", "     AVStream *st;", "     unsigned int frame_count;", "     unsigned int audio_frame_counter = 0;", "     unsigned int video_frame_counter = 0;", "     unsigned int back_size;", "     unsigned short sound_rate;", "     unsigned short rate;", "     unsigned short channels;", "     unsigned short def_sound_size;", "     unsigned int signature;", "     unsigned int pts_den = 11025;  ", "     unsigned int pts_num = 1103;", "     unsigned int* chunk_offset = NULL;", "     int* chunk_size = NULL;", "     int* audio_size = NULL;", "     int i;", "     int ret = 0;", "     avio_skip(pb,4);           ", "     back_size = avio_rl32(pb);  ", "     signature = avio_rb32(pb);", "     avio_skip(pb, 4);          ", "     frame_count = avio_rl32(pb);", "     if(back_size > INT_MAX/2  || frame_count > INT_MAX / sizeof(uint32_t))", "         return AVERROR_INVALIDDATA;", "     avio_skip(pb, 2);          ", "     sound_rate = avio_rl16(pb);", "     rate = avio_rl16(pb);", "     channels = avio_rl16(pb);", "     def_sound_size = avio_rl16(pb);", "     st = avformat_new_stream(s, NULL);", "     if(!st)", "          return AVERROR(ENOMEM);", "     st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;", "     st->codecpar->codec_id = AV_CODEC_ID_RL2;", "     st->codecpar->codec_tag = 0;   ", "     st->codecpar->width = 320;", "     st->codecpar->height = 200;", "     st->codecpar->extradata_size = EXTRADATA1_SIZE;", "     if(signature == RLV3_TAG && back_size > 0)", "         st->codecpar->extradata_size += back_size;", "     if(ff_get_extradata(s, st->codecpar, pb, st->codecpar->extradata_size) < 0)", "         return AVERROR(ENOMEM);", "     if(sound_rate){", "         if (!channels || channels > 42) {", "             av_log(s, AV_LOG_ERROR, \"Invalid number of channels: %d\\n\", channels);", "             return AVERROR_INVALIDDATA;", "         }", "         pts_num = def_sound_size;", "         pts_den = rate;", "         st = avformat_new_stream(s, NULL);", "         if (!st)", "             return AVERROR(ENOMEM);", "         st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;", "         st->codecpar->codec_id = AV_CODEC_ID_PCM_U8;", "         st->codecpar->codec_tag = 1;", "         st->codecpar->channels = channels;", "         st->codecpar->bits_per_coded_sample = 8;", "         st->codecpar->sample_rate = rate;", "         st->codecpar->bit_rate = st->codecpar->channels * st->codecpar->sample_rate *", "             st->codecpar->bits_per_coded_sample;", "         st->codecpar->block_align = st->codecpar->channels *", "             st->codecpar->bits_per_coded_sample / 8;", "         avpriv_set_pts_info(st,32,1,rate);", "     }", "     avpriv_set_pts_info(s->streams[0], 32, pts_num, pts_den);", "     chunk_size =   av_malloc(frame_count * sizeof(uint32_t));", "     audio_size =   av_malloc(frame_count * sizeof(uint32_t));", "     chunk_offset = av_malloc(frame_count * sizeof(uint32_t));", "     if(!chunk_size || !audio_size || !chunk_offset){", "         av_free(chunk_size);", "         av_free(audio_size);", "         av_free(chunk_offset);", "         return AVERROR(ENOMEM);", "      }", "    for(i=0; i < frame_count;i++)", "     for(i=0; i < frame_count;i++) {", "         if (avio_feof(pb))", "             return AVERROR_INVALIDDATA;", "          chunk_size[i] = avio_rl32(pb);", "    for(i=0; i < frame_count;i++)", "     }", "     for(i=0; i < frame_count;i++) {", "         if (avio_feof(pb))", "             return AVERROR_INVALIDDATA;", "          chunk_offset[i] = avio_rl32(pb);", "    for(i=0; i < frame_count;i++)", "     }", "     for(i=0; i < frame_count;i++) {", "         if (avio_feof(pb))", "             return AVERROR_INVALIDDATA;", "          audio_size[i] = avio_rl32(pb) & 0xFFFF;", "     }", "      for(i=0;i<frame_count;i++){", "         if(chunk_size[i] < 0 || audio_size[i] > chunk_size[i]){", "             ret = AVERROR_INVALIDDATA;", "             break;", "         }", "         if(sound_rate && audio_size[i]){", "             av_add_index_entry(s->streams[1], chunk_offset[i],", "                 audio_frame_counter,audio_size[i], 0, AVINDEX_KEYFRAME);", "             audio_frame_counter += audio_size[i] / channels;", "         }", "         av_add_index_entry(s->streams[0], chunk_offset[i] + audio_size[i],", "             video_frame_counter,chunk_size[i]-audio_size[i],0,AVINDEX_KEYFRAME);", "         ++video_frame_counter;", "     }", "     av_free(chunk_size);", "     av_free(audio_size);", "     av_free(chunk_offset);", "     return ret;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int piv_match_card_continued(sc_card_t *card)", " {", " \tint i;", " \tint type  = -1;", " \tpiv_private_data_t *priv = NULL;", " \tint saved_type = card->type;", " \tcard->ops->logout = NULL;", " \tswitch (card->type) {", " \t\tcase -1:", " \t\tcase SC_CARD_TYPE_PIV_II_GENERIC:", " \t\tcase SC_CARD_TYPE_PIV_II_HIST:", " \t\tcase SC_CARD_TYPE_PIV_II_NEO:", " \t\tcase SC_CARD_TYPE_PIV_II_YUBIKEY4:", " \t\tcase SC_CARD_TYPE_PIV_II_GI_DE:", " \t\t\ttype = card->type;", " \t\t\tbreak;", " \t\tdefault:", " \t\t\treturn 0;  ", " \t}", " \tif (type == -1) {", " \t\tif (card->reader->atr_info.hist_bytes != NULL) {", " \t\t\tif (card->reader->atr_info.hist_bytes_len == 8 &&", " \t\t\t\t\t!(memcmp(card->reader->atr_info.hist_bytes, \"Yubikey4\", 8))) {", " \t\t\t\ttype = SC_CARD_TYPE_PIV_II_YUBIKEY4;", " \t\t\t}", " \t\t\telse if (card->reader->atr_info.hist_bytes_len >= 7 &&", " \t\t\t\t\t!(memcmp(card->reader->atr_info.hist_bytes, \"Yubikey\", 7))) {", " \t\t\t\ttype = SC_CARD_TYPE_PIV_II_NEO;", " \t\t\t}", "\t\t\telse if (card->reader->atr_info.hist_bytes_len >= 4 &&", "\t\t\t\t\t!(memcmp(card->reader->atr_info.hist_bytes, \"sfte\", 4))) {", " \t\t\telse if (card->reader->atr_info.hist_bytes_len >= 4", " \t\t\t\t\t&& !(memcmp(card->reader->atr_info.hist_bytes, \"sfte\", 4))) {", "  \t\t\t\ttype = SC_CARD_TYPE_PIV_II_GI_DE;", "  \t\t\t}", "\t\t\telse if (card->reader->atr_info.hist_bytes[0] == 0x80u) {  ", " \t\t\telse if (card->reader->atr_info.hist_bytes_len > 0", " \t\t\t\t\t&& card->reader->atr_info.hist_bytes[0] == 0x80u) {  ", "  \t\t\t\tsize_t datalen;", "  \t\t\t\tconst u8 *data = sc_compacttlv_find_tag(card->reader->atr_info.hist_bytes + 1,", "  \t\t\t\t\t\t\t\t\tcard->reader->atr_info.hist_bytes_len - 1,", " \t\t\t\t\t\t\t\t\t0xF0, &datalen);", " \t\t\t\tif (data != NULL) {", " \t\t\t\t\tint k;", " \t\t\t\t\tfor (k = 0; piv_aids[k].len_long != 0; k++) {", " \t\t\t\t\t\tif (datalen == piv_aids[k].len_long", " \t\t\t\t\t\t\t&& !memcmp(data, piv_aids[k].value, datalen)) {", " \t\t\t\t\t\t\ttype = SC_CARD_TYPE_PIV_II_HIST;", " \t\t\t\t\t\t\tbreak;", " \t\t\t\t\t\t}", " \t\t\t\t\t}", " \t\t\t\t}", " \t\t\t}", " \t\t}", " \t\tif (type == -1)", " \t\t\ttype = SC_CARD_TYPE_PIV_II_GENERIC;", " \t}", " \tpriv = calloc(1, sizeof(piv_private_data_t));", " \tif (!priv)", " \t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);", " \tif (card->type == -1)", " \t\tcard->type = type;", " \tcard->drv_data = priv;  ", " \tpriv->aid_file = sc_file_new();", " \tpriv->selected_obj = -1;", " \tpriv->pin_preference = 0x80;  ", " \tpriv->logged_in = SC_PIN_STATE_UNKNOWN;", " \tpriv->tries_left = 10;  ", " \tpriv->pstate = PIV_STATE_MATCH;", " \tfor (i=0; i < PIV_OBJ_LAST_ENUM -1; i++)", " \t\tif(piv_objects[i].flags & PIV_OBJECT_NOT_PRESENT)", " \t\t\tpriv->obj_cache[i].flags |= PIV_OBJ_CACHE_NOT_PRESENT;", " \tsc_lock(card);", " \ti = piv_find_discovery(card);", " \tif (i < 0) {", " \t\tsc_file_t aidfile;", " \t\ti = piv_find_aid(card, &aidfile);", " \t}", " \tif (i >= 0) {", " \t\tint i7e = piv_find_discovery(card);", " \t\tif (i7e != 0 && i7e !=  SC_ERROR_FILE_NOT_FOUND) {", " \t\t\tpriv->card_issues |= CI_DISCOVERY_USELESS;", " \t\t\tpriv->obj_cache[PIV_OBJ_DISCOVERY].flags |= PIV_OBJ_CACHE_NOT_PRESENT;", " \t\t}", " \t}", " \tif (i < 0) {", " \t\tsc_unlock(card);", " \t\tpiv_finish(card);", " \t\tcard->type = saved_type;", " \t\treturn 0;", " \t}", " \tpriv->pstate=PIV_STATE_INIT;", " \treturn 1;  ", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int sdp_parse_fmtp_config_h264(AVFormatContext *s,", "                                       AVStream *stream,", "                                       PayloadContext *h264_data,", "                                       const char *attr, const char *value)", " {", "     AVCodecParameters *par = stream->codecpar;", "     if (!strcmp(attr, \"packetization-mode\")) {", "         av_log(s, AV_LOG_DEBUG, \"RTP Packetization Mode: %d\\n\", atoi(value));", "         h264_data->packetization_mode = atoi(value);", "         if (h264_data->packetization_mode > 1)", "             av_log(s, AV_LOG_ERROR,", "                    \"Interleaved RTP mode is not supported yet.\\n\");", "     } else if (!strcmp(attr, \"profile-level-id\")) {", "         if (strlen(value) == 6)", "              parse_profile_level_id(s, h264_data, value);", "      } else if (!strcmp(attr, \"sprop-parameter-sets\")) {", "          int ret;", "        if (value[strlen(value) - 1] == ',') {", "         if (*value == 0 || value[strlen(value) - 1] == ',') {", "              av_log(s, AV_LOG_WARNING, \"Missing PPS in sprop-parameter-sets, ignoring\\n\");", "              return 0;", "          }", "         par->extradata_size = 0;", "         av_freep(&par->extradata);", "         ret = ff_h264_parse_sprop_parameter_sets(s, &par->extradata,", "                                                  &par->extradata_size, value);", "         av_log(s, AV_LOG_DEBUG, \"Extradata set to %p (size: %d)\\n\",", "                par->extradata, par->extradata_size);", "         return ret;", "     }", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" SProcXIBarrierReleasePointer(ClientPtr client)", " {", "     xXIBarrierReleasePointerInfo *info;", "     REQUEST(xXIBarrierReleasePointerReq);", "     int i;", "     swaps(&stuff->length);", "      REQUEST_AT_LEAST_SIZE(xXIBarrierReleasePointerReq);", "      swapl(&stuff->num_barriers);", "     if (stuff->num_barriers > UINT32_MAX / sizeof(xXIBarrierReleasePointerInfo))", "         return BadLength;", "      REQUEST_FIXED_SIZE(xXIBarrierReleasePointerReq, stuff->num_barriers * sizeof(xXIBarrierReleasePointerInfo));", "      info = (xXIBarrierReleasePointerInfo*) &stuff[1];", "         swapl(&info->barrier);", "         swapl(&info->eventid);", "     }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" valid_host(cupsd_client_t *con)\t\t ", " {", "   cupsd_alias_t\t*a;\t\t\t ", "   cupsd_netif_t\t*netif;\t\t\t ", "   const char\t*end;\t\t\t ", "   char\t\t*ptr;\t\t\t ", "   strlcpy(con->clientname, httpGetField(con->http, HTTP_FIELD_HOST),", "           sizeof(con->clientname));", "   if ((ptr = strrchr(con->clientname, ':')) != NULL && !strchr(ptr, ']'))", "   {", "     *ptr++ = '\\0';", "     con->clientport = atoi(ptr);", "   }", "   else", "     con->clientport = con->serverport;", "   if (httpAddrLocalhost(httpGetAddress(con->http)))", "   {", "      return (!_cups_strcasecmp(con->clientname, \"localhost\") ||", "  \t    !_cups_strcasecmp(con->clientname, \"localhost.\") ||", "#ifdef __linux", "\t    !_cups_strcasecmp(con->clientname, \"localhost.localdomain\") ||", "#endif  ", "              !strcmp(con->clientname, \"127.0.0.1\") ||", "  \t    !strcmp(con->clientname, \"[::1]\"));", "    }", " #if defined(HAVE_DNSSD) || defined(HAVE_AVAHI)", "   if ((end = strrchr(con->clientname, '.')) != NULL && end > con->clientname &&", "       !end[1])", "   {", "     for (end --; end > con->clientname && *end != '.'; end --);", "   }", "   if (end && (!_cups_strcasecmp(end, \".local\") ||", " \t      !_cups_strcasecmp(end, \".local.\")))", "     return (1);", " #endif  ", "   if (isdigit(con->clientname[0] & 255) || con->clientname[0] == '[')", "   {", "     http_addrlist_t *addrlist;\t\t ", "     if ((addrlist = httpAddrGetList(con->clientname, AF_UNSPEC, NULL)) != NULL)", "     {", "       httpAddrFreeList(addrlist);", "       return (1);", "     }", "   }", "   for (a = (cupsd_alias_t *)cupsArrayFirst(ServerAlias);", "        a;", "        a = (cupsd_alias_t *)cupsArrayNext(ServerAlias))", "   {", "     if (!strcmp(a->name, \"*\"))", "       return (1);", "     if (!_cups_strncasecmp(con->clientname, a->name, a->namelen))", "     {", "       end = con->clientname + a->namelen;", "       if (!*end || (*end == '.' && !end[1]))", "         return (1);", "     }", "   }", " #if defined(HAVE_DNSSD) || defined(HAVE_AVAHI)", "   for (a = (cupsd_alias_t *)cupsArrayFirst(DNSSDAlias);", "        a;", "        a = (cupsd_alias_t *)cupsArrayNext(DNSSDAlias))", "   {", "     if (!strcmp(a->name, \"*\"))", "       return (1);", "     if (!_cups_strncasecmp(con->clientname, a->name, a->namelen))", "     {", "       end = con->clientname + a->namelen;", "       if (!*end || (*end == '.' && !end[1]))", "         return (1);", "     }", "   }", " #endif  ", "   for (netif = (cupsd_netif_t *)cupsArrayFirst(NetIFList);", "        netif;", "        netif = (cupsd_netif_t *)cupsArrayNext(NetIFList))", "   {", "     if (!_cups_strncasecmp(con->clientname, netif->hostname, netif->hostlen))", "     {", "       end = con->clientname + netif->hostlen;", "       if (!*end || (*end == '.' && !end[1]))", "         return (1);", "     }", "   }", "   return (0);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" txid_snapshot_recv(PG_FUNCTION_ARGS)", " {", " \tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);", " \tTxidSnapshot *snap;", "  \ttxid\t\tlast = 0;", "  \tint\t\t\tnxip;", "  \tint\t\t\ti;", "\tint\t\t\tavail;", "\tint\t\t\texpect;", "  \ttxid\t\txmin,", "  \t\t\t\txmax;", "  \tnxip = pq_getmsgint(buf, 4);", "\tavail = buf->len - buf->cursor;", "\texpect = 8 + 8 + nxip * 8;", "\tif (nxip < 0 || nxip > avail || expect > avail)", " \tif (nxip < 0 || nxip > TXID_SNAPSHOT_MAX_NXIP)", "  \t\tgoto bad_format;", "  \txmin = pq_getmsgint64(buf);", " \txmax = pq_getmsgint64(buf);", " \tif (xmin == 0 || xmax == 0 || xmin > xmax || xmax > MAX_TXID)", " \t\tgoto bad_format;", " \tsnap = palloc(TXID_SNAPSHOT_SIZE(nxip));", " \tsnap->xmin = xmin;", " \tsnap->xmax = xmax;", " \tsnap->nxip = nxip;", " \tSET_VARSIZE(snap, TXID_SNAPSHOT_SIZE(nxip));", " \tfor (i = 0; i < nxip; i++)", " \t{", " \t\ttxid\t\tcur = pq_getmsgint64(buf);", " \t\tif (cur <= last || cur < xmin || cur >= xmax)", " \t\t\tgoto bad_format;", " \t\tsnap->xip[i] = cur;", " \t\tlast = cur;", " \t}", " \tPG_RETURN_POINTER(snap);", " bad_format:", " \telog(ERROR, \"invalid snapshot data\");", " \treturn (Datum) NULL;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" jas_image_t *jas_image_create(int numcmpts, jas_image_cmptparm_t *cmptparms,", "    int clrspc)", "  {", "  \tjas_image_t *image;", "\tuint_fast32_t rawsize;", " \tsize_t rawsize;", "  \tuint_fast32_t inmem;", "  \tint cmptno;", "  \tjas_image_cmptparm_t *cmptparm;", " \timage = 0;", " \tJAS_DBGLOG(100, (\"jas_image_create(%d, %p, %d)\\n\", numcmpts, cmptparms,", " \t  clrspc));", "  \tif (!(image = jas_image_create0())) {", "\t\treturn 0;", " \t\tgoto error;", "  \t}", "  \timage->clrspc_ = clrspc;", "  \timage->maxcmpts_ = numcmpts;", "\timage->inmem_ = true;", "  \tif (!(image->cmpts_ = jas_alloc2(image->maxcmpts_,", "  \t  sizeof(jas_image_cmpt_t *)))) {", "\t\tjas_image_destroy(image);", "\t\treturn 0;", " \t\tgoto error;", "  \t}", "  \tfor (cmptno = 0; cmptno < image->maxcmpts_; ++cmptno) {", "  \t\timage->cmpts_[cmptno] = 0;", "  \t}", " #if 0", "  \trawsize = 0;", "  \tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,", " \t  ++cmptparm) {", " \t\trawsize += cmptparm->width * cmptparm->height *", " \t\t  (cmptparm->prec + 7) / 8;", " \t}", "  \tinmem = (rawsize < JAS_IMAGE_INMEMTHRESH);", " #endif", "  \tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,", "  \t  ++cmptparm) {", " \t\tif (!jas_safe_size_mul3(cmptparm->width, cmptparm->height,", " \t\t  (cmptparm->prec + 7), &rawsize)) {", " \t\t\tgoto error;", " \t\t}", " \t\trawsize /= 8;", " \t\tinmem = (rawsize < JAS_IMAGE_INMEMTHRESH);", "  \t\tif (!(image->cmpts_[cmptno] = jas_image_cmpt_create(cmptparm->tlx,", "  \t\t  cmptparm->tly, cmptparm->hstep, cmptparm->vstep,", "  \t\t  cmptparm->width, cmptparm->height, cmptparm->prec,", "  \t\t  cmptparm->sgnd, inmem))) {", "\t\t\tjas_image_destroy(image);", "\t\t\treturn 0;", " \t\t\tgoto error;", "  \t\t}", "  \t\t++image->numcmpts_;", "  \t}", "  \tjas_image_setbbox(image);", "  \treturn image;", " error:", " \tif (image) {", " \t\tjas_image_destroy(image);", " \t}", " \treturn 0;", "  }"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0]}
{"tokens": [" uint32_t GetPayloadTime(size_t handle, uint32_t index, float *in, float *out)", " uint32_t GetPayloadTime(size_t handle, uint32_t index, double *in, double *out)", "  {", "  \tmp4object *mp4 = (mp4object *)handle;", "\tif (mp4 == NULL) return 0;", " \tif (mp4 == NULL) return GPMF_ERROR_MEMORY;", "\tif (mp4->metaoffsets == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in == NULL || out == NULL) return 1;", " \tif (mp4->metaoffsets == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in == NULL || out == NULL) return GPMF_ERROR_MEMORY;", "\t*in = (float)((double)index * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);", "\t*out = (float)((double)(index + 1) * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);", "\treturn 0;", " \t*in = ((double)index * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);", " \t*out = ((double)(index + 1) * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);", " \treturn GPMF_OK;", "  }"], "ner_tags": [0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": [" static int piv_general_io(sc_card_t *card, int ins, int p1, int p2,", " \tconst u8 * sendbuf, size_t sendbuflen, u8 ** recvbuf,", " \tsize_t * recvbuflen)", " {", " \tint r;", " \tsc_apdu_t apdu;", " \tu8 rbufinitbuf[4096];", " \tu8 *rbuf;", " \tsize_t rbuflen;", " \tunsigned int cla_out, tag_out;", " \tconst u8 *body;", " \tsize_t bodylen;", " \tint find_len = 0;", " \tpiv_private_data_t * priv = PIV_DATA(card);", " \tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);", " \tsc_log(card->ctx,", " \t       \"%02x %02x %02x %\"SC_FORMAT_LEN_SIZE_T\"u : %\"SC_FORMAT_LEN_SIZE_T\"u %\"SC_FORMAT_LEN_SIZE_T\"u\",", " \t       ins, p1, p2, sendbuflen, card->max_send_size,", " \t       card->max_recv_size);", " \trbuf = rbufinitbuf;", " \trbuflen = sizeof(rbufinitbuf);", " \tif (recvbuf && *recvbuf && recvbuflen && *recvbuflen) {", " \t\trbuf = *recvbuf;", " \t\trbuflen = *recvbuflen;", " \t}", " \tr = sc_lock(card);", " \tif (r != SC_SUCCESS)", " \t\tLOG_FUNC_RETURN(card->ctx, r);", " \tsc_format_apdu(card, &apdu,", " \t\t\trecvbuf ? SC_APDU_CASE_4_SHORT: SC_APDU_CASE_3_SHORT,", " \t\t\tins, p1, p2);", " \tapdu.flags |= SC_APDU_FLAGS_CHAINING;", " \tif (rbuflen == 8 && card->reader->active_protocol == SC_PROTO_T1) {", " \t\tapdu.flags |= SC_APDU_FLAGS_NO_GET_RESP;", " \t\tfind_len = 1;", " \t}", " \tapdu.lc = sendbuflen;", " \tapdu.datalen = sendbuflen;", " \tapdu.data = sendbuf;", " \tif (recvbuf) {", " \t\tapdu.resp = rbuf;", " \t\tapdu.le = (rbuflen > 256) ? 256 : rbuflen;", " \t\tapdu.resplen = rbuflen;", " \t} else {", " \t\t apdu.resp =  rbuf;", " \t\t apdu.le = 0;", " \t\t apdu.resplen = 0;", " \t}", " \tsc_log(card->ctx,", " \t       \"calling sc_transmit_apdu flags=%lx le=%\"SC_FORMAT_LEN_SIZE_T\"u, resplen=%\"SC_FORMAT_LEN_SIZE_T\"u, resp=%p\",", " \t       apdu.flags, apdu.le, apdu.resplen, apdu.resp);", " \tr = sc_transmit_apdu(card, &apdu);", " \tsc_log(card->ctx,", " \t       \"DEE r=%d apdu.resplen=%\"SC_FORMAT_LEN_SIZE_T\"u sw1=%02x sw2=%02x\",", " \t       r, apdu.resplen, apdu.sw1, apdu.sw2);", " \tif (r < 0) {", " \t\tsc_log(card->ctx, \"Transmit failed\");", " \t\tgoto err;", " \t}", " \tif (!(find_len && apdu.sw1 == 0x61))", " \t    r = sc_check_sw(card, apdu.sw1, apdu.sw2);", " \tif (r < 0) {", " \t\tsc_log(card->ctx, \"Card returned error \");", " \t\tgoto err;", " \t}", " \trbuflen = 0;   ", " \tif ( recvbuflen && recvbuf && apdu.resplen > 3 && priv->pin_cmd_noparse != 1) {", " \t\t*recvbuflen = 0;", "  \t\tbody = rbuf;", "\t\tif (sc_asn1_read_tag(&body, 0xffff, &cla_out, &tag_out, &bodylen) !=  SC_SUCCESS", " \t\tif (sc_asn1_read_tag(&body, rbuflen, &cla_out, &tag_out, &bodylen) !=  SC_SUCCESS", "  \t\t\t\t|| body == NULL)  {", "  \t\t\tsc_log(card->ctx, \"***** received buffer tag MISSING \");", " \t\t\tbody = rbuf;", " \t\t\tif (apdu.sw1 == 0x61  || apdu.sw2 == 0x6c )", " \t\t\t\tbodylen = 12000;", " \t\t\telse", " \t\t\t\tbodylen = apdu.resplen;", " \t\t}", " \t\trbuflen = body - rbuf + bodylen;", " \t\tif (rbuf == rbufinitbuf) {", " \t\t\t*recvbuf = malloc(rbuflen);", " \t\t\tif (*recvbuf == NULL) {", " \t\t\t\tr = SC_ERROR_OUT_OF_MEMORY;", " \t\t\t\tgoto err;", " \t\t\t}", " \t\t\tmemcpy(*recvbuf, rbuf, rbuflen);  ", " \t\t}", " \t}", " \tif (recvbuflen) {", " \t\t*recvbuflen =  rbuflen;", " \t\tr = *recvbuflen;", " \t}", " err:", " \tsc_unlock(card);", " \tLOG_FUNC_RETURN(card->ctx, r);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" archive_read_format_cpio_read_header(struct archive_read *a,", "     struct archive_entry *entry)", " {", " \tstruct cpio *cpio;", " \tconst void *h;", " \tstruct archive_string_conv *sconv;", " \tsize_t namelength;", " \tsize_t name_pad;", " \tint r;", " \tcpio = (struct cpio *)(a->format->data);", " \tsconv = cpio->opt_sconv;", " \tif (sconv == NULL) {", " \t\tif (!cpio->init_default_conversion) {", " \t\t\tcpio->sconv_default =", " \t\t\t    archive_string_default_conversion_for_read(", " \t\t\t      &(a->archive));", " \t\t\tcpio->init_default_conversion = 1;", " \t\t}", " \t\tsconv = cpio->sconv_default;", " \t}", " \tr = (cpio->read_header(a, cpio, entry, &namelength, &name_pad));", " \tif (r < ARCHIVE_WARN)", " \t\treturn (r);", " \th = __archive_read_ahead(a, namelength + name_pad, NULL);", " \tif (h == NULL)", " \t    return (ARCHIVE_FATAL);", " \tif (archive_entry_copy_pathname_l(entry,", " \t    (const char *)h, namelength, sconv) != 0) {", " \t\tif (errno == ENOMEM) {", " \t\t\tarchive_set_error(&a->archive, ENOMEM,", " \t\t\t    \"Can't allocate memory for Pathname\");", " \t\t\treturn (ARCHIVE_FATAL);", " \t\t}", " \t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", " \t\t    \"Pathname can't be converted from %s to current locale.\",", " \t\t    archive_string_conversion_charset_name(sconv));", " \t\tr = ARCHIVE_WARN;", " \t}", " \tcpio->entry_offset = 0;", " \t__archive_read_consume(a, namelength + name_pad);", "  \tif (archive_entry_filetype(entry) == AE_IFLNK) {", " \t\tif (cpio->entry_bytes_remaining > 1024 * 1024) {", " \t\t\tarchive_set_error(&a->archive, ENOMEM,", " \t\t\t    \"Rejecting malformed cpio archive: symlink contents exceed 1 megabyte\");", " \t\t\treturn (ARCHIVE_FATAL);", " \t\t}", "  \t\th = __archive_read_ahead(a,", "  \t\t\t(size_t)cpio->entry_bytes_remaining, NULL);", "  \t\tif (h == NULL)", " \t\t\treturn (ARCHIVE_FATAL);", " \t\tif (archive_entry_copy_symlink_l(entry, (const char *)h,", " \t\t    (size_t)cpio->entry_bytes_remaining, sconv) != 0) {", " \t\t\tif (errno == ENOMEM) {", " \t\t\t\tarchive_set_error(&a->archive, ENOMEM,", " \t\t\t\t    \"Can't allocate memory for Linkname\");", " \t\t\t\treturn (ARCHIVE_FATAL);", " \t\t\t}", " \t\t\tarchive_set_error(&a->archive,", " \t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,", " \t\t\t    \"Linkname can't be converted from %s to \"", " \t\t\t    \"current locale.\",", " \t\t\t    archive_string_conversion_charset_name(sconv));", " \t\t\tr = ARCHIVE_WARN;", " \t\t}", " \t\t__archive_read_consume(a, cpio->entry_bytes_remaining);", " \t\tcpio->entry_bytes_remaining = 0;", " \t}", " \tif (namelength == 11 && strcmp((const char *)h, \"TRAILER!!!\") == 0) {", " \t\tarchive_clear_error(&a->archive);", " \t\treturn (ARCHIVE_EOF);", " \t}", " \tif (record_hardlink(a, cpio, entry) != ARCHIVE_OK) {", " \t\treturn (ARCHIVE_FATAL);", " \t}", " \treturn (r);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void CNB::SetupLSO(virtio_net_hdr_basic *VirtioHeader, PVOID IpHeader, ULONG EthPayloadLength) const", " {", "     PopulateIPLength(reinterpret_cast<IPv4Header*>(IpHeader), static_cast<USHORT>(EthPayloadLength));", "      tTcpIpPacketParsingResult packetReview;", "      packetReview = ParaNdis_CheckSumVerifyFlat(reinterpret_cast<IPv4Header*>(IpHeader), EthPayloadLength,", "                                                 pcrIpChecksum | pcrFixIPChecksum | pcrTcpChecksum | pcrFixPHChecksum,", "                                                FALSE,", "                                                 __FUNCTION__);", "      if (packetReview.xxpCheckSum == ppresPCSOK || packetReview.fixedXxpCS)", "     {", "         auto IpHeaderOffset = m_Context->Offload.ipHeaderOffset;", "         auto VHeader = static_cast<virtio_net_hdr_basic*>(VirtioHeader);", "         auto PriorityHdrLen = (m_ParentNBL->TCI() != 0) ? ETH_PRIORITY_HEADER_SIZE : 0;", "         VHeader->flags = VIRTIO_NET_HDR_F_NEEDS_CSUM;", "         VHeader->gso_type = packetReview.ipStatus == ppresIPV4 ? VIRTIO_NET_HDR_GSO_TCPV4 : VIRTIO_NET_HDR_GSO_TCPV6;", "         VHeader->hdr_len = (USHORT)(packetReview.XxpIpHeaderSize + IpHeaderOffset + PriorityHdrLen);", "         VHeader->gso_size = (USHORT)m_ParentNBL->MSS();", "         VHeader->csum_start = (USHORT)(m_ParentNBL->TCPHeaderOffset() + PriorityHdrLen);", "         VHeader->csum_offset = TCP_CHECKSUM_OFFSET;", "     }", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void ikev2_parent_inR1outI2_continue(struct pluto_crypto_req_cont *pcrc,", " \t\t\t\t\t    struct pluto_crypto_req *r,", " \t\t\t\t\t    err_t ugh)", " {", " \tstruct dh_continuation *dh = (struct dh_continuation *)pcrc;", " \tstruct msg_digest *md = dh->md;", " \tstruct state *const st = md->st;", " \tstf_status e;", " \tDBG(DBG_CONTROLMORE,", " \t    DBG_log(\"ikev2 parent inR1outI2: calculating g^{xy}, sending I2\"));", " \tif (st == NULL) {", " \t\tloglog(RC_LOG_SERIOUS,", " \t\t       \"%s: Request was disconnected from state\",", " \t\t       __FUNCTION__);", " \t\tif (dh->md)", " \t\t\trelease_md(dh->md);", " \t\treturn;", " \t}", " \tpassert(ugh == NULL);", " \tpassert(cur_state == NULL);", " \tpassert(st != NULL);", " \tpassert(st->st_suspended_md == dh->md);", " \tset_suspended(st, NULL);  ", " \tset_cur_state(st);", " \tst->st_calculating = FALSE;", " \te = ikev2_parent_inR1outI2_tail(pcrc, r);", " \tif (dh->md != NULL) {", " \t\tcomplete_v2_state_transition(&dh->md, e);", " \t\tif (dh->md)", "  \t\t\trelease_md(dh->md);", "  \t}", "  \treset_globals();", "\tpassert(GLOBALS_ARE_RESET());", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": [" static int jpc_siz_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate,", "   jas_stream_t *in)", " {", " \tjpc_siz_t *siz = &ms->parms.siz;", "  \tunsigned int i;", "  \tuint_fast8_t tmp;", " \tsiz->comps = 0;", "  \tcstate = 0;", " \tif (jpc_getuint16(in, &siz->caps) ||", " \t  jpc_getuint32(in, &siz->width) ||", " \t  jpc_getuint32(in, &siz->height) ||", " \t  jpc_getuint32(in, &siz->xoff) ||", " \t  jpc_getuint32(in, &siz->yoff) ||", " \t  jpc_getuint32(in, &siz->tilewidth) ||", " \t  jpc_getuint32(in, &siz->tileheight) ||", "  \t  jpc_getuint32(in, &siz->tilexoff) ||", "  \t  jpc_getuint32(in, &siz->tileyoff) ||", "  \t  jpc_getuint16(in, &siz->numcomps)) {", "\t\treturn -1;", " \t\tgoto error;", "  \t}", "\tif (!siz->width || !siz->height || !siz->tilewidth ||", "\t  !siz->tileheight || !siz->numcomps || siz->numcomps > 16384) {", "\t\treturn -1;", " \tif (!siz->width || !siz->height) {", " \t\tjas_eprintf(\"reference grid cannot have zero area\\n\");", " \t\tgoto error;", "  \t}", "\tif (siz->tilexoff >= siz->width || siz->tileyoff >= siz->height) {", "\t\tjas_eprintf(\"all tiles are outside the image area\\n\");", "\t\treturn -1;", " \tif (!siz->tilewidth || !siz->tileheight) {", " \t\tjas_eprintf(\"tile cannot have zero area\\n\");", " \t\tgoto error;", " \t}", " \tif (!siz->numcomps || siz->numcomps > 16384) {", " \t\tjas_eprintf(\"number of components not in permissible range\\n\");", " \t\tgoto error;", "  \t}", " \tif (siz->xoff >= siz->width) {", " \t\tjas_eprintf(\"XOsiz not in permissible range\\n\");", " \t\tgoto error;", " \t}", " \tif (siz->yoff >= siz->height) {", " \t\tjas_eprintf(\"YOsiz not in permissible range\\n\");", " \t\tgoto error;", " \t}", " \tif (siz->tilexoff > siz->xoff || siz->tilexoff + siz->tilewidth <= siz->xoff) {", " \t\tjas_eprintf(\"XTOsiz not in permissible range\\n\");", " \t\tgoto error;", " \t}", " \tif (siz->tileyoff > siz->yoff || siz->tileyoff + siz->tileheight <= siz->yoff) {", " \t\tjas_eprintf(\"YTOsiz not in permissible range\\n\");", " \t\tgoto error;", " \t}", "  \tif (!(siz->comps = jas_alloc2(siz->numcomps, sizeof(jpc_sizcomp_t)))) {", "\t\treturn -1;", " \t\tgoto error;", "  \t}", "  \tfor (i = 0; i < siz->numcomps; ++i) {", "  \t\tif (jpc_getuint8(in, &tmp) ||", "  \t\t  jpc_getuint8(in, &siz->comps[i].hsamp) ||", "  \t\t  jpc_getuint8(in, &siz->comps[i].vsamp)) {", "\t\t\tjas_free(siz->comps);", "\t\t\treturn -1;", " \t\t\tgoto error;", "  \t\t}", "  \t\tif (siz->comps[i].hsamp == 0 || siz->comps[i].hsamp > 255) {", "  \t\t\tjas_eprintf(\"invalid XRsiz value %d\\n\", siz->comps[i].hsamp);", "\t\t\tjas_free(siz->comps);", "\t\t\treturn -1;", " \t\t\tgoto error;", "  \t\t}", "  \t\tif (siz->comps[i].vsamp == 0 || siz->comps[i].vsamp > 255) {", "  \t\t\tjas_eprintf(\"invalid YRsiz value %d\\n\", siz->comps[i].vsamp);", "\t\t\tjas_free(siz->comps);", "\t\t\treturn -1;", " \t\t\tgoto error;", "  \t\t}", "  \t\tsiz->comps[i].sgnd = (tmp >> 7) & 1;", "  \t\tsiz->comps[i].prec = (tmp & 0x7f) + 1;", "  \t}", "  \tif (jas_stream_eof(in)) {", "\t\tjas_free(siz->comps);", "\t\treturn -1;", " \t\tgoto error;", "  \t}", "  \treturn 0;", " error:", " \tif (siz->comps) {", " \t\tjas_free(siz->comps);", " \t}", " \treturn -1;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0]}
{"tokens": ["  static void Np_toString(js_State *J)", "  {", "\tchar buf[32];", " \tchar buf[100];", "  \tjs_Object *self = js_toobject(J, 0);", "  \tint radix = js_isundefined(J, 1) ? 10 : js_tointeger(J, 1);", "  \tif (self->type != JS_CNUMBER)", " \t\tjs_typeerror(J, \"not a number\");", " \tif (radix == 10) {", " \t\tjs_pushstring(J, jsV_numbertostring(J, buf, self->u.number));", " \t\treturn;", " \t}", " \tif (radix < 2 || radix > 36)", " \t\tjs_rangeerror(J, \"invalid radix\");", "  \t{", "  \t\tstatic const char digits[] = \"0123456789abcdefghijklmnopqrstuvwxyz\";", "\t\tchar buf[100];", "  \t\tdouble number = self->u.number;", "  \t\tint sign = self->u.number < 0;", "  \t\tjs_Buffer *sb = NULL;", " \t\tuint64_t u, limit = ((uint64_t)1<<52);", " \t\tint ndigits, exp, point;", " \t\tif (number == 0) { js_pushstring(J, \"0\"); return; }", " \t\tif (isnan(number)) { js_pushstring(J, \"NaN\"); return; }", " \t\tif (isinf(number)) { js_pushstring(J, sign ? \"-Infinity\" : \"Infinity\"); return; }", " \t\tif (sign)", " \t\t\tnumber = -number;", " \t\texp = 0;", " \t\twhile (number * pow(radix, exp) > limit)", " \t\t\t--exp;", " \t\twhile (number * pow(radix, exp+1) < limit)", " \t\t\t++exp;", " \t\tu = number * pow(radix, exp) + 0.5;", " \t\twhile (u > 0 && (u % radix) == 0) {", " \t\t\tu /= radix;", " \t\t\t--exp;", " \t\t}", " \t\tndigits = 0;", " \t\twhile (u > 0) {", " \t\t\tbuf[ndigits++] = digits[u % radix];", " \t\t\tu /= radix;", " \t\t}", " \t\tpoint = ndigits - exp;", " \t\tif (js_try(J)) {", " \t\t\tjs_free(J, sb);", " \t\t\tjs_throw(J);", " \t\t}", " \t\tif (sign)", " \t\t\tjs_putc(J, &sb, '-');", " \t\tif (point <= 0) {", " \t\t\tjs_putc(J, &sb, '0');", " \t\t\tjs_putc(J, &sb, '.');", " \t\t\twhile (point++ < 0)", " \t\t\t\tjs_putc(J, &sb, '0');", " \t\t\twhile (ndigits-- > 0)", " \t\t\t\tjs_putc(J, &sb, buf[ndigits]);", " \t\t} else {", " \t\t\twhile (ndigits-- > 0) {", " \t\t\t\tjs_putc(J, &sb, buf[ndigits]);", " \t\t\t\tif (--point == 0 && ndigits > 0)", " \t\t\t\t\tjs_putc(J, &sb, '.');", " \t\t\t}", " \t\t\twhile (point-- > 0)", " \t\t\t\tjs_putc(J, &sb, '0');", " \t\t}", " \t\tjs_putc(J, &sb, 0);", " \t\tjs_pushstring(J, sb->s);", " \t\tjs_endtry(J);", " \t\tjs_free(J, sb);", " \t}", " }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  jas_matrix_t *jas_matrix_copy(jas_matrix_t *x)", "  {", "  \tjas_matrix_t *y;", "\tint i;", "\tint j;", " \tjas_matind_t i;", " \tjas_matind_t j;", "  \ty = jas_matrix_create(x->numrows_, x->numcols_);", "  \tfor (i = 0; i < x->numrows_; ++i) {", "  \t\tfor (j = 0; j < x->numcols_; ++j) {", " \t\t\t*jas_matrix_getref(y, i, j) = jas_matrix_get(x, i, j);", " \t\t}", " \t}", " \treturn y;", " }"], "ner_tags": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" ProcXResQueryResourceBytes (ClientPtr client)", " {", "     REQUEST(xXResQueryResourceBytesReq);", "     int                          rc;", "      ConstructResourceBytesCtx    ctx;", "      REQUEST_AT_LEAST_SIZE(xXResQueryResourceBytesReq);", "     if (stuff->numSpecs > UINT32_MAX / sizeof(ctx.specs[0]))", "         return BadLength;", "      REQUEST_FIXED_SIZE(xXResQueryResourceBytesReq,", "                         stuff->numSpecs * sizeof(ctx.specs[0]));", "                                        (void*) ((char*) stuff +", "                                                 sz_xXResQueryResourceBytesReq))) {", "         return BadAlloc;", "     }", "     rc = ConstructResourceBytes(stuff->client, &ctx);", "     if (rc == Success) {", "         xXResQueryResourceBytesReply rep = {", "             .type = X_Reply,", "             .sequenceNumber = client->sequence,", "             .length = bytes_to_int32(ctx.resultBytes),", "             .numSizes = ctx.numSizes", "         };", "         if (client->swapped) {", "             swaps (&rep.sequenceNumber);", "             swapl (&rep.length);", "             swapl (&rep.numSizes);", "             SwapXResQueryResourceBytes(&ctx.response);", "         }", "         WriteToClient(client, sizeof(rep), &rep);", "         WriteFragmentsToClient(client, &ctx.response);", "     }", "     DestroyConstructResourceBytesCtx(&ctx);", "     return rc;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int decode_zbuf(AVBPrint *bp, const uint8_t *data,", "                        const uint8_t *data_end)", " {", "     z_stream zstream;", "     unsigned char *buf;", "     unsigned buf_size;", "     int ret;", "     zstream.zalloc = ff_png_zalloc;", "     zstream.zfree  = ff_png_zfree;", "     zstream.opaque = NULL;", "     if (inflateInit(&zstream) != Z_OK)", "         return AVERROR_EXTERNAL;", "     zstream.next_in  = (unsigned char *)data;", "     zstream.avail_in = data_end - data;", "      av_bprint_init(bp, 0, -1);", "      while (zstream.avail_in > 0) {", "        av_bprint_get_buffer(bp, 1, &buf, &buf_size);", "        if (!buf_size) {", "         av_bprint_get_buffer(bp, 2, &buf, &buf_size);", "         if (buf_size < 2) {", "              ret = AVERROR(ENOMEM);", "              goto fail;", "          }", "          zstream.next_out  = buf;", "        zstream.avail_out = buf_size;", "         zstream.avail_out = buf_size - 1;", "          ret = inflate(&zstream, Z_PARTIAL_FLUSH);", "          if (ret != Z_OK && ret != Z_STREAM_END) {", "              ret = AVERROR_EXTERNAL;", "             goto fail;", "         }", "         bp->len += zstream.next_out - buf;", "         if (ret == Z_STREAM_END)", "             break;", "     }", "     inflateEnd(&zstream);", "     bp->str[bp->len] = 0;", "     return 0;", " fail:", "     inflateEnd(&zstream);", "     av_bprint_finalize(bp, NULL);", "     return ret;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" makepol(QPRS_STATE *state)", " {", " \tint32\t\tval = 0,", " \t\t\t\ttype;", " \tint32\t\tlenval = 0;", " \tchar\t   *strval = NULL;", " \tint32\t\tstack[STACKDEPTH];", "  \tint32\t\tlenstack = 0;", "  \tuint16\t\tflag = 0;", " \tcheck_stack_depth();", "  \twhile ((type = gettoken_query(state, &val, &lenval, &strval, &flag)) != END)", "  \t{", "  \t\tswitch (type)", " \t\t{", " \t\t\tcase VAL:", " \t\t\t\tpushval_asis(state, VAL, strval, lenval, flag);", " \t\t\t\twhile (lenstack && (stack[lenstack - 1] == (int32) '&' ||", " \t\t\t\t\t\t\t\t\tstack[lenstack - 1] == (int32) '!'))", " \t\t\t\t{", " \t\t\t\t\tlenstack--;", " \t\t\t\t\tpushquery(state, OPR, stack[lenstack], 0, 0, 0);", " \t\t\t\t}", " \t\t\t\tbreak;", " \t\t\tcase OPR:", " \t\t\t\tif (lenstack && val == (int32) '|')", " \t\t\t\t\tpushquery(state, OPR, val, 0, 0, 0);", " \t\t\t\telse", " \t\t\t\t{", " \t\t\t\t\tif (lenstack == STACKDEPTH)", " \t\t\t\t\t\telog(ERROR, \"stack too short\");", " \t\t\t\t\tstack[lenstack] = val;", " \t\t\t\t\tlenstack++;", " \t\t\t\t}", " \t\t\t\tbreak;", " \t\t\tcase OPEN:", " \t\t\t\tif (makepol(state) == ERR)", " \t\t\t\t\treturn ERR;", " \t\t\t\twhile (lenstack && (stack[lenstack - 1] == (int32) '&' ||", " \t\t\t\t\t\t\t\t\tstack[lenstack - 1] == (int32) '!'))", " \t\t\t\t{", " \t\t\t\t\tlenstack--;", " \t\t\t\t\tpushquery(state, OPR, stack[lenstack], 0, 0, 0);", " \t\t\t\t}", " \t\t\t\tbreak;", " \t\t\tcase CLOSE:", " \t\t\t\twhile (lenstack)", " \t\t\t\t{", " \t\t\t\t\tlenstack--;", " \t\t\t\t\tpushquery(state, OPR, stack[lenstack], 0, 0, 0);", " \t\t\t\t};", " \t\t\t\treturn END;", " \t\t\t\tbreak;", " \t\t\tcase ERR:", " \t\t\tdefault:", " \t\t\t\tereport(ERROR,", " \t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),", " \t\t\t\t\t\t errmsg(\"syntax error\")));", " \t\t\t\treturn ERR;", " \t\t}", " \t}", " \twhile (lenstack)", " \t{", " \t\tlenstack--;", " \t\tpushquery(state, OPR, stack[lenstack], 0, 0, 0);", " \t};", " \treturn END;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" externalParEntProcessor(XML_Parser parser, const char *s, const char *end,", "                         const char **nextPtr) {", "   const char *next = s;", "   int tok;", "   tok = XmlPrologTok(parser->m_encoding, s, end, &next);", "   if (tok <= 0) {", "     if (! parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {", "       *nextPtr = s;", "       return XML_ERROR_NONE;", "     }", "     switch (tok) {", "     case XML_TOK_INVALID:", "       return XML_ERROR_INVALID_TOKEN;", "     case XML_TOK_PARTIAL:", "       return XML_ERROR_UNCLOSED_TOKEN;", "     case XML_TOK_PARTIAL_CHAR:", "       return XML_ERROR_PARTIAL_CHAR;", "     case XML_TOK_NONE:  ", "     default:", "       break;", "     }", "   }", "   else if (tok == XML_TOK_BOM) {", "     s = next;", "     tok = XmlPrologTok(parser->m_encoding, s, end, &next);", "   }", "    parser->m_processor = prologProcessor;", "    return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,", "                  (XML_Bool)! parser->m_parsingStatus.finalBuffer);", "                   (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0]}
{"tokens": [" int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,", "                             size_t size)", " {", "     GetBitContext gb;", "     AC3HeaderInfo *hdr;", "     int err;", "     if (!*phdr)", "         *phdr = av_mallocz(sizeof(AC3HeaderInfo));", "     if (!*phdr)", "          return AVERROR(ENOMEM);", "      hdr = *phdr;", "    init_get_bits8(&gb, buf, size);", "     err = init_get_bits8(&gb, buf, size);", "     if (err < 0)", "         return AVERROR_INVALIDDATA;", "      err = ff_ac3_parse_header(&gb, hdr);", "      if (err < 0)", "          return AVERROR_INVALIDDATA;", "     return get_bits_count(&gb);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" sf_open\t(const char *path, int mode, SF_INFO *sfinfo)", " {\tSF_PRIVATE \t*psf ;", "  \tassert (sizeof (sf_count_t) == 8) ;", "\tif ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)", " \tif ((psf = psf_allocate ()) == NULL)", "  \t{\tsf_errno = SFE_MALLOC_FAILED ;", "  \t\treturn\tNULL ;", "  \t\t} ;", " \tpsf_init_files (psf) ;", " \tpsf_log_printf (psf, \"File : %s\\n\", path) ;", " \tif (copy_filename (psf, path) != 0)", " \t{\tsf_errno = psf->error ;", " \t\treturn\tNULL ;", " \t\t} ;", " \tpsf->file.mode = mode ;", " \tif (strcmp (path, \"-\") == 0)", " \t\tpsf->error = psf_set_stdio (psf) ;", " \telse", " \t\tpsf->error = psf_fopen (psf) ;", " \treturn psf_open_file (psf, sfinfo) ;", " }  "], "ner_tags": [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int ff_jpeg2000_init_component(Jpeg2000Component *comp,", "                                Jpeg2000CodingStyle *codsty,", "                                Jpeg2000QuantStyle *qntsty,", "                                int cbps, int dx, int dy,", "                                AVCodecContext *avctx)", " {", "     uint8_t log2_band_prec_width, log2_band_prec_height;", "     int reslevelno, bandno, gbandno = 0, ret, i, j;", "     uint32_t csize;", "     if (codsty->nreslevels2decode <= 0) {", "         av_log(avctx, AV_LOG_ERROR, \"nreslevels2decode %d invalid or uninitialized\\n\", codsty->nreslevels2decode);", "         return AVERROR_INVALIDDATA;", "     }", "     if (ret = ff_jpeg2000_dwt_init(&comp->dwt, comp->coord,", "                                    codsty->nreslevels2decode - 1,", "                                    codsty->transform))", "         return ret;", "     csize = (comp->coord[0][1] - comp->coord[0][0]) *", "             (comp->coord[1][1] - comp->coord[1][0]);", "     if (codsty->transform == FF_DWT97) {", "         comp->i_data = NULL;", "         comp->f_data = av_malloc_array(csize, sizeof(*comp->f_data));", "         if (!comp->f_data)", "             return AVERROR(ENOMEM);", "     } else {", "         comp->f_data = NULL;", "         comp->i_data = av_malloc_array(csize, sizeof(*comp->i_data));", "         if (!comp->i_data)", "             return AVERROR(ENOMEM);", "     }", "     comp->reslevel = av_malloc_array(codsty->nreslevels, sizeof(*comp->reslevel));", "     if (!comp->reslevel)", "         return AVERROR(ENOMEM);", "     for (reslevelno = 0; reslevelno < codsty->nreslevels; reslevelno++) {", "         int declvl = codsty->nreslevels - reslevelno;     ", "         Jpeg2000ResLevel *reslevel = comp->reslevel + reslevelno;", "         for (i = 0; i < 2; i++)", "             for (j = 0; j < 2; j++)", "                 reslevel->coord[i][j] =", "                     ff_jpeg2000_ceildivpow2(comp->coord_o[i][j], declvl - 1);", "         reslevel->log2_prec_width  = codsty->log2_prec_widths[reslevelno];", "         reslevel->log2_prec_height = codsty->log2_prec_heights[reslevelno];", "         if (reslevelno == 0)", "             reslevel->nbands = 1;", "         else", "             reslevel->nbands = 3;", "         if (reslevel->coord[0][1] == reslevel->coord[0][0])", "             reslevel->num_precincts_x = 0;", "         else", "             reslevel->num_precincts_x =", "                 ff_jpeg2000_ceildivpow2(reslevel->coord[0][1],", "                                         reslevel->log2_prec_width) -", "                 (reslevel->coord[0][0] >> reslevel->log2_prec_width);", "         if (reslevel->coord[1][1] == reslevel->coord[1][0])", "             reslevel->num_precincts_y = 0;", "         else", "             reslevel->num_precincts_y =", "                 ff_jpeg2000_ceildivpow2(reslevel->coord[1][1],", "                                          reslevel->log2_prec_height) -", "                  (reslevel->coord[1][0] >> reslevel->log2_prec_height);", "        reslevel->band = av_malloc_array(reslevel->nbands, sizeof(*reslevel->band));", "         reslevel->band = av_calloc(reslevel->nbands, sizeof(*reslevel->band));", "          if (!reslevel->band)", "              return AVERROR(ENOMEM);", "         for (bandno = 0; bandno < reslevel->nbands; bandno++, gbandno++) {", "             Jpeg2000Band *band = reslevel->band + bandno;", "             int cblkno, precno;", "             int nb_precincts;", "             switch (qntsty->quantsty) {", "                 uint8_t gain;", "                 int numbps;", "             case JPEG2000_QSTY_NONE:", "                 band->f_stepsize = 1;", "                 break;", "             case JPEG2000_QSTY_SI:", "                 numbps = cbps +", "                          lut_gain[codsty->transform == FF_DWT53][bandno + (reslevelno > 0)];", "                 band->f_stepsize = SHL(2048 + qntsty->mant[gbandno],", "                                        2 + numbps - qntsty->expn[gbandno]);", "                 break;", "             case JPEG2000_QSTY_SE:", "                 gain            = cbps;", "                 band->f_stepsize  = pow(2.0, gain - qntsty->expn[gbandno]);", "                 band->f_stepsize *= qntsty->mant[gbandno] / 2048.0 + 1.0;", "                 break;", "             default:", "                 band->f_stepsize = 0;", "                 av_log(avctx, AV_LOG_ERROR, \"Unknown quantization format\\n\");", "                 break;", "             }", "             if (!av_codec_is_encoder(avctx->codec))", "                 band->f_stepsize *= 0.5;", "             band->i_stepsize = band->f_stepsize * (1 << 15);", "             if (reslevelno == 0) {", "                 for (i = 0; i < 2; i++)", "                     for (j = 0; j < 2; j++)", "                         band->coord[i][j] =", "                             ff_jpeg2000_ceildivpow2(comp->coord_o[i][j] - comp->coord_o[i][0],", "                                                     declvl - 1);", "                 log2_band_prec_width  = reslevel->log2_prec_width;", "                 log2_band_prec_height = reslevel->log2_prec_height;", "                 band->log2_cblk_width  = FFMIN(codsty->log2_cblk_width,", "                                                reslevel->log2_prec_width);", "                 band->log2_cblk_height = FFMIN(codsty->log2_cblk_height,", "                                                reslevel->log2_prec_height);", "             } else {", "                 for (i = 0; i < 2; i++)", "                     for (j = 0; j < 2; j++)", "                         band->coord[i][j] =", "                             ff_jpeg2000_ceildivpow2(comp->coord_o[i][j] - comp->coord_o[i][0] -", "                                                     (((bandno + 1 >> i) & 1) << declvl - 1),", "                                                     declvl);", "                 band->log2_cblk_width  = FFMIN(codsty->log2_cblk_width,", "                                                reslevel->log2_prec_width - 1);", "                 band->log2_cblk_height = FFMIN(codsty->log2_cblk_height,", "                                                reslevel->log2_prec_height - 1);", "                 log2_band_prec_width  = reslevel->log2_prec_width  - 1;", "                 log2_band_prec_height = reslevel->log2_prec_height - 1;", "             }", "             for (j = 0; j < 2; j++)", "                 band->coord[0][j] = ff_jpeg2000_ceildiv(band->coord[0][j], dx);", "              for (j = 0; j < 2; j++)", "                  band->coord[1][j] = ff_jpeg2000_ceildiv(band->coord[1][j], dy);", "            band->prec = av_malloc_array(reslevel->num_precincts_x *", "             band->prec = av_calloc(reslevel->num_precincts_x *", "                                           (uint64_t)reslevel->num_precincts_y,", "                                           sizeof(*band->prec));", "              if (!band->prec)", "                 return AVERROR(ENOMEM);", "             nb_precincts = reslevel->num_precincts_x * reslevel->num_precincts_y;", "             for (precno = 0; precno < nb_precincts; precno++) {", "                 Jpeg2000Prec *prec = band->prec + precno;", "                 prec->coord[0][0] = (precno % reslevel->num_precincts_x) *", "                                     (1 << log2_band_prec_width);", "                 prec->coord[0][0] = FFMAX(prec->coord[0][0], band->coord[0][0]);", "                 prec->coord[1][0] = (precno / reslevel->num_precincts_x) *", "                                     (1 << log2_band_prec_height);", "                 prec->coord[1][0] = FFMAX(prec->coord[1][0], band->coord[1][0]);", "                 prec->coord[0][1] = prec->coord[0][0] +", "                                     (1 << log2_band_prec_width);", "                 prec->coord[0][1] = FFMIN(prec->coord[0][1], band->coord[0][1]);", "                 prec->coord[1][1] = prec->coord[1][0] +", "                                     (1 << log2_band_prec_height);", "                 prec->coord[1][1] = FFMIN(prec->coord[1][1], band->coord[1][1]);", "                 prec->nb_codeblocks_width =", "                     ff_jpeg2000_ceildivpow2(prec->coord[0][1] -", "                                             prec->coord[0][0],", "                                             band->log2_cblk_width);", "                 prec->nb_codeblocks_height =", "                     ff_jpeg2000_ceildivpow2(prec->coord[1][1] -", "                                             prec->coord[1][0],", "                                             band->log2_cblk_height);", "                 prec->cblkincl =", "                     ff_jpeg2000_tag_tree_init(prec->nb_codeblocks_width,", "                                               prec->nb_codeblocks_height);", "                 if (!prec->cblkincl)", "                     return AVERROR(ENOMEM);", "                 prec->zerobits =", "                     ff_jpeg2000_tag_tree_init(prec->nb_codeblocks_width,", "                                               prec->nb_codeblocks_height);", "                 if (!prec->zerobits)", "                     return AVERROR(ENOMEM);", "                 prec->cblk = av_mallocz_array(prec->nb_codeblocks_width *", "                                               (uint64_t)prec->nb_codeblocks_height,", "                                               sizeof(*prec->cblk));", "                 if (!prec->cblk)", "                     return AVERROR(ENOMEM);", "                 for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) {", "                     Jpeg2000Cblk *cblk = prec->cblk + cblkno;", "                     uint16_t Cx0, Cy0;", "                     Cx0 = (prec->coord[0][0] >> band->log2_cblk_width) << band->log2_cblk_width;", "                     Cx0 = Cx0 + ((cblkno % prec->nb_codeblocks_width)  << band->log2_cblk_width);", "                     cblk->coord[0][0] = FFMAX(Cx0, prec->coord[0][0]);", "                     Cy0 = (prec->coord[1][0] >> band->log2_cblk_height) << band->log2_cblk_height;", "                     Cy0 = Cy0 + ((cblkno / prec->nb_codeblocks_width)   << band->log2_cblk_height);", "                     cblk->coord[1][0] = FFMAX(Cy0, prec->coord[1][0]);", "                     cblk->coord[0][1] = FFMIN(Cx0 + (1 << band->log2_cblk_width),", "                                               prec->coord[0][1]);", "                     cblk->coord[1][1] = FFMIN(Cy0 + (1 << band->log2_cblk_height),", "                                               prec->coord[1][1]);", "                     if ((bandno + !!reslevelno) & 1) {", "                         cblk->coord[0][0] += comp->reslevel[reslevelno-1].coord[0][1] -", "                                              comp->reslevel[reslevelno-1].coord[0][0];", "                         cblk->coord[0][1] += comp->reslevel[reslevelno-1].coord[0][1] -", "                                              comp->reslevel[reslevelno-1].coord[0][0];", "                     }", "                     if ((bandno + !!reslevelno) & 2) {", "                         cblk->coord[1][0] += comp->reslevel[reslevelno-1].coord[1][1] -", "                                              comp->reslevel[reslevelno-1].coord[1][0];", "                         cblk->coord[1][1] += comp->reslevel[reslevelno-1].coord[1][1] -", "                                              comp->reslevel[reslevelno-1].coord[1][0];", "                     }", "                     cblk->zero      = 0;", "                     cblk->lblock    = 3;", "                     cblk->length    = 0;", "                     cblk->lengthinc = 0;", "                     cblk->npasses   = 0;", "                 }", "             }", "         }", "     }", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int dns_parse_callback(void *c, int rr, const void *data, int len, const void *packet)", "  {", "  \tchar tmp[256];", "  \tstruct dpc_ctx *ctx = c;", " \tif (ctx->cnt >= MAXADDRS) return -1;", "  \tswitch (rr) {", "  \tcase RR_A:", "  \t\tif (len != 4) return -1;", " \t\tctx->addrs[ctx->cnt].scopeid = 0;", " \t\tmemcpy(ctx->addrs[ctx->cnt++].addr, data, 4);", " \t\tbreak;", " \tcase RR_AAAA:", " \t\tif (len != 16) return -1;", " \t\tctx->addrs[ctx->cnt].family = AF_INET6;", " \t\tctx->addrs[ctx->cnt].scopeid = 0;", " \t\tmemcpy(ctx->addrs[ctx->cnt++].addr, data, 16);", " \t\tbreak;", " \tcase RR_CNAME:", " \t\tif (__dn_expand(packet, (const unsigned char *)packet + 512,", " \t\t    data, tmp, sizeof tmp) > 0 && is_valid_hostname(tmp))", " \t\t\tstrcpy(ctx->canon, tmp);", " \t\tbreak;", " \t}", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" XineramaXvShmPutImage(ClientPtr client)", "  {", "      REQUEST(xvShmPutImageReq);", "      PanoramiXRes *draw, *gc, *port;", "    Bool send_event = stuff->send_event;", "     Bool send_event;", "      Bool isRoot;", "      int result, i, x, y;", "      REQUEST_SIZE_MATCH(xvShmPutImageReq);", "     send_event = stuff->send_event;", "      result = dixLookupResourceByClass((void **) &draw, stuff->drawable,", "                                        XRC_DRAWABLE, client, DixWriteAccess);", "      if (result != Success)", "     result = dixLookupResourceByType((void **) &gc, stuff->gc,", "                                      XRT_GC, client, DixReadAccess);", "     if (result != Success)", "         return result;", "     result = dixLookupResourceByType((void **) &port, stuff->port,", "                                      XvXRTPort, client, DixReadAccess);", "     if (result != Success)", "         return result;", "     isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;", "     x = stuff->drw_x;", "     y = stuff->drw_y;", "     FOR_NSCREENS_BACKWARD(i) {", "         if (port->info[i].id) {", "             stuff->drawable = draw->info[i].id;", "             stuff->port = port->info[i].id;", "             stuff->gc = gc->info[i].id;", "             stuff->drw_x = x;", "             stuff->drw_y = y;", "             if (isRoot) {", "                 stuff->drw_x -= screenInfo.screens[i]->x;", "                 stuff->drw_y -= screenInfo.screens[i]->y;", "             }", "             stuff->send_event = (send_event && !i) ? 1 : 0;", "             result = ProcXvShmPutImage(client);", "         }", "     }", "     return result;", " }"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int cg_opendir(const char *path, struct fuse_file_info *fi)", " {", " \tstruct fuse_context *fc = fuse_get_context();", " \tconst char *cgroup;", " \tstruct file_info *dir_info;", " \tchar *controller = NULL;", " \tif (!fc)", " \t\treturn -EIO;", " \tif (strcmp(path, \"/cgroup\") == 0) {", " \t\tcgroup = NULL;", " \t\tcontroller = NULL;", " \t} else {", " \t\tcontroller = pick_controller_from_path(fc, path);", " \t\tif (!controller)", " \t\t\treturn -EIO;", " \t\tcgroup = find_cgroup_in_path(path);", " \t\tif (!cgroup) {", " \t\t\tcgroup = \"/\";", "  \t\t}", "  \t}", "\tif (cgroup && !fc_may_access(fc, controller, cgroup, NULL, O_RDONLY)) {", "\t\treturn -EACCES;", " \tif (cgroup) {", " \t\tif (!caller_may_see_dir(fc->pid, controller, cgroup))", " \t\t\treturn -ENOENT;", " \t\tif (!fc_may_access(fc, controller, cgroup, NULL, O_RDONLY))", " \t\t\treturn -EACCES;", "  \t}", " \tdir_info = malloc(sizeof(*dir_info));", " \tif (!dir_info)", " \t\treturn -ENOMEM;", " \tdir_info->controller = must_copy_string(controller);", " \tdir_info->cgroup = must_copy_string(cgroup);", " \tdir_info->type = LXC_TYPE_CGDIR;", " \tdir_info->buf = NULL;", " \tdir_info->file = NULL;", " \tdir_info->buflen = 0;", " \tfi->fh = (unsigned long)dir_info;", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int yr_object_array_set_item(", "     YR_OBJECT* object,", "     YR_OBJECT* item,", "     int index)", " {", "   YR_OBJECT_ARRAY* array;", "   int i;", "   int count;", "   assert(index >= 0);", "   assert(object->type == OBJECT_TYPE_ARRAY);", "   array = object_as_array(object);", "    if (array->items == NULL)", "    {", "    count = yr_max(64, (index + 1) * 2);", "     count = 64;", "     while (count <= index)", "       count *= 2;", "      array->items = (YR_ARRAY_ITEMS*) yr_malloc(", "          sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));", "     if (array->items == NULL)", "       return ERROR_INSUFFICIENT_MEMORY;", "     memset(array->items->objects, 0, count * sizeof(YR_OBJECT*));", "     array->items->count = count;", "   }", "    else if (index >= array->items->count)", "    {", "      count = array->items->count * 2;", "     while (count <= index)", "       count *= 2;", "      array->items = (YR_ARRAY_ITEMS*) yr_realloc(", "          array->items,", "          sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));", "     if (array->items == NULL)", "       return ERROR_INSUFFICIENT_MEMORY;", "     for (i = array->items->count; i < count; i++)", "       array->items->objects[i] = NULL;", "     array->items->count = count;", "   }", "   item->parent = object;", "   array->items->objects[index] = item;", "   return ERROR_SUCCESS;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int http_read_stream(URLContext *h, uint8_t *buf, int size)", " {", "     HTTPContext *s = h->priv_data;", "     int err, new_location, read_ret;", "     int64_t seek_ret;", "     if (!s->hd)", "         return AVERROR_EOF;", "     if (s->end_chunked_post && !s->end_header) {", "         err = http_read_header(h, &new_location);", "         if (err < 0)", "              return err;", "      }", "    if (s->chunksize >= 0) {", "     if (s->chunksize != UINT64_MAX) {", "          if (!s->chunksize) {", "              char line[32];", "                 do {", "                     if ((err = http_get_line(s, line, sizeof(line))) < 0)", "                          return err;", "                  } while (!*line);     ", "                s->chunksize = strtoll(line, NULL, 16);", "                 s->chunksize = strtoull(line, NULL, 16);", "                av_log(NULL, AV_LOG_TRACE, \"Chunked encoding data size: %\"PRId64\"'\\n\",", "                 av_log(h, AV_LOG_TRACE,", "                        \"Chunked encoding data size: %\"PRIu64\"'\\n\",", "                          s->chunksize);", "                  if (!s->chunksize)", "                      return 0;", "                 else if (s->chunksize == UINT64_MAX) {", "                     av_log(h, AV_LOG_ERROR, \"Invalid chunk size %\"PRIu64\"\\n\",", "                            s->chunksize);", "                     return AVERROR(EINVAL);", "                 }", "          }", "          size = FFMIN(size, s->chunksize);", "      }", " #if CONFIG_ZLIB", "     if (s->compressed)", "         return http_buf_read_compressed(h, buf, size);", " #endif  ", "      read_ret = http_buf_read(h, buf, size);", "      if (   (read_ret  < 0 && s->reconnect        && (!h->is_streamed || s->reconnect_streamed) && s->filesize > 0 && s->off < s->filesize)", "          || (read_ret == 0 && s->reconnect_at_eof && (!h->is_streamed || s->reconnect_streamed))) {", "        int64_t target = h->is_streamed ? 0 : s->off;", "         uint64_t target = h->is_streamed ? 0 : s->off;", "          if (s->reconnect_delay > s->reconnect_delay_max)", "              return AVERROR(EIO);", "        av_log(h, AV_LOG_INFO, \"Will reconnect at %\"PRId64\" error=%s.\\n\", s->off, av_err2str(read_ret));", "         av_log(h, AV_LOG_INFO, \"Will reconnect at %\"PRIu64\" error=%s.\\n\", s->off, av_err2str(read_ret));", "          av_usleep(1000U*1000*s->reconnect_delay);", "          s->reconnect_delay = 1 + 2*s->reconnect_delay;", "          seek_ret = http_seek_internal(h, target, SEEK_SET, 1);", "          if (seek_ret != target) {", "            av_log(h, AV_LOG_ERROR, \"Failed to reconnect at %\"PRId64\".\\n\", target);", "             av_log(h, AV_LOG_ERROR, \"Failed to reconnect at %\"PRIu64\".\\n\", target);", "              return read_ret;", "          }", "         read_ret = http_buf_read(h, buf, size);", "     } else", "         s->reconnect_delay = 0;", "     return read_ret;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int_x509_param_set_hosts(X509_VERIFY_PARAM_ID *id, int mode,", "     const char *name, size_t namelen)", "  {", "  \tchar *copy;", " \tif (name != NULL && namelen == 0)", " \t\tnamelen = strlen(name);", " \tif (name && memchr(name, '\\0', namelen))", " \t\treturn 0;", " \tif (mode == SET_HOST && id->hosts) {", " \t\tstring_stack_free(id->hosts);", " \t\tid->hosts = NULL;", " \t}", " \tif (name == NULL || namelen == 0)", " \t\treturn 1;", " \tcopy = strndup(name, namelen);", " \tif (copy == NULL)", " \t\treturn 0;", " \tif (id->hosts == NULL &&", " \t    (id->hosts = sk_OPENSSL_STRING_new_null()) == NULL) {", " \t\tfree(copy);", " \t\treturn 0;", " \t}", " \tif (!sk_OPENSSL_STRING_push(id->hosts, copy)) {", " \t\tfree(copy);", " \t\tif (sk_OPENSSL_STRING_num(id->hosts) == 0) {", " \t\t\tsk_OPENSSL_STRING_free(id->hosts);", " \t\t\tid->hosts = NULL;", " \t\t}", " \t\treturn 0;", " \t}", " \treturn 1;", " }"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static int jas_iccgetuint16(jas_stream_t *in, jas_iccuint16_t *val)", "  {", "\tulonglong tmp;", " \tjas_ulonglong tmp;", "  \tif (jas_iccgetuint(in, 2, &tmp))", "  \t\treturn -1;", "  \t*val = tmp;", " \treturn 0;", " }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" const char *string_of_NPPVariable(int variable)", " {", "   const char *str;", "   switch (variable) {", " #define _(VAL) case VAL: str = #VAL; break;", " \t_(NPPVpluginNameString);", " \t_(NPPVpluginDescriptionString);", " \t_(NPPVpluginWindowBool);", " \t_(NPPVpluginTransparentBool);", " \t_(NPPVjavaClass);", " \t_(NPPVpluginWindowSize);", " \t_(NPPVpluginTimerInterval);", " \t_(NPPVpluginScriptableInstance);", " \t_(NPPVpluginScriptableIID);", " \t_(NPPVjavascriptPushCallerBool);", " \t_(NPPVpluginKeepLibraryInMemory);", "  \t_(NPPVpluginNeedsXEmbed);", "  \t_(NPPVpluginScriptableNPObject);", "  \t_(NPPVformValue);", " \t_(NPPVpluginUrlRequestsDisplayedBool);", " \t_(NPPVpluginWantsAllNetworkStreams);", " \t_(NPPVpluginNativeAccessibleAtkPlugId);", " \t_(NPPVpluginCancelSrcStream);", " \t_(NPPVSupportsAdvancedKeyHandling);", "  #undef _", "    default:", "  \tswitch (variable & 0xff) {", " #define _(VAL, VAR) case VAL: str = #VAR; break", " \t  _(10, NPPVpluginScriptableInstance);", " #undef _", " \tdefault:", " \t  str = \"<unknown variable>\";", " \t  break;", " \t}", " \tbreak;", "   }", "   return str;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" internalEntityProcessor(XML_Parser parser, const char *s, const char *end,", "                         const char **nextPtr) {", "   ENTITY *entity;", "   const char *textStart, *textEnd;", "   const char *next;", "   enum XML_Error result;", "   OPEN_INTERNAL_ENTITY *openEntity = parser->m_openInternalEntities;", "   if (! openEntity)", "     return XML_ERROR_UNEXPECTED_STATE;", "   entity = openEntity->entity;", "   textStart = ((char *)entity->textPtr) + entity->processed;", "   textEnd = (char *)(entity->textPtr + entity->textLen);", "   next = textStart;", " #ifdef XML_DTD", "   if (entity->is_param) {", "      int tok", "          = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);", "      result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,", "                      tok, next, &next, XML_FALSE);", "                       tok, next, &next, XML_FALSE, XML_TRUE);", "    } else", "  #endif  ", "      result = doContent(parser, openEntity->startTagLevel,", "                        parser->m_internalEncoding, textStart, textEnd, &next,", "                        XML_FALSE);", "   if (result != XML_ERROR_NONE)", "     return result;", "   else if (textEnd != next", "            && parser->m_parsingStatus.parsing == XML_SUSPENDED) {", "     entity->processed = (int)(next - (char *)entity->textPtr);", "     return result;", "   } else {", "     entity->open = XML_FALSE;", "     parser->m_openInternalEntities = openEntity->next;", "     openEntity->next = parser->m_freeInternalEntities;", "     parser->m_freeInternalEntities = openEntity;", "   }", " #ifdef XML_DTD", "   if (entity->is_param) {", "     int tok;", "      parser->m_processor = prologProcessor;", "      tok = XmlPrologTok(parser->m_encoding, s, end, &next);", "      return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,", "                    (XML_Bool)! parser->m_parsingStatus.finalBuffer);", "                     (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE);", "    } else", "  #endif  ", "    {", "     parser->m_processor = contentProcessor;", "     return doContent(parser, parser->m_parentParser ? 1 : 0, parser->m_encoding,", "                      s, end, nextPtr,", "                      (XML_Bool)! parser->m_parsingStatus.finalBuffer);", "   }", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" add_job(cupsd_client_t  *con,\t\t ", " \tcupsd_printer_t *printer,\t ", " \tmime_type_t     *filetype)\t ", " {", "   http_status_t\tstatus;\t\t\t ", "   ipp_attribute_t *attr,\t\t ", " \t\t*auth_info;\t\t ", "   const char\t*mandatory;\t\t ", "   const char\t*val;\t\t\t ", "   int\t\tpriority;\t\t ", "   cupsd_job_t\t*job;\t\t\t ", "   char\t\tjob_uri[HTTP_MAX_URI];\t ", "   int\t\tkbytes;\t\t\t ", "   int\t\ti;\t\t\t ", "   int\t\tlowerpagerange;\t\t ", "   int\t\texact;\t\t\t ", "   ipp_attribute_t *media_col,\t\t ", " \t\t*media_margin;\t\t ", "   ipp_t\t\t*unsup_col;\t\t ", "   static const char * const readonly[] = ", "   {", "     \"date-time-at-completed\",", "     \"date-time-at-creation\",", "     \"date-time-at-processing\",", "     \"job-detailed-status-messages\",", "     \"job-document-access-errors\",", "     \"job-id\",", "     \"job-impressions-completed\",", "     \"job-k-octets-completed\",", "     \"job-media-sheets-completed\",", "     \"job-pages-completed\",", "     \"job-printer-up-time\",", "     \"job-printer-uri\",", "     \"job-state\",", "     \"job-state-message\",", "     \"job-state-reasons\",", "     \"job-uri\",", "     \"number-of-documents\",", "     \"number-of-intervening-jobs\",", "     \"output-device-assigned\",", "     \"time-at-completed\",", "     \"time-at-creation\",", "     \"time-at-processing\"", "   };", "   cupsdLogMessage(CUPSD_LOG_DEBUG2, \"add_job(%p[%d], %p(%s), %p(%s/%s))\",", "                   con, con->number, printer, printer->name,", " \t\t  filetype, filetype ? filetype->super : \"none\",", " \t\t  filetype ? filetype->type : \"none\");", "   if (!printer->shared &&", "       _cups_strcasecmp(con->http->hostname, \"localhost\") &&", "       _cups_strcasecmp(con->http->hostname, ServerName))", "   {", "     send_ipp_status(con, IPP_NOT_AUTHORIZED,", "                     _(\"The printer or class is not shared.\"));", "     return (NULL);", "   }", "   auth_info = ippFindAttribute(con->request, \"auth-info\", IPP_TAG_TEXT);", "   if ((status = cupsdCheckPolicy(printer->op_policy_ptr, con, NULL)) != HTTP_OK)", "   {", "     send_http_error(con, status, printer);", "     return (NULL);", "   }", "   else if (printer->num_auth_info_required == 1 &&", "            !strcmp(printer->auth_info_required[0], \"negotiate\") &&", "            !con->username[0])", "   {", "     send_http_error(con, HTTP_UNAUTHORIZED, printer);", "     return (NULL);", "   }", " #ifdef HAVE_SSL", "   else if (auth_info && !con->http->tls &&", "            !httpAddrLocalhost(con->http->hostaddr))", "   {", "     send_http_error(con, HTTP_UPGRADE_REQUIRED, printer);", "     return (NULL);", "   }", " #endif  ", "   if (!printer->accepting)", "   {", "     send_ipp_status(con, IPP_NOT_ACCEPTING,", "                     _(\"Destination \\\"%s\\\" is not accepting jobs.\"),", "                     printer->name);", "     return (NULL);", "   }", "   for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++)", "   {", "     if ((attr = ippFindAttribute(con->request, readonly[i], IPP_TAG_ZERO)) != NULL)", "     {", "       ippDeleteAttribute(con->request, attr);", "       if (StrictConformance)", "       {", " \tsend_ipp_status(con, IPP_BAD_REQUEST, _(\"The '%s' Job Status attribute cannot be supplied in a job creation request.\"), readonly[i]);", " \treturn (NULL);", "       }", "       cupsdLogMessage(CUPSD_LOG_INFO, \"Unexpected '%s' Job Status attribute in a job creation request.\", readonly[i]);", "     }", "   }", "   if (printer->pc)", "   {", "     for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);", " \t mandatory;", " \t mandatory = (char *)cupsArrayNext(printer->pc->mandatory))", "     {", "       if (!ippFindAttribute(con->request, mandatory, IPP_TAG_ZERO))", "       {", " \tsend_ipp_status(con, IPP_CONFLICT,", " \t\t\t_(\"The \\\"%s\\\" attribute is required for print jobs.\"),", " \t\t\tmandatory);", " \treturn (NULL);", "       }", "     }", "   }", "   if (filetype && printer->filetypes &&", "       !cupsArrayFind(printer->filetypes, filetype))", "   {", "     char\tmimetype[MIME_MAX_SUPER + MIME_MAX_TYPE + 2];", "     snprintf(mimetype, sizeof(mimetype), \"%s/%s\", filetype->super,", "              filetype->type);", "     send_ipp_status(con, IPP_DOCUMENT_FORMAT,", "                     _(\"Unsupported format \\\"%s\\\".\"), mimetype);", "     ippAddString(con->response, IPP_TAG_UNSUPPORTED_GROUP, IPP_TAG_MIMETYPE,", "                  \"document-format\", NULL, mimetype);", "     return (NULL);", "   }", "   if ((attr = ippFindAttribute(con->request, \"copies\",", "                                IPP_TAG_INTEGER)) != NULL)", "   {", "     if (attr->values[0].integer < 1 || attr->values[0].integer > MaxCopies)", "     {", "       send_ipp_status(con, IPP_ATTRIBUTES, _(\"Bad copies value %d.\"),", "                       attr->values[0].integer);", "       ippAddInteger(con->response, IPP_TAG_UNSUPPORTED_GROUP, IPP_TAG_INTEGER,", " \t            \"copies\", attr->values[0].integer);", "       return (NULL);", "     }", "   }", "   if ((attr = ippFindAttribute(con->request, \"job-sheets\",", "                                IPP_TAG_ZERO)) != NULL)", "   {", "     if (attr->value_tag != IPP_TAG_KEYWORD &&", "         attr->value_tag != IPP_TAG_NAME)", "     {", "       send_ipp_status(con, IPP_BAD_REQUEST, _(\"Bad job-sheets value type.\"));", "       return (NULL);", "     }", "     if (attr->num_values > 2)", "     {", "       send_ipp_status(con, IPP_BAD_REQUEST,", "                       _(\"Too many job-sheets values (%d > 2).\"),", " \t\t      attr->num_values);", "       return (NULL);", "     }", "     for (i = 0; i < attr->num_values; i ++)", "       if (strcmp(attr->values[i].string.text, \"none\") &&", "           !cupsdFindBanner(attr->values[i].string.text))", "       {", " \tsend_ipp_status(con, IPP_BAD_REQUEST, _(\"Bad job-sheets value \\\"%s\\\".\"),", " \t\t\tattr->values[i].string.text);", " \treturn (NULL);", "       }", "   }", "   if ((attr = ippFindAttribute(con->request, \"number-up\",", "                                IPP_TAG_INTEGER)) != NULL)", "   {", "     if (attr->values[0].integer != 1 &&", "         attr->values[0].integer != 2 &&", "         attr->values[0].integer != 4 &&", "         attr->values[0].integer != 6 &&", "         attr->values[0].integer != 9 &&", "         attr->values[0].integer != 16)", "     {", "       send_ipp_status(con, IPP_ATTRIBUTES, _(\"Bad number-up value %d.\"),", "                       attr->values[0].integer);", "       ippAddInteger(con->response, IPP_TAG_UNSUPPORTED_GROUP, IPP_TAG_INTEGER,", " \t            \"number-up\", attr->values[0].integer);", "       return (NULL);", "     }", "   }", "   if ((attr = ippFindAttribute(con->request, \"page-ranges\",", "                                IPP_TAG_RANGE)) != NULL)", "   {", "     for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++)", "     {", "       if (attr->values[i].range.lower < lowerpagerange ||", " \t  attr->values[i].range.lower > attr->values[i].range.upper)", "       {", " \tsend_ipp_status(con, IPP_BAD_REQUEST,", " \t                _(\"Bad page-ranges values %d-%d.\"),", " \t                attr->values[i].range.lower,", " \t\t\tattr->values[i].range.upper);", " \treturn (NULL);", "       }", "       lowerpagerange = attr->values[i].range.upper + 1;", "     }", "   }", "   if (!ippFindAttribute(con->request, \"PageRegion\", IPP_TAG_ZERO) &&", "       !ippFindAttribute(con->request, \"PageSize\", IPP_TAG_ZERO) &&", "       _ppdCacheGetPageSize(printer->pc, con->request, NULL, &exact))", "   {", "     if (!exact &&", "         (media_col = ippFindAttribute(con->request, \"media-col\",", " \t                              IPP_TAG_BEGIN_COLLECTION)) != NULL)", "     {", "       send_ipp_status(con, IPP_OK_SUBST, _(\"Unsupported margins.\"));", "       unsup_col = ippNew();", "       if ((media_margin = ippFindAttribute(media_col->values[0].collection,", "                                            \"media-bottom-margin\",", " \t\t\t\t\t   IPP_TAG_INTEGER)) != NULL)", "         ippAddInteger(unsup_col, IPP_TAG_ZERO, IPP_TAG_INTEGER,", " \t              \"media-bottom-margin\", media_margin->values[0].integer);", "       if ((media_margin = ippFindAttribute(media_col->values[0].collection,", "                                            \"media-left-margin\",", " \t\t\t\t\t   IPP_TAG_INTEGER)) != NULL)", "         ippAddInteger(unsup_col, IPP_TAG_ZERO, IPP_TAG_INTEGER,", " \t              \"media-left-margin\", media_margin->values[0].integer);", "       if ((media_margin = ippFindAttribute(media_col->values[0].collection,", "                                            \"media-right-margin\",", " \t\t\t\t\t   IPP_TAG_INTEGER)) != NULL)", "         ippAddInteger(unsup_col, IPP_TAG_ZERO, IPP_TAG_INTEGER,", " \t              \"media-right-margin\", media_margin->values[0].integer);", "       if ((media_margin = ippFindAttribute(media_col->values[0].collection,", "                                            \"media-top-margin\",", " \t\t\t\t\t   IPP_TAG_INTEGER)) != NULL)", "         ippAddInteger(unsup_col, IPP_TAG_ZERO, IPP_TAG_INTEGER,", " \t              \"media-top-margin\", media_margin->values[0].integer);", "       ippAddCollection(con->response, IPP_TAG_UNSUPPORTED_GROUP, \"media-col\",", "                        unsup_col);", "       ippDelete(unsup_col);", "     }", "   }", "   if (MaxJobs && cupsArrayCount(Jobs) >= MaxJobs)", "     cupsdCleanJobs();", "   if (MaxJobs && cupsArrayCount(Jobs) >= MaxJobs)", "   {", "     send_ipp_status(con, IPP_NOT_POSSIBLE, _(\"Too many active jobs.\"));", "     return (NULL);", "   }", "   if ((i = check_quotas(con, printer)) < 0)", "   {", "     send_ipp_status(con, IPP_NOT_POSSIBLE, _(\"Quota limit reached.\"));", "     return (NULL);", "   }", "   else if (i == 0)", "   {", "     send_ipp_status(con, IPP_NOT_AUTHORIZED, _(\"Not allowed to print.\"));", "     return (NULL);", "   }", "   if ((attr = ippFindAttribute(con->request, \"job-priority\",", "                                IPP_TAG_INTEGER)) != NULL)", "     priority = attr->values[0].integer;", "   else", "   {", "     if ((val = cupsGetOption(\"job-priority\", printer->num_options,", "                              printer->options)) != NULL)", "       priority = atoi(val);", "     else", "       priority = 50;", "     ippAddInteger(con->request, IPP_TAG_JOB, IPP_TAG_INTEGER, \"job-priority\",", "                   priority);", "   }", "   if ((attr = ippFindAttribute(con->request, \"job-name\", IPP_TAG_ZERO)) == NULL)", "     ippAddString(con->request, IPP_TAG_JOB, IPP_TAG_NAME, \"job-name\", NULL, \"Untitled\");", "   else if ((attr->value_tag != IPP_TAG_NAME &&", "             attr->value_tag != IPP_TAG_NAMELANG) ||", "            attr->num_values != 1)", "   {", "     send_ipp_status(con, IPP_ATTRIBUTES,", "                     _(\"Bad job-name value: Wrong type or count.\"));", "     if ((attr = ippCopyAttribute(con->response, attr, 0)) != NULL)", "       attr->group_tag = IPP_TAG_UNSUPPORTED_GROUP;", "     return (NULL);", "   }", "   else if (!ippValidateAttribute(attr))", "   {", "     send_ipp_status(con, IPP_ATTRIBUTES, _(\"Bad job-name value: %s\"),", "                     cupsLastErrorString());", "     if ((attr = ippCopyAttribute(con->response, attr, 0)) != NULL)", "       attr->group_tag = IPP_TAG_UNSUPPORTED_GROUP;", "      return (NULL);", "    }", "   attr = ippFindAttribute(con->request, \"requesting-user-name\", IPP_TAG_NAME);", "   if (attr && !ippValidateAttribute(attr))", "   {", "     send_ipp_status(con, IPP_ATTRIBUTES, _(\"Bad requesting-user-name value: %s\"), cupsLastErrorString());", "     if ((attr = ippCopyAttribute(con->response, attr, 0)) != NULL)", "       attr->group_tag = IPP_TAG_UNSUPPORTED_GROUP;", "     return (NULL);", "   }", "    if ((job = cupsdAddJob(priority, printer->name)) == NULL)", "    {", "      send_ipp_status(con, IPP_INTERNAL_ERROR,", "                     _(\"Unable to add job for destination \\\"%s\\\".\"),", " \t\t    printer->name);", "     return (NULL);", "   }", "   job->dtype   = printer->type & (CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE);", "   job->attrs   = con->request;", "   job->dirty   = 1;", "   con->request = ippNewRequest(job->attrs->request.op.operation_id);", "   cupsdMarkDirty(CUPSD_DIRTY_JOBS);", "    add_job_uuid(job);", "    apply_printer_defaults(printer, job);", "  attr = ippFindAttribute(job->attrs, \"requesting-user-name\", IPP_TAG_NAME);", "    if (con->username[0])", "    {", "      cupsdSetString(&job->username, con->username);", "     if (attr)", "       ippSetString(job->attrs, &attr, 0, con->username);", "   }", "   else if (attr)", "   {", "     cupsdLogMessage(CUPSD_LOG_DEBUG,", "                     \"add_job: requesting-user-name=\\\"%s\\\"\",", "                     attr->values[0].string.text);", "     cupsdSetString(&job->username, attr->values[0].string.text);", "   }", "   else", "     cupsdSetString(&job->username, \"anonymous\");", "   if (!attr)", "     ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_NAME,", "                  \"job-originating-user-name\", NULL, job->username);", "   else", "   {", "     ippSetGroupTag(job->attrs, &attr, IPP_TAG_JOB);", "     ippSetName(job->attrs, &attr, \"job-originating-user-name\");", "   }", "   if (con->username[0] || auth_info)", "   {", "     save_auth_info(con, job, auth_info);", "     if (auth_info)", "       ippDeleteAttribute(job->attrs, auth_info);", "   }", "   if ((attr = ippFindAttribute(con->request, \"job-name\", IPP_TAG_NAME)) != NULL)", "     cupsdSetString(&(job->name), attr->values[0].string.text);", "   if ((attr = ippFindAttribute(job->attrs, \"job-originating-host-name\",", "                                IPP_TAG_ZERO)) != NULL)", "   {", "     if (attr->value_tag != IPP_TAG_NAME ||", "         attr->num_values != 1 ||", "         strcmp(con->http->hostname, \"localhost\"))", "     {", "       ippDeleteAttribute(job->attrs, attr);", "       ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_NAME, \"job-originating-host-name\", NULL, con->http->hostname);", "     }", "     else", "       ippSetGroupTag(job->attrs, &attr, IPP_TAG_JOB);", "   }", "   else", "   {", "     ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_NAME,", "         \t \"job-originating-host-name\", NULL, con->http->hostname);", "   }", "   ippAddOutOfBand(job->attrs, IPP_TAG_JOB, IPP_TAG_NOVALUE, \"date-time-at-completed\");", "   ippAddDate(job->attrs, IPP_TAG_JOB, \"date-time-at-creation\", ippTimeToDate(time(NULL)));", "   ippAddOutOfBand(job->attrs, IPP_TAG_JOB, IPP_TAG_NOVALUE, \"date-time-at-processing\");", "   ippAddOutOfBand(job->attrs, IPP_TAG_JOB, IPP_TAG_NOVALUE, \"time-at-completed\");", "   ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_INTEGER, \"time-at-creation\", time(NULL));", "   ippAddOutOfBand(job->attrs, IPP_TAG_JOB, IPP_TAG_NOVALUE, \"time-at-processing\");", "   ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_INTEGER, \"job-id\", job->id);", "   job->state = ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_ENUM,", "                              \"job-state\", IPP_JOB_STOPPED);", "   job->state_value = (ipp_jstate_t)job->state->values[0].integer;", "   job->reasons = ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_KEYWORD,", "                               \"job-state-reasons\", NULL, \"job-incoming\");", "   job->impressions = ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_INTEGER, \"job-impressions-completed\", 0);", "   job->sheets = ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_INTEGER,", "                               \"job-media-sheets-completed\", 0);", "   ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_URI, \"job-printer-uri\", NULL,", "                printer->uri);", "   if ((attr = ippFindAttribute(job->attrs, \"job-k-octets\", IPP_TAG_INTEGER)) != NULL)", "     attr->values[0].integer = 0;", "   else", "     ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_INTEGER, \"job-k-octets\", 0);", "   if ((attr = ippFindAttribute(job->attrs, \"job-hold-until\",", "                                IPP_TAG_KEYWORD)) == NULL)", "     attr = ippFindAttribute(job->attrs, \"job-hold-until\", IPP_TAG_NAME);", "   if (!attr)", "   {", "     if ((val = cupsGetOption(\"job-hold-until\", printer->num_options,", "                              printer->options)) == NULL)", "       val = \"no-hold\";", "     attr = ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_KEYWORD,", "                         \"job-hold-until\", NULL, val);", "   }", "   if (printer->holding_new_jobs)", "   {", "     if (attr && strcmp(attr->values[0].string.text, \"no-hold\"))", "       cupsdSetJobHoldUntil(job, ippGetString(attr, 0, NULL), 0);", "     else", "       cupsdSetJobHoldUntil(job, \"indefinite\", 0);", "     job->state->values[0].integer = IPP_JOB_HELD;", "     job->state_value              = IPP_JOB_HELD;", "     ippSetString(job->attrs, &job->reasons, 0, \"job-held-on-create\");", "   }", "   else if (attr && strcmp(attr->values[0].string.text, \"no-hold\"))", "   {", "     cupsdSetJobHoldUntil(job, attr->values[0].string.text, 0);", "     job->state->values[0].integer = IPP_JOB_HELD;", "     job->state_value              = IPP_JOB_HELD;", "     ippSetString(job->attrs, &job->reasons, 0, \"job-hold-until-specified\");", "   }", "   else if (job->attrs->request.op.operation_id == IPP_CREATE_JOB)", "   {", "     job->hold_until               = time(NULL) + MultipleOperationTimeout;", "     job->state->values[0].integer = IPP_JOB_HELD;", "     job->state_value              = IPP_JOB_HELD;", "   }", "   else", "   {", "     job->state->values[0].integer = IPP_JOB_PENDING;", "     job->state_value              = IPP_JOB_PENDING;", "     ippSetString(job->attrs, &job->reasons, 0, \"none\");", "   }", "   if (!(printer->type & CUPS_PRINTER_REMOTE) || Classification)", "   {", "     if ((attr = ippFindAttribute(job->attrs, \"job-sheets\",", "                                  IPP_TAG_ZERO)) == NULL)", "     {", "       cupsdLogMessage(CUPSD_LOG_DEBUG,", "                       \"Adding default job-sheets values \\\"%s,%s\\\"...\",", "                       printer->job_sheets[0], printer->job_sheets[1]);", "       attr = ippAddStrings(job->attrs, IPP_TAG_JOB, IPP_TAG_NAME, \"job-sheets\",", "                            2, NULL, NULL);", "       ippSetString(job->attrs, &attr, 0, printer->job_sheets[0]);", "       ippSetString(job->attrs, &attr, 1, printer->job_sheets[1]);", "     }", "     job->job_sheets = attr;", "     if (Classification)", "     {", "       cupsdLogMessage(CUPSD_LOG_INFO,", "                       \"Classification=\\\"%s\\\", ClassifyOverride=%d\",", "                       Classification ? Classification : \"(null)\",", " \t\t      ClassifyOverride);", "       if (ClassifyOverride)", "       {", "         if (!strcmp(attr->values[0].string.text, \"none\") &&", " \t    (attr->num_values == 1 ||", " \t     !strcmp(attr->values[1].string.text, \"none\")))", "         {", "           ippSetString(job->attrs, &attr, 0, Classification);", " \t  cupsdLogJob(job, CUPSD_LOG_NOTICE, \"CLASSIFICATION FORCED \"", " \t                \t\t     \"job-sheets=\\\"%s,none\\\", \"", " \t\t\t\t\t     \"job-originating-user-name=\\\"%s\\\"\",", " \t              Classification, job->username);", " \t}", " \telse if (attr->num_values == 2 &&", " \t         strcmp(attr->values[0].string.text,", " \t\t        attr->values[1].string.text) &&", " \t\t strcmp(attr->values[0].string.text, \"none\") &&", " \t\t strcmp(attr->values[1].string.text, \"none\"))", "         {", "           ippSetString(job->attrs, &attr, 1, attr->values[0].string.text);", " \t  cupsdLogJob(job, CUPSD_LOG_NOTICE, \"CLASSIFICATION FORCED \"", " \t                \t\t     \"job-sheets=\\\"%s,%s\\\", \"", " \t\t\t\t\t     \"job-originating-user-name=\\\"%s\\\"\",", " \t\t      attr->values[0].string.text,", " \t\t      attr->values[1].string.text, job->username);", " \t}", " \telse if (strcmp(attr->values[0].string.text, Classification) &&", " \t         strcmp(attr->values[0].string.text, \"none\") &&", " \t\t (attr->num_values == 1 ||", " \t          (strcmp(attr->values[1].string.text, Classification) &&", " \t           strcmp(attr->values[1].string.text, \"none\"))))", "         {", " \t  if (attr->num_values == 1)", "             cupsdLogJob(job, CUPSD_LOG_NOTICE,", " \t\t\t\"CLASSIFICATION OVERRIDDEN \"", " \t\t\t\"job-sheets=\\\"%s\\\", \"", " \t\t\t\"job-originating-user-name=\\\"%s\\\"\",", " \t                attr->values[0].string.text, job->username);", "           else", "             cupsdLogJob(job, CUPSD_LOG_NOTICE,", " \t\t\t\"CLASSIFICATION OVERRIDDEN \"", " \t\t\t\"job-sheets=\\\"%s,%s\\\",fffff \"", " \t\t\t\"job-originating-user-name=\\\"%s\\\"\",", " \t\t\tattr->values[0].string.text,", " \t\t\tattr->values[1].string.text, job->username);", "         }", "       }", "       else if (strcmp(attr->values[0].string.text, Classification) &&", "                (attr->num_values == 1 ||", " \t       strcmp(attr->values[1].string.text, Classification)))", "       {", "         if (attr->num_values > 1 &&", " \t    !strcmp(attr->values[0].string.text, attr->values[1].string.text))", " \t{", "           ippSetString(job->attrs, &attr, 0, Classification);", "           ippSetString(job->attrs, &attr, 1, Classification);", " \t}", "         else", " \t{", "           if (attr->num_values == 1 ||", " \t      strcmp(attr->values[0].string.text, \"none\"))", "             ippSetString(job->attrs, &attr, 0, Classification);", "           if (attr->num_values > 1 &&", " \t      strcmp(attr->values[1].string.text, \"none\"))", " \t    ippSetString(job->attrs, &attr, 1, Classification);", "         }", "         if (attr->num_values > 1)", " \t  cupsdLogJob(job, CUPSD_LOG_NOTICE,", " \t\t      \"CLASSIFICATION FORCED \"", " \t\t      \"job-sheets=\\\"%s,%s\\\", \"", " \t\t      \"job-originating-user-name=\\\"%s\\\"\",", " \t\t      attr->values[0].string.text,", " \t\t      attr->values[1].string.text, job->username);", "         else", " \t  cupsdLogJob(job, CUPSD_LOG_NOTICE,", " \t\t      \"CLASSIFICATION FORCED \"", " \t\t      \"job-sheets=\\\"%s\\\", \"", " \t\t      \"job-originating-user-name=\\\"%s\\\"\",", " \t\t      Classification, job->username);", "       }", "     }", "     if (!(printer->type & CUPS_PRINTER_REMOTE))", "     {", "       cupsdLogJob(job, CUPSD_LOG_INFO, \"Adding start banner page \\\"%s\\\".\",", " \t\t  attr->values[0].string.text);", "       if ((kbytes = copy_banner(con, job, attr->values[0].string.text)) < 0)", "       {", "         cupsdSetJobState(job, IPP_JOB_ABORTED, CUPSD_JOB_PURGE,", " \t                 \"Aborting job because the start banner could not be \"", " \t\t\t \"copied.\");", "         return (NULL);", "       }", "       cupsdUpdateQuota(printer, job->username, 0, kbytes);", "     }", "   }", "   else if ((attr = ippFindAttribute(job->attrs, \"job-sheets\",", "                                     IPP_TAG_ZERO)) != NULL)", "     job->job_sheets = attr;", "   httpAssembleURIf(HTTP_URI_CODING_ALL, job_uri, sizeof(job_uri), \"ipp\", NULL,", "                    con->clientname, con->clientport, \"/jobs/%d\", job->id);", "   ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_URI, \"job-uri\", NULL,", "                job_uri);", "   ippAddInteger(con->response, IPP_TAG_JOB, IPP_TAG_INTEGER, \"job-id\", job->id);", "   ippAddInteger(con->response, IPP_TAG_JOB, IPP_TAG_ENUM, \"job-state\",", "                 job->state_value);", "   ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_TEXT, \"job-state-message\", NULL, \"\");", "   ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_KEYWORD, \"job-state-reasons\",", "                NULL, job->reasons->values[0].string.text);", "   con->response->request.status.status_code = IPP_OK;", "   add_job_subscriptions(con, job);", "   for (attr = job->attrs->attrs->next->next; attr; attr = attr->next)", "     attr->group_tag = IPP_TAG_JOB;", "   cupsdAddEvent(CUPSD_EVENT_JOB_CREATED, printer, job, \"Job created.\");", "   return (job);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int decode_trns_chunk(AVCodecContext *avctx, PNGDecContext *s,", "                              uint32_t length)", "  {", "      int v, i;", "     if (!(s->state & PNG_IHDR)) {", "         av_log(avctx, AV_LOG_ERROR, \"trns before IHDR\\n\");", "         return AVERROR_INVALIDDATA;", "     }", "     if (s->state & PNG_IDAT) {", "         av_log(avctx, AV_LOG_ERROR, \"trns after IDAT\\n\");", "         return AVERROR_INVALIDDATA;", "     }", "      if (s->color_type == PNG_COLOR_TYPE_PALETTE) {", "          if (length > 256 || !(s->state & PNG_PLTE))", "              return AVERROR_INVALIDDATA;", "         for (i = 0; i < length; i++) {", "             v = bytestream2_get_byte(&s->gb);", "             s->palette[i] = (s->palette[i] & 0x00ffffff) | (v << 24);", "          }", "      } else if (s->color_type == PNG_COLOR_TYPE_GRAY || s->color_type == PNG_COLOR_TYPE_RGB) {", "          if ((s->color_type == PNG_COLOR_TYPE_GRAY && length != 2) ||", "            (s->color_type == PNG_COLOR_TYPE_RGB && length != 6))", "             (s->color_type == PNG_COLOR_TYPE_RGB && length != 6) ||", "             s->bit_depth == 1)", "              return AVERROR_INVALIDDATA;", "          for (i = 0; i < length / 2; i++) {", "             v = av_mod_uintp2(bytestream2_get_be16(&s->gb), s->bit_depth);", "             if (s->bit_depth > 8)", "                 AV_WB16(&s->transparent_color_be[2 * i], v);", "             else", "                 s->transparent_color_be[i] = v;", "         }", "     } else {", "         return AVERROR_INVALIDDATA;", "     }", "     bytestream2_skip(&s->gb, 4);  ", "     s->has_trns = 1;", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  int jas_stream_gobble(jas_stream_t *stream, int n)", "  {", "  \tint m;", " \tif (n < 0) {", " \t\tjas_deprecated(\"negative count for jas_stream_gobble\");", " \t}", "  \tm = n;", "  \tfor (m = n; m > 0; --m) {", "  \t\tif (jas_stream_getc(stream) == EOF) {", " \t\t\treturn n - m;", " \t\t}", " \t}", " \treturn n;", " }"], "ner_tags": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" bqarr_in(PG_FUNCTION_ARGS)", " {", " \tchar\t   *buf = (char *) PG_GETARG_POINTER(0);", " \tWORKSTATE\tstate;", " \tint32\t\ti;", " \tQUERYTYPE  *query;", " \tint32\t\tcommonlen;", " \tITEM\t   *ptr;", " \tNODE\t   *tmp;", " \tint32\t\tpos = 0;", " #ifdef BS_DEBUG", " \tStringInfoData pbuf;", " #endif", " \tstate.buf = buf;", " \tstate.state = WAITOPERAND;", " \tstate.count = 0;", " \tstate.num = 0;", " \tstate.str = NULL;", " \tmakepol(&state);", " \tif (!state.num)", " \t\tereport(ERROR,", "  \t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),", "  \t\t\t\t errmsg(\"empty query\")));", " \tif (state.num > QUERYTYPEMAXITEMS)", " \t\tereport(ERROR,", " \t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),", " \t\terrmsg(\"number of query items (%d) exceeds the maximum allowed (%d)\",", " \t\t\t   state.num, (int) QUERYTYPEMAXITEMS)));", "  \tcommonlen = COMPUTESIZE(state.num);", "  \tquery = (QUERYTYPE *) palloc(commonlen);", "  \tSET_VARSIZE(query, commonlen);", "  \tquery->size = state.num;", " \tptr = GETQUERY(query);", " \tfor (i = state.num - 1; i >= 0; i--)", " \t{", " \t\tptr[i].type = state.str->type;", " \t\tptr[i].val = state.str->val;", " \t\ttmp = state.str->next;", " \t\tpfree(state.str);", " \t\tstate.str = tmp;", " \t}", " \tpos = query->size - 1;", " \tfindoprnd(ptr, &pos);", " #ifdef BS_DEBUG", " \tinitStringInfo(&pbuf);", " \tfor (i = 0; i < query->size; i++)", " \t{", " \t\tif (ptr[i].type == OPR)", " \t\t\tappendStringInfo(&pbuf, \"%c(%d) \", ptr[i].val, ptr[i].left);", " \t\telse", " \t\t\tappendStringInfo(&pbuf, \"%d \", ptr[i].val);", " \t}", " \telog(DEBUG3, \"POR: %s\", pbuf.data);", " \tpfree(pbuf.data);", " #endif", " \tPG_RETURN_POINTER(query);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" isoent_gen_joliet_identifier(struct archive_write *a, struct isoent *isoent,", "     struct idr *idr)", " {", " \tstruct iso9660 *iso9660;", " \tstruct isoent *np;", "  \tunsigned char *p;", "  \tsize_t l;", "  \tint r;", "\tint ffmax, parent_len;", " \tsize_t ffmax, parent_len;", "  \tstatic const struct archive_rb_tree_ops rb_ops = {", "  \t\tisoent_cmp_node_joliet, isoent_cmp_key_joliet", "  \t};", " \tif (isoent->children.cnt == 0)", " \t\treturn (0);", " \tiso9660 = a->format_data;", " \tif (iso9660->opt.joliet == OPT_JOLIET_LONGNAME)", " \t\tffmax = 206;", "  \telse", "  \t\tffmax = 128;", "\tr = idr_start(a, idr, isoent->children.cnt, ffmax, 6, 2, &rb_ops);", " \tr = idr_start(a, idr, isoent->children.cnt, (int)ffmax, 6, 2, &rb_ops);", "  \tif (r < 0)", "  \t\treturn (r);", " \tparent_len = 1;", " \tfor (np = isoent; np->parent != np; np = np->parent)", " \t\tparent_len += np->mb_len + 1;", " \tfor (np = isoent->children.first; np != NULL; np = np->chnext) {", " \t\tunsigned char *dot;", "  \t\tint ext_off, noff, weight;", "  \t\tsize_t lt;", "\t\tif ((int)(l = np->file->basename_utf16.length) > ffmax)", " \t\tif ((l = np->file->basename_utf16.length) > ffmax)", "  \t\t\tl = ffmax;", "  \t\tp = malloc((l+1)*2);", " \t\tif (p == NULL) {", " \t\t\tarchive_set_error(&a->archive, ENOMEM,", " \t\t\t    \"Can't allocate memory\");", " \t\t\treturn (ARCHIVE_FATAL);", " \t\t}", " \t\tmemcpy(p, np->file->basename_utf16.s, l);", " \t\tp[l] = 0;", " \t\tp[l+1] = 0;", " \t\tnp->identifier = (char *)p;", " \t\tlt = l;", " \t\tdot = p + l;", " \t\tweight = 0;", " \t\twhile (lt > 0) {", " \t\t\tif (!joliet_allowed_char(p[0], p[1]))", " \t\t\t\tarchive_be16enc(p, 0x005F);  ", " \t\t\telse if (p[0] == 0 && p[1] == 0x2E)  ", " \t\t\t\tdot = p;", " \t\t\tp += 2;", " \t\t\tlt -= 2;", " \t\t}", " \t\text_off = (int)(dot - (unsigned char *)np->identifier);", " \t\tnp->ext_off = ext_off;", " \t\tnp->ext_len = (int)l - ext_off;", " \t\tnp->id_len = (int)l;", "\t\tif ((int)np->file->basename_utf16.length > ffmax) {", " \t\tif (np->file->basename_utf16.length > ffmax) {", "  \t\t\tif (archive_strncpy_l(&iso9660->mbs,", "  \t\t\t    (const char *)np->identifier, l,", "  \t\t\t\tiso9660->sconv_from_utf16be) != 0 &&", " \t\t\t    errno == ENOMEM) {", " \t\t\t\tarchive_set_error(&a->archive, errno,", " \t\t\t\t    \"No memory\");", " \t\t\t\treturn (ARCHIVE_FATAL);", " \t\t\t}", " \t\t\tnp->mb_len = (int)iso9660->mbs.length;", " \t\t\tif (np->mb_len != (int)np->file->basename.length)", " \t\t\t\tweight = np->mb_len;", " \t\t} else", " \t\t\tnp->mb_len = (int)np->file->basename.length;", "\t\tif (parent_len + np->mb_len > 240) {", " \t\tif (parent_len > 240", " \t\t    || np->mb_len > 240", " \t\t    || parent_len + np->mb_len > 240) {", "  \t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,", "  \t\t\t    \"The regulation of Joliet extensions;\"", "  \t\t\t    \" A length of a full-pathname of `%s' is \"", " \t\t\t    \"longer than 240 bytes, (p=%d, b=%d)\",", " \t\t\t    archive_entry_pathname(np->file->entry),", " \t\t\t    (int)parent_len, (int)np->mb_len);", " \t\t\treturn (ARCHIVE_FATAL);", " \t\t}", "\t\tif ((int)l == ffmax)", " \t\tif (l == ffmax)", "  \t\t\tnoff = ext_off - 6;", "\t\telse if ((int)l == ffmax-2)", " \t\telse if (l == ffmax-2)", "  \t\t\tnoff = ext_off - 4;", "\t\telse if ((int)l == ffmax-4)", " \t\telse if (l == ffmax-4)", "  \t\t\tnoff = ext_off - 2;", "  \t\telse", "  \t\t\tnoff = ext_off;", " \t\tidr_register(idr, np, weight, noff);", " \t}", " \tidr_resolve(idr, idr_set_num_beutf16);", " \treturn (ARCHIVE_OK);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" NO_INLINE JsVar *__jspeAssignmentExpression(JsVar *lhs) {", "   if (lex->tk=='=' || lex->tk==LEX_PLUSEQUAL || lex->tk==LEX_MINUSEQUAL ||", "       lex->tk==LEX_MULEQUAL || lex->tk==LEX_DIVEQUAL || lex->tk==LEX_MODEQUAL ||", "       lex->tk==LEX_ANDEQUAL || lex->tk==LEX_OREQUAL ||", "       lex->tk==LEX_XOREQUAL || lex->tk==LEX_RSHIFTEQUAL ||", "       lex->tk==LEX_LSHIFTEQUAL || lex->tk==LEX_RSHIFTUNSIGNEDEQUAL) {", "     JsVar *rhs;", "     int op = lex->tk;", "     JSP_ASSERT_MATCH(op);", "     rhs = jspeAssignmentExpression();", "     rhs = jsvSkipNameAndUnLock(rhs);  ", "      if (JSP_SHOULD_EXECUTE && lhs) {", "        if (op=='=') {", "        if (!jsvGetRefs(lhs) && jsvIsName(lhs)) {", "          if (!jsvIsArrayBufferName(lhs) && !jsvIsNewChild(lhs))", "            jsvAddName(execInfo.root, lhs);", "        }", "        jspReplaceWith(lhs, rhs);", "         jspReplaceWithOrAddToRoot(lhs, rhs);", "        } else {", "          if (op==LEX_PLUSEQUAL) op='+';", "          else if (op==LEX_MINUSEQUAL) op='-';", "         else if (op==LEX_MULEQUAL) op='*';", "         else if (op==LEX_DIVEQUAL) op='/';", "         else if (op==LEX_MODEQUAL) op='%';", "         else if (op==LEX_ANDEQUAL) op='&';", "         else if (op==LEX_OREQUAL) op='|';", "         else if (op==LEX_XOREQUAL) op='^';", "         else if (op==LEX_RSHIFTEQUAL) op=LEX_RSHIFT;", "         else if (op==LEX_LSHIFTEQUAL) op=LEX_LSHIFT;", "         else if (op==LEX_RSHIFTUNSIGNEDEQUAL) op=LEX_RSHIFTUNSIGNED;", "         if (op=='+' && jsvIsName(lhs)) {", "           JsVar *currentValue = jsvSkipName(lhs);", "           if (jsvIsString(currentValue) && !jsvIsFlatString(currentValue) && jsvGetRefs(currentValue)==1 && rhs!=currentValue) {", "             JsVar *str = jsvAsString(rhs, false);", "             jsvAppendStringVarComplete(currentValue, str);", "             jsvUnLock(str);", "             op = 0;", "           }", "           jsvUnLock(currentValue);", "         }", "         if (op) {", "           JsVar *res = jsvMathsOpSkipNames(lhs,rhs,op);", "           jspReplaceWith(lhs, res);", "           jsvUnLock(res);", "         }", "       }", "     }", "     jsvUnLock(rhs);", "   }", "   return lhs;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" sc_parse_ef_gdo_content(const unsigned char *gdo, size_t gdo_len,", " \t\tunsigned char *iccsn, size_t *iccsn_len,", " \t\tunsigned char *chn, size_t *chn_len)", " {", " \tint r = SC_SUCCESS, iccsn_found = 0, chn_found = 0;", " \tconst unsigned char *p = gdo;", " \tsize_t left = gdo_len;", " \twhile (left >= 2) {", " \t\tunsigned int cla, tag;", " \t\tsize_t tag_len;", " \t\tr = sc_asn1_read_tag(&p, left, &cla, &tag, &tag_len);", " \t\tif (r != SC_SUCCESS) {", " \t\t\tif (r == SC_ERROR_ASN1_END_OF_CONTENTS) {", " \t\t\t\tr = SC_SUCCESS;", " \t\t\t}", " \t\t\tbreak;", " \t\t}", " \t\tif (p == NULL) {", " \t\t\tbreak;", " \t\t}", " \t\tif (cla == SC_ASN1_TAG_APPLICATION) {", " \t\t\tswitch (tag) {", " \t\t\t\tcase 0x1A:", " \t\t\t\t\ticcsn_found = 1;", " \t\t\t\t\tif (iccsn && iccsn_len) {", " \t\t\t\t\t\tmemcpy(iccsn, p, MIN(tag_len, *iccsn_len));", " \t\t\t\t\t\t*iccsn_len = MIN(tag_len, *iccsn_len);", " \t\t\t\t\t}", " \t\t\t\t\tbreak;", " \t\t\t\tcase 0x1F20:", " \t\t\t\t\tchn_found = 1;", " \t\t\t\t\tif (chn && chn_len) {", " \t\t\t\t\t\tmemcpy(chn, p, MIN(tag_len, *chn_len));", " \t\t\t\t\t\t*chn_len = MIN(tag_len, *chn_len);", " \t\t\t\t\t}", " \t\t\t\t\tbreak;", " \t\t\t}", "  \t\t}", "  \t\tp += tag_len;", "\t\tleft -= (p - gdo);", " \t\tleft = gdo_len - (p - gdo);", "  \t}", "  \tif (!iccsn_found && iccsn_len)", " \t\t*iccsn_len = 0;", " \tif (!chn_found && chn_len)", " \t\t*chn_len = 0;", " \treturn r;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  dwarf_elf_object_access_load_section(void* obj_in,", "      Dwarf_Half section_index,", "     Dwarf_Small** section_data,", "     int* error)", " {", "     dwarf_elf_object_access_internals_t*obj =", "         (dwarf_elf_object_access_internals_t*)obj_in;", "     if (section_index == 0) {", "         return DW_DLV_NO_ENTRY;", "     }", "     {", "         Elf_Scn *scn = 0;", "         Elf_Data *data = 0;", "         scn = elf_getscn(obj->elf, section_index);", "         if (scn == NULL) {", "             *error = DW_DLE_MDE;", "             return DW_DLV_ERROR;", "         }", "         data = elf_getdata(scn, NULL);", "         if (data == NULL) {", "              *error = DW_DLE_MDE;", "              return DW_DLV_ERROR;", "          }", "         if (!data->d_buf) {", "             *error = DW_DLE_MDE;", "             return DW_DLV_ERROR;", "         }", "          *section_data = data->d_buf;", "      }", "      return DW_DLV_OK;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": [" int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)", " {", "     MpegEncContext *s = &ctx->m;", "     unsigned startcode, v;", "     int ret;", "     int vol = 0;", "      align_get_bits(gb);", "     if (!s->studio_profile && s->avctx->bits_per_raw_sample != 8)", "         s->avctx->bits_per_raw_sample = 0;", "      if (s->codec_tag == AV_RL32(\"WV1F\") && show_bits(gb, 24) == 0x575630) {", "          skip_bits(gb, 24);", "          if (get_bits(gb, 8) == 0xF0)", "             goto end;", "     }", "     startcode = 0xff;", "     for (;;) {", "         if (get_bits_count(gb) >= gb->size_in_bits) {", "             if (gb->size_in_bits == 8 &&", "                 (ctx->divx_version >= 0 || ctx->xvid_build >= 0) || s->codec_tag == AV_RL32(\"QMP4\")) {", "                 av_log(s->avctx, AV_LOG_VERBOSE, \"frame skip %d\\n\", gb->size_in_bits);", "                 return FRAME_SKIPPED;   ", "             } else", "                 return AVERROR_INVALIDDATA;   ", "         }", "         v = get_bits(gb, 8);", "         startcode = ((startcode << 8) | v) & 0xffffffff;", "         if ((startcode & 0xFFFFFF00) != 0x100)", "             continue;   ", "         if (s->avctx->debug & FF_DEBUG_STARTCODE) {", "             av_log(s->avctx, AV_LOG_DEBUG, \"startcode: %3X \", startcode);", "             if (startcode <= 0x11F)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Video Object Start\");", "             else if (startcode <= 0x12F)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Video Object Layer Start\");", "             else if (startcode <= 0x13F)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Reserved\");", "             else if (startcode <= 0x15F)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"FGS bp start\");", "             else if (startcode <= 0x1AF)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Reserved\");", "             else if (startcode == 0x1B0)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Seq Start\");", "             else if (startcode == 0x1B1)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Seq End\");", "             else if (startcode == 0x1B2)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"User Data\");", "             else if (startcode == 0x1B3)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Group of VOP start\");", "             else if (startcode == 0x1B4)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Video Session Error\");", "             else if (startcode == 0x1B5)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Start\");", "             else if (startcode == 0x1B6)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Video Object Plane start\");", "             else if (startcode == 0x1B7)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"slice start\");", "             else if (startcode == 0x1B8)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"extension start\");", "             else if (startcode == 0x1B9)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"fgs start\");", "             else if (startcode == 0x1BA)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"FBA Object start\");", "             else if (startcode == 0x1BB)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"FBA Object Plane start\");", "             else if (startcode == 0x1BC)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Mesh Object start\");", "             else if (startcode == 0x1BD)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Mesh Object Plane start\");", "             else if (startcode == 0x1BE)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Still Texture Object start\");", "             else if (startcode == 0x1BF)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Texture Spatial Layer start\");", "             else if (startcode == 0x1C0)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Texture SNR Layer start\");", "             else if (startcode == 0x1C1)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Texture Tile start\");", "             else if (startcode == 0x1C2)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"Texture Shape Layer start\");", "             else if (startcode == 0x1C3)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"stuffing start\");", "             else if (startcode <= 0x1C5)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"reserved\");", "             else if (startcode <= 0x1FF)", "                 av_log(s->avctx, AV_LOG_DEBUG, \"System start\");", "             av_log(s->avctx, AV_LOG_DEBUG, \" at %d\\n\", get_bits_count(gb));", "         }", "         if (startcode >= 0x120 && startcode <= 0x12F) {", "             if (vol) {", "                 av_log(s->avctx, AV_LOG_WARNING, \"Ignoring multiple VOL headers\\n\");", "                 continue;", "             }", "             vol++;", "             if ((ret = decode_vol_header(ctx, gb)) < 0)", "                 return ret;", "         } else if (startcode == USER_DATA_STARTCODE) {", "             decode_user_data(ctx, gb);", "         } else if (startcode == GOP_STARTCODE) {", "             mpeg4_decode_gop_header(s, gb);", "         } else if (startcode == VOS_STARTCODE) {", "             mpeg4_decode_profile_level(s, gb);", "             if (s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&", "                 (s->avctx->level > 0 && s->avctx->level < 9)) {", "                 s->studio_profile = 1;", "                 next_start_code_studio(gb);", "                 extension_and_user_data(s, gb, 0);", "             }", "         } else if (startcode == VISUAL_OBJ_STARTCODE) {", "             if (s->studio_profile) {", "                 if ((ret = decode_studiovisualobject(ctx, gb)) < 0)", "                     return ret;", "             } else", "                 mpeg4_decode_visual_object(s, gb);", "         } else if (startcode == VOP_STARTCODE) {", "             break;", "         }", "         align_get_bits(gb);", "         startcode = 0xff;", "     }", " end:", "     if (s->avctx->flags & AV_CODEC_FLAG_LOW_DELAY)", "         s->low_delay = 1;", "     s->avctx->has_b_frames = !s->low_delay;", "     if (s->studio_profile) {", "         if (!s->avctx->bits_per_raw_sample) {", "             av_log(s->avctx, AV_LOG_ERROR, \"Missing VOL header\\n\");", "             return AVERROR_INVALIDDATA;", "         }", "         return decode_studio_vop_header(ctx, gb);", "     } else", "         return decode_vop_header(ctx, gb);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  jpc_streamlist_t *jpc_ppmstabtostreams(jpc_ppxstab_t *tab)", "  {", "  \tjpc_streamlist_t *streams;", "\tuchar *dataptr;", " \tjas_uchar *dataptr;", "  \tuint_fast32_t datacnt;", "  \tuint_fast32_t tpcnt;", "  \tjpc_ppxstabent_t *ent;", " \tint entno;", " \tjas_stream_t *stream;", " \tint n;", " \tif (!(streams = jpc_streamlist_create())) {", " \t\tgoto error;", " \t}", " \tif (!tab->numents) {", " \t\treturn streams;", " \t}", " \tentno = 0;", " \tent = tab->ents[entno];", " \tdataptr = ent->data;", " \tdatacnt = ent->len;", " \tfor (;;) {", " \t\tif (datacnt < 4) {", " \t\t\tgoto error;", " \t\t}", " \t\tif (!(stream = jas_stream_memopen(0, 0))) {", " \t\t\tgoto error;", " \t\t}", " \t\tif (jpc_streamlist_insert(streams, jpc_streamlist_numstreams(streams),", " \t\t  stream)) {", " \t\t\tgoto error;", " \t\t}", " \t\ttpcnt = (dataptr[0] << 24) | (dataptr[1] << 16) | (dataptr[2] << 8)", " \t\t  | dataptr[3];", " \t\tdatacnt -= 4;", " \t\tdataptr += 4;", " \t\twhile (tpcnt) {", " \t\t\tif (!datacnt) {", " \t\t\t\tif (++entno >= tab->numents) {", " \t\t\t\t\tgoto error;", " \t\t\t\t}", " \t\t\t\tent = tab->ents[entno];", " \t\t\t\tdataptr = ent->data;", " \t\t\t\tdatacnt = ent->len;", " \t\t\t}", " \t\t\tn = JAS_MIN(tpcnt, datacnt);", " \t\t\tif (jas_stream_write(stream, dataptr, n) != n) {", " \t\t\t\tgoto error;", " \t\t\t}", " \t\t\ttpcnt -= n;", " \t\t\tdataptr += n;", " \t\t\tdatacnt -= n;", " \t\t}", " \t\tjas_stream_rewind(stream);", " \t\tif (!datacnt) {", " \t\t\tif (++entno >= tab->numents) {", " \t\t\t\tbreak;", " \t\t\t}", " \t\t\tent = tab->ents[entno];", " \t\t\tdataptr = ent->data;", " \t\t\tdatacnt = ent->len;", " \t\t}", " \t}", " \treturn streams;", " error:", " \tif (streams) {", " \t\tjpc_streamlist_destroy(streams);", " \t}", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" process_demand_active(STREAM s)", "  {", "  \tuint8 type;", "  \tuint16 len_src_descriptor, len_combined_caps;", " \tstruct stream packet = *s;", "  \trd_create_ui();", "  \tin_uint32_le(s, g_rdp_shareid);", "  \tin_uint16_le(s, len_src_descriptor);", "  \tin_uint16_le(s, len_combined_caps);", " \tif (!s_check_rem(s, len_src_descriptor))", " \t{", " \t\trdp_protocol_error(\"rdp_demand_active(), consume of source descriptor from stream would overrun\", &packet);", " \t}", "  \tin_uint8s(s, len_src_descriptor);", "  \tlogger(Protocol, Debug, \"process_demand_active(), shareid=0x%x\", g_rdp_shareid);", " \trdp_process_server_caps(s, len_combined_caps);", " \trdp_send_confirm_active();", " \trdp_send_synchronise();", " \trdp_send_control(RDP_CTL_COOPERATE);", " \trdp_send_control(RDP_CTL_REQUEST_CONTROL);", " \trdp_recv(&type);\t ", " \trdp_recv(&type);\t ", " \trdp_recv(&type);\t ", " \trdp_send_input(0, RDP_INPUT_SYNCHRONIZE, 0,", " \t\t       g_numlock_sync ? ui_get_numlock_state(read_keyboard_state()) : 0, 0);", " \tif (g_rdp_version >= RDP_V5)", " \t{", " \t\trdp_enum_bmpcache2();", " \t\trdp_send_fonts(3);", " \t}", " \telse", " \t{", " \t\trdp_send_fonts(1);", " \t\trdp_send_fonts(2);", " \t}", " \trdp_recv(&type);\t ", " \treset_order_state();", " }"], "ner_tags": [0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" cliprdr_process(STREAM s)", " {", "  \tuint16 type, status;", "  \tuint32 length, format;", "  \tuint8 *data;", " \tstruct stream packet = *s;", "  \tin_uint16_le(s, type);", "  \tin_uint16_le(s, status);", " \tin_uint32_le(s, length);", " \tdata = s->p;", "  \tlogger(Clipboard, Debug, \"cliprdr_process(), type=%d, status=%d, length=%d\", type, status,", "  \t       length);", " \tif (!s_check_rem(s, length))", " \t{", " \t\trdp_protocol_error(\"cliprdr_process(), consume of packet from stream would overrun\", &packet);", " \t}", "  \tif (status == CLIPRDR_ERROR)", "  \t{", "  \t\tswitch (type)", " \t\t{", " \t\t\tcase CLIPRDR_FORMAT_ACK:", " \t\t\t\tcliprdr_send_native_format_announce(last_formats,", " \t\t\t\t\t\t\t\t    last_formats_length);", " \t\t\t\tbreak;", " \t\t\tcase CLIPRDR_DATA_RESPONSE:", " \t\t\t\tui_clip_request_failed();", " \t\t\t\tbreak;", " \t\t\tdefault:", " \t\t\t\tlogger(Clipboard, Warning,", " \t\t\t\t       \"cliprdr_process(), unhandled error (type=%d)\", type);", " \t\t}", " \t\treturn;", " \t}", " \tswitch (type)", " \t{", " \t\tcase CLIPRDR_CONNECT:", " \t\t\tui_clip_sync();", " \t\t\tbreak;", " \t\tcase CLIPRDR_FORMAT_ANNOUNCE:", " \t\t\tui_clip_format_announce(data, length);", " \t\t\tcliprdr_send_packet(CLIPRDR_FORMAT_ACK, CLIPRDR_RESPONSE, NULL, 0);", " \t\t\treturn;", " \t\tcase CLIPRDR_FORMAT_ACK:", " \t\t\tbreak;", " \t\tcase CLIPRDR_DATA_REQUEST:", " \t\t\tin_uint32_le(s, format);", " \t\t\tui_clip_request_data(format);", " \t\t\tbreak;", " \t\tcase CLIPRDR_DATA_RESPONSE:", " \t\t\tui_clip_handle_data(data, length);", " \t\t\tbreak;", " \t\tcase 7:\t ", " \t\t\tbreak;", " \t\tdefault:", " \t\t\tlogger(Clipboard, Warning, \"cliprdr_process(), unhandled packet type %d\",", " \t\t\t       type);", " \t}", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void jas_matrix_bindsub(jas_matrix_t *mat0, jas_matrix_t *mat1, int r0,", "  int c0, int r1, int c1)", " void jas_matrix_bindsub(jas_matrix_t *mat0, jas_matrix_t *mat1,", "   jas_matind_t r0, jas_matind_t c0, jas_matind_t r1, jas_matind_t c1)", "  {", "\tint i;", " \tjas_matind_t i;", "  \tif (mat0->data_) {", "  \t\tif (!(mat0->flags_ & JAS_MATRIX_REF)) {", " \t\t\tjas_free(mat0->data_);", " \t\t}", " \t\tmat0->data_ = 0;", " \t\tmat0->datasize_ = 0;", " \t}", " \tif (mat0->rows_) {", " \t\tjas_free(mat0->rows_);", " \t\tmat0->rows_ = 0;", " \t}", " \tmat0->flags_ |= JAS_MATRIX_REF;", " \tmat0->numrows_ = r1 - r0 + 1;", " \tmat0->numcols_ = c1 - c0 + 1;", " \tmat0->maxrows_ = mat0->numrows_;", " \tif (!(mat0->rows_ = jas_alloc2(mat0->maxrows_, sizeof(jas_seqent_t *)))) {", " \t\tabort();", " \t}", " \tfor (i = 0; i < mat0->numrows_; ++i) {", " \t\tmat0->rows_[i] = mat1->rows_[r0 + i] + c0;", " \t}", " \tmat0->xstart_ = mat1->xstart_ + c0;", " \tmat0->ystart_ = mat1->ystart_ + r0;", " \tmat0->xend_ = mat0->xstart_ + mat0->numcols_;", " \tmat0->yend_ = mat0->ystart_ + mat0->numrows_;", " }"], "ner_tags": [0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  _archive_write_data(struct archive *_a, const void *buff, size_t s)", "  {", "  \tstruct archive_write *a = (struct archive_write *)_a;", " \tconst size_t max_write = INT_MAX;", "  \tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,", "  \t    ARCHIVE_STATE_DATA, \"archive_write_data\");", " \tif (s > max_write)", " \t\ts = max_write;", "  \tarchive_clear_error(&a->archive);", "  \treturn ((a->format_write_data)(a, buff, s));", "  }"], "ner_tags": [0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0]}
{"tokens": [" _XcursorThemeInherits (const char *full)", " {", "     char    line[8192];", "     char    *result = NULL;", "     FILE    *f;", "     if (!full)", "         return NULL;", "     f = fopen (full, \"r\");", "     if (f)", "     {", " \twhile (fgets (line, sizeof (line), f))", " \t{", " \t    if (!strncmp (line, \"Inherits\", 8))", " \t    {", " \t\tchar    *l = line + 8;", " \t\tchar    *r;", " \t\twhile (*l == ' ') l++;", "  \t\tif (*l != '=') continue;", "  \t\tl++;", "  \t\twhile (*l == ' ') l++;", "\t\tresult = malloc (strlen (l));", " \t\tresult = malloc (strlen (l) + 1);", "  \t\tif (result)", "  \t\t{", "  \t\t    r = result;", " \t\t    while (*l)", " \t\t    {", " \t\t\twhile (XcursorSep(*l) || XcursorWhite (*l)) l++;", " \t\t\tif (!*l)", " \t\t\t    break;", " \t\t\tif (r != result)", " \t\t\t    *r++ = ':';", " \t\t\twhile (*l && !XcursorWhite(*l) &&", " \t\t\t       !XcursorSep(*l))", " \t\t\t    *r++ = *l++;", " \t\t    }", " \t\t    *r++ = '\\0';", " \t\t}", " \t\tbreak;", " \t    }", " \t}", " \tfclose (f);", "     }", "     return result;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" local void process(char *path)", " {", "     int method = -1;                 ", "     size_t len;                      ", "     struct stat st;                  ", "     static char *sufs[] = {\".z\", \"-z\", \"_z\", \".Z\", \".gz\", \"-gz\", \".zz\", \"-zz\",", "                            \".zip\", \".ZIP\", \".tgz\", NULL};", "     if (path == NULL) {", "         strcpy(g.inf, \"<stdin>\");", "         g.ind = 0;", "         g.name = NULL;", "         g.mtime = g.headis & 2 ?", "                   (fstat(g.ind, &st) ? time(NULL) : st.st_mtime) : 0;", "         len = 0;", "     }", "     else {", "         if (path != g.inf) {", "             strncpy(g.inf, path, sizeof(g.inf));", "             if (g.inf[sizeof(g.inf) - 1])", "                 bail(\"name too long: \", path);", "         }", "         len = strlen(g.inf);", "         if (lstat(g.inf, &st)) {", "             if (errno == ENOENT && (g.list || g.decode)) {", "                 char **try = sufs;", "                 do {", "                     if (*try == NULL || len + strlen(*try) >= sizeof(g.inf))", "                         break;", "                     strcpy(g.inf + len, *try++);", "                     errno = 0;", "                 } while (lstat(g.inf, &st) && errno == ENOENT);", "             }", " #ifdef EOVERFLOW", "             if (errno == EOVERFLOW || errno == EFBIG)", "                 bail(g.inf,", "                     \" too large -- not compiled with large file support\");", " #endif", "             if (errno) {", "                 g.inf[len] = 0;", "                 complain(\"%s does not exist -- skipping\", g.inf);", "                 return;", "             }", "             len = strlen(g.inf);", "         }", "         if ((st.st_mode & S_IFMT) != S_IFREG &&", "             (st.st_mode & S_IFMT) != S_IFLNK &&", "             (st.st_mode & S_IFMT) != S_IFDIR) {", "             complain(\"%s is a special file or device -- skipping\", g.inf);", "             return;", "         }", "         if ((st.st_mode & S_IFMT) == S_IFLNK && !g.force && !g.pipeout) {", "             complain(\"%s is a symbolic link -- skipping\", g.inf);", "             return;", "         }", "         if ((st.st_mode & S_IFMT) == S_IFDIR && !g.recurse) {", "             complain(\"%s is a directory -- skipping\", g.inf);", "             return;", "         }", "         if ((st.st_mode & S_IFMT) == S_IFDIR) {", "             char *roll, *item, *cut, *base, *bigger;", "             size_t len, hold;", "             DIR *here;", "             struct dirent *next;", "             here = opendir(g.inf);", "             if (here == NULL)", "                 return;", "             hold = 512;", "             roll = MALLOC(hold);", "             if (roll == NULL)", "                 bail(\"not enough memory\", \"\");", "             *roll = 0;", "             item = roll;", "             while ((next = readdir(here)) != NULL) {", "                 if (next->d_name[0] == 0 ||", "                     (next->d_name[0] == '.' && (next->d_name[1] == 0 ||", "                      (next->d_name[1] == '.' && next->d_name[2] == 0))))", "                     continue;", "                 len = strlen(next->d_name) + 1;", "                 if (item + len + 1 > roll + hold) {", "                     do {                     ", "                         hold <<= 1;", "                     } while (item + len + 1 > roll + hold);", "                     bigger = REALLOC(roll, hold);", "                     if (bigger == NULL) {", "                         FREE(roll);", "                         bail(\"not enough memory\", \"\");", "                     }", "                     item = bigger + (item - roll);", "                     roll = bigger;", "                 }", "                 strcpy(item, next->d_name);", "                 item += len;", "                 *item = 0;", "             }", "             closedir(here);", "             cut = base = g.inf + strlen(g.inf);", "             if (base > g.inf && base[-1] != (unsigned char)'/') {", "                 if ((size_t)(base - g.inf) >= sizeof(g.inf))", "                     bail(\"path too long\", g.inf);", "                 *base++ = '/';", "             }", "             item = roll;", "             while (*item) {", "                 strncpy(base, item, sizeof(g.inf) - (base - g.inf));", "                 if (g.inf[sizeof(g.inf) - 1]) {", "                     strcpy(g.inf + (sizeof(g.inf) - 4), \"...\");", "                     bail(\"path too long: \", g.inf);", "                 }", "                 process(g.inf);", "                 item += strlen(item) + 1;", "             }", "             *cut = 0;", "             FREE(roll);", "             return;", "         }", "         if (!(g.force || g.list || g.decode) && len >= strlen(g.sufx) &&", "                 strcmp(g.inf + len - strlen(g.sufx), g.sufx) == 0) {", "             complain(\"%s ends with %s -- skipping\", g.inf, g.sufx);", "             return;", "         }", "         if (g.decode == 1 && !g.pipeout && !g.list) {", "             int suf = compressed_suffix(g.inf);", "             if (suf == 0) {", "                 complain(\"%s does not have compressed suffix -- skipping\",", "                          g.inf);", "                 return;", "             }", "             len -= suf;", "         }", "         g.ind = open(g.inf, O_RDONLY, 0);", "         if (g.ind < 0)", "             bail(\"read error on \", g.inf);", "         g.name = g.headis & 1 ? justname(g.inf) : NULL;", "         g.mtime = g.headis & 2 ? st.st_mtime : 0;", "     }", "     SET_BINARY_MODE(g.ind);", "     g.hname = NULL;", "     if (g.decode) {", "         in_init();", "         method = get_header(1);", "         if (method != 8 && method != 257 &&", "                 !(method == -2 && g.force && g.pipeout && g.decode != 2 &&", "                   !g.list)) {", "             RELEASE(g.hname);", "             if (g.ind != 0)", "                 close(g.ind);", "             if (method != -1)", "                 complain(method < 0 ? \"%s is not compressed -- skipping\" :", "                          \"%s has unknown compression method -- skipping\",", "                          g.inf);", "             return;", "         }", "         if (g.decode == 2) {", "             if (method == 8)", "                 infchk();", "             else {", "                 unlzw();", "                 if (g.list) {", "                     g.in_tot -= 3;", "                     show_info(method, 0, g.out_tot, 0);", "                 }", "             }", "             RELEASE(g.hname);", "             if (g.ind != 0)", "                 close(g.ind);", "             return;", "         }", "     }", "     if (g.list) {", "         list_info();", "         RELEASE(g.hname);", "         if (g.ind != 0)", "             close(g.ind);", "         return;", "     }", "     if (path == NULL || g.pipeout) {", "         g.outf = MALLOC(strlen(\"<stdout>\") + 1);", "         if (g.outf == NULL)", "             bail(\"not enough memory\", \"\");", "         strcpy(g.outf, \"<stdout>\");", "         g.outd = 1;", "         if (!g.decode && !g.force && isatty(g.outd))", "             bail(\"trying to write compressed data to a terminal\",", "                   \" (use -f to force)\");", "      }", "      else {", "        char *to, *repl;", "         char *to = g.inf, *sufx = \"\";", "         size_t pre = 0;", "        to = g.inf;", "        if (g.decode && (g.headis & 1) != 0 && g.hname != NULL) {", "            to = g.hname;", "            len = strlen(g.hname);", "         if (g.decode) {", "             if ((g.headis & 1) != 0 && g.hname != NULL) {", "                 pre = justname(g.inf) - g.inf;", "                 to = justname(g.hname);", "                 len = strlen(to);", "             }", "             else if (strcmp(to + len, \".tgz\") == 0)", "                 sufx = \".tar\";", "          }", "        repl = g.decode && strcmp(to + len, \".tgz\") ? \"\" : \".tar\";", "         else", "             sufx = g.sufx;", "        g.outf = MALLOC(len + (g.decode ? strlen(repl) : strlen(g.sufx)) + 1);", "         g.outf = MALLOC(pre + len + strlen(sufx) + 1);", "          if (g.outf == NULL)", "              bail(\"not enough memory\", \"\");", "        memcpy(g.outf, to, len);", "        strcpy(g.outf + len, g.decode ? repl : g.sufx);", "         memcpy(g.outf, g.inf, pre);", "         memcpy(g.outf + pre, to, len);", "         strcpy(g.outf + pre + len, sufx);", "          g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |", "                             (g.force ? 0 : O_EXCL), 0600);", "                               (g.force ? 0 : O_EXCL), 0600);", "          if (g.outd < 0 && errno == EEXIST && isatty(0) && g.verbosity) {", "             int ch, reply;", "             fprintf(stderr, \"%s exists -- overwrite (y/n)? \", g.outf);", "             fflush(stderr);", "             reply = -1;", "             do {", "                 ch = getchar();", "                 if (reply < 0 && ch != ' ' && ch != '\\t')", "                     reply = ch == 'y' || ch == 'Y' ? 1 : 0;", "             } while (ch != EOF && ch != '\\n' && ch != '\\r');", "             if (reply == 1)", "                 g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY,", "                               0600);", "         }", "         if (g.outd < 0 && errno == EEXIST) {", "             complain(\"%s exists -- skipping\", g.outf);", "             RELEASE(g.outf);", "             RELEASE(g.hname);", "             if (g.ind != 0)", "                 close(g.ind);", "             return;", "         }", "         if (g.outd < 0)", "             bail(\"write error on \", g.outf);", "     }", "     SET_BINARY_MODE(g.outd);", "     RELEASE(g.hname);", "     if (g.verbosity > 1)", "         fprintf(stderr, \"%s to %s \", g.inf, g.outf);", "     if (g.decode) {", "         if (method == 8)", "             infchk();", "         else if (method == 257)", "             unlzw();", "         else", "             cat();", "     }", " #ifndef NOTHREAD", "     else if (g.procs > 1)", "         parallel_compress();", " #endif", "     else", "         single_compress(0);", "     if (g.verbosity > 1) {", "         putc('\\n', stderr);", "         fflush(stderr);", "     }", "     if (g.ind != 0)", "         close(g.ind);", "     if (g.outd != 1) {", "         if (close(g.outd))", "             bail(\"write error on \", g.outf);", "         g.outd = -1;             ", "         if (g.ind != 0) {", "             copymeta(g.inf, g.outf);", "             if (!g.keep)", "                 unlink(g.inf);", "         }", "         if (g.decode && (g.headis & 2) != 0 && g.stamp)", "             touch(g.outf, g.stamp);", "     }", "     RELEASE(g.outf);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int read_private_key(RSA *rsa)", " {", " \tint r;", " \tsc_path_t path;", " \tsc_file_t *file;", " \tconst sc_acl_entry_t *e;", " \tu8 buf[2048], *p = buf;", " \tsize_t bufsize, keysize;", " \tr = select_app_df();", " \tif (r)", " \t\treturn 1;", " \tsc_format_path(\"I0012\", &path);", " \tr = sc_select_file(card, &path, &file);", " \tif (r) {", " \t\tfprintf(stderr, \"Unable to select private key file: %s\\n\", sc_strerror(r));", " \t\treturn 2;", " \t}", "  \te = sc_file_get_acl_entry(file, SC_AC_OP_READ);", "  \tif (e == NULL || e->method == SC_AC_NEVER)", "  \t\treturn 10;", "\tbufsize = file->size;", " \tbufsize = MIN(file->size, sizeof buf);", "  \tsc_file_free(file);", "  \tr = sc_read_binary(card, 0, buf, bufsize, 0);", "  \tif (r < 0) {", " \t\tfprintf(stderr, \"Unable to read private key file: %s\\n\", sc_strerror(r));", " \t\treturn 2;", " \t}", " \tbufsize = r;", " \tdo {", " \t\tif (bufsize < 4)", " \t\t\treturn 3;", " \t\tkeysize = (p[0] << 8) | p[1];", " \t\tif (keysize == 0)", " \t\t\tbreak;", " \t\tif (keysize < 3)", " \t\t\treturn 3;", " \t\tif (p[2] == opt_key_num)", " \t\t\tbreak;", " \t\tp += keysize;", " \t\tbufsize -= keysize;", " \t} while (1);", " \tif (keysize == 0) {", " \t\tprintf(\"Key number %d not found.\\n\", opt_key_num);", " \t\treturn 2;", " \t}", " \treturn parse_private_key(p, keysize, rsa);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void SavePayload(size_t handle, uint32_t *payload, uint32_t index)", "{", "mp4object *mp4 = (mp4object *)handle;", "if (mp4 == NULL) return;", "uint32_t *MP4buffer = NULL;", "if (index < mp4->indexcount && mp4->mediafp && payload)", "{", "LONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);", "fwrite(payload, 1, mp4->metasizes[index], mp4->mediafp);", "}", "return;", "}"], "ner_tags": [0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0]}
{"tokens": ["int PackMachBase<T>::canUnpack()", "{", "unsigned const lc_seg = lc_segment[sizeof(Addr)>>3];", "fi->seek(0, SEEK_SET);", "fi->readx(&mhdri, sizeof(mhdri));", "if (((unsigned) Mach_header::MH_MAGIC + (sizeof(Addr)>>3)) !=mhdri.magic", "||  my_cputype   !=mhdri.cputype", "||  my_filetype  !=mhdri.filetype", ")", "return false;", "my_cpusubtype = mhdri.cpusubtype;", "unsigned const ncmds = mhdri.ncmds;", "int headway = (int)mhdri.sizeofcmds;", "if ((2 == ncmds", "&& headway < (int)(sizeof(Mach_segment_command) + 4*4))", "||  (3 <= ncmds", "&& headway < (int)(3 * sizeof(Mach_segment_command)", "+ sizeof(Mach_main_command)))) {", "infoWarning(\"Mach_header.sizeofcmds = %d too small\", headway);", "throwCantUnpack(\"file corrupted\");", "}", "sz_mach_headers = headway + sizeof(mhdri);", "if (2048 < headway) {", "infoWarning(\"Mach_header.sizeofcmds(%d) > 2048\", headway);", "}", "rawmseg_buf.alloc(mhdri.sizeofcmds);", "rawmseg = (Mach_segment_command *)rawmseg_buf.getVoidPtr();", "fi->readx(rawmseg, mhdri.sizeofcmds);", "Mach_segment_command const *ptrTEXT = nullptr;", "upx_uint64_t rip = 0;", "unsigned style = 0;", "off_t offLINK = 0;", "unsigned pos_next = 0;", "unsigned nseg = 0;", "Mach_command const *ptr = (Mach_command const *)rawmseg;", "for (unsigned j= 0; j < ncmds;", "ptr = (Mach_command const *)(ptr->cmdsize + (char const *)ptr), ++j) {", "if ((unsigned)headway < ptr->cmdsize) {", "infoWarning(\"bad Mach_command[%u]{@0x%lx,+0x%x}: file_size=0x%lx  cmdsize=0x%lx\",", "j, (unsigned long) (sizeof(mhdri) + ((char const *)ptr - (char const *)rawmseg)), headway,", "(unsigned long) file_size, (unsigned long)ptr->cmdsize);", "throwCantUnpack(\"file corrupted\");", "}", "if (lc_seg == ptr->cmd) {", "Mach_segment_command const *const segptr = (Mach_segment_command const *)ptr;", "if ((unsigned long)file_size < segptr->filesize", "||  (unsigned long)file_size < segptr->fileoff", "||  (unsigned long)file_size < (segptr->filesize + segptr->fileoff)) {", "infoWarning(\"bad Mach_segment_command[%u]{@0x%lx,+0x%x}: file_size=0x%lx  cmdsize=0x%lx\"", "\"  filesize=0x%lx  fileoff=0x%lx\",", "j, (unsigned long) (sizeof(mhdri) + ((char const *)ptr - (char const *)rawmseg)), headway,", "(unsigned long) file_size, (unsigned long)ptr->cmdsize,", "(unsigned long)segptr->filesize, (unsigned long)segptr->fileoff);", "throwCantUnpack(\"file corrupted\");", "}", "++nseg;", "if (!strcmp(\"__XHDR\", segptr->segname)) {", "style = 391;", "}", "if (!strcmp(\"__TEXT\", segptr->segname)) {", "ptrTEXT = segptr;", "style = 391;", "}", "if (!strcmp(\"UPX_DATA\", segptr->segname)) {", "style = 392;", "}", "if (!strcmp(\"__LINKEDIT\", segptr->segname)) {", "offLINK = segptr->fileoff;", "if (segptr->filesize == blankLINK) {", "style = 395;", "}", "if (offLINK < (off_t) pos_next) {", "offLINK = pos_next;", "}", "}", "pos_next = segptr->filesize + segptr->fileoff;", "if ((headway -= ptr->cmdsize) < 0) {", "infoWarning(\"Mach_command[%u]{@%lu}.cmdsize = %u\", j,", "(unsigned long) (sizeof(mhdri) + mhdri.sizeofcmds - (headway + ptr->cmdsize)),", "(unsigned)ptr->cmdsize);", "throwCantUnpack(\"sum(.cmdsize) exceeds .sizeofcmds\");", "}", "}", "else if (Mach_command::LC_UNIXTHREAD==ptr->cmd) {", "rip = entryVMA = threadc_getPC(ptr);", "}", "}", "if (3==nseg && 395 != style) {", "style = 392;", "}", "if (391==style && 0==offLINK && 2==ncmds && ptrTEXT) {", "offLINK = ptrTEXT->fileoff + ptrTEXT->filesize;", "}", "if (0 == style || 0 == offLINK) {", "return false;", "}", "int const small = 32 + sizeof(overlay_offset);", "unsigned bufsize = 4096;", "if (391 == style) {", "fi->seek(offLINK - bufsize, SEEK_SET);", "} else", "if (392 == style) {", "if (MH_DYLIB == my_filetype) {", "fi->seek(fi->st_size() - bufsize, SEEK_SET);", "}", "else {", "if ((off_t)bufsize > (fi->st_size() - offLINK)) {", "bufsize = fi->st_size() - offLINK;", "}", "fi->seek(offLINK, SEEK_SET);", "}", "} else", "if (395 == style) {", "fi->seek(offLINK - bufsize - sizeof(PackHeader), SEEK_SET);", "}", "MemBuffer buf(bufsize);", "fi->readx(buf, bufsize);", "int i = bufsize;", "while (i > small && 0 == buf[--i]) { }", "i -= small;", "if (i < 1 || !getPackHeader(buf + i, bufsize - i, true)) {", "upx_uint64_t const rip_off = ptrTEXT ? (rip - ptrTEXT->vmaddr) : 0;", "if (ptrTEXT && rip && rip_off < ptrTEXT->vmsize) {", "fi->seek(ptrTEXT->fileoff + rip_off, SEEK_SET);", "fi->readx(buf, bufsize);", "unsigned char const *b = &buf[0];", "unsigned disp = *(TE32 const *)&b[1];", "if (0xe8==b[0] && disp < bufsize", "&&  0x5d==b[5+disp] && 0xe8==b[6+disp]) {", "unsigned disp2 = 0u - *(TE32 const *)&b[7+disp];", "if (disp2 < (12+disp) && 0x5b==b[11+disp-disp2]) {", "struct b_info const *bptr = (struct b_info const *)&b[11+disp];", "if (bptr->sz_cpr < bptr->sz_unc && bptr->sz_unc < 0x1000) {", "b = bptr->sz_cpr + (unsigned char const *)(1+ bptr);", "overlay_offset = *(TE32 const *)(32 + b);", "if (overlay_offset < 0x1000) {", "return true;", "}", "overlay_offset = 0;", "}", "}", "}", "}", "if (391==style) {", "TE32 const *uptr = (TE32 const *)&buf[bufsize];", "while (0==*--uptr)           ;", "overlay_offset = *uptr;", "if (mhdri.sizeofcmds <= overlay_offset && overlay_offset < 0x1000) {", "return true;", "}", "overlay_offset = 0;", "return false;", "}", "if (392==style) {", "overlay_offset = 0x100c;", "fi->seek(overlay_offset, SEEK_SET);", "fi->readx(buf, bufsize);", "struct p_info const *const p_ptr = (struct p_info const *)&buf[0];", "struct b_info const *const b_ptr = (struct b_info const *)(1+ p_ptr);", "TE32 const *uptr = (TE32 const *)(1+ b_ptr);", "if (b_ptr->sz_unc < 0x4000", "&&  b_ptr->sz_cpr < b_ptr->sz_unc ) {", "unsigned const method = b_ptr->b_method;", "if ((M_NRV2B_LE32 == method || M_NRV2E_LE32 == method)", "&&  (0xff>>2)==(uptr[0] >> (2+ 24))", "&&  (Mach_header::MH_MAGIC + (sizeof(Addr)>>3)) == uptr[1]) {", "return true;", "}", "unsigned const magic = get_te32(1+ (char const *)uptr);", "if ((M_NRV2B_8 == method || M_NRV2E_8 == method)", "&& 0xfc==(0xfc & uptr[0])", "&&  (Mach_header::MH_MAGIC + (sizeof(Addr)>>3)) == magic) {", "return true;", "}", "}", "overlay_offset = 0;", "fi->seek(offLINK - 0x1000, SEEK_SET);", "fi->readx(buf, 0x1000);", "unsigned const *const lo = (unsigned const *)&buf[0];", "unsigned const *p;", "for (p = (unsigned const *)&buf[0x1000]; p > lo; ) if (*--p) {", "overlay_offset  = *(TE32 const *)p;", "if ((off_t)overlay_offset < offLINK) {", "overlay_offset = ((char const *)p - (char const *)lo) +", "(offLINK - 0x1000) - overlay_offset + sizeof(l_info);", "fi->seek(overlay_offset, SEEK_SET);", "fi->readx(buf, bufsize);", "if (b_ptr->sz_unc < 0x4000", "&&  b_ptr->sz_cpr < b_ptr->sz_unc ) {", "return true;", "}", "}", "}", "}", "}", "overlay_offset = 0;", "int l = ph.buf_offset + ph.getPackHeaderSize();", "if (0 <= l && (unsigned)(l + sizeof(TE32)) <=bufsize) {", "overlay_offset = get_te32(buf + i + l);", "}", "if (       overlay_offset < sz_mach_headers", "||  (off_t)overlay_offset >= file_size) {", "infoWarning(\"file corrupted\");", "MemBuffer buf2(umin(1<<14, file_size));", "fi->seek(sz_mach_headers, SEEK_SET);", "fi->readx(buf2, buf2.getSize());", "unsigned const *p = (unsigned const *)&buf2[0];", "unsigned const *const e_buf2 = (unsigned const *)&buf2[buf2.getSize() - 4*sizeof(*p)];", "for (; p <= e_buf2; ++p)", "if (   0==p[0]", "&&     0!=p[1]", "&&  p[2]==p[1]", "&&  (unsigned)file_size < get_te32(&p[1])", "&&  sz_mach_headers==get_te32(&p[3])", ") {", "overlay_offset = ((char const *)p - (char const *)&buf2[0]) + sz_mach_headers;", "if (!(3&overlay_offset", "||        overlay_offset < sz_mach_headers", "|| (off_t)overlay_offset >= file_size)) {", "infoWarning(\"attempting recovery, overlay_offset = %#x\", overlay_offset);", "return true;", "}", "}", "throwCantUnpack(\"file corrupted\");", "}", "return true;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["GF_Err stbl_AddDTS(GF_SampleTableBox *stbl, u64 DTS, u32 *sampleNumber, u32 LastAUDefDuration, u32 nb_packed_samples)", "{", "u32 i, j, sampNum;", "u64 *DTSs, curDTS;", "Bool inserted;", "GF_SttsEntry *ent;", "GF_TimeToSampleBox *stts = stbl->TimeToSample;", "stts->r_FirstSampleInEntry = 0;", "*sampleNumber = 0;", "if (!nb_packed_samples)", "nb_packed_samples=1;", "if (!stts->nb_entries) {", "if (DTS) return GF_BAD_PARAM;", "stts->alloc_size = 1;", "stts->nb_entries = 1;", "stts->entries = gf_malloc(sizeof(GF_SttsEntry));", "if (!stts->entries) return GF_OUT_OF_MEM;", "stts->entries[0].sampleCount = nb_packed_samples;", "stts->entries[0].sampleDelta = (nb_packed_samples>1) ? 0 : LastAUDefDuration;", "(*sampleNumber) = 1;", "stts->w_currentSampleNum = nb_packed_samples;", "return GF_OK;", "}", "if (DTS >= stts->w_LastDTS) {", "u32 nb_extra = 0;", "ent = &stts->entries[stts->nb_entries-1];", "if (!ent->sampleDelta && (ent->sampleCount>1)) {", "ent->sampleDelta = (u32) ( DTS / ent->sampleCount);", "stts->w_LastDTS = DTS - ent->sampleDelta;", "}", "if ((DTS == stts->w_LastDTS + ent->sampleDelta)", "|| ((nb_packed_samples>1) && ((DTS == stts->w_LastDTS) || (DTS == stts->w_LastDTS + 2*ent->sampleDelta) ))", ") {", "(*sampleNumber) = stts->w_currentSampleNum + 1;", "ent->sampleCount += nb_packed_samples;", "stts->w_currentSampleNum += nb_packed_samples;", "stts->w_LastDTS = DTS + ent->sampleDelta * (nb_packed_samples-1);", "return GF_OK;", "}", "if (ent->sampleCount == 1) {", "#if 0", "if (stts->w_LastDTS)", "ent->sampleDelta += (u32) (DTS - stts->w_LastDTS);", "else", "ent->sampleDelta = (u32) DTS;", "#else", "ent->sampleDelta = (u32) (DTS - stts->w_LastDTS);", "#endif", "ent->sampleCount ++;", "if ((stts->nb_entries>=2) && (ent->sampleDelta== stts->entries[stts->nb_entries-2].sampleDelta)) {", "stts->entries[stts->nb_entries-2].sampleCount += ent->sampleCount;", "stts->nb_entries--;", "}", "stts->w_currentSampleNum ++;", "stts->w_LastDTS = DTS;", "(*sampleNumber) = stts->w_currentSampleNum;", "return GF_OK;", "}", "ent->sampleCount --;", "if (nb_packed_samples>1)", "nb_extra = 1;", "if (stts->alloc_size <= stts->nb_entries + nb_extra) {", "ALLOC_INC(stts->alloc_size);", "stts->entries = gf_realloc(stts->entries, sizeof(GF_SttsEntry)*stts->alloc_size);", "if (!stts->entries) return GF_OUT_OF_MEM;", "memset(&stts->entries[stts->nb_entries], 0, sizeof(GF_SttsEntry)*(stts->alloc_size-stts->nb_entries) );", "}", "if (nb_extra)", "nb_extra = stts->entries[stts->nb_entries-1].sampleDelta;", "ent = &stts->entries[stts->nb_entries];", "stts->nb_entries++;", "if (nb_packed_samples==1) {", "ent->sampleCount = 2;", "ent->sampleDelta = (u32) (DTS - stts->w_LastDTS);", "stts->w_LastDTS = DTS;", "(*sampleNumber) = stts->w_currentSampleNum+1;", "stts->w_currentSampleNum += 1;", "return GF_OK;", "}", "ent->sampleCount = 1;", "ent->sampleDelta = (u32) (DTS - stts->w_LastDTS);", "ent = &stts->entries[stts->nb_entries];", "stts->nb_entries++;", "ent->sampleCount = nb_packed_samples;", "ent->sampleDelta = nb_extra;", "stts->w_LastDTS = DTS;", "(*sampleNumber) = stts->w_currentSampleNum + 1;", "stts->w_currentSampleNum += nb_packed_samples;", "return GF_OK;", "}", "DTSs = (u64*)gf_malloc(sizeof(u64) * (stbl->SampleSize->sampleCount+2) );", "if (!DTSs) return GF_OUT_OF_MEM;", "curDTS = 0;", "sampNum = 0;", "ent = NULL;", "inserted = 0;", "for (i=0; i<stts->nb_entries; i++) {", "ent = & stts->entries[i];", "for (j = 0; j<ent->sampleCount; j++) {", "if (!inserted && (curDTS > DTS)) {", "DTSs[sampNum] = DTS;", "sampNum++;", "*sampleNumber = sampNum;", "inserted = 1;", "}", "DTSs[sampNum] = curDTS;", "curDTS += ent->sampleDelta;", "sampNum ++;", "}", "}", "if (!inserted) {", "gf_free(DTSs);", "return GF_BAD_PARAM;", "}", "if (stts->nb_entries+3 >= stts->alloc_size) {", "stts->alloc_size += 3;", "stts->entries = gf_realloc(stts->entries, sizeof(GF_SttsEntry)*stts->alloc_size);", "if (!stts->entries) return GF_OUT_OF_MEM;", "memset(&stts->entries[stts->nb_entries], 0, sizeof(GF_SttsEntry)*(stts->alloc_size - stts->nb_entries) );", "}", "j=0;", "stts->nb_entries = 1;", "stts->entries[0].sampleCount = 1;", "stts->entries[0].sampleDelta = (u32) DTSs[1]                           ;", "for (i=1; i<stbl->SampleSize->sampleCount+1; i++) {", "if (i == stbl->SampleSize->sampleCount) {", "stts->entries[j].sampleCount++;", "} else if (stts->entries[j].sampleDelta == (u32) ( DTSs[i+1] - DTSs[i]) ) {", "stts->entries[j].sampleCount ++;", "} else {", "stts->nb_entries ++;", "j++;", "stts->entries[j].sampleCount = 1;", "stts->entries[j].sampleDelta = (u32) (DTSs[i+1] - DTSs[i]);", "}", "}", "gf_free(DTSs);", "stts->w_currentSampleNum = stbl->SampleSize->sampleCount + 1;", "return GF_OK;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["xmlAddRef(xmlValidCtxtPtr ctxt, xmlDocPtr doc, const xmlChar *value,", "xmlAttrPtr attr) {", "xmlRefPtr ret;", "xmlRefTablePtr table;", "xmlListPtr ref_list;", "if (doc == NULL) {", "return(NULL);", "}", "if (value == NULL) {", "return(NULL);", "}", "if (attr == NULL) {", "return(NULL);", "}", "table = (xmlRefTablePtr) doc->refs;", "if (table == NULL) {", "doc->refs = table = xmlHashCreateDict(0, doc->dict);", "}", "if (table == NULL) {", "xmlVErrMemory(ctxt,", "\"xmlAddRef: Table creation failed!\\n\");", "return(NULL);", "}", "ret = (xmlRefPtr) xmlMalloc(sizeof(xmlRef));", "if (ret == NULL) {", "xmlVErrMemory(ctxt, \"malloc failed\");", "return(NULL);", "}", "ret->value = xmlStrdup(value);", "if ((ctxt != NULL) && (ctxt->vstateNr != 0)) {", "ret->name = xmlStrdup(attr->name);", "ret->attr = NULL;", "} else {", "ret->name = NULL;", "ret->attr = attr;", "}", "ret->lineno = xmlGetLineNo(attr->parent);", "if (NULL == (ref_list = xmlHashLookup(table, value))) {", "if (NULL == (ref_list = xmlListCreate(xmlFreeRef, xmlDummyCompare))) {", "xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,", "\"xmlAddRef: Reference list creation failed!\\n\",", "NULL);", "goto failed;", "}", "if (xmlHashAddEntry(table, value, ref_list) < 0) {", "xmlListDelete(ref_list);", "xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,", "\"xmlAddRef: Reference list insertion failed!\\n\",", "NULL);", "goto failed;", "}", "}", "if (xmlListAppend(ref_list, ret) != 0) {", "xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,", "\"xmlAddRef: Reference list insertion failed!\\n\",", "NULL);", "goto failed;", "}", "return(ret);", "failed:", "if (ret != NULL) {", "if (ret->value != NULL)", "xmlFree((char *)ret->value);", "if (ret->name != NULL)", "xmlFree((char *)ret->name);", "xmlFree(ret);", "}", "return(NULL);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["int init_aliases(void)", "{", "FILE *fp;", "char alias[MAXALIASLEN + 1U];", "char dir[PATH_MAX + 1U];", "if ((fp = fopen(ALIASES_FILE, \"r\")) == NULL) {", "return 0;", "}", "while (fgets(alias, sizeof alias, fp) != NULL) {", "if (*alias == '#' || *alias == '\\n' || *alias == 0) {", "continue;", "}", "{", "char * const z = alias + strlen(alias) - 1U;", "if (*z != '\\n') {", "goto bad;", "}", "*z = 0;", "}", "do {", "if (fgets(dir, sizeof dir, fp) == NULL || *dir == 0) {", "goto bad;", "}", "{", "char * const z = dir + strlen(dir) - 1U;", "if (*z == '\\n') {", "*z = 0;", "}", "}", "} while (*dir == '#' || *dir == 0);", "if (head == NULL) {", "if ((head = tail = malloc(sizeof *head)) == NULL ||", "(tail->alias = strdup(alias)) == NULL ||", "(tail->dir = strdup(dir)) == NULL) {", "die_mem();", "}", "tail->next = NULL;", "} else {", "DirAlias *curr;", "if ((curr = malloc(sizeof *curr)) == NULL ||", "(curr->alias = strdup(alias)) == NULL ||", "(curr->dir = strdup(dir)) == NULL) {", "die_mem();", "}", "tail->next = curr;", "tail = curr;", "}", "}", "fclose(fp);", "aliases_up++;", "return 0;", "bad:", "fclose(fp);", "logfile(LOG_ERR, MSG_ALIASES_BROKEN_FILE \" [\" ALIASES_FILE \"]\");", "return -1;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["archive_read_format_rar_read_data(struct archive_read *a, const void **buff,", "size_t *size, int64_t *offset)", "{", "struct rar *rar = (struct rar *)(a->format->data);", "int ret;", "if (rar->has_encrypted_entries == ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW) {", "rar->has_encrypted_entries = 0;", "}", "if (rar->bytes_unconsumed > 0) {", "__archive_read_consume(a, rar->bytes_unconsumed);", "rar->bytes_unconsumed = 0;", "}", "*buff = NULL;", "if (rar->entry_eof || rar->offset_seek >= rar->unp_size) {", "*size = 0;", "*offset = rar->offset;", "if (*offset < rar->unp_size)", "*offset = rar->unp_size;", "return (ARCHIVE_EOF);", "}", "switch (rar->compression_method)", "{", "case COMPRESS_METHOD_STORE:", "ret = read_data_stored(a, buff, size, offset);", "break;", "case COMPRESS_METHOD_FASTEST:", "case COMPRESS_METHOD_FAST:", "case COMPRESS_METHOD_NORMAL:", "case COMPRESS_METHOD_GOOD:", "case COMPRESS_METHOD_BEST:", "ret = read_data_compressed(a, buff, size, offset);", "if (ret != ARCHIVE_OK && ret != ARCHIVE_WARN)", "__archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context);", "break;", "default:", "archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", "\"Unsupported compression method for RAR file.\");", "ret = ARCHIVE_FATAL;", "break;", "}", "return (ret);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static void gf_m2ts_process_pmt(GF_M2TS_Demuxer *ts, GF_M2TS_SECTION_ES *pmt, GF_List *sections, u8 table_id, u16 ex_table_id, u8 version_number, u8 last_section_number, u32 status)", "{", "u32 info_length, pos, desc_len, evt_type, nb_es,i;", "u32 nb_sections;", "u32 data_size;", "u32 nb_hevc, nb_hevc_temp, nb_shvc, nb_shvc_temp, nb_mhvc, nb_mhvc_temp;", "unsigned char *data;", "GF_M2TS_Section *section;", "GF_Err e = GF_OK;", "if (!(status&GF_M2TS_TABLE_END)) return;", "nb_es = 0;", "if ((status&GF_M2TS_TABLE_REPEAT) && !(status&GF_M2TS_TABLE_UPDATE))  {", "if (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_PMT_REPEAT, pmt->program);", "return;", "}", "if (pmt->sec->demux_restarted) {", "pmt->sec->demux_restarted = 0;", "return;", "}", "GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PMT Found or updated\\n\"));", "nb_sections = gf_list_count(sections);", "if (nb_sections > 1) {", "GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"PMT on multiple sections not supported\\n\"));", "}", "section = (GF_M2TS_Section *)gf_list_get(sections, 0);", "data = section->data;", "data_size = section->data_size;", "pmt->program->pcr_pid = ((data[0] & 0x1f) << 8) | data[1];", "info_length = ((data[2]&0xf)<<8) | data[3];", "if (info_length != 0) {", "u8 tag, len;", "u32 first_loop_len = 0;", "tag = data[4];", "len = data[5];", "while (info_length > first_loop_len) {", "if (tag == GF_M2TS_MPEG4_IOD_DESCRIPTOR) {", "u32 size;", "GF_BitStream *iod_bs;", "iod_bs = gf_bs_new((char *)data+8, len-2, GF_BITSTREAM_READ);", "if (pmt->program->pmt_iod) gf_odf_desc_del((GF_Descriptor *)pmt->program->pmt_iod);", "e = gf_odf_parse_descriptor(iod_bs , (GF_Descriptor **) &pmt->program->pmt_iod, &size);", "gf_bs_del(iod_bs );", "if (e==GF_OK) {", "if (pmt->program->pmt_iod) pmt->program->pmt_iod->ServiceID = pmt->program->number;", "if (!gf_list_count(pmt->program->pmt_iod->ESDescriptors)) {", "gf_odf_desc_del((GF_Descriptor *)pmt->program->pmt_iod);", "pmt->program->pmt_iod = NULL;", "}", "}", "} else if (tag == GF_M2TS_METADATA_POINTER_DESCRIPTOR) {", "GF_BitStream *metadatapd_bs;", "GF_M2TS_MetadataPointerDescriptor *metapd;", "metadatapd_bs = gf_bs_new((char *)data+6, len, GF_BITSTREAM_READ);", "metapd = gf_m2ts_read_metadata_pointer_descriptor(metadatapd_bs, len);", "gf_bs_del(metadatapd_bs);", "if (metapd->application_format_identifier == GF_M2TS_META_ID3 &&", "metapd->format_identifier == GF_M2TS_META_ID3 &&", "metapd->carriage_flag == METADATA_CARRIAGE_SAME_TS) {", "pmt->program->metadata_pointer_descriptor = metapd;", "} else {", "gf_m2ts_metadata_pointer_descriptor_del(metapd);", "}", "} else {", "GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Skipping descriptor (0x%x) and others not supported\\n\", tag));", "}", "first_loop_len += 2 + len;", "}", "}", "if (data_size <= 4 + info_length) return;", "data += 4 + info_length;", "data_size -= 4 + info_length;", "pos = 0;", "for(i=0; i<gf_list_count(ts->programs); i++) {", "GF_M2TS_Program *prog = (GF_M2TS_Program *)gf_list_get(ts->programs,i);", "if(prog->pmt_pid == pmt->pid) {", "break;", "}", "}", "nb_hevc = nb_hevc_temp = nb_shvc = nb_shvc_temp = nb_mhvc = nb_mhvc_temp = 0;", "while (pos<data_size) {", "GF_M2TS_PES *pes = NULL;", "GF_M2TS_SECTION_ES *ses = NULL;", "GF_M2TS_ES *es = NULL;", "Bool inherit_pcr = 0;", "u32 pid, stream_type, reg_desc_format;", "if (pos + 5 > data_size) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Broken PMT! size %d but position %d and need at least 5 bytes to declare es\\n\", data_size, pos));", "break;", "}", "stream_type = data[0];", "pid = ((data[1] & 0x1f) << 8) | data[2];", "desc_len = ((data[3] & 0xf) << 8) | data[4];", "GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"stream_type :%d \\n\",stream_type));", "switch (stream_type) {", "case GF_M2TS_VIDEO_MPEG1:", "case GF_M2TS_VIDEO_MPEG2:", "case GF_M2TS_VIDEO_DCII:", "case GF_M2TS_VIDEO_MPEG4:", "case GF_M2TS_SYSTEMS_MPEG4_PES:", "case GF_M2TS_VIDEO_H264:", "case GF_M2TS_VIDEO_SVC:", "case GF_M2TS_VIDEO_MVCD:", "case GF_M2TS_VIDEO_HEVC:", "case GF_M2TS_VIDEO_HEVC_MCTS:", "case GF_M2TS_VIDEO_HEVC_TEMPORAL:", "case GF_M2TS_VIDEO_SHVC:", "case GF_M2TS_VIDEO_SHVC_TEMPORAL:", "case GF_M2TS_VIDEO_MHVC:", "case GF_M2TS_VIDEO_MHVC_TEMPORAL:", "inherit_pcr = 1;", "case GF_M2TS_AUDIO_MPEG1:", "case GF_M2TS_AUDIO_MPEG2:", "case GF_M2TS_AUDIO_AAC:", "case GF_M2TS_AUDIO_LATM_AAC:", "case GF_M2TS_AUDIO_AC3:", "case GF_M2TS_AUDIO_DTS:", "case GF_M2TS_MHAS_MAIN:", "case GF_M2TS_MHAS_AUX:", "case GF_M2TS_SUBTITLE_DVB:", "case GF_M2TS_METADATA_PES:", "GF_SAFEALLOC(pes, GF_M2TS_PES);", "if (!pes) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG2TS] Failed to allocate ES for pid %d\\n\", pid));", "return;", "}", "pes->cc = -1;", "pes->flags = GF_M2TS_ES_IS_PES;", "if (inherit_pcr)", "pes->flags |= GF_M2TS_INHERIT_PCR;", "es = (GF_M2TS_ES *)pes;", "break;", "case GF_M2TS_PRIVATE_DATA:", "GF_SAFEALLOC(pes, GF_M2TS_PES);", "if (!pes) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG2TS] Failed to allocate ES for pid %d\\n\", pid));", "return;", "}", "pes->cc = -1;", "pes->flags = GF_M2TS_ES_IS_PES;", "es = (GF_M2TS_ES *)pes;", "break;", "case GF_M2TS_SYSTEMS_MPEG4_SECTIONS:", "GF_SAFEALLOC(ses, GF_M2TS_SECTION_ES);", "if (!ses) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG2TS] Failed to allocate ES for pid %d\\n\", pid));", "return;", "}", "es = (GF_M2TS_ES *)ses;", "es->flags |= GF_M2TS_ES_IS_SECTION;", "if (stream_type == GF_M2TS_SYSTEMS_MPEG4_SECTIONS) {", "ses->sec = gf_m2ts_section_filter_new(gf_m2ts_process_mpeg4section, 0);", "if (!pmt->program->additional_ods) {", "pmt->program->additional_ods = gf_list_new();", "ts->has_4on2 = 1;", "}", "}", "break;", "case GF_M2TS_13818_6_ANNEX_A:", "case GF_M2TS_13818_6_ANNEX_B:", "case GF_M2TS_13818_6_ANNEX_C:", "case GF_M2TS_13818_6_ANNEX_D:", "case GF_M2TS_PRIVATE_SECTION:", "case GF_M2TS_QUALITY_SEC:", "case GF_M2TS_MORE_SEC:", "GF_SAFEALLOC(ses, GF_M2TS_SECTION_ES);", "if (!ses) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG2TS] Failed to allocate ES for pid %d\\n\", pid));", "return;", "}", "es = (GF_M2TS_ES *)ses;", "es->flags |= GF_M2TS_ES_IS_SECTION;", "es->pid = pid;", "es->service_id = pmt->program->number;", "if (stream_type == GF_M2TS_PRIVATE_SECTION) {", "GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"AIT sections on pid %d\\n\", pid));", "} else if (stream_type == GF_M2TS_QUALITY_SEC) {", "GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"Quality metadata sections on pid %d\\n\", pid));", "} else if (stream_type == GF_M2TS_MORE_SEC) {", "GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"MORE sections on pid %d\\n\", pid));", "} else {", "GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"stream type DSM CC user private sections on pid %d \\n\", pid));", "}", "ses->sec = gf_m2ts_section_filter_new(NULL, 1);", "break;", "case GF_M2TS_MPE_SECTIONS:", "if (! ts->prefix_present) {", "GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"stream type MPE found : pid = %d \\n\", pid));", "#ifdef GPAC_ENABLE_MPE", "es = gf_dvb_mpe_section_new();", "if (es->flags & GF_M2TS_ES_IS_SECTION) {", "((GF_M2TS_SECTION_ES*)es)->sec = gf_m2ts_section_filter_new(NULL, 1);", "}", "#endif", "break;", "}", "default:", "GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Stream type (0x%x) for PID %d not supported\\n\", stream_type, pid ) );", "break;", "}", "if (es) {", "es->stream_type = (stream_type==GF_M2TS_PRIVATE_DATA) ? 0 : stream_type;", "es->program = pmt->program;", "es->pid = pid;", "es->component_tag = -1;", "}", "pos += 5;", "data += 5;", "while (desc_len) {", "if (pos + 2 > data_size) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Broken PMT descriptor! size %d but position %d and need at least 2 bytes to parse descritpor\\n\", data_size, pos));", "break;", "}", "u8 tag = data[0];", "u32 len = data[1];", "if (pos + 2 + len > data_size) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Broken PMT descriptor! size %d, desc size %d but position %d\\n\", data_size, len, pos));", "break;", "}", "if (es) {", "switch (tag) {", "case GF_M2TS_ISO_639_LANGUAGE_DESCRIPTOR:", "if (pes && (len>=3) )", "pes->lang = GF_4CC(' ', data[2], data[3], data[4]);", "break;", "case GF_M2TS_MPEG4_SL_DESCRIPTOR:", "if (len>=2) {", "es->mpeg4_es_id = ( (u32) data[2] & 0x1f) << 8  | data[3];", "es->flags |= GF_M2TS_ES_IS_SL;", "}", "break;", "case GF_M2TS_REGISTRATION_DESCRIPTOR:", "if (len>=4) {", "reg_desc_format = GF_4CC(data[2], data[3], data[4], data[5]);", "switch (reg_desc_format) {", "case GF_M2TS_RA_STREAM_AC3:", "es->stream_type = GF_M2TS_AUDIO_AC3;", "break;", "case GF_M2TS_RA_STREAM_VC1:", "es->stream_type = GF_M2TS_VIDEO_VC1;", "break;", "case GF_M2TS_RA_STREAM_GPAC:", "if (len==8) {", "es->stream_type = GF_4CC(data[6], data[7], data[8], data[9]);", "es->flags |= GF_M2TS_GPAC_CODEC_ID;", "break;", "}", "default:", "GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"Unknown registration descriptor %s\\n\", gf_4cc_to_str(reg_desc_format) ));", "break;", "}", "}", "break;", "case GF_M2TS_DVB_EAC3_DESCRIPTOR:", "es->stream_type = GF_M2TS_AUDIO_EC3;", "break;", "case GF_M2TS_DVB_DATA_BROADCAST_ID_DESCRIPTOR:", "if (len>=2) {", "u32 id = data[2]<<8 | data[3];", "if ((id == 0xB) && ses && !ses->sec) {", "ses->sec = gf_m2ts_section_filter_new(NULL, 1);", "}", "}", "break;", "case GF_M2TS_DVB_SUBTITLING_DESCRIPTOR:", "if (pes && (len>=8)) {", "pes->sub.language[0] = data[2];", "pes->sub.language[1] = data[3];", "pes->sub.language[2] = data[4];", "pes->sub.type = data[5];", "pes->sub.composition_page_id = (data[6]<<8) | data[7];", "pes->sub.ancillary_page_id = (data[8]<<8) | data[9];", "}", "es->stream_type = GF_M2TS_DVB_SUBTITLE;", "break;", "case GF_M2TS_DVB_STREAM_IDENTIFIER_DESCRIPTOR:", "if (len>=1) {", "es->component_tag = data[2];", "GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"Component Tag: %d on Program %d\\n\", es->component_tag, es->program->number));", "}", "break;", "case GF_M2TS_DVB_TELETEXT_DESCRIPTOR:", "es->stream_type = GF_M2TS_DVB_TELETEXT;", "break;", "case GF_M2TS_DVB_VBI_DATA_DESCRIPTOR:", "es->stream_type = GF_M2TS_DVB_VBI;", "break;", "case GF_M2TS_HIERARCHY_DESCRIPTOR:", "if (pes && (len>=4)) {", "u8 hierarchy_embedded_layer_index;", "GF_BitStream *hbs = gf_bs_new((const char *)data, data_size, GF_BITSTREAM_READ);", "gf_bs_read_int(hbs, 16);", "gf_bs_read_int(hbs, 1);", "gf_bs_read_int(hbs, 1);", "gf_bs_read_int(hbs, 1);", "gf_bs_read_int(hbs, 1);", "gf_bs_read_int(hbs, 4);", "gf_bs_read_int(hbs, 2);", "gf_bs_read_int(hbs, 6);", "gf_bs_read_int(hbs, 1);", "gf_bs_read_int(hbs, 1);", "hierarchy_embedded_layer_index = gf_bs_read_int(hbs, 6);", "gf_bs_read_int(hbs, 2);", "gf_bs_read_int(hbs, 6);", "gf_bs_del(hbs);", "pes->depends_on_pid = 1+hierarchy_embedded_layer_index;", "}", "break;", "case GF_M2TS_METADATA_DESCRIPTOR:", "{", "GF_BitStream *metadatad_bs;", "GF_M2TS_MetadataDescriptor *metad;", "metadatad_bs = gf_bs_new((char *)data+2, len, GF_BITSTREAM_READ);", "metad = gf_m2ts_read_metadata_descriptor(metadatad_bs, len);", "gf_bs_del(metadatad_bs);", "if (metad->application_format_identifier == GF_M2TS_META_ID3 &&", "metad->format_identifier == GF_M2TS_META_ID3) {", "if (pes) {", "pes->metadata_descriptor = metad;", "pes->stream_type = GF_M2TS_METADATA_ID3_HLS;", "}", "} else {", "gf_m2ts_metadata_descriptor_del(metad);", "}", "}", "break;", "default:", "GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] skipping descriptor (0x%x) not supported\\n\", tag));", "break;", "}", "}", "data += len+2;", "pos += len+2;", "if (desc_len < len+2) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Invalid PMT es descriptor size for PID %d\\n\", pid ) );", "break;", "}", "desc_len-=len+2;", "}", "if (es && !es->stream_type) {", "gf_free(es);", "es = NULL;", "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Private Stream type (0x%x) for PID %d not supported\\n\", stream_type, pid ) );", "}", "if (!es) continue;", "if (ts->ess[pid]) {", "if (status & GF_M2TS_TABLE_FOUND) {", "GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d reused across programs %d and %d, not completely supported\\n\", pid, ts->ess[pid]->program->number, es->program->number ) );", "gf_list_add(pmt->program->streams, es);", "if (!(es->flags & GF_M2TS_ES_IS_SECTION) ) gf_m2ts_set_pes_framing(pes, GF_M2TS_PES_FRAMING_SKIP);", "nb_es++;", "es = NULL;", "}", "else {", "GF_M2TS_ES *o_es = ts->ess[es->pid];", "if ((o_es->stream_type == es->stream_type)", "&& ((o_es->flags & GF_M2TS_ES_STATIC_FLAGS_MASK) == (es->flags & GF_M2TS_ES_STATIC_FLAGS_MASK))", "&& (o_es->mpeg4_es_id == es->mpeg4_es_id)", "&& ((o_es->flags & GF_M2TS_ES_IS_SECTION) || ((GF_M2TS_PES *)o_es)->lang == ((GF_M2TS_PES *)es)->lang)", ") {", "gf_free(es);", "es = NULL;", "} else {", "gf_m2ts_es_del(o_es, ts);", "ts->ess[es->pid] = NULL;", "}", "}", "}", "if (es) {", "ts->ess[es->pid] = es;", "gf_list_add(pmt->program->streams, es);", "if (!(es->flags & GF_M2TS_ES_IS_SECTION) ) gf_m2ts_set_pes_framing(pes, GF_M2TS_PES_FRAMING_SKIP);", "nb_es++;", "if (es->stream_type == GF_M2TS_VIDEO_HEVC) nb_hevc++;", "else if (es->stream_type == GF_M2TS_VIDEO_HEVC_TEMPORAL) nb_hevc_temp++;", "else if (es->stream_type == GF_M2TS_VIDEO_SHVC) nb_shvc++;", "else if (es->stream_type == GF_M2TS_VIDEO_SHVC_TEMPORAL) nb_shvc_temp++;", "else if (es->stream_type == GF_M2TS_VIDEO_MHVC) nb_mhvc++;", "else if (es->stream_type == GF_M2TS_VIDEO_MHVC_TEMPORAL) nb_mhvc_temp++;", "}", "}", "if (nb_hevc_temp + nb_shvc + nb_shvc_temp + nb_mhvc+ nb_mhvc_temp) {", "for (i=0; i<gf_list_count(pmt->program->streams); i++) {", "GF_M2TS_PES *es = (GF_M2TS_PES *)gf_list_get(pmt->program->streams, i);", "if ( !(es->flags & GF_M2TS_ES_IS_PES)) continue;", "if (es->depends_on_pid) continue;", "switch (es->stream_type) {", "case GF_M2TS_VIDEO_HEVC_TEMPORAL:", "es->depends_on_pid = 1;", "break;", "case GF_M2TS_VIDEO_SHVC:", "if (!nb_hevc_temp) es->depends_on_pid = 1;", "else es->depends_on_pid = 2;", "break;", "case GF_M2TS_VIDEO_SHVC_TEMPORAL:", "es->depends_on_pid = 3;", "break;", "case GF_M2TS_VIDEO_MHVC:", "if (!nb_hevc_temp) es->depends_on_pid = 1;", "else es->depends_on_pid = 2;", "break;", "case GF_M2TS_VIDEO_MHVC_TEMPORAL:", "if (!nb_hevc_temp) es->depends_on_pid = 2;", "else es->depends_on_pid = 3;", "break;", "}", "}", "}", "if (nb_es) {", "u32 i;", "for (i=0; i<gf_list_count(pmt->program->streams); i++) {", "GF_M2TS_PES *an_es = NULL;", "GF_M2TS_PES *es = (GF_M2TS_PES *)gf_list_get(pmt->program->streams, i);", "if ( !(es->flags & GF_M2TS_ES_IS_PES)) continue;", "if (!es->depends_on_pid) continue;", "an_es =  (GF_M2TS_PES *)gf_list_get(pmt->program->streams, es->depends_on_pid);", "if (an_es) {", "es->depends_on_pid = an_es->pid;", "} else {", "GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[M2TS] Wrong dependency index in hierarchy descriptor, assuming non-scalable stream\\n\"));", "es->depends_on_pid = 0;", "}", "}", "evt_type = (status&GF_M2TS_TABLE_FOUND) ? GF_M2TS_EVT_PMT_FOUND : GF_M2TS_EVT_PMT_UPDATE;", "if (ts->on_event) ts->on_event(ts, evt_type, pmt->program);", "} else {", "if (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_PMT_REPEAT, pmt->program);", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int src_parser_trans_stage_1_2_3(const int tmp_fd, const char *src, const struct trans_config cfg)", "{", "struct parser_buf pbuf = {", ".f_indx = 0,", ".tmp_indx = 0,", ".f_read_size = 0", "};", "int write_count = 0;", "int src_fd;", "int p_state = P_STATE_CODE;", "src_fd = open(src, O_RDONLY);", "if (src_fd == -1) {", "fprintf(stderr, \"**Error: Could not open source file: %s.\\n\", src);", "return -1;", "}", "while (p_buf_refill(&pbuf, src_fd) > 0) {", "while (PBUF_F_REMD(pbuf)) {", "switch (p_state) {", "case P_STATE_COMMENT_C:", "switch (PBUF_F_CHAR(pbuf)) {", "case '*':", "p_buf_push_tmp_char(&pbuf, '*');", "continue;", "case '/':", "if (pbuf.tmp_indx && (PBUF_TMP_PREV_CHAR(pbuf) == '*')) {", "pbuf.tmp_indx--;", "p_state = P_STATE_CODE;", "}", "break;", "default:", "if (pbuf.tmp_indx && (PBUF_TMP_PREV_CHAR(pbuf) == '*'))", "pbuf.tmp_indx--;", "break;", "}", "pbuf.f_indx++;", "case P_STATE_CODE:", "default:", "switch (PBUF_F_CHAR(pbuf)) {", "case ' ':", "case '\\t':", "if (pbuf.tmp_indx &&", "(PBUF_TMP_PREV_CHAR(pbuf) == ' ' || PBUF_TMP_PREV_CHAR(pbuf) == '\\t' ||", "PBUF_TMP_PREV_CHAR(pbuf) == '\\n'))", "pbuf.f_indx++;", "else", "p_buf_push_tmp_char(&pbuf, ' ');", "continue;", "case '\\r':", "case '\\n':", "if (pbuf.tmp_indx &&", "(PBUF_TMP_PREV_CHAR(pbuf) == ' ' || PBUF_TMP_PREV_CHAR(pbuf) == '\\t' ||", "PBUF_TMP_PREV_CHAR(pbuf) == '\\n')) {", "pbuf.f_indx++;", "} else if (pbuf.tmp_indx &&", "(PBUF_TMP_PREV_CHAR(pbuf) == '\\\\')) {", "pbuf.tmp_indx--;", "pbuf.f_indx++;", "} else {", "p_buf_push_tmp_char(&pbuf, '\\n');", "}", "continue;", "case '\\\\':", "p_buf_push_tmp_char(&pbuf, '\\\\');", "continue;", "case '/':", "p_buf_push_tmp_char(&pbuf, '/');", "continue;", "case '*':", "if (pbuf.tmp_indx &&", "(PBUF_TMP_PREV_CHAR(pbuf) == '/')) {", "pbuf.tmp_indx--;", "pbuf.f_indx++;", "p_state = P_STATE_COMMENT_C;", "continue;", "}", "default:", "break;", "}", "p_buf_write_tmp(&pbuf, tmp_fd);", "p_buf_write_f_char(&pbuf, tmp_fd);", "}", "}", "}", "p_buf_write_tmp(&pbuf, tmp_fd);", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["ngx_http_send_error_page(ngx_http_request_t *r, ngx_http_err_page_t *err_page)", "{", "ngx_int_t                  overwrite;", "ngx_str_t                  uri, args;", "ngx_table_elt_t           *location;", "ngx_http_core_loc_conf_t  *clcf;", "overwrite = err_page->overwrite;", "if (overwrite && overwrite != NGX_HTTP_OK) {", "r->expect_tested = 1;", "}", "if (overwrite >= 0) {", "r->err_status = overwrite;", "}", "if (ngx_http_complex_value(r, &err_page->value, &uri) != NGX_OK) {", "return NGX_ERROR;", "}", "if (uri.len && uri.data[0] == '/') {", "if (err_page->value.lengths) {", "ngx_http_split_args(r, &uri, &args);", "} else {", "args = err_page->args;", "}", "if (r->method != NGX_HTTP_HEAD) {", "r->method = NGX_HTTP_GET;", "r->method_name = ngx_http_core_get_method;", "}", "return ngx_http_internal_redirect(r, &uri, &args);", "}", "if (uri.len && uri.data[0] == '@') {", "return ngx_http_named_location(r, &uri);", "}", "location = ngx_list_push(&r->headers_out.headers);", "if (location == NULL) {", "return NGX_ERROR;", "}", "if (overwrite != NGX_HTTP_MOVED_PERMANENTLY", "&& overwrite != NGX_HTTP_MOVED_TEMPORARILY", "&& overwrite != NGX_HTTP_SEE_OTHER", "&& overwrite != NGX_HTTP_TEMPORARY_REDIRECT", "&& overwrite != NGX_HTTP_PERMANENT_REDIRECT)", "{", "r->err_status = NGX_HTTP_MOVED_TEMPORARILY;", "}", "location->hash = 1;", "ngx_str_set(&location->key, \"Location\");", "location->value = uri;", "ngx_http_clear_location(r);", "r->headers_out.location = location;", "clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);", "if (clcf->msie_refresh && r->headers_in.msie) {", "return ngx_http_send_refresh(r);", "}", "return ngx_http_send_special_response(r, clcf, r->err_status", "- NGX_HTTP_MOVED_PERMANENTLY", "+ NGX_HTTP_OFF_3XX);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["int virtualbox_get_guest_property(char *name, void **value, size_t *size) {", "errno = 0;", "int _cleanup_close_ fd = open(\"/dev/vboxguest\", O_RDWR | O_CLOEXEC);", "if (fd == -1) {", "return VERR_GENERAL_FAILURE;", "}", "int ret = version_info(fd);", "if (ret != VINF_SUCCESS) {", "return ret;", "}", "uint32_t client_id;", "ret = connect(fd, &client_id);", "if (ret != VINF_SUCCESS) {", "return ret;", "}", "ret = get_prop(fd, client_id, name, value, size);", "if (ret != VINF_SUCCESS) {", "disconnect(fd, client_id);", "return ret;", "}", "ret = disconnect(fd, client_id);", "if (ret != VINF_SUCCESS) {", "free(*value);", "*value = NULL;", "return ret;", "}", "errno = 0;", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["String UTF16BEDecoder::to_utf8(const StringView& input)", "{", "StringBuilder builder(input.length() / 2);", "for (size_t i = 0; i < input.length(); i += 2) {", "u16 code_point = (input[i] << 8) | input[i + 1];", "builder.append_code_point(code_point);", "}", "return builder.to_string();", "}"], "ner_tags": [0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["static GF_Err gf_text_process_sub(GF_Filter *filter, GF_TXTIn *ctx)", "{", "u32 i, j, len, line;", "GF_TextSample *samp;", "Double ts_scale;", "char szLine[2048], szTime[20], szText[2048];", "if (!ctx->is_setup) {", "ctx->is_setup = GF_TRUE;", "return txtin_setup_srt(filter, ctx);", "}", "if (!ctx->opid) return GF_NOT_SUPPORTED;", "if (!ctx->playstate) return GF_OK;", "else if (ctx->playstate==2) return GF_EOS;", "if (ctx->seek_state==1) {", "ctx->seek_state = 2;", "gf_fseek(ctx->src, 0, SEEK_SET);", "}", "if (ctx->fps.den && ctx->fps.num) {", "ts_scale = ((Double) ctx->fps.num) / ctx->fps.den;", "} else {", "ts_scale = 25;", "}", "line = 0;", "while (1) {", "char *sOK = gf_text_get_utf8_line(szLine, 2048, ctx->src, ctx->unicode_type);", "if (!sOK) break;", "REM_TRAIL_MARKS(szLine, \"\\r\\n\\t \")", "line++;", "len = (u32) strlen(szLine);", "if (!len) continue;", "i=0;", "if (szLine[i] != '{') {", "GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Bad SUB file (line %d): expecting \\\"{\\\" got \\\"%c\\\"\\n\", line, szLine[i]));", "continue;", "}", "while (szLine[i+1] && szLine[i+1]!='}') {", "szTime[i] = szLine[i+1];", "i++;", "}", "szTime[i] = 0;", "ctx->start = atoi(szTime);", "if (ctx->start < ctx->end) {", "GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] corrupted SUB frame (line %d) - starts (at %d ms) before end of previous one (%d ms) - adjusting time stamps\\n\", line, ctx->start, ctx->end));", "ctx->start = ctx->end;", "}", "j=i+2;", "i=0;", "if (szLine[i+j] != '{') {", "GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] Bad SUB file - expecting \\\"{\\\" got \\\"%c\\\"\\n\", szLine[i]));", "continue;", "}", "while (szLine[i+1+j] && szLine[i+1+j]!='}') {", "szTime[i] = szLine[i+1+j];", "i++;", "}", "szTime[i] = 0;", "ctx->end = atoi(szTime);", "j+=i+2;", "if (ctx->start > ctx->end) {", "GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] corrupted SUB frame (line %d) - ends (at %d ms) before start of current frame (%d ms) - skipping\\n\", line, ctx->end, ctx->start));", "continue;", "}", "if (ctx->start && ctx->first_samp) {", "samp = gf_isom_new_text_sample();", "txtin_process_send_text_sample(ctx, samp, 0, (u32) (ts_scale*ctx->start), GF_TRUE);", "ctx->first_samp = GF_FALSE;", "gf_isom_delete_text_sample(samp);", "}", "for (i=j; i<len; i++) {", "if (szLine[i]=='|') {", "szText[i-j] = '\\n';", "} else {", "szText[i-j] = szLine[i];", "}", "}", "szText[i-j] = 0;", "if (ctx->prev_end) {", "samp = gf_isom_new_text_sample();", "txtin_process_send_text_sample(ctx, samp, (u64) (ts_scale*(s64)ctx->prev_end), (u32) (ts_scale*(ctx->start - ctx->prev_end)), GF_TRUE);", "gf_isom_delete_text_sample(samp);", "}", "samp = gf_isom_new_text_sample();", "gf_isom_text_add_text(samp, szText, (u32) strlen(szText) );", "txtin_process_send_text_sample(ctx, samp, (u64) (ts_scale*(s64)ctx->start), (u32) (ts_scale*(ctx->end - ctx->start)), GF_TRUE);", "gf_isom_delete_text_sample(samp);", "ctx->prev_end = ctx->end;", "gf_filter_pid_set_info(ctx->opid, GF_PROP_PID_DOWN_BYTES, &PROP_LONGUINT( gf_ftell(ctx->src )) );", "if (gf_filter_pid_would_block(ctx->opid))", "return GF_OK;", "}", "if (ctx->end && !ctx->noflush) {", "samp = gf_isom_new_text_sample();", "txtin_process_send_text_sample(ctx, samp, (u64) (ts_scale*(s64)ctx->end), 0, GF_TRUE);", "gf_isom_delete_text_sample(samp);", "}", "gf_filter_pid_set_info_str( ctx->opid, \"ttxt:last_dur\", &PROP_UINT(0) );", "return GF_EOS;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["PackLinuxElf64::canPack()", "{", "union {", "unsigned char buf[sizeof(Elf64_Ehdr) + 14*sizeof(Elf64_Phdr)];", "} u;", "COMPILE_TIME_ASSERT(sizeof(u) <= 1024)", "fi->readx(u.buf, sizeof(u.buf));", "fi->seek(0, SEEK_SET);", "Elf64_Ehdr const *const ehdr = (Elf64_Ehdr *) u.buf;", "if (checkEhdr(ehdr) != 0)", "return false;", "if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) {", "throwCantPack(\"invalid Ehdr e_ehsize; try '--force-execve'\");", "return false;", "}", "if (e_phoff != sizeof(*ehdr)) {", "throwCantPack(\"non-contiguous Ehdr/Phdr; try '--force-execve'\");", "return false;", "}", "Elf64_Phdr const *phdr = phdri;", "for (unsigned j=0; j < e_phnum; ++phdr, ++j) {", "if (j >= 14) {", "throwCantPack(\"too many ElfXX_Phdr; try '--force-execve'\");", "return false;", "}", "unsigned const p_type = get_te32(&phdr->p_type);", "if (1!=exetype && PT_LOAD64 == p_type) {", "exetype = 1;", "load_va = get_te64(&phdr->p_vaddr);", "upx_uint64_t const p_offset = get_te64(&phdr->p_offset);", "upx_uint64_t const off = ~page_mask & load_va;", "if (off && off == p_offset) {", "throwCantPack(\"Go-language PT_LOAD: try hemfix.c, or try '--force-execve'\");", "return false;", "}", "if (0 != p_offset) {", "throwCantPack(\"first PT_LOAD.p_offset != 0; try '--force-execve'\");", "return false;", "}", "hatch_off = ~3ul & (3+ get_te64(&phdr->p_memsz));", "break;", "}", "}", "if (Elf64_Ehdr::ET_DYN==get_te16(&ehdr->e_type)) {", "alloc_file_image(file_image, file_size);", "fi->seek(0, SEEK_SET);", "fi->readx(file_image, file_size);", "memcpy(&ehdri, ehdr, sizeof(Elf64_Ehdr));", "phdri= (Elf64_Phdr *)((size_t)e_phoff + file_image);", "shdri= (Elf64_Shdr *)((size_t)e_shoff + file_image);", "sec_strndx = NULL;", "shstrtab = NULL;", "if (e_shnum) {", "unsigned const e_shstrndx = get_te16(&ehdr->e_shstrndx);", "if (e_shstrndx) {", "if (e_shnum <= e_shstrndx) {", "char msg[40]; snprintf(msg, sizeof(msg),", "\"bad e_shstrndx %#x >= e_shnum %d\", e_shstrndx, e_shnum);", "throwCantPack(msg);", "}", "sec_strndx = &shdri[e_shstrndx];", "upx_uint64_t sh_offset = get_te64(&sec_strndx->sh_offset);", "if ((u64_t)file_size <= sh_offset) {", "char msg[50]; snprintf(msg, sizeof(msg),", "\"bad .e_shstrndx->sh_offset %#lx\", (long unsigned)sh_offset);", "throwCantPack(msg);", "}", "shstrtab = (char const *)(sh_offset + file_image);", "}", "sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM);", "if (sec_dynsym) {", "upx_uint64_t const sh_link = get_te64(&sec_dynsym->sh_link);", "if (e_shnum <= sh_link) {", "char msg[50]; snprintf(msg, sizeof(msg),", "\"bad SHT_DYNSYM.sh_link %#lx\", (long unsigned)sh_link);", "}", "sec_dynstr = &shdri[sh_link];", "}", "if (sec_strndx) {", "unsigned const sh_name = get_te32(&sec_strndx->sh_name);", "if (Elf64_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type)", "|| (u32_t)file_size <= sh_name", "|| (sh_name", "&& 0!=strcmp((char const *)\".shstrtab\", &shstrtab[sh_name]))", ") {", "throwCantPack(\"bad e_shstrndx\");", "}", "}", "}", "Elf64_Phdr const *pload_x0(0);", "phdr= phdri;", "for (int j= e_phnum; --j>=0; ++phdr)", "if (Elf64_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {", "dynseg= (Elf64_Dyn const *)(check_pt_dynamic(phdr) + file_image);", "invert_pt_dynamic(dynseg);", "}", "else if (PT_LOAD64==get_te32(&phdr->p_type)) {", "if (!pload_x0", "&&  Elf32_Phdr::PF_X & get_te32(&phdr->p_flags)", ") {", "pload_x0 = phdr;", "}", "check_pt_load(phdr);", "}", "dynstr=          (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);", "dynsym=     (Elf64_Sym const *)elf_find_dynamic(Elf64_Dyn::DT_SYMTAB);", "if (opt->o_unix.force_pie", "||       Elf64_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf64_Dyn::DT_FLAGS_1)", "||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_RELA),", "(int)elf_unsigned_dynamic(Elf64_Dyn::DT_RELASZ))", "||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_JMPREL),", "(int)elf_unsigned_dynamic(Elf64_Dyn::DT_PLTRELSZ))) {", "is_pie = true;", "goto proceed;", "}", "if (elf_find_dynamic(upx_dt_init)) {", "if (elf_has_dynamic(Elf64_Dyn::DT_TEXTREL)) {", "throwCantPack(\"DT_TEXTREL found; re-compile with -fPIC\");", "goto abandon;", "}", "if (!(Elf64_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf64_Dyn::DT_FLAGS_1))) {", "if (Elf64_Ehdr::EM_AARCH64 == e_machine", "&&  !opt->o_unix.android_shlib", ") {", "opt->info_mode++;", "info(\"note: use --android-shlib if appropriate\");", "opt->info_mode--;", "}", "}", "Elf64_Shdr const *shdr = shdri;", "xct_va = ~0ull;", "if (e_shnum) {", "for (int j= e_shnum; --j>=0; ++shdr) {", "unsigned const sh_type = get_te32(&shdr->sh_type);", "if (Elf64_Shdr::SHF_EXECINSTR & get_te64(&shdr->sh_flags)) {", "xct_va = umin(xct_va, get_te64(&shdr->sh_addr));", "}", "if ((     Elf64_Dyn::DT_PREINIT_ARRAY==upx_dt_init", "&&  Elf64_Shdr::SHT_PREINIT_ARRAY==sh_type)", "||  (     Elf64_Dyn::DT_INIT_ARRAY   ==upx_dt_init", "&&  Elf64_Shdr::SHT_INIT_ARRAY   ==sh_type) ) {", "unsigned user_init_ava = get_te32(&shdr->sh_addr);", "user_init_off = get_te64(&shdr->sh_offset);", "if ((u64_t)file_size <= user_init_off) {", "char msg[70]; snprintf(msg, sizeof(msg),", "\"bad Elf64_Shdr[%d].sh_offset %#x\",", "-1+ e_shnum - j, user_init_off);", "throwCantPack(msg);", "}", "int z_rel = dt_table[Elf64_Dyn::DT_RELA];", "int z_rsz = dt_table[Elf64_Dyn::DT_RELASZ];", "if (z_rel && z_rsz) {", "unsigned rel_off = get_te64(&dynseg[-1+ z_rel].d_val);", "Elf64_Rela *rp = (Elf64_Rela *)&file_image[rel_off];", "unsigned relsz   = get_te64(&dynseg[-1+ z_rsz].d_val);", "Elf64_Rela *last = (Elf64_Rela *)(relsz + (char *)rp);", "for (; rp < last; ++rp) {", "unsigned r_va = get_te64(&rp->r_offset);", "if (r_va == user_init_ava) {", "unsigned r_info = get_te64(&rp->r_info);", "unsigned r_type = ELF64_R_TYPE(r_info);", "if (Elf64_Ehdr::EM_AARCH64 == e_machine", "&&  R_AARCH64_RELATIVE == r_type) {", "user_init_va = get_te64(&rp->r_addend);", "}", "else if (Elf64_Ehdr::EM_AARCH64 == e_machine", "&&  R_AARCH64_ABS64 == r_type) {", "user_init_va = get_te64(&file_image[user_init_off]);", "}", "else {", "char msg[50]; snprintf(msg, sizeof(msg),", "\"bad relocation %#x DT_INIT_ARRAY[0]\",", "r_info);", "throwCantPack(msg);", "}", "break;", "}", "}", "}", "unsigned const p_filesz = get_te64(&pload_x0->p_filesz);", "if (!((user_init_va - xct_va) < p_filesz)) {", "if (0==user_init_va && opt->o_unix.android_shlib) {", "upx_dt_init = 0;", "}", "else {", "char msg[70]; snprintf(msg, sizeof(msg),", "\"bad init address %#x in Elf64_Shdr[%d].%#x\\n\",", "(unsigned)user_init_va, -1+ e_shnum - j, user_init_off);", "throwCantPack(msg);", "}", "}", "}", "if ((Elf64_Dyn::DT_INIT==upx_dt_init || !upx_dt_init)", "&&  Elf64_Shdr::SHT_DYNAMIC == sh_type) {", "unsigned const n = get_te64(&shdr->sh_size) / sizeof(Elf64_Dyn);", "Elf64_Dyn *dynp = (Elf64_Dyn *)&file_image[get_te64(&shdr->sh_offset)];", "for (; Elf64_Dyn::DT_NULL != dynp->d_tag; ++dynp) {", "if (upx_dt_init == get_te64(&dynp->d_tag)) {", "break;", "}", "}", "if ((1+ dynp) < (n+ dynseg)) {", "user_init_va = get_te64(&dynp->d_val);", "set_te64(&dynp->d_tag, upx_dt_init = Elf64_Dyn::DT_INIT);", "user_init_off = (char const *)&dynp->d_val - (char const *)&file_image[0];", "}", "}", "}", "}", "else {", "upx_uint64_t const strsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_STRSZ);", "upx_uint64_t const strtab = elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB);", "upx_uint64_t const relsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_RELSZ);", "upx_uint64_t const rel    = elf_unsigned_dynamic(Elf64_Dyn::DT_REL);", "upx_uint64_t const init   = elf_unsigned_dynamic(upx_dt_init);", "if ((init == (relsz + rel   ) && rel    == (strsz + strtab))", "||  (init == (strsz + strtab) && strtab == (relsz + rel   ))", ") {", "xct_va = init;", "user_init_va = init;", "user_init_off = elf_get_offset_from_address(init);", "}", "}", "upx_uint64_t const va_gash = elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH);", "upx_uint64_t const va_hash = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH);", "unsigned y = 0;", "if ((y=1, xct_va < va_gash)  ||  (y=2, (0==va_gash && xct_va < va_hash))", "||  (y=3, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB))", "||  (y=4, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_SYMTAB))", "||  (y=5, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_REL))", "||  (y=6, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_RELA))", "||  (y=7, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_JMPREL))", "||  (y=8, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERDEF))", "||  (y=9, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERSYM))", "||  (y=10, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERNEEDED)) ) {", "static char const *which[] = {", "\"unknown\",", "\"DT_GNU_HASH\",", "\"DT_HASH\",", "\"DT_STRTAB\",", "\"DT_SYMTAB\",", "\"DT_REL\",", "\"DT_RELA\",", "\"DT_JMPREL\",", "\"DT_VERDEF\",", "\"DT_VERSYM\",", "\"DT_VERNEEDED\",", "};", "char buf[30]; snprintf(buf, sizeof(buf), \"%s above stub\", which[y]);", "throwCantPack(buf);", "goto abandon;", "}", "if (!opt->o_unix.android_shlib) {", "phdr = phdri;", "for (unsigned j= 0; j < e_phnum; ++phdr, ++j) {", "upx_uint64_t const vaddr = get_te64(&phdr->p_vaddr);", "if (PT_NOTE64 == get_te32(&phdr->p_type)", "&& xct_va < vaddr) {", "char buf[40]; snprintf(buf, sizeof(buf),", "\"PT_NOTE %#lx above stub\", (unsigned long)vaddr);", "throwCantPack(buf);", "goto abandon;", "}", "}", "}", "xct_off = elf_get_offset_from_address(xct_va);", "if (opt->debug.debug_level) {", "fprintf(stderr, \"shlib canPack: xct_va=%#lx  xct_off=%#lx\\n\",", "(long)xct_va, (long)xct_off);", "}", "goto proceed;", "}", "else", "throwCantPack(\"need DT_INIT; try \\\"void _init(void){}\\\"\");", "abandon:", "return false;", "proceed: ;", "}", "if (!super::canPack())", "return false;", "assert(exetype == 1);", "exetype = 0;", "opt->o_unix.blocksize = blocksize = file_size;", "return true;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["int data_on_connection(int fd, callback_remove_handler remove)", "{", "int nread;", "char *network_packet;", "char network_line[8192];", "char *p;", "unsigned long id;", "char string[1024];", "unsigned long msg_id = UINT32_MAX;", "enum network_protocol version = network_client_get_version(fd);", "ioctl(fd, FIONREAD, &nread);", "univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"new connection data = %d\\n\",nread);", "if(nread == 0)", "{", "univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_PROCESS, \"%d failed, got 0 close connection to listener \", fd);", "close(fd);", "FD_CLR(fd, &readfds);", "remove(fd);", "network_client_dump ();", "return 0;", "}", "if ( nread >= 8192 ) {", "univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ERROR, \"%d failed, more than 8192 close connection to listener \", fd);", "close(fd);", "FD_CLR(fd, &readfds);", "remove(fd);", "return 0;", "}", "network_packet=malloc((nread+1) * sizeof(char));", "read(fd, network_packet, nread);", "network_packet[nread]='\\0';", "memset(network_line, 0, 8192);", "p=network_packet;", "p_sem(sem_id);", "while ( get_network_line(p, network_line) ) {", "if ( strlen(network_line) > 0 ) {", "univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"line = [%s]\",network_line);", "}", "if ( !strncmp(network_line, \"MSGID: \", strlen(\"MSGID: \")) ) {", "msg_id=strtoul(&(network_line[strlen(\"MSGID: \")]), NULL, 10);", "p+=strlen(network_line);", "} else if ( !strncmp(network_line, \"Version: \", strlen(\"Version: \")) ) {", "char *head = network_line, *end;", "univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"RECV: VERSION\");", "version = strtoul(head + 9, &end, 10);", "if (!head[9] || *end)", "goto failed;", "univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"VERSION=%d\", version);", "if (version < network_procotol_version) {", "univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_PROCESS, \"Forbidden VERSION=%d < %d, close connection to listener\", version, network_procotol_version);", "goto close;", "} else if (version >= PROTOCOL_LAST) {", "univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_PROCESS, \"Future VERSION=%d\", version);", "version = PROTOCOL_LAST - 1;", "}", "network_client_set_version(fd, version);", "msg_id = UINT32_MAX;", "p+=strlen(network_line);", "} else if ( !strncmp(network_line, \"Capabilities: \", strlen(\"Capabilities: \")) ) {", "univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"RECV: Capabilities\");", "if ( version > PROTOCOL_UNKNOWN ) {", "memset(string, 0, sizeof(string));", "snprintf(string, sizeof(string), \"Version: %d\\nCapabilities: \\n\\n\", version);", "univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"SEND: %s\", string);", "write(fd, string, strlen(string));", "} else {", "univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"Capabilities recv, but no version line\");", "}", "p+=strlen(network_line);", "} else if ( !strncmp(network_line, \"GET_DN \", strlen(\"GET_DN \")) && msg_id != UINT32_MAX && network_client_get_version(fd) > 0) {", "univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"RECV: GET_DN\");", "id=strtoul(&(network_line[strlen(\"GET_DN \")]), NULL, 10);", "univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"id: %ld\",id);", "if ( id <= notify_last_id.id) {", "char *dn_string = NULL;", "univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"try to read %ld from cache\", id);", "if ( (dn_string = notifier_cache_get(id)) == NULL ) {", "univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"%ld not found in cache\", id);", "univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"%ld get one dn\", id);", "if( (dn_string=notify_transcation_get_one_dn ( id )) == NULL ) {", "univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"%ld failed \", id);", "univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ERROR, \"%d failed, close connection to listener \", fd);", "close(fd);", "FD_CLR(fd, &readfds);", "remove(fd);", "return 0;", "}", "}", "if ( dn_string != NULL ) {", "snprintf(string, sizeof(string), \"MSGID: %ld\\n%s\\n\\n\",msg_id,dn_string);", "univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"--> %d: [%s]\",fd, string);", "write(fd, string, strlen(string));", "free(dn_string);", "}", "} else {", "network_client_set_next_id(fd, id);", "network_client_set_msg_id(fd, msg_id);", "}", "p+=strlen(network_line)+1;", "msg_id = UINT32_MAX;", "} else if (!strncmp(p, \"WAIT_ID \", 8) && msg_id != UINT32_MAX && version >= PROTOCOL_3) {", "char *head = network_line, *end;", "univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"RECV: WAIT_ID\");", "id = strtoul(head + 8, &end, 10);", "if (!head[8] || *end)", "goto failed;", "univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"id: %ld\", id);", "if (id <= notify_last_id.id) {", "snprintf(string, sizeof(string), \"MSGID: %ld\\n%ld\\n\\n\", msg_id, notify_last_id.id);", "write(fd, string, strlen(string));", "} else {", "network_client_set_next_id(fd, id);", "network_client_set_msg_id(fd, msg_id);", "}", "p += strlen(network_line) + 1;", "msg_id = UINT32_MAX;", "} else if ( !strncmp(network_line, \"GET_ID\", strlen(\"GET_ID\")) && msg_id != UINT32_MAX  && network_client_get_version(fd) > 0) {", "univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"RECV: GET_ID\");", "memset(string, 0, sizeof(string));", "snprintf(string, sizeof(string), \"MSGID: %ld\\n%ld\\n\\n\",msg_id,notify_last_id.id);", "write(fd, string, strlen(string));", "p+=strlen(network_line)+1;", "msg_id = UINT32_MAX;", "} else if ( !strncmp(network_line, \"GET_SCHEMA_ID\", strlen(\"GET_SCHEMA_ID\")) && msg_id != UINT32_MAX  && network_client_get_version(fd) > 0) {", "univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"RECV: GET_SCHEMA_ID\");", "memset(string, 0, sizeof(string));", "snprintf(string, sizeof(string), \"MSGID: %ld\\n%ld\\n\\n\",msg_id,SCHEMA_ID);", "univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"--> %d: [%s]\",fd, string);", "write(fd, string, strlen(string));", "p+=strlen(network_line)+1;", "msg_id = UINT32_MAX;", "} else if ( !strncmp(network_line, \"ALIVE\", strlen(\"ALIVE\")) && msg_id != UINT32_MAX  && network_client_get_version(fd) > 0) {", "univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"RECV: ALIVE\");", "snprintf(string, sizeof(string), \"MSGID: %ld\\nOKAY\\n\\n\",msg_id);", "write(fd, string, strlen(string));", "p+=strlen(network_line)+1;", "msg_id = UINT32_MAX;", "} else {", "p+=strlen(network_line);", "if (strlen(network_line) == 0 ) {", "p+=1;", "} else {", "univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ERROR, \"Drop package [%s]\", network_line);", "}", "}", "}", "v_sem(sem_id);", "univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"END Package\");", "network_client_dump ();", "return 0;", "failed:", "univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_PROCESS, \"Failed parsing [%s]\", p);", "close:", "close(fd);", "FD_CLR(fd, &readfds);", "remove(fd);", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int lookupName(", "Parse *pParse,", "const char *zDb,", "const char *zTab,", "const char *zCol,", "NameContext *pNC,", "Expr *pExpr", "){", "int i, j;", "int cnt = 0;", "int cntTab = 0;", "int nSubquery = 0;", "sqlite3 *db = pParse->db;", "struct SrcList_item *pItem;", "struct SrcList_item *pMatch = 0;", "NameContext *pTopNC = pNC;", "Schema *pSchema = 0;", "int eNewExprOp = TK_COLUMN;", "Table *pTab = 0;", "Column *pCol;", "assert( pNC );", "assert( zCol );", "assert( !ExprHasProperty(pExpr, EP_TokenOnly|EP_Reduced) );", "pExpr->iTable = -1;", "ExprSetVVAProperty(pExpr, EP_NoReduce);", "if( zDb ){", "testcase( pNC->ncFlags & NC_PartIdx );", "testcase( pNC->ncFlags & NC_IsCheck );", "if( (pNC->ncFlags & (NC_PartIdx|NC_IsCheck))!=0 ){", "zDb = 0;", "}else{", "for(i=0; i<db->nDb; i++){", "assert( db->aDb[i].zDbSName );", "if( sqlite3StrICmp(db->aDb[i].zDbSName,zDb)==0 ){", "pSchema = db->aDb[i].pSchema;", "break;", "}", "}", "}", "}", "assert( pNC && cnt==0 );", "do{", "ExprList *pEList;", "SrcList *pSrcList = pNC->pSrcList;", "if( pSrcList ){", "for(i=0, pItem=pSrcList->a; i<pSrcList->nSrc; i++, pItem++){", "pTab = pItem->pTab;", "assert( pTab!=0 && pTab->zName!=0 );", "assert( pTab->nCol>0 );", "if( pItem->pSelect && (pItem->pSelect->selFlags & SF_NestedFrom)!=0 ){", "int hit = 0;", "pEList = pItem->pSelect->pEList;", "for(j=0; j<pEList->nExpr; j++){", "if( sqlite3MatchSpanName(pEList->a[j].zSpan, zCol, zTab, zDb) ){", "cnt++;", "cntTab = 2;", "pMatch = pItem;", "pExpr->iColumn = j;", "hit = 1;", "}", "}", "if( hit || zTab==0 ) continue;", "}", "if( zDb && pTab->pSchema!=pSchema ){", "continue;", "}", "if( zTab ){", "const char *zTabName = pItem->zAlias ? pItem->zAlias : pTab->zName;", "assert( zTabName!=0 );", "if( sqlite3StrICmp(zTabName, zTab)!=0 ){", "continue;", "}", "if( IN_RENAME_OBJECT && pItem->zAlias ){", "sqlite3RenameTokenRemap(pParse, 0, (void*)&pExpr->y.pTab);", "}", "}", "if( 0==(cntTab++) ){", "pMatch = pItem;", "}", "for(j=0, pCol=pTab->aCol; j<pTab->nCol; j++, pCol++){", "if( sqlite3StrICmp(pCol->zName, zCol)==0 ){", "if( cnt==1 ){", "if( pItem->fg.jointype & JT_NATURAL ) continue;", "if( nameInUsingClause(pItem->pUsing, zCol) ) continue;", "}", "cnt++;", "pMatch = pItem;", "pExpr->iColumn = j==pTab->iPKey ? -1 : (i16)j;", "break;", "}", "}", "}", "if( pMatch ){", "pExpr->iTable = pMatch->iCursor;", "pExpr->y.pTab = pMatch->pTab;", "assert( (pMatch->fg.jointype & JT_RIGHT)==0 );", "if( (pMatch->fg.jointype & JT_LEFT)!=0 ){", "ExprSetProperty(pExpr, EP_CanBeNull);", "}", "pSchema = pExpr->y.pTab->pSchema;", "}", "}", "#if !defined(SQLITE_OMIT_TRIGGER) || !defined(SQLITE_OMIT_UPSERT)", "if( zDb==0 && zTab!=0 && cntTab==0 ){", "pTab = 0;", "#ifndef SQLITE_OMIT_TRIGGER", "if( pParse->pTriggerTab!=0 ){", "int op = pParse->eTriggerOp;", "assert( op==TK_DELETE || op==TK_UPDATE || op==TK_INSERT );", "if( op!=TK_DELETE && sqlite3StrICmp(\"new\",zTab) == 0 ){", "pExpr->iTable = 1;", "pTab = pParse->pTriggerTab;", "}else if( op!=TK_INSERT && sqlite3StrICmp(\"old\",zTab)==0 ){", "pExpr->iTable = 0;", "pTab = pParse->pTriggerTab;", "}", "}", "#endif /* SQLITE_OMIT_TRIGGER */", "#ifndef SQLITE_OMIT_UPSERT", "if( (pNC->ncFlags & NC_UUpsert)!=0 ){", "Upsert *pUpsert = pNC->uNC.pUpsert;", "if( pUpsert && sqlite3StrICmp(\"excluded\",zTab)==0 ){", "pTab = pUpsert->pUpsertSrc->a[0].pTab;", "pExpr->iTable = 2;", "}", "}", "#endif /* SQLITE_OMIT_UPSERT */", "if( pTab ){", "int iCol;", "pSchema = pTab->pSchema;", "cntTab++;", "for(iCol=0, pCol=pTab->aCol; iCol<pTab->nCol; iCol++, pCol++){", "if( sqlite3StrICmp(pCol->zName, zCol)==0 ){", "if( iCol==pTab->iPKey ){", "iCol = -1;", "}", "break;", "}", "}", "if( iCol>=pTab->nCol && sqlite3IsRowid(zCol) && VisibleRowid(pTab) ){", "iCol = -1;", "}", "if( iCol<pTab->nCol ){", "cnt++;", "#ifndef SQLITE_OMIT_UPSERT", "if( pExpr->iTable==2 ){", "testcase( iCol==(-1) );", "if( IN_RENAME_OBJECT ){", "pExpr->iColumn = iCol;", "pExpr->y.pTab = pTab;", "eNewExprOp = TK_COLUMN;", "}else{", "pExpr->iTable = pNC->uNC.pUpsert->regData + iCol;", "eNewExprOp = TK_REGISTER;", "ExprSetProperty(pExpr, EP_Alias);", "}", "}else", "#endif /* SQLITE_OMIT_UPSERT */", "{", "#ifndef SQLITE_OMIT_TRIGGER", "if( iCol<0 ){", "pExpr->affExpr = SQLITE_AFF_INTEGER;", "}else if( pExpr->iTable==0 ){", "testcase( iCol==31 );", "testcase( iCol==32 );", "pParse->oldmask |= (iCol>=32 ? 0xffffffff : (((u32)1)<<iCol));", "}else{", "testcase( iCol==31 );", "testcase( iCol==32 );", "pParse->newmask |= (iCol>=32 ? 0xffffffff : (((u32)1)<<iCol));", "}", "pExpr->y.pTab = pTab;", "pExpr->iColumn = (i16)iCol;", "eNewExprOp = TK_TRIGGER;", "#endif /* SQLITE_OMIT_TRIGGER */", "}", "}", "}", "}", "#endif /* !defined(SQLITE_OMIT_TRIGGER) || !defined(SQLITE_OMIT_UPSERT) */", "if( cnt==0", "&& cntTab==1", "&& pMatch", "&& (pNC->ncFlags & (NC_IdxExpr|NC_GenCol))==0", "&& sqlite3IsRowid(zCol)", "&& VisibleRowid(pMatch->pTab)", "){", "cnt = 1;", "pExpr->iColumn = -1;", "pExpr->affExpr = SQLITE_AFF_INTEGER;", "}", "if( (pNC->ncFlags & NC_UEList)!=0", "&& cnt==0", "&& zTab==0", "){", "pEList = pNC->uNC.pEList;", "assert( pEList!=0 );", "for(j=0; j<pEList->nExpr; j++){", "char *zAs = pEList->a[j].zName;", "if( zAs!=0 && sqlite3StrICmp(zAs, zCol)==0 ){", "Expr *pOrig;", "assert( pExpr->pLeft==0 && pExpr->pRight==0 );", "assert( pExpr->x.pList==0 );", "assert( pExpr->x.pSelect==0 );", "pOrig = pEList->a[j].pExpr;", "if( (pNC->ncFlags&NC_AllowAgg)==0 && ExprHasProperty(pOrig, EP_Agg) ){", "sqlite3ErrorMsg(pParse, \"misuse of aliased aggregate %s\", zAs);", "return WRC_Abort;", "}", "if( (pNC->ncFlags&NC_AllowWin)==0 && ExprHasProperty(pOrig, EP_Win) ){", "sqlite3ErrorMsg(pParse, \"misuse of aliased window function %s\",zAs);", "return WRC_Abort;", "}", "if( sqlite3ExprVectorSize(pOrig)!=1 ){", "sqlite3ErrorMsg(pParse, \"row value misused\");", "return WRC_Abort;", "}", "resolveAlias(pParse, pEList, j, pExpr, \"\", nSubquery);", "cnt = 1;", "pMatch = 0;", "assert( zTab==0 && zDb==0 );", "if( IN_RENAME_OBJECT ){", "sqlite3RenameTokenRemap(pParse, 0, (void*)pExpr);", "}", "goto lookupname_end;", "}", "}", "}", "if( cnt ) break;", "pNC = pNC->pNext;", "nSubquery++;", "}while( pNC );", "if( cnt==0 && zTab==0 ){", "assert( pExpr->op==TK_ID );", "if( ExprHasProperty(pExpr,EP_DblQuoted)", "&& areDoubleQuotedStringsEnabled(db, pTopNC)", "){", "sqlite3_log(SQLITE_WARNING,", "\"double-quoted string literal: \\\"%w\\\"\", zCol);", "#ifdef SQLITE_ENABLE_NORMALIZE", "sqlite3VdbeAddDblquoteStr(db, pParse->pVdbe, zCol);", "#endif", "pExpr->op = TK_STRING;", "pExpr->y.pTab = 0;", "return WRC_Prune;", "}", "if( sqlite3ExprIdToTrueFalse(pExpr) ){", "return WRC_Prune;", "}", "}", "if( cnt!=1 ){", "const char *zErr;", "zErr = cnt==0 ? \"no such column\" : \"ambiguous column name\";", "if( zDb ){", "sqlite3ErrorMsg(pParse, \"%s: %s.%s.%s\", zErr, zDb, zTab, zCol);", "}else if( zTab ){", "sqlite3ErrorMsg(pParse, \"%s: %s.%s\", zErr, zTab, zCol);", "}else{", "sqlite3ErrorMsg(pParse, \"%s: %s\", zErr, zCol);", "}", "pParse->checkSchema = 1;", "pTopNC->nErr++;", "}", "if( pExpr->iColumn>=0 && pMatch!=0 ){", "int n = pExpr->iColumn;", "testcase( n==BMS-1 );", "if( n>=BMS ){", "n = BMS-1;", "}", "assert( pMatch->iCursor==pExpr->iTable );", "pMatch->colUsed |= ((Bitmask)1)<<n;", "}", "sqlite3ExprDelete(db, pExpr->pLeft);", "pExpr->pLeft = 0;", "sqlite3ExprDelete(db, pExpr->pRight);", "pExpr->pRight = 0;", "pExpr->op = eNewExprOp;", "ExprSetProperty(pExpr, EP_Leaf);", "lookupname_end:", "if( cnt==1 ){", "assert( pNC!=0 );", "if( !ExprHasProperty(pExpr, EP_Alias) ){", "sqlite3AuthRead(pParse, pExpr, pSchema, pNC->pSrcList);", "}", "for(;;){", "assert( pTopNC!=0 );", "pTopNC->nRef++;", "if( pTopNC==pNC ) break;", "pTopNC = pTopNC->pNext;", "}", "return WRC_Prune;", "} else {", "return WRC_Abort;", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void APar_ExtractDetails(FILE *isofile, uint8_t optional_output) {", "char uint32_buffer[5];", "Trackage track = {0};", "AtomicInfo *mvhdAtom = APar_FindAtom(\"moov.mvhd\", false, VERSIONED_ATOM, 0);", "if (mvhdAtom != NULL) {", "APar_ExtractMovieDetails(uint32_buffer, isofile, mvhdAtom);", "fprintf(stdout,", "\"Movie duration: %.3lf seconds (%s) - %.2lf* kbp/sec bitrate \"", "\"(*=approximate)\\n\",", "movie_info.seconds,", "secsTOtime(movie_info.seconds),", "movie_info.simple_bitrate_calc);", "if (optional_output & SHOW_DATE_INFO) {", "fprintf(stdout,", "\"  Presentation Creation Date (UTC):     %s\\n\",", "APar_extract_UTC(movie_info.creation_time));", "fprintf(stdout,", "\"  Presentation Modification Date (UTC): %s\\n\",", "APar_extract_UTC(movie_info.modified_time));", "}", "}", "AtomicInfo *iodsAtom = APar_FindAtom(\"moov.iods\", false, VERSIONED_ATOM, 0);", "if (iodsAtom != NULL) {", "movie_info.contains_iods = true;", "APar_Extract_iods_Info(isofile, iodsAtom);", "}", "if (optional_output & SHOW_TRACK_INFO) {", "APar_TrackLevelInfo(&track,", "NULL);", "fprintf(", "stdout, \"Low-level details. Total tracks: %u\\n\", track.total_tracks);", "fprintf(stdout,", "\"Trk  Type  Handler                    Kind  Lang  Bytes\\n\");", "if (track.total_tracks > 0) {", "while (track.total_tracks > track.track_num) {", "track.track_num += 1;", "TrackInfo track_info = {0};", "APar_ExtractTrackDetails(uint32_buffer, isofile, &track, &track_info);", "uint16_t more_whitespace =", "purge_extraneous_characters(track_info.track_hdlr_name);", "if (strlen(track_info.track_hdlr_name) == 0) {", "memcpy(track_info.track_hdlr_name, \"[none listed]\", 13);", "}", "fprintf(stdout,", "\"%u    %s  %s\",", "track.track_num,", "uint32tochar4(track_info.track_type, uint32_buffer),", "track_info.track_hdlr_name);", "uint16_t handler_len = strlen(track_info.track_hdlr_name);", "if (handler_len < 25 + more_whitespace) {", "for (uint16_t i = handler_len; i < 25 + more_whitespace; i++) {", "fprintf(stdout, \" \");", "}", "}", "fprintf(stdout,", "\"  %s  %s   %\" PRIu64,", "uint32tochar4(track_info.track_codec, uint32_buffer),", "track_info.unpacked_lang,", "track_info.sample_aggregate);", "if (track_info.encoder_name[0] != 0 && track_info.contains_esds) {", "purge_extraneous_characters(track_info.encoder_name);", "fprintf(stdout, \"   Encoder: %s\", track_info.encoder_name);", "}", "if (track_info.type_of_track & DRM_PROTECTED_TRACK) {", "fprintf(stdout,", "\" (protected %s)\",", "uint32tochar4(track_info.protected_codec, uint32_buffer));", "}", "fprintf(stdout, \"\\n\");", "if (track_info.type_of_track & VIDEO_TRACK ||", "track_info.type_of_track & AUDIO_TRACK) {", "APar_Print_TrackDetails(&track_info);", "}", "if (optional_output & SHOW_DATE_INFO) {", "fprintf(stdout,", "\"       Creation Date (UTC):     %s\\n\",", "APar_extract_UTC(track_info.creation_time));", "fprintf(stdout,", "\"       Modification Date (UTC): %s\\n\",", "APar_extract_UTC(track_info.modified_time));", "}", "}", "}", "}", "}"], "ner_tags": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["GF_Err audio_sample_entry_Read(GF_Box *s, GF_BitStream *bs)", "{", "GF_MPEGAudioSampleEntryBox *ptr;", "char *data;", "u8 a, b, c, d;", "u32 i, size, v, nb_alnum;", "GF_Err e;", "u64 pos, start;", "ptr = (GF_MPEGAudioSampleEntryBox *)s;", "start = gf_bs_get_position(bs);", "gf_bs_seek(bs, start + 8);", "v = gf_bs_read_u16(bs);", "if (v)", "ptr->is_qtff = 1;", "if (v==1) {", "gf_bs_seek(bs, start + 8 + 20  + 4);", "a = gf_bs_read_u8(bs);", "b = gf_bs_read_u8(bs);", "c = gf_bs_read_u8(bs);", "d = gf_bs_read_u8(bs);", "nb_alnum = 0;", "if (isalnum(a)) nb_alnum++;", "if (isalnum(b)) nb_alnum++;", "if (isalnum(c)) nb_alnum++;", "if (isalnum(d)) nb_alnum++;", "if (nb_alnum>2) ptr->is_qtff = 0;", "}", "gf_bs_seek(bs, start);", "e = gf_isom_audio_sample_entry_read((GF_AudioSampleEntryBox*)s, bs);", "if (e) return e;", "pos = gf_bs_get_position(bs);", "size = (u32) s->size;", "if (gf_bs_get_cookie(bs)) {", "ptr->is_qtff |= 1<<16;", "}", "e = gf_isom_box_array_read(s, bs, audio_sample_entry_AddBox);", "if (!e) return GF_OK;", "if (size<8) return GF_ISOM_INVALID_FILE;", "gf_bs_seek(bs, pos);", "data = (char*)gf_malloc(sizeof(char) * size);", "gf_bs_read_data(bs, data, size);", "for (i=0; i<size-8; i++) {", "if (GF_4CC((u32)data[i+4], (u8)data[i+5], (u8)data[i+6], (u8)data[i+7]) == GF_ISOM_BOX_TYPE_ESDS) {", "GF_BitStream *mybs = gf_bs_new(data + i, size - i, GF_BITSTREAM_READ);", "if (ptr->esd) {", "gf_isom_box_del((GF_Box *)ptr->esd);", "ptr->esd=NULL;", "}", "e = gf_isom_box_parse((GF_Box **)&ptr->esd, mybs);", "if (e==GF_OK) {", "gf_isom_box_add_for_dump_mode((GF_Box*)ptr, (GF_Box*)ptr->esd);", "} else if (ptr->esd) {", "gf_isom_box_del((GF_Box *)ptr->esd);", "ptr->esd=NULL;", "}", "gf_bs_del(mybs);", "break;", "}", "}", "gf_free(data);", "return e;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static inline void init_keys(at91_aes_key_size_t *key_size,", "unsigned int *cipher_key,", "unsigned int *cmac_key,", "unsigned int *iv)", "{", "#if defined(CONFIG_AES_KEY_SIZE_128)", "*key_size = AT91_AES_KEY_SIZE_128;", "#elif defined(CONFIG_AES_KEY_SIZE_192)", "*key_size = AT91_AES_KEY_SIZE_192;", "#elif defined(CONFIG_AES_KEY_SIZE_256)", "*key_size = AT91_AES_KEY_SIZE_256;", "#else", "#error \"bad AES key size\"", "#endif", "iv[0]  = CONFIG_AES_IV_WORD0;", "iv[1]  = CONFIG_AES_IV_WORD1;", "iv[2]  = CONFIG_AES_IV_WORD2;", "iv[3]  = CONFIG_AES_IV_WORD3;", "cipher_key[0] = CONFIG_AES_CIPHER_KEY_WORD0;", "cmac_key[0] = CONFIG_AES_CMAC_KEY_WORD0;", "cipher_key[1] = CONFIG_AES_CIPHER_KEY_WORD1;", "cmac_key[1] = CONFIG_AES_CMAC_KEY_WORD1;", "cipher_key[2] = CONFIG_AES_CIPHER_KEY_WORD2;", "cmac_key[2] = CONFIG_AES_CMAC_KEY_WORD2;", "cipher_key[3] = CONFIG_AES_CIPHER_KEY_WORD3;", "cmac_key[3] = CONFIG_AES_CMAC_KEY_WORD3;", "#if defined(CONFIG_AES_KEY_SIZE_192) || defined(CONFIG_AES_KEY_SIZE_256)", "cipher_key[4] = CONFIG_AES_CIPHER_KEY_WORD4;", "cmac_key[4] = CONFIG_AES_CMAC_KEY_WORD4;", "cipher_key[5] = CONFIG_AES_CIPHER_KEY_WORD5;", "cmac_key[5] = CONFIG_AES_CMAC_KEY_WORD5;", "#endif", "#if defined(CONFIG_AES_KEY_SIZE_256)", "cipher_key[6] = CONFIG_AES_CIPHER_KEY_WORD6;", "cmac_key[6] = CONFIG_AES_CMAC_KEY_WORD6;", "cipher_key[7] = CONFIG_AES_CIPHER_KEY_WORD7;", "cmac_key[7] = CONFIG_AES_CMAC_KEY_WORD7;", "#endif", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0]}
{"tokens": ["static int cac_read_binary(sc_card_t *card, unsigned int idx,", "unsigned char *buf, size_t count, unsigned long flags)", "{", "cac_private_data_t * priv = CAC_DATA(card);", "int r = 0;", "u8 *val = NULL;", "u8 *cert_ptr;", "size_t val_len;", "size_t len, cert_len;", "u8 cert_type;", "SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);", "if (priv->cached) {", "sc_log(card->ctx,", "\"returning cached value idx=%d count=%\"SC_FORMAT_LEN_SIZE_T\"u\",", "idx, count);", "if (idx > priv->cache_buf_len) {", "LOG_FUNC_RETURN(card->ctx, SC_ERROR_FILE_END_REACHED);", "}", "len = MIN(count, priv->cache_buf_len-idx);", "memcpy(buf, &priv->cache_buf[idx], len);", "LOG_FUNC_RETURN(card->ctx, len);", "}", "sc_log(card->ctx,", "\"clearing cache idx=%d count=%\"SC_FORMAT_LEN_SIZE_T\"u\",", "idx, count);", "free(priv->cache_buf);", "priv->cache_buf = NULL;", "priv->cache_buf_len = 0;", "r = cac_cac1_get_certificate(card, &val, &val_len);", "if (r < 0)", "goto done;", "if (val_len < 1) {", "r = SC_ERROR_INVALID_DATA;", "goto done;", "}", "cert_type = val[0];", "cert_ptr = val + 1;", "cert_len = val_len - 1;", "if ((cert_type & 0x3) == 1) {", "#ifdef ENABLE_ZLIB", "r = sc_decompress_alloc(&priv->cache_buf, &priv->cache_buf_len,", "cert_ptr, cert_len, COMPRESSION_AUTO);", "#else", "sc_log(card->ctx, \"CAC compression not supported, no zlib\");", "r = SC_ERROR_NOT_SUPPORTED;", "#endif", "if (r)", "goto done;", "} else if (cert_len > 0) {", "priv->cache_buf = malloc(cert_len);", "if (priv->cache_buf == NULL) {", "r = SC_ERROR_OUT_OF_MEMORY;", "goto done;", "}", "priv->cache_buf_len = cert_len;", "memcpy(priv->cache_buf, cert_ptr, cert_len);", "}", "priv->cached = 1;", "len = MIN(count, priv->cache_buf_len-idx);", "if (len && priv->cache_buf)", "memcpy(buf, &priv->cache_buf[idx], len);", "r = len;", "done:", "if (val)", "free(val);", "LOG_FUNC_RETURN(card->ctx, r);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["send_ldap_result_ext(", "Slapi_PBlock *pb,", "int err,", "char *matched,", "char *text,", "int nentries,", "struct berval **urls,", "BerElement *ber)", "{", "Slapi_Operation *operation;", "passwdPolicy *pwpolicy = NULL;", "Connection *conn = NULL;", "Slapi_DN *sdn = NULL;", "const char *dn = NULL;", "ber_tag_t tag;", "int flush_ber_element = 1;", "ber_tag_t bind_method = 0;", "int internal_op;", "int i, rc, logit = 0;", "char *pbtext;", "slapi_pblock_get(pb, SLAPI_BIND_METHOD, &bind_method);", "slapi_pblock_get(pb, SLAPI_OPERATION, &operation);", "slapi_pblock_get(pb, SLAPI_CONNECTION, &conn);", "if (text) {", "pbtext = text;", "} else {", "slapi_pblock_get(pb, SLAPI_PB_RESULT_TEXT, &pbtext);", "}", "if (operation == NULL) {", "slapi_log_err(SLAPI_LOG_ERR, \"send_ldap_result_ext\", \"No operation found: slapi_search_internal_set_pb was incomplete (invalid 'base' ?)\\n\");", "return;", "}", "if (operation->o_status == SLAPI_OP_STATUS_RESULT_SENT) {", "return;", "}", "if (ber != NULL) {", "flush_ber_element = 0;", "}", "if (err != LDAP_SUCCESS) {", "if (err == LDAP_INVALID_CREDENTIALS || err == LDAP_INAPPROPRIATE_AUTH || err == LDAP_AUTH_METHOD_NOT_SUPPORTED || err == LDAP_STRONG_AUTH_NOT_SUPPORTED || err == LDAP_STRONG_AUTH_REQUIRED || err == LDAP_CONFIDENTIALITY_REQUIRED || err == LDAP_INSUFFICIENT_ACCESS || err == LDAP_AUTH_UNKNOWN) {", "slapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsSecurityErrors);", "} else if (err != LDAP_REFERRAL && err != LDAP_OPT_REFERRALS && err != LDAP_PARTIAL_RESULTS) {", "slapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsErrors);", "}", "}", "slapi_log_err(SLAPI_LOG_TRACE, \"send_ldap_result_ext\", \"=> %d:%s:%s\\n\", err,", "matched ? matched : \"\", text ? text : \"\");", "switch (operation->o_tag) {", "case LBER_DEFAULT:", "tag = LBER_SEQUENCE;", "break;", "case LDAP_REQ_SEARCH:", "tag = LDAP_RES_SEARCH_RESULT;", "break;", "case LDAP_REQ_DELETE:", "tag = LDAP_RES_DELETE;", "break;", "case LDAP_REFERRAL:", "if (conn && conn->c_ldapversion > LDAP_VERSION2) {", "tag = LDAP_TAG_REFERRAL;", "break;", "}", "default:", "tag = operation->o_tag + 1;", "break;", "}", "internal_op = operation_is_flag_set(operation, OP_FLAG_INTERNAL);", "if ((conn == NULL) || (internal_op)) {", "if (operation->o_result_handler != NULL) {", "operation->o_result_handler(conn, operation, err,", "matched, text, nentries, urls);", "logit = 1;", "}", "goto log_and_return;", "}", "if ((err == LDAP_INVALID_CREDENTIALS) && (bind_method != LDAP_AUTH_SASL)) {", "slapi_pblock_get(pb, SLAPI_TARGET_SDN, &sdn);", "dn = slapi_sdn_get_dn(sdn);", "pwpolicy = new_passwdPolicy(pb, dn);", "if (pwpolicy && (pwpolicy->pw_lockout == 1)) {", "if (update_pw_retry(pb) == LDAP_CONSTRAINT_VIOLATION && !pwpolicy->pw_is_legacy) {", "err = LDAP_CONSTRAINT_VIOLATION;", "text = \"Invalid credentials, you now have exceeded the password retry limit.\";", "}", "}", "}", "if (ber == NULL) {", "if ((ber = der_alloc()) == NULL) {", "slapi_log_err(SLAPI_LOG_ERR, \"send_ldap_result_ext\", \"ber_alloc failed\\n\");", "goto log_and_return;", "}", "}", "if (err == LDAP_ADMINLIMIT_EXCEEDED &&", "conn->c_ldapversion < LDAP_VERSION3) {", "err = LDAP_SIZELIMIT_EXCEEDED;", "}", "if (conn->c_ldapversion < LDAP_VERSION3 || urls == NULL) {", "char *save, *buf = NULL;", "if (urls != NULL) {", "int len;", "slapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsReferrals);", "len = 10;", "for (i = 0; urls[i] != NULL; i++) {", "len += urls[i]->bv_len + 1;", "}", "if (text != NULL) {", "len += strlen(text) + 1;", "}", "buf = slapi_ch_malloc(len);", "*buf = '\\0';", "if (text != NULL) {", "strcpy(buf, text);", "strcat(buf, \"\\n\");", "}", "strcat(buf, \"Referral:\");", "for (i = 0; urls[i] != NULL; i++) {", "strcat(buf, \"\\n\");", "strcat(buf, urls[i]->bv_val);", "}", "save = text;", "text = buf;", "}", "if ((conn->c_ldapversion < LDAP_VERSION3 &&", "err == LDAP_REFERRAL) ||", "urls != NULL) {", "err = LDAP_PARTIAL_RESULTS;", "}", "rc = ber_printf(ber, \"{it{ess\", operation->o_msgid, tag, err,", "matched ? matched : \"\", pbtext ? pbtext : \"\");", "if (rc != LBER_ERROR) {", "rc = check_and_send_extended_result(pb, tag, ber);", "}", "if (rc != LBER_ERROR) {", "rc = check_and_send_SASL_response(pb, tag, ber, conn);", "}", "if (rc != LBER_ERROR) {", "rc = ber_printf(ber, \"}\");", "}", "if (buf != NULL) {", "text = save;", "slapi_ch_free((void **)&buf);", "}", "} else {", "if (!config_check_referral_mode())", "slapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsReferrals);", "rc = ber_printf(ber, \"{it{esst{s\", operation->o_msgid, tag, err,", "matched ? matched : \"\", text ? text : \"\", LDAP_TAG_REFERRAL,", "urls[0]->bv_val);", "for (i = 1; urls[i] != NULL && rc != LBER_ERROR; i++) {", "rc = ber_printf(ber, \"s\", urls[i]->bv_val);", "}", "if (rc != LBER_ERROR) {", "rc = ber_printf(ber, \"}\");", "}", "if (rc != LBER_ERROR) {", "rc = check_and_send_extended_result(pb, tag, ber);", "}", "if (rc != LBER_ERROR) {", "rc = check_and_send_SASL_response(pb, tag, ber, conn);", "}", "if (rc != LBER_ERROR) {", "rc = ber_printf(ber, \"}\");", "}", "}", "if (err == LDAP_SUCCESS) {", "if (process_read_entry_controls(pb, LDAP_CONTROL_PRE_READ_ENTRY)) {", "err = LDAP_UNAVAILABLE_CRITICAL_EXTENSION;", "goto log_and_return;", "}", "if (process_read_entry_controls(pb, LDAP_CONTROL_POST_READ_ENTRY)) {", "err = LDAP_UNAVAILABLE_CRITICAL_EXTENSION;", "goto log_and_return;", "}", "}", "if (operation->o_results.result_controls != NULL && conn->c_ldapversion >= LDAP_VERSION3 && write_controls(ber, operation->o_results.result_controls) != 0) {", "rc = (int)LBER_ERROR;", "}", "if (rc != LBER_ERROR) {", "rc = ber_put_seq(ber);", "}", "if (rc == LBER_ERROR) {", "slapi_log_err(SLAPI_LOG_ERR, \"send_ldap_result_ext\", \"ber_printf failed 1\\n\");", "if (flush_ber_element == 1) {", "ber_free(ber, 1              );", "}", "goto log_and_return;", "}", "if (flush_ber_element) {", "if (flush_ber(pb, conn, operation, ber, _LDAP_SEND_RESULT) == 0) {", "logit = 1;", "}", "}", "log_and_return:", "operation->o_status = SLAPI_OP_STATUS_RESULT_SENT;", "if (logit && (operation_is_flag_set(operation, OP_FLAG_ACTION_LOG_ACCESS) ||", "(internal_op && config_get_plugin_logging()))) {", "log_result(pb, operation, err, tag, nentries);", "}", "slapi_log_err(SLAPI_LOG_TRACE, \"send_ldap_result_ext\", \"<= %d\\n\", err);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void gtkui_icmp_redir(void)", "{", "GtkWidget *dialog, *table, *hbox, *image, *label, *entry1, *entry2, *frame;", "gint response = 0;", "DEBUG_MSG(\"gtk_icmp_redir\");", "dialog = gtk_dialog_new_with_buttons(\"MITM Attack: ICMP Redirect\", GTK_WINDOW (window),", "GTK_DIALOG_MODAL, GTK_STOCK_OK, GTK_RESPONSE_OK,", "GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL, NULL);", "gtk_container_set_border_width(GTK_CONTAINER (dialog), 5);", "gtk_dialog_set_has_separator(GTK_DIALOG (dialog), FALSE);", "hbox = gtk_hbox_new (FALSE, 5);", "gtk_box_pack_start (GTK_BOX (GTK_DIALOG (dialog)->vbox), hbox, FALSE, FALSE, 0);", "gtk_widget_show(hbox);", "image = gtk_image_new_from_stock (GTK_STOCK_DIALOG_QUESTION, GTK_ICON_SIZE_DIALOG);", "gtk_misc_set_alignment (GTK_MISC (image), 0.5, 0.1);", "gtk_box_pack_start (GTK_BOX (hbox), image, FALSE, FALSE, 5);", "gtk_widget_show(image);", "frame = gtk_frame_new(\"Gateway Information\");", "gtk_container_set_border_width(GTK_CONTAINER (frame), 5);", "gtk_box_pack_start (GTK_BOX (hbox), frame, TRUE, TRUE, 0);", "gtk_widget_show(frame);", "table = gtk_table_new(2, 2, FALSE);", "gtk_table_set_row_spacings(GTK_TABLE (table), 5);", "gtk_table_set_col_spacings(GTK_TABLE (table), 5);", "gtk_container_set_border_width(GTK_CONTAINER (table), 8);", "gtk_container_add(GTK_CONTAINER (frame), table);", "gtk_widget_show(table);", "label = gtk_label_new(\"MAC Address\");", "gtk_misc_set_alignment(GTK_MISC (label), 0, 0.5);", "gtk_table_attach(GTK_TABLE (table), label, 0, 1, 0, 1, GTK_FILL, GTK_FILL, 0, 0);", "gtk_widget_show(label);", "entry1 = gtk_entry_new();", "gtk_entry_set_max_length(GTK_ENTRY (entry1), ETH_ASCII_ADDR_LEN);", "gtk_table_attach_defaults(GTK_TABLE (table), entry1, 1, 2, 0, 1);", "gtk_widget_show(entry1);", "label = gtk_label_new(\"IP Address\");", "gtk_misc_set_alignment(GTK_MISC (label), 0, 0.5);", "gtk_table_attach(GTK_TABLE (table), label, 0, 1, 1, 2, GTK_FILL, GTK_FILL, 0, 0);", "gtk_widget_show(label);", "entry2 = gtk_entry_new();", "gtk_entry_set_max_length(GTK_ENTRY (entry2), IP6_ASCII_ADDR_LEN);", "gtk_table_attach_defaults(GTK_TABLE (table), entry2, 1, 2, 1, 2);", "gtk_widget_show(entry2);", "response = gtk_dialog_run(GTK_DIALOG(dialog));", "if(response == GTK_RESPONSE_OK) {", "gtk_widget_hide(dialog);", "snprintf(params, 6, \"icmp:\");", "strncat(params, gtk_entry_get_text(GTK_ENTRY(entry1)), PARAMS_LEN);", "strncat(params, \"/\", PARAMS_LEN);", "strncat(params, gtk_entry_get_text(GTK_ENTRY(entry2)), PARAMS_LEN);", "gtkui_start_mitm();", "}", "gtk_widget_destroy(dialog);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": ["bool PackLinuxElf32::canPack()", "{", "union {", "unsigned char buf[sizeof(Elf32_Ehdr) + 14*sizeof(Elf32_Phdr)];", "} u;", "COMPILE_TIME_ASSERT(sizeof(u.buf) <= 512)", "fi->seek(0, SEEK_SET);", "fi->readx(u.buf, sizeof(u.buf));", "fi->seek(0, SEEK_SET);", "Elf32_Ehdr const *const ehdr = (Elf32_Ehdr *) u.buf;", "if (checkEhdr(ehdr) != 0)", "return false;", "if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) {", "throwCantPack(\"invalid Ehdr e_ehsize; try '--force-execve'\");", "return false;", "}", "if (e_phoff != sizeof(*ehdr)) {", "throwCantPack(\"non-contiguous Ehdr/Phdr; try '--force-execve'\");", "return false;", "}", "unsigned char osabi0 = u.buf[Elf32_Ehdr::EI_OSABI];", "Elf32_Phdr const *phdr = phdri;", "note_size = 0;", "for (unsigned j=0; j < e_phnum; ++phdr, ++j) {", "if (j >= 14) {", "throwCantPack(\"too many ElfXX_Phdr; try '--force-execve'\");", "return false;", "}", "unsigned const p_type = get_te32(&phdr->p_type);", "unsigned const p_offset = get_te32(&phdr->p_offset);", "if (1!=exetype && PT_LOAD32 == p_type) {", "exetype = 1;", "load_va = get_te32(&phdr->p_vaddr);", "unsigned const off = ~page_mask & (unsigned)load_va;", "if (off && off == p_offset) {", "throwCantPack(\"Go-language PT_LOAD: try hemfix.c, or try '--force-execve'\");", "return false;", "}", "if (0 != p_offset) {", "throwCantPack(\"first PT_LOAD.p_offset != 0; try '--force-execve'\");", "return false;", "}", "hatch_off = ~3u & (3+ get_te32(&phdr->p_memsz));", "}", "if (PT_NOTE32 == p_type) {", "unsigned const x = get_te32(&phdr->p_memsz);", "if ( sizeof(elfout.notes) < x", "||  (sizeof(elfout.notes) < (note_size += x)) ) {", "throwCantPack(\"PT_NOTEs too big; try '--force-execve'\");", "return false;", "}", "if (osabi_note && Elf32_Ehdr::ELFOSABI_NONE==osabi0) {", "struct {", "struct Elf32_Nhdr nhdr;", "char name[8];", "unsigned body;", "} note;", "memset(&note, 0, sizeof(note));", "fi->seek(p_offset, SEEK_SET);", "fi->readx(&note, sizeof(note));", "fi->seek(0, SEEK_SET);", "if (4==get_te32(&note.nhdr.descsz)", "&&  1==get_te32(&note.nhdr.type)", "&&  (1+ strlen(osabi_note))==get_te32(&note.nhdr.namesz)", "&&  0==strcmp(osabi_note, (char const *)&note.name[0])", ") {", "osabi0 = ei_osabi;", "}", "}", "}", "}", "if (Elf32_Ehdr::ELFOSABI_NONE ==osabi0", "||  Elf32_Ehdr::ELFOSABI_LINUX==osabi0) {", "unsigned const arm_eabi = 0xff000000u & get_te32(&ehdr->e_flags);", "if (Elf32_Ehdr::EM_ARM==e_machine", "&&   (EF_ARM_EABI_VER5==arm_eabi", "||  EF_ARM_EABI_VER4==arm_eabi ) ) {", "ei_osabi = osabi0 = Elf32_Ehdr::ELFOSABI_LINUX;", "}", "else {", "osabi0 = opt->o_unix.osabi0;", "}", "}", "if (osabi0!=ei_osabi) {", "return false;", "}", "if (Elf32_Ehdr::ET_DYN==get_te16(&ehdr->e_type)) {", "alloc_file_image(file_image, file_size);", "fi->seek(0, SEEK_SET);", "fi->readx(file_image, file_size);", "memcpy(&ehdri, ehdr, sizeof(Elf32_Ehdr));", "phdri= (Elf32_Phdr *)((size_t)e_phoff + file_image);", "shdri= (Elf32_Shdr *)((size_t)e_shoff + file_image);", "sec_strndx = NULL;", "shstrtab = NULL;", "if (e_shnum) {", "unsigned const e_shstrndx = get_te16(&ehdr->e_shstrndx);", "if (e_shstrndx) {", "if (e_shnum <= e_shstrndx) {", "char msg[40]; snprintf(msg, sizeof(msg),", "\"bad e_shstrndx %#x >= e_shnum %d\", e_shstrndx, e_shnum);", "throwCantPack(msg);", "}", "sec_strndx = &shdri[e_shstrndx];", "unsigned const sh_offset = get_te32(&sec_strndx->sh_offset);", "if ((u32_t)file_size <= sh_offset) {", "char msg[50]; snprintf(msg, sizeof(msg),", "\"bad .e_shstrndx->sh_offset %#x\", sh_offset);", "throwCantPack(msg);", "}", "shstrtab = (char const *)(sh_offset + file_image);", "}", "sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);", "if (sec_dynsym) {", "unsigned const sh_link = get_te32(&sec_dynsym->sh_link);", "if (e_shnum <= sh_link) {", "char msg[50]; snprintf(msg, sizeof(msg),", "\"bad SHT_DYNSYM.sh_link %#x\", sh_link);", "}", "sec_dynstr = &shdri[sh_link];", "}", "if (sec_strndx) {", "unsigned const sh_name = get_te32(&sec_strndx->sh_name);", "if (Elf32_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type)", "|| (u32_t)file_size <= sh_name", "|| (sh_name", "&& 0!=strcmp((char const *)\".shstrtab\", &shstrtab[sh_name]))", ") {", "throwCantPack(\"bad e_shstrndx\");", "}", "}", "}", "Elf32_Phdr const *pload_x0(0);", "phdr= phdri;", "for (int j= e_phnum; --j>=0; ++phdr)", "if (Elf32_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {", "dynseg= (Elf32_Dyn const *)(check_pt_dynamic(phdr) + file_image);", "invert_pt_dynamic(dynseg);", "}", "else if (PT_LOAD32==get_te32(&phdr->p_type)) {", "if (!pload_x0", "&&  Elf32_Phdr::PF_X & get_te32(&phdr->p_flags)", ") {", "pload_x0 = phdr;", "}", "check_pt_load(phdr);", "}", "dynstr=          (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);", "dynsym=     (Elf32_Sym const *)elf_find_dynamic(Elf32_Dyn::DT_SYMTAB);", "if (opt->o_unix.force_pie", "||      Elf32_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf32_Dyn::DT_FLAGS_1)", "||  calls_crt1((Elf32_Rel const *)elf_find_dynamic(Elf32_Dyn::DT_REL),", "(int)elf_unsigned_dynamic(Elf32_Dyn::DT_RELSZ))", "||  calls_crt1((Elf32_Rel const *)elf_find_dynamic(Elf32_Dyn::DT_JMPREL),", "(int)elf_unsigned_dynamic(Elf32_Dyn::DT_PLTRELSZ))) {", "is_pie = true;", "goto proceed;", "}", "if (                      elf_find_dynamic(upx_dt_init)) {", "if (this->e_machine!=Elf32_Ehdr::EM_386", "&&  this->e_machine!=Elf32_Ehdr::EM_MIPS", "&&  this->e_machine!=Elf32_Ehdr::EM_ARM)", "goto abandon;", "if (elf_has_dynamic(Elf32_Dyn::DT_TEXTREL)) {", "throwCantPack(\"DT_TEXTREL found; re-compile with -fPIC\");", "goto abandon;", "}", "if (!(Elf32_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf32_Dyn::DT_FLAGS_1))) {", "if (Elf32_Ehdr::EM_ARM == e_machine", "&&  !opt->o_unix.android_shlib", ") {", "opt->info_mode++;", "info(\"note: use --android-shlib if appropriate\");", "opt->info_mode--;", "}", "}", "Elf32_Shdr const *shdr = shdri;", "xct_va = ~0u;", "if (e_shnum) {", "for (int j= e_shnum; --j>=0; ++shdr) {", "unsigned const sh_type = get_te32(&shdr->sh_type);", "if (Elf32_Shdr::SHF_EXECINSTR & get_te32(&shdr->sh_flags)) {", "xct_va = umin(xct_va, get_te32(&shdr->sh_addr));", "}", "if ((     Elf32_Dyn::DT_PREINIT_ARRAY==upx_dt_init", "&&  Elf32_Shdr::SHT_PREINIT_ARRAY==sh_type)", "||  (     Elf32_Dyn::DT_INIT_ARRAY   ==upx_dt_init", "&&  Elf32_Shdr::SHT_INIT_ARRAY   ==sh_type) ) {", "unsigned user_init_ava = get_te32(&shdr->sh_addr);", "user_init_off = get_te32(&shdr->sh_offset);", "if ((u32_t)file_size <= user_init_off) {", "char msg[70]; snprintf(msg, sizeof(msg),", "\"bad Elf32_Shdr[%d].sh_offset %#x\",", "-1+ e_shnum - j, user_init_off);", "throwCantPack(msg);", "}", "int z_rel = dt_table[Elf32_Dyn::DT_REL];", "int z_rsz = dt_table[Elf32_Dyn::DT_RELSZ];", "if (z_rel && z_rsz) {", "unsigned rel_off = get_te32(&dynseg[-1+ z_rel].d_val);", "Elf32_Rel *rp = (Elf32_Rel *)&file_image[rel_off];", "unsigned relsz   = get_te32(&dynseg[-1+ z_rsz].d_val);", "Elf32_Rel *last = (Elf32_Rel *)(relsz + (char *)rp);", "for (; rp < last; ++rp) {", "unsigned r_va = get_te32(&rp->r_offset);", "if (r_va == user_init_ava) {", "unsigned r_info = get_te32(&rp->r_info);", "unsigned r_type = ELF32_R_TYPE(r_info);", "if (Elf32_Ehdr::EM_ARM == e_machine", "&&  R_ARM_RELATIVE == r_type) {", "user_init_va = get_te32(&file_image[user_init_off]);", "}", "else {", "char msg[50]; snprintf(msg, sizeof(msg),", "\"bad relocation %#x DT_INIT_ARRAY[0]\",", "r_info);", "throwCantPack(msg);", "}", "break;", "}", "}", "}", "unsigned const p_filesz = get_te32(&pload_x0->p_filesz);", "if (!((user_init_va - xct_va) < p_filesz)) {", "if (0==user_init_va && opt->o_unix.android_shlib) {", "upx_dt_init = 0;", "}", "else {", "char msg[70]; snprintf(msg, sizeof(msg),", "\"bad init address %#x in Elf32_Shdr[%d].%#x\\n\",", "(unsigned)user_init_va, -1+ e_shnum - j, user_init_off);", "throwCantPack(msg);", "}", "}", "}", "if ((Elf32_Dyn::DT_INIT==upx_dt_init || !upx_dt_init)", "&&  Elf32_Shdr::SHT_DYNAMIC == sh_type) {", "unsigned const n = get_te32(&shdr->sh_size) / sizeof(Elf32_Dyn);", "Elf32_Dyn *dynp = (Elf32_Dyn *)&file_image[get_te32(&shdr->sh_offset)];", "for (; Elf32_Dyn::DT_NULL != dynp->d_tag; ++dynp) {", "if (upx_dt_init == get_te32(&dynp->d_tag)) {", "break;", "}", "}", "if ((1+ dynp) < (n+ dynseg)) {", "user_init_va = get_te32(&dynp->d_val);", "set_te32(&dynp->d_tag, upx_dt_init = Elf32_Dyn::DT_INIT);", "user_init_off = (char const *)&dynp->d_val - (char const *)&file_image[0];", "}", "}", "}", "}", "else {", "unsigned const strsz  = elf_unsigned_dynamic(Elf32_Dyn::DT_STRSZ);", "unsigned const strtab = elf_unsigned_dynamic(Elf32_Dyn::DT_STRTAB);", "unsigned const relsz  = elf_unsigned_dynamic(Elf32_Dyn::DT_RELSZ);", "unsigned const rel    = elf_unsigned_dynamic(Elf32_Dyn::DT_REL);", "unsigned const init   = elf_unsigned_dynamic(upx_dt_init);", "if ((init == (relsz + rel   ) && rel    == (strsz + strtab))", "||  (init == (strsz + strtab) && strtab == (relsz + rel   ))", ") {", "xct_va = init;", "user_init_va = init;", "user_init_off = elf_get_offset_from_address(init);", "}", "}", "unsigned const va_gash = elf_unsigned_dynamic(Elf32_Dyn::DT_GNU_HASH);", "unsigned const va_hash = elf_unsigned_dynamic(Elf32_Dyn::DT_HASH);", "unsigned y = 0;", "if ((y=1, xct_va < va_gash)  ||  (y=2, (0==va_gash && xct_va < va_hash))", "||  (y=3, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_STRTAB))", "||  (y=4, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_SYMTAB))", "||  (y=5, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_REL))", "||  (y=6, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_RELA))", "||  (y=7, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_JMPREL))", "||  (y=8, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERDEF))", "||  (y=9, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERSYM))", "||  (y=10, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERNEEDED)) ) {", "static char const *which[] = {", "\"unknown\",", "\"DT_GNU_HASH\",", "\"DT_HASH\",", "\"DT_STRTAB\",", "\"DT_SYMTAB\",", "\"DT_REL\",", "\"DT_RELA\",", "\"DT_JMPREL\",", "\"DT_VERDEF\",", "\"DT_VERSYM\",", "\"DT_VERNEEDED\",", "};", "char buf[30]; snprintf(buf, sizeof(buf), \"%s above stub\", which[y]);", "throwCantPack(buf);", "goto abandon;", "}", "if (!opt->o_unix.android_shlib) {", "phdr = phdri;", "for (unsigned j= 0; j < e_phnum; ++phdr, ++j) {", "unsigned const vaddr = get_te32(&phdr->p_vaddr);", "if (PT_NOTE32 == get_te32(&phdr->p_type)", "&& xct_va < vaddr) {", "char buf[40]; snprintf(buf, sizeof(buf),", "\"PT_NOTE %#x above stub\", vaddr);", "throwCantPack(buf);", "goto abandon;", "}", "}", "}", "xct_off = elf_get_offset_from_address(xct_va);", "if (opt->debug.debug_level) {", "fprintf(stderr, \"shlib canPack: xct_va=%#lx  xct_off=%#lx\\n\",", "(long)xct_va, (long)xct_off);", "}", "goto proceed;", "}", "else", "throwCantPack(\"need DT_INIT; try \\\"void _init(void){}\\\"\");", "abandon:", "return false;", "proceed: ;", "}", "if (!super::canPack())", "return false;", "assert(exetype == 1);", "exetype = 0;", "opt->o_unix.blocksize = blocksize = file_size;", "return true;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void CoreUserInputHandler::doMode(const BufferInfo &bufferInfo, const QChar& addOrRemove, const QChar& mode, const QString &nicks)", "{", "QString m;", "bool isNumber;", "int maxModes = network()->support(\"MODES\").toInt(&isNumber);", "if (!isNumber || maxModes == 0) maxModes = 1;", "QStringList nickList;", "if (nicks == \"*\") {", "const QList<IrcUser*> users = network()->ircChannel(bufferInfo.bufferName())->ircUsers();", "foreach(IrcUser *user, users) {", "if ((addOrRemove == '+' && !network()->ircChannel(bufferInfo.bufferName())->userModes(user).contains(mode))", "|| (addOrRemove == '-' && network()->ircChannel(bufferInfo.bufferName())->userModes(user).contains(mode)))", "nickList.append(user->nick());", "}", "} else {", "nickList = nicks.split(' ', QString::SkipEmptyParts);", "}", "if (nickList.count() == 0) return;", "while (!nickList.isEmpty()) {", "int amount = qMin(nickList.count(), maxModes);", "QString m = addOrRemove; for(int i = 0; i < amount; i++) m += mode;", "QStringList params;", "params << bufferInfo.bufferName() << m;", "for(int i = 0; i < amount; i++) params << nickList.takeFirst();", "emit putCmd(\"MODE\", serverEncode(params));", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["GF_Err flac_dmx_process(GF_Filter *filter)", "{", "GF_FLACDmxCtx *ctx = gf_filter_get_udta(filter);", "GF_FilterPacket *pck, *dst_pck;", "u8 *output;", "u8 *start;", "Bool final_flush=GF_FALSE;", "u32 pck_size, remain, prev_pck_size;", "u64 cts = GF_FILTER_NO_TS;", "FLACHeader hdr;", "if (!ctx->duration.num)", "flac_dmx_check_dur(filter, ctx);", "if (ctx->opid && !ctx->is_playing)", "return GF_OK;", "pck = gf_filter_pid_get_packet(ctx->ipid);", "if (!pck) {", "if (gf_filter_pid_is_eos(ctx->ipid)) {", "if (!ctx->flac_buffer_size) {", "if (ctx->opid)", "gf_filter_pid_set_eos(ctx->opid);", "if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);", "ctx->src_pck = NULL;", "return GF_EOS;", "}", "final_flush = GF_TRUE;", "} else {", "return GF_OK;", "}", "}", "prev_pck_size = ctx->flac_buffer_size;", "if (pck && !ctx->resume_from) {", "u8 *data = (u8 *) gf_filter_pck_get_data(pck, &pck_size);", "if (ctx->byte_offset != GF_FILTER_NO_BO) {", "u64 byte_offset = gf_filter_pck_get_byte_offset(pck);", "if (!ctx->flac_buffer_size) {", "ctx->byte_offset = byte_offset;", "} else if (ctx->byte_offset + ctx->flac_buffer_size != byte_offset) {", "ctx->byte_offset = GF_FILTER_NO_BO;", "if ((byte_offset != GF_FILTER_NO_BO) && (byte_offset>ctx->flac_buffer_size) ) {", "ctx->byte_offset = byte_offset - ctx->flac_buffer_size;", "}", "}", "}", "if (ctx->flac_buffer_size + pck_size > ctx->flac_buffer_alloc) {", "ctx->flac_buffer_alloc = ctx->flac_buffer_size + pck_size;", "ctx->flac_buffer = gf_realloc(ctx->flac_buffer, ctx->flac_buffer_alloc);", "}", "memcpy(ctx->flac_buffer + ctx->flac_buffer_size, data, pck_size);", "ctx->flac_buffer_size += pck_size;", "}", "if (ctx->timescale && pck) {", "cts = gf_filter_pck_get_cts(pck);", "}", "if (cts == GF_FILTER_NO_TS) {", "prev_pck_size = 0;", "}", "remain = ctx->flac_buffer_size;", "start = ctx->flac_buffer;", "if (ctx->resume_from) {", "start += ctx->resume_from - 1;", "remain -= ctx->resume_from - 1;", "ctx->resume_from = 0;", "}", "while (remain>2) {", "u32 next_frame=0, nb_samp;", "u32 cur_size = remain-2;", "u8 *cur_buf = start+2;", "u8 *hdr_start = NULL;", "if (final_flush) {", "next_frame = remain;", "} else {", "while (cur_size) {", "hdr_start = memchr(cur_buf, 0xFF, cur_size);", "if (!hdr_start) break;", "next_frame = (u32) (hdr_start-start);", "if (next_frame == remain)", "break;", "if ((hdr_start[1]&0xFC) == 0xF8) {", "if (flac_parse_header(ctx, hdr_start, (u32) remain - next_frame, &hdr))", "break;", "}", "cur_buf = hdr_start+1;", "cur_size = (u32) (cur_buf - start);", "assert(cur_size<=remain);", "cur_size = remain - cur_size;", "hdr_start = NULL;", "}", "if (!hdr_start) break;", "if (next_frame == remain)", "break;", "}", "if (!ctx->initialized) {", "u32 size = next_frame;", "u32 dsi_end = 0;", "gf_bs_reassign_buffer(ctx->bs, ctx->flac_buffer, size);", "u32 magic = gf_bs_read_u32(ctx->bs);", "if (magic != GF_4CC('f','L','a','C')) {", "}", "while (gf_bs_available(ctx->bs)) {", "Bool last = gf_bs_read_int(ctx->bs, 1);", "u32 type = gf_bs_read_int(ctx->bs, 7);", "u32 len = gf_bs_read_int(ctx->bs, 24);", "if (type==0) {", "u16 min_block_size = gf_bs_read_u16(ctx->bs);", "u16 max_block_size = gf_bs_read_u16(ctx->bs);", "gf_bs_read_u24(ctx->bs);", "gf_bs_read_u24(ctx->bs);", "ctx->sample_rate = gf_bs_read_int(ctx->bs, 20);", "ctx->nb_channels = 1 + gf_bs_read_int(ctx->bs, 3);", "ctx->bits_per_sample = 1 + gf_bs_read_int(ctx->bs, 5);", "if (min_block_size==max_block_size) ctx->block_size = min_block_size;", "else ctx->block_size = 0;", "ctx->duration.num = gf_bs_read_long_int(ctx->bs, 36);", "ctx->duration.den = ctx->sample_rate;", "gf_bs_skip_bytes(ctx->bs, 16);", "dsi_end = (u32) gf_bs_get_position(ctx->bs);", "} else {", "gf_bs_skip_bytes(ctx->bs, len);", "}", "if (last) break;", "}", "flac_dmx_check_pid(filter, ctx, ctx->flac_buffer+4, dsi_end-4);", "remain -= size;", "start += size;", "ctx->initialized = GF_TRUE;", "if (!ctx->is_playing) break;", "continue;", "}", "if ((start[0] != 0xFF) && ((start[1]&0xFC) != 0xF8)) {", "GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[FLACDmx] invalid frame, droping %d bytes and resyncing\\n\", next_frame));", "start += next_frame;", "remain -= next_frame;", "continue;", "}", "flac_parse_header(ctx,start, next_frame, &hdr);", "if (hdr.sample_rate != ctx->sample_rate) {", "ctx->sample_rate = hdr.sample_rate;", "gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAMPLE_RATE, & PROP_UINT(ctx->sample_rate));", "}", "nb_samp = hdr.block_size;", "if (ctx->in_seek) {", "u64 nb_samples_at_seek = (u64) (ctx->start_range * ctx->sample_rate);", "if (ctx->cts + nb_samp >= nb_samples_at_seek) {", "ctx->in_seek = GF_FALSE;", "}", "}", "if (ctx->timescale && !prev_pck_size && (cts != GF_FILTER_NO_TS) ) {", "ctx->cts = cts;", "cts = GF_FILTER_NO_TS;", "}", "if (!ctx->in_seek) {", "dst_pck = gf_filter_pck_new_alloc(ctx->opid, next_frame, &output);", "memcpy(output, start, next_frame);", "gf_filter_pck_set_cts(dst_pck, ctx->cts);", "if (!ctx->timescale || (ctx->timescale==ctx->sample_rate) )", "gf_filter_pck_set_duration(dst_pck, nb_samp);", "else {", "gf_filter_pck_set_duration(dst_pck, (nb_samp * ctx->timescale) / ctx->sample_rate);", "}", "gf_filter_pck_set_sap(dst_pck, GF_FILTER_SAP_1);", "gf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);", "if (ctx->byte_offset != GF_FILTER_NO_BO) {", "gf_filter_pck_set_byte_offset(dst_pck, ctx->byte_offset);", "}", "gf_filter_pck_send(dst_pck);", "}", "flac_dmx_update_cts(ctx, nb_samp);", "assert (start[0] == 0xFF);", "assert((start[1]&0xFC) == 0xF8);", "start += next_frame;", "assert(remain >= next_frame);", "remain -= next_frame;", "}", "if (!pck) {", "ctx->flac_buffer_size = 0;", "return flac_dmx_process(filter);", "} else {", "if (remain < ctx->flac_buffer_size) {", "memmove(ctx->flac_buffer, start, remain);", "}", "ctx->flac_buffer_size = remain;", "gf_filter_pid_drop_packet(ctx->ipid);", "}", "return GF_OK;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void SFS_ObjectMemberAccess(ScriptParser *parser)", "{", "if (parser->codec->LastError) return;", "SFS_Expression(parser);", "SFS_AddString(parser, \".\");", "SFS_Identifier(parser);", "}"], "ner_tags": [0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["bool Greeter::start() {", "if (m_started)", "return false;", "if (daemonApp->testing()) {", "m_process = new QProcess(this);", "connect(m_process, SIGNAL(finished(int,QProcess::ExitStatus)), this, SLOT(finished()));", "connect(m_process, SIGNAL(readyReadStandardOutput()), SLOT(onReadyReadStandardOutput()));", "connect(m_process, SIGNAL(readyReadStandardError()), SLOT(onReadyReadStandardError()));", "qDebug() << \"Greeter starting...\";", "QProcessEnvironment env = QProcessEnvironment::systemEnvironment();", "env.insert(QStringLiteral(\"DISPLAY\"), m_display->name());", "env.insert(QStringLiteral(\"XAUTHORITY\"), m_authPath);", "env.insert(QStringLiteral(\"XCURSOR_THEME\"), mainConfig.Theme.CursorTheme.get());", "m_process->setProcessEnvironment(env);", "QStringList args;", "if (daemonApp->testing())", "args << QStringLiteral(\"--test-mode\");", "args << QStringLiteral(\"--socket\") << m_socket", "<< QStringLiteral(\"--theme\") << m_theme;", "m_process->start(QStringLiteral(\"%1/sddm-greeter\").arg(QStringLiteral(BIN_INSTALL_DIR)), args);", "if (m_process->state() == QProcess::NotRunning) {", "qCritical() << \"Greeter failed to launch.\";", "return false;", "}", "if (!m_process->waitForStarted()) {", "qCritical() << \"Failed to start greeter.\";", "return false;", "}", "qDebug() << \"Greeter started.\";", "m_started = true;", "} else {", "m_auth = new Auth(this);", "m_auth->setVerbose(true);", "connect(m_auth, SIGNAL(requestChanged()), this, SLOT(onRequestChanged()));", "connect(m_auth, SIGNAL(session(bool)), this, SLOT(onSessionStarted(bool)));", "connect(m_auth, SIGNAL(finished(Auth::HelperExitStatus)), this, SLOT(onHelperFinished(Auth::HelperExitStatus)));", "connect(m_auth, SIGNAL(info(QString,Auth::Info)), this, SLOT(authInfo(QString,Auth::Info)));", "connect(m_auth, SIGNAL(error(QString,Auth::Error)), this, SLOT(authError(QString,Auth::Error)));", "QStringList args;", "args << QStringLiteral(\"%1/sddm-greeter\").arg(QStringLiteral(BIN_INSTALL_DIR));", "args << QStringLiteral(\"--socket\") << m_socket", "<< QStringLiteral(\"--theme\") << m_theme;", "QProcessEnvironment env;", "QProcessEnvironment sysenv = QProcessEnvironment::systemEnvironment();", "insertEnvironmentList({QStringLiteral(\"LANG\"), QStringLiteral(\"LANGUAGE\"),", "QStringLiteral(\"LC_CTYPE\"), QStringLiteral(\"LC_NUMERIC\"), QStringLiteral(\"LC_TIME\"), QStringLiteral(\"LC_COLLATE\"),", "QStringLiteral(\"LC_MONETARY\"), QStringLiteral(\"LC_MESSAGES\"), QStringLiteral(\"LC_PAPER\"), QStringLiteral(\"LC_NAME\"),", "QStringLiteral(\"LC_ADDRESS\"), QStringLiteral(\"LC_TELEPHONE\"), QStringLiteral(\"LC_MEASUREMENT\"), QStringLiteral(\"LC_IDENTIFICATION\"),", "QStringLiteral(\"LD_LIBRARY_PATH\"),", "QStringLiteral(\"QML2_IMPORT_PATH\"),", "QStringLiteral(\"QT_PLUGIN_PATH\"),", "QStringLiteral(\"XDG_DATA_DIRS\")", "}, sysenv, env);", "env.insert(QStringLiteral(\"PATH\"), mainConfig.Users.DefaultPath.get());", "env.insert(QStringLiteral(\"DISPLAY\"), m_display->name());", "env.insert(QStringLiteral(\"XAUTHORITY\"), m_authPath);", "env.insert(QStringLiteral(\"XCURSOR_THEME\"), mainConfig.Theme.CursorTheme.get());", "env.insert(QStringLiteral(\"XDG_SEAT\"), m_display->seat()->name());", "env.insert(QStringLiteral(\"XDG_SEAT_PATH\"), daemonApp->displayManager()->seatPath(m_display->seat()->name()));", "env.insert(QStringLiteral(\"XDG_SESSION_PATH\"), daemonApp->displayManager()->sessionPath(QStringLiteral(\"Session%1\").arg(daemonApp->newSessionId())));", "env.insert(QStringLiteral(\"XDG_VTNR\"), QString::number(m_display->terminalId()));", "env.insert(QStringLiteral(\"XDG_SESSION_CLASS\"), QStringLiteral(\"greeter\"));", "env.insert(QStringLiteral(\"XDG_SESSION_TYPE\"), m_display->sessionType());", "m_auth->insertEnvironment(env);", "qDebug() << \"Greeter starting...\";", "m_auth->setUser(QStringLiteral(\"sddm\"));", "m_auth->setGreeter(true);", "m_auth->setSession(args.join(QLatin1Char(' ')));", "m_auth->start();", "}", "return true;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static av_cold int decode_init(AVCodecContext *avctx)", "{", "UtvideoContext * const c = avctx->priv_data;", "c->avctx = avctx;", "ff_bswapdsp_init(&c->bdsp);", "if (avctx->extradata_size < 16) {", "av_log(avctx, AV_LOG_ERROR,", "\"Insufficient extradata size %d, should be at least 16\\n\",", "avctx->extradata_size);", "return AVERROR_INVALIDDATA;", "}", "av_log(avctx, AV_LOG_DEBUG, \"Encoder version %d.%d.%d.%d\\n\",", "avctx->extradata[3], avctx->extradata[2],", "avctx->extradata[1], avctx->extradata[0]);", "av_log(avctx, AV_LOG_DEBUG, \"Original format %\"PRIX32\"\\n\",", "AV_RB32(avctx->extradata + 4));", "c->frame_info_size = AV_RL32(avctx->extradata + 8);", "c->flags           = AV_RL32(avctx->extradata + 12);", "if (c->frame_info_size != 4)", "avpriv_request_sample(avctx, \"Frame info not 4 bytes\");", "av_log(avctx, AV_LOG_DEBUG, \"Encoding parameters %08\"PRIX32\"\\n\", c->flags);", "c->slices      = (c->flags >> 24) + 1;", "c->compression = c->flags & 1;", "c->interlaced  = c->flags & 0x800;", "c->slice_bits_size = 0;", "switch (avctx->codec_tag) {", "case MKTAG('U', 'L', 'R', 'G'):", "c->planes      = 3;", "avctx->pix_fmt = AV_PIX_FMT_RGB24;", "break;", "case MKTAG('U', 'L', 'R', 'A'):", "c->planes      = 4;", "avctx->pix_fmt = AV_PIX_FMT_RGBA;", "break;", "case MKTAG('U', 'L', 'Y', '0'):", "c->planes      = 3;", "avctx->pix_fmt = AV_PIX_FMT_YUV420P;", "avctx->colorspace = AVCOL_SPC_BT470BG;", "break;", "case MKTAG('U', 'L', 'Y', '2'):", "c->planes      = 3;", "avctx->pix_fmt = AV_PIX_FMT_YUV422P;", "avctx->colorspace = AVCOL_SPC_BT470BG;", "break;", "case MKTAG('U', 'L', 'H', '0'):", "c->planes      = 3;", "avctx->pix_fmt = AV_PIX_FMT_YUV420P;", "avctx->colorspace = AVCOL_SPC_BT709;", "break;", "case MKTAG('U', 'L', 'H', '2'):", "c->planes      = 3;", "avctx->pix_fmt = AV_PIX_FMT_YUV422P;", "avctx->colorspace = AVCOL_SPC_BT709;", "break;", "default:", "av_log(avctx, AV_LOG_ERROR, \"Unknown Ut Video FOURCC provided (%08X)\\n\",", "avctx->codec_tag);", "return AVERROR_INVALIDDATA;", "}", "return 0;", "}"], "ner_tags": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["void sqlite3Fts5UnicodeAscii(u8 *aArray, u8 *aAscii){", "int i = 0;", "int iTbl = 0;", "while( i<128 ){", "int bToken = aArray[ aFts5UnicodeData[iTbl] & 0x1F ];", "int n = (aFts5UnicodeData[iTbl] >> 5) + i;", "for(; i<128 && i<n; i++){", "aAscii[i] = (u8)bToken;", "}", "iTbl++;", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["static void gf_dump_vrml_simple_field(GF_SceneDumper *sdump, GF_FieldInfo field, GF_Node *parent)", "{", "u32 i, sf_type;", "GF_ChildNodeItem *list;", "void *slot_ptr;", "switch (field.fieldType) {", "case GF_SG_VRML_SFNODE:", "gf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL);", "return;", "case GF_SG_VRML_MFNODE:", "list = * ((GF_ChildNodeItem **) field.far_ptr);", "assert( list );", "sdump->indent++;", "while (list) {", "gf_dump_vrml_node(sdump, list->node, 1, NULL);", "list = list->next;", "}", "sdump->indent--;", "return;", "case GF_SG_VRML_SFCOMMANDBUFFER:", "return;", "}", "if (gf_sg_vrml_is_sf_field(field.fieldType)) {", "if (sdump->XMLDump) StartAttribute(sdump, \"value\");", "gf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, parent);", "if (sdump->XMLDump) EndAttribute(sdump);", "} else {", "GenMFField *mffield;", "mffield = (GenMFField *) field.far_ptr;", "sf_type = gf_sg_vrml_get_sf_type(field.fieldType);", "if (!sdump->XMLDump) {", "gf_fprintf(sdump->trace, \"[\");", "} else if (sf_type==GF_SG_VRML_SFSTRING) {", "gf_fprintf(sdump->trace, \" value=\\'\");", "} else {", "StartAttribute(sdump, \"value\");", "}", "for (i=0; i<mffield->count; i++) {", "if (i) gf_fprintf(sdump->trace, \" \");", "gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);", "gf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, parent);", "}", "if (!sdump->XMLDump) {", "gf_fprintf(sdump->trace, \"]\");", "} else if (sf_type==GF_SG_VRML_SFSTRING) {", "gf_fprintf(sdump->trace, \"\\'\");", "} else {", "EndAttribute(sdump);", "}", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void print_udta(GF_ISOFile *file, u32 track_number, Bool has_itags)", "{", "u32 i, count;", "count =  gf_isom_get_udta_count(file, track_number);", "if (!count) return;", "if (has_itags) {", "for (i=0; i<count; i++) {", "u32 type;", "bin128 uuid;", "gf_isom_get_udta_type(file, track_number, i+1, &type, &uuid);", "if (type == GF_ISOM_BOX_TYPE_META) {", "count--;", "break;", "}", "}", "if (!count) return;", "}", "fprintf(stderr, \"%d UDTA types: \", count);", "for (i=0; i<count; i++) {", "u32 j, type, nb_items, first=GF_TRUE;", "bin128 uuid;", "gf_isom_get_udta_type(file, track_number, i+1, &type, &uuid);", "nb_items = gf_isom_get_user_data_count(file, track_number, type, uuid);", "fprintf(stderr, \"%s (%d) \", gf_4cc_to_str(type), nb_items);", "for (j=0; j<nb_items; j++) {", "u8 *udta=NULL;", "u32 udta_size;", "gf_isom_get_user_data(file, track_number, type, uuid, j+1, &udta, &udta_size);", "if (!udta) continue;", "if (gf_utf8_is_legal(udta, udta_size)) {", "if (first) {", "fprintf(stderr, \"\\n\");", "first = GF_FALSE;", "}", "fprintf(stderr, \"\\t%s\\n\", (char *) udta);", "}", "gf_free(udta);", "}", "}", "fprintf(stderr, \"\\n\");", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void AV1_RewriteESDescriptorEx(GF_MPEGVisualSampleEntryBox *av1, GF_MediaBox *mdia)", "{", "GF_BitRateBox *btrt = gf_isom_sample_entry_get_bitrate((GF_SampleEntryBox *)av1, GF_FALSE);", "if (av1->emul_esd) gf_odf_desc_del((GF_Descriptor *)av1->emul_esd);", "av1->emul_esd = gf_odf_desc_esd_new(2);", "av1->emul_esd->decoderConfig->streamType = GF_STREAM_VISUAL;", "av1->emul_esd->decoderConfig->objectTypeIndication = GF_CODECID_AV1;", "if (btrt) {", "av1->emul_esd->decoderConfig->bufferSizeDB = btrt->bufferSizeDB;", "av1->emul_esd->decoderConfig->avgBitrate = btrt->avgBitrate;", "av1->emul_esd->decoderConfig->maxBitrate = btrt->maxBitrate;", "}", "if (av1->av1_config) {", "GF_AV1Config *av1_cfg = AV1_DuplicateConfig(av1->av1_config->config);", "if (av1_cfg) {", "gf_odf_av1_cfg_write(av1_cfg, &av1->emul_esd->decoderConfig->decoderSpecificInfo->data, &av1->emul_esd->decoderConfig->decoderSpecificInfo->dataLength);", "gf_odf_av1_cfg_del(av1_cfg);", "}", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void SFS_CompoundExpression(ScriptParser *parser)", "{", "if (parser->codec->LastError) return;", "SFS_Expression(parser);", "if (! gf_bs_read_int(parser->bs, 1)) return;", "SFS_AddString(parser, \",\");", "SFS_CompoundExpression(parser);", "}"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0]}
