Unnamed: 0,id,function,location,description,project,cve,cwe
2,179103," static void rpza_decode_stream(RpzaContext *s)
 {
     int width = s->avctx->width;
     int stride = s->frame.linesize[0] / 2;
     int row_inc = stride - 4;
     int stream_ptr = 0;
     int chunk_size;
     unsigned char opcode;
     int n_blocks;
     unsigned short colorA = 0, colorB;
     unsigned short color4[4];
     unsigned char index, idx;
     unsigned short ta, tb;
      unsigned short *pixels = (unsigned short *)s->frame.data[0];
      int row_ptr = 0;
    int pixel_ptr = 0;
     int pixel_ptr = -4;
      int block_ptr;
      int pixel_x, pixel_y;
      int total_blocks;
     if (s->buf[stream_ptr] != 0xe1)
         av_log(s->avctx, AV_LOG_ERROR, ""First chunk byte is 0x%02x instead of 0xe1\n"",
             s->buf[stream_ptr]);
     chunk_size = AV_RB32(&s->buf[stream_ptr]) & 0x00FFFFFF;
     stream_ptr += 4;
     if (chunk_size != s->size)
         av_log(s->avctx, AV_LOG_ERROR, ""MOV chunk size != encoded chunk size; using MOV chunk size\n"");
     chunk_size = s->size;
     total_blocks = ((s->avctx->width + 3) / 4) * ((s->avctx->height + 3) / 4);
     while (stream_ptr < chunk_size) {
         opcode = s->buf[stream_ptr++];  
         n_blocks = (opcode & 0x1f) + 1;  
         if ((opcode & 0x80) == 0) {
             colorA = (opcode << 8) | (s->buf[stream_ptr++]);
             opcode = 0;
             if ((s->buf[stream_ptr] & 0x80) != 0) {
                 opcode = 0x20;
                 n_blocks = 1;
             }
         }
         switch (opcode & 0xe0) {
         case 0x80:
             while (n_blocks--) {
               ADVANCE_BLOCK();
             }
             break;
         case 0xa0:
              colorA = AV_RB16 (&s->buf[stream_ptr]);
              stream_ptr += 2;
              while (n_blocks--) {
                 ADVANCE_BLOCK()
                  block_ptr = row_ptr + pixel_ptr;
                  for (pixel_y = 0; pixel_y < 4; pixel_y++) {
                      for (pixel_x = 0; pixel_x < 4; pixel_x++){
                         pixels[block_ptr] = colorA;
                         block_ptr++;
                      }
                      block_ptr += row_inc;
                  }
                ADVANCE_BLOCK();
              }
              break;
         case 0xc0:
             colorA = AV_RB16 (&s->buf[stream_ptr]);
             stream_ptr += 2;
         case 0x20:
             colorB = AV_RB16 (&s->buf[stream_ptr]);
             stream_ptr += 2;
             color4[0] = colorB;
             color4[1] = 0;
             color4[2] = 0;
             color4[3] = colorA;
             ta = (colorA >> 10) & 0x1F;
             tb = (colorB >> 10) & 0x1F;
             color4[1] |= ((11 * ta + 21 * tb) >> 5) << 10;
             color4[2] |= ((21 * ta + 11 * tb) >> 5) << 10;
             ta = (colorA >> 5) & 0x1F;
             tb = (colorB >> 5) & 0x1F;
             color4[1] |= ((11 * ta + 21 * tb) >> 5) << 5;
             color4[2] |= ((21 * ta + 11 * tb) >> 5) << 5;
             ta = colorA & 0x1F;
             tb = colorB & 0x1F;
             color4[1] |= ((11 * ta + 21 * tb) >> 5);
             color4[2] |= ((21 * ta + 11 * tb) >> 5);
              if (s->size - stream_ptr < n_blocks * 4)
                  return;
              while (n_blocks--) {
                 ADVANCE_BLOCK();
                  block_ptr = row_ptr + pixel_ptr;
                  for (pixel_y = 0; pixel_y < 4; pixel_y++) {
                      index = s->buf[stream_ptr++];
                     for (pixel_x = 0; pixel_x < 4; pixel_x++){
                         idx = (index >> (2 * (3 - pixel_x))) & 0x03;
                         pixels[block_ptr] = color4[idx];
                         block_ptr++;
                      }
                      block_ptr += row_inc;
                  }
                ADVANCE_BLOCK();
              }
              break;
          case 0x00:
              if (s->size - stream_ptr < 16)
                  return;
             ADVANCE_BLOCK();
              block_ptr = row_ptr + pixel_ptr;
              for (pixel_y = 0; pixel_y < 4; pixel_y++) {
                  for (pixel_x = 0; pixel_x < 4; pixel_x++){
                     if ((pixel_y != 0) || (pixel_x !=0)) {
                         colorA = AV_RB16 (&s->buf[stream_ptr]);
                         stream_ptr += 2;
                     }
                     pixels[block_ptr] = colorA;
                     block_ptr++;
                  }
                  block_ptr += row_inc;
              }
            ADVANCE_BLOCK();
              break;
         default:
             av_log(s->avctx, AV_LOG_ERROR, ""Unknown opcode %d in rpza chunk.""
                  "" Skip remaining %d bytes of chunk data.\n"", opcode,
                  chunk_size - stream_ptr);
             return;
         }  
     }
 }","[16, 17, 51, 60, 88, 99, 105, 118]","The rpza_decode_stream function in libavcodec/rpza.c in FFmpeg before 2.1 does not properly maintain a pointer to pixel data, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted Apple RPZA data.",FFmpeg,CVE-2013-7009,CWE-119
16,180136," static void handle_data_packet(struct mt_connection *curconn, struct mt_mactelnet_hdr *pkthdr, int data_len) {
 	struct mt_mactelnet_control_hdr cpkt;
 	struct mt_packet pdata;
 	unsigned char *data = pkthdr->data;
 	unsigned int act_size = 0;
 	int got_user_packet = 0;
 	int got_pass_packet = 0;
 	int got_width_packet = 0;
 	int got_height_packet = 0;
 	int success;
 	success = parse_control_packet(data, data_len - MT_HEADER_LEN, &cpkt);
 	while (success) {
 		if (cpkt.cptype == MT_CPTYPE_BEGINAUTH) {
 			int plen,i;
 			if (!curconn->have_pass_salt) {
 				for (i = 0; i < 16; ++i) {
 					curconn->pass_salt[i] = rand() % 256;
 				}
 				curconn->have_pass_salt = 1;
 				memset(curconn->trypassword, 0, sizeof(curconn->trypassword));
 			}
 			init_packet(&pdata, MT_PTYPE_DATA, pkthdr->dstaddr, pkthdr->srcaddr, pkthdr->seskey, curconn->outcounter);
 			plen = add_control_packet(&pdata, MT_CPTYPE_PASSSALT, (curconn->pass_salt), 16);
 			curconn->outcounter += plen;
 			send_udp(curconn, &pdata);
 		} else if (cpkt.cptype == MT_CPTYPE_USERNAME && curconn->state != STATE_ACTIVE) {
 			memcpy(curconn->username, cpkt.data, act_size = (cpkt.length > MT_MNDP_MAX_STRING_SIZE - 1 ? MT_MNDP_MAX_STRING_SIZE - 1 : cpkt.length));
 			curconn->username[act_size] = 0;
 			got_user_packet = 1;
 		} else if (cpkt.cptype == MT_CPTYPE_TERM_WIDTH && cpkt.length >= 2) {
 			unsigned short width;
 			memcpy(&width, cpkt.data, 2);
 			curconn->terminal_width = le16toh(width);
 			got_width_packet = 1;
 		} else if (cpkt.cptype == MT_CPTYPE_TERM_HEIGHT && cpkt.length >= 2) {
 			unsigned short height;
 			memcpy(&height, cpkt.data, 2);
 			curconn->terminal_height = le16toh(height);
 			got_height_packet = 1;
 		} else if (cpkt.cptype == MT_CPTYPE_TERM_TYPE) {
  			memcpy(curconn->terminal_type, cpkt.data, act_size = (cpkt.length > 30 - 1 ? 30 - 1 : cpkt.length));
  			curconn->terminal_type[act_size] = 0;
		} else if (cpkt.cptype == MT_CPTYPE_PASSWORD) {
 		} else if (cpkt.cptype == MT_CPTYPE_PASSWORD && cpkt.length == 17) {
  #if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)
  			mlock(curconn->trypassword, 17);
 #endif
 			memcpy(curconn->trypassword, cpkt.data, 17);
 			got_pass_packet = 1;
 		} else if (cpkt.cptype == MT_CPTYPE_PLAINDATA) {
 			if (curconn->state == STATE_ACTIVE && curconn->ptsfd != -1) {
 				write(curconn->ptsfd, cpkt.data, cpkt.length);
  			}
  		} else {
			syslog(LOG_WARNING, _(""(%d) Unhandeled control packet type: %d""), curconn->seskey, cpkt.cptype);
 			syslog(LOG_WARNING, _(""(%d) Unhandeled control packet type: %d, length: %d""), curconn->seskey, cpkt.cptype, cpkt.length);
  		}
 		success = parse_control_packet(NULL, 0, &cpkt);
 	}
 	if (got_user_packet && got_pass_packet) {
 		user_login(curconn, pkthdr);
 	}
 	if (curconn->state == STATE_ACTIVE && (got_width_packet || got_height_packet)) {
 		set_terminal_size(curconn->ptsfd, curconn->terminal_width, curconn->terminal_height);
 	}
 }","[43, 44, 55, 56]",Buffer overflow in the handle_packet function in mactelnet.c in the client in MAC-Telnet 0.4.3 and earlier allows remote TELNET servers to execute arbitrary code via a long string in an MT_CPTYPE_PASSSALT control packet.,MAC-Telnet,CVE-2016-7115,CWE-119
28,181553," lha_read_file_header_1(struct archive_read *a, struct lha *lha)
 {
 	const unsigned char *p;
 	size_t extdsize;
 	int i, err, err2;
 	int namelen, padding;
 	unsigned char headersum, sum_calculated;
 	err = ARCHIVE_OK;
 	if ((p = __archive_read_ahead(a, H1_FIXED_SIZE, NULL)) == NULL)
 		return (truncated_error(a));
 	lha->header_size = p[H1_HEADER_SIZE_OFFSET] + 2;
 	headersum = p[H1_HEADER_SUM_OFFSET];
 	lha->compsize = archive_le32dec(p + H1_COMP_SIZE_OFFSET);
 	lha->origsize = archive_le32dec(p + H1_ORIG_SIZE_OFFSET);
 	lha->mtime = lha_dos_time(p + H1_DOS_TIME_OFFSET);
 	namelen = p[H1_NAME_LEN_OFFSET];
 	padding = ((int)lha->header_size) - H1_FIXED_SIZE - namelen;
 	if (namelen > 230 || padding < 0)
 		goto invalid;
 	if ((p = __archive_read_ahead(a, lha->header_size, NULL)) == NULL)
 		return (truncated_error(a));
 	for (i = 0; i < namelen; i++) {
 		if (p[i + H1_FILE_NAME_OFFSET] == 0xff)
 			goto invalid; 
 	}
 	archive_strncpy(&lha->filename, p + H1_FILE_NAME_OFFSET, namelen);
 	lha->crc = archive_le16dec(p + H1_FILE_NAME_OFFSET + namelen);
 	lha->setflag |= CRC_IS_SET;
 	sum_calculated = lha_calcsum(0, p, 2, lha->header_size - 2);
 	__archive_read_consume(a, lha->header_size - 2);
 	err2 = lha_read_file_extended_header(a, lha, NULL, 2,
 	    (size_t)(lha->compsize + 2), &extdsize);
 	if (err2 < ARCHIVE_WARN)
 		return (err2);
 	if (err2 < err)
 		err = err2;
  	lha->compsize -= extdsize - 2;
 	if (lha->compsize < 0)
 		goto invalid;	 
  	if (sum_calculated != headersum) {
  		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
  		    ""LHa header sum error"");
 		return (ARCHIVE_FATAL);
 	}
 	return (err);
 invalid:
 	archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
 	    ""Invalid LHa header"");
 	return (ARCHIVE_FATAL);
 }","[38, 39]",An error in the lha_read_file_header_1() function (archive_read_support_format_lha.c) in libarchive 3.2.2 allows remote attackers to trigger an out-of-bounds read memory access and subsequently cause a crash via a specially crafted archive.,libarchive,CVE-2017-5601,CWE-125
33,182722,"  size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)   
 {
 	mp4object *mp4 = (mp4object *)malloc(sizeof(mp4object));
 	if (mp4 == NULL) return 0;
  	memset(mp4, 0, sizeof(mp4object));
 	struct stat64 mp4stat;
 	stat64(filename, &mp4stat);
 	mp4->filesize = mp4stat.st_size;
 	if (mp4->filesize < 64) return 0;
  #ifdef _WINDOWS
  	fopen_s(&mp4->mediafp, filename, ""rb"");
  #else
 	mp4->mediafp = fopen(filename, ""rb"");
 #endif
 	if (mp4->mediafp)
 	{
 		uint32_t qttag, qtsize32, skip, type = 0, subtype = 0, num;
 		size_t len;
 		int32_t nest = 0;
  		uint64_t nestsize[MAX_NEST_LEVEL] = { 0 };
  		uint64_t lastsize = 0, qtsize;
  		do
  		{
  			len = fread(&qtsize32, 1, 4, mp4->mediafp);
  			len += fread(&qttag, 1, 4, mp4->mediafp);
			if (len == 8)
 			mp4->filepos += len;
 			if (len == 8 && mp4->filepos < mp4->filesize)
  			{
  				if (!VALID_FOURCC(qttag))
  				{
					LONGSEEK(mp4->mediafp, lastsize - 8 - 8, SEEK_CUR);
					NESTSIZE(lastsize - 8);
					continue;
 					CloseSource((size_t)mp4);
 					mp4 = NULL;
 					break;
  				}
  				qtsize32 = BYTESWAP32(qtsize32);
  				if (qtsize32 == 1)  
  				{
					fread(&qtsize, 1, 8, mp4->mediafp);
 					len = fread(&qtsize, 1, 8, mp4->mediafp);
 					mp4->filepos += len;
  					qtsize = BYTESWAP64(qtsize) - 8;
  				}
  				else
 					qtsize = qtsize32;
 				nest++;
 				if (qtsize < 8) break;
 				if (nest >= MAX_NEST_LEVEL) break;
 				nestsize[nest] = qtsize;
 				lastsize = qtsize;
 #if PRINT_MP4_STRUCTURE	
 				for (int i = 1; i < nest; i++) printf(""    "");
 				printf(""%c%c%c%c (%lld)\n"", (qttag & 0xff), ((qttag >> 8) & 0xff), ((qttag >> 16) & 0xff), ((qttag >> 24) & 0xff), qtsize);
  				if (qttag == MAKEID('m', 'd', 'a', 't') ||
  					qttag == MAKEID('f', 't', 'y', 'p') ||
					qttag == MAKEID('u', 'd', 't', 'a'))
 					qttag == MAKEID('u', 'd', 't', 'a') ||
 					qttag == MAKEID('f', 'r', 'e', 'e'))
  				{
					LONGSEEK(mediafp, qtsize - 8, SEEK_CUR);
 					LongSeek(mp4, qtsize - 8);
  					NESTSIZE(qtsize);
 					continue;
 				}
 #else
 				if (qttag != MAKEID('m', 'o', 'o', 'v') &&  
 					qttag != MAKEID('m', 'v', 'h', 'd') &&
 					qttag != MAKEID('t', 'r', 'a', 'k') &&
 					qttag != MAKEID('m', 'd', 'i', 'a') &&
 					qttag != MAKEID('m', 'd', 'h', 'd') &&
 					qttag != MAKEID('m', 'i', 'n', 'f') &&
 					qttag != MAKEID('g', 'm', 'i', 'n') &&
  					qttag != MAKEID('d', 'i', 'n', 'f') &&
  					qttag != MAKEID('a', 'l', 'i', 's') &&
  					qttag != MAKEID('s', 't', 's', 'd') &&
					qttag != MAKEID('a', 'l', 'i', 's') &&
					qttag != MAKEID('a', 'l', 'i', 's') &&
  					qttag != MAKEID('s', 't', 'b', 'l') &&
  					qttag != MAKEID('s', 't', 't', 's') &&
  					qttag != MAKEID('s', 't', 's', 'c') &&
 					qttag != MAKEID('s', 't', 's', 'z') &&
 					qttag != MAKEID('s', 't', 'c', 'o') &&
  					qttag != MAKEID('c', 'o', '6', '4') &&
  					qttag != MAKEID('h', 'd', 'l', 'r'))
  				{
					LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
 					LongSeek(mp4, qtsize - 8);
  					NESTSIZE(qtsize);
  				}
 				else
 #endif
 					if (qttag == MAKEID('m', 'v', 'h', 'd'))  
 					{
 						len = fread(&skip, 1, 4, mp4->mediafp);
 						len += fread(&skip, 1, 4, mp4->mediafp);
  						len += fread(&skip, 1, 4, mp4->mediafp);
  						len += fread(&mp4->clockdemon, 1, 4, mp4->mediafp); mp4->clockdemon = BYTESWAP32(mp4->clockdemon);
  						len += fread(&mp4->clockcount, 1, 4, mp4->mediafp); mp4->clockcount = BYTESWAP32(mp4->clockcount);
						LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);  
 						mp4->filepos += len;
 						LongSeek(mp4, qtsize - 8 - len);  
  						NESTSIZE(qtsize);
  					}
 					else if (qttag == MAKEID('m', 'd', 'h', 'd'))  
 					{
 						media_header md;
 						len = fread(&md, 1, sizeof(md), mp4->mediafp);
 						if (len == sizeof(md))
 						{
 							md.creation_time = BYTESWAP32(md.creation_time);
 							md.modification_time = BYTESWAP32(md.modification_time);
 							md.time_scale = BYTESWAP32(md.time_scale);
 							md.duration = BYTESWAP32(md.duration);
 							mp4->trak_clockdemon = md.time_scale;
 							mp4->trak_clockcount = md.duration;
 							if (mp4->videolength == 0.0)  
 							{
  								mp4->videolength = (float)((double)mp4->trak_clockcount / (double)mp4->trak_clockdemon);
  							}
  						}
						LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);  
 						mp4->filepos += len;
 						LongSeek(mp4, qtsize - 8 - len);  
  						NESTSIZE(qtsize);
  					}
 					else if (qttag == MAKEID('h', 'd', 'l', 'r'))  
 					{
 						uint32_t temp;
 						len = fread(&skip, 1, 4, mp4->mediafp);
  						len += fread(&skip, 1, 4, mp4->mediafp);
  						len += fread(&temp, 1, 4, mp4->mediafp);   
						if (temp != MAKEID('a', 'l', 'i', 's'))
 						if (temp != MAKEID('a', 'l', 'i', 's') && temp != MAKEID('u', 'r', 'l', ' '))
  							type = temp;
						LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);  
 						mp4->filepos += len;
 						LongSeek(mp4, qtsize - 8 - len);  
  						NESTSIZE(qtsize);
 					}
 					else if (qttag == MAKEID('s', 't', 's', 'd'))  
 					{
 						if (type == traktype)  
 						{
 							len = fread(&skip, 1, 4, mp4->mediafp);
 							len += fread(&skip, 1, 4, mp4->mediafp);
 							len += fread(&skip, 1, 4, mp4->mediafp);
 							len += fread(&subtype, 1, 4, mp4->mediafp);   
 							if (len == 16)
 							{
 								if (subtype != traksubtype)  
 								{
  									type = 0;  
  								}
  							}
							LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);  
 							mp4->filepos += len;
 							LongSeek(mp4, qtsize - 8 - len);  
  						}
  						else
							LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
 							LongSeek(mp4, qtsize - 8);
  						NESTSIZE(qtsize);
  					}
 					else if (qttag == MAKEID('s', 't', 's', 'c'))  
 					{
 						if (type == traktype)  
 						{
 							len = fread(&skip, 1, 4, mp4->mediafp);
 							len += fread(&num, 1, 4, mp4->mediafp);
 							num = BYTESWAP32(num);
 							if (num * 12 <= qtsize - 8 - len)
  							{
  								mp4->metastsc_count = num;
  								if (mp4->metastsc) free(mp4->metastsc);
								mp4->metastsc = (SampleToChunk *)malloc(num * 12);
								if (mp4->metastsc)
 								if (num > 0)
  								{
									uint32_t total_stsc = num;
									len += fread(mp4->metastsc, 1, num * sizeof(SampleToChunk), mp4->mediafp);
									do
 									mp4->metastsc = (SampleToChunk *)malloc(num * sizeof(SampleToChunk));
 									if (mp4->metastsc)
  									{
										num--;
										mp4->metastsc[num].chunk_num = BYTESWAP32(mp4->metastsc[num].chunk_num);
										mp4->metastsc[num].samples = BYTESWAP32(mp4->metastsc[num].samples);
										mp4->metastsc[num].id = BYTESWAP32(mp4->metastsc[num].id);
									} while (num > 0);
								}
 										len += fread(mp4->metastsc, 1, num * sizeof(SampleToChunk), mp4->mediafp);
								if (mp4->metastsc_count == 1 && mp4->metastsc[0].samples == 1)  
 										do
 										{
 											num--;
 											mp4->metastsc[num].chunk_num = BYTESWAP32(mp4->metastsc[num].chunk_num);
 											mp4->metastsc[num].samples = BYTESWAP32(mp4->metastsc[num].samples);
 											mp4->metastsc[num].id = BYTESWAP32(mp4->metastsc[num].id);
 										} while (num > 0);
 									}
 								}
 								else
  								{
									if (mp4->metastsc) free(mp4->metastsc);
									mp4->metastsc = NULL;
									mp4->metastsc_count = 0;
 									CloseSource((size_t)mp4);
 									mp4 = NULL;
 									break;
  								}
  							}
							LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);  
 							mp4->filepos += len;
 							LongSeek(mp4, qtsize - 8 - len);  
  						}
  						else
							LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
 							LongSeek(mp4, qtsize - 8);
  						NESTSIZE(qtsize);
  					}
 					else if (qttag == MAKEID('s', 't', 's', 'z'))  
 					{
 						if (type == traktype)  
 						{
 							uint32_t equalsamplesize;
 							len = fread(&skip, 1, 4, mp4->mediafp);
 							len += fread(&equalsamplesize, 1, 4, mp4->mediafp);
 							len += fread(&num, 1, 4, mp4->mediafp);
 							num = BYTESWAP32(num);
 							if (num * 4 <= qtsize - 8 - len)
  							{
  								mp4->metasize_count = num;
  								if (mp4->metasizes) free(mp4->metasizes);
								mp4->metasizes = (uint32_t *)malloc(num * 4);
								if (mp4->metasizes)
 								if(num > 0)
  								{
									if (equalsamplesize == 0)
 									mp4->metasizes = (uint32_t *)malloc(num * 4);
 									if (mp4->metasizes)
  									{
										len += fread(mp4->metasizes, 1, num * 4, mp4->mediafp);
										do
 										if (equalsamplesize == 0)
  										{
											num--;
											mp4->metasizes[num] = BYTESWAP32(mp4->metasizes[num]);
										} while (num > 0);
									}
									else
									{
										equalsamplesize = BYTESWAP32(equalsamplesize);
										do
 											len += fread(mp4->metasizes, 1, num * 4, mp4->mediafp);
 											do
 											{
 												num--;
 												mp4->metasizes[num] = BYTESWAP32(mp4->metasizes[num]);
 											} while (num > 0);
 										}
 										else
  										{
											num--;
											mp4->metasizes[num] = equalsamplesize;
										} while (num > 0);
 											equalsamplesize = BYTESWAP32(equalsamplesize);
 											do
 											{
 												num--;
 												mp4->metasizes[num] = equalsamplesize;
 											} while (num > 0);
 										}
  									}
  								}
 								else
 								{
 									CloseSource((size_t)mp4);
 									mp4 = NULL;
 									break;
 								}
  							}
							LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);  
 							mp4->filepos += len;
 							LongSeek(mp4, qtsize - 8 - len);  
  						}
  						else
							LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
 							LongSeek(mp4, qtsize - 8);
  						NESTSIZE(qtsize);
  					}
 					else if (qttag == MAKEID('s', 't', 'c', 'o'))  
 					{
 						if (type == traktype)  
 						{
 							len = fread(&skip, 1, 4, mp4->mediafp);
 							len += fread(&num, 1, 4, mp4->mediafp);
  							num = BYTESWAP32(num);
  							if (num * 4 <= qtsize - 8 - len)
  							{
 								uint32_t metastco_count = num;
  								if (mp4->metastsc_count > 0 && num != mp4->metasize_count)
  								{
									mp4->indexcount = mp4->metasize_count;
 									mp4->indexcount = num;
  									if (mp4->metaoffsets) free(mp4->metaoffsets);
									mp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);
									if (mp4->metaoffsets)
 									if(num > 0)
  									{
										uint32_t *metaoffsets32 = NULL;
										metaoffsets32 = (uint32_t *)malloc(num * 4);
										if (metaoffsets32)
 										mp4->metaoffsets = (uint64_t *)malloc(num * 8);
 										if (mp4->metaoffsets)
  										{
											uint64_t fileoffset = 0;
											int stsc_pos = 0;
											int stco_pos = 0;
											int repeat = 1;
											len += fread(metaoffsets32, 1, num * 4, mp4->mediafp);
											do
											{
												num--;
												metaoffsets32[num] = BYTESWAP32(metaoffsets32[num]);
											} while (num > 0);
											mp4->metaoffsets[0] = fileoffset = metaoffsets32[stco_pos];
											num = 1;
											while (num < mp4->metasize_count)
 											uint32_t *metaoffsets32 = NULL;
 											metaoffsets32 = (uint32_t *)malloc(num * 4);
 											if (metaoffsets32)
  											{
												if (stsc_pos + 1 < (int)mp4->metastsc_count && num == stsc_pos)
 												uint64_t fileoffset = 0;
 												int stsc_pos = 0;
 												int stco_pos = 0;
 												int repeat = 1;
 												len += fread(metaoffsets32, 1, num * 4, mp4->mediafp);
 												do
  												{
													stco_pos++; stsc_pos++;
													fileoffset = (uint64_t)metaoffsets32[stco_pos];
													repeat = 1;
												}
												else if (repeat == mp4->metastsc[stsc_pos].samples)
												{
													stco_pos++;
													fileoffset = (uint64_t)metaoffsets32[stco_pos];
													repeat = 1;
												}
												else
 													num--;
 													metaoffsets32[num] = BYTESWAP32(metaoffsets32[num]);
 												} while (num > 0);
 												mp4->metaoffsets[0] = fileoffset = metaoffsets32[stco_pos];
 												num = 1;
 												while (num < mp4->indexcount)
  												{
													fileoffset += (uint64_t)mp4->metasizes[num - 1];
													repeat++;
 													if ((uint32_t)repeat == mp4->metastsc[stsc_pos].samples)
 													{
 														if ((uint32_t)stco_pos + 1 < metastco_count)
 														{
 															stco_pos++;
 															fileoffset = (uint64_t)metaoffsets32[stco_pos];
 														}
 														else
 														{
 															fileoffset += (uint64_t)mp4->metasizes[num - 1];
 														}
 														if ((uint32_t)stsc_pos + 1 < mp4->metastsc_count)
 															if (mp4->metastsc[stsc_pos + 1].chunk_num == (uint32_t)stco_pos + 1)
 																stsc_pos++;
 														repeat = 1;
 													}
 													else
 													{
 														fileoffset += (uint64_t)mp4->metasizes[num - 1];
 														repeat++;
 													}
 													mp4->metaoffsets[num] = fileoffset;
 													num++;
  												}
												mp4->metaoffsets[num] = fileoffset;
 												if (mp4->metastsc) free(mp4->metastsc);
 												mp4->metastsc = NULL;
 												mp4->metastsc_count = 0;
												num++;
 												free(metaoffsets32);
  											}
											if (mp4->metastsc) free(mp4->metastsc);
											mp4->metastsc = NULL;
											mp4->metastsc_count = 0;
											free(metaoffsets32);
  										}
  									}
 									else
 									{
 										CloseSource((size_t)mp4);
 										mp4 = NULL;
 										break;
 									}
  								}
  								else
  								{
  									mp4->indexcount = num;
  									if (mp4->metaoffsets) free(mp4->metaoffsets);
									mp4->metaoffsets = (uint64_t *)malloc(num * 8);
									if (mp4->metaoffsets)
 									if (num > 0)
  									{
										uint32_t *metaoffsets32 = NULL;
										metaoffsets32 = (uint32_t *)malloc(num * 4);
										if (metaoffsets32)
 										mp4->metaoffsets = (uint64_t *)malloc(num * 8);
 										if (mp4->metaoffsets)
  										{
											size_t readlen = fread(metaoffsets32, 1, num * 4, mp4->mediafp);
											len += readlen;
											do
 											uint32_t *metaoffsets32 = NULL;
 											metaoffsets32 = (uint32_t *)malloc(num * 4);
 											if (metaoffsets32)
  											{
												num--;
												mp4->metaoffsets[num] = BYTESWAP32(metaoffsets32[num]);
											} while (num > 0);
 												size_t readlen = fread(metaoffsets32, 1, num * 4, mp4->mediafp);
 												len += readlen;
 												do
 												{
 													num--;
 													mp4->metaoffsets[num] = BYTESWAP32(metaoffsets32[num]);
 												} while (num > 0);
											free(metaoffsets32);
 												free(metaoffsets32);
 											}
  										}
  									}
 									else
 									{
 										CloseSource((size_t)mp4);
 										mp4 = NULL;
 										break;
 									}
  								}
  							}
							LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);  
 							mp4->filepos += len;
 							LongSeek(mp4, qtsize - 8 - len);  
  						}
  						else
							LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
 							LongSeek(mp4, qtsize - 8);
  						NESTSIZE(qtsize);
  					}
 					else if (qttag == MAKEID('c', 'o', '6', '4'))  
 					{
 						if (type == traktype)  
 						{
  							len = fread(&skip, 1, 4, mp4->mediafp);
  							len += fread(&num, 1, 4, mp4->mediafp);
  							num = BYTESWAP32(num);
 							if(num == 0)
 							{
 								CloseSource((size_t)mp4);
 								mp4 = NULL;
 								break;
 							}
  							if (num * 8 <= qtsize - 8 - len)
  							{
  								if (mp4->metastsc_count > 0 && num != mp4->metasize_count)
  								{
  									mp4->indexcount = mp4->metasize_count;
  									if (mp4->metaoffsets) free(mp4->metaoffsets);
									mp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);
									if (mp4->metaoffsets)
 									if (mp4->metasize_count)
  									{
										uint64_t *metaoffsets64 = NULL;
										metaoffsets64 = (uint64_t *)malloc(num * 8);
										if (metaoffsets64)
 										mp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);
 										if (mp4->metaoffsets)
  										{
											uint64_t fileoffset = 0;
											int stsc_pos = 0;
											int stco_pos = 0;
											len += fread(metaoffsets64, 1, num * 8, mp4->mediafp);
											do
 											uint64_t *metaoffsets64 = NULL;
 											metaoffsets64 = (uint64_t *)malloc(num * 8);
 											if (metaoffsets64)
  											{
												num--;
												metaoffsets64[num] = BYTESWAP64(metaoffsets64[num]);
											} while (num > 0);
 												uint64_t fileoffset = 0;
 												int stsc_pos = 0;
 												int stco_pos = 0;
 												len += fread(metaoffsets64, 1, num * 8, mp4->mediafp);
 												do
 												{
 													num--;
 													metaoffsets64[num] = BYTESWAP64(metaoffsets64[num]);
 												} while (num > 0);
											fileoffset = metaoffsets64[0];
											mp4->metaoffsets[0] = fileoffset;
 												fileoffset = metaoffsets64[0];
 												mp4->metaoffsets[0] = fileoffset;
											num = 1;
											while (num < mp4->metasize_count)
											{
												if (num != mp4->metastsc[stsc_pos].chunk_num - 1 && 0 == (num - (mp4->metastsc[stsc_pos].chunk_num - 1)) % mp4->metastsc[stsc_pos].samples)
												{
													stco_pos++;
													fileoffset = (uint64_t)metaoffsets64[stco_pos];
												}
												else
 												num = 1;
 												while (num < mp4->metasize_count)
  												{
													fileoffset += (uint64_t)mp4->metasizes[num - 1];
 													if (num != mp4->metastsc[stsc_pos].chunk_num - 1 && 0 == (num - (mp4->metastsc[stsc_pos].chunk_num - 1)) % mp4->metastsc[stsc_pos].samples)
 													{
 														stco_pos++;
 														fileoffset = (uint64_t)metaoffsets64[stco_pos];
 													}
 													else
 													{
 														fileoffset += (uint64_t)mp4->metasizes[num - 1];
 													}
 													mp4->metaoffsets[num] = fileoffset;
 													num++;
  												}
												mp4->metaoffsets[num] = fileoffset;
 												if (mp4->metastsc) free(mp4->metastsc);
 												mp4->metastsc = NULL;
 												mp4->metastsc_count = 0;
												num++;
 												free(metaoffsets64);
  											}
											if (mp4->metastsc) free(mp4->metastsc);
											mp4->metastsc = NULL;
											mp4->metastsc_count = 0;
											free(metaoffsets64);
  										}
  									}
 									else
 									{
 										CloseSource((size_t)mp4);
 										mp4 = NULL;
 										break;
 									}
  								}
  								else
  								{
 									mp4->indexcount = num;
 									if (mp4->metaoffsets) free(mp4->metaoffsets);
 									mp4->metaoffsets = (uint64_t *)malloc(num * 8);
 									if (mp4->metaoffsets)
 									{
 										len += fread(mp4->metaoffsets, 1, num * 8, mp4->mediafp);
 										do
 										{
 											num--;
 											mp4->metaoffsets[num] = BYTESWAP64(mp4->metaoffsets[num]);
 										} while (num > 0);
  									}
  								}
  							}
							LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);  
 							mp4->filepos += len;
 							LongSeek(mp4, qtsize - 8 - len);  
  						}
  						else
							LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
 							LongSeek(mp4, qtsize - 8);
  						NESTSIZE(qtsize);
  					}
 					else if (qttag == MAKEID('s', 't', 't', 's'))  
 					{
 						if (type == traktype)  
 						{
 							uint32_t totaldur = 0, samples = 0;
 							int32_t entries = 0;
 							len = fread(&skip, 1, 4, mp4->mediafp);
 							len += fread(&num, 1, 4, mp4->mediafp);
 							num = BYTESWAP32(num);
 							if (num * 8 <= qtsize - 8 - len)
 							{
 								entries = num;
 								mp4->meta_clockdemon = mp4->trak_clockdemon;
 								mp4->meta_clockcount = mp4->trak_clockcount;
 								while (entries > 0)
 								{
 									int32_t samplecount;
 									int32_t duration;
 									len += fread(&samplecount, 1, 4, mp4->mediafp);
 									samplecount = BYTESWAP32(samplecount);
 									len += fread(&duration, 1, 4, mp4->mediafp);
 									duration = BYTESWAP32(duration);
 									samples += samplecount;
 									entries--;
 									totaldur += duration;
 									mp4->metadatalength += (double)((double)samplecount * (double)duration / (double)mp4->meta_clockdemon);
  								}
  								mp4->basemetadataduration = mp4->metadatalength * (double)mp4->meta_clockdemon / (double)samples;
  							}
							LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);  
 							mp4->filepos += len;
 							LongSeek(mp4, qtsize - 8 - len);  
  						}
  						else
							LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
 							LongSeek(mp4, qtsize - 8);
  						NESTSIZE(qtsize);
  					}
 					else
 					{
 						NESTSIZE(8);
 					}
 			}
 			else
 			{
  				break;
  			}
  		} while (len > 0);
 		if (mp4)
 		{
 			if (mp4->metasizes == NULL || mp4->metaoffsets == NULL)
 			{
 				CloseSource((size_t)mp4);
 				mp4 = NULL;
 			}
 		}
  	}
  	else
  	{
 		free(mp4);
 		mp4 = NULL;
 	}
 	return (size_t)mp4;
 }","[6, 7, 8, 9, 26, 27, 28, 32, 33, 34, 35, 36, 37, 42, 43, 44, 59, 60, 61, 63, 64, 79, 80, 89, 90, 102, 103, 104, 124, 125, 126, 135, 136, 138, 139, 140, 158, 159, 160, 163, 164, 178, 179, 180, 182, 183, 184, 185, 186, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 207, 208, 209, 210, 211, 212, 215, 216, 217, 220, 221, 237, 238, 239, 241, 242, 243, 245, 246, 247, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 278, 279, 280, 281, 282, 283, 285, 286, 287, 290, 291, 303, 306, 307, 309, 310, 311, 313, 314, 315, 316, 317, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 336, 337, 338, 339, 340, 341, 342, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 388, 389, 390, 391, 392, 393, 395, 396, 397, 398, 401, 402, 403, 404, 405, 406, 412, 413, 414, 416, 417, 418, 419, 420, 422, 423, 424, 425, 426, 427, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 444, 445, 446, 447, 448, 449, 452, 453, 454, 457, 458, 468, 469, 470, 471, 472, 473, 480, 481, 482, 484, 485, 486, 487, 488, 490, 491, 492, 493, 494, 495, 496, 497, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 540, 541, 542, 543, 544, 545, 547, 548, 549, 550, 553, 554, 555, 556, 557, 558, 576, 577, 578, 581, 582, 614, 615, 616, 619, 620, 633, 634, 635, 636, 637, 638, 639, 640]",GoPro GPMF-parser 1.2.2 has an out-of-bounds write in OpenMP4Source in demo/GPMF_mp4reader.c.,gpmf-parser,CVE-2019-15148,CWE-787
43,181490," jp2_box_t *jp2_box_get(jas_stream_t *in)
 {
 	jp2_box_t *box;
 	jp2_boxinfo_t *boxinfo;
 	jas_stream_t *tmpstream;
 	uint_fast32_t len;
 	uint_fast64_t extlen;
 	bool dataflag;
  	box = 0;
  	tmpstream = 0;
	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
 	if (!(box = jp2_box_create0())) {
  		goto error;
  	}
	box->ops = &jp2_boxinfo_unk.ops;
  	if (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {
  		goto error;
  	}
  	boxinfo = jp2_boxinfolookup(box->type);
  	box->info = boxinfo;
  	box->len = len;
  	JAS_DBGLOG(10, (
	  ""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\n"",
 	  ""preliminary processing of JP2 box: ""
 	  ""type=%c%s%c (0x%08x); length=%""PRIuFAST32""\n"",
  	  '""', boxinfo->name, '""', box->type, box->len
  	  ));
  	if (box->len == 1) {
 		JAS_DBGLOG(10, (""big length\n""));
  		if (jp2_getuint64(in, &extlen)) {
  			goto error;
  		}
 		if (extlen > 0xffffffffUL) {
 			jas_eprintf(""warning: cannot handle large 64-bit box length\n"");
 			extlen = 0xffffffffUL;
 		}
 		box->len = extlen;
 		box->datalen = extlen - JP2_BOX_HDRLEN(true);
 	} else {
 		box->datalen = box->len - JP2_BOX_HDRLEN(false);
 	}
 	if (box->len != 0 && box->len < 8) {
 		goto error;
 	}
 	dataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));
 	if (dataflag) {
 		if (!(tmpstream = jas_stream_memopen(0, 0))) {
 			goto error;
 		}
 		if (jas_stream_copy(tmpstream, in, box->datalen)) {
 			jas_eprintf(""cannot copy box data\n"");
 			goto error;
 		}
 		jas_stream_rewind(tmpstream);
 		box->ops = &boxinfo->ops;
 		if (box->ops->getdata) {
 			if ((*box->ops->getdata)(box, tmpstream)) {
 				jas_eprintf(""cannot parse box data\n"");
 				goto error;
 			}
 		}
 		jas_stream_close(tmpstream);
 	}
 	if (jas_getdbglevel() >= 1) {
 		jp2_box_dump(box, stderr);
 	}
 	return box;
 error:
 	if (box) {
 		jp2_box_destroy(box);
 	}
 	if (tmpstream) {
 		jas_stream_close(tmpstream);
 	}
 	return 0;
 }","[11, 12, 15, 23, 24, 25, 29]",The jp2_cdef_destroy function in jp2_cod.c in JasPer before 2.0.13 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted image.,jasper,CVE-2017-6850,CWE-476
57,179093," void ff_jpeg2000_cleanup(Jpeg2000Component *comp, Jpeg2000CodingStyle *codsty)
 {
     int reslevelno, bandno, precno;
     for (reslevelno = 0;
          comp->reslevel && reslevelno < codsty->nreslevels;
          reslevelno++) {
         Jpeg2000ResLevel *reslevel = comp->reslevel + reslevelno;
          for (bandno = 0; bandno < reslevel->nbands; bandno++) {
              Jpeg2000Band *band = reslevel->band + bandno;
              for (precno = 0; precno < reslevel->num_precincts_x * reslevel->num_precincts_y; precno++) {
                Jpeg2000Prec *prec = band->prec + precno;
                av_freep(&prec->zerobits);
                av_freep(&prec->cblkincl);
                av_freep(&prec->cblk);
                 if (band->prec) {
                     Jpeg2000Prec *prec = band->prec + precno;
                     av_freep(&prec->zerobits);
                     av_freep(&prec->cblkincl);
                     av_freep(&prec->cblk);
                 }
              }
              av_freep(&band->prec);
         }
         av_freep(&reslevel->band);
     }
     ff_dwt_destroy(&comp->dwt);
     av_freep(&comp->reslevel);
     av_freep(&comp->i_data);
     av_freep(&comp->f_data);
 }","[11, 12, 13, 14, 15, 16, 17, 18, 19, 20]",libavcodec/jpeg2000.c in FFmpeg before 2.1 allows remote attackers to cause a denial of service (invalid pointer dereference) or possibly have unspecified other impact via crafted JPEG2000 data.,FFmpeg,CVE-2013-7017,
120,178411," void vrend_renderer_context_create_internal(uint32_t handle, uint32_t nlen,
                                             const char *debug_name)
 {
    struct vrend_decode_ctx *dctx;
     if (handle >= VREND_MAX_CTX)
        return;
    dctx = dec_ctx[handle];
    if (dctx)
       return;
     dctx = malloc(sizeof(struct vrend_decode_ctx));
     if (!dctx)
        return;
       return;
    }","[7, 8, 9]",Memory leak in the vrend_renderer_context_create_internal function in vrend_decode.c in virglrenderer before 0.6.0 allows local guest OS users to cause a denial of service (host memory consumption) by repeatedly creating a decode context.,virglrenderer,CVE-2016-10163,CWE-399
173,182228," gpk_parse_fileinfo(sc_card_t *card,
 		const u8 *buf, size_t buflen,
 		sc_file_t *file)
 {
 	const u8	*sp, *end, *next;
 	int		i, rc;
 	memset(file, 0, sizeof(*file));
 	for (i = 0; i < SC_MAX_AC_OPS; i++)
 		sc_file_add_acl_entry(file, i, SC_AC_UNKNOWN, SC_AC_KEY_REF_NONE);
 	end = buf + buflen;
 	for (sp = buf; sp + 2 < end; sp = next) {
 		next = sp + 2 + sp[1];
 		if (next > end)
 			break;
 		if (sp[0] == 0x84) {
 			if (sp[1] > sizeof(file->name))
 				continue;
 			memset(file->name, 0, sizeof(file->name));
 			memcpy(file->name, sp+2, sp[1]);
 		} else
  		if (sp[0] == 0x85) {
  			unsigned int	ac[3], n;
 			if (sp + 11 + 2*3 >= end)
 				break;
  			file->id = (sp[4] << 8) | sp[5];
  			file->size = (sp[8] << 8) | sp[9];
  			file->record_length = sp[7];
 			for (n = 0; n < 3; n++)
 				ac[n] = (sp[10+2*n] << 8) | sp[11+2*n];
 			switch (sp[6] & 7) {
 			case 0x01: case 0x02: case 0x03: case 0x04:
 			case 0x05: case 0x06: case 0x07:
 				file->type = SC_FILE_TYPE_WORKING_EF;
 				file->ef_structure = sp[6] & 7;
 				ac_to_acl(ac[0], file, SC_AC_OP_UPDATE);
 				ac_to_acl(ac[1], file, SC_AC_OP_WRITE);
 				ac_to_acl(ac[2], file, SC_AC_OP_READ);
 				break;
 			case 0x00:  
 				file->type = SC_FILE_TYPE_DF;
 				ac_to_acl(ac[0], file, SC_AC_OP_LOCK);
 				ac_to_acl(ac[1], file, SC_AC_OP_CREATE);
 				sc_file_add_acl_entry(file, SC_AC_OP_SELECT,
 					SC_AC_NONE, SC_AC_KEY_REF_NONE);
 				sc_file_add_acl_entry(file, SC_AC_OP_DELETE,
 					SC_AC_NEVER, SC_AC_KEY_REF_NONE);
 				sc_file_add_acl_entry(file, SC_AC_OP_REHABILITATE,
 					SC_AC_NEVER, SC_AC_KEY_REF_NONE);
 				sc_file_add_acl_entry(file, SC_AC_OP_INVALIDATE,
 					SC_AC_NEVER, SC_AC_KEY_REF_NONE);
 				sc_file_add_acl_entry(file, SC_AC_OP_LIST_FILES,
 					SC_AC_NEVER, SC_AC_KEY_REF_NONE);
 				break;
 			}
 		} else
 		if (sp[0] == 0x6f) {
 			file->type = SC_FILE_TYPE_DF;
 			rc = gpk_parse_fci(card, sp + 2, sp[1], file);
 			if (rc < 0)
 				return rc;
 		}
 	}
 	if (file->record_length)
 		file->record_count = file->size / file->record_length;
 	file->magic = SC_FILE_MAGIC;
 	return 0;
 }","[23, 24]",Various out of bounds reads when handling responses in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to potentially crash the opensc library using programs.,OpenSC,CVE-2018-16427,CWE-125
213,181865," static jas_image_cmpt_t *jas_image_cmpt_create(int_fast32_t tlx,
   int_fast32_t tly, int_fast32_t hstep, int_fast32_t vstep,
   int_fast32_t width, int_fast32_t height, uint_fast16_t depth, bool sgnd,
   uint_fast32_t inmem)
 {
  	jas_image_cmpt_t *cmpt;
  	size_t size;
 	JAS_DBGLOG(100, (
 	  ""jas_image_cmpt_create(%ld, %ld, %ld, %ld, %ld, %ld, %d, %d, %d)\n"",
 	  JAS_CAST(long, tlx),
 	  JAS_CAST(long, tly),
 	  JAS_CAST(long, hstep),
 	  JAS_CAST(long, vstep),
 	  JAS_CAST(long, width),
 	  JAS_CAST(long, height),
 	  JAS_CAST(int, depth),
 	  sgnd,
 	  inmem
 	  ));
  	cmpt = 0;
  	if (width < 0 || height < 0 || hstep <= 0 || vstep <= 0) {
  		goto error;
 	}
 	if (!jas_safe_intfast32_add(tlx, width, 0) ||
  	  !jas_safe_intfast32_add(tly, height, 0)) {
  		goto error;
  	}
 	if (!jas_safe_intfast32_mul3(width, height, depth, 0)) {
 		goto error;
 	}
  	if (!(cmpt = jas_malloc(sizeof(jas_image_cmpt_t)))) {
  		goto error;
 	}
 	cmpt->type_ = JAS_IMAGE_CT_UNKNOWN;
 	cmpt->tlx_ = tlx;
 	cmpt->tly_ = tly;
 	cmpt->hstep_ = hstep;
 	cmpt->vstep_ = vstep;
 	cmpt->width_ = width;
 	cmpt->height_ = height;
 	cmpt->prec_ = depth;
 	cmpt->sgnd_ = sgnd;
 	cmpt->stream_ = 0;
 	cmpt->cps_ = (depth + 7) / 8;
	if (!jas_safe_size_mul(cmpt->width_, cmpt->height_, &size) ||
	  !jas_safe_size_mul(size, cmpt->cps_, &size)) {
 	if (!jas_safe_size_mul3(cmpt->width_, cmpt->height_, cmpt->cps_, &size)) {
  		goto error;
  	}
  	cmpt->stream_ = (inmem) ? jas_stream_memopen2(0, size) :
 	  jas_stream_tmpfile();
 	if (!cmpt->stream_) {
 		goto error;
 	}
 	if (size > 0) {
 		if (size - 1 > LONG_MAX) {
 			goto error;
 		}
 		if (jas_stream_seek(cmpt->stream_, size - 1, SEEK_SET) < 0 ||
 		  jas_stream_putc(cmpt->stream_, 0) == EOF ||
 		  jas_stream_seek(cmpt->stream_, 0, SEEK_SET) < 0) {
 			goto error;
 		}
 	}
 	return cmpt;
 error:
 	if (cmpt) {
 		jas_image_cmpt_destroy(cmpt);
 	}
 	return 0;
 }","[8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 28, 29, 30, 45, 46, 47]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
221,182223," coolkey_find_attribute(sc_card_t *card, sc_cardctl_coolkey_attribute_t *attribute)
 {
 	u8 object_record_type;
 	CK_ATTRIBUTE_TYPE attr_type = attribute->attribute_type;
 	const u8 *obj = attribute->object->data;
 	const u8 *attr = NULL;
 	size_t buf_len = attribute->object->length;
 	coolkey_object_header_t *object_head;
 	int attribute_count,i;
 	attribute->attribute_data_type = SC_CARDCTL_COOLKEY_ATTR_TYPE_STRING;
 	attribute->attribute_length = 0;
 	attribute->attribute_value = NULL;
 	if (obj == NULL) {
 		int r = coolkey_fill_object(card, (sc_cardctl_coolkey_object_t *)attribute->object);
 		if (r < 0) {
 			return r;
 		}
 		obj = attribute->object->data;
 	}
 	assert(sizeof(coolkey_object_header_t) >= sizeof(coolkey_v0_object_header_t));
 	if (buf_len <= sizeof(coolkey_v0_object_header_t)) {
 		return SC_ERROR_CORRUPTED_DATA;
 	}
 	object_head = (coolkey_object_header_t *)obj;
 	object_record_type = object_head->record_type;
 	if ((object_record_type != COOLKEY_V1_OBJECT) && (object_record_type != COOLKEY_V0_OBJECT)) {
 		return SC_ERROR_CORRUPTED_DATA;
 	}
 	attr = coolkey_attribute_start(obj, object_record_type, buf_len);
 	if (attr == NULL) {
 		return SC_ERROR_CORRUPTED_DATA;
 	}
 	buf_len -= (attr-obj);
 	attribute_count = coolkey_get_attribute_count(obj, object_record_type, buf_len);
  	for (i=0; i < attribute_count; i++) {
  		size_t record_len = coolkey_get_attribute_record_len(attr, object_record_type, buf_len);
		if (buf_len < record_len) {
 		if (buf_len < record_len || record_len < 4) {
  				return SC_ERROR_CORRUPTED_DATA;
  		}
 		if (attr_type == coolkey_get_attribute_type(attr, object_record_type, record_len)) {
 			return coolkey_get_attribute_data(attr, object_record_type, record_len, attribute);
 		}
 		buf_len -= record_len;
 		attr += record_len;
 	}
 	if (object_record_type == COOLKEY_V1_OBJECT) {
 		unsigned long fixed_attributes = bebytes2ulong(object_head->fixed_attributes_values);
 		return coolkey_get_attribute_data_fixed(attr_type, fixed_attributes, attribute);
 	}
 	return SC_ERROR_DATA_OBJECT_NOT_FOUND;
 }","[37, 38]",Various out of bounds reads when handling responses in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to potentially crash the opensc library using programs.,OpenSC,CVE-2018-16427,CWE-125
231,181937,"  next_line(struct archive_read *a,
      const char **b, ssize_t *avail, ssize_t *ravail, ssize_t *nl)
 {
 	ssize_t len;
 	int quit;
 	quit = 0;
 	if (*avail == 0) {
 		*nl = 0;
 		len = 0;
 	} else
 		len = get_line_size(*b, *avail, nl);
 	while (*nl == 0 && len == *avail && !quit) {
 		ssize_t diff = *ravail - *avail;
 		size_t nbytes_req = (*ravail+1023) & ~1023U;
 		ssize_t tested;
 		if (nbytes_req < (size_t)*ravail + 160)
 			nbytes_req <<= 1;
 		*b = __archive_read_ahead(a, nbytes_req, avail);
 		if (*b == NULL) {
 			if (*ravail >= *avail)
 				return (0);
 			*b = __archive_read_ahead(a, *avail, avail);
 			quit = 1;
 		}
 		*ravail = *avail;
  		*b += diff;
  		*avail -= diff;
  		tested = len; 
		len = get_line_size(*b, *avail, nl);
 		len = get_line_size(*b + len, *avail - len, nl);
  		if (len >= 0)
  			len += tested;
  	}
 	return (len);
 }","[29, 30]","The mtree bidder in libarchive 3.2.1 does not keep track of line sizes when extending the read-ahead, which allows remote attackers to cause a denial of service (crash) via a crafted file, which triggers an invalid read in the (1) detect_form or (2) bid_entry function in libarchive/archive_read_support_format_mtree.c.",libarchive,CVE-2016-8688,CWE-125
287,181492," static int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)
  {
  	jp2_bpcc_t *bpcc = &box->data.bpcc;
  	unsigned int i;
 	bpcc->bpcs = 0;
  	bpcc->numcmpts = box->datalen;
  	if (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts, sizeof(uint_fast8_t)))) {
  		return -1;
 	}
 	for (i = 0; i < bpcc->numcmpts; ++i) {
 		if (jp2_getuint8(in, &bpcc->bpcs[i])) {
 			return -1;
 		}
 	}
 	return 0;
 }",[5],The jp2_cdef_destroy function in jp2_cod.c in JasPer before 2.0.13 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted image.,jasper,CVE-2017-6850,CWE-476
305,179095," static int get_siz(Jpeg2000DecoderContext *s)
 {
     int i;
     int ncomponents;
     uint32_t log2_chroma_wh = 0;
     const enum AVPixelFormat *possible_fmts = NULL;
     int possible_fmts_nb = 0;
     if (bytestream2_get_bytes_left(&s->g) < 36)
         return AVERROR_INVALIDDATA;
     s->avctx->profile = bytestream2_get_be16u(&s->g);  
     s->width          = bytestream2_get_be32u(&s->g);  
     s->height         = bytestream2_get_be32u(&s->g);  
     s->image_offset_x = bytestream2_get_be32u(&s->g);  
     s->image_offset_y = bytestream2_get_be32u(&s->g);  
     s->tile_width     = bytestream2_get_be32u(&s->g);  
     s->tile_height    = bytestream2_get_be32u(&s->g);  
     s->tile_offset_x  = bytestream2_get_be32u(&s->g);  
     s->tile_offset_y  = bytestream2_get_be32u(&s->g);  
     ncomponents       = bytestream2_get_be16u(&s->g);  
     if (ncomponents <= 0) {
         av_log(s->avctx, AV_LOG_ERROR, ""Invalid number of components: %d\n"",
                s->ncomponents);
         return AVERROR_INVALIDDATA;
     }
     if (ncomponents > 4) {
         avpriv_request_sample(s->avctx, ""Support for %d components"",
                               s->ncomponents);
         return AVERROR_PATCHWELCOME;
     }
     s->ncomponents = ncomponents;
     if (s->tile_width <= 0 || s->tile_height <= 0) {
         av_log(s->avctx, AV_LOG_ERROR, ""Invalid tile dimension %dx%d.\n"",
                s->tile_width, s->tile_height);
         return AVERROR_INVALIDDATA;
     }
     if (bytestream2_get_bytes_left(&s->g) < 3 * s->ncomponents)
         return AVERROR_INVALIDDATA;
     for (i = 0; i < s->ncomponents; i++) {  
         uint8_t x    = bytestream2_get_byteu(&s->g);
         s->cbps[i]   = (x & 0x7f) + 1;
         s->precision = FFMAX(s->cbps[i], s->precision);
          s->sgnd[i]   = !!(x & 0x80);
          s->cdx[i]    = bytestream2_get_byteu(&s->g);
          s->cdy[i]    = bytestream2_get_byteu(&s->g);
        if (!s->cdx[i] || !s->cdy[i]) {
         if (   !s->cdx[i] || s->cdx[i] == 3 || s->cdx[i] > 4
             || !s->cdy[i] || s->cdy[i] == 3 || s->cdy[i] > 4) {
              av_log(s->avctx, AV_LOG_ERROR, ""Invalid sample seperation\n"");
              return AVERROR_INVALIDDATA;
          }
         log2_chroma_wh |= s->cdy[i] >> 1 << i * 4 | s->cdx[i] >> 1 << i * 4 + 2;
     }
     s->numXtiles = ff_jpeg2000_ceildiv(s->width  - s->tile_offset_x, s->tile_width);
     s->numYtiles = ff_jpeg2000_ceildiv(s->height - s->tile_offset_y, s->tile_height);
     if (s->numXtiles * (uint64_t)s->numYtiles > INT_MAX/sizeof(*s->tile)) {
         s->numXtiles = s->numYtiles = 0;
         return AVERROR(EINVAL);
     }
     s->tile = av_mallocz_array(s->numXtiles * s->numYtiles, sizeof(*s->tile));
     if (!s->tile) {
         s->numXtiles = s->numYtiles = 0;
         return AVERROR(ENOMEM);
     }
     for (i = 0; i < s->numXtiles * s->numYtiles; i++) {
         Jpeg2000Tile *tile = s->tile + i;
         tile->comp = av_mallocz(s->ncomponents * sizeof(*tile->comp));
         if (!tile->comp)
             return AVERROR(ENOMEM);
     }
     s->avctx->width  = ff_jpeg2000_ceildivpow2(s->width  - s->image_offset_x,
                                                s->reduction_factor);
     s->avctx->height = ff_jpeg2000_ceildivpow2(s->height - s->image_offset_y,
                                                s->reduction_factor);
     if (s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_2K ||
         s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_4K) {
         possible_fmts = xyz_pix_fmts;
         possible_fmts_nb = FF_ARRAY_ELEMS(xyz_pix_fmts);
     } else {
         switch (s->colour_space) {
         case 16:
             possible_fmts = rgb_pix_fmts;
             possible_fmts_nb = FF_ARRAY_ELEMS(rgb_pix_fmts);
             break;
         case 17:
             possible_fmts = gray_pix_fmts;
             possible_fmts_nb = FF_ARRAY_ELEMS(gray_pix_fmts);
             break;
         case 18:
             possible_fmts = yuv_pix_fmts;
             possible_fmts_nb = FF_ARRAY_ELEMS(yuv_pix_fmts);
             break;
         default:
             possible_fmts = all_pix_fmts;
             possible_fmts_nb = FF_ARRAY_ELEMS(all_pix_fmts);
             break;
         }
     }
     for (i = 0; i < possible_fmts_nb; ++i) {
         if (pix_fmt_match(possible_fmts[i], ncomponents, s->precision, log2_chroma_wh, s->pal8)) {
             s->avctx->pix_fmt = possible_fmts[i];
             break;
         }
     }
     if (s->avctx->pix_fmt == AV_PIX_FMT_NONE) {
         av_log(s->avctx, AV_LOG_ERROR,
                ""Unknown pix_fmt, profile: %d, colour_space: %d, ""
                ""components: %d, precision: %d, ""
                ""cdx[1]: %d, cdy[1]: %d, cdx[2]: %d, cdy[2]: %d\n"",
                s->avctx->profile, s->colour_space, ncomponents, s->precision,
                ncomponents > 2 ? s->cdx[1] : 0,
                ncomponents > 2 ? s->cdy[1] : 0,
                ncomponents > 2 ? s->cdx[2] : 0,
                ncomponents > 2 ? s->cdy[2] : 0);
     }
     return 0;
 }","[45, 46, 47]","The get_siz function in libavcodec/jpeg2000dec.c in FFmpeg before 2.1 does not ensure the expected sample separation, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted JPEG2000 data.",FFmpeg,CVE-2013-7016,CWE-119
315,182389," void _jsvTrace(JsVar *var, int indent, JsVar *baseVar, int level) {
 #ifdef SAVE_ON_FLASH
   jsiConsolePrint(""Trace unimplemented in this version.\n"");
 #else
   int i;
   for (i=0;i<indent;i++) jsiConsolePrint("" "");
   if (!var) {
     jsiConsolePrint(""undefined"");
     return;
   }
   jsvTraceLockInfo(var);
   int lowestLevel = _jsvTraceGetLowestLevel(baseVar, var);
   if (lowestLevel < level) {
     jsiConsolePrint(""...\n"");
     return;
   }
   if (jsvIsName(var)) jsiConsolePrint(""Name "");
   char endBracket = ' ';
   if (jsvIsObject(var)) { jsiConsolePrint(""Object { ""); endBracket = '}'; }
   else if (jsvIsArray(var)) { jsiConsolePrintf(""Array(%d) [ "", var->varData.integer); endBracket = ']'; }
   else if (jsvIsNativeFunction(var)) { jsiConsolePrintf(""NativeFunction 0x%x (%d) { "", var->varData.native.ptr, var->varData.native.argTypes); endBracket = '}'; }
   else if (jsvIsFunction(var)) {
     jsiConsolePrint(""Function { "");
     if (jsvIsFunctionReturn(var)) jsiConsolePrint(""return "");
     endBracket = '}';
   } else if (jsvIsPin(var)) jsiConsolePrintf(""Pin %d"", jsvGetInteger(var));
   else if (jsvIsInt(var)) jsiConsolePrintf(""Integer %d"", jsvGetInteger(var));
   else if (jsvIsBoolean(var)) jsiConsolePrintf(""Bool %s"", jsvGetBool(var)?""true"":""false"");
    else if (jsvIsFloat(var)) jsiConsolePrintf(""Double %f"", jsvGetFloat(var));
    else if (jsvIsFunctionParameter(var)) jsiConsolePrintf(""Param %q "", var);
    else if (jsvIsArrayBufferName(var)) jsiConsolePrintf(""ArrayBufferName[%d] "", jsvGetInteger(var));
  else if (jsvIsArrayBuffer(var)) jsiConsolePrintf(""%s "", jswGetBasicObjectName(var));  
   else if (jsvIsArrayBuffer(var)) jsiConsolePrintf(""%s "", jswGetBasicObjectName(var)?jswGetBasicObjectName(var):""unknown ArrayBuffer"");  
    else if (jsvIsString(var)) {
      size_t blocks = 1;
      if (jsvGetLastChild(var)) {
       JsVar *v = jsvLock(jsvGetLastChild(var));
       blocks += jsvCountJsVarsUsed(v);
       jsvUnLock(v);
     }
     if (jsvIsFlatString(var)) {
       blocks += jsvGetFlatStringBlocks(var);
     }
     jsiConsolePrintf(""%sString [%d blocks] %q"", jsvIsFlatString(var)?""Flat"":(jsvIsNativeString(var)?""Native"":""""), blocks, var);
   } else {
     jsiConsolePrintf(""Unknown %d"", var->flags & (JsVarFlags)~(JSV_LOCK_MASK));
   }
   if (jsvIsNameInt(var)) {
     jsiConsolePrintf(""= int %d\n"", (int)jsvGetFirstChildSigned(var));
     return;
   } else if (jsvIsNameIntBool(var)) {
     jsiConsolePrintf(""= bool %s\n"", jsvGetFirstChild(var)?""true"":""false"");
     return;
   }
   if (jsvHasSingleChild(var)) {
     JsVar *child = jsvGetFirstChild(var) ? jsvLock(jsvGetFirstChild(var)) : 0;
     _jsvTrace(child, indent+2, baseVar, level+1);
     jsvUnLock(child);
   } else if (jsvHasChildren(var)) {
     JsvIterator it;
     jsvIteratorNew(&it, var, JSIF_DEFINED_ARRAY_ElEMENTS);
     bool first = true;
     while (jsvIteratorHasElement(&it) && !jspIsInterrupted()) {
       if (first) jsiConsolePrintf(""\n"");
       first = false;
       JsVar *child = jsvIteratorGetKey(&it);
       _jsvTrace(child, indent+2, baseVar, level+1);
       jsvUnLock(child);
       jsiConsolePrintf(""\n"");
       jsvIteratorNext(&it);
     }
     jsvIteratorFree(&it);
     if (!first)
       for (i=0;i<indent;i++) jsiConsolePrint("" "");
   }
   jsiConsolePrintf(""%c"", endBracket);
 #endif
 }","[32, 33]",Espruino before 1.98 allows attackers to cause a denial of service (application crash) with a user crafted input file via a NULL pointer dereference during syntax parsing. This was addressed by adding validation for a debug trace print statement in jsvar.c.,Espruino,CVE-2018-11591,CWE-476
335,182380," NO_INLINE JsVar *jspeArrowFunction(JsVar *funcVar, JsVar *a) {
   assert(!a || jsvIsName(a));
   JSP_ASSERT_MATCH(LEX_ARROW_FUNCTION);
   funcVar = jspeAddNamedFunctionParameter(funcVar, a);
   bool expressionOnly = lex->tk!='{';
   jspeFunctionDefinitionInternal(funcVar, expressionOnly);
   if (execInfo.thisVar) {
     jsvObjectSetChild(funcVar, JSPARSE_FUNCTION_THIS_NAME, execInfo.thisVar);
   }
   return funcVar;
 }
 NO_INLINE JsVar *jspeExpressionOrArrowFunction() {
   JsVar *a = 0;
   JsVar *funcVar = 0;
   bool allNames = true;
   while (lex->tk!=')' && !JSP_SHOULDNT_PARSE) {
     if (allNames && a) {
       funcVar = jspeAddNamedFunctionParameter(funcVar, a);
     }
     jsvUnLock(a);
     a = jspeAssignmentExpression();
     if (!(jsvIsName(a) && jsvIsString(a))) allNames = false;
     if (lex->tk!=')') JSP_MATCH_WITH_CLEANUP_AND_RETURN(',', jsvUnLock2(a,funcVar), 0);
   }
   JSP_MATCH_WITH_CLEANUP_AND_RETURN(')', jsvUnLock2(a,funcVar), 0);
   if (allNames && lex->tk==LEX_ARROW_FUNCTION) {
     funcVar = jspeArrowFunction(funcVar, a);
     jsvUnLock(a);
     return funcVar;
   } else {
     jsvUnLock(funcVar);
     return a;
   }
 }
 NO_INLINE JsVar *jspeClassDefinition(bool parseNamedClass) {
   JsVar *classFunction = 0;
   JsVar *classPrototype = 0;
   JsVar *classInternalName = 0;
   bool actuallyCreateClass = JSP_SHOULD_EXECUTE;
   if (actuallyCreateClass)
     classFunction = jsvNewWithFlags(JSV_FUNCTION);
   if (parseNamedClass && lex->tk==LEX_ID) {
     if (classFunction)
       classInternalName = jslGetTokenValueAsVar(lex);
     JSP_ASSERT_MATCH(LEX_ID);
   }
   if (classFunction) {
     JsVar *prototypeName = jsvFindChildFromString(classFunction, JSPARSE_PROTOTYPE_VAR, true);
     jspEnsureIsPrototype(classFunction, prototypeName);  
     classPrototype = jsvSkipName(prototypeName);
     jsvUnLock(prototypeName);
   }
   if (lex->tk==LEX_R_EXTENDS) {
     JSP_ASSERT_MATCH(LEX_R_EXTENDS);
     JsVar *extendsFrom = actuallyCreateClass ? jsvSkipNameAndUnLock(jspGetNamedVariable(jslGetTokenValueAsString(lex))) : 0;
     JSP_MATCH_WITH_CLEANUP_AND_RETURN(LEX_ID,jsvUnLock4(extendsFrom,classFunction,classInternalName,classPrototype),0);
     if (classPrototype) {
       if (jsvIsFunction(extendsFrom)) {
         jsvObjectSetChild(classPrototype, JSPARSE_INHERITS_VAR, extendsFrom);
         jsvObjectSetChildAndUnLock(classFunction, JSPARSE_FUNCTION_CODE_NAME, jsvNewFromString(""if(this.__proto__.__proto__)this.__proto__.__proto__.apply(this,arguments)""));
       } else
         jsExceptionHere(JSET_SYNTAXERROR, ""'extends' argument should be a function, got %t"", extendsFrom);
     }
     jsvUnLock(extendsFrom);
   }
   JSP_MATCH_WITH_CLEANUP_AND_RETURN('{',jsvUnLock3(classFunction,classInternalName,classPrototype),0);
   while ((lex->tk==LEX_ID || lex->tk==LEX_R_STATIC) && !jspIsInterrupted()) {
     bool isStatic = lex->tk==LEX_R_STATIC;
     if (isStatic) JSP_ASSERT_MATCH(LEX_R_STATIC);
     JsVar *funcName = jslGetTokenValueAsVar(lex);
     JSP_MATCH_WITH_CLEANUP_AND_RETURN(LEX_ID,jsvUnLock3(classFunction,classInternalName,classPrototype),0);
     JsVar *method = jspeFunctionDefinition(false);
     if (classFunction && classPrototype) {
       if (jsvIsStringEqual(funcName, ""get"") || jsvIsStringEqual(funcName, ""set"")) {
         jsExceptionHere(JSET_SYNTAXERROR, ""'get' and 'set' and not supported in Espruino"");
       } else if (jsvIsStringEqual(funcName, ""constructor"")) {
         jswrap_function_replaceWith(classFunction, method);
       } else {
         funcName = jsvMakeIntoVariableName(funcName, 0);
         jsvSetValueOfName(funcName, method);
         jsvAddName(isStatic ? classFunction : classPrototype, funcName);
       }
     }
     jsvUnLock2(method,funcName);
   }
   jsvUnLock(classPrototype);
   if (classInternalName)
     jsvObjectSetChildAndUnLock(classFunction, JSPARSE_FUNCTION_NAME_NAME, classInternalName);
   JSP_MATCH_WITH_CLEANUP_AND_RETURN('}',jsvUnLock(classFunction),0);
   return classFunction;
 }
 #endif
 NO_INLINE JsVar *jspeFactor() {
   if (lex->tk==LEX_ID) {
     JsVar *a = jspGetNamedVariable(jslGetTokenValueAsString(lex));
     JSP_ASSERT_MATCH(LEX_ID);
 #ifndef SAVE_ON_FLASH
     if (lex->tk==LEX_TEMPLATE_LITERAL)
       jsExceptionHere(JSET_SYNTAXERROR, ""Tagged template literals not supported"");
     else if (lex->tk==LEX_ARROW_FUNCTION && jsvIsName(a)) {
       JsVar *funcVar = jspeArrowFunction(0,a);
       jsvUnLock(a);
       a=funcVar;
     }
 #endif
     return a;
   } else if (lex->tk==LEX_INT) {
     JsVar *v = 0;
     if (JSP_SHOULD_EXECUTE) {
       v = jsvNewFromLongInteger(stringToInt(jslGetTokenValueAsString(lex)));
     }
     JSP_ASSERT_MATCH(LEX_INT);
     return v;
   } else if (lex->tk==LEX_FLOAT) {
     JsVar *v = 0;
     if (JSP_SHOULD_EXECUTE) {
       v = jsvNewFromFloat(stringToFloat(jslGetTokenValueAsString(lex)));
     }
     JSP_ASSERT_MATCH(LEX_FLOAT);
     return v;
   } else if (lex->tk=='(') {
     JSP_ASSERT_MATCH('(');
     if (!jspCheckStackPosition()) return 0;
 #ifdef SAVE_ON_FLASH
     JsVar *a = jspeExpression();
     if (!JSP_SHOULDNT_PARSE) JSP_MATCH_WITH_RETURN(')',a);
     return a;
 #else
     return jspeExpressionOrArrowFunction();
 #endif
   } else if (lex->tk==LEX_R_TRUE) {
     JSP_ASSERT_MATCH(LEX_R_TRUE);
     return JSP_SHOULD_EXECUTE ? jsvNewFromBool(true) : 0;
   } else if (lex->tk==LEX_R_FALSE) {
     JSP_ASSERT_MATCH(LEX_R_FALSE);
     return JSP_SHOULD_EXECUTE ? jsvNewFromBool(false) : 0;
   } else if (lex->tk==LEX_R_NULL) {
     JSP_ASSERT_MATCH(LEX_R_NULL);
     return JSP_SHOULD_EXECUTE ? jsvNewWithFlags(JSV_NULL) : 0;
   } else if (lex->tk==LEX_R_UNDEFINED) {
     JSP_ASSERT_MATCH(LEX_R_UNDEFINED);
     return 0;
   } else if (lex->tk==LEX_STR) {
     JsVar *a = 0;
     if (JSP_SHOULD_EXECUTE)
       a = jslGetTokenValueAsVar(lex);
     JSP_ASSERT_MATCH(LEX_STR);
     return a;
 #ifndef SAVE_ON_FLASH
   } else if (lex->tk==LEX_TEMPLATE_LITERAL) {
     return jspeTemplateLiteral();
 #endif
   } else if (lex->tk==LEX_REGEX) {
     JsVar *a = 0;
 #ifdef SAVE_ON_FLASH
     jsExceptionHere(JSET_SYNTAXERROR, ""RegEx are not supported in this version of Espruino\n"");
 #else
     JsVar *regex = jslGetTokenValueAsVar(lex);
     size_t regexEnd = 0, regexLen = 0;
     JsvStringIterator it;
     jsvStringIteratorNew(&it, regex, 0);
     while (jsvStringIteratorHasChar(&it)) {
       regexLen++;
       if (jsvStringIteratorGetChar(&it)=='/')
         regexEnd = regexLen;
       jsvStringIteratorNext(&it);
     }
     jsvStringIteratorFree(&it);
     JsVar *flags = 0;
     if (regexEnd < regexLen)
       flags = jsvNewFromStringVar(regex, regexEnd, JSVAPPENDSTRINGVAR_MAXLENGTH);
     JsVar *regexSource = jsvNewFromStringVar(regex, 1, regexEnd-2);
     a = jswrap_regexp_constructor(regexSource, flags);
     jsvUnLock3(regex, flags, regexSource);
 #endif
     JSP_ASSERT_MATCH(LEX_REGEX);
     return a;
   } else if (lex->tk=='{') {
     if (!jspCheckStackPosition()) return 0;
     return jspeFactorObject();
   } else if (lex->tk=='[') {
     if (!jspCheckStackPosition()) return 0;
     return jspeFactorArray();
   } else if (lex->tk==LEX_R_FUNCTION) {
     if (!jspCheckStackPosition()) return 0;
     JSP_ASSERT_MATCH(LEX_R_FUNCTION);
     return jspeFunctionDefinition(true);
 #ifndef SAVE_ON_FLASH
   } else if (lex->tk==LEX_R_CLASS) {
     if (!jspCheckStackPosition()) return 0;
     JSP_ASSERT_MATCH(LEX_R_CLASS);
     return jspeClassDefinition(true);
   } else if (lex->tk==LEX_R_SUPER) {
     JSP_ASSERT_MATCH(LEX_R_SUPER);
     if (jsvIsObject(execInfo.thisVar)) {
       JsVar *proto1 = jsvObjectGetChild(execInfo.thisVar, JSPARSE_INHERITS_VAR, 0);  
       JsVar *proto2 = jsvIsObject(proto1) ? jsvObjectGetChild(proto1, JSPARSE_INHERITS_VAR, 0) : 0;  
       jsvUnLock(proto1);
       if (!proto2) {
         jsExceptionHere(JSET_SYNTAXERROR, ""Calling 'super' outside of class"");
         return 0;
       }
       if (lex->tk=='(') return proto2;  
       JsVar *proto3 = jsvIsFunction(proto2) ? jsvObjectGetChild(proto2, JSPARSE_PROTOTYPE_VAR, 0) : 0;
       jsvUnLock(proto2);
       return proto3;
     } else if (jsvIsFunction(execInfo.thisVar)) {
       JsVar *proto1 = jsvObjectGetChild(execInfo.thisVar, JSPARSE_PROTOTYPE_VAR, 0);
       JsVar *proto2 = jsvIsObject(proto1) ? jsvObjectGetChild(proto1, JSPARSE_INHERITS_VAR, 0) : 0;
       jsvUnLock(proto1);
       if (!proto2) {
         jsExceptionHere(JSET_SYNTAXERROR, ""Calling 'super' outside of class"");
         return 0;
       }
       return proto2;
     }
     jsExceptionHere(JSET_SYNTAXERROR, ""Calling 'super' outside of class"");
     return 0;
 #endif
   } else if (lex->tk==LEX_R_THIS) {
     JSP_ASSERT_MATCH(LEX_R_THIS);
     return jsvLockAgain( execInfo.thisVar ? execInfo.thisVar : execInfo.root );
   } else if (lex->tk==LEX_R_DELETE) {
     if (!jspCheckStackPosition()) return 0;
     return jspeFactorDelete();
   } else if (lex->tk==LEX_R_TYPEOF) {
     if (!jspCheckStackPosition()) return 0;
     return jspeFactorTypeOf();
   } else if (lex->tk==LEX_R_VOID) {
     if (!jspCheckStackPosition()) return 0;
     JSP_ASSERT_MATCH(LEX_R_VOID);
     jsvUnLock(jspeUnaryExpression());
     return 0;
   }
   JSP_MATCH(LEX_EOF);
   jsExceptionHere(JSET_SYNTAXERROR, ""Unexpected end of Input\n"");
   return 0;
 }
 NO_INLINE JsVar *__jspePostfixExpression(JsVar *a) {
   while (lex->tk==LEX_PLUSPLUS || lex->tk==LEX_MINUSMINUS) {
     int op = lex->tk;
     JSP_ASSERT_MATCH(op);
     if (JSP_SHOULD_EXECUTE) {
       JsVar *one = jsvNewFromInteger(1);
       JsVar *oldValue = jsvAsNumberAndUnLock(jsvSkipName(a));  
       JsVar *res = jsvMathsOpSkipNames(oldValue, one, op==LEX_PLUSPLUS ? '+' : '-');
       jsvUnLock(one);
       jspReplaceWith(a, res);
       jsvUnLock(res);
       jsvUnLock(a);
       a = oldValue;
     }
   }
   return a;
 }
 NO_INLINE JsVar *jspePostfixExpression() {
   JsVar *a;
   if (lex->tk==LEX_PLUSPLUS || lex->tk==LEX_MINUSMINUS) {
     int op = lex->tk;
     JSP_ASSERT_MATCH(op);
     a = jspePostfixExpression();
     if (JSP_SHOULD_EXECUTE) {
       JsVar *one = jsvNewFromInteger(1);
       JsVar *res = jsvMathsOpSkipNames(a, one, op==LEX_PLUSPLUS ? '+' : '-');
       jsvUnLock(one);
       jspReplaceWith(a, res);
       jsvUnLock(res);
     }
   } else
     a = jspeFactorFunctionCall();
   return __jspePostfixExpression(a);
 }
 NO_INLINE JsVar *jspeUnaryExpression() {
   if (lex->tk=='!' || lex->tk=='~' || lex->tk=='-' || lex->tk=='+') {
     short tk = lex->tk;
     JSP_ASSERT_MATCH(tk);
     if (!JSP_SHOULD_EXECUTE) {
       return jspeUnaryExpression();
     }
     if (tk=='!') {  
       return jsvNewFromBool(!jsvGetBoolAndUnLock(jsvSkipNameAndUnLock(jspeUnaryExpression())));
     } else if (tk=='~') {  
       return jsvNewFromInteger(~jsvGetIntegerAndUnLock(jsvSkipNameAndUnLock(jspeUnaryExpression())));
     } else if (tk=='-') {  
       return jsvNegateAndUnLock(jspeUnaryExpression());  
     }  else if (tk=='+') {  
       JsVar *v = jsvSkipNameAndUnLock(jspeUnaryExpression());
       JsVar *r = jsvAsNumber(v);  
       jsvUnLock(v);
       return r;
     }
     assert(0);
     return 0;
   } else
     return jspePostfixExpression();
 }
 unsigned int jspeGetBinaryExpressionPrecedence(int op) {
   switch (op) {
   case LEX_OROR: return 1; break;
   case LEX_ANDAND: return 2; break;
   case '|' : return 3; break;
   case '^' : return 4; break;
   case '&' : return 5; break;
   case LEX_EQUAL:
   case LEX_NEQUAL:
   case LEX_TYPEEQUAL:
   case LEX_NTYPEEQUAL: return 6;
   case LEX_LEQUAL:
   case LEX_GEQUAL:
   case '<':
   case '>':
   case LEX_R_INSTANCEOF: return 7;
   case LEX_R_IN: return (execInfo.execute&EXEC_FOR_INIT)?0:7;
   case LEX_LSHIFT:
   case LEX_RSHIFT:
   case LEX_RSHIFTUNSIGNED: return 8;
   case '+':
   case '-': return 9;
   case '*':
   case '/':
   case '%': return 10;
   default: return 0;
   }
 }
 NO_INLINE JsVar *__jspeBinaryExpression(JsVar *a, unsigned int lastPrecedence) {
   unsigned int precedence = jspeGetBinaryExpressionPrecedence(lex->tk);
   while (precedence && precedence>lastPrecedence) {
     int op = lex->tk;
     JSP_ASSERT_MATCH(op);
     if (op==LEX_ANDAND || op==LEX_OROR) {
       bool aValue = jsvGetBoolAndUnLock(jsvSkipName(a));
       if ((!aValue && op==LEX_ANDAND) ||
           (aValue && op==LEX_OROR)) {
         JSP_SAVE_EXECUTE();
         jspSetNoExecute();
         jsvUnLock(__jspeBinaryExpression(jspeUnaryExpression(),precedence));
         JSP_RESTORE_EXECUTE();
       } else {
         jsvUnLock(a);
         a = __jspeBinaryExpression(jspeUnaryExpression(),precedence);
       }
     } else {  
       JsVar *b = __jspeBinaryExpression(jspeUnaryExpression(),precedence);
       if (JSP_SHOULD_EXECUTE) {
         if (op==LEX_R_IN) {
           JsVar *av = jsvSkipName(a);  
           JsVar *bv = jsvSkipName(b);  
           if (jsvIsArray(bv) || jsvIsObject(bv)) {  
             av = jsvAsArrayIndexAndUnLock(av);
             JsVar *varFound = jspGetVarNamedField( bv, av, true);
             jsvUnLock(a);
             a = jsvNewFromBool(varFound!=0);
             jsvUnLock(varFound);
           } else { 
             jsExceptionHere(JSET_ERROR, ""Cannot use 'in' operator to search a %t"", bv);
             jsvUnLock(a);
             a = 0;
           }
           jsvUnLock2(av, bv);
         } else if (op==LEX_R_INSTANCEOF) {
           bool inst = false;
           JsVar *av = jsvSkipName(a);
           JsVar *bv = jsvSkipName(b);
           if (!jsvIsFunction(bv)) {
             jsExceptionHere(JSET_ERROR, ""Expecting a function on RHS in instanceof check, got %t"", bv);
           } else {
             if (jsvIsObject(av) || jsvIsFunction(av)) {
               JsVar *bproto = jspGetNamedField(bv, JSPARSE_PROTOTYPE_VAR, false);
               JsVar *proto = jsvObjectGetChild(av, JSPARSE_INHERITS_VAR, 0);
               while (proto) {
                 if (proto == bproto) inst=true;
                 JsVar *childProto = jsvObjectGetChild(proto, JSPARSE_INHERITS_VAR, 0);
                 jsvUnLock(proto);
                 proto = childProto;
               }
               if (jspIsConstructor(bv, ""Object"")) inst = true;
               jsvUnLock(bproto);
             }
             if (!inst) {
               const char *name = jswGetBasicObjectName(av);
               if (name) {
                 inst = jspIsConstructor(bv, name);
               }
               if (!inst && (jsvIsArray(av) || jsvIsArrayBuffer(av)) &&
                   jspIsConstructor(bv, ""Object""))
                 inst = true;
             }
           }
           jsvUnLock3(av, bv, a);
           a = jsvNewFromBool(inst);
         } else {   
           JsVar *res = jsvMathsOpSkipNames(a, b, op);
           jsvUnLock(a); a = res;
         }
       }
       jsvUnLock(b);
     }
     precedence = jspeGetBinaryExpressionPrecedence(lex->tk);
   }
   return a;
 }
 JsVar *jspeBinaryExpression() {
   return __jspeBinaryExpression(jspeUnaryExpression(),0);
 }
 NO_INLINE JsVar *__jspeConditionalExpression(JsVar *lhs) {
   if (lex->tk=='?') {
     JSP_ASSERT_MATCH('?');
     if (!JSP_SHOULD_EXECUTE) {
       jsvUnLock(jspeAssignmentExpression());
       JSP_MATCH(':');
       jsvUnLock(jspeAssignmentExpression());
     } else {
       bool first = jsvGetBoolAndUnLock(jsvSkipName(lhs));
       jsvUnLock(lhs);
       if (first) {
         lhs = jspeAssignmentExpression();
         JSP_MATCH(':');
         JSP_SAVE_EXECUTE();
         jspSetNoExecute();
         jsvUnLock(jspeAssignmentExpression());
         JSP_RESTORE_EXECUTE();
       } else {
         JSP_SAVE_EXECUTE();
         jspSetNoExecute();
         jsvUnLock(jspeAssignmentExpression());
         JSP_RESTORE_EXECUTE();
         JSP_MATCH(':');
         lhs = jspeAssignmentExpression();
       }
     }
   }
   return lhs;
 }
 JsVar *jspeConditionalExpression() {
   return __jspeConditionalExpression(jspeBinaryExpression());
 }
 NO_INLINE JsVar *__jspeAssignmentExpression(JsVar *lhs) {
   if (lex->tk=='=' || lex->tk==LEX_PLUSEQUAL || lex->tk==LEX_MINUSEQUAL ||
       lex->tk==LEX_MULEQUAL || lex->tk==LEX_DIVEQUAL || lex->tk==LEX_MODEQUAL ||
       lex->tk==LEX_ANDEQUAL || lex->tk==LEX_OREQUAL ||
       lex->tk==LEX_XOREQUAL || lex->tk==LEX_RSHIFTEQUAL ||
       lex->tk==LEX_LSHIFTEQUAL || lex->tk==LEX_RSHIFTUNSIGNEDEQUAL) {
     JsVar *rhs;
     int op = lex->tk;
     JSP_ASSERT_MATCH(op);
     rhs = jspeAssignmentExpression();
     rhs = jsvSkipNameAndUnLock(rhs);  
      if (JSP_SHOULD_EXECUTE && lhs) {
        if (op=='=') {
        if (!jsvGetRefs(lhs) && jsvIsName(lhs)) {
          if (!jsvIsArrayBufferName(lhs) && !jsvIsNewChild(lhs))
            jsvAddName(execInfo.root, lhs);
        }
        jspReplaceWith(lhs, rhs);
         jspReplaceWithOrAddToRoot(lhs, rhs);
        } else {
          if (op==LEX_PLUSEQUAL) op='+';
          else if (op==LEX_MINUSEQUAL) op='-';
         else if (op==LEX_MULEQUAL) op='*';
         else if (op==LEX_DIVEQUAL) op='/';
         else if (op==LEX_MODEQUAL) op='%';
         else if (op==LEX_ANDEQUAL) op='&';
         else if (op==LEX_OREQUAL) op='|';
         else if (op==LEX_XOREQUAL) op='^';
         else if (op==LEX_RSHIFTEQUAL) op=LEX_RSHIFT;
         else if (op==LEX_LSHIFTEQUAL) op=LEX_LSHIFT;
         else if (op==LEX_RSHIFTUNSIGNEDEQUAL) op=LEX_RSHIFTUNSIGNED;
         if (op=='+' && jsvIsName(lhs)) {
           JsVar *currentValue = jsvSkipName(lhs);
           if (jsvIsString(currentValue) && !jsvIsFlatString(currentValue) && jsvGetRefs(currentValue)==1 && rhs!=currentValue) {
             JsVar *str = jsvAsString(rhs, false);
             jsvAppendStringVarComplete(currentValue, str);
             jsvUnLock(str);
             op = 0;
           }
           jsvUnLock(currentValue);
         }
         if (op) {
           JsVar *res = jsvMathsOpSkipNames(lhs,rhs,op);
           jspReplaceWith(lhs, res);
           jsvUnLock(res);
         }
       }
     }
     jsvUnLock(rhs);
   }
   return lhs;
 }
 JsVar *jspeAssignmentExpression() {
   return __jspeAssignmentExpression(jspeConditionalExpression());
 }
 NO_INLINE JsVar *jspeExpression() {
   while (!JSP_SHOULDNT_PARSE) {
     JsVar *a = jspeAssignmentExpression();
     if (lex->tk!=',') return a;
     jsvCheckReferenceError(a);
     jsvUnLock(a);
     JSP_ASSERT_MATCH(',');
   }
   return 0;
 }
 NO_INLINE void jspeBlockNoBrackets() {
   if (JSP_SHOULD_EXECUTE) {
     while (lex->tk && lex->tk!='}') {
       JsVar *a = jspeStatement();
       jsvCheckReferenceError(a);
       jsvUnLock(a);
       if (JSP_HAS_ERROR) {
         if (lex && !(execInfo.execute&EXEC_ERROR_LINE_REPORTED)) {
           execInfo.execute = (JsExecFlags)(execInfo.execute | EXEC_ERROR_LINE_REPORTED);
           JsVar *stackTrace = jsvObjectGetChild(execInfo.hiddenRoot, JSPARSE_STACKTRACE_VAR, JSV_STRING_0);
           if (stackTrace) {
             jsvAppendPrintf(stackTrace, ""at "");
             jspAppendStackTrace(stackTrace);
             jsvUnLock(stackTrace);
           }
         }
       }
       if (JSP_SHOULDNT_PARSE)
         return;
     }
   } else {
     int brackets = 0;
     while (lex->tk && (brackets || lex->tk != '}')) {
       if (lex->tk == '{') brackets++;
       if (lex->tk == '}') brackets--;
       JSP_ASSERT_MATCH(lex->tk);
     }
   }
   return;
 }","[450, 451, 452, 453, 454, 455]",Espruino before 1.99 allows attackers to cause a denial of service (application crash) and a potential Information Disclosure with user crafted input files via a Buffer Overflow or Out-of-bounds Read during syntax parsing of certain for loops in jsparse.c.,Espruino,CVE-2018-11598,CWE-125
342,182789," static int start_decoder(vorb *f)
 {
    uint8 header[6], x,y;
    int len,i,j,k, max_submaps = 0;
    int longest_floorlist=0;
    if (!start_page(f))                              return FALSE;
    if (!(f->page_flag & PAGEFLAG_first_page))       return error(f, VORBIS_invalid_first_page);
    if (f->page_flag & PAGEFLAG_last_page)           return error(f, VORBIS_invalid_first_page);
    if (f->page_flag & PAGEFLAG_continued_packet)    return error(f, VORBIS_invalid_first_page);
    if (f->segment_count != 1)                       return error(f, VORBIS_invalid_first_page);
    if (f->segments[0] != 30) {
       if (f->segments[0] == 64 &&
           getn(f, header, 6) &&
           header[0] == 'f' &&
           header[1] == 'i' &&
           header[2] == 's' &&
           header[3] == 'h' &&
           header[4] == 'e' &&
           header[5] == 'a' &&
           get8(f)   == 'd' &&
           get8(f)   == '\0')                        return error(f, VORBIS_ogg_skeleton_not_supported);
       else
                                                     return error(f, VORBIS_invalid_first_page);
    }
    if (get8(f) != VORBIS_packet_id)                 return error(f, VORBIS_invalid_first_page);
    if (!getn(f, header, 6))                         return error(f, VORBIS_unexpected_eof);
    if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_first_page);
    if (get32(f) != 0)                               return error(f, VORBIS_invalid_first_page);
    f->channels = get8(f); if (!f->channels)         return error(f, VORBIS_invalid_first_page);
    if (f->channels > STB_VORBIS_MAX_CHANNELS)       return error(f, VORBIS_too_many_channels);
    f->sample_rate = get32(f); if (!f->sample_rate)  return error(f, VORBIS_invalid_first_page);
    get32(f);  
    get32(f);  
    get32(f);  
    x = get8(f);
    {
       int log0,log1;
       log0 = x & 15;
       log1 = x >> 4;
       f->blocksize_0 = 1 << log0;
       f->blocksize_1 = 1 << log1;
       if (log0 < 6 || log0 > 13)                       return error(f, VORBIS_invalid_setup);
       if (log1 < 6 || log1 > 13)                       return error(f, VORBIS_invalid_setup);
       if (log0 > log1)                                 return error(f, VORBIS_invalid_setup);
    }
    x = get8(f);
    if (!(x & 1))                                    return error(f, VORBIS_invalid_first_page);
    if (!start_page(f))                              return FALSE;
    if (!start_packet(f))                            return FALSE;
    do {
       len = next_segment(f);
       skip(f, len);
       f->bytes_in_seg = 0;
    } while (len);
    if (!start_packet(f))                            return FALSE;
    #ifndef STB_VORBIS_NO_PUSHDATA_API
    if (IS_PUSH_MODE(f)) {
       if (!is_whole_packet_present(f, TRUE)) {
          if (f->error == VORBIS_invalid_stream)
             f->error = VORBIS_invalid_setup;
          return FALSE;
       }
    }
    #endif
    crc32_init();  
    if (get8_packet(f) != VORBIS_packet_setup)       return error(f, VORBIS_invalid_setup);
    for (i=0; i < 6; ++i) header[i] = get8_packet(f);
    if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_setup);
    f->codebook_count = get_bits(f,8) + 1;
    f->codebooks = (Codebook *) setup_malloc(f, sizeof(*f->codebooks) * f->codebook_count);
    if (f->codebooks == NULL)                        return error(f, VORBIS_outofmem);
    memset(f->codebooks, 0, sizeof(*f->codebooks) * f->codebook_count);
    for (i=0; i < f->codebook_count; ++i) {
       uint32 *values;
       int ordered, sorted_count;
       int total=0;
       uint8 *lengths;
       Codebook *c = f->codebooks+i;
       CHECK(f);
       x = get_bits(f, 8); if (x != 0x42)            return error(f, VORBIS_invalid_setup);
       x = get_bits(f, 8); if (x != 0x43)            return error(f, VORBIS_invalid_setup);
       x = get_bits(f, 8); if (x != 0x56)            return error(f, VORBIS_invalid_setup);
       x = get_bits(f, 8);
       c->dimensions = (get_bits(f, 8)<<8) + x;
       x = get_bits(f, 8);
       y = get_bits(f, 8);
       c->entries = (get_bits(f, 8)<<16) + (y<<8) + x;
       ordered = get_bits(f,1);
       c->sparse = ordered ? 0 : get_bits(f,1);
       if (c->dimensions == 0 && c->entries != 0)    return error(f, VORBIS_invalid_setup);
       if (c->sparse)
          lengths = (uint8 *) setup_temp_malloc(f, c->entries);
       else
          lengths = c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);
       if (!lengths) return error(f, VORBIS_outofmem);
       if (ordered) {
          int current_entry = 0;
          int current_length = get_bits(f,5) + 1;
           while (current_entry < c->entries) {
              int limit = c->entries - current_entry;
              int n = get_bits(f, ilog(limit));
             if (current_length >= 32) return error(f, VORBIS_invalid_setup);
              if (current_entry + n > (int) c->entries) { return error(f, VORBIS_invalid_setup); }
              memset(lengths + current_entry, current_length, n);
              current_entry += n;
             ++current_length;
          }
       } else {
          for (j=0; j < c->entries; ++j) {
             int present = c->sparse ? get_bits(f,1) : 1;
             if (present) {
                lengths[j] = get_bits(f, 5) + 1;
                ++total;
                if (lengths[j] == 32)
                   return error(f, VORBIS_invalid_setup);
             } else {
                lengths[j] = NO_CODE;
             }
          }
       }
       if (c->sparse && total >= c->entries >> 2) {
          if (c->entries > (int) f->setup_temp_memory_required)
             f->setup_temp_memory_required = c->entries;
          c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);
          if (c->codeword_lengths == NULL) return error(f, VORBIS_outofmem);
          memcpy(c->codeword_lengths, lengths, c->entries);
          setup_temp_free(f, lengths, c->entries);  
          lengths = c->codeword_lengths;
          c->sparse = 0;
       }
       if (c->sparse) {
          sorted_count = total;
       } else {
          sorted_count = 0;
          #ifndef STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH
          for (j=0; j < c->entries; ++j)
             if (lengths[j] > STB_VORBIS_FAST_HUFFMAN_LENGTH && lengths[j] != NO_CODE)
                ++sorted_count;
          #endif
       }
       c->sorted_entries = sorted_count;
       values = NULL;
       CHECK(f);
       if (!c->sparse) {
          c->codewords = (uint32 *) setup_malloc(f, sizeof(c->codewords[0]) * c->entries);
          if (!c->codewords)                  return error(f, VORBIS_outofmem);
       } else {
          unsigned int size;
          if (c->sorted_entries) {
             c->codeword_lengths = (uint8 *) setup_malloc(f, c->sorted_entries);
             if (!c->codeword_lengths)           return error(f, VORBIS_outofmem);
             c->codewords = (uint32 *) setup_temp_malloc(f, sizeof(*c->codewords) * c->sorted_entries);
             if (!c->codewords)                  return error(f, VORBIS_outofmem);
             values = (uint32 *) setup_temp_malloc(f, sizeof(*values) * c->sorted_entries);
             if (!values)                        return error(f, VORBIS_outofmem);
          }
          size = c->entries + (sizeof(*c->codewords) + sizeof(*values)) * c->sorted_entries;
          if (size > f->setup_temp_memory_required)
             f->setup_temp_memory_required = size;
       }
       if (!compute_codewords(c, lengths, c->entries, values)) {
          if (c->sparse) setup_temp_free(f, values, 0);
          return error(f, VORBIS_invalid_setup);
       }
       if (c->sorted_entries) {
          c->sorted_codewords = (uint32 *) setup_malloc(f, sizeof(*c->sorted_codewords) * (c->sorted_entries+1));
          if (c->sorted_codewords == NULL) return error(f, VORBIS_outofmem);
          c->sorted_values    = ( int   *) setup_malloc(f, sizeof(*c->sorted_values   ) * (c->sorted_entries+1));
          if (c->sorted_values == NULL) return error(f, VORBIS_outofmem);
          ++c->sorted_values;
          c->sorted_values[-1] = -1;
          compute_sorted_huffman(c, lengths, values);
       }
       if (c->sparse) {
          setup_temp_free(f, values, sizeof(*values)*c->sorted_entries);
          setup_temp_free(f, c->codewords, sizeof(*c->codewords)*c->sorted_entries);
          setup_temp_free(f, lengths, c->entries);
          c->codewords = NULL;
       }
       compute_accelerated_huffman(c);
       CHECK(f);
       c->lookup_type = get_bits(f, 4);
       if (c->lookup_type > 2) return error(f, VORBIS_invalid_setup);
       if (c->lookup_type > 0) {
          uint16 *mults;
          c->minimum_value = float32_unpack(get_bits(f, 32));
          c->delta_value = float32_unpack(get_bits(f, 32));
           c->value_bits = get_bits(f, 4)+1;
           c->sequence_p = get_bits(f,1);
           if (c->lookup_type == 1) {
            c->lookup_values = lookup1_values(c->entries, c->dimensions);
             int values = lookup1_values(c->entries, c->dimensions);
             if (values < 0) return error(f, VORBIS_invalid_setup);
             c->lookup_values = (uint32) values;
           } else {
              c->lookup_values = c->entries * c->dimensions;
           }
          if (c->lookup_values == 0) return error(f, VORBIS_invalid_setup);
          mults = (uint16 *) setup_temp_malloc(f, sizeof(mults[0]) * c->lookup_values);
          if (mults == NULL) return error(f, VORBIS_outofmem);
          for (j=0; j < (int) c->lookup_values; ++j) {
             int q = get_bits(f, c->value_bits);
             if (q == EOP) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_invalid_setup); }
             mults[j] = q;
          }
 #ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK
          if (c->lookup_type == 1) {
             int len, sparse = c->sparse;
             float last=0;
             if (sparse) {
                if (c->sorted_entries == 0) goto skip;
                c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->sorted_entries * c->dimensions);
             } else
                c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->entries        * c->dimensions);
             if (c->multiplicands == NULL) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }
             len = sparse ? c->sorted_entries : c->entries;
             for (j=0; j < len; ++j) {
                unsigned int z = sparse ? c->sorted_values[j] : j;
                unsigned int div=1;
                for (k=0; k < c->dimensions; ++k) {
                   int off = (z / div) % c->lookup_values;
                   float val = mults[off];
                   val = mults[off]*c->delta_value + c->minimum_value + last;
                   c->multiplicands[j*c->dimensions + k] = val;
                   if (c->sequence_p)
                      last = val;
                   if (k+1 < c->dimensions) {
                      if (div > UINT_MAX / (unsigned int) c->lookup_values) {
                         setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values);
                         return error(f, VORBIS_invalid_setup);
                      }
                      div *= c->lookup_values;
                   }
                }
             }
             c->lookup_type = 2;
          }
          else
 #endif
          {
             float last=0;
             CHECK(f);
             c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->lookup_values);
             if (c->multiplicands == NULL) { setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }
             for (j=0; j < (int) c->lookup_values; ++j) {
                float val = mults[j] * c->delta_value + c->minimum_value + last;
                c->multiplicands[j] = val;
                if (c->sequence_p)
                   last = val;
             }
          }
 #ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK
         skip:;
 #endif
          setup_temp_free(f, mults, sizeof(mults[0])*c->lookup_values);
          CHECK(f);
       }
       CHECK(f);
    }
    x = get_bits(f, 6) + 1;
    for (i=0; i < x; ++i) {
       uint32 z = get_bits(f, 16);
       if (z != 0) return error(f, VORBIS_invalid_setup);
    }
    f->floor_count = get_bits(f, 6)+1;
    f->floor_config = (Floor *)  setup_malloc(f, f->floor_count * sizeof(*f->floor_config));
    if (f->floor_config == NULL) return error(f, VORBIS_outofmem);
    for (i=0; i < f->floor_count; ++i) {
       f->floor_types[i] = get_bits(f, 16);
       if (f->floor_types[i] > 1) return error(f, VORBIS_invalid_setup);
       if (f->floor_types[i] == 0) {
          Floor0 *g = &f->floor_config[i].floor0;
          g->order = get_bits(f,8);
          g->rate = get_bits(f,16);
          g->bark_map_size = get_bits(f,16);
          g->amplitude_bits = get_bits(f,6);
          g->amplitude_offset = get_bits(f,8);
          g->number_of_books = get_bits(f,4) + 1;
          for (j=0; j < g->number_of_books; ++j)
             g->book_list[j] = get_bits(f,8);
          return error(f, VORBIS_feature_not_supported);
       } else {
          stbv__floor_ordering p[31*8+2];
          Floor1 *g = &f->floor_config[i].floor1;
          int max_class = -1; 
          g->partitions = get_bits(f, 5);
          for (j=0; j < g->partitions; ++j) {
             g->partition_class_list[j] = get_bits(f, 4);
             if (g->partition_class_list[j] > max_class)
                max_class = g->partition_class_list[j];
          }
          for (j=0; j <= max_class; ++j) {
             g->class_dimensions[j] = get_bits(f, 3)+1;
             g->class_subclasses[j] = get_bits(f, 2);
             if (g->class_subclasses[j]) {
                g->class_masterbooks[j] = get_bits(f, 8);
                if (g->class_masterbooks[j] >= f->codebook_count) return error(f, VORBIS_invalid_setup);
             }
             for (k=0; k < 1 << g->class_subclasses[j]; ++k) {
                g->subclass_books[j][k] = get_bits(f,8)-1;
                if (g->subclass_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);
             }
          }
          g->floor1_multiplier = get_bits(f,2)+1;
          g->rangebits = get_bits(f,4);
          g->Xlist[0] = 0;
          g->Xlist[1] = 1 << g->rangebits;
          g->values = 2;
          for (j=0; j < g->partitions; ++j) {
             int c = g->partition_class_list[j];
             for (k=0; k < g->class_dimensions[c]; ++k) {
                g->Xlist[g->values] = get_bits(f, g->rangebits);
                ++g->values;
             }
          }
          for (j=0; j < g->values; ++j) {
             p[j].x = g->Xlist[j];
              p[j].id = j;
           }
           qsort(p, g->values, sizeof(p[0]), point_compare);
          for (j=0; j < g->values-1; ++j)
             if (p[j].x == p[j+1].x)
                return error(f, VORBIS_invalid_setup);
           for (j=0; j < g->values; ++j)
              g->sorted_order[j] = (uint8) p[j].id;
          for (j=2; j < g->values; ++j) {
             int low,hi;
             neighbors(g->Xlist, j, &low,&hi);
             g->neighbors[j][0] = low;
             g->neighbors[j][1] = hi;
          }
          if (g->values > longest_floorlist)
             longest_floorlist = g->values;
       }
    }
    f->residue_count = get_bits(f, 6)+1;
    f->residue_config = (Residue *) setup_malloc(f, f->residue_count * sizeof(f->residue_config[0]));
    if (f->residue_config == NULL) return error(f, VORBIS_outofmem);
    memset(f->residue_config, 0, f->residue_count * sizeof(f->residue_config[0]));
    for (i=0; i < f->residue_count; ++i) {
       uint8 residue_cascade[64];
       Residue *r = f->residue_config+i;
       f->residue_types[i] = get_bits(f, 16);
       if (f->residue_types[i] > 2) return error(f, VORBIS_invalid_setup);
       r->begin = get_bits(f, 24);
       r->end = get_bits(f, 24);
       if (r->end < r->begin) return error(f, VORBIS_invalid_setup);
       r->part_size = get_bits(f,24)+1;
       r->classifications = get_bits(f,6)+1;
       r->classbook = get_bits(f,8);
       if (r->classbook >= f->codebook_count) return error(f, VORBIS_invalid_setup);
       for (j=0; j < r->classifications; ++j) {
          uint8 high_bits=0;
          uint8 low_bits=get_bits(f,3);
          if (get_bits(f,1))
             high_bits = get_bits(f,5);
          residue_cascade[j] = high_bits*8 + low_bits;
       }
       r->residue_books = (short (*)[8]) setup_malloc(f, sizeof(r->residue_books[0]) * r->classifications);
       if (r->residue_books == NULL) return error(f, VORBIS_outofmem);
       for (j=0; j < r->classifications; ++j) {
          for (k=0; k < 8; ++k) {
             if (residue_cascade[j] & (1 << k)) {
                r->residue_books[j][k] = get_bits(f, 8);
                if (r->residue_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);
             } else {
                r->residue_books[j][k] = -1;
             }
          }
       }
       r->classdata = (uint8 **) setup_malloc(f, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);
       if (!r->classdata) return error(f, VORBIS_outofmem);
       memset(r->classdata, 0, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);
       for (j=0; j < f->codebooks[r->classbook].entries; ++j) {
          int classwords = f->codebooks[r->classbook].dimensions;
          int temp = j;
          r->classdata[j] = (uint8 *) setup_malloc(f, sizeof(r->classdata[j][0]) * classwords);
          if (r->classdata[j] == NULL) return error(f, VORBIS_outofmem);
          for (k=classwords-1; k >= 0; --k) {
             r->classdata[j][k] = temp % r->classifications;
             temp /= r->classifications;
          }
       }
    }
    f->mapping_count = get_bits(f,6)+1;
    f->mapping = (Mapping *) setup_malloc(f, f->mapping_count * sizeof(*f->mapping));
    if (f->mapping == NULL) return error(f, VORBIS_outofmem);
    memset(f->mapping, 0, f->mapping_count * sizeof(*f->mapping));
    for (i=0; i < f->mapping_count; ++i) {
       Mapping *m = f->mapping + i;      
       int mapping_type = get_bits(f,16);
       if (mapping_type != 0) return error(f, VORBIS_invalid_setup);
       m->chan = (MappingChannel *) setup_malloc(f, f->channels * sizeof(*m->chan));
       if (m->chan == NULL) return error(f, VORBIS_outofmem);
       if (get_bits(f,1))
          m->submaps = get_bits(f,4)+1;
       else
          m->submaps = 1;
       if (m->submaps > max_submaps)
           max_submaps = m->submaps;
        if (get_bits(f,1)) {
           m->coupling_steps = get_bits(f,8)+1;
          if (m->coupling_steps > f->channels) return error(f, VORBIS_invalid_setup);
           for (k=0; k < m->coupling_steps; ++k) {
              m->chan[k].magnitude = get_bits(f, ilog(f->channels-1));
              m->chan[k].angle = get_bits(f, ilog(f->channels-1));
             if (m->chan[k].magnitude >= f->channels)        return error(f, VORBIS_invalid_setup);
             if (m->chan[k].angle     >= f->channels)        return error(f, VORBIS_invalid_setup);
             if (m->chan[k].magnitude == m->chan[k].angle)   return error(f, VORBIS_invalid_setup);
          }
       } else
          m->coupling_steps = 0;
       if (get_bits(f,2)) return error(f, VORBIS_invalid_setup);
       if (m->submaps > 1) {
          for (j=0; j < f->channels; ++j) {
             m->chan[j].mux = get_bits(f, 4);
             if (m->chan[j].mux >= m->submaps)                return error(f, VORBIS_invalid_setup);
          }
       } else
          for (j=0; j < f->channels; ++j)
             m->chan[j].mux = 0;
       for (j=0; j < m->submaps; ++j) {
          get_bits(f,8);  
          m->submap_floor[j] = get_bits(f,8);
          m->submap_residue[j] = get_bits(f,8);
          if (m->submap_floor[j] >= f->floor_count)      return error(f, VORBIS_invalid_setup);
          if (m->submap_residue[j] >= f->residue_count)  return error(f, VORBIS_invalid_setup);
       }
    }
    f->mode_count = get_bits(f, 6)+1;
    for (i=0; i < f->mode_count; ++i) {
       Mode *m = f->mode_config+i;
       m->blockflag = get_bits(f,1);
       m->windowtype = get_bits(f,16);
       m->transformtype = get_bits(f,16);
       m->mapping = get_bits(f,8);
       if (m->windowtype != 0)                 return error(f, VORBIS_invalid_setup);
       if (m->transformtype != 0)              return error(f, VORBIS_invalid_setup);
       if (m->mapping >= f->mapping_count)     return error(f, VORBIS_invalid_setup);
    }
    flush_packet(f);
    f->previous_length = 0;
    for (i=0; i < f->channels; ++i) {
       f->channel_buffers[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1);
       f->previous_window[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2);
       f->finalY[i]          = (int16 *) setup_malloc(f, sizeof(int16) * longest_floorlist);
       if (f->channel_buffers[i] == NULL || f->previous_window[i] == NULL || f->finalY[i] == NULL) return error(f, VORBIS_outofmem);
       memset(f->channel_buffers[i], 0, sizeof(float) * f->blocksize_1);
       #ifdef STB_VORBIS_NO_DEFER_FLOOR
       f->floor_buffers[i]   = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2);
       if (f->floor_buffers[i] == NULL) return error(f, VORBIS_outofmem);
       #endif
    }
    if (!init_blocksize(f, 0, f->blocksize_0)) return FALSE;
    if (!init_blocksize(f, 1, f->blocksize_1)) return FALSE;
    f->blocksize[0] = f->blocksize_0;
    f->blocksize[1] = f->blocksize_1;
 #ifdef STB_VORBIS_DIVIDE_TABLE
    if (integer_divide_table[1][1]==0)
       for (i=0; i < DIVTAB_NUMER; ++i)
          for (j=1; j < DIVTAB_DENOM; ++j)
             integer_divide_table[i][j] = i / j;
 #endif
    {
       uint32 imdct_mem = (f->blocksize_1 * sizeof(float) >> 1);
       uint32 classify_mem;
       int i,max_part_read=0;
       for (i=0; i < f->residue_count; ++i) {
          Residue *r = f->residue_config + i;
          unsigned int actual_size = f->blocksize_1 / 2;
          unsigned int limit_r_begin = r->begin < actual_size ? r->begin : actual_size;
          unsigned int limit_r_end   = r->end   < actual_size ? r->end   : actual_size;
          int n_read = limit_r_end - limit_r_begin;
          int part_read = n_read / r->part_size;
          if (part_read > max_part_read)
             max_part_read = part_read;
       }
       #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE
       classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(uint8 *));
       #else
       classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(int *));
       #endif
       f->temp_memory_required = classify_mem;
       if (imdct_mem > f->temp_memory_required)
          f->temp_memory_required = imdct_mem;
    }
    f->first_decode = TRUE;
    if (f->alloc.alloc_buffer) {
       assert(f->temp_offset == f->alloc.alloc_buffer_length_in_bytes);
       if (f->setup_offset + sizeof(*f) + f->temp_memory_required > (unsigned) f->temp_offset)
          return error(f, VORBIS_outofmem);
    }
    f->first_audio_page_offset = stb_vorbis_get_file_offset(f);
    return TRUE;
 }","[102, 191, 192, 193, 194, 321, 322, 323, 403]",A reachable assertion in the lookup1_values function in stb_vorbis through 2019-03-04 allows an attacker to cause a denial of service by opening a crafted Ogg Vorbis file.,stb,CVE-2019-13223,CWE-20
350,180946," static int read_data(void *opaque, uint8_t *buf, int buf_size)
 {
     struct playlist *v = opaque;
      HLSContext *c = v->parent->priv_data;
      int ret, i;
      int just_opened = 0;
     int reload_count = 0;
  restart:
      if (!v->needed)
         return AVERROR_EOF;
     if (!v->input) {
         int64_t reload_interval;
         struct segment *seg;
         if (v->ctx && v->ctx->nb_streams) {
             v->needed = 0;
             for (i = 0; i < v->n_main_streams; i++) {
                 if (v->main_streams[i]->discard < AVDISCARD_ALL) {
                     v->needed = 1;
                     break;
                 }
             }
         }
         if (!v->needed) {
             av_log(v->parent, AV_LOG_INFO, ""No longer receiving playlist %d\n"",
                 v->index);
             return AVERROR_EOF;
         }
          reload_interval = default_reload_interval(v);
  reload:
         reload_count++;
         if (reload_count > c->max_reload)
             return AVERROR_EOF;
          if (!v->finished &&
              av_gettime_relative() - v->last_load_time >= reload_interval) {
              if ((ret = parse_playlist(c, v->url, v, NULL)) < 0) {
                 av_log(v->parent, AV_LOG_WARNING, ""Failed to reload playlist %d\n"",
                        v->index);
                 return ret;
             }
             reload_interval = v->target_duration / 2;
         }
         if (v->cur_seq_no < v->start_seq_no) {
             av_log(NULL, AV_LOG_WARNING,
                    ""skipping %d segments ahead, expired from playlists\n"",
                    v->start_seq_no - v->cur_seq_no);
             v->cur_seq_no = v->start_seq_no;
         }
         if (v->cur_seq_no >= v->start_seq_no + v->n_segments) {
             if (v->finished)
                 return AVERROR_EOF;
             while (av_gettime_relative() - v->last_load_time < reload_interval) {
                 if (ff_check_interrupt(c->interrupt_callback))
                     return AVERROR_EXIT;
                 av_usleep(100*1000);
             }
             goto reload;
         }
         seg = current_segment(v);
         ret = update_init_section(v, seg);
         if (ret)
             return ret;
         ret = open_input(c, v, seg);
         if (ret < 0) {
             if (ff_check_interrupt(c->interrupt_callback))
                 return AVERROR_EXIT;
             av_log(v->parent, AV_LOG_WARNING, ""Failed to open segment of playlist %d\n"",
                    v->index);
             v->cur_seq_no += 1;
             goto reload;
         }
         just_opened = 1;
     }
     if (v->init_sec_buf_read_offset < v->init_sec_data_len) {
         int copy_size = FFMIN(v->init_sec_data_len - v->init_sec_buf_read_offset, buf_size);
         memcpy(buf, v->init_sec_buf, copy_size);
         v->init_sec_buf_read_offset += copy_size;
         return copy_size;
     }
     ret = read_from_url(v, current_segment(v), buf, buf_size, READ_NORMAL);
     if (ret > 0) {
         if (just_opened && v->is_id3_timestamped != 0) {
             intercept_id3(v, buf, buf_size, &ret);
         }
         return ret;
     }
     ff_format_io_close(v->parent, &v->input);
     v->cur_seq_no++;
     c->cur_seq_no = v->cur_seq_no;
     goto restart;
 }","[7, 30, 31, 32]","In FFmpeg 3.3.3, the read_data function in libavformat/hls.c does not restrict reload attempts for an insufficient list, which allows remote attackers to cause a denial of service (infinite loop).",FFmpeg,CVE-2017-14058,CWE-835
356,182102," rar_read_ahead(struct archive_read *a, size_t min, ssize_t *avail)
 {
   struct rar *rar = (struct rar *)(a->format->data);
   const void *h = __archive_read_ahead(a, min, avail);
   int ret;
   if (avail)
   {
     if (a->archive.read_data_is_posix_read && *avail > (ssize_t)a->archive.read_data_requested)
       *avail = a->archive.read_data_requested;
     if (*avail > rar->bytes_remaining)
       *avail = (ssize_t)rar->bytes_remaining;
     if (*avail < 0)
       return NULL;
      else if (*avail == 0 && rar->main_flags & MHD_VOLUME &&
        rar->file_flags & FHD_SPLIT_AFTER)
      {
       rar->filename_must_match = 1;
        ret = archive_read_format_rar_read_header(a, a->entry);
        if (ret == (ARCHIVE_EOF))
        {
          rar->has_endarc_header = 1;
          ret = archive_read_format_rar_read_header(a, a->entry);
        }
       rar->filename_must_match = 0;
        if (ret != (ARCHIVE_OK))
          return NULL;
        return rar_read_ahead(a, min, avail);
     }
   }
   return h;
 }","[17, 24]",libarchive version commit 416694915449219d505531b1096384f3237dd6cc onwards (release v3.1.0 onwards) contains a CWE-416: Use After Free vulnerability in RAR decoder - libarchive/archive_read_support_format_rar.c that can result in Crash/DoS - it is unknown if RCE is possible. This attack appear to be exploitable via the victim must open a specially crafted RAR archive.,libarchive,CVE-2018-1000878,CWE-416
357,179170," static int filter_frame(AVFilterLink *inlink, AVFrame *in)
 {
     DelogoContext *s = inlink->dst->priv;
     AVFilterLink *outlink = inlink->dst->outputs[0];
     const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);
     AVFrame *out;
     int hsub0 = desc->log2_chroma_w;
     int vsub0 = desc->log2_chroma_h;
     int direct = 0;
     int plane;
     AVRational sar;
     if (av_frame_is_writable(in)) {
         direct = 1;
         out = in;
     } else {
         out = ff_get_video_buffer(outlink, outlink->w, outlink->h);
         if (!out) {
             av_frame_free(&in);
             return AVERROR(ENOMEM);
         }
         av_frame_copy_props(out, in);
     }
     sar = in->sample_aspect_ratio;
      if (!sar.num)
          sar.num = sar.den = 1;
    for (plane = 0; plane < 4 && in->data[plane]; plane++) {
     for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++) {
          int hsub = plane == 1 || plane == 2 ? hsub0 : 0;
          int vsub = plane == 1 || plane == 2 ? vsub0 : 0;
         apply_delogo(out->data[plane], out->linesize[plane],
                      in ->data[plane], in ->linesize[plane],
                      FF_CEIL_RSHIFT(inlink->w, hsub),
                      FF_CEIL_RSHIFT(inlink->h, vsub),
                      sar, s->x>>hsub, s->y>>vsub,
                      FF_CEIL_RSHIFT(s->w + (s->x & ((1<<hsub)-1)), hsub),
                      FF_CEIL_RSHIFT(s->h + (s->y & ((1<<vsub)-1)), vsub),
                      s->band>>FFMIN(hsub, vsub),
                      s->show, direct);
     }
     if (!direct)
         av_frame_free(&in);
     return ff_filter_frame(outlink, out);
 }","[26, 27]","libavfilter in FFmpeg before 2.0.1 has unspecified impact and remote vectors related to a crafted *plane,* which triggers an out-of-bounds heap write.",FFmpeg,CVE-2013-4263,CWE-119
380,182518," init_rc(void)
 {
     int i;
     struct stat st;
     FILE *f;
     if (rc_dir != NULL)
 	goto open_rc;
     rc_dir = expandPath(RC_DIR);
     i = strlen(rc_dir);
     if (i > 1 && rc_dir[i - 1] == '/')
 	rc_dir[i - 1] = '\0';
 #ifdef USE_M17N
     display_charset_str = wc_get_ces_list();
     document_charset_str = display_charset_str;
     system_charset_str = display_charset_str;
 #endif
     if (stat(rc_dir, &st) < 0) {
 	if (errno == ENOENT) {	 
 	    if (do_mkdir(rc_dir, 0700) < 0) {
 		goto rc_dir_err;
 	    }
 	    else {
 		stat(rc_dir, &st);
 	    }
 	}
 	else {
 	    goto rc_dir_err;
 	}
     }
     if (!S_ISDIR(st.st_mode)) {
 	goto rc_dir_err;
     }
     if (!(st.st_mode & S_IWUSR)) {
 	goto rc_dir_err;
     }
     no_rc_dir = FALSE;
     tmp_dir = rc_dir;
     if (config_file == NULL)
 	config_file = rcFile(CONFIG_FILE);
     create_option_search_table();
   open_rc:
     if ((f = fopen(etcFile(W3MCONFIG), ""rt"")) != NULL) {
 	interpret_rc(f);
 	fclose(f);
     }
     if ((f = fopen(confFile(CONFIG_FILE), ""rt"")) != NULL) {
 	interpret_rc(f);
 	fclose(f);
     }
     if (config_file && (f = fopen(config_file, ""rt"")) != NULL) {
 	interpret_rc(f);
 	fclose(f);
     }
     return;
   rc_dir_err:
     no_rc_dir = TRUE;
     if (((tmp_dir = getenv(""TMPDIR"")) == NULL || *tmp_dir == '\0') &&
  	((tmp_dir = getenv(""TMP"")) == NULL || *tmp_dir == '\0') &&
  	((tmp_dir = getenv(""TEMP"")) == NULL || *tmp_dir == '\0'))
  	tmp_dir = ""/tmp"";
 #ifdef HAVE_MKDTEMP
     tmp_dir = mkdtemp(Strnew_m_charp(tmp_dir, ""/w3m-XXXXXX"", NULL)->ptr);
     if (tmp_dir == NULL)
 	tmp_dir = rc_dir;
 #endif
      create_option_search_table();
      goto open_rc;
  }","[61, 62, 63, 64, 65]","w3m through 0.5.3 does not properly handle temporary files when the ~/.w3m directory is unwritable, which allows a local attacker to craft a symlink attack to overwrite arbitrary files.",w3m,CVE-2018-6198,CWE-59
392,182342," static void oinf_entry_dump(GF_OperatingPointsInformation *ptr, FILE * trace)
 {
 	u32 i, count;
 	if (!ptr) {
 		fprintf(trace, ""<OperatingPointsInformation scalability_mask=\""Multiview|Spatial scalability|Auxilary|unknown\"" num_profile_tier_level=\""\"" num_operating_points=\""\"" dependency_layers=\""\"">\n"");
 		fprintf(trace, "" <ProfileTierLevel general_profile_space=\""\"" general_tier_flag=\""\"" general_profile_idc=\""\"" general_profile_compatibility_flags=\""\"" general_constraint_indicator_flags=\""\"" />\n"");
 		fprintf(trace, ""<OperatingPoint output_layer_set_idx=\""\"" max_temporal_id=\""\"" layer_count=\""\"" minPicWidth=\""\"" minPicHeight=\""\"" maxPicWidth=\""\"" maxPicHeight=\""\"" maxChromaFormat=\""\"" maxBitDepth=\""\"" frame_rate_info_flag=\""\"" bit_rate_info_flag=\""\"" avgFrameRate=\""\"" constantFrameRate=\""\"" maxBitRate=\""\"" avgBitRate=\""\""/>\n"");
 		fprintf(trace, ""<Layer dependent_layerID=\""\"" num_layers_dependent_on=\""\"" dependent_on_layerID=\""\"" dimension_identifier=\""\""/>\n"");
 		fprintf(trace, ""</OperatingPointsInformation>\n"");
 		return;
 	}
 	fprintf(trace, ""<OperatingPointsInformation"");
 	fprintf(trace, "" scalability_mask=\""%u ("", ptr->scalability_mask);
 	switch (ptr->scalability_mask) {
 	case 2:
 		fprintf(trace, ""Multiview"");
 		break;
 	case 4:
 		fprintf(trace, ""Spatial scalability"");
 		break;
 	case 8:
 		fprintf(trace, ""Auxilary"");
 		break;
 	default:
 		fprintf(trace, ""unknown"");
 	}
 	fprintf(trace, "")\"" num_profile_tier_level=\""%u\"""", gf_list_count(ptr->profile_tier_levels) );
 	fprintf(trace, "" num_operating_points=\""%u\"" dependency_layers=\""%u\"""", gf_list_count(ptr->operating_points), gf_list_count(ptr->dependency_layers));
 	fprintf(trace, "">\n"");
 	count=gf_list_count(ptr->profile_tier_levels);
 	for (i = 0; i < count; i++) {
 		LHEVC_ProfileTierLevel *ptl = (LHEVC_ProfileTierLevel *)gf_list_get(ptr->profile_tier_levels, i);
 		fprintf(trace, "" <ProfileTierLevel general_profile_space=\""%u\"" general_tier_flag=\""%u\"" general_profile_idc=\""%u\"" general_profile_compatibility_flags=\""%X\"" general_constraint_indicator_flags=\""""LLX""\"" />\n"", ptl->general_profile_space, ptl->general_tier_flag, ptl->general_profile_idc, ptl->general_profile_compatibility_flags, ptl->general_constraint_indicator_flags);
 	}
 	count=gf_list_count(ptr->operating_points);
 	for (i = 0; i < count; i++) {
 		LHEVC_OperatingPoint *op = (LHEVC_OperatingPoint *)gf_list_get(ptr->operating_points, i);
 		fprintf(trace, ""<OperatingPoint output_layer_set_idx=\""%u\"""", op->output_layer_set_idx);
 		fprintf(trace, "" max_temporal_id=\""%u\"" layer_count=\""%u\"""", op->max_temporal_id, op->layer_count);
 		fprintf(trace, "" minPicWidth=\""%u\"" minPicHeight=\""%u\"""", op->minPicWidth, op->minPicHeight);
  		fprintf(trace, "" maxPicWidth=\""%u\"" maxPicHeight=\""%u\"""", op->maxPicWidth, op->maxPicHeight);
  		fprintf(trace, "" maxChromaFormat=\""%u\"" maxBitDepth=\""%u\"""", op->maxChromaFormat, op->maxBitDepth);
  		fprintf(trace, "" frame_rate_info_flag=\""%u\"" bit_rate_info_flag=\""%u\"""", op->frame_rate_info_flag, op->bit_rate_info_flag);
		if (op->frame_rate_info_flag) 
 		if (op->frame_rate_info_flag)
  			fprintf(trace, "" avgFrameRate=\""%u\"" constantFrameRate=\""%u\"""", op->avgFrameRate, op->constantFrameRate);
		if (op->bit_rate_info_flag) 
 		if (op->bit_rate_info_flag)
  			fprintf(trace, "" maxBitRate=\""%u\"" avgBitRate=\""%u\"""", op->maxBitRate, op->avgBitRate);
  		fprintf(trace, ""/>\n"");
  	}
 	count=gf_list_count(ptr->dependency_layers);
 	for (i = 0; i < count; i++) {
 		u32 j;
 		LHEVC_DependentLayer *dep = (LHEVC_DependentLayer *)gf_list_get(ptr->dependency_layers, i);
 		fprintf(trace, ""<Layer dependent_layerID=\""%u\"" num_layers_dependent_on=\""%u\"""", dep->dependent_layerID, dep->num_layers_dependent_on);
 		if (dep->num_layers_dependent_on) {
 			fprintf(trace, "" dependent_on_layerID=\"""");
 			for (j = 0; j < dep->num_layers_dependent_on; j++)
 				fprintf(trace, ""%d "", dep->dependent_on_layerID[j]);
 			fprintf(trace, ""\"""");
 		}
 		fprintf(trace, "" dimension_identifier=\"""");
 		for (j = 0; j < 16; j++)
 			if (ptr->scalability_mask & (1 << j))
 				fprintf(trace, ""%d "", dep->dimension_identifier[j]);
 		fprintf(trace, ""\""/>\n"");
 	}
 	fprintf(trace, ""</OperatingPointsInformation>\n"");
 	return;
 }","[44, 45, 47, 48]",An issue was discovered in MP4Box in GPAC 0.7.1. There is a heap-based buffer over-read in the isomedia/box_dump.c function hdlr_dump.,gpac,CVE-2018-13006,CWE-125
393,181921,"  static int mem_read(jas_stream_obj_t *obj, char *buf, int cnt)
  {
	int n;
 	ssize_t n;
  	assert(cnt >= 0);
  	assert(buf);
 	JAS_DBGLOG(100, (""mem_read(%p, %p, %d)\n"", obj, buf, cnt));
 	jas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;
 	n = m->len_ - m->pos_;
 	cnt = JAS_MIN(n, cnt);
 	memcpy(buf, &m->buf_[m->pos_], cnt);
 	m->pos_ += cnt;
  	return cnt;
  }","[3, 4]","Multiple integer overflows in the (1) jas_realloc function in base/jas_malloc.c and (2) mem_resize function in base/jas_stream.c in JasPer before 1.900.22 allow remote attackers to cause a denial of service via a crafted image, which triggers use after free vulnerabilities.",jasper,CVE-2016-9262,CWE-190
397,178301,"  fbOver (CARD32 x, CARD32 y)
  {
 				  PicturePtr pDst,
 				  INT16      xSrc,
 				  INT16      ySrc,
 				  INT16      xMask,
                                   INT16      yMask,
 				  INT16      xDst,
 				  INT16      yDst,
 				  CARD16     width,
 				  CARD16     height);
 CARD32
 fbOver (CARD32 x, CARD32 y)
 {
     CARD16  a = ~x >> 24;
     CARD16  t;
     CARD32  m,n,o,p;
     m = FbOverU(x,y,0,a,t);
     n = FbOverU(x,y,8,a,t);
     o = FbOverU(x,y,16,a,t);
     p = FbOverU(x,y,24,a,t);
     return m|n|o|p;
 }
 CARD32
 fbOver24 (CARD32 x, CARD32 y)
 {
     CARD16  a = ~x >> 24;
     CARD16  t;
     CARD32  m,n,o;
     m = FbOverU(x,y,0,a,t);
     n = FbOverU(x,y,8,a,t);
     o = FbOverU(x,y,16,a,t);
     return m|n|o;
 }
 CARD32
 fbIn (CARD32 x, CARD8 y)
 {
     CARD16  a = y;
     CARD16  t;
     CARD32  m,n,o,p;
     m = FbInU(x,0,a,t);
     n = FbInU(x,8,a,t);
     o = FbInU(x,16,a,t);
     p = FbInU(x,24,a,t);
     return m|n|o|p;
 }
 #define genericCombine24(a,b,c,d) (((a)*(c)+(b)*(d)))
 #define inOver0888(alpha, source, destval, dest) { \
  	CARD32 dstrb=destval&0xFF00FF; CARD32 dstag=(destval>>8)&0xFF00FF; \
  	CARD32 drb=((source&0xFF00FF)-dstrb)*alpha; CARD32 dag=(((source>>8)&0xFF00FF)-dstag)*alpha; \
 	WRITE(dest, ((((drb>>8) + dstrb) & 0x00FF00FF) | ((((dag>>8) + dstag) << 8) & 0xFF00FF00))); \
     }
 #define inOver0565(alpha, source, destval, dest) { \
  	CARD16 dstrb = destval & 0xf81f; CARD16 dstg  = destval & 0x7e0; \
  	CARD32 drb = ((source&0xf81f)-dstrb)*alpha; CARD32 dg=((source & 0x7e0)-dstg)*alpha; \
 	WRITE(dest, ((((drb>>5) + dstrb)&0xf81f) | (((dg>>5)  + dstg) & 0x7e0))); \
     }
 #define inOver2x0565(alpha, source, destval, dest) { \
  	CARD32 dstrb = destval & 0x07e0f81f; CARD32 dstg  = (destval & 0xf81f07e0)>>5; \
  	CARD32 drb = ((source&0x07e0f81f)-dstrb)*alpha; CARD32 dg=(((source & 0xf81f07e0)>>5)-dstg)*alpha; \
 	WRITE(dest, ((((drb>>5) + dstrb)&0x07e0f81f) | ((((dg>>5)  + dstg)<<5) & 0xf81f07e0))); \
     }
 #if IMAGE_BYTE_ORDER == LSBFirst
 #define setupPackedReader(count,temp,where,workingWhere,workingVal) count=(long)where; \
 					temp=count&3; \
 					where-=temp; \
 					workingWhere=(CARD32 *)where; \
                                         workingVal=READ(workingWhere++); \
 					count=4-temp; \
 					workingVal>>=(8*temp)
         #define readPacked(where,x,y,z) {if(!(x)) { (x)=4; y = READ(z++); } where=(y)&0xff; (y)>>=8; (x)--;}
 	#define readPackedSource(where) readPacked(where,ws,workingSource,wsrc)
 	#define readPackedDest(where) readPacked(where,wd,workingiDest,widst)
         #define writePacked(what) workingoDest>>=8; workingoDest|=(what<<24); ww--; if(!ww) { ww=4; WRITE (wodst++, workingoDest); } 
 #else
 	#warning ""I havn't tested fbCompositeTrans_0888xnx0888() on big endian yet!""
 	#define setupPackedReader(count,temp,where,workingWhere,workingVal) count=(long)where; \
 					temp=count&3; \
 					where-=temp; \
 					workingWhere=(CARD32 *)where; \
                                         workingVal=READ(workingWhere++); \
 					count=4-temp; \
 					workingVal<<=(8*temp)
         #define readPacked(where,x,y,z) {if(!(x)) { (x)=4; y = READ(z++); } where=(y)>>24; (y)<<=8; (x)--;}
 	#define readPackedSource(where) readPacked(where,ws,workingSource,wsrc)
 	#define readPackedDest(where) readPacked(where,wd,workingiDest,widst)
         #define writePacked(what) workingoDest<<=8; workingoDest|=what; ww--; if(!ww) { ww=4; WRITE(wodst++, workingoDest); } 
 #endif
 void
 fbCompositeSolidMask_nx8x8888 (CARD8      op,
 			       PicturePtr pSrc,
 			       PicturePtr pMask,
 			       PicturePtr pDst,
 			       INT16      xSrc,
 			       INT16      ySrc,
 			       INT16      xMask,
 			       INT16      yMask,
 			       INT16      xDst,
 			       INT16      yDst,
 			       CARD16     width,
 			       CARD16     height)
 {
     CARD32	src, srca;
     CARD32	*dstLine, *dst, d, dstMask;
     CARD8	*maskLine, *mask, m;
     FbStride	dstStride, maskStride;
     CARD16	w;
     fbComposeGetSolid(pSrc, src, pDst->format);
     dstMask = FbFullMask (pDst->pDrawable->depth);
     srca = src >> 24;
     if (src == 0)
 	return;
     fbComposeGetStart (pDst, xDst, yDst, CARD32, dstStride, dstLine, 1);
     fbComposeGetStart (pMask, xMask, yMask, CARD8, maskStride, maskLine, 1);
     while (height--)
     {
 	dst = dstLine;
 	dstLine += dstStride;
 	mask = maskLine;
 	maskLine += maskStride;
 	w = width;
 	while (w--)
 	{
 	    m = READ(mask++);
 	    if (m == 0xff)
 	    {
 		if (srca == 0xff)
 		    WRITE(dst, src & dstMask);
 		else
 		    WRITE(dst, fbOver (src, READ(dst)) & dstMask);
 	    }
 	    else if (m)
 	    {
 		d = fbIn (src, m);
 		WRITE(dst, fbOver (d, READ(dst)) & dstMask);
 	    }
 	    dst++;
 	}
     }
     fbFinishAccess (pMask->pDrawable);
     fbFinishAccess (pDst->pDrawable);
 }
 void
 fbCompositeSolidMask_nx8888x8888C (CARD8      op,
 				   PicturePtr pSrc,
 				   PicturePtr pMask,
 				   PicturePtr pDst,
 				   INT16      xSrc,
 				   INT16      ySrc,
 				   INT16      xMask,
 				   INT16      yMask,
 				   INT16      xDst,
 				   INT16      yDst,
 				   CARD16     width,
 				   CARD16     height)
 {
     CARD32	src, srca;
     CARD32	*dstLine, *dst, d, dstMask;
     CARD32	*maskLine, *mask, ma;
     FbStride	dstStride, maskStride;
     CARD16	w;
     CARD32	m, n, o, p;
     fbComposeGetSolid(pSrc, src, pDst->format);
     dstMask = FbFullMask (pDst->pDrawable->depth);
     srca = src >> 24;
     if (src == 0)
 	return;
     fbComposeGetStart (pDst, xDst, yDst, CARD32, dstStride, dstLine, 1);
     fbComposeGetStart (pMask, xMask, yMask, CARD32, maskStride, maskLine, 1);
     while (height--)
     {
 	dst = dstLine;
 	dstLine += dstStride;
 	mask = maskLine;
 	maskLine += maskStride;
 	w = width;
 	while (w--)
 	{
 	    ma = READ(mask++);
 	    if (ma == 0xffffffff)
 	    {
 		if (srca == 0xff)
 		    WRITE(dst, src & dstMask);
 		else
 		    WRITE(dst, fbOver (src, READ(dst)) & dstMask);
 	    }
 	    else if (ma)
 	    {
 		d = READ(dst);
 #define FbInOverC(src,srca,msk,dst,i,result) { \
     CARD16  __a = FbGet8(msk,i); \
     CARD32  __t, __ta; \
     CARD32  __i; \
     __t = FbIntMult (FbGet8(src,i), __a,__i); \
     __ta = (CARD8) ~FbIntMult (srca, __a,__i); \
     __t = __t + FbIntMult(FbGet8(dst,i),__ta,__i); \
     __t = (CARD32) (CARD8) (__t | (-(__t >> 8))); \
     result = __t << (i); \
 }
 		FbInOverC (src, srca, ma, d, 0, m);
 		FbInOverC (src, srca, ma, d, 8, n);
 		FbInOverC (src, srca, ma, d, 16, o);
 		FbInOverC (src, srca, ma, d, 24, p);
 		WRITE(dst, m|n|o|p);
 	    }
 	    dst++;
 	}
     }
     fbFinishAccess (pMask->pDrawable);
     fbFinishAccess (pDst->pDrawable);
 }
 #define srcAlphaCombine24(a,b) genericCombine24(a,b,srca,srcia)
 void
 fbCompositeSolidMask_nx8x0888 (CARD8      op,
 			       PicturePtr pSrc,
 			       PicturePtr pMask,
 			       PicturePtr pDst,
 			       INT16      xSrc,
 			       INT16      ySrc,
 			       INT16      xMask,
 			       INT16      yMask,
 			       INT16      xDst,
 			       INT16      yDst,
 			       CARD16     width,
 			       CARD16     height)
 {
     CARD32	src, srca, srcia;
     CARD8	*dstLine, *dst, *edst;
     CARD8	*maskLine, *mask, m;
     FbStride	dstStride, maskStride;
     CARD16	w;
     CARD32 rs,gs,bs,rd,gd,bd;
     fbComposeGetSolid(pSrc, src, pDst->format);
     srca = src >> 24;
     srcia = 255-srca;
     if (src == 0)
 	return;
     rs=src&0xff;
     gs=(src>>8)&0xff;
     bs=(src>>16)&0xff;
     fbComposeGetStart (pDst, xDst, yDst, CARD8, dstStride, dstLine, 3);
     fbComposeGetStart (pMask, xMask, yMask, CARD8, maskStride, maskLine, 1);
     while (height--)
     {
 	unsigned long wt, wd;
 	CARD32 workingiDest;
 	CARD32 *widst;
 	edst = dst = dstLine;
 	dstLine += dstStride;
 	mask = maskLine;
 	maskLine += maskStride;
 	w = width;
 #ifndef NO_MASKED_PACKED_READ
 	setupPackedReader(wd,wt,edst,widst,workingiDest);
 #endif
 	while (w--)
 	{
 #ifndef NO_MASKED_PACKED_READ
 	    readPackedDest(rd);
 	    readPackedDest(gd);
 	    readPackedDest(bd);
 #else
 	    rd = READ(edst++);
 	    gd = READ(edst++);
 	    bd = READ(edst++);
 #endif
 	    m = READ(mask++);
 	    if (m == 0xff)
 	    {
 		if (srca == 0xff)
 		{
 		    WRITE(dst++, rs);
 		    WRITE(dst++, gs);
 		    WRITE(dst++, bs);
 		}
 		else
 		{
 		    WRITE(dst++, (srcAlphaCombine24(rs, rd)>>8));
 		    WRITE(dst++, (srcAlphaCombine24(gs, gd)>>8));
 		    WRITE(dst++, (srcAlphaCombine24(bs, bd)>>8));
 		}
 	    }
 	    else if (m)
 	    {
 		int na=(srca*(int)m)>>8;
 		int nia=255-na;
 		WRITE(dst++, (genericCombine24(rs, rd, na, nia)>>8));
 		WRITE(dst++, (genericCombine24(gs, gd, na, nia)>>8));
 		WRITE(dst++, (genericCombine24(bs, bd, na, nia)>>8));
 	    }
 	    else
 	    {
 		dst+=3;
 	    }
 	}
     }
     fbFinishAccess (pMask->pDrawable);
     fbFinishAccess (pDst->pDrawable);
 }
 void
 fbCompositeSolidMask_nx8x0565 (CARD8      op,
 				  PicturePtr pSrc,
 				  PicturePtr pMask,
 				  PicturePtr pDst,
 				  INT16      xSrc,
 				  INT16      ySrc,
 				  INT16      xMask,
 				  INT16      yMask,
 				  INT16      xDst,
 				  INT16      yDst,
 				  CARD16     width,
 				  CARD16     height)
 {
     CARD32	src, srca8, srca5;
     CARD16	*dstLine, *dst;
     CARD16	d;
     CARD32	t;
     CARD8	*maskLine, *mask, m;
     FbStride	dstStride, maskStride;
     CARD16	w,src16;
     fbComposeGetSolid(pSrc, src, pDst->format);
     if (src == 0)
 	return;
     srca8 = (src >> 24);
     srca5 = (srca8 >> 3);
     src16 = cvt8888to0565(src);
     fbComposeGetStart (pDst, xDst, yDst, CARD16, dstStride, dstLine, 1);
     fbComposeGetStart (pMask, xMask, yMask, CARD8, maskStride, maskLine, 1);
     while (height--)
     {
 	dst = dstLine;
 	dstLine += dstStride;
 	mask = maskLine;
 	maskLine += maskStride;
 	w = width;
 	while (w--)
 	{
 	    m = READ(mask++);
 	    if (m == 0)
 		dst++;
 	    else if (srca5 == (0xff >> 3))
 	    {
 		if (m == 0xff)
 		    WRITE(dst++, src16);
 		else 
  		{
 		    d = READ(dst);
 		    m >>= 3;
 		    inOver0565 (m, src16, d, dst++);
  		}
 	    }
 	    else
 	    {
 		d = READ(dst);
 		if (m == 0xff) 
 		{
 		    t = fbOver24 (src, cvt0565to0888 (d));
 		}
 		else
 		{
 		    t = fbIn (src, m);
 		    t = fbOver (t, cvt0565to0888 (d));
 		}
 		WRITE(dst++, cvt8888to0565 (t));
 	    }
 	}
     }
     fbFinishAccess (pMask->pDrawable);
     fbFinishAccess (pDst->pDrawable);
 }
 static void
 fbCompositeSolidMask_nx8888x0565 (CARD8      op,
 				  PicturePtr pSrc,
 				  PicturePtr pMask,
 				  PicturePtr pDst,
 				  INT16      xSrc,
 				  INT16      ySrc,
 				  INT16      xMask,
 				  INT16      yMask,
 				  INT16      xDst,
 				  INT16      yDst,
 				  CARD16     width,
 				  CARD16     height)
 {
     CARD32	src, srca8, srca5;
     CARD16	*dstLine, *dst;
     CARD16	d;
     CARD32	*maskLine, *mask;
     CARD32	t;
     CARD8	m;
     FbStride	dstStride, maskStride;
     CARD16	w, src16;
     fbComposeGetSolid(pSrc, src, pDst->format);
     if (src == 0)
 	return;
     srca8 = src >> 24;
     srca5 = srca8 >> 3;
     src16 = cvt8888to0565(src);
     fbComposeGetStart (pDst, xDst, yDst, CARD16, dstStride, dstLine, 1);
     fbComposeGetStart (pMask, xMask, yMask, CARD32, maskStride, maskLine, 1);
     while (height--)
     {
 	dst = dstLine;
 	dstLine += dstStride;
 	mask = maskLine;
 	maskLine += maskStride;
 	w = width;
 	while (w--)
 	{
 	    m = READ(mask++) >> 24;
 	    if (m == 0)
 		dst++;
 	    else if (srca5 == (0xff >> 3))
 	    {
 		if (m == 0xff)
 		    WRITE(dst++, src16);
 		else
 		{
 		    d = READ(dst);
 		    m >>= 3;
 		    inOver0565 (m, src16, d, dst++);
 		}
 	    }
 	    else
 	    {
 		if (m == 0xff) 
 		{
 		    d = READ(dst);
 		    t = fbOver24 (src, cvt0565to0888 (d));
 		    WRITE(dst++, cvt8888to0565 (t));
 		}
 		else
 		{
 		    d = READ(dst);
 		    t = fbIn (src, m);
 		    t = fbOver (t, cvt0565to0888 (d));
 		    WRITE(dst++, cvt8888to0565 (t));
 		}
 	    }
 	}
     }
 }
 void
 fbCompositeSolidMask_nx8888x0565C (CARD8      op,
 				   PicturePtr pSrc,
 				   PicturePtr pMask,
 				   PicturePtr pDst,
 				   INT16      xSrc,
 				   INT16      ySrc,
 				   INT16      xMask,
 				   INT16      yMask,
 				   INT16      xDst,
 				   INT16      yDst,
 				   CARD16     width,
 				   CARD16     height)
 {
     CARD32	src, srca;
     CARD16	src16;
     CARD16	*dstLine, *dst;
     CARD32	d;
     CARD32	*maskLine, *mask, ma;
     FbStride	dstStride, maskStride;
     CARD16	w;
     CARD32	m, n, o;
     fbComposeGetSolid(pSrc, src, pDst->format);
     srca = src >> 24;
     if (src == 0)
 	return;
     src16 = cvt8888to0565(src);
     fbComposeGetStart (pDst, xDst, yDst, CARD16, dstStride, dstLine, 1);
     fbComposeGetStart (pMask, xMask, yMask, CARD32, maskStride, maskLine, 1);
     while (height--)
     {
 	dst = dstLine;
 	dstLine += dstStride;
 	mask = maskLine;
 	maskLine += maskStride;
 	w = width;
 	while (w--)
 	{
 	    ma = READ(mask++);
 	    if (ma == 0xffffffff)
 	    {
 		if (srca == 0xff)
 		{
 		    WRITE(dst, src16);
 		}
 		else
 		{
 		    d = READ(dst);
 		    d = fbOver24 (src, cvt0565to0888(d));
 		    WRITE(dst, cvt8888to0565(d));
 		}
 	    }
 	    else if (ma)
 	    {
 		d = READ(dst);
 		d = cvt0565to0888(d);
 		FbInOverC (src, srca, ma, d, 0, m);
 		FbInOverC (src, srca, ma, d, 8, n);
 		FbInOverC (src, srca, ma, d, 16, o);
 		d = m|n|o;
 		WRITE(dst, cvt8888to0565(d));
 	    }
 	    dst++;
 	}
     }
     fbFinishAccess (pMask->pDrawable);
     fbFinishAccess (pDst->pDrawable);
 }
 void
 fbCompositeSrc_8888x8888 (CARD8      op,
 			 PicturePtr pSrc,
 			 PicturePtr pMask,
 			 PicturePtr pDst,
 			 INT16      xSrc,
 			 INT16      ySrc,
 			 INT16      xMask,
 			 INT16      yMask,
 			 INT16      xDst,
 			 INT16      yDst,
 			 CARD16     width,
 			 CARD16     height)
 {
     CARD32	*dstLine, *dst, dstMask;
     CARD32	*srcLine, *src, s;
     FbStride	dstStride, srcStride;
     CARD8	a;
     CARD16	w;
     fbComposeGetStart (pDst, xDst, yDst, CARD32, dstStride, dstLine, 1);
     fbComposeGetStart (pSrc, xSrc, ySrc, CARD32, srcStride, srcLine, 1);
     dstMask = FbFullMask (pDst->pDrawable->depth);
     while (height--)
     {
 	dst = dstLine;
 	dstLine += dstStride;
 	src = srcLine;
 	srcLine += srcStride;
 	w = width;
 	while (w--)
 	{
 	    s = READ(src++);
 	    a = s >> 24;
 	    if (a == 0xff)
 		WRITE(dst, s & dstMask);
 	    else if (a)
 		WRITE(dst, fbOver (s, READ(dst)) & dstMask);
 	    dst++;
 	}
     }
     fbFinishAccess (pSrc->pDrawable);
     fbFinishAccess (pDst->pDrawable);
 }
 void
 fbCompositeSrc_8888x0888 (CARD8      op,
 			 PicturePtr pSrc,
 			 PicturePtr pMask,
 			 PicturePtr pDst,
 			 INT16      xSrc,
 			 INT16      ySrc,
 			 INT16      xMask,
 			 INT16      yMask,
 			 INT16      xDst,
 			 INT16      yDst,
 			 CARD16     width,
 			 CARD16     height)
 {
     CARD8	*dstLine, *dst;
     CARD32	d;
     CARD32	*srcLine, *src, s;
     CARD8	a;
     FbStride	dstStride, srcStride;
     CARD16	w;
     fbComposeGetStart (pDst, xDst, yDst, CARD8, dstStride, dstLine, 3);
     fbComposeGetStart (pSrc, xSrc, ySrc, CARD32, srcStride, srcLine, 1);
     while (height--)
     {
 	dst = dstLine;
 	dstLine += dstStride;
 	src = srcLine;
 	srcLine += srcStride;
 	w = width;
 	while (w--)
 	{
 	    s = READ(src++);
 	    a = s >> 24;
 	    if (a)
 	    {
 		if (a == 0xff)
 		    d = s;
 		else
 		    d = fbOver24 (s, Fetch24(dst));
 		Store24(dst,d);
 	    }
 	    dst += 3;
 	}
     }
     fbFinishAccess (pSrc->pDrawable);
     fbFinishAccess (pDst->pDrawable);
 }
 void
 fbCompositeSrc_8888x0565 (CARD8      op,
 			 PicturePtr pSrc,
 			 PicturePtr pMask,
 			 PicturePtr pDst,
 			 INT16      xSrc,
 			 INT16      ySrc,
 			 INT16      xMask,
 			 INT16      yMask,
 			 INT16      xDst,
 			 INT16      yDst,
 			 CARD16     width,
 			 CARD16     height)
 {
     CARD16	*dstLine, *dst;
     CARD32	d;
     CARD32	*srcLine, *src, s;
     CARD8	a;
     FbStride	dstStride, srcStride;
     CARD16	w;
     fbComposeGetStart (pSrc, xSrc, ySrc, CARD32, srcStride, srcLine, 1);
     fbComposeGetStart (pDst, xDst, yDst, CARD16, dstStride, dstLine, 1);
     while (height--)
     {
 	dst = dstLine;
 	dstLine += dstStride;
 	src = srcLine;
 	srcLine += srcStride;
 	w = width;
 	while (w--)
 	{
 	    s = READ(src++);
 	    a = s >> 24;
 	    if (a)
 	    {
 		if (a == 0xff)
 		    d = s;
 		else
 		{
 		    d = READ(dst);
 		    d = fbOver24 (s, cvt0565to0888(d));
 		}
 		WRITE(dst, cvt8888to0565(d));
 	    }
 	    dst++;
 	}
     }
     fbFinishAccess (pDst->pDrawable);
     fbFinishAccess (pSrc->pDrawable);
 }
 void
 fbCompositeSrcAdd_8000x8000 (CARD8	op,
 			     PicturePtr pSrc,
 			     PicturePtr pMask,
 			     PicturePtr pDst,
 			     INT16      xSrc,
 			     INT16      ySrc,
 			     INT16      xMask,
 			     INT16      yMask,
 			     INT16      xDst,
 			     INT16      yDst,
 			     CARD16     width,
 			     CARD16     height)
 {
     CARD8	*dstLine, *dst;
     CARD8	*srcLine, *src;
     FbStride	dstStride, srcStride;
     CARD16	w;
     CARD8	s, d;
     CARD16	t;
     fbComposeGetStart (pSrc, xSrc, ySrc, CARD8, srcStride, srcLine, 1);
     fbComposeGetStart (pDst, xDst, yDst, CARD8, dstStride, dstLine, 1);
     while (height--)
     {
 	dst = dstLine;
 	dstLine += dstStride;
 	src = srcLine;
 	srcLine += srcStride;
 	w = width;
 	while (w--)
 	{
 	    s = READ(src++);
 	    if (s)
 	    {
 		if (s != 0xff)
 		{
 		    d = READ(dst);
 		    t = d + s;
 		    s = t | (0 - (t >> 8));
 		}
 		WRITE(dst, s);
 	    }
 	    dst++;
 	}
     }
     fbFinishAccess (pDst->pDrawable);
     fbFinishAccess (pSrc->pDrawable);
 }
 void
 fbCompositeSrcAdd_8888x8888 (CARD8	op,
 			     PicturePtr pSrc,
 			     PicturePtr pMask,
 			     PicturePtr pDst,
 			     INT16      xSrc,
 			     INT16      ySrc,
 			     INT16      xMask,
 			     INT16      yMask,
 			     INT16      xDst,
 			     INT16      yDst,
 			     CARD16     width,
 			     CARD16     height)
 {
     CARD32	*dstLine, *dst;
     CARD32	*srcLine, *src;
     FbStride	dstStride, srcStride;
     CARD16	w;
     CARD32	s, d;
     CARD16	t;
     CARD32	m,n,o,p;
     fbComposeGetStart (pSrc, xSrc, ySrc, CARD32, srcStride, srcLine, 1);
     fbComposeGetStart (pDst, xDst, yDst, CARD32, dstStride, dstLine, 1);
     while (height--)
     {
 	dst = dstLine;
 	dstLine += dstStride;
 	src = srcLine;
 	srcLine += srcStride;
 	w = width;
 	while (w--)
 	{
 	    s = READ(src++);
 	    if (s)
 	    {
 		if (s != 0xffffffff)
 		{
 		    d = READ(dst);
 		    if (d)
 		    {
 			m = FbAdd(s,d,0,t);
 			n = FbAdd(s,d,8,t);
 			o = FbAdd(s,d,16,t);
 			p = FbAdd(s,d,24,t);
 			s = m|n|o|p;
 		    }
 		}
 		WRITE(dst, s);
 	    }
 	    dst++;
 	}
     }
     fbFinishAccess (pDst->pDrawable);
     fbFinishAccess (pSrc->pDrawable);
 }
 static void
 fbCompositeSrcAdd_8888x8x8 (CARD8      op,
 			    PicturePtr pSrc,
 			    PicturePtr pMask,
 			    PicturePtr pDst,
 			    INT16      xSrc,
 			    INT16      ySrc,
 			    INT16      xMask,
 			    INT16      yMask,
 			    INT16      xDst,
 			    INT16      yDst,
 			    CARD16     width,
 			    CARD16     height)
 {
     CARD8	*dstLine, *dst;
     CARD8	*maskLine, *mask;
     FbStride	dstStride, maskStride;
     CARD16	w;
     CARD32	src;
     CARD8	sa;
     fbComposeGetStart (pDst, xDst, yDst, CARD8, dstStride, dstLine, 1);
     fbComposeGetStart (pMask, xMask, yMask, CARD8, maskStride, maskLine, 1);
     fbComposeGetSolid (pSrc, src, pDst->format);
     sa = (src >> 24);
     while (height--)
     {
 	dst = dstLine;
 	dstLine += dstStride;
 	mask = maskLine;
 	maskLine += maskStride;
 	w = width;
 	while (w--)
 	{
 	    CARD16	tmp;
 	    CARD16	a;
 	    CARD32	m, d;
 	    CARD32	r;
 	    a = READ(mask++);
 	    d = READ(dst);
 	    m = FbInU (sa, 0, a, tmp);
 	    r = FbAdd (m, d, 0, tmp);
 	    WRITE(dst++, r);
 	}
     }
     fbFinishAccess(pDst->pDrawable);
     fbFinishAccess(pMask->pDrawable);
 }
 void
 fbCompositeSrcAdd_1000x1000 (CARD8	op,
 			     PicturePtr pSrc,
 			     PicturePtr pMask,
 			     PicturePtr pDst,
 			     INT16      xSrc,
 			     INT16      ySrc,
 			     INT16      xMask,
 			     INT16      yMask,
 			     INT16      xDst,
 			     INT16      yDst,
 			     CARD16     width,
 			     CARD16     height)
 {
     FbBits	*dstBits, *srcBits;
     FbStride	dstStride, srcStride;
     int		dstBpp, srcBpp;
     int		dstXoff, dstYoff;
     int		srcXoff, srcYoff;
     fbGetDrawable(pSrc->pDrawable, srcBits, srcStride, srcBpp, srcXoff, srcYoff);
     fbGetDrawable(pDst->pDrawable, dstBits, dstStride, dstBpp, dstXoff, dstYoff);
     fbBlt (srcBits + srcStride * (ySrc + srcYoff),
 	   srcStride,
 	   xSrc + srcXoff,
 	   dstBits + dstStride * (yDst + dstYoff),
 	   dstStride,
 	   xDst + dstXoff,
 	   width,
 	   height,
 	   GXor,
 	   FB_ALLONES,
 	   srcBpp,
 	   FALSE,
 	   FALSE);
     fbFinishAccess(pDst->pDrawable);
     fbFinishAccess(pSrc->pDrawable);
 }
 void
 fbCompositeSolidMask_nx1xn (CARD8      op,
 			    PicturePtr pSrc,
 			    PicturePtr pMask,
 			    PicturePtr pDst,
 			    INT16      xSrc,
 			    INT16      ySrc,
 			    INT16      xMask,
 			    INT16      yMask,
 			    INT16      xDst,
 			    INT16      yDst,
 			    CARD16     width,
 			    CARD16     height)
 {
     FbBits	*dstBits;
     FbStip	*maskBits;
     FbStride	dstStride, maskStride;
     int		dstBpp, maskBpp;
     int		dstXoff, dstYoff;
     int		maskXoff, maskYoff;
     FbBits	src;
     fbComposeGetSolid(pSrc, src, pDst->format);
     fbGetStipDrawable (pMask->pDrawable, maskBits, maskStride, maskBpp, maskXoff, maskYoff);
     fbGetDrawable (pDst->pDrawable, dstBits, dstStride, dstBpp, dstXoff, dstYoff);
     switch (dstBpp) {
     case 32:
 	break;
     case 24:
 	break;
     case 16:
 	src = cvt8888to0565(src);
 	break;
     }
     src = fbReplicatePixel (src, dstBpp);
     fbBltOne (maskBits + maskStride * (yMask + maskYoff),
 	      maskStride,
 	      xMask + maskXoff,
 	      dstBits + dstStride * (yDst + dstYoff),
 	      dstStride,
 	      (xDst + dstXoff) * dstBpp,
 	      dstBpp,
 	      width * dstBpp,
 	      height,
 	      0x0,
 	      src,
 	      FB_ALLONES,
 	      0x0);
     fbFinishAccess (pDst->pDrawable);
     fbFinishAccess (pMask->pDrawable);
 }
 # define mod(a,b)	((b) == 1 ? 0 : (a) >= 0 ? (a) % (b) : (b) - (-a) % (b))
 static void
 fbCompositeSrcSrc_nxn  (CARD8	   op,
 			PicturePtr pSrc,
 			PicturePtr pMask,
 			PicturePtr pDst,
 			INT16      xSrc,
 			INT16      ySrc,
 			INT16      xMask,
 			INT16      yMask,
 			INT16      xDst,
 			INT16      yDst,
 			CARD16     width,
 			CARD16     height);
 static void
 fbCompositeTrans_0565xnx0565(CARD8      op,
 			     PicturePtr pSrc,
 			     PicturePtr pMask,
 			     PicturePtr pDst,
 			     INT16      xSrc,
 			     INT16      ySrc,
 			     INT16      xMask,
 			     INT16      yMask,
 			     INT16      xDst,
 			     INT16      yDst,
 			     CARD16     width,
 			     CARD16     height)
 {
     CARD16	*dstLine, *dst;
     CARD16	*srcLine, *src;
     FbStride	dstStride, srcStride;
     CARD16	w;
     FbBits	mask;
     CARD8	maskAlpha;
     CARD16	s_16, d_16;
     CARD32	s_32, d_32;
     fbComposeGetSolid (pMask, mask, pDst->format);
     maskAlpha = mask >> 27;
     if (!maskAlpha)
 	return;
     if (maskAlpha == 0xff)
     {
 	fbCompositeSrcSrc_nxn (PictOpSrc, pSrc, pMask, pDst,
 			       xSrc, ySrc, xMask, yMask, xDst, yDst, 
 			       width, height);
 	return;
     }
     fbComposeGetStart (pSrc, xSrc, ySrc, CARD16, srcStride, srcLine, 1);
     fbComposeGetStart (pDst, xDst, yDst, CARD16, dstStride, dstLine, 1);
     while (height--)
     {
 	CARD32 *isrc, *idst;
 	dst = dstLine;
 	dstLine += dstStride;
 	src = srcLine;
 	srcLine += srcStride;
 	w = width;
 	if(((long)src&1)==1)
 	{
 	    s_16 = READ(src++);
 	    d_16 = READ(dst);
 	    inOver0565(maskAlpha, s_16, d_16, dst++);
 	    w--;
 	}
 	isrc=(CARD32 *)src;
 	if(((long)dst&1)==0)
 	{
 	    idst=(CARD32 *)dst;
 	    while (w>1)
 	    {
 		s_32 = READ(isrc++);
 		d_32 = READ(idst);
 		inOver2x0565(maskAlpha, s_32, d_32, idst++);
 		w-=2;
 	    }
 	    dst=(CARD16 *)idst;
 	}
 	else
 	{
 	    while (w > 1)
 	    {
 		s_32 = READ(isrc++);
 #if IMAGE_BYTE_ORDER == LSBFirst
 		s_16=s_32&0xffff;
 #else
 		s_16=s_32>>16;
 #endif
 		d_16 = READ(dst);
 		inOver0565 (maskAlpha, s_16, d_16, dst++);
 #if IMAGE_BYTE_ORDER == LSBFirst
 		s_16=s_32>>16;
 #else
 		s_16=s_32&0xffff;
 #endif
 		d_16 = READ(dst);
 		inOver0565(maskAlpha, s_16, d_16, dst++);
 		w-=2;
 	    }
 	}
 	src=(CARD16 *)isrc;
 	if(w!=0)
 	{
 	    s_16 = READ(src);
 	    d_16 = READ(dst);
 	    inOver0565(maskAlpha, s_16, d_16, dst);
 	}
     }
     fbFinishAccess (pSrc->pDrawable);
     fbFinishAccess (pDst->pDrawable);
 }
 #define alphamaskCombine24(a,b) genericCombine24(a,b,maskAlpha,maskiAlpha)
 static void
 fbCompositeTrans_0888xnx0888(CARD8      op,
  			     PicturePtr pSrc,
  			     PicturePtr pMask,
  			     PicturePtr pDst,
  			     INT16      xSrc,
  			     INT16      ySrc,
  			     INT16      xMask,
  			     INT16      yMask,
  			     INT16      xDst,
  			     INT16      yDst,
  			     CARD16     width,
  			     CARD16     height)
 {
     CARD8	*dstLine, *dst,*idst;
     CARD8	*srcLine, *src;
     FbStride	dstStride, srcStride;
     CARD16	w;
     FbBits	mask;
     CARD16	maskAlpha,maskiAlpha;
     fbComposeGetSolid (pMask, mask, pDst->format);
     maskAlpha = mask >> 24;
     maskiAlpha= 255-maskAlpha;
     if (!maskAlpha)
  	return;
     fbComposeGetStart (pSrc, xSrc, ySrc, CARD8, srcStride, srcLine, 3);
     fbComposeGetStart (pDst, xDst, yDst, CARD8, dstStride, dstLine, 3);
     {
 	unsigned long ws,wt;
 	CARD32 workingSource;
 	CARD32 *wsrc, *wdst, *widst;
 	CARD32 rs, rd, nd;
 	CARD8 *isrc;
 	if ((((xSrc * 3) & 3) != ((xDst * 3) & 3)) ||
 	    ((srcStride & 3) != (dstStride & 3)))
 	{
 	    while (height--)
 	    {
 		dst = dstLine;
 		dstLine += dstStride;
 		isrc = src = srcLine;
 		srcLine += srcStride;
 		w = width*3;
 		setupPackedReader(ws,wt,isrc,wsrc,workingSource);
 		switch(~(long)dst&3)
 		{
 		case 1:
 		    readPackedSource(rs);
 		    rd = READ(dst);   
 		    WRITE(dst++, alphamaskCombine24(rs, rd) >> 8);
 		    w--; if(w==0) break;
 		case 2:
 		    readPackedSource(rs);
 		    rd = READ(dst);
 		    WRITE(dst++, alphamaskCombine24(rs, rd) >> 8);
 		    w--; if(w==0) break;
 		case 3:
 		    readPackedSource(rs);
 		    rd = READ(dst);
 		    WRITE(dst++,alphamaskCombine24(rs, rd) >> 8);
 		    w--; if(w==0) break;
 		}
 		wdst=(CARD32 *)dst;
 		while (w>3)
 		{
 		    rs=READ(wsrc++);
 #if IMAGE_BYTE_ORDER == LSBFirst
 		    rd=READ(wdst);
 		    readPackedSource(nd);
 		    readPackedSource(rs);
 		    nd|=rs<<8;
 		    readPackedSource(rs);
 		    nd|=rs<<16;
 		    readPackedSource(rs);
 		    nd|=rs<<24;
 #else
 		    readPackedSource(nd);
 		    nd<<=24;
 		    readPackedSource(rs);
 		    nd|=rs<<16;
 		    readPackedSource(rs);
 		    nd|=rs<<8;
 		    readPackedSource(rs);
 		    nd|=rs;
 #endif
 		    inOver0888(maskAlpha, nd, rd, wdst++);
 		    w-=4;
 		}
 		src=(CARD8 *)wdst;
 		switch(w)
 		{
 		case 3:
 		    readPackedSource(rs);
 		    rd=READ(dst);
 		    WRITE(dst++,alphamaskCombine24(rs, rd)>>8);
 		case 2:
 		    readPackedSource(rs);
 		    rd = READ(dst);  
 		    WRITE(dst++, alphamaskCombine24(rs, rd)>>8);
 		case 1:
 		    readPackedSource(rs);
 		    rd = READ(dst);  
 		    WRITE(dst++, alphamaskCombine24(rs, rd)>>8);
 		}
 	    }
 	}
 	else
 	{
 	    while (height--)
 	    {
 		idst=dst = dstLine;
 		dstLine += dstStride;
 		src = srcLine;
 		srcLine += srcStride;
 		w = width*3;
 		switch(~(long)src&3)
 		{
 		case 1:
 		    rd=alphamaskCombine24(READ(src++), READ(dst))>>8;
 		    WRITE(dst++, rd);
 		    w--; if(w==0) break;
 		case 2:
 		    rd=alphamaskCombine24(READ(src++), READ(dst))>>8;
 		    WRITE(dst++, rd);
 		    w--; if(w==0) break;
 		case 3:
 		    rd=alphamaskCombine24(READ(src++), READ(dst))>>8;
 		    WRITE(dst++, rd);
 		    w--; if(w==0) break;
 		}
 		wsrc=(CARD32 *)src;
 		widst=(CARD32 *)dst;
 		while(w>3)
 		{
 		    rs = READ(wsrc++);
 		    rd = READ(widst);
 		    inOver0888 (maskAlpha, rs, rd, widst++);
 		    w-=4;
 		}
 		src=(CARD8 *)wsrc;
 		dst=(CARD8 *)widst;
 		switch(w)
 		{
 		case 3:
 		    rd=alphamaskCombine24(READ(src++), READ(dst))>>8;
 		    WRITE(dst++, rd);
 		case 2:
 		    rd=alphamaskCombine24(READ(src++), READ(dst))>>8;
 		    WRITE(dst++, rd);
 		case 1:
 		    rd=alphamaskCombine24(READ(src++), READ(dst))>>8;
 		    WRITE(dst++, rd);
 		}
 	    }
 	}
     }
 }
 static void
 fbCompositeSrcSrc_nxn  (CARD8	   op,
 			PicturePtr pSrc,
 			PicturePtr pMask,
 			PicturePtr pDst,
 			INT16      xSrc,
 			INT16      ySrc,
 			INT16      xMask,
 			INT16      yMask,
 			INT16      xDst,
 			INT16      yDst,
 			CARD16     width,
 			CARD16     height)
 {
     FbBits	*dst;
     FbBits	*src;
     FbStride	dstStride, srcStride;
     int		srcXoff, srcYoff;
     int		dstXoff, dstYoff;
     int		srcBpp;
     int		dstBpp;
     Bool	reverse = FALSE;
     Bool	upsidedown = FALSE;
     fbGetDrawable(pSrc->pDrawable,src,srcStride,srcBpp,srcXoff,srcYoff);
     fbGetDrawable(pDst->pDrawable,dst,dstStride,dstBpp,dstXoff,dstYoff);
     fbBlt (src + (ySrc + srcYoff) * srcStride,
 	   srcStride,
 	   (xSrc + srcXoff) * srcBpp,
 	   dst + (yDst + dstYoff) * dstStride,
 	   dstStride,
 	   (xDst + dstXoff) * dstBpp,
 	   (width) * dstBpp,
 	   (height),
 	   GXcopy,
 	   FB_ALLONES,
 	   dstBpp,
 	   reverse,
 	   upsidedown);
     fbFinishAccess(pSrc->pDrawable);
     fbFinishAccess(pDst->pDrawable);
 }
 #define SCANLINE_BUFFER_LENGTH 2048
 static void
 fbCompositeRectWrapper  (CARD8	   op,
 			 PicturePtr pSrc,
 			 PicturePtr pMask,
 			 PicturePtr pDst,
 			 INT16      xSrc,
 			 INT16      ySrc,
 			 INT16      xMask,
 			 INT16      yMask,
 			 INT16      xDst,
 			 INT16      yDst,
 			 CARD16     width,
 			 CARD16     height)
 {
     CARD32 _scanline_buffer[SCANLINE_BUFFER_LENGTH * 3];
     CARD32 *scanline_buffer = _scanline_buffer;
     FbComposeData data;
     data.op = op;
     data.src = pSrc;
     data.mask = pMask;
     data.dest = pDst;
     data.xSrc = xSrc;
     data.ySrc = ySrc;
     data.xMask = xMask;
  }
  void
 fbWalkCompositeRegion (CARD8 op,
 		       PicturePtr pSrc,
 		       PicturePtr pMask,
 		       PicturePtr pDst,
 		       INT16 xSrc,
 		       INT16 ySrc,
 		       INT16 xMask,
 		       INT16 yMask,
 		       INT16 xDst,
 		       INT16 yDst,
 		       CARD16 width,
 		       CARD16 height,
 		       Bool srcRepeat,
 		       Bool maskRepeat,
 		       CompositeFunc compositeRect)
 {
     RegionRec	    region;
     int		    n;
     BoxPtr	    pbox;
     int		    w, h, w_this, h_this;
     int		    x_msk, y_msk, x_src, y_src, x_dst, y_dst;
     xDst += pDst->pDrawable->x;
     yDst += pDst->pDrawable->y;
     if (pSrc->pDrawable)
     {
         xSrc += pSrc->pDrawable->x;
         ySrc += pSrc->pDrawable->y;
     }
     if (pMask && pMask->pDrawable)
     {
 	xMask += pMask->pDrawable->x;
 	yMask += pMask->pDrawable->y;
     }
     if (!miComputeCompositeRegion (&region, pSrc, pMask, pDst, xSrc, ySrc,
 				   xMask, yMask, xDst, yDst, width, height))
         return;
     n = REGION_NUM_RECTS (&region);
     pbox = REGION_RECTS (&region);
     while (n--)
     {
 	h = pbox->y2 - pbox->y1;
 	y_src = pbox->y1 - yDst + ySrc;
 	y_msk = pbox->y1 - yDst + yMask;
 	y_dst = pbox->y1;
 	while (h)
 	{
 	    h_this = h;
 	    w = pbox->x2 - pbox->x1;
 	    x_src = pbox->x1 - xDst + xSrc;
 	    x_msk = pbox->x1 - xDst + xMask;
 	    x_dst = pbox->x1;
 	    if (maskRepeat)
 	    {
 		y_msk = mod (y_msk - pMask->pDrawable->y, pMask->pDrawable->height);
 		if (h_this > pMask->pDrawable->height - y_msk)
 		    h_this = pMask->pDrawable->height - y_msk;
 		y_msk += pMask->pDrawable->y;
 	    }
 	    if (srcRepeat)
 	    {
 		y_src = mod (y_src - pSrc->pDrawable->y, pSrc->pDrawable->height);
 		if (h_this > pSrc->pDrawable->height - y_src)
 		    h_this = pSrc->pDrawable->height - y_src;
 		y_src += pSrc->pDrawable->y;
 	    }
 	    while (w)
 	    {
 		w_this = w;
 		if (maskRepeat)
 		{
 		    x_msk = mod (x_msk - pMask->pDrawable->x, pMask->pDrawable->width);
 		    if (w_this > pMask->pDrawable->width - x_msk)
 			w_this = pMask->pDrawable->width - x_msk;
 		    x_msk += pMask->pDrawable->x;
 		}
 		if (srcRepeat)
 		{
 		    x_src = mod (x_src - pSrc->pDrawable->x, pSrc->pDrawable->width);
 		    if (w_this > pSrc->pDrawable->width - x_src)
 			w_this = pSrc->pDrawable->width - x_src;
 		    x_src += pSrc->pDrawable->x;
 		}
 		(*compositeRect) (op, pSrc, pMask, pDst,
 				  x_src, y_src, x_msk, y_msk, x_dst, y_dst,
 				  w_this, h_this);
 		w -= w_this;
 		x_src += w_this;
 		x_msk += w_this;
 		x_dst += w_this;
 	    }
 	    h -= h_this;
 	    y_src += h_this;
 	    y_msk += h_this;
 	    y_dst += h_this;
 	}
 	pbox++;
     }
     REGION_UNINIT (pDst->pDrawable->pScreen, &region);
 }
 void
  fbComposite (CARD8      op,
  	     PicturePtr pSrc,
  	     PicturePtr pMask,
 			case PICT_x8r8g8b8:
 			case PICT_a8b8g8r8:
 			case PICT_x8b8g8r8:
 #ifdef USE_MMX
 			    if (fbHaveMMX())
 				func = fbCompositeSolidMask_nx8x8888mmx;
 			    else
  	     CARD16     width,
  	     CARD16     height)
  {
    RegionRec	    region;
    int		    n;
    BoxPtr	    pbox;
    CompositeFunc   func = NULL;
      Bool	    srcRepeat = pSrc->pDrawable && pSrc->repeatType == RepeatNormal;
      Bool	    maskRepeat = FALSE;
      Bool	    srcTransform = pSrc->transform != 0;
 			break;
      Bool	    srcAlphaMap = pSrc->alphaMap != 0;
      Bool	    maskAlphaMap = FALSE;
      Bool	    dstAlphaMap = pDst->alphaMap != 0;
    int		    x_msk, y_msk, x_src, y_src, x_dst, y_dst;
    int		    w, h, w_this, h_this;
     CompositeFunc   func = NULL;
  #ifdef USE_MMX
      static Bool mmx_setup = FALSE;
 				    func = fbCompositeSolidMask_nx8888x8888Cmmx;
 				else
 #endif
      }
  #endif
    xDst += pDst->pDrawable->x;
    yDst += pDst->pDrawable->y;
    if (pSrc->pDrawable) {
        xSrc += pSrc->pDrawable->x;
        ySrc += pSrc->pDrawable->y;
    }
      if (srcRepeat && srcTransform &&
  	pSrc->pDrawable->width == 1 &&
  	pSrc->pDrawable->height == 1)
 				else
      if (pMask && pMask->pDrawable)
      {
	xMask += pMask->pDrawable->x;
	yMask += pMask->pDrawable->y;
  	maskRepeat = pMask->repeatType == RepeatNormal;
  	if (pMask->filter == PictFilterConvolution)
 			}
 			else
 			{
 			    switch (pDst->format) {
                             case PICT_r5g6b5:
                                 func = fbCompositeSolidMask_nx8888x0565;
                                 break;
 			    default:
 				break;
                             }
 			}
 			break;
 		    case PICT_a8b8g8r8:
 			if (pMask->componentAlpha) {
 			    switch (pDst->format) {
 			    case PICT_a8b8g8r8:
 			    case PICT_x8b8g8r8:
 #ifdef USE_MMX
 				if (fbHaveMMX())
 				    func = fbCompositeSolidMask_nx8888x8888Cmmx;
 				else
 #endif
 				    func = fbCompositeSolidMask_nx8888x8888C;
 				break;
 			    case PICT_b5g6r5:
 #ifdef USE_MMX
 				if (fbHaveMMX())
 				    func = fbCompositeSolidMask_nx8888x0565Cmmx;
 				else
 #endif
 				    func = fbCompositeSolidMask_nx8888x0565C;
 				break;
 			    default:
 				break;
 			    }
 			}
 			else
 			{
 			    switch (pDst->format) {
                             case PICT_b5g6r5:
                                 func = fbCompositeSolidMask_nx8888x0565;
                                 break;
 			    default:
 				break;
                             }
 			}
 			break;
 		    case PICT_a1:
 			switch (pDst->format) {
 			case PICT_r5g6b5:
 			case PICT_b5g6r5:
 			case PICT_r8g8b8:
 			case PICT_b8g8r8:
 			case PICT_a8r8g8b8:
 			case PICT_x8r8g8b8:
 			case PICT_a8b8g8r8:
 			case PICT_x8b8g8r8:
 			{
 			    FbBits src;
 			    fbComposeGetSolid(pSrc, src, pDst->format);
 			    if ((src & 0xff000000) == 0xff000000)
 				func = fbCompositeSolidMask_nx1xn;
 			    break;
 			}
 			default:
 			    break;
 			}
 			break;
 		    default:
 			break;
 		    }","[1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300, 1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308, 1309, 1310, 1311, 1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319, 1320, 1321, 1322, 1323, 1337, 1338, 1339, 1340, 1348, 1349, 1350, 1358, 1359, 1360, 1361, 1362, 1363, 1370, 1371]","The fbComposite function in fbpict.c in the Render extension in the X server in X.Org X11R7.1 allows remote authenticated users to cause a denial of service (memory corruption and daemon crash) or possibly execute arbitrary code via a crafted request, related to an incorrect macro definition.",xserver,CVE-2010-1166,CWE-189
412,181276," yyparse (void *yyscanner, RE_LEX_ENVIRONMENT *lex_env)
 {
 int yychar;
 YY_INITIAL_VALUE (static YYSTYPE yyval_default;)
 YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
     int yynerrs;
     int yystate;
     int yyerrstatus;
     yytype_int16 yyssa[YYINITDEPTH];
     yytype_int16 *yyss;
     yytype_int16 *yyssp;
     YYSTYPE yyvsa[YYINITDEPTH];
     YYSTYPE *yyvs;
     YYSTYPE *yyvsp;
     YYSIZE_T yystacksize;
   int yyn;
   int yyresult;
   int yytoken = 0;
   YYSTYPE yyval;
 #if YYERROR_VERBOSE
   char yymsgbuf[128];
   char *yymsg = yymsgbuf;
   YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
 #endif
 #define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
   int yylen = 0;
   yyssp = yyss = yyssa;
   yyvsp = yyvs = yyvsa;
   yystacksize = YYINITDEPTH;
   YYDPRINTF ((stderr, ""Starting parse\n""));
   yystate = 0;
   yyerrstatus = 0;
   yynerrs = 0;
   yychar = YYEMPTY;  
   goto yysetstate;
  yynewstate:
   yyssp++;
  yysetstate:
   *yyssp = yystate;
   if (yyss + yystacksize - 1 <= yyssp)
     {
       YYSIZE_T yysize = yyssp - yyss + 1;
 #ifdef yyoverflow
       {
         YYSTYPE *yyvs1 = yyvs;
         yytype_int16 *yyss1 = yyss;
         yyoverflow (YY_(""memory exhausted""),
                     &yyss1, yysize * sizeof (*yyssp),
                     &yyvs1, yysize * sizeof (*yyvsp),
                     &yystacksize);
         yyss = yyss1;
         yyvs = yyvs1;
       }
 #else  
 # ifndef YYSTACK_RELOCATE
       goto yyexhaustedlab;
 # else
       if (YYMAXDEPTH <= yystacksize)
         goto yyexhaustedlab;
       yystacksize *= 2;
       if (YYMAXDEPTH < yystacksize)
         yystacksize = YYMAXDEPTH;
       {
         yytype_int16 *yyss1 = yyss;
         union yyalloc *yyptr =
           (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
         if (! yyptr)
           goto yyexhaustedlab;
         YYSTACK_RELOCATE (yyss_alloc, yyss);
         YYSTACK_RELOCATE (yyvs_alloc, yyvs);
 #  undef YYSTACK_RELOCATE
         if (yyss1 != yyssa)
           YYSTACK_FREE (yyss1);
       }
 # endif
 #endif  
       yyssp = yyss + yysize - 1;
       yyvsp = yyvs + yysize - 1;
       YYDPRINTF ((stderr, ""Stack size increased to %lu\n"",
                   (unsigned long int) yystacksize));
       if (yyss + yystacksize - 1 <= yyssp)
         YYABORT;
     }
   YYDPRINTF ((stderr, ""Entering state %d\n"", yystate));
   if (yystate == YYFINAL)
     YYACCEPT;
   goto yybackup;
 yybackup:
   yyn = yypact[yystate];
   if (yypact_value_is_default (yyn))
     goto yydefault;
   if (yychar == YYEMPTY)
     {
       YYDPRINTF ((stderr, ""Reading a token: ""));
       yychar = yylex (&yylval, yyscanner, lex_env);
     }
   if (yychar <= YYEOF)
     {
       yychar = yytoken = YYEOF;
       YYDPRINTF ((stderr, ""Now at end of input.\n""));
     }
   else
     {
       yytoken = YYTRANSLATE (yychar);
       YY_SYMBOL_PRINT (""Next token is"", yytoken, &yylval, &yylloc);
     }
   yyn += yytoken;
   if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
     goto yydefault;
   yyn = yytable[yyn];
   if (yyn <= 0)
     {
       if (yytable_value_is_error (yyn))
         goto yyerrlab;
       yyn = -yyn;
       goto yyreduce;
     }
   if (yyerrstatus)
     yyerrstatus--;
   YY_SYMBOL_PRINT (""Shifting"", yytoken, &yylval, &yylloc);
   yychar = YYEMPTY;
   yystate = yyn;
   YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
   *++yyvsp = yylval;
   YY_IGNORE_MAYBE_UNINITIALIZED_END
   goto yynewstate;
 yydefault:
   yyn = yydefact[yystate];
   if (yyn == 0)
     goto yyerrlab;
   goto yyreduce;
 yyreduce:
   yylen = yyr2[yyn];
   yyval = yyvsp[1-yylen];
   YY_REDUCE_PRINT (yyn);
    switch (yyn)
      {
          case 2:
#line 105 ""re_grammar.y""  
 #line 113 ""re_grammar.y""  
      {
          RE_AST* re_ast = yyget_extra(yyscanner);
          re_ast->root_node = (yyvsp[0].re_node);
        }
#line 1340 ""re_grammar.c""  
 #line 1348 ""re_grammar.c""  
      break;
    case 4:
#line 114 ""re_grammar.y""  
 #line 122 ""re_grammar.y""  
      {
          (yyval.re_node) = (yyvsp[0].re_node);
        }
#line 1348 ""re_grammar.c""  
 #line 1356 ""re_grammar.c""  
      break;
    case 5:
#line 118 ""re_grammar.y""  
 #line 126 ""re_grammar.y""  
      {
          mark_as_not_fast_regexp();
         incr_ast_levels();
          (yyval.re_node) = yr_re_node_create(RE_NODE_ALT, (yyvsp[-2].re_node), (yyvsp[0].re_node));
         DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[-2].re_node));
         DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[0].re_node));
          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        }
#line 1363 ""re_grammar.c""  
 #line 1372 ""re_grammar.c""  
      break;
    case 6:
#line 129 ""re_grammar.y""  
 #line 138 ""re_grammar.y""  
      {
          RE_NODE* node;
          mark_as_not_fast_regexp();
         incr_ast_levels();
          node = yr_re_node_create(RE_NODE_EMPTY, NULL, NULL);
         DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[-1].re_node));
         ERROR_IF(node == NULL, ERROR_INSUFFICIENT_MEMORY);
         (yyval.re_node) = yr_re_node_create(RE_NODE_ALT, (yyvsp[-1].re_node), node);
          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        }
#line 1382 ""re_grammar.c""  
 #line 1392 ""re_grammar.c""  
      break;
    case 7:
#line 147 ""re_grammar.y""  
 #line 157 ""re_grammar.y""  
      {
          (yyval.re_node) = (yyvsp[0].re_node);
        }
#line 1390 ""re_grammar.c""  
 #line 1400 ""re_grammar.c""  
      break;
    case 8:
#line 151 ""re_grammar.y""  
 #line 161 ""re_grammar.y""  
      {
         incr_ast_levels();
          (yyval.re_node) = yr_re_node_create(RE_NODE_CONCAT, (yyvsp[-1].re_node), (yyvsp[0].re_node));
          DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[-1].re_node));
          DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[0].re_node));
          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        }
#line 1402 ""re_grammar.c""  
 #line 1414 ""re_grammar.c""  
      break;
    case 9:
#line 162 ""re_grammar.y""  
 #line 174 ""re_grammar.y""  
      {
          RE_AST* re_ast;
         mark_as_not_fast_regexp();
         re_ast = yyget_extra(yyscanner);
         re_ast->flags |= RE_FLAGS_GREEDY;
         (yyval.re_node) = yr_re_node_create(RE_NODE_STAR, (yyvsp[-1].re_node), NULL);
          DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[-1].re_node));
          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        }
#line 1420 ""re_grammar.c""  
 #line 1432 ""re_grammar.c""  
      break;
    case 10:
#line 176 ""re_grammar.y""  
 #line 188 ""re_grammar.y""  
      {
          RE_AST* re_ast;
         mark_as_not_fast_regexp();
         re_ast = yyget_extra(yyscanner);
         re_ast->flags |= RE_FLAGS_UNGREEDY;
         (yyval.re_node) = yr_re_node_create(RE_NODE_STAR, (yyvsp[-2].re_node), NULL);
         DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[-2].re_node));
         ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
          (yyval.re_node)->greedy = FALSE;
        }
#line 1440 ""re_grammar.c""  
 #line 1452 ""re_grammar.c""  
      break;
    case 11:
#line 192 ""re_grammar.y""  
 #line 204 ""re_grammar.y""  
      {
          RE_AST* re_ast;
         mark_as_not_fast_regexp();
         re_ast = yyget_extra(yyscanner);
         re_ast->flags |= RE_FLAGS_GREEDY;
         (yyval.re_node) = yr_re_node_create(RE_NODE_PLUS, (yyvsp[-1].re_node), NULL);
          DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[-1].re_node));
          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        }
#line 1458 ""re_grammar.c""  
 #line 1470 ""re_grammar.c""  
      break;
    case 12:
#line 206 ""re_grammar.y""  
 #line 218 ""re_grammar.y""  
      {
          RE_AST* re_ast;
         mark_as_not_fast_regexp();
         re_ast = yyget_extra(yyscanner);
         re_ast->flags |= RE_FLAGS_UNGREEDY;
         (yyval.re_node) = yr_re_node_create(RE_NODE_PLUS, (yyvsp[-2].re_node), NULL);
         DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[-2].re_node));
         ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
          (yyval.re_node)->greedy = FALSE;
        }
#line 1478 ""re_grammar.c""  
 #line 1490 ""re_grammar.c""  
      break;
    case 13:
#line 222 ""re_grammar.y""  
 #line 234 ""re_grammar.y""  
      {
          RE_AST* re_ast = yyget_extra(yyscanner);
          re_ast->flags |= RE_FLAGS_GREEDY;
         if ((yyvsp[-1].re_node)->type == RE_NODE_ANY)
         {
           (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY, NULL, NULL);
           DESTROY_NODE_IF(TRUE, (yyvsp[-1].re_node));
         }
         else
         {
           mark_as_not_fast_regexp();
           (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE, (yyvsp[-1].re_node), NULL);
           DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[-1].re_node));
         }
         DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[-1].re_node));
         ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
          (yyval.re_node)->start = 0;
          (yyval.re_node)->end = 1;
        }
#line 1505 ""re_grammar.c""  
 #line 1517 ""re_grammar.c""  
      break;
    case 14:
#line 245 ""re_grammar.y""  
 #line 257 ""re_grammar.y""  
      {
          RE_AST* re_ast = yyget_extra(yyscanner);
          re_ast->flags |= RE_FLAGS_UNGREEDY;
         if ((yyvsp[-2].re_node)->type == RE_NODE_ANY)
         {
           (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY, NULL, NULL);
           DESTROY_NODE_IF(TRUE, (yyvsp[-2].re_node));
         }
         else
         {
           mark_as_not_fast_regexp();
           (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE, (yyvsp[-2].re_node), NULL);
           DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[-2].re_node));
         }
         DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[-2].re_node));
         ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
         (yyval.re_node)->start = 0;
          (yyval.re_node)->end = 1;
          (yyval.re_node)->greedy = FALSE;
        }
#line 1533 ""re_grammar.c""  
 #line 1545 ""re_grammar.c""  
      break;
    case 15:
#line 269 ""re_grammar.y""  
 #line 281 ""re_grammar.y""  
      {
          RE_AST* re_ast = yyget_extra(yyscanner);
          re_ast->flags |= RE_FLAGS_GREEDY;
         if ((yyvsp[-1].re_node)->type == RE_NODE_ANY)
         {
           (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY, NULL, NULL);
           DESTROY_NODE_IF(TRUE, (yyvsp[-1].re_node));
         }
         else
         {
           mark_as_not_fast_regexp();
           (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE, (yyvsp[-1].re_node), NULL);
           DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[-1].re_node));
         }
         ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
          (yyval.re_node)->start = (yyvsp[0].range) & 0xFFFF;;
          (yyval.re_node)->end = (yyvsp[0].range) >> 16;;
        }
#line 1559 ""re_grammar.c""  
 #line 1571 ""re_grammar.c""  
      break;
    case 16:
#line 291 ""re_grammar.y""  
 #line 303 ""re_grammar.y""  
      {
          RE_AST* re_ast = yyget_extra(yyscanner);
          re_ast->flags |= RE_FLAGS_UNGREEDY;
         if ((yyvsp[-2].re_node)->type == RE_NODE_ANY)
         {
           (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY, NULL, NULL);
           DESTROY_NODE_IF(TRUE, (yyvsp[-2].re_node));
         }
         else
         {
           mark_as_not_fast_regexp();
           (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE, (yyvsp[-2].re_node), NULL);
           DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[-2].re_node));
         }
         ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
         (yyval.re_node)->start = (yyvsp[-1].range) & 0xFFFF;;
          (yyval.re_node)->end = (yyvsp[-1].range) >> 16;;
          (yyval.re_node)->greedy = FALSE;
        }
#line 1586 ""re_grammar.c""  
 #line 1598 ""re_grammar.c""  
      break;
    case 17:
#line 314 ""re_grammar.y""  
 #line 326 ""re_grammar.y""  
      {
          (yyval.re_node) = (yyvsp[0].re_node);
        }
#line 1594 ""re_grammar.c""  
 #line 1606 ""re_grammar.c""  
      break;
    case 18:
#line 318 ""re_grammar.y""  
 #line 330 ""re_grammar.y""  
      {
          (yyval.re_node) = yr_re_node_create(RE_NODE_WORD_BOUNDARY, NULL, NULL);
          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        }
#line 1604 ""re_grammar.c""  
 #line 1616 ""re_grammar.c""  
      break;
    case 19:
#line 324 ""re_grammar.y""  
 #line 336 ""re_grammar.y""  
      {
          (yyval.re_node) = yr_re_node_create(RE_NODE_NON_WORD_BOUNDARY, NULL, NULL);
          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        }
#line 1614 ""re_grammar.c""  
 #line 1626 ""re_grammar.c""  
      break;
    case 20:
#line 330 ""re_grammar.y""  
 #line 342 ""re_grammar.y""  
      {
          (yyval.re_node) = yr_re_node_create(RE_NODE_ANCHOR_START, NULL, NULL);
          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        }
#line 1624 ""re_grammar.c""  
 #line 1636 ""re_grammar.c""  
      break;
    case 21:
#line 336 ""re_grammar.y""  
 #line 348 ""re_grammar.y""  
      {
          (yyval.re_node) = yr_re_node_create(RE_NODE_ANCHOR_END, NULL, NULL);
          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        }
#line 1634 ""re_grammar.c""  
 #line 1646 ""re_grammar.c""  
      break;
    case 22:
#line 345 ""re_grammar.y""  
 #line 357 ""re_grammar.y""  
      {
         incr_ast_levels();
          (yyval.re_node) = (yyvsp[-1].re_node);
        }
#line 1642 ""re_grammar.c""  
 #line 1656 ""re_grammar.c""  
      break;
    case 23:
#line 349 ""re_grammar.y""  
 #line 363 ""re_grammar.y""  
      {
          (yyval.re_node) = yr_re_node_create(RE_NODE_ANY, NULL, NULL);
          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        }
#line 1652 ""re_grammar.c""  
 #line 1666 ""re_grammar.c""  
      break;
    case 24:
#line 355 ""re_grammar.y""  
 #line 369 ""re_grammar.y""  
      {
          (yyval.re_node) = yr_re_node_create(RE_NODE_LITERAL, NULL, NULL);
          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
          (yyval.re_node)->value = (yyvsp[0].integer);
        }
#line 1664 ""re_grammar.c""  
 #line 1678 ""re_grammar.c""  
      break;
    case 25:
#line 363 ""re_grammar.y""  
 #line 377 ""re_grammar.y""  
      {
          (yyval.re_node) = yr_re_node_create(RE_NODE_WORD_CHAR, NULL, NULL);
          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        }
#line 1674 ""re_grammar.c""  
 #line 1688 ""re_grammar.c""  
      break;
    case 26:
#line 369 ""re_grammar.y""  
 #line 383 ""re_grammar.y""  
      {
          (yyval.re_node) = yr_re_node_create(RE_NODE_NON_WORD_CHAR, NULL, NULL);
          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        }
#line 1684 ""re_grammar.c""  
 #line 1698 ""re_grammar.c""  
      break;
    case 27:
#line 375 ""re_grammar.y""  
 #line 389 ""re_grammar.y""  
      {
          (yyval.re_node) = yr_re_node_create(RE_NODE_SPACE, NULL, NULL);
          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        }
#line 1694 ""re_grammar.c""  
 #line 1708 ""re_grammar.c""  
      break;
    case 28:
#line 381 ""re_grammar.y""  
 #line 395 ""re_grammar.y""  
      {
           (yyval.re_node) = yr_re_node_create(RE_NODE_NON_SPACE, NULL, NULL);
           ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        }
#line 1704 ""re_grammar.c""  
 #line 1718 ""re_grammar.c""  
      break;
    case 29:
#line 387 ""re_grammar.y""  
 #line 401 ""re_grammar.y""  
      {
          (yyval.re_node) = yr_re_node_create(RE_NODE_DIGIT, NULL, NULL);
          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        }
#line 1714 ""re_grammar.c""  
 #line 1728 ""re_grammar.c""  
      break;
    case 30:
#line 393 ""re_grammar.y""  
 #line 407 ""re_grammar.y""  
      {
          (yyval.re_node) = yr_re_node_create(RE_NODE_NON_DIGIT, NULL, NULL);
          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        }
#line 1724 ""re_grammar.c""  
 #line 1738 ""re_grammar.c""  
      break;
    case 31:
#line 399 ""re_grammar.y""  
 #line 413 ""re_grammar.y""  
      {
          (yyval.re_node) = yr_re_node_create(RE_NODE_CLASS, NULL, NULL);
          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
          (yyval.re_node)->class_vector = (yyvsp[0].class_vector);
        }
#line 1736 ""re_grammar.c""  
 #line 1750 ""re_grammar.c""  
      break;
#line 1740 ""re_grammar.c""  
 #line 1754 ""re_grammar.c""  
        default: break;
      }
   YY_SYMBOL_PRINT (""-> $$ ="", yyr1[yyn], &yyval, &yyloc);
   YYPOPSTACK (yylen);
   yylen = 0;
   YY_STACK_PRINT (yyss, yyssp);
   *++yyvsp = yyval;
   yyn = yyr1[yyn];
   yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
   if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
     yystate = yytable[yystate];
   else
     yystate = yydefgoto[yyn - YYNTOKENS];
   goto yynewstate;
 yyerrlab:
   yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
   if (!yyerrstatus)
     {
       ++yynerrs;
 #if ! YYERROR_VERBOSE
       yyerror (yyscanner, lex_env, YY_(""syntax error""));
 #else
 # define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
                                         yyssp, yytoken)
       {
         char const *yymsgp = YY_(""syntax error"");
         int yysyntax_error_status;
         yysyntax_error_status = YYSYNTAX_ERROR;
         if (yysyntax_error_status == 0)
           yymsgp = yymsg;
         else if (yysyntax_error_status == 1)
           {
             if (yymsg != yymsgbuf)
               YYSTACK_FREE (yymsg);
             yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
             if (!yymsg)
               {
                 yymsg = yymsgbuf;
                 yymsg_alloc = sizeof yymsgbuf;
                 yysyntax_error_status = 2;
               }
             else
               {
                 yysyntax_error_status = YYSYNTAX_ERROR;
                 yymsgp = yymsg;
               }
           }
         yyerror (yyscanner, lex_env, yymsgp);
         if (yysyntax_error_status == 2)
           goto yyexhaustedlab;
       }
 # undef YYSYNTAX_ERROR
 #endif
     }
   if (yyerrstatus == 3)
     {
       if (yychar <= YYEOF)
         {
           if (yychar == YYEOF)
             YYABORT;
         }
       else
         {
           yydestruct (""Error: discarding"",
                       yytoken, &yylval, yyscanner, lex_env);
           yychar = YYEMPTY;
         }
     }
   goto yyerrlab1;
 yyerrorlab:
   if (  0)
      goto yyerrorlab;
   YYPOPSTACK (yylen);
   yylen = 0;
   YY_STACK_PRINT (yyss, yyssp);
   yystate = *yyssp;
   goto yyerrlab1;
 yyerrlab1:
   yyerrstatus = 3;       
   for (;;)
     {
       yyn = yypact[yystate];
       if (!yypact_value_is_default (yyn))
         {
           yyn += YYTERROR;
           if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
             {
               yyn = yytable[yyn];
               if (0 < yyn)
                 break;
             }
         }
       if (yyssp == yyss)
         YYABORT;
       yydestruct (""Error: popping"",
                   yystos[yystate], yyvsp, yyscanner, lex_env);
       YYPOPSTACK (1);
       yystate = *yyssp;
       YY_STACK_PRINT (yyss, yyssp);
     }
   YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
   *++yyvsp = yylval;
   YY_IGNORE_MAYBE_UNINITIALIZED_END
   YY_SYMBOL_PRINT (""Shifting"", yystos[yyn], yyvsp, yylsp);
   yystate = yyn;
   goto yynewstate;
 yyacceptlab:
   yyresult = 0;
   goto yyreturn;
 yyabortlab:
   yyresult = 1;
   goto yyreturn;
 #if !defined yyoverflow || YYERROR_VERBOSE
 yyexhaustedlab:
   yyerror (yyscanner, lex_env, YY_(""memory exhausted""));
   yyresult = 2;
 #endif
 yyreturn:
   if (yychar != YYEMPTY)
     {
       yytoken = YYTRANSLATE (yychar);
       yydestruct (""Cleanup: discarding lookahead"",
                   yytoken, &yylval, yyscanner, lex_env);
     }
   YYPOPSTACK (yylen);
   YY_STACK_PRINT (yyss, yyssp);
   while (yyssp != yyss)
     {
       yydestruct (""Cleanup: popping"",
                   yystos[*yyssp], yyvsp, yyscanner, lex_env);
       YYPOPSTACK (1);
     }
 #ifndef yyoverflow
   if (yyss != yyssa)
     YYSTACK_FREE (yyss);
 #endif
 #if YYERROR_VERBOSE
   if (yymsg != yymsgbuf)
     YYSTACK_FREE (yymsg);
  #endif
    return yyresult;
  }","[139, 140, 145, 146, 149, 150, 154, 155, 158, 159, 162, 168, 169, 172, 173, 177, 184, 185, 188, 189, 193, 194, 197, 198, 200, 206, 207, 210, 211, 221, 222, 225, 226, 237, 238, 241, 242, 252, 253, 256, 257, 268, 269, 272, 273, 293, 294, 297, 298, 319, 320, 323, 324, 343, 344, 347, 348, 368, 369, 372, 373, 377, 378, 381, 382, 387, 388, 391, 392, 397, 398, 401, 402, 407, 408, 411, 412, 417, 418, 421, 422, 424, 427, 428, 431, 432, 437, 438, 441, 442, 448, 449, 452, 453, 458, 459, 462, 463, 468, 469, 472, 473, 478, 479, 482, 483, 488, 489, 492, 493, 498, 499, 502, 503, 508, 509, 512, 513, 519, 520, 522, 523]",libyara/re.c in the regexp module in YARA 3.5.0 allows remote attackers to cause a denial of service (stack consumption) via a crafted rule that is mishandled in the _yr_re_emit function.,yara,CVE-2017-9304,CWE-674
413,181672," static int http_read_header(URLContext *h, int *new_location)
 {
     HTTPContext *s = h->priv_data;
      char line[MAX_URL_SIZE];
      int err = 0;
    s->chunksize = -1;
     s->chunksize = UINT64_MAX;
      for (;;) {
          if ((err = http_get_line(s, line, sizeof(line))) < 0)
             return err;
         av_log(h, AV_LOG_TRACE, ""header='%s'\n"", line);
         err = process_line(h, line, s->line_count, new_location);
         if (err < 0)
             return err;
         if (err == 0)
             break;
         s->line_count++;
     }
     if (s->seekable == -1 && s->is_mediagateway && s->filesize == 2000000000)
         h->is_streamed = 1;  
     cookie_string(s->cookie_dict, &s->cookies);
     av_dict_free(&s->cookie_dict);
     return err;
 }","[6, 7]","Heap-based buffer overflow in libavformat/http.c in FFmpeg before 2.8.10, 3.0.x before 3.0.5, 3.1.x before 3.1.6, and 3.2.x before 3.2.2 allows remote web servers to execute arbitrary code via a negative chunk size in an HTTP response.",FFmpeg,CVE-2016-10190,CWE-119
420,178442," validGlxScreen(ClientPtr client, int screen, __GLXscreen **pGlxScreen, int *err)
 {
    if (screen >= screenInfo.numScreens) {
     if (screen < 0 || screen >= screenInfo.numScreens) {
  	client->errorValue = screen;
  	*err = BadValue;
  	return FALSE;
     }
     *pGlxScreen = glxGetScreen(screenInfo.screens[screen]);
     return TRUE;
 }","[3, 4]",The GLX extension in X.Org xserver 1.7.7 allows remote authenticated users to cause a denial of service (server crash) and possibly execute arbitrary code via (1) a crafted request that triggers a client swap in glx/glxcmdsswap.c; or (2) a crafted length or (3) a negative value in the screen field in a request to glx/glxcmds.c.,xserver,CVE-2010-4818,CWE-20
448,182082,"  static int save_dev(blkid_dev dev, FILE *file)
  {
  	struct list_head *p;
 	if (!dev || dev->bid_name[0] != '/')
 		return 0;
 	DBG(SAVE, ul_debug(""device %s, type %s"", dev->bid_name, dev->bid_type ?
 		   dev->bid_type : ""(null)""));
 	fprintf(file, ""<device DEVNO=\""0x%04lx\"" TIME=\""%ld.%ld\"""",
 			(unsigned long) dev->bid_devno,
 			(long) dev->bid_time,
 			(long) dev->bid_utime);
  	if (dev->bid_pri)
  		fprintf(file, "" PRI=\""%d\"""", dev->bid_pri);
  	list_for_each(p, &dev->bid_tags) {
  		blkid_tag tag = list_entry(p, struct blkid_struct_tag, bit_tags);
		fprintf(file, "" %s=\""%s\"""", tag->bit_name,tag->bit_val);
 		fputc(' ', file);			 
 		fputs(tag->bit_name, file);		 
 		fputc('=', file);			 
 		save_quoted(tag->bit_val, file);	 
  	}
  	fprintf(file, "">%s</device>\n"", dev->bid_name);
 	return 0;
 }","[16, 17, 18, 19, 20]",Blkid in util-linux before 2.26rc-1 allows local users to execute arbitrary code.,util-linux,CVE-2014-9114,CWE-77
451,180015," tar_directory_for_file (GsfInfileTar *dir, const char *name, gboolean last)
 {
 	const char *s = name;
 	while (1) {
 		const char *s0 = s;
 		char *dirname;
 		while (1) {
 			if (*s == 0) {
 				if (last && s != s0)
 					break;
 				else
 					return dir;
 			}
 			if (*s == '/')
 				break;
 			s++;
 		}
 		dirname = g_strndup (s0, s - s0);
 		while (*s == '/')
 			s++;
 		if (strcmp (dirname, ""."") != 0) {
 			GsfInput *subdir =
  				gsf_infile_child_by_name (GSF_INFILE (dir),
  							  dirname);
  			if (subdir) {
 				dir = GSF_IS_INFILE_TAR (subdir)
 					? GSF_INFILE_TAR (subdir)
 					: dir;
  				g_object_unref (subdir);
				dir = GSF_INFILE_TAR (subdir);
  			} else
  				dir = tar_create_dir (dir, dirname);
  		}
 		g_free (dirname);
 	}
 }","[26, 27, 28, 30]",An error within the *tar_directory_for_file()* function (gsf-infile-tar.c) in GNOME Structured File Library before 1.14.41 can be exploited to trigger a Null pointer dereference and subsequently cause a crash via a crafted TAR file.,libgsf,CVE-2016-9888,CWE-476
454,182062," ProcessUDPHeader(tTcpIpPacketParsingResult _res, PVOID pIpHeader, ULONG len, USHORT ipHeaderSize)
  {
      tTcpIpPacketParsingResult res = _res;
      ULONG udpDataStart = ipHeaderSize + sizeof(UDPHeader);
    res.xxpStatus = ppresXxpIncomplete;
      res.TcpUdp = ppresIsUDP;
      res.XxpIpHeaderSize = udpDataStart;
      if (len >= udpDataStart)
      {
          UDPHeader *pUdpHeader = (UDPHeader *)RtlOffsetToPointer(pIpHeader, ipHeaderSize);
          USHORT datagramLength = swap_short(pUdpHeader->udp_length);
          res.xxpStatus = ppresXxpKnown;
         res.xxpFull = TRUE;
          DPrintf(2, (""udp: len %d, datagramLength %d\n"", len, datagramLength));
      }
     else
     {
         res.xxpFull = FALSE;
         res.xxpStatus = ppresXxpIncomplete;
     }
      return res;
  }","[5, 13, 16, 17, 18, 19, 20]","The NetKVM Windows Virtio driver allows remote attackers to cause a denial of service (guest crash) via a crafted length value in an IP packet, as demonstrated by a value that does not account for the size of the IP options.",kvm-guest-drivers-windows,CVE-2015-3215,CWE-20
457,182972," mcs_recv_connect_response(STREAM mcs_data)
  {
  	UNUSED(mcs_data);
  	uint8 result;
	int length;
 	uint32 length;
  	STREAM s;
 	struct stream packet;
  	RD_BOOL is_fastpath;
  	uint8 fastpath_hdr;
 	logger(Protocol, Debug, ""%s()"", __func__);
 	s = iso_recv(&is_fastpath, &fastpath_hdr);
  	if (s == NULL)
  		return False;
 	packet = *s;
  	ber_parse_header(s, MCS_CONNECT_RESPONSE, &length);
 	ber_parse_header(s, BER_TAG_RESULT, &length);
 	in_uint8(s, result);
 	if (result != 0)
 	{
 		logger(Protocol, Error, ""mcs_recv_connect_response(), result=%d"", result);
 		return False;
 	}
  	ber_parse_header(s, BER_TAG_INTEGER, &length);
  	in_uint8s(s, length);	 
 	if (!s_check_rem(s, length))
 	{
 		rdp_protocol_error(""mcs_recv_connect_response(), consume connect id from stream would overrun"", &packet);
 	}
  	mcs_parse_domain_params(s);
  	ber_parse_header(s, BER_TAG_OCTET_STRING, &length);
 	sec_process_mcs_data(s);
 	return s_check_end(s);
 }","[5, 6, 8, 15, 26, 27, 28, 29]",rdesktop versions up to and including v1.8.3 contain a Buffer Overflow over the global variables in the function seamless_process_line() that results in memory corruption and probably even a remote code execution.,rdesktop,CVE-2018-20182,CWE-119
471,178607," SProcXResQueryResourceBytes (ClientPtr client)
 {
     REQUEST(xXResQueryResourceBytesReq);
     int c;
     xXResResourceIdSpec *specs = (void*) ((char*) stuff + sizeof(*stuff));
      int c;
      xXResResourceIdSpec *specs = (void*) ((char*) stuff + sizeof(*stuff));
    swapl(&stuff->numSpecs);
      REQUEST_AT_LEAST_SIZE(xXResQueryResourceBytesReq);
     swapl(&stuff->numSpecs);
      REQUEST_FIXED_SIZE(xXResQueryResourceBytesReq,
                         stuff->numSpecs * sizeof(specs[0]));
     }","[8, 10]",xorg-x11-server before 1.19.5 was missing length validation in RENDER extension allowing malicious X client to cause X server to crash or possibly execute arbitrary code.,xserver,CVE-2017-12187,CWE-20
472,182873," static void Sp_split_regexp(js_State *J)
 {
 	js_Regexp *re;
 	const char *text;
 	int limit, len, k;
 	const char *p, *a, *b, *c, *e;
 	Resub m;
 	text = checkstring(J, 0);
 	re = js_toregexp(J, 1);
 	limit = js_isdefined(J, 2) ? js_tointeger(J, 2) : 1 << 30;
 	js_newarray(J);
 	len = 0;
 	e = text + strlen(text);
  	if (e == text) {
		if (js_regexec(re->prog, text, &m, 0)) {
 		if (js_doregexec(J, re->prog, text, &m, 0)) {
  			if (len == limit) return;
  			js_pushliteral(J, """");
  			js_setindex(J, -2, 0);
 		}
 		return;
 	}
  	p = a = text;
  	while (a < e) {
		if (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))
 		if (js_doregexec(J, re->prog, a, &m, a > text ? REG_NOTBOL : 0))
  			break;  
  		b = m.sub[0].sp;
 		c = m.sub[0].ep;
 		if (b == p) {
 			++a;
 			continue;
 		}
 		if (len == limit) return;
 		js_pushlstring(J, p, b - p);
 		js_setindex(J, -2, len++);
 		for (k = 1; k < m.nsub; ++k) {
 			if (len == limit) return;
 			js_pushlstring(J, m.sub[k].sp, m.sub[k].ep - m.sub[k].sp);
 			js_setindex(J, -2, len++);
 		}
 		a = p = c;
 	}
 	if (len == limit) return;
 	js_pushstring(J, p);
 	js_setindex(J, -2, len);
 }","[15, 16, 25, 26]",An issue was discovered in Artifex MuJS 1.0.5. It has unlimited recursion because the match function in regexp.c lacks a depth check.,mujs,CVE-2019-11413,CWE-400
485,182520," feed_table_block_tag(struct table *tbl,
 		     char *line, struct table_mode *mode, int indent, int cmd)
 {
     int offset;
     if (mode->indent_level <= 0 && indent == -1)
 	return;
     if (mode->indent_level >= CHAR_MAX && indent == 1)
 	return;
     setwidth(tbl, mode);
     feed_table_inline_tag(tbl, line, mode, -1);
     clearcontentssize(tbl, mode);
     if (indent == 1) {
 	mode->indent_level++;
 	if (mode->indent_level <= MAX_INDENT_LEVEL)
 	    tbl->indent += INDENT_INCR;
     }
     else if (indent == -1) {
 	mode->indent_level--;
  	if (mode->indent_level < MAX_INDENT_LEVEL)
  	    tbl->indent -= INDENT_INCR;
      }
     if (tbl->indent < 0)
 	tbl->indent = 0;
      offset = tbl->indent;
      if (cmd == HTML_DT) {
  	if (mode->indent_level > 0 && mode->indent_level <= MAX_INDENT_LEVEL)
  	    offset -= INDENT_INCR;
 	if (offset < 0)
 	    offset = 0;
      }
      if (tbl->indent > 0) {
  	check_minimum0(tbl, 0);
 	addcontentssize(tbl, offset);
     }
 }","[22, 23, 28, 29]",w3m through 0.5.3 is prone to an infinite recursion flaw in HTMLlineproc0 because the feed_table_block_tag function in table.c does not prevent a negative indent value.,w3m,CVE-2018-6196,CWE-835
490,179580," queryin(char *buf)
 {
 	QPRS_STATE	state;
 	int32		i;
 	ltxtquery  *query;
 	int32		commonlen;
 	ITEM	   *ptr;
 	NODE	   *tmp;
 	int32		pos = 0;
 #ifdef BS_DEBUG
 	char		pbuf[16384],
 			   *cur;
 #endif
 	state.buf = buf;
 	state.state = WAITOPERAND;
 	state.count = 0;
 	state.num = 0;
 	state.str = NULL;
 	state.sumlen = 0;
 	state.lenop = 64;
 	state.curop = state.op = (char *) palloc(state.lenop);
 	*(state.curop) = '\0';
 	makepol(&state);
 	if (!state.num)
 		ereport(ERROR,
 				(errcode(ERRCODE_SYNTAX_ERROR),
  				 errmsg(""syntax error""),
  				 errdetail(""Empty query."")));
 	if (LTXTQUERY_TOO_BIG(state.num, state.sumlen))
 		ereport(ERROR,
 				(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),
 				 errmsg(""ltxtquery is too large"")));
  	commonlen = COMPUTESIZE(state.num, state.sumlen);
  	query = (ltxtquery *) palloc(commonlen);
  	SET_VARSIZE(query, commonlen);
  	query->size = state.num;
 	ptr = GETQUERY(query);
 	for (i = 0; i < state.num; i++)
 	{
 		ptr[i].type = state.str->type;
 		ptr[i].val = state.str->val;
 		ptr[i].distance = state.str->distance;
 		ptr[i].length = state.str->length;
 		ptr[i].flag = state.str->flag;
 		tmp = state.str->next;
 		pfree(state.str);
 		state.str = tmp;
 	}
 	memcpy((void *) GETOPERAND(query), (void *) state.op, state.sumlen);
 	pfree(state.op);
 	pos = 0;
 	findoprnd(ptr, &pos);
 	return query;
 }","[29, 30, 31, 32]","Multiple integer overflows in contrib/hstore/hstore_io.c in PostgreSQL 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact via vectors related to the (1) hstore_recv, (2) hstore_from_arrays, and (3) hstore_from_array functions in contrib/hstore/hstore_io.c; and the (4) hstoreArrayToPairs function in contrib/hstore/hstore_op.c, which triggers a buffer overflow.  NOTE: this issue was SPLIT from CVE-2014-0064 because it has a different set of affected versions.",postgres,CVE-2014-2669,CWE-189
491,181494," static int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)
 {
  	jp2_cmap_t *cmap = &box->data.cmap;
  	jp2_cmapent_t *ent;
  	unsigned int i;
 	cmap->ents = 0;
  	cmap->numchans = (box->datalen) / 4;
  	if (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {
 		return -1;
 	}
 	for (i = 0; i < cmap->numchans; ++i) {
 		ent = &cmap->ents[i];
 		if (jp2_getuint16(in, &ent->cmptno) ||
 		  jp2_getuint8(in, &ent->map) ||
 		  jp2_getuint8(in, &ent->pcol)) {
 			return -1;
 		}
 	}
 	return 0;
 }",[6],The jp2_cdef_destroy function in jp2_cod.c in JasPer before 2.0.13 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted image.,jasper,CVE-2017-6850,CWE-476
498,182844," ZSTD_compressSequences_internal(seqStore_t* seqStorePtr,
                               ZSTD_entropyCTables_t const* prevEntropy,
                               ZSTD_entropyCTables_t* nextEntropy,
                               ZSTD_CCtx_params const* cctxParams,
                               void* dst, size_t dstCapacity,
                               void* workspace, size_t wkspSize,
                               const int bmi2)
 {
     const int longOffsets = cctxParams->cParams.windowLog > STREAM_ACCUMULATOR_MIN;
     ZSTD_strategy const strategy = cctxParams->cParams.strategy;
     U32 count[MaxSeq+1];
     FSE_CTable* CTable_LitLength = nextEntropy->fse.litlengthCTable;
     FSE_CTable* CTable_OffsetBits = nextEntropy->fse.offcodeCTable;
     FSE_CTable* CTable_MatchLength = nextEntropy->fse.matchlengthCTable;
     U32 LLtype, Offtype, MLtype;    
     const seqDef* const sequences = seqStorePtr->sequencesStart;
     const BYTE* const ofCodeTable = seqStorePtr->ofCode;
     const BYTE* const llCodeTable = seqStorePtr->llCode;
     const BYTE* const mlCodeTable = seqStorePtr->mlCode;
     BYTE* const ostart = (BYTE*)dst;
     BYTE* const oend = ostart + dstCapacity;
     BYTE* op = ostart;
     size_t const nbSeq = seqStorePtr->sequences - seqStorePtr->sequencesStart;
     BYTE* seqHead;
     BYTE* lastNCount = NULL;
     ZSTD_STATIC_ASSERT(HUF_WORKSPACE_SIZE >= (1<<MAX(MLFSELog,LLFSELog)));
     {   const BYTE* const literals = seqStorePtr->litStart;
         size_t const litSize = seqStorePtr->lit - literals;
         int const disableLiteralCompression = (cctxParams->cParams.strategy == ZSTD_fast) && (cctxParams->cParams.targetLength > 0);
         size_t const cSize = ZSTD_compressLiterals(
                                     &prevEntropy->huf, &nextEntropy->huf,
                                     cctxParams->cParams.strategy, disableLiteralCompression,
                                     op, dstCapacity,
                                     literals, litSize,
                                     workspace, wkspSize,
                                     bmi2);
         if (ZSTD_isError(cSize))
           return cSize;
         assert(cSize <= dstCapacity);
         op += cSize;
     }
     if ((oend-op) < 3   + 1  ) return ERROR(dstSize_tooSmall);
     if (nbSeq < 0x7F)
         *op++ = (BYTE)nbSeq;
     else if (nbSeq < LONGNBSEQ)
         op[0] = (BYTE)((nbSeq>>8) + 0x80), op[1] = (BYTE)nbSeq, op+=2;
     else
         op[0]=0xFF, MEM_writeLE16(op+1, (U16)(nbSeq - LONGNBSEQ)), op+=3;
     if (nbSeq==0) {
         memcpy(&nextEntropy->fse, &prevEntropy->fse, sizeof(prevEntropy->fse));
         return op - ostart;
     }
     seqHead = op++;
     ZSTD_seqToCodes(seqStorePtr);
     {   U32 max = MaxLL;
         size_t const mostFrequent = HIST_countFast_wksp(count, &max, llCodeTable, nbSeq, workspace, wkspSize);    
         DEBUGLOG(5, ""Building LL table"");
         nextEntropy->fse.litlength_repeatMode = prevEntropy->fse.litlength_repeatMode;
         LLtype = ZSTD_selectEncodingType(&nextEntropy->fse.litlength_repeatMode, count, max, mostFrequent, nbSeq, LLFSELog, prevEntropy->fse.litlengthCTable, LL_defaultNorm, LL_defaultNormLog, ZSTD_defaultAllowed, strategy);
         assert(set_basic < set_compressed && set_rle < set_compressed);
         assert(!(LLtype < set_compressed && nextEntropy->fse.litlength_repeatMode != FSE_repeat_none));  
         {   size_t const countSize = ZSTD_buildCTable(op, oend - op, CTable_LitLength, LLFSELog, (symbolEncodingType_e)LLtype,
                                                     count, max, llCodeTable, nbSeq, LL_defaultNorm, LL_defaultNormLog, MaxLL,
                                                     prevEntropy->fse.litlengthCTable, sizeof(prevEntropy->fse.litlengthCTable),
                                                     workspace, wkspSize);
             if (ZSTD_isError(countSize)) return countSize;
             if (LLtype == set_compressed)
                 lastNCount = op;
             op += countSize;
     }   }
     {   U32 max = MaxOff;
         size_t const mostFrequent = HIST_countFast_wksp(count, &max, ofCodeTable, nbSeq, workspace, wkspSize);   
         ZSTD_defaultPolicy_e const defaultPolicy = (max <= DefaultMaxOff) ? ZSTD_defaultAllowed : ZSTD_defaultDisallowed;
         DEBUGLOG(5, ""Building OF table"");
         nextEntropy->fse.offcode_repeatMode = prevEntropy->fse.offcode_repeatMode;
         Offtype = ZSTD_selectEncodingType(&nextEntropy->fse.offcode_repeatMode, count, max, mostFrequent, nbSeq, OffFSELog, prevEntropy->fse.offcodeCTable, OF_defaultNorm, OF_defaultNormLog, defaultPolicy, strategy);
         assert(!(Offtype < set_compressed && nextEntropy->fse.offcode_repeatMode != FSE_repeat_none));  
         {   size_t const countSize = ZSTD_buildCTable(op, oend - op, CTable_OffsetBits, OffFSELog, (symbolEncodingType_e)Offtype,
                                                     count, max, ofCodeTable, nbSeq, OF_defaultNorm, OF_defaultNormLog, DefaultMaxOff,
                                                     prevEntropy->fse.offcodeCTable, sizeof(prevEntropy->fse.offcodeCTable),
                                                     workspace, wkspSize);
             if (ZSTD_isError(countSize)) return countSize;
             if (Offtype == set_compressed)
                 lastNCount = op;
             op += countSize;
     }   }
      {   U32 max = MaxML;
          size_t const mostFrequent = HIST_countFast_wksp(count, &max, mlCodeTable, nbSeq, workspace, wkspSize);    
        DEBUGLOG(5, ""Building ML table"");
         DEBUGLOG(5, ""Building ML table (remaining space : %i)"", (int)(oend-op));
          nextEntropy->fse.matchlength_repeatMode = prevEntropy->fse.matchlength_repeatMode;
          MLtype = ZSTD_selectEncodingType(&nextEntropy->fse.matchlength_repeatMode, count, max, mostFrequent, nbSeq, MLFSELog, prevEntropy->fse.matchlengthCTable, ML_defaultNorm, ML_defaultNormLog, ZSTD_defaultAllowed, strategy);
          assert(!(MLtype < set_compressed && nextEntropy->fse.matchlength_repeatMode != FSE_repeat_none));  
         {   size_t const countSize = ZSTD_buildCTable(op, oend - op, CTable_MatchLength, MLFSELog, (symbolEncodingType_e)MLtype,
                                                     count, max, mlCodeTable, nbSeq, ML_defaultNorm, ML_defaultNormLog, MaxML,
                                                     prevEntropy->fse.matchlengthCTable, sizeof(prevEntropy->fse.matchlengthCTable),
                                                     workspace, wkspSize);
             if (ZSTD_isError(countSize)) return countSize;
             if (MLtype == set_compressed)
                 lastNCount = op;
             op += countSize;
     }   }
     *seqHead = (BYTE)((LLtype<<6) + (Offtype<<4) + (MLtype<<2));
     {   size_t const bitstreamSize = ZSTD_encodeSequences(
                                         op, oend - op,
                                         CTable_MatchLength, mlCodeTable,
                                         CTable_OffsetBits, ofCodeTable,
                                         CTable_LitLength, llCodeTable,
                                         sequences, nbSeq,
                                         longOffsets, bmi2);
         if (ZSTD_isError(bitstreamSize)) return bitstreamSize;
         op += bitstreamSize;
         if (lastNCount && (op - lastNCount) < 4) {
             assert(op - lastNCount == 3);
             DEBUGLOG(5, ""Avoiding bug in zstd decoder in versions <= 1.3.4 by ""
                         ""emitting an uncompressed block."");
             return 0;
         }
     }
     return op - ostart;
 }","[89, 90]",A race condition in the one-pass compression functions of Zstandard prior to version 1.3.8 could allow an attacker to write bytes out of bounds if an output buffer smaller than the recommended size was used.,zstd,CVE-2019-11922,CWE-362
500,182359," gimp_write_and_read_file (Gimp     *gimp,
                           gboolean  with_unusual_stuff,
                           gboolean  compat_paths,
                           gboolean  use_gimp_2_8_features)
 {
    GimpImage           *image;
    GimpImage           *loaded_image;
    GimpPlugInProcedure *proc;
  gchar               *filename;
   gchar               *filename = NULL;
   gint                 file_handle;
    GFile               *file;
   image = gimp_create_mainimage (gimp,
                                  with_unusual_stuff,
                                  compat_paths,
                                  use_gimp_2_8_features);
   gimp_assert_mainimage (image,
                          with_unusual_stuff,
                          compat_paths,
                           use_gimp_2_8_features);
  filename = g_build_filename (g_get_tmp_dir (), ""gimp-test.xcf"", NULL);
   file_handle = g_file_open_tmp (""gimp-test-XXXXXX.xcf"", &filename, NULL);
   g_assert (file_handle != -1);
   close (file_handle);
    file = g_file_new_for_path (filename);
    g_free (filename);
   proc = gimp_plug_in_manager_file_procedure_find (image->gimp->plug_in_manager,
                                                    GIMP_FILE_PROCEDURE_GROUP_SAVE,
                                                    file,
                                                    NULL  );
   file_save (gimp,
              image,
              NULL  ,
              file,
              proc,
              GIMP_RUN_NONINTERACTIVE,
              FALSE  ,
              FALSE  ,
              FALSE  ,
              NULL  );
   loaded_image = gimp_test_load_image (image->gimp, file);
   gimp_assert_mainimage (loaded_image,
                          with_unusual_stuff,
                          compat_paths,
                          use_gimp_2_8_features);
   g_file_delete (file, NULL, NULL);
   g_object_unref (file);
 }","[9, 10, 11, 21, 22, 23, 24]","GIMP through 2.10.2 makes g_get_tmp_dir calls to establish temporary filenames, which may result in a filename that already exists, as demonstrated by the gimp_write_and_read_file function in app/tests/test-xcf.c. This might be leveraged by attackers to overwrite files or read file content that was intended to be private.",gimp,CVE-2018-12713,CWE-20
504,179034," int rpc_type_of_NPNVariable(int variable)
 {
   int type;
   switch (variable) {
   case NPNVjavascriptEnabledBool:
   case NPNVasdEnabledBool:
    case NPNVisOfflineBool:
    case NPNVSupportsXEmbedBool:
    case NPNVSupportsWindowless:
   case NPNVprivateModeBool:
   case NPNVsupportsAdvancedKeyHandling:
  	type = RPC_TYPE_BOOLEAN;
  	break;
    case NPNVToolkit:
   case NPNVnetscapeWindow:
 	type = RPC_TYPE_UINT32;
 	break;
   case NPNVWindowNPObject:
   case NPNVPluginElementNPObject:
 	type = RPC_TYPE_NP_OBJECT;
 	break;
   default:
 	type = RPC_ERROR_GENERIC;
 	break;
   }
   return type;
 }","[10, 11]","nspluginwrapper before 1.4.4 does not properly provide access to NPNVprivateModeBool variable settings, which could prevent Firefox plugins from determining if they should run in Private Browsing mode and allow remote attackers to bypass intended access restrictions, as demonstrated using Flash.",nspluginwrapper,CVE-2011-2486,CWE-264
506,181658," int read_escaped_char(
     yyscan_t yyscanner,
     uint8_t* escaped_char)
 {
   char text[4] = {0, 0, 0, 0};
    text[0] = '\\';
    text[1] = RE_YY_INPUT(yyscanner);
  if (text[1] == EOF)
   if (text[1] == EOF || text[1] == 0)
      return 0;
    if (text[1] == 'x')
    {
      text[2] = RE_YY_INPUT(yyscanner);
    if (text[2] == EOF)
     if (!isxdigit(text[2]))
        return 0;
      text[3] = RE_YY_INPUT(yyscanner);
    if (text[3] == EOF)
     if (!isxdigit(text[3]))
        return 0;
    }
   *escaped_char = escaped_char_value(text);
   return 1;
 }","[8, 9, 14, 15, 18, 19]",libyara/lexer.l in YARA 3.5.0 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted rule that is mishandled in the yy_get_next_buffer function.,yara,CVE-2016-10210,CWE-476
520,182230," auth_read_binary(struct sc_card *card, unsigned int offset,
 		unsigned char *buf, size_t count, unsigned long flags)
 {
 	int rv;
 	struct sc_pkcs15_bignum bn[2];
 	unsigned char *out = NULL;
 	bn[0].data = NULL;
  	bn[1].data = NULL;
  	LOG_FUNC_CALLED(card->ctx);
 	if (!auth_current_ef)
 		LOG_TEST_RET(card->ctx, SC_ERROR_INVALID_ARGUMENTS, ""Invalid auth_current_ef"");
  	sc_log(card->ctx,
  	       ""offset %i; size %""SC_FORMAT_LEN_SIZE_T""u; flags 0x%lX"",
  	       offset, count, flags);
 	sc_log(card->ctx,""last selected : magic %X; ef %X"",
 			auth_current_ef->magic, auth_current_ef->ef_structure);
 	if (offset & ~0x7FFF)
 		LOG_TEST_RET(card->ctx, SC_ERROR_INVALID_ARGUMENTS, ""Invalid file offset"");
 	if (auth_current_ef->magic==SC_FILE_MAGIC &&
 			auth_current_ef->ef_structure == SC_CARDCTL_OBERTHUR_KEY_RSA_PUBLIC)   {
 		int jj;
 		unsigned char resp[256];
 		size_t resp_len, out_len;
 		struct sc_pkcs15_pubkey_rsa key;
 		resp_len = sizeof(resp);
 		rv = auth_read_component(card, SC_CARDCTL_OBERTHUR_KEY_RSA_PUBLIC,
 				2, resp, resp_len);
 		LOG_TEST_RET(card->ctx, rv, ""read component failed"");
 		for (jj=0; jj<rv && *(resp+jj)==0; jj++)
 			;
 		bn[0].data = calloc(1, rv - jj);
 		if (!bn[0].data) {
 			rv = SC_ERROR_OUT_OF_MEMORY;
 			goto err;
 		}
 		bn[0].len = rv - jj;
 		memcpy(bn[0].data, resp + jj, rv - jj);
 		rv = auth_read_component(card, SC_CARDCTL_OBERTHUR_KEY_RSA_PUBLIC,
 				1, resp, resp_len);
 		LOG_TEST_GOTO_ERR(card->ctx, rv, ""Cannot read RSA public key component"");
 		bn[1].data = calloc(1, rv);
 		if (!bn[1].data) {
 			rv = SC_ERROR_OUT_OF_MEMORY;
 			goto err;
 		}
 		bn[1].len = rv;
 		memcpy(bn[1].data, resp, rv);
 		key.exponent = bn[0];
 		key.modulus = bn[1];
 		if (sc_pkcs15_encode_pubkey_rsa(card->ctx, &key, &out, &out_len)) {
 			rv = SC_ERROR_INVALID_ASN1_OBJECT;
 			LOG_TEST_GOTO_ERR(card->ctx, rv, ""cannot encode RSA public key"");
 		}
 		else {
 			rv  = out_len - offset > count ? count : out_len - offset;
 			memcpy(buf, out + offset, rv);
 			sc_log_hex(card->ctx, ""write_publickey"", buf, rv);
 		}
 	}
 	else {
 		rv = iso_ops->read_binary(card, offset, buf, count, 0);
 	}
 err:
 	free(bn[0].data);
 	free(bn[1].data);
 	free(out);
 	LOG_FUNC_RETURN(card->ctx, rv);
 }","[10, 11]",Various out of bounds reads when handling responses in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to potentially crash the opensc library using programs.,OpenSC,CVE-2018-16427,CWE-125
525,182879," static int hls_slice_header(HEVCContext *s)
 {
     GetBitContext *gb = &s->HEVClc->gb;
     SliceHeader *sh   = &s->sh;
     int i, ret;
      sh->first_slice_in_pic_flag = get_bits1(gb);
     if (s->ref && sh->first_slice_in_pic_flag) {
         av_log(s->avctx, AV_LOG_ERROR, ""Two slices reporting being the first in the same frame.\n"");
         return 1;  
     }
      if ((IS_IDR(s) || IS_BLA(s)) && sh->first_slice_in_pic_flag) {
          s->seq_decode = (s->seq_decode + 1) & 0xff;
          s->max_ra     = INT_MAX;
         if (IS_IDR(s))
             ff_hevc_clear_refs(s);
     }
     sh->no_output_of_prior_pics_flag = 0;
     if (IS_IRAP(s))
         sh->no_output_of_prior_pics_flag = get_bits1(gb);
     sh->pps_id = get_ue_golomb_long(gb);
     if (sh->pps_id >= HEVC_MAX_PPS_COUNT || !s->ps.pps_list[sh->pps_id]) {
         av_log(s->avctx, AV_LOG_ERROR, ""PPS id out of range: %d\n"", sh->pps_id);
         return AVERROR_INVALIDDATA;
     }
     if (!sh->first_slice_in_pic_flag &&
         s->ps.pps != (HEVCPPS*)s->ps.pps_list[sh->pps_id]->data) {
         av_log(s->avctx, AV_LOG_ERROR, ""PPS changed between slices.\n"");
         return AVERROR_INVALIDDATA;
     }
     s->ps.pps = (HEVCPPS*)s->ps.pps_list[sh->pps_id]->data;
     if (s->nal_unit_type == HEVC_NAL_CRA_NUT && s->last_eos == 1)
         sh->no_output_of_prior_pics_flag = 1;
     if (s->ps.sps != (HEVCSPS*)s->ps.sps_list[s->ps.pps->sps_id]->data) {
         const HEVCSPS *sps = (HEVCSPS*)s->ps.sps_list[s->ps.pps->sps_id]->data;
         const HEVCSPS *last_sps = s->ps.sps;
         enum AVPixelFormat pix_fmt;
         if (last_sps && IS_IRAP(s) && s->nal_unit_type != HEVC_NAL_CRA_NUT) {
             if (sps->width != last_sps->width || sps->height != last_sps->height ||
                 sps->temporal_layer[sps->max_sub_layers - 1].max_dec_pic_buffering !=
                 last_sps->temporal_layer[last_sps->max_sub_layers - 1].max_dec_pic_buffering)
                 sh->no_output_of_prior_pics_flag = 0;
         }
         ff_hevc_clear_refs(s);
         ret = set_sps(s, sps, sps->pix_fmt);
         if (ret < 0)
             return ret;
         pix_fmt = get_format(s, sps);
         if (pix_fmt < 0)
             return pix_fmt;
         s->avctx->pix_fmt = pix_fmt;
         s->seq_decode = (s->seq_decode + 1) & 0xff;
         s->max_ra     = INT_MAX;
     }
     sh->dependent_slice_segment_flag = 0;
     if (!sh->first_slice_in_pic_flag) {
         int slice_address_length;
         if (s->ps.pps->dependent_slice_segments_enabled_flag)
             sh->dependent_slice_segment_flag = get_bits1(gb);
         slice_address_length = av_ceil_log2(s->ps.sps->ctb_width *
                                             s->ps.sps->ctb_height);
         sh->slice_segment_addr = get_bitsz(gb, slice_address_length);
         if (sh->slice_segment_addr >= s->ps.sps->ctb_width * s->ps.sps->ctb_height) {
             av_log(s->avctx, AV_LOG_ERROR,
                    ""Invalid slice segment address: %u.\n"",
                    sh->slice_segment_addr);
             return AVERROR_INVALIDDATA;
         }
         if (!sh->dependent_slice_segment_flag) {
             sh->slice_addr = sh->slice_segment_addr;
             s->slice_idx++;
         }
     } else {
         sh->slice_segment_addr = sh->slice_addr = 0;
         s->slice_idx           = 0;
         s->slice_initialized   = 0;
     }
     if (!sh->dependent_slice_segment_flag) {
         s->slice_initialized = 0;
         for (i = 0; i < s->ps.pps->num_extra_slice_header_bits; i++)
             skip_bits(gb, 1);   
         sh->slice_type = get_ue_golomb_long(gb);
         if (!(sh->slice_type == HEVC_SLICE_I ||
               sh->slice_type == HEVC_SLICE_P ||
               sh->slice_type == HEVC_SLICE_B)) {
             av_log(s->avctx, AV_LOG_ERROR, ""Unknown slice type: %d.\n"",
                    sh->slice_type);
             return AVERROR_INVALIDDATA;
         }
         if (IS_IRAP(s) && sh->slice_type != HEVC_SLICE_I) {
             av_log(s->avctx, AV_LOG_ERROR, ""Inter slices in an IRAP frame.\n"");
             return AVERROR_INVALIDDATA;
         }
         sh->pic_output_flag = 1;
         if (s->ps.pps->output_flag_present_flag)
             sh->pic_output_flag = get_bits1(gb);
         if (s->ps.sps->separate_colour_plane_flag)
             sh->colour_plane_id = get_bits(gb, 2);
         if (!IS_IDR(s)) {
             int poc, pos;
             sh->pic_order_cnt_lsb = get_bits(gb, s->ps.sps->log2_max_poc_lsb);
             poc = ff_hevc_compute_poc(s->ps.sps, s->pocTid0, sh->pic_order_cnt_lsb, s->nal_unit_type);
             if (!sh->first_slice_in_pic_flag && poc != s->poc) {
                 av_log(s->avctx, AV_LOG_WARNING,
                        ""Ignoring POC change between slices: %d -> %d\n"", s->poc, poc);
                 if (s->avctx->err_recognition & AV_EF_EXPLODE)
                     return AVERROR_INVALIDDATA;
                 poc = s->poc;
             }
             s->poc = poc;
             sh->short_term_ref_pic_set_sps_flag = get_bits1(gb);
             pos = get_bits_left(gb);
             if (!sh->short_term_ref_pic_set_sps_flag) {
                 ret = ff_hevc_decode_short_term_rps(gb, s->avctx, &sh->slice_rps, s->ps.sps, 1);
                 if (ret < 0)
                     return ret;
                 sh->short_term_rps = &sh->slice_rps;
             } else {
                 int numbits, rps_idx;
                 if (!s->ps.sps->nb_st_rps) {
                     av_log(s->avctx, AV_LOG_ERROR, ""No ref lists in the SPS.\n"");
                     return AVERROR_INVALIDDATA;
                 }
                 numbits = av_ceil_log2(s->ps.sps->nb_st_rps);
                 rps_idx = numbits > 0 ? get_bits(gb, numbits) : 0;
                 sh->short_term_rps = &s->ps.sps->st_rps[rps_idx];
             }
             sh->short_term_ref_pic_set_size = pos - get_bits_left(gb);
             pos = get_bits_left(gb);
             ret = decode_lt_rps(s, &sh->long_term_rps, gb);
             if (ret < 0) {
                 av_log(s->avctx, AV_LOG_WARNING, ""Invalid long term RPS.\n"");
                 if (s->avctx->err_recognition & AV_EF_EXPLODE)
                     return AVERROR_INVALIDDATA;
             }
             sh->long_term_ref_pic_set_size = pos - get_bits_left(gb);
             if (s->ps.sps->sps_temporal_mvp_enabled_flag)
                 sh->slice_temporal_mvp_enabled_flag = get_bits1(gb);
             else
                 sh->slice_temporal_mvp_enabled_flag = 0;
         } else {
             s->sh.short_term_rps = NULL;
             s->poc               = 0;
         }
         if (sh->first_slice_in_pic_flag && s->temporal_id == 0 &&
             s->nal_unit_type != HEVC_NAL_TRAIL_N &&
             s->nal_unit_type != HEVC_NAL_TSA_N   &&
             s->nal_unit_type != HEVC_NAL_STSA_N  &&
             s->nal_unit_type != HEVC_NAL_RADL_N  &&
             s->nal_unit_type != HEVC_NAL_RADL_R  &&
             s->nal_unit_type != HEVC_NAL_RASL_N  &&
             s->nal_unit_type != HEVC_NAL_RASL_R)
             s->pocTid0 = s->poc;
         if (s->ps.sps->sao_enabled) {
             sh->slice_sample_adaptive_offset_flag[0] = get_bits1(gb);
             if (s->ps.sps->chroma_format_idc) {
                 sh->slice_sample_adaptive_offset_flag[1] =
                 sh->slice_sample_adaptive_offset_flag[2] = get_bits1(gb);
             }
         } else {
             sh->slice_sample_adaptive_offset_flag[0] = 0;
             sh->slice_sample_adaptive_offset_flag[1] = 0;
             sh->slice_sample_adaptive_offset_flag[2] = 0;
         }
         sh->nb_refs[L0] = sh->nb_refs[L1] = 0;
         if (sh->slice_type == HEVC_SLICE_P || sh->slice_type == HEVC_SLICE_B) {
             int nb_refs;
             sh->nb_refs[L0] = s->ps.pps->num_ref_idx_l0_default_active;
             if (sh->slice_type == HEVC_SLICE_B)
                 sh->nb_refs[L1] = s->ps.pps->num_ref_idx_l1_default_active;
             if (get_bits1(gb)) {  
                 sh->nb_refs[L0] = get_ue_golomb_long(gb) + 1;
                 if (sh->slice_type == HEVC_SLICE_B)
                     sh->nb_refs[L1] = get_ue_golomb_long(gb) + 1;
             }
             if (sh->nb_refs[L0] > HEVC_MAX_REFS || sh->nb_refs[L1] > HEVC_MAX_REFS) {
                 av_log(s->avctx, AV_LOG_ERROR, ""Too many refs: %d/%d.\n"",
                        sh->nb_refs[L0], sh->nb_refs[L1]);
                 return AVERROR_INVALIDDATA;
             }
             sh->rpl_modification_flag[0] = 0;
             sh->rpl_modification_flag[1] = 0;
             nb_refs = ff_hevc_frame_nb_refs(s);
             if (!nb_refs) {
                 av_log(s->avctx, AV_LOG_ERROR, ""Zero refs for a frame with P or B slices.\n"");
                 return AVERROR_INVALIDDATA;
             }
             if (s->ps.pps->lists_modification_present_flag && nb_refs > 1) {
                 sh->rpl_modification_flag[0] = get_bits1(gb);
                 if (sh->rpl_modification_flag[0]) {
                     for (i = 0; i < sh->nb_refs[L0]; i++)
                         sh->list_entry_lx[0][i] = get_bits(gb, av_ceil_log2(nb_refs));
                 }
                 if (sh->slice_type == HEVC_SLICE_B) {
                     sh->rpl_modification_flag[1] = get_bits1(gb);
                     if (sh->rpl_modification_flag[1] == 1)
                         for (i = 0; i < sh->nb_refs[L1]; i++)
                             sh->list_entry_lx[1][i] = get_bits(gb, av_ceil_log2(nb_refs));
                 }
             }
             if (sh->slice_type == HEVC_SLICE_B)
                 sh->mvd_l1_zero_flag = get_bits1(gb);
             if (s->ps.pps->cabac_init_present_flag)
                 sh->cabac_init_flag = get_bits1(gb);
             else
                 sh->cabac_init_flag = 0;
             sh->collocated_ref_idx = 0;
             if (sh->slice_temporal_mvp_enabled_flag) {
                 sh->collocated_list = L0;
                 if (sh->slice_type == HEVC_SLICE_B)
                     sh->collocated_list = !get_bits1(gb);
                 if (sh->nb_refs[sh->collocated_list] > 1) {
                     sh->collocated_ref_idx = get_ue_golomb_long(gb);
                     if (sh->collocated_ref_idx >= sh->nb_refs[sh->collocated_list]) {
                         av_log(s->avctx, AV_LOG_ERROR,
                                ""Invalid collocated_ref_idx: %d.\n"",
                                sh->collocated_ref_idx);
                         return AVERROR_INVALIDDATA;
                     }
                 }
             }
             if ((s->ps.pps->weighted_pred_flag   && sh->slice_type == HEVC_SLICE_P) ||
                 (s->ps.pps->weighted_bipred_flag && sh->slice_type == HEVC_SLICE_B)) {
                 int ret = pred_weight_table(s, gb);
                 if (ret < 0)
                     return ret;
             }
             sh->max_num_merge_cand = 5 - get_ue_golomb_long(gb);
             if (sh->max_num_merge_cand < 1 || sh->max_num_merge_cand > 5) {
                 av_log(s->avctx, AV_LOG_ERROR,
                        ""Invalid number of merging MVP candidates: %d.\n"",
                        sh->max_num_merge_cand);
                 return AVERROR_INVALIDDATA;
             }
         }
         sh->slice_qp_delta = get_se_golomb(gb);
         if (s->ps.pps->pic_slice_level_chroma_qp_offsets_present_flag) {
             sh->slice_cb_qp_offset = get_se_golomb(gb);
             sh->slice_cr_qp_offset = get_se_golomb(gb);
         } else {
             sh->slice_cb_qp_offset = 0;
             sh->slice_cr_qp_offset = 0;
         }
         if (s->ps.pps->chroma_qp_offset_list_enabled_flag)
             sh->cu_chroma_qp_offset_enabled_flag = get_bits1(gb);
         else
             sh->cu_chroma_qp_offset_enabled_flag = 0;
         if (s->ps.pps->deblocking_filter_control_present_flag) {
             int deblocking_filter_override_flag = 0;
             if (s->ps.pps->deblocking_filter_override_enabled_flag)
                 deblocking_filter_override_flag = get_bits1(gb);
             if (deblocking_filter_override_flag) {
                 sh->disable_deblocking_filter_flag = get_bits1(gb);
                 if (!sh->disable_deblocking_filter_flag) {
                     int beta_offset_div2 = get_se_golomb(gb);
                     int tc_offset_div2   = get_se_golomb(gb) ;
                     if (beta_offset_div2 < -6 || beta_offset_div2 > 6 ||
                         tc_offset_div2   < -6 || tc_offset_div2   > 6) {
                         av_log(s->avctx, AV_LOG_ERROR,
                             ""Invalid deblock filter offsets: %d, %d\n"",
                             beta_offset_div2, tc_offset_div2);
                         return AVERROR_INVALIDDATA;
                     }
                     sh->beta_offset = beta_offset_div2 * 2;
                     sh->tc_offset   =   tc_offset_div2 * 2;
                 }
             } else {
                 sh->disable_deblocking_filter_flag = s->ps.pps->disable_dbf;
                 sh->beta_offset                    = s->ps.pps->beta_offset;
                 sh->tc_offset                      = s->ps.pps->tc_offset;
             }
         } else {
             sh->disable_deblocking_filter_flag = 0;
             sh->beta_offset                    = 0;
             sh->tc_offset                      = 0;
         }
         if (s->ps.pps->seq_loop_filter_across_slices_enabled_flag &&
             (sh->slice_sample_adaptive_offset_flag[0] ||
              sh->slice_sample_adaptive_offset_flag[1] ||
              !sh->disable_deblocking_filter_flag)) {
             sh->slice_loop_filter_across_slices_enabled_flag = get_bits1(gb);
         } else {
             sh->slice_loop_filter_across_slices_enabled_flag = s->ps.pps->seq_loop_filter_across_slices_enabled_flag;
         }
     } else if (!s->slice_initialized) {
         av_log(s->avctx, AV_LOG_ERROR, ""Independent slice segment missing.\n"");
         return AVERROR_INVALIDDATA;
     }
     sh->num_entry_point_offsets = 0;
     if (s->ps.pps->tiles_enabled_flag || s->ps.pps->entropy_coding_sync_enabled_flag) {
         unsigned num_entry_point_offsets = get_ue_golomb_long(gb);
         if (num_entry_point_offsets > get_bits_left(gb)) {
             av_log(s->avctx, AV_LOG_ERROR, ""num_entry_point_offsets %d is invalid\n"", num_entry_point_offsets);
             return AVERROR_INVALIDDATA;
         }
         sh->num_entry_point_offsets = num_entry_point_offsets;
         if (sh->num_entry_point_offsets > 0) {
             int offset_len = get_ue_golomb_long(gb) + 1;
             if (offset_len < 1 || offset_len > 32) {
                 sh->num_entry_point_offsets = 0;
                 av_log(s->avctx, AV_LOG_ERROR, ""offset_len %d is invalid\n"", offset_len);
                 return AVERROR_INVALIDDATA;
             }
             av_freep(&sh->entry_point_offset);
             av_freep(&sh->offset);
             av_freep(&sh->size);
             sh->entry_point_offset = av_malloc_array(sh->num_entry_point_offsets, sizeof(unsigned));
             sh->offset = av_malloc_array(sh->num_entry_point_offsets, sizeof(int));
             sh->size = av_malloc_array(sh->num_entry_point_offsets, sizeof(int));
             if (!sh->entry_point_offset || !sh->offset || !sh->size) {
                 sh->num_entry_point_offsets = 0;
                 av_log(s->avctx, AV_LOG_ERROR, ""Failed to allocate memory\n"");
                 return AVERROR(ENOMEM);
             }
             for (i = 0; i < sh->num_entry_point_offsets; i++) {
                 unsigned val = get_bits_long(gb, offset_len);
                 sh->entry_point_offset[i] = val + 1;  
             }
             if (s->threads_number > 1 && (s->ps.pps->num_tile_rows > 1 || s->ps.pps->num_tile_columns > 1)) {
                 s->enable_parallel_tiles = 0;  
                 s->threads_number = 1;
             } else
                 s->enable_parallel_tiles = 0;
         } else
             s->enable_parallel_tiles = 0;
     }
     if (s->ps.pps->slice_header_extension_present_flag) {
         unsigned int length = get_ue_golomb_long(gb);
         if (length*8LL > get_bits_left(gb)) {
             av_log(s->avctx, AV_LOG_ERROR, ""too many slice_header_extension_data_bytes\n"");
             return AVERROR_INVALIDDATA;
         }
         for (i = 0; i < length; i++)
             skip_bits(gb, 8);   
     }
     sh->slice_qp = 26U + s->ps.pps->pic_init_qp_minus26 + sh->slice_qp_delta;
     if (sh->slice_qp > 51 ||
         sh->slice_qp < -s->ps.sps->qp_bd_offset) {
         av_log(s->avctx, AV_LOG_ERROR,
                ""The slice_qp %d is outside the valid range ""
                ""[%d, 51].\n"",
                sh->slice_qp,
                -s->ps.sps->qp_bd_offset);
         return AVERROR_INVALIDDATA;
     }
     sh->slice_ctb_addr_rs = sh->slice_segment_addr;
     if (!s->sh.slice_ctb_addr_rs && s->sh.dependent_slice_segment_flag) {
         av_log(s->avctx, AV_LOG_ERROR, ""Impossible slice segment.\n"");
         return AVERROR_INVALIDDATA;
     }
     if (get_bits_left(gb) < 0) {
         av_log(s->avctx, AV_LOG_ERROR,
                ""Overread slice header by %d bits\n"", -get_bits_left(gb));
         return AVERROR_INVALIDDATA;
     }
     s->HEVClc->first_qp_group = !s->sh.dependent_slice_segment_flag;
     if (!s->ps.pps->cu_qp_delta_enabled_flag)
         s->HEVClc->qp_y = s->sh.slice_qp;
     s->slice_initialized = 1;
     s->HEVClc->tu.cu_qp_offset_cb = 0;
     s->HEVClc->tu.cu_qp_offset_cr = 0;
     return 0;
 }","[7, 8, 9, 10]","libavcodec/hevcdec.c in FFmpeg 4.1.2 mishandles detection of duplicate first slices, which allows remote attackers to cause a denial of service (NULL pointer dereference and out-of-array access) or possibly have unspecified other impact via crafted HEVC data.",FFmpeg,CVE-2019-11338,CWE-476
526,182704," processInternalEntity(XML_Parser parser, ENTITY *entity, XML_Bool betweenDecl) {
   const char *textStart, *textEnd;
   const char *next;
   enum XML_Error result;
   OPEN_INTERNAL_ENTITY *openEntity;
   if (parser->m_freeInternalEntities) {
     openEntity = parser->m_freeInternalEntities;
     parser->m_freeInternalEntities = openEntity->next;
   } else {
     openEntity
         = (OPEN_INTERNAL_ENTITY *)MALLOC(parser, sizeof(OPEN_INTERNAL_ENTITY));
     if (! openEntity)
       return XML_ERROR_NO_MEMORY;
   }
   entity->open = XML_TRUE;
   entity->processed = 0;
   openEntity->next = parser->m_openInternalEntities;
   parser->m_openInternalEntities = openEntity;
   openEntity->entity = entity;
   openEntity->startTagLevel = parser->m_tagLevel;
   openEntity->betweenDecl = betweenDecl;
   openEntity->internalEventPtr = NULL;
   openEntity->internalEventEndPtr = NULL;
   textStart = (char *)entity->textPtr;
   textEnd = (char *)(entity->textPtr + entity->textLen);
   next = textStart;
 #ifdef XML_DTD
   if (entity->is_param) {
      int tok
          = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);
      result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,
                      tok, next, &next, XML_FALSE);
                       tok, next, &next, XML_FALSE, XML_FALSE);
    } else
  #endif  
      result = doContent(parser, parser->m_tagLevel, parser->m_internalEncoding,
                        textStart, textEnd, &next, XML_FALSE);
   if (result == XML_ERROR_NONE) {
     if (textEnd != next && parser->m_parsingStatus.parsing == XML_SUSPENDED) {
       entity->processed = (int)(next - textStart);
       parser->m_processor = internalEntityProcessor;
     } else {
       entity->open = XML_FALSE;
       parser->m_openInternalEntities = openEntity->next;
       openEntity->next = parser->m_freeInternalEntities;
       parser->m_freeInternalEntities = openEntity;
     }
   }
   return result;
 }","[32, 33]","In libexpat before 2.2.8, crafted XML input could fool the parser into changing from DTD parsing to document parsing too early; a consecutive call to XML_GetCurrentLineNumber (or XML_GetCurrentColumnNumber) then resulted in a heap-based buffer over-read.",libexpat,CVE-2019-15903,CWE-611
542,178509," create_bits (pixman_format_code_t format,
              int                  width,
              int                  height,
              int *		  rowstride_bytes,
 	     pixman_bool_t	  clear)
 {
     int stride;
     size_t buf_size;
     int bpp;
     bpp = PIXMAN_FORMAT_BPP (format);
     if (_pixman_multiply_overflows_int (width, bpp))
 	return NULL;
     stride = width * bpp;
     if (_pixman_addition_overflows_int (stride, 0x1f))
 	return NULL;
     stride += 0x1f;
     stride >>= 5;
     stride *= sizeof (uint32_t);
      if (_pixman_multiply_overflows_size (height, stride))
  	return NULL;
    buf_size = height * stride;
     buf_size = (size_t)height * stride;
      if (rowstride_bytes)
  	*rowstride_bytes = stride;
     if (clear)
 	return calloc (buf_size, 1);
     else
 	return malloc (buf_size);
 }","[21, 22]",Integer overflow in the create_bits function in pixman-bits-image.c in Pixman before 0.32.6 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via large height and stride values.,pixman,CVE-2014-9766,CWE-189
545,178441,"  int __glXDispSwap_CreateContext(__GLXclientState *cl, GLbyte *pc)
  {
     ClientPtr client = cl->client;
      xGLXCreateContextReq *req = (xGLXCreateContextReq *) pc;
      __GLX_DECLARE_SWAP_VARIABLES;
     REQUEST_SIZE_MATCH(xGLXCreateContextReq);
      __GLX_SWAP_SHORT(&req->length);
      __GLX_SWAP_INT(&req->context);
      __GLX_SWAP_INT(&req->visual);
     return __glXDisp_CreateContext(cl, pc);
 }","[3, 6]",The GLX extension in X.Org xserver 1.7.7 allows remote authenticated users to cause a denial of service (server crash) and possibly execute arbitrary code via (1) a crafted request that triggers a client swap in glx/glxcmdsswap.c; or (2) a crafted length or (3) a negative value in the screen field in a request to glx/glxcmds.c.,xserver,CVE-2010-4818,CWE-20
552,182245," epass2003_sm_unwrap_apdu(struct sc_card *card, struct sc_apdu *sm, struct sc_apdu *plain)
 {
 	int r;
 	size_t len = 0;
 	epass2003_exdata *exdata = NULL;
 	if (!card->drv_data) 
 		return SC_ERROR_INVALID_ARGUMENTS;
 	exdata = (epass2003_exdata *)card->drv_data;
 	LOG_FUNC_CALLED(card->ctx);
  	r = sc_check_sw(card, sm->sw1, sm->sw2);
  	if (r == SC_SUCCESS) {
  		if (exdata->sm) {
 			len = plain->resplen;
  			if (0 != decrypt_response(card, sm->resp, sm->resplen, plain->resp, &len))
  				return SC_ERROR_CARD_CMD_FAILED;
  		}
 		else {
 			memcpy(plain->resp, sm->resp, sm->resplen);
 			len = sm->resplen;
 		}
 	}
 	plain->resplen = len;
 	plain->sw1 = sm->sw1;
 	plain->sw2 = sm->sw2;
 	sc_log(card->ctx,
 	       ""unwrapped APDU: resplen %""SC_FORMAT_LEN_SIZE_T""u, SW %02X%02X"",
 	       plain->resplen, plain->sw1, plain->sw2);
 	LOG_FUNC_RETURN(card->ctx, SC_SUCCESS);
 }",[13],A double free when handling responses from an HSM Card in sc_pkcs15emu_sc_hsm_init in libopensc/pkcs15-sc-hsm.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.,OpenSC,CVE-2018-16425,CWE-415
596,181668," static int http_buf_read(URLContext *h, uint8_t *buf, int size)
 {
     HTTPContext *s = h->priv_data;
     int len;
     len = s->buf_end - s->buf_ptr;
     if (len > 0) {
         if (len > size)
             len = size;
          memcpy(buf, s->buf_ptr, len);
          s->buf_ptr += len;
      } else {
        int64_t target_end = s->end_off ? s->end_off : s->filesize;
        if ((!s->willclose || s->chunksize < 0) &&
            target_end >= 0 && s->off >= target_end)
         uint64_t target_end = s->end_off ? s->end_off : s->filesize;
         if ((!s->willclose || s->chunksize == UINT64_MAX) && s->off >= target_end)
              return AVERROR_EOF;
          len = ffurl_read(s->hd, buf, size);
        if (!len && (!s->willclose || s->chunksize < 0) &&
            target_end >= 0 && s->off < target_end) {
         if (!len && (!s->willclose || s->chunksize == UINT64_MAX) && s->off < target_end) {
              av_log(h, AV_LOG_ERROR,
                   ""Stream ends prematurely at %""PRId64"", should be %""PRId64""\n"",
                    ""Stream ends prematurely at %""PRIu64"", should be %""PRIu64""\n"",
                     s->off, target_end
                    );
              return AVERROR(EIO);
         }
     }
     if (len > 0) {
         s->off += len;
         if (s->chunksize > 0)
             s->chunksize -= len;
     }
     return len;
 }","[12, 13, 14, 15, 16, 19, 20, 21, 23, 24]","Heap-based buffer overflow in libavformat/http.c in FFmpeg before 2.8.10, 3.0.x before 3.0.5, 3.1.x before 3.1.6, and 3.2.x before 3.2.2 allows remote web servers to execute arbitrary code via a negative chunk size in an HTTP response.",FFmpeg,CVE-2016-10190,CWE-119
607,182241," static int enum_dir(sc_path_t path, int depth)
  {
  	sc_file_t *file;
  	int r, file_type;
	u8 files[SC_MAX_APDU_BUFFER_SIZE];
 	u8 files[SC_MAX_EXT_APDU_BUFFER_SIZE];
  	r = sc_lock(card);
  	if (r == SC_SUCCESS)
 		r = sc_select_file(card, &path, &file);
 	sc_unlock(card);
 	if (r) {
 		fprintf(stderr, ""SELECT FILE failed: %s\n"", sc_strerror(r));
 		return 1;
 	}
 	print_file(card, file, &path, depth);
 	file_type = file->type;
 	sc_file_free(file);
 	if (file_type == SC_FILE_TYPE_DF) {
 		int i;
 		r = sc_lock(card);
 		if (r == SC_SUCCESS)
 			r = sc_list_files(card, files, sizeof(files));
 		sc_unlock(card);
 		if (r < 0) {
 			fprintf(stderr, ""sc_list_files() failed: %s\n"", sc_strerror(r));
 			return 1;
  		}
  		if (r == 0) {
  			printf(""Empty directory\n"");
		} else
		for (i = 0; i < r/2; i++) {
			sc_path_t tmppath;
			memset(&tmppath, 0, sizeof(tmppath));
			memcpy(&tmppath, &path, sizeof(path));
			memcpy(tmppath.value + tmppath.len, files + 2*i, 2);
			tmppath.len += 2;
			enum_dir(tmppath, depth + 1);
 		} else {
 			for (i = 0; i < r/2; i++) {
 				sc_path_t tmppath;
 				memset(&tmppath, 0, sizeof(tmppath));
 				memcpy(&tmppath, &path, sizeof(path));
 				memcpy(tmppath.value + tmppath.len, files + 2*i, 2);
 				tmppath.len += 2;
 				enum_dir(tmppath, depth + 1);
 			}
  		}
  	}
  	return 0;
 }","[5, 6, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46]",Various out of bounds reads when handling responses in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to potentially crash the opensc library using programs.,OpenSC,CVE-2018-16427,CWE-125
616,181898,"  static int pgx_gethdr(jas_stream_t *in, pgx_hdr_t *hdr)
  {
  	int c;
	uchar buf[2];
 	jas_uchar buf[2];
  	if ((c = jas_stream_getc(in)) == EOF) {
  		goto error;
 	}
 	buf[0] = c;
 	if ((c = jas_stream_getc(in)) == EOF) {
 		goto error;
 	}
 	buf[1] = c;
 	hdr->magic = buf[0] << 8 | buf[1];
 	if (hdr->magic != PGX_MAGIC) {
 		jas_eprintf(""invalid PGX signature\n"");
 		goto error;
 	}
 	if ((c = pgx_getc(in)) == EOF || !isspace(c)) {
 		goto error;
 	}
 	if (pgx_getbyteorder(in, &hdr->bigendian)) {
 		jas_eprintf(""cannot get byte order\n"");
 		goto error;
 	}
 	if (pgx_getsgnd(in, &hdr->sgnd)) {
 		jas_eprintf(""cannot get signedness\n"");
 		goto error;
 	}
 	if (pgx_getuint32(in, &hdr->prec)) {
 		jas_eprintf(""cannot get precision\n"");
 		goto error;
 	}
 	if (pgx_getuint32(in, &hdr->width)) {
 		jas_eprintf(""cannot get width\n"");
 		goto error;
 	}
 	if (pgx_getuint32(in, &hdr->height)) {
 		jas_eprintf(""cannot get height\n"");
 		goto error;
 	}
 	return 0;
 error:
 	return -1;
 }","[4, 5]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
627,182248," sc_pkcs15emu_esteid_init (sc_pkcs15_card_t * p15card)
 {
 	sc_card_t *card = p15card->card;
 	unsigned char buff[128];
 	int r, i;
 	size_t field_length = 0, modulus_length = 0;
 	sc_path_t tmppath;
 	set_string (&p15card->tokeninfo->label, ""ID-kaart"");
 	set_string (&p15card->tokeninfo->manufacturer_id, ""AS Sertifitseerimiskeskus"");
 	sc_format_path (""3f00eeee5044"", &tmppath);
 	r = sc_select_file (card, &tmppath, NULL);
 	SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, ""select esteid PD failed"");
  	r = sc_read_record (card, SC_ESTEID_PD_DOCUMENT_NR, buff, sizeof(buff), SC_RECORD_BY_REC_NR);
  	SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, ""read document number failed"");
	buff[r] = '\0';
 	buff[MIN((size_t) r, (sizeof buff)-1)] = '\0';
  	set_string (&p15card->tokeninfo->serial_number, (const char *) buff);
  	p15card->tokeninfo->flags = SC_PKCS15_TOKEN_PRN_GENERATION
 				  | SC_PKCS15_TOKEN_EID_COMPLIANT
 				  | SC_PKCS15_TOKEN_READONLY;
 	for (i = 0; i < 2; i++) {
 		static const char *esteid_cert_names[2] = {
 			""Isikutuvastus"",
 			""Allkirjastamine""};
 		static char const *esteid_cert_paths[2] = {
 			""3f00eeeeaace"",
 			""3f00eeeeddce""};
 		static int esteid_cert_ids[2] = {1, 2};
 		struct sc_pkcs15_cert_info cert_info;
 		struct sc_pkcs15_object cert_obj;
 		memset(&cert_info, 0, sizeof(cert_info));
 		memset(&cert_obj, 0, sizeof(cert_obj));
 		cert_info.id.value[0] = esteid_cert_ids[i];
 		cert_info.id.len = 1;
 		sc_format_path(esteid_cert_paths[i], &cert_info.path);
 		strlcpy(cert_obj.label, esteid_cert_names[i], sizeof(cert_obj.label));
 		r = sc_pkcs15emu_add_x509_cert(p15card, &cert_obj, &cert_info);
 		if (r < 0)
 			return SC_ERROR_INTERNAL;
 		if (i == 0) {
 			sc_pkcs15_cert_t *cert = NULL;
 			r = sc_pkcs15_read_certificate(p15card, &cert_info, &cert);
 			if (r < 0)
 				return SC_ERROR_INTERNAL;
 			if (cert->key->algorithm == SC_ALGORITHM_EC)
 				field_length = cert->key->u.ec.params.field_length;
 			else
 				modulus_length = cert->key->u.rsa.modulus.len * 8;
 			if (r == SC_SUCCESS) {
 				static const struct sc_object_id cn_oid = {{ 2, 5, 4, 3, -1 }};
 				u8 *cn_name = NULL;
 				size_t cn_len = 0;
 				sc_pkcs15_get_name_from_dn(card->ctx, cert->subject,
 					cert->subject_len, &cn_oid, &cn_name, &cn_len);
 				if (cn_len > 0) {
 					char *token_name = malloc(cn_len+1);
 					if (token_name) {
 						memcpy(token_name, cn_name, cn_len);
 						token_name[cn_len] = '\0';
 						set_string(&p15card->tokeninfo->label, (const char*)token_name);
 						free(token_name);
 					}
 				}
 				free(cn_name);
 				sc_pkcs15_free_certificate(cert);
 			}
 		}
 	}
 	sc_format_path (""3f000016"", &tmppath);
 	r = sc_select_file (card, &tmppath, NULL);
 	if (r < 0)
 		return SC_ERROR_INTERNAL;
 	for (i = 0; i < 3; i++) {
 		unsigned char tries_left;
 		static const char *esteid_pin_names[3] = {
 			""PIN1"",
 			""PIN2"",
 			""PUK"" };
 		static const int esteid_pin_min[3] = {4, 5, 8};
 		static const int esteid_pin_ref[3] = {1, 2, 0};
 		static const int esteid_pin_authid[3] = {1, 2, 3};
 		static const int esteid_pin_flags[3] = {0, 0, SC_PKCS15_PIN_FLAG_UNBLOCKING_PIN};
 		struct sc_pkcs15_auth_info pin_info;
 		struct sc_pkcs15_object pin_obj;
 		memset(&pin_info, 0, sizeof(pin_info));
 		memset(&pin_obj, 0, sizeof(pin_obj));
 		r = sc_read_record (card, i + 1, buff, sizeof(buff), SC_RECORD_BY_REC_NR);
 		if (r < 0)
 			return SC_ERROR_INTERNAL;
 		tries_left = buff[5];
 		pin_info.auth_id.len = 1;
 		pin_info.auth_id.value[0] = esteid_pin_authid[i];
 		pin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;
 		pin_info.attrs.pin.reference = esteid_pin_ref[i];
 		pin_info.attrs.pin.flags = esteid_pin_flags[i];
 		pin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;
 		pin_info.attrs.pin.min_length = esteid_pin_min[i];
 		pin_info.attrs.pin.stored_length = 12;
 		pin_info.attrs.pin.max_length = 12;
 		pin_info.attrs.pin.pad_char = '\0';
 		pin_info.tries_left = (int)tries_left;
 		pin_info.max_tries = 3;
 		strlcpy(pin_obj.label, esteid_pin_names[i], sizeof(pin_obj.label));
 		pin_obj.flags = esteid_pin_flags[i];
 		if (i < 2) {
 			pin_obj.auth_id.len = 1;
 			pin_obj.auth_id.value[0] = 3;
 		}
 		r = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);
 		if (r < 0)
 			return SC_ERROR_INTERNAL;
 	}
 	for (i = 0; i < 2; i++) {
 		static int prkey_pin[2] = {1, 2};
 		static const char *prkey_name[2] = {
 			""Isikutuvastus"",
 			""Allkirjastamine""};
 		struct sc_pkcs15_prkey_info prkey_info;
 		struct sc_pkcs15_object prkey_obj;
 		memset(&prkey_info, 0, sizeof(prkey_info));
 		memset(&prkey_obj, 0, sizeof(prkey_obj));
 		prkey_info.id.len = 1;
 		prkey_info.id.value[0] = prkey_pin[i];
 		prkey_info.native = 1;
 		prkey_info.key_reference = i + 1;
 		prkey_info.field_length = field_length;
 		prkey_info.modulus_length = modulus_length;
 		if (i == 1)
 			prkey_info.usage = SC_PKCS15_PRKEY_USAGE_NONREPUDIATION;
 		else if(field_length > 0)  
 			prkey_info.usage = SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_DERIVE;
 		else
 			prkey_info.usage = SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_ENCRYPT | SC_PKCS15_PRKEY_USAGE_DECRYPT;
 		strlcpy(prkey_obj.label, prkey_name[i], sizeof(prkey_obj.label));
 		prkey_obj.auth_id.len = 1;
 		prkey_obj.auth_id.value[0] = prkey_pin[i];
 		prkey_obj.user_consent = 0;
 		prkey_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE;
 		if(field_length > 0)
 			r = sc_pkcs15emu_add_ec_prkey(p15card, &prkey_obj, &prkey_info);
 		else
 			r = sc_pkcs15emu_add_rsa_prkey(p15card, &prkey_obj, &prkey_info);
 		if (r < 0)
 			return SC_ERROR_INTERNAL;
 	}
 	return SC_SUCCESS;
 }","[15, 16]",A double free when handling responses from an HSM Card in sc_pkcs15emu_sc_hsm_init in libopensc/pkcs15-sc-hsm.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.,OpenSC,CVE-2018-16425,CWE-415
637,177935," SProcXSendExtensionEvent(ClientPtr client)
  {
      CARD32 *p;
      int i;
    xEvent eventT;
     xEvent eventT = { .u.u.type = 0 };
      xEvent *eventP;
      EventSwapPtr proc;
     REQUEST(xSendExtensionEventReq);
     swaps(&stuff->length);
     REQUEST_AT_LEAST_SIZE(xSendExtensionEventReq);
     swapl(&stuff->destination);
     swaps(&stuff->count);
     if (stuff->length !=
         bytes_to_int32(sizeof(xSendExtensionEventReq)) + stuff->count +
         bytes_to_int32(stuff->num_events * sizeof(xEvent)))
         return BadLength;
     eventP = (xEvent *) &stuff[1];
     for (i = 0; i < stuff->num_events; i++, eventP++) {
         proc = EventSwapVector[eventP->u.u.type & 0177];
         if (proc == NotImplemented)      
             return BadValue;
         (*proc) (eventP, &eventT);
         *eventP = eventT;
     }
     p = (CARD32 *) (((xEvent *) &stuff[1]) + stuff->num_events);
     SwapLongs(p, stuff->count);
     return (ProcXSendExtensionEvent(client));
 }","[5, 6]",Uninitialized data in endianness conversion in the XEvent handling of the X.Org X Server before 2017-06-19 allowed authenticated malicious users to access potentially privileged data from the X server.,xserver,CVE-2017-10972,CWE-665
641,180308," cleanup_pathname(struct archive_write_disk *a)
 cleanup_pathname_fsobj(char *path, int *error_number, struct archive_string *error_string, int flags)
  {
  	char *dest, *src;
  	char separator = '\0';
	dest = src = a->name;
 	dest = src = path;
  	if (*src == '\0') {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty pathname"");
 		if (error_number) *error_number = ARCHIVE_ERRNO_MISC;
 		if (error_string)
 		    archive_string_sprintf(error_string,
 			    ""Invalid empty pathname"");
  		return (ARCHIVE_FAILED);
  	}
 #if defined(__CYGWIN__)
 	cleanup_pathname_win(a);
  #endif
  	if (*src == '/') {
		if (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			                  ""Path is absolute"");
 		if (flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
 			if (error_number) *error_number = ARCHIVE_ERRNO_MISC;
 			if (error_string)
 			    archive_string_sprintf(error_string,
 				    ""Path is absolute"");
  			return (ARCHIVE_FAILED);
  		}
 		separator = *src++;
 	}
 	for (;;) {
 		if (src[0] == '\0') {
 			break;
 		} else if (src[0] == '/') {
 			src++;
 			continue;
 		} else if (src[0] == '.') {
 			if (src[1] == '\0') {
 				break;
 			} else if (src[1] == '/') {
 				src += 2;
 				continue;
  			} else if (src[1] == '.') {
  				if (src[2] == '/' || src[2] == '\0') {
					if (a->flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {
						archive_set_error(&a->archive,
						    ARCHIVE_ERRNO_MISC,
						    ""Path contains '..'"");
 					if (flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {
 						if (error_number) *error_number = ARCHIVE_ERRNO_MISC;
 						if (error_string)
 						    archive_string_sprintf(error_string,
 							    ""Path contains '..'"");
  						return (ARCHIVE_FAILED);
  					}
  				}
 			}
 		}
 		if (separator)
 			*dest++ = '/';
 		while (*src != '\0' && *src != '/') {
 			*dest++ = *src++;
 		}
 		if (*src == '\0')
 			break;
 		separator = *src++;
 	}
	if (dest == a->name) {
 	if (dest == path) {
 		if (separator)
 			*dest++ = '/';
 		else
 			*dest++ = '.';
 	}
 	*dest = '\0';
  	return (ARCHIVE_OK);
  }","[2, 6, 7, 9, 10, 11, 12, 13, 14, 21, 22, 23, 24, 25, 26, 27, 28, 47, 48, 49, 50, 51, 52, 53, 54, 55, 70, 71]","The sandboxing code in libarchive 3.2.0 and earlier mishandles hardlink archive entries of non-zero data size, which might allow remote attackers to write to arbitrary files via a crafted archive file.",libarchive,CVE-2016-5418,CWE-20
644,181643," static int jpc_pi_nextcprl(register jpc_pi_t *pi)
 {
 	int rlvlno;
 	jpc_pirlvl_t *pirlvl;
 	jpc_pchg_t *pchg;
 	int prchind;
 	int prcvind;
 	int *prclyrno;
 	uint_fast32_t trx0;
 	uint_fast32_t try0;
 	uint_fast32_t r;
 	uint_fast32_t rpx;
 	uint_fast32_t rpy;
 	pchg = pi->pchg;
 	if (!pi->prgvolfirst) {
 		goto skip;
 	} else {
 		pi->prgvolfirst = 0;
 	}
 	for (pi->compno = pchg->compnostart, pi->picomp =
  	  &pi->picomps[pi->compno]; pi->compno < JAS_CAST(int, pchg->compnoend) && pi->compno < pi->numcomps; ++pi->compno,
  	  ++pi->picomp) {
  		pirlvl = pi->picomp->pirlvls;
		pi->xstep = pi->picomp->hsamp * (1 << (pirlvl->prcwidthexpn +
		  pi->picomp->numrlvls - 1));
		pi->ystep = pi->picomp->vsamp * (1 << (pirlvl->prcheightexpn +
		  pi->picomp->numrlvls - 1));
 		pi->xstep = pi->picomp->hsamp * (JAS_CAST(uint_fast32_t, 1) <<
 		  (pirlvl->prcwidthexpn + pi->picomp->numrlvls - 1));
 		pi->ystep = pi->picomp->vsamp * (JAS_CAST(uint_fast32_t, 1) <<
 		  (pirlvl->prcheightexpn + pi->picomp->numrlvls - 1));
  		for (rlvlno = 1, pirlvl = &pi->picomp->pirlvls[1];
  		  rlvlno < pi->picomp->numrlvls; ++rlvlno, ++pirlvl) {
			pi->xstep = JAS_MIN(pi->xstep, pi->picomp->hsamp * (1 <<
			  (pirlvl->prcwidthexpn + pi->picomp->numrlvls -
			  rlvlno - 1)));
			pi->ystep = JAS_MIN(pi->ystep, pi->picomp->vsamp * (1 <<
			  (pirlvl->prcheightexpn + pi->picomp->numrlvls -
			  rlvlno - 1)));
 			pi->xstep = JAS_MIN(pi->xstep, pi->picomp->hsamp *
 			  (JAS_CAST(uint_fast32_t, 1) << (pirlvl->prcwidthexpn +
 			  pi->picomp->numrlvls - rlvlno - 1)));
 			pi->ystep = JAS_MIN(pi->ystep, pi->picomp->vsamp *
 			  (JAS_CAST(uint_fast32_t, 1) << (pirlvl->prcheightexpn +
 			  pi->picomp->numrlvls - rlvlno - 1)));
  		}
  		for (pi->y = pi->ystart; pi->y < pi->yend;
  		  pi->y += pi->ystep - (pi->y % pi->ystep)) {
 			for (pi->x = pi->xstart; pi->x < pi->xend;
 			  pi->x += pi->xstep - (pi->x % pi->xstep)) {
 				for (pi->rlvlno = pchg->rlvlnostart,
 				  pi->pirlvl = &pi->picomp->pirlvls[pi->rlvlno];
 				  pi->rlvlno < pi->picomp->numrlvls && pi->rlvlno <
 				  pchg->rlvlnoend; ++pi->rlvlno, ++pi->pirlvl) {
 					if (pi->pirlvl->numprcs == 0) {
 						continue;
 					}
 					r = pi->picomp->numrlvls - 1 - pi->rlvlno;
 					trx0 = JPC_CEILDIV(pi->xstart, pi->picomp->hsamp << r);
 					try0 = JPC_CEILDIV(pi->ystart, pi->picomp->vsamp << r);
 					rpx = r + pi->pirlvl->prcwidthexpn;
 					rpy = r + pi->pirlvl->prcheightexpn;
 					if (((pi->x == pi->xstart && ((trx0 << r) % (1 << rpx))) ||
 					  !(pi->x % (pi->picomp->hsamp << rpx))) &&
 					  ((pi->y == pi->ystart && ((try0 << r) % (1 << rpy))) ||
 					  !(pi->y % (pi->picomp->vsamp << rpy)))) {
 						prchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x, pi->picomp->hsamp
 						  << r), pi->pirlvl->prcwidthexpn) - JPC_FLOORDIVPOW2(trx0,
 						  pi->pirlvl->prcwidthexpn);
 						prcvind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->y, pi->picomp->vsamp
 						  << r), pi->pirlvl->prcheightexpn) - JPC_FLOORDIVPOW2(try0,
 						  pi->pirlvl->prcheightexpn);
 						pi->prcno = prcvind *
 						  pi->pirlvl->numhprcs +
 						  prchind;
 						assert(pi->prcno <
 						  pi->pirlvl->numprcs);
 						for (pi->lyrno = 0; pi->lyrno <
 						  pi->numlyrs && pi->lyrno < JAS_CAST(int, pchg->lyrnoend); ++pi->lyrno) {
 							prclyrno = &pi->pirlvl->prclyrnos[pi->prcno];
 							if (pi->lyrno >= *prclyrno) {
 								++(*prclyrno);
 								return 0;
 							}
 skip:
 							;
 						}
 					}
 				}
 			}
 		}
 	}
 	return 1;
 }","[24, 25, 26, 27, 28, 29, 30, 31, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45]","Integer overflow in the jpc_pi_nextcprl function in jpc_t2cod.c in JasPer before 1.900.20 allows remote attackers to have unspecified impact via a crafted file, which triggers use of an uninitialized value.",jasper,CVE-2016-10251,CWE-190
645,180926," read_header(struct archive_read *a, struct archive_entry *entry,
             char head_type)
 {
   const void *h;
   const char *p, *endp;
   struct rar *rar;
   struct rar_header rar_header;
   struct rar_file_header file_header;
   int64_t header_size;
   unsigned filename_size, end;
   char *filename;
   char *strp;
   char packed_size[8];
   char unp_size[8];
   int ttime;
   struct archive_string_conv *sconv, *fn_sconv;
   unsigned long crc32_val;
   int ret = (ARCHIVE_OK), ret2;
   rar = (struct rar *)(a->format->data);
   sconv = rar->opt_sconv;
   if (sconv == NULL) {
     if (!rar->init_default_conversion) {
       rar->sconv_default =
           archive_string_default_conversion_for_read(
             &(a->archive));
       rar->init_default_conversion = 1;
     }
     sconv = rar->sconv_default;
   }
   if ((h = __archive_read_ahead(a, 7, NULL)) == NULL)
     return (ARCHIVE_FATAL);
   p = h;
   memcpy(&rar_header, p, sizeof(rar_header));
   rar->file_flags = archive_le16dec(rar_header.flags);
   header_size = archive_le16dec(rar_header.size);
   if (header_size < (int64_t)sizeof(file_header) + 7) {
     archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
       ""Invalid header size"");
     return (ARCHIVE_FATAL);
   }
   crc32_val = crc32(0, (const unsigned char *)p + 2, 7 - 2);
   __archive_read_consume(a, 7);
   if (!(rar->file_flags & FHD_SOLID))
   {
     rar->compression_method = 0;
     rar->packed_size = 0;
     rar->unp_size = 0;
     rar->mtime = 0;
     rar->ctime = 0;
     rar->atime = 0;
     rar->arctime = 0;
     rar->mode = 0;
     memset(&rar->salt, 0, sizeof(rar->salt));
     rar->atime = 0;
     rar->ansec = 0;
     rar->ctime = 0;
     rar->cnsec = 0;
     rar->mtime = 0;
     rar->mnsec = 0;
     rar->arctime = 0;
     rar->arcnsec = 0;
   }
   else
   {
     archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                       ""RAR solid archive support unavailable."");
     return (ARCHIVE_FATAL);
   }
   if ((h = __archive_read_ahead(a, (size_t)header_size - 7, NULL)) == NULL)
     return (ARCHIVE_FATAL);
   crc32_val = crc32(crc32_val, h, (unsigned)(header_size - 7));
   if ((crc32_val & 0xffff) != archive_le16dec(rar_header.crc)) {
     archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
       ""Header CRC error"");
     return (ARCHIVE_FATAL);
   }
   p = h;
   endp = p + header_size - 7;
   memcpy(&file_header, p, sizeof(file_header));
   p += sizeof(file_header);
   rar->compression_method = file_header.method;
   ttime = archive_le32dec(file_header.file_time);
   rar->mtime = get_time(ttime);
   rar->file_crc = archive_le32dec(file_header.file_crc);
   if (rar->file_flags & FHD_PASSWORD)
   {
 	archive_entry_set_is_data_encrypted(entry, 1);
 	rar->has_encrypted_entries = 1;
     archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                       ""RAR encryption support unavailable."");
   }
   if (rar->file_flags & FHD_LARGE)
   {
     memcpy(packed_size, file_header.pack_size, 4);
     memcpy(packed_size + 4, p, 4);  
     p += 4;
     memcpy(unp_size, file_header.unp_size, 4);
     memcpy(unp_size + 4, p, 4);  
     p += 4;
     rar->packed_size = archive_le64dec(&packed_size);
     rar->unp_size = archive_le64dec(&unp_size);
   }
   else
   {
     rar->packed_size = archive_le32dec(file_header.pack_size);
     rar->unp_size = archive_le32dec(file_header.unp_size);
   }
   if (rar->packed_size < 0 || rar->unp_size < 0)
   {
     archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                       ""Invalid sizes specified."");
     return (ARCHIVE_FATAL);
   }
   rar->bytes_remaining = rar->packed_size;
   if (head_type == NEWSUB_HEAD) {
     size_t distance = p - (const char *)h;
     header_size += rar->packed_size;
     if ((h = __archive_read_ahead(a, (size_t)header_size - 7, NULL)) == NULL)
         return (ARCHIVE_FATAL);
     p = h;
     endp = p + header_size - 7;
     p += distance;
   }
   filename_size = archive_le16dec(file_header.name_size);
   if (p + filename_size > endp) {
     archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
       ""Invalid filename size"");
     return (ARCHIVE_FATAL);
   }
   if (rar->filename_allocated < filename_size * 2 + 2) {
     char *newptr;
     size_t newsize = filename_size * 2 + 2;
     newptr = realloc(rar->filename, newsize);
     if (newptr == NULL) {
       archive_set_error(&a->archive, ENOMEM,
                         ""Couldn't allocate memory."");
       return (ARCHIVE_FATAL);
     }
     rar->filename = newptr;
     rar->filename_allocated = newsize;
   }
   filename = rar->filename;
   memcpy(filename, p, filename_size);
   filename[filename_size] = '\0';
   if (rar->file_flags & FHD_UNICODE)
   {
     if (filename_size != strlen(filename))
     {
       unsigned char highbyte, flagbits, flagbyte;
       unsigned fn_end, offset;
       end = filename_size;
       fn_end = filename_size * 2;
       filename_size = 0;
       offset = (unsigned)strlen(filename) + 1;
       highbyte = *(p + offset++);
       flagbits = 0;
       flagbyte = 0;
       while (offset < end && filename_size < fn_end)
       {
         if (!flagbits)
         {
           flagbyte = *(p + offset++);
           flagbits = 8;
         }
         flagbits -= 2;
         switch((flagbyte >> flagbits) & 3)
         {
           case 0:
             filename[filename_size++] = '\0';
             filename[filename_size++] = *(p + offset++);
             break;
           case 1:
             filename[filename_size++] = highbyte;
             filename[filename_size++] = *(p + offset++);
             break;
           case 2:
             filename[filename_size++] = *(p + offset + 1);
             filename[filename_size++] = *(p + offset);
             offset += 2;
             break;
           case 3:
           {
             char extra, high;
             uint8_t length = *(p + offset++);
             if (length & 0x80) {
               extra = *(p + offset++);
               high = (char)highbyte;
             } else
               extra = high = 0;
             length = (length & 0x7f) + 2;
             while (length && filename_size < fn_end) {
               unsigned cp = filename_size >> 1;
               filename[filename_size++] = high;
               filename[filename_size++] = p[cp] + extra;
               length--;
             }
           }
           break;
         }
       }
       if (filename_size > fn_end) {
         archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
           ""Invalid filename"");
          return (ARCHIVE_FATAL);
        }
        filename[filename_size++] = '\0';
      filename[filename_size++] = '\0';
       filename[filename_size] = '\0';
       if (rar->sconv_utf16be == NULL) {
         rar->sconv_utf16be = archive_string_conversion_from_charset(
            &a->archive, ""UTF-16BE"", 1);
         if (rar->sconv_utf16be == NULL)
           return (ARCHIVE_FATAL);
       }
       fn_sconv = rar->sconv_utf16be;
       strp = filename;
       while (memcmp(strp, ""\x00\x00"", 2))
       {
         if (!memcmp(strp, ""\x00\\"", 2))
           *(strp + 1) = '/';
         strp += 2;
       }
       p += offset;
     } else {
       if (rar->sconv_utf8 == NULL) {
         rar->sconv_utf8 = archive_string_conversion_from_charset(
            &a->archive, ""UTF-8"", 1);
         if (rar->sconv_utf8 == NULL)
           return (ARCHIVE_FATAL);
       }
       fn_sconv = rar->sconv_utf8;
       while ((strp = strchr(filename, '\\')) != NULL)
         *strp = '/';
       p += filename_size;
     }
   }
   else
   {
     fn_sconv = sconv;
     while ((strp = strchr(filename, '\\')) != NULL)
       *strp = '/';
     p += filename_size;
   }
   if (rar->filename_save &&
     filename_size == rar->filename_save_size &&
     !memcmp(rar->filename, rar->filename_save, filename_size + 1))
   {
     __archive_read_consume(a, header_size - 7);
     rar->cursor++;
     if (rar->cursor >= rar->nodes)
     {
       rar->nodes++;
       if ((rar->dbo =
         realloc(rar->dbo, sizeof(*rar->dbo) * rar->nodes)) == NULL)
       {
         archive_set_error(&a->archive, ENOMEM, ""Couldn't allocate memory."");
         return (ARCHIVE_FATAL);
       }
       rar->dbo[rar->cursor].header_size = header_size;
       rar->dbo[rar->cursor].start_offset = -1;
       rar->dbo[rar->cursor].end_offset = -1;
     }
     if (rar->dbo[rar->cursor].start_offset < 0)
     {
       rar->dbo[rar->cursor].start_offset = a->filter->position;
       rar->dbo[rar->cursor].end_offset = rar->dbo[rar->cursor].start_offset +
         rar->packed_size;
     }
     return ret;
   }
   rar->filename_save = (char*)realloc(rar->filename_save,
                                       filename_size + 1);
   memcpy(rar->filename_save, rar->filename, filename_size + 1);
   rar->filename_save_size = filename_size;
   free(rar->dbo);
   if ((rar->dbo = calloc(1, sizeof(*rar->dbo))) == NULL)
   {
     archive_set_error(&a->archive, ENOMEM, ""Couldn't allocate memory."");
     return (ARCHIVE_FATAL);
   }
   rar->dbo[0].header_size = header_size;
   rar->dbo[0].start_offset = -1;
   rar->dbo[0].end_offset = -1;
   rar->cursor = 0;
   rar->nodes = 1;
   if (rar->file_flags & FHD_SALT)
   {
     if (p + 8 > endp) {
       archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
         ""Invalid header size"");
       return (ARCHIVE_FATAL);
     }
     memcpy(rar->salt, p, 8);
     p += 8;
   }
   if (rar->file_flags & FHD_EXTTIME) {
     if (read_exttime(p, rar, endp) < 0) {
       archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
         ""Invalid header size"");
       return (ARCHIVE_FATAL);
     }
   }
   __archive_read_consume(a, header_size - 7);
   rar->dbo[0].start_offset = a->filter->position;
   rar->dbo[0].end_offset = rar->dbo[0].start_offset + rar->packed_size;
   switch(file_header.host_os)
   {
   case OS_MSDOS:
   case OS_OS2:
   case OS_WIN32:
     rar->mode = archive_le32dec(file_header.file_attr);
     if (rar->mode & FILE_ATTRIBUTE_DIRECTORY)
       rar->mode = AE_IFDIR | S_IXUSR | S_IXGRP | S_IXOTH;
     else
       rar->mode = AE_IFREG;
     rar->mode |= S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
     break;
   case OS_UNIX:
   case OS_MAC_OS:
   case OS_BEOS:
     rar->mode = archive_le32dec(file_header.file_attr);
     break;
   default:
     archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                       ""Unknown file attributes from RAR file's host OS"");
     return (ARCHIVE_FATAL);
   }
   rar->bytes_uncopied = rar->bytes_unconsumed = 0;
   rar->lzss.position = rar->offset = 0;
   rar->offset_seek = 0;
   rar->dictionary_size = 0;
   rar->offset_outgoing = 0;
   rar->br.cache_avail = 0;
   rar->br.avail_in = 0;
   rar->crc_calculated = 0;
   rar->entry_eof = 0;
   rar->valid = 1;
   rar->is_ppmd_block = 0;
   rar->start_new_table = 1;
   free(rar->unp_buffer);
   rar->unp_buffer = NULL;
   rar->unp_offset = 0;
   rar->unp_buffer_size = UNP_BUFFER_SIZE;
   memset(rar->lengthtable, 0, sizeof(rar->lengthtable));
   __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context, &g_szalloc);
   rar->ppmd_valid = rar->ppmd_eod = 0;
   if (head_type == NEWSUB_HEAD)
     return ret;
   archive_entry_set_mtime(entry, rar->mtime, rar->mnsec);
   archive_entry_set_ctime(entry, rar->ctime, rar->cnsec);
   archive_entry_set_atime(entry, rar->atime, rar->ansec);
   archive_entry_set_size(entry, rar->unp_size);
   archive_entry_set_mode(entry, rar->mode);
   if (archive_entry_copy_pathname_l(entry, filename, filename_size, fn_sconv))
   {
     if (errno == ENOMEM)
     {
       archive_set_error(&a->archive, ENOMEM,
                         ""Can't allocate memory for Pathname"");
       return (ARCHIVE_FATAL);
     }
     archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                       ""Pathname cannot be converted from %s to current locale."",
                       archive_string_conversion_charset_name(fn_sconv));
     ret = (ARCHIVE_WARN);
   }
   if (((rar->mode) & AE_IFMT) == AE_IFLNK)
   {
     rar->bytes_remaining = 0;
     archive_entry_set_size(entry, 0);
     if ((ret2 = read_symlink_stored(a, entry, sconv)) < (ARCHIVE_WARN))
       return ret2;
     if (ret > ret2)
       ret = ret2;
   }
   if (rar->bytes_remaining == 0)
     rar->entry_eof = 1;
   return ret;
 }","[207, 208]","read_header in archive_read_support_format_rar.c in libarchive 3.3.2 suffers from an off-by-one error for UTF-16 names in RAR archives, leading to an out-of-bounds read in archive_read_format_rar_read_header.",libarchive,CVE-2017-14502,CWE-125
667,179591," varbit_in(PG_FUNCTION_ARGS)
 {
 	char	   *input_string = PG_GETARG_CSTRING(0);
 #ifdef NOT_USED
 	Oid			typelem = PG_GETARG_OID(1);
 #endif
 	int32		atttypmod = PG_GETARG_INT32(2);
 	VarBit	   *result;			 
 	char	   *sp;				 
 	bits8	   *r;				 
 	int			len,			 
 				bitlen,			 
 				slen;			 
 	bool		bit_not_hex;	 
 	int			bc;
 	bits8		x = 0;
 	if (input_string[0] == 'b' || input_string[0] == 'B')
 	{
 		bit_not_hex = true;
 		sp = input_string + 1;
 	}
 	else if (input_string[0] == 'x' || input_string[0] == 'X')
 	{
 		bit_not_hex = false;
 		sp = input_string + 1;
 	}
 	else
 	{
 		bit_not_hex = true;
  		sp = input_string;
  	}
 	slen = strlen(sp);
  	slen = strlen(sp);
  	if (bit_not_hex)
  		bitlen = slen;
  	else
 	{
 		if (slen > VARBITMAXLEN / 4)
 			ereport(ERROR,
 					(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),
 				 errmsg(""bit string length exceeds the maximum allowed (%d)"",
 						VARBITMAXLEN)));
  		bitlen = slen * 4;
 	}
 	if (atttypmod <= 0)
 		atttypmod = bitlen;
 	else if (bitlen > atttypmod)
 		ereport(ERROR,
 				(errcode(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),
 				 errmsg(""bit string too long for type bit varying(%d)"",
 						atttypmod)));
 	len = VARBITTOTALLEN(bitlen);
 	result = (VarBit *) palloc0(len);
 	SET_VARSIZE(result, len);
 	VARBITLEN(result) = Min(bitlen, atttypmod);
 	r = VARBITS(result);
 	if (bit_not_hex)
 	{
 		x = HIGHBIT;
 		for (; *sp; sp++)
 		{
 			if (*sp == '1')
 				*r |= x;
 			else if (*sp != '0')
 				ereport(ERROR,
 						(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),
 						 errmsg(""\""%c\"" is not a valid binary digit"",
 								*sp)));
 			x >>= 1;
 			if (x == 0)
 			{
 				x = HIGHBIT;
 				r++;
 			}
 		}
 	}
 	else
 	{
 		for (bc = 0; *sp; sp++)
 		{
 			if (*sp >= '0' && *sp <= '9')
 				x = (bits8) (*sp - '0');
 			else if (*sp >= 'A' && *sp <= 'F')
 				x = (bits8) (*sp - 'A') + 10;
 			else if (*sp >= 'a' && *sp <= 'f')
 				x = (bits8) (*sp - 'a') + 10;
 			else
 				ereport(ERROR,
 						(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),
 						 errmsg(""\""%c\"" is not a valid hexadecimal digit"",
 								*sp)));
 			if (bc)
 			{
 				*r++ |= x;
 				bc = 0;
 			}
 			else
 			{
 				*r = x << 4;
 				bc = 1;
 			}
 		}
 	}
 	PG_RETURN_VARBIT_P(result);
 }","[32, 33, 37, 38, 39, 40, 41, 42, 44]","Multiple integer overflows in contrib/hstore/hstore_io.c in PostgreSQL 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact via vectors related to the (1) hstore_recv, (2) hstore_from_arrays, and (3) hstore_from_array functions in contrib/hstore/hstore_io.c; and the (4) hstoreArrayToPairs function in contrib/hstore/hstore_op.c, which triggers a buffer overflow.  NOTE: this issue was SPLIT from CVE-2014-0064 because it has a different set of affected versions.",postgres,CVE-2014-2669,CWE-189
678,178613,"  SProcXFixesSelectCursorInput(ClientPtr client)
  {
      REQUEST(xXFixesSelectCursorInputReq);
     REQUEST_SIZE_MATCH(xXFixesSelectCursorInputReq);
      swaps(&stuff->length);
      swapl(&stuff->window);
     return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
 }",[4],xorg-x11-server before 1.19.5 was missing length validation in XFIXES extension allowing malicious X client to cause X server to crash or possibly execute arbitrary code.,xserver,CVE-2017-12183,CWE-20
679,179104," static int decode_slice_header(H264Context *h, H264Context *h0)
 {
     unsigned int first_mb_in_slice;
     unsigned int pps_id;
     int ret;
     unsigned int slice_type, tmp, i, j;
     int last_pic_structure, last_pic_droppable;
     int must_reinit;
     int needs_reinit = 0;
     int field_pic_flag, bottom_field_flag;
     h->me.qpel_put = h->h264qpel.put_h264_qpel_pixels_tab;
     h->me.qpel_avg = h->h264qpel.avg_h264_qpel_pixels_tab;
     first_mb_in_slice = get_ue_golomb_long(&h->gb);
     if (first_mb_in_slice == 0) {  
         if (h0->current_slice && FIELD_PICTURE(h)) {
             field_end(h, 1);
         }
         h0->current_slice = 0;
         if (!h0->first_field) {
             if (h->cur_pic_ptr && !h->droppable) {
                 ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,
                                           h->picture_structure == PICT_BOTTOM_FIELD);
             }
             h->cur_pic_ptr = NULL;
         }
     }
     slice_type = get_ue_golomb_31(&h->gb);
     if (slice_type > 9) {
         av_log(h->avctx, AV_LOG_ERROR,
                ""slice type too large (%d) at %d %d\n"",
                slice_type, h->mb_x, h->mb_y);
         return AVERROR_INVALIDDATA;
     }
     if (slice_type > 4) {
         slice_type -= 5;
         h->slice_type_fixed = 1;
     } else
         h->slice_type_fixed = 0;
     slice_type = golomb_to_pict_type[slice_type];
     h->slice_type     = slice_type;
     h->slice_type_nos = slice_type & 3;
     h->pict_type = h->slice_type;
     pps_id = get_ue_golomb(&h->gb);
     if (pps_id >= MAX_PPS_COUNT) {
         av_log(h->avctx, AV_LOG_ERROR, ""pps_id %d out of range\n"", pps_id);
         return AVERROR_INVALIDDATA;
     }
     if (!h0->pps_buffers[pps_id]) {
         av_log(h->avctx, AV_LOG_ERROR,
                ""non-existing PPS %u referenced\n"",
                pps_id);
         return AVERROR_INVALIDDATA;
     }
     h->pps = *h0->pps_buffers[pps_id];
     if (!h0->sps_buffers[h->pps.sps_id]) {
         av_log(h->avctx, AV_LOG_ERROR,
                ""non-existing SPS %u referenced\n"",
                h->pps.sps_id);
         return AVERROR_INVALIDDATA;
     }
     if (h->pps.sps_id != h->current_sps_id ||
         h0->sps_buffers[h->pps.sps_id]->new) {
         h0->sps_buffers[h->pps.sps_id]->new = 0;
         h->current_sps_id = h->pps.sps_id;
         h->sps            = *h0->sps_buffers[h->pps.sps_id];
         if (h->mb_width  != h->sps.mb_width ||
             h->mb_height != h->sps.mb_height * (2 - h->sps.frame_mbs_only_flag) ||
             h->avctx->bits_per_raw_sample != h->sps.bit_depth_luma ||
             h->cur_chroma_format_idc != h->sps.chroma_format_idc
         )
             needs_reinit = 1;
         if (h->bit_depth_luma    != h->sps.bit_depth_luma ||
             h->chroma_format_idc != h->sps.chroma_format_idc) {
             h->bit_depth_luma    = h->sps.bit_depth_luma;
             h->chroma_format_idc = h->sps.chroma_format_idc;
             needs_reinit         = 1;
         }
         if ((ret = h264_set_parameter_from_sps(h)) < 0)
             return ret;
     }
     h->avctx->profile = ff_h264_get_profile(&h->sps);
     h->avctx->level   = h->sps.level_idc;
     h->avctx->refs    = h->sps.ref_frame_count;
     must_reinit = (h->context_initialized &&
                     (   16*h->sps.mb_width != h->avctx->coded_width
                      || 16*h->sps.mb_height * (2 - h->sps.frame_mbs_only_flag) != h->avctx->coded_height
                      || h->avctx->bits_per_raw_sample != h->sps.bit_depth_luma
                      || h->cur_chroma_format_idc != h->sps.chroma_format_idc
                      || av_cmp_q(h->sps.sar, h->avctx->sample_aspect_ratio)
                      || h->mb_width  != h->sps.mb_width
                      || h->mb_height != h->sps.mb_height * (2 - h->sps.frame_mbs_only_flag)
                     ));
     if (h0->avctx->pix_fmt != get_pixel_format(h0, 0))
         must_reinit = 1;
     h->mb_width  = h->sps.mb_width;
     h->mb_height = h->sps.mb_height * (2 - h->sps.frame_mbs_only_flag);
     h->mb_num    = h->mb_width * h->mb_height;
     h->mb_stride = h->mb_width + 1;
     h->b_stride = h->mb_width * 4;
     h->chroma_y_shift = h->sps.chroma_format_idc <= 1;  
     h->width  = 16 * h->mb_width;
     h->height = 16 * h->mb_height;
     ret = init_dimensions(h);
     if (ret < 0)
         return ret;
     if (h->sps.video_signal_type_present_flag) {
         h->avctx->color_range = h->sps.full_range>0 ? AVCOL_RANGE_JPEG
                                                     : AVCOL_RANGE_MPEG;
         if (h->sps.colour_description_present_flag) {
             if (h->avctx->colorspace != h->sps.colorspace)
                 needs_reinit = 1;
             h->avctx->color_primaries = h->sps.color_primaries;
             h->avctx->color_trc       = h->sps.color_trc;
             h->avctx->colorspace      = h->sps.colorspace;
         }
     }
     if (h->context_initialized &&
         (h->width  != h->avctx->coded_width   ||
          h->height != h->avctx->coded_height  ||
          must_reinit ||
          needs_reinit)) {
         if (h != h0) {
             av_log(h->avctx, AV_LOG_ERROR, ""changing width/height on ""
                    ""slice %d\n"", h0->current_slice + 1);
             return AVERROR_INVALIDDATA;
         }
         flush_change(h);
         if ((ret = get_pixel_format(h, 1)) < 0)
             return ret;
         h->avctx->pix_fmt = ret;
         av_log(h->avctx, AV_LOG_INFO, ""Reinit context to %dx%d, ""
                ""pix_fmt: %s\n"", h->width, h->height, av_get_pix_fmt_name(h->avctx->pix_fmt));
         if ((ret = h264_slice_header_init(h, 1)) < 0) {
             av_log(h->avctx, AV_LOG_ERROR,
                    ""h264_slice_header_init() failed\n"");
             return ret;
         }
     }
     if (!h->context_initialized) {
         if (h != h0) {
             av_log(h->avctx, AV_LOG_ERROR,
                    ""Cannot (re-)initialize context during parallel decoding.\n"");
             return AVERROR_PATCHWELCOME;
         }
         if ((ret = get_pixel_format(h, 1)) < 0)
             return ret;
         h->avctx->pix_fmt = ret;
         if ((ret = h264_slice_header_init(h, 0)) < 0) {
             av_log(h->avctx, AV_LOG_ERROR,
                    ""h264_slice_header_init() failed\n"");
             return ret;
         }
     }
     if (h == h0 && h->dequant_coeff_pps != pps_id) {
         h->dequant_coeff_pps = pps_id;
         init_dequant_tables(h);
     }
     h->frame_num = get_bits(&h->gb, h->sps.log2_max_frame_num);
     h->mb_mbaff        = 0;
     h->mb_aff_frame    = 0;
     last_pic_structure = h0->picture_structure;
     last_pic_droppable = h0->droppable;
     h->droppable       = h->nal_ref_idc == 0;
     if (h->sps.frame_mbs_only_flag) {
         h->picture_structure = PICT_FRAME;
     } else {
         if (!h->sps.direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B) {
             av_log(h->avctx, AV_LOG_ERROR, ""This stream was generated by a broken encoder, invalid 8x8 inference\n"");
             return -1;
         }
         field_pic_flag = get_bits1(&h->gb);
         if (field_pic_flag) {
             bottom_field_flag = get_bits1(&h->gb);
             h->picture_structure = PICT_TOP_FIELD + bottom_field_flag;
         } else {
             h->picture_structure = PICT_FRAME;
             h->mb_aff_frame      = h->sps.mb_aff;
         }
     }
     h->mb_field_decoding_flag = h->picture_structure != PICT_FRAME;
     if (h0->current_slice != 0) {
         if (last_pic_structure != h->picture_structure ||
             last_pic_droppable != h->droppable) {
             av_log(h->avctx, AV_LOG_ERROR,
                    ""Changing field mode (%d -> %d) between slices is not allowed\n"",
                    last_pic_structure, h->picture_structure);
             h->picture_structure = last_pic_structure;
             h->droppable         = last_pic_droppable;
             return AVERROR_INVALIDDATA;
         } else if (!h0->cur_pic_ptr) {
             av_log(h->avctx, AV_LOG_ERROR,
                    ""unset cur_pic_ptr on %d. slice\n"",
                    h0->current_slice + 1);
             return AVERROR_INVALIDDATA;
         }
     } else {
         if (h->frame_num != h->prev_frame_num && h->prev_frame_num >= 0) {
             int unwrap_prev_frame_num = h->prev_frame_num;
             int max_frame_num         = 1 << h->sps.log2_max_frame_num;
             if (unwrap_prev_frame_num > h->frame_num)
                 unwrap_prev_frame_num -= max_frame_num;
             if ((h->frame_num - unwrap_prev_frame_num) > h->sps.ref_frame_count) {
                 unwrap_prev_frame_num = (h->frame_num - h->sps.ref_frame_count) - 1;
                 if (unwrap_prev_frame_num < 0)
                     unwrap_prev_frame_num += max_frame_num;
                 h->prev_frame_num = unwrap_prev_frame_num;
             }
         }
         if (h0->first_field) {
             assert(h0->cur_pic_ptr);
             assert(h0->cur_pic_ptr->f.data[0]);
              assert(h0->cur_pic_ptr->reference != DELAYED_PIC_REF);
            if (!last_pic_droppable && h0->cur_pic_ptr->tf.owner == h0->avctx) {
             if (h0->cur_pic_ptr->tf.owner == h0->avctx) {
                  ff_thread_report_progress(&h0->cur_pic_ptr->tf, INT_MAX,
                                            last_pic_structure == PICT_BOTTOM_FIELD);
              }
              if (!FIELD_PICTURE(h) || h->picture_structure == last_pic_structure) {
                if (!last_pic_droppable && last_pic_structure != PICT_FRAME) {
                 if (last_pic_structure != PICT_FRAME) {
                      ff_thread_report_progress(&h0->cur_pic_ptr->tf, INT_MAX,
                                                last_pic_structure == PICT_TOP_FIELD);
                  }
             } else {
                 if (h0->cur_pic_ptr->frame_num != h->frame_num) {
                    if (!last_pic_droppable && last_pic_structure != PICT_FRAME) {
                     if (last_pic_structure != PICT_FRAME) {
                          ff_thread_report_progress(&h0->cur_pic_ptr->tf, INT_MAX,
                                                    last_pic_structure == PICT_TOP_FIELD);
                      }
                 } else {
                     if (!((last_pic_structure   == PICT_TOP_FIELD &&
                            h->picture_structure == PICT_BOTTOM_FIELD) ||
                           (last_pic_structure   == PICT_BOTTOM_FIELD &&
                            h->picture_structure == PICT_TOP_FIELD))) {
                         av_log(h->avctx, AV_LOG_ERROR,
                                ""Invalid field mode combination %d/%d\n"",
                                last_pic_structure, h->picture_structure);
                         h->picture_structure = last_pic_structure;
                         h->droppable         = last_pic_droppable;
                         return AVERROR_INVALIDDATA;
                     } else if (last_pic_droppable != h->droppable) {
                         avpriv_request_sample(h->avctx,
                                               ""Found reference and non-reference fields in the same frame, which"");
                         h->picture_structure = last_pic_structure;
                         h->droppable         = last_pic_droppable;
                         return AVERROR_PATCHWELCOME;
                     }
                 }
             }
         }
         while (h->frame_num != h->prev_frame_num && h->prev_frame_num >= 0 && !h0->first_field &&
                h->frame_num != (h->prev_frame_num + 1) % (1 << h->sps.log2_max_frame_num)) {
             Picture *prev = h->short_ref_count ? h->short_ref[0] : NULL;
             av_log(h->avctx, AV_LOG_DEBUG, ""Frame num gap %d %d\n"",
                    h->frame_num, h->prev_frame_num);
             if (!h->sps.gaps_in_frame_num_allowed_flag)
                 for(i=0; i<FF_ARRAY_ELEMS(h->last_pocs); i++)
                     h->last_pocs[i] = INT_MIN;
             ret = h264_frame_start(h);
             if (ret < 0)
                 return ret;
             h->prev_frame_num++;
             h->prev_frame_num        %= 1 << h->sps.log2_max_frame_num;
             h->cur_pic_ptr->frame_num = h->prev_frame_num;
             ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, 0);
             ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, 1);
             ret = ff_generate_sliding_window_mmcos(h, 1);
             if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))
                 return ret;
             ret = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index);
             if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))
                 return ret;
             if (h->short_ref_count) {
                 if (prev) {
                     av_image_copy(h->short_ref[0]->f.data,
                                   h->short_ref[0]->f.linesize,
                                   (const uint8_t **)prev->f.data,
                                   prev->f.linesize,
                                   h->avctx->pix_fmt,
                                   h->mb_width  * 16,
                                   h->mb_height * 16);
                     h->short_ref[0]->poc = prev->poc + 2;
                 }
                 h->short_ref[0]->frame_num = h->prev_frame_num;
             }
         }
         if (h0->first_field) {
             assert(h0->cur_pic_ptr);
             assert(h0->cur_pic_ptr->f.data[0]);
             assert(h0->cur_pic_ptr->reference != DELAYED_PIC_REF);
             if (!FIELD_PICTURE(h) || h->picture_structure == last_pic_structure) {
                 h0->cur_pic_ptr = NULL;
                 h0->first_field = FIELD_PICTURE(h);
             } else {
                 if (h0->cur_pic_ptr->frame_num != h->frame_num) {
                     ff_thread_report_progress(&h0->cur_pic_ptr->tf, INT_MAX,
                                               h0->picture_structure==PICT_BOTTOM_FIELD);
                     h0->first_field = 1;
                     h0->cur_pic_ptr = NULL;
                 } else {
                     h0->first_field = 0;
                 }
             }
         } else {
             h0->first_field = FIELD_PICTURE(h);
         }
         if (!FIELD_PICTURE(h) || h0->first_field) {
             if (h264_frame_start(h) < 0) {
                 h0->first_field = 0;
                 return AVERROR_INVALIDDATA;
             }
         } else {
             release_unused_pictures(h, 0);
         }
         if (FIELD_PICTURE(h)) {
             for(i = (h->picture_structure == PICT_BOTTOM_FIELD); i<h->mb_height; i++)
                 memset(h->slice_table + i*h->mb_stride, -1, (h->mb_stride - (i+1==h->mb_height)) * sizeof(*h->slice_table));
         } else {
             memset(h->slice_table, -1,
                 (h->mb_height * h->mb_stride - 1) * sizeof(*h->slice_table));
         }
         h0->last_slice_type = -1;
     }
     if (h != h0 && (ret = clone_slice(h, h0)) < 0)
         return ret;
     for (i = 0; i < h->slice_context_count; i++)
         if (h->thread_context[i]) {
             ret = alloc_scratch_buffers(h->thread_context[i], h->linesize);
             if (ret < 0)
                 return ret;
         }
     h->cur_pic_ptr->frame_num = h->frame_num;  
     av_assert1(h->mb_num == h->mb_width * h->mb_height);
     if (first_mb_in_slice << FIELD_OR_MBAFF_PICTURE(h) >= h->mb_num ||
         first_mb_in_slice >= h->mb_num) {
         av_log(h->avctx, AV_LOG_ERROR, ""first_mb_in_slice overflow\n"");
         return AVERROR_INVALIDDATA;
     }
     h->resync_mb_x = h->mb_x =  first_mb_in_slice % h->mb_width;
     h->resync_mb_y = h->mb_y = (first_mb_in_slice / h->mb_width) <<
                                FIELD_OR_MBAFF_PICTURE(h);
     if (h->picture_structure == PICT_BOTTOM_FIELD)
         h->resync_mb_y = h->mb_y = h->mb_y + 1;
     av_assert1(h->mb_y < h->mb_height);
     if (h->picture_structure == PICT_FRAME) {
         h->curr_pic_num = h->frame_num;
         h->max_pic_num  = 1 << h->sps.log2_max_frame_num;
     } else {
         h->curr_pic_num = 2 * h->frame_num + 1;
         h->max_pic_num  = 1 << (h->sps.log2_max_frame_num + 1);
     }
     if (h->nal_unit_type == NAL_IDR_SLICE)
         get_ue_golomb(&h->gb);  
     if (h->sps.poc_type == 0) {
         h->poc_lsb = get_bits(&h->gb, h->sps.log2_max_poc_lsb);
         if (h->pps.pic_order_present == 1 && h->picture_structure == PICT_FRAME)
             h->delta_poc_bottom = get_se_golomb(&h->gb);
     }
     if (h->sps.poc_type == 1 && !h->sps.delta_pic_order_always_zero_flag) {
         h->delta_poc[0] = get_se_golomb(&h->gb);
         if (h->pps.pic_order_present == 1 && h->picture_structure == PICT_FRAME)
             h->delta_poc[1] = get_se_golomb(&h->gb);
     }
     ff_init_poc(h, h->cur_pic_ptr->field_poc, &h->cur_pic_ptr->poc);
     if (h->pps.redundant_pic_cnt_present)
         h->redundant_pic_count = get_ue_golomb(&h->gb);
     ret = ff_set_ref_count(h);
     if (ret < 0)
         return ret;
     if (slice_type != AV_PICTURE_TYPE_I &&
         (h0->current_slice == 0 ||
          slice_type != h0->last_slice_type ||
          memcmp(h0->last_ref_count, h0->ref_count, sizeof(h0->ref_count)))) {
         ff_h264_fill_default_ref_list(h);
     }
     if (h->slice_type_nos != AV_PICTURE_TYPE_I) {
        ret = ff_h264_decode_ref_pic_list_reordering(h);
        if (ret < 0) {
            h->ref_count[1] = h->ref_count[0] = 0;
            return ret;
        }
     }
     if ((h->pps.weighted_pred && h->slice_type_nos == AV_PICTURE_TYPE_P) ||
         (h->pps.weighted_bipred_idc == 1 &&
          h->slice_type_nos == AV_PICTURE_TYPE_B))
         ff_pred_weight_table(h);
     else if (h->pps.weighted_bipred_idc == 2 &&
              h->slice_type_nos == AV_PICTURE_TYPE_B) {
         implicit_weight_table(h, -1);
     } else {
         h->use_weight = 0;
         for (i = 0; i < 2; i++) {
             h->luma_weight_flag[i]   = 0;
             h->chroma_weight_flag[i] = 0;
         }
     }
     if (h->nal_ref_idc) {
         ret = ff_h264_decode_ref_pic_marking(h0, &h->gb,
                                              !(h->avctx->active_thread_type & FF_THREAD_FRAME) ||
                                              h0->current_slice == 0);
         if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))
             return AVERROR_INVALIDDATA;
     }
     if (FRAME_MBAFF(h)) {
         ff_h264_fill_mbaff_ref_list(h);
         if (h->pps.weighted_bipred_idc == 2 && h->slice_type_nos == AV_PICTURE_TYPE_B) {
             implicit_weight_table(h, 0);
             implicit_weight_table(h, 1);
         }
     }
     if (h->slice_type_nos == AV_PICTURE_TYPE_B && !h->direct_spatial_mv_pred)
         ff_h264_direct_dist_scale_factor(h);
     ff_h264_direct_ref_list_init(h);
     if (h->slice_type_nos != AV_PICTURE_TYPE_I && h->pps.cabac) {
         tmp = get_ue_golomb_31(&h->gb);
         if (tmp > 2) {
             av_log(h->avctx, AV_LOG_ERROR, ""cabac_init_idc overflow\n"");
             return AVERROR_INVALIDDATA;
         }
         h->cabac_init_idc = tmp;
     }
     h->last_qscale_diff = 0;
     tmp = h->pps.init_qp + get_se_golomb(&h->gb);
     if (tmp > 51 + 6 * (h->sps.bit_depth_luma - 8)) {
         av_log(h->avctx, AV_LOG_ERROR, ""QP %u out of range\n"", tmp);
         return AVERROR_INVALIDDATA;
     }
     h->qscale       = tmp;
     h->chroma_qp[0] = get_chroma_qp(h, 0, h->qscale);
     h->chroma_qp[1] = get_chroma_qp(h, 1, h->qscale);
     if (h->slice_type == AV_PICTURE_TYPE_SP)
         get_bits1(&h->gb);  
     if (h->slice_type == AV_PICTURE_TYPE_SP ||
         h->slice_type == AV_PICTURE_TYPE_SI)
         get_se_golomb(&h->gb);  
     h->deblocking_filter     = 1;
     h->slice_alpha_c0_offset = 52;
     h->slice_beta_offset     = 52;
     if (h->pps.deblocking_filter_parameters_present) {
         tmp = get_ue_golomb_31(&h->gb);
         if (tmp > 2) {
             av_log(h->avctx, AV_LOG_ERROR,
                    ""deblocking_filter_idc %u out of range\n"", tmp);
             return AVERROR_INVALIDDATA;
         }
         h->deblocking_filter = tmp;
         if (h->deblocking_filter < 2)
             h->deblocking_filter ^= 1;   
         if (h->deblocking_filter) {
             h->slice_alpha_c0_offset += get_se_golomb(&h->gb) << 1;
             h->slice_beta_offset     += get_se_golomb(&h->gb) << 1;
             if (h->slice_alpha_c0_offset > 104U ||
                 h->slice_beta_offset     > 104U) {
                 av_log(h->avctx, AV_LOG_ERROR,
                        ""deblocking filter parameters %d %d out of range\n"",
                        h->slice_alpha_c0_offset, h->slice_beta_offset);
                 return AVERROR_INVALIDDATA;
             }
         }
     }
     if (h->avctx->skip_loop_filter >= AVDISCARD_ALL ||
         (h->avctx->skip_loop_filter >= AVDISCARD_NONKEY &&
          h->slice_type_nos != AV_PICTURE_TYPE_I) ||
         (h->avctx->skip_loop_filter >= AVDISCARD_BIDIR  &&
          h->slice_type_nos == AV_PICTURE_TYPE_B) ||
         (h->avctx->skip_loop_filter >= AVDISCARD_NONREF &&
          h->nal_ref_idc == 0))
         h->deblocking_filter = 0;
     if (h->deblocking_filter == 1 && h0->max_contexts > 1) {
         if (h->avctx->flags2 & CODEC_FLAG2_FAST) {
             h->deblocking_filter = 2;
         } else {
             h0->max_contexts = 1;
             if (!h0->single_decode_warning) {
                 av_log(h->avctx, AV_LOG_INFO,
                        ""Cannot parallelize deblocking type 1, decoding such frames in sequential order\n"");
                 h0->single_decode_warning = 1;
             }
             if (h != h0) {
                 av_log(h->avctx, AV_LOG_ERROR,
                        ""Deblocking switched inside frame.\n"");
                 return 1;
             }
         }
     }
     h->qp_thresh = 15 + 52 -
                    FFMIN(h->slice_alpha_c0_offset, h->slice_beta_offset) -
                    FFMAX3(0,
                           h->pps.chroma_qp_index_offset[0],
                           h->pps.chroma_qp_index_offset[1]) +
                    6 * (h->sps.bit_depth_luma - 8);
     h0->last_slice_type = slice_type;
     memcpy(h0->last_ref_count, h0->ref_count, sizeof(h0->last_ref_count));
     h->slice_num        = ++h0->current_slice;
     if (h->slice_num)
         h0->slice_row[(h->slice_num-1)&(MAX_SLICES-1)]= h->resync_mb_y;
     if (   h0->slice_row[h->slice_num&(MAX_SLICES-1)] + 3 >= h->resync_mb_y
         && h0->slice_row[h->slice_num&(MAX_SLICES-1)] <= h->resync_mb_y
         && h->slice_num >= MAX_SLICES) {
         av_log(h->avctx, AV_LOG_WARNING, ""Possibly too many slices (%d >= %d), increase MAX_SLICES and recompile if there are artifacts\n"", h->slice_num, MAX_SLICES);
     }
     for (j = 0; j < 2; j++) {
         int id_list[16];
         int *ref2frm = h->ref2frm[h->slice_num & (MAX_SLICES - 1)][j];
         for (i = 0; i < 16; i++) {
             id_list[i] = 60;
             if (j < h->list_count && i < h->ref_count[j] &&
                 h->ref_list[j][i].f.buf[0]) {
                 int k;
                 AVBuffer *buf = h->ref_list[j][i].f.buf[0]->buffer;
                 for (k = 0; k < h->short_ref_count; k++)
                     if (h->short_ref[k]->f.buf[0]->buffer == buf) {
                         id_list[i] = k;
                         break;
                     }
                 for (k = 0; k < h->long_ref_count; k++)
                     if (h->long_ref[k] && h->long_ref[k]->f.buf[0]->buffer == buf) {
                         id_list[i] = h->short_ref_count + k;
                         break;
                     }
             }
         }
         ref2frm[0] =
         ref2frm[1] = -1;
         for (i = 0; i < 16; i++)
             ref2frm[i + 2] = 4 * id_list[i] + (h->ref_list[j][i].reference & 3);
         ref2frm[18 + 0] =
         ref2frm[18 + 1] = -1;
         for (i = 16; i < 48; i++)
             ref2frm[i + 4] = 4 * id_list[(i - 16) >> 1] +
                              (h->ref_list[j][i].reference & 3);
     }
     if (h->ref_count[0]) h->er.last_pic = &h->ref_list[0][0];
     if (h->ref_count[1]) h->er.next_pic = &h->ref_list[1][0];
     h->er.ref_count = h->ref_count[0];
     if (h->avctx->debug & FF_DEBUG_PICT_INFO) {
         av_log(h->avctx, AV_LOG_DEBUG,
                ""slice:%d %s mb:%d %c%s%s pps:%u frame:%d poc:%d/%d ref:%d/%d qp:%d loop:%d:%d:%d weight:%d%s %s\n"",
                h->slice_num,
                (h->picture_structure == PICT_FRAME ? ""F"" : h->picture_structure == PICT_TOP_FIELD ? ""T"" : ""B""),
                first_mb_in_slice,
                av_get_picture_type_char(h->slice_type),
                h->slice_type_fixed ? "" fix"" : """",
                h->nal_unit_type == NAL_IDR_SLICE ? "" IDR"" : """",
                pps_id, h->frame_num,
                h->cur_pic_ptr->field_poc[0],
                h->cur_pic_ptr->field_poc[1],
                h->ref_count[0], h->ref_count[1],
                h->qscale,
                h->deblocking_filter,
                h->slice_alpha_c0_offset / 2 - 26, h->slice_beta_offset / 2 - 26,
                h->use_weight,
                h->use_weight == 1 && h->use_weight_chroma ? ""c"" : """",
                h->slice_type == AV_PICTURE_TYPE_B ? (h->direct_spatial_mv_pred ? ""SPAT"" : ""TEMP"") : """");
     }
     return 0;
 }","[213, 214, 219, 220, 226, 227]","The decode_slice_header function in libavcodec/h264.c in FFmpeg before 2.1 incorrectly relies on a certain droppable field, which allows remote attackers to cause a denial of service (deadlock) or possibly have unspecified other impact via crafted H.264 data.",FFmpeg,CVE-2013-7008,
707,177800," XcursorCommentCreate (XcursorUInt comment_type, int length)
 {
     XcursorComment  *comment;
     if (length > XCURSOR_COMMENT_MAX_LEN)
 	return NULL;
  {
      XcursorComment  *comment;
    if (length > XCURSOR_COMMENT_MAX_LEN)
     if (length < 0 || length > XCURSOR_COMMENT_MAX_LEN)
  	return NULL;
      comment = malloc (sizeof (XcursorComment) + length + 1);
     comment->comment[0] = '\0';
     return comment;
 }
 void
 XcursorCommentDestroy (XcursorComment *comment)
 {
     free (comment);
 }
 XcursorComments *
 XcursorCommentsCreate (int size)
 {
     XcursorComments *comments;
     comments = malloc (sizeof (XcursorComments) +
 		       size * sizeof (XcursorComment *));
     if (!comments)
 	return NULL;
     comments->ncomment = 0;
     comments->comments = (XcursorComment **) (comments + 1);
     return comments;
 }
 void
 XcursorCommentsDestroy (XcursorComments *comments)
 {
     int	n;
     if (!comments)
         return;
     for (n = 0; n < comments->ncomment; n++)
 	XcursorCommentDestroy (comments->comments[n]);
     free (comments);
 }
 static XcursorBool
 _XcursorReadUInt (XcursorFile *file, XcursorUInt *u)
 {
     unsigned char   bytes[4];
     if (!file || !u)
         return XcursorFalse;
     if ((*file->read) (file, bytes, 4) != 4)
 	return XcursorFalse;
     *u = ((bytes[0] << 0) |
 	  (bytes[1] << 8) |
 	  (bytes[2] << 16) |
 	  (bytes[3] << 24));
     return XcursorTrue;
 }
 static XcursorBool
 _XcursorReadBytes (XcursorFile *file, char *bytes, int length)
 {
     if (!file || !bytes || (*file->read) (file, (unsigned char *) bytes, length) != length)
 	return XcursorFalse;
     return XcursorTrue;
 }
 static XcursorBool
 _XcursorWriteUInt (XcursorFile *file, XcursorUInt u)
 {
     unsigned char   bytes[4];
     if (!file)
         return XcursorFalse;
     bytes[0] = u;
     bytes[1] = u >>  8;
     bytes[2] = u >> 16;
     bytes[3] = u >> 24;
     if ((*file->write) (file, bytes, 4) != 4)
 	return XcursorFalse;
     return XcursorTrue;
 }
 static XcursorBool
 _XcursorWriteBytes (XcursorFile *file, char *bytes, int length)
 {
     if (!file || !bytes || (*file->write) (file, (unsigned char *) bytes, length) != length)
 	return XcursorFalse;
     return XcursorTrue;
 }
 static void
 _XcursorFileHeaderDestroy (XcursorFileHeader *fileHeader)
 {
     free (fileHeader);
 }
 static XcursorFileHeader *
 _XcursorFileHeaderCreate (XcursorUInt ntoc)
 {
     XcursorFileHeader	*fileHeader;
     if (ntoc > 0x10000)
 	return NULL;
     fileHeader = malloc (sizeof (XcursorFileHeader) +
 			 ntoc * sizeof (XcursorFileToc));
     if (!fileHeader)
 	return NULL;
     fileHeader->magic = XCURSOR_MAGIC;
     fileHeader->header = XCURSOR_FILE_HEADER_LEN;
     fileHeader->version = XCURSOR_FILE_VERSION;
     fileHeader->ntoc = ntoc;
     fileHeader->tocs = (XcursorFileToc *) (fileHeader + 1);
     return fileHeader;
 }
 static XcursorFileHeader *
 _XcursorReadFileHeader (XcursorFile *file)
 {
     XcursorFileHeader	head, *fileHeader;
     XcursorUInt		skip;
     int			n;
     if (!file)
         return NULL;
     if (!_XcursorReadUInt (file, &head.magic))
 	return NULL;
     if (head.magic != XCURSOR_MAGIC)
 	return NULL;
     if (!_XcursorReadUInt (file, &head.header))
 	return NULL;
     if (!_XcursorReadUInt (file, &head.version))
 	return NULL;
     if (!_XcursorReadUInt (file, &head.ntoc))
 	return NULL;
     skip = head.header - XCURSOR_FILE_HEADER_LEN;
     if (skip)
 	if ((*file->seek) (file, skip, SEEK_CUR) == EOF)
 	    return NULL;
     fileHeader = _XcursorFileHeaderCreate (head.ntoc);
     if (!fileHeader)
 	return NULL;
     fileHeader->magic = head.magic;
     fileHeader->header = head.header;
     fileHeader->version = head.version;
     fileHeader->ntoc = head.ntoc;
     for (n = 0; n < fileHeader->ntoc; n++)
     {
 	if (!_XcursorReadUInt (file, &fileHeader->tocs[n].type))
 	    break;
 	if (!_XcursorReadUInt (file, &fileHeader->tocs[n].subtype))
 	    break;
 	if (!_XcursorReadUInt (file, &fileHeader->tocs[n].position))
 	    break;
     }
     if (n != fileHeader->ntoc)
     {
 	_XcursorFileHeaderDestroy (fileHeader);
 	return NULL;
     }
     return fileHeader;
 }
 static XcursorUInt
 _XcursorFileHeaderLength (XcursorFileHeader *fileHeader)
 {
     return (XCURSOR_FILE_HEADER_LEN +
 	    fileHeader->ntoc * XCURSOR_FILE_TOC_LEN);
 }
 static XcursorBool
 _XcursorWriteFileHeader (XcursorFile *file, XcursorFileHeader *fileHeader)
 {
     int	toc;
     if (!file || !fileHeader)
         return XcursorFalse;
     if (!_XcursorWriteUInt (file, fileHeader->magic))
 	return XcursorFalse;
     if (!_XcursorWriteUInt (file, fileHeader->header))
 	return XcursorFalse;
     if (!_XcursorWriteUInt (file, fileHeader->version))
 	return XcursorFalse;
     if (!_XcursorWriteUInt (file, fileHeader->ntoc))
 	return XcursorFalse;
     for (toc = 0; toc < fileHeader->ntoc; toc++)
     {
 	if (!_XcursorWriteUInt (file, fileHeader->tocs[toc].type))
 	    return XcursorFalse;
 	if (!_XcursorWriteUInt (file, fileHeader->tocs[toc].subtype))
 	    return XcursorFalse;
 	if (!_XcursorWriteUInt (file, fileHeader->tocs[toc].position))
 	    return XcursorFalse;
     }
     return XcursorTrue;
 }
 static XcursorBool
 _XcursorSeekToToc (XcursorFile		*file,
 		   XcursorFileHeader	*fileHeader,
 		   int			toc)
 {
     if (!file || !fileHeader || \
         (*file->seek) (file, fileHeader->tocs[toc].position, SEEK_SET) == EOF)
 	return XcursorFalse;
     return XcursorTrue;
 }
 static XcursorBool
 _XcursorFileReadChunkHeader (XcursorFile	*file,
 			     XcursorFileHeader	*fileHeader,
 			     int		toc,
 			     XcursorChunkHeader	*chunkHeader)
 {
     if (!file || !fileHeader || !chunkHeader)
         return XcursorFalse;
     if (!_XcursorSeekToToc (file, fileHeader, toc))
 	return XcursorFalse;
     if (!_XcursorReadUInt (file, &chunkHeader->header))
 	return XcursorFalse;
     if (!_XcursorReadUInt (file, &chunkHeader->type))
 	return XcursorFalse;
     if (!_XcursorReadUInt (file, &chunkHeader->subtype))
 	return XcursorFalse;
     if (!_XcursorReadUInt (file, &chunkHeader->version))
 	return XcursorFalse;
     if (chunkHeader->type != fileHeader->tocs[toc].type ||
 	chunkHeader->subtype != fileHeader->tocs[toc].subtype)
 	return XcursorFalse;
     return XcursorTrue;
 }
 static XcursorBool
 _XcursorFileWriteChunkHeader (XcursorFile	    *file,
 			      XcursorFileHeader	    *fileHeader,
 			      int		    toc,
 			      XcursorChunkHeader    *chunkHeader)
 {
     if (!file || !fileHeader || !chunkHeader)
         return XcursorFalse;
     if (!_XcursorSeekToToc (file, fileHeader, toc))
 	return XcursorFalse;
     if (!_XcursorWriteUInt (file, chunkHeader->header))
 	return XcursorFalse;
     if (!_XcursorWriteUInt (file, chunkHeader->type))
 	return XcursorFalse;
     if (!_XcursorWriteUInt (file, chunkHeader->subtype))
 	return XcursorFalse;
     if (!_XcursorWriteUInt (file, chunkHeader->version))
 	return XcursorFalse;
     return XcursorTrue;
 }
 #define dist(a,b)   ((a) > (b) ? (a) - (b) : (b) - (a))
 static XcursorDim
 _XcursorFindBestSize (XcursorFileHeader *fileHeader,
 		      XcursorDim	size,
 		      int		*nsizesp)
 {
     int		n;
     int		nsizes = 0;
     XcursorDim	bestSize = 0;
     XcursorDim	thisSize;
     if (!fileHeader || !nsizesp)
         return 0;
     for (n = 0; n < fileHeader->ntoc; n++)
     {
 	if (fileHeader->tocs[n].type != XCURSOR_IMAGE_TYPE)
 	    continue;
 	thisSize = fileHeader->tocs[n].subtype;
 	if (!bestSize || dist (thisSize, size) < dist (bestSize, size))
 	{
 	    bestSize = thisSize;
 	    nsizes = 1;
 	}
 	else if (thisSize == bestSize)
 	    nsizes++;
     }
     *nsizesp = nsizes;
     return bestSize;
 }
 static int
 _XcursorFindImageToc (XcursorFileHeader	*fileHeader,
 		      XcursorDim	size,
 		      int		count)
 {
     int			toc;
     XcursorDim		thisSize;
     if (!fileHeader)
         return 0;
     for (toc = 0; toc < fileHeader->ntoc; toc++)
     {
 	if (fileHeader->tocs[toc].type != XCURSOR_IMAGE_TYPE)
 	    continue;
 	thisSize = fileHeader->tocs[toc].subtype;
 	if (thisSize != size)
 	    continue;
 	if (!count)
 	    break;
 	count--;
     }
     if (toc == fileHeader->ntoc)
 	return -1;
     return toc;
 }
 static XcursorImage *
 _XcursorReadImage (XcursorFile		*file,
 		   XcursorFileHeader	*fileHeader,
 		   int			toc)
 {
     XcursorChunkHeader	chunkHeader;
     XcursorImage	head;
     XcursorImage	*image;
     int			n;
     XcursorPixel	*p;
     if (!file || !fileHeader)
         return NULL;
     if (!_XcursorFileReadChunkHeader (file, fileHeader, toc, &chunkHeader))
 	return NULL;
     if (!_XcursorReadUInt (file, &head.width))
 	return NULL;
     if (!_XcursorReadUInt (file, &head.height))
 	return NULL;
     if (!_XcursorReadUInt (file, &head.xhot))
 	return NULL;
     if (!_XcursorReadUInt (file, &head.yhot))
 	return NULL;
     if (!_XcursorReadUInt (file, &head.delay))
 	return NULL;
     if (head.width >= 0x10000 || head.height > 0x10000)
 	return NULL;
      if (!_XcursorReadUInt (file, &head.delay))
  	return NULL;
    if (head.width >= 0x10000 || head.height > 0x10000)
     if (head.width > XCURSOR_IMAGE_MAX_SIZE  ||
 	head.height > XCURSOR_IMAGE_MAX_SIZE)
  	return NULL;
      if (head.width == 0 || head.height == 0)
  	return NULL;
 	image->version = chunkHeader.version;
     image->size = chunkHeader.subtype;
      image = XcursorImageCreate (head.width, head.height);
     if (image == NULL)
 	return NULL;
      if (chunkHeader.version < image->version)
  	image->version = chunkHeader.version;
      image->size = chunkHeader.subtype;
 	{
 	    XcursorImageDestroy (image);
 	    return NULL;
 	}
 	p++;
     }
     return image;
 }","[8, 9, 315, 316, 317, 324, 325]","libXcursor before 1.1.15 has various integer overflows that could lead to heap buffer overflows when processing malicious cursors, e.g., with programs like GIMP. It is also possible that an attack vector exists against the related code in cursor/xcursor.c in Wayland through 1.14.0.",xcursor,CVE-2017-16612,CWE-190
747,180646," void set_fat(DOS_FS * fs, uint32_t cluster, int32_t new)
 {
     unsigned char *data = NULL;
     int size;
     loff_t offs;
     if (new == -1)
 	new = FAT_EOF(fs);
     else if ((long)new == -2)
 	new = FAT_BAD(fs);
     switch (fs->fat_bits) {
     case 12:
 	data = fs->fat + cluster * 3 / 2;
 	offs = fs->fat_start + cluster * 3 / 2;
 	if (cluster & 1) {
 	    FAT_ENTRY prevEntry;
 	    get_fat(&prevEntry, fs->fat, cluster - 1, fs);
 	    data[0] = ((new & 0xf) << 4) | (prevEntry.value >> 8);
  	    data[1] = new >> 4;
  	} else {
  	    FAT_ENTRY subseqEntry;
	    if (cluster != fs->clusters - 1)
 	    if (cluster != fs->clusters + 1)
  		get_fat(&subseqEntry, fs->fat, cluster + 1, fs);
  	    else
  		subseqEntry.value = 0;
 	    data[0] = new & 0xff;
 	    data[1] = (new >> 8) | ((0xff & subseqEntry.value) << 4);
 	}
 	size = 2;
 	break;
     case 16:
 	data = fs->fat + cluster * 2;
 	offs = fs->fat_start + cluster * 2;
 	*(unsigned short *)data = htole16(new);
 	size = 2;
 	break;
     case 32:
 	{
 	    FAT_ENTRY curEntry;
 	    get_fat(&curEntry, fs->fat, cluster, fs);
 	    data = fs->fat + cluster * 4;
 	    offs = fs->fat_start + cluster * 4;
 	    *(uint32_t *)data = htole32((new & 0xfffffff) |
 					     (curEntry.reserved << 28));
 	    size = 4;
 	}
 	break;
     default:
 	die(""Bad FAT entry size: %d bits."", fs->fat_bits);
     }
     fs_write(offs, size, data);
     if (fs->nfats > 1) {
 	fs_write(offs + fs->fat_size, size, data);
     }
 }","[21, 22]","The set_fat function in fat.c in dosfstools before 4.0 might allow attackers to corrupt a FAT12 filesystem or cause a denial of service (invalid memory read and crash) by writing an odd number of clusters to the third to last entry on a FAT12 filesystem, which triggers an *off-by-two error.*",dosfstools,CVE-2015-8872,CWE-189
769,181243," int vp78_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,
                       AVPacket *avpkt, int is_vp7)
 {
     VP8Context *s = avctx->priv_data;
     int ret, i, referenced, num_jobs;
      enum AVDiscard skip_thresh;
      VP8Frame *av_uninit(curframe), *prev_frame;
     av_assert0(avctx->pix_fmt == AV_PIX_FMT_YUVA420P || avctx->pix_fmt == AV_PIX_FMT_YUV420P);
      if (is_vp7)
          ret = vp7_decode_frame_header(s, avpkt->data, avpkt->size);
      else
         ret = vp8_decode_frame_header(s, avpkt->data, avpkt->size);
     if (ret < 0)
         goto err;
     prev_frame = s->framep[VP56_FRAME_CURRENT];
     referenced = s->update_last || s->update_golden == VP56_FRAME_CURRENT ||
                  s->update_altref == VP56_FRAME_CURRENT;
     skip_thresh = !referenced ? AVDISCARD_NONREF
                               : !s->keyframe ? AVDISCARD_NONKEY
                                              : AVDISCARD_ALL;
     if (avctx->skip_frame >= skip_thresh) {
         s->invisible = 1;
         memcpy(&s->next_framep[0], &s->framep[0], sizeof(s->framep[0]) * 4);
         goto skip_decode;
     }
     s->deblock_filter = s->filter.level && avctx->skip_loop_filter < skip_thresh;
     for (i = 0; i < 5; i++)
         if (s->frames[i].tf.f->data[0] &&
             &s->frames[i] != prev_frame &&
             &s->frames[i] != s->framep[VP56_FRAME_PREVIOUS] &&
             &s->frames[i] != s->framep[VP56_FRAME_GOLDEN]   &&
             &s->frames[i] != s->framep[VP56_FRAME_GOLDEN2])
             vp8_release_frame(s, &s->frames[i]);
     curframe = s->framep[VP56_FRAME_CURRENT] = vp8_find_free_buffer(s);
     if (!s->colorspace)
         avctx->colorspace = AVCOL_SPC_BT470BG;
     if (s->fullrange)
         avctx->color_range = AVCOL_RANGE_JPEG;
     else
         avctx->color_range = AVCOL_RANGE_MPEG;
     if (!s->keyframe && (!s->framep[VP56_FRAME_PREVIOUS] ||
                          !s->framep[VP56_FRAME_GOLDEN]   ||
                          !s->framep[VP56_FRAME_GOLDEN2])) {
         av_log(avctx, AV_LOG_WARNING,
                ""Discarding interframe without a prior keyframe!\n"");
         ret = AVERROR_INVALIDDATA;
         goto err;
     }
     curframe->tf.f->key_frame = s->keyframe;
     curframe->tf.f->pict_type = s->keyframe ? AV_PICTURE_TYPE_I
                                             : AV_PICTURE_TYPE_P;
     if ((ret = vp8_alloc_frame(s, curframe, referenced)) < 0)
         goto err;
     if (s->update_altref != VP56_FRAME_NONE)
         s->next_framep[VP56_FRAME_GOLDEN2] = s->framep[s->update_altref];
     else
         s->next_framep[VP56_FRAME_GOLDEN2] = s->framep[VP56_FRAME_GOLDEN2];
     if (s->update_golden != VP56_FRAME_NONE)
         s->next_framep[VP56_FRAME_GOLDEN] = s->framep[s->update_golden];
     else
         s->next_framep[VP56_FRAME_GOLDEN] = s->framep[VP56_FRAME_GOLDEN];
     if (s->update_last)
         s->next_framep[VP56_FRAME_PREVIOUS] = curframe;
     else
         s->next_framep[VP56_FRAME_PREVIOUS] = s->framep[VP56_FRAME_PREVIOUS];
     s->next_framep[VP56_FRAME_CURRENT] = curframe;
     if (avctx->codec->update_thread_context)
         ff_thread_finish_setup(avctx);
     s->linesize   = curframe->tf.f->linesize[0];
     s->uvlinesize = curframe->tf.f->linesize[1];
     memset(s->top_nnz, 0, s->mb_width * sizeof(*s->top_nnz));
     if (!s->mb_layout)
         memset(s->macroblocks + s->mb_height * 2 - 1, 0,
                (s->mb_width + 1) * sizeof(*s->macroblocks));
     if (!s->mb_layout && s->keyframe)
         memset(s->intra4x4_pred_mode_top, DC_PRED, s->mb_width * 4);
     memset(s->ref_count, 0, sizeof(s->ref_count));
     if (s->mb_layout == 1) {
         if (prev_frame && s->segmentation.enabled &&
             !s->segmentation.update_map)
             ff_thread_await_progress(&prev_frame->tf, 1, 0);
         if (is_vp7)
             vp7_decode_mv_mb_modes(avctx, curframe, prev_frame);
         else
             vp8_decode_mv_mb_modes(avctx, curframe, prev_frame);
     }
     if (avctx->active_thread_type == FF_THREAD_FRAME)
         num_jobs = 1;
     else
         num_jobs = FFMIN(s->num_coeff_partitions, avctx->thread_count);
     s->num_jobs   = num_jobs;
     s->curframe   = curframe;
     s->prev_frame = prev_frame;
     s->mv_bounds.mv_min.y   = -MARGIN;
     s->mv_bounds.mv_max.y   = ((s->mb_height - 1) << 6) + MARGIN;
     for (i = 0; i < MAX_THREADS; i++) {
         VP8ThreadData *td = &s->thread_data[i];
         atomic_init(&td->thread_mb_pos, 0);
         atomic_init(&td->wait_mb_pos, INT_MAX);
     }
     if (is_vp7)
         avctx->execute2(avctx, vp7_decode_mb_row_sliced, s->thread_data, NULL,
                         num_jobs);
     else
         avctx->execute2(avctx, vp8_decode_mb_row_sliced, s->thread_data, NULL,
                         num_jobs);
     ff_thread_report_progress(&curframe->tf, INT_MAX, 0);
     memcpy(&s->framep[0], &s->next_framep[0], sizeof(s->framep[0]) * 4);
 skip_decode:
     if (!s->update_probabilities)
         s->prob[0] = s->prob[1];
     if (!s->invisible) {
         if ((ret = av_frame_ref(data, curframe->tf.f)) < 0)
             return ret;
         *got_frame = 1;
     }
     return avpkt->size;
 err:
     memcpy(&s->next_framep[0], &s->framep[0], sizeof(s->framep[0]) * 4);
     return ret;
 }",[8],"libavcodec/webp.c in FFmpeg before 2.8.12, 3.0.x before 3.0.8, 3.1.x before 3.1.8, 3.2.x before 3.2.5, and 3.3.x before 3.3.1 does not ensure that pix_fmt is set, which allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted file, related to the vp8_decode_mb_row_no_filter and pred8x8_128_dc_8_c functions.",FFmpeg,CVE-2017-9994,CWE-119
808,180837," xmlParsePEReference(xmlParserCtxtPtr ctxt)
 {
     const xmlChar *name;
     xmlEntityPtr entity = NULL;
     xmlParserInputPtr input;
     if (RAW != '%')
         return;
     NEXT;
     name = xmlParseName(ctxt);
     if (name == NULL) {
 	xmlFatalErrMsg(ctxt, XML_ERR_PEREF_NO_NAME, ""PEReference: no name\n"");
 	return;
     }
     if (xmlParserDebugEntities)
 	xmlGenericError(xmlGenericErrorContext,
 		""PEReference: %s\n"", name);
     if (RAW != ';') {
 	xmlFatalErr(ctxt, XML_ERR_PEREF_SEMICOL_MISSING, NULL);
         return;
     }
     NEXT;
     ctxt->nbentities++;
     if ((ctxt->sax != NULL) &&
 	(ctxt->sax->getParameterEntity != NULL))
 	entity = ctxt->sax->getParameterEntity(ctxt->userData, name);
     if (ctxt->instate == XML_PARSER_EOF)
 	return;
     if (entity == NULL) {
 	if ((ctxt->standalone == 1) ||
 	    ((ctxt->hasExternalSubset == 0) &&
 	     (ctxt->hasPErefs == 0))) {
 	    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
 			      ""PEReference: %%%s; not found\n"",
 			      name);
 	} else {
             if ((ctxt->validate) && (ctxt->vctxt.error != NULL)) {
                 xmlValidityError(ctxt, XML_WAR_UNDECLARED_ENTITY,
                                  ""PEReference: %%%s; not found\n"",
                                  name, NULL);
             } else
                 xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,
                               ""PEReference: %%%s; not found\n"",
                               name, NULL);
             ctxt->valid = 0;
 	}
 	xmlParserEntityCheck(ctxt, 0, NULL, 0);
     } else {
 	if ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&
 	    (entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {
 	    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,
 		  ""Internal: %%%s; is not a parameter entity\n"",
 			  name, NULL);
 	} else {
             xmlChar start[4];
             xmlCharEncoding enc;
 	    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
 	        ((ctxt->options & XML_PARSE_NOENT) == 0) &&
 		((ctxt->options & XML_PARSE_DTDVALID) == 0) &&
 		((ctxt->options & XML_PARSE_DTDLOAD) == 0) &&
 		((ctxt->options & XML_PARSE_DTDATTR) == 0) &&
 		(ctxt->replaceEntities == 0) &&
 		(ctxt->validate == 0))
  		return;
  	    input = xmlNewEntityInputStream(ctxt, entity);
	    if (xmlPushInput(ctxt, input) < 0)
 	    if (xmlPushInput(ctxt, input) < 0) {
                 xmlFreeInputStream(input);
  		return;
             }
  	    if (entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) {
                 GROW
                 if (ctxt->instate == XML_PARSER_EOF)
                     return;
                 if ((ctxt->input->end - ctxt->input->cur)>=4) {
                     start[0] = RAW;
                     start[1] = NXT(1);
                     start[2] = NXT(2);
                     start[3] = NXT(3);
                     enc = xmlDetectCharEncoding(start, 4);
                     if (enc != XML_CHAR_ENCODING_NONE) {
                         xmlSwitchEncoding(ctxt, enc);
                     }
                 }
                 if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) &&
                     (IS_BLANK_CH(NXT(5)))) {
                     xmlParseTextDecl(ctxt);
                 }
             }
 	}
     }
     ctxt->hasPErefs = 1;
 }","[65, 66, 67, 69]",parser.c in libxml2 before 2.9.5 does not prevent infinite recursion in parameter entities.,libxml2,CVE-2017-16932,CWE-835
815,182116,"  static void decode_residue(vorb *f, float *residue_buffers[], int ch, int n, int rn, uint8 *do_not_decode)
  {
     int i,j,pass;
     Residue *r = f->residue_config + rn;
     int rtype = f->residue_types[rn];
     int c = r->classbook;
     int classwords = f->codebooks[c].dimensions;
   int n_read = r->end - r->begin;
    unsigned int actual_size = rtype == 2 ? n*2 : n;
    unsigned int limit_r_begin = (r->begin < actual_size ? r->begin : actual_size);
    unsigned int limit_r_end   = (r->end   < actual_size ? r->end   : actual_size);
    int n_read = limit_r_end - limit_r_begin;
     int part_read = n_read / r->part_size;
     int temp_alloc_point = temp_alloc_save(f);
     #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE
    uint8 ***part_classdata = (uint8 ***) temp_block_array(f,f->channels, part_read * sizeof(**part_classdata));
    #else
    int **classifications = (int **) temp_block_array(f,f->channels, part_read * sizeof(**classifications));
    #endif
    CHECK(f);
    for (i=0; i < ch; ++i)
       if (!do_not_decode[i])
          memset(residue_buffers[i], 0, sizeof(float) * n);
    if (rtype == 2 && ch != 1) {
       for (j=0; j < ch; ++j)
          if (!do_not_decode[j])
             break;
       if (j == ch)
          goto done;
       for (pass=0; pass < 8; ++pass) {
          int pcount = 0, class_set = 0;
          if (ch == 2) {
             while (pcount < part_read) {
                int z = r->begin + pcount*r->part_size;
                int c_inter = (z & 1), p_inter = z>>1;
                if (pass == 0) {
                   Codebook *c = f->codebooks+r->classbook;
                   int q;
                   DECODE(q,f,c);
                   if (q == EOP) goto done;
                   #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE
                   part_classdata[0][class_set] = r->classdata[q];
                   #else
                   for (i=classwords-1; i >= 0; --i) {
                      classifications[0][i+pcount] = q % r->classifications;
                      q /= r->classifications;
                   }
                   #endif
                }
                for (i=0; i < classwords && pcount < part_read; ++i, ++pcount) {
                   int z = r->begin + pcount*r->part_size;
                   #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE
                   int c = part_classdata[0][class_set][i];
                   #else
                   int c = classifications[0][pcount];
                   #endif
                   int b = r->residue_books[c][pass];
                   if (b >= 0) {
                      Codebook *book = f->codebooks + b;
                      #ifdef STB_VORBIS_DIVIDES_IN_CODEBOOK
                      if (!codebook_decode_deinterleave_repeat(f, book, residue_buffers, ch, &c_inter, &p_inter, n, r->part_size))
                         goto done;
                      #else
                      if (!codebook_decode_deinterleave_repeat(f, book, residue_buffers, ch, &c_inter, &p_inter, n, r->part_size))
                         goto done;
                      #endif
                   } else {
                      z += r->part_size;
                      c_inter = z & 1;
                      p_inter = z >> 1;
                   }
                }
                #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE
                ++class_set;
                #endif
             }
          } else if (ch == 1) {
             while (pcount < part_read) {
                int z = r->begin + pcount*r->part_size;
                int c_inter = 0, p_inter = z;
                if (pass == 0) {
                   Codebook *c = f->codebooks+r->classbook;
                   int q;
                   DECODE(q,f,c);
                   if (q == EOP) goto done;
                   #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE
                   part_classdata[0][class_set] = r->classdata[q];
                   #else
                   for (i=classwords-1; i >= 0; --i) {
                      classifications[0][i+pcount] = q % r->classifications;
                      q /= r->classifications;
                   }
                   #endif
                }
                for (i=0; i < classwords && pcount < part_read; ++i, ++pcount) {
                   int z = r->begin + pcount*r->part_size;
                   #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE
                   int c = part_classdata[0][class_set][i];
                   #else
                   int c = classifications[0][pcount];
                   #endif
                   int b = r->residue_books[c][pass];
                   if (b >= 0) {
                      Codebook *book = f->codebooks + b;
                      if (!codebook_decode_deinterleave_repeat(f, book, residue_buffers, ch, &c_inter, &p_inter, n, r->part_size))
                         goto done;
                   } else {
                      z += r->part_size;
                      c_inter = 0;
                      p_inter = z;
                   }
                }
                #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE
                ++class_set;
                #endif
             }
          } else {
             while (pcount < part_read) {
                int z = r->begin + pcount*r->part_size;
                int c_inter = z % ch, p_inter = z/ch;
                if (pass == 0) {
                   Codebook *c = f->codebooks+r->classbook;
                   int q;
                   DECODE(q,f,c);
                   if (q == EOP) goto done;
                   #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE
                   part_classdata[0][class_set] = r->classdata[q];
                   #else
                   for (i=classwords-1; i >= 0; --i) {
                      classifications[0][i+pcount] = q % r->classifications;
                      q /= r->classifications;
                   }
                   #endif
                }
                for (i=0; i < classwords && pcount < part_read; ++i, ++pcount) {
                   int z = r->begin + pcount*r->part_size;
                   #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE
                   int c = part_classdata[0][class_set][i];
                   #else
                   int c = classifications[0][pcount];
                   #endif
                   int b = r->residue_books[c][pass];
                   if (b >= 0) {
                      Codebook *book = f->codebooks + b;
                      if (!codebook_decode_deinterleave_repeat(f, book, residue_buffers, ch, &c_inter, &p_inter, n, r->part_size))
                         goto done;
                   } else {
                      z += r->part_size;
                      c_inter = z % ch;
                      p_inter = z / ch;
                   }
                }
                #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE
                ++class_set;
                #endif
             }
          }
       }
       goto done;
    }
    CHECK(f);
    for (pass=0; pass < 8; ++pass) {
       int pcount = 0, class_set=0;
       while (pcount < part_read) {
          if (pass == 0) {
             for (j=0; j < ch; ++j) {
                if (!do_not_decode[j]) {
                   Codebook *c = f->codebooks+r->classbook;
                   int temp;
                   DECODE(temp,f,c);
                   if (temp == EOP) goto done;
                   #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE
                   part_classdata[j][class_set] = r->classdata[temp];
                   #else
                   for (i=classwords-1; i >= 0; --i) {
                      classifications[j][i+pcount] = temp % r->classifications;
                      temp /= r->classifications;
                   }
                   #endif
                }
             }
          }
          for (i=0; i < classwords && pcount < part_read; ++i, ++pcount) {
             for (j=0; j < ch; ++j) {
                if (!do_not_decode[j]) {
                   #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE
                   int c = part_classdata[j][class_set][i];
                   #else
                   int c = classifications[j][pcount];
                   #endif
                   int b = r->residue_books[c][pass];
                   if (b >= 0) {
                      float *target = residue_buffers[j];
                      int offset = r->begin + pcount * r->part_size;
                      int n = r->part_size;
                      Codebook *book = f->codebooks + b;
                      if (!residue_decode(f, book, target, offset, n, rtype))
                         goto done;
                   }
                }
             }
          }
          #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE
          ++class_set;
          #endif
       }
    }
   done:
    CHECK(f);
    #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE
    temp_free(f,part_classdata);
    #else
    temp_free(f,classifications);
    #endif
    temp_alloc_restore(f,temp_alloc_point);
 }","[8, 9, 10, 11, 12]","Sean Barrett stb_vorbis version 1.12 and earlier contains a Buffer Overflow vulnerability in All vorbis decoding paths. that can result in memory corruption, denial of service, comprised execution of host program. This attack appear to be exploitable via Victim must open a specially crafted Ogg Vorbis file. This vulnerability appears to have been fixed in 1.13.",stb,CVE-2018-1000050,CWE-119
829,182247," static int tcos_select_file(sc_card_t *card,
 			    const sc_path_t *in_path,
 			    sc_file_t **file_out)
 {
 	sc_context_t *ctx;
 	sc_apdu_t apdu;
 	sc_file_t *file=NULL;
 	u8 buf[SC_MAX_APDU_BUFFER_SIZE], pathbuf[SC_MAX_PATH_SIZE], *path = pathbuf;
 	unsigned int i;
 	int r, pathlen;
 	assert(card != NULL && in_path != NULL);
 	ctx=card->ctx;
 	memcpy(path, in_path->value, in_path->len);
 	pathlen = in_path->len;
 	sc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0, 0x04);
 	switch (in_path->type) {
 	case SC_PATH_TYPE_FILE_ID:
 		if (pathlen != 2) return SC_ERROR_INVALID_ARGUMENTS;
 	case SC_PATH_TYPE_FROM_CURRENT:
 		apdu.p1 = 9;
 		break;
 	case SC_PATH_TYPE_DF_NAME:
 		apdu.p1 = 4;
 		break;
 	case SC_PATH_TYPE_PATH:
 		apdu.p1 = 8;
 		if (pathlen >= 2 && memcmp(path, ""\x3F\x00"", 2) == 0) path += 2, pathlen -= 2;
 		if (pathlen == 0) apdu.p1 = 0;
 		break;
 	case SC_PATH_TYPE_PARENT:
 		apdu.p1 = 3;
 		pathlen = 0;
 		break;
 	default:
 		SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);
 	}
 	if( pathlen == 0 ) apdu.cse = SC_APDU_CASE_2_SHORT;
 	apdu.lc = pathlen;
 	apdu.data = path;
 	apdu.datalen = pathlen;
 	if (file_out != NULL) {
 		apdu.resp = buf;
 		apdu.resplen = sizeof(buf);
 		apdu.le = 256;
 	} else {
 		apdu.resplen = 0;
 		apdu.le = 0; 
 		apdu.p2 = 0x0C; 
 		apdu.cse = (pathlen == 0) ? SC_APDU_CASE_1 : SC_APDU_CASE_3_SHORT;
 	}
 	r = sc_transmit_apdu(card, &apdu);
 	SC_TEST_RET(ctx, SC_LOG_DEBUG_NORMAL, r, ""APDU transmit failed"");
 	r = sc_check_sw(card, apdu.sw1, apdu.sw2);
 	if (r || file_out == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, r);
 	if (apdu.resplen < 1 || apdu.resp[0] != 0x62){
 		sc_debug(ctx, SC_LOG_DEBUG_NORMAL, ""received invalid template %02X\n"", apdu.resp[0]);
 		SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);
 	}
 	file = sc_file_new();
 	if (file == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_OUT_OF_MEMORY);
 	*file_out = file;
  	file->path = *in_path;
  	for(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){
		int j, len=apdu.resp[i+1];
 		size_t j, len=apdu.resp[i+1];
  		unsigned char type=apdu.resp[i], *d=apdu.resp+i+2;
  		switch (type) {
 		case 0x80:
 		case 0x81:
 			file->size=0;
 			for(j=0; j<len; ++j) file->size = (file->size<<8) | d[j];
 			break;
 		case 0x82:
 			file->shareable = (d[0] & 0x40) ? 1 : 0;
 			file->ef_structure = d[0] & 7;
 			switch ((d[0]>>3) & 7) {
 			case 0: file->type = SC_FILE_TYPE_WORKING_EF; break;
 			case 7: file->type = SC_FILE_TYPE_DF; break;
 			default:
 				sc_debug(ctx, SC_LOG_DEBUG_NORMAL, ""invalid file type %02X in file descriptor\n"", d[0]);
 				SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);
 			}
 			break;
 		case 0x83:
  			file->id = (d[0]<<8) | d[1];
  			break;
  		case 0x84:
			memcpy(file->name, d, len);
			file->namelen = len;
 			file->namelen = MIN(sizeof file->name, len);
 			memcpy(file->name, d, file->namelen);
  			break;
  		case 0x86:
  			sc_file_set_sec_attr(file, d, len); 
 			break;
 		default:
 			if (len>0) sc_file_set_prop_attr(file, d, len); 
 		}
 	}
 	file->magic = SC_FILE_MAGIC;
 	parse_sec_attr(card, file, file->sec_attr, file->sec_attr_len);
 	return 0;
 }","[64, 65, 88, 89, 90, 91]",A double free when handling responses from an HSM Card in sc_pkcs15emu_sc_hsm_init in libopensc/pkcs15-sc-hsm.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.,OpenSC,CVE-2018-16425,CWE-415
868,178440," ProcRenderAddGlyphs (ClientPtr client)
 {
     GlyphSetPtr     glyphSet;
     REQUEST(xRenderAddGlyphsReq);
     GlyphNewRec	    glyphsLocal[NLOCALGLYPH];
     GlyphNewPtr	    glyphsBase, glyphs, glyph_new;
     int		    remain, nglyphs;
     CARD32	    *gids;
     xGlyphInfo	    *gi;
     CARD8	    *bits;
     unsigned int    size;
     int		    err;
     int		    i, screen;
     PicturePtr	    pSrc = NULL, pDst = NULL;
     PixmapPtr	    pSrcPix = NULL, pDstPix = NULL;
     CARD32	    component_alpha;
     REQUEST_AT_LEAST_SIZE(xRenderAddGlyphsReq);
     err = dixLookupResourceByType((pointer *)&glyphSet, stuff->glyphset, GlyphSetType,
 			    client, DixAddAccess);
     if (err != Success)
     {
 	client->errorValue = stuff->glyphset;
 	return err;
     }
     err = BadAlloc;
     nglyphs = stuff->nglyphs;
     if (nglyphs > UINT32_MAX / sizeof(GlyphNewRec))
 	    return BadAlloc;
     component_alpha = NeedsComponent (glyphSet->format->format);
     if (nglyphs <= NLOCALGLYPH) {
 	memset (glyphsLocal, 0, sizeof (glyphsLocal));
 	glyphsBase = glyphsLocal;
     }
     else
     {
 	glyphsBase = (GlyphNewPtr)calloc(nglyphs, sizeof (GlyphNewRec));
 	if (!glyphsBase)
 	    return BadAlloc;
     }
     remain = (client->req_len << 2) - sizeof (xRenderAddGlyphsReq);
     glyphs = glyphsBase;
     gids = (CARD32 *) (stuff + 1);
      gi = (xGlyphInfo *) (gids + nglyphs);
      bits = (CARD8 *) (gi + nglyphs);
      remain -= (sizeof (CARD32) + sizeof (xGlyphInfo)) * nglyphs;
     if (gi < stuff || gi > ((CARD32 *)stuff + client->req_len) ||
         bits < stuff || bits > ((CARD32 *)stuff + client->req_len)) {
         err = BadLength;
         goto bail;
     }
      for (i = 0; i < nglyphs; i++)
      {
  	size_t padded_width;
 	size = gi[i].height * padded_width;
 	if (remain < size)
 	    break;
 	err = HashGlyph (&gi[i], bits, size, glyph_new->sha1);
 	if (err)
 	    goto bail;
 	glyph_new->glyph = FindGlyphByHash (glyph_new->sha1,
 					    glyphSet->fdepth);
 	if (glyph_new->glyph && glyph_new->glyph != DeletedGlyph)
 	{
 	    glyph_new->found = TRUE;
 	}
 	else
 	{
 	    GlyphPtr glyph;
 	    glyph_new->found = FALSE;
 	    glyph_new->glyph = glyph = AllocateGlyph (&gi[i], glyphSet->fdepth);
 	    if (! glyph)
 	    {
 		err = BadAlloc;
 		goto bail;
 	    }
 	    for (screen = 0; screen < screenInfo.numScreens; screen++)
 	    {
 		int	    width = gi[i].width;
 		int	    height = gi[i].height;
 		int	    depth = glyphSet->format->depth;
 		ScreenPtr   pScreen;
 		int	    error;
 		if (!width || !height)
 		    break;
 		pScreen = screenInfo.screens[screen];
 		pSrcPix = GetScratchPixmapHeader (pScreen,
 						  width, height,
 						  depth, depth,
 						  -1, bits);
 		if (! pSrcPix)
 		{
 		    err = BadAlloc;
 		    goto bail;
 		}
 		pSrc = CreatePicture (0, &pSrcPix->drawable,
 				      glyphSet->format, 0, NULL,
 				      serverClient, &error);
 		if (! pSrc)
 		{
 		    err = BadAlloc;
 		    goto bail;
 		}
 		pDstPix = (pScreen->CreatePixmap) (pScreen,
 						   width, height, depth,
 						   CREATE_PIXMAP_USAGE_GLYPH_PICTURE);
 		if (!pDstPix)
 		{
 		    err = BadAlloc;
 		    goto bail;
 		}
 		GlyphPicture (glyph)[screen] = pDst =
 			CreatePicture (0, &pDstPix->drawable,
 				       glyphSet->format,
 				       CPComponentAlpha, &component_alpha,
 				       serverClient, &error);
 		(pScreen->DestroyPixmap) (pDstPix);
 		pDstPix = NULL;
 		if (! pDst)
 		{
 		    err = BadAlloc;
 		    goto bail;
 		}
 		CompositePicture (PictOpSrc,
 				  pSrc,
 				  None,
 				  pDst,
 				  0, 0,
 				  0, 0,
 				  0, 0,
 				  width, height);
 		FreePicture ((pointer) pSrc, 0);
 		pSrc = NULL;
 		FreeScratchPixmapHeader (pSrcPix);
 		pSrcPix = NULL;
 	    }
 	    memcpy (glyph_new->glyph->sha1, glyph_new->sha1, 20);
 	}
 	glyph_new->id = gids[i];
 	if (size & 3)
 	    size += 4 - (size & 3);
 	bits += size;
 	remain -= size;
     }
     if (remain || i < nglyphs)
     {
 	err = BadLength;
 	goto bail;
     }
     if (!ResizeGlyphSet (glyphSet, nglyphs))
     {
 	err = BadAlloc;
 	goto bail;
     }
     for (i = 0; i < nglyphs; i++)
 	AddGlyph (glyphSet, glyphs[i].glyph, glyphs[i].id);
     if (glyphsBase != glyphsLocal)
 	free(glyphsBase);
     return Success;
 bail:
     if (pSrc)
 	FreePicture ((pointer) pSrc, 0);
     if (pSrcPix)
 	FreeScratchPixmapHeader (pSrcPix);
     for (i = 0; i < nglyphs; i++)
 	if (glyphs[i].glyph && ! glyphs[i].found)
 	    free(glyphs[i].glyph);
     if (glyphsBase != glyphsLocal)
 	free(glyphsBase);
     return err;
 }","[46, 47, 48, 49, 50]","The ProcRenderAddGlyphs function in the Render extension (render/render.c) in X.Org xserver 1.7.7 and earlier allows local users to read arbitrary memory and possibly cause a denial of service (server crash) via unspecified vectors related to an ""input sanitization flaw.""",xserver,CVE-2010-4819,CWE-20
890,179175," static int filter_frame(AVFilterLink *inlink, AVFrame *inpic)
 {
     KerndeintContext *kerndeint = inlink->dst->priv;
     AVFilterLink *outlink = inlink->dst->outputs[0];
     AVFrame *outpic;
     const uint8_t *prvp;    
     const uint8_t *prvpp;   
     const uint8_t *prvpn;   
     const uint8_t *prvppp;  
     const uint8_t *prvpnn;  
     const uint8_t *prvp4p;  
     const uint8_t *prvp4n;  
     const uint8_t *srcp;    
     const uint8_t *srcpp;   
     const uint8_t *srcpn;   
     const uint8_t *srcppp;  
     const uint8_t *srcpnn;  
     const uint8_t *srcp3p;  
     const uint8_t *srcp3n;  
     const uint8_t *srcp4p;  
     const uint8_t *srcp4n;  
     uint8_t *dstp, *dstp_saved;
     const uint8_t *srcp_saved;
     int src_linesize, psrc_linesize, dst_linesize, bwidth;
     int x, y, plane, val, hi, lo, g, h, n = kerndeint->frame++;
     double valf;
     const int thresh = kerndeint->thresh;
     const int order  = kerndeint->order;
     const int map    = kerndeint->map;
     const int sharp  = kerndeint->sharp;
     const int twoway = kerndeint->twoway;
     const int is_packed_rgb = kerndeint->is_packed_rgb;
     outpic = ff_get_video_buffer(outlink, outlink->w, outlink->h);
     if (!outpic) {
         av_frame_free(&inpic);
         return AVERROR(ENOMEM);
     }
      av_frame_copy_props(outpic, inpic);
      outpic->interlaced_frame = 0;
    for (plane = 0; inpic->data[plane] && plane < 4; plane++) {
     for (plane = 0; plane < 4 && inpic->data[plane] && inpic->linesize[plane]; plane++) {
          h = plane == 0 ? inlink->h : FF_CEIL_RSHIFT(inlink->h, kerndeint->vsub);
          bwidth = kerndeint->tmp_bwidth[plane];
         srcp = srcp_saved = inpic->data[plane];
         src_linesize      = inpic->linesize[plane];
         psrc_linesize     = kerndeint->tmp_linesize[plane];
         dstp = dstp_saved = outpic->data[plane];
         dst_linesize      = outpic->linesize[plane];
         srcp              = srcp_saved + (1 - order) * src_linesize;
         dstp              = dstp_saved + (1 - order) * dst_linesize;
         for (y = 0; y < h; y += 2) {
             memcpy(dstp, srcp, bwidth);
             srcp += 2 * src_linesize;
             dstp += 2 * dst_linesize;
         }
         memcpy(dstp_saved + order            * dst_linesize, srcp_saved + (1 -     order) * src_linesize, bwidth);
         memcpy(dstp_saved + (2 + order    )  * dst_linesize, srcp_saved + (3 -     order) * src_linesize, bwidth);
         memcpy(dstp_saved + (h - 2 + order)  * dst_linesize, srcp_saved + (h - 1 - order) * src_linesize, bwidth);
         memcpy(dstp_saved + (h - 4 + order)  * dst_linesize, srcp_saved + (h - 3 - order) * src_linesize, bwidth);
         prvp   = kerndeint->tmp_data[plane] + 5 * psrc_linesize - (1 - order) * psrc_linesize;
         prvpp  = prvp - psrc_linesize;
         prvppp = prvp - 2 * psrc_linesize;
         prvp4p = prvp - 4 * psrc_linesize;
         prvpn  = prvp + psrc_linesize;
         prvpnn = prvp + 2 * psrc_linesize;
         prvp4n = prvp + 4 * psrc_linesize;
         srcp   = srcp_saved + 5 * src_linesize - (1 - order) * src_linesize;
         srcpp  = srcp - src_linesize;
         srcppp = srcp - 2 * src_linesize;
         srcp3p = srcp - 3 * src_linesize;
         srcp4p = srcp - 4 * src_linesize;
         srcpn  = srcp + src_linesize;
         srcpnn = srcp + 2 * src_linesize;
         srcp3n = srcp + 3 * src_linesize;
         srcp4n = srcp + 4 * src_linesize;
         dstp   = dstp_saved + 5 * dst_linesize - (1 - order) * dst_linesize;
         for (y = 5 - (1 - order); y <= h - 5 - (1 - order); y += 2) {
             for (x = 0; x < bwidth; x++) {
                 if (thresh == 0 || n == 0 ||
                     (abs((int)prvp[x]  - (int)srcp[x])  > thresh) ||
                     (abs((int)prvpp[x] - (int)srcpp[x]) > thresh) ||
                     (abs((int)prvpn[x] - (int)srcpn[x]) > thresh)) {
                     if (map) {
                         g = x & ~3;
                         if (is_packed_rgb) {
                             AV_WB32(dstp + g, 0xffffffff);
                             x = g + 3;
                         } else if (inlink->format == AV_PIX_FMT_YUYV422) {
                             AV_WB32(dstp + g, 0xeb80eb80);
                             x = g + 3;
                         } else {
                             dstp[x] = plane == 0 ? 235 : 128;
                         }
                     } else {
                         if (is_packed_rgb) {
                             hi = 255;
                             lo = 0;
                         } else if (inlink->format == AV_PIX_FMT_YUYV422) {
                             hi = x & 1 ? 240 : 235;
                             lo = 16;
                         } else {
                             hi = plane == 0 ? 235 : 240;
                             lo = 16;
                         }
                         if (sharp) {
                             if (twoway) {
                                 valf = + 0.526 * ((int)srcpp[x] + (int)srcpn[x])
                                     + 0.170 * ((int)srcp[x] + (int)prvp[x])
                                     - 0.116 * ((int)srcppp[x] + (int)srcpnn[x] + (int)prvppp[x] + (int)prvpnn[x])
                                     - 0.026 * ((int)srcp3p[x] + (int)srcp3n[x])
                                     + 0.031 * ((int)srcp4p[x] + (int)srcp4n[x] + (int)prvp4p[x] + (int)prvp4n[x]);
                             } else {
                                 valf = + 0.526 * ((int)srcpp[x] + (int)srcpn[x])
                                     + 0.170 * ((int)prvp[x])
                                     - 0.116 * ((int)prvppp[x] + (int)prvpnn[x])
                                     - 0.026 * ((int)srcp3p[x] + (int)srcp3n[x])
                                     + 0.031 * ((int)prvp4p[x] + (int)prvp4p[x]);
                             }
                             dstp[x] = av_clip(valf, lo, hi);
                         } else {
                             if (twoway) {
                                 val = (8 * ((int)srcpp[x] + (int)srcpn[x]) + 2 * ((int)srcp[x] + (int)prvp[x])
                                        - (int)(srcppp[x]) - (int)(srcpnn[x])
                                        - (int)(prvppp[x]) - (int)(prvpnn[x])) >> 4;
                             } else {
                                 val = (8 * ((int)srcpp[x] + (int)srcpn[x]) + 2 * ((int)prvp[x])
                                        - (int)(prvppp[x]) - (int)(prvpnn[x])) >> 4;
                             }
                             dstp[x] = av_clip(val, lo, hi);
                         }
                     }
                 } else {
                     dstp[x] = srcp[x];
                 }
             }
             prvp   += 2 * psrc_linesize;
             prvpp  += 2 * psrc_linesize;
             prvppp += 2 * psrc_linesize;
             prvpn  += 2 * psrc_linesize;
             prvpnn += 2 * psrc_linesize;
             prvp4p += 2 * psrc_linesize;
             prvp4n += 2 * psrc_linesize;
             srcp   += 2 * src_linesize;
             srcpp  += 2 * src_linesize;
             srcppp += 2 * src_linesize;
             srcp3p += 2 * src_linesize;
             srcp4p += 2 * src_linesize;
             srcpn  += 2 * src_linesize;
             srcpnn += 2 * src_linesize;
             srcp3n += 2 * src_linesize;
             srcp4n += 2 * src_linesize;
             dstp   += 2 * dst_linesize;
         }
         srcp = inpic->data[plane];
         dstp = kerndeint->tmp_data[plane];
         av_image_copy_plane(dstp, psrc_linesize, srcp, src_linesize, bwidth, h);
     }
     av_frame_free(&inpic);
     return ff_filter_frame(outlink, outpic);
 }","[40, 41]","libavfilter in FFmpeg before 2.0.1 has unspecified impact and remote vectors related to a crafted *plane,* which triggers an out-of-bounds heap write.",FFmpeg,CVE-2013-4263,CWE-119
901,179637," DecodeTime(char *str, int *tmask, struct tm * tm, fsec_t *fsec)
 {
 	char	   *cp;
 	*tmask = DTK_TIME_M;
 	tm->tm_hour = strtol(str, &cp, 10);
 	if (*cp != ':')
 		return -1;
 	str = cp + 1;
 	tm->tm_min = strtol(str, &cp, 10);
 	if (*cp == '\0')
 	{
 		tm->tm_sec = 0;
 		*fsec = 0;
 	}
 	else if (*cp != ':')
 		return -1;
 	else
 	{
 		str = cp + 1;
 		tm->tm_sec = strtol(str, &cp, 10);
 		if (*cp == '\0')
 			*fsec = 0;
  		else if (*cp == '.')
  		{
  #ifdef HAVE_INT64_TIMESTAMP
			char		fstr[MAXDATELEN + 1];
 			char		fstr[7];
 			int			i;
 			cp++;
			strncpy(fstr, (cp + 1), 7);
			strcpy(fstr + strlen(fstr), ""000000"");
			*(fstr + 6) = '\0';
 			for (i = 0; i < 6; i++)
 				fstr[i] = *cp != '\0' ? *cp++ : '0';
 			fstr[i] = '\0';
  			*fsec = strtol(fstr, &cp, 10);
  #else
  			str = cp;
 			*fsec = strtod(str, &cp);
 #endif
 			if (*cp != '\0')
 				return -1;
 		}
 		else
 			return -1;
 	}
 #ifdef HAVE_INT64_TIMESTAMP
 	if (tm->tm_hour < 0 || tm->tm_min < 0 || tm->tm_min > 59 ||
 		tm->tm_sec < 0 || tm->tm_sec > 59 || *fsec >= USECS_PER_SEC)
 		return -1;
 #else
 	if (tm->tm_hour < 0 || tm->tm_min < 0 || tm->tm_min > 59 ||
 		tm->tm_sec < 0 || tm->tm_sec > 59 || *fsec >= 1)
 		return -1;
 #endif
 	return 0;
 }	 ","[26, 27, 28, 29, 30, 31, 32, 33, 34, 35]","Multiple stack-based buffer overflows in PostgreSQL before 8.4.20, 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to cause a denial of service (crash) or possibly execute arbitrary code via vectors related to an incorrect MAXDATELEN constant and datetime values involving (1) intervals, (2) timestamps, or (3) timezones, a different vulnerability than CVE-2014-0065.",postgres,CVE-2014-0063,CWE-119
902,182846," ZSTD_encodeSequences_body(
             void* dst, size_t dstCapacity,
             FSE_CTable const* CTable_MatchLength, BYTE const* mlCodeTable,
             FSE_CTable const* CTable_OffsetBits, BYTE const* ofCodeTable,
             FSE_CTable const* CTable_LitLength, BYTE const* llCodeTable,
             seqDef const* sequences, size_t nbSeq, int longOffsets)
 {
     BIT_CStream_t blockStream;
     FSE_CState_t  stateMatchLength;
     FSE_CState_t  stateOffsetBits;
      FSE_CState_t  stateLitLength;
      CHECK_E(BIT_initCStream(&blockStream, dst, dstCapacity), dstSize_tooSmall);  
     DEBUGLOG(6, ""available space for bitstream : %i  (dstCapacity=%u)"",
                 (int)(blockStream.endPtr - blockStream.startPtr),
                 (unsigned)dstCapacity);
      FSE_initCState2(&stateMatchLength, CTable_MatchLength, mlCodeTable[nbSeq-1]);
     FSE_initCState2(&stateOffsetBits,  CTable_OffsetBits,  ofCodeTable[nbSeq-1]);
     FSE_initCState2(&stateLitLength,   CTable_LitLength,   llCodeTable[nbSeq-1]);
     BIT_addBits(&blockStream, sequences[nbSeq-1].litLength, LL_bits[llCodeTable[nbSeq-1]]);
     if (MEM_32bits()) BIT_flushBits(&blockStream);
     BIT_addBits(&blockStream, sequences[nbSeq-1].matchLength, ML_bits[mlCodeTable[nbSeq-1]]);
     if (MEM_32bits()) BIT_flushBits(&blockStream);
     if (longOffsets) {
         U32 const ofBits = ofCodeTable[nbSeq-1];
         int const extraBits = ofBits - MIN(ofBits, STREAM_ACCUMULATOR_MIN-1);
         if (extraBits) {
             BIT_addBits(&blockStream, sequences[nbSeq-1].offset, extraBits);
             BIT_flushBits(&blockStream);
         }
         BIT_addBits(&blockStream, sequences[nbSeq-1].offset >> extraBits,
                     ofBits - extraBits);
     } else {
         BIT_addBits(&blockStream, sequences[nbSeq-1].offset, ofCodeTable[nbSeq-1]);
     }
     BIT_flushBits(&blockStream);
     {   size_t n;
         for (n=nbSeq-2 ; n<nbSeq ; n--) {       
             BYTE const llCode = llCodeTable[n];
             BYTE const ofCode = ofCodeTable[n];
             BYTE const mlCode = mlCodeTable[n];
             U32  const llBits = LL_bits[llCode];
             U32  const ofBits = ofCode;
             U32  const mlBits = ML_bits[mlCode];
             DEBUGLOG(6, ""encoding: litlen:%2u - matchlen:%2u - offCode:%7u"",
                         sequences[n].litLength,
                         sequences[n].matchLength + MINMATCH,
                         sequences[n].offset);
             FSE_encodeSymbol(&blockStream, &stateOffsetBits, ofCode);           
             FSE_encodeSymbol(&blockStream, &stateMatchLength, mlCode);          
             if (MEM_32bits()) BIT_flushBits(&blockStream);                   
             FSE_encodeSymbol(&blockStream, &stateLitLength, llCode);            
             if (MEM_32bits() || (ofBits+mlBits+llBits >= 64-7-(LLFSELog+MLFSELog+OffFSELog)))
                 BIT_flushBits(&blockStream);                                 
             BIT_addBits(&blockStream, sequences[n].litLength, llBits);
             if (MEM_32bits() && ((llBits+mlBits)>24)) BIT_flushBits(&blockStream);
             BIT_addBits(&blockStream, sequences[n].matchLength, mlBits);
             if (MEM_32bits() || (ofBits+mlBits+llBits > 56)) BIT_flushBits(&blockStream);
             if (longOffsets) {
                 int const extraBits = ofBits - MIN(ofBits, STREAM_ACCUMULATOR_MIN-1);
                 if (extraBits) {
                     BIT_addBits(&blockStream, sequences[n].offset, extraBits);
                     BIT_flushBits(&blockStream);                             
                 }
                 BIT_addBits(&blockStream, sequences[n].offset >> extraBits,
                             ofBits - extraBits);                             
             } else {
                  BIT_addBits(&blockStream, sequences[n].offset, ofBits);      
              }
              BIT_flushBits(&blockStream);                                     
             DEBUGLOG(7, ""remaining space : %i"", (int)(blockStream.endPtr - blockStream.ptr));
      }   }
      DEBUGLOG(6, ""ZSTD_encodeSequences: flushing ML state with %u bits"", stateMatchLength.stateLog);
     FSE_flushCState(&blockStream, &stateMatchLength);
     DEBUGLOG(6, ""ZSTD_encodeSequences: flushing Off state with %u bits"", stateOffsetBits.stateLog);
     FSE_flushCState(&blockStream, &stateOffsetBits);
     DEBUGLOG(6, ""ZSTD_encodeSequences: flushing LL state with %u bits"", stateLitLength.stateLog);
     FSE_flushCState(&blockStream, &stateLitLength);
     {   size_t const streamSize = BIT_closeCStream(&blockStream);
         if (streamSize==0) return ERROR(dstSize_tooSmall);    
         return streamSize;
     }
 }","[13, 14, 15, 70]",A race condition in the one-pass compression functions of Zstandard prior to version 1.3.8 could allow an attacker to write bytes out of bounds if an output buffer smaller than the recommended size was used.,zstd,CVE-2019-11922,CWE-362
913,181872,"  void jas_matrix_clip(jas_matrix_t *matrix, jas_seqent_t minval,
    jas_seqent_t maxval)
  {
	int i;
	int j;
 	jas_matind_t i;
 	jas_matind_t j;
  	jas_seqent_t v;
  	jas_seqent_t *rowstart;
  	jas_seqent_t *data;
	int rowstep;
 	jas_matind_t rowstep;
  	if (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {
  		assert(matrix->rows_);
 		rowstep = jas_matrix_rowstep(matrix);
 		for (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,
 		  rowstart += rowstep) {
 			data = rowstart;
 			for (j = matrix->numcols_, data = rowstart; j > 0; --j,
 			  ++data) {
 				v = *data;
 				if (v < minval) {
 					*data = minval;
 				} else if (v > maxval) {
 					*data = maxval;
 				}
 			}
 		}
 	}
 }","[4, 5, 6, 7, 11, 12]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
932,181648," jas_matrix_t *jas_matrix_create(int numrows, int numcols)
  {
  	jas_matrix_t *matrix;
  	int i;
 	size_t size;
 	matrix = 0;
  	if (numrows < 0 || numcols < 0) {
		return 0;
 		goto error;
  	}
  	if (!(matrix = jas_malloc(sizeof(jas_matrix_t)))) {
		return 0;
 		goto error;
  	}
  	matrix->flags_ = 0;
  	matrix->numrows_ = numrows;
  	matrix->numcols_ = numcols;
  	matrix->rows_ = 0;
  	matrix->maxrows_ = numrows;
  	matrix->data_ = 0;
	matrix->datasize_ = numrows * numcols;
 	matrix->datasize_ = 0;
 	if (!jas_safe_size_mul(numrows, numcols, &size)) {
 		goto error;
 	}
 	matrix->datasize_ = size;
  	if (matrix->maxrows_ > 0) {
  		if (!(matrix->rows_ = jas_alloc2(matrix->maxrows_,
  		  sizeof(jas_seqent_t *)))) {
			jas_matrix_destroy(matrix);
			return 0;
 			goto error;
  		}
  	}
  	if (matrix->datasize_ > 0) {
  		if (!(matrix->data_ = jas_alloc2(matrix->datasize_,
  		  sizeof(jas_seqent_t)))) {
			jas_matrix_destroy(matrix);
			return 0;
 			goto error;
  		}
  	}
 	for (i = 0; i < numrows; ++i) {
 		matrix->rows_[i] = &matrix->data_[i * matrix->numcols_];
 	}
 	for (i = 0; i < matrix->datasize_; ++i) {
 		matrix->data_[i] = 0;
 	}
 	matrix->xstart_ = 0;
 	matrix->ystart_ = 0;
 	matrix->xend_ = matrix->numcols_;
  	matrix->yend_ = matrix->numrows_;
  	return matrix;
 error:
 	if (matrix) {
 		jas_matrix_destroy(matrix);
 	}
 	return 0;
  }","[5, 6, 8, 9, 12, 13, 21, 22, 23, 24, 25, 26, 30, 31, 32, 38, 39, 40, 54, 55, 56, 57, 58]","Integer overflow in the jpc_dec_tiledecode function in jpc_dec.c in JasPer before 1.900.12 allows remote attackers to have unspecified impact via a crafted image file, which triggers a heap-based buffer overflow.",jasper,CVE-2016-10249,CWE-190
940,181893,"  static int jpg_dec_parseopts(char *optstr, jpg_dec_importopts_t *opts)
  {
  	jas_tvparser_t *tvp;
	opts->max_size = 0;
 	opts->max_samples = 64 * JAS_MEBI;
  	if (!(tvp = jas_tvparser_create(optstr ? optstr : """"))) {
  		return -1;
 	}
 	while (!jas_tvparser_next(tvp)) {
  		switch (jas_taginfo_nonull(jas_taginfos_lookup(decopts,
  		  jas_tvparser_gettag(tvp)))->id) {
  		case OPT_MAXSIZE:
			opts->max_size = atoi(jas_tvparser_getval(tvp));
 			opts->max_samples = atoi(jas_tvparser_getval(tvp));
  			break;
  		default:
  			jas_eprintf(""warning: ignoring invalid option %s\n"",
 			  jas_tvparser_gettag(tvp));
 			break;
 		}
 	}
 	jas_tvparser_destroy(tvp);
 	return 0;
 }","[4, 5, 13, 14]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
941,178116," int vrend_create_vertex_elements_state(struct vrend_context *ctx,
                                        uint32_t handle,
                                         unsigned num_elements,
                                         const struct pipe_vertex_element *elements)
  {
   struct vrend_vertex_element_array *v = CALLOC_STRUCT(vrend_vertex_element_array);
    struct vrend_vertex_element_array *v;
     const struct util_format_description *desc;
     GLenum type;
     int i;
     uint32_t ret_handle;
   if (!v)
      return ENOMEM;
     if (num_elements > PIPE_MAX_ATTRIBS)
        return EINVAL;
    v = CALLOC_STRUCT(vrend_vertex_element_array);
    if (!v)
       return ENOMEM;
     v->count = num_elements;
     for (i = 0; i < num_elements; i++) {
        memcpy(&v->elements[i].base, &elements[i], sizeof(struct pipe_vertex_element));
       desc = util_format_description(elements[i].src_format);
       if (!desc) {
          FREE(v);
          return EINVAL;
       }
       type = GL_FALSE;
       if (desc->channel[0].type == UTIL_FORMAT_TYPE_FLOAT) {
          if (desc->channel[0].size == 32)
             type = GL_FLOAT;
          else if (desc->channel[0].size == 64)
             type = GL_DOUBLE;
          else if (desc->channel[0].size == 16)
             type = GL_HALF_FLOAT;
       } else if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED &&
                  desc->channel[0].size == 8)
          type = GL_UNSIGNED_BYTE;
       else if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED &&
                desc->channel[0].size == 8)
          type = GL_BYTE;
       else if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED &&
                desc->channel[0].size == 16)
          type = GL_UNSIGNED_SHORT;
       else if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED &&
                desc->channel[0].size == 16)
          type = GL_SHORT;
       else if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED &&
                desc->channel[0].size == 32)
          type = GL_UNSIGNED_INT;
       else if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED &&
                desc->channel[0].size == 32)
          type = GL_INT;
       else if (elements[i].src_format == PIPE_FORMAT_R10G10B10A2_SSCALED ||
                elements[i].src_format == PIPE_FORMAT_R10G10B10A2_SNORM ||
                elements[i].src_format == PIPE_FORMAT_B10G10R10A2_SNORM)
          type = GL_INT_2_10_10_10_REV;
       else if (elements[i].src_format == PIPE_FORMAT_R10G10B10A2_USCALED ||
                elements[i].src_format == PIPE_FORMAT_R10G10B10A2_UNORM ||
                elements[i].src_format == PIPE_FORMAT_B10G10R10A2_UNORM)
          type = GL_UNSIGNED_INT_2_10_10_10_REV;
       else if (elements[i].src_format == PIPE_FORMAT_R11G11B10_FLOAT)
          type = GL_UNSIGNED_INT_10F_11F_11F_REV;
       if (type == GL_FALSE) {
          report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_VERTEX_FORMAT, elements[i].src_format);
          FREE(v);
          return EINVAL;
       }
       v->elements[i].type = type;
       if (desc->channel[0].normalized)
          v->elements[i].norm = GL_TRUE;
       if (desc->nr_channels == 4 && desc->swizzle[0] == UTIL_FORMAT_SWIZZLE_Z)
          v->elements[i].nr_chan = GL_BGRA;
       else if (elements[i].src_format == PIPE_FORMAT_R11G11B10_FLOAT)
          v->elements[i].nr_chan = 3;
       else
          v->elements[i].nr_chan = desc->nr_channels;
    }
    if (vrend_state.have_vertex_attrib_binding) {
       glGenVertexArrays(1, &v->id);
       glBindVertexArray(v->id);
       for (i = 0; i < num_elements; i++) {
          struct vrend_vertex_element *ve = &v->elements[i];
          if (util_format_is_pure_integer(ve->base.src_format))
             glVertexAttribIFormat(i, ve->nr_chan, ve->type, ve->base.src_offset);
          else
             glVertexAttribFormat(i, ve->nr_chan, ve->type, ve->norm, ve->base.src_offset);
          glVertexAttribBinding(i, ve->base.vertex_buffer_index);
          glVertexBindingDivisor(i, ve->base.instance_divisor);
          glEnableVertexAttribArray(i);
       }
    }
    ret_handle = vrend_renderer_object_insert(ctx, v, sizeof(struct vrend_vertex_element), handle,
                                              VIRGL_OBJECT_VERTEX_ELEMENTS);
    if (!ret_handle) {
       FREE(v);
       return ENOMEM;
    }
    return 0;
 }","[6, 7, 12, 13, 16, 17, 18]",Memory leak in the vrend_create_vertex_elements_state function in vrend_renderer.c in virglrenderer allows local guest OS users to cause a denial of service (host memory consumption) via a large number of VIRGL_OBJECT_VERTEX_ELEMENTS commands.,virglrenderer,CVE-2017-6386,CWE-772
948,179174," static int filter_frame(AVFilterLink *inlink, AVFrame *in)
 {
     AVFilterContext *ctx  = inlink->dst;
     FlipContext *s     = ctx->priv;
     AVFilterLink *outlink = ctx->outputs[0];
     AVFrame *out;
     uint8_t *inrow, *outrow;
     int i, j, plane, step;
     out = ff_get_video_buffer(outlink, outlink->w, outlink->h);
     if (!out) {
         av_frame_free(&in);
         return AVERROR(ENOMEM);
     }
     av_frame_copy_props(out, in);
      if (av_pix_fmt_desc_get(inlink->format)->flags & AV_PIX_FMT_FLAG_PAL)
          memcpy(out->data[1], in->data[1], AVPALETTE_SIZE);
    for (plane = 0; plane < 4 && in->data[plane]; plane++) {
     for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++) {
          const int width  = (plane == 1 || plane == 2) ? FF_CEIL_RSHIFT(inlink->w, s->hsub) : inlink->w;
          const int height = (plane == 1 || plane == 2) ? FF_CEIL_RSHIFT(inlink->h, s->vsub) : inlink->h;
          step = s->max_step[plane];
         outrow = out->data[plane];
         inrow  = in ->data[plane] + (width - 1) * step;
         for (i = 0; i < height; i++) {
             switch (step) {
             case 1:
                 for (j = 0; j < width; j++)
                     outrow[j] = inrow[-j];
             break;
             case 2:
             {
                 uint16_t *outrow16 = (uint16_t *)outrow;
                 uint16_t * inrow16 = (uint16_t *) inrow;
                 for (j = 0; j < width; j++)
                     outrow16[j] = inrow16[-j];
             }
             break;
             case 3:
             {
                 uint8_t *in  =  inrow;
                 uint8_t *out = outrow;
                 for (j = 0; j < width; j++, out += 3, in -= 3) {
                     int32_t v = AV_RB24(in);
                     AV_WB24(out, v);
                 }
             }
             break;
             case 4:
             {
                 uint32_t *outrow32 = (uint32_t *)outrow;
                 uint32_t * inrow32 = (uint32_t *) inrow;
                 for (j = 0; j < width; j++)
                     outrow32[j] = inrow32[-j];
             }
             break;
             default:
                 for (j = 0; j < width; j++)
                     memcpy(outrow + j*step, inrow - j*step, step);
             }
             inrow  += in ->linesize[plane];
             outrow += out->linesize[plane];
         }
     }
     av_frame_free(&in);
     return ff_filter_frame(outlink, out);
 }","[17, 18]","libavfilter in FFmpeg before 2.0.1 has unspecified impact and remote vectors related to a crafted *plane,* which triggers an out-of-bounds heap write.",FFmpeg,CVE-2013-4263,CWE-119
955,182096," static int rm_read_multi(AVFormatContext *s, AVIOContext *pb,
                          AVStream *st, char *mime)
 {
     int number_of_streams = avio_rb16(pb);
     int number_of_mdpr;
     int i, ret;
     unsigned size2;
     for (i = 0; i<number_of_streams; i++)
         avio_rb16(pb);
     number_of_mdpr = avio_rb16(pb);
     if (number_of_mdpr != 1) {
         avpriv_request_sample(s, ""MLTI with multiple (%d) MDPR"", number_of_mdpr);
     }
     for (i = 0; i < number_of_mdpr; i++) {
         AVStream *st2;
         if (i > 0) {
             st2 = avformat_new_stream(s, NULL);
             if (!st2) {
                 ret = AVERROR(ENOMEM);
                 return ret;
             }
             st2->id = st->id + (i<<16);
             st2->codecpar->bit_rate = st->codecpar->bit_rate;
             st2->start_time = st->start_time;
             st2->duration   = st->duration;
             st2->codecpar->codec_type = AVMEDIA_TYPE_DATA;
             st2->priv_data = ff_rm_alloc_rmstream();
             if (!st2->priv_data)
                 return AVERROR(ENOMEM);
         } else
             st2 = st;
          size2 = avio_rb32(pb);
          ret = ff_rm_read_mdpr_codecdata(s, s->pb, st2, st2->priv_data,
                                        size2, mime);
                                         size2, NULL);
          if (ret < 0)
              return ret;
      }
     return 0;
 }","[34, 35]",FFmpeg before commit a7e032a277452366771951e29fd0bf2bd5c029f0 contains a use-after-free vulnerability in the realmedia demuxer that can result in vulnerability allows attacker to read heap memory. This attack appear to be exploitable via specially crafted RM file has to be provided as input. This vulnerability appears to have been fixed in a7e032a277452366771951e29fd0bf2bd5c029f0 and later.,FFmpeg,CVE-2018-1999013,CWE-416
979,178051," void CtcpHandler::handleTime(CtcpType ctcptype, const QString &prefix, const QString &target, const QString &param) {
 void CtcpHandler::handleTime(CtcpType ctcptype, const QString &prefix, const QString &target, const QString &param, QString &reply) {
    Q_UNUSED(target)
    if(ctcptype == CtcpQuery) {
    if(_ignoreListManager->ctcpMatch(prefix, network()->networkName(), ""TIME""))
      return;
    reply(nickFromMask(prefix), ""TIME"", QDateTime::currentDateTime().toString());
     reply = QDateTime::currentDateTime().toString();
      emit displayMsg(Message::Server, BufferInfo::StatusBuffer, """", tr(""Received CTCP TIME request by %1"").arg(prefix));
  }
  else {
   } else {
      emit displayMsg(Message::Server, BufferInfo::StatusBuffer, """", tr(""Received CTCP TIME answer from %1: %2"")
                      .arg(nickFromMask(prefix)).arg(param));
    }
  }","[2, 5, 6, 7, 8, 10, 11, 12]",ctcphandler.cpp in Quassel before 0.6.3 and 0.7.x before 0.7.1 allows remote attackers to cause a denial of service (unresponsive IRC) via multiple Client-To-Client Protocol (CTCP) requests in a PRIVMSG message.,quassel,CVE-2010-3443,CWE-399
998,182419," static int DecodeGifImg(struct ngiflib_img * i) {
 	struct ngiflib_decode_context context;
 	long npix;
 	u8 * stackp;
 	u8 * stack_top;
 	u16 clr;
 	u16 eof;
 	u16 free;
 	u16 act_code = 0;
 	u16 old_code = 0;
 	u16 read_byt;
 	u16 ab_prfx[4096];
 	u8 ab_suffx[4096];
 	u8 ab_stack[4096];
 	u8 flags;
 	u8 casspecial = 0;
 	if(!i) return -1;
 	i->posX = GetWord(i->parent);	 
 	i->posY = GetWord(i->parent);	 
  	i->width = GetWord(i->parent);	 
  	i->height = GetWord(i->parent);	 
 	if((i->width > i->parent->width) || (i->height > i->parent->height)) {
 #if !defined(NGIFLIB_NO_FILE)
 		if(i->parent->log) fprintf(i->parent->log, ""*** ERROR *** Image bigger than global GIF canvas !\n"");
 #endif
 		return -1;
 	}
 	if((i->posX + i->width) > i->parent->width) {
 #if !defined(NGIFLIB_NO_FILE)
 		if(i->parent->log) fprintf(i->parent->log, ""*** WARNING *** Adjusting X position\n"");
 #endif
 		i->posX = i->parent->width - i->width;
 	}
 	if((i->posY + i->height) > i->parent->height) {
 #if !defined(NGIFLIB_NO_FILE)
 		if(i->parent->log) fprintf(i->parent->log, ""*** WARNING *** Adjusting Y position\n"");
 #endif
 		i->posY = i->parent->height - i->height;
 	}
  	context.Xtogo = i->width;
  	context.curY = i->posY;
  #ifdef NGIFLIB_INDEXED_ONLY
 	#ifdef NGIFLIB_ENABLE_CALLBACKS
 	context.line_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width;
 	context.frbuff_p.p8 = context.line_p.p8 + i->posX;
 	#else
 	context.frbuff_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width + i->posX;
 	#endif  
 #else
 	if(i->parent->mode & NGIFLIB_MODE_INDEXED) {
 		#ifdef NGIFLIB_ENABLE_CALLBACKS
 		context.line_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width;
 		context.frbuff_p.p8 = context.line_p.p8 + i->posX;
 		#else
 		context.frbuff_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width + i->posX;
 		#endif  
 	} else {
 		#ifdef NGIFLIB_ENABLE_CALLBACKS
 		context.line_p.p32 = i->parent->frbuff.p32 + (u32)i->posY*i->parent->width;
 		context.frbuff_p.p32 = context.line_p.p32 + i->posX;
 		#else
 		context.frbuff_p.p32 = i->parent->frbuff.p32 + (u32)i->posY*i->parent->width + i->posX;
 		#endif  
 	}
 #endif  
 	npix = (long)i->width * i->height;
 	flags = GetByte(i->parent);
 	i->interlaced = (flags & 64) >> 6;
 	context.pass = i->interlaced ? 1 : 0;
 	i->sort_flag = (flags & 32) >> 5;	 
 	i->localpalbits = (flags & 7) + 1;
 	if(flags&128) {  
 		int k;
 		int localpalsize = 1 << i->localpalbits;
 #if !defined(NGIFLIB_NO_FILE)
 		if(i->parent && i->parent->log) fprintf(i->parent->log, ""Local palette\n"");
 #endif  
 		i->palette = (struct ngiflib_rgb *)ngiflib_malloc(sizeof(struct ngiflib_rgb)*localpalsize);
 		for(k=0; k<localpalsize; k++) {
 			i->palette[k].r = GetByte(i->parent);
 			i->palette[k].g = GetByte(i->parent);
 			i->palette[k].b = GetByte(i->parent);
 		}
 #ifdef NGIFLIB_ENABLE_CALLBACKS
 		if(i->parent->palette_cb) i->parent->palette_cb(i->parent, i->palette, localpalsize);
 #endif  
 	} else {
 		i->palette = i->parent->palette;
 		i->localpalbits = i->parent->imgbits;
 	}
 	i->ncolors = 1 << i->localpalbits;
 	i->imgbits = GetByte(i->parent);	 
 #if !defined(NGIFLIB_NO_FILE)
 	if(i->parent && i->parent->log) {
 		if(i->interlaced) fprintf(i->parent->log, ""interlaced "");
 		fprintf(i->parent->log, ""img pos(%hu,%hu) size %hux%hu palbits=%hhu imgbits=%hhu ncolors=%hu\n"",
 	       i->posX, i->posY, i->width, i->height, i->localpalbits, i->imgbits, i->ncolors);
 	}
 #endif  
 	if(i->imgbits==1) {	 
 		i->imgbits = 2;
 	}
 	clr = 1 << i->imgbits;
 	eof = clr + 1;
 	free = clr + 2;
 	context.nbbit = i->imgbits + 1;
 	context.max = clr + clr - 1;  
 	stackp = stack_top = ab_stack + 4096;
 	context.restbits = 0;	 
 	context.restbyte = 0;	 
 	context.lbyte = 0;
 	for(;;) {
 		act_code = GetGifWord(i, &context);
 		if(act_code==eof) {
 #if !defined(NGIFLIB_NO_FILE)
 			if(i->parent && i->parent->log) fprintf(i->parent->log, ""End of image code\n"");
 #endif  
 			return 0;
 		}
 		if(npix==0) {
 #if !defined(NGIFLIB_NO_FILE)
 			if(i->parent && i->parent->log) fprintf(i->parent->log, ""assez de pixels, On se casse !\n"");
 #endif  
 			return 1;
 		}	
 		if(act_code==clr) {
 #if !defined(NGIFLIB_NO_FILE)
 			if(i->parent && i->parent->log) fprintf(i->parent->log, ""Code clear (free=%hu) npix=%ld\n"", free, npix);
 #endif  
 			free = clr + 2;
 			context.nbbit = i->imgbits + 1;
 			context.max = clr + clr - 1;  
 			act_code = GetGifWord(i, &context);
 			casspecial = (u8)act_code;
 			old_code = act_code;
 			WritePixel(i, &context, casspecial); npix--;
 		} else {
 			read_byt = act_code;
 			if(act_code >= free) {	 
 				*(--stackp) = casspecial;  
 				act_code = old_code;
 			}
 			while(act_code > clr) {  
 				*(--stackp) = ab_suffx[act_code];
 				act_code = ab_prfx[act_code];	 
 			}
 			casspecial = (u8)act_code;	 
 			*(--stackp) = casspecial;	 
 			WritePixels(i, &context, stackp, stack_top - stackp);	 
 			npix -= (stack_top - stackp);
 			stackp = stack_top;
 			if(free < 4096) {  
 				ab_prfx[free] = old_code;
 				ab_suffx[free] = (u8)act_code;
 				free++;
 				if((free > context.max) && (context.nbbit < 12)) {
 					context.nbbit++;	 
 					context.max += context.max + 1;
 				}
 			}
 			old_code = read_byt;
 		}
 	}
 	return 0;
 }","[22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39]","The DecodeGifImg function in ngiflib.c in MiniUPnP ngiflib 0.4 lacks certain checks against width and height, which allows remote attackers to cause a denial of service (WritePixels heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted GIF file.",ngiflib,CVE-2018-10677,CWE-119
1010,180947," static int asf_read_marker(AVFormatContext *s, int64_t size)
 {
     AVIOContext *pb = s->pb;
     ASFContext *asf = s->priv_data;
     int i, count, name_len, ret;
     char name[1024];
     avio_rl64(pb);             
     avio_rl64(pb);             
      count = avio_rl32(pb);     
      avio_rl16(pb);             
      name_len = avio_rl16(pb);  
    for (i = 0; i < name_len; i++)
        avio_r8(pb);  
     avio_skip(pb, name_len);
      for (i = 0; i < count; i++) {
          int64_t pres_time;
          int name_len;
         if (avio_feof(pb))
             return AVERROR_INVALIDDATA;
          avio_rl64(pb);              
          pres_time = avio_rl64(pb);  
          pres_time -= asf->hdr.preroll * 10000;
         avio_rl16(pb);              
         avio_rl32(pb);              
         avio_rl32(pb);              
         name_len = avio_rl32(pb);   
         if ((ret = avio_get_str16le(pb, name_len * 2, name,
                                     sizeof(name))) < name_len)
             avio_skip(pb, name_len - ret);
         avpriv_new_chapter(s, i, (AVRational) { 1, 10000000 }, pres_time,
                            AV_NOPTS_VALUE, name);
     }
     return 0;
 }","[12, 13, 14, 18, 19]","In FFmpeg 3.3.3, a DoS in asf_read_marker() due to lack of an EOF (End of File) check might cause huge CPU and memory consumption. When a crafted ASF file, which claims a large *name_len* or *count* field in the header but does not contain sufficient backing data, is provided, the loops over the name and markers would consume huge CPU and memory resources, since there is no EOF check inside these loops.",FFmpeg,CVE-2017-14057,CWE-834
1054,181916," static jas_image_cmpt_t *jas_image_cmpt_create(int_fast32_t tlx,
   int_fast32_t tly, int_fast32_t hstep, int_fast32_t vstep,
   int_fast32_t width, int_fast32_t height, uint_fast16_t depth, bool sgnd,
   uint_fast32_t inmem)
 {
 	jas_image_cmpt_t *cmpt;
 	size_t size;
 	cmpt = 0;
 	if (width < 0 || height < 0 || hstep <= 0 || vstep <= 0) {
 		goto error;
 	}
 	if (!jas_safe_intfast32_add(tlx, width, 0) ||
 	  !jas_safe_intfast32_add(tly, height, 0)) {
 		goto error;
 	}
 	if (!(cmpt = jas_malloc(sizeof(jas_image_cmpt_t)))) {
 		goto error;
 	}
 	cmpt->type_ = JAS_IMAGE_CT_UNKNOWN;
 	cmpt->tlx_ = tlx;
 	cmpt->tly_ = tly;
 	cmpt->hstep_ = hstep;
 	cmpt->vstep_ = vstep;
 	cmpt->width_ = width;
 	cmpt->height_ = height;
 	cmpt->prec_ = depth;
 	cmpt->sgnd_ = sgnd;
 	cmpt->stream_ = 0;
 	cmpt->cps_ = (depth + 7) / 8;
 	if (!jas_safe_size_mul(cmpt->width_, cmpt->height_, &size) ||
  	  !jas_safe_size_mul(size, cmpt->cps_, &size)) {
  		goto error;
  	}
	cmpt->stream_ = (inmem) ? jas_stream_memopen(0, size) :
 	cmpt->stream_ = (inmem) ? jas_stream_memopen2(0, size) :
  	  jas_stream_tmpfile();
  	if (!cmpt->stream_) {
  		goto error;
 	}
 	if (jas_stream_seek(cmpt->stream_, size - 1, SEEK_SET) < 0 ||
 	  jas_stream_putc(cmpt->stream_, 0) == EOF ||
 	  jas_stream_seek(cmpt->stream_, 0, SEEK_SET) < 0) {
 		goto error;
 	}
 	return cmpt;
 error:
 	if (cmpt) {
 		jas_image_cmpt_destroy(cmpt);
 	}
 	return 0;
 }","[34, 35]","Multiple integer overflows in the (1) jas_realloc function in base/jas_malloc.c and (2) mem_resize function in base/jas_stream.c in JasPer before 1.900.22 allow remote attackers to cause a denial of service via a crafted image, which triggers use after free vulnerabilities.",jasper,CVE-2016-9262,CWE-190
1056,182249," static int gemsafe_get_cert_len(sc_card_t *card)
 {
 	int r;
 	u8  ibuf[GEMSAFE_MAX_OBJLEN];
 	u8 *iptr;
 	struct sc_path path;
 	struct sc_file *file;
 	size_t objlen, certlen;
 	unsigned int ind, i=0;
 	sc_format_path(GEMSAFE_PATH, &path);
 	r = sc_select_file(card, &path, &file);
 	if (r != SC_SUCCESS || !file)
 		return SC_ERROR_INTERNAL;
 	r = sc_read_binary(card, 0, ibuf, GEMSAFE_READ_QUANTUM, 0);
 	if (r < 0)
 		return SC_ERROR_INTERNAL;
 	objlen = (((size_t) ibuf[0]) << 8) | ibuf[1];
 	sc_log(card->ctx, ""Stored object is of size: %""SC_FORMAT_LEN_SIZE_T""u"",
 	       objlen);
 	if (objlen < 1 || objlen > GEMSAFE_MAX_OBJLEN) {
 	    sc_log(card->ctx, ""Invalid object size: %""SC_FORMAT_LEN_SIZE_T""u"",
 		   objlen);
 	    return SC_ERROR_INTERNAL;
 	}
  	ind = 2;  
	while (ibuf[ind] == 0x01) {
 	while (ibuf[ind] == 0x01 && i < gemsafe_cert_max) {
  		if (ibuf[ind+1] == 0xFE) {
  			gemsafe_prkeys[i].ref = ibuf[ind+4];
  			sc_log(card->ctx, ""Key container %d is allocated and uses key_ref %d"",
 					i+1, gemsafe_prkeys[i].ref);
 			ind += 9;
 		}
 		else {
 			gemsafe_prkeys[i].label = NULL;
 			gemsafe_cert[i].label = NULL;
 			sc_log(card->ctx, ""Key container %d is unallocated"", i+1);
 			ind += 8;
 		}
 		i++;
 	}
 	for (; i < gemsafe_cert_max; i++) {
 		gemsafe_prkeys[i].label = NULL;
 		gemsafe_cert[i].label = NULL;
 	}
 	iptr = ibuf + GEMSAFE_READ_QUANTUM;
 	while ((size_t)(iptr - ibuf) < objlen) {
 		r = sc_read_binary(card, iptr - ibuf, iptr,
 				   MIN(GEMSAFE_READ_QUANTUM, objlen - (iptr - ibuf)), 0);
 		if (r < 0) {
 			sc_log(card->ctx, ""Could not read cert object"");
 			return SC_ERROR_INTERNAL;
 		}
 		iptr += GEMSAFE_READ_QUANTUM;
 	}
 	i = 0;
 	while (ind < objlen - 1) {
 		if (ibuf[ind] == 0x30 && ibuf[ind+1] == 0x82) {
 			while (i < gemsafe_cert_max && gemsafe_cert[i].label == NULL)
 				i++;
 			if (i == gemsafe_cert_max) {
 				sc_log(card->ctx, ""Warning: Found orphaned certificate at offset %d"", ind);
 				return SC_SUCCESS;
 			}
 			if (ind+3 >= sizeof ibuf)
 				return SC_ERROR_INVALID_DATA;
 			certlen = ((((size_t) ibuf[ind+2]) << 8) | ibuf[ind+3]) + 4;
 			sc_log(card->ctx,
 			       ""Found certificate of key container %d at offset %d, len %""SC_FORMAT_LEN_SIZE_T""u"",
 			       i+1, ind, certlen);
 			gemsafe_cert[i].index = ind;
 			gemsafe_cert[i].count = certlen;
 			ind += certlen;
 			i++;
 		} else
 			ind++;
 	}
 	for (; i < gemsafe_cert_max; i++) {
 		if (gemsafe_cert[i].label) {
 			sc_log(card->ctx, ""Warning: Certificate of key container %d is missing"", i+1);
 			gemsafe_prkeys[i].label = NULL;
 			gemsafe_cert[i].label = NULL;
 		}
 	}
 	return SC_SUCCESS;
 }","[26, 27]",A double free when handling responses from an HSM Card in sc_pkcs15emu_sc_hsm_init in libopensc/pkcs15-sc-hsm.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.,OpenSC,CVE-2018-16425,CWE-415
1060,182098," static int parse_video_info(AVIOContext *pb, AVStream *st)
 {
     uint16_t size_asf;  
     uint32_t size_bmp;  
     unsigned int tag;
     st->codecpar->width  = avio_rl32(pb);
     st->codecpar->height = avio_rl32(pb);
     avio_skip(pb, 1);  
     size_asf = avio_rl16(pb);
     tag = ff_get_bmp_header(pb, st, &size_bmp);
     st->codecpar->codec_tag = tag;
      st->codecpar->codec_id  = ff_codec_get_id(ff_codec_bmp_tags, tag);
      size_bmp = FFMAX(size_asf, size_bmp);
    if (size_bmp > BMP_HEADER_SIZE) {
     if (size_bmp > BMP_HEADER_SIZE &&
         size_bmp < INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE) {
          int ret;
          st->codecpar->extradata_size  = size_bmp - BMP_HEADER_SIZE;
          if (!(st->codecpar->extradata = av_malloc(st->codecpar->extradata_size +
                                                AV_INPUT_BUFFER_PADDING_SIZE))) {
             st->codecpar->extradata_size = 0;
             return AVERROR(ENOMEM);
         }
         memset(st->codecpar->extradata + st->codecpar->extradata_size , 0,
                AV_INPUT_BUFFER_PADDING_SIZE);
         if ((ret = avio_read(pb, st->codecpar->extradata,
                              st->codecpar->extradata_size)) < 0)
             return ret;
     }
     return 0;
 }","[14, 15, 16]",FFmpeg before commit 2b46ebdbff1d8dec7a3d8ea280a612b91a582869 contains a Buffer Overflow vulnerability in asf_o format demuxer that can result in heap-buffer-overflow that may result in remote code execution. This attack appears to be exploitable via specially crafted ASF file that has to be provided as input to FFmpeg. This vulnerability appears to have been fixed in 2b46ebdbff1d8dec7a3d8ea280a612b91a582869 and later.,FFmpeg,CVE-2018-1999011,CWE-119
1064,182326," static int er_supported(ERContext *s)
  {
      if(s->avctx->hwaccel && s->avctx->hwaccel->decode_slice           ||
         !s->cur_pic.f                                                  ||
       s->cur_pic.field_picture                                       ||
       s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO
        s->cur_pic.field_picture
      )
          return 0;
      return 1;
 }","[5, 6, 7]","In libavcodec in FFmpeg 4.0.1, improper maintenance of the consistency between the context profile field and studio_profile in libavcodec may trigger an assertion failure while converting a crafted AVI file to MPEG4, leading to a denial of service, related to error_resilience.c, h263dec.c, and mpeg4videodec.c.",FFmpeg,CVE-2018-13304,CWE-617
1069,182787," static float *get_window(vorb *f, int len)
 {
     len <<= 1;
     if (len == f->blocksize_0) return f->window[0];
     if (len == f->blocksize_1) return f->window[1];
   assert(0);
     return NULL;
  }",[6],A reachable assertion in the lookup1_values function in stb_vorbis through 2019-03-04 allows an attacker to cause a denial of service by opening a crafted Ogg Vorbis file.,stb,CVE-2019-13223,CWE-20
1096,181264," static int dnxhd_find_frame_end(DNXHDParserContext *dctx,
                                 const uint8_t *buf, int buf_size)
 {
     ParseContext *pc = &dctx->pc;
     uint64_t state = pc->state64;
     int pic_found = pc->frame_start_found;
     int i = 0;
     int interlaced = dctx->interlaced;
     int cur_field = dctx->cur_field;
     if (!pic_found) {
         for (i = 0; i < buf_size; i++) {
             state = (state << 8) | buf[i];
             if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {
                 i++;
                 pic_found = 1;
                 interlaced = (state&2)>>1;  
                 cur_field = state&1;
                 dctx->cur_byte = 0;
                 dctx->remaining = 0;
                 break;
             }
         }
     }
     if (pic_found && !dctx->remaining) {
         if (!buf_size)  
             return 0;
         for (; i < buf_size; i++) {
             dctx->cur_byte++;
             state = (state << 8) | buf[i];
             if (dctx->cur_byte == 24) {
                 dctx->h = (state >> 32) & 0xFFFF;
             } else if (dctx->cur_byte == 26) {
                  dctx->w = (state >> 32) & 0xFFFF;
              } else if (dctx->cur_byte == 42) {
                  int cid = (state >> 32) & 0xFFFFFFFF;
                 int remaining;
                  if (cid <= 0)
                      continue;
                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);
                if (dctx->remaining <= 0) {
                    dctx->remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
                    if (dctx->remaining <= 0)
                        return dctx->remaining;
                 remaining = avpriv_dnxhd_get_frame_size(cid);
                 if (remaining <= 0) {
                     remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
                     if (remaining <= 0)
                         continue;
                  }
                 dctx->remaining = remaining;
                  if (buf_size - i >= dctx->remaining && (!dctx->interlaced || dctx->cur_field)) {
                      int remaining = dctx->remaining;
                     pc->frame_start_found = 0;
                     pc->state64 = -1;
                     dctx->interlaced = interlaced;
                     dctx->cur_field = 0;
                     dctx->cur_byte = 0;
                     dctx->remaining = 0;
                     return remaining;
                 } else {
                     dctx->remaining -= buf_size;
                 }
             }
         }
     } else if (pic_found) {
         if (dctx->remaining > buf_size) {
             dctx->remaining -= buf_size;
         } else {
             int remaining = dctx->remaining;
             pc->frame_start_found = 0;
             pc->state64 = -1;
             dctx->interlaced = interlaced;
             dctx->cur_field = 0;
             dctx->cur_byte = 0;
             dctx->remaining = 0;
             return remaining;
         }
     }
     pc->frame_start_found = pic_found;
     pc->state64 = state;
     dctx->interlaced = interlaced;
     dctx->cur_field = cur_field;
     return END_NOT_FOUND;
 }","[36, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50]","The dnxhd decoder in FFmpeg before 3.2.6, and 3.3.x before 3.3.3 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted mov file.",FFmpeg,CVE-2017-9608,CWE-476
1131,182255," const char * util_acl_to_str(const sc_acl_entry_t *e)
 {
 	static char line[80], buf[20];
 	unsigned int acl;
 	if (e == NULL)
 		return ""N/A"";
 	line[0] = 0;
 	while (e != NULL) {
 		acl = e->method;
 		switch (acl) {
 		case SC_AC_UNKNOWN:
 			return ""N/A"";
 		case SC_AC_NEVER:
 			return ""NEVR"";
 		case SC_AC_NONE:
 			return ""NONE"";
 		case SC_AC_CHV:
 			strcpy(buf, ""CHV"");
 			if (e->key_ref != SC_AC_KEY_REF_NONE)
 				sprintf(buf + 3, ""%d"", e->key_ref);
 			break;
 		case SC_AC_TERM:
 			strcpy(buf, ""TERM"");
 			break;
 		case SC_AC_PRO:
 			strcpy(buf, ""PROT"");
 			break;
 		case SC_AC_AUT:
 			strcpy(buf, ""AUTH"");
 			if (e->key_ref != SC_AC_KEY_REF_NONE)
 				sprintf(buf + 4, ""%d"", e->key_ref);
 			break;
 		case SC_AC_SEN:
 			strcpy(buf, ""Sec.Env. "");
 			if (e->key_ref != SC_AC_KEY_REF_NONE)
 				sprintf(buf + 3, ""#%d"", e->key_ref);
 			break;
 		case SC_AC_SCB:
 			strcpy(buf, ""Sec.ControlByte "");
 			if (e->key_ref != SC_AC_KEY_REF_NONE)
 				sprintf(buf + 3, ""Ox%X"", e->key_ref);
 			break;
 		case SC_AC_IDA:
 			strcpy(buf, ""PKCS#15 AuthID "");
 			if (e->key_ref != SC_AC_KEY_REF_NONE)
 				sprintf(buf + 3, ""#%d"", e->key_ref);
 			break;
 		default:
  			strcpy(buf, ""????"");
  			break;
  		}
		strcat(line, buf);
		strcat(line, "" "");
 		strncat(line, buf, sizeof line);
 		strncat(line, "" "", sizeof line);
  		e = e->next;
  	}
 	line[(sizeof line)-1] = '\0';  
  	line[strlen(line)-1] = 0;  
  	return line;
  }","[52, 53, 54, 55, 58]",A double free when handling responses from an HSM Card in sc_pkcs15emu_sc_hsm_init in libopensc/pkcs15-sc-hsm.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.,OpenSC,CVE-2018-16425,CWE-415
1217,181876,"  void jas_matrix_divpow2(jas_matrix_t *matrix, int n)
  {
	int i;
	int j;
 	jas_matind_t i;
 	jas_matind_t j;
  	jas_seqent_t *rowstart;
	int rowstep;
 	jas_matind_t rowstep;
  	jas_seqent_t *data;
  	if (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {
 		assert(matrix->rows_);
 		rowstep = jas_matrix_rowstep(matrix);
 		for (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,
 		  rowstart += rowstep) {
 			for (j = matrix->numcols_, data = rowstart; j > 0; --j,
 			  ++data) {
 				*data = (*data >= 0) ? ((*data) >> n) :
 				  (-((-(*data)) >> n));
 			}
 		}
 	}
 }","[3, 4, 5, 6, 8, 9]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
1218,182224," static int entersafe_gen_key(sc_card_t *card, sc_entersafe_gen_key_data *data)
 {
 	int	r;
 	size_t len = data->key_length >> 3;
 	sc_apdu_t apdu;
 	u8 rbuf[300];
 	u8 sbuf[4],*p;
 	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
 	sc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x22, 0x01, 0xB8);
 	apdu.lc=0x04;
 	sbuf[0]=0x83;
 	sbuf[1]=0x02;
 	sbuf[2]=data->key_id;
 	sbuf[3]=0x2A;
 	apdu.data = sbuf;
 	apdu.datalen=4;
 	apdu.lc=4;
 	apdu.le=0;
 	r=entersafe_transmit_apdu(card, &apdu, 0,0,0,0);
 	SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, ""APDU transmit failed"");
 	SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, sc_check_sw(card,apdu.sw1,apdu.sw2),""EnterSafe set MSE failed"");
 	sc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x46,  0x00, 0x00);
 	apdu.le      = 0;
 	sbuf[0] = (u8)(data->key_length >> 8);
 	sbuf[1] = (u8)(data->key_length);
 	apdu.data    = sbuf;
 	apdu.lc      = 2;
 	apdu.datalen = 2;
 	r = entersafe_transmit_apdu(card, &apdu,0,0,0,0);
 	SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, ""APDU transmit failed"");
 	SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, sc_check_sw(card,apdu.sw1,apdu.sw2),""EnterSafe generate keypair failed"");
 	sc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xE6,  0x2A, data->key_id);
 	apdu.cla     = 0x80;
 	apdu.resp    = rbuf;
 	apdu.resplen = sizeof(rbuf);
 	apdu.le      = 256;
 	r = entersafe_transmit_apdu(card, &apdu,0,0,0,0);
 	SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, ""APDU transmit failed"");
 	SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, sc_check_sw(card,apdu.sw1,apdu.sw2),""EnterSafe get pukey failed"");
  	data->modulus = malloc(len);
  	if (!data->modulus)
		 SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,SC_ERROR_OUT_OF_MEMORY);
 		SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_OUT_OF_MEMORY);
  	p=rbuf;
	assert(*p=='E');
 	if (*p!='E')
 		SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_DATA);
  	p+=2+p[1];
	assert(*p=='N');
 	if (*p!='N')
 		SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_DATA);
  	++p;
  	if(*p++>0x80)
  	{
 		 u8 len_bytes=(*(p-1))&0x0f;
 		 size_t module_len=0;
 		 while(len_bytes!=0)
 		 {
 			  module_len=module_len<<8;
 			  module_len+=*p++;
 			  --len_bytes;
 		 }
 	}
 	entersafe_reverse_buffer(p,len);
 	memcpy(data->modulus,p,len);
 	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,SC_SUCCESS);
 }","[42, 43, 45, 46, 47, 49, 50, 51]",Various out of bounds reads when handling responses in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to potentially crash the opensc library using programs.,OpenSC,CVE-2018-16427,CWE-125
1240,182388," JsVar *jswrap_graphics_createArrayBuffer(int width, int height, int bpp, JsVar *options) {
   if (width<=0 || height<=0 || width>32767 || height>32767) {
     jsExceptionHere(JSET_ERROR, ""Invalid Size"");
     return 0;
   }
   if (!isValidBPP(bpp)) {
     jsExceptionHere(JSET_ERROR, ""Invalid BPP"");
     return 0;
   }
   JsVar *parent = jspNewObject(0, ""Graphics"");
   if (!parent) return 0;  
   JsGraphics gfx;
   graphicsStructInit(&gfx);
   gfx.data.type = JSGRAPHICSTYPE_ARRAYBUFFER;
   gfx.data.flags = JSGRAPHICSFLAGS_NONE;
   gfx.graphicsVar = parent;
   gfx.data.width = (unsigned short)width;
   gfx.data.height = (unsigned short)height;
   gfx.data.bpp = (unsigned char)bpp;
   if (jsvIsObject(options)) {
     if (jsvGetBoolAndUnLock(jsvObjectGetChild(options, ""zigzag"", 0)))
       gfx.data.flags = (JsGraphicsFlags)(gfx.data.flags | JSGRAPHICSFLAGS_ARRAYBUFFER_ZIGZAG);
     if (jsvGetBoolAndUnLock(jsvObjectGetChild(options, ""msb"", 0)))
       gfx.data.flags = (JsGraphicsFlags)(gfx.data.flags | JSGRAPHICSFLAGS_ARRAYBUFFER_MSB);
      if (jsvGetBoolAndUnLock(jsvObjectGetChild(options, ""vertical_byte"", 0))) {
        if (gfx.data.bpp==1)
          gfx.data.flags = (JsGraphicsFlags)(gfx.data.flags | JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE);
      else
        jsWarn(""vertical_byte only works for 1bpp ArrayBuffers\n"");
       else {
         jsExceptionHere(JSET_ERROR, ""vertical_byte only works for 1bpp ArrayBuffers\n"");
         return 0;
       }
       if (gfx.data.height&7) {
         jsExceptionHere(JSET_ERROR, ""height must be a multiple of 8 when using vertical_byte\n"");
         return 0;
       }
      }
      JsVar *colorv = jsvObjectGetChild(options, ""color_order"", 0);
      if (colorv) {
       if (jsvIsStringEqual(colorv, ""rgb"")) ;  
       else if (!jsvIsStringEqual(colorv, ""brg""))
         gfx.data.flags = (JsGraphicsFlags)(gfx.data.flags | JSGRAPHICSFLAGS_COLOR_BRG);
       else if (!jsvIsStringEqual(colorv, ""bgr""))
         gfx.data.flags = (JsGraphicsFlags)(gfx.data.flags | JSGRAPHICSFLAGS_COLOR_BGR);
       else if (!jsvIsStringEqual(colorv, ""gbr""))
         gfx.data.flags = (JsGraphicsFlags)(gfx.data.flags | JSGRAPHICSFLAGS_COLOR_GBR);
       else if (!jsvIsStringEqual(colorv, ""grb""))
         gfx.data.flags = (JsGraphicsFlags)(gfx.data.flags | JSGRAPHICSFLAGS_COLOR_GRB);
       else if (!jsvIsStringEqual(colorv, ""rbg""))
         gfx.data.flags = (JsGraphicsFlags)(gfx.data.flags | JSGRAPHICSFLAGS_COLOR_RBG);
       else
         jsWarn(""color_order must be 3 characters"");
       jsvUnLock(colorv);
     }
   }
   lcdInit_ArrayBuffer(&gfx);
   graphicsSetVar(&gfx);
   return parent;
 }","[28, 29, 30, 31, 32, 33, 34, 35, 36, 37]",Espruino before 1.98 allows attackers to cause a denial of service (application crash) with a user crafted input file via an Out-of-bounds Read during syntax parsing in which certain height validation is missing in libs/graphics/jswrap_graphics.c.,Espruino,CVE-2018-11592,CWE-125
1247,181508," size_t compile_tree(struct filter_op **fop)
 {
    int i = 1;
     struct filter_op *array = NULL;
     struct unfold_elm *ue;
   BUG_IF(tree_root == NULL);
    if (tree_root == NULL)
       return 0;
     fprintf(stdout, "" Unfolding the meta-tree "");
     fflush(stdout);
    unfold_blk(&tree_root);
    fprintf(stdout, "" done.\n\n"");
    labels_to_offsets();
    TAILQ_FOREACH(ue, &unfolded_tree, next) {
       if (ue->label == 0) {
          SAFE_REALLOC(array, i * sizeof(struct filter_op));
          memcpy(&array[i - 1], &ue->fop, sizeof(struct filter_op));
          i++;
       }
    }
    SAFE_REALLOC(array, i * sizeof(struct filter_op));
    array[i - 1].opcode = FOP_EXIT;
    *fop = array;
    return (i);
 }","[6, 7, 8]",The compile_tree function in ef_compiler.c in the Etterfilter utility in Ettercap 0.8.2 and earlier allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted filter.,ettercap,CVE-2017-6430,CWE-125
1248,181674," static int64_t http_seek_internal(URLContext *h, int64_t off, int whence, int force_reconnect)
  {
      HTTPContext *s = h->priv_data;
      URLContext *old_hd = s->hd;
    int64_t old_off = s->off;
     uint64_t old_off = s->off;
      uint8_t old_buf[BUFFER_SIZE];
      int old_buf_size, ret;
      AVDictionary *options = NULL;
     if (whence == AVSEEK_SIZE)
         return s->filesize;
     else if (!force_reconnect &&
               ((whence == SEEK_CUR && off == 0) ||
                (whence == SEEK_SET && off == s->off)))
          return s->off;
    else if ((s->filesize == -1 && whence == SEEK_END))
     else if ((s->filesize == UINT64_MAX && whence == SEEK_END))
          return AVERROR(ENOSYS);
      if (whence == SEEK_CUR)
         off += s->off;
     else if (whence == SEEK_END)
         off += s->filesize;
     else if (whence != SEEK_SET)
         return AVERROR(EINVAL);
     if (off < 0)
         return AVERROR(EINVAL);
     s->off = off;
     if (s->off && h->is_streamed)
         return AVERROR(ENOSYS);
     old_buf_size = s->buf_end - s->buf_ptr;
     memcpy(old_buf, s->buf_ptr, old_buf_size);
     s->hd = NULL;
     if ((ret = http_open_cnx(h, &options)) < 0) {
         av_dict_free(&options);
         memcpy(s->buffer, old_buf, old_buf_size);
         s->buf_ptr = s->buffer;
         s->buf_end = s->buffer + old_buf_size;
         s->hd      = old_hd;
         s->off     = old_off;
         return ret;
     }
     av_dict_free(&options);
     ffurl_close(old_hd);
     return off;
 }","[5, 6, 16, 17]","Heap-based buffer overflow in libavformat/http.c in FFmpeg before 2.8.10, 3.0.x before 3.0.5, 3.1.x before 3.1.6, and 3.2.x before 3.2.2 allows remote web servers to execute arbitrary code via a negative chunk size in an HTTP response.",FFmpeg,CVE-2016-10190,CWE-119
1254,179571," hstore_recv(PG_FUNCTION_ARGS)
 {
 	int32		buflen;
 	HStore	   *out;
 	Pairs	   *pairs;
 	int32		i;
 	int32		pcount;
 	StringInfo	buf = (StringInfo) PG_GETARG_POINTER(0);
 	pcount = pq_getmsgint(buf, 4);
 	if (pcount == 0)
 	{
 		out = hstorePairs(NULL, 0, 0);
  		PG_RETURN_POINTER(out);
  	}
 	if (pcount < 0 || pcount > MaxAllocSize / sizeof(Pairs))
 		ereport(ERROR,
 				(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),
 			  errmsg(""number of pairs (%d) exceeds the maximum allowed (%d)"",
 					 pcount, (int) (MaxAllocSize / sizeof(Pairs)))));
  	pairs = palloc(pcount * sizeof(Pairs));
  	for (i = 0; i < pcount; ++i)
 	{
 		int			rawlen = pq_getmsgint(buf, 4);
 		int			len;
 		if (rawlen < 0)
 			ereport(ERROR,
 					(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),
 					 errmsg(""null value not allowed for hstore key"")));
 		pairs[i].key = pq_getmsgtext(buf, rawlen, &len);
 		pairs[i].keylen = hstoreCheckKeyLen(len);
 		pairs[i].needfree = true;
 		rawlen = pq_getmsgint(buf, 4);
 		if (rawlen < 0)
 		{
 			pairs[i].val = NULL;
 			pairs[i].vallen = 0;
 			pairs[i].isnull = true;
 		}
 		else
 		{
 			pairs[i].val = pq_getmsgtext(buf, rawlen, &len);
 			pairs[i].vallen = hstoreCheckValLen(len);
 			pairs[i].isnull = false;
 		}
 	}
 	pcount = hstoreUniquePairs(pairs, pcount, &buflen);
 	out = hstorePairs(pairs, pcount, buflen);
 	PG_RETURN_POINTER(out);
 }","[15, 16, 17, 18, 19]","Multiple integer overflows in contrib/hstore/hstore_io.c in PostgreSQL 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact via vectors related to the (1) hstore_recv, (2) hstore_from_arrays, and (3) hstore_from_array functions in contrib/hstore/hstore_io.c; and the (4) hstoreArrayToPairs function in contrib/hstore/hstore_op.c, which triggers a buffer overflow.  NOTE: this issue was SPLIT from CVE-2014-0064 because it has a different set of affected versions.",postgres,CVE-2014-2669,CWE-189
1256,181671," static int http_proxy_open(URLContext *h, const char *uri, int flags)
 {
     HTTPContext *s = h->priv_data;
     char hostname[1024], hoststr[1024];
     char auth[1024], pathbuf[1024], *path;
     char lower_url[100];
     int port, ret = 0, attempts = 0;
     HTTPAuthType cur_auth_type;
     char *authstr;
     int new_loc;
     if( s->seekable == 1 )
         h->is_streamed = 0;
     else
         h->is_streamed = 1;
     av_url_split(NULL, 0, auth, sizeof(auth), hostname, sizeof(hostname), &port,
                  pathbuf, sizeof(pathbuf), uri);
     ff_url_join(hoststr, sizeof(hoststr), NULL, NULL, hostname, port, NULL);
     path = pathbuf;
     if (*path == '/')
         path++;
     ff_url_join(lower_url, sizeof(lower_url), ""tcp"", NULL, hostname, port,
                 NULL);
 redo:
     ret = ffurl_open_whitelist(&s->hd, lower_url, AVIO_FLAG_READ_WRITE,
                                &h->interrupt_callback, NULL,
                                h->protocol_whitelist, h->protocol_blacklist, h);
     if (ret < 0)
         return ret;
     authstr = ff_http_auth_create_response(&s->proxy_auth_state, auth,
                                            path, ""CONNECT"");
     snprintf(s->buffer, sizeof(s->buffer),
              ""CONNECT %s HTTP/1.1\r\n""
              ""Host: %s\r\n""
              ""Connection: close\r\n""
              ""%s%s""
              ""\r\n"",
              path,
              hoststr,
              authstr ? ""Proxy-"" : """", authstr ? authstr : """");
     av_freep(&authstr);
     if ((ret = ffurl_write(s->hd, s->buffer, strlen(s->buffer))) < 0)
         goto fail;
      s->buf_ptr    = s->buffer;
      s->buf_end    = s->buffer;
      s->line_count = 0;
    s->filesize   = -1;
     s->filesize   = UINT64_MAX;
      cur_auth_type = s->proxy_auth_state.auth_type;
     ret = http_read_header(h, &new_loc);
     if (ret < 0)
         goto fail;
     attempts++;
     if (s->http_code == 407 &&
         (cur_auth_type == HTTP_AUTH_NONE || s->proxy_auth_state.stale) &&
         s->proxy_auth_state.auth_type != HTTP_AUTH_NONE && attempts < 2) {
         ffurl_closep(&s->hd);
         goto redo;
     }
     if (s->http_code < 400)
         return 0;
     ret = ff_http_averror(s->http_code, AVERROR(EIO));
 fail:
     http_proxy_close(h);
     return ret;
 }","[46, 47]","Heap-based buffer overflow in libavformat/http.c in FFmpeg before 2.8.10, 3.0.x before 3.0.5, 3.1.x before 3.1.6, and 3.2.x before 3.2.2 allows remote web servers to execute arbitrary code via a negative chunk size in an HTTP response.",FFmpeg,CVE-2016-10190,CWE-119
1281,182364,"  static void mpeg4_encode_gop_header(MpegEncContext *s)
  {
    int hours, minutes, seconds;
     int64_t hours, minutes, seconds;
      int64_t time;
      put_bits(&s->pb, 16, 0);
     put_bits(&s->pb, 16, GOP_STARTCODE);
     time = s->current_picture_ptr->f->pts;
     if (s->reordered_input_picture[1])
         time = FFMIN(time, s->reordered_input_picture[1]->f->pts);
     time = time * s->avctx->time_base.num;
     s->last_time_base = FFUDIV(time, s->avctx->time_base.den);
     seconds = FFUDIV(time, s->avctx->time_base.den);
     minutes = FFUDIV(seconds, 60); seconds = FFUMOD(seconds, 60);
     hours   = FFUDIV(minutes, 60); minutes = FFUMOD(minutes, 60);
     hours   = FFUMOD(hours  , 24);
     put_bits(&s->pb, 5, hours);
     put_bits(&s->pb, 6, minutes);
     put_bits(&s->pb, 1, 1);
     put_bits(&s->pb, 6, seconds);
     put_bits(&s->pb, 1, !!(s->avctx->flags & AV_CODEC_FLAG_CLOSED_GOP));
     put_bits(&s->pb, 1, 0);   
     ff_mpeg4_stuffing(&s->pb);
 }","[3, 4]","An improper integer type in the mpeg4_encode_gop_header function in libavcodec/mpeg4videoenc.c in FFmpeg 4.0 may trigger an assertion violation while converting a crafted AVI file to MPEG4, leading to a denial of service.",FFmpeg,CVE-2018-12458,CWE-20
1294,183237," psf_binheader_writef (SF_PRIVATE *psf, const char *format, ...)
 {	va_list	argptr ;
 	sf_count_t 		countdata ;
 	unsigned long 	longdata ;
 	unsigned int 	data ;
 	float			floatdata ;
 	double			doubledata ;
 	void			*bindata ;
 	size_t			size ;
 	char			c, *strptr ;
 	int				count = 0, trunc_8to4 ;
 	trunc_8to4 = SF_FALSE ;
  	va_start (argptr, format) ;
  	while ((c = *format++))
	{	switch (c)
 	{
 		if (psf->header.indx + 16 >= psf->header.len && psf_bump_header_allocation (psf, 16))
 			return count ;
 		switch (c)
  		{	case ' ' :  
  					break ;
 			case 'e' :  
 					psf->rwf_endian = SF_ENDIAN_LITTLE ;
 					break ;
 			case 'E' :  
 					psf->rwf_endian = SF_ENDIAN_BIG ;
 					break ;
 			case 't' :  
 					trunc_8to4 = SF_TRUE ;
 					break ;
 			case 'T' :  
 					trunc_8to4 = SF_FALSE ;
 					break ;
 			case 'm' :
 					data = va_arg (argptr, unsigned int) ;
 					header_put_marker (psf, data) ;
 					count += 4 ;
 					break ;
 			case '1' :
 					data = va_arg (argptr, unsigned int) ;
 					header_put_byte (psf, data) ;
 					count += 1 ;
 					break ;
 			case '2' :
 					data = va_arg (argptr, unsigned int) ;
 					if (psf->rwf_endian == SF_ENDIAN_BIG)
 					{	header_put_be_short (psf, data) ;
 						}
 					else
 					{	header_put_le_short (psf, data) ;
 						} ;
 					count += 2 ;
 					break ;
 			case '3' :  
 					data = va_arg (argptr, unsigned int) ;
 					if (psf->rwf_endian == SF_ENDIAN_BIG)
 					{	header_put_be_3byte (psf, data) ;
 						}
 					else
 					{	header_put_le_3byte (psf, data) ;
 						} ;
 					count += 3 ;
 					break ;
 			case '4' :
 					data = va_arg (argptr, unsigned int) ;
 					if (psf->rwf_endian == SF_ENDIAN_BIG)
 					{	header_put_be_int (psf, data) ;
 						}
 					else
 					{	header_put_le_int (psf, data) ;
 						} ;
 					count += 4 ;
 					break ;
 			case '8' :
 					countdata = va_arg (argptr, sf_count_t) ;
 					if (psf->rwf_endian == SF_ENDIAN_BIG && trunc_8to4 == SF_FALSE)
 					{	header_put_be_8byte (psf, countdata) ;
 						count += 8 ;
 						}
 					else if (psf->rwf_endian == SF_ENDIAN_LITTLE && trunc_8to4 == SF_FALSE)
 					{	header_put_le_8byte (psf, countdata) ;
 						count += 8 ;
 						}
 					else if (psf->rwf_endian == SF_ENDIAN_BIG && trunc_8to4 == SF_TRUE)
 					{	longdata = countdata & 0xFFFFFFFF ;
 						header_put_be_int (psf, longdata) ;
 						count += 4 ;
 						}
 					else if (psf->rwf_endian == SF_ENDIAN_LITTLE && trunc_8to4 == SF_TRUE)
 					{	longdata = countdata & 0xFFFFFFFF ;
 						header_put_le_int (psf, longdata) ;
 						count += 4 ;
 						}
 					break ;
 			case 'f' :
  					floatdata = (float) va_arg (argptr, double) ;
  					if (psf->rwf_endian == SF_ENDIAN_BIG)
						float32_be_write (floatdata, psf->header + psf->headindex) ;
 						float32_be_write (floatdata, psf->header.ptr + psf->header.indx) ;
  					else
						float32_le_write (floatdata, psf->header + psf->headindex) ;
					psf->headindex += 4 ;
 						float32_le_write (floatdata, psf->header.ptr + psf->header.indx) ;
 					psf->header.indx += 4 ;
  					count += 4 ;
  					break ;
  			case 'd' :
  					doubledata = va_arg (argptr, double) ;
  					if (psf->rwf_endian == SF_ENDIAN_BIG)
						double64_be_write (doubledata, psf->header + psf->headindex) ;
 						double64_be_write (doubledata, psf->header.ptr + psf->header.indx) ;
  					else
						double64_le_write (doubledata, psf->header + psf->headindex) ;
					psf->headindex += 8 ;
 						double64_le_write (doubledata, psf->header.ptr + psf->header.indx) ;
 					psf->header.indx += 8 ;
  					count += 8 ;
  					break ;
 			case 's' :
  					strptr = va_arg (argptr, char *) ;
  					size = strlen (strptr) + 1 ;
  					size += (size & 1) ;
 					if (psf->header.indx + (sf_count_t) size >= psf->header.len && psf_bump_header_allocation (psf, 16))
 						return count ;
  					if (psf->rwf_endian == SF_ENDIAN_BIG)
  						header_put_be_int (psf, size) ;
  					else
  						header_put_le_int (psf, size) ;
					memcpy (&(psf->header [psf->headindex]), strptr, size) ;
					psf->headindex += size ;
					psf->header [psf->headindex - 1] = 0 ;
 					memcpy (&(psf->header.ptr [psf->header.indx]), strptr, size) ;
 					psf->header.indx += size ;
 					psf->header.ptr [psf->header.indx - 1] = 0 ;
  					count += 4 + size ;
  					break ;
 			case 'S' :
  					strptr = va_arg (argptr, char *) ;
  					size = strlen (strptr) ;
 					if (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))
 						return count ;
  					if (psf->rwf_endian == SF_ENDIAN_BIG)
  						header_put_be_int (psf, size) ;
  					else
  						header_put_le_int (psf, size) ;
					memcpy (&(psf->header [psf->headindex]), strptr, size + 1) ;
 					memcpy (&(psf->header.ptr [psf->header.indx]), strptr, size + 1) ;
  					size += (size & 1) ;
					psf->headindex += size ;
					psf->header [psf->headindex] = 0 ;
 					psf->header.indx += size ;
 					psf->header.ptr [psf->header.indx] = 0 ;
  					count += 4 + size ;
  					break ;
 			case 'p' :
 					strptr = va_arg (argptr, char *) ;
  					size = strlen (strptr) ;
  					size = (size & 1) ? size : size + 1 ;
  					size = (size > 254) ? 254 : size ;
 					if (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))
 						return count ;
  					header_put_byte (psf, size) ;
					memcpy (&(psf->header [psf->headindex]), strptr, size) ;
					psf->headindex += size ;
 					memcpy (&(psf->header.ptr [psf->header.indx]), strptr, size) ;
 					psf->header.indx += size ;
  					count += 1 + size ;
  					break ;
  			case 'b' :
  					bindata	= va_arg (argptr, void *) ;
  					size	= va_arg (argptr, size_t) ;
					if (psf->headindex + size < sizeof (psf->header))
					{	memcpy (&(psf->header [psf->headindex]), bindata, size) ;
						psf->headindex += size ;
						count += size ;
						} ;
 					if (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))
 						return count ;
 					memcpy (&(psf->header.ptr [psf->header.indx]), bindata, size) ;
 					psf->header.indx += size ;
 					count += size ;
  					break ;
  			case 'z' :
  					size = va_arg (argptr, size_t) ;
 					if (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))
 						return count ;
  					count += size ;
  					while (size)
					{	psf->header [psf->headindex] = 0 ;
						psf->headindex ++ ;
 					{	psf->header.ptr [psf->header.indx] = 0 ;
 						psf->header.indx ++ ;
  						size -- ;
  						} ;
  					break ;
  			case 'h' :
  					bindata = va_arg (argptr, void *) ;
					memcpy (&(psf->header [psf->headindex]), bindata, 16) ;
					psf->headindex += 16 ;
 					memcpy (&(psf->header.ptr [psf->header.indx]), bindata, 16) ;
 					psf->header.indx += 16 ;
  					count += 16 ;
  					break ;
  			case 'j' :	 
  					size = va_arg (argptr, size_t) ;
					psf->headindex += size ;
 					if (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))
 						return count ;
 					psf->header.indx += size ;
  					count += size ;
  					break ;
  			case 'o' :	 
  					size = va_arg (argptr, size_t) ;
					if (size < sizeof (psf->header))
					{	psf->headindex = size ;
						count = 0 ;
						} ;
 					if ((sf_count_t) size >= psf->header.len && psf_bump_header_allocation (psf, size))
 						return count ;
 					psf->header.indx = size ;
  					break ;
  			default :
 				psf_log_printf (psf, ""*** Invalid format specifier `%c'\n"", c) ;
 				psf->error = SFE_INTERNAL ;
 				break ;
 			} ;
 		} ;
 	va_end (argptr) ;
 	return count ;
 }  ","[15, 16, 17, 18, 19, 98, 99, 101, 102, 103, 104, 110, 111, 113, 114, 115, 116, 123, 124, 129, 130, 131, 132, 133, 134, 140, 141, 146, 147, 149, 150, 151, 152, 160, 161, 163, 164, 165, 166, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 185, 186, 189, 190, 191, 192, 198, 199, 200, 201, 206, 207, 208, 209, 214, 215, 216, 217, 218, 219, 220]","In libsndfile before 1.0.28, an error in the *header_read()* function (common.c) when handling ID3 tags can be exploited to cause a stack-based buffer overflow via a specially crafted FLAC file.",libsndfile,CVE-2017-7586,CWE-119
1295,180945," static int cine_read_header(AVFormatContext *avctx)
 {
     AVIOContext *pb = avctx->pb;
     AVStream *st;
     unsigned int version, compression, offImageHeader, offSetup, offImageOffsets, biBitCount, length, CFA;
     int vflip;
     char *description;
     uint64_t i;
     st = avformat_new_stream(avctx, NULL);
     if (!st)
         return AVERROR(ENOMEM);
     st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;
     st->codecpar->codec_id   = AV_CODEC_ID_RAWVIDEO;
     st->codecpar->codec_tag  = 0;
     avio_skip(pb, 4);  
     compression = avio_rl16(pb);
     version     = avio_rl16(pb);
     if (version != 1) {
         avpriv_request_sample(avctx, ""unknown version %i"", version);
         return AVERROR_INVALIDDATA;
     }
     avio_skip(pb, 12);  
     st->duration    = avio_rl32(pb);
     offImageHeader  = avio_rl32(pb);
     offSetup        = avio_rl32(pb);
     offImageOffsets = avio_rl32(pb);
     avio_skip(pb, 8);  
     avio_seek(pb, offImageHeader, SEEK_SET);
     avio_skip(pb, 4);  
     st->codecpar->width      = avio_rl32(pb);
     st->codecpar->height     = avio_rl32(pb);
     if (avio_rl16(pb) != 1)  
         return AVERROR_INVALIDDATA;
     biBitCount = avio_rl16(pb);
     if (biBitCount != 8 && biBitCount != 16 && biBitCount != 24 && biBitCount != 48) {
         avpriv_request_sample(avctx, ""unsupported biBitCount %i"", biBitCount);
         return AVERROR_INVALIDDATA;
     }
     switch (avio_rl32(pb)) {
     case BMP_RGB:
         vflip = 0;
         break;
     case 0x100:  
         st->codecpar->codec_tag = MKTAG('B', 'I', 'T', 0);
         vflip = 1;
         break;
     default:
         avpriv_request_sample(avctx, ""unknown bitmap compression"");
         return AVERROR_INVALIDDATA;
     }
     avio_skip(pb, 4);  
     avio_seek(pb, offSetup, SEEK_SET);
     avio_skip(pb, 140);  
     if (avio_rl16(pb) != 0x5453)
         return AVERROR_INVALIDDATA;
     length = avio_rl16(pb);
     if (length < 0x163C) {
         avpriv_request_sample(avctx, ""short SETUP header"");
         return AVERROR_INVALIDDATA;
     }
     avio_skip(pb, 616);  
     if (!avio_rl32(pb) ^ vflip) {
         st->codecpar->extradata  = av_strdup(""BottomUp"");
         st->codecpar->extradata_size  = 9;
     }
     avio_skip(pb, 4);  
     avpriv_set_pts_info(st, 64, 1, avio_rl32(pb));
     avio_skip(pb, 20);  
     set_metadata_int(&st->metadata, ""camera_version"", avio_rl32(pb), 0);
     set_metadata_int(&st->metadata, ""firmware_version"", avio_rl32(pb), 0);
     set_metadata_int(&st->metadata, ""software_version"", avio_rl32(pb), 0);
     set_metadata_int(&st->metadata, ""recording_timezone"", avio_rl32(pb), 0);
     CFA = avio_rl32(pb);
     set_metadata_int(&st->metadata, ""brightness"", avio_rl32(pb), 1);
     set_metadata_int(&st->metadata, ""contrast"", avio_rl32(pb), 1);
     set_metadata_int(&st->metadata, ""gamma"", avio_rl32(pb), 1);
     avio_skip(pb, 12 + 16);  
     set_metadata_float(&st->metadata, ""wbgain[0].r"", av_int2float(avio_rl32(pb)), 1);
     set_metadata_float(&st->metadata, ""wbgain[0].b"", av_int2float(avio_rl32(pb)), 1);
     avio_skip(pb, 36);  
     st->codecpar->bits_per_coded_sample = avio_rl32(pb);
     if (compression == CC_RGB) {
         if (biBitCount == 8) {
             st->codecpar->format = AV_PIX_FMT_GRAY8;
         } else if (biBitCount == 16) {
             st->codecpar->format = AV_PIX_FMT_GRAY16LE;
         } else if (biBitCount == 24) {
             st->codecpar->format = AV_PIX_FMT_BGR24;
         } else if (biBitCount == 48) {
             st->codecpar->format = AV_PIX_FMT_BGR48LE;
         } else {
             avpriv_request_sample(avctx, ""unsupported biBitCount %i"", biBitCount);
             return AVERROR_INVALIDDATA;
         }
     } else if (compression == CC_UNINT) {
         switch (CFA & 0xFFFFFF) {
         case CFA_BAYER:
             if (biBitCount == 8) {
                 st->codecpar->format = AV_PIX_FMT_BAYER_GBRG8;
             } else if (biBitCount == 16) {
                 st->codecpar->format = AV_PIX_FMT_BAYER_GBRG16LE;
             } else {
                 avpriv_request_sample(avctx, ""unsupported biBitCount %i"", biBitCount);
                 return AVERROR_INVALIDDATA;
             }
             break;
         case CFA_BAYERFLIP:
             if (biBitCount == 8) {
                 st->codecpar->format = AV_PIX_FMT_BAYER_RGGB8;
             } else if (biBitCount == 16) {
                 st->codecpar->format = AV_PIX_FMT_BAYER_RGGB16LE;
             } else {
                 avpriv_request_sample(avctx, ""unsupported biBitCount %i"", biBitCount);
                 return AVERROR_INVALIDDATA;
             }
             break;
         default:
            avpriv_request_sample(avctx, ""unsupported Color Field Array (CFA) %i"", CFA & 0xFFFFFF);
             return AVERROR_INVALIDDATA;
         }
     } else {  
         avpriv_request_sample(avctx, ""unsupported compression %i"", compression);
         return AVERROR_INVALIDDATA;
     }
     avio_skip(pb, 668);  
     set_metadata_int(&st->metadata, ""shutter_ns"", avio_rl32(pb), 0);
     avio_skip(pb, 24);  
 #define DESCRIPTION_SIZE 4096
     description = av_malloc(DESCRIPTION_SIZE + 1);
     if (!description)
         return AVERROR(ENOMEM);
     i = avio_get_str(pb, DESCRIPTION_SIZE, description, DESCRIPTION_SIZE + 1);
     if (i < DESCRIPTION_SIZE)
         avio_skip(pb, DESCRIPTION_SIZE - i);
     if (description[0])
         av_dict_set(&st->metadata, ""description"", description, AV_DICT_DONT_STRDUP_VAL);
     else
         av_free(description);
     avio_skip(pb, 1176);  
     set_metadata_int(&st->metadata, ""enable_crop"", avio_rl32(pb), 1);
     set_metadata_int(&st->metadata, ""crop_left"", avio_rl32(pb), 1);
     set_metadata_int(&st->metadata, ""crop_top"", avio_rl32(pb), 1);
     set_metadata_int(&st->metadata, ""crop_right"", avio_rl32(pb), 1);
     set_metadata_int(&st->metadata, ""crop_bottom"", avio_rl32(pb), 1);
      avio_seek(pb, offImageOffsets, SEEK_SET);
    for (i = 0; i < st->duration; i++)
     for (i = 0; i < st->duration; i++) {
         if (avio_feof(pb))
             return AVERROR_INVALIDDATA;
          av_add_index_entry(st, avio_rl64(pb), i, 0, 0, AVINDEX_KEYFRAME);
     }
      return 0;
  }","[146, 147, 148, 149, 151]","In FFmpeg 3.3.3, a DoS in cine_read_header() due to lack of an EOF check might cause huge CPU and memory consumption. When a crafted CINE file, which claims a large *duration* field in the header but does not contain sufficient backing data, is provided, the image-offset parsing loop would consume huge CPU and memory resources, since there is no EOF check inside the loop.",FFmpeg,CVE-2017-14059,CWE-834
1301,182240," static int insert_pin(
 	sc_pkcs15_card_t *p15card,
 	const char       *path,
 	unsigned char     id,
 	unsigned char     auth_id,
 	unsigned char     pin_reference,
 	int               min_length,
 	const char       *label,
 	int               pin_flags
 ){
 	sc_card_t *card=p15card->card;
 	sc_context_t *ctx=p15card->card->ctx;
 	sc_file_t *f;
 	struct sc_pkcs15_auth_info pin_info;
 	struct sc_pkcs15_object pin_obj;
 	int r;
 	memset(&pin_info, 0, sizeof(pin_info));
 	pin_info.auth_id.len      = 1;
 	pin_info.auth_id.value[0] = id;
 	pin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;
 	pin_info.attrs.pin.reference        = pin_reference;
 	pin_info.attrs.pin.flags            = pin_flags;
 	pin_info.attrs.pin.type             = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;
 	pin_info.attrs.pin.min_length       = min_length;
 	pin_info.attrs.pin.stored_length    = 16;
 	pin_info.attrs.pin.max_length       = 16;
 	pin_info.attrs.pin.pad_char         = '\0';
 	pin_info.logged_in = SC_PIN_STATE_UNKNOWN;
 	sc_format_path(path, &pin_info.path);
 	memset(&pin_obj, 0, sizeof(pin_obj));
 	strlcpy(pin_obj.label, label, sizeof(pin_obj.label));
 	pin_obj.flags            = SC_PKCS15_CO_FLAG_MODIFIABLE | SC_PKCS15_CO_FLAG_PRIVATE;
 	pin_obj.auth_id.len      = auth_id ? 0 : 1;
 	pin_obj.auth_id.value[0] = auth_id;
 	if(card->type==SC_CARD_TYPE_TCOS_V3){
 		unsigned char buf[256];
 		int i, rec_no=0;
 		if(pin_info.path.len>=2) pin_info.path.len-=2;
 		sc_append_file_id(&pin_info.path, 0x5049);
 		if(sc_select_file(card, &pin_info.path, NULL)!=SC_SUCCESS){
 			sc_debug(ctx, SC_LOG_DEBUG_NORMAL,
 				""Select(%s) failed\n"",
 				sc_print_path(&pin_info.path));
 			return 1;
 		}
 		sc_debug(ctx, SC_LOG_DEBUG_NORMAL,
 			""Searching for PIN-Ref %02X\n"", pin_reference);
 		while((r=sc_read_record(card, ++rec_no, buf, sizeof(buf), SC_RECORD_BY_REC_NR))>0){
 			int found=0, fbz=-1;
 			if(buf[0]!=0xA0) continue;
 			for(i=2;i<buf[1]+2;i+=2+buf[i+1]){
 				if(buf[i]==0x83 && buf[i+1]==1 && buf[i+2]==pin_reference) ++found;
 				if(buf[i]==0x90) fbz=buf[i+1+buf[i+1]];
 			}
 			if(found) pin_info.tries_left=fbz;
 			if(found) break;
 		}
 		if(r<=0){
 			sc_debug(ctx, SC_LOG_DEBUG_NORMAL,""No EF_PWDD-Record found\n"");
  			return 1;
  		}
  	} else {
		if(sc_select_file(card, &pin_info.path, &f)!=SC_SUCCESS){
 		if(sc_select_file(card, &pin_info.path, &f)!=SC_SUCCESS
 			   	|| !f->prop_attr || f->prop_attr_len < 4){
  			sc_debug(ctx, SC_LOG_DEBUG_NORMAL,""Select(%s) failed\n"", path);
  			return 1;
  		}
 		pin_info.tries_left=f->prop_attr[3];
 		sc_file_free(f);
 	}
 	r=sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);
 	if(r!=SC_SUCCESS){
 		sc_debug(ctx, SC_LOG_DEBUG_NORMAL, ""sc_pkcs15emu_add_pin_obj(%s) failed\n"", path);
 		return 4;
 	}
 	sc_debug(ctx, SC_LOG_DEBUG_NORMAL, ""%s: OK, FBZ=%d\n"", path, pin_info.tries_left);
 	return 0;
 }","[63, 64, 65]",Various out of bounds reads when handling responses in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to potentially crash the opensc library using programs.,OpenSC,CVE-2018-16427,CWE-125
1341,178620," ProcEstablishConnection(ClientPtr client)
 {
     const char *reason;
     char *auth_proto, *auth_string;
     xConnClientPrefix *prefix;
     REQUEST(xReq);
      prefix = (xConnClientPrefix *) ((char *) stuff + sz_xReq);
      auth_proto = (char *) prefix + sz_xConnClientPrefix;
      auth_string = auth_proto + pad_to_int32(prefix->nbytesAuthProto);
    if ((prefix->majorVersion != X_PROTOCOL) ||
     if ((client->req_len << 2) != sz_xReq + sz_xConnClientPrefix +
 	pad_to_int32(prefix->nbytesAuthProto) +
 	pad_to_int32(prefix->nbytesAuthString))
         reason = ""Bad length"";
     else if ((prefix->majorVersion != X_PROTOCOL) ||
          (prefix->minorVersion != X_PROTOCOL_REVISION))
          reason = ""Protocol version mismatch"";
      else
     return (SendConnSetup(client, reason));
 }","[10, 11, 12, 13, 14, 15]",xorg-x11-server before 1.19.5 was missing extra length validation in ProcEstablishConnection function allowing malicious X client to cause X server to crash or possibly execute arbitrary code.,xserver,CVE-2017-12176,CWE-20
1344,180803," on_handler_appeared(GDBusConnection *connection,
 		    const gchar     *name,
 		    const gchar     *name_owner,
 		    gpointer         user_data)
 {
 	struct tcmur_handler *handler = user_data;
 	struct dbus_info *info = handler->opaque;
  	if (info->register_invocation) {
  		info->connection = connection;
		tcmur_register_handler(handler);
 		tcmur_register_dbus_handler(handler);
  		dbus_export_handler(handler, G_CALLBACK(on_dbus_check_config));
  		g_dbus_method_invocation_return_value(info->register_invocation,
  			    g_variant_new(""(bs)"", TRUE, ""succeeded""));
 		info->register_invocation = NULL;
 	}
 }","[10, 11]",tcmu-runner version 1.0.5 to 1.2.0 is vulnerable to a dbus triggered NULL pointer dereference in the tcmu-runner daemon's on_unregister_handler() function resulting in denial of service,tcmu-runner,CVE-2017-1000200,CWE-476
1347,182226," decrypt_response(struct sc_card *card, unsigned char *in, unsigned char *out, size_t * out_len)
 decrypt_response(struct sc_card *card, unsigned char *in, size_t inlen, unsigned char *out, size_t * out_len)
  {
	size_t in_len;
 	size_t cipher_len;
  	size_t i;
  	unsigned char iv[16] = { 0 };
  	unsigned char plaintext[4096] = { 0 };
 	epass2003_exdata *exdata = NULL;
 	if (!card->drv_data) 
 		return SC_ERROR_INVALID_ARGUMENTS;
 	exdata = (epass2003_exdata *)card->drv_data;
 	if (in[0] == 0x99)
 		return 0;
  	if (0x01 == in[2] && 0x82 != in[1]) {
		in_len = in[1];
 		cipher_len = in[1];
  		i = 3;
  	}
  	else if (0x01 == in[3] && 0x81 == in[1]) {
		in_len = in[2];
 		cipher_len = in[2];
  		i = 4;
  	}
  	else if (0x01 == in[4] && 0x82 == in[1]) {
		in_len = in[2] * 0x100;
		in_len += in[3];
 		cipher_len = in[2] * 0x100;
 		cipher_len += in[3];
  		i = 5;
  	}
  	else {
  		return -1;
  	}
 	if (cipher_len < 2 || i+cipher_len > inlen || cipher_len > sizeof plaintext)
 		return -1;
  	if (KEY_TYPE_AES == exdata->smtype)
		aes128_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], in_len - 1, plaintext);
 		aes128_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], cipher_len - 1, plaintext);
  	else
		des3_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], in_len - 1, plaintext);
 		des3_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], cipher_len - 1, plaintext);
	while (0x80 != plaintext[in_len - 2] && (in_len - 2 > 0))
		in_len--;
 	while (0x80 != plaintext[cipher_len - 2] && (cipher_len - 2 > 0))
 		cipher_len--;
	if (2 == in_len)
 	if (2 == cipher_len)
  		return -1;
	memcpy(out, plaintext, in_len - 2);
	*out_len = in_len - 2;
 	memcpy(out, plaintext, cipher_len - 2);
 	*out_len = cipher_len - 2;
  	return 0;
  }","[2, 4, 5, 16, 17, 21, 22, 26, 27, 28, 29, 35, 36, 38, 39, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53]",Various out of bounds reads when handling responses in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to potentially crash the opensc library using programs.,OpenSC,CVE-2018-16427,CWE-125
1382,181890," static int jpc_ppm_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)
 {
 	jpc_ppm_t *ppm = &ms->parms.ppm;
  	cstate = 0;
	if (JAS_CAST(uint, jas_stream_write(out, (char *) ppm->data, ppm->len)) != ppm->len) {
 	if (JAS_CAST(jas_uint, jas_stream_write(out, (char *) ppm->data, ppm->len)) != ppm->len) {
  		return -1;
  	}
  	return 0;
 }","[5, 6]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
1409,181431," id3_skip (SF_PRIVATE * psf)
 {	unsigned char	buf [10] ;
 	memset (buf, 0, sizeof (buf)) ;
 	psf_binheader_readf (psf, ""pb"", 0, buf, 10) ;
 	if (buf [0] == 'I' && buf [1] == 'D' && buf [2] == '3')
 	{	int	offset = buf [6] & 0x7f ;
 		offset = (offset << 7) | (buf [7] & 0x7f) ;
 		offset = (offset << 7) | (buf [8] & 0x7f) ;
 		offset = (offset << 7) | (buf [9] & 0x7f) ;
 		psf_log_printf (psf, ""ID3 length : %d\n--------------------\n"", offset) ;
 		if (offset < 0)
 			return 0 ;
  		psf->fileoffset += offset + 10 ;
		psf_binheader_readf (psf, ""p"", psf->fileoffset) ;
		return 1 ;
 		if (psf->fileoffset < psf->filelength)
 		{	psf_binheader_readf (psf, ""p"", psf->fileoffset) ;
 			return 1 ;
 			} ;
  		} ;
  	return 0 ;
 }  ","[14, 15, 16, 17, 18, 19]","In libsndfile before 1.0.28, an error in the *header_read()* function (common.c) when handling ID3 tags can be exploited to cause a stack-based buffer overflow via a specially crafted FLAC file.",libsndfile,CVE-2017-7586,CWE-119
1424,179880,"  static int cg_rmdir(const char *path)
  {
  	struct fuse_context *fc = fuse_get_context();
	char *fpath = NULL, *cgdir = NULL, *controller;
 	char *fpath = NULL, *cgdir = NULL, *controller, *next = NULL;
  	const char *cgroup;
  	int ret;
 	if (!fc)
 		return -EIO;
 	controller = pick_controller_from_path(fc, path);
 	if (!controller)
 		return -EINVAL;
 	cgroup = find_cgroup_in_path(path);
 	if (!cgroup)
 		return -EINVAL;
 	get_cgdir_and_path(cgroup, &cgdir, &fpath);
 	if (!fpath) {
 		ret = -EINVAL;
  		goto out;
  	}
	fprintf(stderr, ""rmdir: verifying access to %s:%s (req path %s)\n"",
			controller, cgdir, path);
 	if (!caller_is_in_ancestor(fc->pid, controller, cgroup, &next)) {
 		if (!fpath || strcmp(next, fpath) == 0)
 			ret = -EBUSY;
 		else
 			ret = -ENOENT;
 		goto out;
 	}
  	if (!fc_may_access(fc, controller, cgdir, NULL, O_WRONLY)) {
  		ret = -EACCES;
  		goto out;
 	}
 	if (!caller_is_in_ancestor(fc->pid, controller, cgroup, NULL)) {
 		ret = -EACCES;
 		goto out;
 	}
 	if (!cgfs_remove(controller, cgroup)) {
 		ret = -EINVAL;
 		goto out;
 	}
 	ret = 0;
  out:
  	free(cgdir);
 	free(next);
  	return ret;
  }","[4, 5, 21, 22, 23, 24, 25, 26, 27, 28, 29, 45]","LXCFS before 0.12 does not properly enforce directory escapes, which might allow local users to gain privileges by (1) querying or (2) updating a cgroup.",lxcfs,CVE-2015-1342,CWE-264
1426,182756," static void ssdp_recv(int sd)
 {
  	ssize_t len;
  	struct sockaddr sa;
  	socklen_t salen;
	char buf[MAX_PKT_SIZE];
 	char buf[MAX_PKT_SIZE + 1];
  	memset(buf, 0, sizeof(buf));
	len = recvfrom(sd, buf, sizeof(buf), MSG_DONTWAIT, &sa, &salen);
 	len = recvfrom(sd, buf, sizeof(buf) - 1, MSG_DONTWAIT, &sa, &salen);
  	if (len > 0) {
		buf[len] = 0;
  		if (sa.sa_family != AF_INET)
  			return;
 		if (strstr(buf, ""M-SEARCH *"")) {
 			size_t i;
 			char *ptr, *type;
 			struct ifsock *ifs;
 			struct sockaddr_in *sin = (struct sockaddr_in *)&sa;
 			ifs = find_outbound(&sa);
 			if (!ifs) {
 				logit(LOG_DEBUG, ""No matching socket for client %s"", inet_ntoa(sin->sin_addr));
 				return;
 			}
 			logit(LOG_DEBUG, ""Matching socket for client %s"", inet_ntoa(sin->sin_addr));
 			type = strcasestr(buf, ""\r\nST:"");
 			if (!type) {
 				logit(LOG_DEBUG, ""No Search Type (ST:) found in M-SEARCH *, assuming "" SSDP_ST_ALL);
 				type = SSDP_ST_ALL;
 				send_message(ifs, type, &sa);
 				return;
 			}
 			type = strchr(type, ':');
 			if (!type)
 				return;
 			type++;
 			while (isspace(*type))
 				type++;
 			ptr = strstr(type, ""\r\n"");
 			if (!ptr)
 				return;
 			*ptr = 0;
 			for (i = 0; supported_types[i]; i++) {
 				if (!strcmp(supported_types[i], type)) {
 					logit(LOG_DEBUG, ""M-SEARCH * ST: %s from %s port %d"", type,
 					      inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));
 					send_message(ifs, type, &sa);
 					return;
 				}
 			}
 			logit(LOG_DEBUG, ""M-SEARCH * for unsupported ST: %s from %s"", type,
 			      inet_ntoa(sin->sin_addr));
 		}
 	}
 }","[6, 7, 9, 10, 12]","SSDP Responder 1.x through 1.5 mishandles incoming network messages, leading to a stack-based buffer overflow by 1 byte. This results in a crash of the server, but only when strict stack checking is enabled. This is caused by an off-by-one error in ssdp_recv in ssdpd.c.",ssdp-responder,CVE-2019-14323,CWE-119
1446,182361," av_cold void ff_idctdsp_init(IDCTDSPContext *c, AVCodecContext *avctx)
 {
     const unsigned high_bit_depth = avctx->bits_per_raw_sample > 8;
     if (avctx->lowres==1) {
         c->idct_put  = ff_jref_idct4_put;
         c->idct_add  = ff_jref_idct4_add;
         c->idct      = ff_j_rev_dct4;
         c->perm_type = FF_IDCT_PERM_NONE;
     } else if (avctx->lowres==2) {
         c->idct_put  = ff_jref_idct2_put;
         c->idct_add  = ff_jref_idct2_add;
         c->idct      = ff_j_rev_dct2;
         c->perm_type = FF_IDCT_PERM_NONE;
     } else if (avctx->lowres==3) {
         c->idct_put  = ff_jref_idct1_put;
         c->idct_add  = ff_jref_idct1_add;
         c->idct      = ff_j_rev_dct1;
         c->perm_type = FF_IDCT_PERM_NONE;
     } else {
          if (avctx->bits_per_raw_sample == 10 || avctx->bits_per_raw_sample == 9) {
            if (avctx->codec_id == AV_CODEC_ID_MPEG4 && avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO)
             if (c->mpeg4_studio_profile)
                  c->idct_put              = ff_simple_idct_put_int32_10bit;
              else {
                  c->idct_put              = ff_simple_idct_put_int16_10bit;
                 c->idct_add              = ff_simple_idct_add_int16_10bit;
                 c->idct                  = ff_simple_idct_int16_10bit;
             }
             c->perm_type             = FF_IDCT_PERM_NONE;
         } else if (avctx->bits_per_raw_sample == 12) {
             c->idct_put              = ff_simple_idct_put_int16_12bit;
             c->idct_add              = ff_simple_idct_add_int16_12bit;
             c->idct                  = ff_simple_idct_int16_12bit;
             c->perm_type             = FF_IDCT_PERM_NONE;
         } else {
             if (avctx->idct_algo == FF_IDCT_INT) {
                 c->idct_put  = ff_jref_idct_put;
                 c->idct_add  = ff_jref_idct_add;
                 c->idct      = ff_j_rev_dct;
                 c->perm_type = FF_IDCT_PERM_LIBMPEG2;
 #if CONFIG_FAANIDCT
             } else if (avctx->idct_algo == FF_IDCT_FAAN) {
                 c->idct_put  = ff_faanidct_put;
                 c->idct_add  = ff_faanidct_add;
                 c->idct      = ff_faanidct;
                 c->perm_type = FF_IDCT_PERM_NONE;
 #endif  
             } else {  
                 c->idct_put  = ff_simple_idct_put_int16_8bit;
                 c->idct_add  = ff_simple_idct_add_int16_8bit;
                 c->idct      = ff_simple_idct_int16_8bit;
                 c->perm_type = FF_IDCT_PERM_NONE;
             }
         }
     }
     c->put_pixels_clamped        = ff_put_pixels_clamped_c;
     c->put_signed_pixels_clamped = put_signed_pixels_clamped_c;
     c->add_pixels_clamped        = ff_add_pixels_clamped_c;
     if (CONFIG_MPEG4_DECODER && avctx->idct_algo == FF_IDCT_XVID)
         ff_xvid_idct_init(c, avctx);
     if (ARCH_AARCH64)
         ff_idctdsp_init_aarch64(c, avctx, high_bit_depth);
     if (ARCH_ALPHA)
         ff_idctdsp_init_alpha(c, avctx, high_bit_depth);
     if (ARCH_ARM)
         ff_idctdsp_init_arm(c, avctx, high_bit_depth);
     if (ARCH_PPC)
         ff_idctdsp_init_ppc(c, avctx, high_bit_depth);
     if (ARCH_X86)
         ff_idctdsp_init_x86(c, avctx, high_bit_depth);
     if (ARCH_MIPS)
         ff_idctdsp_init_mips(c, avctx, high_bit_depth);
     ff_init_scantable_permutation(c->idct_permutation,
                                   c->perm_type);
 }","[21, 22]","libavcodec in FFmpeg 4.0 may trigger a NULL pointer dereference if the studio profile is incorrectly detected while converting a crafted AVI file to MPEG4, leading to a denial of service, related to idctdsp.c and mpegvideo.c.",FFmpeg,CVE-2018-12460,CWE-476
1463,180936," static int nsv_parse_NSVf_header(AVFormatContext *s)
 {
     NSVContext *nsv = s->priv_data;
     AVIOContext *pb = s->pb;
     unsigned int av_unused file_size;
     unsigned int size;
     int64_t duration;
     int strings_size;
     int table_entries;
     int table_entries_used;
     nsv->state = NSV_UNSYNC;  
     size = avio_rl32(pb);
     if (size < 28)
         return -1;
     nsv->NSVf_end = size;
     file_size = (uint32_t)avio_rl32(pb);
     av_log(s, AV_LOG_TRACE, ""NSV NSVf chunk_size %u\n"", size);
     av_log(s, AV_LOG_TRACE, ""NSV NSVf file_size %u\n"", file_size);
     nsv->duration = duration = avio_rl32(pb);  
     av_log(s, AV_LOG_TRACE, ""NSV NSVf duration %""PRId64"" ms\n"", duration);
     strings_size = avio_rl32(pb);
     table_entries = avio_rl32(pb);
     table_entries_used = avio_rl32(pb);
     av_log(s, AV_LOG_TRACE, ""NSV NSVf info-strings size: %d, table entries: %d, bis %d\n"",
             strings_size, table_entries, table_entries_used);
     if (avio_feof(pb))
         return -1;
     av_log(s, AV_LOG_TRACE, ""NSV got header; filepos %""PRId64""\n"", avio_tell(pb));
     if (strings_size > 0) {
         char *strings;  
         char *p, *endp;
         char *token, *value;
         char quote;
         p = strings = av_mallocz((size_t)strings_size + 1);
         if (!p)
             return AVERROR(ENOMEM);
         endp = strings + strings_size;
         avio_read(pb, strings, strings_size);
         while (p < endp) {
             while (*p == ' ')
                 p++;  
             if (p >= endp-2)
                 break;
             token = p;
             p = strchr(p, '=');
             if (!p || p >= endp-2)
                 break;
             *p++ = '\0';
             quote = *p++;
             value = p;
             p = strchr(p, quote);
             if (!p || p >= endp)
                 break;
             *p++ = '\0';
             av_log(s, AV_LOG_TRACE, ""NSV NSVf INFO: %s='%s'\n"", token, value);
             av_dict_set(&s->metadata, token, value, 0);
         }
         av_free(strings);
     }
     if (avio_feof(pb))
         return -1;
     av_log(s, AV_LOG_TRACE, ""NSV got infos; filepos %""PRId64""\n"", avio_tell(pb));
     if (table_entries_used > 0) {
         int i;
         nsv->index_entries = table_entries_used;
         if((unsigned)table_entries_used >= UINT_MAX / sizeof(uint32_t))
             return -1;
         nsv->nsvs_file_offset = av_malloc_array((unsigned)table_entries_used, sizeof(uint32_t));
          if (!nsv->nsvs_file_offset)
              return AVERROR(ENOMEM);
        for(i=0;i<table_entries_used;i++)
         for(i=0;i<table_entries_used;i++) {
             if (avio_feof(pb))
                 return AVERROR_INVALIDDATA;
              nsv->nsvs_file_offset[i] = avio_rl32(pb) + size;
         }
          if(table_entries > table_entries_used &&
             avio_rl32(pb) == MKTAG('T','O','C','2')) {
             nsv->nsvs_timestamps = av_malloc_array((unsigned)table_entries_used, sizeof(uint32_t));
             if (!nsv->nsvs_timestamps)
                 return AVERROR(ENOMEM);
             for(i=0;i<table_entries_used;i++) {
                 nsv->nsvs_timestamps[i] = avio_rl32(pb);
             }
         }
     }
     av_log(s, AV_LOG_TRACE, ""NSV got index; filepos %""PRId64""\n"", avio_tell(pb));
     avio_seek(pb, nsv->base_offset + size, SEEK_SET);  
     if (avio_feof(pb))
         return -1;
     nsv->state = NSV_HAS_READ_NSVF;
     return 0;
 }","[71, 72, 73, 74, 76]","In libavformat/nsvdec.c in FFmpeg 3.3.3, a DoS in nsv_parse_NSVf_header() due to lack of an EOF (End of File) check might cause huge CPU consumption. When a crafted NSV file, which claims a large *table_entries_used* field in the header but does not contain sufficient backing data, is provided, the loop over 'table_entries_used' would consume huge CPU resources, since there is no EOF check inside the loop.",FFmpeg,CVE-2017-14171,CWE-834
1478,179087," static int g2m_init_buffers(G2MContext *c)
 {
      int aligned_height;
      if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) {
        c->framebuf_stride = FFALIGN(c->width * 3, 16);
        aligned_height     = FFALIGN(c->height,    16);
         c->framebuf_stride = FFALIGN(c->width + 15, 16) * 3;
         aligned_height     = c->height + 15;
          av_free(c->framebuf);
          c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);
          if (!c->framebuf)
             return AVERROR(ENOMEM);
     }
     if (!c->synth_tile || !c->jpeg_tile ||
         c->old_tile_w < c->tile_width ||
         c->old_tile_h < c->tile_height) {
         c->tile_stride = FFALIGN(c->tile_width, 16) * 3;
         aligned_height = FFALIGN(c->tile_height,    16);
         av_free(c->synth_tile);
         av_free(c->jpeg_tile);
         av_free(c->kempf_buf);
         av_free(c->kempf_flags);
         c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);
         c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);
         c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height
                                     + FF_INPUT_BUFFER_PADDING_SIZE);
         c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);
         if (!c->synth_tile || !c->jpeg_tile ||
             !c->kempf_buf || !c->kempf_flags)
             return AVERROR(ENOMEM);
     }
     return 0;
 }","[5, 6, 7, 8]","The g2m_init_buffers function in libavcodec/g2meet.c in FFmpeg before 2.1 does not properly allocate memory for tiles, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted Go2Webinar data.",FFmpeg,CVE-2013-7022,CWE-119
1509,182339," GF_Err urn_Read(GF_Box *s, GF_BitStream *bs)
 {
 	u32 i, to_read;
 	char *tmpName;
 	GF_DataEntryURNBox *ptr = (GF_DataEntryURNBox *)s;
 	if (! ptr->size ) return GF_OK;
 	to_read = (u32) ptr->size;
 	tmpName = (char*)gf_malloc(sizeof(char) * to_read);
 	if (!tmpName) return GF_OUT_OF_MEM;
 	gf_bs_read_data(bs, tmpName, to_read);
  	i = 0;
	while ( (tmpName[i] != 0) && (i < to_read) ) {
 	while ( (i < to_read) && (tmpName[i] != 0) ) {
  		i++;
  	}
 	if (i == to_read) {
 		gf_free(tmpName);
 		return GF_ISOM_INVALID_FILE;
 	}
 	if (i == to_read - 1) {
 		ptr->nameURN = tmpName;
 		ptr->location = NULL;
 		return GF_OK;
 	}
 	ptr->nameURN = (char*)gf_malloc(sizeof(char) * (i+1));
 	if (!ptr->nameURN) {
 		gf_free(tmpName);
 		return GF_OUT_OF_MEM;
 	}
 	ptr->location = (char*)gf_malloc(sizeof(char) * (to_read - i - 1));
 	if (!ptr->location) {
 		gf_free(tmpName);
 		gf_free(ptr->nameURN);
 		ptr->nameURN = NULL;
 		return GF_OUT_OF_MEM;
 	}
 	memcpy(ptr->nameURN, tmpName, i + 1);
 	memcpy(ptr->location, tmpName + i + 1, (to_read - i - 1));
 	gf_free(tmpName);
 	return GF_OK;
 }","[12, 13]",An issue was discovered in MP4Box in GPAC 0.7.1. There is a heap-based buffer over-read in the isomedia/box_dump.c function hdlr_dump.,gpac,CVE-2018-13006,CWE-125
1510,182517," w3m_exit(int i)
 {
 #ifdef USE_MIGEMO
     init_migemo();		 
 #endif
     stopDownload();
     deleteFiles();
 #ifdef USE_SSL
     free_ssl_ctx();
 #endif
     disconnectFTP();
 #ifdef USE_NNTP
     disconnectNews();
  #endif
  #ifdef __MINGW32_VERSION
      WSACleanup();
 #endif
 #ifdef HAVE_MKDTEMP
     if (no_rc_dir && tmp_dir != rc_dir)
 	if (rmdir(tmp_dir) != 0) {
 	    fprintf(stderr, ""Can't remove temporary directory (%s)!\n"", tmp_dir);
 	    exit(1);
 	}
  #endif
      exit(i);
  }","[17, 18, 19, 20, 21, 22, 23]","w3m through 0.5.3 does not properly handle temporary files when the ~/.w3m directory is unwritable, which allows a local attacker to craft a symlink attack to overwrite arbitrary files.",w3m,CVE-2018-6198,CWE-59
1512,181887," jas_image_t *jp2_decode(jas_stream_t *in, char *optstr)
 {
 	jp2_box_t *box;
 	int found;
 	jas_image_t *image;
 	jp2_dec_t *dec;
 	bool samedtype;
 	int dtype;
 	unsigned int i;
 	jp2_cmap_t *cmapd;
 	jp2_pclr_t *pclrd;
 	jp2_cdef_t *cdefd;
 	unsigned int channo;
 	int newcmptno;
 	int_fast32_t *lutents;
 #if 0
 	jp2_cdefchan_t *cdefent;
 	int cmptno;
 #endif
 	jp2_cmapent_t *cmapent;
 	jas_icchdr_t icchdr;
 	jas_iccprof_t *iccprof;
 	dec = 0;
 	box = 0;
 	image = 0;
 	if (!(dec = jp2_dec_create())) {
 		goto error;
 	}
 	if (!(box = jp2_box_get(in))) {
 		jas_eprintf(""error: cannot get box\n"");
 		goto error;
 	}
 	if (box->type != JP2_BOX_JP) {
 		jas_eprintf(""error: expecting signature box\n"");
 		goto error;
 	}
 	if (box->data.jp.magic != JP2_JP_MAGIC) {
 		jas_eprintf(""incorrect magic number\n"");
 		goto error;
 	}
 	jp2_box_destroy(box);
 	box = 0;
 	if (!(box = jp2_box_get(in))) {
 		goto error;
 	}
 	if (box->type != JP2_BOX_FTYP) {
 		jas_eprintf(""expecting file type box\n"");
 		goto error;
 	}
 	jp2_box_destroy(box);
 	box = 0;
 	found = 0;
 	while ((box = jp2_box_get(in))) {
 		if (jas_getdbglevel() >= 1) {
 			jas_eprintf(""got box type %s\n"", box->info->name);
 		}
 		switch (box->type) {
 		case JP2_BOX_JP2C:
 			found = 1;
 			break;
 		case JP2_BOX_IHDR:
 			if (!dec->ihdr) {
 				dec->ihdr = box;
 				box = 0;
 			}
 			break;
 		case JP2_BOX_BPCC:
 			if (!dec->bpcc) {
 				dec->bpcc = box;
 				box = 0;
 			}
 			break;
 		case JP2_BOX_CDEF:
 			if (!dec->cdef) {
 				dec->cdef = box;
 				box = 0;
 			}
 			break;
 		case JP2_BOX_PCLR:
 			if (!dec->pclr) {
 				dec->pclr = box;
 				box = 0;
 			}
 			break;
 		case JP2_BOX_CMAP:
 			if (!dec->cmap) {
 				dec->cmap = box;
 				box = 0;
 			}
 			break;
 		case JP2_BOX_COLR:
 			if (!dec->colr) {
 				dec->colr = box;
 				box = 0;
 			}
 			break;
 		}
 		if (box) {
 			jp2_box_destroy(box);
 			box = 0;
 		}
 		if (found) {
 			break;
 		}
 	}
 	if (!found) {
 		jas_eprintf(""error: no code stream found\n"");
 		goto error;
 	}
 	if (!(dec->image = jpc_decode(in, optstr))) {
 		jas_eprintf(""error: cannot decode code stream\n"");
 		goto error;
 	}
 	if (!dec->ihdr) {
 		jas_eprintf(""error: missing IHDR box\n"");
 		goto error;
 	}
	if (dec->ihdr->data.ihdr.numcmpts != JAS_CAST(uint,
 	if (dec->ihdr->data.ihdr.numcmpts != JAS_CAST(jas_uint,
  	  jas_image_numcmpts(dec->image))) {
  		jas_eprintf(""warning: number of components mismatch\n"");
  	}
 	if (!jas_image_numcmpts(dec->image)) {
 		jas_eprintf(""error: no components\n"");
 		goto error;
 	}
  	samedtype = true;
  	dtype = jas_image_cmptdtype(dec->image, 0);
	for (i = 1; i < JAS_CAST(uint, jas_image_numcmpts(dec->image)); ++i) {
 	for (i = 1; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image)); ++i) {
  		if (jas_image_cmptdtype(dec->image, i) != dtype) {
  			samedtype = false;
  			break;
 		}
 	}
 	if ((samedtype && dec->ihdr->data.ihdr.bpc != JP2_DTYPETOBPC(dtype)) ||
 	  (!samedtype && dec->ihdr->data.ihdr.bpc != JP2_IHDR_BPCNULL)) {
 		jas_eprintf(""warning: component data type mismatch\n"");
 	}
 	if (dec->ihdr->data.ihdr.comptype != JP2_IHDR_COMPTYPE) {
 		jas_eprintf(""error: unsupported compression type\n"");
 		goto error;
 	}
  	if (dec->bpcc) {
		if (dec->bpcc->data.bpcc.numcmpts != JAS_CAST(uint, jas_image_numcmpts(
 		if (dec->bpcc->data.bpcc.numcmpts != JAS_CAST(jas_uint, jas_image_numcmpts(
  		  dec->image))) {
  			jas_eprintf(""warning: number of components mismatch\n"");
  		}
  		if (!samedtype) {
			for (i = 0; i < JAS_CAST(uint, jas_image_numcmpts(dec->image));
 			for (i = 0; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image));
  			  ++i) {
  				if (jas_image_cmptdtype(dec->image, i) !=
  				  JP2_BPCTODTYPE(dec->bpcc->data.bpcc.bpcs[i])) {
 					jas_eprintf(""warning: component data type mismatch\n"");
 				}
 			}
 		} else {
 			jas_eprintf(""warning: superfluous BPCC box\n"");
 		}
 	}
 	if (!dec->colr) {
 		jas_eprintf(""error: no COLR box\n"");
 		goto error;
 	}
 	switch (dec->colr->data.colr.method) {
 	case JP2_COLR_ENUM:
 		jas_image_setclrspc(dec->image, jp2_getcs(&dec->colr->data.colr));
 		break;
 	case JP2_COLR_ICC:
 		iccprof = jas_iccprof_createfrombuf(dec->colr->data.colr.iccp,
 		  dec->colr->data.colr.iccplen);
 		if (!iccprof) {
 			jas_eprintf(""error: failed to parse ICC profile\n"");
 			goto error;
 		}
 		jas_iccprof_gethdr(iccprof, &icchdr);
 		jas_eprintf(""ICC Profile CS %08x\n"", icchdr.colorspc);
 		jas_image_setclrspc(dec->image, fromiccpcs(icchdr.colorspc));
 		dec->image->cmprof_ = jas_cmprof_createfromiccprof(iccprof);
 		assert(dec->image->cmprof_);
 		jas_iccprof_destroy(iccprof);
 		break;
 	}
 	if (dec->cmap && !dec->pclr) {
 		jas_eprintf(""warning: missing PCLR box or superfluous CMAP box\n"");
 		jp2_box_destroy(dec->cmap);
 		dec->cmap = 0;
 	}
 	if (!dec->cmap && dec->pclr) {
 		jas_eprintf(""warning: missing CMAP box or superfluous PCLR box\n"");
 		jp2_box_destroy(dec->pclr);
 		dec->pclr = 0;
 	}
  	dec->numchans = dec->cmap ? dec->cmap->data.cmap.numchans :
	  JAS_CAST(uint, jas_image_numcmpts(dec->image));
 	  JAS_CAST(jas_uint, jas_image_numcmpts(dec->image));
  	if (dec->cmap) {
  		for (i = 0; i < dec->numchans; ++i) {
			if (dec->cmap->data.cmap.ents[i].cmptno >= JAS_CAST(uint,
 			if (dec->cmap->data.cmap.ents[i].cmptno >= JAS_CAST(jas_uint,
  			  jas_image_numcmpts(dec->image))) {
  				jas_eprintf(""error: invalid component number in CMAP box\n"");
  				goto error;
 			}
 			if (dec->cmap->data.cmap.ents[i].pcol >=
 			  dec->pclr->data.pclr.numchans) {
 				jas_eprintf(""error: invalid CMAP LUT index\n"");
 				goto error;
 			}
 		}
 	}
 	if (!(dec->chantocmptlut = jas_alloc2(dec->numchans,
 	  sizeof(uint_fast16_t)))) {
 		jas_eprintf(""error: no memory\n"");
 		goto error;
 	}
 	if (!dec->cmap) {
 		for (i = 0; i < dec->numchans; ++i) {
 			dec->chantocmptlut[i] = i;
 		}
 	} else {
 		cmapd = &dec->cmap->data.cmap;
 		pclrd = &dec->pclr->data.pclr;
 		cdefd = &dec->cdef->data.cdef;
 		for (channo = 0; channo < cmapd->numchans; ++channo) {
 			cmapent = &cmapd->ents[channo];
 			if (cmapent->map == JP2_CMAP_DIRECT) {
 				dec->chantocmptlut[channo] = channo;
 			} else if (cmapent->map == JP2_CMAP_PALETTE) {
 				lutents = jas_alloc2(pclrd->numlutents, sizeof(int_fast32_t));
 				for (i = 0; i < pclrd->numlutents; ++i) {
 					lutents[i] = pclrd->lutdata[cmapent->pcol + i * pclrd->numchans];
 				}
 				newcmptno = jas_image_numcmpts(dec->image);
 				jas_image_depalettize(dec->image, cmapent->cmptno,
 				  pclrd->numlutents, lutents,
 				  JP2_BPCTODTYPE(pclrd->bpc[cmapent->pcol]), newcmptno);
 				dec->chantocmptlut[channo] = newcmptno;
 				jas_free(lutents);
 #if 0
 				if (dec->cdef) {
 					cdefent = jp2_cdef_lookup(cdefd, channo);
 					if (!cdefent) {
 						abort();
 					}
 				jas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), cdefent->type, cdefent->assoc));
 				} else {
 				jas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), 0, channo + 1));
 				}
 #endif
 			}
 		}
 	}
	for (i = 0; i < JAS_CAST(uint, jas_image_numcmpts(dec->image)); ++i) {
 	for (i = 0; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image)); ++i) {
  		jas_image_setcmpttype(dec->image, i, JAS_IMAGE_CT_UNKNOWN);
  	}
 	if (dec->cdef) {
 		for (i = 0; i < dec->numchans; ++i) {
 			if (dec->cdef->data.cdef.ents[i].channo >= dec->numchans) {
 				jas_eprintf(""error: invalid channel number in CDEF box\n"");
 				goto error;
 			}
 			jas_image_setcmpttype(dec->image,
 			  dec->chantocmptlut[dec->cdef->data.cdef.ents[i].channo],
 			  jp2_getct(jas_image_clrspc(dec->image),
 			  dec->cdef->data.cdef.ents[i].type,
 			  dec->cdef->data.cdef.ents[i].assoc));
 		}
 	} else {
 		for (i = 0; i < dec->numchans; ++i) {
 			jas_image_setcmpttype(dec->image, dec->chantocmptlut[i],
 			  jp2_getct(jas_image_clrspc(dec->image), 0, i + 1));
 		}
 	}
 	for (i = jas_image_numcmpts(dec->image); i > 0; --i) {
 		if (jas_image_cmpttype(dec->image, i - 1) == JAS_IMAGE_CT_UNKNOWN) {
 			jas_image_delcmpt(dec->image, i - 1);
 		}
 	}
 	if (!jas_image_numcmpts(dec->image)) {
 		jas_eprintf(""error: no components\n"");
 		goto error;
 	}
 #if 0
 jas_eprintf(""no of components is %d\n"", jas_image_numcmpts(dec->image));
 #endif
 	image = dec->image;
 	dec->image = 0;
 	jp2_dec_destroy(dec);
 	return image;
 error:
 	if (box) {
 		jp2_box_destroy(box);
 	}
 	if (dec) {
 		jp2_dec_destroy(dec);
 	}
 	return 0;
 }","[118, 119, 129, 130, 145, 146, 151, 152, 197, 198, 201, 202, 256, 257]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
1516,182867," archive_read_format_zip_cleanup(struct archive_read *a)
 {
 	struct zip *zip;
 	struct zip_entry *zip_entry, *next_zip_entry;
 	zip = (struct zip *)(a->format->data);
 #ifdef HAVE_ZLIB_H
 	if (zip->stream_valid)
  		inflateEnd(&zip->stream);
  #endif
#if HAVA_LZMA_H && HAVE_LIBLZMA
 #if HAVE_LZMA_H && HAVE_LIBLZMA
      if (zip->zipx_lzma_valid) {
  		lzma_end(&zip->zipx_lzma_stream);
  	}
 #endif
 #ifdef HAVE_BZLIB_H
 	if (zip->bzstream_valid) {
 		BZ2_bzDecompressEnd(&zip->bzstream);
 	}
 #endif
 	free(zip->uncompressed_buffer);
 	if (zip->ppmd8_valid)
 		__archive_ppmd8_functions.Ppmd8_Free(&zip->ppmd8);
 	if (zip->zip_entries) {
 		zip_entry = zip->zip_entries;
 		while (zip_entry != NULL) {
 			next_zip_entry = zip_entry->next;
 			archive_string_free(&zip_entry->rsrcname);
 			free(zip_entry);
 			zip_entry = next_zip_entry;
 		}
 	}
 	free(zip->decrypted_buffer);
 	if (zip->cctx_valid)
 		archive_decrypto_aes_ctr_release(&zip->cctx);
 	if (zip->hctx_valid)
 		archive_hmac_sha1_cleanup(&zip->hctx);
 	free(zip->iv);
 	free(zip->erd);
 	free(zip->v_data);
 	archive_string_free(&zip->format_name);
 	free(zip);
 	(a->format->data) = NULL;
 	return (ARCHIVE_OK);
 }","[10, 11]",A memory leak in archive_read_format_zip_cleanup in archive_read_support_format_zip.c in libarchive 3.3.4-dev allows remote attackers to cause a denial of service via a crafted ZIP file because of a HAVE_LZMA_H typo. NOTE: this only affects users who downloaded the development code from GitHub. Users of the product's official releases are unaffected.,libarchive,CVE-2019-11463,CWE-399
1520,179096," static int flashsv_decode_frame(AVCodecContext *avctx, void *data,
                                 int *got_frame, AVPacket *avpkt)
 {
     int buf_size       = avpkt->size;
     FlashSVContext *s  = avctx->priv_data;
     int h_blocks, v_blocks, h_part, v_part, i, j, ret;
     GetBitContext gb;
     int last_blockwidth = s->block_width;
     int last_blockheight= s->block_height;
     if (buf_size == 0)
         return 0;
     if (buf_size < 4)
         return -1;
     init_get_bits(&gb, avpkt->data, buf_size * 8);
     s->block_width  = 16 * (get_bits(&gb,  4) + 1);
     s->image_width  =       get_bits(&gb, 12);
     s->block_height = 16 * (get_bits(&gb,  4) + 1);
     s->image_height =       get_bits(&gb, 12);
     if (   last_blockwidth != s->block_width
         || last_blockheight!= s->block_height)
         av_freep(&s->blocks);
     if (s->ver == 2) {
         skip_bits(&gb, 6);
         if (get_bits1(&gb)) {
             avpriv_request_sample(avctx, ""iframe"");
             return AVERROR_PATCHWELCOME;
         }
         if (get_bits1(&gb)) {
             avpriv_request_sample(avctx, ""Custom palette"");
             return AVERROR_PATCHWELCOME;
         }
     }
     h_blocks = s->image_width  / s->block_width;
     h_part   = s->image_width  % s->block_width;
     v_blocks = s->image_height / s->block_height;
     v_part   = s->image_height % s->block_height;
     if (s->block_size < s->block_width * s->block_height) {
         int tmpblock_size = 3 * s->block_width * s->block_height;
         s->tmpblock = av_realloc(s->tmpblock, tmpblock_size);
         if (!s->tmpblock) {
             av_log(avctx, AV_LOG_ERROR, ""Can't allocate decompression buffer.\n"");
             return AVERROR(ENOMEM);
         }
         if (s->ver == 2) {
             s->deflate_block_size = calc_deflate_block_size(tmpblock_size);
             if (s->deflate_block_size <= 0) {
                 av_log(avctx, AV_LOG_ERROR, ""Can't determine deflate buffer size.\n"");
                 return -1;
             }
             s->deflate_block = av_realloc(s->deflate_block, s->deflate_block_size);
             if (!s->deflate_block) {
                 av_log(avctx, AV_LOG_ERROR, ""Can't allocate deflate buffer.\n"");
                 return AVERROR(ENOMEM);
             }
         }
     }
     s->block_size = s->block_width * s->block_height;
     if (avctx->width == 0 && avctx->height == 0) {
         avcodec_set_dimensions(avctx, s->image_width, s->image_height);
     }
     if (avctx->width != s->image_width || avctx->height != s->image_height) {
         av_log(avctx, AV_LOG_ERROR,
                ""Frame width or height differs from first frame!\n"");
         av_log(avctx, AV_LOG_ERROR, ""fh = %d, fv %d  vs  ch = %d, cv = %d\n"",
                avctx->height, avctx->width, s->image_height, s->image_width);
         return AVERROR_INVALIDDATA;
     }
     s->is_keyframe = (avpkt->flags & AV_PKT_FLAG_KEY) && (s->ver == 2);
     if (s->is_keyframe) {
         s->keyframedata = av_realloc(s->keyframedata, avpkt->size);
         memcpy(s->keyframedata, avpkt->data, avpkt->size);
     }
     if(s->ver == 2 && !s->blocks)
         s->blocks = av_mallocz((v_blocks + !!v_part) * (h_blocks + !!h_part)
                                 * sizeof(s->blocks[0]));
     av_dlog(avctx, ""image: %dx%d block: %dx%d num: %dx%d part: %dx%d\n"",
             s->image_width, s->image_height, s->block_width, s->block_height,
             h_blocks, v_blocks, h_part, v_part);
     if ((ret = ff_reget_buffer(avctx, &s->frame)) < 0)
         return ret;
     for (j = 0; j < v_blocks + (v_part ? 1 : 0); j++) {
         int y_pos  = j * s->block_height;  
         int cur_blk_height = (j < v_blocks) ? s->block_height : v_part;
         for (i = 0; i < h_blocks + (h_part ? 1 : 0); i++) {
             int x_pos = i * s->block_width;  
             int cur_blk_width = (i < h_blocks) ? s->block_width : h_part;
             int has_diff = 0;
             int size = get_bits(&gb, 16);
             s->color_depth    = 0;
             s->zlibprime_curr = 0;
             s->zlibprime_prev = 0;
             s->diff_start     = 0;
             s->diff_height    = cur_blk_height;
             if (8 * size > get_bits_left(&gb)) {
                 av_frame_unref(&s->frame);
                 return AVERROR_INVALIDDATA;
             }
             if (s->ver == 2 && size) {
                 skip_bits(&gb, 3);
                 s->color_depth    = get_bits(&gb, 2);
                 has_diff          = get_bits1(&gb);
                 s->zlibprime_curr = get_bits1(&gb);
                 s->zlibprime_prev = get_bits1(&gb);
                 if (s->color_depth != 0 && s->color_depth != 2) {
                     av_log(avctx, AV_LOG_ERROR,
                            ""%dx%d invalid color depth %d\n"", i, j, s->color_depth);
                     return AVERROR_INVALIDDATA;
                 }
                 if (has_diff) {
                     if (!s->keyframe) {
                         av_log(avctx, AV_LOG_ERROR,
                                ""inter frame without keyframe\n"");
                         return AVERROR_INVALIDDATA;
                      }
                      s->diff_start  = get_bits(&gb, 8);
                      s->diff_height = get_bits(&gb, 8);
                     if (s->diff_start + s->diff_height > cur_blk_height) {
                         av_log(avctx, AV_LOG_ERROR, ""Block parameters invalid\n"");
                         return AVERROR_INVALIDDATA;
                     }
                      av_log(avctx, AV_LOG_DEBUG,
                             ""%dx%d diff start %d height %d\n"",
                             i, j, s->diff_start, s->diff_height);
                     size -= 2;
                 }
                 if (s->zlibprime_prev)
                     av_log(avctx, AV_LOG_DEBUG, ""%dx%d zlibprime_prev\n"", i, j);
                 if (s->zlibprime_curr) {
                     int col = get_bits(&gb, 8);
                     int row = get_bits(&gb, 8);
                     av_log(avctx, AV_LOG_DEBUG, ""%dx%d zlibprime_curr %dx%d\n"", i, j, col, row);
                     size -= 2;
                     avpriv_request_sample(avctx, ""zlibprime_curr"");
                     return AVERROR_PATCHWELCOME;
                 }
                 if (!s->blocks && (s->zlibprime_curr || s->zlibprime_prev)) {
                     av_log(avctx, AV_LOG_ERROR, ""no data available for zlib ""
                            ""priming\n"");
                     return AVERROR_INVALIDDATA;
                 }
                 size--;  
             }
             if (has_diff) {
                 int k;
                 int off = (s->image_height - y_pos - 1) * s->frame.linesize[0];
                 for (k = 0; k < cur_blk_height; k++)
                     memcpy(s->frame.data[0] + off - k*s->frame.linesize[0] + x_pos*3,
                            s->keyframe + off - k*s->frame.linesize[0] + x_pos*3,
                            cur_blk_width * 3);
             }
             if (size) {
                 if (flashsv_decode_block(avctx, avpkt, &gb, size,
                                          cur_blk_width, cur_blk_height,
                                          x_pos, y_pos,
                                          i + j * (h_blocks + !!h_part)))
                     av_log(avctx, AV_LOG_ERROR,
                            ""error in decompression of block %dx%d\n"", i, j);
             }
         }
     }
     if (s->is_keyframe && s->ver == 2) {
         if (!s->keyframe) {
             s->keyframe = av_malloc(s->frame.linesize[0] * avctx->height);
             if (!s->keyframe) {
                 av_log(avctx, AV_LOG_ERROR, ""Cannot allocate image data\n"");
                 return AVERROR(ENOMEM);
             }
         }
         memcpy(s->keyframe, s->frame.data[0], s->frame.linesize[0] * avctx->height);
     }
     if ((ret = av_frame_ref(data, &s->frame)) < 0)
         return ret;
     *got_frame = 1;
     if ((get_bits_count(&gb) / 8) != buf_size)
         av_log(avctx, AV_LOG_ERROR, ""buffer not fully consumed (%d != %d)\n"",
                buf_size, (get_bits_count(&gb) / 8));
     return buf_size;
 }","[117, 118, 119, 120]","The flashsv_decode_frame function in libavcodec/flashsv.c in FFmpeg before 2.1 does not properly validate a certain height value, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted Flash Screen Video data.",FFmpeg,CVE-2013-7015,CWE-20
1546,183312," void CNB::DoIPHdrCSO(PVOID IpHeader, ULONG EthPayloadLength) const
  {
      ParaNdis_CheckSumVerifyFlat(IpHeader,
                                  EthPayloadLength,
                                pcrIpChecksum | pcrFixIPChecksum,
                                 pcrIpChecksum | pcrFixIPChecksum, FALSE,
                                  __FUNCTION__);
  }","[5, 6]","The NetKVM Windows Virtio driver allows remote attackers to cause a denial of service (guest crash) via a crafted length value in an IP packet, as demonstrated by a value that does not account for the size of the IP options.",kvm-guest-drivers-windows,CVE-2015-3215,CWE-20
1559,179035," int rpc_type_of_NPPVariable(int variable)
 {
   int type;
   switch (variable) {
    case NPPVpluginNameString:
    case NPPVpluginDescriptionString:
    case NPPVformValue:  
   case NPPVpluginNativeAccessibleAtkPlugId:
  	type = RPC_TYPE_STRING;
  	break;
    case NPPVpluginWindowSize:
   case NPPVpluginTimerInterval:
 	type = RPC_TYPE_INT32;
 	break;
   case NPPVpluginNeedsXEmbed:
   case NPPVpluginWindowBool:
    case NPPVpluginTransparentBool:
    case NPPVjavascriptPushCallerBool:
    case NPPVpluginKeepLibraryInMemory:
   case NPPVpluginUrlRequestsDisplayedBool:
   case NPPVpluginWantsAllNetworkStreams:
   case NPPVpluginCancelSrcStream:
   case NPPVSupportsAdvancedKeyHandling:
  	type = RPC_TYPE_BOOLEAN;
  	break;
    case NPPVpluginScriptableNPObject:
 	type = RPC_TYPE_NP_OBJECT;
 	break;
   default:
 	type = RPC_ERROR_GENERIC;
 	break;
   }
   return type;
 }","[8, 20, 21, 22, 23]","nspluginwrapper before 1.4.4 does not properly provide access to NPNVprivateModeBool variable settings, which could prevent Firefox plugins from determining if they should run in Private Browsing mode and allow remote attackers to bypass intended access restrictions, as demonstrated using Flash.",nspluginwrapper,CVE-2011-2486,CWE-264
1570,182020," rtadv_read (struct thread *thread)
 {
   int sock;
   int len;
   u_char buf[RTADV_MSG_SIZE];
   struct sockaddr_in6 from;
   ifindex_t ifindex = 0;
   int hoplimit = -1;
   struct zebra_vrf *zvrf = THREAD_ARG (thread);
   sock = THREAD_FD (thread);
   zvrf->rtadv.ra_read = NULL;
    rtadv_event (zvrf, RTADV_READ, sock);
  len = rtadv_recv_packet (sock, buf, BUFSIZ, &from, &ifindex, &hoplimit);
   len = rtadv_recv_packet (sock, buf, sizeof (buf), &from, &ifindex, &hoplimit);
    if (len < 0) 
      {
       zlog_warn (""router solicitation recv failed: %s."", safe_strerror (errno));
       return len;
     }
   rtadv_process_packet (buf, (unsigned)len, ifindex, hoplimit, zvrf->vrf_id);
   return 0;
 }","[13, 14]","It was discovered that the zebra daemon in Quagga before 1.0.20161017 suffered from a stack-based buffer overflow when processing IPv6 Neighbor Discovery messages. The root cause was relying on BUFSIZ to be compatible with a message size; however, BUFSIZ is system-dependent.",quagga,CVE-2016-1245,CWE-119
1579,182289," static int mov_write_audio_tag(AVFormatContext *s, AVIOContext *pb, MOVMuxContext *mov, MOVTrack *track)
 {
     int64_t pos = avio_tell(pb);
     int version = 0;
      uint32_t tag = track->tag;
      if (track->mode == MODE_MOV) {
        if (track->timescale > UINT16_MAX) {
         if (track->timescale > UINT16_MAX || !track->par->channels) {
              if (mov_get_lpcm_flags(track->par->codec_id))
                  tag = AV_RL32(""lpcm"");
              version = 2;
         } else if (track->audio_vbr || mov_pcm_le_gt16(track->par->codec_id) ||
                    mov_pcm_be_gt16(track->par->codec_id) ||
                    track->par->codec_id == AV_CODEC_ID_ADPCM_MS ||
                    track->par->codec_id == AV_CODEC_ID_ADPCM_IMA_WAV ||
                    track->par->codec_id == AV_CODEC_ID_QDM2) {
             version = 1;
         }
     }
     avio_wb32(pb, 0);  
     if (mov->encryption_scheme != MOV_ENC_NONE) {
         ffio_wfourcc(pb, ""enca"");
     } else {
         avio_wl32(pb, tag);  
     }
     avio_wb32(pb, 0);  
     avio_wb16(pb, 0);  
     avio_wb16(pb, 1);  
     avio_wb16(pb, version);  
     avio_wb16(pb, 0);  
     avio_wb32(pb, 0);  
     if (version == 2) {
         avio_wb16(pb, 3);
         avio_wb16(pb, 16);
         avio_wb16(pb, 0xfffe);
         avio_wb16(pb, 0);
         avio_wb32(pb, 0x00010000);
         avio_wb32(pb, 72);
         avio_wb64(pb, av_double2int(track->par->sample_rate));
         avio_wb32(pb, track->par->channels);
         avio_wb32(pb, 0x7F000000);
         avio_wb32(pb, av_get_bits_per_sample(track->par->codec_id));
         avio_wb32(pb, mov_get_lpcm_flags(track->par->codec_id));
         avio_wb32(pb, track->sample_size);
         avio_wb32(pb, get_samples_per_packet(track));
     } else {
         if (track->mode == MODE_MOV) {
             avio_wb16(pb, track->par->channels);
             if (track->par->codec_id == AV_CODEC_ID_PCM_U8 ||
                 track->par->codec_id == AV_CODEC_ID_PCM_S8)
                 avio_wb16(pb, 8);  
             else if (track->par->codec_id == AV_CODEC_ID_ADPCM_G726)
                 avio_wb16(pb, track->par->bits_per_coded_sample);
             else
                 avio_wb16(pb, 16);
             avio_wb16(pb, track->audio_vbr ? -2 : 0);  
         } else {  
             if (track->par->codec_id == AV_CODEC_ID_FLAC ||
                 track->par->codec_id == AV_CODEC_ID_OPUS) {
                 avio_wb16(pb, track->par->channels);
             } else {
                 avio_wb16(pb, 2);
             }
             if (track->par->codec_id == AV_CODEC_ID_FLAC) {
                 avio_wb16(pb, track->par->bits_per_raw_sample);
             } else {
                 avio_wb16(pb, 16);
             }
             avio_wb16(pb, 0);
         }
         avio_wb16(pb, 0);  
         if (track->par->codec_id == AV_CODEC_ID_OPUS)
             avio_wb16(pb, 48000);
         else
             avio_wb16(pb, track->par->sample_rate <= UINT16_MAX ?
                           track->par->sample_rate : 0);
         avio_wb16(pb, 0);  
     }
     if (version == 1) {  
         if (mov_pcm_le_gt16(track->par->codec_id) ||
             mov_pcm_be_gt16(track->par->codec_id))
             avio_wb32(pb, 1);  
         else
             avio_wb32(pb, track->par->frame_size);  
         avio_wb32(pb, track->sample_size / track->par->channels);  
         avio_wb32(pb, track->sample_size);  
         avio_wb32(pb, 2);  
     }
     if (track->mode == MODE_MOV &&
         (track->par->codec_id == AV_CODEC_ID_AAC           ||
          track->par->codec_id == AV_CODEC_ID_AC3           ||
          track->par->codec_id == AV_CODEC_ID_EAC3          ||
          track->par->codec_id == AV_CODEC_ID_AMR_NB        ||
          track->par->codec_id == AV_CODEC_ID_ALAC          ||
          track->par->codec_id == AV_CODEC_ID_ADPCM_MS      ||
          track->par->codec_id == AV_CODEC_ID_ADPCM_IMA_WAV ||
          track->par->codec_id == AV_CODEC_ID_QDM2          ||
          (mov_pcm_le_gt16(track->par->codec_id) && version==1) ||
          (mov_pcm_be_gt16(track->par->codec_id) && version==1)))
         mov_write_wave_tag(s, pb, track);
     else if (track->tag == MKTAG('m','p','4','a'))
         mov_write_esds_tag(pb, track);
     else if (track->par->codec_id == AV_CODEC_ID_AMR_NB)
         mov_write_amr_tag(pb, track);
     else if (track->par->codec_id == AV_CODEC_ID_AC3)
         mov_write_ac3_tag(pb, track);
     else if (track->par->codec_id == AV_CODEC_ID_EAC3)
         mov_write_eac3_tag(pb, track);
     else if (track->par->codec_id == AV_CODEC_ID_ALAC)
         mov_write_extradata_tag(pb, track);
     else if (track->par->codec_id == AV_CODEC_ID_WMAPRO)
         mov_write_wfex_tag(s, pb, track);
     else if (track->par->codec_id == AV_CODEC_ID_FLAC)
         mov_write_dfla_tag(pb, track);
     else if (track->par->codec_id == AV_CODEC_ID_OPUS)
         mov_write_dops_tag(pb, track);
     else if (track->vos_len > 0)
         mov_write_glbl_tag(pb, track);
     if (track->mode == MODE_MOV && track->par->codec_type == AVMEDIA_TYPE_AUDIO)
         mov_write_chan_tag(s, pb, track);
     if (mov->encryption_scheme != MOV_ENC_NONE) {
         ff_mov_cenc_write_sinf_tag(track, pb, mov->encryption_kid);
     }
     return update_size(pb, pos);
 }","[7, 8]",libavformat/movenc.c in FFmpeg before 4.0.2 allows attackers to cause a denial of service (application crash caused by a divide-by-zero error) with a user crafted audio file when converting to the MOV audio format.,FFmpeg,CVE-2018-14395,CWE-369
1623,183404," static int decode_studio_vop_header(Mpeg4DecContext *ctx, GetBitContext *gb)
 {
     MpegEncContext *s = &ctx->m;
     if (get_bits_left(gb) <= 32)
          return 0;
      s->partitioned_frame = 0;
     s->interlaced_dct = 0;
      s->decode_mb = mpeg4_decode_studio_mb;
      decode_smpte_tc(ctx, gb);
     skip_bits(gb, 10);  
     skip_bits(gb, 2);  
     s->pict_type = get_bits(gb, 2) + AV_PICTURE_TYPE_I;  
     if (get_bits1(gb)) {  
         skip_bits1(gb);  
         skip_bits1(gb);  
         s->progressive_frame = get_bits1(gb) ^ 1;  
     }
     if (s->pict_type == AV_PICTURE_TYPE_I) {
         if (get_bits1(gb))
             reset_studio_dc_predictors(s);
     }
     if (ctx->shape != BIN_ONLY_SHAPE) {
         s->alternate_scan = get_bits1(gb);
         s->frame_pred_frame_dct = get_bits1(gb);
         s->dct_precision = get_bits(gb, 2);
         s->intra_dc_precision = get_bits(gb, 2);
         s->q_scale_type = get_bits1(gb);
     }
     if (s->alternate_scan) {
         ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable,   ff_alternate_vertical_scan);
         ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable,   ff_alternate_vertical_scan);
         ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_vertical_scan);
         ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);
     } else {
         ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable,   ff_zigzag_direct);
         ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable,   ff_zigzag_direct);
         ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan);
         ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);
     }
     mpeg4_load_default_matrices(s);
     next_start_code_studio(gb);
     extension_and_user_data(s, gb, 4);
     return 0;
 }",[7],The studio profile decoder in libavcodec/mpeg4videodec.c in FFmpeg 4.0 before 4.0.4 and 4.1 before 4.1.2 allows remote attackers to cause a denial of service (out-of-array access) or possibly have unspecified other impact via crafted MPEG-4 video data.,FFmpeg,CVE-2019-11339,CWE-125
1624,182927," char *strstr(char *s1, char *s2)
 {                                
     char *p;
     int len = strlen(s2);
      if (*s2 == '\0')             
          return s1;
    for (p = s1; (p = strchr(p, *s2)) != NULL; p = strchr(p + 1, *s2)) {
     for (p = s1; (p = strchr(p, *s2)) != NULL; p++) {
          if (strncmp(p, s2, len) == 0)
              return (p);
      }
     return NULL;
 }","[7, 8]",Boa through 0.94.14rc21 allows remote attackers to trigger a memory leak because of missing calls to the free function.,boa,CVE-2018-21028,
1641,182344," GF_Err tenc_dump(GF_Box *a, FILE * trace)
 {
 	GF_TrackEncryptionBox *ptr = (GF_TrackEncryptionBox*) a;
 	if (!a) return GF_BAD_PARAM;
 	gf_isom_box_dump_start(a, ""TrackEncryptionBox"", trace);
 	fprintf(trace, ""isEncrypted=\""%d\"""", ptr->isProtected);
 	if (ptr->Per_Sample_IV_Size)
 		fprintf(trace, "" IV_size=\""%d\"" KID=\"""", ptr->Per_Sample_IV_Size);
 	else {
 		fprintf(trace, "" constant_IV_size=\""%d\"" constant_IV=\"""", ptr->constant_IV_size);
 		dump_data_hex(trace, (char *) ptr->constant_IV, ptr->constant_IV_size);
  		fprintf(trace, ""\""  KID=\"""");
  	}
  	dump_data_hex(trace, (char *) ptr->KID, 16);
	if (ptr->version) 
 	if (ptr->version)
  		fprintf(trace, ""\"" crypt_byte_block=\""%d\"" skip_byte_block=\""%d"", ptr->crypt_byte_block, ptr->skip_byte_block);
  	fprintf(trace, ""\"">\n"");
  	gf_isom_box_dump_done(""TrackEncryptionBox"", a, trace);
 	return GF_OK;
 }","[15, 16]",An issue was discovered in MP4Box in GPAC 0.7.1. There is a heap-based buffer over-read in the isomedia/box_dump.c function hdlr_dump.,gpac,CVE-2018-13006,CWE-125
1647,182246," static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)
 {
 	muscle_private_t* priv = MUSCLE_DATA(card);
 	mscfs_t *fs = priv->fs;
 	int x;
 	int count = 0;
  	mscfs_check_cache(priv->fs);
  	for(x = 0; x < fs->cache.size; x++) {
		u8* oid= fs->cache.array[x].objectId.id;
 		u8* oid = fs->cache.array[x].objectId.id;
 		if (bufLen < 2)
 			break;
  		sc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,
  			""FILE: %02X%02X%02X%02X\n"",
  			oid[0],oid[1],oid[2],oid[3]);
 		if(0 == memcmp(fs->currentPath, oid, 2)) {
 			buf[0] = oid[2];
  			buf[1] = oid[3];
  			if(buf[0] == 0x00 && buf[1] == 0x00) continue;  
  			buf += 2;
			count+=2;
 			count += 2;
 			bufLen -= 2;
  		}
  	}
  	return count;
 }","[9, 10, 11, 12, 21, 22, 23]",A double free when handling responses from an HSM Card in sc_pkcs15emu_sc_hsm_init in libopensc/pkcs15-sc-hsm.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.,OpenSC,CVE-2018-16425,CWE-415
1665,181572," char *FLTGetIsLikeComparisonCommonExpression(FilterEncodingNode *psFilterNode)
 {
   const size_t bufferSize = 1024;
   char szBuffer[1024];
   char szTmp[256];
   char *pszValue = NULL;
   const char *pszWild = NULL;
   const char *pszSingle = NULL;
   const char *pszEscape = NULL;
   int  bCaseInsensitive = 0;
   FEPropertyIsLike* propIsLike;
   int nLength=0, i=0, iTmp=0;
   if (!psFilterNode || !psFilterNode->pOther || !psFilterNode->psLeftNode || !psFilterNode->psRightNode || !psFilterNode->psRightNode->pszValue)
     return NULL;
   propIsLike = (FEPropertyIsLike *)psFilterNode->pOther;
   pszWild = propIsLike->pszWildCard;
   pszSingle = propIsLike->pszSingleChar;
   pszEscape = propIsLike->pszEscapeChar;
   bCaseInsensitive = propIsLike->bCaseInsensitive;
   if (!pszWild || strlen(pszWild) == 0 || !pszSingle || strlen(pszSingle) == 0 || !pszEscape || strlen(pszEscape) == 0)
     return NULL;
   szBuffer[0] = '\0';
   sprintf(szTmp, ""%s"", ""(\""["");
   szTmp[4] = '\0';
   strlcat(szBuffer, szTmp, bufferSize);
   strlcat(szBuffer, psFilterNode->psLeftNode->pszValue, bufferSize);
   szBuffer[strlen(szBuffer)] = '\0';
   if (bCaseInsensitive == 1)
     sprintf(szTmp, ""%s"", ""]\"" ~* \"""");
   else
     sprintf(szTmp, ""%s"", ""]\"" ~ \"""");
   szTmp[7] = '\0';
   strlcat(szBuffer, szTmp, bufferSize);
   szBuffer[strlen(szBuffer)] = '\0';
    pszValue = psFilterNode->psRightNode->pszValue;
    nLength = strlen(pszValue);
   if( 1 + 2 * nLength + 1 + 1 >= sizeof(szTmp) )
       return NULL;
    iTmp =0;
    if (nLength > 0 && pszValue[0] != pszWild[0] && pszValue[0] != pszSingle[0] && pszValue[0] != pszEscape[0]) {
     szTmp[iTmp]= '^';
     iTmp++;
   }
   for (i=0; i<nLength; i++) {
     if (pszValue[i] != pszWild[0] && pszValue[i] != pszSingle[0] && pszValue[i] != pszEscape[0]) {
       szTmp[iTmp] = pszValue[i];
       iTmp++;
       szTmp[iTmp] = '\0';
     } else if (pszValue[i] == pszSingle[0]) {
       szTmp[iTmp] = '.';
       iTmp++;
       szTmp[iTmp] = '\0';
     } else if (pszValue[i] == pszEscape[0]) {
       szTmp[iTmp] = '\\';
       iTmp++;
       szTmp[iTmp] = '\0';
     } else if (pszValue[i] == pszWild[0]) {
       szTmp[iTmp++] = '.';
       szTmp[iTmp++] = '*';
       szTmp[iTmp] = '\0';
     }
   }
   szTmp[iTmp] = '""';
   szTmp[++iTmp] = '\0';
   strlcat(szBuffer, szTmp, bufferSize);
   strlcat(szBuffer, "")"", bufferSize);
   return msStrdup(szBuffer);
 }","[37, 38]","Stack-based buffer overflow in MapServer before 6.0.6, 6.2.x before 6.2.4, 6.4.x before 6.4.5, and 7.0.x before 7.0.4 allows remote attackers to cause a denial of service (crash) or execute arbitrary code via vectors involving WFS get feature requests.",mapserver,CVE-2017-5522,CWE-119
1684,182701,"  doProlog(XML_Parser parser, const ENCODING *enc, const char *s, const char *end,
         int tok, const char *next, const char **nextPtr, XML_Bool haveMore) {
          int tok, const char *next, const char **nextPtr, XML_Bool haveMore,
          XML_Bool allowClosingDoctype) {
  #ifdef XML_DTD
    static const XML_Char externalSubsetName[] = {ASCII_HASH, '\0'};
  #endif  
   static const XML_Char atypeCDATA[]
       = {ASCII_C, ASCII_D, ASCII_A, ASCII_T, ASCII_A, '\0'};
   static const XML_Char atypeID[] = {ASCII_I, ASCII_D, '\0'};
   static const XML_Char atypeIDREF[]
       = {ASCII_I, ASCII_D, ASCII_R, ASCII_E, ASCII_F, '\0'};
   static const XML_Char atypeIDREFS[]
       = {ASCII_I, ASCII_D, ASCII_R, ASCII_E, ASCII_F, ASCII_S, '\0'};
   static const XML_Char atypeENTITY[]
       = {ASCII_E, ASCII_N, ASCII_T, ASCII_I, ASCII_T, ASCII_Y, '\0'};
   static const XML_Char atypeENTITIES[]
       = {ASCII_E, ASCII_N, ASCII_T, ASCII_I, ASCII_T,
          ASCII_I, ASCII_E, ASCII_S, '\0'};
   static const XML_Char atypeNMTOKEN[]
       = {ASCII_N, ASCII_M, ASCII_T, ASCII_O, ASCII_K, ASCII_E, ASCII_N, '\0'};
   static const XML_Char atypeNMTOKENS[]
       = {ASCII_N, ASCII_M, ASCII_T, ASCII_O, ASCII_K,
          ASCII_E, ASCII_N, ASCII_S, '\0'};
   static const XML_Char notationPrefix[]
       = {ASCII_N, ASCII_O, ASCII_T, ASCII_A,      ASCII_T,
          ASCII_I, ASCII_O, ASCII_N, ASCII_LPAREN, '\0'};
   static const XML_Char enumValueSep[] = {ASCII_PIPE, '\0'};
   static const XML_Char enumValueStart[] = {ASCII_LPAREN, '\0'};
   DTD *const dtd = parser->m_dtd;
   const char **eventPP;
   const char **eventEndPP;
   enum XML_Content_Quant quant;
   if (enc == parser->m_encoding) {
     eventPP = &parser->m_eventPtr;
     eventEndPP = &parser->m_eventEndPtr;
   } else {
     eventPP = &(parser->m_openInternalEntities->internalEventPtr);
     eventEndPP = &(parser->m_openInternalEntities->internalEventEndPtr);
   }
   for (;;) {
     int role;
     XML_Bool handleDefault = XML_TRUE;
     *eventPP = s;
     *eventEndPP = next;
     if (tok <= 0) {
       if (haveMore && tok != XML_TOK_INVALID) {
         *nextPtr = s;
         return XML_ERROR_NONE;
       }
       switch (tok) {
       case XML_TOK_INVALID:
         *eventPP = next;
         return XML_ERROR_INVALID_TOKEN;
       case XML_TOK_PARTIAL:
         return XML_ERROR_UNCLOSED_TOKEN;
       case XML_TOK_PARTIAL_CHAR:
         return XML_ERROR_PARTIAL_CHAR;
       case -XML_TOK_PROLOG_S:
         tok = -tok;
         break;
       case XML_TOK_NONE:
 #ifdef XML_DTD
         if (enc != parser->m_encoding
             && ! parser->m_openInternalEntities->betweenDecl) {
           *nextPtr = s;
           return XML_ERROR_NONE;
         }
         if (parser->m_isParamEntity || enc != parser->m_encoding) {
           if (XmlTokenRole(&parser->m_prologState, XML_TOK_NONE, end, end, enc)
               == XML_ROLE_ERROR)
             return XML_ERROR_INCOMPLETE_PE;
           *nextPtr = s;
           return XML_ERROR_NONE;
         }
 #endif  
         return XML_ERROR_NO_ELEMENTS;
       default:
         tok = -tok;
         next = end;
         break;
       }
     }
     role = XmlTokenRole(&parser->m_prologState, tok, s, next, enc);
     switch (role) {
     case XML_ROLE_XML_DECL: {
       enum XML_Error result = processXmlDecl(parser, 0, s, next);
       if (result != XML_ERROR_NONE)
         return result;
       enc = parser->m_encoding;
       handleDefault = XML_FALSE;
     } break;
     case XML_ROLE_DOCTYPE_NAME:
       if (parser->m_startDoctypeDeclHandler) {
         parser->m_doctypeName
             = poolStoreString(&parser->m_tempPool, enc, s, next);
         if (! parser->m_doctypeName)
           return XML_ERROR_NO_MEMORY;
         poolFinish(&parser->m_tempPool);
         parser->m_doctypePubid = NULL;
         handleDefault = XML_FALSE;
       }
       parser->m_doctypeSysid = NULL;  
       break;
     case XML_ROLE_DOCTYPE_INTERNAL_SUBSET:
       if (parser->m_startDoctypeDeclHandler) {
         parser->m_startDoctypeDeclHandler(
             parser->m_handlerArg, parser->m_doctypeName, parser->m_doctypeSysid,
             parser->m_doctypePubid, 1);
         parser->m_doctypeName = NULL;
         poolClear(&parser->m_tempPool);
         handleDefault = XML_FALSE;
       }
       break;
 #ifdef XML_DTD
     case XML_ROLE_TEXT_DECL: {
       enum XML_Error result = processXmlDecl(parser, 1, s, next);
       if (result != XML_ERROR_NONE)
         return result;
       enc = parser->m_encoding;
       handleDefault = XML_FALSE;
     } break;
 #endif  
     case XML_ROLE_DOCTYPE_PUBLIC_ID:
 #ifdef XML_DTD
       parser->m_useForeignDTD = XML_FALSE;
       parser->m_declEntity = (ENTITY *)lookup(
           parser, &dtd->paramEntities, externalSubsetName, sizeof(ENTITY));
       if (! parser->m_declEntity)
         return XML_ERROR_NO_MEMORY;
 #endif  
       dtd->hasParamEntityRefs = XML_TRUE;
       if (parser->m_startDoctypeDeclHandler) {
         XML_Char *pubId;
         if (! XmlIsPublicId(enc, s, next, eventPP))
           return XML_ERROR_PUBLICID;
         pubId = poolStoreString(&parser->m_tempPool, enc,
                                 s + enc->minBytesPerChar,
                                 next - enc->minBytesPerChar);
         if (! pubId)
           return XML_ERROR_NO_MEMORY;
         normalizePublicId(pubId);
         poolFinish(&parser->m_tempPool);
         parser->m_doctypePubid = pubId;
         handleDefault = XML_FALSE;
         goto alreadyChecked;
       }
     case XML_ROLE_ENTITY_PUBLIC_ID:
       if (! XmlIsPublicId(enc, s, next, eventPP))
         return XML_ERROR_PUBLICID;
     alreadyChecked:
       if (dtd->keepProcessing && parser->m_declEntity) {
         XML_Char *tem
             = poolStoreString(&dtd->pool, enc, s + enc->minBytesPerChar,
                               next - enc->minBytesPerChar);
         if (! tem)
           return XML_ERROR_NO_MEMORY;
         normalizePublicId(tem);
         parser->m_declEntity->publicId = tem;
         poolFinish(&dtd->pool);
         if (parser->m_entityDeclHandler && role == XML_ROLE_ENTITY_PUBLIC_ID)
           handleDefault = XML_FALSE;
        }
        break;
      case XML_ROLE_DOCTYPE_CLOSE:
       if (allowClosingDoctype != XML_TRUE) {
         return XML_ERROR_INVALID_TOKEN;
       }
        if (parser->m_doctypeName) {
          parser->m_startDoctypeDeclHandler(
              parser->m_handlerArg, parser->m_doctypeName, parser->m_doctypeSysid,
             parser->m_doctypePubid, 0);
         poolClear(&parser->m_tempPool);
         handleDefault = XML_FALSE;
       }
 #ifdef XML_DTD
       if (parser->m_doctypeSysid || parser->m_useForeignDTD) {
         XML_Bool hadParamEntityRefs = dtd->hasParamEntityRefs;
         dtd->hasParamEntityRefs = XML_TRUE;
         if (parser->m_paramEntityParsing
             && parser->m_externalEntityRefHandler) {
           ENTITY *entity = (ENTITY *)lookup(parser, &dtd->paramEntities,
                                             externalSubsetName, sizeof(ENTITY));
           if (! entity) {
             return XML_ERROR_NO_MEMORY;  
           }
           if (parser->m_useForeignDTD)
             entity->base = parser->m_curBase;
           dtd->paramEntityRead = XML_FALSE;
           if (! parser->m_externalEntityRefHandler(
                   parser->m_externalEntityRefHandlerArg, 0, entity->base,
                   entity->systemId, entity->publicId))
             return XML_ERROR_EXTERNAL_ENTITY_HANDLING;
           if (dtd->paramEntityRead) {
             if (! dtd->standalone && parser->m_notStandaloneHandler
                 && ! parser->m_notStandaloneHandler(parser->m_handlerArg))
               return XML_ERROR_NOT_STANDALONE;
           }
           else if (! parser->m_doctypeSysid)
             dtd->hasParamEntityRefs = hadParamEntityRefs;
         }
         parser->m_useForeignDTD = XML_FALSE;
       }
 #endif  
       if (parser->m_endDoctypeDeclHandler) {
         parser->m_endDoctypeDeclHandler(parser->m_handlerArg);
         handleDefault = XML_FALSE;
       }
       break;
     case XML_ROLE_INSTANCE_START:
 #ifdef XML_DTD
       if (parser->m_useForeignDTD) {
         XML_Bool hadParamEntityRefs = dtd->hasParamEntityRefs;
         dtd->hasParamEntityRefs = XML_TRUE;
         if (parser->m_paramEntityParsing
             && parser->m_externalEntityRefHandler) {
           ENTITY *entity = (ENTITY *)lookup(parser, &dtd->paramEntities,
                                             externalSubsetName, sizeof(ENTITY));
           if (! entity)
             return XML_ERROR_NO_MEMORY;
           entity->base = parser->m_curBase;
           dtd->paramEntityRead = XML_FALSE;
           if (! parser->m_externalEntityRefHandler(
                   parser->m_externalEntityRefHandlerArg, 0, entity->base,
                   entity->systemId, entity->publicId))
             return XML_ERROR_EXTERNAL_ENTITY_HANDLING;
           if (dtd->paramEntityRead) {
             if (! dtd->standalone && parser->m_notStandaloneHandler
                 && ! parser->m_notStandaloneHandler(parser->m_handlerArg))
               return XML_ERROR_NOT_STANDALONE;
           }
           else
             dtd->hasParamEntityRefs = hadParamEntityRefs;
         }
       }
 #endif  
       parser->m_processor = contentProcessor;
       return contentProcessor(parser, s, end, nextPtr);
     case XML_ROLE_ATTLIST_ELEMENT_NAME:
       parser->m_declElementType = getElementType(parser, enc, s, next);
       if (! parser->m_declElementType)
         return XML_ERROR_NO_MEMORY;
       goto checkAttListDeclHandler;
     case XML_ROLE_ATTRIBUTE_NAME:
       parser->m_declAttributeId = getAttributeId(parser, enc, s, next);
       if (! parser->m_declAttributeId)
         return XML_ERROR_NO_MEMORY;
       parser->m_declAttributeIsCdata = XML_FALSE;
       parser->m_declAttributeType = NULL;
       parser->m_declAttributeIsId = XML_FALSE;
       goto checkAttListDeclHandler;
     case XML_ROLE_ATTRIBUTE_TYPE_CDATA:
       parser->m_declAttributeIsCdata = XML_TRUE;
       parser->m_declAttributeType = atypeCDATA;
       goto checkAttListDeclHandler;
     case XML_ROLE_ATTRIBUTE_TYPE_ID:
       parser->m_declAttributeIsId = XML_TRUE;
       parser->m_declAttributeType = atypeID;
       goto checkAttListDeclHandler;
     case XML_ROLE_ATTRIBUTE_TYPE_IDREF:
       parser->m_declAttributeType = atypeIDREF;
       goto checkAttListDeclHandler;
     case XML_ROLE_ATTRIBUTE_TYPE_IDREFS:
       parser->m_declAttributeType = atypeIDREFS;
       goto checkAttListDeclHandler;
     case XML_ROLE_ATTRIBUTE_TYPE_ENTITY:
       parser->m_declAttributeType = atypeENTITY;
       goto checkAttListDeclHandler;
     case XML_ROLE_ATTRIBUTE_TYPE_ENTITIES:
       parser->m_declAttributeType = atypeENTITIES;
       goto checkAttListDeclHandler;
     case XML_ROLE_ATTRIBUTE_TYPE_NMTOKEN:
       parser->m_declAttributeType = atypeNMTOKEN;
       goto checkAttListDeclHandler;
     case XML_ROLE_ATTRIBUTE_TYPE_NMTOKENS:
       parser->m_declAttributeType = atypeNMTOKENS;
     checkAttListDeclHandler:
       if (dtd->keepProcessing && parser->m_attlistDeclHandler)
         handleDefault = XML_FALSE;
       break;
     case XML_ROLE_ATTRIBUTE_ENUM_VALUE:
     case XML_ROLE_ATTRIBUTE_NOTATION_VALUE:
       if (dtd->keepProcessing && parser->m_attlistDeclHandler) {
         const XML_Char *prefix;
         if (parser->m_declAttributeType) {
           prefix = enumValueSep;
         } else {
           prefix = (role == XML_ROLE_ATTRIBUTE_NOTATION_VALUE ? notationPrefix
                                                               : enumValueStart);
         }
         if (! poolAppendString(&parser->m_tempPool, prefix))
           return XML_ERROR_NO_MEMORY;
         if (! poolAppend(&parser->m_tempPool, enc, s, next))
           return XML_ERROR_NO_MEMORY;
         parser->m_declAttributeType = parser->m_tempPool.start;
         handleDefault = XML_FALSE;
       }
       break;
     case XML_ROLE_IMPLIED_ATTRIBUTE_VALUE:
     case XML_ROLE_REQUIRED_ATTRIBUTE_VALUE:
       if (dtd->keepProcessing) {
         if (! defineAttribute(parser->m_declElementType,
                               parser->m_declAttributeId,
                               parser->m_declAttributeIsCdata,
                               parser->m_declAttributeIsId, 0, parser))
           return XML_ERROR_NO_MEMORY;
         if (parser->m_attlistDeclHandler && parser->m_declAttributeType) {
           if (*parser->m_declAttributeType == XML_T(ASCII_LPAREN)
               || (*parser->m_declAttributeType == XML_T(ASCII_N)
                   && parser->m_declAttributeType[1] == XML_T(ASCII_O))) {
             if (! poolAppendChar(&parser->m_tempPool, XML_T(ASCII_RPAREN))
                 || ! poolAppendChar(&parser->m_tempPool, XML_T('\0')))
               return XML_ERROR_NO_MEMORY;
             parser->m_declAttributeType = parser->m_tempPool.start;
             poolFinish(&parser->m_tempPool);
           }
           *eventEndPP = s;
           parser->m_attlistDeclHandler(
               parser->m_handlerArg, parser->m_declElementType->name,
               parser->m_declAttributeId->name, parser->m_declAttributeType, 0,
               role == XML_ROLE_REQUIRED_ATTRIBUTE_VALUE);
           poolClear(&parser->m_tempPool);
           handleDefault = XML_FALSE;
         }
       }
       break;
     case XML_ROLE_DEFAULT_ATTRIBUTE_VALUE:
     case XML_ROLE_FIXED_ATTRIBUTE_VALUE:
       if (dtd->keepProcessing) {
         const XML_Char *attVal;
         enum XML_Error result = storeAttributeValue(
             parser, enc, parser->m_declAttributeIsCdata,
             s + enc->minBytesPerChar, next - enc->minBytesPerChar, &dtd->pool);
         if (result)
           return result;
         attVal = poolStart(&dtd->pool);
         poolFinish(&dtd->pool);
         if (! defineAttribute(
                 parser->m_declElementType, parser->m_declAttributeId,
                 parser->m_declAttributeIsCdata, XML_FALSE, attVal, parser))
           return XML_ERROR_NO_MEMORY;
         if (parser->m_attlistDeclHandler && parser->m_declAttributeType) {
           if (*parser->m_declAttributeType == XML_T(ASCII_LPAREN)
               || (*parser->m_declAttributeType == XML_T(ASCII_N)
                   && parser->m_declAttributeType[1] == XML_T(ASCII_O))) {
             if (! poolAppendChar(&parser->m_tempPool, XML_T(ASCII_RPAREN))
                 || ! poolAppendChar(&parser->m_tempPool, XML_T('\0')))
               return XML_ERROR_NO_MEMORY;
             parser->m_declAttributeType = parser->m_tempPool.start;
             poolFinish(&parser->m_tempPool);
           }
           *eventEndPP = s;
           parser->m_attlistDeclHandler(
               parser->m_handlerArg, parser->m_declElementType->name,
               parser->m_declAttributeId->name, parser->m_declAttributeType,
               attVal, role == XML_ROLE_FIXED_ATTRIBUTE_VALUE);
           poolClear(&parser->m_tempPool);
           handleDefault = XML_FALSE;
         }
       }
       break;
     case XML_ROLE_ENTITY_VALUE:
       if (dtd->keepProcessing) {
         enum XML_Error result = storeEntityValue(
             parser, enc, s + enc->minBytesPerChar, next - enc->minBytesPerChar);
         if (parser->m_declEntity) {
           parser->m_declEntity->textPtr = poolStart(&dtd->entityValuePool);
           parser->m_declEntity->textLen
               = (int)(poolLength(&dtd->entityValuePool));
           poolFinish(&dtd->entityValuePool);
           if (parser->m_entityDeclHandler) {
             *eventEndPP = s;
             parser->m_entityDeclHandler(
                 parser->m_handlerArg, parser->m_declEntity->name,
                 parser->m_declEntity->is_param, parser->m_declEntity->textPtr,
                 parser->m_declEntity->textLen, parser->m_curBase, 0, 0, 0);
             handleDefault = XML_FALSE;
           }
         } else
           poolDiscard(&dtd->entityValuePool);
         if (result != XML_ERROR_NONE)
           return result;
       }
       break;
     case XML_ROLE_DOCTYPE_SYSTEM_ID:
 #ifdef XML_DTD
       parser->m_useForeignDTD = XML_FALSE;
 #endif  
       dtd->hasParamEntityRefs = XML_TRUE;
       if (parser->m_startDoctypeDeclHandler) {
         parser->m_doctypeSysid = poolStoreString(&parser->m_tempPool, enc,
                                                  s + enc->minBytesPerChar,
                                                  next - enc->minBytesPerChar);
         if (parser->m_doctypeSysid == NULL)
           return XML_ERROR_NO_MEMORY;
         poolFinish(&parser->m_tempPool);
         handleDefault = XML_FALSE;
       }
 #ifdef XML_DTD
       else
         parser->m_doctypeSysid = externalSubsetName;
 #endif  
       if (! dtd->standalone
 #ifdef XML_DTD
           && ! parser->m_paramEntityParsing
 #endif  
           && parser->m_notStandaloneHandler
           && ! parser->m_notStandaloneHandler(parser->m_handlerArg))
         return XML_ERROR_NOT_STANDALONE;
 #ifndef XML_DTD
       break;
 #else   
       if (! parser->m_declEntity) {
         parser->m_declEntity = (ENTITY *)lookup(
             parser, &dtd->paramEntities, externalSubsetName, sizeof(ENTITY));
         if (! parser->m_declEntity)
           return XML_ERROR_NO_MEMORY;
         parser->m_declEntity->publicId = NULL;
       }
 #endif  
     case XML_ROLE_ENTITY_SYSTEM_ID:
       if (dtd->keepProcessing && parser->m_declEntity) {
         parser->m_declEntity->systemId
             = poolStoreString(&dtd->pool, enc, s + enc->minBytesPerChar,
                               next - enc->minBytesPerChar);
         if (! parser->m_declEntity->systemId)
           return XML_ERROR_NO_MEMORY;
         parser->m_declEntity->base = parser->m_curBase;
         poolFinish(&dtd->pool);
         if (parser->m_entityDeclHandler && role == XML_ROLE_ENTITY_SYSTEM_ID)
           handleDefault = XML_FALSE;
       }
       break;
     case XML_ROLE_ENTITY_COMPLETE:
       if (dtd->keepProcessing && parser->m_declEntity
           && parser->m_entityDeclHandler) {
         *eventEndPP = s;
         parser->m_entityDeclHandler(
             parser->m_handlerArg, parser->m_declEntity->name,
             parser->m_declEntity->is_param, 0, 0, parser->m_declEntity->base,
             parser->m_declEntity->systemId, parser->m_declEntity->publicId, 0);
         handleDefault = XML_FALSE;
       }
       break;
     case XML_ROLE_ENTITY_NOTATION_NAME:
       if (dtd->keepProcessing && parser->m_declEntity) {
         parser->m_declEntity->notation
             = poolStoreString(&dtd->pool, enc, s, next);
         if (! parser->m_declEntity->notation)
           return XML_ERROR_NO_MEMORY;
         poolFinish(&dtd->pool);
         if (parser->m_unparsedEntityDeclHandler) {
           *eventEndPP = s;
           parser->m_unparsedEntityDeclHandler(
               parser->m_handlerArg, parser->m_declEntity->name,
               parser->m_declEntity->base, parser->m_declEntity->systemId,
               parser->m_declEntity->publicId, parser->m_declEntity->notation);
           handleDefault = XML_FALSE;
         } else if (parser->m_entityDeclHandler) {
           *eventEndPP = s;
           parser->m_entityDeclHandler(
               parser->m_handlerArg, parser->m_declEntity->name, 0, 0, 0,
               parser->m_declEntity->base, parser->m_declEntity->systemId,
               parser->m_declEntity->publicId, parser->m_declEntity->notation);
           handleDefault = XML_FALSE;
         }
       }
       break;
     case XML_ROLE_GENERAL_ENTITY_NAME: {
       if (XmlPredefinedEntityName(enc, s, next)) {
         parser->m_declEntity = NULL;
         break;
       }
       if (dtd->keepProcessing) {
         const XML_Char *name = poolStoreString(&dtd->pool, enc, s, next);
         if (! name)
           return XML_ERROR_NO_MEMORY;
         parser->m_declEntity = (ENTITY *)lookup(parser, &dtd->generalEntities,
                                                 name, sizeof(ENTITY));
         if (! parser->m_declEntity)
           return XML_ERROR_NO_MEMORY;
         if (parser->m_declEntity->name != name) {
           poolDiscard(&dtd->pool);
           parser->m_declEntity = NULL;
         } else {
           poolFinish(&dtd->pool);
           parser->m_declEntity->publicId = NULL;
           parser->m_declEntity->is_param = XML_FALSE;
           parser->m_declEntity->is_internal
               = ! (parser->m_parentParser || parser->m_openInternalEntities);
           if (parser->m_entityDeclHandler)
             handleDefault = XML_FALSE;
         }
       } else {
         poolDiscard(&dtd->pool);
         parser->m_declEntity = NULL;
       }
     } break;
     case XML_ROLE_PARAM_ENTITY_NAME:
 #ifdef XML_DTD
       if (dtd->keepProcessing) {
         const XML_Char *name = poolStoreString(&dtd->pool, enc, s, next);
         if (! name)
           return XML_ERROR_NO_MEMORY;
         parser->m_declEntity = (ENTITY *)lookup(parser, &dtd->paramEntities,
                                                 name, sizeof(ENTITY));
         if (! parser->m_declEntity)
           return XML_ERROR_NO_MEMORY;
         if (parser->m_declEntity->name != name) {
           poolDiscard(&dtd->pool);
           parser->m_declEntity = NULL;
         } else {
           poolFinish(&dtd->pool);
           parser->m_declEntity->publicId = NULL;
           parser->m_declEntity->is_param = XML_TRUE;
           parser->m_declEntity->is_internal
               = ! (parser->m_parentParser || parser->m_openInternalEntities);
           if (parser->m_entityDeclHandler)
             handleDefault = XML_FALSE;
         }
       } else {
         poolDiscard(&dtd->pool);
         parser->m_declEntity = NULL;
       }
 #else   
       parser->m_declEntity = NULL;
 #endif  
       break;
     case XML_ROLE_NOTATION_NAME:
       parser->m_declNotationPublicId = NULL;
       parser->m_declNotationName = NULL;
       if (parser->m_notationDeclHandler) {
         parser->m_declNotationName
             = poolStoreString(&parser->m_tempPool, enc, s, next);
         if (! parser->m_declNotationName)
           return XML_ERROR_NO_MEMORY;
         poolFinish(&parser->m_tempPool);
         handleDefault = XML_FALSE;
       }
       break;
     case XML_ROLE_NOTATION_PUBLIC_ID:
       if (! XmlIsPublicId(enc, s, next, eventPP))
         return XML_ERROR_PUBLICID;
       if (parser
               ->m_declNotationName) {  
         XML_Char *tem = poolStoreString(&parser->m_tempPool, enc,
                                         s + enc->minBytesPerChar,
                                         next - enc->minBytesPerChar);
         if (! tem)
           return XML_ERROR_NO_MEMORY;
         normalizePublicId(tem);
         parser->m_declNotationPublicId = tem;
         poolFinish(&parser->m_tempPool);
         handleDefault = XML_FALSE;
       }
       break;
     case XML_ROLE_NOTATION_SYSTEM_ID:
       if (parser->m_declNotationName && parser->m_notationDeclHandler) {
         const XML_Char *systemId = poolStoreString(&parser->m_tempPool, enc,
                                                    s + enc->minBytesPerChar,
                                                    next - enc->minBytesPerChar);
         if (! systemId)
           return XML_ERROR_NO_MEMORY;
         *eventEndPP = s;
         parser->m_notationDeclHandler(
             parser->m_handlerArg, parser->m_declNotationName, parser->m_curBase,
             systemId, parser->m_declNotationPublicId);
         handleDefault = XML_FALSE;
       }
       poolClear(&parser->m_tempPool);
       break;
     case XML_ROLE_NOTATION_NO_SYSTEM_ID:
       if (parser->m_declNotationPublicId && parser->m_notationDeclHandler) {
         *eventEndPP = s;
         parser->m_notationDeclHandler(
             parser->m_handlerArg, parser->m_declNotationName, parser->m_curBase,
             0, parser->m_declNotationPublicId);
         handleDefault = XML_FALSE;
       }
       poolClear(&parser->m_tempPool);
       break;
     case XML_ROLE_ERROR:
       switch (tok) {
       case XML_TOK_PARAM_ENTITY_REF:
         return XML_ERROR_PARAM_ENTITY_REF;
       case XML_TOK_XML_DECL:
         return XML_ERROR_MISPLACED_XML_PI;
       default:
         return XML_ERROR_SYNTAX;
       }
 #ifdef XML_DTD
     case XML_ROLE_IGNORE_SECT: {
       enum XML_Error result;
       if (parser->m_defaultHandler)
         reportDefault(parser, enc, s, next);
       handleDefault = XML_FALSE;
       result = doIgnoreSection(parser, enc, &next, end, nextPtr, haveMore);
       if (result != XML_ERROR_NONE)
         return result;
       else if (! next) {
         parser->m_processor = ignoreSectionProcessor;
         return result;
       }
     } break;
 #endif  
     case XML_ROLE_GROUP_OPEN:
       if (parser->m_prologState.level >= parser->m_groupSize) {
         if (parser->m_groupSize) {
           {
             char *const new_connector = (char *)REALLOC(
                 parser, parser->m_groupConnector, parser->m_groupSize *= 2);
             if (new_connector == NULL) {
               parser->m_groupSize /= 2;
               return XML_ERROR_NO_MEMORY;
             }
             parser->m_groupConnector = new_connector;
           }
           if (dtd->scaffIndex) {
             int *const new_scaff_index = (int *)REALLOC(
                 parser, dtd->scaffIndex, parser->m_groupSize * sizeof(int));
             if (new_scaff_index == NULL)
               return XML_ERROR_NO_MEMORY;
             dtd->scaffIndex = new_scaff_index;
           }
         } else {
           parser->m_groupConnector
               = (char *)MALLOC(parser, parser->m_groupSize = 32);
           if (! parser->m_groupConnector) {
             parser->m_groupSize = 0;
             return XML_ERROR_NO_MEMORY;
           }
         }
       }
       parser->m_groupConnector[parser->m_prologState.level] = 0;
       if (dtd->in_eldecl) {
         int myindex = nextScaffoldPart(parser);
         if (myindex < 0)
           return XML_ERROR_NO_MEMORY;
         assert(dtd->scaffIndex != NULL);
         dtd->scaffIndex[dtd->scaffLevel] = myindex;
         dtd->scaffLevel++;
         dtd->scaffold[myindex].type = XML_CTYPE_SEQ;
         if (parser->m_elementDeclHandler)
           handleDefault = XML_FALSE;
       }
       break;
     case XML_ROLE_GROUP_SEQUENCE:
       if (parser->m_groupConnector[parser->m_prologState.level] == ASCII_PIPE)
         return XML_ERROR_SYNTAX;
       parser->m_groupConnector[parser->m_prologState.level] = ASCII_COMMA;
       if (dtd->in_eldecl && parser->m_elementDeclHandler)
         handleDefault = XML_FALSE;
       break;
     case XML_ROLE_GROUP_CHOICE:
       if (parser->m_groupConnector[parser->m_prologState.level] == ASCII_COMMA)
         return XML_ERROR_SYNTAX;
       if (dtd->in_eldecl
           && ! parser->m_groupConnector[parser->m_prologState.level]
           && (dtd->scaffold[dtd->scaffIndex[dtd->scaffLevel - 1]].type
               != XML_CTYPE_MIXED)) {
         dtd->scaffold[dtd->scaffIndex[dtd->scaffLevel - 1]].type
             = XML_CTYPE_CHOICE;
         if (parser->m_elementDeclHandler)
           handleDefault = XML_FALSE;
       }
       parser->m_groupConnector[parser->m_prologState.level] = ASCII_PIPE;
       break;
     case XML_ROLE_PARAM_ENTITY_REF:
 #ifdef XML_DTD
     case XML_ROLE_INNER_PARAM_ENTITY_REF:
       dtd->hasParamEntityRefs = XML_TRUE;
       if (! parser->m_paramEntityParsing)
         dtd->keepProcessing = dtd->standalone;
       else {
         const XML_Char *name;
         ENTITY *entity;
         name = poolStoreString(&dtd->pool, enc, s + enc->minBytesPerChar,
                                next - enc->minBytesPerChar);
         if (! name)
           return XML_ERROR_NO_MEMORY;
         entity = (ENTITY *)lookup(parser, &dtd->paramEntities, name, 0);
         poolDiscard(&dtd->pool);
         if (parser->m_prologState.documentEntity
             && (dtd->standalone ? ! parser->m_openInternalEntities
                                 : ! dtd->hasParamEntityRefs)) {
           if (! entity)
             return XML_ERROR_UNDEFINED_ENTITY;
           else if (! entity->is_internal) {
             return XML_ERROR_ENTITY_DECLARED_IN_PE;  
           }
         } else if (! entity) {
           dtd->keepProcessing = dtd->standalone;
           if ((role == XML_ROLE_PARAM_ENTITY_REF)
               && parser->m_skippedEntityHandler) {
             parser->m_skippedEntityHandler(parser->m_handlerArg, name, 1);
             handleDefault = XML_FALSE;
           }
           break;
         }
         if (entity->open)
           return XML_ERROR_RECURSIVE_ENTITY_REF;
         if (entity->textPtr) {
           enum XML_Error result;
           XML_Bool betweenDecl
               = (role == XML_ROLE_PARAM_ENTITY_REF ? XML_TRUE : XML_FALSE);
           result = processInternalEntity(parser, entity, betweenDecl);
           if (result != XML_ERROR_NONE)
             return result;
           handleDefault = XML_FALSE;
           break;
         }
         if (parser->m_externalEntityRefHandler) {
           dtd->paramEntityRead = XML_FALSE;
           entity->open = XML_TRUE;
           if (! parser->m_externalEntityRefHandler(
                   parser->m_externalEntityRefHandlerArg, 0, entity->base,
                   entity->systemId, entity->publicId)) {
             entity->open = XML_FALSE;
             return XML_ERROR_EXTERNAL_ENTITY_HANDLING;
           }
           entity->open = XML_FALSE;
           handleDefault = XML_FALSE;
           if (! dtd->paramEntityRead) {
             dtd->keepProcessing = dtd->standalone;
             break;
           }
         } else {
           dtd->keepProcessing = dtd->standalone;
           break;
         }
       }
 #endif  
       if (! dtd->standalone && parser->m_notStandaloneHandler
           && ! parser->m_notStandaloneHandler(parser->m_handlerArg))
         return XML_ERROR_NOT_STANDALONE;
       break;
     case XML_ROLE_ELEMENT_NAME:
       if (parser->m_elementDeclHandler) {
         parser->m_declElementType = getElementType(parser, enc, s, next);
         if (! parser->m_declElementType)
           return XML_ERROR_NO_MEMORY;
         dtd->scaffLevel = 0;
         dtd->scaffCount = 0;
         dtd->in_eldecl = XML_TRUE;
         handleDefault = XML_FALSE;
       }
       break;
     case XML_ROLE_CONTENT_ANY:
     case XML_ROLE_CONTENT_EMPTY:
       if (dtd->in_eldecl) {
         if (parser->m_elementDeclHandler) {
           XML_Content *content
               = (XML_Content *)MALLOC(parser, sizeof(XML_Content));
           if (! content)
             return XML_ERROR_NO_MEMORY;
           content->quant = XML_CQUANT_NONE;
           content->name = NULL;
           content->numchildren = 0;
           content->children = NULL;
           content->type = ((role == XML_ROLE_CONTENT_ANY) ? XML_CTYPE_ANY
                                                           : XML_CTYPE_EMPTY);
           *eventEndPP = s;
           parser->m_elementDeclHandler(
               parser->m_handlerArg, parser->m_declElementType->name, content);
           handleDefault = XML_FALSE;
         }
         dtd->in_eldecl = XML_FALSE;
       }
       break;
     case XML_ROLE_CONTENT_PCDATA:
       if (dtd->in_eldecl) {
         dtd->scaffold[dtd->scaffIndex[dtd->scaffLevel - 1]].type
             = XML_CTYPE_MIXED;
         if (parser->m_elementDeclHandler)
           handleDefault = XML_FALSE;
       }
       break;
     case XML_ROLE_CONTENT_ELEMENT:
       quant = XML_CQUANT_NONE;
       goto elementContent;
     case XML_ROLE_CONTENT_ELEMENT_OPT:
       quant = XML_CQUANT_OPT;
       goto elementContent;
     case XML_ROLE_CONTENT_ELEMENT_REP:
       quant = XML_CQUANT_REP;
       goto elementContent;
     case XML_ROLE_CONTENT_ELEMENT_PLUS:
       quant = XML_CQUANT_PLUS;
     elementContent:
       if (dtd->in_eldecl) {
         ELEMENT_TYPE *el;
         const XML_Char *name;
         int nameLen;
         const char *nxt
             = (quant == XML_CQUANT_NONE ? next : next - enc->minBytesPerChar);
         int myindex = nextScaffoldPart(parser);
         if (myindex < 0)
           return XML_ERROR_NO_MEMORY;
         dtd->scaffold[myindex].type = XML_CTYPE_NAME;
         dtd->scaffold[myindex].quant = quant;
         el = getElementType(parser, enc, s, nxt);
         if (! el)
           return XML_ERROR_NO_MEMORY;
         name = el->name;
         dtd->scaffold[myindex].name = name;
         nameLen = 0;
         for (; name[nameLen++];)
           ;
         dtd->contentStringLen += nameLen;
         if (parser->m_elementDeclHandler)
           handleDefault = XML_FALSE;
       }
       break;
     case XML_ROLE_GROUP_CLOSE:
       quant = XML_CQUANT_NONE;
       goto closeGroup;
     case XML_ROLE_GROUP_CLOSE_OPT:
       quant = XML_CQUANT_OPT;
       goto closeGroup;
     case XML_ROLE_GROUP_CLOSE_REP:
       quant = XML_CQUANT_REP;
       goto closeGroup;
     case XML_ROLE_GROUP_CLOSE_PLUS:
       quant = XML_CQUANT_PLUS;
     closeGroup:
       if (dtd->in_eldecl) {
         if (parser->m_elementDeclHandler)
           handleDefault = XML_FALSE;
         dtd->scaffLevel--;
         dtd->scaffold[dtd->scaffIndex[dtd->scaffLevel]].quant = quant;
         if (dtd->scaffLevel == 0) {
           if (! handleDefault) {
             XML_Content *model = build_model(parser);
             if (! model)
               return XML_ERROR_NO_MEMORY;
             *eventEndPP = s;
             parser->m_elementDeclHandler(
                 parser->m_handlerArg, parser->m_declElementType->name, model);
           }
           dtd->in_eldecl = XML_FALSE;
           dtd->contentStringLen = 0;
         }
       }
       break;
     case XML_ROLE_PI:
       if (! reportProcessingInstruction(parser, enc, s, next))
         return XML_ERROR_NO_MEMORY;
       handleDefault = XML_FALSE;
       break;
     case XML_ROLE_COMMENT:
       if (! reportComment(parser, enc, s, next))
         return XML_ERROR_NO_MEMORY;
       handleDefault = XML_FALSE;
       break;
     case XML_ROLE_NONE:
       switch (tok) {
       case XML_TOK_BOM:
         handleDefault = XML_FALSE;
         break;
       }
       break;
     case XML_ROLE_DOCTYPE_NONE:
       if (parser->m_startDoctypeDeclHandler)
         handleDefault = XML_FALSE;
       break;
     case XML_ROLE_ENTITY_NONE:
       if (dtd->keepProcessing && parser->m_entityDeclHandler)
         handleDefault = XML_FALSE;
       break;
     case XML_ROLE_NOTATION_NONE:
       if (parser->m_notationDeclHandler)
         handleDefault = XML_FALSE;
       break;
     case XML_ROLE_ATTLIST_NONE:
       if (dtd->keepProcessing && parser->m_attlistDeclHandler)
         handleDefault = XML_FALSE;
       break;
     case XML_ROLE_ELEMENT_NONE:
       if (parser->m_elementDeclHandler)
         handleDefault = XML_FALSE;
       break;
     }  
     if (handleDefault && parser->m_defaultHandler)
       reportDefault(parser, enc, s, next);
     switch (parser->m_parsingStatus.parsing) {
     case XML_SUSPENDED:
       *nextPtr = next;
       return XML_ERROR_NONE;
     case XML_FINISHED:
       return XML_ERROR_ABORTED;
     default:
       s = next;
       tok = XmlPrologTok(enc, s, end, &next);
     }
   }
 }","[2, 3, 4, 166, 167, 168]","In libexpat before 2.2.8, crafted XML input could fool the parser into changing from DTD parsing to document parsing too early; a consecutive call to XML_GetCurrentLineNumber (or XML_GetCurrentColumnNumber) then resulted in a heap-based buffer over-read.",libexpat,CVE-2019-15903,CWE-611
1692,182716," GPMF_ERR IsValidSize(GPMF_stream *ms, uint32_t size)  
  {
  	if (ms)
  	{
		int32_t nestsize = (int32_t)ms->nest_size[ms->nest_level];
 		uint32_t nestsize = (uint32_t)ms->nest_size[ms->nest_level];
  		if (nestsize == 0 && ms->nest_level == 0)
  			nestsize = ms->buffer_size_longs;
 		if (size + 2 <= nestsize) return GPMF_OK;
 	}
 	return GPMF_ERROR_BAD_STRUCTURE;
 }","[5, 6]",GoPro GPMF-parser 1.2.2 has an out-of-bounds write in OpenMP4Source in demo/GPMF_mp4reader.c.,gpmf-parser,CVE-2019-15148,CWE-787
1712,182094," static void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)
 static int read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)
  {
      int i, j, v;
      if (get_bits1(gb)) {
         if (get_bits_left(gb) < 64*8)
             return AVERROR_INVALIDDATA;
          for (i = 0; i < 64; i++) {
              v = get_bits(gb, 8);
             j = s->idsp.idct_permutation[ff_zigzag_direct[i]];
             s->intra_matrix[j]        = v;
             s->chroma_intra_matrix[j] = v;
         }
      }
      if (get_bits1(gb)) {
         if (get_bits_left(gb) < 64*8)
             return AVERROR_INVALIDDATA;
          for (i = 0; i < 64; i++) {
              get_bits(gb, 8);
          }
      }
      if (get_bits1(gb)) {
         if (get_bits_left(gb) < 64*8)
             return AVERROR_INVALIDDATA;
          for (i = 0; i < 64; i++) {
              v = get_bits(gb, 8);
             j = s->idsp.idct_permutation[ff_zigzag_direct[i]];
             s->chroma_intra_matrix[j] = v;
         }
      }
      if (get_bits1(gb)) {
         if (get_bits_left(gb) < 64*8)
             return AVERROR_INVALIDDATA;
          for (i = 0; i < 64; i++) {
              get_bits(gb, 8);
          }
      }
      next_start_code_studio(gb);
     return 0;
  }","[2, 6, 7, 16, 17, 23, 24, 32, 33, 39]",FFmpeg before commit 5aba5b89d0b1d73164d3b81764828bb8b20ff32a contains an out of array read vulnerability in ASF_F format demuxer that can result in heap memory reading. This attack appear to be exploitable via specially crafted ASF file that has to provided as input. This vulnerability appears to have been fixed in 5aba5b89d0b1d73164d3b81764828bb8b20ff32a and later.,FFmpeg,CVE-2018-1999015,CWE-125
1731,181279," forward_search_range(regex_t* reg, const UChar* str, const UChar* end, UChar* s,
 		     UChar* range, UChar** low, UChar** high, UChar** low_prev)
 {
   UChar *p, *pprev = (UChar* )NULL;
 #ifdef ONIG_DEBUG_SEARCH
   fprintf(stderr, ""forward_search_range: str: %d, end: %d, s: %d, range: %d\n"",
 	  (int )str, (int )end, (int )s, (int )range);
 #endif
   p = s;
   if (reg->dmin > 0) {
     if (ONIGENC_IS_SINGLEBYTE(reg->enc)) {
       p += reg->dmin;
     }
     else {
       UChar *q = p + reg->dmin;
       if (q >= end) return 0;  
       while (p < q) p += enclen(reg->enc, p);
     }
   }
  retry:
   switch (reg->optimize) {
   case ONIG_OPTIMIZE_EXACT:
     p = slow_search(reg->enc, reg->exact, reg->exact_end, p, end, range);
     break;
   case ONIG_OPTIMIZE_EXACT_IC:
     p = slow_search_ic(reg->enc, reg->case_fold_flag,
                        reg->exact, reg->exact_end, p, end, range);
     break;
   case ONIG_OPTIMIZE_EXACT_BM:
     p = bm_search(reg, reg->exact, reg->exact_end, p, end, range);
     break;
   case ONIG_OPTIMIZE_EXACT_BM_NOT_REV:
     p = bm_search_notrev(reg, reg->exact, reg->exact_end, p, end, range);
     break;
   case ONIG_OPTIMIZE_MAP:
     p = map_search(reg->enc, reg->map, p, range);
     break;
   }
   if (p && p < range) {
     if (p - reg->dmin < s) {
     retry_gate:
       pprev = p;
       p += enclen(reg->enc, p);
       goto retry;
     }
     if (reg->sub_anchor) {
       UChar* prev;
       switch (reg->sub_anchor) {
       case ANCHOR_BEGIN_LINE:
         if (!ON_STR_BEGIN(p)) {
           prev = onigenc_get_prev_char_head(reg->enc,
                                             (pprev ? pprev : str), p);
           if (!ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))
             goto retry_gate;
         }
         break;
       case ANCHOR_END_LINE:
         if (ON_STR_END(p)) {
 #ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE
           prev = (UChar* )onigenc_get_prev_char_head(reg->enc,
                                                      (pprev ? pprev : str), p);
           if (prev && ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))
             goto retry_gate;
 #endif
         }
         else if (! ONIGENC_IS_MBC_NEWLINE(reg->enc, p, end)
 #ifdef USE_CRNL_AS_LINE_TERMINATOR
                  && ! ONIGENC_IS_MBC_CRNL(reg->enc, p, end)
 #endif
                  )
           goto retry_gate;
         break;
       }
     }
     if (reg->dmax == 0) {
       *low = p;
       if (low_prev) {
         if (*low > s)
           *low_prev = onigenc_get_prev_char_head(reg->enc, s, p);
         else
           *low_prev = onigenc_get_prev_char_head(reg->enc,
                                                  (pprev ? pprev : str), p);
       }
      }
      else {
        if (reg->dmax != ONIG_INFINITE_DISTANCE) {
        *low = p - reg->dmax;
        if (*low > s) {
          *low = onigenc_get_right_adjust_char_head_with_prev(reg->enc, s,
                                          *low, (const UChar** )low_prev);
          if (low_prev && IS_NULL(*low_prev))
            *low_prev = onigenc_get_prev_char_head(reg->enc,
                                                   (pprev ? pprev : s), *low);
         if (p - str < reg->dmax) {
           *low = (UChar* )str;
           if (low_prev)
             *low_prev = onigenc_get_prev_char_head(reg->enc, str, *low);
          }
          else {
          if (low_prev)
            *low_prev = onigenc_get_prev_char_head(reg->enc,
                                                   (pprev ? pprev : str), *low);
           *low = p - reg->dmax;
           if (*low > s) {
             *low = onigenc_get_right_adjust_char_head_with_prev(reg->enc, s,
                                                  *low, (const UChar** )low_prev);
             if (low_prev && IS_NULL(*low_prev))
               *low_prev = onigenc_get_prev_char_head(reg->enc,
                                                      (pprev ? pprev : s), *low);
           }
           else {
             if (low_prev)
               *low_prev = onigenc_get_prev_char_head(reg->enc,
                                                      (pprev ? pprev : str), *low);
           }
          }
        }
      }
     *high = p - reg->dmin;
 #ifdef ONIG_DEBUG_SEARCH
     fprintf(stderr,
     ""forward_search_range success: low: %d, high: %d, dmin: %d, dmax: %d\n"",
 	    (int )(*low - str), (int )(*high - str), reg->dmin, reg->dmax);
 #endif
     return 1;  
   }
   return 0;  
 }","[87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115]","An issue was discovered in Oniguruma 6.2.0, as used in Oniguruma-mod in Ruby through 2.4.1 and mbstring in PHP through 7.1.5. A SIGSEGV occurs in left_adjust_char_head() during regular expression compilation. Invalid handling of reg->dmax in forward_search_range() could result in an invalid pointer dereference, normally as an immediate denial-of-service condition.",oniguruma,CVE-2017-9229,CWE-476
1736,179037," const char *string_of_NPNVariable(int variable)
 {
   const char *str;
   switch (variable) {
 #define _(VAL) case VAL: str = #VAL; break;
 	_(NPNVxDisplay);
 	_(NPNVxtAppContext);
 	_(NPNVnetscapeWindow);
 	_(NPNVjavascriptEnabledBool);
 	_(NPNVasdEnabledBool);
 	_(NPNVisOfflineBool);
 	_(NPNVserviceManager);
 	_(NPNVDOMElement);
 	_(NPNVDOMWindow);
 	_(NPNVToolkit);
 	_(NPNVSupportsXEmbedBool);
  	_(NPNVWindowNPObject);
  	_(NPNVPluginElementNPObject);
  	_(NPNVSupportsWindowless);
 	_(NPNVprivateModeBool);
 	_(NPNVsupportsAdvancedKeyHandling);
  #undef _
    default:
  	switch (variable & 0xff) {
 #define _(VAL, VAR) case VAL: str = #VAR; break
 	  _(10, NPNVserviceManager);
 	  _(11, NPNVDOMElement);
 	  _(12, NPNVDOMWindow);
 	  _(13, NPNVToolkit);
 #undef _
 	default:
 	  str = ""<unknown variable>"";
 	  break;
 	}
 	break;
   }
   return str;
 }","[20, 21]","nspluginwrapper before 1.4.4 does not properly provide access to NPNVprivateModeBool variable settings, which could prevent Firefox plugins from determining if they should run in Private Browsing mode and allow remote attackers to bypass intended access restrictions, as demonstrated using Flash.",nspluginwrapper,CVE-2011-2486,CWE-264
1750,181882,"  jas_matrix_t *jas_seq2d_input(FILE *in)
  {
  	jas_matrix_t *matrix;
	int i;
	int j;
 	jas_matind_t i;
 	jas_matind_t j;
  	long x;
	int numrows;
	int numcols;
	int xoff;
	int yoff;
	if (fscanf(in, ""%d %d"", &xoff, &yoff) != 2)
 	jas_matind_t numrows;
 	jas_matind_t numcols;
 	jas_matind_t xoff;
 	jas_matind_t yoff;
 	long tmp_xoff;
 	long tmp_yoff;
 	long tmp_numrows;
 	long tmp_numcols;
 	if (fscanf(in, ""%ld %ld"", &tmp_xoff, &tmp_yoff) != 2) {
  		return 0;
	if (fscanf(in, ""%d %d"", &numcols, &numrows) != 2)
 	}
 	xoff = tmp_xoff;
 	yoff = tmp_yoff;
 	if (fscanf(in, ""%ld %ld"", &tmp_numcols, &tmp_numrows) != 2) {
  		return 0;
	if (!(matrix = jas_seq2d_create(xoff, yoff, xoff + numcols, yoff + numrows)))
 	}
 	numrows = tmp_numrows;
 	numcols = tmp_numcols;
 	if (!(matrix = jas_seq2d_create(xoff, yoff, xoff + numcols,
 	  yoff + numrows))) {
  		return 0;
 	}
  	if (jas_matrix_numrows(matrix) != numrows ||
  	  jas_matrix_numcols(matrix) != numcols) {
 		abort();
 	}
 	for (i = 0; i < jas_matrix_numrows(matrix); i++) {
 		for (j = 0; j < jas_matrix_numcols(matrix); j++) {
 			if (fscanf(in, ""%ld"", &x) != 1) {
 				jas_matrix_destroy(matrix);
 				return 0;
 			}
 			jas_matrix_set(matrix, i, j, JAS_CAST(jas_seqent_t, x));
 		}
 	}
 	return matrix;
 }","[4, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 24, 25, 26, 27, 28, 30, 31, 32, 33, 34, 35, 37]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
1790,182616," void jpc_qmfb_join_colgrp(jpc_fix_t *a, int numrows, int stride,
   int parity)
 {
 	int bufsize = JPC_CEILDIVPOW2(numrows, 1);
 	jpc_fix_t joinbuf[QMFB_JOINBUFSIZE * JPC_QMFB_COLGRPSIZE];
 	jpc_fix_t *buf = joinbuf;
 	jpc_fix_t *srcptr;
 	jpc_fix_t *dstptr;
 	register jpc_fix_t *srcptr2;
 	register jpc_fix_t *dstptr2;
 	register int n;
 	register int i;
 	int hstartcol;
  	if (bufsize > QMFB_JOINBUFSIZE) {
		if (!(buf = jas_alloc3(bufsize, JPC_QMFB_COLGRPSIZE, sizeof(jpc_fix_t)))) {
 		if (!(buf = jas_alloc3(bufsize, JPC_QMFB_COLGRPSIZE,
 		  sizeof(jpc_fix_t)))) {
  			abort();
  		}
 	}
 	hstartcol = (numrows + 1 - parity) >> 1;
 	n = hstartcol;
 	srcptr = &a[0];
 	dstptr = buf;
 	while (n-- > 0) {
 		dstptr2 = dstptr;
 		srcptr2 = srcptr;
 		for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
 			*dstptr2 = *srcptr2;
 			++dstptr2;
 			++srcptr2;
 		}
 		srcptr += stride;
 		dstptr += JPC_QMFB_COLGRPSIZE;
 	}
 	srcptr = &a[hstartcol * stride];
 	dstptr = &a[(1 - parity) * stride];
 	n = numrows - hstartcol;
 	while (n-- > 0) {
 		dstptr2 = dstptr;
 		srcptr2 = srcptr;
 		for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
 			*dstptr2 = *srcptr2;
 			++dstptr2;
 			++srcptr2;
 		}
 		dstptr += 2 * stride;
 		srcptr += stride;
 	}
 	srcptr = buf;
 	dstptr = &a[parity * stride];
 	n = hstartcol;
 	while (n-- > 0) {
 		dstptr2 = dstptr;
 		srcptr2 = srcptr;
 		for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
 			*dstptr2 = *srcptr2;
 			++dstptr2;
 			++srcptr2;
 		}
 		dstptr += 2 * stride;
 		srcptr += JPC_QMFB_COLGRPSIZE;
 	}
 	if (buf != joinbuf) {
 		jas_free(buf);
 	}
 }","[15, 16, 17]",A heap-buffer overflow vulnerability was found in QMFB code in JPC codec caused by buffer being allocated with too small size. jasper versions before 2.0.0 are affected.,jasper,CVE-2016-8654,CWE-119
1795,182928," int main(int argc, char *argv[])
 {
     time_t timep;
     struct tm *timeptr;
     char *now;
     if (argc < 3) {
         send_error(1);
         return -1;
     } else if (argc > 3) {
         send_error(5);
         return -1;
     }
     build_needs_escape();
     if (argv[2] == NULL)
         index_directory(argv[1], argv[1]);
     else
         index_directory(argv[1], argv[2]);
     time(&timep);
 #ifdef USE_LOCALTIME
     timeptr = localtime(&timep);
 #else
      timeptr = gmtime(&timep);
  #endif
      now = strdup(asctime(timeptr));
 	if (!now) {
 		return -1;
 	}
      now[strlen(now) - 1] = '\0';
  #ifdef USE_LOCALTIME
      printf(""</table>\n<hr noshade>\nIndex generated %s %s\n""
            ""<!-- This program is part of the Boa Webserver Copyright (C) 1991-2002 http:www.boa.org -->\n""
            ""</body>\n</html>\n"", now, TIMEZONE(timeptr));
 #else
     printf(""</table>\n<hr noshade>\nIndex generated %s UTC\n""
             ""<!-- This program is part of the Boa Webserver Copyright (C) 1991-2002 http:www.boa.org -->\n""
             ""</body>\n</html>\n"", now);
  #endif
 	free(now);
      return 0;
  }","[25, 26, 27, 38]",Boa through 0.94.14rc21 allows remote attackers to trigger a memory leak because of missing calls to the free function.,boa,CVE-2018-21028,
1801,182686," static int asn1_decode_entry(sc_context_t *ctx,struct sc_asn1_entry *entry,
 			     const u8 *obj, size_t objlen, int depth)
 {
 	void *parm = entry->parm;
 	int (*callback_func)(sc_context_t *nctx, void *arg, const u8 *nobj,
 			     size_t nobjlen, int ndepth);
 	size_t *len = (size_t *) entry->arg;
 	int r = 0;
 	callback_func = parm;
 	sc_debug(ctx, SC_LOG_DEBUG_ASN1, ""%*.*sdecoding '%s', raw data:%s%s\n"",
 		depth, depth, """", entry->name,
 		sc_dump_hex(obj, objlen > 16  ? 16 : objlen),
 		objlen > 16 ? ""..."" : """");
 	switch (entry->type) {
 	case SC_ASN1_STRUCT:
 		if (parm != NULL)
 			r = asn1_decode(ctx, (struct sc_asn1_entry *) parm, obj,
 				       objlen, NULL, NULL, 0, depth + 1);
 		break;
 	case SC_ASN1_NULL:
 		break;
 	case SC_ASN1_BOOLEAN:
 		if (parm != NULL) {
 			if (objlen != 1) {
 				sc_debug(ctx, SC_LOG_DEBUG_ASN1,
 					 ""invalid ASN.1 object length: %""SC_FORMAT_LEN_SIZE_T""u\n"",
 					 objlen);
 				r = SC_ERROR_INVALID_ASN1_OBJECT;
 			} else
 				*((int *) parm) = obj[0] ? 1 : 0;
 		}
 		break;
 	case SC_ASN1_INTEGER:
 	case SC_ASN1_ENUMERATED:
 		if (parm != NULL) {
 			r = sc_asn1_decode_integer(obj, objlen, (int *) entry->parm);
 			sc_debug(ctx, SC_LOG_DEBUG_ASN1, ""%*.*sdecoding '%s' returned %d\n"", depth, depth, """",
 					entry->name, *((int *) entry->parm));
 		}
 		break;
 	case SC_ASN1_BIT_STRING_NI:
 	case SC_ASN1_BIT_STRING:
 		if (parm != NULL) {
 			int invert = entry->type == SC_ASN1_BIT_STRING ? 1 : 0;
 			assert(len != NULL);
 			if (objlen < 1) {
 				r = SC_ERROR_INVALID_ASN1_OBJECT;
 				break;
 			}
 			if (entry->flags & SC_ASN1_ALLOC) {
 				u8 **buf = (u8 **) parm;
 				*buf = malloc(objlen-1);
 				if (*buf == NULL) {
 					r = SC_ERROR_OUT_OF_MEMORY;
 					break;
 				}
 				*len = objlen-1;
 				parm = *buf;
 			}
 			r = decode_bit_string(obj, objlen, (u8 *) parm, *len, invert);
 			if (r >= 0) {
 				*len = r;
 				r = 0;
 			}
 		}
 		break;
 	case SC_ASN1_BIT_FIELD:
 		if (parm != NULL)
 			r = decode_bit_field(obj, objlen, (u8 *) parm, *len);
 		break;
 	case SC_ASN1_OCTET_STRING:
 		if (parm != NULL) {
 			size_t c;
 			assert(len != NULL);
  			if ((entry->flags & SC_ASN1_UNSIGNED)
			 && obj[0] == 0x00 && objlen > 1) {
 					&& objlen > 1 && obj[0] == 0x00) {
  				objlen--;
  				obj++;
  			}
 			if (entry->flags & SC_ASN1_ALLOC) {
 				u8 **buf = (u8 **) parm;
 				*buf = malloc(objlen);
 				if (*buf == NULL) {
 					r = SC_ERROR_OUT_OF_MEMORY;
 					break;
 				}
 				c = *len = objlen;
 				parm = *buf;
 			} else
 				c = objlen > *len ? *len : objlen;
 			memcpy(parm, obj, c);
 			*len = c;
 		}
 		break;
 	case SC_ASN1_GENERALIZEDTIME:
 		if (parm != NULL) {
 			size_t c;
 			assert(len != NULL);
 			if (entry->flags & SC_ASN1_ALLOC) {
 				u8 **buf = (u8 **) parm;
 				*buf = malloc(objlen);
 				if (*buf == NULL) {
 					r = SC_ERROR_OUT_OF_MEMORY;
 					break;
 				}
 				c = *len = objlen;
 				parm = *buf;
 			} else
 				c = objlen > *len ? *len : objlen;
 			memcpy(parm, obj, c);
 			*len = c;
 		}
 		break;
 	case SC_ASN1_OBJECT:
 		if (parm != NULL)
 			r = sc_asn1_decode_object_id(obj, objlen, (struct sc_object_id *) parm);
 		break;
 	case SC_ASN1_PRINTABLESTRING:
 	case SC_ASN1_UTF8STRING:
 		if (parm != NULL) {
 			assert(len != NULL);
 			if (entry->flags & SC_ASN1_ALLOC) {
 				u8 **buf = (u8 **) parm;
 				*buf = malloc(objlen+1);
 				if (*buf == NULL) {
 					r = SC_ERROR_OUT_OF_MEMORY;
 					break;
 				}
 				*len = objlen+1;
 				parm = *buf;
 			}
 			r = sc_asn1_decode_utf8string(obj, objlen, (u8 *) parm, len);
 			if (entry->flags & SC_ASN1_ALLOC) {
 				*len -= 1;
 			}
 		}
 		break;
 	case SC_ASN1_PATH:
 		if (entry->parm != NULL)
 			r = asn1_decode_path(ctx, obj, objlen, (sc_path_t *) parm, depth);
 		break;
 	case SC_ASN1_PKCS15_ID:
 		if (entry->parm != NULL) {
 			struct sc_pkcs15_id *id = (struct sc_pkcs15_id *) parm;
 			size_t c = objlen > sizeof(id->value) ? sizeof(id->value) : objlen;
 			memcpy(id->value, obj, c);
 			id->len = c;
 		}
 		break;
 	case SC_ASN1_PKCS15_OBJECT:
 		if (entry->parm != NULL)
 			r = asn1_decode_p15_object(ctx, obj, objlen, (struct sc_asn1_pkcs15_object *) parm, depth);
 		break;
 	case SC_ASN1_ALGORITHM_ID:
 		if (entry->parm != NULL)
 			r = sc_asn1_decode_algorithm_id(ctx, obj, objlen, (struct sc_algorithm_id *) parm, depth);
 		break;
 	case SC_ASN1_SE_INFO:
 		if (entry->parm != NULL)
 			r = asn1_decode_se_info(ctx, obj, objlen, (sc_pkcs15_sec_env_info_t ***)entry->parm, len, depth);
 		break;
 	case SC_ASN1_CALLBACK:
 		if (entry->parm != NULL)
 			r = callback_func(ctx, entry->arg, obj, objlen, depth);
 		break;
 	default:
 		sc_debug(ctx, SC_LOG_DEBUG_ASN1, ""invalid ASN.1 type: %d\n"", entry->type);
 		return SC_ERROR_INVALID_ASN1_OBJECT;
 	}
 	if (r) {
 		sc_debug(ctx, SC_LOG_DEBUG_ASN1, ""decoding of ASN.1 object '%s' failed: %s\n"", entry->name,
 		      sc_strerror(r));
 		return r;
 	}
 	entry->flags |= SC_ASN1_PRESENT;
 	return 0;
 }","[76, 77]",OpenSC before 0.20.0-rc1 has an out-of-bounds access of an ASN.1 Octet string in asn1_decode_entry in libopensc/asn1.c.,OpenSC,CVE-2019-15946,CWE-119
1814,181646,"  void *jas_malloc(size_t size)
  {
  	void *result;
	JAS_DBGLOG(101, (""jas_malloc called with %zu\n"", size));
 	JAS_DBGLOG(101, (""jas_malloc(%zu)\n"", size));
  	result = malloc(size);
  	JAS_DBGLOG(100, (""jas_malloc(%zu) -> %p\n"", size, result));
  	return result;
 }","[4, 5]","Integer overflow in the jpc_dec_tiledecode function in jpc_dec.c in JasPer before 1.900.12 allows remote attackers to have unspecified impact via a crafted image file, which triggers a heap-based buffer overflow.",jasper,CVE-2016-10249,CWE-190
1818,182876,"  static void numtostr(js_State *J, const char *fmt, int w, double n)
  {
	char buf[32], *e;
 	char buf[50], *e;
  	sprintf(buf, fmt, w, n);
  	e = strchr(buf, 'e');
  	if (e) {
 		int exp = atoi(e+1);
 		sprintf(e, ""e%+d"", exp);
 	}
 	js_pushstring(J, buf);
 }","[3, 4]",An issue was discovered in Artifex MuJS 1.0.5. The Number#toFixed() and numtostr implementations in jsnumber.c have a stack-based buffer overflow.,mujs,CVE-2019-11411,CWE-119
1831,182878," static int decode_nal_unit(HEVCContext *s, const H2645NAL *nal)
 {
     HEVCLocalContext *lc = s->HEVClc;
     GetBitContext *gb    = &lc->gb;
     int ctb_addr_ts, ret;
     *gb              = nal->gb;
     s->nal_unit_type = nal->type;
     s->temporal_id   = nal->temporal_id;
     switch (s->nal_unit_type) {
     case HEVC_NAL_VPS:
         if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {
             ret = s->avctx->hwaccel->decode_params(s->avctx,
                                                    nal->type,
                                                    nal->raw_data,
                                                    nal->raw_size);
             if (ret < 0)
                 goto fail;
         }
         ret = ff_hevc_decode_nal_vps(gb, s->avctx, &s->ps);
         if (ret < 0)
             goto fail;
         break;
     case HEVC_NAL_SPS:
         if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {
             ret = s->avctx->hwaccel->decode_params(s->avctx,
                                                    nal->type,
                                                    nal->raw_data,
                                                    nal->raw_size);
             if (ret < 0)
                 goto fail;
         }
         ret = ff_hevc_decode_nal_sps(gb, s->avctx, &s->ps,
                                      s->apply_defdispwin);
         if (ret < 0)
             goto fail;
         break;
     case HEVC_NAL_PPS:
         if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {
             ret = s->avctx->hwaccel->decode_params(s->avctx,
                                                    nal->type,
                                                    nal->raw_data,
                                                    nal->raw_size);
             if (ret < 0)
                 goto fail;
         }
         ret = ff_hevc_decode_nal_pps(gb, s->avctx, &s->ps);
         if (ret < 0)
             goto fail;
         break;
     case HEVC_NAL_SEI_PREFIX:
     case HEVC_NAL_SEI_SUFFIX:
         if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {
             ret = s->avctx->hwaccel->decode_params(s->avctx,
                                                    nal->type,
                                                    nal->raw_data,
                                                    nal->raw_size);
             if (ret < 0)
                 goto fail;
         }
         ret = ff_hevc_decode_nal_sei(gb, s->avctx, &s->sei, &s->ps, s->nal_unit_type);
         if (ret < 0)
             goto fail;
         break;
     case HEVC_NAL_TRAIL_R:
     case HEVC_NAL_TRAIL_N:
     case HEVC_NAL_TSA_N:
     case HEVC_NAL_TSA_R:
     case HEVC_NAL_STSA_N:
     case HEVC_NAL_STSA_R:
     case HEVC_NAL_BLA_W_LP:
     case HEVC_NAL_BLA_W_RADL:
     case HEVC_NAL_BLA_N_LP:
     case HEVC_NAL_IDR_W_RADL:
     case HEVC_NAL_IDR_N_LP:
     case HEVC_NAL_CRA_NUT:
     case HEVC_NAL_RADL_N:
     case HEVC_NAL_RADL_R:
     case HEVC_NAL_RASL_N:
     case HEVC_NAL_RASL_R:
          ret = hls_slice_header(s);
          if (ret < 0)
              return ret;
         if (ret == 1) {
             ret = AVERROR_INVALIDDATA;
             goto fail;
         }
          if (
              (s->avctx->skip_frame >= AVDISCARD_BIDIR && s->sh.slice_type == HEVC_SLICE_B) ||
             (s->avctx->skip_frame >= AVDISCARD_NONINTRA && s->sh.slice_type != HEVC_SLICE_I) ||
             (s->avctx->skip_frame >= AVDISCARD_NONKEY && !IS_IRAP(s))) {
             break;
          }
          if (s->sh.first_slice_in_pic_flag) {
            if (s->ref) {
                av_log(s->avctx, AV_LOG_ERROR, ""Two slices reporting being the first in the same frame.\n"");
                goto fail;
            }
              if (s->max_ra == INT_MAX) {
                  if (s->nal_unit_type == HEVC_NAL_CRA_NUT || IS_BLA(s)) {
                      s->max_ra = s->poc;
                 } else {
                     if (IS_IDR(s))
                         s->max_ra = INT_MIN;
                 }
             }
             if ((s->nal_unit_type == HEVC_NAL_RASL_R || s->nal_unit_type == HEVC_NAL_RASL_N) &&
                 s->poc <= s->max_ra) {
                 s->is_decoded = 0;
                 break;
             } else {
                 if (s->nal_unit_type == HEVC_NAL_RASL_R && s->poc > s->max_ra)
                     s->max_ra = INT_MIN;
             }
             s->overlap ++;
             ret = hevc_frame_start(s);
             if (ret < 0)
                 return ret;
         } else if (!s->ref) {
             av_log(s->avctx, AV_LOG_ERROR, ""First slice in a frame missing.\n"");
             goto fail;
         }
         if (s->nal_unit_type != s->first_nal_type) {
             av_log(s->avctx, AV_LOG_ERROR,
                    ""Non-matching NAL types of the VCL NALUs: %d %d\n"",
                    s->first_nal_type, s->nal_unit_type);
             return AVERROR_INVALIDDATA;
         }
         if (!s->sh.dependent_slice_segment_flag &&
             s->sh.slice_type != HEVC_SLICE_I) {
             ret = ff_hevc_slice_rpl(s);
             if (ret < 0) {
                 av_log(s->avctx, AV_LOG_WARNING,
                        ""Error constructing the reference lists for the current slice.\n"");
                 goto fail;
             }
         }
         if (s->sh.first_slice_in_pic_flag && s->avctx->hwaccel) {
             ret = s->avctx->hwaccel->start_frame(s->avctx, NULL, 0);
             if (ret < 0)
                 goto fail;
         }
         if (s->avctx->hwaccel) {
             ret = s->avctx->hwaccel->decode_slice(s->avctx, nal->raw_data, nal->raw_size);
             if (ret < 0)
                 goto fail;
         } else {
             if (s->threads_number > 1 && s->sh.num_entry_point_offsets > 0)
                 ctb_addr_ts = hls_slice_data_wpp(s, nal);
             else
                 ctb_addr_ts = hls_slice_data(s);
             if (ctb_addr_ts >= (s->ps.sps->ctb_width * s->ps.sps->ctb_height)) {
                 s->is_decoded = 1;
             }
             if (ctb_addr_ts < 0) {
                 ret = ctb_addr_ts;
                 goto fail;
             }
         }
         break;
     case HEVC_NAL_EOS_NUT:
     case HEVC_NAL_EOB_NUT:
         s->seq_decode = (s->seq_decode + 1) & 0xff;
         s->max_ra     = INT_MAX;
         break;
     case HEVC_NAL_AUD:
     case HEVC_NAL_FD_NUT:
         break;
     default:
         av_log(s->avctx, AV_LOG_INFO,
                ""Skipping NAL unit %d\n"", s->nal_unit_type);
     }
     return 0;
 fail:
     if (s->avctx->err_recognition & AV_EF_EXPLODE)
         return ret;
     return 0;
 }","[83, 84, 85, 86, 94, 95, 96, 97]","libavcodec/hevcdec.c in FFmpeg 4.1.2 mishandles detection of duplicate first slices, which allows remote attackers to cause a denial of service (NULL pointer dereference and out-of-array access) or possibly have unspecified other impact via crafted HEVC data.",FFmpeg,CVE-2019-11338,CWE-476
1837,181421," static int decode_frame(AVCodecContext *avctx,
                         void *data, int *got_frame,
                         AVPacket *avpkt)
 {
     PicContext *s = avctx->priv_data;
     AVFrame *frame = data;
     uint32_t *palette;
     int bits_per_plane, bpp, etype, esize, npal, pos_after_pal;
     int i, x, y, plane, tmp, ret, val;
     bytestream2_init(&s->g, avpkt->data, avpkt->size);
     if (bytestream2_get_bytes_left(&s->g) < 11)
         return AVERROR_INVALIDDATA;
     if (bytestream2_get_le16u(&s->g) != 0x1234)
         return AVERROR_INVALIDDATA;
     s->width       = bytestream2_get_le16u(&s->g);
     s->height      = bytestream2_get_le16u(&s->g);
     bytestream2_skip(&s->g, 4);
     tmp            = bytestream2_get_byteu(&s->g);
     bits_per_plane = tmp & 0xF;
     s->nb_planes   = (tmp >> 4) + 1;
     bpp            = bits_per_plane * s->nb_planes;
     if (bits_per_plane > 8 || bpp < 1 || bpp > 32) {
         avpriv_request_sample(avctx, ""Unsupported bit depth"");
         return AVERROR_PATCHWELCOME;
     }
     if (bytestream2_peek_byte(&s->g) == 0xFF || bpp == 1 || bpp == 4 || bpp == 8) {
         bytestream2_skip(&s->g, 2);
         etype = bytestream2_get_le16(&s->g);
         esize = bytestream2_get_le16(&s->g);
         if (bytestream2_get_bytes_left(&s->g) < esize)
             return AVERROR_INVALIDDATA;
     } else {
         etype = -1;
         esize = 0;
     }
     avctx->pix_fmt = AV_PIX_FMT_PAL8;
      if (av_image_check_size(s->width, s->height, 0, avctx) < 0)
          return -1;
    if (s->width != avctx->width && s->height != avctx->height) {
     if (s->width != avctx->width || s->height != avctx->height) {
          ret = ff_set_dimensions(avctx, s->width, s->height);
          if (ret < 0)
              return ret;
     }
     if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)
         return ret;
     memset(frame->data[0], 0, s->height * frame->linesize[0]);
     frame->pict_type           = AV_PICTURE_TYPE_I;
     frame->palette_has_changed = 1;
     pos_after_pal = bytestream2_tell(&s->g) + esize;
     palette = (uint32_t*)frame->data[1];
     if (etype == 1 && esize > 1 && bytestream2_peek_byte(&s->g) < 6) {
         int idx = bytestream2_get_byte(&s->g);
         npal = 4;
         for (i = 0; i < npal; i++)
             palette[i] = ff_cga_palette[ cga_mode45_index[idx][i] ];
     } else if (etype == 2) {
         npal = FFMIN(esize, 16);
         for (i = 0; i < npal; i++) {
             int pal_idx = bytestream2_get_byte(&s->g);
             palette[i]  = ff_cga_palette[FFMIN(pal_idx, 15)];
         }
     } else if (etype == 3) {
         npal = FFMIN(esize, 16);
         for (i = 0; i < npal; i++) {
             int pal_idx = bytestream2_get_byte(&s->g);
             palette[i]  = ff_ega_palette[FFMIN(pal_idx, 63)];
         }
     } else if (etype == 4 || etype == 5) {
         npal = FFMIN(esize / 3, 256);
         for (i = 0; i < npal; i++) {
             palette[i] = bytestream2_get_be24(&s->g) << 2;
             palette[i] |= 0xFFU << 24 | palette[i] >> 6 & 0x30303;
         }
     } else {
         if (bpp == 1) {
             npal = 2;
             palette[0] = 0xFF000000;
             palette[1] = 0xFFFFFFFF;
         } else if (bpp == 2) {
             npal = 4;
             for (i = 0; i < npal; i++)
                 palette[i] = ff_cga_palette[ cga_mode45_index[0][i] ];
         } else {
             npal = 16;
             memcpy(palette, ff_cga_palette, npal * 4);
         }
     }
     memset(palette + npal, 0, AVPALETTE_SIZE - npal * 4);
     bytestream2_seek(&s->g, pos_after_pal, SEEK_SET);
     val = 0;
     y = s->height - 1;
     if (bytestream2_get_le16(&s->g)) {
         x = 0;
         plane = 0;
         while (bytestream2_get_bytes_left(&s->g) >= 6) {
             int stop_size, marker, t1, t2;
             t1        = bytestream2_get_bytes_left(&s->g);
             t2        = bytestream2_get_le16(&s->g);
             stop_size = t1 - FFMIN(t1, t2);
             bytestream2_skip(&s->g, 2);
             marker    = bytestream2_get_byte(&s->g);
             while (plane < s->nb_planes &&
                    bytestream2_get_bytes_left(&s->g) > stop_size) {
                 int run = 1;
                 val = bytestream2_get_byte(&s->g);
                 if (val == marker) {
                     run = bytestream2_get_byte(&s->g);
                     if (run == 0)
                         run = bytestream2_get_le16(&s->g);
                     val = bytestream2_get_byte(&s->g);
                 }
                 if (!bytestream2_get_bytes_left(&s->g))
                     break;
                 if (bits_per_plane == 8) {
                     picmemset_8bpp(s, frame, val, run, &x, &y);
                     if (y < 0)
                         goto finish;
                 } else {
                     picmemset(s, frame, val, run, &x, &y, &plane, bits_per_plane);
                 }
             }
         }
         if (x < avctx->width) {
             int run = (y + 1) * avctx->width - x;
             if (bits_per_plane == 8)
                 picmemset_8bpp(s, frame, val, run, &x, &y);
             else
                 picmemset(s, frame, val, run / (8 / bits_per_plane), &x, &y, &plane, bits_per_plane);
         }
     } else {
         while (y >= 0 && bytestream2_get_bytes_left(&s->g) > 0) {
             memcpy(frame->data[0] + y * frame->linesize[0], s->g.buffer, FFMIN(avctx->width, bytestream2_get_bytes_left(&s->g)));
             bytestream2_skip(&s->g, avctx->width);
             y--;
         }
     }
 finish:
     *got_frame      = 1;
     return avpkt->size;
 }","[39, 40]",FFmpeg before 2017-02-07 has an out-of-bounds write caused by a heap-based buffer overflow related to the decode_frame function in libavcodec/pictordec.c.,FFmpeg,CVE-2017-7862,CWE-787
1839,180137," static void user_login(struct mt_connection *curconn, struct mt_mactelnet_hdr *pkthdr) {
 	struct mt_packet pdata;
 	unsigned char md5sum[17];
  	char md5data[100];
  	struct mt_credentials *user;
  	char *slavename;
 	int act_pass_len;
  	read_userfile();
 	if ((user = find_user(curconn->username)) != NULL) {
 		md5_state_t state;
 #if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)
 		mlock(md5data, sizeof(md5data));
 		mlock(md5sum, sizeof(md5sum));
 		if (user->password != NULL) {
 			mlock(user->password, strlen(user->password));
  		}
  #endif
 		act_pass_len = strlen(user->password);
 		act_pass_len = act_pass_len <= 82 ? act_pass_len : 82;
  		md5data[0] = 0;
		strncpy(md5data + 1, user->password, 82);
		memcpy(md5data + 1 + strlen(user->password), curconn->pass_salt, 16);
 		memcpy(md5data + 1, user->password, act_pass_len);
 		memcpy(md5data + 1 + act_pass_len, curconn->pass_salt, 16);
  		md5_init(&state);
		md5_append(&state, (const md5_byte_t *)md5data, strlen(user->password) + 17);
 		md5_append(&state, (const md5_byte_t *)md5data, 1 + act_pass_len + 16);
  		md5_finish(&state, (md5_byte_t *)md5sum + 1);
  		md5sum[0] = 0;
 		init_packet(&pdata, MT_PTYPE_DATA, pkthdr->dstaddr, pkthdr->srcaddr, pkthdr->seskey, curconn->outcounter);
 		curconn->outcounter += add_control_packet(&pdata, MT_CPTYPE_END_AUTH, NULL, 0);
 		send_udp(curconn, &pdata);
 		if (curconn->state == STATE_ACTIVE) {
 			return;
 		}
 	}
 	if (user == NULL || memcmp(md5sum, curconn->trypassword, 17) != 0) {
 		syslog(LOG_NOTICE, _(""(%d) Invalid login by %s.""), curconn->seskey, curconn->username);
 		abort_connection(curconn, pkthdr, _(""Login failed, incorrect username or password\r\n""));
 		return;
 	}
 	curconn->state = STATE_ACTIVE;
 	curconn->terminal_mode = 1;
 	curconn->ptsfd = posix_openpt(O_RDWR);
 	if (curconn->ptsfd == -1 || grantpt(curconn->ptsfd) == -1 || unlockpt(curconn->ptsfd) == -1) {
 			syslog(LOG_ERR, ""posix_openpt: %s"", strerror(errno));
 			abort_connection(curconn, pkthdr, _(""Terminal error\r\n""));
 			return;
 	}
 	slavename = ptsname(curconn->ptsfd);
 	if (slavename != NULL) {
 		pid_t pid;
 		struct stat sb;
 		struct passwd *user = (struct passwd *)malloc(sizeof(struct passwd));
 		struct passwd *tmpuser=user;
 		char *buffer = malloc(1024);
 		if (user == NULL || buffer == NULL) {
 			syslog(LOG_CRIT, _(""(%d) Error allocating memory.""), curconn->seskey);
 			abort_connection(curconn, pkthdr, _(""System error, out of memory\r\n""));
 			return;
 		}
 		if (getpwnam_r(curconn->username, user, buffer, 1024, &tmpuser) != 0) {
 			syslog(LOG_WARNING, _(""(%d) Login ok, but local user not accessible (%s).""), curconn->seskey, curconn->username);
 			abort_connection(curconn, pkthdr, _(""Local user not accessible\r\n""));
 			free(user);
 			free(buffer);
 			return;
 		}
 		chown(slavename, user->pw_uid, user->pw_gid);
 		curconn->slavefd = open(slavename, O_RDWR);
 		if (curconn->slavefd == -1) {
 			syslog(LOG_ERR, _(""Error opening %s: %s""), slavename, strerror(errno));
 			abort_connection(curconn, pkthdr, _(""Error opening terminal\r\n""));
 			list_remove_connection(curconn);
 			return;
 		}
 		if ((pid = fork()) == 0) {
 			struct net_interface *interface;
 			uwtmp_login(curconn);
 			syslog(LOG_INFO, _(""(%d) User %s logged in.""), curconn->seskey, curconn->username);
 			setenv(""USER"", user->pw_name, 1);
 			setenv(""HOME"", user->pw_dir, 1);
 			setenv(""SHELL"", user->pw_shell, 1);
 			setenv(""TERM"", curconn->terminal_type, 1);
 			close(sockfd);
 			close(insockfd);
 			DL_FOREACH(interfaces, interface) {
 				if (interface->socketfd > 0) {
 					close(interface->socketfd);
 				}
 			}
 			setsid();
 			fcntl (curconn->slavefd, F_SETFD, FD_CLOEXEC);
 			close(curconn->ptsfd);
 			close(0);
 			dup(curconn->slavefd);
 			close(1);
 			dup(curconn->slavefd);
 			close(2);
 			dup(curconn->slavefd);
 			ioctl(0, TIOCSCTTY, 1);
 			tcsetpgrp(0, getpid());
 			if ((setgid(user->pw_gid) != 0) || (setuid(user->pw_uid) != 0)) {
 				syslog(LOG_ERR, _(""(%d) Could not log in %s (%d:%d): setuid/setgid: %s""), curconn->seskey, curconn->username, user->pw_uid, user->pw_gid, strerror(errno));
 				abort_connection(curconn, pkthdr, _(""Internal error\r\n""));
 				exit(0);
 			}
 			if (stat(_PATH_NOLOGIN, &sb) == 0 && getuid() != 0) {
 				syslog(LOG_NOTICE, _(""(%d) User %s disconnected with "" _PATH_NOLOGIN "" message.""), curconn->seskey, curconn->username);
 				display_nologin();
 				curconn->state = STATE_CLOSED;
 				init_packet(&pdata, MT_PTYPE_END, pkthdr->dstaddr, pkthdr->srcaddr, pkthdr->seskey, curconn->outcounter);
 				send_udp(curconn, &pdata);
 				exit(0);
 			}
 			display_motd();
 			chdir(user->pw_dir);
 			execl(user->pw_shell, user->pw_shell, ""-"", (char *) 0);
 			exit(0);  
 		}
 		free(user);
 		free(buffer);
 		close(curconn->slavefd);
 		curconn->pid = pid;
 		set_terminal_size(curconn->ptsfd, curconn->terminal_width, curconn->terminal_height);
 	}
 }","[7, 18, 19, 21, 22, 23, 24, 26, 27]",Buffer overflow in the handle_packet function in mactelnet.c in the client in MAC-Telnet 0.4.3 and earlier allows remote TELNET servers to execute arbitrary code via a long string in an MT_CPTYPE_PASSSALT control packet.,MAC-Telnet,CVE-2016-7115,CWE-119
1845,182964," static Bool FFD_CanHandleURL(GF_InputService *plug, const char *url)
 {
 	Bool has_audio, has_video;
 	s32 i;
  	AVFormatContext *ctx;
  	AVOutputFormat *fmt_out;
  	Bool ret = GF_FALSE;
	char *ext, szName[1000], szExt[20];
 	char *ext, szName[1024], szExt[20];
  	const char *szExtList;
  	FFDemux *ffd;
  	if (!plug || !url)
 		return GF_FALSE;
 	if (!strnicmp(url, ""rtsp:"", 7)) return GF_FALSE;
 	if (!strnicmp(url, ""rtspu:"", 8)) return GF_FALSE;
 	if (!strnicmp(url, ""rtp:"", 6)) return GF_FALSE;
 	if (!strnicmp(url, ""plato:"", 8)) return GF_FALSE;
 	if (!strnicmp(url, ""udp:"", 6)) return GF_FALSE;
 	if (!strnicmp(url, ""tcp:"", 6)) return GF_FALSE;
 	if (!strnicmp(url, ""data:"", 5)) return GF_FALSE;
  	ffd = (FFDemux*)plug->priv;
 	if (strlen(url) >= sizeof(szName))
 		return GF_FALSE;
  	strcpy(szName, url);
  	ext = strrchr(szName, '#');
  	if (ext) ext[0] = 0;
 	ext = strrchr(szName, '?');
 	if (ext) ext[0] = 0;
  	ext = strrchr(szName, '.');
  	if (ext && strlen(ext) > 19) ext = NULL;
	if (ext && strlen(ext) > 1) {
 	if (ext && strlen(ext) > 1 && strlen(ext) <= sizeof(szExt)) {
  		strcpy(szExt, &ext[1]);
  		strlwr(szExt);
  #ifndef FFMPEG_DEMUX_ENABLE_MPEG2TS
 		if (strstr(""ts m2t mts dmb trp"", szExt) ) return GF_FALSE;
 #endif
 		if (!strcmp(szExt, ""mp4"") || !strcmp(szExt, ""mpg4"") || !strcmp(szExt, ""m4a"") || !strcmp(szExt, ""m21"")
 		        || !strcmp(szExt, ""m4v"") || !strcmp(szExt, ""m4a"")
 		        || !strcmp(szExt, ""m4s"") || !strcmp(szExt, ""3gs"")
 		        || !strcmp(szExt, ""3gp"") || !strcmp(szExt, ""3gpp"") || !strcmp(szExt, ""3gp2"") || !strcmp(szExt, ""3g2"")
 		        || !strcmp(szExt, ""mp3"")
 		        || !strcmp(szExt, ""ac3"")
 		        || !strcmp(szExt, ""amr"")
 		        || !strcmp(szExt, ""bt"") || !strcmp(szExt, ""wrl"") || !strcmp(szExt, ""x3dv"")
 		        || !strcmp(szExt, ""xmt"") || !strcmp(szExt, ""xmta"") || !strcmp(szExt, ""x3d"")
 		        || !strcmp(szExt, ""jpg"") || !strcmp(szExt, ""jpeg"") || !strcmp(szExt, ""png"")
 		   ) return GF_FALSE;
 		{
 			u32 i;
 			for (i = 0 ; FFD_MIME_TYPES[i]; i+=3) {
 				if (gf_service_check_mime_register(plug, FFD_MIME_TYPES[i], FFD_MIME_TYPES[i+1], FFD_MIME_TYPES[i+2], ext))
 					return GF_TRUE;
 			}
 		}
 	}
 	ffd_parse_options(ffd, url);
 	ctx = NULL;
 	if (open_file(&ctx, szName, NULL, ffd->options ? &ffd->options : NULL)<0) {
 		AVInputFormat *av_in = NULL;
 		if (ext && !strcmp(szExt, ""cmp"")) av_in = av_find_input_format(""m4v"");
 		if (open_file(&ctx, szName, av_in, ffd->options ? &ffd->options : NULL)<0) {
 			return GF_FALSE;
 		}
 	}
 	if (!ctx) goto exit;
 	if (av_find_stream_info(ctx) <0) goto exit;
 	has_video = has_audio = GF_FALSE;
 	for(i = 0; i < (s32)ctx->nb_streams; i++) {
 		AVCodecContext *enc = ctx->streams[i]->codec;
 		switch(enc->codec_type) {
 		case AVMEDIA_TYPE_AUDIO:
 			if (!has_audio) has_audio = GF_TRUE;
 			break;
 		case AVMEDIA_TYPE_VIDEO:
 			if (!has_video) has_video= GF_TRUE;
 			break;
 		default:
 			break;
 		}
 	}
 	if (!has_audio && !has_video) goto exit;
 	ret = GF_TRUE;
 #if ((LIBAVFORMAT_VERSION_MAJOR == 52) && (LIBAVFORMAT_VERSION_MINOR <= 47)) || (LIBAVFORMAT_VERSION_MAJOR < 52)
 	fmt_out = guess_stream_format(NULL, url, NULL);
 #else
 	fmt_out = av_guess_format(NULL, url, NULL);
 #endif
 	if (fmt_out) gf_service_register_mime(plug, fmt_out->mime_type, fmt_out->extensions, fmt_out->name);
 	else {
 		ext = strrchr(szName, '.');
 		if (ext) {
 			strcpy(szExt, &ext[1]);
 			strlwr(szExt);
 			szExtList = gf_modules_get_option((GF_BaseInterface *)plug, ""MimeTypes"", ""application/x-ffmpeg"");
 			if (!szExtList) {
 				gf_service_register_mime(plug, ""application/x-ffmpeg"", szExt, ""Other Movies (FFMPEG)"");
 			} else if (!strstr(szExtList, szExt)) {
 				u32 len;
 				char *buf;
 				len = (u32) (strlen(szExtList) + strlen(szExt) + 10);
 				buf = (char*)gf_malloc(sizeof(char)*len);
 				sprintf(buf, ""\""%s "", szExt);
 				strcat(buf, &szExtList[1]);
 				gf_modules_set_option((GF_BaseInterface *)plug, ""MimeTypes"", ""application/x-ffmpeg"", buf);
 				gf_free(buf);
 			}
 		}
 	}
 exit:
 #if FF_API_CLOSE_INPUT_FILE
 	if (ctx) av_close_input_file(ctx);
 #else
 	if (ctx) avformat_close_input(&ctx);
 #endif
 	return ret;
 }","[8, 9, 22, 23, 31, 32]",GPAC version 0.7.1 and earlier has a buffer overflow vulnerability in the cat_multiple_files function in applications/mp4box/fileimport.c when MP4Box is used for a local directory containing crafted filenames.,gpac,CVE-2018-20762,CWE-119
1846,181509,"  int main(int argc, char *argv[])
  {
    int ret_value = 0;
     libettercap_init();
     ef_globals_alloc();
     select_text_interface();
    libettercap_ui_init();
    fprintf(stdout, ""\n"" EC_COLOR_BOLD ""%s %s"" EC_COLOR_END "" copyright %s %s\n\n"", 
                       PROGRAM, EC_VERSION, EC_COPYRIGHT, EC_AUTHORS);
    EF_GBL->lineno = 1;
    parse_options(argc, argv);
    if (EF_GBL_OPTIONS->source_file) {
       yyin = fopen(EF_GBL_OPTIONS->source_file, ""r"");
       if (yyin == NULL)
          FATAL_ERROR(""Input file not found !"");
    } else {
       FATAL_ERROR(""No source file."");
    }
    setbuf(yyin, NULL);
    setbuf(stdout, NULL);
    setbuf(stderr, NULL);
    load_tables();
    load_constants();
    fprintf(stdout, ""\n Parsing source file \'%s\' "", EF_GBL_OPTIONS->source_file);
    fflush(stdout);
    ef_debug(1, ""\n"");
    if (yyparse() == 0)
       fprintf(stdout, "" done.\n\n"");
    else
        fprintf(stdout, ""\n\nThe script contains errors...\n\n"");
   if (write_output() != E_SUCCESS)
      FATAL_ERROR(""Cannot write output file (%s)"", EF_GBL_OPTIONS->output_file);
    ret_value = write_output();
    if (ret_value == -E_NOTHANDLED)
       FATAL_ERROR(""Cannot write output file (%s): the filter is not correctly handled."", EF_GBL_OPTIONS->output_file);
    else if (ret_value == -E_INVALID)
       FATAL_ERROR(""Cannot write output file (%s): the filter format is not correct. "", EF_GBL_OPTIONS->output_file);
     ef_globals_free();
     return 0;
  }","[3, 31, 32, 33, 34, 35, 36, 37]",The compile_tree function in ef_compiler.c in the Etterfilter utility in Ettercap 0.8.2 and earlier allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted filter.,ettercap,CVE-2017-6430,CWE-125
1871,180802," on_unregister_handler(TCMUService1HandlerManager1 *interface,
 		      GDBusMethodInvocation *invocation,
 		      gchar *subtype,
  		      gpointer user_data)
  {
  	struct tcmur_handler *handler = find_handler_by_subtype(subtype);
	struct dbus_info *info = handler->opaque;
 	struct dbus_info *info = handler ? handler->opaque : NULL;
  	if (!handler) {
  		g_dbus_method_invocation_return_value(invocation,
 			g_variant_new(""(bs)"", FALSE,
 				      ""unknown subtype""));
 		return TRUE;
 	}
 	dbus_unexport_handler(handler);
 	tcmur_unregister_handler(handler);
 	g_bus_unwatch_name(info->watcher_id);
 	g_free(info);
 	g_free(handler);
 	g_dbus_method_invocation_return_value(invocation,
 		g_variant_new(""(bs)"", TRUE, ""succeeded""));
 	return TRUE;
 }","[7, 8]",The tcmu-runner daemon in tcmu-runner version 1.0.5 to 1.2.0 is vulnerable to a local denial of service attack,tcmu-runner,CVE-2017-1000201,CWE-20
1879,182661," int attribute_align_arg avcodec_open2(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options)
 {
     int ret = 0;
     int codec_init_ok = 0;
     AVDictionary *tmp = NULL;
     const AVPixFmtDescriptor *pixdesc;
     if (avcodec_is_open(avctx))
         return 0;
     if ((!codec && !avctx->codec)) {
         av_log(avctx, AV_LOG_ERROR, ""No codec provided to avcodec_open2()\n"");
         return AVERROR(EINVAL);
     }
     if ((codec && avctx->codec && codec != avctx->codec)) {
         av_log(avctx, AV_LOG_ERROR, ""This AVCodecContext was allocated for %s, ""
                                     ""but %s passed to avcodec_open2()\n"", avctx->codec->name, codec->name);
         return AVERROR(EINVAL);
     }
     if (!codec)
         codec = avctx->codec;
     if (avctx->extradata_size < 0 || avctx->extradata_size >= FF_MAX_EXTRADATA_SIZE)
         return AVERROR(EINVAL);
     if (options)
         av_dict_copy(&tmp, *options, 0);
     ff_lock_avcodec(avctx, codec);
     avctx->internal = av_mallocz(sizeof(*avctx->internal));
     if (!avctx->internal) {
         ret = AVERROR(ENOMEM);
         goto end;
     }
     avctx->internal->pool = av_mallocz(sizeof(*avctx->internal->pool));
     if (!avctx->internal->pool) {
         ret = AVERROR(ENOMEM);
         goto free_and_end;
     }
     avctx->internal->to_free = av_frame_alloc();
     if (!avctx->internal->to_free) {
         ret = AVERROR(ENOMEM);
         goto free_and_end;
     }
     avctx->internal->compat_decode_frame = av_frame_alloc();
     if (!avctx->internal->compat_decode_frame) {
         ret = AVERROR(ENOMEM);
         goto free_and_end;
     }
     avctx->internal->buffer_frame = av_frame_alloc();
     if (!avctx->internal->buffer_frame) {
         ret = AVERROR(ENOMEM);
         goto free_and_end;
     }
     avctx->internal->buffer_pkt = av_packet_alloc();
     if (!avctx->internal->buffer_pkt) {
         ret = AVERROR(ENOMEM);
         goto free_and_end;
     }
     avctx->internal->ds.in_pkt = av_packet_alloc();
     if (!avctx->internal->ds.in_pkt) {
         ret = AVERROR(ENOMEM);
         goto free_and_end;
     }
     avctx->internal->last_pkt_props = av_packet_alloc();
     if (!avctx->internal->last_pkt_props) {
         ret = AVERROR(ENOMEM);
         goto free_and_end;
     }
     avctx->internal->skip_samples_multiplier = 1;
     if (codec->priv_data_size > 0) {
         if (!avctx->priv_data) {
             avctx->priv_data = av_mallocz(codec->priv_data_size);
             if (!avctx->priv_data) {
                 ret = AVERROR(ENOMEM);
                 goto end;
             }
             if (codec->priv_class) {
                 *(const AVClass **)avctx->priv_data = codec->priv_class;
                 av_opt_set_defaults(avctx->priv_data);
             }
         }
         if (codec->priv_class && (ret = av_opt_set_dict(avctx->priv_data, &tmp)) < 0)
             goto free_and_end;
     } else {
         avctx->priv_data = NULL;
     }
     if ((ret = av_opt_set_dict(avctx, &tmp)) < 0)
         goto free_and_end;
     if (avctx->codec_whitelist && av_match_list(codec->name, avctx->codec_whitelist, ',') <= 0) {
         av_log(avctx, AV_LOG_ERROR, ""Codec (%s) not on whitelist \'%s\'\n"", codec->name, avctx->codec_whitelist);
         ret = AVERROR(EINVAL);
         goto free_and_end;
     }
     if (!(avctx->coded_width && avctx->coded_height && avctx->width && avctx->height &&
           (avctx->codec_id == AV_CODEC_ID_H264 || avctx->codec_id == AV_CODEC_ID_VP6F || avctx->codec_id == AV_CODEC_ID_DXV))) {
     if (avctx->coded_width && avctx->coded_height)
         ret = ff_set_dimensions(avctx, avctx->coded_width, avctx->coded_height);
     else if (avctx->width && avctx->height)
         ret = ff_set_dimensions(avctx, avctx->width, avctx->height);
     if (ret < 0)
         goto free_and_end;
     }
     if ((avctx->coded_width || avctx->coded_height || avctx->width || avctx->height)
         && (  av_image_check_size2(avctx->coded_width, avctx->coded_height, avctx->max_pixels, AV_PIX_FMT_NONE, 0, avctx) < 0
            || av_image_check_size2(avctx->width,       avctx->height,       avctx->max_pixels, AV_PIX_FMT_NONE, 0, avctx) < 0)) {
         av_log(avctx, AV_LOG_WARNING, ""Ignoring invalid width/height values\n"");
         ff_set_dimensions(avctx, 0, 0);
     }
     if (avctx->width > 0 && avctx->height > 0) {
         if (av_image_check_sar(avctx->width, avctx->height,
                                avctx->sample_aspect_ratio) < 0) {
             av_log(avctx, AV_LOG_WARNING, ""ignoring invalid SAR: %u/%u\n"",
                    avctx->sample_aspect_ratio.num,
                    avctx->sample_aspect_ratio.den);
             avctx->sample_aspect_ratio = (AVRational){ 0, 1 };
         }
     }
     if (av_codec_is_decoder(codec))
         av_freep(&avctx->subtitle_header);
     if (avctx->channels > FF_SANE_NB_CHANNELS) {
         av_log(avctx, AV_LOG_ERROR, ""Too many channels: %d\n"", avctx->channels);
         ret = AVERROR(EINVAL);
         goto free_and_end;
     }
     avctx->codec = codec;
     if ((avctx->codec_type == AVMEDIA_TYPE_UNKNOWN || avctx->codec_type == codec->type) &&
         avctx->codec_id == AV_CODEC_ID_NONE) {
         avctx->codec_type = codec->type;
         avctx->codec_id   = codec->id;
     }
     if (avctx->codec_id != codec->id || (avctx->codec_type != codec->type
                                          && avctx->codec_type != AVMEDIA_TYPE_ATTACHMENT)) {
         av_log(avctx, AV_LOG_ERROR, ""Codec type or id mismatches\n"");
         ret = AVERROR(EINVAL);
         goto free_and_end;
     }
     avctx->frame_number = 0;
     avctx->codec_descriptor = avcodec_descriptor_get(avctx->codec_id);
     if ((avctx->codec->capabilities & AV_CODEC_CAP_EXPERIMENTAL) &&
         avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {
         const char *codec_string = av_codec_is_encoder(codec) ? ""encoder"" : ""decoder"";
         AVCodec *codec2;
         av_log(avctx, AV_LOG_ERROR,
                ""The %s '%s' is experimental but experimental codecs are not enabled, ""
                ""add '-strict %d' if you want to use it.\n"",
                codec_string, codec->name, FF_COMPLIANCE_EXPERIMENTAL);
         codec2 = av_codec_is_encoder(codec) ? avcodec_find_encoder(codec->id) : avcodec_find_decoder(codec->id);
         if (!(codec2->capabilities & AV_CODEC_CAP_EXPERIMENTAL))
             av_log(avctx, AV_LOG_ERROR, ""Alternatively use the non experimental %s '%s'.\n"",
                 codec_string, codec2->name);
         ret = AVERROR_EXPERIMENTAL;
         goto free_and_end;
     }
     if (avctx->codec_type == AVMEDIA_TYPE_AUDIO &&
         (!avctx->time_base.num || !avctx->time_base.den)) {
         avctx->time_base.num = 1;
         avctx->time_base.den = avctx->sample_rate;
     }
     if (!HAVE_THREADS)
         av_log(avctx, AV_LOG_WARNING, ""Warning: not compiled with thread support, using thread emulation\n"");
     if (CONFIG_FRAME_THREAD_ENCODER && av_codec_is_encoder(avctx->codec)) {
         ff_unlock_avcodec(codec);  
         ret = ff_frame_thread_encoder_init(avctx, options ? *options : NULL);
         ff_lock_avcodec(avctx, codec);
         if (ret < 0)
             goto free_and_end;
     }
     if (av_codec_is_decoder(avctx->codec)) {
         ret = ff_decode_bsfs_init(avctx);
         if (ret < 0)
             goto free_and_end;
     }
     if (HAVE_THREADS
         && !(avctx->internal->frame_thread_encoder && (avctx->active_thread_type&FF_THREAD_FRAME))) {
         ret = ff_thread_init(avctx);
         if (ret < 0) {
             goto free_and_end;
         }
     }
     if (!HAVE_THREADS && !(codec->capabilities & AV_CODEC_CAP_AUTO_THREADS))
         avctx->thread_count = 1;
     if (avctx->codec->max_lowres < avctx->lowres || avctx->lowres < 0) {
         av_log(avctx, AV_LOG_WARNING, ""The maximum value for lowres supported by the decoder is %d\n"",
                avctx->codec->max_lowres);
         avctx->lowres = avctx->codec->max_lowres;
     }
     if (av_codec_is_encoder(avctx->codec)) {
         int i;
 #if FF_API_CODED_FRAME
 FF_DISABLE_DEPRECATION_WARNINGS
         avctx->coded_frame = av_frame_alloc();
         if (!avctx->coded_frame) {
             ret = AVERROR(ENOMEM);
             goto free_and_end;
         }
 FF_ENABLE_DEPRECATION_WARNINGS
 #endif
         if (avctx->time_base.num <= 0 || avctx->time_base.den <= 0) {
             av_log(avctx, AV_LOG_ERROR, ""The encoder timebase is not set.\n"");
             ret = AVERROR(EINVAL);
             goto free_and_end;
         }
         if (avctx->codec->sample_fmts) {
             for (i = 0; avctx->codec->sample_fmts[i] != AV_SAMPLE_FMT_NONE; i++) {
                 if (avctx->sample_fmt == avctx->codec->sample_fmts[i])
                     break;
                 if (avctx->channels == 1 &&
                     av_get_planar_sample_fmt(avctx->sample_fmt) ==
                     av_get_planar_sample_fmt(avctx->codec->sample_fmts[i])) {
                     avctx->sample_fmt = avctx->codec->sample_fmts[i];
                     break;
                 }
             }
             if (avctx->codec->sample_fmts[i] == AV_SAMPLE_FMT_NONE) {
                 char buf[128];
                 snprintf(buf, sizeof(buf), ""%d"", avctx->sample_fmt);
                 av_log(avctx, AV_LOG_ERROR, ""Specified sample format %s is invalid or not supported\n"",
                        (char *)av_x_if_null(av_get_sample_fmt_name(avctx->sample_fmt), buf));
                 ret = AVERROR(EINVAL);
                 goto free_and_end;
             }
         }
         if (avctx->codec->pix_fmts) {
             for (i = 0; avctx->codec->pix_fmts[i] != AV_PIX_FMT_NONE; i++)
                 if (avctx->pix_fmt == avctx->codec->pix_fmts[i])
                     break;
             if (avctx->codec->pix_fmts[i] == AV_PIX_FMT_NONE
                 && !((avctx->codec_id == AV_CODEC_ID_MJPEG || avctx->codec_id == AV_CODEC_ID_LJPEG)
                      && avctx->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL)) {
                 char buf[128];
                 snprintf(buf, sizeof(buf), ""%d"", avctx->pix_fmt);
                 av_log(avctx, AV_LOG_ERROR, ""Specified pixel format %s is invalid or not supported\n"",
                        (char *)av_x_if_null(av_get_pix_fmt_name(avctx->pix_fmt), buf));
                 ret = AVERROR(EINVAL);
                 goto free_and_end;
             }
             if (avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ420P ||
                 avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ411P ||
                 avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ422P ||
                 avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ440P ||
                 avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ444P)
                 avctx->color_range = AVCOL_RANGE_JPEG;
         }
         if (avctx->codec->supported_samplerates) {
             for (i = 0; avctx->codec->supported_samplerates[i] != 0; i++)
                 if (avctx->sample_rate == avctx->codec->supported_samplerates[i])
                     break;
             if (avctx->codec->supported_samplerates[i] == 0) {
                 av_log(avctx, AV_LOG_ERROR, ""Specified sample rate %d is not supported\n"",
                        avctx->sample_rate);
                 ret = AVERROR(EINVAL);
                 goto free_and_end;
             }
         }
         if (avctx->sample_rate < 0) {
             av_log(avctx, AV_LOG_ERROR, ""Specified sample rate %d is not supported\n"",
                     avctx->sample_rate);
             ret = AVERROR(EINVAL);
             goto free_and_end;
         }
         if (avctx->codec->channel_layouts) {
             if (!avctx->channel_layout) {
                 av_log(avctx, AV_LOG_WARNING, ""Channel layout not specified\n"");
             } else {
                 for (i = 0; avctx->codec->channel_layouts[i] != 0; i++)
                     if (avctx->channel_layout == avctx->codec->channel_layouts[i])
                         break;
                 if (avctx->codec->channel_layouts[i] == 0) {
                     char buf[512];
                     av_get_channel_layout_string(buf, sizeof(buf), -1, avctx->channel_layout);
                     av_log(avctx, AV_LOG_ERROR, ""Specified channel layout '%s' is not supported\n"", buf);
                     ret = AVERROR(EINVAL);
                     goto free_and_end;
                 }
             }
         }
         if (avctx->channel_layout && avctx->channels) {
             int channels = av_get_channel_layout_nb_channels(avctx->channel_layout);
             if (channels != avctx->channels) {
                 char buf[512];
                 av_get_channel_layout_string(buf, sizeof(buf), -1, avctx->channel_layout);
                 av_log(avctx, AV_LOG_ERROR,
                        ""Channel layout '%s' with %d channels does not match number of specified channels %d\n"",
                        buf, channels, avctx->channels);
                 ret = AVERROR(EINVAL);
                 goto free_and_end;
             }
         } else if (avctx->channel_layout) {
             avctx->channels = av_get_channel_layout_nb_channels(avctx->channel_layout);
         }
         if (avctx->channels < 0) {
             av_log(avctx, AV_LOG_ERROR, ""Specified number of channels %d is not supported\n"",
                     avctx->channels);
             ret = AVERROR(EINVAL);
             goto free_and_end;
         }
         if(avctx->codec_type == AVMEDIA_TYPE_VIDEO) {
             pixdesc = av_pix_fmt_desc_get(avctx->pix_fmt);
             if (    avctx->bits_per_raw_sample < 0
                 || (avctx->bits_per_raw_sample > 8 && pixdesc->comp[0].depth <= 8)) {
                 av_log(avctx, AV_LOG_WARNING, ""Specified bit depth %d not possible with the specified pixel formats depth %d\n"",
                     avctx->bits_per_raw_sample, pixdesc->comp[0].depth);
                 avctx->bits_per_raw_sample = pixdesc->comp[0].depth;
             }
             if (avctx->width <= 0 || avctx->height <= 0) {
                 av_log(avctx, AV_LOG_ERROR, ""dimensions not set\n"");
                 ret = AVERROR(EINVAL);
                 goto free_and_end;
             }
         }
         if (   (avctx->codec_type == AVMEDIA_TYPE_VIDEO || avctx->codec_type == AVMEDIA_TYPE_AUDIO)
             && avctx->bit_rate>0 && avctx->bit_rate<1000) {
             av_log(avctx, AV_LOG_WARNING, ""Bitrate %""PRId64"" is extremely low, maybe you mean %""PRId64""k\n"", avctx->bit_rate, avctx->bit_rate);
         }
         if (!avctx->rc_initial_buffer_occupancy)
             avctx->rc_initial_buffer_occupancy = avctx->rc_buffer_size * 3LL / 4;
         if (avctx->ticks_per_frame && avctx->time_base.num &&
             avctx->ticks_per_frame > INT_MAX / avctx->time_base.num) {
             av_log(avctx, AV_LOG_ERROR,
                    ""ticks_per_frame %d too large for the timebase %d/%d."",
                    avctx->ticks_per_frame,
                    avctx->time_base.num,
                    avctx->time_base.den);
             goto free_and_end;
         }
         if (avctx->hw_frames_ctx) {
             AVHWFramesContext *frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;
             if (frames_ctx->format != avctx->pix_fmt) {
                 av_log(avctx, AV_LOG_ERROR,
                        ""Mismatching AVCodecContext.pix_fmt and AVHWFramesContext.format\n"");
                 ret = AVERROR(EINVAL);
                 goto free_and_end;
             }
             if (avctx->sw_pix_fmt != AV_PIX_FMT_NONE &&
                 avctx->sw_pix_fmt != frames_ctx->sw_format) {
                 av_log(avctx, AV_LOG_ERROR,
                        ""Mismatching AVCodecContext.sw_pix_fmt (%s) ""
                        ""and AVHWFramesContext.sw_format (%s)\n"",
                        av_get_pix_fmt_name(avctx->sw_pix_fmt),
                        av_get_pix_fmt_name(frames_ctx->sw_format));
                 ret = AVERROR(EINVAL);
                 goto free_and_end;
             }
             avctx->sw_pix_fmt = frames_ctx->sw_format;
         }
     }
     avctx->pts_correction_num_faulty_pts =
     avctx->pts_correction_num_faulty_dts = 0;
     avctx->pts_correction_last_pts =
     avctx->pts_correction_last_dts = INT64_MIN;
     if (   !CONFIG_GRAY && avctx->flags & AV_CODEC_FLAG_GRAY
         && avctx->codec_descriptor->type == AVMEDIA_TYPE_VIDEO)
         av_log(avctx, AV_LOG_WARNING,
                ""gray decoding requested but not enabled at configuration time\n"");
     if (   avctx->codec->init && (!(avctx->active_thread_type&FF_THREAD_FRAME)
         || avctx->internal->frame_thread_encoder)) {
         ret = avctx->codec->init(avctx);
         if (ret < 0) {
             goto free_and_end;
         }
         codec_init_ok = 1;
     }
     ret=0;
     if (av_codec_is_decoder(avctx->codec)) {
         if (!avctx->bit_rate)
             avctx->bit_rate = get_bit_rate(avctx);
         if (avctx->channel_layout) {
             int channels = av_get_channel_layout_nb_channels(avctx->channel_layout);
             if (!avctx->channels)
                 avctx->channels = channels;
             else if (channels != avctx->channels) {
                 char buf[512];
                 av_get_channel_layout_string(buf, sizeof(buf), -1, avctx->channel_layout);
                 av_log(avctx, AV_LOG_WARNING,
                        ""Channel layout '%s' with %d channels does not match specified number of channels %d: ""
                        ""ignoring specified channel layout\n"",
                        buf, channels, avctx->channels);
                 avctx->channel_layout = 0;
             }
         }
         if (avctx->channels && avctx->channels < 0 ||
             avctx->channels > FF_SANE_NB_CHANNELS) {
             ret = AVERROR(EINVAL);
             goto free_and_end;
         }
         if (avctx->bits_per_coded_sample < 0) {
             ret = AVERROR(EINVAL);
             goto free_and_end;
         }
         if (avctx->sub_charenc) {
             if (avctx->codec_type != AVMEDIA_TYPE_SUBTITLE) {
                 av_log(avctx, AV_LOG_ERROR, ""Character encoding is only ""
                        ""supported with subtitles codecs\n"");
                 ret = AVERROR(EINVAL);
                 goto free_and_end;
             } else if (avctx->codec_descriptor->props & AV_CODEC_PROP_BITMAP_SUB) {
                 av_log(avctx, AV_LOG_WARNING, ""Codec '%s' is bitmap-based, ""
                        ""subtitles character encoding will be ignored\n"",
                        avctx->codec_descriptor->name);
                 avctx->sub_charenc_mode = FF_SUB_CHARENC_MODE_DO_NOTHING;
             } else {
                 if (avctx->sub_charenc_mode == FF_SUB_CHARENC_MODE_AUTOMATIC)
                     avctx->sub_charenc_mode = FF_SUB_CHARENC_MODE_PRE_DECODER;
                 if (avctx->sub_charenc_mode == FF_SUB_CHARENC_MODE_PRE_DECODER) {
 #if CONFIG_ICONV
                     iconv_t cd = iconv_open(""UTF-8"", avctx->sub_charenc);
                     if (cd == (iconv_t)-1) {
                         ret = AVERROR(errno);
                         av_log(avctx, AV_LOG_ERROR, ""Unable to open iconv context ""
                                ""with input character encoding \""%s\""\n"", avctx->sub_charenc);
                         goto free_and_end;
                     }
                     iconv_close(cd);
 #else
                     av_log(avctx, AV_LOG_ERROR, ""Character encoding subtitles ""
                            ""conversion needs a libavcodec built with iconv support ""
                            ""for this codec\n"");
                     ret = AVERROR(ENOSYS);
                     goto free_and_end;
 #endif
                 }
             }
         }
 #if FF_API_AVCTX_TIMEBASE
         if (avctx->framerate.num > 0 && avctx->framerate.den > 0)
             avctx->time_base = av_inv_q(av_mul_q(avctx->framerate, (AVRational){avctx->ticks_per_frame, 1}));
 #endif
     }
     if (codec->priv_data_size > 0 && avctx->priv_data && codec->priv_class) {
         av_assert0(*(const AVClass **)avctx->priv_data == codec->priv_class);
     }
 end:
     ff_unlock_avcodec(codec);
     if (options) {
         av_dict_free(options);
         *options = tmp;
     }
      return ret;
  free_and_end:
    if (avctx->codec &&
     if (avctx->codec && avctx->codec->close &&
          (codec_init_ok ||
           (avctx->codec->caps_internal & FF_CODEC_CAP_INIT_CLEANUP)))
          avctx->codec->close(avctx);
     if (codec->priv_class && codec->priv_data_size)
         av_opt_free(avctx->priv_data);
     av_opt_free(avctx);
 #if FF_API_CODED_FRAME
 FF_DISABLE_DEPRECATION_WARNINGS
     av_frame_free(&avctx->coded_frame);
 FF_ENABLE_DEPRECATION_WARNINGS
 #endif
     av_dict_free(&tmp);
     av_freep(&avctx->priv_data);
     if (avctx->internal) {
         av_frame_free(&avctx->internal->to_free);
         av_frame_free(&avctx->internal->compat_decode_frame);
         av_frame_free(&avctx->internal->buffer_frame);
         av_packet_free(&avctx->internal->buffer_pkt);
         av_packet_free(&avctx->internal->last_pkt_props);
         av_packet_free(&avctx->internal->ds.in_pkt);
         ff_decode_bsfs_uninit(avctx);
         av_freep(&avctx->internal->pool);
     }
     av_freep(&avctx->internal);
     avctx->codec = NULL;
     goto end;
 }","[436, 437]","In FFmpeg before 4.2, avcodec_open2 in libavcodec/utils.c allows a NULL pointer dereference and possibly unspecified other impact when there is no valid close function pointer.",FFmpeg,CVE-2019-17539,
1886,182720,"  uint32_t *GetPayload(size_t handle, uint32_t *lastpayload, uint32_t index)
  {
  	mp4object *mp4 = (mp4object *)handle;
 	if (mp4 == NULL) return NULL;
 	uint32_t *MP4buffer = NULL;
 	if (index < mp4->indexcount && mp4->mediafp)
 	{
 		MP4buffer = (uint32_t *)realloc((void *)lastpayload, mp4->metasizes[index]);
  		if (MP4buffer)
  		{
			LONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);
			fread(MP4buffer, 1, mp4->metasizes[index], mp4->mediafp);
			return MP4buffer;
 			if (mp4->filesize > mp4->metaoffsets[index]+mp4->metasizes[index])
 			{
 				LONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);
 				fread(MP4buffer, 1, mp4->metasizes[index], mp4->mediafp);
 				mp4->filepos = mp4->metaoffsets[index] + mp4->metasizes[index];
 				return MP4buffer;
 			}
  		}
  	}
  	return NULL;
  }","[11, 12, 13, 14, 15, 16, 17, 18, 19, 20]",GoPro GPMF-parser 1.2.2 has an out-of-bounds write in OpenMP4Source in demo/GPMF_mp4reader.c.,gpmf-parser,CVE-2019-15148,CWE-787
1898,180522," static int ndp_sock_recv(struct ndp *ndp)
 {
 	struct ndp_msg *msg;
 	enum ndp_msg_type msg_type;
 	size_t len;
 	int err;
 	msg = ndp_msg_alloc();
 	if (!msg)
 		return -ENOMEM;
  	len = ndp_msg_payload_maxlen(msg);
  	err = myrecvfrom6(ndp->sock, msg->buf, &len, 0,
			  &msg->addrto, &msg->ifindex);
 			  &msg->addrto, &msg->ifindex, &msg->hoplimit);
  	if (err) {
  		err(ndp, ""Failed to receive message"");
  		goto free_msg;
  	}
	dbg(ndp, ""rcvd from: %s, ifindex: %u"",
		 str_in6_addr(&msg->addrto), msg->ifindex);
 	dbg(ndp, ""rcvd from: %s, ifindex: %u, hoplimit: %d"",
 		 str_in6_addr(&msg->addrto), msg->ifindex, msg->hoplimit);
 	if (msg->hoplimit != 255) {
 		warn(ndp, ""ignoring packet with bad hop limit (%d)"", msg->hoplimit);
 		err = 0;
 		goto free_msg;
 	}
  	if (len < sizeof(*msg->icmp6_hdr)) {
  		warn(ndp, ""rcvd icmp6 packet too short (%luB)"", len);
 		err = 0;
 		goto free_msg;
 	}
 	err = ndp_msg_type_by_raw_type(&msg_type, msg->icmp6_hdr->icmp6_type);
 	if (err) {
 		err = 0;
 		goto free_msg;
 	}
 	ndp_msg_init(msg, msg_type);
 	ndp_msg_payload_len_set(msg, len);
 	if (!ndp_msg_check_valid(msg)) {
 		warn(ndp, ""rcvd invalid ND message"");
 		err = 0;
 		goto free_msg;
 	}
 	dbg(ndp, ""rcvd %s, len: %zuB"",
 		 ndp_msg_type_info(msg_type)->strabbr, len);
 	if (!ndp_msg_check_opts(msg)) {
 		err = 0;
 		goto free_msg;
 	}
 	err = ndp_call_handlers(ndp, msg);;
 free_msg:
 	ndp_msg_destroy(msg);
 	return err;
 }","[12, 13, 18, 19, 20, 21, 22, 23, 24, 25, 26]","libndp before 1.6, as used in NetworkManager, does not properly validate the origin of Neighbor Discovery Protocol (NDP) messages, which allows remote attackers to conduct man-in-the-middle attacks or cause a denial of service (network connectivity disruption) by advertising a node as a router from a non-local network.",libndp,CVE-2016-3698,CWE-284
1903,179957," devzvol_readdir(struct vnode *dvp, struct uio *uiop, struct cred *cred,
     int *eofp, caller_context_t *ct_unused, int flags_unused)
 {
 	struct sdev_node *sdvp = VTOSDEV(dvp);
 	char *ptr;
 	sdcmn_err13((""zv readdir of '%s' %s'"", sdvp->sdev_path,
 	    sdvp->sdev_name));
 	if (strcmp(sdvp->sdev_path, ZVOL_DIR) == 0) {
 		struct vnode *vp;
 		rw_exit(&sdvp->sdev_contents);
 		(void) devname_lookup_func(sdvp, ""dsk"", &vp, cred,
 		    devzvol_create_dir, SDEV_VATTR);
 		VN_RELE(vp);
 		(void) devname_lookup_func(sdvp, ""rdsk"", &vp, cred,
 		    devzvol_create_dir, SDEV_VATTR);
 		VN_RELE(vp);
 		rw_enter(&sdvp->sdev_contents, RW_READER);
 		return (devname_readdir_func(dvp, uiop, cred, eofp, 0));
 	}
 	if (uiop->uio_offset == 0)
 		devzvol_prunedir(sdvp);
 	ptr = sdvp->sdev_path + strlen(ZVOL_DIR);
 	if ((strcmp(ptr, ""/dsk"") == 0) || (strcmp(ptr, ""/rdsk"") == 0)) {
 		rw_exit(&sdvp->sdev_contents);
 		devzvol_create_pool_dirs(dvp);
 		rw_enter(&sdvp->sdev_contents, RW_READER);
  		return (devname_readdir_func(dvp, uiop, cred, eofp, 0));
  	}
	ptr = strchr(ptr + 1, '/') + 1;
 	ptr = strchr(ptr + 1, '/');
 	if (ptr == NULL)
 		return (ENOENT);
 	ptr++;
  	rw_exit(&sdvp->sdev_contents);
  	sdev_iter_datasets(dvp, ZFS_IOC_DATASET_LIST_NEXT, ptr);
  	rw_enter(&sdvp->sdev_contents, RW_READER);
 	return (devname_readdir_func(dvp, uiop, cred, eofp, 0));
 }","[29, 30, 31, 32, 33]","The devzvol_readdir function in illumos does not check the return value of a strchr call, which allows remote attackers to cause a denial of service (NULL pointer dereference and panic) via unspecified vectors.",illumos-gate,CVE-2014-9491,
1925,181908," static int jpc_siz_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate,
   jas_stream_t *in)
 {
 	jpc_siz_t *siz = &ms->parms.siz;
 	unsigned int i;
 	uint_fast8_t tmp;
 	cstate = 0;
 	if (jpc_getuint16(in, &siz->caps) ||
 	  jpc_getuint32(in, &siz->width) ||
 	  jpc_getuint32(in, &siz->height) ||
 	  jpc_getuint32(in, &siz->xoff) ||
 	  jpc_getuint32(in, &siz->yoff) ||
 	  jpc_getuint32(in, &siz->tilewidth) ||
 	  jpc_getuint32(in, &siz->tileheight) ||
 	  jpc_getuint32(in, &siz->tilexoff) ||
 	  jpc_getuint32(in, &siz->tileyoff) ||
 	  jpc_getuint16(in, &siz->numcomps)) {
 		return -1;
 	}
 	if (!siz->width || !siz->height || !siz->tilewidth ||
  	  !siz->tileheight || !siz->numcomps || siz->numcomps > 16384) {
  		return -1;
  	}
 	if (siz->tilexoff >= siz->width || siz->tileyoff >= siz->height) {
 		jas_eprintf(""all tiles are outside the image area\n"");
 		return -1;
 	}
  	if (!(siz->comps = jas_alloc2(siz->numcomps, sizeof(jpc_sizcomp_t)))) {
  		return -1;
  	}
 	for (i = 0; i < siz->numcomps; ++i) {
 		if (jpc_getuint8(in, &tmp) ||
 		  jpc_getuint8(in, &siz->comps[i].hsamp) ||
 		  jpc_getuint8(in, &siz->comps[i].vsamp)) {
 			jas_free(siz->comps);
 			return -1;
 		}
 		if (siz->comps[i].hsamp == 0 || siz->comps[i].hsamp > 255) {
 			jas_eprintf(""invalid XRsiz value %d\n"", siz->comps[i].hsamp);
 			jas_free(siz->comps);
 			return -1;
 		}
 		if (siz->comps[i].vsamp == 0 || siz->comps[i].vsamp > 255) {
 			jas_eprintf(""invalid YRsiz value %d\n"", siz->comps[i].vsamp);
 			jas_free(siz->comps);
 			return -1;
 		}
 		siz->comps[i].sgnd = (tmp >> 7) & 1;
 		siz->comps[i].prec = (tmp & 0x7f) + 1;
 	}
 	if (jas_stream_eof(in)) {
 		jas_free(siz->comps);
 		return -1;
 	}
 	return 0;
 }","[24, 25, 26, 27]",The jas_seq2d_create function in jas_seq.c in JasPer before 1.900.14 allows remote attackers to cause a denial of service (assertion failure) via a crafted image file.,jasper,CVE-2016-9390,CWE-20
1976,179796," void ff_h264_free_tables(H264Context *h, int free_rbsp)
 {
     int i;
     H264Context *hx;
     av_freep(&h->intra4x4_pred_mode);
     av_freep(&h->chroma_pred_mode_table);
     av_freep(&h->cbp_table);
     av_freep(&h->mvd_table[0]);
     av_freep(&h->mvd_table[1]);
     av_freep(&h->direct_table);
     av_freep(&h->non_zero_count);
     av_freep(&h->slice_table_base);
     h->slice_table = NULL;
     av_freep(&h->list_counts);
     av_freep(&h->mb2b_xy);
     av_freep(&h->mb2br_xy);
     av_buffer_pool_uninit(&h->qscale_table_pool);
     av_buffer_pool_uninit(&h->mb_type_pool);
     av_buffer_pool_uninit(&h->motion_val_pool);
     av_buffer_pool_uninit(&h->ref_index_pool);
      if (free_rbsp && h->DPB) {
          for (i = 0; i < H264_MAX_PICTURE_COUNT; i++)
              ff_h264_unref_picture(h, &h->DPB[i]);
         memset(h->delayed_pic, 0, sizeof(h->delayed_pic));
          av_freep(&h->DPB);
      } else if (h->DPB) {
          for (i = 0; i < H264_MAX_PICTURE_COUNT; i++)
             h->DPB[i].needs_realloc = 1;
     }
     h->cur_pic_ptr = NULL;
     for (i = 0; i < H264_MAX_THREADS; i++) {
         hx = h->thread_context[i];
         if (!hx)
             continue;
         av_freep(&hx->top_borders[1]);
         av_freep(&hx->top_borders[0]);
         av_freep(&hx->bipred_scratchpad);
         av_freep(&hx->edge_emu_buffer);
         av_freep(&hx->dc_val_base);
         av_freep(&hx->er.mb_index2xy);
         av_freep(&hx->er.error_status_table);
         av_freep(&hx->er.er_temp_buffer);
         av_freep(&hx->er.mbintra_table);
         av_freep(&hx->er.mbskip_table);
         if (free_rbsp) {
             av_freep(&hx->rbsp_buffer[1]);
             av_freep(&hx->rbsp_buffer[0]);
             hx->rbsp_buffer_size[0] = 0;
             hx->rbsp_buffer_size[1] = 0;
         }
         if (i)
             av_freep(&h->thread_context[i]);
     }
 }",[24],"Use-after-free vulnerability in the ff_h264_free_tables function in libavcodec/h264.c in FFmpeg before 2.3.6 allows remote attackers to cause a denial of service or possibly have unspecified other impact via crafted H.264 data in an MP4 file, as demonstrated by an HTML VIDEO element that references H.264 data.",FFmpeg,CVE-2015-3417,
1978,178605," ProcScreenSaverUnsetAttributes(ClientPtr client)
 {
 #ifdef PANORAMIX
     if (!noPanoramiXExtension) {
         REQUEST(xScreenSaverUnsetAttributesReq);
          PanoramiXRes *draw;
          int rc, i;
         REQUEST_SIZE_MATCH(xScreenSaverUnsetAttributesReq);
          rc = dixLookupResourceByClass((void **) &draw, stuff->drawable,
                                        XRC_DRAWABLE, client, DixWriteAccess);
          if (rc != Success)
         for (i = PanoramiXNumScreens - 1; i > 0; i--) {
             stuff->drawable = draw->info[i].id;
             ScreenSaverUnsetAttributes(client);
         }
         stuff->drawable = draw->info[0].id;
     }
 #endif
     return ScreenSaverUnsetAttributes(client);
 }",[8],xorg-x11-server before 1.19.5 was missing length validation in RENDER extension allowing malicious X client to cause X server to crash or possibly execute arbitrary code.,xserver,CVE-2017-12187,CWE-20
2010,181419," static int decode_frame_common(AVCodecContext *avctx, PNGDecContext *s,
                                AVFrame *p, AVPacket *avpkt)
 {
     AVDictionary *metadata  = NULL;
     uint32_t tag, length;
     int decode_next_dat = 0;
     int ret;
     for (;;) {
         length = bytestream2_get_bytes_left(&s->gb);
         if (length <= 0) {
             if (avctx->codec_id == AV_CODEC_ID_PNG &&
                 avctx->skip_frame == AVDISCARD_ALL) {
                 av_frame_set_metadata(p, metadata);
                 return 0;
             }
             if (CONFIG_APNG_DECODER && avctx->codec_id == AV_CODEC_ID_APNG && length == 0) {
                 if (!(s->state & PNG_IDAT))
                     return 0;
                 else
                     goto exit_loop;
             }
             av_log(avctx, AV_LOG_ERROR, ""%d bytes left\n"", length);
             if (   s->state & PNG_ALLIMAGE
                 && avctx->strict_std_compliance <= FF_COMPLIANCE_NORMAL)
                 goto exit_loop;
             ret = AVERROR_INVALIDDATA;
             goto fail;
         }
         length = bytestream2_get_be32(&s->gb);
         if (length > 0x7fffffff || length > bytestream2_get_bytes_left(&s->gb)) {
             av_log(avctx, AV_LOG_ERROR, ""chunk too big\n"");
             ret = AVERROR_INVALIDDATA;
             goto fail;
         }
         tag = bytestream2_get_le32(&s->gb);
         if (avctx->debug & FF_DEBUG_STARTCODE)
             av_log(avctx, AV_LOG_DEBUG, ""png: tag=%c%c%c%c length=%u\n"",
                 (tag & 0xff),
                 ((tag >> 8) & 0xff),
                 ((tag >> 16) & 0xff),
                 ((tag >> 24) & 0xff), length);
         if (avctx->codec_id == AV_CODEC_ID_PNG &&
             avctx->skip_frame == AVDISCARD_ALL) {
             switch(tag) {
             case MKTAG('I', 'H', 'D', 'R'):
             case MKTAG('p', 'H', 'Y', 's'):
             case MKTAG('t', 'E', 'X', 't'):
             case MKTAG('I', 'D', 'A', 'T'):
             case MKTAG('t', 'R', 'N', 'S'):
                 break;
             default:
                 goto skip_tag;
             }
         }
         switch (tag) {
         case MKTAG('I', 'H', 'D', 'R'):
             if ((ret = decode_ihdr_chunk(avctx, s, length)) < 0)
                 goto fail;
             break;
         case MKTAG('p', 'H', 'Y', 's'):
             if ((ret = decode_phys_chunk(avctx, s)) < 0)
                 goto fail;
             break;
         case MKTAG('f', 'c', 'T', 'L'):
             if (!CONFIG_APNG_DECODER || avctx->codec_id != AV_CODEC_ID_APNG)
                 goto skip_tag;
             if ((ret = decode_fctl_chunk(avctx, s, length)) < 0)
                 goto fail;
             decode_next_dat = 1;
             break;
         case MKTAG('f', 'd', 'A', 'T'):
             if (!CONFIG_APNG_DECODER || avctx->codec_id != AV_CODEC_ID_APNG)
                 goto skip_tag;
             if (!decode_next_dat) {
                 ret = AVERROR_INVALIDDATA;
                 goto fail;
             }
             bytestream2_get_be32(&s->gb);
             length -= 4;
         case MKTAG('I', 'D', 'A', 'T'):
             if (CONFIG_APNG_DECODER && avctx->codec_id == AV_CODEC_ID_APNG && !decode_next_dat)
                 goto skip_tag;
             if ((ret = decode_idat_chunk(avctx, s, length, p)) < 0)
                 goto fail;
             break;
         case MKTAG('P', 'L', 'T', 'E'):
             if (decode_plte_chunk(avctx, s, length) < 0)
                 goto skip_tag;
             break;
         case MKTAG('t', 'R', 'N', 'S'):
             if (decode_trns_chunk(avctx, s, length) < 0)
                 goto skip_tag;
             break;
         case MKTAG('t', 'E', 'X', 't'):
             if (decode_text_chunk(s, length, 0, &metadata) < 0)
                 av_log(avctx, AV_LOG_WARNING, ""Broken tEXt chunk\n"");
             bytestream2_skip(&s->gb, length + 4);
             break;
         case MKTAG('z', 'T', 'X', 't'):
             if (decode_text_chunk(s, length, 1, &metadata) < 0)
                 av_log(avctx, AV_LOG_WARNING, ""Broken zTXt chunk\n"");
             bytestream2_skip(&s->gb, length + 4);
             break;
         case MKTAG('s', 'T', 'E', 'R'): {
             int mode = bytestream2_get_byte(&s->gb);
             AVStereo3D *stereo3d = av_stereo3d_create_side_data(p);
             if (!stereo3d)
                 goto fail;
             if (mode == 0 || mode == 1) {
                 stereo3d->type  = AV_STEREO3D_SIDEBYSIDE;
                 stereo3d->flags = mode ? 0 : AV_STEREO3D_FLAG_INVERT;
             } else {
                  av_log(avctx, AV_LOG_WARNING,
                         ""Unknown value in sTER chunk (%d)\n"", mode);
             }
             bytestream2_skip(&s->gb, 4);  
             break;
         }
         case MKTAG('I', 'E', 'N', 'D'):
             if (!(s->state & PNG_ALLIMAGE))
                 av_log(avctx, AV_LOG_ERROR, ""IEND without all image\n"");
             if (!(s->state & (PNG_ALLIMAGE|PNG_IDAT))) {
                 ret = AVERROR_INVALIDDATA;
                 goto fail;
             }
             bytestream2_skip(&s->gb, 4);  
             goto exit_loop;
         default:
 skip_tag:
             bytestream2_skip(&s->gb, length + 4);
             break;
         }
     }
 exit_loop:
     if (avctx->codec_id == AV_CODEC_ID_PNG &&
         avctx->skip_frame == AVDISCARD_ALL) {
         av_frame_set_metadata(p, metadata);
         return 0;
     }
     if (s->bits_per_pixel <= 4)
         handle_small_bpp(s, p);
     if (s->has_trns && s->color_type != PNG_COLOR_TYPE_PALETTE) {
         size_t byte_depth = s->bit_depth > 8 ? 2 : 1;
          size_t raw_bpp = s->bpp - byte_depth;
          unsigned x, y;
         av_assert0(s->bit_depth > 1);
          for (y = 0; y < s->height; ++y) {
              uint8_t *row = &s->image_buf[s->image_linesize * y];
             for (x = s->width; x > 0; --x) {
                 uint8_t *pixel = &row[s->bpp * (x - 1)];
                 memmove(pixel, &row[raw_bpp * (x - 1)], raw_bpp);
                 if (!memcmp(pixel, s->transparent_color_be, raw_bpp)) {
                     memset(&pixel[raw_bpp], 0, byte_depth);
                 } else {
                     memset(&pixel[raw_bpp], 0xff, byte_depth);
                 }
             }
         }
     }
     if (s->last_picture.f->data[0]) {
         if (   !(avpkt->flags & AV_PKT_FLAG_KEY) && avctx->codec_tag != AV_RL32(""MPNG"")
             && s->last_picture.f->width == p->width
             && s->last_picture.f->height== p->height
             && s->last_picture.f->format== p->format
          ) {
             if (CONFIG_PNG_DECODER && avctx->codec_id != AV_CODEC_ID_APNG)
                 handle_p_frame_png(s, p);
             else if (CONFIG_APNG_DECODER &&
                      avctx->codec_id == AV_CODEC_ID_APNG &&
                      (ret = handle_p_frame_apng(avctx, s, p)) < 0)
                 goto fail;
         }
     }
     ff_thread_report_progress(&s->picture, INT_MAX, 0);
     ff_thread_report_progress(&s->previous_picture, INT_MAX, 0);
     av_frame_set_metadata(p, metadata);
     metadata   = NULL;
     return 0;
 fail:
     av_dict_free(&metadata);
     ff_thread_report_progress(&s->picture, INT_MAX, 0);
     ff_thread_report_progress(&s->previous_picture, INT_MAX, 0);
     return ret;
 }",[146],FFmpeg before 2017-02-04 has an out-of-bounds write caused by a heap-based buffer overflow related to the decode_frame_common function in libavcodec/pngdec.c.,FFmpeg,CVE-2017-7863,CWE-787
2047,183240," sf_open_fd	(int fd, int mode, SF_INFO *sfinfo, int close_desc)
 {	SF_PRIVATE 	*psf ;
 	if ((SF_CONTAINER (sfinfo->format)) == SF_FORMAT_SD2)
 	{	sf_errno = SFE_SD2_FD_DISALLOWED ;
  		return	NULL ;
  		} ;
	if ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)
 	if ((psf = psf_allocate ()) == NULL)
  	{	sf_errno = SFE_MALLOC_FAILED ;
  		return	NULL ;
  		} ;
 	psf_init_files (psf) ;
 	copy_filename (psf, """") ;
 	psf->file.mode = mode ;
 	psf_set_file (psf, fd) ;
 	psf->is_pipe = psf_is_pipe (psf) ;
 	psf->fileoffset = psf_ftell (psf) ;
 	if (! close_desc)
 		psf->file.do_not_close_descriptor = SF_TRUE ;
 	return psf_open_file (psf, sfinfo) ;
 }  ","[7, 8]","In libsndfile before 1.0.28, an error in the *header_read()* function (common.c) when handling ID3 tags can be exploited to cause a stack-based buffer overflow via a specially crafted FLAC file.",libsndfile,CVE-2017-7586,CWE-119
2057,181496," static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)
 {
  #if 0
  	jp2_pclr_t *pclr = &box->data.pclr;
  #endif
box = 0;
out = 0;
 	box = 0;
 	out = 0;
  	return -1;
  }","[6, 7, 8, 9]",The jp2_cdef_destroy function in jp2_cod.c in JasPer before 2.0.13 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted image.,jasper,CVE-2017-6850,CWE-476
2123,182962," int mp4client_main(int argc, char **argv)
 {
 	char c;
 	const char *str;
 	int ret_val = 0;
 	u32 i, times[100], nb_times, dump_mode;
 	u32 simulation_time_in_ms = 0;
 	u32 initial_service_id = 0;
 	Bool auto_exit = GF_FALSE;
 	Bool logs_set = GF_FALSE;
 	Bool start_fs = GF_FALSE;
 	Bool use_rtix = GF_FALSE;
 	Bool pause_at_first = GF_FALSE;
 	Bool no_cfg_save = GF_FALSE;
 	Bool is_cfg_only = GF_FALSE;
 	Double play_from = 0;
 #ifdef GPAC_MEMORY_TRACKING
     GF_MemTrackerType mem_track = GF_MemTrackerNone;
 #endif
 	Double fps = GF_IMPORT_DEFAULT_FPS;
 	Bool fill_ar, visible, do_uncache, has_command;
 	char *url_arg, *out_arg, *the_cfg, *rti_file, *views, *mosaic;
 	FILE *logfile = NULL;
 	Float scale = 1;
 #ifndef WIN32
 	dlopen(NULL, RTLD_NOW|RTLD_GLOBAL);
 #endif
 	strcpy(the_url, ""."");
 	memset(&user, 0, sizeof(GF_User));
 	dump_mode = DUMP_NONE;
 	fill_ar = visible = do_uncache = has_command = GF_FALSE;
 	url_arg = out_arg = the_cfg = rti_file = views = mosaic = NULL;
 	nb_times = 0;
 	times[0] = 0;
 	for (i=1; i<(u32) argc; i++) {
 		char *arg = argv[i];
 		if (!strcmp(arg, ""-c"") || !strcmp(arg, ""-cfg"")) {
 			the_cfg = argv[i+1];
 			i++;
 		}
 		else if (!strcmp(arg, ""-mem-track"") || !strcmp(arg, ""-mem-track-stack"")) {
 #ifdef GPAC_MEMORY_TRACKING
             mem_track = !strcmp(arg, ""-mem-track-stack"") ? GF_MemTrackerBackTrace : GF_MemTrackerSimple;
 #else
 			fprintf(stderr, ""WARNING - GPAC not compiled with Memory Tracker - ignoring \""%s\""\n"", arg);
 #endif
 		} else if (!strcmp(arg, ""-gui"")) {
 			gui_mode = 1;
 		} else if (!strcmp(arg, ""-guid"")) {
 			gui_mode = 2;
 		} else if (!strcmp(arg, ""-h"") || !strcmp(arg, ""-help"")) {
 			PrintUsage();
 			return 0;
 		}
 	}
 #ifdef GPAC_MEMORY_TRACKING
 	gf_sys_init(mem_track);
 #else
 	gf_sys_init(GF_MemTrackerNone);
 #endif
 	gf_sys_set_args(argc, (const char **) argv);
 	cfg_file = gf_cfg_init(the_cfg, NULL);
 	if (!cfg_file) {
 		fprintf(stderr, ""Error: Configuration File not found\n"");
 		return 1;
 	}
 	if (gf_log_set_tools_levels( gf_cfg_get_key(cfg_file, ""General"", ""Logs"") ) != GF_OK) {
 		return 1;
 	}
 	if( gf_cfg_get_key(cfg_file, ""General"", ""Logs"") != NULL ) {
 		logs_set = GF_TRUE;
 	}
 	if (!gui_mode) {
 		str = gf_cfg_get_key(cfg_file, ""General"", ""ForceGUI"");
 		if (str && !strcmp(str, ""yes"")) gui_mode = 1;
 	}
 	for (i=1; i<(u32) argc; i++) {
 		char *arg = argv[i];
 		if (!strcmp(arg, ""-rti"")) {
 			rti_file = argv[i+1];
 			i++;
 		} else if (!strcmp(arg, ""-rtix"")) {
 			rti_file = argv[i+1];
 			i++;
 			use_rtix = GF_TRUE;
 		} else if (!stricmp(arg, ""-size"")) {
 			if (sscanf(argv[i+1], ""%dx%d"", &forced_width, &forced_height) != 2) {
 				forced_width = forced_height = 0;
 			}
 			i++;
 		} else if (!strcmp(arg, ""-quiet"")) {
 			be_quiet = 1;
 		} else if (!strcmp(arg, ""-strict-error"")) {
 			gf_log_set_strict_error(1);
 		} else if (!strcmp(arg, ""-log-file"") || !strcmp(arg, ""-lf"")) {
 			logfile = gf_fopen(argv[i+1], ""wt"");
 			gf_log_set_callback(logfile, on_gpac_log);
 			i++;
 		} else if (!strcmp(arg, ""-logs"") ) {
 			if (gf_log_set_tools_levels(argv[i+1]) != GF_OK) {
 				return 1;
 			}
 			logs_set = GF_TRUE;
 			i++;
 		} else if (!strcmp(arg, ""-log-clock"") || !strcmp(arg, ""-lc"")) {
 			log_time_start = 1;
 		} else if (!strcmp(arg, ""-log-utc"") || !strcmp(arg, ""-lu"")) {
 			log_utc_time = 1;
 		}
 #if defined(__DARWIN__) || defined(__APPLE__)
 		else if (!strcmp(arg, ""-thread"")) threading_flags = 0;
 #else
 		else if (!strcmp(arg, ""-no-thread"")) threading_flags = GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_WINDOW_NO_THREAD;
 #endif
 		else if (!strcmp(arg, ""-no-cthread"") || !strcmp(arg, ""-no-compositor-thread"")) threading_flags |= GF_TERM_NO_COMPOSITOR_THREAD;
 		else if (!strcmp(arg, ""-no-audio"")) no_audio = 1;
 		else if (!strcmp(arg, ""-no-regulation"")) no_regulation = 1;
 		else if (!strcmp(arg, ""-fs"")) start_fs = 1;
 		else if (!strcmp(arg, ""-opt"")) {
 			set_cfg_option(argv[i+1]);
 			i++;
 		} else if (!strcmp(arg, ""-conf"")) {
 			set_cfg_option(argv[i+1]);
 			is_cfg_only=GF_TRUE;
 			i++;
 		}
 		else if (!strcmp(arg, ""-ifce"")) {
 			gf_cfg_set_key(cfg_file, ""Network"", ""DefaultMCastInterface"", argv[i+1]);
 			i++;
 		}
 		else if (!stricmp(arg, ""-help"")) {
 			PrintUsage();
 			return 1;
 		}
 		else if (!stricmp(arg, ""-noprog"")) {
 			no_prog=1;
 			gf_set_progress_callback(NULL, progress_quiet);
 		}
 		else if (!stricmp(arg, ""-no-save"") || !stricmp(arg, ""--no-save"")  ) {
 			no_cfg_save=1;
 		}
 		else if (!stricmp(arg, ""-ntp-shift"")) {
 			s32 shift = atoi(argv[i+1]);
 			i++;
 			gf_net_set_ntp_shift(shift);
 		}
 		else if (!stricmp(arg, ""-run-for"")) {
 			simulation_time_in_ms = atoi(argv[i+1]) * 1000;
 			if (!simulation_time_in_ms)
 				simulation_time_in_ms = 1;  
 			i++;
 		}
 		else if (!strcmp(arg, ""-out"")) {
 			out_arg = argv[i+1];
 			i++;
 		}
 		else if (!stricmp(arg, ""-fps"")) {
 			fps = atof(argv[i+1]);
 			i++;
 		} else if (!strcmp(arg, ""-avi"") || !strcmp(arg, ""-sha"")) {
 			dump_mode &= 0xFFFF0000;
 			if (!strcmp(arg, ""-sha"")) dump_mode |= DUMP_SHA1;
 			else dump_mode |= DUMP_AVI;
 			if ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) {
 				if (!strcmp(arg, ""-avi"") && (nb_times!=2) ) {
 					fprintf(stderr, ""Only one time arg found for -avi - check usage\n"");
 					return 1;
 				}
 				i++;
 			}
 		} else if (!strcmp(arg, ""-rgbds"")) {  
 				dump_mode |= DUMP_RGB_DEPTH_SHAPE;
 		} else if (!strcmp(arg, ""-rgbd"")) {  
 				dump_mode |= DUMP_RGB_DEPTH;
 		} else if (!strcmp(arg, ""-depth"")) {
 				dump_mode |= DUMP_DEPTH_ONLY;
 		} else if (!strcmp(arg, ""-bmp"")) {
 			dump_mode &= 0xFFFF0000;
 			dump_mode |= DUMP_BMP;
 			if ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;
 		} else if (!strcmp(arg, ""-png"")) {
 			dump_mode &= 0xFFFF0000;
 			dump_mode |= DUMP_PNG;
 			if ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;
 		} else if (!strcmp(arg, ""-raw"")) {
 			dump_mode &= 0xFFFF0000;
 			dump_mode |= DUMP_RAW;
 			if ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;
 		} else if (!stricmp(arg, ""-scale"")) {
 			sscanf(argv[i+1], ""%f"", &scale);
 			i++;
 		}
 		else if (!strcmp(arg, ""-c"") || !strcmp(arg, ""-cfg"")) {
 			i++;
 		}
 		if (!gui_mode) {
 			if (arg[0] != '-') {
 				if (url_arg) {
 					fprintf(stderr, ""Several input URLs provided (\""%s\"", \""%s\""). Check your command-line.\n"", url_arg, arg);
 					return 1;
 				}
 				url_arg = arg;
 			}
 			else if (!strcmp(arg, ""-loop"")) loop_at_end = 1;
 			else if (!strcmp(arg, ""-bench"")) bench_mode = 1;
 			else if (!strcmp(arg, ""-vbench"")) bench_mode = 2;
 			else if (!strcmp(arg, ""-sbench"")) bench_mode = 3;
 			else if (!strcmp(arg, ""-no-addon"")) enable_add_ons = GF_FALSE;
 			else if (!strcmp(arg, ""-pause"")) pause_at_first = 1;
 			else if (!strcmp(arg, ""-play-from"")) {
 				play_from = atof((const char *) argv[i+1]);
 				i++;
 			}
 			else if (!strcmp(arg, ""-speed"")) {
 				playback_speed = FLT2FIX( atof((const char *) argv[i+1]) );
 				if (playback_speed <= 0) playback_speed = FIX_ONE;
 				i++;
 			}
 			else if (!strcmp(arg, ""-no-wnd"")) user.init_flags |= GF_TERM_WINDOWLESS;
 			else if (!strcmp(arg, ""-no-back"")) user.init_flags |= GF_TERM_WINDOW_TRANSPARENT;
 			else if (!strcmp(arg, ""-align"")) {
 				if (argv[i+1][0]=='m') align_mode = 1;
 				else if (argv[i+1][0]=='b') align_mode = 2;
 				align_mode <<= 8;
 				if (argv[i+1][1]=='m') align_mode |= 1;
 				else if (argv[i+1][1]=='r') align_mode |= 2;
 				i++;
 			} else if (!strcmp(arg, ""-fill"")) {
 				fill_ar = GF_TRUE;
 			} else if (!strcmp(arg, ""-show"")) {
 				visible = 1;
 			} else if (!strcmp(arg, ""-uncache"")) {
 				do_uncache = GF_TRUE;
 			}
 			else if (!strcmp(arg, ""-exit"")) auto_exit = GF_TRUE;
 			else if (!stricmp(arg, ""-views"")) {
 				views = argv[i+1];
 				i++;
 			}
 			else if (!stricmp(arg, ""-mosaic"")) {
 				mosaic = argv[i+1];
 				i++;
 			}
 			else if (!stricmp(arg, ""-com"")) {
 				has_command = GF_TRUE;
 				i++;
 			}
 			else if (!stricmp(arg, ""-service"")) {
 				initial_service_id = atoi(argv[i+1]);
 				i++;
 			}
 		}
 	}
 	if (is_cfg_only) {
 		gf_cfg_del(cfg_file);
 		fprintf(stderr, ""GPAC Config updated\n"");
 		return 0;
 	}
 	if (do_uncache) {
 		const char *cache_dir = gf_cfg_get_key(cfg_file, ""General"", ""CacheDirectory"");
 		do_flatten_cache(cache_dir);
 		fprintf(stderr, ""GPAC Cache dir %s flattened\n"", cache_dir);
 		gf_cfg_del(cfg_file);
 		return 0;
 	}
 	if (dump_mode && !url_arg ) {
 		FILE *test;
 		url_arg = (char *)gf_cfg_get_key(cfg_file, ""General"", ""StartupFile"");
 		test = url_arg ? gf_fopen(url_arg, ""rt"") : NULL;
 		if (!test) url_arg = NULL;
 		else gf_fclose(test);
 		if (!url_arg) {
 			fprintf(stderr, ""Missing argument for dump\n"");
 			PrintUsage();
 			if (logfile) gf_fclose(logfile);
 			return 1;
 		}
 	}
 	if (!gui_mode && !url_arg && (gf_cfg_get_key(cfg_file, ""General"", ""StartupFile"") != NULL)) {
 		gui_mode=1;
 	}
 #ifdef WIN32
 	if (gui_mode==1) {
 		const char *opt;
 		TCHAR buffer[1024];
 		DWORD res = GetCurrentDirectory(1024, buffer);
 		buffer[res] = 0;
 		opt = gf_cfg_get_key(cfg_file, ""General"", ""ModulesDirectory"");
 		if (strstr(opt, buffer)) {
 			gui_mode=1;
 		} else {
 			gui_mode=2;
 		}
 	}
 #endif
 	if (gui_mode==1) {
 		hide_shell(1);
 	}
 	if (gui_mode) {
 		no_prog=1;
 		gf_set_progress_callback(NULL, progress_quiet);
 	}
 	if (!url_arg && simulation_time_in_ms)
 		simulation_time_in_ms += gf_sys_clock();
 #if defined(__DARWIN__) || defined(__APPLE__)
 	carbon_init();
 #endif
 	if (dump_mode) rti_file = NULL;
 	if (!logs_set) {
 		gf_log_set_tool_level(GF_LOG_ALL, GF_LOG_WARNING);
 	}
 	if (rti_file || logfile || log_utc_time || log_time_start)
 		gf_log_set_callback(NULL, on_gpac_log);
 	if (rti_file) init_rti_logs(rti_file, url_arg, use_rtix);
 	{
 		GF_SystemRTInfo rti;
 		if (gf_sys_get_rti(0, &rti, 0))
 			fprintf(stderr, ""System info: %d MB RAM - %d cores\n"", (u32) (rti.physical_memory/1024/1024), rti.nb_cores);
 	}
 	if (dump_mode) {
 		user.init_flags |= GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_NO_REGULATION;
 		if (!visible)
 			user.init_flags |= GF_TERM_INIT_HIDE;
 		gf_cfg_set_key(cfg_file, ""Audio"", ""DriverName"", ""Raw Audio Output"");
 		no_cfg_save=GF_TRUE;
 	} else {
 		init_w = forced_width;
 		init_h = forced_height;
 	}
 	user.modules = gf_modules_new(NULL, cfg_file);
 	if (user.modules) i = gf_modules_get_count(user.modules);
 	if (!i || !user.modules) {
 		fprintf(stderr, ""Error: no modules found - exiting\n"");
 		if (user.modules) gf_modules_del(user.modules);
 		gf_cfg_del(cfg_file);
 		gf_sys_close();
 		if (logfile) gf_fclose(logfile);
 		return 1;
 	}
 	fprintf(stderr, ""Modules Found : %d \n"", i);
 	str = gf_cfg_get_key(cfg_file, ""General"", ""GPACVersion"");
 	if (!str || strcmp(str, GPAC_FULL_VERSION)) {
 		gf_cfg_del_section(cfg_file, ""PluginsCache"");
 		gf_cfg_set_key(cfg_file, ""General"", ""GPACVersion"", GPAC_FULL_VERSION);
 	}
 	user.config = cfg_file;
 	user.EventProc = GPAC_EventProc;
 	user.opaque = user.modules;
 	if (threading_flags) user.init_flags |= threading_flags;
 	if (no_audio) user.init_flags |= GF_TERM_NO_AUDIO;
 	if (no_regulation) user.init_flags |= GF_TERM_NO_REGULATION;
 	if (threading_flags & (GF_TERM_NO_DECODER_THREAD|GF_TERM_NO_COMPOSITOR_THREAD) ) term_step = GF_TRUE;
 	if (dump_mode) user.init_flags |= GF_TERM_USE_AUDIO_HW_CLOCK;
 	if (bench_mode) {
 		gf_cfg_discard_changes(user.config);
 		auto_exit = GF_TRUE;
 		gf_cfg_set_key(user.config, ""Audio"", ""DriverName"", ""Raw Audio Output"");
 		if (bench_mode!=2) {
 			gf_cfg_set_key(user.config, ""Video"", ""DriverName"", ""Raw Video Output"");
 			gf_cfg_set_key(user.config, ""RAWVideo"", ""RawOutput"", ""null"");
 			gf_cfg_set_key(user.config, ""Compositor"", ""OpenGLMode"", ""disable"");
 		} else {
 			gf_cfg_set_key(user.config, ""Video"", ""DisableVSync"", ""yes"");
 		}
 	}
 	{
 		char dim[50];
 		sprintf(dim, ""%d"", forced_width);
 		gf_cfg_set_key(user.config, ""Compositor"", ""DefaultWidth"", forced_width ? dim : NULL);
 		sprintf(dim, ""%d"", forced_height);
 		gf_cfg_set_key(user.config, ""Compositor"", ""DefaultHeight"", forced_height ? dim : NULL);
 	}
 	fprintf(stderr, ""Loading GPAC Terminal\n"");
 	i = gf_sys_clock();
 	term = gf_term_new(&user);
 	if (!term) {
 		fprintf(stderr, ""\nInit error - check you have at least one video out and one rasterizer...\nFound modules:\n"");
 		list_modules(user.modules);
 		gf_modules_del(user.modules);
 		gf_cfg_discard_changes(cfg_file);
 		gf_cfg_del(cfg_file);
 		gf_sys_close();
 		if (logfile) gf_fclose(logfile);
 		return 1;
 	}
 	fprintf(stderr, ""Terminal Loaded in %d ms\n"", gf_sys_clock()-i);
 	if (bench_mode) {
 		display_rti = 2;
 		gf_term_set_option(term, GF_OPT_VIDEO_BENCH, (bench_mode==3) ? 2 : 1);
 		if (bench_mode==1) bench_mode=2;
 	}
 	if (dump_mode) {
 		if (fill_ar) gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);
 	} else {
 		str = gf_cfg_get_key(cfg_file, ""Video"", ""DriverName"");
 		if (!bench_mode && !strcmp(str, ""Raw Video Output"")) fprintf(stderr, ""WARNING: using raw output video (memory only) - no display used\n"");
 		str = gf_cfg_get_key(cfg_file, ""Audio"", ""DriverName"");
 		if (!str || !strcmp(str, ""No Audio Output Available"")) fprintf(stderr, ""WARNING: no audio output available - make sure no other program is locking the sound card\n"");
 		str = gf_cfg_get_key(cfg_file, ""General"", ""NoMIMETypeFetch"");
 		no_mime_check = (str && !stricmp(str, ""yes"")) ? 1 : 0;
 	}
 	str = gf_cfg_get_key(cfg_file, ""HTTPProxy"", ""Enabled"");
 	if (str && !strcmp(str, ""yes"")) {
 		str = gf_cfg_get_key(cfg_file, ""HTTPProxy"", ""Name"");
 		if (str) fprintf(stderr, ""HTTP Proxy %s enabled\n"", str);
 	}
 	if (rti_file) {
 		str = gf_cfg_get_key(cfg_file, ""General"", ""RTIRefreshPeriod"");
 		if (str) {
 			rti_update_time_ms = atoi(str);
 		} else {
 			gf_cfg_set_key(cfg_file, ""General"", ""RTIRefreshPeriod"", ""200"");
 		}
 		UpdateRTInfo(""At GPAC load time\n"");
 	}
 	Run = 1;
 	if (dump_mode) {
 		if (!nb_times) {
 			times[0] = 0;
 			nb_times++;
 		}
 		ret_val = dump_file(url_arg, out_arg, dump_mode, fps, forced_width, forced_height, scale, times, nb_times);
 		Run = 0;
 	}
 	else if (views) {
 	}
  	else if (!gui_mode && url_arg) {
  		char *ext;
		strcpy(the_url, url_arg);
 		if (strlen(url_arg) >= sizeof(the_url)) {
 			fprintf(stderr, ""Input url %s is too long, truncating to %d chars.\n"", url_arg, (int)(sizeof(the_url) - 1));
 			strncpy(the_url, url_arg, sizeof(the_url)-1);
 			the_url[sizeof(the_url) - 1] = 0;
 		}
 		else {
 			strcpy(the_url, url_arg);
 		}
  		ext = strrchr(the_url, '.');
  		if (ext && (!stricmp(ext, "".m3u"") || !stricmp(ext, "".pls""))) {
  			GF_Err e = GF_OK;
 			fprintf(stderr, ""Opening Playlist %s\n"", the_url);
 			strcpy(pl_path, the_url);
 			if (!strncmp(""http:"", the_url, 5)) {
  				GF_DownloadSession *sess = gf_dm_sess_new(term->downloader, the_url, GF_NETIO_SESSION_NOT_THREADED, NULL, NULL, &e);
  				if (sess) {
  					e = gf_dm_sess_process(sess);
					if (!e) strcpy(the_url, gf_dm_sess_get_cache_name(sess));
 					if (!e) {
 						strncpy(the_url, gf_dm_sess_get_cache_name(sess), sizeof(the_url) - 1);
 						the_url[sizeof(the_cfg) - 1] = 0;
 					}
  					gf_dm_sess_del(sess);
  				}
  			}
 			playlist = e ? NULL : gf_fopen(the_url, ""rt"");
 			readonly_playlist = 1;
 			if (playlist) {
 				request_next_playlist_item = GF_TRUE;
 			} else {
 				if (e)
 					fprintf(stderr, ""Failed to open playlist %s: %s\n"", the_url, gf_error_to_string(e) );
 				fprintf(stderr, ""Hit 'h' for help\n\n"");
 			}
 		} else {
 			fprintf(stderr, ""Opening URL %s\n"", the_url);
 			if (pause_at_first) fprintf(stderr, ""[Status: Paused]\n"");
 			gf_term_connect_from_time(term, the_url, (u64) (play_from*1000), pause_at_first);
 		}
 	} else {
  		fprintf(stderr, ""Hit 'h' for help\n\n"");
  		str = gf_cfg_get_key(cfg_file, ""General"", ""StartupFile"");
  		if (str) {
			strcpy(the_url, ""MP4Client ""GPAC_FULL_VERSION);
 			strncpy(the_url, ""MP4Client ""GPAC_FULL_VERSION , sizeof(the_url)-1);
 			the_url[sizeof(the_url) - 1] = 0;
  			gf_term_connect(term, str);
  			startup_file = 1;
  			is_connected = 1;
 		}
 	}
 	if (gui_mode==2) gui_mode=0;
 	if (start_fs) gf_term_set_option(term, GF_OPT_FULLSCREEN, 1);
 	if (views) {
 		char szTemp[4046];
 		sprintf(szTemp, ""views:%s"", views);
 		gf_term_connect(term, szTemp);
 	}
 	if (mosaic) {
 		char szTemp[4046];
 		sprintf(szTemp, ""mosaic:%s"", mosaic);
 		gf_term_connect(term, szTemp);
 	}
 	if (bench_mode) {
 		rti_update_time_ms = 500;
 		bench_mode_start = gf_sys_clock();
 	}
 	while (Run) {
 		if ((gui_mode==1) || !gf_prompt_has_input()) {
 			if (reload) {
 				reload = 0;
 				gf_term_disconnect(term);
 				gf_term_connect(term, startup_file ? gf_cfg_get_key(cfg_file, ""General"", ""StartupFile"") : the_url);
 			}
 			if (restart && gf_term_get_option(term, GF_OPT_IS_OVER)) {
 				restart = 0;
 				gf_term_play_from_time(term, 0, 0);
 			}
 			if (request_next_playlist_item) {
 				c = '\n';
 				request_next_playlist_item = 0;
 				goto force_input;
 			}
 			if (has_command && is_connected) {
 				has_command = GF_FALSE;
 				for (i=0; i<(u32)argc; i++) {
 					if (!strcmp(argv[i], ""-com"")) {
 						gf_term_scene_update(term, NULL, argv[i+1]);
 						i++;
 					}
 				}
 			}
 			if (initial_service_id && is_connected) {
 				GF_ObjectManager *root_od = gf_term_get_root_object(term);
 				if (root_od) {
 					gf_term_select_service(term, root_od, initial_service_id);
 					initial_service_id = 0;
 				}
 			}
 			if (!use_rtix || display_rti) UpdateRTInfo(NULL);
 			if (term_step) {
 				gf_term_process_step(term);
 			} else {
 				gf_sleep(rti_update_time_ms);
 			}
 			if (auto_exit && eos_seen && gf_term_get_option(term, GF_OPT_IS_OVER)) {
 				Run = GF_FALSE;
 			}
 			if (simulation_time_in_ms
 			        && ( (gf_term_get_elapsed_time_in_ms(term)>simulation_time_in_ms) || (!url_arg && gf_sys_clock()>simulation_time_in_ms))
 			   ) {
 				Run = GF_FALSE;
 			}
 			continue;
 		}
 		c = gf_prompt_get_char();
 force_input:
 		switch (c) {
 		case 'q':
 		{
 			GF_Event evt;
 			memset(&evt, 0, sizeof(GF_Event));
 			evt.type = GF_EVENT_QUIT;
 			gf_term_send_event(term, &evt);
 		}
 		break;
 		case 'X':
 			exit(0);
 			break;
 		case 'Q':
 			break;
 		case 'o':
 			startup_file = 0;
 			gf_term_disconnect(term);
 			fprintf(stderr, ""Enter the absolute URL\n"");
 			if (1 > scanf(""%s"", the_url)) {
 				fprintf(stderr, ""Cannot read absolute URL, aborting\n"");
 				break;
 			}
 			if (rti_file) init_rti_logs(rti_file, the_url, use_rtix);
 			gf_term_connect(term, the_url);
 			break;
 		case 'O':
 			gf_term_disconnect(term);
 			fprintf(stderr, ""Enter the absolute URL to the playlist\n"");
 			if (1 > scanf(""%s"", the_url)) {
 				fprintf(stderr, ""Cannot read the absolute URL, aborting.\n"");
 				break;
 			}
 			playlist = gf_fopen(the_url, ""rt"");
 			if (playlist) {
 				if (1 >	fscanf(playlist, ""%s"", the_url)) {
 					fprintf(stderr, ""Cannot read any URL from playlist, aborting.\n"");
 					gf_fclose( playlist);
 					break;
 				}
 				fprintf(stderr, ""Opening URL %s\n"", the_url);
 				gf_term_connect(term, the_url);
 			}
 			break;
 		case '\n':
 		case 'N':
 			if (playlist) {
 				int res;
 				gf_term_disconnect(term);
 				res = fscanf(playlist, ""%s"", the_url);
 				if ((res == EOF) && loop_at_end) {
 					fseek(playlist, 0, SEEK_SET);
 					res = fscanf(playlist, ""%s"", the_url);
 				}
 				if (res == EOF) {
 					fprintf(stderr, ""No more items - exiting\n"");
 					Run = 0;
 				} else if (the_url[0] == '#') {
 					request_next_playlist_item = GF_TRUE;
 				} else {
 					fprintf(stderr, ""Opening URL %s\n"", the_url);
 					gf_term_connect_with_path(term, the_url, pl_path);
 				}
 			}
 			break;
 		case 'P':
 			if (playlist) {
 				u32 count;
 				gf_term_disconnect(term);
 				if (1 > scanf(""%u"", &count)) {
 					fprintf(stderr, ""Cannot read number, aborting.\n"");
 					break;
 				}
 				while (count) {
 					if (fscanf(playlist, ""%s"", the_url)) {
 						fprintf(stderr, ""Failed to read line, aborting\n"");
 						break;
 					}
 					count--;
 				}
 				fprintf(stderr, ""Opening URL %s\n"", the_url);
 				gf_term_connect(term, the_url);
 			}
 			break;
 		case 'r':
 			if (is_connected)
 				reload = 1;
 			break;
 		case 'D':
 			if (is_connected) gf_term_disconnect(term);
 			break;
 		case 'p':
 			if (is_connected) {
 				Bool is_pause = gf_term_get_option(term, GF_OPT_PLAY_STATE);
 				fprintf(stderr, ""[Status: %s]\n"", is_pause ? ""Playing"" : ""Paused"");
 				gf_term_set_option(term, GF_OPT_PLAY_STATE, is_pause ? GF_STATE_PLAYING : GF_STATE_PAUSED);
 			}
 			break;
 		case 's':
 			if (is_connected) {
 				gf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_STEP_PAUSE);
 				fprintf(stderr, ""Step time: "");
 				PrintTime(gf_term_get_time_in_ms(term));
 				fprintf(stderr, ""\n"");
 			}
 			break;
 		case 'z':
 		case 'T':
 			if (!CanSeek || (Duration<=2000)) {
 				fprintf(stderr, ""scene not seekable\n"");
 			} else {
 				Double res;
 				s32 seekTo;
 				fprintf(stderr, ""Duration: "");
 				PrintTime(Duration);
 				res = gf_term_get_time_in_ms(term);
 				if (c=='z') {
 					res *= 100;
 					res /= (s64)Duration;
 					fprintf(stderr, "" (current %.2f %%)\nEnter Seek percentage:\n"", res);
 					if (scanf(""%d"", &seekTo) == 1) {
 						if (seekTo > 100) seekTo = 100;
 						res = (Double)(s64)Duration;
 						res /= 100;
 						res *= seekTo;
 						gf_term_play_from_time(term, (u64) (s64) res, 0);
 					}
 				} else {
 					u32 r, h, m, s;
 					fprintf(stderr, "" - Current Time: "");
 					PrintTime((u64) res);
 					fprintf(stderr, ""\nEnter seek time (Format: s, m:s or h:m:s):\n"");
 					h = m = s = 0;
 					r =scanf(""%d:%d:%d"", &h, &m, &s);
 					if (r==2) {
 						s = m;
 						m = h;
 						h = 0;
 					}
 					else if (r==1) {
 						s = h;
 						m = h = 0;
 					}
 					if (r && (r<=3)) {
 						u64 time = h*3600 + m*60 + s;
 						gf_term_play_from_time(term, time*1000, 0);
 					}
 				}
 			}
 			break;
 		case 't':
 		{
 			if (is_connected) {
 				fprintf(stderr, ""Current Time: "");
 				PrintTime(gf_term_get_time_in_ms(term));
 				fprintf(stderr, "" - Duration: "");
 				PrintTime(Duration);
 				fprintf(stderr, ""\n"");
 			}
 		}
 		break;
 		case 'w':
 			if (is_connected) PrintWorldInfo(term);
 			break;
 		case 'v':
 			if (is_connected) PrintODList(term, NULL, 0, 0, ""Root"");
 			break;
 		case 'i':
 			if (is_connected) {
 				u32 ID;
 				fprintf(stderr, ""Enter OD ID (0 for main OD): "");
 				fflush(stderr);
 				if (scanf(""%ud"", &ID) == 1) {
 					ViewOD(term, ID, (u32)-1, NULL);
 				} else {
 					char str_url[GF_MAX_PATH];
 					if (scanf(""%s"", str_url) == 1)
 						ViewOD(term, 0, (u32)-1, str_url);
 				}
 			}
 			break;
 		case 'j':
 			if (is_connected) {
 				u32 num;
 				do {
 					fprintf(stderr, ""Enter OD number (0 for main OD): "");
 					fflush(stderr);
 				} while( 1 > scanf(""%ud"", &num));
 				ViewOD(term, (u32)-1, num, NULL);
 			}
 			break;
 		case 'b':
 			if (is_connected) ViewODs(term, 1);
 			break;
 		case 'm':
 			if (is_connected) ViewODs(term, 0);
 			break;
 		case 'l':
 			list_modules(user.modules);
 			break;
 		case 'n':
 			if (is_connected) set_navigation();
 			break;
 		case 'x':
 			if (is_connected) gf_term_set_option(term, GF_OPT_NAVIGATION_TYPE, 0);
 			break;
 		case 'd':
 			if (is_connected) {
 				GF_ObjectManager *odm = NULL;
 				char radname[GF_MAX_PATH], *sExt;
 				GF_Err e;
 				u32 i, count, odid;
 				Bool xml_dump, std_out;
 				radname[0] = 0;
 				do {
 					fprintf(stderr, ""Enter Inline OD ID if any or 0 : "");
 					fflush(stderr);
 				} while( 1 >  scanf(""%ud"", &odid));
 				if (odid) {
 					GF_ObjectManager *root_odm = gf_term_get_root_object(term);
 					if (!root_odm) break;
 					count = gf_term_get_object_count(term, root_odm);
 					for (i=0; i<count; i++) {
 						GF_MediaInfo info;
 						odm = gf_term_get_object(term, root_odm, i);
 						if (gf_term_get_object_info(term, odm, &info) == GF_OK) {
 							if (info.od->objectDescriptorID==odid) break;
 						}
 						odm = NULL;
 					}
 				}
 				do {
 					fprintf(stderr, ""Enter file radical name (+\'.x\' for XML dumping) - \""std\"" for stderr: "");
 					fflush(stderr);
 				} while( 1 > scanf(""%s"", radname));
 				sExt = strrchr(radname, '.');
 				xml_dump = 0;
 				if (sExt) {
 					if (!stricmp(sExt, "".x"")) xml_dump = 1;
 					sExt[0] = 0;
 				}
 				std_out = strnicmp(radname, ""std"", 3) ? 0 : 1;
 				e = gf_term_dump_scene(term, std_out ? NULL : radname, NULL, xml_dump, 0, odm);
 				fprintf(stderr, ""Dump done (%s)\n"", gf_error_to_string(e));
 			}
 			break;
 		case 'c':
 			PrintGPACConfig();
 			break;
 		case '3':
 		{
 			Bool use_3d = !gf_term_get_option(term, GF_OPT_USE_OPENGL);
 			if (gf_term_set_option(term, GF_OPT_USE_OPENGL, use_3d)==GF_OK) {
 				fprintf(stderr, ""Using %s for 2D drawing\n"", use_3d ? ""OpenGL"" : ""2D rasterizer"");
 			}
 		}
 		break;
 		case 'k':
 		{
 			Bool opt = gf_term_get_option(term, GF_OPT_STRESS_MODE);
 			opt = !opt;
 			fprintf(stderr, ""Turning stress mode %s\n"", opt ? ""on"" : ""off"");
 			gf_term_set_option(term, GF_OPT_STRESS_MODE, opt);
 		}
 		break;
 		case '4':
 			gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_4_3);
 			break;
 		case '5':
 			gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_16_9);
 			break;
 		case '6':
 			gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);
 			break;
 		case '7':
 			gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_KEEP);
 			break;
 		case 'C':
 			switch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {
 			case GF_MEDIA_CACHE_DISABLED:
 				gf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_ENABLED);
 				break;
 			case GF_MEDIA_CACHE_ENABLED:
 				gf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_DISABLED);
 				break;
 			case GF_MEDIA_CACHE_RUNNING:
 				fprintf(stderr, ""Streaming Cache is running - please stop it first\n"");
 				continue;
 			}
 			switch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {
 			case GF_MEDIA_CACHE_ENABLED:
 				fprintf(stderr, ""Streaming Cache Enabled\n"");
 				break;
 			case GF_MEDIA_CACHE_DISABLED:
 				fprintf(stderr, ""Streaming Cache Disabled\n"");
 				break;
 			case GF_MEDIA_CACHE_RUNNING:
 				fprintf(stderr, ""Streaming Cache Running\n"");
 				break;
 			}
 			break;
 		case 'S':
 		case 'A':
 			if (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)==GF_MEDIA_CACHE_RUNNING) {
 				gf_term_set_option(term, GF_OPT_MEDIA_CACHE, (c=='S') ? GF_MEDIA_CACHE_DISABLED : GF_MEDIA_CACHE_DISCARD);
 				fprintf(stderr, ""Streaming Cache stopped\n"");
 			} else {
 				fprintf(stderr, ""Streaming Cache not running\n"");
 			}
 			break;
 		case 'R':
 			display_rti = !display_rti;
 			ResetCaption();
 			break;
 		case 'F':
 			if (display_rti) display_rti = 0;
 			else display_rti = 2;
 			ResetCaption();
 			break;
 		case 'u':
 		{
 			GF_Err e;
 			char szCom[8192];
 			fprintf(stderr, ""Enter command to send:\n"");
 			fflush(stdin);
 			szCom[0] = 0;
 			if (1 > scanf(""%[^\t\n]"", szCom)) {
 				fprintf(stderr, ""Cannot read command to send, aborting.\n"");
 				break;
 			}
 			e = gf_term_scene_update(term, NULL, szCom);
 			if (e) fprintf(stderr, ""Processing command failed: %s\n"", gf_error_to_string(e));
 		}
 		break;
 		case 'e':
 		{
 			GF_Err e;
 			char jsCode[8192];
 			fprintf(stderr, ""Enter JavaScript code to evaluate:\n"");
 			fflush(stdin);
 			jsCode[0] = 0;
 			if (1 > scanf(""%[^\t\n]"", jsCode)) {
 				fprintf(stderr, ""Cannot read code to evaluate, aborting.\n"");
 				break;
 			}
 			e = gf_term_scene_update(term, ""application/ecmascript"", jsCode);
 			if (e) fprintf(stderr, ""Processing JS code failed: %s\n"", gf_error_to_string(e));
 		}
 		break;
 		case 'L':
 		{
 			char szLog[1024], *cur_logs;
 			cur_logs = gf_log_get_tools_levels();
 			fprintf(stderr, ""Enter new log level (current tools %s):\n"", cur_logs);
 			gf_free(cur_logs);
 			if (scanf(""%s"", szLog) < 1) {
 				fprintf(stderr, ""Cannot read new log level, aborting.\n"");
 				break;
 			}
 			gf_log_modify_tools_levels(szLog);
 		}
 		break;
 		case 'g':
 		{
 			GF_SystemRTInfo rti;
 			gf_sys_get_rti(rti_update_time_ms, &rti, 0);
 			fprintf(stderr, ""GPAC allocated memory ""LLD""\n"", rti.gpac_memory);
 		}
 		break;
 		case 'M':
 		{
 			u32 size;
 			do {
 				fprintf(stderr, ""Enter new video cache memory in kBytes (current %ud):\n"", gf_term_get_option(term, GF_OPT_VIDEO_CACHE_SIZE));
 			} while (1 > scanf(""%ud"", &size));
 			gf_term_set_option(term, GF_OPT_VIDEO_CACHE_SIZE, size);
 		}
 		break;
 		case 'H':
 		{
 			u32 http_bitrate = gf_term_get_option(term, GF_OPT_HTTP_MAX_RATE);
 			do {
 				fprintf(stderr, ""Enter new http bitrate in bps (0 for none) - current limit: %d\n"", http_bitrate);
 			} while (1 > scanf(""%ud"", &http_bitrate));
 			gf_term_set_option(term, GF_OPT_HTTP_MAX_RATE, http_bitrate);
 		}
 		break;
 		case 'E':
 			gf_term_set_option(term, GF_OPT_RELOAD_CONFIG, 1);
 			break;
 		case 'B':
 			switch_bench(!bench_mode);
 			break;
 		case 'Y':
 		{
 			char szOpt[8192];
 			fprintf(stderr, ""Enter option to set (Section:Name=Value):\n"");
 			fflush(stdin);
 			szOpt[0] = 0;
 			if (1 > scanf(""%[^\t\n]"", szOpt)) {
 				fprintf(stderr, ""Cannot read option\n"");
 				break;
 			}
 			set_cfg_option(szOpt);
 		}
 		break;
 		case 'Z':
 		{
 			char szFileName[100];
 			u32 nb_pass, nb_views, offscreen_view = 0;
 			GF_VideoSurface fb;
 			GF_Err e;
 			nb_pass = 1;
 			nb_views = gf_term_get_option(term, GF_OPT_NUM_STEREO_VIEWS);
 			if (nb_views>1) {
 				fprintf(stderr, ""Auto-stereo mode detected - type number of view to dump (0 is main output, 1 to %d offscreen view, %d for all offscreen, %d for all offscreen and main)\n"", nb_views, nb_views+1, nb_views+2);
 				if (scanf(""%d"", &offscreen_view) != 1) {
 					offscreen_view = 0;
 				}
 				if (offscreen_view==nb_views+1) {
 					offscreen_view = 1;
 					nb_pass = nb_views;
 				}
 				else if (offscreen_view==nb_views+2) {
 					offscreen_view = 0;
 					nb_pass = nb_views+1;
 				}
 			}
 			while (nb_pass) {
 				nb_pass--;
 				if (offscreen_view) {
 					sprintf(szFileName, ""view%d_dump.png"", offscreen_view);
 					e = gf_term_get_offscreen_buffer(term, &fb, offscreen_view-1, 0);
 				} else {
 					sprintf(szFileName, ""gpac_video_dump_""LLU"".png"", gf_net_get_utc() );
 					e = gf_term_get_screen_buffer(term, &fb);
 				}
 				offscreen_view++;
 				if (e) {
 					fprintf(stderr, ""Error dumping screen buffer %s\n"", gf_error_to_string(e) );
 					nb_pass = 0;
 				} else {
 #ifndef GPAC_DISABLE_AV_PARSERS
 					u32 dst_size = fb.width*fb.height*4;
 					char *dst = (char*)gf_malloc(sizeof(char)*dst_size);
 					e = gf_img_png_enc(fb.video_buffer, fb.width, fb.height, fb.pitch_y, fb.pixel_format, dst, &dst_size);
 					if (e) {
 						fprintf(stderr, ""Error encoding PNG %s\n"", gf_error_to_string(e) );
 						nb_pass = 0;
 					} else {
 						FILE *png = gf_fopen(szFileName, ""wb"");
 						if (!png) {
 							fprintf(stderr, ""Error writing file %s\n"", szFileName);
 							nb_pass = 0;
 						} else {
 							gf_fwrite(dst, dst_size, 1, png);
 							gf_fclose(png);
 							fprintf(stderr, ""Dump to %s\n"", szFileName);
 						}
 					}
 					if (dst) gf_free(dst);
 					gf_term_release_screen_buffer(term, &fb);
 #endif  
 				}
 			}
 			fprintf(stderr, ""Done: %s\n"", szFileName);
 		}
 		break;
 		case 'G':
 		{
 			GF_ObjectManager *root_od, *odm;
 			u32 index;
 			char szOpt[8192];
 			fprintf(stderr, ""Enter 0-based index of object to select or service ID:\n"");
 			fflush(stdin);
 			szOpt[0] = 0;
 			if (1 > scanf(""%[^\t\n]"", szOpt)) {
 				fprintf(stderr, ""Cannot read OD ID\n"");
 				break;
 			}
 			index = atoi(szOpt);
 			odm = NULL;
 			root_od = gf_term_get_root_object(term);
 			if (root_od) {
 				if ( gf_term_find_service(term, root_od, index)) {
 					gf_term_select_service(term, root_od, index);
 				} else {
 					fprintf(stderr, ""Cannot find service %d - trying with object index\n"", index);
 					odm = gf_term_get_object(term, root_od, index);
 					if (odm) {
 						gf_term_select_object(term, odm);
 					} else {
 						fprintf(stderr, ""Cannot find object at index %d\n"", index);
 					}
 				}
 			}
 		}
 		break;
 		case 'h':
 			PrintHelp();
 			break;
 		default:
 			break;
 		}
 	}
 	if (bench_mode) {
 		PrintAVInfo(GF_TRUE);
 	}
 	if (simulation_time_in_ms) {
 		gf_log_set_strict_error(0);
 	}
 	i = gf_sys_clock();
 	gf_term_disconnect(term);
 	if (rti_file) UpdateRTInfo(""Disconnected\n"");
 	fprintf(stderr, ""Deleting terminal... "");
 	if (playlist) gf_fclose(playlist);
 #if defined(__DARWIN__) || defined(__APPLE__)
 	carbon_uninit();
 #endif
 	gf_term_del(term);
 	fprintf(stderr, ""done (in %d ms) - ran for %d ms\n"", gf_sys_clock() - i, gf_sys_clock());
 	fprintf(stderr, ""GPAC cleanup ...\n"");
 	gf_modules_del(user.modules);
 	if (no_cfg_save)
 		gf_cfg_discard_changes(cfg_file);
 	gf_cfg_del(cfg_file);
 	gf_sys_close();
 	if (rti_logs) gf_fclose(rti_logs);
 	if (logfile) gf_fclose(logfile);
 	if (gui_mode) {
 		hide_shell(2);
 	}
 #ifdef GPAC_MEMORY_TRACKING
 	if (mem_track && (gf_memory_size() || gf_file_handles_count() )) {
 	        gf_log_set_tool_level(GF_LOG_MEMORY, GF_LOG_INFO);
 		gf_memory_print();
 		return 2;
 	}
 #endif
 	return ret_val;
 }","[429, 430, 431, 432, 433, 434, 435, 436, 437, 447, 448, 449, 450, 451, 473, 474, 475]",GPAC version 0.7.1 and earlier has a buffer overflow vulnerability in the cat_multiple_files function in applications/mp4box/fileimport.c when MP4Box is used for a local directory containing crafted filenames.,gpac,CVE-2018-20762,CWE-119
2138,182095," static int mxf_parse_structural_metadata(MXFContext *mxf)
 {
     MXFPackage *material_package = NULL;
     int i, j, k, ret;
     av_log(mxf->fc, AV_LOG_TRACE, ""metadata sets count %d\n"", mxf->metadata_sets_count);
     for (i = 0; i < mxf->packages_count; i++) {
         material_package = mxf_resolve_strong_ref(mxf, &mxf->packages_refs[i], MaterialPackage);
         if (material_package) break;
     }
     if (!material_package) {
         av_log(mxf->fc, AV_LOG_ERROR, ""no material package found\n"");
         return AVERROR_INVALIDDATA;
     }
     mxf_add_umid_metadata(&mxf->fc->metadata, ""material_package_umid"", material_package);
     if (material_package->name && material_package->name[0])
         av_dict_set(&mxf->fc->metadata, ""material_package_name"", material_package->name, 0);
     mxf_parse_package_comments(mxf, &mxf->fc->metadata, material_package);
     for (i = 0; i < material_package->tracks_count; i++) {
         MXFPackage *source_package = NULL;
         MXFTrack *material_track = NULL;
         MXFTrack *source_track = NULL;
         MXFTrack *temp_track = NULL;
         MXFDescriptor *descriptor = NULL;
         MXFStructuralComponent *component = NULL;
         MXFTimecodeComponent *mxf_tc = NULL;
         UID *essence_container_ul = NULL;
         const MXFCodecUL *codec_ul = NULL;
         const MXFCodecUL *container_ul = NULL;
         const MXFCodecUL *pix_fmt_ul = NULL;
         AVStream *st;
         AVTimecode tc;
         int flags;
         if (!(material_track = mxf_resolve_strong_ref(mxf, &material_package->tracks_refs[i], Track))) {
             av_log(mxf->fc, AV_LOG_ERROR, ""could not resolve material track strong ref\n"");
             continue;
         }
         if ((component = mxf_resolve_strong_ref(mxf, &material_track->sequence_ref, TimecodeComponent))) {
             mxf_tc = (MXFTimecodeComponent*)component;
             flags = mxf_tc->drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0;
             if (av_timecode_init(&tc, mxf_tc->rate, flags, mxf_tc->start_frame, mxf->fc) == 0) {
                 mxf_add_timecode_metadata(&mxf->fc->metadata, ""timecode"", &tc);
             }
         }
         if (!(material_track->sequence = mxf_resolve_strong_ref(mxf, &material_track->sequence_ref, Sequence))) {
             av_log(mxf->fc, AV_LOG_ERROR, ""could not resolve material track sequence strong ref\n"");
             continue;
         }
         for (j = 0; j < material_track->sequence->structural_components_count; j++) {
             component = mxf_resolve_strong_ref(mxf, &material_track->sequence->structural_components_refs[j], TimecodeComponent);
             if (!component)
                 continue;
             mxf_tc = (MXFTimecodeComponent*)component;
             flags = mxf_tc->drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0;
             if (av_timecode_init(&tc, mxf_tc->rate, flags, mxf_tc->start_frame, mxf->fc) == 0) {
                 mxf_add_timecode_metadata(&mxf->fc->metadata, ""timecode"", &tc);
                 break;
             }
         }
         if(material_track->sequence->structural_components_count > 1)
             av_log(mxf->fc, AV_LOG_WARNING, ""material track %d: has %d components\n"",
                        material_track->track_id, material_track->sequence->structural_components_count);
         for (j = 0; j < material_track->sequence->structural_components_count; j++) {
             component = mxf_resolve_sourceclip(mxf, &material_track->sequence->structural_components_refs[j]);
             if (!component)
                 continue;
             source_package = mxf_resolve_source_package(mxf, component->source_package_ul, component->source_package_uid);
             if (!source_package) {
                 av_log(mxf->fc, AV_LOG_TRACE, ""material track %d: no corresponding source package found\n"", material_track->track_id);
                 continue;
             }
             for (k = 0; k < source_package->tracks_count; k++) {
                 if (!(temp_track = mxf_resolve_strong_ref(mxf, &source_package->tracks_refs[k], Track))) {
                     av_log(mxf->fc, AV_LOG_ERROR, ""could not resolve source track strong ref\n"");
                     ret = AVERROR_INVALIDDATA;
                     goto fail_and_free;
                 }
                 if (temp_track->track_id == component->source_track_id) {
                     source_track = temp_track;
                     break;
                 }
             }
             if (!source_track) {
                 av_log(mxf->fc, AV_LOG_ERROR, ""material track %d: no corresponding source track found\n"", material_track->track_id);
                 break;
             }
             for (k = 0; k < mxf->essence_container_data_count; k++) {
                  MXFEssenceContainerData *essence_data;
                  if (!(essence_data = mxf_resolve_strong_ref(mxf, &mxf->essence_container_data_refs[k], EssenceContainerData))) {
                    av_log(mxf, AV_LOG_TRACE, ""could not resolve essence container data strong ref\n"");
                     av_log(mxf->fc, AV_LOG_TRACE, ""could not resolve essence container data strong ref\n"");
                      continue;
                  }
                  if (!memcmp(component->source_package_ul, essence_data->package_ul, sizeof(UID)) && !memcmp(component->source_package_uid, essence_data->package_uid, sizeof(UID))) {
                     source_track->body_sid = essence_data->body_sid;
                     source_track->index_sid = essence_data->index_sid;
                     break;
                 }
             }
             if(source_track && component)
                 break;
         }
         if (!source_track || !component || !source_package) {
             if((ret = mxf_add_metadata_stream(mxf, material_track)))
                 goto fail_and_free;
             continue;
         }
         if (!(source_track->sequence = mxf_resolve_strong_ref(mxf, &source_track->sequence_ref, Sequence))) {
             av_log(mxf->fc, AV_LOG_ERROR, ""could not resolve source track sequence strong ref\n"");
             ret = AVERROR_INVALIDDATA;
             goto fail_and_free;
         }
         if (memcmp(material_track->sequence->data_definition_ul, source_track->sequence->data_definition_ul, 16)) {
             av_log(mxf->fc, AV_LOG_ERROR, ""material track %d: DataDefinition mismatch\n"", material_track->track_id);
             continue;
         }
         st = avformat_new_stream(mxf->fc, NULL);
         if (!st) {
             av_log(mxf->fc, AV_LOG_ERROR, ""could not allocate stream\n"");
             ret = AVERROR(ENOMEM);
             goto fail_and_free;
         }
         st->id = material_track->track_id;
         st->priv_data = source_track;
         source_package->descriptor = mxf_resolve_strong_ref(mxf, &source_package->descriptor_ref, AnyType);
         descriptor = mxf_resolve_multidescriptor(mxf, source_package->descriptor, source_track->track_id);
         if (descriptor && descriptor->duration != AV_NOPTS_VALUE)
             source_track->original_duration = st->duration = FFMIN(descriptor->duration, component->duration);
         else
             source_track->original_duration = st->duration = component->duration;
         if (st->duration == -1)
             st->duration = AV_NOPTS_VALUE;
         st->start_time = component->start_position;
         if (material_track->edit_rate.num <= 0 ||
             material_track->edit_rate.den <= 0) {
             av_log(mxf->fc, AV_LOG_WARNING,
                    ""Invalid edit rate (%d/%d) found on stream #%d, ""
                    ""defaulting to 25/1\n"",
                    material_track->edit_rate.num,
                    material_track->edit_rate.den, st->index);
             material_track->edit_rate = (AVRational){25, 1};
         }
         avpriv_set_pts_info(st, 64, material_track->edit_rate.den, material_track->edit_rate.num);
         source_track->edit_rate = material_track->edit_rate;
         PRINT_KEY(mxf->fc, ""data definition   ul"", source_track->sequence->data_definition_ul);
         codec_ul = mxf_get_codec_ul(ff_mxf_data_definition_uls, &source_track->sequence->data_definition_ul);
         st->codecpar->codec_type = codec_ul->id;
         if (!descriptor) {
             av_log(mxf->fc, AV_LOG_INFO, ""source track %d: stream %d, no descriptor found\n"", source_track->track_id, st->index);
             continue;
         }
         PRINT_KEY(mxf->fc, ""essence codec     ul"", descriptor->essence_codec_ul);
         PRINT_KEY(mxf->fc, ""essence container ul"", descriptor->essence_container_ul);
         essence_container_ul = &descriptor->essence_container_ul;
         source_track->wrapping = (mxf->op == OPAtom) ? ClipWrapped : mxf_get_wrapping_kind(essence_container_ul);
         if (source_track->wrapping == UnknownWrapped)
             av_log(mxf->fc, AV_LOG_INFO, ""wrapping of stream %d is unknown\n"", st->index);
         if (IS_KLV_KEY(essence_container_ul, mxf_encrypted_essence_container)) {
             av_log(mxf->fc, AV_LOG_INFO, ""broken encrypted mxf file\n"");
             for (k = 0; k < mxf->metadata_sets_count; k++) {
                 MXFMetadataSet *metadata = mxf->metadata_sets[k];
                 if (metadata->type == CryptoContext) {
                     essence_container_ul = &((MXFCryptoContext *)metadata)->source_container_ul;
                     break;
                 }
             }
         }
         codec_ul = mxf_get_codec_ul(ff_mxf_codec_uls, &descriptor->essence_codec_ul);
         st->codecpar->codec_id = (enum AVCodecID)codec_ul->id;
         if (st->codecpar->codec_id == AV_CODEC_ID_NONE) {
             codec_ul = mxf_get_codec_ul(ff_mxf_codec_uls, &descriptor->codec_ul);
             st->codecpar->codec_id = (enum AVCodecID)codec_ul->id;
         }
         av_log(mxf->fc, AV_LOG_VERBOSE, ""%s: Universal Label: "",
                avcodec_get_name(st->codecpar->codec_id));
         for (k = 0; k < 16; k++) {
             av_log(mxf->fc, AV_LOG_VERBOSE, ""%.2x"",
                    descriptor->essence_codec_ul[k]);
             if (!(k+1 & 19) || k == 5)
                 av_log(mxf->fc, AV_LOG_VERBOSE, ""."");
         }
         av_log(mxf->fc, AV_LOG_VERBOSE, ""\n"");
         mxf_add_umid_metadata(&st->metadata, ""file_package_umid"", source_package);
         if (source_package->name && source_package->name[0])
             av_dict_set(&st->metadata, ""file_package_name"", source_package->name, 0);
         if (material_track->name && material_track->name[0])
             av_dict_set(&st->metadata, ""track_name"", material_track->name, 0);
         mxf_parse_physical_source_package(mxf, source_track, st);
         if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {
             source_track->intra_only = mxf_is_intra_only(descriptor);
             container_ul = mxf_get_codec_ul(mxf_picture_essence_container_uls, essence_container_ul);
             if (st->codecpar->codec_id == AV_CODEC_ID_NONE)
                 st->codecpar->codec_id = container_ul->id;
             st->codecpar->width = descriptor->width;
             st->codecpar->height = descriptor->height;  
             switch (descriptor->frame_layout) {
                 case FullFrame:
                     st->codecpar->field_order = AV_FIELD_PROGRESSIVE;
                     break;
                 case OneField:
                     av_log(mxf->fc, AV_LOG_INFO, ""OneField frame layout isn't currently supported\n"");
                     break;  
                 case MixedFields:
                     break;
                 case SegmentedFrame:
                     st->codecpar->field_order = AV_FIELD_PROGRESSIVE;
                 case SeparateFields:
                     av_log(mxf->fc, AV_LOG_DEBUG, ""video_line_map: (%d, %d), field_dominance: %d\n"",
                            descriptor->video_line_map[0], descriptor->video_line_map[1],
                            descriptor->field_dominance);
                     if ((descriptor->video_line_map[0] > 0) && (descriptor->video_line_map[1] > 0)) {
                         if ((descriptor->video_line_map[0] + descriptor->video_line_map[1]) % 2) {
                             switch (descriptor->field_dominance) {
                                 case MXF_FIELD_DOMINANCE_DEFAULT:
                                 case MXF_FIELD_DOMINANCE_FF:
                                     st->codecpar->field_order = AV_FIELD_TT;
                                     break;
                                 case MXF_FIELD_DOMINANCE_FL:
                                     st->codecpar->field_order = AV_FIELD_TB;
                                     break;
                                 default:
                                     avpriv_request_sample(mxf->fc,
                                                           ""Field dominance %d support"",
                                                           descriptor->field_dominance);
                             }
                         } else {
                             switch (descriptor->field_dominance) {
                                 case MXF_FIELD_DOMINANCE_DEFAULT:
                                 case MXF_FIELD_DOMINANCE_FF:
                                     st->codecpar->field_order = AV_FIELD_BB;
                                     break;
                                 case MXF_FIELD_DOMINANCE_FL:
                                     st->codecpar->field_order = AV_FIELD_BT;
                                     break;
                                 default:
                                     avpriv_request_sample(mxf->fc,
                                                           ""Field dominance %d support"",
                                                           descriptor->field_dominance);
                             }
                         }
                     }
                     st->codecpar->height *= 2;
                     break;
                 default:
                     av_log(mxf->fc, AV_LOG_INFO, ""Unknown frame layout type: %d\n"", descriptor->frame_layout);
             }
             if (st->codecpar->codec_id == AV_CODEC_ID_RAWVIDEO) {
                 st->codecpar->format = descriptor->pix_fmt;
                 if (st->codecpar->format == AV_PIX_FMT_NONE) {
                     pix_fmt_ul = mxf_get_codec_ul(ff_mxf_pixel_format_uls,
                                                   &descriptor->essence_codec_ul);
                     st->codecpar->format = (enum AVPixelFormat)pix_fmt_ul->id;
                     if (st->codecpar->format== AV_PIX_FMT_NONE) {
                         st->codecpar->codec_tag = mxf_get_codec_ul(ff_mxf_codec_tag_uls,
                                                                    &descriptor->essence_codec_ul)->id;
                         if (!st->codecpar->codec_tag) {
                             if (descriptor->horiz_subsampling == 2 &&
                                 descriptor->vert_subsampling == 1 &&
                                 descriptor->component_depth == 8) {
                                 st->codecpar->format = AV_PIX_FMT_UYVY422;
                             }
                         }
                     }
                 }
             }
             st->need_parsing = AVSTREAM_PARSE_HEADERS;
             if (material_track->sequence->origin) {
                 av_dict_set_int(&st->metadata, ""material_track_origin"", material_track->sequence->origin, 0);
             }
             if (source_track->sequence->origin) {
                 av_dict_set_int(&st->metadata, ""source_track_origin"", source_track->sequence->origin, 0);
             }
             if (descriptor->aspect_ratio.num && descriptor->aspect_ratio.den)
                 st->display_aspect_ratio = descriptor->aspect_ratio;
         } else if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {
             container_ul = mxf_get_codec_ul(mxf_sound_essence_container_uls, essence_container_ul);
             if (st->codecpar->codec_id == AV_CODEC_ID_NONE || (st->codecpar->codec_id == AV_CODEC_ID_PCM_ALAW && (enum AVCodecID)container_ul->id != AV_CODEC_ID_NONE))
                 st->codecpar->codec_id = (enum AVCodecID)container_ul->id;
             st->codecpar->channels = descriptor->channels;
             st->codecpar->bits_per_coded_sample = descriptor->bits_per_sample;
             if (descriptor->sample_rate.den > 0) {
                 st->codecpar->sample_rate = descriptor->sample_rate.num / descriptor->sample_rate.den;
                 avpriv_set_pts_info(st, 64, descriptor->sample_rate.den, descriptor->sample_rate.num);
             } else {
                 av_log(mxf->fc, AV_LOG_WARNING, ""invalid sample rate (%d/%d) ""
                        ""found for stream #%d, time base forced to 1/48000\n"",
                        descriptor->sample_rate.num, descriptor->sample_rate.den,
                        st->index);
                 avpriv_set_pts_info(st, 64, 1, 48000);
             }
             if (st->duration != AV_NOPTS_VALUE)
                 st->duration = av_rescale_q(st->duration,
                                             av_inv_q(material_track->edit_rate),
                                             st->time_base);
             if (st->codecpar->codec_id == AV_CODEC_ID_PCM_S16LE) {
                 if (descriptor->bits_per_sample > 16 && descriptor->bits_per_sample <= 24)
                     st->codecpar->codec_id = AV_CODEC_ID_PCM_S24LE;
                 else if (descriptor->bits_per_sample == 32)
                     st->codecpar->codec_id = AV_CODEC_ID_PCM_S32LE;
             } else if (st->codecpar->codec_id == AV_CODEC_ID_PCM_S16BE) {
                 if (descriptor->bits_per_sample > 16 && descriptor->bits_per_sample <= 24)
                     st->codecpar->codec_id = AV_CODEC_ID_PCM_S24BE;
                 else if (descriptor->bits_per_sample == 32)
                     st->codecpar->codec_id = AV_CODEC_ID_PCM_S32BE;
             } else if (st->codecpar->codec_id == AV_CODEC_ID_MP2) {
                 st->need_parsing = AVSTREAM_PARSE_FULL;
             }
         } else if (st->codecpar->codec_type == AVMEDIA_TYPE_DATA) {
             enum AVMediaType type;
             container_ul = mxf_get_codec_ul(mxf_data_essence_container_uls, essence_container_ul);
             if (st->codecpar->codec_id == AV_CODEC_ID_NONE)
                 st->codecpar->codec_id = container_ul->id;
             type = avcodec_get_type(st->codecpar->codec_id);
             if (type == AVMEDIA_TYPE_SUBTITLE)
                 st->codecpar->codec_type = type;
             if (container_ul->desc)
                 av_dict_set(&st->metadata, ""data_type"", container_ul->desc, 0);
         }
         if (descriptor->extradata) {
             if (!ff_alloc_extradata(st->codecpar, descriptor->extradata_size)) {
                 memcpy(st->codecpar->extradata, descriptor->extradata, descriptor->extradata_size);
             }
         } else if (st->codecpar->codec_id == AV_CODEC_ID_H264) {
             int coded_width = mxf_get_codec_ul(mxf_intra_only_picture_coded_width,
                                                &descriptor->essence_codec_ul)->id;
             if (coded_width)
                 st->codecpar->width = coded_width;
             ret = ff_generate_avci_extradata(st);
             if (ret < 0)
                 return ret;
         }
         if (st->codecpar->codec_type != AVMEDIA_TYPE_DATA && source_track->wrapping != FrameWrapped) {
             st->need_parsing = AVSTREAM_PARSE_TIMESTAMPS;
         }
     }
     ret = 0;
 fail_and_free:
     return ret;
 }","[89, 90]",FFmpeg before commit bab0716c7f4793ec42e05a5aa7e80d82a0dd4e75 contains an out of array access vulnerability in MXF format demuxer that can result in DoS. This attack appear to be exploitable via specially crafted MXF file which has to be provided as input. This vulnerability appears to have been fixed in bab0716c7f4793ec42e05a5aa7e80d82a0dd4e75 and later.,FFmpeg,CVE-2018-1999014,CWE-125
2139,181647,"  void *jas_realloc(void *ptr, size_t size)
  {
  	void *result;
	JAS_DBGLOG(101, (""jas_realloc called with %x,%zu\n"", ptr, size));
 	JAS_DBGLOG(101, (""jas_realloc(%x, %zu)\n"", ptr, size));
  	result = realloc(ptr, size);
  	JAS_DBGLOG(100, (""jas_realloc(%p, %zu) -> %p\n"", ptr, size, result));
  	return result;
 }","[4, 5]","Integer overflow in the jpc_dec_tiledecode function in jpc_dec.c in JasPer before 1.900.12 allows remote attackers to have unspecified impact via a crafted image file, which triggers a heap-based buffer overflow.",jasper,CVE-2016-10249,CWE-190
2140,182063,"  QualifyIpPacket(IPHeader *pIpHeader, ULONG len)
  {
      tTcpIpPacketParsingResult res;
     res.value = 0;
     if (len < 4)
     {
         res.ipStatus = ppresNotIP;
         return res;
     }
      UCHAR  ver_len = pIpHeader->v4.ip_verlen;
      UCHAR  ip_version = (ver_len & 0xF0) >> 4;
      USHORT ipHeaderSize = 0;
      USHORT fullLength = 0;
      res.value = 0;
      if (ip_version == 4)
      {
         if (len < sizeof(IPv4Header))
         {
             res.ipStatus = ppresNotIP;
             return res;
         }
          ipHeaderSize = (ver_len & 0xF) << 2;
          fullLength = swap_short(pIpHeader->v4.ip_length);
        DPrintf(3, (""ip_version %d, ipHeaderSize %d, protocol %d, iplen %d\n"",
            ip_version, ipHeaderSize, pIpHeader->v4.ip_protocol, fullLength));
         DPrintf(3, (""ip_version %d, ipHeaderSize %d, protocol %d, iplen %d, L2 payload length %d\n"",
             ip_version, ipHeaderSize, pIpHeader->v4.ip_protocol, fullLength, len));
          res.ipStatus = (ipHeaderSize >= sizeof(IPv4Header)) ? ppresIPV4 : ppresNotIP;
        if (len < ipHeaderSize) res.ipCheckSum = ppresIPTooShort;
        if (fullLength) {}
        else
         if (res.ipStatus == ppresNotIP)
          {
            DPrintf(2, (""ip v.%d, iplen %d\n"", ip_version, fullLength));
             return res;
         }
         if (ipHeaderSize >= fullLength || len < fullLength)
         {
             DPrintf(2, (""[%s] - truncated packet - ip_version %d, ipHeaderSize %d, protocol %d, iplen %d, L2 payload length %d\n"",
                 ip_version, ipHeaderSize, pIpHeader->v4.ip_protocol, fullLength, len));
             res.ipCheckSum = ppresIPTooShort;
             return res;
          }
      }
      else if (ip_version == 6)
     {
         UCHAR nextHeader = pIpHeader->v6.ip6_next_header;
         BOOLEAN bParsingDone = FALSE;
         ipHeaderSize = sizeof(pIpHeader->v6);
         res.ipStatus = ppresIPV6;
         res.ipCheckSum = ppresCSOK;
         fullLength = swap_short(pIpHeader->v6.ip6_payload_len);
         fullLength += ipHeaderSize;
         while (nextHeader != 59)
         {
             IPv6ExtHeader *pExt;
             switch (nextHeader)
             {
                 case PROTOCOL_TCP:
                     bParsingDone = TRUE;
                     res.xxpStatus = ppresXxpKnown;
                     res.TcpUdp = ppresIsTCP;
                     res.xxpFull = len >= fullLength ? 1 : 0;
                     res = ProcessTCPHeader(res, pIpHeader, len, ipHeaderSize);
                     break;
                 case PROTOCOL_UDP:
                     bParsingDone = TRUE;
                     res.xxpStatus = ppresXxpKnown;
                     res.TcpUdp = ppresIsUDP;
                     res.xxpFull = len >= fullLength ? 1 : 0;
                     res = ProcessUDPHeader(res, pIpHeader, len, ipHeaderSize);
                     break;
                 case 0:
                 case 60:
                 case 43:
                 case 44:
                 case 51:
                 case 50:
                 case 135:
                     if (len >= ((ULONG)ipHeaderSize + 8))
                     {
                         pExt = (IPv6ExtHeader *)((PUCHAR)pIpHeader + ipHeaderSize);
                         nextHeader = pExt->ip6ext_next_header;
                         ipHeaderSize += 8;
                         ipHeaderSize += pExt->ip6ext_hdr_len * 8;
                     }
                     else
                     {
                         DPrintf(0, (""[%s] ERROR: Break in the middle of ext. headers(len %d, hdr > %d)\n"", __FUNCTION__, len, ipHeaderSize));
                         res.ipStatus = ppresNotIP;
                         bParsingDone = TRUE;
                     }
                     break;
                 default:
                     res.xxpStatus = ppresXxpOther;
                     bParsingDone = TRUE;
                     break;
             }
             if (bParsingDone)
                 break;
         }
         if (ipHeaderSize <= MAX_SUPPORTED_IPV6_HEADERS)
         {
             DPrintf(3, (""ip_version %d, ipHeaderSize %d, protocol %d, iplen %d\n"",
                 ip_version, ipHeaderSize, nextHeader, fullLength));
             res.ipHeaderSize = ipHeaderSize;
         }
         else
         {
             DPrintf(0, (""[%s] ERROR: IP chain is too large (%d)\n"", __FUNCTION__, ipHeaderSize));
             res.ipStatus = ppresNotIP;
         }
     }
      if (res.ipStatus == ppresIPV4)
      {
          res.ipHeaderSize = ipHeaderSize;
        res.xxpFull = len >= fullLength ? 1 : 0;
          res.IsFragment = (pIpHeader->v4.ip_offset & ~0xC0) != 0;
          switch (pIpHeader->v4.ip_protocol)
         {
             case PROTOCOL_TCP:
             {
                 res = ProcessTCPHeader(res, pIpHeader, len, ipHeaderSize);
             }
             break;
         case PROTOCOL_UDP:
             {
                 res = ProcessUDPHeader(res, pIpHeader, len, ipHeaderSize);
             }
             break;
         default:
             res.xxpStatus = ppresXxpOther;
             break;
         }
     }
     return res;
 }","[4, 5, 6, 7, 8, 9, 17, 18, 19, 20, 21, 24, 25, 26, 27, 29, 30, 31, 32, 34, 35, 36, 37, 38, 39, 40, 41, 42, 117]","The NetKVM Windows Virtio driver allows remote attackers to cause a denial of service (guest crash) via a crafted length value in an IP packet, as demonstrated by a value that does not account for the size of the IP options.",kvm-guest-drivers-windows,CVE-2015-3215,CWE-20
2160,181244," static int vp8_lossy_decode_frame(AVCodecContext *avctx, AVFrame *p,
                                   int *got_frame, uint8_t *data_start,
                                   unsigned int data_size)
 {
     WebPContext *s = avctx->priv_data;
     AVPacket pkt;
     int ret;
      if (!s->initialized) {
          ff_vp8_decode_init(avctx);
          s->initialized = 1;
        if (s->has_alpha)
            avctx->pix_fmt = AV_PIX_FMT_YUVA420P;
      }
     avctx->pix_fmt = s->has_alpha ? AV_PIX_FMT_YUVA420P : AV_PIX_FMT_YUV420P;
      s->lossless = 0;
      if (data_size > INT_MAX) {
         av_log(avctx, AV_LOG_ERROR, ""unsupported chunk size\n"");
         return AVERROR_PATCHWELCOME;
     }
     av_init_packet(&pkt);
     pkt.data = data_start;
     pkt.size = data_size;
     ret = ff_vp8_decode_frame(avctx, p, got_frame, &pkt);
     if (ret < 0)
         return ret;
     update_canvas_size(avctx, avctx->width, avctx->height);
     if (s->has_alpha) {
         ret = vp8_lossy_decode_alpha(avctx, p, s->alpha_data,
                                      s->alpha_data_size);
         if (ret < 0)
             return ret;
     }
     return ret;
 }","[11, 12, 14]","libavcodec/webp.c in FFmpeg before 2.8.12, 3.0.x before 3.0.8, 3.1.x before 3.1.8, 3.2.x before 3.2.5, and 3.3.x before 3.3.1 does not ensure that pix_fmt is set, which allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted file, related to the vp8_decode_mb_row_no_filter and pred8x8_128_dc_8_c functions.",FFmpeg,CVE-2017-9994,CWE-119
2167,181546," yyparse (void *yyscanner, YR_COMPILER* compiler)
 {
 int yychar;
 YY_INITIAL_VALUE (static YYSTYPE yyval_default;)
 YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
     int yynerrs;
     int yystate;
     int yyerrstatus;
     yytype_int16 yyssa[YYINITDEPTH];
     yytype_int16 *yyss;
     yytype_int16 *yyssp;
     YYSTYPE yyvsa[YYINITDEPTH];
     YYSTYPE *yyvs;
     YYSTYPE *yyvsp;
     YYSIZE_T yystacksize;
   int yyn;
   int yyresult;
   int yytoken = 0;
   YYSTYPE yyval;
 #if YYERROR_VERBOSE
   char yymsgbuf[128];
   char *yymsg = yymsgbuf;
   YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
 #endif
 #define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
   int yylen = 0;
   yyssp = yyss = yyssa;
   yyvsp = yyvs = yyvsa;
   yystacksize = YYINITDEPTH;
   YYDPRINTF ((stderr, ""Starting parse\n""));
   yystate = 0;
   yyerrstatus = 0;
   yynerrs = 0;
   yychar = YYEMPTY;  
   goto yysetstate;
  yynewstate:
   yyssp++;
  yysetstate:
   *yyssp = yystate;
   if (yyss + yystacksize - 1 <= yyssp)
     {
       YYSIZE_T yysize = yyssp - yyss + 1;
 #ifdef yyoverflow
       {
         YYSTYPE *yyvs1 = yyvs;
         yytype_int16 *yyss1 = yyss;
         yyoverflow (YY_(""memory exhausted""),
                     &yyss1, yysize * sizeof (*yyssp),
                     &yyvs1, yysize * sizeof (*yyvsp),
                     &yystacksize);
         yyss = yyss1;
         yyvs = yyvs1;
       }
 #else  
 # ifndef YYSTACK_RELOCATE
       goto yyexhaustedlab;
 # else
       if (YYMAXDEPTH <= yystacksize)
         goto yyexhaustedlab;
       yystacksize *= 2;
       if (YYMAXDEPTH < yystacksize)
         yystacksize = YYMAXDEPTH;
       {
         yytype_int16 *yyss1 = yyss;
         union yyalloc *yyptr =
           (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
         if (! yyptr)
           goto yyexhaustedlab;
         YYSTACK_RELOCATE (yyss_alloc, yyss);
         YYSTACK_RELOCATE (yyvs_alloc, yyvs);
 #  undef YYSTACK_RELOCATE
         if (yyss1 != yyssa)
           YYSTACK_FREE (yyss1);
       }
 # endif
 #endif  
       yyssp = yyss + yysize - 1;
       yyvsp = yyvs + yysize - 1;
       YYDPRINTF ((stderr, ""Stack size increased to %lu\n"",
                   (unsigned long int) yystacksize));
       if (yyss + yystacksize - 1 <= yyssp)
         YYABORT;
     }
   YYDPRINTF ((stderr, ""Entering state %d\n"", yystate));
   if (yystate == YYFINAL)
     YYACCEPT;
   goto yybackup;
 yybackup:
   yyn = yypact[yystate];
   if (yypact_value_is_default (yyn))
     goto yydefault;
   if (yychar == YYEMPTY)
     {
       YYDPRINTF ((stderr, ""Reading a token: ""));
       yychar = yylex (&yylval, yyscanner, compiler);
     }
   if (yychar <= YYEOF)
     {
       yychar = yytoken = YYEOF;
       YYDPRINTF ((stderr, ""Now at end of input.\n""));
     }
   else
     {
       yytoken = YYTRANSLATE (yychar);
       YY_SYMBOL_PRINT (""Next token is"", yytoken, &yylval, &yylloc);
     }
   yyn += yytoken;
   if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
     goto yydefault;
   yyn = yytable[yyn];
   if (yyn <= 0)
     {
       if (yytable_value_is_error (yyn))
         goto yyerrlab;
       yyn = -yyn;
       goto yyreduce;
     }
   if (yyerrstatus)
     yyerrstatus--;
   YY_SYMBOL_PRINT (""Shifting"", yytoken, &yylval, &yylloc);
   yychar = YYEMPTY;
   yystate = yyn;
   YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
   *++yyvsp = yylval;
   YY_IGNORE_MAYBE_UNINITIALIZED_END
   goto yynewstate;
 yydefault:
   yyn = yydefact[yystate];
   if (yyn == 0)
     goto yyerrlab;
   goto yyreduce;
 yyreduce:
   yylen = yyr2[yyn];
   yyval = yyvsp[1-yylen];
   YY_REDUCE_PRINT (yyn);
   switch (yyn)
     {
         case 8:
 #line 230 ""grammar.y""  
     {
         int result = yr_parser_reduce_import(yyscanner, (yyvsp[0].sized_string));
         yr_free((yyvsp[0].sized_string));
         ERROR_IF(result != ERROR_SUCCESS);
       }
 #line 1661 ""grammar.c""  
     break;
   case 9:
 #line 242 ""grammar.y""  
     {
         YR_RULE* rule = yr_parser_reduce_rule_declaration_phase_1(
             yyscanner, (int32_t) (yyvsp[-2].integer), (yyvsp[0].c_string));
         ERROR_IF(rule == NULL);
         (yyval.rule) = rule;
       }
 #line 1674 ""grammar.c""  
     break;
   case 10:
 #line 251 ""grammar.y""  
     {
         YR_RULE* rule = (yyvsp[-4].rule);  
         rule->tags = (yyvsp[-3].c_string);
         rule->metas = (yyvsp[-1].meta);
         rule->strings = (yyvsp[0].string);
       }
 #line 1686 ""grammar.c""  
     break;
   case 11:
 #line 259 ""grammar.y""  
     {
         YR_RULE* rule = (yyvsp[-7].rule);  
         compiler->last_result = yr_parser_reduce_rule_declaration_phase_2(
             yyscanner, rule);
         yr_free((yyvsp[-8].c_string));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
 #line 1701 ""grammar.c""  
     break;
   case 12:
 #line 274 ""grammar.y""  
     {
         (yyval.meta) = NULL;
       }
 #line 1709 ""grammar.c""  
     break;
   case 13:
 #line 278 ""grammar.y""  
     {
         YR_META null_meta;
         memset(&null_meta, 0xFF, sizeof(YR_META));
         null_meta.type = META_TYPE_NULL;
         compiler->last_result = yr_arena_write_data(
             compiler->metas_arena,
             &null_meta,
             sizeof(YR_META),
             NULL);
         (yyval.meta) = (yyvsp[0].meta);
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
 #line 1736 ""grammar.c""  
     break;
   case 14:
 #line 305 ""grammar.y""  
     {
         (yyval.string) = NULL;
       }
 #line 1744 ""grammar.c""  
     break;
   case 15:
 #line 309 ""grammar.y""  
     {
         YR_STRING null_string;
         memset(&null_string, 0xFF, sizeof(YR_STRING));
         null_string.g_flags = STRING_GFLAGS_NULL;
         compiler->last_result = yr_arena_write_data(
             compiler->strings_arena,
             &null_string,
             sizeof(YR_STRING),
             NULL);
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         (yyval.string) = (yyvsp[0].string);
       }
 #line 1771 ""grammar.c""  
     break;
   case 17:
 #line 340 ""grammar.y""  
     { (yyval.integer) = 0;  }
 #line 1777 ""grammar.c""  
     break;
   case 18:
 #line 341 ""grammar.y""  
     { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }
 #line 1783 ""grammar.c""  
     break;
   case 19:
 #line 346 ""grammar.y""  
     { (yyval.integer) = RULE_GFLAGS_PRIVATE; }
 #line 1789 ""grammar.c""  
     break;
   case 20:
 #line 347 ""grammar.y""  
     { (yyval.integer) = RULE_GFLAGS_GLOBAL; }
 #line 1795 ""grammar.c""  
     break;
   case 21:
 #line 353 ""grammar.y""  
     {
         (yyval.c_string) = NULL;
       }
 #line 1803 ""grammar.c""  
     break;
   case 22:
 #line 357 ""grammar.y""  
     {
         compiler->last_result = yr_arena_write_string(
             yyget_extra(yyscanner)->sz_arena, """", NULL);
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         (yyval.c_string) = (yyvsp[0].c_string);
       }
 #line 1821 ""grammar.c""  
     break;
   case 23:
 #line 375 ""grammar.y""  
     {
         char* identifier;
         compiler->last_result = yr_arena_write_string(
             yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), &identifier);
         yr_free((yyvsp[0].c_string));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         (yyval.c_string) = identifier;
       }
 #line 1838 ""grammar.c""  
     break;
   case 24:
 #line 388 ""grammar.y""  
     {
         char* tag_name = (yyvsp[-1].c_string);
         size_t tag_length = tag_name != NULL ? strlen(tag_name) : 0;
         while (tag_length > 0)
         {
           if (strcmp(tag_name, (yyvsp[0].c_string)) == 0)
           {
             yr_compiler_set_error_extra_info(compiler, tag_name);
             compiler->last_result = ERROR_DUPLICATED_TAG_IDENTIFIER;
             break;
           }
           tag_name = (char*) yr_arena_next_address(
               yyget_extra(yyscanner)->sz_arena,
               tag_name,
               tag_length + 1);
           tag_length = tag_name != NULL ? strlen(tag_name) : 0;
         }
         if (compiler->last_result == ERROR_SUCCESS)
           compiler->last_result = yr_arena_write_string(
               yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), NULL);
         yr_free((yyvsp[0].c_string));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         (yyval.c_string) = (yyvsp[-1].c_string);
       }
 #line 1874 ""grammar.c""  
     break;
   case 25:
 #line 424 ""grammar.y""  
     {  (yyval.meta) = (yyvsp[0].meta); }
 #line 1880 ""grammar.c""  
     break;
   case 26:
 #line 425 ""grammar.y""  
     {  (yyval.meta) = (yyvsp[-1].meta); }
 #line 1886 ""grammar.c""  
     break;
   case 27:
 #line 431 ""grammar.y""  
     {
         SIZED_STRING* sized_string = (yyvsp[0].sized_string);
         (yyval.meta) = yr_parser_reduce_meta_declaration(
             yyscanner,
             META_TYPE_STRING,
             (yyvsp[-2].c_string),
             sized_string->c_string,
             0);
         yr_free((yyvsp[-2].c_string));
         yr_free((yyvsp[0].sized_string));
         ERROR_IF((yyval.meta) == NULL);
       }
 #line 1906 ""grammar.c""  
     break;
   case 28:
 #line 447 ""grammar.y""  
     {
         (yyval.meta) = yr_parser_reduce_meta_declaration(
             yyscanner,
             META_TYPE_INTEGER,
             (yyvsp[-2].c_string),
             NULL,
             (yyvsp[0].integer));
         yr_free((yyvsp[-2].c_string));
         ERROR_IF((yyval.meta) == NULL);
       }
 #line 1923 ""grammar.c""  
     break;
   case 29:
 #line 460 ""grammar.y""  
     {
         (yyval.meta) = yr_parser_reduce_meta_declaration(
             yyscanner,
             META_TYPE_INTEGER,
             (yyvsp[-3].c_string),
             NULL,
             -(yyvsp[0].integer));
         yr_free((yyvsp[-3].c_string));
         ERROR_IF((yyval.meta) == NULL);
       }
 #line 1940 ""grammar.c""  
     break;
   case 30:
 #line 473 ""grammar.y""  
     {
         (yyval.meta) = yr_parser_reduce_meta_declaration(
             yyscanner,
             META_TYPE_BOOLEAN,
             (yyvsp[-2].c_string),
             NULL,
             TRUE);
         yr_free((yyvsp[-2].c_string));
         ERROR_IF((yyval.meta) == NULL);
       }
 #line 1957 ""grammar.c""  
     break;
   case 31:
 #line 486 ""grammar.y""  
     {
         (yyval.meta) = yr_parser_reduce_meta_declaration(
             yyscanner,
             META_TYPE_BOOLEAN,
             (yyvsp[-2].c_string),
             NULL,
             FALSE);
         yr_free((yyvsp[-2].c_string));
         ERROR_IF((yyval.meta) == NULL);
       }
 #line 1974 ""grammar.c""  
     break;
   case 32:
 #line 502 ""grammar.y""  
     { (yyval.string) = (yyvsp[0].string); }
 #line 1980 ""grammar.c""  
     break;
   case 33:
 #line 503 ""grammar.y""  
     { (yyval.string) = (yyvsp[-1].string); }
 #line 1986 ""grammar.c""  
     break;
   case 34:
 #line 509 ""grammar.y""  
     {
         compiler->error_line = yyget_lineno(yyscanner);
       }
 #line 1994 ""grammar.c""  
     break;
   case 35:
 #line 513 ""grammar.y""  
     {
         (yyval.string) = yr_parser_reduce_string_declaration(
             yyscanner, (int32_t) (yyvsp[0].integer), (yyvsp[-4].c_string), (yyvsp[-1].sized_string));
         yr_free((yyvsp[-4].c_string));
         yr_free((yyvsp[-1].sized_string));
         ERROR_IF((yyval.string) == NULL);
         compiler->error_line = 0;
       }
 #line 2009 ""grammar.c""  
     break;
   case 36:
 #line 524 ""grammar.y""  
     {
         compiler->error_line = yyget_lineno(yyscanner);
       }
 #line 2017 ""grammar.c""  
     break;
   case 37:
 #line 528 ""grammar.y""  
     {
         (yyval.string) = yr_parser_reduce_string_declaration(
             yyscanner, (int32_t) (yyvsp[0].integer) | STRING_GFLAGS_REGEXP, (yyvsp[-4].c_string), (yyvsp[-1].sized_string));
         yr_free((yyvsp[-4].c_string));
         yr_free((yyvsp[-1].sized_string));
         ERROR_IF((yyval.string) == NULL);
         compiler->error_line = 0;
       }
 #line 2033 ""grammar.c""  
     break;
   case 38:
 #line 540 ""grammar.y""  
     {
         (yyval.string) = yr_parser_reduce_string_declaration(
             yyscanner, STRING_GFLAGS_HEXADECIMAL, (yyvsp[-2].c_string), (yyvsp[0].sized_string));
         yr_free((yyvsp[-2].c_string));
         yr_free((yyvsp[0].sized_string));
         ERROR_IF((yyval.string) == NULL);
       }
 #line 2047 ""grammar.c""  
     break;
   case 39:
 #line 553 ""grammar.y""  
     { (yyval.integer) = 0; }
 #line 2053 ""grammar.c""  
     break;
   case 40:
 #line 554 ""grammar.y""  
     { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }
 #line 2059 ""grammar.c""  
     break;
   case 41:
 #line 559 ""grammar.y""  
     { (yyval.integer) = STRING_GFLAGS_WIDE; }
 #line 2065 ""grammar.c""  
     break;
   case 42:
 #line 560 ""grammar.y""  
     { (yyval.integer) = STRING_GFLAGS_ASCII; }
 #line 2071 ""grammar.c""  
     break;
   case 43:
 #line 561 ""grammar.y""  
     { (yyval.integer) = STRING_GFLAGS_NO_CASE; }
 #line 2077 ""grammar.c""  
     break;
   case 44:
 #line 562 ""grammar.y""  
     { (yyval.integer) = STRING_GFLAGS_FULL_WORD; }
 #line 2083 ""grammar.c""  
     break;
   case 45:
 #line 568 ""grammar.y""  
     {
         int var_index = yr_parser_lookup_loop_variable(yyscanner, (yyvsp[0].c_string));
         if (var_index >= 0)
         {
           compiler->last_result = yr_parser_emit_with_arg(
               yyscanner,
               OP_PUSH_M,
               LOOP_LOCAL_VARS * var_index,
               NULL,
               NULL);
           (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
           (yyval.expression).value.integer = UNDEFINED;
           (yyval.expression).identifier = compiler->loop_identifier[var_index];
         }
         else
         {
           YR_OBJECT* object = (YR_OBJECT*) yr_hash_table_lookup(
               compiler->objects_table, (yyvsp[0].c_string), NULL);
           if (object == NULL)
           {
             char* ns = compiler->current_namespace->name;
             object = (YR_OBJECT*) yr_hash_table_lookup(
                 compiler->objects_table, (yyvsp[0].c_string), ns);
           }
           if (object != NULL)
           {
             char* id;
             compiler->last_result = yr_arena_write_string(
                 compiler->sz_arena, (yyvsp[0].c_string), &id);
             if (compiler->last_result == ERROR_SUCCESS)
               compiler->last_result = yr_parser_emit_with_arg_reloc(
                   yyscanner,
                   OP_OBJ_LOAD,
                   id,
                   NULL,
                   NULL);
             (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
             (yyval.expression).value.object = object;
             (yyval.expression).identifier = object->identifier;
           }
           else
           {
             YR_RULE* rule = (YR_RULE*) yr_hash_table_lookup(
                 compiler->rules_table,
                 (yyvsp[0].c_string),
                 compiler->current_namespace->name);
             if (rule != NULL)
             {
               compiler->last_result = yr_parser_emit_with_arg_reloc(
                   yyscanner,
                   OP_PUSH_RULE,
                   rule,
                   NULL,
                   NULL);
               (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
               (yyval.expression).value.integer = UNDEFINED;
               (yyval.expression).identifier = rule->identifier;
             }
             else
             {
               yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
               compiler->last_result = ERROR_UNDEFINED_IDENTIFIER;
             }
           }
         }
         yr_free((yyvsp[0].c_string));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
 #line 2172 ""grammar.c""  
     break;
   case 46:
 #line 653 ""grammar.y""  
     {
         YR_OBJECT* field = NULL;
         if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_OBJECT &&
             (yyvsp[-2].expression).value.object->type == OBJECT_TYPE_STRUCTURE)
         {
           field = yr_object_lookup_field((yyvsp[-2].expression).value.object, (yyvsp[0].c_string));
           if (field != NULL)
           {
             char* ident;
             compiler->last_result = yr_arena_write_string(
               compiler->sz_arena, (yyvsp[0].c_string), &ident);
             if (compiler->last_result == ERROR_SUCCESS)
               compiler->last_result = yr_parser_emit_with_arg_reloc(
                   yyscanner,
                   OP_OBJ_FIELD,
                   ident,
                   NULL,
                   NULL);
             (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
             (yyval.expression).value.object = field;
             (yyval.expression).identifier = field->identifier;
           }
           else
           {
             yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
             compiler->last_result = ERROR_INVALID_FIELD_NAME;
           }
         }
         else
         {
           yr_compiler_set_error_extra_info(
               compiler, (yyvsp[-2].expression).identifier);
           compiler->last_result = ERROR_NOT_A_STRUCTURE;
         }
         yr_free((yyvsp[0].c_string));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
 #line 2222 ""grammar.c""  
     break;
   case 47:
 #line 699 ""grammar.y""  
     {
         YR_OBJECT_ARRAY* array;
         YR_OBJECT_DICTIONARY* dict;
         if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
             (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_ARRAY)
         {
           if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)
           {
             yr_compiler_set_error_extra_info(
                 compiler, ""array indexes must be of integer type"");
             compiler->last_result = ERROR_WRONG_TYPE;
           }
           ERROR_IF(compiler->last_result != ERROR_SUCCESS);
           compiler->last_result = yr_parser_emit(
               yyscanner, OP_INDEX_ARRAY, NULL);
           array = (YR_OBJECT_ARRAY*) (yyvsp[-3].expression).value.object;
           (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
           (yyval.expression).value.object = array->prototype_item;
           (yyval.expression).identifier = array->identifier;
         }
         else if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
                  (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_DICTIONARY)
         {
           if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_STRING)
           {
             yr_compiler_set_error_extra_info(
                 compiler, ""dictionary keys must be of string type"");
             compiler->last_result = ERROR_WRONG_TYPE;
           }
           ERROR_IF(compiler->last_result != ERROR_SUCCESS);
           compiler->last_result = yr_parser_emit(
               yyscanner, OP_LOOKUP_DICT, NULL);
           dict = (YR_OBJECT_DICTIONARY*) (yyvsp[-3].expression).value.object;
           (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
           (yyval.expression).value.object = dict->prototype_item;
           (yyval.expression).identifier = dict->identifier;
         }
         else
         {
           yr_compiler_set_error_extra_info(
               compiler, (yyvsp[-3].expression).identifier);
           compiler->last_result = ERROR_NOT_INDEXABLE;
         }
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
 #line 2283 ""grammar.c""  
     break;
   case 48:
 #line 757 ""grammar.y""  
     {
         YR_OBJECT_FUNCTION* function;
         char* args_fmt;
         if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
             (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_FUNCTION)
         {
           compiler->last_result = yr_parser_check_types(
               compiler, (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object, (yyvsp[-1].c_string));
           if (compiler->last_result == ERROR_SUCCESS)
             compiler->last_result = yr_arena_write_string(
               compiler->sz_arena, (yyvsp[-1].c_string), &args_fmt);
           if (compiler->last_result == ERROR_SUCCESS)
             compiler->last_result = yr_parser_emit_with_arg_reloc(
                 yyscanner,
                 OP_CALL,
                 args_fmt,
                 NULL,
                 NULL);
           function = (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object;
           (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
           (yyval.expression).value.object = function->return_obj;
           (yyval.expression).identifier = function->identifier;
         }
         else
         {
           yr_compiler_set_error_extra_info(
               compiler, (yyvsp[-3].expression).identifier);
           compiler->last_result = ERROR_NOT_A_FUNCTION;
         }
         yr_free((yyvsp[-1].c_string));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
 #line 2328 ""grammar.c""  
     break;
   case 49:
 #line 801 ""grammar.y""  
     { (yyval.c_string) = yr_strdup(""""); }
 #line 2334 ""grammar.c""  
     break;
   case 50:
 #line 802 ""grammar.y""  
     { (yyval.c_string) = (yyvsp[0].c_string); }
 #line 2340 ""grammar.c""  
     break;
   case 51:
 #line 807 ""grammar.y""  
     {
         (yyval.c_string) = (char*) yr_malloc(MAX_FUNCTION_ARGS + 1);
         switch((yyvsp[0].expression).type)
         {
           case EXPRESSION_TYPE_INTEGER:
             strlcpy((yyval.c_string), ""i"", MAX_FUNCTION_ARGS);
             break;
           case EXPRESSION_TYPE_FLOAT:
             strlcpy((yyval.c_string), ""f"", MAX_FUNCTION_ARGS);
             break;
           case EXPRESSION_TYPE_BOOLEAN:
             strlcpy((yyval.c_string), ""b"", MAX_FUNCTION_ARGS);
             break;
           case EXPRESSION_TYPE_STRING:
             strlcpy((yyval.c_string), ""s"", MAX_FUNCTION_ARGS);
             break;
            case EXPRESSION_TYPE_REGEXP:
              strlcpy((yyval.c_string), ""r"", MAX_FUNCTION_ARGS);
              break;
           default:
             assert(FALSE);
          }
          ERROR_IF((yyval.c_string) == NULL);
        }
#line 2369 ""grammar.c""  
 #line 2371 ""grammar.c""  
      break;
    case 52:
#line 832 ""grammar.y""  
 #line 834 ""grammar.y""  
      {
          if (strlen((yyvsp[-2].c_string)) == MAX_FUNCTION_ARGS)
          {
           compiler->last_result = ERROR_TOO_MANY_ARGUMENTS;
         }
         else
         {
           switch((yyvsp[0].expression).type)
           {
             case EXPRESSION_TYPE_INTEGER:
               strlcat((yyvsp[-2].c_string), ""i"", MAX_FUNCTION_ARGS);
               break;
             case EXPRESSION_TYPE_FLOAT:
               strlcat((yyvsp[-2].c_string), ""f"", MAX_FUNCTION_ARGS);
               break;
             case EXPRESSION_TYPE_BOOLEAN:
               strlcat((yyvsp[-2].c_string), ""b"", MAX_FUNCTION_ARGS);
               break;
             case EXPRESSION_TYPE_STRING:
               strlcat((yyvsp[-2].c_string), ""s"", MAX_FUNCTION_ARGS);
               break;
              case EXPRESSION_TYPE_REGEXP:
                strlcat((yyvsp[-2].c_string), ""r"", MAX_FUNCTION_ARGS);
                break;
             default:
               assert(FALSE);
            }
          }
          ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          (yyval.c_string) = (yyvsp[-2].c_string);
        }
#line 2405 ""grammar.c""  
 #line 2409 ""grammar.c""  
      break;
    case 53:
#line 868 ""grammar.y""  
 #line 872 ""grammar.y""  
      {
          SIZED_STRING* sized_string = (yyvsp[0].sized_string);
          RE* re;
         RE_ERROR error;
         int re_flags = 0;
         if (sized_string->flags & SIZED_STRING_FLAGS_NO_CASE)
           re_flags |= RE_FLAGS_NO_CASE;
         if (sized_string->flags & SIZED_STRING_FLAGS_DOT_ALL)
           re_flags |= RE_FLAGS_DOT_ALL;
         compiler->last_result = yr_re_compile(
             sized_string->c_string,
             re_flags,
             compiler->re_code_arena,
             &re,
             &error);
         yr_free((yyvsp[0].sized_string));
         if (compiler->last_result == ERROR_INVALID_REGULAR_EXPRESSION)
           yr_compiler_set_error_extra_info(compiler, error.message);
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         if (compiler->last_result == ERROR_SUCCESS)
           compiler->last_result = yr_parser_emit_with_arg_reloc(
               yyscanner,
               OP_PUSH,
               re->root_node->forward_code,
               NULL,
               NULL);
         yr_re_destroy(re);
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          (yyval.expression).type = EXPRESSION_TYPE_REGEXP;
        }
#line 2451 ""grammar.c""  
 #line 2455 ""grammar.c""  
      break;
    case 54:
#line 914 ""grammar.y""  
 #line 918 ""grammar.y""  
      {
          if ((yyvsp[0].expression).type == EXPRESSION_TYPE_STRING)
          {
           if ((yyvsp[0].expression).value.sized_string != NULL)
           {
             yywarning(yyscanner,
               ""Using literal string \""%s\"" in a boolean operation."",
               (yyvsp[0].expression).value.sized_string->c_string);
           }
           compiler->last_result = yr_parser_emit(
               yyscanner, OP_STR_TO_BOOL, NULL);
           ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         }
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        }
#line 2474 ""grammar.c""  
 #line 2478 ""grammar.c""  
      break;
    case 55:
#line 936 ""grammar.y""  
 #line 940 ""grammar.y""  
      {
          compiler->last_result = yr_parser_emit_with_arg(
              yyscanner, OP_PUSH, 1, NULL, NULL);
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        }
#line 2487 ""grammar.c""  
 #line 2491 ""grammar.c""  
      break;
    case 56:
#line 945 ""grammar.y""  
 #line 949 ""grammar.y""  
      {
          compiler->last_result = yr_parser_emit_with_arg(
              yyscanner, OP_PUSH, 0, NULL, NULL);
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        }
#line 2500 ""grammar.c""  
 #line 2504 ""grammar.c""  
      break;
    case 57:
#line 954 ""grammar.y""  
 #line 958 ""grammar.y""  
      {
          CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, ""matches"");
          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_REGEXP, ""matches"");
         if (compiler->last_result == ERROR_SUCCESS)
           compiler->last_result = yr_parser_emit(
               yyscanner,
               OP_MATCHES,
               NULL);
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        }
#line 2519 ""grammar.c""  
 #line 2523 ""grammar.c""  
      break;
    case 58:
#line 969 ""grammar.y""  
 #line 973 ""grammar.y""  
      {
          CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, ""contains"");
          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_STRING, ""contains"");
         compiler->last_result = yr_parser_emit(
             yyscanner, OP_CONTAINS, NULL);
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        }
#line 2535 ""grammar.c""  
 #line 2539 ""grammar.c""  
      break;
    case 59:
#line 981 ""grammar.y""  
 #line 985 ""grammar.y""  
      {
          int result = yr_parser_reduce_string_identifier(
              yyscanner,
             (yyvsp[0].c_string),
             OP_FOUND,
             UNDEFINED);
         yr_free((yyvsp[0].c_string));
         ERROR_IF(result != ERROR_SUCCESS);
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        }
#line 2553 ""grammar.c""  
 #line 2557 ""grammar.c""  
      break;
    case 60:
#line 995 ""grammar.y""  
 #line 999 ""grammar.y""  
      {
          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""at"");
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[-2].c_string), OP_FOUND_AT, (yyvsp[0].expression).value.integer);
         yr_free((yyvsp[-2].c_string));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        }
#line 2570 ""grammar.c""  
 #line 2574 ""grammar.c""  
      break;
    case 61:
#line 1008 ""grammar.y""  
 #line 1012 ""grammar.y""  
      {
          compiler->last_result = yr_parser_reduce_string_identifier(
              yyscanner, (yyvsp[-2].c_string), OP_FOUND_IN, UNDEFINED);
         yr_free((yyvsp[-2].c_string));
         ERROR_IF(compiler->last_result!= ERROR_SUCCESS);
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        }
#line 2585 ""grammar.c""  
 #line 2589 ""grammar.c""  
      break;
    case 62:
#line 1019 ""grammar.y""  
 #line 1023 ""grammar.y""  
      {
          if (compiler->loop_depth > 0)
          {
            compiler->loop_depth--;
            compiler->loop_identifier[compiler->loop_depth] = NULL;
          }
         YYERROR;
        }
#line 2597 ""grammar.c""  
 #line 2603 ""grammar.c""  
      break;
    case 63:
#line 1027 ""grammar.y""  
 #line 1033 ""grammar.y""  
      {
          int var_index;
         if (compiler->loop_depth == MAX_LOOP_NESTING)
           compiler->last_result = \
               ERROR_LOOP_NESTING_LIMIT_EXCEEDED;
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         var_index = yr_parser_lookup_loop_variable(
             yyscanner, (yyvsp[-1].c_string));
         if (var_index >= 0)
         {
           yr_compiler_set_error_extra_info(
               compiler, (yyvsp[-1].c_string));
           compiler->last_result = \
               ERROR_DUPLICATED_LOOP_IDENTIFIER;
         }
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
          ERROR_IF(compiler->last_result != ERROR_SUCCESS);
        }
#line 2631 ""grammar.c""  
 #line 2637 ""grammar.c""  
      break;
    case 64:
#line 1057 ""grammar.y""  
 #line 1063 ""grammar.y""  
      {
          int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
          uint8_t* addr;
         yr_parser_emit_with_arg(
             yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);
         yr_parser_emit_with_arg(
             yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);
         if ((yyvsp[-1].integer) == INTEGER_SET_ENUMERATION)
         {
           yr_parser_emit_with_arg(
               yyscanner, OP_POP_M, mem_offset, &addr, NULL);
         }
         else  
         {
           yr_parser_emit_with_arg(
               yyscanner, OP_POP_M, mem_offset + 3, &addr, NULL);
           yr_parser_emit_with_arg(
               yyscanner, OP_POP_M, mem_offset, NULL, NULL);
         }
         compiler->loop_address[compiler->loop_depth] = addr;
          compiler->loop_identifier[compiler->loop_depth] = (yyvsp[-4].c_string);
          compiler->loop_depth++;
        }
#line 2670 ""grammar.c""  
 #line 2676 ""grammar.c""  
      break;
    case 65:
#line 1092 ""grammar.y""  
 #line 1098 ""grammar.y""  
      {
          int mem_offset;
         compiler->loop_depth--;
         mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
         yr_parser_emit_with_arg(
             yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);
         yr_parser_emit_with_arg(
             yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);
         if ((yyvsp[-5].integer) == INTEGER_SET_ENUMERATION)
         {
           yr_parser_emit_with_arg_reloc(
               yyscanner,
               OP_JNUNDEF,
               compiler->loop_address[compiler->loop_depth],
               NULL,
               NULL);
         }
         else  
         {
           yr_parser_emit_with_arg(
               yyscanner, OP_INCR_M, mem_offset, NULL, NULL);
           yr_parser_emit_with_arg(
               yyscanner, OP_PUSH_M, mem_offset, NULL, NULL);
           yr_parser_emit_with_arg(
               yyscanner, OP_PUSH_M, mem_offset + 3, NULL, NULL);
           yr_parser_emit_with_arg_reloc(
               yyscanner,
               OP_JLE,
               compiler->loop_address[compiler->loop_depth],
               NULL,
               NULL);
           yr_parser_emit(yyscanner, OP_POP, NULL);
           yr_parser_emit(yyscanner, OP_POP, NULL);
         }
         yr_parser_emit(yyscanner, OP_POP, NULL);
         yr_parser_emit_with_arg(
             yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);
         yr_parser_emit_with_arg(
             yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);
         yr_parser_emit(yyscanner, OP_INT_LE, NULL);
         compiler->loop_identifier[compiler->loop_depth] = NULL;
         yr_free((yyvsp[-8].c_string));
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        }
#line 2753 ""grammar.c""  
 #line 2759 ""grammar.c""  
      break;
    case 66:
#line 1171 ""grammar.y""  
 #line 1177 ""grammar.y""  
      {
          int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
          uint8_t* addr;
         if (compiler->loop_depth == MAX_LOOP_NESTING)
           compiler->last_result = \
             ERROR_LOOP_NESTING_LIMIT_EXCEEDED;
         if (compiler->loop_for_of_mem_offset != -1)
           compiler->last_result = \
             ERROR_NESTED_FOR_OF_LOOP;
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         yr_parser_emit_with_arg(
             yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);
         yr_parser_emit_with_arg(
             yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);
         yr_parser_emit_with_arg(
             yyscanner, OP_POP_M, mem_offset, &addr, NULL);
         compiler->loop_for_of_mem_offset = mem_offset;
         compiler->loop_address[compiler->loop_depth] = addr;
          compiler->loop_identifier[compiler->loop_depth] = NULL;
          compiler->loop_depth++;
        }
#line 2787 ""grammar.c""  
 #line 2793 ""grammar.c""  
      break;
    case 67:
#line 1201 ""grammar.y""  
 #line 1207 ""grammar.y""  
      {
          int mem_offset;
         compiler->loop_depth--;
         compiler->loop_for_of_mem_offset = -1;
         mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
         yr_parser_emit_with_arg(
             yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);
         yr_parser_emit_with_arg(
             yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);
         yr_parser_emit_with_arg_reloc(
             yyscanner,
             OP_JNUNDEF,
             compiler->loop_address[compiler->loop_depth],
             NULL,
             NULL);
         yr_parser_emit(yyscanner, OP_POP, NULL);
         yr_parser_emit_with_arg(
             yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);
         yr_parser_emit_with_arg(
             yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);
         yr_parser_emit(yyscanner, OP_INT_LE, NULL);
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        }
#line 2840 ""grammar.c""  
 #line 2846 ""grammar.c""  
      break;
    case 68:
#line 1250 ""grammar.y""  
 #line 1256 ""grammar.y""  
      {
          yr_parser_emit(yyscanner, OP_OF, NULL);
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        }
#line 2850 ""grammar.c""  
 #line 2856 ""grammar.c""  
      break;
    case 69:
#line 1256 ""grammar.y""  
 #line 1262 ""grammar.y""  
      {
          yr_parser_emit(yyscanner, OP_NOT, NULL);
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        }
#line 2860 ""grammar.c""  
 #line 2866 ""grammar.c""  
      break;
    case 70:
#line 1262 ""grammar.y""  
 #line 1268 ""grammar.y""  
      {
          YR_FIXUP* fixup;
          void* jmp_destination_addr;
         compiler->last_result = yr_parser_emit_with_arg_reloc(
             yyscanner,
             OP_JFALSE,
             0,           
             NULL,
             &jmp_destination_addr);
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));
         if (fixup == NULL)
           compiler->last_error = ERROR_INSUFFICIENT_MEMORY;
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         fixup->address = jmp_destination_addr;
          fixup->next = compiler->fixup_stack_head;
          compiler->fixup_stack_head = fixup;
        }
#line 2890 ""grammar.c""  
 #line 2896 ""grammar.c""  
      break;
    case 71:
#line 1288 ""grammar.y""  
 #line 1294 ""grammar.y""  
      {
          YR_FIXUP* fixup;
          uint8_t* and_addr;
         compiler->last_result = yr_arena_reserve_memory(
             compiler->code_arena, 2);
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         compiler->last_result = yr_parser_emit(yyscanner, OP_AND, &and_addr);
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         fixup = compiler->fixup_stack_head;
         *(void**)(fixup->address) = (void*)(and_addr + 1);
         compiler->fixup_stack_head = fixup->next;
         yr_free(fixup);
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        }
#line 2930 ""grammar.c""  
 #line 2936 ""grammar.c""  
      break;
    case 72:
#line 1324 ""grammar.y""  
 #line 1330 ""grammar.y""  
      {
          YR_FIXUP* fixup;
          void* jmp_destination_addr;
         compiler->last_result = yr_parser_emit_with_arg_reloc(
             yyscanner,
             OP_JTRUE,
             0,          
             NULL,
             &jmp_destination_addr);
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));
         if (fixup == NULL)
           compiler->last_error = ERROR_INSUFFICIENT_MEMORY;
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         fixup->address = jmp_destination_addr;
          fixup->next = compiler->fixup_stack_head;
          compiler->fixup_stack_head = fixup;
        }
#line 2959 ""grammar.c""  
 #line 2965 ""grammar.c""  
      break;
    case 73:
#line 1349 ""grammar.y""  
 #line 1355 ""grammar.y""  
      {
          YR_FIXUP* fixup;
          uint8_t* or_addr;
         compiler->last_result = yr_arena_reserve_memory(
             compiler->code_arena, 2);
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         compiler->last_result = yr_parser_emit(yyscanner, OP_OR, &or_addr);
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         fixup = compiler->fixup_stack_head;
         *(void**)(fixup->address) = (void*)(or_addr + 1);
         compiler->fixup_stack_head = fixup->next;
         yr_free(fixup);
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        }
#line 2999 ""grammar.c""  
 #line 3005 ""grammar.c""  
      break;
    case 74:
#line 1385 ""grammar.y""  
 #line 1391 ""grammar.y""  
      {
          compiler->last_result = yr_parser_reduce_operation(
              yyscanner, ""<"", (yyvsp[-2].expression), (yyvsp[0].expression));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        }
#line 3012 ""grammar.c""  
 #line 3018 ""grammar.c""  
      break;
    case 75:
#line 1394 ""grammar.y""  
 #line 1400 ""grammar.y""  
      {
          compiler->last_result = yr_parser_reduce_operation(
              yyscanner, "">"", (yyvsp[-2].expression), (yyvsp[0].expression));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        }
#line 3025 ""grammar.c""  
 #line 3031 ""grammar.c""  
      break;
    case 76:
#line 1403 ""grammar.y""  
 #line 1409 ""grammar.y""  
      {
          compiler->last_result = yr_parser_reduce_operation(
              yyscanner, ""<="", (yyvsp[-2].expression), (yyvsp[0].expression));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        }
#line 3038 ""grammar.c""  
 #line 3044 ""grammar.c""  
      break;
    case 77:
#line 1412 ""grammar.y""  
 #line 1418 ""grammar.y""  
      {
          compiler->last_result = yr_parser_reduce_operation(
              yyscanner, "">="", (yyvsp[-2].expression), (yyvsp[0].expression));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        }
#line 3051 ""grammar.c""  
 #line 3057 ""grammar.c""  
      break;
    case 78:
#line 1421 ""grammar.y""  
 #line 1427 ""grammar.y""  
      {
          compiler->last_result = yr_parser_reduce_operation(
              yyscanner, ""=="", (yyvsp[-2].expression), (yyvsp[0].expression));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        }
#line 3064 ""grammar.c""  
 #line 3070 ""grammar.c""  
      break;
    case 79:
#line 1430 ""grammar.y""  
 #line 1436 ""grammar.y""  
      {
          compiler->last_result = yr_parser_reduce_operation(
              yyscanner, ""!="", (yyvsp[-2].expression), (yyvsp[0].expression));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        }
#line 3077 ""grammar.c""  
 #line 3083 ""grammar.c""  
      break;
    case 80:
#line 1439 ""grammar.y""  
 #line 1445 ""grammar.y""  
      {
          (yyval.expression) = (yyvsp[0].expression);
        }
#line 3085 ""grammar.c""  
 #line 3091 ""grammar.c""  
      break;
    case 81:
#line 1443 ""grammar.y""  
 #line 1449 ""grammar.y""  
      {
          (yyval.expression) = (yyvsp[-1].expression);
        }
#line 3093 ""grammar.c""  
 #line 3099 ""grammar.c""  
      break;
    case 82:
#line 1450 ""grammar.y""  
 #line 1456 ""grammar.y""  
      { (yyval.integer) = INTEGER_SET_ENUMERATION; }
#line 3099 ""grammar.c""  
 #line 3105 ""grammar.c""  
      break;
    case 83:
#line 1451 ""grammar.y""  
 #line 1457 ""grammar.y""  
      { (yyval.integer) = INTEGER_SET_RANGE; }
#line 3105 ""grammar.c""  
 #line 3111 ""grammar.c""  
      break;
    case 84:
#line 1457 ""grammar.y""  
 #line 1463 ""grammar.y""  
      {
          if ((yyvsp[-3].expression).type != EXPRESSION_TYPE_INTEGER)
          {
           yr_compiler_set_error_extra_info(
               compiler, ""wrong type for range's lower bound"");
           compiler->last_result = ERROR_WRONG_TYPE;
         }
         if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)
         {
           yr_compiler_set_error_extra_info(
               compiler, ""wrong type for range's upper bound"");
           compiler->last_result = ERROR_WRONG_TYPE;
         }
          ERROR_IF(compiler->last_result != ERROR_SUCCESS);
        }
#line 3127 ""grammar.c""  
 #line 3133 ""grammar.c""  
      break;
    case 85:
#line 1479 ""grammar.y""  
 #line 1485 ""grammar.y""  
      {
          if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
          {
           yr_compiler_set_error_extra_info(
               compiler, ""wrong type for enumeration item"");
           compiler->last_result = ERROR_WRONG_TYPE;
         }
          ERROR_IF(compiler->last_result != ERROR_SUCCESS);
        }
#line 3143 ""grammar.c""  
 #line 3149 ""grammar.c""  
      break;
    case 86:
#line 1491 ""grammar.y""  
 #line 1497 ""grammar.y""  
      {
          if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
          {
           yr_compiler_set_error_extra_info(
               compiler, ""wrong type for enumeration item"");
           compiler->last_result = ERROR_WRONG_TYPE;
         }
          ERROR_IF(compiler->last_result != ERROR_SUCCESS);
        }
#line 3158 ""grammar.c""  
 #line 3164 ""grammar.c""  
      break;
    case 87:
#line 1506 ""grammar.y""  
 #line 1512 ""grammar.y""  
      {
          yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
        }
#line 3167 ""grammar.c""  
 #line 3173 ""grammar.c""  
      break;
    case 89:
#line 1512 ""grammar.y""  
 #line 1518 ""grammar.y""  
      {
          yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
          yr_parser_emit_pushes_for_strings(yyscanner, ""$*"");
          ERROR_IF(compiler->last_result != ERROR_SUCCESS);
        }
#line 3178 ""grammar.c""  
 #line 3184 ""grammar.c""  
      break;
    case 92:
#line 1529 ""grammar.y""  
 #line 1535 ""grammar.y""  
      {
          yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
          yr_free((yyvsp[0].c_string));
          ERROR_IF(compiler->last_result != ERROR_SUCCESS);
        }
#line 3189 ""grammar.c""  
 #line 3195 ""grammar.c""  
      break;
    case 93:
#line 1536 ""grammar.y""  
 #line 1542 ""grammar.y""  
      {
          yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
          yr_free((yyvsp[0].c_string));
          ERROR_IF(compiler->last_result != ERROR_SUCCESS);
        }
#line 3200 ""grammar.c""  
 #line 3206 ""grammar.c""  
      break;
    case 95:
#line 1548 ""grammar.y""  
 #line 1554 ""grammar.y""  
      {
          yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
        }
#line 3208 ""grammar.c""  
 #line 3214 ""grammar.c""  
      break;
    case 96:
#line 1552 ""grammar.y""  
 #line 1558 ""grammar.y""  
      {
          yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);
        }
#line 3216 ""grammar.c""  
 #line 3222 ""grammar.c""  
      break;
    case 97:
#line 1560 ""grammar.y""  
 #line 1566 ""grammar.y""  
      {
          (yyval.expression) = (yyvsp[-1].expression);
        }
#line 3224 ""grammar.c""  
 #line 3230 ""grammar.c""  
      break;
    case 98:
#line 1564 ""grammar.y""  
 #line 1570 ""grammar.y""  
      {
          compiler->last_result = yr_parser_emit(
              yyscanner, OP_FILESIZE, NULL);
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
        }
#line 3238 ""grammar.c""  
 #line 3244 ""grammar.c""  
      break;
    case 99:
#line 1574 ""grammar.y""  
 #line 1580 ""grammar.y""  
      {
          yywarning(yyscanner,
              ""Using deprecated \""entrypoint\"" keyword. Use the \""entry_point\"" ""
             ""function from PE module instead."");
         compiler->last_result = yr_parser_emit(
             yyscanner, OP_ENTRYPOINT, NULL);
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
        }
#line 3256 ""grammar.c""  
 #line 3262 ""grammar.c""  
      break;
    case 100:
#line 1588 ""grammar.y""  
 #line 1594 ""grammar.y""  
      {
          CHECK_TYPE((yyvsp[-1].expression), EXPRESSION_TYPE_INTEGER, ""intXXXX or uintXXXX"");
         compiler->last_result = yr_parser_emit(
             yyscanner, (uint8_t) (OP_READ_INT + (yyvsp[-3].integer)), NULL);
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
        }
#line 3276 ""grammar.c""  
 #line 3282 ""grammar.c""  
      break;
    case 101:
#line 1604 ""grammar.y""  
 #line 1610 ""grammar.y""  
      {
          compiler->last_result = yr_parser_emit_with_arg(
              yyscanner, OP_PUSH, (yyvsp[0].integer), NULL, NULL);
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = (yyvsp[0].integer);
        }
#line 3290 ""grammar.c""  
 #line 3296 ""grammar.c""  
      break;
    case 102:
#line 1614 ""grammar.y""  
 #line 1620 ""grammar.y""  
      {
          compiler->last_result = yr_parser_emit_with_arg_double(
              yyscanner, OP_PUSH, (yyvsp[0].double_), NULL, NULL);
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        }
#line 3303 ""grammar.c""  
 #line 3309 ""grammar.c""  
      break;
    case 103:
#line 1623 ""grammar.y""  
 #line 1629 ""grammar.y""  
      {
          SIZED_STRING* sized_string;
         compiler->last_result = yr_arena_write_data(
             compiler->sz_arena,
             (yyvsp[0].sized_string),
             (yyvsp[0].sized_string)->length + sizeof(SIZED_STRING),
             (void**) &sized_string);
         yr_free((yyvsp[0].sized_string));
         if (compiler->last_result == ERROR_SUCCESS)
           compiler->last_result = yr_parser_emit_with_arg_reloc(
               yyscanner,
               OP_PUSH,
               sized_string,
               NULL,
               NULL);
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          (yyval.expression).type = EXPRESSION_TYPE_STRING;
          (yyval.expression).value.sized_string = sized_string;
        }
#line 3332 ""grammar.c""  
 #line 3338 ""grammar.c""  
      break;
    case 104:
#line 1648 ""grammar.y""  
 #line 1654 ""grammar.y""  
      {
          compiler->last_result = yr_parser_reduce_string_identifier(
              yyscanner, (yyvsp[0].c_string), OP_COUNT, UNDEFINED);
         yr_free((yyvsp[0].c_string));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
        }
#line 3348 ""grammar.c""  
 #line 3354 ""grammar.c""  
      break;
    case 105:
#line 1660 ""grammar.y""  
 #line 1666 ""grammar.y""  
      {
          compiler->last_result = yr_parser_reduce_string_identifier(
              yyscanner, (yyvsp[-3].c_string), OP_OFFSET, UNDEFINED);
         yr_free((yyvsp[-3].c_string));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
        }
#line 3364 ""grammar.c""  
 #line 3370 ""grammar.c""  
      break;
    case 106:
#line 1672 ""grammar.y""  
 #line 1678 ""grammar.y""  
      {
          compiler->last_result = yr_parser_emit_with_arg(
              yyscanner, OP_PUSH, 1, NULL, NULL);
         if (compiler->last_result == ERROR_SUCCESS)
           compiler->last_result = yr_parser_reduce_string_identifier(
               yyscanner, (yyvsp[0].c_string), OP_OFFSET, UNDEFINED);
         yr_free((yyvsp[0].c_string));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
        }
#line 3384 ""grammar.c""  
 #line 3390 ""grammar.c""  
      break;
    case 107:
#line 1688 ""grammar.y""  
 #line 1694 ""grammar.y""  
      {
          compiler->last_result = yr_parser_reduce_string_identifier(
              yyscanner, (yyvsp[-3].c_string), OP_LENGTH, UNDEFINED);
         yr_free((yyvsp[-3].c_string));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
        }
#line 3400 ""grammar.c""  
 #line 3406 ""grammar.c""  
      break;
    case 108:
#line 1700 ""grammar.y""  
 #line 1706 ""grammar.y""  
      {
          compiler->last_result = yr_parser_emit_with_arg(
              yyscanner, OP_PUSH, 1, NULL, NULL);
         if (compiler->last_result == ERROR_SUCCESS)
           compiler->last_result = yr_parser_reduce_string_identifier(
               yyscanner, (yyvsp[0].c_string), OP_LENGTH, UNDEFINED);
         yr_free((yyvsp[0].c_string));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
        }
#line 3420 ""grammar.c""  
 #line 3426 ""grammar.c""  
      break;
    case 109:
#line 1716 ""grammar.y""  
 #line 1722 ""grammar.y""  
      {
          if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)   
          {
           (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
           (yyval.expression).value.integer = UNDEFINED;
         }
         else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_BOOLEAN)   
         {
           (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
           (yyval.expression).value.integer = UNDEFINED;
         }
         else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_OBJECT)
         {
           compiler->last_result = yr_parser_emit(
               yyscanner, OP_OBJ_VALUE, NULL);
           switch((yyvsp[0].expression).value.object->type)
           {
             case OBJECT_TYPE_INTEGER:
               (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
               (yyval.expression).value.integer = UNDEFINED;
               break;
             case OBJECT_TYPE_FLOAT:
               (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
               break;
             case OBJECT_TYPE_STRING:
               (yyval.expression).type = EXPRESSION_TYPE_STRING;
               (yyval.expression).value.sized_string = NULL;
               break;
             default:
               yr_compiler_set_error_extra_info_fmt(
                   compiler,
                   ""wrong usage of identifier \""%s\"""",
                   (yyvsp[0].expression).identifier);
               compiler->last_result = ERROR_WRONG_TYPE;
           }
         }
         else
         {
           assert(FALSE);
         }
          ERROR_IF(compiler->last_result != ERROR_SUCCESS);
        }
#line 3469 ""grammar.c""  
 #line 3475 ""grammar.c""  
      break;
    case 110:
#line 1761 ""grammar.y""  
 #line 1767 ""grammar.y""  
      {
          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, ""-"");
         if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
         {
           (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
           (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
               UNDEFINED : -((yyvsp[0].expression).value.integer);
           compiler->last_result = yr_parser_emit(yyscanner, OP_INT_MINUS, NULL);
         }
         else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_FLOAT)
         {
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
           compiler->last_result = yr_parser_emit(yyscanner, OP_DBL_MINUS, NULL);
         }
          ERROR_IF(compiler->last_result != ERROR_SUCCESS);
        }
#line 3492 ""grammar.c""  
 #line 3498 ""grammar.c""  
      break;
    case 111:
#line 1780 ""grammar.y""  
 #line 1786 ""grammar.y""  
      {
          compiler->last_result = yr_parser_reduce_operation(
              yyscanner, ""+"", (yyvsp[-2].expression), (yyvsp[0].expression));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
             (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
         {
           (yyval.expression).value.integer = OPERATION(+, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
           (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         }
         else
         {
            (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
          }
        }
#line 3514 ""grammar.c""  
 #line 3520 ""grammar.c""  
      break;
    case 112:
#line 1798 ""grammar.y""  
 #line 1804 ""grammar.y""  
      {
          compiler->last_result = yr_parser_reduce_operation(
              yyscanner, ""-"", (yyvsp[-2].expression), (yyvsp[0].expression));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
             (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
         {
           (yyval.expression).value.integer = OPERATION(-, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
           (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         }
         else
         {
            (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
          }
        }
#line 3536 ""grammar.c""  
 #line 3542 ""grammar.c""  
      break;
    case 113:
#line 1816 ""grammar.y""  
 #line 1822 ""grammar.y""  
      {
          compiler->last_result = yr_parser_reduce_operation(
              yyscanner, ""*"", (yyvsp[-2].expression), (yyvsp[0].expression));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
             (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
         {
           (yyval.expression).value.integer = OPERATION(*, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
           (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         }
         else
         {
            (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
          }
        }
#line 3558 ""grammar.c""  
 #line 3564 ""grammar.c""  
      break;
    case 114:
#line 1834 ""grammar.y""  
 #line 1840 ""grammar.y""  
      {
          compiler->last_result = yr_parser_reduce_operation(
              yyscanner, ""\\"", (yyvsp[-2].expression), (yyvsp[0].expression));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
             (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
         {
           if ((yyvsp[0].expression).value.integer != 0)
           {
             (yyval.expression).value.integer = OPERATION(/, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
             (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
           }
           else
           {
             compiler->last_result = ERROR_DIVISION_BY_ZERO;
             ERROR_IF(compiler->last_result != ERROR_SUCCESS);
           }
         }
         else
         {
            (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
          }
        }
#line 3588 ""grammar.c""  
 #line 3594 ""grammar.c""  
      break;
    case 115:
#line 1860 ""grammar.y""  
 #line 1866 ""grammar.y""  
      {
          CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""%"");
          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""%"");
         yr_parser_emit(yyscanner, OP_MOD, NULL);
         if ((yyvsp[0].expression).value.integer != 0)
         {
           (yyval.expression).value.integer = OPERATION(%, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
           (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         }
         else
         {
           compiler->last_result = ERROR_DIVISION_BY_ZERO;
            ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          }
        }
#line 3610 ""grammar.c""  
 #line 3616 ""grammar.c""  
      break;
    case 116:
#line 1878 ""grammar.y""  
 #line 1884 ""grammar.y""  
      {
          CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""^"");
          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""^"");
         yr_parser_emit(yyscanner, OP_BITWISE_XOR, NULL);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = OPERATION(^, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        }
#line 3624 ""grammar.c""  
 #line 3630 ""grammar.c""  
      break;
    case 117:
#line 1888 ""grammar.y""  
 #line 1894 ""grammar.y""  
      {
          CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""^"");
          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""^"");
         yr_parser_emit(yyscanner, OP_BITWISE_AND, NULL);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = OPERATION(&, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        }
#line 3638 ""grammar.c""  
 #line 3644 ""grammar.c""  
      break;
    case 118:
#line 1898 ""grammar.y""  
 #line 1904 ""grammar.y""  
      {
          CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""|"");
          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""|"");
         yr_parser_emit(yyscanner, OP_BITWISE_OR, NULL);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = OPERATION(|, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        }
#line 3652 ""grammar.c""  
 #line 3658 ""grammar.c""  
      break;
    case 119:
#line 1908 ""grammar.y""  
 #line 1914 ""grammar.y""  
      {
          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""~"");
         yr_parser_emit(yyscanner, OP_BITWISE_NOT, NULL);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
              UNDEFINED : ~((yyvsp[0].expression).value.integer);
        }
#line 3666 ""grammar.c""  
 #line 3672 ""grammar.c""  
      break;
    case 120:
#line 1918 ""grammar.y""  
 #line 1924 ""grammar.y""  
      {
          CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""<<"");
          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""<<"");
         yr_parser_emit(yyscanner, OP_SHL, NULL);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        }
#line 3680 ""grammar.c""  
 #line 3686 ""grammar.c""  
      break;
    case 121:
#line 1928 ""grammar.y""  
 #line 1934 ""grammar.y""  
      {
          CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "">>"");
          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "">>"");
         yr_parser_emit(yyscanner, OP_SHR, NULL);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = OPERATION(>>, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        }
#line 3694 ""grammar.c""  
 #line 3700 ""grammar.c""  
      break;
    case 122:
#line 1938 ""grammar.y""  
 #line 1944 ""grammar.y""  
      {
          (yyval.expression) = (yyvsp[0].expression);
        }
#line 3702 ""grammar.c""  
 #line 3708 ""grammar.c""  
      break;
#line 3706 ""grammar.c""  
 #line 3712 ""grammar.c""  
        default: break;
      }
   YY_SYMBOL_PRINT (""-> $$ ="", yyr1[yyn], &yyval, &yyloc);
   YYPOPSTACK (yylen);
   yylen = 0;
   YY_STACK_PRINT (yyss, yyssp);
   *++yyvsp = yyval;
   yyn = yyr1[yyn];
   yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
   if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
     yystate = yytable[yystate];
   else
     yystate = yydefgoto[yyn - YYNTOKENS];
   goto yynewstate;
 yyerrlab:
   yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
   if (!yyerrstatus)
     {
       ++yynerrs;
 #if ! YYERROR_VERBOSE
       yyerror (yyscanner, compiler, YY_(""syntax error""));
 #else
 # define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
                                         yyssp, yytoken)
       {
         char const *yymsgp = YY_(""syntax error"");
         int yysyntax_error_status;
         yysyntax_error_status = YYSYNTAX_ERROR;
         if (yysyntax_error_status == 0)
           yymsgp = yymsg;
         else if (yysyntax_error_status == 1)
           {
             if (yymsg != yymsgbuf)
               YYSTACK_FREE (yymsg);
             yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
             if (!yymsg)
               {
                 yymsg = yymsgbuf;
                 yymsg_alloc = sizeof yymsgbuf;
                 yysyntax_error_status = 2;
               }
             else
               {
                 yysyntax_error_status = YYSYNTAX_ERROR;
                 yymsgp = yymsg;
               }
           }
         yyerror (yyscanner, compiler, yymsgp);
         if (yysyntax_error_status == 2)
           goto yyexhaustedlab;
       }
 # undef YYSYNTAX_ERROR
 #endif
     }
   if (yyerrstatus == 3)
     {
       if (yychar <= YYEOF)
         {
           if (yychar == YYEOF)
             YYABORT;
         }
       else
         {
           yydestruct (""Error: discarding"",
                       yytoken, &yylval, yyscanner, compiler);
           yychar = YYEMPTY;
         }
     }
   goto yyerrlab1;
 yyerrorlab:
   if (  0)
      goto yyerrorlab;
   YYPOPSTACK (yylen);
   yylen = 0;
   YY_STACK_PRINT (yyss, yyssp);
   yystate = *yyssp;
   goto yyerrlab1;
 yyerrlab1:
   yyerrstatus = 3;       
   for (;;)
     {
       yyn = yypact[yystate];
       if (!yypact_value_is_default (yyn))
         {
           yyn += YYTERROR;
           if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
             {
               yyn = yytable[yyn];
               if (0 < yyn)
                 break;
             }
         }
       if (yyssp == yyss)
         YYABORT;
       yydestruct (""Error: popping"",
                   yystos[yystate], yyvsp, yyscanner, compiler);
       YYPOPSTACK (1);
       yystate = *yyssp;
       YY_STACK_PRINT (yyss, yyssp);
     }
   YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
   *++yyvsp = yylval;
   YY_IGNORE_MAYBE_UNINITIALIZED_END
   YY_SYMBOL_PRINT (""Shifting"", yystos[yyn], yyvsp, yylsp);
   yystate = yyn;
   goto yynewstate;
 yyacceptlab:
   yyresult = 0;
   goto yyreturn;
 yyabortlab:
   yyresult = 1;
   goto yyreturn;
 #if !defined yyoverflow || YYERROR_VERBOSE
 yyexhaustedlab:
   yyerror (yyscanner, compiler, YY_(""memory exhausted""));
   yyresult = 2;
 #endif
 yyreturn:
   if (yychar != YYEMPTY)
     {
       yytoken = YYTRANSLATE (yychar);
       yydestruct (""Cleanup: discarding lookahead"",
                   yytoken, &yylval, yyscanner, compiler);
     }
   YYPOPSTACK (yylen);
   YY_STACK_PRINT (yyss, yyssp);
   while (yyssp != yyss)
     {
       yydestruct (""Cleanup: popping"",
                   yystos[*yyssp], yyvsp, yyscanner, compiler);
       YYPOPSTACK (1);
     }
 #ifndef yyoverflow
   if (yyss != yyssa)
     YYSTACK_FREE (yyss);
 #endif
 #if YYERROR_VERBOSE
   if (yymsg != yymsgbuf)
     YYSTACK_FREE (yymsg);
  #endif
    return yyresult;
  }","[701, 702, 706, 707, 710, 711, 736, 737, 743, 744, 747, 748, 779, 780, 783, 784, 800, 801, 804, 805, 812, 813, 816, 817, 824, 825, 828, 829, 841, 842, 845, 846, 855, 856, 859, 860, 871, 872, 875, 876, 885, 886, 889, 890, 898, 899, 902, 903, 910, 912, 913, 916, 917, 938, 939, 942, 943, 967, 968, 971, 972, 1017, 1018, 1021, 1022, 1044, 1045, 1048, 1049, 1073, 1074, 1077, 1078, 1083, 1084, 1087, 1088, 1093, 1094, 1097, 1098, 1117, 1118, 1121, 1122, 1137, 1138, 1141, 1142, 1161, 1162, 1165, 1166, 1181, 1182, 1185, 1186, 1193, 1194, 1197, 1198, 1205, 1206, 1209, 1210, 1217, 1218, 1221, 1222, 1229, 1230, 1233, 1234, 1241, 1242, 1245, 1246, 1253, 1254, 1257, 1258, 1262, 1263, 1266, 1267, 1271, 1272, 1275, 1276, 1278, 1279, 1282, 1283, 1285, 1286, 1289, 1290, 1306, 1307, 1310, 1311, 1321, 1322, 1325, 1326, 1336, 1337, 1340, 1341, 1345, 1346, 1349, 1350, 1356, 1357, 1360, 1361, 1367, 1368, 1371, 1372, 1378, 1379, 1382, 1383, 1387, 1388, 1391, 1392, 1396, 1397, 1400, 1401, 1405, 1406, 1409, 1410, 1418, 1419, 1422, 1423, 1434, 1435, 1438, 1439, 1448, 1449, 1452, 1453, 1461, 1462, 1465, 1466, 1473, 1474, 1477, 1478, 1498, 1499, 1502, 1503, 1512, 1513, 1516, 1517, 1526, 1527, 1530, 1531, 1543, 1544, 1547, 1548, 1557, 1558, 1561, 1562, 1574, 1575, 1578, 1579, 1622, 1623, 1626, 1627, 1644, 1645, 1648, 1649, 1665, 1666, 1669, 1670, 1686, 1687, 1690, 1691, 1707, 1708, 1711, 1712, 1736, 1737, 1740, 1741, 1757, 1758, 1761, 1762, 1770, 1771, 1774, 1775, 1783, 1784, 1787, 1788, 1796, 1797, 1800, 1801, 1809, 1810, 1813, 1814, 1822, 1823, 1826, 1827, 1835, 1836, 1839, 1840, 1844, 1845, 1847, 1848]",libyara/grammar.y in YARA 3.5.0 allows remote attackers to cause a denial of service (heap-based out-of-bounds read and application crash) via a crafted rule that is mishandled in the yara_yyparse function.,yara,CVE-2017-5923,CWE-125
2216,178443,"  int __glXDisp_CreateContext(__GLXclientState *cl, GLbyte *pc)
  {
     ClientPtr client = cl->client;
      xGLXCreateContextReq *req = (xGLXCreateContextReq *) pc;
      __GLXconfig *config;
      __GLXscreen *pGlxScreen;
      int err;
     REQUEST_SIZE_MATCH(xGLXCreateContextReq);
      if (!validGlxScreen(cl->client, req->screen, &pGlxScreen, &err))
  	return err;
      if (!validGlxVisual(cl->client, pGlxScreen, req->visual, &config, &err))
 			   config, pGlxScreen, req->isDirect);
 }","[3, 8]",The GLX extension in X.Org xserver 1.7.7 allows remote authenticated users to cause a denial of service (server crash) and possibly execute arbitrary code via (1) a crafted request that triggers a client swap in glx/glxcmdsswap.c; or (2) a crafted length or (3) a negative value in the screen field in a request to glx/glxcmds.c.,xserver,CVE-2010-4818,CWE-20
2222,179576," lquery_in(PG_FUNCTION_ARGS)
 {
 	char	   *buf = (char *) PG_GETARG_POINTER(0);
 	char	   *ptr;
 	int			num = 0,
 				totallen = 0,
 				numOR = 0;
 	int			state = LQPRS_WAITLEVEL;
 	lquery	   *result;
 	nodeitem   *lptr = NULL;
 	lquery_level *cur,
 			   *curqlevel,
 			   *tmpql;
 	lquery_variant *lrptr = NULL;
 	bool		hasnot = false;
 	bool		wasbad = false;
 	int			charlen;
 	int			pos = 0;
 	ptr = buf;
 	while (*ptr)
 	{
 		charlen = pg_mblen(ptr);
 		if (charlen == 1)
 		{
 			if (t_iseq(ptr, '.'))
 				num++;
 			else if (t_iseq(ptr, '|'))
 				numOR++;
 		}
 		ptr += charlen;
  	}
  	num++;
 	if (num > MaxAllocSize / ITEMSIZE)
 		ereport(ERROR,
 				(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),
 			 errmsg(""number of levels (%d) exceeds the maximum allowed (%d)"",
 					num, (int) (MaxAllocSize / ITEMSIZE))));
  	curqlevel = tmpql = (lquery_level *) palloc0(ITEMSIZE * num);
  	ptr = buf;
  	while (*ptr)
 	{
 		charlen = pg_mblen(ptr);
 		if (state == LQPRS_WAITLEVEL)
 		{
 			if (ISALNUM(ptr))
 			{
 				GETVAR(curqlevel) = lptr = (nodeitem *) palloc0(sizeof(nodeitem) * (numOR + 1));
 				lptr->start = ptr;
 				state = LQPRS_WAITDELIM;
 				curqlevel->numvar = 1;
 			}
 			else if (charlen == 1 && t_iseq(ptr, '!'))
 			{
 				GETVAR(curqlevel) = lptr = (nodeitem *) palloc0(sizeof(nodeitem) * (numOR + 1));
 				lptr->start = ptr + 1;
 				state = LQPRS_WAITDELIM;
 				curqlevel->numvar = 1;
 				curqlevel->flag |= LQL_NOT;
 				hasnot = true;
 			}
 			else if (charlen == 1 && t_iseq(ptr, '*'))
 				state = LQPRS_WAITOPEN;
 			else
 				UNCHAR;
 		}
 		else if (state == LQPRS_WAITVAR)
 		{
 			if (ISALNUM(ptr))
 			{
 				lptr++;
 				lptr->start = ptr;
 				state = LQPRS_WAITDELIM;
 				curqlevel->numvar++;
 			}
 			else
 				UNCHAR;
 		}
 		else if (state == LQPRS_WAITDELIM)
 		{
 			if (charlen == 1 && t_iseq(ptr, '@'))
 			{
 				if (lptr->start == ptr)
 					UNCHAR;
 				lptr->flag |= LVAR_INCASE;
 				curqlevel->flag |= LVAR_INCASE;
 			}
 			else if (charlen == 1 && t_iseq(ptr, '*'))
 			{
 				if (lptr->start == ptr)
 					UNCHAR;
 				lptr->flag |= LVAR_ANYEND;
 				curqlevel->flag |= LVAR_ANYEND;
 			}
 			else if (charlen == 1 && t_iseq(ptr, '%'))
 			{
 				if (lptr->start == ptr)
 					UNCHAR;
 				lptr->flag |= LVAR_SUBLEXEME;
 				curqlevel->flag |= LVAR_SUBLEXEME;
 			}
 			else if (charlen == 1 && t_iseq(ptr, '|'))
 			{
 				lptr->len = ptr - lptr->start -
 					((lptr->flag & LVAR_SUBLEXEME) ? 1 : 0) -
 					((lptr->flag & LVAR_INCASE) ? 1 : 0) -
 					((lptr->flag & LVAR_ANYEND) ? 1 : 0);
 				if (lptr->wlen > 255)
 					ereport(ERROR,
 							(errcode(ERRCODE_NAME_TOO_LONG),
 							 errmsg(""name of level is too long""),
 							 errdetail(""Name length is %d, must ""
 									   ""be < 256, in position %d."",
 									   lptr->wlen, pos)));
 				state = LQPRS_WAITVAR;
 			}
 			else if (charlen == 1 && t_iseq(ptr, '.'))
 			{
 				lptr->len = ptr - lptr->start -
 					((lptr->flag & LVAR_SUBLEXEME) ? 1 : 0) -
 					((lptr->flag & LVAR_INCASE) ? 1 : 0) -
 					((lptr->flag & LVAR_ANYEND) ? 1 : 0);
 				if (lptr->wlen > 255)
 					ereport(ERROR,
 							(errcode(ERRCODE_NAME_TOO_LONG),
 							 errmsg(""name of level is too long""),
 							 errdetail(""Name length is %d, must ""
 									   ""be < 256, in position %d."",
 									   lptr->wlen, pos)));
 				state = LQPRS_WAITLEVEL;
 				curqlevel = NEXTLEV(curqlevel);
 			}
 			else if (ISALNUM(ptr))
 			{
 				if (lptr->flag)
 					UNCHAR;
 			}
 			else
 				UNCHAR;
 		}
 		else if (state == LQPRS_WAITOPEN)
 		{
 			if (charlen == 1 && t_iseq(ptr, '{'))
 				state = LQPRS_WAITFNUM;
 			else if (charlen == 1 && t_iseq(ptr, '.'))
 			{
 				curqlevel->low = 0;
 				curqlevel->high = 0xffff;
 				curqlevel = NEXTLEV(curqlevel);
 				state = LQPRS_WAITLEVEL;
 			}
 			else
 				UNCHAR;
 		}
 		else if (state == LQPRS_WAITFNUM)
 		{
 			if (charlen == 1 && t_iseq(ptr, ','))
 				state = LQPRS_WAITSNUM;
 			else if (t_isdigit(ptr))
 			{
 				curqlevel->low = atoi(ptr);
 				state = LQPRS_WAITND;
 			}
 			else
 				UNCHAR;
 		}
 		else if (state == LQPRS_WAITSNUM)
 		{
 			if (t_isdigit(ptr))
 			{
 				curqlevel->high = atoi(ptr);
 				state = LQPRS_WAITCLOSE;
 			}
 			else if (charlen == 1 && t_iseq(ptr, '}'))
 			{
 				curqlevel->high = 0xffff;
 				state = LQPRS_WAITEND;
 			}
 			else
 				UNCHAR;
 		}
 		else if (state == LQPRS_WAITCLOSE)
 		{
 			if (charlen == 1 && t_iseq(ptr, '}'))
 				state = LQPRS_WAITEND;
 			else if (!t_isdigit(ptr))
 				UNCHAR;
 		}
 		else if (state == LQPRS_WAITND)
 		{
 			if (charlen == 1 && t_iseq(ptr, '}'))
 			{
 				curqlevel->high = curqlevel->low;
 				state = LQPRS_WAITEND;
 			}
 			else if (charlen == 1 && t_iseq(ptr, ','))
 				state = LQPRS_WAITSNUM;
 			else if (!t_isdigit(ptr))
 				UNCHAR;
 		}","[33, 34, 35, 36, 37]","Multiple integer overflows in contrib/hstore/hstore_io.c in PostgreSQL 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact via vectors related to the (1) hstore_recv, (2) hstore_from_arrays, and (3) hstore_from_array functions in contrib/hstore/hstore_io.c; and the (4) hstoreArrayToPairs function in contrib/hstore/hstore_op.c, which triggers a buffer overflow.  NOTE: this issue was SPLIT from CVE-2014-0064 because it has a different set of affected versions.",postgres,CVE-2014-2669,CWE-189
2230,178121," void vrend_renderer_context_destroy(uint32_t handle)
 {
    struct vrend_decode_ctx *ctx;
    bool ret;
     if (handle >= VREND_MAX_CTX)
        return;
    if (handle == 0) {
       return;
    }
     ctx = dec_ctx[handle];
     if (!ctx)
        return;
       vrend_hw_switch_context(dec_ctx[0]->grctx, true);
 }","[7, 8, 9]",The vrend_decode_reset function in vrend_decode.c in virglrenderer before 0.6.0 allows local guest OS users to cause a denial of service (NULL pointer dereference and QEMU process crash) by destroying context 0 (zero).,virglrenderer,CVE-2017-6210,CWE-476
2236,179171," static void copy_fields(const FieldMatchContext *fm, AVFrame *dst,
                          const AVFrame *src, int field)
  {
      int plane;
    for (plane = 0; plane < 4 && src->data[plane]; plane++)
     for (plane = 0; plane < 4 && src->data[plane] && src->linesize[plane]; plane++)
          av_image_copy_plane(dst->data[plane] + field*dst->linesize[plane], dst->linesize[plane] << 1,
                              src->data[plane] + field*src->linesize[plane], src->linesize[plane] << 1,
                              get_width(fm, src, plane), get_height(fm, src, plane) / 2);
 }","[5, 6]","libavfilter in FFmpeg before 2.0.1 has unspecified impact and remote vectors related to a crafted *plane,* which triggers an out-of-bounds heap write.",FFmpeg,CVE-2013-4263,CWE-119
2242,181495," static int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in)
 {
 	jp2_pclr_t *pclr = &box->data.pclr;
 	int lutsize;
 	unsigned int i;
 	unsigned int j;
  	int_fast32_t x;
  	pclr->lutdata = 0;
 	pclr->bpc = 0;
  	if (jp2_getuint16(in, &pclr->numlutents) ||
  	  jp2_getuint8(in, &pclr->numchans)) {
 		return -1;
 	}
 	lutsize = pclr->numlutents * pclr->numchans;
 	if (!(pclr->lutdata = jas_alloc2(lutsize, sizeof(int_fast32_t)))) {
 		return -1;
 	}
 	if (!(pclr->bpc = jas_alloc2(pclr->numchans, sizeof(uint_fast8_t)))) {
 		return -1;
 	}
 	for (i = 0; i < pclr->numchans; ++i) {
 		if (jp2_getuint8(in, &pclr->bpc[i])) {
 			return -1;
 		}
 	}
 	for (i = 0; i < pclr->numlutents; ++i) {
 		for (j = 0; j < pclr->numchans; ++j) {
 			if (jp2_getint(in, (pclr->bpc[j] & 0x80) != 0,
 			  (pclr->bpc[j] & 0x7f) + 1, &x)) {
 				return -1;
 			}
 			pclr->lutdata[i * pclr->numchans + j] = x;
 		}
 	}
 	return 0;
 }",[9],The jp2_cdef_destroy function in jp2_cod.c in JasPer before 2.0.13 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted image.,jasper,CVE-2017-6850,CWE-476
2245,179250," rad_get_vendor_attr(u_int32_t *vendor, const void **data, size_t *len)
 rad_get_vendor_attr(u_int32_t *vendor, unsigned char *type, const void **data, size_t *len, const void *raw, size_t raw_len)
  {
  	struct vendor_attribute *attr;
	attr = (struct vendor_attribute *)*data;
 	if (raw_len < sizeof(struct vendor_attribute)) {
 		return -1;
 	}
 	attr = (struct vendor_attribute *) raw;
  	*vendor = ntohl(attr->vendor_value);
 	*type = attr->attrib_type;
  	*data = attr->attrib_data;
  	*len = attr->attrib_len - 2;
 	if ((attr->attrib_len + 4) > raw_len) {
 		return -1;
 	}
  	return (attr->attrib_type);
  }","[2, 5, 6, 7, 8, 9, 11, 14, 15, 16]",Buffer overflow in the radius_get_vendor_attr function in the Radius extension before 1.2.7 for PHP allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a large Vendor Specific Attributes (VSA) length value.,php-radius,CVE-2013-2220,CWE-119
2250,179089," static int read_header(FFV1Context *f)
 {
     uint8_t state[CONTEXT_SIZE];
     int i, j, context_count = -1;  
     RangeCoder *const c = &f->slice_context[0]->c;
      memset(state, 128, sizeof(state));
      if (f->version < 2) {
        int chroma_planes, chroma_h_shift, chroma_v_shift, transparency;
         int chroma_planes, chroma_h_shift, chroma_v_shift, transparency, colorspace, bits_per_raw_sample;
          unsigned v= get_symbol(c, state, 0);
          if (v >= 2) {
              av_log(f->avctx, AV_LOG_ERROR, ""invalid version %d in ver01 header\n"", v);
             return AVERROR_INVALIDDATA;
         }
         f->version = v;
         f->ac      = f->avctx->coder_type = get_symbol(c, state, 0);
         if (f->ac > 1) {
             for (i = 1; i < 256; i++)
                  f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];
          }
        f->colorspace = get_symbol(c, state, 0);  
        if (f->version > 0)
            f->avctx->bits_per_raw_sample = get_symbol(c, state, 0);
         colorspace     = get_symbol(c, state, 0);  
         bits_per_raw_sample = f->version > 0 ? get_symbol(c, state, 0) : f->avctx->bits_per_raw_sample;
          chroma_planes  = get_rac(c, state);
          chroma_h_shift = get_symbol(c, state, 0);
          chroma_v_shift = get_symbol(c, state, 0);
          transparency   = get_rac(c, state);
          if (f->plane_count) {
            if (   chroma_planes != f->chroma_planes
             if (   colorspace    != f->colorspace
                 || bits_per_raw_sample != f->avctx->bits_per_raw_sample
                 || chroma_planes != f->chroma_planes
                  || chroma_h_shift!= f->chroma_h_shift
                  || chroma_v_shift!= f->chroma_v_shift
                  || transparency  != f->transparency) {
                 av_log(f->avctx, AV_LOG_ERROR, ""Invalid change of global parameters\n"");
                 return AVERROR_INVALIDDATA;
              }
          }
         f->colorspace     = colorspace;
         f->avctx->bits_per_raw_sample = bits_per_raw_sample;
          f->chroma_planes  = chroma_planes;
          f->chroma_h_shift = chroma_h_shift;
          f->chroma_v_shift = chroma_v_shift;
         f->transparency   = transparency;
         f->plane_count    = 2 + f->transparency;
     }
     if (f->colorspace == 0) {
         if (!f->transparency && !f->chroma_planes) {
             if (f->avctx->bits_per_raw_sample <= 8)
                 f->avctx->pix_fmt = AV_PIX_FMT_GRAY8;
             else
                 f->avctx->pix_fmt = AV_PIX_FMT_GRAY16;
         } else if (f->avctx->bits_per_raw_sample<=8 && !f->transparency) {
             switch(16 * f->chroma_h_shift + f->chroma_v_shift) {
             case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P; break;
             case 0x01: f->avctx->pix_fmt = AV_PIX_FMT_YUV440P; break;
             case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P; break;
             case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P; break;
             case 0x20: f->avctx->pix_fmt = AV_PIX_FMT_YUV411P; break;
             case 0x22: f->avctx->pix_fmt = AV_PIX_FMT_YUV410P; break;
             default:
                 av_log(f->avctx, AV_LOG_ERROR, ""format not supported\n"");
                 return AVERROR(ENOSYS);
             }
         } else if (f->avctx->bits_per_raw_sample <= 8 && f->transparency) {
             switch(16*f->chroma_h_shift + f->chroma_v_shift) {
             case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P; break;
             case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P; break;
             case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P; break;
             default:
                 av_log(f->avctx, AV_LOG_ERROR, ""format not supported\n"");
                 return AVERROR(ENOSYS);
             }
         } else if (f->avctx->bits_per_raw_sample == 9) {
             f->packed_at_lsb = 1;
             switch(16 * f->chroma_h_shift + f->chroma_v_shift) {
             case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P9; break;
             case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P9; break;
             case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P9; break;
             default:
                 av_log(f->avctx, AV_LOG_ERROR, ""format not supported\n"");
                 return AVERROR(ENOSYS);
             }
         } else if (f->avctx->bits_per_raw_sample == 10) {
             f->packed_at_lsb = 1;
             switch(16 * f->chroma_h_shift + f->chroma_v_shift) {
             case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P10; break;
             case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P10; break;
             case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P10; break;
             default:
                 av_log(f->avctx, AV_LOG_ERROR, ""format not supported\n"");
                 return AVERROR(ENOSYS);
             }
         } else {
             switch(16 * f->chroma_h_shift + f->chroma_v_shift) {
             case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P16; break;
             case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P16; break;
             case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P16; break;
             default:
                 av_log(f->avctx, AV_LOG_ERROR, ""format not supported\n"");
                 return AVERROR(ENOSYS);
             }
         }
     } else if (f->colorspace == 1) {
         if (f->chroma_h_shift || f->chroma_v_shift) {
             av_log(f->avctx, AV_LOG_ERROR,
                    ""chroma subsampling not supported in this colorspace\n"");
             return AVERROR(ENOSYS);
         }
         if (     f->avctx->bits_per_raw_sample ==  9)
             f->avctx->pix_fmt = AV_PIX_FMT_GBRP9;
         else if (f->avctx->bits_per_raw_sample == 10)
             f->avctx->pix_fmt = AV_PIX_FMT_GBRP10;
         else if (f->avctx->bits_per_raw_sample == 12)
             f->avctx->pix_fmt = AV_PIX_FMT_GBRP12;
         else if (f->avctx->bits_per_raw_sample == 14)
             f->avctx->pix_fmt = AV_PIX_FMT_GBRP14;
         else
         if (f->transparency) f->avctx->pix_fmt = AV_PIX_FMT_RGB32;
         else                 f->avctx->pix_fmt = AV_PIX_FMT_0RGB32;
     } else {
         av_log(f->avctx, AV_LOG_ERROR, ""colorspace not supported\n"");
         return AVERROR(ENOSYS);
     }
     av_dlog(f->avctx, ""%d %d %d\n"",
             f->chroma_h_shift, f->chroma_v_shift, f->avctx->pix_fmt);
     if (f->version < 2) {
         context_count = read_quant_tables(c, f->quant_table);
         if (context_count < 0) {
             av_log(f->avctx, AV_LOG_ERROR, ""read_quant_table error\n"");
             return AVERROR_INVALIDDATA;
         }
     } else if (f->version < 3) {
         f->slice_count = get_symbol(c, state, 0);
     } else {
         const uint8_t *p = c->bytestream_end;
         for (f->slice_count = 0;
              f->slice_count < MAX_SLICES && 3 < p - c->bytestream_start;
              f->slice_count++) {
             int trailer = 3 + 5*!!f->ec;
             int size = AV_RB24(p-trailer);
             if (size + trailer > p - c->bytestream_start)
                 break;
             p -= size + trailer;
         }
     }
     if (f->slice_count > (unsigned)MAX_SLICES || f->slice_count <= 0) {
         av_log(f->avctx, AV_LOG_ERROR, ""slice count %d is invalid\n"", f->slice_count);
         return AVERROR_INVALIDDATA;
     }
     for (j = 0; j < f->slice_count; j++) {
         FFV1Context *fs = f->slice_context[j];
         fs->ac            = f->ac;
         fs->packed_at_lsb = f->packed_at_lsb;
         fs->slice_damaged = 0;
         if (f->version == 2) {
             fs->slice_x      =  get_symbol(c, state, 0)      * f->width ;
             fs->slice_y      =  get_symbol(c, state, 0)      * f->height;
             fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width  + fs->slice_x;
             fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;
             fs->slice_x     /= f->num_h_slices;
             fs->slice_y     /= f->num_v_slices;
             fs->slice_width  = fs->slice_width  / f->num_h_slices - fs->slice_x;
             fs->slice_height = fs->slice_height / f->num_v_slices - fs->slice_y;
             if ((unsigned)fs->slice_width  > f->width ||
                 (unsigned)fs->slice_height > f->height)
                 return AVERROR_INVALIDDATA;
             if (   (unsigned)fs->slice_x + (uint64_t)fs->slice_width  > f->width
                 || (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height)
                 return AVERROR_INVALIDDATA;
         }
         for (i = 0; i < f->plane_count; i++) {
             PlaneContext *const p = &fs->plane[i];
             if (f->version == 2) {
                 int idx = get_symbol(c, state, 0);
                 if (idx > (unsigned)f->quant_table_count) {
                     av_log(f->avctx, AV_LOG_ERROR,
                            ""quant_table_index out of range\n"");
                     return AVERROR_INVALIDDATA;
                 }
                 p->quant_table_index = idx;
                 memcpy(p->quant_table, f->quant_tables[idx],
                        sizeof(p->quant_table));
                 context_count = f->context_count[idx];
             } else {
                 memcpy(p->quant_table, f->quant_table, sizeof(p->quant_table));
             }
             if (f->version <= 2) {
                 av_assert0(context_count >= 0);
                 if (p->context_count < context_count) {
                     av_freep(&p->state);
                     av_freep(&p->vlc_state);
                 }
                 p->context_count = context_count;
             }
         }
     }
     return 0;
 }","[8, 9, 21, 22, 23, 24, 25, 31, 32, 33, 34, 42, 43]","The read_header function in libavcodec/ffv1dec.c in FFmpeg before 2.1 does not properly enforce certain bit-count and colorspace constraints, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted FFV1 data.",FFmpeg,CVE-2013-7020,CWE-119
2270,181282," match_at(regex_t* reg, const UChar* str, const UChar* end,
 #ifdef USE_MATCH_RANGE_MUST_BE_INSIDE_OF_SPECIFIED_RANGE
 	 const UChar* right_range,
 #endif
 	 const UChar* sstart, UChar* sprev, OnigMatchArg* msa)
 {
   static UChar FinishCode[] = { OP_FINISH };
   int i, n, num_mem, best_len, pop_level;
   LengthType tlen, tlen2;
   MemNumType mem;
   RelAddrType addr;
   UChar *s, *q, *sbegin;
   int is_alloca;
   char *alloc_base;
   OnigStackType *stk_base, *stk, *stk_end;
   OnigStackType *stkp;  
   OnigStackIndex si;
   OnigStackIndex *repeat_stk;
   OnigStackIndex *mem_start_stk, *mem_end_stk;
 #ifdef USE_COMBINATION_EXPLOSION_CHECK
   int scv;
   unsigned char* state_check_buff = msa->state_check_buff;
   int num_comb_exp_check = reg->num_comb_exp_check;
 #endif
   UChar *p = reg->p;
   OnigOptionType option = reg->options;
   OnigEncoding encode = reg->enc;
   OnigCaseFoldType case_fold_flag = reg->case_fold_flag;
   pop_level = reg->stack_pop_level;
   num_mem = reg->num_mem;
   STACK_INIT(INIT_MATCH_STACK_SIZE);
   UPDATE_FOR_STACK_REALLOC;
   for (i = 1; i <= num_mem; i++) {
     mem_start_stk[i] = mem_end_stk[i] = INVALID_STACK_INDEX;
   }
 #ifdef ONIG_DEBUG_MATCH
   fprintf(stderr, ""match_at: str: %d, end: %d, start: %d, sprev: %d\n"",
 	  (int )str, (int )end, (int )sstart, (int )sprev);
   fprintf(stderr, ""size: %d, start offset: %d\n"",
 	  (int )(end - str), (int )(sstart - str));
 #endif
   STACK_PUSH_ENSURED(STK_ALT, FinishCode);   
   best_len = ONIG_MISMATCH;
   s = (UChar* )sstart;
   while (1) {
 #ifdef ONIG_DEBUG_MATCH
     {
       UChar *q, *bp, buf[50];
       int len;
       fprintf(stderr, ""%4d> \"""", (int )(s - str));
       bp = buf;
       for (i = 0, q = s; i < 7 && q < end; i++) {
 	len = enclen(encode, q);
 	while (len-- > 0) *bp++ = *q++;
       }
       if (q < end) { xmemcpy(bp, ""...\"""", 4); bp += 4; }
       else         { xmemcpy(bp, ""\"""",    1); bp += 1; }
       *bp = 0;
       fputs((char* )buf, stderr);
       for (i = 0; i < 20 - (bp - buf); i++) fputc(' ', stderr);
       onig_print_compiled_byte_code(stderr, p, NULL, encode);
       fprintf(stderr, ""\n"");
     }
 #endif
     sbegin = s;
     switch (*p++) {
     case OP_END:  MOP_IN(OP_END);
       n = s - sstart;
       if (n > best_len) {
         OnigRegion* region;
 #ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE
         if (IS_FIND_LONGEST(option)) {
           if (n > msa->best_len) {
             msa->best_len = n;
             msa->best_s   = (UChar* )sstart;
           }
           else
             goto end_best_len;
         }
 #endif
         best_len = n;
         region = msa->region;
         if (region) {
 #ifdef USE_POSIX_API_REGION_OPTION
           if (IS_POSIX_REGION(msa->options)) {
             posix_regmatch_t* rmt = (posix_regmatch_t* )region;
             rmt[0].rm_so = sstart - str;
             rmt[0].rm_eo = s      - str;
             for (i = 1; i <= num_mem; i++) {
               if (mem_end_stk[i] != INVALID_STACK_INDEX) {
                 if (BIT_STATUS_AT(reg->bt_mem_start, i))
                   rmt[i].rm_so = STACK_AT(mem_start_stk[i])->u.mem.pstr - str;
                 else
                   rmt[i].rm_so = (UChar* )((void* )(mem_start_stk[i])) - str;
                 rmt[i].rm_eo = (BIT_STATUS_AT(reg->bt_mem_end, i)
                                 ? STACK_AT(mem_end_stk[i])->u.mem.pstr
                                 : (UChar* )((void* )mem_end_stk[i])) - str;
               }
               else {
                 rmt[i].rm_so = rmt[i].rm_eo = ONIG_REGION_NOTPOS;
               }
             }
           }
           else {
 #endif  
             region->beg[0] = sstart - str;
             region->end[0] = s      - str;
             for (i = 1; i <= num_mem; i++) {
               if (mem_end_stk[i] != INVALID_STACK_INDEX) {
                 if (BIT_STATUS_AT(reg->bt_mem_start, i))
                   region->beg[i] = STACK_AT(mem_start_stk[i])->u.mem.pstr - str;
                 else
                   region->beg[i] = (UChar* )((void* )mem_start_stk[i]) - str;
                 region->end[i] = (BIT_STATUS_AT(reg->bt_mem_end, i)
                                   ? STACK_AT(mem_end_stk[i])->u.mem.pstr
                                   : (UChar* )((void* )mem_end_stk[i])) - str;
               }
               else {
                 region->beg[i] = region->end[i] = ONIG_REGION_NOTPOS;
               }
             }
 #ifdef USE_CAPTURE_HISTORY
             if (reg->capture_history != 0) {
               int r;
               OnigCaptureTreeNode* node;
               if (IS_NULL(region->history_root)) {
                 region->history_root = node = history_node_new();
                 CHECK_NULL_RETURN_MEMERR(node);
               }
               else {
                 node = region->history_root;
                 history_tree_clear(node);
               }
               node->group = 0;
               node->beg   = sstart - str;
               node->end   = s      - str;
               stkp = stk_base;
               r = make_capture_history_tree(region->history_root, &stkp,
                                             stk, (UChar* )str, reg);
               if (r < 0) {
                 best_len = r;  
                 goto finish;
               }
             }
 #endif  
 #ifdef USE_POSIX_API_REGION_OPTION
           }  
 #endif
         }  
       }  
 #ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE
     end_best_len:
 #endif
       MOP_OUT;
       if (IS_FIND_CONDITION(option)) {
         if (IS_FIND_NOT_EMPTY(option) && s == sstart) {
           best_len = ONIG_MISMATCH;
           goto fail;  
         }
         if (IS_FIND_LONGEST(option) && DATA_ENSURE_CHECK1) {
           goto fail;  
         }
       }
       goto finish;
        break;
      case OP_EXACT1:  MOP_IN(OP_EXACT1);
#if 0
        DATA_ENSURE(1);
        if (*p != *s) goto fail;
        p++; s++;
#endif
      if (*p != *s++) goto fail;
      DATA_ENSURE(0);
      p++;
        MOP_OUT;
        break;
     case OP_EXACT1_IC:  MOP_IN(OP_EXACT1_IC);
       {
         int len;
         UChar *q, lowbuf[ONIGENC_MBC_CASE_FOLD_MAXLEN];
         DATA_ENSURE(1);
         len = ONIGENC_MBC_CASE_FOLD(encode,
                                     case_fold_flag,
                                     &s, end, lowbuf);
         DATA_ENSURE(0);
         q = lowbuf;
         while (len-- > 0) {
           if (*p != *q) {
             goto fail;
           }
           p++; q++;
         }
       }
       MOP_OUT;
       break;
     case OP_EXACT2:  MOP_IN(OP_EXACT2);
       DATA_ENSURE(2);
       if (*p != *s) goto fail;
       p++; s++;
       if (*p != *s) goto fail;
       sprev = s;
       p++; s++;
       MOP_OUT;
       continue;
       break;
     case OP_EXACT3:  MOP_IN(OP_EXACT3);
       DATA_ENSURE(3);
       if (*p != *s) goto fail;
       p++; s++;
       if (*p != *s) goto fail;
       p++; s++;
       if (*p != *s) goto fail;
       sprev = s;
       p++; s++;
       MOP_OUT;
       continue;
       break;
     case OP_EXACT4:  MOP_IN(OP_EXACT4);
       DATA_ENSURE(4);
       if (*p != *s) goto fail;
       p++; s++;
       if (*p != *s) goto fail;
       p++; s++;
       if (*p != *s) goto fail;
       p++; s++;
       if (*p != *s) goto fail;
       sprev = s;
       p++; s++;
       MOP_OUT;
       continue;
       break;
     case OP_EXACT5:  MOP_IN(OP_EXACT5);
       DATA_ENSURE(5);
       if (*p != *s) goto fail;
       p++; s++;
       if (*p != *s) goto fail;
       p++; s++;
       if (*p != *s) goto fail;
       p++; s++;
       if (*p != *s) goto fail;
       p++; s++;
       if (*p != *s) goto fail;
       sprev = s;
       p++; s++;
       MOP_OUT;
       continue;
       break;
     case OP_EXACTN:  MOP_IN(OP_EXACTN);
       GET_LENGTH_INC(tlen, p);
       DATA_ENSURE(tlen);
       while (tlen-- > 0) {
         if (*p++ != *s++) goto fail;
       }
       sprev = s - 1;
       MOP_OUT;
       continue;
       break;
     case OP_EXACTN_IC:  MOP_IN(OP_EXACTN_IC);
       {
         int len;
         UChar *q, *endp, lowbuf[ONIGENC_MBC_CASE_FOLD_MAXLEN];
         GET_LENGTH_INC(tlen, p);
         endp = p + tlen;
         while (p < endp) {
           sprev = s;
           DATA_ENSURE(1);
           len = ONIGENC_MBC_CASE_FOLD(encode,
                                       case_fold_flag,
                                       &s, end, lowbuf);
           DATA_ENSURE(0);
           q = lowbuf;
           while (len-- > 0) {
             if (*p != *q) goto fail;
             p++; q++;
           }
         }
       }
       MOP_OUT;
       continue;
       break;
     case OP_EXACTMB2N1:  MOP_IN(OP_EXACTMB2N1);
       DATA_ENSURE(2);
       if (*p != *s) goto fail;
       p++; s++;
       if (*p != *s) goto fail;
       p++; s++;
       MOP_OUT;
       break;
     case OP_EXACTMB2N2:  MOP_IN(OP_EXACTMB2N2);
       DATA_ENSURE(4);
       if (*p != *s) goto fail;
       p++; s++;
       if (*p != *s) goto fail;
       p++; s++;
       sprev = s;
       if (*p != *s) goto fail;
       p++; s++;
       if (*p != *s) goto fail;
       p++; s++;
       MOP_OUT;
       continue;
       break;
     case OP_EXACTMB2N3:  MOP_IN(OP_EXACTMB2N3);
       DATA_ENSURE(6);
       if (*p != *s) goto fail;
       p++; s++;
       if (*p != *s) goto fail;
       p++; s++;
       if (*p != *s) goto fail;
       p++; s++;
       if (*p != *s) goto fail;
       p++; s++;
       sprev = s;
       if (*p != *s) goto fail;
       p++; s++;
       if (*p != *s) goto fail;
       p++; s++;
       MOP_OUT;
       continue;
       break;
     case OP_EXACTMB2N:  MOP_IN(OP_EXACTMB2N);
       GET_LENGTH_INC(tlen, p);
       DATA_ENSURE(tlen * 2);
       while (tlen-- > 0) {
         if (*p != *s) goto fail;
         p++; s++;
         if (*p != *s) goto fail;
         p++; s++;
       }
       sprev = s - 2;
       MOP_OUT;
       continue;
       break;
     case OP_EXACTMB3N:  MOP_IN(OP_EXACTMB3N);
       GET_LENGTH_INC(tlen, p);
       DATA_ENSURE(tlen * 3);
       while (tlen-- > 0) {
         if (*p != *s) goto fail;
         p++; s++;
         if (*p != *s) goto fail;
         p++; s++;
         if (*p != *s) goto fail;
         p++; s++;
       }
       sprev = s - 3;
       MOP_OUT;
       continue;
       break;
     case OP_EXACTMBN:  MOP_IN(OP_EXACTMBN);
       GET_LENGTH_INC(tlen,  p);   
       GET_LENGTH_INC(tlen2, p);   
       tlen2 *= tlen;
       DATA_ENSURE(tlen2);
       while (tlen2-- > 0) {
         if (*p != *s) goto fail;
         p++; s++;
       }
       sprev = s - tlen;
       MOP_OUT;
       continue;
       break;
     case OP_CCLASS:  MOP_IN(OP_CCLASS);
       DATA_ENSURE(1);
       if (BITSET_AT(((BitSetRef )p), *s) == 0) goto fail;
       p += SIZE_BITSET;
       s += enclen(encode, s);    
       MOP_OUT;
       break;
     case OP_CCLASS_MB:  MOP_IN(OP_CCLASS_MB);
       if (! ONIGENC_IS_MBC_HEAD(encode, s)) goto fail;
     cclass_mb:
       GET_LENGTH_INC(tlen, p);
       {
         OnigCodePoint code;
         UChar *ss;
         int mb_len;
         DATA_ENSURE(1);
         mb_len = enclen(encode, s);
         DATA_ENSURE(mb_len);
         ss = s;
         s += mb_len;
         code = ONIGENC_MBC_TO_CODE(encode, ss, s);
 #ifdef PLATFORM_UNALIGNED_WORD_ACCESS
         if (! onig_is_in_code_range(p, code)) goto fail;
 #else
         q = p;
         ALIGNMENT_RIGHT(q);
         if (! onig_is_in_code_range(q, code)) goto fail;
 #endif
       }
       p += tlen;
       MOP_OUT;
       break;
     case OP_CCLASS_MIX:  MOP_IN(OP_CCLASS_MIX);
       DATA_ENSURE(1);
       if (ONIGENC_IS_MBC_HEAD(encode, s)) {
         p += SIZE_BITSET;
         goto cclass_mb;
       }
       else {
         if (BITSET_AT(((BitSetRef )p), *s) == 0)
           goto fail;
         p += SIZE_BITSET;
         GET_LENGTH_INC(tlen, p);
         p += tlen;
         s++;
       }
       MOP_OUT;
       break;
     case OP_CCLASS_NOT:  MOP_IN(OP_CCLASS_NOT);
       DATA_ENSURE(1);
       if (BITSET_AT(((BitSetRef )p), *s) != 0) goto fail;
       p += SIZE_BITSET;
       s += enclen(encode, s);
       MOP_OUT;
       break;
     case OP_CCLASS_MB_NOT:  MOP_IN(OP_CCLASS_MB_NOT);
       DATA_ENSURE(1);
       if (! ONIGENC_IS_MBC_HEAD(encode, s)) {
         s++;
         GET_LENGTH_INC(tlen, p);
         p += tlen;
         goto cc_mb_not_success;
       }
     cclass_mb_not:
       GET_LENGTH_INC(tlen, p);
       {
         OnigCodePoint code;
         UChar *ss;
         int mb_len = enclen(encode, s);
         if (! DATA_ENSURE_CHECK(mb_len)) {
           DATA_ENSURE(1);
           s = (UChar* )end;
           p += tlen;
           goto cc_mb_not_success;
         }
         ss = s;
         s += mb_len;
         code = ONIGENC_MBC_TO_CODE(encode, ss, s);
 #ifdef PLATFORM_UNALIGNED_WORD_ACCESS
         if (onig_is_in_code_range(p, code)) goto fail;
 #else
         q = p;
         ALIGNMENT_RIGHT(q);
         if (onig_is_in_code_range(q, code)) goto fail;
 #endif
       }
       p += tlen;
     cc_mb_not_success:
       MOP_OUT;
       break;
     case OP_CCLASS_MIX_NOT:  MOP_IN(OP_CCLASS_MIX_NOT);
       DATA_ENSURE(1);
       if (ONIGENC_IS_MBC_HEAD(encode, s)) {
         p += SIZE_BITSET;
         goto cclass_mb_not;
       }
       else {
         if (BITSET_AT(((BitSetRef )p), *s) != 0)
           goto fail;
         p += SIZE_BITSET;
         GET_LENGTH_INC(tlen, p);
         p += tlen;
         s++;
       }
       MOP_OUT;
       break;
     case OP_CCLASS_NODE:  MOP_IN(OP_CCLASS_NODE);
       {
         OnigCodePoint code;
         void *node;
         int mb_len;
         UChar *ss;
         DATA_ENSURE(1);
         GET_POINTER_INC(node, p);
         mb_len = enclen(encode, s);
         ss = s;
         s += mb_len;
         DATA_ENSURE(0);
         code = ONIGENC_MBC_TO_CODE(encode, ss, s);
         if (onig_is_code_in_cc_len(mb_len, code, node) == 0) goto fail;
       }
       MOP_OUT;
       break;
     case OP_ANYCHAR:  MOP_IN(OP_ANYCHAR);
       DATA_ENSURE(1);
       n = enclen(encode, s);
       DATA_ENSURE(n);
       if (ONIGENC_IS_MBC_NEWLINE(encode, s, end)) goto fail;
       s += n;
       MOP_OUT;
       break;
     case OP_ANYCHAR_ML:  MOP_IN(OP_ANYCHAR_ML);
       DATA_ENSURE(1);
       n = enclen(encode, s);
       DATA_ENSURE(n);
       s += n;
       MOP_OUT;
       break;
     case OP_ANYCHAR_STAR:  MOP_IN(OP_ANYCHAR_STAR);
       while (DATA_ENSURE_CHECK1) {
         STACK_PUSH_ALT(p, s, sprev);
         n = enclen(encode, s);
         DATA_ENSURE(n);
         if (ONIGENC_IS_MBC_NEWLINE(encode, s, end))  goto fail;
         sprev = s;
         s += n;
       }
       MOP_OUT;
       break;
     case OP_ANYCHAR_ML_STAR:  MOP_IN(OP_ANYCHAR_ML_STAR);
       while (DATA_ENSURE_CHECK1) {
         STACK_PUSH_ALT(p, s, sprev);
         n = enclen(encode, s);
         if (n > 1) {
           DATA_ENSURE(n);
           sprev = s;
           s += n;
         }
         else {
           sprev = s;
           s++;
         }
       }
       MOP_OUT;
       break;
     case OP_ANYCHAR_STAR_PEEK_NEXT:  MOP_IN(OP_ANYCHAR_STAR_PEEK_NEXT);
       while (DATA_ENSURE_CHECK1) {
         if (*p == *s) {
           STACK_PUSH_ALT(p + 1, s, sprev);
         }
         n = enclen(encode, s);
         DATA_ENSURE(n);
         if (ONIGENC_IS_MBC_NEWLINE(encode, s, end))  goto fail;
         sprev = s;
         s += n;
       }
       p++;
       MOP_OUT;
       break;
     case OP_ANYCHAR_ML_STAR_PEEK_NEXT:MOP_IN(OP_ANYCHAR_ML_STAR_PEEK_NEXT);
       while (DATA_ENSURE_CHECK1) {
         if (*p == *s) {
           STACK_PUSH_ALT(p + 1, s, sprev);
         }
         n = enclen(encode, s);
         if (n > 1) {
           DATA_ENSURE(n);
           sprev = s;
           s += n;
         }
         else {
           sprev = s;
           s++;
         }
       }
       p++;
       MOP_OUT;
       break;
 #ifdef USE_COMBINATION_EXPLOSION_CHECK
     case OP_STATE_CHECK_ANYCHAR_STAR:  MOP_IN(OP_STATE_CHECK_ANYCHAR_STAR);
       GET_STATE_CHECK_NUM_INC(mem, p);
       while (DATA_ENSURE_CHECK1) {
         STATE_CHECK_VAL(scv, mem);
         if (scv) goto fail;
         STACK_PUSH_ALT_WITH_STATE_CHECK(p, s, sprev, mem);
         n = enclen(encode, s);
         DATA_ENSURE(n);
         if (ONIGENC_IS_MBC_NEWLINE(encode, s, end))  goto fail;
         sprev = s;
         s += n;
       }
       MOP_OUT;
       break;
     case OP_STATE_CHECK_ANYCHAR_ML_STAR:
       MOP_IN(OP_STATE_CHECK_ANYCHAR_ML_STAR);
       GET_STATE_CHECK_NUM_INC(mem, p);
       while (DATA_ENSURE_CHECK1) {
         STATE_CHECK_VAL(scv, mem);
         if (scv) goto fail;
         STACK_PUSH_ALT_WITH_STATE_CHECK(p, s, sprev, mem);
         n = enclen(encode, s);
         if (n > 1) {
           DATA_ENSURE(n);
           sprev = s;
           s += n;
         }
         else {
           sprev = s;
           s++;
         }
       }
       MOP_OUT;
       break;
 #endif  
     case OP_WORD:  MOP_IN(OP_WORD);
       DATA_ENSURE(1);
       if (! ONIGENC_IS_MBC_WORD(encode, s, end))
         goto fail;
       s += enclen(encode, s);
       MOP_OUT;
       break;
     case OP_NOT_WORD:  MOP_IN(OP_NOT_WORD);
       DATA_ENSURE(1);
       if (ONIGENC_IS_MBC_WORD(encode, s, end))
         goto fail;
       s += enclen(encode, s);
       MOP_OUT;
       break;
     case OP_WORD_BOUND:  MOP_IN(OP_WORD_BOUND);
       if (ON_STR_BEGIN(s)) {
         DATA_ENSURE(1);
         if (! ONIGENC_IS_MBC_WORD(encode, s, end))
           goto fail;
       }
       else if (ON_STR_END(s)) {
         if (! ONIGENC_IS_MBC_WORD(encode, sprev, end))
           goto fail;
       }
       else {
         if (ONIGENC_IS_MBC_WORD(encode, s, end)
             == ONIGENC_IS_MBC_WORD(encode, sprev, end))
           goto fail;
       }
       MOP_OUT;
       continue;
       break;
     case OP_NOT_WORD_BOUND:  MOP_IN(OP_NOT_WORD_BOUND);
       if (ON_STR_BEGIN(s)) {
         if (DATA_ENSURE_CHECK1 && ONIGENC_IS_MBC_WORD(encode, s, end))
           goto fail;
       }
       else if (ON_STR_END(s)) {
         if (ONIGENC_IS_MBC_WORD(encode, sprev, end))
           goto fail;
       }
       else {
         if (ONIGENC_IS_MBC_WORD(encode, s, end)
             != ONIGENC_IS_MBC_WORD(encode, sprev, end))
           goto fail;
       }
       MOP_OUT;
       continue;
       break;
 #ifdef USE_WORD_BEGIN_END
     case OP_WORD_BEGIN:  MOP_IN(OP_WORD_BEGIN);
       if (DATA_ENSURE_CHECK1 && ONIGENC_IS_MBC_WORD(encode, s, end)) {
         if (ON_STR_BEGIN(s) || !ONIGENC_IS_MBC_WORD(encode, sprev, end)) {
           MOP_OUT;
           continue;
         }
       }
       goto fail;
       break;
     case OP_WORD_END:  MOP_IN(OP_WORD_END);
       if (!ON_STR_BEGIN(s) && ONIGENC_IS_MBC_WORD(encode, sprev, end)) {
         if (ON_STR_END(s) || !ONIGENC_IS_MBC_WORD(encode, s, end)) {
           MOP_OUT;
           continue;
         }
       }
       goto fail;
       break;
 #endif
     case OP_BEGIN_BUF:  MOP_IN(OP_BEGIN_BUF);
       if (! ON_STR_BEGIN(s)) goto fail;
       MOP_OUT;
       continue;
       break;
     case OP_END_BUF:  MOP_IN(OP_END_BUF);
       if (! ON_STR_END(s)) goto fail;
       MOP_OUT;
       continue;
       break;
     case OP_BEGIN_LINE:  MOP_IN(OP_BEGIN_LINE);
       if (ON_STR_BEGIN(s)) {
         if (IS_NOTBOL(msa->options)) goto fail;
         MOP_OUT;
         continue;
       }
       else if (ONIGENC_IS_MBC_NEWLINE(encode, sprev, end) && !ON_STR_END(s)) {
         MOP_OUT;
         continue;
       }
       goto fail;
       break;
     case OP_END_LINE:  MOP_IN(OP_END_LINE);
       if (ON_STR_END(s)) {
 #ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE
         if (IS_EMPTY_STR || !ONIGENC_IS_MBC_NEWLINE(encode, sprev, end)) {
 #endif
           if (IS_NOTEOL(msa->options)) goto fail;
           MOP_OUT;
           continue;
 #ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE
         }
 #endif
       }
       else if (ONIGENC_IS_MBC_NEWLINE(encode, s, end)) {
         MOP_OUT;
         continue;
       }
 #ifdef USE_CRNL_AS_LINE_TERMINATOR
       else if (ONIGENC_IS_MBC_CRNL(encode, s, end)) {
         MOP_OUT;
         continue;
       }
 #endif
       goto fail;
       break;
     case OP_SEMI_END_BUF:  MOP_IN(OP_SEMI_END_BUF);
       if (ON_STR_END(s)) {
 #ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE
         if (IS_EMPTY_STR || !ONIGENC_IS_MBC_NEWLINE(encode, sprev, end)) {
 #endif
           if (IS_NOTEOL(msa->options)) goto fail;
           MOP_OUT;
           continue;
 #ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE
         }
 #endif
       }
       else if (ONIGENC_IS_MBC_NEWLINE(encode, s, end) &&
                ON_STR_END(s + enclen(encode, s))) {
         MOP_OUT;
         continue;
       }
 #ifdef USE_CRNL_AS_LINE_TERMINATOR
       else if (ONIGENC_IS_MBC_CRNL(encode, s, end)) {
         UChar* ss = s + enclen(encode, s);
         ss += enclen(encode, ss);
         if (ON_STR_END(ss)) {
           MOP_OUT;
           continue;
         }
       }
 #endif
       goto fail;
       break;
     case OP_BEGIN_POSITION:  MOP_IN(OP_BEGIN_POSITION);
       if (s != msa->start)
         goto fail;
       MOP_OUT;
       continue;
       break;
     case OP_MEMORY_START_PUSH:  MOP_IN(OP_MEMORY_START_PUSH);
       GET_MEMNUM_INC(mem, p);
       STACK_PUSH_MEM_START(mem, s);
       MOP_OUT;
       continue;
       break;
     case OP_MEMORY_START:  MOP_IN(OP_MEMORY_START);
       GET_MEMNUM_INC(mem, p);
       mem_start_stk[mem] = (OnigStackIndex )((void* )s);
       MOP_OUT;
       continue;
       break;
     case OP_MEMORY_END_PUSH:  MOP_IN(OP_MEMORY_END_PUSH);
       GET_MEMNUM_INC(mem, p);
       STACK_PUSH_MEM_END(mem, s);
       MOP_OUT;
       continue;
       break;
     case OP_MEMORY_END:  MOP_IN(OP_MEMORY_END);
       GET_MEMNUM_INC(mem, p);
       mem_end_stk[mem] = (OnigStackIndex )((void* )s);
       MOP_OUT;
       continue;
       break;
 #ifdef USE_SUBEXP_CALL
     case OP_MEMORY_END_PUSH_REC:  MOP_IN(OP_MEMORY_END_PUSH_REC);
       GET_MEMNUM_INC(mem, p);
       STACK_GET_MEM_START(mem, stkp);  
       STACK_PUSH_MEM_END(mem, s);
       mem_start_stk[mem] = GET_STACK_INDEX(stkp);
       MOP_OUT;
       continue;
       break;
     case OP_MEMORY_END_REC:  MOP_IN(OP_MEMORY_END_REC);
       GET_MEMNUM_INC(mem, p);
       mem_end_stk[mem] = (OnigStackIndex )((void* )s);
       STACK_GET_MEM_START(mem, stkp);
       if (BIT_STATUS_AT(reg->bt_mem_start, mem))
         mem_start_stk[mem] = GET_STACK_INDEX(stkp);
       else
         mem_start_stk[mem] = (OnigStackIndex )((void* )stkp->u.mem.pstr);
       STACK_PUSH_MEM_END_MARK(mem);
       MOP_OUT;
       continue;
       break;
 #endif
     case OP_BACKREF1:  MOP_IN(OP_BACKREF1);
       mem = 1;
       goto backref;
       break;
     case OP_BACKREF2:  MOP_IN(OP_BACKREF2);
       mem = 2;
       goto backref;
       break;
     case OP_BACKREFN:  MOP_IN(OP_BACKREFN);
       GET_MEMNUM_INC(mem, p);
     backref:
       {
         int len;
         UChar *pstart, *pend;
         if (mem > num_mem) goto fail;
         if (mem_end_stk[mem]   == INVALID_STACK_INDEX) goto fail;
         if (mem_start_stk[mem] == INVALID_STACK_INDEX) goto fail;
         if (BIT_STATUS_AT(reg->bt_mem_start, mem))
           pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;
         else
           pstart = (UChar* )((void* )mem_start_stk[mem]);
         pend = (BIT_STATUS_AT(reg->bt_mem_end, mem)
                 ? STACK_AT(mem_end_stk[mem])->u.mem.pstr
                 : (UChar* )((void* )mem_end_stk[mem]));
         n = pend - pstart;
         DATA_ENSURE(n);
         sprev = s;
         STRING_CMP(pstart, s, n);
         while (sprev + (len = enclen(encode, sprev)) < s)
           sprev += len;
         MOP_OUT;
         continue;
       }
       break;
     case OP_BACKREFN_IC:  MOP_IN(OP_BACKREFN_IC);
       GET_MEMNUM_INC(mem, p);
       {
         int len;
         UChar *pstart, *pend;
         if (mem > num_mem) goto fail;
         if (mem_end_stk[mem]   == INVALID_STACK_INDEX) goto fail;
         if (mem_start_stk[mem] == INVALID_STACK_INDEX) goto fail;
         if (BIT_STATUS_AT(reg->bt_mem_start, mem))
           pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;
         else
           pstart = (UChar* )((void* )mem_start_stk[mem]);
         pend = (BIT_STATUS_AT(reg->bt_mem_end, mem)
                 ? STACK_AT(mem_end_stk[mem])->u.mem.pstr
                 : (UChar* )((void* )mem_end_stk[mem]));
         n = pend - pstart;
         DATA_ENSURE(n);
         sprev = s;
         STRING_CMP_IC(case_fold_flag, pstart, &s, n);
         while (sprev + (len = enclen(encode, sprev)) < s)
           sprev += len;
         MOP_OUT;
         continue;
       }
       break;
     case OP_BACKREF_MULTI:  MOP_IN(OP_BACKREF_MULTI);
       {
         int len, is_fail;
         UChar *pstart, *pend, *swork;
         GET_LENGTH_INC(tlen, p);
         for (i = 0; i < tlen; i++) {
           GET_MEMNUM_INC(mem, p);
           if (mem_end_stk[mem]   == INVALID_STACK_INDEX) continue;
           if (mem_start_stk[mem] == INVALID_STACK_INDEX) continue;
           if (BIT_STATUS_AT(reg->bt_mem_start, mem))
             pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;
           else
             pstart = (UChar* )((void* )mem_start_stk[mem]);
           pend = (BIT_STATUS_AT(reg->bt_mem_end, mem)
                   ? STACK_AT(mem_end_stk[mem])->u.mem.pstr
                   : (UChar* )((void* )mem_end_stk[mem]));
           n = pend - pstart;
           DATA_ENSURE(n);
           sprev = s;
           swork = s;
           STRING_CMP_VALUE(pstart, swork, n, is_fail);
           if (is_fail) continue;
           s = swork;
           while (sprev + (len = enclen(encode, sprev)) < s)
             sprev += len;
           p += (SIZE_MEMNUM * (tlen - i - 1));
           break;  
         }
         if (i == tlen) goto fail;
         MOP_OUT;
         continue;
       }
       break;
     case OP_BACKREF_MULTI_IC:  MOP_IN(OP_BACKREF_MULTI_IC);
       {
         int len, is_fail;
         UChar *pstart, *pend, *swork;
         GET_LENGTH_INC(tlen, p);
         for (i = 0; i < tlen; i++) {
           GET_MEMNUM_INC(mem, p);
           if (mem_end_stk[mem]   == INVALID_STACK_INDEX) continue;
           if (mem_start_stk[mem] == INVALID_STACK_INDEX) continue;
           if (BIT_STATUS_AT(reg->bt_mem_start, mem))
             pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;
           else
             pstart = (UChar* )((void* )mem_start_stk[mem]);
           pend = (BIT_STATUS_AT(reg->bt_mem_end, mem)
                   ? STACK_AT(mem_end_stk[mem])->u.mem.pstr
                   : (UChar* )((void* )mem_end_stk[mem]));
           n = pend - pstart;
           DATA_ENSURE(n);
           sprev = s;
           swork = s;
           STRING_CMP_VALUE_IC(case_fold_flag, pstart, &swork, n, is_fail);
           if (is_fail) continue;
           s = swork;
           while (sprev + (len = enclen(encode, sprev)) < s)
             sprev += len;
           p += (SIZE_MEMNUM * (tlen - i - 1));
           break;  
         }
         if (i == tlen) goto fail;
         MOP_OUT;
         continue;
       }
       break;
 #ifdef USE_BACKREF_WITH_LEVEL
     case OP_BACKREF_WITH_LEVEL:
       {
         int len;
         OnigOptionType ic;
         LengthType level;
         GET_OPTION_INC(ic,    p);
         GET_LENGTH_INC(level, p);
         GET_LENGTH_INC(tlen,  p);
         sprev = s;
         if (backref_match_at_nested_level(reg, stk, stk_base, ic
                      , case_fold_flag, (int )level, (int )tlen, p, &s, end)) {
           while (sprev + (len = enclen(encode, sprev)) < s)
             sprev += len;
           p += (SIZE_MEMNUM * tlen);
         }
         else
           goto fail;
         MOP_OUT;
         continue;
       }
       break;
 #endif
 #if 0    
     case OP_SET_OPTION_PUSH:  MOP_IN(OP_SET_OPTION_PUSH);
       GET_OPTION_INC(option, p);
       STACK_PUSH_ALT(p, s, sprev);
       p += SIZE_OP_SET_OPTION + SIZE_OP_FAIL;
       MOP_OUT;
       continue;
       break;
     case OP_SET_OPTION:  MOP_IN(OP_SET_OPTION);
       GET_OPTION_INC(option, p);
       MOP_OUT;
       continue;
       break;
 #endif
     case OP_NULL_CHECK_START:  MOP_IN(OP_NULL_CHECK_START);
       GET_MEMNUM_INC(mem, p);     
       STACK_PUSH_NULL_CHECK_START(mem, s);
       MOP_OUT;
       continue;
       break;
     case OP_NULL_CHECK_END:  MOP_IN(OP_NULL_CHECK_END);
       {
         int isnull;
         GET_MEMNUM_INC(mem, p);  
         STACK_NULL_CHECK(isnull, mem, s);
         if (isnull) {
 #ifdef ONIG_DEBUG_MATCH
           fprintf(stderr, ""NULL_CHECK_END: skip  id:%d, s:%d\n"",
                   (int )mem, (int )s);
 #endif
         null_check_found:
           switch (*p++) {
           case OP_JUMP:
           case OP_PUSH:
             p += SIZE_RELADDR;
             break;
           case OP_REPEAT_INC:
           case OP_REPEAT_INC_NG:
           case OP_REPEAT_INC_SG:
           case OP_REPEAT_INC_NG_SG:
             p += SIZE_MEMNUM;
             break;
           default:
             goto unexpected_bytecode_error;
             break;
           }
         }
       }
       MOP_OUT;
       continue;
       break;
 #ifdef USE_MONOMANIAC_CHECK_CAPTURES_IN_ENDLESS_REPEAT
     case OP_NULL_CHECK_END_MEMST:  MOP_IN(OP_NULL_CHECK_END_MEMST);
       {
         int isnull;
         GET_MEMNUM_INC(mem, p);  
         STACK_NULL_CHECK_MEMST(isnull, mem, s, reg);
         if (isnull) {
 #ifdef ONIG_DEBUG_MATCH
           fprintf(stderr, ""NULL_CHECK_END_MEMST: skip  id:%d, s:%d\n"",
                   (int )mem, (int )s);
 #endif
           if (isnull == -1) goto fail;
           goto 	null_check_found;
         }
       }
       MOP_OUT;
       continue;
       break;
 #endif
 #ifdef USE_SUBEXP_CALL
     case OP_NULL_CHECK_END_MEMST_PUSH:
       MOP_IN(OP_NULL_CHECK_END_MEMST_PUSH);
       {
         int isnull;
         GET_MEMNUM_INC(mem, p);  
 #ifdef USE_MONOMANIAC_CHECK_CAPTURES_IN_ENDLESS_REPEAT
         STACK_NULL_CHECK_MEMST_REC(isnull, mem, s, reg);
 #else
         STACK_NULL_CHECK_REC(isnull, mem, s);
 #endif
         if (isnull) {
 #ifdef ONIG_DEBUG_MATCH
           fprintf(stderr, ""NULL_CHECK_END_MEMST_PUSH: skip  id:%d, s:%d\n"",
                   (int )mem, (int )s);
 #endif
           if (isnull == -1) goto fail;
           goto 	null_check_found;
         }
         else {
           STACK_PUSH_NULL_CHECK_END(mem);
         }
       }
       MOP_OUT;
       continue;
       break;
 #endif
     case OP_JUMP:  MOP_IN(OP_JUMP);
       GET_RELADDR_INC(addr, p);
       p += addr;
       MOP_OUT;
       CHECK_INTERRUPT_IN_MATCH_AT;
       continue;
       break;
     case OP_PUSH:  MOP_IN(OP_PUSH);
       GET_RELADDR_INC(addr, p);
       STACK_PUSH_ALT(p + addr, s, sprev);
       MOP_OUT;
       continue;
       break;
 #ifdef USE_COMBINATION_EXPLOSION_CHECK
     case OP_STATE_CHECK_PUSH:  MOP_IN(OP_STATE_CHECK_PUSH);
       GET_STATE_CHECK_NUM_INC(mem, p);
       STATE_CHECK_VAL(scv, mem);
       if (scv) goto fail;
       GET_RELADDR_INC(addr, p);
       STACK_PUSH_ALT_WITH_STATE_CHECK(p + addr, s, sprev, mem);
       MOP_OUT;
       continue;
       break;
     case OP_STATE_CHECK_PUSH_OR_JUMP:  MOP_IN(OP_STATE_CHECK_PUSH_OR_JUMP);
       GET_STATE_CHECK_NUM_INC(mem, p);
       GET_RELADDR_INC(addr, p);
       STATE_CHECK_VAL(scv, mem);
       if (scv) {
         p += addr;
       }
       else {
         STACK_PUSH_ALT_WITH_STATE_CHECK(p + addr, s, sprev, mem);
       }
       MOP_OUT;
       continue;
       break;
     case OP_STATE_CHECK:  MOP_IN(OP_STATE_CHECK);
       GET_STATE_CHECK_NUM_INC(mem, p);
       STATE_CHECK_VAL(scv, mem);
       if (scv) goto fail;
       STACK_PUSH_STATE_CHECK(s, mem);
       MOP_OUT;
       continue;
       break;
 #endif  
     case OP_POP:  MOP_IN(OP_POP);
       STACK_POP_ONE;
       MOP_OUT;
       continue;
       break;
     case OP_PUSH_OR_JUMP_EXACT1:  MOP_IN(OP_PUSH_OR_JUMP_EXACT1);
       GET_RELADDR_INC(addr, p);
       if (*p == *s && DATA_ENSURE_CHECK1) {
         p++;
         STACK_PUSH_ALT(p + addr, s, sprev);
         MOP_OUT;
         continue;
       }
       p += (addr + 1);
       MOP_OUT;
       continue;
       break;
     case OP_PUSH_IF_PEEK_NEXT:  MOP_IN(OP_PUSH_IF_PEEK_NEXT);
       GET_RELADDR_INC(addr, p);
       if (*p == *s) {
         p++;
         STACK_PUSH_ALT(p + addr, s, sprev);
         MOP_OUT;
         continue;
       }
       p++;
       MOP_OUT;
       continue;
       break;
     case OP_REPEAT:  MOP_IN(OP_REPEAT);
       {
         GET_MEMNUM_INC(mem, p);     
         GET_RELADDR_INC(addr, p);
         STACK_ENSURE(1);
         repeat_stk[mem] = GET_STACK_INDEX(stk);
         STACK_PUSH_REPEAT(mem, p);
         if (reg->repeat_range[mem].lower == 0) {
           STACK_PUSH_ALT(p + addr, s, sprev);
         }
       }
       MOP_OUT;
       continue;
       break;
     case OP_REPEAT_NG:  MOP_IN(OP_REPEAT_NG);
       {
         GET_MEMNUM_INC(mem, p);     
         GET_RELADDR_INC(addr, p);
         STACK_ENSURE(1);
         repeat_stk[mem] = GET_STACK_INDEX(stk);
         STACK_PUSH_REPEAT(mem, p);
         if (reg->repeat_range[mem].lower == 0) {
           STACK_PUSH_ALT(p, s, sprev);
           p += addr;
         }
       }
       MOP_OUT;
       continue;
       break;
     case OP_REPEAT_INC:  MOP_IN(OP_REPEAT_INC);
       GET_MEMNUM_INC(mem, p);  
       si = repeat_stk[mem];
       stkp = STACK_AT(si);
     repeat_inc:
       stkp->u.repeat.count++;
       if (stkp->u.repeat.count >= reg->repeat_range[mem].upper) {
       }
       else if (stkp->u.repeat.count >= reg->repeat_range[mem].lower) {
         STACK_PUSH_ALT(p, s, sprev);
         p = STACK_AT(si)->u.repeat.pcode;  
       }
       else {
         p = stkp->u.repeat.pcode;
       }
       STACK_PUSH_REPEAT_INC(si);
       MOP_OUT;
       CHECK_INTERRUPT_IN_MATCH_AT;
       continue;
       break;
     case OP_REPEAT_INC_SG:  MOP_IN(OP_REPEAT_INC_SG);
       GET_MEMNUM_INC(mem, p);  
       STACK_GET_REPEAT(mem, stkp);
       si = GET_STACK_INDEX(stkp);
       goto repeat_inc;
       break;
     case OP_REPEAT_INC_NG:  MOP_IN(OP_REPEAT_INC_NG);
       GET_MEMNUM_INC(mem, p);  
       si = repeat_stk[mem];
       stkp = STACK_AT(si);
     repeat_inc_ng:
       stkp->u.repeat.count++;
       if (stkp->u.repeat.count < reg->repeat_range[mem].upper) {
         if (stkp->u.repeat.count >= reg->repeat_range[mem].lower) {
           UChar* pcode = stkp->u.repeat.pcode;
           STACK_PUSH_REPEAT_INC(si);
           STACK_PUSH_ALT(pcode, s, sprev);
         }
         else {
           p = stkp->u.repeat.pcode;
           STACK_PUSH_REPEAT_INC(si);
         }
       }
       else if (stkp->u.repeat.count == reg->repeat_range[mem].upper) {
         STACK_PUSH_REPEAT_INC(si);
       }
       MOP_OUT;
       CHECK_INTERRUPT_IN_MATCH_AT;
       continue;
       break;
     case OP_REPEAT_INC_NG_SG:  MOP_IN(OP_REPEAT_INC_NG_SG);
       GET_MEMNUM_INC(mem, p);  
       STACK_GET_REPEAT(mem, stkp);
       si = GET_STACK_INDEX(stkp);
       goto repeat_inc_ng;
       break;
     case OP_PUSH_POS:  MOP_IN(OP_PUSH_POS);
       STACK_PUSH_POS(s, sprev);
       MOP_OUT;
       continue;
       break;
     case OP_POP_POS:  MOP_IN(OP_POP_POS);
       {
         STACK_POS_END(stkp);
         s     = stkp->u.state.pstr;
         sprev = stkp->u.state.pstr_prev;
       }
       MOP_OUT;
       continue;
       break;
     case OP_PUSH_POS_NOT:  MOP_IN(OP_PUSH_POS_NOT);
       GET_RELADDR_INC(addr, p);
       STACK_PUSH_POS_NOT(p + addr, s, sprev);
       MOP_OUT;
       continue;
       break;
     case OP_FAIL_POS:  MOP_IN(OP_FAIL_POS);
       STACK_POP_TIL_POS_NOT;
       goto fail;
       break;
     case OP_PUSH_STOP_BT:  MOP_IN(OP_PUSH_STOP_BT);
       STACK_PUSH_STOP_BT;
       MOP_OUT;
       continue;
       break;
     case OP_POP_STOP_BT:  MOP_IN(OP_POP_STOP_BT);
       STACK_STOP_BT_END;
       MOP_OUT;
       continue;
       break;
     case OP_LOOK_BEHIND:  MOP_IN(OP_LOOK_BEHIND);
       GET_LENGTH_INC(tlen, p);
       s = (UChar* )ONIGENC_STEP_BACK(encode, str, s, (int )tlen);
       if (IS_NULL(s)) goto fail;
       sprev = (UChar* )onigenc_get_prev_char_head(encode, str, s);
       MOP_OUT;
       continue;
       break;
     case OP_PUSH_LOOK_BEHIND_NOT:  MOP_IN(OP_PUSH_LOOK_BEHIND_NOT);
       GET_RELADDR_INC(addr, p);
       GET_LENGTH_INC(tlen, p);
       q = (UChar* )ONIGENC_STEP_BACK(encode, str, s, (int )tlen);
       if (IS_NULL(q)) {
         p += addr;
       }
       else {
         STACK_PUSH_LOOK_BEHIND_NOT(p + addr, s, sprev);
         s = q;
         sprev = (UChar* )onigenc_get_prev_char_head(encode, str, s);
       }
       MOP_OUT;
       continue;
       break;
     case OP_FAIL_LOOK_BEHIND_NOT:  MOP_IN(OP_FAIL_LOOK_BEHIND_NOT);
       STACK_POP_TIL_LOOK_BEHIND_NOT;
       goto fail;
       break;
 #ifdef USE_SUBEXP_CALL
     case OP_CALL:  MOP_IN(OP_CALL);
       GET_ABSADDR_INC(addr, p);
       STACK_PUSH_CALL_FRAME(p);
       p = reg->p + addr;
       MOP_OUT;
       continue;
       break;
     case OP_RETURN:  MOP_IN(OP_RETURN);
       STACK_RETURN(p);
       STACK_PUSH_RETURN;
       MOP_OUT;
       continue;
       break;
 #endif
     case OP_FINISH:
       goto finish;
       break;
     fail:
       MOP_OUT;
     case OP_FAIL:  MOP_IN(OP_FAIL);
       STACK_POP;
       p     = stk->u.state.pcode;
       s     = stk->u.state.pstr;
       sprev = stk->u.state.pstr_prev;
 #ifdef USE_COMBINATION_EXPLOSION_CHECK
       if (stk->u.state.state_check != 0) {
         stk->type = STK_STATE_CHECK_MARK;
         stk++;
       }
 #endif
       MOP_OUT;
       continue;
       break;
     default:
       goto bytecode_error;
     }  
     sprev = sbegin;
   }  
  finish:
   STACK_SAVE;
   return best_len;
 #ifdef ONIG_DEBUG
  stack_error:
   STACK_SAVE;
   return ONIGERR_STACK_BUG;
 #endif
  bytecode_error:
   STACK_SAVE;
   return ONIGERR_UNDEFINED_BYTECODE;
  unexpected_bytecode_error:
   STACK_SAVE;
   return ONIGERR_UNEXPECTED_BYTECODE;
 }","[167, 171, 172, 173, 174]","An issue was discovered in Oniguruma 6.2.0, as used in Oniguruma-mod in Ruby through 2.4.1 and mbstring in PHP through 7.1.5. A stack out-of-bounds read occurs in match_at() during regular expression searching. A logical error involving order of validation and access in match_at() could result in an out-of-bounds read from a stack buffer.",oniguruma,CVE-2017-9224,CWE-125
2273,182845," static size_t ZSTD_encodeSequences(
             void* dst, size_t dstCapacity,
             FSE_CTable const* CTable_MatchLength, BYTE const* mlCodeTable,
             FSE_CTable const* CTable_OffsetBits, BYTE const* ofCodeTable,
              FSE_CTable const* CTable_LitLength, BYTE const* llCodeTable,
              seqDef const* sequences, size_t nbSeq, int longOffsets, int bmi2)
  {
     DEBUGLOG(5, ""ZSTD_encodeSequences: dstCapacity = %u"", (unsigned)dstCapacity);
  #if DYNAMIC_BMI2
      if (bmi2) {
          return ZSTD_encodeSequences_bmi2(dst, dstCapacity,
                                          CTable_MatchLength, mlCodeTable,
                                          CTable_OffsetBits, ofCodeTable,
                                          CTable_LitLength, llCodeTable,
                                          sequences, nbSeq, longOffsets);
     }
 #endif
     (void)bmi2;
     return ZSTD_encodeSequences_default(dst, dstCapacity,
                                         CTable_MatchLength, mlCodeTable,
                                         CTable_OffsetBits, ofCodeTable,
                                         CTable_LitLength, llCodeTable,
                                         sequences, nbSeq, longOffsets);
 }",[8],A race condition in the one-pass compression functions of Zstandard prior to version 1.3.8 could allow an attacker to write bytes out of bounds if an output buffer smaller than the recommended size was used.,zstd,CVE-2019-11922,CWE-362
2296,181510," int write_output(void)
 {
    int fd;
    struct filter_op *fop;
    struct filter_header fh;
    size_t ninst, i;
    u_char *data;
    ninst = compile_tree(&fop);
     if (fop == NULL)
        return -E_NOTHANDLED;
    if (ninst == 0)
       return -E_INVALID;
     fd = open(EF_GBL_OPTIONS->output_file, O_CREAT | O_RDWR | O_TRUNC | O_BINARY, 0644);
     ON_ERROR(fd, -1, ""Can't create file %s"", EF_GBL_OPTIONS->output_file);
    fprintf(stdout, "" Writing output to \'%s\' "", EF_GBL_OPTIONS->output_file);
    fflush(stdout);
    fh.magic = htons(EC_FILTER_MAGIC);
    strncpy(fh.version, EC_VERSION, sizeof(fh.version));
    fh.data = sizeof(fh);
    data = create_data_segment(&fh, fop, ninst);
    write(fd, &fh, sizeof(struct filter_header));
    write(fd, data, fh.code - fh.data);
    for (i = 0; i <= ninst; i++) {
       print_progress_bar(&fop[i]);
       write(fd, &fop[i], sizeof(struct filter_op));
    }
    close(fd);
    fprintf(stdout, "" done.\n\n"");
    fprintf(stdout, "" -> Script encoded into %d instructions.\n\n"", (int)(i - 1));
    return E_SUCCESS;
 }","[11, 12]",The compile_tree function in ef_compiler.c in the Etterfilter utility in Ettercap 0.8.2 and earlier allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted filter.,ettercap,CVE-2017-6430,CWE-125
2298,180950," static int ivr_read_header(AVFormatContext *s)
 {
     unsigned tag, type, len, tlen, value;
     int i, j, n, count, nb_streams = 0, ret;
     uint8_t key[256], val[256];
     AVIOContext *pb = s->pb;
     AVStream *st;
     int64_t pos, offset, temp;
     pos = avio_tell(pb);
     tag = avio_rl32(pb);
     if (tag == MKTAG('.','R','1','M')) {
         if (avio_rb16(pb) != 1)
             return AVERROR_INVALIDDATA;
         if (avio_r8(pb) != 1)
             return AVERROR_INVALIDDATA;
         len = avio_rb32(pb);
         avio_skip(pb, len);
         avio_skip(pb, 5);
         temp = avio_rb64(pb);
         while (!avio_feof(pb) && temp) {
             offset = temp;
             temp = avio_rb64(pb);
         }
         avio_skip(pb, offset - avio_tell(pb));
         if (avio_r8(pb) != 1)
             return AVERROR_INVALIDDATA;
         len = avio_rb32(pb);
         avio_skip(pb, len);
         if (avio_r8(pb) != 2)
             return AVERROR_INVALIDDATA;
         avio_skip(pb, 16);
         pos = avio_tell(pb);
         tag = avio_rl32(pb);
     }
     if (tag != MKTAG('.','R','E','C'))
         return AVERROR_INVALIDDATA;
     if (avio_r8(pb) != 0)
         return AVERROR_INVALIDDATA;
     count = avio_rb32(pb);
     for (i = 0; i < count; i++) {
         if (avio_feof(pb))
             return AVERROR_INVALIDDATA;
         type = avio_r8(pb);
         tlen = avio_rb32(pb);
         avio_get_str(pb, tlen, key, sizeof(key));
         len = avio_rb32(pb);
         if (type == 5) {
             avio_get_str(pb, len, val, sizeof(val));
              av_log(s, AV_LOG_DEBUG, ""%s = '%s'\n"", key, val);
          } else if (type == 4) {
              av_log(s, AV_LOG_DEBUG, ""%s = '0x"", key);
            for (j = 0; j < len; j++)
             for (j = 0; j < len; j++) {
                 if (avio_feof(pb))
                     return AVERROR_INVALIDDATA;
                  av_log(s, AV_LOG_DEBUG, ""%X"", avio_r8(pb));
             }
              av_log(s, AV_LOG_DEBUG, ""'\n"");
          } else if (len == 4 && type == 3 && !strncmp(key, ""StreamCount"", tlen)) {
              nb_streams = value = avio_rb32(pb);
         } else if (len == 4 && type == 3) {
             value = avio_rb32(pb);
             av_log(s, AV_LOG_DEBUG, ""%s = %d\n"", key, value);
         } else {
             av_log(s, AV_LOG_DEBUG, ""Skipping unsupported key: %s\n"", key);
             avio_skip(pb, len);
         }
     }
     for (n = 0; n < nb_streams; n++) {
         st = avformat_new_stream(s, NULL);
         if (!st)
             return AVERROR(ENOMEM);
         st->priv_data = ff_rm_alloc_rmstream();
         if (!st->priv_data)
             return AVERROR(ENOMEM);
         if (avio_r8(pb) != 1)
             return AVERROR_INVALIDDATA;
         count = avio_rb32(pb);
         for (i = 0; i < count; i++) {
             if (avio_feof(pb))
                 return AVERROR_INVALIDDATA;
             type = avio_r8(pb);
             tlen  = avio_rb32(pb);
             avio_get_str(pb, tlen, key, sizeof(key));
             len  = avio_rb32(pb);
             if (type == 5) {
                 avio_get_str(pb, len, val, sizeof(val));
                 av_log(s, AV_LOG_DEBUG, ""%s = '%s'\n"", key, val);
             } else if (type == 4 && !strncmp(key, ""OpaqueData"", tlen)) {
                 ret = ffio_ensure_seekback(pb, 4);
                 if (ret < 0)
                     return ret;
                 if (avio_rb32(pb) == MKBETAG('M', 'L', 'T', 'I')) {
                     ret = rm_read_multi(s, pb, st, NULL);
                 } else {
                     avio_seek(pb, -4, SEEK_CUR);
                     ret = ff_rm_read_mdpr_codecdata(s, pb, st, st->priv_data, len, NULL);
                 }
                 if (ret < 0)
                     return ret;
             } else if (type == 4) {
                 int j;
                 av_log(s, AV_LOG_DEBUG, ""%s = '0x"", key);
                 for (j = 0; j < len; j++)
                     av_log(s, AV_LOG_DEBUG, ""%X"", avio_r8(pb));
                 av_log(s, AV_LOG_DEBUG, ""'\n"");
             } else if (len == 4 && type == 3 && !strncmp(key, ""Duration"", tlen)) {
                 st->duration = avio_rb32(pb);
             } else if (len == 4 && type == 3) {
                 value = avio_rb32(pb);
                 av_log(s, AV_LOG_DEBUG, ""%s = %d\n"", key, value);
             } else {
                 av_log(s, AV_LOG_DEBUG, ""Skipping unsupported key: %s\n"", key);
                 avio_skip(pb, len);
             }
         }
     }
     if (avio_r8(pb) != 6)
         return AVERROR_INVALIDDATA;
     avio_skip(pb, 12);
     avio_skip(pb, avio_rb64(pb) + pos - avio_tell(s->pb));
     if (avio_r8(pb) != 8)
         return AVERROR_INVALIDDATA;
     avio_skip(pb, 8);
     return 0;
 }","[52, 53, 54, 55, 57]","In libavformat/rmdec.c in FFmpeg 3.3.3, a DoS in ivr_read_header() due to lack of an EOF (End of File) check might cause huge CPU consumption. When a crafted IVR file, which claims a large *len* field in the header but does not contain sufficient backing data, is provided, the first type==4 loop would consume huge CPU resources, since there is no EOF check inside the loop.",FFmpeg,CVE-2017-14054,CWE-834
2307,181925," jp2_box_t *jp2_box_get(jas_stream_t *in)
 {
 	jp2_box_t *box;
 	jp2_boxinfo_t *boxinfo;
 	jas_stream_t *tmpstream;
 	uint_fast32_t len;
 	uint_fast64_t extlen;
 	bool dataflag;
 	box = 0;
 	tmpstream = 0;
 	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
 		goto error;
 	}
 	box->ops = &jp2_boxinfo_unk.ops;
 	if (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {
 		goto error;
 	}
 	boxinfo = jp2_boxinfolookup(box->type);
  	box->info = boxinfo;
  	box->ops = &boxinfo->ops;
  	box->len = len;
 	JAS_DBGLOG(10, (
 	  ""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\n"",
 	  '""', boxinfo->name, '""', box->type, box->len
 	  ));
  	if (box->len == 1) {
  		if (jp2_getuint64(in, &extlen)) {
  			goto error;
 		}
 		if (extlen > 0xffffffffUL) {
 			jas_eprintf(""warning: cannot handle large 64-bit box length\n"");
 			extlen = 0xffffffffUL;
 		}
 		box->len = extlen;
 		box->datalen = extlen - JP2_BOX_HDRLEN(true);
 	} else {
 		box->datalen = box->len - JP2_BOX_HDRLEN(false);
 	}
 	if (box->len != 0 && box->len < 8) {
 		goto error;
 	}
 	dataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));
 	if (dataflag) {
 		if (!(tmpstream = jas_stream_memopen(0, 0))) {
  			goto error;
  		}
  		if (jas_stream_copy(tmpstream, in, box->datalen)) {
 			box->ops = &jp2_boxinfo_unk.ops;
  			jas_eprintf(""cannot copy box data\n"");
  			goto error;
  		}
 		jas_stream_rewind(tmpstream);
 		if (box->ops->getdata) {
 			if ((*box->ops->getdata)(box, tmpstream)) {
 				jas_eprintf(""cannot parse box data\n"");
 				goto error;
 			}
 		}
 		jas_stream_close(tmpstream);
 	}
 	if (jas_getdbglevel() >= 1) {
 		jp2_box_dump(box, stderr);
 	}
 	return box;
 error:
 	if (box) {
 		jp2_box_destroy(box);
 	}
 	if (tmpstream) {
 		jas_stream_close(tmpstream);
 	}
 	return 0;
 }","[22, 23, 24, 25, 48]",The jp2_colr_destroy function in libjasper/jp2/jp2_cod.c in JasPer before 1.900.10 allows remote attackers to cause a denial of service (NULL pointer dereference).,jasper,CVE-2016-8887,CWE-476
2326,182083," static void print_value(int output, int num, const char *devname,
 			const char *value, const char *name, size_t valsz)
 {
 	if (output & OUTPUT_VALUE_ONLY) {
 		fputs(value, stdout);
 		fputc('\n', stdout);
 	} else if (output & OUTPUT_UDEV_LIST) {
 		print_udev_format(name, value);
 	} else if (output & OUTPUT_EXPORT_LIST) {
 		if (num == 1 && devname)
  			printf(""DEVNAME=%s\n"", devname);
  		fputs(name, stdout);
  		fputs(""="", stdout);
		safe_print(value, valsz, NULL);
 		safe_print(value, valsz, "" \\\""'$`<>"");
  		fputs(""\n"", stdout);
  	} else {
 		if (num == 1 && devname)
 			printf(""%s:"", devname);
  		fputs("" "", stdout);
  		fputs(name, stdout);
  		fputs(""=\"""", stdout);
		safe_print(value, valsz, ""\"""");
 		safe_print(value, valsz, ""\""\\"");
  		fputs(""\"""", stdout);
  	}
  }","[14, 15, 23, 24]",Blkid in util-linux before 2.26rc-1 allows local users to execute arbitrary code.,util-linux,CVE-2014-9114,CWE-77
2359,181271," int _yr_scan_match_callback(
     uint8_t* match_data,
     int32_t match_length,
     int flags,
     void* args)
 {
   CALLBACK_ARGS* callback_args = (CALLBACK_ARGS*) args;
   YR_STRING* string = callback_args->string;
   YR_MATCH* new_match;
   int result = ERROR_SUCCESS;
   int tidx = callback_args->context->tidx;
   size_t match_offset = match_data - callback_args->data;
    match_length += callback_args->forward_matches;
   assert(match_offset + match_length <= callback_args->data_size);
    if (callback_args->full_word)
    {
      if (flags & RE_FLAGS_WIDE)
     {
       if (match_offset >= 2 &&
           *(match_data - 1) == 0 &&
           isalnum(*(match_data - 2)))
         return ERROR_SUCCESS;
       if (match_offset + match_length + 1 < callback_args->data_size &&
           *(match_data + match_length + 1) == 0 &&
           isalnum(*(match_data + match_length)))
         return ERROR_SUCCESS;
     }
     else
     {
       if (match_offset >= 1 &&
           isalnum(*(match_data - 1)))
         return ERROR_SUCCESS;
       if (match_offset + match_length < callback_args->data_size &&
           isalnum(*(match_data + match_length)))
         return ERROR_SUCCESS;
     }
   }
   if (STRING_IS_CHAIN_PART(string))
   {
     result = _yr_scan_verify_chained_string_match(
         string,
         callback_args->context,
         match_data,
         callback_args->data_base,
         match_offset,
         match_length);
   }
   else
   {
     if (string->matches[tidx].count == 0)
     {
       FAIL_ON_ERROR(yr_arena_write_data(
           callback_args->context->matching_strings_arena,
           &string,
           sizeof(string),
           NULL));
     }
     FAIL_ON_ERROR(yr_arena_allocate_memory(
         callback_args->context->matches_arena,
         sizeof(YR_MATCH),
         (void**) &new_match));
     new_match->data_length = yr_min(match_length, MAX_MATCH_DATA);
     FAIL_ON_ERROR(yr_arena_write_data(
         callback_args->context->matches_arena,
         match_data,
         new_match->data_length,
         (void**) &new_match->data));
     if (result == ERROR_SUCCESS)
     {
       new_match->base = callback_args->data_base;
       new_match->offset = match_offset;
       new_match->match_length = match_length;
       new_match->prev = NULL;
       new_match->next = NULL;
       FAIL_ON_ERROR(_yr_scan_add_match_to_list(
           new_match,
           &string->matches[tidx],
           STRING_IS_GREEDY_REGEXP(string)));
     }
   }
   return result;
 }",[14],The yr_arena_write_data function in YARA 3.6.1 allows remote attackers to cause a denial of service (buffer over-read and application crash) or obtain sensitive information from process memory via a crafted file that is mishandled in the yr_re_fast_exec function in libyara/re.c and the _yr_scan_match_callback function in libyara/scan.c.,yara,CVE-2017-9465,CWE-125
2361,182977," rdpdr_process(STREAM s)
 {
 	uint32 handle;
  	uint16 vmin;
  	uint16 component;
  	uint16 pakid;
 	struct stream packet = *s;
  	logger(Protocol, Debug, ""rdpdr_process()"");
 	in_uint16(s, component);
 	in_uint16(s, pakid);
 	if (component == RDPDR_CTYP_CORE)
 	{
 		switch (pakid)
 		{
 			case PAKID_CORE_DEVICE_IOREQUEST:
 				rdpdr_process_irp(s);
 				break;
 			case PAKID_CORE_SERVER_ANNOUNCE:
  				in_uint8s(s, 2);	 
  				in_uint16_le(s, vmin);	 
  				in_uint32_le(s, g_client_id);	 
 				if (!s_check(s))
 				{
 					rdp_protocol_error(""rdpdr_process(), consume of g_client_id from stream did overrun"", &packet);
 				}
  				if (vmin < 0x000c)
 					g_client_id = 0x815ed39d;	 
 				g_epoch++;
 #if WITH_SCARD
 				scard_release_all_contexts();
 #endif
 				rdpdr_send_client_announce_reply();
 				rdpdr_send_client_name_request();
 				break;
 			case PAKID_CORE_CLIENTID_CONFIRM:
 				rdpdr_send_client_device_list_announce();
 				break;
 			case PAKID_CORE_DEVICE_REPLY:
 				in_uint32(s, handle);
 				logger(Protocol, Debug,
 				       ""rdpdr_process(), server connected to resource %d"", handle);
 				break;
 			case PAKID_CORE_SERVER_CAPABILITY:
 				rdpdr_send_client_capability_response();
 				break;
 			default:
 				logger(Protocol, Debug,
 				       ""rdpdr_process(), pakid 0x%x of component 0x%x"", pakid,
 				       component);
 				break;
 		}
 	}
 	else if (component == RDPDR_CTYP_PRN)
 	{
 		if (pakid == PAKID_PRN_CACHE_DATA)
 			printercache_process(s);
 	}
 	else
 		logger(Protocol, Warning, ""rdpdr_process(), unhandled component 0x%x"", component);
 }","[7, 22, 23, 24, 25]",rdesktop versions up to and including v1.8.3 contain a Buffer Overflow over the global variables in the function seamless_process_line() that results in memory corruption and probably even a remote code execution.,rdesktop,CVE-2018-20182,CWE-119
2375,181877," int jas_matrix_resize(jas_matrix_t *matrix, int numrows, int numcols)
 int jas_matrix_resize(jas_matrix_t *matrix, jas_matind_t numrows,
   jas_matind_t numcols)
  {
	int size;
	int i;
 	jas_matind_t size;
 	jas_matind_t i;
  	size = numrows * numcols;
  	if (size > matrix->datasize_ || numrows > matrix->maxrows_) {
 		return -1;
 	}
 	matrix->numrows_ = numrows;
 	matrix->numcols_ = numcols;
 	for (i = 0; i < numrows; ++i) {
 		matrix->rows_[i] = &matrix->data_[numcols * i];
 	}
 	return 0;
 }","[2, 3, 5, 6, 7, 8]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
2395,179498," fep_client_open (const char *address)
 {
   FepClient *client;
   struct sockaddr_un sun;
   ssize_t sun_len;
   int retval;
   if (!address)
     address = getenv (""LIBFEP_CONTROL_SOCK"");
   if (!address)
     return NULL;
   if (strlen (address) + 1 >= sizeof(sun.sun_path))
     {
       fep_log (FEP_LOG_LEVEL_WARNING,
 	       ""unix domain socket path too long: %d + 1 >= %d"",
 	       strlen (address),
 	       sizeof (sun.sun_path));
       free (address);
       return NULL;
     }
   client = xzalloc (sizeof(FepClient));
   client->filter_running = false;
   client->messages = NULL;
    memset (&sun, 0, sizeof(struct sockaddr_un));
    sun.sun_family = AF_UNIX;
#ifdef __linux__
  sun.sun_path[0] = '\0';
  memcpy (sun.sun_path + 1, address, strlen (address));
  sun_len = offsetof (struct sockaddr_un, sun_path) + strlen (address) + 1;
#else
    memcpy (sun.sun_path, address, strlen (address));
    sun_len = sizeof (struct sockaddr_un);
#endif
    client->control = socket (AF_UNIX, SOCK_STREAM, 0);
    if (client->control < 0)
     {
       free (client);
       return NULL;
     }
   retval = connect (client->control,
 		    (const struct sockaddr *) &sun,
 		    sun_len);
   if (retval < 0)
     {
       close (client->control);
       free (client);
       return NULL;
     }
   return client;
 }","[25, 26, 27, 28, 29, 32]","libfep 0.0.5 before 0.1.0 does not properly use UNIX domain sockets in the abstract namespace, which allows local users to gain privileges via unspecified vectors.",libfep,CVE-2014-3980,CWE-264
2396,182383,"  void jslGetTokenString(char *str, size_t len) {
    if (lex->tk == LEX_ID) {
    strncpy(str, ""ID:"", len);
    strncat(str, jslGetTokenValueAsString(), len);
     espruino_snprintf(str, len, ""ID:%s"", jslGetTokenValueAsString());
    } else if (lex->tk == LEX_STR) {
    strncpy(str, ""String:'"", len);
    strncat(str, jslGetTokenValueAsString(), len);
    strncat(str, ""'"", len);
     espruino_snprintf(str, len, ""String:'%s'"", jslGetTokenValueAsString());
    } else
      jslTokenAsString(lex->tk, str, len);
  }","[3, 4, 5, 7, 8, 9, 10]","Espruino before 1.99 allows attackers to cause a denial of service (application crash) and a potential Escalation of Privileges with a user crafted input file via a Buffer Overflow during syntax parsing, because strncat is misused.",Espruino,CVE-2018-11595,CWE-119
2401,178821,"  char *suhosin_decrypt_single_cookie(char *name, int name_len, char *value, int value_len, char *key, char **where TSRMLS_DC)
  {
	char buffer[4096];
    char buffer2[4096];
      int o_name_len = name_len;
	char *buf = buffer, *buf2 = buffer2, *d, *d_url;
 	char *buf, *buf2, *d, *d_url;
  	int l;
	if (name_len > sizeof(buffer)-2) {
		buf = estrndup(name, name_len);
	} else {
		memcpy(buf, name, name_len);
		buf[name_len] = 0;
	}
 	buf = estrndup(name, name_len);
  	name_len = php_url_decode(buf, name_len);
    normalize_varname(buf);
    name_len = strlen(buf);
 	normalize_varname(buf);
 	name_len = strlen(buf);
  	if (SUHOSIN_G(cookie_plainlist)) {
  		if (zend_hash_exists(SUHOSIN_G(cookie_plainlist), buf, name_len+1)) {
  decrypt_return_plain:
			if (buf != buffer) {
				efree(buf);
			}
 			efree(buf);
              memcpy(*where, name, o_name_len);
              *where += o_name_len;
              **where = '='; *where +=1;
 	        memcpy(*where, value, value_len);
 	        *where += value_len;
 			return *where;
 		}
 	} else if (SUHOSIN_G(cookie_cryptlist)) {
 		if (!zend_hash_exists(SUHOSIN_G(cookie_cryptlist), buf, name_len+1)) {
 			goto decrypt_return_plain;
 		}
  	}
	if (strlen(value) <= sizeof(buffer2)-2) {
		memcpy(buf2, value, value_len);
		buf2[value_len] = 0;
	} else {
		buf2 = estrndup(value, value_len);
	}
 	buf2 = estrndup(value, value_len);
  	value_len = php_url_decode(buf2, value_len);
 	d = suhosin_decrypt_string(buf2, value_len, buf, name_len, key, &l, SUHOSIN_G(cookie_checkraddr) TSRMLS_CC);
     if (d == NULL) {
         goto skip_cookie;
     }
 	d_url = php_url_encode(d, l, &l);
 	efree(d);
     memcpy(*where, name, o_name_len);
     *where += o_name_len;
     **where = '=';*where += 1;
 	memcpy(*where, d_url, l);
  	*where += l;
  	efree(d_url);
  skip_cookie:
	if (buf != buffer) {
		efree(buf);
	}
	if (buf2 != buffer2) {
		efree(buf2);
	}
 	efree(buf);
 	efree(buf2);
  	return *where;
  }","[3, 4, 6, 7, 9, 10, 11, 12, 13, 14, 15, 17, 18, 19, 20, 24, 25, 26, 27, 40, 41, 42, 43, 44, 45, 46, 61, 62, 63, 64, 65, 66, 67, 68]","Stack-based buffer overflow in the suhosin_encrypt_single_cookie function in the transparent cookie-encryption feature in the Suhosin extension before 0.9.33 for PHP, when suhosin.cookie.encrypt and suhosin.multiheader are enabled, might allow remote attackers to execute arbitrary code via a long string that is used in a Set-Cookie HTTP header.",suhosin,CVE-2012-0807,CWE-119
2407,182385," NO_INLINE JsVar *jspeArrowFunction(JsVar *funcVar, JsVar *a) {
   assert(!a || jsvIsName(a));
   JSP_ASSERT_MATCH(LEX_ARROW_FUNCTION);
   funcVar = jspeAddNamedFunctionParameter(funcVar, a);
   bool expressionOnly = lex->tk!='{';
   jspeFunctionDefinitionInternal(funcVar, expressionOnly);
   if (execInfo.thisVar) {
     jsvObjectSetChild(funcVar, JSPARSE_FUNCTION_THIS_NAME, execInfo.thisVar);
   }
   return funcVar;
 }
 NO_INLINE JsVar *jspeExpressionOrArrowFunction() {
   JsVar *a = 0;
   JsVar *funcVar = 0;
   bool allNames = true;
   while (lex->tk!=')' && !JSP_SHOULDNT_PARSE) {
     if (allNames && a) {
       funcVar = jspeAddNamedFunctionParameter(funcVar, a);
     }
     jsvUnLock(a);
     a = jspeAssignmentExpression();
     if (!(jsvIsName(a) && jsvIsString(a))) allNames = false;
     if (lex->tk!=')') JSP_MATCH_WITH_CLEANUP_AND_RETURN(',', jsvUnLock2(a,funcVar), 0);
   }
   JSP_MATCH_WITH_CLEANUP_AND_RETURN(')', jsvUnLock2(a,funcVar), 0);
   if (allNames && lex->tk==LEX_ARROW_FUNCTION) {
     funcVar = jspeArrowFunction(funcVar, a);
     jsvUnLock(a);
     return funcVar;
   } else {
     jsvUnLock(funcVar);
     return a;
   }
 }
 NO_INLINE JsVar *jspeClassDefinition(bool parseNamedClass) {
   JsVar *classFunction = 0;
   JsVar *classPrototype = 0;
   JsVar *classInternalName = 0;
   bool actuallyCreateClass = JSP_SHOULD_EXECUTE;
   if (actuallyCreateClass)
     classFunction = jsvNewWithFlags(JSV_FUNCTION);
   if (parseNamedClass && lex->tk==LEX_ID) {
     if (classFunction)
       classInternalName = jslGetTokenValueAsVar(lex);
     JSP_ASSERT_MATCH(LEX_ID);
   }
   if (classFunction) {
     JsVar *prototypeName = jsvFindChildFromString(classFunction, JSPARSE_PROTOTYPE_VAR, true);
     jspEnsureIsPrototype(classFunction, prototypeName);  
     classPrototype = jsvSkipName(prototypeName);
     jsvUnLock(prototypeName);
   }
   if (lex->tk==LEX_R_EXTENDS) {
     JSP_ASSERT_MATCH(LEX_R_EXTENDS);
     JsVar *extendsFrom = actuallyCreateClass ? jsvSkipNameAndUnLock(jspGetNamedVariable(jslGetTokenValueAsString(lex))) : 0;
     JSP_MATCH_WITH_CLEANUP_AND_RETURN(LEX_ID,jsvUnLock4(extendsFrom,classFunction,classInternalName,classPrototype),0);
     if (classPrototype) {
       if (jsvIsFunction(extendsFrom)) {
         jsvObjectSetChild(classPrototype, JSPARSE_INHERITS_VAR, extendsFrom);
         jsvObjectSetChildAndUnLock(classFunction, JSPARSE_FUNCTION_CODE_NAME, jsvNewFromString(""if(this.__proto__.__proto__)this.__proto__.__proto__.apply(this,arguments)""));
       } else
         jsExceptionHere(JSET_SYNTAXERROR, ""'extends' argument should be a function, got %t"", extendsFrom);
     }
     jsvUnLock(extendsFrom);
   }
   JSP_MATCH_WITH_CLEANUP_AND_RETURN('{',jsvUnLock3(classFunction,classInternalName,classPrototype),0);
   while ((lex->tk==LEX_ID || lex->tk==LEX_R_STATIC) && !jspIsInterrupted()) {
     bool isStatic = lex->tk==LEX_R_STATIC;
     if (isStatic) JSP_ASSERT_MATCH(LEX_R_STATIC);
     JsVar *funcName = jslGetTokenValueAsVar(lex);
     JSP_MATCH_WITH_CLEANUP_AND_RETURN(LEX_ID,jsvUnLock3(classFunction,classInternalName,classPrototype),0);
     JsVar *method = jspeFunctionDefinition(false);
     if (classFunction && classPrototype) {
       if (jsvIsStringEqual(funcName, ""get"") || jsvIsStringEqual(funcName, ""set"")) {
         jsExceptionHere(JSET_SYNTAXERROR, ""'get' and 'set' and not supported in Espruino"");
       } else if (jsvIsStringEqual(funcName, ""constructor"")) {
         jswrap_function_replaceWith(classFunction, method);
       } else {
         funcName = jsvMakeIntoVariableName(funcName, 0);
         jsvSetValueOfName(funcName, method);
         jsvAddName(isStatic ? classFunction : classPrototype, funcName);
       }
     }
     jsvUnLock2(method,funcName);
   }
   jsvUnLock(classPrototype);
   if (classInternalName)
     jsvObjectSetChildAndUnLock(classFunction, JSPARSE_FUNCTION_NAME_NAME, classInternalName);
   JSP_MATCH_WITH_CLEANUP_AND_RETURN('}',jsvUnLock(classFunction),0);
   return classFunction;
 }
 #endif
 NO_INLINE JsVar *jspeFactor() {
   if (lex->tk==LEX_ID) {
     JsVar *a = jspGetNamedVariable(jslGetTokenValueAsString(lex));
     JSP_ASSERT_MATCH(LEX_ID);
 #ifndef SAVE_ON_FLASH
     if (lex->tk==LEX_TEMPLATE_LITERAL)
       jsExceptionHere(JSET_SYNTAXERROR, ""Tagged template literals not supported"");
     else if (lex->tk==LEX_ARROW_FUNCTION && jsvIsName(a)) {
       JsVar *funcVar = jspeArrowFunction(0,a);
       jsvUnLock(a);
       a=funcVar;
     }
 #endif
     return a;
   } else if (lex->tk==LEX_INT) {
     JsVar *v = 0;
     if (JSP_SHOULD_EXECUTE) {
       v = jsvNewFromLongInteger(stringToInt(jslGetTokenValueAsString(lex)));
     }
     JSP_ASSERT_MATCH(LEX_INT);
     return v;
   } else if (lex->tk==LEX_FLOAT) {
     JsVar *v = 0;
     if (JSP_SHOULD_EXECUTE) {
       v = jsvNewFromFloat(stringToFloat(jslGetTokenValueAsString(lex)));
     }
     JSP_ASSERT_MATCH(LEX_FLOAT);
     return v;
   } else if (lex->tk=='(') {
     JSP_ASSERT_MATCH('(');
     if (!jspCheckStackPosition()) return 0;
 #ifdef SAVE_ON_FLASH
     JsVar *a = jspeExpression();
     if (!JSP_SHOULDNT_PARSE) JSP_MATCH_WITH_RETURN(')',a);
     return a;
 #else
     return jspeExpressionOrArrowFunction();
 #endif
   } else if (lex->tk==LEX_R_TRUE) {
     JSP_ASSERT_MATCH(LEX_R_TRUE);
     return JSP_SHOULD_EXECUTE ? jsvNewFromBool(true) : 0;
   } else if (lex->tk==LEX_R_FALSE) {
     JSP_ASSERT_MATCH(LEX_R_FALSE);
     return JSP_SHOULD_EXECUTE ? jsvNewFromBool(false) : 0;
   } else if (lex->tk==LEX_R_NULL) {
     JSP_ASSERT_MATCH(LEX_R_NULL);
     return JSP_SHOULD_EXECUTE ? jsvNewWithFlags(JSV_NULL) : 0;
   } else if (lex->tk==LEX_R_UNDEFINED) {
     JSP_ASSERT_MATCH(LEX_R_UNDEFINED);
     return 0;
   } else if (lex->tk==LEX_STR) {
     JsVar *a = 0;
     if (JSP_SHOULD_EXECUTE)
       a = jslGetTokenValueAsVar(lex);
     JSP_ASSERT_MATCH(LEX_STR);
     return a;
 #ifndef SAVE_ON_FLASH
   } else if (lex->tk==LEX_TEMPLATE_LITERAL) {
     return jspeTemplateLiteral();
 #endif
   } else if (lex->tk==LEX_REGEX) {
     JsVar *a = 0;
 #ifdef SAVE_ON_FLASH
     jsExceptionHere(JSET_SYNTAXERROR, ""RegEx are not supported in this version of Espruino\n"");
 #else
     JsVar *regex = jslGetTokenValueAsVar(lex);
     size_t regexEnd = 0, regexLen = 0;
     JsvStringIterator it;
     jsvStringIteratorNew(&it, regex, 0);
     while (jsvStringIteratorHasChar(&it)) {
       regexLen++;
       if (jsvStringIteratorGetChar(&it)=='/')
         regexEnd = regexLen;
       jsvStringIteratorNext(&it);
     }
     jsvStringIteratorFree(&it);
     JsVar *flags = 0;
     if (regexEnd < regexLen)
       flags = jsvNewFromStringVar(regex, regexEnd, JSVAPPENDSTRINGVAR_MAXLENGTH);
     JsVar *regexSource = jsvNewFromStringVar(regex, 1, regexEnd-2);
     a = jswrap_regexp_constructor(regexSource, flags);
     jsvUnLock3(regex, flags, regexSource);
 #endif
     JSP_ASSERT_MATCH(LEX_REGEX);
     return a;
   } else if (lex->tk=='{') {
     if (!jspCheckStackPosition()) return 0;
     return jspeFactorObject();
   } else if (lex->tk=='[') {
     if (!jspCheckStackPosition()) return 0;
     return jspeFactorArray();
   } else if (lex->tk==LEX_R_FUNCTION) {
     if (!jspCheckStackPosition()) return 0;
     JSP_ASSERT_MATCH(LEX_R_FUNCTION);
     return jspeFunctionDefinition(true);
 #ifndef SAVE_ON_FLASH
   } else if (lex->tk==LEX_R_CLASS) {
     if (!jspCheckStackPosition()) return 0;
     JSP_ASSERT_MATCH(LEX_R_CLASS);
     return jspeClassDefinition(true);
   } else if (lex->tk==LEX_R_SUPER) {
     JSP_ASSERT_MATCH(LEX_R_SUPER);
     if (jsvIsObject(execInfo.thisVar)) {
       JsVar *proto1 = jsvObjectGetChild(execInfo.thisVar, JSPARSE_INHERITS_VAR, 0);  
       JsVar *proto2 = jsvIsObject(proto1) ? jsvObjectGetChild(proto1, JSPARSE_INHERITS_VAR, 0) : 0;  
       jsvUnLock(proto1);
       if (!proto2) {
         jsExceptionHere(JSET_SYNTAXERROR, ""Calling 'super' outside of class"");
         return 0;
       }
       if (lex->tk=='(') return proto2;  
       JsVar *proto3 = jsvIsFunction(proto2) ? jsvObjectGetChild(proto2, JSPARSE_PROTOTYPE_VAR, 0) : 0;
       jsvUnLock(proto2);
       return proto3;
     } else if (jsvIsFunction(execInfo.thisVar)) {
       JsVar *proto1 = jsvObjectGetChild(execInfo.thisVar, JSPARSE_PROTOTYPE_VAR, 0);
       JsVar *proto2 = jsvIsObject(proto1) ? jsvObjectGetChild(proto1, JSPARSE_INHERITS_VAR, 0) : 0;
       jsvUnLock(proto1);
       if (!proto2) {
         jsExceptionHere(JSET_SYNTAXERROR, ""Calling 'super' outside of class"");
         return 0;
       }
       return proto2;
     }
     jsExceptionHere(JSET_SYNTAXERROR, ""Calling 'super' outside of class"");
     return 0;
 #endif
   } else if (lex->tk==LEX_R_THIS) {
     JSP_ASSERT_MATCH(LEX_R_THIS);
     return jsvLockAgain( execInfo.thisVar ? execInfo.thisVar : execInfo.root );
   } else if (lex->tk==LEX_R_DELETE) {
     if (!jspCheckStackPosition()) return 0;
     return jspeFactorDelete();
   } else if (lex->tk==LEX_R_TYPEOF) {
      if (!jspCheckStackPosition()) return 0;
      return jspeFactorTypeOf();
    } else if (lex->tk==LEX_R_VOID) {
     if (!jspCheckStackPosition()) return 0;
      JSP_ASSERT_MATCH(LEX_R_VOID);
      jsvUnLock(jspeUnaryExpression());
      return 0;
   }
   JSP_MATCH(LEX_EOF);
   jsExceptionHere(JSET_SYNTAXERROR, ""Unexpected end of Input\n"");
   return 0;
 }
 NO_INLINE JsVar *__jspePostfixExpression(JsVar *a) {
   while (lex->tk==LEX_PLUSPLUS || lex->tk==LEX_MINUSMINUS) {
     int op = lex->tk;
     JSP_ASSERT_MATCH(op);
     if (JSP_SHOULD_EXECUTE) {
       JsVar *one = jsvNewFromInteger(1);
       JsVar *oldValue = jsvAsNumberAndUnLock(jsvSkipName(a));  
       JsVar *res = jsvMathsOpSkipNames(oldValue, one, op==LEX_PLUSPLUS ? '+' : '-');
       jsvUnLock(one);
       jspReplaceWith(a, res);
       jsvUnLock(res);
       jsvUnLock(a);
       a = oldValue;
     }
   }
   return a;
 }
 NO_INLINE JsVar *jspePostfixExpression() {
   JsVar *a;
   if (lex->tk==LEX_PLUSPLUS || lex->tk==LEX_MINUSMINUS) {
     int op = lex->tk;
     JSP_ASSERT_MATCH(op);
     a = jspePostfixExpression();
     if (JSP_SHOULD_EXECUTE) {
       JsVar *one = jsvNewFromInteger(1);
       JsVar *res = jsvMathsOpSkipNames(a, one, op==LEX_PLUSPLUS ? '+' : '-');
       jsvUnLock(one);
       jspReplaceWith(a, res);
       jsvUnLock(res);
     }
   } else
     a = jspeFactorFunctionCall();
   return __jspePostfixExpression(a);
 }
 NO_INLINE JsVar *jspeUnaryExpression() {
   if (lex->tk=='!' || lex->tk=='~' || lex->tk=='-' || lex->tk=='+') {
     short tk = lex->tk;
     JSP_ASSERT_MATCH(tk);
     if (!JSP_SHOULD_EXECUTE) {
       return jspeUnaryExpression();
     }
     if (tk=='!') {  
       return jsvNewFromBool(!jsvGetBoolAndUnLock(jsvSkipNameAndUnLock(jspeUnaryExpression())));
     } else if (tk=='~') {  
       return jsvNewFromInteger(~jsvGetIntegerAndUnLock(jsvSkipNameAndUnLock(jspeUnaryExpression())));
     } else if (tk=='-') {  
       return jsvNegateAndUnLock(jspeUnaryExpression());  
     }  else if (tk=='+') {  
       JsVar *v = jsvSkipNameAndUnLock(jspeUnaryExpression());
       JsVar *r = jsvAsNumber(v);  
       jsvUnLock(v);
       return r;
     }
     assert(0);
     return 0;
   } else
     return jspePostfixExpression();
 }
 unsigned int jspeGetBinaryExpressionPrecedence(int op) {
   switch (op) {
   case LEX_OROR: return 1; break;
   case LEX_ANDAND: return 2; break;
   case '|' : return 3; break;
   case '^' : return 4; break;
   case '&' : return 5; break;
   case LEX_EQUAL:
   case LEX_NEQUAL:
   case LEX_TYPEEQUAL:
   case LEX_NTYPEEQUAL: return 6;
   case LEX_LEQUAL:
   case LEX_GEQUAL:
   case '<':
   case '>':
   case LEX_R_INSTANCEOF: return 7;
   case LEX_R_IN: return (execInfo.execute&EXEC_FOR_INIT)?0:7;
   case LEX_LSHIFT:
   case LEX_RSHIFT:
   case LEX_RSHIFTUNSIGNED: return 8;
   case '+':
   case '-': return 9;
   case '*':
   case '/':
   case '%': return 10;
   default: return 0;
   }
 }
 NO_INLINE JsVar *__jspeBinaryExpression(JsVar *a, unsigned int lastPrecedence) {
   unsigned int precedence = jspeGetBinaryExpressionPrecedence(lex->tk);
   while (precedence && precedence>lastPrecedence) {
     int op = lex->tk;
     JSP_ASSERT_MATCH(op);
     if (op==LEX_ANDAND || op==LEX_OROR) {
       bool aValue = jsvGetBoolAndUnLock(jsvSkipName(a));
       if ((!aValue && op==LEX_ANDAND) ||
           (aValue && op==LEX_OROR)) {
         JSP_SAVE_EXECUTE();
         jspSetNoExecute();
         jsvUnLock(__jspeBinaryExpression(jspeUnaryExpression(),precedence));
         JSP_RESTORE_EXECUTE();
       } else {
         jsvUnLock(a);
         a = __jspeBinaryExpression(jspeUnaryExpression(),precedence);
       }
     } else {  
       JsVar *b = __jspeBinaryExpression(jspeUnaryExpression(),precedence);
       if (JSP_SHOULD_EXECUTE) {
         if (op==LEX_R_IN) {
           JsVar *av = jsvSkipName(a);  
           JsVar *bv = jsvSkipName(b);  
           if (jsvIsArray(bv) || jsvIsObject(bv)) {  
             av = jsvAsArrayIndexAndUnLock(av);
             JsVar *varFound = jspGetVarNamedField( bv, av, true);
             jsvUnLock(a);
             a = jsvNewFromBool(varFound!=0);
             jsvUnLock(varFound);
           } else { 
             jsExceptionHere(JSET_ERROR, ""Cannot use 'in' operator to search a %t"", bv);
             jsvUnLock(a);
             a = 0;
           }
           jsvUnLock2(av, bv);
         } else if (op==LEX_R_INSTANCEOF) {
           bool inst = false;
           JsVar *av = jsvSkipName(a);
           JsVar *bv = jsvSkipName(b);
           if (!jsvIsFunction(bv)) {
             jsExceptionHere(JSET_ERROR, ""Expecting a function on RHS in instanceof check, got %t"", bv);
           } else {
             if (jsvIsObject(av) || jsvIsFunction(av)) {
               JsVar *bproto = jspGetNamedField(bv, JSPARSE_PROTOTYPE_VAR, false);
               JsVar *proto = jsvObjectGetChild(av, JSPARSE_INHERITS_VAR, 0);
               while (proto) {
                 if (proto == bproto) inst=true;
                 JsVar *childProto = jsvObjectGetChild(proto, JSPARSE_INHERITS_VAR, 0);
                 jsvUnLock(proto);
                 proto = childProto;
               }
               if (jspIsConstructor(bv, ""Object"")) inst = true;
               jsvUnLock(bproto);
             }
             if (!inst) {
               const char *name = jswGetBasicObjectName(av);
               if (name) {
                 inst = jspIsConstructor(bv, name);
               }
               if (!inst && (jsvIsArray(av) || jsvIsArrayBuffer(av)) &&
                   jspIsConstructor(bv, ""Object""))
                 inst = true;
             }
           }
           jsvUnLock3(av, bv, a);
           a = jsvNewFromBool(inst);
         } else {   
           JsVar *res = jsvMathsOpSkipNames(a, b, op);
           jsvUnLock(a); a = res;
         }
       }
       jsvUnLock(b);
     }
     precedence = jspeGetBinaryExpressionPrecedence(lex->tk);
   }
   return a;
 }
 JsVar *jspeBinaryExpression() {
   return __jspeBinaryExpression(jspeUnaryExpression(),0);
 }
 NO_INLINE JsVar *__jspeConditionalExpression(JsVar *lhs) {
   if (lex->tk=='?') {
     JSP_ASSERT_MATCH('?');
     if (!JSP_SHOULD_EXECUTE) {
       jsvUnLock(jspeAssignmentExpression());
       JSP_MATCH(':');
       jsvUnLock(jspeAssignmentExpression());
     } else {
       bool first = jsvGetBoolAndUnLock(jsvSkipName(lhs));
       jsvUnLock(lhs);
       if (first) {
         lhs = jspeAssignmentExpression();
         JSP_MATCH(':');
         JSP_SAVE_EXECUTE();
         jspSetNoExecute();
         jsvUnLock(jspeAssignmentExpression());
         JSP_RESTORE_EXECUTE();
       } else {
         JSP_SAVE_EXECUTE();
         jspSetNoExecute();
         jsvUnLock(jspeAssignmentExpression());
         JSP_RESTORE_EXECUTE();
         JSP_MATCH(':');
         lhs = jspeAssignmentExpression();
       }
     }
   }
   return lhs;
 }
 JsVar *jspeConditionalExpression() {
   return __jspeConditionalExpression(jspeBinaryExpression());
 }
 NO_INLINE JsVar *__jspeAssignmentExpression(JsVar *lhs) {
   if (lex->tk=='=' || lex->tk==LEX_PLUSEQUAL || lex->tk==LEX_MINUSEQUAL ||
       lex->tk==LEX_MULEQUAL || lex->tk==LEX_DIVEQUAL || lex->tk==LEX_MODEQUAL ||
       lex->tk==LEX_ANDEQUAL || lex->tk==LEX_OREQUAL ||
       lex->tk==LEX_XOREQUAL || lex->tk==LEX_RSHIFTEQUAL ||
       lex->tk==LEX_LSHIFTEQUAL || lex->tk==LEX_RSHIFTUNSIGNEDEQUAL) {
     JsVar *rhs;
     int op = lex->tk;
     JSP_ASSERT_MATCH(op);
     rhs = jspeAssignmentExpression();
     rhs = jsvSkipNameAndUnLock(rhs);  
     if (JSP_SHOULD_EXECUTE && lhs) {
       if (op=='=') {
         if (!jsvGetRefs(lhs) && jsvIsName(lhs)) {
           if (!jsvIsArrayBufferName(lhs) && !jsvIsNewChild(lhs))
             jsvAddName(execInfo.root, lhs);
         }
         jspReplaceWith(lhs, rhs);
       } else {
         if (op==LEX_PLUSEQUAL) op='+';
         else if (op==LEX_MINUSEQUAL) op='-';
         else if (op==LEX_MULEQUAL) op='*';
         else if (op==LEX_DIVEQUAL) op='/';
         else if (op==LEX_MODEQUAL) op='%';
         else if (op==LEX_ANDEQUAL) op='&';
         else if (op==LEX_OREQUAL) op='|';
         else if (op==LEX_XOREQUAL) op='^';
         else if (op==LEX_RSHIFTEQUAL) op=LEX_RSHIFT;
         else if (op==LEX_LSHIFTEQUAL) op=LEX_LSHIFT;
         else if (op==LEX_RSHIFTUNSIGNEDEQUAL) op=LEX_RSHIFTUNSIGNED;
         if (op=='+' && jsvIsName(lhs)) {
           JsVar *currentValue = jsvSkipName(lhs);
           if (jsvIsString(currentValue) && !jsvIsFlatString(currentValue) && jsvGetRefs(currentValue)==1 && rhs!=currentValue) {
             JsVar *str = jsvAsString(rhs, false);
             jsvAppendStringVarComplete(currentValue, str);
             jsvUnLock(str);
             op = 0;
           }
           jsvUnLock(currentValue);
         }
         if (op) {
           JsVar *res = jsvMathsOpSkipNames(lhs,rhs,op);
           jspReplaceWith(lhs, res);
           jsvUnLock(res);
         }
       }
     }
     jsvUnLock(rhs);
   }
   return lhs;
 }
 JsVar *jspeAssignmentExpression() {
   return __jspeAssignmentExpression(jspeConditionalExpression());
 }
 NO_INLINE JsVar *jspeExpression() {
   while (!JSP_SHOULDNT_PARSE) {
     JsVar *a = jspeAssignmentExpression();
     if (lex->tk!=',') return a;
     jsvUnLock(a);
     JSP_ASSERT_MATCH(',');
   }
   return 0;
 }
 NO_INLINE void jspeBlockNoBrackets() {
   if (JSP_SHOULD_EXECUTE) {
     while (lex->tk && lex->tk!='}') {
       jsvUnLock(jspeStatement());
       if (JSP_HAS_ERROR) {
         if (lex && !(execInfo.execute&EXEC_ERROR_LINE_REPORTED)) {
           execInfo.execute = (JsExecFlags)(execInfo.execute | EXEC_ERROR_LINE_REPORTED);
           JsVar *stackTrace = jsvObjectGetChild(execInfo.hiddenRoot, JSPARSE_STACKTRACE_VAR, JSV_STRING_0);
           if (stackTrace) {
             jsvAppendPrintf(stackTrace, ""at "");
             jspAppendStackTrace(stackTrace);
             jsvUnLock(stackTrace);
           }
         }
       }
       if (JSP_SHOULDNT_PARSE)
         return;
     }
   } else {
     int brackets = 0;
     while (lex->tk && (brackets || lex->tk != '}')) {
       if (lex->tk == '{') brackets++;
       if (lex->tk == '}') brackets--;
       JSP_ASSERT_MATCH(lex->tk);
     }
   }
   return;
 }",[230],Espruino before 1.99 allows attackers to cause a denial of service (application crash) with a user crafted input file via a Buffer Overflow during syntax parsing of *VOID* tokens in jsparse.c.,Espruino,CVE-2018-11594,CWE-119
2442,181173," int ff_amf_get_field_value(const uint8_t *data, const uint8_t *data_end,
 static int amf_get_field_value2(GetByteContext *gb,
                             const uint8_t *name, uint8_t *dst, int dst_size)
  {
      int namelen = strlen(name);
      int len;
    while (*data != AMF_DATA_TYPE_OBJECT && data < data_end) {
        len = ff_amf_tag_size(data, data_end);
        if (len < 0)
            len = data_end - data;
        data += len;
     while (bytestream2_peek_byte(gb) != AMF_DATA_TYPE_OBJECT && bytestream2_get_bytes_left(gb) > 0) {
         int ret = amf_tag_skip(gb);
         if (ret < 0)
             return -1;
      }
    if (data_end - data < 3)
     if (bytestream2_get_bytes_left(gb) < 3)
          return -1;
    data++;
     bytestream2_get_byte(gb);
      for (;;) {
        int size = bytestream_get_be16(&data);
         int size = bytestream2_get_be16(gb);
          if (!size)
              break;
        if (size < 0 || size >= data_end - data)
         if (size < 0 || size >= bytestream2_get_bytes_left(gb))
              return -1;
        data += size;
        if (size == namelen && !memcmp(data-size, name, namelen)) {
            switch (*data++) {
         bytestream2_skip(gb, size);
         if (size == namelen && !memcmp(gb->buffer-size, name, namelen)) {
             switch (bytestream2_get_byte(gb)) {
              case AMF_DATA_TYPE_NUMBER:
                snprintf(dst, dst_size, ""%g"", av_int2double(AV_RB64(data)));
                 snprintf(dst, dst_size, ""%g"", av_int2double(bytestream2_get_be64(gb)));
                  break;
              case AMF_DATA_TYPE_BOOL:
                snprintf(dst, dst_size, ""%s"", *data ? ""true"" : ""false"");
                 snprintf(dst, dst_size, ""%s"", bytestream2_get_byte(gb) ? ""true"" : ""false"");
                  break;
              case AMF_DATA_TYPE_STRING:
                len = bytestream_get_be16(&data);
                av_strlcpy(dst, data, FFMIN(len+1, dst_size));
                 len = bytestream2_get_be16(gb);
                 if (dst_size < 1)
                     return -1;
                 if (dst_size < len + 1)
                     len = dst_size - 1;
                 bytestream2_get_buffer(gb, dst, len);
                 dst[len] = 0;
                  break;
              default:
                  return -1;
              }
              return 0;
          }
        len = ff_amf_tag_size(data, data_end);
        if (len < 0 || len >= data_end - data)
         len = amf_tag_skip(gb);
         if (len < 0 || bytestream2_get_bytes_left(gb) <= 0)
              return -1;
        data += len;
      }
      return -1;
  }","[2, 7, 8, 9, 10, 11, 12, 13, 14, 15, 17, 18, 20, 21, 23, 24, 27, 28, 30, 31, 32, 33, 34, 35, 37, 38, 41, 42, 45, 46, 47, 48, 49, 50, 51, 52, 53, 60, 61, 62, 63, 65]",The ff_amf_get_field_value function in libavformat/rtmppkt.c in FFmpeg 3.3.2 allows remote RTMP servers to cause a denial of service (Segmentation Violation and application crash) via a crafted stream.,FFmpeg,CVE-2017-11665,CWE-20
2446,182961," Bool GPAC_EventProc(void *ptr, GF_Event *evt)
 {
 	if (!term) return 0;
 	if (gui_mode==1) {
 		if (evt->type==GF_EVENT_QUIT) {
 			Run = 0;
 		} else if (evt->type==GF_EVENT_KEYDOWN) {
 			switch (evt->key.key_code) {
 			case GF_KEY_C:
 				if (evt->key.flags & (GF_KEY_MOD_CTRL|GF_KEY_MOD_ALT)) {
 					hide_shell(shell_visible ? 1 : 0);
 					if (shell_visible) gui_mode=2;
 				}
 				break;
 			default:
 				break;
 			}
 		}
 		return 0;
 	}
 	switch (evt->type) {
 	case GF_EVENT_DURATION:
 		Duration = (u64) ( 1000 * (s64) evt->duration.duration);
 		CanSeek = evt->duration.can_seek;
 		break;
 	case GF_EVENT_MESSAGE:
 	{
 		const char *servName;
 		if (!evt->message.service || !strcmp(evt->message.service, the_url)) {
 			servName = """";
 		} else if (!strnicmp(evt->message.service, ""data:"", 5)) {
 			servName = ""(embedded data)"";
 		} else {
 			servName = evt->message.service;
 		}
 		if (!evt->message.message) return 0;
 		if (evt->message.error) {
 			if (!is_connected) last_error = evt->message.error;
 			if (evt->message.error==GF_SCRIPT_INFO) {
 				GF_LOG(GF_LOG_INFO, GF_LOG_CONSOLE, (""%s\n"", evt->message.message));
 			} else {
 				GF_LOG(GF_LOG_ERROR, GF_LOG_CONSOLE, (""%s %s: %s\n"", servName, evt->message.message, gf_error_to_string(evt->message.error)));
 			}
 		} else if (!be_quiet)
 			GF_LOG(GF_LOG_INFO, GF_LOG_CONSOLE, (""%s %s\n"", servName, evt->message.message));
 	}
 	break;
 	case GF_EVENT_PROGRESS:
 	{
 		char *szTitle = """";
 		if (evt->progress.progress_type==0) {
 			szTitle = ""Buffer "";
 			if (bench_mode && (bench_mode!=3) ) {
 				if (evt->progress.done >= evt->progress.total) bench_buffer = 0;
 				else bench_buffer = 1 + 100*evt->progress.done / evt->progress.total;
 				break;
 			}
 		}
 		else if (evt->progress.progress_type==1) {
 			if (bench_mode) break;
 			szTitle = ""Download "";
 		}
 		else if (evt->progress.progress_type==2) szTitle = ""Import "";
 		gf_set_progress(szTitle, evt->progress.done, evt->progress.total);
 	}
 	break;
 	case GF_EVENT_DBLCLICK:
 		gf_term_set_option(term, GF_OPT_FULLSCREEN, !gf_term_get_option(term, GF_OPT_FULLSCREEN));
 		return 0;
 	case GF_EVENT_MOUSEDOWN:
 		if (evt->mouse.button==GF_MOUSE_RIGHT) {
 			right_down = 1;
 			last_x = evt->mouse.x;
 			last_y = evt->mouse.y;
 		}
 		return 0;
 	case GF_EVENT_MOUSEUP:
 		if (evt->mouse.button==GF_MOUSE_RIGHT) {
 			right_down = 0;
 			last_x = evt->mouse.x;
 			last_y = evt->mouse.y;
 		}
 		return 0;
 	case GF_EVENT_MOUSEMOVE:
 		if (right_down && (user.init_flags & GF_TERM_WINDOWLESS) ) {
 			GF_Event move;
 			move.move.x = evt->mouse.x - last_x;
 			move.move.y = last_y-evt->mouse.y;
 			move.type = GF_EVENT_MOVE;
 			move.move.relative = 1;
 			gf_term_user_event(term, &move);
 		}
 		return 0;
 	case GF_EVENT_KEYUP:
 		switch (evt->key.key_code) {
 		case GF_KEY_SPACE:
 			if (evt->key.flags & GF_KEY_MOD_CTRL) switch_bench(!bench_mode);
 			break;
 		}
 		break;
 	case GF_EVENT_KEYDOWN:
 		gf_term_process_shortcut(term, evt);
 		switch (evt->key.key_code) {
 		case GF_KEY_SPACE:
 			if (evt->key.flags & GF_KEY_MOD_CTRL) {
 				if (!bench_mode) switch_bench(!bench_mode);
 			}
 			break;
 		case GF_KEY_PAGEDOWN:
 		case GF_KEY_MEDIANEXTTRACK:
 			request_next_playlist_item = 1;
 			break;
 		case GF_KEY_MEDIAPREVIOUSTRACK:
 			break;
 		case GF_KEY_ESCAPE:
 			gf_term_set_option(term, GF_OPT_FULLSCREEN, !gf_term_get_option(term, GF_OPT_FULLSCREEN));
 			break;
 		case GF_KEY_C:
 			if (evt->key.flags & (GF_KEY_MOD_CTRL|GF_KEY_MOD_ALT)) {
 				hide_shell(shell_visible ? 1 : 0);
 				if (!shell_visible) gui_mode=1;
 			}
 			break;
 		case GF_KEY_F:
 			if (evt->key.flags & GF_KEY_MOD_CTRL) fprintf(stderr, ""Rendering rate: %f FPS\n"", gf_term_get_framerate(term, 0));
 			break;
 		case GF_KEY_T:
 			if (evt->key.flags & GF_KEY_MOD_CTRL) fprintf(stderr, ""Scene Time: %f \n"", gf_term_get_time_in_ms(term)/1000.0);
 			break;
 		case GF_KEY_D:
 			if (evt->key.flags & GF_KEY_MOD_CTRL) gf_term_set_option(term, GF_OPT_DRAW_MODE, (gf_term_get_option(term, GF_OPT_DRAW_MODE)==GF_DRAW_MODE_DEFER) ? GF_DRAW_MODE_IMMEDIATE : GF_DRAW_MODE_DEFER );
 			break;
 		case GF_KEY_4:
 			if (evt->key.flags & GF_KEY_MOD_CTRL)
 				gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_4_3);
 			break;
 		case GF_KEY_5:
 			if (evt->key.flags & GF_KEY_MOD_CTRL)
 				gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_16_9);
 			break;
 		case GF_KEY_6:
 			if (evt->key.flags & GF_KEY_MOD_CTRL)
 				gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);
 			break;
 		case GF_KEY_7:
 			if (evt->key.flags & GF_KEY_MOD_CTRL)
 				gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_KEEP);
 			break;
 		case GF_KEY_O:
 			if ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {
 				if (gf_term_get_option(term, GF_OPT_MAIN_ADDON)) {
 					fprintf(stderr, ""Resuming to main content\n"");
 					gf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_PLAY_LIVE);
 				} else {
 					fprintf(stderr, ""Main addon not enabled\n"");
 				}
 			}
 			break;
 		case GF_KEY_P:
 			if ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {
 				u32 pause_state = gf_term_get_option(term, GF_OPT_PLAY_STATE) ;
 				fprintf(stderr, ""[Status: %s]\n"", pause_state ? ""Playing"" : ""Paused"");
 				if ((pause_state == GF_STATE_PAUSED) && (evt->key.flags & GF_KEY_MOD_SHIFT)) {
 					gf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_PLAY_LIVE);
 				} else {
 					gf_term_set_option(term, GF_OPT_PLAY_STATE, (pause_state==GF_STATE_PAUSED) ? GF_STATE_PLAYING : GF_STATE_PAUSED);
 				}
 			}
 			break;
 		case GF_KEY_S:
 			if ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {
 				gf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_STEP_PAUSE);
 				fprintf(stderr, ""Step time: "");
 				PrintTime(gf_term_get_time_in_ms(term));
 				fprintf(stderr, ""\n"");
 			}
 			break;
 		case GF_KEY_B:
 			if ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected)
 				ViewODs(term, 1);
 			break;
 		case GF_KEY_M:
 			if ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected)
 				ViewODs(term, 0);
 			break;
 		case GF_KEY_H:
 			if ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {
 				gf_term_switch_quality(term, 1);
 			}
 			break;
 		case GF_KEY_L:
 			if ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {
 				gf_term_switch_quality(term, 0);
 			}
 			break;
 		case GF_KEY_F5:
 			if (is_connected)
 				reload = 1;
 			break;
 		case GF_KEY_A:
 			addon_visible = !addon_visible;
 			gf_term_toggle_addons(term, addon_visible);
 			break;
 		case GF_KEY_UP:
 			if ((evt->key.flags & VK_MOD) && is_connected) {
 				do_set_speed(playback_speed * 2);
 			}
 			break;
 		case GF_KEY_DOWN:
 			if ((evt->key.flags & VK_MOD) && is_connected) {
 				do_set_speed(playback_speed / 2);
 			}
 			break;
 		case GF_KEY_LEFT:
 			if ((evt->key.flags & VK_MOD) && is_connected) {
 				do_set_speed(-1 * playback_speed );
 			}
 			break;
 		}
 		break;
 	case GF_EVENT_CONNECT:
 		if (evt->connect.is_connected) {
 			is_connected = 1;
 			fprintf(stderr, ""Service Connected\n"");
 			eos_seen = GF_FALSE;
 			if (playback_speed != FIX_ONE)
 				gf_term_set_speed(term, playback_speed);
 		} else if (is_connected) {
 			fprintf(stderr, ""Service %s\n"", is_connected ? ""Disconnected"" : ""Connection Failed"");
 			is_connected = 0;
 			Duration = 0;
 		}
 		if (init_w && init_h) {
 			gf_term_set_size(term, init_w, init_h);
 		}
 		ResetCaption();
 		break;
 	case GF_EVENT_EOS:
 		eos_seen = GF_TRUE;
 		if (playlist) {
 			if (Duration>1500)
 				request_next_playlist_item = GF_TRUE;
 		}
 		else if (loop_at_end) {
 			restart = 1;
 		}
 		break;
 	case GF_EVENT_SIZE:
 		if (user.init_flags & GF_TERM_WINDOWLESS) {
 			GF_Event move;
 			move.type = GF_EVENT_MOVE;
 			move.move.align_x = align_mode & 0xFF;
 			move.move.align_y = (align_mode>>8) & 0xFF;
 			move.move.relative = 2;
 			gf_term_user_event(term, &move);
 		}
 		break;
 	case GF_EVENT_SCENE_SIZE:
 		if (forced_width && forced_height) {
 			GF_Event size;
 			size.type = GF_EVENT_SIZE;
 			size.size.width = forced_width;
 			size.size.height = forced_height;
 			gf_term_user_event(term, &size);
 		}
 		break;
 	case GF_EVENT_METADATA:
 		ResetCaption();
 		break;
 	case GF_EVENT_RELOAD:
 		if (is_connected)
 			reload = 1;
 		break;
 	case GF_EVENT_DROPFILE:
 	{
 		u32 i, pos;
 		if (readonly_playlist) {
 			gf_fclose(playlist);
 			playlist = NULL;
 		}
 		readonly_playlist = 0;
 		if (!playlist) {
 			readonly_playlist = 0;
 			playlist = gf_temp_file_new(NULL);
 		}
 		pos = ftell(playlist);
 		i=0;
 		while (i<evt->open_file.nb_files) {
 			if (evt->open_file.files[i] != NULL) {
 				fprintf(playlist, ""%s\n"", evt->open_file.files[i]);
 			}
 			i++;
 		}
 		fseek(playlist, pos, SEEK_SET);
 		request_next_playlist_item = 1;
 	}
 	return 1;
 	case GF_EVENT_QUIT:
 		if (evt->message.error)  {
 			fprintf(stderr, ""A fatal error was encoutered: %s (%s) - exiting ...\n"", evt->message.message ? evt->message.message : ""no details"", gf_error_to_string(evt->message.error) );
 		}
 		Run = 0;
 		break;
 	case GF_EVENT_DISCONNECT:
 		gf_term_disconnect(term);
 		break;
 	case GF_EVENT_MIGRATE:
 	{
 	}
 	break;
 	case GF_EVENT_NAVIGATE_INFO:
 		if (evt->navigate.to_url) fprintf(stderr, ""Go to URL: \""%s\""\r"", evt->navigate.to_url);
  		break;
  	case GF_EVENT_NAVIGATE:
  		if (gf_term_is_supported_url(term, evt->navigate.to_url, 1, no_mime_check)) {
			strcpy(the_url, evt->navigate.to_url);
 			strncpy(the_url, evt->navigate.to_url, sizeof(the_url)-1);
 			the_url[sizeof(the_url) - 1] = 0;
  			fprintf(stderr, ""Navigating to URL %s\n"", the_url);
  			gf_term_navigate_to(term, evt->navigate.to_url);
  			return 1;
 		} else {
 			fprintf(stderr, ""Navigation destination not supported\nGo to URL: %s\n"", evt->navigate.to_url);
 		}
 		break;
 	case GF_EVENT_SET_CAPTION:
 		gf_term_user_event(term, evt);
 		break;
 	case GF_EVENT_AUTHORIZATION:
 	{
 		int maxTries = 1;
 		assert( evt->type == GF_EVENT_AUTHORIZATION);
 		assert( evt->auth.user);
 		assert( evt->auth.password);
 		assert( evt->auth.site_url);
 		while ((!strlen(evt->auth.user) || !strlen(evt->auth.password)) && (maxTries--) >= 0) {
 			fprintf(stderr, ""**** Authorization required for site %s ****\n"", evt->auth.site_url);
 			fprintf(stderr, ""login   : "");
 			read_line_input(evt->auth.user, 50, 1);
 			fprintf(stderr, ""\npassword: "");
 			read_line_input(evt->auth.password, 50, 0);
 			fprintf(stderr, ""*********\n"");
 		}
 		if (maxTries < 0) {
 			fprintf(stderr, ""**** No User or password has been filled, aborting ***\n"");
 			return 0;
 		}
 		return 1;
 	}
 	case GF_EVENT_ADDON_DETECTED:
 		if (enable_add_ons) {
 			fprintf(stderr, ""Media Addon %s detected - enabling it\n"", evt->addon_connect.addon_url);
 			addon_visible = 1;
 		}
 		return enable_add_ons;
 	}
 	return 0;
 }","[316, 317, 318]",GPAC version 0.7.1 and earlier has a buffer overflow vulnerability in the cat_multiple_files function in applications/mp4box/fileimport.c when MP4Box is used for a local directory containing crafted filenames.,gpac,CVE-2018-20762,CWE-119
2454,180521," static int ndp_sock_open(struct ndp *ndp)
 {
 	int sock;
 	int ret;
 	int err;
 	int val;
 	sock = socket(PF_INET6, SOCK_RAW, IPPROTO_ICMPV6);
 	if (sock == -1) {
 		err(ndp, ""Failed to create ICMP6 socket."");
 		return -errno;
 	}
 	val = 1;
 	ret = setsockopt(sock, IPPROTO_IPV6, IPV6_RECVPKTINFO,
 			 &val, sizeof(val));
 	if (ret == -1) {
 		err(ndp, ""Failed to setsockopt IPV6_RECVPKTINFO."");
 		err = -errno;
 		goto close_sock;
 	}
 	val = 255;
 	ret = setsockopt(sock, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,
 			 &val, sizeof(val));
 	if (ret == -1) {
 		err(ndp, ""Failed to setsockopt IPV6_MULTICAST_HOPS."");
 		err = -errno;
  		goto close_sock;
  	}
 	val = 1;
 	ret = setsockopt(sock, IPPROTO_IPV6, IPV6_RECVHOPLIMIT,
 			 &val, sizeof(val));
 	if (ret == -1) {
 		err(ndp, ""Failed to setsockopt IPV6_RECVHOPLIMIT,."");
 		err = -errno;
 		goto close_sock;
 	}
  	ndp->sock = sock;
  	return 0;
  close_sock:
 	close(sock);
 	return err;
 }","[28, 29, 30, 31, 32, 33, 34, 35]","libndp before 1.6, as used in NetworkManager, does not properly validate the origin of Neighbor Discovery Protocol (NDP) messages, which allows remote attackers to conduct man-in-the-middle attacks or cause a denial of service (network connectivity disruption) by advertising a node as a router from a non-local network.",libndp,CVE-2016-3698,CWE-284
2461,180930," static int asf_build_simple_index(AVFormatContext *s, int stream_index)
 {
     ff_asf_guid g;
     ASFContext *asf     = s->priv_data;
     int64_t current_pos = avio_tell(s->pb);
     int64_t ret;
     if((ret = avio_seek(s->pb, asf->data_object_offset + asf->data_object_size, SEEK_SET)) < 0) {
         return ret;
     }
     if ((ret = ff_get_guid(s->pb, &g)) < 0)
         goto end;
     while (ff_guidcmp(&g, &ff_asf_simple_index_header)) {
         int64_t gsize = avio_rl64(s->pb);
         if (gsize < 24 || avio_feof(s->pb)) {
             goto end;
         }
         avio_skip(s->pb, gsize - 24);
         if ((ret = ff_get_guid(s->pb, &g)) < 0)
             goto end;
     }
     {
         int64_t itime, last_pos = -1;
         int pct, ict;
         int i;
         int64_t av_unused gsize = avio_rl64(s->pb);
         if ((ret = ff_get_guid(s->pb, &g)) < 0)
             goto end;
         itime = avio_rl64(s->pb);
         pct   = avio_rl32(s->pb);
         ict   = avio_rl32(s->pb);
         av_log(s, AV_LOG_DEBUG,
                ""itime:0x%""PRIx64"", pct:%d, ict:%d\n"", itime, pct, ict);
         for (i = 0; i < ict; i++) {
             int pktnum        = avio_rl32(s->pb);
             int pktct         = avio_rl16(s->pb);
              int64_t pos       = s->internal->data_offset + s->packet_size * (int64_t)pktnum;
              int64_t index_pts = FFMAX(av_rescale(itime, i, 10000) - asf->hdr.preroll, 0);
             if (avio_feof(s->pb)) {
                 ret = AVERROR_INVALIDDATA;
                 goto end;
             }
              if (pos != last_pos) {
                  av_log(s, AV_LOG_DEBUG, ""pktnum:%d, pktct:%d  pts: %""PRId64""\n"",
                         pktnum, pktct, index_pts);
                 av_add_index_entry(s->streams[stream_index], pos, index_pts,
                                    s->packet_size, 0, AVINDEX_KEYFRAME);
                 last_pos = pos;
             }
         }
         asf->index_read = ict > 1;
     }
 end:
     avio_seek(s->pb, current_pos, SEEK_SET);
     return ret;
 }","[38, 39, 40, 41]","In libavformat/asfdec_f.c in FFmpeg 3.3.3, a DoS in asf_build_simple_index() due to lack of an EOF (End of File) check might cause huge CPU consumption. When a crafted ASF file, which claims a large *ict* field in the header but does not contain sufficient backing data, is provided, the for loop would consume huge CPU and memory resources, since there is no EOF check inside the loop.",FFmpeg,CVE-2017-14223,CWE-399
2472,182254," int read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t *data_len)
 {
 	struct sc_path path;
 	struct sc_file *file;
 	unsigned char *p;
 	int ok = 0;
 	int r;
 	size_t len;
 	sc_format_path(str_path, &path);
 	if (SC_SUCCESS != sc_select_file(card, &path, &file)) {
  		goto err;
  	}
	len = file ? file->size : 4096;
 	len = file && file->size > 0 ? file->size : 4096;
  	p = realloc(*data, len);
  	if (!p) {
  		goto err;
 	}
 	*data = p;
 	*data_len = len;
 	r = sc_read_binary(card, 0, p, len, 0);
 	if (r < 0)
 		goto err;
 	*data_len = r;
 	ok = 1;
 err:
 	sc_file_free(file);
 	return ok;
 }","[13, 14]",A double free when handling responses from an HSM Card in sc_pkcs15emu_sc_hsm_init in libopensc/pkcs15-sc-hsm.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.,OpenSC,CVE-2018-16425,CWE-415
2473,183234," header_seek (SF_PRIVATE *psf, sf_count_t position, int whence)
  {
  	switch (whence)
  	{	case SEEK_SET :
			if (position > SIGNED_SIZEOF (psf->header))
 			if (psf->header.indx + position >= psf->header.len)
 				psf_bump_header_allocation (psf, position) ;
 			if (position > psf->header.len)
  			{	 
  				psf_fseek (psf, position, whence) ;
  				return ;
  				} ;
			if (position > psf->headend)
				psf->headend += psf_fread (psf->header + psf->headend, 1, position - psf->headend, psf) ;
			psf->headindex = position ;
 			if (position > psf->header.end)
 				psf->header.end += psf_fread (psf->header.ptr + psf->header.end, 1, position - psf->header.end, psf) ;
 			psf->header.indx = position ;
  			break ;
  		case SEEK_CUR :
			if (psf->headindex + position < 0)
 			if (psf->header.indx + position >= psf->header.len)
 				psf_bump_header_allocation (psf, position) ;
 			if (psf->header.indx + position < 0)
  				break ;
			if (psf->headindex >= SIGNED_SIZEOF (psf->header))
 			if (psf->header.indx >= psf->header.len)
  			{	psf_fseek (psf, position, whence) ;
  				return ;
  				} ;
			if (psf->headindex + position <= psf->headend)
			{	psf->headindex += position ;
 			if (psf->header.indx + position <= psf->header.end)
 			{	psf->header.indx += position ;
  				break ;
  				} ;
			if (psf->headindex + position > SIGNED_SIZEOF (psf->header))
 			if (psf->header.indx + position > psf->header.len)
  			{	 
				psf->headindex = psf->headend ;
 				psf->header.indx = psf->header.end ;
  				psf_fseek (psf, position, SEEK_CUR) ;
  				break ;
  				} ;
			psf->headend += psf_fread (psf->header + psf->headend, 1, position - (psf->headend - psf->headindex), psf) ;
			psf->headindex = psf->headend ;
 			psf->header.end += psf_fread (psf->header.ptr + psf->header.end, 1, position - (psf->header.end - psf->header.indx), psf) ;
 			psf->header.indx = psf->header.end ;
  			break ;
  		case SEEK_END :
 		default :
 			psf_log_printf (psf, ""Bad whence param in header_seek().\n"") ;
 			break ;
 		} ;
 	return ;
 }  ","[5, 6, 7, 8, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24, 26, 27, 31, 32, 33, 34, 37, 38, 40, 41, 45, 46, 47, 48]","In libsndfile before 1.0.28, an error in the *header_read()* function (common.c) when handling ID3 tags can be exploited to cause a stack-based buffer overflow via a specially crafted FLAC file.",libsndfile,CVE-2017-7586,CWE-119
2524,182045," int xmkstemp(char **tmpname, char *dir)
 int xmkstemp(char **tmpname, const char *dir, const char *prefix)
  {
  	char *localtmp;
	char *tmpenv;
 	const char *tmpenv;
  	mode_t old_mode;
  	int fd, rc;
	if (dir != NULL)
		tmpenv = dir;
	else
		tmpenv = getenv(""TMPDIR"");
	if (tmpenv)
		rc = asprintf(&localtmp, ""%s/%s.XXXXXX"", tmpenv,
			  program_invocation_short_name);
	else
		rc = asprintf(&localtmp, ""%s/%s.XXXXXX"", _PATH_TMP,
			  program_invocation_short_name);
 	tmpenv = dir ? dir : getenv(""TMPDIR"");
 	if (!tmpenv)
 		tmpenv = _PATH_TMP;
 	rc = asprintf(&localtmp, ""%s/%s.XXXXXX"", tmpenv, prefix);
  	if (rc < 0)
  		return -1;
 	old_mode = umask(077);
 	fd = mkostemp(localtmp, O_RDWR|O_CREAT|O_EXCL|O_CLOEXEC);
 	umask(old_mode);
 	if (fd == -1) {
 		free(localtmp);
 		localtmp = NULL;
 	}
 	*tmpname = localtmp;
 	return fd;
 }","[2, 5, 6, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]",The mkostemp function in login-utils in util-linux when used incorrectly allows remote attackers to cause file name collision and possibly other attacks.,util-linux,CVE-2015-5224,CWE-264
2555,181275," yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, void *yyscanner, RE_LEX_ENVIRONMENT *lex_env)
 {
   YYUSE (yyvaluep);
   YYUSE (yyscanner);
   YYUSE (lex_env);
   if (!yymsg)
     yymsg = ""Deleting"";
   YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
   YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
    switch (yytype)
      {
            case 6:  
#line 96 ""re_grammar.y""  
 #line 104 ""re_grammar.y""  
        { yr_free(((*yyvaluep).class_vector)); }
#line 1045 ""re_grammar.c""  
 #line 1053 ""re_grammar.c""  
          break;
      case 26:  
#line 97 ""re_grammar.y""  
 #line 105 ""re_grammar.y""  
        { yr_re_node_destroy(((*yyvaluep).re_node)); }
#line 1051 ""re_grammar.c""  
 #line 1059 ""re_grammar.c""  
          break;
      case 27:  
#line 98 ""re_grammar.y""  
 #line 106 ""re_grammar.y""  
        { yr_re_node_destroy(((*yyvaluep).re_node)); }
#line 1057 ""re_grammar.c""  
 #line 1065 ""re_grammar.c""  
          break;
      case 28:  
#line 99 ""re_grammar.y""  
 #line 107 ""re_grammar.y""  
        { yr_re_node_destroy(((*yyvaluep).re_node)); }
#line 1063 ""re_grammar.c""  
 #line 1071 ""re_grammar.c""  
          break;
      case 29:  
#line 100 ""re_grammar.y""  
 #line 108 ""re_grammar.y""  
        { yr_re_node_destroy(((*yyvaluep).re_node)); }
#line 1069 ""re_grammar.c""  
 #line 1077 ""re_grammar.c""  
          break;
       default:
         break;
     }
   YY_IGNORE_MAYBE_UNINITIALIZED_END
 }","[13, 14, 16, 17, 20, 21, 23, 24, 27, 28, 30, 31, 34, 35, 37, 38, 41, 42, 44, 45]",libyara/re.c in the regexp module in YARA 3.5.0 allows remote attackers to cause a denial of service (stack consumption) via a crafted rule that is mishandled in the _yr_re_emit function.,yara,CVE-2017-9304,CWE-674
2563,179645," static void ikev2_parent_outI1_continue(struct pluto_crypto_req_cont *pcrc,
 					struct pluto_crypto_req *r,
 					err_t ugh)
 {
 	struct ke_continuation *ke = (struct ke_continuation *)pcrc;
 	struct msg_digest *md = ke->md;
 	struct state *const st = md->st;
 	stf_status e;
 	DBG(DBG_CONTROLMORE,
 	    DBG_log(""ikev2 parent outI1: calculated ke+nonce, sending I1""));
 	if (st == NULL) {
 		loglog(RC_LOG_SERIOUS,
 		       ""%s: Request was disconnected from state"",
 		       __FUNCTION__);
 		if (ke->md)
 			release_md(ke->md);
 		return;
 	}
 	passert(ugh == NULL);
 	passert(cur_state == NULL);
 	passert(st != NULL);
 	passert(st->st_suspended_md == ke->md);
 	set_suspended(st, NULL);  
 	set_cur_state(st);
 	st->st_calculating = FALSE;
 	e = ikev2_parent_outI1_tail(pcrc, r);
 	if (ke->md != NULL) {
 		complete_v2_state_transition(&ke->md, e);
 		if (ke->md)
 			release_md(ke->md);
  	}
  	reset_cur_state();
  	reset_globals();
	passert(GLOBALS_ARE_RESET());
  }",[34],The ikev2parent_inI1outR1 function in pluto/ikev2_parent.c in libreswan before 3.7 allows remote attackers to cause a denial of service (restart) via an IKEv2 I1 notification without a KE payload.,libreswan,CVE-2013-7294,CWE-20
2567,179088," static int filter_frame(AVFilterLink *inlink, AVFrame *buf)
 {
     AVFilterContext    *ctx = inlink->dst;
     FPSContext           *s = ctx->priv;
     AVFilterLink   *outlink = ctx->outputs[0];
     int64_t delta;
     int i, ret;
     s->frames_in++;
     if (s->pts == AV_NOPTS_VALUE) {
         if (buf->pts != AV_NOPTS_VALUE) {
             ret = write_to_fifo(s->fifo, buf);
             if (ret < 0)
                 return ret;
             if (s->start_time != DBL_MAX && s->start_time != AV_NOPTS_VALUE) {
                 double first_pts = s->start_time * AV_TIME_BASE;
                 first_pts = FFMIN(FFMAX(first_pts, INT64_MIN), INT64_MAX);
                 s->first_pts = s->pts = av_rescale_q(first_pts, AV_TIME_BASE_Q,
                                                      inlink->time_base);
                 av_log(ctx, AV_LOG_VERBOSE, ""Set first pts to (in:%""PRId64"" out:%""PRId64"")\n"",
                        s->first_pts, av_rescale_q(first_pts, AV_TIME_BASE_Q,
                                                   outlink->time_base));
             } else {
                 s->first_pts = s->pts = buf->pts;
             }
         } else {
             av_log(ctx, AV_LOG_WARNING, ""Discarding initial frame(s) with no ""
                    ""timestamp.\n"");
             av_frame_free(&buf);
             s->drop++;
         }
         return 0;
      }
    if (buf->pts == AV_NOPTS_VALUE) {
     if (buf->pts == AV_NOPTS_VALUE || av_fifo_size(s->fifo) <= 0) {
          return write_to_fifo(s->fifo, buf);
      }
     delta = av_rescale_q_rnd(buf->pts - s->pts, inlink->time_base,
                              outlink->time_base, s->rounding);
     if (delta < 1) {
         AVFrame *tmp;
         int drop = av_fifo_size(s->fifo)/sizeof(AVFrame*);
         av_log(ctx, AV_LOG_DEBUG, ""Dropping %d frame(s).\n"", drop);
         s->drop += drop;
         av_fifo_generic_read(s->fifo, &tmp, sizeof(tmp), NULL);
         flush_fifo(s->fifo);
         ret = write_to_fifo(s->fifo, tmp);
         av_frame_free(&buf);
         return ret;
     }
     for (i = 0; i < delta; i++) {
         AVFrame *buf_out;
         av_fifo_generic_read(s->fifo, &buf_out, sizeof(buf_out), NULL);
         if (!av_fifo_size(s->fifo) && i < delta - 1) {
             AVFrame *dup = av_frame_clone(buf_out);
             av_log(ctx, AV_LOG_DEBUG, ""Duplicating frame.\n"");
             if (dup)
                 ret = write_to_fifo(s->fifo, dup);
             else
                 ret = AVERROR(ENOMEM);
             if (ret < 0) {
                 av_frame_free(&buf_out);
                 av_frame_free(&buf);
                 return ret;
             }
             s->dup++;
         }
         buf_out->pts = av_rescale_q(s->first_pts, inlink->time_base,
                                     outlink->time_base) + s->frames_out;
         if ((ret = ff_filter_frame(outlink, buf_out)) < 0) {
             av_frame_free(&buf);
             return ret;
         }
         s->frames_out++;
     }
     flush_fifo(s->fifo);
     ret = write_to_fifo(s->fifo, buf);
     s->pts = s->first_pts + av_rescale_q(s->frames_out, outlink->time_base, inlink->time_base);
     return ret;
 }","[33, 34]","The filter_frame function in libavfilter/vf_fps.c in FFmpeg before 2.1 does not properly ensure the availability of FIFO content, which allows remote attackers to cause a denial of service (double free) or possibly have unspecified other impact via crafted data.",FFmpeg,CVE-2013-7021,CWE-399
2589,181879," void jas_seq2d_bindsub(jas_matrix_t *s, jas_matrix_t *s1, int xstart,
  int ystart, int xend, int yend)
 void jas_seq2d_bindsub(jas_matrix_t *s, jas_matrix_t *s1, jas_matind_t xstart,
   jas_matind_t ystart, jas_matind_t xend, jas_matind_t yend)
  {
  	jas_matrix_bindsub(s, s1, ystart - s1->ystart_, xstart - s1->xstart_,
  	  yend - s1->ystart_ - 1, xend - s1->xstart_ - 1);
  }","[2, 3, 4]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
2610,179585," parse_tsquery(char *buf,
 			  PushFunction pushval,
 			  Datum opaque,
 			  bool isplain)
 {
 	struct TSQueryParserStateData state;
 	int			i;
 	TSQuery		query;
 	int			commonlen;
 	QueryItem  *ptr;
 	ListCell   *cell;
 	state.buffer = buf;
 	state.buf = buf;
 	state.state = (isplain) ? WAITSINGLEOPERAND : WAITFIRSTOPERAND;
 	state.count = 0;
 	state.polstr = NIL;
 	state.valstate = init_tsvector_parser(state.buffer, true, true);
 	state.sumlen = 0;
 	state.lenop = 64;
 	state.curop = state.op = (char *) palloc(state.lenop);
 	*(state.curop) = '\0';
 	makepol(&state, pushval, opaque);
 	close_tsvector_parser(state.valstate);
 	if (list_length(state.polstr) == 0)
 	{
 		ereport(NOTICE,
 				(errmsg(""text-search query doesn't contain lexemes: \""%s\"""",
 						state.buffer)));
 		query = (TSQuery) palloc(HDRSIZETQ);
 		SET_VARSIZE(query, HDRSIZETQ);
 		query->size = 0;
  		return query;
  	}
 	if (TSQUERY_TOO_BIG(list_length(state.polstr), state.sumlen))
 		ereport(ERROR,
 				(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),
 				 errmsg(""tsquery is too large"")));
  	commonlen = COMPUTESIZE(list_length(state.polstr), state.sumlen);
  	query = (TSQuery) palloc0(commonlen);
  	SET_VARSIZE(query, commonlen);
  	query->size = list_length(state.polstr);
 	ptr = GETQUERY(query);
 	i = 0;
 	foreach(cell, state.polstr)
 	{
 		QueryItem  *item = (QueryItem *) lfirst(cell);
 		switch (item->type)
 		{
 			case QI_VAL:
 				memcpy(&ptr[i], item, sizeof(QueryOperand));
 				break;
 			case QI_VALSTOP:
 				ptr[i].type = QI_VALSTOP;
 				break;
 			case QI_OPR:
 				memcpy(&ptr[i], item, sizeof(QueryOperator));
 				break;
 			default:
 				elog(ERROR, ""unrecognized QueryItem type: %d"", item->type);
 		}
 		i++;
 	}
 	memcpy((void *) GETOPERAND(query), (void *) state.op, state.sumlen);
 	pfree(state.op);
 	findoprnd(ptr, query->size);
 	return query;
 }","[34, 35, 36, 37]","Multiple integer overflows in contrib/hstore/hstore_io.c in PostgreSQL 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact via vectors related to the (1) hstore_recv, (2) hstore_from_arrays, and (3) hstore_from_array functions in contrib/hstore/hstore_io.c; and the (4) hstoreArrayToPairs function in contrib/hstore/hstore_op.c, which triggers a buffer overflow.  NOTE: this issue was SPLIT from CVE-2014-0064 because it has a different set of affected versions.",postgres,CVE-2014-2669,CWE-189
2628,179642," static void ikev2_parent_inI1outR1_continue(struct pluto_crypto_req_cont *pcrc,
 					    struct pluto_crypto_req *r,
 					    err_t ugh)
 {
 	struct ke_continuation *ke = (struct ke_continuation *)pcrc;
 	struct msg_digest *md = ke->md;
 	struct state *const st = md->st;
 	stf_status e;
 	DBG(DBG_CONTROLMORE,
 	    DBG_log(""ikev2 parent inI1outR1: calculated ke+nonce, sending R1""));
 	if (st == NULL) {
 		loglog(RC_LOG_SERIOUS,
 		       ""%s: Request was disconnected from state"",
 		       __FUNCTION__);
 		if (ke->md)
 			release_md(ke->md);
 		return;
 	}
 	passert(ugh == NULL);
 	passert(cur_state == NULL);
 	passert(st != NULL);
 	passert(st->st_suspended_md == ke->md);
 	set_suspended(st, NULL);  
 	set_cur_state(st);
 	st->st_calculating = FALSE;
 	e = ikev2_parent_inI1outR1_tail(pcrc, r);
 	if (ke->md != NULL) {
 		complete_v2_state_transition(&ke->md, e);
 		if (ke->md)
  			release_md(ke->md);
  	}
  	reset_globals();
	passert(GLOBALS_ARE_RESET());
  }",[33],The ikev2parent_inI1outR1 function in pluto/ikev2_parent.c in libreswan before 3.7 allows remote attackers to cause a denial of service (restart) via an IKEv2 I1 notification without a KE payload.,libreswan,CVE-2013-7294,CWE-20
2653,179570," hstore_from_record(PG_FUNCTION_ARGS)
 {
 	HeapTupleHeader rec;
 	int32		buflen;
 	HStore	   *out;
 	Pairs	   *pairs;
 	Oid			tupType;
 	int32		tupTypmod;
 	TupleDesc	tupdesc;
 	HeapTupleData tuple;
 	RecordIOData *my_extra;
 	int			ncolumns;
 	int			i,
 				j;
 	Datum	   *values;
 	bool	   *nulls;
 	if (PG_ARGISNULL(0))
 	{
 		Oid			argtype = get_fn_expr_argtype(fcinfo->flinfo, 0);
 		tupType = argtype;
 		tupTypmod = -1;
 		rec = NULL;
 	}
 	else
 	{
 		rec = PG_GETARG_HEAPTUPLEHEADER(0);
 		tupType = HeapTupleHeaderGetTypeId(rec);
 		tupTypmod = HeapTupleHeaderGetTypMod(rec);
 	}
 	tupdesc = lookup_rowtype_tupdesc(tupType, tupTypmod);
 	ncolumns = tupdesc->natts;
 	my_extra = (RecordIOData *) fcinfo->flinfo->fn_extra;
 	if (my_extra == NULL ||
 		my_extra->ncolumns != ncolumns)
 	{
 		fcinfo->flinfo->fn_extra =
 			MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,
 							   sizeof(RecordIOData) - sizeof(ColumnIOData)
 							   + ncolumns * sizeof(ColumnIOData));
 		my_extra = (RecordIOData *) fcinfo->flinfo->fn_extra;
 		my_extra->record_type = InvalidOid;
 		my_extra->record_typmod = 0;
 	}
 	if (my_extra->record_type != tupType ||
 		my_extra->record_typmod != tupTypmod)
 	{
 		MemSet(my_extra, 0,
 			   sizeof(RecordIOData) - sizeof(ColumnIOData)
 			   + ncolumns * sizeof(ColumnIOData));
 		my_extra->record_type = tupType;
 		my_extra->record_typmod = tupTypmod;
  		my_extra->ncolumns = ncolumns;
  	}
 	Assert(ncolumns <= MaxTupleAttributeNumber);		 
  	pairs = palloc(ncolumns * sizeof(Pairs));
  	if (rec)
 	{
 		tuple.t_len = HeapTupleHeaderGetDatumLength(rec);
 		ItemPointerSetInvalid(&(tuple.t_self));
 		tuple.t_tableOid = InvalidOid;
 		tuple.t_data = rec;
 		values = (Datum *) palloc(ncolumns * sizeof(Datum));
 		nulls = (bool *) palloc(ncolumns * sizeof(bool));
 		heap_deform_tuple(&tuple, tupdesc, values, nulls);
 	}
 	else
 	{
 		values = NULL;
 		nulls = NULL;
 	}
 	for (i = 0, j = 0; i < ncolumns; ++i)
 	{
 		ColumnIOData *column_info = &my_extra->columns[i];
 		Oid			column_type = tupdesc->attrs[i]->atttypid;
 		char	   *value;
 		if (tupdesc->attrs[i]->attisdropped)
 			continue;
 		pairs[j].key = NameStr(tupdesc->attrs[i]->attname);
 		pairs[j].keylen = hstoreCheckKeyLen(strlen(NameStr(tupdesc->attrs[i]->attname)));
 		if (!nulls || nulls[i])
 		{
 			pairs[j].val = NULL;
 			pairs[j].vallen = 4;
 			pairs[j].isnull = true;
 			pairs[j].needfree = false;
 			++j;
 			continue;
 		}
 		if (column_info->column_type != column_type)
 		{
 			bool		typIsVarlena;
 			getTypeOutputInfo(column_type,
 							  &column_info->typiofunc,
 							  &typIsVarlena);
 			fmgr_info_cxt(column_info->typiofunc, &column_info->proc,
 						  fcinfo->flinfo->fn_mcxt);
 			column_info->column_type = column_type;
 		}
 		value = OutputFunctionCall(&column_info->proc, values[i]);
 		pairs[j].val = value;
 		pairs[j].vallen = hstoreCheckValLen(strlen(value));
 		pairs[j].isnull = false;
 		pairs[j].needfree = false;
 		++j;
 	}
 	ncolumns = hstoreUniquePairs(pairs, j, &buflen);
 	out = hstorePairs(pairs, ncolumns, buflen);
 	ReleaseTupleDesc(tupdesc);
 	PG_RETURN_POINTER(out);
 }",[54],"Multiple integer overflows in contrib/hstore/hstore_io.c in PostgreSQL 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact via vectors related to the (1) hstore_recv, (2) hstore_from_arrays, and (3) hstore_from_array functions in contrib/hstore/hstore_io.c; and the (4) hstoreArrayToPairs function in contrib/hstore/hstore_op.c, which triggers a buffer overflow.  NOTE: this issue was SPLIT from CVE-2014-0064 because it has a different set of affected versions.",postgres,CVE-2014-2669,CWE-189
2654,181649," static void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps)
 {
 	int i;
 	int j;
 	int thresh;
 	jpc_fix_t val;
 	jpc_fix_t mag;
  	bool warn;
  	uint_fast32_t mask;
 	if (roishift < 0) {
 		jas_eprintf(""warning: forcing negative ROI shift to zero ""
 		  ""(bitstream is probably corrupt)\n"");
 		roishift = 0;
 	}
  	if (roishift == 0 && bgshift == 0) {
  		return;
  	}
 	thresh = 1 << roishift;
 	warn = false;
 	for (i = 0; i < jas_matrix_numrows(x); ++i) {
 		for (j = 0; j < jas_matrix_numcols(x); ++j) {
 			val = jas_matrix_get(x, i, j);
 			mag = JAS_ABS(val);
 			if (mag >= thresh) {
 				mag >>= roishift;
 				val = (val < 0) ? (-mag) : mag;
 				jas_matrix_set(x, i, j, val);
  			} else {
  				mag <<= bgshift;
				mask = (1 << numbps) - 1;
 				mask = (JAS_CAST(uint_fast32_t, 1) << numbps) - 1;
 				if (mag & (~mask)) {
 					if (!warn) {
 						jas_eprintf(""warning: possibly corrupt code stream\n"");
 						warn = true;
 					}
 					mag &= mask;
 				}
 				val = (val < 0) ? (-mag) : mag;
 				jas_matrix_set(x, i, j, val);
 			}
 		}
 	}
 }","[10, 11, 12, 13, 14, 30, 31]",The jpc_tsfb_synthesize function in jpc_tsfb.c in JasPer before 1.900.9 allows remote attackers to cause a denial of service (NULL pointer dereference) via vectors involving an empty sequence.,jasper,CVE-2016-10248,CWE-476
2664,181849," static int jpc_dec_tileinit(jpc_dec_t *dec, jpc_dec_tile_t *tile)
 {
 	jpc_dec_tcomp_t *tcomp;
 	int compno;
 	int rlvlno;
 	jpc_dec_rlvl_t *rlvl;
 	jpc_dec_band_t *band;
 	jpc_dec_prc_t *prc;
 	int bndno;
 	jpc_tsfb_band_t *bnd;
 	int bandno;
 	jpc_dec_ccp_t *ccp;
 	int prccnt;
 	jpc_dec_cblk_t *cblk;
 	int cblkcnt;
 	uint_fast32_t tlprcxstart;
 	uint_fast32_t tlprcystart;
 	uint_fast32_t brprcxend;
 	uint_fast32_t brprcyend;
 	uint_fast32_t tlcbgxstart;
 	uint_fast32_t tlcbgystart;
 	uint_fast32_t brcbgxend;
 	uint_fast32_t brcbgyend;
 	uint_fast32_t cbgxstart;
 	uint_fast32_t cbgystart;
 	uint_fast32_t cbgxend;
 	uint_fast32_t cbgyend;
 	uint_fast32_t tlcblkxstart;
 	uint_fast32_t tlcblkystart;
 	uint_fast32_t brcblkxend;
 	uint_fast32_t brcblkyend;
 	uint_fast32_t cblkxstart;
 	uint_fast32_t cblkystart;
 	uint_fast32_t cblkxend;
 	uint_fast32_t cblkyend;
 	uint_fast32_t tmpxstart;
 	uint_fast32_t tmpystart;
  	uint_fast32_t tmpxend;
  	uint_fast32_t tmpyend;
  	jpc_dec_cp_t *cp;
	jpc_tsfb_band_t bnds[64];
 	jpc_tsfb_band_t bnds[JPC_MAXBANDS];
  	jpc_pchg_t *pchg;
  	int pchgno;
  	jpc_dec_cmpt_t *cmpt;
 	cp = tile->cp;
 	tile->realmode = 0;
 	if (cp->mctid == JPC_MCT_ICT) {
 		tile->realmode = 1;
 	}
 	for (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <
 	  dec->numcomps; ++compno, ++tcomp, ++cmpt) {
 		ccp = &tile->cp->ccps[compno];
 		if (ccp->qmfbid == JPC_COX_INS) {
 			tile->realmode = 1;
 		}
 		tcomp->numrlvls = ccp->numrlvls;
 		if (!(tcomp->rlvls = jas_alloc2(tcomp->numrlvls,
 		  sizeof(jpc_dec_rlvl_t)))) {
 			return -1;
 		}
 		if (!(tcomp->data = jas_seq2d_create(JPC_CEILDIV(tile->xstart,
 		  cmpt->hstep), JPC_CEILDIV(tile->ystart, cmpt->vstep),
 		  JPC_CEILDIV(tile->xend, cmpt->hstep), JPC_CEILDIV(tile->yend,
 		  cmpt->vstep)))) {
 			return -1;
 		}
 		if (!(tcomp->tsfb = jpc_cod_gettsfb(ccp->qmfbid,
 		  tcomp->numrlvls - 1))) {
 			return -1;
 		}
 		{
 			jpc_tsfb_getbands(tcomp->tsfb, jas_seq2d_xstart(tcomp->data),
 			  jas_seq2d_ystart(tcomp->data), jas_seq2d_xend(tcomp->data),
 			  jas_seq2d_yend(tcomp->data), bnds);
 		}
 		for (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls;
 		  ++rlvlno, ++rlvl) {
 			rlvl->bands = 0;
 			rlvl->xstart = JPC_CEILDIVPOW2(tcomp->xstart,
 			  tcomp->numrlvls - 1 - rlvlno);
 			rlvl->ystart = JPC_CEILDIVPOW2(tcomp->ystart,
 			  tcomp->numrlvls - 1 - rlvlno);
 			rlvl->xend = JPC_CEILDIVPOW2(tcomp->xend,
 			  tcomp->numrlvls - 1 - rlvlno);
 			rlvl->yend = JPC_CEILDIVPOW2(tcomp->yend,
 			  tcomp->numrlvls - 1 - rlvlno);
 			rlvl->prcwidthexpn = ccp->prcwidthexpns[rlvlno];
 			rlvl->prcheightexpn = ccp->prcheightexpns[rlvlno];
 			tlprcxstart = JPC_FLOORDIVPOW2(rlvl->xstart,
 			  rlvl->prcwidthexpn) << rlvl->prcwidthexpn;
 			tlprcystart = JPC_FLOORDIVPOW2(rlvl->ystart,
 			  rlvl->prcheightexpn) << rlvl->prcheightexpn;
 			brprcxend = JPC_CEILDIVPOW2(rlvl->xend,
 			  rlvl->prcwidthexpn) << rlvl->prcwidthexpn;
 			brprcyend = JPC_CEILDIVPOW2(rlvl->yend,
 			  rlvl->prcheightexpn) << rlvl->prcheightexpn;
 			rlvl->numhprcs = (brprcxend - tlprcxstart) >>
 			  rlvl->prcwidthexpn;
 			rlvl->numvprcs = (brprcyend - tlprcystart) >>
 			  rlvl->prcheightexpn;
 			rlvl->numprcs = rlvl->numhprcs * rlvl->numvprcs;
 			if (rlvl->xstart >= rlvl->xend || rlvl->ystart >= rlvl->yend) {
 				rlvl->bands = 0;
 				rlvl->numprcs = 0;
 				rlvl->numhprcs = 0;
 				rlvl->numvprcs = 0;
 				continue;
 			}	
 			if (!rlvlno) {
 				tlcbgxstart = tlprcxstart;
 				tlcbgystart = tlprcystart;
 				brcbgxend = brprcxend;
 				brcbgyend = brprcyend;
 				rlvl->cbgwidthexpn = rlvl->prcwidthexpn;
 				rlvl->cbgheightexpn = rlvl->prcheightexpn;
 			} else {
 				tlcbgxstart = JPC_CEILDIVPOW2(tlprcxstart, 1);
 				tlcbgystart = JPC_CEILDIVPOW2(tlprcystart, 1);
 				brcbgxend = JPC_CEILDIVPOW2(brprcxend, 1);
 				brcbgyend = JPC_CEILDIVPOW2(brprcyend, 1);
 				rlvl->cbgwidthexpn = rlvl->prcwidthexpn - 1;
 				rlvl->cbgheightexpn = rlvl->prcheightexpn - 1;
 			}
 			rlvl->cblkwidthexpn = JAS_MIN(ccp->cblkwidthexpn,
 			  rlvl->cbgwidthexpn);
 			rlvl->cblkheightexpn = JAS_MIN(ccp->cblkheightexpn,
 			  rlvl->cbgheightexpn);
 			rlvl->numbands = (!rlvlno) ? 1 : 3;
 			if (!(rlvl->bands = jas_alloc2(rlvl->numbands,
 			  sizeof(jpc_dec_band_t)))) {
 				return -1;
 			}
 			for (bandno = 0, band = rlvl->bands;
 			  bandno < rlvl->numbands; ++bandno, ++band) {
 				bndno = (!rlvlno) ? 0 : (3 * (rlvlno - 1) +
 				  bandno + 1);
 				bnd = &bnds[bndno];
 				band->orient = bnd->orient;
 				band->stepsize = ccp->stepsizes[bndno];
 				band->analgain = JPC_NOMINALGAIN(ccp->qmfbid,
 				  tcomp->numrlvls - 1, rlvlno, band->orient);
 				band->absstepsize = jpc_calcabsstepsize(band->stepsize,
 				  cmpt->prec + band->analgain);
 				band->numbps = ccp->numguardbits +
 				  JPC_QCX_GETEXPN(band->stepsize) - 1;
 				band->roishift = (ccp->roishift + band->numbps >= JPC_PREC) ?
 				  (JPC_PREC - 1 - band->numbps) : ccp->roishift;
 				band->data = 0;
 				band->prcs = 0;
 				if (bnd->xstart == bnd->xend || bnd->ystart == bnd->yend) {
 					continue;
 				}
 				if (!(band->data = jas_seq2d_create(0, 0, 0, 0))) {
 					return -1;
 				}
 				jas_seq2d_bindsub(band->data, tcomp->data, bnd->locxstart,
 				  bnd->locystart, bnd->locxend, bnd->locyend);
 				jas_seq2d_setshift(band->data, bnd->xstart, bnd->ystart);
 				assert(rlvl->numprcs);
 				if (!(band->prcs = jas_alloc2(rlvl->numprcs,
 				  sizeof(jpc_dec_prc_t)))) {
 					return -1;
 				}
 				cbgxstart = tlcbgxstart;
 				cbgystart = tlcbgystart;
 				for (prccnt = rlvl->numprcs, prc = band->prcs;
 				  prccnt > 0; --prccnt, ++prc) {
 					cbgxend = cbgxstart + (1 << rlvl->cbgwidthexpn);
 					cbgyend = cbgystart + (1 << rlvl->cbgheightexpn);
 					prc->xstart = JAS_MAX(cbgxstart, JAS_CAST(uint_fast32_t,
 					  jas_seq2d_xstart(band->data)));
 					prc->ystart = JAS_MAX(cbgystart, JAS_CAST(uint_fast32_t,
 					  jas_seq2d_ystart(band->data)));
 					prc->xend = JAS_MIN(cbgxend, JAS_CAST(uint_fast32_t,
 					  jas_seq2d_xend(band->data)));
 					prc->yend = JAS_MIN(cbgyend, JAS_CAST(uint_fast32_t,
 					  jas_seq2d_yend(band->data)));
 					if (prc->xend > prc->xstart && prc->yend > prc->ystart) {
 						tlcblkxstart = JPC_FLOORDIVPOW2(prc->xstart,
 						  rlvl->cblkwidthexpn) << rlvl->cblkwidthexpn;
 						tlcblkystart = JPC_FLOORDIVPOW2(prc->ystart,
 						  rlvl->cblkheightexpn) << rlvl->cblkheightexpn;
 						brcblkxend = JPC_CEILDIVPOW2(prc->xend,
 						  rlvl->cblkwidthexpn) << rlvl->cblkwidthexpn;
 						brcblkyend = JPC_CEILDIVPOW2(prc->yend,
 						  rlvl->cblkheightexpn) << rlvl->cblkheightexpn;
 						prc->numhcblks = (brcblkxend - tlcblkxstart) >>
 						  rlvl->cblkwidthexpn;
 						prc->numvcblks = (brcblkyend - tlcblkystart) >>
 						  rlvl->cblkheightexpn;
 						prc->numcblks = prc->numhcblks * prc->numvcblks;
 						assert(prc->numcblks > 0);
 						if (!(prc->incltagtree = jpc_tagtree_create(
 						  prc->numhcblks, prc->numvcblks))) {
 							return -1;
 						}
 						if (!(prc->numimsbstagtree = jpc_tagtree_create(
 						  prc->numhcblks, prc->numvcblks))) {
 							return -1;
 						}
 						if (!(prc->cblks = jas_alloc2(prc->numcblks,
 						  sizeof(jpc_dec_cblk_t)))) {
 							return -1;
 						}
 						cblkxstart = cbgxstart;
 						cblkystart = cbgystart;
 						for (cblkcnt = prc->numcblks, cblk = prc->cblks;
 						  cblkcnt > 0;) {
 							cblkxend = cblkxstart + (1 << rlvl->cblkwidthexpn);
 							cblkyend = cblkystart + (1 << rlvl->cblkheightexpn);
 							tmpxstart = JAS_MAX(cblkxstart, prc->xstart);
 							tmpystart = JAS_MAX(cblkystart, prc->ystart);
 							tmpxend = JAS_MIN(cblkxend, prc->xend);
 							tmpyend = JAS_MIN(cblkyend, prc->yend);
 							if (tmpxend > tmpxstart && tmpyend > tmpystart) {
 								cblk->firstpassno = -1;
 								cblk->mqdec = 0;
 								cblk->nulldec = 0;
 								cblk->flags = 0;
 								cblk->numpasses = 0;
 								cblk->segs.head = 0;
 								cblk->segs.tail = 0;
 								cblk->curseg = 0;
 								cblk->numimsbs = 0;
 								cblk->numlenbits = 3;
 								cblk->flags = 0;
 								if (!(cblk->data = jas_seq2d_create(0, 0, 0,
 								  0))) {
 									return -1;
 								}
 								jas_seq2d_bindsub(cblk->data, band->data,
 								  tmpxstart, tmpystart, tmpxend, tmpyend);
 								++cblk;
 								--cblkcnt;
 							}
 							cblkxstart += 1 << rlvl->cblkwidthexpn;
 							if (cblkxstart >= cbgxend) {
 								cblkxstart = cbgxstart;
 								cblkystart += 1 << rlvl->cblkheightexpn;
 							}
 						}
 					} else {
 						prc->cblks = 0;
 						prc->incltagtree = 0;
 						prc->numimsbstagtree = 0;
 					}
 					cbgxstart += 1 << rlvl->cbgwidthexpn;
 					if (cbgxstart >= brcbgxend) {
 						cbgxstart = tlcbgxstart;
 						cbgystart += 1 << rlvl->cbgheightexpn;
 					}
 				}
 			}
 		}
 	}
 	if (!(tile->pi = jpc_dec_pi_create(dec, tile))) {
 		return -1;
 	}
 	for (pchgno = 0; pchgno < jpc_pchglist_numpchgs(tile->cp->pchglist);
 	  ++pchgno) {
 		pchg = jpc_pchg_copy(jpc_pchglist_get(tile->cp->pchglist, pchgno));
 		assert(pchg);
 		jpc_pi_addpchg(tile->pi, pchg);
 	}
 	jpc_pi_init(tile->pi);
 	return 0;
 }","[41, 42]",Stack-based buffer overflow in the jpc_tsfb_getbands2 function in jpc_tsfb.c in JasPer before 1.900.30 allows remote attackers to have unspecified impact via a crafted image.,jasper,CVE-2016-9560,CWE-119
2694,182236," static void parse_sec_attr_44(sc_file_t *file, const u8 *buf, size_t len)
 {
 	const int df_idx[8] = {	  
 		SC_AC_OP_DELETE, SC_AC_OP_CREATE, SC_AC_OP_CREATE,
 		SC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE,
 		SC_AC_OP_LOCK, SC_AC_OP_DELETE, -1};
 	const int ef_idx[8] = {
 		SC_AC_OP_READ, SC_AC_OP_UPDATE, SC_AC_OP_WRITE,
 		SC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE,
 		-1, SC_AC_OP_ERASE, -1};
 	const int efi_idx[8] = {  
 		SC_AC_OP_READ, SC_AC_OP_ERASE, SC_AC_OP_UPDATE,
 		SC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE,
 		-1, SC_AC_OP_ERASE, -1};
 	u8		bValue;
 	int		i;
 	int		iKeyRef = 0;
 	int		iMethod;
 	int		iPinCount;
 	int		iOffset = 0;
 	int		iOperation;
 	const int*	p_idx;
  	while (len > 1) {				 
  		int	iACLen   = buf[iOffset] & 0x0F;
 		if ((size_t) iACLen > len)
 			break;
  		iPinCount = -1;			 
  		iMethod = SC_AC_NONE;		 
 		if (buf[iOffset] & 0X80) {  
 			int	iParmLen = 1;			 
 			int	iKeyLen  = 0;			 
 			if (buf[iOffset]   & 0x20) iKeyLen++;
 			if (buf[iOffset+1] & 0x40) iParmLen++;
 			if (buf[iOffset+1] & 0x20) iParmLen++;
 			if (buf[iOffset+1] & 0x10) iParmLen++;
 			if (buf[iOffset+1] & 0x08) iParmLen++;
  			if(iKeyLen) {
				int iSC = buf[iOffset+iACLen];
 				int iSC;
 				if (len < 1+iACLen)
 					break;
 				iSC = buf[iOffset+iACLen];
  				switch( (iSC>>5) & 0x03 ){
  				case 0:
 					iMethod = SC_AC_TERM;		 
 					break;
 				case 1:
 					iMethod = SC_AC_AUT;		 
 					break;
 				case 2:
 				case 3:
 					iMethod = SC_AC_PRO;		 
 					break;
 				}
 				iKeyRef = iSC & 0x1F;			 
 			}
  			if (iACLen > (1+iParmLen+iKeyLen)) {   
 				if (len < 1+1+1+iParmLen)
 					break;
  				iKeyRef = buf[iOffset+1+1+iParmLen];   
  				iMethod = SC_AC_CHV;
  			}
 			if (len < 1+2)
 				break;
  			switch(buf[iOffset+2]){
  			case 0x2A:			 
  				iOperation = SC_AC_OP_CRYPTO;
 				break;
 			case 0x46:			 
 				iOperation = SC_AC_OP_UPDATE;
 				break;
 			default:
 				iOperation = SC_AC_OP_SELECT;
 				break;
 			}
 			sc_file_add_acl_entry(file, iOperation, iMethod, iKeyRef);
 		}
 		else {  
 			switch (file->type) {
 			case SC_FILE_TYPE_DF:             
 				p_idx = df_idx;
 				break;
 			case SC_FILE_TYPE_INTERNAL_EF:    
 				p_idx = efi_idx;
 				break;
 			default:                          
 				p_idx = ef_idx;
 				break;
 			}
  			iPinCount = iACLen - 1;		
  			if (buf[iOffset] & 0x20) {
				int iSC = buf[iOffset + iACLen];
 				int iSC;
 				if (len < 1 + iACLen)
 					break;
 				iSC = buf[iOffset + iACLen];
  				switch( (iSC>>5) & 0x03 ) {
  				case 0:
 					iMethod = SC_AC_TERM;		 
 					break;
 				case 1:
 					iMethod = SC_AC_AUT;		 
 					break;
 				case 2:
 				case 3:
 					iMethod = SC_AC_PRO;		 
 					break;
 				}
 				iKeyRef = iSC & 0x1F;			 
 				iPinCount--;				 
 			}
  			if ( iPinCount > 0 ) {
 				if (len < 1 + 2)
 					break;
  				iKeyRef = buf[iOffset + 2];	 
  				iMethod = SC_AC_CHV;
  			}
 			bValue = buf[iOffset + 1];
 			for (i = 0; i < 8; i++) {
 				if((bValue & 1) && (p_idx[i] >= 0))
 					sc_file_add_acl_entry(file, p_idx[i], iMethod, iKeyRef);
 				bValue >>= 1;
 			}
 		}
 		iOffset += iACLen +1;		 
 		len     -= iACLen +1;
 	}
 }","[25, 26, 38, 39, 40, 41, 42, 58, 59, 63, 64, 92, 93, 94, 95, 96, 113, 114]",Various out of bounds reads when handling responses in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to potentially crash the opensc library using programs.,OpenSC,CVE-2018-16427,CWE-125
2700,179173," static int filter_frame(AVFilterLink *inlink, AVFrame *in)
 {
     GradFunContext *s = inlink->dst->priv;
     AVFilterLink *outlink = inlink->dst->outputs[0];
     AVFrame *out;
     int p, direct;
     if (av_frame_is_writable(in)) {
         direct = 1;
         out = in;
     } else {
         direct = 0;
         out = ff_get_video_buffer(outlink, outlink->w, outlink->h);
         if (!out) {
             av_frame_free(&in);
             return AVERROR(ENOMEM);
         }
          av_frame_copy_props(out, in);
      }
    for (p = 0; p < 4 && in->data[p]; p++) {
     for (p = 0; p < 4 && in->data[p] && in->linesize[p]; p++) {
          int w = inlink->w;
          int h = inlink->h;
          int r = s->radius;
         if (p) {
             w = s->chroma_w;
             h = s->chroma_h;
             r = s->chroma_r;
         }
         if (FFMIN(w, h) > 2 * r)
             filter(s, out->data[p], in->data[p], w, h, out->linesize[p], in->linesize[p], r);
         else if (out->data[p] != in->data[p])
             av_image_copy_plane(out->data[p], out->linesize[p], in->data[p], in->linesize[p], w, h);
     }
     if (!direct)
         av_frame_free(&in);
     return ff_filter_frame(outlink, out);
 }","[19, 20]","libavfilter in FFmpeg before 2.0.1 has unspecified impact and remote vectors related to a crafted *plane,* which triggers an out-of-bounds heap write.",FFmpeg,CVE-2013-4263,CWE-119
2701,181645," jp2_box_t *jp2_box_get(jas_stream_t *in)
 {
 	jp2_box_t *box;
 	jp2_boxinfo_t *boxinfo;
 	jas_stream_t *tmpstream;
 	uint_fast32_t len;
 	uint_fast64_t extlen;
 	bool dataflag;
 	box = 0;
 	tmpstream = 0;
  	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
  		goto error;
  	}
  	box->ops = &jp2_boxinfo_unk.ops;
  	if (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {
  		goto error;
  	}
  	boxinfo = jp2_boxinfolookup(box->type);
  	box->info = boxinfo;
	box->ops = &boxinfo->ops;
  	box->len = len;
  	JAS_DBGLOG(10, (
  	  ""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\n"",
 	  '""', boxinfo->name, '""', box->type, box->len
 	  ));
 	if (box->len == 1) {
 		if (jp2_getuint64(in, &extlen)) {
 			goto error;
 		}
 		if (extlen > 0xffffffffUL) {
 			jas_eprintf(""warning: cannot handle large 64-bit box length\n"");
 			extlen = 0xffffffffUL;
 		}
 		box->len = extlen;
 		box->datalen = extlen - JP2_BOX_HDRLEN(true);
 	} else {
 		box->datalen = box->len - JP2_BOX_HDRLEN(false);
 	}
 	if (box->len != 0 && box->len < 8) {
 		goto error;
 	}
 	dataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));
 	if (dataflag) {
 		if (!(tmpstream = jas_stream_memopen(0, 0))) {
  			goto error;
  		}
  		if (jas_stream_copy(tmpstream, in, box->datalen)) {
			box->ops = &jp2_boxinfo_unk.ops;
  			jas_eprintf(""cannot copy box data\n"");
  			goto error;
  		}
  		jas_stream_rewind(tmpstream);
 		box->ops = &boxinfo->ops;
  		if (box->ops->getdata) {
  			if ((*box->ops->getdata)(box, tmpstream)) {
  				jas_eprintf(""cannot parse box data\n"");
 				goto error;
 			}
 		}
 		jas_stream_close(tmpstream);
 	}
 	if (jas_getdbglevel() >= 1) {
 		jp2_box_dump(box, stderr);
 	}
 	return box;
 error:
 	if (box) {
 		jp2_box_destroy(box);
 	}
 	if (tmpstream) {
 		jas_stream_close(tmpstream);
 	}
 	return 0;
 }","[20, 48, 53]",The jp2_colr_destroy function in jp2_cod.c in JasPer before 1.900.13 allows remote attackers to cause a denial of service (NULL pointer dereference) by leveraging incorrect cleanup of JP2 box data on error. NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-8887.,jasper,CVE-2016-10250,CWE-476
2719,181571," char *FLTGetIsLikeComparisonExpression(FilterEncodingNode *psFilterNode)
 {
   const size_t bufferSize = 1024;
   char szBuffer[1024];
   char szTmp[256];
   char *pszValue = NULL;
   const char *pszWild = NULL;
   const char *pszSingle = NULL;
   const char *pszEscape = NULL;
   int  bCaseInsensitive = 0;
   int nLength=0, i=0, iTmp=0;
   FEPropertyIsLike* propIsLike;
   if (!psFilterNode || !psFilterNode->pOther || !psFilterNode->psLeftNode ||
       !psFilterNode->psRightNode || !psFilterNode->psRightNode->pszValue)
     return NULL;
   propIsLike = (FEPropertyIsLike *)psFilterNode->pOther;
   pszWild = propIsLike->pszWildCard;
   pszSingle = propIsLike->pszSingleChar;
   pszEscape = propIsLike->pszEscapeChar;
   bCaseInsensitive = propIsLike->bCaseInsensitive;
   if (!pszWild || strlen(pszWild) == 0 ||
       !pszSingle || strlen(pszSingle) == 0 ||
       !pszEscape || strlen(pszEscape) == 0)
     return NULL;
   szBuffer[0] = '\0';
   sprintf(szTmp, ""%s"", "" (\""["");
   szTmp[4] = '\0';
   strlcat(szBuffer, szTmp, bufferSize);
   strlcat(szBuffer, psFilterNode->psLeftNode->pszValue, bufferSize);
   szBuffer[strlen(szBuffer)] = '\0';
   if(bCaseInsensitive == 1)
     sprintf(szTmp, ""%s"", ""]\"" ~* /"");
   else
     sprintf(szTmp, ""%s"", ""]\"" =~ /"");
   szTmp[7] = '\0';
   strlcat(szBuffer, szTmp, bufferSize);
   szBuffer[strlen(szBuffer)] = '\0';
    pszValue = psFilterNode->psRightNode->pszValue;
    nLength = strlen(pszValue);
   if( 1 + 2 * nLength + 1 + 1 >= sizeof(szTmp) )
       return NULL;
    iTmp =0;
    if (nLength > 0 && pszValue[0] != pszWild[0] &&
       pszValue[0] != pszSingle[0] &&
       pszValue[0] != pszEscape[0]) {
     szTmp[iTmp]= '^';
     iTmp++;
   }
   for (i=0; i<nLength; i++) {
     if (pszValue[i] != pszWild[0] &&
         pszValue[i] != pszSingle[0] &&
         pszValue[i] != pszEscape[0]) {
       szTmp[iTmp] = pszValue[i];
       iTmp++;
       szTmp[iTmp] = '\0';
     } else if  (pszValue[i] == pszSingle[0]) {
       szTmp[iTmp] = '.';
       iTmp++;
       szTmp[iTmp] = '\0';
     } else if  (pszValue[i] == pszEscape[0]) {
       szTmp[iTmp] = '\\';
       iTmp++;
       szTmp[iTmp] = '\0';
     } else if (pszValue[i] == pszWild[0]) {
       szTmp[iTmp++] = '.';
       szTmp[iTmp++] = '*';
       szTmp[iTmp] = '\0';
     }
   }
   szTmp[iTmp] = '/';
   szTmp[++iTmp] = '\0';
   strlcat(szBuffer, szTmp, bufferSize);
   strlcat(szBuffer, "")"", bufferSize);
   return msStrdup(szBuffer);
 }","[40, 41]","Stack-based buffer overflow in MapServer before 6.0.6, 6.2.x before 6.2.4, 6.4.x before 6.4.5, and 7.0.x before 7.0.4 allows remote attackers to cause a denial of service (crash) or execute arbitrary code via vectors involving WFS get feature requests.",mapserver,CVE-2017-5522,CWE-119
2736,181426," flac_buffer_copy (SF_PRIVATE *psf)
 {	FLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;
 	const FLAC__Frame *frame = pflac->frame ;
 	const int32_t* const *buffer = pflac->wbuffer ;
 	unsigned i = 0, j, offset, channels, len ;
 	if (frame->header.blocksize > FLAC__MAX_BLOCK_SIZE)
 	{	psf_log_printf (psf, ""Ooops : frame->header.blocksize (%d) > FLAC__MAX_BLOCK_SIZE (%d)\n"", __func__, __LINE__, frame->header.blocksize, FLAC__MAX_BLOCK_SIZE) ;
 		psf->error = SFE_INTERNAL ;
 		return 0 ;
 		} ;
 	if (frame->header.channels > FLAC__MAX_CHANNELS)
 		psf_log_printf (psf, ""Ooops : frame->header.channels (%d) > FLAC__MAX_BLOCK_SIZE (%d)\n"", __func__, __LINE__, frame->header.channels, FLAC__MAX_CHANNELS) ;
 	channels = SF_MIN (frame->header.channels, FLAC__MAX_CHANNELS) ;
  	if (pflac->ptr == NULL)
  	{	 
		pflac->bufferbackup = SF_TRUE ;
  		for (i = 0 ; i < channels ; i++)
  		{
  			if (pflac->rbuffer [i] == NULL)
 				pflac->rbuffer [i] = calloc (FLAC__MAX_BLOCK_SIZE, sizeof (int32_t)) ;
 			memcpy (pflac->rbuffer [i], buffer [i], frame->header.blocksize * sizeof (int32_t)) ;
 			} ;
 		pflac->wbuffer = (const int32_t* const*) pflac->rbuffer ;
 		return 0 ;
 		} ;
  	len = SF_MIN (pflac->len, frame->header.blocksize) ;
 	if (pflac->remain % channels != 0)
 	{	psf_log_printf (psf, ""Error: pflac->remain %u    channels %u\n"", pflac->remain, channels) ;
 		return 0 ;
 		} ;
  	switch (pflac->pcmtype)
  	{	case PFLAC_PCM_SHORT :
  			{	short *retpcm = (short*) pflac->ptr ;
 				int shift = 16 - frame->header.bits_per_sample ;
 				if (shift < 0)
 				{	shift = abs (shift) ;
 					for (i = 0 ; i < len && pflac->remain > 0 ; i++)
 					{	offset = pflac->pos + i * channels ;
 						if (pflac->bufferpos >= frame->header.blocksize)
 							break ;
 						if (offset + channels > pflac->len)
 							break ;
 						for (j = 0 ; j < channels ; j++)
 							retpcm [offset + j] = buffer [j][pflac->bufferpos] >> shift ;
 						pflac->remain -= channels ;
 						pflac->bufferpos++ ;
 						}
 					}
 				else
 				{	for (i = 0 ; i < len && pflac->remain > 0 ; i++)
 					{	offset = pflac->pos + i * channels ;
 						if (pflac->bufferpos >= frame->header.blocksize)
 							break ;
 						if (offset + channels > pflac->len)
 							break ;
 						for (j = 0 ; j < channels ; j++)
 							retpcm [offset + j] = ((uint16_t) buffer [j][pflac->bufferpos]) << shift ;
 						pflac->remain -= channels ;
 						pflac->bufferpos++ ;
 						} ;
 					} ;
 				} ;
 			break ;
 		case PFLAC_PCM_INT :
 			{	int *retpcm = (int*) pflac->ptr ;
 				int shift = 32 - frame->header.bits_per_sample ;
 				for (i = 0 ; i < len && pflac->remain > 0 ; i++)
 				{	offset = pflac->pos + i * channels ;
 					if (pflac->bufferpos >= frame->header.blocksize)
 						break ;
 					if (offset + channels > pflac->len)
 						break ;
 					for (j = 0 ; j < channels ; j++)
 						retpcm [offset + j] = ((uint32_t) buffer [j][pflac->bufferpos]) << shift ;
 					pflac->remain -= channels ;
 					pflac->bufferpos++ ;
 					} ;
 				} ;
 			break ;
 		case PFLAC_PCM_FLOAT :
 			{	float *retpcm = (float*) pflac->ptr ;
 				float norm = (psf->norm_float == SF_TRUE) ? 1.0 / (1 << (frame->header.bits_per_sample - 1)) : 1.0 ;
 				for (i = 0 ; i < len && pflac->remain > 0 ; i++)
 				{	offset = pflac->pos + i * channels ;
 					if (pflac->bufferpos >= frame->header.blocksize)
 						break ;
 					if (offset + channels > pflac->len)
 						break ;
 					for (j = 0 ; j < channels ; j++)
 						retpcm [offset + j] = buffer [j][pflac->bufferpos] * norm ;
 					pflac->remain -= channels ;
 					pflac->bufferpos++ ;
 					} ;
 				} ;
 			break ;
 		case PFLAC_PCM_DOUBLE :
 			{	double *retpcm = (double*) pflac->ptr ;
 				double norm = (psf->norm_double == SF_TRUE) ? 1.0 / (1 << (frame->header.bits_per_sample - 1)) : 1.0 ;
 				for (i = 0 ; i < len && pflac->remain > 0 ; i++)
 				{	offset = pflac->pos + i * channels ;
 					if (pflac->bufferpos >= frame->header.blocksize)
 						break ;
 					if (offset + channels > pflac->len)
 						break ;
 					for (j = 0 ; j < channels ; j++)
 						retpcm [offset + j] = buffer [j][pflac->bufferpos] * norm ;
 					pflac->remain -= channels ;
 					pflac->bufferpos++ ;
 					} ;
 				} ;
 			break ;
 		default :
 			return 0 ;
 		} ;
 	offset = i * channels ;
 	pflac->pos += i * channels ;
 	return offset ;
 }  ","[16, 27, 28, 29, 30]","In libsndfile before 1.0.28, an error in the *flac_buffer_copy()* function (flac.c) can be exploited to cause a segmentation violation (with read memory access) via a specially crafted FLAC file during a resample attempt, a similar issue to CVE-2017-7585.",libsndfile,CVE-2017-7742,CWE-119
2770,181906," static int jpc_qcd_dumpparms(jpc_ms_t *ms, FILE *out)
 {
 	jpc_qcd_t *qcd = &ms->parms.qcd;
 	int i;
 	fprintf(out, ""qntsty = %d; numguard = %d; numstepsizes = %d\n"",
  	  (int) qcd->compparms.qntsty, qcd->compparms.numguard, qcd->compparms.numstepsizes);
  	for (i = 0; i < qcd->compparms.numstepsizes; ++i) {
  		fprintf(out, ""expn[%d] = 0x%04x; mant[%d] = 0x%04x;\n"",
		  i, (unsigned) JPC_QCX_GETEXPN(qcd->compparms.stepsizes[i]),
		  i, (unsigned) JPC_QCX_GETMANT(qcd->compparms.stepsizes[i]));
 		  i, JAS_CAST(unsigned, JPC_QCX_GETEXPN(qcd->compparms.stepsizes[i])),
 		  i, JAS_CAST(unsigned, JPC_QCX_GETMANT(qcd->compparms.stepsizes[i])));
  	}
  	return 0;
  }","[9, 10, 11, 12]",The jpc_bitstream_getbits function in jpc_bs.c in JasPer before 2.0.10 allows remote attackers to cause a denial of service (assertion failure) via a very large integer.,jasper,CVE-2016-9391,
2805,180940," atol8(const char *p, size_t char_cnt)
  {
  	int64_t l;
  	int digit;
 	if (char_cnt == 0)
 		return (0);
  	l = 0;
  	while (char_cnt-- > 0) {
  		if (*p >= '0' && *p <= '7')
 			digit = *p - '0';
 		else
 			break;
 		p++;
 		l <<= 3;
 		l |= digit;
 	}
 	return (l);
 }","[5, 6]","libarchive 3.3.2 allows remote attackers to cause a denial of service (xml_data heap-based buffer over-read and application crash) via a crafted xar archive, related to the mishandling of empty strings in the atol8 function in archive_read_support_format_xar.c.",libarchive,CVE-2017-14166,CWE-125
2819,182973," process_secondary_order(STREAM s)
 {
 	uint16 length;
  	uint16 flags;
  	uint8 type;
  	uint8 *next_order;
 	struct stream packet = *s;
  	in_uint16_le(s, length);
  	in_uint16_le(s, flags);	 
  	in_uint8(s, type);
 	if (!s_check_rem(s, length + 7))
 	{
 		rdp_protocol_error(""process_secondary_order(), next order pointer would overrun stream"", &packet);
 	}
  	next_order = s->p + (sint16) length + 7;
  	switch (type)
 	{
 		case RDP_ORDER_RAW_BMPCACHE:
 			process_raw_bmpcache(s);
 			break;
 		case RDP_ORDER_COLCACHE:
 			process_colcache(s);
 			break;
 		case RDP_ORDER_BMPCACHE:
 			process_bmpcache(s);
 			break;
 		case RDP_ORDER_FONTCACHE:
 			process_fontcache(s);
 			break;
 		case RDP_ORDER_RAW_BMPCACHE2:
 			process_bmpcache2(s, flags, False);	 
 			break;
 		case RDP_ORDER_BMPCACHE2:
 			process_bmpcache2(s, flags, True);	 
 			break;
 		case RDP_ORDER_BRUSHCACHE:
 			process_brushcache(s, flags);
 			break;
 		default:
 			logger(Graphics, Warning,
 			       ""process_secondary_order(), unhandled secondary order %d"", type);
 	}
 	s->p = next_order;
 }","[7, 11, 12, 13, 14]",rdesktop versions up to and including v1.8.3 contain a Buffer Overflow over the global variables in the function seamless_process_line() that results in memory corruption and probably even a remote code execution.,rdesktop,CVE-2018-20182,CWE-119
2820,181892," static int jpc_enc_encodemainhdr(jpc_enc_t *enc)
 {
 	jpc_siz_t *siz;
 	jpc_cod_t *cod;
 	jpc_qcd_t *qcd;
 	int i;
 long startoff;
 long mainhdrlen;
 	jpc_enc_cp_t *cp;
 	jpc_qcc_t *qcc;
 	jpc_enc_tccp_t *tccp;
 	uint_fast16_t cmptno;
 	jpc_tsfb_band_t bandinfos[JPC_MAXBANDS];
 	jpc_fix_t mctsynweight;
 	jpc_enc_tcp_t *tcp;
 	jpc_tsfb_t *tsfb;
 	jpc_tsfb_band_t *bandinfo;
 	uint_fast16_t numbands;
 	uint_fast16_t bandno;
 	uint_fast16_t rlvlno;
 	uint_fast16_t analgain;
 	jpc_fix_t absstepsize;
 	char buf[1024];
 	jpc_com_t *com;
 	cp = enc->cp;
 startoff = jas_stream_getrwcount(enc->out);
 	if (!(enc->mrk = jpc_ms_create(JPC_MS_SOC))) {
 		return -1;
 	}
 	if (jpc_putms(enc->out, enc->cstate, enc->mrk)) {
 		jas_eprintf(""cannot write SOC marker\n"");
 		return -1;
 	}
 	jpc_ms_destroy(enc->mrk);
 	enc->mrk = 0;
 	if (!(enc->mrk = jpc_ms_create(JPC_MS_SIZ))) {
 		return -1;
 	}
 	siz = &enc->mrk->parms.siz;
 	siz->caps = 0;
 	siz->xoff = cp->imgareatlx;
 	siz->yoff = cp->imgareatly;
 	siz->width = cp->refgrdwidth;
 	siz->height = cp->refgrdheight;
 	siz->tilexoff = cp->tilegrdoffx;
 	siz->tileyoff = cp->tilegrdoffy;
 	siz->tilewidth = cp->tilewidth;
 	siz->tileheight = cp->tileheight;
 	siz->numcomps = cp->numcmpts;
 	siz->comps = jas_alloc2(siz->numcomps, sizeof(jpc_sizcomp_t));
 	assert(siz->comps);
 	for (i = 0; i < JAS_CAST(int, cp->numcmpts); ++i) {
 		siz->comps[i].prec = cp->ccps[i].prec;
 		siz->comps[i].sgnd = cp->ccps[i].sgnd;
 		siz->comps[i].hsamp = cp->ccps[i].sampgrdstepx;
 		siz->comps[i].vsamp = cp->ccps[i].sampgrdstepy;
 	}
 	if (jpc_putms(enc->out, enc->cstate, enc->mrk)) {
 		jas_eprintf(""cannot write SIZ marker\n"");
 		return -1;
 	}
 	jpc_ms_destroy(enc->mrk);
 	enc->mrk = 0;
 	if (!(enc->mrk = jpc_ms_create(JPC_MS_COM))) {
 		return -1;
 	}
 	sprintf(buf, ""Creator: JasPer Version %s"", jas_getversion());
  	com = &enc->mrk->parms.com;
  	com->len = JAS_CAST(uint_fast16_t, strlen(buf));
  	com->regid = JPC_COM_LATIN;
	if (!(com->data = JAS_CAST(uchar *, jas_strdup(buf)))) {
 	if (!(com->data = JAS_CAST(jas_uchar *, jas_strdup(buf)))) {
  		abort();
  	}
  	if (jpc_putms(enc->out, enc->cstate, enc->mrk)) {
 		jas_eprintf(""cannot write COM marker\n"");
 		return -1;
 	}
 	jpc_ms_destroy(enc->mrk);
 	enc->mrk = 0;
 #if 0
 	if (!(enc->mrk = jpc_ms_create(JPC_MS_CRG))) {
 		return -1;
 	}
 	crg = &enc->mrk->parms.crg;
 	crg->comps = jas_alloc2(crg->numcomps, sizeof(jpc_crgcomp_t));
 	if (jpc_putms(enc->out, enc->cstate, enc->mrk)) {
 		jas_eprintf(""cannot write CRG marker\n"");
 		return -1;
 	}
 	jpc_ms_destroy(enc->mrk);
 	enc->mrk = 0;
 #endif
 	tcp = &cp->tcp;
 	tccp = &cp->tccp;
 	for (cmptno = 0; cmptno < cp->numcmpts; ++cmptno) {
 		tsfb = jpc_cod_gettsfb(tccp->qmfbid, tccp->maxrlvls - 1);
 		jpc_tsfb_getbands(tsfb, 0, 0, 1 << tccp->maxrlvls, 1 << tccp->maxrlvls,
 		  bandinfos);
 		jpc_tsfb_destroy(tsfb);
 		mctsynweight = jpc_mct_getsynweight(tcp->mctid, cmptno);
 		numbands = 3 * tccp->maxrlvls - 2;
 		for (bandno = 0, bandinfo = bandinfos; bandno < numbands;
 		  ++bandno, ++bandinfo) {
 			rlvlno = (bandno) ? ((bandno - 1) / 3 + 1) : 0;
 			analgain = JPC_NOMINALGAIN(tccp->qmfbid, tccp->maxrlvls,
 			  rlvlno, bandinfo->orient);
 			if (!tcp->intmode) {
 				absstepsize = jpc_fix_div(jpc_inttofix(1 <<
 				  (analgain + 1)), bandinfo->synenergywt);
 			} else {
 				absstepsize = jpc_inttofix(1);
 			}	
 			cp->ccps[cmptno].stepsizes[bandno] =
 			  jpc_abstorelstepsize(absstepsize,
 			  cp->ccps[cmptno].prec + analgain);
 		}
 		cp->ccps[cmptno].numstepsizes = numbands;
 	}
 	if (!(enc->mrk = jpc_ms_create(JPC_MS_COD))) {
 		return -1;
 	}
 	cod = &enc->mrk->parms.cod;
 	cod->csty = cp->tccp.csty | cp->tcp.csty;
 	cod->compparms.csty = cp->tccp.csty | cp->tcp.csty;
 	cod->compparms.numdlvls = cp->tccp.maxrlvls - 1;
 	cod->compparms.numrlvls = cp->tccp.maxrlvls;
 	cod->prg = cp->tcp.prg;
 	cod->numlyrs = cp->tcp.numlyrs;
 	cod->compparms.cblkwidthval = JPC_COX_CBLKSIZEEXPN(cp->tccp.cblkwidthexpn);
 	cod->compparms.cblkheightval = JPC_COX_CBLKSIZEEXPN(cp->tccp.cblkheightexpn);
 	cod->compparms.cblksty = cp->tccp.cblksty;
 	cod->compparms.qmfbid = cp->tccp.qmfbid;
 	cod->mctrans = (cp->tcp.mctid != JPC_MCT_NONE);
 	if (tccp->csty & JPC_COX_PRT) {
 		for (rlvlno = 0; rlvlno < tccp->maxrlvls; ++rlvlno) {
 			cod->compparms.rlvls[rlvlno].parwidthval = tccp->prcwidthexpns[rlvlno];
 			cod->compparms.rlvls[rlvlno].parheightval = tccp->prcheightexpns[rlvlno];
 		}
 	}
 	if (jpc_putms(enc->out, enc->cstate, enc->mrk)) {
 		jas_eprintf(""cannot write COD marker\n"");
 		return -1;
 	}
 	jpc_ms_destroy(enc->mrk);
 	enc->mrk = 0;
 	if (!(enc->mrk = jpc_ms_create(JPC_MS_QCD))) {
 		return -1;
 	}
 	qcd = &enc->mrk->parms.qcd;
 	qcd->compparms.qntsty = (tccp->qmfbid == JPC_COX_INS) ?
 	  JPC_QCX_SEQNT : JPC_QCX_NOQNT;
 	qcd->compparms.numstepsizes = cp->ccps[0].numstepsizes;
 	qcd->compparms.numguard = cp->tccp.numgbits;
 	qcd->compparms.stepsizes = cp->ccps[0].stepsizes;
 	if (jpc_putms(enc->out, enc->cstate, enc->mrk)) {
 		return -1;
 	}
 	qcd->compparms.stepsizes = 0;
 	jpc_ms_destroy(enc->mrk);
 	enc->mrk = 0;
 	tccp = &cp->tccp;
 	for (cmptno = 1; cmptno < cp->numcmpts; ++cmptno) {
 		if (!(enc->mrk = jpc_ms_create(JPC_MS_QCC))) {
 			return -1;
 		}
 		qcc = &enc->mrk->parms.qcc;
 		qcc->compno = cmptno;
 		qcc->compparms.qntsty = (tccp->qmfbid == JPC_COX_INS) ?
 		  JPC_QCX_SEQNT : JPC_QCX_NOQNT;
 		qcc->compparms.numstepsizes = cp->ccps[cmptno].numstepsizes;
 		qcc->compparms.numguard = cp->tccp.numgbits;
 		qcc->compparms.stepsizes = cp->ccps[cmptno].stepsizes;
 		if (jpc_putms(enc->out, enc->cstate, enc->mrk)) {
 			return -1;
 		}
 		qcc->compparms.stepsizes = 0;
 		jpc_ms_destroy(enc->mrk);
 		enc->mrk = 0;
 	}
 #define MAINTLRLEN	2
 	mainhdrlen = jas_stream_getrwcount(enc->out) - startoff;
 	enc->len += mainhdrlen;
 	if (enc->cp->totalsize != UINT_FAST32_MAX) {
 		uint_fast32_t overhead;
 		overhead = mainhdrlen + MAINTLRLEN;
 		enc->mainbodysize = (enc->cp->totalsize >= overhead) ?
 		  (enc->cp->totalsize - overhead) : 0;
 	} else {
 		enc->mainbodysize = UINT_FAST32_MAX;
 	}
 	return 0;
 }","[71, 72]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
2821,182929," static char *escape_pathname(const char *inp)
 {
     const unsigned char *s;
     char *escaped, *d;
     if (!inp) {
         return NULL;
      }
      escaped = malloc (4 * strlen(inp) + 1);
      if (!escaped) {
    	perror(""malloc"");
	return NULL;
 		perror(""malloc"");
 		return NULL;
      }
      for (d = escaped, s = (const unsigned char *)inp; *s; s++) {
          if (needs_escape (*s)) {
             snprintf (d, 5, ""\\x%02x"", *s);
             d += strlen (d);
         } else {
             *d++ = *s;
         }
     }
     *d++ = '\0';
     return escaped;
 }","[10, 11, 12, 13]",Boa through 0.94.14rc21 allows remote attackers to trigger a memory leak because of missing calls to the free function.,boa,CVE-2018-21028,
2844,180648," static pfunc check_literal(struct jv_parser* p) {
   if (p->tokenpos == 0) return 0;
   const char* pattern = 0;
   int plen;
   jv v;
   switch (p->tokenbuf[0]) {
   case 't': pattern = ""true""; plen = 4; v = jv_true(); break;
   case 'f': pattern = ""false""; plen = 5; v = jv_false(); break;
   case 'n': pattern = ""null""; plen = 4; v = jv_null(); break;
   }
   if (pattern) {
     if (p->tokenpos != plen) return ""Invalid literal"";
     for (int i=0; i<plen; i++)
       if (p->tokenbuf[i] != pattern[i])
         return ""Invalid literal"";
      TRY(value(p, v));
    } else {
    p->tokenbuf[p->tokenpos] = 0;  
     p->tokenbuf[p->tokenpos] = 0;
      char* end = 0;
      double d = jvp_strtod(&p->dtoa, p->tokenbuf, &end);
      if (end == 0 || *end != 0)
       return ""Invalid numeric literal"";
     TRY(value(p, jv_number(d)));
   }
   p->tokenpos = 0;
   return 0;
 }","[18, 19]","Off-by-one error in the tokenadd function in jv_parse.c in jq allows remote attackers to cause a denial of service (crash) via a long JSON-encoded number, which triggers a heap-based buffer overflow.",jq,CVE-2015-8863,CWE-119
2853,180493," read_SubStreamsInfo(struct archive_read *a, struct _7z_substream_info *ss,
     struct _7z_folder *f, size_t numFolders)
 {
 	const unsigned char *p;
 	uint64_t *usizes;
 	size_t unpack_streams;
 	int type;
 	unsigned i;
 	uint32_t numDigests;
 	memset(ss, 0, sizeof(*ss));
 	for (i = 0; i < numFolders; i++)
 		f[i].numUnpackStreams = 1;
 	if ((p = header_bytes(a, 1)) == NULL)
 		return (-1);
 	type = *p;
 	if (type == kNumUnPackStream) {
 		unpack_streams = 0;
 		for (i = 0; i < numFolders; i++) {
 			if (parse_7zip_uint64(a, &(f[i].numUnpackStreams)) < 0)
  				return (-1);
  			if (UMAX_ENTRY < f[i].numUnpackStreams)
  				return (-1);
 			if (unpack_streams > SIZE_MAX - UMAX_ENTRY) {
 				return (-1);
 			}
  			unpack_streams += (size_t)f[i].numUnpackStreams;
  		}
  		if ((p = header_bytes(a, 1)) == NULL)
 			return (-1);
 		type = *p;
 	} else
 		unpack_streams = numFolders;
 	ss->unpack_streams = unpack_streams;
 	if (unpack_streams) {
 		ss->unpackSizes = calloc(unpack_streams,
 		    sizeof(*ss->unpackSizes));
 		ss->digestsDefined = calloc(unpack_streams,
 		    sizeof(*ss->digestsDefined));
 		ss->digests = calloc(unpack_streams,
 		    sizeof(*ss->digests));
 		if (ss->unpackSizes == NULL || ss->digestsDefined == NULL ||
 		    ss->digests == NULL)
 			return (-1);
 	}
 	usizes = ss->unpackSizes;
 	for (i = 0; i < numFolders; i++) {
 		unsigned pack;
 		uint64_t sum;
 		if (f[i].numUnpackStreams == 0)
 			continue;
 		sum = 0;
 		if (type == kSize) {
 			for (pack = 1; pack < f[i].numUnpackStreams; pack++) {
 				if (parse_7zip_uint64(a, usizes) < 0)
 					return (-1);
 				sum += *usizes++;
 			}
 		}
 		*usizes++ = folder_uncompressed_size(&f[i]) - sum;
 	}
 	if (type == kSize) {
 		if ((p = header_bytes(a, 1)) == NULL)
 			return (-1);
 		type = *p;
 	}
 	for (i = 0; i < unpack_streams; i++) {
 		ss->digestsDefined[i] = 0;
 		ss->digests[i] = 0;
 	}
 	numDigests = 0;
 	for (i = 0; i < numFolders; i++) {
 		if (f[i].numUnpackStreams != 1 || !f[i].digest_defined)
 			numDigests += (uint32_t)f[i].numUnpackStreams;
 	}
 	if (type == kCRC) {
 		struct _7z_digests tmpDigests;
 		unsigned char *digestsDefined = ss->digestsDefined;
 		uint32_t * digests = ss->digests;
 		int di = 0;
 		memset(&tmpDigests, 0, sizeof(tmpDigests));
 		if (read_Digests(a, &(tmpDigests), numDigests) < 0) {
 			free_Digest(&tmpDigests);
 			return (-1);
 		}
 		for (i = 0; i < numFolders; i++) {
 			if (f[i].numUnpackStreams == 1 && f[i].digest_defined) {
 				*digestsDefined++ = 1;
 				*digests++ = f[i].digest;
 			} else {
 				unsigned j;
 				for (j = 0; j < f[i].numUnpackStreams;
 				    j++, di++) {
 					*digestsDefined++ =
 					    tmpDigests.defineds[di];
 					*digests++ =
 					    tmpDigests.digests[di];
 				}
 			}
 		}
 		free_Digest(&tmpDigests);
 		if ((p = header_bytes(a, 1)) == NULL)
 			return (-1);
 		type = *p;
 	}
 	if (type != kEnd)
 		return (-1);
 	return (0);
 }","[23, 24, 25]","Integer overflow in the read_SubStreamsInfo function in archive_read_support_format_7zip.c in libarchive before 3.2.1 allows remote attackers to execute arbitrary code via a 7zip file with a large number of substreams, which triggers a heap-based buffer overflow.",libarchive,CVE-2016-4300,CWE-190
2871,181644," void jp2_box_dump(jp2_box_t *box, FILE *out)
 {
 	jp2_boxinfo_t *boxinfo;
 	boxinfo = jp2_boxinfolookup(box->type);
  	assert(boxinfo);
  	fprintf(out, ""JP2 box: "");
	fprintf(out, ""type=%c%s%c (0x%08""PRIxFAST32""); length=%""PRIuFAST32""\n"", '""', boxinfo->name,
	  '""', box->type, box->len);
 	fprintf(out, ""type=%c%s%c (0x%08""PRIxFAST32""); length=%""PRIuFAST32""\n"", '""',
 	  boxinfo->name, '""', box->type, box->len);
  	if (box->ops->dumpdata) {
  		(*box->ops->dumpdata)(box, out);
  	}
 }","[7, 8, 9, 10]",The jp2_colr_destroy function in jp2_cod.c in JasPer before 1.900.13 allows remote attackers to cause a denial of service (NULL pointer dereference) by leveraging incorrect cleanup of JP2 box data on error. NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-8887.,jasper,CVE-2016-10250,CWE-476
2889,181899,"  int pgx_validate(jas_stream_t *in)
  {
	uchar buf[PGX_MAGICLEN];
 	jas_uchar buf[PGX_MAGICLEN];
  	uint_fast32_t magic;
  	int i;
  	int n;
 	assert(JAS_STREAM_MAXPUTBACK >= PGX_MAGICLEN);
 	if ((n = jas_stream_read(in, buf, PGX_MAGICLEN)) < 0) {
 		return -1;
 	}
 	for (i = n - 1; i >= 0; --i) {
 		if (jas_stream_ungetc(in, buf[i]) == EOF) {
 			return -1;
 		}
 	}
 	if (n < PGX_MAGICLEN) {
 		return -1;
 	}
 	magic = (buf[0] << 8) | buf[1];
 	if (magic != PGX_MAGIC) {
 		return -1;
 	}
 	return 0;
 }","[3, 4]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
2905,180404," void read_boot(DOS_FS * fs)
 {
      struct boot_sector b;
      unsigned total_sectors;
      unsigned short logical_sector_size, sectors;
    unsigned fat_length;
     off_t fat_length;
      unsigned total_fat_entries;
      off_t data_size;
     fs_read(0, sizeof(b), &b);
     logical_sector_size = GET_UNALIGNED_W(b.sector_size);
     if (!logical_sector_size)
 	die(""Logical sector size is zero."");
     if (logical_sector_size & (SECTOR_SIZE - 1))
 	die(""Logical sector size (%d bytes) is not a multiple of the physical ""
 	    ""sector size."", logical_sector_size);
     fs->cluster_size = b.cluster_size * logical_sector_size;
     if (!fs->cluster_size)
 	die(""Cluster size is zero."");
     if (b.fats != 2 && b.fats != 1)
 	die(""Currently, only 1 or 2 FATs are supported, not %d.\n"", b.fats);
     fs->nfats = b.fats;
     sectors = GET_UNALIGNED_W(b.sectors);
     total_sectors = sectors ? sectors : le32toh(b.total_sect);
     if (verbose)
 	printf(""Checking we can access the last sector of the filesystem\n"");
      fs_test((off_t)((total_sectors & ~1) - 1) * logical_sector_size,
  	    logical_sector_size);
      fat_length = le16toh(b.fat_length) ?
  	le16toh(b.fat_length) : le32toh(b.fat32_length);
     if (!fat_length)
 	die(""FAT size is zero."");
      fs->fat_start = (off_t)le16toh(b.reserved) * logical_sector_size;
      fs->root_start = ((off_t)le16toh(b.reserved) + b.fats * fat_length) *
  	logical_sector_size;
      fs->root_entries = GET_UNALIGNED_W(b.dir_entries);
      fs->data_start = fs->root_start + ROUND_TO_MULTIPLE(fs->root_entries <<
  							MSDOS_DIR_BITS,
  							logical_sector_size);
      data_size = (off_t)total_sectors * logical_sector_size - fs->data_start;
     if (data_size < fs->cluster_size)
 	die(""Filesystem has no space for any data clusters"");
      fs->data_clusters = data_size / fs->cluster_size;
      fs->root_cluster = 0;	 
      fs->fsinfo_start = 0;	 
     fs->free_clusters = -1;	 
     if (!b.fat_length && b.fat32_length) {
 	fs->fat_bits = 32;
 	fs->root_cluster = le32toh(b.root_cluster);
 	if (!fs->root_cluster && fs->root_entries)
 	    printf(""Warning: FAT32 root dir not in cluster chain! ""
 		   ""Compatibility mode...\n"");
 	else if (!fs->root_cluster && !fs->root_entries)
 	    die(""No root directory!"");
 	else if (fs->root_cluster && fs->root_entries)
 	    printf(""Warning: FAT32 root dir is in a cluster chain, but ""
 		   ""a separate root dir\n""
 		   ""  area is defined. Cannot fix this easily.\n"");
 	if (fs->data_clusters < FAT16_THRESHOLD)
 	    printf(""Warning: Filesystem is FAT32 according to fat_length ""
 		   ""and fat32_length fields,\n""
 		   ""  but has only %lu clusters, less than the required ""
 		   ""minimum of %d.\n""
 		   ""  This may lead to problems on some systems.\n"",
 		   (unsigned long)fs->data_clusters, FAT16_THRESHOLD);
 	check_fat_state_bit(fs, &b);
 	fs->backupboot_start = le16toh(b.backup_boot) * logical_sector_size;
 	check_backup_boot(fs, &b, logical_sector_size);
 	read_fsinfo(fs, &b, logical_sector_size);
     } else if (!atari_format) {
 	fs->fat_bits = (fs->data_clusters >= FAT12_THRESHOLD) ? 16 : 12;
 	if (fs->data_clusters >= FAT16_THRESHOLD)
 	    die(""Too many clusters (%lu) for FAT16 filesystem."", fs->data_clusters);
 	check_fat_state_bit(fs, &b);
     } else {
 	fs->fat_bits = 16;	 
 	if (fs->data_clusters + 2 > fat_length * logical_sector_size * 8 / 16 ||
 	    (total_sectors == 720 || total_sectors == 1440 ||
 	     total_sectors == 2880))
 	    fs->fat_bits = 12;
     }
     fs->eff_fat_bits = (fs->fat_bits == 32) ? 28 : fs->fat_bits;
     fs->fat_size = fat_length * logical_sector_size;
     fs->label = calloc(12, sizeof(uint8_t));
     if (fs->fat_bits == 12 || fs->fat_bits == 16) {
 	struct boot_sector_16 *b16 = (struct boot_sector_16 *)&b;
 	if (b16->extended_sig == 0x29)
 	    memmove(fs->label, b16->label, 11);
 	else
 	    fs->label = NULL;
     } else if (fs->fat_bits == 32) {
 	if (b.extended_sig == 0x29)
 	    memmove(fs->label, &b.label, 11);
 	else
 	    fs->label = NULL;
     }
     total_fat_entries = (uint64_t)fs->fat_size * 8 / fs->fat_bits;
     if (fs->data_clusters > total_fat_entries - 2)
 	die(""Filesystem has %u clusters but only space for %u FAT entries."",
 	    fs->data_clusters, total_fat_entries - 2);
     if (!fs->root_entries && !fs->root_cluster)
 	die(""Root directory has zero size."");
     if (fs->root_entries & (MSDOS_DPS - 1))
 	die(""Root directory (%d entries) doesn't span an integral number of ""
 	    ""sectors."", fs->root_entries);
     if (logical_sector_size & (SECTOR_SIZE - 1))
 	die(""Logical sector size (%d bytes) is not a multiple of the physical ""
 	    ""sector size."", logical_sector_size);
 #if 0				 
     if (!atari_format && (!b.secs_track || !b.heads))
 	die(""Invalid disk format in boot sector."");
 #endif
     if (verbose)
 	dump_boot(fs, &b, logical_sector_size);
 }","[6, 7, 31, 32, 41, 42]","The read_boot function in boot.c in dosfstools before 4.0 allows attackers to cause a denial of service (crash) via a crafted filesystem, which triggers a heap-based buffer overflow in the (1) read_fat function or an out-of-bounds heap read in (2) get_fat function.",dosfstools,CVE-2016-4804,CWE-119
2909,181873,"  int jas_matrix_cmp(jas_matrix_t *mat0, jas_matrix_t *mat1)
  {
	int i;
	int j;
 	jas_matind_t i;
 	jas_matind_t j;
  	if (mat0->numrows_ != mat1->numrows_ || mat0->numcols_ !=
  	  mat1->numcols_) {
 		return 1;
 	}
 	for (i = 0; i < mat0->numrows_; i++) {
 		for (j = 0; j < mat0->numcols_; j++) {
 			if (jas_matrix_get(mat0, i, j) != jas_matrix_get(mat1, i, j)) {
 				return 1;
 			}
 		}
 	}
 	return 0;
 }","[3, 4, 5, 6]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
2912,179575,"  findoprnd(ITEM *ptr, int32 *pos)
  {
 	check_stack_depth();
  #ifdef BS_DEBUG
  	elog(DEBUG3, (ptr[*pos].type == OPR) ?
  		 ""%d  %c"" : ""%d  %d"", *pos, ptr[*pos].val);
 #endif
 	if (ptr[*pos].type == VAL)
 	{
 		ptr[*pos].left = 0;
 		(*pos)--;
 	}
 	else if (ptr[*pos].val == (int32) '!')
 	{
 		ptr[*pos].left = -1;
 		(*pos)--;
 		findoprnd(ptr, pos);
 	}
 	else
 	{
 		ITEM	   *curitem = &ptr[*pos];
 		int32		tmp = *pos;
 		(*pos)--;
 		findoprnd(ptr, pos);
 		curitem->left = *pos - tmp;
 		findoprnd(ptr, pos);
 	}
 }",[3],"Multiple integer overflows in contrib/hstore/hstore_io.c in PostgreSQL 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact via vectors related to the (1) hstore_recv, (2) hstore_from_arrays, and (3) hstore_from_array functions in contrib/hstore/hstore_io.c; and the (4) hstoreArrayToPairs function in contrib/hstore/hstore_op.c, which triggers a buffer overflow.  NOTE: this issue was SPLIT from CVE-2014-0064 because it has a different set of affected versions.",postgres,CVE-2014-2669,CWE-189
2917,181914," static int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms)
 {
 	jpc_siz_t *siz = &ms->parms.siz;
 	int compno;
 	int tileno;
 	jpc_dec_tile_t *tile;
 	jpc_dec_tcomp_t *tcomp;
  	int htileno;
  	int vtileno;
  	jpc_dec_cmpt_t *cmpt;
 	size_t size;
  	dec->xstart = siz->xoff;
  	dec->ystart = siz->yoff;
 	dec->xend = siz->width;
 	dec->yend = siz->height;
 	dec->tilewidth = siz->tilewidth;
 	dec->tileheight = siz->tileheight;
 	dec->tilexoff = siz->tilexoff;
 	dec->tileyoff = siz->tileyoff;
 	dec->numcomps = siz->numcomps;
 	if (!(dec->cp = jpc_dec_cp_create(dec->numcomps))) {
 		return -1;
 	}
 	if (!(dec->cmpts = jas_alloc2(dec->numcomps, sizeof(jpc_dec_cmpt_t)))) {
 		return -1;
 	}
 	for (compno = 0, cmpt = dec->cmpts; compno < dec->numcomps; ++compno,
 	  ++cmpt) {
 		cmpt->prec = siz->comps[compno].prec;
 		cmpt->sgnd = siz->comps[compno].sgnd;
 		cmpt->hstep = siz->comps[compno].hsamp;
 		cmpt->vstep = siz->comps[compno].vsamp;
 		cmpt->width = JPC_CEILDIV(dec->xend, cmpt->hstep) -
 		  JPC_CEILDIV(dec->xstart, cmpt->hstep);
 		cmpt->height = JPC_CEILDIV(dec->yend, cmpt->vstep) -
 		  JPC_CEILDIV(dec->ystart, cmpt->vstep);
 		cmpt->hsubstep = 0;
 		cmpt->vsubstep = 0;
 	}
 	dec->image = 0;
  	dec->numhtiles = JPC_CEILDIV(dec->xend - dec->tilexoff, dec->tilewidth);
  	dec->numvtiles = JPC_CEILDIV(dec->yend - dec->tileyoff, dec->tileheight);
	dec->numtiles = dec->numhtiles * dec->numvtiles;
 	if (!jas_safe_size_mul(dec->numhtiles, dec->numvtiles, &size)) {
 		return -1;
 	}
 	dec->numtiles = size;
  	JAS_DBGLOG(10, (""numtiles = %d; numhtiles = %d; numvtiles = %d;\n"",
  	  dec->numtiles, dec->numhtiles, dec->numvtiles));
  	if (!(dec->tiles = jas_alloc2(dec->numtiles, sizeof(jpc_dec_tile_t)))) {
 		return -1;
 	}
 	for (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,
 	  ++tile) {
 		htileno = tileno % dec->numhtiles;
 		vtileno = tileno / dec->numhtiles;
 		tile->realmode = 0;
 		tile->state = JPC_TILE_INIT;
 		tile->xstart = JAS_MAX(dec->tilexoff + htileno * dec->tilewidth,
 		  dec->xstart);
 		tile->ystart = JAS_MAX(dec->tileyoff + vtileno * dec->tileheight,
 		  dec->ystart);
 		tile->xend = JAS_MIN(dec->tilexoff + (htileno + 1) *
 		  dec->tilewidth, dec->xend);
 		tile->yend = JAS_MIN(dec->tileyoff + (vtileno + 1) *
 		  dec->tileheight, dec->yend);
 		tile->numparts = 0;
 		tile->partno = 0;
 		tile->pkthdrstream = 0;
 		tile->pkthdrstreampos = 0;
 		tile->pptstab = 0;
 		tile->cp = 0;
 		tile->pi = 0;
 		if (!(tile->tcomps = jas_alloc2(dec->numcomps,
 		  sizeof(jpc_dec_tcomp_t)))) {
 			return -1;
 		}
 		for (compno = 0, cmpt = dec->cmpts, tcomp = tile->tcomps;
 		  compno < dec->numcomps; ++compno, ++cmpt, ++tcomp) {
 			tcomp->rlvls = 0;
 			tcomp->numrlvls = 0;
 			tcomp->data = 0;
 			tcomp->xstart = JPC_CEILDIV(tile->xstart, cmpt->hstep);
 			tcomp->ystart = JPC_CEILDIV(tile->ystart, cmpt->vstep);
 			tcomp->xend = JPC_CEILDIV(tile->xend, cmpt->hstep);
 			tcomp->yend = JPC_CEILDIV(tile->yend, cmpt->vstep);
 			tcomp->tsfb = 0;
 		}
 	}
 	dec->pkthdrstreams = 0;
 	dec->state = JPC_MH;
 	return 0;
 }","[11, 43, 44, 45, 46, 47]","Integer overflow in the jpc_dec_process_siz function in libjasper/jpc/jpc_dec.c in JasPer before 1.900.13 allows remote attackers to have unspecified impact via a crafted file, which triggers an assertion failure.",jasper,CVE-2016-9387,CWE-190
2934,181932," static int jpc_siz_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate,
   jas_stream_t *in)
 {
 	jpc_siz_t *siz = &ms->parms.siz;
 	unsigned int i;
 	uint_fast8_t tmp;
 	cstate = 0;
 	if (jpc_getuint16(in, &siz->caps) ||
 	  jpc_getuint32(in, &siz->width) ||
 	  jpc_getuint32(in, &siz->height) ||
 	  jpc_getuint32(in, &siz->xoff) ||
 	  jpc_getuint32(in, &siz->yoff) ||
 	  jpc_getuint32(in, &siz->tilewidth) ||
 	  jpc_getuint32(in, &siz->tileheight) ||
 	  jpc_getuint32(in, &siz->tilexoff) ||
 	  jpc_getuint32(in, &siz->tileyoff) ||
 	  jpc_getuint16(in, &siz->numcomps)) {
 		return -1;
 	}
 	if (!siz->width || !siz->height || !siz->tilewidth ||
 	  !siz->tileheight || !siz->numcomps) {
 		return -1;
 	}
 	if (!(siz->comps = jas_alloc2(siz->numcomps, sizeof(jpc_sizcomp_t)))) {
 		return -1;
 	}
 	for (i = 0; i < siz->numcomps; ++i) {
 		if (jpc_getuint8(in, &tmp) ||
 		  jpc_getuint8(in, &siz->comps[i].hsamp) ||
 		  jpc_getuint8(in, &siz->comps[i].vsamp)) {
  			jas_free(siz->comps);
  			return -1;
  		}
 		if (siz->comps[i].hsamp == 0 || siz->comps[i].hsamp > 255) {
 			jas_eprintf(""invalid XRsiz value %d\n"", siz->comps[i].hsamp);
 			jas_free(siz->comps);
 			return -1;
 		}
 		if (siz->comps[i].vsamp == 0 || siz->comps[i].vsamp > 255) {
 			jas_eprintf(""invalid YRsiz value %d\n"", siz->comps[i].vsamp);
 			jas_free(siz->comps);
 			return -1;
 		}
  		siz->comps[i].sgnd = (tmp >> 7) & 1;
  		siz->comps[i].prec = (tmp & 0x7f) + 1;
  	}
 	if (jas_stream_eof(in)) {
 		jas_free(siz->comps);
 		return -1;
 	}
 	return 0;
 }","[34, 35, 36, 37, 38, 39, 40, 41, 42, 43]",The jpc_dec_process_siz function in libjasper/jpc/jpc_dec.c in JasPer before 1.900.4 allows remote attackers to cause a denial of service (divide-by-zero error and application crash) via a crafted YRsiz value in a BMP image to the imginfo command.,jasper,CVE-2016-8692,CWE-369
2941,180491," parse_codes(struct archive_read *a)
 {
   int i, j, val, n, r;
   unsigned char bitlengths[MAX_SYMBOLS], zerocount, ppmd_flags;
   unsigned int maxorder;
   struct huffman_code precode;
   struct rar *rar = (struct rar *)(a->format->data);
   struct rar_br *br = &(rar->br);
   free_codes(a);
   rar_br_consume_unalined_bits(br);
   if (!rar_br_read_ahead(a, br, 1))
     goto truncated_data;
   if ((rar->is_ppmd_block = rar_br_bits(br, 1)) != 0)
   {
     rar_br_consume(br, 1);
     if (!rar_br_read_ahead(a, br, 7))
       goto truncated_data;
     ppmd_flags = rar_br_bits(br, 7);
     rar_br_consume(br, 7);
     if (ppmd_flags & 0x20)
     {
       if (!rar_br_read_ahead(a, br, 8))
         goto truncated_data;
       rar->dictionary_size = (rar_br_bits(br, 8) + 1) << 20;
       rar_br_consume(br, 8);
     }
     if (ppmd_flags & 0x40)
     {
       if (!rar_br_read_ahead(a, br, 8))
         goto truncated_data;
       rar->ppmd_escape = rar->ppmd7_context.InitEsc = rar_br_bits(br, 8);
       rar_br_consume(br, 8);
     }
     else
       rar->ppmd_escape = 2;
     if (ppmd_flags & 0x20)
     {
       maxorder = (ppmd_flags & 0x1F) + 1;
       if(maxorder > 16)
         maxorder = 16 + (maxorder - 16) * 3;
       if (maxorder == 1)
       {
         archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                           ""Truncated RAR file data"");
         return (ARCHIVE_FATAL);
       }
       __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context, &g_szalloc);
       rar->bytein.a = a;
       rar->bytein.Read = &ppmd_read;
       __archive_ppmd7_functions.PpmdRAR_RangeDec_CreateVTable(&rar->range_dec);
        rar->range_dec.Stream = &rar->bytein;
        __archive_ppmd7_functions.Ppmd7_Construct(&rar->ppmd7_context);
       if (rar->dictionary_size == 0) {
 	      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                           ""Invalid zero dictionary size"");
 	      return (ARCHIVE_FATAL);
       }
        if (!__archive_ppmd7_functions.Ppmd7_Alloc(&rar->ppmd7_context,
          rar->dictionary_size, &g_szalloc))
        {
         archive_set_error(&a->archive, ENOMEM,
                           ""Out of memory"");
         return (ARCHIVE_FATAL);
       }
       if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec))
       {
         archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                           ""Unable to initialize PPMd range decoder"");
         return (ARCHIVE_FATAL);
       }
       __archive_ppmd7_functions.Ppmd7_Init(&rar->ppmd7_context, maxorder);
       rar->ppmd_valid = 1;
     }
     else
     {
       if (!rar->ppmd_valid) {
         archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                           ""Invalid PPMd sequence"");
         return (ARCHIVE_FATAL);
       }
       if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec))
       {
         archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                           ""Unable to initialize PPMd range decoder"");
         return (ARCHIVE_FATAL);
       }
     }
   }
   else
   {
     rar_br_consume(br, 1);
     if (!rar_br_read_ahead(a, br, 1))
       goto truncated_data;
     if (!rar_br_bits(br, 1))
       memset(rar->lengthtable, 0, sizeof(rar->lengthtable));
     rar_br_consume(br, 1);
     memset(&bitlengths, 0, sizeof(bitlengths));
     for (i = 0; i < MAX_SYMBOLS;)
     {
       if (!rar_br_read_ahead(a, br, 4))
         goto truncated_data;
       bitlengths[i++] = rar_br_bits(br, 4);
       rar_br_consume(br, 4);
       if (bitlengths[i-1] == 0xF)
       {
         if (!rar_br_read_ahead(a, br, 4))
           goto truncated_data;
         zerocount = rar_br_bits(br, 4);
         rar_br_consume(br, 4);
         if (zerocount)
         {
           i--;
           for (j = 0; j < zerocount + 2 && i < MAX_SYMBOLS; j++)
             bitlengths[i++] = 0;
         }
       }
     }
     memset(&precode, 0, sizeof(precode));
     r = create_code(a, &precode, bitlengths, MAX_SYMBOLS, MAX_SYMBOL_LENGTH);
     if (r != ARCHIVE_OK) {
       free(precode.tree);
       free(precode.table);
       return (r);
     }
     for (i = 0; i < HUFFMAN_TABLE_SIZE;)
     {
       if ((val = read_next_symbol(a, &precode)) < 0) {
         free(precode.tree);
         free(precode.table);
         return (ARCHIVE_FATAL);
       }
       if (val < 16)
       {
         rar->lengthtable[i] = (rar->lengthtable[i] + val) & 0xF;
         i++;
       }
       else if (val < 18)
       {
         if (i == 0)
         {
           free(precode.tree);
           free(precode.table);
           archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                             ""Internal error extracting RAR file."");
           return (ARCHIVE_FATAL);
         }
         if(val == 16) {
           if (!rar_br_read_ahead(a, br, 3)) {
             free(precode.tree);
             free(precode.table);
             goto truncated_data;
           }
           n = rar_br_bits(br, 3) + 3;
           rar_br_consume(br, 3);
         } else {
           if (!rar_br_read_ahead(a, br, 7)) {
             free(precode.tree);
             free(precode.table);
             goto truncated_data;
           }
           n = rar_br_bits(br, 7) + 11;
           rar_br_consume(br, 7);
         }
         for (j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++)
         {
           rar->lengthtable[i] = rar->lengthtable[i-1];
           i++;
         }
       }
       else
       {
         if(val == 18) {
           if (!rar_br_read_ahead(a, br, 3)) {
             free(precode.tree);
             free(precode.table);
             goto truncated_data;
           }
           n = rar_br_bits(br, 3) + 3;
           rar_br_consume(br, 3);
         } else {
           if (!rar_br_read_ahead(a, br, 7)) {
             free(precode.tree);
             free(precode.table);
             goto truncated_data;
           }
           n = rar_br_bits(br, 7) + 11;
           rar_br_consume(br, 7);
         }
         for(j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++)
           rar->lengthtable[i++] = 0;
       }
     }
     free(precode.tree);
     free(precode.table);
     r = create_code(a, &rar->maincode, &rar->lengthtable[0], MAINCODE_SIZE,
                 MAX_SYMBOL_LENGTH);
     if (r != ARCHIVE_OK)
       return (r);
     r = create_code(a, &rar->offsetcode, &rar->lengthtable[MAINCODE_SIZE],
                 OFFSETCODE_SIZE, MAX_SYMBOL_LENGTH);
     if (r != ARCHIVE_OK)
       return (r);
     r = create_code(a, &rar->lowoffsetcode,
                 &rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE],
                 LOWOFFSETCODE_SIZE, MAX_SYMBOL_LENGTH);
     if (r != ARCHIVE_OK)
       return (r);
     r = create_code(a, &rar->lengthcode,
                 &rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE +
                 LOWOFFSETCODE_SIZE], LENGTHCODE_SIZE, MAX_SYMBOL_LENGTH);
     if (r != ARCHIVE_OK)
       return (r);
   }
   if (!rar->dictionary_size || !rar->lzss.window)
   {
     void *new_window;
     unsigned int new_size;
     if (rar->unp_size >= DICTIONARY_MAX_SIZE)
       new_size = DICTIONARY_MAX_SIZE;
     else
       new_size = rar_fls((unsigned int)rar->unp_size) << 1;
     new_window = realloc(rar->lzss.window, new_size);
     if (new_window == NULL) {
       archive_set_error(&a->archive, ENOMEM,
                         ""Unable to allocate memory for uncompressed data."");
       return (ARCHIVE_FATAL);
     }
     rar->lzss.window = (unsigned char *)new_window;
     rar->dictionary_size = new_size;
     memset(rar->lzss.window, 0, rar->dictionary_size);
     rar->lzss.mask = rar->dictionary_size - 1;
   }
   rar->start_new_table = 0;
   return (ARCHIVE_OK);
 truncated_data:
   archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                     ""Truncated RAR file data"");
   rar->valid = 0;
   return (ARCHIVE_FATAL);
 }","[53, 54, 55, 56, 57]",Heap-based buffer overflow in the parse_codes function in archive_read_support_format_rar.c in libarchive before 3.2.1 allows remote attackers to execute arbitrary code via a RAR file with a zero-sized dictionary.,libarchive,CVE-2016-4302,CWE-119
2943,182980," seamless_process(STREAM s)
  {
  	unsigned int pkglen;
  	char *buf;
 	struct stream packet = *s;
 	if (!s_check(s))
 	{
 		rdp_protocol_error(""seamless_process(), stream is in unstable state"", &packet);
 	}
  	pkglen = s->end - s->p;
 	buf = xmalloc(pkglen + 1);
 	STRNCPY(buf, (char *) s->p, pkglen + 1);
 	str_handle_lines(buf, &seamless_rest, seamless_line_handler, NULL);
 	xfree(buf);
 }","[5, 6, 7, 8, 9]",rdesktop versions up to and including v1.8.3 contain a Buffer Overflow over the global variables in the function seamless_process_line() that results in memory corruption and probably even a remote code execution.,rdesktop,CVE-2018-20182,CWE-119
2944,182382," size_t jsvGetString(const JsVar *v, char *str, size_t len) {
   assert(len>0);
   const char *s = jsvGetConstString(v);
   if (s) {
      len--;
      int l = 0;
    while (*s && l<len) {
     while (s[l] && l<len) {
        str[l] = s[l];
        l++;
      }
     str[l] = 0;
     return l;
   } else if (jsvIsInt(v)) {
     itostr(v->varData.integer, str, 10);
     return strlen(str);
   } else if (jsvIsFloat(v)) {
     ftoa_bounded(v->varData.floating, str, len);
     return strlen(str);
   } else if (jsvHasCharacterData(v)) {
     assert(!jsvIsStringExt(v));
     size_t l = len;
     JsvStringIterator it;
     jsvStringIteratorNewConst(&it, v, 0);
     while (jsvStringIteratorHasChar(&it)) {
       if (l--<=1) {
         *str = 0;
         jsvStringIteratorFree(&it);
         return len;
       }
       *(str++) = jsvStringIteratorGetChar(&it);
       jsvStringIteratorNext(&it);
     }
     jsvStringIteratorFree(&it);
     *str = 0;
     return len-l;
   } else {
     JsVar *stringVar = jsvAsString((JsVar*)v, false);  
     if (stringVar) {
       size_t l = jsvGetString(stringVar, str, len);  
       jsvUnLock(stringVar);
       return l;
     } else {
       str[0] = 0;
       jsExceptionHere(JSET_INTERNALERROR, ""Variable type cannot be converted to string"");
       return 0;
     }
   }
 }","[7, 8]",Espruino before 1.99 allows attackers to cause a denial of service (application crash) with a user crafted input file via a Buffer Overflow during syntax parsing because a check for '0' is made for the wrong array element in jsvar.c.,Espruino,CVE-2018-11596,CWE-119
2960,181864," static inline ulong encode_twos_comp(long n, int prec)
 static inline jas_ulong encode_twos_comp(long n, int prec)
  {
	ulong result;
 	jas_ulong result;
  	assert(prec >= 2);
  	jas_eprintf(""warning: support for signed data is untested\n"");
 	if (n < 0) {
 		result = -n;
 		result = (result ^ 0xffffffffUL) + 1;
 		result &= (1 << prec) - 1;
 	} else {
 		result = n;
 	}
 	return result;
 }","[2, 4, 5]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
2971,180949," static int mv_read_header(AVFormatContext *avctx)
 {
     MvContext *mv = avctx->priv_data;
     AVIOContext *pb = avctx->pb;
     AVStream *ast = NULL, *vst = NULL;  
     int version, i;
     int ret;
     avio_skip(pb, 4);
     version = avio_rb16(pb);
     if (version == 2) {
         uint64_t timestamp;
         int v;
         avio_skip(pb, 22);
         ast = avformat_new_stream(avctx, NULL);
         if (!ast)
             return AVERROR(ENOMEM);
         vst = avformat_new_stream(avctx, NULL);
         if (!vst)
             return AVERROR(ENOMEM);
         avpriv_set_pts_info(vst, 64, 1, 15);
         vst->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;
         vst->avg_frame_rate    = av_inv_q(vst->time_base);
         vst->nb_frames         = avio_rb32(pb);
         v = avio_rb32(pb);
         switch (v) {
         case 1:
             vst->codecpar->codec_id = AV_CODEC_ID_MVC1;
             break;
         case 2:
             vst->codecpar->format = AV_PIX_FMT_ARGB;
             vst->codecpar->codec_id = AV_CODEC_ID_RAWVIDEO;
             break;
         default:
             avpriv_request_sample(avctx, ""Video compression %i"", v);
             break;
         }
         vst->codecpar->codec_tag = 0;
         vst->codecpar->width     = avio_rb32(pb);
         vst->codecpar->height    = avio_rb32(pb);
         avio_skip(pb, 12);
         ast->codecpar->codec_type  = AVMEDIA_TYPE_AUDIO;
         ast->nb_frames          = vst->nb_frames;
         ast->codecpar->sample_rate = avio_rb32(pb);
         if (ast->codecpar->sample_rate <= 0) {
             av_log(avctx, AV_LOG_ERROR, ""Invalid sample rate %d\n"", ast->codecpar->sample_rate);
             return AVERROR_INVALIDDATA;
         }
         avpriv_set_pts_info(ast, 33, 1, ast->codecpar->sample_rate);
         if (set_channels(avctx, ast, avio_rb32(pb)) < 0)
             return AVERROR_INVALIDDATA;
         v = avio_rb32(pb);
         if (v == AUDIO_FORMAT_SIGNED) {
             ast->codecpar->codec_id = AV_CODEC_ID_PCM_S16BE;
         } else {
             avpriv_request_sample(avctx, ""Audio compression (format %i)"", v);
         }
         avio_skip(pb, 12);
         var_read_metadata(avctx, ""title"", 0x80);
         var_read_metadata(avctx, ""comment"", 0x100);
         avio_skip(pb, 0x80);
         timestamp = 0;
         for (i = 0; i < vst->nb_frames; i++) {
              uint32_t pos   = avio_rb32(pb);
              uint32_t asize = avio_rb32(pb);
              uint32_t vsize = avio_rb32(pb);
             if (avio_feof(pb))
                 return AVERROR_INVALIDDATA;
              avio_skip(pb, 8);
              av_add_index_entry(ast, pos, timestamp, asize, 0, AVINDEX_KEYFRAME);
              av_add_index_entry(vst, pos + asize, i, vsize, 0, AVINDEX_KEYFRAME);
             timestamp += asize / (ast->codecpar->channels * 2);
         }
     } else if (!version && avio_rb16(pb) == 3) {
         avio_skip(pb, 4);
         if ((ret = read_table(avctx, NULL, parse_global_var)) < 0)
             return ret;
         if (mv->nb_audio_tracks > 1) {
             avpriv_request_sample(avctx, ""Multiple audio streams support"");
             return AVERROR_PATCHWELCOME;
         } else if (mv->nb_audio_tracks) {
             ast = avformat_new_stream(avctx, NULL);
             if (!ast)
                 return AVERROR(ENOMEM);
             ast->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;
             if ((read_table(avctx, ast, parse_audio_var)) < 0)
                 return ret;
             if (mv->acompression == 100 &&
                 mv->aformat == AUDIO_FORMAT_SIGNED &&
                 ast->codecpar->bits_per_coded_sample == 16) {
                 ast->codecpar->codec_id = AV_CODEC_ID_PCM_S16BE;
             } else {
                 avpriv_request_sample(avctx,
                                       ""Audio compression %i (format %i, sr %i)"",
                                       mv->acompression, mv->aformat,
                                       ast->codecpar->bits_per_coded_sample);
                 ast->codecpar->codec_id = AV_CODEC_ID_NONE;
             }
             if (ast->codecpar->channels <= 0) {
                 av_log(avctx, AV_LOG_ERROR, ""No valid channel count found.\n"");
                 return AVERROR_INVALIDDATA;
             }
         }
         if (mv->nb_video_tracks > 1) {
             avpriv_request_sample(avctx, ""Multiple video streams support"");
             return AVERROR_PATCHWELCOME;
         } else if (mv->nb_video_tracks) {
             vst = avformat_new_stream(avctx, NULL);
             if (!vst)
                 return AVERROR(ENOMEM);
             vst->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;
             if ((ret = read_table(avctx, vst, parse_video_var))<0)
                 return ret;
         }
         if (mv->nb_audio_tracks)
             read_index(pb, ast);
         if (mv->nb_video_tracks)
             read_index(pb, vst);
     } else {
         avpriv_request_sample(avctx, ""Version %i"", version);
         return AVERROR_PATCHWELCOME;
     }
     return 0;
 }","[66, 67]","In libavformat/mvdec.c in FFmpeg 3.3.3, a DoS in mv_read_header() due to lack of an EOF (End of File) check might cause huge CPU and memory consumption. When a crafted MV file, which claims a large *nb_frames* field in the header but does not contain sufficient backing data, is provided, the loop over the frames would consume huge CPU and memory resources, since there is no EOF check inside the loop.",FFmpeg,CVE-2017-14055,CWE-834
2976,183216," static int open_url(AVFormatContext *s, AVIOContext **pb, const char *url,
                     AVDictionary *opts, AVDictionary *opts2, int *is_http)
 {
     HLSContext *c = s->priv_data;
     AVDictionary *tmp = NULL;
     const char *proto_name = NULL;
     int ret;
     av_dict_copy(&tmp, opts, 0);
     av_dict_copy(&tmp, opts2, 0);
     if (av_strstart(url, ""crypto"", NULL)) {
         if (url[6] == '+' || url[6] == ':')
             proto_name = avio_find_protocol_name(url + 7);
     }
     if (!proto_name)
         proto_name = avio_find_protocol_name(url);
     if (!proto_name)
          return AVERROR_INVALIDDATA;
    if (!av_strstart(proto_name, ""http"", NULL) && !av_strstart(proto_name, ""file"", NULL))
     if (av_strstart(proto_name, ""file"", NULL)) {
         if (strcmp(c->allowed_extensions, ""ALL"") && !av_match_ext(url, c->allowed_extensions)) {
             av_log(s, AV_LOG_ERROR,
                 ""Filename extension of \'%s\' is not a common multimedia extension, blocked for security reasons.\n""
                 ""If you wish to override this adjust allowed_extensions, you can set it to \'ALL\' to allow all\n"",
                 url);
             return AVERROR_INVALIDDATA;
         }
     } else if (av_strstart(proto_name, ""http"", NULL)) {
         ;
     } else
          return AVERROR_INVALIDDATA;
      if (!strncmp(proto_name, url, strlen(proto_name)) && url[strlen(proto_name)] == ':')
          ;
      else if (av_strstart(url, ""crypto"", NULL) && !strncmp(proto_name, url + 7, strlen(proto_name)) && url[7 + strlen(proto_name)] == ':')
         ;
     else if (strcmp(proto_name, ""file"") || !strncmp(url, ""file,"", 5))
         return AVERROR_INVALIDDATA;
     ret = s->io_open(s, pb, url, AVIO_FLAG_READ, &tmp);
     if (ret >= 0) {
         char *new_cookies = NULL;
         if (!(s->flags & AVFMT_FLAG_CUSTOM_IO))
             av_opt_get(*pb, ""cookies"", AV_OPT_SEARCH_CHILDREN, (uint8_t**)&new_cookies);
         if (new_cookies) {
             av_free(c->cookies);
             c->cookies = new_cookies;
         }
         av_dict_set(&opts, ""cookies"", c->cookies, 0);
     }
     av_dict_free(&tmp);
     if (is_http)
         *is_http = av_strstart(proto_name, ""http"", NULL);
     return ret;
 }","[18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]","FFmpeg before 2.8.12, 3.0.x and 3.1.x before 3.1.9, 3.2.x before 3.2.6, and 3.3.x before 3.3.2 does not properly restrict HTTP Live Streaming filename extensions and demuxer names, which allows attackers to read arbitrary files via crafted playlist data.",FFmpeg,CVE-2017-9993,CWE-200
3027,182151," PHYSICALPATH_FUNC(mod_alias_physical_handler) {
 	plugin_data *p = p_d;
 	int uri_len, basedir_len;
 	char *uri_ptr;
 	size_t k;
 	if (buffer_is_empty(con->physical.path)) return HANDLER_GO_ON;
 	mod_alias_patch_connection(srv, con, p);
 	basedir_len = buffer_string_length(con->physical.basedir);
 	if ('/' == con->physical.basedir->ptr[basedir_len-1]) --basedir_len;
 	uri_len = buffer_string_length(con->physical.path) - basedir_len;
 	uri_ptr = con->physical.path->ptr + basedir_len;
 	for (k = 0; k < p->conf.alias->used; k++) {
 		data_string *ds = (data_string *)p->conf.alias->data[k];
 		int alias_len = buffer_string_length(ds->key);
 		if (alias_len > uri_len) continue;
 		if (buffer_is_empty(ds->key)) continue;
 		if (0 == (con->conf.force_lowercase_filenames ?
 					strncasecmp(uri_ptr, ds->key->ptr, alias_len) :
  					strncmp(uri_ptr, ds->key->ptr, alias_len))) {
 			if (uri_ptr[alias_len] == '.') {
 				char *s = uri_ptr + alias_len + 1;
 				if (*s == '.') ++s;
 				if (*s == '/' || *s == '\0') {
 					size_t vlen = buffer_string_length(ds->value);
 					if (0 != alias_len && ds->key->ptr[alias_len-1] != '/'
 					    && 0 != vlen && ds->value->ptr[vlen-1] == '/') {
 						con->http_status = 403;
 						return HANDLER_FINISHED;
 					}
 				}
 			}
  			buffer_copy_buffer(con->physical.basedir, ds->value);
  			buffer_copy_buffer(srv->tmp_buf, ds->value);
  			buffer_append_string(srv->tmp_buf, uri_ptr + alias_len);
 			buffer_copy_buffer(con->physical.path, srv->tmp_buf);
 			return HANDLER_GO_ON;
 		}
 	}
 	return HANDLER_GO_ON;
 }","[20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]","An issue was discovered in mod_alias_physical_handler in mod_alias.c in lighttpd before 1.4.50. There is potential ../ path traversal of a single directory above an alias target, with a specific mod_alias configuration where the matched alias lacks a trailing '/' character, but the alias target filesystem path does have a trailing '/' character.",lighttpd1.4,CVE-2018-19052,
3037,182221," authentic_set_current_files(struct sc_card *card, struct sc_path *path,
 		unsigned char *resp, size_t resplen, struct sc_file **file_out)
 {
 	struct sc_context *ctx = card->ctx;
 	struct sc_file *file = NULL;
 	int rv;
 	LOG_FUNC_CALLED(ctx);
 	if (resplen)   {
 		switch (resp[0]) {
 		case 0x62:
 		case 0x6F:
 			file = sc_file_new();
 			if (file == NULL)
 				LOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);
 			if (path)
 				file->path = *path;
 			rv = authentic_process_fci(card, file, resp, resplen);
 			LOG_TEST_RET(ctx, rv, ""cannot set 'current file': FCI process error"");
 			break;
 		default:
 			LOG_FUNC_RETURN(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED);
 		}
 		if (file->type == SC_FILE_TYPE_DF)   {
 			struct sc_path cur_df_path;
 			memset(&cur_df_path, 0, sizeof(cur_df_path));
 			if (card->cache.valid && card->cache.current_df)   {
 				cur_df_path = card->cache.current_df->path;
 				sc_file_free(card->cache.current_df);
 			}
 			card->cache.current_df = NULL;
  			sc_file_dup(&card->cache.current_df, file);
  			if (cur_df_path.len)   {
 				if (cur_df_path.len + card->cache.current_df->path.len > sizeof card->cache.current_df->path.value
 						|| cur_df_path.len > sizeof card->cache.current_df->path.value)
 					LOG_FUNC_RETURN(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED);
  				memcpy(card->cache.current_df->path.value + cur_df_path.len,
  						card->cache.current_df->path.value,
  						card->cache.current_df->path.len);
 				memcpy(card->cache.current_df->path.value, cur_df_path.value, cur_df_path.len);
 				card->cache.current_df->path.len += cur_df_path.len;
 			}
 			sc_file_free(card->cache.current_ef);
 			card->cache.current_ef = NULL;
 			card->cache.valid = 1;
 		}
 		else   {
 			sc_file_free(card->cache.current_ef);
 			card->cache.current_ef = NULL;
 			sc_file_dup(&card->cache.current_ef, file);
 		}
 		if (file_out)
 			*file_out = file;
 		else
 			sc_file_free(file);
 	}
 	LOG_FUNC_RETURN(ctx, SC_SUCCESS);
 }","[33, 34, 35]",Various out of bounds reads when handling responses in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to potentially crash the opensc library using programs.,OpenSC,CVE-2018-16427,CWE-125
3054,182061," ProcessTCPHeader(tTcpIpPacketParsingResult _res, PVOID pIpHeader, ULONG len, USHORT ipHeaderSize)
 {
      ULONG tcpipDataAt;
      tTcpIpPacketParsingResult res = _res;
      tcpipDataAt = ipHeaderSize + sizeof(TCPHeader);
    res.xxpStatus = ppresXxpIncomplete;
      res.TcpUdp = ppresIsTCP;
      if (len >= tcpipDataAt)
      {
          TCPHeader *pTcpHeader = (TCPHeader *)RtlOffsetToPointer(pIpHeader, ipHeaderSize);
          res.xxpStatus = ppresXxpKnown;
         res.xxpFull = TRUE;
          tcpipDataAt = ipHeaderSize + TCP_HEADER_LENGTH(pTcpHeader);
          res.XxpIpHeaderSize = tcpipDataAt;
      }
      else
      {
          DPrintf(2, (""tcp: %d < min headers %d\n"", len, tcpipDataAt));
         res.xxpFull = FALSE;
         res.xxpStatus = ppresXxpIncomplete;
      }
      return res;
  }","[6, 12, 19, 20]","The NetKVM Windows Virtio driver allows remote attackers to cause a denial of service (guest crash) via a crafted length value in an IP packet, as demonstrated by a value that does not account for the size of the IP options.",kvm-guest-drivers-windows,CVE-2015-3215,CWE-20
3057,181216," int module_load(
     YR_SCAN_CONTEXT* context,
     YR_OBJECT* module_object,
     void* module_data,
     size_t module_data_size)
 {
   set_integer(1, module_object, ""constants.one"");
   set_integer(2, module_object, ""constants.two"");
   set_string(""foo"", module_object, ""constants.foo"");
   set_string("""", module_object, ""constants.empty"");
   set_integer(1, module_object, ""struct_array[1].i"");
    set_integer(0, module_object, ""integer_array[%i]"", 0);
    set_integer(1, module_object, ""integer_array[%i]"", 1);
    set_integer(2, module_object, ""integer_array[%i]"", 2);
   set_integer(256, module_object, ""integer_array[%i]"", 256);
    set_string(""foo"", module_object, ""string_array[%i]"", 0);
    set_string(""bar"", module_object, ""string_array[%i]"", 1);
   set_string(""baz"", module_object, ""string_array[%i]"", 2);
   set_sized_string(""foo\0bar"", 7, module_object, ""string_array[%i]"", 3);
   set_string(""foo"", module_object, ""string_dict[%s]"", ""foo"");
   set_string(""bar"", module_object, ""string_dict[\""bar\""]"");
   set_string(""foo"", module_object, ""struct_dict[%s].s"", ""foo"");
   set_integer(1, module_object, ""struct_dict[%s].i"", ""foo"");
   return ERROR_SUCCESS;
 }",[15],Heap buffer overflow in the yr_object_array_set_item() function in object.c in YARA 3.x allows a denial-of-service attack by scanning a crafted .NET file.,yara,CVE-2017-11328,CWE-119
3062,183235," psf_asciiheader_printf (SF_PRIVATE *psf, const char *format, ...)
 {	va_list	argptr ;
  	int		maxlen ;
  	char	*start ;
	maxlen = strlen ((char*) psf->header) ;
	start	= ((char*) psf->header) + maxlen ;
	maxlen	= sizeof (psf->header) - maxlen ;
 	maxlen = strlen ((char*) psf->header.ptr) ;
 	start	= ((char*) psf->header.ptr) + maxlen ;
 	maxlen	= psf->header.len - maxlen ;
  	va_start (argptr, format) ;
  	vsnprintf (start, maxlen, format, argptr) ;
 	va_end (argptr) ;
  	start [maxlen - 1] = 0 ;
	psf->headindex = strlen ((char*) psf->header) ;
 	psf->header.indx = strlen ((char*) psf->header.ptr) ;
  	return ;
  }  ","[5, 6, 7, 8, 9, 10, 15, 16]","In libsndfile before 1.0.28, an error in the *header_read()* function (common.c) when handling ID3 tags can be exploited to cause a stack-based buffer overflow via a specially crafted FLAC file.",libsndfile,CVE-2017-7586,CWE-119
3079,182242," iasecc_select_file(struct sc_card *card, const struct sc_path *path,
 		 struct sc_file **file_out)
 {
 	struct sc_context *ctx = card->ctx;
 	struct sc_path lpath;
 	int cache_valid = card->cache.valid, df_from_cache = 0;
 	int rv, ii;
 	LOG_FUNC_CALLED(ctx);
 	memcpy(&lpath, path, sizeof(struct sc_path));
 	if (file_out)
 		*file_out = NULL;
 	sc_log(ctx,
 	       ""iasecc_select_file(card:%p) path.len %""SC_FORMAT_LEN_SIZE_T""u; path.type %i; aid_len %""SC_FORMAT_LEN_SIZE_T""u"",
 	       card, path->len, path->type, path->aid.len);
  	sc_log(ctx, ""iasecc_select_file() path:%s"", sc_print_path(path));
  	sc_print_cache(card);
	if (lpath.len >= 2 && lpath.value[0] == 0x3F && lpath.value[1] == 0x00)   {
 	if (path->type != SC_PATH_TYPE_DF_NAME
 			&& lpath.len >= 2
 			&& lpath.value[0] == 0x3F && lpath.value[1] == 0x00)   {
  		sc_log(ctx, ""EF.ATR(aid:'%s')"", card->ef_atr ? sc_dump_hex(card->ef_atr->aid.value, card->ef_atr->aid.len) : """");
  		rv = iasecc_select_mf(card, file_out);
  		LOG_TEST_RET(ctx, rv, ""MF selection error"");
		if (lpath.len >= 2 && lpath.value[0] == 0x3F && lpath.value[1] == 0x00)	   {
			memmove(&lpath.value[0], &lpath.value[2], lpath.len - 2);
			lpath.len -=  2;
		}
 		memmove(&lpath.value[0], &lpath.value[2], lpath.len - 2);
 		lpath.len -=  2;
  	}
  	if (lpath.aid.len)	{
 		struct sc_file *file = NULL;
 		struct sc_path ppath;
 		sc_log(ctx,
 		       ""iasecc_select_file() select parent AID:%p/%""SC_FORMAT_LEN_SIZE_T""u"",
 		       lpath.aid.value, lpath.aid.len);
 		sc_log(ctx, ""iasecc_select_file() select parent AID:%s"", sc_dump_hex(lpath.aid.value, lpath.aid.len));
 		memset(&ppath, 0, sizeof(ppath));
 		memcpy(ppath.value, lpath.aid.value, lpath.aid.len);
 		ppath.len = lpath.aid.len;
 		ppath.type = SC_PATH_TYPE_DF_NAME;
 		if (card->cache.valid && card->cache.current_df
 				&& card->cache.current_df->path.len == lpath.aid.len
 				&& !memcmp(card->cache.current_df->path.value, lpath.aid.value, lpath.aid.len))
 			df_from_cache = 1;
 		rv = iasecc_select_file(card, &ppath, &file);
 		LOG_TEST_RET(ctx, rv, ""select AID path failed"");
 		if (file_out)
 			*file_out = file;
 		else
 		   sc_file_free(file);
 		if (lpath.type == SC_PATH_TYPE_DF_NAME)
 			lpath.type = SC_PATH_TYPE_FROM_CURRENT;
 	}
 	if (lpath.type == SC_PATH_TYPE_PATH)
 		lpath.type = SC_PATH_TYPE_FROM_CURRENT;
 	if (!lpath.len)
 		LOG_FUNC_RETURN(ctx, SC_SUCCESS);
 	sc_print_cache(card);
 	if (card->cache.valid && card->cache.current_df && lpath.type == SC_PATH_TYPE_DF_NAME
 			&& card->cache.current_df->path.len == lpath.len
 			&& !memcmp(card->cache.current_df->path.value, lpath.value, lpath.len))   {
 		sc_log(ctx, ""returns current DF path %s"", sc_print_path(&card->cache.current_df->path));
 		if (file_out)   {
 			sc_file_free(*file_out);
 			sc_file_dup(file_out, card->cache.current_df);
 		}
 		sc_print_cache(card);
 		LOG_FUNC_RETURN(ctx, SC_SUCCESS);
 	}
 	do   {
 		struct sc_apdu apdu;
 		struct sc_file *file = NULL;
 		unsigned char rbuf[SC_MAX_APDU_BUFFER_SIZE];
 		int pathlen = lpath.len;
 		sc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0x00, 0x00);
 		if (card->type != SC_CARD_TYPE_IASECC_GEMALTO
 				&& card->type != SC_CARD_TYPE_IASECC_OBERTHUR
 				&& card->type != SC_CARD_TYPE_IASECC_SAGEM
 				&& card->type != SC_CARD_TYPE_IASECC_AMOS
 				&& card->type != SC_CARD_TYPE_IASECC_MI
 				&& card->type != SC_CARD_TYPE_IASECC_MI2)
 			LOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, ""Unsupported card"");
 		if (lpath.type == SC_PATH_TYPE_FILE_ID)   {
 			apdu.p1 = 0x02;
 			if (card->type == SC_CARD_TYPE_IASECC_OBERTHUR)   {
 				apdu.p1 = 0x01;
 				apdu.p2 = 0x04;
 			}
 			if (card->type == SC_CARD_TYPE_IASECC_AMOS)
 				apdu.p2 = 0x04;
 			if (card->type == SC_CARD_TYPE_IASECC_MI)
 				apdu.p2 = 0x04;
 			if (card->type == SC_CARD_TYPE_IASECC_MI2)
 				apdu.p2 = 0x04;
 		}
 		else if (lpath.type == SC_PATH_TYPE_FROM_CURRENT)  {
 			apdu.p1 = 0x09;
 			if (card->type == SC_CARD_TYPE_IASECC_OBERTHUR)
 				apdu.p2 = 0x04;
 			if (card->type == SC_CARD_TYPE_IASECC_AMOS)
 				apdu.p2 = 0x04;
 			if (card->type == SC_CARD_TYPE_IASECC_MI)
 				apdu.p2 = 0x04;
 			if (card->type == SC_CARD_TYPE_IASECC_MI2)
 				apdu.p2 = 0x04;
 		}
 		else if (lpath.type == SC_PATH_TYPE_PARENT)   {
 			apdu.p1 = 0x03;
 			pathlen = 0;
 			apdu.cse = SC_APDU_CASE_2_SHORT;
 		}
 		else if (lpath.type == SC_PATH_TYPE_DF_NAME)   {
 			apdu.p1 = 0x04;
 			if (card->type == SC_CARD_TYPE_IASECC_AMOS)
 				apdu.p2 = 0x04;
 			if (card->type == SC_CARD_TYPE_IASECC_MI2)
 				apdu.p2 = 0x04;
 		}
 		else   {
 			sc_log(ctx, ""Invalid PATH type: 0x%X"", lpath.type);
 			LOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, ""iasecc_select_file() invalid PATH type"");
 		}
 		for (ii=0; ii<2; ii++)   {
 			apdu.lc = pathlen;
 			apdu.data = lpath.value;
 			apdu.datalen = pathlen;
 			apdu.resp = rbuf;
 			apdu.resplen = sizeof(rbuf);
 			apdu.le = 256;
 			rv = sc_transmit_apdu(card, &apdu);
 			LOG_TEST_RET(ctx, rv, ""APDU transmit failed"");
 			rv = sc_check_sw(card, apdu.sw1, apdu.sw2);
 			if (rv == SC_ERROR_INCORRECT_PARAMETERS &&
 					lpath.type == SC_PATH_TYPE_DF_NAME && apdu.p2 == 0x00)   {
 				apdu.p2 = 0x0C;
 				continue;
 			}
 			if (ii)   {
 				apdu.resplen = sizeof(rbuf);
 				rv = iasecc_emulate_fcp(ctx, &apdu);
 				LOG_TEST_RET(ctx, rv, ""Failed to emulate DF FCP"");
 			}
 			break;
 		}
 		if (rv == SC_ERROR_FILE_NOT_FOUND && cache_valid && df_from_cache)   {
 			sc_invalidate_cache(card);
 			sc_log(ctx, ""iasecc_select_file() file not found, retry without cached DF"");
 			if (file_out)   {
 				sc_file_free(*file_out);
 				*file_out = NULL;
 			}
 			rv = iasecc_select_file(card, path, file_out);
 			LOG_FUNC_RETURN(ctx, rv);
 		}
 		LOG_TEST_RET(ctx, rv, ""iasecc_select_file() check SW failed"");
 		sc_log(ctx,
 		       ""iasecc_select_file() apdu.resp %""SC_FORMAT_LEN_SIZE_T""u"",
 		       apdu.resplen);
 		if (apdu.resplen)   {
 			sc_log(ctx, ""apdu.resp %02X:%02X:%02X..."", apdu.resp[0], apdu.resp[1], apdu.resp[2]);
 			switch (apdu.resp[0]) {
 			case 0x62:
 			case 0x6F:
 				file = sc_file_new();
 				if (file == NULL)
 					LOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);
 				file->path = lpath;
 				rv = iasecc_process_fci(card, file, apdu.resp, apdu.resplen);
 				if (rv)
 					LOG_FUNC_RETURN(ctx, rv);
 				break;
 			default:
 				LOG_FUNC_RETURN(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED);
 			}
 			sc_log(ctx, ""FileType %i"", file->type);
 			if (file->type == SC_FILE_TYPE_DF)   {
 				if (card->cache.valid)
 					sc_file_free(card->cache.current_df);
 				card->cache.current_df = NULL;
 				if (card->cache.valid)
 					sc_file_free(card->cache.current_ef);
 				card->cache.current_ef = NULL;
 				sc_file_dup(&card->cache.current_df, file);
 				card->cache.valid = 1;
 			}
 			else   {
 				if (card->cache.valid)
 					sc_file_free(card->cache.current_ef);
 				card->cache.current_ef = NULL;
 				sc_file_dup(&card->cache.current_ef, file);
 			}
 			if (file_out)   {
 				sc_file_free(*file_out);
 				*file_out = file;
 			}
 			else   {
 				sc_file_free(file);
 			}
 		}
 		else if (lpath.type == SC_PATH_TYPE_DF_NAME)   {
 			sc_file_free(card->cache.current_df);
 			card->cache.current_df = NULL;
 			sc_file_free(card->cache.current_ef);
 			card->cache.current_ef = NULL;
 			card->cache.valid = 1;
 		}
 	} while(0);
 	sc_print_cache(card);
 	LOG_FUNC_RETURN(ctx, SC_SUCCESS);
 }","[17, 18, 19, 20, 24, 25, 26, 27, 28, 29]",Endless recursion when handling responses from an IAS-ECC card in iasecc_select_file in libopensc/card-iasecc.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to hang or crash the opensc library using programs.,OpenSC,CVE-2018-16426,CWE-674
3087,179178," static AVFrame *get_video_buffer(AVFilterLink *inlink, int w, int h)
 {
     PadContext *s = inlink->dst->priv;
     AVFrame *frame = ff_get_video_buffer(inlink->dst->outputs[0],
                                          w + (s->w - s->in_w),
                                          h + (s->h - s->in_h));
     int plane;
     if (!frame)
         return NULL;
      frame->width  = w;
      frame->height = h;
    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {
     for (plane = 0; plane < 4 && frame->data[plane] && frame->linesize[plane]; plane++) {
          int hsub = s->draw.hsub[plane];
          int vsub = s->draw.vsub[plane];
          frame->data[plane] += (s->x >> hsub) * s->draw.pixelstep[plane] +
                               (s->y >> vsub) * frame->linesize[plane];
     }
     return frame;
 }","[12, 13]","libavfilter in FFmpeg before 2.0.1 has unspecified impact and remote vectors related to a crafted *plane,* which triggers an out-of-bounds heap write.",FFmpeg,CVE-2013-4263,CWE-119
3089,182618," void jpc_qmfb_split_colgrp(jpc_fix_t *a, int numrows, int stride,
   int parity)
 {
 	int bufsize = JPC_CEILDIVPOW2(numrows, 1);
 	jpc_fix_t splitbuf[QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE];
 	jpc_fix_t *buf = splitbuf;
 	jpc_fix_t *srcptr;
 	jpc_fix_t *dstptr;
 	register jpc_fix_t *srcptr2;
 	register jpc_fix_t *dstptr2;
  	register int n;
  	register int i;
  	int m;
	int hstartcol;
 	int hstartrow;
  	if (bufsize > QMFB_SPLITBUFSIZE) {
		if (!(buf = jas_alloc2(bufsize, sizeof(jpc_fix_t)))) {
 		if (!(buf = jas_alloc3(bufsize, JPC_QMFB_COLGRPSIZE,
 		  sizeof(jpc_fix_t)))) {
  			abort();
  		}
  	}
  	if (numrows >= 2) {
		hstartcol = (numrows + 1 - parity) >> 1;
		m = numrows - hstartcol;
 		hstartrow = (numrows + 1 - parity) >> 1;
 		m = numrows - hstartrow;
  		n = m;
 		dstptr = buf;
 		srcptr = &a[(1 - parity) * stride];
 		while (n-- > 0) {
 			dstptr2 = dstptr;
 			srcptr2 = srcptr;
 			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
 				*dstptr2 = *srcptr2;
 				++dstptr2;
 				++srcptr2;
 			}
 			dstptr += JPC_QMFB_COLGRPSIZE;
 			srcptr += stride << 1;
 		}
 		dstptr = &a[(1 - parity) * stride];
 		srcptr = &a[(2 - parity) * stride];
 		n = numrows - m - (!parity);
 		while (n-- > 0) {
 			dstptr2 = dstptr;
 			srcptr2 = srcptr;
 			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
 				*dstptr2 = *srcptr2;
 				++dstptr2;
 				++srcptr2;
 			}
 			dstptr += stride;
  			srcptr += stride << 1;
  		}
		dstptr = &a[hstartcol * stride];
 		dstptr = &a[hstartrow * stride];
  		srcptr = buf;
  		n = m;
  		while (n-- > 0) {
 			dstptr2 = dstptr;
 			srcptr2 = srcptr;
 			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
 				*dstptr2 = *srcptr2;
 				++dstptr2;
 				++srcptr2;
 			}
 			dstptr += stride;
 			srcptr += JPC_QMFB_COLGRPSIZE;
 		}
 	}
 	if (buf != splitbuf) {
 		jas_free(buf);
 	}
 }","[14, 15, 17, 18, 19, 24, 25, 26, 27, 56, 57]",A heap-buffer overflow vulnerability was found in QMFB code in JPC codec caused by buffer being allocated with too small size. jasper versions before 2.0.0 are affected.,jasper,CVE-2016-8654,CWE-119
3101,181883,"  int jas_seq2d_output(jas_matrix_t *matrix, FILE *out)
  {
  #define MAXLINELEN	80
	int i;
	int j;
 	jas_matind_t i;
 	jas_matind_t j;
  	jas_seqent_t x;
  	char buf[MAXLINELEN + 1];
  	char sbuf[MAXLINELEN + 1];
 	int n;
 	fprintf(out, ""%""PRIiFAST32"" %""PRIiFAST32""\n"", jas_seq2d_xstart(matrix),
 	  jas_seq2d_ystart(matrix));
 	fprintf(out, ""%""PRIiFAST32"" %""PRIiFAST32""\n"", jas_matrix_numcols(matrix),
 	  jas_matrix_numrows(matrix));
 	buf[0] = '\0';
 	for (i = 0; i < jas_matrix_numrows(matrix); ++i) {
 		for (j = 0; j < jas_matrix_numcols(matrix); ++j) {
 			x = jas_matrix_get(matrix, i, j);
 			sprintf(sbuf, ""%s%4ld"", (strlen(buf) > 0) ? "" "" : """",
 			  JAS_CAST(long, x));
 			n = JAS_CAST(int, strlen(buf));
 			if (n + JAS_CAST(int, strlen(sbuf)) > MAXLINELEN) {
 				fputs(buf, out);
 				fputs(""\n"", out);
 				buf[0] = '\0';
 			}
 			strcat(buf, sbuf);
 			if (j == jas_matrix_numcols(matrix) - 1) {
 				fputs(buf, out);
 				fputs(""\n"", out);
 				buf[0] = '\0';
 			}
 		}
 	}
 	fputs(buf, out);
 	return 0;
 }","[4, 5, 6, 7]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
3106,180838," xmlPushInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr input) {
     int ret;
     if (input == NULL) return(-1);
     if (xmlParserDebugEntities) {
 	if ((ctxt->input != NULL) && (ctxt->input->filename))
 	    xmlGenericError(xmlGenericErrorContext,
 		    ""%s(%d): "", ctxt->input->filename,
 		    ctxt->input->line);
  	xmlGenericError(xmlGenericErrorContext,
  		""Pushing input %d : %.30s\n"", ctxt->inputNr+1, input->cur);
      }
     if (((ctxt->inputNr > 40) && ((ctxt->options & XML_PARSE_HUGE) == 0)) ||
         (ctxt->inputNr > 1024)) {
         xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
         while (ctxt->inputNr > 1)
             xmlFreeInputStream(inputPop(ctxt));
 	return(-1);
     }
      ret = inputPush(ctxt, input);
      if (ctxt->instate == XML_PARSER_EOF)
          return(-1);
     GROW;
     return(ret);
 }","[12, 13, 14, 15, 16, 17, 18]",parser.c in libxml2 before 2.9.5 does not prevent infinite recursion in parameter entities.,libxml2,CVE-2017-16932,CWE-835
3114,180804," on_handler_vanished(GDBusConnection *connection,
 		    const gchar     *name,
 		    gpointer         user_data)
 {
 	struct tcmur_handler *handler = user_data;
 	struct dbus_info *info = handler->opaque;
 	if (info->register_invocation) {
 		char *reason;
 		reason = g_strdup_printf(""Cannot find handler bus name: ""
 				""org.kernel.TCMUService1.HandlerManager1.%s"",
 				handler->subtype);
 		g_dbus_method_invocation_return_value(info->register_invocation,
  			    g_variant_new(""(bs)"", FALSE, reason));
  		g_free(reason);
  	}
	tcmur_unregister_handler(handler);
 	tcmur_unregister_dbus_handler(handler);
  	dbus_unexport_handler(handler);
  }","[16, 17]",tcmu-runner version 1.0.5 to 1.2.0 is vulnerable to a dbus triggered NULL pointer dereference in the tcmu-runner daemon's on_unregister_handler() function resulting in denial of service,tcmu-runner,CVE-2017-1000200,CWE-476
3128,181270," int yr_re_fast_exec(
     uint8_t* code,
     uint8_t* input_data,
     size_t input_forwards_size,
     size_t input_backwards_size,
     int flags,
     RE_MATCH_CALLBACK_FUNC callback,
     void* callback_args,
     int* matches)
 {
   RE_REPEAT_ANY_ARGS* repeat_any_args;
   uint8_t* code_stack[MAX_FAST_RE_STACK];
   uint8_t* input_stack[MAX_FAST_RE_STACK];
   int matches_stack[MAX_FAST_RE_STACK];
   uint8_t* ip = code;
   uint8_t* input = input_data;
   uint8_t* next_input;
   uint8_t* next_opcode;
   uint8_t mask;
   uint8_t value;
   int i;
   int stop;
   int input_incr;
   int sp = 0;
   int bytes_matched;
   int max_bytes_matched;
   max_bytes_matched = flags & RE_FLAGS_BACKWARDS ?
       (int) input_backwards_size :
       (int) input_forwards_size;
   input_incr = flags & RE_FLAGS_BACKWARDS ? -1 : 1;
   if (flags & RE_FLAGS_BACKWARDS)
     input--;
   code_stack[sp] = code;
   input_stack[sp] = input;
   matches_stack[sp] = 0;
   sp++;
   while (sp > 0)
   {
     sp--;
     ip = code_stack[sp];
     input = input_stack[sp];
     bytes_matched = matches_stack[sp];
     stop = FALSE;
     while(!stop)
     {
       if (*ip == RE_OPCODE_MATCH)
       {
         if (flags & RE_FLAGS_EXHAUSTIVE)
         {
           FAIL_ON_ERROR(callback(
              flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data,
              bytes_matched,
              flags,
              callback_args));
           break;
         }
         else
         {
           if (matches != NULL)
             *matches = bytes_matched;
           return ERROR_SUCCESS;
         }
       }
       if (bytes_matched >= max_bytes_matched)
         break;
       switch(*ip)
       {
         case RE_OPCODE_LITERAL:
           if (*input == *(ip + 1))
           {
             bytes_matched++;
             input += input_incr;
             ip += 2;
           }
           else
           {
             stop = TRUE;
           }
           break;
         case RE_OPCODE_MASKED_LITERAL:
           value = *(int16_t*)(ip + 1) & 0xFF;
           mask = *(int16_t*)(ip + 1) >> 8;
           if ((*input & mask) == value)
           {
             bytes_matched++;
             input += input_incr;
             ip += 3;
           }
           else
           {
             stop = TRUE;
           }
           break;
         case RE_OPCODE_ANY:
           bytes_matched++;
           input += input_incr;
           ip += 1;
           break;
         case RE_OPCODE_REPEAT_ANY_UNGREEDY:
           repeat_any_args = (RE_REPEAT_ANY_ARGS*)(ip + 1);
           next_opcode = ip + 1 + sizeof(RE_REPEAT_ANY_ARGS);
            for (i = repeat_any_args->min + 1; i <= repeat_any_args->max; i++)
            {
            next_input = input + i * input_incr;
              if (bytes_matched + i >= max_bytes_matched)
                break;
             next_input = input + i * input_incr;
              if ( *(next_opcode) != RE_OPCODE_LITERAL ||
                  (*(next_opcode) == RE_OPCODE_LITERAL &&
                   *(next_opcode + 1) == *next_input))
             {
               if (sp >= MAX_FAST_RE_STACK)
                 return -4;
               code_stack[sp] = next_opcode;
               input_stack[sp] = next_input;
               matches_stack[sp] = bytes_matched + i;
               sp++;
             }
           }
            input += input_incr * repeat_any_args->min;
            bytes_matched += repeat_any_args->min;
           bytes_matched = yr_min(bytes_matched, max_bytes_matched);
            ip = next_opcode;
            break;
         default:
           assert(FALSE);
       }
     }
   }
   if (matches != NULL)
     *matches = -1;
   return ERROR_SUCCESS;
 }","[104, 107, 122]",The yr_arena_write_data function in YARA 3.6.1 allows remote attackers to cause a denial of service (buffer over-read and application crash) or obtain sensitive information from process memory via a crafted file that is mishandled in the yr_re_fast_exec function in libyara/re.c and the _yr_scan_match_callback function in libyara/scan.c.,yara,CVE-2017-9465,CWE-125
3141,178604," ProcPanoramiXGetScreenSize(ClientPtr client)
 {
     REQUEST(xPanoramiXGetScreenSizeReq);
     WindowPtr pWin;
      xPanoramiXGetScreenSizeReply rep;
      int rc;
     REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);
      if (stuff->screen >= PanoramiXNumScreens)
          return BadMatch;
    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);
      rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
      if (rc != Success)
          return rc;
     rep = (xPanoramiXGetScreenSizeReply) {
         .type = X_Reply,
         .sequenceNumber = client->sequence,
         .length = 0,
         .width = screenInfo.screens[stuff->screen]->width,
         .height = screenInfo.screens[stuff->screen]->height,
         .window = stuff->window,
         .screen = stuff->screen
     };
     if (client->swapped) {
         swaps(&rep.sequenceNumber);
         swapl(&rep.length);
         swapl(&rep.width);
         swapl(&rep.height);
         swapl(&rep.window);
         swapl(&rep.screen);
     }
     WriteToClient(client, sizeof(xPanoramiXGetScreenSizeReply), &rep);
     return Success;
 }","[7, 10]",xorg-x11-server before 1.19.5 was missing length validation in RENDER extension allowing malicious X client to cause X server to crash or possibly execute arbitrary code.,xserver,CVE-2017-12187,CWE-20
3153,177796," static int nfs_readlink_req(struct nfs_priv *npriv, struct nfs_fh *fh,
 			    char **target)
 {
 	uint32_t data[1024];
 	uint32_t *p;
 	uint32_t len;
 	struct packet *nfs_packet;
 	p = &(data[0]);
 	p = rpc_add_credentials(p);
 	p = nfs_add_fh3(p, fh);
 	len = p - &(data[0]);
 	nfs_packet = rpc_req(npriv, PROG_NFS, NFSPROC3_READLINK, data, len);
 	if (IS_ERR(nfs_packet))
 		return PTR_ERR(nfs_packet);
 	p = (void *)nfs_packet->data + sizeof(struct rpc_reply) + 4;
  	p = nfs_read_post_op_attr(p, NULL);
  	len = ntoh32(net_read_uint32(p));  
 	len = max_t(unsigned int, len,
 		    nfs_packet->len - sizeof(struct rpc_reply) - sizeof(uint32_t));
  	p++;
  	*target = xzalloc(len + 1);
 	return 0;
 }","[18, 19]",Pengutronix barebox through 2019.08.1 has a remote buffer overflow in nfs_readlink_req in fs/nfs.c because a length field is directly used for a memcpy.,pengutronix,CVE-2019-15938,CWE-119
3154,179647," stf_status ikev2parent_inI2outR2(struct msg_digest *md)
 {
 	struct state *st = md->st;
 	DBG(DBG_CONTROLMORE,
 	    DBG_log(
 		    ""ikev2 parent inI2outR2: calculating g^{xy} in order to decrypt I2""));
  	if (!md->chain[ISAKMP_NEXT_v2E]) {
  		libreswan_log(""R2 state should receive an encrypted payload"");
		reset_globals();
 		reset_globals();  
  		return STF_FATAL;
  	}
 	{
 		struct dh_continuation *dh = alloc_thing(
 			struct dh_continuation,
 			""ikev2_inI2outR2 KE"");
 		stf_status e;
 		dh->md = md;
 		set_suspended(st, dh->md);
 		pcrc_init(&dh->dh_pcrc);
 		dh->dh_pcrc.pcrc_func = ikev2_parent_inI2outR2_continue;
 		e = start_dh_v2(&dh->dh_pcrc, st, st->st_import, RESPONDER,
 				st->st_oakley.groupnum);
 		if (e != STF_SUSPEND && e != STF_INLINE) {
 			loglog(RC_CRYPTOFAILED, ""system too busy"");
 			delete_state(st);
 		}
 		reset_globals();
 		return e;
 	}
 }","[9, 10]",The ikev2parent_inI1outR1 function in pluto/ikev2_parent.c in libreswan before 3.7 allows remote attackers to cause a denial of service (restart) via an IKEv2 I1 notification without a KE payload.,libreswan,CVE-2013-7294,CWE-20
3158,181895,"  int jpg_validate(jas_stream_t *in)
  {
	uchar buf[JPG_MAGICLEN];
 	jas_uchar buf[JPG_MAGICLEN];
  	int i;
  	int n;
 	assert(JAS_STREAM_MAXPUTBACK >= JPG_MAGICLEN);
 	if ((n = jas_stream_read(in, buf, JPG_MAGICLEN)) < 0) {
 		return -1;
 	}
 	for (i = n - 1; i >= 0; --i) {
 		if (jas_stream_ungetc(in, buf[i]) == EOF) {
 			return -1;
 		}
 	}
 	if (n < JPG_MAGICLEN) {
 		return -1;
 	}
 	if (buf[0] != (JPG_MAGIC >> 8) || buf[1] != (JPG_MAGIC & 0xff)) {
 		return -1;
 	}
 	return 0;
 }","[3, 4]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
3167,182877," static int mpeg4_decode_studio_block(MpegEncContext *s, int32_t block[64], int n)
 {
     Mpeg4DecContext *ctx = s->avctx->priv_data;
     int cc, dct_dc_size, dct_diff, code, j, idx = 1, group = 0, run = 0,
         additional_code_len, sign, mismatch;
     VLC *cur_vlc = &ctx->studio_intra_tab[0];
     uint8_t *const scantable = s->intra_scantable.permutated;
     const uint16_t *quant_matrix;
     uint32_t flc;
     const int min = -1 *  (1 << (s->avctx->bits_per_raw_sample + 6));
     const int max =      ((1 << (s->avctx->bits_per_raw_sample + 6)) - 1);
     mismatch = 1;
     memset(block, 0, 64 * sizeof(int32_t));
     if (n < 4) {
         cc = 0;
         dct_dc_size = get_vlc2(&s->gb, ctx->studio_luma_dc.table, STUDIO_INTRA_BITS, 2);
         quant_matrix = s->intra_matrix;
     } else {
         cc = (n & 1) + 1;
         if (ctx->rgb)
             dct_dc_size = get_vlc2(&s->gb, ctx->studio_luma_dc.table, STUDIO_INTRA_BITS, 2);
         else
             dct_dc_size = get_vlc2(&s->gb, ctx->studio_chroma_dc.table, STUDIO_INTRA_BITS, 2);
         quant_matrix = s->chroma_intra_matrix;
     }
     if (dct_dc_size < 0) {
         av_log(s->avctx, AV_LOG_ERROR, ""illegal dct_dc_size vlc\n"");
         return AVERROR_INVALIDDATA;
     } else if (dct_dc_size == 0) {
         dct_diff = 0;
     } else {
         dct_diff = get_xbits(&s->gb, dct_dc_size);
         if (dct_dc_size > 8) {
             if(!check_marker(s->avctx, &s->gb, ""dct_dc_size > 8""))
                 return AVERROR_INVALIDDATA;
         }
     }
     s->last_dc[cc] += dct_diff;
     if (s->mpeg_quant)
         block[0] = s->last_dc[cc] * (8 >> s->intra_dc_precision);
     else
         block[0] = s->last_dc[cc] * (8 >> s->intra_dc_precision) * (8 >> s->dct_precision);
     block[0] = av_clip(block[0], min, max);
     mismatch ^= block[0];
     while (1) {
         group = get_vlc2(&s->gb, cur_vlc->table, STUDIO_INTRA_BITS, 2);
         if (group < 0) {
             av_log(s->avctx, AV_LOG_ERROR, ""illegal ac coefficient group vlc\n"");
             return AVERROR_INVALIDDATA;
         }
         additional_code_len = ac_state_tab[group][0];
         cur_vlc = &ctx->studio_intra_tab[ac_state_tab[group][1]];
         if (group == 0) {
             break;
         } else if (group >= 1 && group <= 6) {
             run = 1 << additional_code_len;
             if (additional_code_len)
                 run += get_bits(&s->gb, additional_code_len);
             idx += run;
             continue;
         } else if (group >= 7 && group <= 12) {
             code = get_bits(&s->gb, additional_code_len);
             sign = code & 1;
              code >>= 1;
              run = (1 << (additional_code_len - 1)) + code;
              idx += run;
             if (idx > 63)
                 return AVERROR_INVALIDDATA;
              j = scantable[idx++];
              block[j] = sign ? 1 : -1;
          } else if (group >= 13 && group <= 20) {
             if (idx > 63)
                 return AVERROR_INVALIDDATA;
              j = scantable[idx++];
              block[j] = get_xbits(&s->gb, additional_code_len);
          } else if (group == 21) {
             if (idx > 63)
                 return AVERROR_INVALIDDATA;
              j = scantable[idx++];
              additional_code_len = s->avctx->bits_per_raw_sample + s->dct_precision + 4;
              flc = get_bits(&s->gb, additional_code_len);
             if (flc >> (additional_code_len-1))
                 block[j] = -1 * (( flc ^ ((1 << additional_code_len) -1)) + 1);
             else
                 block[j] = flc;
         }
         block[j] = ((8 * 2 * block[j] * quant_matrix[j] * s->qscale) >> s->dct_precision) / 32;
         block[j] = av_clip(block[j], min, max);
         mismatch ^= block[j];
     }
     block[63] ^= mismatch & 1;
     return 0;
 }","[67, 68, 72, 73, 77, 78]",The studio profile decoder in libavcodec/mpeg4videodec.c in FFmpeg 4.0 before 4.0.4 and 4.1 before 4.1.2 allows remote attackers to cause a denial of service (out-of-array access) or possibly have unspecified other impact via crafted MPEG-4 video data.,FFmpeg,CVE-2019-11339,CWE-125
3176,182243," static int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* serial)
 {
 	cac_private_data_t * priv = CAC_DATA(card);
 	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_NORMAL);
         if (card->serialnr.len)   {
                 *serial = card->serialnr;
                 SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);
          }
  	if (priv->cac_id_len) {
  		serial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);
		memcpy(serial->value, priv->cac_id, priv->cac_id_len);
 		memcpy(serial->value, priv->cac_id, serial->len);
  		SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);
  	}
  	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);
 }","[11, 12]",A double free when handling responses from an HSM Card in sc_pkcs15emu_sc_hsm_init in libopensc/pkcs15-sc-hsm.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.,OpenSC,CVE-2018-16425,CWE-415
3180,177936," ProcSendEvent(ClientPtr client)
 {
     WindowPtr pWin;
     WindowPtr effectiveFocus = NullWindow;       
     DeviceIntPtr dev = PickPointer(client);
     DeviceIntPtr keybd = GetMaster(dev, MASTER_KEYBOARD);
     SpritePtr pSprite = dev->spriteInfo->sprite;
     REQUEST(xSendEventReq);
     REQUEST_SIZE_MATCH(xSendEventReq);
     stuff->event.u.u.type &= ~(SEND_EVENT_BIT);
     if (!((stuff->event.u.u.type > X_Reply &&
            stuff->event.u.u.type < LASTEvent) ||
           (stuff->event.u.u.type >= EXTENSION_EVENT_BASE &&
            stuff->event.u.u.type < (unsigned) lastEvent))) {
          client->errorValue = stuff->event.u.u.type;
          return BadValue;
      }
     if (stuff->event.u.u.type == GenericEvent) {
         client->errorValue = stuff->event.u.u.type;
         return BadValue;
     }
      if (stuff->event.u.u.type == ClientMessage &&
          stuff->event.u.u.detail != 8 &&
          stuff->event.u.u.detail != 16 && stuff->event.u.u.detail != 32) {
     }
     if (stuff->destination == PointerWindow)
         pWin = pSprite->win;
     else if (stuff->destination == InputFocus) {
         WindowPtr inputFocus = (keybd) ? keybd->focus->win : NoneWin;
         if (inputFocus == NoneWin)
             return Success;
         if (inputFocus == PointerRootWin)
             inputFocus = GetCurrentRootWindow(dev);
         if (IsParent(inputFocus, pSprite->win)) {
             effectiveFocus = inputFocus;
             pWin = pSprite->win;
         }
         else
             effectiveFocus = pWin = inputFocus;
     }
     else
         dixLookupWindow(&pWin, stuff->destination, client, DixSendAccess);
     if (!pWin)
         return BadWindow;
     if ((stuff->propagate != xFalse) && (stuff->propagate != xTrue)) {
         client->errorValue = stuff->propagate;
         return BadValue;
     }
     stuff->event.u.u.type |= SEND_EVENT_BIT;
     if (stuff->propagate) {
         for (; pWin; pWin = pWin->parent) {
             if (XaceHook(XACE_SEND_ACCESS, client, NULL, pWin,
                          &stuff->event, 1))
                 return Success;
             if (DeliverEventsToWindow(dev, pWin,
                                       &stuff->event, 1, stuff->eventMask,
                                       NullGrab))
                 return Success;
             if (pWin == effectiveFocus)
                 return Success;
             stuff->eventMask &= ~wDontPropagateMask(pWin);
             if (!stuff->eventMask)
                 break;
         }
     }
     else if (!XaceHook(XACE_SEND_ACCESS, client, NULL, pWin, &stuff->event, 1))
         DeliverEventsToWindow(dev, pWin, &stuff->event,
                               1, stuff->eventMask, NullGrab);
     return Success;
 }","[18, 19, 20, 21]","In the X.Org X server before 2017-06-19, a user authenticated to an X Session could crash or execute code in the context of the X Server by exploiting a stack overflow in the endianness conversion of X Events.",xserver,CVE-2017-10971,CWE-119
3220,182614," static int jpc_pi_nextrpcl(register jpc_pi_t *pi)
 {
 	int rlvlno;
 	jpc_pirlvl_t *pirlvl;
 	jpc_pchg_t *pchg;
 	int prchind;
 	int prcvind;
 	int *prclyrno;
 	int compno;
 	jpc_picomp_t *picomp;
 	int xstep;
 	int ystep;
 	uint_fast32_t r;
 	uint_fast32_t rpx;
 	uint_fast32_t rpy;
 	uint_fast32_t trx0;
 	uint_fast32_t try0;
 	pchg = pi->pchg;
 	if (!pi->prgvolfirst) {
 		goto skip;
 	} else {
 		pi->xstep = 0;
 		pi->ystep = 0;
 		for (compno = 0, picomp = pi->picomps; compno < pi->numcomps;
  		  ++compno, ++picomp) {
  			for (rlvlno = 0, pirlvl = picomp->pirlvls; rlvlno <
  			  picomp->numrlvls; ++rlvlno, ++pirlvl) {
				xstep = picomp->hsamp * (1 << (pirlvl->prcwidthexpn +
				  picomp->numrlvls - rlvlno - 1));
				ystep = picomp->vsamp * (1 << (pirlvl->prcheightexpn +
				  picomp->numrlvls - rlvlno - 1));
 				if (pirlvl->prcwidthexpn + pi->picomp->numrlvls >
 				  JAS_UINTFAST32_NUMBITS - 2 ||
 				  pirlvl->prcheightexpn + pi->picomp->numrlvls >
 				  JAS_UINTFAST32_NUMBITS - 2) {
 					return -1;
 				}
 				xstep = picomp->hsamp * (JAS_CAST(uint_fast32_t, 1) <<
 				  (pirlvl->prcwidthexpn + picomp->numrlvls - rlvlno - 1));
 				ystep = picomp->vsamp * (JAS_CAST(uint_fast32_t, 1) <<
 				  (pirlvl->prcheightexpn + picomp->numrlvls - rlvlno - 1));
  				pi->xstep = (!pi->xstep) ? xstep : JAS_MIN(pi->xstep, xstep);
  				pi->ystep = (!pi->ystep) ? ystep : JAS_MIN(pi->ystep, ystep);
  			}
 		}
 		pi->prgvolfirst = 0;
 	}
 	for (pi->rlvlno = pchg->rlvlnostart; pi->rlvlno < pchg->rlvlnoend &&
 	  pi->rlvlno < pi->maxrlvls; ++pi->rlvlno) {
 		for (pi->y = pi->ystart; pi->y < pi->yend; pi->y +=
 		  pi->ystep - (pi->y % pi->ystep)) {
 			for (pi->x = pi->xstart; pi->x < pi->xend; pi->x +=
 			  pi->xstep - (pi->x % pi->xstep)) {
 				for (pi->compno = pchg->compnostart,
 				  pi->picomp = &pi->picomps[pi->compno];
 				  pi->compno < JAS_CAST(int, pchg->compnoend) && pi->compno <
 				  pi->numcomps; ++pi->compno, ++pi->picomp) {
 					if (pi->rlvlno >= pi->picomp->numrlvls) {
 						continue;
 					}
 					pi->pirlvl = &pi->picomp->pirlvls[pi->rlvlno];
 					if (pi->pirlvl->numprcs == 0) {
 						continue;
 					}
 					r = pi->picomp->numrlvls - 1 - pi->rlvlno;
 					rpx = r + pi->pirlvl->prcwidthexpn;
  					rpy = r + pi->pirlvl->prcheightexpn;
  					trx0 = JPC_CEILDIV(pi->xstart, pi->picomp->hsamp << r);
  					try0 = JPC_CEILDIV(pi->ystart, pi->picomp->vsamp << r);
					if (((pi->x == pi->xstart && ((trx0 << r) % (1 << rpx)))
					  || !(pi->x % (1 << rpx))) &&
					  ((pi->y == pi->ystart && ((try0 << r) % (1 << rpy)))
					  || !(pi->y % (1 << rpy)))) {
						prchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x, pi->picomp->hsamp
						  << r), pi->pirlvl->prcwidthexpn) - JPC_FLOORDIVPOW2(trx0,
						  pi->pirlvl->prcwidthexpn);
						prcvind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->y, pi->picomp->vsamp
						  << r), pi->pirlvl->prcheightexpn) - JPC_FLOORDIVPOW2(try0,
						  pi->pirlvl->prcheightexpn);
 					if (((pi->x == pi->xstart &&
 					  ((trx0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpx)))
 					  || !(pi->x % (JAS_CAST(uint_fast32_t, 1) << rpx))) &&
 					  ((pi->y == pi->ystart &&
 					  ((try0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpy)))
 					  || !(pi->y % (JAS_CAST(uint_fast32_t, 1) << rpy)))) {
 						prchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x,
 						  pi->picomp->hsamp << r), pi->pirlvl->prcwidthexpn) -
 						  JPC_FLOORDIVPOW2(trx0, pi->pirlvl->prcwidthexpn);
 						prcvind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->y,
 						  pi->picomp->vsamp << r), pi->pirlvl->prcheightexpn) -
 						  JPC_FLOORDIVPOW2(try0, pi->pirlvl->prcheightexpn);
  						pi->prcno = prcvind * pi->pirlvl->numhprcs + prchind;
  						assert(pi->prcno < pi->pirlvl->numprcs);
  						for (pi->lyrno = 0; pi->lyrno <
						  pi->numlyrs && pi->lyrno < JAS_CAST(int, pchg->lyrnoend); ++pi->lyrno) {
 						  pi->numlyrs && pi->lyrno < JAS_CAST(int,
 						  pchg->lyrnoend); ++pi->lyrno) {
  							prclyrno = &pi->pirlvl->prclyrnos[pi->prcno];
  							if (pi->lyrno >= *prclyrno) {
  								++(*prclyrno);
 								return 0;
 							}
 skip:
 							;
 						}
 					}
 				}
 			}
 		}
 	}
 	return 1;
 }","[28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 95, 96, 97]",An out-of-bounds heap read vulnerability was found in the jpc_pi_nextpcrl() function of jasper before 2.0.6 when processing crafted input.,jasper,CVE-2016-9583,CWE-125
3226,181666," static int http_receive_data(HTTPContext *c)
 {
     HTTPContext *c1;
     int len, loop_run = 0;
     while (c->chunked_encoding && !c->chunk_size &&
            c->buffer_end > c->buffer_ptr) {
         len = recv(c->fd, c->buffer_ptr, 1, 0);
         if (len < 0) {
             if (ff_neterrno() != AVERROR(EAGAIN) &&
                 ff_neterrno() != AVERROR(EINTR))
                 goto fail;
             return 0;
         } else if (len == 0) {
             goto fail;
          } else if (c->buffer_ptr - c->buffer >= 2 &&
                     !memcmp(c->buffer_ptr - 1, ""\r\n"", 2)) {
              c->chunk_size = strtol(c->buffer, 0, 16);
            if (c->chunk_size == 0)  
             if (c->chunk_size <= 0) {  
                 c->chunk_size = 0;
                  goto fail;
             }
              c->buffer_ptr = c->buffer;
              break;
          } else if (++loop_run > 10)
             goto fail;
         else
             c->buffer_ptr++;
     }
     if (c->buffer_end > c->buffer_ptr) {
         len = recv(c->fd, c->buffer_ptr,
                    FFMIN(c->chunk_size, c->buffer_end - c->buffer_ptr), 0);
         if (len < 0) {
             if (ff_neterrno() != AVERROR(EAGAIN) &&
                 ff_neterrno() != AVERROR(EINTR))
                 goto fail;
         } else if (len == 0)
              goto fail;
          else {
             av_assert0(len <= c->chunk_size);
              c->chunk_size -= len;
              c->buffer_ptr += len;
              c->data_count += len;
             update_datarate(&c->datarate, c->data_count);
         }
     }
     if (c->buffer_ptr - c->buffer >= 2 && c->data_count > FFM_PACKET_SIZE) {
         if (c->buffer[0] != 'f' ||
             c->buffer[1] != 'm') {
             http_log(""Feed stream has become desynchronized -- disconnecting\n"");
             goto fail;
         }
     }
     if (c->buffer_ptr >= c->buffer_end) {
         FFServerStream *feed = c->stream;
         if (c->data_count > FFM_PACKET_SIZE) {
             if (lseek(c->feed_fd, feed->feed_write_index, SEEK_SET) == -1)
                 http_log(""Seek to %""PRId64"" failed\n"", feed->feed_write_index);
             if (write(c->feed_fd, c->buffer, FFM_PACKET_SIZE) < 0) {
                 http_log(""Error writing to feed file: %s\n"", strerror(errno));
                 goto fail;
             }
             feed->feed_write_index += FFM_PACKET_SIZE;
             if (feed->feed_write_index > c->stream->feed_size)
                 feed->feed_size = feed->feed_write_index;
             if (c->stream->feed_max_size &&
                 feed->feed_write_index >= c->stream->feed_max_size)
                 feed->feed_write_index = FFM_PACKET_SIZE;
             if (ffm_write_write_index(c->feed_fd, feed->feed_write_index) < 0) {
                 http_log(""Error writing index to feed file: %s\n"",
                          strerror(errno));
                 goto fail;
             }
             for(c1 = first_http_ctx; c1; c1 = c1->next) {
                 if (c1->state == HTTPSTATE_WAIT_FEED &&
                     c1->stream->feed == c->stream->feed)
                     c1->state = HTTPSTATE_SEND_DATA;
             }
         } else {
             AVFormatContext *s = avformat_alloc_context();
             AVIOContext *pb;
             AVInputFormat *fmt_in;
             int i;
             if (!s)
                 goto fail;
             fmt_in = av_find_input_format(feed->fmt->name);
             if (!fmt_in)
                 goto fail;
             pb = avio_alloc_context(c->buffer, c->buffer_end - c->buffer,
                                     0, NULL, NULL, NULL, NULL);
             if (!pb)
                 goto fail;
             pb->seekable = 0;
             s->pb = pb;
             if (avformat_open_input(&s, c->stream->feed_filename, fmt_in, NULL) < 0) {
                 av_freep(&pb);
                 goto fail;
             }
             if (s->nb_streams != feed->nb_streams) {
                 avformat_close_input(&s);
                 av_freep(&pb);
                 http_log(""Feed '%s' stream number does not match registered feed\n"",
                          c->stream->feed_filename);
                 goto fail;
             }
             for (i = 0; i < s->nb_streams; i++) {
                 LayeredAVStream *fst = feed->streams[i];
                 AVStream *st = s->streams[i];
                 avcodec_parameters_to_context(fst->codec, st->codecpar);
                 avcodec_parameters_from_context(fst->codecpar, fst->codec);
             }
             avformat_close_input(&s);
             av_freep(&pb);
         }
         c->buffer_ptr = c->buffer;
     }
     return 0;
  fail:
     c->stream->feed_opened = 0;
     close(c->feed_fd);
     for(c1 = first_http_ctx; c1; c1 = c1->next) {
         if (c1->state == HTTPSTATE_WAIT_FEED &&
             c1->stream->feed == c->stream->feed)
             c1->state = HTTPSTATE_SEND_DATA_TRAILER;
     }
     return -1;
 }","[18, 19, 20, 22, 40]","Heap-based buffer overflow in ffserver.c in FFmpeg before 2.8.10, 3.0.x before 3.0.5, 3.1.x before 3.1.6, and 3.2.x before 3.2.2 allows remote attackers to execute arbitrary code by leveraging failure to check chunk size.",FFmpeg,CVE-2016-10192,CWE-119
3228,182222," static int cac_read_binary(sc_card_t *card, unsigned int idx,
 		unsigned char *buf, size_t count, unsigned long flags)
 {
 	cac_private_data_t * priv = CAC_DATA(card);
 	int r = 0;
 	u8 *tl = NULL, *val = NULL;
 	u8 *tl_ptr, *val_ptr, *tlv_ptr, *tl_start;
 	u8 *cert_ptr;
 	size_t tl_len, val_len, tlv_len;
 	size_t len, tl_head_len, cert_len;
 	u8 cert_type, tag;
 	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
 	if (priv->cached) {
 		sc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,
 			 ""returning cached value idx=%d count=%""SC_FORMAT_LEN_SIZE_T""u"",
 			 idx, count);
 		if (idx > priv->cache_buf_len) {
 			SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_END_REACHED);
 		}
 		len = MIN(count, priv->cache_buf_len-idx);
 		memcpy(buf, &priv->cache_buf[idx], len);
 		SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, len);
 	}
 	sc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,
 		 ""clearing cache idx=%d count=%""SC_FORMAT_LEN_SIZE_T""u"",
 		 idx, count);
 	if (priv->cache_buf) {
 		free(priv->cache_buf);
 		priv->cache_buf = NULL;
 		priv->cache_buf_len = 0;
 	}
 	if (priv->object_type <= 0)
 		 SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_INTERNAL);
 	r = cac_read_file(card, CAC_FILE_TAG, &tl, &tl_len);
 	if (r < 0)  {
 		goto done;
 	}
 	r = cac_read_file(card, CAC_FILE_VALUE, &val, &val_len);
 	if (r < 0)
 		goto done;
 	switch (priv->object_type) {
 	case CAC_OBJECT_TYPE_TLV_FILE:
 		tlv_len = tl_len + val_len;
 		priv->cache_buf = malloc(tlv_len);
 		if (priv->cache_buf == NULL) {
 			r = SC_ERROR_OUT_OF_MEMORY;
 			goto done;
 		}
 		priv->cache_buf_len = tlv_len;
 		for (tl_ptr = tl, val_ptr=val, tlv_ptr = priv->cache_buf;
 				tl_len >= 2 && tlv_len > 0;
 				val_len -= len, tlv_len -= len, val_ptr += len, tlv_ptr += len) {
 			tl_start = tl_ptr;
 			if (sc_simpletlv_read_tag(&tl_ptr, tl_len, &tag, &len) != SC_SUCCESS)
 				break;
 			tl_head_len = (tl_ptr - tl_start);
 			sc_simpletlv_put_tag(tag, len, tlv_ptr, tlv_len, &tlv_ptr);
 			tlv_len -= tl_head_len;
 			tl_len -= tl_head_len;
 			if (val_len < len) {
 				len = val_len;
 			}
 			if (tlv_len < len) {
 				len = tlv_len;
 			}
 			memcpy(tlv_ptr, val_ptr, len);
 		}
 		break;
 	case CAC_OBJECT_TYPE_CERT:
 		sc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,
 			 "" obj= cert_file, val_len=%""SC_FORMAT_LEN_SIZE_T""u (0x%04""SC_FORMAT_LEN_SIZE_T""x)"",
 			 val_len, val_len);
  		cert_len = 0;
  		cert_ptr = NULL;
  		cert_type = 0;
		for (tl_ptr = tl, val_ptr=val; tl_len >= 2;
				val_len -= len, val_ptr += len, tl_len -= tl_head_len) {
 		for (tl_ptr = tl, val_ptr = val; tl_len >= 2;
 		    val_len -= len, val_ptr += len, tl_len -= tl_head_len) {
  			tl_start = tl_ptr;
  			if (sc_simpletlv_read_tag(&tl_ptr, tl_len, &tag, &len) != SC_SUCCESS)
  				break;
  			tl_head_len = tl_ptr - tl_start;
 			if (val_len < len)
 				break;
  			if (tag == CAC_TAG_CERTIFICATE) {
  				cert_len = len;
  				cert_ptr = val_ptr;
 			}
 			if (tag == CAC_TAG_CERTINFO) {
 				if ((len >= 1) && (val_len >=1)) {
 					cert_type = *val_ptr;
 				}
 			}
 			if (tag == CAC_TAG_MSCUID) {
 				sc_log_hex(card->ctx, ""MSCUID"", val_ptr, len);
 			}
 			if ((val_len < len) || (tl_len < tl_head_len)) {
 				break;
 			}
 		}
 		if ((cert_type & 0x3) == 1) {
 #ifdef ENABLE_ZLIB
 			r = sc_decompress_alloc(&priv->cache_buf, &priv->cache_buf_len,
 				cert_ptr, cert_len, COMPRESSION_AUTO);
 #else
 			sc_log(card->ctx, ""CAC compression not supported, no zlib"");
 			r = SC_ERROR_NOT_SUPPORTED;
 #endif
 			if (r)
 				goto done;
 		} else if (cert_len > 0) {
 			priv->cache_buf = malloc(cert_len);
 			if (priv->cache_buf == NULL) {
 				r = SC_ERROR_OUT_OF_MEMORY;
 				goto done;
 			}
 			priv->cache_buf_len = cert_len;
 			memcpy(priv->cache_buf, cert_ptr, cert_len);
 		} else {
 			sc_log(card->ctx, ""Can't read zero-length certificate"");
 			goto done;
 		}
 		break;
 	case CAC_OBJECT_TYPE_GENERIC:
 	default:
 		sc_log(card->ctx, ""Unknown object type: %x"", priv->object_type);
 		r = SC_ERROR_INTERNAL;
 		goto done;
 	}
 	priv->cached = 1;
 	len = MIN(count, priv->cache_buf_len-idx);
 	memcpy(buf, &priv->cache_buf[idx], len);
 	r = len;
 done:
 	if (tl)
 		free(tl);
 	if (val)
 		free(val);
 	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, r);
 }","[76, 77, 78, 79, 84, 85]",Various out of bounds reads when handling responses in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to potentially crash the opensc library using programs.,OpenSC,CVE-2018-16427,CWE-125
3231,177801,"  static void build_l4proto_dccp(const struct nf_conntrack *ct, struct nethdr *n)
  {
	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
		      sizeof(struct nfct_attr_grp_port));
  	if (!nfct_attr_is_set(ct, ATTR_DCCP_STATE))
  		return;
 	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
 		      sizeof(struct nfct_attr_grp_port));
  	ct_build_u8(ct, ATTR_DCCP_STATE, n, NTA_DCCP_STATE);
  	ct_build_u8(ct, ATTR_DCCP_ROLE, n, NTA_DCCP_ROLE);
  }","[3, 4, 7, 8]","conntrackd in conntrack-tools 1.4.2 and earlier does not ensure that the optional kernel modules are loaded before using them, which allows remote attackers to cause a denial of service (crash) via a (1) DCCP, (2) SCTP, or (3) ICMPv6 packet.",netfilter,CVE-2015-6496,CWE-17
3243,181854," int jas_memdump(FILE *out, void *data, size_t len)
  {
  	size_t i;
  	size_t j;
	uchar *dp;
 	jas_uchar *dp;
  	dp = data;
  	for (i = 0; i < len; i += 16) {
  		fprintf(out, ""%04zx:"", i);
 		for (j = 0; j < 16; ++j) {
 			if (i + j < len) {
 				fprintf(out, "" %02x"", dp[i + j]);
 			}
 		}
 		fprintf(out, ""\n"");
 	}
 	return 0;
 }","[5, 6]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
3250,181855,"  static int jas_iccgetsint32(jas_stream_t *in, jas_iccsint32_t *val)
  {
	ulonglong tmp;
 	jas_ulonglong tmp;
  	if (jas_iccgetuint(in, 4, &tmp))
  		return -1;
	*val = (tmp & 0x80000000) ? (-JAS_CAST(longlong, (((~tmp) &
	  0x7fffffff) + 1))) : JAS_CAST(longlong, tmp);
 	*val = (tmp & 0x80000000) ? (-JAS_CAST(jas_longlong, (((~tmp) &
 	  0x7fffffff) + 1))) : JAS_CAST(jas_longlong, tmp);
  	return 0;
  }","[3, 4, 7, 8, 9, 10]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
3271,182103," read_header(struct archive_read *a, struct archive_entry *entry,
             char head_type)
 {
   const void *h;
   const char *p, *endp;
   struct rar *rar;
   struct rar_header rar_header;
   struct rar_file_header file_header;
   int64_t header_size;
   unsigned filename_size, end;
   char *filename;
   char *strp;
   char packed_size[8];
   char unp_size[8];
   int ttime;
   struct archive_string_conv *sconv, *fn_sconv;
   unsigned long crc32_val;
   int ret = (ARCHIVE_OK), ret2;
   rar = (struct rar *)(a->format->data);
   sconv = rar->opt_sconv;
   if (sconv == NULL) {
     if (!rar->init_default_conversion) {
       rar->sconv_default =
           archive_string_default_conversion_for_read(
             &(a->archive));
       rar->init_default_conversion = 1;
     }
     sconv = rar->sconv_default;
   }
   if ((h = __archive_read_ahead(a, 7, NULL)) == NULL)
     return (ARCHIVE_FATAL);
   p = h;
   memcpy(&rar_header, p, sizeof(rar_header));
   rar->file_flags = archive_le16dec(rar_header.flags);
   header_size = archive_le16dec(rar_header.size);
   if (header_size < (int64_t)sizeof(file_header) + 7) {
     archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
       ""Invalid header size"");
     return (ARCHIVE_FATAL);
   }
   crc32_val = crc32(0, (const unsigned char *)p + 2, 7 - 2);
   __archive_read_consume(a, 7);
   if (!(rar->file_flags & FHD_SOLID))
   {
     rar->compression_method = 0;
     rar->packed_size = 0;
     rar->unp_size = 0;
     rar->mtime = 0;
     rar->ctime = 0;
     rar->atime = 0;
     rar->arctime = 0;
     rar->mode = 0;
     memset(&rar->salt, 0, sizeof(rar->salt));
     rar->atime = 0;
     rar->ansec = 0;
     rar->ctime = 0;
     rar->cnsec = 0;
     rar->mtime = 0;
     rar->mnsec = 0;
     rar->arctime = 0;
     rar->arcnsec = 0;
   }
   else
   {
     archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                       ""RAR solid archive support unavailable."");
     return (ARCHIVE_FATAL);
   }
   if ((h = __archive_read_ahead(a, (size_t)header_size - 7, NULL)) == NULL)
     return (ARCHIVE_FATAL);
   crc32_val = crc32(crc32_val, h, (unsigned)(header_size - 7));
   if ((crc32_val & 0xffff) != archive_le16dec(rar_header.crc)) {
     archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
       ""Header CRC error"");
     return (ARCHIVE_FATAL);
   }
   p = h;
   endp = p + header_size - 7;
   memcpy(&file_header, p, sizeof(file_header));
   p += sizeof(file_header);
   rar->compression_method = file_header.method;
   ttime = archive_le32dec(file_header.file_time);
   rar->mtime = get_time(ttime);
   rar->file_crc = archive_le32dec(file_header.file_crc);
   if (rar->file_flags & FHD_PASSWORD)
   {
 	archive_entry_set_is_data_encrypted(entry, 1);
 	rar->has_encrypted_entries = 1;
     archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                       ""RAR encryption support unavailable."");
   }
   if (rar->file_flags & FHD_LARGE)
   {
     memcpy(packed_size, file_header.pack_size, 4);
     memcpy(packed_size + 4, p, 4);  
     p += 4;
     memcpy(unp_size, file_header.unp_size, 4);
     memcpy(unp_size + 4, p, 4);  
     p += 4;
     rar->packed_size = archive_le64dec(&packed_size);
     rar->unp_size = archive_le64dec(&unp_size);
   }
   else
   {
     rar->packed_size = archive_le32dec(file_header.pack_size);
     rar->unp_size = archive_le32dec(file_header.unp_size);
   }
   if (rar->packed_size < 0 || rar->unp_size < 0)
   {
     archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                       ""Invalid sizes specified."");
     return (ARCHIVE_FATAL);
   }
   rar->bytes_remaining = rar->packed_size;
   if (head_type == NEWSUB_HEAD) {
     size_t distance = p - (const char *)h;
     header_size += rar->packed_size;
     if ((h = __archive_read_ahead(a, (size_t)header_size - 7, NULL)) == NULL)
         return (ARCHIVE_FATAL);
     p = h;
     endp = p + header_size - 7;
     p += distance;
   }
   filename_size = archive_le16dec(file_header.name_size);
   if (p + filename_size > endp) {
     archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
       ""Invalid filename size"");
     return (ARCHIVE_FATAL);
   }
   if (rar->filename_allocated < filename_size * 2 + 2) {
     char *newptr;
     size_t newsize = filename_size * 2 + 2;
     newptr = realloc(rar->filename, newsize);
     if (newptr == NULL) {
       archive_set_error(&a->archive, ENOMEM,
                         ""Couldn't allocate memory."");
       return (ARCHIVE_FATAL);
     }
     rar->filename = newptr;
     rar->filename_allocated = newsize;
   }
   filename = rar->filename;
   memcpy(filename, p, filename_size);
   filename[filename_size] = '\0';
   if (rar->file_flags & FHD_UNICODE)
   {
     if (filename_size != strlen(filename))
     {
       unsigned char highbyte, flagbits, flagbyte;
       unsigned fn_end, offset;
       end = filename_size;
       fn_end = filename_size * 2;
       filename_size = 0;
       offset = (unsigned)strlen(filename) + 1;
       highbyte = *(p + offset++);
       flagbits = 0;
       flagbyte = 0;
       while (offset < end && filename_size < fn_end)
       {
         if (!flagbits)
         {
           flagbyte = *(p + offset++);
           flagbits = 8;
         }
         flagbits -= 2;
         switch((flagbyte >> flagbits) & 3)
         {
           case 0:
             filename[filename_size++] = '\0';
             filename[filename_size++] = *(p + offset++);
             break;
           case 1:
             filename[filename_size++] = highbyte;
             filename[filename_size++] = *(p + offset++);
             break;
           case 2:
             filename[filename_size++] = *(p + offset + 1);
             filename[filename_size++] = *(p + offset);
             offset += 2;
             break;
           case 3:
           {
             char extra, high;
             uint8_t length = *(p + offset++);
             if (length & 0x80) {
               extra = *(p + offset++);
               high = (char)highbyte;
             } else
               extra = high = 0;
             length = (length & 0x7f) + 2;
             while (length && filename_size < fn_end) {
               unsigned cp = filename_size >> 1;
               filename[filename_size++] = high;
               filename[filename_size++] = p[cp] + extra;
               length--;
             }
           }
           break;
         }
       }
       if (filename_size > fn_end) {
         archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
           ""Invalid filename"");
         return (ARCHIVE_FATAL);
       }
       filename[filename_size++] = '\0';
       filename[filename_size] = '\0';
       if (rar->sconv_utf16be == NULL) {
         rar->sconv_utf16be = archive_string_conversion_from_charset(
            &a->archive, ""UTF-16BE"", 1);
         if (rar->sconv_utf16be == NULL)
           return (ARCHIVE_FATAL);
       }
       fn_sconv = rar->sconv_utf16be;
       strp = filename;
       while (memcmp(strp, ""\x00\x00"", 2))
       {
         if (!memcmp(strp, ""\x00\\"", 2))
           *(strp + 1) = '/';
         strp += 2;
       }
       p += offset;
     } else {
       if (rar->sconv_utf8 == NULL) {
         rar->sconv_utf8 = archive_string_conversion_from_charset(
            &a->archive, ""UTF-8"", 1);
         if (rar->sconv_utf8 == NULL)
           return (ARCHIVE_FATAL);
       }
       fn_sconv = rar->sconv_utf8;
       while ((strp = strchr(filename, '\\')) != NULL)
         *strp = '/';
       p += filename_size;
     }
   }
   else
   {
     fn_sconv = sconv;
     while ((strp = strchr(filename, '\\')) != NULL)
       *strp = '/';
     p += filename_size;
   }
   if (rar->filename_save &&
     filename_size == rar->filename_save_size &&
     !memcmp(rar->filename, rar->filename_save, filename_size + 1))
   {
     __archive_read_consume(a, header_size - 7);
     rar->cursor++;
     if (rar->cursor >= rar->nodes)
     {
       rar->nodes++;
       if ((rar->dbo =
         realloc(rar->dbo, sizeof(*rar->dbo) * rar->nodes)) == NULL)
       {
         archive_set_error(&a->archive, ENOMEM, ""Couldn't allocate memory."");
         return (ARCHIVE_FATAL);
       }
       rar->dbo[rar->cursor].header_size = header_size;
       rar->dbo[rar->cursor].start_offset = -1;
       rar->dbo[rar->cursor].end_offset = -1;
     }
     if (rar->dbo[rar->cursor].start_offset < 0)
     {
       rar->dbo[rar->cursor].start_offset = a->filter->position;
       rar->dbo[rar->cursor].end_offset = rar->dbo[rar->cursor].start_offset +
         rar->packed_size;
      }
      return ret;
    }
   else if (rar->filename_must_match)
   {
     archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
       ""Mismatch of file parts split across multi-volume archive"");
     return (ARCHIVE_FATAL);
   }
    rar->filename_save = (char*)realloc(rar->filename_save,
                                        filename_size + 1);
   memcpy(rar->filename_save, rar->filename, filename_size + 1);
   rar->filename_save_size = filename_size;
   free(rar->dbo);
   if ((rar->dbo = calloc(1, sizeof(*rar->dbo))) == NULL)
   {
     archive_set_error(&a->archive, ENOMEM, ""Couldn't allocate memory."");
     return (ARCHIVE_FATAL);
   }
   rar->dbo[0].header_size = header_size;
   rar->dbo[0].start_offset = -1;
   rar->dbo[0].end_offset = -1;
   rar->cursor = 0;
   rar->nodes = 1;
   if (rar->file_flags & FHD_SALT)
   {
     if (p + 8 > endp) {
       archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
         ""Invalid header size"");
       return (ARCHIVE_FATAL);
     }
     memcpy(rar->salt, p, 8);
     p += 8;
   }
   if (rar->file_flags & FHD_EXTTIME) {
     if (read_exttime(p, rar, endp) < 0) {
       archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
         ""Invalid header size"");
       return (ARCHIVE_FATAL);
     }
   }
   __archive_read_consume(a, header_size - 7);
   rar->dbo[0].start_offset = a->filter->position;
   rar->dbo[0].end_offset = rar->dbo[0].start_offset + rar->packed_size;
   switch(file_header.host_os)
   {
   case OS_MSDOS:
   case OS_OS2:
   case OS_WIN32:
     rar->mode = archive_le32dec(file_header.file_attr);
     if (rar->mode & FILE_ATTRIBUTE_DIRECTORY)
       rar->mode = AE_IFDIR | S_IXUSR | S_IXGRP | S_IXOTH;
     else
       rar->mode = AE_IFREG;
     rar->mode |= S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
     break;
   case OS_UNIX:
   case OS_MAC_OS:
   case OS_BEOS:
     rar->mode = archive_le32dec(file_header.file_attr);
     break;
   default:
     archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                       ""Unknown file attributes from RAR file's host OS"");
     return (ARCHIVE_FATAL);
   }
   rar->bytes_uncopied = rar->bytes_unconsumed = 0;
   rar->lzss.position = rar->offset = 0;
   rar->offset_seek = 0;
   rar->dictionary_size = 0;
   rar->offset_outgoing = 0;
   rar->br.cache_avail = 0;
   rar->br.avail_in = 0;
   rar->crc_calculated = 0;
   rar->entry_eof = 0;
   rar->valid = 1;
   rar->is_ppmd_block = 0;
   rar->start_new_table = 1;
   free(rar->unp_buffer);
   rar->unp_buffer = NULL;
   rar->unp_offset = 0;
   rar->unp_buffer_size = UNP_BUFFER_SIZE;
   memset(rar->lengthtable, 0, sizeof(rar->lengthtable));
   __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context);
   rar->ppmd_valid = rar->ppmd_eod = 0;
   if (head_type == NEWSUB_HEAD)
     return ret;
   archive_entry_set_mtime(entry, rar->mtime, rar->mnsec);
   archive_entry_set_ctime(entry, rar->ctime, rar->cnsec);
   archive_entry_set_atime(entry, rar->atime, rar->ansec);
   archive_entry_set_size(entry, rar->unp_size);
   archive_entry_set_mode(entry, rar->mode);
   if (archive_entry_copy_pathname_l(entry, filename, filename_size, fn_sconv))
   {
     if (errno == ENOMEM)
     {
       archive_set_error(&a->archive, ENOMEM,
                         ""Can't allocate memory for Pathname"");
       return (ARCHIVE_FATAL);
     }
     archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                       ""Pathname cannot be converted from %s to current locale."",
                       archive_string_conversion_charset_name(fn_sconv));
     ret = (ARCHIVE_WARN);
   }
   if (((rar->mode) & AE_IFMT) == AE_IFLNK)
   {
     rar->bytes_remaining = 0;
     archive_entry_set_size(entry, 0);
     if ((ret2 = read_symlink_stored(a, entry, sconv)) < (ARCHIVE_WARN))
       return ret2;
     if (ret > ret2)
       ret = ret2;
   }
   if (rar->bytes_remaining == 0)
     rar->entry_eof = 1;
   return ret;
 }","[270, 271, 272, 273, 274, 275]",libarchive version commit 416694915449219d505531b1096384f3237dd6cc onwards (release v3.1.0 onwards) contains a CWE-416: Use After Free vulnerability in RAR decoder - libarchive/archive_read_support_format_rar.c that can result in Crash/DoS - it is unknown if RCE is possible. This attack appear to be exploitable via the victim must open a specially crafted RAR archive.,libarchive,CVE-2018-1000878,CWE-416
3291,181918,"  int jas_stream_pad(jas_stream_t *stream, int n, int c)
  {
  	int m;
 	if (n < 0) {
 		jas_deprecated(""negative count for jas_stream_pad"");
 	}
  	m = n;
  	for (m = n; m > 0; --m) {
  		if (jas_stream_putc(stream, c) == EOF)
 			return n - m;
 	}
 	return n;
 }","[4, 5, 6]","Multiple integer overflows in the (1) jas_realloc function in base/jas_malloc.c and (2) mem_resize function in base/jas_stream.c in JasPer before 1.900.22 allow remote attackers to cause a denial of service via a crafted image, which triggers use after free vulnerabilities.",jasper,CVE-2016-9262,CWE-190
3316,178619," ProcDbeGetVisualInfo(ClientPtr client)
 {
     REQUEST(xDbeGetVisualInfoReq);
     DbeScreenPrivPtr pDbeScreenPriv;
     xDbeGetVisualInfoReply rep;
     Drawable *drawables;
     DrawablePtr *pDrawables = NULL;
     register int i, j, rc;
     register int count;          
     register int length;         
     ScreenPtr pScreen;
      XdbeScreenVisualInfo *pScrVisInfo;
      REQUEST_AT_LEAST_SIZE(xDbeGetVisualInfoReq);
     if (stuff->n > UINT32_MAX / sizeof(CARD32))
         return BadLength;
     REQUEST_FIXED_SIZE(xDbeGetVisualInfoReq, stuff->n * sizeof(CARD32));
      if (stuff->n > UINT32_MAX / sizeof(DrawablePtr))
          return BadAlloc;
             return BadAlloc;
         }","[14, 15, 16]",xorg-x11-server before 1.19.5 was vulnerable to integer overflow in ProcDbeGetVisualInfo function allowing malicious X client to cause X server to crash or possibly execute arbitrary code.,xserver,CVE-2017-12177,CWE-190
3329,181985," int m_authenticate(struct Client* cptr, struct Client* sptr, int parc, char* parv[])
 {
   struct Client* acptr;
   int first = 0;
   char realhost[HOSTLEN + 3];
   char *hoststr = (cli_sockhost(cptr) ? cli_sockhost(cptr) : cli_sock_ip(cptr));
   if (!CapActive(cptr, CAP_SASL))
     return 0;
   if (parc < 2)  
     return need_more_params(cptr, ""AUTHENTICATE"");
   if (strlen(parv[1]) > 400)
     return send_reply(cptr, ERR_SASLTOOLONG);
   if (IsSASLComplete(cptr))
     return send_reply(cptr, ERR_SASLALREADY);
   if (!(acptr = cli_saslagent(cptr))) {
     if (strcmp(feature_str(FEAT_SASL_SERVER), ""*""))
       acptr = find_match_server((char *)feature_str(FEAT_SASL_SERVER));
     else
       acptr = NULL;
   }
   if (!acptr && strcmp(feature_str(FEAT_SASL_SERVER), ""*""))
     return send_reply(cptr, ERR_SASLFAIL, "": service unavailable"");
   if (acptr && IsMe(acptr))
     return 0;
   if (!cli_saslcookie(cptr)) {
     do {
       cli_saslcookie(cptr) = ircrandom() & 0x7fffffff;
     } while (!cli_saslcookie(cptr));
     first = 1;
   }
   if (strchr(hoststr, ':') != NULL)
     ircd_snprintf(0, realhost, sizeof(realhost), ""[%s]"", hoststr);
   else
     ircd_strncpy(realhost, hoststr, sizeof(realhost));
    if (acptr) {
      if (first) {
       if (*parv[1] == ':' || strchr(parv[1], ' '))
 		return exit_client(cptr, sptr, sptr, ""Malformed AUTHENTICATE"");
        if (!EmptyString(cli_sslclifp(cptr)))
          sendcmdto_one(&me, CMD_SASL, acptr, ""%C %C!%u.%u S %s :%s"", acptr, &me,
                        cli_fd(cptr), cli_saslcookie(cptr),
                       parv[1], cli_sslclifp(cptr));
       else
         sendcmdto_one(&me, CMD_SASL, acptr, ""%C %C!%u.%u S :%s"", acptr, &me,
                       cli_fd(cptr), cli_saslcookie(cptr), parv[1]);
       if (feature_bool(FEAT_SASL_SENDHOST))
         sendcmdto_one(&me, CMD_SASL, acptr, ""%C %C!%u.%u H :%s@%s:%s"", acptr, &me,
                       cli_fd(cptr), cli_saslcookie(cptr), cli_username(cptr),
                       realhost, cli_sock_ip(cptr));
     } else {
       sendcmdto_one(&me, CMD_SASL, acptr, ""%C %C!%u.%u C :%s"", acptr, &me,
                     cli_fd(cptr), cli_saslcookie(cptr), parv[1]);
      }
    } else {
      if (first) {
       if (*parv[1] == ':' || strchr(parv[1], ' '))
         return exit_client(cptr, sptr, sptr, ""Malformed AUTHENTICATE"");
        if (!EmptyString(cli_sslclifp(cptr)))
          sendcmdto_serv_butone(&me, CMD_SASL, cptr, ""* %C!%u.%u S %s :%s"", &me,
                                cli_fd(cptr), cli_saslcookie(cptr),
                               parv[1], cli_sslclifp(cptr));
       else
         sendcmdto_serv_butone(&me, CMD_SASL, cptr, ""* %C!%u.%u S :%s"", &me,
                               cli_fd(cptr), cli_saslcookie(cptr), parv[1]);
       if (feature_bool(FEAT_SASL_SENDHOST))
         sendcmdto_serv_butone(&me, CMD_SASL, cptr, ""* %C!%u.%u H :%s@%s:%s"", &me,
                               cli_fd(cptr), cli_saslcookie(cptr), cli_username(cptr),
                               realhost, cli_sock_ip(cptr));
     } else {
       sendcmdto_serv_butone(&me, CMD_SASL, cptr, ""* %C!%u.%u C :%s"", &me,
                             cli_fd(cptr), cli_saslcookie(cptr), parv[1]);
     }
   }
   if (!t_active(&cli_sasltimeout(cptr)))
     timer_add(timer_init(&cli_sasltimeout(cptr)), sasl_timeout_callback, (void*) cptr,
               TT_RELATIVE, feature_int(FEAT_SASL_TIMEOUT));
   return 0;
 }","[37, 38, 56, 57]",The m_authenticate function in ircd/m_authenticate.c in nefarious2 allows remote attackers to spoof certificate fingerprints and consequently log in as another user via a crafted AUTHENTICATE parameter.,nefarious2,CVE-2016-7145,CWE-287
3333,182381," NO_INLINE JsVar *jspeFactor() {
   if (lex->tk==LEX_ID) {
     JsVar *a = jspGetNamedVariable(jslGetTokenValueAsString(lex));
     JSP_ASSERT_MATCH(LEX_ID);
 #ifndef SAVE_ON_FLASH
     if (lex->tk==LEX_TEMPLATE_LITERAL)
       jsExceptionHere(JSET_SYNTAXERROR, ""Tagged template literals not supported"");
     else if (lex->tk==LEX_ARROW_FUNCTION && jsvIsName(a)) {
       JsVar *funcVar = jspeArrowFunction(0,a);
       jsvUnLock(a);
       a=funcVar;
     }
 #endif
     return a;
   } else if (lex->tk==LEX_INT) {
     JsVar *v = 0;
     if (JSP_SHOULD_EXECUTE) {
       v = jsvNewFromLongInteger(stringToInt(jslGetTokenValueAsString(lex)));
     }
     JSP_ASSERT_MATCH(LEX_INT);
     return v;
   } else if (lex->tk==LEX_FLOAT) {
     JsVar *v = 0;
     if (JSP_SHOULD_EXECUTE) {
       v = jsvNewFromFloat(stringToFloat(jslGetTokenValueAsString(lex)));
     }
     JSP_ASSERT_MATCH(LEX_FLOAT);
     return v;
   } else if (lex->tk=='(') {
     JSP_ASSERT_MATCH('(');
     if (!jspCheckStackPosition()) return 0;
 #ifdef SAVE_ON_FLASH
     JsVar *a = jspeExpression();
     if (!JSP_SHOULDNT_PARSE) JSP_MATCH_WITH_RETURN(')',a);
     return a;
 #else
     return jspeExpressionOrArrowFunction();
 #endif
   } else if (lex->tk==LEX_R_TRUE) {
     JSP_ASSERT_MATCH(LEX_R_TRUE);
     return JSP_SHOULD_EXECUTE ? jsvNewFromBool(true) : 0;
   } else if (lex->tk==LEX_R_FALSE) {
     JSP_ASSERT_MATCH(LEX_R_FALSE);
     return JSP_SHOULD_EXECUTE ? jsvNewFromBool(false) : 0;
   } else if (lex->tk==LEX_R_NULL) {
     JSP_ASSERT_MATCH(LEX_R_NULL);
     return JSP_SHOULD_EXECUTE ? jsvNewWithFlags(JSV_NULL) : 0;
   } else if (lex->tk==LEX_R_UNDEFINED) {
     JSP_ASSERT_MATCH(LEX_R_UNDEFINED);
     return 0;
   } else if (lex->tk==LEX_STR) {
     JsVar *a = 0;
     if (JSP_SHOULD_EXECUTE)
       a = jslGetTokenValueAsVar(lex);
     JSP_ASSERT_MATCH(LEX_STR);
     return a;
 #ifndef SAVE_ON_FLASH
   } else if (lex->tk==LEX_TEMPLATE_LITERAL) {
     return jspeTemplateLiteral();
 #endif
   } else if (lex->tk==LEX_REGEX) {
     JsVar *a = 0;
 #ifdef SAVE_ON_FLASH
     jsExceptionHere(JSET_SYNTAXERROR, ""RegEx are not supported in this version of Espruino\n"");
 #else
     JsVar *regex = jslGetTokenValueAsVar(lex);
     size_t regexEnd = 0, regexLen = 0;
     JsvStringIterator it;
     jsvStringIteratorNew(&it, regex, 0);
     while (jsvStringIteratorHasChar(&it)) {
       regexLen++;
       if (jsvStringIteratorGetChar(&it)=='/')
         regexEnd = regexLen;
       jsvStringIteratorNext(&it);
     }
     jsvStringIteratorFree(&it);
     JsVar *flags = 0;
     if (regexEnd < regexLen)
       flags = jsvNewFromStringVar(regex, regexEnd, JSVAPPENDSTRINGVAR_MAXLENGTH);
     JsVar *regexSource = jsvNewFromStringVar(regex, 1, regexEnd-2);
     a = jswrap_regexp_constructor(regexSource, flags);
     jsvUnLock3(regex, flags, regexSource);
 #endif
     JSP_ASSERT_MATCH(LEX_REGEX);
     return a;
   } else if (lex->tk=='{') {
     if (!jspCheckStackPosition()) return 0;
     return jspeFactorObject();
   } else if (lex->tk=='[') {
     if (!jspCheckStackPosition()) return 0;
     return jspeFactorArray();
   } else if (lex->tk==LEX_R_FUNCTION) {
     if (!jspCheckStackPosition()) return 0;
     JSP_ASSERT_MATCH(LEX_R_FUNCTION);
     return jspeFunctionDefinition(true);
 #ifndef SAVE_ON_FLASH
   } else if (lex->tk==LEX_R_CLASS) {
     if (!jspCheckStackPosition()) return 0;
     JSP_ASSERT_MATCH(LEX_R_CLASS);
     return jspeClassDefinition(true);
   } else if (lex->tk==LEX_R_SUPER) {
     JSP_ASSERT_MATCH(LEX_R_SUPER);
     if (jsvIsObject(execInfo.thisVar)) {
       JsVar *proto1 = jsvObjectGetChild(execInfo.thisVar, JSPARSE_INHERITS_VAR, 0);  
       JsVar *proto2 = jsvIsObject(proto1) ? jsvObjectGetChild(proto1, JSPARSE_INHERITS_VAR, 0) : 0;  
       jsvUnLock(proto1);
       if (!proto2) {
         jsExceptionHere(JSET_SYNTAXERROR, ""Calling 'super' outside of class"");
         return 0;
       }
       if (lex->tk=='(') return proto2;  
       JsVar *proto3 = jsvIsFunction(proto2) ? jsvObjectGetChild(proto2, JSPARSE_PROTOTYPE_VAR, 0) : 0;
       jsvUnLock(proto2);
       return proto3;
     } else if (jsvIsFunction(execInfo.thisVar)) {
       JsVar *proto1 = jsvObjectGetChild(execInfo.thisVar, JSPARSE_PROTOTYPE_VAR, 0);
       JsVar *proto2 = jsvIsObject(proto1) ? jsvObjectGetChild(proto1, JSPARSE_INHERITS_VAR, 0) : 0;
       jsvUnLock(proto1);
       if (!proto2) {
         jsExceptionHere(JSET_SYNTAXERROR, ""Calling 'super' outside of class"");
         return 0;
       }
       return proto2;
     }
     jsExceptionHere(JSET_SYNTAXERROR, ""Calling 'super' outside of class"");
     return 0;
 #endif
   } else if (lex->tk==LEX_R_THIS) {
     JSP_ASSERT_MATCH(LEX_R_THIS);
     return jsvLockAgain( execInfo.thisVar ? execInfo.thisVar : execInfo.root );
   } else if (lex->tk==LEX_R_DELETE) {
     if (!jspCheckStackPosition()) return 0;
     return jspeFactorDelete();
   } else if (lex->tk==LEX_R_TYPEOF) {
     if (!jspCheckStackPosition()) return 0;
     return jspeFactorTypeOf();
   } else if (lex->tk==LEX_R_VOID) {
     if (!jspCheckStackPosition()) return 0;
     JSP_ASSERT_MATCH(LEX_R_VOID);
     jsvUnLock(jspeUnaryExpression());
     return 0;
   }
   JSP_MATCH(LEX_EOF);
   jsExceptionHere(JSET_SYNTAXERROR, ""Unexpected end of Input\n"");
   return 0;
 }
 NO_INLINE JsVar *__jspePostfixExpression(JsVar *a) {
   while (lex->tk==LEX_PLUSPLUS || lex->tk==LEX_MINUSMINUS) {
     int op = lex->tk;
     JSP_ASSERT_MATCH(op);
     if (JSP_SHOULD_EXECUTE) {
       JsVar *one = jsvNewFromInteger(1);
       JsVar *oldValue = jsvAsNumberAndUnLock(jsvSkipName(a));  
       JsVar *res = jsvMathsOpSkipNames(oldValue, one, op==LEX_PLUSPLUS ? '+' : '-');
       jsvUnLock(one);
       jspReplaceWith(a, res);
       jsvUnLock(res);
       jsvUnLock(a);
       a = oldValue;
     }
   }
   return a;
 }
 NO_INLINE JsVar *jspePostfixExpression() {
   JsVar *a;
   if (lex->tk==LEX_PLUSPLUS || lex->tk==LEX_MINUSMINUS) {
     int op = lex->tk;
     JSP_ASSERT_MATCH(op);
     a = jspePostfixExpression();
     if (JSP_SHOULD_EXECUTE) {
       JsVar *one = jsvNewFromInteger(1);
       JsVar *res = jsvMathsOpSkipNames(a, one, op==LEX_PLUSPLUS ? '+' : '-');
       jsvUnLock(one);
       jspReplaceWith(a, res);
       jsvUnLock(res);
     }
   } else
     a = jspeFactorFunctionCall();
   return __jspePostfixExpression(a);
 }
 NO_INLINE JsVar *jspeUnaryExpression() {
   if (lex->tk=='!' || lex->tk=='~' || lex->tk=='-' || lex->tk=='+') {
     short tk = lex->tk;
     JSP_ASSERT_MATCH(tk);
     if (!JSP_SHOULD_EXECUTE) {
       return jspeUnaryExpression();
     }
     if (tk=='!') {  
       return jsvNewFromBool(!jsvGetBoolAndUnLock(jsvSkipNameAndUnLock(jspeUnaryExpression())));
     } else if (tk=='~') {  
       return jsvNewFromInteger(~jsvGetIntegerAndUnLock(jsvSkipNameAndUnLock(jspeUnaryExpression())));
     } else if (tk=='-') {  
       return jsvNegateAndUnLock(jspeUnaryExpression());  
     }  else if (tk=='+') {  
       JsVar *v = jsvSkipNameAndUnLock(jspeUnaryExpression());
       JsVar *r = jsvAsNumber(v);  
       jsvUnLock(v);
       return r;
     }
     assert(0);
     return 0;
   } else
     return jspePostfixExpression();
 }
 unsigned int jspeGetBinaryExpressionPrecedence(int op) {
   switch (op) {
   case LEX_OROR: return 1; break;
   case LEX_ANDAND: return 2; break;
   case '|' : return 3; break;
   case '^' : return 4; break;
   case '&' : return 5; break;
   case LEX_EQUAL:
   case LEX_NEQUAL:
   case LEX_TYPEEQUAL:
   case LEX_NTYPEEQUAL: return 6;
   case LEX_LEQUAL:
   case LEX_GEQUAL:
   case '<':
   case '>':
   case LEX_R_INSTANCEOF: return 7;
   case LEX_R_IN: return (execInfo.execute&EXEC_FOR_INIT)?0:7;
   case LEX_LSHIFT:
   case LEX_RSHIFT:
   case LEX_RSHIFTUNSIGNED: return 8;
   case '+':
   case '-': return 9;
   case '*':
   case '/':
   case '%': return 10;
   default: return 0;
   }
 }
 NO_INLINE JsVar *__jspeBinaryExpression(JsVar *a, unsigned int lastPrecedence) {
   unsigned int precedence = jspeGetBinaryExpressionPrecedence(lex->tk);
   while (precedence && precedence>lastPrecedence) {
     int op = lex->tk;
     JSP_ASSERT_MATCH(op);
     if (op==LEX_ANDAND || op==LEX_OROR) {
       bool aValue = jsvGetBoolAndUnLock(jsvSkipName(a));
       if ((!aValue && op==LEX_ANDAND) ||
           (aValue && op==LEX_OROR)) {
         JSP_SAVE_EXECUTE();
         jspSetNoExecute();
         jsvUnLock(__jspeBinaryExpression(jspeUnaryExpression(),precedence));
         JSP_RESTORE_EXECUTE();
       } else {
         jsvUnLock(a);
         a = __jspeBinaryExpression(jspeUnaryExpression(),precedence);
       }
     } else {  
       JsVar *b = __jspeBinaryExpression(jspeUnaryExpression(),precedence);
       if (JSP_SHOULD_EXECUTE) {
         if (op==LEX_R_IN) {
           JsVar *av = jsvSkipName(a);  
           JsVar *bv = jsvSkipName(b);  
           if (jsvIsArray(bv) || jsvIsObject(bv)) {  
             av = jsvAsArrayIndexAndUnLock(av);
             JsVar *varFound = jspGetVarNamedField( bv, av, true);
             jsvUnLock(a);
             a = jsvNewFromBool(varFound!=0);
             jsvUnLock(varFound);
           } else { 
             jsExceptionHere(JSET_ERROR, ""Cannot use 'in' operator to search a %t"", bv);
             jsvUnLock(a);
             a = 0;
           }
           jsvUnLock2(av, bv);
         } else if (op==LEX_R_INSTANCEOF) {
           bool inst = false;
           JsVar *av = jsvSkipName(a);
           JsVar *bv = jsvSkipName(b);
           if (!jsvIsFunction(bv)) {
             jsExceptionHere(JSET_ERROR, ""Expecting a function on RHS in instanceof check, got %t"", bv);
           } else {
             if (jsvIsObject(av) || jsvIsFunction(av)) {
               JsVar *bproto = jspGetNamedField(bv, JSPARSE_PROTOTYPE_VAR, false);
               JsVar *proto = jsvObjectGetChild(av, JSPARSE_INHERITS_VAR, 0);
               while (proto) {
                 if (proto == bproto) inst=true;
                 JsVar *childProto = jsvObjectGetChild(proto, JSPARSE_INHERITS_VAR, 0);
                 jsvUnLock(proto);
                 proto = childProto;
               }
               if (jspIsConstructor(bv, ""Object"")) inst = true;
               jsvUnLock(bproto);
             }
             if (!inst) {
               const char *name = jswGetBasicObjectName(av);
               if (name) {
                 inst = jspIsConstructor(bv, name);
               }
               if (!inst && (jsvIsArray(av) || jsvIsArrayBuffer(av)) &&
                   jspIsConstructor(bv, ""Object""))
                 inst = true;
             }
           }
           jsvUnLock3(av, bv, a);
           a = jsvNewFromBool(inst);
         } else {   
           JsVar *res = jsvMathsOpSkipNames(a, b, op);
           jsvUnLock(a); a = res;
         }
       }
       jsvUnLock(b);
     }
     precedence = jspeGetBinaryExpressionPrecedence(lex->tk);
   }
   return a;
 }
 JsVar *jspeBinaryExpression() {
   return __jspeBinaryExpression(jspeUnaryExpression(),0);
 }
 NO_INLINE JsVar *__jspeConditionalExpression(JsVar *lhs) {
   if (lex->tk=='?') {
     JSP_ASSERT_MATCH('?');
     if (!JSP_SHOULD_EXECUTE) {
       jsvUnLock(jspeAssignmentExpression());
       JSP_MATCH(':');
       jsvUnLock(jspeAssignmentExpression());
     } else {
       bool first = jsvGetBoolAndUnLock(jsvSkipName(lhs));
       jsvUnLock(lhs);
       if (first) {
         lhs = jspeAssignmentExpression();
         JSP_MATCH(':');
         JSP_SAVE_EXECUTE();
         jspSetNoExecute();
         jsvUnLock(jspeAssignmentExpression());
         JSP_RESTORE_EXECUTE();
       } else {
         JSP_SAVE_EXECUTE();
         jspSetNoExecute();
         jsvUnLock(jspeAssignmentExpression());
         JSP_RESTORE_EXECUTE();
         JSP_MATCH(':');
         lhs = jspeAssignmentExpression();
       }
     }
   }
   return lhs;
 }
 JsVar *jspeConditionalExpression() {
   return __jspeConditionalExpression(jspeBinaryExpression());
 }
 NO_INLINE JsVar *__jspeAssignmentExpression(JsVar *lhs) {
   if (lex->tk=='=' || lex->tk==LEX_PLUSEQUAL || lex->tk==LEX_MINUSEQUAL ||
       lex->tk==LEX_MULEQUAL || lex->tk==LEX_DIVEQUAL || lex->tk==LEX_MODEQUAL ||
       lex->tk==LEX_ANDEQUAL || lex->tk==LEX_OREQUAL ||
       lex->tk==LEX_XOREQUAL || lex->tk==LEX_RSHIFTEQUAL ||
       lex->tk==LEX_LSHIFTEQUAL || lex->tk==LEX_RSHIFTUNSIGNEDEQUAL) {
     JsVar *rhs;
     int op = lex->tk;
     JSP_ASSERT_MATCH(op);
     rhs = jspeAssignmentExpression();
     rhs = jsvSkipNameAndUnLock(rhs);  
      if (JSP_SHOULD_EXECUTE && lhs) {
        if (op=='=') {
        if (!jsvGetRefs(lhs) && jsvIsName(lhs)) {
          if (!jsvIsArrayBufferName(lhs) && !jsvIsNewChild(lhs))
            jsvAddName(execInfo.root, lhs);
        }
        jspReplaceWith(lhs, rhs);
         jspReplaceWithOrAddToRoot(lhs, rhs);
        } else {
          if (op==LEX_PLUSEQUAL) op='+';
          else if (op==LEX_MINUSEQUAL) op='-';
         else if (op==LEX_MULEQUAL) op='*';
         else if (op==LEX_DIVEQUAL) op='/';
         else if (op==LEX_MODEQUAL) op='%';
         else if (op==LEX_ANDEQUAL) op='&';
         else if (op==LEX_OREQUAL) op='|';
         else if (op==LEX_XOREQUAL) op='^';
         else if (op==LEX_RSHIFTEQUAL) op=LEX_RSHIFT;
         else if (op==LEX_LSHIFTEQUAL) op=LEX_LSHIFT;
         else if (op==LEX_RSHIFTUNSIGNEDEQUAL) op=LEX_RSHIFTUNSIGNED;
         if (op=='+' && jsvIsName(lhs)) {
           JsVar *currentValue = jsvSkipName(lhs);
           if (jsvIsString(currentValue) && !jsvIsFlatString(currentValue) && jsvGetRefs(currentValue)==1 && rhs!=currentValue) {
             JsVar *str = jsvAsString(rhs, false);
             jsvAppendStringVarComplete(currentValue, str);
             jsvUnLock(str);
             op = 0;
           }
           jsvUnLock(currentValue);
         }
         if (op) {
           JsVar *res = jsvMathsOpSkipNames(lhs,rhs,op);
           jspReplaceWith(lhs, res);
           jsvUnLock(res);
         }
       }
     }
     jsvUnLock(rhs);
   }
   return lhs;
 }
 JsVar *jspeAssignmentExpression() {
   return __jspeAssignmentExpression(jspeConditionalExpression());
 }
 NO_INLINE JsVar *jspeExpression() {
   while (!JSP_SHOULDNT_PARSE) {
     JsVar *a = jspeAssignmentExpression();
     if (lex->tk!=',') return a;
     jsvCheckReferenceError(a);
     jsvUnLock(a);
     JSP_ASSERT_MATCH(',');
   }
   return 0;
 }
 NO_INLINE void jspeBlockNoBrackets() {
   if (JSP_SHOULD_EXECUTE) {
     while (lex->tk && lex->tk!='}') {
       JsVar *a = jspeStatement();
       jsvCheckReferenceError(a);
       jsvUnLock(a);
       if (JSP_HAS_ERROR) {
         if (lex && !(execInfo.execute&EXEC_ERROR_LINE_REPORTED)) {
           execInfo.execute = (JsExecFlags)(execInfo.execute | EXEC_ERROR_LINE_REPORTED);
           JsVar *stackTrace = jsvObjectGetChild(execInfo.hiddenRoot, JSPARSE_STACKTRACE_VAR, JSV_STRING_0);
           if (stackTrace) {
             jsvAppendPrintf(stackTrace, ""at "");
             jspAppendStackTrace(stackTrace);
             jsvUnLock(stackTrace);
           }
         }
       }
       if (JSP_SHOULDNT_PARSE)
         return;
     }
   } else {
     int brackets = 0;
     while (lex->tk && (brackets || lex->tk != '}')) {
       if (lex->tk == '{') brackets++;
       if (lex->tk == '}') brackets--;
       JSP_ASSERT_MATCH(lex->tk);
     }
   }","[358, 359, 360, 361, 362, 363]",Espruino before 1.99 allows attackers to cause a denial of service (application crash) and a potential Information Disclosure with user crafted input files via a Buffer Overflow or Out-of-bounds Read during syntax parsing of certain for loops in jsparse.c.,Espruino,CVE-2018-11598,CWE-125
3356,181919," int jas_stream_read(jas_stream_t *stream, void *buf, int cnt)
 {
 	int n;
  	int c;
  	char *bufptr;
 	if (cnt < 0) {
 		jas_deprecated(""negative count for jas_stream_read"");
 	}
  	bufptr = buf;
  	n = 0;
 	while (n < cnt) {
 		if ((c = jas_stream_getc(stream)) == EOF) {
 			return n;
 		}
 		*bufptr++ = c;
 		++n;
 	}
 	return n;
 }","[6, 7, 8]","Multiple integer overflows in the (1) jas_realloc function in base/jas_malloc.c and (2) mem_resize function in base/jas_stream.c in JasPer before 1.900.22 allow remote attackers to cause a denial of service via a crafted image, which triggers use after free vulnerabilities.",jasper,CVE-2016-9262,CWE-190
3367,181248," static uint32_t color_string_to_rgba(const char *p, int len)
 {
     uint32_t ret = 0xFF000000;
      const ColorEntry *entry;
      char color_name[100];
     len = FFMIN(FFMAX(len, 0), sizeof(color_name) - 1);
      if (*p == '#') {
          p++;
          len--;
         if (len == 3) {
             ret |= (hex_char_to_number(p[2]) <<  4) |
                    (hex_char_to_number(p[1]) << 12) |
                    (hex_char_to_number(p[0]) << 20);
         } else if (len == 4) {
             ret  = (hex_char_to_number(p[3]) <<  4) |
                    (hex_char_to_number(p[2]) << 12) |
                    (hex_char_to_number(p[1]) << 20) |
                    (hex_char_to_number(p[0]) << 28);
         } else if (len == 6) {
             ret |=  hex_char_to_number(p[5])        |
                    (hex_char_to_number(p[4]) <<  4) |
                    (hex_char_to_number(p[3]) <<  8) |
                    (hex_char_to_number(p[2]) << 12) |
                    (hex_char_to_number(p[1]) << 16) |
                    (hex_char_to_number(p[0]) << 20);
         } else if (len == 8) {
             ret  =  hex_char_to_number(p[7])        |
                    (hex_char_to_number(p[6]) <<  4) |
                    (hex_char_to_number(p[5]) <<  8) |
                    (hex_char_to_number(p[4]) << 12) |
                    (hex_char_to_number(p[3]) << 16) |
                    (hex_char_to_number(p[2]) << 20) |
                    (hex_char_to_number(p[1]) << 24) |
                    (hex_char_to_number(p[0]) << 28);
         }
     } else {
         strncpy(color_name, p, len);
         color_name[len] = '\0';
         entry = bsearch(color_name,
                         color_table,
                         FF_ARRAY_ELEMS(color_table),
                         sizeof(ColorEntry),
                         color_table_compare);
         if (!entry)
             return ret;
         ret = entry->rgb_color;
     }
     return ret;
 }",[6],Stack-based buffer overflow in the color_string_to_rgba function in libavcodec/xpmdec.c in FFmpeg 3.3 before 3.3.1 allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted file.,FFmpeg,CVE-2017-9990,CWE-119
3373,182976," rdp_in_unistr(STREAM s, int in_len, char **string, uint32 * str_size)
 {
 	static iconv_t icv_utf16_to_local;
  	size_t ibl, obl;
  	char *pin, *pout;
 	struct stream packet = *s;
 	if ((in_len < 0) || ((uint32)in_len >= (RD_UINT32_MAX / 2)))
 	{
 		logger(Protocol, Error, ""rdp_in_unistr(), length of unicode data is out of bounds."");
 		abort();
 	}
 	if (!s_check_rem(s, in_len))
 	{
 		rdp_protocol_error(""rdp_in_unistr(), consume of unicode data from stream would overrun"", &packet);
 	}
  	if (!icv_utf16_to_local)
  	{
 		icv_utf16_to_local = iconv_open(g_codepage, WINDOWS_CODEPAGE);
 		if (icv_utf16_to_local == (iconv_t) - 1)
 		{
 			logger(Protocol, Error, ""rdp_in_unistr(), iconv_open[%s -> %s] fail %p"",
 			       WINDOWS_CODEPAGE, g_codepage, icv_utf16_to_local);
 			abort();
 		}
 	}
 	if (*string == NULL)
 	{
 		*string = xmalloc(in_len * 2);
 		*str_size = in_len * 2;
 	}
 	ibl = in_len;
 	obl = *str_size - 1;
 	pin = (char *) s->p;
 	pout = *string;
 	if (iconv(icv_utf16_to_local, (char **) &pin, &ibl, &pout, &obl) == (size_t) - 1)
 	{
 		if (errno == E2BIG)
 		{
 			logger(Protocol, Warning,
 			       ""rdp_in_unistr(), server sent an unexpectedly long string, truncating"");
 		}
 		else
 		{
 			logger(Protocol, Warning, ""rdp_in_unistr(), iconv fail, errno %d"", errno);
 			free(*string);
 			*string = NULL;
 			*str_size = 0;
 		}
 		abort();
 	}
 	s->p += in_len;
 	*pout = 0;
 	if (*string)
 		*str_size = pout - *string;
 }","[6, 7, 8, 9, 10, 11, 12, 13, 14, 15]",rdesktop versions up to and including v1.8.3 contain a Buffer Overflow over the global variables in the function seamless_process_line() that results in memory corruption and probably even a remote code execution.,rdesktop,CVE-2018-20182,CWE-119
3400,182101," archive_acl_from_text_l(struct archive_acl *acl, const char *text,
     int want_type, struct archive_string_conv *sc)
 {
 	struct {
 		const char *start;
 		const char *end;
 	} field[6], name;
 	const char *s, *st;
 	int numfields, fields, n, r, sol, ret;
 	int type, types, tag, permset, id;
 	size_t len;
 	char sep;
 	switch (want_type) {
 	case ARCHIVE_ENTRY_ACL_TYPE_POSIX1E:
 		want_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;
 		__LA_FALLTHROUGH;
 	case ARCHIVE_ENTRY_ACL_TYPE_ACCESS:
 	case ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:
 		numfields = 5;
 		break;
 	case ARCHIVE_ENTRY_ACL_TYPE_NFS4:
 		numfields = 6;
 		break;
 	default:
 		return (ARCHIVE_FATAL);
 	}
 	ret = ARCHIVE_OK;
 	types = 0;
 	while (text != NULL &&  *text != '\0') {
 		fields = 0;
 		do {
 			const char *start, *end;
 			next_field(&text, &start, &end, &sep);
 			if (fields < numfields) {
 				field[fields].start = start;
 				field[fields].end = end;
 			}
 			++fields;
 		} while (sep == ':');
 		for (n = fields; n < numfields; ++n)
 			field[n].start = field[n].end = NULL;
 		if (field[0].start != NULL && *(field[0].start) == '#') {
 			continue;
 		}
 		n = 0;
 		sol = 0;
 		id = -1;
 		permset = 0;
 		name.start = name.end = NULL;
 		if (want_type != ARCHIVE_ENTRY_ACL_TYPE_NFS4) {
 			s = field[0].start;
 			len = field[0].end - field[0].start;
 			if (*s == 'd' && (len == 1 || (len >= 7
 			    && memcmp((s + 1), ""efault"", 6) == 0))) {
 				type = ARCHIVE_ENTRY_ACL_TYPE_DEFAULT;
 				if (len > 7)
 					field[0].start += 7;
 				else
 					n = 1;
 			} else
 				type = want_type;
 			isint(field[n + 1].start, field[n + 1].end, &id);
 			if (id == -1 && fields > (n + 3))
 				isint(field[n + 3].start, field[n + 3].end,
 				    &id);
 			tag = 0;
 			s = field[n].start;
  			st = field[n].start + 1;
  			len = field[n].end - field[n].start;
 			if (len == 0) {
 				ret = ARCHIVE_WARN;
 				continue;
 			}
  			switch (*s) {
  			case 'u':
  				if (len == 1 || (len == 4
 				    && memcmp(st, ""ser"", 3) == 0))
 					tag = ARCHIVE_ENTRY_ACL_USER_OBJ;
 				break;
 			case 'g':
 				if (len == 1 || (len == 5
 				    && memcmp(st, ""roup"", 4) == 0))
 					tag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;
 				break;
 			case 'o':
 				if (len == 1 || (len == 5
 				    && memcmp(st, ""ther"", 4) == 0))
 					tag = ARCHIVE_ENTRY_ACL_OTHER;
 				break;
 			case 'm':
 				if (len == 1 || (len == 4
 				    && memcmp(st, ""ask"", 3) == 0))
 					tag = ARCHIVE_ENTRY_ACL_MASK;
 				break;
 			default:
 					break;
 			}
 			switch (tag) {
 			case ARCHIVE_ENTRY_ACL_OTHER:
 			case ARCHIVE_ENTRY_ACL_MASK:
 				if (fields == (n + 2)
 				    && field[n + 1].start < field[n + 1].end
 				    && ismode(field[n + 1].start,
 				    field[n + 1].end, &permset)) {
 					sol = 1;
 				} else if (fields == (n + 3) &&
 				    field[n + 1].start < field[n + 1].end) {
 					ret = ARCHIVE_WARN;
 					continue;
 				}
 				break;
 			case ARCHIVE_ENTRY_ACL_USER_OBJ:
 			case ARCHIVE_ENTRY_ACL_GROUP_OBJ:
 				if (id != -1 ||
 				    field[n + 1].start < field[n + 1].end) {
 					name = field[n + 1];
 					if (tag == ARCHIVE_ENTRY_ACL_USER_OBJ)
 						tag = ARCHIVE_ENTRY_ACL_USER;
 					else
 						tag = ARCHIVE_ENTRY_ACL_GROUP;
 				}
 				break;
 			default:
 				ret = ARCHIVE_WARN;
 				continue;
 			}
 			if (permset == 0 && !ismode(field[n + 2 - sol].start,
 			    field[n + 2 - sol].end, &permset)) {
 				ret = ARCHIVE_WARN;
 				continue;
 			}
 		} else {
 			s = field[0].start;
 			len = field[0].end - field[0].start;
 			tag = 0;
 			switch (len) {
 			case 4:
 				if (memcmp(s, ""user"", 4) == 0)
 					tag = ARCHIVE_ENTRY_ACL_USER;
 				break;
 			case 5:
 				if (memcmp(s, ""group"", 5) == 0)
 					tag = ARCHIVE_ENTRY_ACL_GROUP;
 				break;
 			case 6:
 				if (memcmp(s, ""owner@"", 6) == 0)
 					tag = ARCHIVE_ENTRY_ACL_USER_OBJ;
 				else if (memcmp(s, ""group@"", 6) == 0)
 					tag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;
 				break;
 			case 9:
 				if (memcmp(s, ""everyone@"", 9) == 0)
 					tag = ARCHIVE_ENTRY_ACL_EVERYONE;
 				break;
 			default:
 				break;
 			}
 			if (tag == 0) {
 				ret = ARCHIVE_WARN;
 				continue;
 			} else if (tag == ARCHIVE_ENTRY_ACL_USER ||
 			    tag == ARCHIVE_ENTRY_ACL_GROUP) {
 				n = 1;
 				name = field[1];
 				isint(name.start, name.end, &id);
 			} else
 				n = 0;
 			if (!is_nfs4_perms(field[1 + n].start,
 			    field[1 + n].end, &permset)) {
 				ret = ARCHIVE_WARN;
 				continue;
 			}
 			if (!is_nfs4_flags(field[2 + n].start,
 			    field[2 + n].end, &permset)) {
 				ret = ARCHIVE_WARN;
 				continue;
 			}
 			s = field[3 + n].start;
 			len = field[3 + n].end - field[3 + n].start;
 			type = 0;
 			if (len == 4) {
 				if (memcmp(s, ""deny"", 4) == 0)
 					type = ARCHIVE_ENTRY_ACL_TYPE_DENY;
 			} else if (len == 5) {
 				if (memcmp(s, ""allow"", 5) == 0)
 					type = ARCHIVE_ENTRY_ACL_TYPE_ALLOW;
 				else if (memcmp(s, ""audit"", 5) == 0)
 					type = ARCHIVE_ENTRY_ACL_TYPE_AUDIT;
 				else if (memcmp(s, ""alarm"", 5) == 0)
 					type = ARCHIVE_ENTRY_ACL_TYPE_ALARM;
 			}
 			if (type == 0) {
 				ret = ARCHIVE_WARN;
 				continue;
 			}
 			isint(field[4 + n].start, field[4 + n].end,
 			    &id);
 		}
 		r = archive_acl_add_entry_len_l(acl, type, permset,
 		    tag, id, name.start, name.end - name.start, sc);
 		if (r < ARCHIVE_WARN)
 			return (r);
 		if (r != ARCHIVE_OK)
 			ret = ARCHIVE_WARN;
 		types |= type;
 	}
 	archive_acl_reset(acl, types);
 	return (ret);
 }","[70, 71, 72, 73]","libarchive version commit 379867ecb330b3a952fb7bfa7bffb7bbd5547205 onwards (release v3.3.0 onwards) contains a CWE-476: NULL Pointer Dereference vulnerability in ACL parser - libarchive/archive_acl.c, archive_acl_from_text_l() that can result in Crash/DoS. This attack appear to be exploitable via the victim must open a specially crafted archive file.",libarchive,CVE-2018-1000879,CWE-476
3407,182059," tChecksumCheckResult ParaNdis_CheckRxChecksum(
                                             PARANDIS_ADAPTER *pContext,
                                             ULONG virtioFlags,
                                             tCompletePhysicalAddress *pPacketPages,
                                             ULONG ulPacketLength,
                                              ULONG ulDataOffset)
  {
      tOffloadSettingsFlags f = pContext->Offload.flags;
    tChecksumCheckResult res, resIp;
     tChecksumCheckResult res;
      tTcpIpPacketParsingResult ppr;
      ULONG flagsToCalculate = 0;
      res.value = 0;
    resIp.value = 0;
     if (f.fRxIPChecksum) flagsToCalculate |= pcrIpChecksum;  
     if (!(virtioFlags & VIRTIO_NET_HDR_F_DATA_VALID))
     {
         if (virtioFlags & VIRTIO_NET_HDR_F_NEEDS_CSUM)
         {
             flagsToCalculate |= pcrFixXxpChecksum | pcrTcpChecksum | pcrUdpChecksum;
         }
         else
         {
             if (f.fRxTCPChecksum) flagsToCalculate |= pcrTcpV4Checksum;
             if (f.fRxUDPChecksum) flagsToCalculate |= pcrUdpV4Checksum;
             if (f.fRxTCPv6Checksum) flagsToCalculate |= pcrTcpV6Checksum;
             if (f.fRxUDPv6Checksum) flagsToCalculate |= pcrUdpV6Checksum;
         }
     }
      ppr = ParaNdis_CheckSumVerify(pPacketPages, ulPacketLength - ETH_HEADER_SIZE, ulDataOffset + ETH_HEADER_SIZE, flagsToCalculate, __FUNCTION__);
     if (ppr.ipCheckSum == ppresIPTooShort || ppr.xxpStatus == ppresXxpIncomplete)
     {
         res.flags.IpOK = FALSE;
         res.flags.IpFailed = TRUE;
         return res;
     }
      if (virtioFlags & VIRTIO_NET_HDR_F_DATA_VALID)
      {
          pContext->extraStatistics.framesRxCSHwOK++;
         ppr.xxpCheckSum = ppresCSOK;
     }
     if (ppr.ipStatus == ppresIPV4 && !ppr.IsFragment)
     {
         if (f.fRxIPChecksum)
         {
             res.flags.IpOK =  ppr.ipCheckSum == ppresCSOK;
             res.flags.IpFailed = ppr.ipCheckSum == ppresCSBad;
         }
         if(ppr.xxpStatus == ppresXxpKnown)
         {
             if(ppr.TcpUdp == ppresIsTCP)  
             {
                 if (f.fRxTCPChecksum)
                 {
                     res.flags.TcpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS;
                     res.flags.TcpFailed = !res.flags.TcpOK;
                 }
             }
             else  
             {
                 if (f.fRxUDPChecksum)
                 {
                     res.flags.UdpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS;
                     res.flags.UdpFailed = !res.flags.UdpOK;
                 }
             }
         }
     }
     else if (ppr.ipStatus == ppresIPV6)
     {
         if(ppr.xxpStatus == ppresXxpKnown)
         {
             if(ppr.TcpUdp == ppresIsTCP)  
             {
                 if (f.fRxTCPv6Checksum)
                 {
                     res.flags.TcpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS;
                     res.flags.TcpFailed = !res.flags.TcpOK;
                 }
             }
             else  
             {
                 if (f.fRxUDPv6Checksum)
                 {
                     res.flags.UdpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS;
                     res.flags.UdpFailed = !res.flags.UdpOK;
                 }
             }
         }
     }
     return res;
 }","[9, 10, 14, 31, 32, 33, 34, 35, 36]","The NetKVM Windows Virtio driver allows remote attackers to cause a denial of service (guest crash) via a crafted length value in an IP packet, as demonstrated by a value that does not account for the size of the IP options.",kvm-guest-drivers-windows,CVE-2015-3215,CWE-20
3408,182219," static int asepcos_parse_sec_attr(sc_card_t *card, sc_file_t *file, const u8 *buf,
 	size_t len)
 {
 	const u8 *p = buf;
  	while (len != 0) {
  		unsigned int amode, tlen = 3;
		if (len < 5 && p[0] != 0x80 && p[1] != 0x01) {
 		if (len < 5 || p[0] != 0x80 || p[1] != 0x01) {
  			sc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, ""invalid access mode encoding"");
  			return SC_ERROR_INTERNAL;
  		}
 		amode = p[2];
 		if (p[3] == 0x90 && p[4] == 0x00) {
 			int r = set_sec_attr(file, amode, 0, SC_AC_NONE);
 			if (r != SC_SUCCESS) 
 				return r;
 			tlen += 2;
 		} else if (p[3] == 0x97 && p[4] == 0x00) {
 			int r = set_sec_attr(file, amode, 0, SC_AC_NEVER);
 			if (r != SC_SUCCESS) 
 				return r;
 			tlen += 2;
 		} else if (p[3] == 0xA0 && len >= 4U + p[4]) {
 			int r = set_sec_attr(file, amode, p[5], SC_AC_CHV);
 			if (r != SC_SUCCESS)
 				return r;
 			tlen += 2 + p[4];  
 		} else if (p[3] == 0xAF && len >= 4U + p[4]) {
 			int r = set_sec_attr(file, amode, p[5], SC_AC_CHV);
 			if (r != SC_SUCCESS)
 				return r;
 			tlen += 2 + p[4];	 
 		} else {
 			sc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, ""invalid security condition"");
 			return SC_ERROR_INTERNAL;
 		}
 		p   += tlen;
 		len -= tlen;
 	}
 	return SC_SUCCESS;
 }","[7, 8]",Various out of bounds reads when handling responses in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to potentially crash the opensc library using programs.,OpenSC,CVE-2018-16427,CWE-125
3438,178615,"  SProcXFixesChangeSaveSet(ClientPtr client)
  {
      REQUEST(xXFixesChangeSaveSetReq);
     REQUEST_SIZE_MATCH(xXFixesChangeSaveSetReq);
      swaps(&stuff->length);
      swapl(&stuff->window);
 }",[4],xorg-x11-server before 1.19.5 was missing length validation in XFIXES extension allowing malicious X client to cause X server to crash or possibly execute arbitrary code.,xserver,CVE-2017-12183,CWE-20
3466,182007," static pngquant_error rwpng_read_image24_libpng(FILE *infile, png24_image *mainprog_ptr, int verbose)
 {
     png_structp  png_ptr = NULL;
     png_infop    info_ptr = NULL;
     png_size_t   rowbytes;
     int          color_type, bit_depth;
     png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, mainprog_ptr,
       rwpng_error_handler, verbose ? rwpng_warning_stderr_handler : rwpng_warning_silent_handler);
     if (!png_ptr) {
         return PNG_OUT_OF_MEMORY_ERROR;    
     }
     info_ptr = png_create_info_struct(png_ptr);
     if (!info_ptr) {
         png_destroy_read_struct(&png_ptr, NULL, NULL);
         return PNG_OUT_OF_MEMORY_ERROR;    
     }
     if (setjmp(mainprog_ptr->jmpbuf)) {
         png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
         return LIBPNG_FATAL_ERROR;    
     }
 #if defined(PNG_SKIP_sRGB_CHECK_PROFILE) && defined(PNG_SET_OPTION_SUPPORTED)
     png_set_option(png_ptr, PNG_SKIP_sRGB_CHECK_PROFILE, PNG_OPTION_ON);
 #endif
 #if PNG_LIBPNG_VER >= 10500 && defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
     png_set_keep_unknown_chunks(png_ptr, PNG_HANDLE_CHUNK_IF_SAFE, (png_const_bytep)""pHYs\0iTXt\0tEXt\0zTXt"", 4);
 #endif
     png_set_read_user_chunk_fn(png_ptr, &mainprog_ptr->chunks, read_chunk_callback);
     struct rwpng_read_data read_data = {infile, 0};
     png_set_read_fn(png_ptr, &read_data, user_read_data);
     png_read_info(png_ptr, info_ptr);   
      png_get_IHDR(png_ptr, info_ptr, &mainprog_ptr->width, &mainprog_ptr->height,
                   &bit_depth, &color_type, NULL, NULL, NULL);
    if (mainprog_ptr->width > INT_MAX/mainprog_ptr->height) {
        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
        return PNG_OUT_OF_MEMORY_ERROR;   
    }
     if (!(color_type & PNG_COLOR_MASK_ALPHA)) {
 #ifdef PNG_READ_FILLER_SUPPORTED
         png_set_expand(png_ptr);
         png_set_filler(png_ptr, 65535L, PNG_FILLER_AFTER);
 #else
         fprintf(stderr, ""pngquant readpng:  image is neither RGBA nor GA\n"");
         png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
         mainprog_ptr->retval = WRONG_INPUT_COLOR_TYPE;
         return mainprog_ptr->retval;
 #endif
     }
     if (bit_depth == 16) {
         png_set_strip_16(png_ptr);
     }
     if (!(color_type & PNG_COLOR_MASK_COLOR)) {
         png_set_gray_to_rgb(png_ptr);
     }
     double gamma = 0.45455;
     if (png_get_valid(png_ptr, info_ptr, PNG_INFO_sRGB)) {
         mainprog_ptr->input_color = RWPNG_SRGB;
         mainprog_ptr->output_color = RWPNG_SRGB;
     } else {
         png_get_gAMA(png_ptr, info_ptr, &gamma);
         if (gamma > 0 && gamma <= 1.0) {
             mainprog_ptr->input_color = RWPNG_GAMA_ONLY;
             mainprog_ptr->output_color = RWPNG_GAMA_ONLY;
         } else {
             fprintf(stderr, ""pngquant readpng:  ignored out-of-range gamma %f\n"", gamma);
             mainprog_ptr->input_color = RWPNG_NONE;
             mainprog_ptr->output_color = RWPNG_NONE;
             gamma = 0.45455;
         }
     }
     mainprog_ptr->gamma = gamma;
     png_set_interlace_handling(png_ptr);
     png_read_update_info(png_ptr, info_ptr);
      rowbytes = png_get_rowbytes(png_ptr, info_ptr);
     if (rowbytes > INT_MAX/mainprog_ptr->height) {
         png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
         return PNG_OUT_OF_MEMORY_ERROR;
     }
      if ((mainprog_ptr->rgba_data = malloc(rowbytes * mainprog_ptr->height)) == NULL) {
          fprintf(stderr, ""pngquant readpng:  unable to allocate image data\n"");
          png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
         return PNG_OUT_OF_MEMORY_ERROR;
     }
     png_bytepp row_pointers = rwpng_create_row_pointers(info_ptr, png_ptr, mainprog_ptr->rgba_data, mainprog_ptr->height, 0);
     png_read_image(png_ptr, row_pointers);
     png_read_end(png_ptr, NULL);
 #if USE_LCMS
 #if PNG_LIBPNG_VER < 10500
     png_charp ProfileData;
 #else
     png_bytep ProfileData;
 #endif
     png_uint_32 ProfileLen;
     cmsHPROFILE hInProfile = NULL;
     int COLOR_PNG = color_type & PNG_COLOR_MASK_COLOR;
     if (png_get_iCCP(png_ptr, info_ptr, &(png_charp){0}, &(int){0}, &ProfileData, &ProfileLen)) {
         hInProfile = cmsOpenProfileFromMem(ProfileData, ProfileLen);
         cmsColorSpaceSignature colorspace = cmsGetColorSpace(hInProfile);
         if (colorspace == cmsSigRgbData && COLOR_PNG) {
             mainprog_ptr->input_color = RWPNG_ICCP;
             mainprog_ptr->output_color = RWPNG_SRGB;
         } else {
             if (colorspace == cmsSigGrayData && !COLOR_PNG) {
                 mainprog_ptr->input_color = RWPNG_ICCP_WARN_GRAY;
                 mainprog_ptr->output_color = RWPNG_SRGB;
             }
             cmsCloseProfile(hInProfile);
             hInProfile = NULL;
         }
     }
     if (hInProfile == NULL && COLOR_PNG &&
         !png_get_valid(png_ptr, info_ptr, PNG_INFO_sRGB) &&
         png_get_valid(png_ptr, info_ptr, PNG_INFO_gAMA) &&
         png_get_valid(png_ptr, info_ptr, PNG_INFO_cHRM)) {
         cmsCIExyY WhitePoint;
         cmsCIExyYTRIPLE Primaries;
         png_get_cHRM(png_ptr, info_ptr, &WhitePoint.x, &WhitePoint.y,
                      &Primaries.Red.x, &Primaries.Red.y,
                      &Primaries.Green.x, &Primaries.Green.y,
                      &Primaries.Blue.x, &Primaries.Blue.y);
         WhitePoint.Y = Primaries.Red.Y = Primaries.Green.Y = Primaries.Blue.Y = 1.0;
         cmsToneCurve *GammaTable[3];
         GammaTable[0] = GammaTable[1] = GammaTable[2] = cmsBuildGamma(NULL, 1/gamma);
         hInProfile = cmsCreateRGBProfile(&WhitePoint, &Primaries, GammaTable);
         cmsFreeToneCurve(GammaTable[0]);
         mainprog_ptr->input_color = RWPNG_GAMA_CHRM;
         mainprog_ptr->output_color = RWPNG_SRGB;
     }
     if (hInProfile != NULL) {
         cmsHPROFILE hOutProfile = cmsCreate_sRGBProfile();
         cmsHTRANSFORM hTransform = cmsCreateTransform(hInProfile, TYPE_RGBA_8,
                                                       hOutProfile, TYPE_RGBA_8,
                                                       INTENT_PERCEPTUAL,
                                                       omp_get_max_threads() > 1 ? cmsFLAGS_NOCACHE : 0);
         #pragma omp parallel for \
             if (mainprog_ptr->height*mainprog_ptr->width > 8000) \
             schedule(static)
         for (unsigned int i = 0; i < mainprog_ptr->height; i++) {
             cmsDoTransform(hTransform, row_pointers[i],
                                        row_pointers[i],
                                        mainprog_ptr->width);
         }
         cmsDeleteTransform(hTransform);
         cmsCloseProfile(hOutProfile);
         cmsCloseProfile(hInProfile);
         mainprog_ptr->gamma = 0.45455;
     }
 #endif
     png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
     mainprog_ptr->file_size = read_data.bytes_read;
     mainprog_ptr->row_pointers = (unsigned char **)row_pointers;
     return SUCCESS;
 }","[33, 34, 35, 36, 74, 75, 76, 77]","Integer overflow in the rwpng_read_image24_libpng function in rwpng.c in pngquant 2.7.0 allows remote attackers to have unspecified impact via a crafted PNG file, which triggers a buffer overflow.",pngquant,CVE-2016-5735,CWE-190
3546,182044," int main(void)
  {
  	FILE *f;
  	char *tmpname;
	f = xfmkstemp(&tmpname, NULL);
 	f = xfmkstemp(&tmpname, NULL, ""test"");
  	unlink(tmpname);
  	free(tmpname);
  	fclose(f);
 	return EXIT_FAILURE;
 }","[5, 6]",The mkostemp function in login-utils in util-linux when used incorrectly allows remote attackers to cause file name collision and possibly other attacks.,util-linux,CVE-2015-5224,CWE-264
3547,181376," int _yr_scan_verify_re_match(
     YR_SCAN_CONTEXT* context,
     YR_AC_MATCH* ac_match,
     uint8_t* data,
     size_t data_size,
     size_t data_base,
     size_t offset)
 {
   CALLBACK_ARGS callback_args;
   RE_EXEC_FUNC exec;
   int forward_matches = -1;
   int backward_matches = -1;
   int flags = 0;
   if (STRING_IS_GREEDY_REGEXP(ac_match->string))
     flags |= RE_FLAGS_GREEDY;
   if (STRING_IS_NO_CASE(ac_match->string))
     flags |= RE_FLAGS_NO_CASE;
   if (STRING_IS_DOT_ALL(ac_match->string))
     flags |= RE_FLAGS_DOT_ALL;
   if (STRING_IS_FAST_REGEXP(ac_match->string))
     exec = yr_re_fast_exec;
   else
     exec = yr_re_exec;
   if (STRING_IS_ASCII(ac_match->string))
   {
     forward_matches = exec(
          ac_match->forward_code,
          data + offset,
          data_size - offset,
        offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags,
         offset,
         flags,
          NULL,
          NULL);
    }
   if (STRING_IS_WIDE(ac_match->string) && forward_matches == -1)
   {
     flags |= RE_FLAGS_WIDE;
     forward_matches = exec(
          ac_match->forward_code,
          data + offset,
          data_size - offset,
        offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags,
         offset,
         flags,
          NULL,
          NULL);
    }
   switch(forward_matches)
   {
     case -1:
       return ERROR_SUCCESS;
     case -2:
       return ERROR_INSUFFICIENT_MEMORY;
     case -3:
       return ERROR_TOO_MANY_MATCHES;
     case -4:
       return ERROR_TOO_MANY_RE_FIBERS;
     case -5:
       return ERROR_INTERNAL_FATAL_ERROR;
   }
   if (forward_matches == 0 && ac_match->backward_code == NULL)
     return ERROR_SUCCESS;
   callback_args.string = ac_match->string;
   callback_args.context = context;
   callback_args.data = data;
   callback_args.data_size = data_size;
   callback_args.data_base = data_base;
   callback_args.forward_matches = forward_matches;
   callback_args.full_word = STRING_IS_FULL_WORD(ac_match->string);
   if (ac_match->backward_code != NULL)
   {
      backward_matches = exec(
          ac_match->backward_code,
          data + offset,
         data_size - offset,
          offset,
          flags | RE_FLAGS_BACKWARDS | RE_FLAGS_EXHAUSTIVE,
          _yr_scan_match_callback,
         (void*) &callback_args);
     switch(backward_matches)
     {
       case -2:
         return ERROR_INSUFFICIENT_MEMORY;
       case -3:
         return ERROR_TOO_MANY_MATCHES;
       case -4:
         return ERROR_TOO_MANY_RE_FIBERS;
       case -5:
         return ERROR_INTERNAL_FATAL_ERROR;
     }
   }
   else
   {
     FAIL_ON_ERROR(_yr_scan_match_callback(
         data + offset, 0, flags, &callback_args));
   }
   return ERROR_SUCCESS;
 }","[30, 31, 32, 43, 44, 45, 76]",libyara/re.c in the regex component in YARA 3.5.0 allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted rule that is mishandled in the yr_re_exec function.,yara,CVE-2017-8294,CWE-125
3563,182046," static int mif_process_cmpt(mif_hdr_t *hdr, char *buf)
 {
 	jas_tvparser_t *tvp;
 	mif_cmpt_t *cmpt;
 	int id;
 	cmpt = 0;
 	tvp = 0;
 	if (!(cmpt = mif_cmpt_create())) {
 		goto error;
 	}
 	cmpt->tlx = 0;
 	cmpt->tly = 0;
 	cmpt->sampperx = 0;
 	cmpt->samppery = 0;
 	cmpt->width = 0;
 	cmpt->height = 0;
 	cmpt->prec = 0;
 	cmpt->sgnd = -1;
 	cmpt->data = 0;
 	if (!(tvp = jas_tvparser_create(buf))) {
 		goto error;
 	}
 	while (!(id = jas_tvparser_next(tvp))) {
 		switch (jas_taginfo_nonull(jas_taginfos_lookup(mif_tags,
 		  jas_tvparser_gettag(tvp)))->id) {
 		case MIF_TLX:
 			cmpt->tlx = atoi(jas_tvparser_getval(tvp));
 			break;
 		case MIF_TLY:
 			cmpt->tly = atoi(jas_tvparser_getval(tvp));
 			break;
 		case MIF_WIDTH:
 			cmpt->width = atoi(jas_tvparser_getval(tvp));
 			break;
 		case MIF_HEIGHT:
 			cmpt->height = atoi(jas_tvparser_getval(tvp));
 			break;
 		case MIF_HSAMP:
 			cmpt->sampperx = atoi(jas_tvparser_getval(tvp));
 			break;
 		case MIF_VSAMP:
 			cmpt->samppery = atoi(jas_tvparser_getval(tvp));
 			break;
 		case MIF_PREC:
 			cmpt->prec = atoi(jas_tvparser_getval(tvp));
 			break;
 		case MIF_SGND:
 			cmpt->sgnd = atoi(jas_tvparser_getval(tvp));
 			break;
 		case MIF_DATA:
 			if (!(cmpt->data = jas_strdup(jas_tvparser_getval(tvp)))) {
 				return -1;
 			}
  			break;
  		}
  	}
	jas_tvparser_destroy(tvp);
  	if (!cmpt->sampperx || !cmpt->samppery) {
  		goto error;
  	}
  	if (mif_hdr_addcmpt(hdr, hdr->numcmpts, cmpt)) {
  		goto error;
  	}
 	jas_tvparser_destroy(tvp);
  	return 0;
  error:
 	if (cmpt) {
 		mif_cmpt_destroy(cmpt);
 	}
 	if (tvp) {
 		jas_tvparser_destroy(tvp);
 	}
 	return -1;
 }","[57, 64]",Use-after-free vulnerability in the mif_process_cmpt function in libjasper/mif/mif_cod.c in the JasPer JPEG-2000 library before 1.900.2 allows remote attackers to cause a denial of service (crash) via a crafted JPEG 2000 image file.,jasper,CVE-2015-5221,CWE-416
3608,180135," static void send_auth(char *username, char *password) {
 	struct mt_packet data;
 	unsigned short width = 0;
 	unsigned short height = 0;
  	char *terminal = getenv(""TERM"");
  	char md5data[100];
  	unsigned char md5sum[17];
	int plen;
 	int plen, act_pass_len;
  	md5_state_t state;
  #if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)
  	mlock(md5data, sizeof(md5data));
  	mlock(md5sum, sizeof(md5data));
  #endif
 	act_pass_len = strnlen(password, 82);
  	md5data[0] = 0;
	strncpy(md5data + 1, password, 82);
	md5data[83] = '\0';
	memcpy(md5data + 1 + strlen(password), pass_salt, 16);
 	memcpy(md5data + 1, password, act_pass_len);
 	memcpy(md5data + 1 + act_pass_len, pass_salt, 16);
  	md5_init(&state);
	md5_append(&state, (const md5_byte_t *)md5data, strlen(password) + 17);
 	md5_append(&state, (const md5_byte_t *)md5data, 1 + act_pass_len + 16);
  	md5_finish(&state, (md5_byte_t *)md5sum + 1);
  	md5sum[0] = 0;
 	init_packet(&data, MT_PTYPE_DATA, srcmac, dstmac, sessionkey, outcounter);
 	plen = add_control_packet(&data, MT_CPTYPE_PASSWORD, md5sum, 17);
 	plen += add_control_packet(&data, MT_CPTYPE_USERNAME, username, strlen(username));
 	plen += add_control_packet(&data, MT_CPTYPE_TERM_TYPE, terminal, strlen(terminal));
 	if (is_a_tty && get_terminal_size(&width, &height) != -1) {
 		width = htole16(width);
 		height = htole16(height);
 		plen += add_control_packet(&data, MT_CPTYPE_TERM_WIDTH, &width, 2);
 		plen += add_control_packet(&data, MT_CPTYPE_TERM_HEIGHT, &height, 2);
 	}
 	outcounter += plen;
 	send_udp(&data, 1);
 }","[8, 9, 15, 17, 18, 19, 20, 21, 23, 24]",Buffer overflow in the handle_packet function in mactelnet.c in the client in MAC-Telnet 0.4.3 and earlier allows remote TELNET servers to execute arbitrary code via a long string in an MT_CPTYPE_PASSSALT control packet.,MAC-Telnet,CVE-2016-7115,CWE-119
3654,182790," static int vorbis_finish_frame(stb_vorbis *f, int len, int left, int right)
 {
    int prev,i,j;
     if (f->previous_length) {
        int i,j, n = f->previous_length;
        float *w = get_window(f, n);
       if (w == NULL) return 0;
        for (i=0; i < f->channels; ++i) {
           for (j=0; j < n; ++j)
              f->channel_buffers[i][left+j] =
                f->channel_buffers[i][left+j]*w[    j] +
                f->previous_window[i][     j]*w[n-1-j];
       }
    }
    prev = f->previous_length;
    f->previous_length = len - right;
    for (i=0; i < f->channels; ++i)
       for (j=0; right+j < len; ++j)
          f->previous_window[i][j] = f->channel_buffers[i][right+j];
    if (!prev)
       return 0;
    if (len < right) right = len;
    f->samples_output += right-left;
    return right - left;
 }",[7],A reachable assertion in the lookup1_values function in stb_vorbis through 2019-03-04 allows an attacker to cause a denial of service by opening a crafted Ogg Vorbis file.,stb,CVE-2019-13223,CWE-20
3684,181880,"  jas_seq2d_t *jas_seq2d_copy(jas_seq2d_t *x)
  {
  	jas_matrix_t *y;
	int i;
	int j;
 	jas_matind_t i;
 	jas_matind_t j;
  	y = jas_seq2d_create(jas_seq2d_xstart(x), jas_seq2d_ystart(x),
  	  jas_seq2d_xend(x), jas_seq2d_yend(x));
  	assert(y);
 	for (i = 0; i < x->numrows_; ++i) {
 		for (j = 0; j < x->numcols_; ++j) {
 			*jas_matrix_getref(y, i, j) = jas_matrix_get(x, i, j);
 		}
 	}
 	return y;
 }","[4, 5, 6, 7]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
3700,182334," static int handle_eac3(MOVMuxContext *mov, AVPacket *pkt, MOVTrack *track)
 {
     AC3HeaderInfo *hdr = NULL;
     struct eac3_info *info;
     int num_blocks, ret;
     if (!track->eac3_priv && !(track->eac3_priv = av_mallocz(sizeof(*info))))
         return AVERROR(ENOMEM);
     info = track->eac3_priv;
     if (avpriv_ac3_parse_header(&hdr, pkt->data, pkt->size) < 0) {
         if (!track->entry) {
             av_log(mov, AV_LOG_WARNING, ""Dropping invalid packet from start of the stream\n"");
             ret = 0;
         } else
             ret = AVERROR_INVALIDDATA;
         goto end;
     }
     info->data_rate = FFMAX(info->data_rate, hdr->bit_rate / 1000);
     num_blocks = hdr->num_blocks;
     if (!info->ec3_done) {
         if (hdr->bitstream_id <= 10 && hdr->substreamid != 0) {
             ret = AVERROR(EINVAL);
             goto end;
         }
         if (hdr->frame_type == EAC3_FRAME_TYPE_INDEPENDENT) {
             if (hdr->substreamid > info->num_ind_sub + 1) {
                 ret = AVERROR(EINVAL);
                 goto end;
             }
              if (hdr->substreamid == info->num_ind_sub + 1) {
                avpriv_request_sample(track->par, ""Multiple independent substreams"");
                 avpriv_request_sample(mov->fc, ""Multiple independent substreams"");
                  ret = AVERROR_PATCHWELCOME;
                  goto end;
              } else if (hdr->substreamid < info->num_ind_sub ||
                        hdr->substreamid == 0 && info->substream[0].bsid) {
                 info->ec3_done = 1;
                 goto concatenate;
             }
         } else {
             if (hdr->substreamid != 0) {
                 avpriv_request_sample(mov->fc, ""Multiple non EAC3 independent substreams"");
                 ret = AVERROR_PATCHWELCOME;
                 goto end;
             }
         }
         info->substream[hdr->substreamid].fscod = hdr->sr_code;
         info->substream[hdr->substreamid].bsid  = hdr->bitstream_id;
         info->substream[hdr->substreamid].bsmod = hdr->bitstream_mode;
         info->substream[hdr->substreamid].acmod = hdr->channel_mode;
         info->substream[hdr->substreamid].lfeon = hdr->lfe_on;
         if (pkt->size != hdr->frame_size) {
             int cumul_size = hdr->frame_size;
             int parent = hdr->substreamid;
             while (cumul_size != pkt->size) {
                 GetBitContext gbc;
                 int i;
                 ret = avpriv_ac3_parse_header(&hdr, pkt->data + cumul_size, pkt->size - cumul_size);
                 if (ret < 0)
                     goto end;
                 if (hdr->frame_type != EAC3_FRAME_TYPE_DEPENDENT) {
                     ret = AVERROR(EINVAL);
                     goto end;
                 }
                 info->substream[parent].num_dep_sub++;
                 ret /= 8;
                 init_get_bits8(&gbc, pkt->data + cumul_size + ret, pkt->size - cumul_size - ret);
                 skip_bits(&gbc, 5);
                 for (i = 0; i < (hdr->channel_mode ? 1 : 2); i++) {
                     skip_bits(&gbc, 5);  
                     if (get_bits1(&gbc)) {
                         skip_bits(&gbc, 8);  
                     }
                 }
                 if (get_bits1(&gbc))
                     info->substream[parent].chan_loc |= (get_bits(&gbc, 16) >> 5) & 0x1f;
                 else
                     info->substream[parent].chan_loc |= hdr->channel_mode;
                 cumul_size += hdr->frame_size;
             }
         }
     }
 concatenate:
     if (!info->num_blocks && num_blocks == 6) {
         ret = pkt->size;
         goto end;
     }
     else if (info->num_blocks + num_blocks > 6) {
         ret = AVERROR_INVALIDDATA;
         goto end;
     }
     if (!info->num_blocks) {
         ret = av_packet_ref(&info->pkt, pkt);
         if (!ret)
             info->num_blocks = num_blocks;
         goto end;
     } else {
         if ((ret = av_grow_packet(&info->pkt, pkt->size)) < 0)
             goto end;
         memcpy(info->pkt.data + info->pkt.size - pkt->size, pkt->data, pkt->size);
         info->num_blocks += num_blocks;
         info->pkt.duration += pkt->duration;
         if ((ret = av_copy_packet_side_data(&info->pkt, pkt)) < 0)
             goto end;
         if (info->num_blocks != 6)
             goto end;
         av_packet_unref(pkt);
         av_packet_move_ref(pkt, &info->pkt);
         info->num_blocks = 0;
     }
     ret = pkt->size;
 end:
     av_free(hdr);
     return ret;
 }","[30, 31]","In FFmpeg 4.0.1, an improper argument (AVCodecParameters) passed to the avpriv_request_sample function in the handle_eac3 function in libavformat/movenc.c may trigger an out-of-array read while converting a crafted AVI file to MPEG4, leading to a denial of service and possibly an information disclosure.",FFmpeg,CVE-2018-13300,CWE-125
3729,181859,"  static int jas_iccgetuint64(jas_stream_t *in, jas_iccuint64_t *val)
  {
	ulonglong tmp;
 	jas_ulonglong tmp;
  	if (jas_iccgetuint(in, 8, &tmp))
  		return -1;
  	*val = tmp;
  	return 0;
  }","[3, 4]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
3735,181867,"  jas_image_t *jas_image_create0()
 {
 	jas_image_t *image;
 	if (!(image = jas_malloc(sizeof(jas_image_t)))) {
 		return 0;
 	}
 	image->tlx_ = 0;
 	image->tly_ = 0;
 	image->brx_ = 0;
 	image->bry_ = 0;
 	image->clrspc_ = JAS_CLRSPC_UNKNOWN;
  	image->numcmpts_ = 0;
  	image->maxcmpts_ = 0;
  	image->cmpts_ = 0;
	image->inmem_ = true;
  	image->cmprof_ = 0;
  	return image;
 }",[15],Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
3746,182870," static void Sp_match(js_State *J)
 {
 	js_Regexp *re;
 	const char *text;
 	int len;
 	const char *a, *b, *c, *e;
 	Resub m;
 	text = checkstring(J, 0);
 	if (js_isregexp(J, 1))
 		js_copy(J, 1);
 	else if (js_isundefined(J, 1))
 		js_newregexp(J, """", 0);
 	else
 		js_newregexp(J, js_tostring(J, 1), 0);
 	re = js_toregexp(J, -1);
 	if (!(re->flags & JS_REGEXP_G)) {
 		js_RegExp_prototype_exec(J, re, text);
 		return;
 	}
 	re->last = 0;
 	js_newarray(J);
 	len = 0;
  	a = text;
  	e = text + strlen(text);
  	while (a <= e) {
		if (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))
 		if (js_doregexec(J, re->prog, a, &m, a > text ? REG_NOTBOL : 0))
  			break;
  		b = m.sub[0].sp;
 		c = m.sub[0].ep;
 		js_pushlstring(J, b, c - b);
 		js_setindex(J, -2, len++);
 		a = c;
 		if (c - b == 0)
 			++a;
 	}
 	if (len == 0) {
 		js_pop(J, 1);
 		js_pushnull(J);
 	}
 }","[26, 27]",An issue was discovered in Artifex MuJS 1.0.5. It has unlimited recursion because the match function in regexp.c lacks a depth check.,mujs,CVE-2019-11413,CWE-400
3752,178123," static boolean parse_identifier( const char **pcur, char *ret )
 static boolean parse_identifier( const char **pcur, char *ret, size_t len )
  {
     const char *cur = *pcur;
     int i = 0;
     if (is_alpha_underscore( cur )) {
        ret[i++] = *cur++;
      while (is_alpha_underscore( cur ) || is_digit( cur ))
       while (is_alpha_underscore( cur ) || is_digit( cur )) {
          if (i == len - 1)
             return FALSE;
           ret[i++] = *cur++;
       }
        ret[i++] = '\0';
        *pcur = cur;
        return TRUE;
 static boolean parse_float( const char **pcur, float *val )
 {
    const char *cur = *pcur;
    boolean integral_part = FALSE;
    boolean fractional_part = FALSE;
    if (*cur == '0' && *(cur + 1) == 'x') {
       union fi fi;
       fi.ui = strtoul(cur, NULL, 16);
       *val = fi.f;
       cur += 10;
       goto out;
    }
    *val = (float) atof( cur );
    if (*cur == '-' || *cur == '+')
       cur++;
    if (is_digit( cur )) {
       cur++;
       integral_part = TRUE;
       while (is_digit( cur ))
          cur++;
    }
    if (*cur == '.') {
       cur++;
       if (is_digit( cur )) {
          cur++;
          fractional_part = TRUE;
          while (is_digit( cur ))
             cur++;
       }
    }
    if (!integral_part && !fractional_part)
       return FALSE;
    if (uprcase( *cur ) == 'E') {
       cur++;
       if (*cur == '-' || *cur == '+')
          cur++;
       if (is_digit( cur )) {
          cur++;
          while (is_digit( cur ))
             cur++;
       }
       else
          return FALSE;
    }
 out:
    *pcur = cur;
    return TRUE;
 }
 static boolean parse_double( const char **pcur, uint32_t *val0, uint32_t *val1)
 {
    const char *cur = *pcur;
    union {
       double dval;
       uint32_t uval[2];
    } v;
    v.dval = strtod(cur, (char**)pcur);
    if (*pcur == cur)
       return FALSE;
    *val0 = v.uval[0];
    *val1 = v.uval[1];
    return TRUE;
 }
 struct translate_ctx
 {
    const char *text;
    const char *cur;
    struct tgsi_token *tokens;
    struct tgsi_token *tokens_cur;
    struct tgsi_token *tokens_end;
    struct tgsi_header *header;
    unsigned processor : 4;
    unsigned implied_array_size : 6;
    unsigned num_immediates;
 };
 static void report_error(struct translate_ctx *ctx, const char *format, ...)
 {
    va_list args;
    int line = 1;
    int column = 1;
    const char *itr = ctx->text;
    debug_printf(""\nTGSI asm error: "");
    va_start(args, format);
    _debug_vprintf(format, args);
    va_end(args);
    while (itr != ctx->cur) {
       if (*itr == '\n') {
          column = 1;
          ++line;
       }
       ++column;
       ++itr;
    }
    debug_printf("" [%d : %d] \n"", line, column);
 }
 static boolean parse_header( struct translate_ctx *ctx )
 {
    uint processor;
    if (str_match_nocase_whole( &ctx->cur, ""FRAG"" ))
       processor = TGSI_PROCESSOR_FRAGMENT;
    else if (str_match_nocase_whole( &ctx->cur, ""VERT"" ))
       processor = TGSI_PROCESSOR_VERTEX;
    else if (str_match_nocase_whole( &ctx->cur, ""GEOM"" ))
       processor = TGSI_PROCESSOR_GEOMETRY;
    else if (str_match_nocase_whole( &ctx->cur, ""TESS_CTRL"" ))
       processor = TGSI_PROCESSOR_TESS_CTRL;
    else if (str_match_nocase_whole( &ctx->cur, ""TESS_EVAL"" ))
       processor = TGSI_PROCESSOR_TESS_EVAL;
    else if (str_match_nocase_whole( &ctx->cur, ""COMP"" ))
       processor = TGSI_PROCESSOR_COMPUTE;
    else {
       report_error( ctx, ""Unknown header"" );
       return FALSE;
    }
    if (ctx->tokens_cur >= ctx->tokens_end)
       return FALSE;
    ctx->header = (struct tgsi_header *) ctx->tokens_cur++;
    *ctx->header = tgsi_build_header();
    if (ctx->tokens_cur >= ctx->tokens_end)
       return FALSE;
    *(struct tgsi_processor *) ctx->tokens_cur++ = tgsi_build_processor( processor, ctx->header );
    ctx->processor = processor;
    return TRUE;
 }
 static boolean parse_label( struct translate_ctx *ctx, uint *val )
 {
    const char *cur = ctx->cur;
    if (parse_uint( &cur, val )) {
       eat_opt_white( &cur );
       if (*cur == ':') {
          cur++;
          ctx->cur = cur;
          return TRUE;
       }
    }
    return FALSE;
 }
 static boolean
 parse_file( const char **pcur, uint *file )
 {
    uint i;
    for (i = 0; i < TGSI_FILE_COUNT; i++) {
       const char *cur = *pcur;
       if (str_match_nocase_whole( &cur, tgsi_file_name(i) )) {
          *pcur = cur;
          *file = i;
          return TRUE;
       }
    }
    return FALSE;
 }
 static boolean
 parse_opt_writemask(
    struct translate_ctx *ctx,
    uint *writemask )
 {
    const char *cur;
    cur = ctx->cur;
    eat_opt_white( &cur );
    if (*cur == '.') {
       cur++;
       *writemask = TGSI_WRITEMASK_NONE;
       eat_opt_white( &cur );
       if (uprcase( *cur ) == 'X') {
          cur++;
          *writemask |= TGSI_WRITEMASK_X;
       }
       if (uprcase( *cur ) == 'Y') {
          cur++;
          *writemask |= TGSI_WRITEMASK_Y;
       }
       if (uprcase( *cur ) == 'Z') {
          cur++;
          *writemask |= TGSI_WRITEMASK_Z;
       }
       if (uprcase( *cur ) == 'W') {
          cur++;
          *writemask |= TGSI_WRITEMASK_W;
       }
       if (*writemask == TGSI_WRITEMASK_NONE) {
          report_error( ctx, ""Writemask expected"" );
          return FALSE;
       }
       ctx->cur = cur;
    }
    else {
       *writemask = TGSI_WRITEMASK_XYZW;
    }
    return TRUE;
 }
 static boolean
 parse_register_file_bracket(
    struct translate_ctx *ctx,
    uint *file )
 {
    if (!parse_file( &ctx->cur, file )) {
       report_error( ctx, ""Unknown register file"" );
       return FALSE;
    }
    eat_opt_white( &ctx->cur );
    if (*ctx->cur != '[') {
       report_error( ctx, ""Expected `['"" );
       return FALSE;
    }
    ctx->cur++;
    return TRUE;
 }
 static boolean
 parse_register_file_bracket_index(
    struct translate_ctx *ctx,
    uint *file,
    int *index )
 {
    uint uindex;
    if (!parse_register_file_bracket( ctx, file ))
       return FALSE;
    eat_opt_white( &ctx->cur );
    if (!parse_uint( &ctx->cur, &uindex )) {
       report_error( ctx, ""Expected literal unsigned integer"" );
       return FALSE;
    }
    *index = (int) uindex;
    return TRUE;
 }
 static boolean
 parse_register_1d(struct translate_ctx *ctx,
                   uint *file,
                   int *index )
 {
    if (!parse_register_file_bracket_index( ctx, file, index ))
       return FALSE;
    eat_opt_white( &ctx->cur );
    if (*ctx->cur != ']') {
       report_error( ctx, ""Expected `]'"" );
       return FALSE;
    }
    ctx->cur++;
    return TRUE;
 }
 struct parsed_bracket {
    int index;
    uint ind_file;
    int ind_index;
    uint ind_comp;
    uint ind_array;
 };
 static boolean
 parse_register_bracket(
    struct translate_ctx *ctx,
    struct parsed_bracket *brackets)
 {
    const char *cur;
    uint uindex;
    memset(brackets, 0, sizeof(struct parsed_bracket));
    eat_opt_white( &ctx->cur );
    cur = ctx->cur;
    if (parse_file( &cur, &brackets->ind_file )) {
       if (!parse_register_1d( ctx, &brackets->ind_file,
                               &brackets->ind_index ))
          return FALSE;
       eat_opt_white( &ctx->cur );
       if (*ctx->cur == '.') {
          ctx->cur++;
          eat_opt_white(&ctx->cur);
          switch (uprcase(*ctx->cur)) {
          case 'X':
             brackets->ind_comp = TGSI_SWIZZLE_X;
             break;
          case 'Y':
             brackets->ind_comp = TGSI_SWIZZLE_Y;
             break;
          case 'Z':
             brackets->ind_comp = TGSI_SWIZZLE_Z;
             break;
          case 'W':
             brackets->ind_comp = TGSI_SWIZZLE_W;
             break;
          default:
             report_error(ctx, ""Expected indirect register swizzle component `x', `y', `z' or `w'"");
             return FALSE;
          }
          ctx->cur++;
          eat_opt_white(&ctx->cur);
       }
       if (*ctx->cur == '+' || *ctx->cur == '-')
          parse_int( &ctx->cur, &brackets->index );
       else
          brackets->index = 0;
    }
    else {
       if (!parse_uint( &ctx->cur, &uindex )) {
          report_error( ctx, ""Expected literal unsigned integer"" );
          return FALSE;
       }
       brackets->index = (int) uindex;
       brackets->ind_file = TGSI_FILE_NULL;
       brackets->ind_index = 0;
    }
    eat_opt_white( &ctx->cur );
    if (*ctx->cur != ']') {
       report_error( ctx, ""Expected `]'"" );
       return FALSE;
    }
    ctx->cur++;
    if (*ctx->cur == '(') {
       ctx->cur++;
       eat_opt_white( &ctx->cur );
       if (!parse_uint( &ctx->cur, &brackets->ind_array )) {
          report_error( ctx, ""Expected literal unsigned integer"" );
          return FALSE;
       }
       eat_opt_white( &ctx->cur );
       if (*ctx->cur != ')') {
          report_error( ctx, ""Expected `)'"" );
          return FALSE;
       }
       ctx->cur++;
    }
    return TRUE;
 }
 static boolean
 parse_opt_register_src_bracket(
    struct translate_ctx *ctx,
    struct parsed_bracket *brackets,
    int *parsed_brackets)
 {
    const char *cur = ctx->cur;
    *parsed_brackets = 0;
    eat_opt_white( &cur );
    if (cur[0] == '[') {
       ++cur;
       ctx->cur = cur;
       if (!parse_register_bracket(ctx, brackets))
          return FALSE;
       *parsed_brackets = 1;
    }
    return TRUE;
 }
 static boolean
 parse_register_src(
    struct translate_ctx *ctx,
    uint *file,
    struct parsed_bracket *brackets)
 {
    brackets->ind_comp = TGSI_SWIZZLE_X;
    if (!parse_register_file_bracket( ctx, file ))
       return FALSE;
    if (!parse_register_bracket( ctx, brackets ))
        return FALSE;
    return TRUE;
 }
 struct parsed_dcl_bracket {
    uint first;
    uint last;
 };
 static boolean
 parse_register_dcl_bracket(
    struct translate_ctx *ctx,
    struct parsed_dcl_bracket *bracket)
 {
    uint uindex;
    memset(bracket, 0, sizeof(struct parsed_dcl_bracket));
    eat_opt_white( &ctx->cur );
    if (!parse_uint( &ctx->cur, &uindex )) {
       if (ctx->cur[0] == ']' && ctx->implied_array_size != 0) {
          bracket->first = 0;
          bracket->last = ctx->implied_array_size - 1;
          goto cleanup;
       }
       report_error( ctx, ""Expected literal unsigned integer"" );
       return FALSE;
    }
    bracket->first = uindex;
    eat_opt_white( &ctx->cur );
    if (ctx->cur[0] == '.' && ctx->cur[1] == '.') {
       uint uindex;
       ctx->cur += 2;
       eat_opt_white( &ctx->cur );
       if (!parse_uint( &ctx->cur, &uindex )) {
          report_error( ctx, ""Expected literal integer"" );
          return FALSE;
       }
       bracket->last = (int) uindex;
       eat_opt_white( &ctx->cur );
    }
    else {
       bracket->last = bracket->first;
    }
 cleanup:
    if (*ctx->cur != ']') {
       report_error( ctx, ""Expected `]' or `..'"" );
       return FALSE;
    }
    ctx->cur++;
    return TRUE;
 }
 static boolean
 parse_register_dcl(
    struct translate_ctx *ctx,
    uint *file,
    struct parsed_dcl_bracket *brackets,
    int *num_brackets)
 {
    const char *cur;
    *num_brackets = 0;
    if (!parse_register_file_bracket( ctx, file ))
       return FALSE;
    if (!parse_register_dcl_bracket( ctx, &brackets[0] ))
       return FALSE;
    *num_brackets = 1;
    cur = ctx->cur;
    eat_opt_white( &cur );
    if (cur[0] == '[') {
       bool is_in = *file == TGSI_FILE_INPUT;
       bool is_out = *file == TGSI_FILE_OUTPUT;
       ++cur;
       ctx->cur = cur;
       if (!parse_register_dcl_bracket( ctx, &brackets[1] ))
          return FALSE;
       if ((ctx->processor == TGSI_PROCESSOR_GEOMETRY && is_in) ||
           (ctx->processor == TGSI_PROCESSOR_TESS_EVAL && is_in) ||
           (ctx->processor == TGSI_PROCESSOR_TESS_CTRL && (is_in || is_out))) {
          brackets[0] = brackets[1];
          *num_brackets = 1;
       } else {
          *num_brackets = 2;
       }
    }
    return TRUE;
 }
 static boolean
 parse_register_dst(
    struct translate_ctx *ctx,
    uint *file,
    struct parsed_bracket *brackets)
 {
    brackets->ind_comp = TGSI_SWIZZLE_X;
    if (!parse_register_file_bracket( ctx, file ))
       return FALSE;
    if (!parse_register_bracket( ctx, brackets ))
        return FALSE;
    return TRUE;
 }
 static boolean
 parse_dst_operand(
    struct translate_ctx *ctx,
    struct tgsi_full_dst_register *dst )
 {
    uint file;
    uint writemask;
    const char *cur;
    struct parsed_bracket bracket[2];
    int parsed_opt_brackets;
    if (!parse_register_dst( ctx, &file, &bracket[0] ))
       return FALSE;
    if (!parse_opt_register_src_bracket(ctx, &bracket[1], &parsed_opt_brackets))
       return FALSE;
    cur = ctx->cur;
    eat_opt_white( &cur );
    if (!parse_opt_writemask( ctx, &writemask ))
       return FALSE;
    dst->Register.File = file;
    if (parsed_opt_brackets) {
       dst->Register.Dimension = 1;
       dst->Dimension.Indirect = 0;
       dst->Dimension.Dimension = 0;
       dst->Dimension.Index = bracket[0].index;
       if (bracket[0].ind_file != TGSI_FILE_NULL) {
          dst->Dimension.Indirect = 1;
          dst->DimIndirect.File = bracket[0].ind_file;
          dst->DimIndirect.Index = bracket[0].ind_index;
          dst->DimIndirect.Swizzle = bracket[0].ind_comp;
          dst->DimIndirect.ArrayID = bracket[0].ind_array;
       }
       bracket[0] = bracket[1];
    }
    dst->Register.Index = bracket[0].index;
    dst->Register.WriteMask = writemask;
    if (bracket[0].ind_file != TGSI_FILE_NULL) {
       dst->Register.Indirect = 1;
       dst->Indirect.File = bracket[0].ind_file;
       dst->Indirect.Index = bracket[0].ind_index;
       dst->Indirect.Swizzle = bracket[0].ind_comp;
       dst->Indirect.ArrayID = bracket[0].ind_array;
    }
    return TRUE;
 }
 static boolean
 parse_optional_swizzle(
    struct translate_ctx *ctx,
    uint *swizzle,
    boolean *parsed_swizzle,
    int components)
 {
    const char *cur = ctx->cur;
    *parsed_swizzle = FALSE;
    eat_opt_white( &cur );
    if (*cur == '.') {
       uint i;
       cur++;
       eat_opt_white( &cur );
       for (i = 0; i < components; i++) {
          if (uprcase( *cur ) == 'X')
             swizzle[i] = TGSI_SWIZZLE_X;
          else if (uprcase( *cur ) == 'Y')
             swizzle[i] = TGSI_SWIZZLE_Y;
          else if (uprcase( *cur ) == 'Z')
             swizzle[i] = TGSI_SWIZZLE_Z;
          else if (uprcase( *cur ) == 'W')
             swizzle[i] = TGSI_SWIZZLE_W;
          else {
 	    report_error( ctx, ""Expected register swizzle component `x', `y', `z' or `w'"" );
 	    return FALSE;
          }
          cur++;
       }
       *parsed_swizzle = TRUE;
       ctx->cur = cur;
    }
    return TRUE;
 }
 static boolean
 parse_src_operand(
    struct translate_ctx *ctx,
    struct tgsi_full_src_register *src )
 {
    uint file;
    uint swizzle[4];
    boolean parsed_swizzle;
    struct parsed_bracket bracket[2];
    int parsed_opt_brackets;
    if (*ctx->cur == '-') {
       ctx->cur++;
       eat_opt_white( &ctx->cur );
       src->Register.Negate = 1;
    }
    if (*ctx->cur == '|') {
       ctx->cur++;
       eat_opt_white( &ctx->cur );
       src->Register.Absolute = 1;
    }
    if (!parse_register_src(ctx, &file, &bracket[0]))
       return FALSE;
    if (!parse_opt_register_src_bracket(ctx, &bracket[1], &parsed_opt_brackets))
       return FALSE;
    src->Register.File = file;
    if (parsed_opt_brackets) {
       src->Register.Dimension = 1;
       src->Dimension.Indirect = 0;
       src->Dimension.Dimension = 0;
       src->Dimension.Index = bracket[0].index;
       if (bracket[0].ind_file != TGSI_FILE_NULL) {
          src->Dimension.Indirect = 1;
          src->DimIndirect.File = bracket[0].ind_file;
          src->DimIndirect.Index = bracket[0].ind_index;
          src->DimIndirect.Swizzle = bracket[0].ind_comp;
          src->DimIndirect.ArrayID = bracket[0].ind_array;
       }
       bracket[0] = bracket[1];
    }
    src->Register.Index = bracket[0].index;
    if (bracket[0].ind_file != TGSI_FILE_NULL) {
       src->Register.Indirect = 1;
       src->Indirect.File = bracket[0].ind_file;
       src->Indirect.Index = bracket[0].ind_index;
       src->Indirect.Swizzle = bracket[0].ind_comp;
       src->Indirect.ArrayID = bracket[0].ind_array;
    }
    if (parse_optional_swizzle( ctx, swizzle, &parsed_swizzle, 4 )) {
       if (parsed_swizzle) {
          src->Register.SwizzleX = swizzle[0];
          src->Register.SwizzleY = swizzle[1];
          src->Register.SwizzleZ = swizzle[2];
          src->Register.SwizzleW = swizzle[3];
       }
    }
    if (src->Register.Absolute) {
       eat_opt_white( &ctx->cur );
       if (*ctx->cur != '|') {
          report_error( ctx, ""Expected `|'"" );
          return FALSE;
       }
       ctx->cur++;
    }
    return TRUE;
 }
 static boolean
 parse_texoffset_operand(
    struct translate_ctx *ctx,
    struct tgsi_texture_offset *src )
 {
    uint file;
    uint swizzle[3];
    boolean parsed_swizzle;
    struct parsed_bracket bracket;
    if (!parse_register_src(ctx, &file, &bracket))
       return FALSE;
    src->File = file;
    src->Index = bracket.index;
    if (parse_optional_swizzle( ctx, swizzle, &parsed_swizzle, 3 )) {
       if (parsed_swizzle) {
          src->SwizzleX = swizzle[0];
          src->SwizzleY = swizzle[1];
          src->SwizzleZ = swizzle[2];
       }
    }
    return TRUE;
 }
 static boolean
 match_inst(const char **pcur,
            unsigned *saturate,
            const struct tgsi_opcode_info *info)
 {
    const char *cur = *pcur;
    if (str_match_nocase_whole(&cur, info->mnemonic)) {
       *pcur = cur;
       *saturate = 0;
       return TRUE;
    }
    if (str_match_no_case(&cur, info->mnemonic)) {
       if (str_match_nocase_whole(&cur, ""_SAT"")) {
          *pcur = cur;
          *saturate = 1;
          return TRUE;
       }
    }
    return FALSE;
 }
 static boolean
 parse_instruction(
    struct translate_ctx *ctx,
    boolean has_label )
 {
    uint i;
    uint saturate = 0;
    const struct tgsi_opcode_info *info;
    struct tgsi_full_instruction inst;
    const char *cur;
    uint advance;
    inst = tgsi_default_full_instruction();
    eat_opt_white( &ctx->cur );
    if (*ctx->cur == '(') {
       uint file;
       int index;
       uint swizzle[4];
       boolean parsed_swizzle;
       inst.Instruction.Predicate = 1;
       ctx->cur++;
       if (*ctx->cur == '!') {
          ctx->cur++;
          inst.Predicate.Negate = 1;
       }
       if (!parse_register_1d( ctx, &file, &index ))
          return FALSE;
       if (parse_optional_swizzle( ctx, swizzle, &parsed_swizzle, 4 )) {
          if (parsed_swizzle) {
             inst.Predicate.SwizzleX = swizzle[0];
             inst.Predicate.SwizzleY = swizzle[1];
             inst.Predicate.SwizzleZ = swizzle[2];
             inst.Predicate.SwizzleW = swizzle[3];
          }
       }
       if (*ctx->cur != ')') {
          report_error( ctx, ""Expected `)'"" );
          return FALSE;
       }
       ctx->cur++;
    }
    eat_opt_white( &ctx->cur );
    for (i = 0; i < TGSI_OPCODE_LAST; i++) {
       cur = ctx->cur;
       info = tgsi_get_opcode_info( i );
       if (match_inst(&cur, &saturate, info)) {
          if (info->num_dst + info->num_src + info->is_tex == 0) {
             ctx->cur = cur;
             break;
          }
          else if (*cur == '\0' || eat_white( &cur )) {
             ctx->cur = cur;
             break;
          }
       }
    }
    if (i == TGSI_OPCODE_LAST) {
       if (has_label)
          report_error( ctx, ""Unknown opcode"" );
       else
          report_error( ctx, ""Expected `DCL', `IMM' or a label"" );
       return FALSE;
    }
    inst.Instruction.Opcode = i;
    inst.Instruction.Saturate = saturate;
    inst.Instruction.NumDstRegs = info->num_dst;
    inst.Instruction.NumSrcRegs = info->num_src;
    if (i >= TGSI_OPCODE_SAMPLE && i <= TGSI_OPCODE_GATHER4) {
       inst.Instruction.Texture = 1;
       inst.Texture.Texture = TGSI_TEXTURE_UNKNOWN;
    }
    for (i = 0; i < info->num_dst + info->num_src + info->is_tex; i++) {
       if (i > 0) {
          eat_opt_white( &ctx->cur );
          if (*ctx->cur != ',') {
             report_error( ctx, ""Expected `,'"" );
             return FALSE;
          }
          ctx->cur++;
          eat_opt_white( &ctx->cur );
       }
       if (i < info->num_dst) {
          if (!parse_dst_operand( ctx, &inst.Dst[i] ))
             return FALSE;
       }
       else if (i < info->num_dst + info->num_src) {
          if (!parse_src_operand( ctx, &inst.Src[i - info->num_dst] ))
             return FALSE;
       }
       else {
          uint j;
          for (j = 0; j < TGSI_TEXTURE_COUNT; j++) {
             if (str_match_nocase_whole( &ctx->cur, tgsi_texture_names[j] )) {
                inst.Instruction.Texture = 1;
                inst.Texture.Texture = j;
                break;
             }
          }
          if (j == TGSI_TEXTURE_COUNT) {
             report_error( ctx, ""Expected texture target"" );
             return FALSE;
          }
       }
    }
    cur = ctx->cur;
    eat_opt_white( &cur );
    for (i = 0; inst.Instruction.Texture && *cur == ','; i++) {
          cur++;
          eat_opt_white( &cur );
          ctx->cur = cur;
          if (!parse_texoffset_operand( ctx, &inst.TexOffsets[i] ))
             return FALSE;
          cur = ctx->cur;
          eat_opt_white( &cur );
    }
    inst.Texture.NumOffsets = i;
    cur = ctx->cur;
    eat_opt_white( &cur );
    if (info->is_branch && *cur == ':') {
       uint target;
       cur++;
       eat_opt_white( &cur );
       if (!parse_uint( &cur, &target )) {
          report_error( ctx, ""Expected a label"" );
          return FALSE;
       }
       inst.Instruction.Label = 1;
       inst.Label.Label = target;
       ctx->cur = cur;
    }
    advance = tgsi_build_full_instruction(
       &inst,
       ctx->tokens_cur,
       ctx->header,
       (uint) (ctx->tokens_end - ctx->tokens_cur) );
    if (advance == 0)
       return FALSE;
    ctx->tokens_cur += advance;
    return TRUE;
 }
 static boolean parse_immediate_data(struct translate_ctx *ctx, unsigned type,
                                     union tgsi_immediate_data *values)
 {
    unsigned i;
    int ret;
    eat_opt_white( &ctx->cur );
    if (*ctx->cur != '{') {
       report_error( ctx, ""Expected `{'"" );
       return FALSE;
    }
    ctx->cur++;
    for (i = 0; i < 4; i++) {
       eat_opt_white( &ctx->cur );
       if (i > 0) {
          if (*ctx->cur != ',') {
             report_error( ctx, ""Expected `,'"" );
             return FALSE;
          }
          ctx->cur++;
          eat_opt_white( &ctx->cur );
       }
       switch (type) {
       case TGSI_IMM_FLOAT64:
          ret = parse_double(&ctx->cur, &values[i].Uint, &values[i+1].Uint);
          i++;
          break;
       case TGSI_IMM_FLOAT32:
          ret = parse_float(&ctx->cur, &values[i].Float);
          break;
       case TGSI_IMM_UINT32:
          ret = parse_uint(&ctx->cur, &values[i].Uint);
          break;
       case TGSI_IMM_INT32:
          ret = parse_int(&ctx->cur, &values[i].Int);
          break;
       default:
          assert(0);
          ret = FALSE;
          break;
       }
       if (!ret) {
          report_error( ctx, ""Expected immediate constant"" );
          return FALSE;
       }
    }
    eat_opt_white( &ctx->cur );
    if (*ctx->cur != '}') {
       report_error( ctx, ""Expected `}'"" );
       return FALSE;
    }
    ctx->cur++;
    return TRUE;
 }
 static boolean parse_declaration( struct translate_ctx *ctx )
 {
    struct tgsi_full_declaration decl;
    uint file;
    struct parsed_dcl_bracket brackets[2];
    int num_brackets;
    uint writemask;
    const char *cur, *cur2;
    uint advance;
    boolean is_vs_input;
    if (!eat_white( &ctx->cur )) {
       report_error( ctx, ""Syntax error"" );
       return FALSE;
    }
    if (!parse_register_dcl( ctx, &file, brackets, &num_brackets))
       return FALSE;
    if (!parse_opt_writemask( ctx, &writemask ))
       return FALSE;
    decl = tgsi_default_full_declaration();
    decl.Declaration.File = file;
    decl.Declaration.UsageMask = writemask;
    if (num_brackets == 1) {
       decl.Range.First = brackets[0].first;
       decl.Range.Last = brackets[0].last;
    } else {
       decl.Range.First = brackets[1].first;
       decl.Range.Last = brackets[1].last;
       decl.Declaration.Dimension = 1;
       decl.Dim.Index2D = brackets[0].first;
    }
    is_vs_input = (file == TGSI_FILE_INPUT &&
                   ctx->processor == TGSI_PROCESSOR_VERTEX);
    cur = ctx->cur;
    eat_opt_white( &cur );
    if (*cur == ',') {
       cur2 = cur;
       cur2++;
       eat_opt_white( &cur2 );
       if (str_match_nocase_whole( &cur2, ""ARRAY"" )) {
          int arrayid;
          if (*cur2 != '(') {
             report_error( ctx, ""Expected `('"" );
             return FALSE;
          }
          cur2++;
          eat_opt_white( &cur2 );
          if (!parse_int( &cur2, &arrayid )) {
             report_error( ctx, ""Expected `,'"" );
             return FALSE;
          }
          eat_opt_white( &cur2 );
          if (*cur2 != ')') {
             report_error( ctx, ""Expected `)'"" );
             return FALSE;
          }
          cur2++;
          decl.Declaration.Array = 1;
          decl.Array.ArrayID = arrayid;
          ctx->cur = cur = cur2;
       }
    }
    if (*cur == ',' && !is_vs_input) {
       uint i, j;
       cur++;
       eat_opt_white( &cur );
       if (file == TGSI_FILE_RESOURCE) {
          for (i = 0; i < TGSI_TEXTURE_COUNT; i++) {
             if (str_match_nocase_whole(&cur, tgsi_texture_names[i])) {
                decl.Resource.Resource = i;
                break;
             }
          }
          if (i == TGSI_TEXTURE_COUNT) {
             report_error(ctx, ""Expected texture target"");
             return FALSE;
          }
          cur2 = cur;
          eat_opt_white(&cur2);
          while (*cur2 == ',') {
             cur2++;
             eat_opt_white(&cur2);
             if (str_match_nocase_whole(&cur2, ""RAW"")) {
                decl.Resource.Raw = 1;
             } else if (str_match_nocase_whole(&cur2, ""WR"")) {
                decl.Resource.Writable = 1;
             } else {
                break;
             }
             cur = cur2;
             eat_opt_white(&cur2);
          }
          ctx->cur = cur;
       } else if (file == TGSI_FILE_SAMPLER_VIEW) {
          for (i = 0; i < TGSI_TEXTURE_COUNT; i++) {
             if (str_match_nocase_whole(&cur, tgsi_texture_names[i])) {
                decl.SamplerView.Resource = i;
                break;
             }
          }
          if (i == TGSI_TEXTURE_COUNT) {
             report_error(ctx, ""Expected texture target"");
             return FALSE;
          }
          eat_opt_white( &cur );
          if (*cur != ',') {
             report_error( ctx, ""Expected `,'"" );
             return FALSE;
          }
          ++cur;
          eat_opt_white( &cur );
          for (j = 0; j < 4; ++j) {
             for (i = 0; i < TGSI_RETURN_TYPE_COUNT; ++i) {
                if (str_match_nocase_whole(&cur, tgsi_return_type_names[i])) {
                   switch (j) {
                   case 0:
                      decl.SamplerView.ReturnTypeX = i;
                      break;
                   case 1:
                      decl.SamplerView.ReturnTypeY = i;
                      break;
                   case 2:
                      decl.SamplerView.ReturnTypeZ = i;
                      break;
                   case 3:
                      decl.SamplerView.ReturnTypeW = i;
                      break;
                   default:
                      assert(0);
                   }
                   break;
                }
             }
             if (i == TGSI_RETURN_TYPE_COUNT) {
                if (j == 0 || j >  2) {
                   report_error(ctx, ""Expected type name"");
                   return FALSE;
                }
                break;
             } else {
                cur2 = cur;
                eat_opt_white( &cur2 );
                if (*cur2 == ',') {
                   cur2++;
                   eat_opt_white( &cur2 );
                   cur = cur2;
                   continue;
                } else
                   break;
             }
          }
          if (j < 4) {
             decl.SamplerView.ReturnTypeY =
                decl.SamplerView.ReturnTypeZ =
                decl.SamplerView.ReturnTypeW =
                decl.SamplerView.ReturnTypeX;
          }
          ctx->cur = cur;
       } else {
          if (str_match_nocase_whole(&cur, ""LOCAL"")) {
             decl.Declaration.Local = 1;
             ctx->cur = cur;
          }
          cur = ctx->cur;
          eat_opt_white( &cur );
          if (*cur == ',') {
             cur++;
             eat_opt_white( &cur );
             for (i = 0; i < TGSI_SEMANTIC_COUNT; i++) {
                if (str_match_nocase_whole(&cur, tgsi_semantic_names[i])) {
                   uint index;
                   cur2 = cur;
                   eat_opt_white( &cur2 );
                   if (*cur2 == '[') {
                      cur2++;
                      eat_opt_white( &cur2 );
                      if (!parse_uint( &cur2, &index )) {
                         report_error( ctx, ""Expected literal integer"" );
                         return FALSE;
                      }
                      eat_opt_white( &cur2 );
                      if (*cur2 != ']') {
                         report_error( ctx, ""Expected `]'"" );
                         return FALSE;
                      }
                      cur2++;
                      decl.Semantic.Index = index;
                      cur = cur2;
                   }
                   decl.Declaration.Semantic = 1;
                   decl.Semantic.Name = i;
                   ctx->cur = cur;
                   break;
                }
             }
          }
       }
    }
    cur = ctx->cur;
    eat_opt_white( &cur );
    if (*cur == ',' && !is_vs_input) {
       uint i;
       cur++;
       eat_opt_white( &cur );
       for (i = 0; i < TGSI_INTERPOLATE_COUNT; i++) {
          if (str_match_nocase_whole( &cur, tgsi_interpolate_names[i] )) {
             decl.Declaration.Interpolate = 1;
             decl.Interp.Interpolate = i;
             ctx->cur = cur;
             break;
          }
       }
       if (i == TGSI_INTERPOLATE_COUNT) {
          report_error( ctx, ""Expected semantic or interpolate attribute"" );
          return FALSE;
       }
    }
    cur = ctx->cur;
    eat_opt_white( &cur );
    if (*cur == ',' && !is_vs_input) {
       uint i;
       cur++;
       eat_opt_white( &cur );
       for (i = 0; i < TGSI_INTERPOLATE_LOC_COUNT; i++) {
          if (str_match_nocase_whole( &cur, tgsi_interpolate_locations[i] )) {
             decl.Interp.Location = i;
             ctx->cur = cur;
             break;
          }
       }
    }
    advance = tgsi_build_full_declaration(
       &decl,
       ctx->tokens_cur,
       ctx->header,
       (uint) (ctx->tokens_end - ctx->tokens_cur) );
    if (advance == 0)
       return FALSE;
    ctx->tokens_cur += advance;
    return TRUE;
 }
 static boolean parse_immediate( struct translate_ctx *ctx )
 {
    struct tgsi_full_immediate imm;
    uint advance;
    int type;
    if (*ctx->cur == '[') {
       uint uindex;
       ++ctx->cur;
       eat_opt_white( &ctx->cur );
       if (!parse_uint( &ctx->cur, &uindex )) {
          report_error( ctx, ""Expected literal unsigned integer"" );
          return FALSE;
       }
       if (uindex != ctx->num_immediates) {
          report_error( ctx, ""Immediates must be sorted"" );
          return FALSE;
       }
       eat_opt_white( &ctx->cur );
       if (*ctx->cur != ']') {
          report_error( ctx, ""Expected `]'"" );
          return FALSE;
       }
       ctx->cur++;
    }
    if (!eat_white( &ctx->cur )) {
       report_error( ctx, ""Syntax error"" );
       return FALSE;
    }
    for (type = 0; type < Elements(tgsi_immediate_type_names); ++type) {
       if (str_match_nocase_whole(&ctx->cur, tgsi_immediate_type_names[type]))
          break;
    }
    if (type == Elements(tgsi_immediate_type_names)) {
       report_error( ctx, ""Expected immediate type"" );
       return FALSE;
    }
    imm = tgsi_default_full_immediate();
    imm.Immediate.NrTokens += 4;
    imm.Immediate.DataType = type;
    parse_immediate_data(ctx, type, imm.u);
    advance = tgsi_build_full_immediate(
       &imm,
       ctx->tokens_cur,
       ctx->header,
       (uint) (ctx->tokens_end - ctx->tokens_cur) );
    if (advance == 0)
       return FALSE;
    ctx->tokens_cur += advance;
    ctx->num_immediates++;
    return TRUE;
 }
 static boolean
 parse_primitive( const char **pcur, uint *primitive )
 {
    uint i;
    for (i = 0; i < PIPE_PRIM_MAX; i++) {
       const char *cur = *pcur;
       if (str_match_nocase_whole( &cur, tgsi_primitive_names[i])) {
          *primitive = i;
          *pcur = cur;
          return TRUE;
       }
    }
    return FALSE;
 }
 static boolean
 parse_fs_coord_origin( const char **pcur, uint *fs_coord_origin )
 {
    uint i;
    for (i = 0; i < Elements(tgsi_fs_coord_origin_names); i++) {
       const char *cur = *pcur;
       if (str_match_nocase_whole( &cur, tgsi_fs_coord_origin_names[i])) {
          *fs_coord_origin = i;
          *pcur = cur;
          return TRUE;
       }
    }
    return FALSE;
 }
 static boolean
 parse_fs_coord_pixel_center( const char **pcur, uint *fs_coord_pixel_center )
 {
    uint i;
    for (i = 0; i < Elements(tgsi_fs_coord_pixel_center_names); i++) {
       const char *cur = *pcur;
       if (str_match_nocase_whole( &cur, tgsi_fs_coord_pixel_center_names[i])) {
          *fs_coord_pixel_center = i;
          *pcur = cur;
          return TRUE;
       }
    }
    return FALSE;
 }
 static boolean parse_property( struct translate_ctx *ctx )
 {
    struct tgsi_full_property prop;
    uint property_name;
    uint values[8];
    uint advance;
    char id[64];
    if (!eat_white( &ctx->cur )) {
       report_error( ctx, ""Syntax error"" );
       return FALSE;
    }
        report_error( ctx, ""Syntax error"" );
        return FALSE;
     }
   if (!parse_identifier( &ctx->cur, id )) {
    if (!parse_identifier( &ctx->cur, id, sizeof(id) )) {
        report_error( ctx, ""Syntax error"" );
        return FALSE;
     }
          break;
       }
    }","[2, 8, 9, 10, 11, 13, 1183, 1184]",Stack-based buffer overflow in the parse_identifier function in tgsi_text.c in the TGSI auxiliary module in the Gallium driver in virglrenderer before 0.6.0 allows local guest OS users to cause a denial of service (out-of-bounds array access and QEMU process crash) via vectors related to parsing properties.,virglrenderer,CVE-2017-6209,CWE-119
3783,182981," seamless_process_line(const char *line, void *data)
 {
 	UNUSED(data);
 	char *p, *l;
 	char *tok1, *tok3, *tok4, *tok5, *tok6, *tok7, *tok8;
 	unsigned long id, flags;
 	char *endptr;
 	l = xstrdup(line);
 	p = l;
 	logger(Core, Debug, ""seamless_process_line(), got '%s'"", p);
 	tok1 = seamless_get_token(&p);
 	(void) seamless_get_token(&p);
 	tok3 = seamless_get_token(&p);
 	tok4 = seamless_get_token(&p);
 	tok5 = seamless_get_token(&p);
 	tok6 = seamless_get_token(&p);
 	tok7 = seamless_get_token(&p);
 	tok8 = seamless_get_token(&p);
 	if (!strcmp(""CREATE"", tok1))
 	{
 		unsigned long group, parent;
 		if (!tok6)
 			return False;
 		id = strtoul(tok3, &endptr, 0);
 		if (*endptr)
 			return False;
 		group = strtoul(tok4, &endptr, 0);
 		if (*endptr)
 			return False;
 		parent = strtoul(tok5, &endptr, 0);
 		if (*endptr)
 			return False;
 		flags = strtoul(tok6, &endptr, 0);
 		if (*endptr)
 			return False;
 		ui_seamless_create_window(id, group, parent, flags);
 	}
 	else if (!strcmp(""DESTROY"", tok1))
 	{
 		if (!tok4)
 			return False;
 		id = strtoul(tok3, &endptr, 0);
 		if (*endptr)
 			return False;
 		flags = strtoul(tok4, &endptr, 0);
 		if (*endptr)
 			return False;
 		ui_seamless_destroy_window(id, flags);
 	}
 	else if (!strcmp(""DESTROYGRP"", tok1))
 	{
 		if (!tok4)
 			return False;
 		id = strtoul(tok3, &endptr, 0);
 		if (*endptr)
 			return False;
 		flags = strtoul(tok4, &endptr, 0);
 		if (*endptr)
 			return False;
 		ui_seamless_destroy_group(id, flags);
 	}
 	else if (!strcmp(""SETICON"", tok1))
 	{
 		int chunk, width, height, len;
 		char byte[3];
 		if (!tok8)
 			return False;
 		id = strtoul(tok3, &endptr, 0);
 		if (*endptr)
 			return False;
 		chunk = strtoul(tok4, &endptr, 0);
 		if (*endptr)
 			return False;
 		width = strtoul(tok6, &endptr, 0);
 		if (*endptr)
 			return False;
 		height = strtoul(tok7, &endptr, 0);
 		if (*endptr)
 			return False;
 		byte[2] = '\0';
 		len = 0;
 		while (*tok8 != '\0')
 		{
 			byte[0] = *tok8;
 			tok8++;
 			if (*tok8 == '\0')
 				return False;
 			byte[1] = *tok8;
 			tok8++;
  			icon_buf[len] = strtol(byte, NULL, 16);
  			len++;
 			if ((size_t)len >= sizeof(icon_buf))
 			{
 				logger(Protocol, Warning, ""seamless_process_line(), icon data would overrun icon_buf"");
 				break;
 			}
  		}
  		ui_seamless_seticon(id, tok5, width, height, chunk, icon_buf, len);
 	}
 	else if (!strcmp(""DELICON"", tok1))
 	{
 		int width, height;
 		if (!tok6)
 			return False;
 		id = strtoul(tok3, &endptr, 0);
 		if (*endptr)
 			return False;
 		width = strtoul(tok5, &endptr, 0);
 		if (*endptr)
 			return False;
 		height = strtoul(tok6, &endptr, 0);
 		if (*endptr)
 			return False;
 		ui_seamless_delicon(id, tok4, width, height);
 	}
 	else if (!strcmp(""POSITION"", tok1))
 	{
 		int x, y, width, height;
 		if (!tok8)
 			return False;
 		id = strtoul(tok3, &endptr, 0);
 		if (*endptr)
 			return False;
 		x = strtol(tok4, &endptr, 0);
 		if (*endptr)
 			return False;
 		y = strtol(tok5, &endptr, 0);
 		if (*endptr)
 			return False;
 		width = strtol(tok6, &endptr, 0);
 		if (*endptr)
 			return False;
 		height = strtol(tok7, &endptr, 0);
 		if (*endptr)
 			return False;
 		flags = strtoul(tok8, &endptr, 0);
 		if (*endptr)
 			return False;
 		ui_seamless_move_window(id, x, y, width, height, flags);
 	}
 	else if (!strcmp(""ZCHANGE"", tok1))
 	{
 		unsigned long behind;
 		id = strtoul(tok3, &endptr, 0);
 		if (*endptr)
 			return False;
 		behind = strtoul(tok4, &endptr, 0);
 		if (*endptr)
 			return False;
 		flags = strtoul(tok5, &endptr, 0);
 		if (*endptr)
 			return False;
 		ui_seamless_restack_window(id, behind, flags);
 	}
 	else if (!strcmp(""TITLE"", tok1))
 	{
 		if (!tok5)
 			return False;
 		id = strtoul(tok3, &endptr, 0);
 		if (*endptr)
 			return False;
 		flags = strtoul(tok5, &endptr, 0);
 		if (*endptr)
 			return False;
 		ui_seamless_settitle(id, tok4, flags);
 	}
 	else if (!strcmp(""STATE"", tok1))
 	{
 		unsigned int state;
 		if (!tok5)
 			return False;
 		id = strtoul(tok3, &endptr, 0);
 		if (*endptr)
 			return False;
 		state = strtoul(tok4, &endptr, 0);
 		if (*endptr)
 			return False;
 		flags = strtoul(tok5, &endptr, 0);
 		if (*endptr)
 			return False;
 		ui_seamless_setstate(id, state, flags);
 	}
 	else if (!strcmp(""DEBUG"", tok1))
 	{
 		logger(Core, Debug, ""seamless_process_line(), %s"", line);
 	}
 	else if (!strcmp(""SYNCBEGIN"", tok1))
 	{
 		if (!tok3)
 			return False;
 		flags = strtoul(tok3, &endptr, 0);
 		if (*endptr)
 			return False;
 		ui_seamless_syncbegin(flags);
 	}
 	else if (!strcmp(""SYNCEND"", tok1))
 	{
 		if (!tok3)
 			return False;
 		flags = strtoul(tok3, &endptr, 0);
 		if (*endptr)
 			return False;
 	}
 	else if (!strcmp(""HELLO"", tok1))
 	{
 		if (!tok3)
 			return False;
 		flags = strtoul(tok3, &endptr, 0);
 		if (*endptr)
 			return False;
 		ui_seamless_begin(! !(flags & SEAMLESSRDP_HELLO_HIDDEN));
 	}
 	else if (!strcmp(""ACK"", tok1))
 	{
 		unsigned int serial;
 		serial = strtoul(tok3, &endptr, 0);
 		if (*endptr)
 			return False;
 		ui_seamless_ack(serial);
 	}
 	else if (!strcmp(""HIDE"", tok1))
 	{
 		if (!tok3)
 			return False;
 		flags = strtoul(tok3, &endptr, 0);
 		if (*endptr)
 			return False;
 		ui_seamless_hide_desktop();
 	}
 	else if (!strcmp(""UNHIDE"", tok1))
 	{
 		if (!tok3)
 			return False;
 		flags = strtoul(tok3, &endptr, 0);
 		if (*endptr)
 			return False;
 		ui_seamless_unhide_desktop();
 	}
 	xfree(l);
 	return True;
 }","[92, 93, 94, 95, 96]",rdesktop versions up to and including v1.8.3 contain a Buffer Overflow over the global variables in the function seamless_process_line() that results in memory corruption and probably even a remote code execution.,rdesktop,CVE-2018-20182,CWE-119
3790,178131,"  void vrend_set_framebuffer_state(struct vrend_context *ctx,
                                 uint32_t nr_cbufs, uint32_t surf_handle[8],
                                  uint32_t nr_cbufs, uint32_t surf_handle[PIPE_MAX_COLOR_BUFS],
                                   uint32_t zsurf_handle)
  {
     struct vrend_surface *surf, *zsurf;
    int i;
    int old_num;
    GLenum status;
    GLint new_height = -1;
    bool new_ibf = false;
    glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, ctx->sub->fb_id);
    if (zsurf_handle) {
       zsurf = vrend_object_lookup(ctx->sub->object_hash, zsurf_handle, VIRGL_OBJECT_SURFACE);
       if (!zsurf) {
          report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_SURFACE, zsurf_handle);
          return;
       }
    } else
       zsurf = NULL;
    if (ctx->sub->zsurf != zsurf) {
       vrend_surface_reference(&ctx->sub->zsurf, zsurf);
       vrend_hw_set_zsurf_texture(ctx);
    }
    old_num = ctx->sub->nr_cbufs;
    ctx->sub->nr_cbufs = nr_cbufs;
    ctx->sub->old_nr_cbufs = old_num;
    for (i = 0; i < nr_cbufs; i++) {
       if (surf_handle[i] != 0) {
          surf = vrend_object_lookup(ctx->sub->object_hash, surf_handle[i], VIRGL_OBJECT_SURFACE);
          if (!surf) {
             report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_SURFACE, surf_handle[i]);
             return;
          }
       } else
          surf = NULL;
       if (ctx->sub->surf[i] != surf) {
          vrend_surface_reference(&ctx->sub->surf[i], surf);
          vrend_hw_set_color_surface(ctx, i);
       }
    }
    if (old_num > ctx->sub->nr_cbufs) {
       for (i = ctx->sub->nr_cbufs; i < old_num; i++) {
          vrend_surface_reference(&ctx->sub->surf[i], NULL);
          vrend_hw_set_color_surface(ctx, i);
       }
    }
    if (ctx->sub->nr_cbufs == 0 && !ctx->sub->zsurf) {
       new_height = 0;
       new_ibf = false;
    } else if (ctx->sub->nr_cbufs == 0) {
       new_height = u_minify(ctx->sub->zsurf->texture->base.height0, ctx->sub->zsurf->val0);
       new_ibf = ctx->sub->zsurf->texture->y_0_top ? true : false;
    }
    else {
       surf = NULL;
       for (i = 0; i < ctx->sub->nr_cbufs; i++) {
          if (ctx->sub->surf[i]) {
             surf = ctx->sub->surf[i];
             break;
          }
       }
       if (surf == NULL) {
          report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_SURFACE, i);
          return;
       }
       new_height = u_minify(surf->texture->base.height0, surf->val0);
       new_ibf = surf->texture->y_0_top ? true : false;
    }
    if (new_height != -1) {
       if (ctx->sub->fb_height != new_height || ctx->sub->inverted_fbo_content != new_ibf) {
          ctx->sub->fb_height = new_height;
          ctx->sub->inverted_fbo_content = new_ibf;
          ctx->sub->scissor_state_dirty = (1 << 0);
          ctx->sub->viewport_state_dirty = (1 << 0);
       }
    }
    vrend_hw_emit_framebuffer_state(ctx);
    if (ctx->sub->nr_cbufs > 0 || ctx->sub->zsurf) {
       status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
       if (status != GL_FRAMEBUFFER_COMPLETE)
          fprintf(stderr,""failed to complete framebuffer 0x%x %s\n"", status, ctx->debug_name);
    }
    ctx->sub->shader_dirty = true;
 }","[2, 3]",The util_format_is_pure_uint function in vrend_renderer.c in Virgil 3d project (aka virglrenderer) 0.6.0 and earlier allows local guest OS users to cause a denial of service (NULL pointer dereference) via a crafted VIRGL_CCMD_CLEAR command.,virglrenderer,CVE-2017-5937,CWE-476
3798,182231," auth_select_file(struct sc_card *card, const struct sc_path *in_path,
 				 struct sc_file **file_out)
 {
 	struct sc_path path;
 	struct sc_file *tmp_file = NULL;
 	size_t offs, ii;
 	int rv;
 	LOG_FUNC_CALLED(card->ctx);
 	assert(card != NULL && in_path != NULL);
  	memcpy(&path, in_path, sizeof(struct sc_path));
 	if (!auth_current_df)
 		return SC_ERROR_OBJECT_NOT_FOUND;
  	sc_log(card->ctx, ""in_path; type=%d, path=%s, out %p"",
  			in_path->type, sc_print_path(in_path), file_out);
  	sc_log(card->ctx, ""current path; type=%d, path=%s"",
 			auth_current_df->path.type, sc_print_path(&auth_current_df->path));
 	if (auth_current_ef)
 		sc_log(card->ctx, ""current file; type=%d, path=%s"",
 				auth_current_ef->path.type, sc_print_path(&auth_current_ef->path));
 	if (path.type == SC_PATH_TYPE_PARENT || path.type == SC_PATH_TYPE_FILE_ID)   {
 		sc_file_free(auth_current_ef);
 		auth_current_ef = NULL;
 		rv = iso_ops->select_file(card, &path, &tmp_file);
 		LOG_TEST_RET(card->ctx, rv, ""select file failed"");
 		if (!tmp_file)
 			return SC_ERROR_OBJECT_NOT_FOUND;
 		if (path.type == SC_PATH_TYPE_PARENT)   {
 			memcpy(&tmp_file->path, &auth_current_df->path, sizeof(struct sc_path));
 			if (tmp_file->path.len > 2)
 				tmp_file->path.len -= 2;
 			sc_file_free(auth_current_df);
 			sc_file_dup(&auth_current_df, tmp_file);
 		}
 		else   {
 			if (tmp_file->type == SC_FILE_TYPE_DF)   {
 				sc_concatenate_path(&tmp_file->path, &auth_current_df->path, &path);
 				sc_file_free(auth_current_df);
 				sc_file_dup(&auth_current_df, tmp_file);
 			}
 			else   {
 				sc_file_free(auth_current_ef);
 				sc_file_dup(&auth_current_ef, tmp_file);
 				sc_concatenate_path(&auth_current_ef->path, &auth_current_df->path, &path);
 			}
 		}
 		if (file_out)
 			sc_file_dup(file_out, tmp_file);
 		sc_file_free(tmp_file);
 	}
 	else if (path.type == SC_PATH_TYPE_DF_NAME)   {
 		rv = iso_ops->select_file(card, &path, NULL);
 		if (rv)   {
 			sc_file_free(auth_current_ef);
 			auth_current_ef = NULL;
 		}
 		LOG_TEST_RET(card->ctx, rv, ""select file failed"");
 	}
 	else   {
 		for (offs = 0; offs < path.len && offs < auth_current_df->path.len; offs += 2)
 			if (path.value[offs] != auth_current_df->path.value[offs] ||
 					path.value[offs + 1] != auth_current_df->path.value[offs + 1])
 				break;
 		sc_log(card->ctx, ""offs %""SC_FORMAT_LEN_SIZE_T""u"", offs);
 		if (offs && offs < auth_current_df->path.len)   {
 			size_t deep = auth_current_df->path.len - offs;
 			sc_log(card->ctx, ""deep %""SC_FORMAT_LEN_SIZE_T""u"",
 			       deep);
 			for (ii=0; ii<deep; ii+=2)   {
 				struct sc_path tmp_path;
 				memcpy(&tmp_path, &auth_current_df->path,  sizeof(struct sc_path));
 				tmp_path.type = SC_PATH_TYPE_PARENT;
 				rv = auth_select_file (card, &tmp_path, file_out);
 				LOG_TEST_RET(card->ctx, rv, ""select file failed"");
 			}
 		}
 		if (path.len - offs > 0)   {
 			struct sc_path tmp_path;
 			memset(&tmp_path, 0, sizeof(struct sc_path));
 			tmp_path.type = SC_PATH_TYPE_FILE_ID;
 			tmp_path.len = 2;
 			for (ii=0; ii < path.len - offs; ii+=2)   {
 				memcpy(tmp_path.value, path.value + offs + ii, 2);
 				rv = auth_select_file(card, &tmp_path, file_out);
 				LOG_TEST_RET(card->ctx, rv, ""select file failed"");
 			}
 		}
 		else if (path.len - offs == 0 && file_out)  {
 			if (sc_compare_path(&path, &auth_current_df->path))
 				sc_file_dup(file_out, auth_current_df);
 			else  if (auth_current_ef)
 				sc_file_dup(file_out, auth_current_ef);
 			else
 				LOG_TEST_RET(card->ctx, SC_ERROR_INTERNAL, ""No current EF"");
 		}
 	}
 	LOG_FUNC_RETURN(card->ctx, 0);
 }","[11, 12]",Various out of bounds reads when handling responses in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to potentially crash the opensc library using programs.,OpenSC,CVE-2018-16427,CWE-125
3806,182869,"  void js_RegExp_prototype_exec(js_State *J, js_Regexp *re, const char *text)
  {
 	int result;
  	int i;
  	int opts;
  	Resub m;
 	opts = 0;
 	if (re->flags & JS_REGEXP_G) {
 		if (re->last > strlen(text)) {
 			re->last = 0;
 			js_pushnull(J);
 			return;
 		}
 		if (re->last > 0) {
 			text += re->last;
 			opts |= REG_NOTBOL;
  		}
  	}
	if (!js_regexec(re->prog, text, &m, opts)) {
 	result = js_regexec(re->prog, text, &m, opts);
 	if (result < 0)
 		js_error(J, ""regexec failed"");
 	if (result == 0) {
  		js_newarray(J);
  		js_pushstring(J, text);
  		js_setproperty(J, -2, ""input"");
 		js_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));
 		js_setproperty(J, -2, ""index"");
 		for (i = 0; i < m.nsub; ++i) {
 			js_pushlstring(J, m.sub[i].sp, m.sub[i].ep - m.sub[i].sp);
 			js_setindex(J, -2, i);
 		}
 		if (re->flags & JS_REGEXP_G)
 			re->last = re->last + (m.sub[0].ep - text);
 		return;
 	}
 	if (re->flags & JS_REGEXP_G)
 		re->last = 0;
 	js_pushnull(J);
 }","[3, 19, 20, 21, 22, 23]",An issue was discovered in Artifex MuJS 1.0.5. It has unlimited recursion because the match function in regexp.c lacks a depth check.,mujs,CVE-2019-11413,CWE-400
3843,180839," static int csnmp_read_table(host_definition_t *host, data_definition_t *data) {
   struct snmp_pdu *req;
   struct snmp_pdu *res = NULL;
   struct variable_list *vb;
   const data_set_t *ds;
   size_t oid_list_len = data->values_len + 1;
   oid_t oid_list[oid_list_len];
   _Bool oid_list_todo[oid_list_len];
   int status;
   size_t i;
   csnmp_list_instances_t *instance_list_head;
   csnmp_list_instances_t *instance_list_tail;
   csnmp_table_values_t **value_list_head;
   csnmp_table_values_t **value_list_tail;
   DEBUG(""snmp plugin: csnmp_read_table (host = %s, data = %s)"", host->name,
         data->name);
   if (host->sess_handle == NULL) {
     DEBUG(""snmp plugin: csnmp_read_table: host->sess_handle == NULL"");
     return (-1);
   }
   ds = plugin_get_ds(data->type);
   if (!ds) {
     ERROR(""snmp plugin: DataSet `%s' not defined."", data->type);
     return (-1);
   }
   if (ds->ds_num != data->values_len) {
     ERROR(""snmp plugin: DataSet `%s' requires %zu values, but config talks ""
           ""about %zu"",
           data->type, ds->ds_num, data->values_len);
     return (-1);
   }
   assert(data->values_len > 0);
   memcpy(oid_list, data->values, data->values_len * sizeof(oid_t));
   if (data->instance.oid.oid_len > 0)
     memcpy(oid_list + data->values_len, &data->instance.oid, sizeof(oid_t));
   else  
     oid_list_len--;
   for (i = 0; i < oid_list_len; i++)
     oid_list_todo[i] = 1;
   value_list_head = calloc(data->values_len, sizeof(*value_list_head));
   value_list_tail = calloc(data->values_len, sizeof(*value_list_tail));
   if ((value_list_head == NULL) || (value_list_tail == NULL)) {
     ERROR(""snmp plugin: csnmp_read_table: calloc failed."");
     sfree(value_list_head);
     sfree(value_list_tail);
     return (-1);
   }
   instance_list_head = NULL;
   instance_list_tail = NULL;
   status = 0;
   while (status == 0) {
     int oid_list_todo_num;
     req = snmp_pdu_create(SNMP_MSG_GETNEXT);
     if (req == NULL) {
       ERROR(""snmp plugin: snmp_pdu_create failed."");
       status = -1;
       break;
     }
     oid_list_todo_num = 0;
     for (i = 0; i < oid_list_len; i++) {
       if (!oid_list_todo[i])
         continue;
       oid_list_todo_num++;
       snmp_add_null_var(req, oid_list[i].oid, oid_list[i].oid_len);
     }
      if (oid_list_todo_num == 0) {
        DEBUG(""snmp plugin: all variables have left their subtree"");
       snmp_free_pdu(req);
        status = 0;
        break;
      }
      res = NULL;
      status = snmp_sess_synch_response(host->sess_handle, req, &res);
      if ((status != STAT_SUCCESS) || (res == NULL)) {
        char *errstr = NULL;
       snmp_sess_error(host->sess_handle, NULL, NULL, &errstr);
       c_complain(LOG_ERR, &host->complaint,
                  ""snmp plugin: host %s: snmp_sess_synch_response failed: %s"",
                  host->name, (errstr == NULL) ? ""Unknown problem"" : errstr);
       if (res != NULL)
          snmp_free_pdu(res);
        res = NULL;
      req = NULL;
        sfree(errstr);
        csnmp_host_close_session(host);
       status = -1;
       break;
     }
     status = 0;
     assert(res != NULL);
     c_release(LOG_INFO, &host->complaint,
               ""snmp plugin: host %s: snmp_sess_synch_response successful."",
               host->name);
     vb = res->variables;
     if (vb == NULL) {
       status = -1;
       break;
     }
     for (vb = res->variables, i = 0; (vb != NULL);
          vb = vb->next_variable, i++) {
       while ((i < oid_list_len) && !oid_list_todo[i])
         i++;
       if ((data->instance.oid.oid_len > 0) && (i == data->values_len)) {
         if ((vb->type == SNMP_ENDOFMIBVIEW) ||
             (snmp_oid_ncompare(
                  data->instance.oid.oid, data->instance.oid.oid_len, vb->name,
                  vb->name_length, data->instance.oid.oid_len) != 0)) {
           DEBUG(""snmp plugin: host = %s; data = %s; Instance left its subtree."",
                 host->name, data->name);
           oid_list_todo[i] = 0;
           continue;
         }
         if (csnmp_instance_list_add(&instance_list_head, &instance_list_tail,
                                     res, host, data) != 0) {
           ERROR(""snmp plugin: host %s: csnmp_instance_list_add failed."",
                 host->name);
           status = -1;
           break;
         }
       } else  
       {
         csnmp_table_values_t *vt;
         oid_t vb_name;
         oid_t suffix;
         int ret;
         csnmp_oid_init(&vb_name, vb->name, vb->name_length);
         ret = csnmp_oid_suffix(&suffix, &vb_name, data->values + i);
         if (ret != 0) {
           DEBUG(""snmp plugin: host = %s; data = %s; i = %zu; ""
                 ""Value probably left its subtree."",
                 host->name, data->name, i);
           oid_list_todo[i] = 0;
           continue;
         }
         if ((value_list_tail[i] != NULL) &&
             (csnmp_oid_compare(&suffix, &value_list_tail[i]->suffix) <= 0)) {
           DEBUG(""snmp plugin: host = %s; data = %s; i = %zu; ""
                 ""Suffix is not increasing."",
                 host->name, data->name, i);
           oid_list_todo[i] = 0;
           continue;
         }
         vt = calloc(1, sizeof(*vt));
         if (vt == NULL) {
           ERROR(""snmp plugin: calloc failed."");
           status = -1;
           break;
         }
         vt->value =
             csnmp_value_list_to_value(vb, ds->ds[i].type, data->scale,
                                       data->shift, host->name, data->name);
         memcpy(&vt->suffix, &suffix, sizeof(vt->suffix));
         vt->next = NULL;
         if (value_list_tail[i] == NULL)
           value_list_head[i] = vt;
         else
           value_list_tail[i]->next = vt;
         value_list_tail[i] = vt;
       }
       memcpy(oid_list[i].oid, vb->name, sizeof(oid) * vb->name_length);
       oid_list[i].oid_len = vb->name_length;
     }  
     if (res != NULL)
       snmp_free_pdu(res);
     res = NULL;
   }  
   if (res != NULL)
      snmp_free_pdu(res);
    res = NULL;
  if (req != NULL)
    snmp_free_pdu(req);
  req = NULL;
    if (status == 0)
      csnmp_dispatch_table(host, data, instance_list_head, value_list_head);
   while (instance_list_head != NULL) {
     csnmp_list_instances_t *next = instance_list_head->next;
     sfree(instance_list_head);
     instance_list_head = next;
   }
   for (i = 0; i < data->values_len; i++) {
     while (value_list_head[i] != NULL) {
       csnmp_table_values_t *next = value_list_head[i]->next;
       sfree(value_list_head[i]);
       value_list_head[i] = next;
     }
   }
   sfree(value_list_head);
   sfree(value_list_tail);
   return (0);
 }  ","[68, 83, 170, 171, 172]","The csnmp_read_table function in snmp.c in the SNMP plugin in collectd before 5.6.3 is susceptible to a double free in a certain error case, which could lead to a crash (or potentially have other impact).",collectd,CVE-2017-16820,CWE-415
3857,181934," jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)
 {
 	jas_image_t *image;
 	bmp_hdr_t hdr;
 	bmp_info_t *info;
 	uint_fast16_t cmptno;
 	jas_image_cmptparm_t cmptparms[3];
 	jas_image_cmptparm_t *cmptparm;
 	uint_fast16_t numcmpts;
 	long n;
 	if (optstr) {
 		jas_eprintf(""warning: ignoring BMP decoder options\n"");
 	}
 	jas_eprintf(
 	  ""THE BMP FORMAT IS NOT FULLY SUPPORTED!\n""
 	  ""THAT IS, THE JASPER SOFTWARE CANNOT DECODE ALL TYPES OF BMP DATA.\n""
 	  ""IF YOU HAVE ANY PROBLEMS, PLEASE TRY CONVERTING YOUR IMAGE DATA\n""
 	  ""TO THE PNM FORMAT, AND USING THIS FORMAT INSTEAD.\n""
 	  );
 	if (bmp_gethdr(in, &hdr)) {
  		jas_eprintf(""cannot get header\n"");
  		return 0;
  	}
 	JAS_DBGLOG(1, (
 	  ""BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\n"",
 	  hdr.magic, hdr.siz, hdr.reserved1, hdr.reserved2, hdr.off
 	  ));
  	if (!(info = bmp_getinfo(in))) {
  		jas_eprintf(""cannot get info\n"");
  		return 0;
  	}
 	JAS_DBGLOG(1,
 	  (""BMP information: len %d; width %d; height %d; numplanes %d; ""
 	  ""depth %d; enctype %d; siz %d; hres %d; vres %d; numcolors %d; ""
 	  ""mincolors %d\n"", info->len, info->width, info->height, info->numplanes,
 	  info->depth, info->enctype, info->siz, info->hres, info->vres,
 	  info->numcolors, info->mincolors));
  	if (!bmp_issupported(&hdr, info)) {
 		jas_eprintf(""error: unsupported BMP encoding\n"");
 		bmp_info_destroy(info);
 		return 0;
 	}
 	if ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {
 		jas_eprintf(""error: possibly bad bitmap offset?\n"");
 		return 0;
 	}
 	if (n > 0) {
 		jas_eprintf(""skipping unknown data in BMP file\n"");
 		if (bmp_gobble(in, n)) {
 			bmp_info_destroy(info);
 			return 0;
 		}
 	}
 	numcmpts = bmp_numcmpts(info);
 	for (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,
 	  ++cmptparm) {
 		cmptparm->tlx = 0;
 		cmptparm->tly = 0;
 		cmptparm->hstep = 1;
 		cmptparm->vstep = 1;
 		cmptparm->width = info->width;
 		cmptparm->height = info->height;
 		cmptparm->prec = 8;
 		cmptparm->sgnd = false;
 	}
 	if (!(image = jas_image_create(numcmpts, cmptparms,
 	  JAS_CLRSPC_UNKNOWN))) {
 		bmp_info_destroy(info);
 		return 0;
 	}
 	if (numcmpts == 3) {
 		jas_image_setclrspc(image, JAS_CLRSPC_SRGB);
 		jas_image_setcmpttype(image, 0,
 		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));
 		jas_image_setcmpttype(image, 1,
 		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));
 		jas_image_setcmpttype(image, 2,
 		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));
 	} else {
 		jas_image_setclrspc(image, JAS_CLRSPC_SGRAY);
 		jas_image_setcmpttype(image, 0,
 		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));
 	}
 	if (bmp_getdata(in, info, image)) {
 		bmp_info_destroy(info);
 		jas_image_destroy(image);
 		return 0;
 	}
 	bmp_info_destroy(info);
 	return image;
 }","[24, 25, 26, 27, 32, 33, 34, 35, 36, 37]",The bmp_getdata function in libjasper/bmp/bmp_dec.c in JasPer before 1.900.5 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted BMP image in an imginfo command.,jasper,CVE-2016-8690,CWE-476
3858,179086," int ff_combine_frame(ParseContext *pc, int next, const uint8_t **buf, int *buf_size)
 {
     if(pc->overread){
         av_dlog(NULL, ""overread %d, state:%X next:%d index:%d o_index:%d\n"",
                 pc->overread, pc->state, next, pc->index, pc->overread_index);
         av_dlog(NULL, ""%X %X %X %X\n"", (*buf)[0], (*buf)[1], (*buf)[2], (*buf)[3]);
     }
     for(; pc->overread>0; pc->overread--){
         pc->buffer[pc->index++]= pc->buffer[pc->overread_index++];
     }
     if(!*buf_size && next == END_NOT_FOUND){
         next= 0;
     }
     pc->last_index= pc->index;
      if(next == END_NOT_FOUND){
          void* new_buffer = av_fast_realloc(pc->buffer, &pc->buffer_size, (*buf_size) + pc->index + FF_INPUT_BUFFER_PADDING_SIZE);
        if(!new_buffer)
         if(!new_buffer) {
             pc->index = 0;
              return AVERROR(ENOMEM);
         }
          pc->buffer = new_buffer;
          memcpy(&pc->buffer[pc->index], *buf, *buf_size);
          pc->index += *buf_size;
         return -1;
     }
     *buf_size=
     pc->overread_index= pc->index + next;
      if(pc->index){
          void* new_buffer = av_fast_realloc(pc->buffer, &pc->buffer_size, next + pc->index + FF_INPUT_BUFFER_PADDING_SIZE);
        if(!new_buffer)
         if(!new_buffer) {
             pc->overread_index =
             pc->index = 0;
              return AVERROR(ENOMEM);
         }
          pc->buffer = new_buffer;
          if (next > -FF_INPUT_BUFFER_PADDING_SIZE)
              memcpy(&pc->buffer[pc->index], *buf,
                    next + FF_INPUT_BUFFER_PADDING_SIZE);
         pc->index = 0;
         *buf= pc->buffer;
     }
     for(;next < 0; next++){
         pc->state = (pc->state<<8) | pc->buffer[pc->last_index + next];
         pc->state64 = (pc->state64<<8) | pc->buffer[pc->last_index + next];
         pc->overread++;
     }
     if(pc->overread){
         av_dlog(NULL, ""overread %d, state:%X next:%d index:%d o_index:%d\n"",
                 pc->overread, pc->state, next, pc->index, pc->overread_index);
         av_dlog(NULL, ""%X %X %X %X\n"", (*buf)[0], (*buf)[1],(*buf)[2],(*buf)[3]);
     }
     return 0;
 }","[17, 18, 19, 21, 31, 32, 33, 34, 36]","The ff_combine_frame function in libavcodec/parser.c in FFmpeg before 2.1 does not properly handle certain memory-allocation errors, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted data.",FFmpeg,CVE-2013-7023,CWE-119
3882,182784," compile_length_bag_node(BagNode* node, regex_t* reg)
 {
   int len;
   int tlen;
   if (node->type == BAG_OPTION)
     return compile_length_option_node(node, reg);
   if (NODE_BAG_BODY(node)) {
     tlen = compile_length_tree(NODE_BAG_BODY(node), reg);
     if (tlen < 0) return tlen;
   }
   else
     tlen = 0;
   switch (node->type) {
   case BAG_MEMORY:
 #ifdef USE_CALL
     if (node->m.regnum == 0 && NODE_IS_CALLED(node)) {
       len = tlen + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN;
       return len;
     }
     if (NODE_IS_CALLED(node)) {
       len = SIZE_OP_MEMORY_START_PUSH + tlen
         + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN;
       if (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum))
         len += (NODE_IS_RECURSION(node)
                 ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_PUSH);
       else
         len += (NODE_IS_RECURSION(node)
                 ? SIZE_OP_MEMORY_END_REC : SIZE_OP_MEMORY_END);
     }
     else if (NODE_IS_RECURSION(node)) {
       len = SIZE_OP_MEMORY_START_PUSH;
       len += tlen + (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum)
                      ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_REC);
     }
     else
 #endif
     {
       if (MEM_STATUS_AT0(reg->bt_mem_start, node->m.regnum))
         len = SIZE_OP_MEMORY_START_PUSH;
       else
         len = SIZE_OP_MEMORY_START;
       len += tlen + (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum)
                      ? SIZE_OP_MEMORY_END_PUSH : SIZE_OP_MEMORY_END);
     }
     break;
   case BAG_STOP_BACKTRACK:
     if (NODE_IS_STOP_BT_SIMPLE_REPEAT(node)) {
       int v;
       QuantNode* qn;
       qn = QUANT_(NODE_BAG_BODY(node));
       tlen = compile_length_tree(NODE_QUANT_BODY(qn), reg);
       if (tlen < 0) return tlen;
       v = onig_positive_int_multiply(qn->lower, tlen);
       if (v < 0) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;
       len = v + SIZE_OP_PUSH + tlen + SIZE_OP_POP_OUT + SIZE_OP_JUMP;
     }
     else {
       len = SIZE_OP_ATOMIC_START + tlen + SIZE_OP_ATOMIC_END;
     }
     break;
   case BAG_IF_ELSE:
     {
       Node* cond = NODE_BAG_BODY(node);
       Node* Then = node->te.Then;
       Node* Else = node->te.Else;
       len = compile_length_tree(cond, reg);
       if (len < 0) return len;
       len += SIZE_OP_PUSH;
       len += SIZE_OP_ATOMIC_START + SIZE_OP_ATOMIC_END;
       if (IS_NOT_NULL(Then)) {
         tlen = compile_length_tree(Then, reg);
         if (tlen < 0) return tlen;
          len += tlen;
        }
       len += SIZE_OP_JUMP + SIZE_OP_ATOMIC_END;
        if (IS_NOT_NULL(Else)) {
        len += SIZE_OP_JUMP;
          tlen = compile_length_tree(Else, reg);
          if (tlen < 0) return tlen;
          len += tlen;
       }
     }
     break;
   case BAG_OPTION:
     len = 0;
     break;
   }
   return len;
 }","[75, 77]","A NULL Pointer Dereference in match_at() in regexec.c in Oniguruma 6.9.2 allows attackers to potentially cause denial of service by providing a crafted regular expression. Oniguruma issues often affect Ruby, as well as common optional libraries for PHP and Rust.",oniguruma,CVE-2019-13225,CWE-476
3891,180520,"  static int myrecvfrom6(int sockfd, void *buf, size_t *buflen, int flags,
		       struct in6_addr *addr, uint32_t *ifindex)
 		       struct in6_addr *addr, uint32_t *ifindex, int *hoplimit)
  {
  	struct sockaddr_in6 sin6;
	unsigned char cbuf[CMSG_SPACE(sizeof(struct in6_pktinfo))];
 	unsigned char cbuf[2 * CMSG_SPACE(sizeof(struct in6_pktinfo))];
  	struct iovec iovec;
  	struct msghdr msghdr;
  	struct cmsghdr *cmsghdr;
 	ssize_t len;
 	iovec.iov_len = *buflen;
 	iovec.iov_base = buf;
 	memset(&msghdr, 0, sizeof(msghdr));
 	msghdr.msg_name = &sin6;
 	msghdr.msg_namelen = sizeof(sin6);
 	msghdr.msg_iov = &iovec;
 	msghdr.msg_iovlen = 1;
 	msghdr.msg_control = cbuf;
 	msghdr.msg_controllen = sizeof(cbuf);
 	len = recvmsg(sockfd, &msghdr, flags);
 	if (len == -1)
 		return -errno;
 	*buflen = len;
  	*ifindex = sin6.sin6_scope_id;
          for (cmsghdr = CMSG_FIRSTHDR(&msghdr); cmsghdr;
  	     cmsghdr = CMSG_NXTHDR(&msghdr, cmsghdr)) {
		if (cmsghdr->cmsg_level == IPPROTO_IPV6 &&
		    cmsghdr->cmsg_type == IPV6_PKTINFO &&
		    cmsghdr->cmsg_len == CMSG_LEN(sizeof(struct in6_pktinfo))) {
			struct in6_pktinfo *pktinfo;
 		if (cmsghdr->cmsg_level != IPPROTO_IPV6)
 			continue;
 		switch(cmsghdr->cmsg_type) {
 		case IPV6_PKTINFO:
 			if (cmsghdr->cmsg_len == CMSG_LEN(sizeof(struct in6_pktinfo))) {
 				struct in6_pktinfo *pktinfo;
 				pktinfo = (struct in6_pktinfo *) CMSG_DATA(cmsghdr);
 				*ifindex = pktinfo->ipi6_ifindex;
 			}
 			break;
 		case IPV6_HOPLIMIT:
 			if (cmsghdr->cmsg_len == CMSG_LEN(sizeof(int))) {
 				int *val;
			pktinfo = (struct in6_pktinfo *) CMSG_DATA(cmsghdr);
			*ifindex = pktinfo->ipi6_ifindex;
 				val = (int *) CMSG_DATA(cmsghdr);
 				*hoplimit = *val;
 			}
 			break;
  		}
  	}
  	*addr = sin6.sin6_addr;
 	return 0;
 }","[2, 3, 6, 7, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50]","libndp before 1.6, as used in NetworkManager, does not properly validate the origin of Neighbor Discovery Protocol (NDP) messages, which allows remote attackers to conduct man-in-the-middle attacks or cause a denial of service (network connectivity disruption) by advertising a node as a router from a non-local network.",libndp,CVE-2016-3698,CWE-284
3903,182612," static int jpc_pi_nextpcrl(register jpc_pi_t *pi)
 {
 	int rlvlno;
 	jpc_pirlvl_t *pirlvl;
 	jpc_pchg_t *pchg;
 	int prchind;
 	int prcvind;
 	int *prclyrno;
 	int compno;
 	jpc_picomp_t *picomp;
 	int xstep;
 	int ystep;
 	uint_fast32_t trx0;
 	uint_fast32_t try0;
 	uint_fast32_t r;
 	uint_fast32_t rpx;
 	uint_fast32_t rpy;
 	pchg = pi->pchg;
 	if (!pi->prgvolfirst) {
 		goto skip;
 	} else {
 		pi->xstep = 0;
 		pi->ystep = 0;
 		for (compno = 0, picomp = pi->picomps; compno < pi->numcomps;
  		  ++compno, ++picomp) {
  			for (rlvlno = 0, pirlvl = picomp->pirlvls; rlvlno <
  			  picomp->numrlvls; ++rlvlno, ++pirlvl) {
				xstep = picomp->hsamp * (1 <<
				  (pirlvl->prcwidthexpn + picomp->numrlvls -
				  rlvlno - 1));
				ystep = picomp->vsamp * (1 <<
				  (pirlvl->prcheightexpn + picomp->numrlvls -
				  rlvlno - 1));
				pi->xstep = (!pi->xstep) ? xstep :
				  JAS_MIN(pi->xstep, xstep);
				pi->ystep = (!pi->ystep) ? ystep :
				  JAS_MIN(pi->ystep, ystep);
 				if (pirlvl->prcwidthexpn + pi->picomp->numrlvls >
 				  JAS_UINTFAST32_NUMBITS - 2 ||
 				  pirlvl->prcheightexpn + pi->picomp->numrlvls >
 				  JAS_UINTFAST32_NUMBITS - 2) {
 					return -1;
 				}
 				xstep = picomp->hsamp * (JAS_CAST(uint_fast32_t, 1) <<
 				  (pirlvl->prcwidthexpn + picomp->numrlvls - rlvlno - 1));
 				ystep = picomp->vsamp * (JAS_CAST(uint_fast32_t, 1) <<
 				  (pirlvl->prcheightexpn + picomp->numrlvls - rlvlno - 1));
 				pi->xstep = (!pi->xstep) ? xstep : JAS_MIN(pi->xstep, xstep);
 				pi->ystep = (!pi->ystep) ? ystep : JAS_MIN(pi->ystep, ystep);
  			}
  		}
  		pi->prgvolfirst = 0;
 	}
 	for (pi->y = pi->ystart; pi->y < pi->yend; pi->y += pi->ystep -
 	  (pi->y % pi->ystep)) {
 		for (pi->x = pi->xstart; pi->x < pi->xend; pi->x += pi->xstep -
 		  (pi->x % pi->xstep)) {
 			for (pi->compno = pchg->compnostart, pi->picomp =
 			  &pi->picomps[pi->compno]; pi->compno < pi->numcomps
 			  && pi->compno < JAS_CAST(int, pchg->compnoend); ++pi->compno,
 			  ++pi->picomp) {
 				for (pi->rlvlno = pchg->rlvlnostart,
 				  pi->pirlvl = &pi->picomp->pirlvls[pi->rlvlno];
 				  pi->rlvlno < pi->picomp->numrlvls &&
 				  pi->rlvlno < pchg->rlvlnoend; ++pi->rlvlno,
 				  ++pi->pirlvl) {
 					if (pi->pirlvl->numprcs == 0) {
 						continue;
 					}
 					r = pi->picomp->numrlvls - 1 - pi->rlvlno;
 					trx0 = JPC_CEILDIV(pi->xstart, pi->picomp->hsamp << r);
  					try0 = JPC_CEILDIV(pi->ystart, pi->picomp->vsamp << r);
  					rpx = r + pi->pirlvl->prcwidthexpn;
  					rpy = r + pi->pirlvl->prcheightexpn;
					if (((pi->x == pi->xstart && ((trx0 << r) % (1 << rpx))) ||
 					if (((pi->x == pi->xstart &&
 					  ((trx0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpx))) ||
  					  !(pi->x % (pi->picomp->hsamp << rpx))) &&
					  ((pi->y == pi->ystart && ((try0 << r) % (1 << rpy))) ||
 					  ((pi->y == pi->ystart &&
 					  ((try0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpy))) ||
  					  !(pi->y % (pi->picomp->vsamp << rpy)))) {
						prchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x, pi->picomp->hsamp
						  << r), pi->pirlvl->prcwidthexpn) - JPC_FLOORDIVPOW2(trx0,
						  pi->pirlvl->prcwidthexpn);
						prcvind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->y, pi->picomp->vsamp
						  << r), pi->pirlvl->prcheightexpn) - JPC_FLOORDIVPOW2(try0,
						  pi->pirlvl->prcheightexpn);
 						prchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x,
 						  pi->picomp->hsamp << r), pi->pirlvl->prcwidthexpn) -
 						  JPC_FLOORDIVPOW2(trx0, pi->pirlvl->prcwidthexpn);
 						prcvind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->y,
 						  pi->picomp->vsamp << r), pi->pirlvl->prcheightexpn) -
 						  JPC_FLOORDIVPOW2(try0, pi->pirlvl->prcheightexpn);
  						pi->prcno = prcvind * pi->pirlvl->numhprcs + prchind;
  						assert(pi->prcno < pi->pirlvl->numprcs);
  						for (pi->lyrno = 0; pi->lyrno < pi->numlyrs &&
						  pi->lyrno < JAS_CAST(int, pchg->lyrnoend); ++pi->lyrno) {
 						  pi->lyrno < JAS_CAST(int, pchg->lyrnoend);
 						  ++pi->lyrno) {
  							prclyrno = &pi->pirlvl->prclyrnos[pi->prcno];
  							if (pi->lyrno >= *prclyrno) {
  								++(*prclyrno);
 								return 0;
 							}
 skip:
 							;
 						}
 					}
 				}
 			}
 		}
 	}
 	return 1;
 }","[28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 75, 76, 77, 79, 80, 81, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 98, 99, 100]",An out-of-bounds heap read vulnerability was found in the jpc_pi_nextpcrl() function of jasper before 2.0.6 when processing crafted input.,jasper,CVE-2016-9583,CWE-125
3913,178698,"  int sfgets(void)
  {
      struct pollfd pfd;
      int pollret;
      ssize_t readnb;
      signed char seen_r = 0;
    static size_t scanned;
    static size_t readnbd;
      if (scanned > (size_t) 0U) {        
          readnbd -= scanned;        
         memmove(cmd, cmd + scanned, readnbd);    
         scanned = (size_t) 0U;
     }
     pfd.fd = clientfd;
 #ifdef __APPLE_CC__
     pfd.events = POLLIN | POLLERR | POLLHUP;
 #else
     pfd.events = POLLIN | POLLPRI | POLLERR | POLLHUP;
 #endif
     while (scanned < cmdsize) {
         if (scanned >= readnbd) {       
             pfd.revents = 0;
             while ((pollret = poll(&pfd, 1U, idletime * 1000UL)) < 0 &&
                    errno == EINTR);
             if (pollret == 0) {
                 return -1;
             }
             if (pollret <= 0 ||
                 (pfd.revents & (POLLERR | POLLHUP | POLLNVAL)) != 0) {
                 return -2;
             }
             if ((pfd.revents & (POLLIN | POLLPRI)) == 0) {
                 continue;
             }
             if (readnbd >= cmdsize) {
                 break;
             }
 #ifdef WITH_TLS
             if (tls_cnx != NULL) {
                 while ((readnb = SSL_read
                         (tls_cnx, cmd + readnbd, cmdsize - readnbd))
                        < (ssize_t) 0 && errno == EINTR);
             } else
 #endif
             {
                 while ((readnb = read(clientfd, cmd + readnbd,
                                       cmdsize - readnbd)) < (ssize_t) 0 &&
                        errno == EINTR);
             }
             if (readnb <= (ssize_t) 0) {
                 return -2;
             }
             readnbd += readnb;
             if (readnbd > cmdsize) {
                 return -2;
             }
         }
 #ifdef RFC_CONFORMANT_LINES
         if (seen_r != 0) {
 #endif
             if (cmd[scanned] == '\n') {
 #ifndef RFC_CONFORMANT_LINES
                 if (seen_r != 0) {
 #endif
                     cmd[scanned - 1U] = 0;
 #ifndef RFC_CONFORMANT_LINES
                 } else {
                     cmd[scanned] = 0;
                 }
 #endif
                 if (++scanned >= readnbd) {    
                     scanned = readnbd = (size_t) 0U;
                 }
                 return 0;
             }
             seen_r = 0;
 #ifdef RFC_CONFORMANT_LINES
         }
 #endif
         if (ISCTRLCODE(cmd[scanned])) {
             if (cmd[scanned] == '\r') {
                 seen_r = 1;
             }
 #ifdef RFC_CONFORMANT_PARSER                    
             else if (cmd[scanned] == 0) {
                 cmd[scanned] = '\n';
             }
 #else
             cmd[scanned] = '_';                
 #endif
         }
         scanned++;
     }
     die(421, LOG_WARNING, MSG_LINE_TOO_LONG);    
     return 0;                          
 }","[7, 8]","The STARTTLS implementation in ftp_parser.c in Pure-FTPd before 1.0.30 does not properly restrict I/O buffering, which allows man-in-the-middle attackers to insert commands into encrypted FTP sessions by sending a cleartext command that is processed after TLS is in place, related to a *plaintext command injection* attack, a similar issue to CVE-2011-0411.",pure-ftpd,CVE-2011-1575,CWE-399
3918,182418," static int DecodeGifImg(struct ngiflib_img * i) {
 	struct ngiflib_decode_context context;
 	long npix;
 	u8 * stackp;
 	u8 * stack_top;
 	u16 clr;
 	u16 eof;
 	u16 free;
 	u16 act_code = 0;
 	u16 old_code = 0;
 	u16 read_byt;
 	u16 ab_prfx[4096];
 	u8 ab_suffx[4096];
 	u8 ab_stack[4096];
 	u8 flags;
 	u8 casspecial = 0;
 	if(!i) return -1;
 	i->posX = GetWord(i->parent);	 
 	i->posY = GetWord(i->parent);	 
 	i->width = GetWord(i->parent);	 
 	i->height = GetWord(i->parent);	 
 	if((i->width > i->parent->width) || (i->height > i->parent->height)) {
 #if !defined(NGIFLIB_NO_FILE)
 		if(i->parent->log) fprintf(i->parent->log, ""*** ERROR *** Image bigger than global GIF canvas !\n"");
 #endif
 		return -1;
 	}
 	if((i->posX + i->width) > i->parent->width) {
 #if !defined(NGIFLIB_NO_FILE)
 		if(i->parent->log) fprintf(i->parent->log, ""*** WARNING *** Adjusting X position\n"");
 #endif
 		i->posX = i->parent->width - i->width;
 	}
 	if((i->posY + i->height) > i->parent->height) {
 #if !defined(NGIFLIB_NO_FILE)
 		if(i->parent->log) fprintf(i->parent->log, ""*** WARNING *** Adjusting Y position\n"");
 #endif
 		i->posY = i->parent->height - i->height;
 	}
 	context.Xtogo = i->width;
 	context.curY = i->posY;
 #ifdef NGIFLIB_INDEXED_ONLY
 	#ifdef NGIFLIB_ENABLE_CALLBACKS
 	context.line_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width;
 	context.frbuff_p.p8 = context.line_p.p8 + i->posX;
 	#else
 	context.frbuff_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width + i->posX;
 	#endif  
 #else
 	if(i->parent->mode & NGIFLIB_MODE_INDEXED) {
 		#ifdef NGIFLIB_ENABLE_CALLBACKS
 		context.line_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width;
 		context.frbuff_p.p8 = context.line_p.p8 + i->posX;
 		#else
 		context.frbuff_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width + i->posX;
 		#endif  
 	} else {
 		#ifdef NGIFLIB_ENABLE_CALLBACKS
 		context.line_p.p32 = i->parent->frbuff.p32 + (u32)i->posY*i->parent->width;
 		context.frbuff_p.p32 = context.line_p.p32 + i->posX;
 		#else
 		context.frbuff_p.p32 = i->parent->frbuff.p32 + (u32)i->posY*i->parent->width + i->posX;
 		#endif  
 	}
 #endif  
 	npix = (long)i->width * i->height;
 	flags = GetByte(i->parent);
 	i->interlaced = (flags & 64) >> 6;
 	context.pass = i->interlaced ? 1 : 0;
 	i->sort_flag = (flags & 32) >> 5;	 
 	i->localpalbits = (flags & 7) + 1;
 	if(flags&128) {  
 		int k;
 		int localpalsize = 1 << i->localpalbits;
 #if !defined(NGIFLIB_NO_FILE)
 		if(i->parent && i->parent->log) fprintf(i->parent->log, ""Local palette\n"");
 #endif  
 		i->palette = (struct ngiflib_rgb *)ngiflib_malloc(sizeof(struct ngiflib_rgb)*localpalsize);
 		for(k=0; k<localpalsize; k++) {
 			i->palette[k].r = GetByte(i->parent);
 			i->palette[k].g = GetByte(i->parent);
 			i->palette[k].b = GetByte(i->parent);
 		}
 #ifdef NGIFLIB_ENABLE_CALLBACKS
 		if(i->parent->palette_cb) i->parent->palette_cb(i->parent, i->palette, localpalsize);
 #endif  
 	} else {
 		i->palette = i->parent->palette;
 		i->localpalbits = i->parent->imgbits;
 	}
 	i->ncolors = 1 << i->localpalbits;
 	i->imgbits = GetByte(i->parent);	 
 #if !defined(NGIFLIB_NO_FILE)
 	if(i->parent && i->parent->log) {
 		if(i->interlaced) fprintf(i->parent->log, ""interlaced "");
 		fprintf(i->parent->log, ""img pos(%hu,%hu) size %hux%hu palbits=%hhu imgbits=%hhu ncolors=%hu\n"",
 	       i->posX, i->posY, i->width, i->height, i->localpalbits, i->imgbits, i->ncolors);
 	}
 #endif  
 	if(i->imgbits==1) {	 
 		i->imgbits = 2;
 	}
 	clr = 1 << i->imgbits;
 	eof = clr + 1;
 	free = clr + 2;
 	context.nbbit = i->imgbits + 1;
 	context.max = clr + clr - 1;  
 	stackp = stack_top = ab_stack + 4096;
 	context.restbits = 0;	 
 	context.restbyte = 0;	 
 	context.lbyte = 0;
 	for(;;) {
 		act_code = GetGifWord(i, &context);
 		if(act_code==eof) {
 #if !defined(NGIFLIB_NO_FILE)
 			if(i->parent && i->parent->log) fprintf(i->parent->log, ""End of image code\n"");
 #endif  
 			return 0;
 		}
 		if(npix==0) {
 #if !defined(NGIFLIB_NO_FILE)
 			if(i->parent && i->parent->log) fprintf(i->parent->log, ""assez de pixels, On se casse !\n"");
 #endif  
 			return 1;
 		}	
 		if(act_code==clr) {
 #if !defined(NGIFLIB_NO_FILE)
 			if(i->parent && i->parent->log) fprintf(i->parent->log, ""Code clear (free=%hu) npix=%ld\n"", free, npix);
 #endif  
 			free = clr + 2;
 			context.nbbit = i->imgbits + 1;
 			context.max = clr + clr - 1;  
  			act_code = GetGifWord(i, &context);
  			casspecial = (u8)act_code;
  			old_code = act_code;
			WritePixel(i, &context, casspecial); npix--;
 			if(npix > 0) WritePixel(i, &context, casspecial);
 			npix--;
  		} else {
  			read_byt = act_code;
  			if(act_code >= free) {	 
 				*(--stackp) = casspecial;  
 				act_code = old_code;
 			}
 			while(act_code > clr) {  
 				*(--stackp) = ab_suffx[act_code];
 				act_code = ab_prfx[act_code];	 
 			}
  			casspecial = (u8)act_code;	 
  			*(--stackp) = casspecial;	 
			WritePixels(i, &context, stackp, stack_top - stackp);	 
 			if(npix >= (stack_top - stackp)) {
 				WritePixels(i, &context, stackp, stack_top - stackp);	 
 			} else if(npix > 0) {	 
 				WritePixels(i, &context, stackp, npix);
 			}
  			npix -= (stack_top - stackp);
  			stackp = stack_top;
 			if(free < 4096) {  
 				ab_prfx[free] = old_code;
 				ab_suffx[free] = (u8)act_code;
 				free++;
 				if((free > context.max) && (context.nbbit < 12)) {
 					context.nbbit++;	 
 					context.max += context.max + 1;
 				}
 			}
 			old_code = read_byt;
 		}
 	}
 	return 0;
 }","[136, 137, 138, 151, 152, 153, 154, 155, 156]","The DecodeGifImg function in ngiflib.c in MiniUPnP ngiflib 0.4 does not consider the bounds of the pixels data structure, which allows remote attackers to cause a denial of service (WritePixels heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted GIF file, a different vulnerability than CVE-2018-10677.",ngiflib,CVE-2018-10717,CWE-119
3919,182969," cssp_read_tsrequest(STREAM token, STREAM pubkey)
 {
  	STREAM s;
  	int length;
  	int tagval;
 	struct stream packet;
  	s = tcp_recv(NULL, 4);
 	if (s == NULL)
 		return False;
 	if (s->p[0] != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))
 	{
 		logger(Protocol, Error,
 		       ""cssp_read_tsrequest(), expected BER_TAG_SEQUENCE|BER_TAG_CONSTRUCTED, got %x"",
 		       s->p[0]);
 		return False;
 	}
 	if (s->p[1] < 0x80)
 		length = s->p[1] - 2;
 	else if (s->p[1] == 0x81)
 		length = s->p[2] - 1;
 	else if (s->p[1] == 0x82)
 		length = (s->p[2] << 8) | s->p[3];
 	else
 		return False;
  	s = tcp_recv(s, length);
 	packet = *s;
  	if (!ber_in_header(s, &tagval, &length) ||
 	    tagval != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))
 		return False;
  	if (!ber_in_header(s, &tagval, &length) ||
  	    tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0))
  		return False;
 	if (!s_check_rem(s, length))
 	{
 		 rdp_protocol_error(""cssp_read_tsrequest(), consume of version from stream would overrun"",
 				    &packet);
 	}
  	in_uint8s(s, length);
 	if (token)
 	{
 		if (!ber_in_header(s, &tagval, &length)
 		    || tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 1))
 			return False;
 		if (!ber_in_header(s, &tagval, &length)
 		    || tagval != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))
 			return False;
 		if (!ber_in_header(s, &tagval, &length)
 		    || tagval != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))
 			return False;
 		if (!ber_in_header(s, &tagval, &length)
 		    || tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0))
 			return False;
  		if (!ber_in_header(s, &tagval, &length) || tagval != BER_TAG_OCTET_STRING)
  			return False;
		token->end = token->p = token->data;
 		if (!s_check_rem(s, length))
 		{
 			rdp_protocol_error(""cssp_read_tsrequest(), consume of token from stream would overrun"",
 					   &packet);
 		}
 		s_realloc(token, length);
 		s_reset(token);
  		out_uint8p(token, s->p, length);
  		s_mark_end(token);
  	}
 	if (pubkey)
 	{
 		if (!ber_in_header(s, &tagval, &length)
 		    || tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 3))
 			return False;
 		if (!ber_in_header(s, &tagval, &length) || tagval != BER_TAG_OCTET_STRING)
 			return False;
 		pubkey->data = pubkey->p = s->p;
 		pubkey->end = pubkey->data + length;
 		pubkey->size = length;
 	}
 	return True;
 }","[6, 26, 33, 34, 35, 36, 37, 55, 56, 57, 58, 59, 60, 61, 62]",rdesktop versions up to and including v1.8.3 contain a Buffer Overflow over the global variables in the function seamless_process_line() that results in memory corruption and probably even a remote code execution.,rdesktop,CVE-2018-20182,CWE-119
3926,178614," ProcXFixesCopyRegion(ClientPtr client)
 {
      RegionPtr pSource, pDestination;
      REQUEST(xXFixesCopyRegionReq);
     REQUEST_SIZE_MATCH(xXFixesCopyRegionReq);
      VERIFY_REGION(pSource, stuff->source, client, DixReadAccess);
      VERIFY_REGION(pDestination, stuff->destination, client, DixWriteAccess);
     if (!RegionCopy(pDestination, pSource))
         return BadAlloc;
     return Success;
 }",[5],xorg-x11-server before 1.19.5 was missing length validation in XFIXES extension allowing malicious X client to cause X server to crash or possibly execute arbitrary code.,xserver,CVE-2017-12183,CWE-20
3968,183215," static int decode_unit(SCPRContext *s, PixelModel *pixel, unsigned step, unsigned *rval)
 {
     GetByteContext *gb = &s->gb;
     RangeCoder *rc = &s->rc;
     unsigned totfr = pixel->total_freq;
     unsigned value, x = 0, cumfr = 0, cnt_x = 0;
     int i, j, ret, c, cnt_c;
     if ((ret = s->get_freq(rc, totfr, &value)) < 0)
         return ret;
     while (x < 16) {
         cnt_x = pixel->lookup[x];
         if (value >= cumfr + cnt_x)
             cumfr += cnt_x;
         else
             break;
         x++;
     }
     c = x * 16;
     cnt_c = 0;
     while (c < 256) {
         cnt_c = pixel->freq[c];
         if (value >= cumfr + cnt_c)
             cumfr += cnt_c;
         else
              break;
          c++;
      }
     if (x >= 16 || c >= 256) {
         return AVERROR_INVALIDDATA;
     }
      if ((ret = s->decode(gb, rc, cumfr, cnt_c, totfr)) < 0)
          return ret;
     pixel->freq[c] = cnt_c + step;
     pixel->lookup[x] = cnt_x + step;
     totfr += step;
     if (totfr > BOT) {
         totfr = 0;
         for (i = 0; i < 256; i++) {
             unsigned nc = (pixel->freq[i] >> 1) + 1;
             pixel->freq[i] = nc;
             totfr += nc;
         }
         for (i = 0; i < 16; i++) {
             unsigned sum = 0;
             unsigned i16_17 = i << 4;
             for (j = 0; j < 16; j++)
                 sum += pixel->freq[i16_17 + j];
             pixel->lookup[i] = sum;
         }
     }
     pixel->total_freq = totfr;
     *rval = c & s->cbits;
     return 0;
 }","[28, 29, 30]","libavcodec/scpr.c in FFmpeg 3.3 before 3.3.1 does not properly validate height and width data, which allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted file.",FFmpeg,CVE-2017-9995,CWE-119
4027,181911,"  static int ras_getcmap(jas_stream_t *in, ras_hdr_t *hdr, ras_cmap_t *cmap)
 {
 	int i;
 	int j;
 	int x;
 	int c;
 	int numcolors;
 	int actualnumcolors;
 	switch (hdr->maptype) {
 	case RAS_MT_NONE:
 		break;
 	case RAS_MT_EQUALRGB:
  		{
  		jas_eprintf(""warning: palettized images not fully supported\n"");
  		numcolors = 1 << hdr->depth;
		assert(numcolors <= RAS_CMAP_MAXSIZ);
 		if (numcolors > RAS_CMAP_MAXSIZ) {
 			return -1;
 		}
  		actualnumcolors = hdr->maplength / 3;
  		for (i = 0; i < numcolors; i++) {
  			cmap->data[i] = 0;
 		}
 		if ((hdr->maplength % 3) || hdr->maplength < 0 ||
 		  hdr->maplength > 3 * numcolors) {
 			return -1;
 		}
 		for (i = 0; i < 3; i++) {
 			for (j = 0; j < actualnumcolors; j++) {
 				if ((c = jas_stream_getc(in)) == EOF) {
 					return -1;
 				}
 				x = 0;
 				switch (i) {
 				case 0:
 					x = RAS_RED(c);
 					break;
 				case 1:
 					x = RAS_GREEN(c);
 					break;
 				case 2:
 					x = RAS_BLUE(c);
 					break;
 				}
 				cmap->data[j] |= x;
 			}
 		}
 		}
 		break;
 	default:
 		return -1;
 		break;
 	}
 	return 0;
 }","[16, 17, 18, 19]",The ras_getcmap function in ras_dec.c in JasPer before 1.900.14 allows remote attackers to cause a denial of service (assertion failure) via a crafted image file.,jasper,CVE-2016-9388,
4034,181927," jas_matrix_t *jas_matrix_create(int numrows, int numcols)
 {
  	jas_matrix_t *matrix;
  	int i;
 	if (numrows < 0 || numcols < 0) {
 		return 0;
 	}
  	if (!(matrix = jas_malloc(sizeof(jas_matrix_t)))) {
  		return 0;
  	}
 	matrix->flags_ = 0;
 	matrix->numrows_ = numrows;
 	matrix->numcols_ = numcols;
 	matrix->rows_ = 0;
 	matrix->maxrows_ = numrows;
 	matrix->data_ = 0;
 	matrix->datasize_ = numrows * numcols;
 	if (matrix->maxrows_ > 0) {
 		if (!(matrix->rows_ = jas_alloc2(matrix->maxrows_,
 		  sizeof(jas_seqent_t *)))) {
 			jas_matrix_destroy(matrix);
 			return 0;
 		}
 	}
 	if (matrix->datasize_ > 0) {
 		if (!(matrix->data_ = jas_alloc2(matrix->datasize_,
 		  sizeof(jas_seqent_t)))) {
 			jas_matrix_destroy(matrix);
 			return 0;
 		}
 	}
 	for (i = 0; i < numrows; ++i) {
 		matrix->rows_[i] = &matrix->data_[i * matrix->numcols_];
 	}
 	for (i = 0; i < matrix->datasize_; ++i) {
 		matrix->data_[i] = 0;
 	}
 	matrix->xstart_ = 0;
 	matrix->ystart_ = 0;
 	matrix->xend_ = matrix->numcols_;
 	matrix->yend_ = matrix->numrows_;
 	return matrix;
 }","[5, 6, 7]",The bmp_getdata function in libjasper/bmp/bmp_dec.c in JasPer 1.900.5 allows remote attackers to cause a denial of service (NULL pointer dereference) by calling the imginfo command with a crafted BMP image. NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-8690.,jasper,CVE-2016-8884,CWE-476
4058,178480," ProcPutImage(ClientPtr client)
 {
     GC *pGC;
     DrawablePtr pDraw;
     long length;                 
     long lengthProto;            
     char *tmpImage;
     REQUEST(xPutImageReq);
     REQUEST_AT_LEAST_SIZE(xPutImageReq);
     VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixWriteAccess);
     if (stuff->format == XYBitmap) {
         if ((stuff->depth != 1) ||
             (stuff->leftPad >= (unsigned int) screenInfo.bitmapScanlinePad))
             return BadMatch;
         length = BitmapBytePad(stuff->width + stuff->leftPad);
     }
     else if (stuff->format == XYPixmap) {
         if ((pDraw->depth != stuff->depth) ||
             (stuff->leftPad >= (unsigned int) screenInfo.bitmapScanlinePad))
             return BadMatch;
         length = BitmapBytePad(stuff->width + stuff->leftPad);
         length *= stuff->depth;
     }
     else if (stuff->format == ZPixmap) {
         if ((pDraw->depth != stuff->depth) || (stuff->leftPad != 0))
             return BadMatch;
         length = PixmapBytePad(stuff->width, stuff->depth);
     }
     else {
         client->errorValue = stuff->format;
         return BadValue;
     }
      tmpImage = (char *) &stuff[1];
      lengthProto = length;
    if (lengthProto >= (INT32_MAX / stuff->height))
     if (stuff->height != 0 && lengthProto >= (INT32_MAX / stuff->height))
          return BadLength;
      if ((bytes_to_int32(lengthProto * stuff->height) +
          bytes_to_int32(sizeof(xPutImageReq))) != client->req_len)
         return BadLength;
     ReformatImage(tmpImage, lengthProto * stuff->height,
                   stuff->format == ZPixmap ? BitsPerPixel(stuff->depth) : 1,
                   ClientOrder(client));
     (*pGC->ops->PutImage) (pDraw, pGC, stuff->depth, stuff->dstX, stuff->dstY,
                            stuff->width, stuff->height,
                            stuff->leftPad, stuff->format, tmpImage);
     return Success;
 }","[35, 36]",The ProcPutImage function in dix/dispatch.c in X.Org Server (aka xserver and xorg-server) before 1.16.4 allows attackers to cause a denial of service (divide-by-zero and crash) via a zero-height PutImage request.,xserver,CVE-2015-3418,CWE-369
4065,181926," jas_image_t *jp2_decode(jas_stream_t *in, char *optstr)
 {
 	jp2_box_t *box;
 	int found;
 	jas_image_t *image;
 	jp2_dec_t *dec;
 	bool samedtype;
 	int dtype;
 	unsigned int i;
 	jp2_cmap_t *cmapd;
 	jp2_pclr_t *pclrd;
 	jp2_cdef_t *cdefd;
 	unsigned int channo;
 	int newcmptno;
 	int_fast32_t *lutents;
 #if 0
 	jp2_cdefchan_t *cdefent;
 	int cmptno;
 #endif
 	jp2_cmapent_t *cmapent;
 	jas_icchdr_t icchdr;
 	jas_iccprof_t *iccprof;
 	dec = 0;
 	box = 0;
 	image = 0;
 	if (!(dec = jp2_dec_create())) {
 		goto error;
 	}
 	if (!(box = jp2_box_get(in))) {
 		jas_eprintf(""error: cannot get box\n"");
 		goto error;
 	}
 	if (box->type != JP2_BOX_JP) {
 		jas_eprintf(""error: expecting signature box\n"");
 		goto error;
 	}
 	if (box->data.jp.magic != JP2_JP_MAGIC) {
 		jas_eprintf(""incorrect magic number\n"");
 		goto error;
 	}
 	jp2_box_destroy(box);
 	box = 0;
 	if (!(box = jp2_box_get(in))) {
 		goto error;
 	}
 	if (box->type != JP2_BOX_FTYP) {
 		jas_eprintf(""expecting file type box\n"");
 		goto error;
 	}
 	jp2_box_destroy(box);
 	box = 0;
  	found = 0;
  	while ((box = jp2_box_get(in))) {
  		if (jas_getdbglevel() >= 1) {
			jas_eprintf(""box type %s\n"", box->info->name);
 			jas_eprintf(""got box type %s\n"", box->info->name);
  		}
  		switch (box->type) {
  		case JP2_BOX_JP2C:
 			found = 1;
 			break;
 		case JP2_BOX_IHDR:
 			if (!dec->ihdr) {
 				dec->ihdr = box;
 				box = 0;
 			}
 			break;
 		case JP2_BOX_BPCC:
 			if (!dec->bpcc) {
 				dec->bpcc = box;
 				box = 0;
 			}
 			break;
 		case JP2_BOX_CDEF:
 			if (!dec->cdef) {
 				dec->cdef = box;
 				box = 0;
 			}
 			break;
 		case JP2_BOX_PCLR:
 			if (!dec->pclr) {
 				dec->pclr = box;
 				box = 0;
 			}
 			break;
 		case JP2_BOX_CMAP:
 			if (!dec->cmap) {
 				dec->cmap = box;
 				box = 0;
 			}
 			break;
 		case JP2_BOX_COLR:
 			if (!dec->colr) {
 				dec->colr = box;
 				box = 0;
 			}
 			break;
 		}
 		if (box) {
 			jp2_box_destroy(box);
 			box = 0;
 		}
 		if (found) {
 			break;
 		}
 	}
 	if (!found) {
 		jas_eprintf(""error: no code stream found\n"");
 		goto error;
 	}
 	if (!(dec->image = jpc_decode(in, optstr))) {
 		jas_eprintf(""error: cannot decode code stream\n"");
 		goto error;
 	}
 	if (!dec->ihdr) {
 		jas_eprintf(""error: missing IHDR box\n"");
 		goto error;
 	}
 	if (dec->ihdr->data.ihdr.numcmpts != JAS_CAST(uint,
 	  jas_image_numcmpts(dec->image))) {
 		jas_eprintf(""warning: number of components mismatch\n"");
 	}
 	if (!jas_image_numcmpts(dec->image)) {
 		jas_eprintf(""error: no components\n"");
 		goto error;
 	}
 	samedtype = true;
 	dtype = jas_image_cmptdtype(dec->image, 0);
 	for (i = 1; i < JAS_CAST(uint, jas_image_numcmpts(dec->image)); ++i) {
 		if (jas_image_cmptdtype(dec->image, i) != dtype) {
 			samedtype = false;
 			break;
 		}
 	}
 	if ((samedtype && dec->ihdr->data.ihdr.bpc != JP2_DTYPETOBPC(dtype)) ||
 	  (!samedtype && dec->ihdr->data.ihdr.bpc != JP2_IHDR_BPCNULL)) {
 		jas_eprintf(""warning: component data type mismatch\n"");
 	}
 	if (dec->ihdr->data.ihdr.comptype != JP2_IHDR_COMPTYPE) {
 		jas_eprintf(""error: unsupported compression type\n"");
 		goto error;
 	}
 	if (dec->bpcc) {
 		if (dec->bpcc->data.bpcc.numcmpts != JAS_CAST(uint, jas_image_numcmpts(
 		  dec->image))) {
 			jas_eprintf(""warning: number of components mismatch\n"");
 		}
 		if (!samedtype) {
 			for (i = 0; i < JAS_CAST(uint, jas_image_numcmpts(dec->image));
 			  ++i) {
 				if (jas_image_cmptdtype(dec->image, i) !=
 				  JP2_BPCTODTYPE(dec->bpcc->data.bpcc.bpcs[i])) {
 					jas_eprintf(""warning: component data type mismatch\n"");
 				}
 			}
 		} else {
 			jas_eprintf(""warning: superfluous BPCC box\n"");
 		}
 	}
 	if (!dec->colr) {
 		jas_eprintf(""error: no COLR box\n"");
 		goto error;
 	}
 	switch (dec->colr->data.colr.method) {
 	case JP2_COLR_ENUM:
 		jas_image_setclrspc(dec->image, jp2_getcs(&dec->colr->data.colr));
 		break;
 	case JP2_COLR_ICC:
 		iccprof = jas_iccprof_createfrombuf(dec->colr->data.colr.iccp,
 		  dec->colr->data.colr.iccplen);
 		if (!iccprof) {
 			jas_eprintf(""error: failed to parse ICC profile\n"");
 			goto error;
 		}
 		jas_iccprof_gethdr(iccprof, &icchdr);
 		jas_eprintf(""ICC Profile CS %08x\n"", icchdr.colorspc);
 		jas_image_setclrspc(dec->image, fromiccpcs(icchdr.colorspc));
 		dec->image->cmprof_ = jas_cmprof_createfromiccprof(iccprof);
 		assert(dec->image->cmprof_);
 		jas_iccprof_destroy(iccprof);
 		break;
 	}
 	if (dec->cmap && !dec->pclr) {
 		jas_eprintf(""warning: missing PCLR box or superfluous CMAP box\n"");
 		jp2_box_destroy(dec->cmap);
 		dec->cmap = 0;
 	}
 	if (!dec->cmap && dec->pclr) {
 		jas_eprintf(""warning: missing CMAP box or superfluous PCLR box\n"");
 		jp2_box_destroy(dec->pclr);
 		dec->pclr = 0;
 	}
 	dec->numchans = dec->cmap ? dec->cmap->data.cmap.numchans :
 	  JAS_CAST(uint, jas_image_numcmpts(dec->image));
 	if (dec->cmap) {
 		for (i = 0; i < dec->numchans; ++i) {
 			if (dec->cmap->data.cmap.ents[i].cmptno >= JAS_CAST(uint,
 			  jas_image_numcmpts(dec->image))) {
 				jas_eprintf(""error: invalid component number in CMAP box\n"");
 				goto error;
 			}
 			if (dec->cmap->data.cmap.ents[i].pcol >=
 			  dec->pclr->data.pclr.numchans) {
 				jas_eprintf(""error: invalid CMAP LUT index\n"");
 				goto error;
 			}
 		}
 	}
 	if (!(dec->chantocmptlut = jas_alloc2(dec->numchans,
 	  sizeof(uint_fast16_t)))) {
 		jas_eprintf(""error: no memory\n"");
 		goto error;
 	}
 	if (!dec->cmap) {
 		for (i = 0; i < dec->numchans; ++i) {
 			dec->chantocmptlut[i] = i;
 		}
 	} else {
 		cmapd = &dec->cmap->data.cmap;
 		pclrd = &dec->pclr->data.pclr;
 		cdefd = &dec->cdef->data.cdef;
 		for (channo = 0; channo < cmapd->numchans; ++channo) {
 			cmapent = &cmapd->ents[channo];
 			if (cmapent->map == JP2_CMAP_DIRECT) {
 				dec->chantocmptlut[channo] = channo;
 			} else if (cmapent->map == JP2_CMAP_PALETTE) {
 				lutents = jas_alloc2(pclrd->numlutents, sizeof(int_fast32_t));
 				for (i = 0; i < pclrd->numlutents; ++i) {
 					lutents[i] = pclrd->lutdata[cmapent->pcol + i * pclrd->numchans];
 				}
 				newcmptno = jas_image_numcmpts(dec->image);
 				jas_image_depalettize(dec->image, cmapent->cmptno,
 				  pclrd->numlutents, lutents,
 				  JP2_BPCTODTYPE(pclrd->bpc[cmapent->pcol]), newcmptno);
 				dec->chantocmptlut[channo] = newcmptno;
 				jas_free(lutents);
 #if 0
 				if (dec->cdef) {
 					cdefent = jp2_cdef_lookup(cdefd, channo);
 					if (!cdefent) {
 						abort();
 					}
 				jas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), cdefent->type, cdefent->assoc));
 				} else {
 				jas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), 0, channo + 1));
 				}
 #endif
 			}
 		}
 	}
 	for (i = 0; i < JAS_CAST(uint, jas_image_numcmpts(dec->image)); ++i) {
 		jas_image_setcmpttype(dec->image, i, JAS_IMAGE_CT_UNKNOWN);
 	}
 	if (dec->cdef) {
 		for (i = 0; i < dec->numchans; ++i) {
 			if (dec->cdef->data.cdef.ents[i].channo >= dec->numchans) {
 				jas_eprintf(""error: invalid channel number in CDEF box\n"");
 				goto error;
 			}
 			jas_image_setcmpttype(dec->image,
 			  dec->chantocmptlut[dec->cdef->data.cdef.ents[i].channo],
 			  jp2_getct(jas_image_clrspc(dec->image),
 			  dec->cdef->data.cdef.ents[i].type,
 			  dec->cdef->data.cdef.ents[i].assoc));
 		}
 	} else {
 		for (i = 0; i < dec->numchans; ++i) {
 			jas_image_setcmpttype(dec->image, dec->chantocmptlut[i],
 			  jp2_getct(jas_image_clrspc(dec->image), 0, i + 1));
 		}
 	}
 	for (i = jas_image_numcmpts(dec->image); i > 0; --i) {
 		if (jas_image_cmpttype(dec->image, i - 1) == JAS_IMAGE_CT_UNKNOWN) {
 			jas_image_delcmpt(dec->image, i - 1);
 		}
 	}
 	if (!jas_image_numcmpts(dec->image)) {
 		jas_eprintf(""error: no components\n"");
 		goto error;
 	}
 #if 0
 jas_eprintf(""no of components is %d\n"", jas_image_numcmpts(dec->image));
 #endif
 	image = dec->image;
 	dec->image = 0;
 	jp2_dec_destroy(dec);
 	return image;
 error:
 	if (box) {
 		jp2_box_destroy(box);
 	}
 	if (dec) {
 		jp2_dec_destroy(dec);
 	}
 	return 0;
 }","[55, 56]",The jp2_colr_destroy function in libjasper/jp2/jp2_cod.c in JasPer before 1.900.10 allows remote attackers to cause a denial of service (NULL pointer dereference).,jasper,CVE-2016-8887,CWE-476
4068,181888," jpc_ms_t *jpc_getms(jas_stream_t *in, jpc_cstate_t *cstate)
 {
 	jpc_ms_t *ms;
 	jpc_mstabent_t *mstabent;
 	jas_stream_t *tmpstream;
 	if (!(ms = jpc_ms_create(0))) {
 		return 0;
 	}
 	if (jpc_getuint16(in, &ms->id) || ms->id < JPC_MS_MIN ||
 	  ms->id > JPC_MS_MAX) {
 		jpc_ms_destroy(ms);
 		return 0;
 	}
 	mstabent = jpc_mstab_lookup(ms->id);
 	ms->ops = &mstabent->ops;
 	if (JPC_MS_HASPARMS(ms->id)) {
 		if (jpc_getuint16(in, &ms->len) || ms->len < 3) {
 			jpc_ms_destroy(ms);
 			return 0;
 		}
 		ms->len -= 2;
 		if (!(tmpstream = jas_stream_memopen(0, 0))) {
 			jpc_ms_destroy(ms);
 			return 0;
 		}
 		if (jas_stream_copy(tmpstream, in, ms->len) ||
 		  jas_stream_seek(tmpstream, 0, SEEK_SET) < 0) {
 			jas_stream_close(tmpstream);
 			jpc_ms_destroy(ms);
 			return 0;
 		}
 		if ((*ms->ops->getparms)(ms, cstate, tmpstream)) {
 			ms->ops = 0;
 			jpc_ms_destroy(ms);
 			jas_stream_close(tmpstream);
 			return 0;
 		}
 		if (jas_getdbglevel() > 0) {
  			jpc_ms_dump(ms, stderr);
  		}
		if (JAS_CAST(ulong, jas_stream_tell(tmpstream)) != ms->len) {
 		if (JAS_CAST(jas_ulong, jas_stream_tell(tmpstream)) != ms->len) {
  			jas_eprintf(
  			  ""warning: trailing garbage in marker segment (%ld bytes)\n"",
  			  ms->len - jas_stream_tell(tmpstream));
 		}
 		jas_stream_close(tmpstream);
 	} else {
 		ms->len = 0;
 		if (jas_getdbglevel() > 0) {
 			jpc_ms_dump(ms, stderr);
 		}
 	}
 	if (ms->id == JPC_MS_SIZ) {
 		cstate->numcomps = ms->parms.siz.numcomps;
 	}
 	return ms;
 }","[41, 42]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
4075,182717," int main(int argc, char *argv[])
 {
 	int32_t ret = GPMF_OK;
 	GPMF_stream metadata_stream, *ms = &metadata_stream;
 	double metadatalength;
 	uint32_t *payload = NULL;  
 	if (argc != 2)
 	{
 		printf(""usage: %s <file_with_GPMF>\n"", argv[0]);
 		return -1;
  	}
  	size_t mp4 = OpenMP4Source(argv[1], MOV_GPMF_TRAK_TYPE, MOV_GPMF_TRAK_SUBTYPE);
 	if (mp4 == 0)
 	{
 		printf(""error: %s is an invalid MP4/MOV\n"", argv[1]);
 		return -1;
 	}
  	metadatalength = GetDuration(mp4);
 	if (metadatalength > 0.0)
 	{
 		uint32_t index, payloads = GetNumberPayloads(mp4);
 #if 1
 		if (payloads == 1)  
 		{
 			uint32_t payloadsize = GetPayloadSize(mp4,0);
 			payload = GetPayload(mp4, payload, 0);
 			if(payload == NULL)
 				goto cleanup;
 			ret = GPMF_Init(ms, payload, payloadsize);
 			if (ret != GPMF_OK)
 				goto cleanup;
 			ret = GPMF_Validate(ms, GPMF_RECURSE_LEVELS);  
 			if (GPMF_OK != ret)
 			{
 				printf(""Invalid Structure\n"");
 				goto cleanup;
 			}
 			GPMF_ResetState(ms);
 			do
 			{
 				PrintGPMF(ms);   
 			} while (GPMF_OK == GPMF_Next(ms, GPMF_RECURSE_LEVELS));
 			GPMF_ResetState(ms);
 			printf(""\n"");
 		}
 #endif
  		for (index = 0; index < payloads; index++)
  		{
  			uint32_t payloadsize = GetPayloadSize(mp4, index);
			float in = 0.0, out = 0.0;  
 			double in = 0.0, out = 0.0;  
  			payload = GetPayload(mp4, payload, index);
  			if (payload == NULL)
  				goto cleanup;
 			ret = GetPayloadTime(mp4, index, &in, &out);
 			if (ret != GPMF_OK)
 				goto cleanup;
 			ret = GPMF_Init(ms, payload, payloadsize);
 			if (ret != GPMF_OK)
 				goto cleanup;
 #if 1		 
 			if (index == 0)  
 			{
 				ret = GPMF_FindNext(ms, GPMF_KEY_STREAM, GPMF_RECURSE_LEVELS);
 				while (GPMF_OK == ret)
 				{
 					ret = GPMF_SeekToSamples(ms);
 					if (GPMF_OK == ret)  
 					{
 						uint32_t key = GPMF_Key(ms);
 						GPMF_SampleType type = GPMF_Type(ms);
 						uint32_t elements = GPMF_ElementsInStruct(ms);
 						uint32_t samples = GPMF_PayloadSampleCount(ms);
 						if (samples)
 						{
 							printf(""  STRM of %c%c%c%c "", PRINTF_4CC(key));
 							if (type == GPMF_TYPE_COMPLEX)
 							{
 								GPMF_stream find_stream;
 								GPMF_CopyState(ms, &find_stream);
 								if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TYPE, GPMF_CURRENT_LEVEL))
 								{
 									char tmp[64];
 									char *data = (char *)GPMF_RawData(&find_stream);
 									int size = GPMF_RawDataSize(&find_stream);
 									if (size < sizeof(tmp))
 									{
 										memcpy(tmp, data, size);
 										tmp[size] = 0;
 										printf(""of type %s "", tmp);
 									}
 								}
 							}
 							else
 							{
 								printf(""of type %c "", type);
 							}
 							printf(""with %d sample%s "", samples, samples > 1 ? ""s"" : """");
 							if (elements > 1)
 								printf(""-- %d elements per sample"", elements);
 							printf(""\n"");
 						}
 						ret = GPMF_FindNext(ms, GPMF_KEY_STREAM, GPMF_RECURSE_LEVELS);
 					}
 					else
 					{
 						if (ret == GPMF_ERROR_BAD_STRUCTURE)  
 						{
 							ret = GPMF_Next(ms, GPMF_CURRENT_LEVEL);  
 						}
 					}
 				}
 				GPMF_ResetState(ms);
 				printf(""\n"");
 			}
 #endif 
 #if 1		 
 			if (index == 0)  
 			{
 				if (GPMF_OK == GPMF_FindNext(ms, STR2FOURCC(""GPS5""), GPMF_RECURSE_LEVELS) ||  
 					GPMF_OK == GPMF_FindNext(ms, STR2FOURCC(""GPRI""), GPMF_RECURSE_LEVELS))    
 				{
 					uint32_t key = GPMF_Key(ms);
 					uint32_t samples = GPMF_Repeat(ms);
 					uint32_t elements = GPMF_ElementsInStruct(ms);
 					uint32_t buffersize = samples * elements * sizeof(double);
 					GPMF_stream find_stream;
 					double *ptr, *tmpbuffer = malloc(buffersize);
 					char units[10][6] = { """" };
 					uint32_t unit_samples = 1;
 					printf(""MP4 Payload time %.3f to %.3f seconds\n"", in, out);
 					if (tmpbuffer && samples)
 					{
 						uint32_t i, j;
 						GPMF_CopyState(ms, &find_stream);
 						if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_SI_UNITS, GPMF_CURRENT_LEVEL) ||
 							GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_UNITS, GPMF_CURRENT_LEVEL))
 						{
 							char *data = (char *)GPMF_RawData(&find_stream);
 							int ssize = GPMF_StructSize(&find_stream);
 							unit_samples = GPMF_Repeat(&find_stream);
 							for (i = 0; i < unit_samples; i++)
 							{
 								memcpy(units[i], data, ssize);
 								units[i][ssize] = 0;
 								data += ssize;
 							}
 						}
 						GPMF_ScaledData(ms, tmpbuffer, buffersize, 0, samples, GPMF_TYPE_DOUBLE);   
 						ptr = tmpbuffer;
 						for (i = 0; i < samples; i++)
 						{
 							printf(""%c%c%c%c "", PRINTF_4CC(key));
 							for (j = 0; j < elements; j++)
 								printf(""%.3f%s, "", *ptr++, units[j%unit_samples]);
 							printf(""\n"");
 						}
 						free(tmpbuffer);
 					}
 				}
 				GPMF_ResetState(ms);
 				printf(""\n"");
 			}
 #endif 
 		}
 #if 1
 		while (GPMF_OK == GPMF_FindNext(ms, GPMF_KEY_STREAM, GPMF_RECURSE_LEVELS))
  		{
  			if (GPMF_OK == GPMF_SeekToSamples(ms))  
  			{
 				double in = 0.0, out = 0.0;
  				uint32_t fourcc = GPMF_Key(ms);
				double rate = GetGPMFSampleRate(mp4, fourcc, GPMF_SAMPLE_RATE_PRECISE); 
				printf(""%c%c%c%c sampling rate = %f Hz\n"", PRINTF_4CC(fourcc), rate);
 				double rate = GetGPMFSampleRate(mp4, fourcc, GPMF_SAMPLE_RATE_PRECISE, &in, &out); 
 				printf(""%c%c%c%c sampling rate = %f Hz (from %f to %f)\n"", PRINTF_4CC(fourcc), rate, in, out);
  			}
  		}
  #endif
 	cleanup:
 		if (payload) FreePayload(payload); payload = NULL;
 		CloseSource(mp4);
 	}
 	return ret;
 }","[13, 14, 15, 16, 17, 50, 51, 171, 173, 174, 175, 176]",GoPro GPMF-parser 1.2.2 has an out-of-bounds write in OpenMP4Source in demo/GPMF_mp4reader.c.,gpmf-parser,CVE-2019-15148,CWE-787
4081,181931," static int mem_resize(jas_stream_memobj_t *m, int bufsize)
  {
  	unsigned char *buf;
	assert(m->buf_);
  	assert(bufsize >= 0);
	if (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char)))) {
 	if (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&
 	  bufsize) {
  		return -1;
  	}
  	m->buf_ = buf;
 	m->bufsize_ = bufsize;
 	return 0;
 }","[4, 6, 7, 8]",Double free vulnerability in the mem_close function in jas_stream.c in JasPer before 1.900.10 allows remote attackers to cause a denial of service (crash) or possibly execute arbitrary code via a crafted BMP image to the imginfo command.,jasper,CVE-2016-8693,CWE-415
4086,181997,"  smb2_flush(smb_request_t *sr)
  {
	smb_ofile_t *of = NULL;
  	uint16_t StructSize;
  	uint16_t reserved1;
  	uint32_t reserved2;
 	smb2fid_t smb2fid;
 	uint32_t status;
 	int rc = 0;
 	rc = smb_mbc_decodef(
 	    &sr->smb_data, ""wwlqq"",
 	    &StructSize,		 
 	    &reserved1,			 
 	    &reserved2,			 
 	    &smb2fid.persistent,	 
 	    &smb2fid.temporal);		 
 	if (rc)
 		return (SDRC_ERROR);
 	if (StructSize != 24)
 		return (SDRC_ERROR);
 	status = smb2sr_lookup_fid(sr, &smb2fid);
 	if (status) {
  		smb2sr_put_error(sr, status);
  		return (SDRC_SUCCESS);
  	}
	of = sr->fid_ofile;
	if ((of->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)
		(void) smb_fsop_commit(sr, of->f_cr, of->f_node);
 	smb_ofile_flush(sr, sr->fid_ofile);
 	(void) smb_mbc_encodef(
 	    &sr->reply, ""wwl"",
 	    4,	 	 
 	    0);  		 
 	return (SDRC_SUCCESS);
 }","[3, 26, 27, 28, 29]",illumos smbsrv NULL pointer dereference allows system crash.,illumos-gate,CVE-2016-6561,CWE-476
4144,182387,"  void jslTokenAsString(int token, char *str, size_t len) {
   assert(len>28);  
    if (token>32 && token<128) {
      assert(len>=4);
     str[0] = '\'';
     str[1] = (char)token;
     str[2] = '\'';
     str[3] = 0;
      return;
    }
    switch (token) {
  case LEX_EOF : strncpy(str, ""EOF"", len); return;
  case LEX_ID : strncpy(str, ""ID"", len); return;
  case LEX_INT : strncpy(str, ""INT"", len); return;
  case LEX_FLOAT : strncpy(str, ""FLOAT"", len); return;
  case LEX_STR : strncpy(str, ""STRING"", len); return;
  case LEX_UNFINISHED_STR : strncpy(str, ""UNFINISHED STRING"", len); return;
  case LEX_TEMPLATE_LITERAL : strncpy(str, ""TEMPLATE LITERAL"", len); return;
  case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy(str, ""UNFINISHED TEMPLATE LITERAL"", len); return;
  case LEX_REGEX : strncpy(str, ""REGEX"", len); return;
  case LEX_UNFINISHED_REGEX : strncpy(str, ""UNFINISHED REGEX"", len); return;
  case LEX_UNFINISHED_COMMENT : strncpy(str, ""UNFINISHED COMMENT"", len); return;
   case LEX_EOF : strcpy(str, ""EOF""); return;
   case LEX_ID : strcpy(str, ""ID""); return;
   case LEX_INT : strcpy(str, ""INT""); return;
   case LEX_FLOAT : strcpy(str, ""FLOAT""); return;
   case LEX_STR : strcpy(str, ""STRING""); return;
   case LEX_UNFINISHED_STR : strcpy(str, ""UNFINISHED STRING""); return;
   case LEX_TEMPLATE_LITERAL : strcpy(str, ""TEMPLATE LITERAL""); return;
   case LEX_UNFINISHED_TEMPLATE_LITERAL : strcpy(str, ""UNFINISHED TEMPLATE LITERAL""); return;
   case LEX_REGEX : strcpy(str, ""REGEX""); return;
   case LEX_UNFINISHED_REGEX : strcpy(str, ""UNFINISHED REGEX""); return;
   case LEX_UNFINISHED_COMMENT : strcpy(str, ""UNFINISHED COMMENT""); return;
    }
    if (token>=_LEX_OPERATOR_START && token<_LEX_R_LIST_END) {
      const char tokenNames[] =
           ""==\0""
           ""===\0""
           ""!=\0""
           ""!==\0""
           ""<=\0""
           ""<<\0""
           ""<<=\0""
           "">=\0""
           "">>\0""
           "">>>\0""
           "">>=\0""
           "">>>=\0""
           ""+=\0""
           ""-=\0""
           ""++\0""
           ""--\0""
           ""*=\0""
           ""/=\0""
           ""%=\0""
           ""&=\0""
           ""&&\0""
           ""|=\0""
           ""||\0""
           ""^=\0""
           ""=>\0""
           ""if\0""
           ""else\0""
           ""do\0""
           ""while\0""
           ""for\0""
           ""return\0""
           ""continue\0""
           ""function\0""
           ""return\0""
           ""var\0""
           ""let\0""
           ""const\0""
           ""this\0""
           ""throw\0""
           ""try\0""
           ""catch\0""
           ""finally\0""
           ""true\0""
           ""false\0""
           ""null\0""
           ""undefined\0""
           ""new\0""
           ""in\0""
           ""instanceof\0""
           ""switch\0""
           ""case\0""
           ""default\0""
           ""delete\0""
           ""typeof\0""
           ""void\0""
           ""debugger\0""
           ""class\0""
           ""extends\0""
             ""super\0""
           ""static\0""
         ;
     unsigned int p = 0;
     int n = token-_LEX_OPERATOR_START;
     while (n>0 && p<sizeof(tokenNames)) {
       while (tokenNames[p] && p<sizeof(tokenNames)) p++;
       p++;  
        n--;  
      }
      assert(n==0);
    strncpy(str, &tokenNames[p], len);
     strcpy(str, &tokenNames[p]);
      return;
    }
  assert(len>=10);
    espruino_snprintf(str, len, ""?[%d]"", token);
  }","[2, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 106, 107, 110]",Espruino before 1.99 allows attackers to cause a denial of service (application crash) and potential Information Disclosure with a user crafted input file via a Buffer Overflow during syntax parsing because strncpy is misused in jslex.c.,Espruino,CVE-2018-11593,CWE-787
4149,181250," static int xpm_decode_frame(AVCodecContext *avctx, void *data,
                             int *got_frame, AVPacket *avpkt)
  {
      XPMDecContext *x = avctx->priv_data;
      AVFrame *p=data;
    const uint8_t *end, *ptr = avpkt->data;
     const uint8_t *end, *ptr;
      int ncolors, cpp, ret, i, j;
      int64_t size;
      uint32_t *dst;
      avctx->pix_fmt = AV_PIX_FMT_BGRA;
    end = avpkt->data + avpkt->size;
    while (memcmp(ptr, ""/* XPM */"", 9) && ptr < end - 9)
     av_fast_padded_malloc(&x->buf, &x->buf_size, avpkt->size);
     if (!x->buf)
         return AVERROR(ENOMEM);
     memcpy(x->buf, avpkt->data, avpkt->size);
     x->buf[avpkt->size] = 0;
     ptr = x->buf;
     end = x->buf + avpkt->size;
     while (end - ptr > 9 && memcmp(ptr, ""/* XPM */"", 9))
          ptr++;
    if (ptr >= end) {
     if (end - ptr <= 9) {
          av_log(avctx, AV_LOG_ERROR, ""missing signature\n"");
          return AVERROR_INVALIDDATA;
      }
     ptr += mod_strcspn(ptr, ""\"""");
     if (sscanf(ptr, ""\""%u %u %u %u\"","",
                &avctx->width, &avctx->height, &ncolors, &cpp) != 4) {
         av_log(avctx, AV_LOG_ERROR, ""missing image parameters\n"");
         return AVERROR_INVALIDDATA;
     }
     if ((ret = ff_set_dimensions(avctx, avctx->width, avctx->height)) < 0)
         return ret;
     if ((ret = ff_get_buffer(avctx, p, 0)) < 0)
         return ret;
     if (cpp <= 0 || cpp >= 5) {
         av_log(avctx, AV_LOG_ERROR, ""unsupported/invalid number of chars per pixel: %d\n"", cpp);
         return AVERROR_INVALIDDATA;
     }
      size = 1;
      for (i = 0; i < cpp; i++)
        size *= 94;
         size *= 95;
      if (ncolors <= 0 || ncolors > size) {
          av_log(avctx, AV_LOG_ERROR, ""invalid number of colors: %d\n"", ncolors);
         return AVERROR_INVALIDDATA;
     }
     size *= 4;
     av_fast_padded_malloc(&x->pixels, &x->pixels_size, size);
     if (!x->pixels)
          return AVERROR(ENOMEM);
      ptr += mod_strcspn(ptr, "","") + 1;
     if (end - ptr < 1)
         return AVERROR_INVALIDDATA;
      for (i = 0; i < ncolors; i++) {
          const uint8_t *index;
          int len;
          ptr += mod_strcspn(ptr, ""\"""") + 1;
        if (ptr + cpp > end)
         if (end - ptr < cpp)
              return AVERROR_INVALIDDATA;
          index = ptr;
          ptr += cpp;
         ptr = strstr(ptr, ""c "");
         if (ptr) {
             ptr += 2;
         } else {
             return AVERROR_INVALIDDATA;
         }
         len = strcspn(ptr, ""\"" "");
         if ((ret = ascii2index(index, cpp)) < 0)
             return ret;
          x->pixels[ret] = color_string_to_rgba(ptr, len);
          ptr += mod_strcspn(ptr, "","") + 1;
         if (end - ptr < 1)
             return AVERROR_INVALIDDATA;
      }
      for (i = 0; i < avctx->height; i++) {
          dst = (uint32_t *)(p->data[0] + i * p->linesize[0]);
         if (end - ptr < 1)
             return AVERROR_INVALIDDATA;
          ptr += mod_strcspn(ptr, ""\"""") + 1;
         if (end - ptr < 1)
             return AVERROR_INVALIDDATA;
          for (j = 0; j < avctx->width; j++) {
            if (ptr + cpp > end)
             if (end - ptr < cpp)
                  return AVERROR_INVALIDDATA;
              if ((ret = ascii2index(ptr, cpp)) < 0)
                 return ret;
             *dst++ = x->pixels[ret];
             ptr += cpp;
         }
         ptr += mod_strcspn(ptr, "","") + 1;
     }
     p->key_frame = 1;
     p->pict_type = AV_PICTURE_TYPE_I;
     *got_frame = 1;
     return avpkt->size;
 }","[6, 7, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 23, 24, 44, 45, 55, 56, 61, 62, 77, 78, 82, 83, 85, 86, 88, 89]",Stack-based buffer overflow in the color_string_to_rgba function in libavcodec/xpmdec.c in FFmpeg 3.3 before 3.3.1 allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted file.,FFmpeg,CVE-2017-9990,CWE-119
4151,181273," yyparse (void *yyscanner, HEX_LEX_ENVIRONMENT *lex_env)
 {
 int yychar;
 YY_INITIAL_VALUE (static YYSTYPE yyval_default;)
 YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
     int yynerrs;
     int yystate;
     int yyerrstatus;
     yytype_int16 yyssa[YYINITDEPTH];
     yytype_int16 *yyss;
     yytype_int16 *yyssp;
     YYSTYPE yyvsa[YYINITDEPTH];
     YYSTYPE *yyvs;
     YYSTYPE *yyvsp;
     YYSIZE_T yystacksize;
   int yyn;
   int yyresult;
   int yytoken = 0;
   YYSTYPE yyval;
 #if YYERROR_VERBOSE
   char yymsgbuf[128];
   char *yymsg = yymsgbuf;
   YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
 #endif
 #define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
   int yylen = 0;
   yyssp = yyss = yyssa;
   yyvsp = yyvs = yyvsa;
   yystacksize = YYINITDEPTH;
   YYDPRINTF ((stderr, ""Starting parse\n""));
   yystate = 0;
   yyerrstatus = 0;
   yynerrs = 0;
   yychar = YYEMPTY;  
   goto yysetstate;
  yynewstate:
   yyssp++;
  yysetstate:
   *yyssp = yystate;
   if (yyss + yystacksize - 1 <= yyssp)
     {
       YYSIZE_T yysize = yyssp - yyss + 1;
 #ifdef yyoverflow
       {
         YYSTYPE *yyvs1 = yyvs;
         yytype_int16 *yyss1 = yyss;
         yyoverflow (YY_(""memory exhausted""),
                     &yyss1, yysize * sizeof (*yyssp),
                     &yyvs1, yysize * sizeof (*yyvsp),
                     &yystacksize);
         yyss = yyss1;
         yyvs = yyvs1;
       }
 #else  
 # ifndef YYSTACK_RELOCATE
       goto yyexhaustedlab;
 # else
       if (YYMAXDEPTH <= yystacksize)
         goto yyexhaustedlab;
       yystacksize *= 2;
       if (YYMAXDEPTH < yystacksize)
         yystacksize = YYMAXDEPTH;
       {
         yytype_int16 *yyss1 = yyss;
         union yyalloc *yyptr =
           (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
         if (! yyptr)
           goto yyexhaustedlab;
         YYSTACK_RELOCATE (yyss_alloc, yyss);
         YYSTACK_RELOCATE (yyvs_alloc, yyvs);
 #  undef YYSTACK_RELOCATE
         if (yyss1 != yyssa)
           YYSTACK_FREE (yyss1);
       }
 # endif
 #endif  
       yyssp = yyss + yysize - 1;
       yyvsp = yyvs + yysize - 1;
       YYDPRINTF ((stderr, ""Stack size increased to %lu\n"",
                   (unsigned long int) yystacksize));
       if (yyss + yystacksize - 1 <= yyssp)
         YYABORT;
     }
   YYDPRINTF ((stderr, ""Entering state %d\n"", yystate));
   if (yystate == YYFINAL)
     YYACCEPT;
   goto yybackup;
 yybackup:
   yyn = yypact[yystate];
   if (yypact_value_is_default (yyn))
     goto yydefault;
   if (yychar == YYEMPTY)
     {
       YYDPRINTF ((stderr, ""Reading a token: ""));
       yychar = yylex (&yylval, yyscanner, lex_env);
     }
   if (yychar <= YYEOF)
     {
       yychar = yytoken = YYEOF;
       YYDPRINTF ((stderr, ""Now at end of input.\n""));
     }
   else
     {
       yytoken = YYTRANSLATE (yychar);
       YY_SYMBOL_PRINT (""Next token is"", yytoken, &yylval, &yylloc);
     }
   yyn += yytoken;
   if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
     goto yydefault;
   yyn = yytable[yyn];
   if (yyn <= 0)
     {
       if (yytable_value_is_error (yyn))
         goto yyerrlab;
       yyn = -yyn;
       goto yyreduce;
     }
   if (yyerrstatus)
     yyerrstatus--;
   YY_SYMBOL_PRINT (""Shifting"", yytoken, &yylval, &yylloc);
   yychar = YYEMPTY;
   yystate = yyn;
   YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
   *++yyvsp = yylval;
   YY_IGNORE_MAYBE_UNINITIALIZED_END
   goto yynewstate;
 yydefault:
   yyn = yydefact[yystate];
   if (yyn == 0)
     goto yyerrlab;
   goto yyreduce;
 yyreduce:
   yylen = yyr2[yyn];
   yyval = yyvsp[1-yylen];
   YY_REDUCE_PRINT (yyn);
    switch (yyn)
      {
          case 2:
#line 106 ""hex_grammar.y""  
 #line 113 ""hex_grammar.y""  
      {
          RE_AST* re_ast = yyget_extra(yyscanner);
          re_ast->root_node = (yyvsp[-1].re_node);
        }
#line 1330 ""hex_grammar.c""  
 #line 1337 ""hex_grammar.c""  
      break;
    case 3:
#line 115 ""hex_grammar.y""  
 #line 122 ""hex_grammar.y""  
      {
          (yyval.re_node) = (yyvsp[0].re_node);
        }
#line 1338 ""hex_grammar.c""  
 #line 1345 ""hex_grammar.c""  
      break;
    case 4:
#line 119 ""hex_grammar.y""  
 #line 126 ""hex_grammar.y""  
      {
         incr_ast_levels();
          (yyval.re_node) = yr_re_node_create(RE_NODE_CONCAT, (yyvsp[-1].re_node), (yyvsp[0].re_node));
          DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[-1].re_node));
          DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[0].re_node));
          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        }
#line 1351 ""hex_grammar.c""  
 #line 1360 ""hex_grammar.c""  
      break;
    case 5:
#line 128 ""hex_grammar.y""  
 #line 137 ""hex_grammar.y""  
      {
          RE_NODE* new_concat;
          RE_NODE* leftmost_concat = NULL;
          RE_NODE* leftmost_node = (yyvsp[-1].re_node);
         incr_ast_levels();
          (yyval.re_node) = NULL;
         while (leftmost_node->type == RE_NODE_CONCAT)
         {
           leftmost_concat = leftmost_node;
           leftmost_node = leftmost_node->left;
         }
         new_concat = yr_re_node_create(
             RE_NODE_CONCAT, (yyvsp[-2].re_node), leftmost_node);
         if (new_concat != NULL)
         {
           if (leftmost_concat != NULL)
           {
             leftmost_concat->left = new_concat;
             (yyval.re_node) = yr_re_node_create(RE_NODE_CONCAT, (yyvsp[-1].re_node), (yyvsp[0].re_node));
           }
           else
           {
             (yyval.re_node) = yr_re_node_create(RE_NODE_CONCAT, new_concat, (yyvsp[0].re_node));
           }
         }
         DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[-2].re_node));
         DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[-1].re_node));
         DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[0].re_node));
          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        }
#line 1413 ""hex_grammar.c""  
 #line 1424 ""hex_grammar.c""  
      break;
    case 6:
#line 190 ""hex_grammar.y""  
 #line 201 ""hex_grammar.y""  
      {
          (yyval.re_node) = (yyvsp[0].re_node);
        }
#line 1421 ""hex_grammar.c""  
 #line 1432 ""hex_grammar.c""  
      break;
    case 7:
#line 194 ""hex_grammar.y""  
 #line 205 ""hex_grammar.y""  
      {
         incr_ast_levels();
          (yyval.re_node) = yr_re_node_create(RE_NODE_CONCAT, (yyvsp[-1].re_node), (yyvsp[0].re_node));
          DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[-1].re_node));
          DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[0].re_node));
          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        }
#line 1434 ""hex_grammar.c""  
 #line 1447 ""hex_grammar.c""  
      break;
    case 8:
#line 207 ""hex_grammar.y""  
 #line 220 ""hex_grammar.y""  
      {
          (yyval.re_node) = (yyvsp[0].re_node);
        }
#line 1442 ""hex_grammar.c""  
 #line 1455 ""hex_grammar.c""  
      break;
    case 9:
#line 211 ""hex_grammar.y""  
 #line 224 ""hex_grammar.y""  
      {
          (yyval.re_node) = (yyvsp[0].re_node);
          (yyval.re_node)->greedy = FALSE;
        }
#line 1451 ""hex_grammar.c""  
 #line 1464 ""hex_grammar.c""  
      break;
    case 10:
#line 220 ""hex_grammar.y""  
 #line 233 ""hex_grammar.y""  
      {
          lex_env->token_count++;
         if (lex_env->token_count > MAX_HEX_STRING_TOKENS)
         {
           yr_re_node_destroy((yyvsp[0].re_node));
           yyerror(yyscanner, lex_env, ""string too long"");
           YYABORT;
         }
          (yyval.re_node) = (yyvsp[0].re_node);
        }
#line 1468 ""hex_grammar.c""  
 #line 1481 ""hex_grammar.c""  
      break;
    case 11:
#line 233 ""hex_grammar.y""  
 #line 246 ""hex_grammar.y""  
      {
          lex_env->inside_or++;
        }
#line 1476 ""hex_grammar.c""  
 #line 1489 ""hex_grammar.c""  
      break;
    case 12:
#line 237 ""hex_grammar.y""  
 #line 250 ""hex_grammar.y""  
      {
          (yyval.re_node) = (yyvsp[-1].re_node);
          lex_env->inside_or--;
        }
#line 1485 ""hex_grammar.c""  
 #line 1498 ""hex_grammar.c""  
      break;
    case 13:
#line 246 ""hex_grammar.y""  
 #line 259 ""hex_grammar.y""  
      {
          if ((yyvsp[-1].integer) <= 0)
          {
           yyerror(yyscanner, lex_env, ""invalid jump length"");
           YYABORT;
         }
         if (lex_env->inside_or && (yyvsp[-1].integer) > STRING_CHAINING_THRESHOLD)
         {
           yyerror(yyscanner, lex_env, ""jumps over ""
               STR(STRING_CHAINING_THRESHOLD)
               "" now allowed inside alternation (|)"");
           YYABORT;
         }
         (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY, NULL, NULL);
         ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
          (yyval.re_node)->start = (int) (yyvsp[-1].integer);
          (yyval.re_node)->end = (int) (yyvsp[-1].integer);
        }
#line 1512 ""hex_grammar.c""  
 #line 1525 ""hex_grammar.c""  
      break;
    case 14:
#line 269 ""hex_grammar.y""  
 #line 282 ""hex_grammar.y""  
      {
          if (lex_env->inside_or &&
              ((yyvsp[-3].integer) > STRING_CHAINING_THRESHOLD ||
              (yyvsp[-1].integer) > STRING_CHAINING_THRESHOLD) )
         {
           yyerror(yyscanner, lex_env, ""jumps over ""
               STR(STRING_CHAINING_THRESHOLD)
               "" now allowed inside alternation (|)"");
           YYABORT;
         }
         if ((yyvsp[-3].integer) < 0 || (yyvsp[-1].integer) < 0)
         {
           yyerror(yyscanner, lex_env, ""invalid negative jump length"");
           YYABORT;
         }
         if ((yyvsp[-3].integer) > (yyvsp[-1].integer))
         {
           yyerror(yyscanner, lex_env, ""invalid jump range"");
           YYABORT;
         }
         (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY, NULL, NULL);
         ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
          (yyval.re_node)->start = (int) (yyvsp[-3].integer);
          (yyval.re_node)->end = (int) (yyvsp[-1].integer);
        }
#line 1548 ""hex_grammar.c""  
 #line 1561 ""hex_grammar.c""  
      break;
    case 15:
#line 301 ""hex_grammar.y""  
 #line 314 ""hex_grammar.y""  
      {
          if (lex_env->inside_or)
          {
           yyerror(yyscanner, lex_env,
               ""unbounded jumps not allowed inside alternation (|)"");
           YYABORT;
         }
         if ((yyvsp[-2].integer) < 0)
         {
           yyerror(yyscanner, lex_env, ""invalid negative jump length"");
           YYABORT;
         }
         (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY, NULL, NULL);
         ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
          (yyval.re_node)->start = (int) (yyvsp[-2].integer);
          (yyval.re_node)->end = INT_MAX;
        }
#line 1574 ""hex_grammar.c""  
 #line 1587 ""hex_grammar.c""  
      break;
    case 16:
#line 323 ""hex_grammar.y""  
 #line 336 ""hex_grammar.y""  
      {
          if (lex_env->inside_or)
          {
           yyerror(yyscanner, lex_env,
               ""unbounded jumps not allowed inside alternation (|)"");
           YYABORT;
         }
         (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY, NULL, NULL);
         ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
          (yyval.re_node)->start = 0;
          (yyval.re_node)->end = INT_MAX;
        }
#line 1594 ""hex_grammar.c""  
 #line 1607 ""hex_grammar.c""  
      break;
    case 17:
#line 343 ""hex_grammar.y""  
 #line 356 ""hex_grammar.y""  
      {
            (yyval.re_node) = (yyvsp[0].re_node);
        }
#line 1602 ""hex_grammar.c""  
 #line 1615 ""hex_grammar.c""  
      break;
    case 18:
#line 347 ""hex_grammar.y""  
 #line 360 ""hex_grammar.y""  
      {
          mark_as_not_fast_regexp();
         incr_ast_levels();
          (yyval.re_node) = yr_re_node_create(RE_NODE_ALT, (yyvsp[-2].re_node), (yyvsp[0].re_node));
         DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[-2].re_node));
         DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[0].re_node));
          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        }
#line 1617 ""hex_grammar.c""  
 #line 1631 ""hex_grammar.c""  
      break;
    case 19:
#line 361 ""hex_grammar.y""  
 #line 375 ""hex_grammar.y""  
      {
          (yyval.re_node) = yr_re_node_create(RE_NODE_LITERAL, NULL, NULL);
          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
          (yyval.re_node)->value = (int) (yyvsp[0].integer);
        }
#line 1629 ""hex_grammar.c""  
 #line 1643 ""hex_grammar.c""  
      break;
    case 20:
#line 369 ""hex_grammar.y""  
 #line 383 ""hex_grammar.y""  
      {
          uint8_t mask = (uint8_t) ((yyvsp[0].integer) >> 8);
         if (mask == 0x00)
         {
           (yyval.re_node) = yr_re_node_create(RE_NODE_ANY, NULL, NULL);
           ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
         }
         else
         {
           (yyval.re_node) = yr_re_node_create(RE_NODE_MASKED_LITERAL, NULL, NULL);
           ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
           (yyval.re_node)->value = (yyvsp[0].integer) & 0xFF;
            (yyval.re_node)->mask = mask;
          }
        }
#line 1653 ""hex_grammar.c""  
 #line 1667 ""hex_grammar.c""  
      break;
#line 1657 ""hex_grammar.c""  
 #line 1671 ""hex_grammar.c""  
        default: break;
      }
   YY_SYMBOL_PRINT (""-> $$ ="", yyr1[yyn], &yyval, &yyloc);
   YYPOPSTACK (yylen);
   yylen = 0;
   YY_STACK_PRINT (yyss, yyssp);
   *++yyvsp = yyval;
   yyn = yyr1[yyn];
   yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
   if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
     yystate = yytable[yystate];
   else
     yystate = yydefgoto[yyn - YYNTOKENS];
   goto yynewstate;
 yyerrlab:
   yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
   if (!yyerrstatus)
     {
       ++yynerrs;
 #if ! YYERROR_VERBOSE
       yyerror (yyscanner, lex_env, YY_(""syntax error""));
 #else
 # define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
                                         yyssp, yytoken)
       {
         char const *yymsgp = YY_(""syntax error"");
         int yysyntax_error_status;
         yysyntax_error_status = YYSYNTAX_ERROR;
         if (yysyntax_error_status == 0)
           yymsgp = yymsg;
         else if (yysyntax_error_status == 1)
           {
             if (yymsg != yymsgbuf)
               YYSTACK_FREE (yymsg);
             yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
             if (!yymsg)
               {
                 yymsg = yymsgbuf;
                 yymsg_alloc = sizeof yymsgbuf;
                 yysyntax_error_status = 2;
               }
             else
               {
                 yysyntax_error_status = YYSYNTAX_ERROR;
                 yymsgp = yymsg;
               }
           }
         yyerror (yyscanner, lex_env, yymsgp);
         if (yysyntax_error_status == 2)
           goto yyexhaustedlab;
       }
 # undef YYSYNTAX_ERROR
 #endif
     }
   if (yyerrstatus == 3)
     {
       if (yychar <= YYEOF)
         {
           if (yychar == YYEOF)
             YYABORT;
         }
       else
         {
           yydestruct (""Error: discarding"",
                       yytoken, &yylval, yyscanner, lex_env);
           yychar = YYEMPTY;
         }
     }
   goto yyerrlab1;
 yyerrorlab:
   if (  0)
      goto yyerrorlab;
   YYPOPSTACK (yylen);
   yylen = 0;
   YY_STACK_PRINT (yyss, yyssp);
   yystate = *yyssp;
   goto yyerrlab1;
 yyerrlab1:
   yyerrstatus = 3;       
   for (;;)
     {
       yyn = yypact[yystate];
       if (!yypact_value_is_default (yyn))
         {
           yyn += YYTERROR;
           if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
             {
               yyn = yytable[yyn];
               if (0 < yyn)
                 break;
             }
         }
       if (yyssp == yyss)
         YYABORT;
       yydestruct (""Error: popping"",
                   yystos[yystate], yyvsp, yyscanner, lex_env);
       YYPOPSTACK (1);
       yystate = *yyssp;
       YY_STACK_PRINT (yyss, yyssp);
     }
   YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
   *++yyvsp = yylval;
   YY_IGNORE_MAYBE_UNINITIALIZED_END
   YY_SYMBOL_PRINT (""Shifting"", yystos[yyn], yyvsp, yylsp);
   yystate = yyn;
   goto yynewstate;
 yyacceptlab:
   yyresult = 0;
   goto yyreturn;
 yyabortlab:
   yyresult = 1;
   goto yyreturn;
 #if !defined yyoverflow || YYERROR_VERBOSE
 yyexhaustedlab:
   yyerror (yyscanner, lex_env, YY_(""memory exhausted""));
   yyresult = 2;
 #endif
 yyreturn:
   if (yychar != YYEMPTY)
     {
       yytoken = YYTRANSLATE (yychar);
       yydestruct (""Cleanup: discarding lookahead"",
                   yytoken, &yylval, yyscanner, lex_env);
     }
   YYPOPSTACK (yylen);
   YY_STACK_PRINT (yyss, yyssp);
   while (yyssp != yyss)
     {
       yydestruct (""Cleanup: popping"",
                   yystos[*yyssp], yyvsp, yyscanner, lex_env);
       YYPOPSTACK (1);
     }
 #ifndef yyoverflow
   if (yyss != yyssa)
     YYSTACK_FREE (yyss);
 #endif
 #if YYERROR_VERBOSE
   if (yymsg != yymsgbuf)
     YYSTACK_FREE (yymsg);
  #endif
    return yyresult;
  }","[139, 140, 145, 146, 149, 150, 154, 155, 158, 159, 161, 167, 168, 171, 172, 177, 203, 204, 207, 208, 212, 213, 216, 217, 219, 225, 226, 229, 230, 234, 235, 238, 239, 244, 245, 248, 249, 260, 261, 264, 265, 269, 270, 273, 274, 279, 280, 283, 284, 303, 304, 307, 308, 334, 335, 338, 339, 357, 358, 361, 362, 375, 376, 379, 380, 384, 385, 388, 389, 392, 398, 399, 402, 403, 409, 410, 413, 414, 430, 431, 433, 434]","libyara/re.c in the regexp module in YARA 3.5.0 allows remote attackers to cause a denial of service (stack consumption) via a crafted rule (involving hex strings) that is mishandled in the _yr_re_emit function, a different vulnerability than CVE-2017-9304.",yara,CVE-2017-9438,CWE-674
4188,181280," forward_search_range(regex_t* reg, const UChar* str, const UChar* end, UChar* s,
 		     UChar* range, UChar** low, UChar** high, UChar** low_prev)
 {
   UChar *p, *pprev = (UChar* )NULL;
 #ifdef ONIG_DEBUG_SEARCH
   fprintf(stderr, ""forward_search_range: str: %d, end: %d, s: %d, range: %d\n"",
 	  (int )str, (int )end, (int )s, (int )range);
 #endif
   p = s;
   if (reg->dmin > 0) {
     if (ONIGENC_IS_SINGLEBYTE(reg->enc)) {
       p += reg->dmin;
      }
      else {
        UChar *q = p + reg->dmin;
       if (q >= end) return 0;  
        while (p < q) p += enclen(reg->enc, p);
      }
    }
  retry:
   switch (reg->optimize) {
   case ONIG_OPTIMIZE_EXACT:
     p = slow_search(reg->enc, reg->exact, reg->exact_end, p, end, range);
     break;
   case ONIG_OPTIMIZE_EXACT_IC:
     p = slow_search_ic(reg->enc, reg->case_fold_flag,
                        reg->exact, reg->exact_end, p, end, range);
     break;
   case ONIG_OPTIMIZE_EXACT_BM:
     p = bm_search(reg, reg->exact, reg->exact_end, p, end, range);
     break;
   case ONIG_OPTIMIZE_EXACT_BM_NOT_REV:
     p = bm_search_notrev(reg, reg->exact, reg->exact_end, p, end, range);
     break;
   case ONIG_OPTIMIZE_MAP:
     p = map_search(reg->enc, reg->map, p, range);
     break;
   }
   if (p && p < range) {
     if (p - reg->dmin < s) {
     retry_gate:
       pprev = p;
       p += enclen(reg->enc, p);
       goto retry;
     }
     if (reg->sub_anchor) {
       UChar* prev;
       switch (reg->sub_anchor) {
       case ANCHOR_BEGIN_LINE:
         if (!ON_STR_BEGIN(p)) {
           prev = onigenc_get_prev_char_head(reg->enc,
                                             (pprev ? pprev : str), p);
           if (!ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))
             goto retry_gate;
         }
         break;
       case ANCHOR_END_LINE:
         if (ON_STR_END(p)) {
 #ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE
           prev = (UChar* )onigenc_get_prev_char_head(reg->enc,
                                                      (pprev ? pprev : str), p);
           if (prev && ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))
             goto retry_gate;
 #endif
         }
         else if (! ONIGENC_IS_MBC_NEWLINE(reg->enc, p, end)
 #ifdef USE_CRNL_AS_LINE_TERMINATOR
                  && ! ONIGENC_IS_MBC_CRNL(reg->enc, p, end)
 #endif
                  )
           goto retry_gate;
         break;
       }
     }
     if (reg->dmax == 0) {
       *low = p;
       if (low_prev) {
         if (*low > s)
           *low_prev = onigenc_get_prev_char_head(reg->enc, s, p);
         else
           *low_prev = onigenc_get_prev_char_head(reg->enc,
                                                  (pprev ? pprev : str), p);
       }
     }
     else {
       if (reg->dmax != ONIG_INFINITE_DISTANCE) {
         *low = p - reg->dmax;
         if (*low > s) {
           *low = onigenc_get_right_adjust_char_head_with_prev(reg->enc, s,
                                           *low, (const UChar** )low_prev);
           if (low_prev && IS_NULL(*low_prev))
             *low_prev = onigenc_get_prev_char_head(reg->enc,
                                                    (pprev ? pprev : s), *low);
         }
         else {
           if (low_prev)
             *low_prev = onigenc_get_prev_char_head(reg->enc,
                                                    (pprev ? pprev : str), *low);
         }
       }
     }
     *high = p - reg->dmin;
 #ifdef ONIG_DEBUG_SEARCH
     fprintf(stderr,
     ""forward_search_range success: low: %d, high: %d, dmin: %d, dmax: %d\n"",
 	    (int )(*low - str), (int )(*high - str), reg->dmin, reg->dmax);
 #endif
     return 1;  
   }
   return 0;  
 }",[16],"An issue was discovered in Oniguruma 6.2.0, as used in Oniguruma-mod in Ruby through 2.4.1 and mbstring in PHP through 7.1.5. A stack out-of-bounds read occurs in mbc_enc_len() during regular expression searching. Invalid handling of reg->dmin in forward_search_range() could result in an invalid pointer dereference, as an out-of-bounds read from a stack buffer.",oniguruma,CVE-2017-9227,CWE-125
4211,182708," static uint8_t excluded_channels(bitfile *ld, drc_info *drc)
 {
     uint8_t i, n = 0;
     uint8_t num_excl_chan = 7;
     for (i = 0; i < 7; i++)
     {
         drc->exclude_mask[i] = faad_get1bit(ld
             DEBUGVAR(1,103,""excluded_channels(): exclude_mask""));
     }
     n++;
      while ((drc->additional_excluded_chns[n-1] = faad_get1bit(ld
          DEBUGVAR(1,104,""excluded_channels(): additional_excluded_chns""))) == 1)
      {
         if (i >= MAX_CHANNELS - num_excl_chan - 7)
             return n;
          for (i = num_excl_chan; i < num_excl_chan+7; i++)
          {
              drc->exclude_mask[i] = faad_get1bit(ld
                 DEBUGVAR(1,105,""excluded_channels(): exclude_mask""));
         }
         n++;
         num_excl_chan += 7;
     }
     return n;
 }","[14, 15]","An issue was discovered in Freeware Advanced Audio Decoder 2 (FAAD2) 2.8.8. The faad_resetbits function in libfaad/bits.c is affected by a buffer overflow vulnerability. The number of bits to be read is determined by ld->buffer_size - words*4, cast to uint32. If ld->buffer_size - words*4 is negative, a buffer overflow is later performed via getdword_n(&ld->start[words], ld->bytes_left).",faad2,CVE-2019-15296,CWE-119
4218,178618," ProcXIChangeHierarchy(ClientPtr client)
 {
     xXIAnyHierarchyChangeInfo *any;
     size_t len;			 
     int rc = Success;
     int flags[MAXDEVICES] = { 0 };
     REQUEST(xXIChangeHierarchyReq);
     REQUEST_AT_LEAST_SIZE(xXIChangeHierarchyReq);
      if (!stuff->num_changes)
          return rc;
    len = ((size_t)stuff->length << 2) - sizeof(xXIAnyHierarchyChangeInfo);
     len = ((size_t)stuff->length << 2) - sizeof(xXIChangeHierarchyReq);
      any = (xXIAnyHierarchyChangeInfo *) &stuff[1];
      while (stuff->num_changes--) {
         if (len < sizeof(xXIAnyHierarchyChangeInfo)) {
             rc = BadLength;
             goto unwind;
         }
         SWAPIF(swaps(&any->type));
         SWAPIF(swaps(&any->length));
         if (len < ((size_t)any->length << 2))
             return BadLength;
 #define CHANGE_SIZE_MATCH(type) \
     do { \
         if ((len < sizeof(type)) || (any->length != (sizeof(type) >> 2))) { \
             rc = BadLength; \
             goto unwind; \
         } \
     } while(0)
         switch (any->type) {
         case XIAddMaster:
         {
             xXIAddMasterInfo *c = (xXIAddMasterInfo *) any;
             if (len < sizeof(xXIAddMasterInfo)) {
                 rc = BadLength;
                 goto unwind;
             }
             SWAPIF(swaps(&c->name_len));
             if (c->name_len > (len - sizeof(xXIAddMasterInfo))) {
                 rc = BadLength;
                 goto unwind;
             }
             rc = add_master(client, c, flags);
             if (rc != Success)
                 goto unwind;
         }
             break;
         case XIRemoveMaster:
         {
             xXIRemoveMasterInfo *r = (xXIRemoveMasterInfo *) any;
             CHANGE_SIZE_MATCH(xXIRemoveMasterInfo);
             rc = remove_master(client, r, flags);
             if (rc != Success)
                 goto unwind;
         }
             break;
         case XIDetachSlave:
         {
             xXIDetachSlaveInfo *c = (xXIDetachSlaveInfo *) any;
             CHANGE_SIZE_MATCH(xXIDetachSlaveInfo);
             rc = detach_slave(client, c, flags);
             if (rc != Success)
                 goto unwind;
         }
             break;
         case XIAttachSlave:
         {
             xXIAttachSlaveInfo *c = (xXIAttachSlaveInfo *) any;
             CHANGE_SIZE_MATCH(xXIAttachSlaveInfo);
             rc = attach_slave(client, c, flags);
             if (rc != Success)
                 goto unwind;
         }
             break;
         }
         len -= any->length * 4;
         any = (xXIAnyHierarchyChangeInfo *) ((char *) any + any->length * 4);
     }
  unwind:
     XISendDeviceHierarchyEvent(flags);
     return rc;
 }","[11, 12]",xorg-x11-server before 1.19.5 had wrong extra length check in ProcXIChangeHierarchy function allowing malicious X client to cause X server to crash or possibly execute arbitrary code.,xserver,CVE-2017-12178,CWE-20
4247,179179," static int filter_frame(AVFilterLink *inlink, AVFrame *frame)
 {
     AVFilterContext *ctx = inlink->dst;
     const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);
      uint32_t plane_checksum[4] = {0}, checksum = 0;
      int i, plane, vsub = desc->log2_chroma_h;
    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {
     for (plane = 0; plane < 4 && frame->data[plane] && frame->linesize[plane]; plane++) {
          int64_t linesize = av_image_get_linesize(frame->format, frame->width, plane);
          uint8_t *data = frame->data[plane];
          int h = plane == 1 || plane == 2 ? FF_CEIL_RSHIFT(inlink->h, vsub) : inlink->h;
         if (linesize < 0)
             return linesize;
         for (i = 0; i < h; i++) {
             plane_checksum[plane] = av_adler32_update(plane_checksum[plane], data, linesize);
             checksum = av_adler32_update(checksum, data, linesize);
             data += frame->linesize[plane];
         }
     }
     av_log(ctx, AV_LOG_INFO,
            ""n:%""PRId64"" pts:%s pts_time:%s pos:%""PRId64"" ""
            ""fmt:%s sar:%d/%d s:%dx%d i:%c iskey:%d type:%c ""
            ""checksum:%08X plane_checksum:[%08X"",
            inlink->frame_count,
            av_ts2str(frame->pts), av_ts2timestr(frame->pts, &inlink->time_base), av_frame_get_pkt_pos(frame),
            desc->name,
            frame->sample_aspect_ratio.num, frame->sample_aspect_ratio.den,
            frame->width, frame->height,
            !frame->interlaced_frame ? 'P' :          
            frame->top_field_first   ? 'T' : 'B',     
            frame->key_frame,
             av_get_picture_type_char(frame->pict_type),
             checksum, plane_checksum[0]);
    for (plane = 1; plane < 4 && frame->data[plane]; plane++)
     for (plane = 1; plane < 4 && frame->data[plane] && frame->linesize[plane]; plane++)
          av_log(ctx, AV_LOG_INFO, "" %08X"", plane_checksum[plane]);
      av_log(ctx, AV_LOG_INFO, ""]\n"");
     return ff_filter_frame(inlink->dst->outputs[0], frame);
 }","[7, 8, 34, 35]","libavfilter in FFmpeg before 2.0.1 has unspecified impact and remote vectors related to a crafted *plane,* which triggers an out-of-bounds heap write.",FFmpeg,CVE-2013-4263,CWE-119
4256,181245," static int read_gab2_sub(AVFormatContext *s, AVStream *st, AVPacket *pkt)
 {
     if (pkt->size >= 7 &&
         pkt->size < INT_MAX - AVPROBE_PADDING_SIZE &&
         !strcmp(pkt->data, ""GAB2"") && AV_RL16(pkt->data + 5) == 2) {
         uint8_t desc[256];
         int score      = AVPROBE_SCORE_EXTENSION, ret;
         AVIStream *ast = st->priv_data;
         AVInputFormat *sub_demuxer;
         AVRational time_base;
         int size;
         AVIOContext *pb = avio_alloc_context(pkt->data + 7,
                                              pkt->size - 7,
                                              0, NULL, NULL, NULL, NULL);
         AVProbeData pd;
         unsigned int desc_len = avio_rl32(pb);
         if (desc_len > pb->buf_end - pb->buf_ptr)
             goto error;
         ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));
         avio_skip(pb, desc_len - ret);
         if (*desc)
             av_dict_set(&st->metadata, ""title"", desc, 0);
         avio_rl16(pb);    
         avio_rl32(pb);    
         size = pb->buf_end - pb->buf_ptr;
         pd = (AVProbeData) { .buf      = av_mallocz(size + AVPROBE_PADDING_SIZE),
                              .buf_size = size };
         if (!pd.buf)
             goto error;
         memcpy(pd.buf, pb->buf_ptr, size);
         sub_demuxer = av_probe_input_format2(&pd, 1, &score);
         av_freep(&pd.buf);
          if (!sub_demuxer)
              goto error;
         if (strcmp(sub_demuxer->name, ""srt"") && strcmp(sub_demuxer->name, ""ass""))
             goto error;
          if (!(ast->sub_ctx = avformat_alloc_context()))
              goto error;
         ast->sub_ctx->pb = pb;
         if (ff_copy_whiteblacklists(ast->sub_ctx, s) < 0)
             goto error;
         if (!avformat_open_input(&ast->sub_ctx, """", sub_demuxer, NULL)) {
             if (ast->sub_ctx->nb_streams != 1)
                 goto error;
             ff_read_packet(ast->sub_ctx, &ast->sub_pkt);
             avcodec_parameters_copy(st->codecpar, ast->sub_ctx->streams[0]->codecpar);
             time_base = ast->sub_ctx->streams[0]->time_base;
             avpriv_set_pts_info(st, 64, time_base.num, time_base.den);
         }
         ast->sub_buffer = pkt->data;
         memset(pkt, 0, sizeof(*pkt));
         return 1;
 error:
         av_freep(&ast->sub_ctx);
         av_freep(&pb);
     }
     return 0;
 }","[35, 36]","FFmpeg before 2.8.12, 3.0.x and 3.1.x before 3.1.9, 3.2.x before 3.2.6, and 3.3.x before 3.3.2 does not properly restrict HTTP Live Streaming filename extensions and demuxer names, which allows attackers to read arbitrary files via crafted playlist data.",FFmpeg,CVE-2017-9993,CWE-200
4260,181246," static int decode_dds1(GetByteContext *gb, uint8_t *frame, int width, int height)
 {
     const uint8_t *frame_start = frame;
     const uint8_t *frame_end   = frame + width * height;
     int mask = 0x10000, bitbuf = 0;
     int i, v, offset, count, segments;
     segments = bytestream2_get_le16(gb);
     while (segments--) {
         if (bytestream2_get_bytes_left(gb) < 2)
             return AVERROR_INVALIDDATA;
         if (mask == 0x10000) {
             bitbuf = bytestream2_get_le16u(gb);
             mask = 1;
         }
         if (bitbuf & mask) {
             v = bytestream2_get_le16(gb);
             offset = (v & 0x1FFF) << 2;
             count = ((v >> 13) + 2) << 1;
             if (frame - frame_start < offset || frame_end - frame < count*2 + width)
                 return AVERROR_INVALIDDATA;
             for (i = 0; i < count; i++) {
                 frame[0] = frame[1] =
                 frame[width] = frame[width + 1] = frame[-offset];
                 frame += 2;
             }
         } else if (bitbuf & (mask << 1)) {
             v = bytestream2_get_le16(gb)*2;
             if (frame - frame_end < v)
                  return AVERROR_INVALIDDATA;
              frame += v;
          } else {
            if (frame_end - frame < width + 3)
             if (frame_end - frame < width + 4)
                  return AVERROR_INVALIDDATA;
              frame[0] = frame[1] =
              frame[width] = frame[width + 1] =  bytestream2_get_byte(gb);
             frame += 2;
             frame[0] = frame[1] =
             frame[width] = frame[width + 1] =  bytestream2_get_byte(gb);
             frame += 2;
         }
         mask <<= 2;
     }
     return 0;
 }","[32, 33]","Heap-based buffer overflow in the decode_dds1 function in libavcodec/dfa.c in FFmpeg before 2.8.12, 3.0.x before 3.0.8, 3.1.x before 3.1.8, 3.2.x before 3.2.5, and 3.3.x before 3.3.1 allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted file.",FFmpeg,CVE-2017-9992,CWE-119
4263,182655," parse_rockridge(struct archive_read *a, struct file_info *file,
      const unsigned char *p, const unsigned char *end)
  {
  	struct iso9660 *iso9660;
 	int entry_seen = 0;
  	iso9660 = (struct iso9660 *)(a->format->data);
 	while (p + 4 <= end   
 	    && p[0] >= 'A' && p[0] <= 'Z'  
 	    && p[1] >= 'A' && p[1] <= 'Z'  
 	    && p[2] >= 4  
 	    && p + p[2] <= end) {  
 		const unsigned char *data = p + 4;
 		int data_length = p[2] - 4;
 		int version = p[3];
 		switch(p[0]) {
 		case 'C':
 			if (p[1] == 'E') {
 				if (version == 1 && data_length == 24) {
 					int32_t location =
 					    archive_le32dec(data);
 					file->ce_offset =
 					    archive_le32dec(data+8);
 					file->ce_size =
 					    archive_le32dec(data+16);
 					if (register_CE(a, location, file)
 					    != ARCHIVE_OK)
 						return (ARCHIVE_FATAL);
 				}
 			}
 			else if (p[1] == 'L') {
 				if (version == 1 && data_length == 8) {
 					file->cl_offset = (uint64_t)
 					    iso9660->logical_block_size *
 					    (uint64_t)archive_le32dec(data);
 					iso9660->seenRockridge = 1;
 				}
 			}
 			break;
 		case 'N':
 			if (p[1] == 'M') {
 				if (version == 1) {
 					parse_rockridge_NM1(file,
 					    data, data_length);
 					iso9660->seenRockridge = 1;
 				}
 			}
 			break;
 		case 'P':
 			if (p[1] == 'N') {
 				if (version == 1 && data_length == 16) {
 					file->rdev = toi(data,4);
 					file->rdev <<= 32;
 					file->rdev |= toi(data + 8, 4);
 					iso9660->seenRockridge = 1;
 				}
 			}
 			else if (p[1] == 'X') {
 				if (version == 1) {
 					if (data_length >= 8)
 						file->mode
 						    = toi(data, 4);
 					if (data_length >= 16)
 						file->nlinks
 						    = toi(data + 8, 4);
 					if (data_length >= 24)
 						file->uid
 						    = toi(data + 16, 4);
 					if (data_length >= 32)
 						file->gid
 						    = toi(data + 24, 4);
 					if (data_length >= 40)
 						file->number
 						    = toi(data + 32, 4);
 					iso9660->seenRockridge = 1;
 				}
 			}
 			break;
 		case 'R':
 			if (p[1] == 'E' && version == 1) {
 				file->re = 1;
 				iso9660->seenRockridge = 1;
 			}
 			else if (p[1] == 'R' && version == 1) {
 			}
 			break;
 		case 'S':
 			if (p[1] == 'L') {
 				if (version == 1) {
 					parse_rockridge_SL1(file,
 					    data, data_length);
 					iso9660->seenRockridge = 1;
 				}
 			}
 			else if (p[1] == 'T'
 			    && data_length == 0 && version == 1) {
 				iso9660->seenSUSP = 0;
 				iso9660->seenRockridge = 0;
 				return (ARCHIVE_OK);
 			}
 			break;
 		case 'T':
 			if (p[1] == 'F') {
 				if (version == 1) {
 					parse_rockridge_TF1(file,
 					    data, data_length);
 					iso9660->seenRockridge = 1;
 				}
 			}
 			break;
 		case 'Z':
 			if (p[1] == 'F') {
 				if (version == 1)
 					parse_rockridge_ZF1(file,
 					    data, data_length);
 			}
 			break;
 		default:
 			break;
  		}
  		p += p[2];
 		entry_seen = 1;
 	}
 	if (entry_seen)
 		return (ARCHIVE_OK);
 	else {
 		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
 				  ""Tried to parse Rockridge extensions, but none found"");
 		return (ARCHIVE_WARN);
  	}
	return (ARCHIVE_OK);
  }","[5, 121, 122, 123, 124, 125, 126, 127, 128, 130]","libarchive version commit 5a98dcf8a86364b3c2c469c85b93647dfb139961 onwards (version v2.8.0 onwards) contains a CWE-835: Loop with Unreachable Exit Condition ('Infinite Loop') vulnerability in ISO9660 parser, archive_read_support_format_iso9660.c, read_CE()/parse_rockridge() that can result in DoS by infinite loop. This attack appears to be exploitable via the victim opening a specially crafted ISO9660 file.",libarchive,CVE-2019-1000020,CWE-400
4285,181912," static int ras_getdatastd(jas_stream_t *in, ras_hdr_t *hdr, ras_cmap_t *cmap,
   jas_image_t *image)
 {
 	int pad;
 	int nz;
 	int z;
 	int c;
 	int y;
 	int x;
 	int v;
 	int i;
 	jas_matrix_t *data[3];
  	cmap = 0;
 	assert(jas_image_numcmpts(image) <= 3);
 	for (i = 0; i < 3; ++i) {
 		data[i] = 0;
 	}
  	for (i = 0; i < jas_image_numcmpts(image); ++i) {
		data[i] = jas_matrix_create(1, jas_image_width(image));
		assert(data[i]);
 		if (!(data[i] = jas_matrix_create(1, jas_image_width(image)))) {
 			goto error;
 		}
  	}
  	pad = RAS_ROWSIZE(hdr) - (hdr->width * hdr->depth + 7) / 8;
 	for (y = 0; y < hdr->height; y++) {
 		nz = 0;
 		z = 0;
  		for (x = 0; x < hdr->width; x++) {
  			while (nz < hdr->depth) {
  				if ((c = jas_stream_getc(in)) == EOF) {
					return -1;
 					goto error;
  				}
  				z = (z << 8) | c;
  				nz += 8;
 			}
 			v = (z >> (nz - hdr->depth)) & RAS_ONES(hdr->depth);
 			z &= RAS_ONES(nz - hdr->depth);
 			nz -= hdr->depth;
 			if (jas_image_numcmpts(image) == 3) {
 				jas_matrix_setv(data[0], x, (RAS_GETRED(v)));
 				jas_matrix_setv(data[1], x, (RAS_GETGREEN(v)));
 				jas_matrix_setv(data[2], x, (RAS_GETBLUE(v)));
 			} else {
 				jas_matrix_setv(data[0], x, (v));
 			}
  		}
  		if (pad) {
  			if ((c = jas_stream_getc(in)) == EOF) {
				return -1;
 				goto error;
  			}
  		}
  		for (i = 0; i < jas_image_numcmpts(image); ++i) {
  			if (jas_image_writecmpt(image, i, 0, y, hdr->width, 1,
  			  data[i])) {
				return -1;
 				goto error;
  			}
  		}
  	}
  	for (i = 0; i < jas_image_numcmpts(image); ++i) {
  		jas_matrix_destroy(data[i]);
 		data[i] = 0;
  	}
  	return 0;
 error:
 	for (i = 0; i < 3; ++i) {
 		if (data[i]) {
 			jas_matrix_destroy(data[i]);
 		}
 	}
 	return -1;
  }","[14, 15, 16, 17, 19, 20, 21, 22, 23, 32, 33, 51, 52, 58, 59, 65, 68, 69, 70, 71, 72, 73, 74]",The ras_getcmap function in ras_dec.c in JasPer before 1.900.14 allows remote attackers to cause a denial of service (assertion failure) via a crafted image file.,jasper,CVE-2016-9388,
4348,179497," _fep_open_control_socket (Fep *fep)
 {
   struct sockaddr_un sun;
   char *path;
   int fd;
   ssize_t sun_len;
   fd = socket (AF_UNIX, SOCK_STREAM, 0);
   if (fd < 0)
     {
       perror (""socket"");
       return -1;
     }
   path = create_socket_name (""fep-XXXXXX/control"");
   if (strlen (path) + 1 >= sizeof(sun.sun_path))
     {
       fep_log (FEP_LOG_LEVEL_WARNING,
 	       ""unix domain socket path too long: %d + 1 >= %d"",
 	       strlen (path),
 	       sizeof (sun.sun_path));
       free (path);
       return -1;
     }
    memset (&sun, 0, sizeof(sun));
    sun.sun_family = AF_UNIX;
#ifdef __linux__
  sun.sun_path[0] = '\0';
  memcpy (sun.sun_path + 1, path, strlen (path));
  sun_len = offsetof (struct sockaddr_un, sun_path) + strlen (path) + 1;
  remove_control_socket (path);
#else
    memcpy (sun.sun_path, path, strlen (path));
    sun_len = sizeof (struct sockaddr_un);
#endif
    if (bind (fd, (const struct sockaddr *) &sun, sun_len) < 0)
      {
       perror (""bind"");
       free (path);
       close (fd);
       return -1;
     }
   if (listen (fd, 5) < 0)
     {
       perror (""listen"");
       free (path);
       close (fd);
       return -1;
     }
   fep->server = fd;
   fep->control_socket_path = path;
   return 0;
 }","[25, 26, 27, 28, 29, 30, 33]","libfep 0.0.5 before 0.1.0 does not properly use UNIX domain sockets in the abstract namespace, which allows local users to gain privileges via unspecified vectors.",libfep,CVE-2014-3980,CWE-264
4358,180193," choose_volume(struct archive_read *a, struct iso9660 *iso9660)
 {
 	struct file_info *file;
 	int64_t skipsize;
 	struct vd *vd;
 	const void *block;
 	char seenJoliet;
 	vd = &(iso9660->primary);
 	if (!iso9660->opt_support_joliet)
 		iso9660->seenJoliet = 0;
 	if (iso9660->seenJoliet &&
 		vd->location > iso9660->joliet.location)
  		vd = &(iso9660->joliet);
	skipsize = LOGICAL_BLOCK_SIZE * vd->location;
 	skipsize = LOGICAL_BLOCK_SIZE * (int64_t)vd->location;
  	skipsize = __archive_read_consume(a, skipsize);
  	if (skipsize < 0)
  		return ((int)skipsize);
 	iso9660->current_position = skipsize;
 	block = __archive_read_ahead(a, vd->size, NULL);
 	if (block == NULL) {
 		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
 		    ""Failed to read full block when scanning ""
 		    ""ISO9660 directory list"");
 		return (ARCHIVE_FATAL);
 	}
 	seenJoliet = iso9660->seenJoliet; 
 	iso9660->seenJoliet = 0;
 	file = parse_file_info(a, NULL, block);
 	if (file == NULL)
 		return (ARCHIVE_FATAL);
 	iso9660->seenJoliet = seenJoliet;
 	if (vd == &(iso9660->primary) && iso9660->seenRockridge
 	    && iso9660->seenJoliet)
 		iso9660->seenJoliet = 0;
 	if (vd == &(iso9660->primary) && !iso9660->seenRockridge
  	    && iso9660->seenJoliet) {
  		vd = &(iso9660->joliet);
		skipsize = LOGICAL_BLOCK_SIZE * vd->location;
 		skipsize = LOGICAL_BLOCK_SIZE * (int64_t)vd->location;
  		skipsize -= iso9660->current_position;
  		skipsize = __archive_read_consume(a, skipsize);
  		if (skipsize < 0)
 			return ((int)skipsize);
 		iso9660->current_position += skipsize;
 		block = __archive_read_ahead(a, vd->size, NULL);
 		if (block == NULL) {
 			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
 			    ""Failed to read full block when scanning ""
 			    ""ISO9660 directory list"");
 			return (ARCHIVE_FATAL);
 		}
 		iso9660->seenJoliet = 0;
 		file = parse_file_info(a, NULL, block);
 		if (file == NULL)
 			return (ARCHIVE_FATAL);
 		iso9660->seenJoliet = seenJoliet;
 	}
 	if (add_entry(a, iso9660, file) != ARCHIVE_OK)
 		return (ARCHIVE_FATAL);
 	if (iso9660->seenRockridge) {
 		a->archive.archive_format = ARCHIVE_FORMAT_ISO9660_ROCKRIDGE;
 		a->archive.archive_format_name =
 		    ""ISO9660 with Rockridge extensions"";
 	}
 	return (ARCHIVE_OK);
 }","[14, 15, 39, 40]",Integer overflow in the ISO parser in libarchive before 3.2.1 allows remote attackers to cause a denial of service (application crash) via a crafted ISO file.,libarchive,CVE-2016-5844,CWE-190
4368,177797," static int nfs_readlink_reply(unsigned char *pkt, unsigned len)
  {
  	uint32_t *data;
  	char *path;
	int rlen;
 	unsigned int rlen;
  	int ret;
  	ret = rpc_check_reply(pkt, 1);
 	if (ret)
 		return ret;
 	data = (uint32_t *)(pkt + sizeof(struct rpc_reply));
 	data++;
  	rlen = ntohl(net_read_uint32(data));  
 	rlen = max_t(unsigned int, rlen,
 		     len - sizeof(struct rpc_reply) - sizeof(uint32_t));
  	data++;
  	path = (char *)data;
 	} else {
 		memcpy(nfs_path, path, rlen);
 		nfs_path[rlen] = 0;
 	}","[5, 6, 14, 15]",Pengutronix barebox through 2019.08.1 has a remote buffer overflow in nfs_readlink_reply in net/nfs.c because a length field is directly used for a memcpy.,pengutronix,CVE-2019-15937,CWE-119
4370,182097," static int read_part_of_packet(AVFormatContext *s, int64_t *pts,
                                int *len, int *strid, int read_packet) {
     AVIOContext *pb = s->pb;
     PVAContext *pvactx = s->priv_data;
     int syncword, streamid, reserved, flags, length, pts_flag;
     int64_t pva_pts = AV_NOPTS_VALUE, startpos;
     int ret;
 recover:
     startpos = avio_tell(pb);
     syncword = avio_rb16(pb);
     streamid = avio_r8(pb);
     avio_r8(pb);                
     reserved = avio_r8(pb);
     flags    = avio_r8(pb);
     length   = avio_rb16(pb);
     pts_flag = flags & 0x10;
     if (syncword != PVA_MAGIC) {
         pva_log(s, AV_LOG_ERROR, ""invalid syncword\n"");
         return AVERROR(EIO);
     }
     if (streamid != PVA_VIDEO_PAYLOAD && streamid != PVA_AUDIO_PAYLOAD) {
         pva_log(s, AV_LOG_ERROR, ""invalid streamid\n"");
         return AVERROR(EIO);
     }
     if (reserved != 0x55) {
         pva_log(s, AV_LOG_WARNING, ""expected reserved byte to be 0x55\n"");
     }
     if (length > PVA_MAX_PAYLOAD_LENGTH) {
         pva_log(s, AV_LOG_ERROR, ""invalid payload length %u\n"", length);
         return AVERROR(EIO);
     }
     if (streamid == PVA_VIDEO_PAYLOAD && pts_flag) {
         pva_pts = avio_rb32(pb);
         length -= 4;
     } else if (streamid == PVA_AUDIO_PAYLOAD) {
         if (!pvactx->continue_pes) {
             int pes_signal, pes_header_data_length, pes_packet_length,
                 pes_flags;
             unsigned char pes_header_data[256];
             pes_signal             = avio_rb24(pb);
             avio_r8(pb);
             pes_packet_length      = avio_rb16(pb);
              pes_flags              = avio_rb16(pb);
              pes_header_data_length = avio_r8(pb);
             if (avio_feof(pb)) {
                 return AVERROR_EOF;
             }
              if (pes_signal != 1 || pes_header_data_length == 0) {
                  pva_log(s, AV_LOG_WARNING, ""expected non empty signaled PES packet, ""
                                            ""trying to recover\n"");
                 avio_skip(pb, length - 9);
                 if (!read_packet)
                     return AVERROR(EIO);
                 goto recover;
             }
             ret = avio_read(pb, pes_header_data, pes_header_data_length);
             if (ret != pes_header_data_length)
                 return ret < 0 ? ret : AVERROR_INVALIDDATA;
             length -= 9 + pes_header_data_length;
             pes_packet_length -= 3 + pes_header_data_length;
             pvactx->continue_pes = pes_packet_length;
             if (pes_flags & 0x80 && (pes_header_data[0] & 0xf0) == 0x20) {
                 if (pes_header_data_length < 5) {
                     pva_log(s, AV_LOG_ERROR, ""header too short\n"");
                     avio_skip(pb, length);
                     return AVERROR_INVALIDDATA;
                 }
                 pva_pts = ff_parse_pes_pts(pes_header_data);
             }
         }
         pvactx->continue_pes -= length;
         if (pvactx->continue_pes < 0) {
             pva_log(s, AV_LOG_WARNING, ""audio data corruption\n"");
             pvactx->continue_pes = 0;
         }
     }
     if (pva_pts != AV_NOPTS_VALUE)
         av_add_index_entry(s->streams[streamid-1], startpos, pva_pts, 0, 0, AVINDEX_KEYFRAME);
     *pts   = pva_pts;
     *len   = length;
     *strid = streamid;
     return 0;
 }","[45, 46, 47]",FFmpeg before commit 9807d3976be0e92e4ece3b4b1701be894cd7c2e1 contains a CWE-835: Infinite loop vulnerability in pva format demuxer that can result in a Vulnerability that allows attackers to consume excessive amount of resources like CPU and RAM. This attack appear to be exploitable via specially crafted PVA file has to be provided as input. This vulnerability appears to have been fixed in 9807d3976be0e92e4ece3b4b1701be894cd7c2e1 and later.,FFmpeg,CVE-2018-1999012,CWE-835
4378,182882," static void test_burl_normalize (void) {
     buffer *psrc = buffer_init();
     buffer *ptmp = buffer_init();
     int flags;
     flags = HTTP_PARSEOPT_URL_NORMALIZE_UNRESERVED;
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""no-slash""), CONST_STR_LEN(""no-slash""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/""), CONST_STR_LEN(""/""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/abc""), CONST_STR_LEN(""/abc""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/abc/""), CONST_STR_LEN(""/abc/""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/abc/def""), CONST_STR_LEN(""/abc/def""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/abc?""), CONST_STR_LEN(""/abc?""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/abc?d""), CONST_STR_LEN(""/abc?d""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/abc?d=""), CONST_STR_LEN(""/abc?d=""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/abc?d=e""), CONST_STR_LEN(""/abc?d=e""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/abc?d=e&""), CONST_STR_LEN(""/abc?d=e&""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/abc?d=e&f""), CONST_STR_LEN(""/abc?d=e&f""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/abc?d=e&f=g""), CONST_STR_LEN(""/abc?d=e&f=g""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/abc?d=e&f=g#""), CONST_STR_LEN(""/abc?d=e&f=g""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/abc?d=e&f=g#any""), CONST_STR_LEN(""/abc?d=e&f=g""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/%2F""), CONST_STR_LEN(""/%2F""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/%2f""), CONST_STR_LEN(""/%2F""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/%20""), CONST_STR_LEN(""/%20""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/%2b""), CONST_STR_LEN(""/%2B""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/%2B""), CONST_STR_LEN(""/%2B""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/%3a""), CONST_STR_LEN(""/%3A""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/%3A""), CONST_STR_LEN(""/%3A""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/~test%20_""), CONST_STR_LEN(""/~test%20%C3%A4_""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/\375""), """", (size_t)-2);
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/\376""), """", (size_t)-2);
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/\377""), """", (size_t)-2);
     flags = HTTP_PARSEOPT_URL_NORMALIZE_REQUIRED;
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/""), CONST_STR_LEN(""/""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/abc""), CONST_STR_LEN(""/abc""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/abc/""), CONST_STR_LEN(""/abc/""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/abc/def""), CONST_STR_LEN(""/abc/def""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/abc?""), CONST_STR_LEN(""/abc?""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/abc?d""), CONST_STR_LEN(""/abc?d""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/abc?d=""), CONST_STR_LEN(""/abc?d=""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/abc?d=e""), CONST_STR_LEN(""/abc?d=e""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/abc?d=e&""), CONST_STR_LEN(""/abc?d=e&""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/abc?d=e&f""), CONST_STR_LEN(""/abc?d=e&f""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/abc?d=e&f=g""), CONST_STR_LEN(""/abc?d=e&f=g""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/abc?d=e&f=g#""), CONST_STR_LEN(""/abc?d=e&f=g""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/abc?d=e&f=g#any""), CONST_STR_LEN(""/abc?d=e&f=g""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/%2F""), CONST_STR_LEN(""/%2F""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/%2f""), CONST_STR_LEN(""/%2F""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/%20""), CONST_STR_LEN(""/%20""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/%2b""), CONST_STR_LEN(""/+""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/%2B""), CONST_STR_LEN(""/+""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/%3a""), CONST_STR_LEN(""/:""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/%3A""), CONST_STR_LEN(""/:""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/~test%20_""), CONST_STR_LEN(""/~test%20%C3%A4_""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/\375""), """", (size_t)-2);
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/\376""), """", (size_t)-2);
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/\377""), """", (size_t)-2);
     flags |= HTTP_PARSEOPT_URL_NORMALIZE_CTRLS_REJECT;
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/\a""), """", (size_t)-2);
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/\t""), """", (size_t)-2);
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/\r""), """", (size_t)-2);
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/\177""), """", (size_t)-2);
   #if defined(__WIN32) || defined(__CYGWIN__)
     flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_BACKSLASH_TRANS;
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/a\\b""), CONST_STR_LEN(""/a/b""));
   #endif
      flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_DECODE;
      run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/a/b?c=/""), CONST_STR_LEN(""/a/b?c=/""));
      run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/a/b?c=%2f""), CONST_STR_LEN(""/a/b?c=/""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""%2f?""), CONST_STR_LEN(""/?""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/%2f?""), CONST_STR_LEN(""?""));
      run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/a%2fb""), CONST_STR_LEN(""/a/b""));
      run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/a%2Fb""), CONST_STR_LEN(""/a/b""));
      run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/a%2fb?c=/""), CONST_STR_LEN(""/a/b?c=/""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/a%2fb?c=%2f""), CONST_STR_LEN(""/a/b?c=/""));
     flags &= ~HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_DECODE;
     flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_REJECT;
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/a%2fb""), """", (size_t)-2);
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/a%2Fb""), """", (size_t)-2);
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/a/b?c=%2f""), CONST_STR_LEN(""/a/b?c=/""));
     flags &= ~HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_REJECT;
     flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REMOVE;
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""./a/b""), CONST_STR_LEN(""/a/b""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""../a/b""), CONST_STR_LEN(""/a/b""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/a/./b""), CONST_STR_LEN(""/a/b""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/a/../b""), CONST_STR_LEN(""/b""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/a/b/.""), CONST_STR_LEN(""/a/b/""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/a/b/..""), CONST_STR_LEN(""/a/""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/a/../b/..""), CONST_STR_LEN(""/""));
     flags &= ~HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REMOVE;
     flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REJECT;
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""./a/b""), """", (size_t)-2);
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""../a/b""), """", (size_t)-2);
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/a/./b""), """", (size_t)-2);
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/a/../b""), """", (size_t)-2);
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/a/b/.""), """", (size_t)-2);
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/a/b/..""), """", (size_t)-2);
     flags &= ~HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REJECT;
     flags |= HTTP_PARSEOPT_URL_NORMALIZE_QUERY_20_PLUS;
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/a/b?c=d+e""), CONST_STR_LEN(""/a/b?c=d+e""));
     run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(""/a/b?c=d%20e""), CONST_STR_LEN(""/a/b?c=d+e""));
     flags &= ~HTTP_PARSEOPT_URL_NORMALIZE_QUERY_20_PLUS;
     buffer_free(psrc);
     buffer_free(ptmp);
 }","[68, 69]","** DISPUTED ** lighttpd before 1.4.54 has a signed integer overflow, which might allow remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a malicious HTTP GET request, as demonstrated by mishandling of /%2F? in burl_normalize_2F_to_slash_fix in burl.c. NOTE: The developer states *The feature which can be abused to cause the crash is a new feature in lighttpd 1.4.50, and is not enabled by default. It must be explicitly configured in the config file (e.g. lighttpd.conf). Certain input will trigger an abort() in lighttpd when that feature is enabled. lighttpd detects the underflow or realloc() will fail (in both 32-bit and 64-bit executables), also detected in lighttpd. Either triggers an explicit abort() by lighttpd. This is not exploitable beyond triggering the explicit abort() with subsequent application exit.*",lighttpd1.4,CVE-2019-11072,CWE-190
4387,178118," static struct vrend_linked_shader_program *add_shader_program(struct vrend_context *ctx,
                                                               struct vrend_shader *vs,
                                                               struct vrend_shader *fs,
                                                               struct vrend_shader *gs)
 {
    struct vrend_linked_shader_program *sprog = CALLOC_STRUCT(vrend_linked_shader_program);
    char name[16];
    int i;
    GLuint prog_id;
    GLint lret;
    int id;
    int last_shader;
    if (!sprog)
       return NULL;
    if ((gs && gs->compiled_fs_id != fs->id) ||
        (!gs && vs->compiled_fs_id != fs->id)) {
       bool ret;
       if (gs)
          vrend_patch_vertex_shader_interpolants(gs->glsl_prog,
                                                 &gs->sel->sinfo,
                                                 &fs->sel->sinfo, true, fs->key.flatshade);
       else
          vrend_patch_vertex_shader_interpolants(vs->glsl_prog,
                                                 &vs->sel->sinfo,
                                                 &fs->sel->sinfo, false, fs->key.flatshade);
       ret = vrend_compile_shader(ctx, gs ? gs : vs);
       if (ret == false) {
          glDeleteShader(gs ? gs->id : vs->id);
          free(sprog);
          return NULL;
       }
       if (gs)
          gs->compiled_fs_id = fs->id;
       else
          vs->compiled_fs_id = fs->id;
    }
    prog_id = glCreateProgram();
    glAttachShader(prog_id, vs->id);
    if (gs) {
       if (gs->id > 0)
          glAttachShader(prog_id, gs->id);
       set_stream_out_varyings(prog_id, &gs->sel->sinfo);
    }
    else
       set_stream_out_varyings(prog_id, &vs->sel->sinfo);
    glAttachShader(prog_id, fs->id);
    if (fs->sel->sinfo.num_outputs > 1) {
       if (util_blend_state_is_dual(&ctx->sub->blend_state, 0)) {
          glBindFragDataLocationIndexed(prog_id, 0, 0, ""fsout_c0"");
          glBindFragDataLocationIndexed(prog_id, 0, 1, ""fsout_c1"");
          sprog->dual_src_linked = true;
       } else {
          glBindFragDataLocationIndexed(prog_id, 0, 0, ""fsout_c0"");
          glBindFragDataLocationIndexed(prog_id, 1, 0, ""fsout_c1"");
          sprog->dual_src_linked = false;
       }
    } else
       sprog->dual_src_linked = false;
    if (vrend_state.have_vertex_attrib_binding) {
       uint32_t mask = vs->sel->sinfo.attrib_input_mask;
       while (mask) {
          i = u_bit_scan(&mask);
          snprintf(name, 10, ""in_%d"", i);
          glBindAttribLocation(prog_id, i, name);
       }
    }
    glLinkProgram(prog_id);
    glGetProgramiv(prog_id, GL_LINK_STATUS, &lret);
    if (lret == GL_FALSE) {
       char infolog[65536];
       int len;
       glGetProgramInfoLog(prog_id, 65536, &len, infolog);
       fprintf(stderr,""got error linking\n%s\n"", infolog);
       report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_SHADER, 0);
       fprintf(stderr,""vert shader: %d GLSL\n%s\n"", vs->id, vs->glsl_prog);
       if (gs)
           fprintf(stderr,""geom shader: %d GLSL\n%s\n"", gs->id, gs->glsl_prog);
        fprintf(stderr,""frag shader: %d GLSL\n%s\n"", fs->id, fs->glsl_prog);
        glDeleteProgram(prog_id);
       free(sprog);
        return NULL;
     }
    sprog->ss[PIPE_SHADER_FRAGMENT] = fs;
    sprog->ss[PIPE_SHADER_GEOMETRY] = gs;
    list_add(&sprog->sl[PIPE_SHADER_VERTEX], &vs->programs);
    list_add(&sprog->sl[PIPE_SHADER_FRAGMENT], &fs->programs);
    if (gs)
       list_add(&sprog->sl[PIPE_SHADER_GEOMETRY], &gs->programs);
    last_shader = gs ? PIPE_SHADER_GEOMETRY : PIPE_SHADER_FRAGMENT;
    sprog->id = prog_id;
    list_addtail(&sprog->head, &ctx->sub->programs);
    if (fs->key.pstipple_tex)
       sprog->fs_stipple_loc = glGetUniformLocation(prog_id, ""pstipple_sampler"");
    else
       sprog->fs_stipple_loc = -1;
    sprog->vs_ws_adjust_loc = glGetUniformLocation(prog_id, ""winsys_adjust"");
    for (id = PIPE_SHADER_VERTEX; id <= last_shader; id++) {
       if (sprog->ss[id]->sel->sinfo.samplers_used_mask) {
          uint32_t mask = sprog->ss[id]->sel->sinfo.samplers_used_mask;
          int nsamp = util_bitcount(sprog->ss[id]->sel->sinfo.samplers_used_mask);
          int index;
          sprog->shadow_samp_mask[id] = sprog->ss[id]->sel->sinfo.shadow_samp_mask;
          if (sprog->ss[id]->sel->sinfo.shadow_samp_mask) {
             sprog->shadow_samp_mask_locs[id] = calloc(nsamp, sizeof(uint32_t));
             sprog->shadow_samp_add_locs[id] = calloc(nsamp, sizeof(uint32_t));
          } else {
             sprog->shadow_samp_mask_locs[id] = sprog->shadow_samp_add_locs[id] = NULL;
          }
          sprog->samp_locs[id] = calloc(nsamp, sizeof(uint32_t));
          if (sprog->samp_locs[id]) {
             const char *prefix = pipe_shader_to_prefix(id);
             index = 0;
             while(mask) {
                i = u_bit_scan(&mask);
                snprintf(name, 10, ""%ssamp%d"", prefix, i);
                sprog->samp_locs[id][index] = glGetUniformLocation(prog_id, name);
                if (sprog->ss[id]->sel->sinfo.shadow_samp_mask & (1 << i)) {
                   snprintf(name, 14, ""%sshadmask%d"", prefix, i);
                   sprog->shadow_samp_mask_locs[id][index] = glGetUniformLocation(prog_id, name);
                   snprintf(name, 14, ""%sshadadd%d"", prefix, i);
                   sprog->shadow_samp_add_locs[id][index] = glGetUniformLocation(prog_id, name);
                }
                index++;
             }
          }
       } else {
          sprog->samp_locs[id] = NULL;
          sprog->shadow_samp_mask_locs[id] = NULL;
          sprog->shadow_samp_add_locs[id] = NULL;
          sprog->shadow_samp_mask[id] = 0;
       }
       sprog->samplers_used_mask[id] = sprog->ss[id]->sel->sinfo.samplers_used_mask;
    }
    for (id = PIPE_SHADER_VERTEX; id <= last_shader; id++) {
       if (sprog->ss[id]->sel->sinfo.num_consts) {
          sprog->const_locs[id] = calloc(sprog->ss[id]->sel->sinfo.num_consts, sizeof(uint32_t));
          if (sprog->const_locs[id]) {
             const char *prefix = pipe_shader_to_prefix(id);
             for (i = 0; i < sprog->ss[id]->sel->sinfo.num_consts; i++) {
                snprintf(name, 16, ""%sconst0[%d]"", prefix, i);
                sprog->const_locs[id][i] = glGetUniformLocation(prog_id, name);
             }
          }
       } else
          sprog->const_locs[id] = NULL;
    }
    if (!vrend_state.have_vertex_attrib_binding) {
       if (vs->sel->sinfo.num_inputs) {
          sprog->attrib_locs = calloc(vs->sel->sinfo.num_inputs, sizeof(uint32_t));
          if (sprog->attrib_locs) {
             for (i = 0; i < vs->sel->sinfo.num_inputs; i++) {
                snprintf(name, 10, ""in_%d"", i);
                sprog->attrib_locs[i] = glGetAttribLocation(prog_id, name);
             }
          }
       } else
          sprog->attrib_locs = NULL;
    }
    for (id = PIPE_SHADER_VERTEX; id <= last_shader; id++) {
       if (sprog->ss[id]->sel->sinfo.num_ubos) {
          const char *prefix = pipe_shader_to_prefix(id);
          sprog->ubo_locs[id] = calloc(sprog->ss[id]->sel->sinfo.num_ubos, sizeof(uint32_t));
          for (i = 0; i < sprog->ss[id]->sel->sinfo.num_ubos; i++) {
             snprintf(name, 16, ""%subo%d"", prefix, i + 1);
             sprog->ubo_locs[id][i] = glGetUniformBlockIndex(prog_id, name);
          }
       } else
          sprog->ubo_locs[id] = NULL;
    }
    if (vs->sel->sinfo.num_ucp) {
       for (i = 0; i < vs->sel->sinfo.num_ucp; i++) {
          snprintf(name, 10, ""clipp[%d]"", i);
          sprog->clip_locs[i] = glGetUniformLocation(prog_id, name);
       }
    }
    return sprog;
 }",[80],Memory leak in the add_shader_program function in vrend_renderer.c in virglrenderer before 0.6.0 allows local guest OS users to cause a denial of service (host memory consumption) via vectors involving the sprog variable.,virglrenderer,CVE-2017-6317,CWE-772
4402,181249," static av_cold int xpm_decode_close(AVCodecContext *avctx)
 {
      XPMDecContext *x = avctx->priv_data;
      av_freep(&x->pixels);
     av_freep(&x->buf);
     x->buf_size = 0;
      return 0;
  }","[5, 6]",Stack-based buffer overflow in the color_string_to_rgba function in libavcodec/xpmdec.c in FFmpeg 3.3 before 3.3.1 allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted file.,FFmpeg,CVE-2017-9990,CWE-119
4429,182979," rdpsnddbg_process(STREAM s)
 {
 	unsigned int pkglen;
  	static char *rest = NULL;
  	char *buf;
 	if (!s_check(s))
 	{
 		rdp_protocol_error(""rdpsnddbg_process(), stream is in unstable state"", s);
 	}
  	pkglen = s->end - s->p;
  	buf = (char *) xmalloc(pkglen + 1);
 	STRNCPY(buf, (char *) s->p, pkglen + 1);
 	str_handle_lines(buf, &rest, rdpsnddbg_line_handler, NULL);
 	xfree(buf);
 }","[6, 7, 8, 9]",rdesktop versions up to and including v1.8.3 contain a Buffer Overflow over the global variables in the function seamless_process_line() that results in memory corruption and probably even a remote code execution.,rdesktop,CVE-2018-20182,CWE-119
4448,182384," void jslTokenAsString(int token, char *str, size_t len) {
   if (token>32 && token<128) {
     assert(len>=4);
     str[0] = '\'';
     str[1] = (char)token;
     str[2] = '\'';
     str[3] = 0;
     return;
   }
   switch (token) {
   case LEX_EOF : strncpy(str, ""EOF"", len); return;
   case LEX_ID : strncpy(str, ""ID"", len); return;
   case LEX_INT : strncpy(str, ""INT"", len); return;
   case LEX_FLOAT : strncpy(str, ""FLOAT"", len); return;
   case LEX_STR : strncpy(str, ""STRING"", len); return;
   case LEX_UNFINISHED_STR : strncpy(str, ""UNFINISHED STRING"", len); return;
   case LEX_TEMPLATE_LITERAL : strncpy(str, ""TEMPLATE LITERAL"", len); return;
   case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy(str, ""UNFINISHED TEMPLATE LITERAL"", len); return;
   case LEX_REGEX : strncpy(str, ""REGEX"", len); return;
   case LEX_UNFINISHED_REGEX : strncpy(str, ""UNFINISHED REGEX"", len); return;
   case LEX_UNFINISHED_COMMENT : strncpy(str, ""UNFINISHED COMMENT"", len); return;
   }
   if (token>=_LEX_OPERATOR_START && token<_LEX_R_LIST_END) {
     const char tokenNames[] =
           ""==\0""
           ""===\0""
           ""!=\0""
           ""!==\0""
           ""<=\0""
           ""<<\0""
           ""<<=\0""
           "">=\0""
           "">>\0""
           "">>>\0""
           "">>=\0""
           "">>>=\0""
           ""+=\0""
           ""-=\0""
           ""++\0""
           ""--\0""
           ""*=\0""
           ""/=\0""
           ""%=\0""
           ""&=\0""
           ""&&\0""
           ""|=\0""
           ""||\0""
           ""^=\0""
           ""=>\0""
           ""if\0""
           ""else\0""
           ""do\0""
           ""while\0""
           ""for\0""
           ""return\0""
           ""continue\0""
           ""function\0""
           ""return\0""
           ""var\0""
           ""let\0""
           ""const\0""
           ""this\0""
           ""throw\0""
           ""try\0""
           ""catch\0""
           ""finally\0""
           ""true\0""
           ""false\0""
           ""null\0""
           ""undefined\0""
           ""new\0""
           ""in\0""
           ""instanceof\0""
           ""switch\0""
           ""case\0""
           ""default\0""
           ""delete\0""
           ""typeof\0""
           ""void\0""
           ""debugger\0""
           ""class\0""
           ""extends\0""
             ""super\0""
           ""static\0""
         ;
     unsigned int p = 0;
     int n = token-_LEX_OPERATOR_START;
     while (n>0 && p<sizeof(tokenNames)) {
       while (tokenNames[p] && p<sizeof(tokenNames)) p++;
       p++;  
       n--;  
     }
     assert(n==0);
     strncpy(str, &tokenNames[p], len);
     return;
    }
    assert(len>=10);
  strncpy(str, ""?["",len);
  itostr(token, &str[2], 10);
  strncat(str, ""]"",len);
   espruino_snprintf(str, len, ""?[%d]"", token);
  }","[98, 99, 100, 101]","Espruino before 1.99 allows attackers to cause a denial of service (application crash) and a potential Escalation of Privileges with a user crafted input file via a Buffer Overflow during syntax parsing, because strncat is misused.",Espruino,CVE-2018-11595,CWE-119
4457,181875," jas_matrix_t *jas_matrix_create(int numrows, int numcols)
 jas_matrix_t *jas_matrix_create(jas_matind_t numrows, jas_matind_t numcols)
  {
  	jas_matrix_t *matrix;
	int i;
 	jas_matind_t i;
  	size_t size;
  	matrix = 0;
 	if (numrows < 0 || numcols < 0) {
 		goto error;
 	}
 	if (!(matrix = jas_malloc(sizeof(jas_matrix_t)))) {
 		goto error;
 	}
 	matrix->flags_ = 0;
 	matrix->numrows_ = numrows;
 	matrix->numcols_ = numcols;
 	matrix->rows_ = 0;
 	matrix->maxrows_ = numrows;
 	matrix->data_ = 0;
 	matrix->datasize_ = 0;
 	if (!jas_safe_size_mul(numrows, numcols, &size)) {
 		goto error;
 	}
 	matrix->datasize_ = size;
 	if (matrix->maxrows_ > 0) {
 		if (!(matrix->rows_ = jas_alloc2(matrix->maxrows_,
 		  sizeof(jas_seqent_t *)))) {
 			goto error;
 		}
 	}
 	if (matrix->datasize_ > 0) {
 		if (!(matrix->data_ = jas_alloc2(matrix->datasize_,
 		  sizeof(jas_seqent_t)))) {
 			goto error;
 		}
 	}
 	for (i = 0; i < numrows; ++i) {
 		matrix->rows_[i] = &matrix->data_[i * matrix->numcols_];
 	}
 	for (i = 0; i < matrix->datasize_; ++i) {
 		matrix->data_[i] = 0;
 	}
 	matrix->xstart_ = 0;
 	matrix->ystart_ = 0;
 	matrix->xend_ = matrix->numcols_;
 	matrix->yend_ = matrix->numrows_;
 	return matrix;
 error:
 	if (matrix) {
 		jas_matrix_destroy(matrix);
 	}
 	return 0;
 }","[2, 5, 6]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
4509,179852," main(int argc, char *argv[])
 {
 	static char buff[16384];
 	struct cpio _cpio;  
 	struct cpio *cpio;
 	const char *errmsg;
 	int uid, gid;
 	int opt;
 	cpio = &_cpio;
 	memset(cpio, 0, sizeof(*cpio));
 	cpio->buff = buff;
 	cpio->buff_size = sizeof(buff);
 #if defined(HAVE_SIGACTION) && defined(SIGPIPE)
 	{  
 		struct sigaction sa;
 		sigemptyset(&sa.sa_mask);
 		sa.sa_flags = 0;
 		sa.sa_handler = SIG_IGN;
 		sigaction(SIGPIPE, &sa, NULL);
 	}
 #endif
 	lafe_setprogname(*argv, ""bsdcpio"");
 #if HAVE_SETLOCALE
 	if (setlocale(LC_ALL, """") == NULL)
 		lafe_warnc(0, ""Failed to set default locale"");
 #endif
 	cpio->uid_override = -1;
 	cpio->gid_override = -1;
 	cpio->argv = argv;
 	cpio->argc = argc;
 	cpio->mode = '\0';
 	cpio->verbose = 0;
 	cpio->compress = '\0';
 	cpio->extract_flags = ARCHIVE_EXTRACT_NO_AUTODIR;
  	cpio->extract_flags |= ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER;
  	cpio->extract_flags |= ARCHIVE_EXTRACT_SECURE_SYMLINKS;
  	cpio->extract_flags |= ARCHIVE_EXTRACT_SECURE_NODOTDOT;
 	cpio->extract_flags |= ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS;
  	cpio->extract_flags |= ARCHIVE_EXTRACT_PERM;
  	cpio->extract_flags |= ARCHIVE_EXTRACT_FFLAGS;
  	cpio->extract_flags |= ARCHIVE_EXTRACT_ACL;
 #if !defined(_WIN32) && !defined(__CYGWIN__)
 	if (geteuid() == 0)
 		cpio->extract_flags |= ARCHIVE_EXTRACT_OWNER;
 #endif
 	cpio->bytes_per_block = 512;
 	cpio->filename = NULL;
 	cpio->matching = archive_match_new();
 	if (cpio->matching == NULL)
 		lafe_errc(1, 0, ""Out of memory"");
 	while ((opt = cpio_getopt(cpio)) != -1) {
 		switch (opt) {
 		case '0':  
 			cpio->option_null = 1;
 			break;
 		case 'A':  
 			cpio->option_append = 1;
 			break;
 		case 'a':  
 			cpio->option_atime_restore = 1;
 			break;
 		case 'B':  
 			cpio->bytes_per_block = 5120;
 			break;
 		case OPTION_B64ENCODE:
 			cpio->add_filter = opt;
 			break;
 		case 'C':  
 			cpio->bytes_per_block = atoi(cpio->argument);
 			if (cpio->bytes_per_block <= 0)
 				lafe_errc(1, 0, ""Invalid blocksize %s"", cpio->argument);
 			break;
 		case 'c':  
 			cpio->format = ""odc"";
 			break;
 		case 'd':  
 			cpio->extract_flags &= ~ARCHIVE_EXTRACT_NO_AUTODIR;
 			break;
 		case 'E':  
 			if (archive_match_include_pattern_from_file(
 			    cpio->matching, cpio->argument,
 			    cpio->option_null) != ARCHIVE_OK)
 				lafe_errc(1, 0, ""Error : %s"",
 				    archive_error_string(cpio->matching));
 			break;
 		case 'F':  
 			cpio->filename = cpio->argument;
 			break;
 		case 'f':  
 			if (archive_match_exclude_pattern(cpio->matching,
 			    cpio->argument) != ARCHIVE_OK)
 				lafe_errc(1, 0, ""Error : %s"",
 				    archive_error_string(cpio->matching));
 			break;
 		case OPTION_GRZIP:
 			cpio->compress = opt;
 			break;
 		case 'H':  
 			cpio->format = cpio->argument;
 			break;
 		case 'h':
 			long_help();
 			break;
 		case 'I':  
 			cpio->filename = cpio->argument;
 			break;
 		case 'i':  
 			if (cpio->mode != '\0')
 				lafe_errc(1, 0,
 				    ""Cannot use both -i and -%c"", cpio->mode);
 			cpio->mode = opt;
 			break;
 		case 'J':  
 			cpio->compress = opt;
 			break;
 		case 'j':  
 			cpio->compress = opt;
 			break;
  		case OPTION_INSECURE:
  			cpio->extract_flags &= ~ARCHIVE_EXTRACT_SECURE_SYMLINKS;
  			cpio->extract_flags &= ~ARCHIVE_EXTRACT_SECURE_NODOTDOT;
 			cpio->extract_flags &= ~ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS;
  			break;
  		case 'L':  
  			cpio->option_follow_links = 1;
 			break;
 		case 'l':  
 			cpio->option_link = 1;
 			break;
 		case OPTION_LRZIP:
 		case OPTION_LZ4:
 		case OPTION_LZMA:  
 		case OPTION_LZOP:  
 			cpio->compress = opt;
 			break;
 		case 'm':  
 			cpio->extract_flags |= ARCHIVE_EXTRACT_TIME;
 			break;
 		case 'n':  
 			cpio->option_numeric_uid_gid = 1;
 			break;
 		case OPTION_NO_PRESERVE_OWNER:  
 			cpio->extract_flags &= ~ARCHIVE_EXTRACT_OWNER;
 			break;
 		case 'O':  
 			cpio->filename = cpio->argument;
 			break;
 		case 'o':  
 			if (cpio->mode != '\0')
 				lafe_errc(1, 0,
 				    ""Cannot use both -o and -%c"", cpio->mode);
 			cpio->mode = opt;
 			break;
 		case 'p':  
 			if (cpio->mode != '\0')
 				lafe_errc(1, 0,
 				    ""Cannot use both -p and -%c"", cpio->mode);
 			cpio->mode = opt;
 			cpio->extract_flags &= ~ARCHIVE_EXTRACT_SECURE_NODOTDOT;
 			break;
 		case OPTION_PASSPHRASE:
 			cpio->passphrase = cpio->argument;
 			break;
 		case OPTION_PRESERVE_OWNER:
 			cpio->extract_flags |= ARCHIVE_EXTRACT_OWNER;
 			break;
 		case OPTION_QUIET:  
 			cpio->quiet = 1;
 			break;
 		case 'R':  
 			errmsg = owner_parse(cpio->argument, &uid, &gid);
 			if (errmsg) {
 				lafe_warnc(-1, ""%s"", errmsg);
 				usage();
 			}
 			if (uid != -1) {
 				cpio->uid_override = uid;
 				cpio->uname_override = NULL;
 			}
 			if (gid != -1) {
 				cpio->gid_override = gid;
 				cpio->gname_override = NULL;
 			}
 			break;
 		case 'r':  
 			cpio->option_rename = 1;
 			break;
 		case 't':  
 			cpio->option_list = 1;
 			break;
 		case 'u':  
 			cpio->extract_flags
 			    &= ~ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER;
 			break;
 		case OPTION_UUENCODE:
 			cpio->add_filter = opt;
 			break;
 		case 'v':  
 			cpio->verbose++;
 			break;
 		case 'V':  
 			cpio->dot++;
 			break;
 		case OPTION_VERSION:  
 			version();
 			break;
 #if 0
 		case 'W':  
 			break;
 #endif
 		case 'y':  
 			cpio->compress = opt;
 			break;
 		case 'Z':  
 			cpio->compress = opt;
 			break;
 		case 'z':  
 			cpio->compress = opt;
 			break;
 		default:
 			usage();
 		}
 	}
 	if (cpio->option_list && cpio->mode == '\0')
 		cpio->mode = 'i';
 	if (cpio->option_list && cpio->mode != 'i')
 		lafe_errc(1, 0, ""Option -t requires -i"");
 	if (cpio->option_numeric_uid_gid && !cpio->option_list)
 		lafe_errc(1, 0, ""Option -n requires -it"");
 	if (cpio->format != NULL && cpio->mode != 'o')
 		lafe_errc(1, 0, ""Option --format requires -o"");
 	if (cpio->option_link && cpio->mode != 'p')
 		lafe_errc(1, 0, ""Option -l requires -p"");
 	if (cpio->dot && cpio->verbose)
 		cpio->dot = 0;
 	switch (cpio->mode) {
 	case 'o':
 		if (cpio->format == NULL)
 			cpio->format = ""odc"";  
 		mode_out(cpio);
 		break;
 	case 'i':
 		while (*cpio->argv != NULL) {
 			if (archive_match_include_pattern(cpio->matching,
 			    *cpio->argv) != ARCHIVE_OK)
 				lafe_errc(1, 0, ""Error : %s"",
 				    archive_error_string(cpio->matching));
 			--cpio->argc;
 			++cpio->argv;
 		}
 		if (cpio->option_list)
 			mode_list(cpio);
 		else
 			mode_in(cpio);
 		break;
 	case 'p':
 		if (*cpio->argv == NULL || **cpio->argv == '\0')
 			lafe_errc(1, 0,
 			    ""-p mode requires a target directory"");
 		mode_pass(cpio, *cpio->argv);
 		break;
 	default:
 		lafe_errc(1, 0,
 		    ""Must specify at least one of -i, -o, or -p"");
 	}
 	archive_match_free(cpio->matching);
 	free_cache(cpio->gname_cache);
 	free_cache(cpio->uname_cache);
 	free(cpio->destdir);
 	passphrase_free(cpio->ppbuff);
 	return (cpio->return_value);
 }","[38, 122]",Absolute path traversal vulnerability in bsdcpio in libarchive 3.1.2 and earlier allows remote attackers to write to arbitrary files via a full pathname in an archive.,libarchive,CVE-2015-2304,CWE-22
4510,178609," ProcPseudoramiXGetScreenSize(ClientPtr client)
 {
     REQUEST(xPanoramiXGetScreenSizeReq);
     WindowPtr pWin;
     xPanoramiXGetScreenSizeReply rep;
     register int rc;
      TRACE;
     REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);
      if (stuff->screen >= pseudoramiXNumScreens)
        return BadMatch;
    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);
      rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
      if (rc != Success)
          return rc;
     rep.type = X_Reply;
     rep.length = 0;
     rep.sequenceNumber = client->sequence;
     rep.width = pseudoramiXScreens[stuff->screen].w;
     rep.height = pseudoramiXScreens[stuff->screen].h;
     rep.window = stuff->window;
     rep.screen = stuff->screen;
     if (client->swapped) {
         swaps(&rep.sequenceNumber);
         swapl(&rep.length);
         swapl(&rep.width);
         swapl(&rep.height);
         swapl(&rep.window);
         swapl(&rep.screen);
     }
     WriteToClient(client, sizeof(xPanoramiXGetScreenSizeReply),&rep);
     return Success;
 }","[8, 11]",xorg-x11-server before 1.19.5 was missing length validation in RENDER extension allowing malicious X client to cause X server to crash or possibly execute arbitrary code.,xserver,CVE-2017-12187,CWE-20
4519,183143," static bool ndp_msg_check_valid(struct ndp_msg *msg)
 {
 	size_t len = ndp_msg_payload_len(msg);
 	enum ndp_msg_type msg_type = ndp_msg_type(msg);
  	if (len < ndp_msg_type_info(msg_type)->raw_struct_size)
  		return false;
	return true;
 	if (ndp_msg_type_info(msg_type)->addrto_validate)
 		return ndp_msg_type_info(msg_type)->addrto_validate(&msg->addrto);
 	else
 		return true;
  }","[7, 8, 9, 10, 11]","libndp before 1.6, as used in NetworkManager, does not properly validate the origin of Neighbor Discovery Protocol (NDP) messages, which allows remote attackers to conduct man-in-the-middle attacks or cause a denial of service (network connectivity disruption) by advertising a node as a router from a non-local network.",libndp,CVE-2016-3698,CWE-284
4529,181374,"  int yr_re_exec(
      uint8_t* re_code,
      uint8_t* input_data,
    size_t input_size,
     size_t input_forwards_size,
     size_t input_backwards_size,
      int flags,
      RE_MATCH_CALLBACK_FUNC callback,
      void* callback_args)
 {
   uint8_t* ip;
   uint8_t* input;
   uint8_t mask;
   uint8_t value;
   RE_FIBER_LIST fibers;
   RE_THREAD_STORAGE* storage;
   RE_FIBER* fiber;
   RE_FIBER* next_fiber;
   int error;
   int bytes_matched;
   int max_bytes_matched;
   int match;
   int character_size;
   int input_incr;
   int kill;
   int action;
   int result = -1;
   #define ACTION_NONE       0
   #define ACTION_CONTINUE   1
    #define ACTION_KILL       2
    #define ACTION_KILL_TAIL  3
  #define prolog if (bytes_matched >= max_bytes_matched) \
   #define prolog { \
       if ((bytes_matched >= max_bytes_matched) || \
           (character_size == 2 && *(input + 1) != 0)) \
        { \
          action = ACTION_KILL; \
          break; \
      }
       } \
     }
  #define fail_if_error(e) switch (e) { \
   #define fail_if_error(e) { \
       switch (e) { \
          case ERROR_INSUFFICIENT_MEMORY: \
            return -2; \
          case ERROR_TOO_MANY_RE_FIBERS: \
            return -4; \
      }
       } \
     }
    if (_yr_re_alloc_storage(&storage) != ERROR_SUCCESS)
      return -2;
   if (flags & RE_FLAGS_WIDE)
     character_size = 2;
   else
     character_size = 1;
   input = input_data;
   input_incr = character_size;
    if (flags & RE_FLAGS_BACKWARDS)
    {
     max_bytes_matched = (int) yr_min(input_backwards_size, RE_SCAN_LIMIT);
      input -= character_size;
      input_incr = -input_incr;
    }
  max_bytes_matched = (int) yr_min(input_size, RE_SCAN_LIMIT);
   else
   {
     max_bytes_matched = (int) yr_min(input_forwards_size, RE_SCAN_LIMIT);
   }
    max_bytes_matched = max_bytes_matched - max_bytes_matched % character_size;
   bytes_matched = 0;
   error = _yr_re_fiber_create(&storage->fiber_pool, &fiber);
   fail_if_error(error);
   fiber->ip = re_code;
   fibers.head = fiber;
   fibers.tail = fiber;
   error = _yr_re_fiber_sync(&fibers, &storage->fiber_pool, fiber);
   fail_if_error(error);
   while (fibers.head != NULL)
   {
     fiber = fibers.head;
     while(fiber != NULL)
     {
       ip = fiber->ip;
       action = ACTION_NONE;
       switch(*ip)
       {
         case RE_OPCODE_ANY:
           prolog;
           match = (flags & RE_FLAGS_DOT_ALL) || (*input != 0x0A);
           action = match ? ACTION_NONE : ACTION_KILL;
           fiber->ip += 1;
           break;
         case RE_OPCODE_REPEAT_ANY_GREEDY:
         case RE_OPCODE_REPEAT_ANY_UNGREEDY:
           prolog;
           match = (flags & RE_FLAGS_DOT_ALL) || (*input != 0x0A);
           action = match ? ACTION_NONE : ACTION_KILL;
           break;
         case RE_OPCODE_LITERAL:
           prolog;
           if (flags & RE_FLAGS_NO_CASE)
             match = yr_lowercase[*input] == yr_lowercase[*(ip + 1)];
           else
             match = (*input == *(ip + 1));
           action = match ? ACTION_NONE : ACTION_KILL;
           fiber->ip += 2;
           break;
         case RE_OPCODE_MASKED_LITERAL:
           prolog;
           value = *(int16_t*)(ip + 1) & 0xFF;
           mask = *(int16_t*)(ip + 1) >> 8;
           match = ((*input & mask) == value);
           action = match ? ACTION_NONE : ACTION_KILL;
           fiber->ip += 3;
           break;
         case RE_OPCODE_CLASS:
           prolog;
           match = CHAR_IN_CLASS(*input, ip + 1);
           if (!match && (flags & RE_FLAGS_NO_CASE))
             match = CHAR_IN_CLASS(yr_altercase[*input], ip + 1);
           action = match ? ACTION_NONE : ACTION_KILL;
           fiber->ip += 33;
           break;
          case RE_OPCODE_WORD_CHAR:
            prolog;
          match = IS_WORD_CHAR(*input);
           match = _yr_re_is_word_char(input, character_size);
            action = match ? ACTION_NONE : ACTION_KILL;
            fiber->ip += 1;
            break;
          case RE_OPCODE_NON_WORD_CHAR:
            prolog;
          match = !IS_WORD_CHAR(*input);
           match = !_yr_re_is_word_char(input, character_size);
            action = match ? ACTION_NONE : ACTION_KILL;
            fiber->ip += 1;
            break;
         case RE_OPCODE_SPACE:
         case RE_OPCODE_NON_SPACE:
           prolog;
           switch(*input)
           {
             case ' ':
             case '\t':
             case '\r':
             case '\n':
             case '\v':
             case '\f':
               match = TRUE;
               break;
             default:
               match = FALSE;
           }
           if (*ip == RE_OPCODE_NON_SPACE)
             match = !match;
           action = match ? ACTION_NONE : ACTION_KILL;
           fiber->ip += 1;
           break;
         case RE_OPCODE_DIGIT:
           prolog;
           match = isdigit(*input);
           action = match ? ACTION_NONE : ACTION_KILL;
           fiber->ip += 1;
           break;
         case RE_OPCODE_NON_DIGIT:
           prolog;
           match = !isdigit(*input);
           action = match ? ACTION_NONE : ACTION_KILL;
           fiber->ip += 1;
           break;
          case RE_OPCODE_WORD_BOUNDARY:
          case RE_OPCODE_NON_WORD_BOUNDARY:
          if (bytes_matched == 0 &&
              !(flags & RE_FLAGS_NOT_AT_START) &&
              !(flags & RE_FLAGS_BACKWARDS))
           if (bytes_matched == 0 && input_backwards_size < character_size)
           {
              match = TRUE;
           }
            else if (bytes_matched >= max_bytes_matched)
           {
              match = TRUE;
          else if (IS_WORD_CHAR(*(input - input_incr)) != IS_WORD_CHAR(*input))
            match = TRUE;
           }
            else
            match = FALSE;
           {
             assert(input <  input_data + input_forwards_size);
             assert(input >= input_data - input_backwards_size);
             assert(input - input_incr <  input_data + input_forwards_size);
             assert(input - input_incr >= input_data - input_backwards_size);
             match = _yr_re_is_word_char(input, character_size) != \
                     _yr_re_is_word_char(input - input_incr, character_size);
           }
            if (*ip == RE_OPCODE_NON_WORD_BOUNDARY)
              match = !match;
           action = match ? ACTION_CONTINUE : ACTION_KILL;
           fiber->ip += 1;
           break;
          case RE_OPCODE_MATCH_AT_START:
            if (flags & RE_FLAGS_BACKWARDS)
            kill = input_size > (size_t) bytes_matched;
             kill = input_backwards_size > (size_t) bytes_matched;
            else
            kill = (flags & RE_FLAGS_NOT_AT_START) || (bytes_matched != 0);
             kill = input_backwards_size > 0 || (bytes_matched != 0);
            action = kill ? ACTION_KILL : ACTION_CONTINUE;
            fiber->ip += 1;
            break;
          case RE_OPCODE_MATCH_AT_END:
            kill = flags & RE_FLAGS_BACKWARDS ||
                 input_size > (size_t) bytes_matched;
                  input_forwards_size > (size_t) bytes_matched;
            action = kill ? ACTION_KILL : ACTION_CONTINUE;
            fiber->ip += 1;
            break;
         case RE_OPCODE_MATCH:
           result = bytes_matched;
           if (flags & RE_FLAGS_EXHAUSTIVE)
           {
             if (callback != NULL)
             {
               int cb_result;
               if (flags & RE_FLAGS_BACKWARDS)
                 cb_result = callback(
                     input + character_size,
                     bytes_matched,
                     flags,
                     callback_args);
               else
                 cb_result = callback(
                     input_data,
                     bytes_matched,
                     flags,
                     callback_args);
               switch(cb_result)
               {
                 case ERROR_INSUFFICIENT_MEMORY:
                   return -2;
                 case ERROR_TOO_MANY_MATCHES:
                   return -3;
                 default:
                   if (cb_result != ERROR_SUCCESS)
                     return -4;
               }
             }
             action = ACTION_KILL;
           }
           else
           {
             action = ACTION_KILL_TAIL;
           }
           break;
         default:
           assert(FALSE);
       }
       switch(action)
       {
         case ACTION_KILL:
           fiber = _yr_re_fiber_kill(&fibers, &storage->fiber_pool, fiber);
           break;
         case ACTION_KILL_TAIL:
           _yr_re_fiber_kill_tail(&fibers, &storage->fiber_pool, fiber);
           fiber = NULL;
           break;
         case ACTION_CONTINUE:
           error = _yr_re_fiber_sync(&fibers, &storage->fiber_pool, fiber);
           fail_if_error(error);
           break;
         default:
           next_fiber = fiber->next;
           error = _yr_re_fiber_sync(&fibers, &storage->fiber_pool, fiber);
           fail_if_error(error);
           fiber = next_fiber;
        }
      }
    if (flags & RE_FLAGS_WIDE &&
        bytes_matched < max_bytes_matched &&
        *(input + 1) != 0)
    {
      _yr_re_fiber_kill_all(&fibers, &storage->fiber_pool);
    }
      input += input_incr;
      bytes_matched += character_size;
     if (flags & RE_FLAGS_SCAN && bytes_matched < max_bytes_matched)
     {
       error = _yr_re_fiber_create(&storage->fiber_pool, &fiber);
       fail_if_error(error);
       fiber->ip = re_code;
       _yr_re_fiber_append(&fibers, fiber);
       error = _yr_re_fiber_sync(&fibers, &storage->fiber_pool, fiber);
       fail_if_error(error);
     }
   }
   return result;
 }","[4, 5, 6, 32, 33, 34, 35, 39, 40, 41, 42, 43, 44, 49, 50, 51, 62, 66, 67, 68, 69, 70, 128, 129, 135, 136, 175, 176, 177, 178, 179, 181, 183, 185, 186, 187, 189, 190, 191, 192, 193, 194, 195, 196, 197, 205, 206, 208, 209, 215, 216, 280, 281, 282, 283, 284, 285]",libyara/re.c in the regex component in YARA 3.5.0 allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted rule that is mishandled in the yr_re_exec function.,yara,CVE-2017-8294,CWE-125
4533,179577," ltree_in(PG_FUNCTION_ARGS)
 {
 	char	   *buf = (char *) PG_GETARG_POINTER(0);
 	char	   *ptr;
 	nodeitem   *list,
 			   *lptr;
 	int			num = 0,
 				totallen = 0;
 	int			state = LTPRS_WAITNAME;
 	ltree	   *result;
 	ltree_level *curlevel;
 	int			charlen;
 	int			pos = 0;
 	ptr = buf;
 	while (*ptr)
 	{
 		charlen = pg_mblen(ptr);
 		if (charlen == 1 && t_iseq(ptr, '.'))
 			num++;
  		ptr += charlen;
  	}
 	if (num + 1 > MaxAllocSize / sizeof(nodeitem))
 		ereport(ERROR,
 				(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),
 			 errmsg(""number of levels (%d) exceeds the maximum allowed (%d)"",
 					num + 1, (int) (MaxAllocSize / sizeof(nodeitem)))));
  	list = lptr = (nodeitem *) palloc(sizeof(nodeitem) * (num + 1));
  	ptr = buf;
  	while (*ptr)
 	{
 		charlen = pg_mblen(ptr);
 		if (state == LTPRS_WAITNAME)
 		{
 			if (ISALNUM(ptr))
 			{
 				lptr->start = ptr;
 				lptr->wlen = 0;
 				state = LTPRS_WAITDELIM;
 			}
 			else
 				UNCHAR;
 		}
 		else if (state == LTPRS_WAITDELIM)
 		{
 			if (charlen == 1 && t_iseq(ptr, '.'))
 			{
 				lptr->len = ptr - lptr->start;
 				if (lptr->wlen > 255)
 					ereport(ERROR,
 							(errcode(ERRCODE_NAME_TOO_LONG),
 							 errmsg(""name of level is too long""),
 							 errdetail(""Name length is %d, must ""
 									   ""be < 256, in position %d."",
 									   lptr->wlen, pos)));
 				totallen += MAXALIGN(lptr->len + LEVEL_HDRSIZE);
 				lptr++;
 				state = LTPRS_WAITNAME;
 			}
 			else if (!ISALNUM(ptr))
 				UNCHAR;
 		}
 		else
 			elog(ERROR, ""internal error in parser"");
 		ptr += charlen;
 		lptr->wlen++;
 		pos++;
 	}
 	if (state == LTPRS_WAITDELIM)
 	{
 		lptr->len = ptr - lptr->start;
 		if (lptr->wlen > 255)
 			ereport(ERROR,
 					(errcode(ERRCODE_NAME_TOO_LONG),
 					 errmsg(""name of level is too long""),
 					 errdetail(""Name length is %d, must ""
 							   ""be < 256, in position %d."",
 							   lptr->wlen, pos)));
 		totallen += MAXALIGN(lptr->len + LEVEL_HDRSIZE);
 		lptr++;
 	}
 	else if (!(state == LTPRS_WAITNAME && lptr == list))
 		ereport(ERROR,
 				(errcode(ERRCODE_SYNTAX_ERROR),
 				 errmsg(""syntax error""),
 				 errdetail(""Unexpected end of line."")));
 	result = (ltree *) palloc0(LTREE_HDRSIZE + totallen);
 	SET_VARSIZE(result, LTREE_HDRSIZE + totallen);
 	result->numlevel = lptr - list;
 	curlevel = LTREE_FIRST(result);
 	lptr = list;
 	while (lptr - list < result->numlevel)
 	{
 		curlevel->len = (uint16) lptr->len;
 		memcpy(curlevel->name, lptr->start, lptr->len);
 		curlevel = LEVEL_NEXT(curlevel);
 		lptr++;
 	}
 	pfree(list);
 	PG_RETURN_POINTER(result);
 }","[22, 23, 24, 25, 26]","Multiple integer overflows in contrib/hstore/hstore_io.c in PostgreSQL 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact via vectors related to the (1) hstore_recv, (2) hstore_from_arrays, and (3) hstore_from_array functions in contrib/hstore/hstore_io.c; and the (4) hstoreArrayToPairs function in contrib/hstore/hstore_op.c, which triggers a buffer overflow.  NOTE: this issue was SPLIT from CVE-2014-0064 because it has a different set of affected versions.",postgres,CVE-2014-2669,CWE-189
4546,181913," static int ras_putdatastd(jas_stream_t *out, ras_hdr_t *hdr, jas_image_t *image,  int numcmpts, int *cmpts)
 {
 	int rowsize;
 	int pad;
 	unsigned int z;
 	int nz;
 	int c;
 	int x;
 	int y;
 	int v;
  	jas_matrix_t *data[3];
  	int i;
 	assert(numcmpts <= 3);
 	for (i = 0; i < 3; ++i) {
 		data[i] = 0;
 	}
  	for (i = 0; i < numcmpts; ++i) {
		data[i] = jas_matrix_create(jas_image_height(image), jas_image_width(image));
		assert(data[i]);
 		if (!(data[i] = jas_matrix_create(jas_image_height(image),
 		  jas_image_width(image)))) {
 			goto error;
 		}
  	}
  	rowsize = RAS_ROWSIZE(hdr);
 	pad = rowsize - (hdr->width * hdr->depth + 7) / 8;
 	hdr->length = hdr->height * rowsize;
 	for (y = 0; y < hdr->height; y++) {
  		for (i = 0; i < numcmpts; ++i) {
  			if (jas_image_readcmpt(image, cmpts[i], 0, y,
  					jas_image_width(image), 1, data[i])) {
				return -1;
 				goto error;
  			}
  		}
  		z = 0;
 		nz = 0;
 		for (x = 0; x < hdr->width; x++) {
 			z <<= hdr->depth;
 			if (RAS_ISRGB(hdr)) {
 				v = RAS_RED((jas_matrix_getv(data[0], x))) |
 				  RAS_GREEN((jas_matrix_getv(data[1], x))) |
 				  RAS_BLUE((jas_matrix_getv(data[2], x)));
 			} else {
 				v = (jas_matrix_getv(data[0], x));
 			}
 			z |= v & RAS_ONES(hdr->depth);
 			nz += hdr->depth;
  			while (nz >= 8) {
  				c = (z >> (nz - 8)) & 0xff;
  				if (jas_stream_putc(out, c) == EOF) {
					return -1;
 					goto error;
  				}
  				nz -= 8;
  				z &= RAS_ONES(nz);
 			}
 		}
  		if (nz > 0) {
  			c = (z >> (8 - nz)) & RAS_ONES(nz);
  			if (jas_stream_putc(out, c) == EOF) {
				return -1;
 				goto error;
  			}
  		}
  		if (pad % 2) {
  			if (jas_stream_putc(out, 0) == EOF) {
				return -1;
 				goto error;
  			}
  		}
  	}
  	for (i = 0; i < numcmpts; ++i) {
  		jas_matrix_destroy(data[i]);
 		data[i] = 0;
  	}
  	return 0;
 error:
 	for (i = 0; i < numcmpts; ++i) {
 		if (data[i]) {
 			jas_matrix_destroy(data[i]);
 		}
 	}
 	return -1;
  }","[13, 14, 15, 16, 18, 19, 20, 21, 22, 23, 32, 33, 52, 53, 62, 63, 68, 69, 75, 78, 79, 80, 81, 82, 83, 84]",The ras_getcmap function in ras_dec.c in JasPer before 1.900.14 allows remote attackers to cause a denial of service (assertion failure) via a crafted image file.,jasper,CVE-2016-9388,
4559,179877,"  int cg_mkdir(const char *path, mode_t mode)
  {
  	struct fuse_context *fc = fuse_get_context();
	char *fpath = NULL, *path1, *cgdir = NULL, *controller;
 	char *fpath = NULL, *path1, *cgdir = NULL, *controller, *next = NULL;
  	const char *cgroup;
  	int ret;
 	if (!fc)
 		return -EIO;
 	controller = pick_controller_from_path(fc, path);
 	if (!controller)
 		return -EINVAL;
 	cgroup = find_cgroup_in_path(path);
 	if (!cgroup)
 		return -EINVAL;
 	get_cgdir_and_path(cgroup, &cgdir, &fpath);
 	if (!fpath)
 		path1 = ""/"";
  	else
  		path1 = cgdir;
 	if (!caller_is_in_ancestor(fc->pid, controller, path1, &next)) {
 		if (fpath && strcmp(next, fpath) == 0)
 			ret = -EEXIST;
 		else
 			ret = -ENOENT;
 		goto out;
 	}
  	if (!fc_may_access(fc, controller, path1, NULL, O_RDWR)) {
  		ret = -EACCES;
  		goto out;
 	}
 	if (!caller_is_in_ancestor(fc->pid, controller, path1, NULL)) {
 		ret = -EACCES;
 		goto out;
 	}
 	ret = cgfs_create(controller, cgroup, fc->uid, fc->gid);
 	printf(""cgfs_create returned %d for %s %s\n"", ret, controller, cgroup);
  out:
  	free(cgdir);
 	free(next);
  	return ret;
  }","[4, 5, 21, 22, 23, 24, 25, 26, 27, 40]","LXCFS before 0.12 does not properly enforce directory escapes, which might allow local users to gain privileges by (1) querying or (2) updating a cgroup.",lxcfs,CVE-2015-1342,CWE-264
4567,179646," stf_status ikev2parent_inI1outR1(struct msg_digest *md)
 {
 	struct state *st = md->st;
 	lset_t policy = POLICY_IKEV2_ALLOW;
 	struct connection *c = find_host_connection(&md->iface->ip_addr,
 						    md->iface->port,
 						    &md->sender,
 						    md->sender_port,
 						    POLICY_IKEV2_ALLOW);
 #if 0
 	if (c == NULL) {
 		pb_stream pre_sa_pbs = sa_pd->pbs;
 		policy = preparse_isakmp_sa_body(&pre_sa_pbs);
 		c = find_host_connection(&md->iface->ip_addr, pluto_port,
 					 (ip_address*)NULL, md->sender_port,
 					 policy);
 	}
 #endif
 	if (c == NULL) {
 		{
 			struct connection *d;
 			d = find_host_connection(&md->iface->ip_addr,
 						 pluto_port,
 						 (ip_address*)NULL,
 						 md->sender_port, policy);
 			for (; d != NULL; d = d->hp_next) {
 				if (d->kind == CK_GROUP) {
 				} else {
 					if (d->kind == CK_TEMPLATE &&
 					    !(d->policy & POLICY_OPPO)) {
 						c = d;
 						break;
 					}
 					if (addrinsubnet(&md->sender,
 							 &d->spd.that.client)
 					    &&
 					    (c == NULL ||
 					     !subnetinsubnet(&c->spd.that.
 							     client,
 							     &d->spd.that.
 							     client)))
 						c = d;
 				}
 			}
 		}
 		if (c == NULL) {
 			loglog(RC_LOG_SERIOUS, ""initial parent SA message received on %s:%u""
 			       "" but no connection has been authorized%s%s"",
 			       ip_str(
 				       &md->iface->ip_addr),
 			       ntohs(portof(&md->iface->ip_addr)),
 			       (policy != LEMPTY) ? "" with policy="" : """",
 			       (policy !=
 				LEMPTY) ? bitnamesof(sa_policy_bit_names,
 						     policy) : """");
 			return STF_FAIL + v2N_NO_PROPOSAL_CHOSEN;
 		}
 		if (c->kind != CK_TEMPLATE) {
 			loglog(RC_LOG_SERIOUS, ""initial parent SA message received on %s:%u""
 			       "" but \""%s\"" forbids connection"",
 			       ip_str(
 				       &md->iface->ip_addr), pluto_port,
 			       c->name);
 			return STF_FAIL + v2N_NO_PROPOSAL_CHOSEN;
 		}
 		c = rw_instantiate(c, &md->sender, NULL, NULL);
 	} else {
 		if ((c->kind == CK_TEMPLATE) && c->spd.that.virt) {
 			DBG(DBG_CONTROL,
 			    DBG_log(
 				    ""local endpoint has virt (vnet/vhost) set without wildcards - needs instantiation""));
 			c = rw_instantiate(c, &md->sender, NULL, NULL);
 		} else if ((c->kind == CK_TEMPLATE) &&
 			   (c->policy & POLICY_IKEV2_ALLOW_NARROWING)) {
 			DBG(DBG_CONTROL,
 			    DBG_log(
 				    ""local endpoint has narrowing=yes - needs instantiation""));
 			c = rw_instantiate(c, &md->sender, NULL, NULL);
 		}
 	}
 	DBG_log(""found connection: %s\n"", c ? c->name : ""<none>"");
 	if (!st) {
 		st = new_state();
 		memcpy(st->st_icookie, md->hdr.isa_icookie, COOKIE_SIZE);
 		get_cookie(FALSE, st->st_rcookie, COOKIE_SIZE, &md->sender);
 		initialize_new_state(st, c, policy, 0, NULL_FD,
 				     pcim_stranger_crypto);
 		st->st_ikev2 = TRUE;
 		change_state(st, STATE_PARENT_R1);
 		st->st_msgid_lastack = INVALID_MSGID;
 		st->st_msgid_nextuse = 0;
 		md->st = st;
 		md->from_state = STATE_IKEv2_BASE;
 	}
 	if (force_busy == TRUE) {
 		u_char dcookie[SHA1_DIGEST_SIZE];
 		chunk_t dc;
 		ikev2_get_dcookie( dcookie, st->st_ni, &md->sender,
 				   st->st_icookie);
 		dc.ptr = dcookie;
 		dc.len = SHA1_DIGEST_SIZE;
 		if ( md->chain[ISAKMP_NEXT_v2KE] &&
 		     md->chain[ISAKMP_NEXT_v2N] &&
 		     (md->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type ==
 		      v2N_COOKIE)) {
 			u_int8_t spisize;
 			const pb_stream *dc_pbs;
 			chunk_t blob;
 			DBG(DBG_CONTROLMORE,
 			    DBG_log(""received a DOS cookie in I1 verify it""));
 			spisize =
 				md->chain[ISAKMP_NEXT_v2N]->payload.v2n.
 				isan_spisize;
 			dc_pbs = &md->chain[ISAKMP_NEXT_v2N]->pbs;
 			blob.ptr = dc_pbs->cur + spisize;
 			blob.len = pbs_left(dc_pbs) - spisize;
 			DBG(DBG_CONTROLMORE,
 			    DBG_dump_chunk(""dcookie received in I1 Packet"",
 					   blob);
 			    DBG_dump(""dcookie computed"", dcookie,
 				     SHA1_DIGEST_SIZE));
 			if (memcmp(blob.ptr, dcookie, SHA1_DIGEST_SIZE) != 0) {
 				libreswan_log(
 					""mismatch in DOS v2N_COOKIE,send a new one"");
 				SEND_NOTIFICATION_AA(v2N_COOKIE, &dc);
 				return STF_FAIL + v2N_INVALID_IKE_SPI;
 			}
 			DBG(DBG_CONTROLMORE,
 			    DBG_log(""dcookie received match with computed one""));
 		} else {
 			DBG(DBG_CONTROLMORE,
 			    DBG_log(
 				    ""busy mode on. receieved I1 without a valid dcookie"");
 			    DBG_log(""send a dcookie and forget this state""));
 			SEND_NOTIFICATION_AA(v2N_COOKIE, &dc);
 			return STF_FAIL;
 		}
 	} else {
 		DBG(DBG_CONTROLMORE,
 		    DBG_log(""will not send/process a dcookie""));
 	}
  	{
  		struct ikev2_ke *ke;
 		char fromname[ADDRTOT_BUF];
 		addrtot(&md->sender, 0, fromname, ADDRTOT_BUF);
 		if (!md->chain[ISAKMP_NEXT_v2KE]) {
 			if(md->chain[ISAKMP_NEXT_v2N]) {
 				libreswan_log(""Received Notify(%d): %s"",
 					md->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type,
 					enum_name(&ikev2_notify_names,
 						md->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type));
 			}
 			libreswan_log(
 				""rejecting I1 from %s:%u, no KE payload present"",
 				fromname, md->sender_port);
 			return STF_FAIL + v2N_INVALID_KE_PAYLOAD;
 		}
  		ke = &md->chain[ISAKMP_NEXT_v2KE]->payload.v2ke;
  		st->st_oakley.group = lookup_group(ke->isak_group);
  		if (st->st_oakley.group == NULL) {
			char fromname[ADDRTOT_BUF];
			addrtot(&md->sender, 0, fromname, ADDRTOT_BUF);
  			libreswan_log(
  				""rejecting I1 from %s:%u, invalid DH group=%u"",
  				fromname, md->sender_port,
  				ke->isak_group);
			return v2N_INVALID_KE_PAYLOAD;
 			return STF_FAIL + v2N_INVALID_KE_PAYLOAD;
  		}
  	}
 	{
 		struct ke_continuation *ke = alloc_thing(
 			struct ke_continuation,
 			""ikev2_inI1outR1 KE"");
 		stf_status e;
 		ke->md = md;
 		set_suspended(st, ke->md);
 		if (!st->st_sec_in_use) {
 			pcrc_init(&ke->ke_pcrc);
 			ke->ke_pcrc.pcrc_func =
 				ikev2_parent_inI1outR1_continue;
 			e = build_ke(&ke->ke_pcrc, st, st->st_oakley.group,
 				     pcim_stranger_crypto);
 			if (e != STF_SUSPEND && e != STF_INLINE) {
 				loglog(RC_CRYPTOFAILED, ""system too busy"");
 				delete_state(st);
 			}
 		} else {
 			e =
 				ikev2_parent_inI1outR1_tail((struct
 							     pluto_crypto_req_cont
 							     *)ke,
 							    NULL);
 		}
 		reset_globals();
 		return e;
 	}
 }","[144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 161, 162, 167, 168]",The ikev2parent_inI1outR1 function in pluto/ikev2_parent.c in libreswan before 3.7 allows remote attackers to cause a denial of service (restart) via an IKEv2 I1 notification without a KE payload.,libreswan,CVE-2013-7294,CWE-20
4621,182340," GF_Err hdlr_dump(GF_Box *a, FILE * trace)
  {
  	GF_HandlerBox *p = (GF_HandlerBox *)a;
  	gf_isom_box_dump_start(a, ""HandlerBox"", trace);
	if (p->nameUTF8 && (u32) p->nameUTF8[0] == strlen(p->nameUTF8+1)) {
 	if (p->nameUTF8 && (u32) p->nameUTF8[0] == strlen(p->nameUTF8)-1) {
  		fprintf(trace, ""hdlrType=\""%s\"" Name=\""%s\"" "", gf_4cc_to_str(p->handlerType), p->nameUTF8+1);
  	} else {
  		fprintf(trace, ""hdlrType=\""%s\"" Name=\""%s\"" "", gf_4cc_to_str(p->handlerType), p->nameUTF8);
 	}
 	fprintf(trace, ""reserved1=\""%d\"" reserved2=\"""", p->reserved1);
 	dump_data(trace, (char *) p->reserved2, 12);
 	fprintf(trace, ""\"""");
 	fprintf(trace, "">\n"");
 	gf_isom_box_dump_done(""HandlerBox"", a, trace);
 	return GF_OK;
 }","[5, 6]",An issue was discovered in MP4Box in GPAC 0.7.1. There is a heap-based buffer over-read in the isomedia/box_dump.c function hdlr_dump.,gpac,CVE-2018-13006,CWE-125
4623,182220," authentic_process_fci(struct sc_card *card, struct sc_file *file,
 		 const unsigned char *buf, size_t buflen)
 {
 	struct sc_context *ctx = card->ctx;
 	size_t taglen;
 	int rv;
 	unsigned ii;
 	const unsigned char *tag = NULL;
 	unsigned char ops_DF[8] = {
 		SC_AC_OP_CREATE, SC_AC_OP_DELETE, SC_AC_OP_CRYPTO, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
 	};
 	unsigned char ops_EF[8] = {
 		SC_AC_OP_READ, SC_AC_OP_DELETE, SC_AC_OP_UPDATE, SC_AC_OP_RESIZE, 0xFF, 0xFF, 0xFF, 0xFF
 	};
 	LOG_FUNC_CALLED(ctx);
 	tag = sc_asn1_find_tag(card->ctx,  buf, buflen, 0x6F, &taglen);
 	if (tag != NULL) {
 		sc_log(ctx, ""  FCP length %""SC_FORMAT_LEN_SIZE_T""u"", taglen);
 		buf = tag;
 		buflen = taglen;
 	}
 	tag = sc_asn1_find_tag(card->ctx,  buf, buflen, 0x62, &taglen);
 	if (tag != NULL) {
 		sc_log(ctx, ""  FCP length %""SC_FORMAT_LEN_SIZE_T""u"", taglen);
 		buf = tag;
 		buflen = taglen;
 	}
 	rv = iso_ops->process_fci(card, file, buf, buflen);
 	LOG_TEST_RET(ctx, rv, ""ISO parse FCI failed"");
 	if (!file->sec_attr_len)   {
 		sc_log_hex(ctx, ""ACLs not found in data"", buf, buflen);
 		sc_log(ctx, ""Path:%s; Type:%X; PathType:%X"", sc_print_path(&file->path), file->type, file->path.type);
 		if (file->path.type == SC_PATH_TYPE_DF_NAME || file->type == SC_FILE_TYPE_DF)   {
 			file->type = SC_FILE_TYPE_DF;
 		}
 		else   {
 			LOG_TEST_RET(ctx, SC_ERROR_OBJECT_NOT_FOUND, ""ACLs tag missing"");
 		}
  	}
  	sc_log_hex(ctx, ""ACL data"", file->sec_attr, file->sec_attr_len);
	for (ii = 0; ii < file->sec_attr_len / 2; ii++)  {
 	for (ii = 0; ii < file->sec_attr_len / 2 && ii < sizeof ops_DF; ii++)  {
  		unsigned char op = file->type == SC_FILE_TYPE_DF ? ops_DF[ii] : ops_EF[ii];
  		unsigned char acl = *(file->sec_attr + ii*2);
  		unsigned char cred_id = *(file->sec_attr + ii*2 + 1);
 		unsigned sc = acl * 0x100 + cred_id;
 		sc_log(ctx, ""ACL(%i) op 0x%X, acl %X:%X"", ii, op, acl, cred_id);
 		if (op == 0xFF)
 			;
 		else if (!acl && !cred_id)
 			sc_file_add_acl_entry(file, op, SC_AC_NONE, 0);
 		else if (acl == 0xFF)
 			sc_file_add_acl_entry(file, op, SC_AC_NEVER, 0);
 		else if (acl & AUTHENTIC_AC_SM_MASK)
 			sc_file_add_acl_entry(file, op, SC_AC_SCB, sc);
 		else if (cred_id)
 			sc_file_add_acl_entry(file, op, SC_AC_CHV, cred_id);
 		else
 			sc_file_add_acl_entry(file, op, SC_AC_NEVER, 0);
 	}
 	LOG_FUNC_RETURN(ctx, 0);
 }","[41, 42]",Various out of bounds reads when handling responses in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to potentially crash the opensc library using programs.,OpenSC,CVE-2018-16427,CWE-125
4654,182117," static int start_decoder(vorb *f)
 {
    uint8 header[6], x,y;
    int len,i,j,k, max_submaps = 0;
    int longest_floorlist=0;
    if (!start_page(f))                              return FALSE;
    if (!(f->page_flag & PAGEFLAG_first_page))       return error(f, VORBIS_invalid_first_page);
    if (f->page_flag & PAGEFLAG_last_page)           return error(f, VORBIS_invalid_first_page);
    if (f->page_flag & PAGEFLAG_continued_packet)    return error(f, VORBIS_invalid_first_page);
    if (f->segment_count != 1)                       return error(f, VORBIS_invalid_first_page);
    if (f->segments[0] != 30)                        return error(f, VORBIS_invalid_first_page);
    if (get8(f) != VORBIS_packet_id)                 return error(f, VORBIS_invalid_first_page);
    if (!getn(f, header, 6))                         return error(f, VORBIS_unexpected_eof);
    if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_first_page);
    if (get32(f) != 0)                               return error(f, VORBIS_invalid_first_page);
    f->channels = get8(f); if (!f->channels)         return error(f, VORBIS_invalid_first_page);
    if (f->channels > STB_VORBIS_MAX_CHANNELS)       return error(f, VORBIS_too_many_channels);
    f->sample_rate = get32(f); if (!f->sample_rate)  return error(f, VORBIS_invalid_first_page);
    get32(f);  
    get32(f);  
    get32(f);  
    x = get8(f);
    {
       int log0,log1;
       log0 = x & 15;
       log1 = x >> 4;
       f->blocksize_0 = 1 << log0;
       f->blocksize_1 = 1 << log1;
       if (log0 < 6 || log0 > 13)                       return error(f, VORBIS_invalid_setup);
       if (log1 < 6 || log1 > 13)                       return error(f, VORBIS_invalid_setup);
       if (log0 > log1)                                 return error(f, VORBIS_invalid_setup);
    }
    x = get8(f);
    if (!(x & 1))                                    return error(f, VORBIS_invalid_first_page);
    if (!start_page(f))                              return FALSE;
    if (!start_packet(f))                            return FALSE;
    do {
       len = next_segment(f);
       skip(f, len);
       f->bytes_in_seg = 0;
    } while (len);
    if (!start_packet(f))                            return FALSE;
    #ifndef STB_VORBIS_NO_PUSHDATA_API
    if (IS_PUSH_MODE(f)) {
       if (!is_whole_packet_present(f, TRUE)) {
          if (f->error == VORBIS_invalid_stream)
             f->error = VORBIS_invalid_setup;
          return FALSE;
       }
    }
    #endif
    crc32_init();  
    if (get8_packet(f) != VORBIS_packet_setup)       return error(f, VORBIS_invalid_setup);
    for (i=0; i < 6; ++i) header[i] = get8_packet(f);
    if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_setup);
    f->codebook_count = get_bits(f,8) + 1;
    f->codebooks = (Codebook *) setup_malloc(f, sizeof(*f->codebooks) * f->codebook_count);
    if (f->codebooks == NULL)                        return error(f, VORBIS_outofmem);
    memset(f->codebooks, 0, sizeof(*f->codebooks) * f->codebook_count);
    for (i=0; i < f->codebook_count; ++i) {
       uint32 *values;
       int ordered, sorted_count;
       int total=0;
       uint8 *lengths;
       Codebook *c = f->codebooks+i;
       CHECK(f);
       x = get_bits(f, 8); if (x != 0x42)            return error(f, VORBIS_invalid_setup);
       x = get_bits(f, 8); if (x != 0x43)            return error(f, VORBIS_invalid_setup);
       x = get_bits(f, 8); if (x != 0x56)            return error(f, VORBIS_invalid_setup);
       x = get_bits(f, 8);
       c->dimensions = (get_bits(f, 8)<<8) + x;
       x = get_bits(f, 8);
       y = get_bits(f, 8);
       c->entries = (get_bits(f, 8)<<16) + (y<<8) + x;
       ordered = get_bits(f,1);
       c->sparse = ordered ? 0 : get_bits(f,1);
       if (c->dimensions == 0 && c->entries != 0)    return error(f, VORBIS_invalid_setup);
       if (c->sparse)
          lengths = (uint8 *) setup_temp_malloc(f, c->entries);
       else
          lengths = c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);
       if (!lengths) return error(f, VORBIS_outofmem);
       if (ordered) {
          int current_entry = 0;
          int current_length = get_bits(f,5) + 1;
          while (current_entry < c->entries) {
             int limit = c->entries - current_entry;
             int n = get_bits(f, ilog(limit));
             if (current_entry + n > (int) c->entries) { return error(f, VORBIS_invalid_setup); }
             memset(lengths + current_entry, current_length, n);
             current_entry += n;
             ++current_length;
          }
       } else {
          for (j=0; j < c->entries; ++j) {
             int present = c->sparse ? get_bits(f,1) : 1;
             if (present) {
                lengths[j] = get_bits(f, 5) + 1;
                ++total;
                if (lengths[j] == 32)
                   return error(f, VORBIS_invalid_setup);
             } else {
                lengths[j] = NO_CODE;
             }
          }
       }
       if (c->sparse && total >= c->entries >> 2) {
          if (c->entries > (int) f->setup_temp_memory_required)
             f->setup_temp_memory_required = c->entries;
          c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);
          if (c->codeword_lengths == NULL) return error(f, VORBIS_outofmem);
          memcpy(c->codeword_lengths, lengths, c->entries);
          setup_temp_free(f, lengths, c->entries);  
          lengths = c->codeword_lengths;
          c->sparse = 0;
       }
       if (c->sparse) {
          sorted_count = total;
       } else {
          sorted_count = 0;
          #ifndef STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH
          for (j=0; j < c->entries; ++j)
             if (lengths[j] > STB_VORBIS_FAST_HUFFMAN_LENGTH && lengths[j] != NO_CODE)
                ++sorted_count;
          #endif
       }
       c->sorted_entries = sorted_count;
       values = NULL;
       CHECK(f);
       if (!c->sparse) {
          c->codewords = (uint32 *) setup_malloc(f, sizeof(c->codewords[0]) * c->entries);
          if (!c->codewords)                  return error(f, VORBIS_outofmem);
       } else {
          unsigned int size;
          if (c->sorted_entries) {
             c->codeword_lengths = (uint8 *) setup_malloc(f, c->sorted_entries);
             if (!c->codeword_lengths)           return error(f, VORBIS_outofmem);
             c->codewords = (uint32 *) setup_temp_malloc(f, sizeof(*c->codewords) * c->sorted_entries);
             if (!c->codewords)                  return error(f, VORBIS_outofmem);
             values = (uint32 *) setup_temp_malloc(f, sizeof(*values) * c->sorted_entries);
             if (!values)                        return error(f, VORBIS_outofmem);
          }
          size = c->entries + (sizeof(*c->codewords) + sizeof(*values)) * c->sorted_entries;
          if (size > f->setup_temp_memory_required)
             f->setup_temp_memory_required = size;
       }
       if (!compute_codewords(c, lengths, c->entries, values)) {
          if (c->sparse) setup_temp_free(f, values, 0);
          return error(f, VORBIS_invalid_setup);
       }
       if (c->sorted_entries) {
          c->sorted_codewords = (uint32 *) setup_malloc(f, sizeof(*c->sorted_codewords) * (c->sorted_entries+1));
          if (c->sorted_codewords == NULL) return error(f, VORBIS_outofmem);
          c->sorted_values    = ( int   *) setup_malloc(f, sizeof(*c->sorted_values   ) * (c->sorted_entries+1));
          if (c->sorted_values == NULL) return error(f, VORBIS_outofmem);
          ++c->sorted_values;
          c->sorted_values[-1] = -1;
          compute_sorted_huffman(c, lengths, values);
       }
       if (c->sparse) {
          setup_temp_free(f, values, sizeof(*values)*c->sorted_entries);
          setup_temp_free(f, c->codewords, sizeof(*c->codewords)*c->sorted_entries);
          setup_temp_free(f, lengths, c->entries);
          c->codewords = NULL;
       }
       compute_accelerated_huffman(c);
       CHECK(f);
       c->lookup_type = get_bits(f, 4);
       if (c->lookup_type > 2) return error(f, VORBIS_invalid_setup);
       if (c->lookup_type > 0) {
          uint16 *mults;
          c->minimum_value = float32_unpack(get_bits(f, 32));
          c->delta_value = float32_unpack(get_bits(f, 32));
          c->value_bits = get_bits(f, 4)+1;
          c->sequence_p = get_bits(f,1);
          if (c->lookup_type == 1) {
             c->lookup_values = lookup1_values(c->entries, c->dimensions);
          } else {
             c->lookup_values = c->entries * c->dimensions;
          }
          if (c->lookup_values == 0) return error(f, VORBIS_invalid_setup);
          mults = (uint16 *) setup_temp_malloc(f, sizeof(mults[0]) * c->lookup_values);
          if (mults == NULL) return error(f, VORBIS_outofmem);
          for (j=0; j < (int) c->lookup_values; ++j) {
             int q = get_bits(f, c->value_bits);
             if (q == EOP) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_invalid_setup); }
             mults[j] = q;
          }
 #ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK
          if (c->lookup_type == 1) {
             int len, sparse = c->sparse;
             float last=0;
             if (sparse) {
                if (c->sorted_entries == 0) goto skip;
                c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->sorted_entries * c->dimensions);
             } else
                c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->entries        * c->dimensions);
             if (c->multiplicands == NULL) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }
             len = sparse ? c->sorted_entries : c->entries;
             for (j=0; j < len; ++j) {
                unsigned int z = sparse ? c->sorted_values[j] : j;
                unsigned int div=1;
                for (k=0; k < c->dimensions; ++k) {
                   int off = (z / div) % c->lookup_values;
                   float val = mults[off];
                   val = mults[off]*c->delta_value + c->minimum_value + last;
                   c->multiplicands[j*c->dimensions + k] = val;
                   if (c->sequence_p)
                      last = val;
                   if (k+1 < c->dimensions) {
                      if (div > UINT_MAX / (unsigned int) c->lookup_values) {
                         setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values);
                         return error(f, VORBIS_invalid_setup);
                      }
                      div *= c->lookup_values;
                   }
                }
             }
             c->lookup_type = 2;
          }
          else
 #endif
          {
             float last=0;
             CHECK(f);
             c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->lookup_values);
             if (c->multiplicands == NULL) { setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }
             for (j=0; j < (int) c->lookup_values; ++j) {
                float val = mults[j] * c->delta_value + c->minimum_value + last;
                c->multiplicands[j] = val;
                if (c->sequence_p)
                   last = val;
             }
          }
 #ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK
         skip:;
 #endif
          setup_temp_free(f, mults, sizeof(mults[0])*c->lookup_values);
          CHECK(f);
       }
       CHECK(f);
    }
    x = get_bits(f, 6) + 1;
    for (i=0; i < x; ++i) {
       uint32 z = get_bits(f, 16);
       if (z != 0) return error(f, VORBIS_invalid_setup);
    }
    f->floor_count = get_bits(f, 6)+1;
    f->floor_config = (Floor *)  setup_malloc(f, f->floor_count * sizeof(*f->floor_config));
    if (f->floor_config == NULL) return error(f, VORBIS_outofmem);
    for (i=0; i < f->floor_count; ++i) {
       f->floor_types[i] = get_bits(f, 16);
       if (f->floor_types[i] > 1) return error(f, VORBIS_invalid_setup);
       if (f->floor_types[i] == 0) {
          Floor0 *g = &f->floor_config[i].floor0;
          g->order = get_bits(f,8);
          g->rate = get_bits(f,16);
          g->bark_map_size = get_bits(f,16);
          g->amplitude_bits = get_bits(f,6);
          g->amplitude_offset = get_bits(f,8);
          g->number_of_books = get_bits(f,4) + 1;
          for (j=0; j < g->number_of_books; ++j)
             g->book_list[j] = get_bits(f,8);
          return error(f, VORBIS_feature_not_supported);
       } else {
          stbv__floor_ordering p[31*8+2];
          Floor1 *g = &f->floor_config[i].floor1;
          int max_class = -1; 
          g->partitions = get_bits(f, 5);
          for (j=0; j < g->partitions; ++j) {
             g->partition_class_list[j] = get_bits(f, 4);
             if (g->partition_class_list[j] > max_class)
                max_class = g->partition_class_list[j];
          }
          for (j=0; j <= max_class; ++j) {
             g->class_dimensions[j] = get_bits(f, 3)+1;
             g->class_subclasses[j] = get_bits(f, 2);
             if (g->class_subclasses[j]) {
                g->class_masterbooks[j] = get_bits(f, 8);
                if (g->class_masterbooks[j] >= f->codebook_count) return error(f, VORBIS_invalid_setup);
             }
             for (k=0; k < 1 << g->class_subclasses[j]; ++k) {
                g->subclass_books[j][k] = get_bits(f,8)-1;
                if (g->subclass_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);
             }
          }
          g->floor1_multiplier = get_bits(f,2)+1;
          g->rangebits = get_bits(f,4);
          g->Xlist[0] = 0;
          g->Xlist[1] = 1 << g->rangebits;
          g->values = 2;
          for (j=0; j < g->partitions; ++j) {
             int c = g->partition_class_list[j];
             for (k=0; k < g->class_dimensions[c]; ++k) {
                g->Xlist[g->values] = get_bits(f, g->rangebits);
                ++g->values;
             }
          }
          for (j=0; j < g->values; ++j) {
             p[j].x = g->Xlist[j];
             p[j].id = j;
          }
          qsort(p, g->values, sizeof(p[0]), point_compare);
          for (j=0; j < g->values; ++j)
             g->sorted_order[j] = (uint8) p[j].id;
          for (j=2; j < g->values; ++j) {
             int low,hi;
             neighbors(g->Xlist, j, &low,&hi);
             g->neighbors[j][0] = low;
             g->neighbors[j][1] = hi;
          }
          if (g->values > longest_floorlist)
             longest_floorlist = g->values;
       }
    }
    f->residue_count = get_bits(f, 6)+1;
    f->residue_config = (Residue *) setup_malloc(f, f->residue_count * sizeof(f->residue_config[0]));
    if (f->residue_config == NULL) return error(f, VORBIS_outofmem);
    memset(f->residue_config, 0, f->residue_count * sizeof(f->residue_config[0]));
    for (i=0; i < f->residue_count; ++i) {
       uint8 residue_cascade[64];
       Residue *r = f->residue_config+i;
       f->residue_types[i] = get_bits(f, 16);
       if (f->residue_types[i] > 2) return error(f, VORBIS_invalid_setup);
       r->begin = get_bits(f, 24);
       r->end = get_bits(f, 24);
       if (r->end < r->begin) return error(f, VORBIS_invalid_setup);
       r->part_size = get_bits(f,24)+1;
       r->classifications = get_bits(f,6)+1;
       r->classbook = get_bits(f,8);
       if (r->classbook >= f->codebook_count) return error(f, VORBIS_invalid_setup);
       for (j=0; j < r->classifications; ++j) {
          uint8 high_bits=0;
          uint8 low_bits=get_bits(f,3);
          if (get_bits(f,1))
             high_bits = get_bits(f,5);
          residue_cascade[j] = high_bits*8 + low_bits;
       }
       r->residue_books = (short (*)[8]) setup_malloc(f, sizeof(r->residue_books[0]) * r->classifications);
       if (r->residue_books == NULL) return error(f, VORBIS_outofmem);
       for (j=0; j < r->classifications; ++j) {
          for (k=0; k < 8; ++k) {
             if (residue_cascade[j] & (1 << k)) {
                r->residue_books[j][k] = get_bits(f, 8);
                if (r->residue_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);
             } else {
                r->residue_books[j][k] = -1;
             }
          }
       }
       r->classdata = (uint8 **) setup_malloc(f, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);
       if (!r->classdata) return error(f, VORBIS_outofmem);
       memset(r->classdata, 0, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);
       for (j=0; j < f->codebooks[r->classbook].entries; ++j) {
          int classwords = f->codebooks[r->classbook].dimensions;
          int temp = j;
          r->classdata[j] = (uint8 *) setup_malloc(f, sizeof(r->classdata[j][0]) * classwords);
          if (r->classdata[j] == NULL) return error(f, VORBIS_outofmem);
          for (k=classwords-1; k >= 0; --k) {
             r->classdata[j][k] = temp % r->classifications;
             temp /= r->classifications;
          }
       }
    }
    f->mapping_count = get_bits(f,6)+1;
    f->mapping = (Mapping *) setup_malloc(f, f->mapping_count * sizeof(*f->mapping));
    if (f->mapping == NULL) return error(f, VORBIS_outofmem);
    memset(f->mapping, 0, f->mapping_count * sizeof(*f->mapping));
    for (i=0; i < f->mapping_count; ++i) {
       Mapping *m = f->mapping + i;      
       int mapping_type = get_bits(f,16);
       if (mapping_type != 0) return error(f, VORBIS_invalid_setup);
       m->chan = (MappingChannel *) setup_malloc(f, f->channels * sizeof(*m->chan));
       if (m->chan == NULL) return error(f, VORBIS_outofmem);
       if (get_bits(f,1))
          m->submaps = get_bits(f,4)+1;
       else
          m->submaps = 1;
       if (m->submaps > max_submaps)
          max_submaps = m->submaps;
       if (get_bits(f,1)) {
          m->coupling_steps = get_bits(f,8)+1;
          for (k=0; k < m->coupling_steps; ++k) {
             m->chan[k].magnitude = get_bits(f, ilog(f->channels-1));
             m->chan[k].angle = get_bits(f, ilog(f->channels-1));
             if (m->chan[k].magnitude >= f->channels)        return error(f, VORBIS_invalid_setup);
             if (m->chan[k].angle     >= f->channels)        return error(f, VORBIS_invalid_setup);
             if (m->chan[k].magnitude == m->chan[k].angle)   return error(f, VORBIS_invalid_setup);
          }
       } else
          m->coupling_steps = 0;
       if (get_bits(f,2)) return error(f, VORBIS_invalid_setup);
       if (m->submaps > 1) {
          for (j=0; j < f->channels; ++j) {
             m->chan[j].mux = get_bits(f, 4);
             if (m->chan[j].mux >= m->submaps)                return error(f, VORBIS_invalid_setup);
          }
       } else
          for (j=0; j < f->channels; ++j)
             m->chan[j].mux = 0;
       for (j=0; j < m->submaps; ++j) {
          get_bits(f,8);  
          m->submap_floor[j] = get_bits(f,8);
          m->submap_residue[j] = get_bits(f,8);
          if (m->submap_floor[j] >= f->floor_count)      return error(f, VORBIS_invalid_setup);
          if (m->submap_residue[j] >= f->residue_count)  return error(f, VORBIS_invalid_setup);
       }
    }
    f->mode_count = get_bits(f, 6)+1;
    for (i=0; i < f->mode_count; ++i) {
       Mode *m = f->mode_config+i;
       m->blockflag = get_bits(f,1);
       m->windowtype = get_bits(f,16);
       m->transformtype = get_bits(f,16);
       m->mapping = get_bits(f,8);
       if (m->windowtype != 0)                 return error(f, VORBIS_invalid_setup);
       if (m->transformtype != 0)              return error(f, VORBIS_invalid_setup);
       if (m->mapping >= f->mapping_count)     return error(f, VORBIS_invalid_setup);
    }
    flush_packet(f);
    f->previous_length = 0;
    for (i=0; i < f->channels; ++i) {
       f->channel_buffers[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1);
       f->previous_window[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2);
       f->finalY[i]          = (int16 *) setup_malloc(f, sizeof(int16) * longest_floorlist);
       if (f->channel_buffers[i] == NULL || f->previous_window[i] == NULL || f->finalY[i] == NULL) return error(f, VORBIS_outofmem);
       #ifdef STB_VORBIS_NO_DEFER_FLOOR
       f->floor_buffers[i]   = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2);
       if (f->floor_buffers[i] == NULL) return error(f, VORBIS_outofmem);
       #endif
    }
    if (!init_blocksize(f, 0, f->blocksize_0)) return FALSE;
    if (!init_blocksize(f, 1, f->blocksize_1)) return FALSE;
    f->blocksize[0] = f->blocksize_0;
    f->blocksize[1] = f->blocksize_1;
 #ifdef STB_VORBIS_DIVIDE_TABLE
    if (integer_divide_table[1][1]==0)
       for (i=0; i < DIVTAB_NUMER; ++i)
          for (j=1; j < DIVTAB_DENOM; ++j)
             integer_divide_table[i][j] = i / j;
 #endif
    {
       uint32 imdct_mem = (f->blocksize_1 * sizeof(float) >> 1);
       uint32 classify_mem;
        int i,max_part_read=0;
        for (i=0; i < f->residue_count; ++i) {
           Residue *r = f->residue_config + i;
         int n_read = r->end - r->begin;
          unsigned int actual_size = f->blocksize_1 / 2;
          unsigned int limit_r_begin = r->begin < actual_size ? r->begin : actual_size;
          unsigned int limit_r_end   = r->end   < actual_size ? r->end   : actual_size;
          int n_read = limit_r_end - limit_r_begin;
           int part_read = n_read / r->part_size;
           if (part_read > max_part_read)
              max_part_read = part_read;
       }
       #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE
       classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(uint8 *));
       #else
        classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(int *));
        #endif
        f->temp_memory_required = classify_mem;
        if (imdct_mem > f->temp_memory_required)
           f->temp_memory_required = imdct_mem;
    }
    f->first_decode = TRUE;
    if (f->alloc.alloc_buffer) {
       assert(f->temp_offset == f->alloc.alloc_buffer_length_in_bytes);
       if (f->setup_offset + sizeof(*f) + f->temp_memory_required > (unsigned) f->temp_offset)
          return error(f, VORBIS_outofmem);
    }
    f->first_audio_page_offset = stb_vorbis_get_file_offset(f);
    return TRUE;
 }","[448, 449, 450, 451, 452]","Sean Barrett stb_vorbis version 1.12 and earlier contains a Buffer Overflow vulnerability in All vorbis decoding paths. that can result in memory corruption, denial of service, comprised execution of host program. This attack appear to be exploitable via Victim must open a specially crafted Ogg Vorbis file. This vulnerability appears to have been fixed in 1.13.",stb,CVE-2018-1000050,CWE-119
4658,181878,"  void jas_matrix_setall(jas_matrix_t *matrix, jas_seqent_t val)
  {
	int i;
	int j;
 	jas_matind_t i;
 	jas_matind_t j;
  	jas_seqent_t *rowstart;
	int rowstep;
 	jas_matind_t rowstep;
  	jas_seqent_t *data;
  	if (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {
 		assert(matrix->rows_);
 		rowstep = jas_matrix_rowstep(matrix);
 		for (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,
 		  rowstart += rowstep) {
 			for (j = matrix->numcols_, data = rowstart; j > 0; --j,
 			  ++data) {
 				*data = val;
 			}
 		}
 	}
 }","[3, 4, 5, 6, 8, 9]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
4685,179853,"  cleanup_pathname(struct archive_write_disk *a)
 {
 	char *dest, *src;
 	char separator = '\0';
 	dest = src = a->name;
 	if (*src == '\0') {
 		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
 		    ""Invalid empty pathname"");
 		return (ARCHIVE_FAILED);
 	}
 #if defined(__CYGWIN__)
  	cleanup_pathname_win(a);
  #endif
	if (*src == '/')
 	if (*src == '/') {
 		if (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
 			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
 			                  ""Path is absolute"");
 			return (ARCHIVE_FAILED);
 		}
  		separator = *src++;
 	}
  	for (;;) {
 		if (src[0] == '\0') {
 			break;
 		} else if (src[0] == '/') {
 			src++;
 			continue;
 		} else if (src[0] == '.') {
 			if (src[1] == '\0') {
 				break;
 			} else if (src[1] == '/') {
 				src += 2;
 				continue;
 			} else if (src[1] == '.') {
 				if (src[2] == '/' || src[2] == '\0') {
 					if (a->flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {
 						archive_set_error(&a->archive,
 						    ARCHIVE_ERRNO_MISC,
 						    ""Path contains '..'"");
 						return (ARCHIVE_FAILED);
 					}
 				}
 			}
 		}
 		if (separator)
 			*dest++ = '/';
 		while (*src != '\0' && *src != '/') {
 			*dest++ = *src++;
 		}
 		if (*src == '\0')
 			break;
 		separator = *src++;
 	}
 	if (dest == a->name) {
 		if (separator)
 			*dest++ = '/';
 		else
 			*dest++ = '.';
 	}
 	*dest = '\0';
 	return (ARCHIVE_OK);
 }","[14, 15, 16, 17, 18, 19, 20, 22]",Absolute path traversal vulnerability in bsdcpio in libarchive 3.1.2 and earlier allows remote attackers to write to arbitrary files via a full pathname in an archive.,libarchive,CVE-2015-2304,CWE-22
4691,182723,"  size_t OpenMP4SourceUDTA(char *filename)
  {
 	mp4object *mp4 = (mp4object *)malloc(sizeof(mp4object));
 	if (mp4 == NULL) return 0;
 	memset(mp4, 0, sizeof(mp4object));
 #ifdef _WINDOWS
 	fopen_s(&mp4->mediafp, filename, ""rb"");
 #else
 	mp4->mediafp = fopen(filename, ""rb"");
 #endif
  	if (mp4->mediafp)
  	{
		uint32_t qttag, qtsize32, len;
 		uint32_t qttag, qtsize32;
 		size_t len;
  		int32_t nest = 0;
  		uint64_t nestsize[MAX_NEST_LEVEL] = { 0 };
  		uint64_t lastsize = 0, qtsize;
 		do
 		{
 			len = fread(&qtsize32, 1, 4, mp4->mediafp);
 			len += fread(&qttag, 1, 4, mp4->mediafp);
 			if (len == 8)
  			{
  				if (!GPMF_VALID_FOURCC(qttag))
  				{
					LONGSEEK(mp4->mediafp, lastsize - 8 - 8, SEEK_CUR);
 					LongSeek(mp4, lastsize - 8 - 8);
  					NESTSIZE(lastsize - 8);
  					continue;
 				}
 				qtsize32 = BYTESWAP32(qtsize32);
 				if (qtsize32 == 1)  
 				{
 					fread(&qtsize, 1, 8, mp4->mediafp);
 					qtsize = BYTESWAP64(qtsize) - 8;
 				}
 				else
 					qtsize = qtsize32;
 				nest++;
 				if (qtsize < 8) break;
 				if (nest >= MAX_NEST_LEVEL) break;
 				nestsize[nest] = qtsize;
 				lastsize = qtsize;
  				if (qttag == MAKEID('m', 'd', 'a', 't') ||
  					qttag == MAKEID('f', 't', 'y', 'p'))
  				{
					LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
 					LongSeek(mp4, qtsize - 8);
  					NESTSIZE(qtsize);
  					continue;
  				}
 				if (qttag == MAKEID('G', 'P', 'M', 'F'))
 				{
 					mp4->videolength += 1.0;
 					mp4->metadatalength += 1.0;
 					mp4->indexcount = (int)mp4->metadatalength;
 					mp4->metasizes = (uint32_t *)malloc(mp4->indexcount * 4 + 4);  memset(mp4->metasizes, 0, mp4->indexcount * 4 + 4);
 					mp4->metaoffsets = (uint64_t *)malloc(mp4->indexcount * 8 + 8);  memset(mp4->metaoffsets, 0, mp4->indexcount * 8 + 8);
 					mp4->metasizes[0] = (int)qtsize - 8;
 					mp4->metaoffsets[0] = ftell(mp4->mediafp);
 					mp4->metasize_count = 1;
 					return (size_t)mp4;   
 				}
  				if (qttag != MAKEID('m', 'o', 'o', 'v') &&  
  					qttag != MAKEID('u', 'd', 't', 'a'))
  				{
					LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
 					LongSeek(mp4, qtsize - 8);
  					NESTSIZE(qtsize);
  					continue;
  				}
 				else
 				{
 					NESTSIZE(8);
 				}
 			}
 		} while (len > 0);
 	}
 	return (size_t)mp4;
  }","[13, 14, 15, 27, 28, 48, 49, 68, 69]",GoPro GPMF-parser 1.2.2 has an out-of-bounds write in OpenMP4Source in demo/GPMF_mp4reader.c.,gpmf-parser,CVE-2019-15148,CWE-787
4692,182057," inf_gtk_certificate_manager_certificate_func(InfXmppConnection* connection,
                                              gnutls_session_t session,
                                              InfCertificateChain* chain,
                                              gpointer user_data)
 {
   InfGtkCertificateManager* manager;
   InfGtkCertificateManagerPrivate* priv;
   InfGtkCertificateDialogFlags flags;
   gnutls_x509_crt_t presented_cert;
   gnutls_x509_crt_t known_cert;
   gchar* hostname;
   gboolean match_hostname;
   gboolean issuer_known;
   gnutls_x509_crt_t root_cert;
   int ret;
   unsigned int verify;
   GHashTable* table;
   gboolean cert_equal;
   time_t expiration_time;
   InfGtkCertificateManagerQuery* query;
   gchar* text;
   GtkWidget* vbox;
   GtkWidget* label;
   GError* error;
   manager = INF_GTK_CERTIFICATE_MANAGER(user_data);
   priv = INF_GTK_CERTIFICATE_MANAGER_PRIVATE(manager);
   g_object_get(G_OBJECT(connection), ""remote-hostname"", &hostname, NULL);
   presented_cert = inf_certificate_chain_get_own_certificate(chain);
   match_hostname = gnutls_x509_crt_check_hostname(presented_cert, hostname);
   ret = gnutls_certificate_verify_peers2(session, &verify);
   error = NULL;
   if(ret != GNUTLS_E_SUCCESS)
     inf_gnutls_set_error(&error, ret);
   if(error == NULL)
   {
     issuer_known = TRUE;
     if(verify & GNUTLS_CERT_SIGNER_NOT_FOUND)
     {
       issuer_known = FALSE;
       root_cert = inf_certificate_chain_get_root_certificate(chain);
       ret = gnutls_x509_crt_list_verify(
         inf_certificate_chain_get_raw(chain),
         inf_certificate_chain_get_n_certificates(chain),
         &root_cert,
         1,
         NULL,
         0,
         GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT,
         &verify
       );
        if(ret != GNUTLS_E_SUCCESS)
          inf_gnutls_set_error(&error, ret);
      else if(verify & GNUTLS_CERT_INVALID)
        inf_gnutls_certificate_verification_set_error(&error, verify);
      }
     if(error == NULL)
       if(verify & GNUTLS_CERT_INVALID)
         inf_gnutls_certificate_verification_set_error(&error, verify);
    }
   table = NULL;
   if(error == NULL)
   {
     known_cert = NULL;
     if(!match_hostname || !issuer_known)
     {
       table = inf_gtk_certificate_manager_ref_known_hosts(manager, &error);
       if(table != NULL)
         known_cert = g_hash_table_lookup(table, hostname);
     }
   }
   flags = 0;
   if(error == NULL)
   {
     if(known_cert != NULL)
     {
       cert_equal = inf_gtk_certificate_manager_compare_fingerprint(
         known_cert,
         presented_cert,
         &error
       );
       if(error == NULL && cert_equal == FALSE)
       {
         if(!match_hostname)
           flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_HOSTNAME_MISMATCH;
         if(!issuer_known)
           flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_ISSUER_NOT_KNOWN;
         flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_UNEXPECTED;
         expiration_time = gnutls_x509_crt_get_expiration_time(known_cert);
         if(expiration_time != (time_t)(-1))
         {
           expiration_time -= INF_GTK_CERTIFICATE_MANAGER_EXPIRATION_TOLERANCE;
           if(time(NULL) > expiration_time)
           {
             flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_OLD_EXPIRED;
           }
         }
       }
     }
     else
     {
       if(!match_hostname)
         flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_HOSTNAME_MISMATCH;
       if(!issuer_known)
         flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_ISSUER_NOT_KNOWN;
     }
   }
   if(error == NULL)
   {
     if(flags == 0)
     {
       if(match_hostname && issuer_known)
       {
         if(table != NULL && g_hash_table_remove(table, hostname) == TRUE)
         {
           inf_gtk_certificate_manager_write_known_hosts_with_warning(
             manager,
             table
           );
         }
       }
       inf_xmpp_connection_certificate_verify_continue(connection);
     }
     else
     {
       query = g_slice_new(InfGtkCertificateManagerQuery);
       query->manager = manager;
       query->known_hosts = table;
       query->connection = connection;
       query->dialog = inf_gtk_certificate_dialog_new(
         priv->parent_window,
         0,
         flags,
         hostname,
         chain
       );
       query->certificate_chain = chain;
       table = NULL;
       g_object_ref(query->connection);
       inf_certificate_chain_ref(chain);
       g_signal_connect(
         G_OBJECT(connection),
         ""notify::status"",
         G_CALLBACK(inf_gtk_certificate_manager_notify_status_cb),
         query
       );
       g_signal_connect(
         G_OBJECT(query->dialog),
         ""response"",
         G_CALLBACK(inf_gtk_certificate_manager_response_cb),
         query
       );
       gtk_dialog_add_button(
         GTK_DIALOG(query->dialog),
         _(""_Cancel connection""),
         GTK_RESPONSE_REJECT
       );
       gtk_dialog_add_button(
         GTK_DIALOG(query->dialog),
         _(""C_ontinue connection""),
         GTK_RESPONSE_ACCEPT
       );
       text = g_strdup_printf(
         _(""Do you want to continue the connection to host \""%s\""? If you ""
           ""choose to continue, this certificate will be trusted in the ""
           ""future when connecting to this host.""),
         hostname
       );
       label = gtk_label_new(text);
       gtk_label_set_line_wrap(GTK_LABEL(label), TRUE);
       gtk_label_set_line_wrap_mode(GTK_LABEL(label), PANGO_WRAP_WORD_CHAR);
       gtk_label_set_max_width_chars(GTK_LABEL(label), 60);
       gtk_misc_set_alignment(GTK_MISC(label), 0.0, 0.0);
       gtk_widget_show(label);
       g_free(text);
       vbox = gtk_dialog_get_content_area(GTK_DIALOG(query->dialog));
       gtk_box_pack_start(GTK_BOX(vbox), label, FALSE, FALSE, 0);
       priv->queries = g_slist_prepend(priv->queries, query);
       gtk_window_present(GTK_WINDOW(query->dialog));
     }
   }
   else
   {
     inf_xmpp_connection_certificate_verify_cancel(connection, error);
     g_error_free(error);
   }
   if(table != NULL) g_hash_table_unref(table);
   g_free(hostname);
 }","[53, 54, 56, 57, 58]","libinfinity before 0.6.6-1 does not validate expired SSL certificates, which allows remote attackers to have unspecified impact via unknown vectors.",libinfinity,CVE-2015-3886,CWE-295
4693,182251," int sc_file_set_sec_attr(sc_file_t *file, const u8 *sec_attr,
 			 size_t sec_attr_len)
 {
 	u8 *tmp;
 	if (!sc_file_valid(file)) {
  		return SC_ERROR_INVALID_ARGUMENTS;
  	}
	if (sec_attr == NULL) {
 	if (sec_attr == NULL || sec_attr_len) {
  		if (file->sec_attr != NULL)
  			free(file->sec_attr);
  		file->sec_attr = NULL;
 		file->sec_attr_len = 0;
 		return 0;
 	 }
 	tmp = (u8 *) realloc(file->sec_attr, sec_attr_len);
 	if (!tmp) {
 		if (file->sec_attr)
 			free(file->sec_attr);
 		file->sec_attr     = NULL;
 		file->sec_attr_len = 0;
 		return SC_ERROR_OUT_OF_MEMORY;
 	}
 	file->sec_attr = tmp;
 	memcpy(file->sec_attr, sec_attr, sec_attr_len);
 	file->sec_attr_len = sec_attr_len;
 	return 0;
 }","[8, 9]",A double free when handling responses from an HSM Card in sc_pkcs15emu_sc_hsm_init in libopensc/pkcs15-sc-hsm.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.,OpenSC,CVE-2018-16425,CWE-415
4715,182683," static void WritePixel(struct ngiflib_img * i, struct ngiflib_decode_context * context, u8 v) {
 	struct ngiflib_gif * p = i->parent;
 	if(v!=i->gce.transparent_color || !i->gce.transparent_flag) {
 #ifndef NGIFLIB_INDEXED_ONLY
 		if(p->mode & NGIFLIB_MODE_INDEXED) {
 #endif  
 			*context->frbuff_p.p8 = v;
 #ifndef NGIFLIB_INDEXED_ONLY
 		} else
 			*context->frbuff_p.p32 =
 			   GifIndexToTrueColor(i->palette, v);
 #endif  
 	}
 	if(--(context->Xtogo) <= 0) {
 		#ifdef NGIFLIB_ENABLE_CALLBACKS
 		if(p->line_cb) p->line_cb(p, context->line_p, context->curY);
 		#endif  
 		context->Xtogo = i->width;
 		switch(context->pass) {
 		case 0:
 			context->curY++;
  			break;
  		case 1:	 
  			context->curY += 8;
			if(context->curY >= p->height) {
				context->pass++;
				context->curY = i->posY + 4;
			}
  			break;
  		case 2:	 
  			context->curY += 8;
			if(context->curY >= p->height) {
				context->pass++;
				context->curY = i->posY + 2;
			}
  			break;
  		case 3:	 
  			context->curY += 4;
			if(context->curY >= p->height) {
				context->pass++;
				context->curY = i->posY + 1;
			}
  			break;
  		case 4:	 
  			context->curY += 2;
  			break;
  		}
 		while(context->pass > 0 && context->pass < 4 &&
 		      context->curY >= p->height) {
 			switch(++context->pass) {
 			case 2:	 
 				context->curY = i->posY + 4;
 				break;
 			case 3:	 
 				context->curY = i->posY + 2;
 				break;
 			case 4:	 
 				context->curY = i->posY + 1;
 				break;
 			}
 		}
  #ifndef NGIFLIB_INDEXED_ONLY
  		if(p->mode & NGIFLIB_MODE_INDEXED) {
  #endif  
 			#ifdef NGIFLIB_ENABLE_CALLBACKS
 			context->line_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width;
 			context->frbuff_p.p8 = context->line_p.p8 + i->posX;
 			#else
 			context->frbuff_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width + i->posX;
 			#endif  
 #ifndef NGIFLIB_INDEXED_ONLY
 		} else {
 			#ifdef NGIFLIB_ENABLE_CALLBACKS
 			context->line_p.p32 = p->frbuff.p32 + (u32)context->curY*p->width;
 			context->frbuff_p.p32 = context->line_p.p32 + i->posX;
 			#else
 			context->frbuff_p.p32 = p->frbuff.p32 + (u32)context->curY*p->width + i->posX;
 			#endif  
 		}
 #endif  
 	} else {
 #ifndef NGIFLIB_INDEXED_ONLY
 		if(p->mode & NGIFLIB_MODE_INDEXED) {
 #endif  
 			context->frbuff_p.p8++;
 #ifndef NGIFLIB_INDEXED_ONLY
 		} else {
 			context->frbuff_p.p32++;
 		}
 #endif  
 	}
 }","[25, 26, 27, 28, 32, 33, 34, 35, 39, 40, 41, 42, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61]","ngiflib 0.4 has a heap-based buffer overflow in WritePixels() in ngiflib.c when called from DecodeGifImg, because deinterlacing for small pictures is mishandled.",ngiflib,CVE-2019-16347,CWE-119
4727,181241," static int cdxl_decode_frame(AVCodecContext *avctx, void *data,
                              int *got_frame, AVPacket *pkt)
 {
     CDXLVideoContext *c = avctx->priv_data;
     AVFrame * const p = data;
     int ret, w, h, encoding, aligned_width, buf_size = pkt->size;
     const uint8_t *buf = pkt->data;
     if (buf_size < 32)
         return AVERROR_INVALIDDATA;
     encoding        = buf[1] & 7;
     c->format       = buf[1] & 0xE0;
     w               = AV_RB16(&buf[14]);
     h               = AV_RB16(&buf[16]);
     c->bpp          = buf[19];
     c->palette_size = AV_RB16(&buf[20]);
     c->palette      = buf + 32;
     c->video        = c->palette + c->palette_size;
     c->video_size   = buf_size - c->palette_size - 32;
     if (c->palette_size > 512)
         return AVERROR_INVALIDDATA;
     if (buf_size < c->palette_size + 32)
         return AVERROR_INVALIDDATA;
     if (c->bpp < 1)
         return AVERROR_INVALIDDATA;
     if (c->format != BIT_PLANAR && c->format != BIT_LINE && c->format != CHUNKY) {
         avpriv_request_sample(avctx, ""Pixel format 0x%0x"", c->format);
         return AVERROR_PATCHWELCOME;
     }
     if ((ret = ff_set_dimensions(avctx, w, h)) < 0)
         return ret;
     if (c->format == CHUNKY)
         aligned_width = avctx->width;
     else
         aligned_width = FFALIGN(c->avctx->width, 16);
     c->padded_bits  = aligned_width - c->avctx->width;
     if (c->video_size < aligned_width * avctx->height * (int64_t)c->bpp / 8)
          return AVERROR_INVALIDDATA;
      if (!encoding && c->palette_size && c->bpp <= 8 && c->format != CHUNKY) {
          avctx->pix_fmt = AV_PIX_FMT_PAL8;
    } else if (encoding == 1 && (c->bpp == 6 || c->bpp == 8)) {
     } else if (encoding == 1 && (c->bpp == 6 || c->bpp == 8) && c->format != CHUNKY) {
          if (c->palette_size != (1 << (c->bpp - 1)))
              return AVERROR_INVALIDDATA;
          avctx->pix_fmt = AV_PIX_FMT_BGR24;
     } else if (!encoding && c->bpp == 24 && c->format == CHUNKY &&
                !c->palette_size) {
         avctx->pix_fmt = AV_PIX_FMT_RGB24;
     } else {
         avpriv_request_sample(avctx, ""Encoding %d, bpp %d and format 0x%x"",
                               encoding, c->bpp, c->format);
         return AVERROR_PATCHWELCOME;
     }
     if ((ret = ff_get_buffer(avctx, p, 0)) < 0)
         return ret;
     p->pict_type = AV_PICTURE_TYPE_I;
     if (encoding) {
         av_fast_padded_malloc(&c->new_video, &c->new_video_size,
                               h * w + AV_INPUT_BUFFER_PADDING_SIZE);
         if (!c->new_video)
             return AVERROR(ENOMEM);
         if (c->bpp == 8)
             cdxl_decode_ham8(c, p);
         else
             cdxl_decode_ham6(c, p);
     } else if (avctx->pix_fmt == AV_PIX_FMT_PAL8) {
         cdxl_decode_rgb(c, p);
     } else {
         cdxl_decode_raw(c, p);
     }
     *got_frame = 1;
     return buf_size;
 }","[40, 41]","The cdxl_decode_frame function in libavcodec/cdxl.c in FFmpeg 2.8.x before 2.8.12, 3.0.x before 3.0.8, 3.1.x before 3.1.8, 3.2.x before 3.2.5, and 3.3.x before 3.3.1 does not exclude the CHUNKY format, which allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted file.",FFmpeg,CVE-2017-9996,CWE-119
4749,181896,"  static mif_hdr_t *mif_hdr_get(jas_stream_t *in)
  {
	uchar magicbuf[MIF_MAGICLEN];
 	jas_uchar magicbuf[MIF_MAGICLEN];
  	char buf[4096];
  	mif_hdr_t *hdr;
  	bool done;
 	jas_tvparser_t *tvp;
 	int id;
 	hdr = 0;
 	tvp = 0;
 	if (jas_stream_read(in, magicbuf, MIF_MAGICLEN) != MIF_MAGICLEN) {
 		goto error;
 	}
 	if (magicbuf[0] != (MIF_MAGIC >> 24) || magicbuf[1] != ((MIF_MAGIC >> 16) &
 	  0xff) || magicbuf[2] != ((MIF_MAGIC >> 8) & 0xff) || magicbuf[3] !=
 	  (MIF_MAGIC & 0xff)) {
 		jas_eprintf(""error: bad signature\n"");
 		goto error;
 	}
 	if (!(hdr = mif_hdr_create(0))) {
 		goto error;
 	}
 	done = false;
 	do {
 		if (!mif_getline(in, buf, sizeof(buf))) {
 			jas_eprintf(""mif_getline failed\n"");
 			goto error;
 		}
 		if (buf[0] == '\0') {
 			continue;
 		}
 		JAS_DBGLOG(10, (""header line: len=%d; %s\n"", strlen(buf), buf));
 		if (!(tvp = jas_tvparser_create(buf))) {
 			jas_eprintf(""jas_tvparser_create failed\n"");
 			goto error;
 		}
 		if (jas_tvparser_next(tvp)) {
 			jas_eprintf(""cannot get record type\n"");
 			goto error;
 		}
 		id = jas_taginfo_nonull(jas_taginfos_lookup(mif_tags2,
 		  jas_tvparser_gettag(tvp)))->id;
 		jas_tvparser_destroy(tvp);
 		tvp = 0;
 		switch (id) {
 		case MIF_CMPT:
 			if (mif_process_cmpt(hdr, buf)) {
 				jas_eprintf(""cannot get component information\n"");
 				goto error;
 			}
 			break;
 		case MIF_END:
 			done = 1;
 			break;
 		default:
 			jas_eprintf(""invalid header information: %s\n"", buf);
 			goto error;
 			break;
 		}
 	} while (!done);
 	return hdr;
 error:
 	if (hdr) {
 		mif_hdr_destroy(hdr);
 	}
 	if (tvp) {
 		jas_tvparser_destroy(tvp);
 	}
 	return 0;
 }","[3, 4]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
4761,179090," static int get_cox(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c)
 {
     uint8_t byte;
     if (bytestream2_get_bytes_left(&s->g) < 5)
         return AVERROR_INVALIDDATA;
     c->nreslevels = bytestream2_get_byteu(&s->g) + 1;
     if (c->nreslevels >= JPEG2000_MAX_RESLEVELS) {
         av_log(s->avctx, AV_LOG_ERROR, ""nreslevels %d is invalid\n"", c->nreslevels);
          return AVERROR_INVALIDDATA;
      }
     if (c->nreslevels <= s->reduction_factor) {
         av_log(s->avctx, AV_LOG_ERROR, ""reduction_factor too large for this bitstream, max is %d\n"", c->nreslevels - 1);
         s->reduction_factor = c->nreslevels - 1;
         return AVERROR(EINVAL);
     }
    if (c->nreslevels < s->reduction_factor)
        c->nreslevels2decode = 1;
    else
        c->nreslevels2decode = c->nreslevels - s->reduction_factor;
     c->nreslevels2decode = c->nreslevels - s->reduction_factor;
      c->log2_cblk_width  = (bytestream2_get_byteu(&s->g) & 15) + 2;  
      c->log2_cblk_height = (bytestream2_get_byteu(&s->g) & 15) + 2;  
     if (c->log2_cblk_width > 10 || c->log2_cblk_height > 10 ||
         c->log2_cblk_width + c->log2_cblk_height > 12) {
         av_log(s->avctx, AV_LOG_ERROR, ""cblk size invalid\n"");
         return AVERROR_INVALIDDATA;
     }
     if (c->log2_cblk_width > 6 || c->log2_cblk_height > 6) {
         avpriv_request_sample(s->avctx, ""cblk size > 64"");
         return AVERROR_PATCHWELCOME;
     }
     c->cblk_style = bytestream2_get_byteu(&s->g);
     if (c->cblk_style != 0) {  
         av_log(s->avctx, AV_LOG_WARNING, ""extra cblk styles %X\n"", c->cblk_style);
     }
     c->transform = bytestream2_get_byteu(&s->g);  
     if ((s->avctx->flags & CODEC_FLAG_BITEXACT) && (c->transform == FF_DWT97))
         c->transform = FF_DWT97_INT;
     if (c->csty & JPEG2000_CSTY_PREC) {
         int i;
         for (i = 0; i < c->nreslevels; i++) {
             byte = bytestream2_get_byte(&s->g);
             c->log2_prec_widths[i]  =  byte       & 0x0F;     
             c->log2_prec_heights[i] = (byte >> 4) & 0x0F;     
         }
     } else {
         memset(c->log2_prec_widths , 15, sizeof(c->log2_prec_widths ));
         memset(c->log2_prec_heights, 15, sizeof(c->log2_prec_heights));
     }
     return 0;
 }","[11, 12, 13, 14, 15, 16, 17, 18, 19, 20]","The get_cox function in libavcodec/jpeg2000dec.c in FFmpeg before 2.1 does not properly validate the reduction factor, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted JPEG2000 data.",FFmpeg,CVE-2013-7019,CWE-20
4762,179097,"  static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)
  {
      long i;
    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {
     for (i = 0; i <= w - (int)sizeof(long); i += sizeof(long)) {
          long a = *(long *)(src1 + i);
          long b = *(long *)(src2 + i);
          *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);
     }
     for (; i < w; i++)
         dst[i] = src1[i] + src2[i];
 }","[4, 5]",Integer signedness error in the add_bytes_l2_c function in libavcodec/pngdsp.c in FFmpeg before 2.1 allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted PNG data.,FFmpeg,CVE-2013-7014,CWE-189
4774,180649,"  static void tokenadd(struct jv_parser* p, char c) {
    assert(p->tokenpos <= p->tokenlen);
  if (p->tokenpos == p->tokenlen) {
   if (p->tokenpos >= (p->tokenlen - 1)) {
      p->tokenlen = p->tokenlen*2 + 256;
      p->tokenbuf = jv_mem_realloc(p->tokenbuf, p->tokenlen);
    }
   assert(p->tokenpos < p->tokenlen);
   p->tokenbuf[p->tokenpos++] = c;
 }","[3, 4]","Off-by-one error in the tokenadd function in jv_parse.c in jq allows remote attackers to cause a denial of service (crash) via a long JSON-encoded number, which triggers a heap-based buffer overflow.",jq,CVE-2015-8863,CWE-119
4786,178687," dispatch_cmd(conn c)
 {
     int r, i, timeout = -1;
     size_t z;
     unsigned int count;
     job j;
     unsigned char type;
     char *size_buf, *delay_buf, *ttr_buf, *pri_buf, *end_buf, *name;
     unsigned int pri, body_size;
     usec delay, ttr;
     uint64_t id;
     tube t = NULL;
     c->cmd[c->cmd_len - 2] = '\0';
     if (strlen(c->cmd) != c->cmd_len - 2) {
         return reply_msg(c, MSG_BAD_FORMAT);
     }
     type = which_cmd(c);
     dprintf(""got %s command: \""%s\""\n"", op_names[(int) type], c->cmd);
     switch (type) {
     case OP_PUT:
         r = read_pri(&pri, c->cmd + 4, &delay_buf);
         if (r) return reply_msg(c, MSG_BAD_FORMAT);
         r = read_delay(&delay, delay_buf, &ttr_buf);
         if (r) return reply_msg(c, MSG_BAD_FORMAT);
         r = read_ttr(&ttr, ttr_buf, &size_buf);
         if (r) return reply_msg(c, MSG_BAD_FORMAT);
         errno = 0;
         body_size = strtoul(size_buf, &end_buf, 10);
          if (errno) return reply_msg(c, MSG_BAD_FORMAT);
          if (body_size > job_data_size_limit) {
            return reply_msg(c, MSG_JOB_TOO_BIG);
             return skip(c, body_size + 2, MSG_JOB_TOO_BIG);
          }
         if (end_buf[0] != '\0') return reply_msg(c, MSG_BAD_FORMAT);
         conn_set_producer(c);
         c->in_job = make_job(pri, delay, ttr ? : 1, body_size + 2, c->use);
         if (!c->in_job) {
             twarnx(""server error: "" MSG_OUT_OF_MEMORY);
             return skip(c, body_size + 2, MSG_OUT_OF_MEMORY);
         }
         fill_extra_data(c);
         maybe_enqueue_incoming_job(c);
         break;
     case OP_PEEK_READY:
         if (c->cmd_len != CMD_PEEK_READY_LEN + 2) {
             return reply_msg(c, MSG_BAD_FORMAT);
         }
         op_ct[type]++;
         j = job_copy(pq_peek(&c->use->ready));
         if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD);
         reply_job(c, j, MSG_FOUND);
         break;
     case OP_PEEK_DELAYED:
         if (c->cmd_len != CMD_PEEK_DELAYED_LEN + 2) {
             return reply_msg(c, MSG_BAD_FORMAT);
         }
         op_ct[type]++;
         j = job_copy(pq_peek(&c->use->delay));
         if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD);
         reply_job(c, j, MSG_FOUND);
         break;
     case OP_PEEK_BURIED:
         if (c->cmd_len != CMD_PEEK_BURIED_LEN + 2) {
             return reply_msg(c, MSG_BAD_FORMAT);
         }
         op_ct[type]++;
         j = job_copy(buried_job_p(c->use)? j = c->use->buried.next : NULL);
         if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD);
         reply_job(c, j, MSG_FOUND);
         break;
     case OP_PEEKJOB:
         errno = 0;
         id = strtoull(c->cmd + CMD_PEEKJOB_LEN, &end_buf, 10);
         if (errno) return reply_msg(c, MSG_BAD_FORMAT);
         op_ct[type]++;
         j = job_copy(peek_job(id));
         if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD);
         reply_job(c, j, MSG_FOUND);
         break;
     case OP_RESERVE_TIMEOUT:
         errno = 0;
         timeout = strtol(c->cmd + CMD_RESERVE_TIMEOUT_LEN, &end_buf, 10);
         if (errno) return reply_msg(c, MSG_BAD_FORMAT);
     case OP_RESERVE:  
         if (type == OP_RESERVE && c->cmd_len != CMD_RESERVE_LEN + 2) {
             return reply_msg(c, MSG_BAD_FORMAT);
         }
         op_ct[type]++;
         conn_set_worker(c);
         if (conn_has_close_deadline(c) && !conn_ready(c)) {
             return reply_msg(c, MSG_DEADLINE_SOON);
         }
         wait_for_job(c, timeout);
         process_queue();
         break;
     case OP_DELETE:
         errno = 0;
         id = strtoull(c->cmd + CMD_DELETE_LEN, &end_buf, 10);
         if (errno) return reply_msg(c, MSG_BAD_FORMAT);
         op_ct[type]++;
         j = job_find(id);
         j = remove_reserved_job(c, j) ? :
             remove_ready_job(j) ? :
             remove_buried_job(j);
         if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD);
         j->state = JOB_STATE_INVALID;
         r = binlog_write_job(j);
         job_free(j);
         if (!r) return reply_serr(c, MSG_INTERNAL_ERROR);
         reply(c, MSG_DELETED, MSG_DELETED_LEN, STATE_SENDWORD);
         break;
     case OP_RELEASE:
         errno = 0;
         id = strtoull(c->cmd + CMD_RELEASE_LEN, &pri_buf, 10);
         if (errno) return reply_msg(c, MSG_BAD_FORMAT);
         r = read_pri(&pri, pri_buf, &delay_buf);
         if (r) return reply_msg(c, MSG_BAD_FORMAT);
         r = read_delay(&delay, delay_buf, NULL);
         if (r) return reply_msg(c, MSG_BAD_FORMAT);
         op_ct[type]++;
         j = remove_reserved_job(c, job_find(id));
         if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD);
         if (delay) {
             z = binlog_reserve_space_update(j);
             if (!z) return reply_serr(c, MSG_OUT_OF_MEMORY);
             j->reserved_binlog_space += z;
         }
         j->pri = pri;
         j->delay = delay;
         j->release_ct++;
         r = enqueue_job(j, delay, !!delay);
         if (r < 0) return reply_serr(c, MSG_INTERNAL_ERROR);
         if (r == 1) {
             return reply(c, MSG_RELEASED, MSG_RELEASED_LEN, STATE_SENDWORD);
         }
         bury_job(j, 0);
         reply(c, MSG_BURIED, MSG_BURIED_LEN, STATE_SENDWORD);
         break;
     case OP_BURY:
         errno = 0;
         id = strtoull(c->cmd + CMD_BURY_LEN, &pri_buf, 10);
         if (errno) return reply_msg(c, MSG_BAD_FORMAT);
         r = read_pri(&pri, pri_buf, NULL);
         if (r) return reply_msg(c, MSG_BAD_FORMAT);
         op_ct[type]++;
         j = remove_reserved_job(c, job_find(id));
         if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD);
         j->pri = pri;
         r = bury_job(j, 1);
         if (!r) return reply_serr(c, MSG_INTERNAL_ERROR);
         reply(c, MSG_BURIED, MSG_BURIED_LEN, STATE_SENDWORD);
         break;
     case OP_KICK:
         errno = 0;
         count = strtoul(c->cmd + CMD_KICK_LEN, &end_buf, 10);
         if (end_buf == c->cmd + CMD_KICK_LEN) {
             return reply_msg(c, MSG_BAD_FORMAT);
         }
         if (errno) return reply_msg(c, MSG_BAD_FORMAT);
         op_ct[type]++;
         i = kick_jobs(c->use, count);
         return reply_line(c, STATE_SENDWORD, ""KICKED %u\r\n"", i);
     case OP_TOUCH:
         errno = 0;
         id = strtoull(c->cmd + CMD_TOUCH_LEN, &end_buf, 10);
         if (errno) return twarn(""strtoull""), reply_msg(c, MSG_BAD_FORMAT);
         op_ct[type]++;
         j = touch_job(c, job_find(id));
         if (j) {
             reply(c, MSG_TOUCHED, MSG_TOUCHED_LEN, STATE_SENDWORD);
         } else {
             return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD);
         }
         break;
     case OP_STATS:
         if (c->cmd_len != CMD_STATS_LEN + 2) {
             return reply_msg(c, MSG_BAD_FORMAT);
         }
         op_ct[type]++;
         do_stats(c, fmt_stats, NULL);
         break;
     case OP_JOBSTATS:
         errno = 0;
         id = strtoull(c->cmd + CMD_JOBSTATS_LEN, &end_buf, 10);
         if (errno) return reply_msg(c, MSG_BAD_FORMAT);
         op_ct[type]++;
         j = peek_job(id);
         if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD);
         if (!j->tube) return reply_serr(c, MSG_INTERNAL_ERROR);
         do_stats(c, (fmt_fn) fmt_job_stats, j);
         break;
     case OP_STATS_TUBE:
         name = c->cmd + CMD_STATS_TUBE_LEN;
         if (!name_is_ok(name, 200)) return reply_msg(c, MSG_BAD_FORMAT);
         op_ct[type]++;
         t = tube_find(name);
         if (!t) return reply_msg(c, MSG_NOTFOUND);
         do_stats(c, (fmt_fn) fmt_stats_tube, t);
         t = NULL;
         break;
     case OP_LIST_TUBES:
         if (c->cmd_len != CMD_LIST_TUBES_LEN + 2) {
             return reply_msg(c, MSG_BAD_FORMAT);
         }
         op_ct[type]++;
         do_list_tubes(c, &tubes);
         break;
     case OP_LIST_TUBE_USED:
         if (c->cmd_len != CMD_LIST_TUBE_USED_LEN + 2) {
             return reply_msg(c, MSG_BAD_FORMAT);
         }
         op_ct[type]++;
         reply_line(c, STATE_SENDWORD, ""USING %s\r\n"", c->use->name);
         break;
     case OP_LIST_TUBES_WATCHED:
         if (c->cmd_len != CMD_LIST_TUBES_WATCHED_LEN + 2) {
             return reply_msg(c, MSG_BAD_FORMAT);
         }
         op_ct[type]++;
         do_list_tubes(c, &c->watch);
         break;
     case OP_USE:
         name = c->cmd + CMD_USE_LEN;
         if (!name_is_ok(name, 200)) return reply_msg(c, MSG_BAD_FORMAT);
         op_ct[type]++;
         TUBE_ASSIGN(t, tube_find_or_make(name));
         if (!t) return reply_serr(c, MSG_OUT_OF_MEMORY);
         c->use->using_ct--;
         TUBE_ASSIGN(c->use, t);
         TUBE_ASSIGN(t, NULL);
         c->use->using_ct++;
         reply_line(c, STATE_SENDWORD, ""USING %s\r\n"", c->use->name);
         break;
     case OP_WATCH:
         name = c->cmd + CMD_WATCH_LEN;
         if (!name_is_ok(name, 200)) return reply_msg(c, MSG_BAD_FORMAT);
         op_ct[type]++;
         TUBE_ASSIGN(t, tube_find_or_make(name));
         if (!t) return reply_serr(c, MSG_OUT_OF_MEMORY);
         r = 1;
         if (!ms_contains(&c->watch, t)) r = ms_append(&c->watch, t);
         TUBE_ASSIGN(t, NULL);
         if (!r) return reply_serr(c, MSG_OUT_OF_MEMORY);
         reply_line(c, STATE_SENDWORD, ""WATCHING %d\r\n"", c->watch.used);
         break;
     case OP_IGNORE:
         name = c->cmd + CMD_IGNORE_LEN;
         if (!name_is_ok(name, 200)) return reply_msg(c, MSG_BAD_FORMAT);
         op_ct[type]++;
         t = NULL;
         for (i = 0; i < c->watch.used; i++) {
             t = c->watch.items[i];
             if (strncmp(t->name, name, MAX_TUBE_NAME_LEN) == 0) break;
             t = NULL;
         }
         if (t && c->watch.used < 2) return reply_msg(c, MSG_NOT_IGNORED);
         if (t) ms_remove(&c->watch, t);  
         t = NULL;
         reply_line(c, STATE_SENDWORD, ""WATCHING %d\r\n"", c->watch.used);
         break;
     case OP_QUIT:
         conn_close(c);
         break;
     case OP_PAUSE_TUBE:
         op_ct[type]++;
         r = read_tube_name(&name, c->cmd + CMD_PAUSE_TUBE_LEN, &delay_buf);
         if (r) return reply_msg(c, MSG_BAD_FORMAT);
         r = read_delay(&delay, delay_buf, NULL);
         if (r) return reply_msg(c, MSG_BAD_FORMAT);
         *delay_buf = '\0';
         t = tube_find(name);
         if (!t) return reply_msg(c, MSG_NOTFOUND);
         t->deadline_at = now_usec() + delay;
         t->pause = delay;
         t->stat.pause_ct++;
         set_main_delay_timeout();
         reply_line(c, STATE_SENDWORD, ""PAUSED\r\n"");
         break;
     default:
         return reply_msg(c, MSG_UNKNOWN_COMMAND);
     }
 }","[31, 32]","The put command functionality in beanstalkd 1.4.5 and earlier allows remote attackers to execute arbitrary Beanstalk commands via the body in a job that is too big, which is not properly handled by the dispatch_cmd function in prot.c.",beanstalkd,CVE-2010-2060,
4788,182959," int mp4client_main(int argc, char **argv)
 {
 	char c;
 	const char *str;
 	int ret_val = 0;
 	u32 i, times[100], nb_times, dump_mode;
 	u32 simulation_time_in_ms = 0;
 	u32 initial_service_id = 0;
 	Bool auto_exit = GF_FALSE;
 	Bool logs_set = GF_FALSE;
 	Bool start_fs = GF_FALSE;
 	Bool use_rtix = GF_FALSE;
 	Bool pause_at_first = GF_FALSE;
 	Bool no_cfg_save = GF_FALSE;
 	Bool is_cfg_only = GF_FALSE;
 	Double play_from = 0;
 #ifdef GPAC_MEMORY_TRACKING
     GF_MemTrackerType mem_track = GF_MemTrackerNone;
 #endif
 	Double fps = GF_IMPORT_DEFAULT_FPS;
 	Bool fill_ar, visible, do_uncache, has_command;
 	char *url_arg, *out_arg, *the_cfg, *rti_file, *views, *mosaic;
 	FILE *logfile = NULL;
 	Float scale = 1;
 #ifndef WIN32
 	dlopen(NULL, RTLD_NOW|RTLD_GLOBAL);
 #endif
 	strcpy(the_url, ""."");
 	memset(&user, 0, sizeof(GF_User));
 	dump_mode = DUMP_NONE;
 	fill_ar = visible = do_uncache = has_command = GF_FALSE;
 	url_arg = out_arg = the_cfg = rti_file = views = mosaic = NULL;
 	nb_times = 0;
 	times[0] = 0;
 	for (i=1; i<(u32) argc; i++) {
 		char *arg = argv[i];
 		if (!strcmp(arg, ""-c"") || !strcmp(arg, ""-cfg"")) {
 			the_cfg = argv[i+1];
 			i++;
 		}
 		else if (!strcmp(arg, ""-mem-track"") || !strcmp(arg, ""-mem-track-stack"")) {
 #ifdef GPAC_MEMORY_TRACKING
             mem_track = !strcmp(arg, ""-mem-track-stack"") ? GF_MemTrackerBackTrace : GF_MemTrackerSimple;
 #else
 			fprintf(stderr, ""WARNING - GPAC not compiled with Memory Tracker - ignoring \""%s\""\n"", arg);
 #endif
 		} else if (!strcmp(arg, ""-gui"")) {
 			gui_mode = 1;
 		} else if (!strcmp(arg, ""-guid"")) {
 			gui_mode = 2;
 		} else if (!strcmp(arg, ""-h"") || !strcmp(arg, ""-help"")) {
 			PrintUsage();
 			return 0;
 		}
 	}
 #ifdef GPAC_MEMORY_TRACKING
 	gf_sys_init(mem_track);
 #else
 	gf_sys_init(GF_MemTrackerNone);
 #endif
 	gf_sys_set_args(argc, (const char **) argv);
 	cfg_file = gf_cfg_init(the_cfg, NULL);
 	if (!cfg_file) {
 		fprintf(stderr, ""Error: Configuration File not found\n"");
 		return 1;
 	}
 	if (gf_log_set_tools_levels( gf_cfg_get_key(cfg_file, ""General"", ""Logs"") ) != GF_OK) {
 		return 1;
 	}
 	if( gf_cfg_get_key(cfg_file, ""General"", ""Logs"") != NULL ) {
 		logs_set = GF_TRUE;
 	}
 	if (!gui_mode) {
 		str = gf_cfg_get_key(cfg_file, ""General"", ""ForceGUI"");
 		if (str && !strcmp(str, ""yes"")) gui_mode = 1;
 	}
 	for (i=1; i<(u32) argc; i++) {
 		char *arg = argv[i];
 		if (!strcmp(arg, ""-rti"")) {
 			rti_file = argv[i+1];
 			i++;
 		} else if (!strcmp(arg, ""-rtix"")) {
 			rti_file = argv[i+1];
 			i++;
 			use_rtix = GF_TRUE;
 		} else if (!stricmp(arg, ""-size"")) {
 			if (sscanf(argv[i+1], ""%dx%d"", &forced_width, &forced_height) != 2) {
 				forced_width = forced_height = 0;
 			}
 			i++;
 		} else if (!strcmp(arg, ""-quiet"")) {
 			be_quiet = 1;
 		} else if (!strcmp(arg, ""-strict-error"")) {
 			gf_log_set_strict_error(1);
 		} else if (!strcmp(arg, ""-log-file"") || !strcmp(arg, ""-lf"")) {
 			logfile = gf_fopen(argv[i+1], ""wt"");
 			gf_log_set_callback(logfile, on_gpac_log);
 			i++;
 		} else if (!strcmp(arg, ""-logs"") ) {
 			if (gf_log_set_tools_levels(argv[i+1]) != GF_OK) {
 				return 1;
 			}
 			logs_set = GF_TRUE;
 			i++;
 		} else if (!strcmp(arg, ""-log-clock"") || !strcmp(arg, ""-lc"")) {
 			log_time_start = 1;
 		} else if (!strcmp(arg, ""-log-utc"") || !strcmp(arg, ""-lu"")) {
 			log_utc_time = 1;
 		}
 #if defined(__DARWIN__) || defined(__APPLE__)
 		else if (!strcmp(arg, ""-thread"")) threading_flags = 0;
 #else
 		else if (!strcmp(arg, ""-no-thread"")) threading_flags = GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_WINDOW_NO_THREAD;
 #endif
 		else if (!strcmp(arg, ""-no-cthread"") || !strcmp(arg, ""-no-compositor-thread"")) threading_flags |= GF_TERM_NO_COMPOSITOR_THREAD;
 		else if (!strcmp(arg, ""-no-audio"")) no_audio = 1;
 		else if (!strcmp(arg, ""-no-regulation"")) no_regulation = 1;
 		else if (!strcmp(arg, ""-fs"")) start_fs = 1;
 		else if (!strcmp(arg, ""-opt"")) {
 			set_cfg_option(argv[i+1]);
 			i++;
 		} else if (!strcmp(arg, ""-conf"")) {
 			set_cfg_option(argv[i+1]);
 			is_cfg_only=GF_TRUE;
 			i++;
 		}
 		else if (!strcmp(arg, ""-ifce"")) {
 			gf_cfg_set_key(cfg_file, ""Network"", ""DefaultMCastInterface"", argv[i+1]);
 			i++;
 		}
 		else if (!stricmp(arg, ""-help"")) {
 			PrintUsage();
 			return 1;
 		}
 		else if (!stricmp(arg, ""-noprog"")) {
 			no_prog=1;
 			gf_set_progress_callback(NULL, progress_quiet);
 		}
 		else if (!stricmp(arg, ""-no-save"") || !stricmp(arg, ""--no-save"")  ) {
 			no_cfg_save=1;
 		}
 		else if (!stricmp(arg, ""-ntp-shift"")) {
 			s32 shift = atoi(argv[i+1]);
 			i++;
 			gf_net_set_ntp_shift(shift);
 		}
 		else if (!stricmp(arg, ""-run-for"")) {
 			simulation_time_in_ms = atoi(argv[i+1]) * 1000;
 			if (!simulation_time_in_ms)
 				simulation_time_in_ms = 1;  
 			i++;
 		}
 		else if (!strcmp(arg, ""-out"")) {
 			out_arg = argv[i+1];
 			i++;
 		}
 		else if (!stricmp(arg, ""-fps"")) {
 			fps = atof(argv[i+1]);
 			i++;
 		} else if (!strcmp(arg, ""-avi"") || !strcmp(arg, ""-sha"")) {
 			dump_mode &= 0xFFFF0000;
 			if (!strcmp(arg, ""-sha"")) dump_mode |= DUMP_SHA1;
 			else dump_mode |= DUMP_AVI;
 			if ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) {
 				if (!strcmp(arg, ""-avi"") && (nb_times!=2) ) {
 					fprintf(stderr, ""Only one time arg found for -avi - check usage\n"");
 					return 1;
 				}
 				i++;
 			}
 		} else if (!strcmp(arg, ""-rgbds"")) {  
 				dump_mode |= DUMP_RGB_DEPTH_SHAPE;
 		} else if (!strcmp(arg, ""-rgbd"")) {  
 				dump_mode |= DUMP_RGB_DEPTH;
 		} else if (!strcmp(arg, ""-depth"")) {
 				dump_mode |= DUMP_DEPTH_ONLY;
 		} else if (!strcmp(arg, ""-bmp"")) {
 			dump_mode &= 0xFFFF0000;
 			dump_mode |= DUMP_BMP;
 			if ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;
 		} else if (!strcmp(arg, ""-png"")) {
 			dump_mode &= 0xFFFF0000;
 			dump_mode |= DUMP_PNG;
 			if ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;
 		} else if (!strcmp(arg, ""-raw"")) {
 			dump_mode &= 0xFFFF0000;
 			dump_mode |= DUMP_RAW;
 			if ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;
 		} else if (!stricmp(arg, ""-scale"")) {
 			sscanf(argv[i+1], ""%f"", &scale);
 			i++;
 		}
 		else if (!strcmp(arg, ""-c"") || !strcmp(arg, ""-cfg"")) {
 			i++;
 		}
 		if (!gui_mode) {
 			if (arg[0] != '-') {
 				if (url_arg) {
 					fprintf(stderr, ""Several input URLs provided (\""%s\"", \""%s\""). Check your command-line.\n"", url_arg, arg);
 					return 1;
 				}
 				url_arg = arg;
 			}
 			else if (!strcmp(arg, ""-loop"")) loop_at_end = 1;
 			else if (!strcmp(arg, ""-bench"")) bench_mode = 1;
 			else if (!strcmp(arg, ""-vbench"")) bench_mode = 2;
 			else if (!strcmp(arg, ""-sbench"")) bench_mode = 3;
 			else if (!strcmp(arg, ""-no-addon"")) enable_add_ons = GF_FALSE;
 			else if (!strcmp(arg, ""-pause"")) pause_at_first = 1;
 			else if (!strcmp(arg, ""-play-from"")) {
 				play_from = atof((const char *) argv[i+1]);
 				i++;
 			}
 			else if (!strcmp(arg, ""-speed"")) {
 				playback_speed = FLT2FIX( atof((const char *) argv[i+1]) );
 				if (playback_speed <= 0) playback_speed = FIX_ONE;
 				i++;
 			}
 			else if (!strcmp(arg, ""-no-wnd"")) user.init_flags |= GF_TERM_WINDOWLESS;
 			else if (!strcmp(arg, ""-no-back"")) user.init_flags |= GF_TERM_WINDOW_TRANSPARENT;
 			else if (!strcmp(arg, ""-align"")) {
 				if (argv[i+1][0]=='m') align_mode = 1;
 				else if (argv[i+1][0]=='b') align_mode = 2;
 				align_mode <<= 8;
 				if (argv[i+1][1]=='m') align_mode |= 1;
 				else if (argv[i+1][1]=='r') align_mode |= 2;
 				i++;
 			} else if (!strcmp(arg, ""-fill"")) {
 				fill_ar = GF_TRUE;
 			} else if (!strcmp(arg, ""-show"")) {
 				visible = 1;
 			} else if (!strcmp(arg, ""-uncache"")) {
 				do_uncache = GF_TRUE;
 			}
 			else if (!strcmp(arg, ""-exit"")) auto_exit = GF_TRUE;
 			else if (!stricmp(arg, ""-views"")) {
 				views = argv[i+1];
 				i++;
 			}
 			else if (!stricmp(arg, ""-mosaic"")) {
 				mosaic = argv[i+1];
 				i++;
 			}
 			else if (!stricmp(arg, ""-com"")) {
 				has_command = GF_TRUE;
 				i++;
 			}
 			else if (!stricmp(arg, ""-service"")) {
 				initial_service_id = atoi(argv[i+1]);
 				i++;
 			}
 		}
 	}
 	if (is_cfg_only) {
 		gf_cfg_del(cfg_file);
 		fprintf(stderr, ""GPAC Config updated\n"");
 		return 0;
 	}
 	if (do_uncache) {
 		const char *cache_dir = gf_cfg_get_key(cfg_file, ""General"", ""CacheDirectory"");
 		do_flatten_cache(cache_dir);
 		fprintf(stderr, ""GPAC Cache dir %s flattened\n"", cache_dir);
 		gf_cfg_del(cfg_file);
 		return 0;
 	}
 	if (dump_mode && !url_arg ) {
 		FILE *test;
 		url_arg = (char *)gf_cfg_get_key(cfg_file, ""General"", ""StartupFile"");
 		test = url_arg ? gf_fopen(url_arg, ""rt"") : NULL;
 		if (!test) url_arg = NULL;
 		else gf_fclose(test);
 		if (!url_arg) {
 			fprintf(stderr, ""Missing argument for dump\n"");
 			PrintUsage();
 			if (logfile) gf_fclose(logfile);
 			return 1;
 		}
 	}
 	if (!gui_mode && !url_arg && (gf_cfg_get_key(cfg_file, ""General"", ""StartupFile"") != NULL)) {
 		gui_mode=1;
 	}
 #ifdef WIN32
 	if (gui_mode==1) {
 		const char *opt;
 		TCHAR buffer[1024];
 		DWORD res = GetCurrentDirectory(1024, buffer);
 		buffer[res] = 0;
 		opt = gf_cfg_get_key(cfg_file, ""General"", ""ModulesDirectory"");
 		if (strstr(opt, buffer)) {
 			gui_mode=1;
 		} else {
 			gui_mode=2;
 		}
 	}
 #endif
 	if (gui_mode==1) {
 		hide_shell(1);
 	}
 	if (gui_mode) {
 		no_prog=1;
 		gf_set_progress_callback(NULL, progress_quiet);
 	}
 	if (!url_arg && simulation_time_in_ms)
 		simulation_time_in_ms += gf_sys_clock();
 #if defined(__DARWIN__) || defined(__APPLE__)
 	carbon_init();
 #endif
 	if (dump_mode) rti_file = NULL;
 	if (!logs_set) {
 		gf_log_set_tool_level(GF_LOG_ALL, GF_LOG_WARNING);
 	}
 	if (rti_file || logfile || log_utc_time || log_time_start)
 		gf_log_set_callback(NULL, on_gpac_log);
 	if (rti_file) init_rti_logs(rti_file, url_arg, use_rtix);
 	{
 		GF_SystemRTInfo rti;
 		if (gf_sys_get_rti(0, &rti, 0))
 			fprintf(stderr, ""System info: %d MB RAM - %d cores\n"", (u32) (rti.physical_memory/1024/1024), rti.nb_cores);
 	}
 	if (dump_mode) {
 		user.init_flags |= GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_NO_REGULATION;
 		if (!visible)
 			user.init_flags |= GF_TERM_INIT_HIDE;
 		gf_cfg_set_key(cfg_file, ""Audio"", ""DriverName"", ""Raw Audio Output"");
 		no_cfg_save=GF_TRUE;
 	} else {
 		init_w = forced_width;
 		init_h = forced_height;
 	}
 	user.modules = gf_modules_new(NULL, cfg_file);
 	if (user.modules) i = gf_modules_get_count(user.modules);
 	if (!i || !user.modules) {
 		fprintf(stderr, ""Error: no modules found - exiting\n"");
 		if (user.modules) gf_modules_del(user.modules);
 		gf_cfg_del(cfg_file);
 		gf_sys_close();
 		if (logfile) gf_fclose(logfile);
 		return 1;
 	}
 	fprintf(stderr, ""Modules Found : %d \n"", i);
 	str = gf_cfg_get_key(cfg_file, ""General"", ""GPACVersion"");
 	if (!str || strcmp(str, GPAC_FULL_VERSION)) {
 		gf_cfg_del_section(cfg_file, ""PluginsCache"");
 		gf_cfg_set_key(cfg_file, ""General"", ""GPACVersion"", GPAC_FULL_VERSION);
 	}
 	user.config = cfg_file;
 	user.EventProc = GPAC_EventProc;
 	user.opaque = user.modules;
 	if (threading_flags) user.init_flags |= threading_flags;
 	if (no_audio) user.init_flags |= GF_TERM_NO_AUDIO;
 	if (no_regulation) user.init_flags |= GF_TERM_NO_REGULATION;
 	if (threading_flags & (GF_TERM_NO_DECODER_THREAD|GF_TERM_NO_COMPOSITOR_THREAD) ) term_step = GF_TRUE;
 	if (dump_mode) user.init_flags |= GF_TERM_USE_AUDIO_HW_CLOCK;
 	if (bench_mode) {
 		gf_cfg_discard_changes(user.config);
 		auto_exit = GF_TRUE;
 		gf_cfg_set_key(user.config, ""Audio"", ""DriverName"", ""Raw Audio Output"");
 		if (bench_mode!=2) {
 			gf_cfg_set_key(user.config, ""Video"", ""DriverName"", ""Raw Video Output"");
 			gf_cfg_set_key(user.config, ""RAWVideo"", ""RawOutput"", ""null"");
 			gf_cfg_set_key(user.config, ""Compositor"", ""OpenGLMode"", ""disable"");
 		} else {
 			gf_cfg_set_key(user.config, ""Video"", ""DisableVSync"", ""yes"");
 		}
 	}
 	{
 		char dim[50];
 		sprintf(dim, ""%d"", forced_width);
 		gf_cfg_set_key(user.config, ""Compositor"", ""DefaultWidth"", forced_width ? dim : NULL);
 		sprintf(dim, ""%d"", forced_height);
 		gf_cfg_set_key(user.config, ""Compositor"", ""DefaultHeight"", forced_height ? dim : NULL);
 	}
 	fprintf(stderr, ""Loading GPAC Terminal\n"");
 	i = gf_sys_clock();
 	term = gf_term_new(&user);
 	if (!term) {
 		fprintf(stderr, ""\nInit error - check you have at least one video out and one rasterizer...\nFound modules:\n"");
 		list_modules(user.modules);
 		gf_modules_del(user.modules);
 		gf_cfg_discard_changes(cfg_file);
 		gf_cfg_del(cfg_file);
 		gf_sys_close();
 		if (logfile) gf_fclose(logfile);
 		return 1;
 	}
 	fprintf(stderr, ""Terminal Loaded in %d ms\n"", gf_sys_clock()-i);
 	if (bench_mode) {
 		display_rti = 2;
 		gf_term_set_option(term, GF_OPT_VIDEO_BENCH, (bench_mode==3) ? 2 : 1);
 		if (bench_mode==1) bench_mode=2;
 	}
 	if (dump_mode) {
 		if (fill_ar) gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);
 	} else {
 		str = gf_cfg_get_key(cfg_file, ""Video"", ""DriverName"");
 		if (!bench_mode && !strcmp(str, ""Raw Video Output"")) fprintf(stderr, ""WARNING: using raw output video (memory only) - no display used\n"");
 		str = gf_cfg_get_key(cfg_file, ""Audio"", ""DriverName"");
 		if (!str || !strcmp(str, ""No Audio Output Available"")) fprintf(stderr, ""WARNING: no audio output available - make sure no other program is locking the sound card\n"");
 		str = gf_cfg_get_key(cfg_file, ""General"", ""NoMIMETypeFetch"");
 		no_mime_check = (str && !stricmp(str, ""yes"")) ? 1 : 0;
 	}
 	str = gf_cfg_get_key(cfg_file, ""HTTPProxy"", ""Enabled"");
 	if (str && !strcmp(str, ""yes"")) {
 		str = gf_cfg_get_key(cfg_file, ""HTTPProxy"", ""Name"");
 		if (str) fprintf(stderr, ""HTTP Proxy %s enabled\n"", str);
 	}
 	if (rti_file) {
 		str = gf_cfg_get_key(cfg_file, ""General"", ""RTIRefreshPeriod"");
 		if (str) {
 			rti_update_time_ms = atoi(str);
 		} else {
 			gf_cfg_set_key(cfg_file, ""General"", ""RTIRefreshPeriod"", ""200"");
 		}
 		UpdateRTInfo(""At GPAC load time\n"");
 	}
 	Run = 1;
 	if (dump_mode) {
 		if (!nb_times) {
 			times[0] = 0;
 			nb_times++;
 		}
 		ret_val = dump_file(url_arg, out_arg, dump_mode, fps, forced_width, forced_height, scale, times, nb_times);
 		Run = 0;
 	}
 	else if (views) {
 	}
 	else if (!gui_mode && url_arg) {
 		char *ext;
 		if (strlen(url_arg) >= sizeof(the_url)) {
 			fprintf(stderr, ""Input url %s is too long, truncating to %d chars.\n"", url_arg, (int)(sizeof(the_url) - 1));
 			strncpy(the_url, url_arg, sizeof(the_url)-1);
 			the_url[sizeof(the_url) - 1] = 0;
 		}
 		else {
 			strcpy(the_url, url_arg);
 		}
 		ext = strrchr(the_url, '.');
 		if (ext && (!stricmp(ext, "".m3u"") || !stricmp(ext, "".pls""))) {
 			GF_Err e = GF_OK;
 			fprintf(stderr, ""Opening Playlist %s\n"", the_url);
 			strcpy(pl_path, the_url);
 			if (!strncmp(""http:"", the_url, 5)) {
 				GF_DownloadSession *sess = gf_dm_sess_new(term->downloader, the_url, GF_NETIO_SESSION_NOT_THREADED, NULL, NULL, &e);
 				if (sess) {
  					e = gf_dm_sess_process(sess);
  					if (!e) {
  						strncpy(the_url, gf_dm_sess_get_cache_name(sess), sizeof(the_url) - 1);
						the_url[sizeof(the_cfg) - 1] = 0;
 						the_url[sizeof(the_url) - 1] = 0;
  					}
  					gf_dm_sess_del(sess);
  				}
 			}
 			playlist = e ? NULL : gf_fopen(the_url, ""rt"");
 			readonly_playlist = 1;
 			if (playlist) {
 				request_next_playlist_item = GF_TRUE;
 			} else {
 				if (e)
 					fprintf(stderr, ""Failed to open playlist %s: %s\n"", the_url, gf_error_to_string(e) );
 				fprintf(stderr, ""Hit 'h' for help\n\n"");
 			}
 		} else {
 			fprintf(stderr, ""Opening URL %s\n"", the_url);
 			if (pause_at_first) fprintf(stderr, ""[Status: Paused]\n"");
 			gf_term_connect_from_time(term, the_url, (u64) (play_from*1000), pause_at_first);
 		}
 	} else {
 		fprintf(stderr, ""Hit 'h' for help\n\n"");
 		str = gf_cfg_get_key(cfg_file, ""General"", ""StartupFile"");
 		if (str) {
 			strncpy(the_url, ""MP4Client ""GPAC_FULL_VERSION , sizeof(the_url)-1);
 			the_url[sizeof(the_url) - 1] = 0;
 			gf_term_connect(term, str);
 			startup_file = 1;
 			is_connected = 1;
 		}
 	}
 	if (gui_mode==2) gui_mode=0;
 	if (start_fs) gf_term_set_option(term, GF_OPT_FULLSCREEN, 1);
 	if (views) {
 		char szTemp[4046];
 		sprintf(szTemp, ""views:%s"", views);
 		gf_term_connect(term, szTemp);
 	}
 	if (mosaic) {
 		char szTemp[4046];
 		sprintf(szTemp, ""mosaic:%s"", mosaic);
 		gf_term_connect(term, szTemp);
 	}
 	if (bench_mode) {
 		rti_update_time_ms = 500;
 		bench_mode_start = gf_sys_clock();
 	}
 	while (Run) {
 		if ((gui_mode==1) || !gf_prompt_has_input()) {
 			if (reload) {
 				reload = 0;
 				gf_term_disconnect(term);
 				gf_term_connect(term, startup_file ? gf_cfg_get_key(cfg_file, ""General"", ""StartupFile"") : the_url);
 			}
 			if (restart && gf_term_get_option(term, GF_OPT_IS_OVER)) {
 				restart = 0;
 				gf_term_play_from_time(term, 0, 0);
 			}
 			if (request_next_playlist_item) {
 				c = '\n';
 				request_next_playlist_item = 0;
 				goto force_input;
 			}
 			if (has_command && is_connected) {
 				has_command = GF_FALSE;
 				for (i=0; i<(u32)argc; i++) {
 					if (!strcmp(argv[i], ""-com"")) {
 						gf_term_scene_update(term, NULL, argv[i+1]);
 						i++;
 					}
 				}
 			}
 			if (initial_service_id && is_connected) {
 				GF_ObjectManager *root_od = gf_term_get_root_object(term);
 				if (root_od) {
 					gf_term_select_service(term, root_od, initial_service_id);
 					initial_service_id = 0;
 				}
 			}
 			if (!use_rtix || display_rti) UpdateRTInfo(NULL);
 			if (term_step) {
 				gf_term_process_step(term);
 			} else {
 				gf_sleep(rti_update_time_ms);
 			}
 			if (auto_exit && eos_seen && gf_term_get_option(term, GF_OPT_IS_OVER)) {
 				Run = GF_FALSE;
 			}
 			if (simulation_time_in_ms
 			        && ( (gf_term_get_elapsed_time_in_ms(term)>simulation_time_in_ms) || (!url_arg && gf_sys_clock()>simulation_time_in_ms))
 			   ) {
 				Run = GF_FALSE;
 			}
 			continue;
 		}
 		c = gf_prompt_get_char();
 force_input:
 		switch (c) {
 		case 'q':
 		{
 			GF_Event evt;
 			memset(&evt, 0, sizeof(GF_Event));
 			evt.type = GF_EVENT_QUIT;
 			gf_term_send_event(term, &evt);
 		}
 		break;
 		case 'X':
 			exit(0);
 			break;
 		case 'Q':
 			break;
 		case 'o':
 			startup_file = 0;
 			gf_term_disconnect(term);
 			fprintf(stderr, ""Enter the absolute URL\n"");
 			if (1 > scanf(""%s"", the_url)) {
 				fprintf(stderr, ""Cannot read absolute URL, aborting\n"");
 				break;
 			}
 			if (rti_file) init_rti_logs(rti_file, the_url, use_rtix);
 			gf_term_connect(term, the_url);
 			break;
 		case 'O':
 			gf_term_disconnect(term);
 			fprintf(stderr, ""Enter the absolute URL to the playlist\n"");
 			if (1 > scanf(""%s"", the_url)) {
 				fprintf(stderr, ""Cannot read the absolute URL, aborting.\n"");
 				break;
 			}
 			playlist = gf_fopen(the_url, ""rt"");
 			if (playlist) {
 				if (1 >	fscanf(playlist, ""%s"", the_url)) {
 					fprintf(stderr, ""Cannot read any URL from playlist, aborting.\n"");
 					gf_fclose( playlist);
 					break;
 				}
 				fprintf(stderr, ""Opening URL %s\n"", the_url);
 				gf_term_connect(term, the_url);
 			}
 			break;
 		case '\n':
 		case 'N':
 			if (playlist) {
 				int res;
 				gf_term_disconnect(term);
 				res = fscanf(playlist, ""%s"", the_url);
 				if ((res == EOF) && loop_at_end) {
 					fseek(playlist, 0, SEEK_SET);
 					res = fscanf(playlist, ""%s"", the_url);
 				}
 				if (res == EOF) {
 					fprintf(stderr, ""No more items - exiting\n"");
 					Run = 0;
 				} else if (the_url[0] == '#') {
 					request_next_playlist_item = GF_TRUE;
 				} else {
 					fprintf(stderr, ""Opening URL %s\n"", the_url);
 					gf_term_connect_with_path(term, the_url, pl_path);
 				}
 			}
 			break;
 		case 'P':
 			if (playlist) {
 				u32 count;
 				gf_term_disconnect(term);
 				if (1 > scanf(""%u"", &count)) {
 					fprintf(stderr, ""Cannot read number, aborting.\n"");
 					break;
 				}
 				while (count) {
 					if (fscanf(playlist, ""%s"", the_url)) {
 						fprintf(stderr, ""Failed to read line, aborting\n"");
 						break;
 					}
 					count--;
 				}
 				fprintf(stderr, ""Opening URL %s\n"", the_url);
 				gf_term_connect(term, the_url);
 			}
 			break;
 		case 'r':
 			if (is_connected)
 				reload = 1;
 			break;
 		case 'D':
 			if (is_connected) gf_term_disconnect(term);
 			break;
 		case 'p':
 			if (is_connected) {
 				Bool is_pause = gf_term_get_option(term, GF_OPT_PLAY_STATE);
 				fprintf(stderr, ""[Status: %s]\n"", is_pause ? ""Playing"" : ""Paused"");
 				gf_term_set_option(term, GF_OPT_PLAY_STATE, is_pause ? GF_STATE_PLAYING : GF_STATE_PAUSED);
 			}
 			break;
 		case 's':
 			if (is_connected) {
 				gf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_STEP_PAUSE);
 				fprintf(stderr, ""Step time: "");
 				PrintTime(gf_term_get_time_in_ms(term));
 				fprintf(stderr, ""\n"");
 			}
 			break;
 		case 'z':
 		case 'T':
 			if (!CanSeek || (Duration<=2000)) {
 				fprintf(stderr, ""scene not seekable\n"");
 			} else {
 				Double res;
 				s32 seekTo;
 				fprintf(stderr, ""Duration: "");
 				PrintTime(Duration);
 				res = gf_term_get_time_in_ms(term);
 				if (c=='z') {
 					res *= 100;
 					res /= (s64)Duration;
 					fprintf(stderr, "" (current %.2f %%)\nEnter Seek percentage:\n"", res);
 					if (scanf(""%d"", &seekTo) == 1) {
 						if (seekTo > 100) seekTo = 100;
 						res = (Double)(s64)Duration;
 						res /= 100;
 						res *= seekTo;
 						gf_term_play_from_time(term, (u64) (s64) res, 0);
 					}
 				} else {
 					u32 r, h, m, s;
 					fprintf(stderr, "" - Current Time: "");
 					PrintTime((u64) res);
 					fprintf(stderr, ""\nEnter seek time (Format: s, m:s or h:m:s):\n"");
 					h = m = s = 0;
 					r =scanf(""%d:%d:%d"", &h, &m, &s);
 					if (r==2) {
 						s = m;
 						m = h;
 						h = 0;
 					}
 					else if (r==1) {
 						s = h;
 						m = h = 0;
 					}
 					if (r && (r<=3)) {
 						u64 time = h*3600 + m*60 + s;
 						gf_term_play_from_time(term, time*1000, 0);
 					}
 				}
 			}
 			break;
 		case 't':
 		{
 			if (is_connected) {
 				fprintf(stderr, ""Current Time: "");
 				PrintTime(gf_term_get_time_in_ms(term));
 				fprintf(stderr, "" - Duration: "");
 				PrintTime(Duration);
 				fprintf(stderr, ""\n"");
 			}
 		}
 		break;
 		case 'w':
 			if (is_connected) PrintWorldInfo(term);
 			break;
 		case 'v':
 			if (is_connected) PrintODList(term, NULL, 0, 0, ""Root"");
 			break;
 		case 'i':
 			if (is_connected) {
 				u32 ID;
 				fprintf(stderr, ""Enter OD ID (0 for main OD): "");
 				fflush(stderr);
 				if (scanf(""%ud"", &ID) == 1) {
 					ViewOD(term, ID, (u32)-1, NULL);
 				} else {
 					char str_url[GF_MAX_PATH];
 					if (scanf(""%s"", str_url) == 1)
 						ViewOD(term, 0, (u32)-1, str_url);
 				}
 			}
 			break;
 		case 'j':
 			if (is_connected) {
 				u32 num;
 				do {
 					fprintf(stderr, ""Enter OD number (0 for main OD): "");
 					fflush(stderr);
 				} while( 1 > scanf(""%ud"", &num));
 				ViewOD(term, (u32)-1, num, NULL);
 			}
 			break;
 		case 'b':
 			if (is_connected) ViewODs(term, 1);
 			break;
 		case 'm':
 			if (is_connected) ViewODs(term, 0);
 			break;
 		case 'l':
 			list_modules(user.modules);
 			break;
 		case 'n':
 			if (is_connected) set_navigation();
 			break;
 		case 'x':
 			if (is_connected) gf_term_set_option(term, GF_OPT_NAVIGATION_TYPE, 0);
 			break;
 		case 'd':
 			if (is_connected) {
 				GF_ObjectManager *odm = NULL;
 				char radname[GF_MAX_PATH], *sExt;
 				GF_Err e;
 				u32 i, count, odid;
 				Bool xml_dump, std_out;
 				radname[0] = 0;
 				do {
 					fprintf(stderr, ""Enter Inline OD ID if any or 0 : "");
 					fflush(stderr);
 				} while( 1 >  scanf(""%ud"", &odid));
 				if (odid) {
 					GF_ObjectManager *root_odm = gf_term_get_root_object(term);
 					if (!root_odm) break;
 					count = gf_term_get_object_count(term, root_odm);
 					for (i=0; i<count; i++) {
 						GF_MediaInfo info;
 						odm = gf_term_get_object(term, root_odm, i);
 						if (gf_term_get_object_info(term, odm, &info) == GF_OK) {
 							if (info.od->objectDescriptorID==odid) break;
 						}
 						odm = NULL;
 					}
 				}
 				do {
 					fprintf(stderr, ""Enter file radical name (+\'.x\' for XML dumping) - \""std\"" for stderr: "");
 					fflush(stderr);
 				} while( 1 > scanf(""%s"", radname));
 				sExt = strrchr(radname, '.');
 				xml_dump = 0;
 				if (sExt) {
 					if (!stricmp(sExt, "".x"")) xml_dump = 1;
 					sExt[0] = 0;
 				}
 				std_out = strnicmp(radname, ""std"", 3) ? 0 : 1;
 				e = gf_term_dump_scene(term, std_out ? NULL : radname, NULL, xml_dump, 0, odm);
 				fprintf(stderr, ""Dump done (%s)\n"", gf_error_to_string(e));
 			}
 			break;
 		case 'c':
 			PrintGPACConfig();
 			break;
 		case '3':
 		{
 			Bool use_3d = !gf_term_get_option(term, GF_OPT_USE_OPENGL);
 			if (gf_term_set_option(term, GF_OPT_USE_OPENGL, use_3d)==GF_OK) {
 				fprintf(stderr, ""Using %s for 2D drawing\n"", use_3d ? ""OpenGL"" : ""2D rasterizer"");
 			}
 		}
 		break;
 		case 'k':
 		{
 			Bool opt = gf_term_get_option(term, GF_OPT_STRESS_MODE);
 			opt = !opt;
 			fprintf(stderr, ""Turning stress mode %s\n"", opt ? ""on"" : ""off"");
 			gf_term_set_option(term, GF_OPT_STRESS_MODE, opt);
 		}
 		break;
 		case '4':
 			gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_4_3);
 			break;
 		case '5':
 			gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_16_9);
 			break;
 		case '6':
 			gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);
 			break;
 		case '7':
 			gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_KEEP);
 			break;
 		case 'C':
 			switch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {
 			case GF_MEDIA_CACHE_DISABLED:
 				gf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_ENABLED);
 				break;
 			case GF_MEDIA_CACHE_ENABLED:
 				gf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_DISABLED);
 				break;
 			case GF_MEDIA_CACHE_RUNNING:
 				fprintf(stderr, ""Streaming Cache is running - please stop it first\n"");
 				continue;
 			}
 			switch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {
 			case GF_MEDIA_CACHE_ENABLED:
 				fprintf(stderr, ""Streaming Cache Enabled\n"");
 				break;
 			case GF_MEDIA_CACHE_DISABLED:
 				fprintf(stderr, ""Streaming Cache Disabled\n"");
 				break;
 			case GF_MEDIA_CACHE_RUNNING:
 				fprintf(stderr, ""Streaming Cache Running\n"");
 				break;
 			}
 			break;
 		case 'S':
 		case 'A':
 			if (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)==GF_MEDIA_CACHE_RUNNING) {
 				gf_term_set_option(term, GF_OPT_MEDIA_CACHE, (c=='S') ? GF_MEDIA_CACHE_DISABLED : GF_MEDIA_CACHE_DISCARD);
 				fprintf(stderr, ""Streaming Cache stopped\n"");
 			} else {
 				fprintf(stderr, ""Streaming Cache not running\n"");
 			}
 			break;
 		case 'R':
 			display_rti = !display_rti;
 			ResetCaption();
 			break;
 		case 'F':
 			if (display_rti) display_rti = 0;
 			else display_rti = 2;
 			ResetCaption();
 			break;
 		case 'u':
 		{
 			GF_Err e;
 			char szCom[8192];
 			fprintf(stderr, ""Enter command to send:\n"");
 			fflush(stdin);
 			szCom[0] = 0;
 			if (1 > scanf(""%[^\t\n]"", szCom)) {
 				fprintf(stderr, ""Cannot read command to send, aborting.\n"");
 				break;
 			}
 			e = gf_term_scene_update(term, NULL, szCom);
 			if (e) fprintf(stderr, ""Processing command failed: %s\n"", gf_error_to_string(e));
 		}
 		break;
 		case 'e':
 		{
 			GF_Err e;
 			char jsCode[8192];
 			fprintf(stderr, ""Enter JavaScript code to evaluate:\n"");
 			fflush(stdin);
 			jsCode[0] = 0;
 			if (1 > scanf(""%[^\t\n]"", jsCode)) {
 				fprintf(stderr, ""Cannot read code to evaluate, aborting.\n"");
 				break;
 			}
 			e = gf_term_scene_update(term, ""application/ecmascript"", jsCode);
 			if (e) fprintf(stderr, ""Processing JS code failed: %s\n"", gf_error_to_string(e));
 		}
 		break;
 		case 'L':
 		{
 			char szLog[1024], *cur_logs;
 			cur_logs = gf_log_get_tools_levels();
 			fprintf(stderr, ""Enter new log level (current tools %s):\n"", cur_logs);
 			gf_free(cur_logs);
 			if (scanf(""%s"", szLog) < 1) {
 				fprintf(stderr, ""Cannot read new log level, aborting.\n"");
 				break;
 			}
 			gf_log_modify_tools_levels(szLog);
 		}
 		break;
 		case 'g':
 		{
 			GF_SystemRTInfo rti;
 			gf_sys_get_rti(rti_update_time_ms, &rti, 0);
 			fprintf(stderr, ""GPAC allocated memory ""LLD""\n"", rti.gpac_memory);
 		}
 		break;
 		case 'M':
 		{
 			u32 size;
 			do {
 				fprintf(stderr, ""Enter new video cache memory in kBytes (current %ud):\n"", gf_term_get_option(term, GF_OPT_VIDEO_CACHE_SIZE));
 			} while (1 > scanf(""%ud"", &size));
 			gf_term_set_option(term, GF_OPT_VIDEO_CACHE_SIZE, size);
 		}
 		break;
 		case 'H':
 		{
 			u32 http_bitrate = gf_term_get_option(term, GF_OPT_HTTP_MAX_RATE);
 			do {
 				fprintf(stderr, ""Enter new http bitrate in bps (0 for none) - current limit: %d\n"", http_bitrate);
 			} while (1 > scanf(""%ud"", &http_bitrate));
 			gf_term_set_option(term, GF_OPT_HTTP_MAX_RATE, http_bitrate);
 		}
 		break;
 		case 'E':
 			gf_term_set_option(term, GF_OPT_RELOAD_CONFIG, 1);
 			break;
 		case 'B':
 			switch_bench(!bench_mode);
 			break;
 		case 'Y':
 		{
 			char szOpt[8192];
 			fprintf(stderr, ""Enter option to set (Section:Name=Value):\n"");
 			fflush(stdin);
 			szOpt[0] = 0;
 			if (1 > scanf(""%[^\t\n]"", szOpt)) {
 				fprintf(stderr, ""Cannot read option\n"");
 				break;
 			}
 			set_cfg_option(szOpt);
 		}
 		break;
 		case 'Z':
 		{
 			char szFileName[100];
 			u32 nb_pass, nb_views, offscreen_view = 0;
 			GF_VideoSurface fb;
 			GF_Err e;
 			nb_pass = 1;
 			nb_views = gf_term_get_option(term, GF_OPT_NUM_STEREO_VIEWS);
 			if (nb_views>1) {
 				fprintf(stderr, ""Auto-stereo mode detected - type number of view to dump (0 is main output, 1 to %d offscreen view, %d for all offscreen, %d for all offscreen and main)\n"", nb_views, nb_views+1, nb_views+2);
 				if (scanf(""%d"", &offscreen_view) != 1) {
 					offscreen_view = 0;
 				}
 				if (offscreen_view==nb_views+1) {
 					offscreen_view = 1;
 					nb_pass = nb_views;
 				}
 				else if (offscreen_view==nb_views+2) {
 					offscreen_view = 0;
 					nb_pass = nb_views+1;
 				}
 			}
 			while (nb_pass) {
 				nb_pass--;
 				if (offscreen_view) {
 					sprintf(szFileName, ""view%d_dump.png"", offscreen_view);
 					e = gf_term_get_offscreen_buffer(term, &fb, offscreen_view-1, 0);
 				} else {
 					sprintf(szFileName, ""gpac_video_dump_""LLU"".png"", gf_net_get_utc() );
 					e = gf_term_get_screen_buffer(term, &fb);
 				}
 				offscreen_view++;
 				if (e) {
 					fprintf(stderr, ""Error dumping screen buffer %s\n"", gf_error_to_string(e) );
 					nb_pass = 0;
 				} else {
 #ifndef GPAC_DISABLE_AV_PARSERS
 					u32 dst_size = fb.width*fb.height*4;
 					char *dst = (char*)gf_malloc(sizeof(char)*dst_size);
 					e = gf_img_png_enc(fb.video_buffer, fb.width, fb.height, fb.pitch_y, fb.pixel_format, dst, &dst_size);
 					if (e) {
 						fprintf(stderr, ""Error encoding PNG %s\n"", gf_error_to_string(e) );
 						nb_pass = 0;
 					} else {
 						FILE *png = gf_fopen(szFileName, ""wb"");
 						if (!png) {
 							fprintf(stderr, ""Error writing file %s\n"", szFileName);
 							nb_pass = 0;
 						} else {
 							gf_fwrite(dst, dst_size, 1, png);
 							gf_fclose(png);
 							fprintf(stderr, ""Dump to %s\n"", szFileName);
 						}
 					}
 					if (dst) gf_free(dst);
 					gf_term_release_screen_buffer(term, &fb);
 #endif  
 				}
 			}
 			fprintf(stderr, ""Done: %s\n"", szFileName);
 		}
 		break;
 		case 'G':
 		{
 			GF_ObjectManager *root_od, *odm;
 			u32 index;
 			char szOpt[8192];
 			fprintf(stderr, ""Enter 0-based index of object to select or service ID:\n"");
 			fflush(stdin);
 			szOpt[0] = 0;
 			if (1 > scanf(""%[^\t\n]"", szOpt)) {
 				fprintf(stderr, ""Cannot read OD ID\n"");
 				break;
 			}
 			index = atoi(szOpt);
 			odm = NULL;
 			root_od = gf_term_get_root_object(term);
 			if (root_od) {
 				if ( gf_term_find_service(term, root_od, index)) {
 					gf_term_select_service(term, root_od, index);
 				} else {
 					fprintf(stderr, ""Cannot find service %d - trying with object index\n"", index);
 					odm = gf_term_get_object(term, root_od, index);
 					if (odm) {
 						gf_term_select_object(term, odm);
 					} else {
 						fprintf(stderr, ""Cannot find object at index %d\n"", index);
 					}
 				}
 			}
 		}
 		break;
 		case 'h':
 			PrintHelp();
 			break;
 		default:
 			break;
 		}
 	}
 	if (bench_mode) {
 		PrintAVInfo(GF_TRUE);
 	}
 	if (simulation_time_in_ms) {
 		gf_log_set_strict_error(0);
 	}
 	i = gf_sys_clock();
 	gf_term_disconnect(term);
 	if (rti_file) UpdateRTInfo(""Disconnected\n"");
 	fprintf(stderr, ""Deleting terminal... "");
 	if (playlist) gf_fclose(playlist);
 #if defined(__DARWIN__) || defined(__APPLE__)
 	carbon_uninit();
 #endif
 	gf_term_del(term);
 	fprintf(stderr, ""done (in %d ms) - ran for %d ms\n"", gf_sys_clock() - i, gf_sys_clock());
 	fprintf(stderr, ""GPAC cleanup ...\n"");
 	gf_modules_del(user.modules);
 	if (no_cfg_save)
 		gf_cfg_discard_changes(cfg_file);
 	gf_cfg_del(cfg_file);
 	gf_sys_close();
 	if (rti_logs) gf_fclose(rti_logs);
 	if (logfile) gf_fclose(logfile);
 	if (gui_mode) {
 		hide_shell(2);
 	}
 #ifdef GPAC_MEMORY_TRACKING
 	if (mem_track && (gf_memory_size() || gf_file_handles_count() )) {
 	        gf_log_set_tool_level(GF_LOG_MEMORY, GF_LOG_INFO);
 		gf_memory_print();
 		return 2;
 	}
 #endif
 	return ret_val;
 }","[448, 449]","In GPAC 0.7.1 and earlier, gf_text_get_utf8_line in media_tools/text_import.c in libgpac_static.a allows an out-of-bounds write because of missing szLineConv bounds checking.",gpac,CVE-2018-20763,CWE-787
4827,182978," rdpsnd_process_training(STREAM in)
 {
  	uint16 tick;
  	uint16 packsize;
  	STREAM out;
 	struct stream packet = *in;
 	if (!s_check_rem(in, 4))
 	{
 		rdp_protocol_error(""rdpsnd_process_training(), consume of training data from stream would overrun"", &packet);
 	}
  	in_uint16_le(in, tick);
  	in_uint16_le(in, packsize);
 	logger(Sound, Debug, ""rdpsnd_process_training(), tick=0x%04x"", (unsigned) tick);
 	out = rdpsnd_init_packet(SNDC_TRAINING, 4);
 	out_uint16_le(out, tick);
 	out_uint16_le(out, packsize);
 	s_mark_end(out);
 	rdpsnd_send(out);
 }","[6, 7, 8, 9, 10]",rdesktop versions up to and including v1.8.3 contain a Buffer Overflow over the global variables in the function seamless_process_line() that results in memory corruption and probably even a remote code execution.,rdesktop,CVE-2018-20182,CWE-119
4828,182963," void set_cfg_option(char *opt_string)
 {
 	char *sep, *sep2, szSec[1024], szKey[1024], szVal[1024];
 	sep = strchr(opt_string, ':');
 	if (!sep) {
 		fprintf(stderr, ""Badly formatted option %s - expected Section:Name=Value\n"", opt_string);
 		return;
  	}
  	{
  		const size_t sepIdx = sep - opt_string;
 		if (sepIdx >= sizeof(szSec)) {
 			fprintf(stderr, ""Badly formatted option %s - Section name is too long\n"", opt_string);
 			return;
 		}
  		strncpy(szSec, opt_string, sepIdx);
  		szSec[sepIdx] = 0;
  	}
 	sep ++;
 	sep2 = strchr(sep, '=');
 	if (!sep2) {
 		fprintf(stderr, ""Badly formatted option %s - expected Section:Name=Value\n"", opt_string);
 		return;
  	}
  	{
  		const size_t sepIdx = sep2 - sep;
 		if (sepIdx >= sizeof(szKey)) {
 			fprintf(stderr, ""Badly formatted option %s - key name is too long\n"", opt_string);
 			return;
 		}
  		strncpy(szKey, sep, sepIdx);
  		szKey[sepIdx] = 0;
 		if (strlen(sep2 + 1) >= sizeof(szVal)) {
 			fprintf(stderr, ""Badly formatted option %s - value is too long\n"", opt_string);
 			return;
 		}
  		strcpy(szVal, sep2+1);
  	}
 	if (!stricmp(szKey, ""*"")) {
 		if (stricmp(szVal, ""null"")) {
 			fprintf(stderr, ""Badly formatted option %s - expected Section:*=null\n"", opt_string);
 			return;
 		}
 		gf_cfg_del_section(cfg_file, szSec);
 		return;
 	}
 	if (!stricmp(szVal, ""null"")) {
 		szVal[0]=0;
 	}
 	gf_cfg_set_key(cfg_file, szSec, szKey, szVal[0] ? szVal : NULL);
 }","[11, 12, 13, 14, 26, 27, 28, 29, 32, 33, 34, 35]",GPAC version 0.7.1 and earlier has a buffer overflow vulnerability in the cat_multiple_files function in applications/mp4box/fileimport.c when MP4Box is used for a local directory containing crafted filenames.,gpac,CVE-2018-20762,CWE-119
4851,182786," static __forceinline void draw_line(float *output, int x0, int y0, int x1, int y1, int n)
 {
    int dy = y1 - y0;
    int adx = x1 - x0;
    int ady = abs(dy);
    int base;
    int x=x0,y=y0;
    int err = 0;
    int sy;
 #ifdef STB_VORBIS_DIVIDE_TABLE
    if (adx < DIVTAB_DENOM && ady < DIVTAB_NUMER) {
       if (dy < 0) {
          base = -integer_divide_table[ady][adx];
          sy = base-1;
       } else {
          base =  integer_divide_table[ady][adx];
          sy = base+1;
       }
    } else {
       base = dy / adx;
       if (dy < 0)
          sy = base - 1;
       else
          sy = base+1;
    }
 #else
    base = dy / adx;
    if (dy < 0)
       sy = base - 1;
    else
       sy = base+1;
 #endif
     ady -= abs(base) * adx;
     if (x1 > n) x1 = n;
     if (x < x1) {
      LINE_OP(output[x], inverse_db_table[y]);
       LINE_OP(output[x], inverse_db_table[y&255]);
        for (++x; x < x1; ++x) {
           err += ady;
           if (err >= adx) {
              err -= adx;
              y += sy;
           } else
              y += base;
         LINE_OP(output[x], inverse_db_table[y]);
          LINE_OP(output[x], inverse_db_table[y&255]);
        }
     }
  }","[36, 37, 45, 46]",A reachable assertion in the lookup1_values function in stb_vorbis through 2019-03-04 allows an attacker to cause a denial of service by opening a crafted Ogg Vorbis file.,stb,CVE-2019-13223,CWE-20
4862,178085," Status XvMCGetDRInfo(Display *dpy, XvPortID port,
 		     char **name, char **busID,
 		     int *major, int *minor,
 		     int *patchLevel,
 		     int *isLocal)
 {
     XExtDisplayInfo *info = xvmc_find_display(dpy);
     xvmcGetDRInfoReply rep;
     xvmcGetDRInfoReq  *req;
     CARD32 magic;
 #ifdef HAVE_SHMAT
     volatile CARD32 *shMem;
     struct timezone here;
     struct timeval now;
     here.tz_minuteswest = 0;
     here.tz_dsttime = 0;
 #endif
     *name = NULL;
     *busID = NULL;
     XvMCCheckExtension (dpy, info, BadImplementation);
     LockDisplay (dpy);
     XvMCGetReq (GetDRInfo, req);
     req->port = port;
     magic = 0;
     req->magic = 0;
 #ifdef HAVE_SHMAT
     req->shmKey = shmget(IPC_PRIVATE, 1024, IPC_CREAT | 0600);
     if (req->shmKey >= 0) {
 	shMem = (CARD32 *) shmat(req->shmKey, NULL, 0);
 	shmctl( req->shmKey, IPC_RMID, NULL);
 	if ( shMem ) {
 	    register volatile CARD32 *shMemC = shMem;
 	    register int i;
 	    gettimeofday( &now, &here);
 	    magic = now.tv_usec & 0x000FFFFF;
 	    req->magic = magic;
 	    i = 1024 / sizeof(CARD32);
 	    while(i--) {
 	        *shMemC++ = magic;
 	        magic = ~magic;
 	    }
 	} else {
 	    req->shmKey = -1;
 	}
     }
 #else
     req->shmKey = 0;
 #endif
     if (!_XReply (dpy, (xReply *) &rep, 0, xFalse)) {
         UnlockDisplay (dpy);
         SyncHandle ();
 #ifdef HAVE_SHMAT
 	if ( req->shmKey >= 0) {
 	    shmdt( (const void *) shMem );
 	}
 #endif
         return -1;
     }
 #ifdef HAVE_SHMAT
     shmdt( (const void *) shMem );
 #endif
     if (rep.length > 0) {
 	unsigned long realSize = 0;
 	char *tmpBuf = NULL;
 	if ((rep.length < (INT_MAX >> 2)) &&
 	    (rep.nameLen + rep.busIDLen > rep.nameLen)) {
 	    realSize = rep.length << 2;
 	    if (realSize >= (rep.nameLen + rep.busIDLen)) {
 		tmpBuf = Xmalloc(realSize);
 		*name = Xmalloc(rep.nameLen);
 		*busID = Xmalloc(rep.busIDLen);
 	    }
 	}
  	if (*name && *busID && tmpBuf) {
  	    _XRead(dpy, tmpBuf, realSize);
  	    strncpy(*name,tmpBuf,rep.nameLen);
	    (*name)[rep.nameLen - 1] = '\0';
 	    (*name)[rep.nameLen == 0 ? 0 : rep.nameLen - 1] = '\0';
  	    strncpy(*busID,tmpBuf+rep.nameLen,rep.busIDLen);
	    (*busID)[rep.busIDLen - 1] = '\0';
 	    (*busID)[rep.busIDLen == 0 ? 0 : rep.busIDLen - 1] = '\0';
  	    XFree(tmpBuf);
  	} else {
  	    XFree(*name);
 	    *name = NULL;
 	    XFree(*busID);
 	    *busID = NULL;
 	    XFree(tmpBuf);
 	    _XEatDataWords(dpy, rep.length);
 	    UnlockDisplay (dpy);
 	    SyncHandle ();
 	    return -1;
 	}
     }
     UnlockDisplay (dpy);
     SyncHandle ();
     *major = rep.major;
     *minor = rep.minor;
     *patchLevel = rep.patchLevel;
     *isLocal = (req->shmKey > 0) ? rep.isLocal : 1;
     return (rep.length > 0) ? Success : BadImplementation;
 }","[77, 78, 80, 81]",Buffer underflow in X.org libXvMC before 1.0.10 allows remote X servers to have unspecified impact via an empty string.,libXvMC,CVE-2016-7953,CWE-119
4869,179091," static int decode_cblk(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *codsty,
                        Jpeg2000T1Context *t1, Jpeg2000Cblk *cblk,
                        int width, int height, int bandpos)
 {
     int passno = cblk->npasses, pass_t = 2, bpno = cblk->nonzerobits - 1, y;
     int clnpass_cnt = 0;
      int bpass_csty_symbol           = codsty->cblk_style & JPEG2000_CBLK_BYPASS;
      int vert_causal_ctx_csty_symbol = codsty->cblk_style & JPEG2000_CBLK_VSC;
     av_assert0(width  <= JPEG2000_MAX_CBLKW);
     av_assert0(height <= JPEG2000_MAX_CBLKH);
      for (y = 0; y < height; y++)
          memset(t1->data[y], 0, width * sizeof(**t1->data));
     if (!cblk->length)
         return 0;
     for (y = 0; y < height + 2; y++)
         memset(t1->flags[y], 0, (width + 2) * sizeof(**t1->flags));
     cblk->data[cblk->length] = 0xff;
     cblk->data[cblk->length+1] = 0xff;
     ff_mqc_initdec(&t1->mqc, cblk->data);
     while (passno--) {
         switch(pass_t) {
         case 0:
             decode_sigpass(t1, width, height, bpno + 1, bandpos,
                            bpass_csty_symbol && (clnpass_cnt >= 4),
                            vert_causal_ctx_csty_symbol);
             break;
         case 1:
             decode_refpass(t1, width, height, bpno + 1);
             if (bpass_csty_symbol && clnpass_cnt >= 4)
                 ff_mqc_initdec(&t1->mqc, cblk->data);
             break;
         case 2:
             decode_clnpass(s, t1, width, height, bpno + 1, bandpos,
                            codsty->cblk_style & JPEG2000_CBLK_SEGSYM,
                            vert_causal_ctx_csty_symbol);
             clnpass_cnt = clnpass_cnt + 1;
             if (bpass_csty_symbol && clnpass_cnt >= 4)
                 ff_mqc_initdec(&t1->mqc, cblk->data);
             break;
         }
         pass_t++;
         if (pass_t == 3) {
             bpno--;
             pass_t = 0;
         }
     }
     return 0;
 }","[9, 10]","libavcodec/jpeg2000dec.c in FFmpeg before 2.1 does not ensure the use of valid code-block dimension values, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted JPEG2000 data.",FFmpeg,CVE-2013-7018,CWE-119
4877,182705," prologProcessor(XML_Parser parser, const char *s, const char *end,
                 const char **nextPtr) {
    const char *next = s;
    int tok = XmlPrologTok(parser->m_encoding, s, end, &next);
    return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,
                  (XML_Bool)! parser->m_parsingStatus.finalBuffer);
                   (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE);
  }","[6, 7]","In libexpat before 2.2.8, crafted XML input could fool the parser into changing from DTD parsing to document parsing too early; a consecutive call to XML_GetCurrentLineNumber (or XML_GetCurrentColumnNumber) then resulted in a heap-based buffer over-read.",libexpat,CVE-2019-15903,CWE-611
4879,181427,"  flac_read_loop (SF_PRIVATE *psf, unsigned len)
  {	FLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;
 	FLAC__StreamDecoderState state ;
  	pflac->pos = 0 ;
  	pflac->len = len ;
  	pflac->remain = len ;
 	state = FLAC__stream_decoder_get_state (pflac->fsd) ;
 	if (state > FLAC__STREAM_DECODER_END_OF_STREAM)
 	{	psf_log_printf (psf, ""FLAC__stream_decoder_get_state returned %s\n"", FLAC__StreamDecoderStateString [state]) ;
 		pflac->frame = NULL ;
 		} ;
  	if (pflac->frame != NULL && pflac->bufferpos < pflac->frame->header.blocksize)
  		flac_buffer_copy (psf) ;
  	while (pflac->pos < pflac->len)
  	{	if (FLAC__stream_decoder_process_single (pflac->fsd) == 0)
  			break ;
		if (FLAC__stream_decoder_get_state (pflac->fsd) >= FLAC__STREAM_DECODER_END_OF_STREAM)
 		state = FLAC__stream_decoder_get_state (pflac->fsd) ;
 		if (state >= FLAC__STREAM_DECODER_END_OF_STREAM)
 		{	psf_log_printf (psf, ""FLAC__stream_decoder_get_state returned %s\n"", FLAC__StreamDecoderStateString [state]) ;
 			pflac->frame = NULL ;
  			break ;
 			} ;
  		} ;
  	pflac->ptr = NULL ;
 	return pflac->pos ;
 }  ","[3, 7, 8, 9, 10, 11, 17, 18, 19, 20, 21, 23]","In libsndfile before 1.0.28, an error in the *flac_buffer_copy()* function (flac.c) can be exploited to cause a segmentation violation (with read memory access) via a specially crafted FLAC file during a resample attempt, a similar issue to CVE-2017-7585.",libsndfile,CVE-2017-7742,CWE-119
4880,181373," int yr_execute_code(
     YR_RULES* rules,
     YR_SCAN_CONTEXT* context,
     int timeout,
     time_t start_time)
 {
   int64_t mem[MEM_SIZE];
   int32_t sp = 0;
   uint8_t* ip = rules->code_start;
   YR_VALUE args[MAX_FUNCTION_ARGS];
   YR_VALUE *stack;
   YR_VALUE r1;
   YR_VALUE r2;
   YR_VALUE r3;
   #ifdef PROFILING_ENABLED
   YR_RULE* current_rule = NULL;
   #endif
   YR_RULE* rule;
   YR_MATCH* match;
   YR_OBJECT_FUNCTION* function;
   char* identifier;
   char* args_fmt;
   int i;
   int found;
   int count;
   int result = ERROR_SUCCESS;
   int stop = FALSE;
   int cycle = 0;
   int tidx = context->tidx;
   int stack_size;
   #ifdef PROFILING_ENABLED
   clock_t start = clock();
   #endif
   yr_get_configuration(YR_CONFIG_STACK_SIZE, (void*) &stack_size);
   stack = (YR_VALUE*) yr_malloc(stack_size * sizeof(YR_VALUE));
   if (stack == NULL)
     return ERROR_INSUFFICIENT_MEMORY;
   while(!stop)
   {
     switch(*ip)
     {
       case OP_HALT:
         assert(sp == 0);  
         stop = TRUE;
         break;
       case OP_PUSH:
         r1.i = *(uint64_t*)(ip + 1);
         ip += sizeof(uint64_t);
         push(r1);
         break;
       case OP_POP:
         pop(r1);
         break;
       case OP_CLEAR_M:
         r1.i = *(uint64_t*)(ip + 1);
         ip += sizeof(uint64_t);
         mem[r1.i] = 0;
         break;
       case OP_ADD_M:
         r1.i = *(uint64_t*)(ip + 1);
         ip += sizeof(uint64_t);
         pop(r2);
         if (!is_undef(r2))
           mem[r1.i] += r2.i;
         break;
       case OP_INCR_M:
         r1.i = *(uint64_t*)(ip + 1);
         ip += sizeof(uint64_t);
         mem[r1.i]++;
         break;
       case OP_PUSH_M:
         r1.i = *(uint64_t*)(ip + 1);
         ip += sizeof(uint64_t);
         r1.i = mem[r1.i];
         push(r1);
         break;
       case OP_POP_M:
         r1.i = *(uint64_t*)(ip + 1);
         ip += sizeof(uint64_t);
         pop(r2);
         mem[r1.i] = r2.i;
         break;
       case OP_SWAPUNDEF:
         r1.i = *(uint64_t*)(ip + 1);
         ip += sizeof(uint64_t);
         pop(r2);
         if (is_undef(r2))
         {
           r1.i = mem[r1.i];
           push(r1);
         }
         else
         {
           push(r2);
         }
         break;
       case OP_JNUNDEF:
         pop(r1);
         push(r1);
         ip = jmp_if(!is_undef(r1), ip);
         break;
       case OP_JLE:
         pop(r2);
         pop(r1);
         push(r1);
         push(r2);
         ip = jmp_if(r1.i <= r2.i, ip);
         break;
       case OP_JTRUE:
         pop(r1);
         push(r1);
         ip = jmp_if(!is_undef(r1) && r1.i, ip);
         break;
       case OP_JFALSE:
         pop(r1);
         push(r1);
         ip = jmp_if(is_undef(r1) || !r1.i, ip);
         break;
       case OP_AND:
         pop(r2);
         pop(r1);
         if (is_undef(r1) || is_undef(r2))
           r1.i = 0;
         else
           r1.i = r1.i && r2.i;
         push(r1);
         break;
       case OP_OR:
         pop(r2);
         pop(r1);
         if (is_undef(r1))
         {
           push(r2);
         }
         else if (is_undef(r2))
         {
           push(r1);
         }
         else
         {
           r1.i = r1.i || r2.i;
           push(r1);
         }
         break;
       case OP_NOT:
         pop(r1);
         if (is_undef(r1))
           r1.i = UNDEFINED;
         else
           r1.i= !r1.i;
         push(r1);
         break;
       case OP_MOD:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         if (r2.i != 0)
           r1.i = r1.i % r2.i;
         else
           r1.i = UNDEFINED;
         push(r1);
         break;
       case OP_SHR:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.i = r1.i >> r2.i;
         push(r1);
         break;
       case OP_SHL:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.i = r1.i << r2.i;
         push(r1);
         break;
       case OP_BITWISE_NOT:
         pop(r1);
         ensure_defined(r1);
         r1.i = ~r1.i;
         push(r1);
         break;
       case OP_BITWISE_AND:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.i = r1.i & r2.i;
         push(r1);
         break;
       case OP_BITWISE_OR:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.i = r1.i | r2.i;
         push(r1);
         break;
       case OP_BITWISE_XOR:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.i = r1.i ^ r2.i;
         push(r1);
         break;
       case OP_PUSH_RULE:
         rule = *(YR_RULE**)(ip + 1);
         ip += sizeof(uint64_t);
         r1.i = rule->t_flags[tidx] & RULE_TFLAGS_MATCH ? 1 : 0;
         push(r1);
         break;
       case OP_INIT_RULE:
         #ifdef PROFILING_ENABLED
         current_rule = *(YR_RULE**)(ip + 1);
         #endif
         ip += sizeof(uint64_t);
         break;
       case OP_MATCH_RULE:
         pop(r1);
         rule = *(YR_RULE**)(ip + 1);
         ip += sizeof(uint64_t);
         if (!is_undef(r1) && r1.i)
           rule->t_flags[tidx] |= RULE_TFLAGS_MATCH;
         else if (RULE_IS_GLOBAL(rule))
           rule->ns->t_flags[tidx] |= NAMESPACE_TFLAGS_UNSATISFIED_GLOBAL;
         #ifdef PROFILING_ENABLED
         rule->clock_ticks += clock() - start;
         start = clock();
         #endif
         break;
       case OP_OBJ_LOAD:
         identifier = *(char**)(ip + 1);
         ip += sizeof(uint64_t);
         r1.o = (YR_OBJECT*) yr_hash_table_lookup(
             context->objects_table,
             identifier,
             NULL);
         assert(r1.o != NULL);
         push(r1);
         break;
       case OP_OBJ_FIELD:
         identifier = *(char**)(ip + 1);
         ip += sizeof(uint64_t);
         pop(r1);
         ensure_defined(r1);
         r1.o = yr_object_lookup_field(r1.o, identifier);
         assert(r1.o != NULL);
         push(r1);
         break;
       case OP_OBJ_VALUE:
         pop(r1);
         ensure_defined(r1);
         switch(r1.o->type)
         {
           case OBJECT_TYPE_INTEGER:
             r1.i = ((YR_OBJECT_INTEGER*) r1.o)->value;
             break;
           case OBJECT_TYPE_FLOAT:
             if (isnan(((YR_OBJECT_DOUBLE*) r1.o)->value))
               r1.i = UNDEFINED;
             else
               r1.d = ((YR_OBJECT_DOUBLE*) r1.o)->value;
             break;
           case OBJECT_TYPE_STRING:
             if (((YR_OBJECT_STRING*) r1.o)->value == NULL)
               r1.i = UNDEFINED;
             else
               r1.p = ((YR_OBJECT_STRING*) r1.o)->value;
             break;
           default:
             assert(FALSE);
         }
         push(r1);
         break;
       case OP_INDEX_ARRAY:
         pop(r1);   
         pop(r2);   
         ensure_defined(r1);
         ensure_defined(r2);
         assert(r2.o->type == OBJECT_TYPE_ARRAY);
         r1.o = yr_object_array_get_item(r2.o, 0, (int) r1.i);
         if (r1.o == NULL)
           r1.i = UNDEFINED;
         push(r1);
         break;
       case OP_LOOKUP_DICT:
         pop(r1);   
         pop(r2);   
         ensure_defined(r1);
         ensure_defined(r2);
         assert(r2.o->type == OBJECT_TYPE_DICTIONARY);
         r1.o = yr_object_dict_get_item(
             r2.o, 0, r1.ss->c_string);
         if (r1.o == NULL)
           r1.i = UNDEFINED;
         push(r1);
         break;
       case OP_CALL:
         args_fmt = *(char**)(ip + 1);
         ip += sizeof(uint64_t);
         i = (int) strlen(args_fmt);
         count = 0;
         while (i > 0)
         {
           pop(r1);
           if (is_undef(r1))   
             count++;
           args[i - 1] = r1;
           i--;
         }
         pop(r2);
         ensure_defined(r2);
         if (count > 0)
         {
           r1.i = UNDEFINED;
           push(r1);
           break;
         }
         function = (YR_OBJECT_FUNCTION*) r2.o;
         result = ERROR_INTERNAL_FATAL_ERROR;
         for (i = 0; i < MAX_OVERLOADED_FUNCTIONS; i++)
         {
           if (function->prototypes[i].arguments_fmt == NULL)
             break;
           if (strcmp(function->prototypes[i].arguments_fmt, args_fmt) == 0)
           {
             result = function->prototypes[i].code(args, context, function);
             break;
           }
         }
         assert(i < MAX_OVERLOADED_FUNCTIONS);
         if (result == ERROR_SUCCESS)
         {
           r1.o = function->return_obj;
           push(r1);
         }
         else
         {
           stop = TRUE;
         }
         break;
       case OP_FOUND:
         pop(r1);
         r1.i = r1.s->matches[tidx].tail != NULL ? 1 : 0;
         push(r1);
         break;
       case OP_FOUND_AT:
         pop(r2);
         pop(r1);
         if (is_undef(r1))
         {
           r1.i = 0;
           push(r1);
           break;
         }
         match = r2.s->matches[tidx].head;
         r3.i = FALSE;
         while (match != NULL)
         {
           if (r1.i == match->base + match->offset)
           {
             r3.i = TRUE;
             break;
           }
           if (r1.i < match->base + match->offset)
             break;
           match = match->next;
         }
         push(r3);
         break;
       case OP_FOUND_IN:
         pop(r3);
         pop(r2);
         pop(r1);
         ensure_defined(r1);
         ensure_defined(r2);
         match = r3.s->matches[tidx].head;
         r3.i = FALSE;
         while (match != NULL && !r3.i)
         {
           if (match->base + match->offset >= r1.i &&
               match->base + match->offset <= r2.i)
           {
             r3.i = TRUE;
           }
           if (match->base + match->offset > r2.i)
             break;
           match = match->next;
         }
         push(r3);
         break;
       case OP_COUNT:
         pop(r1);
         r1.i = r1.s->matches[tidx].count;
         push(r1);
         break;
       case OP_OFFSET:
         pop(r2);
         pop(r1);
         ensure_defined(r1);
         match = r2.s->matches[tidx].head;
         i = 1;
         r3.i = UNDEFINED;
         while (match != NULL && r3.i == UNDEFINED)
         {
           if (r1.i == i)
             r3.i = match->base + match->offset;
           i++;
           match = match->next;
         }
         push(r3);
         break;
       case OP_LENGTH:
         pop(r2);
         pop(r1);
         ensure_defined(r1);
         match = r2.s->matches[tidx].head;
         i = 1;
         r3.i = UNDEFINED;
         while (match != NULL && r3.i == UNDEFINED)
         {
           if (r1.i == i)
             r3.i = match->match_length;
           i++;
           match = match->next;
         }
         push(r3);
         break;
       case OP_OF:
         found = 0;
         count = 0;
         pop(r1);
         while (!is_undef(r1))
         {
           if (r1.s->matches[tidx].tail != NULL)
             found++;
           count++;
           pop(r1);
         }
         pop(r2);
         if (is_undef(r2))
           r1.i = found >= count ? 1 : 0;
         else
           r1.i = found >= r2.i ? 1 : 0;
         push(r1);
         break;
       case OP_FILESIZE:
         r1.i = context->file_size;
         push(r1);
         break;
       case OP_ENTRYPOINT:
         r1.i = context->entry_point;
         push(r1);
         break;
       case OP_INT8:
         pop(r1);
         r1.i = read_int8_t_little_endian(context->iterator, (size_t) r1.i);
         push(r1);
         break;
       case OP_INT16:
         pop(r1);
         r1.i = read_int16_t_little_endian(context->iterator, (size_t) r1.i);
         push(r1);
         break;
       case OP_INT32:
         pop(r1);
         r1.i = read_int32_t_little_endian(context->iterator, (size_t) r1.i);
         push(r1);
         break;
       case OP_UINT8:
         pop(r1);
         r1.i = read_uint8_t_little_endian(context->iterator, (size_t) r1.i);
         push(r1);
         break;
       case OP_UINT16:
         pop(r1);
         r1.i = read_uint16_t_little_endian(context->iterator, (size_t) r1.i);
         push(r1);
         break;
       case OP_UINT32:
         pop(r1);
         r1.i = read_uint32_t_little_endian(context->iterator, (size_t) r1.i);
         push(r1);
         break;
       case OP_INT8BE:
         pop(r1);
         r1.i = read_int8_t_big_endian(context->iterator, (size_t) r1.i);
         push(r1);
         break;
       case OP_INT16BE:
         pop(r1);
         r1.i = read_int16_t_big_endian(context->iterator, (size_t) r1.i);
         push(r1);
         break;
       case OP_INT32BE:
         pop(r1);
         r1.i = read_int32_t_big_endian(context->iterator, (size_t) r1.i);
         push(r1);
         break;
       case OP_UINT8BE:
         pop(r1);
         r1.i = read_uint8_t_big_endian(context->iterator, (size_t) r1.i);
         push(r1);
         break;
       case OP_UINT16BE:
         pop(r1);
         r1.i = read_uint16_t_big_endian(context->iterator, (size_t) r1.i);
         push(r1);
         break;
       case OP_UINT32BE:
         pop(r1);
         r1.i = read_uint32_t_big_endian(context->iterator, (size_t) r1.i);
         push(r1);
         break;
       case OP_CONTAINS:
         pop(r2);
         pop(r1);
         ensure_defined(r1);
         ensure_defined(r2);
         r1.i = memmem(r1.ss->c_string, r1.ss->length,
                       r2.ss->c_string, r2.ss->length) != NULL;
         push(r1);
         break;
       case OP_IMPORT:
         r1.i = *(uint64_t*)(ip + 1);
         ip += sizeof(uint64_t);
         result = yr_modules_load((char*) r1.p, context);
         if (result != ERROR_SUCCESS)
           stop = TRUE;
         break;
       case OP_MATCHES:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         if (r1.ss->length == 0)
         {
           r1.i = FALSE;
           push(r1);
           break;
         }
         r1.i = yr_re_exec(
            (uint8_t*) r2.re->code,
            (uint8_t*) r1.ss->c_string,
            r1.ss->length,
           0,
            r2.re->flags | RE_FLAGS_SCAN,
            NULL,
            NULL) >= 0;
         push(r1);
         break;
       case OP_INT_TO_DBL:
         r1.i = *(uint64_t*)(ip + 1);
         ip += sizeof(uint64_t);
         r2 = stack[sp - r1.i];
         if (is_undef(r2))
           stack[sp - r1.i].i = UNDEFINED;
         else
           stack[sp - r1.i].d = (double) r2.i;
         break;
       case OP_STR_TO_BOOL:
         pop(r1);
         ensure_defined(r1);
         r1.i = r1.ss->length > 0;
         push(r1);
         break;
       case OP_INT_EQ:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.i = r1.i == r2.i;
         push(r1);
         break;
       case OP_INT_NEQ:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.i = r1.i != r2.i;
         push(r1);
         break;
       case OP_INT_LT:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.i = r1.i < r2.i;
         push(r1);
         break;
       case OP_INT_GT:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.i = r1.i > r2.i;
         push(r1);
         break;
       case OP_INT_LE:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.i = r1.i <= r2.i;
         push(r1);
         break;
       case OP_INT_GE:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.i = r1.i >= r2.i;
         push(r1);
         break;
       case OP_INT_ADD:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.i = r1.i + r2.i;
         push(r1);
         break;
       case OP_INT_SUB:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.i = r1.i - r2.i;
         push(r1);
         break;
       case OP_INT_MUL:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.i = r1.i * r2.i;
         push(r1);
         break;
       case OP_INT_DIV:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         if (r2.i != 0)
           r1.i = r1.i / r2.i;
         else
           r1.i = UNDEFINED;
         push(r1);
         break;
       case OP_INT_MINUS:
         pop(r1);
         ensure_defined(r1);
         r1.i = -r1.i;
         push(r1);
         break;
       case OP_DBL_LT:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.i = r1.d < r2.d;
         push(r1);
         break;
       case OP_DBL_GT:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.i = r1.d > r2.d;
         push(r1);
         break;
       case OP_DBL_LE:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.i = r1.d <= r2.d;
         push(r1);
         break;
       case OP_DBL_GE:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.i = r1.d >= r2.d;
         push(r1);
         break;
       case OP_DBL_EQ:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.i = r1.d == r2.d;
         push(r1);
         break;
       case OP_DBL_NEQ:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.i = r1.d != r2.d;
         push(r1);
         break;
       case OP_DBL_ADD:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.d = r1.d + r2.d;
         push(r1);
         break;
       case OP_DBL_SUB:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.d = r1.d - r2.d;
         push(r1);
         break;
       case OP_DBL_MUL:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.d = r1.d * r2.d;
         push(r1);
         break;
       case OP_DBL_DIV:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.d = r1.d / r2.d;
         push(r1);
         break;
       case OP_DBL_MINUS:
         pop(r1);
         ensure_defined(r1);
         r1.d = -r1.d;
         push(r1);
         break;
       case OP_STR_EQ:
       case OP_STR_NEQ:
       case OP_STR_LT:
       case OP_STR_LE:
       case OP_STR_GT:
       case OP_STR_GE:
         pop(r2);
         pop(r1);
         ensure_defined(r1);
         ensure_defined(r2);
         switch(*ip)
         {
           case OP_STR_EQ:
             r1.i = (sized_string_cmp(r1.ss, r2.ss) == 0);
             break;
           case OP_STR_NEQ:
             r1.i = (sized_string_cmp(r1.ss, r2.ss) != 0);
             break;
           case OP_STR_LT:
             r1.i = (sized_string_cmp(r1.ss, r2.ss) < 0);
             break;
           case OP_STR_LE:
             r1.i = (sized_string_cmp(r1.ss, r2.ss) <= 0);
             break;
           case OP_STR_GT:
             r1.i = (sized_string_cmp(r1.ss, r2.ss) > 0);
             break;
           case OP_STR_GE:
             r1.i = (sized_string_cmp(r1.ss, r2.ss) >= 0);
             break;
         }
         push(r1);
         break;
       default:
         assert(FALSE);
     }
     if (timeout > 0)   
     {
       if (++cycle == 10)
       {
         if (difftime(time(NULL), start_time) > timeout)
         {
           #ifdef PROFILING_ENABLED
           assert(current_rule != NULL);
           current_rule->clock_ticks += clock() - start;
           #endif
           result = ERROR_SCAN_TIMEOUT;
           stop = TRUE;
         }
         cycle = 0;
       }
     }
     ip++;
   }
   yr_modules_unload_all(context);
   yr_free(stack);
   return result;
 }",[550],libyara/re.c in the regex component in YARA 3.5.0 allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted rule that is mishandled in the yr_re_exec function.,yara,CVE-2017-8294,CWE-125
4884,180134," static int handle_packet(unsigned char *data, int data_len) {
 	struct mt_mactelnet_hdr pkthdr;
 	if (data_len < MT_HEADER_LEN){
 		return -1;
 	}
 	parse_packet(data, &pkthdr);
 	if (pkthdr.seskey != sessionkey) {
 		return -1;
 	}
 	if (pkthdr.ptype == MT_PTYPE_DATA) {
 		struct mt_packet odata;
 		struct mt_mactelnet_control_hdr cpkt;
 		int success = 0;
 		init_packet(&odata, MT_PTYPE_ACK, srcmac, dstmac, sessionkey, pkthdr.counter + (data_len - MT_HEADER_LEN));
 		send_udp(&odata, 0);
 		if (pkthdr.counter > incounter || (incounter - pkthdr.counter) > 65535) {
 			incounter = pkthdr.counter;
 		} else {
 			return -1;
 		}
 		success = parse_control_packet(data + MT_HEADER_LEN, data_len - MT_HEADER_LEN, &cpkt);
 		while (success) {
  			if (cpkt.cptype == MT_CPTYPE_PASSSALT) {
				memcpy(pass_salt, cpkt.data, cpkt.length);
 				if (cpkt.length != 16) {
 					fprintf(stderr, _(""Invalid salt length: %d (instead of 16) received from server %s\n""), cpkt.length, ether_ntoa((struct ether_addr *)dstmac));
 				}
 				memcpy(pass_salt, cpkt.data, 16);
  				send_auth(username, password);
  			}
 			else if (cpkt.cptype == MT_CPTYPE_PLAINDATA) {
 				fwrite((const void *)cpkt.data, 1, cpkt.length, stdout);
 			}
 			else if (cpkt.cptype == MT_CPTYPE_END_AUTH) {
 				terminal_mode = 1;
 				if (is_a_tty) {
 					raw_term();
 					setvbuf(stdin,  (char*)NULL, _IONBF, 0);
 					signal(SIGWINCH, sig_winch);
 				}
 			}
 			success = parse_control_packet(NULL, 0, &cpkt);
 		}
 	}
 	else if (pkthdr.ptype == MT_PTYPE_ACK) {
 	}
 	else if (pkthdr.ptype == MT_PTYPE_END) {
 		struct mt_packet odata;
 		init_packet(&odata, MT_PTYPE_END, srcmac, dstmac, pkthdr.seskey, 0);
 		send_udp(&odata, 0);
 		if (!quiet_mode) {
 			fprintf(stderr, _(""Connection closed.\n""));
 		}
 		running = 0;
 	} else {
 		fprintf(stderr, _(""Unhandeled packet type: %d received from server %s\n""), pkthdr.ptype, ether_ntoa((struct ether_addr *)dstmac));
 		return -1;
 	}
 	return pkthdr.ptype;
 }","[24, 25, 26, 27, 28]",Buffer overflow in the handle_packet function in mactelnet.c in the client in MAC-Telnet 0.4.3 and earlier allows remote TELNET servers to execute arbitrary code via a long string in an MT_CPTYPE_PASSSALT control packet.,MAC-Telnet,CVE-2016-7115,CWE-119
4900,180805," on_register_handler(TCMUService1HandlerManager1 *interface,
 		    GDBusMethodInvocation *invocation,
 		    gchar *subtype,
 		    gchar *cfg_desc,
 		    gpointer user_data)
 {
 	struct tcmur_handler *handler;
 	struct dbus_info *info;
 	char *bus_name;
 	bus_name = g_strdup_printf(""org.kernel.TCMUService1.HandlerManager1.%s"",
 				   subtype);
 	handler               = g_new0(struct tcmur_handler, 1);
 	handler->subtype      = g_strdup(subtype);
 	handler->cfg_desc     = g_strdup(cfg_desc);
 	handler->open         = dbus_handler_open;
 	handler->close        = dbus_handler_close;
  	handler->handle_cmd   = dbus_handler_handle_cmd;
  	info = g_new0(struct dbus_info, 1);
 	handler->opaque = info;
 	handler->_is_dbus_handler = 1;
  	info->register_invocation = invocation;
  	info->watcher_id = g_bus_watch_name(G_BUS_TYPE_SYSTEM,
  					    bus_name,
 					    G_BUS_NAME_WATCHER_FLAGS_NONE,
 					    on_handler_appeared,
 					    on_handler_vanished,
 					    handler,
 					    NULL);
 	g_free(bus_name);
 	handler->opaque = info;
 	return TRUE;
 }","[19, 20]",tcmu-runner version 1.0.5 to 1.2.0 is vulnerable to a dbus triggered NULL pointer dereference in the tcmu-runner daemon's on_unregister_handler() function resulting in denial of service,tcmu-runner,CVE-2017-1000200,CWE-476
4911,181885," jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)
 {
 	jas_image_t *image;
 	bmp_hdr_t hdr;
 	bmp_info_t *info;
 	uint_fast16_t cmptno;
 	jas_image_cmptparm_t cmptparms[3];
  	jas_image_cmptparm_t *cmptparm;
  	uint_fast16_t numcmpts;
  	long n;
 	bmp_dec_importopts_t opts;
 	size_t num_samples;
  	image = 0;
  	info = 0;
	if (optstr) {
		jas_eprintf(""warning: ignoring BMP decoder options\n"");
 	if (bmp_dec_parseopts(optstr, &opts)) {
 		goto error;
  	}
  	jas_eprintf(
 	  ""THE BMP FORMAT IS NOT FULLY SUPPORTED!\n""
 	  ""THAT IS, THE JASPER SOFTWARE CANNOT DECODE ALL TYPES OF BMP DATA.\n""
 	  ""IF YOU HAVE ANY PROBLEMS, PLEASE TRY CONVERTING YOUR IMAGE DATA\n""
 	  ""TO THE PNM FORMAT, AND USING THIS FORMAT INSTEAD.\n""
 	  );
  	if (bmp_gethdr(in, &hdr)) {
  		jas_eprintf(""cannot get header\n"");
  		goto error;
  	JAS_DBGLOG(1, (
  	  ""BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\n"",
 	  hdr.magic, hdr.siz, hdr.reserved1, hdr.reserved2, hdr.off
 	  ));
  	if (!(info = bmp_getinfo(in))) {
  		jas_eprintf(""cannot get info\n"");
  	}
  	JAS_DBGLOG(1,
 	  (""BMP information: len %ld; width %ld; height %ld; numplanes %d; ""
 	  ""depth %d; enctype %ld; siz %ld; hres %ld; vres %ld; numcolors %ld; ""
 	  ""mincolors %ld\n"", JAS_CAST(long, info->len),
 	  JAS_CAST(long, info->width), JAS_CAST(long, info->height),
 	  JAS_CAST(long, info->numplanes), JAS_CAST(long, info->depth),
 	  JAS_CAST(long, info->enctype), JAS_CAST(long, info->siz),
 	  JAS_CAST(long, info->hres), JAS_CAST(long, info->vres),
 	  JAS_CAST(long, info->numcolors), JAS_CAST(long, info->mincolors)));
 	if (info->width < 0 || info->height < 0 || info->numplanes < 0 ||
 	  info->depth < 0 || info->siz < 0 || info->hres < 0 || info->vres < 0) {
 		jas_eprintf(""corrupt bit stream\n"");
  		goto error;
  	}
 	if (!jas_safe_size_mul3(info->width, info->height, info->numplanes,
 	  &num_samples)) {
 		jas_eprintf(""image size too large\n"");
 		goto error;
 	}
 	if (opts.max_samples > 0 && num_samples > opts.max_samples) {
 		jas_eprintf(""maximum number of pixels exceeded (%zu)\n"",
 		  opts.max_samples);
 		goto error;
 	}
  	if (!bmp_issupported(&hdr, info)) {
  		jas_eprintf(""error: unsupported BMP encoding\n"");
  	}
  	if ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {
  		jas_eprintf(""error: possibly bad bitmap offset?\n"");
  		goto error;
  	if (n > 0) {
  		jas_eprintf(""skipping unknown data in BMP file\n"");
  		if (bmp_gobble(in, n)) {
  		}
  	}
 	numcmpts = bmp_numcmpts(info);
 	for (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,
 	  ++cmptparm) {
 		cmptparm->tlx = 0;
 		cmptparm->tly = 0;
 		cmptparm->hstep = 1;
 		cmptparm->vstep = 1;
 		cmptparm->width = info->width;
 		cmptparm->height = info->height;
 		cmptparm->prec = 8;
 		cmptparm->sgnd = false;
 	}
  	if (!(image = jas_image_create(numcmpts, cmptparms,
  	  JAS_CLRSPC_UNKNOWN))) {
  	}
 	if (numcmpts == 3) {
 		jas_image_setclrspc(image, JAS_CLRSPC_SRGB);
 		jas_image_setcmpttype(image, 0,
 		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));
 		jas_image_setcmpttype(image, 1,
 		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));
 		jas_image_setcmpttype(image, 2,
 		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));
 	} else {
 		jas_image_setclrspc(image, JAS_CLRSPC_SGRAY);
 		jas_image_setcmpttype(image, 0,
 		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));
 	}
  	if (bmp_getdata(in, info, image)) {
  	}
 	bmp_info_destroy(info);
 	return image;
 error:
 	if (info) {
 		bmp_info_destroy(info);
 	}
 	if (image) {
 		jas_image_destroy(image);
 	}
 	return 0;
 }","[11, 12, 15, 16, 17, 18, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
4938,182926," scandir(const char *dir, struct dirent ***namelist,
         int (*select) (const struct dirent *),
         int (*compar) (const struct dirent **, const struct dirent **))
 {
     DIR *d = opendir(dir);
     struct dirent *current;
     struct dirent **names;
     int count = 0;
     int pos = 0;
     int result = -1;
     if (NULL == d)
         return -1;
      while (NULL != readdir(d))
          count++;
 	closedir(d);
      names = malloc(sizeof (struct dirent *) * count);
 	if (!names) 
 		return -1;
    closedir(d);
      d = opendir(dir);
    if (NULL == d)
     if (NULL == d) {
 		free(names);
          return -1;
     }
      while (NULL != (current = readdir(d))) {
          if (NULL == select || select(current)) {
              struct dirent *copyentry = malloc(current->d_reclen);
 			if (!copyentry)
 				continue;
              memcpy(copyentry, current, current->d_reclen);
              names[pos] = copyentry;
             pos++;
         }
     }
     result = closedir(d);
     if (pos != count)
         names = realloc(names, sizeof (struct dirent *) * pos);
     *namelist = names;
     return pos;
 }","[15, 17, 18, 19, 21, 22, 23, 25, 29, 30]",Boa through 0.94.14rc21 allows remote attackers to trigger a memory leak because of missing calls to the free function.,boa,CVE-2018-21028,
4942,181281," unicode_unfold_key(OnigCodePoint code)
 {
   static const struct ByUnfoldKey wordlist[] =
     {
       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
       {0xffffffff, -1, 0},
       {0x1040a, 3267, 1},
       {0x1e0a, 1727, 1},
       {0x040a, 1016, 1},
       {0x010a, 186, 1},
       {0x1f0a, 2088, 1},
       {0x2c0a, 2451, 1},
       {0x0189, 619, 1},
       {0x1f89, 134, 2},
       {0x1f85, 154, 2},
       {0x0389, 733, 1},
       {0x03ff, 724, 1},
       {0xab89, 1523, 1},
       {0xab85, 1511, 1},
       {0x10c89, 3384, 1},
       {0x10c85, 3372, 1},
       {0x1e84, 1911, 1},
       {0x03f5, 752, 1},
       {0x0184, 360, 1},
       {0x1f84, 149, 2},
       {0x2c84, 2592, 1},
       {0x017d, 351, 1},
       {0x1ff3, 96, 2},
       {0xab84, 1508, 1},
       {0xa784, 3105, 1},
       {0x10c84, 3369, 1},
       {0xab7d, 1487, 1},
       {0xa77d, 1706, 1},
       {0x1e98, 38, 2},
       {0x0498, 1106, 1},
       {0x0198, 375, 1},
       {0x1f98, 169, 2},
       {0x2c98, 2622, 1},
       {0x0398, 762, 1},
       {0xa684, 2940, 1},
       {0xab98, 1568, 1},
       {0xa798, 3123, 1},
       {0x10c98, 3429, 1},
       {0x050a, 1277, 1},
       {0x1ffb, 2265, 1},
       {0x1e96, 16, 2},
       {0x0496, 1103, 1},
       {0x0196, 652, 1},
       {0x1f96, 199, 2},
       {0x2c96, 2619, 1},
       {0x0396, 756, 1},
       {0xa698, 2970, 1},
       {0xab96, 1562, 1},
       {0xa796, 3120, 1},
       {0x10c96, 3423, 1},
       {0x1feb, 2259, 1},
       {0x2ceb, 2736, 1},
       {0x1e90, 1929, 1},
       {0x0490, 1094, 1},
       {0x0190, 628, 1},
       {0x1f90, 169, 2},
       {0x2c90, 2610, 1},
       {0x0390, 25, 3},
       {0xa696, 2967, 1},
       {0xab90, 1544, 1},
       {0xa790, 3114, 1},
       {0x10c90, 3405, 1},
       {0x01d7, 444, 1},
       {0x1fd7, 31, 3},
       {0x1ea6, 1947, 1},
       {0x04a6, 1127, 1},
       {0x01a6, 676, 1},
       {0x1fa6, 239, 2},
       {0x2ca6, 2643, 1},
       {0x03a6, 810, 1},
       {0xa690, 2958, 1},
       {0xaba6, 1610, 1},
       {0xa7a6, 3144, 1},
       {0x10ca6, 3471, 1},
       {0x1ea4, 1944, 1},
       {0x04a4, 1124, 1},
       {0x01a4, 390, 1},
       {0x1fa4, 229, 2},
       {0x2ca4, 2640, 1},
       {0x03a4, 804, 1},
       {0x10a6, 2763, 1},
       {0xaba4, 1604, 1},
       {0xa7a4, 3141, 1},
       {0x10ca4, 3465, 1},
       {0x1ea0, 1938, 1},
       {0x04a0, 1118, 1},
       {0x01a0, 384, 1},
       {0x1fa0, 209, 2},
       {0x2ca0, 2634, 1},
       {0x03a0, 792, 1},
       {0x10a4, 2757, 1},
       {0xaba0, 1592, 1},
       {0xa7a0, 3135, 1},
       {0x10ca0, 3453, 1},
       {0x1eb2, 1965, 1},
       {0x04b2, 1145, 1},
       {0x01b2, 694, 1},
       {0x1fb2, 249, 2},
       {0x2cb2, 2661, 1},
       {0x03fd, 718, 1},
       {0x10a0, 2745, 1},
       {0xabb2, 1646, 1},
       {0xa7b2, 703, 1},
       {0x10cb2, 3507, 1},
       {0x1eac, 1956, 1},
       {0x04ac, 1136, 1},
       {0x01ac, 396, 1},
       {0x1fac, 229, 2},
       {0x2cac, 2652, 1},
       {0x0537, 1352, 1},
       {0x10b2, 2799, 1},
       {0xabac, 1628, 1},
       {0xa7ac, 637, 1},
       {0x10cac, 3489, 1},
       {0x1eaa, 1953, 1},
       {0x04aa, 1133, 1},
       {0x00dd, 162, 1},
       {0x1faa, 219, 2},
       {0x2caa, 2649, 1},
       {0x03aa, 824, 1},
       {0x10ac, 2781, 1},
       {0xabaa, 1622, 1},
       {0xa7aa, 646, 1},
       {0x10caa, 3483, 1},
       {0x1ea8, 1950, 1},
       {0x04a8, 1130, 1},
       {0x020a, 517, 1},
       {0x1fa8, 209, 2},
       {0x2ca8, 2646, 1},
       {0x03a8, 817, 1},
       {0x10aa, 2775, 1},
       {0xaba8, 1616, 1},
       {0xa7a8, 3147, 1},
       {0x10ca8, 3477, 1},
       {0x1ea2, 1941, 1},
       {0x04a2, 1121, 1},
       {0x01a2, 387, 1},
       {0x1fa2, 219, 2},
       {0x2ca2, 2637, 1},
       {0x118a6, 3528, 1},
       {0x10a8, 2769, 1},
       {0xaba2, 1598, 1},
       {0xa7a2, 3138, 1},
       {0x10ca2, 3459, 1},
       {0x2ced, 2739, 1},
       {0x1fe9, 2283, 1},
       {0x1fe7, 47, 3},
       {0x1eb0, 1962, 1},
       {0x04b0, 1142, 1},
       {0x118a4, 3522, 1},
       {0x10a2, 2751, 1},
       {0x2cb0, 2658, 1},
       {0x03b0, 41, 3},
       {0x1fe3, 41, 3},
       {0xabb0, 1640, 1},
       {0xa7b0, 706, 1},
       {0x10cb0, 3501, 1},
       {0x01d9, 447, 1},
       {0x1fd9, 2277, 1},
       {0x118a0, 3510, 1},
       {0x00df, 24, 2},
       {0x00d9, 150, 1},
       {0xab77, 1469, 1},
       {0x10b0, 2793, 1},
       {0x1eae, 1959, 1},
       {0x04ae, 1139, 1},
       {0x01ae, 685, 1},
       {0x1fae, 239, 2},
       {0x2cae, 2655, 1},
       {0x118b2, 3564, 1},
       {0xab73, 1457, 1},
       {0xabae, 1634, 1},
       {0xab71, 1451, 1},
       {0x10cae, 3495, 1},
       {0x1e2a, 1775, 1},
       {0x042a, 968, 1},
       {0x012a, 234, 1},
       {0x1f2a, 2130, 1},
       {0x2c2a, 2547, 1},
       {0x118ac, 3546, 1},
       {0x10ae, 2787, 1},
       {0x0535, 1346, 1},
       {0xa72a, 2988, 1},
       {0x1e9a, 0, 2},
       {0x049a, 1109, 1},
       {0xff37, 3225, 1},
       {0x1f9a, 179, 2},
       {0x2c9a, 2625, 1},
       {0x039a, 772, 1},
       {0x118aa, 3540, 1},
       {0xab9a, 1574, 1},
       {0xa79a, 3126, 1},
       {0x10c9a, 3435, 1},
       {0x1e94, 1935, 1},
       {0x0494, 1100, 1},
       {0x0194, 640, 1},
       {0x1f94, 189, 2},
       {0x2c94, 2616, 1},
       {0x0394, 749, 1},
       {0x118a8, 3534, 1},
       {0xab94, 1556, 1},
       {0xa69a, 2973, 1},
       {0x10c94, 3417, 1},
       {0x10402, 3243, 1},
       {0x1e02, 1715, 1},
       {0x0402, 992, 1},
       {0x0102, 174, 1},
       {0x0533, 1340, 1},
       {0x2c02, 2427, 1},
       {0x118a2, 3516, 1},
       {0x052a, 1325, 1},
       {0xa694, 2964, 1},
       {0x1e92, 1932, 1},
       {0x0492, 1097, 1},
       {0x2165, 2307, 1},
       {0x1f92, 179, 2},
       {0x2c92, 2613, 1},
       {0x0392, 742, 1},
       {0x2161, 2295, 1},
       {0xab92, 1550, 1},
       {0xa792, 3117, 1},
       {0x10c92, 3411, 1},
       {0x118b0, 3558, 1},
       {0x1f5f, 2199, 1},
       {0x1e8e, 1926, 1},
       {0x048e, 1091, 1},
       {0x018e, 453, 1},
       {0x1f8e, 159, 2},
       {0x2c8e, 2607, 1},
       {0x038e, 833, 1},
       {0xa692, 2961, 1},
       {0xab8e, 1538, 1},
       {0x0055, 59, 1},
       {0x10c8e, 3399, 1},
       {0x1f5d, 2196, 1},
       {0x212a, 27, 1},
       {0x04cb, 1181, 1},
       {0x01cb, 425, 1},
       {0x1fcb, 2241, 1},
       {0x118ae, 3552, 1},
       {0x0502, 1265, 1},
       {0x00cb, 111, 1},
       {0xa68e, 2955, 1},
       {0x1e8a, 1920, 1},
       {0x048a, 1085, 1},
       {0x018a, 622, 1},
       {0x1f8a, 139, 2},
       {0x2c8a, 2601, 1},
       {0x038a, 736, 1},
       {0x2c67, 2571, 1},
       {0xab8a, 1526, 1},
       {0x1e86, 1914, 1},
       {0x10c8a, 3387, 1},
       {0x0186, 616, 1},
       {0x1f86, 159, 2},
       {0x2c86, 2595, 1},
       {0x0386, 727, 1},
       {0xff35, 3219, 1},
       {0xab86, 1514, 1},
       {0xa786, 3108, 1},
       {0x10c86, 3375, 1},
       {0xa68a, 2949, 1},
       {0x0555, 1442, 1},
       {0x1ebc, 1980, 1},
       {0x04bc, 1160, 1},
       {0x01bc, 411, 1},
       {0x1fbc, 62, 2},
       {0x2cbc, 2676, 1},
       {0x1f5b, 2193, 1},
       {0xa686, 2943, 1},
       {0xabbc, 1676, 1},
       {0x1eb8, 1974, 1},
       {0x04b8, 1154, 1},
       {0x01b8, 408, 1},
       {0x1fb8, 2268, 1},
       {0x2cb8, 2670, 1},
       {0x01db, 450, 1},
       {0x1fdb, 2247, 1},
       {0xabb8, 1664, 1},
       {0x10bc, 2829, 1},
       {0x00db, 156, 1},
       {0x1eb6, 1971, 1},
       {0x04b6, 1151, 1},
       {0xff33, 3213, 1},
       {0x1fb6, 58, 2},
       {0x2cb6, 2667, 1},
       {0xff2a, 3186, 1},
       {0x10b8, 2817, 1},
       {0xabb6, 1658, 1},
       {0xa7b6, 3153, 1},
       {0x10426, 3351, 1},
       {0x1e26, 1769, 1},
       {0x0426, 956, 1},
       {0x0126, 228, 1},
       {0x0053, 52, 1},
       {0x2c26, 2535, 1},
       {0x0057, 65, 1},
       {0x10b6, 2811, 1},
       {0x022a, 562, 1},
       {0xa726, 2982, 1},
       {0x1e2e, 1781, 1},
       {0x042e, 980, 1},
       {0x012e, 240, 1},
       {0x1f2e, 2142, 1},
       {0x2c2e, 2559, 1},
       {0xffffffff, -1, 0},
       {0x2167, 2313, 1},
       {0xffffffff, -1, 0},
       {0xa72e, 2994, 1},
       {0x1e2c, 1778, 1},
       {0x042c, 974, 1},
       {0x012c, 237, 1},
       {0x1f2c, 2136, 1},
       {0x2c2c, 2553, 1},
       {0x1f6f, 2223, 1},
       {0x2c6f, 604, 1},
       {0xabbf, 1685, 1},
       {0xa72c, 2991, 1},
       {0x1e28, 1772, 1},
       {0x0428, 962, 1},
       {0x0128, 231, 1},
       {0x1f28, 2124, 1},
       {0x2c28, 2541, 1},
       {0xffffffff, -1, 0},
       {0x0553, 1436, 1},
       {0x10bf, 2838, 1},
       {0xa728, 2985, 1},
       {0x0526, 1319, 1},
       {0x0202, 505, 1},
       {0x1e40, 1808, 1},
       {0x10424, 3345, 1},
       {0x1e24, 1766, 1},
       {0x0424, 950, 1},
       {0x0124, 225, 1},
       {0xffffffff, -1, 0},
       {0x2c24, 2529, 1},
       {0x052e, 1331, 1},
       {0xa740, 3018, 1},
       {0x118bc, 3594, 1},
       {0xa724, 2979, 1},
       {0x1ef2, 2061, 1},
       {0x04f2, 1241, 1},
       {0x01f2, 483, 1},
       {0x1ff2, 257, 2},
       {0x2cf2, 2742, 1},
       {0x052c, 1328, 1},
       {0x118b8, 3582, 1},
       {0xa640, 2865, 1},
       {0x10422, 3339, 1},
       {0x1e22, 1763, 1},
       {0x0422, 944, 1},
       {0x0122, 222, 1},
       {0x2126, 820, 1},
       {0x2c22, 2523, 1},
       {0x0528, 1322, 1},
       {0x01f1, 483, 1},
       {0x118b6, 3576, 1},
       {0xa722, 2976, 1},
       {0x03f1, 796, 1},
       {0x1ebe, 1983, 1},
       {0x04be, 1163, 1},
       {0xfb02, 12, 2},
       {0x1fbe, 767, 1},
       {0x2cbe, 2679, 1},
       {0x01b5, 405, 1},
       {0x0540, 1379, 1},
       {0xabbe, 1682, 1},
       {0x0524, 1316, 1},
       {0x00b5, 779, 1},
       {0xabb5, 1655, 1},
       {0x1eba, 1977, 1},
       {0x04ba, 1157, 1},
       {0x216f, 2337, 1},
       {0x1fba, 2226, 1},
       {0x2cba, 2673, 1},
       {0x10be, 2835, 1},
       {0x0051, 46, 1},
       {0xabba, 1670, 1},
       {0x10b5, 2808, 1},
       {0x1e6e, 1878, 1},
       {0x046e, 1055, 1},
       {0x016e, 330, 1},
       {0x1f6e, 2220, 1},
       {0x2c6e, 664, 1},
       {0x118bf, 3603, 1},
       {0x0522, 1313, 1},
       {0x10ba, 2823, 1},
       {0xa76e, 3087, 1},
       {0x1eb4, 1968, 1},
       {0x04b4, 1148, 1},
       {0x2c75, 2583, 1},
       {0x1fb4, 50, 2},
       {0x2cb4, 2664, 1},
       {0xab75, 1463, 1},
       {0x1ec2, 1989, 1},
       {0xabb4, 1652, 1},
       {0xa7b4, 3150, 1},
       {0x1fc2, 253, 2},
       {0x2cc2, 2685, 1},
       {0x03c2, 800, 1},
       {0x00c2, 83, 1},
       {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
       {0xff26, 3174, 1},
       {0x10b4, 2805, 1},
       {0x1eca, 2001, 1},
       {0x0551, 1430, 1},
       {0x01ca, 425, 1},
       {0x1fca, 2238, 1},
       {0x2cca, 2697, 1},
       {0x10c2, 2847, 1},
       {0x00ca, 108, 1},
       {0xff2e, 3198, 1},
       {0x1e8c, 1923, 1},
       {0x048c, 1088, 1},
       {0x0226, 556, 1},
       {0x1f8c, 149, 2},
       {0x2c8c, 2604, 1},
       {0x038c, 830, 1},
       {0xffffffff, -1, 0},
       {0xab8c, 1532, 1},
       {0xff2c, 3192, 1},
       {0x10c8c, 3393, 1},
       {0x1ec4, 1992, 1},
       {0x022e, 568, 1},
       {0x01c4, 417, 1},
       {0x1fc4, 54, 2},
       {0x2cc4, 2688, 1},
       {0xffffffff, -1, 0},
       {0x00c4, 89, 1},
       {0xff28, 3180, 1},
       {0xa68c, 2952, 1},
       {0x01cf, 432, 1},
       {0x022c, 565, 1},
       {0x118be, 3600, 1},
       {0x03cf, 839, 1},
       {0x00cf, 123, 1},
       {0x118b5, 3573, 1},
       {0xffffffff, -1, 0},
       {0x10c4, 2853, 1},
       {0x216e, 2334, 1},
       {0x24cb, 2406, 1},
       {0x0228, 559, 1},
       {0xff24, 3168, 1},
       {0xffffffff, -1, 0},
       {0x118ba, 3588, 1},
       {0x1efe, 2079, 1},
       {0x04fe, 1259, 1},
       {0x01fe, 499, 1},
       {0x1e9e, 24, 2},
       {0x049e, 1115, 1},
       {0x03fe, 721, 1},
       {0x1f9e, 199, 2},
       {0x2c9e, 2631, 1},
       {0x039e, 786, 1},
       {0x0224, 553, 1},
       {0xab9e, 1586, 1},
       {0xa79e, 3132, 1},
       {0x10c9e, 3447, 1},
       {0x01f7, 414, 1},
       {0x1ff7, 67, 3},
       {0xff22, 3162, 1},
       {0x03f7, 884, 1},
       {0x118b4, 3570, 1},
       {0x049c, 1112, 1},
       {0x019c, 661, 1},
       {0x1f9c, 189, 2},
       {0x2c9c, 2628, 1},
       {0x039c, 779, 1},
       {0x24bc, 2361, 1},
       {0xab9c, 1580, 1},
       {0xa79c, 3129, 1},
       {0x10c9c, 3441, 1},
       {0x0222, 550, 1},
       {0x1e7c, 1899, 1},
       {0x047c, 1076, 1},
       {0x1e82, 1908, 1},
       {0x24b8, 2349, 1},
       {0x0182, 357, 1},
       {0x1f82, 139, 2},
       {0x2c82, 2589, 1},
       {0xab7c, 1484, 1},
       {0xffffffff, -1, 0},
       {0xab82, 1502, 1},
       {0xa782, 3102, 1},
       {0x10c82, 3363, 1},
       {0x2c63, 1709, 1},
       {0x24b6, 2343, 1},
       {0x1e80, 1905, 1},
       {0x0480, 1082, 1},
       {0x1f59, 2190, 1},
       {0x1f80, 129, 2},
       {0x2c80, 2586, 1},
       {0x0059, 71, 1},
       {0xa682, 2937, 1},
       {0xab80, 1496, 1},
       {0xa780, 3099, 1},
       {0x10c80, 3357, 1},
       {0xffffffff, -1, 0},
       {0x1e4c, 1826, 1},
       {0x0145, 270, 1},
       {0x014c, 279, 1},
       {0x1f4c, 2184, 1},
       {0x0345, 767, 1},
       {0x0045, 12, 1},
       {0x004c, 31, 1},
       {0xa680, 2934, 1},
       {0xa74c, 3036, 1},
       {0x1e4a, 1823, 1},
       {0x01d5, 441, 1},
       {0x014a, 276, 1},
       {0x1f4a, 2178, 1},
       {0x03d5, 810, 1},
       {0x00d5, 141, 1},
       {0x004a, 24, 1},
       {0x24bf, 2370, 1},
       {0xa74a, 3033, 1},
       {0xa64c, 2883, 1},
       {0x1041c, 3321, 1},
       {0x1e1c, 1754, 1},
       {0x041c, 926, 1},
       {0x011c, 213, 1},
       {0x1f1c, 2118, 1},
       {0x2c1c, 2505, 1},
       {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
       {0xa64a, 2880, 1},
       {0x1041a, 3315, 1},
       {0x1e1a, 1751, 1},
       {0x041a, 920, 1},
       {0x011a, 210, 1},
       {0x1f1a, 2112, 1},
       {0x2c1a, 2499, 1},
       {0xabbd, 1679, 1},
       {0x0545, 1394, 1},
       {0x054c, 1415, 1},
       {0x10418, 3309, 1},
       {0x1e18, 1748, 1},
       {0x0418, 914, 1},
       {0x0118, 207, 1},
       {0x1f18, 2106, 1},
       {0x2c18, 2493, 1},
       {0x10bd, 2832, 1},
       {0x2163, 2301, 1},
       {0x054a, 1409, 1},
       {0x1040e, 3279, 1},
       {0x1e0e, 1733, 1},
       {0x040e, 1028, 1},
       {0x010e, 192, 1},
       {0x1f0e, 2100, 1},
       {0x2c0e, 2463, 1},
       {0x1efc, 2076, 1},
       {0x04fc, 1256, 1},
       {0x01fc, 496, 1},
       {0x1ffc, 96, 2},
       {0x051c, 1304, 1},
       {0x1040c, 3273, 1},
       {0x1e0c, 1730, 1},
       {0x040c, 1022, 1},
       {0x010c, 189, 1},
       {0x1f0c, 2094, 1},
       {0x2c0c, 2457, 1},
       {0x1f6d, 2217, 1},
       {0x2c6d, 607, 1},
       {0x051a, 1301, 1},
       {0x24be, 2367, 1},
       {0x10408, 3261, 1},
       {0x1e08, 1724, 1},
       {0x0408, 1010, 1},
       {0x0108, 183, 1},
       {0x1f08, 2082, 1},
       {0x2c08, 2445, 1},
       {0x04c9, 1178, 1},
       {0x0518, 1298, 1},
       {0x1fc9, 2235, 1},
       {0xffffffff, -1, 0},
       {0x24ba, 2355, 1},
       {0x00c9, 105, 1},
       {0x10416, 3303, 1},
       {0x1e16, 1745, 1},
       {0x0416, 908, 1},
       {0x0116, 204, 1},
       {0x050e, 1283, 1},
       {0x2c16, 2487, 1},
       {0x10414, 3297, 1},
       {0x1e14, 1742, 1},
       {0x0414, 902, 1},
       {0x0114, 201, 1},
       {0x042b, 971, 1},
       {0x2c14, 2481, 1},
       {0x1f2b, 2133, 1},
       {0x2c2b, 2550, 1},
       {0xffffffff, -1, 0},
       {0x050c, 1280, 1},
       {0x10406, 3255, 1},
       {0x1e06, 1721, 1},
       {0x0406, 1004, 1},
       {0x0106, 180, 1},
       {0x13fb, 1697, 1},
       {0x2c06, 2439, 1},
       {0x24c2, 2379, 1},
       {0x118bd, 3597, 1},
       {0xffffffff, -1, 0},
       {0x0508, 1274, 1},
       {0x10404, 3249, 1},
       {0x1e04, 1718, 1},
       {0x0404, 998, 1},
       {0x0104, 177, 1},
       {0x1f95, 194, 2},
       {0x2c04, 2433, 1},
       {0x0395, 752, 1},
       {0x24ca, 2403, 1},
       {0xab95, 1559, 1},
       {0x0531, 1334, 1},
       {0x10c95, 3420, 1},
       {0x0516, 1295, 1},
       {0x1e6c, 1875, 1},
       {0x046c, 1052, 1},
       {0x016c, 327, 1},
       {0x1f6c, 2214, 1},
       {0x216d, 2331, 1},
       {0x0514, 1292, 1},
       {0x0245, 697, 1},
       {0x024c, 598, 1},
       {0xa76c, 3084, 1},
       {0x10400, 3237, 1},
       {0x1e00, 1712, 1},
       {0x0400, 986, 1},
       {0x0100, 171, 1},
       {0x24c4, 2385, 1},
       {0x2c00, 2421, 1},
       {0x0506, 1271, 1},
       {0x024a, 595, 1},
       {0x1fab, 224, 2},
       {0xa66c, 2931, 1},
       {0x03ab, 827, 1},
       {0x24cf, 2418, 1},
       {0xabab, 1625, 1},
       {0xa7ab, 631, 1},
       {0x10cab, 3486, 1},
       {0xffffffff, -1, 0},
       {0x0504, 1268, 1},
       {0xffffffff, -1, 0},
       {0x021c, 544, 1},
       {0x01a9, 679, 1},
       {0x1fa9, 214, 2},
       {0x10ab, 2778, 1},
       {0x03a9, 820, 1},
       {0x212b, 92, 1},
       {0xaba9, 1619, 1},
       {0x1e88, 1917, 1},
       {0x10ca9, 3480, 1},
       {0x021a, 541, 1},
       {0x1f88, 129, 2},
       {0x2c88, 2598, 1},
       {0x0388, 730, 1},
       {0x13fd, 1703, 1},
       {0xab88, 1520, 1},
       {0x10a9, 2772, 1},
       {0x10c88, 3381, 1},
       {0xffffffff, -1, 0},
       {0x0218, 538, 1},
       {0x0500, 1262, 1},
       {0x1f4d, 2187, 1},
       {0x01a7, 393, 1},
       {0x1fa7, 244, 2},
       {0x004d, 34, 1},
       {0x03a7, 814, 1},
       {0xa688, 2946, 1},
       {0xaba7, 1613, 1},
       {0x020e, 523, 1},
       {0x10ca7, 3474, 1},
       {0x1e6a, 1872, 1},
       {0x046a, 1049, 1},
       {0x016a, 324, 1},
       {0x1f6a, 2208, 1},
       {0xffffffff, -1, 0},
       {0x216c, 2328, 1},
       {0x10a7, 2766, 1},
       {0x01d1, 435, 1},
       {0xa76a, 3081, 1},
       {0x020c, 520, 1},
       {0x03d1, 762, 1},
       {0x00d1, 129, 1},
       {0x1e68, 1869, 1},
       {0x0468, 1046, 1},
       {0x0168, 321, 1},
       {0x1f68, 2202, 1},
       {0xffffffff, -1, 0},
       {0xff31, 3207, 1},
       {0xa66a, 2928, 1},
       {0x0208, 514, 1},
       {0xa768, 3078, 1},
       {0x1e64, 1863, 1},
       {0x0464, 1040, 1},
       {0x0164, 315, 1},
       {0x054d, 1418, 1},
       {0x2c64, 673, 1},
       {0xffffffff, -1, 0},
       {0xff2b, 3189, 1},
       {0xffffffff, -1, 0},
       {0xa764, 3072, 1},
       {0xa668, 2925, 1},
       {0x0216, 535, 1},
       {0xffffffff, -1, 0},
       {0x118ab, 3543, 1},
       {0x1e62, 1860, 1},
       {0x0462, 1037, 1},
       {0x0162, 312, 1},
       {0x0214, 532, 1},
       {0x2c62, 655, 1},
       {0xa664, 2919, 1},
       {0x1ed2, 2013, 1},
       {0x04d2, 1193, 1},
       {0xa762, 3069, 1},
       {0x1fd2, 20, 3},
       {0x2cd2, 2709, 1},
       {0x118a9, 3537, 1},
       {0x00d2, 132, 1},
       {0x0206, 511, 1},
       {0x10420, 3333, 1},
       {0x1e20, 1760, 1},
       {0x0420, 938, 1},
       {0x0120, 219, 1},
       {0xa662, 2916, 1},
       {0x2c20, 2517, 1},
       {0x1e60, 1856, 1},
       {0x0460, 1034, 1},
       {0x0160, 309, 1},
       {0x0204, 508, 1},
       {0x2c60, 2562, 1},
       {0xffffffff, -1, 0},
       {0x24bd, 2364, 1},
       {0x216a, 2322, 1},
       {0xa760, 3066, 1},
       {0xffffffff, -1, 0},
       {0xfb16, 125, 2},
       {0x118a7, 3531, 1},
       {0x1efa, 2073, 1},
       {0x04fa, 1253, 1},
       {0x01fa, 493, 1},
       {0x1ffa, 2262, 1},
       {0xfb14, 109, 2},
       {0x03fa, 887, 1},
       {0xa660, 2913, 1},
       {0x2168, 2316, 1},
       {0x01b7, 700, 1},
       {0x1fb7, 10, 3},
       {0x1f6b, 2211, 1},
       {0x2c6b, 2577, 1},
       {0x0200, 502, 1},
       {0xabb7, 1661, 1},
       {0xfb06, 29, 2},
       {0x1e56, 1841, 1},
       {0x2164, 2304, 1},
       {0x0156, 294, 1},
       {0x1f56, 62, 3},
       {0x0520, 1310, 1},
       {0x004f, 40, 1},
       {0x0056, 62, 1},
       {0x10b7, 2814, 1},
       {0xa756, 3051, 1},
       {0xfb04, 5, 3},
       {0x1e78, 1893, 1},
       {0x0478, 1070, 1},
       {0x0178, 168, 1},
       {0x1e54, 1838, 1},
       {0x2162, 2298, 1},
       {0x0154, 291, 1},
       {0x1f54, 57, 3},
       {0xab78, 1472, 1},
       {0xa656, 2898, 1},
       {0x0054, 56, 1},
       {0x1e52, 1835, 1},
       {0xa754, 3048, 1},
       {0x0152, 288, 1},
       {0x1f52, 52, 3},
       {0x24c9, 2400, 1},
       {0x1e32, 1787, 1},
       {0x0052, 49, 1},
       {0x0132, 243, 1},
       {0xa752, 3045, 1},
       {0xffffffff, -1, 0},
       {0xfb00, 4, 2},
       {0xa654, 2895, 1},
       {0xffffffff, -1, 0},
       {0xa732, 2997, 1},
       {0x2160, 2292, 1},
       {0x054f, 1424, 1},
       {0x0556, 1445, 1},
       {0x1e50, 1832, 1},
       {0xa652, 2892, 1},
       {0x0150, 285, 1},
       {0x1f50, 84, 2},
       {0x017b, 348, 1},
       {0x1e4e, 1829, 1},
       {0x0050, 43, 1},
       {0x014e, 282, 1},
       {0xa750, 3042, 1},
       {0xab7b, 1481, 1},
       {0xa77b, 3093, 1},
       {0x004e, 37, 1},
       {0x0554, 1439, 1},
       {0xa74e, 3039, 1},
       {0x1e48, 1820, 1},
       {0xffffffff, -1, 0},
       {0x216b, 2325, 1},
       {0x1f48, 2172, 1},
       {0xa650, 2889, 1},
       {0x0552, 1433, 1},
       {0x0048, 21, 1},
       {0xffffffff, -1, 0},
       {0xa748, 3030, 1},
       {0xa64e, 2886, 1},
       {0x0532, 1337, 1},
       {0x1041e, 3327, 1},
       {0x1e1e, 1757, 1},
       {0x041e, 932, 1},
       {0x011e, 216, 1},
       {0x118b7, 3579, 1},
       {0x2c1e, 2511, 1},
       {0xffffffff, -1, 0},
       {0xa648, 2877, 1},
       {0x1ff9, 2253, 1},
       {0xffffffff, -1, 0},
       {0x03f9, 878, 1},
       {0x0550, 1427, 1},
       {0x10412, 3291, 1},
       {0x1e12, 1739, 1},
       {0x0412, 896, 1},
       {0x0112, 198, 1},
       {0x054e, 1421, 1},
       {0x2c12, 2475, 1},
       {0x10410, 3285, 1},
       {0x1e10, 1736, 1},
       {0x0410, 890, 1},
       {0x0110, 195, 1},
       {0xffffffff, -1, 0},
       {0x2c10, 2469, 1},
       {0x2132, 2289, 1},
       {0x0548, 1403, 1},
       {0x1ef8, 2070, 1},
       {0x04f8, 1250, 1},
       {0x01f8, 490, 1},
       {0x1ff8, 2250, 1},
       {0x0220, 381, 1},
       {0x1ee2, 2037, 1},
       {0x04e2, 1217, 1},
       {0x01e2, 462, 1},
       {0x1fe2, 36, 3},
       {0x2ce2, 2733, 1},
       {0x03e2, 857, 1},
       {0x051e, 1307, 1},
       {0x1ede, 2031, 1},
       {0x04de, 1211, 1},
       {0x01de, 456, 1},
       {0xffffffff, -1, 0},
       {0x2cde, 2727, 1},
       {0x03de, 851, 1},
       {0x00de, 165, 1},
       {0x1f69, 2205, 1},
       {0x2c69, 2574, 1},
       {0x1eda, 2025, 1},
       {0x04da, 1205, 1},
       {0x0512, 1289, 1},
       {0x1fda, 2244, 1},
       {0x2cda, 2721, 1},
       {0x03da, 845, 1},
       {0x00da, 153, 1},
       {0xffffffff, -1, 0},
       {0x0510, 1286, 1},
       {0x1ed8, 2022, 1},
       {0x04d8, 1202, 1},
       {0xffffffff, -1, 0},
       {0x1fd8, 2274, 1},
       {0x2cd8, 2718, 1},
       {0x03d8, 842, 1},
       {0x00d8, 147, 1},
       {0x1ed6, 2019, 1},
       {0x04d6, 1199, 1},
       {0xffffffff, -1, 0},
       {0x1fd6, 76, 2},
       {0x2cd6, 2715, 1},
       {0x03d6, 792, 1},
       {0x00d6, 144, 1},
       {0x1ec8, 1998, 1},
       {0xffffffff, -1, 0},
       {0x01c8, 421, 1},
       {0x1fc8, 2232, 1},
       {0x2cc8, 2694, 1},
       {0xff32, 3210, 1},
       {0x00c8, 102, 1},
       {0x04c7, 1175, 1},
       {0x01c7, 421, 1},
       {0x1fc7, 15, 3},
       {0x1ec0, 1986, 1},
       {0x04c0, 1187, 1},
       {0x00c7, 99, 1},
       {0xffffffff, -1, 0},
       {0x2cc0, 2682, 1},
       {0x0179, 345, 1},
       {0x00c0, 77, 1},
       {0x0232, 574, 1},
       {0x01b3, 402, 1},
       {0x1fb3, 62, 2},
       {0xab79, 1475, 1},
       {0xa779, 3090, 1},
       {0x10c7, 2859, 1},
       {0xabb3, 1649, 1},
       {0xa7b3, 3156, 1},
       {0x1fa5, 234, 2},
       {0x10c0, 2841, 1},
       {0x03a5, 807, 1},
       {0xffffffff, -1, 0},
       {0xaba5, 1607, 1},
       {0x01b1, 691, 1},
       {0x10ca5, 3468, 1},
       {0x10b3, 2802, 1},
       {0x2169, 2319, 1},
       {0x024e, 601, 1},
       {0xabb1, 1643, 1},
       {0xa7b1, 682, 1},
       {0x10cb1, 3504, 1},
       {0x10a5, 2760, 1},
       {0xffffffff, -1, 0},
       {0x01af, 399, 1},
       {0x1faf, 244, 2},
       {0xffffffff, -1, 0},
       {0x0248, 592, 1},
       {0x10b1, 2796, 1},
       {0xabaf, 1637, 1},
       {0x1fad, 234, 2},
       {0x10caf, 3498, 1},
       {0x04cd, 1184, 1},
       {0x01cd, 429, 1},
       {0xabad, 1631, 1},
       {0xa7ad, 658, 1},
       {0x10cad, 3492, 1},
       {0x00cd, 117, 1},
       {0x10af, 2790, 1},
       {0x021e, 547, 1},
       {0x1fa3, 224, 2},
       {0xffffffff, -1, 0},
       {0x03a3, 800, 1},
       {0x10ad, 2784, 1},
       {0xaba3, 1601, 1},
       {0xffffffff, -1, 0},
       {0x10ca3, 3462, 1},
       {0x10cd, 2862, 1},
       {0x1fa1, 214, 2},
       {0x24b7, 2346, 1},
       {0x03a1, 796, 1},
       {0x0212, 529, 1},
       {0xaba1, 1595, 1},
       {0x10a3, 2754, 1},
       {0x10ca1, 3456, 1},
       {0x01d3, 438, 1},
       {0x1fd3, 25, 3},
       {0x0210, 526, 1},
       {0xffffffff, -1, 0},
       {0x00d3, 135, 1},
       {0x1e97, 34, 2},
       {0x10a1, 2748, 1},
       {0x0197, 649, 1},
       {0x1f97, 204, 2},
       {0xffffffff, -1, 0},
       {0x0397, 759, 1},
       {0x1041d, 3324, 1},
       {0xab97, 1565, 1},
       {0x041d, 929, 1},
       {0x10c97, 3426, 1},
       {0x1f1d, 2121, 1},
       {0x2c1d, 2508, 1},
       {0x1e72, 1884, 1},
       {0x0472, 1061, 1},
       {0x0172, 336, 1},
       {0x118b3, 3567, 1},
       {0x2c72, 2580, 1},
       {0x0372, 712, 1},
       {0x1041b, 3318, 1},
       {0xab72, 1454, 1},
       {0x041b, 923, 1},
       {0x118a5, 3525, 1},
       {0x1f1b, 2115, 1},
       {0x2c1b, 2502, 1},
       {0x1e70, 1881, 1},
       {0x0470, 1058, 1},
       {0x0170, 333, 1},
       {0x118b1, 3561, 1},
       {0x2c70, 610, 1},
       {0x0370, 709, 1},
       {0x1e46, 1817, 1},
       {0xab70, 1448, 1},
       {0x1e66, 1866, 1},
       {0x0466, 1043, 1},
       {0x0166, 318, 1},
       {0x1e44, 1814, 1},
       {0x0046, 15, 1},
       {0x118af, 3555, 1},
       {0xa746, 3027, 1},
       {0xffffffff, -1, 0},
       {0xa766, 3075, 1},
       {0x0044, 9, 1},
       {0x118ad, 3549, 1},
       {0xa744, 3024, 1},
       {0x1e7a, 1896, 1},
       {0x047a, 1073, 1},
       {0x1e3a, 1799, 1},
       {0xffffffff, -1, 0},
       {0xa646, 2874, 1},
       {0x1f3a, 2154, 1},
       {0xa666, 2922, 1},
       {0xab7a, 1478, 1},
       {0x118a3, 3519, 1},
       {0xa644, 2871, 1},
       {0xa73a, 3009, 1},
       {0xffffffff, -1, 0},
       {0x1ef4, 2064, 1},
       {0x04f4, 1244, 1},
       {0x01f4, 487, 1},
       {0x1ff4, 101, 2},
       {0x118a1, 3513, 1},
       {0x03f4, 762, 1},
       {0x1eec, 2052, 1},
       {0x04ec, 1232, 1},
       {0x01ec, 477, 1},
       {0x1fec, 2286, 1},
       {0x0546, 1397, 1},
       {0x03ec, 872, 1},
       {0xffffffff, -1, 0},
       {0x013f, 261, 1},
       {0x1f3f, 2169, 1},
       {0x0544, 1391, 1},
       {0x1eea, 2049, 1},
       {0x04ea, 1229, 1},
       {0x01ea, 474, 1},
       {0x1fea, 2256, 1},
       {0xffffffff, -1, 0},
       {0x03ea, 869, 1},
       {0x1ee8, 2046, 1},
       {0x04e8, 1226, 1},
       {0x01e8, 471, 1},
       {0x1fe8, 2280, 1},
       {0x053a, 1361, 1},
       {0x03e8, 866, 1},
       {0x1ee6, 2043, 1},
       {0x04e6, 1223, 1},
       {0x01e6, 468, 1},
       {0x1fe6, 88, 2},
       {0x1f4b, 2181, 1},
       {0x03e6, 863, 1},
       {0x1e5e, 1853, 1},
       {0x004b, 27, 1},
       {0x015e, 306, 1},
       {0x2166, 2310, 1},
       {0x1ee4, 2040, 1},
       {0x04e4, 1220, 1},
       {0x01e4, 465, 1},
       {0x1fe4, 80, 2},
       {0xa75e, 3063, 1},
       {0x03e4, 860, 1},
       {0x1ee0, 2034, 1},
       {0x04e0, 1214, 1},
       {0x01e0, 459, 1},
       {0x053f, 1376, 1},
       {0x2ce0, 2730, 1},
       {0x03e0, 854, 1},
       {0x1edc, 2028, 1},
       {0x04dc, 1208, 1},
       {0xa65e, 2910, 1},
       {0xffffffff, -1, 0},
       {0x2cdc, 2724, 1},
       {0x03dc, 848, 1},
       {0x00dc, 159, 1},
       {0x1ed0, 2010, 1},
       {0x04d0, 1190, 1},
       {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
       {0x2cd0, 2706, 1},
       {0x03d0, 742, 1},
       {0x00d0, 126, 1},
       {0x1ecc, 2004, 1},
       {0x054b, 1412, 1},
       {0xffffffff, -1, 0},
       {0x1fcc, 71, 2},
       {0x2ccc, 2700, 1},
       {0x1ec6, 1995, 1},
       {0x00cc, 114, 1},
       {0xffffffff, -1, 0},
       {0x1fc6, 67, 2},
       {0x2cc6, 2691, 1},
       {0x24c8, 2397, 1},
       {0x00c6, 96, 1},
       {0x04c5, 1172, 1},
       {0x01c5, 417, 1},
       {0xffffffff, -1, 0},
       {0x1fbb, 2229, 1},
       {0x24c7, 2394, 1},
       {0x00c5, 92, 1},
       {0x1fb9, 2271, 1},
       {0xabbb, 1673, 1},
       {0x24c0, 2373, 1},
       {0x04c3, 1169, 1},
       {0xabb9, 1667, 1},
       {0x1fc3, 71, 2},
       {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
       {0x00c3, 86, 1},
       {0x10c5, 2856, 1},
       {0x10bb, 2826, 1},
       {0x1ed4, 2016, 1},
       {0x04d4, 1196, 1},
       {0x10b9, 2820, 1},
       {0x13fc, 1700, 1},
       {0x2cd4, 2712, 1},
       {0x0246, 589, 1},
       {0x00d4, 138, 1},
       {0x10c3, 2850, 1},
       {0xffffffff, -1, 0},
       {0xff3a, 3234, 1},
       {0x0244, 688, 1},
       {0x019f, 670, 1},
       {0x1f9f, 204, 2},
       {0xffffffff, -1, 0},
       {0x039f, 789, 1},
       {0xffffffff, -1, 0},
       {0xab9f, 1589, 1},
       {0xffffffff, -1, 0},
       {0x10c9f, 3450, 1},
       {0x019d, 667, 1},
       {0x1f9d, 194, 2},
       {0x023a, 2565, 1},
       {0x039d, 783, 1},
       {0x1e5a, 1847, 1},
       {0xab9d, 1583, 1},
       {0x015a, 300, 1},
       {0x10c9d, 3444, 1},
       {0x1e9b, 1856, 1},
       {0x24cd, 2412, 1},
       {0x005a, 74, 1},
       {0x1f9b, 184, 2},
       {0xa75a, 3057, 1},
       {0x039b, 776, 1},
       {0x1ece, 2007, 1},
       {0xab9b, 1577, 1},
       {0x1e99, 42, 2},
       {0x10c9b, 3438, 1},
       {0x2cce, 2703, 1},
       {0x1f99, 174, 2},
       {0x00ce, 120, 1},
       {0x0399, 767, 1},
       {0xa65a, 2904, 1},
       {0xab99, 1571, 1},
       {0xffffffff, -1, 0},
       {0x10c99, 3432, 1},
       {0x0193, 634, 1},
       {0x1f93, 184, 2},
       {0x1e58, 1844, 1},
       {0x0393, 746, 1},
       {0x0158, 297, 1},
       {0xab93, 1553, 1},
       {0xffffffff, -1, 0},
       {0x10c93, 3414, 1},
       {0x0058, 68, 1},
       {0x042d, 977, 1},
       {0xa758, 3054, 1},
       {0x1f2d, 2139, 1},
       {0x2c2d, 2556, 1},
       {0x118bb, 3591, 1},
       {0x0191, 369, 1},
       {0x1f91, 174, 2},
       {0x118b9, 3585, 1},
       {0x0391, 739, 1},
       {0xffffffff, -1, 0},
       {0xab91, 1547, 1},
       {0xa658, 2901, 1},
       {0x10c91, 3408, 1},
       {0x018f, 625, 1},
       {0x1f8f, 164, 2},
       {0xffffffff, -1, 0},
       {0x038f, 836, 1},
       {0xffffffff, -1, 0},
       {0xab8f, 1541, 1},
       {0xffffffff, -1, 0},
       {0x10c8f, 3402, 1},
       {0x018b, 366, 1},
       {0x1f8b, 144, 2},
       {0xffffffff, -1, 0},
       {0x0187, 363, 1},
       {0x1f87, 164, 2},
       {0xab8b, 1529, 1},
       {0xa78b, 3111, 1},
       {0x10c8b, 3390, 1},
       {0xab87, 1517, 1},
       {0x04c1, 1166, 1},
       {0x10c87, 3378, 1},
       {0x1e7e, 1902, 1},
       {0x047e, 1079, 1},
       {0xffffffff, -1, 0},
       {0x00c1, 80, 1},
       {0x2c7e, 580, 1},
       {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
       {0xab7e, 1490, 1},
       {0xa77e, 3096, 1},
       {0x1e76, 1890, 1},
       {0x0476, 1067, 1},
       {0x0176, 342, 1},
       {0x1e42, 1811, 1},
       {0x10c1, 2844, 1},
       {0x0376, 715, 1},
       {0x1e36, 1793, 1},
       {0xab76, 1466, 1},
       {0x0136, 249, 1},
       {0x0042, 3, 1},
       {0x1e3e, 1805, 1},
       {0xa742, 3021, 1},
       {0x1e38, 1796, 1},
       {0x1f3e, 2166, 1},
       {0xa736, 3003, 1},
       {0x1f38, 2148, 1},
       {0xffffffff, -1, 0},
       {0x0587, 105, 2},
       {0xa73e, 3015, 1},
       {0xffffffff, -1, 0},
       {0xa738, 3006, 1},
       {0xa642, 2868, 1},
       {0x1e5c, 1850, 1},
       {0x1e34, 1790, 1},
       {0x015c, 303, 1},
       {0x0134, 246, 1},
       {0x1ef6, 2067, 1},
       {0x04f6, 1247, 1},
       {0x01f6, 372, 1},
       {0x1ff6, 92, 2},
       {0xa75c, 3060, 1},
       {0xa734, 3000, 1},
       {0x1ef0, 2058, 1},
       {0x04f0, 1238, 1},
       {0x01f0, 20, 2},
       {0xffffffff, -1, 0},
       {0x1e30, 1784, 1},
       {0x03f0, 772, 1},
       {0x0130, 261, 2},
       {0x0542, 1385, 1},
       {0xa65c, 2907, 1},
       {0x1f83, 144, 2},
       {0x0536, 1349, 1},
       {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
       {0xab83, 1505, 1},
       {0x053e, 1373, 1},
       {0x10c83, 3366, 1},
       {0x0538, 1355, 1},
       {0x1eee, 2055, 1},
       {0x04ee, 1235, 1},
       {0x01ee, 480, 1},
       {0x1f8d, 154, 2},
       {0xffffffff, -1, 0},
       {0x03ee, 875, 1},
       {0xffffffff, -1, 0},
       {0xab8d, 1535, 1},
       {0xa78d, 643, 1},
       {0x10c8d, 3396, 1},
       {0x0534, 1343, 1},
       {0x0181, 613, 1},
       {0x1f81, 134, 2},
       {0x013d, 258, 1},
       {0x1f3d, 2163, 1},
       {0xffffffff, -1, 0},
       {0xab81, 1499, 1},
       {0x017f, 52, 1},
       {0x10c81, 3360, 1},
       {0x2c7f, 583, 1},
       {0x037f, 881, 1},
       {0xff2d, 3195, 1},
       {0xab7f, 1493, 1},
       {0x1e74, 1887, 1},
       {0x0474, 1064, 1},
       {0x0174, 339, 1},
       {0x1e3c, 1802, 1},
       {0x0149, 46, 2},
       {0x1f49, 2175, 1},
       {0x1f3c, 2160, 1},
       {0xab74, 1460, 1},
       {0x0049, 3606, 1},
       {0x0143, 267, 1},
       {0x24cc, 2409, 1},
       {0xa73c, 3012, 1},
       {0xffffffff, -1, 0},
       {0x0043, 6, 1},
       {0x0141, 264, 1},
       {0x24c6, 2391, 1},
       {0x013b, 255, 1},
       {0x1f3b, 2157, 1},
       {0x0041, 0, 1},
       {0x0139, 252, 1},
       {0x1f39, 2151, 1},
       {0x24c5, 2388, 1},
       {0x24bb, 2358, 1},
       {0x13fa, 1694, 1},
       {0x053d, 1370, 1},
       {0x24b9, 2352, 1},
       {0x0429, 965, 1},
       {0x2183, 2340, 1},
       {0x1f29, 2127, 1},
       {0x2c29, 2544, 1},
       {0x24c3, 2382, 1},
       {0x10427, 3354, 1},
       {0x10425, 3348, 1},
       {0x0427, 959, 1},
       {0x0425, 953, 1},
       {0xffffffff, -1, 0},
       {0x2c27, 2538, 1},
       {0x2c25, 2532, 1},
       {0x0549, 1406, 1},
       {0x053c, 1367, 1},
       {0x10423, 3342, 1},
       {0xffffffff, -1, 0},
       {0x0423, 947, 1},
       {0x0543, 1388, 1},
       {0xffffffff, -1, 0},
       {0x2c23, 2526, 1},
       {0xff36, 3222, 1},
       {0xffffffff, -1, 0},
       {0x0541, 1382, 1},
       {0x10421, 3336, 1},
       {0x053b, 1364, 1},
       {0x0421, 941, 1},
       {0xff38, 3228, 1},
       {0x0539, 1358, 1},
       {0x2c21, 2520, 1},
       {0x10419, 3312, 1},
       {0x10417, 3306, 1},
       {0x0419, 917, 1},
       {0x0417, 911, 1},
       {0x1f19, 2109, 1},
       {0x2c19, 2496, 1},
       {0x2c17, 2490, 1},
       {0x023e, 2568, 1},
       {0xff34, 3216, 1},
       {0x10415, 3300, 1},
       {0x10413, 3294, 1},
       {0x0415, 905, 1},
       {0x0413, 899, 1},
       {0xffffffff, -1, 0},
       {0x2c15, 2484, 1},
       {0x2c13, 2478, 1},
       {0xffffffff, -1, 0},
       {0x24ce, 2415, 1},
       {0x1040f, 3282, 1},
       {0xffffffff, -1, 0},
       {0x040f, 1031, 1},
       {0xff30, 3204, 1},
       {0x1f0f, 2103, 1},
       {0x2c0f, 2466, 1},
       {0x1040d, 3276, 1},
       {0xffffffff, -1, 0},
       {0x040d, 1025, 1},
       {0x0147, 273, 1},
       {0x1f0d, 2097, 1},
       {0x2c0d, 2460, 1},
       {0x1040b, 3270, 1},
       {0x0047, 18, 1},
       {0x040b, 1019, 1},
       {0x0230, 571, 1},
       {0x1f0b, 2091, 1},
       {0x2c0b, 2454, 1},
       {0x10409, 3264, 1},
       {0x10405, 3252, 1},
       {0x0409, 1013, 1},
       {0x0405, 1001, 1},
       {0x1f09, 2085, 1},
       {0x2c09, 2448, 1},
       {0x2c05, 2436, 1},
       {0x10403, 3246, 1},
       {0x10401, 3240, 1},
       {0x0403, 995, 1},
       {0x0401, 989, 1},
       {0xffffffff, -1, 0},
       {0x2c03, 2430, 1},
       {0x2c01, 2424, 1},
       {0x13f9, 1691, 1},
       {0x042f, 983, 1},
       {0xffffffff, -1, 0},
       {0x1f2f, 2145, 1},
       {0x1041f, 3330, 1},
       {0xffffffff, -1, 0},
       {0x041f, 935, 1},
       {0x023d, 378, 1},
       {0x10411, 3288, 1},
       {0x2c1f, 2514, 1},
       {0x0411, 893, 1},
       {0x0547, 1400, 1},
       {0xffffffff, -1, 0},
       {0x2c11, 2472, 1},
       {0x10407, 3258, 1},
       {0xffffffff, -1, 0},
       {0x0407, 1007, 1},
       {0x24c1, 2376, 1},
       {0xffffffff, -1, 0},
       {0x2c07, 2442, 1},
       {0xffffffff, -1, 0},
       {0x13f8, 1688, 1},
       {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
       {0xff39, 3231, 1},
       {0xffffffff, -1, 0},
       {0x0243, 354, 1},
       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
       {0x0241, 586, 1},
       {0xff29, 3183, 1},
       {0x023b, 577, 1},
       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
       {0xff27, 3177, 1},
       {0xff25, 3171, 1},
       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
       {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
       {0xff23, 3165, 1},
       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
       {0xff21, 3159, 1},
       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
       {0xffffffff, -1, 0},
       {0xfb17, 117, 2},
       {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
       {0xff2f, 3201, 1},
       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
       {0xfb15, 113, 2},
       {0xfb13, 121, 2},
       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
       {0xffffffff, -1, 0},
       {0xfb05, 29, 2},
       {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},
       {0xfb03, 0, 3},
       {0xfb01, 8, 2}
     };
   if (0 == 0)
     {
       int key = hash(&code);
       if (key <= MAX_HASH_VALUE && key >= 0)
          {
            OnigCodePoint gcode = wordlist[key].code;
          if (code == gcode)
           if (code == gcode && wordlist[key].index >= 0)
              return &wordlist[key];
          }
      }
   return 0;
 }","[1456, 1457]","An issue was discovered in Oniguruma 6.2.0, as used in Oniguruma-mod in Ruby through 2.4.1 and mbstring in PHP through 7.1.5. A stack out-of-bounds write in onigenc_unicode_get_case_fold_codes_by_str() occurs during regular expression compilation. Code point 0xFFFFFFFF is not properly handled in unicode_unfold_key(). A malformed regular expression could result in 4 bytes being written off the end of a stack buffer of expand_case_fold_string() during the call to onigenc_unicode_get_case_fold_codes_by_str(), a typical stack buffer overflow.",oniguruma,CVE-2017-9225,CWE-787
4945,182881," static int burl_normalize_2F_to_slash_fix (buffer *b, int qs, int i)
 {
     char * const s = b->ptr;
     const int blen = (int)buffer_string_length(b);
     const int used = qs < 0 ? blen : qs;
     int j = i;
     for (; i < used; ++i, ++j) {
         s[j] = s[i];
         if (s[i] == '%' && s[i+1] == '2' && s[i+2] == 'F') {
             s[j] = '/';
             i+=2;
          }
      }
      if (qs >= 0) {
        memmove(s+j, s+qs, blen - qs);
        j += blen - qs;
         const int qslen = blen - qs;
         memmove(s+j, s+qs, (size_t)qslen);
         qs = j;
         j += qslen;
      }
      buffer_string_set_length(b, j);
      return qs;
 }","[15, 16, 17, 18, 19, 20]","** DISPUTED ** lighttpd before 1.4.54 has a signed integer overflow, which might allow remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a malicious HTTP GET request, as demonstrated by mishandling of /%2F? in burl_normalize_2F_to_slash_fix in burl.c. NOTE: The developer states *The feature which can be abused to cause the crash is a new feature in lighttpd 1.4.50, and is not enabled by default. It must be explicitly configured in the config file (e.g. lighttpd.conf). Certain input will trigger an abort() in lighttpd when that feature is enabled. lighttpd detects the underflow or realloc() will fail (in both 32-bit and 64-bit executables), also detected in lighttpd. Either triggers an explicit abort() by lighttpd. This is not exploitable beyond triggering the explicit abort() with subsequent application exit.*",lighttpd1.4,CVE-2019-11072,CWE-190
4966,179874," static bool do_write_pids(pid_t tpid, const char *contrl, const char *cg, const char *file, const char *buf)
 bool hostuid_to_ns(uid_t uid, pid_t pid, uid_t *answer)
 {
 	FILE *f;
 	char line[400];
 	sprintf(line, ""/proc/%d/uid_map"", pid);
 	if ((f = fopen(line, ""r"")) == NULL) {
 		return false;
 	}
 	*answer = convert_id_to_ns(f, uid);
 	fclose(f);
 	if (*answer == -1)
 		return false;
 	return true;
 }
 void get_pid_creds(pid_t pid, uid_t *uid, gid_t *gid)
 {
 	char line[400];
 	uid_t u;
 	gid_t g;
 	FILE *f;
 	*uid = -1;
 	*gid = -1;
 	sprintf(line, ""/proc/%d/status"", pid);
 	if ((f = fopen(line, ""r"")) == NULL) {
 		fprintf(stderr, ""Error opening %s: %s\n"", line, strerror(errno));
 		return;
 	}
 	while (fgets(line, 400, f)) {
 		if (strncmp(line, ""Uid:"", 4) == 0) {
 			if (sscanf(line+4, ""%u"", &u) != 1) {
 				fprintf(stderr, ""bad uid line for pid %u\n"", pid);
 				fclose(f);
 				return;
 			}
 			*uid = u;
 		} else if (strncmp(line, ""Gid:"", 4) == 0) {
 			if (sscanf(line+4, ""%u"", &g) != 1) {
 				fprintf(stderr, ""bad gid line for pid %u\n"", pid);
 				fclose(f);
 				return;
 			}
 			*gid = g;
 		}
 	}
 	fclose(f);
 }
 bool may_move_pid(pid_t r, uid_t r_uid, pid_t v)
 {
 	uid_t v_uid, tmpuid;
 	gid_t v_gid;
 	if (r == v)
 		return true;
 	if (r_uid == 0)
 		return true;
 	get_pid_creds(v, &v_uid, &v_gid);
 	if (r_uid == v_uid)
 		return true;
 	if (hostuid_to_ns(r_uid, r, &tmpuid) && tmpuid == 0
 			&& hostuid_to_ns(v_uid, r, &tmpuid))
 		return true;
 	return false;
 }
 static bool do_write_pids(pid_t tpid, uid_t tuid, const char *contrl, const char *cg,
 		const char *file, const char *buf)
  {
  	int sock[2] = {-1, -1};
  	pid_t qpid, cpid = -1;
 	FILE *pids_file = NULL;
 	bool answer = false, fail = false;
 	pids_file = open_pids_file(contrl, cg);
 	if (!pids_file)
 		return false;
 	if (socketpair(AF_UNIX, SOCK_DGRAM, 0, sock) < 0) {
 		perror(""socketpair"");
 		goto out;
 	}
 	cpid = fork();
 	if (cpid == -1)
 		goto out;
 	if (!cpid) {  
 		fclose(pids_file);
 		pid_from_ns_wrapper(sock[1], tpid);
 	}
 	const char *ptr = buf;
 	while (sscanf(ptr, ""%d"", &qpid) == 1) {
 		struct ucred cred;
 		char v;
 		if (write(sock[0], &qpid, sizeof(qpid)) != sizeof(qpid)) {
 			fprintf(stderr, ""%s: error writing pid to child: %s\n"",
 				__func__, strerror(errno));
 			goto out;
 		}
  		if (recv_creds(sock[0], &cred, &v)) {
  			if (v == '0') {
 				if (!may_move_pid(tpid, tuid, cred.pid)) {
 					fail = true;
 					break;
 				}
  				if (fprintf(pids_file, ""%d"", (int) cred.pid) < 0)
  					fail = true;
  			}
 		}
 		ptr = strchr(ptr, '\n');
 		if (!ptr)
 			break;
 		ptr++;
 	}
 	qpid = -1;
 	if (write(sock[0], &qpid ,sizeof(qpid)) != sizeof(qpid))
 		fprintf(stderr, ""Warning: failed to ask child to exit\n"");
 	if (!fail)
 		answer = true;
 out:
 	if (cpid != -1)
 		wait_for_pid(cpid);
 	if (sock[0] != -1) {
 		close(sock[0]);
 		close(sock[1]);
 	}
 	if (pids_file) {
 		if (fclose(pids_file) != 0)
 			answer = false;
 	}
 	return answer;
 }","[2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 96, 97, 98, 99]","The do_write_pids function in lxcfs.c in LXCFS before 0.12 does not properly check permissions, which allows local users to gain privileges by writing a pid to the tasks file.",lxcfs,CVE-2015-1344,CWE-264
4990,181677," static int store_icy(URLContext *h, int size)
  {
      HTTPContext *s = h->priv_data;
    int remaining = s->icy_metaint - s->icy_data_read;
     uint64_t remaining;
    if (remaining < 0)
     if (s->icy_metaint < s->icy_data_read)
          return AVERROR_INVALIDDATA;
     remaining = s->icy_metaint - s->icy_data_read;
      if (!remaining) {
         uint8_t ch;
         int len = http_read_stream_all(h, &ch, 1);
         if (len < 0)
             return len;
         if (ch > 0) {
             char data[255 * 16 + 1];
             int ret;
             len = ch * 16;
             ret = http_read_stream_all(h, data, len);
             if (ret < 0)
                 return ret;
             data[len + 1] = 0;
             if ((ret = av_opt_set(s, ""icy_metadata_packet"", data, 0)) < 0)
                 return ret;
             update_metadata(s, data);
         }
         s->icy_data_read = 0;
         remaining        = s->icy_metaint;
     }
     return FFMIN(size, remaining);
 }","[4, 5, 6, 7, 9]","Heap-based buffer overflow in libavformat/http.c in FFmpeg before 2.8.10, 3.0.x before 3.0.5, 3.1.x before 3.1.6, and 3.2.x before 3.2.2 allows remote web servers to execute arbitrary code via a negative chunk size in an HTTP response.",FFmpeg,CVE-2016-10190,CWE-119
5009,182519," formUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form)
 {
     Buffer save;
     char *p;
     int spos, epos, rows, c_rows, pos, col = 0;
     Line *l;
     copyBuffer(&save, buf);
     gotoLine(buf, a->start.line);
     switch (form->type) {
     case FORM_TEXTAREA:
     case FORM_INPUT_TEXT:
     case FORM_INPUT_FILE:
     case FORM_INPUT_PASSWORD:
     case FORM_INPUT_CHECKBOX:
     case FORM_INPUT_RADIO:
 #ifdef MENU_SELECT
     case FORM_SELECT:
 #endif				 
 	spos = a->start.pos;
 	epos = a->end.pos;
 	break;
     default:
 	spos = a->start.pos + 1;
 	epos = a->end.pos - 1;
     }
     switch (form->type) {
     case FORM_INPUT_CHECKBOX:
     case FORM_INPUT_RADIO:
 	if (buf->currentLine == NULL ||
 	    spos >= buf->currentLine->len || spos < 0)
 	    break;
 	if (form->checked)
 	    buf->currentLine->lineBuf[spos] = '*';
 	else
 	    buf->currentLine->lineBuf[spos] = ' ';
 	break;
     case FORM_INPUT_TEXT:
     case FORM_INPUT_FILE:
     case FORM_INPUT_PASSWORD:
     case FORM_TEXTAREA:
 #ifdef MENU_SELECT
     case FORM_SELECT:
 	if (form->type == FORM_SELECT) {
 	    p = form->label->ptr;
 	    updateSelectOption(form, form->select_option);
 	}
 	else
 #endif				 
 	{
 	    if (!form->value)
 		break;
 	    p = form->value->ptr;
 	}
 	l = buf->currentLine;
 	if (!l)
 	    break;
 	if (form->type == FORM_TEXTAREA) {
 	    int n = a->y - buf->currentLine->linenumber;
 	    if (n > 0)
 		for (; l && n; l = l->prev, n--) ;
 	    else if (n < 0)
 		for (; l && n; l = l->prev, n++) ;
 	    if (!l)
 		break;
 	}
  	rows = form->rows ? form->rows : 1;
  	col = COLPOS(l, a->start.pos);
  	for (c_rows = 0; c_rows < rows; c_rows++, l = l->next) {
 	    if (l == NULL)
 		break;
  	    if (rows > 1) {
  		pos = columnPos(l, col);
  		a = retrieveAnchor(buf->formitem, l->linenumber, pos);
 		if (a == NULL)
 		    break;
 		spos = a->start.pos;
 		epos = a->end.pos;
 	    }
 	    if (a->start.line != a->end.line || spos > epos || epos >= l->len ||
 		spos < 0 || epos < 0 || COLPOS(l, epos) < col)
 		break;
 	    pos = form_update_line(l, &p, spos, epos, COLPOS(l, epos) - col,
 				   rows > 1,
 				   form->type == FORM_INPUT_PASSWORD);
 	    if (pos != epos) {
 		shiftAnchorPosition(buf->href, buf->hmarklist,
 				    a->start.line, spos, pos - epos);
 		shiftAnchorPosition(buf->name, buf->hmarklist,
 				    a->start.line, spos, pos - epos);
 		shiftAnchorPosition(buf->img, buf->hmarklist,
 				    a->start.line, spos, pos - epos);
 		shiftAnchorPosition(buf->formitem, buf->hmarklist,
 				    a->start.line, spos, pos - epos);
 	    }
 	}
 	break;
     }
     copyBuffer(buf, &save);
     arrangeLine(buf);
 }","[69, 70]",w3m through 0.5.3 is prone to a NULL pointer dereference flaw in formUpdateBuffer in form.c.,w3m,CVE-2018-6197,CWE-476
5019,182874," static void ctrycatchfinally(JF, js_Ast *trystm, js_Ast *catchvar, js_Ast *catchstm, js_Ast *finallystm)
 {
 	int L1, L2, L3;
 	L1 = emitjump(J, F, OP_TRY);
 	{
 		L2 = emitjump(J, F, OP_TRY);
 		{
 			cstm(J, F, finallystm);  
 			emit(J, F, OP_THROW);  
 		}
 		label(J, F, L2);
 		if (F->strict) {
 			checkfutureword(J, F, catchvar);
 			if (!strcmp(catchvar->string, ""arguments""))
 				jsC_error(J, catchvar, ""redefining 'arguments' is not allowed in strict mode"");
 			if (!strcmp(catchvar->string, ""eval""))
 				jsC_error(J, catchvar, ""redefining 'eval' is not allowed in strict mode"");
 		}
 		emitline(J, F, catchvar);
  		emitstring(J, F, OP_CATCH, catchvar->string);
  		cstm(J, F, catchstm);
  		emit(J, F, OP_ENDCATCH);
 		emit(J, F, OP_ENDTRY);
  		L3 = emitjump(J, F, OP_JUMP);  
  	}
  	label(J, F, L1);
 	cstm(J, F, trystm);
 	emit(J, F, OP_ENDTRY);
 	label(J, F, L3);
 	cstm(J, F, finallystm);
 }",[23],An issue was discovered in Artifex MuJS 1.0.5. jscompile.c can cause a denial of service (invalid stack-frame jump) because it lacks an ENDTRY opcode call.,mujs,CVE-2019-11412,CWE-119
5021,179873," int cg_write(const char *path, const char *buf, size_t size, off_t offset,
 	     struct fuse_file_info *fi)
 {
 	struct fuse_context *fc = fuse_get_context();
 	char *localbuf = NULL;
 	struct cgfs_files *k = NULL;
 	struct file_info *f = (struct file_info *)fi->fh;
 	bool r;
 	if (f->type != LXC_TYPE_CGFILE) {
 		fprintf(stderr, ""Internal error: directory cache info used in cg_write\n"");
 		return -EIO;
 	}
 	if (offset)
 		return 0;
 	if (!fc)
 		return -EIO;
 	localbuf = alloca(size+1);
 	localbuf[size] = '\0';
 	memcpy(localbuf, buf, size);
 	if ((k = cgfs_get_key(f->controller, f->cgroup, f->file)) == NULL) {
 		size = -EINVAL;
 		goto out;
 	}
 	if (!fc_may_access(fc, f->controller, f->cgroup, f->file, O_WRONLY)) {
 		size = -EACCES;
 		goto out;
 	}
 	if (strcmp(f->file, ""tasks"") == 0 ||
 			strcmp(f->file, ""/tasks"") == 0 ||
  			strcmp(f->file, ""/cgroup.procs"") == 0 ||
  			strcmp(f->file, ""cgroup.procs"") == 0)
		r = do_write_pids(fc->pid, f->controller, f->cgroup, f->file, localbuf);
 		r = do_write_pids(fc->pid, fc->uid, f->controller, f->cgroup, f->file, localbuf);
  	else
  		r = cgfs_set_value(f->controller, f->cgroup, f->file, localbuf);
 	if (!r)
 		size = -EINVAL;
 out:
 	free_key(k);
 	return size;
 }","[32, 33]","The do_write_pids function in lxcfs.c in LXCFS before 0.12 does not properly check permissions, which allows local users to gain privileges by writing a pid to the tasks file.",lxcfs,CVE-2015-1344,CWE-264
5038,182947," setElementTypePrefix(XML_Parser parser, ELEMENT_TYPE *elementType)
 {
   DTD * const dtd = parser->m_dtd;   
   const XML_Char *name;
   for (name = elementType->name; *name; name++) {
     if (*name == XML_T(ASCII_COLON)) {
       PREFIX *prefix;
       const XML_Char *s;
       for (s = elementType->name; s != name; s++) {
         if (!poolAppendChar(&dtd->pool, *s))
           return 0;
       }
       if (!poolAppendChar(&dtd->pool, XML_T('\0')))
         return 0;
       prefix = (PREFIX *)lookup(parser, &dtd->prefixes, poolStart(&dtd->pool),
                                 sizeof(PREFIX));
       if (!prefix)
         return 0;
       if (prefix->name == poolStart(&dtd->pool))
         poolFinish(&dtd->pool);
        else
          poolDiscard(&dtd->pool);
        elementType->prefix = prefix;
       break;
      }
    }
    return 1;
 }",[24],"In libexpat in Expat before 2.2.7, XML input including XML names that contain a large number of colons could make the XML parser consume a high amount of RAM and CPU resources while processing (enough to be usable for denial-of-service attacks).",libexpat,CVE-2018-20843,CWE-611
5102,179589," bit_catenate(VarBit *arg1, VarBit *arg2)
 {
 	VarBit	   *result;
 	int			bitlen1,
 				bitlen2,
 				bytelen,
 				bit1pad,
 				bit2shift;
 	bits8	   *pr,
 			   *pa;
  	bitlen1 = VARBITLEN(arg1);
  	bitlen2 = VARBITLEN(arg2);
 	if (bitlen1 > VARBITMAXLEN - bitlen2)
 		ereport(ERROR,
 				(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),
 				 errmsg(""bit string length exceeds the maximum allowed (%d)"",
 						VARBITMAXLEN)));
  	bytelen = VARBITTOTALLEN(bitlen1 + bitlen2);
  	result = (VarBit *) palloc(bytelen);
 	SET_VARSIZE(result, bytelen);
 	VARBITLEN(result) = bitlen1 + bitlen2;
 	memcpy(VARBITS(result), VARBITS(arg1), VARBITBYTES(arg1));
 	bit1pad = VARBITPAD(arg1);
 	if (bit1pad == 0)
 	{
 		memcpy(VARBITS(result) + VARBITBYTES(arg1), VARBITS(arg2),
 			   VARBITBYTES(arg2));
 	}
 	else if (bitlen2 > 0)
 	{
 		bit2shift = BITS_PER_BYTE - bit1pad;
 		pr = VARBITS(result) + VARBITBYTES(arg1) - 1;
 		for (pa = VARBITS(arg2); pa < VARBITEND(arg2); pa++)
 		{
 			*pr |= ((*pa >> bit2shift) & BITMASK);
 			pr++;
 			if (pr < VARBITEND(result))
 				*pr = (*pa << bit1pad) & BITMASK;
 		}
 	}
 	return result;
 }","[13, 14, 15, 16, 17]","Multiple integer overflows in contrib/hstore/hstore_io.c in PostgreSQL 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact via vectors related to the (1) hstore_recv, (2) hstore_from_arrays, and (3) hstore_from_array functions in contrib/hstore/hstore_io.c; and the (4) hstoreArrayToPairs function in contrib/hstore/hstore_op.c, which triggers a buffer overflow.  NOTE: this issue was SPLIT from CVE-2014-0064 because it has a different set of affected versions.",postgres,CVE-2014-2669,CWE-189
5104,182328,"  static enum AVPixelFormat h263_get_format(AVCodecContext *avctx)
  {
     MpegEncContext *s = avctx->priv_data;
      if (avctx->bits_per_raw_sample > 8) {
        av_assert1(avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);
         av_assert1(s->studio_profile);
          return avctx->pix_fmt;
      }
     if (avctx->codec->id == AV_CODEC_ID_MSS2)
         return AV_PIX_FMT_YUV420P;
     if (CONFIG_GRAY && (avctx->flags & AV_CODEC_FLAG_GRAY)) {
         if (avctx->color_range == AVCOL_RANGE_UNSPECIFIED)
             avctx->color_range = AVCOL_RANGE_MPEG;
         return AV_PIX_FMT_GRAY8;
     }
     return avctx->pix_fmt = ff_get_format(avctx, avctx->codec->pix_fmts);
 }","[3, 5, 6]","In libavcodec in FFmpeg 4.0.1, improper maintenance of the consistency between the context profile field and studio_profile in libavcodec may trigger an assertion failure while converting a crafted AVI file to MPEG4, leading to a denial of service, related to error_resilience.c, h263dec.c, and mpeg4videodec.c.",FFmpeg,CVE-2018-13304,CWE-617
5124,182611," static int jpc_pi_nextcprl(register jpc_pi_t *pi)
 {
 	int rlvlno;
 	jpc_pirlvl_t *pirlvl;
 	jpc_pchg_t *pchg;
 	int prchind;
 	int prcvind;
 	int *prclyrno;
 	uint_fast32_t trx0;
 	uint_fast32_t try0;
 	uint_fast32_t r;
 	uint_fast32_t rpx;
 	uint_fast32_t rpy;
 	pchg = pi->pchg;
 	if (!pi->prgvolfirst) {
 		goto skip;
 	} else {
  		pi->prgvolfirst = 0;
  	}
	for (pi->compno = pchg->compnostart, pi->picomp =
	  &pi->picomps[pi->compno]; pi->compno < JAS_CAST(int, pchg->compnoend) && pi->compno < pi->numcomps; ++pi->compno,
	  ++pi->picomp) {
 	for (pi->compno = pchg->compnostart, pi->picomp = &pi->picomps[pi->compno];
 	  pi->compno < JAS_CAST(int, pchg->compnoend) && pi->compno < pi->numcomps;
 	  ++pi->compno, ++pi->picomp) {
  		pirlvl = pi->picomp->pirlvls;
 		if (pirlvl->prcwidthexpn + pi->picomp->numrlvls >
 		  JAS_UINTFAST32_NUMBITS - 2 ||
 		  pirlvl->prcheightexpn + pi->picomp->numrlvls >
 		  JAS_UINTFAST32_NUMBITS - 2) {
 			return -1;
 		}
  		pi->xstep = pi->picomp->hsamp * (JAS_CAST(uint_fast32_t, 1) <<
  		  (pirlvl->prcwidthexpn + pi->picomp->numrlvls - 1));
  		pi->ystep = pi->picomp->vsamp * (JAS_CAST(uint_fast32_t, 1) <<
 		  (pirlvl->prcheightexpn + pi->picomp->numrlvls - 1));
 		for (rlvlno = 1, pirlvl = &pi->picomp->pirlvls[1];
 		  rlvlno < pi->picomp->numrlvls; ++rlvlno, ++pirlvl) {
 			pi->xstep = JAS_MIN(pi->xstep, pi->picomp->hsamp *
 			  (JAS_CAST(uint_fast32_t, 1) << (pirlvl->prcwidthexpn +
 			  pi->picomp->numrlvls - rlvlno - 1)));
 			pi->ystep = JAS_MIN(pi->ystep, pi->picomp->vsamp *
 			  (JAS_CAST(uint_fast32_t, 1) << (pirlvl->prcheightexpn +
 			  pi->picomp->numrlvls - rlvlno - 1)));
 		}
 		for (pi->y = pi->ystart; pi->y < pi->yend;
 		  pi->y += pi->ystep - (pi->y % pi->ystep)) {
 			for (pi->x = pi->xstart; pi->x < pi->xend;
 			  pi->x += pi->xstep - (pi->x % pi->xstep)) {
 				for (pi->rlvlno = pchg->rlvlnostart,
 				  pi->pirlvl = &pi->picomp->pirlvls[pi->rlvlno];
 				  pi->rlvlno < pi->picomp->numrlvls && pi->rlvlno <
 				  pchg->rlvlnoend; ++pi->rlvlno, ++pi->pirlvl) {
 					if (pi->pirlvl->numprcs == 0) {
 						continue;
 					}
 					r = pi->picomp->numrlvls - 1 - pi->rlvlno;
 					trx0 = JPC_CEILDIV(pi->xstart, pi->picomp->hsamp << r);
  					try0 = JPC_CEILDIV(pi->ystart, pi->picomp->vsamp << r);
  					rpx = r + pi->pirlvl->prcwidthexpn;
  					rpy = r + pi->pirlvl->prcheightexpn;
					if (((pi->x == pi->xstart && ((trx0 << r) % (1 << rpx))) ||
 					if (((pi->x == pi->xstart &&
 					  ((trx0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpx))) ||
  					  !(pi->x % (pi->picomp->hsamp << rpx))) &&
					  ((pi->y == pi->ystart && ((try0 << r) % (1 << rpy))) ||
 					  ((pi->y == pi->ystart &&
 					  ((try0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpy))) ||
  					  !(pi->y % (pi->picomp->vsamp << rpy)))) {
						prchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x, pi->picomp->hsamp
						  << r), pi->pirlvl->prcwidthexpn) - JPC_FLOORDIVPOW2(trx0,
						  pi->pirlvl->prcwidthexpn);
						prcvind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->y, pi->picomp->vsamp
						  << r), pi->pirlvl->prcheightexpn) - JPC_FLOORDIVPOW2(try0,
						  pi->pirlvl->prcheightexpn);
						pi->prcno = prcvind *
						  pi->pirlvl->numhprcs +
						  prchind;
						assert(pi->prcno <
						  pi->pirlvl->numprcs);
						for (pi->lyrno = 0; pi->lyrno <
						  pi->numlyrs && pi->lyrno < JAS_CAST(int, pchg->lyrnoend); ++pi->lyrno) {
 						prchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x,
 						  pi->picomp->hsamp << r), pi->pirlvl->prcwidthexpn) -
 						  JPC_FLOORDIVPOW2(trx0, pi->pirlvl->prcwidthexpn);
 						prcvind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->y,
 						  pi->picomp->vsamp << r), pi->pirlvl->prcheightexpn) -
 						  JPC_FLOORDIVPOW2(try0, pi->pirlvl->prcheightexpn);
 						pi->prcno = prcvind * pi->pirlvl->numhprcs + prchind;
 						assert(pi->prcno < pi->pirlvl->numprcs);
 						for (pi->lyrno = 0; pi->lyrno < pi->numlyrs &&
 						  pi->lyrno < JAS_CAST(int, pchg->lyrnoend);
 						  ++pi->lyrno) {
  							prclyrno = &pi->pirlvl->prclyrnos[pi->prcno];
  							if (pi->lyrno >= *prclyrno) {
  								++(*prclyrno);
 								return 0;
 							}
 skip:
 							;
 						}
 					}
 				}
 			}
 		}
 	}
 	return 1;
 }","[20, 21, 22, 23, 24, 25, 27, 28, 29, 30, 31, 32, 62, 63, 64, 66, 67, 68, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93]",An out-of-bounds heap read vulnerability was found in the jpc_pi_nextpcrl() function of jasper before 2.0.6 when processing crafted input.,jasper,CVE-2016-9583,CWE-125
5131,183236," psf_binheader_readf (SF_PRIVATE *psf, char const *format, ...)
 {	va_list			argptr ;
 	sf_count_t		*countptr, countdata ;
 	unsigned char	*ucptr, sixteen_bytes [16] ;
 	unsigned int 	*intptr, intdata ;
 	unsigned short	*shortptr ;
 	char			*charptr ;
  	float			*floatptr ;
  	double			*doubleptr ;
  	char			c ;
	int				byte_count = 0, count ;
 	int				byte_count = 0, count = 0 ;
  	if (! format)
  		return psf_ftell (psf) ;
  	va_start (argptr, format) ;
  	while ((c = *format++))
	{	switch (c)
 	{
 		if (psf->header.indx + 16 >= psf->header.len && psf_bump_header_allocation (psf, 16))
 			return count ;
 		switch (c)
  		{	case 'e' :  
  					psf->rwf_endian = SF_ENDIAN_LITTLE ;
  					break ;
 			case 'E' :  
 					psf->rwf_endian = SF_ENDIAN_BIG ;
 					break ;
  			case 'm' :  
  					intptr = va_arg (argptr, unsigned int*) ;
 					*intptr = 0 ;
  					ucptr = (unsigned char*) intptr ;
  					byte_count += header_read (psf, ucptr, sizeof (int)) ;
  					*intptr = GET_MARKER (ucptr) ;
  					break ;
  			case 'h' :
  					intptr = va_arg (argptr, unsigned int*) ;
 					*intptr = 0 ;
  					ucptr = (unsigned char*) intptr ;
  					byte_count += header_read (psf, sixteen_bytes, sizeof (sixteen_bytes)) ;
  					{	int k ;
 						intdata = 0 ;
 						for (k = 0 ; k < 16 ; k++)
 							intdata ^= sixteen_bytes [k] << k ;
 						}
 					*intptr = intdata ;
 					break ;
 			case '1' :
 					charptr = va_arg (argptr, char*) ;
 					*charptr = 0 ;
 					byte_count += header_read (psf, charptr, sizeof (char)) ;
 					break ;
 			case '2' :  
 					shortptr = va_arg (argptr, unsigned short*) ;
 					*shortptr = 0 ;
 					ucptr = (unsigned char*) shortptr ;
 					byte_count += header_read (psf, ucptr, sizeof (short)) ;
 					if (psf->rwf_endian == SF_ENDIAN_BIG)
 						*shortptr = GET_BE_SHORT (ucptr) ;
 					else
 						*shortptr = GET_LE_SHORT (ucptr) ;
 					break ;
 			case '3' :  
 					intptr = va_arg (argptr, unsigned int*) ;
 					*intptr = 0 ;
 					byte_count += header_read (psf, sixteen_bytes, 3) ;
 					if (psf->rwf_endian == SF_ENDIAN_BIG)
 						*intptr = GET_BE_3BYTE (sixteen_bytes) ;
 					else
 						*intptr = GET_LE_3BYTE (sixteen_bytes) ;
 					break ;
 			case '4' :  
 					intptr = va_arg (argptr, unsigned int*) ;
 					*intptr = 0 ;
 					ucptr = (unsigned char*) intptr ;
 					byte_count += header_read (psf, ucptr, sizeof (int)) ;
 					if (psf->rwf_endian == SF_ENDIAN_BIG)
 						*intptr = psf_get_be32 (ucptr, 0) ;
 					else
 						*intptr = psf_get_le32 (ucptr, 0) ;
 					break ;
 			case '8' :  
 					countptr = va_arg (argptr, sf_count_t *) ;
 					*countptr = 0 ;
 					byte_count += header_read (psf, sixteen_bytes, 8) ;
 					if (psf->rwf_endian == SF_ENDIAN_BIG)
 						countdata = psf_get_be64 (sixteen_bytes, 0) ;
 					else
 						countdata = psf_get_le64 (sixteen_bytes, 0) ;
 					*countptr = countdata ;
 					break ;
 			case 'f' :  
 					floatptr = va_arg (argptr, float *) ;
 					*floatptr = 0.0 ;
 					byte_count += header_read (psf, floatptr, sizeof (float)) ;
 					if (psf->rwf_endian == SF_ENDIAN_BIG)
 						*floatptr = float32_be_read ((unsigned char*) floatptr) ;
 					else
 						*floatptr = float32_le_read ((unsigned char*) floatptr) ;
 					break ;
 			case 'd' :  
 					doubleptr = va_arg (argptr, double *) ;
 					*doubleptr = 0.0 ;
 					byte_count += header_read (psf, doubleptr, sizeof (double)) ;
 					if (psf->rwf_endian == SF_ENDIAN_BIG)
 						*doubleptr = double64_be_read ((unsigned char*) doubleptr) ;
 					else
 						*doubleptr = double64_le_read ((unsigned char*) doubleptr) ;
 					break ;
 			case 's' :
 					psf_log_printf (psf, ""Format conversion 's' not implemented yet.\n"") ;
  					break ;
  			case 'b' :  
  					charptr = va_arg (argptr, char*) ;
  					count = va_arg (argptr, size_t) ;
					if (count > 0)
						byte_count += header_read (psf, charptr, count) ;
 					memset (charptr, 0, count) ;
 					byte_count += header_read (psf, charptr, count) ;
  					break ;
  			case 'G' :
  					charptr = va_arg (argptr, char*) ;
  					count = va_arg (argptr, size_t) ;
					if (count > 0)
						byte_count += header_gets (psf, charptr, count) ;
 					memset (charptr, 0, count) ;
 					if (psf->header.indx + count >= psf->header.len && psf_bump_header_allocation (psf, count))
 						return 0 ;
 					byte_count += header_gets (psf, charptr, count) ;
  					break ;
  			case 'z' :
  					psf_log_printf (psf, ""Format conversion 'z' not implemented yet.\n"") ;
  					break ;
			case 'p' :
 			case 'p' :	 
  					count = va_arg (argptr, size_t) ;
  					header_seek (psf, count, SEEK_SET) ;
  					byte_count = count ;
  					break ;
			case 'j' :
 			case 'j' :	 
  					count = va_arg (argptr, size_t) ;
					if (count)
					{	header_seek (psf, count, SEEK_CUR) ;
						byte_count += count ;
						} ;
 					header_seek (psf, count, SEEK_CUR) ;
 					byte_count += count ;
  					break ;
  			default :
 				psf_log_printf (psf, ""*** Invalid format specifier `%c'\n"", c) ;
 				psf->error = SFE_INTERNAL ;
 				break ;
 			} ;
 		} ;
 	va_end (argptr) ;
 	return byte_count ;
 }  ","[11, 12, 17, 18, 19, 20, 21, 30, 37, 115, 116, 117, 118, 123, 124, 125, 126, 127, 128, 133, 134, 139, 140, 142, 143, 144, 145, 146, 147]","In libsndfile before 1.0.28, an error in the *header_read()* function (common.c) when handling ID3 tags can be exploited to cause a stack-based buffer overflow via a specially crafted FLAC file.",libsndfile,CVE-2017-7586,CWE-119
5142,182235," static int rtecp_select_file(sc_card_t *card,
 		const sc_path_t *in_path, sc_file_t **file_out)
 {
 	sc_file_t **file_out_copy, *file;
 	int r;
 	assert(card && card->ctx && in_path);
 	switch (in_path->type)
 	{
 	case SC_PATH_TYPE_DF_NAME:
 	case SC_PATH_TYPE_FROM_CURRENT:
 	case SC_PATH_TYPE_PARENT:
 		SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_NOT_SUPPORTED);
 	}
 	assert(iso_ops && iso_ops->select_file);
 	file_out_copy = file_out;
 	r = iso_ops->select_file(card, in_path, file_out_copy);
 	if (r || file_out_copy == NULL)
 		SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);
 	assert(file_out_copy);
 	file = *file_out_copy;
 	assert(file);
 	if (file->sec_attr && file->sec_attr_len == SC_RTECP_SEC_ATTR_SIZE)
  		set_acl_from_sec_attr(card, file);
  	else
  		r = SC_ERROR_UNKNOWN_DATA_RECEIVED;
	if (r)
 	if (r && !file_out)
  		sc_file_free(file);
  	else
  	{
 		assert(file_out);
 		*file_out = file;
 	}
 	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);
 }","[26, 27]",Various out of bounds reads when handling responses in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to potentially crash the opensc library using programs.,OpenSC,CVE-2018-16427,CWE-125
5147,182617," void jpc_qmfb_split_col(jpc_fix_t *a, int numrows, int stride,
   int parity)
 {
 	int bufsize = JPC_CEILDIVPOW2(numrows, 1);
 	jpc_fix_t splitbuf[QMFB_SPLITBUFSIZE];
 	jpc_fix_t *buf = splitbuf;
 	register jpc_fix_t *srcptr;
  	register jpc_fix_t *dstptr;
  	register int n;
  	register int m;
	int hstartcol;
 	int hstartrow;
  	if (bufsize > QMFB_SPLITBUFSIZE) {
 		if (!(buf = jas_alloc2(bufsize, sizeof(jpc_fix_t)))) {
 			abort();
 		}
  	}
  	if (numrows >= 2) {
		hstartcol = (numrows + 1 - parity) >> 1;
		m = numrows - hstartcol;
 		hstartrow = (numrows + 1 - parity) >> 1;
 		m = numrows - hstartrow;
  		n = m;
 		dstptr = buf;
 		srcptr = &a[(1 - parity) * stride];
 		while (n-- > 0) {
 			*dstptr = *srcptr;
 			++dstptr;
 			srcptr += stride << 1;
 		}
 		dstptr = &a[(1 - parity) * stride];
 		srcptr = &a[(2 - parity) * stride];
 		n = numrows - m - (!parity);
 		while (n-- > 0) {
 			*dstptr = *srcptr;
 			dstptr += stride;
  			srcptr += stride << 1;
  		}
		dstptr = &a[hstartcol * stride];
 		dstptr = &a[hstartrow * stride];
  		srcptr = buf;
  		n = m;
  		while (n-- > 0) {
 			*dstptr = *srcptr;
 			dstptr += stride;
 			++srcptr;
 		}
 	}
 	if (buf != splitbuf) {
 		jas_free(buf);
 	}
 }","[11, 12, 19, 20, 21, 22, 39, 40]",A heap-buffer overflow vulnerability was found in QMFB code in JPC codec caused by buffer being allocated with too small size. jasper versions before 2.0.0 are affected.,jasper,CVE-2016-8654,CWE-119
5162,177937,"  ProcXSendExtensionEvent(ClientPtr client)
  {
    int ret;
     int ret, i;
      DeviceIntPtr dev;
      xEvent *first;
      XEventClass *list;
     struct tmask tmp[EMASKSIZE];
     REQUEST(xSendExtensionEventReq);
     REQUEST_AT_LEAST_SIZE(xSendExtensionEventReq);
     if (stuff->length !=
         bytes_to_int32(sizeof(xSendExtensionEventReq)) + stuff->count +
         (stuff->num_events * bytes_to_int32(sizeof(xEvent))))
         return BadLength;
     ret = dixLookupDevice(&dev, stuff->deviceid, client, DixWriteAccess);
     if (ret != Success)
         return ret;
     if (stuff->num_events == 0)
         return ret;
      first = ((xEvent *) &stuff[1]);
    if (!((EXTENSION_EVENT_BASE <= first->u.u.type) &&
          (first->u.u.type < lastEvent))) {
        client->errorValue = first->u.u.type;
        return BadValue;
     for (i = 0; i < stuff->num_events; i++) {
         if (!((EXTENSION_EVENT_BASE <= first[i].u.u.type) &&
             (first[i].u.u.type < lastEvent))) {
             client->errorValue = first[i].u.u.type;
             return BadValue;
         }
      }
      list = (XEventClass *) (first + stuff->num_events);
         return ret;
     ret = (SendEvent(client, dev, stuff->destination,
                      stuff->propagate, (xEvent *) &stuff[1],
                      tmp[stuff->deviceid].mask, stuff->num_events));
     return ret;
 }","[3, 4, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]","In the X.Org X server before 2017-06-19, a user authenticated to an X Session could crash or execute code in the context of the X Server by exploiting a stack overflow in the endianness conversion of X Events.",xserver,CVE-2017-10971,CWE-119
5168,182329," int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)
 {
     MpegEncContext *s = &ctx->m;
     unsigned startcode, v;
     int ret;
     int vol = 0;
     align_get_bits(gb);
     if (!s->studio_profile && s->avctx->bits_per_raw_sample != 8)
         s->avctx->bits_per_raw_sample = 0;
     if (s->codec_tag == AV_RL32(""WV1F"") && show_bits(gb, 24) == 0x575630) {
         skip_bits(gb, 24);
         if (get_bits(gb, 8) == 0xF0)
             goto end;
     }
     startcode = 0xff;
     for (;;) {
         if (get_bits_count(gb) >= gb->size_in_bits) {
             if (gb->size_in_bits == 8 &&
                 (ctx->divx_version >= 0 || ctx->xvid_build >= 0) || s->codec_tag == AV_RL32(""QMP4"")) {
                 av_log(s->avctx, AV_LOG_VERBOSE, ""frame skip %d\n"", gb->size_in_bits);
                 return FRAME_SKIPPED;   
             } else
                 return AVERROR_INVALIDDATA;   
         }
         v = get_bits(gb, 8);
         startcode = ((startcode << 8) | v) & 0xffffffff;
         if ((startcode & 0xFFFFFF00) != 0x100)
             continue;   
         if (s->avctx->debug & FF_DEBUG_STARTCODE) {
             av_log(s->avctx, AV_LOG_DEBUG, ""startcode: %3X "", startcode);
             if (startcode <= 0x11F)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Video Object Start"");
             else if (startcode <= 0x12F)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Video Object Layer Start"");
             else if (startcode <= 0x13F)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Reserved"");
             else if (startcode <= 0x15F)
                 av_log(s->avctx, AV_LOG_DEBUG, ""FGS bp start"");
             else if (startcode <= 0x1AF)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Reserved"");
             else if (startcode == 0x1B0)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Visual Object Seq Start"");
             else if (startcode == 0x1B1)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Visual Object Seq End"");
             else if (startcode == 0x1B2)
                 av_log(s->avctx, AV_LOG_DEBUG, ""User Data"");
             else if (startcode == 0x1B3)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Group of VOP start"");
             else if (startcode == 0x1B4)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Video Session Error"");
             else if (startcode == 0x1B5)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Visual Object Start"");
             else if (startcode == 0x1B6)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Video Object Plane start"");
             else if (startcode == 0x1B7)
                 av_log(s->avctx, AV_LOG_DEBUG, ""slice start"");
             else if (startcode == 0x1B8)
                 av_log(s->avctx, AV_LOG_DEBUG, ""extension start"");
             else if (startcode == 0x1B9)
                 av_log(s->avctx, AV_LOG_DEBUG, ""fgs start"");
             else if (startcode == 0x1BA)
                 av_log(s->avctx, AV_LOG_DEBUG, ""FBA Object start"");
             else if (startcode == 0x1BB)
                 av_log(s->avctx, AV_LOG_DEBUG, ""FBA Object Plane start"");
             else if (startcode == 0x1BC)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Mesh Object start"");
             else if (startcode == 0x1BD)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Mesh Object Plane start"");
             else if (startcode == 0x1BE)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Still Texture Object start"");
             else if (startcode == 0x1BF)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Texture Spatial Layer start"");
             else if (startcode == 0x1C0)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Texture SNR Layer start"");
             else if (startcode == 0x1C1)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Texture Tile start"");
             else if (startcode == 0x1C2)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Texture Shape Layer start"");
             else if (startcode == 0x1C3)
                 av_log(s->avctx, AV_LOG_DEBUG, ""stuffing start"");
             else if (startcode <= 0x1C5)
                 av_log(s->avctx, AV_LOG_DEBUG, ""reserved"");
             else if (startcode <= 0x1FF)
                 av_log(s->avctx, AV_LOG_DEBUG, ""System start"");
             av_log(s->avctx, AV_LOG_DEBUG, "" at %d\n"", get_bits_count(gb));
         }
         if (startcode >= 0x120 && startcode <= 0x12F) {
             if (vol) {
                 av_log(s->avctx, AV_LOG_WARNING, ""Ignoring multiple VOL headers\n"");
                 continue;
             }
             vol++;
             if ((ret = decode_vol_header(ctx, gb)) < 0)
                 return ret;
         } else if (startcode == USER_DATA_STARTCODE) {
             decode_user_data(ctx, gb);
         } else if (startcode == GOP_STARTCODE) {
             mpeg4_decode_gop_header(s, gb);
         } else if (startcode == VOS_STARTCODE) {
             int profile, level;
             mpeg4_decode_profile_level(s, gb, &profile, &level);
             if (profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&
                 (level > 0 && level < 9)) {
                 s->studio_profile = 1;
                 next_start_code_studio(gb);
                 extension_and_user_data(s, gb, 0);
             } else if (s->studio_profile) {
                 avpriv_request_sample(s->avctx, ""Mixes studio and non studio profile\n"");
                 return AVERROR_PATCHWELCOME;
             }
             s->avctx->profile = profile;
             s->avctx->level   = level;
         } else if (startcode == VISUAL_OBJ_STARTCODE) {
             if (s->studio_profile) {
                 if ((ret = decode_studiovisualobject(ctx, gb)) < 0)
                     return ret;
             } else
                 mpeg4_decode_visual_object(s, gb);
         } else if (startcode == VOP_STARTCODE) {
             break;
         }
         align_get_bits(gb);
         startcode = 0xff;
     }
 end:
     if (s->avctx->flags & AV_CODEC_FLAG_LOW_DELAY)
         s->low_delay = 1;
      s->avctx->has_b_frames = !s->low_delay;
      if (s->studio_profile) {
        av_assert0(s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);
          if (!s->avctx->bits_per_raw_sample) {
              av_log(s->avctx, AV_LOG_ERROR, ""Missing VOL header\n"");
              return AVERROR_INVALIDDATA;
         }
         return decode_studio_vop_header(ctx, gb);
     } else
         return decode_vop_header(ctx, gb);
 }",[130],"In libavcodec in FFmpeg 4.0.1, improper maintenance of the consistency between the context profile field and studio_profile in libavcodec may trigger an assertion failure while converting a crafted AVI file to MPEG4, leading to a denial of service, related to error_resilience.c, h263dec.c, and mpeg4videodec.c.",FFmpeg,CVE-2018-13304,CWE-617
5187,181359," int yr_object_copy(
     YR_OBJECT* object,
     YR_OBJECT** object_copy)
 {
   YR_OBJECT* copy;
   YR_OBJECT* o;
   YR_STRUCTURE_MEMBER* structure_member;
   YR_OBJECT_FUNCTION* func;
   YR_OBJECT_FUNCTION* func_copy;
   int i;
   *object_copy = NULL;
   FAIL_ON_ERROR(yr_object_create(
       object->type,
       object->identifier,
       NULL,
       &copy));
    switch(object->type)
    {
      case OBJECT_TYPE_INTEGER:
      ((YR_OBJECT_INTEGER*) copy)->value = UNDEFINED;
       ((YR_OBJECT_INTEGER*) copy)->value = ((YR_OBJECT_INTEGER*) object)->value;
        break;
      case OBJECT_TYPE_STRING:
      ((YR_OBJECT_STRING*) copy)->value = NULL;
       if (((YR_OBJECT_STRING*) object)->value != NULL)
       {
         ((YR_OBJECT_STRING*) copy)->value = sized_string_dup(
             ((YR_OBJECT_STRING*) object)->value);
       }
       else
       {
         ((YR_OBJECT_STRING*) copy)->value = NULL;
       }
       break;
     case OBJECT_TYPE_FLOAT:
       ((YR_OBJECT_DOUBLE*) copy)->value = ((YR_OBJECT_DOUBLE*) object)->value;
        break;
      case OBJECT_TYPE_FUNCTION:
       func = (YR_OBJECT_FUNCTION*) object;
       func_copy = (YR_OBJECT_FUNCTION*) copy;
       FAIL_ON_ERROR_WITH_CLEANUP(
         yr_object_copy(func->return_obj, &func_copy->return_obj),
         yr_object_destroy(copy));
       for (i = 0; i < MAX_OVERLOADED_FUNCTIONS; i++)
         func_copy->prototypes[i] = func->prototypes[i];
       break;
     case OBJECT_TYPE_STRUCTURE:
       structure_member = ((YR_OBJECT_STRUCTURE*) object)->members;
       while (structure_member != NULL)
       {
         FAIL_ON_ERROR_WITH_CLEANUP(
             yr_object_copy(structure_member->object, &o),
             yr_object_destroy(copy));
         FAIL_ON_ERROR_WITH_CLEANUP(
             yr_object_structure_set_member(copy, o),
             yr_free(o);
             yr_object_destroy(copy));
         structure_member = structure_member->next;
       }
       break;
     case OBJECT_TYPE_ARRAY:
       yr_object_copy(
         ((YR_OBJECT_ARRAY *) object)->prototype_item,
         &o);
       ((YR_OBJECT_ARRAY *)copy)->prototype_item = o;
       break;
     case OBJECT_TYPE_DICTIONARY:
       yr_object_copy(
         ((YR_OBJECT_DICTIONARY *) object)->prototype_item,
         &o);
       ((YR_OBJECT_DICTIONARY *)copy)->prototype_item = o;
       break;
     default:
       assert(FALSE);
   }
   *object_copy = copy;
   return ERROR_SUCCESS;
 }","[20, 21, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36]",The sized_string_cmp function in libyara/sizedstr.c in YARA 3.5.0 allows remote attackers to cause a denial of service (use-after-free and application crash) via a crafted rule.,yara,CVE-2017-8929,CWE-416
5196,182060," tTcpIpPacketParsingResult ParaNdis_CheckSumVerify(
                                                 tCompletePhysicalAddress *pDataPages,
                                                 ULONG ulDataLength,
                                                 ULONG ulStartOffset,
                                                 ULONG flags,
                                                 LPCSTR caller)
 {
      IPHeader *pIpHeader = (IPHeader *) RtlOffsetToPointer(pDataPages[0].Virtual, ulStartOffset);
      tTcpIpPacketParsingResult res = QualifyIpPacket(pIpHeader, ulDataLength);
     if (res.ipStatus == ppresNotIP || res.ipCheckSum == ppresIPTooShort)
         return res;
      if (res.ipStatus == ppresIPV4)
      {
          if (flags & pcrIpChecksum)
             res = VerifyIpChecksum(&pIpHeader->v4, res, (flags & pcrFixIPChecksum) != 0);
         if(res.xxpStatus == ppresXxpKnown)
         {
             if (res.TcpUdp == ppresIsTCP)  
             {
                 if(flags & pcrTcpV4Checksum)
                 {
                     res = VerifyTcpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixTcpV4Checksum));
                 }
             }
             else  
             {
                 if (flags & pcrUdpV4Checksum)
                 {
                     res = VerifyUdpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixUdpV4Checksum));
                 }
             }
         }
     }
     else if (res.ipStatus == ppresIPV6)
     {
         if(res.xxpStatus == ppresXxpKnown)
         {
             if (res.TcpUdp == ppresIsTCP)  
             {
                 if(flags & pcrTcpV6Checksum)
                 {
                     res = VerifyTcpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixTcpV6Checksum));
                 }
             }
             else  
             {
                 if (flags & pcrUdpV6Checksum)
                 {
                     res = VerifyUdpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixUdpV6Checksum));
                 }
             }
         }
     }
     PrintOutParsingResult(res, 1, caller);
     return res;
 }","[10, 11]","The NetKVM Windows Virtio driver allows remote attackers to cause a denial of service (guest crash) via a crafted length value in an IP packet, as demonstrated by a value that does not account for the size of the IP options.",kvm-guest-drivers-windows,CVE-2015-3215,CWE-20
5213,181998," smb_com_flush(smb_request_t *sr)
 {
 	smb_ofile_t	*file;
 	smb_llist_t	*flist;
 	int		rc;
 	if (smb_flush_required == 0) {
 		rc = smbsr_encode_empty_result(sr);
 		return ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);
 	}
 	if (sr->smb_fid != 0xffff) {
 		smbsr_lookup_file(sr);
 		if (sr->fid_ofile == NULL) {
 			smbsr_error(sr, NT_STATUS_INVALID_HANDLE,
  			    ERRDOS, ERRbadfid);
  			return (SDRC_ERROR);
  		}
		smb_flush_file(sr, sr->fid_ofile);
 		smb_ofile_flush(sr, sr->fid_ofile);
  	} else {
  		flist = &sr->tid_tree->t_ofile_list;
  		smb_llist_enter(flist, RW_READER);
  		file = smb_llist_head(flist);
  		while (file) {
  			mutex_enter(&file->f_mutex);
			smb_flush_file(sr, file);
 			smb_ofile_flush(sr, file);
  			mutex_exit(&file->f_mutex);
  			file = smb_llist_next(flist, file);
  		}
 		smb_llist_exit(flist);
 	}
  	rc = smbsr_encode_empty_result(sr);
  	return ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);
  }","[17, 18, 25, 26]",illumos smbsrv NULL pointer dereference allows system crash.,illumos-gate,CVE-2016-6561,CWE-476
5215,183218," static int dnxhd_find_frame_end(DNXHDParserContext *dctx,
                                 const uint8_t *buf, int buf_size)
 {
     ParseContext *pc = &dctx->pc;
     uint64_t state = pc->state64;
     int pic_found = pc->frame_start_found;
     int i = 0;
     if (!pic_found) {
         for (i = 0; i < buf_size; i++) {
             state = (state << 8) | buf[i];
             if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {
                 i++;
                 pic_found = 1;
                 dctx->cur_byte = 0;
                 dctx->remaining = 0;
                 break;
             }
         }
     }
     if (pic_found && !dctx->remaining) {
         if (!buf_size)  
             return 0;
         for (; i < buf_size; i++) {
             dctx->cur_byte++;
             state = (state << 8) | buf[i];
             if (dctx->cur_byte == 24) {
                 dctx->h = (state >> 32) & 0xFFFF;
             } else if (dctx->cur_byte == 26) {
                  dctx->w = (state >> 32) & 0xFFFF;
              } else if (dctx->cur_byte == 42) {
                  int cid = (state >> 32) & 0xFFFFFFFF;
                 int remaining;
                  if (cid <= 0)
                      continue;
                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);
                if (dctx->remaining <= 0) {
                    dctx->remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
                    if (dctx->remaining <= 0)
                        return dctx->remaining;
                 remaining = avpriv_dnxhd_get_frame_size(cid);
                 if (remaining <= 0) {
                     remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
                     if (remaining <= 0)
                         continue;
                  }
                 dctx->remaining = remaining;
                  if (buf_size - i + 47 >= dctx->remaining) {
                      int remaining = dctx->remaining;
                     pc->frame_start_found = 0;
                     pc->state64 = -1;
                     dctx->cur_byte = 0;
                     dctx->remaining = 0;
                     return remaining;
                 } else {
                     dctx->remaining -= buf_size;
                 }
             }
         }
     } else if (pic_found) {
         if (dctx->remaining > buf_size) {
             dctx->remaining -= buf_size;
         } else {
             int remaining = dctx->remaining;
             pc->frame_start_found = 0;
             pc->state64 = -1;
             dctx->cur_byte = 0;
             dctx->remaining = 0;
             return remaining;
         }
     }
     pc->frame_start_found = pic_found;
     pc->state64 = state;
     return END_NOT_FOUND;
 }","[32, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 46]","The dnxhd decoder in FFmpeg before 3.2.6, and 3.3.x before 3.3.3 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted mov file.",FFmpeg,CVE-2017-9608,CWE-476
5231,181922," static int mem_resize(jas_stream_memobj_t *m, int bufsize)
 static int mem_resize(jas_stream_memobj_t *m, size_t bufsize)
  {
  	unsigned char *buf;
	assert(bufsize >= 0);
 	JAS_DBGLOG(100, (""mem_resize(%p, %zu)\n"", m, bufsize));
 	if (!bufsize) {
 		jas_eprintf(
 		  ""mem_resize was not really designed to handle a buffer of size 0\n""
 		  ""This may not work.\n""
 		);
 	}
	JAS_DBGLOG(100, (""mem_resize(%p, %d)\n"", m, bufsize));
  	if (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&
  	  bufsize) {
  		JAS_DBGLOG(100, (""mem_resize realloc failed\n""));
 		return -1;
 	}
 	JAS_DBGLOG(100, (""mem_resize realloc succeeded\n""));
 	m->buf_ = buf;
 	m->bufsize_ = bufsize;
 	return 0;
 }","[2, 5, 6, 7, 8, 9, 10, 11, 12, 13]","Multiple integer overflows in the (1) jas_realloc function in base/jas_malloc.c and (2) mem_resize function in base/jas_stream.c in JasPer before 1.900.22 allow remote attackers to cause a denial of service via a crafted image, which triggers use after free vulnerabilities.",jasper,CVE-2016-9262,CWE-190
5238,182970," lspci_process(STREAM s)
 {
  	unsigned int pkglen;
  	static char *rest = NULL;
  	char *buf;
 	struct stream packet = *s;
 	if (!s_check(s))
 	{
 		rdp_protocol_error(""lspci_process(), stream is in unstable state"", &packet);
 	}
  	pkglen = s->end - s->p;
 	buf = xmalloc(pkglen + 1);
 	STRNCPY(buf, (char *) s->p, pkglen + 1);
 	str_handle_lines(buf, &rest, lspci_process_line, NULL);
 	xfree(buf);
 }","[6, 7, 8, 9, 10]",rdesktop versions up to and including v1.8.3 contain a Buffer Overflow over the global variables in the function seamless_process_line() that results in memory corruption and probably even a remote code execution.,rdesktop,CVE-2018-20182,CWE-119
5240,181900,"  int pnm_validate(jas_stream_t *in)
  {
	uchar buf[2];
 	jas_uchar buf[2];
  	int i;
  	int n;
 	assert(JAS_STREAM_MAXPUTBACK >= 2);
 	if ((n = jas_stream_read(in, buf, 2)) < 0) {
 		return -1;
 	}
 	for (i = n - 1; i >= 0; --i) {
 		if (jas_stream_ungetc(in, buf[i]) == EOF) {
 			return -1;
 		}
 	}
 	if (n < 2) {
 		return -1;
 	}
 	if (buf[0] == 'P' && isdigit(buf[1])) {
 		return 0;
 	}
 	return -1;
 }","[3, 4]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
5241,179101,"  static void add_bytes_c(uint8_t *dst, uint8_t *src, int w){
      long i;
    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){
     for(i=0; i<=w-(int)sizeof(long); i+=sizeof(long)){
          long a = *(long*)(src+i);
          long b = *(long*)(dst+i);
          *(long*)(dst+i) = ((a&pb_7f) + (b&pb_7f)) ^ ((a^b)&pb_80);
     }
     for(; i<w; i++)
         dst[i+0] += src[i+0];
 }","[3, 4]",Multiple integer signedness errors in libavcodec/dsputil.c in FFmpeg before 2.1 allow remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted data.,FFmpeg,CVE-2013-7010,CWE-189
5264,181856," static int jas_iccgetuint(jas_stream_t *in, int n, ulonglong *val)
 static int jas_iccgetuint(jas_stream_t *in, int n, jas_ulonglong *val)
  {
  	int i;
  	int c;
	ulonglong v;
 	jas_ulonglong v;
  	v = 0;
  	for (i = n; i > 0; --i) {
  		if ((c = jas_stream_getc(in)) == EOF)
 			return -1;
 		v = (v << 8) | c;
 	}
 	*val = v;
 	return 0;
 }","[2, 6, 7]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
5267,181860," jas_iccprof_t *jas_iccprof_createfrombuf(uchar *buf, int len)
 jas_iccprof_t *jas_iccprof_createfrombuf(jas_uchar *buf, int len)
  {
  	jas_stream_t *in;
  	jas_iccprof_t *prof;
 	if (!(in = jas_stream_memopen(JAS_CAST(char *, buf), len)))
 		goto error;
 	if (!(prof = jas_iccprof_load(in)))
 		goto error;
 	jas_stream_close(in);
 	return prof;
 error:
 	if (in)
 		jas_stream_close(in);
 	return 0;
 }",[2],Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
5308,179177," static int filter_frame(AVFilterLink *inlink, AVFrame *in)
 {
     PadContext *s = inlink->dst->priv;
     AVFrame *out;
     int needs_copy = frame_needs_copy(s, in);
     if (needs_copy) {
         av_log(inlink->dst, AV_LOG_DEBUG, ""Direct padding impossible allocating new frame\n"");
         out = ff_get_video_buffer(inlink->dst->outputs[0],
                                   FFMAX(inlink->w, s->w),
                                   FFMAX(inlink->h, s->h));
         if (!out) {
             av_frame_free(&in);
             return AVERROR(ENOMEM);
         }
         av_frame_copy_props(out, in);
     } else {
          int i;
          out = in;
        for (i = 0; i < 4 && out->data[i]; i++) {
         for (i = 0; i < 4 && out->data[i] && out->linesize[i]; i++) {
              int hsub = s->draw.hsub[i];
              int vsub = s->draw.vsub[i];
              out->data[i] -= (s->x >> hsub) * s->draw.pixelstep[i] +
                             (s->y >> vsub) * out->linesize[i];
         }
     }
     if (s->y) {
         ff_fill_rectangle(&s->draw, &s->color,
                           out->data, out->linesize,
                           0, 0, s->w, s->y);
     }
     if (s->h > s->y + s->in_h) {
         ff_fill_rectangle(&s->draw, &s->color,
                           out->data, out->linesize,
                           0, s->y + s->in_h, s->w, s->h - s->y - s->in_h);
     }
     ff_fill_rectangle(&s->draw, &s->color, out->data, out->linesize,
                       0, s->y, s->x, in->height);
     if (needs_copy) {
         ff_copy_rectangle2(&s->draw,
                           out->data, out->linesize, in->data, in->linesize,
                           s->x, s->y, 0, 0, in->width, in->height);
     }
     ff_fill_rectangle(&s->draw, &s->color, out->data, out->linesize,
                       s->x + s->in_w, s->y, s->w - s->x - s->in_w,
                       in->height);
     out->width  = s->w;
     out->height = s->h;
     if (in != out)
         av_frame_free(&in);
     return ff_filter_frame(inlink->dst->outputs[0], out);
 }","[19, 20]","libavfilter in FFmpeg before 2.0.1 has unspecified impact and remote vectors related to a crafted *plane,* which triggers an out-of-bounds heap write.",FFmpeg,CVE-2013-4263,CWE-119
5310,181910," static int jpc_dec_tiledecode(jpc_dec_t *dec, jpc_dec_tile_t *tile)
 {
 	int i;
 	int j;
 	jpc_dec_tcomp_t *tcomp;
 	jpc_dec_rlvl_t *rlvl;
 	jpc_dec_band_t *band;
 	int compno;
 	int rlvlno;
 	int bandno;
 	int adjust;
 	int v;
 	jpc_dec_ccp_t *ccp;
 	jpc_dec_cmpt_t *cmpt;
 	if (jpc_dec_decodecblks(dec, tile)) {
 		jas_eprintf(""jpc_dec_decodecblks failed\n"");
 		return -1;
 	}
 	for (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;
 	  ++compno, ++tcomp) {
 		ccp = &tile->cp->ccps[compno];
 		for (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls;
 		  ++rlvlno, ++rlvl) {
 			if (!rlvl->bands) {
 				continue;
 			}
 			for (bandno = 0, band = rlvl->bands;
 			  bandno < rlvl->numbands; ++bandno, ++band) {
 				if (!band->data) {
 					continue;
 				}
 				jpc_undo_roi(band->data, band->roishift, ccp->roishift -
 				  band->roishift, band->numbps);
 				if (tile->realmode) {
 					jas_matrix_asl(band->data, JPC_FIX_FRACBITS);
 					jpc_dequantize(band->data, band->absstepsize);
 				}
 			}
 		}
 	}
 	for (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;
 	  ++compno, ++tcomp) {
 		ccp = &tile->cp->ccps[compno];
 		jpc_tsfb_synthesize(tcomp->tsfb, tcomp->data);
 	}
 	switch (tile->cp->mctid) {
 	case JPC_MCT_RCT:
 		if (dec->numcomps < 3) {
  			jas_eprintf(""RCT requires at least three components\n"");
  			return -1;
  		}
 		if (!jas_image_cmpt_domains_same(dec->image)) {
 			jas_eprintf(""RCT requires all components have the same domain\n"");
 			return -1;
 		}
  		jpc_irct(tile->tcomps[0].data, tile->tcomps[1].data,
  		  tile->tcomps[2].data);
  		break;
 	case JPC_MCT_ICT:
 		if (dec->numcomps < 3) {
  			jas_eprintf(""ICT requires at least three components\n"");
  			return -1;
  		}
 		if (!jas_image_cmpt_domains_same(dec->image)) {
 			jas_eprintf(""RCT requires all components have the same domain\n"");
 			return -1;
 		}
  		jpc_iict(tile->tcomps[0].data, tile->tcomps[1].data,
  		  tile->tcomps[2].data);
  		break;
 	}
 	if (tile->realmode) {
 		for (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;
 		  ++compno, ++tcomp) {
 			for (i = 0; i < jas_matrix_numrows(tcomp->data); ++i) {
 				for (j = 0; j < jas_matrix_numcols(tcomp->data); ++j) {
 					v = jas_matrix_get(tcomp->data, i, j);
 					v = jpc_fix_round(v);
 					jas_matrix_set(tcomp->data, i, j, jpc_fixtoint(v));
 				}
 			}
 		}
 	}
 	for (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <
 	  dec->numcomps; ++compno, ++tcomp, ++cmpt) {
 		adjust = cmpt->sgnd ? 0 : (1 << (cmpt->prec - 1));
 		for (i = 0; i < jas_matrix_numrows(tcomp->data); ++i) {
 			for (j = 0; j < jas_matrix_numcols(tcomp->data); ++j) {
 				*jas_matrix_getref(tcomp->data, i, j) += adjust;
 			}
 		}
 	}
 	for (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <
 	  dec->numcomps; ++compno, ++tcomp, ++cmpt) {
 		jpc_fix_t mn;
 		jpc_fix_t mx;
 		mn = cmpt->sgnd ? (-(1 << (cmpt->prec - 1))) : (0);
 		mx = cmpt->sgnd ? ((1 << (cmpt->prec - 1)) - 1) : ((1 <<
 		  cmpt->prec) - 1);
 		jas_matrix_clip(tcomp->data, mn, mx);
 	}
 	for (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <
 	  dec->numcomps; ++compno, ++tcomp, ++cmpt) {
 		if (jas_image_writecmpt(dec->image, compno, tcomp->xstart -
 		  JPC_CEILDIV(dec->xstart, cmpt->hstep), tcomp->ystart -
 		  JPC_CEILDIV(dec->ystart, cmpt->vstep), jas_matrix_numcols(
 		  tcomp->data), jas_matrix_numrows(tcomp->data), tcomp->data)) {
 			jas_eprintf(""write component failed\n"");
 			return -1;
 		}
 	}
 	return 0;
 }","[52, 53, 54, 55, 64, 65, 66, 67]",The jpc_irct and jpc_iict functions in jpc_mct.c in JasPer before 1.900.14 allow remote attackers to cause a denial of service (assertion failure).,jasper,CVE-2016-9389,
5320,182250," static int sc_pkcs15emu_sc_hsm_init (sc_pkcs15_card_t * p15card)
 {
 	sc_card_t *card = p15card->card;
 	sc_hsm_private_data_t *priv = (sc_hsm_private_data_t *) card->drv_data;
 	sc_file_t *file = NULL;
 	sc_path_t path;
 	u8 filelist[MAX_EXT_APDU_LENGTH];
 	int filelistlength;
 	int r, i;
 	sc_cvc_t devcert;
 	struct sc_app_info *appinfo;
 	struct sc_pkcs15_auth_info pin_info;
 	struct sc_pkcs15_object pin_obj;
 	struct sc_pin_cmd_data pindata;
 	u8 efbin[1024];
 	u8 *ptr;
 	size_t len;
 	LOG_FUNC_CALLED(card->ctx);
 	appinfo = calloc(1, sizeof(struct sc_app_info));
 	if (appinfo == NULL) {
 		LOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);
 	}
 	appinfo->aid = sc_hsm_aid;
 	appinfo->ddo.aid = sc_hsm_aid;
 	p15card->app = appinfo;
 	sc_path_set(&path, SC_PATH_TYPE_DF_NAME, sc_hsm_aid.value, sc_hsm_aid.len, 0, 0);
 	r = sc_select_file(card, &path, &file);
 	LOG_TEST_RET(card->ctx, r, ""Could not select SmartCard-HSM application"");
 	p15card->card->version.hw_major = 24;	 
 	p15card->card->version.hw_minor = 13;
 	if (file && file->prop_attr && file->prop_attr_len >= 2) {
 		p15card->card->version.fw_major = file->prop_attr[file->prop_attr_len - 2];
 		p15card->card->version.fw_minor = file->prop_attr[file->prop_attr_len - 1];
 	}
 	sc_file_free(file);
 	if (priv->EF_C_DevAut && priv->EF_C_DevAut_len) {
 		ptr = priv->EF_C_DevAut;
 		len = priv->EF_C_DevAut_len;
 	} else {
 		len = sizeof efbin;
  		r = read_file(p15card, (u8 *) ""\x2F\x02"", efbin, &len, 1);
  		LOG_TEST_RET(card->ctx, r, ""Skipping optional EF.C_DevAut"");
		ptr = realloc(priv->EF_C_DevAut, len);
		if (ptr) {
			memcpy(ptr, efbin, len);
			priv->EF_C_DevAut = ptr;
			priv->EF_C_DevAut_len = len;
 		if (len > 0) {
 			ptr = realloc(priv->EF_C_DevAut, len);
 			if (ptr) {
 				memcpy(ptr, efbin, len);
 				priv->EF_C_DevAut = ptr;
 				priv->EF_C_DevAut_len = len;
 			}
  		}
  		ptr = efbin;
 	}
 	memset(&devcert, 0 ,sizeof(devcert));
 	r = sc_pkcs15emu_sc_hsm_decode_cvc(p15card, (const u8 **)&ptr, &len, &devcert);
 	LOG_TEST_RET(card->ctx, r, ""Could not decode EF.C_DevAut"");
 	sc_pkcs15emu_sc_hsm_read_tokeninfo(p15card);
 	if (p15card->tokeninfo->label == NULL) {
 		if (p15card->card->type == SC_CARD_TYPE_SC_HSM_GOID
 				|| p15card->card->type == SC_CARD_TYPE_SC_HSM_SOC) {
 			p15card->tokeninfo->label = strdup(""GoID"");
 		} else {
 			p15card->tokeninfo->label = strdup(""SmartCard-HSM"");
 		}
 		if (p15card->tokeninfo->label == NULL)
 			LOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);
 	}
 	if ((p15card->tokeninfo->manufacturer_id != NULL) && !strcmp(""(unknown)"", p15card->tokeninfo->manufacturer_id)) {
 		free(p15card->tokeninfo->manufacturer_id);
 		p15card->tokeninfo->manufacturer_id = NULL;
 	}
 	if (p15card->tokeninfo->manufacturer_id == NULL) {
 		if (p15card->card->type == SC_CARD_TYPE_SC_HSM_GOID
 				|| p15card->card->type == SC_CARD_TYPE_SC_HSM_SOC) {
 			p15card->tokeninfo->manufacturer_id = strdup(""Bundesdruckerei GmbH"");
 		} else {
 			p15card->tokeninfo->manufacturer_id = strdup(""www.CardContact.de"");
 		}
 		if (p15card->tokeninfo->manufacturer_id == NULL)
 			LOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);
 	}
 	appinfo->label = strdup(p15card->tokeninfo->label);
 	if (appinfo->label == NULL)
 		LOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);
 	len = strnlen(devcert.chr, sizeof devcert.chr);		 
 	assert(len >= 8);
 	len -= 5;
 	p15card->tokeninfo->serial_number = calloc(len + 1, 1);
 	if (p15card->tokeninfo->serial_number == NULL)
 		LOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);
 	memcpy(p15card->tokeninfo->serial_number, devcert.chr, len);
 	*(p15card->tokeninfo->serial_number + len) = 0;
 	sc_hsm_set_serialnr(card, p15card->tokeninfo->serial_number);
 	sc_pkcs15emu_sc_hsm_free_cvc(&devcert);
 	memset(&pin_info, 0, sizeof(pin_info));
 	memset(&pin_obj, 0, sizeof(pin_obj));
 	pin_info.auth_id.len = 1;
 	pin_info.auth_id.value[0] = 1;
 	pin_info.path.aid = sc_hsm_aid;
 	pin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;
 	pin_info.attrs.pin.reference = 0x81;
 	pin_info.attrs.pin.flags = SC_PKCS15_PIN_FLAG_LOCAL|SC_PKCS15_PIN_FLAG_INITIALIZED|SC_PKCS15_PIN_FLAG_EXCHANGE_REF_DATA;
 	pin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;
 	pin_info.attrs.pin.min_length = 6;
 	pin_info.attrs.pin.stored_length = 0;
 	pin_info.attrs.pin.max_length = 15;
 	pin_info.attrs.pin.pad_char = '\0';
 	pin_info.tries_left = 3;
 	pin_info.max_tries = 3;
 	pin_obj.auth_id.len = 1;
 	pin_obj.auth_id.value[0] = 2;
 	strlcpy(pin_obj.label, ""UserPIN"", sizeof(pin_obj.label));
 	pin_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE|SC_PKCS15_CO_FLAG_MODIFIABLE;
 	r = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);
 	if (r < 0)
 		LOG_FUNC_RETURN(card->ctx, r);
 	memset(&pin_info, 0, sizeof(pin_info));
 	memset(&pin_obj, 0, sizeof(pin_obj));
 	pin_info.auth_id.len = 1;
 	pin_info.auth_id.value[0] = 2;
 	pin_info.path.aid = sc_hsm_aid;
 	pin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;
 	pin_info.attrs.pin.reference = 0x88;
 	pin_info.attrs.pin.flags = SC_PKCS15_PIN_FLAG_LOCAL|SC_PKCS15_PIN_FLAG_INITIALIZED|SC_PKCS15_PIN_FLAG_UNBLOCK_DISABLED|SC_PKCS15_PIN_FLAG_SO_PIN;
 	pin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_BCD;
 	pin_info.attrs.pin.min_length = 16;
 	pin_info.attrs.pin.stored_length = 0;
 	pin_info.attrs.pin.max_length = 16;
 	pin_info.attrs.pin.pad_char = '\0';
 	pin_info.tries_left = 15;
 	pin_info.max_tries = 15;
 	strlcpy(pin_obj.label, ""SOPIN"", sizeof(pin_obj.label));
 	pin_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE;
 	r = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);
 	if (r < 0)
 		LOG_FUNC_RETURN(card->ctx, r);
 	if (card->type == SC_CARD_TYPE_SC_HSM_SOC
 			|| card->type == SC_CARD_TYPE_SC_HSM_GOID) {
 		r = SC_SUCCESS;
 	} else {
 		memset(&pindata, 0, sizeof(pindata));
 		pindata.cmd = SC_PIN_CMD_GET_INFO;
 		pindata.pin_type = SC_AC_CHV;
 		pindata.pin_reference = 0x85;
 		r = sc_pin_cmd(card, &pindata, NULL);
 	}
 	if (r == SC_ERROR_DATA_OBJECT_NOT_FOUND) {
 		memset(&pindata, 0, sizeof(pindata));
 		pindata.cmd = SC_PIN_CMD_GET_INFO;
 		pindata.pin_type = SC_AC_CHV;
 		pindata.pin_reference = 0x86;
 		r = sc_pin_cmd(card, &pindata, NULL);
 	}
 	if ((r != SC_ERROR_DATA_OBJECT_NOT_FOUND) && (r != SC_ERROR_INCORRECT_PARAMETERS))
 		card->caps |= SC_CARD_CAP_PROTECTED_AUTHENTICATION_PATH;
 	filelistlength = sc_list_files(card, filelist, sizeof(filelist));
 	LOG_TEST_RET(card->ctx, filelistlength, ""Could not enumerate file and key identifier"");
 	for (i = 0; i < filelistlength; i += 2) {
 		switch(filelist[i]) {
 		case KEY_PREFIX:
 			r = sc_pkcs15emu_sc_hsm_add_prkd(p15card, filelist[i + 1]);
 			break;
 		case DCOD_PREFIX:
 			r = sc_pkcs15emu_sc_hsm_add_dcod(p15card, filelist[i + 1]);
 			break;
 		case CD_PREFIX:
 			r = sc_pkcs15emu_sc_hsm_add_cd(p15card, filelist[i + 1]);
 			break;
 		}
 		if (r != SC_SUCCESS) {
 			sc_log(card->ctx, ""Error %d adding elements to framework"", r);
 		}
 	}
 	LOG_FUNC_RETURN(card->ctx, SC_SUCCESS);
 }","[43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54]",A double free when handling responses from an HSM Card in sc_pkcs15emu_sc_hsm_init in libopensc/pkcs15-sc-hsm.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.,OpenSC,CVE-2018-16425,CWE-415
5330,182232," pgp_enumerate_blob(sc_card_t *card, pgp_blob_t *blob)
 {
 	const u8	*in;
 	int		r;
 	if (blob->files != NULL)
 		return SC_SUCCESS;
 	if ((r = pgp_read_blob(card, blob)) < 0)
 		return r;
 	in = blob->data;
 	while ((int) blob->len > (in - blob->data)) {
 		unsigned int	cla, tag, tmptag;
 		size_t		len;
  		const u8	*data = in;
  		pgp_blob_t	*new;
 		if (!in)
 			return SC_ERROR_OBJECT_NOT_VALID;
  		r = sc_asn1_read_tag(&data, blob->len - (in - blob->data),
  					&cla, &tag, &len);
  		if (r < 0 || data == NULL) {
 			sc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,
 				 ""Unexpected end of contents\n"");
  			return SC_ERROR_OBJECT_NOT_VALID;
  		}
 		if (data + len > blob->data + blob->len)
 			return SC_ERROR_OBJECT_NOT_VALID;
  		for (tmptag = tag; tmptag > 0x0FF; tmptag >>= 8) {
  			cla <<= 8;
 		}
 		tag |= cla;
 		if (tag == blob->id) {
 			in = data;
 			continue;
 		}
 		if ((new = pgp_new_blob(card, blob, tag, sc_file_new())) == NULL)
 			return SC_ERROR_OUT_OF_MEMORY;
 		pgp_set_blob(new, data, len);
 		in = data + len;
 	}
 	return SC_SUCCESS;
 }","[15, 16, 24, 25]",Various out of bounds reads when handling responses in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to potentially crash the opensc library using programs.,OpenSC,CVE-2018-16427,CWE-125
5342,181493," static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)
 {
  	jp2_cdef_t *cdef = &box->data.cdef;
  	jp2_cdefchan_t *chan;
  	unsigned int channo;
 	cdef->ents = 0;
  	if (jp2_getuint16(in, &cdef->numchans)) {
  		return -1;
  	}
 	if (!(cdef->ents = jas_alloc2(cdef->numchans, sizeof(jp2_cdefchan_t)))) {
 		return -1;
 	}
 	for (channo = 0; channo < cdef->numchans; ++channo) {
 		chan = &cdef->ents[channo];
 		if (jp2_getuint16(in, &chan->channo) || jp2_getuint16(in, &chan->type) ||
 		  jp2_getuint16(in, &chan->assoc)) {
 			return -1;
 		}
 	}
 	return 0;
 }",[6],The jp2_cdef_destroy function in jp2_cod.c in JasPer before 2.0.13 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted image.,jasper,CVE-2017-6850,CWE-476
5353,181667," static int rtmp_packet_read_one_chunk(URLContext *h, RTMPPacket *p,
                                       int chunk_size, RTMPPacket **prev_pkt_ptr,
                                       int *nb_prev_pkt, uint8_t hdr)
 {
     uint8_t buf[16];
     int channel_id, timestamp, size;
     uint32_t ts_field;  
     uint32_t extra = 0;
     enum RTMPPacketType type;
     int written = 0;
     int ret, toread;
     RTMPPacket *prev_pkt;
     written++;
     channel_id = hdr & 0x3F;
     if (channel_id < 2) {  
         buf[1] = 0;
         if (ffurl_read_complete(h, buf, channel_id + 1) != channel_id + 1)
             return AVERROR(EIO);
         written += channel_id + 1;
         channel_id = AV_RL16(buf) + 64;
     }
     if ((ret = ff_rtmp_check_alloc_array(prev_pkt_ptr, nb_prev_pkt,
                                          channel_id)) < 0)
         return ret;
     prev_pkt = *prev_pkt_ptr;
     size  = prev_pkt[channel_id].size;
     type  = prev_pkt[channel_id].type;
     extra = prev_pkt[channel_id].extra;
     hdr >>= 6;  
     if (hdr == RTMP_PS_ONEBYTE) {
         ts_field = prev_pkt[channel_id].ts_field;
     } else {
         if (ffurl_read_complete(h, buf, 3) != 3)
             return AVERROR(EIO);
         written += 3;
         ts_field = AV_RB24(buf);
         if (hdr != RTMP_PS_FOURBYTES) {
             if (ffurl_read_complete(h, buf, 3) != 3)
                 return AVERROR(EIO);
             written += 3;
             size = AV_RB24(buf);
             if (ffurl_read_complete(h, buf, 1) != 1)
                 return AVERROR(EIO);
             written++;
             type = buf[0];
             if (hdr == RTMP_PS_TWELVEBYTES) {
                 if (ffurl_read_complete(h, buf, 4) != 4)
                     return AVERROR(EIO);
                 written += 4;
                 extra = AV_RL32(buf);
             }
         }
     }
     if (ts_field == 0xFFFFFF) {
         if (ffurl_read_complete(h, buf, 4) != 4)
             return AVERROR(EIO);
         timestamp = AV_RB32(buf);
     } else {
         timestamp = ts_field;
     }
      if (hdr != RTMP_PS_TWELVEBYTES)
          timestamp += prev_pkt[channel_id].timestamp;
     if (prev_pkt[channel_id].read && size != prev_pkt[channel_id].size) {
         av_log(NULL, AV_LOG_ERROR, ""RTMP packet size mismatch %d != %d\n"",
                 size,
                 prev_pkt[channel_id].size);
         ff_rtmp_packet_destroy(&prev_pkt[channel_id]);
         prev_pkt[channel_id].read = 0;
     }
      if (!prev_pkt[channel_id].read) {
          if ((ret = ff_rtmp_packet_create(p, channel_id, type, timestamp,
                                           size)) < 0)
             return ret;
         p->read = written;
         p->offset = 0;
         prev_pkt[channel_id].ts_field   = ts_field;
         prev_pkt[channel_id].timestamp  = timestamp;
     } else {
         RTMPPacket *prev = &prev_pkt[channel_id];
         p->data          = prev->data;
         p->size          = prev->size;
         p->channel_id    = prev->channel_id;
         p->type          = prev->type;
         p->ts_field      = prev->ts_field;
         p->extra         = prev->extra;
         p->offset        = prev->offset;
         p->read          = prev->read + written;
         p->timestamp     = prev->timestamp;
         prev->data       = NULL;
     }
     p->extra = extra;
     prev_pkt[channel_id].channel_id = channel_id;
     prev_pkt[channel_id].type       = type;
     prev_pkt[channel_id].size       = size;
     prev_pkt[channel_id].extra      = extra;
     size = size - p->offset;
     toread = FFMIN(size, chunk_size);
     if (ffurl_read_complete(h, p->data + p->offset, toread) != toread) {
         ff_rtmp_packet_destroy(p);
         return AVERROR(EIO);
     }
     size      -= toread;
     p->read   += toread;
     p->offset += toread;
     if (size > 0) {
        RTMPPacket *prev = &prev_pkt[channel_id];
        prev->data = p->data;
        prev->read = p->read;
        prev->offset = p->offset;
        p->data      = NULL;
        return AVERROR(EAGAIN);
     }
     prev_pkt[channel_id].read = 0;  
     return p->read;
 }","[63, 64, 65, 66, 67, 68, 69]","Heap-based buffer overflow in libavformat/rtmppkt.c in FFmpeg before 2.8.10, 3.0.x before 3.0.5, 3.1.x before 3.1.6, and 3.2.x before 3.2.2 allows remote attackers to execute arbitrary code by leveraging failure to check for RTMP packet size mismatches.",FFmpeg,CVE-2016-10191,CWE-119
5359,180064," Strgrow(Str x)
  {
      char *old = x->ptr;
      int newlen;
    newlen = x->length * 6 / 5;
    if (newlen == x->length)
     newlen = x->area_size * 6 / 5;
     if (newlen == x->area_size)
  	newlen += 2;
      x->ptr = GC_MALLOC_ATOMIC(newlen);
      x->area_size = newlen;
     bcopy((void *)old, (void *)x->ptr, x->length);
     GC_free(old);
 }","[5, 6, 7, 8]",An issue was discovered in the Tatsuya Kinoshita w3m fork before 0.5.3-31. w3m allows remote attackers to cause memory corruption in certain conditions via a crafted HTML page.,w3m,CVE-2016-9442,CWE-119
5382,177803,"  static void build_l4proto_sctp(const struct nf_conntrack *ct, struct nethdr *n)
  {
	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
		      sizeof(struct nfct_attr_grp_port));
  	if (!nfct_attr_is_set(ct, ATTR_SCTP_STATE))
  		return;
 	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
 		      sizeof(struct nfct_attr_grp_port));
  	ct_build_u8(ct, ATTR_SCTP_STATE, n, NTA_SCTP_STATE);
  	ct_build_u32(ct, ATTR_SCTP_VTAG_ORIG, n, NTA_SCTP_VTAG_ORIG);
  	ct_build_u32(ct, ATTR_SCTP_VTAG_REPL, n, NTA_SCTP_VTAG_REPL);
 }","[3, 4, 7, 8]","conntrackd in conntrack-tools 1.4.2 and earlier does not ensure that the optional kernel modules are loaded before using them, which allows remote attackers to cause a denial of service (crash) via a (1) DCCP, (2) SCTP, or (3) ICMPv6 packet.",netfilter,CVE-2015-6496,CWE-17
5388,178616,"  SProcXFixesQueryVersion(ClientPtr client)
  {
      REQUEST(xXFixesQueryVersionReq);
     REQUEST_SIZE_MATCH(xXFixesQueryVersionReq);
      swaps(&stuff->length);
      swapl(&stuff->majorVersion);
     return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
 }",[4],xorg-x11-server before 1.19.5 was missing length validation in XFIXES extension allowing malicious X client to cause X server to crash or possibly execute arbitrary code.,xserver,CVE-2017-12183,CWE-20
5389,179583," poly_in(PG_FUNCTION_ARGS)
 {
 	char	   *str = PG_GETARG_CSTRING(0);
  	POLYGON    *poly;
  	int			npts;
  	int			size;
 	int			base_size;
  	int			isopen;
  	char	   *s;
 	if ((npts = pair_count(str, ',')) <= 0)
 		ereport(ERROR,
  				(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),
  			  errmsg(""invalid input syntax for type polygon: \""%s\"""", str)));
	size = offsetof(POLYGON, p[0]) +sizeof(poly->p[0]) * npts;
 	base_size = sizeof(poly->p[0]) * npts;
 	size = offsetof(POLYGON, p[0]) + base_size;
 	if (base_size / npts != sizeof(poly->p[0]) || size <= base_size)
 		ereport(ERROR,
 				(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),
 				 errmsg(""too many points requested"")));
  	poly = (POLYGON *) palloc0(size);	 
  	SET_VARSIZE(poly, size);
 	poly->npts = npts;
 	if ((!path_decode(FALSE, npts, str, &isopen, &s, &(poly->p[0])))
 		|| (*s != '\0'))
 		ereport(ERROR,
 				(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),
 			  errmsg(""invalid input syntax for type polygon: \""%s\"""", str)));
 	make_bound_box(poly);
 	PG_RETURN_POLYGON_P(poly);
 }","[7, 14, 15, 16, 17, 18, 19, 20]","Multiple integer overflows in contrib/hstore/hstore_io.c in PostgreSQL 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact via vectors related to the (1) hstore_recv, (2) hstore_from_arrays, and (3) hstore_from_array functions in contrib/hstore/hstore_io.c; and the (4) hstoreArrayToPairs function in contrib/hstore/hstore_op.c, which triggers a buffer overflow.  NOTE: this issue was SPLIT from CVE-2014-0064 because it has a different set of affected versions.",postgres,CVE-2014-2669,CWE-189
5424,182658," static av_cold int vqa_decode_init(AVCodecContext *avctx)
 {
     VqaContext *s = avctx->priv_data;
     int i, j, codebook_index, ret;
     s->avctx = avctx;
     avctx->pix_fmt = AV_PIX_FMT_PAL8;
     if (s->avctx->extradata_size != VQA_HEADER_SIZE) {
         av_log(s->avctx, AV_LOG_ERROR, ""expected extradata size of %d\n"", VQA_HEADER_SIZE);
         return AVERROR(EINVAL);
     }
     s->vqa_version = s->avctx->extradata[0];
     switch (s->vqa_version) {
     case 1:
     case 2:
         break;
     case 3:
         avpriv_report_missing_feature(avctx, ""VQA Version %d"", s->vqa_version);
         return AVERROR_PATCHWELCOME;
     default:
         avpriv_request_sample(avctx, ""VQA Version %i"", s->vqa_version);
         return AVERROR_PATCHWELCOME;
      }
      s->width = AV_RL16(&s->avctx->extradata[6]);
      s->height = AV_RL16(&s->avctx->extradata[8]);
    if ((ret = av_image_check_size(s->width, s->height, 0, avctx)) < 0) {
     if ((ret = ff_set_dimensions(avctx, s->width, s->height)) < 0) {
          s->width= s->height= 0;
          return ret;
      }
     s->vector_width = s->avctx->extradata[10];
     s->vector_height = s->avctx->extradata[11];
     s->partial_count = s->partial_countdown = s->avctx->extradata[13];
     if ((s->vector_width != 4) ||
         ((s->vector_height != 2) && (s->vector_height != 4))) {
         return AVERROR_INVALIDDATA;
     }
     if (s->width % s->vector_width || s->height % s->vector_height) {
         av_log(avctx, AV_LOG_ERROR, ""Image size not multiple of block size\n"");
         return AVERROR_INVALIDDATA;
     }
     s->codebook_size = MAX_CODEBOOK_SIZE;
     s->codebook = av_malloc(s->codebook_size);
     if (!s->codebook)
         goto fail;
     s->next_codebook_buffer = av_malloc(s->codebook_size);
     if (!s->next_codebook_buffer)
         goto fail;
     s->decode_buffer_size = (s->width / s->vector_width) *
         (s->height / s->vector_height) * 2;
     s->decode_buffer = av_mallocz(s->decode_buffer_size);
     if (!s->decode_buffer)
         goto fail;
     if (s->vector_height == 4) {
         codebook_index = 0xFF00 * 16;
         for (i = 0; i < 256; i++)
             for (j = 0; j < 16; j++)
                 s->codebook[codebook_index++] = i;
     } else {
         codebook_index = 0xF00 * 8;
         for (i = 0; i < 256; i++)
             for (j = 0; j < 8; j++)
                 s->codebook[codebook_index++] = i;
     }
     s->next_codebook_buffer_index = 0;
     return 0;
 fail:
     av_freep(&s->codebook);
     av_freep(&s->next_codebook_buffer);
     av_freep(&s->decode_buffer);
     return AVERROR(ENOMEM);
 }","[25, 26]",FFmpeg before 4.2 has a heap-based buffer overflow in vqa_decode_chunk because of an out-of-array access in vqa_decode_init in libavcodec/vqavideo.c.,FFmpeg,CVE-2019-17542,
5472,183316," tTcpIpPacketParsingResult ParaNdis_ReviewIPPacket(PVOID buffer, ULONG size, LPCSTR caller)
 tTcpIpPacketParsingResult ParaNdis_ReviewIPPacket(PVOID buffer, ULONG size, BOOLEAN verifyLength, LPCSTR caller)
  {
    tTcpIpPacketParsingResult res = QualifyIpPacket((IPHeader *) buffer, size);
     tTcpIpPacketParsingResult res = QualifyIpPacket((IPHeader *) buffer, size, verifyLength);
      PrintOutParsingResult(res, 1, caller);
      return res;
  }","[2, 4, 5]","The NetKVM Windows Virtio driver allows remote attackers to cause a denial of service (guest crash) via a crafted length value in an IP packet, as demonstrated by a value that does not account for the size of the IP options.",kvm-guest-drivers-windows,CVE-2015-3215,CWE-20
5489,178050," void CtcpHandler::handlePing(CtcpType ctcptype, const QString &prefix, const QString &target, const QString &param) {
 void CtcpHandler::handlePing(CtcpType ctcptype, const QString &prefix, const QString &target, const QString &param, QString &reply) {
    Q_UNUSED(target)
    if(ctcptype == CtcpQuery) {
    if(_ignoreListManager->ctcpMatch(prefix, network()->networkName(), ""PING""))
      return;
    reply(nickFromMask(prefix), ""PING"", param);
     reply = param;
      emit displayMsg(Message::Server, BufferInfo::StatusBuffer, """", tr(""Received CTCP PING request from %1"").arg(prefix));
    } else {
     emit displayMsg(Message::Server, BufferInfo::StatusBuffer, """", tr(""Received CTCP TIME request by %1"").arg(prefix));
   }
   else {
     emit displayMsg(Message::Server, BufferInfo::StatusBuffer, """", tr(""Received CTCP TIME answer from %1: %2"")
    }
  }","[2, 5, 6, 7, 8]",ctcphandler.cpp in Quassel before 0.6.3 and 0.7.x before 0.7.1 allows remote attackers to cause a denial of service (unresponsive IRC) via multiple Client-To-Client Protocol (CTCP) requests in a PRIVMSG message.,quassel,CVE-2010-3443,CWE-399
5493,178697," void parser(void)
 {
     char *arg;
 #ifndef MINIMAL
     char *sitearg;
 #endif
 #ifdef WITH_RFC2640
     char *narg = NULL;
 #endif
     size_t n;
 #ifdef IMPLICIT_TLS
     (void) tls_init_new_session();
     data_protection_level = CPL_PRIVATE;
 #endif
     for (;;) {
         xferfd = -1;
         if (state_needs_update != 0) {
             state_needs_update = 0;
             setprocessname(""pure-ftpd (IDLE)"");
 #ifdef FTPWHO
             if (shm_data_cur != NULL) {
                 ftpwho_lock();
                 shm_data_cur->state = FTPWHO_STATE_IDLE;
                 *shm_data_cur->filename = 0;
                 ftpwho_unlock();
             }
 #endif
         }
         doreply();
         alarm(idletime * 2);
         switch (sfgets()) {
         case -1:
 #ifdef BORING_MODE
             die(421, LOG_INFO, MSG_TIMEOUT);
 #else
             die(421, LOG_INFO, MSG_TIMEOUT_PARSER);
 #endif
         case -2:
             return;
         }
 #ifdef DEBUG
         if (debug != 0) {
             addreply(0, ""%s"", cmd);
         }
 #endif
         n = (size_t) 0U;
         while ((isalpha((unsigned char) cmd[n]) || cmd[n] == '@') &&
                n < cmdsize) {
             cmd[n] = (char) tolower((unsigned char) cmd[n]);
             n++;
         }
         if (n >= cmdsize) {             
             die(421, LOG_WARNING, MSG_LINE_TOO_LONG);
         }
         if (n == (size_t) 0U) {
             nop:
             addreply_noformat(500, ""?"");
             continue;
         }
 #ifdef SKIP_COMMAND_TRAILING_SPACES        
         while (isspace((unsigned char) cmd[n]) && n < cmdsize) {
             cmd[n++] = 0;
         }
         arg = cmd + n;        
         while (cmd[n] != 0 && n < cmdsize) {
             n++;
         }
         n--;
         while (isspace((unsigned char) cmd[n])) {
             cmd[n--] = 0;
         }
 #else
         if (cmd[n] == 0) {
             arg = cmd + n;
         } else if (isspace((unsigned char) cmd[n])) {
             cmd[n] = 0;
             arg = cmd + n + 1;
         } else {
             goto nop;
         }
 #endif
         if (logging != 0) {
 #ifdef DEBUG
             logfile(LOG_DEBUG, MSG_DEBUG_COMMAND "" [%s] [%s]"",
                    cmd, arg);
 #else
             logfile(LOG_DEBUG, MSG_DEBUG_COMMAND "" [%s] [%s]"",
                    cmd, strcmp(cmd, ""pass"") ? arg : ""<*>"");
 #endif
         }
 #ifdef WITH_RFC2640
         narg = charset_client2fs(arg);
 	arg = narg;
 #endif
 #ifndef MINIMAL
         if (!strcmp(cmd, ""noop"")) {
             antiidle();
             donoop();
             goto wayout;
         }
 #endif
         if (!strcmp(cmd, ""user"")) {
 #ifdef WITH_TLS
             if (enforce_tls_auth > 1 && tls_cnx == NULL) {
                 die(421, LOG_WARNING, MSG_TLS_NEEDED);
             }
 #endif
             douser(arg);
         } else if (!strcmp(cmd, ""acct"")) {
             addreply(202, MSG_WHOAREYOU);
         } else if (!strcmp(cmd, ""pass"")) {
             if (guest == 0) {
                 randomdelay();
             }
             dopass(arg);
         } else if (!strcmp(cmd, ""quit"")) {
             addreply(221, MSG_GOODBYE,
                      (unsigned long long) ((uploaded + 1023ULL) / 1024ULL),
                      (unsigned long long) ((downloaded + 1023ULL) / 1024ULL));
             return;
         } else if (!strcmp(cmd, ""syst"")) {
             antiidle();
             addreply_noformat(215, ""UNIX Type: L8"");
             goto wayout;
 #ifdef WITH_TLS
         } else if (enforce_tls_auth > 0 &&
                    !strcmp(cmd, ""auth"") && !strcasecmp(arg, ""tls"")) {
              addreply_noformat(234, ""AUTH TLS OK."");
              doreply();
              if (tls_cnx == NULL) {
                 flush_cmd();
                  (void) tls_init_new_session();
              }
              goto wayout;
         } else if (!strcmp(cmd, ""pbsz"")) {
             addreply_noformat(tls_cnx == NULL ? 503 : 200, ""PBSZ=0"");
         } else if (!strcmp(cmd, ""prot"")) {
             if (tls_cnx == NULL) {
                 addreply_noformat(503, MSG_PROT_BEFORE_PBSZ);
                 goto wayout;
             }
             switch (*arg) {
             case 0:
                 addreply_noformat(503, MSG_MISSING_ARG);
                 data_protection_level = CPL_NONE;
                 break;
             case 'C':
                 if (arg[1] == 0) {
                     addreply(200, MSG_PROT_OK, ""clear"");
                     data_protection_level = CPL_CLEAR;
                     break;
                 }
             case 'S':
             case 'E':
                 if (arg[1] == 0) {
                     addreply(200, MSG_PROT_UNKNOWN_LEVEL, arg, ""private"");
                     data_protection_level = CPL_PRIVATE;
                     break;
                 }
             case 'P':
                 if (arg[1] == 0) {
                     addreply(200, MSG_PROT_OK, ""private"");
                     data_protection_level = CPL_PRIVATE;
                     break;
                 }
             default:
                 addreply_noformat(534, ""Fallback to [C]"");
                 data_protection_level = CPL_CLEAR;
                 break;
             }
 #endif
         } else if (!strcmp(cmd, ""auth"") || !strcmp(cmd, ""adat"")) {
             addreply_noformat(500, MSG_AUTH_UNIMPLEMENTED);
         } else if (!strcmp(cmd, ""type"")) {
             antiidle();
             dotype(arg);
             goto wayout;
         } else if (!strcmp(cmd, ""mode"")) {
             antiidle();                
             domode(arg);
             goto wayout;
 #ifndef MINIMAL
         } else if (!strcmp(cmd, ""feat"")) {
             dofeat();
             goto wayout;
 	} else if (!strcmp(cmd, ""opts"")) {
 	    doopts(arg);
 	    goto wayout;
 #endif
         } else if (!strcmp(cmd, ""stru"")) {
             dostru(arg);
             goto wayout;
 #ifndef MINIMAL
         } else if (!strcmp(cmd, ""help"")) {
             goto help_site;
 #endif
 #ifdef DEBUG
         } else if (!strcmp(cmd, ""xdbg"")) {
             debug++;
             addreply(200, MSG_XDBG_OK, debug);
             goto wayout;
 #endif            
         } else if (loggedin == 0) {            
             addreply_noformat(530, MSG_NOT_LOGGED_IN);
             goto wayout;
         } else {
             if (!strcmp(cmd, ""cwd"") || !strcmp(cmd, ""xcwd"")) {
                 antiidle();
                 docwd(arg);
                 goto wayout;
             } else if (!strcmp(cmd, ""port"")) {
                 doport(arg);
 #ifndef MINIMAL
             } else if (!strcmp(cmd, ""eprt"")) {
                 doeprt(arg);
             } else if (!strcmp(cmd, ""esta"") &&
                        disallow_passive == 0 &&
                        STORAGE_FAMILY(force_passive_ip) == 0) {
                 doesta();
             } else if (!strcmp(cmd, ""estp"")) {
                 doestp();
 #endif
             } else if (disallow_passive == 0 && 
                        (!strcmp(cmd, ""pasv"") || !strcmp(cmd, ""p@sw""))) {
                 dopasv(0);
             } else if (disallow_passive == 0 && 
                        (!strcmp(cmd, ""epsv"") && 
                        (broken_client_compat == 0 ||
                         STORAGE_FAMILY(ctrlconn) == AF_INET6))) {
                 if (!strcasecmp(arg, ""all"")) {
                     epsv_all = 1;
                     addreply_noformat(220, MSG_ACTIVE_DISABLED);
                 } else if (!strcmp(arg, ""2"") && !v6ready) {
                     addreply_noformat(522, MSG_ONLY_IPV4);
                 } else {
                     dopasv(1);
                 }
 #ifndef MINIMAL            
             } else if (disallow_passive == 0 && !strcmp(cmd, ""spsv"")) {
                 dopasv(2);
             } else if (!strcmp(cmd, ""allo"")) {
                 if (*arg == 0) {
                     addreply_noformat(501, MSG_STAT_FAILURE);
                 } else {
                     const off_t size = (off_t) strtoull(arg, NULL, 10);
                     if (size < (off_t) 0) {
                         addreply_noformat(501, MSG_STAT_FAILURE);                        
                     } else {
                         doallo(size);
                     }
                 }
 #endif
             } else if (!strcmp(cmd, ""pwd"") || !strcmp(cmd, ""xpwd"")) {
 #ifdef WITH_RFC2640
 		char *nwd;
 #endif
                 antiidle();
 #ifdef WITH_RFC2640
 		nwd = charset_fs2client(wd);
 		addreply(257, ""\""%s\"" "" MSG_IS_YOUR_CURRENT_LOCATION, nwd);
 		free(nwd);
 #else
                 addreply(257, ""\""%s\"" "" MSG_IS_YOUR_CURRENT_LOCATION, wd);
 #endif
                 goto wayout;                
             } else if (!strcmp(cmd, ""cdup"") || !strcmp(cmd, ""xcup"")) {
                 docwd("".."");
             } else if (!strcmp(cmd, ""retr"")) {
                 if (*arg != 0) {
 #ifdef WITH_TLS
                     if (enforce_tls_auth == 3 &&
                         data_protection_level != CPL_PRIVATE) {
                         addreply_noformat(521, MSG_PROT_PRIVATE_NEEDED);
                     }
                     else
 #endif
                     {
                         doretr(arg);
                     }
                 } else {
                     addreply_noformat(501, MSG_NO_FILE_NAME);
                 }
             } else if (!strcmp(cmd, ""rest"")) {
                 antiidle();
                 if (*arg != 0) {
                     dorest(arg);
                 } else {
                     addreply_noformat(501, MSG_NO_RESTART_POINT);
                     restartat = (off_t) 0;
                 }
                 goto wayout;
             } else if (!strcmp(cmd, ""dele"")) {
                 if (*arg != 0) {
                     dodele(arg);
                 } else {
                     addreply_noformat(501, MSG_NO_FILE_NAME);
                 }
             } else if (!strcmp(cmd, ""stor"")) {
                 arg = revealextraspc(arg);
                 if (*arg != 0) {
 #ifdef WITH_TLS
                     if (enforce_tls_auth == 3 &&
                         data_protection_level != CPL_PRIVATE) {
                         addreply_noformat(521, MSG_PROT_PRIVATE_NEEDED);
                     } else 
 #endif
                     {
                         dostor(arg, 0, autorename);
                     }
                 } else {
                     addreply_noformat(501, MSG_NO_FILE_NAME);
                 }
             } else if (!strcmp(cmd, ""appe"")) {
                 arg = revealextraspc(arg);
                 if (*arg != 0) {
 #ifdef WITH_TLS
                     if (enforce_tls_auth == 3 &&
                         data_protection_level != CPL_PRIVATE) {
                         addreply_noformat(521, MSG_PROT_PRIVATE_NEEDED);
                     } else 
 #endif
                     {
                         dostor(arg, 1, 0);
                     }
                 } else {
                     addreply_noformat(501, MSG_NO_FILE_NAME);
                 }
 #ifndef MINIMAL
             } else if (!strcmp(cmd, ""stou"")) {
 #ifdef WITH_TLS
                 if (enforce_tls_auth == 3 &&
                     data_protection_level != CPL_PRIVATE) {
                     addreply_noformat(521, MSG_PROT_PRIVATE_NEEDED);
                 } else 
 #endif
                 {
             	     dostou();
                 }
 #endif
 #ifndef DISABLE_MKD_RMD
             } else if (!strcmp(cmd, ""mkd"") || !strcmp(cmd, ""xmkd"")) {
                 arg = revealextraspc(arg);
                 if (*arg != 0) {
                     domkd(arg);
                 } else {
                     addreply_noformat(501, MSG_NO_DIRECTORY_NAME);
                 }
             } else if (!strcmp(cmd, ""rmd"") || !strcmp(cmd, ""xrmd"")) {
                 if (*arg != 0) {
                     dormd(arg);
                 } else {
                     addreply_noformat(550, MSG_NO_DIRECTORY_NAME);
                 }
 #endif
 #ifndef MINIMAL
             } else if (!strcmp(cmd, ""stat"")) {
                 if (*arg != 0) {
                     modern_listings = 0;
                     donlist(arg, 1, 1, 1, 1);
                 } else {
                     addreply_noformat(211, ""http:www.pureftpd.org/"");
                 }
 #endif
             } else if (!strcmp(cmd, ""list"")) {
 #ifndef MINIMAL
                 modern_listings = 0;
 #endif
 #ifdef WITH_TLS
                 if (enforce_tls_auth == 3 &&
                     data_protection_level != CPL_PRIVATE) {
                     addreply_noformat(521, MSG_PROT_PRIVATE_NEEDED);
                 } else
 #endif
                 {
                     donlist(arg, 0, 1, 0, 1);
                 }
             } else if (!strcmp(cmd, ""nlst"")) {
 #ifndef MINIMAL                
                 modern_listings = 0;
 #endif
 #ifdef WITH_TLS
                 if (enforce_tls_auth == 3 &&
                     data_protection_level != CPL_PRIVATE) {
                     addreply_noformat(521, MSG_PROT_PRIVATE_NEEDED);
                 } else
 #endif
                 {
                     donlist(arg, 0, 0, 0, broken_client_compat);
                 }
 #ifndef MINIMAL
             } else if (!strcmp(cmd, ""mlst"")) {
 #ifdef WITH_TLS
                 if (enforce_tls_auth == 3 &&
                     data_protection_level != CPL_PRIVATE) {
                     addreply_noformat(521, MSG_PROT_PRIVATE_NEEDED);
                 } else
 #endif
                 {
                     domlst(*arg != 0 ? arg : ""."");
                 }
             } else if (!strcmp(cmd, ""mlsd"")) {
                 modern_listings = 1;
 #ifdef WITH_TLS
                 if (enforce_tls_auth == 3 &&
                     data_protection_level != CPL_PRIVATE) {
                     addreply_noformat(521, MSG_PROT_PRIVATE_NEEDED);
                 } else
 #endif
                 {
                     donlist(arg, 0, 1, 1, 0);
                 }
 #endif
             } else if (!strcmp(cmd, ""abor"")) {
                 addreply_noformat(226, MSG_ABOR_SUCCESS);
 #ifndef MINIMAL
             } else if (!strcmp(cmd, ""site"")) {
                 if ((sitearg = arg) != NULL) {
                     while (*sitearg != 0 && !isspace((unsigned char) *sitearg)) {
                         sitearg++;
                     }
                     if (*sitearg != 0) {
                         *sitearg++ = 0;
                     }
                 }
                 if (!strcasecmp(arg, ""idle"")) {
                     if (sitearg == NULL || *sitearg == 0) {
                         addreply_noformat(501, ""SITE IDLE: "" MSG_MISSING_ARG);
                     } else {
                         unsigned long int i = 0;
                         i = strtoul(sitearg, &sitearg, 10);
                         if (sitearg && *sitearg)
                             addreply(501, MSG_GARBAGE_FOUND "" : %s"", sitearg);
                         else if (i > MAX_SITE_IDLE)
                             addreply_noformat(501, MSG_VALUE_TOO_LARGE);
                         else {
                             idletime = i;
                             addreply(200, MSG_IDLE_TIME, idletime);
                             idletime_noop = (double) idletime * 2.0;
                         }
                     }
                 } else if (!strcasecmp(arg, ""time"")) {
                     dositetime();
                 } else if (!strcasecmp(arg, ""help"")) {
                     help_site:
                     addreply_noformat(214, MSG_SITE_HELP CRLF
 # ifdef WITH_DIRALIASES
                                       "" ALIAS"" CRLF
 # endif
                                       "" CHMOD"" CRLF "" IDLE"" CRLF "" UTIME"");
                     addreply_noformat(214, ""Pure-FTPd - http:pureftpd.org/"");
                 } else if (!strcasecmp(arg, ""chmod"")) {
                     char *sitearg2;
                     mode_t mode;
                     parsechmod:
                     if (sitearg == NULL || *sitearg == 0) {
                         addreply_noformat(501, MSG_MISSING_ARG);
                         goto chmod_wayout;
                     }
                     sitearg2 = sitearg;
                     while (*sitearg2 != 0 && !isspace((unsigned char) *sitearg2)) {
                         sitearg2++;
                     }                    
                     while (*sitearg2 != 0 && isspace((unsigned char) *sitearg2)) {
                         sitearg2++;
                     }                    
                     if (*sitearg2 == 0) {
                         addreply_noformat(550, MSG_NO_FILE_NAME);
                         goto chmod_wayout;
                     }
                     mode = (mode_t) strtoul(sitearg, NULL, 8);
                     if (mode > (mode_t) 07777) {
                         addreply_noformat(501, MSG_BAD_CHMOD);
                         goto chmod_wayout;
                     }
                     dochmod(sitearg2, mode);
                     chmod_wayout:
                     (void) 0;
                 } else if (!strcasecmp(arg, ""utime"")) {
                     char *sitearg2;
                     if (sitearg == NULL || *sitearg == 0) {
                         addreply_noformat(501, MSG_NO_FILE_NAME);
                         goto utime_wayout;
                     }		    
                     if ((sitearg2 = strrchr(sitearg, ' ')) == NULL ||
                         sitearg2 == sitearg) {
                         addreply_noformat(501, MSG_MISSING_ARG);
                         goto utime_wayout;
                     }
                     if (strcasecmp(sitearg2, "" UTC"") != 0) {
                         addreply_noformat(500, ""UTC Only"");
                         goto utime_wayout;			
                     }
                     *sitearg2-- = 0;
                     if ((sitearg2 = strrchr(sitearg, ' ')) == NULL ||
                         sitearg2 == sitearg) {
                         utime_no_arg:
                         addreply_noformat(501, MSG_MISSING_ARG);
                         goto utime_wayout;
                     }
                     *sitearg2-- = 0;
                     if ((sitearg2 = strrchr(sitearg, ' ')) == NULL ||
                         sitearg2 == sitearg) {
                         goto utime_no_arg;
                     }
                     *sitearg2-- = 0;
                     if ((sitearg2 = strrchr(sitearg, ' ')) == NULL ||
                         sitearg2 == sitearg) {
                         goto utime_no_arg;
                     }
                     *sitearg2++ = 0;
                     if (*sitearg2 == 0) {
                         goto utime_no_arg;			
                     }
                     doutime(sitearg, sitearg2);
                     utime_wayout:
                     (void) 0;
 # ifdef WITH_DIRALIASES		    
                 } else if (!strcasecmp(arg, ""alias"")) {
                     if (sitearg == NULL || *sitearg == 0) {
                         print_aliases();
                     } else {
                         const char *alias;
                         if ((alias = lookup_alias(sitearg)) != NULL) {
                             addreply(214, MSG_ALIASES_ALIAS, sitearg, alias);
                         } else {
                             addreply(502, MSG_ALIASES_UNKNOWN, sitearg);
                         }
                     }
 # endif
                 } else if (*arg != 0) {
                     addreply(500, ""SITE %s "" MSG_UNKNOWN_EXTENSION, arg);
                 } else {
                     addreply_noformat(500, ""SITE: "" MSG_MISSING_ARG);
                 }
 #endif
             } else if (!strcmp(cmd, ""mdtm"")) {
                 domdtm(arg);
             } else if (!strcmp(cmd, ""size"")) {
                 dosize(arg);
 #ifndef MINIMAL
             } else if (!strcmp(cmd, ""chmod"")) {
                 sitearg = arg;
                 goto parsechmod;
 #endif
             } else if (!strcmp(cmd, ""rnfr"")) {
                 if (*arg != 0) {
                     dornfr(arg);
                 } else {
                     addreply_noformat(550, MSG_NO_FILE_NAME);
                 }
             } else if (!strcmp(cmd, ""rnto"")) {
                 arg = revealextraspc(arg);
                 if (*arg != 0) {
                     dornto(arg);
                 } else {
                     addreply_noformat(550, MSG_NO_FILE_NAME);
                 }
             } else {
                 addreply_noformat(500, MSG_UNKNOWN_COMMAND);
             }
         }
         noopidle = (time_t) -1;
         wayout:
 #ifdef WITH_RFC2640
         free(narg);
         narg = NULL;
 #endif
 #ifdef THROTTLING
         if (throttling_delay != 0UL) {
             usleep2(throttling_delay);
         }
 #else
         (void) 0;
 #endif
     }
 }",[131],"The STARTTLS implementation in ftp_parser.c in Pure-FTPd before 1.0.30 does not properly restrict I/O buffering, which allows man-in-the-middle attackers to insert commands into encrypted FTP sessions by sending a cleartext command that is processed after TLS is in place, related to a *plaintext command injection* attack, a similar issue to CVE-2011-0411.",pure-ftpd,CVE-2011-1575,CWE-399
5504,179176," static int filter_frame(AVFilterLink *inlink, AVFrame *in)
 {
     AVFilterContext *ctx = inlink->dst;
     LutContext *s = ctx->priv;
     AVFilterLink *outlink = ctx->outputs[0];
     AVFrame *out;
     uint8_t *inrow, *outrow, *inrow0, *outrow0;
     int i, j, plane, direct = 0;
     if (av_frame_is_writable(in)) {
         direct = 1;
         out = in;
     } else {
         out = ff_get_video_buffer(outlink, outlink->w, outlink->h);
         if (!out) {
             av_frame_free(&in);
             return AVERROR(ENOMEM);
         }
         av_frame_copy_props(out, in);
     }
     if (s->is_rgb) {
         inrow0  = in ->data[0];
         outrow0 = out->data[0];
         for (i = 0; i < in->height; i ++) {
             int w = inlink->w;
             const uint8_t (*tab)[256] = (const uint8_t (*)[256])s->lut;
             inrow  = inrow0;
             outrow = outrow0;
             for (j = 0; j < w; j++) {
                 switch (s->step) {
                 case 4:  outrow[3] = tab[3][inrow[3]];  
                 case 3:  outrow[2] = tab[2][inrow[2]];  
                 case 2:  outrow[1] = tab[1][inrow[1]];  
                 default: outrow[0] = tab[0][inrow[0]];
                 }
                 outrow += s->step;
                 inrow  += s->step;
             }
             inrow0  += in ->linesize[0];
             outrow0 += out->linesize[0];
          }
      } else {
        for (plane = 0; plane < 4 && in->data[plane]; plane++) {
         for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++) {
              int vsub = plane == 1 || plane == 2 ? s->vsub : 0;
              int hsub = plane == 1 || plane == 2 ? s->hsub : 0;
              int h = FF_CEIL_RSHIFT(inlink->h, vsub);
             int w = FF_CEIL_RSHIFT(inlink->w, hsub);
             inrow  = in ->data[plane];
             outrow = out->data[plane];
             for (i = 0; i < h; i++) {
                 const uint8_t *tab = s->lut[plane];
                 for (j = 0; j < w; j++)
                     outrow[j] = tab[inrow[j]];
                 inrow  += in ->linesize[plane];
                 outrow += out->linesize[plane];
             }
         }
     }
     if (!direct)
         av_frame_free(&in);
     return ff_filter_frame(outlink, out);
 }","[42, 43]","libavfilter in FFmpeg before 2.0.1 has unspecified impact and remote vectors related to a crafted *plane,* which triggers an out-of-bounds heap write.",FFmpeg,CVE-2013-4263,CWE-119
5506,182290," int ff_mov_write_packet(AVFormatContext *s, AVPacket *pkt)
 {
     MOVMuxContext *mov = s->priv_data;
     AVIOContext *pb = s->pb;
     MOVTrack *trk = &mov->tracks[pkt->stream_index];
     AVCodecParameters *par = trk->par;
     unsigned int samples_in_chunk = 0;
     int size = pkt->size, ret = 0;
     uint8_t *reformatted_data = NULL;
     ret = check_pkt(s, pkt);
     if (ret < 0)
         return ret;
     if (mov->flags & FF_MOV_FLAG_FRAGMENT) {
         int ret;
         if (mov->moov_written || mov->flags & FF_MOV_FLAG_EMPTY_MOOV) {
             if (mov->frag_interleave && mov->fragments > 0) {
                 if (trk->entry - trk->entries_flushed >= mov->frag_interleave) {
                     if ((ret = mov_flush_fragment_interleaving(s, trk)) < 0)
                         return ret;
                 }
             }
             if (!trk->mdat_buf) {
                 if ((ret = avio_open_dyn_buf(&trk->mdat_buf)) < 0)
                     return ret;
             }
             pb = trk->mdat_buf;
         } else {
             if (!mov->mdat_buf) {
                 if ((ret = avio_open_dyn_buf(&mov->mdat_buf)) < 0)
                     return ret;
             }
             pb = mov->mdat_buf;
         }
     }
     if (par->codec_id == AV_CODEC_ID_AMR_NB) {
         static const uint16_t packed_size[16] =
             {13, 14, 16, 18, 20, 21, 27, 32, 6, 0, 0, 0, 0, 0, 0, 1};
         int len = 0;
         while (len < size && samples_in_chunk < 100) {
             len += packed_size[(pkt->data[len] >> 3) & 0x0F];
             samples_in_chunk++;
         }
         if (samples_in_chunk > 1) {
             av_log(s, AV_LOG_ERROR, ""fatal error, input is not a single packet, implement a AVParser for it\n"");
             return -1;
         }
     } else if (par->codec_id == AV_CODEC_ID_ADPCM_MS ||
                par->codec_id == AV_CODEC_ID_ADPCM_IMA_WAV) {
         samples_in_chunk = trk->par->frame_size;
     } else if (trk->sample_size)
         samples_in_chunk = size / trk->sample_size;
      else
          samples_in_chunk = 1;
     if (samples_in_chunk < 1) {
         av_log(s, AV_LOG_ERROR, ""fatal error, input packet contains no samples\n"");
         return AVERROR_PATCHWELCOME;
     }
      if (trk->vos_len == 0 && par->extradata_size > 0 &&
          !TAG_IS_AVCI(trk->tag) &&
         (par->codec_id != AV_CODEC_ID_DNXHD)) {
         trk->vos_len  = par->extradata_size;
         trk->vos_data = av_malloc(trk->vos_len);
         if (!trk->vos_data) {
             ret = AVERROR(ENOMEM);
             goto err;
         }
         memcpy(trk->vos_data, par->extradata, trk->vos_len);
     }
     if (par->codec_id == AV_CODEC_ID_AAC && pkt->size > 2 &&
         (AV_RB16(pkt->data) & 0xfff0) == 0xfff0) {
         if (!s->streams[pkt->stream_index]->nb_frames) {
             av_log(s, AV_LOG_ERROR, ""Malformed AAC bitstream detected: ""
                    ""use the audio bitstream filter 'aac_adtstoasc' to fix it ""
                    ""('-bsf:a aac_adtstoasc' option with ffmpeg)\n"");
             return -1;
         }
         av_log(s, AV_LOG_WARNING, ""aac bitstream error\n"");
     }
     if (par->codec_id == AV_CODEC_ID_H264 && trk->vos_len > 0 && *(uint8_t *)trk->vos_data != 1 && !TAG_IS_AVCI(trk->tag)) {
         if (trk->hint_track >= 0 && trk->hint_track < mov->nb_streams) {
             ff_avc_parse_nal_units_buf(pkt->data, &reformatted_data,
                                        &size);
             avio_write(pb, reformatted_data, size);
         } else {
             if (trk->cenc.aes_ctr) {
                 size = ff_mov_cenc_avc_parse_nal_units(&trk->cenc, pb, pkt->data, size);
                 if (size < 0) {
                     ret = size;
                     goto err;
                 }
             } else {
                 size = ff_avc_parse_nal_units(pb, pkt->data, pkt->size);
             }
         }
     } else if (par->codec_id == AV_CODEC_ID_HEVC && trk->vos_len > 6 &&
                (AV_RB24(trk->vos_data) == 1 || AV_RB32(trk->vos_data) == 1)) {
         if (trk->hint_track >= 0 && trk->hint_track < mov->nb_streams) {
             ff_hevc_annexb2mp4_buf(pkt->data, &reformatted_data, &size, 0, NULL);
             avio_write(pb, reformatted_data, size);
         } else {
             size = ff_hevc_annexb2mp4(pb, pkt->data, pkt->size, 0, NULL);
         }
 #if CONFIG_AC3_PARSER
     } else if (par->codec_id == AV_CODEC_ID_EAC3) {
         size = handle_eac3(mov, pkt, trk);
         if (size < 0)
             return size;
         else if (!size)
             goto end;
         avio_write(pb, pkt->data, size);
 #endif
     } else {
         if (trk->cenc.aes_ctr) {
             if (par->codec_id == AV_CODEC_ID_H264 && par->extradata_size > 4) {
                 int nal_size_length = (par->extradata[4] & 0x3) + 1;
                 ret = ff_mov_cenc_avc_write_nal_units(s, &trk->cenc, nal_size_length, pb, pkt->data, size);
             } else {
                 ret = ff_mov_cenc_write_packet(&trk->cenc, pb, pkt->data, size);
             }
             if (ret) {
                 goto err;
             }
         } else {
             avio_write(pb, pkt->data, size);
         }
     }
     if ((par->codec_id == AV_CODEC_ID_DNXHD ||
          par->codec_id == AV_CODEC_ID_AC3) && !trk->vos_len) {
         trk->vos_len  = size;
         trk->vos_data = av_malloc(size);
         if (!trk->vos_data) {
             ret = AVERROR(ENOMEM);
             goto err;
         }
         memcpy(trk->vos_data, pkt->data, size);
     }
     if (trk->entry >= trk->cluster_capacity) {
         unsigned new_capacity = 2 * (trk->entry + MOV_INDEX_CLUSTER_SIZE);
         if (av_reallocp_array(&trk->cluster, new_capacity,
                               sizeof(*trk->cluster))) {
             ret = AVERROR(ENOMEM);
             goto err;
         }
         trk->cluster_capacity = new_capacity;
     }
     trk->cluster[trk->entry].pos              = avio_tell(pb) - size;
     trk->cluster[trk->entry].samples_in_chunk = samples_in_chunk;
     trk->cluster[trk->entry].chunkNum         = 0;
     trk->cluster[trk->entry].size             = size;
     trk->cluster[trk->entry].entries          = samples_in_chunk;
     trk->cluster[trk->entry].dts              = pkt->dts;
     trk->cluster[trk->entry].pts              = pkt->pts;
     if (!trk->entry && trk->start_dts != AV_NOPTS_VALUE) {
         if (!trk->frag_discont) {
             trk->cluster[trk->entry].dts = trk->start_dts + trk->track_duration;
             if ((mov->flags & FF_MOV_FLAG_DASH && !(mov->flags & FF_MOV_FLAG_GLOBAL_SIDX)) ||
                 mov->mode == MODE_ISM)
                 pkt->pts = pkt->dts + trk->end_pts - trk->cluster[trk->entry].dts;
         } else {
             trk->frag_start = pkt->dts - trk->start_dts;
             trk->end_pts = AV_NOPTS_VALUE;
             trk->frag_discont = 0;
         }
     }
     if (!trk->entry && trk->start_dts == AV_NOPTS_VALUE && !mov->use_editlist &&
         s->avoid_negative_ts == AVFMT_AVOID_NEG_TS_MAKE_ZERO) {
         trk->cluster[trk->entry].dts = trk->start_dts = 0;
     }
     if (trk->start_dts == AV_NOPTS_VALUE) {
         trk->start_dts = pkt->dts;
         if (trk->frag_discont) {
             if (mov->use_editlist) {
                 trk->frag_start = pkt->pts;
                 trk->start_dts  = pkt->dts - pkt->pts;
             } else {
                 trk->frag_start = pkt->dts;
                 trk->start_dts  = 0;
             }
             trk->frag_discont = 0;
         } else if (pkt->dts && mov->moov_written)
             av_log(s, AV_LOG_WARNING,
                    ""Track %d starts with a nonzero dts %""PRId64"", while the moov ""
                    ""already has been written. Set the delay_moov flag to handle ""
                    ""this case.\n"",
                    pkt->stream_index, pkt->dts);
     }
     trk->track_duration = pkt->dts - trk->start_dts + pkt->duration;
     trk->last_sample_is_subtitle_end = 0;
     if (pkt->pts == AV_NOPTS_VALUE) {
         av_log(s, AV_LOG_WARNING, ""pts has no value\n"");
         pkt->pts = pkt->dts;
     }
     if (pkt->dts != pkt->pts)
         trk->flags |= MOV_TRACK_CTTS;
     trk->cluster[trk->entry].cts   = pkt->pts - pkt->dts;
     trk->cluster[trk->entry].flags = 0;
     if (trk->start_cts == AV_NOPTS_VALUE)
         trk->start_cts = pkt->pts - pkt->dts;
     if (trk->end_pts == AV_NOPTS_VALUE)
         trk->end_pts = trk->cluster[trk->entry].dts +
                        trk->cluster[trk->entry].cts + pkt->duration;
     else
         trk->end_pts = FFMAX(trk->end_pts, trk->cluster[trk->entry].dts +
                                            trk->cluster[trk->entry].cts +
                                            pkt->duration);
     if (par->codec_id == AV_CODEC_ID_VC1) {
         mov_parse_vc1_frame(pkt, trk);
     } else if (pkt->flags & AV_PKT_FLAG_KEY) {
         if (mov->mode == MODE_MOV && par->codec_id == AV_CODEC_ID_MPEG2VIDEO &&
             trk->entry > 0) {  
             mov_parse_mpeg2_frame(pkt, &trk->cluster[trk->entry].flags);
             if (trk->cluster[trk->entry].flags & MOV_PARTIAL_SYNC_SAMPLE)
                 trk->flags |= MOV_TRACK_STPS;
         } else {
             trk->cluster[trk->entry].flags = MOV_SYNC_SAMPLE;
         }
         if (trk->cluster[trk->entry].flags & MOV_SYNC_SAMPLE)
             trk->has_keyframes++;
     }
     if (pkt->flags & AV_PKT_FLAG_DISPOSABLE) {
         trk->cluster[trk->entry].flags |= MOV_DISPOSABLE_SAMPLE;
         trk->has_disposable++;
     }
     trk->entry++;
     trk->sample_count += samples_in_chunk;
     mov->mdat_size    += size;
     if (trk->hint_track >= 0 && trk->hint_track < mov->nb_streams)
         ff_mov_add_hinted_packet(s, pkt, trk->hint_track, trk->entry,
                                  reformatted_data, size);
 end:
 err:
     av_free(reformatted_data);
     return ret;
 }","[54, 55, 56, 57]",libavformat/movenc.c in FFmpeg before 4.0.2 allows attackers to cause a denial of service (application crash caused by a divide-by-zero error) with a user crafted Waveform audio file.,FFmpeg,CVE-2018-14394,CWE-369
5517,182930," int main(int argc, char *argv[])
 {
     char buff[1024];
     int fd, nr, nw;
     if (argc < 2) {
         fprintf(stderr,
                 ""usage: %s output-filename\n""
                 ""       %s |output-command\n""
                 ""       %s :host:port\n"", argv[0], argv[0], argv[0]);
         return 1;
     }
     fd = open_gen_fd(argv[1]);
     if (fd < 0) {
         perror(""open_gen_fd"");
         exit(EXIT_FAILURE);
     }
     while ((nr = read(0, buff, sizeof (buff))) != 0) {
         if (nr < 0) {
             if (errno == EINTR)
                 continue;
             perror(""read"");
             exit(EXIT_FAILURE);
         }
         nw = write(fd, buff, nr);
         if (nw < 0) {
             perror(""write"");
              exit(EXIT_FAILURE);
          }
      }
 	close(fd);
      return 0;
  }",[30],Boa through 0.94.14rc21 allows remote attackers to trigger a memory leak because of missing calls to the free function.,boa,CVE-2018-21028,
5532,178129," static int vrend_decode_create_ve(struct vrend_decode_ctx *ctx, uint32_t handle, uint16_t length)
 {
    struct pipe_vertex_element *ve = NULL;
    int num_elements;
    int i;
    int ret;
    if (length < 1)
       return EINVAL;
    if ((length - 1) % 4)
       return EINVAL;
    num_elements = (length - 1) / 4;
    if (num_elements) {
       ve = calloc(num_elements, sizeof(struct pipe_vertex_element));
       if (!ve)
          return ENOMEM;
       for (i = 0; i < num_elements; i++) {
           ve[i].src_offset = get_buf_entry(ctx, VIRGL_OBJ_VERTEX_ELEMENTS_V0_SRC_OFFSET(i));
           ve[i].instance_divisor = get_buf_entry(ctx, VIRGL_OBJ_VERTEX_ELEMENTS_V0_INSTANCE_DIVISOR(i));
           ve[i].vertex_buffer_index = get_buf_entry(ctx, VIRGL_OBJ_VERTEX_ELEMENTS_V0_VERTEX_BUFFER_INDEX(i));
          if (ve[i].vertex_buffer_index >= PIPE_MAX_ATTRIBS)
             return EINVAL;
           ve[i].src_format = get_buf_entry(ctx, VIRGL_OBJ_VERTEX_ELEMENTS_V0_SRC_FORMAT(i));
        }
     }
    return ret;
 }","[20, 21]",The vrend_draw_vbo function in virglrenderer before 0.6.0 allows local guest OS users to cause a denial of service (out-of-bounds array access and QEMU process crash) via vectors involving vertext_buffer_index.,virglrenderer,CVE-2017-5956,CWE-125
5549,182104," parse_codes(struct archive_read *a)
 {
   int i, j, val, n, r;
   unsigned char bitlengths[MAX_SYMBOLS], zerocount, ppmd_flags;
   unsigned int maxorder;
   struct huffman_code precode;
   struct rar *rar = (struct rar *)(a->format->data);
   struct rar_br *br = &(rar->br);
   free_codes(a);
   rar_br_consume_unalined_bits(br);
   if (!rar_br_read_ahead(a, br, 1))
     goto truncated_data;
   if ((rar->is_ppmd_block = rar_br_bits(br, 1)) != 0)
   {
     rar_br_consume(br, 1);
     if (!rar_br_read_ahead(a, br, 7))
       goto truncated_data;
     ppmd_flags = rar_br_bits(br, 7);
     rar_br_consume(br, 7);
     if (ppmd_flags & 0x20)
     {
       if (!rar_br_read_ahead(a, br, 8))
         goto truncated_data;
       rar->dictionary_size = (rar_br_bits(br, 8) + 1) << 20;
       rar_br_consume(br, 8);
     }
     if (ppmd_flags & 0x40)
     {
       if (!rar_br_read_ahead(a, br, 8))
         goto truncated_data;
       rar->ppmd_escape = rar->ppmd7_context.InitEsc = rar_br_bits(br, 8);
       rar_br_consume(br, 8);
     }
     else
       rar->ppmd_escape = 2;
     if (ppmd_flags & 0x20)
     {
       maxorder = (ppmd_flags & 0x1F) + 1;
       if(maxorder > 16)
         maxorder = 16 + (maxorder - 16) * 3;
       if (maxorder == 1)
       {
         archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                           ""Truncated RAR file data"");
         return (ARCHIVE_FATAL);
       }
       __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context);
       rar->bytein.a = a;
       rar->bytein.Read = &ppmd_read;
       __archive_ppmd7_functions.PpmdRAR_RangeDec_CreateVTable(&rar->range_dec);
       rar->range_dec.Stream = &rar->bytein;
       __archive_ppmd7_functions.Ppmd7_Construct(&rar->ppmd7_context);
       if (rar->dictionary_size == 0) {
 	      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                           ""Invalid zero dictionary size"");
 	      return (ARCHIVE_FATAL);
       }
       if (!__archive_ppmd7_functions.Ppmd7_Alloc(&rar->ppmd7_context,
         rar->dictionary_size))
       {
         archive_set_error(&a->archive, ENOMEM,
                           ""Out of memory"");
         return (ARCHIVE_FATAL);
       }
       if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec))
       {
         archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                           ""Unable to initialize PPMd range decoder"");
         return (ARCHIVE_FATAL);
       }
       __archive_ppmd7_functions.Ppmd7_Init(&rar->ppmd7_context, maxorder);
       rar->ppmd_valid = 1;
     }
     else
     {
       if (!rar->ppmd_valid) {
         archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                           ""Invalid PPMd sequence"");
         return (ARCHIVE_FATAL);
       }
       if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec))
       {
         archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                           ""Unable to initialize PPMd range decoder"");
         return (ARCHIVE_FATAL);
       }
     }
   }
   else
   {
     rar_br_consume(br, 1);
     if (!rar_br_read_ahead(a, br, 1))
       goto truncated_data;
     if (!rar_br_bits(br, 1))
       memset(rar->lengthtable, 0, sizeof(rar->lengthtable));
     rar_br_consume(br, 1);
     memset(&bitlengths, 0, sizeof(bitlengths));
     for (i = 0; i < MAX_SYMBOLS;)
     {
       if (!rar_br_read_ahead(a, br, 4))
         goto truncated_data;
       bitlengths[i++] = rar_br_bits(br, 4);
       rar_br_consume(br, 4);
       if (bitlengths[i-1] == 0xF)
       {
         if (!rar_br_read_ahead(a, br, 4))
           goto truncated_data;
         zerocount = rar_br_bits(br, 4);
         rar_br_consume(br, 4);
         if (zerocount)
         {
           i--;
           for (j = 0; j < zerocount + 2 && i < MAX_SYMBOLS; j++)
             bitlengths[i++] = 0;
         }
       }
     }
     memset(&precode, 0, sizeof(precode));
     r = create_code(a, &precode, bitlengths, MAX_SYMBOLS, MAX_SYMBOL_LENGTH);
     if (r != ARCHIVE_OK) {
       free(precode.tree);
       free(precode.table);
       return (r);
     }
     for (i = 0; i < HUFFMAN_TABLE_SIZE;)
     {
       if ((val = read_next_symbol(a, &precode)) < 0) {
         free(precode.tree);
         free(precode.table);
         return (ARCHIVE_FATAL);
       }
       if (val < 16)
       {
         rar->lengthtable[i] = (rar->lengthtable[i] + val) & 0xF;
         i++;
       }
       else if (val < 18)
       {
         if (i == 0)
         {
           free(precode.tree);
           free(precode.table);
           archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                             ""Internal error extracting RAR file."");
           return (ARCHIVE_FATAL);
         }
         if(val == 16) {
           if (!rar_br_read_ahead(a, br, 3)) {
             free(precode.tree);
             free(precode.table);
             goto truncated_data;
           }
           n = rar_br_bits(br, 3) + 3;
           rar_br_consume(br, 3);
         } else {
           if (!rar_br_read_ahead(a, br, 7)) {
             free(precode.tree);
             free(precode.table);
             goto truncated_data;
           }
           n = rar_br_bits(br, 7) + 11;
           rar_br_consume(br, 7);
         }
         for (j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++)
         {
           rar->lengthtable[i] = rar->lengthtable[i-1];
           i++;
         }
       }
       else
       {
         if(val == 18) {
           if (!rar_br_read_ahead(a, br, 3)) {
             free(precode.tree);
             free(precode.table);
             goto truncated_data;
           }
           n = rar_br_bits(br, 3) + 3;
           rar_br_consume(br, 3);
         } else {
           if (!rar_br_read_ahead(a, br, 7)) {
             free(precode.tree);
             free(precode.table);
             goto truncated_data;
           }
           n = rar_br_bits(br, 7) + 11;
           rar_br_consume(br, 7);
         }
         for(j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++)
           rar->lengthtable[i++] = 0;
       }
     }
     free(precode.tree);
     free(precode.table);
     r = create_code(a, &rar->maincode, &rar->lengthtable[0], MAINCODE_SIZE,
                 MAX_SYMBOL_LENGTH);
     if (r != ARCHIVE_OK)
       return (r);
     r = create_code(a, &rar->offsetcode, &rar->lengthtable[MAINCODE_SIZE],
                 OFFSETCODE_SIZE, MAX_SYMBOL_LENGTH);
     if (r != ARCHIVE_OK)
       return (r);
     r = create_code(a, &rar->lowoffsetcode,
                 &rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE],
                 LOWOFFSETCODE_SIZE, MAX_SYMBOL_LENGTH);
     if (r != ARCHIVE_OK)
       return (r);
     r = create_code(a, &rar->lengthcode,
                 &rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE +
                 LOWOFFSETCODE_SIZE], LENGTHCODE_SIZE, MAX_SYMBOL_LENGTH);
     if (r != ARCHIVE_OK)
       return (r);
   }
   if (!rar->dictionary_size || !rar->lzss.window)
   {
     void *new_window;
     unsigned int new_size;
     if (rar->unp_size >= DICTIONARY_MAX_SIZE)
        new_size = DICTIONARY_MAX_SIZE;
      else
        new_size = rar_fls((unsigned int)rar->unp_size) << 1;
     if (new_size == 0) {
       archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                         ""Zero window size is invalid."");
       return (ARCHIVE_FATAL);
     }
      new_window = realloc(rar->lzss.window, new_size);
      if (new_window == NULL) {
        archive_set_error(&a->archive, ENOMEM,
                         ""Unable to allocate memory for uncompressed data."");
       return (ARCHIVE_FATAL);
     }
     rar->lzss.window = (unsigned char *)new_window;
     rar->dictionary_size = new_size;
     memset(rar->lzss.window, 0, rar->dictionary_size);
     rar->lzss.mask = rar->dictionary_size - 1;
   }
   rar->start_new_table = 0;
   return (ARCHIVE_OK);
 truncated_data:
   archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                     ""Truncated RAR file data"");
   rar->valid = 0;
   return (ARCHIVE_FATAL);
 }","[222, 223, 224, 225, 226]","libarchive version commit 416694915449219d505531b1096384f3237dd6cc onwards (release v3.1.0 onwards) contains a CWE-415: Double Free vulnerability in RAR decoder - libarchive/archive_read_support_format_rar.c, parse_codes(), realloc(rar->lzss.window, new_size) with new_size = 0 that can result in Crash/DoS. This attack appear to be exploitable via the victim must open a specially crafted RAR archive.",libarchive,CVE-2018-1000877,CWE-415
5555,182478," GF_Err gf_isom_oinf_read_entry(void *entry, GF_BitStream *bs)
 {
 	GF_OperatingPointsInformation* ptr = (GF_OperatingPointsInformation *)entry;
 	u32 i, j, count;
 	if (!ptr) return GF_BAD_PARAM;
 	ptr->scalability_mask = gf_bs_read_u16(bs);
 	gf_bs_read_int(bs, 2); 
 	count = gf_bs_read_int(bs, 6);
 	for (i = 0; i < count; i++) {
 		LHEVC_ProfileTierLevel *ptl;
 		GF_SAFEALLOC(ptl, LHEVC_ProfileTierLevel);
 		if (!ptl) return GF_OUT_OF_MEM;
 		ptl->general_profile_space = gf_bs_read_int(bs, 2);
 		ptl->general_tier_flag= gf_bs_read_int(bs, 1);
 		ptl->general_profile_idc = gf_bs_read_int(bs, 5);
 		ptl->general_profile_compatibility_flags = gf_bs_read_u32(bs);
 		ptl->general_constraint_indicator_flags = gf_bs_read_long_int(bs, 48);
 		ptl->general_level_idc = gf_bs_read_u8(bs);
 		gf_list_add(ptr->profile_tier_levels, ptl);
 	}
 	count = gf_bs_read_u16(bs);
 	for (i = 0; i < count; i++) {
 		LHEVC_OperatingPoint *op;
 		GF_SAFEALLOC(op, LHEVC_OperatingPoint);
 		if (!op) return GF_OUT_OF_MEM;
  		op->output_layer_set_idx = gf_bs_read_u16(bs);
  		op->max_temporal_id = gf_bs_read_u8(bs);
  		op->layer_count = gf_bs_read_u8(bs);
 		if (op->layer_count > ARRAY_LENGTH(op->layers_info))
 			return GF_NON_COMPLIANT_BITSTREAM;
  		for (j = 0; j < op->layer_count; j++) {
  			op->layers_info[j].ptl_idx = gf_bs_read_u8(bs);
  			op->layers_info[j].layer_id = gf_bs_read_int(bs, 6);
 			op->layers_info[j].is_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;
 			op->layers_info[j].is_alternate_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;
 		}
 		op->minPicWidth = gf_bs_read_u16(bs);
 		op->minPicHeight = gf_bs_read_u16(bs);
 		op->maxPicWidth = gf_bs_read_u16(bs);
 		op->maxPicHeight = gf_bs_read_u16(bs);
 		op->maxChromaFormat = gf_bs_read_int(bs, 2);
 		op->maxBitDepth = gf_bs_read_int(bs, 3) + 8;
 		gf_bs_read_int(bs, 1); 
 		op->frame_rate_info_flag = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;
 		op->bit_rate_info_flag = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;
 		if (op->frame_rate_info_flag) {
 			op->avgFrameRate = gf_bs_read_u16(bs);
 			gf_bs_read_int(bs, 6);  
 			op->constantFrameRate = gf_bs_read_int(bs, 2);
 		}
 		if (op->bit_rate_info_flag) {
 			op->maxBitRate = gf_bs_read_u32(bs);
 			op->avgBitRate = gf_bs_read_u32(bs);
 		}
 		gf_list_add(ptr->operating_points, op);
 	}
 	count = gf_bs_read_u8(bs);
 	for (i = 0; i < count; i++) {
 		LHEVC_DependentLayer *dep;
 		GF_SAFEALLOC(dep, LHEVC_DependentLayer);
 		if (!dep) return GF_OUT_OF_MEM;
 		dep->dependent_layerID = gf_bs_read_u8(bs);
 		dep->num_layers_dependent_on = gf_bs_read_u8(bs);
 		for (j = 0; j < dep->num_layers_dependent_on; j++)
 			dep->dependent_on_layerID[j] = gf_bs_read_u8(bs);
 		for (j = 0; j < 16; j++) {
 			if (ptr->scalability_mask & (1 << j))
 				dep->dimension_identifier[j] = gf_bs_read_u8(bs);
 		}
 		gf_list_add(ptr->dependency_layers, dep);
 	}
 	return GF_OK;
 }","[29, 30]","GPAC through 0.7.1 has a Buffer Overflow in the gf_media_avc_read_sps function in media_tools/av_parsers.c, a different vulnerability than CVE-2018-1000100.",gpac,CVE-2018-7752,CWE-119
5583,182684," static void WritePixels(struct ngiflib_img * i, struct ngiflib_decode_context * context, const u8 * pixels, u16 n) {
 	u16 tocopy;	
 	struct ngiflib_gif * p = i->parent;
 	while(n > 0) {
 		tocopy = (context->Xtogo < n) ? context->Xtogo : n;
 		if(!i->gce.transparent_flag) {
 #ifndef NGIFLIB_INDEXED_ONLY
 			if(p->mode & NGIFLIB_MODE_INDEXED) {
 #endif  
 				ngiflib_memcpy(context->frbuff_p.p8, pixels, tocopy);
 				pixels += tocopy;
 				context->frbuff_p.p8 += tocopy;
 #ifndef NGIFLIB_INDEXED_ONLY
 			} else {
 				int j;
 				for(j = (int)tocopy; j > 0; j--) {
 					*(context->frbuff_p.p32++) =
 					   GifIndexToTrueColor(i->palette, *pixels++);
 				}
 			}
 #endif  
 		} else {
 			int j;
 #ifndef NGIFLIB_INDEXED_ONLY
 			if(p->mode & NGIFLIB_MODE_INDEXED) {
 #endif  
 				for(j = (int)tocopy; j > 0; j--) {
 					if(*pixels != i->gce.transparent_color) *context->frbuff_p.p8 = *pixels;
 					pixels++;
 					context->frbuff_p.p8++;
 				}
 #ifndef NGIFLIB_INDEXED_ONLY
 			} else {
 				for(j = (int)tocopy; j > 0; j--) {
 					if(*pixels != i->gce.transparent_color) {
 						*context->frbuff_p.p32 = GifIndexToTrueColor(i->palette, *pixels);
 					}
 					pixels++;
 					context->frbuff_p.p32++;
 				}
 			}
 #endif  
 		}
 		context->Xtogo -= tocopy;
 		if(context->Xtogo == 0) {
 			#ifdef NGIFLIB_ENABLE_CALLBACKS
 			if(p->line_cb) p->line_cb(p, context->line_p, context->curY);
 			#endif  
 			context->Xtogo = i->width;
 			switch(context->pass) {
 			case 0:
 				context->curY++;
  				break;
  			case 1:	 
  				context->curY += 8;
				if(context->curY >= p->height) {
					context->pass++;
					context->curY = i->posY + 4;
				}
  				break;
  			case 2:	 
  				context->curY += 8;
				if(context->curY >= p->height) {
					context->pass++;
					context->curY = i->posY + 2;
				}
  				break;
  			case 3:	 
  				context->curY += 4;
				if(context->curY >= p->height) {
					context->pass++;
					context->curY = i->posY + 1;
				}
  				break;
  			case 4:	 
  				context->curY += 2;
  				break;
  			}
 			while(context->pass > 0 && context->pass < 4 &&
 			      context->curY >= p->height) {
 				switch(++context->pass) {
 				case 2:	 
 					context->curY = i->posY + 4;
 					break;
 				case 3:	 
 					context->curY = i->posY + 2;
 					break;
 				case 4:	 
 					context->curY = i->posY + 1;
 					break;
 				}
 			}
  #ifndef NGIFLIB_INDEXED_ONLY
  			if(p->mode & NGIFLIB_MODE_INDEXED) {
  #endif  
 				#ifdef NGIFLIB_ENABLE_CALLBACKS
 				context->line_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width;
 				context->frbuff_p.p8 = context->line_p.p8 + i->posX;
 				#else
 				context->frbuff_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width + i->posX;
 				#endif  
 #ifndef NGIFLIB_INDEXED_ONLY
 			} else {
 				#ifdef NGIFLIB_ENABLE_CALLBACKS
 				context->line_p.p32 = p->frbuff.p32 + (u32)context->curY*p->width;
 				context->frbuff_p.p32 = context->line_p.p32 + i->posX;
 				#else
 				context->frbuff_p.p32 = p->frbuff.p32 + (u32)context->curY*p->width + i->posX;
 				#endif  
 			}
 #endif  
 		}
 		n -= tocopy;
 	}
 }","[56, 57, 58, 59, 63, 64, 65, 66, 70, 71, 72, 73, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92]","ngiflib 0.4 has a heap-based buffer overflow in WritePixels() in ngiflib.c when called from DecodeGifImg, because deinterlacing for small pictures is mishandled.",ngiflib,CVE-2019-16347,CWE-119
5613,182619," void jpc_qmfb_split_colres(jpc_fix_t *a, int numrows, int numcols,
   int stride, int parity)
 {
 	int bufsize = JPC_CEILDIVPOW2(numrows, 1);
 	jpc_fix_t splitbuf[QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE];
 	jpc_fix_t *buf = splitbuf;
 	jpc_fix_t *srcptr;
 	jpc_fix_t *dstptr;
 	register jpc_fix_t *srcptr2;
 	register jpc_fix_t *dstptr2;
 	register int n;
 	register int i;
 	int m;
 	int hstartcol;
  	if (bufsize > QMFB_SPLITBUFSIZE) {
		if (!(buf = jas_alloc2(bufsize, sizeof(jpc_fix_t)))) {
 		if (!(buf = jas_alloc3(bufsize, numcols, sizeof(jpc_fix_t)))) {
  			abort();
  		}
 	}
 	if (numrows >= 2) {
 		hstartcol = (numrows + 1 - parity) >> 1;
 		m = numrows - hstartcol;
 		n = m;
 		dstptr = buf;
 		srcptr = &a[(1 - parity) * stride];
 		while (n-- > 0) {
 			dstptr2 = dstptr;
 			srcptr2 = srcptr;
 			for (i = 0; i < numcols; ++i) {
 				*dstptr2 = *srcptr2;
 				++dstptr2;
 				++srcptr2;
 			}
 			dstptr += numcols;
 			srcptr += stride << 1;
 		}
 		dstptr = &a[(1 - parity) * stride];
 		srcptr = &a[(2 - parity) * stride];
 		n = numrows - m - (!parity);
 		while (n-- > 0) {
 			dstptr2 = dstptr;
 			srcptr2 = srcptr;
 			for (i = 0; i < numcols; ++i) {
 				*dstptr2 = *srcptr2;
 				++dstptr2;
 				++srcptr2;
 			}
 			dstptr += stride;
 			srcptr += stride << 1;
 		}
 		dstptr = &a[hstartcol * stride];
 		srcptr = buf;
 		n = m;
 		while (n-- > 0) {
 			dstptr2 = dstptr;
 			srcptr2 = srcptr;
 			for (i = 0; i < numcols; ++i) {
 				*dstptr2 = *srcptr2;
 				++dstptr2;
 				++srcptr2;
 			}
 			dstptr += stride;
 			srcptr += numcols;
 		}
 	}
 	if (buf != splitbuf) {
 		jas_free(buf);
 	}
 }","[16, 17]",A heap-buffer overflow vulnerability was found in QMFB code in JPC codec caused by buffer being allocated with too small size. jasper versions before 2.0.0 are affected.,jasper,CVE-2016-8654,CWE-119
5627,182868," static void Rp_test(js_State *J)
  {
  	js_Regexp *re;
  	const char *text;
 	int result;
  	int opts;
  	Resub m;
 	re = js_toregexp(J, 0);
 	text = js_tostring(J, 1);
 	opts = 0;
 	if (re->flags & JS_REGEXP_G) {
 		if (re->last > strlen(text)) {
 			re->last = 0;
 			js_pushboolean(J, 0);
 			return;
 		}
 		if (re->last > 0) {
 			text += re->last;
 			opts |= REG_NOTBOL;
  		}
  	}
	if (!js_regexec(re->prog, text, &m, opts)) {
 	result = js_regexec(re->prog, text, &m, opts);
 	if (result < 0)
 		js_error(J, ""regexec failed"");
 	if (result == 0) {
  		if (re->flags & JS_REGEXP_G)
  			re->last = re->last + (m.sub[0].ep - text);
  		js_pushboolean(J, 1);
 		return;
 	}
 	if (re->flags & JS_REGEXP_G)
 		re->last = 0;
 	js_pushboolean(J, 0);
 }","[5, 22, 23, 24, 25, 26]",An issue was discovered in Artifex MuJS 1.0.5. It has unlimited recursion because the match function in regexp.c lacks a depth check.,mujs,CVE-2019-11413,CWE-400
5637,182707," void faad_resetbits(bitfile *ld, int bits)
 {
     uint32_t tmp;
      int words = bits >> 5;
      int remainder = bits & 0x1F;
    ld->bytes_left = ld->buffer_size - words*4;
     if (ld->buffer_size < words * 4)
         ld->bytes_left = 0;
     else
         ld->bytes_left = ld->buffer_size - words*4;
      if (ld->bytes_left >= 4)
      {
         tmp = getdword(&ld->start[words]);
         ld->bytes_left -= 4;
     } else {
         tmp = getdword_n(&ld->start[words], ld->bytes_left);
         ld->bytes_left = 0;
     }
     ld->bufa = tmp;
     if (ld->bytes_left >= 4)
     {
         tmp = getdword(&ld->start[words+1]);
         ld->bytes_left -= 4;
     } else {
         tmp = getdword_n(&ld->start[words+1], ld->bytes_left);
         ld->bytes_left = 0;
     }
     ld->bufb = tmp;
     ld->bits_left = 32 - remainder;
     ld->tail = &ld->start[words+2];
     ld->error = 0;
 }","[6, 7, 8, 9, 10]","An issue was discovered in Freeware Advanced Audio Decoder 2 (FAAD2) 2.8.8. The faad_resetbits function in libfaad/bits.c is affected by a buffer overflow vulnerability. The number of bits to be read is determined by ld->buffer_size - words*4, cast to uint32. If ld->buffer_size - words*4 is negative, a buffer overflow is later performed via getdword_n(&ld->start[words], ld->bytes_left).",faad2,CVE-2019-15296,CWE-119
5643,181210," static int ape_decode_frame(AVCodecContext *avctx, void *data,
                             int *got_frame_ptr, AVPacket *avpkt)
 {
     AVFrame *frame     = data;
     const uint8_t *buf = avpkt->data;
     APEContext *s = avctx->priv_data;
     uint8_t *sample8;
     int16_t *sample16;
      int32_t *sample24;
      int i, ch, ret;
      int blockstodecode;
     uint64_t decoded_buffer_size;
     av_assert0(s->samples >= 0);
     if(!s->samples){
         uint32_t nblocks, offset;
         int buf_size;
         if (!avpkt->size) {
             *got_frame_ptr = 0;
             return 0;
         }
         if (avpkt->size < 8) {
             av_log(avctx, AV_LOG_ERROR, ""Packet is too small\n"");
             return AVERROR_INVALIDDATA;
         }
         buf_size = avpkt->size & ~3;
         if (buf_size != avpkt->size) {
             av_log(avctx, AV_LOG_WARNING, ""packet size is not a multiple of 4. ""
                    ""extra bytes at the end will be skipped.\n"");
         }
         if (s->fileversion < 3950)  
             buf_size += 2;
         av_fast_padded_malloc(&s->data, &s->data_size, buf_size);
         if (!s->data)
             return AVERROR(ENOMEM);
         s->bdsp.bswap_buf((uint32_t *) s->data, (const uint32_t *) buf,
                           buf_size >> 2);
         memset(s->data + (buf_size & ~3), 0, buf_size & 3);
         s->ptr = s->data;
         s->data_end = s->data + buf_size;
         nblocks = bytestream_get_be32(&s->ptr);
         offset  = bytestream_get_be32(&s->ptr);
         if (s->fileversion >= 3900) {
             if (offset > 3) {
                 av_log(avctx, AV_LOG_ERROR, ""Incorrect offset passed\n"");
                 s->data = NULL;
                 return AVERROR_INVALIDDATA;
             }
             if (s->data_end - s->ptr < offset) {
                 av_log(avctx, AV_LOG_ERROR, ""Packet is too small\n"");
                 return AVERROR_INVALIDDATA;
             }
             s->ptr += offset;
         } else {
             if ((ret = init_get_bits8(&s->gb, s->ptr, s->data_end - s->ptr)) < 0)
                 return ret;
             if (s->fileversion > 3800)
                 skip_bits_long(&s->gb, offset * 8);
             else
                  skip_bits_long(&s->gb, offset);
          }
        if (!nblocks || nblocks > INT_MAX) {
         if (!nblocks || nblocks > INT_MAX / 2 / sizeof(*s->decoded_buffer) - 8) {
              av_log(avctx, AV_LOG_ERROR, ""Invalid sample count: %""PRIu32"".\n"",
                     nblocks);
              return AVERROR_INVALIDDATA;
         }
         if (init_frame_decoder(s) < 0) {
             av_log(avctx, AV_LOG_ERROR, ""Error reading frame header\n"");
             return AVERROR_INVALIDDATA;
         }
         s->samples = nblocks;
     }
     if (!s->data) {
         *got_frame_ptr = 0;
         return avpkt->size;
     }
     blockstodecode = FFMIN(s->blocks_per_loop, s->samples);
     if (s->fileversion < 3930)
          blockstodecode = s->samples;
    av_fast_malloc(&s->decoded_buffer, &s->decoded_size,
                   2 * FFALIGN(blockstodecode, 8) * sizeof(*s->decoded_buffer));
     decoded_buffer_size = 2LL * FFALIGN(blockstodecode, 8) * sizeof(*s->decoded_buffer);
     av_assert0(decoded_buffer_size <= INT_MAX);
     av_fast_malloc(&s->decoded_buffer, &s->decoded_size, decoded_buffer_size);
      if (!s->decoded_buffer)
          return AVERROR(ENOMEM);
      memset(s->decoded_buffer, 0, s->decoded_size);
     s->decoded[0] = s->decoded_buffer;
     s->decoded[1] = s->decoded_buffer + FFALIGN(blockstodecode, 8);
     frame->nb_samples = blockstodecode;
     if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)
         return ret;
     s->error=0;
     if ((s->channels == 1) || (s->frameflags & APE_FRAMECODE_PSEUDO_STEREO))
         ape_unpack_mono(s, blockstodecode);
     else
         ape_unpack_stereo(s, blockstodecode);
     emms_c();
     if (s->error) {
         s->samples=0;
         av_log(avctx, AV_LOG_ERROR, ""Error decoding frame\n"");
         return AVERROR_INVALIDDATA;
     }
     switch (s->bps) {
     case 8:
         for (ch = 0; ch < s->channels; ch++) {
             sample8 = (uint8_t *)frame->data[ch];
             for (i = 0; i < blockstodecode; i++)
                 *sample8++ = (s->decoded[ch][i] + 0x80) & 0xff;
         }
         break;
     case 16:
         for (ch = 0; ch < s->channels; ch++) {
             sample16 = (int16_t *)frame->data[ch];
             for (i = 0; i < blockstodecode; i++)
                 *sample16++ = s->decoded[ch][i];
         }
         break;
     case 24:
         for (ch = 0; ch < s->channels; ch++) {
             sample24 = (int32_t *)frame->data[ch];
             for (i = 0; i < blockstodecode; i++)
                 *sample24++ = s->decoded[ch][i] << 8;
         }
         break;
     }
     s->samples -= blockstodecode;
     *got_frame_ptr = 1;
     return !s->samples ? avpkt->size : 0;
 }","[12, 61, 62, 80, 81, 82, 83, 84]",Integer overflow in the ape_decode_frame function in libavcodec/apedec.c in FFmpeg through 3.3.2 allows remote attackers to cause a denial of service (out-of-array access and application crash) or possibly have unspecified other impact via a crafted APE file.,FFmpeg,CVE-2017-11399,CWE-125
5716,179036," g_NPN_GetValue(NPP instance, NPNVariable variable, void *value)
 {
   D(bug(""NPN_GetValue instance=%p, variable=%d [%s]\n"", instance, variable, string_of_NPNVariable(variable)));
   if (!thread_check()) {
 	npw_printf(""WARNING: NPN_GetValue not called from the main thread\n"");
 	return NPERR_INVALID_INSTANCE_ERROR;
   }
   PluginInstance *plugin = NULL;
   if (instance)
 	plugin = PLUGIN_INSTANCE(instance);
   switch (variable) {
   case NPNVxDisplay:
 	*(void **)value = x_display;
 	break;
   case NPNVxtAppContext:
 	*(void **)value = XtDisplayToApplicationContext(x_display);
 	break;
   case NPNVToolkit:
 	*(NPNToolkitType *)value = NPW_TOOLKIT;
 	break;
 #if USE_XPCOM
   case NPNVserviceManager: {
 	nsIServiceManager *sm;
 	int ret = NS_GetServiceManager(&sm);
 	if (NS_FAILED(ret)) {
 	  npw_printf(""WARNING: NS_GetServiceManager failed\n"");
 	  return NPERR_GENERIC_ERROR;
 	}
 	*(nsIServiceManager **)value = sm;
 	break;
   }
   case NPNVDOMWindow:
   case NPNVDOMElement:
 	npw_printf(""WARNING: %s is not supported by NPN_GetValue()\n"", string_of_NPNVariable(variable));
 	return NPERR_INVALID_PARAM;
 #endif
   case NPNVnetscapeWindow:
 	if (plugin == NULL) {
 	  npw_printf(""ERROR: NPNVnetscapeWindow requires a non NULL instance\n"");
 	  return NPERR_INVALID_INSTANCE_ERROR;
 	}
 	if (plugin->browser_toplevel == NULL) {
 	  GdkNativeWindow netscape_xid = None;
 	  NPError error = g_NPN_GetValue_real(instance, variable, &netscape_xid);
 	  if (error != NPERR_NO_ERROR)
 		return error;
 	  if (netscape_xid == None)
 		return NPERR_GENERIC_ERROR;
 	  plugin->browser_toplevel = gdk_window_foreign_new(netscape_xid);
 	  if (plugin->browser_toplevel == NULL)
 		return NPERR_GENERIC_ERROR;
 	}
 	*((GdkNativeWindow *)value) = GDK_WINDOW_XWINDOW(plugin->browser_toplevel);
 	break;
 #if ALLOW_WINDOWLESS_PLUGINS
   case NPNVSupportsWindowless:
 #endif
    case NPNVSupportsXEmbedBool:
    case NPNVWindowNPObject:
    case NPNVPluginElementNPObject:
   case NPNVprivateModeBool:
   case NPNVsupportsAdvancedKeyHandling:
  	return g_NPN_GetValue_real(instance, variable, value);
    default:
  	switch (variable & 0xff) {
 	case 13:  
 	  if (NPW_TOOLKIT == NPNVGtk2) {
 		*(NPNToolkitType *)value = NPW_TOOLKIT;
 		return NPERR_NO_ERROR;
 	  }
 	  break;
 	}
 	D(bug(""WARNING: unhandled variable %d (%s) in NPN_GetValue()\n"", variable, string_of_NPNVariable(variable)));
 	return NPERR_INVALID_PARAM;
   }
   return NPERR_NO_ERROR;
 }","[61, 62]","nspluginwrapper before 1.4.4 does not properly provide access to NPNVprivateModeBool variable settings, which could prevent Firefox plugins from determining if they should run in Private Browsing mode and allow remote attackers to bypass intended access restrictions, as demonstrated using Flash.",nspluginwrapper,CVE-2011-2486,CWE-264
5723,180309," create_filesystem_object(struct archive_write_disk *a)
 {
  	const char *linkname;
  	mode_t final_mode, mode;
  	int r;
 	char *linkname_copy;	 
 	struct archive_string error_string;
 	int error_number;
 	linkname = archive_entry_hardlink(a->entry);
 	if (linkname != NULL) {
  #if !HAVE_LINK
  		return (EPERM);
  #else
 		archive_string_init(&error_string);
 		linkname_copy = strdup(linkname);
 		if (linkname_copy == NULL) {
 		    return (EPERM);
 		}
 		r = cleanup_pathname_fsobj(linkname_copy, &error_number, &error_string, a->flags);
 		if (r != ARCHIVE_OK) {
 			archive_set_error(&a->archive, error_number, ""%s"", error_string.s);
 			free(linkname_copy);
 			return (EPERM);
 		}
 		r = check_symlinks_fsobj(linkname_copy, &error_number, &error_string, a->flags);
 		if (r != ARCHIVE_OK) {
 			archive_set_error(&a->archive, error_number, ""%s"", error_string.s);
 			free(linkname_copy);
 			return (EPERM);
 		}
 		free(linkname_copy);
  		r = link(linkname, a->name) ? errno : 0;
 		if (r == 0 && a->filesize <= 0) {
 			a->todo = 0;
 			a->deferred = 0;
 		} else if (r == 0 && a->filesize > 0) {
 			a->fd = open(a->name,
 				     O_WRONLY | O_TRUNC | O_BINARY | O_CLOEXEC);
 			__archive_ensure_cloexec_flag(a->fd);
 			if (a->fd < 0)
 				r = errno;
 		}
 		return (r);
 #endif
 	}
 	linkname = archive_entry_symlink(a->entry);
 	if (linkname != NULL) {
 #if HAVE_SYMLINK
 		return symlink(linkname, a->name) ? errno : 0;
 #else
 		return (EPERM);
 #endif
 	}
 	final_mode = a->mode & 07777;
 	mode = final_mode & 0777 & ~a->user_umask;
 	switch (a->mode & AE_IFMT) {
 	default:
 	case AE_IFREG:
 		a->fd = open(a->name,
 		    O_WRONLY | O_CREAT | O_EXCL | O_BINARY | O_CLOEXEC, mode);
 		__archive_ensure_cloexec_flag(a->fd);
 		r = (a->fd < 0);
 		break;
 	case AE_IFCHR:
 #ifdef HAVE_MKNOD
 		r = mknod(a->name, mode | S_IFCHR,
 		    archive_entry_rdev(a->entry));
 		break;
 #else
 		return (EINVAL);
 #endif  
 	case AE_IFBLK:
 #ifdef HAVE_MKNOD
 		r = mknod(a->name, mode | S_IFBLK,
 		    archive_entry_rdev(a->entry));
 		break;
 #else
 		return (EINVAL);
 #endif  
 	case AE_IFDIR:
 		mode = (mode | MINIMUM_DIR_MODE) & MAXIMUM_DIR_MODE;
 		r = mkdir(a->name, mode);
 		if (r == 0) {
 			a->deferred |= (a->todo & TODO_TIMES);
 			a->todo &= ~TODO_TIMES;
 			if ((mode != final_mode)
 			    || (a->flags & ARCHIVE_EXTRACT_PERM))
 				a->deferred |= (a->todo & TODO_MODE);
 			a->todo &= ~TODO_MODE;
 		}
 		break;
 	case AE_IFIFO:
 #ifdef HAVE_MKFIFO
 		r = mkfifo(a->name, mode);
 		break;
 #else
 		return (EINVAL);
 #endif  
 	}
 	if (r)
 		return (errno);
 	if (mode == final_mode)
 		a->todo &= ~TODO_MODE;
 	return (0);
 }","[6, 7, 8, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]","The sandboxing code in libarchive 3.2.0 and earlier mishandles hardlink archive entries of non-zero data size, which might allow remote attackers to write to arbitrary files via a crafted archive file.",libarchive,CVE-2016-5418,CWE-20
5734,179811,"  static char *get_pid_environ_val(pid_t pid,char *val){
  char temp[500];
   int temp_size = 500;
   char *temp = malloc(temp_size);
    int i=0;
    int foundit=0;
    FILE *fp;
   sprintf(temp,""/proc/%d/environ"",pid);
   fp=fopen(temp,""r"");
   if(fp==NULL)
     return NULL;
    for(;;){
     if (i >= temp_size) {
       temp_size *= 2;
       temp = realloc(temp, temp_size);
     }
      temp[i]=fgetc(fp);    
      if(foundit==1 && (temp[i]==0 || temp[i]=='\0' || temp[i]==EOF)){
       char *ret;
       temp[i]=0;
       ret=malloc(strlen(temp)+10);
       sprintf(ret,""%s"",temp);
       fclose(fp);
       return ret;
     }
     switch(temp[i]){
     case EOF:
       fclose(fp);
       return NULL;
     case '=':
       temp[i]=0;
       if(!strcmp(temp,val)){
 	foundit=1;
       }
       i=0;
       break;
     case '\0':
       i=0;
       break;
     default:
       i++;
     }
   }
 }","[2, 3, 4, 13, 14, 15, 16]",Buffer overflow in das_watchdog 0.9.0 allows local users to execute arbitrary code with root privileges via a large string in the XAUTHORITY environment variable.,das_watchdog,CVE-2015-2831,CWE-119
5753,182227," epass2003_sm_unwrap_apdu(struct sc_card *card, struct sc_apdu *sm, struct sc_apdu *plain)
 {
 	int r;
 	size_t len = 0;
 	epass2003_exdata *exdata = NULL;
 	if (!card->drv_data) 
 		return SC_ERROR_INVALID_ARGUMENTS;
 	exdata = (epass2003_exdata *)card->drv_data;
 	LOG_FUNC_CALLED(card->ctx);
  	r = sc_check_sw(card, sm->sw1, sm->sw2);
  	if (r == SC_SUCCESS) {
  		if (exdata->sm) {
			if (0 != decrypt_response(card, sm->resp, plain->resp, &len))
 			if (0 != decrypt_response(card, sm->resp, sm->resplen, plain->resp, &len))
  				return SC_ERROR_CARD_CMD_FAILED;
  		}
  		else {
 			memcpy(plain->resp, sm->resp, sm->resplen);
 			len = sm->resplen;
 		}
 	}
 	plain->resplen = len;
 	plain->sw1 = sm->sw1;
 	plain->sw2 = sm->sw2;
 	sc_log(card->ctx,
 	       ""unwrapped APDU: resplen %""SC_FORMAT_LEN_SIZE_T""u, SW %02X%02X"",
 	       plain->resplen, plain->sw1, plain->sw2);
 	LOG_FUNC_RETURN(card->ctx, SC_SUCCESS);
 }","[13, 14]",Various out of bounds reads when handling responses in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to potentially crash the opensc library using programs.,OpenSC,CVE-2018-16427,CWE-125
5769,180403," static void dump_boot(DOS_FS * fs, struct boot_sector *b, unsigned lss)
 {
     unsigned short sectors;
     printf(""Boot sector contents:\n"");
     if (!atari_format) {
 	char id[9];
 	strncpy(id, (const char *)b->system_id, 8);
 	id[8] = 0;
 	printf(""System ID \""%s\""\n"", id);
     } else {
 	printf(""Serial number 0x%x\n"",
 	       b->system_id[5] | (b->system_id[6] << 8) | (b->
 							   system_id[7] << 16));
     }
     printf(""Media byte 0x%02x (%s)\n"", b->media, get_media_descr(b->media));
     printf(""%10d bytes per logical sector\n"", GET_UNALIGNED_W(b->sector_size));
     printf(""%10d bytes per cluster\n"", fs->cluster_size);
     printf(""%10d reserved sector%s\n"", le16toh(b->reserved),
 	   le16toh(b->reserved) == 1 ? """" : ""s"");
     printf(""First FAT starts at byte %llu (sector %llu)\n"",
  	   (unsigned long long)fs->fat_start,
  	   (unsigned long long)fs->fat_start / lss);
      printf(""%10d FATs, %d bit entries\n"", b->fats, fs->fat_bits);
    printf(""%10d bytes per FAT (= %u sectors)\n"", fs->fat_size,
	   fs->fat_size / lss);
     printf(""%10lld bytes per FAT (= %llu sectors)\n"", (long long)fs->fat_size,
 	   (long long)fs->fat_size / lss);
      if (!fs->root_cluster) {
  	printf(""Root directory starts at byte %llu (sector %llu)\n"",
  	       (unsigned long long)fs->root_start,
 	       (unsigned long long)fs->root_start / lss);
 	printf(""%10d root directory entries\n"", fs->root_entries);
     } else {
 	printf(""Root directory start at cluster %lu (arbitrary size)\n"",
 	       (unsigned long)fs->root_cluster);
     }
     printf(""Data area starts at byte %llu (sector %llu)\n"",
 	   (unsigned long long)fs->data_start,
 	   (unsigned long long)fs->data_start / lss);
     printf(""%10lu data clusters (%llu bytes)\n"",
 	   (unsigned long)fs->data_clusters,
 	   (unsigned long long)fs->data_clusters * fs->cluster_size);
     printf(""%u sectors/track, %u heads\n"", le16toh(b->secs_track),
 	   le16toh(b->heads));
     printf(""%10u hidden sectors\n"", atari_format ?
 	   (((unsigned char *)&b->hidden)[0] |
 	    ((unsigned char *)&b->hidden)[1] << 8) : le32toh(b->hidden));
     sectors = GET_UNALIGNED_W(b->sectors);
     printf(""%10u sectors total\n"", sectors ? sectors : le32toh(b->total_sect));
 }","[24, 25, 26, 27]","The read_boot function in boot.c in dosfstools before 4.0 allows attackers to cause a denial of service (crash) via a crafted filesystem, which triggers a heap-based buffer overflow in the (1) read_fat function or an out-of-bounds heap read in (2) get_fat function.",dosfstools,CVE-2016-4804,CWE-119
5786,179100," static int read_header(FFV1Context *f)
 {
     uint8_t state[CONTEXT_SIZE];
     int i, j, context_count = -1;  
     RangeCoder *const c = &f->slice_context[0]->c;
      memset(state, 128, sizeof(state));
      if (f->version < 2) {
         int chroma_planes, chroma_h_shift, chroma_v_shift, transparency;
          unsigned v= get_symbol(c, state, 0);
          if (v >= 2) {
              av_log(f->avctx, AV_LOG_ERROR, ""invalid version %d in ver01 header\n"", v);
             return AVERROR_INVALIDDATA;
         }
         f->version = v;
         f->ac      = f->avctx->coder_type = get_symbol(c, state, 0);
         if (f->ac > 1) {
             for (i = 1; i < 256; i++)
                 f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];
         }
         f->colorspace = get_symbol(c, state, 0);  
          if (f->version > 0)
              f->avctx->bits_per_raw_sample = get_symbol(c, state, 0);
        f->chroma_planes  = get_rac(c, state);
        f->chroma_h_shift = get_symbol(c, state, 0);
        f->chroma_v_shift = get_symbol(c, state, 0);
        f->transparency   = get_rac(c, state);
         chroma_planes  = get_rac(c, state);
         chroma_h_shift = get_symbol(c, state, 0);
         chroma_v_shift = get_symbol(c, state, 0);
         transparency   = get_rac(c, state);
         if (f->plane_count) {
             if (   chroma_planes != f->chroma_planes
                 || chroma_h_shift!= f->chroma_h_shift
                 || chroma_v_shift!= f->chroma_v_shift
                 || transparency  != f->transparency) {
                 av_log(f->avctx, AV_LOG_ERROR, ""Invalid change of global parameters\n"");
                 return AVERROR_INVALIDDATA;
             }
         }
         f->chroma_planes  = chroma_planes;
         f->chroma_h_shift = chroma_h_shift;
         f->chroma_v_shift = chroma_v_shift;
         f->transparency   = transparency;
          f->plane_count    = 2 + f->transparency;
      }
     if (f->colorspace == 0) {
         if (!f->transparency && !f->chroma_planes) {
             if (f->avctx->bits_per_raw_sample <= 8)
                 f->avctx->pix_fmt = AV_PIX_FMT_GRAY8;
             else
                 f->avctx->pix_fmt = AV_PIX_FMT_GRAY16;
         } else if (f->avctx->bits_per_raw_sample<=8 && !f->transparency) {
             switch(16 * f->chroma_h_shift + f->chroma_v_shift) {
             case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P; break;
             case 0x01: f->avctx->pix_fmt = AV_PIX_FMT_YUV440P; break;
             case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P; break;
             case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P; break;
             case 0x20: f->avctx->pix_fmt = AV_PIX_FMT_YUV411P; break;
             case 0x22: f->avctx->pix_fmt = AV_PIX_FMT_YUV410P; break;
             default:
                 av_log(f->avctx, AV_LOG_ERROR, ""format not supported\n"");
                 return AVERROR(ENOSYS);
             }
         } else if (f->avctx->bits_per_raw_sample <= 8 && f->transparency) {
             switch(16*f->chroma_h_shift + f->chroma_v_shift) {
             case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P; break;
             case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P; break;
             case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P; break;
             default:
                 av_log(f->avctx, AV_LOG_ERROR, ""format not supported\n"");
                 return AVERROR(ENOSYS);
             }
         } else if (f->avctx->bits_per_raw_sample == 9) {
             f->packed_at_lsb = 1;
             switch(16 * f->chroma_h_shift + f->chroma_v_shift) {
             case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P9; break;
             case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P9; break;
             case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P9; break;
             default:
                 av_log(f->avctx, AV_LOG_ERROR, ""format not supported\n"");
                 return AVERROR(ENOSYS);
             }
         } else if (f->avctx->bits_per_raw_sample == 10) {
             f->packed_at_lsb = 1;
             switch(16 * f->chroma_h_shift + f->chroma_v_shift) {
             case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P10; break;
             case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P10; break;
             case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P10; break;
             default:
                 av_log(f->avctx, AV_LOG_ERROR, ""format not supported\n"");
                 return AVERROR(ENOSYS);
             }
         } else {
             switch(16 * f->chroma_h_shift + f->chroma_v_shift) {
             case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P16; break;
             case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P16; break;
             case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P16; break;
             default:
                 av_log(f->avctx, AV_LOG_ERROR, ""format not supported\n"");
                 return AVERROR(ENOSYS);
             }
         }
     } else if (f->colorspace == 1) {
         if (f->chroma_h_shift || f->chroma_v_shift) {
             av_log(f->avctx, AV_LOG_ERROR,
                    ""chroma subsampling not supported in this colorspace\n"");
             return AVERROR(ENOSYS);
         }
         if (     f->avctx->bits_per_raw_sample ==  9)
             f->avctx->pix_fmt = AV_PIX_FMT_GBRP9;
         else if (f->avctx->bits_per_raw_sample == 10)
             f->avctx->pix_fmt = AV_PIX_FMT_GBRP10;
         else if (f->avctx->bits_per_raw_sample == 12)
             f->avctx->pix_fmt = AV_PIX_FMT_GBRP12;
         else if (f->avctx->bits_per_raw_sample == 14)
             f->avctx->pix_fmt = AV_PIX_FMT_GBRP14;
         else
         if (f->transparency) f->avctx->pix_fmt = AV_PIX_FMT_RGB32;
         else                 f->avctx->pix_fmt = AV_PIX_FMT_0RGB32;
     } else {
         av_log(f->avctx, AV_LOG_ERROR, ""colorspace not supported\n"");
         return AVERROR(ENOSYS);
     }
     av_dlog(f->avctx, ""%d %d %d\n"",
             f->chroma_h_shift, f->chroma_v_shift, f->avctx->pix_fmt);
     if (f->version < 2) {
         context_count = read_quant_tables(c, f->quant_table);
         if (context_count < 0) {
             av_log(f->avctx, AV_LOG_ERROR, ""read_quant_table error\n"");
             return AVERROR_INVALIDDATA;
         }
     } else if (f->version < 3) {
         f->slice_count = get_symbol(c, state, 0);
     } else {
         const uint8_t *p = c->bytestream_end;
         for (f->slice_count = 0;
              f->slice_count < MAX_SLICES && 3 < p - c->bytestream_start;
              f->slice_count++) {
             int trailer = 3 + 5*!!f->ec;
             int size = AV_RB24(p-trailer);
             if (size + trailer > p - c->bytestream_start)
                 break;
             p -= size + trailer;
         }
     }
     if (f->slice_count > (unsigned)MAX_SLICES || f->slice_count <= 0) {
         av_log(f->avctx, AV_LOG_ERROR, ""slice count %d is invalid\n"", f->slice_count);
         return AVERROR_INVALIDDATA;
     }
     for (j = 0; j < f->slice_count; j++) {
         FFV1Context *fs = f->slice_context[j];
         fs->ac            = f->ac;
         fs->packed_at_lsb = f->packed_at_lsb;
         fs->slice_damaged = 0;
         if (f->version == 2) {
             fs->slice_x      =  get_symbol(c, state, 0)      * f->width ;
             fs->slice_y      =  get_symbol(c, state, 0)      * f->height;
             fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width  + fs->slice_x;
             fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;
             fs->slice_x     /= f->num_h_slices;
             fs->slice_y     /= f->num_v_slices;
             fs->slice_width  = fs->slice_width  / f->num_h_slices - fs->slice_x;
             fs->slice_height = fs->slice_height / f->num_v_slices - fs->slice_y;
             if ((unsigned)fs->slice_width  > f->width ||
                 (unsigned)fs->slice_height > f->height)
                 return AVERROR_INVALIDDATA;
             if (   (unsigned)fs->slice_x + (uint64_t)fs->slice_width  > f->width
                 || (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height)
                 return AVERROR_INVALIDDATA;
         }
         for (i = 0; i < f->plane_count; i++) {
             PlaneContext *const p = &fs->plane[i];
             if (f->version == 2) {
                 int idx = get_symbol(c, state, 0);
                 if (idx > (unsigned)f->quant_table_count) {
                     av_log(f->avctx, AV_LOG_ERROR,
                            ""quant_table_index out of range\n"");
                     return AVERROR_INVALIDDATA;
                 }
                 p->quant_table_index = idx;
                 memcpy(p->quant_table, f->quant_tables[idx],
                        sizeof(p->quant_table));
                 context_count = f->context_count[idx];
             } else {
                 memcpy(p->quant_table, f->quant_table, sizeof(p->quant_table));
             }
             if (f->version <= 2) {
                 av_assert0(context_count >= 0);
                 if (p->context_count < context_count) {
                     av_freep(&p->state);
                     av_freep(&p->vlc_state);
                 }
                 p->context_count = context_count;
             }
         }
     }
     return 0;
 }","[8, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43]","The read_header function in libavcodec/ffv1dec.c in FFmpeg before 2.1 does not prevent changes to global parameters, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted FFV1 data.",FFmpeg,CVE-2013-7011,CWE-119
5787,178822,"  char *suhosin_encrypt_single_cookie(char *name, int name_len, char *value, int value_len, char *key TSRMLS_DC)
  {
	char buffer[4096];
    char buffer2[4096];
	char *buf = buffer, *buf2 = buffer2, *d, *d_url;
    int l;
	if (name_len > sizeof(buffer)-2) {
		buf = estrndup(name, name_len);
	} else {
		memcpy(buf, name, name_len);
		buf[name_len] = 0;
	}
 	char *buf, *buf2, *d, *d_url;
 	int l;
 	buf = estrndup(name, name_len);
  	name_len = php_url_decode(buf, name_len);
    normalize_varname(buf);
    name_len = strlen(buf);
 	normalize_varname(buf);
 	name_len = strlen(buf);
  	if (SUHOSIN_G(cookie_plainlist)) {
  		if (zend_hash_exists(SUHOSIN_G(cookie_plainlist), buf, name_len+1)) {
  encrypt_return_plain:
			if (buf != buffer) {
				efree(buf);
			}
 			efree(buf);
  			return estrndup(value, value_len);
  		}
  	} else if (SUHOSIN_G(cookie_cryptlist)) {
 		if (!zend_hash_exists(SUHOSIN_G(cookie_cryptlist), buf, name_len+1)) {
 			goto encrypt_return_plain;
  		}
  	}
	if (strlen(value) <= sizeof(buffer2)-2) {
		memcpy(buf2, value, value_len);
		buf2[value_len] = 0;
	} else {
		buf2 = estrndup(value, value_len);
	}
 	buf2 = estrndup(value, value_len);
  	value_len = php_url_decode(buf2, value_len);
  	d = suhosin_encrypt_string(buf2, value_len, buf, name_len, key TSRMLS_CC);
  	d_url = php_url_encode(d, strlen(d), &l);
  	efree(d);
    if (buf != buffer) {
		efree(buf);
	}
    if (buf2 != buffer2) {
		efree(buf2);
	}
 	efree(buf);
 	efree(buf2);
  	return d_url;
  }","[3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 17, 18, 19, 20, 24, 25, 26, 27, 35, 36, 37, 38, 39, 40, 41, 46, 47, 48, 49, 50, 51, 52, 53]","Stack-based buffer overflow in the suhosin_encrypt_single_cookie function in the transparent cookie-encryption feature in the Suhosin extension before 0.9.33 for PHP, when suhosin.cookie.encrypt and suhosin.multiheader are enabled, might allow remote attackers to execute arbitrary code via a long string that is used in a Set-Cookie HTTP header.",suhosin,CVE-2012-0807,CWE-119
5788,181933," int main(int argc, char **argv)
 {
 	int fmtid;
 	int id;
 	char *infile;
 	jas_stream_t *instream;
 	jas_image_t *image;
 	int width;
 	int height;
 	int depth;
  	int numcmpts;
  	int verbose;
  	char *fmtname;
 	int debug;
  	if (jas_init()) {
  		abort();
 	}
 	cmdname = argv[0];
  	infile = 0;
  	verbose = 0;
 	debug = 0;
  	while ((id = jas_getopt(argc, argv, opts)) >= 0) {
 		switch (id) {
 		case OPT_VERBOSE:
 			verbose = 1;
 			break;
 		case OPT_VERSION:
  			printf(""%s\n"", JAS_VERSION);
  			exit(EXIT_SUCCESS);
  			break;
 		case OPT_DEBUG:
 			debug = atoi(jas_optarg);
 			break;
  		case OPT_INFILE:
  			infile = jas_optarg;
  			break;
 		case OPT_HELP:
 		default:
 			usage();
 			break;
  		}
  	}
 	jas_setdbglevel(debug);
  	if (infile) {
 		if (!(instream = jas_stream_fopen(infile, ""rb""))) {
 			fprintf(stderr, ""cannot open input image file %s\n"", infile);
 			exit(EXIT_FAILURE);
 		}
 	} else {
 		if (!(instream = jas_stream_fdopen(0, ""rb""))) {
 			fprintf(stderr, ""cannot open standard input\n"");
 			exit(EXIT_FAILURE);
 		}
 	}
 	if ((fmtid = jas_image_getfmt(instream)) < 0) {
 		fprintf(stderr, ""unknown image format\n"");
 	}
  	if (!(image = jas_image_decode(instream, fmtid, 0))) {
 		jas_stream_close(instream);
  		fprintf(stderr, ""cannot load image\n"");
  		return EXIT_FAILURE;
  	}
 	jas_stream_close(instream);
 	numcmpts = jas_image_numcmpts(image);
 	width = jas_image_cmptwidth(image, 0);
 	height = jas_image_cmptheight(image, 0);
 	depth = jas_image_cmptprec(image, 0);
 	if (!(fmtname = jas_image_fmttostr(fmtid))) {
 		abort();
 	}
 	printf(""%s %d %d %d %d %ld\n"", fmtname, numcmpts, width, height, depth, (long) jas_image_rawsize(image));
 	jas_image_destroy(image);
 	jas_image_clearfmts();
 	return EXIT_SUCCESS;
 }","[14, 21, 31, 32, 33, 43, 59]",The bmp_getdata function in libjasper/bmp/bmp_dec.c in JasPer before 1.900.5 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted BMP image in an imginfo command.,jasper,CVE-2016-8690,CWE-476
5799,181676," static int process_line(URLContext *h, char *line, int line_count,
                         int *new_location)
 {
     HTTPContext *s = h->priv_data;
     const char *auto_method =  h->flags & AVIO_FLAG_READ ? ""POST"" : ""GET"";
     char *tag, *p, *end, *method, *resource, *version;
     int ret;
     if (line[0] == '\0') {
         s->end_header = 1;
         return 0;
     }
     p = line;
     if (line_count == 0) {
         if (s->is_connected_server) {
             method = p;
             while (*p && !av_isspace(*p))
                 p++;
             *(p++) = '\0';
             av_log(h, AV_LOG_TRACE, ""Received method: %s\n"", method);
             if (s->method) {
                 if (av_strcasecmp(s->method, method)) {
                     av_log(h, AV_LOG_ERROR, ""Received and expected HTTP method do not match. (%s expected, %s received)\n"",
                            s->method, method);
                     return ff_http_averror(400, AVERROR(EIO));
                 }
             } else {
                 av_log(h, AV_LOG_TRACE, ""Autodetected %s HTTP method\n"", auto_method);
                 if (av_strcasecmp(auto_method, method)) {
                     av_log(h, AV_LOG_ERROR, ""Received and autodetected HTTP method did not match ""
                            ""(%s autodetected %s received)\n"", auto_method, method);
                     return ff_http_averror(400, AVERROR(EIO));
                 }
                 if (!(s->method = av_strdup(method)))
                     return AVERROR(ENOMEM);
             }
             while (av_isspace(*p))
                 p++;
             resource = p;
             while (!av_isspace(*p))
                 p++;
             *(p++) = '\0';
             av_log(h, AV_LOG_TRACE, ""Requested resource: %s\n"", resource);
             if (!(s->resource = av_strdup(resource)))
                 return AVERROR(ENOMEM);
             while (av_isspace(*p))
                 p++;
             version = p;
             while (*p && !av_isspace(*p))
                 p++;
             *p = '\0';
             if (av_strncasecmp(version, ""HTTP/"", 5)) {
                 av_log(h, AV_LOG_ERROR, ""Malformed HTTP version string.\n"");
                 return ff_http_averror(400, AVERROR(EIO));
             }
             av_log(h, AV_LOG_TRACE, ""HTTP version string: %s\n"", version);
         } else {
             while (!av_isspace(*p) && *p != '\0')
                 p++;
             while (av_isspace(*p))
                 p++;
             s->http_code = strtol(p, &end, 10);
             av_log(h, AV_LOG_TRACE, ""http_code=%d\n"", s->http_code);
             if ((ret = check_http_code(h, s->http_code, end)) < 0)
                 return ret;
         }
     } else {
         while (*p != '\0' && *p != ':')
             p++;
         if (*p != ':')
             return 1;
         *p  = '\0';
         tag = line;
         p++;
         while (av_isspace(*p))
             p++;
         if (!av_strcasecmp(tag, ""Location"")) {
              if ((ret = parse_location(s, p)) < 0)
                  return ret;
              *new_location = 1;
        } else if (!av_strcasecmp(tag, ""Content-Length"") && s->filesize == -1) {
            s->filesize = strtoll(p, NULL, 10);
         } else if (!av_strcasecmp(tag, ""Content-Length"") &&
                    s->filesize == UINT64_MAX) {
             s->filesize = strtoull(p, NULL, 10);
          } else if (!av_strcasecmp(tag, ""Content-Range"")) {
              parse_content_range(h, p);
          } else if (!av_strcasecmp(tag, ""Accept-Ranges"") &&
                    !strncmp(p, ""bytes"", 5) &&
                    s->seekable == -1) {
              h->is_streamed = 0;
          } else if (!av_strcasecmp(tag, ""Transfer-Encoding"") &&
                     !av_strncasecmp(p, ""chunked"", 7)) {
            s->filesize  = -1;
             s->filesize  = UINT64_MAX;
              s->chunksize = 0;
          } else if (!av_strcasecmp(tag, ""WWW-Authenticate"")) {
              ff_http_auth_handle_header(&s->auth_state, tag, p);
         } else if (!av_strcasecmp(tag, ""Authentication-Info"")) {
             ff_http_auth_handle_header(&s->auth_state, tag, p);
         } else if (!av_strcasecmp(tag, ""Proxy-Authenticate"")) {
             ff_http_auth_handle_header(&s->proxy_auth_state, tag, p);
         } else if (!av_strcasecmp(tag, ""Connection"")) {
             if (!strcmp(p, ""close""))
                 s->willclose = 1;
         } else if (!av_strcasecmp(tag, ""Server"")) {
             if (!av_strcasecmp(p, ""AkamaiGHost"")) {
                 s->is_akamai = 1;
             } else if (!av_strncasecmp(p, ""MediaGateway"", 12)) {
                 s->is_mediagateway = 1;
             }
         } else if (!av_strcasecmp(tag, ""Content-Type"")) {
             av_free(s->mime_type);
             s->mime_type = av_strdup(p);
         } else if (!av_strcasecmp(tag, ""Set-Cookie"")) {
              if (parse_cookie(s, p, &s->cookie_dict))
                  av_log(h, AV_LOG_WARNING, ""Unable to parse '%s'\n"", p);
          } else if (!av_strcasecmp(tag, ""Icy-MetaInt"")) {
            s->icy_metaint = strtoll(p, NULL, 10);
             s->icy_metaint = strtoull(p, NULL, 10);
          } else if (!av_strncasecmp(tag, ""Icy-"", 4)) {
              if ((ret = parse_icy(s, tag, p)) < 0)
                  return ret;
         } else if (!av_strcasecmp(tag, ""Content-Encoding"")) {
             if ((ret = parse_content_encoding(h, p)) < 0)
                 return ret;
         }
     }
     return 1;
 }","[80, 81, 82, 83, 84, 93, 94, 118, 119]","Heap-based buffer overflow in libavformat/http.c in FFmpeg before 2.8.10, 3.0.x before 3.0.5, 3.1.x before 3.1.6, and 3.2.x before 3.2.2 allows remote web servers to execute arbitrary code via a negative chunk size in an HTTP response.",FFmpeg,CVE-2016-10190,CWE-119
5802,181986," CMD_FUNC(m_authenticate)
 {
 	aClient *agent_p = NULL;
 	if (!SASL_SERVER || !MyConnect(sptr) || BadPtr(parv[1]) || !CHECKPROTO(sptr, PROTO_SASL))
 		return 0;
 	if (sptr->local->sasl_complete)
 	{
 		sendto_one(sptr, err_str(ERR_SASLALREADY), me.name, BadPtr(sptr->name) ? ""*"" : sptr->name);
  		return 0;
  	}
 	if ((parv[1][0] == ':') || strchr(parv[1], ' '))
 	{
 		sendto_one(sptr, err_str(ERR_CANNOTDOCOMMAND), me.name, ""*"", ""AUTHENTICATE"", ""Invalid parameter"");
 		return 0;
 	}
  	if (strlen(parv[1]) > 400)
  	{
  		sendto_one(sptr, err_str(ERR_SASLTOOLONG), me.name, BadPtr(sptr->name) ? ""*"" : sptr->name);
 		return 0;
 	}
 	if (*sptr->local->sasl_agent)
 		agent_p = find_client(sptr->local->sasl_agent, NULL);
 	if (agent_p == NULL)
 	{
 		char *addr = BadPtr(sptr->ip) ? ""0"" : sptr->ip;
 		char *certfp = moddata_client_get(sptr, ""certfp"");
 		sendto_server(NULL, 0, 0, "":%s SASL %s %s H %s %s"",
 		    me.name, SASL_SERVER, encode_puid(sptr), addr, addr);
 		if (certfp)
 			sendto_server(NULL, 0, 0, "":%s SASL %s %s S %s %s"",
 			    me.name, SASL_SERVER, encode_puid(sptr), parv[1], certfp);
 		else
 			sendto_server(NULL, 0, 0, "":%s SASL %s %s S %s"",
 			    me.name, SASL_SERVER, encode_puid(sptr), parv[1]);
 	}
 	else
 		sendto_server(NULL, 0, 0, "":%s SASL %s %s C %s"",
 		    me.name, AGENT_SID(agent_p), encode_puid(sptr), parv[1]);
 	sptr->local->sasl_out++;
 	return 0;
 }","[11, 12, 13, 14, 15]",The m_authenticate function in modules/m_sasl.c in UnrealIRCd before 3.2.10.7 and 4.x before 4.0.6 allows remote attackers to spoof certificate fingerprints and consequently log in as another user via a crafted AUTHENTICATE parameter.,unrealircd,CVE-2016-7144,CWE-287
5810,178696," static int ape_read_header(AVFormatContext * s, AVFormatParameters * ap)
 {
     AVIOContext *pb = s->pb;
     APEContext *ape = s->priv_data;
     AVStream *st;
     uint32_t tag;
     int i;
     int total_blocks;
     int64_t pts;
     ape->junklength = 0;
     tag = avio_rl32(pb);
     if (tag != MKTAG('M', 'A', 'C', ' '))
         return -1;
     ape->fileversion = avio_rl16(pb);
     if (ape->fileversion < APE_MIN_VERSION || ape->fileversion > APE_MAX_VERSION) {
         av_log(s, AV_LOG_ERROR, ""Unsupported file version - %d.%02d\n"", ape->fileversion / 1000, (ape->fileversion % 1000) / 10);
         return -1;
     }
     if (ape->fileversion >= 3980) {
         ape->padding1             = avio_rl16(pb);
         ape->descriptorlength     = avio_rl32(pb);
         ape->headerlength         = avio_rl32(pb);
         ape->seektablelength      = avio_rl32(pb);
         ape->wavheaderlength      = avio_rl32(pb);
         ape->audiodatalength      = avio_rl32(pb);
         ape->audiodatalength_high = avio_rl32(pb);
         ape->wavtaillength        = avio_rl32(pb);
         avio_read(pb, ape->md5, 16);
         if (ape->descriptorlength > 52)
             avio_seek(pb, ape->descriptorlength - 52, SEEK_CUR);
         ape->compressiontype      = avio_rl16(pb);
         ape->formatflags          = avio_rl16(pb);
         ape->blocksperframe       = avio_rl32(pb);
         ape->finalframeblocks     = avio_rl32(pb);
         ape->totalframes          = avio_rl32(pb);
         ape->bps                  = avio_rl16(pb);
         ape->channels             = avio_rl16(pb);
         ape->samplerate           = avio_rl32(pb);
     } else {
         ape->descriptorlength = 0;
         ape->headerlength = 32;
         ape->compressiontype      = avio_rl16(pb);
         ape->formatflags          = avio_rl16(pb);
         ape->channels             = avio_rl16(pb);
         ape->samplerate           = avio_rl32(pb);
         ape->wavheaderlength      = avio_rl32(pb);
         ape->wavtaillength        = avio_rl32(pb);
         ape->totalframes          = avio_rl32(pb);
         ape->finalframeblocks     = avio_rl32(pb);
         if (ape->formatflags & MAC_FORMAT_FLAG_HAS_PEAK_LEVEL) {
             avio_seek(pb, 4, SEEK_CUR);  
             ape->headerlength += 4;
         }
         if (ape->formatflags & MAC_FORMAT_FLAG_HAS_SEEK_ELEMENTS) {
             ape->seektablelength = avio_rl32(pb);
             ape->headerlength += 4;
             ape->seektablelength *= sizeof(int32_t);
         } else
             ape->seektablelength = ape->totalframes * sizeof(int32_t);
         if (ape->formatflags & MAC_FORMAT_FLAG_8_BIT)
             ape->bps = 8;
         else if (ape->formatflags & MAC_FORMAT_FLAG_24_BIT)
             ape->bps = 24;
         else
             ape->bps = 16;
         if (ape->fileversion >= 3950)
             ape->blocksperframe = 73728 * 4;
         else if (ape->fileversion >= 3900 || (ape->fileversion >= 3800  && ape->compressiontype >= 4000))
             ape->blocksperframe = 73728;
         else
             ape->blocksperframe = 9216;
         if (!(ape->formatflags & MAC_FORMAT_FLAG_CREATE_WAV_HEADER))
              avio_seek(pb, ape->wavheaderlength, SEEK_CUR);
      }
     if(!ape->totalframes){
         av_log(s, AV_LOG_ERROR, ""No frames in the file!\n"");
         return AVERROR(EINVAL);
     }
      if(ape->totalframes > UINT_MAX / sizeof(APEFrame)){
          av_log(s, AV_LOG_ERROR, ""Too many frames: %d\n"", ape->totalframes);
          return -1;
     }
     ape->frames       = av_malloc(ape->totalframes * sizeof(APEFrame));
     if(!ape->frames)
         return AVERROR(ENOMEM);
     ape->firstframe   = ape->junklength + ape->descriptorlength + ape->headerlength + ape->seektablelength + ape->wavheaderlength;
     ape->currentframe = 0;
     ape->totalsamples = ape->finalframeblocks;
     if (ape->totalframes > 1)
         ape->totalsamples += ape->blocksperframe * (ape->totalframes - 1);
     if (ape->seektablelength > 0) {
         ape->seektable = av_malloc(ape->seektablelength);
         for (i = 0; i < ape->seektablelength / sizeof(uint32_t); i++)
             ape->seektable[i] = avio_rl32(pb);
     }
     ape->frames[0].pos     = ape->firstframe;
     ape->frames[0].nblocks = ape->blocksperframe;
     ape->frames[0].skip    = 0;
     for (i = 1; i < ape->totalframes; i++) {
         ape->frames[i].pos      = ape->seektable[i];  
         ape->frames[i].nblocks  = ape->blocksperframe;
         ape->frames[i - 1].size = ape->frames[i].pos - ape->frames[i - 1].pos;
         ape->frames[i].skip     = (ape->frames[i].pos - ape->frames[0].pos) & 3;
     }
     ape->frames[ape->totalframes - 1].size    = ape->finalframeblocks * 4;
     ape->frames[ape->totalframes - 1].nblocks = ape->finalframeblocks;
     for (i = 0; i < ape->totalframes; i++) {
         if(ape->frames[i].skip){
             ape->frames[i].pos  -= ape->frames[i].skip;
             ape->frames[i].size += ape->frames[i].skip;
         }
         ape->frames[i].size = (ape->frames[i].size + 3) & ~3;
     }
     ape_dumpinfo(s, ape);
     if (!url_is_streamed(pb)) {
         ff_ape_parse_tag(s);
         avio_seek(pb, 0, SEEK_SET);
     }
     av_log(s, AV_LOG_DEBUG, ""Decoding file - v%d.%02d, compression level %d\n"", ape->fileversion / 1000, (ape->fileversion % 1000) / 10, ape->compressiontype);
     st = av_new_stream(s, 0);
     if (!st)
         return -1;
     total_blocks = (ape->totalframes == 0) ? 0 : ((ape->totalframes - 1) * ape->blocksperframe) + ape->finalframeblocks;
     st->codec->codec_type      = AVMEDIA_TYPE_AUDIO;
     st->codec->codec_id        = CODEC_ID_APE;
     st->codec->codec_tag       = MKTAG('A', 'P', 'E', ' ');
     st->codec->channels        = ape->channels;
     st->codec->sample_rate     = ape->samplerate;
     st->codec->bits_per_coded_sample = ape->bps;
     st->codec->frame_size      = MAC_SUBFRAME_SIZE;
     st->nb_frames = ape->totalframes;
     st->start_time = 0;
     st->duration  = total_blocks / MAC_SUBFRAME_SIZE;
     av_set_pts_info(st, 64, MAC_SUBFRAME_SIZE, ape->samplerate);
     st->codec->extradata = av_malloc(APE_EXTRADATA_SIZE);
     st->codec->extradata_size = APE_EXTRADATA_SIZE;
     AV_WL16(st->codec->extradata + 0, ape->fileversion);
     AV_WL16(st->codec->extradata + 2, ape->compressiontype);
     AV_WL16(st->codec->extradata + 4, ape->formatflags);
     pts = 0;
     for (i = 0; i < ape->totalframes; i++) {
         ape->frames[i].pts = pts;
         av_add_index_entry(st, ape->frames[i].pos, ape->frames[i].pts, 0, 0, AVINDEX_KEYFRAME);
         pts += ape->blocksperframe / MAC_SUBFRAME_SIZE;
     }
     return 0;
 }","[75, 76, 77, 78]","The ape_read_header function in ape.c in libavformat in FFmpeg before 0.5.4, as used in MPlayer, VideoLAN VLC media player, and other products, allows remote attackers to cause a denial of service (application crash) via an APE (aka Monkey's Audio) file that contains a header but no frames.",FFmpeg,CVE-2011-2161,CWE-399
5877,182967," process_plane(uint8 * in, int width, int height, uint8 * out, int size)
 {
 	UNUSED(size);
 	int indexw;
 	int indexh;
 	int code;
 	int collen;
 	int replen;
 	int color;
 	int x;
 	int revcode;
 	uint8 * last_line;
 	uint8 * this_line;
 	uint8 * org_in;
 	uint8 * org_out;
 	org_in = in;
 	org_out = out;
 	last_line = 0;
 	indexh = 0;
 	while (indexh < height)
 	{
 		out = (org_out + width * height * 4) - ((indexh + 1) * width * 4);
 		color = 0;
 		this_line = out;
 		indexw = 0;
 		if (last_line == 0)
 		{
 			while (indexw < width)
 			{
 				code = CVAL(in);
 				replen = code & 0xf;
 				collen = (code >> 4) & 0xf;
 				revcode = (replen << 4) | collen;
 				if ((revcode <= 47) && (revcode >= 16))
 				{
  					replen = revcode;
  					collen = 0;
  				}
				while (collen > 0)
 				while (indexw < width && collen > 0)
  				{
  					color = CVAL(in);
  					*out = color;
  					out += 4;
  					indexw++;
  					collen--;
  				}
				while (replen > 0)
 				while (indexw < width && replen > 0)
  				{
  					*out = color;
  					out += 4;
 					indexw++;
 					replen--;
 				}
 			}
 		}
 		else
 		{
 			while (indexw < width)
 			{
 				code = CVAL(in);
 				replen = code & 0xf;
 				collen = (code >> 4) & 0xf;
 				revcode = (replen << 4) | collen;
 				if ((revcode <= 47) && (revcode >= 16))
 				{
  					replen = revcode;
  					collen = 0;
  				}
				while (collen > 0)
 				while (indexw < width && collen > 0)
  				{
  					x = CVAL(in);
  					if (x & 1)
 					{
 						x = x >> 1;
 						x = x + 1;
 						color = -x;
 					}
 					else
 					{
 						x = x >> 1;
 						color = x;
 					}
 					x = last_line[indexw * 4] + color;
 					*out = x;
 					out += 4;
  					indexw++;
  					collen--;
  				}
				while (replen > 0)
 				while (indexw < width && replen > 0)
  				{
  					x = last_line[indexw * 4] + color;
  					*out = x;
 					out += 4;
 					indexw++;
 					replen--;
 				}
 			}
 		}
 		indexh++;
 		last_line = this_line;
 	}
 	return (int) (in - org_in);
 }","[39, 40, 48, 49, 71, 72, 92, 93]",rdesktop versions up to and including v1.8.3 contain a Buffer Overflow over the global variables in the function seamless_process_line() that results in memory corruption and probably even a remote code execution.,rdesktop,CVE-2018-20182,CWE-119
5921,179635," PGTYPESdate_from_asc(char *str, char **endptr)
 {
 	date		dDate;
 	fsec_t		fsec;
 	struct tm	tt,
 			   *tm = &tt;
 	int			dtype;
  	int			nf;
  	char	   *field[MAXDATEFIELDS];
  	int			ftype[MAXDATEFIELDS];
	char		lowstr[MAXDATELEN + 1];
 	char		lowstr[MAXDATELEN + MAXDATEFIELDS];
  	char	   *realptr;
  	char	  **ptr = (endptr != NULL) ? endptr : &realptr;
  	bool		EuroDates = FALSE;
  	errno = 0;
	if (strlen(str) >= sizeof(lowstr))
 	if (strlen(str) > MAXDATELEN)
  	{
  		errno = PGTYPES_DATE_BAD_DATE;
  		return INT_MIN;
 	}
 	if (ParseDateTime(str, lowstr, field, ftype, &nf, ptr) != 0 ||
 		DecodeDateTime(field, ftype, nf, &dtype, tm, &fsec, EuroDates) != 0)
 	{
 		errno = PGTYPES_DATE_BAD_DATE;
 		return INT_MIN;
 	}
 	switch (dtype)
 	{
 		case DTK_DATE:
 			break;
 		case DTK_EPOCH:
 			if (GetEpochTime(tm) < 0)
 			{
 				errno = PGTYPES_DATE_BAD_DATE;
 				return INT_MIN;
 			}
 			break;
 		default:
 			errno = PGTYPES_DATE_BAD_DATE;
 			return INT_MIN;
 	}
 	dDate = (date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - date2j(2000, 1, 1));
 	return dDate;
 }","[11, 12, 17, 18]","Multiple stack-based buffer overflows in PostgreSQL before 8.4.20, 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to cause a denial of service (crash) or possibly execute arbitrary code via vectors related to an incorrect MAXDATELEN constant and datetime values involving (1) intervals, (2) timestamps, or (3) timezones, a different vulnerability than CVE-2014-0065.",postgres,CVE-2014-0063,CWE-119
5945,182081," static int parse_token(char **name, char **value, char **cp)
 {
 	char *end;
 	if (!name || !value || !cp)
 		return -BLKID_ERR_PARAM;
 	if (!(*value = strchr(*cp, '=')))
 		return 0;
 	**value = '\0';
 	*name = strip_line(*cp);
  	*value = skip_over_blank(*value + 1);
  	if (**value == '""') {
		end = strchr(*value + 1, '""');
		if (!end) {
 		char *p = end = *value + 1;
 		while (*p) {
 			if (*p == '\\') {
 				p++;
 				*end = *p;
 			} else {
 				*end = *p;
 				if (*p == '""')
 					break;
 			}
 			p++;
 			end++;
 		}
 		if (*end != '""') {
  			DBG(READ, ul_debug(""unbalanced quotes at: %s"", *value));
  			*cp = *value;
  			return -BLKID_ERR_CACHE;
  		}
  		(*value)++;
  		*end = '\0';
		end++;
 		end = ++p;
  	} else {
  		end = skip_over_word(*value);
  		if (*end) {
 			*end = '\0';
 			end++;
 		}
 	}
 	*cp = end;
 	return 1;
 }","[12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 34, 35]",Blkid in util-linux before 2.26rc-1 allows local users to execute arbitrary code.,util-linux,CVE-2014-9114,CWE-77
5954,182327," int ff_h263_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,
                          AVPacket *avpkt)
 {
     const uint8_t *buf = avpkt->data;
     int buf_size       = avpkt->size;
     MpegEncContext *s  = avctx->priv_data;
     int ret;
     int slice_ret = 0;
     AVFrame *pict = data;
     if (buf_size == 0) {
         if (s->low_delay == 0 && s->next_picture_ptr) {
             if ((ret = av_frame_ref(pict, s->next_picture_ptr->f)) < 0)
                 return ret;
             s->next_picture_ptr = NULL;
             *got_frame = 1;
         }
         return 0;
     }
     if (s->avctx->flags & AV_CODEC_FLAG_TRUNCATED) {
         int next;
         if (CONFIG_MPEG4_DECODER && s->codec_id == AV_CODEC_ID_MPEG4) {
             next = ff_mpeg4_find_frame_end(&s->parse_context, buf, buf_size);
         } else if (CONFIG_H263_DECODER && s->codec_id == AV_CODEC_ID_H263) {
             next = ff_h263_find_frame_end(&s->parse_context, buf, buf_size);
         } else if (CONFIG_H263P_DECODER && s->codec_id == AV_CODEC_ID_H263P) {
             next = ff_h263_find_frame_end(&s->parse_context, buf, buf_size);
         } else {
             av_log(s->avctx, AV_LOG_ERROR,
                    ""this codec does not support truncated bitstreams\n"");
             return AVERROR(ENOSYS);
         }
         if (ff_combine_frame(&s->parse_context, next, (const uint8_t **)&buf,
                              &buf_size) < 0)
             return buf_size;
     }
 retry:
     if (s->divx_packed && s->bitstream_buffer_size) {
         int i;
         for(i=0; i < buf_size-3; i++) {
             if (buf[i]==0 && buf[i+1]==0 && buf[i+2]==1) {
                 if (buf[i+3]==0xB0) {
                     av_log(s->avctx, AV_LOG_WARNING, ""Discarding excessive bitstream in packed xvid\n"");
                     s->bitstream_buffer_size = 0;
                 }
                 break;
             }
         }
     }
     if (s->bitstream_buffer_size && (s->divx_packed || buf_size <= MAX_NVOP_SIZE))  
         ret = init_get_bits8(&s->gb, s->bitstream_buffer,
                              s->bitstream_buffer_size);
     else
         ret = init_get_bits8(&s->gb, buf, buf_size);
     s->bitstream_buffer_size = 0;
     if (ret < 0)
         return ret;
     if (!s->context_initialized)
         ff_mpv_idct_init(s);
     if (CONFIG_WMV2_DECODER && s->msmpeg4_version == 5) {
         ret = ff_wmv2_decode_picture_header(s);
     } else if (CONFIG_MSMPEG4_DECODER && s->msmpeg4_version) {
         ret = ff_msmpeg4_decode_picture_header(s);
     } else if (CONFIG_MPEG4_DECODER && avctx->codec_id == AV_CODEC_ID_MPEG4) {
         if (s->avctx->extradata_size && s->picture_number == 0) {
             GetBitContext gb;
             if (init_get_bits8(&gb, s->avctx->extradata, s->avctx->extradata_size) >= 0 )
                 ff_mpeg4_decode_picture_header(avctx->priv_data, &gb);
         }
         ret = ff_mpeg4_decode_picture_header(avctx->priv_data, &s->gb);
     } else if (CONFIG_H263I_DECODER && s->codec_id == AV_CODEC_ID_H263I) {
         ret = ff_intel_h263_decode_picture_header(s);
     } else if (CONFIG_FLV_DECODER && s->h263_flv) {
         ret = ff_flv_decode_picture_header(s);
     } else {
         ret = ff_h263_decode_picture_header(s);
     }
     if (ret < 0 || ret == FRAME_SKIPPED) {
         if (   s->width  != avctx->coded_width
             || s->height != avctx->coded_height) {
                 av_log(s->avctx, AV_LOG_WARNING, ""Reverting picture dimensions change due to header decoding failure\n"");
                 s->width = avctx->coded_width;
                 s->height= avctx->coded_height;
         }
     }
     if (ret == FRAME_SKIPPED)
         return get_consumed_bytes(s, buf_size);
     if (ret < 0) {
         av_log(s->avctx, AV_LOG_ERROR, ""header damaged\n"");
         return ret;
     }
     if (!s->context_initialized) {
         avctx->pix_fmt = h263_get_format(avctx);
         if ((ret = ff_mpv_common_init(s)) < 0)
             return ret;
     }
     if (!s->current_picture_ptr || s->current_picture_ptr->f->data[0]) {
         int i = ff_find_unused_picture(s->avctx, s->picture, 0);
         if (i < 0)
             return i;
         s->current_picture_ptr = &s->picture[i];
     }
     avctx->has_b_frames = !s->low_delay;
     if (CONFIG_MPEG4_DECODER && avctx->codec_id == AV_CODEC_ID_MPEG4) {
         if (ff_mpeg4_workaround_bugs(avctx) == 1)
             goto retry;
         if (s->studio_profile != (s->idsp.idct == NULL))
             ff_mpv_idct_init(s);
     }
     if (s->width  != avctx->coded_width  ||
         s->height != avctx->coded_height ||
         s->context_reinit) {
         s->context_reinit = 0;
         ret = ff_set_dimensions(avctx, s->width, s->height);
         if (ret < 0)
             return ret;
         ff_set_sar(avctx, avctx->sample_aspect_ratio);
         if ((ret = ff_mpv_common_frame_size_change(s)))
             return ret;
         if (avctx->pix_fmt != h263_get_format(avctx)) {
             av_log(avctx, AV_LOG_ERROR, ""format change not supported\n"");
             avctx->pix_fmt = AV_PIX_FMT_NONE;
             return AVERROR_UNKNOWN;
         }
     }
     if (s->codec_id == AV_CODEC_ID_H263  ||
         s->codec_id == AV_CODEC_ID_H263P ||
         s->codec_id == AV_CODEC_ID_H263I)
         s->gob_index = H263_GOB_HEIGHT(s->height);
     s->current_picture.f->pict_type = s->pict_type;
     s->current_picture.f->key_frame = s->pict_type == AV_PICTURE_TYPE_I;
     if (!s->last_picture_ptr &&
         (s->pict_type == AV_PICTURE_TYPE_B || s->droppable))
         return get_consumed_bytes(s, buf_size);
     if ((avctx->skip_frame >= AVDISCARD_NONREF &&
          s->pict_type == AV_PICTURE_TYPE_B)    ||
         (avctx->skip_frame >= AVDISCARD_NONKEY &&
          s->pict_type != AV_PICTURE_TYPE_I)    ||
         avctx->skip_frame >= AVDISCARD_ALL)
         return get_consumed_bytes(s, buf_size);
     if (s->next_p_frame_damaged) {
         if (s->pict_type == AV_PICTURE_TYPE_B)
             return get_consumed_bytes(s, buf_size);
         else
             s->next_p_frame_damaged = 0;
     }
     if ((!s->no_rounding) || s->pict_type == AV_PICTURE_TYPE_B) {
         s->me.qpel_put = s->qdsp.put_qpel_pixels_tab;
         s->me.qpel_avg = s->qdsp.avg_qpel_pixels_tab;
     } else {
         s->me.qpel_put = s->qdsp.put_no_rnd_qpel_pixels_tab;
         s->me.qpel_avg = s->qdsp.avg_qpel_pixels_tab;
     }
     if ((ret = ff_mpv_frame_start(s, avctx)) < 0)
         return ret;
     if (!s->divx_packed)
         ff_thread_finish_setup(avctx);
     if (avctx->hwaccel) {
         ret = avctx->hwaccel->start_frame(avctx, s->gb.buffer,
                                           s->gb.buffer_end - s->gb.buffer);
         if (ret < 0 )
             return ret;
     }
     ff_mpeg_er_frame_start(s);
     if (CONFIG_WMV2_DECODER && s->msmpeg4_version == 5) {
         ret = ff_wmv2_decode_secondary_picture_header(s);
         if (ret < 0)
             return ret;
         if (ret == 1)
             goto frame_end;
     }
     s->mb_x = 0;
     s->mb_y = 0;
     slice_ret = decode_slice(s);
     while (s->mb_y < s->mb_height) {
         if (s->msmpeg4_version) {
             if (s->slice_height == 0 || s->mb_x != 0 || slice_ret < 0 ||
                 (s->mb_y % s->slice_height) != 0 || get_bits_left(&s->gb) < 0)
                 break;
         } else {
             int prev_x = s->mb_x, prev_y = s->mb_y;
             if (ff_h263_resync(s) < 0)
                 break;
             if (prev_y * s->mb_width + prev_x < s->mb_y * s->mb_width + s->mb_x)
                 s->er.error_occurred = 1;
         }
         if (s->msmpeg4_version < 4 && s->h263_pred)
             ff_mpeg4_clean_buffers(s);
         if (decode_slice(s) < 0)
             slice_ret = AVERROR_INVALIDDATA;
     }
     if (s->msmpeg4_version && s->msmpeg4_version < 4 &&
         s->pict_type == AV_PICTURE_TYPE_I)
         if (!CONFIG_MSMPEG4_DECODER ||
             ff_msmpeg4_decode_ext_header(s, buf_size) < 0)
             s->er.error_status_table[s->mb_num - 1] = ER_MB_ERROR;
      av_assert1(s->bitstream_buffer_size == 0);
  frame_end:
    ff_er_frame_end(&s->er);
     if (!s->studio_profile)
         ff_er_frame_end(&s->er);
      if (avctx->hwaccel) {
          ret = avctx->hwaccel->end_frame(avctx);
         if (ret < 0)
             return ret;
     }
     ff_mpv_frame_end(s);
     if (CONFIG_MPEG4_DECODER && avctx->codec_id == AV_CODEC_ID_MPEG4)
         ff_mpeg4_frame_end(avctx, buf, buf_size);
     if (!s->divx_packed && avctx->hwaccel)
         ff_thread_finish_setup(avctx);
     av_assert1(s->current_picture.f->pict_type == s->current_picture_ptr->f->pict_type);
     av_assert1(s->current_picture.f->pict_type == s->pict_type);
     if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay) {
         if ((ret = av_frame_ref(pict, s->current_picture_ptr->f)) < 0)
             return ret;
         ff_print_debug_info(s, s->current_picture_ptr, pict);
         ff_mpv_export_qp_table(s, pict, s->current_picture_ptr, FF_QSCALE_TYPE_MPEG1);
     } else if (s->last_picture_ptr) {
         if ((ret = av_frame_ref(pict, s->last_picture_ptr->f)) < 0)
             return ret;
         ff_print_debug_info(s, s->last_picture_ptr, pict);
         ff_mpv_export_qp_table(s, pict, s->last_picture_ptr, FF_QSCALE_TYPE_MPEG1);
     }
     if (s->last_picture_ptr || s->low_delay) {
         if (   pict->format == AV_PIX_FMT_YUV420P
             && (s->codec_tag == AV_RL32(""GEOV"") || s->codec_tag == AV_RL32(""GEOX""))) {
             int x, y, p;
             av_frame_make_writable(pict);
             for (p=0; p<3; p++) {
                 int w = AV_CEIL_RSHIFT(pict-> width, !!p);
                 int h = AV_CEIL_RSHIFT(pict->height, !!p);
                 int linesize = pict->linesize[p];
                 for (y=0; y<(h>>1); y++)
                     for (x=0; x<w; x++)
                         FFSWAP(int,
                                pict->data[p][x + y*linesize],
                                pict->data[p][x + (h-1-y)*linesize]);
             }
         }
         *got_frame = 1;
     }
     if (slice_ret < 0 && (avctx->err_recognition & AV_EF_EXPLODE))
         return slice_ret;
     else
         return get_consumed_bytes(s, buf_size);
 }","[198, 199, 200]","In libavcodec in FFmpeg 4.0.1, improper maintenance of the consistency between the context profile field and studio_profile in libavcodec may trigger an assertion failure while converting a crafted AVI file to MPEG4, leading to a denial of service, related to error_resilience.c, h263dec.c, and mpeg4videodec.c.",FFmpeg,CVE-2018-13304,CWE-617
5980,179172," static int filter_frame(AVFilterLink *inlink, AVFrame *frame)
 {
     AVFilterContext   *ctx     = inlink->dst;
     FieldOrderContext *s       = ctx->priv;
     AVFilterLink      *outlink = ctx->outputs[0];
     int h, plane, line_step, line_size, line;
     uint8_t *data;
     if (!frame->interlaced_frame ||
         frame->top_field_first == s->dst_tff)
         return ff_filter_frame(outlink, frame);
     av_dlog(ctx,
              ""picture will move %s one line\n"",
              s->dst_tff ? ""up"" : ""down"");
      h = frame->height;
    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {
     for (plane = 0; plane < 4 && frame->data[plane] && frame->linesize[plane]; plane++) {
          line_step = frame->linesize[plane];
          line_size = s->line_size[plane];
          data = frame->data[plane];
         if (s->dst_tff) {
             for (line = 0; line < h; line++) {
                 if (1 + line < frame->height) {
                     memcpy(data, data + line_step, line_size);
                 } else {
                     memcpy(data, data - line_step - line_step, line_size);
                 }
                 data += line_step;
             }
         } else {
             data += (h - 1) * line_step;
             for (line = h - 1; line >= 0 ; line--) {
                 if (line > 0) {
                     memcpy(data, data - line_step, line_size);
                 } else {
                     memcpy(data, data + line_step + line_step, line_size);
                 }
                 data -= line_step;
             }
         }
     }
     frame->top_field_first = s->dst_tff;
     return ff_filter_frame(outlink, frame);
 }","[15, 16]","libavfilter in FFmpeg before 2.0.1 has unspecified impact and remote vectors related to a crafted *plane,* which triggers an out-of-bounds heap write.",FFmpeg,CVE-2013-4263,CWE-119
5990,182656," get_uncompressed_data(struct archive_read *a, const void **buff, size_t size,
     size_t minimum)
 {
 	struct _7zip *zip = (struct _7zip *)a->format->data;
 	ssize_t bytes_avail;
  	if (zip->codec == _7Z_COPY && zip->codec2 == (unsigned long)-1) {
		*buff = __archive_read_ahead(a, 1, &bytes_avail);
 		*buff = __archive_read_ahead(a, minimum, &bytes_avail);
  		if (bytes_avail <= 0) {
  			archive_set_error(&a->archive,
  			    ARCHIVE_ERRNO_FILE_FORMAT,
 			    ""Truncated 7-Zip file data"");
 			return (ARCHIVE_FATAL);
 		}
 		if ((size_t)bytes_avail >
 		    zip->uncompressed_buffer_bytes_remaining)
 			bytes_avail = (ssize_t)
 			    zip->uncompressed_buffer_bytes_remaining;
 		if ((size_t)bytes_avail > size)
 			bytes_avail = (ssize_t)size;
 		zip->pack_stream_bytes_unconsumed = bytes_avail;
 	} else if (zip->uncompressed_buffer_pointer == NULL) {
 		archive_set_error(&(a->archive),
 		    ARCHIVE_ERRNO_MISC, ""Damaged 7-Zip archive"");
 		return (ARCHIVE_FATAL);
 	} else {
 		if (minimum > zip->uncompressed_buffer_bytes_remaining) {
 			if (extract_pack_stream(a, minimum) < 0)
 				return (ARCHIVE_FATAL);
 		}
 		if (size > zip->uncompressed_buffer_bytes_remaining)
 			bytes_avail = (ssize_t)
 			    zip->uncompressed_buffer_bytes_remaining;
 		else
 			bytes_avail = (ssize_t)size;
 		*buff = zip->uncompressed_buffer_pointer;
 		zip->uncompressed_buffer_pointer += bytes_avail;
 	}
 	zip->uncompressed_buffer_bytes_remaining -= bytes_avail;
 	return (bytes_avail);
 }","[7, 8]","libarchive version commit bf9aec176c6748f0ee7a678c5f9f9555b9a757c1 onwards (release v3.0.2 onwards) contains a CWE-125: Out-of-bounds Read vulnerability in 7zip decompression, archive_read_support_format_7zip.c, header_bytes() that can result in a crash (denial of service). This attack appears to be exploitable via the victim opening a specially crafted 7zip file.",libarchive,CVE-2019-1000019,CWE-125
5991,180937," static int mxf_read_index_entry_array(AVIOContext *pb, MXFIndexTableSegment *segment)
 {
     int i, length;
      segment->nb_index_entries = avio_rb32(pb);
      length = avio_rb32(pb);
     if(segment->nb_index_entries && length < 11)
         return AVERROR_INVALIDDATA;
      if (!(segment->temporal_offset_entries=av_calloc(segment->nb_index_entries, sizeof(*segment->temporal_offset_entries))) ||
          !(segment->flag_entries          = av_calloc(segment->nb_index_entries, sizeof(*segment->flag_entries))) ||
         !(segment->stream_offset_entries = av_calloc(segment->nb_index_entries, sizeof(*segment->stream_offset_entries)))) {
         av_freep(&segment->temporal_offset_entries);
         av_freep(&segment->flag_entries);
         return AVERROR(ENOMEM);
      }
      for (i = 0; i < segment->nb_index_entries; i++) {
         if(avio_feof(pb))
             return AVERROR_INVALIDDATA;
          segment->temporal_offset_entries[i] = avio_r8(pb);
          avio_r8(pb);                                         
          segment->flag_entries[i] = avio_r8(pb);
         segment->stream_offset_entries[i] = avio_rb64(pb);
         avio_skip(pb, length - 11);
     }
     return 0;
 }","[6, 7, 16, 17]","In libavformat/mxfdec.c in FFmpeg 3.3.3, a DoS in mxf_read_index_entry_array() due to lack of an EOF (End of File) check might cause huge CPU consumption. When a crafted MXF file, which claims a large *nb_index_entries* field in the header but does not contain sufficient backing data, is provided, the loop would consume huge CPU resources, since there is no EOF check inside the loop. Moreover, this big loop can be invoked multiple times if there is more than one applicable data segment in the crafted MXF file.",FFmpeg,CVE-2017-14170,CWE-834
6005,181272," yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, void *yyscanner, HEX_LEX_ENVIRONMENT *lex_env)
 {
   YYUSE (yyvaluep);
   YYUSE (yyscanner);
   YYUSE (lex_env);
   if (!yymsg)
     yymsg = ""Deleting"";
   YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
   YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
    switch (yytype)
      {
            case 16:  
#line 94 ""hex_grammar.y""  
 #line 101 ""hex_grammar.y""  
        { yr_re_node_destroy(((*yyvaluep).re_node)); }
#line 1023 ""hex_grammar.c""  
 #line 1030 ""hex_grammar.c""  
          break;
      case 17:  
#line 95 ""hex_grammar.y""  
 #line 102 ""hex_grammar.y""  
        { yr_re_node_destroy(((*yyvaluep).re_node)); }
#line 1029 ""hex_grammar.c""  
 #line 1036 ""hex_grammar.c""  
          break;
      case 18:  
#line 96 ""hex_grammar.y""  
 #line 103 ""hex_grammar.y""  
        { yr_re_node_destroy(((*yyvaluep).re_node)); }
#line 1035 ""hex_grammar.c""  
 #line 1042 ""hex_grammar.c""  
          break;
      case 19:  
#line 97 ""hex_grammar.y""  
 #line 104 ""hex_grammar.y""  
        { yr_re_node_destroy(((*yyvaluep).re_node)); }
#line 1041 ""hex_grammar.c""  
 #line 1048 ""hex_grammar.c""  
          break;
      case 21:  
#line 100 ""hex_grammar.y""  
 #line 107 ""hex_grammar.y""  
        { yr_re_node_destroy(((*yyvaluep).re_node)); }
#line 1047 ""hex_grammar.c""  
 #line 1054 ""hex_grammar.c""  
          break;
      case 22:  
#line 99 ""hex_grammar.y""  
 #line 106 ""hex_grammar.y""  
        { yr_re_node_destroy(((*yyvaluep).re_node)); }
#line 1053 ""hex_grammar.c""  
 #line 1060 ""hex_grammar.c""  
          break;
      case 23:  
#line 98 ""hex_grammar.y""  
 #line 105 ""hex_grammar.y""  
        { yr_re_node_destroy(((*yyvaluep).re_node)); }
#line 1059 ""hex_grammar.c""  
 #line 1066 ""hex_grammar.c""  
          break;
       default:
         break;
     }
   YY_IGNORE_MAYBE_UNINITIALIZED_END
 }","[13, 14, 16, 17, 20, 21, 23, 24, 27, 28, 30, 31, 34, 35, 37, 38, 41, 42, 44, 45, 48, 49, 51, 52, 55, 56, 58, 59]","libyara/re.c in the regexp module in YARA 3.5.0 allows remote attackers to cause a denial of service (stack consumption) via a crafted rule (involving hex strings) that is mishandled in the _yr_re_emit function, a different vulnerability than CVE-2017-9304.",yara,CVE-2017-9438,CWE-674
6009,181923,"  static long mem_seek(jas_stream_obj_t *obj, long offset, int origin)
  {
  	jas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;
	long newpos;
 	size_t newpos;
  	JAS_DBGLOG(100, (""mem_seek(%p, %ld, %d)\n"", obj, offset, origin));
  	switch (origin) {
 	case SEEK_SET:
 		newpos = offset;
 		break;
 	case SEEK_END:
 		newpos = m->len_ - offset;
 		break;
 	case SEEK_CUR:
 		newpos = m->pos_ + offset;
 		break;
 	default:
 		abort();
 		break;
 	}
 	if (newpos < 0) {
 		return -1;
 	}
 	m->pos_ = newpos;
 	return m->pos_;
 }","[4, 5]","Multiple integer overflows in the (1) jas_realloc function in base/jas_malloc.c and (2) mem_resize function in base/jas_stream.c in JasPer before 1.900.22 allow remote attackers to cause a denial of service via a crafted image, which triggers use after free vulnerabilities.",jasper,CVE-2016-9262,CWE-190
6026,181853," int main(int argc, char **argv)
 {
 	int fmtid;
 	int id;
 	char *infile;
 	jas_stream_t *instream;
 	jas_image_t *image;
 	int width;
 	int height;
 	int depth;
 	int numcmpts;
 	int verbose;
  	char *fmtname;
  	int debug;
  	size_t max_mem;
 	size_t max_samples;
 	char optstr[32];
  	if (jas_init()) {
  		abort();
  	}
  	cmdname = argv[0];
 	max_samples = 64 * JAS_MEBI;
  	infile = 0;
  	verbose = 0;
  	debug = 0;
 #if defined(JAS_DEFAULT_MAX_MEM_USAGE)
 	max_mem = JAS_DEFAULT_MAX_MEM_USAGE;
 #endif
 	while ((id = jas_getopt(argc, argv, opts)) >= 0) {
 		switch (id) {
 		case OPT_VERBOSE:
 			verbose = 1;
 			break;
 		case OPT_VERSION:
 			printf(""%s\n"", JAS_VERSION);
 			exit(EXIT_SUCCESS);
 			break;
 		case OPT_DEBUG:
 			debug = atoi(jas_optarg);
 			break;
  		case OPT_INFILE:
  			infile = jas_optarg;
  			break;
 		case OPT_MAXSAMPLES:
 			max_samples = strtoull(jas_optarg, 0, 10);
 			break;
  		case OPT_MAXMEM:
  			max_mem = strtoull(jas_optarg, 0, 10);
  			break;
 		case OPT_HELP:
 		default:
 			usage();
 			break;
 		}
 	}
 	jas_setdbglevel(debug);
 #if defined(JAS_DEFAULT_MAX_MEM_USAGE)
 	jas_set_max_mem_usage(max_mem);
 #endif
 	if (infile) {
 		if (!(instream = jas_stream_fopen(infile, ""rb""))) {
 			fprintf(stderr, ""cannot open input image file %s\n"", infile);
 			exit(EXIT_FAILURE);
 		}
 	} else {
 		if (!(instream = jas_stream_fdopen(0, ""rb""))) {
 			fprintf(stderr, ""cannot open standard input\n"");
 			exit(EXIT_FAILURE);
 		}
 	}
 	if ((fmtid = jas_image_getfmt(instream)) < 0) {
  		fprintf(stderr, ""unknown image format\n"");
  	}
 	snprintf(optstr, sizeof(optstr), ""max_samples=%-zu"", max_samples);
	if (!(image = jas_image_decode(instream, fmtid, 0))) {
 	if (!(image = jas_image_decode(instream, fmtid, optstr))) {
  		jas_stream_close(instream);
  		fprintf(stderr, ""cannot load image\n"");
  		return EXIT_FAILURE;
 	}
  	jas_stream_close(instream);
 	if (!(fmtname = jas_image_fmttostr(fmtid))) {
 		jas_eprintf(""format name lookup failed\n"");
 		return EXIT_FAILURE;
 	}
  	if (!(numcmpts = jas_image_numcmpts(image))) {
  		fprintf(stderr, ""warning: image has no components\n"");
  	}
 	if (numcmpts) {
 		width = jas_image_cmptwidth(image, 0);
 		height = jas_image_cmptheight(image, 0);
 		depth = jas_image_cmptprec(image, 0);
 	} else {
 		width = 0;
  		height = 0;
  		depth = 0;
  	}
	if (!(fmtname = jas_image_fmttostr(fmtid))) {
		abort();
	}
	printf(""%s %d %d %d %d %ld\n"", fmtname, numcmpts, width, height, depth, (long) jas_image_rawsize(image));
 	printf(""%s %d %d %d %d %ld\n"", fmtname, numcmpts, width, height, depth,
 	  JAS_CAST(long, jas_image_rawsize(image)));
  	jas_image_destroy(image);
  	jas_image_clearfmts();
 	return EXIT_SUCCESS;
 }","[16, 17, 22, 44, 45, 46, 74, 75, 76, 82, 83, 84, 85, 98, 99, 100, 101, 102, 103]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
6037,182386," NO_INLINE JsVar *jspeFactor() {
   if (lex->tk==LEX_ID) {
     JsVar *a = jspGetNamedVariable(jslGetTokenValueAsString(lex));
     JSP_ASSERT_MATCH(LEX_ID);
 #ifndef SAVE_ON_FLASH
     if (lex->tk==LEX_TEMPLATE_LITERAL)
       jsExceptionHere(JSET_SYNTAXERROR, ""Tagged template literals not supported"");
     else if (lex->tk==LEX_ARROW_FUNCTION && jsvIsName(a)) {
       JsVar *funcVar = jspeArrowFunction(0,a);
       jsvUnLock(a);
       a=funcVar;
     }
 #endif
     return a;
   } else if (lex->tk==LEX_INT) {
     JsVar *v = 0;
     if (JSP_SHOULD_EXECUTE) {
       v = jsvNewFromLongInteger(stringToInt(jslGetTokenValueAsString(lex)));
     }
     JSP_ASSERT_MATCH(LEX_INT);
     return v;
   } else if (lex->tk==LEX_FLOAT) {
     JsVar *v = 0;
     if (JSP_SHOULD_EXECUTE) {
       v = jsvNewFromFloat(stringToFloat(jslGetTokenValueAsString(lex)));
     }
     JSP_ASSERT_MATCH(LEX_FLOAT);
     return v;
   } else if (lex->tk=='(') {
     JSP_ASSERT_MATCH('(');
     if (!jspCheckStackPosition()) return 0;
 #ifdef SAVE_ON_FLASH
     JsVar *a = jspeExpression();
     if (!JSP_SHOULDNT_PARSE) JSP_MATCH_WITH_RETURN(')',a);
     return a;
 #else
     return jspeExpressionOrArrowFunction();
 #endif
   } else if (lex->tk==LEX_R_TRUE) {
     JSP_ASSERT_MATCH(LEX_R_TRUE);
     return JSP_SHOULD_EXECUTE ? jsvNewFromBool(true) : 0;
   } else if (lex->tk==LEX_R_FALSE) {
     JSP_ASSERT_MATCH(LEX_R_FALSE);
     return JSP_SHOULD_EXECUTE ? jsvNewFromBool(false) : 0;
   } else if (lex->tk==LEX_R_NULL) {
     JSP_ASSERT_MATCH(LEX_R_NULL);
     return JSP_SHOULD_EXECUTE ? jsvNewWithFlags(JSV_NULL) : 0;
   } else if (lex->tk==LEX_R_UNDEFINED) {
     JSP_ASSERT_MATCH(LEX_R_UNDEFINED);
     return 0;
   } else if (lex->tk==LEX_STR) {
     JsVar *a = 0;
     if (JSP_SHOULD_EXECUTE)
       a = jslGetTokenValueAsVar(lex);
     JSP_ASSERT_MATCH(LEX_STR);
     return a;
 #ifndef SAVE_ON_FLASH
   } else if (lex->tk==LEX_TEMPLATE_LITERAL) {
     return jspeTemplateLiteral();
 #endif
   } else if (lex->tk==LEX_REGEX) {
     JsVar *a = 0;
 #ifdef SAVE_ON_FLASH
     jsExceptionHere(JSET_SYNTAXERROR, ""RegEx are not supported in this version of Espruino\n"");
 #else
     JsVar *regex = jslGetTokenValueAsVar(lex);
     size_t regexEnd = 0, regexLen = 0;
     JsvStringIterator it;
     jsvStringIteratorNew(&it, regex, 0);
     while (jsvStringIteratorHasChar(&it)) {
       regexLen++;
       if (jsvStringIteratorGetChar(&it)=='/')
         regexEnd = regexLen;
       jsvStringIteratorNext(&it);
     }
     jsvStringIteratorFree(&it);
     JsVar *flags = 0;
     if (regexEnd < regexLen)
       flags = jsvNewFromStringVar(regex, regexEnd, JSVAPPENDSTRINGVAR_MAXLENGTH);
     JsVar *regexSource = jsvNewFromStringVar(regex, 1, regexEnd-2);
     a = jswrap_regexp_constructor(regexSource, flags);
     jsvUnLock3(regex, flags, regexSource);
 #endif
     JSP_ASSERT_MATCH(LEX_REGEX);
     return a;
   } else if (lex->tk=='{') {
     if (!jspCheckStackPosition()) return 0;
     return jspeFactorObject();
   } else if (lex->tk=='[') {
     if (!jspCheckStackPosition()) return 0;
     return jspeFactorArray();
   } else if (lex->tk==LEX_R_FUNCTION) {
     if (!jspCheckStackPosition()) return 0;
     JSP_ASSERT_MATCH(LEX_R_FUNCTION);
     return jspeFunctionDefinition(true);
 #ifndef SAVE_ON_FLASH
   } else if (lex->tk==LEX_R_CLASS) {
     if (!jspCheckStackPosition()) return 0;
     JSP_ASSERT_MATCH(LEX_R_CLASS);
     return jspeClassDefinition(true);
   } else if (lex->tk==LEX_R_SUPER) {
     JSP_ASSERT_MATCH(LEX_R_SUPER);
     if (jsvIsObject(execInfo.thisVar)) {
       JsVar *proto1 = jsvObjectGetChild(execInfo.thisVar, JSPARSE_INHERITS_VAR, 0);  
       JsVar *proto2 = jsvIsObject(proto1) ? jsvObjectGetChild(proto1, JSPARSE_INHERITS_VAR, 0) : 0;  
       jsvUnLock(proto1);
       if (!proto2) {
         jsExceptionHere(JSET_SYNTAXERROR, ""Calling 'super' outside of class"");
         return 0;
       }
       if (lex->tk=='(') return proto2;  
       JsVar *proto3 = jsvIsFunction(proto2) ? jsvObjectGetChild(proto2, JSPARSE_PROTOTYPE_VAR, 0) : 0;
       jsvUnLock(proto2);
       return proto3;
     } else if (jsvIsFunction(execInfo.thisVar)) {
       JsVar *proto1 = jsvObjectGetChild(execInfo.thisVar, JSPARSE_PROTOTYPE_VAR, 0);
       JsVar *proto2 = jsvIsObject(proto1) ? jsvObjectGetChild(proto1, JSPARSE_INHERITS_VAR, 0) : 0;
       jsvUnLock(proto1);
       if (!proto2) {
         jsExceptionHere(JSET_SYNTAXERROR, ""Calling 'super' outside of class"");
         return 0;
       }
       return proto2;
     }
     jsExceptionHere(JSET_SYNTAXERROR, ""Calling 'super' outside of class"");
     return 0;
 #endif
   } else if (lex->tk==LEX_R_THIS) {
     JSP_ASSERT_MATCH(LEX_R_THIS);
     return jsvLockAgain( execInfo.thisVar ? execInfo.thisVar : execInfo.root );
   } else if (lex->tk==LEX_R_DELETE) {
     if (!jspCheckStackPosition()) return 0;
     return jspeFactorDelete();
   } else if (lex->tk==LEX_R_TYPEOF) {
      if (!jspCheckStackPosition()) return 0;
      return jspeFactorTypeOf();
    } else if (lex->tk==LEX_R_VOID) {
     if (!jspCheckStackPosition()) return 0;
      JSP_ASSERT_MATCH(LEX_R_VOID);
      jsvUnLock(jspeUnaryExpression());
      return 0;
   }
   JSP_MATCH(LEX_EOF);
   jsExceptionHere(JSET_SYNTAXERROR, ""Unexpected end of Input\n"");
   return 0;
 }
 NO_INLINE JsVar *__jspePostfixExpression(JsVar *a) {
   while (lex->tk==LEX_PLUSPLUS || lex->tk==LEX_MINUSMINUS) {
     int op = lex->tk;
     JSP_ASSERT_MATCH(op);
     if (JSP_SHOULD_EXECUTE) {
       JsVar *one = jsvNewFromInteger(1);
       JsVar *oldValue = jsvAsNumberAndUnLock(jsvSkipName(a));  
       JsVar *res = jsvMathsOpSkipNames(oldValue, one, op==LEX_PLUSPLUS ? '+' : '-');
       jsvUnLock(one);
       jspReplaceWith(a, res);
       jsvUnLock(res);
       jsvUnLock(a);
       a = oldValue;
     }
   }
   return a;
 }
 NO_INLINE JsVar *jspePostfixExpression() {
   JsVar *a;
   if (lex->tk==LEX_PLUSPLUS || lex->tk==LEX_MINUSMINUS) {
     int op = lex->tk;
     JSP_ASSERT_MATCH(op);
     a = jspePostfixExpression();
     if (JSP_SHOULD_EXECUTE) {
       JsVar *one = jsvNewFromInteger(1);
       JsVar *res = jsvMathsOpSkipNames(a, one, op==LEX_PLUSPLUS ? '+' : '-');
       jsvUnLock(one);
       jspReplaceWith(a, res);
       jsvUnLock(res);
     }
   } else
     a = jspeFactorFunctionCall();
   return __jspePostfixExpression(a);
 }
 NO_INLINE JsVar *jspeUnaryExpression() {
   if (lex->tk=='!' || lex->tk=='~' || lex->tk=='-' || lex->tk=='+') {
     short tk = lex->tk;
     JSP_ASSERT_MATCH(tk);
     if (!JSP_SHOULD_EXECUTE) {
       return jspeUnaryExpression();
     }
     if (tk=='!') {  
       return jsvNewFromBool(!jsvGetBoolAndUnLock(jsvSkipNameAndUnLock(jspeUnaryExpression())));
     } else if (tk=='~') {  
       return jsvNewFromInteger(~jsvGetIntegerAndUnLock(jsvSkipNameAndUnLock(jspeUnaryExpression())));
     } else if (tk=='-') {  
       return jsvNegateAndUnLock(jspeUnaryExpression());  
     }  else if (tk=='+') {  
       JsVar *v = jsvSkipNameAndUnLock(jspeUnaryExpression());
       JsVar *r = jsvAsNumber(v);  
       jsvUnLock(v);
       return r;
     }
     assert(0);
     return 0;
   } else
     return jspePostfixExpression();
 }
 unsigned int jspeGetBinaryExpressionPrecedence(int op) {
   switch (op) {
   case LEX_OROR: return 1; break;
   case LEX_ANDAND: return 2; break;
   case '|' : return 3; break;
   case '^' : return 4; break;
   case '&' : return 5; break;
   case LEX_EQUAL:
   case LEX_NEQUAL:
   case LEX_TYPEEQUAL:
   case LEX_NTYPEEQUAL: return 6;
   case LEX_LEQUAL:
   case LEX_GEQUAL:
   case '<':
   case '>':
   case LEX_R_INSTANCEOF: return 7;
   case LEX_R_IN: return (execInfo.execute&EXEC_FOR_INIT)?0:7;
   case LEX_LSHIFT:
   case LEX_RSHIFT:
   case LEX_RSHIFTUNSIGNED: return 8;
   case '+':
   case '-': return 9;
   case '*':
   case '/':
   case '%': return 10;
   default: return 0;
   }
 }
 NO_INLINE JsVar *__jspeBinaryExpression(JsVar *a, unsigned int lastPrecedence) {
   unsigned int precedence = jspeGetBinaryExpressionPrecedence(lex->tk);
   while (precedence && precedence>lastPrecedence) {
     int op = lex->tk;
     JSP_ASSERT_MATCH(op);
     if (op==LEX_ANDAND || op==LEX_OROR) {
       bool aValue = jsvGetBoolAndUnLock(jsvSkipName(a));
       if ((!aValue && op==LEX_ANDAND) ||
           (aValue && op==LEX_OROR)) {
         JSP_SAVE_EXECUTE();
         jspSetNoExecute();
         jsvUnLock(__jspeBinaryExpression(jspeUnaryExpression(),precedence));
         JSP_RESTORE_EXECUTE();
       } else {
         jsvUnLock(a);
         a = __jspeBinaryExpression(jspeUnaryExpression(),precedence);
       }
     } else {  
       JsVar *b = __jspeBinaryExpression(jspeUnaryExpression(),precedence);
       if (JSP_SHOULD_EXECUTE) {
         if (op==LEX_R_IN) {
           JsVar *av = jsvSkipName(a);  
           JsVar *bv = jsvSkipName(b);  
           if (jsvIsArray(bv) || jsvIsObject(bv)) {  
             av = jsvAsArrayIndexAndUnLock(av);
             JsVar *varFound = jspGetVarNamedField( bv, av, true);
             jsvUnLock(a);
             a = jsvNewFromBool(varFound!=0);
             jsvUnLock(varFound);
           } else { 
             jsExceptionHere(JSET_ERROR, ""Cannot use 'in' operator to search a %t"", bv);
             jsvUnLock(a);
             a = 0;
           }
           jsvUnLock2(av, bv);
         } else if (op==LEX_R_INSTANCEOF) {
           bool inst = false;
           JsVar *av = jsvSkipName(a);
           JsVar *bv = jsvSkipName(b);
           if (!jsvIsFunction(bv)) {
             jsExceptionHere(JSET_ERROR, ""Expecting a function on RHS in instanceof check, got %t"", bv);
           } else {
             if (jsvIsObject(av) || jsvIsFunction(av)) {
               JsVar *bproto = jspGetNamedField(bv, JSPARSE_PROTOTYPE_VAR, false);
               JsVar *proto = jsvObjectGetChild(av, JSPARSE_INHERITS_VAR, 0);
               while (proto) {
                 if (proto == bproto) inst=true;
                 JsVar *childProto = jsvObjectGetChild(proto, JSPARSE_INHERITS_VAR, 0);
                 jsvUnLock(proto);
                 proto = childProto;
               }
               if (jspIsConstructor(bv, ""Object"")) inst = true;
               jsvUnLock(bproto);
             }
             if (!inst) {
               const char *name = jswGetBasicObjectName(av);
               if (name) {
                 inst = jspIsConstructor(bv, name);
               }
               if (!inst && (jsvIsArray(av) || jsvIsArrayBuffer(av)) &&
                   jspIsConstructor(bv, ""Object""))
                 inst = true;
             }
           }
           jsvUnLock3(av, bv, a);
           a = jsvNewFromBool(inst);
         } else {   
           JsVar *res = jsvMathsOpSkipNames(a, b, op);
           jsvUnLock(a); a = res;
         }
       }
       jsvUnLock(b);
     }
     precedence = jspeGetBinaryExpressionPrecedence(lex->tk);
   }
   return a;
 }
 JsVar *jspeBinaryExpression() {
   return __jspeBinaryExpression(jspeUnaryExpression(),0);
 }
 NO_INLINE JsVar *__jspeConditionalExpression(JsVar *lhs) {
   if (lex->tk=='?') {
     JSP_ASSERT_MATCH('?');
     if (!JSP_SHOULD_EXECUTE) {
       jsvUnLock(jspeAssignmentExpression());
       JSP_MATCH(':');
       jsvUnLock(jspeAssignmentExpression());
     } else {
       bool first = jsvGetBoolAndUnLock(jsvSkipName(lhs));
       jsvUnLock(lhs);
       if (first) {
         lhs = jspeAssignmentExpression();
         JSP_MATCH(':');
         JSP_SAVE_EXECUTE();
         jspSetNoExecute();
         jsvUnLock(jspeAssignmentExpression());
         JSP_RESTORE_EXECUTE();
       } else {
         JSP_SAVE_EXECUTE();
         jspSetNoExecute();
         jsvUnLock(jspeAssignmentExpression());
         JSP_RESTORE_EXECUTE();
         JSP_MATCH(':');
         lhs = jspeAssignmentExpression();
       }
     }
   }
   return lhs;
 }
 JsVar *jspeConditionalExpression() {
   return __jspeConditionalExpression(jspeBinaryExpression());
 }
 NO_INLINE JsVar *__jspeAssignmentExpression(JsVar *lhs) {
   if (lex->tk=='=' || lex->tk==LEX_PLUSEQUAL || lex->tk==LEX_MINUSEQUAL ||
       lex->tk==LEX_MULEQUAL || lex->tk==LEX_DIVEQUAL || lex->tk==LEX_MODEQUAL ||
       lex->tk==LEX_ANDEQUAL || lex->tk==LEX_OREQUAL ||
       lex->tk==LEX_XOREQUAL || lex->tk==LEX_RSHIFTEQUAL ||
       lex->tk==LEX_LSHIFTEQUAL || lex->tk==LEX_RSHIFTUNSIGNEDEQUAL) {
     JsVar *rhs;
     int op = lex->tk;
     JSP_ASSERT_MATCH(op);
     rhs = jspeAssignmentExpression();
     rhs = jsvSkipNameAndUnLock(rhs);  
     if (JSP_SHOULD_EXECUTE && lhs) {
       if (op=='=') {
         if (!jsvGetRefs(lhs) && jsvIsName(lhs)) {
           if (!jsvIsArrayBufferName(lhs) && !jsvIsNewChild(lhs))
             jsvAddName(execInfo.root, lhs);
         }
         jspReplaceWith(lhs, rhs);
       } else {
         if (op==LEX_PLUSEQUAL) op='+';
         else if (op==LEX_MINUSEQUAL) op='-';
         else if (op==LEX_MULEQUAL) op='*';
         else if (op==LEX_DIVEQUAL) op='/';
         else if (op==LEX_MODEQUAL) op='%';
         else if (op==LEX_ANDEQUAL) op='&';
         else if (op==LEX_OREQUAL) op='|';
         else if (op==LEX_XOREQUAL) op='^';
         else if (op==LEX_RSHIFTEQUAL) op=LEX_RSHIFT;
         else if (op==LEX_LSHIFTEQUAL) op=LEX_LSHIFT;
         else if (op==LEX_RSHIFTUNSIGNEDEQUAL) op=LEX_RSHIFTUNSIGNED;
         if (op=='+' && jsvIsName(lhs)) {
           JsVar *currentValue = jsvSkipName(lhs);
           if (jsvIsString(currentValue) && !jsvIsFlatString(currentValue) && jsvGetRefs(currentValue)==1 && rhs!=currentValue) {
             JsVar *str = jsvAsString(rhs, false);
             jsvAppendStringVarComplete(currentValue, str);
             jsvUnLock(str);
             op = 0;
           }
           jsvUnLock(currentValue);
         }
         if (op) {
           JsVar *res = jsvMathsOpSkipNames(lhs,rhs,op);
           jspReplaceWith(lhs, res);
           jsvUnLock(res);
         }
       }
     }
     jsvUnLock(rhs);
   }
   return lhs;
 }
 JsVar *jspeAssignmentExpression() {
   return __jspeAssignmentExpression(jspeConditionalExpression());
 }
 NO_INLINE JsVar *jspeExpression() {
   while (!JSP_SHOULDNT_PARSE) {
     JsVar *a = jspeAssignmentExpression();
     if (lex->tk!=',') return a;
     jsvUnLock(a);
     JSP_ASSERT_MATCH(',');
   }
   return 0;
 }
 NO_INLINE void jspeBlockNoBrackets() {
   if (JSP_SHOULD_EXECUTE) {
     while (lex->tk && lex->tk!='}') {
       jsvUnLock(jspeStatement());
       if (JSP_HAS_ERROR) {
         if (lex && !(execInfo.execute&EXEC_ERROR_LINE_REPORTED)) {
           execInfo.execute = (JsExecFlags)(execInfo.execute | EXEC_ERROR_LINE_REPORTED);
           JsVar *stackTrace = jsvObjectGetChild(execInfo.hiddenRoot, JSPARSE_STACKTRACE_VAR, JSV_STRING_0);
           if (stackTrace) {
             jsvAppendPrintf(stackTrace, ""at "");
             jspAppendStackTrace(stackTrace);
             jsvUnLock(stackTrace);
           }
         }
       }
       if (JSP_SHOULDNT_PARSE)
         return;
     }
   } else {
     int brackets = 0;
     while (lex->tk && (brackets || lex->tk != '}')) {
       if (lex->tk == '{') brackets++;
       if (lex->tk == '}') brackets--;
       JSP_ASSERT_MATCH(lex->tk);
     }
   }",[138],Espruino before 1.99 allows attackers to cause a denial of service (application crash) with a user crafted input file via a Buffer Overflow during syntax parsing of *VOID* tokens in jsparse.c.,Espruino,CVE-2018-11594,CWE-119
6073,181924,"  static int mem_write(jas_stream_obj_t *obj, char *buf, int cnt)
  {
	int n;
 	size_t n;
  	int ret;
  	jas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;
	long newbufsize;
	long newpos;
 	size_t newbufsize;
 	size_t newpos;
  	assert(buf);
  	assert(cnt >= 0);
 	JAS_DBGLOG(100, (""mem_write(%p, %p, %d)\n"", obj, buf, cnt));
 	newpos = m->pos_ + cnt;
  	if (newpos > m->bufsize_ && m->growable_) {
  		newbufsize = m->bufsize_;
  		while (newbufsize < newpos) {
			newbufsize <<= 1;
			assert(newbufsize >= 0);
 			if (!jas_safe_size_mul(newbufsize, 2, &newbufsize)) {
 				JAS_DBGLOG(100, (""new buffer size would cause overflow\n""));
 				return -1;
 			}
  		}
		JAS_DBGLOG(100, (""mem_write resizing from %d to %z\n"", m->bufsize_,
 		JAS_DBGLOG(100, (""mem_write resizing from %d to %zu\n"", m->bufsize_,
  		  newbufsize));
		JAS_DBGLOG(100, (""mem_write resizing from %d to %ul\n"", m->bufsize_,
		  JAS_CAST(unsigned long, newbufsize)));
 		assert(newbufsize > 0);
  		if (mem_resize(m, newbufsize)) {
  			return -1;
  		}
 	}
 	if (m->pos_ > m->len_) {
 		n = JAS_MIN(m->pos_, m->bufsize_) - m->len_;
 		if (n > 0) {
 			memset(&m->buf_[m->len_], 0, n);
 			m->len_ += n;
 		}
 		if (m->pos_ != m->len_) {
 			return 0;
 		}
 	}
 	n = m->bufsize_ - m->pos_;
 	ret = JAS_MIN(n, cnt);
 	if (ret > 0) {
 		memcpy(&m->buf_[m->pos_], buf, ret);
 		m->pos_ += ret;
 	}
 	if (m->pos_ > m->len_) {
 		m->len_ = m->pos_;
 	}
 	assert(ret == cnt);
 	return ret;
 }","[3, 4, 7, 8, 9, 10, 18, 19, 20, 21, 22, 23, 25, 26, 28, 29, 30]","Multiple integer overflows in the (1) jas_realloc function in base/jas_malloc.c and (2) mem_resize function in base/jas_stream.c in JasPer before 1.900.22 allow remote attackers to cause a denial of service via a crafted image, which triggers use after free vulnerabilities.",jasper,CVE-2016-9262,CWE-190
6079,183241," sf_open_virtual	(SF_VIRTUAL_IO *sfvirtual, int mode, SF_INFO *sfinfo, void *user_data)
 {	SF_PRIVATE 	*psf ;
 	if (sfvirtual->get_filelen == NULL || sfvirtual->seek == NULL || sfvirtual->tell == NULL)
 	{	sf_errno = SFE_BAD_VIRTUAL_IO ;
 		snprintf (sf_parselog, sizeof (sf_parselog), ""Bad vio_get_filelen / vio_seek / vio_tell in SF_VIRTUAL_IO struct.\n"") ;
 		return NULL ;
 		} ;
 	if ((mode == SFM_READ || mode == SFM_RDWR) && sfvirtual->read == NULL)
 	{	sf_errno = SFE_BAD_VIRTUAL_IO ;
 		snprintf (sf_parselog, sizeof (sf_parselog), ""Bad vio_read in SF_VIRTUAL_IO struct.\n"") ;
 		return NULL ;
 		} ;
 	if ((mode == SFM_WRITE || mode == SFM_RDWR) && sfvirtual->write == NULL)
 	{	sf_errno = SFE_BAD_VIRTUAL_IO ;
 		snprintf (sf_parselog, sizeof (sf_parselog), ""Bad vio_write in SF_VIRTUAL_IO struct.\n"") ;
  		return NULL ;
  		} ;
	if ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)
 	if ((psf = psf_allocate ()) == NULL)
  	{	sf_errno = SFE_MALLOC_FAILED ;
  		return	NULL ;
  		} ;
 	psf_init_files (psf) ;
 	psf->virtual_io = SF_TRUE ;
 	psf->vio = *sfvirtual ;
 	psf->vio_user_data = user_data ;
 	psf->file.mode = mode ;
 	return psf_open_file (psf, sfinfo) ;
 }  ","[18, 19]","In libsndfile before 1.0.28, an error in the *header_read()* function (common.c) when handling ID3 tags can be exploited to cause a stack-based buffer overflow via a specially crafted FLAC file.",libsndfile,CVE-2017-7586,CWE-119
6081,180827," static void gmc_mmx(uint8_t *dst, uint8_t *src,
                     int stride, int h, int ox, int oy,
                     int dxx, int dxy, int dyx, int dyy,
                     int shift, int r, int width, int height)
 {
     const int w    = 8;
     const int ix   = ox  >> (16 + shift);
     const int iy   = oy  >> (16 + shift);
     const int oxs  = ox  >> 4;
     const int oys  = oy  >> 4;
     const int dxxs = dxx >> 4;
     const int dxys = dxy >> 4;
     const int dyxs = dyx >> 4;
     const int dyys = dyy >> 4;
     const uint16_t r4[4]   = { r, r, r, r };
     const uint16_t dxy4[4] = { dxys, dxys, dxys, dxys };
     const uint16_t dyy4[4] = { dyys, dyys, dyys, dyys };
     const uint64_t shift2  = 2 * shift;
 #define MAX_STRIDE 4096U
 #define MAX_H 8U
     uint8_t edge_buf[(MAX_H + 1) * MAX_STRIDE];
     int x, y;
     const int dxw = (dxx - (1 << (16 + shift))) * (w - 1);
      const int dyh = (dyy - (1 << (16 + shift))) * (h - 1);
      const int dxh = dxy * (h - 1);
      const int dyw = dyx * (w - 1);
    int need_emu  =  (unsigned) ix >= width  - w ||
                     (unsigned) iy >= height - h;
     int need_emu  =  (unsigned) ix >= width  - w || width < w ||
                      (unsigned) iy >= height - h || height< h
                      ;
      if (  
          ((ox ^ (ox + dxw)) | (ox ^ (ox + dxh)) | (ox ^ (ox + dxw + dxh)) |
          (oy ^ (oy + dyw)) | (oy ^ (oy + dyh)) | (oy ^ (oy + dyw + dyh))) >> (16 + shift) ||
         (dxx | dxy | dyx | dyy) & 15 ||
         (need_emu && (h > MAX_H || stride > MAX_STRIDE))) {
         ff_gmc_c(dst, src, stride, h, ox, oy, dxx, dxy, dyx, dyy,
                  shift, r, width, height);
         return;
     }
     src += ix + iy * stride;
     if (need_emu) {
         ff_emulated_edge_mc_8(edge_buf, src, stride, stride, w + 1, h + 1, ix, iy, width, height);
         src = edge_buf;
     }
     __asm__ volatile (
         ""movd         %0, %%mm6         \n\t""
         ""pxor      %%mm7, %%mm7         \n\t""
         ""punpcklwd %%mm6, %%mm6         \n\t""
         ""punpcklwd %%mm6, %%mm6         \n\t""
         :: ""r"" (1 << shift));
     for (x = 0; x < w; x += 4) {
         uint16_t dx4[4] = { oxs - dxys + dxxs * (x + 0),
                             oxs - dxys + dxxs * (x + 1),
                             oxs - dxys + dxxs * (x + 2),
                             oxs - dxys + dxxs * (x + 3) };
         uint16_t dy4[4] = { oys - dyys + dyxs * (x + 0),
                             oys - dyys + dyxs * (x + 1),
                             oys - dyys + dyxs * (x + 2),
                             oys - dyys + dyxs * (x + 3) };
         for (y = 0; y < h; y++) {
             __asm__ volatile (
                 ""movq      %0, %%mm4    \n\t""
                 ""movq      %1, %%mm5    \n\t""
                 ""paddw     %2, %%mm4    \n\t""
                 ""paddw     %3, %%mm5    \n\t""
                 ""movq   %%mm4, %0       \n\t""
                 ""movq   %%mm5, %1       \n\t""
                 ""psrlw    $12, %%mm4    \n\t""
                 ""psrlw    $12, %%mm5    \n\t""
                 : ""+m"" (*dx4), ""+m"" (*dy4)
                 : ""m"" (*dxy4), ""m"" (*dyy4));
             __asm__ volatile (
                 ""movq      %%mm6, %%mm2 \n\t""
                 ""movq      %%mm6, %%mm1 \n\t""
                 ""psubw     %%mm4, %%mm2 \n\t""
                 ""psubw     %%mm5, %%mm1 \n\t""
                 ""movq      %%mm2, %%mm0 \n\t""
                 ""movq      %%mm4, %%mm3 \n\t""
                 ""pmullw    %%mm1, %%mm0 \n\t""  
                 ""pmullw    %%mm5, %%mm3 \n\t""  
                 ""pmullw    %%mm5, %%mm2 \n\t""  
                 ""pmullw    %%mm4, %%mm1 \n\t""  
                 ""movd         %4, %%mm5 \n\t""
                 ""movd         %3, %%mm4 \n\t""
                 ""punpcklbw %%mm7, %%mm5 \n\t""
                 ""punpcklbw %%mm7, %%mm4 \n\t""
                 ""pmullw    %%mm5, %%mm3 \n\t""  
                 ""pmullw    %%mm4, %%mm2 \n\t""  
                 ""movd         %2, %%mm5 \n\t""
                 ""movd         %1, %%mm4 \n\t""
                 ""punpcklbw %%mm7, %%mm5 \n\t""
                 ""punpcklbw %%mm7, %%mm4 \n\t""
                 ""pmullw    %%mm5, %%mm1 \n\t""  
                 ""pmullw    %%mm4, %%mm0 \n\t""  
                 ""paddw        %5, %%mm1 \n\t""
                 ""paddw     %%mm3, %%mm2 \n\t""
                 ""paddw     %%mm1, %%mm0 \n\t""
                 ""paddw     %%mm2, %%mm0 \n\t""
                 ""psrlw        %6, %%mm0 \n\t""
                 ""packuswb  %%mm0, %%mm0 \n\t""
                 ""movd      %%mm0, %0    \n\t""
                 : ""=m"" (dst[x + y * stride])
                 : ""m"" (src[0]), ""m"" (src[1]),
                   ""m"" (src[stride]), ""m"" (src[stride + 1]),
                   ""m"" (*r4), ""m"" (shift2));
             src += stride;
         }
         src += 4 - h * stride;
     }
 }","[27, 28, 29, 30, 31]","The gmc_mmx function in libavcodec/x86/mpegvideodsp.c in FFmpeg 3.4 does not properly validate widths and heights, which allows remote attackers to cause a denial of service (integer signedness error and out-of-array read) via a crafted MPEG file.",FFmpeg,CVE-2017-17081,CWE-125
6083,178126," int vrend_create_vertex_elements_state(struct vrend_context *ctx,
                                        uint32_t handle,
                                        unsigned num_elements,
                                        const struct pipe_vertex_element *elements)
 {
    struct vrend_vertex_element_array *v = CALLOC_STRUCT(vrend_vertex_element_array);
    const struct util_format_description *desc;
    GLenum type;
    int i;
    uint32_t ret_handle;
     if (!v)
        return ENOMEM;
    if (num_elements > PIPE_MAX_ATTRIBS)
       return EINVAL;
     v->count = num_elements;
     for (i = 0; i < num_elements; i++) {
        memcpy(&v->elements[i].base, &elements[i], sizeof(struct pipe_vertex_element));
          FREE(v);
          return EINVAL;
       }
       type = GL_FALSE;
       if (desc->channel[0].type == UTIL_FORMAT_TYPE_FLOAT) {
          if (desc->channel[0].size == 32)
             type = GL_FLOAT;
          else if (desc->channel[0].size == 64)
             type = GL_DOUBLE;
          else if (desc->channel[0].size == 16)
             type = GL_HALF_FLOAT;
       } else if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED &&
                  desc->channel[0].size == 8)
          type = GL_UNSIGNED_BYTE;
       else if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED &&
                desc->channel[0].size == 8)
          type = GL_BYTE;
       else if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED &&
                desc->channel[0].size == 16)
          type = GL_UNSIGNED_SHORT;
       else if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED &&
                desc->channel[0].size == 16)
          type = GL_SHORT;
       else if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED &&
                desc->channel[0].size == 32)
          type = GL_UNSIGNED_INT;
       else if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED &&
                desc->channel[0].size == 32)
          type = GL_INT;
       else if (elements[i].src_format == PIPE_FORMAT_R10G10B10A2_SSCALED ||
                elements[i].src_format == PIPE_FORMAT_R10G10B10A2_SNORM ||
                elements[i].src_format == PIPE_FORMAT_B10G10R10A2_SNORM)
          type = GL_INT_2_10_10_10_REV;
       else if (elements[i].src_format == PIPE_FORMAT_R10G10B10A2_USCALED ||
                elements[i].src_format == PIPE_FORMAT_R10G10B10A2_UNORM ||
                elements[i].src_format == PIPE_FORMAT_B10G10R10A2_UNORM)
          type = GL_UNSIGNED_INT_2_10_10_10_REV;
       else if (elements[i].src_format == PIPE_FORMAT_R11G11B10_FLOAT)
          type = GL_UNSIGNED_INT_10F_11F_11F_REV;
       if (type == GL_FALSE) {
          report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_VERTEX_FORMAT, elements[i].src_format);
          FREE(v);
          return EINVAL;
       }
       v->elements[i].type = type;
       if (desc->channel[0].normalized)
          v->elements[i].norm = GL_TRUE;
       if (desc->nr_channels == 4 && desc->swizzle[0] == UTIL_FORMAT_SWIZZLE_Z)
          v->elements[i].nr_chan = GL_BGRA;
       else if (elements[i].src_format == PIPE_FORMAT_R11G11B10_FLOAT)
          v->elements[i].nr_chan = 3;
       else
          v->elements[i].nr_chan = desc->nr_channels;
    }","[13, 14]",Heap-based buffer overflow in the vrend_create_vertex_elements_state function in vrend_renderer.c in virglrenderer before 0.6.0 allows local guest OS users to cause a denial of service (out-of-bounds array access and crash) via the num_elements parameter.,virglrenderer,CVE-2017-5994,CWE-119
6090,181863," static inline long decode_twos_comp(ulong c, int prec)
 static inline long decode_twos_comp(jas_ulong c, int prec)
  {
  	long result;
  	assert(prec >= 2);
 	jas_eprintf(""warning: support for signed data is untested\n"");
 	result = (c & ((1 << (prec - 1)) - 1)) - (c & (1 << (prec - 1)));
  	return result;
  }",[2],Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
6107,178052," void CtcpHandler::handleVersion(CtcpType ctcptype, const QString &prefix, const QString &target, const QString &param) {
 void CtcpHandler::handleVersion(CtcpType ctcptype, const QString &prefix, const QString &target, const QString &param, QString &reply) {
    Q_UNUSED(target)
    if(ctcptype == CtcpQuery) {
    if(_ignoreListManager->ctcpMatch(prefix, network()->networkName(), ""VERSION""))
      return;
    reply(nickFromMask(prefix), ""VERSION"", QString(""Quassel IRC %1 (built on %2) -- http:www.quassel-irc.org"")
          .arg(Quassel::buildInfo().plainVersionString)
          .arg(Quassel::buildInfo().buildDate));
     reply = QString(""Quassel IRC %1 (built on %2) -- http:www.quassel-irc.org"").arg(Quassel::buildInfo().plainVersionString).arg(Quassel::buildInfo().buildDate);
      emit displayMsg(Message::Server, BufferInfo::StatusBuffer, """", tr(""Received CTCP VERSION request by %1"").arg(prefix));
    } else {
       str.append(tr("" with arguments: %1"").arg(param));
     emit displayMsg(Message::Error, BufferInfo::StatusBuffer, """", str);
    }
  }","[2, 5, 6, 7, 8, 9, 10]",ctcphandler.cpp in Quassel before 0.6.3 and 0.7.x before 0.7.1 allows remote attackers to cause a denial of service (unresponsive IRC) via multiple Client-To-Client Protocol (CTCP) requests in a PRIVMSG message.,quassel,CVE-2010-3443,CWE-399
6120,182238," static int itacns_add_data_files(sc_pkcs15_card_t *p15card)
 {
 	const size_t array_size =
 		sizeof(itacns_data_files)/sizeof(itacns_data_files[0]);
 	unsigned int i;
 	int rv;
 	sc_pkcs15_data_t *p15_personaldata = NULL;
 	sc_pkcs15_data_info_t dinfo;
 	struct sc_pkcs15_object *objs[32];
 	struct sc_pkcs15_data_info *cinfo;
 	for(i=0; i < array_size; i++) {
 		sc_path_t path;
 		sc_pkcs15_data_info_t data;
 		sc_pkcs15_object_t    obj;
 		if (itacns_data_files[i].cie_only &&
 			p15card->card->type != SC_CARD_TYPE_ITACNS_CIE_V2)
 			continue;
 		sc_format_path(itacns_data_files[i].path, &path);
 		memset(&data, 0, sizeof(data));
 		memset(&obj, 0, sizeof(obj));
 		strlcpy(data.app_label, itacns_data_files[i].label,
 			sizeof(data.app_label));
 		strlcpy(obj.label, itacns_data_files[i].label,
 			sizeof(obj.label));
 		data.path = path;
 		rv = sc_pkcs15emu_add_data_object(p15card, &obj, &data);
 		SC_TEST_RET(p15card->card->ctx, SC_LOG_DEBUG_NORMAL, rv,
 			""Could not add data file"");
 	}
 	memset(&dinfo, 0, sizeof(dinfo));
 	strcpy(dinfo.app_label, ""EF_DatiPersonali"");
 	rv = sc_pkcs15_get_objects(p15card, SC_PKCS15_TYPE_DATA_OBJECT,
 		objs, 32);
 	if(rv < 0) {
 		sc_debug(p15card->card->ctx, SC_LOG_DEBUG_NORMAL,
 			""Data enumeration failed"");
 		return SC_SUCCESS;
 	}
 	for(i=0; i<32; i++) {
 		cinfo = (struct sc_pkcs15_data_info *) objs[i]->data;
 		if(!strcmp(""EF_DatiPersonali"", objs[i]->label))
 			break;
 	}
 	if(i>=32) {
 		sc_debug(p15card->card->ctx, SC_LOG_DEBUG_NORMAL,
 			""Could not find EF_DatiPersonali: ""
 			""keeping generic card name"");
 		return SC_SUCCESS;
 	}
 	rv = sc_pkcs15_read_data_object(p15card, cinfo, &p15_personaldata);
 	if (rv) {
  		sc_debug(p15card->card->ctx, SC_LOG_DEBUG_NORMAL,
  			""Could not read EF_DatiPersonali: ""
  			""keeping generic card name"");
 		return SC_SUCCESS;
  	}
  	{
 		char fullname[160];
 		if(get_name_from_EF_DatiPersonali(p15_personaldata->data,
 			fullname, sizeof(fullname))) {
 			sc_debug(p15card->card->ctx, SC_LOG_DEBUG_NORMAL,
 				""Could not parse EF_DatiPersonali: ""
 				""keeping generic card name"");
 			sc_pkcs15_free_data_object(p15_personaldata);
 			return SC_SUCCESS;
 		}
 		set_string(&p15card->tokeninfo->label, fullname);
 	}
 	sc_pkcs15_free_data_object(p15_personaldata);
 	return SC_SUCCESS;
 }",[55],Various out of bounds reads when handling responses in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to potentially crash the opensc library using programs.,OpenSC,CVE-2018-16427,CWE-125
6123,183035," virDomainGetTime(virDomainPtr dom,
                  long long *seconds,
                  unsigned int *nseconds,
                  unsigned int flags)
 {
     VIR_DOMAIN_DEBUG(dom, ""seconds=%p, nseconds=%p, flags=%x"",
                      seconds, nseconds, flags);
      virResetLastError();
      virCheckDomainReturn(dom, -1);
     virCheckReadOnlyGoto(dom->conn->flags, error);
      if (dom->conn->driver->domainGetTime) {
          int ret = dom->conn->driver->domainGetTime(dom, seconds,
                                                    nseconds, flags);
         if (ret < 0)
             goto error;
         return ret;
     }
     virReportUnsupportedError();
  error:
     virDispatchError(dom->conn);
     return -1;
 }",[10],"libvirt-domain.c in libvirt before 1.3.1 supports virDomainGetTime API calls by guest agents with an RO connection, even though an RW connection was supposed to be required, a different vulnerability than CVE-2019-3886.",libvirt,CVE-2016-10746,CWE-254
6165,179569," hstore_from_arrays(PG_FUNCTION_ARGS)
 {
 	int32		buflen;
 	HStore	   *out;
 	Pairs	   *pairs;
 	Datum	   *key_datums;
 	bool	   *key_nulls;
 	int			key_count;
 	Datum	   *value_datums;
 	bool	   *value_nulls;
 	int			value_count;
 	ArrayType  *key_array;
 	ArrayType  *value_array;
 	int			i;
 	if (PG_ARGISNULL(0))
 		PG_RETURN_NULL();
 	key_array = PG_GETARG_ARRAYTYPE_P(0);
 	Assert(ARR_ELEMTYPE(key_array) == TEXTOID);
 	if (ARR_NDIM(key_array) > 1)
 		ereport(ERROR,
 				(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),
 				 errmsg(""wrong number of array subscripts"")));
 	deconstruct_array(key_array,
  					  TEXTOID, -1, false, 'i',
  					  &key_datums, &key_nulls, &key_count);
 	if (key_count > MaxAllocSize / sizeof(Pairs))
 		ereport(ERROR,
 				(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),
 			  errmsg(""number of pairs (%d) exceeds the maximum allowed (%d)"",
 					 key_count, (int) (MaxAllocSize / sizeof(Pairs)))));
  	if (PG_ARGISNULL(1))
 	{
 		value_array = NULL;
 		value_count = key_count;
 		value_datums = NULL;
 		value_nulls = NULL;
 	}
 	else
 	{
 		value_array = PG_GETARG_ARRAYTYPE_P(1);
 		Assert(ARR_ELEMTYPE(value_array) == TEXTOID);
 		if (ARR_NDIM(value_array) > 1)
 			ereport(ERROR,
 					(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),
 					 errmsg(""wrong number of array subscripts"")));
 		if ((ARR_NDIM(key_array) > 0 || ARR_NDIM(value_array) > 0) &&
 			(ARR_NDIM(key_array) != ARR_NDIM(value_array) ||
 			 ARR_DIMS(key_array)[0] != ARR_DIMS(value_array)[0] ||
 			 ARR_LBOUND(key_array)[0] != ARR_LBOUND(value_array)[0]))
 			ereport(ERROR,
 					(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),
 					 errmsg(""arrays must have same bounds"")));
 		deconstruct_array(value_array,
 						  TEXTOID, -1, false, 'i',
 						  &value_datums, &value_nulls, &value_count);
 		Assert(key_count == value_count);
 	}
 	pairs = palloc(key_count * sizeof(Pairs));
 	for (i = 0; i < key_count; ++i)
 	{
 		if (key_nulls[i])
 			ereport(ERROR,
 					(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),
 					 errmsg(""null value not allowed for hstore key"")));
 		if (!value_nulls || value_nulls[i])
 		{
 			pairs[i].key = VARDATA_ANY(key_datums[i]);
 			pairs[i].val = NULL;
 			pairs[i].keylen = hstoreCheckKeyLen(VARSIZE_ANY_EXHDR(key_datums[i]));
 			pairs[i].vallen = 4;
 			pairs[i].isnull = true;
 			pairs[i].needfree = false;
 		}
 		else
 		{
 			pairs[i].key = VARDATA_ANY(key_datums[i]);
 			pairs[i].val = VARDATA_ANY(value_datums[i]);
 			pairs[i].keylen = hstoreCheckKeyLen(VARSIZE_ANY_EXHDR(key_datums[i]));
 			pairs[i].vallen = hstoreCheckValLen(VARSIZE_ANY_EXHDR(value_datums[i]));
 			pairs[i].isnull = false;
 			pairs[i].needfree = false;
 		}
 	}
 	key_count = hstoreUniquePairs(pairs, key_count, &buflen);
 	out = hstorePairs(pairs, key_count, buflen);
 	PG_RETURN_POINTER(out);
 }","[26, 27, 28, 29, 30]","Multiple integer overflows in contrib/hstore/hstore_io.c in PostgreSQL 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact via vectors related to the (1) hstore_recv, (2) hstore_from_arrays, and (3) hstore_from_array functions in contrib/hstore/hstore_io.c; and the (4) hstoreArrayToPairs function in contrib/hstore/hstore_op.c, which triggers a buffer overflow.  NOTE: this issue was SPLIT from CVE-2014-0064 because it has a different set of affected versions.",postgres,CVE-2014-2669,CWE-189
6170,182099," int ff_mms_asf_header_parser(MMSContext *mms)
 {
     uint8_t *p = mms->asf_header;
     uint8_t *end;
     int flags, stream_id;
     mms->stream_num = 0;
     if (mms->asf_header_size < sizeof(ff_asf_guid) * 2 + 22 ||
         memcmp(p, ff_asf_header, sizeof(ff_asf_guid))) {
         av_log(NULL, AV_LOG_ERROR,
                ""Corrupt stream (invalid ASF header, size=%d)\n"",
                mms->asf_header_size);
         return AVERROR_INVALIDDATA;
     }
     end = mms->asf_header + mms->asf_header_size;
     p += sizeof(ff_asf_guid) + 14;
     while(end - p >= sizeof(ff_asf_guid) + 8) {
         uint64_t chunksize;
         if (!memcmp(p, ff_asf_data_header, sizeof(ff_asf_guid))) {
             chunksize = 50;  
         } else {
             chunksize = AV_RL64(p + sizeof(ff_asf_guid));
         }
         if (!chunksize || chunksize > end - p) {
             av_log(NULL, AV_LOG_ERROR,
                    ""Corrupt stream (header chunksize %""PRId64"" is invalid)\n"",
                    chunksize);
             return AVERROR_INVALIDDATA;
         }
         if (!memcmp(p, ff_asf_file_header, sizeof(ff_asf_guid))) {
             if (end - p > sizeof(ff_asf_guid) * 2 + 68) {
                 mms->asf_packet_len = AV_RL32(p + sizeof(ff_asf_guid) * 2 + 64);
                 if (mms->asf_packet_len <= 0 || mms->asf_packet_len > sizeof(mms->in_buffer)) {
                     av_log(NULL, AV_LOG_ERROR,
                            ""Corrupt stream (too large pkt_len %d)\n"",
                            mms->asf_packet_len);
                     return AVERROR_INVALIDDATA;
                  }
              }
          } else if (!memcmp(p, ff_asf_stream_header, sizeof(ff_asf_guid))) {
            flags     = AV_RL16(p + sizeof(ff_asf_guid)*3 + 24);
            stream_id = flags & 0x7F;
            if (mms->stream_num < MMS_MAX_STREAMS &&
                    46 + mms->stream_num * 6 < sizeof(mms->out_buffer)) {
                mms->streams = av_fast_realloc(mms->streams,
                                   &mms->nb_streams_allocated,
                                   (mms->stream_num + 1) * sizeof(MMSStream));
                if (!mms->streams)
                    return AVERROR(ENOMEM);
                mms->streams[mms->stream_num].id = stream_id;
                mms->stream_num++;
            } else {
                av_log(NULL, AV_LOG_ERROR,
                       ""Corrupt stream (too many A/V streams)\n"");
                return AVERROR_INVALIDDATA;
             if (end - p >= (sizeof(ff_asf_guid) * 3 + 26)) {
                 flags     = AV_RL16(p + sizeof(ff_asf_guid)*3 + 24);
                 stream_id = flags & 0x7F;
                 if (mms->stream_num < MMS_MAX_STREAMS &&
                         46 + mms->stream_num * 6 < sizeof(mms->out_buffer)) {
                     mms->streams = av_fast_realloc(mms->streams,
                                        &mms->nb_streams_allocated,
                                        (mms->stream_num + 1) * sizeof(MMSStream));
                     if (!mms->streams)
                         return AVERROR(ENOMEM);
                     mms->streams[mms->stream_num].id = stream_id;
                     mms->stream_num++;
                 } else {
                     av_log(NULL, AV_LOG_ERROR,
                            ""Corrupt stream (too many A/V streams)\n"");
                     return AVERROR_INVALIDDATA;
                 }
              }
          } else if (!memcmp(p, ff_asf_ext_stream_header, sizeof(ff_asf_guid))) {
              if (end - p >= 88) {
                 int stream_count = AV_RL16(p + 84), ext_len_count = AV_RL16(p + 86);
                 uint64_t skip_bytes = 88;
                 while (stream_count--) {
                     if (end - p < skip_bytes + 4) {
                         av_log(NULL, AV_LOG_ERROR,
                                ""Corrupt stream (next stream name length is not in the buffer)\n"");
                         return AVERROR_INVALIDDATA;
                     }
                     skip_bytes += 4 + AV_RL16(p + skip_bytes + 2);
                 }
                 while (ext_len_count--) {
                     if (end - p < skip_bytes + 22) {
                         av_log(NULL, AV_LOG_ERROR,
                                ""Corrupt stream (next extension system info length is not in the buffer)\n"");
                         return AVERROR_INVALIDDATA;
                     }
                     skip_bytes += 22 + AV_RL32(p + skip_bytes + 18);
                 }
                 if (end - p < skip_bytes) {
                     av_log(NULL, AV_LOG_ERROR,
                            ""Corrupt stream (the last extension system info length is invalid)\n"");
                     return AVERROR_INVALIDDATA;
                 }
                 if (chunksize - skip_bytes > 24)
                     chunksize = skip_bytes;
              }
          } else if (!memcmp(p, ff_asf_head1_guid, sizeof(ff_asf_guid))) {
              chunksize = 46;  
             if (chunksize > end - p) {
                 av_log(NULL, AV_LOG_ERROR,
                     ""Corrupt stream (header chunksize %""PRId64"" is invalid)\n"",
                     chunksize);
                 return AVERROR_INVALIDDATA;
             }
          }
          p += chunksize;
      }
     return 0;
 }","[40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 103, 104, 105, 106, 107, 108]",FFmpeg before commit cced03dd667a5df6df8fd40d8de0bff477ee02e8 contains multiple out of array access vulnerabilities in the mms protocol that can result in attackers accessing out of bound data. This attack appear to be exploitable via network connectivity. This vulnerability appears to have been fixed in cced03dd667a5df6df8fd40d8de0bff477ee02e8 and later.,FFmpeg,CVE-2018-1999010,CWE-125
6183,182100," _warc_read(struct archive_read *a, const void **buf, size_t *bsz, int64_t *off)
 {
 	struct warc_s *w = a->format->data;
 	const char *rab;
 	ssize_t nrd;
 	if (w->cntoff >= w->cntlen) {
 	eof:
 		*buf = NULL;
 		*bsz = 0U;
 		*off = w->cntoff + 4U ;
 		w->unconsumed = 0U;
  		return (ARCHIVE_EOF);
  	}
 	if (w->unconsumed) {
 		__archive_read_consume(a, w->unconsumed);
 		w->unconsumed = 0U;
 	}
  	rab = __archive_read_ahead(a, 1U, &nrd);
  	if (nrd < 0) {
  		*bsz = 0U;
 		return (int)nrd;
 	} else if (nrd == 0) {
 		goto eof;
 	} else if ((size_t)nrd > w->cntlen - w->cntoff) {
 		nrd = w->cntlen - w->cntoff;
 	}
 	*off = w->cntoff;
 	*bsz = nrd;
 	*buf = rab;
 	w->cntoff += nrd;
 	w->unconsumed = (size_t)nrd;
 	return (ARCHIVE_OK);
 }","[14, 15, 16, 17]","libarchive version commit 9693801580c0cf7c70e862d305270a16b52826a7 onwards (release v3.2.0 onwards) contains a CWE-20: Improper Input Validation vulnerability in WARC parser - libarchive/archive_read_support_format_warc.c, _warc_read() that can result in DoS - quasi-infinite run time and disk usage from tiny file. This attack appear to be exploitable via the victim must open a specially crafted WARC file.",libarchive,CVE-2018-1000880,CWE-415
6206,182390," size_t jsuGetFreeStack() {
 #ifdef ARM
   void *frame = __builtin_frame_address(0);
   size_t stackPos = (size_t)((char*)frame);
   size_t stackEnd = (size_t)((char*)&LINKER_END_VAR);
   if (stackPos < stackEnd) return 0;  
   return  stackPos - stackEnd;
 #elif defined(LINUX)
    char ptr;  
    extern void *STACK_BASE;
    uint32_t count =  (uint32_t)((size_t)STACK_BASE - (size_t)&ptr);
  return 1000000 - count;  
   const uint32_t max_stack = 1000000;  
   if (count>max_stack) return 0;
   return max_stack - count;
  #else
    return 1000000;  
 #endif
 }","[12, 13, 14, 15]",Espruino before 1.99 allows attackers to cause a denial of service (application crash) with a user crafted input file via an integer overflow during syntax parsing. This was addressed by fixing stack size detection on Linux in jsutils.c.,Espruino,CVE-2018-11590,CWE-190
6207,182752," void * adminchild(struct clientparam* param) {
  int i, res;
  char * buf;
  char username[256];
   char *sb;
   char *req = NULL;
   struct printparam pp;
 int contentlen = 0;
  unsigned contentlen = 0;
   int isform = 0;
   pp.inbuf = 0;
  pp.cp = param;
  buf = myalloc(LINESIZE);
  if(!buf) {RETURN(555);}
  i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, LINESIZE - 1, '\n', conf.timeouts[STRING_S]);
  if(i<5 || ((buf[0]!='G' || buf[1]!='E' || buf[2]!='T' || buf[3]!=' ' || buf[4]!='/') && 
 	   (buf[0]!='P' || buf[1]!='O' || buf[2]!='S' || buf[3]!='T' || buf[4]!=' ' || buf[5]!='/')))
  {
 	RETURN(701);
  }
  buf[i] = 0;
  sb = strchr(buf+5, ' ');
  if(!sb){
 	RETURN(702);
  }
  *sb = 0;
  req = mystrdup(buf + ((*buf == 'P')? 6 : 5));
  while((i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, LINESIZE - 1, '\n', conf.timeouts[STRING_S])) > 2){
 	buf[i] = 0;
 	if(i > 19 && (!strncasecmp(buf, ""authorization"", 13))){
 		sb = strchr(buf, ':');
 		if(!sb)continue;
 		++sb;
 		while(isspace(*sb))sb++;
 		if(!*sb || strncasecmp(sb, ""basic"", 5)){
 			continue;
 		}
 		sb+=5;
 		while(isspace(*sb))sb++;
 		i = de64((unsigned char *)sb, (unsigned char *)username, 255);
 		if(i<=0)continue;
 		username[i] = 0;
 		sb = strchr((char *)username, ':');
 		if(sb){
 			*sb = 0;
 			if(param->password)myfree(param->password);
 			param->password = (unsigned char *)mystrdup(sb+1);
 		}
 		if(param->username) myfree(param->username);
 		param->username = (unsigned char *)mystrdup(username);
 		continue;
 	}
  	else if(i > 15 && (!strncasecmp(buf, ""content-length:"", 15))){
  		sb = buf + 15;
  		while(isspace(*sb))sb++;
		contentlen = atoi(sb);
 		sscanf(sb, ""%u"", &contentlen);
 		if(contentlen > LINESIZE*1024) contentlen = 0;
  	}
  	else if(i > 13 && (!strncasecmp(buf, ""content-type:"", 13))){
  		sb = buf + 13;
 		while(isspace(*sb))sb++;
 		if(!strncasecmp(sb, ""x-www-form-urlencoded"", 21)) isform = 1;
 	}
  }
  param->operation = ADMIN;
  if(isform && contentlen) {
 	printstr(&pp, ""HTTP/1.0 100 Continue\r\n\r\n"");
 	stdpr(&pp, NULL, 0);
  }
  res = (*param->srv->authfunc)(param);
  if(res && res != 10) {
 	printstr(&pp, authreq);
 	RETURN(res);
  }
  if(param->srv->singlepacket || param->redirected){
 	if(*req == 'C') req[1] = 0;
 	else *req = 0;
  }
  sprintf(buf, ok, conf.stringtable?(char *)conf.stringtable[2]:""3proxy"", conf.stringtable?(char *)conf.stringtable[2]:""3[APA3A] tiny proxy"", conf.stringtable?(char *)conf.stringtable[3]:"""");
  if(*req != 'S') printstr(&pp, buf);
  switch(*req){
 	case 'C':
 		printstr(&pp, counters);
 		{
 			struct trafcount *cp; 
 			int num = 0;
 			for(cp = conf.trafcounter; cp; cp = cp->next, num++){
 			 int inbuf = 0;
 			 if(cp->ace && (param->srv->singlepacket || param->redirected)){
 				if(!ACLmatches(cp->ace, param))continue;
 			 }
 			 if(req[1] == 'S' && atoi(req+2) == num) cp->disabled=0;
 			 if(req[1] == 'D' && atoi(req+2) == num) cp->disabled=1;
 			 inbuf += sprintf(buf,	""<tr>""
 						""<td>%s</td><td><A HREF=\'/C%c%d\'>%s</A></td><td>"",
 						(cp->comment)?cp->comment:""&nbsp;"",
 						(cp->disabled)?'S':'D',
 						num,
 						(cp->disabled)?""NO"":""YES""
 					);
 			 if(!cp->ace || !cp->ace->users){
 				inbuf += sprintf(buf+inbuf, ""<center>ANY</center>"");
 			 }
 			 else {
 				inbuf += printuserlist(buf+inbuf, LINESIZE-800, cp->ace->users, "",<br />\r\n"");
 			 }
 			 inbuf += sprintf(buf+inbuf, ""</td><td>"");
 			 if(!cp->ace || !cp->ace->src){
 				inbuf += sprintf(buf+inbuf, ""<center>ANY</center>"");
 			 }
 			 else {
 				inbuf += printiplist(buf+inbuf, LINESIZE-512, cp->ace->src, "",<br />\r\n"");
 			 }
 			 inbuf += sprintf(buf+inbuf, ""</td><td>"");
 			 if(!cp->ace || !cp->ace->dst){
 				inbuf += sprintf(buf+inbuf, ""<center>ANY</center>"");
 			 }
 			 else {
 				inbuf += printiplist(buf+inbuf, LINESIZE-512, cp->ace->dst, "",<br />\r\n"");
 			 }
 			 inbuf += sprintf(buf+inbuf, ""</td><td>"");
 			 if(!cp->ace || !cp->ace->ports){
 				inbuf += sprintf(buf+inbuf, ""<center>ANY</center>"");
 			 }
 			 else {
 				inbuf += printportlist(buf+inbuf, LINESIZE-128, cp->ace->ports, "",<br />\r\n"");
 			 }
 			 if(cp->type == NONE) {
 			  inbuf += sprintf(buf+inbuf,	
 					""</td><td colspan=\'6\' align=\'center\'>exclude from limitation</td></tr>\r\n""
 				 );
 			 }
 			 else {
 			  inbuf += sprintf(buf+inbuf,	
 					""</td><td>%""PRINTF_INT64_MODIFIER""u</td>""
 					""<td>MB%s</td>""
 					""<td>%""PRINTF_INT64_MODIFIER""u</td>""
 					""<td>%s</td>"",
 				 cp->traflim64 / (1024 * 1024),
 				 rotations[cp->type],
 				 cp->traf64,
 				 cp->cleared?ctime(&cp->cleared):""never""
 				);
 			 inbuf += sprintf(buf + inbuf,
 					""<td>%s</td>""
 					""<td>%i</td>""
 					""</tr>\r\n"",
 				 cp->updated?ctime(&cp->updated):""never"",
 				 cp->number
 				);
 			 }
 			 printstr(&pp, buf);
 			}
 		}
 		printstr(&pp, counterstail);
 		break;
 	case 'R':
 		conf.needreload = 1;
 		printstr(&pp, ""<h3>Reload scheduled</h3>"");
 		break;
 	case 'S':
 		{
 			if(req[1] == 'X'){
 				printstr(&pp, style);
 				break;
 			}
 			printstr(&pp, xml);
 			printval(conf.services, TYPE_SERVER, 0, &pp);
 			printstr(&pp, postxml);
 		}
 			break;
 	case 'F':
 		{
 			FILE *fp;
 			char buf[256];
 			fp = confopen();
 			if(!fp){
 				printstr(&pp, ""<h3><font color=\""red\"">Failed to open config file</font></h3>"");
  				break;
  			}
  				printstr(&pp, ""<h3>Please be careful editing config file remotely</h3>"");
				printstr(&pp, ""<form method=\""POST\"" action=\""/U\""><textarea cols=\""80\"" rows=\""30\"" name=\""conffile\"">"");
 				printstr(&pp, ""<form method=\""POST\"" action=\""/U\"" enctype=\""application/x-www-form-urlencoded\""><textarea cols=\""80\"" rows=\""30\"" name=\""conffile\"">"");
  				while(fgets(buf, 256, fp)){
  					printstr(&pp, buf);
  				}
 				if(!writable) fclose(fp);
 				printstr(&pp, ""</textarea><br><input type=\""Submit\""></form>"");
 			break;
  		}
  	case 'U':
  		{
			int l=0;
 			unsigned l=0;
  			int error = 0;
			if(!writable || fseek(writable, 0, 0)){
 			if(!writable || !contentlen || fseek(writable, 0, 0)){
  				error = 1;
  			}
			while((i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, LINESIZE - 1, '+', conf.timeouts[STRING_S])) > 0){
 			while(l < contentlen && (i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, (contentlen - l) > LINESIZE - 1?LINESIZE - 1:contentlen - l, '+', conf.timeouts[STRING_S])) > 0){
  				if(i > (contentlen - l)) i = (contentlen - l);
				buf[i] = 0;
  				if(!l){
					if(strncasecmp(buf, ""conffile="", 9)) error = 1;
 					if(i<9 || strncasecmp(buf, ""conffile="", 9)) error = 1;
  				}
  				if(!error){
 					buf[i] = 0;
  					decodeurl((unsigned char *)buf, 1);
  					fprintf(writable, ""%s"", l? buf : buf + 9);
  				}
  				l += i;
				if(l >= contentlen) break;
  			}
  			if(writable && !error){
  				fflush(writable);
 #ifndef _WINCE
 				ftruncate(fileno(writable), ftell(writable));
 #endif
 			}
 			printstr(&pp, error?    ""<h3><font color=\""red\"">Config file is not writable</font></h3>Make sure you have \""writable\"" command in configuration file"":
 						""<h3>Configuration updated</h3>"");
 		}
 		break;
 	default:
 		printstr(&pp, (char *)conf.stringtable[WEBBANNERS]);
 		break;
  }
  if(*req != 'S') printstr(&pp, tail);
 CLEANRET:
  printstr(&pp, NULL);
  if(buf) myfree(buf);
  (*param->srv->logfunc)(param, (unsigned char *)req);
  if(req)myfree(req);
  freeparam(param);
  return (NULL);
 }","[8, 9, 56, 57, 58, 183, 184, 194, 195, 197, 198, 201, 202, 204, 206, 207, 210, 215]",webadmin.c in 3proxy before 0.8.13 has an out-of-bounds write in the admin interface.,3proxy,CVE-2019-14495,CWE-787
6216,183317," QualifyIpPacket(IPHeader *pIpHeader, ULONG len)
 QualifyIpPacket(IPHeader *pIpHeader, ULONG len, BOOLEAN verifyLength)
  {
      tTcpIpPacketParsingResult res;
      res.value = 0;
     if (len < 4)
     {
         res.ipStatus = ppresNotIP;
         return res;
     }
     UCHAR  ver_len = pIpHeader->v4.ip_verlen;
     UCHAR  ip_version = (ver_len & 0xF0) >> 4;
     USHORT ipHeaderSize = 0;
     USHORT fullLength = 0;
     res.value = 0;
     if (ip_version == 4)
     {
         if (len < sizeof(IPv4Header))
         {
             res.ipStatus = ppresNotIP;
             return res;
         }
         ipHeaderSize = (ver_len & 0xF) << 2;
         fullLength = swap_short(pIpHeader->v4.ip_length);
         DPrintf(3, (""ip_version %d, ipHeaderSize %d, protocol %d, iplen %d, L2 payload length %d\n"",
             ip_version, ipHeaderSize, pIpHeader->v4.ip_protocol, fullLength, len));
         res.ipStatus = (ipHeaderSize >= sizeof(IPv4Header)) ? ppresIPV4 : ppresNotIP;
         if (res.ipStatus == ppresNotIP)
         {
              return res;
          }
        if (ipHeaderSize >= fullLength || len < fullLength)
         if (ipHeaderSize >= fullLength || ( verifyLength && len < fullLength))
          {
            DPrintf(2, (""[%s] - truncated packet - ip_version %d, ipHeaderSize %d, protocol %d, iplen %d, L2 payload length %d\n"", __FUNCTION__,
                ip_version, ipHeaderSize, pIpHeader->v4.ip_protocol, fullLength, len));
             DPrintf(2, (""[%s] - truncated packet - ip_version %d, ipHeaderSize %d, protocol %d, iplen %d, L2 payload length %d, verify = %s\n"", __FUNCTION__,
                 ip_version, ipHeaderSize, pIpHeader->v4.ip_protocol, fullLength, len, (verifyLength ? ""true"" : ""false"")));
              res.ipCheckSum = ppresIPTooShort;
              return res;
          }
     }
     else if (ip_version == 6)
     {
         if (len < sizeof(IPv6Header))
         {
             res.ipStatus = ppresNotIP;
             return res;
         }
         UCHAR nextHeader = pIpHeader->v6.ip6_next_header;
         BOOLEAN bParsingDone = FALSE;
         ipHeaderSize = sizeof(pIpHeader->v6);
         res.ipStatus = ppresIPV6;
          res.ipCheckSum = ppresCSOK;
          fullLength = swap_short(pIpHeader->v6.ip6_payload_len);
          fullLength += ipHeaderSize;
        if (len < fullLength)
         if (verifyLength && (len < fullLength))
          {
              res.ipStatus = ppresNotIP;
              return res;
         }
         while (nextHeader != 59)
         {
             IPv6ExtHeader *pExt;
             switch (nextHeader)
             {
                 case PROTOCOL_TCP:
                     bParsingDone = TRUE;
                     res.xxpStatus = ppresXxpKnown;
                     res.TcpUdp = ppresIsTCP;
                     res.xxpFull = len >= fullLength ? 1 : 0;
                     res = ProcessTCPHeader(res, pIpHeader, len, ipHeaderSize);
                     break;
                 case PROTOCOL_UDP:
                     bParsingDone = TRUE;
                     res.xxpStatus = ppresXxpKnown;
                     res.TcpUdp = ppresIsUDP;
                     res.xxpFull = len >= fullLength ? 1 : 0;
                     res = ProcessUDPHeader(res, pIpHeader, len, ipHeaderSize);
                     break;
                 case 0:
                 case 60:
                 case 43:
                 case 44:
                 case 51:
                 case 50:
                 case 135:
                     if (len >= ((ULONG)ipHeaderSize + 8))
                     {
                         pExt = (IPv6ExtHeader *)((PUCHAR)pIpHeader + ipHeaderSize);
                         nextHeader = pExt->ip6ext_next_header;
                         ipHeaderSize += 8;
                         ipHeaderSize += pExt->ip6ext_hdr_len * 8;
                     }
                     else
                     {
                         DPrintf(0, (""[%s] ERROR: Break in the middle of ext. headers(len %d, hdr > %d)\n"", __FUNCTION__, len, ipHeaderSize));
                         res.ipStatus = ppresNotIP;
                         bParsingDone = TRUE;
                     }
                     break;
                 default:
                     res.xxpStatus = ppresXxpOther;
                     bParsingDone = TRUE;
                     break;
             }
             if (bParsingDone)
                 break;
         }
         if (ipHeaderSize <= MAX_SUPPORTED_IPV6_HEADERS)
         {
             DPrintf(3, (""ip_version %d, ipHeaderSize %d, protocol %d, iplen %d\n"",
                 ip_version, ipHeaderSize, nextHeader, fullLength));
             res.ipHeaderSize = ipHeaderSize;
         }
         else
         {
             DPrintf(0, (""[%s] ERROR: IP chain is too large (%d)\n"", __FUNCTION__, ipHeaderSize));
             res.ipStatus = ppresNotIP;
         }
     }
     if (res.ipStatus == ppresIPV4)
     {
         res.ipHeaderSize = ipHeaderSize;
         res.IsFragment = (pIpHeader->v4.ip_offset & ~0xC0) != 0;
         switch (pIpHeader->v4.ip_protocol)
         {
             case PROTOCOL_TCP:
             {
                 res = ProcessTCPHeader(res, pIpHeader, len, ipHeaderSize);
             }
             break;
         case PROTOCOL_UDP:
             {
                 res = ProcessUDPHeader(res, pIpHeader, len, ipHeaderSize);
             }
             break;
         default:
             res.xxpStatus = ppresXxpOther;
             break;
         }
     }
     return res;
 }","[2, 32, 33, 35, 36, 37, 38, 57, 58]","The NetKVM Windows Virtio driver allows remote attackers to cause a denial of service (guest crash) via a crafted length value in an IP packet, as demonstrated by a value that does not account for the size of the IP options.",kvm-guest-drivers-windows,CVE-2015-3215,CWE-20
6226,181868," static int putint(jas_stream_t *out, int sgnd, int prec, long val)
 {
  	int n;
  	int c;
  	bool s;
	ulong tmp;
 	jas_ulong tmp;
  	assert((!sgnd && prec >= 1) || (sgnd && prec >= 2));
  	if (sgnd) {
  		val = encode_twos_comp(val, prec);
 	}
 	assert(val >= 0);
 	val &= (1 << prec) - 1;
 	n = (prec + 7) / 8;
 	while (--n >= 0) {
 		c = (val >> (n * 8)) & 0xff;
 		if (jas_stream_putc(out, c) != c)
 			return -1;
 	}
 	return 0;
 }","[6, 7]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
6242,182983," sec_recv(RD_BOOL * is_fastpath)
 {
 	uint8 fastpath_hdr, fastpath_flags;
  	uint16 sec_flags;
  	uint16 channel;
  	STREAM s;
 	struct stream packet;
  	while ((s = mcs_recv(&channel, is_fastpath, &fastpath_hdr)) != NULL)
  	{
 		packet = *s;
  		if (*is_fastpath == True)
  		{
  			fastpath_flags = (fastpath_hdr & 0xC0) >> 6;
  			if (fastpath_flags & FASTPATH_OUTPUT_ENCRYPTED)
  			{
 				if (!s_check_rem(s, 8)) {
 					rdp_protocol_error(""sec_recv(), consume fastpath signature from stream would overrun"", &packet);
 				}
  				in_uint8s(s, 8);	 
  				sec_decrypt(s->p, s->end - s->p);
  			}
 			return s;
 		}
 		if (g_encryption || (!g_licence_issued && !g_licence_error_result))
 		{
 			in_uint16_le(s, sec_flags);
 			in_uint8s(s, 2);	 
 			if (g_encryption)
  			{
  				if (sec_flags & SEC_ENCRYPT)
  				{
 					if (!s_check_rem(s, 8)) {
 						rdp_protocol_error(""sec_recv(), consume encrypt signature from stream would overrun"", &packet);
 					}
  					in_uint8s(s, 8);	 
  					sec_decrypt(s->p, s->end - s->p);
  				}
 				if (sec_flags & SEC_LICENSE_PKT)
 				{
 					licence_process(s);
 					continue;
 				}
 				if (sec_flags & SEC_REDIRECTION_PKT)
  				{
  					uint8 swapbyte;
 					if (!s_check_rem(s, 8)) {
 						rdp_protocol_error(""sec_recv(), consume redirect signature from stream would overrun"", &packet);
 					}
  					in_uint8s(s, 8);	 
  					sec_decrypt(s->p, s->end - s->p);
 					if (s->p[0] == 0 && s->p[1] == 4)
 					{
 						swapbyte = s->p[0];
 						s->p[0] = s->p[2];
 						s->p[2] = swapbyte;
 						swapbyte = s->p[1];
 						s->p[1] = s->p[3];
 						s->p[3] = swapbyte;
 						swapbyte = s->p[2];
 						s->p[2] = s->p[3];
 						s->p[3] = swapbyte;
 					}
 				}
 			}
 			else
 			{
 				if (sec_flags & SEC_LICENSE_PKT)
 				{
 					licence_process(s);
 					continue;
 				}
 				s->p -= 4;
 			}
 		}
 		if (channel != MCS_GLOBAL_CHANNEL)
 		{
 			channel_process(s, channel);
 			continue;
 		}
 		return s;
 	}
 	return NULL;
 }","[7, 10, 16, 17, 18, 32, 33, 34, 46, 47, 48]",rdesktop versions up to and including v1.8.3 contain a Buffer Overflow over the global variables in the function seamless_process_line() that results in memory corruption and probably even a remote code execution.,rdesktop,CVE-2018-20182,CWE-119
6245,179092," static int get_cox(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c)
 {
     uint8_t byte;
     if (bytestream2_get_bytes_left(&s->g) < 5)
         return AVERROR_INVALIDDATA;
     c->nreslevels = bytestream2_get_byteu(&s->g) + 1;
     if (c->nreslevels >= JPEG2000_MAX_RESLEVELS) {
         av_log(s->avctx, AV_LOG_ERROR, ""nreslevels %d is invalid\n"", c->nreslevels);
         return AVERROR_INVALIDDATA;
     }
     if (c->nreslevels < s->reduction_factor)
         c->nreslevels2decode = 1;
     else
         c->nreslevels2decode = c->nreslevels - s->reduction_factor;
     c->log2_cblk_width  = (bytestream2_get_byteu(&s->g) & 15) + 2;  
     c->log2_cblk_height = (bytestream2_get_byteu(&s->g) & 15) + 2;  
     if (c->log2_cblk_width > 10 || c->log2_cblk_height > 10 ||
         c->log2_cblk_width + c->log2_cblk_height > 12) {
         av_log(s->avctx, AV_LOG_ERROR, ""cblk size invalid\n"");
          return AVERROR_INVALIDDATA;
      }
     if (c->log2_cblk_width > 6 || c->log2_cblk_height > 6) {
         avpriv_request_sample(s->avctx, ""cblk size > 64"");
         return AVERROR_PATCHWELCOME;
     }
      c->cblk_style = bytestream2_get_byteu(&s->g);
      if (c->cblk_style != 0) {  
          av_log(s->avctx, AV_LOG_WARNING, ""extra cblk styles %X\n"", c->cblk_style);
     }
     c->transform = bytestream2_get_byteu(&s->g);  
     if ((s->avctx->flags & CODEC_FLAG_BITEXACT) && (c->transform == FF_DWT97))
         c->transform = FF_DWT97_INT;
     if (c->csty & JPEG2000_CSTY_PREC) {
         int i;
         for (i = 0; i < c->nreslevels; i++) {
             byte = bytestream2_get_byte(&s->g);
             c->log2_prec_widths[i]  =  byte       & 0x0F;     
             c->log2_prec_heights[i] = (byte >> 4) & 0x0F;     
         }
     } else {
         memset(c->log2_prec_widths , 15, sizeof(c->log2_prec_widths ));
         memset(c->log2_prec_heights, 15, sizeof(c->log2_prec_heights));
     }
     return 0;
 }","[22, 23, 24, 25]","libavcodec/jpeg2000dec.c in FFmpeg before 2.1 does not ensure the use of valid code-block dimension values, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted JPEG2000 data.",FFmpeg,CVE-2013-7018,CWE-119
6253,179636," DecodeNumberField(int len, char *str, int fmask,
 				  int *tmask, struct tm * tm, fsec_t *fsec, int *is2digits)
 {
 	char	   *cp;
  	if ((cp = strchr(str, '.')) != NULL)
  	{
  #ifdef HAVE_INT64_TIMESTAMP
		char		fstr[MAXDATELEN + 1];
 		char		fstr[7];
 		int			i;
 		cp++;
		strcpy(fstr, (cp + 1));
		strcpy(fstr + strlen(fstr), ""000000"");
		*(fstr + 6) = '\0';
 		for (i = 0; i < 6; i++)
 			fstr[i] = *cp != '\0' ? *cp++ : '0';
 		fstr[i] = '\0';
  		*fsec = strtol(fstr, NULL, 10);
  #else
  		*fsec = strtod(cp, NULL);
 #endif
 		*cp = '\0';
 		len = strlen(str);
 	}
 	else if ((fmask & DTK_DATE_M) != DTK_DATE_M)
 	{
 		if (len == 8)
 		{
 			*tmask = DTK_DATE_M;
 			tm->tm_mday = atoi(str + 6);
 			*(str + 6) = '\0';
 			tm->tm_mon = atoi(str + 4);
 			*(str + 4) = '\0';
 			tm->tm_year = atoi(str + 0);
 			return DTK_DATE;
 		}
 		else if (len == 6)
 		{
 			*tmask = DTK_DATE_M;
 			tm->tm_mday = atoi(str + 4);
 			*(str + 4) = '\0';
 			tm->tm_mon = atoi(str + 2);
 			*(str + 2) = '\0';
 			tm->tm_year = atoi(str + 0);
 			*is2digits = TRUE;
 			return DTK_DATE;
 		}
 		else if (len == 5)
 		{
 			*tmask = DTK_DATE_M;
 			tm->tm_mday = atoi(str + 2);
 			*(str + 2) = '\0';
 			tm->tm_mon = 1;
 			tm->tm_year = atoi(str + 0);
 			*is2digits = TRUE;
 			return DTK_DATE;
 		}
 	}
 	if ((fmask & DTK_TIME_M) != DTK_TIME_M)
 	{
 		if (len == 6)
 		{
 			*tmask = DTK_TIME_M;
 			tm->tm_sec = atoi(str + 4);
 			*(str + 4) = '\0';
 			tm->tm_min = atoi(str + 2);
 			*(str + 2) = '\0';
 			tm->tm_hour = atoi(str + 0);
 			return DTK_TIME;
 		}
 		else if (len == 4)
 		{
 			*tmask = DTK_TIME_M;
 			tm->tm_sec = 0;
 			tm->tm_min = atoi(str + 2);
 			*(str + 2) = '\0';
 			tm->tm_hour = atoi(str + 0);
 			return DTK_TIME;
 		}
 	}
 	return -1;
 }	 ","[8, 9, 10, 11, 12, 13, 14, 15, 16, 17]","Multiple stack-based buffer overflows in PostgreSQL before 8.4.20, 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to cause a denial of service (crash) or possibly execute arbitrary code via vectors related to an incorrect MAXDATELEN constant and datetime values involving (1) intervals, (2) timestamps, or (3) timezones, a different vulnerability than CVE-2014-0065.",postgres,CVE-2014-0063,CWE-119
6259,178303," SafeAlphaCompositeSolidMask_nx8x8888(
     CARD8      op,
     PicturePtr pSrc,
     PicturePtr pMask,
     PicturePtr pDst,
     INT16      xSrc,
     INT16      ySrc,
     INT16      xMask,
     INT16      yMask,
     INT16      xDst,
     INT16      yDst,
     CARD16     width,
     CARD16     height)
 {
     CARD32	src, srca;
     CARD32	*dstLine, *dst, d, dstMask;
     CARD8	*maskLine, *mask, m;
     FbStride	dstStride, maskStride;
     CARD16	w;
     fbComposeGetSolid(pSrc, src, pDst->format);
     dstMask = FbFullMask (pDst->pDrawable->depth);
     srca = src >> 24;
     if (src == 0)
 	return;
     fbComposeGetStart (pDst, xDst, yDst, CARD32, dstStride, dstLine, 1);
     fbComposeGetStart (pMask, xMask, yMask, CARD8, maskStride, maskLine, 1);
     if (dstMask == FB_ALLONES && pDst->pDrawable->bitsPerPixel == 32 &&
         width * height > rootless_CompositePixels_threshold &&
         SCREENREC(pDst->pDrawable->pScreen)->imp->CompositePixels)
     {
 	void *srcp[2], *destp[2];
 	unsigned int dest_rowbytes[2];
 	unsigned int fn;
 	srcp[0] = &src; srcp[1] = &src;
 	destp[0] = dstLine; destp[1] = dstLine;
 	dest_rowbytes[0] = dstStride * 4; dest_rowbytes[1] = dest_rowbytes[0];
 	fn = RL_COMPOSITE_FUNCTION(RL_COMPOSITE_OVER, RL_DEPTH_ARGB8888,
                                    RL_DEPTH_A8, RL_DEPTH_ARGB8888);
 	if (SCREENREC(pDst->pDrawable->pScreen)->imp->CompositePixels(
                 width, height, fn, srcp, NULL,
                 maskLine, maskStride,
                 destp, dest_rowbytes) == Success)
 	{
 	    return;
 	}
     }
     while (height--)
     {
 	dst = dstLine;
 	dstLine += dstStride;
 	mask = maskLine;
 	maskLine += maskStride;
 	w = width;
 	while (w--)
 	{
  }
  void
SafeAlphaComposite (CARD8      op,
    PicturePtr      pSrc,
    PicturePtr      pMask,
    PicturePtr      pDst,
    INT16           xSrc,
    INT16           ySrc,
    INT16           xMask,
    INT16           yMask,
    INT16           xDst,
    INT16           yDst,
    CARD16          width,
    CARD16          height)
 SafeAlphaComposite (CARD8           op,
 		    PicturePtr      pSrc,
 		    PicturePtr      pMask,
 		    PicturePtr      pDst,
 		    INT16           xSrc,
 		    INT16           ySrc,
 		    INT16           xMask,
 		    INT16           yMask,
 		    INT16           xDst,
 		    INT16           yDst,
 		    CARD16          width,
 		    CARD16          height)
  {
    RegionRec	    region;
    int		    n;
    BoxPtr	    pbox;
    CompositeFunc   func = 0;
    Bool	    srcRepeat = pSrc->repeat;
    Bool	    maskRepeat = FALSE;
    Bool            srcAlphaMap = pSrc->alphaMap != 0;
    Bool	    maskAlphaMap = FALSE;
    Bool            dstAlphaMap = pDst->alphaMap != 0;
    int		    x_msk, y_msk, x_src, y_src, x_dst, y_dst;
    int		    w, h, w_this, h_this;
    int		    dstDepth = pDst->pDrawable->depth;
    int		    oldFormat = pDst->format;
    xDst += pDst->pDrawable->x;
    yDst += pDst->pDrawable->y;
    xSrc += pSrc->pDrawable->x;
    ySrc += pSrc->pDrawable->y;
    if (pMask)
    {
	xMask += pMask->pDrawable->x;
	yMask += pMask->pDrawable->y;
	maskRepeat = pMask->repeat;
	maskAlphaMap = pMask->alphaMap != 0;
    }
     int oldDepth = pDst->pDrawable->depth;
     int oldFormat = pDst->format;
     int		    n;
      {
          pDst->format = PICT_a8r8g8b8;
      }
    if (!pSrc->transform && !(pMask && pMask->transform))
    if (!maskAlphaMap && !srcAlphaMap && !dstAlphaMap)
    switch (op) {
    case PictOpSrc:
#ifdef USE_MMX
	if (!pMask && pSrc->format == pDst->format &&
	    pSrc->pDrawable != pDst->pDrawable)
	{
	    func = fbCompositeCopyAreammx;
	}
#endif
	break;
    case PictOpOver:
	if (pMask)
	{
	    if (srcRepeat && 
		pSrc->pDrawable->width == 1 &&
		pSrc->pDrawable->height == 1)
	    {
		srcRepeat = FALSE;
		if (PICT_FORMAT_COLOR(pSrc->format)) {
		    switch (pMask->format) {
		    case PICT_a8:
			switch (pDst->format) {
			case PICT_r5g6b5:
			case PICT_b5g6r5:
#ifdef USE_MMX
			    if (fbHaveMMX())
				func = fbCompositeSolidMask_nx8x0565mmx;
			    else
#endif
			    func = fbCompositeSolidMask_nx8x0565;
			    break;
			case PICT_r8g8b8:
			case PICT_b8g8r8:
			    func = fbCompositeSolidMask_nx8x0888;
			    break;
			case PICT_a8r8g8b8:
			case PICT_x8r8g8b8:
			case PICT_a8b8g8r8:
			case PICT_x8b8g8r8:
			    func = SafeAlphaCompositeSolidMask_nx8x8888;
			    break;
			}
			break;
		    case PICT_a8r8g8b8:
			if (pMask->componentAlpha) {
			    switch (pDst->format) {
			    case PICT_a8r8g8b8:
			    case PICT_x8r8g8b8:
#ifdef USE_MMX
				if (fbHaveMMX())
				    func = fbCompositeSolidMask_nx8888x8888Cmmx;
				else
#endif
				func = fbCompositeSolidMask_nx8888x8888C;
				break;
			    case PICT_r5g6b5:
#ifdef USE_MMX
				if (fbHaveMMX())
				    func = fbCompositeSolidMask_nx8888x0565Cmmx;
				else
#endif
				func = fbCompositeSolidMask_nx8888x0565C;
				break;
			    }
			}
			break;
		    case PICT_a8b8g8r8:
			if (pMask->componentAlpha) {
			    switch (pDst->format) {
			    case PICT_a8b8g8r8:
			    case PICT_x8b8g8r8:
#ifdef USE_MMX
				if (fbHaveMMX())
				    func = fbCompositeSolidMask_nx8888x8888Cmmx;
				else
#endif
				func = fbCompositeSolidMask_nx8888x8888C;
				break;
			    case PICT_b5g6r5:
#ifdef USE_MMX
				if (fbHaveMMX())
				    func = fbCompositeSolidMask_nx8888x0565Cmmx;
				else
#endif
				func = fbCompositeSolidMask_nx8888x0565C;
				break;
			    }
			}
			break;
		    case PICT_a1:
			switch (pDst->format) {
			case PICT_r5g6b5:
			case PICT_b5g6r5:
			case PICT_r8g8b8:
			case PICT_b8g8r8:
			case PICT_a8r8g8b8:
			case PICT_x8r8g8b8:
			case PICT_a8b8g8r8:
			case PICT_x8b8g8r8:
			    func = fbCompositeSolidMask_nx1xn;
			    break;
			}
			break;
		    }
		}
	    }
	    else  
	    {
		if (pSrc->pDrawable == pMask->pDrawable &&
		    xSrc == xMask && ySrc == yMask &&
		    !pMask->componentAlpha)
		{
		    switch (pSrc->format) {
		    case PICT_x8b8g8r8:
			switch (pMask->format) {
			case PICT_a8r8g8b8:
			case PICT_a8b8g8r8:
			    switch (pDst->format) {
			    case PICT_a8r8g8b8:
			    case PICT_x8r8g8b8:
#ifdef USE_MMX
				if (fbHaveMMX())
				    func = fbCompositeSrc_8888RevNPx8888mmx;
#endif
				break;
			    case PICT_r5g6b5:
#ifdef USE_MMX
				if (fbHaveMMX())
				    func = fbCompositeSrc_8888RevNPx0565mmx;
#endif
				break;
			    }
			    break;
			}
			break;
		    case PICT_x8r8g8b8:
			switch (pMask->format) {
			case PICT_a8r8g8b8:
			case PICT_a8b8g8r8:
			    switch (pDst->format) {
			    case PICT_a8b8g8r8:
			    case PICT_x8b8g8r8:
#ifdef USE_MMX
				if (fbHaveMMX())
				    func = fbCompositeSrc_8888RevNPx8888mmx;
#endif
				break;
			    case PICT_r5g6b5:
#ifdef USE_MMX
				if (fbHaveMMX())
				    func = fbCompositeSrc_8888RevNPx0565mmx;
#endif
				break;
			    }
			    break;
			}
			break;
		    }
		    break;
	}
	else
	{
		    if (maskRepeat &&
			pMask->pDrawable->width == 1 &&
			pMask->pDrawable->height == 1)
		    {
			if (pSrc->format == PICT_x8r8g8b8 &&
			    pDst->format == PICT_x8r8g8b8 &&
			    pMask->format == PICT_a8)
			{
#ifdef USE_MMX
			    if (fbHaveMMX())
				func = fbCompositeSrc_8888x8x8888mmx;
#endif
			}
		    }
		}
	    }
	}
	else  
	{
	    if (srcRepeat &&
		pSrc->pDrawable->width == 1 &&
		pSrc->pDrawable->height == 1)
	    {
	    switch (pSrc->format) {
	    case PICT_a8r8g8b8:
		    switch (pDst->format) {
		    case PICT_a8r8g8b8:
	    case PICT_x8r8g8b8:
#ifdef USE_MMX
			if (fbHaveMMX())
			{
			    srcRepeat = FALSE;
			    func = fbCompositeSolid_nx8888mmx;
			}
#endif
			break;
		    case PICT_r5g6b5:
#ifdef USE_MMX
			if (fbHaveMMX())
			{
			    srcRepeat = FALSE;
			    func = fbCompositeSolid_nx0565mmx;
			}
#endif
			break;
		    }
		    break;
		}
	    }
	    else
	    {
		switch (pSrc->format) {
		case PICT_a8r8g8b8:
		switch (pDst->format) {
		case PICT_a8r8g8b8:
		case PICT_x8r8g8b8:
#ifdef USE_MMX
			if (fbHaveMMX())
			    func = fbCompositeSrc_8888x8888mmx;
			else
#endif
		    func = fbCompositeSrc_8888x8888;
		    break;
		case PICT_r8g8b8:
		    func = fbCompositeSrc_8888x0888;
		    break;
		case PICT_r5g6b5:
		    func = fbCompositeSrc_8888x0565;
		    break;
		}
		break;
		case PICT_x8r8g8b8:
		    switch (pDst->format) {
		    case PICT_a8r8g8b8:
		    case PICT_x8r8g8b8:
#ifdef USE_MMX
			if (fbHaveMMX())
			    func = fbCompositeCopyAreammx;
#endif
			break;
		    }
		case PICT_x8b8g8r8:
		    switch (pDst->format) {
	    case PICT_a8b8g8r8:
	    case PICT_x8b8g8r8:
#ifdef USE_MMX
			if (fbHaveMMX())
			    func = fbCompositeCopyAreammx;
#endif
			break;
		    }
		    break;
		case PICT_a8b8g8r8:
		switch (pDst->format) {
		case PICT_a8b8g8r8:
		case PICT_x8b8g8r8:
#ifdef USE_MMX
			if (fbHaveMMX())
			    func = fbCompositeSrc_8888x8888mmx;
			else
#endif
		    func = fbCompositeSrc_8888x8888;
		    break;
		case PICT_b8g8r8:
		    func = fbCompositeSrc_8888x0888;
		    break;
		case PICT_b5g6r5:
		    func = fbCompositeSrc_8888x0565;
		    break;
		}
		break;
	    case PICT_r5g6b5:
		switch (pDst->format) {
		case PICT_r5g6b5:
		    func = fbCompositeSrc_0565x0565;
		    break;
		}
		break;
	    case PICT_b5g6r5:
		switch (pDst->format) {
		case PICT_b5g6r5:
		    func = fbCompositeSrc_0565x0565;
		    break;
		}
		break;
	    }
	}
	}
	break;
    case PictOpAdd:
	if (pMask == 0)
	{
	    switch (pSrc->format) {
	    case PICT_a8r8g8b8:
		switch (pDst->format) {
		case PICT_a8r8g8b8:
#ifdef USE_MMX
		    if (fbHaveMMX())
			func = fbCompositeSrcAdd_8888x8888mmx;
		    else
#endif
		    func = fbCompositeSrcAdd_8888x8888;
		    break;
		}
		break;
	    case PICT_a8b8g8r8:
		switch (pDst->format) {
		case PICT_a8b8g8r8:
#ifdef USE_MMX
		    if (fbHaveMMX())
			func = fbCompositeSrcAdd_8888x8888mmx;
		    else
#endif
		    func = fbCompositeSrcAdd_8888x8888;
		    break;
		}
		break;
	    case PICT_a8:
		switch (pDst->format) {
		case PICT_a8:
#ifdef USE_MMX
		    if (fbHaveMMX())
			func = fbCompositeSrcAdd_8000x8000mmx;
		    else
#endif
		    func = fbCompositeSrcAdd_8000x8000;
		    break;
		}
		break;
	    case PICT_a1:
		switch (pDst->format) {
		case PICT_a1:
		    func = fbCompositeSrcAdd_1000x1000;
		    break;
		}
		break;
	    }
	}
	break;
    }
    if (!func) {
        fbCompositeGeneral(op, pSrc, pMask, pDst, xSrc, ySrc, xMask, yMask, xDst, yDst, width, height);
        pDst->pDrawable->depth = dstDepth;
        pDst->format = oldFormat;
        return;
     if (pSrc->pDrawable && pMask->pDrawable &&
 	!pSrc->transform && !pMask->transform &&
 	!pSrc->alphaMap && !pMask->alphaMap &&
 	!pMask->repeat && !pMask->componentAlpha && !pDst->alphaMap &&
 	pMask->format == PICT_a8 &&
 	pSrc->repeatType == RepeatNormal && 
 	pSrc->pDrawable->width == 1 &&
 	pSrc->pDrawable->height == 1 &&
 	(pDst->format == PICT_a8r8g8b8 ||
 	 pDst->format == PICT_x8r8g8b8 ||
 	 pDst->format == PICT_a8b8g8r8 ||
 	 pDst->format == PICT_x8b8g8r8))
     {
 	fbWalkCompositeRegion (op, pSrc, pMask, pDst,
 			       xSrc, ySrc, xMask, yMask, xDst, yDst,
 			       width, height,
 			       TRUE  ,
 			       FALSE  ,
 			       SafeAlphaCompositeSolidMask_nx8x8888);
      }
    if (!miComputeCompositeRegion (&region,
 				   pSrc,
 				   pMask,
 				   pDst,
 				   xSrc,
 				   ySrc,
 				   xMask,
 				   yMask,
 				   xDst,
 				   yDst,
 				   width,
                                   height))
        return;
    n = REGION_NUM_RECTS (&region);
    pbox = REGION_RECTS (&region);
    while (n--)
     else
      {
	h = pbox->y2 - pbox->y1;
	y_src = pbox->y1 - yDst + ySrc;
	y_msk = pbox->y1 - yDst + yMask;
	y_dst = pbox->y1;
	while (h)
	{
	    h_this = h;
	    w = pbox->x2 - pbox->x1;
	    x_src = pbox->x1 - xDst + xSrc;
	    x_msk = pbox->x1 - xDst + xMask;
	    x_dst = pbox->x1;
	    if (maskRepeat)
	    {
		y_msk = mod (y_msk, pMask->pDrawable->height);
		if (h_this > pMask->pDrawable->height - y_msk)
		    h_this = pMask->pDrawable->height - y_msk;
	    }
	    if (srcRepeat)
	    {
		y_src = mod (y_src, pSrc->pDrawable->height);
		if (h_this > pSrc->pDrawable->height - y_src)
		    h_this = pSrc->pDrawable->height - y_src;
	    }
	    while (w)
	    {
		w_this = w;
		if (maskRepeat)
		{
		    x_msk = mod (x_msk, pMask->pDrawable->width);
		    if (w_this > pMask->pDrawable->width - x_msk)
			w_this = pMask->pDrawable->width - x_msk;
		}
		if (srcRepeat)
		{
		    x_src = mod (x_src, pSrc->pDrawable->width);
		    if (w_this > pSrc->pDrawable->width - x_src)
			w_this = pSrc->pDrawable->width - x_src;
		}
		(*func) (op, pSrc, pMask, pDst,
			 x_src, y_src, x_msk, y_msk, x_dst, y_dst,
			 w_this, h_this);
		w -= w_this;
		x_src += w_this;
		x_msk += w_this;
		x_dst += w_this;
	    }
	    h -= h_this;
	    y_src += h_this;
	    y_msk += h_this;
	    y_dst += h_this;
	}
	pbox++;
 	fbComposite (op, pSrc, pMask, pDst,
 		     xSrc, ySrc, xMask, yMask, xDst, yDst, width, height);
      }
    REGION_UNINIT (pDst->pDrawable->pScreen, &region);
    pDst->pDrawable->depth = dstDepth;
     pDst->pDrawable->depth = oldDepth;
      pDst->format = oldFormat;
  }
     }
     if (oldFormat == PICT_x8r8g8b8)
     {
         pDst->format = PICT_a8r8g8b8;
     }
     if (!pSrc->transform && !(pMask && pMask->transform))
     if (!maskAlphaMap && !srcAlphaMap && !dstAlphaMap)
     switch (op) {
     case PictOpSrc:
 #ifdef USE_MMX
 	if (!pMask && pSrc->format == pDst->format &&
 	    pSrc->pDrawable != pDst->pDrawable)
 	{
 	    func = fbCompositeCopyAreammx;
 	}
 #endif
 	break;
     case PictOpOver:
 	if (pMask)
 	{
 	    if (srcRepeat && 
 		pSrc->pDrawable->width == 1 &&
 		pSrc->pDrawable->height == 1)
 	    {
 		srcRepeat = FALSE;
 		if (PICT_FORMAT_COLOR(pSrc->format)) {
 		    switch (pMask->format) {
 		    case PICT_a8:
 			switch (pDst->format) {
 			case PICT_r5g6b5:
 			case PICT_b5g6r5:
 #ifdef USE_MMX
 			    if (fbHaveMMX())
 				func = fbCompositeSolidMask_nx8x0565mmx;
 			    else
 #endif
 			    func = fbCompositeSolidMask_nx8x0565;
 			    break;
 			case PICT_r8g8b8:
 			case PICT_b8g8r8:
 			    func = fbCompositeSolidMask_nx8x0888;
 			    break;
 			case PICT_a8r8g8b8:
 			case PICT_x8r8g8b8:
 			case PICT_a8b8g8r8:
 			case PICT_x8b8g8r8:
 			    func = SafeAlphaCompositeSolidMask_nx8x8888;
 			    break;
 			}
 			break;
 		    case PICT_a8r8g8b8:
 			if (pMask->componentAlpha) {
 			    switch (pDst->format) {
 			    case PICT_a8r8g8b8:
 			    case PICT_x8r8g8b8:
 #ifdef USE_MMX
 				if (fbHaveMMX())
 				    func = fbCompositeSolidMask_nx8888x8888Cmmx;
 				else
 #endif
 				func = fbCompositeSolidMask_nx8888x8888C;
 				break;
 			    case PICT_r5g6b5:
 #ifdef USE_MMX
 				if (fbHaveMMX())
 				    func = fbCompositeSolidMask_nx8888x0565Cmmx;
 				else
 #endif
 				func = fbCompositeSolidMask_nx8888x0565C;
 				break;
 			    }
 			}
 			break;
 		    case PICT_a8b8g8r8:
 			if (pMask->componentAlpha) {
 			    switch (pDst->format) {
 			    case PICT_a8b8g8r8:
 			    case PICT_x8b8g8r8:
 #ifdef USE_MMX
 				if (fbHaveMMX())
 				    func = fbCompositeSolidMask_nx8888x8888Cmmx;
 				else
 #endif
 				func = fbCompositeSolidMask_nx8888x8888C;
 				break;
 			    case PICT_b5g6r5:
 #ifdef USE_MMX
 				if (fbHaveMMX())
 				    func = fbCompositeSolidMask_nx8888x0565Cmmx;
 				else
 #endif
 				func = fbCompositeSolidMask_nx8888x0565C;
 				break;
 			    }
 			}
 			break;
 		    case PICT_a1:
 			switch (pDst->format) {
 			case PICT_r5g6b5:
 			case PICT_b5g6r5:
 			case PICT_r8g8b8:
 			case PICT_b8g8r8:
 			case PICT_a8r8g8b8:
 			case PICT_x8r8g8b8:
 			case PICT_a8b8g8r8:
 			case PICT_x8b8g8r8:
 			    func = fbCompositeSolidMask_nx1xn;
 			    break;
 			}
 			break;
 		    }
 		}
 	    }
 	    else  
 	    {
 		if (pSrc->pDrawable == pMask->pDrawable &&
 		    xSrc == xMask && ySrc == yMask &&
 		    !pMask->componentAlpha)
 		{
 		    switch (pSrc->format) {
 		    case PICT_x8b8g8r8:
 			switch (pMask->format) {
 			case PICT_a8r8g8b8:
 			case PICT_a8b8g8r8:
 			    switch (pDst->format) {
 			    case PICT_a8r8g8b8:
 			    case PICT_x8r8g8b8:
 #ifdef USE_MMX
 				if (fbHaveMMX())
 				    func = fbCompositeSrc_8888RevNPx8888mmx;
 #endif
 				break;
 			    case PICT_r5g6b5:
 #ifdef USE_MMX
 				if (fbHaveMMX())
 				    func = fbCompositeSrc_8888RevNPx0565mmx;
 #endif
 				break;
 			    }
 			    break;
 			}
 			break;
 		    case PICT_x8r8g8b8:
 			switch (pMask->format) {
 			case PICT_a8r8g8b8:
 			case PICT_a8b8g8r8:
 			    switch (pDst->format) {
 			    case PICT_a8b8g8r8:
 			    case PICT_x8b8g8r8:
 #ifdef USE_MMX
 				if (fbHaveMMX())
 				    func = fbCompositeSrc_8888RevNPx8888mmx;
 #endif
 				break;
 			    case PICT_r5g6b5:
 #ifdef USE_MMX
 				if (fbHaveMMX())
 				    func = fbCompositeSrc_8888RevNPx0565mmx;
 #endif
 				break;
 			    }
 			    break;
 			}
 			break;
 		    }
 		    break;
 	}
 	else
 	{
 		    if (maskRepeat &&
 			pMask->pDrawable->width == 1 &&
 			pMask->pDrawable->height == 1)
 		    {
 			if (pSrc->format == PICT_x8r8g8b8 &&
 			    pDst->format == PICT_x8r8g8b8 &&
 			    pMask->format == PICT_a8)
 			{
 #ifdef USE_MMX
 			    if (fbHaveMMX())
 				func = fbCompositeSrc_8888x8x8888mmx;
 #endif
 			}
 		    }
 		}
 	    }
 	}
 	else  
 	{
 	    if (srcRepeat &&
 		pSrc->pDrawable->width == 1 &&
 		pSrc->pDrawable->height == 1)
 	    {
 	    switch (pSrc->format) {
 	    case PICT_a8r8g8b8:
 		    switch (pDst->format) {
 		    case PICT_a8r8g8b8:
 	    case PICT_x8r8g8b8:
 #ifdef USE_MMX
 			if (fbHaveMMX())
 			{
 			    srcRepeat = FALSE;
 			    func = fbCompositeSolid_nx8888mmx;
 			}
 #endif
 			break;
 		    case PICT_r5g6b5:
 #ifdef USE_MMX
 			if (fbHaveMMX())
 			{
 			    srcRepeat = FALSE;
 			    func = fbCompositeSolid_nx0565mmx;
 			}
 #endif
 			break;
 		    }
 		    break;
 		}
 	    }
 	    else
 	    {
 		switch (pSrc->format) {
 		case PICT_a8r8g8b8:
 		switch (pDst->format) {
 		case PICT_a8r8g8b8:
 		case PICT_x8r8g8b8:
 #ifdef USE_MMX
 			if (fbHaveMMX())
 			    func = fbCompositeSrc_8888x8888mmx;
 			else
 #endif
 		    func = fbCompositeSrc_8888x8888;
 		    break;
 		case PICT_r8g8b8:
 		    func = fbCompositeSrc_8888x0888;
 		    break;
 		case PICT_r5g6b5:
 		    func = fbCompositeSrc_8888x0565;
 		    break;
 		}
 		break;
 		case PICT_x8r8g8b8:
 		    switch (pDst->format) {
 		    case PICT_a8r8g8b8:
 		    case PICT_x8r8g8b8:
 #ifdef USE_MMX
 			if (fbHaveMMX())
 			    func = fbCompositeCopyAreammx;
 #endif
 			break;
 		    }
 		case PICT_x8b8g8r8:
 		    switch (pDst->format) {
 	    case PICT_a8b8g8r8:
 	    case PICT_x8b8g8r8:
 #ifdef USE_MMX
 			if (fbHaveMMX())
 			    func = fbCompositeCopyAreammx;
 #endif
 			break;
 		    }
 		    break;
 		case PICT_a8b8g8r8:
 		switch (pDst->format) {
 		case PICT_a8b8g8r8:
 		case PICT_x8b8g8r8:
 #ifdef USE_MMX
 			if (fbHaveMMX())
 			    func = fbCompositeSrc_8888x8888mmx;
 			else
 #endif
 		    func = fbCompositeSrc_8888x8888;
 		    break;
 		case PICT_b8g8r8:
 		    func = fbCompositeSrc_8888x0888;
 		    break;
 		case PICT_b5g6r5:
 		    func = fbCompositeSrc_8888x0565;
 		    break;
 		}
 		break;
 	    case PICT_r5g6b5:
 		switch (pDst->format) {
 		case PICT_r5g6b5:
 		    func = fbCompositeSrc_0565x0565;
 		    break;
 		}
 		break;
 	    case PICT_b5g6r5:
 		switch (pDst->format) {
 		case PICT_b5g6r5:
 		    func = fbCompositeSrc_0565x0565;
 		    break;
 		}
 		break;
 	    }
 	}
 	}
 	break;
     case PictOpAdd:
 	if (pMask == 0)
 	{
 	    switch (pSrc->format) {
 	    case PICT_a8r8g8b8:
 		switch (pDst->format) {
 		case PICT_a8r8g8b8:
 #ifdef USE_MMX
 		    if (fbHaveMMX())
 			func = fbCompositeSrcAdd_8888x8888mmx;
 		    else
 #endif
 		    func = fbCompositeSrcAdd_8888x8888;
 		    break;
 		}
 		break;
 	    case PICT_a8b8g8r8:
 		switch (pDst->format) {
 		case PICT_a8b8g8r8:
 #ifdef USE_MMX
 		    if (fbHaveMMX())
 			func = fbCompositeSrcAdd_8888x8888mmx;
 		    else
 #endif
 		    func = fbCompositeSrcAdd_8888x8888;
 		    break;
 		}
 		break;
 	    case PICT_a8:
 		switch (pDst->format) {
 		case PICT_a8:
 #ifdef USE_MMX
 		    if (fbHaveMMX())
 			func = fbCompositeSrcAdd_8000x8000mmx;
 		    else
 #endif
 		    func = fbCompositeSrcAdd_8000x8000;
 		    break;
 		}
 		break;
 	    case PICT_a1:
 		switch (pDst->format) {
 		case PICT_a1:
 		    func = fbCompositeSrcAdd_1000x1000;
 		    break;
 		}
 		break;
 	    }
 	}
 	break;
     }
     if (!func) {
         fbCompositeGeneral(op, pSrc, pMask, pDst, xSrc, ySrc, xMask, yMask, xDst, yDst, width, height);
         pDst->pDrawable->depth = dstDepth;
         pDst->format = oldFormat;
         return;
     }
     if (!miComputeCompositeRegion (&region,
  				   pSrc,
  				   pMask,
  				   pDst,
  				   xSrc,
  				   ySrc,
  				   xMask,
  				   yMask,
  				   xDst,
  				   yDst,
  				   width,
                                    height))
         return;
     n = REGION_NUM_RECTS (&region);
     pbox = REGION_RECTS (&region);
     while (n--)
     {
 	h = pbox->y2 - pbox->y1;
 	y_src = pbox->y1 - yDst + ySrc;
 	y_msk = pbox->y1 - yDst + yMask;
 	y_dst = pbox->y1;
 	while (h)
 	{
 	    h_this = h;
 	    w = pbox->x2 - pbox->x1;
 	    x_src = pbox->x1 - xDst + xSrc;
 	    x_msk = pbox->x1 - xDst + xMask;
 	    x_dst = pbox->x1;
 	    if (maskRepeat)
 	    {
 		y_msk = mod (y_msk, pMask->pDrawable->height);
 		if (h_this > pMask->pDrawable->height - y_msk)
 		    h_this = pMask->pDrawable->height - y_msk;
 	    }
 	    if (srcRepeat)
 	    {
 		y_src = mod (y_src, pSrc->pDrawable->height);
 		if (h_this > pSrc->pDrawable->height - y_src)
 		    h_this = pSrc->pDrawable->height - y_src;
 	    }
 	    while (w)
 	    {
 		w_this = w;
 		if (maskRepeat)
 		{
 		    x_msk = mod (x_msk, pMask->pDrawable->width);
 		    if (w_this > pMask->pDrawable->width - x_msk)
 			w_this = pMask->pDrawable->width - x_msk;
 		}
 		if (srcRepeat)
 		{
 		    x_src = mod (x_src, pSrc->pDrawable->width);
 		    if (w_this > pSrc->pDrawable->width - x_src)
 			w_this = pSrc->pDrawable->width - x_src;
 		}
 		(*func) (op, pSrc, pMask, pDst,
 			 x_src, y_src, x_msk, y_msk, x_dst, y_dst,
 			 w_this, h_this);
 		w -= w_this;
 		x_src += w_this;
 		x_msk += w_this;
 		x_dst += w_this;
 	    }
 	    h -= h_this;
 	    y_src += h_this;
 	    y_msk += h_this;
 	    y_dst += h_this;
 	}
 	pbox++;
     }
     REGION_UNINIT (pDst->pDrawable->pScreen, &region);
     pDst->pDrawable->depth = dstDepth;
     pDst->format = oldFormat;
 }","[58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 555, 556, 557]","The fbComposite function in fbpict.c in the Render extension in the X server in X.Org X11R7.1 allows remote authenticated users to cause a denial of service (memory corruption and daemon crash) or possibly execute arbitrary code via a crafted request, related to an incorrect macro definition.",xserver,CVE-2010-1166,CWE-189
6260,179099," static int get_siz(Jpeg2000DecoderContext *s)
 {
     int i;
     int ncomponents;
     uint32_t log2_chroma_wh = 0;
     const enum AVPixelFormat *possible_fmts = NULL;
     int possible_fmts_nb = 0;
     if (bytestream2_get_bytes_left(&s->g) < 36)
         return AVERROR_INVALIDDATA;
     s->avctx->profile = bytestream2_get_be16u(&s->g);  
     s->width          = bytestream2_get_be32u(&s->g);  
     s->height         = bytestream2_get_be32u(&s->g);  
     s->image_offset_x = bytestream2_get_be32u(&s->g);  
     s->image_offset_y = bytestream2_get_be32u(&s->g);  
     s->tile_width     = bytestream2_get_be32u(&s->g);  
     s->tile_height    = bytestream2_get_be32u(&s->g);  
     s->tile_offset_x  = bytestream2_get_be32u(&s->g);  
      s->tile_offset_y  = bytestream2_get_be32u(&s->g);  
      ncomponents       = bytestream2_get_be16u(&s->g);  
     if (s->image_offset_x || s->image_offset_y) {
         avpriv_request_sample(s->avctx, ""Support for image offsets"");
         return AVERROR_PATCHWELCOME;
     }
      if (ncomponents <= 0) {
          av_log(s->avctx, AV_LOG_ERROR, ""Invalid number of components: %d\n"",
                 s->ncomponents);
         return AVERROR_INVALIDDATA;
     }
     if (ncomponents > 4) {
         avpriv_request_sample(s->avctx, ""Support for %d components"",
                               s->ncomponents);
         return AVERROR_PATCHWELCOME;
     }
     s->ncomponents = ncomponents;
     if (s->tile_width <= 0 || s->tile_height <= 0) {
         av_log(s->avctx, AV_LOG_ERROR, ""Invalid tile dimension %dx%d.\n"",
                s->tile_width, s->tile_height);
         return AVERROR_INVALIDDATA;
     }
     if (bytestream2_get_bytes_left(&s->g) < 3 * s->ncomponents)
         return AVERROR_INVALIDDATA;
     for (i = 0; i < s->ncomponents; i++) {  
         uint8_t x    = bytestream2_get_byteu(&s->g);
         s->cbps[i]   = (x & 0x7f) + 1;
         s->precision = FFMAX(s->cbps[i], s->precision);
         s->sgnd[i]   = !!(x & 0x80);
         s->cdx[i]    = bytestream2_get_byteu(&s->g);
         s->cdy[i]    = bytestream2_get_byteu(&s->g);
         if (   !s->cdx[i] || s->cdx[i] == 3 || s->cdx[i] > 4
             || !s->cdy[i] || s->cdy[i] == 3 || s->cdy[i] > 4) {
             av_log(s->avctx, AV_LOG_ERROR, ""Invalid sample separation %d/%d\n"", s->cdx[i], s->cdy[i]);
             return AVERROR_INVALIDDATA;
         }
         log2_chroma_wh |= s->cdy[i] >> 1 << i * 4 | s->cdx[i] >> 1 << i * 4 + 2;
     }
     s->numXtiles = ff_jpeg2000_ceildiv(s->width  - s->tile_offset_x, s->tile_width);
     s->numYtiles = ff_jpeg2000_ceildiv(s->height - s->tile_offset_y, s->tile_height);
     if (s->numXtiles * (uint64_t)s->numYtiles > INT_MAX/sizeof(*s->tile)) {
         s->numXtiles = s->numYtiles = 0;
         return AVERROR(EINVAL);
     }
     s->tile = av_mallocz_array(s->numXtiles * s->numYtiles, sizeof(*s->tile));
     if (!s->tile) {
         s->numXtiles = s->numYtiles = 0;
         return AVERROR(ENOMEM);
     }
     for (i = 0; i < s->numXtiles * s->numYtiles; i++) {
         Jpeg2000Tile *tile = s->tile + i;
         tile->comp = av_mallocz(s->ncomponents * sizeof(*tile->comp));
         if (!tile->comp)
             return AVERROR(ENOMEM);
     }
     s->avctx->width  = ff_jpeg2000_ceildivpow2(s->width  - s->image_offset_x,
                                                s->reduction_factor);
     s->avctx->height = ff_jpeg2000_ceildivpow2(s->height - s->image_offset_y,
                                                s->reduction_factor);
     if (s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_2K ||
         s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_4K) {
         possible_fmts = xyz_pix_fmts;
         possible_fmts_nb = FF_ARRAY_ELEMS(xyz_pix_fmts);
     } else {
         switch (s->colour_space) {
         case 16:
             possible_fmts = rgb_pix_fmts;
             possible_fmts_nb = FF_ARRAY_ELEMS(rgb_pix_fmts);
             break;
         case 17:
             possible_fmts = gray_pix_fmts;
             possible_fmts_nb = FF_ARRAY_ELEMS(gray_pix_fmts);
             break;
         case 18:
             possible_fmts = yuv_pix_fmts;
             possible_fmts_nb = FF_ARRAY_ELEMS(yuv_pix_fmts);
             break;
         default:
             possible_fmts = all_pix_fmts;
             possible_fmts_nb = FF_ARRAY_ELEMS(all_pix_fmts);
             break;
         }
     }
     for (i = 0; i < possible_fmts_nb; ++i) {
         if (pix_fmt_match(possible_fmts[i], ncomponents, s->precision, log2_chroma_wh, s->pal8)) {
             s->avctx->pix_fmt = possible_fmts[i];
             break;
         }
     }
     if (s->avctx->pix_fmt == AV_PIX_FMT_NONE) {
         av_log(s->avctx, AV_LOG_ERROR,
                ""Unknown pix_fmt, profile: %d, colour_space: %d, ""
                ""components: %d, precision: %d, ""
                ""cdx[1]: %d, cdy[1]: %d, cdx[2]: %d, cdy[2]: %d\n"",
                s->avctx->profile, s->colour_space, ncomponents, s->precision,
                ncomponents > 2 ? s->cdx[1] : 0,
                ncomponents > 2 ? s->cdy[1] : 0,
                ncomponents > 2 ? s->cdx[2] : 0,
                ncomponents > 2 ? s->cdy[2] : 0);
     }
     s->avctx->bits_per_raw_sample = s->precision;
     return 0;
 }","[20, 21, 22, 23]","The get_siz function in libavcodec/jpeg2000dec.c in FFmpeg before 2.1 does not prevent attempts to use non-zero image offsets, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted JPEG2000 data.",FFmpeg,CVE-2013-7012,CWE-119
6282,182785,"  onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,
                 OnigCompileInfo* ci, OnigErrorInfo* einfo)
 {
   int r;
   UChar *cpat, *cpat_end;
    if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;
    if (ci->pattern_enc != ci->target_enc) {
    r = conv_encoding(ci->pattern_enc, ci->target_enc, pattern, pattern_end,
                      &cpat, &cpat_end);
    if (r != 0) return r;
     return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION;
    }
    else {
      cpat     = (UChar* )pattern;
     cpat_end = (UChar* )pattern_end;
   }
   *reg = (regex_t* )xmalloc(sizeof(regex_t));
   if (IS_NULL(*reg)) {
     r = ONIGERR_MEMORY;
     goto err2;
   }
   r = onig_reg_init(*reg, ci->option, ci->case_fold_flag, ci->target_enc,
                     ci->syntax);
   if (r != 0) goto err;
   r = onig_compile(*reg, cpat, cpat_end, einfo);
   if (r != 0) {
   err:
     onig_free(*reg);
     *reg = NULL;
   }
  err2:
   if (cpat != pattern) xfree(cpat);
   return r;
 }","[8, 9, 10, 11]","A use-after-free in onig_new_deluxe() in regext.c in Oniguruma 6.9.2 allows attackers to potentially cause information disclosure, denial of service, or possibly code execution by providing a crafted regular expression. The attacker provides a pair of a regex pattern and a string, with a multi-byte encoding that gets handled by onig_new_deluxe(). Oniguruma issues often affect Ruby, as well as common optional libraries for PHP and Rust.",oniguruma,CVE-2019-13224,CWE-416
6299,179085," static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,
                                 AVFrame *picture)
 {
     int compno, reslevelno, bandno;
     int x, y;
     uint8_t *line;
     Jpeg2000T1Context t1;
     for (compno = 0; compno < s->ncomponents; compno++) {
         Jpeg2000Component *comp     = tile->comp + compno;
         Jpeg2000CodingStyle *codsty = tile->codsty + compno;
         for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) {
             Jpeg2000ResLevel *rlevel = comp->reslevel + reslevelno;
             for (bandno = 0; bandno < rlevel->nbands; bandno++) {
                 int nb_precincts, precno;
                 Jpeg2000Band *band = rlevel->band + bandno;
                 int cblkno = 0, bandpos;
                 bandpos = bandno + (reslevelno > 0);
                 if (band->coord[0][0] == band->coord[0][1] ||
                     band->coord[1][0] == band->coord[1][1])
                     continue;
                 nb_precincts = rlevel->num_precincts_x * rlevel->num_precincts_y;
                 for (precno = 0; precno < nb_precincts; precno++) {
                     Jpeg2000Prec *prec = band->prec + precno;
                     for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) {
                         int x, y;
                         Jpeg2000Cblk *cblk = prec->cblk + cblkno;
                         decode_cblk(s, codsty, &t1, cblk,
                                     cblk->coord[0][1] - cblk->coord[0][0],
                                     cblk->coord[1][1] - cblk->coord[1][0],
                                     bandpos);
                         x = cblk->coord[0][0];
                         y = cblk->coord[1][0];
                         if (codsty->transform == FF_DWT97)
                             dequantization_float(x, y, cblk, comp, &t1, band);
                         else
                             dequantization_int(x, y, cblk, comp, &t1, band);
                    }  
                 }  
             }  
         }  
         ff_dwt_decode(&comp->dwt, codsty->transform == FF_DWT97 ? (void*)comp->f_data : (void*)comp->i_data);
     }  
     if (tile->codsty[0].mct)
         mct_decode(s, tile);
     if (s->cdef[0] < 0) {
         for (x = 0; x < s->ncomponents; x++)
             s->cdef[x] = x + 1;
         if ((s->ncomponents & 1) == 0)
             s->cdef[s->ncomponents-1] = 0;
     }
     if (s->precision <= 8) {
         for (compno = 0; compno < s->ncomponents; compno++) {
             Jpeg2000Component *comp = tile->comp + compno;
             Jpeg2000CodingStyle *codsty = tile->codsty + compno;
             float *datap = comp->f_data;
             int32_t *i_datap = comp->i_data;
             int cbps = s->cbps[compno];
             int w = tile->comp[compno].coord[0][1] - s->image_offset_x;
             int planar = !!picture->data[2];
             int pixelsize = planar ? 1 : s->ncomponents;
             int plane = 0;
             if (planar)
                 plane = s->cdef[compno] ? s->cdef[compno]-1 : (s->ncomponents-1);
              y    = tile->comp[compno].coord[1][0] - s->image_offset_y;
            line = picture->data[plane] + y * picture->linesize[plane];
             line = picture->data[plane] + y / s->cdy[compno] * picture->linesize[plane];
              for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {
                  uint8_t *dst;
                  x   = tile->comp[compno].coord[0][0] - s->image_offset_x;
                dst = line + x * pixelsize + compno*!planar;
                 dst = line + x / s->cdx[compno] * pixelsize + compno*!planar;
                  if (codsty->transform == FF_DWT97) {
                      for (; x < w; x += s->cdx[compno]) {
                         int val = lrintf(*datap) + (1 << (cbps - 1));
                         val = av_clip(val, 0, (1 << cbps) - 1);
                         *dst = val << (8 - cbps);
                         datap++;
                         dst += pixelsize;
                     }
                 } else {
                     for (; x < w; x += s->cdx[compno]) {
                         int val = *i_datap + (1 << (cbps - 1));
                         val = av_clip(val, 0, (1 << cbps) - 1);
                         *dst = val << (8 - cbps);
                         i_datap++;
                         dst += pixelsize;
                     }
                 }
                 line += picture->linesize[plane];
             }
         }
     } else {
         for (compno = 0; compno < s->ncomponents; compno++) {
             Jpeg2000Component *comp = tile->comp + compno;
             Jpeg2000CodingStyle *codsty = tile->codsty + compno;
             float *datap = comp->f_data;
             int32_t *i_datap = comp->i_data;
             uint16_t *linel;
             int cbps = s->cbps[compno];
             int w = tile->comp[compno].coord[0][1] - s->image_offset_x;
             int planar = !!picture->data[2];
             int pixelsize = planar ? 1 : s->ncomponents;
             int plane = 0;
             if (planar)
                  plane = s->cdef[compno] ? s->cdef[compno]-1 : (s->ncomponents-1);
              y     = tile->comp[compno].coord[1][0] - s->image_offset_y;
            linel = (uint16_t *)picture->data[plane] + y * (picture->linesize[plane] >> 1);
             linel = (uint16_t *)picture->data[plane] + y / s->cdy[compno] * (picture->linesize[plane] >> 1);
              for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {
                  uint16_t *dst;
                  x   = tile->comp[compno].coord[0][0] - s->image_offset_x;
                dst = linel + (x * pixelsize + compno*!planar);
                 dst = linel + (x / s->cdx[compno] * pixelsize + compno*!planar);
                  if (codsty->transform == FF_DWT97) {
                      for (; x < w; x += s-> cdx[compno]) {
                          int  val = lrintf(*datap) + (1 << (cbps - 1));
                         val = av_clip(val, 0, (1 << cbps) - 1);
                         *dst = val << (16 - cbps);
                         datap++;
                         dst += pixelsize;
                     }
                 } else {
                     for (; x < w; x += s-> cdx[compno]) {
                         int val = *i_datap + (1 << (cbps - 1));
                         val = av_clip(val, 0, (1 << cbps) - 1);
                         *dst = val << (16 - cbps);
                         i_datap++;
                         dst += pixelsize;
                     }
                 }
                 linel += picture->linesize[plane] >> 1;
             }
         }
     }
     return 0;
 }","[65, 66, 70, 71, 107, 108, 112, 113]","The jpeg2000_decode_tile function in libavcodec/jpeg2000dec.c in FFmpeg before 2.1 does not consider the component number in certain calculations, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted JPEG2000 data.",FFmpeg,CVE-2013-7024,CWE-119
6327,179697," int msPostGISLayerSetTimeFilter(layerObj *lp, const char *timestring, const char *timefield)
 {
   char **atimes, **aranges = NULL;
   int numtimes=0,i=0,numranges=0;
   size_t buffer_size = 512;
   char buffer[512], bufferTmp[512];
   buffer[0] = '\0';
   bufferTmp[0] = '\0';
    if (!lp || !timestring || !timefield)
      return MS_FALSE;
   if( strchr(timestring,'\'') || strchr(timestring, '\\') ) {
      msSetError(MS_MISCERR, ""Invalid time filter."", ""msPostGISLayerSetTimeFilter()"");
      return MS_FALSE;
   }
    if (strstr(timestring, "","") == NULL &&
        strstr(timestring, ""/"") == NULL) {  
     createPostgresTimeCompareSimple(timefield, timestring, buffer, buffer_size);
   } else {
     atimes = msStringSplit (timestring, ',', &numtimes);
     if (atimes == NULL || numtimes < 1)
       return MS_FALSE;
     strlcat(buffer, ""("", buffer_size);
     for(i=0; i<numtimes; i++) {
       if(i!=0) {
         strlcat(buffer, "" OR "", buffer_size);
       }
       strlcat(buffer, ""("", buffer_size);
       aranges = msStringSplit(atimes[i],  '/', &numranges);
       if(!aranges) return MS_FALSE;
       if(numranges == 1) {
         createPostgresTimeCompareSimple(timefield, atimes[i], bufferTmp, buffer_size);
         strlcat(buffer, bufferTmp, buffer_size);
       } else if(numranges == 2) {
         createPostgresTimeCompareRange(timefield, aranges[0], aranges[1], bufferTmp, buffer_size);
         strlcat(buffer, bufferTmp, buffer_size);
       } else {
         return MS_FALSE;
       }
       msFreeCharArray(aranges, numranges);
       strlcat(buffer, "")"", buffer_size);
     }
     strlcat(buffer, "")"", buffer_size);
     msFreeCharArray(atimes, numtimes);
   }
   if(!*buffer) {
     return MS_FALSE;
   }
   if(lp->filteritem) free(lp->filteritem);
   lp->filteritem = msStrdup(timefield);
   if (&lp->filter) {
     if (lp->filter.type == MS_EXPRESSION) {
       snprintf(bufferTmp, buffer_size, ""(%s) and %s"", lp->filter.string, buffer);
       loadExpressionString(&lp->filter, bufferTmp);
     } else {
       freeExpression(&lp->filter);
       loadExpressionString(&lp->filter, buffer);
     }
   }
   return MS_TRUE;
 }","[11, 12, 13, 14]","SQL injection vulnerability in the msPostGISLayerSetTimeFilter function in mappostgis.c in MapServer before 6.4.1, when a WMS-Time service is used, allows remote attackers to execute arbitrary SQL commands via a crafted string in a PostGIS TIME filter.",mapserver,CVE-2013-7262,CWE-89
6330,182971,"  mcs_parse_domain_params(STREAM s)
  {
	int length;
 	uint32 length;
 	struct stream packet = *s;
  	ber_parse_header(s, MCS_TAG_DOMAIN_PARAMS, &length);
 	if (!s_check_rem(s, length))
 	{
 		rdp_protocol_error(""mcs_parse_domain_params(), consume domain params from stream would overrun"", &packet);
 	}
  	in_uint8s(s, length);
  	return s_check(s);
 }","[3, 4, 5, 7, 8, 9, 10]",rdesktop versions up to and including v1.8.3 contain a Buffer Overflow over the global variables in the function seamless_process_line() that results in memory corruption and probably even a remote code execution.,rdesktop,CVE-2018-20182,CWE-119
6356,178409," LockServer(void)
 {
   char tmp[PATH_MAX], pid_str[12];
   int lfd, i, haslock, l_pid, t;
   char *tmppath = NULL;
   int len;
   char port[20];
   if (nolock) return;
   tmppath = LOCK_DIR;
   sprintf(port, ""%d"", atoi(display));
   len = strlen(LOCK_PREFIX) > strlen(LOCK_TMP_PREFIX) ? strlen(LOCK_PREFIX) :
 						strlen(LOCK_TMP_PREFIX);
   len += strlen(tmppath) + strlen(port) + strlen(LOCK_SUFFIX) + 1;
   if (len > sizeof(LockFile))
     FatalError(""Display name `%s' is too long\n"", port);
   (void)sprintf(tmp, ""%s"" LOCK_TMP_PREFIX ""%s"" LOCK_SUFFIX, tmppath, port);
   (void)sprintf(LockFile, ""%s"" LOCK_PREFIX ""%s"" LOCK_SUFFIX, tmppath, port);
   StillLocking = TRUE;
   i = 0;
   do {
     i++;
     lfd = open(tmp, O_CREAT | O_EXCL | O_WRONLY, 0644);
     if (lfd < 0)
        sleep(2);
     else
        break;
   } while (i < 3);
   if (lfd < 0) {
     unlink(tmp);
     i = 0;
     do {
       i++;
       lfd = open(tmp, O_CREAT | O_EXCL | O_WRONLY, 0644);
       if (lfd < 0)
          sleep(2);
       else
          break;
     } while (i < 3);
   }
   if (lfd < 0)
     FatalError(""Could not create lock file in %s\n"", tmp);
   (void) sprintf(pid_str, ""%10ld\n"", (long)getpid());
   (void) write(lfd, pid_str, 11);
   (void) chmod(tmp, 0444);
   (void) close(lfd);
   i = 0;
   haslock = 0;
   while ((!haslock) && (i++ < 3)) {
     haslock = (link(tmp,LockFile) == 0);
     if (haslock) {
       break;
     }
     else {
      lfd = open(LockFile, O_RDONLY);
       lfd = open(LockFile, O_RDONLY|O_NOFOLLOW);
        if (lfd < 0) {
          unlink(tmp);
          FatalError(""Can't read lock file %s\n"", LockFile);
       }
       pid_str[0] = '\0';
       if (read(lfd, pid_str, 11) != 11) {
         unlink(LockFile);
         close(lfd);
         continue;
       }
       pid_str[11] = '\0';
       sscanf(pid_str, ""%d"", &l_pid);
       close(lfd);
       errno = 0;
       t = kill(l_pid, 0);
       if ((t< 0) && (errno == ESRCH)) {
         unlink(LockFile);
         continue;
       }
       else if (((t < 0) && (errno == EPERM)) || (t == 0)) {
         unlink(tmp);
 	FatalError(""Server is already active for display %s\n%s %s\n%s\n"",
 		   port, ""\tIf this server is no longer running, remove"",
 		   LockFile, ""\tand start again."");
       }
     }
   }
   unlink(tmp);
   if (!haslock)
     FatalError(""Could not create server lock file: %s\n"", LockFile);
   StillLocking = FALSE;
 }","[54, 55]","The LockServer function in os/utils.c in X.Org xserver before 1.11.2 allows local users to determine the existence of arbitrary files via a symlink attack on a temporary lock file, which is handled differently if the file exists.",xserver,CVE-2011-4028,CWE-59
6371,182966," ber_parse_header(STREAM s, int tagval, int *length)
 ber_parse_header(STREAM s, int tagval, uint32 *length)
  {
  	int tag, len;
 	if (tagval > 0xff)
 	{
 		in_uint16_be(s, tag);
 	}
 	else
 	{
 		in_uint8(s, tag);
 	}
 	if (tag != tagval)
 	{
 		logger(Core, Error, ""ber_parse_header(), expected tag %d, got %d"", tagval, tag);
 		return False;
 	}
 	in_uint8(s, len);
 	if (len & 0x80)
 	{
 		len &= ~0x80;
 		*length = 0;
 		while (len--)
 			next_be(s, *length);
 	}
 	else
 		*length = len;
 	return s_check(s);
 }",[2],rdesktop versions up to and including v1.8.3 contain a Buffer Overflow over the global variables in the function seamless_process_line() that results in memory corruption and probably even a remote code execution.,rdesktop,CVE-2018-20182,CWE-119
6375,181358," int yr_execute_code(
     YR_RULES* rules,
     YR_SCAN_CONTEXT* context,
     int timeout,
     time_t start_time)
 {
   int64_t mem[MEM_SIZE];
   int32_t sp = 0;
   uint8_t* ip = rules->code_start;
   YR_VALUE args[MAX_FUNCTION_ARGS];
   YR_VALUE *stack;
   YR_VALUE r1;
   YR_VALUE r2;
   YR_VALUE r3;
   #ifdef PROFILING_ENABLED
   YR_RULE* current_rule = NULL;
   #endif
    YR_RULE* rule;
    YR_MATCH* match;
    YR_OBJECT_FUNCTION* function;
   YR_OBJECT** obj_ptr;
   YR_ARENA* obj_arena;
    char* identifier;
    char* args_fmt;
   int i;
   int found;
   int count;
   int result = ERROR_SUCCESS;
   int stop = FALSE;
   int cycle = 0;
   int tidx = context->tidx;
   int stack_size;
   #ifdef PROFILING_ENABLED
   clock_t start = clock();
   #endif
   yr_get_configuration(YR_CONFIG_STACK_SIZE, (void*) &stack_size);
   stack = (YR_VALUE*) yr_malloc(stack_size * sizeof(YR_VALUE));
    if (stack == NULL)
      return ERROR_INSUFFICIENT_MEMORY;
   FAIL_ON_ERROR_WITH_CLEANUP(
       yr_arena_create(1024, 0, &obj_arena),
       yr_free(stack));
    while(!stop)
    {
      switch(*ip)
     {
       case OP_NOP:
         break;
       case OP_HALT:
         assert(sp == 0);  
         stop = TRUE;
         break;
       case OP_PUSH:
         r1.i = *(uint64_t*)(ip + 1);
         ip += sizeof(uint64_t);
         push(r1);
         break;
       case OP_POP:
         pop(r1);
         break;
       case OP_CLEAR_M:
         r1.i = *(uint64_t*)(ip + 1);
         ip += sizeof(uint64_t);
         mem[r1.i] = 0;
         break;
       case OP_ADD_M:
         r1.i = *(uint64_t*)(ip + 1);
         ip += sizeof(uint64_t);
         pop(r2);
         if (!is_undef(r2))
           mem[r1.i] += r2.i;
         break;
       case OP_INCR_M:
         r1.i = *(uint64_t*)(ip + 1);
         ip += sizeof(uint64_t);
         mem[r1.i]++;
         break;
       case OP_PUSH_M:
         r1.i = *(uint64_t*)(ip + 1);
         ip += sizeof(uint64_t);
         r1.i = mem[r1.i];
         push(r1);
         break;
       case OP_POP_M:
         r1.i = *(uint64_t*)(ip + 1);
         ip += sizeof(uint64_t);
         pop(r2);
         mem[r1.i] = r2.i;
         break;
       case OP_SWAPUNDEF:
         r1.i = *(uint64_t*)(ip + 1);
         ip += sizeof(uint64_t);
         pop(r2);
         if (is_undef(r2))
         {
           r1.i = mem[r1.i];
           push(r1);
         }
         else
         {
           push(r2);
         }
         break;
       case OP_JNUNDEF:
         pop(r1);
         push(r1);
         ip = jmp_if(!is_undef(r1), ip);
         break;
       case OP_JLE:
         pop(r2);
         pop(r1);
         push(r1);
         push(r2);
         ip = jmp_if(r1.i <= r2.i, ip);
         break;
       case OP_JTRUE:
         pop(r1);
         push(r1);
         ip = jmp_if(!is_undef(r1) && r1.i, ip);
         break;
       case OP_JFALSE:
         pop(r1);
         push(r1);
         ip = jmp_if(is_undef(r1) || !r1.i, ip);
         break;
       case OP_AND:
         pop(r2);
         pop(r1);
         if (is_undef(r1) || is_undef(r2))
           r1.i = 0;
         else
           r1.i = r1.i && r2.i;
         push(r1);
         break;
       case OP_OR:
         pop(r2);
         pop(r1);
         if (is_undef(r1))
         {
           push(r2);
         }
         else if (is_undef(r2))
         {
           push(r1);
         }
         else
         {
           r1.i = r1.i || r2.i;
           push(r1);
         }
         break;
       case OP_NOT:
         pop(r1);
         if (is_undef(r1))
           r1.i = UNDEFINED;
         else
           r1.i= !r1.i;
         push(r1);
         break;
       case OP_MOD:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         if (r2.i != 0)
           r1.i = r1.i % r2.i;
         else
           r1.i = UNDEFINED;
         push(r1);
         break;
       case OP_SHR:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.i = r1.i >> r2.i;
         push(r1);
         break;
       case OP_SHL:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.i = r1.i << r2.i;
         push(r1);
         break;
       case OP_BITWISE_NOT:
         pop(r1);
         ensure_defined(r1);
         r1.i = ~r1.i;
         push(r1);
         break;
       case OP_BITWISE_AND:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.i = r1.i & r2.i;
         push(r1);
         break;
       case OP_BITWISE_OR:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.i = r1.i | r2.i;
         push(r1);
         break;
       case OP_BITWISE_XOR:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.i = r1.i ^ r2.i;
         push(r1);
         break;
       case OP_PUSH_RULE:
         rule = *(YR_RULE**)(ip + 1);
         ip += sizeof(uint64_t);
         r1.i = rule->t_flags[tidx] & RULE_TFLAGS_MATCH ? 1 : 0;
         push(r1);
         break;
       case OP_INIT_RULE:
         #ifdef PROFILING_ENABLED
         current_rule = *(YR_RULE**)(ip + 1);
         #endif
         ip += sizeof(uint64_t);
         break;
       case OP_MATCH_RULE:
         pop(r1);
         rule = *(YR_RULE**)(ip + 1);
         ip += sizeof(uint64_t);
         if (!is_undef(r1) && r1.i)
           rule->t_flags[tidx] |= RULE_TFLAGS_MATCH;
         else if (RULE_IS_GLOBAL(rule))
           rule->ns->t_flags[tidx] |= NAMESPACE_TFLAGS_UNSATISFIED_GLOBAL;
         #ifdef PROFILING_ENABLED
          rule->clock_ticks += clock() - start;
          start = clock();
          #endif
         assert(sp == 0);
          break;
        case OP_OBJ_LOAD:
         identifier = *(char**)(ip + 1);
         ip += sizeof(uint64_t);
         r1.o = (YR_OBJECT*) yr_hash_table_lookup(
             context->objects_table,
             identifier,
             NULL);
         assert(r1.o != NULL);
         push(r1);
         break;
       case OP_OBJ_FIELD:
         identifier = *(char**)(ip + 1);
         ip += sizeof(uint64_t);
         pop(r1);
         ensure_defined(r1);
         r1.o = yr_object_lookup_field(r1.o, identifier);
         assert(r1.o != NULL);
         push(r1);
         break;
       case OP_OBJ_VALUE:
         pop(r1);
         ensure_defined(r1);
         switch(r1.o->type)
         {
           case OBJECT_TYPE_INTEGER:
             r1.i = ((YR_OBJECT_INTEGER*) r1.o)->value;
             break;
           case OBJECT_TYPE_FLOAT:
             if (isnan(((YR_OBJECT_DOUBLE*) r1.o)->value))
               r1.i = UNDEFINED;
             else
               r1.d = ((YR_OBJECT_DOUBLE*) r1.o)->value;
             break;
           case OBJECT_TYPE_STRING:
             if (((YR_OBJECT_STRING*) r1.o)->value == NULL)
               r1.i = UNDEFINED;
             else
               r1.p = ((YR_OBJECT_STRING*) r1.o)->value;
             break;
           default:
             assert(FALSE);
         }
         push(r1);
         break;
       case OP_INDEX_ARRAY:
         pop(r1);   
         pop(r2);   
         ensure_defined(r1);
         ensure_defined(r2);
         assert(r2.o->type == OBJECT_TYPE_ARRAY);
         r1.o = yr_object_array_get_item(r2.o, 0, (int) r1.i);
         if (r1.o == NULL)
           r1.i = UNDEFINED;
         push(r1);
         break;
       case OP_LOOKUP_DICT:
         pop(r1);   
         pop(r2);   
         ensure_defined(r1);
         ensure_defined(r2);
         assert(r2.o->type == OBJECT_TYPE_DICTIONARY);
         r1.o = yr_object_dict_get_item(
             r2.o, 0, r1.ss->c_string);
         if (r1.o == NULL)
           r1.i = UNDEFINED;
         push(r1);
         break;
       case OP_CALL:
         args_fmt = *(char**)(ip + 1);
         ip += sizeof(uint64_t);
         i = (int) strlen(args_fmt);
         count = 0;
         while (i > 0)
         {
           pop(r1);
           if (is_undef(r1))   
             count++;
           args[i - 1] = r1;
           i--;
         }
         pop(r2);
         ensure_defined(r2);
         if (count > 0)
         {
           r1.i = UNDEFINED;
           push(r1);
           break;
         }
         function = (YR_OBJECT_FUNCTION*) r2.o;
         result = ERROR_INTERNAL_FATAL_ERROR;
         for (i = 0; i < MAX_OVERLOADED_FUNCTIONS; i++)
         {
           if (function->prototypes[i].arguments_fmt == NULL)
             break;
           if (strcmp(function->prototypes[i].arguments_fmt, args_fmt) == 0)
           {
             result = function->prototypes[i].code(args, context, function);
             break;
            }
          }
          assert(i < MAX_OVERLOADED_FUNCTIONS);
          if (result == ERROR_SUCCESS)
        {
          r1.o = function->return_obj;
          push(r1);
        }
        else
        {
          stop = TRUE;
        }
           result = yr_object_copy(function->return_obj, &r1.o);
         if (result == ERROR_SUCCESS)
           result = yr_arena_write_data(obj_arena, &r1.o, sizeof(r1.o), NULL);
         stop = (result != ERROR_SUCCESS);
         push(r1);
          break;
        case OP_FOUND:
         pop(r1);
         r1.i = r1.s->matches[tidx].tail != NULL ? 1 : 0;
         push(r1);
         break;
       case OP_FOUND_AT:
         pop(r2);
         pop(r1);
         if (is_undef(r1))
         {
           r1.i = 0;
           push(r1);
           break;
         }
         match = r2.s->matches[tidx].head;
         r3.i = FALSE;
         while (match != NULL)
         {
           if (r1.i == match->base + match->offset)
           {
             r3.i = TRUE;
             break;
           }
           if (r1.i < match->base + match->offset)
             break;
           match = match->next;
         }
         push(r3);
         break;
       case OP_FOUND_IN:
         pop(r3);
         pop(r2);
         pop(r1);
         ensure_defined(r1);
         ensure_defined(r2);
         match = r3.s->matches[tidx].head;
         r3.i = FALSE;
         while (match != NULL && !r3.i)
         {
           if (match->base + match->offset >= r1.i &&
               match->base + match->offset <= r2.i)
           {
             r3.i = TRUE;
           }
           if (match->base + match->offset > r2.i)
             break;
           match = match->next;
         }
         push(r3);
         break;
       case OP_COUNT:
         pop(r1);
         r1.i = r1.s->matches[tidx].count;
         push(r1);
         break;
       case OP_OFFSET:
         pop(r2);
         pop(r1);
         ensure_defined(r1);
         match = r2.s->matches[tidx].head;
         i = 1;
         r3.i = UNDEFINED;
         while (match != NULL && r3.i == UNDEFINED)
         {
           if (r1.i == i)
             r3.i = match->base + match->offset;
           i++;
           match = match->next;
         }
         push(r3);
         break;
       case OP_LENGTH:
         pop(r2);
         pop(r1);
         ensure_defined(r1);
         match = r2.s->matches[tidx].head;
         i = 1;
         r3.i = UNDEFINED;
         while (match != NULL && r3.i == UNDEFINED)
         {
           if (r1.i == i)
             r3.i = match->match_length;
           i++;
           match = match->next;
         }
         push(r3);
         break;
       case OP_OF:
         found = 0;
         count = 0;
         pop(r1);
         while (!is_undef(r1))
         {
           if (r1.s->matches[tidx].tail != NULL)
             found++;
           count++;
           pop(r1);
         }
         pop(r2);
         if (is_undef(r2))
           r1.i = found >= count ? 1 : 0;
         else
           r1.i = found >= r2.i ? 1 : 0;
         push(r1);
         break;
       case OP_FILESIZE:
         r1.i = context->file_size;
         push(r1);
         break;
       case OP_ENTRYPOINT:
         r1.i = context->entry_point;
         push(r1);
         break;
       case OP_INT8:
         pop(r1);
         r1.i = read_int8_t_little_endian(context->iterator, (size_t) r1.i);
         push(r1);
         break;
       case OP_INT16:
         pop(r1);
         r1.i = read_int16_t_little_endian(context->iterator, (size_t) r1.i);
         push(r1);
         break;
       case OP_INT32:
         pop(r1);
         r1.i = read_int32_t_little_endian(context->iterator, (size_t) r1.i);
         push(r1);
         break;
       case OP_UINT8:
         pop(r1);
         r1.i = read_uint8_t_little_endian(context->iterator, (size_t) r1.i);
         push(r1);
         break;
       case OP_UINT16:
         pop(r1);
         r1.i = read_uint16_t_little_endian(context->iterator, (size_t) r1.i);
         push(r1);
         break;
       case OP_UINT32:
         pop(r1);
         r1.i = read_uint32_t_little_endian(context->iterator, (size_t) r1.i);
         push(r1);
         break;
       case OP_INT8BE:
         pop(r1);
         r1.i = read_int8_t_big_endian(context->iterator, (size_t) r1.i);
         push(r1);
         break;
       case OP_INT16BE:
         pop(r1);
         r1.i = read_int16_t_big_endian(context->iterator, (size_t) r1.i);
         push(r1);
         break;
       case OP_INT32BE:
         pop(r1);
         r1.i = read_int32_t_big_endian(context->iterator, (size_t) r1.i);
         push(r1);
         break;
       case OP_UINT8BE:
         pop(r1);
         r1.i = read_uint8_t_big_endian(context->iterator, (size_t) r1.i);
         push(r1);
         break;
       case OP_UINT16BE:
         pop(r1);
         r1.i = read_uint16_t_big_endian(context->iterator, (size_t) r1.i);
         push(r1);
         break;
       case OP_UINT32BE:
         pop(r1);
         r1.i = read_uint32_t_big_endian(context->iterator, (size_t) r1.i);
         push(r1);
         break;
       case OP_CONTAINS:
         pop(r2);
         pop(r1);
         ensure_defined(r1);
         ensure_defined(r2);
         r1.i = memmem(r1.ss->c_string, r1.ss->length,
                       r2.ss->c_string, r2.ss->length) != NULL;
         push(r1);
         break;
       case OP_IMPORT:
         r1.i = *(uint64_t*)(ip + 1);
         ip += sizeof(uint64_t);
         result = yr_modules_load((char*) r1.p, context);
         if (result != ERROR_SUCCESS)
           stop = TRUE;
         break;
       case OP_MATCHES:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         if (r1.ss->length == 0)
         {
           r1.i = FALSE;
           push(r1);
           break;
         }
         result = yr_re_exec(
           (uint8_t*) r2.re->code,
           (uint8_t*) r1.ss->c_string,
           r1.ss->length,
           0,
           r2.re->flags | RE_FLAGS_SCAN,
           NULL,
           NULL,
           &found);
         if (result != ERROR_SUCCESS)
           stop = TRUE;
         r1.i = found >= 0;
         push(r1);
         break;
       case OP_INT_TO_DBL:
         r1.i = *(uint64_t*)(ip + 1);
         ip += sizeof(uint64_t);
         r2 = stack[sp - r1.i];
         if (is_undef(r2))
           stack[sp - r1.i].i = UNDEFINED;
         else
           stack[sp - r1.i].d = (double) r2.i;
         break;
       case OP_STR_TO_BOOL:
         pop(r1);
         ensure_defined(r1);
         r1.i = r1.ss->length > 0;
         push(r1);
         break;
       case OP_INT_EQ:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.i = r1.i == r2.i;
         push(r1);
         break;
       case OP_INT_NEQ:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.i = r1.i != r2.i;
         push(r1);
         break;
       case OP_INT_LT:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.i = r1.i < r2.i;
         push(r1);
         break;
       case OP_INT_GT:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.i = r1.i > r2.i;
         push(r1);
         break;
       case OP_INT_LE:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.i = r1.i <= r2.i;
         push(r1);
         break;
       case OP_INT_GE:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.i = r1.i >= r2.i;
         push(r1);
         break;
       case OP_INT_ADD:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.i = r1.i + r2.i;
         push(r1);
         break;
       case OP_INT_SUB:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.i = r1.i - r2.i;
         push(r1);
         break;
       case OP_INT_MUL:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.i = r1.i * r2.i;
         push(r1);
         break;
       case OP_INT_DIV:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         if (r2.i != 0)
           r1.i = r1.i / r2.i;
         else
           r1.i = UNDEFINED;
         push(r1);
         break;
       case OP_INT_MINUS:
         pop(r1);
         ensure_defined(r1);
         r1.i = -r1.i;
         push(r1);
         break;
       case OP_DBL_LT:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.i = r1.d < r2.d;
         push(r1);
         break;
       case OP_DBL_GT:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.i = r1.d > r2.d;
         push(r1);
         break;
       case OP_DBL_LE:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.i = r1.d <= r2.d;
         push(r1);
         break;
       case OP_DBL_GE:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.i = r1.d >= r2.d;
         push(r1);
         break;
       case OP_DBL_EQ:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.i = r1.d == r2.d;
         push(r1);
         break;
       case OP_DBL_NEQ:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.i = r1.d != r2.d;
         push(r1);
         break;
       case OP_DBL_ADD:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.d = r1.d + r2.d;
         push(r1);
         break;
       case OP_DBL_SUB:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.d = r1.d - r2.d;
         push(r1);
         break;
       case OP_DBL_MUL:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.d = r1.d * r2.d;
         push(r1);
         break;
       case OP_DBL_DIV:
         pop(r2);
         pop(r1);
         ensure_defined(r2);
         ensure_defined(r1);
         r1.d = r1.d / r2.d;
         push(r1);
         break;
       case OP_DBL_MINUS:
         pop(r1);
         ensure_defined(r1);
         r1.d = -r1.d;
         push(r1);
         break;
       case OP_STR_EQ:
       case OP_STR_NEQ:
       case OP_STR_LT:
       case OP_STR_LE:
       case OP_STR_GT:
       case OP_STR_GE:
         pop(r2);
         pop(r1);
         ensure_defined(r1);
         ensure_defined(r2);
         switch(*ip)
         {
           case OP_STR_EQ:
             r1.i = (sized_string_cmp(r1.ss, r2.ss) == 0);
             break;
           case OP_STR_NEQ:
             r1.i = (sized_string_cmp(r1.ss, r2.ss) != 0);
             break;
           case OP_STR_LT:
             r1.i = (sized_string_cmp(r1.ss, r2.ss) < 0);
             break;
           case OP_STR_LE:
             r1.i = (sized_string_cmp(r1.ss, r2.ss) <= 0);
             break;
           case OP_STR_GT:
             r1.i = (sized_string_cmp(r1.ss, r2.ss) > 0);
             break;
           case OP_STR_GE:
             r1.i = (sized_string_cmp(r1.ss, r2.ss) >= 0);
             break;
         }
         push(r1);
         break;
       default:
         assert(FALSE);
     }
     if (timeout > 0)   
     {
       if (++cycle == 10)
       {
         if (difftime(time(NULL), start_time) > timeout)
         {
           #ifdef PROFILING_ENABLED
           assert(current_rule != NULL);
           current_rule->clock_ticks += clock() - start;
           #endif
           result = ERROR_SCAN_TIMEOUT;
           stop = TRUE;
         }
         cycle = 0;
       }
     }
      ip++;
    }
   obj_ptr = (YR_OBJECT**) yr_arena_base_address(obj_arena);
   while (obj_ptr != NULL)
   {
     yr_object_destroy(*obj_ptr);
     obj_ptr = (YR_OBJECT**) yr_arena_next_address(
         obj_arena, obj_ptr, sizeof(YR_OBJECT*));
   }
   yr_arena_destroy(obj_arena);
    yr_modules_unload_all(context);
    yr_free(stack);
   return result;
 }","[21, 22, 40, 41, 42, 241, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 817, 818, 819, 820, 821, 822, 823, 824]",The sized_string_cmp function in libyara/sizedstr.c in YARA 3.5.0 allows remote attackers to cause a denial of service (use-after-free and application crash) via a crafted rule.,yara,CVE-2017-8929,CWE-416
6394,181920," int jas_stream_write(jas_stream_t *stream, const void *buf, int cnt)
 {
  	int n;
  	const char *bufptr;
 	if (cnt < 0) {
 		jas_deprecated(""negative count for jas_stream_write"");
 	}
  	bufptr = buf;
  	n = 0;
 	while (n < cnt) {
 		if (jas_stream_putc(stream, *bufptr) == EOF) {
 			return n;
 		}
 		++bufptr;
 		++n;
 	}
 	return n;
 }","[5, 6, 7]","Multiple integer overflows in the (1) jas_realloc function in base/jas_malloc.c and (2) mem_resize function in base/jas_stream.c in JasPer before 1.900.22 allow remote attackers to cause a denial of service via a crafted image, which triggers use after free vulnerabilities.",jasper,CVE-2016-9262,CWE-190
6396,183318," tPacketIndicationType ParaNdis_PrepareReceivedPacket(
     PARANDIS_ADAPTER *pContext,
     pRxNetDescriptor pBuffersDesc,
     PUINT            pnCoalescedSegmentsCount)
 {
     PMDL pMDL = pBuffersDesc->Holder;
     PNET_BUFFER_LIST pNBL = NULL;
     *pnCoalescedSegmentsCount = 1;
     if (pMDL)
     {
         ULONG nBytesStripped = 0;
         PNET_PACKET_INFO pPacketInfo = &pBuffersDesc->PacketInfo;
         if (pContext->ulPriorityVlanSetting && pPacketInfo->hasVlanHeader)
         {
             nBytesStripped = ParaNdis_StripVlanHeaderMoveHead(pPacketInfo);
         }
         ParaNdis_PadPacketToMinimalLength(pPacketInfo);
         ParaNdis_AdjustRxBufferHolderLength(pBuffersDesc, nBytesStripped);
         pNBL = NdisAllocateNetBufferAndNetBufferList(pContext->BufferListsPool, 0, 0, pMDL, nBytesStripped, pPacketInfo->dataLength);
         if (pNBL)
         {
             virtio_net_hdr_basic *pHeader = (virtio_net_hdr_basic *) pBuffersDesc->PhysicalPages[0].Virtual;
             tChecksumCheckResult csRes;
             pNBL->SourceHandle = pContext->MiniportHandle;
             NBLSetRSSInfo(pContext, pNBL, pPacketInfo);
             NBLSet8021QInfo(pContext, pNBL, pPacketInfo);
             pNBL->MiniportReserved[0] = pBuffersDesc;
 #if PARANDIS_SUPPORT_RSC
             if(pHeader->gso_type != VIRTIO_NET_HDR_GSO_NONE)
             {
                 *pnCoalescedSegmentsCount = PktGetTCPCoalescedSegmentsCount(pPacketInfo, pContext->MaxPacketSize.nMaxDataSize);
                 NBLSetRSCInfo(pContext, pNBL, pPacketInfo, *pnCoalescedSegmentsCount);
             }
             else
 #endif
             {
                 csRes = ParaNdis_CheckRxChecksum(
                     pContext,
                      pHeader->flags,
                      &pBuffersDesc->PhysicalPages[PARANDIS_FIRST_RX_DATA_PAGE],
                      pPacketInfo->dataLength,
                    nBytesStripped);
                     nBytesStripped, TRUE);
                  if (csRes.value)
                  {
                      NDIS_TCP_IP_CHECKSUM_NET_BUFFER_LIST_INFO qCSInfo;
                     qCSInfo.Value = NULL;
                     qCSInfo.Receive.IpChecksumFailed = csRes.flags.IpFailed;
                     qCSInfo.Receive.IpChecksumSucceeded = csRes.flags.IpOK;
                     qCSInfo.Receive.TcpChecksumFailed = csRes.flags.TcpFailed;
                     qCSInfo.Receive.TcpChecksumSucceeded = csRes.flags.TcpOK;
                     qCSInfo.Receive.UdpChecksumFailed = csRes.flags.UdpFailed;
                     qCSInfo.Receive.UdpChecksumSucceeded = csRes.flags.UdpOK;
                     NET_BUFFER_LIST_INFO(pNBL, TcpIpChecksumNetBufferListInfo) = qCSInfo.Value;
                     DPrintf(1, (""Reporting CS %X->%X\n"", csRes.value, (ULONG)(ULONG_PTR)qCSInfo.Value));
                 }
             }
             pNBL->Status = NDIS_STATUS_SUCCESS;
 #if defined(ENABLE_HISTORY_LOG)
             {
                 tTcpIpPacketParsingResult packetReview = ParaNdis_CheckSumVerify(
                     RtlOffsetToPointer(pPacketInfo->headersBuffer, ETH_HEADER_SIZE),
                     pPacketInfo->dataLength,
                     pcrIpChecksum | pcrTcpChecksum | pcrUdpChecksum,
                     __FUNCTION__
                     );
                 ParaNdis_DebugHistory(pContext, hopPacketReceived, pNBL, pPacketInfo->dataLength, (ULONG)(ULONG_PTR)qInfo.Value, packetReview.value);
             }
 #endif
         }
     }
     return pNBL;
 }","[42, 43]","The NetKVM Windows Virtio driver allows remote attackers to cause a denial of service (guest crash) via a crafted length value in an IP packet, as demonstrated by a value that does not account for the size of the IP options.",kvm-guest-drivers-windows,CVE-2015-3215,CWE-20
6444,178610," ProcRenderSetPictureFilter(ClientPtr client)
 {
     REQUEST(xRenderSetPictureFilterReq);
     PicturePtr pPicture;
     int result;
     xFixed *params;
     int nparams;
     char *name;
     REQUEST_AT_LEAST_SIZE(xRenderSetPictureFilterReq);
     VERIFY_PICTURE(pPicture, stuff->picture, client, DixSetAttrAccess);
      name = (char *) (stuff + 1);
      params = (xFixed *) (name + pad_to_int32(stuff->nbytes));
      nparams = ((xFixed *) stuff + client->req_len) - params;
     if (nparams < 0)
 	return BadLength;
      result = SetPictureFilter(pPicture, name, stuff->nbytes, params, nparams);
      return result;
  }","[14, 15]",xorg-x11-server before 1.19.5 was missing length validation in RENDER extension allowing malicious X client to cause X server to crash or possibly execute arbitrary code.,xserver,CVE-2017-12187,CWE-20
6456,181881," jas_matrix_t *jas_seq2d_create(int xstart, int ystart, int xend, int yend)
 jas_matrix_t *jas_seq2d_create(jas_matind_t xstart, jas_matind_t ystart,
   jas_matind_t xend, jas_matind_t yend)
  {
  	jas_matrix_t *matrix;
  	assert(xstart <= xend && ystart <= yend);
 	if (!(matrix = jas_matrix_create(yend - ystart, xend - xstart))) {
 		return 0;
 	}
 	matrix->xstart_ = xstart;
 	matrix->ystart_ = ystart;
 	matrix->xend_ = xend;
 	matrix->yend_ = yend;
  	return matrix;
  }","[2, 3]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
6470,183311," tChecksumCheckResult ParaNdis_CheckRxChecksum(
                                             PARANDIS_ADAPTER *pContext,
                                              ULONG virtioFlags,
                                              tCompletePhysicalAddress *pPacketPages,
                                              ULONG ulPacketLength,
                                            ULONG ulDataOffset)
                                             ULONG ulDataOffset,
                                             BOOLEAN verifyLength)
  {
      tOffloadSettingsFlags f = pContext->Offload.flags;
      tChecksumCheckResult res;
     tTcpIpPacketParsingResult ppr;
     ULONG flagsToCalculate = 0;
     res.value = 0;
     if (f.fRxIPChecksum) flagsToCalculate |= pcrIpChecksum;  
     if (!(virtioFlags & VIRTIO_NET_HDR_F_DATA_VALID))
     {
         if (virtioFlags & VIRTIO_NET_HDR_F_NEEDS_CSUM)
         {
             flagsToCalculate |= pcrFixXxpChecksum | pcrTcpChecksum | pcrUdpChecksum;
         }
         else
         {
             if (f.fRxTCPChecksum) flagsToCalculate |= pcrTcpV4Checksum;
             if (f.fRxUDPChecksum) flagsToCalculate |= pcrUdpV4Checksum;
             if (f.fRxTCPv6Checksum) flagsToCalculate |= pcrTcpV6Checksum;
             if (f.fRxUDPv6Checksum) flagsToCalculate |= pcrUdpV6Checksum;
          }
      }
    ppr = ParaNdis_CheckSumVerify(pPacketPages, ulPacketLength - ETH_HEADER_SIZE, ulDataOffset + ETH_HEADER_SIZE, flagsToCalculate, __FUNCTION__);
     ppr = ParaNdis_CheckSumVerify(pPacketPages, ulPacketLength - ETH_HEADER_SIZE, ulDataOffset + ETH_HEADER_SIZE, flagsToCalculate,
         verifyLength, __FUNCTION__);
      if (ppr.ipCheckSum == ppresIPTooShort || ppr.xxpStatus == ppresXxpIncomplete)
      {
         res.flags.IpOK = FALSE;
         res.flags.IpFailed = TRUE;
         return res;
     }
     if (virtioFlags & VIRTIO_NET_HDR_F_DATA_VALID)
     {
         pContext->extraStatistics.framesRxCSHwOK++;
         ppr.xxpCheckSum = ppresCSOK;
     }
     if (ppr.ipStatus == ppresIPV4 && !ppr.IsFragment)
     {
         if (f.fRxIPChecksum)
         {
             res.flags.IpOK =  ppr.ipCheckSum == ppresCSOK;
             res.flags.IpFailed = ppr.ipCheckSum == ppresCSBad;
         }
         if(ppr.xxpStatus == ppresXxpKnown)
         {
             if(ppr.TcpUdp == ppresIsTCP)  
             {
                 if (f.fRxTCPChecksum)
                 {
                     res.flags.TcpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS;
                     res.flags.TcpFailed = !res.flags.TcpOK;
                 }
             }
             else  
             {
                 if (f.fRxUDPChecksum)
                 {
                     res.flags.UdpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS;
                     res.flags.UdpFailed = !res.flags.UdpOK;
                 }
             }
         }
     }
     else if (ppr.ipStatus == ppresIPV6)
     {
         if(ppr.xxpStatus == ppresXxpKnown)
         {
             if(ppr.TcpUdp == ppresIsTCP)  
             {
                 if (f.fRxTCPv6Checksum)
                 {
                     res.flags.TcpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS;
                     res.flags.TcpFailed = !res.flags.TcpOK;
                 }
             }
             else  
             {
                 if (f.fRxUDPv6Checksum)
                 {
                     res.flags.UdpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS;
                     res.flags.UdpFailed = !res.flags.UdpOK;
                 }
             }
         }
     }
     return res;
 }","[6, 7, 8, 30, 31, 32]","The NetKVM Windows Virtio driver allows remote attackers to cause a denial of service (guest crash) via a crafted length value in an IP packet, as demonstrated by a value that does not account for the size of the IP options.",kvm-guest-drivers-windows,CVE-2015-3215,CWE-20
6473,182960," GF_Err cat_multiple_files(GF_ISOFile *dest, char *fileName, u32 import_flags, Double force_fps, u32 frames_per_sample, char *tmp_dir, Bool force_cat, Bool align_timelines, Bool allow_add_in_command)
 {
 	CATEnum cat_enum;
 	char *sep;
 	cat_enum.dest = dest;
 	cat_enum.import_flags = import_flags;
 	cat_enum.force_fps = force_fps;
 	cat_enum.frames_per_sample = frames_per_sample;
 	cat_enum.tmp_dir = tmp_dir;
 	cat_enum.force_cat = force_cat;
  	cat_enum.align_timelines = align_timelines;
  	cat_enum.allow_add_in_command = allow_add_in_command;
 	if (strlen(fileName) >= sizeof(cat_enum.szPath)) {
 		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""File name %s is too long.\n"", fileName));
 		return GF_NOT_SUPPORTED;
 	}
  	strcpy(cat_enum.szPath, fileName);
  	sep = strrchr(cat_enum.szPath, GF_PATH_SEPARATOR);
  	if (!sep) sep = strrchr(cat_enum.szPath, '/');
  	if (!sep) {
  		strcpy(cat_enum.szPath, ""."");
 		if (strlen(fileName) >= sizeof(cat_enum.szRad1)) {
 			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""File name %s is too long.\n"", fileName));
 			return GF_NOT_SUPPORTED;
 		}
  		strcpy(cat_enum.szRad1, fileName);
  	} else {
 		if (strlen(sep + 1) >= sizeof(cat_enum.szRad1)) {
 			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""File name %s is too long.\n"", (sep + 1)));
 			return GF_NOT_SUPPORTED;
 		}
  		strcpy(cat_enum.szRad1, sep+1);
  		sep[0] = 0;
  	}
  	sep = strchr(cat_enum.szRad1, '*');
 	if (strlen(sep + 1) >= sizeof(cat_enum.szRad2)) {
 		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""File name %s is too long.\n"", (sep + 1)));
 		return GF_NOT_SUPPORTED;
 	}
  	strcpy(cat_enum.szRad2, sep+1);
  	sep[0] = 0;
  	sep = strchr(cat_enum.szRad2, '%');
  	if (!sep) sep = strchr(cat_enum.szRad2, '#');
  	if (!sep) sep = strchr(cat_enum.szRad2, ':');
  	strcpy(cat_enum.szOpt, """");
  	if (sep) {
 		if (strlen(sep) >= sizeof(cat_enum.szOpt)) {
 			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""Invalid option: %s.\n"", sep));
 			return GF_NOT_SUPPORTED;
 		}
  		strcpy(cat_enum.szOpt, sep);
  		sep[0] = 0;
  	}
 	return gf_enum_directory(cat_enum.szPath, 0, cat_enumerate, &cat_enum, NULL);
 }","[13, 14, 15, 16, 22, 23, 24, 25, 28, 29, 30, 31, 36, 37, 38, 39, 47, 48, 49, 50]",GPAC version 0.7.1 and earlier has a buffer overflow vulnerability in the cat_multiple_files function in applications/mp4box/fileimport.c when MP4Box is used for a local directory containing crafted filenames.,gpac,CVE-2018-20762,CWE-119
6474,178130," void vrend_clear(struct vrend_context *ctx,
                  unsigned buffers,
                  const union pipe_color_union *color,
                  double depth, unsigned stencil)
 {
    GLbitfield bits = 0;
    if (ctx->in_error)
       return;
    if (ctx->ctx_switch_pending)
       vrend_finish_context_switch(ctx);
    glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, ctx->sub->fb_id);
    vrend_update_frontface_state(ctx);
    if (ctx->sub->stencil_state_dirty)
       vrend_update_stencil_state(ctx);
    if (ctx->sub->scissor_state_dirty)
       vrend_update_scissor_state(ctx);
    if (ctx->sub->viewport_state_dirty)
       vrend_update_viewport_state(ctx);
    vrend_use_program(ctx, 0);
    if (buffers & PIPE_CLEAR_COLOR) {
       if (ctx->sub->nr_cbufs && ctx->sub->surf[0] && vrend_format_is_emulated_alpha(ctx->sub->surf[0]->format)) {
          glClearColor(color->f[3], 0.0, 0.0, 0.0);
       } else {
          glClearColor(color->f[0], color->f[1], color->f[2], color->f[3]);
       }
    }
    if (buffers & PIPE_CLEAR_DEPTH) {
       glDepthMask(GL_TRUE);
       glClearDepth(depth);
    }
    if (buffers & PIPE_CLEAR_STENCIL)
       glClearStencil(stencil);
    if (buffers & PIPE_CLEAR_COLOR) {
       uint32_t mask = 0;
       int i;
       for (i = 0; i < ctx->sub->nr_cbufs; i++) {
          if (ctx->sub->surf[i])
             mask |= (1 << i);
       }
       if (mask != (buffers >> 2)) {
           mask = buffers >> 2;
           while (mask) {
              i = u_bit_scan(&mask);
            if (util_format_is_pure_uint(ctx->sub->surf[i]->format))
             if (i < PIPE_MAX_COLOR_BUFS && ctx->sub->surf[i] && util_format_is_pure_uint(ctx->sub->surf[i] && ctx->sub->surf[i]->format))
                 glClearBufferuiv(GL_COLOR,
                                  i, (GLuint *)color);
            else if (util_format_is_pure_sint(ctx->sub->surf[i]->format))
             else if (i < PIPE_MAX_COLOR_BUFS && ctx->sub->surf[i] && util_format_is_pure_sint(ctx->sub->surf[i] && ctx->sub->surf[i]->format))
                 glClearBufferiv(GL_COLOR,
                                  i, (GLint *)color);
              else
                glClearBufferfv(GL_COLOR,
                                 i, (GLfloat *)color);
          }
       }
       else
          bits |= GL_COLOR_BUFFER_BIT;
    }
    if (buffers & PIPE_CLEAR_DEPTH)
       bits |= GL_DEPTH_BUFFER_BIT;
    if (buffers & PIPE_CLEAR_STENCIL)
       bits |= GL_STENCIL_BUFFER_BIT;
    if (bits)
       glClear(bits);
    if (buffers & PIPE_CLEAR_DEPTH)
       if (!ctx->sub->dsa_state.depth.writemask)
          glDepthMask(GL_FALSE);
 }","[44, 45, 48, 49]",The util_format_is_pure_uint function in vrend_renderer.c in Virgil 3d project (aka virglrenderer) 0.6.0 and earlier allows local guest OS users to cause a denial of service (NULL pointer dereference) via a crafted VIRGL_CCMD_CLEAR command.,virglrenderer,CVE-2017-5937,CWE-476
6490,181905," int jpc_bitstream_putbits(jpc_bitstream_t *bitstream, int n, long v)
 {
 	int m;
	assert(n >= 0 && n < 32);
 	if (n < 0 || n >= 32) {
 		return EOF;
 	}
  	assert(!(v & (~JAS_ONES(n))));
 	m = n - 1;
 	while (--n >= 0) {
 		if (jpc_bitstream_putbit(bitstream, (v >> m) & 1) == EOF) {
 			return EOF;
 		}
 		v <<= 1;
 	}
 	return 0;
 }","[4, 5, 6, 7]",The jpc_bitstream_getbits function in jpc_bs.c in JasPer before 2.0.10 allows remote attackers to cause a denial of service (assertion failure) via a very large integer.,jasper,CVE-2016-9391,
6491,178611," ProcXFixesSetCursorName(ClientPtr client)
 {
     CursorPtr pCursor;
     char *tchar;
     REQUEST(xXFixesSetCursorNameReq);
      REQUEST(xXFixesSetCursorNameReq);
      Atom atom;
    REQUEST_AT_LEAST_SIZE(xXFixesSetCursorNameReq);
     REQUEST_FIXED_SIZE(xXFixesSetCursorNameReq, stuff->nbytes);
      VERIFY_CURSOR(pCursor, stuff->cursor, client, DixSetAttrAccess);
      tchar = (char *) &stuff[1];
      atom = MakeAtom(tchar, stuff->nbytes, TRUE);
         return BadAlloc;
     pCursor->name = atom;
     return Success;
 }","[8, 9]",xorg-x11-server before 1.19.5 was missing length validation in XFIXES extension allowing malicious X client to cause X server to crash or possibly execute arbitrary code.,xserver,CVE-2017-12183,CWE-20
6500,179578,"  findoprnd(ITEM *ptr, int32 *pos)
  {
 	check_stack_depth();
  	if (ptr[*pos].type == VAL || ptr[*pos].type == VALTRUE)
  	{
  		ptr[*pos].left = 0;
 		(*pos)++;
 	}
 	else if (ptr[*pos].val == (int32) '!')
 	{
 		ptr[*pos].left = 1;
 		(*pos)++;
 		findoprnd(ptr, pos);
 	}
 	else
 	{
 		ITEM	   *curitem = &ptr[*pos];
 		int32		tmp = *pos;
 		(*pos)++;
 		findoprnd(ptr, pos);
 		curitem->left = *pos - tmp;
 		findoprnd(ptr, pos);
 	}
 }",[3],"Multiple integer overflows in contrib/hstore/hstore_io.c in PostgreSQL 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact via vectors related to the (1) hstore_recv, (2) hstore_from_arrays, and (3) hstore_from_array functions in contrib/hstore/hstore_io.c; and the (4) hstoreArrayToPairs function in contrib/hstore/hstore_op.c, which triggers a buffer overflow.  NOTE: this issue was SPLIT from CVE-2014-0064 because it has a different set of affected versions.",postgres,CVE-2014-2669,CWE-189
6502,181418," void avcodec_align_dimensions2(AVCodecContext *s, int *width, int *height,
                                int linesize_align[AV_NUM_DATA_POINTERS])
 {
     int i;
     int w_align = 1;
     int h_align = 1;
     AVPixFmtDescriptor const *desc = av_pix_fmt_desc_get(s->pix_fmt);
     if (desc) {
         w_align = 1 << desc->log2_chroma_w;
         h_align = 1 << desc->log2_chroma_h;
     }
     switch (s->pix_fmt) {
     case AV_PIX_FMT_YUV420P:
     case AV_PIX_FMT_YUYV422:
     case AV_PIX_FMT_YVYU422:
     case AV_PIX_FMT_UYVY422:
     case AV_PIX_FMT_YUV422P:
     case AV_PIX_FMT_YUV440P:
     case AV_PIX_FMT_YUV444P:
     case AV_PIX_FMT_GBRP:
     case AV_PIX_FMT_GBRAP:
     case AV_PIX_FMT_GRAY8:
     case AV_PIX_FMT_GRAY16BE:
     case AV_PIX_FMT_GRAY16LE:
     case AV_PIX_FMT_YUVJ420P:
     case AV_PIX_FMT_YUVJ422P:
     case AV_PIX_FMT_YUVJ440P:
     case AV_PIX_FMT_YUVJ444P:
     case AV_PIX_FMT_YUVA420P:
     case AV_PIX_FMT_YUVA422P:
     case AV_PIX_FMT_YUVA444P:
     case AV_PIX_FMT_YUV420P9LE:
     case AV_PIX_FMT_YUV420P9BE:
     case AV_PIX_FMT_YUV420P10LE:
     case AV_PIX_FMT_YUV420P10BE:
     case AV_PIX_FMT_YUV420P12LE:
     case AV_PIX_FMT_YUV420P12BE:
     case AV_PIX_FMT_YUV420P14LE:
     case AV_PIX_FMT_YUV420P14BE:
     case AV_PIX_FMT_YUV420P16LE:
     case AV_PIX_FMT_YUV420P16BE:
     case AV_PIX_FMT_YUVA420P9LE:
     case AV_PIX_FMT_YUVA420P9BE:
     case AV_PIX_FMT_YUVA420P10LE:
     case AV_PIX_FMT_YUVA420P10BE:
     case AV_PIX_FMT_YUVA420P16LE:
     case AV_PIX_FMT_YUVA420P16BE:
     case AV_PIX_FMT_YUV422P9LE:
     case AV_PIX_FMT_YUV422P9BE:
     case AV_PIX_FMT_YUV422P10LE:
     case AV_PIX_FMT_YUV422P10BE:
     case AV_PIX_FMT_YUV422P12LE:
     case AV_PIX_FMT_YUV422P12BE:
     case AV_PIX_FMT_YUV422P14LE:
     case AV_PIX_FMT_YUV422P14BE:
     case AV_PIX_FMT_YUV422P16LE:
     case AV_PIX_FMT_YUV422P16BE:
     case AV_PIX_FMT_YUVA422P9LE:
     case AV_PIX_FMT_YUVA422P9BE:
     case AV_PIX_FMT_YUVA422P10LE:
     case AV_PIX_FMT_YUVA422P10BE:
     case AV_PIX_FMT_YUVA422P16LE:
     case AV_PIX_FMT_YUVA422P16BE:
     case AV_PIX_FMT_YUV440P10LE:
     case AV_PIX_FMT_YUV440P10BE:
     case AV_PIX_FMT_YUV440P12LE:
     case AV_PIX_FMT_YUV440P12BE:
     case AV_PIX_FMT_YUV444P9LE:
     case AV_PIX_FMT_YUV444P9BE:
     case AV_PIX_FMT_YUV444P10LE:
     case AV_PIX_FMT_YUV444P10BE:
     case AV_PIX_FMT_YUV444P12LE:
     case AV_PIX_FMT_YUV444P12BE:
     case AV_PIX_FMT_YUV444P14LE:
     case AV_PIX_FMT_YUV444P14BE:
     case AV_PIX_FMT_YUV444P16LE:
     case AV_PIX_FMT_YUV444P16BE:
     case AV_PIX_FMT_YUVA444P9LE:
     case AV_PIX_FMT_YUVA444P9BE:
     case AV_PIX_FMT_YUVA444P10LE:
     case AV_PIX_FMT_YUVA444P10BE:
     case AV_PIX_FMT_YUVA444P16LE:
     case AV_PIX_FMT_YUVA444P16BE:
     case AV_PIX_FMT_GBRP9LE:
     case AV_PIX_FMT_GBRP9BE:
     case AV_PIX_FMT_GBRP10LE:
     case AV_PIX_FMT_GBRP10BE:
     case AV_PIX_FMT_GBRP12LE:
     case AV_PIX_FMT_GBRP12BE:
     case AV_PIX_FMT_GBRP14LE:
     case AV_PIX_FMT_GBRP14BE:
     case AV_PIX_FMT_GBRP16LE:
     case AV_PIX_FMT_GBRP16BE:
     case AV_PIX_FMT_GBRAP12LE:
     case AV_PIX_FMT_GBRAP12BE:
     case AV_PIX_FMT_GBRAP16LE:
     case AV_PIX_FMT_GBRAP16BE:
         w_align = 16;  
         h_align = 16 * 2;  
         break;
     case AV_PIX_FMT_YUV411P:
     case AV_PIX_FMT_YUVJ411P:
     case AV_PIX_FMT_UYYVYY411:
         w_align = 32;
         h_align = 16 * 2;
         break;
     case AV_PIX_FMT_YUV410P:
         if (s->codec_id == AV_CODEC_ID_SVQ1) {
             w_align = 64;
             h_align = 64;
         }
         break;
     case AV_PIX_FMT_RGB555:
         if (s->codec_id == AV_CODEC_ID_RPZA) {
              w_align = 4;
              h_align = 4;
          }
         if (s->codec_id == AV_CODEC_ID_INTERPLAY_VIDEO) {
             w_align = 8;
             h_align = 8;
         }
          break;
      case AV_PIX_FMT_PAL8:
      case AV_PIX_FMT_BGR8:
     case AV_PIX_FMT_RGB8:
         if (s->codec_id == AV_CODEC_ID_SMC ||
             s->codec_id == AV_CODEC_ID_CINEPAK) {
              w_align = 4;
              h_align = 4;
          }
        if (s->codec_id == AV_CODEC_ID_JV) {
         if (s->codec_id == AV_CODEC_ID_JV ||
             s->codec_id == AV_CODEC_ID_INTERPLAY_VIDEO) {
              w_align = 8;
              h_align = 8;
          }
         break;
     case AV_PIX_FMT_BGR24:
         if ((s->codec_id == AV_CODEC_ID_MSZH) ||
             (s->codec_id == AV_CODEC_ID_ZLIB)) {
             w_align = 4;
             h_align = 4;
         }
         break;
     case AV_PIX_FMT_RGB24:
         if (s->codec_id == AV_CODEC_ID_CINEPAK) {
             w_align = 4;
             h_align = 4;
         }
         break;
     default:
         break;
     }
     if (s->codec_id == AV_CODEC_ID_IFF_ILBM) {
         w_align = FFMAX(w_align, 8);
     }
     *width  = FFALIGN(*width, w_align);
     *height = FFALIGN(*height, h_align);
     if (s->codec_id == AV_CODEC_ID_H264 || s->lowres) {
         *height += 2;
         *width = FFMAX(*width, 32);
     }
     for (i = 0; i < 4; i++)
         linesize_align[i] = STRIDE_ALIGN;
 }","[118, 119, 120, 121, 131, 132, 133]",FFmpeg before 2017-01-24 has an out-of-bounds write caused by a heap-based buffer overflow related to the ipvideo_decode_block_opcode_0xA function in libavcodec/interplayvideo.c and the avcodec_align_dimensions2 function in libavcodec/utils.c.,FFmpeg,CVE-2017-7865,CWE-787
6510,181936," read_Header(struct archive_read *a, struct _7z_header_info *h,
     int check_header_id)
 {
 	struct _7zip *zip = (struct _7zip *)a->format->data;
 	const unsigned char *p;
 	struct _7z_folder *folders;
 	struct _7z_stream_info *si = &(zip->si);
 	struct _7zip_entry *entries;
 	uint32_t folderIndex, indexInFolder;
 	unsigned i;
 	int eindex, empty_streams, sindex;
 	if (check_header_id) {
 		if ((p = header_bytes(a, 1)) == NULL)
 			return (-1);
 		if (*p != kHeader)
 			return (-1);
 	}
 	if ((p = header_bytes(a, 1)) == NULL)
 		return (-1);
 	if (*p == kArchiveProperties) {
 		for (;;) {
 			uint64_t size;
 			if ((p = header_bytes(a, 1)) == NULL)
 				return (-1);
 			if (*p == 0)
 				break;
 			if (parse_7zip_uint64(a, &size) < 0)
 				return (-1);
 		}
 		if ((p = header_bytes(a, 1)) == NULL)
 			return (-1);
 	}
 	if (*p == kMainStreamsInfo) {
 		if (read_StreamsInfo(a, &(zip->si)) < 0)
 			return (-1);
 		if ((p = header_bytes(a, 1)) == NULL)
 			return (-1);
 	}
 	if (*p == kEnd)
 		return (0);
 	if (*p != kFilesInfo)
 		return (-1);
 	if (parse_7zip_uint64(a, &(zip->numFiles)) < 0)
 		return (-1);
 	if (UMAX_ENTRY < zip->numFiles)
 		return (-1);
 	zip->entries = calloc((size_t)zip->numFiles, sizeof(*zip->entries));
 	if (zip->entries == NULL)
 		return (-1);
 	entries = zip->entries;
 	empty_streams = 0;
 	for (;;) {
 		int type;
 		uint64_t size;
 		size_t ll;
 		if ((p = header_bytes(a, 1)) == NULL)
 			return (-1);
 		type = *p;
 		if (type == kEnd)
 			break;
 		if (parse_7zip_uint64(a, &size) < 0)
 			return (-1);
 		if (zip->header_bytes_remaining < size)
 			return (-1);
 		ll = (size_t)size;
  		switch (type) {
  		case kEmptyStream:
 			if (h->emptyStreamBools != NULL)
 				return (-1);
  			h->emptyStreamBools = calloc((size_t)zip->numFiles,
  			    sizeof(*h->emptyStreamBools));
  			if (h->emptyStreamBools == NULL)
 				return (-1);
 			if (read_Bools(
 			    a, h->emptyStreamBools, (size_t)zip->numFiles) < 0)
 				return (-1);
 			empty_streams = 0;
 			for (i = 0; i < zip->numFiles; i++) {
 				if (h->emptyStreamBools[i])
 					empty_streams++;
 			}
 			break;
 		case kEmptyFile:
 			if (empty_streams <= 0) {
 				if (header_bytes(a, ll) == NULL)
  					return (-1);
  				break;
  			}
 			if (h->emptyFileBools != NULL)
 				return (-1);
  			h->emptyFileBools = calloc(empty_streams,
  			    sizeof(*h->emptyFileBools));
  			if (h->emptyFileBools == NULL)
 				return (-1);
 			if (read_Bools(a, h->emptyFileBools, empty_streams) < 0)
 				return (-1);
 			break;
 		case kAnti:
 			if (empty_streams <= 0) {
 				if (header_bytes(a, ll) == NULL)
  					return (-1);
  				break;
  			}
 			if (h->antiBools != NULL)
 				return (-1);
  			h->antiBools = calloc(empty_streams,
  			    sizeof(*h->antiBools));
  			if (h->antiBools == NULL)
 				return (-1);
 			if (read_Bools(a, h->antiBools, empty_streams) < 0)
 				return (-1);
 			break;
 		case kCTime:
 		case kATime:
 		case kMTime:
 			if (read_Times(a, h, type) < 0)
 				return (-1);
 			break;
 		case kName:
 		{
 			unsigned char *np;
 			size_t nl, nb;
 			if ((p = header_bytes(a, 1)) == NULL)
 				return (-1);
 			ll--;
  			if ((ll & 1) || ll < zip->numFiles * 4)
  				return (-1);
 			if (zip->entry_names != NULL)
 				return (-1);
  			zip->entry_names = malloc(ll);
  			if (zip->entry_names == NULL)
  				return (-1);
 			np = zip->entry_names;
 			nb = ll;
 			while (nb) {
 				size_t b;
 				if (nb > UBUFF_SIZE)
 					b = UBUFF_SIZE;
 				else
 					b = nb;
 				if ((p = header_bytes(a, b)) == NULL)
 					return (-1);
 				memcpy(np, p, b);
 				np += b;
 				nb -= b;
 			}
 			np = zip->entry_names;
 			nl = ll;
 			for (i = 0; i < zip->numFiles; i++) {
 				entries[i].utf16name = np;
 #if defined(_WIN32) && !defined(__CYGWIN__) && defined(_DEBUG)
 				entries[i].wname = (wchar_t *)np;
 #endif
 				while (nl >= 2 && (np[0] || np[1])) {
 					np += 2;
 					nl -= 2;
 				}
 				if (nl < 2)
 					return (-1); 
 				entries[i].name_len = np - entries[i].utf16name;
 				np += 2;
 				nl -= 2;
 			}
 			break;
 		}
 		case kAttributes:
 		{
 			int allAreDefined;
  			if ((p = header_bytes(a, 2)) == NULL)
  				return (-1);
  			allAreDefined = *p;
 			if (h->attrBools != NULL)
 				return (-1);
  			h->attrBools = calloc((size_t)zip->numFiles,
  			    sizeof(*h->attrBools));
  			if (h->attrBools == NULL)
 				return (-1);
 			if (allAreDefined)
 				memset(h->attrBools, 1, (size_t)zip->numFiles);
 			else {
 				if (read_Bools(a, h->attrBools,
 				      (size_t)zip->numFiles) < 0)
 					return (-1);
 			}
 			for (i = 0; i < zip->numFiles; i++) {
 				if (h->attrBools[i]) {
 					if ((p = header_bytes(a, 4)) == NULL)
 						return (-1);
 					entries[i].attr = archive_le32dec(p);
 				}
 			}
 			break;
 		}
 		case kDummy:
 			if (ll == 0)
 				break;
 		default:
 			if (header_bytes(a, ll) == NULL)
 				return (-1);
 			break;
 		}
 	}
 	folders = si->ci.folders;
 	eindex = sindex = 0;
 	folderIndex = indexInFolder = 0;
 	for (i = 0; i < zip->numFiles; i++) {
 		if (h->emptyStreamBools == NULL || h->emptyStreamBools[i] == 0)
 			entries[i].flg |= HAS_STREAM;
 		entries[i].mode = entries[i].attr >> 16;
 		if (entries[i].flg & HAS_STREAM) {
 			if ((size_t)sindex >= si->ss.unpack_streams)
 				return (-1);
 			if (entries[i].mode == 0)
 				entries[i].mode = AE_IFREG | 0666;
 			if (si->ss.digestsDefined[sindex])
 				entries[i].flg |= CRC32_IS_SET;
 			entries[i].ssIndex = sindex;
 			sindex++;
 		} else {
 			int dir;
 			if (h->emptyFileBools == NULL)
 				dir = 1;
 			else {
 				if (h->emptyFileBools[eindex])
 					dir = 0;
 				else
 					dir = 1;
 				eindex++;
 			}
 			if (entries[i].mode == 0) {
 				if (dir)
 					entries[i].mode = AE_IFDIR | 0777;
 				else
 					entries[i].mode = AE_IFREG | 0666;
 			} else if (dir &&
 			    (entries[i].mode & AE_IFMT) != AE_IFDIR) {
 				entries[i].mode &= ~AE_IFMT;
 				entries[i].mode |= AE_IFDIR;
 			}
 			if ((entries[i].mode & AE_IFMT) == AE_IFDIR &&
 			    entries[i].name_len >= 2 &&
 			    (entries[i].utf16name[entries[i].name_len-2] != '/' ||
 			     entries[i].utf16name[entries[i].name_len-1] != 0)) {
 				entries[i].utf16name[entries[i].name_len] = '/';
 				entries[i].utf16name[entries[i].name_len+1] = 0;
 				entries[i].name_len += 2;
 			}
 			entries[i].ssIndex = -1;
 		}
 		if (entries[i].attr & 0x01)
 			entries[i].mode &= ~0222; 
 		if ((entries[i].flg & HAS_STREAM) == 0 && indexInFolder == 0) {
 			entries[i].folderIndex = -1;
 			continue;
 		}
 		if (indexInFolder == 0) {
 			for (;;) {
 				if (folderIndex >= si->ci.numFolders)
 					return (-1);
 				if (folders[folderIndex].numUnpackStreams)
 					break;
 				folderIndex++;
 			}
 		}
 		entries[i].folderIndex = folderIndex;
 		if ((entries[i].flg & HAS_STREAM) == 0)
 			continue;
 		indexInFolder++;
 		if (indexInFolder >= folders[folderIndex].numUnpackStreams) {
 			folderIndex++;
 			indexInFolder = 0;
 		}
 	}
 	return (0);
 }","[68, 69, 89, 90, 104, 105, 128, 129, 172, 173]",The read_Header function in archive_read_support_format_7zip.c in libarchive 3.2.1 allows remote attackers to cause a denial of service (out-of-bounds read) via multiple EmptyStream attributes in a header in a 7zip archive.,libarchive,CVE-2016-8689,CWE-125
6514,179180," static int filter_frame(AVFilterLink *inlink, AVFrame *in)
 {
     unsigned x, y;
     AVFilterContext *ctx = inlink->dst;
     VignetteContext *s = ctx->priv;
     AVFilterLink *outlink = inlink->dst->outputs[0];
     AVFrame *out;
     out = ff_get_video_buffer(outlink, outlink->w, outlink->h);
     if (!out) {
         av_frame_free(&in);
         return AVERROR(ENOMEM);
     }
     av_frame_copy_props(out, in);
     if (s->eval_mode == EVAL_MODE_FRAME)
         update_context(s, inlink, in);
     if (s->desc->flags & AV_PIX_FMT_FLAG_RGB) {
         uint8_t       *dst = out->data[0];
         const uint8_t *src = in ->data[0];
         const float *fmap = s->fmap;
         const int dst_linesize = out->linesize[0];
         const int src_linesize = in ->linesize[0];
         const int fmap_linesize = s->fmap_linesize;
         for (y = 0; y < inlink->h; y++) {
             uint8_t       *dstp = dst;
             const uint8_t *srcp = src;
             for (x = 0; x < inlink->w; x++, dstp += 3, srcp += 3) {
                 const float f = fmap[x];
                 dstp[0] = av_clip_uint8(srcp[0] * f + get_dither_value(s));
                 dstp[1] = av_clip_uint8(srcp[1] * f + get_dither_value(s));
                 dstp[2] = av_clip_uint8(srcp[2] * f + get_dither_value(s));
             }
             dst += dst_linesize;
             src += src_linesize;
             fmap += fmap_linesize;
         }
      } else {
          int plane;
        for (plane = 0; plane < 4 && in->data[plane]; plane++) {
         for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++) {
              uint8_t       *dst = out->data[plane];
              const uint8_t *src = in ->data[plane];
              const float *fmap = s->fmap;
             const int dst_linesize = out->linesize[plane];
             const int src_linesize = in ->linesize[plane];
             const int fmap_linesize = s->fmap_linesize;
             const int chroma = plane == 1 || plane == 2;
             const int hsub = chroma ? s->desc->log2_chroma_w : 0;
             const int vsub = chroma ? s->desc->log2_chroma_h : 0;
             const int w = FF_CEIL_RSHIFT(inlink->w, hsub);
             const int h = FF_CEIL_RSHIFT(inlink->h, vsub);
             for (y = 0; y < h; y++) {
                 uint8_t *dstp = dst;
                 const uint8_t *srcp = src;
                 for (x = 0; x < w; x++) {
                     const double dv = get_dither_value(s);
                     if (chroma) *dstp++ = av_clip_uint8(fmap[x << hsub] * (*srcp++ - 127) + 127 + dv);
                     else        *dstp++ = av_clip_uint8(fmap[x        ] *  *srcp++              + dv);
                 }
                 dst += dst_linesize;
                 src += src_linesize;
                 fmap += fmap_linesize << vsub;
             }
         }
     }
     return ff_filter_frame(outlink, out);
 }","[38, 39]","libavfilter in FFmpeg before 2.0.1 has unspecified impact and remote vectors related to a crafted *plane,* which triggers an out-of-bounds heap write.",FFmpeg,CVE-2013-4263,CWE-119
6524,181884," static void jas_stream_initbuf(jas_stream_t *stream, int bufmode, char *buf,
   int bufsize)
 {
 	assert(!stream->bufbase_);
 	if (bufmode != JAS_STREAM_UNBUF) {
 		if (!buf) {
 			if ((stream->bufbase_ = jas_malloc(JAS_STREAM_BUFSIZE +
 			  JAS_STREAM_MAXPUTBACK))) {
 				stream->bufmode_ |= JAS_STREAM_FREEBUF;
 				stream->bufsize_ = JAS_STREAM_BUFSIZE;
 			} else {
 				stream->bufbase_ = stream->tinybuf_;
 				stream->bufsize_ = 1;
 			}
 		} else {
  			assert(bufsize > JAS_STREAM_MAXPUTBACK);
			stream->bufbase_ = JAS_CAST(uchar *, buf);
 			stream->bufbase_ = JAS_CAST(jas_uchar *, buf);
  			stream->bufsize_ = bufsize - JAS_STREAM_MAXPUTBACK;
  		}
  	} else {
 		assert(!buf);
 		stream->bufbase_ = stream->tinybuf_;
 		stream->bufsize_ = 1;
 	}
 	stream->bufstart_ = &stream->bufbase_[JAS_STREAM_MAXPUTBACK];
 	stream->ptr_ = stream->bufstart_;
 	stream->cnt_ = 0;
 	stream->bufmode_ |= bufmode & JAS_STREAM_BUFMODEMASK;
 }","[17, 18]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
6535,178159," parse_instruction(
    struct translate_ctx *ctx,
    boolean has_label )
 {
    uint i;
    uint saturate = 0;
    const struct tgsi_opcode_info *info;
    struct tgsi_full_instruction inst;
    const char *cur;
    uint advance;
    inst = tgsi_default_full_instruction();
    eat_opt_white( &ctx->cur );
    if (*ctx->cur == '(') {
       uint file;
       int index;
       uint swizzle[4];
       boolean parsed_swizzle;
       inst.Instruction.Predicate = 1;
       ctx->cur++;
       if (*ctx->cur == '!') {
          ctx->cur++;
          inst.Predicate.Negate = 1;
       }
       if (!parse_register_1d( ctx, &file, &index ))
          return FALSE;
       if (parse_optional_swizzle( ctx, swizzle, &parsed_swizzle, 4 )) {
          if (parsed_swizzle) {
             inst.Predicate.SwizzleX = swizzle[0];
             inst.Predicate.SwizzleY = swizzle[1];
             inst.Predicate.SwizzleZ = swizzle[2];
             inst.Predicate.SwizzleW = swizzle[3];
          }
       }
       if (*ctx->cur != ')') {
          report_error( ctx, ""Expected `)'"" );
          return FALSE;
       }
       ctx->cur++;
    }
    eat_opt_white( &ctx->cur );
    for (i = 0; i < TGSI_OPCODE_LAST; i++) {
       cur = ctx->cur;
       info = tgsi_get_opcode_info( i );
       if (match_inst(&cur, &saturate, info)) {
          if (info->num_dst + info->num_src + info->is_tex == 0) {
             ctx->cur = cur;
             break;
          }
          else if (*cur == '\0' || eat_white( &cur )) {
             ctx->cur = cur;
             break;
          }
       }
    }
    if (i == TGSI_OPCODE_LAST) {
       if (has_label)
          report_error( ctx, ""Unknown opcode"" );
       else
          report_error( ctx, ""Expected `DCL', `IMM' or a label"" );
       return FALSE;
    }
    inst.Instruction.Opcode = i;
    inst.Instruction.Saturate = saturate;
    inst.Instruction.NumDstRegs = info->num_dst;
    inst.Instruction.NumSrcRegs = info->num_src;
    if (i >= TGSI_OPCODE_SAMPLE && i <= TGSI_OPCODE_GATHER4) {
       inst.Instruction.Texture = 1;
       inst.Texture.Texture = TGSI_TEXTURE_UNKNOWN;
    }
    for (i = 0; i < info->num_dst + info->num_src + info->is_tex; i++) {
       if (i > 0) {
          eat_opt_white( &ctx->cur );
          if (*ctx->cur != ',') {
             report_error( ctx, ""Expected `,'"" );
             return FALSE;
          }
          ctx->cur++;
          eat_opt_white( &ctx->cur );
       }
       if (i < info->num_dst) {
          if (!parse_dst_operand( ctx, &inst.Dst[i] ))
             return FALSE;
       }
       else if (i < info->num_dst + info->num_src) {
          if (!parse_src_operand( ctx, &inst.Src[i - info->num_dst] ))
             return FALSE;
       }
       else {
          uint j;
          for (j = 0; j < TGSI_TEXTURE_COUNT; j++) {
             if (str_match_nocase_whole( &ctx->cur, tgsi_texture_names[j] )) {
                inst.Instruction.Texture = 1;
                inst.Texture.Texture = j;
                break;
             }
          }
          if (j == TGSI_TEXTURE_COUNT) {
             report_error( ctx, ""Expected texture target"" );
             return FALSE;
          }
       }
    }
     cur = ctx->cur;
     eat_opt_white( &cur );
   for (i = 0; inst.Instruction.Texture && *cur == ','; i++) {
    for (i = 0; inst.Instruction.Texture && *cur == ',' && i < TGSI_FULL_MAX_TEX_OFFSETS; i++) {
           cur++;
           eat_opt_white( &cur );
           ctx->cur = cur;
          if (!parse_texoffset_operand( ctx, &inst.TexOffsets[i] ))
             return FALSE;
          cur = ctx->cur;
          eat_opt_white( &cur );
    }
    inst.Texture.NumOffsets = i;
    cur = ctx->cur;
    eat_opt_white( &cur );
    if (info->is_branch && *cur == ':') {
       uint target;
       cur++;
       eat_opt_white( &cur );
       if (!parse_uint( &cur, &target )) {
          report_error( ctx, ""Expected a label"" );
          return FALSE;
       }
       inst.Instruction.Label = 1;
       inst.Label.Label = target;
       ctx->cur = cur;
    }
    advance = tgsi_build_full_instruction(
       &inst,
       ctx->tokens_cur,
       ctx->header,
       (uint) (ctx->tokens_end - ctx->tokens_cur) );
    if (advance == 0)
       return FALSE;
    ctx->tokens_cur += advance;
    return TRUE;
 }","[105, 106]",The parse_instruction function in gallium/auxiliary/tgsi/tgsi_text.c in virglrenderer before 0.6.0 allows local guest OS users to cause a denial of service (out-of-bounds array access and process crash) via a crafted texture instruction.,virglrenderer,CVE-2017-5580,CWE-119
6536,179167," int av_reallocp_array(void *ptr, size_t nmemb, size_t size)
  {
      void **ptrptr = ptr;
      *ptrptr = av_realloc_f(*ptrptr, nmemb, size);
    if (!*ptrptr && !(nmemb && size))
     if (!*ptrptr && nmemb && size)
          return AVERROR(ENOMEM);
      return 0;
  }","[5, 6]",The av_reallocp_array function in libavutil/mem.c in FFmpeg before 2.0.1 has an unspecified impact and remote vectors related to a *wrong return code* and a resultant NULL pointer dereference.,FFmpeg,CVE-2013-4265,
6541,182783," compile_bag_node(BagNode* node, regex_t* reg, ScanEnv* env)
 {
   int r, len;
   switch (node->type) {
   case BAG_MEMORY:
     r = compile_bag_memory_node(node, reg, env);
     break;
   case BAG_OPTION:
     r = compile_option_node(node, reg, env);
     break;
   case BAG_STOP_BACKTRACK:
     if (NODE_IS_STOP_BT_SIMPLE_REPEAT(node)) {
       QuantNode* qn = QUANT_(NODE_BAG_BODY(node));
       r = compile_tree_n_times(NODE_QUANT_BODY(qn), qn->lower, reg, env);
       if (r != 0) return r;
       len = compile_length_tree(NODE_QUANT_BODY(qn), reg);
       if (len < 0) return len;
       r = add_op(reg, OP_PUSH);
       if (r != 0) return r;
       COP(reg)->push.addr = SIZE_INC_OP + len + SIZE_OP_POP_OUT + SIZE_OP_JUMP;
       r = compile_tree(NODE_QUANT_BODY(qn), reg, env);
       if (r != 0) return r;
       r = add_op(reg, OP_POP_OUT);
       if (r != 0) return r;
       r = add_op(reg, OP_JUMP);
       if (r != 0) return r;
       COP(reg)->jump.addr = -((int )SIZE_OP_PUSH + len + (int )SIZE_OP_POP_OUT);
     }
     else {
       r = add_op(reg, OP_ATOMIC_START);
       if (r != 0) return r;
       r = compile_tree(NODE_BAG_BODY(node), reg, env);
       if (r != 0) return r;
       r = add_op(reg, OP_ATOMIC_END);
     }
     break;
    case BAG_IF_ELSE:
      {
      int cond_len, then_len, jump_len;
       int cond_len, then_len, else_len, jump_len;
        Node* cond = NODE_BAG_BODY(node);
        Node* Then = node->te.Then;
        Node* Else = node->te.Else;
       r = add_op(reg, OP_ATOMIC_START);
       if (r != 0) return r;
       cond_len = compile_length_tree(cond, reg);
       if (cond_len < 0) return cond_len;
       if (IS_NOT_NULL(Then)) {
         then_len = compile_length_tree(Then, reg);
         if (then_len < 0) return then_len;
       }
        else
          then_len = 0;
      jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END;
      if (IS_NOT_NULL(Else)) jump_len += SIZE_OP_JUMP;
       jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END + SIZE_OP_JUMP;
        r = add_op(reg, OP_PUSH);
        if (r != 0) return r;
       COP(reg)->push.addr = SIZE_INC_OP + jump_len;
       r = compile_tree(cond, reg, env);
       if (r != 0) return r;
       r = add_op(reg, OP_ATOMIC_END);
       if (r != 0) return r;
       if (IS_NOT_NULL(Then)) {
         r = compile_tree(Then, reg, env);
         if (r != 0) return r;
        }
        if (IS_NOT_NULL(Else)) {
        int else_len = compile_length_tree(Else, reg);
        r = add_op(reg, OP_JUMP);
        if (r != 0) return r;
        COP(reg)->jump.addr = else_len + SIZE_INC_OP;
         else_len = compile_length_tree(Else, reg);
         if (else_len < 0) return else_len;
       }
       else
         else_len = 0;
       r = add_op(reg, OP_JUMP);
       if (r != 0) return r;
       COP(reg)->jump.addr = SIZE_OP_ATOMIC_END + else_len + SIZE_INC_OP;
       r = add_op(reg, OP_ATOMIC_END);
       if (r != 0) return r;
       if (IS_NOT_NULL(Else)) {
          r = compile_tree(Else, reg, env);
        }
      }
     break;
   }
   return r;
 }","[39, 40, 54, 55, 56, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83]","A NULL Pointer Dereference in match_at() in regexec.c in Oniguruma 6.9.2 allows attackers to potentially cause denial of service by providing a crafted regular expression. Oniguruma issues often affect Ruby, as well as common optional libraries for PHP and Rust.",oniguruma,CVE-2019-13225,CWE-476
6542,181670," static int http_open(URLContext *h, const char *uri, int flags,
                      AVDictionary **options)
 {
     HTTPContext *s = h->priv_data;
     int ret;
     if( s->seekable == 1 )
         h->is_streamed = 0;
      else
          h->is_streamed = 1;
    s->filesize = -1;
     s->filesize = UINT64_MAX;
      s->location = av_strdup(uri);
      if (!s->location)
          return AVERROR(ENOMEM);
     if (options)
         av_dict_copy(&s->chained_options, *options, 0);
     if (s->headers) {
         int len = strlen(s->headers);
         if (len < 2 || strcmp(""\r\n"", s->headers + len - 2)) {
             av_log(h, AV_LOG_WARNING,
                    ""No trailing CRLF found in HTTP header.\n"");
             ret = av_reallocp(&s->headers, len + 3);
             if (ret < 0)
                 return ret;
             s->headers[len]     = '\r';
             s->headers[len + 1] = '\n';
             s->headers[len + 2] = '\0';
         }
     }
     if (s->listen) {
         return http_listen(h, uri, flags, options);
     }
     ret = http_open_cnx(h, options);
     if (ret < 0)
         av_dict_free(&s->chained_options);
     return ret;
 }","[10, 11]","Heap-based buffer overflow in libavformat/http.c in FFmpeg before 2.8.10, 3.0.x before 3.0.5, 3.1.x before 3.1.6, and 3.2.x before 3.2.2 allows remote web servers to execute arbitrary code via a negative chunk size in an HTTP response.",FFmpeg,CVE-2016-10190,CWE-119
6555,181669," static int http_connect(URLContext *h, const char *path, const char *local_path,
                         const char *hoststr, const char *auth,
                         const char *proxyauth, int *new_location)
 {
     HTTPContext *s = h->priv_data;
      int post, err;
      char headers[HTTP_HEADERS_SIZE] = """";
      char *authstr = NULL, *proxyauthstr = NULL;
    int64_t off = s->off;
     uint64_t off = s->off;
      int len = 0;
      const char *method;
      int send_expect_100 = 0;
     post = h->flags & AVIO_FLAG_WRITE;
     if (s->post_data) {
         post            = 1;
         s->chunked_post = 0;
     }
     if (s->method)
         method = s->method;
     else
         method = post ? ""POST"" : ""GET"";
     authstr      = ff_http_auth_create_response(&s->auth_state, auth,
                                                 local_path, method);
     proxyauthstr = ff_http_auth_create_response(&s->proxy_auth_state, proxyauth,
                                                 local_path, method);
     if (post && !s->post_data) {
         send_expect_100 = s->send_expect_100;
         if (auth && *auth &&
             s->auth_state.auth_type == HTTP_AUTH_NONE &&
             s->http_code != 401)
             send_expect_100 = 1;
     }
 #if FF_API_HTTP_USER_AGENT
     if (strcmp(s->user_agent_deprecated, DEFAULT_USER_AGENT)) {
         av_log(s, AV_LOG_WARNING, ""the user-agent option is deprecated, please use user_agent option\n"");
         s->user_agent = av_strdup(s->user_agent_deprecated);
     }
 #endif
     if (!has_header(s->headers, ""\r\nUser-Agent: ""))
         len += av_strlcatf(headers + len, sizeof(headers) - len,
                            ""User-Agent: %s\r\n"", s->user_agent);
     if (!has_header(s->headers, ""\r\nAccept: ""))
         len += av_strlcpy(headers + len, ""Accept: */*\r\n"",
                           sizeof(headers) - len);
      if (!has_header(s->headers, ""\r\nRange: "") && !post && (s->off > 0 || s->end_off || s->seekable == -1)) {
          len += av_strlcatf(headers + len, sizeof(headers) - len,
                           ""Range: bytes=%""PRId64""-"", s->off);
                            ""Range: bytes=%""PRIu64""-"", s->off);
          if (s->end_off)
              len += av_strlcatf(headers + len, sizeof(headers) - len,
                                 ""%""PRId64, s->end_off - 1);
         len += av_strlcpy(headers + len, ""\r\n"",
                           sizeof(headers) - len);
     }
     if (send_expect_100 && !has_header(s->headers, ""\r\nExpect: ""))
         len += av_strlcatf(headers + len, sizeof(headers) - len,
                            ""Expect: 100-continue\r\n"");
     if (!has_header(s->headers, ""\r\nConnection: "")) {
         if (s->multiple_requests)
             len += av_strlcpy(headers + len, ""Connection: keep-alive\r\n"",
                               sizeof(headers) - len);
         else
             len += av_strlcpy(headers + len, ""Connection: close\r\n"",
                               sizeof(headers) - len);
     }
     if (!has_header(s->headers, ""\r\nHost: ""))
         len += av_strlcatf(headers + len, sizeof(headers) - len,
                            ""Host: %s\r\n"", hoststr);
     if (!has_header(s->headers, ""\r\nContent-Length: "") && s->post_data)
         len += av_strlcatf(headers + len, sizeof(headers) - len,
                            ""Content-Length: %d\r\n"", s->post_datalen);
     if (!has_header(s->headers, ""\r\nContent-Type: "") && s->content_type)
         len += av_strlcatf(headers + len, sizeof(headers) - len,
                            ""Content-Type: %s\r\n"", s->content_type);
     if (!has_header(s->headers, ""\r\nCookie: "") && s->cookies) {
         char *cookies = NULL;
         if (!get_cookies(s, &cookies, path, hoststr) && cookies) {
             len += av_strlcatf(headers + len, sizeof(headers) - len,
                                ""Cookie: %s\r\n"", cookies);
             av_free(cookies);
         }
     }
     if (!has_header(s->headers, ""\r\nIcy-MetaData: "") && s->icy)
         len += av_strlcatf(headers + len, sizeof(headers) - len,
                            ""Icy-MetaData: %d\r\n"", 1);
     if (s->headers)
         av_strlcpy(headers + len, s->headers, sizeof(headers) - len);
     snprintf(s->buffer, sizeof(s->buffer),
              ""%s %s HTTP/1.1\r\n""
              ""%s""
              ""%s""
              ""%s""
              ""%s%s""
              ""\r\n"",
              method,
              path,
              post && s->chunked_post ? ""Transfer-Encoding: chunked\r\n"" : """",
              headers,
              authstr ? authstr : """",
              proxyauthstr ? ""Proxy-"" : """", proxyauthstr ? proxyauthstr : """");
     av_log(h, AV_LOG_DEBUG, ""request: %s\n"", s->buffer);
     if ((err = ffurl_write(s->hd, s->buffer, strlen(s->buffer))) < 0)
         goto done;
     if (s->post_data)
         if ((err = ffurl_write(s->hd, s->post_data, s->post_datalen)) < 0)
             goto done;
     s->buf_ptr          = s->buffer;
     s->buf_end          = s->buffer;
      s->line_count       = 0;
      s->off              = 0;
      s->icy_data_read    = 0;
    s->filesize         = -1;
     s->filesize         = UINT64_MAX;
      s->willclose        = 0;
      s->end_chunked_post = 0;
      s->end_header       = 0;
     if (post && !s->post_data && !send_expect_100) {
         s->http_code = 200;
         err = 0;
         goto done;
     }
     err = http_read_header(h, new_location);
     if (err < 0)
         goto done;
     if (*new_location)
         s->off = off;
     err = (off == s->off) ? 0 : -1;
 done:
     av_freep(&authstr);
     av_freep(&proxyauthstr);
     return err;
 }","[9, 10, 48, 49, 113, 114]","Heap-based buffer overflow in libavformat/http.c in FFmpeg before 2.8.10, 3.0.x before 3.0.5, 3.1.x before 3.1.6, and 3.2.x before 3.2.2 allows remote web servers to execute arbitrary code via a negative chunk size in an HTTP response.",FFmpeg,CVE-2016-10190,CWE-119
6561,182613," static int jpc_pi_nextrlcp(register jpc_pi_t *pi)
 {
 	jpc_pchg_t *pchg;
 	int *prclyrno;
 	pchg = pi->pchg;
 	if (!pi->prgvolfirst) {
 		assert(pi->prcno < pi->pirlvl->numprcs);
 		prclyrno = &pi->pirlvl->prclyrnos[pi->prcno];
 		goto skip;
 	} else {
 		pi->prgvolfirst = 0;
 	}
 	for (pi->rlvlno = pchg->rlvlnostart; pi->rlvlno < pi->maxrlvls &&
 	  pi->rlvlno < pchg->rlvlnoend; ++pi->rlvlno) {
 		for (pi->lyrno = 0; pi->lyrno < pi->numlyrs && pi->lyrno <
  		  JAS_CAST(int, pchg->lyrnoend); ++pi->lyrno) {
  			for (pi->compno = pchg->compnostart, pi->picomp =
  			  &pi->picomps[pi->compno]; pi->compno < pi->numcomps &&
			  pi->compno < JAS_CAST(int, pchg->compnoend); ++pi->compno, ++pi->picomp) {
 			  pi->compno < JAS_CAST(int, pchg->compnoend); ++pi->compno,
 			  ++pi->picomp) {
  				if (pi->rlvlno >= pi->picomp->numrlvls) {
  					continue;
  				}
 				pi->pirlvl = &pi->picomp->pirlvls[pi->rlvlno];
 				for (pi->prcno = 0, prclyrno = pi->pirlvl->prclyrnos;
 				  pi->prcno < pi->pirlvl->numprcs; ++pi->prcno, ++prclyrno) {
 					if (pi->lyrno >= *prclyrno) {
 						*prclyrno = pi->lyrno;
 						++(*prclyrno);
 						return 0;
 					}
 skip:
 					;
 				}
 			}
 		}
 	}
 	return 1;
 }","[19, 20, 21]",An out-of-bounds heap read vulnerability was found in the jpc_pi_nextpcrl() function of jasper before 2.0.6 when processing crafted input.,jasper,CVE-2016-9583,CWE-125
6586,181904," long jpc_bitstream_getbits(jpc_bitstream_t *bitstream, int n)
 {
 	long v;
 	int u;
	assert(n >= 0 && n < 32);
 	if (n < 0 || n >= 32) {
 		return -1;
 	}
  	v = 0;
 	while (--n >= 0) {
 		if ((u = jpc_bitstream_getbit(bitstream)) < 0) {
 			return -1;
 		}
 		v = (v << 1) | u;
 	}
 	return v;
 }","[5, 6, 7, 8]",The jpc_bitstream_getbits function in jpc_bs.c in JasPer before 2.0.10 allows remote attackers to cause a denial of service (assertion failure) via a very large integer.,jasper,CVE-2016-9391,
6592,183214," static int cdxl_decode_frame(AVCodecContext *avctx, void *data,
                              int *got_frame, AVPacket *pkt)
 {
     CDXLVideoContext *c = avctx->priv_data;
     AVFrame * const p = data;
     int ret, w, h, encoding, aligned_width, buf_size = pkt->size;
     const uint8_t *buf = pkt->data;
     if (buf_size < 32)
         return AVERROR_INVALIDDATA;
     encoding        = buf[1] & 7;
     c->format       = buf[1] & 0xE0;
     w               = AV_RB16(&buf[14]);
     h               = AV_RB16(&buf[16]);
     c->bpp          = buf[19];
     c->palette_size = AV_RB16(&buf[20]);
     c->palette      = buf + 32;
     c->video        = c->palette + c->palette_size;
     c->video_size   = buf_size - c->palette_size - 32;
     if (c->palette_size > 512)
         return AVERROR_INVALIDDATA;
     if (buf_size < c->palette_size + 32)
         return AVERROR_INVALIDDATA;
     if (c->bpp < 1)
         return AVERROR_INVALIDDATA;
     if (c->format != BIT_PLANAR && c->format != BIT_LINE && c->format != CHUNKY) {
         avpriv_request_sample(avctx, ""Pixel format 0x%0x"", c->format);
         return AVERROR_PATCHWELCOME;
     }
     if ((ret = ff_set_dimensions(avctx, w, h)) < 0)
         return ret;
     if (c->format == CHUNKY)
         aligned_width = avctx->width;
     else
         aligned_width = FFALIGN(c->avctx->width, 16);
      c->padded_bits  = aligned_width - c->avctx->width;
      if (c->video_size < aligned_width * avctx->height * (int64_t)c->bpp / 8)
          return AVERROR_INVALIDDATA;
    if (!encoding && c->palette_size && c->bpp <= 8) {
     if (!encoding && c->palette_size && c->bpp <= 8 && c->format != CHUNKY) {
          avctx->pix_fmt = AV_PIX_FMT_PAL8;
      } else if (encoding == 1 && (c->bpp == 6 || c->bpp == 8)) {
          if (c->palette_size != (1 << (c->bpp - 1)))
             return AVERROR_INVALIDDATA;
         avctx->pix_fmt = AV_PIX_FMT_BGR24;
     } else if (!encoding && c->bpp == 24 && c->format == CHUNKY &&
                !c->palette_size) {
         avctx->pix_fmt = AV_PIX_FMT_RGB24;
     } else {
         avpriv_request_sample(avctx, ""Encoding %d, bpp %d and format 0x%x"",
                               encoding, c->bpp, c->format);
         return AVERROR_PATCHWELCOME;
     }
     if ((ret = ff_get_buffer(avctx, p, 0)) < 0)
         return ret;
     p->pict_type = AV_PICTURE_TYPE_I;
     if (encoding) {
         av_fast_padded_malloc(&c->new_video, &c->new_video_size,
                               h * w + AV_INPUT_BUFFER_PADDING_SIZE);
         if (!c->new_video)
             return AVERROR(ENOMEM);
         if (c->bpp == 8)
             cdxl_decode_ham8(c, p);
         else
             cdxl_decode_ham6(c, p);
     } else if (avctx->pix_fmt == AV_PIX_FMT_PAL8) {
         cdxl_decode_rgb(c, p);
     } else {
         cdxl_decode_raw(c, p);
     }
     *got_frame = 1;
     return buf_size;
 }","[38, 39]","The cdxl_decode_frame function in libavcodec/cdxl.c in FFmpeg 2.8.x before 2.8.12, 3.0.x before 3.0.8, 3.1.x before 3.1.8, 3.2.x before 3.2.5, and 3.3.x before 3.3.1 does not exclude the CHUNKY format, which allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted file.",FFmpeg,CVE-2017-9996,CWE-119
6594,181894," jas_image_t *jpg_decode(jas_stream_t *in, char *optstr)
 {
 	struct jpeg_decompress_struct cinfo;
 	struct jpeg_error_mgr jerr;
 	FILE *input_file;
 	jpg_dest_t dest_mgr_buf;
 	jpg_dest_t *dest_mgr = &dest_mgr_buf;
 	JDIMENSION num_scanlines;
  	jas_image_t *image;
  	int ret;
  	jpg_dec_importopts_t opts;
	size_t size;
 	size_t num_samples;
 	JAS_DBGLOG(100, (""jpg_decode(%p, \""%s\"")\n"", in, optstr));
  	if (jpg_dec_parseopts(optstr, &opts)) {
  		goto error;
 	}
 	memset(&cinfo, 0, sizeof(struct jpeg_decompress_struct));
 	memset(dest_mgr, 0, sizeof(jpg_dest_t));
 	dest_mgr->data = 0;
 	image = 0;
 	input_file = 0;
 	if (!(input_file = tmpfile())) {
 		jas_eprintf(""cannot make temporary file\n"");
 		goto error;
 	}
 	if (jpg_copystreamtofile(input_file, in)) {
 		jas_eprintf(""cannot copy stream\n"");
 		goto error;
 	}
 	rewind(input_file);
 	JAS_DBGLOG(10, (""jpeg_std_error(%p)\n"", &jerr));
 	cinfo.err = jpeg_std_error(&jerr);
 	JAS_DBGLOG(10, (""jpeg_create_decompress(%p)\n"", &cinfo));
 	jpeg_create_decompress(&cinfo);
 	JAS_DBGLOG(10, (""jpeg_stdio_src(%p, %p)\n"", &cinfo, input_file));
 	jpeg_stdio_src(&cinfo, input_file);
 	JAS_DBGLOG(10, (""jpeg_read_header(%p, TRUE)\n"", &cinfo));
 	ret = jpeg_read_header(&cinfo, TRUE);
 	JAS_DBGLOG(10, (""jpeg_read_header return value %d\n"", ret));
 	if (ret != JPEG_HEADER_OK) {
 		jas_eprintf(""jpeg_read_header did not return JPEG_HEADER_OK\n"");
 	}
 	JAS_DBGLOG(10, (
 	  ""header: image_width %d; image_height %d; num_components %d\n"",
  	  cinfo.image_width, cinfo.image_height, cinfo.num_components)
  	  );
 	if (opts.max_samples > 0) {
 		if (!jas_safe_size_mul3(cinfo.image_width, cinfo.image_height,
 		  cinfo.num_components, &num_samples)) {
 			goto error;
 		}
 		if (num_samples > opts.max_samples) {
 			jas_eprintf(""image is too large (%zu > %zu)\n"", num_samples,
 			  opts.max_samples);
 			goto error;
 		}
 	}
  	JAS_DBGLOG(10, (""jpeg_start_decompress(%p)\n"", &cinfo));
  	ret = jpeg_start_decompress(&cinfo);
 	JAS_DBGLOG(10, (""jpeg_start_decompress return value %d\n"", ret));
 	JAS_DBGLOG(10, (
 	  ""header: output_width %d; output_height %d; output_components %d\n"",
  	  cinfo.output_width, cinfo.output_height, cinfo.output_components)
  	  );
	if (opts.max_size) {
		if (!jas_safe_size_mul(cinfo.output_width, cinfo.output_height,
		  &size) ||
		  !jas_safe_size_mul(size, cinfo.output_components, &size)) {
			goto error;
		}
		if (size > opts.max_size) {
			jas_eprintf(""image is too large\n"");
			goto error;
		}
	}
  	if (!(image = jpg_mkimage(&cinfo))) {
  		jas_eprintf(""jpg_mkimage failed\n"");
 		goto error;
 	}
 	dest_mgr->image = image;
 	if (!(dest_mgr->data = jas_matrix_create(1, cinfo.output_width))) {
 		jas_eprintf(""jas_matrix_create failed\n"");
 		goto error;
 	}
 	dest_mgr->start_output = jpg_start_output;
 	dest_mgr->put_pixel_rows = jpg_put_pixel_rows;
 	dest_mgr->finish_output = jpg_finish_output;
     dest_mgr->buffer = (*cinfo.mem->alloc_sarray)
       ((j_common_ptr) &cinfo, JPOOL_IMAGE,
        cinfo.output_width * cinfo.output_components, (JDIMENSION) 1);
 	dest_mgr->buffer_height = 1;
 	dest_mgr->error = 0;
 	(*dest_mgr->start_output)(&cinfo, dest_mgr);
 	while (cinfo.output_scanline < cinfo.output_height) {
 		JAS_DBGLOG(10, (""jpeg_read_scanlines(%p, %p, %lu)\n"", &cinfo,
 		  dest_mgr->buffer, JAS_CAST(unsigned long, dest_mgr->buffer_height)));
 		num_scanlines = jpeg_read_scanlines(&cinfo, dest_mgr->buffer,
 		  dest_mgr->buffer_height);
 		JAS_DBGLOG(10, (""jpeg_read_scanlines return value %lu\n"",
 		  JAS_CAST(unsigned long, num_scanlines)));
 		(*dest_mgr->put_pixel_rows)(&cinfo, dest_mgr, num_scanlines);
 	}
 	(*dest_mgr->finish_output)(&cinfo, dest_mgr);
 	JAS_DBGLOG(10, (""jpeg_finish_decompress(%p)\n"", &cinfo));
 	jpeg_finish_decompress(&cinfo);
 	JAS_DBGLOG(10, (""jpeg_destroy_decompress(%p)\n"", &cinfo));
 	jpeg_destroy_decompress(&cinfo);
 	jas_matrix_destroy(dest_mgr->data);
 	JAS_DBGLOG(10, (""fclose(%p)\n"", input_file));
 	fclose(input_file);
 	input_file = 0;
 	if (dest_mgr->error) {
 		jas_eprintf(""error during decoding\n"");
 		goto error;
 	}
 	return image;
 error:
 	if (dest_mgr->data) {
 		jas_matrix_destroy(dest_mgr->data);
 	}
 	if (image) {
 		jas_image_destroy(image);
 	}
 	if (input_file) {
 		fclose(input_file);
 	}
 	return 0;
 }","[12, 13, 14, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
6632,182847," static int fuzzerTests(U32 seed, U32 nbTests, unsigned startTest, U32 const maxDurationS, double compressibility, int bigTests)
 {
     static const U32 maxSrcLog = 23;
     static const U32 maxSampleLog = 22;
     size_t const srcBufferSize = (size_t)1<<maxSrcLog;
     size_t const dstBufferSize = (size_t)1<<maxSampleLog;
     size_t const cBufferSize   = ZSTD_compressBound(dstBufferSize);
     BYTE* cNoiseBuffer[5];
     BYTE* const cBuffer = (BYTE*) malloc (cBufferSize);
     BYTE* const dstBuffer = (BYTE*) malloc (dstBufferSize);
     BYTE* const mirrorBuffer = (BYTE*) malloc (dstBufferSize);
     ZSTD_CCtx* const refCtx = ZSTD_createCCtx();
     ZSTD_CCtx* const ctx = ZSTD_createCCtx();
     ZSTD_DCtx* const dctx = ZSTD_createDCtx();
     U32 result = 0;
     U32 testNb = 0;
     U32 coreSeed = seed;
     UTIL_time_t const startClock = UTIL_getTime();
     U64 const maxClockSpan = maxDurationS * SEC_TO_MICRO;
     int const cLevelLimiter = bigTests ? 3 : 2;
     cNoiseBuffer[0] = (BYTE*)malloc (srcBufferSize);
     cNoiseBuffer[1] = (BYTE*)malloc (srcBufferSize);
     cNoiseBuffer[2] = (BYTE*)malloc (srcBufferSize);
     cNoiseBuffer[3] = (BYTE*)malloc (srcBufferSize);
     cNoiseBuffer[4] = (BYTE*)malloc (srcBufferSize);
     CHECK (!cNoiseBuffer[0] || !cNoiseBuffer[1] || !cNoiseBuffer[2] || !cNoiseBuffer[3] || !cNoiseBuffer[4]
            || !dstBuffer || !mirrorBuffer || !cBuffer || !refCtx || !ctx || !dctx,
            ""Not enough memory, fuzzer tests cancelled"");
     RDG_genBuffer(cNoiseBuffer[0], srcBufferSize, 0.00, 0., coreSeed);     
     RDG_genBuffer(cNoiseBuffer[1], srcBufferSize, 0.05, 0., coreSeed);     
     RDG_genBuffer(cNoiseBuffer[2], srcBufferSize, compressibility, 0., coreSeed);
     RDG_genBuffer(cNoiseBuffer[3], srcBufferSize, 0.95, 0., coreSeed);     
     RDG_genBuffer(cNoiseBuffer[4], srcBufferSize, 1.00, 0., coreSeed);     
     for (testNb=1; testNb < startTest; testNb++) FUZ_rand(&coreSeed);
     for ( ; (testNb <= nbTests) || (UTIL_clockSpanMicro(startClock) < maxClockSpan); testNb++ ) {
         BYTE* srcBuffer;    
         U32 lseed;
         size_t sampleSize, maxTestSize, totalTestSize;
         size_t cSize, totalCSize, totalGenSize;
         U64 crcOrig;
         BYTE* sampleBuffer;
         const BYTE* dict;
         size_t dictSize;
         if (nbTests >= testNb) { DISPLAYUPDATE(2, ""\r%6u/%6u    "", testNb, nbTests); }
         else { DISPLAYUPDATE(2, ""\r%6u          "", testNb); }
         FUZ_rand(&coreSeed);
         { U32 const prime1 = 2654435761U; lseed = coreSeed ^ prime1; }
         {   U32 buffNb = FUZ_rand(&lseed) & 0x7F;
             if (buffNb & 7) buffNb=2;    
             else {
                 buffNb >>= 3;
                 if (buffNb & 7) {
                     const U32 tnb[2] = { 1, 3 };    
                     buffNb = tnb[buffNb >> 3];
                 } else {
                     const U32 tnb[2] = { 0, 4 };    
                     buffNb = tnb[buffNb >> 3];
             }   }
             srcBuffer = cNoiseBuffer[buffNb];
         }
         sampleSize = FUZ_randomLength(&lseed, maxSampleLog);
         sampleBuffer = (BYTE*)malloc(sampleSize);
         CHECK(sampleBuffer==NULL, ""not enough memory for sample buffer"");
         { size_t const sampleStart = FUZ_rand(&lseed) % (srcBufferSize - sampleSize);
           memcpy(sampleBuffer, srcBuffer + sampleStart, sampleSize); }
         crcOrig = XXH64(sampleBuffer, sampleSize, 0);
         {   int const cLevelPositive =
                     ( FUZ_rand(&lseed) %
                      (ZSTD_maxCLevel() - (FUZ_highbit32((U32)sampleSize) / cLevelLimiter)) )
                     + 1;
             int const cLevel = ((FUZ_rand(&lseed) & 15) == 3) ?
                              - (int)((FUZ_rand(&lseed) & 7) + 1) :    
                              cLevelPositive;
             DISPLAYLEVEL(5, ""fuzzer t%u: Simple compression test (level %i) \n"", testNb, cLevel);
             cSize = ZSTD_compressCCtx(ctx, cBuffer, cBufferSize, sampleBuffer, sampleSize, cLevel);
              CHECK(ZSTD_isError(cSize), ""ZSTD_compressCCtx failed : %s"", ZSTD_getErrorName(cSize));
            if (cSize > 3) {
                const size_t missing = (FUZ_rand(&lseed) % (cSize-2)) + 1;    
             assert(cSize > 3);
             {   const size_t missing = (FUZ_rand(&lseed) % (cSize-2)) + 1;
                  const size_t tooSmallSize = cSize - missing;
                  const U32 endMark = 0x4DC2B1A9;
                  memcpy(dstBuffer+tooSmallSize, &endMark, 4);
                 DISPLAYLEVEL(5, ""fuzzer t%u: compress into too small buffer of size %u (missing %u bytes) \n"",
                             testNb, (unsigned)tooSmallSize, (unsigned)missing);
                  { size_t const errorCode = ZSTD_compressCCtx(ctx, dstBuffer, tooSmallSize, sampleBuffer, sampleSize, cLevel);
                    CHECK(!ZSTD_isError(errorCode), ""ZSTD_compressCCtx should have failed ! (buffer too small : %u < %u)"", (U32)tooSmallSize, (U32)cSize); }
                  { U32 endCheck; memcpy(&endCheck, dstBuffer+tooSmallSize, 4);
                  CHECK(endCheck != endMark, ""ZSTD_compressCCtx : dst buffer overflow""); }
                   CHECK(endCheck != endMark, ""ZSTD_compressCCtx : dst buffer overflow  (check.%08X != %08X.mark)"", endCheck, endMark); }
          }   }
         {   ZSTD_frameHeader zfh;
             CHECK_Z( ZSTD_getFrameHeader(&zfh, cBuffer, cSize) );
             CHECK(zfh.frameContentSize != sampleSize, ""Frame content size incorrect"");
         }
         {   unsigned long long const rSize = ZSTD_findDecompressedSize(cBuffer, cSize);
             CHECK(rSize != sampleSize, ""decompressed size incorrect"");
         }
         DISPLAYLEVEL(5, ""fuzzer t%u: simple decompression test \n"", testNb);
         {   size_t const margin = (FUZ_rand(&lseed) & 1) ? 0 : (FUZ_rand(&lseed) & 31) + 1;
             size_t const dSize = ZSTD_decompress(dstBuffer, sampleSize + margin, cBuffer, cSize);
             CHECK(dSize != sampleSize, ""ZSTD_decompress failed (%s) (srcSize : %u ; cSize : %u)"", ZSTD_getErrorName(dSize), (U32)sampleSize, (U32)cSize);
             {   U64 const crcDest = XXH64(dstBuffer, sampleSize, 0);
                 CHECK(crcOrig != crcDest, ""decompression result corrupted (pos %u / %u)"", (U32)findDiff(sampleBuffer, dstBuffer, sampleSize), (U32)sampleSize);
         }   }
         free(sampleBuffer);    
         DISPLAYLEVEL(5, ""fuzzer t%u: decompression of truncated source \n"", testNb);
         {   size_t const missing = (FUZ_rand(&lseed) % (cSize-2)) + 1;    
             size_t const tooSmallSize = cSize - missing;
             void* cBufferTooSmall = malloc(tooSmallSize);    
             CHECK(cBufferTooSmall == NULL, ""not enough memory !"");
             memcpy(cBufferTooSmall, cBuffer, tooSmallSize);
             { size_t const errorCode = ZSTD_decompress(dstBuffer, dstBufferSize, cBufferTooSmall, tooSmallSize);
               CHECK(!ZSTD_isError(errorCode), ""ZSTD_decompress should have failed ! (truncated src buffer)""); }
             free(cBufferTooSmall);
         }
         DISPLAYLEVEL(5, ""fuzzer t%u: decompress into too small dst buffer \n"", testNb);
         if (sampleSize > 3) {
             size_t const missing = (FUZ_rand(&lseed) % (sampleSize-2)) + 1;    
             size_t const tooSmallSize = sampleSize - missing;
             static const BYTE token = 0xA9;
             dstBuffer[tooSmallSize] = token;
             { size_t const errorCode = ZSTD_decompress(dstBuffer, tooSmallSize, cBuffer, cSize);
               CHECK(!ZSTD_isError(errorCode), ""ZSTD_decompress should have failed : %u > %u (dst buffer too small)"", (U32)errorCode, (U32)tooSmallSize); }
             CHECK(dstBuffer[tooSmallSize] != token, ""ZSTD_decompress : dst buffer overflow"");
         }
         if (cSize > 6) {
             {   U32 const maxNbBits = FUZ_highbit32((U32)(cSize-4));
                 size_t pos = 4;    
                 for (;;) {
                     {   U32 const nbBits = FUZ_rand(&lseed) % maxNbBits;
                         size_t const mask = (1<<nbBits) - 1;
                         size_t const skipLength = FUZ_rand(&lseed) & mask;
                         pos += skipLength;
                     }
                     if (pos >= cSize) break;
                     {   U32 const nbBitsCodes = FUZ_rand(&lseed) % maxNbBits;
                         U32 const nbBits = nbBitsCodes ? nbBitsCodes-1 : 0;
                         size_t const mask = (1<<nbBits) - 1;
                         size_t const rNoiseLength = (FUZ_rand(&lseed) & mask) + 1;
                         size_t const noiseLength = MIN(rNoiseLength, cSize-pos);
                         size_t const noiseStart = FUZ_rand(&lseed) % (srcBufferSize - noiseLength);
                         memcpy(cBuffer + pos, srcBuffer + noiseStart, noiseLength);
                         pos += noiseLength;
             }   }   }
             DISPLAYLEVEL(5, ""fuzzer t%u: decompress noisy source \n"", testNb);
             {   U32 const endMark = 0xA9B1C3D6;
                 memcpy(dstBuffer+sampleSize, &endMark, 4);
                 {   size_t const decompressResult = ZSTD_decompress(dstBuffer, sampleSize, cBuffer, cSize);
                     CHECK((!ZSTD_isError(decompressResult)) && (decompressResult>sampleSize),
                           ""ZSTD_decompress on noisy src : result is too large : %u > %u (dst buffer)"", (U32)decompressResult, (U32)sampleSize);
                 }
                 {   U32 endCheck; memcpy(&endCheck, dstBuffer+sampleSize, 4);
                     CHECK(endMark!=endCheck, ""ZSTD_decompress on noisy src : dst buffer overflow"");
         }   }   }    
         DISPLAYLEVEL(5, ""fuzzer t%u: Bufferless streaming compression test \n"", testNb);
         {   U32 const testLog = FUZ_rand(&lseed) % maxSrcLog;
             U32 const dictLog = FUZ_rand(&lseed) % maxSrcLog;
             int const cLevel = (FUZ_rand(&lseed) %
                                 (ZSTD_maxCLevel() -
                                  (MAX(testLog, dictLog) / cLevelLimiter))) +
                                1;
             maxTestSize = FUZ_rLogLength(&lseed, testLog);
             if (maxTestSize >= dstBufferSize) maxTestSize = dstBufferSize-1;
             dictSize = FUZ_rLogLength(&lseed, dictLog);    
             dict = srcBuffer + (FUZ_rand(&lseed) % (srcBufferSize - dictSize));
             DISPLAYLEVEL(6, ""fuzzer t%u: Compressing up to <=%u bytes at level %i with dictionary size %u \n"",
                             testNb, (U32)maxTestSize, cLevel, (U32)dictSize);
             if (FUZ_rand(&lseed) & 0xF) {
                 CHECK_Z ( ZSTD_compressBegin_usingDict(refCtx, dict, dictSize, cLevel) );
             } else {
                 ZSTD_compressionParameters const cPar = ZSTD_getCParams(cLevel, ZSTD_CONTENTSIZE_UNKNOWN, dictSize);
                 ZSTD_frameParameters const fPar = { FUZ_rand(&lseed)&1  ,
                                                     !(FUZ_rand(&lseed)&3)  ,
                                                     0   };    
                 ZSTD_parameters const p = FUZ_makeParams(cPar, fPar);
                 CHECK_Z ( ZSTD_compressBegin_advanced(refCtx, dict, dictSize, p, 0) );
             }
             CHECK_Z( ZSTD_copyCCtx(ctx, refCtx, 0) );
         }
         {   U32 const nbChunks = (FUZ_rand(&lseed) & 127) + 2;
             U32 n;
             XXH64_state_t xxhState;
             XXH64_reset(&xxhState, 0);
             for (totalTestSize=0, cSize=0, n=0 ; n<nbChunks ; n++) {
                 size_t const segmentSize = FUZ_randomLength(&lseed, maxSampleLog);
                 size_t const segmentStart = FUZ_rand(&lseed) % (srcBufferSize - segmentSize);
                 if (cBufferSize-cSize < ZSTD_compressBound(segmentSize)) break;    
                 if (totalTestSize+segmentSize > maxTestSize) break;
                 {   size_t const compressResult = ZSTD_compressContinue(ctx, cBuffer+cSize, cBufferSize-cSize, srcBuffer+segmentStart, segmentSize);
                     CHECK (ZSTD_isError(compressResult), ""multi-segments compression error : %s"", ZSTD_getErrorName(compressResult));
                     cSize += compressResult;
                 }
                 XXH64_update(&xxhState, srcBuffer+segmentStart, segmentSize);
                 memcpy(mirrorBuffer + totalTestSize, srcBuffer+segmentStart, segmentSize);
                 totalTestSize += segmentSize;
             }
             {   size_t const flushResult = ZSTD_compressEnd(ctx, cBuffer+cSize, cBufferSize-cSize, NULL, 0);
                 CHECK (ZSTD_isError(flushResult), ""multi-segments epilogue error : %s"", ZSTD_getErrorName(flushResult));
                 cSize += flushResult;
             }
             crcOrig = XXH64_digest(&xxhState);
         }
         DISPLAYLEVEL(5, ""fuzzer t%u: Bufferless streaming decompression test \n"", testNb);
         {   ZSTD_frameHeader zfh;
             CHECK( ZSTD_getFrameHeader(&zfh, cBuffer, ZSTD_frameHeaderSize_max),
                   ""ZSTD_getFrameHeader(): error retrieving frame information"");
             {   size_t const roundBuffSize = ZSTD_decodingBufferSize_min(zfh.windowSize, zfh.frameContentSize);
                 CHECK_Z(roundBuffSize);
                 CHECK((roundBuffSize > totalTestSize) && (zfh.frameContentSize!=ZSTD_CONTENTSIZE_UNKNOWN),
                       ""ZSTD_decodingBufferSize_min() requires more memory (%u) than necessary (%u)"",
                       (U32)roundBuffSize, (U32)totalTestSize );
         }   }
         if (dictSize<8) dictSize=0, dict=NULL;    
         CHECK_Z( ZSTD_decompressBegin_usingDict(dctx, dict, dictSize) );
         totalCSize = 0;
         totalGenSize = 0;
         while (totalCSize < cSize) {
             size_t const inSize = ZSTD_nextSrcSizeToDecompress(dctx);
             size_t const genSize = ZSTD_decompressContinue(dctx, dstBuffer+totalGenSize, dstBufferSize-totalGenSize, cBuffer+totalCSize, inSize);
             CHECK (ZSTD_isError(genSize), ""ZSTD_decompressContinue error : %s"", ZSTD_getErrorName(genSize));
             totalGenSize += genSize;
             totalCSize += inSize;
         }
         CHECK (ZSTD_nextSrcSizeToDecompress(dctx) != 0, ""frame not fully decoded"");
         CHECK (totalGenSize != totalTestSize, ""streaming decompressed data : wrong size"")
         CHECK (totalCSize != cSize, ""compressed data should be fully read"")
         {   U64 const crcDest = XXH64(dstBuffer, totalTestSize, 0);
             CHECK(crcOrig != crcDest, ""streaming decompressed data corrupted (pos %u / %u)"",
                 (U32)findDiff(mirrorBuffer, dstBuffer, totalTestSize), (U32)totalTestSize);
         }
     }    
     DISPLAY(""\r%u fuzzer tests completed   \n"", testNb-1);
 _cleanup:
     ZSTD_freeCCtx(refCtx);
     ZSTD_freeCCtx(ctx);
     ZSTD_freeDCtx(dctx);
     free(cNoiseBuffer[0]);
     free(cNoiseBuffer[1]);
     free(cNoiseBuffer[2]);
     free(cNoiseBuffer[3]);
     free(cNoiseBuffer[4]);
     free(cBuffer);
     free(dstBuffer);
     free(mirrorBuffer);
     return result;
 _output_error:
     result = 1;
     goto _cleanup;
 }","[77, 78, 79, 80, 84, 85, 89, 90]",A race condition in the one-pass compression functions of Zstandard prior to version 1.3.8 could allow an attacker to write bytes out of bounds if an output buffer smaller than the recommended size was used.,zstd,CVE-2019-11922,CWE-362
6658,182615," int jpc_dec_decodepkts(jpc_dec_t *dec, jas_stream_t *pkthdrstream, jas_stream_t *in)
 {
 	jpc_dec_tile_t *tile;
 	jpc_pi_t *pi;
 	int ret;
  	tile = dec->curtile;
  	pi = tile->pi;
  	for (;;) {
if (!tile->pkthdrstream || jas_stream_peekc(tile->pkthdrstream) == EOF) {
		switch (jpc_dec_lookahead(in)) {
		case JPC_MS_EOC:
		case JPC_MS_SOT:
			return 0;
			break;
		case JPC_MS_SOP:
		case JPC_MS_EPH:
		case 0:
			break;
		default:
			return -1;
			break;
 		if (!tile->pkthdrstream || jas_stream_peekc(tile->pkthdrstream) == EOF) {
 			switch (jpc_dec_lookahead(in)) {
 			case JPC_MS_EOC:
 			case JPC_MS_SOT:
 				return 0;
 				break;
 			case JPC_MS_SOP:
 			case JPC_MS_EPH:
 			case 0:
 				break;
 			default:
 				return -1;
 				break;
 			}
  		}
}
  		if ((ret = jpc_pi_next(pi))) {
  			return ret;
  		}
if (dec->maxpkts >= 0 && dec->numpkts >= dec->maxpkts) {
	jas_eprintf(""warning: stopping decode prematurely as requested\n"");
	return 0;
}
 		if (dec->maxpkts >= 0 && dec->numpkts >= dec->maxpkts) {
 			jas_eprintf(""warning: stopping decode prematurely as requested\n"");
 			return 0;
 		}
  		if (jas_getdbglevel() >= 1) {
  			jas_eprintf(""packet offset=%08ld prg=%d cmptno=%02d ""
  			  ""rlvlno=%02d prcno=%03d lyrno=%02d\n"", (long)
  			  jas_stream_getrwcount(in), jpc_pi_prg(pi), jpc_pi_cmptno(pi),
  			  jpc_pi_rlvlno(pi), jpc_pi_prcno(pi), jpc_pi_lyrno(pi));
  		}
		if (jpc_dec_decodepkt(dec, pkthdrstream, in, jpc_pi_cmptno(pi), jpc_pi_rlvlno(pi),
		  jpc_pi_prcno(pi), jpc_pi_lyrno(pi))) {
 		if (jpc_dec_decodepkt(dec, pkthdrstream, in, jpc_pi_cmptno(pi),
 		  jpc_pi_rlvlno(pi), jpc_pi_prcno(pi), jpc_pi_lyrno(pi))) {
  			return -1;
  		}
++dec->numpkts;
 		++dec->numpkts;
  	}
  	return 0;
 }","[9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 37, 41, 42, 43, 44, 45, 46, 47, 48, 55, 56, 57, 58, 61, 62]",An out-of-bounds heap read vulnerability was found in the jpc_pi_nextpcrl() function of jasper before 2.0.6 when processing crafted input.,jasper,CVE-2016-9583,CWE-125
6669,178612," SProcXFixesCreatePointerBarrier(ClientPtr client)
 {
     REQUEST(xXFixesCreatePointerBarrierReq);
     int i;
      int i;
      CARD16 *in_devices = (CARD16 *) &stuff[1];
     REQUEST_AT_LEAST_SIZE(xXFixesCreatePointerBarrierReq);
      swaps(&stuff->length);
      swaps(&stuff->num_devices);
      REQUEST_FIXED_SIZE(xXFixesCreatePointerBarrierReq, pad_to_int32(stuff->num_devices));
     swaps(&stuff->x1);
     swaps(&stuff->y1);
     swaps(&stuff->x2);
     swaps(&stuff->y2);
     swapl(&stuff->directions);
     for (i = 0; i < stuff->num_devices; i++) {
         swaps(in_devices + i);
     }
     return ProcXFixesVector[stuff->xfixesReqType] (client);
 }",[7],xorg-x11-server before 1.19.5 was missing length validation in XFIXES extension allowing malicious X client to cause X server to crash or possibly execute arbitrary code.,xserver,CVE-2017-12183,CWE-20
6683,183350," static int jpc_pi_nextrpcl(register jpc_pi_t *pi)
 {
 	int rlvlno;
 	jpc_pirlvl_t *pirlvl;
 	jpc_pchg_t *pchg;
 	int prchind;
 	int prcvind;
 	int *prclyrno;
 	int compno;
 	jpc_picomp_t *picomp;
 	int xstep;
 	int ystep;
 	uint_fast32_t r;
 	uint_fast32_t rpx;
 	uint_fast32_t rpy;
 	uint_fast32_t trx0;
 	uint_fast32_t try0;
 	pchg = pi->pchg;
 	if (!pi->prgvolfirst) {
 		goto skip;
 	} else {
 		pi->xstep = 0;
 		pi->ystep = 0;
 		for (compno = 0, picomp = pi->picomps; compno < pi->numcomps;
 		  ++compno, ++picomp) {
  			for (rlvlno = 0, pirlvl = picomp->pirlvls; rlvlno <
  			  picomp->numrlvls; ++rlvlno, ++pirlvl) {
				if (pirlvl->prcwidthexpn + pi->picomp->numrlvls >
 				if (pirlvl->prcwidthexpn + picomp->numrlvls >
  				  JAS_UINTFAST32_NUMBITS - 2 ||
				  pirlvl->prcheightexpn + pi->picomp->numrlvls >
 				  pirlvl->prcheightexpn + picomp->numrlvls >
  				  JAS_UINTFAST32_NUMBITS - 2) {
  					return -1;
  				}
 				xstep = picomp->hsamp * (JAS_CAST(uint_fast32_t, 1) <<
 				  (pirlvl->prcwidthexpn + picomp->numrlvls - rlvlno - 1));
 				ystep = picomp->vsamp * (JAS_CAST(uint_fast32_t, 1) <<
 				  (pirlvl->prcheightexpn + picomp->numrlvls - rlvlno - 1));
 				pi->xstep = (!pi->xstep) ? xstep : JAS_MIN(pi->xstep, xstep);
 				pi->ystep = (!pi->ystep) ? ystep : JAS_MIN(pi->ystep, ystep);
 			}
 		}
 		pi->prgvolfirst = 0;
 	}
 	for (pi->rlvlno = pchg->rlvlnostart; pi->rlvlno < pchg->rlvlnoend &&
 	  pi->rlvlno < pi->maxrlvls; ++pi->rlvlno) {
 		for (pi->y = pi->ystart; pi->y < pi->yend; pi->y +=
 		  pi->ystep - (pi->y % pi->ystep)) {
 			for (pi->x = pi->xstart; pi->x < pi->xend; pi->x +=
 			  pi->xstep - (pi->x % pi->xstep)) {
 				for (pi->compno = pchg->compnostart,
 				  pi->picomp = &pi->picomps[pi->compno];
 				  pi->compno < JAS_CAST(int, pchg->compnoend) && pi->compno <
 				  pi->numcomps; ++pi->compno, ++pi->picomp) {
 					if (pi->rlvlno >= pi->picomp->numrlvls) {
 						continue;
 					}
 					pi->pirlvl = &pi->picomp->pirlvls[pi->rlvlno];
 					if (pi->pirlvl->numprcs == 0) {
 						continue;
 					}
 					r = pi->picomp->numrlvls - 1 - pi->rlvlno;
 					rpx = r + pi->pirlvl->prcwidthexpn;
 					rpy = r + pi->pirlvl->prcheightexpn;
 					trx0 = JPC_CEILDIV(pi->xstart, pi->picomp->hsamp << r);
 					try0 = JPC_CEILDIV(pi->ystart, pi->picomp->vsamp << r);
 					if (((pi->x == pi->xstart &&
 					  ((trx0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpx)))
 					  || !(pi->x % (JAS_CAST(uint_fast32_t, 1) << rpx))) &&
 					  ((pi->y == pi->ystart &&
 					  ((try0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpy)))
 					  || !(pi->y % (JAS_CAST(uint_fast32_t, 1) << rpy)))) {
 						prchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x,
 						  pi->picomp->hsamp << r), pi->pirlvl->prcwidthexpn) -
 						  JPC_FLOORDIVPOW2(trx0, pi->pirlvl->prcwidthexpn);
 						prcvind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->y,
 						  pi->picomp->vsamp << r), pi->pirlvl->prcheightexpn) -
 						  JPC_FLOORDIVPOW2(try0, pi->pirlvl->prcheightexpn);
 						pi->prcno = prcvind * pi->pirlvl->numhprcs + prchind;
 						assert(pi->prcno < pi->pirlvl->numprcs);
 						for (pi->lyrno = 0; pi->lyrno <
 						  pi->numlyrs && pi->lyrno < JAS_CAST(int,
 						  pchg->lyrnoend); ++pi->lyrno) {
 							prclyrno = &pi->pirlvl->prclyrnos[pi->prcno];
 							if (pi->lyrno >= *prclyrno) {
 								++(*prclyrno);
 								return 0;
 							}
 skip:
 							;
 						}
 					}
 				}
 			}
 		}
 	}
 	return 1;
 }","[28, 29, 31, 32]",An out-of-bounds heap read vulnerability was found in the jpc_pi_nextpcrl() function of jasper before 2.0.6 when processing crafted input.,jasper,CVE-2016-9583,CWE-125
6697,179581," path_in(PG_FUNCTION_ARGS)
 {
 	char	   *str = PG_GETARG_CSTRING(0);
 	PATH	   *path;
 	int			isopen;
  	char	   *s;
  	int			npts;
  	int			size;
 	int			base_size;
  	int			depth = 0;
  	if ((npts = pair_count(str, ',')) <= 0)
 		ereport(ERROR,
 				(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),
 				 errmsg(""invalid input syntax for type path: \""%s\"""", str)));
 	s = str;
 	while (isspace((unsigned char) *s))
 		s++;
 	if ((*s == LDELIM) && (strrchr(s, LDELIM) == s))
 	{
 		s++;
  		depth++;
  	}
	size = offsetof(PATH, p[0]) +sizeof(path->p[0]) * npts;
 	base_size = sizeof(path->p[0]) * npts;
 	size = offsetof(PATH, p[0]) + base_size;
 	if (base_size / npts != sizeof(path->p[0]) || size <= base_size)
 		ereport(ERROR,
 				(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),
 				 errmsg(""too many points requested"")));
  	path = (PATH *) palloc(size);
  	SET_VARSIZE(path, size);
 	path->npts = npts;
 	if ((!path_decode(TRUE, npts, s, &isopen, &s, &(path->p[0])))
 	&& (!((depth == 0) && (*s == '\0'))) && !((depth >= 1) && (*s == RDELIM)))
 		ereport(ERROR,
 				(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),
 				 errmsg(""invalid input syntax for type path: \""%s\"""", str)));
 	path->closed = (!isopen);
 	path->dummy = 0;
 	PG_RETURN_PATH_P(path);
 }","[9, 23, 24, 25, 26, 27, 28, 29]","Multiple integer overflows in contrib/hstore/hstore_io.c in PostgreSQL 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact via vectors related to the (1) hstore_recv, (2) hstore_from_arrays, and (3) hstore_from_array functions in contrib/hstore/hstore_io.c; and the (4) hstoreArrayToPairs function in contrib/hstore/hstore_op.c, which triggers a buffer overflow.  NOTE: this issue was SPLIT from CVE-2014-0064 because it has a different set of affected versions.",postgres,CVE-2014-2669,CWE-189
6706,181870,"  void jas_matrix_asr(jas_matrix_t *matrix, int n)
  {
	int i;
	int j;
 	jas_matind_t i;
 	jas_matind_t j;
  	jas_seqent_t *rowstart;
	int rowstep;
 	jas_matind_t rowstep;
  	jas_seqent_t *data;
  	assert(n >= 0);
 	if (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {
 		assert(matrix->rows_);
 		rowstep = jas_matrix_rowstep(matrix);
 		for (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,
 		  rowstart += rowstep) {
 			for (j = matrix->numcols_, data = rowstart; j > 0; --j,
 			  ++data) {
 				*data = jas_seqent_asr(*data, n);
 			}
 		}
 	}
 }","[3, 4, 5, 6, 8, 9]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
6710,183219,"  header_gets (SF_PRIVATE *psf, char *ptr, int bufsize)
  {	int		k ;
 	if (psf->header.indx + bufsize >= psf->header.len && psf_bump_header_allocation (psf, bufsize))
 		return 0 ;
  	for (k = 0 ; k < bufsize - 1 ; k++)
	{	if (psf->headindex < psf->headend)
		{	ptr [k] = psf->header [psf->headindex] ;
			psf->headindex ++ ;
 	{	if (psf->header.indx < psf->header.end)
 		{	ptr [k] = psf->header.ptr [psf->header.indx] ;
 			psf->header.indx ++ ;
  			}
  		else
		{	psf->headend += psf_fread (psf->header + psf->headend, 1, 1, psf) ;
			ptr [k] = psf->header [psf->headindex] ;
			psf->headindex = psf->headend ;
 		{	psf->header.end += psf_fread (psf->header.ptr + psf->header.end, 1, 1, psf) ;
 			ptr [k] = psf->header.ptr [psf->header.indx] ;
 			psf->header.indx = psf->header.end ;
  			} ;
  		if (ptr [k] == '\n')
 			break ;
 		} ;
 	ptr [k] = 0 ;
 	return k ;
 }  ","[3, 4, 6, 7, 8, 9, 10, 11, 14, 15, 16, 17, 18, 19]","In libsndfile before 1.0.28, an error in the *header_read()* function (common.c) when handling ID3 tags can be exploited to cause a stack-based buffer overflow via a specially crafted FLAC file.",libsndfile,CVE-2017-7586,CWE-119
6713,179572," hstoreArrayToPairs(ArrayType *a, int *npairs)
 {
 	Datum	   *key_datums;
 	bool	   *key_nulls;
 	int			key_count;
 	Pairs	   *key_pairs;
 	int			bufsiz;
 	int			i,
 				j;
 	deconstruct_array(a,
 					  TEXTOID, -1, false, 'i',
 					  &key_datums, &key_nulls, &key_count);
 	if (key_count == 0)
 	{
 		*npairs = 0;
  		return NULL;
  	}
 	if (key_count > MaxAllocSize / sizeof(Pairs))
 		ereport(ERROR,
 				(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),
 			  errmsg(""number of pairs (%d) exceeds the maximum allowed (%d)"",
 					 key_count, (int) (MaxAllocSize / sizeof(Pairs)))));
  	key_pairs = palloc(sizeof(Pairs) * key_count);
  	for (i = 0, j = 0; i < key_count; i++)
 	{
 		if (!key_nulls[i])
 		{
 			key_pairs[j].key = VARDATA(key_datums[i]);
 			key_pairs[j].keylen = VARSIZE(key_datums[i]) - VARHDRSZ;
 			key_pairs[j].val = NULL;
 			key_pairs[j].vallen = 0;
 			key_pairs[j].needfree = 0;
 			key_pairs[j].isnull = 1;
 			j++;
 		}
 	}
 	*npairs = hstoreUniquePairs(key_pairs, j, &bufsiz);
 	return key_pairs;
 }","[18, 19, 20, 21, 22]","Multiple integer overflows in contrib/hstore/hstore_io.c in PostgreSQL 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact via vectors related to the (1) hstore_recv, (2) hstore_from_arrays, and (3) hstore_from_array functions in contrib/hstore/hstore_io.c; and the (4) hstoreArrayToPairs function in contrib/hstore/hstore_op.c, which triggers a buffer overflow.  NOTE: this issue was SPLIT from CVE-2014-0064 because it has a different set of affected versions.",postgres,CVE-2014-2669,CWE-189
6720,178408," LockServer(void)
 {
   char tmp[PATH_MAX], pid_str[12];
   int lfd, i, haslock, l_pid, t;
   char *tmppath = NULL;
   int len;
   char port[20];
   if (nolock) return;
   tmppath = LOCK_DIR;
   sprintf(port, ""%d"", atoi(display));
   len = strlen(LOCK_PREFIX) > strlen(LOCK_TMP_PREFIX) ? strlen(LOCK_PREFIX) :
 						strlen(LOCK_TMP_PREFIX);
   len += strlen(tmppath) + strlen(port) + strlen(LOCK_SUFFIX) + 1;
   if (len > sizeof(LockFile))
     FatalError(""Display name `%s' is too long\n"", port);
   (void)sprintf(tmp, ""%s"" LOCK_TMP_PREFIX ""%s"" LOCK_SUFFIX, tmppath, port);
   (void)sprintf(LockFile, ""%s"" LOCK_PREFIX ""%s"" LOCK_SUFFIX, tmppath, port);
   StillLocking = TRUE;
   i = 0;
   do {
     i++;
     lfd = open(tmp, O_CREAT | O_EXCL | O_WRONLY, 0644);
     if (lfd < 0)
        sleep(2);
     else
        break;
   } while (i < 3);
   if (lfd < 0) {
     unlink(tmp);
     i = 0;
     do {
       i++;
       lfd = open(tmp, O_CREAT | O_EXCL | O_WRONLY, 0644);
       if (lfd < 0)
          sleep(2);
       else
          break;
     } while (i < 3);
   }
   if (lfd < 0)
      FatalError(""Could not create lock file in %s\n"", tmp);
    (void) sprintf(pid_str, ""%10ld\n"", (long)getpid());
    (void) write(lfd, pid_str, 11);
  (void) chmod(tmp, 0444);
   (void) fchmod(lfd, 0444);
    (void) close(lfd);
   i = 0;
   haslock = 0;
   while ((!haslock) && (i++ < 3)) {
     haslock = (link(tmp,LockFile) == 0);
     if (haslock) {
       break;
     }
     else {
       lfd = open(LockFile, O_RDONLY|O_NOFOLLOW);
       if (lfd < 0) {
         unlink(tmp);
         FatalError(""Can't read lock file %s\n"", LockFile);
       }
       pid_str[0] = '\0';
       if (read(lfd, pid_str, 11) != 11) {
         unlink(LockFile);
         close(lfd);
         continue;
       }
       pid_str[11] = '\0';
       sscanf(pid_str, ""%d"", &l_pid);
       close(lfd);
       errno = 0;
       t = kill(l_pid, 0);
       if ((t< 0) && (errno == ESRCH)) {
         unlink(LockFile);
         continue;
       }
       else if (((t < 0) && (errno == EPERM)) || (t == 0)) {
         unlink(tmp);
 	FatalError(""Server is already active for display %s\n%s %s\n%s\n"",
 		   port, ""\tIf this server is no longer running, remove"",
 		   LockFile, ""\tand start again."");
       }
     }
   }
   unlink(tmp);
   if (!haslock)
     FatalError(""Could not create server lock file: %s\n"", LockFile);
   StillLocking = FALSE;
 }","[44, 45]","The LockServer function in os/utils.c in X.Org xserver before 1.11.2 allows local users to change the permissions of arbitrary files to 444, read those files, and possibly cause a denial of service (removed execution permission) via a symlink attack on a temporary lock file.",xserver,CVE-2011-4029,CWE-362
6743,182788," static int lookup1_values(int entries, int dim)
 {
     int r = (int) floor(exp((float) log((float) entries) / dim));
     if ((int) floor(pow((float) r+1, dim)) <= entries)    
        ++r;                                               
   assert(pow((float) r+1, dim) > entries);
   assert((int) floor(pow((float) r, dim)) <= entries);  
    if (pow((float) r+1, dim) <= entries)
       return -1;
    if ((int) floor(pow((float) r, dim)) > entries)
       return -1;
     return r;
  }","[6, 7, 8, 9, 10, 11]",A reachable assertion in the lookup1_values function in stb_vorbis through 2019-03-04 allows an attacker to cause a denial of service by opening a crafted Ogg Vorbis file.,stb,CVE-2019-13223,CWE-20
6744,180557," static int mov_read_dref(MOVContext *c, AVIOContext *pb, MOVAtom atom)
 {
     AVStream *st;
     MOVStreamContext *sc;
     int entries, i, j;
     if (c->fc->nb_streams < 1)
         return 0;
     st = c->fc->streams[c->fc->nb_streams-1];
     sc = st->priv_data;
     avio_rb32(pb);  
     entries = avio_rb32(pb);
      if (entries >= UINT_MAX / sizeof(*sc->drefs))
          return AVERROR_INVALIDDATA;
      av_free(sc->drefs);
     sc->drefs_count = 0;
      sc->drefs = av_mallocz(entries * sizeof(*sc->drefs));
      if (!sc->drefs)
          return AVERROR(ENOMEM);
     sc->drefs_count = entries;
     for (i = 0; i < sc->drefs_count; i++) {
         MOVDref *dref = &sc->drefs[i];
         uint32_t size = avio_rb32(pb);
         int64_t next = avio_tell(pb) + size - 4;
         if (size < 12)
             return AVERROR_INVALIDDATA;
         dref->type = avio_rl32(pb);
         avio_rb32(pb);  
         av_dlog(c->fc, ""type %.4s size %d\n"", (char*)&dref->type, size);
         if (dref->type == MKTAG('a','l','i','s') && size > 150) {
             uint16_t volume_len, len;
             int16_t type;
             avio_skip(pb, 10);
             volume_len = avio_r8(pb);
             volume_len = FFMIN(volume_len, 27);
             avio_read(pb, dref->volume, 27);
             dref->volume[volume_len] = 0;
             av_log(c->fc, AV_LOG_DEBUG, ""volume %s, len %d\n"", dref->volume, volume_len);
             avio_skip(pb, 12);
             len = avio_r8(pb);
             len = FFMIN(len, 63);
             avio_read(pb, dref->filename, 63);
             dref->filename[len] = 0;
             av_log(c->fc, AV_LOG_DEBUG, ""filename %s, len %d\n"", dref->filename, len);
             avio_skip(pb, 16);
             dref->nlvl_from = avio_rb16(pb);
             dref->nlvl_to   = avio_rb16(pb);
             av_log(c->fc, AV_LOG_DEBUG, ""nlvl from %d, nlvl to %d\n"",
                    dref->nlvl_from, dref->nlvl_to);
             avio_skip(pb, 16);
             for (type = 0; type != -1 && avio_tell(pb) < next; ) {
                 if(url_feof(pb))
                     return AVERROR_EOF;
                 type = avio_rb16(pb);
                 len = avio_rb16(pb);
                 av_log(c->fc, AV_LOG_DEBUG, ""type %d, len %d\n"", type, len);
                 if (len&1)
                     len += 1;
                 if (type == 2) {  
                     av_free(dref->path);
                     dref->path = av_mallocz(len+1);
                     if (!dref->path)
                         return AVERROR(ENOMEM);
                     avio_read(pb, dref->path, len);
                     if (len > volume_len && !strncmp(dref->path, dref->volume, volume_len)) {
                         len -= volume_len;
                         memmove(dref->path, dref->path+volume_len, len);
                         dref->path[len] = 0;
                     }
                     for (j = 0; j < len; j++)
                         if (dref->path[j] == ':')
                             dref->path[j] = '/';
                     av_log(c->fc, AV_LOG_DEBUG, ""path %s\n"", dref->path);
                 } else if (type == 0) {  
                     av_free(dref->dir);
                     dref->dir = av_malloc(len+1);
                     if (!dref->dir)
                         return AVERROR(ENOMEM);
                     avio_read(pb, dref->dir, len);
                     dref->dir[len] = 0;
                     for (j = 0; j < len; j++)
                         if (dref->dir[j] == ':')
                             dref->dir[j] = '/';
                     av_log(c->fc, AV_LOG_DEBUG, ""dir %s\n"", dref->dir);
                 } else
                     avio_skip(pb, len);
             }
         }
         avio_seek(pb, next, SEEK_SET);
     }
     return 0;
 }",[15],The mov_read_dref function in libavformat/mov.c in Libav before 11.7 and FFmpeg before 0.11 allows remote attackers to cause a denial of service (memory corruption) or execute arbitrary code via the entries value in a dref box in an MP4 file.,FFmpeg,CVE-2016-3062,CWE-119
6763,181247," static int xwd_decode_frame(AVCodecContext *avctx, void *data,
                             int *got_frame, AVPacket *avpkt)
 {
     AVFrame *p = data;
     const uint8_t *buf = avpkt->data;
     int i, ret, buf_size = avpkt->size;
     uint32_t version, header_size, vclass, ncolors;
     uint32_t xoffset, be, bpp, lsize, rsize;
     uint32_t pixformat, pixdepth, bunit, bitorder, bpad;
     uint32_t rgb[3];
     uint8_t *ptr;
     GetByteContext gb;
     if (buf_size < XWD_HEADER_SIZE)
         return AVERROR_INVALIDDATA;
     bytestream2_init(&gb, buf, buf_size);
     header_size = bytestream2_get_be32u(&gb);
     version = bytestream2_get_be32u(&gb);
     if (version != XWD_VERSION) {
         av_log(avctx, AV_LOG_ERROR, ""unsupported version\n"");
         return AVERROR_INVALIDDATA;
     }
     if (buf_size < header_size || header_size < XWD_HEADER_SIZE) {
         av_log(avctx, AV_LOG_ERROR, ""invalid header size\n"");
         return AVERROR_INVALIDDATA;
     }
     pixformat     = bytestream2_get_be32u(&gb);
     pixdepth      = bytestream2_get_be32u(&gb);
     avctx->width  = bytestream2_get_be32u(&gb);
     avctx->height = bytestream2_get_be32u(&gb);
     xoffset       = bytestream2_get_be32u(&gb);
     be            = bytestream2_get_be32u(&gb);
     bunit         = bytestream2_get_be32u(&gb);
     bitorder      = bytestream2_get_be32u(&gb);
     bpad          = bytestream2_get_be32u(&gb);
     bpp           = bytestream2_get_be32u(&gb);
     lsize         = bytestream2_get_be32u(&gb);
     vclass        = bytestream2_get_be32u(&gb);
     rgb[0]        = bytestream2_get_be32u(&gb);
     rgb[1]        = bytestream2_get_be32u(&gb);
     rgb[2]        = bytestream2_get_be32u(&gb);
     bytestream2_skipu(&gb, 8);
     ncolors       = bytestream2_get_be32u(&gb);
     bytestream2_skipu(&gb, header_size - (XWD_HEADER_SIZE - 20));
     av_log(avctx, AV_LOG_DEBUG,
            ""pixformat %""PRIu32"", pixdepth %""PRIu32"", bunit %""PRIu32"", bitorder %""PRIu32"", bpad %""PRIu32""\n"",
            pixformat, pixdepth, bunit, bitorder, bpad);
     av_log(avctx, AV_LOG_DEBUG,
            ""vclass %""PRIu32"", ncolors %""PRIu32"", bpp %""PRIu32"", be %""PRIu32"", lsize %""PRIu32"", xoffset %""PRIu32""\n"",
            vclass, ncolors, bpp, be, lsize, xoffset);
     av_log(avctx, AV_LOG_DEBUG,
            ""red %0""PRIx32"", green %0""PRIx32"", blue %0""PRIx32""\n"",
            rgb[0], rgb[1], rgb[2]);
     if (pixformat > XWD_Z_PIXMAP) {
         av_log(avctx, AV_LOG_ERROR, ""invalid pixmap format\n"");
         return AVERROR_INVALIDDATA;
     }
     if (pixdepth == 0 || pixdepth > 32) {
         av_log(avctx, AV_LOG_ERROR, ""invalid pixmap depth\n"");
         return AVERROR_INVALIDDATA;
     }
     if (xoffset) {
         avpriv_request_sample(avctx, ""xoffset %""PRIu32"""", xoffset);
         return AVERROR_PATCHWELCOME;
     }
     if (be > 1) {
         av_log(avctx, AV_LOG_ERROR, ""invalid byte order\n"");
         return AVERROR_INVALIDDATA;
     }
     if (bitorder > 1) {
         av_log(avctx, AV_LOG_ERROR, ""invalid bitmap bit order\n"");
         return AVERROR_INVALIDDATA;
     }
     if (bunit != 8 && bunit != 16 && bunit != 32) {
         av_log(avctx, AV_LOG_ERROR, ""invalid bitmap unit\n"");
         return AVERROR_INVALIDDATA;
     }
     if (bpad != 8 && bpad != 16 && bpad != 32) {
         av_log(avctx, AV_LOG_ERROR, ""invalid bitmap scan-line pad\n"");
         return AVERROR_INVALIDDATA;
     }
     if (bpp == 0 || bpp > 32) {
         av_log(avctx, AV_LOG_ERROR, ""invalid bits per pixel\n"");
         return AVERROR_INVALIDDATA;
     }
     if (ncolors > 256) {
         av_log(avctx, AV_LOG_ERROR, ""invalid number of entries in colormap\n"");
         return AVERROR_INVALIDDATA;
     }
     if ((ret = av_image_check_size(avctx->width, avctx->height, 0, NULL)) < 0)
         return ret;
     rsize = FFALIGN(avctx->width * bpp, bpad) / 8;
     if (lsize < rsize) {
         av_log(avctx, AV_LOG_ERROR, ""invalid bytes per scan-line\n"");
         return AVERROR_INVALIDDATA;
     }
     if (bytestream2_get_bytes_left(&gb) < ncolors * XWD_CMAP_SIZE + (uint64_t)avctx->height * lsize) {
         av_log(avctx, AV_LOG_ERROR, ""input buffer too small\n"");
         return AVERROR_INVALIDDATA;
     }
     if (pixformat != XWD_Z_PIXMAP) {
         avpriv_report_missing_feature(avctx, ""Pixmap format %""PRIu32, pixformat);
         return AVERROR_PATCHWELCOME;
     }
     avctx->pix_fmt = AV_PIX_FMT_NONE;
     switch (vclass) {
     case XWD_STATIC_GRAY:
      case XWD_GRAY_SCALE:
          if (bpp != 1 && bpp != 8)
              return AVERROR_INVALIDDATA;
        if (pixdepth == 1) {
         if (bpp == 1 && pixdepth == 1) {
              avctx->pix_fmt = AV_PIX_FMT_MONOWHITE;
        } else if (pixdepth == 8) {
         } else if (bpp == 8 && pixdepth == 8) {
              avctx->pix_fmt = AV_PIX_FMT_GRAY8;
          }
          break;
     case XWD_STATIC_COLOR:
     case XWD_PSEUDO_COLOR:
         if (bpp == 8)
             avctx->pix_fmt = AV_PIX_FMT_PAL8;
         break;
     case XWD_TRUE_COLOR:
     case XWD_DIRECT_COLOR:
         if (bpp != 16 && bpp != 24 && bpp != 32)
             return AVERROR_INVALIDDATA;
         if (bpp == 16 && pixdepth == 15) {
             if (rgb[0] == 0x7C00 && rgb[1] == 0x3E0 && rgb[2] == 0x1F)
                 avctx->pix_fmt = be ? AV_PIX_FMT_RGB555BE : AV_PIX_FMT_RGB555LE;
             else if (rgb[0] == 0x1F && rgb[1] == 0x3E0 && rgb[2] == 0x7C00)
                 avctx->pix_fmt = be ? AV_PIX_FMT_BGR555BE : AV_PIX_FMT_BGR555LE;
         } else if (bpp == 16 && pixdepth == 16) {
             if (rgb[0] == 0xF800 && rgb[1] == 0x7E0 && rgb[2] == 0x1F)
                 avctx->pix_fmt = be ? AV_PIX_FMT_RGB565BE : AV_PIX_FMT_RGB565LE;
             else if (rgb[0] == 0x1F && rgb[1] == 0x7E0 && rgb[2] == 0xF800)
                 avctx->pix_fmt = be ? AV_PIX_FMT_BGR565BE : AV_PIX_FMT_BGR565LE;
         } else if (bpp == 24) {
             if (rgb[0] == 0xFF0000 && rgb[1] == 0xFF00 && rgb[2] == 0xFF)
                 avctx->pix_fmt = be ? AV_PIX_FMT_RGB24 : AV_PIX_FMT_BGR24;
             else if (rgb[0] == 0xFF && rgb[1] == 0xFF00 && rgb[2] == 0xFF0000)
                 avctx->pix_fmt = be ? AV_PIX_FMT_BGR24 : AV_PIX_FMT_RGB24;
         } else if (bpp == 32) {
             if (rgb[0] == 0xFF0000 && rgb[1] == 0xFF00 && rgb[2] == 0xFF)
                 avctx->pix_fmt = be ? AV_PIX_FMT_ARGB : AV_PIX_FMT_BGRA;
             else if (rgb[0] == 0xFF && rgb[1] == 0xFF00 && rgb[2] == 0xFF0000)
                 avctx->pix_fmt = be ? AV_PIX_FMT_ABGR : AV_PIX_FMT_RGBA;
         }
         bytestream2_skipu(&gb, ncolors * XWD_CMAP_SIZE);
         break;
     default:
         av_log(avctx, AV_LOG_ERROR, ""invalid visual class\n"");
         return AVERROR_INVALIDDATA;
     }
     if (avctx->pix_fmt == AV_PIX_FMT_NONE) {
         avpriv_request_sample(avctx,
                               ""Unknown file: bpp %""PRIu32"", pixdepth %""PRIu32"", vclass %""PRIu32"""",
                               bpp, pixdepth, vclass);
         return AVERROR_PATCHWELCOME;
     }
     if ((ret = ff_get_buffer(avctx, p, 0)) < 0)
         return ret;
     p->key_frame = 1;
     p->pict_type = AV_PICTURE_TYPE_I;
     if (avctx->pix_fmt == AV_PIX_FMT_PAL8) {
         uint32_t *dst = (uint32_t *)p->data[1];
         uint8_t red, green, blue;
         for (i = 0; i < ncolors; i++) {
             bytestream2_skipu(&gb, 4);  
             red    = bytestream2_get_byteu(&gb);
             bytestream2_skipu(&gb, 1);
             green  = bytestream2_get_byteu(&gb);
             bytestream2_skipu(&gb, 1);
             blue   = bytestream2_get_byteu(&gb);
             bytestream2_skipu(&gb, 3);  
             dst[i] = red << 16 | green << 8 | blue;
         }
     }
     ptr = p->data[0];
     for (i = 0; i < avctx->height; i++) {
         bytestream2_get_bufferu(&gb, ptr, rsize);
         bytestream2_skipu(&gb, lsize - rsize);
         ptr += p->linesize[0];
     }
     *got_frame       = 1;
     return buf_size;
 }","[110, 111, 113, 114]","Heap-based buffer overflow in the xwd_decode_frame function in libavcodec/xwddec.c in FFmpeg before 2.8.12, 3.0.x before 3.0.8, 3.1.x before 3.1.8, 3.2.x before 3.2.5, and 3.3.x before 3.3.1 allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted file.",FFmpeg,CVE-2017-9991,CWE-119
6766,182332," int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)
 {
     MpegEncContext *s = &ctx->m;
     unsigned startcode, v;
     int ret;
     int vol = 0;
     align_get_bits(gb);
     if (!s->studio_profile && s->avctx->bits_per_raw_sample != 8)
         s->avctx->bits_per_raw_sample = 0;
     if (s->codec_tag == AV_RL32(""WV1F"") && show_bits(gb, 24) == 0x575630) {
         skip_bits(gb, 24);
         if (get_bits(gb, 8) == 0xF0)
             goto end;
     }
     startcode = 0xff;
     for (;;) {
         if (get_bits_count(gb) >= gb->size_in_bits) {
             if (gb->size_in_bits == 8 &&
                 (ctx->divx_version >= 0 || ctx->xvid_build >= 0) || s->codec_tag == AV_RL32(""QMP4"")) {
                 av_log(s->avctx, AV_LOG_VERBOSE, ""frame skip %d\n"", gb->size_in_bits);
                 return FRAME_SKIPPED;   
             } else
                 return AVERROR_INVALIDDATA;   
         }
         v = get_bits(gb, 8);
         startcode = ((startcode << 8) | v) & 0xffffffff;
         if ((startcode & 0xFFFFFF00) != 0x100)
             continue;   
         if (s->avctx->debug & FF_DEBUG_STARTCODE) {
             av_log(s->avctx, AV_LOG_DEBUG, ""startcode: %3X "", startcode);
             if (startcode <= 0x11F)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Video Object Start"");
             else if (startcode <= 0x12F)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Video Object Layer Start"");
             else if (startcode <= 0x13F)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Reserved"");
             else if (startcode <= 0x15F)
                 av_log(s->avctx, AV_LOG_DEBUG, ""FGS bp start"");
             else if (startcode <= 0x1AF)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Reserved"");
             else if (startcode == 0x1B0)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Visual Object Seq Start"");
             else if (startcode == 0x1B1)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Visual Object Seq End"");
             else if (startcode == 0x1B2)
                 av_log(s->avctx, AV_LOG_DEBUG, ""User Data"");
             else if (startcode == 0x1B3)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Group of VOP start"");
             else if (startcode == 0x1B4)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Video Session Error"");
             else if (startcode == 0x1B5)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Visual Object Start"");
             else if (startcode == 0x1B6)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Video Object Plane start"");
             else if (startcode == 0x1B7)
                 av_log(s->avctx, AV_LOG_DEBUG, ""slice start"");
             else if (startcode == 0x1B8)
                 av_log(s->avctx, AV_LOG_DEBUG, ""extension start"");
             else if (startcode == 0x1B9)
                 av_log(s->avctx, AV_LOG_DEBUG, ""fgs start"");
             else if (startcode == 0x1BA)
                 av_log(s->avctx, AV_LOG_DEBUG, ""FBA Object start"");
             else if (startcode == 0x1BB)
                 av_log(s->avctx, AV_LOG_DEBUG, ""FBA Object Plane start"");
             else if (startcode == 0x1BC)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Mesh Object start"");
             else if (startcode == 0x1BD)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Mesh Object Plane start"");
             else if (startcode == 0x1BE)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Still Texture Object start"");
             else if (startcode == 0x1BF)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Texture Spatial Layer start"");
             else if (startcode == 0x1C0)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Texture SNR Layer start"");
             else if (startcode == 0x1C1)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Texture Tile start"");
             else if (startcode == 0x1C2)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Texture Shape Layer start"");
             else if (startcode == 0x1C3)
                 av_log(s->avctx, AV_LOG_DEBUG, ""stuffing start"");
             else if (startcode <= 0x1C5)
                 av_log(s->avctx, AV_LOG_DEBUG, ""reserved"");
             else if (startcode <= 0x1FF)
                 av_log(s->avctx, AV_LOG_DEBUG, ""System start"");
             av_log(s->avctx, AV_LOG_DEBUG, "" at %d\n"", get_bits_count(gb));
         }
         if (startcode >= 0x120 && startcode <= 0x12F) {
             if (vol) {
                 av_log(s->avctx, AV_LOG_WARNING, ""Ignoring multiple VOL headers\n"");
                 continue;
             }
             vol++;
             if ((ret = decode_vol_header(ctx, gb)) < 0)
                 return ret;
         } else if (startcode == USER_DATA_STARTCODE) {
             decode_user_data(ctx, gb);
          } else if (startcode == GOP_STARTCODE) {
              mpeg4_decode_gop_header(s, gb);
          } else if (startcode == VOS_STARTCODE) {
            mpeg4_decode_profile_level(s, gb);
            if (s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&
                (s->avctx->level > 0 && s->avctx->level < 9)) {
             int profile, level;
             mpeg4_decode_profile_level(s, gb, &profile, &level);
             if (profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&
                 (level > 0 && level < 9)) {
                  s->studio_profile = 1;
                  next_start_code_studio(gb);
                  extension_and_user_data(s, gb, 0);
             } else if (s->studio_profile) {
                 avpriv_request_sample(s->avctx, ""Mixes studio and non studio profile\n"");
                 return AVERROR_PATCHWELCOME;
              }
             s->avctx->profile = profile;
             s->avctx->level   = level;
          } else if (startcode == VISUAL_OBJ_STARTCODE) {
              if (s->studio_profile) {
                  if ((ret = decode_studiovisualobject(ctx, gb)) < 0)
                     return ret;
             } else
                 mpeg4_decode_visual_object(s, gb);
         } else if (startcode == VOP_STARTCODE) {
             break;
         }
         align_get_bits(gb);
         startcode = 0xff;
     }
 end:
     if (s->avctx->flags & AV_CODEC_FLAG_LOW_DELAY)
         s->low_delay = 1;
      s->avctx->has_b_frames = !s->low_delay;
      if (s->studio_profile) {
         av_assert0(s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);
          if (!s->avctx->bits_per_raw_sample) {
              av_log(s->avctx, AV_LOG_ERROR, ""Missing VOL header\n"");
              return AVERROR_INVALIDDATA;
         }
         return decode_studio_vop_header(ctx, gb);
     } else
         return decode_vop_header(ctx, gb);
 }","[100, 101, 102, 103, 104, 105, 106, 110, 111, 112, 114, 115, 133]","In FFmpeg 4.0.1, due to a missing check of a profile value before setting it, the ff_mpeg4_decode_picture_header function in libavcodec/mpeg4videodec.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.",FFmpeg,CVE-2018-13301,CWE-476
6771,179590," bit_in(PG_FUNCTION_ARGS)
 {
 	char	   *input_string = PG_GETARG_CSTRING(0);
 #ifdef NOT_USED
 	Oid			typelem = PG_GETARG_OID(1);
 #endif
 	int32		atttypmod = PG_GETARG_INT32(2);
 	VarBit	   *result;			 
 	char	   *sp;				 
 	bits8	   *r;				 
 	int			len,			 
 				bitlen,			 
 				slen;			 
 	bool		bit_not_hex;	 
 	int			bc;
 	bits8		x = 0;
 	if (input_string[0] == 'b' || input_string[0] == 'B')
 	{
 		bit_not_hex = true;
 		sp = input_string + 1;
 	}
 	else if (input_string[0] == 'x' || input_string[0] == 'X')
 	{
 		bit_not_hex = false;
 		sp = input_string + 1;
 	}
 	else
 	{
 		bit_not_hex = true;
  		sp = input_string;
  	}
 	slen = strlen(sp);
  	slen = strlen(sp);
  	if (bit_not_hex)
  		bitlen = slen;
  	else
 	{
 		if (slen > VARBITMAXLEN / 4)
 			ereport(ERROR,
 					(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),
 				 errmsg(""bit string length exceeds the maximum allowed (%d)"",
 						VARBITMAXLEN)));
  		bitlen = slen * 4;
 	}
 	if (atttypmod <= 0)
 		atttypmod = bitlen;
 	else if (bitlen != atttypmod)
 		ereport(ERROR,
 				(errcode(ERRCODE_STRING_DATA_LENGTH_MISMATCH),
 				 errmsg(""bit string length %d does not match type bit(%d)"",
 						bitlen, atttypmod)));
 	len = VARBITTOTALLEN(atttypmod);
 	result = (VarBit *) palloc0(len);
 	SET_VARSIZE(result, len);
 	VARBITLEN(result) = atttypmod;
 	r = VARBITS(result);
 	if (bit_not_hex)
 	{
 		x = HIGHBIT;
 		for (; *sp; sp++)
 		{
 			if (*sp == '1')
 				*r |= x;
 			else if (*sp != '0')
 				ereport(ERROR,
 						(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),
 						 errmsg(""\""%c\"" is not a valid binary digit"",
 								*sp)));
 			x >>= 1;
 			if (x == 0)
 			{
 				x = HIGHBIT;
 				r++;
 			}
 		}
 	}
 	else
 	{
 		for (bc = 0; *sp; sp++)
 		{
 			if (*sp >= '0' && *sp <= '9')
 				x = (bits8) (*sp - '0');
 			else if (*sp >= 'A' && *sp <= 'F')
 				x = (bits8) (*sp - 'A') + 10;
 			else if (*sp >= 'a' && *sp <= 'f')
 				x = (bits8) (*sp - 'a') + 10;
 			else
 				ereport(ERROR,
 						(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),
 						 errmsg(""\""%c\"" is not a valid hexadecimal digit"",
 								*sp)));
 			if (bc)
 			{
 				*r++ |= x;
 				bc = 0;
 			}
 			else
 			{
 				*r = x << 4;
 				bc = 1;
 			}
 		}
 	}
 	PG_RETURN_VARBIT_P(result);
 }","[32, 33, 37, 38, 39, 40, 41, 42, 44]","Multiple integer overflows in contrib/hstore/hstore_io.c in PostgreSQL 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact via vectors related to the (1) hstore_recv, (2) hstore_from_arrays, and (3) hstore_from_array functions in contrib/hstore/hstore_io.c; and the (4) hstoreArrayToPairs function in contrib/hstore/hstore_op.c, which triggers a buffer overflow.  NOTE: this issue was SPLIT from CVE-2014-0064 because it has a different set of affected versions.",postgres,CVE-2014-2669,CWE-189
6772,182239," static int insert_key(
 	sc_pkcs15_card_t *p15card,
 	const char       *path,
 	unsigned char     id,
 	unsigned char     key_reference,
 	int               key_length,
 	unsigned char     auth_id,
 	const char       *label
 ){
 	sc_card_t *card=p15card->card;
 	sc_context_t *ctx=p15card->card->ctx;
 	sc_file_t *f;
 	struct sc_pkcs15_prkey_info prkey_info;
 	struct sc_pkcs15_object prkey_obj;
 	int r, can_sign, can_crypt;
 	memset(&prkey_info, 0, sizeof(prkey_info));
 	prkey_info.id.len         = 1;
 	prkey_info.id.value[0]    = id;
 	prkey_info.native         = 1;
 	prkey_info.key_reference  = key_reference;
 	prkey_info.modulus_length = key_length;
 	sc_format_path(path, &prkey_info.path);
 	memset(&prkey_obj, 0, sizeof(prkey_obj));
 	strlcpy(prkey_obj.label, label, sizeof(prkey_obj.label));
 	prkey_obj.flags            = SC_PKCS15_CO_FLAG_PRIVATE;
 	prkey_obj.auth_id.len      = 1;
 	prkey_obj.auth_id.value[0] = auth_id;
 	can_sign=can_crypt=0;
 	if(card->type==SC_CARD_TYPE_TCOS_V3){
 		unsigned char buf[256];
  		int i, rec_no=0;
  		if(prkey_info.path.len>=2) prkey_info.path.len-=2;
  		sc_append_file_id(&prkey_info.path, 0x5349);
		if(sc_select_file(card, &prkey_info.path, NULL)!=SC_SUCCESS){
 		if(sc_select_file(card, &prkey_info.path, NULL)!=SC_SUCCESS || !f->prop_attr){
  			sc_debug(ctx, SC_LOG_DEBUG_NORMAL,
  				""Select(%s) failed\n"",
  				sc_print_path(&prkey_info.path));
 			return 1;
 		}
 		sc_debug(ctx, SC_LOG_DEBUG_NORMAL,
 			""Searching for Key-Ref %02X\n"", key_reference);
 		while((r=sc_read_record(card, ++rec_no, buf, sizeof(buf), SC_RECORD_BY_REC_NR))>0){
 			int found=0;
 			if(buf[0]!=0xA0) continue;
 			for(i=2;i<buf[1]+2;i+=2+buf[i+1]){
 				if(buf[i]==0x83 && buf[i+1]==1 && buf[i+2]==key_reference) ++found;
 			}
 			if(found) break;
 		}
 		if(r<=0){
 			sc_debug(ctx, SC_LOG_DEBUG_NORMAL,""No EF_KEYD-Record found\n"");
 			return 1;
 		}
 		for(i=0;i<r;i+=2+buf[i+1]){
 			if(buf[i]==0xB6) can_sign++;
  			if(buf[i]==0xB8) can_crypt++;
  		}
  	} else {
		if(sc_select_file(card, &prkey_info.path, &f)!=SC_SUCCESS){
 		if(sc_select_file(card, &prkey_info.path, &f)!=SC_SUCCESS
 			   	|| !f->prop_attr || f->prop_attr_len < 2){
  			sc_debug(ctx, SC_LOG_DEBUG_NORMAL,
  				""Select(%s) failed\n"",
  				sc_print_path(&prkey_info.path));
 			return 1;
 		}
 		if (f->prop_attr[1] & 0x04) can_crypt=1;
 		if (f->prop_attr[1] & 0x08) can_sign=1;
 		sc_file_free(f);
 	}
 	prkey_info.usage= SC_PKCS15_PRKEY_USAGE_SIGN;
 	if(can_crypt) prkey_info.usage |= SC_PKCS15_PRKEY_USAGE_ENCRYPT|SC_PKCS15_PRKEY_USAGE_DECRYPT;
 	if(can_sign) prkey_info.usage |= SC_PKCS15_PRKEY_USAGE_NONREPUDIATION;
 	r=sc_pkcs15emu_add_rsa_prkey(p15card, &prkey_obj, &prkey_info);
 	if(r!=SC_SUCCESS){
 		sc_debug(ctx, SC_LOG_DEBUG_NORMAL, ""sc_pkcs15emu_add_rsa_prkey(%s) failed\n"", path);
 		return 4;
 	}
 	sc_debug(ctx, SC_LOG_DEBUG_NORMAL, ""%s: OK%s%s\n"", path, can_sign ? "", Sign"" : """", can_crypt ? "", Crypt"" : """");
 	return 0;
 }","[34, 35, 60, 61, 62]",Various out of bounds reads when handling responses in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to potentially crash the opensc library using programs.,OpenSC,CVE-2018-16427,CWE-125
6775,181928," jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)
 {
 	jas_image_t *image;
 	bmp_hdr_t hdr;
 	bmp_info_t *info;
 	uint_fast16_t cmptno;
 	jas_image_cmptparm_t cmptparms[3];
 	jas_image_cmptparm_t *cmptparm;
  	uint_fast16_t numcmpts;
  	long n;
 	image = 0;
 	info = 0;
  	if (optstr) {
  		jas_eprintf(""warning: ignoring BMP decoder options\n"");
  	}
 	jas_eprintf(
 	  ""THE BMP FORMAT IS NOT FULLY SUPPORTED!\n""
 	  ""THAT IS, THE JASPER SOFTWARE CANNOT DECODE ALL TYPES OF BMP DATA.\n""
 	  ""IF YOU HAVE ANY PROBLEMS, PLEASE TRY CONVERTING YOUR IMAGE DATA\n""
 	  ""TO THE PNM FORMAT, AND USING THIS FORMAT INSTEAD.\n""
 	  );
  	if (bmp_gethdr(in, &hdr)) {
  		jas_eprintf(""cannot get header\n"");
		return 0;
 		goto error;
  	}
  	JAS_DBGLOG(1, (
  	  ""BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\n"",
 	  hdr.magic, hdr.siz, hdr.reserved1, hdr.reserved2, hdr.off
 	  ));
  	if (!(info = bmp_getinfo(in))) {
  		jas_eprintf(""cannot get info\n"");
		return 0;
 		goto error;
  	}
  	JAS_DBGLOG(1,
	  (""BMP information: len %d; width %d; height %d; numplanes %d; ""
	  ""depth %d; enctype %d; siz %d; hres %d; vres %d; numcolors %d; ""
	  ""mincolors %d\n"", info->len, info->width, info->height, info->numplanes,
	  info->depth, info->enctype, info->siz, info->hres, info->vres,
	  info->numcolors, info->mincolors));
 	  (""BMP information: len %ld; width %ld; height %ld; numplanes %d; ""
 	  ""depth %d; enctype %ld; siz %ld; hres %ld; vres %ld; numcolors %ld; ""
 	  ""mincolors %ld\n"", JAS_CAST(long, info->len),
 	  JAS_CAST(long, info->width), JAS_CAST(long, info->height),
 	  JAS_CAST(long, info->numplanes), JAS_CAST(long, info->depth),
 	  JAS_CAST(long, info->enctype), JAS_CAST(long, info->siz),
 	  JAS_CAST(long, info->hres), JAS_CAST(long, info->vres),
 	  JAS_CAST(long, info->numcolors), JAS_CAST(long, info->mincolors)));
 	if (info->width < 0 || info->height < 0 || info->numplanes < 0 ||
 	  info->depth < 0 || info->siz < 0 || info->hres < 0 || info->vres < 0) {
 		jas_eprintf(""corrupt bit stream\n"");
 		goto error;
 	}
  	if (!bmp_issupported(&hdr, info)) {
  		jas_eprintf(""error: unsupported BMP encoding\n"");
		bmp_info_destroy(info);
		return 0;
 		goto error;
  	}
  	if ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {
  		jas_eprintf(""error: possibly bad bitmap offset?\n"");
		return 0;
 		goto error;
  	}
  	if (n > 0) {
  		jas_eprintf(""skipping unknown data in BMP file\n"");
  		if (bmp_gobble(in, n)) {
			bmp_info_destroy(info);
			return 0;
 			goto error;
  		}
  	}
 	numcmpts = bmp_numcmpts(info);
 	for (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,
 	  ++cmptparm) {
 		cmptparm->tlx = 0;
 		cmptparm->tly = 0;
 		cmptparm->hstep = 1;
 		cmptparm->vstep = 1;
 		cmptparm->width = info->width;
 		cmptparm->height = info->height;
 		cmptparm->prec = 8;
 		cmptparm->sgnd = false;
 	}
  	if (!(image = jas_image_create(numcmpts, cmptparms,
  	  JAS_CLRSPC_UNKNOWN))) {
		bmp_info_destroy(info);
		return 0;
 		goto error;
  	}
  	if (numcmpts == 3) {
 		jas_image_setclrspc(image, JAS_CLRSPC_SRGB);
 		jas_image_setcmpttype(image, 0,
 		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));
 		jas_image_setcmpttype(image, 1,
 		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));
 		jas_image_setcmpttype(image, 2,
 		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));
 	} else {
 		jas_image_setclrspc(image, JAS_CLRSPC_SGRAY);
 		jas_image_setcmpttype(image, 0,
 		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));
 	}
  	if (bmp_getdata(in, info, image)) {
		bmp_info_destroy(info);
		jas_image_destroy(image);
		return 0;
 		goto error;
  	}
  	bmp_info_destroy(info);
  	return image;
 error:
 	if (info) {
 		bmp_info_destroy(info);
 	}
 	if (image) {
 		jas_image_destroy(image);
 	}
 	return 0;
  }","[11, 12, 24, 25, 33, 34, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 57, 58, 59, 63, 64, 69, 70, 71, 88, 89, 90, 106, 107, 108, 109, 113, 114, 115, 116, 117, 118, 119, 120]",The bmp_getdata function in libjasper/bmp/bmp_dec.c in JasPer 1.900.5 allows remote attackers to cause a denial of service (NULL pointer dereference) by calling the imginfo command with a crafted BMP image. NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-8690.,jasper,CVE-2016-8884,CWE-476
6781,183315," tTcpIpPacketParsingResult ParaNdis_CheckSumVerify(
                                                 tCompletePhysicalAddress *pDataPages,
                                                  ULONG ulDataLength,
                                                  ULONG ulStartOffset,
                                                  ULONG flags,
                                                 BOOLEAN verifyLength,
                                                  LPCSTR caller)
  {
      IPHeader *pIpHeader = (IPHeader *) RtlOffsetToPointer(pDataPages[0].Virtual, ulStartOffset);
    tTcpIpPacketParsingResult res = QualifyIpPacket(pIpHeader, ulDataLength);
     tTcpIpPacketParsingResult res = QualifyIpPacket(pIpHeader, ulDataLength, verifyLength);
      if (res.ipStatus == ppresNotIP || res.ipCheckSum == ppresIPTooShort)
          return res;
     if (res.ipStatus == ppresIPV4)
     {
         if (flags & pcrIpChecksum)
             res = VerifyIpChecksum(&pIpHeader->v4, res, (flags & pcrFixIPChecksum) != 0);
         if(res.xxpStatus == ppresXxpKnown)
         {
             if (res.TcpUdp == ppresIsTCP)  
             {
                 if(flags & pcrTcpV4Checksum)
                 {
                     res = VerifyTcpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixTcpV4Checksum));
                 }
             }
             else  
             {
                 if (flags & pcrUdpV4Checksum)
                 {
                     res = VerifyUdpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixUdpV4Checksum));
                 }
             }
         }
     }
     else if (res.ipStatus == ppresIPV6)
     {
         if(res.xxpStatus == ppresXxpKnown)
         {
             if (res.TcpUdp == ppresIsTCP)  
             {
                 if(flags & pcrTcpV6Checksum)
                 {
                     res = VerifyTcpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixTcpV6Checksum));
                 }
             }
             else  
             {
                 if (flags & pcrUdpV6Checksum)
                 {
                     res = VerifyUdpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixUdpV6Checksum));
                 }
             }
         }
     }
     PrintOutParsingResult(res, 1, caller);
      return res;
  }","[6, 10, 11]","The NetKVM Windows Virtio driver allows remote attackers to cause a denial of service (guest crash) via a crafted length value in an IP packet, as demonstrated by a value that does not account for the size of the IP options.",kvm-guest-drivers-windows,CVE-2015-3215,CWE-20
6803,182333," static int mpeg4_decode_profile_level(MpegEncContext *s, GetBitContext *gb)
 static int mpeg4_decode_profile_level(MpegEncContext *s, GetBitContext *gb, int *profile, int *level)
  {
    s->avctx->profile = get_bits(gb, 4);
    s->avctx->level   = get_bits(gb, 4);
     *profile = get_bits(gb, 4);
     *level   = get_bits(gb, 4);
    if (s->avctx->profile == 0 && s->avctx->level == 8) {
        s->avctx->level = 0;
     if (*profile == 0 && *level == 8) {
         *level = 0;
      }
      return 0;
 }","[2, 4, 5, 6, 7, 8, 9, 10, 11]","In FFmpeg 4.0.1, due to a missing check of a profile value before setting it, the ff_mpeg4_decode_picture_header function in libavcodec/mpeg4videodec.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.",FFmpeg,CVE-2018-13301,CWE-476
6822,181889," static int jpc_ppm_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)
 {
 	jpc_ppm_t *ppm = &ms->parms.ppm;
 	cstate = 0;
 	ppm->data = 0;
 	if (ms->len < 1) {
 		goto error;
 	}
 	if (jpc_getuint8(in, &ppm->ind)) {
 		goto error;
 	}
 	ppm->len = ms->len - 1;
 	if (ppm->len > 0) {
  		if (!(ppm->data = jas_malloc(ppm->len))) {
  			goto error;
  		}
		if (JAS_CAST(uint, jas_stream_read(in, ppm->data, ppm->len)) != ppm->len) {
 		if (JAS_CAST(jas_uint, jas_stream_read(in, ppm->data, ppm->len)) != ppm->len) {
  			goto error;
  		}
  	} else {
 		ppm->data = 0;
 	}
 	return 0;
 error:
 	jpc_ppm_destroyparms(ms);
 	return -1;
 }","[17, 18]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
6830,8473,"void gitn_box_del(GF_Box *s)
{
u32 i;
GroupIdToNameBox *ptr = (GroupIdToNameBox *)s;
if (ptr == NULL) return;
for (i=0; i<ptr->nb_entries; i++) {
if (ptr->entries[i].name) gf_free(ptr->entries[i].name);
}
if (ptr->entries) gf_free(ptr->entries);
gf_free(ptr);
}","[6, 7, 9]",NULL Pointer Dereference in GitHub repository gpac/gpac prior to 1.1.0.,gpac,CVE-2021-4043,CWE-476
6831,7969,"static GF_Err av1dmx_parse_flush_sample(GF_Filter *filter, GF_AV1DmxCtx *ctx)
{
u32 pck_size;
GF_FilterPacket *pck;
u8 *output;
gf_bs_get_content_no_truncate(ctx->state.bs, &ctx->state.frame_obus, &pck_size, &ctx->state.frame_obus_alloc);
if (!pck_size) {
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[AV1Dmx] no frame OBU, skipping OBU\n""));
return GF_OK;
}
pck = gf_filter_pck_new_alloc(ctx->opid, pck_size, &output);
if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, pck);
gf_filter_pck_set_cts(pck, ctx->cts);
gf_filter_pck_set_sap(pck, ctx->state.frame_state.key_frame ? GF_FILTER_SAP_1 : 0);
memcpy(output, ctx->state.frame_obus, pck_size);
if (ctx->deps) {
u8 flags = 0;
flags = ( ctx->state.frame_state.key_frame) ? 2 : 1;
flags <<= 2;
flags |= ctx->state.frame_state.refresh_frame_flags ? 1 : 2;
flags <<= 2;
gf_filter_pck_set_dependency_flags(pck, flags);
}
gf_filter_pck_send(pck);
av1dmx_update_cts(ctx);
gf_av1_reset_state(&ctx->state, GF_FALSE);
return GF_OK;
}",[6],"There is a Null Pointer Dereference in function filter_core/filter_pck.c:gf_filter_pck_new_alloc_internal in GPAC 1.0.1. The pid comes from function av1dmx_parse_flush_sample, the ctx.opid maybe NULL. The result is a crash in gf_filter_pck_new_alloc_internal.",gpac,CVE-2021-30015,CWE-476
6833,7209,"Fraction::Fraction(int32_t num,int32_t den)
{
int32_t g = gcd(num, den);
if (num == std::numeric_limits<int32_t>::min() && g == -1) {
num++;
}
if (den == std::numeric_limits<int32_t>::min() && g == -1) {
den++;
}
numerator = num / g;
denominator = den / g;
while (denominator > MAX_FRACTION_DENOMINATOR) {
numerator >>= 1;
denominator >>= 1;
}
}","[3, 4, 5, 7, 8, 10, 11, 12, 13, 14]","Floating point exception in function Fraction in libheif 1.4.0, allows attackers to cause a Denial of Service or possibly other unspecified impacts.",libheif,CVE-2020-19498,NVD-CWE-noinfo
6834,6079,"void sqlite3CreateView(
Parse *pParse,
Token *pBegin,
Token *pName1,
Token *pName2,
ExprList *pCNames,
Select *pSelect,
int isTemp,
int noErr
){
Table *p;
int n;
const char *z;
Token sEnd;
DbFixer sFix;
Token *pName = 0;
int iDb;
sqlite3 *db = pParse->db;
if( pParse->nVar>0 ){
sqlite3ErrorMsg(pParse, ""parameters are not allowed in views"");
goto create_view_fail;
}
sqlite3StartTable(pParse, pName1, pName2, isTemp, 1, 0, noErr);
p = pParse->pNewTable;
if( p==0 || pParse->nErr ) goto create_view_fail;
sqlite3TwoPartName(pParse, pName1, pName2, &pName);
iDb = sqlite3SchemaToIndex(db, p->pSchema);
sqlite3FixInit(&sFix, pParse, iDb, ""view"", pName);
if( sqlite3FixSelect(&sFix, pSelect) ) goto create_view_fail;
if( IN_RENAME_OBJECT ){
p->pSelect = pSelect;
pSelect = 0;
}else{
p->pSelect = sqlite3SelectDup(db, pSelect, EXPRDUP_REDUCE);
}
p->pCheck = sqlite3ExprListDup(db, pCNames, EXPRDUP_REDUCE);
if( db->mallocFailed ) goto create_view_fail;
sEnd = pParse->sLastToken;
assert( sEnd.z[0]!=0 || sEnd.n==0 );
if( sEnd.z[0]!=';' ){
sEnd.z += sEnd.n;
}
sEnd.n = 0;
n = (int)(sEnd.z - pBegin->z);
assert( n>0 );
z = pBegin->z;
while( sqlite3Isspace(z[n-1]) ){ n--; }
sEnd.z = &z[n-1];
sEnd.n = 1;
sqlite3EndTable(pParse, 0, &sEnd, 0, 0);
create_view_fail:
sqlite3SelectDelete(db, pSelect);
if( IN_RENAME_OBJECT ){
sqlite3RenameExprlistUnmap(pParse, pCNames);
}
sqlite3ExprListDelete(db, pCNames);
return;
}",[30],alter.c in SQLite through 3.30.1 allows attackers to trigger infinite recursion via certain types of self-referential views in conjunction with ALTER TABLE statements.,sqlite,CVE-2019-19645,CWE-674
6843,9924,"void TestGatherNd(int* param_dims, const ParamType* param_data, int* index_dims,
const IndexType* index_data, int* output_dims,
ParamType* output_data,
const ParamType* expected_output_data) {
TfLiteIntArray* pdims = IntArrayFromInts(param_dims);
TfLiteIntArray* idims = IntArrayFromInts(index_dims);
TfLiteIntArray* odims = IntArrayFromInts(output_dims);
constexpr int inputs_size = 2;
constexpr int outputs_size = 1;
constexpr int tensors_size = inputs_size + outputs_size;
TfLiteTensor tensors[tensors_size] = {
CreateTensor(param_data, pdims),
CreateTensor(index_data, idims),
CreateTensor(output_data, odims),
};
int inputs_array_data[] = {2, 0, 1};
TfLiteIntArray* inputs_array = IntArrayFromInts(inputs_array_data);
int outputs_array_data[] = {1, 2};
TfLiteIntArray* outputs_array = IntArrayFromInts(outputs_array_data);
const TfLiteRegistration registration = Register_GATHER_ND();
micro::KernelRunner runner(registration, tensors, tensors_size, inputs_array,
outputs_array,                  nullptr);
TF_LITE_MICRO_EXPECT_EQ(kTfLiteOk, runner.InitAndPrepare());
TF_LITE_MICRO_EXPECT_EQ(kTfLiteOk, runner.Invoke());
TfLiteTensor* actual_output_tensor = &tensors[2];
TfLiteIntArray* actual_output_dims = actual_output_tensor->dims;
const int output_size = ElementCount(*actual_output_dims);
for (int i = 0; i < output_size; ++i) {
TF_LITE_MICRO_EXPECT_EQ(expected_output_data[i], output_data[i]);
}
}","[3, 4, 24, 25, 26, 27, 28, 29]","TensorFlow is an open source platform for machine learning. The `GatherNd` function takes arguments that determine the sizes of inputs and outputs. If the inputs given are greater than or equal to the sizes of the outputs, an out-of-bounds memory read or a crash is triggered. This issue has been patched in GitHub commit 4142e47e9e31db481781b955ed3ff807a781b494. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue.",tflite-micro,CVE-2022-35938,CWE-125
6845,6299,"int secure_decrypt(void *data, unsigned int data_length, int is_signed)
{
at91_aes_key_size_t key_size;
unsigned int cmac_key[8], cipher_key[8];
unsigned int iv[AT91_AES_IV_SIZE_WORD];
unsigned int computed_cmac[AT91_AES_BLOCK_SIZE_WORD];
unsigned int fixed_length;
const unsigned int *cmac;
int rc = -1;
init_keys(&key_size, cipher_key, cmac_key, iv);
at91_aes_init();
if (is_signed) {
if (at91_aes_cmac(data_length, data, computed_cmac,
key_size, cmac_key))
goto exit;
fixed_length = at91_aes_roundup(data_length);
cmac = (const unsigned int *)((char *)data + fixed_length);
if (!consttime_memequal(cmac, computed_cmac, AT91_AES_BLOCK_SIZE_BYTE))
goto exit;
}
if (at91_aes_cbc(data_length, data, data, 0,
key_size, cipher_key, iv))
goto exit;
rc = 0;
exit:
at91_aes_cleanup();
memset(cmac_key, 0, sizeof(cmac_key));
memset(cipher_key, 0, sizeof(cipher_key));
memset(iv, 0, sizeof(iv));
return rc;
}","[4, 5, 10, 27, 30]",AT91bootstrap before 3.9.2 does not properly wipe encryption and authentication keys from memory before passing control to a less privileged software component. This can be exploited to disclose these keys and subsequently encrypt and sign the next boot stage (such as the bootloader).,at91bootstrap,CVE-2020-11684,CWE-326
6848,7465,"PackLinuxElf64::invert_pt_dynamic(Elf64_Dyn const *dynp)
{
if (dt_table[Elf64_Dyn::DT_NULL]) {
return;
}
Elf64_Dyn const *const dynp0 = dynp;
unsigned ndx = 1+ 0;
if (dynp)
for (; ; ++ndx, ++dynp) {
upx_uint64_t const d_tag = get_te64(&dynp->d_tag);
if (d_tag>>32) {
char msg[50]; snprintf(msg, sizeof(msg),
""bad Elf64_Dyn[%d].d_tag %#lx"", -1+ ndx, (long unsigned)d_tag);
throwCantPack(msg);
}
if (d_tag < DT_NUM) {
if (Elf64_Dyn::DT_NEEDED != d_tag
&&  dt_table[d_tag]
&&    get_te64(&dynp->d_val)
!= get_te64(&dynp0[-1+ dt_table[d_tag]].d_val)) {
char msg[50]; snprintf(msg, sizeof(msg),
""duplicate DT_%#x: [%#x] [%#x]"",
(unsigned)d_tag, -1+ dt_table[d_tag], -1+ ndx);
throwCantPack(msg);
}
dt_table[d_tag] = ndx;
}
if (Elf64_Dyn::DT_NULL == d_tag) {
break;
}
}
upx_dt_init = 0;
if (dt_table[Elf64_Dyn::DT_INIT])          upx_dt_init = Elf64_Dyn::DT_INIT;
else if (dt_table[Elf64_Dyn::DT_PREINIT_ARRAY]) upx_dt_init = Elf64_Dyn::DT_PREINIT_ARRAY;
else if (dt_table[Elf64_Dyn::DT_INIT_ARRAY])    upx_dt_init = Elf64_Dyn::DT_INIT_ARRAY;
unsigned const z_str = dt_table[Elf64_Dyn::DT_STRSZ];
if (z_str) {
strtab_end = get_te64(&dynp0[-1+ z_str].d_val);
if ((u64_t)file_size <= strtab_end) {
char msg[50]; snprintf(msg, sizeof(msg),
""bad DT_STRSZ %#x"", strtab_end);
throwCantPack(msg);
}
}
unsigned const x_sym = dt_table[Elf64_Dyn::DT_SYMTAB];
unsigned const x_str = dt_table[Elf64_Dyn::DT_STRTAB];
if (x_sym && x_str) {
upx_uint64_t const v_sym = get_te64(&dynp0[-1+ x_sym].d_val);
upx_uint64_t const v_str = get_te64(&dynp0[-1+ x_str].d_val);
unsigned const  z_sym = dt_table[Elf64_Dyn::DT_SYMENT];
unsigned const sz_sym = !z_sym ? sizeof(Elf64_Sym)
: get_te64(&dynp0[-1+ z_sym].d_val);
if (sz_sym < sizeof(Elf64_Sym)) {
char msg[50]; snprintf(msg, sizeof(msg),
""bad DT_SYMENT %x"", sz_sym);
throwCantPack(msg);
}
if (v_sym < v_str) {
symnum_end = (v_str - v_sym) / sz_sym;
}
if (symnum_end < 1) {
throwCantPack(""bad DT_SYMTAB"");
}
}
unsigned const v_hsh = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH);
if (v_hsh && file_image) {
hashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_HASH);
if (!hashtab) {
char msg[40]; snprintf(msg, sizeof(msg),
""bad DT_HASH %#x"", v_hsh);
throwCantPack(msg);
}
unsigned const nbucket = get_te32(&hashtab[0]);
unsigned const *const buckets = &hashtab[2];
unsigned const *const chains = &buckets[nbucket]; (void)chains;
unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);
if (!nbucket
|| (nbucket>>31) || (file_size/sizeof(unsigned)) <= (2*nbucket)
|| ((v_hsh < v_sym) && (v_sym - v_hsh) < (sizeof(unsigned)*2
+ sizeof(*buckets)*nbucket
+ sizeof(*chains) *nbucket
))
) {
char msg[90]; snprintf(msg, sizeof(msg),
""bad DT_HASH nbucket=%#x  len=%#x"",
nbucket, (v_sym - v_hsh));
throwCantPack(msg);
}
}
unsigned const v_gsh = elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH);
if (v_gsh && file_image) {
gashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_GNU_HASH);
if (!gashtab) {
char msg[40]; snprintf(msg, sizeof(msg),
""bad DT_GNU_HASH %#x"", v_gsh);
throwCantPack(msg);
}
unsigned const n_bucket = get_te32(&gashtab[0]);
unsigned const n_bitmask = get_te32(&gashtab[2]);
unsigned const gnu_shift = get_te32(&gashtab[3]);
upx_uint64_t const *const bitmask = (upx_uint64_t const *)(void const *)&gashtab[4];
unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask];
unsigned     const *const hasharr = &buckets[n_bucket]; (void)hasharr;
upx_uint64_t const v_sym = get_te64(&dynp0[-1+ x_sym].d_val);
if (!n_bucket || !n_bitmask
|| (-1+ n_bitmask) & n_bitmask
|| 8*sizeof(upx_uint64_t) <= gnu_shift
|| (n_bucket>>30)
|| (n_bitmask>>30)
|| (file_size/sizeof(unsigned)) <= ((sizeof(*bitmask)/sizeof(unsigned))*n_bitmask + 2*n_bucket)
|| ((v_gsh < v_sym) && (v_sym - v_gsh) < (sizeof(unsigned)*4
+ sizeof(*bitmask)*n_bitmask
+ sizeof(*buckets)*n_bucket
+ sizeof(*hasharr)*n_bucket
))
) {
char msg[90]; snprintf(msg, sizeof(msg),
""bad DT_GNU_HASH n_bucket=%#x  n_bitmask=%#x  len=%#lx"",
n_bucket, n_bitmask, (long unsigned)(v_sym - v_gsh));
throwCantPack(msg);
}
}
unsigned const e_shstrndx = get_te16(&ehdri.e_shstrndx);
if (e_shnum <= e_shstrndx
&&  !(0==e_shnum && 0==e_shstrndx) ) {
char msg[40]; snprintf(msg, sizeof(msg),
""bad .e_shstrndx %d >= .e_shnum %d"", e_shstrndx, e_shnum);
throwCantPack(msg);
}
}","[76, 77, 104, 105]",A Segmentaation fault was found in UPX in invert_pt_dynamic() function in p_lx_elf.cpp. An attacker with a crafted input file allows invalid memory address access that could lead to a denial of service.,upx,CVE-2020-27787,NVD-CWE-noinfo
6849,8679,"sc_pkcs15emu_oberthur_add_data(struct sc_pkcs15_card *p15card,
unsigned int file_id, unsigned int size, int private)
{
struct sc_context *ctx = p15card->card->ctx;
struct sc_pkcs15_data_info dinfo;
struct sc_pkcs15_object dobj;
unsigned flags;
unsigned char *info_blob = NULL, *label = NULL, *app = NULL, *oid = NULL;
size_t info_len, label_len, app_len, oid_len, offs;
char ch_tmp[0x100];
int rv;
SC_FUNC_CALLED(ctx, SC_LOG_DEBUG_VERBOSE);
sc_log(ctx, ""Add data(file-id:%04X,size:%i,is-private:%i)"", file_id, size, private);
memset(&dinfo, 0, sizeof(dinfo));
memset(&dobj, 0, sizeof(dobj));
snprintf(ch_tmp, sizeof(ch_tmp), ""%s%04X"", private ? AWP_OBJECTS_DF_PRV : AWP_OBJECTS_DF_PUB, file_id | 0x100);
rv = sc_oberthur_read_file(p15card, ch_tmp, &info_blob, &info_len, 1);
LOG_TEST_RET(ctx, rv, ""Failed to add data: read oberthur file error"");
if (info_len < 2) {
free(info_blob);
LOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, ""Failed to add certificate: no 'tag'"");
}
flags = *(info_blob + 0) * 0x100 + *(info_blob + 1);
offs = 2;
if (offs + 2 > info_len) {
free(info_blob);
LOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, ""Failed to add data: no 'label'"");
}
label = info_blob + offs + 2;
label_len = *(info_blob + offs + 1) + *(info_blob + offs) * 0x100;
if (offs + 2 + label_len > info_len) {
free(info_blob);
LOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, ""Invalid length of 'label' received"");
}
if (label_len > sizeof(dobj.label) - 1)
label_len = sizeof(dobj.label) - 1;
offs += 2 + *(info_blob + offs + 1);
if (offs + 2 > info_len) {
free(info_blob);
LOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, ""Failed to add data: no 'application'"");
}
app = info_blob + offs + 2;
app_len = *(info_blob + offs + 1) + *(info_blob + offs) * 0x100;
if (offs + 2 + app_len > info_len) {
free(info_blob);
LOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, ""Invalid length of 'application' received"");
}
if (app_len > sizeof(dinfo.app_label) - 1)
app_len = sizeof(dinfo.app_label) - 1;
offs += 2 + app_len;
if (offs + 2 > info_len) {
free(info_blob);
LOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, ""Failed to add data: no 'OID'"");
}
oid_len = *(info_blob + offs + 1) + *(info_blob + offs) * 0x100;
if (offs + 2 + oid_len > info_len) {
free(info_blob);
LOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, ""Invalid length of 'oid' received"");
}
if (oid_len)   {
oid = info_blob + offs + 2;
if (*oid != 0x06 || (*(oid + 1) != oid_len - 2)) {
free(info_blob);
LOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, ""Failed to add data: invalid 'OID' format"");
}
oid += 2;
oid_len -= 2;
}
snprintf(ch_tmp, sizeof(ch_tmp), ""%s%04X"", private ? AWP_OBJECTS_DF_PRV : AWP_OBJECTS_DF_PUB, file_id);
sc_format_path(ch_tmp, &dinfo.path);
memcpy(dobj.label, label, label_len);
memcpy(dinfo.app_label, app, app_len);
if (oid_len)
sc_asn1_decode_object_id(oid, oid_len, &dinfo.app_oid);
if (flags & OBERTHUR_ATTR_MODIFIABLE)
dobj.flags |= SC_PKCS15_CO_FLAG_MODIFIABLE;
if (private)   {
dobj.auth_id.len = sizeof(PinDomainID) > sizeof(dobj.auth_id.value)
? sizeof(dobj.auth_id.value) : sizeof(PinDomainID);
memcpy(dobj.auth_id.value, PinDomainID, dobj.auth_id.len);
dobj.flags |= SC_PKCS15_CO_FLAG_PRIVATE;
}
rv = sc_pkcs15emu_add_data_object(p15card, &dobj, &dinfo);
free(info_blob);
LOG_FUNC_RETURN(p15card->card->ctx, rv);
}",[60],Heap buffer overflow issues were found in Opensc before version 0.22.0 in pkcs15-oberthur.c that could potentially crash programs using the library.,OpenSC,CVE-2021-42781,CWE-787
6854,7968,"s32 vvc_parse_picture_header(GF_BitStream *bs, VVCState *vvc, VVCSliceInfo *si)
{
u32 pps_id;
si->irap_or_gdr_pic = gf_bs_read_int_log(bs, 1, ""irap_or_gdr_pic"");
si->non_ref_pic = gf_bs_read_int_log(bs, 1, ""non_ref_pic"");
if (si->irap_or_gdr_pic)
si->gdr_pic = gf_bs_read_int_log(bs, 1, ""gdr_pic"");
if ((si->inter_slice_allowed_flag = gf_bs_read_int_log(bs, 1, ""inter_slice_allowed_flag"")))
si->intra_slice_allowed_flag = gf_bs_read_int_log(bs, 1, ""intra_slice_allowed_flag"");
pps_id = gf_bs_read_ue_log(bs, ""pps_id"");
if (pps_id >= 64)
return -1;
si->pps = &vvc->pps[pps_id];
si->sps = &vvc->sps[si->pps->sps_id];
si->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, ""poc_lsb"");
si->recovery_point_valid = 0;
si->gdr_recovery_count = 0;
if (si->gdr_pic) {
si->recovery_point_valid = 1;
si->gdr_recovery_count = gf_bs_read_ue_log(bs, ""gdr_recovery_count"");
}
gf_bs_read_int_log(bs, si->sps->ph_num_extra_bits, ""ph_extra_bits"");
if (si->sps->poc_msb_cycle_flag) {
if ( (si->poc_msb_cycle_present_flag = gf_bs_read_int_log(bs, 1, ""poc_msb_cycle_present_flag""))) {
si->poc_msb_cycle = gf_bs_read_int_log(bs, si->sps->poc_msb_cycle_len, ""poc_msb_cycle"");
}
}
return 0;
}",[11],There is a integer overflow in media_tools/av_parsers.c in the hevc_parse_slice_segment function in GPAC 1.0.1 which results in a crash.,gpac,CVE-2021-30014,CWE-190
6861,8462,"qemuProcessHandleMonitorEOF(qemuMonitorPtr mon,
virDomainObjPtr vm,
void *opaque)
{
virQEMUDriverPtr driver = opaque;
qemuDomainObjPrivatePtr priv;
struct qemuProcessEvent *processEvent;
virObjectLock(vm);
VIR_DEBUG(""Received EOF on %p '%s'"", vm, vm->def->name);
priv = vm->privateData;
if (priv->beingDestroyed) {
VIR_DEBUG(""Domain is being destroyed, EOF is expected"");
goto cleanup;
}
processEvent = g_new0(struct qemuProcessEvent, 1);
processEvent->eventType = QEMU_PROCESS_EVENT_MONITOR_EOF;
processEvent->vm = virObjectRef(vm);
if (virThreadPoolSendJob(driver->workerPool, 0, processEvent) < 0) {
virObjectUnref(vm);
qemuProcessEventFree(processEvent);
goto cleanup;
}
qemuMonitorUnregister(mon);
qemuDomainDestroyNamespace(driver, vm);
cleanup:
virObjectUnlock(vm);
}","[23, 24]",A use-after-free flaw was found in libvirt. The qemuMonitorUnregister() function in qemuProcessHandleMonitorEOF is called using multiple threads without being adequately protected by a monitor lock. This flaw could be triggered by the virConnectGetAllDomainStats API when the guest is shutting down. An unprivileged client with a read-only connection could use this flaw to perform a denial of service attack by causing the libvirt daemon to crash.,libvirt,CVE-2021-3975,CWE-416
6883,6111,"void zipfileStep(sqlite3_context *pCtx, int nVal, sqlite3_value **apVal){
ZipfileCtx *p;
ZipfileEntry e;
sqlite3_value *pName = 0;
sqlite3_value *pMode = 0;
sqlite3_value *pMtime = 0;
sqlite3_value *pData = 0;
sqlite3_value *pMethod = 0;
int bIsDir = 0;
u32 mode;
int rc = SQLITE_OK;
char *zErr = 0;
int iMethod = -1;
const u8 *aData = 0;
int nData = 0;
int szUncompressed = 0;
u8 *aFree = 0;
u32 iCrc32 = 0;
char *zName = 0;
int nName = 0;
char *zFree = 0;
int nByte;
memset(&e, 0, sizeof(e));
p = (ZipfileCtx*)sqlite3_aggregate_context(pCtx, sizeof(ZipfileCtx));
if( p==0 ) return;
if( nVal!=2 && nVal!=4 && nVal!=5 ){
zErr = sqlite3_mprintf(""wrong number of arguments to function zipfile()"");
rc = SQLITE_ERROR;
goto zipfile_step_out;
}
pName = apVal[0];
if( nVal==2 ){
pData = apVal[1];
}else{
pMode = apVal[1];
pMtime = apVal[2];
pData = apVal[3];
if( nVal==5 ){
pMethod = apVal[4];
}
}
zName = (char*)sqlite3_value_text(pName);
nName = sqlite3_value_bytes(pName);
if( zName==0 ){
zErr = sqlite3_mprintf(""first argument to zipfile() must be non-NULL"");
rc = SQLITE_ERROR;
goto zipfile_step_out;
}
if( pMethod && SQLITE_NULL!=sqlite3_value_type(pMethod) ){
iMethod = (int)sqlite3_value_int64(pMethod);
if( iMethod!=0 && iMethod!=8 ){
zErr = sqlite3_mprintf(""illegal method value: %d"", iMethod);
rc = SQLITE_ERROR;
goto zipfile_step_out;
}
}
if( sqlite3_value_type(pData)==SQLITE_NULL ){
bIsDir = 1;
iMethod = 0;
}else{
aData = sqlite3_value_blob(pData);
szUncompressed = nData = sqlite3_value_bytes(pData);
iCrc32 = crc32(0, aData, nData);
if( iMethod<0 || iMethod==8 ){
int nOut = 0;
rc = zipfileDeflate(aData, nData, &aFree, &nOut, &zErr);
if( rc!=SQLITE_OK ){
goto zipfile_step_out;
}
if( iMethod==8 || nOut<nData ){
aData = aFree;
nData = nOut;
iMethod = 8;
}else{
iMethod = 0;
}
}
}
rc = zipfileGetMode(pMode, bIsDir, &mode, &zErr);
if( rc ) goto zipfile_step_out;
e.mUnixTime = zipfileGetTime(pMtime);
if( bIsDir==0 ){
if( zName[nName-1]=='/' ){
zErr = sqlite3_mprintf(""non-directory name must not end with /"");
rc = SQLITE_ERROR;
goto zipfile_step_out;
}
}else{
if( zName[nName-1]!='/' ){
zName = zFree = sqlite3_mprintf(""%s/"", zName);
nName++;
if( zName==0 ){
rc = SQLITE_NOMEM;
goto zipfile_step_out;
}
}else{
while( nName>1 && zName[nName-2]=='/' ) nName--;
}
}
e.cds.iVersionMadeBy = ZIPFILE_NEWENTRY_MADEBY;
e.cds.iVersionExtract = ZIPFILE_NEWENTRY_REQUIRED;
e.cds.flags = ZIPFILE_NEWENTRY_FLAGS;
e.cds.iCompression = (u16)iMethod;
zipfileMtimeToDos(&e.cds, (u32)e.mUnixTime);
e.cds.crc32 = iCrc32;
e.cds.szCompressed = nData;
e.cds.szUncompressed = szUncompressed;
e.cds.iExternalAttr = (mode<<16);
e.cds.iOffset = p->body.n;
e.cds.nFile = (u16)nName;
e.cds.zFile = zName;
nByte = ZIPFILE_LFH_FIXED_SZ + e.cds.nFile + 9;
if( (rc = zipfileBufferGrow(&p->body, nByte)) ) goto zipfile_step_out;
p->body.n += zipfileSerializeLFH(&e, &p->body.a[p->body.n]);
if( nData>0 ){
if( (rc = zipfileBufferGrow(&p->body, nData)) ) goto zipfile_step_out;
memcpy(&p->body.a[p->body.n], aData, nData);
p->body.n += nData;
}
nByte = ZIPFILE_CDS_FIXED_SZ + e.cds.nFile + 9;
if( (rc = zipfileBufferGrow(&p->cds, nByte)) ) goto zipfile_step_out;
p->cds.n += zipfileSerializeCDS(&e, &p->cds.a[p->cds.n]);
p->nEntry++;
zipfile_step_out:
sqlite3_free(aFree);
sqlite3_free(zFree);
if( rc ){
if( zErr ){
sqlite3_result_error(pCtx, zErr, -1);
}else{
sqlite3_result_error_code(pCtx, rc);
}
}
sqlite3_free(zErr);
}","[91, 96]","ext/misc/zipfile.c in SQLite 3.30.1 mishandles certain uses of INSERT INTO in situations involving embedded '\0' characters in filenames, leading to a memory-management error that can be detected by (for example) valgrind.",sqlite,CVE-2019-19959,NVD-CWE-Other
6886,5703,"uint32_t *GetPayload(size_t handle, uint32_t *lastpayload, uint32_t index)
{
mp4object *mp4 = (mp4object *)handle;
if (mp4 == NULL) return NULL;
uint32_t *MP4buffer = NULL;
if (index < mp4->indexcount && mp4->mediafp)
{
MP4buffer = (uint32_t *)realloc((void *)lastpayload, mp4->metasizes[index]);
if (MP4buffer)
{
LONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);
fread(MP4buffer, 1, mp4->metasizes[index], mp4->mediafp);
return MP4buffer;
}
}
return NULL;
}","[11, 12, 13]",GoPro GPMF-parser 1.2.2 has a heap-based buffer over-read (4 bytes) in GPMF_Next in GPMF_parser.c.,gpmf-parser,CVE-2019-15146,CWE-125
6890,4486,"static void* swoole_unserialize_object(void *buffer, zval *return_value, zend_uchar bucket_len, zval *args, long flag)
{
zval property;
uint32_t arr_num = 0;
size_t name_len = *((unsigned short*) buffer);
if (!name_len)
{
php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""illegal unserialize data"");
return NULL;
}
buffer += 2;
zend_string *class_name;
if (flag == UNSERIALIZE_OBJECT_TO_STDCLASS)
{
class_name = swoole_string_init(ZEND_STRL(""StdClass""));
}
else
{
class_name = swoole_string_init((char*) buffer, name_len);
}
buffer += name_len;
zend_class_entry *ce = swoole_try_get_ce(class_name);
swoole_string_release(class_name);
if (!ce)
{
return NULL;
}
buffer = get_array_real_len(buffer, bucket_len, &arr_num);
buffer = swoole_unserialize_arr(buffer, &property, arr_num, flag);
object_init_ex(return_value, ce);
zval *data,*d;
zend_string *key;
zend_ulong index;
ZEND_HASH_FOREACH_KEY_VAL(Z_ARRVAL(property), index, key, data)
{
const char *prop_name, *tmp;
size_t prop_len;
if (key)
{
if ((d = zend_hash_find(Z_OBJPROP_P(return_value), key)) != NULL)
{
if (Z_TYPE_P(d) == IS_INDIRECT)
{
d = Z_INDIRECT_P(d);
}
zval_dtor(d);
ZVAL_COPY(d, data);
}
else
{
zend_unmangle_property_name_ex(key, &tmp, &prop_name, &prop_len);
zend_update_property(ce, return_value, prop_name, prop_len, data);
}
}
else
{
zend_hash_next_index_insert(Z_OBJPROP_P(return_value), data);
}
}
ZEND_HASH_FOREACH_END();
zval_dtor(&property);
if (ce->constructor)
{
}
if (zend_hash_str_exists(&ce->function_table, ZEND_STRL(""__wakeup"")))
{
zval ret, wakeup;
zend_string *fname = swoole_string_init(ZEND_STRL(""__wakeup""));
Z_STR(wakeup) = fname;
Z_TYPE_INFO(wakeup) = IS_STRING_EX;
call_user_function_ex(CG(function_table), return_value, &wakeup, &ret, 0, NULL, 1, NULL);
swoole_string_release(fname);
zval_ptr_dtor(&ret);
}
return buffer;
}","[6, 13, 17, 24, 31]",The unpack implementation in Swoole version 4.0.4 lacks correct size checks in the deserialization process. An attacker can craft a serialized object to exploit this vulnerability and cause a SEGV.,swoole-src,CVE-2018-15503,CWE-502
6895,4419,"bool PamBackend::start(const QString &user) {
bool result;
QString service = QStringLiteral(""sddm"");
if (user == QStringLiteral(""sddm"") && m_greeter)
service = QStringLiteral(""sddm-greeter"");
else if (m_app->session()->path().isEmpty())
service = QStringLiteral(""sddm-check"");
else if (m_autologin)
service = QStringLiteral(""sddm-autologin"");
result = m_pam->start(service, user);
if (!result)
m_app->error(m_pam->errorString(), Auth::ERROR_INTERNAL);
return result;
}","[6, 7]","An issue was discovered in SDDM through 0.17.0. If configured with ReuseSession=true, the password is not checked for users with an already existing session. Any user with access to the system D-Bus can therefore unlock any graphical session. This is related to daemon/Display.cpp and helper/backend/PamBackend.cpp.",sddm,CVE-2018-14345,CWE-287
6904,7963,"static s32 gf_hevc_read_sps_bs_internal(GF_BitStream *bs, HEVCState *hevc, u8 layer_id, u32 *vui_flag_pos)
{
s32 vps_id, sps_id = -1;
u32 i, nb_CTUs, depth;
HEVC_SPS *sps;
HEVC_VPS *vps;
HEVC_ProfileTierLevel ptl;
Bool multiLayerExtSpsFlag;
u8 sps_ext_or_max_sub_layers_minus1, max_sub_layers_minus1;
if (vui_flag_pos) *vui_flag_pos = 0;
vps_id = gf_bs_read_int_log(bs, 4, ""vps_id"");
if (vps_id >= 16) {
return -1;
}
memset(&ptl, 0, sizeof(ptl));
max_sub_layers_minus1 = 0;
sps_ext_or_max_sub_layers_minus1 = 0;
if (layer_id == 0)
max_sub_layers_minus1 = gf_bs_read_int_log(bs, 3, ""max_sub_layers_minus1"");
else
sps_ext_or_max_sub_layers_minus1 = gf_bs_read_int_log(bs, 3, ""sps_ext_or_max_sub_layers_minus1"");
multiLayerExtSpsFlag = (layer_id != 0) && (sps_ext_or_max_sub_layers_minus1 == 7);
if (!multiLayerExtSpsFlag) {
gf_bs_read_int_log(bs, 1, ""temporal_id_nesting_flag"");
hevc_profile_tier_level(bs, 1, max_sub_layers_minus1, &ptl, 0);
}
sps_id = gf_bs_read_ue_log(bs, ""sps_id"");
if ((sps_id < 0) || (sps_id >= 16)) {
return -1;
}
sps = &hevc->sps[sps_id];
if (!sps->state) {
sps->state = 1;
sps->id = sps_id;
sps->vps_id = vps_id;
}
sps->ptl = ptl;
vps = &hevc->vps[vps_id];
sps->max_sub_layers_minus1 = 0;
sps->sps_ext_or_max_sub_layers_minus1 = 0;
sps->colour_primaries = 2;
sps->transfer_characteristic = 2;
sps->matrix_coeffs = 2;
if (multiLayerExtSpsFlag) {
sps->update_rep_format_flag = gf_bs_read_int_log(bs, 1, ""update_rep_format_flag"");
if (sps->update_rep_format_flag) {
sps->rep_format_idx = gf_bs_read_int_log(bs, 8, ""rep_format_idx"");
}
else {
sps->rep_format_idx = vps->rep_format_idx[layer_id];
}
sps->width = vps->rep_formats[sps->rep_format_idx].pic_width_luma_samples;
sps->height = vps->rep_formats[sps->rep_format_idx].pic_height_luma_samples;
sps->chroma_format_idc = vps->rep_formats[sps->rep_format_idx].chroma_format_idc;
sps->bit_depth_luma = vps->rep_formats[sps->rep_format_idx].bit_depth_luma;
sps->bit_depth_chroma = vps->rep_formats[sps->rep_format_idx].bit_depth_chroma;
sps->separate_colour_plane_flag = vps->rep_formats[sps->rep_format_idx].separate_colour_plane_flag;
sps->ptl = vps->ext_ptl[0];
}
else {
sps->chroma_format_idc = gf_bs_read_ue_log(bs, ""chroma_format_idc"");
if (sps->chroma_format_idc == 3)
sps->separate_colour_plane_flag = gf_bs_read_int_log(bs, 1, ""separate_colour_plane_flag"");
sps->width = gf_bs_read_ue_log(bs, ""width"");
sps->height = gf_bs_read_ue_log(bs, ""height"");
if ((sps->cw_flag = gf_bs_read_int_log(bs, 1, ""conformance_window_flag""))) {
u32 SubWidthC, SubHeightC;
if (sps->chroma_format_idc == 1) {
SubWidthC = SubHeightC = 2;
}
else if (sps->chroma_format_idc == 2) {
SubWidthC = 2;
SubHeightC = 1;
}
else {
SubWidthC = SubHeightC = 1;
}
sps->cw_left = gf_bs_read_ue_log(bs, ""conformance_window_left"");
sps->cw_right = gf_bs_read_ue_log(bs, ""conformance_window_right"");
sps->cw_top = gf_bs_read_ue_log(bs, ""conformance_window_top"");
sps->cw_bottom = gf_bs_read_ue_log(bs, ""conformance_window_bottom"");
sps->width -= SubWidthC * (sps->cw_left + sps->cw_right);
sps->height -= SubHeightC * (sps->cw_top + sps->cw_bottom);
}
sps->bit_depth_luma = 8 + gf_bs_read_ue_log(bs, ""bit_depth_luma_minus8"");
sps->bit_depth_chroma = 8 + gf_bs_read_ue_log(bs, ""bit_depth_chroma_minus8"");
}
sps->log2_max_pic_order_cnt_lsb = 4 + gf_bs_read_ue_log(bs, ""log2_max_pic_order_cnt_lsb_minus4"");
if (!multiLayerExtSpsFlag) {
sps->sub_layer_ordering_info_present_flag = gf_bs_read_int_log(bs, 1, ""sub_layer_ordering_info_present_flag"");
for (i = sps->sub_layer_ordering_info_present_flag ? 0 : sps->max_sub_layers_minus1; i <= sps->max_sub_layers_minus1; i++) {
gf_bs_read_ue_log_idx(bs, ""max_dec_pic_buffering"", i);
gf_bs_read_ue_log_idx(bs, ""num_reorder_pics"", i);
gf_bs_read_ue_log_idx(bs, ""max_latency_increase"", i);
}
}
sps->log2_min_luma_coding_block_size = 3 + gf_bs_read_ue_log(bs, ""log2_min_luma_coding_block_size_minus3"");
sps->log2_diff_max_min_luma_coding_block_size = gf_bs_read_ue_log(bs, ""log2_diff_max_min_luma_coding_block_size"");
sps->max_CU_width = (1 << (sps->log2_min_luma_coding_block_size + sps->log2_diff_max_min_luma_coding_block_size));
sps->max_CU_height = (1 << (sps->log2_min_luma_coding_block_size + sps->log2_diff_max_min_luma_coding_block_size));
sps->log2_min_transform_block_size = 2 + gf_bs_read_ue_log(bs, ""log2_min_transform_block_size_minus2"");
sps->log2_max_transform_block_size = sps->log2_min_transform_block_size  + gf_bs_read_ue_log(bs, ""log2_max_transform_block_size"");
depth = 0;
sps->max_transform_hierarchy_depth_inter = gf_bs_read_ue_log(bs, ""max_transform_hierarchy_depth_inter"");
sps->max_transform_hierarchy_depth_intra = gf_bs_read_ue_log(bs, ""max_transform_hierarchy_depth_intra"");
while ((u32)(sps->max_CU_width >> sps->log2_diff_max_min_luma_coding_block_size) > (u32)(1 << (sps->log2_min_transform_block_size + depth)))
{
depth++;
}
sps->max_CU_depth = sps->log2_diff_max_min_luma_coding_block_size + depth;
nb_CTUs = ((sps->width + sps->max_CU_width - 1) / sps->max_CU_width) * ((sps->height + sps->max_CU_height - 1) / sps->max_CU_height);
sps->bitsSliceSegmentAddress = 0;
while (nb_CTUs > (u32)(1 << sps->bitsSliceSegmentAddress)) {
sps->bitsSliceSegmentAddress++;
}
sps->scaling_list_enable_flag = gf_bs_read_int_log(bs, 1, ""scaling_list_enable_flag"");
if (sps->scaling_list_enable_flag) {
sps->infer_scaling_list_flag = 0;
sps->scaling_list_ref_layer_id = 0;
if (multiLayerExtSpsFlag) {
sps->infer_scaling_list_flag = gf_bs_read_int_log(bs, 1, ""infer_scaling_list_flag"");
}
if (sps->infer_scaling_list_flag) {
sps->scaling_list_ref_layer_id = gf_bs_read_int_log(bs, 6, ""scaling_list_ref_layer_id"");
}
else {
sps->scaling_list_data_present_flag = gf_bs_read_int_log(bs, 1, ""scaling_list_data_present_flag"");
if (sps->scaling_list_data_present_flag) {
hevc_scaling_list_data(bs);
}
}
}
sps->asymmetric_motion_partitions_enabled_flag = gf_bs_read_int_log(bs, 1, ""asymmetric_motion_partitions_enabled_flag"");
sps->sample_adaptive_offset_enabled_flag = gf_bs_read_int_log(bs, 1, ""sample_adaptive_offset_enabled_flag"");
if ( (sps->pcm_enabled_flag = gf_bs_read_int_log(bs, 1, ""pcm_enabled_flag"")) ) {
sps->pcm_sample_bit_depth_luma_minus1 = gf_bs_read_int_log(bs, 4, ""pcm_sample_bit_depth_luma_minus1"");
sps->pcm_sample_bit_depth_chroma_minus1 = gf_bs_read_int_log(bs, 4, ""pcm_sample_bit_depth_chroma_minus1"");
sps->log2_min_pcm_luma_coding_block_size_minus3 = gf_bs_read_ue_log(bs, ""log2_min_pcm_luma_coding_block_size_minus3"");
sps->log2_diff_max_min_pcm_luma_coding_block_size = gf_bs_read_ue_log(bs, ""log2_diff_max_min_pcm_luma_coding_block_size"");
sps->pcm_loop_filter_disable_flag = gf_bs_read_int_log(bs, 1, ""pcm_loop_filter_disable_flag"");
}
sps->num_short_term_ref_pic_sets = gf_bs_read_ue_log(bs, ""num_short_term_ref_pic_sets"");
if (sps->num_short_term_ref_pic_sets > 64) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[HEVC] Invalid number of short term reference picture sets %d\n"", sps->num_short_term_ref_pic_sets));
return -1;
}
for (i = 0; i < sps->num_short_term_ref_pic_sets; i++) {
Bool ret = hevc_parse_short_term_ref_pic_set(bs, sps, i);
if (!ret) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[HEVC] Invalid short_term_ref_pic_set\n""));
return -1;
}
}
sps->long_term_ref_pics_present_flag = gf_bs_read_int_log(bs, 1, ""long_term_ref_pics_present_flag"");
if (sps->long_term_ref_pics_present_flag) {
sps->num_long_term_ref_pic_sps = gf_bs_read_ue_log(bs, ""num_long_term_ref_pic_sps"");
for (i = 0; i < sps->num_long_term_ref_pic_sps; i++) {
gf_bs_read_int_log_idx(bs, sps->log2_max_pic_order_cnt_lsb, ""lt_ref_pic_poc_lsb_sps"", i);
gf_bs_read_int_log_idx(bs, 1, ""used_by_curr_pic_lt_sps_flag"", i);
}
}
sps->temporal_mvp_enable_flag = gf_bs_read_int_log(bs, 1, ""temporal_mvp_enable_flag"");
sps->strong_intra_smoothing_enable_flag = gf_bs_read_int_log(bs, 1, ""strong_intra_smoothing_enable_flag"");
if (vui_flag_pos)
*vui_flag_pos = (u32)gf_bs_get_bit_offset(bs);
if ((sps->vui_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""vui_parameters_present_flag"")) ) {
sps->aspect_ratio_info_present_flag = gf_bs_read_int_log(bs, 1, ""aspect_ratio_info_present_flag"");
if (sps->aspect_ratio_info_present_flag) {
sps->sar_idc = gf_bs_read_int_log(bs, 8, ""aspect_ratio_idc"");
if (sps->sar_idc == 255) {
sps->sar_width = gf_bs_read_int_log(bs, 16, ""aspect_ratio_width"");
sps->sar_height = gf_bs_read_int_log(bs, 16, ""aspect_ratio_height"");
}
else if (sps->sar_idc < 17) {
sps->sar_width = hevc_sar[sps->sar_idc].w;
sps->sar_height = hevc_sar[sps->sar_idc].h;
}
}
if ((sps->overscan_info_present = gf_bs_read_int_log(bs, 1, ""overscan_info_present"")))
sps->overscan_appropriate = gf_bs_read_int_log(bs, 1, ""overscan_appropriate"");
sps->video_signal_type_present_flag = gf_bs_read_int_log(bs, 1, ""video_signal_type_present_flag"");
if (sps->video_signal_type_present_flag) {
sps->video_format = gf_bs_read_int_log(bs, 3, ""video_format"");
sps->video_full_range_flag = gf_bs_read_int_log(bs, 1, ""video_full_range_flag"");
if ((sps->colour_description_present_flag = gf_bs_read_int_log(bs, 1, ""colour_description_present_flag""))) {
sps->colour_primaries = gf_bs_read_int_log(bs, 8, ""colour_primaries"");
sps->transfer_characteristic = gf_bs_read_int_log(bs, 8, ""transfer_characteristic"");
sps->matrix_coeffs = gf_bs_read_int_log(bs, 8, ""matrix_coefficients"");
}
}
if ((sps->chroma_loc_info_present_flag = gf_bs_read_int_log(bs, 1, ""chroma_loc_info_present_flag""))) {
sps->chroma_sample_loc_type_top_field = gf_bs_read_ue_log(bs, ""chroma_sample_loc_type_top_field"");
sps->chroma_sample_loc_type_bottom_field = gf_bs_read_ue_log(bs, ""chroma_sample_loc_type_bottom_field"");
}
sps->neutra_chroma_indication_flag = gf_bs_read_int_log(bs, 1, ""neutra_chroma_indication_flag"");
sps->field_seq_flag = gf_bs_read_int_log(bs, 1, ""field_seq_flag"");
sps->frame_field_info_present_flag = gf_bs_read_int_log(bs, 1, ""frame_field_info_present_flag"");
if ((sps->default_display_window_flag = gf_bs_read_int_log(bs, 1, ""default_display_window_flag""))) {
sps->left_offset = gf_bs_read_ue_log(bs, ""display_window_left_offset"");
sps->right_offset = gf_bs_read_ue_log(bs, ""display_window_right_offset"");
sps->top_offset = gf_bs_read_ue_log(bs, ""display_window_top_offset"");
sps->bottom_offset = gf_bs_read_ue_log(bs, ""display_window_bottom_offset"");
}
sps->has_timing_info = gf_bs_read_int_log(bs, 1, ""has_timing_info"");
if (sps->has_timing_info) {
sps->num_units_in_tick = gf_bs_read_int_log(bs, 32, ""num_units_in_tick"");
sps->time_scale = gf_bs_read_int_log(bs, 32, ""time_scale"");
sps->poc_proportional_to_timing_flag = gf_bs_read_int_log(bs, 1, ""poc_proportional_to_timing_flag"");
if (sps->poc_proportional_to_timing_flag)
sps->num_ticks_poc_diff_one_minus1 = gf_bs_read_ue_log(bs, ""num_ticks_poc_diff_one_minus1"");
if ((sps->hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""hrd_parameters_present_flag""))) {
return sps_id;
}
}
if (gf_bs_read_int_log(bs, 1, ""bitstream_restriction_flag"")) {
gf_bs_read_int_log(bs, 1, ""tiles_fixed_structure_flag"");
gf_bs_read_int_log(bs, 1, ""motion_vectors_over_pic_boundaries_flag"");
gf_bs_read_int_log(bs, 1, ""restricted_ref_pic_lists_flag"");
gf_bs_read_ue_log(bs, ""min_spatial_segmentation_idc"");
gf_bs_read_ue_log(bs, ""max_bytes_per_pic_denom"");
gf_bs_read_ue_log(bs, ""max_bits_per_min_cu_denom"");
gf_bs_read_ue_log(bs, ""log2_max_mv_length_horizontal"");
gf_bs_read_ue_log(bs, ""log2_max_mv_length_vertical"");
}
}
if (gf_bs_read_int_log(bs, 1, ""sps_extension_flag"")) {
#if 0
while (gf_bs_available(bs)) {
gf_bs_read_int(bs, 1);
}
#endif
}
return sps_id;
}",[12],There is a integer overflow in media_tools/av_parsers.c in the hevc_parse_slice_segment function in GPAC 1.0.1 which results in a crash.,gpac,CVE-2021-30014,CWE-190
6925,1073,"bit_in(PG_FUNCTION_ARGS)
{
char    *input_string = PG_GETARG_CSTRING(0);
#ifdef NOT_USED
Oid   typelem = PG_GETARG_OID(1);
#endif
int32  atttypmod = PG_GETARG_INT32(2);
VarBit    *result;
char    *sp;
bits8    *r;
int   len,
bitlen,
slen;
bool  bit_not_hex;
int   bc;
bits8  x = 0;
if (input_string[0] == 'b' || input_string[0] == 'B')
{
bit_not_hex = true;
sp = input_string + 1;
}
else if (input_string[0] == 'x' || input_string[0] == 'X')
{
bit_not_hex = false;
sp = input_string + 1;
}
else
{
bit_not_hex = true;
sp = input_string;
}
slen = strlen(sp);
if (bit_not_hex)
bitlen = slen;
else
bitlen = slen * 4;
if (atttypmod <= 0)
atttypmod = bitlen;
else if (bitlen != atttypmod)
ereport(ERROR,
(errcode(ERRCODE_STRING_DATA_LENGTH_MISMATCH),
errmsg(""bit string length %d does not match type bit(%d)"",
bitlen, atttypmod)));
len = VARBITTOTALLEN(atttypmod);
result = (VarBit *) palloc0(len);
SET_VARSIZE(result, len);
VARBITLEN(result) = atttypmod;
r = VARBITS(result);
if (bit_not_hex)
{
x = HIGHBIT;
for (; *sp; sp++)
{
if (*sp == '1')
*r |= x;
else if (*sp != '0')
ereport(ERROR,
(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),
errmsg(""\""%c\"" is not a valid binary digit"",
*sp)));
x >>= 1;
if (x == 0)
{
x = HIGHBIT;
r++;
}
}
}
else
{
for (bc = 0; *sp; sp++)
{
if (*sp >= '0' && *sp <= '9')
x = (bits8) (*sp - '0');
else if (*sp >= 'A' && *sp <= 'F')
x = (bits8) (*sp - 'A') + 10;
else if (*sp >= 'a' && *sp <= 'f')
x = (bits8) (*sp - 'a') + 10;
else
ereport(ERROR,
(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),
errmsg(""\""%c\"" is not a valid hexadecimal digit"",
*sp)));
if (bc)
{
*r++ |= x;
bc = 0;
}
else
{
*r = x << 4;
bc = 1;
}
}
}
PG_RETURN_VARBIT_P(result);
}","[32, 36, 37]","Multiple integer overflows in the path_in and other unspecified functions in PostgreSQL before 8.4.20, 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact and attack vectors, which trigger a buffer overflow.  NOTE: this identifier has been SPLIT due to different affected versions; use CVE-2014-2669 for the hstore vector.",postgres,CVE-2014-0064,CWE-189
6935,6142,"static void gf_m2ts_process_pmt(GF_M2TS_Demuxer *ts, GF_M2TS_SECTION_ES *pmt, GF_List *sections, u8 table_id, u16 ex_table_id, u8 version_number, u8 last_section_number, u32 status)
{
u32 info_length, pos, desc_len, evt_type, nb_es,i;
u32 nb_sections;
u32 data_size;
u32 nb_hevc, nb_hevc_temp, nb_shvc, nb_shvc_temp, nb_mhvc, nb_mhvc_temp;
unsigned char *data;
GF_M2TS_Section *section;
GF_Err e = GF_OK;
if (!(status&GF_M2TS_TABLE_END)) return;
nb_es = 0;
if ((status&GF_M2TS_TABLE_REPEAT) && !(status&GF_M2TS_TABLE_UPDATE))  {
if (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_PMT_REPEAT, pmt->program);
return;
}
if (pmt->sec->demux_restarted) {
pmt->sec->demux_restarted = 0;
return;
}
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[MPEG-2 TS] PMT Found or updated\n""));
nb_sections = gf_list_count(sections);
if (nb_sections > 1) {
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""PMT on multiple sections not supported\n""));
}
section = (GF_M2TS_Section *)gf_list_get(sections, 0);
data = section->data;
data_size = section->data_size;
pmt->program->pcr_pid = ((data[0] & 0x1f) << 8) | data[1];
info_length = ((data[2]&0xf)<<8) | data[3];
if (info_length != 0) {
u8 tag, len;
u32 first_loop_len = 0;
tag = data[4];
len = data[5];
while (info_length > first_loop_len) {
if (tag == GF_M2TS_MPEG4_IOD_DESCRIPTOR) {
u32 size;
GF_BitStream *iod_bs;
iod_bs = gf_bs_new((char *)data+8, len-2, GF_BITSTREAM_READ);
if (pmt->program->pmt_iod) gf_odf_desc_del((GF_Descriptor *)pmt->program->pmt_iod);
e = gf_odf_parse_descriptor(iod_bs , (GF_Descriptor **) &pmt->program->pmt_iod, &size);
gf_bs_del(iod_bs );
if (e==GF_OK) {
if (pmt->program->pmt_iod) pmt->program->pmt_iod->ServiceID = pmt->program->number;
if (!gf_list_count(pmt->program->pmt_iod->ESDescriptors)) {
gf_odf_desc_del((GF_Descriptor *)pmt->program->pmt_iod);
pmt->program->pmt_iod = NULL;
}
}
} else if (tag == GF_M2TS_METADATA_POINTER_DESCRIPTOR) {
GF_BitStream *metadatapd_bs;
GF_M2TS_MetadataPointerDescriptor *metapd;
metadatapd_bs = gf_bs_new((char *)data+6, len, GF_BITSTREAM_READ);
metapd = gf_m2ts_read_metadata_pointer_descriptor(metadatapd_bs, len);
gf_bs_del(metadatapd_bs);
if (metapd->application_format_identifier == GF_M2TS_META_ID3 &&
metapd->format_identifier == GF_M2TS_META_ID3 &&
metapd->carriage_flag == METADATA_CARRIAGE_SAME_TS) {
pmt->program->metadata_pointer_descriptor = metapd;
} else {
gf_m2ts_metadata_pointer_descriptor_del(metapd);
}
} else {
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[MPEG-2 TS] Skipping descriptor (0x%x) and others not supported\n"", tag));
}
first_loop_len += 2 + len;
}
}
if (data_size <= 4 + info_length) return;
data += 4 + info_length;
data_size -= 4 + info_length;
pos = 0;
for(i=0; i<gf_list_count(ts->programs); i++) {
GF_M2TS_Program *prog = (GF_M2TS_Program *)gf_list_get(ts->programs,i);
if(prog->pmt_pid == pmt->pid) {
break;
}
}
nb_hevc = nb_hevc_temp = nb_shvc = nb_shvc_temp = nb_mhvc = nb_mhvc_temp = 0;
while (pos<data_size) {
GF_M2TS_PES *pes = NULL;
GF_M2TS_SECTION_ES *ses = NULL;
GF_M2TS_ES *es = NULL;
Bool inherit_pcr = 0;
u32 pid, stream_type, reg_desc_format;
stream_type = data[0];
pid = ((data[1] & 0x1f) << 8) | data[2];
desc_len = ((data[3] & 0xf) << 8) | data[4];
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""stream_type :%d \n"",stream_type));
switch (stream_type) {
case GF_M2TS_VIDEO_MPEG1:
case GF_M2TS_VIDEO_MPEG2:
case GF_M2TS_VIDEO_DCII:
case GF_M2TS_VIDEO_MPEG4:
case GF_M2TS_SYSTEMS_MPEG4_PES:
case GF_M2TS_VIDEO_H264:
case GF_M2TS_VIDEO_SVC:
case GF_M2TS_VIDEO_MVCD:
case GF_M2TS_VIDEO_HEVC:
case GF_M2TS_VIDEO_HEVC_MCTS:
case GF_M2TS_VIDEO_HEVC_TEMPORAL:
case GF_M2TS_VIDEO_SHVC:
case GF_M2TS_VIDEO_SHVC_TEMPORAL:
case GF_M2TS_VIDEO_MHVC:
case GF_M2TS_VIDEO_MHVC_TEMPORAL:
inherit_pcr = 1;
case GF_M2TS_AUDIO_MPEG1:
case GF_M2TS_AUDIO_MPEG2:
case GF_M2TS_AUDIO_AAC:
case GF_M2TS_AUDIO_LATM_AAC:
case GF_M2TS_AUDIO_AC3:
case GF_M2TS_AUDIO_DTS:
case GF_M2TS_MHAS_MAIN:
case GF_M2TS_MHAS_AUX:
case GF_M2TS_SUBTITLE_DVB:
case GF_M2TS_METADATA_PES:
GF_SAFEALLOC(pes, GF_M2TS_PES);
if (!pes) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[MPEG2TS] Failed to allocate ES for pid %d\n"", pid));
return;
}
pes->cc = -1;
pes->flags = GF_M2TS_ES_IS_PES;
if (inherit_pcr)
pes->flags |= GF_M2TS_INHERIT_PCR;
es = (GF_M2TS_ES *)pes;
break;
case GF_M2TS_PRIVATE_DATA:
GF_SAFEALLOC(pes, GF_M2TS_PES);
if (!pes) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[MPEG2TS] Failed to allocate ES for pid %d\n"", pid));
return;
}
pes->cc = -1;
pes->flags = GF_M2TS_ES_IS_PES;
es = (GF_M2TS_ES *)pes;
break;
case GF_M2TS_SYSTEMS_MPEG4_SECTIONS:
GF_SAFEALLOC(ses, GF_M2TS_SECTION_ES);
if (!ses) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[MPEG2TS] Failed to allocate ES for pid %d\n"", pid));
return;
}
es = (GF_M2TS_ES *)ses;
es->flags |= GF_M2TS_ES_IS_SECTION;
if (stream_type == GF_M2TS_SYSTEMS_MPEG4_SECTIONS) {
ses->sec = gf_m2ts_section_filter_new(gf_m2ts_process_mpeg4section, 0);
if (!pmt->program->additional_ods) {
pmt->program->additional_ods = gf_list_new();
ts->has_4on2 = 1;
}
}
break;
case GF_M2TS_13818_6_ANNEX_A:
case GF_M2TS_13818_6_ANNEX_B:
case GF_M2TS_13818_6_ANNEX_C:
case GF_M2TS_13818_6_ANNEX_D:
case GF_M2TS_PRIVATE_SECTION:
case GF_M2TS_QUALITY_SEC:
case GF_M2TS_MORE_SEC:
GF_SAFEALLOC(ses, GF_M2TS_SECTION_ES);
if (!ses) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[MPEG2TS] Failed to allocate ES for pid %d\n"", pid));
return;
}
es = (GF_M2TS_ES *)ses;
es->flags |= GF_M2TS_ES_IS_SECTION;
es->pid = pid;
es->service_id = pmt->program->number;
if (stream_type == GF_M2TS_PRIVATE_SECTION) {
GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (""AIT sections on pid %d\n"", pid));
} else if (stream_type == GF_M2TS_QUALITY_SEC) {
GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (""Quality metadata sections on pid %d\n"", pid));
} else if (stream_type == GF_M2TS_MORE_SEC) {
GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (""MORE sections on pid %d\n"", pid));
} else {
GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (""stream type DSM CC user private sections on pid %d \n"", pid));
}
ses->sec = gf_m2ts_section_filter_new(NULL, 1);
break;
case GF_M2TS_MPE_SECTIONS:
if (! ts->prefix_present) {
GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (""stream type MPE found : pid = %d \n"", pid));
#ifdef GPAC_ENABLE_MPE
es = gf_dvb_mpe_section_new();
if (es->flags & GF_M2TS_ES_IS_SECTION) {
((GF_M2TS_SECTION_ES*)es)->sec = gf_m2ts_section_filter_new(NULL, 1);
}
#endif
break;
}
default:
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[MPEG-2 TS] Stream type (0x%x) for PID %d not supported\n"", stream_type, pid ) );
break;
}
if (es) {
es->stream_type = (stream_type==GF_M2TS_PRIVATE_DATA) ? 0 : stream_type;
es->program = pmt->program;
es->pid = pid;
es->component_tag = -1;
}
pos += 5;
data += 5;
while (desc_len) {
u8 tag = data[0];
u32 len = data[1];
if (es) {
switch (tag) {
case GF_M2TS_ISO_639_LANGUAGE_DESCRIPTOR:
if (pes)
pes->lang = GF_4CC(' ', data[2], data[3], data[4]);
break;
case GF_M2TS_MPEG4_SL_DESCRIPTOR:
es->mpeg4_es_id = ( (u32) data[2] & 0x1f) << 8  | data[3];
es->flags |= GF_M2TS_ES_IS_SL;
break;
case GF_M2TS_REGISTRATION_DESCRIPTOR:
reg_desc_format = GF_4CC(data[2], data[3], data[4], data[5]);
switch (reg_desc_format) {
case GF_M2TS_RA_STREAM_AC3:
es->stream_type = GF_M2TS_AUDIO_AC3;
break;
case GF_M2TS_RA_STREAM_VC1:
es->stream_type = GF_M2TS_VIDEO_VC1;
break;
case GF_M2TS_RA_STREAM_GPAC:
if (len==8) {
es->stream_type = GF_4CC(data[6], data[7], data[8], data[9]);
es->flags |= GF_M2TS_GPAC_CODEC_ID;
break;
}
default:
GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (""Unknown registration descriptor %s\n"", gf_4cc_to_str(reg_desc_format) ));
break;
}
break;
case GF_M2TS_DVB_EAC3_DESCRIPTOR:
es->stream_type = GF_M2TS_AUDIO_EC3;
break;
case GF_M2TS_DVB_DATA_BROADCAST_ID_DESCRIPTOR:
{
u32 id = data[2]<<8 | data[3];
if ((id == 0xB) && ses && !ses->sec) {
ses->sec = gf_m2ts_section_filter_new(NULL, 1);
}
}
break;
case GF_M2TS_DVB_SUBTITLING_DESCRIPTOR:
if (pes) {
pes->sub.language[0] = data[2];
pes->sub.language[1] = data[3];
pes->sub.language[2] = data[4];
pes->sub.type = data[5];
pes->sub.composition_page_id = (data[6]<<8) | data[7];
pes->sub.ancillary_page_id = (data[8]<<8) | data[9];
}
es->stream_type = GF_M2TS_DVB_SUBTITLE;
break;
case GF_M2TS_DVB_STREAM_IDENTIFIER_DESCRIPTOR:
{
es->component_tag = data[2];
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""Component Tag: %d on Program %d\n"", es->component_tag, es->program->number));
}
break;
case GF_M2TS_DVB_TELETEXT_DESCRIPTOR:
es->stream_type = GF_M2TS_DVB_TELETEXT;
break;
case GF_M2TS_DVB_VBI_DATA_DESCRIPTOR:
es->stream_type = GF_M2TS_DVB_VBI;
break;
case GF_M2TS_HIERARCHY_DESCRIPTOR:
if (pes) {
u8 hierarchy_embedded_layer_index;
GF_BitStream *hbs = gf_bs_new((const char *)data, data_size, GF_BITSTREAM_READ);
gf_bs_read_int(hbs, 16);
gf_bs_read_int(hbs, 1);
gf_bs_read_int(hbs, 1);
gf_bs_read_int(hbs, 1);
gf_bs_read_int(hbs, 1);
gf_bs_read_int(hbs, 4);
gf_bs_read_int(hbs, 2);
gf_bs_read_int(hbs, 6);
gf_bs_read_int(hbs, 1);
gf_bs_read_int(hbs, 1);
hierarchy_embedded_layer_index = gf_bs_read_int(hbs, 6);
gf_bs_read_int(hbs, 2);
gf_bs_read_int(hbs, 6);
gf_bs_del(hbs);
pes->depends_on_pid = 1+hierarchy_embedded_layer_index;
}
break;
case GF_M2TS_METADATA_DESCRIPTOR:
{
GF_BitStream *metadatad_bs;
GF_M2TS_MetadataDescriptor *metad;
metadatad_bs = gf_bs_new((char *)data+2, len, GF_BITSTREAM_READ);
metad = gf_m2ts_read_metadata_descriptor(metadatad_bs, len);
gf_bs_del(metadatad_bs);
if (metad->application_format_identifier == GF_M2TS_META_ID3 &&
metad->format_identifier == GF_M2TS_META_ID3) {
if (pes) {
pes->metadata_descriptor = metad;
pes->stream_type = GF_M2TS_METADATA_ID3_HLS;
}
} else {
gf_m2ts_metadata_descriptor_del(metad);
}
}
break;
default:
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[MPEG-2 TS] skipping descriptor (0x%x) not supported\n"", tag));
break;
}
}
data += len+2;
pos += len+2;
if (desc_len < len+2) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[MPEG-2 TS] Invalid PMT es descriptor size for PID %d\n"", pid ) );
break;
}
desc_len-=len+2;
}
if (es && !es->stream_type) {
gf_free(es);
es = NULL;
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[MPEG-2 TS] Private Stream type (0x%x) for PID %d not supported\n"", stream_type, pid ) );
}
if (!es) continue;
if (ts->ess[pid]) {
if (status & GF_M2TS_TABLE_FOUND) {
GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (""[MPEG-2 TS] PID %d reused across programs %d and %d, not completely supported\n"", pid, ts->ess[pid]->program->number, es->program->number ) );
gf_list_add(pmt->program->streams, es);
if (!(es->flags & GF_M2TS_ES_IS_SECTION) ) gf_m2ts_set_pes_framing(pes, GF_M2TS_PES_FRAMING_SKIP);
nb_es++;
es = NULL;
}
else {
GF_M2TS_ES *o_es = ts->ess[es->pid];
if ((o_es->stream_type == es->stream_type)
&& ((o_es->flags & GF_M2TS_ES_STATIC_FLAGS_MASK) == (es->flags & GF_M2TS_ES_STATIC_FLAGS_MASK))
&& (o_es->mpeg4_es_id == es->mpeg4_es_id)
&& ((o_es->flags & GF_M2TS_ES_IS_SECTION) || ((GF_M2TS_PES *)o_es)->lang == ((GF_M2TS_PES *)es)->lang)
) {
gf_free(es);
es = NULL;
} else {
gf_m2ts_es_del(o_es, ts);
ts->ess[es->pid] = NULL;
}
}
}
if (es) {
ts->ess[es->pid] = es;
gf_list_add(pmt->program->streams, es);
if (!(es->flags & GF_M2TS_ES_IS_SECTION) ) gf_m2ts_set_pes_framing(pes, GF_M2TS_PES_FRAMING_SKIP);
nb_es++;
}
if (es->stream_type == GF_M2TS_VIDEO_HEVC) nb_hevc++;
else if (es->stream_type == GF_M2TS_VIDEO_HEVC_TEMPORAL) nb_hevc_temp++;
else if (es->stream_type == GF_M2TS_VIDEO_SHVC) nb_shvc++;
else if (es->stream_type == GF_M2TS_VIDEO_SHVC_TEMPORAL) nb_shvc_temp++;
else if (es->stream_type == GF_M2TS_VIDEO_MHVC) nb_mhvc++;
else if (es->stream_type == GF_M2TS_VIDEO_MHVC_TEMPORAL) nb_mhvc_temp++;
}
if (nb_hevc_temp + nb_shvc + nb_shvc_temp + nb_mhvc+ nb_mhvc_temp) {
for (i=0; i<gf_list_count(pmt->program->streams); i++) {
GF_M2TS_PES *es = (GF_M2TS_PES *)gf_list_get(pmt->program->streams, i);
if ( !(es->flags & GF_M2TS_ES_IS_PES)) continue;
if (es->depends_on_pid) continue;
switch (es->stream_type) {
case GF_M2TS_VIDEO_HEVC_TEMPORAL:
es->depends_on_pid = 1;
break;
case GF_M2TS_VIDEO_SHVC:
if (!nb_hevc_temp) es->depends_on_pid = 1;
else es->depends_on_pid = 2;
break;
case GF_M2TS_VIDEO_SHVC_TEMPORAL:
es->depends_on_pid = 3;
break;
case GF_M2TS_VIDEO_MHVC:
if (!nb_hevc_temp) es->depends_on_pid = 1;
else es->depends_on_pid = 2;
break;
case GF_M2TS_VIDEO_MHVC_TEMPORAL:
if (!nb_hevc_temp) es->depends_on_pid = 2;
else es->depends_on_pid = 3;
break;
}
}
}
if (nb_es) {
u32 i;
for (i=0; i<gf_list_count(pmt->program->streams); i++) {
GF_M2TS_PES *an_es = NULL;
GF_M2TS_PES *es = (GF_M2TS_PES *)gf_list_get(pmt->program->streams, i);
if ( !(es->flags & GF_M2TS_ES_IS_PES)) continue;
if (!es->depends_on_pid) continue;
an_es =  (GF_M2TS_PES *)gf_list_get(pmt->program->streams, es->depends_on_pid);
if (an_es) {
es->depends_on_pid = an_es->pid;
} else {
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[M2TS] Wrong dependency index in hierarchy descriptor, assuming non-scalable stream\n""));
es->depends_on_pid = 0;
}
}
evt_type = (status&GF_M2TS_TABLE_FOUND) ? GF_M2TS_EVT_PMT_FOUND : GF_M2TS_EVT_PMT_UPDATE;
if (ts->on_event) ts->on_event(ts, evt_type, pmt->program);
} else {
if (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_PMT_REPEAT, pmt->program);
}
}","[358, 359, 360, 361, 362, 363]","An issue was discovered in libgpac.a in GPAC before 0.8.0, as demonstrated by MP4Box. It contains a heap-based buffer over-read in gf_m2ts_process_pmt in media_tools/mpegts.c that can cause a denial of service via a crafted MP4 file.",gpac,CVE-2019-20629,CWE-125
6943,3924,"sf_flac_write_callback (const FLAC__StreamDecoder * UNUSED (decoder), const FLAC__Frame *frame, const int32_t * const buffer [], void *client_data)
{ SF_PRIVATE *psf = (SF_PRIVATE*) client_data ;
FLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;
pflac->frame = frame ;
pflac->bufferpos = 0 ;
pflac->bufferbackup = SF_FALSE ;
pflac->wbuffer = buffer ;
flac_buffer_copy (psf) ;
return FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE ;
}",[6],"In libsndfile before 1.0.28, an error in the ""flac_buffer_copy()"" function (flac.c) can be exploited to cause a stack-based buffer overflow via a specially crafted FLAC file.",libsndfile,CVE-2017-7585,CWE-119
6947,3008,"int ras_validate(jas_stream_t *in)
{
uchar buf[RAS_MAGICLEN];
int i;
int n;
uint_fast32_t magic;
assert(JAS_STREAM_MAXPUTBACK >= RAS_MAGICLEN);
if ((n = jas_stream_read(in, buf, RAS_MAGICLEN)) < 0) {
return -1;
}
for (i = n - 1; i >= 0; --i) {
if (jas_stream_ungetc(in, buf[i]) == EOF) {
return -1;
}
}
if (n < RAS_MAGICLEN) {
return -1;
}
magic = (JAS_CAST(uint_fast32_t, buf[0]) << 24) |
(JAS_CAST(uint_fast32_t, buf[1]) << 16) |
(JAS_CAST(uint_fast32_t, buf[2]) << 8) |
buf[3];
if (magic != RAS_MAGIC) {
return -1;
}
return 0;
}",[3],The jas_seq2d_create function in jas_seq.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (assertion failure) via a crafted file.,jasper,CVE-2016-9395,CWE-20
6979,7328,"GF_Err abst_box_read(GF_Box *s, GF_BitStream *bs)
{
GF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;
int i;
u32 tmp_strsize;
char *tmp_str;
GF_Err e;
ISOM_DECREASE_SIZE(ptr, 25)
ptr->bootstrapinfo_version = gf_bs_read_u32(bs);
ptr->profile = gf_bs_read_int(bs, 2);
ptr->live = gf_bs_read_int(bs, 1);
ptr->update = gf_bs_read_int(bs, 1);
ptr->reserved = gf_bs_read_int(bs, 4);
ptr->time_scale = gf_bs_read_u32(bs);
ptr->current_media_time = gf_bs_read_u64(bs);
ptr->smpte_time_code_offset = gf_bs_read_u64(bs);
i=0;
if (ptr->size<8) return GF_ISOM_INVALID_FILE;
tmp_strsize =(u32)ptr->size-8;
tmp_str = gf_malloc(sizeof(char)*tmp_strsize);
if (!tmp_str) return GF_OUT_OF_MEM;
memset(tmp_str, 0, sizeof(char)*tmp_strsize);
while (tmp_strsize) {
ISOM_DECREASE_SIZE(ptr, 1)
tmp_str[i] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[i])
break;
i++;
}
if (i) {
ptr->movie_identifier = gf_strdup(tmp_str);
}
ISOM_DECREASE_SIZE(ptr, 1)
ptr->server_entry_count = gf_bs_read_u8(bs);
for (i=0; i<ptr->server_entry_count; i++) {
int j=0;
tmp_strsize=(u32)ptr->size;
while (tmp_strsize) {
ISOM_DECREASE_SIZE(ptr, 1)
tmp_str[j] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[j])
break;
j++;
}
if (j) {
gf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);
}
}
ISOM_DECREASE_SIZE(ptr, 1)
ptr->quality_entry_count = gf_bs_read_u8(bs);
for (i=0; i<ptr->quality_entry_count; i++) {
int j=0;
tmp_strsize=(u32)ptr->size;
while (tmp_strsize) {
ISOM_DECREASE_SIZE(ptr, 1)
tmp_str[j] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[j])
break;
j++;
}
if (j) {
gf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);
}
}
i=0;
tmp_strsize=(u32)ptr->size;
while (tmp_strsize) {
ISOM_DECREASE_SIZE(ptr, 1)
tmp_str[i] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[i])
break;
i++;
}
if (i) {
ptr->drm_data = gf_strdup(tmp_str);
}
i=0;
tmp_strsize=(u32)ptr->size;
while (tmp_strsize) {
ISOM_DECREASE_SIZE(ptr, 1)
tmp_str[i] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[i])
break;
i++;
}
if (i) {
ptr->meta_data = gf_strdup(tmp_str);
}
ISOM_DECREASE_SIZE(ptr, 1)
ptr->segment_run_table_count = gf_bs_read_u8(bs);
for (i=0; i<ptr->segment_run_table_count; i++) {
GF_AdobeSegmentRunTableBox *asrt = NULL;
e = gf_isom_box_parse((GF_Box **)&asrt, bs);
if (e) {
if (asrt) gf_isom_box_del((GF_Box*)asrt);
gf_free(tmp_str);
return e;
}
gf_list_add(ptr->segment_run_table_entries, asrt);
}
ISOM_DECREASE_SIZE(ptr, 1)
ptr->fragment_run_table_count = gf_bs_read_u8(bs);
for (i=0; i<ptr->fragment_run_table_count; i++) {
GF_AdobeFragmentRunTableBox *afrt = NULL;
e = gf_isom_box_parse((GF_Box **)&afrt, bs);
if (e) {
if (afrt) gf_isom_box_del((GF_Box*)afrt);
gf_free(tmp_str);
return e;
}
gf_list_add(ptr->fragment_run_table_entries, afrt);
}
gf_free(tmp_str);
return GF_OK;
}",[19],An issue was discovered in gpac before 1.0.1. The abst_box_read function in box_code_adobe.c has a heap-based buffer over-read.,gpac,CVE-2020-23928,CWE-125
6985,7205,"GF_Err ilst_item_box_read(GF_Box *s,GF_BitStream *bs)
{
GF_Err e;
u32 sub_type;
GF_Box *a = NULL;
GF_ListItemBox *ptr = (GF_ListItemBox *)s;
sub_type = gf_bs_peek_bits(bs, 32, 4);
if (sub_type == GF_ISOM_BOX_TYPE_DATA ) {
e = gf_isom_box_parse(&a, bs);
if (!e && ptr->size < a->size) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[isom] not enough bytes in box %s: %d left, reading %d (file %s, line %d)\n"", gf_4cc_to_str(ptr->type), ptr->size, a->size, __FILE__, __LINE__ ));
e = GF_ISOM_INVALID_FILE;
}
if (e) {
if (a) gf_isom_box_del(a);
return e;
}
ISOM_DECREASE_SIZE(ptr, a->size);
if (a && ptr->data) gf_isom_box_del_parent(&ptr->child_boxes, (GF_Box *) ptr->data);
if (a && a->size > 4 && a->type != GF_ISOM_BOX_TYPE_VOID) {
ptr->data = (GF_DataBox *)a;
if (!ptr->child_boxes) ptr->child_boxes = gf_list_new();
gf_list_add(ptr->child_boxes, ptr->data);
} else {
ptr->data = NULL;
gf_isom_box_del(a);
}
}
else {
u64 pos = gf_bs_get_position(bs);
u64 prev_size = s->size;
e = gf_isom_box_array_read(s, bs, NULL);
if (e==GF_OK) return GF_OK;
gf_isom_box_array_del(s->child_boxes);
s->child_boxes=NULL;
gf_bs_seek(bs, pos);
s->size = prev_size;
ptr->data = (GF_DataBox *)gf_isom_box_new_parent(&ptr->child_boxes, GF_ISOM_BOX_TYPE_DATA);
ptr->data->qt_style = GF_TRUE;
ISOM_DECREASE_SIZE(ptr, 2);
ptr->data->dataSize = gf_bs_read_u16(bs);
gf_bs_read_u16(bs);
ptr->data->data = (char *) gf_malloc(sizeof(char)*(ptr->data->dataSize + 1));
gf_bs_read_data(bs, ptr->data->data, ptr->data->dataSize);
ptr->data->data[ptr->data->dataSize] = 0;
ISOM_DECREASE_SIZE(ptr, ptr->data->dataSize);
}
return GF_OK;
}","[10, 18]","An issue was discovered in box_code_apple.c:119 in Gpac MP4Box 0.8.0, allows attackers to cause a Denial of Service due to an invalid read on function ilst_item_Read.",gpac,CVE-2020-19488,CWE-476
7001,8673,"static int idprime_get_token_name(sc_card_t* card, char** tname)
{
idprime_private_data_t * priv = card->drv_data;
sc_path_t tinfo_path = {""\x00\x00"", 2, 0, 0, SC_PATH_TYPE_PATH, {"""", 0}};
sc_file_t *file = NULL;
u8 buf[2];
int r;
LOG_FUNC_CALLED(card->ctx);
if (tname == NULL) {
LOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);
}
if (!priv->tinfo_present) {
LOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);
}
memcpy(tinfo_path.value, priv->tinfo_df, 2);
r = iso_ops->select_file(card, &tinfo_path, &file);
if (r != SC_SUCCESS || file->size == 0) {
sc_file_free(file);
LOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);
}
r = iso_ops->read_binary(card, 0, buf, 2, 0);
if (r < 2 || buf[1] > file->size) {
sc_file_free(file);
LOG_FUNC_RETURN(card->ctx, r);
}
sc_file_free(file);
*tname = malloc(buf[1]);
if (*tname == NULL) {
LOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);
}
r = iso_ops->read_binary(card, 2, (unsigned char *)*tname, buf[1], 0);
if (r < 1) {
free(*tname);
LOG_FUNC_RETURN(card->ctx, r);
}
if ((*tname)[r-1] != '\0') {
(*tname)[r-1] = '\0';
}
LOG_FUNC_RETURN(card->ctx, SC_SUCCESS);
}","[7, 27, 28, 31, 33, 36, 37, 39]",A heap double free issue was found in Opensc before version 0.22.0 in sc_pkcs15_free_tokeninfo.,OpenSC,CVE-2021-42778,CWE-415
7018,7552,"GF_Err gf_hinter_track_process(GF_RTPHinter *tkHint)
{
GF_Err e;
u32 i, descIndex, duration;
u64 ts;
u8 PadBits;
GF_Fraction ft;
GF_ISOSample *samp;
tkHint->HintSample = tkHint->RTPTime = 0;
tkHint->TotalSample = gf_isom_get_sample_count(tkHint->file, tkHint->TrackNum);
ft.num = tkHint->rtp_p->sl_config.timestampResolution;
ft.den = tkHint->OrigTimeScale;
e = GF_OK;
for (i=0; i<tkHint->TotalSample; i++) {
samp = gf_isom_get_sample(tkHint->file, tkHint->TrackNum, i+1, &descIndex);
if (!samp) return gf_isom_last_error(tkHint->file);
tkHint->CurrentSample = i + 1;
if (samp->IsRAP==RAP_REDUNDANT) {
tkHint->rtp_p->sl_header.AU_sequenceNumber -= 1;
samp->IsRAP = RAP;
}
ts = ft.num * (samp->DTS+samp->CTS_Offset) / ft.den;
tkHint->rtp_p->sl_header.compositionTimeStamp = ts;
ts = ft.num * samp->DTS / ft.den;
tkHint->rtp_p->sl_header.decodingTimeStamp = ts;
tkHint->rtp_p->sl_header.randomAccessPointFlag = samp->IsRAP;
tkHint->base_offset_in_sample = 0;
if (tkHint->rtp_p->slMap.IV_length) {
GF_ISMASample *s = gf_isom_get_ismacryp_sample(tkHint->file, tkHint->TrackNum, samp, descIndex);
if (s->flags & GF_ISOM_ISMA_USE_SEL_ENC) tkHint->base_offset_in_sample += 1;
if (s->flags & GF_ISOM_ISMA_IS_ENCRYPTED) tkHint->base_offset_in_sample += s->IV_length + s->KI_length;
gf_free(samp->data);
samp->data = s->data;
samp->dataLength = s->dataLength;
gf_rtp_builder_set_cryp_info(tkHint->rtp_p, s->IV, (char*)s->key_indicator, (s->flags & GF_ISOM_ISMA_IS_ENCRYPTED) ? 1 : 0);
s->data = NULL;
s->dataLength = 0;
gf_isom_ismacryp_delete_sample(s);
}
if (tkHint->rtp_p->sl_config.usePaddingFlag) {
gf_isom_get_sample_padding_bits(tkHint->file, tkHint->TrackNum, i+1, &PadBits);
tkHint->rtp_p->sl_header.paddingBits = PadBits;
} else {
tkHint->rtp_p->sl_header.paddingBits = 0;
}
duration = gf_isom_get_sample_duration(tkHint->file, tkHint->TrackNum, i+1);
if (tkHint->avc_nalu_size) {
u32 v, size;
u32 remain = samp->dataLength;
char *ptr = samp->data;
tkHint->rtp_p->sl_header.accessUnitStartFlag = 1;
tkHint->rtp_p->sl_header.accessUnitEndFlag = 0;
while (remain) {
size = 0;
v = tkHint->avc_nalu_size;
if (v>remain) {
GF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (""[rtp hinter] Broken AVC nalu encapsulation: NALU size length is %d but only %d bytes left in sample %d\n"", v, remain, tkHint->CurrentSample));
break;
}
while (v) {
size |= (u8) *ptr;
ptr++;
remain--;
v-=1;
if (v) size<<=8;
}
tkHint->base_offset_in_sample = samp->dataLength-remain;
if (remain < size) {
GF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (""[rtp hinter] Broken AVC nalu encapsulation: NALU size is %d but only %d bytes left in sample %d\n"", size, remain, tkHint->CurrentSample));
break;
}
remain -= size;
tkHint->rtp_p->sl_header.accessUnitEndFlag = remain ? 0 : 1;
e = gf_rtp_builder_process(tkHint->rtp_p, ptr, size, (u8) !remain, samp->dataLength, duration, (u8) (descIndex + GF_RTP_TX3G_SIDX_OFFSET) );
ptr += size;
tkHint->rtp_p->sl_header.accessUnitStartFlag = 0;
}
} else {
e = gf_rtp_builder_process(tkHint->rtp_p, samp->data, samp->dataLength, 1, samp->dataLength, duration, (u8) (descIndex + GF_RTP_TX3G_SIDX_OFFSET) );
}
tkHint->rtp_p->sl_header.packetSequenceNumber += 1;
gf_set_progress(""Hinting"", tkHint->CurrentSample, tkHint->TotalSample);
tkHint->rtp_p->sl_header.AU_sequenceNumber += 1;
gf_isom_sample_del(&samp);
if (e) return e;
}
gf_rtp_builder_process(tkHint->rtp_p, NULL, 0, 1, 0, 0, 0);
gf_isom_end_hint_sample(tkHint->file, tkHint->HintTrack, (u8) tkHint->SampleIsRAP);
return GF_OK;
}","[74, 75]",An issue was discovered in GPAC version 0.8.0 and 1.0.1. There is heap-based buffer overflow in the function gp_rtp_builder_do_avc() in ietf/rtp_pck_mpeg4.c.,gpac,CVE-2020-35979,CWE-787
7024,6100,"int sqlite3WindowRewrite(Parse *pParse, Select *p){
int rc = SQLITE_OK;
if( p->pWin && p->pPrior==0 && (p->selFlags & SF_WinRewrite)==0 ){
Vdbe *v = sqlite3GetVdbe(pParse);
sqlite3 *db = pParse->db;
Select *pSub = 0;
SrcList *pSrc = p->pSrc;
Expr *pWhere = p->pWhere;
ExprList *pGroupBy = p->pGroupBy;
Expr *pHaving = p->pHaving;
ExprList *pSort = 0;
ExprList *pSublist = 0;
Window *pMWin = p->pWin;
Window *pWin;
Table *pTab;
pTab = sqlite3DbMallocZero(db, sizeof(Table));
if( pTab==0 ){
return SQLITE_NOMEM;
}
p->pSrc = 0;
p->pWhere = 0;
p->pGroupBy = 0;
p->pHaving = 0;
p->selFlags &= ~SF_Aggregate;
p->selFlags |= SF_WinRewrite;
pSort = sqlite3ExprListDup(db, pMWin->pPartition, 0);
pSort = exprListAppendList(pParse, pSort, pMWin->pOrderBy, 1);
if( pSort && p->pOrderBy && p->pOrderBy->nExpr<=pSort->nExpr ){
int nSave = pSort->nExpr;
pSort->nExpr = p->pOrderBy->nExpr;
if( sqlite3ExprListCompare(pSort, p->pOrderBy, -1)==0 ){
sqlite3ExprListDelete(db, p->pOrderBy);
p->pOrderBy = 0;
}
pSort->nExpr = nSave;
}
pMWin->iEphCsr = pParse->nTab++;
pParse->nTab += 3;
selectWindowRewriteEList(pParse, pMWin, pSrc, p->pEList, pTab, &pSublist);
selectWindowRewriteEList(pParse, pMWin, pSrc, p->pOrderBy, pTab, &pSublist);
pMWin->nBufferCol = (pSublist ? pSublist->nExpr : 0);
pSublist = exprListAppendList(pParse, pSublist, pMWin->pPartition, 0);
pSublist = exprListAppendList(pParse, pSublist, pMWin->pOrderBy, 0);
for(pWin=pMWin; pWin; pWin=pWin->pNextWin){
ExprList *pArgs = pWin->pOwner->x.pList;
if( pWin->pFunc->funcFlags & SQLITE_FUNC_SUBTYPE ){
selectWindowRewriteEList(pParse, pMWin, pSrc, pArgs, pTab, &pSublist);
pWin->iArgCol = (pSublist ? pSublist->nExpr : 0);
pWin->bExprArgs = 1;
}else{
pWin->iArgCol = (pSublist ? pSublist->nExpr : 0);
pSublist = exprListAppendList(pParse, pSublist, pArgs, 0);
}
if( pWin->pFilter ){
Expr *pFilter = sqlite3ExprDup(db, pWin->pFilter, 0);
pSublist = sqlite3ExprListAppend(pParse, pSublist, pFilter);
}
pWin->regAccum = ++pParse->nMem;
pWin->regResult = ++pParse->nMem;
sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regAccum);
}
if( pSublist==0 ){
pSublist = sqlite3ExprListAppend(pParse, 0,
sqlite3Expr(db, TK_INTEGER, ""0"")
);
}
pSub = sqlite3SelectNew(
pParse, pSublist, pSrc, pWhere, pGroupBy, pHaving, pSort, 0, 0
);
p->pSrc = sqlite3SrcListAppend(pParse, 0, 0, 0);
if( p->pSrc ){
Table *pTab2;
p->pSrc->a[0].pSelect = pSub;
sqlite3SrcListAssignCursors(pParse, p->pSrc);
pSub->selFlags |= SF_Expanded;
pTab2 = sqlite3ResultSetOfSelect(pParse, pSub, SQLITE_AFF_NONE);
if( pTab2==0 ){
rc = SQLITE_NOMEM;
}else{
memcpy(pTab, pTab2, sizeof(Table));
pTab->tabFlags |= TF_Ephemeral;
p->pSrc->a[0].pTab = pTab;
pTab = pTab2;
}
sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pMWin->iEphCsr, pSublist->nExpr);
sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+1, pMWin->iEphCsr);
sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+2, pMWin->iEphCsr);
sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+3, pMWin->iEphCsr);
}else{
sqlite3SelectDelete(db, pSub);
}
if( db->mallocFailed ) rc = SQLITE_NOMEM;
sqlite3DbFree(db, pTab);
}
return rc;
}","[18, 95]","SQLite 3.30.1 mishandles certain parser-tree rewriting, related to expr.c, vdbeaux.c, and window.c. This is caused by incorrect sqlite3WindowRewrite() error handling.",sqlite,CVE-2019-19924,CWE-755
7026,9772,"auto uncomp = output_buffer.make_fragmented_temporary_buffer(uncomp_len, fragmented_temporary_buffer::default_fragment_size, [&] (bytes_mutable_view out) {
auto ret = LZ4_decompress_safe(reinterpret_cast<const char*>(in.data()), reinterpret_cast<char*>(out.data()),
in.size(), out.size());
if (ret < 0) {
throw std::runtime_error(""CQL frame LZ4 uncompression failure"");
}
return out.size();
});",[7],"Scylla is a real-time big data database that is API-compatible with Apache Cassandra and Amazon DynamoDB. When decompressing CQL frame received from user, Scylla assumes that user-provided uncompressed length is correct. If user provides fake length, that is greater than the real one, part of decompression buffer won't be overwritten, and will be left uninitialized. This can be exploited in several ways, depending on the privileges of the user. 1. The main exploit is that an attacker with access to CQL port, but no user account, can bypass authentication, but only if there are other legitimate clients making connections to the cluster, and they use LZ4. 2. Attacker that already has a user account on the cluster can read parts of uninitialized memory, which can contain things like passwords of other users or fragments of other queries / results, which leads to authorization bypass and sensitive information disclosure. The bug has been patched in the following versions: Scylla Enterprise: 2020.1.14, 2021.1.12, 2022.1.0. Scylla Open Source: 4.6.7, 5.0.3. Users unable to upgrade should make sure none of their drivers connect to cluster using LZ4 compression, and that Scylla CQL port is behind firewall. Additionally make sure no untrusted client can connect to Scylla, by setting up authentication and applying workarounds from previous point (firewall, no lz4 compression).",scylladb,CVE-2022-29240,CWE-908
7027,3005,"static int jpc_siz_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate,
jas_stream_t *in)
{
jpc_siz_t *siz = &ms->parms.siz;
unsigned int i;
uint_fast8_t tmp;
cstate = 0;
if (jpc_getuint16(in, &siz->caps) ||
jpc_getuint32(in, &siz->width) ||
jpc_getuint32(in, &siz->height) ||
jpc_getuint32(in, &siz->xoff) ||
jpc_getuint32(in, &siz->yoff) ||
jpc_getuint32(in, &siz->tilewidth) ||
jpc_getuint32(in, &siz->tileheight) ||
jpc_getuint32(in, &siz->tilexoff) ||
jpc_getuint32(in, &siz->tileyoff) ||
jpc_getuint16(in, &siz->numcomps)) {
return -1;
}
if (!siz->width || !siz->height || !siz->tilewidth ||
!siz->tileheight || !siz->numcomps || siz->numcomps > 16384) {
return -1;
}
if (siz->tilexoff >= siz->width || siz->tileyoff >= siz->height) {
jas_eprintf(""all tiles are outside the image area\n"");
return -1;
}
if (!(siz->comps = jas_alloc2(siz->numcomps, sizeof(jpc_sizcomp_t)))) {
return -1;
}
for (i = 0; i < siz->numcomps; ++i) {
if (jpc_getuint8(in, &tmp) ||
jpc_getuint8(in, &siz->comps[i].hsamp) ||
jpc_getuint8(in, &siz->comps[i].vsamp)) {
jas_free(siz->comps);
return -1;
}
if (siz->comps[i].hsamp == 0 || siz->comps[i].hsamp > 255) {
jas_eprintf(""invalid XRsiz value %d\n"", siz->comps[i].hsamp);
jas_free(siz->comps);
return -1;
}
if (siz->comps[i].vsamp == 0 || siz->comps[i].vsamp > 255) {
jas_eprintf(""invalid YRsiz value %d\n"", siz->comps[i].vsamp);
jas_free(siz->comps);
return -1;
}
siz->comps[i].sgnd = (tmp >> 7) & 1;
siz->comps[i].prec = (tmp & 0x7f) + 1;
}
if (jas_stream_eof(in)) {
jas_free(siz->comps);
return -1;
}
return 0;
}","[7, 18, 20, 21, 22, 24, 25, 26, 28, 29, 35, 36, 40, 41, 45, 46, 52, 53]",The calcstepsizes function in jpc_dec.c in JasPer before 1.900.17 allows remote attackers to cause a denial of service (assertion failure) via a crafted file.,jasper,CVE-2016-9392,NVD-CWE-Other
7032,9851,"void SFS_Expression(ScriptParser *parser)
{
u32 val = gf_bs_read_int(parser->bs, NUMBITS_EXPR_TYPE);
if (parser->codec->LastError) return;
switch(val) {
case ET_CURVED_EXPR:
SFS_AddString(parser, ""("");
SFS_CompoundExpression(parser);
SFS_AddString(parser, "")"");
break;
case ET_NEGATIVE:
SFS_AddString(parser, ""-"");
SFS_Expression(parser);
break;
case ET_NOT:
SFS_AddString(parser, ""!"");
SFS_Expression(parser);
break;
case ET_ONESCOMP:
SFS_AddString(parser, ""~"");
SFS_Expression(parser);
break;
case ET_INCREMENT:
SFS_AddString(parser, ""++"");
SFS_Expression(parser);
break;
case ET_DECREMENT:
SFS_AddString(parser, ""--"");
SFS_Expression(parser);
break;
case ET_POST_INCREMENT:
SFS_Expression(parser);
SFS_AddString(parser, ""++"");
break;
case ET_POST_DECREMENT:
SFS_Expression(parser);
SFS_AddString(parser, ""--"");
break;
case ET_CONDTEST:
SFS_Expression(parser);
SFS_AddString(parser, "" ? "");
SFS_Expression(parser);
SFS_AddString(parser, "" : "");
SFS_Expression(parser);
break;
case ET_STRING:
SFS_AddString(parser, ""'"");
SFS_GetString(parser);
SFS_AddString(parser, ""'"");
break;
case ET_NUMBER:
SFS_GetNumber(parser);
break;
case ET_IDENTIFIER:
SFS_Identifier(parser);
break;
case ET_FUNCTION_CALL:
SFS_FunctionCall(parser);
break;
case ET_NEW:
SFS_NewObject(parser);
break;
case ET_OBJECT_MEMBER_ACCESS:
SFS_ObjectMemberAccess(parser);
break;
case ET_OBJECT_METHOD_CALL:
SFS_ObjectMethodCall(parser);
break;
case ET_ARRAY_DEREFERENCE:
SFS_ArrayDeref(parser);
break;
case ET_MULTIPLY:
SFS_Expression(parser);
SFS_AddString(parser, ""*"");
SFS_Expression(parser);
break;
case ET_DIVIDE:
SFS_Expression(parser);
SFS_AddString(parser, ""/"");
SFS_Expression(parser);
break;
case ET_MOD:
SFS_Expression(parser);
SFS_AddString(parser, ""%"");
SFS_Expression(parser);
break;
case ET_PLUS:
SFS_Expression(parser);
SFS_AddString(parser, ""+"");
SFS_Expression(parser);
break;
case ET_MINUS:
SFS_Expression(parser);
SFS_AddString(parser, ""-"");
SFS_Expression(parser);
break;
case ET_LSHIFT:
SFS_Expression(parser);
SFS_AddString(parser, ""<<"");
SFS_Expression(parser);
break;
case ET_RSHIFT:
SFS_Expression(parser);
SFS_AddString(parser, "">>"");
SFS_Expression(parser);
break;
case ET_RSHIFTFILL:
SFS_Expression(parser);
SFS_AddString(parser, "">>>"");
SFS_Expression(parser);
break;
case ET_AND:
SFS_Expression(parser);
SFS_AddString(parser, ""&"");
SFS_Expression(parser);
break;
case ET_XOR:
SFS_Expression(parser);
SFS_AddString(parser, ""^"");
SFS_Expression(parser);
break;
case ET_OR:
SFS_Expression(parser);
SFS_AddString(parser, ""|"");
SFS_Expression(parser);
break;
case ET_LT:
SFS_Expression(parser);
SFS_AddString(parser, ""<"");
SFS_Expression(parser);
break;
case ET_LE:
SFS_Expression(parser);
SFS_AddString(parser, ""<="");
SFS_Expression(parser);
break;
case ET_GT:
SFS_Expression(parser);
SFS_AddString(parser, "">"");
SFS_Expression(parser);
break;
case ET_GE:
SFS_Expression(parser);
SFS_AddString(parser, "">="");
SFS_Expression(parser);
break;
case ET_EQ:
SFS_Expression(parser);
SFS_AddString(parser, ""=="");
SFS_Expression(parser);
break;
case ET_NE:
SFS_Expression(parser);
SFS_AddString(parser, ""!="");
SFS_Expression(parser);
break;
case ET_LAND:
SFS_Expression(parser);
SFS_AddString(parser, ""&&"");
SFS_Expression(parser);
break;
case ET_LOR:
SFS_Expression(parser);
SFS_AddString(parser, ""||"");
SFS_Expression(parser);
break;
case ET_ASSIGN:
SFS_Expression(parser);
SFS_AddString(parser, ""="");
SFS_Expression(parser);
break;
case ET_PLUSEQ:
SFS_Expression(parser);
SFS_AddString(parser, ""+="");
SFS_Expression(parser);
break;
case ET_MINUSEQ:
SFS_Expression(parser);
SFS_AddString(parser, ""-="");
SFS_Expression(parser);
break;
case ET_MULTIPLYEQ:
SFS_Expression(parser);
SFS_AddString(parser, ""*="");
SFS_Expression(parser);
break;
case ET_DIVIDEEQ:
SFS_Expression(parser);
SFS_AddString(parser, ""/="");
SFS_Expression(parser);
break;
case ET_MODEQ:
SFS_Expression(parser);
SFS_AddString(parser, ""%="");
SFS_Expression(parser);
break;
case ET_LSHIFTEQ:
SFS_Expression(parser);
SFS_AddString(parser, ""<<="");
SFS_Expression(parser);
break;
case ET_RSHIFTEQ:
SFS_Expression(parser);
SFS_AddString(parser, "">>="");
SFS_Expression(parser);
break;
case ET_RSHIFTFILLEQ:
SFS_Expression(parser);
SFS_AddString(parser, "">>>="");
SFS_Expression(parser);
break;
case ET_ANDEQ:
SFS_Expression(parser);
SFS_AddString(parser, ""&="");
SFS_Expression(parser);
break;
case ET_XOREQ:
SFS_Expression(parser);
SFS_AddString(parser, ""^="");
SFS_Expression(parser);
break;
case ET_OREQ:
SFS_Expression(parser);
SFS_AddString(parser, ""|="");
SFS_Expression(parser);
break;
case ET_BOOLEAN:
SFS_GetBoolean(parser);
break;
case ET_VAR:
SFS_AddString(parser, ""var "");
SFS_Arguments(parser, GF_TRUE);
break;
case ET_FUNCTION_ASSIGN:
SFS_AddString(parser, ""function "");
SFS_Arguments(parser, GF_FALSE);
SFS_StatementBlock(parser, GF_TRUE);
break;
default:
parser->codec->LastError = GF_NON_COMPLIANT_BITSTREAM;
break;
}
}","[5, 241]",Uncontrolled Recursion in GitHub repository gpac/gpac prior to 2.1.0-DEV.,gpac,CVE-2022-3222,CWE-674
7034,5803,"static void WritePixel(struct ngiflib_img * i, struct ngiflib_decode_context * context, u8 v) {
struct ngiflib_gif * p = i->parent;
if(v!=i->gce.transparent_color || !i->gce.transparent_flag) {
#ifndef NGIFLIB_INDEXED_ONLY
if(p->mode & NGIFLIB_MODE_INDEXED) {
#endif /* NGIFLIB_INDEXED_ONLY */
*context->frbuff_p.p8 = v;
#ifndef NGIFLIB_INDEXED_ONLY
} else
*context->frbuff_p.p32 =
GifIndexToTrueColor(i->palette, v);
#endif /* NGIFLIB_INDEXED_ONLY */
}
if(--(context->Xtogo) <= 0) {
#ifdef NGIFLIB_ENABLE_CALLBACKS
if(p->line_cb) p->line_cb(p, context->line_p, context->curY);
#endif /* NGIFLIB_ENABLE_CALLBACKS */
context->Xtogo = i->width;
switch(context->pass) {
case 0:
context->curY++;
break;
case 1:
context->curY += 8;
if(context->curY >= p->height) {
context->pass++;
context->curY = i->posY + 4;
}
break;
case 2:
context->curY += 8;
if(context->curY >= p->height) {
context->pass++;
context->curY = i->posY + 2;
}
break;
case 3:
context->curY += 4;
if(context->curY >= p->height) {
context->pass++;
context->curY = i->posY + 1;
}
break;
case 4:
context->curY += 2;
break;
}
#ifndef NGIFLIB_INDEXED_ONLY
if(p->mode & NGIFLIB_MODE_INDEXED) {
#endif /* NGIFLIB_INDEXED_ONLY */
#ifdef NGIFLIB_ENABLE_CALLBACKS
context->line_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width;
context->frbuff_p.p8 = context->line_p.p8 + i->posX;
#else
context->frbuff_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width + i->posX;
#endif /* NGIFLIB_ENABLE_CALLBACKS */
#ifndef NGIFLIB_INDEXED_ONLY
} else {
#ifdef NGIFLIB_ENABLE_CALLBACKS
context->line_p.p32 = p->frbuff.p32 + (u32)context->curY*p->width;
context->frbuff_p.p32 = context->line_p.p32 + i->posX;
#else
context->frbuff_p.p32 = p->frbuff.p32 + (u32)context->curY*p->width + i->posX;
#endif /* NGIFLIB_ENABLE_CALLBACKS */
}
#endif /* NGIFLIB_INDEXED_ONLY */
} else {
#ifndef NGIFLIB_INDEXED_ONLY
if(p->mode & NGIFLIB_MODE_INDEXED) {
#endif /* NGIFLIB_INDEXED_ONLY */
context->frbuff_p.p8++;
#ifndef NGIFLIB_INDEXED_ONLY
} else {
context->frbuff_p.p32++;
}
#endif /* NGIFLIB_INDEXED_ONLY */
}
}","[25, 26, 27, 32, 33, 34, 39, 40, 41, 48]","ngiflib 0.4 has a heap-based buffer overflow in WritePixel() in ngiflib.c when called from DecodeGifImg, because deinterlacing for small pictures is mishandled.",ngiflib,CVE-2019-16346,CWE-682
7040,6357,"exif_mnote_data_canon_load (ExifMnoteData *ne,
const unsigned char *buf, unsigned int buf_size)
{
ExifMnoteDataCanon *n = (ExifMnoteDataCanon *) ne;
ExifShort c;
size_t i, tcount, o, datao;
if (!n || !buf || !buf_size) {
exif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,
""ExifMnoteCanon"", ""Short MakerNote"");
return;
}
datao = 6 + n->offset;
if (CHECKOVERFLOW(datao, buf_size, 2)) {
exif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,
""ExifMnoteCanon"", ""Short MakerNote"");
return;
}
c = exif_get_short (buf + datao, n->order);
datao += 2;
exif_mnote_data_canon_clear (n);
n->entries = exif_mem_alloc (ne->mem, sizeof (MnoteCanonEntry) * c);
if (!n->entries) {
EXIF_LOG_NO_MEMORY(ne->log, ""ExifMnoteCanon"", sizeof (MnoteCanonEntry) * c);
return;
}
tcount = 0;
for (i = c, o = datao; i; --i, o += 12) {
size_t s;
memset(&n->entries[tcount], 0, sizeof(MnoteCanonEntry));
if (CHECKOVERFLOW(o,buf_size,12)) {
exif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,
""ExifMnoteCanon"", ""Short MakerNote"");
break;
}
n->entries[tcount].tag        = exif_get_short (buf + o, n->order);
n->entries[tcount].format     = exif_get_short (buf + o + 2, n->order);
n->entries[tcount].components = exif_get_long (buf + o + 4, n->order);
n->entries[tcount].order      = n->order;
exif_log (ne->log, EXIF_LOG_CODE_DEBUG, ""ExifMnoteCanon"",
""Loading entry 0x%x ('%s')..."", n->entries[tcount].tag,
mnote_canon_tag_get_name (n->entries[tcount].tag));
if ( exif_format_get_size (n->entries[tcount].format) &&
buf_size / exif_format_get_size (n->entries[tcount].format) < n->entries[tcount].components
) {
exif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,
""ExifMnoteCanon"", ""Tag size overflow detected (%u * %lu)"", exif_format_get_size (n->entries[tcount].format), n->entries[tcount].components);
continue;
}
s = exif_format_get_size (n->entries[tcount].format) *
n->entries[tcount].components;
n->entries[tcount].size = s;
if (!s) {
exif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,
""ExifMnoteCanon"",
""Invalid zero-length tag size"");
continue;
} else {
size_t dataofs = o + 8;
if (s > 4) dataofs = exif_get_long (buf + dataofs, n->order) + 6;
if (CHECKOVERFLOW(dataofs, buf_size, s)) {
exif_log (ne->log, EXIF_LOG_CODE_DEBUG,
""ExifMnoteCanon"",
""Tag data past end of buffer (%u > %u)"",
(unsigned)(dataofs + s), buf_size);
continue;
}
n->entries[tcount].data = exif_mem_alloc (ne->mem, s);
if (!n->entries[tcount].data) {
EXIF_LOG_NO_MEMORY(ne->log, ""ExifMnoteCanon"", s);
continue;
}
memcpy (n->entries[tcount].data, buf + dataofs, s);
}
++tcount;
}
n->count = tcount;
}","[7, 74]",An issue was discovered in libexif before 0.6.22. An unrestricted size in handling Canon EXIF MakerNote data could lead to consumption of large amounts of compute time for decoding EXIF data.,libexif,CVE-2020-13114,CWE-770
7056,6349,"exif_mnote_data_pentax_load (ExifMnoteData *en,
const unsigned char *buf, unsigned int buf_size)
{
ExifMnoteDataPentax *n = (ExifMnoteDataPentax *) en;
size_t i, tcount, o, datao, base = 0;
ExifShort c;
if (!n || !buf || !buf_size) {
exif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,
""ExifMnoteDataPentax"", ""Short MakerNote"");
return;
}
datao = 6 + n->offset;
if ((datao + 8 < datao) || (datao + 8 < 8) || (datao + 8 > buf_size)) {
exif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,
""ExifMnoteDataPentax"", ""Short MakerNote"");
return;
}
if (!memcmp(buf + datao, ""AOC"", 4)) {
if ((buf[datao + 4] == 'I') && (buf[datao + 5] == 'I')) {
n->version = pentaxV3;
n->order = EXIF_BYTE_ORDER_INTEL;
} else if ((buf[datao + 4] == 'M') && (buf[datao + 5] == 'M')) {
n->version = pentaxV3;
n->order = EXIF_BYTE_ORDER_MOTOROLA;
} else {
n->version = pentaxV2;
}
exif_log (en->log, EXIF_LOG_CODE_DEBUG, ""ExifMnoteDataPentax"",
""Parsing Pentax maker note v%d..."", (int)n->version);
datao += 4 + 2;
base = MNOTE_PENTAX2_TAG_BASE;
} else if (!memcmp(buf + datao, ""QVC"", 4)) {
exif_log (en->log, EXIF_LOG_CODE_DEBUG, ""ExifMnoteDataPentax"",
""Parsing Casio maker note v2..."");
n->version = casioV2;
base = MNOTE_CASIO2_TAG_BASE;
datao += 4 + 2;
} else {
exif_log (en->log, EXIF_LOG_CODE_DEBUG, ""ExifMnoteDataPentax"",
""Parsing Pentax maker note v1..."");
n->version = pentaxV1;
}
c = exif_get_short (buf + datao, n->order);
datao += 2;
exif_mnote_data_pentax_clear (n);
n->entries = exif_mem_alloc (en->mem, sizeof (MnotePentaxEntry) * c);
if (!n->entries) {
EXIF_LOG_NO_MEMORY(en->log, ""ExifMnoteDataPentax"", sizeof (MnotePentaxEntry) * c);
return;
}
tcount = 0;
for (i = c, o = datao; i; --i, o += 12) {
size_t s;
if ((o + 12 < o) || (o + 12 < 12) || (o + 12 > buf_size)) {
exif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,
""ExifMnoteDataPentax"", ""Short MakerNote"");
break;
}
n->entries[tcount].tag        = exif_get_short (buf + o + 0, n->order) + base;
n->entries[tcount].format     = exif_get_short (buf + o + 2, n->order);
n->entries[tcount].components = exif_get_long  (buf + o + 4, n->order);
n->entries[tcount].order      = n->order;
exif_log (en->log, EXIF_LOG_CODE_DEBUG, ""ExifMnotePentax"",
""Loading entry 0x%x ('%s')..."", n->entries[tcount].tag,
mnote_pentax_tag_get_name (n->entries[tcount].tag));
s = exif_format_get_size (n->entries[tcount].format) *
n->entries[tcount].components;
n->entries[tcount].size = s;
if (s) {
size_t dataofs = o + 8;
if (s > 4)
dataofs = exif_get_long (buf + dataofs, n->order) + 6;
if ((dataofs + s < dataofs) || (dataofs + s < s) ||
(dataofs + s > buf_size)) {
exif_log (en->log, EXIF_LOG_CODE_DEBUG,
""ExifMnoteDataPentax"", ""Tag data past end ""
""of buffer (%u > %u)"", (unsigned)(dataofs + s), buf_size);
continue;
}
n->entries[tcount].data = exif_mem_alloc (en->mem, s);
if (!n->entries[tcount].data) {
EXIF_LOG_NO_MEMORY(en->log, ""ExifMnoteDataPentax"", s);
continue;
}
memcpy (n->entries[tcount].data, buf + dataofs, s);
}
++tcount;
}
n->count = tcount;
}","[13, 54, 66, 73, 74]",An issue was discovered in libexif before 0.6.22. Several buffer over-reads in EXIF MakerNote handling could lead to information disclosure and crashes. This is different from CVE-2020-0093.,libexif,CVE-2020-13112,CWE-125
7057,5708,"double GetGPMFSampleRate(size_t handle, uint32_t fourcc, uint32_t flags)
{
mp4object *mp4 = (mp4object *)handle;
if (mp4 == NULL) return 0.0;
GPMF_stream metadata_stream, *ms = &metadata_stream;
uint32_t teststart = 0;
uint32_t testend = mp4->indexcount;
double rate = 0.0;
if (mp4->indexcount < 1)
return 0.0;
if (mp4->indexcount > 3)
{
teststart++;
testend--;
}
uint32_t *payload = GetPayload(handle, NULL, teststart);
uint32_t payloadsize = GetPayloadSize(handle, teststart);
int32_t ret = GPMF_Init(ms, payload, payloadsize);
if (ret != GPMF_OK)
goto cleanup;
{
uint32_t startsamples = 0;
uint32_t endsamples = 0;
uint32_t missing_samples = 0;
while (ret == GPMF_OK && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))
{
missing_samples = 1;
teststart++;
payload = GetPayload(handle, payload, teststart);
payloadsize = GetPayloadSize(handle, teststart);
ret = GPMF_Init(ms, payload, payloadsize);
}
if (missing_samples)
{
teststart++;
payload = GetPayload(handle, payload, teststart);
payloadsize = GetPayloadSize(handle, teststart);
ret = GPMF_Init(ms, payload, payloadsize);
}
if (ret == GPMF_OK)
{
uint32_t samples = GPMF_Repeat(ms);
GPMF_stream find_stream;
GPMF_CopyState(ms, &find_stream);
if (!(flags & GPMF_SAMPLE_RATE_PRECISE) && GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))
{
startsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream)) - samples;
payload = GetPayload(handle, payload, testend);
payloadsize = GetPayloadSize(handle, testend);
ret = GPMF_Init(ms, payload, payloadsize);
if (ret != GPMF_OK)
goto cleanup;
if (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))
{
GPMF_CopyState(ms, &find_stream);
if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))
{
endsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream));
rate = (double)(endsamples - startsamples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);
goto cleanup;
}
}
rate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);
}
else
{
uint32_t payloadpos = 0, payloadcount = 0;
double slope, top = 0.0, bot = 0.0, meanX = 0, meanY = 0;
uint32_t *repeatarray = malloc(mp4->indexcount * 4 + 4);
memset(repeatarray, 0, mp4->indexcount * 4 + 4);
samples = 0;
for (payloadpos = teststart; payloadpos < testend; payloadcount++, payloadpos++)
{
payload = GetPayload(handle, payload, payloadpos);
payloadsize = GetPayloadSize(handle, payloadpos);
ret = GPMF_Init(ms, payload, payloadsize);
if (ret != GPMF_OK)
goto cleanup;
if (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))
{
GPMF_stream find_stream2;
GPMF_CopyState(ms, &find_stream2);
if (GPMF_OK == GPMF_FindNext(&find_stream2, fourcc, GPMF_CURRENT_LEVEL))
{
if (repeatarray)
{
float in, out;
do
{
samples++;
} while (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_CURRENT_LEVEL));
repeatarray[payloadpos] = samples;
meanY += (double)samples;
GetPayloadTime(handle, payloadpos, &in, &out);
meanX += out;
}
}
else
{
uint32_t repeat = GPMF_Repeat(ms);
samples += repeat;
if (repeatarray)
{
float in, out;
repeatarray[payloadpos] = samples;
meanY += (double)samples;
GetPayloadTime(handle, payloadpos, &in, &out);
meanX += out;
}
}
}
}
if (repeatarray)
{
meanY /= (double)payloadcount;
meanX /= (double)payloadcount;
for (payloadpos = teststart; payloadpos < testend; payloadpos++)
{
float in, out;
GetPayloadTime(handle, payloadpos, &in, &out);
top += ((double)out - meanX)*((double)repeatarray[payloadpos] - meanY);
bot += ((double)out - meanX)*((double)out - meanX);
}
slope = top / bot;
#if 0
{
double intercept;
intercept = meanY - slope*meanX;
printf(""%c%c%c%c start offset = %f (%.3fms)\n"", PRINTF_4CC(fourcc), intercept, 1000.0 * intercept / slope);
}
#endif
rate = slope;
}
else
{
rate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);
}
free(repeatarray);
goto cleanup;
}
}
}
cleanup:
if (payload)
{
FreePayload(payload);
payload = NULL;
}
return rate;
}","[9, 11, 13, 14, 16, 17, 18, 22, 24, 25, 27, 33, 35, 36, 37, 38, 40, 42, 45, 47, 48, 51, 52, 53, 55, 56, 58, 59, 60, 63, 65, 67, 68, 69, 70, 71, 72, 74, 75, 76, 77, 78, 79, 81, 82, 83, 85, 87, 88, 90, 91, 92, 93, 94, 95, 98, 100, 101, 102, 104, 105, 106, 107, 108, 113, 115, 116, 117, 119, 120, 121, 122, 124, 125, 127, 128, 129, 131, 132, 134, 136, 138, 139]",GoPro GPMF-parser 1.2.2 has a heap-based buffer over-read (4 bytes) in GPMF_Next in GPMF_parser.c.,gpmf-parser,CVE-2019-15146,CWE-125
7071,9462,"xmlValidCtxtNormalizeAttributeValue(xmlValidCtxtPtr ctxt, xmlDocPtr doc,
xmlNodePtr elem, const xmlChar *name, const xmlChar *value) {
xmlChar *ret, *dst;
const xmlChar *src;
xmlAttributePtr attrDecl = NULL;
int extsubset = 0;
if (doc == NULL) return(NULL);
if (elem == NULL) return(NULL);
if (name == NULL) return(NULL);
if (value == NULL) return(NULL);
if ((elem->ns != NULL) && (elem->ns->prefix != NULL)) {
xmlChar fn[50];
xmlChar *fullname;
fullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);
if (fullname == NULL)
return(NULL);
attrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullname, name);
if ((attrDecl == NULL) && (doc->extSubset != NULL)) {
attrDecl = xmlGetDtdAttrDesc(doc->extSubset, fullname, name);
if (attrDecl != NULL)
extsubset = 1;
}
if ((fullname != fn) && (fullname != elem->name))
xmlFree(fullname);
}
if ((attrDecl == NULL) && (doc->intSubset != NULL))
attrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, name);
if ((attrDecl == NULL) && (doc->extSubset != NULL)) {
attrDecl = xmlGetDtdAttrDesc(doc->extSubset, elem->name, name);
if (attrDecl != NULL)
extsubset = 1;
}
if (attrDecl == NULL)
return(NULL);
if (attrDecl->atype == XML_ATTRIBUTE_CDATA)
return(NULL);
ret = xmlStrdup(value);
if (ret == NULL)
return(NULL);
src = value;
dst = ret;
while (*src == 0x20) src++;
while (*src != 0) {
if (*src == 0x20) {
while (*src == 0x20) src++;
if (*src != 0)
*dst++ = 0x20;
} else {
*dst++ = *src++;
}
}
*dst = 0;
if ((doc->standalone) && (extsubset == 1) && (!xmlStrEqual(value, ret))) {
xmlErrValidNode(ctxt, elem, XML_DTD_NOT_STANDALONE,
""standalone: %s on %s value had to be normalized based on external subset declaration\n"",
name, elem->name, NULL);
ctxt->valid = 0;
}
return(ret);
}","[3, 4, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 52]",valid.c in libxml2 before 2.9.13 has a use-after-free of ID and IDREF attributes.,libxml2,CVE-2022-23308,CWE-416
7079,5566,"static int vorbis_finish_frame(stb_vorbis *f, int len, int left, int right)
{
int prev,i,j;
if (f->previous_length) {
int i,j, n = f->previous_length;
float *w = get_window(f, n);
for (i=0; i < f->channels; ++i) {
for (j=0; j < n; ++j)
f->channel_buffers[i][left+j] =
f->channel_buffers[i][left+j]*w[    j] +
f->previous_window[i][     j]*w[n-1-j];
}
}
prev = f->previous_length;
f->previous_length = len - right;
for (i=0; i < f->channels; ++i)
for (j=0; right+j < len; ++j)
f->previous_window[i][j] = f->channel_buffers[i][right+j];
if (!prev)
return 0;
if (len < right) right = len;
f->samples_output += right-left;
return right - left;
}",[7],A heap buffer overflow in the start_decoder function in stb_vorbis through 2019-03-04 allows an attacker to cause a denial of service or execute arbitrary code by opening a crafted Ogg Vorbis file.,stb,CVE-2019-13217,CWE-787
7083,6075,"static int cac_cac1_get_certificate(sc_card_t *card, u8 **out_buf, size_t *out_len)
{
u8 buf[CAC_MAX_SIZE];
u8 *out_ptr;
size_t size = 0;
size_t left = 0;
size_t len, next_len;
sc_apdu_t apdu;
int r = SC_SUCCESS;
SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
size = left = *out_buf ? *out_len : sizeof(buf);
out_ptr = *out_buf ? *out_buf : buf;
sc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, CAC_INS_GET_CERTIFICATE, 0, 0 );
next_len = MIN(left, 100);
for (; left > 0; left -= len, out_ptr += len) {
len = next_len;
apdu.resp = out_ptr;
apdu.le = len;
apdu.resplen = left;
r = sc_transmit_apdu(card, &apdu);
if (r < 0) {
break;
}
if (apdu.resplen == 0) {
r = SC_ERROR_INTERNAL;
break;
}
if (apdu.sw1 != 0x63 || apdu.sw2 < 1)  {
r = sc_check_sw(card, apdu.sw1, apdu.sw2);
left -= len;
break;
}
next_len = MIN(left, apdu.sw2);
}
if (r < 0) {
SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);
}
r = size - left;
if (*out_buf == NULL) {
*out_buf = malloc(r);
if (*out_buf == NULL) {
SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,
SC_ERROR_OUT_OF_MEMORY);
}
memcpy(*out_buf, buf, r);
}
*out_len = r;
SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);
}","[7, 14, 15, 16, 33]",An issue was discovered in OpenSC through 0.19.0 and 0.20.x through 0.20.0-rc3. libopensc/card-cac1.c mishandles buffer limits for CAC certificates.,OpenSC,CVE-2019-19481,CWE-119
7090,5988,"archive_wstring_append_from_mbs(struct archive_wstring *dest,
const char *p, size_t len)
{
size_t r;
int ret_val = 0;
size_t wcs_length = len;
size_t mbs_length = len;
const char *mbs = p;
wchar_t *wcs;
#if HAVE_MBRTOWC
mbstate_t shift_state;
memset(&shift_state, 0, sizeof(shift_state));
#endif
if (NULL == archive_wstring_ensure(dest, dest->length + wcs_length + 1))
return (-1);
wcs = dest->s + dest->length;
while (*mbs && mbs_length > 0) {
if (wcs_length == 0) {
dest->length = wcs - dest->s;
dest->s[dest->length] = L'\0';
wcs_length = mbs_length;
if (NULL == archive_wstring_ensure(dest,
dest->length + wcs_length + 1))
return (-1);
wcs = dest->s + dest->length;
}
#if HAVE_MBRTOWC
r = mbrtowc(wcs, mbs, wcs_length, &shift_state);
#else
r = mbtowc(wcs, mbs, wcs_length);
#endif
if (r == (size_t)-1 || r == (size_t)-2) {
ret_val = -1;
if (errno == EILSEQ) {
++mbs;
--mbs_length;
continue;
} else
break;
}
if (r == 0 || r > mbs_length)
break;
wcs++;
wcs_length--;
mbs += r;
mbs_length -= r;
}
dest->length = wcs - dest->s;
dest->s[dest->length] = L'\0';
return (ret_val);
}","[6, 14, 18, 27, 28, 30, 34, 35, 36, 37, 38, 39, 44]","In Libarchive 3.4.0, archive_wstring_append_from_mbs in archive_string.c has an out-of-bounds read because of an incorrect mbrtowc or mbtowc call. For example, bsdtar crashes via a crafted archive.",libarchive,CVE-2019-19221,CWE-125
7093,5804,"static void WritePixels(struct ngiflib_img * i, struct ngiflib_decode_context * context, const u8 * pixels, u16 n) {
u16 tocopy;
struct ngiflib_gif * p = i->parent;
while(n > 0) {
tocopy = (context->Xtogo < n) ? context->Xtogo : n;
if(!i->gce.transparent_flag) {
#ifndef NGIFLIB_INDEXED_ONLY
if(p->mode & NGIFLIB_MODE_INDEXED) {
#endif /* NGIFLIB_INDEXED_ONLY */
ngiflib_memcpy(context->frbuff_p.p8, pixels, tocopy);
pixels += tocopy;
context->frbuff_p.p8 += tocopy;
#ifndef NGIFLIB_INDEXED_ONLY
} else {
int j;
for(j = (int)tocopy; j > 0; j--) {
*(context->frbuff_p.p32++) =
GifIndexToTrueColor(i->palette, *pixels++);
}
}
#endif /* NGIFLIB_INDEXED_ONLY */
} else {
int j;
#ifndef NGIFLIB_INDEXED_ONLY
if(p->mode & NGIFLIB_MODE_INDEXED) {
#endif /* NGIFLIB_INDEXED_ONLY */
for(j = (int)tocopy; j > 0; j--) {
if(*pixels != i->gce.transparent_color) *context->frbuff_p.p8 = *pixels;
pixels++;
context->frbuff_p.p8++;
}
#ifndef NGIFLIB_INDEXED_ONLY
} else {
for(j = (int)tocopy; j > 0; j--) {
if(*pixels != i->gce.transparent_color) {
*context->frbuff_p.p32 = GifIndexToTrueColor(i->palette, *pixels);
}
pixels++;
context->frbuff_p.p32++;
}
}
#endif /* NGIFLIB_INDEXED_ONLY */
}
context->Xtogo -= tocopy;
if(context->Xtogo == 0) {
#ifdef NGIFLIB_ENABLE_CALLBACKS
if(p->line_cb) p->line_cb(p, context->line_p, context->curY);
#endif /* NGIFLIB_ENABLE_CALLBACKS */
context->Xtogo = i->width;
switch(context->pass) {
case 0:
context->curY++;
break;
case 1:
context->curY += 8;
if(context->curY >= p->height) {
context->pass++;
context->curY = i->posY + 4;
}
break;
case 2:
context->curY += 8;
if(context->curY >= p->height) {
context->pass++;
context->curY = i->posY + 2;
}
break;
case 3:
context->curY += 4;
if(context->curY >= p->height) {
context->pass++;
context->curY = i->posY + 1;
}
break;
case 4:
context->curY += 2;
break;
}
#ifndef NGIFLIB_INDEXED_ONLY
if(p->mode & NGIFLIB_MODE_INDEXED) {
#endif /* NGIFLIB_INDEXED_ONLY */
#ifdef NGIFLIB_ENABLE_CALLBACKS
context->line_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width;
context->frbuff_p.p8 = context->line_p.p8 + i->posX;
#else
context->frbuff_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width + i->posX;
#endif /* NGIFLIB_ENABLE_CALLBACKS */
#ifndef NGIFLIB_INDEXED_ONLY
} else {
#ifdef NGIFLIB_ENABLE_CALLBACKS
context->line_p.p32 = p->frbuff.p32 + (u32)context->curY*p->width;
context->frbuff_p.p32 = context->line_p.p32 + i->posX;
#else
context->frbuff_p.p32 = p->frbuff.p32 + (u32)context->curY*p->width + i->posX;
#endif /* NGIFLIB_ENABLE_CALLBACKS */
}
#endif /* NGIFLIB_INDEXED_ONLY */
}
n -= tocopy;
}
}","[56, 57, 58, 63, 64, 65, 70, 71, 72, 79]","ngiflib 0.4 has a heap-based buffer overflow in WritePixel() in ngiflib.c when called from DecodeGifImg, because deinterlacing for small pictures is mishandled.",ngiflib,CVE-2019-16346,CWE-682
7094,8010,"GF_Err MergeTrack(GF_TrackBox *trak, GF_TrackFragmentBox *traf, GF_MovieFragmentBox *moof_box, u64 moof_offset, s32 compressed_diff, u64 *cumulated_offset, Bool is_first_merge)
{
u32 i, j, chunk_size, track_num;
u64 base_offset, data_offset, traf_duration;
u32 def_duration, DescIndex, def_size, def_flags;
u32 duration, size, flags, prev_trun_data_offset, sample_index;
u8 pad, sync;
u16 degr;
Bool first_samp_in_traf=GF_TRUE;
Bool store_traf_map=GF_FALSE;
u8 *moof_template=NULL;
u32 moof_template_size=0;
Bool is_seg_start = GF_FALSE;
u64 seg_start=0, sidx_start=0, sidx_end=0, frag_start=0, last_dts=0;
GF_TrackFragmentRunBox *trun;
GF_TrunEntry *ent;
#ifdef GF_ENABLE_CTRN
GF_TrackFragmentBox *traf_ref = NULL;
#endif
GF_Err stbl_AppendTime(GF_SampleTableBox *stbl, u32 duration, u32 nb_pack);
GF_Err stbl_AppendSize(GF_SampleTableBox *stbl, u32 size, u32 nb_pack);
GF_Err stbl_AppendChunk(GF_SampleTableBox *stbl, u64 offset);
GF_Err stbl_AppendSampleToChunk(GF_SampleTableBox *stbl, u32 DescIndex, u32 samplesInChunk);
GF_Err stbl_AppendCTSOffset(GF_SampleTableBox *stbl, s32 CTSOffset);
GF_Err stbl_AppendRAP(GF_SampleTableBox *stbl, u8 isRap);
GF_Err stbl_AppendPadding(GF_SampleTableBox *stbl, u8 padding);
GF_Err stbl_AppendDegradation(GF_SampleTableBox *stbl, u16 DegradationPriority);
if (trak->Header->trackID != traf->tfhd->trackID) return GF_OK;
if (!trak->Media->information->sampleTable
|| !trak->Media->information->sampleTable->SampleSize
|| !trak->Media->information->sampleTable->TimeToSample
|| !trak->Media->information->sampleTable->SampleToChunk
|| !trak->Media->information->sampleTable->ChunkOffset
) {
return GF_ISOM_INVALID_FILE;
}
if (!traf->trex->track)
traf->trex->track = trak;
DescIndex = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_DESC) ? traf->tfhd->sample_desc_index : traf->trex->def_sample_desc_index;
if (!DescIndex) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] default sample description set to 0, likely broken ! Fixing to 1\n"" ));
DescIndex = 1;
} else if (DescIndex > gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes)) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] default sample description set to %d but only %d sample description(s), likely broken ! Fixing to 1\n"", DescIndex, gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes)));
DescIndex = 1;
}
#ifdef GF_ENABLE_CTRN
if (traf->trex->inherit_from_traf_id) {
u32 traf_count = gf_list_count(moof_box->TrackList);
for (i=0; i<traf_count; i++) {
GF_TrackFragmentBox *atraf = gf_list_get(moof_box->TrackList, i);
if (atraf->tfhd && atraf->tfhd->trackID==traf->trex->inherit_from_traf_id) {
traf_ref = atraf;
break;
}
}
}
#endif
def_duration = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_DUR) ? traf->tfhd->def_sample_duration : traf->trex->def_sample_duration;
def_size = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_SIZE) ? traf->tfhd->def_sample_size : traf->trex->def_sample_size;
def_flags = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_FLAGS) ? traf->tfhd->def_sample_flags : traf->trex->def_sample_flags;
base_offset = moof_offset;
if (traf->tfhd->flags & GF_ISOM_TRAF_BASE_OFFSET)
base_offset = traf->tfhd->base_data_offset;
else if (!(traf->tfhd->flags & GF_ISOM_MOOF_BASE_OFFSET))
base_offset = *cumulated_offset;
chunk_size = 0;
prev_trun_data_offset = 0;
data_offset = 0;
traf_duration = 0;
if (traf->tfdt && is_first_merge) {
#ifndef GPAC_DISABLE_LOG
if (trak->moov->mov->NextMoofNumber && trak->present_in_scalable_segment && trak->sample_count_at_seg_start && (trak->dts_at_seg_start != traf->tfdt->baseMediaDecodeTime)) {
s32 drift = (s32) ((s64) traf->tfdt->baseMediaDecodeTime - (s64)trak->dts_at_seg_start);
if (drift<0)  {
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] Warning: TFDT timing ""LLD"" less than cumulated timing ""LLD"" - using tfdt\n"", traf->tfdt->baseMediaDecodeTime, trak->dts_at_seg_start ));
} else {
GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (""[iso file] TFDT timing ""LLD"" higher than cumulated timing ""LLD"" (last sample got extended in duration)\n"", traf->tfdt->baseMediaDecodeTime, trak->dts_at_seg_start ));
}
}
#endif
trak->dts_at_seg_start = traf->tfdt->baseMediaDecodeTime;
}
else if (traf->tfxd) {
trak->dts_at_seg_start = traf->tfxd->absolute_time_in_track_timescale;
}
if (traf->tfxd) {
trak->last_tfxd_value = traf->tfxd->absolute_time_in_track_timescale;
trak->last_tfxd_value += traf->tfxd->fragment_duration_in_track_timescale;
}
if (traf->tfrf) {
if (trak->tfrf) gf_isom_box_del_parent(&trak->child_boxes, (GF_Box *)trak->tfrf);
trak->tfrf = traf->tfrf;
gf_list_del_item(traf->child_boxes, traf->tfrf);
gf_list_add(trak->child_boxes, trak->tfrf);
}
if (trak->moov->mov->signal_frag_bounds) {
store_traf_map = GF_TRUE;
if (is_first_merge) {
GF_MovieFragmentBox *moof_clone = NULL;
gf_isom_box_freeze_order((GF_Box *)moof_box);
gf_isom_clone_box((GF_Box *)moof_box, (GF_Box **)&moof_clone);
if (moof_clone) {
GF_BitStream *bs;
for (i=0; i<gf_list_count(moof_clone->TrackList); i++) {
GF_TrackFragmentBox *traf_clone = gf_list_get(moof_clone->TrackList, i);
gf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->TrackRuns);
gf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sampleGroups);
gf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sampleGroupsDescription);
gf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sub_samples);
gf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sai_offsets);
gf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sai_sizes);
if (traf_clone->sample_encryption) {
gf_isom_box_del_parent(&traf_clone->child_boxes, (GF_Box *) traf_clone->sample_encryption);
traf_clone->sample_encryption = NULL;
}
if (traf_clone->sdtp) {
gf_isom_box_del_parent(&traf_clone->child_boxes, (GF_Box *) traf_clone->sdtp);
traf_clone->sdtp = NULL;
}
}
gf_isom_box_size((GF_Box *)moof_clone);
bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
if (trak->moov->mov->seg_styp) {
gf_isom_box_size(trak->moov->mov->seg_styp);
gf_isom_box_write(trak->moov->mov->seg_styp, bs);
}
if (trak->moov->mov->root_sidx) {
gf_isom_box_size((GF_Box *)trak->moov->mov->root_sidx);
gf_isom_box_write((GF_Box *)trak->moov->mov->root_sidx, bs);
}
if (trak->moov->mov->seg_ssix) {
gf_isom_box_size(trak->moov->mov->seg_ssix);
gf_isom_box_write(trak->moov->mov->seg_ssix, bs);
}
gf_isom_box_write((GF_Box *)moof_clone, bs);
gf_isom_box_del((GF_Box*)moof_clone);
gf_bs_get_content(bs, &moof_template, &moof_template_size);
gf_bs_del(bs);
}
}
if (trak->moov->mov->seg_styp) {
is_seg_start = GF_TRUE;
seg_start = trak->moov->mov->styp_start_offset;
}
if (trak->moov->mov->root_sidx) {
is_seg_start = GF_TRUE;
sidx_start = trak->moov->mov->sidx_start_offset;
sidx_end = trak->moov->mov->sidx_end_offset;
if (! seg_start || (sidx_start<seg_start))
seg_start = sidx_start;
}
frag_start = trak->moov->mov->current_top_box_start;
}
else if (trak->moov->mov->store_traf_map) {
store_traf_map = GF_TRUE;
}
sample_index = 0;
i=0;
while ((trun = (GF_TrackFragmentRunBox *)gf_list_enum(traf->TrackRuns, &i))) {
for (j=0; j<trun->sample_count; j++) {
GF_Err e;
s32 cts_offset=0;
if (j<trun->nb_samples) {
ent = &trun->samples[j];
} else {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Track %d doesn't have enough trun entries (%d) compared to sample count (%d) in run\n"", traf->trex->trackID, trun->nb_samples, trun->sample_count ));
break;
}
size = def_size;
duration = def_duration;
flags = def_flags;
cts_offset = ent->CTS_Offset;
#ifdef GF_ENABLE_CTRN
if (trun->use_ctrn) {
if (!j && (trun->ctrn_flags & GF_ISOM_CTRN_FIRST_SAMPLE) ) {
if (trun->ctrn_first_dur) duration = ent->Duration;
if (trun->ctrn_first_size) size = ent->size;
if (trun->ctrn_first_ctts) flags = ent->flags;
} else {
if (trun->ctrn_dur) duration = ent->Duration;
if (trun->ctrn_size) size = ent->size;
if (trun->ctrn_sample_flags) flags = ent->flags;
}
if (trun->ctrn_flags & 0xF0) {
GF_TrunEntry *ref_entry;
if (!traf_ref) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Track %d use traf inheritance to track ID %d but reference traf not found\n"", traf->trex->trackID, traf->trex->inherit_from_traf_id ));
break;
}
ref_entry = traf_get_sample_entry(traf_ref, sample_index);
if (!ref_entry) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Track %d use traf inheritance but sample %d not found in reference traf\n"", traf->trex->trackID, sample_index+1 ));
break;
}
if (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_DUR)
duration = ref_entry->Duration;
if (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_SIZE)
size = ref_entry->size;
if (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_FLAGS)
flags = ref_entry->flags;
if (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_CTSO)
cts_offset = ref_entry->CTS_Offset;
}
} else
#endif
{
if (trun->flags & GF_ISOM_TRUN_DURATION) duration = ent->Duration;
if (trun->flags & GF_ISOM_TRUN_SIZE) size = ent->size;
if (trun->flags & GF_ISOM_TRUN_FLAGS) {
flags = ent->flags;
} else if (!j && (trun->flags & GF_ISOM_TRUN_FIRST_FLAG)) {
flags = trun->first_sample_flags;
}
}
sample_index++;
ent->size = size;
ent->Duration = duration;
ent->flags = flags;
ent->CTS_Offset = cts_offset;
last_dts += duration;
if (!trak->Media->information->sampleTable->SampleSize) {
trak->Media->information->sampleTable->SampleSize = (GF_SampleSizeBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STSZ);
if (!trak->Media->information->sampleTable->SampleSize)
return GF_OUT_OF_MEM;
}
e = stbl_AppendSize(trak->Media->information->sampleTable, size, ent->nb_pack);
if (e) return e;
if (!trak->Media->information->sampleTable->TimeToSample) {
trak->Media->information->sampleTable->TimeToSample = (GF_TimeToSampleBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STTS);
if (!trak->Media->information->sampleTable->TimeToSample)
return GF_OUT_OF_MEM;
}
e = stbl_AppendTime(trak->Media->information->sampleTable, duration, ent->nb_pack);
if (e) return e;
if (!j) {
u64 final_offset;
data_offset = base_offset;
if (trun->flags & GF_ISOM_TRUN_DATA_OFFSET) {
data_offset += trun->data_offset;
chunk_size = 0;
prev_trun_data_offset = trun->data_offset;
if (trun->data_offset>=0) {
data_offset -= compressed_diff;
prev_trun_data_offset -= compressed_diff;
}
}
else if (prev_trun_data_offset) {
data_offset += prev_trun_data_offset + chunk_size;
}
else {
data_offset += chunk_size;
if ((i==1) && (trun->data_offset>=0)) {
data_offset -= compressed_diff;
}
}
final_offset = data_offset;
if (trak->moov->compressed_diff) {
final_offset += trak->moov->compressed_diff;
}
if (!trak->Media->information->sampleTable->ChunkOffset) {
trak->Media->information->sampleTable->ChunkOffset = gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STCO);
if (!trak->Media->information->sampleTable->ChunkOffset)
return GF_OUT_OF_MEM;
}
e = stbl_AppendChunk(trak->Media->information->sampleTable, final_offset);
if (e) return e;
if (!trak->Media->information->sampleTable->SampleToChunk) {
trak->Media->information->sampleTable->SampleToChunk = (GF_SampleToChunkBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STSC);
if (!trak->Media->information->sampleTable->SampleToChunk)
return GF_OUT_OF_MEM;
}
e = stbl_AppendSampleToChunk(trak->Media->information->sampleTable,
DescIndex, trun->sample_count);
if (e) return e;
}
chunk_size += size;
if (store_traf_map && first_samp_in_traf) {
first_samp_in_traf = GF_FALSE;
e = stbl_AppendTrafMap(trak->Media->information->sampleTable, is_seg_start, seg_start, frag_start, moof_template, moof_template_size, sidx_start, sidx_end);
if (e) return e;
moof_template = NULL;
moof_template_size = 0;
}
if (ent->nb_pack>1) {
j+= ent->nb_pack-1;
traf_duration += ent->nb_pack*duration;
continue;
}
traf_duration += duration;
e = stbl_AppendCTSOffset(trak->Media->information->sampleTable, cts_offset);
if (e) return e;
sync = GF_ISOM_GET_FRAG_SYNC(flags);
if (trak->Media->information->sampleTable->no_sync_found && sync) {
trak->Media->information->sampleTable->no_sync_found = 0;
}
e = stbl_AppendRAP(trak->Media->information->sampleTable, sync);
if (e) return e;
pad = GF_ISOM_GET_FRAG_PAD(flags);
if (pad) {
e = stbl_AppendPadding(trak->Media->information->sampleTable, pad);
if (e) return e;
}
degr = GF_ISOM_GET_FRAG_DEG(flags);
if (degr) {
e = stbl_AppendDegradation(trak->Media->information->sampleTable, degr);
if (e) return e;
}
e = stbl_AppendDependencyType(trak->Media->information->sampleTable, GF_ISOM_GET_FRAG_LEAD(flags), GF_ISOM_GET_FRAG_DEPENDS(flags), GF_ISOM_GET_FRAG_DEPENDED(flags), GF_ISOM_GET_FRAG_REDUNDANT(flags));
if (e) return e;
}
}
if (trak->moov->mov->is_smooth && !traf->tfdt && !traf->tfxd) {
if (is_first_merge)
trak->dts_at_seg_start = trak->dts_at_next_seg_start;
trak->dts_at_next_seg_start += last_dts;
}
if (traf_duration && trak->editBox && trak->editBox->editList) {
for (i=0; i<gf_list_count(trak->editBox->editList->entryList); i++) {
GF_EdtsEntry *edts_e = gf_list_get(trak->editBox->editList->entryList, i);
if (edts_e->was_empty_dur) {
u64 extend_dur = traf_duration;
extend_dur *= trak->moov->mvhd->timeScale;
extend_dur /= trak->Media->mediaHeader->timeScale;
edts_e->segmentDuration += extend_dur;
}
else if (!edts_e->segmentDuration) {
edts_e->was_empty_dur = GF_TRUE;
if ((s64) traf_duration > edts_e->mediaTime)
traf_duration -= edts_e->mediaTime;
else
traf_duration = 0;
edts_e->segmentDuration = traf_duration;
edts_e->segmentDuration *= trak->moov->mvhd->timeScale;
edts_e->segmentDuration /= trak->Media->mediaHeader->timeScale;
}
}
}
*cumulated_offset = data_offset + chunk_size;
if (traf->sampleGroups) {
GF_List *groups;
GF_List *groupDescs;
Bool is_identical_sgpd = GF_TRUE;
u32 *new_idx = NULL, new_idx_count=0;
if (!trak->Media->information->sampleTable->sampleGroups)
trak->Media->information->sampleTable->sampleGroups = gf_list_new();
if (!trak->Media->information->sampleTable->sampleGroupsDescription)
trak->Media->information->sampleTable->sampleGroupsDescription = gf_list_new();
groupDescs = trak->Media->information->sampleTable->sampleGroupsDescription;
for (i=0; i<gf_list_count(traf->sampleGroupsDescription); i++) {
GF_SampleGroupDescriptionBox *new_sgdesc = NULL;
GF_SampleGroupDescriptionBox *sgdesc = gf_list_get(traf->sampleGroupsDescription, i);
for (j=0; j<gf_list_count(groupDescs); j++) {
new_sgdesc = gf_list_get(groupDescs, j);
if (new_sgdesc->grouping_type==sgdesc->grouping_type) break;
new_sgdesc = NULL;
}
if (!new_sgdesc) {
gf_list_add(groupDescs, sgdesc);
gf_list_add(trak->Media->information->sampleTable->child_boxes, sgdesc);
gf_list_rem(traf->sampleGroupsDescription, i);
gf_list_del_item(traf->child_boxes, sgdesc);
i--;
}
else {
u32 count;
is_identical_sgpd = gf_isom_is_identical_sgpd(new_sgdesc, sgdesc, 0);
if (is_identical_sgpd)
continue;
new_idx_count = gf_list_count(sgdesc->group_descriptions);
new_idx = (u32 *)gf_malloc(new_idx_count * sizeof(u32));
if (!new_idx) return GF_OUT_OF_MEM;
count = 0;
while (gf_list_count(sgdesc->group_descriptions)) {
void *sgpd_entry = gf_list_get(sgdesc->group_descriptions, 0);
Bool new_entry = GF_TRUE;
for (j = 0; j < gf_list_count(new_sgdesc->group_descriptions); j++) {
void *ptr = gf_list_get(new_sgdesc->group_descriptions, j);
if (gf_isom_is_identical_sgpd(sgpd_entry, ptr, new_sgdesc->grouping_type)) {
new_idx[count] = j + 1;
count ++;
new_entry = GF_FALSE;
gf_free(sgpd_entry);
break;
}
}
if (new_entry) {
gf_list_add(new_sgdesc->group_descriptions, sgpd_entry);
new_idx[count] = gf_list_count(new_sgdesc->group_descriptions);
count ++;
}
gf_list_rem(sgdesc->group_descriptions, 0);
}
}
}
groups = trak->Media->information->sampleTable->sampleGroups;
for (i=0; i<gf_list_count(traf->sampleGroups); i++) {
GF_SampleGroupBox *stbl_group = NULL;
GF_SampleGroupBox *frag_group = gf_list_get(traf->sampleGroups, i);
for (j=0; j<gf_list_count(groups); j++) {
stbl_group = gf_list_get(groups, j);
if ((frag_group->grouping_type==stbl_group->grouping_type) && (frag_group->grouping_type_parameter==stbl_group->grouping_type_parameter))
break;
stbl_group = NULL;
}
if (!stbl_group) {
stbl_group = (GF_SampleGroupBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_SBGP);
if (!stbl_group) return GF_OUT_OF_MEM;
stbl_group->grouping_type = frag_group->grouping_type;
stbl_group->grouping_type_parameter = frag_group->grouping_type_parameter;
stbl_group->version = frag_group->version;
gf_list_add(groups, stbl_group);
}
if (is_identical_sgpd) {
for (j = 0; j < frag_group->entry_count; j++)
frag_group->sample_entries[j].group_description_index &= 0x0FFFF;
if (frag_group->entry_count && stbl_group->entry_count &&
(frag_group->sample_entries[0].group_description_index==stbl_group->sample_entries[stbl_group->entry_count-1].group_description_index)
) {
stbl_group->sample_entries[stbl_group->entry_count - 1].sample_count += frag_group->sample_entries[0].sample_count;
if (frag_group->entry_count>1) {
stbl_group->sample_entries = gf_realloc(stbl_group->sample_entries, sizeof(GF_SampleGroupEntry) * (stbl_group->entry_count + frag_group->entry_count - 1));
memcpy(&stbl_group->sample_entries[stbl_group->entry_count], &frag_group->sample_entries[1], sizeof(GF_SampleGroupEntry) * (frag_group->entry_count - 1));
stbl_group->entry_count += frag_group->entry_count - 1;
}
} else {
stbl_group->sample_entries = gf_realloc(stbl_group->sample_entries, sizeof(GF_SampleGroupEntry) * (stbl_group->entry_count + frag_group->entry_count));
memcpy(&stbl_group->sample_entries[stbl_group->entry_count], &frag_group->sample_entries[0], sizeof(GF_SampleGroupEntry) * frag_group->entry_count);
stbl_group->entry_count += frag_group->entry_count;
}
} else {
stbl_group->sample_entries = gf_realloc(stbl_group->sample_entries, sizeof(GF_SampleGroupEntry) * (stbl_group->entry_count + frag_group->entry_count));
for (j = 0; j < frag_group->entry_count; j++) {
u32 sgidx = frag_group->sample_entries[j].group_description_index;
if (sgidx > 0x10000) {
sgidx -= 0x10001;
if (sgidx>=new_idx_count) {
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[isobmf] corrupted sample group index in fragment %d but only %d group descriptions in fragment\n"", sgidx, new_idx_count));
} else {
frag_group->sample_entries[j].group_description_index = new_idx[sgidx];
}
}
}
memcpy(&stbl_group->sample_entries[stbl_group->entry_count], &frag_group->sample_entries[0], sizeof(GF_SampleGroupEntry) * frag_group->entry_count);
stbl_group->entry_count += frag_group->entry_count;
}
}
if (new_idx) gf_free(new_idx);
}
track_num = gf_isom_get_tracknum_from_id(trak->moov, trak->Header->trackID);
if (gf_isom_is_cenc_media(trak->moov->mov, track_num, DescIndex)
|| traf->sample_encryption) {
GF_SampleEncryptionBox *senc = NULL;
u32 scheme_type;
gf_isom_get_cenc_info(trak->moov->mov, track_num, DescIndex, NULL, &scheme_type, NULL);
if (traf->sample_encryption) {
for (i = 0; i < gf_list_count(trak->Media->information->sampleTable->child_boxes); i++) {
GF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->child_boxes, i);
if (a->type != traf->sample_encryption->type) continue;
if ((a->type ==GF_ISOM_BOX_TYPE_UUID) && (((GF_UUIDBox *)a)->internal_4cc == GF_ISOM_BOX_UUID_PSEC)) {
senc = (GF_SampleEncryptionBox *)a;
break;
}
else if (a->type ==GF_ISOM_BOX_TYPE_SENC) {
senc = (GF_SampleEncryptionBox *)a;
break;
}
}
if (!senc && trak->sample_encryption)
senc = trak->sample_encryption;
if (!senc) {
if (traf->sample_encryption->piff_type==1) {
senc = (GF_SampleEncryptionBox *)gf_isom_create_piff_psec_box(1, 0x2, 0, 0, NULL);
} else {
senc = gf_isom_create_samp_enc_box(1, 0x2);
}
if (!trak->Media->information->sampleTable->child_boxes) trak->Media->information->sampleTable->child_boxes = gf_list_new();
trak->sample_encryption = senc;
if (!trak->child_boxes) trak->child_boxes = gf_list_new();
gf_list_add(trak->child_boxes, senc);
}
}
if (gf_isom_cenc_has_saiz_saio_traf(traf, scheme_type)) {
u32 nb_saio;
u32 aux_info_type;
u64 offset;
GF_Err e;
Bool is_encrypted;
GF_SampleAuxiliaryInfoOffsetBox *saio = NULL;
GF_SampleAuxiliaryInfoSizeBox *saiz = NULL;
offset = nb_saio = 0;
for (i = 0; i < gf_list_count(traf->sai_offsets); i++) {
saio = (GF_SampleAuxiliaryInfoOffsetBox *)gf_list_get(traf->sai_offsets, i);
aux_info_type = saio->aux_info_type;
if (!aux_info_type) aux_info_type = scheme_type;
if ((aux_info_type == GF_ISOM_CENC_SCHEME) || (aux_info_type == GF_ISOM_CBC_SCHEME) ||
(aux_info_type == GF_ISOM_CENS_SCHEME) || (aux_info_type == GF_ISOM_CBCS_SCHEME) ||
(gf_list_count(traf->sai_offsets) == 1)) {
offset = saio->offsets[0] + moof_offset;
nb_saio = saio->entry_count;
break;
}
}
for (i = 0; i < gf_list_count(traf->sai_sizes); i++) {
saiz = (GF_SampleAuxiliaryInfoSizeBox *)gf_list_get(traf->sai_sizes, i);
aux_info_type = saiz->aux_info_type;
if (!aux_info_type) aux_info_type = scheme_type;
if ((aux_info_type == GF_ISOM_CENC_SCHEME) || (aux_info_type == GF_ISOM_CBC_SCHEME) ||
(aux_info_type == GF_ISOM_CENS_SCHEME) || (aux_info_type == GF_ISOM_CBCS_SCHEME) ||
(gf_list_count(traf->sai_sizes) == 1)) {
break;
}
}
if (saiz && saio && senc) {
for (i = 0; i < saiz->sample_count; i++) {
GF_CENCSampleAuxInfo *sai;
const u8 *key_info=NULL;
u32 key_info_size;
u64 cur_position;
if (nb_saio != 1)
offset = saio->offsets[i] + moof_offset;
size = saiz->default_sample_info_size ? saiz->default_sample_info_size : saiz->sample_info_size[i];
cur_position = gf_bs_get_position(trak->moov->mov->movieFileMap->bs);
gf_bs_seek(trak->moov->mov->movieFileMap->bs, offset);
GF_SAFEALLOC(sai, GF_CENCSampleAuxInfo);
if (!sai) return GF_OUT_OF_MEM;
e = gf_isom_get_sample_cenc_info_internal(trak, traf, senc, i+1, &is_encrypted, NULL, NULL, &key_info, &key_info_size);
if (e) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[isobmf] could not get cenc info for sample %d: %s\n"", i+1, gf_error_to_string(e) ));
return e;
}
if (is_encrypted) {
sai->cenc_data_size = size;
sai->cenc_data = gf_malloc(sizeof(u8)*size);
if (!sai->cenc_data) return GF_OUT_OF_MEM;
gf_bs_read_data(trak->moov->mov->movieFileMap->bs, sai->cenc_data, sai->cenc_data_size);
} else {
sai->isNotProtected=1;
}
if (key_info) {
if (!key_info[0]) {
if (size > key_info[3])
senc->flags = 0x00000002;
}
else {
senc->flags = 0x00000002;
}
}
gf_bs_seek(trak->moov->mov->movieFileMap->bs, cur_position);
gf_list_add(senc->samp_aux_info, sai);
e = gf_isom_cenc_merge_saiz_saio(senc, trak->Media->information->sampleTable, offset, size);
if (e) return e;
if (nb_saio == 1)
offset += size;
}
}
} else if (traf->sample_encryption) {
senc_Parse(trak->moov->mov->movieFileMap->bs, trak, traf, traf->sample_encryption);
trak->sample_encryption->AlgorithmID = traf->sample_encryption->AlgorithmID;
if (!trak->sample_encryption->IV_size)
trak->sample_encryption->IV_size = traf->sample_encryption->IV_size;
if (!trak->sample_encryption->samp_aux_info) trak->sample_encryption->samp_aux_info = gf_list_new();
gf_list_transfer(trak->sample_encryption->samp_aux_info, traf->sample_encryption->samp_aux_info);
if (traf->sample_encryption->flags & 0x00000002)
trak->sample_encryption->flags |= 0x00000002;
}
}
return GF_OK;
}","[499, 500, 501, 504, 514]",The MergeTrack function in GPAC 1.0.1 allows attackers to cause a denial of service (NULL pointer dereference) via a crafted file in the MP4Box command.,gpac,CVE-2021-31260,CWE-476
7104,6370,"int imap_open_connection (IMAP_DATA* idata)
{
if (mutt_socket_open (idata->conn) < 0)
return -1;
idata->state = IMAP_CONNECTED;
if (imap_cmd_step (idata) != IMAP_CMD_OK)
{
imap_close_connection (idata);
return -1;
}
if (ascii_strncasecmp (""* OK"", idata->buf, 4) == 0)
{
if (ascii_strncasecmp (""* OK [CAPABILITY"", idata->buf, 16)
&& imap_check_capabilities (idata))
goto bail;
#if defined(USE_SSL)
if (!idata->conn->ssf && (option(OPTSSLFORCETLS) ||
mutt_bit_isset (idata->capabilities, STARTTLS)))
{
int rc;
if (option(OPTSSLFORCETLS))
rc = MUTT_YES;
else if ((rc = query_quadoption (OPT_SSLSTARTTLS,
_(""Secure connection with TLS?""))) == -1)
goto err_close_conn;
if (rc == MUTT_YES)
{
if ((rc = imap_exec (idata, ""STARTTLS"", IMAP_CMD_FAIL_OK)) == -1)
goto bail;
if (rc != -2)
{
if (mutt_ssl_starttls (idata->conn))
{
mutt_error (_(""Could not negotiate TLS connection""));
mutt_sleep (1);
goto err_close_conn;
}
else
{
if (imap_exec (idata, ""CAPABILITY"", 0))
goto bail;
}
}
}
}
if (option(OPTSSLFORCETLS) && ! idata->conn->ssf)
{
mutt_error _(""Encrypted connection unavailable"");
mutt_sleep (1);
goto err_close_conn;
}
#endif
}
else if (ascii_strncasecmp (""* PREAUTH"", idata->buf, 9) == 0)
{
idata->state = IMAP_AUTHENTICATED;
if (imap_check_capabilities (idata) != 0)
goto bail;
FREE (&idata->capstr);
}
else
{
imap_error (""imap_open_connection()"", idata->buf);
goto bail;
}
return 0;
#if defined(USE_SSL)
err_close_conn:
imap_close_connection (idata);
#endif
bail:
FREE (&idata->capstr);
return -1;
}",[56],Mutt before 1.14.3 allows an IMAP fcc/postpone man-in-the-middle attack via a PREAUTH response.,mutt,CVE-2020-14093,CWE-319
7105,8689,"iasecc_process_fci(struct sc_card *card, struct sc_file *file,
const unsigned char *buf, size_t buflen)
{
struct sc_context *ctx = card->ctx;
size_t taglen;
int rv, ii, offs;
const unsigned char *acls = NULL, *tag = NULL;
unsigned char mask;
unsigned char ops_DF[7] = {
SC_AC_OP_DELETE, 0xFF, SC_AC_OP_ACTIVATE, SC_AC_OP_DEACTIVATE, 0xFF, SC_AC_OP_CREATE, 0xFF
};
unsigned char ops_EF[7] = {
SC_AC_OP_DELETE, 0xFF, SC_AC_OP_ACTIVATE, SC_AC_OP_DEACTIVATE, 0xFF, SC_AC_OP_UPDATE, SC_AC_OP_READ
};
LOG_FUNC_CALLED(ctx);
tag = sc_asn1_find_tag(ctx,  buf, buflen, 0x6F, &taglen);
sc_log(ctx, ""processing FCI: 0x6F tag %p"", tag);
if (tag != NULL) {
sc_log(ctx, ""  FCP length %""SC_FORMAT_LEN_SIZE_T""u"", taglen);
buf = tag;
buflen = taglen;
}
tag = sc_asn1_find_tag(ctx,  buf, buflen, 0x62, &taglen);
sc_log(ctx, ""processing FCI: 0x62 tag %p"", tag);
if (tag != NULL) {
sc_log(ctx, ""  FCP length %""SC_FORMAT_LEN_SIZE_T""u"", taglen);
buf = tag;
buflen = taglen;
}
rv = iso_ops->process_fci(card, file, buf, buflen);
LOG_TEST_RET(ctx, rv, ""ISO parse FCI failed"");
sc_log(ctx, ""iasecc_process_fci() type %i; let's parse file ACLs"", file->type);
tag = sc_asn1_find_tag(ctx, buf, buflen, IASECC_DOCP_TAG_ACLS, &taglen);
if (tag)
acls = sc_asn1_find_tag(ctx, tag, taglen, IASECC_DOCP_TAG_ACLS_CONTACT, &taglen);
else
acls = sc_asn1_find_tag(ctx, buf, buflen, IASECC_DOCP_TAG_ACLS_CONTACT, &taglen);
if (!acls)   {
sc_log(ctx,
""ACLs not found in data(%""SC_FORMAT_LEN_SIZE_T""u) %s"",
buflen, sc_dump_hex(buf, buflen));
LOG_TEST_RET(ctx, SC_ERROR_OBJECT_NOT_FOUND, ""ACLs tag missing"");
}
sc_log(ctx, ""ACLs(%""SC_FORMAT_LEN_SIZE_T""u) '%s'"", taglen,
sc_dump_hex(acls, taglen));
mask = 0x40, offs = 1;
for (ii = 0; ii < 7; ii++, mask /= 2)  {
unsigned char op = file->type == SC_FILE_TYPE_DF ? ops_DF[ii] : ops_EF[ii];
if (!(mask & acls[0]))
continue;
sc_log(ctx, ""ACLs mask 0x%X, offs %i, op 0x%X, acls[offs] 0x%X"", mask, offs, op, acls[offs]);
if (op == 0xFF)   {
;
}
else if (acls[offs] == 0)   {
sc_file_add_acl_entry(file, op, SC_AC_NONE, 0);
}
else if (acls[offs] == 0xFF)   {
sc_file_add_acl_entry(file, op, SC_AC_NEVER, 0);
}
else if ((acls[offs] & IASECC_SCB_METHOD_MASK) == IASECC_SCB_METHOD_USER_AUTH)   {
sc_file_add_acl_entry(file, op, SC_AC_SEN, acls[offs] & IASECC_SCB_METHOD_MASK_REF);
}
else if (acls[offs] & IASECC_SCB_METHOD_MASK)   {
sc_file_add_acl_entry(file, op, SC_AC_SCB, acls[offs]);
}
else   {
sc_log(ctx, ""Warning: non supported SCB method: %X"", acls[offs]);
sc_file_add_acl_entry(file, op, SC_AC_NEVER, 0);
}
offs++;
}
LOG_FUNC_RETURN(ctx, 0);
}",[38],Stack buffer overflow issues were found in Opensc before version 0.22.0 in various places that could potentially crash programs using the library.,OpenSC,CVE-2021-42782,CWE-787
7113,8488,"static s32 gf_avc_read_sps_bs_internal(GF_BitStream *bs, AVCState *avc, u32 subseq_sps, u32 *vui_flag_pos, u32 nal_hdr)
{
AVC_SPS *sps;
s32 mb_width, mb_height, sps_id = -1;
u32 profile_idc, level_idc, pcomp, i, chroma_format_idc, cl = 0, cr = 0, ct = 0, cb = 0, luma_bd, chroma_bd;
u8 separate_colour_plane_flag = 0;
if (!vui_flag_pos) {
gf_bs_enable_emulation_byte_removal(bs, GF_TRUE);
}
if (!bs) {
return -1;
}
if (!nal_hdr) {
gf_bs_read_int_log(bs, 1, ""forbidden_zero_bit"");
gf_bs_read_int_log(bs, 2, ""nal_ref_idc"");
gf_bs_read_int_log(bs, 5, ""nal_unit_type"");
}
profile_idc = gf_bs_read_int_log(bs, 8, ""profile_idc"");
pcomp = gf_bs_read_int_log(bs, 8, ""profile_compatibility"");
if (pcomp & 0x3)
return -1;
level_idc = gf_bs_read_int_log(bs, 8, ""level_idc"");
sps_id = gf_bs_read_ue_log(bs, ""sps_id"") + GF_SVC_SSPS_ID_SHIFT * subseq_sps;
if ((sps_id < 0) || (sps_id >= 32)) {
return -1;
}
luma_bd = chroma_bd = 0;
sps = &avc->sps[sps_id];
chroma_format_idc = sps->ChromaArrayType = 1;
sps->state |= subseq_sps ? AVC_SUBSPS_PARSED : AVC_SPS_PARSED;
switch (profile_idc) {
case 100:
case 110:
case 122:
case 244:
case 44:
if (pcomp & 0xE0)
return -1;
case 83:
case 86:
case 118:
case 128:
chroma_format_idc = gf_bs_read_ue_log(bs, ""chroma_format_idc"");
sps->ChromaArrayType = chroma_format_idc;
if (chroma_format_idc == 3) {
separate_colour_plane_flag = gf_bs_read_int_log(bs, 1, ""separate_colour_plane_flag"");
if (separate_colour_plane_flag) sps->ChromaArrayType = 0;
}
luma_bd = gf_bs_read_ue_log(bs, ""luma_bit_depth"");
chroma_bd = gf_bs_read_ue_log(bs, ""chroma_bit_depth"");
gf_bs_read_int_log(bs, 1, ""qpprime_y_zero_transform_bypass_flag"");
if (gf_bs_read_int_log(bs, 1, ""seq_scaling_matrix_present_flag"")) {
u32 k;
for (k = 0; k < 8; k++) {
if (gf_bs_read_int_log_idx(bs, 1, ""seq_scaling_list_present_flag"", k)) {
u32 z, last = 8, next = 8;
u32 sl = k < 6 ? 16 : 64;
for (z = 0; z < sl; z++) {
if (next) {
s32 delta = gf_bs_read_se(bs);
next = (last + delta + 256) % 256;
}
last = next ? next : last;
}
}
}
}
break;
}
sps->profile_idc = profile_idc;
sps->level_idc = level_idc;
sps->prof_compat = pcomp;
sps->log2_max_frame_num = gf_bs_read_ue_log(bs, ""log2_max_frame_num"") + 4;
sps->poc_type = gf_bs_read_ue_log(bs, ""poc_type"");
sps->chroma_format = chroma_format_idc;
sps->luma_bit_depth_m8 = luma_bd;
sps->chroma_bit_depth_m8 = chroma_bd;
if (sps->poc_type == 0) {
sps->log2_max_poc_lsb = gf_bs_read_ue_log(bs, ""log2_max_poc_lsb"") + 4;
}
else if (sps->poc_type == 1) {
sps->delta_pic_order_always_zero_flag = gf_bs_read_int_log(bs, 1, ""delta_pic_order_always_zero_flag"");
sps->offset_for_non_ref_pic = gf_bs_read_se_log(bs, ""offset_for_non_ref_pic"");
sps->offset_for_top_to_bottom_field = gf_bs_read_se_log(bs, ""offset_for_top_to_bottom_field"");
sps->poc_cycle_length = gf_bs_read_ue_log(bs, ""poc_cycle_length"");
if (sps->poc_cycle_length > GF_ARRAY_LENGTH(sps->offset_for_ref_frame)) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[avc-h264] offset_for_ref_frame overflow from poc_cycle_length\n""));
return -1;
}
for (i = 0; i < sps->poc_cycle_length; i++)
sps->offset_for_ref_frame[i] = gf_bs_read_se_log_idx(bs, ""offset_for_ref_frame"", i);
}
if (sps->poc_type > 2) {
return -1;
}
sps->max_num_ref_frames = gf_bs_read_ue_log(bs, ""max_num_ref_frames"");
sps->gaps_in_frame_num_value_allowed_flag = gf_bs_read_int_log(bs, 1, ""gaps_in_frame_num_value_allowed_flag"");
mb_width = gf_bs_read_ue_log(bs, ""pic_width_in_mbs_minus1"") + 1;
mb_height = gf_bs_read_ue_log(bs, ""pic_height_in_map_units_minus1"") + 1;
sps->frame_mbs_only_flag = gf_bs_read_int_log(bs, 1, ""frame_mbs_only_flag"");
sps->width = mb_width * 16;
sps->height = (2 - sps->frame_mbs_only_flag) * mb_height * 16;
if (!sps->frame_mbs_only_flag) sps->mb_adaptive_frame_field_flag = gf_bs_read_int_log(bs, 1, ""mb_adaptive_frame_field_flag"");
gf_bs_read_int_log(bs, 1, ""direct_8x8_inference_flag"");
if (gf_bs_read_int_log(bs, 1, ""frame_cropping_flag"")) {
int CropUnitX, CropUnitY, SubWidthC = -1, SubHeightC = -1;
if (chroma_format_idc == 1) {
SubWidthC = 2; SubHeightC = 2;
}
else if (chroma_format_idc == 2) {
SubWidthC = 2; SubHeightC = 1;
}
else if ((chroma_format_idc == 3) && (separate_colour_plane_flag == 0)) {
SubWidthC = 1; SubHeightC = 1;
}
if (sps->ChromaArrayType == 0) {
assert(SubWidthC == -1);
CropUnitX = 1;
CropUnitY = 2 - sps->frame_mbs_only_flag;
}
else {
CropUnitX = SubWidthC;
CropUnitY = SubHeightC * (2 - sps->frame_mbs_only_flag);
}
cl = gf_bs_read_ue_log(bs, ""frame_crop_left_offset"");
cr = gf_bs_read_ue_log(bs, ""frame_crop_right_offset"");
ct = gf_bs_read_ue_log(bs, ""frame_crop_top_offset"");
cb = gf_bs_read_ue_log(bs, ""frame_crop_bottom_offset"");
sps->width -= CropUnitX * (cl + cr);
sps->height -= CropUnitY * (ct + cb);
cl *= CropUnitX;
cr *= CropUnitX;
ct *= CropUnitY;
cb *= CropUnitY;
}
sps->crop.left = cl;
sps->crop.right = cr;
sps->crop.top = ct;
sps->crop.bottom = cb;
if (vui_flag_pos) {
*vui_flag_pos = (u32)gf_bs_get_bit_offset(bs);
}
sps->vui_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""vui_parameters_present_flag"");
if (sps->vui_parameters_present_flag) {
sps->vui.aspect_ratio_info_present_flag = gf_bs_read_int_log(bs, 1, ""aspect_ratio_info_present_flag"");
if (sps->vui.aspect_ratio_info_present_flag) {
s32 aspect_ratio_idc = gf_bs_read_int_log(bs, 8, ""aspect_ratio_idc"");
if (aspect_ratio_idc == 255) {
sps->vui.par_num = gf_bs_read_int_log(bs, 16, ""aspect_ratio_num"");
sps->vui.par_den = gf_bs_read_int_log(bs, 16, ""aspect_ratio_den"");
}
else if (aspect_ratio_idc < GF_ARRAY_LENGTH(avc_hevc_sar) ) {
sps->vui.par_num = avc_hevc_sar[aspect_ratio_idc].w;
sps->vui.par_den = avc_hevc_sar[aspect_ratio_idc].h;
}
else {
GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (""[avc-h264] Unknown aspect_ratio_idc: your video may have a wrong aspect ratio. Contact the GPAC team!\n""));
}
}
sps->vui.overscan_info_present_flag = gf_bs_read_int_log(bs, 1, ""overscan_info_present_flag"");
if (sps->vui.overscan_info_present_flag)
gf_bs_read_int_log(bs, 1, ""overscan_appropriate_flag"");
sps->vui.video_format = 5;
sps->vui.colour_primaries = 2;
sps->vui.transfer_characteristics = 2;
sps->vui.matrix_coefficients = 2;
sps->vui.video_signal_type_present_flag = gf_bs_read_int_log(bs, 1, ""video_signal_type_present_flag"");
if (sps->vui.video_signal_type_present_flag) {
sps->vui.video_format = gf_bs_read_int_log(bs, 3, ""video_format"");
sps->vui.video_full_range_flag = gf_bs_read_int_log(bs, 1, ""video_full_range_flag"");
sps->vui.colour_description_present_flag = gf_bs_read_int_log(bs, 1, ""colour_description_present_flag"");
if (sps->vui.colour_description_present_flag) {
sps->vui.colour_primaries = gf_bs_read_int_log(bs, 8, ""colour_primaries"");
sps->vui.transfer_characteristics = gf_bs_read_int_log(bs, 8, ""transfer_characteristics"");
sps->vui.matrix_coefficients = gf_bs_read_int_log(bs, 8, ""matrix_coefficients"");
}
}
if (gf_bs_read_int_log(bs, 1, ""chroma_location_info_present_flag"")) {
gf_bs_read_ue_log(bs, ""chroma_sample_location_type_top_field"");
gf_bs_read_ue_log(bs, ""chroma_sample_location_type_bottom_field"");
}
sps->vui.timing_info_present_flag = gf_bs_read_int_log(bs, 1, ""timing_info_present_flag"");
if (sps->vui.timing_info_present_flag) {
sps->vui.num_units_in_tick = gf_bs_read_int_log(bs, 32, ""num_units_in_tick"");
sps->vui.time_scale = gf_bs_read_int_log(bs, 32, ""time_scale"");
sps->vui.fixed_frame_rate_flag = gf_bs_read_int_log(bs, 1, ""fixed_frame_rate_flag"");
}
sps->vui.nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""nal_hrd_parameters_present_flag"");
if (sps->vui.nal_hrd_parameters_present_flag)
avc_parse_hrd_parameters(bs, &sps->vui.hrd);
sps->vui.vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""vcl_hrd_parameters_present_flag"");
if (sps->vui.vcl_hrd_parameters_present_flag)
avc_parse_hrd_parameters(bs, &sps->vui.hrd);
if (sps->vui.nal_hrd_parameters_present_flag || sps->vui.vcl_hrd_parameters_present_flag)
sps->vui.low_delay_hrd_flag = gf_bs_read_int_log(bs, 1, ""low_delay_hrd_flag"");
sps->vui.pic_struct_present_flag = gf_bs_read_int_log(bs, 1, ""pic_struct_present_flag"");
}
if (subseq_sps) {
if ((profile_idc == 83) || (profile_idc == 86)) {
u8 extended_spatial_scalability_idc;
gf_bs_read_int_log(bs, 1, ""inter_layer_deblocking_filter_control_present_flag"");
extended_spatial_scalability_idc = gf_bs_read_int_log(bs, 2, ""extended_spatial_scalability_idc"");
if (sps->ChromaArrayType == 1 || sps->ChromaArrayType == 2) {
gf_bs_read_int_log(bs, 1, ""chroma_phase_x_plus1_flag"");
}
if (sps->ChromaArrayType == 1) {
gf_bs_read_int_log(bs, 2, ""chroma_phase_y_plus1"");
}
if (extended_spatial_scalability_idc == 1) {
if (sps->ChromaArrayType > 0) {
gf_bs_read_int_log(bs, 1, ""seq_ref_layer_chroma_phase_x_plus1_flag"");
gf_bs_read_int_log(bs, 2, ""seq_ref_layer_chroma_phase_y_plus1"");
}
gf_bs_read_se_log(bs, ""seq_scaled_ref_layer_left_offset"");
gf_bs_read_se_log(bs, ""seq_scaled_ref_layer_top_offset"");
gf_bs_read_se_log(bs, ""seq_scaled_ref_layer_right_offset"");
gf_bs_read_se_log(bs, ""seq_scaled_ref_layer_bottom_offset"");
}
if (gf_bs_read_int_log(bs, 1, ""seq_tcoeff_level_prediction_flag"")) {
gf_bs_read_int_log(bs, 1, ""adaptive_tcoeff_level_prediction_flag"");
}
gf_bs_read_int_log(bs, 1, ""slice_header_restriction_flag"");
if (gf_bs_read_int_log(bs, 1, ""svc_vui_parameters_present"")) {
u32 vui_ext_num_entries_minus1 = gf_bs_read_ue_log(bs, ""vui_ext_num_entries_minus1"");
for (i = 0; i <= vui_ext_num_entries_minus1; i++) {
u8 vui_ext_nal_hrd_parameters_present_flag, vui_ext_vcl_hrd_parameters_present_flag, vui_ext_timing_info_present_flag;
gf_bs_read_int_log(bs, 3, ""vui_ext_dependency_id"");
gf_bs_read_int_log(bs, 4, ""vui_ext_quality_id"");
gf_bs_read_int_log(bs, 3, ""vui_ext_temporal_id"");
vui_ext_timing_info_present_flag = gf_bs_read_int_log(bs, 1, ""vui_ext_timing_info_present_flag"");
if (vui_ext_timing_info_present_flag) {
gf_bs_read_int_log(bs, 32, ""vui_ext_num_units_in_tick"");
gf_bs_read_int_log(bs, 32, ""vui_ext_time_scale"");
gf_bs_read_int_log(bs, 1, ""vui_ext_fixed_frame_rate_flag"");
}
vui_ext_nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""vui_ext_nal_hrd_parameters_present_flag"");
if (vui_ext_nal_hrd_parameters_present_flag) {
}
vui_ext_vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""vui_ext_vcl_hrd_parameters_present_flag"");
if (vui_ext_vcl_hrd_parameters_present_flag) {
}
if (vui_ext_nal_hrd_parameters_present_flag || vui_ext_vcl_hrd_parameters_present_flag) {
gf_bs_read_int_log(bs, 1, ""vui_ext_low_delay_hrd_flag"");
}
gf_bs_read_int_log(bs, 1, ""vui_ext_pic_struct_present_flag"");
}
}
}
else if ((profile_idc == 118) || (profile_idc == 128)) {
GF_LOG(GF_LOG_INFO, GF_LOG_CODING, (""[avc-h264] MVC parsing not implemented - skipping parsing end of Subset SPS\n""));
return sps_id;
}
if (gf_bs_read_int_log(bs, 1, ""additional_extension2"")) {
GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (""[avc-h264] skipping parsing end of Subset SPS (additional_extension2)\n""));
return sps_id;
}
}
return sps_id;
}",[87],"The binary MP4Box in Gpac 1.0.1 has a double-free vulnerability in the avc_compute_poc function in av_parsers.c, which allows attackers to cause a denial of service, even code execution and escalation of privileges.",gpac,CVE-2021-40570,CWE-415
7119,8051,"GF_Err stbl_AddSize(GF_SampleSizeBox *stsz, u32 sampleNumber, u32 size, u32 nb_pack_samples)
{
u32 i, k;
u32 *newSizes;
if (!stsz               || !sampleNumber) return GF_BAD_PARAM;
if (sampleNumber > stsz->sampleCount + 1) return GF_BAD_PARAM;
if (!nb_pack_samples) nb_pack_samples = 1;
else if (nb_pack_samples>1)
size /= nb_pack_samples;
if (stsz->sizes == NULL) {
if (! stsz->sampleCount && (stsz->type != GF_ISOM_BOX_TYPE_STZ2) ) {
stsz->sampleCount = nb_pack_samples;
stsz->sampleSize = size;
return GF_OK;
}
if (stsz->sampleSize == size) {
stsz->sampleCount += nb_pack_samples;
return GF_OK;
}
if (nb_pack_samples>1) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Inserting packed samples with different sizes is not yet supported\n"" ));
return GF_NOT_SUPPORTED;
}
stsz->sizes = (u32*)gf_malloc(sizeof(u32) * (stsz->sampleCount + 1));
if (!stsz->sizes) return GF_OUT_OF_MEM;
stsz->alloc_size = stsz->sampleCount + 1;
k = 0;
for (i = 0 ; i < stsz->sampleCount; i++) {
if (i + 1 == sampleNumber) {
stsz->sizes[i + k] = size;
k = 1;
}
stsz->sizes[i+k] = stsz->sampleSize;
}
if (stsz->sampleCount + 1 == sampleNumber) {
stsz->sizes[stsz->sampleCount] = size;
}
stsz->sampleSize = 0;
stsz->sampleCount++;
return GF_OK;
}
if (stsz->sampleCount + 1 == sampleNumber) {
if (!stsz->alloc_size) stsz->alloc_size = stsz->sampleCount;
if (stsz->sampleCount == stsz->alloc_size) {
ALLOC_INC(stsz->alloc_size);
stsz->sizes = gf_realloc(stsz->sizes, sizeof(u32)*(stsz->alloc_size) );
if (!stsz->sizes) return GF_OUT_OF_MEM;
memset(&stsz->sizes[stsz->sampleCount], 0, sizeof(u32)*(stsz->alloc_size - stsz->sampleCount) );
}
stsz->sizes[stsz->sampleCount] = size;
} else {
newSizes = (u32*)gf_malloc(sizeof(u32)*(1 + stsz->sampleCount) );
if (!newSizes) return GF_OUT_OF_MEM;
k = 0;
for (i = 0; i < stsz->sampleCount; i++) {
if (i + 1 == sampleNumber) {
newSizes[i + k] = size;
k = 1;
}
newSizes[i + k] = stsz->sizes[i];
}
gf_free(stsz->sizes);
stsz->sizes = newSizes;
stsz->alloc_size = 1 + stsz->sampleCount;
}
stsz->sampleCount++;
return GF_OK;
}","[7, 8, 9, 12, 17, 20]",Buffer overflow in the stbl_AppendSize function in MP4Box in GPAC 1.0.1 allows attackers to cause a denial of service or execute arbitrary code via a crafted file.,gpac,CVE-2021-32439,CWE-120
7129,5567,"static int start_decoder(vorb *f)
{
uint8 header[6], x,y;
int len,i,j,k, max_submaps = 0;
int longest_floorlist=0;
if (!start_page(f))                              return FALSE;
if (!(f->page_flag & PAGEFLAG_first_page))       return error(f, VORBIS_invalid_first_page);
if (f->page_flag & PAGEFLAG_last_page)           return error(f, VORBIS_invalid_first_page);
if (f->page_flag & PAGEFLAG_continued_packet)    return error(f, VORBIS_invalid_first_page);
if (f->segment_count != 1)                       return error(f, VORBIS_invalid_first_page);
if (f->segments[0] != 30) {
if (f->segments[0] == 64 &&
getn(f, header, 6) &&
header[0] == 'f' &&
header[1] == 'i' &&
header[2] == 's' &&
header[3] == 'h' &&
header[4] == 'e' &&
header[5] == 'a' &&
get8(f)   == 'd' &&
get8(f)   == '\0')                        return error(f, VORBIS_ogg_skeleton_not_supported);
else
return error(f, VORBIS_invalid_first_page);
}
if (get8(f) != VORBIS_packet_id)                 return error(f, VORBIS_invalid_first_page);
if (!getn(f, header, 6))                         return error(f, VORBIS_unexpected_eof);
if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_first_page);
if (get32(f) != 0)                               return error(f, VORBIS_invalid_first_page);
f->channels = get8(f); if (!f->channels)         return error(f, VORBIS_invalid_first_page);
if (f->channels > STB_VORBIS_MAX_CHANNELS)       return error(f, VORBIS_too_many_channels);
f->sample_rate = get32(f); if (!f->sample_rate)  return error(f, VORBIS_invalid_first_page);
get32(f);
get32(f);
get32(f);
x = get8(f);
{
int log0,log1;
log0 = x & 15;
log1 = x >> 4;
f->blocksize_0 = 1 << log0;
f->blocksize_1 = 1 << log1;
if (log0 < 6 || log0 > 13)                       return error(f, VORBIS_invalid_setup);
if (log1 < 6 || log1 > 13)                       return error(f, VORBIS_invalid_setup);
if (log0 > log1)                                 return error(f, VORBIS_invalid_setup);
}
x = get8(f);
if (!(x & 1))                                    return error(f, VORBIS_invalid_first_page);
if (!start_page(f))                              return FALSE;
if (!start_packet(f))                            return FALSE;
do {
len = next_segment(f);
skip(f, len);
f->bytes_in_seg = 0;
} while (len);
if (!start_packet(f))                            return FALSE;
#ifndef STB_VORBIS_NO_PUSHDATA_API
if (IS_PUSH_MODE(f)) {
if (!is_whole_packet_present(f, TRUE)) {
if (f->error == VORBIS_invalid_stream)
f->error = VORBIS_invalid_setup;
return FALSE;
}
}
#endif
crc32_init();
if (get8_packet(f) != VORBIS_packet_setup)       return error(f, VORBIS_invalid_setup);
for (i=0; i < 6; ++i) header[i] = get8_packet(f);
if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_setup);
f->codebook_count = get_bits(f,8) + 1;
f->codebooks = (Codebook *) setup_malloc(f, sizeof(*f->codebooks) * f->codebook_count);
if (f->codebooks == NULL)                        return error(f, VORBIS_outofmem);
memset(f->codebooks, 0, sizeof(*f->codebooks) * f->codebook_count);
for (i=0; i < f->codebook_count; ++i) {
uint32 *values;
int ordered, sorted_count;
int total=0;
uint8 *lengths;
Codebook *c = f->codebooks+i;
CHECK(f);
x = get_bits(f, 8); if (x != 0x42)            return error(f, VORBIS_invalid_setup);
x = get_bits(f, 8); if (x != 0x43)            return error(f, VORBIS_invalid_setup);
x = get_bits(f, 8); if (x != 0x56)            return error(f, VORBIS_invalid_setup);
x = get_bits(f, 8);
c->dimensions = (get_bits(f, 8)<<8) + x;
x = get_bits(f, 8);
y = get_bits(f, 8);
c->entries = (get_bits(f, 8)<<16) + (y<<8) + x;
ordered = get_bits(f,1);
c->sparse = ordered ? 0 : get_bits(f,1);
if (c->dimensions == 0 && c->entries != 0)    return error(f, VORBIS_invalid_setup);
if (c->sparse)
lengths = (uint8 *) setup_temp_malloc(f, c->entries);
else
lengths = c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);
if (!lengths) return error(f, VORBIS_outofmem);
if (ordered) {
int current_entry = 0;
int current_length = get_bits(f,5) + 1;
while (current_entry < c->entries) {
int limit = c->entries - current_entry;
int n = get_bits(f, ilog(limit));
if (current_entry + n > (int) c->entries) { return error(f, VORBIS_invalid_setup); }
memset(lengths + current_entry, current_length, n);
current_entry += n;
++current_length;
}
} else {
for (j=0; j < c->entries; ++j) {
int present = c->sparse ? get_bits(f,1) : 1;
if (present) {
lengths[j] = get_bits(f, 5) + 1;
++total;
if (lengths[j] == 32)
return error(f, VORBIS_invalid_setup);
} else {
lengths[j] = NO_CODE;
}
}
}
if (c->sparse && total >= c->entries >> 2) {
if (c->entries > (int) f->setup_temp_memory_required)
f->setup_temp_memory_required = c->entries;
c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);
if (c->codeword_lengths == NULL) return error(f, VORBIS_outofmem);
memcpy(c->codeword_lengths, lengths, c->entries);
setup_temp_free(f, lengths, c->entries);
lengths = c->codeword_lengths;
c->sparse = 0;
}
if (c->sparse) {
sorted_count = total;
} else {
sorted_count = 0;
#ifndef STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH
for (j=0; j < c->entries; ++j)
if (lengths[j] > STB_VORBIS_FAST_HUFFMAN_LENGTH && lengths[j] != NO_CODE)
++sorted_count;
#endif
}
c->sorted_entries = sorted_count;
values = NULL;
CHECK(f);
if (!c->sparse) {
c->codewords = (uint32 *) setup_malloc(f, sizeof(c->codewords[0]) * c->entries);
if (!c->codewords)                  return error(f, VORBIS_outofmem);
} else {
unsigned int size;
if (c->sorted_entries) {
c->codeword_lengths = (uint8 *) setup_malloc(f, c->sorted_entries);
if (!c->codeword_lengths)           return error(f, VORBIS_outofmem);
c->codewords = (uint32 *) setup_temp_malloc(f, sizeof(*c->codewords) * c->sorted_entries);
if (!c->codewords)                  return error(f, VORBIS_outofmem);
values = (uint32 *) setup_temp_malloc(f, sizeof(*values) * c->sorted_entries);
if (!values)                        return error(f, VORBIS_outofmem);
}
size = c->entries + (sizeof(*c->codewords) + sizeof(*values)) * c->sorted_entries;
if (size > f->setup_temp_memory_required)
f->setup_temp_memory_required = size;
}
if (!compute_codewords(c, lengths, c->entries, values)) {
if (c->sparse) setup_temp_free(f, values, 0);
return error(f, VORBIS_invalid_setup);
}
if (c->sorted_entries) {
c->sorted_codewords = (uint32 *) setup_malloc(f, sizeof(*c->sorted_codewords) * (c->sorted_entries+1));
if (c->sorted_codewords == NULL) return error(f, VORBIS_outofmem);
c->sorted_values    = ( int   *) setup_malloc(f, sizeof(*c->sorted_values   ) * (c->sorted_entries+1));
if (c->sorted_values == NULL) return error(f, VORBIS_outofmem);
++c->sorted_values;
c->sorted_values[-1] = -1;
compute_sorted_huffman(c, lengths, values);
}
if (c->sparse) {
setup_temp_free(f, values, sizeof(*values)*c->sorted_entries);
setup_temp_free(f, c->codewords, sizeof(*c->codewords)*c->sorted_entries);
setup_temp_free(f, lengths, c->entries);
c->codewords = NULL;
}
compute_accelerated_huffman(c);
CHECK(f);
c->lookup_type = get_bits(f, 4);
if (c->lookup_type > 2) return error(f, VORBIS_invalid_setup);
if (c->lookup_type > 0) {
uint16 *mults;
c->minimum_value = float32_unpack(get_bits(f, 32));
c->delta_value = float32_unpack(get_bits(f, 32));
c->value_bits = get_bits(f, 4)+1;
c->sequence_p = get_bits(f,1);
if (c->lookup_type == 1) {
c->lookup_values = lookup1_values(c->entries, c->dimensions);
} else {
c->lookup_values = c->entries * c->dimensions;
}
if (c->lookup_values == 0) return error(f, VORBIS_invalid_setup);
mults = (uint16 *) setup_temp_malloc(f, sizeof(mults[0]) * c->lookup_values);
if (mults == NULL) return error(f, VORBIS_outofmem);
for (j=0; j < (int) c->lookup_values; ++j) {
int q = get_bits(f, c->value_bits);
if (q == EOP) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_invalid_setup); }
mults[j] = q;
}
#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK
if (c->lookup_type == 1) {
int len, sparse = c->sparse;
float last=0;
if (sparse) {
if (c->sorted_entries == 0) goto skip;
c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->sorted_entries * c->dimensions);
} else
c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->entries        * c->dimensions);
if (c->multiplicands == NULL) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }
len = sparse ? c->sorted_entries : c->entries;
for (j=0; j < len; ++j) {
unsigned int z = sparse ? c->sorted_values[j] : j;
unsigned int div=1;
for (k=0; k < c->dimensions; ++k) {
int off = (z / div) % c->lookup_values;
float val = mults[off];
val = mults[off]*c->delta_value + c->minimum_value + last;
c->multiplicands[j*c->dimensions + k] = val;
if (c->sequence_p)
last = val;
if (k+1 < c->dimensions) {
if (div > UINT_MAX / (unsigned int) c->lookup_values) {
setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values);
return error(f, VORBIS_invalid_setup);
}
div *= c->lookup_values;
}
}
}
c->lookup_type = 2;
}
else
#endif
{
float last=0;
CHECK(f);
c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->lookup_values);
if (c->multiplicands == NULL) { setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }
for (j=0; j < (int) c->lookup_values; ++j) {
float val = mults[j] * c->delta_value + c->minimum_value + last;
c->multiplicands[j] = val;
if (c->sequence_p)
last = val;
}
}
#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK
skip:;
#endif
setup_temp_free(f, mults, sizeof(mults[0])*c->lookup_values);
CHECK(f);
}
CHECK(f);
}
x = get_bits(f, 6) + 1;
for (i=0; i < x; ++i) {
uint32 z = get_bits(f, 16);
if (z != 0) return error(f, VORBIS_invalid_setup);
}
f->floor_count = get_bits(f, 6)+1;
f->floor_config = (Floor *)  setup_malloc(f, f->floor_count * sizeof(*f->floor_config));
if (f->floor_config == NULL) return error(f, VORBIS_outofmem);
for (i=0; i < f->floor_count; ++i) {
f->floor_types[i] = get_bits(f, 16);
if (f->floor_types[i] > 1) return error(f, VORBIS_invalid_setup);
if (f->floor_types[i] == 0) {
Floor0 *g = &f->floor_config[i].floor0;
g->order = get_bits(f,8);
g->rate = get_bits(f,16);
g->bark_map_size = get_bits(f,16);
g->amplitude_bits = get_bits(f,6);
g->amplitude_offset = get_bits(f,8);
g->number_of_books = get_bits(f,4) + 1;
for (j=0; j < g->number_of_books; ++j)
g->book_list[j] = get_bits(f,8);
return error(f, VORBIS_feature_not_supported);
} else {
stbv__floor_ordering p[31*8+2];
Floor1 *g = &f->floor_config[i].floor1;
int max_class = -1;
g->partitions = get_bits(f, 5);
for (j=0; j < g->partitions; ++j) {
g->partition_class_list[j] = get_bits(f, 4);
if (g->partition_class_list[j] > max_class)
max_class = g->partition_class_list[j];
}
for (j=0; j <= max_class; ++j) {
g->class_dimensions[j] = get_bits(f, 3)+1;
g->class_subclasses[j] = get_bits(f, 2);
if (g->class_subclasses[j]) {
g->class_masterbooks[j] = get_bits(f, 8);
if (g->class_masterbooks[j] >= f->codebook_count) return error(f, VORBIS_invalid_setup);
}
for (k=0; k < 1 << g->class_subclasses[j]; ++k) {
g->subclass_books[j][k] = get_bits(f,8)-1;
if (g->subclass_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);
}
}
g->floor1_multiplier = get_bits(f,2)+1;
g->rangebits = get_bits(f,4);
g->Xlist[0] = 0;
g->Xlist[1] = 1 << g->rangebits;
g->values = 2;
for (j=0; j < g->partitions; ++j) {
int c = g->partition_class_list[j];
for (k=0; k < g->class_dimensions[c]; ++k) {
g->Xlist[g->values] = get_bits(f, g->rangebits);
++g->values;
}
}
for (j=0; j < g->values; ++j) {
p[j].x = g->Xlist[j];
p[j].id = j;
}
qsort(p, g->values, sizeof(p[0]), point_compare);
for (j=0; j < g->values; ++j)
g->sorted_order[j] = (uint8) p[j].id;
for (j=2; j < g->values; ++j) {
int low,hi;
neighbors(g->Xlist, j, &low,&hi);
g->neighbors[j][0] = low;
g->neighbors[j][1] = hi;
}
if (g->values > longest_floorlist)
longest_floorlist = g->values;
}
}
f->residue_count = get_bits(f, 6)+1;
f->residue_config = (Residue *) setup_malloc(f, f->residue_count * sizeof(f->residue_config[0]));
if (f->residue_config == NULL) return error(f, VORBIS_outofmem);
memset(f->residue_config, 0, f->residue_count * sizeof(f->residue_config[0]));
for (i=0; i < f->residue_count; ++i) {
uint8 residue_cascade[64];
Residue *r = f->residue_config+i;
f->residue_types[i] = get_bits(f, 16);
if (f->residue_types[i] > 2) return error(f, VORBIS_invalid_setup);
r->begin = get_bits(f, 24);
r->end = get_bits(f, 24);
if (r->end < r->begin) return error(f, VORBIS_invalid_setup);
r->part_size = get_bits(f,24)+1;
r->classifications = get_bits(f,6)+1;
r->classbook = get_bits(f,8);
if (r->classbook >= f->codebook_count) return error(f, VORBIS_invalid_setup);
for (j=0; j < r->classifications; ++j) {
uint8 high_bits=0;
uint8 low_bits=get_bits(f,3);
if (get_bits(f,1))
high_bits = get_bits(f,5);
residue_cascade[j] = high_bits*8 + low_bits;
}
r->residue_books = (short (*)[8]) setup_malloc(f, sizeof(r->residue_books[0]) * r->classifications);
if (r->residue_books == NULL) return error(f, VORBIS_outofmem);
for (j=0; j < r->classifications; ++j) {
for (k=0; k < 8; ++k) {
if (residue_cascade[j] & (1 << k)) {
r->residue_books[j][k] = get_bits(f, 8);
if (r->residue_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);
} else {
r->residue_books[j][k] = -1;
}
}
}
r->classdata = (uint8 **) setup_malloc(f, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);
if (!r->classdata) return error(f, VORBIS_outofmem);
memset(r->classdata, 0, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);
for (j=0; j < f->codebooks[r->classbook].entries; ++j) {
int classwords = f->codebooks[r->classbook].dimensions;
int temp = j;
r->classdata[j] = (uint8 *) setup_malloc(f, sizeof(r->classdata[j][0]) * classwords);
if (r->classdata[j] == NULL) return error(f, VORBIS_outofmem);
for (k=classwords-1; k >= 0; --k) {
r->classdata[j][k] = temp % r->classifications;
temp /= r->classifications;
}
}
}
f->mapping_count = get_bits(f,6)+1;
f->mapping = (Mapping *) setup_malloc(f, f->mapping_count * sizeof(*f->mapping));
if (f->mapping == NULL) return error(f, VORBIS_outofmem);
memset(f->mapping, 0, f->mapping_count * sizeof(*f->mapping));
for (i=0; i < f->mapping_count; ++i) {
Mapping *m = f->mapping + i;
int mapping_type = get_bits(f,16);
if (mapping_type != 0) return error(f, VORBIS_invalid_setup);
m->chan = (MappingChannel *) setup_malloc(f, f->channels * sizeof(*m->chan));
if (m->chan == NULL) return error(f, VORBIS_outofmem);
if (get_bits(f,1))
m->submaps = get_bits(f,4)+1;
else
m->submaps = 1;
if (m->submaps > max_submaps)
max_submaps = m->submaps;
if (get_bits(f,1)) {
m->coupling_steps = get_bits(f,8)+1;
for (k=0; k < m->coupling_steps; ++k) {
m->chan[k].magnitude = get_bits(f, ilog(f->channels-1));
m->chan[k].angle = get_bits(f, ilog(f->channels-1));
if (m->chan[k].magnitude >= f->channels)        return error(f, VORBIS_invalid_setup);
if (m->chan[k].angle     >= f->channels)        return error(f, VORBIS_invalid_setup);
if (m->chan[k].magnitude == m->chan[k].angle)   return error(f, VORBIS_invalid_setup);
}
} else
m->coupling_steps = 0;
if (get_bits(f,2)) return error(f, VORBIS_invalid_setup);
if (m->submaps > 1) {
for (j=0; j < f->channels; ++j) {
m->chan[j].mux = get_bits(f, 4);
if (m->chan[j].mux >= m->submaps)                return error(f, VORBIS_invalid_setup);
}
} else
for (j=0; j < f->channels; ++j)
m->chan[j].mux = 0;
for (j=0; j < m->submaps; ++j) {
get_bits(f,8);
m->submap_floor[j] = get_bits(f,8);
m->submap_residue[j] = get_bits(f,8);
if (m->submap_floor[j] >= f->floor_count)      return error(f, VORBIS_invalid_setup);
if (m->submap_residue[j] >= f->residue_count)  return error(f, VORBIS_invalid_setup);
}
}
f->mode_count = get_bits(f, 6)+1;
for (i=0; i < f->mode_count; ++i) {
Mode *m = f->mode_config+i;
m->blockflag = get_bits(f,1);
m->windowtype = get_bits(f,16);
m->transformtype = get_bits(f,16);
m->mapping = get_bits(f,8);
if (m->windowtype != 0)                 return error(f, VORBIS_invalid_setup);
if (m->transformtype != 0)              return error(f, VORBIS_invalid_setup);
if (m->mapping >= f->mapping_count)     return error(f, VORBIS_invalid_setup);
}
flush_packet(f);
f->previous_length = 0;
for (i=0; i < f->channels; ++i) {
f->channel_buffers[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1);
f->previous_window[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2);
f->finalY[i]          = (int16 *) setup_malloc(f, sizeof(int16) * longest_floorlist);
if (f->channel_buffers[i] == NULL || f->previous_window[i] == NULL || f->finalY[i] == NULL) return error(f, VORBIS_outofmem);
memset(f->channel_buffers[i], 0, sizeof(float) * f->blocksize_1);
#ifdef STB_VORBIS_NO_DEFER_FLOOR
f->floor_buffers[i]   = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2);
if (f->floor_buffers[i] == NULL) return error(f, VORBIS_outofmem);
#endif
}
if (!init_blocksize(f, 0, f->blocksize_0)) return FALSE;
if (!init_blocksize(f, 1, f->blocksize_1)) return FALSE;
f->blocksize[0] = f->blocksize_0;
f->blocksize[1] = f->blocksize_1;
#ifdef STB_VORBIS_DIVIDE_TABLE
if (integer_divide_table[1][1]==0)
for (i=0; i < DIVTAB_NUMER; ++i)
for (j=1; j < DIVTAB_DENOM; ++j)
integer_divide_table[i][j] = i / j;
#endif
{
uint32 imdct_mem = (f->blocksize_1 * sizeof(float) >> 1);
uint32 classify_mem;
int i,max_part_read=0;
for (i=0; i < f->residue_count; ++i) {
Residue *r = f->residue_config + i;
unsigned int actual_size = f->blocksize_1 / 2;
unsigned int limit_r_begin = r->begin < actual_size ? r->begin : actual_size;
unsigned int limit_r_end   = r->end   < actual_size ? r->end   : actual_size;
int n_read = limit_r_end - limit_r_begin;
int part_read = n_read / r->part_size;
if (part_read > max_part_read)
max_part_read = part_read;
}
#ifndef STB_VORBIS_DIVIDES_IN_RESIDUE
classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(uint8 *));
#else
classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(int *));
#endif
f->temp_memory_required = classify_mem;
if (imdct_mem > f->temp_memory_required)
f->temp_memory_required = imdct_mem;
}
f->first_decode = TRUE;
if (f->alloc.alloc_buffer) {
assert(f->temp_offset == f->alloc.alloc_buffer_length_in_bytes);
if (f->setup_offset + sizeof(*f) + f->temp_memory_required > (unsigned) f->temp_offset)
return error(f, VORBIS_outofmem);
}
f->first_audio_page_offset = stb_vorbis_get_file_offset(f);
return TRUE;
}","[102, 190, 317, 396]",A heap buffer overflow in the start_decoder function in stb_vorbis through 2019-03-04 allows an attacker to cause a denial of service or execute arbitrary code by opening a crafted Ogg Vorbis file.,stb,CVE-2019-13217,CWE-787
7133,8131,"GF_Descriptor *gf_isom_get_root_od(GF_ISOFile *movie)
{
GF_Descriptor *desc;
GF_ObjectDescriptor *od;
GF_InitialObjectDescriptor *iod;
GF_IsomObjectDescriptor *isom_od;
GF_IsomInitialObjectDescriptor *isom_iod;
GF_ESD *esd;
GF_ES_ID_Inc *inc;
u32 i;
u8 useIOD;
if (!movie || !movie->moov) return NULL;
if (!movie->moov->iods) return NULL;
if (movie->disable_odf_translate) {
movie->LastError = gf_odf_desc_copy((GF_Descriptor *) movie->moov->iods->descriptor, &desc);
if (movie->LastError) return NULL;
return desc;
}
od = NULL;
iod = NULL;
switch (movie->moov->iods->descriptor->tag) {
case GF_ODF_ISOM_OD_TAG:
od = (GF_ObjectDescriptor*)gf_malloc(sizeof(GF_ObjectDescriptor));
if (!od) return NULL;
memset(od, 0, sizeof(GF_ObjectDescriptor));
od->ESDescriptors = gf_list_new();
useIOD = 0;
break;
case GF_ODF_ISOM_IOD_TAG:
iod = (GF_InitialObjectDescriptor*)gf_malloc(sizeof(GF_InitialObjectDescriptor));
if (!iod) return NULL;
memset(iod, 0, sizeof(GF_InitialObjectDescriptor));
iod->ESDescriptors = gf_list_new();
useIOD = 1;
break;
default:
return NULL;
}
movie->LastError = gf_odf_desc_copy((GF_Descriptor *) movie->moov->iods->descriptor, &desc);
if (movie->LastError) return NULL;
if (!useIOD) {
isom_od = (GF_IsomObjectDescriptor *)desc;
od->objectDescriptorID = isom_od->objectDescriptorID;
od->extensionDescriptors = isom_od->extensionDescriptors;
isom_od->extensionDescriptors = NULL;
od->IPMP_Descriptors = isom_od->IPMP_Descriptors;
isom_od->IPMP_Descriptors = NULL;
od->OCIDescriptors = isom_od->OCIDescriptors;
isom_od->OCIDescriptors = NULL;
od->URLString = isom_od->URLString;
isom_od->URLString = NULL;
od->tag = GF_ODF_OD_TAG;
i=0;
while ((inc = (GF_ES_ID_Inc*)gf_list_enum(isom_od->ES_ID_IncDescriptors, &i))) {
movie->LastError = GetESDForTime(movie->moov, inc->trackID, 0, &esd);
if (!movie->LastError) movie->LastError = gf_list_add(od->ESDescriptors, esd);
if (movie->LastError) {
gf_odf_desc_del(desc);
gf_odf_desc_del((GF_Descriptor *) od);
return NULL;
}
}
gf_odf_desc_del(desc);
return (GF_Descriptor *)od;
} else {
isom_iod = (GF_IsomInitialObjectDescriptor *)desc;
iod->objectDescriptorID = isom_iod->objectDescriptorID;
iod->extensionDescriptors = isom_iod->extensionDescriptors;
isom_iod->extensionDescriptors = NULL;
iod->IPMP_Descriptors = isom_iod->IPMP_Descriptors;
isom_iod->IPMP_Descriptors = NULL;
iod->OCIDescriptors = isom_iod->OCIDescriptors;
isom_iod->OCIDescriptors = NULL;
iod->URLString = isom_iod->URLString;
isom_iod->URLString = NULL;
iod->tag = GF_ODF_IOD_TAG;
iod->audio_profileAndLevel = isom_iod->audio_profileAndLevel;
iod->graphics_profileAndLevel = isom_iod->graphics_profileAndLevel;
iod->inlineProfileFlag = isom_iod->inlineProfileFlag;
iod->OD_profileAndLevel = isom_iod->OD_profileAndLevel;
iod->scene_profileAndLevel = isom_iod->scene_profileAndLevel;
iod->visual_profileAndLevel = isom_iod->visual_profileAndLevel;
iod->IPMPToolList = isom_iod->IPMPToolList;
isom_iod->IPMPToolList = NULL;
i=0;
while ((inc = (GF_ES_ID_Inc*)gf_list_enum(isom_iod->ES_ID_IncDescriptors, &i))) {
movie->LastError = GetESDForTime(movie->moov, inc->trackID, 0, &esd);
if (!movie->LastError) movie->LastError = gf_list_add(iod->ESDescriptors, esd);
if (movie->LastError) {
gf_odf_desc_del(desc);
gf_odf_desc_del((GF_Descriptor *) iod);
return NULL;
}
}
gf_odf_desc_del(desc);
return (GF_Descriptor *)iod;
}
}",[40],Memory leak in the gf_isom_get_root_od function in MP4Box in GPAC 1.0.1 allows attackers to read memory via a crafted file.,gpac,CVE-2021-33365,CWE-401
7152,6155,"PackLinuxElf32::elf_find_dynamic(unsigned int key) const
{
Elf32_Dyn const *dynp= dynseg;
if (dynp)
for (; (unsigned)((char const *)dynp - (char const *)dynseg) < sz_dynseg
&& Elf32_Dyn::DT_NULL!=dynp->d_tag; ++dynp) if (get_te32(&dynp->d_tag)==key) {
unsigned const t= elf_get_offset_from_address(get_te32(&dynp->d_val));
if (t) {
return t + file_image;
}
break;
}
return 0;
}",[8],p_lx_elf.cpp in UPX before 3.96 has an integer overflow during unpacking via crafted values in a PT_DYNAMIC segment.,upx,CVE-2019-20805,CWE-190
7154,9539,"static Fixed lsr_translate_coords(GF_LASeRCodec *lsr, u32 val, u32 nb_bits)
{
#ifdef GPAC_FIXED_POINT
if (val >> (nb_bits-1) ) {
s32 neg = (s32) val - (1<<nb_bits);
if (neg < -FIX_ONE / 2)
return 2 * gf_divfix(INT2FIX(neg/2), lsr->res_factor);
return gf_divfix(INT2FIX(neg), lsr->res_factor);
} else {
if (val > FIX_ONE / 2)
return 2 * gf_divfix(INT2FIX(val/2), lsr->res_factor);
return gf_divfix(INT2FIX(val), lsr->res_factor);
}
#else
if (val >> (nb_bits-1) ) {
s32 neg = (s32) val - (1<<nb_bits);
return gf_divfix(INT2FIX(neg), lsr->res_factor);
} else {
return gf_divfix(INT2FIX(val), lsr->res_factor);
}
#endif
}",[3],Integer Overflow or Wraparound in GitHub repository gpac/gpac prior to 2.1-DEV.,gpac,CVE-2022-2454,CWE-190
7164,8032,"GF_Err trak_box_size(GF_Box *s)
{
u32 pos=0;
GF_TrackBox *ptr = (GF_TrackBox *)s;
if (ptr->sample_encryption && ptr->sample_encryption->load_needed) {
GF_Err e = senc_Parse(ptr->moov->mov->movieFileMap->bs, ptr, NULL, ptr->sample_encryption);
if (e) return e;
}
gf_isom_check_position(s, (GF_Box *)ptr->Header, &pos);
gf_isom_check_position(s, (GF_Box *)ptr->Aperture, &pos);
gf_isom_check_position(s, (GF_Box *)ptr->References, &pos);
gf_isom_check_position(s, (GF_Box *)ptr->editBox, &pos);
gf_isom_check_position(s, (GF_Box *)ptr->Media, &pos);
gf_isom_check_position(s, (GF_Box *)ptr->meta, &pos);
gf_isom_check_position(s, (GF_Box *)ptr->groups, &pos);
gf_isom_check_position(s, (GF_Box *)ptr->udta, &pos);
return GF_OK;
}",[6],The trak_box_size function in GPAC 1.0.1 allows attackers to cause a denial of service (NULL pointer dereference) via a crafted file in the MP4Box command.,gpac,CVE-2021-32135,CWE-476
7171,8481,"static s32 avc_parse_slice(GF_BitStream *bs, AVCState *avc, Bool svc_idr_flag, AVCSliceInfo *si)
{
s32 pps_id, num_ref_idx_l0_active_minus1 = 0, num_ref_idx_l1_active_minus1 = 0;
gf_bs_read_ue_log(bs, ""first_mb_in_slice"");
si->slice_type = gf_bs_read_ue_log(bs, ""slice_type"");
if (si->slice_type > 9) return -1;
pps_id = gf_bs_read_ue_log(bs, ""pps_id"");
if (pps_id > 255) return -1;
si->pps = &avc->pps[pps_id];
if (!si->pps->slice_group_count) return -2;
si->sps = &avc->sps[si->pps->sps_id];
if (!si->sps->log2_max_frame_num) return -2;
avc->sps_active_idx = si->pps->sps_id;
avc->pps_active_idx = pps_id;
si->frame_num = gf_bs_read_int_log(bs, si->sps->log2_max_frame_num, ""frame_num"");
si->field_pic_flag = 0;
si->bottom_field_flag = 0;
if (!si->sps->frame_mbs_only_flag) {
si->field_pic_flag = gf_bs_read_int_log(bs, 1, ""field_pic_flag"");
if (si->field_pic_flag)
si->bottom_field_flag = gf_bs_read_int_log(bs, 1, ""bottom_field_flag"");
}
if ((si->nal_unit_type == GF_AVC_NALU_IDR_SLICE) || svc_idr_flag)
si->idr_pic_id = gf_bs_read_ue_log(bs, ""idr_pic_id"");
if (si->sps->poc_type == 0) {
si->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, ""poc_lsb"");
if (si->pps->pic_order_present && !si->field_pic_flag) {
si->delta_poc_bottom = gf_bs_read_se_log(bs, ""poc_lsb"");
}
}
else if ((si->sps->poc_type == 1) && !si->sps->delta_pic_order_always_zero_flag) {
si->delta_poc[0] = gf_bs_read_se_log(bs, ""delta_poc0"");
if ((si->pps->pic_order_present == 1) && !si->field_pic_flag)
si->delta_poc[1] = gf_bs_read_se_log(bs, ""delta_poc1"");
}
if (si->pps->redundant_pic_cnt_present) {
si->redundant_pic_cnt = gf_bs_read_ue_log(bs, ""redundant_pic_cnt"");
}
if (si->slice_type % 5 == GF_AVC_TYPE_B) {
gf_bs_read_int_log(bs, 1, ""direct_spatial_mv_pred_flag"");
}
num_ref_idx_l0_active_minus1 = si->pps->num_ref_idx_l0_default_active_minus1;
num_ref_idx_l1_active_minus1 = si->pps->num_ref_idx_l1_default_active_minus1;
if (si->slice_type % 5 == GF_AVC_TYPE_P || si->slice_type % 5 == GF_AVC_TYPE_SP || si->slice_type % 5 == GF_AVC_TYPE_B) {
Bool num_ref_idx_active_override_flag = gf_bs_read_int_log(bs, 1, ""num_ref_idx_active_override_flag"");
if (num_ref_idx_active_override_flag) {
num_ref_idx_l0_active_minus1 = gf_bs_read_ue_log(bs, ""num_ref_idx_l0_active_minus1"");
if (si->slice_type % 5 == GF_AVC_TYPE_B) {
num_ref_idx_l1_active_minus1 = gf_bs_read_ue_log(bs, ""num_ref_idx_l1_active_minus1"");
}
}
}
if (si->nal_unit_type == 20 || si->nal_unit_type == 21) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[avc-h264] unimplemented ref_pic_list_mvc_modification() in slide header\n""));
assert(0);
return -1;
}
else {
ref_pic_list_modification(bs, si->slice_type);
}
if ((si->pps->weighted_pred_flag && (si->slice_type % 5 == GF_AVC_TYPE_P || si->slice_type % 5 == GF_AVC_TYPE_SP))
|| (si->pps->weighted_bipred_idc == 1 && si->slice_type % 5 == GF_AVC_TYPE_B)) {
pred_weight_table(bs, si->slice_type, si->sps->ChromaArrayType, num_ref_idx_l0_active_minus1, num_ref_idx_l1_active_minus1);
}
if (si->nal_ref_idc != 0) {
dec_ref_pic_marking(bs, (si->nal_unit_type == GF_AVC_NALU_IDR_SLICE));
}
if (si->pps->entropy_coding_mode_flag && si->slice_type % 5 != GF_AVC_TYPE_I && si->slice_type % 5 != GF_AVC_TYPE_SI) {
gf_bs_read_ue_log(bs, ""cabac_init_idc"");
}
gf_bs_read_se(bs);
if (si->slice_type % 5 == GF_AVC_TYPE_SP || si->slice_type % 5 == GF_AVC_TYPE_SI) {
if (si->slice_type % 5 == GF_AVC_TYPE_SP) {
gf_bs_read_int_log(bs, 1, ""sp_for_switch_flag"");
}
gf_bs_read_se_log(bs, ""slice_qs_delta"");
}
if (si->pps->deblocking_filter_control_present_flag) {
if (gf_bs_read_ue_log(bs, ""disable_deblocking_filter_idc"") != 1) {
gf_bs_read_se_log(bs, ""slice_alpha_c0_offset_div2"");
gf_bs_read_se_log(bs, ""slice_beta_offset_div2"");
}
}
if (si->pps->slice_group_count > 1 && si->pps->mb_slice_group_map_type >= 3 && si->pps->mb_slice_group_map_type <= 5) {
gf_bs_read_int_log(bs, (u32)ceil(log1p((si->pps->pic_size_in_map_units_minus1 + 1) / (si->pps->slice_group_change_rate_minus1 + 1) ) / log(2)), ""slice_group_change_cycle"");
}
return 0;
}",[8],"A Segmentation fault caused by null pointer dereference vulnerability eists in Gpac through 1.0.2 via the avc_parse_slice function in av_parsers.c when using mp4box, which causes a denial of service.",gpac,CVE-2021-40564,CWE-476
7186,6236,"exif_data_load_data_entry (ExifData *data, ExifEntry *entry,
const unsigned char *d,
unsigned int size, unsigned int offset)
{
unsigned int s, doff;
entry->tag        = exif_get_short (d + offset + 0, data->priv->order);
entry->format     = exif_get_short (d + offset + 2, data->priv->order);
entry->components = exif_get_long  (d + offset + 4, data->priv->order);
exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, ""ExifData"",
""Loading entry 0x%x ('%s')..."", entry->tag,
exif_tag_get_name (entry->tag));
s = exif_format_get_size(entry->format) * entry->components;
if ((s < entry->components) || (s == 0)){
return 0;
}
if (s > 4)
doff = exif_get_long (d + offset + 8, data->priv->order);
else
doff = offset + 8;
if ((doff + s < doff) || (doff + s < s) || (doff + s > size)) {
exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, ""ExifData"",
""Tag data past end of buffer (%u > %u)"", doff+s, size);
return 0;
}
entry->data = exif_data_alloc (data, s);
if (entry->data) {
entry->size = s;
memcpy (entry->data, d + doff, s);
} else {
EXIF_LOG_NO_MEMORY(data->priv->log, ""ExifData"", s);
return 0;
}
if (entry->tag == EXIF_TAG_MAKER_NOTE) {
if (!entry->data) {
exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, ""ExifData"",
""MakerNote found with empty data"");
} else if (entry->size > 6) {
exif_log (data->priv->log,
EXIF_LOG_CODE_DEBUG, ""ExifData"",
""MakerNote found (%02x %02x %02x %02x ""
""%02x %02x %02x...)."",
entry->data[0], entry->data[1], entry->data[2],
entry->data[3], entry->data[4], entry->data[5],
entry->data[6]);
}
data->priv->offset_mnote = doff;
}
return 1;
}","[20, 22]","In libexif, there is a possible out of bounds write due to an integer overflow. This could lead to remote escalation of privilege in the media content provider with no additional execution privileges needed. User interaction is needed for exploitation. Product: AndroidVersions: Android-10Android ID: A-112537774",libexif,CVE-2019-9278,CWE-190
7187,8492,"char *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicode_type)
{
u32 i, j, len;
char *sOK;
char szLineConv[1024];
unsigned short *sptr;
memset(szLine, 0, sizeof(char)*lineSize);
sOK = gf_fgets(szLine, lineSize, txt_in);
if (!sOK) return NULL;
if (unicode_type<=1) {
j=0;
len = (u32) strlen(szLine);
for (i=0; i<len; i++) {
if (!unicode_type && (szLine[i] & 0x80)) {
if ((szLine[i+1] & 0xc0) != 0x80) {
szLineConv[j] = 0xc0 | ( (szLine[i] >> 6) & 0x3 );
j++;
szLine[i] &= 0xbf;
}
else if ( (szLine[i] & 0xe0) == 0xc0) {
szLineConv[j] = szLine[i];
i++;
j++;
}
else if ( (szLine[i] & 0xf0) == 0xe0) {
szLineConv[j] = szLine[i];
i++;
j++;
szLineConv[j] = szLine[i];
i++;
j++;
}
else if ( (szLine[i] & 0xf8) == 0xf0) {
szLineConv[j] = szLine[i];
i++;
j++;
szLineConv[j] = szLine[i];
i++;
j++;
szLineConv[j] = szLine[i];
i++;
j++;
} else {
i+=1;
continue;
}
}
szLineConv[j] = szLine[i];
j++;
}
szLineConv[j] = 0;
strcpy(szLine, szLineConv);
return sOK;
}
#ifdef GPAC_BIG_ENDIAN
if (unicode_type==3)
#else
if (unicode_type==2)
#endif
{
i=0;
while (1) {
char c;
if (!szLine[i] && !szLine[i+1]) break;
c = szLine[i+1];
szLine[i+1] = szLine[i];
szLine[i] = c;
i+=2;
}
}
sptr = (u16 *)szLine;
i = (u32) gf_utf8_wcstombs(szLineConv, 1024, (const unsigned short **) &sptr);
szLineConv[i] = 0;
strcpy(szLine, szLineConv);
if (unicode_type==3) gf_fgetc(txt_in);
return sOK;
}","[5, 72]","The binary MP4Box in Gpac 1.0.1 has a double-free vulnerability in the gf_text_get_utf8_line function in load_text.c, which allows attackers to cause a denial of service, even code execution and escalation of privileges.",gpac,CVE-2021-40574,CWE-415
7199,8126,"GF_Err afra_box_read(GF_Box *s, GF_BitStream *bs)
{
unsigned int i;
GF_AdobeFragRandomAccessBox *ptr = (GF_AdobeFragRandomAccessBox *)s;
ISOM_DECREASE_SIZE(ptr, 9)
ptr->long_ids = gf_bs_read_int(bs, 1);
ptr->long_offsets = gf_bs_read_int(bs, 1);
ptr->global_entries = gf_bs_read_int(bs, 1);
ptr->reserved = gf_bs_read_int(bs, 5);
ptr->time_scale = gf_bs_read_u32(bs);
ptr->entry_count = gf_bs_read_u32(bs);
if (ptr->size / ( (ptr->long_offsets ? 16 : 12) ) < ptr->entry_count)
return GF_ISOM_INVALID_FILE;
for (i=0; i<ptr->entry_count; i++) {
GF_AfraEntry *ae = gf_malloc(sizeof(GF_AfraEntry));
if (!ae) return GF_OUT_OF_MEM;
ISOM_DECREASE_SIZE(ptr, 8)
ae->time = gf_bs_read_u64(bs);
if (ptr->long_offsets) {
ISOM_DECREASE_SIZE(ptr, 8)
ae->offset = gf_bs_read_u64(bs);
} else {
ISOM_DECREASE_SIZE(ptr, 4)
ae->offset = gf_bs_read_u32(bs);
}
gf_list_insert(ptr->local_access_entries, ae, i);
}
if (ptr->global_entries) {
ISOM_DECREASE_SIZE(ptr, 4)
ptr->global_entry_count = gf_bs_read_u32(bs);
for (i=0; i<ptr->global_entry_count; i++) {
GF_GlobalAfraEntry *ae = gf_malloc(sizeof(GF_GlobalAfraEntry));
if (!ae) return GF_OUT_OF_MEM;
ISOM_DECREASE_SIZE(ptr, 8)
ae->time = gf_bs_read_u64(bs);
if (ptr->long_ids) {
ISOM_DECREASE_SIZE(ptr, 8)
ae->segment = gf_bs_read_u32(bs);
ae->fragment = gf_bs_read_u32(bs);
} else {
ISOM_DECREASE_SIZE(ptr, 4)
ae->segment = gf_bs_read_u16(bs);
ae->fragment = gf_bs_read_u16(bs);
}
if (ptr->long_offsets) {
ISOM_DECREASE_SIZE(ptr, 16)
ae->afra_offset = gf_bs_read_u64(bs);
ae->offset_from_afra = gf_bs_read_u64(bs);
} else {
ISOM_DECREASE_SIZE(ptr, 8)
ae->afra_offset = gf_bs_read_u32(bs);
ae->offset_from_afra = gf_bs_read_u32(bs);
}
gf_list_insert(ptr->global_access_entries, ae, i);
}
}
return GF_OK;
}","[17, 26, 34, 54]",Memory leak in the afra_box_read function in MP4Box in GPAC 1.0.1 allows attackers to read memory via a crafted file.,gpac,CVE-2021-33361,CWE-401
7205,4351,"void RemoteFsDevice::load()
{
if (RemoteFsDevice::constSambaAvahiProtocol==details.url.scheme()) {
Avahi::self();
QUrlQuery q(details.url);
if (q.hasQueryItem(constServiceNameQuery)) {
details.serviceName=q.queryItemValue(constServiceNameQuery);
}
if (!details.serviceName.isEmpty()) {
AvahiService *srv=Avahi::self()->getService(details.serviceName);
if (!srv || srv->getHost().isEmpty()) {
sub=tr(""Not Available"");
} else {
sub=tr(""Available"");
}
}
connect(Avahi::self(), SIGNAL(serviceAdded(QString)), SLOT(serviceAdded(QString)));
connect(Avahi::self(), SIGNAL(serviceRemoved(QString)), SLOT(serviceRemoved(QString)));
}
if (isConnected()) {
setAudioFolder();
readOpts(settingsFileName(), opts, true);
rescan(false);
}
}","[3, 4, 5, 6, 7, 9, 10, 11, 12, 13, 14, 17, 18]","An issue was discovered in the cantata-mounter D-Bus service in Cantata through 2.3.1. The mount target path check in mounter.cpp `mpOk()` is insufficient. A regular user can consequently mount a CIFS filesystem anywhere (e.g., outside of the /home directory tree) by passing directory traversal sequences such as a home/../usr substring.",cantata,CVE-2018-12559,CWE-22
7207,7732,"set_acl(struct archive *a, int fd, const char *name,
struct archive_acl *abstract_acl,
int ae_requested_type, const char *tname)
{
aclent_t  *aclent;
#if ARCHIVE_ACL_SUNOS_NFS4
ace_t   *ace;
#endif
int   cmd, e, r;
void   *aclp;
int   ret;
int   ae_type, ae_permset, ae_tag, ae_id;
int   perm_map_size;
const acl_perm_map_t *perm_map;
uid_t   ae_uid;
gid_t   ae_gid;
const char *ae_name;
int   entries;
int   i;
ret = ARCHIVE_OK;
entries = archive_acl_reset(abstract_acl, ae_requested_type);
if (entries == 0)
return (ARCHIVE_OK);
switch (ae_requested_type) {
case ARCHIVE_ENTRY_ACL_TYPE_POSIX1E:
cmd = SETACL;
aclp = malloc(entries * sizeof(aclent_t));
break;
#if ARCHIVE_ACL_SUNOS_NFS4
case ARCHIVE_ENTRY_ACL_TYPE_NFS4:
cmd = ACE_SETACL;
aclp = malloc(entries * sizeof(ace_t));
break;
#endif
default:
errno = ENOENT;
archive_set_error(a, errno, ""Unsupported ACL type"");
return (ARCHIVE_FAILED);
}
if (aclp == NULL) {
archive_set_error(a, errno,
""Can't allocate memory for acl buffer"");
return (ARCHIVE_FAILED);
}
e = 0;
while (archive_acl_next(a, abstract_acl, ae_requested_type, &ae_type,
&ae_permset, &ae_tag, &ae_id, &ae_name) == ARCHIVE_OK) {
aclent = NULL;
#if ARCHIVE_ACL_SUNOS_NFS4
ace = NULL;
#endif
if (cmd == SETACL) {
aclent = &((aclent_t *)aclp)[e];
aclent->a_id = -1;
aclent->a_type = 0;
aclent->a_perm = 0;
}
#if ARCHIVE_ACL_SUNOS_NFS4
else {
ace = &((ace_t *)aclp)[e];
ace->a_who = -1;
ace->a_access_mask = 0;
ace->a_flags = 0;
}
#endif	/* ARCHIVE_ACL_SUNOS_NFS4 */
switch (ae_tag) {
case ARCHIVE_ENTRY_ACL_USER:
ae_uid = archive_write_disk_uid(a, ae_name, ae_id);
if (aclent != NULL) {
aclent->a_id = ae_uid;
aclent->a_type |= USER;
}
#if ARCHIVE_ACL_SUNOS_NFS4
else {
ace->a_who = ae_uid;
}
#endif
break;
case ARCHIVE_ENTRY_ACL_GROUP:
ae_gid = archive_write_disk_gid(a, ae_name, ae_id);
if (aclent != NULL) {
aclent->a_id = ae_gid;
aclent->a_type |= GROUP;
}
#if ARCHIVE_ACL_SUNOS_NFS4
else {
ace->a_who = ae_gid;
ace->a_flags |= ACE_IDENTIFIER_GROUP;
}
#endif
break;
case ARCHIVE_ENTRY_ACL_USER_OBJ:
if (aclent != NULL)
aclent->a_type |= USER_OBJ;
#if ARCHIVE_ACL_SUNOS_NFS4
else {
ace->a_flags |= ACE_OWNER;
}
#endif
break;
case ARCHIVE_ENTRY_ACL_GROUP_OBJ:
if (aclent != NULL)
aclent->a_type |= GROUP_OBJ;
#if ARCHIVE_ACL_SUNOS_NFS4
else {
ace->a_flags |= ACE_GROUP;
ace->a_flags |= ACE_IDENTIFIER_GROUP;
}
#endif
break;
case ARCHIVE_ENTRY_ACL_MASK:
if (aclent != NULL)
aclent->a_type |= CLASS_OBJ;
break;
case ARCHIVE_ENTRY_ACL_OTHER:
if (aclent != NULL)
aclent->a_type |= OTHER_OBJ;
break;
#if ARCHIVE_ACL_SUNOS_NFS4
case ARCHIVE_ENTRY_ACL_EVERYONE:
if (ace != NULL)
ace->a_flags |= ACE_EVERYONE;
break;
#endif
default:
archive_set_error(a, ARCHIVE_ERRNO_MISC,
""Unsupported ACL tag"");
ret = ARCHIVE_FAILED;
goto exit_free;
}
r = 0;
switch (ae_type) {
#if ARCHIVE_ACL_SUNOS_NFS4
case ARCHIVE_ENTRY_ACL_TYPE_ALLOW:
if (ace != NULL)
ace->a_type = ACE_ACCESS_ALLOWED_ACE_TYPE;
else
r = -1;
break;
case ARCHIVE_ENTRY_ACL_TYPE_DENY:
if (ace != NULL)
ace->a_type = ACE_ACCESS_DENIED_ACE_TYPE;
else
r = -1;
break;
case ARCHIVE_ENTRY_ACL_TYPE_AUDIT:
if (ace != NULL)
ace->a_type = ACE_SYSTEM_AUDIT_ACE_TYPE;
else
r = -1;
break;
case ARCHIVE_ENTRY_ACL_TYPE_ALARM:
if (ace != NULL)
ace->a_type = ACE_SYSTEM_ALARM_ACE_TYPE;
else
r = -1;
break;
#endif
case ARCHIVE_ENTRY_ACL_TYPE_ACCESS:
if (aclent == NULL)
r = -1;
break;
case ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:
if (aclent != NULL)
aclent->a_type |= ACL_DEFAULT;
else
r = -1;
break;
default:
archive_set_error(a, ARCHIVE_ERRNO_MISC,
""Unsupported ACL entry type"");
ret = ARCHIVE_FAILED;
goto exit_free;
}
if (r != 0) {
errno = EINVAL;
archive_set_error(a, errno,
""Failed to set ACL entry type"");
ret = ARCHIVE_FAILED;
goto exit_free;
}
#if ARCHIVE_ACL_SUNOS_NFS4
if (ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_NFS4) {
perm_map_size = acl_nfs4_perm_map_size;
perm_map = acl_nfs4_perm_map;
} else {
#endif
perm_map_size = acl_posix_perm_map_size;
perm_map = acl_posix_perm_map;
#if ARCHIVE_ACL_SUNOS_NFS4
}
#endif
for (i = 0; i < perm_map_size; ++i) {
if (ae_permset & perm_map[i].a_perm) {
#if ARCHIVE_ACL_SUNOS_NFS4
if (ae_requested_type ==
ARCHIVE_ENTRY_ACL_TYPE_NFS4)
ace->a_access_mask |=
perm_map[i].p_perm;
else
#endif
aclent->a_perm |= perm_map[i].p_perm;
}
}
#if ARCHIVE_ACL_SUNOS_NFS4
if (ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_NFS4) {
for (i = 0; i < acl_nfs4_flag_map_size; ++i) {
if (ae_permset & acl_nfs4_flag_map[i].a_perm) {
ace->a_flags |=
acl_nfs4_flag_map[i].p_perm;
}
}
}
#endif
e++;
}
if (fd >= 0) {
if (facl(fd, cmd, entries, aclp) == 0)
ret = ARCHIVE_OK;
else {
if (errno == EOPNOTSUPP) {
ret = ARCHIVE_OK;
} else {
archive_set_error(a, errno,
""Failed to set acl on fd: %s"", tname);
ret = ARCHIVE_WARN;
}
}
} else if (acl(name, cmd, entries, aclp) != 0) {
if (errno == EOPNOTSUPP) {
ret = ARCHIVE_OK;
} else {
archive_set_error(a, errno, ""Failed to set acl: %s"",
tname);
ret = ARCHIVE_WARN;
}
}
exit_free:
free(aclp);
return (ret);
}","[2, 45]","An improper link resolution flaw while extracting an archive can lead to changing the access control list (ACL) of the target of the link. An attacker may provide a malicious archive to a victim user, who would trigger this flaw when trying to extract the archive. A local attacker may use this flaw to change the ACL of a file on the system and gain more privileges.",libarchive,CVE-2021-23177,CWE-59
7215,5867,"int amqp_handle_input(amqp_connection_state_t state, amqp_bytes_t received_data,
amqp_frame_t *decoded_frame) {
size_t bytes_consumed;
void *raw_frame;
decoded_frame->frame_type = 0;
if (received_data.len == 0) {
return AMQP_STATUS_OK;
}
if (state->state == CONNECTION_STATE_IDLE) {
state->state = CONNECTION_STATE_HEADER;
}
bytes_consumed = consume_data(state, &received_data);
if (state->inbound_offset < state->target_size) {
return (int)bytes_consumed;
}
raw_frame = state->inbound_buffer.bytes;
switch (state->state) {
case CONNECTION_STATE_INITIAL:
if (memcmp(raw_frame, ""AMQP"", 4) == 0) {
decoded_frame->frame_type = AMQP_PSEUDOFRAME_PROTOCOL_HEADER;
decoded_frame->channel = 0;
decoded_frame->payload.protocol_header.transport_high =
amqp_d8(amqp_offset(raw_frame, 4));
decoded_frame->payload.protocol_header.transport_low =
amqp_d8(amqp_offset(raw_frame, 5));
decoded_frame->payload.protocol_header.protocol_version_major =
amqp_d8(amqp_offset(raw_frame, 6));
decoded_frame->payload.protocol_header.protocol_version_minor =
amqp_d8(amqp_offset(raw_frame, 7));
return_to_idle(state);
return (int)bytes_consumed;
}
case CONNECTION_STATE_HEADER: {
amqp_channel_t channel;
amqp_pool_t *channel_pool;
channel = amqp_d16(amqp_offset(raw_frame, 1));
state->target_size =
amqp_d32(amqp_offset(raw_frame, 3)) + HEADER_SIZE + FOOTER_SIZE;
if ((size_t)state->frame_max < state->target_size) {
return AMQP_STATUS_BAD_AMQP_DATA;
}
channel_pool = amqp_get_or_create_channel_pool(state, channel);
if (NULL == channel_pool) {
return AMQP_STATUS_NO_MEMORY;
}
amqp_pool_alloc_bytes(channel_pool, state->target_size,
&state->inbound_buffer);
if (NULL == state->inbound_buffer.bytes) {
return AMQP_STATUS_NO_MEMORY;
}
memcpy(state->inbound_buffer.bytes, state->header_buffer, HEADER_SIZE);
raw_frame = state->inbound_buffer.bytes;
state->state = CONNECTION_STATE_BODY;
bytes_consumed += consume_data(state, &received_data);
if (state->inbound_offset < state->target_size) {
return (int)bytes_consumed;
}
}
case CONNECTION_STATE_BODY: {
amqp_bytes_t encoded;
int res;
amqp_pool_t *channel_pool;
if (amqp_d8(amqp_offset(raw_frame, state->target_size - 1)) !=
AMQP_FRAME_END) {
return AMQP_STATUS_BAD_AMQP_DATA;
}
decoded_frame->frame_type = amqp_d8(amqp_offset(raw_frame, 0));
decoded_frame->channel = amqp_d16(amqp_offset(raw_frame, 1));
channel_pool =
amqp_get_or_create_channel_pool(state, decoded_frame->channel);
if (NULL == channel_pool) {
return AMQP_STATUS_NO_MEMORY;
}
switch (decoded_frame->frame_type) {
case AMQP_FRAME_METHOD:
decoded_frame->payload.method.id =
amqp_d32(amqp_offset(raw_frame, HEADER_SIZE));
encoded.bytes = amqp_offset(raw_frame, HEADER_SIZE + 4);
encoded.len = state->target_size - HEADER_SIZE - 4 - FOOTER_SIZE;
res = amqp_decode_method(decoded_frame->payload.method.id,
channel_pool, encoded,
&decoded_frame->payload.method.decoded);
if (res < 0) {
return res;
}
break;
case AMQP_FRAME_HEADER:
decoded_frame->payload.properties.class_id =
amqp_d16(amqp_offset(raw_frame, HEADER_SIZE));
decoded_frame->payload.properties.body_size =
amqp_d64(amqp_offset(raw_frame, HEADER_SIZE + 4));
encoded.bytes = amqp_offset(raw_frame, HEADER_SIZE + 12);
encoded.len = state->target_size - HEADER_SIZE - 12 - FOOTER_SIZE;
decoded_frame->payload.properties.raw = encoded;
res = amqp_decode_properties(
decoded_frame->payload.properties.class_id, channel_pool, encoded,
&decoded_frame->payload.properties.decoded);
if (res < 0) {
return res;
}
break;
case AMQP_FRAME_BODY:
decoded_frame->payload.body_fragment.len =
state->target_size - HEADER_SIZE - FOOTER_SIZE;
decoded_frame->payload.body_fragment.bytes =
amqp_offset(raw_frame, HEADER_SIZE);
break;
case AMQP_FRAME_HEARTBEAT:
break;
default:
decoded_frame->frame_type = 0;
break;
}
return_to_idle(state);
return (int)bytes_consumed;
}
default:
amqp_abort(""Internal error: invalid amqp_connection_state_t->state %d"",
state->state);
}
}","[37, 38, 39]",An issue was discovered in amqp_handle_input in amqp_connection.c in rabbitmq-c 0.9.0. There is an integer overflow that leads to heap memory corruption in the handling of CONNECTION_STATE_HEADER. A rogue server could return a malicious frame header that leads to a smaller target_size value than needed. This condition is then carried on to a memcpy function that copies too much data into a heap buffer.,rabbitmq-c,CVE-2019-18609,CWE-787
7217,4485,"static void swoole_serialize_arr(seriaString *buffer, zend_array *zvalue)
{
zval *data;
zend_string *key;
zend_ulong index;
swPoolstr *swStr = NULL;
zend_uchar is_pack = zvalue->u.flags & HASH_FLAG_PACKED;
ZEND_HASH_FOREACH_KEY_VAL(zvalue, index, key, data)
{
SBucketType type = {0};
type.data_type = Z_TYPE_P(data);
size_t p = buffer->offset;
if (is_pack && zvalue->nNextFreeElement == zvalue->nNumOfElements)
{
type.key_type = KEY_TYPE_INDEX;
type.key_len = 0;
SERIA_SET_ENTRY_TYPE(buffer, type);
}
else
{
if (key)
{
type.key_type = KEY_TYPE_STRING;
if ((swStr = swoole_mini_filter_find(key)))
{
type.key_len = 3;
SERIA_SET_ENTRY_TYPE(buffer, type);
if (swStr->offset & 4)
{
SERIA_SET_ENTRY_SIZE4(buffer, swStr->offset);
}
else
{
SERIA_SET_ENTRY_SHORT(buffer, swStr->offset);
}
}
else
{
if (key->len <= 0xff)
{
type.key_len = 1;
SERIA_SET_ENTRY_TYPE(buffer, type);
swoole_mini_filter_add(key, buffer->offset, 1);
SERIA_SET_ENTRY_TYPE(buffer, key->len);
swoole_string_cpy(buffer, key->val, key->len);
}
else if (key->len <= 0xffff)
{
type.key_len = 2;
SERIA_SET_ENTRY_TYPE(buffer, type);
swoole_mini_filter_add(key, buffer->offset, 2);
SERIA_SET_ENTRY_SHORT(buffer, key->len);
swoole_string_cpy(buffer, key->val, key->len);
}
else
{
type.key_len = 0;
SERIA_SET_ENTRY_TYPE(buffer, type);
swoole_mini_filter_add(key, buffer->offset, 3);
swoole_string_cpy(buffer, key + XtOffsetOf(zend_string, len), sizeof (size_t) + key->len);
}
}
}
else
{
type.key_type = KEY_TYPE_INDEX;
if (index <= 0xff)
{
type.key_len = 1;
SERIA_SET_ENTRY_TYPE(buffer, type);
SERIA_SET_ENTRY_TYPE(buffer, index);
}
else if (index <= 0xffff)
{
type.key_len = 2;
SERIA_SET_ENTRY_TYPE(buffer, type);
SERIA_SET_ENTRY_SHORT(buffer, index);
}
else
{
type.key_len = 3;
SERIA_SET_ENTRY_TYPE(buffer, type);
SERIA_SET_ENTRY_ULONG(buffer, index);
}
}
}
try_again:
switch (Z_TYPE_P(data))
{
case IS_STRING:
{
if ((swStr = swoole_mini_filter_find(Z_STR_P(data))))
{
((SBucketType*) (buffer->buffer + p))->data_len = 3;
if (swStr->offset & 4)
{
SERIA_SET_ENTRY_SIZE4(buffer, swStr->offset);
}
else
{
SERIA_SET_ENTRY_SHORT(buffer, swStr->offset);
}
}
else
{
if (Z_STRLEN_P(data) <= 0xff)
{
((SBucketType*) (buffer->buffer + p))->data_len = 1;
swoole_mini_filter_add(Z_STR_P(data), buffer->offset, 1);
SERIA_SET_ENTRY_TYPE(buffer, Z_STRLEN_P(data));
swoole_string_cpy(buffer, Z_STRVAL_P(data), Z_STRLEN_P(data));
}
else if (Z_STRLEN_P(data) <= 0xffff)
{
((SBucketType*) (buffer->buffer + p))->data_len = 2;
swoole_mini_filter_add(Z_STR_P(data), buffer->offset, 2);
SERIA_SET_ENTRY_SHORT(buffer, Z_STRLEN_P(data));
swoole_string_cpy(buffer, Z_STRVAL_P(data), Z_STRLEN_P(data));
}
else
{
((SBucketType*) (buffer->buffer + p))->data_len = 0;
swoole_mini_filter_add(Z_STR_P(data), buffer->offset, 3);
swoole_string_cpy(buffer, (char*) Z_STR_P(data) + XtOffsetOf(zend_string, len), sizeof (size_t) + Z_STRLEN_P(data));
}
}
break;
}
case IS_LONG:
{
SBucketType* long_type = (SBucketType*) (buffer->buffer + p);
swoole_serialize_long(buffer, data, long_type);
break;
}
case IS_DOUBLE:
swoole_set_zend_value(buffer, &(data->value));
break;
case IS_REFERENCE:
data = Z_REFVAL_P(data);
((SBucketType*) (buffer->buffer + p))->data_type = Z_TYPE_P(data);
goto try_again;
break;
case IS_ARRAY:
{
zend_array *ht = Z_ARRVAL_P(data);
if (GC_IS_RECURSIVE(ht))
{
((SBucketType*) (buffer->buffer + p))->data_type = IS_NULL;
php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""the array has cycle ref"");
}
else
{
seria_array_type(ht, buffer, p, buffer->offset);
if (ZEND_HASH_APPLY_PROTECTION(ht))
{
GC_PROTECT_RECURSION(ht);
swoole_serialize_arr(buffer, ht);
GC_UNPROTECT_RECURSION(ht);
}
else
{
swoole_serialize_arr(buffer, ht);
}
}
break;
}
case IS_INDIRECT:
data = Z_INDIRECT_P(data);
zend_uchar type = Z_TYPE_P(data);
((SBucketType*) (buffer->buffer + p))->data_type = (type == IS_UNDEF ? IS_NULL : type);
goto try_again;
break;
case IS_OBJECT:
{
((SBucketType*) (buffer->buffer + p))->data_type = IS_UNDEF;
if (ZEND_HASH_APPLY_PROTECTION(Z_OBJPROP_P(data)))
{
GC_PROTECT_RECURSION(Z_OBJPROP_P(data));
swoole_serialize_object(buffer, data, p);
GC_UNPROTECT_RECURSION(Z_OBJPROP_P(data));
}
else
{
swoole_serialize_object(buffer, data, p);
}
break;
}
default:
break;
}
}
ZEND_HASH_FOREACH_END();
}",[148],The unpack implementation in Swoole version 4.0.4 lacks correct size checks in the deserialization process. An attacker can craft a serialized object to exploit this vulnerability and cause a SEGV.,swoole-src,CVE-2018-15503,CWE-502
7219,6369,"static int parse_playlist(HLSContext *c, const char *url,
struct playlist *pls, AVIOContext *in)
{
int ret = 0, is_segment = 0, is_variant = 0;
int64_t duration = 0;
enum KeyType key_type = KEY_NONE;
uint8_t iv[16] = """";
int has_iv = 0;
char key[MAX_URL_SIZE] = """";
char line[MAX_URL_SIZE];
const char *ptr;
int close_in = 0;
int64_t seg_offset = 0;
int64_t seg_size = -1;
uint8_t *new_url = NULL;
struct variant_info variant_info;
char tmp_str[MAX_URL_SIZE];
struct segment *cur_init_section = NULL;
if (!in) {
#if 1
AVDictionary *opts = NULL;
close_in = 1;
av_dict_set(&opts, ""seekable"", ""0"", 0);
av_dict_set(&opts, ""user-agent"", c->user_agent, 0);
av_dict_set(&opts, ""cookies"", c->cookies, 0);
av_dict_set(&opts, ""headers"", c->headers, 0);
ret = avio_open2(&in, url, AVIO_FLAG_READ,
c->interrupt_callback, &opts);
av_dict_free(&opts);
if (ret < 0)
return ret;
#else
ret = open_in(c, &in, url);
if (ret < 0)
return ret;
close_in = 1;
#endif
}
if (av_opt_get(in, ""location"", AV_OPT_SEARCH_CHILDREN, &new_url) >= 0)
url = new_url;
read_chomp_line(in, line, sizeof(line));
if (strcmp(line, ""#EXTM3U"")) {
ret = AVERROR_INVALIDDATA;
goto fail;
}
if (pls) {
free_segment_list(pls);
pls->finished = 0;
pls->type = PLS_TYPE_UNSPECIFIED;
}
while (!avio_feof(in)) {
read_chomp_line(in, line, sizeof(line));
if (av_strstart(line, ""#EXT-X-STREAM-INF:"", &ptr)) {
is_variant = 1;
memset(&variant_info, 0, sizeof(variant_info));
ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_variant_args,
&variant_info);
} else if (av_strstart(line, ""#EXT-X-KEY:"", &ptr)) {
struct key_info info = {{0}};
ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_key_args,
&info);
key_type = KEY_NONE;
has_iv = 0;
if (!strcmp(info.method, ""AES-128""))
key_type = KEY_AES_128;
if (!strcmp(info.method, ""SAMPLE-AES""))
key_type = KEY_SAMPLE_AES;
if (!strncmp(info.iv, ""0x"", 2) || !strncmp(info.iv, ""0X"", 2)) {
ff_hex_to_data(iv, info.iv + 2);
has_iv = 1;
}
av_strlcpy(key, info.uri, sizeof(key));
} else if (av_strstart(line, ""#EXT-X-MEDIA:"", &ptr)) {
struct rendition_info info = {{0}};
ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_rendition_args,
&info);
new_rendition(c, &info, url);
} else if (av_strstart(line, ""#EXT-X-TARGETDURATION:"", &ptr)) {
ret = ensure_playlist(c, &pls, url);
if (ret < 0)
goto fail;
pls->target_duration = atoi(ptr) * AV_TIME_BASE;
} else if (av_strstart(line, ""#EXT-X-MEDIA-SEQUENCE:"", &ptr)) {
ret = ensure_playlist(c, &pls, url);
if (ret < 0)
goto fail;
pls->start_seq_no = atoi(ptr);
} else if (av_strstart(line, ""#EXT-X-PLAYLIST-TYPE:"", &ptr)) {
ret = ensure_playlist(c, &pls, url);
if (ret < 0)
goto fail;
if (!strcmp(ptr, ""EVENT""))
pls->type = PLS_TYPE_EVENT;
else if (!strcmp(ptr, ""VOD""))
pls->type = PLS_TYPE_VOD;
} else if (av_strstart(line, ""#EXT-X-MAP:"", &ptr)) {
struct init_section_info info = {{0}};
ret = ensure_playlist(c, &pls, url);
if (ret < 0)
goto fail;
ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_init_section_args,
&info);
cur_init_section = new_init_section(pls, &info, url);
} else if (av_strstart(line, ""#EXT-X-ENDLIST"", &ptr)) {
if (pls)
pls->finished = 1;
} else if (av_strstart(line, ""#EXTINF:"", &ptr)) {
is_segment = 1;
duration   = atof(ptr) * AV_TIME_BASE;
} else if (av_strstart(line, ""#EXT-X-BYTERANGE:"", &ptr)) {
seg_size = atoi(ptr);
ptr = strchr(ptr, '@');
if (ptr)
seg_offset = atoi(ptr+1);
} else if (av_strstart(line, ""#"", NULL)) {
continue;
} else if (line[0]) {
if (is_variant) {
if (!new_variant(c, &variant_info, line, url)) {
ret = AVERROR(ENOMEM);
goto fail;
}
is_variant = 0;
}
if (is_segment) {
struct segment *seg;
if (!pls) {
if (!new_variant(c, 0, url, NULL)) {
ret = AVERROR(ENOMEM);
goto fail;
}
pls = c->playlists[c->n_playlists - 1];
}
seg = av_malloc(sizeof(struct segment));
if (!seg) {
ret = AVERROR(ENOMEM);
goto fail;
}
seg->duration = duration;
seg->key_type = key_type;
if (has_iv) {
memcpy(seg->iv, iv, sizeof(iv));
} else {
int seq = pls->start_seq_no + pls->n_segments;
memset(seg->iv, 0, sizeof(seg->iv));
AV_WB32(seg->iv + 12, seq);
}
if (key_type != KEY_NONE) {
ff_make_absolute_url(tmp_str, sizeof(tmp_str), url, key);
seg->key = av_strdup(tmp_str);
if (!seg->key) {
av_free(seg);
ret = AVERROR(ENOMEM);
goto fail;
}
} else {
seg->key = NULL;
}
ff_make_absolute_url(tmp_str, sizeof(tmp_str), url, line);
seg->url = av_strdup(tmp_str);
if (!seg->url) {
av_free(seg->key);
av_free(seg);
ret = AVERROR(ENOMEM);
goto fail;
}
dynarray_add(&pls->segments, &pls->n_segments, seg);
is_segment = 0;
seg->size = seg_size;
if (seg_size >= 0) {
seg->url_offset = seg_offset;
seg_offset += seg_size;
seg_size = -1;
} else {
seg->url_offset = 0;
seg_offset = 0;
}
seg->init_section = cur_init_section;
}
}
}
if (pls)
pls->last_load_time = av_gettime_relative();
fail:
av_free(new_url);
if (close_in)
avio_close(in);
return ret;
}","[139, 140, 167]","FFmpeg 2.8 and 4.2.3 has a use-after-free via a crafted EXTINF duration in an m3u8 file because parse_playlist in libavformat/hls.c frees a pointer, and later that pointer is accessed in av_probe_input_format3 in libavformat/format.c.",FFmpeg,CVE-2020-13904,CWE-416
7230,1074,"varbit_in(PG_FUNCTION_ARGS)
{
char    *input_string = PG_GETARG_CSTRING(0);
#ifdef NOT_USED
Oid   typelem = PG_GETARG_OID(1);
#endif
int32  atttypmod = PG_GETARG_INT32(2);
VarBit    *result;
char    *sp;
bits8    *r;
int   len,
bitlen,
slen;
bool  bit_not_hex;
int   bc;
bits8  x = 0;
if (input_string[0] == 'b' || input_string[0] == 'B')
{
bit_not_hex = true;
sp = input_string + 1;
}
else if (input_string[0] == 'x' || input_string[0] == 'X')
{
bit_not_hex = false;
sp = input_string + 1;
}
else
{
bit_not_hex = true;
sp = input_string;
}
slen = strlen(sp);
if (bit_not_hex)
bitlen = slen;
else
bitlen = slen * 4;
if (atttypmod <= 0)
atttypmod = bitlen;
else if (bitlen > atttypmod)
ereport(ERROR,
(errcode(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),
errmsg(""bit string too long for type bit varying(%d)"",
atttypmod)));
len = VARBITTOTALLEN(bitlen);
result = (VarBit *) palloc0(len);
SET_VARSIZE(result, len);
VARBITLEN(result) = Min(bitlen, atttypmod);
r = VARBITS(result);
if (bit_not_hex)
{
x = HIGHBIT;
for (; *sp; sp++)
{
if (*sp == '1')
*r |= x;
else if (*sp != '0')
ereport(ERROR,
(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),
errmsg(""\""%c\"" is not a valid binary digit"",
*sp)));
x >>= 1;
if (x == 0)
{
x = HIGHBIT;
r++;
}
}
}
else
{
for (bc = 0; *sp; sp++)
{
if (*sp >= '0' && *sp <= '9')
x = (bits8) (*sp - '0');
else if (*sp >= 'A' && *sp <= 'F')
x = (bits8) (*sp - 'A') + 10;
else if (*sp >= 'a' && *sp <= 'f')
x = (bits8) (*sp - 'a') + 10;
else
ereport(ERROR,
(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),
errmsg(""\""%c\"" is not a valid hexadecimal digit"",
*sp)));
if (bc)
{
*r++ |= x;
bc = 0;
}
else
{
*r = x << 4;
bc = 1;
}
}
}
PG_RETURN_VARBIT_P(result);
}","[32, 36, 37]","Multiple integer overflows in the path_in and other unspecified functions in PostgreSQL before 8.4.20, 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact and attack vectors, which trigger a buffer overflow.  NOTE: this identifier has been SPLIT due to different affected versions; use CVE-2014-2669 for the hstore vector.",postgres,CVE-2014-0064,CWE-189
7235,9632,"static void gf_dump_vrml_field(GF_SceneDumper *sdump, GF_Node *node, GF_FieldInfo field)
{
u32 i, sf_type;
Bool needs_field_container;
GF_ChildNodeItem *list;
void *slot_ptr;
switch (field.fieldType) {
case GF_SG_VRML_SFNODE:
assert ( *(GF_Node **)field.far_ptr);
if (sdump->XMLDump) {
if (!sdump->X3DDump) {
StartElement(sdump, (char *) field.name);
EndElementHeader(sdump, 1);
sdump->indent++;
}
} else {
StartAttribute(sdump, field.name);
}
gf_dump_vrml_node(sdump, *(GF_Node **)field.far_ptr, 0, NULL);
if (sdump->XMLDump) {
if (!sdump->X3DDump) {
sdump->indent--;
EndElement(sdump, (char *) field.name, 1);
}
} else {
EndAttribute(sdump);
}
return;
case GF_SG_VRML_MFNODE:
needs_field_container = 0;
if (sdump->XMLDump && sdump->X3DDump) {
u32 count, nb_ndt;
GF_FieldInfo info;
if (!strcmp(field.name, ""children"")) {
needs_field_container = 0;
} else {
nb_ndt = 0;
count = gf_node_get_field_count(node);
for (i=0; i<count; i++) {
gf_node_get_field(node, i, &info);
if ((info.eventType==GF_SG_EVENT_IN) || (info.eventType==GF_SG_EVENT_OUT)) continue;
if (info.NDTtype==field.NDTtype) nb_ndt++;
}
needs_field_container = (nb_ndt>1) ? 1 : 0;
}
}
#ifndef GPAC_DISABLE_X3D
if (!sdump->X3DDump) {
if (gf_node_get_tag(node)==TAG_X3D_Switch) field.name = ""choice"";
}
#endif
list = * ((GF_ChildNodeItem **) field.far_ptr);
assert(list);
if (!sdump->XMLDump || !sdump->X3DDump) StartList(sdump, field.name);
sdump->indent++;
while (list) {
gf_dump_vrml_node(sdump, list->node, 1, needs_field_container ? (char *) field.name : NULL);
list = list->next;
}
sdump->indent--;
if (!sdump->XMLDump || !sdump->X3DDump) EndList(sdump, field.name);
return;
case GF_SG_VRML_SFCOMMANDBUFFER:
{
SFCommandBuffer *cb = (SFCommandBuffer *)field.far_ptr;
StartElement(sdump, (char *) field.name);
EndElementHeader(sdump, 1);
sdump->indent++;
if (!gf_list_count(cb->commandList)) {
if (sdump->trace && cb->bufferSize) {
if (sdump->XMLDump) gf_fprintf(sdump->trace, ""<!--SFCommandBuffer cannot be dumped while playing - use MP4Box instead-->\n"");
else gf_fprintf(sdump->trace, ""#SFCommandBuffer cannot be dumped while playing - use MP4Box instead\n"");
}
} else {
gf_sm_dump_command_list(sdump, cb->commandList, sdump->indent, 0);
}
sdump->indent--;
EndElement(sdump, (char *) field.name, 1);
}
return;
case GF_SG_VRML_MFATTRREF:
if (sdump->XMLDump) {
MFAttrRef *ar = (MFAttrRef *)field.far_ptr;
StartElement(sdump, (char *) field.name);
EndElementHeader(sdump, 1);
sdump->indent++;
for (i=0; i<ar->count; i++) {
if (ar->vals[i].node) {
GF_FieldInfo pinfo;
DUMP_IND(sdump);
gf_node_get_field(ar->vals[i].node, ar->vals[i].fieldIndex, &pinfo);
gf_fprintf(sdump->trace, ""<store node=\"""");
scene_dump_vrml_id(sdump, ar->vals[i].node);
gf_fprintf(sdump->trace, ""\"" field=\""%s\""/>\n"", pinfo.name);
}
}
sdump->indent--;
EndElement(sdump, (char *) field.name, 1);
return;
}
break;
}
if (gf_sg_vrml_is_sf_field(field.fieldType)) {
StartAttribute(sdump, field.name);
gf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, node);
EndAttribute(sdump);
} else {
GenMFField *mffield = (GenMFField *) field.far_ptr;
sf_type = gf_sg_vrml_get_sf_type(field.fieldType);
if (sdump->XMLDump && sdump->X3DDump) {
switch (sf_type) {
case GF_SG_VRML_SFSTRING:
case GF_SG_VRML_SFSCRIPT:
case GF_SG_VRML_SFURL:
gf_fprintf(sdump->trace, "" %s=\'"", (char *) field.name);
break;
default:
StartAttribute(sdump, field.name);
break;
}
} else {
StartAttribute(sdump, field.name);
}
if (!sdump->XMLDump) gf_fprintf(sdump->trace, ""["");
if (mffield) {
for (i=0; i<mffield->count; i++) {
if (i) gf_fprintf(sdump->trace, "" "");
gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);
gf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, node);
}
}
if (!sdump->XMLDump) gf_fprintf(sdump->trace, ""]"");
if (sdump->XMLDump && sdump->X3DDump) {
switch (sf_type) {
case GF_SG_VRML_SFSTRING:
case GF_SG_VRML_SFSCRIPT:
case GF_SG_VRML_SFURL:
gf_fprintf(sdump->trace, ""\'"");
break;
default:
EndAttribute(sdump);
break;
}
} else {
EndAttribute(sdump);
}
}
}","[125, 126, 127, 128, 129]",NULL Pointer Dereference in GitHub repository gpac/gpac prior to v2.1.0-DEV.,gpac,CVE-2022-2549,CWE-476
7244,9641,"static int build_open_gop_key_points(AVStream *st)
{
int k;
int sample_id = 0;
uint32_t cra_index;
MOVStreamContext *sc = st->priv_data;
if (st->codecpar->codec_id != AV_CODEC_ID_HEVC || !sc->sync_group_count)
return 0;
sc->sample_offsets_count = 0;
for (uint32_t i = 0; i < sc->ctts_count; i++)
sc->sample_offsets_count += sc->ctts_data[i].count;
av_freep(&sc->sample_offsets);
sc->sample_offsets = av_calloc(sc->sample_offsets_count, sizeof(*sc->sample_offsets));
if (!sc->sample_offsets)
return AVERROR(ENOMEM);
k = 0;
for (uint32_t i = 0; i < sc->ctts_count; i++)
for (int j = 0; j < sc->ctts_data[i].count; j++)
sc->sample_offsets[k++] = sc->ctts_data[i].duration;
cra_index = get_sgpd_sync_index(sc, HEVC_NAL_CRA_NUT);
if (!cra_index)
return 0;
sc->open_key_samples_count = 0;
for (uint32_t i = 0; i < sc->sync_group_count; i++)
if (sc->sync_group[i].index == cra_index)
sc->open_key_samples_count += sc->sync_group[i].count;
av_freep(&sc->open_key_samples);
sc->open_key_samples = av_calloc(sc->open_key_samples_count, sizeof(*sc->open_key_samples));
if (!sc->open_key_samples)
return AVERROR(ENOMEM);
k = 0;
for (uint32_t i = 0; i < sc->sync_group_count; i++) {
const MOVSbgp *sg = &sc->sync_group[i];
if (sg->index == cra_index)
for (uint32_t j = 0; j < sg->count; j++)
sc->open_key_samples[k++] = sample_id;
sample_id += sg->count;
}
sc->min_sample_duration = UINT_MAX;
for (uint32_t i = 0; i < sc->stts_count; i++)
sc->min_sample_duration = FFMIN(sc->min_sample_duration, sc->stts_data[i].duration);
return 0;
}","[10, 12, 25, 27, 37]",A heap out-of-bounds memory write exists in FFMPEG since version 5.1. The size calculation in `build_open_gop_key_points()` goes through all entries in the loop and adds `sc->ctts_data[i].count` to `sc->sample_offsets_count`. This can lead to an integer overflow resulting in a small allocation with `av_calloc()`. An attacker can cause remote code execution via a malicious mp4 file. We recommend upgrading past commit c953baa084607dd1d84c3bfcce3cf6a87c3e6e05,FFmpeg,CVE-2022-2566,CWE-190
7248,4349,"void RemoteFsDevice::mount()
{
if (details.isLocalFile()) {
return;
}
if (isConnected() || proc) {
return;
}
if (messageSent) {
return;
}
if (constSambaAvahiProtocol==details.url.scheme()) {
Details det=details;
AvahiService *srv=Avahi::self()->getService(det.serviceName);
if (!srv || srv->getHost().isEmpty() || 0==srv->getPort()) {
emit error(tr(""Failed to resolve connection details for %1"").arg(details.name));
return;
}
if (constPromptPassword==det.url.password()) {
bool ok=false;
QString passwd=InputDialog::getPassword(QString(), &ok, QApplication::activeWindow());
if (!ok) {
return;
}
det.url.setPassword(passwd);
}
det.url.setScheme(constSambaProtocol);
det.url.setHost(srv->getHost());
det.url.setPort(srv->getPort());
mounter()->mount(det.url.toString(), mountPoint(details, true), getuid(), getgid(), getpid());
setStatusMessage(tr(""Connecting...""));
messageSent=true;
return;
}
if (constSambaProtocol==details.url.scheme()) {
Details det=details;
if (constPromptPassword==det.url.password()) {
bool ok=false;
QString passwd=InputDialog::getPassword(QString(), &ok, QApplication::activeWindow());
if (!ok) {
return;
}
det.url.setPassword(passwd);
}
mounter()->mount(det.url.toString(), mountPoint(details, true), getuid(), getgid(), getpid());
setStatusMessage(tr(""Connecting...""));
messageSent=true;
return;
}
QString cmd;
QStringList args;
QString askPass;
if (!details.isLocalFile() && !details.isEmpty()) {
bool needAskPass=!details.extraOptions.contains(""IdentityFile="");
if (needAskPass) {
QStringList askPassList;
if (Utils::KDE==Utils::currentDe()) {
askPassList << QLatin1String(""ksshaskpass"") << QLatin1String(""ssh-askpass"") << QLatin1String(""ssh-askpass-gnome"");
} else {
askPassList << QLatin1String(""ssh-askpass-gnome"") << QLatin1String(""ssh-askpass"") << QLatin1String(""ksshaskpass"");
}
for (const QString &ap: askPassList) {
askPass=Utils::findExe(ap);
if (!askPass.isEmpty()) {
break;
}
}
if (askPass.isEmpty()) {
emit error(tr(""No suitable ssh-askpass application installed! This is required for entering passwords.""));
return;
}
}
QString sshfs=Utils::findExe(""sshfs"");
if (sshfs.isEmpty()) {
emit error(tr(""\""sshfs\"" is not installed!""));
return;
}
cmd=Utils::findExe(""setsid"");
if (!cmd.isEmpty()) {
QString mp=mountPoint(details, true);
if (mp.isEmpty()) {
emit error(""Failed to determine mount point"");
}
if (!QDir(mp).entryList(QDir::NoDot|QDir::NoDotDot|QDir::AllEntries|QDir::Hidden).isEmpty()) {
emit error(tr(""Mount point (\""%1\"") is not empty!"").arg(mp));
return;
}
args << sshfs << details.url.userName()+QChar('@')+details.url.host()+QChar(':')+details.url.path()<< QLatin1String(""-p"")
<< QString::number(details.url.port()) << mountPoint(details, true)
<< QLatin1String(""-o"") << QLatin1String(""ServerAliveInterval=15"");
if (!details.extraOptions.isEmpty()) {
args << details.extraOptions.split(' ', QString::SkipEmptyParts);
}
} else {
emit error(tr(""\""sshfs\"" is not installed!"").replace(""sshfs"", ""setsid""));
}
}
if (!cmd.isEmpty()) {
setStatusMessage(tr(""Connecting...""));
proc=new QProcess(this);
proc->setProperty(""mount"", true);
if (!askPass.isEmpty()) {
QProcessEnvironment env = QProcessEnvironment::systemEnvironment();
env.insert(""SSH_ASKPASS"", askPass);
proc->setProcessEnvironment(env);
}
connect(proc, SIGNAL(finished(int)), SLOT(procFinished(int)));
proc->start(cmd, args, QIODevice::ReadOnly);
}
}","[12, 13, 14, 15, 16, 17, 19, 20, 21, 22, 23, 25, 27, 28, 29, 30, 31, 32, 33, 35, 36, 37, 38, 39, 40, 41, 43, 45, 46, 47, 48]","An issue was discovered in the cantata-mounter D-Bus service in Cantata through 2.3.1. The mount target path check in mounter.cpp `mpOk()` is insufficient. A regular user can consequently mount a CIFS filesystem anywhere (e.g., outside of the /home directory tree) by passing directory traversal sequences such as a home/../usr substring.",cantata,CVE-2018-12559,CWE-22
7255,4345,"static inline bool isValid(const RemoteFsDevice::Details &d)
{
return d.isLocalFile() || RemoteFsDevice::constSshfsProtocol==d.url.scheme() ||
RemoteFsDevice::constSambaProtocol==d.url.scheme() || RemoteFsDevice::constSambaAvahiProtocol==d.url.scheme();
}","[3, 4]","An issue was discovered in the cantata-mounter D-Bus service in Cantata through 2.3.1. The mount target path check in mounter.cpp `mpOk()` is insufficient. A regular user can consequently mount a CIFS filesystem anywhere (e.g., outside of the /home directory tree) by passing directory traversal sequences such as a home/../usr substring.",cantata,CVE-2018-12559,CWE-22
7259,8489,"GF_AV1Config *gf_odf_av1_cfg_read_bs_size(GF_BitStream *bs, u32 size)
{
#ifndef GPAC_DISABLE_AV_PARSERS
AV1State state;
u8 reserved;
GF_AV1Config *cfg;
if (!size) size = (u32) gf_bs_available(bs);
if (!size) return NULL;
cfg = gf_odf_av1_cfg_new();
gf_av1_init_state(&state);
state.config = cfg;
cfg->marker = gf_bs_read_int(bs, 1);
cfg->version = gf_bs_read_int(bs, 7);
cfg->seq_profile = gf_bs_read_int(bs, 3);
cfg->seq_level_idx_0 = gf_bs_read_int(bs, 5);
cfg->seq_tier_0 = gf_bs_read_int(bs, 1);
cfg->high_bitdepth = gf_bs_read_int(bs, 1);
cfg->twelve_bit = gf_bs_read_int(bs, 1);
cfg->monochrome = gf_bs_read_int(bs, 1);
cfg->chroma_subsampling_x = gf_bs_read_int(bs, 1);
cfg->chroma_subsampling_y = gf_bs_read_int(bs, 1);
cfg->chroma_sample_position = gf_bs_read_int(bs, 2);
reserved = gf_bs_read_int(bs, 3);
if (reserved != 0 || cfg->marker != 1 || cfg->version != 1) {
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[AV1] wrong avcC reserved %d / marker %d / version %d expecting 0 1 1\n"", reserved, cfg->marker, cfg->version));
gf_odf_av1_cfg_del(cfg);
return NULL;
}
cfg->initial_presentation_delay_present = gf_bs_read_int(bs, 1);
if (cfg->initial_presentation_delay_present) {
cfg->initial_presentation_delay_minus_one = gf_bs_read_int(bs, 4);
} else {
gf_bs_read_int(bs, 4);
cfg->initial_presentation_delay_minus_one = 0;
}
size -= 4;
while (size) {
u64 pos, obu_size;
ObuType obu_type;
GF_AV1_OBUArrayEntry *a;
pos = gf_bs_get_position(bs);
obu_size = 0;
if (gf_av1_parse_obu(bs, &obu_type, &obu_size, NULL, &state) != GF_OK) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[AV1] could not parse AV1 OBU at position ""LLU"". Leaving parsing.\n"", pos));
break;
}
assert(obu_size == gf_bs_get_position(bs) - pos);
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[AV1] parsed AV1 OBU type=%u size=""LLU"" at position ""LLU"".\n"", obu_type, obu_size, pos));
if (!av1_is_obu_header(obu_type)) {
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[AV1] AV1 unexpected OBU type=%u size=""LLU"" found at position ""LLU"". Forwarding.\n"", pos));
}
GF_SAFEALLOC(a, GF_AV1_OBUArrayEntry);
if (!a) break;
a->obu = gf_malloc((size_t)obu_size);
if (!a->obu) {
gf_free(a);
break;
}
gf_bs_seek(bs, pos);
gf_bs_read_data(bs, (char *) a->obu, (u32)obu_size);
a->obu_length = obu_size;
a->obu_type = obu_type;
gf_list_add(cfg->obu_array, a);
if (size<obu_size) {
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[AV1] AV1 config misses %d bytes to fit the entire OBU\n"", obu_size - size));
break;
}
size -= (u32) obu_size;
}
gf_av1_reset_state(& state, GF_TRUE);
return cfg;
#else
return NULL;
#endif
}",[71],"The binary MP4Box in Gpac 1.0.1 has a double-free vulnerability in the ilst_box_read function in box_code_apple.c, which allows attackers to cause a denial of service, even code execution and escalation of privileges.",gpac,CVE-2021-40571,CWE-415
7270,9855,"void SFS_Params(ScriptParser *parser)
{
u32 val;
if (parser->codec->LastError) return;
val = gf_bs_read_int(parser->bs, 1);
while (val) {
SFS_Expression(parser);
val = gf_bs_read_int(parser->bs, 1);
if(val) SFS_AddString(parser, "","");
}
}",[8],Uncontrolled Recursion in GitHub repository gpac/gpac prior to 2.1.0-DEV.,gpac,CVE-2022-3222,CWE-674
7288,8049,"static GF_Err gf_media_export_filters(GF_MediaExporter *dumper)
{
char *args, szSubArgs[1024], szExt[30];
GF_Filter *file_out, *reframer, *remux=NULL, *src_filter;
GF_FilterSession *fsess;
GF_Err e = GF_OK;
u32 codec_id=0;
u32 sample_count=0;
Bool skip_write_filter = GF_FALSE;
Bool ext_forced = GF_FALSE;
Bool use_dynext = GF_FALSE;
args = NULL;
strcpy(szExt, """");
if (dumper->trackID && dumper->file) {
u32 msubtype = 0;
u32 mtype = 0;
u32 afmt = 0;
GF_PixelFormat pfmt = 0;
GF_ESD *esd;
const char *export_ext = dumper->out_name ? gf_file_ext_start(dumper->out_name) : NULL;
u32 track_num = gf_isom_get_track_by_id(dumper->file, dumper->trackID);
if (!track_num) {
GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (""[Exporter] No tracks with ID %d in file\n"", dumper->trackID));
return GF_BAD_PARAM;
}
esd = gf_media_map_esd(dumper->file, track_num, 0);
sample_count = gf_isom_get_sample_count(dumper->file, dumper->trackID);
if (esd) {
if (esd->decoderConfig->objectTypeIndication<GF_CODECID_LAST_MPEG4_MAPPING) {
codec_id = gf_codecid_from_oti(esd->decoderConfig->streamType, esd->decoderConfig->objectTypeIndication);
#ifndef GPAC_DISABLE_AV_PARSERS
if (esd->decoderConfig->decoderSpecificInfo && (codec_id==GF_CODECID_AAC_MPEG4)) {
GF_M4ADecSpecInfo acfg;
gf_m4a_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &acfg);
if (acfg.base_object_type == GF_M4A_USAC)
codec_id = GF_CODECID_USAC;
}
#endif
} else {
codec_id = esd->decoderConfig->objectTypeIndication;
}
}
if (!codec_id) {
msubtype = gf_isom_get_media_subtype(dumper->file, track_num, 1);
codec_id = gf_codec_id_from_isobmf(msubtype);
}
mtype = gf_isom_get_media_type(dumper->file, track_num);
if (!codec_id) {
pfmt = gf_pixel_fmt_from_qt_type(msubtype);
if (pfmt) codec_id = GF_CODECID_RAW;
}
if (!codec_id) {
strcpy(szExt, gf_4cc_to_str(msubtype));
ext_forced = GF_TRUE;
} else if (codec_id==GF_CODECID_RAW) {
switch (mtype) {
case GF_ISOM_MEDIA_VISUAL:
case GF_ISOM_MEDIA_AUXV:
case GF_ISOM_MEDIA_PICT:
if (pfmt)
strcpy(szExt, gf_pixel_fmt_sname(pfmt));
break;
case GF_ISOM_MEDIA_AUDIO:
afmt = gf_audio_fmt_from_isobmf(msubtype);
if (afmt)
strcpy(szExt, gf_audio_fmt_name(afmt));
break;
default:
strcpy(szExt, gf_4cc_to_str(msubtype));
break;
}
} else {
const char *sname = gf_codecid_file_ext(codec_id);
if (export_ext && strstr(sname, export_ext+1)) {
szExt[0]=0;
} else {
char *sep;
strncpy(szExt, sname, 29);
szExt[29]=0;
sep = strchr(szExt, '|');
if (sep) sep[0] = 0;
}
}
switch (mtype) {
case GF_ISOM_MEDIA_VISUAL:
case GF_ISOM_MEDIA_AUXV:
case GF_ISOM_MEDIA_PICT:
case GF_ISOM_MEDIA_AUDIO:
skip_write_filter = codec_id ? GF_TRUE : GF_FALSE;
break;
default:
switch (codec_id) {
case GF_CODECID_WEBVTT:
skip_write_filter = GF_TRUE;
break;
case GF_CODECID_META_TEXT:
case GF_CODECID_META_XML:
case GF_CODECID_SUBS_TEXT:
case GF_CODECID_SUBS_XML:
case GF_CODECID_SIMPLE_TEXT:
szExt[0] = 0;
use_dynext = GF_TRUE;
break;
}
break;
}
if ((codec_id==GF_CODECID_VORBIS) || (codec_id==GF_CODECID_THEORA) || (codec_id==GF_CODECID_OPUS)) {
char *outname = dumper->out_name;
if (outname && !strcmp(outname, ""std"")) outname=NULL;
if (esd) gf_odf_desc_del((GF_Descriptor *) esd);
#ifndef GPAC_DISABLE_AV_PARSERS
return gf_dump_to_ogg(dumper, outname, track_num);
#else
return GF_NOT_SUPPORTED;
#endif
}
if (codec_id==GF_CODECID_SUBPIC) {
#ifndef GPAC_DISABLE_AV_PARSERS
char *dsi = NULL;
u32 dsi_size = 0;
if (esd && esd->decoderConfig && esd->decoderConfig->decoderSpecificInfo) {
dsi = esd->decoderConfig->decoderSpecificInfo->data;
dsi_size = esd->decoderConfig->decoderSpecificInfo->dataLength;
}
e = gf_dump_to_vobsub(dumper, dumper->out_name, track_num, dsi, dsi_size);
#else
e = GF_NOT_SUPPORTED;
#endif
if (esd) gf_odf_desc_del((GF_Descriptor *) esd);
return e;
}
if (esd) gf_odf_desc_del((GF_Descriptor *) esd);
} else {
const char *export_ext = dumper->out_name ? gf_file_ext_start(dumper->out_name) : NULL;
skip_write_filter = GF_TRUE;
if (!export_ext)
use_dynext = GF_TRUE;
}
fsess = gf_fs_new_defaults(0);
if (!fsess) {
GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (""[Exporter] Failed to create filter session\n""));
return GF_OUT_OF_MEM;
}
file_out = NULL;
args = NULL;
if (dumper->flags & GF_EXPORT_REMUX) {
file_out = gf_fs_load_destination(fsess, dumper->out_name, NULL, NULL, &e);
if (!file_out) {
gf_fs_del(fsess);
GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (""[Exporter] Cannot open destination %s\n"", dumper->out_name));
return e;
}
}
else if (!dumper->dump_file) {
Bool no_ext = (dumper->flags & GF_EXPORT_NO_FILE_EXT) ? GF_TRUE : GF_FALSE;
char *ext = gf_file_ext_start(dumper->out_name);
e = gf_dynstrcat(&args, ""fout:dst="", NULL);
e |= gf_dynstrcat(&args, dumper->out_name, NULL);
if (dumper->flags & GF_EXPORT_NHNT) {
strcpy(szExt, ""nhnt"");
e |= gf_dynstrcat(&args, "":clone"", NULL);
no_ext = GF_TRUE;
if (!ext)
e |= gf_dynstrcat(&args, "":dynext"", NULL);
} else if (dumper->flags & GF_EXPORT_NHML) {
strcpy(szExt, ""nhml"");
e |= gf_dynstrcat(&args, "":clone"", NULL);
no_ext = GF_TRUE;
if (!ext)
e |= gf_dynstrcat(&args, "":dynext"", NULL);
}
if (dumper->flags & GF_EXPORT_RAW_SAMPLES) {
if (!dumper->sample_num) {
ext = gf_file_ext_start(args);
if (ext) ext[0] = 0;
if (sample_count>=1000) {
e |= gf_dynstrcat(&args, ""_$num%08d$"", NULL);
} else if (sample_count) {
e |= gf_dynstrcat(&args, ""_$num%03d$"", NULL);
} else {
e |= gf_dynstrcat(&args, ""_$num$"", NULL);
}
ext = gf_file_ext_start(dumper->out_name);
if (ext) e |= gf_dynstrcat(&args, ext, NULL);
}
e |= gf_dynstrcat(&args, "":dynext"", NULL);
} else if (dumper->trackID && strlen(szExt) ) {
if (!no_ext && !gf_file_ext_start(dumper->out_name)) {
if (args) gf_free(args);
args=NULL;
e = gf_dynstrcat(&args, ""fout:dst="", NULL);
e |= gf_dynstrcat(&args, dumper->out_name, NULL);
e |= gf_dynstrcat(&args, szExt, ""."");
} else {
e |= gf_dynstrcat(&args, "":ext="", NULL);
e |= gf_dynstrcat(&args, szExt, NULL);
}
} else if ((dumper->trackID || dumper->track_type) && use_dynext) {
e |= gf_dynstrcat(&args, "":dynext"", NULL);
}
if (e) {
GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (""[Exporter] Cannot load arguments for output file dumper\n""));
if (args) gf_free(args);
gf_fs_del(fsess);
return e;
}
file_out = gf_fs_load_filter(fsess, args, &e);
if (!file_out) {
gf_fs_del(fsess);
if (args) gf_free(args);
GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (""[Exporter] Cannot load output file dumper\n""));
return e;
}
}
if (args) gf_free(args);
args = NULL;
if (dumper->flags & GF_EXPORT_RAW_SAMPLES) {
e = gf_dynstrcat(&args, ""writegen:frame"", NULL);
if (dumper->sample_num) {
sprintf(szSubArgs, "":sstart=%d:send=%d"", dumper->sample_num, dumper->sample_num);
e |= gf_dynstrcat(&args, szSubArgs, NULL);
}
remux = e ? NULL : gf_fs_load_filter(fsess, args, &e);
if (!remux || e) {
gf_fs_del(fsess);
GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (""[Exporter] Cannot load stream->file filter\n""));
if (args) gf_free(args);
return e ? e : GF_FILTER_NOT_FOUND;
}
}
else if (dumper->flags & GF_EXPORT_NHNT) {
remux = gf_fs_load_filter(fsess, ""nhntw:exporter"", &e);
if (!remux) {
gf_fs_del(fsess);
GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (""[Exporter] Cannot load NHNT write filter\n""));
return e;
}
}
else if (dumper->flags & GF_EXPORT_NHML) {
e = gf_dynstrcat(&args, ""nhmlw:exporter:name="", NULL);
e |= gf_dynstrcat(&args, dumper->out_name, NULL);
if (dumper->flags & GF_EXPORT_NHML_FULL)
e |= gf_dynstrcat(&args, "":pckp"", NULL);
if (dumper->dump_file) {
sprintf(szSubArgs, "":nhmlonly:filep=%p"", dumper->dump_file);
e |= gf_dynstrcat(&args, szSubArgs, NULL);
}
remux = e ? NULL : gf_fs_load_filter(fsess, args, &e);
if (!remux || e) {
gf_fs_del(fsess);
if (args) gf_free(args);
GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (""[Exporter] Cannot load NHML write filter\n""));
return e ? e : GF_FILTER_NOT_FOUND;
}
} else if (!skip_write_filter) {
e = gf_dynstrcat(&args, ""writegen:exporter"", NULL);
if (ext_forced) {
e |= gf_dynstrcat(&args, "":#Extension="", NULL);
e |= gf_dynstrcat(&args, szExt, NULL);
}
remux = e ? NULL : gf_fs_load_filter(fsess, args, &e);
if (!remux) {
gf_fs_del(fsess);
if (args) gf_free(args);
GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (""[Exporter] Cannot load stream->file filter\n""));
return e;
}
}
if (args) gf_free(args);
args = NULL;
e = gf_dynstrcat(&args, ""reframer:SID=1"", NULL);
if (dumper->trackID) {
sprintf(szSubArgs, ""#PID=%d"", dumper->trackID);
e |= gf_dynstrcat(&args, szSubArgs, NULL);
}
e |= gf_dynstrcat(&args, "":exporter"", NULL);
if (dumper->flags & GF_EXPORT_SVC_LAYER)
e |= gf_dynstrcat(&args, "":extract=layer"", NULL);
if (dumper->flags & GF_EXPORT_WEBVTT_NOMERGE)
e |= gf_dynstrcat(&args, "":merge"", NULL);
reframer = gf_fs_load_filter(fsess, args, &e);
if (!reframer || e) {
gf_fs_del(fsess);
if (args) gf_free(args);
GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (""[Exporter] Cannot load reframer filter\n""));
return e ? e : GF_FILTER_NOT_FOUND;
}
if (args) gf_free(args);
args = NULL;
if (dumper->file) {
e = gf_dynstrcat(&args, ""mp4dmx:FID=1:noedit:alltk:allt"", NULL);
if (!e) {
sprintf(szSubArgs, "":mov=%p"", dumper->file);
e = gf_dynstrcat(&args, szSubArgs, NULL);
}
src_filter = gf_fs_load_filter(fsess, args, &e);
gf_free(args);
args = NULL;
} else {
src_filter = gf_fs_load_source(fsess, dumper->in_name, ""FID=1:noedit:alltk:allt"", NULL, &e);
}
if (!src_filter || e) {
gf_fs_del(fsess);
GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (""[Exporter] Cannot load filter for input file \""%s\"": %s\n"", dumper->in_name, gf_error_to_string(e) ));
return e;
}
if (dumper->track_type) {
const char *mtype = (dumper->track_type==1) ? ""video"" : ""audio"";
if (dumper->trackID) {
sprintf(szSubArgs, ""%s%d"", mtype, dumper->trackID);
} else {
sprintf(szSubArgs, ""%s"", mtype);
}
}
else if (dumper->trackID) {
sprintf(szSubArgs, ""PID=%d"", dumper->trackID);
}
if (remux) {
gf_filter_set_source(file_out, remux, (dumper->trackID || dumper->track_type) ? szSubArgs : NULL);
gf_filter_set_source(remux, reframer, (dumper->trackID || dumper->track_type) ? szSubArgs : NULL);
} else {
gf_filter_set_source(file_out, reframer, (dumper->trackID || dumper->track_type) ? szSubArgs : NULL);
}
e = gf_fs_run(fsess);
if (e>GF_OK) e = GF_OK;
if (!e) e = gf_fs_get_last_connect_error(fsess);
if (!e) e = gf_fs_get_last_process_error(fsess);
if (!e) {
if (dumper->file)
gf_fs_print_unused_args(fsess, NULL);
else
gf_fs_print_unused_args(fsess, ""alltk,allt,noedit"");
}
gf_fs_print_non_connected(fsess);
if (dumper->print_stats_graph & 1) gf_fs_print_stats(fsess);
if (dumper->print_stats_graph & 2) gf_fs_print_connections(fsess);
gf_fs_del(fsess);
return e;
}",[28],The gf_media_export_filters function in GPAC 1.0.1 allows attackers to cause a denial of service (NULL pointer dereference) via a crafted file in the MP4Box command.,gpac,CVE-2021-32438,CWE-476
7297,7962,"static s32 gf_hevc_read_vps_bs_internal(GF_BitStream *bs, HEVCState *hevc, Bool stop_at_vps_ext)
{
u8 vps_sub_layer_ordering_info_present_flag, vps_extension_flag;
u32 i, j;
s32 vps_id;
HEVC_VPS *vps;
u8 layer_id_included_flag[MAX_LHVC_LAYERS][64];
vps_id = gf_bs_read_int_log(bs, 4, ""vps_id"");
if (vps_id >= 16) return -1;
vps = &hevc->vps[vps_id];
vps->bit_pos_vps_extensions = -1;
if (!vps->state) {
vps->id = vps_id;
vps->state = 1;
}
vps->base_layer_internal_flag = gf_bs_read_int_log(bs, 1, ""base_layer_internal_flag"");
vps->base_layer_available_flag = gf_bs_read_int_log(bs, 1, ""base_layer_available_flag"");
vps->max_layers = 1 + gf_bs_read_int_log(bs, 6, ""max_layers_minus1"");
if (vps->max_layers > MAX_LHVC_LAYERS) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[HEVC] sorry, %d layers in VPS but only %d supported\n"", vps->max_layers, MAX_LHVC_LAYERS));
return -1;
}
vps->max_sub_layers = gf_bs_read_int_log(bs, 3, ""max_sub_layers_minus1"") + 1;
vps->temporal_id_nesting = gf_bs_read_int_log(bs, 1, ""temporal_id_nesting"");
gf_bs_read_int_log(bs, 16, ""vps_reserved_ffff_16bits"");
hevc_profile_tier_level(bs, 1, vps->max_sub_layers - 1, &vps->ptl, 0);
vps_sub_layer_ordering_info_present_flag = gf_bs_read_int_log(bs, 1, ""vps_sub_layer_ordering_info_present_flag"");
for (i = (vps_sub_layer_ordering_info_present_flag ? 0 : vps->max_sub_layers - 1); i < vps->max_sub_layers; i++) {
gf_bs_read_ue_log_idx(bs, ""vps_max_dec_pic_buffering_minus1"", i);
gf_bs_read_ue_log_idx(bs, ""vps_max_num_reorder_pics"", i);
gf_bs_read_ue_log_idx(bs, ""vps_max_latency_increase_plus1"", i);
}
vps->max_layer_id = gf_bs_read_int_log(bs, 6, ""max_layer_id"");
if (vps->max_layer_id > MAX_LHVC_LAYERS) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[HEVC] VPS max layer ID %u but GPAC only supports %u\n"", vps->max_layer_id, MAX_LHVC_LAYERS));
return -1;
}
vps->num_layer_sets = gf_bs_read_ue_log(bs, ""num_layer_sets_minus1"") + 1;
if (vps->num_layer_sets > MAX_LHVC_LAYERS) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[HEVC] Wrong number of layer sets in VPS %d\n"", vps->num_layer_sets));
return -1;
}
for (i = 1; i < vps->num_layer_sets; i++) {
for (j = 0; j <= vps->max_layer_id; j++) {
layer_id_included_flag[i][j] = gf_bs_read_int_log_idx2(bs, 1, ""layer_id_included_flag"", i, j);
}
}
vps->num_layers_in_id_list[0] = 1;
for (i = 1; i < vps->num_layer_sets; i++) {
u32 n, m;
n = 0;
for (m = 0; m <= vps->max_layer_id; m++) {
if (layer_id_included_flag[i][m]) {
vps->LayerSetLayerIdList[i][n++] = m;
if (vps->LayerSetLayerIdListMax[i] < m)
vps->LayerSetLayerIdListMax[i] = m;
}
}
vps->num_layers_in_id_list[i] = n;
}
if (gf_bs_read_int_log(bs, 1, ""vps_timing_info_present_flag"")) {
u32 vps_num_hrd_parameters;
gf_bs_read_int_log(bs, 32, ""vps_num_units_in_tick"");
gf_bs_read_int_log(bs, 32, ""vps_time_scale"");
if (gf_bs_read_int_log(bs, 1, ""vps_poc_proportional_to_timing_flag"")) {
gf_bs_read_ue_log(bs, ""vps_num_ticks_poc_diff_one_minus1"");
}
vps_num_hrd_parameters = gf_bs_read_ue_log(bs, ""vps_num_hrd_parameters"");
for (i = 0; i < vps_num_hrd_parameters; i++) {
Bool cprms_present_flag = GF_TRUE;
gf_bs_read_ue_log_idx(bs, ""hrd_layer_set_idx"", i);
if (i > 0)
cprms_present_flag = gf_bs_read_int_log(bs, 1, ""cprms_present_flag"");
hevc_parse_hrd_parameters(bs, cprms_present_flag, vps->max_sub_layers - 1, i);
}
}
if (stop_at_vps_ext) {
return vps_id;
}
vps_extension_flag = gf_bs_read_int_log(bs, 1, ""vps_extension_flag"");
if (vps_extension_flag) {
Bool res;
gf_bs_align(bs);
res = hevc_parse_vps_extension(vps, bs);
if (res != GF_TRUE) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[HEVC] Failed to parse VPS extensions\n""));
return -1;
}
if (gf_bs_read_int_log(bs, 1, ""vps_extension2_flag"")) {
#if 0
while (gf_bs_available(bs)) {
gf_bs_read_int(bs, 1);
}
#endif
}
}
return vps_id;
}",[9],There is a integer overflow in media_tools/av_parsers.c in the hevc_parse_slice_segment function in GPAC 1.0.1 which results in a crash.,gpac,CVE-2021-30014,CWE-190
7310,7790,"void TRI_InitV8ServerUtils(v8::Isolate* isolate) {
TRI_AddGlobalFunctionVocbase(isolate,
TRI_V8_ASCII_STRING(isolate, ""SYS_CLUSTER_API_JWT_POLICY""), JS_ClusterApiJwtPolicy, true);
TRI_AddGlobalFunctionVocbase(isolate,
TRI_V8_ASCII_STRING(isolate, ""SYS_IS_FOXX_API_DISABLED""), JS_IsFoxxApiDisabled, true);
TRI_AddGlobalFunctionVocbase(isolate,
TRI_V8_ASCII_STRING(isolate, ""SYS_IS_FOXX_STORE_DISABLED""), JS_IsFoxxStoreDisabled, true);
TRI_AddGlobalFunctionVocbase(isolate,
TRI_V8_ASCII_STRING(isolate, ""SYS_RUN_IN_RESTRICTED_CONTEXT""), JS_RunInRestrictedContext, true);
TRI_AddGlobalFunctionVocbase(isolate,
TRI_V8_ASCII_STRING(isolate,
""SYS_CREATE_HOTBACKUP""),
JS_CreateHotbackup);
TRI_AddGlobalFunctionVocbase(isolate,
TRI_V8_ASCII_STRING(isolate,
""SYS_DEBUG_CLEAR_FAILAT""),
JS_DebugClearFailAt);
#ifdef ARANGODB_ENABLE_FAILURE_TESTS
TRI_AddGlobalFunctionVocbase(
isolate, TRI_V8_ASCII_STRING(isolate, ""SYS_DEBUG_TERMINATE""), JS_DebugTerminate);
TRI_AddGlobalFunctionVocbase(isolate,
TRI_V8_ASCII_STRING(isolate,
""SYS_DEBUG_SET_FAILAT""),
JS_DebugSetFailAt);
TRI_AddGlobalFunctionVocbase(isolate,
TRI_V8_ASCII_STRING(isolate,
""SYS_DEBUG_REMOVE_FAILAT""),
JS_DebugRemoveFailAt);
TRI_AddGlobalFunctionVocbase(isolate,
TRI_V8_ASCII_STRING(isolate,
""SYS_DEBUG_SHOULD_FAILAT""),
JS_DebugShouldFailAt);
#endif
TRI_GET_GLOBALS();
FoxxFeature& foxxFeature = v8g->_server.getFeature<FoxxFeature>();
isolate->GetCurrentContext()
->Global()
->DefineOwnProperty(
TRI_IGETC, TRI_V8_ASCII_STRING(isolate, ""FOXX_QUEUES_POLL_INTERVAL""),
v8::Number::New(isolate, foxxFeature.pollInterval()), v8::ReadOnly)
.FromMaybe(false);
isolate->GetCurrentContext()
->Global()
->DefineOwnProperty(
TRI_IGETC,
TRI_V8_ASCII_STRING(isolate, ""FOXX_STARTUP_WAIT_FOR_SELF_HEAL""),
v8::Boolean::New(isolate, foxxFeature.startupWaitForSelfHeal()), v8::ReadOnly)
.FromMaybe(false);
}",[8],"In ArangoDB, versions v3.7.0 through v3.9.0-alpha.1 have a feature which allows downloading a Foxx service from a publicly available URL. This feature does not enforce proper filtering of requests performed internally, which can be abused by a highly-privileged attacker to perform blind SSRF and send internal requests to localhost.",arangodb,CVE-2021-25939,CWE-918
7311,9178,"static int get_prop(int fd, uint32_t client_id, const char *name, void **value, size_t *size) {
size_t msg_size = sizeof(struct vbg_ioctl_hgcm_call) + 4 * sizeof(struct vmmdev_hgcm_function_parameter64);
struct vbg_ioctl_hgcm_call _cleanup_free_ *msg = calloc(1, msg_size);
init_header(&msg->hdr, msg_size - sizeof(msg->hdr), msg_size - sizeof(msg->hdr));
msg->client_id = client_id;
msg->function = 1;
msg->timeout_ms = -1;
msg->interruptible = 1;
msg->parm_count = 4;
char ch;
struct vmmdev_hgcm_function_parameter64 *params = (void *) (msg + 1);
params[0].type = VMMDEV_HGCM_PARM_TYPE_LINADDR_IN;
params[0].u.pointer.size = strlen(name) + 1;
params[0].u.pointer.u.linear_addr = (uintptr_t) name;
params[1].type = VMMDEV_HGCM_PARM_TYPE_LINADDR;
params[1].u.pointer.size = 1;
params[1].u.pointer.u.linear_addr = (uintptr_t) &ch;
params[2].type = VMMDEV_HGCM_PARM_TYPE_64BIT;
params[3].type = VMMDEV_HGCM_PARM_TYPE_32BIT;
if (ioctl(fd, VBG_IOCTL_HGCM_CALL_64(msg_size), msg)) {
return VERR_GENERAL_FAILURE;
}
switch (msg->hdr.rc) {
case VINF_SUCCESS:
case VERR_BUFFER_OVERFLOW:
;
size_t buf_size = params[3].u.value32;
void _cleanup_free_ *buf = malloc(buf_size);
params[1].u.pointer.size = buf_size;
params[1].u.pointer.u.linear_addr = (uintptr_t) buf;
if (ioctl(fd, VBG_IOCTL_HGCM_CALL_64(msg_size), msg)) {
return VERR_GENERAL_FAILURE;
}
if (msg->hdr.rc != VINF_SUCCESS) {
return msg->hdr.rc;
}
*value = buf;
buf = NULL;
*size = buf_size;
return VINF_SUCCESS;
case VERR_NOT_FOUND:
*value = NULL;
*size = 0;
return VINF_SUCCESS;
default:
return msg->hdr.rc;
}
}",[6],A vulnerability was found in Ignition where ignition configs are accessible from unprivileged containers in VMs running on VMware products. This issue is only relevant in user environments where the Ignition config contains secrets. The highest threat from this vulnerability is to data confidentiality. Possible workaround is to not put secrets in the Ignition config.,ignition,CVE-2022-1706,CWE-863
7325,6353,"exif_mnote_data_pentax_load (ExifMnoteData *en,
const unsigned char *buf, unsigned int buf_size)
{
ExifMnoteDataPentax *n = (ExifMnoteDataPentax *) en;
size_t i, tcount, o, datao, base = 0;
ExifShort c;
if (!n || !buf || !buf_size) {
exif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,
""ExifMnoteDataPentax"", ""Short MakerNote"");
return;
}
datao = 6 + n->offset;
if (CHECKOVERFLOW(datao, buf_size, 8)) {
exif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,
""ExifMnoteDataPentax"", ""Short MakerNote"");
return;
}
if (!memcmp(buf + datao, ""AOC"", 4)) {
if ((buf[datao + 4] == 'I') && (buf[datao + 5] == 'I')) {
n->version = pentaxV3;
n->order = EXIF_BYTE_ORDER_INTEL;
} else if ((buf[datao + 4] == 'M') && (buf[datao + 5] == 'M')) {
n->version = pentaxV3;
n->order = EXIF_BYTE_ORDER_MOTOROLA;
} else {
n->version = pentaxV2;
}
exif_log (en->log, EXIF_LOG_CODE_DEBUG, ""ExifMnoteDataPentax"",
""Parsing Pentax maker note v%d..."", (int)n->version);
datao += 4 + 2;
base = MNOTE_PENTAX2_TAG_BASE;
} else if (!memcmp(buf + datao, ""QVC"", 4)) {
exif_log (en->log, EXIF_LOG_CODE_DEBUG, ""ExifMnoteDataPentax"",
""Parsing Casio maker note v2..."");
n->version = casioV2;
base = MNOTE_CASIO2_TAG_BASE;
datao += 4 + 2;
} else {
exif_log (en->log, EXIF_LOG_CODE_DEBUG, ""ExifMnoteDataPentax"",
""Parsing Pentax maker note v1..."");
n->version = pentaxV1;
}
c = exif_get_short (buf + datao, n->order);
datao += 2;
exif_mnote_data_pentax_clear (n);
n->entries = exif_mem_alloc (en->mem, sizeof (MnotePentaxEntry) * c);
if (!n->entries) {
EXIF_LOG_NO_MEMORY(en->log, ""ExifMnoteDataPentax"", sizeof (MnotePentaxEntry) * c);
return;
}
tcount = 0;
for (i = c, o = datao; i; --i, o += 12) {
size_t s;
if (CHECKOVERFLOW(o,buf_size,12)) {
exif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,
""ExifMnoteDataPentax"", ""Short MakerNote"");
break;
}
n->entries[tcount].tag        = exif_get_short (buf + o + 0, n->order) + base;
n->entries[tcount].format     = exif_get_short (buf + o + 2, n->order);
n->entries[tcount].components = exif_get_long  (buf + o + 4, n->order);
n->entries[tcount].order      = n->order;
exif_log (en->log, EXIF_LOG_CODE_DEBUG, ""ExifMnotePentax"",
""Loading entry 0x%x ('%s')..."", n->entries[tcount].tag,
mnote_pentax_tag_get_name (n->entries[tcount].tag));
if ( exif_format_get_size (n->entries[tcount].format) &&
buf_size / exif_format_get_size (n->entries[tcount].format) < n->entries[tcount].components
) {
exif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,
""ExifMnoteDataPentax"", ""Tag size overflow detected (%u * %lu)"", exif_format_get_size (n->entries[tcount].format), n->entries[tcount].components);
break;
}
s = exif_format_get_size (n->entries[tcount].format) *
n->entries[tcount].components;
n->entries[tcount].size = s;
if (s) {
size_t dataofs = o + 8;
if (s > 4)
dataofs = exif_get_long (buf + dataofs, n->order) + 6;
if (CHECKOVERFLOW(dataofs, buf_size, s)) {
exif_log (en->log, EXIF_LOG_CODE_DEBUG,
""ExifMnoteDataPentax"", ""Tag data past end ""
""of buffer (%u > %u)"", (unsigned)(dataofs + s), buf_size);
continue;
}
n->entries[tcount].data = exif_mem_alloc (en->mem, s);
if (!n->entries[tcount].data) {
EXIF_LOG_NO_MEMORY(en->log, ""ExifMnoteDataPentax"", s);
continue;
}
memcpy (n->entries[tcount].data, buf + dataofs, s);
}
++tcount;
}
n->count = tcount;
}",[54],An issue was discovered in libexif before 0.6.22. Use of uninitialized memory in EXIF Makernote handling could lead to crashes and potential use-after-free conditions.,libexif,CVE-2020-13113,CWE-908
7329,8476,"void dostor(char *name, const int append, const int autorename)
{
ULHandler ulhandler;
int f;
const char *ul_name = NULL;
const char *atomic_file = NULL;
off_t filesize = (off_t) 0U;
struct stat st;
double started = 0.0;
signed char overwrite = 0;
int overflow = 0;
int ret = -1;
off_t max_filesize = (off_t) -1;
#ifdef QUOTAS
Quota quota;
#endif
const char *name2 = NULL;
if (type < 1 || (type == 1 && restartat > (off_t) 1)) {
addreply_noformat(503, MSG_NO_ASCII_RESUME);
goto end;
}
#ifndef ANON_CAN_RESUME
if (guest != 0 && anon_noupload != 0) {
addreply_noformat(550, MSG_ANON_CANT_OVERWRITE);
goto end;
}
#endif
if (ul_check_free_space(name, -1.0) == 0) {
addreply_noformat(552, MSG_NO_DISK_SPACE);
goto end;
}
if (checknamesanity(name, dot_write_ok) != 0) {
addreply(553, MSG_SANITY_FILE_FAILURE, name);
goto end;
}
if (autorename != 0) {
no_truncate = 1;
}
if (restartat > (off_t) 0 || no_truncate != 0) {
if ((atomic_file = get_atomic_file(name)) == NULL) {
addreply(553, MSG_SANITY_FILE_FAILURE, name);
goto end;
}
if (restartat > (off_t) 0 &&
rename(name, atomic_file) != 0 && errno != ENOENT) {
error(553, MSG_RENAME_FAILURE);
atomic_file = NULL;
goto end;
}
}
if (atomic_file != NULL) {
ul_name = atomic_file;
} else {
ul_name = name;
}
if (atomic_file == NULL &&
(f = open(ul_name, O_WRONLY | O_NOFOLLOW)) != -1) {
overwrite++;
} else if ((f = open(ul_name, O_CREAT | O_WRONLY | O_NOFOLLOW,
(mode_t) 0777 & ~u_mask)) == -1) {
error(553, MSG_OPEN_FAILURE2);
goto end;
}
if (fstat(f, &st) < 0) {
(void) close(f);
error(553, MSG_STAT_FAILURE2);
goto end;
}
if (!S_ISREG(st.st_mode)) {
(void) close(f);
addreply_noformat(550, MSG_NOT_REGULAR_FILE);
goto end;
}
alarm(MAX_SESSION_XFER_IDLE);
if (st.st_size > (off_t) 0) {
#ifndef ANON_CAN_RESUME
if (guest != 0) {
addreply_noformat(550, MSG_ANON_CANT_OVERWRITE);
(void) close(f);
goto end;
}
#endif
if (append != 0) {
restartat = st.st_size;
}
} else {
restartat = (off_t) 0;
}
if (restartat > st.st_size) {
restartat = st.st_size;
}
if (restartat > (off_t) 0 && lseek(f, restartat, SEEK_SET) < (off_t) 0) {
(void) close(f);
error(451, ""seek"");
goto end;
}
if (restartat < st.st_size) {
if (ftruncate(f, restartat) < 0) {
(void) close(f);
error(451, ""ftruncate"");
goto end;
}
#ifdef QUOTAS
if (restartat != st.st_size) {
(void) quota_update(NULL, 0LL,
(long long) (restartat - st.st_size),
&overflow);
}
#endif
}
#ifdef QUOTAS
if (quota_update(&quota, 0LL, 0LL, &overflow) == 0 &&
(overflow > 0 || quota.files >= user_quota_files ||
quota.size > user_quota_size ||
(max_filesize >= (off_t) 0 &&
(max_filesize = user_quota_size - quota.size) < (off_t) 0))) {
overflow = 1;
(void) close(f);
goto afterquota;
}
#endif
opendata();
if (xferfd == -1) {
(void) close(f);
goto end;
}
doreply();
# ifdef WITH_TLS
if (data_protection_level == CPL_PRIVATE) {
tls_init_data_session(xferfd, passive);
}
# endif
state_needs_update = 1;
setprocessname(""pure-ftpd (UPLOAD)"");
filesize = restartat;
#ifdef FTPWHO
if (shm_data_cur != NULL) {
const size_t sl = strlen(name);
ftpwho_lock();
shm_data_cur->state = FTPWHO_STATE_UPLOAD;
shm_data_cur->download_total_size = (off_t) 0U;
shm_data_cur->download_current_size = (off_t) filesize;
shm_data_cur->restartat = restartat;
(void) time(&shm_data_cur->xfer_date);
if (sl < sizeof shm_data_cur->filename) {
memcpy(shm_data_cur->filename, name, sl);
shm_data_cur->filename[sl] = 0;
} else {
memcpy(shm_data_cur->filename,
&name[sl - sizeof shm_data_cur->filename - 1U],
sizeof shm_data_cur->filename);
}
ftpwho_unlock();
}
#endif
started = get_usec_time();
if (ul_init(&ulhandler, clientfd, tls_cnx, xferfd, name, f, tls_data_cnx,
restartat, type == 1, throttling_bandwidth_ul,
max_filesize) == 0) {
ret = ul_send(&ulhandler);
ul_exit(&ulhandler);
} else {
ret = -1;
}
(void) close(f);
closedata();
#ifdef SHOW_REAL_DISK_SPACE
if (FSTATFS(f, &statfsbuf) == 0) {
double space;
space = (double) STATFS_BAVAIL(statfsbuf) *
(double) STATFS_FRSIZE(statfsbuf);
if (space > 524288.0) {
addreply(0, MSG_SPACE_FREE_M, space / 1048576.0);
} else {
addreply(0, MSG_SPACE_FREE_K, space / 1024.0);
}
}
#endif
uploaded += (unsigned long long) ulhandler.total_uploaded;
{
off_t atomic_file_size;
off_t original_file_size;
int files_count;
if (overwrite == 0) {
files_count = 1;
} else {
files_count = 0;
}
if (autorename != 0 && restartat == (off_t) 0) {
if ((atomic_file_size = get_file_size(atomic_file)) < (off_t) 0) {
goto afterquota;
}
if (tryautorename(atomic_file, name, &name2) != 0) {
error(553, MSG_RENAME_FAILURE);
goto afterquota;
} else {
#ifdef QUOTAS
ul_quota_update(name2 ? name2 : name, 1, atomic_file_size);
#endif
atomic_file = NULL;
}
} else if (atomic_file != NULL) {
if ((atomic_file_size = get_file_size(atomic_file)) < (off_t) 0) {
goto afterquota;
}
if ((original_file_size = get_file_size(name)) < (off_t) 0 ||
restartat > original_file_size) {
original_file_size = restartat;
}
if (rename(atomic_file, name) != 0) {
error(553, MSG_RENAME_FAILURE);
goto afterquota;
} else {
#ifdef QUOTAS
overflow = ul_quota_update
(name, files_count, atomic_file_size - original_file_size);
#endif
atomic_file = NULL;
}
} else {
#ifdef QUOTAS
overflow = ul_quota_update
(name, files_count, ulhandler.total_uploaded);
#endif
}
}
afterquota:
if (overflow > 0) {
addreply(552, MSG_QUOTA_EXCEEDED, name);
} else {
if (ret == 0) {
addreply_noformat(226, MSG_TRANSFER_SUCCESSFUL);
} else {
addreply_noformat(451, MSG_ABORTED);
}
displayrate(MSG_UPLOADED, ulhandler.total_uploaded, started,
name2 ? name2 : name, 1);
}
end:
restartat = (off_t) 0;
if (atomic_file != NULL) {
unlink(atomic_file);
atomic_file = NULL;
}
}","[115, 116]","In Pure-FTPd before 1.0.50, an incorrect max_filesize quota mechanism in the server allows attackers to upload files of unbounded size, which may lead to denial of service or a server hang. This occurs because a certain greater-than-zero test does not anticipate an initial -1 value. (Versions 1.0.23 through 1.0.49 are affected.)",pure-ftpd,CVE-2021-40524,CWE-434
7351,4103,"next_state_class(CClassNode* cc, OnigCodePoint* vs, enum CCVALTYPE* type,
enum CCSTATE* state, ScanEnv* env)
{
int r;
if (*state == CCS_RANGE)
return ONIGERR_CHAR_CLASS_VALUE_AT_END_OF_RANGE;
if (*state == CCS_VALUE && *type != CCV_CLASS) {
if (*type == CCV_SB)
BITSET_SET_BIT(cc->bs, (int )(*vs));
else if (*type == CCV_CODE_POINT) {
r = add_code_range(&(cc->mbuf), env, *vs, *vs);
if (r < 0) return r;
}
}
*state = CCS_VALUE;
*type  = CCV_CLASS;
return 0;
}",[15],"An issue was discovered in Oniguruma 6.2.0, as used in Oniguruma-mod in Ruby through 2.4.1 and mbstring in PHP through 7.1.5. A heap out-of-bounds write occurs in bitset_set_range() during regular expression compilation due to an uninitialized variable from an incorrect state transition. An incorrect state transition in parse_char_class() could create an execution path that leaves a critical local variable uninitialized until it's used as an index, resulting in an out-of-bounds write memory corruption.",oniguruma,CVE-2017-9228,CWE-787
7357,7544,"srs_timestamp_check(srs_t *srs, const char *stamp)
{
const char *sp;
char  *bp;
int    off;
time_t   now;
time_t   then;
then = 0;
for (sp = stamp; *sp; sp++) {
bp = strchr(SRS_TIME_BASECHARS, toupper(*sp));
if (bp == NULL)
return SRS_EBADTIMESTAMPCHAR;
off = bp - SRS_TIME_BASECHARS;
then = (then << SRS_TIME_BASEBITS) | off;
}
time(&now);
now = (now / SRS_TIME_PRECISION) % SRS_TIME_SLOTS;
while (now < then)
now = now + SRS_TIME_SLOTS;
if (now <= then + srs->maxage)
return SRS_SUCCESS;
return SRS_ETIMESTAMPOUTOFDATE;
}",[8],srs2.c in PostSRSd before 1.10 allows remote attackers to cause a denial of service (CPU consumption) via a long timestamp tag in an SRS address.,postsrsd,CVE-2020-35573,CWE-834
7376,9802,"static SQInteger thread_call(HSQUIRRELVM v)
{
SQObjectPtr o = stack_get(v,1);
if(sq_type(o) == OT_THREAD) {
SQInteger nparams = sq_gettop(v);
_thread(o)->Push(_thread(o)->_roottable);
for(SQInteger i = 2; i<(nparams+1); i++)
sq_move(_thread(o),v,i);
if(SQ_SUCCEEDED(sq_call(_thread(o),nparams,SQTrue,SQTrue))) {
sq_move(v,_thread(o),-1);
sq_pop(_thread(o),1);
return 1;
}
v->_lasterror = _thread(o)->_lasterror;
return SQ_ERROR;
}
return sq_throwerror(v,_SC(""wrong parameter""));
}",[6],Heap-based buffer overflow in sqbaselib.cpp in SQUIRREL 3.2 due to lack of a certain sq_reservestack call.,squirrel,CVE-2022-30292,CWE-787
7377,4487,"PHPAPI int php_swoole_unserialize(void *buffer, size_t len, zval *return_value, zval *object_args, long flag)
{
SBucketType type = *(SBucketType*) (buffer);
zend_uchar real_type = type.data_type;
buffer += sizeof (SBucketType);
switch (real_type)
{
case IS_NULL:
case IS_TRUE:
case IS_FALSE:
Z_TYPE_INFO_P(return_value) = real_type;
break;
case IS_LONG:
swoole_unserialize_long(buffer, return_value, type);
Z_TYPE_INFO_P(return_value) = real_type;
break;
case IS_DOUBLE:
swoole_unserialize_raw(buffer, return_value);
Z_TYPE_INFO_P(return_value) = real_type;
break;
case IS_STRING:
len -= sizeof (SBucketType);
zend_string *str = swoole_unserialize_string(buffer, len);
ZVAL_STR(return_value, str);
break;
case IS_ARRAY:
{
if (swoole_seria_check_eof(buffer, len) < 0)
{
php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""detect the error eof"");
return SW_FALSE;
}
unser_start = buffer - sizeof (SBucketType);
uint32_t num = 0;
buffer = get_array_real_len(buffer, type.data_len, &num);
if (!swoole_unserialize_arr(buffer, return_value, num, flag))
{
return SW_FALSE;
}
break;
}
case IS_UNDEF:
if (swoole_seria_check_eof(buffer, len) < 0)
{
php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""detect the error eof"");
return SW_FALSE;
}
unser_start = buffer - sizeof (SBucketType);
if (!swoole_unserialize_object(buffer, return_value, type.data_len, object_args, flag))
{
return SW_FALSE;
}
break;
default:
php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""the type is not supported by swoole serialize."");
return SW_FALSE;
}
return SW_TRUE;
}","[5, 30, 31, 45, 46]",The unpack implementation in Swoole version 4.0.4 lacks correct size checks in the deserialization process. An attacker can craft a serialized object to exploit this vulnerability and cause a SEGV.,swoole-src,CVE-2018-15503,CWE-502
7386,7219,"archive_string_append_from_wcs(struct archive_string *as,
const wchar_t *w, size_t len)
{
int n, ret_val = 0;
char *p;
char *end;
#if HAVE_WCRTOMB
mbstate_t shift_state;
memset(&shift_state, 0, sizeof(shift_state));
#else
wctomb(NULL, L'\0');
#endif
if (archive_string_ensure(as, as->length + len + 1) == NULL)
return (-1);
p = as->s + as->length;
end = as->s + as->buffer_length - MB_CUR_MAX -1;
while (*w != L'\0' && len > 0) {
if (p >= end) {
as->length = p - as->s;
as->s[as->length] = '\0';
if (archive_string_ensure(as,
as->length + len * 2 + 1) == NULL)
return (-1);
p = as->s + as->length;
end = as->s + as->buffer_length - MB_CUR_MAX -1;
}
#if HAVE_WCRTOMB
n = wcrtomb(p, *w++, &shift_state);
#else
n = wctomb(p, *w++);
#endif
if (n == -1) {
if (errno == EILSEQ) {
*p++ = '?';
ret_val = -1;
} else {
ret_val = -1;
break;
}
} else
p += n;
len--;
}
as->length = p - as->s;
as->s[as->length] = '\0';
return (ret_val);
}",[22],Heap-based buffer overflow in archive_string_append_from_wcs() (archive_string.c) in libarchive-3.4.1dev allows remote attackers to cause a denial of service (out-of-bounds write in heap memory resulting into a crash) via a crafted archive file. NOTE: this only affects users who downloaded the development code from GitHub. Users of the product's official releases are unaffected.,libarchive,CVE-2020-21674,CWE-787
7390,5063,"static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame,
AVPacket *avpkt)
{
const uint8_t *buf = avpkt->data;
int buf_size = avpkt->size;
UtvideoContext *c = avctx->priv_data;
int i, j;
const uint8_t *plane_start[5];
int plane_size, max_slice_size = 0, slice_start, slice_end, slice_size;
int ret;
GetByteContext gb;
ThreadFrame frame = { .f = data };
if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0)
return ret;
bytestream2_init(&gb, buf, buf_size);
if (c->pro) {
if (bytestream2_get_bytes_left(&gb) < c->frame_info_size) {
av_log(avctx, AV_LOG_ERROR, ""Not enough data for frame information\n"");
return AVERROR_INVALIDDATA;
}
c->frame_info = bytestream2_get_le32u(&gb);
c->slices = ((c->frame_info >> 16) & 0xff) + 1;
for (i = 0; i < c->planes; i++) {
plane_start[i] = gb.buffer;
if (bytestream2_get_bytes_left(&gb) < 1024 + 4 * c->slices) {
av_log(avctx, AV_LOG_ERROR, ""Insufficient data for a plane\n"");
return AVERROR_INVALIDDATA;
}
slice_start = 0;
slice_end   = 0;
for (j = 0; j < c->slices; j++) {
slice_end   = bytestream2_get_le32u(&gb);
if (slice_end < 0 || slice_end < slice_start ||
bytestream2_get_bytes_left(&gb) < slice_end) {
av_log(avctx, AV_LOG_ERROR, ""Incorrect slice size\n"");
return AVERROR_INVALIDDATA;
}
slice_size  = slice_end - slice_start;
slice_start = slice_end;
max_slice_size = FFMAX(max_slice_size, slice_size);
}
plane_size = slice_end;
bytestream2_skipu(&gb, plane_size);
bytestream2_skipu(&gb, 1024);
}
plane_start[c->planes] = gb.buffer;
} else {
for (i = 0; i < c->planes; i++) {
plane_start[i] = gb.buffer;
if (bytestream2_get_bytes_left(&gb) < 256 + 4 * c->slices) {
av_log(avctx, AV_LOG_ERROR, ""Insufficient data for a plane\n"");
return AVERROR_INVALIDDATA;
}
bytestream2_skipu(&gb, 256);
slice_start = 0;
slice_end   = 0;
for (j = 0; j < c->slices; j++) {
slice_end   = bytestream2_get_le32u(&gb);
if (slice_end < 0 || slice_end < slice_start ||
bytestream2_get_bytes_left(&gb) < slice_end) {
av_log(avctx, AV_LOG_ERROR, ""Incorrect slice size\n"");
return AVERROR_INVALIDDATA;
}
slice_size  = slice_end - slice_start;
slice_start = slice_end;
max_slice_size = FFMAX(max_slice_size, slice_size);
}
plane_size = slice_end;
bytestream2_skipu(&gb, plane_size);
}
plane_start[c->planes] = gb.buffer;
if (bytestream2_get_bytes_left(&gb) < c->frame_info_size) {
av_log(avctx, AV_LOG_ERROR, ""Not enough data for frame information\n"");
return AVERROR_INVALIDDATA;
}
c->frame_info = bytestream2_get_le32u(&gb);
}
av_log(avctx, AV_LOG_DEBUG, ""frame information flags %""PRIX32""\n"",
c->frame_info);
c->frame_pred = (c->frame_info >> 8) & 3;
if (c->frame_pred == PRED_GRADIENT) {
avpriv_request_sample(avctx, ""Frame with gradient prediction"");
return AVERROR_PATCHWELCOME;
}
av_fast_malloc(&c->slice_bits, &c->slice_bits_size,
max_slice_size + AV_INPUT_BUFFER_PADDING_SIZE);
if (!c->slice_bits) {
av_log(avctx, AV_LOG_ERROR, ""Cannot allocate temporary buffer\n"");
return AVERROR(ENOMEM);
}
switch (c->avctx->pix_fmt) {
case AV_PIX_FMT_RGB24:
case AV_PIX_FMT_RGBA:
for (i = 0; i < c->planes; i++) {
ret = decode_plane(c, i, frame.f->data[0] + ff_ut_rgb_order[i],
c->planes, frame.f->linesize[0], avctx->width,
avctx->height, plane_start[i],
c->frame_pred == PRED_LEFT);
if (ret)
return ret;
if (c->frame_pred == PRED_MEDIAN) {
if (!c->interlaced) {
restore_median(frame.f->data[0] + ff_ut_rgb_order[i],
c->planes, frame.f->linesize[0], avctx->width,
avctx->height, c->slices, 0);
} else {
restore_median_il(frame.f->data[0] + ff_ut_rgb_order[i],
c->planes, frame.f->linesize[0],
avctx->width, avctx->height, c->slices,
0);
}
}
}
restore_rgb_planes(frame.f->data[0], c->planes, frame.f->linesize[0],
avctx->width, avctx->height);
break;
case AV_PIX_FMT_GBRAP10:
case AV_PIX_FMT_GBRP10:
for (i = 0; i < c->planes; i++) {
ret = decode_plane10(c, i, (uint16_t *)frame.f->data[i], 1,
frame.f->linesize[i] / 2, avctx->width,
avctx->height, plane_start[i],
plane_start[i + 1] - 1024,
c->frame_pred == PRED_LEFT);
if (ret)
return ret;
}
restore_rgb_planes10(frame.f, avctx->width, avctx->height);
break;
case AV_PIX_FMT_YUV420P:
for (i = 0; i < 3; i++) {
ret = decode_plane(c, i, frame.f->data[i], 1, frame.f->linesize[i],
avctx->width >> !!i, avctx->height >> !!i,
plane_start[i], c->frame_pred == PRED_LEFT);
if (ret)
return ret;
if (c->frame_pred == PRED_MEDIAN) {
if (!c->interlaced) {
restore_median(frame.f->data[i], 1, frame.f->linesize[i],
avctx->width >> !!i, avctx->height >> !!i,
c->slices, !i);
} else {
restore_median_il(frame.f->data[i], 1, frame.f->linesize[i],
avctx->width  >> !!i,
avctx->height >> !!i,
c->slices, !i);
}
}
}
break;
case AV_PIX_FMT_YUV422P:
for (i = 0; i < 3; i++) {
ret = decode_plane(c, i, frame.f->data[i], 1, frame.f->linesize[i],
avctx->width >> !!i, avctx->height,
plane_start[i], c->frame_pred == PRED_LEFT);
if (ret)
return ret;
if (c->frame_pred == PRED_MEDIAN) {
if (!c->interlaced) {
restore_median(frame.f->data[i], 1, frame.f->linesize[i],
avctx->width >> !!i, avctx->height,
c->slices, 0);
} else {
restore_median_il(frame.f->data[i], 1, frame.f->linesize[i],
avctx->width >> !!i, avctx->height,
c->slices, 0);
}
}
}
break;
case AV_PIX_FMT_YUV444P:
for (i = 0; i < 3; i++) {
ret = decode_plane(c, i, frame.f->data[i], 1, frame.f->linesize[i],
avctx->width, avctx->height,
plane_start[i], c->frame_pred == PRED_LEFT);
if (ret)
return ret;
if (c->frame_pred == PRED_MEDIAN) {
if (!c->interlaced) {
restore_median(frame.f->data[i], 1, frame.f->linesize[i],
avctx->width, avctx->height,
c->slices, 0);
} else {
restore_median_il(frame.f->data[i], 1, frame.f->linesize[i],
avctx->width, avctx->height,
c->slices, 0);
}
}
}
break;
case AV_PIX_FMT_YUV422P10:
for (i = 0; i < 3; i++) {
ret = decode_plane10(c, i, (uint16_t *)frame.f->data[i], 1, frame.f->linesize[i] / 2,
avctx->width >> !!i, avctx->height,
plane_start[i], plane_start[i + 1] - 1024, c->frame_pred == PRED_LEFT);
if (ret)
return ret;
}
break;
}
frame.f->key_frame = 1;
frame.f->pict_type = AV_PICTURE_TYPE_I;
frame.f->interlaced_frame = !!c->interlaced;
*got_frame = 1;
return buf_size;
}",[34],The decode_frame function in libavcodec/utvideodec.c in FFmpeg through 3.2 allows remote attackers to cause a denial of service (out of array read) via a crafted AVI file.,FFmpeg,CVE-2018-6621,CWE-125
7394,6081,"void sqlite3Pragma(
Parse *pParse,
Token *pId1,
Token *pId2,
Token *pValue,
int minusFlag
){
char *zLeft = 0;
char *zRight = 0;
const char *zDb = 0;
Token *pId;
char *aFcntl[4];
int iDb;
int rc;
sqlite3 *db = pParse->db;
Db *pDb;
Vdbe *v = sqlite3GetVdbe(pParse);
const PragmaName *pPragma;
if( v==0 ) return;
sqlite3VdbeRunOnlyOnce(v);
pParse->nMem = 2;
iDb = sqlite3TwoPartName(pParse, pId1, pId2, &pId);
if( iDb<0 ) return;
pDb = &db->aDb[iDb];
if( iDb==1 && sqlite3OpenTempDatabase(pParse) ){
return;
}
zLeft = sqlite3NameFromToken(db, pId);
if( !zLeft ) return;
if( minusFlag ){
zRight = sqlite3MPrintf(db, ""-%T"", pValue);
}else{
zRight = sqlite3NameFromToken(db, pValue);
}
assert( pId2 );
zDb = pId2->n>0 ? pDb->zDbSName : 0;
if( sqlite3AuthCheck(pParse, SQLITE_PRAGMA, zLeft, zRight, zDb) ){
goto pragma_out;
}
aFcntl[0] = 0;
aFcntl[1] = zLeft;
aFcntl[2] = zRight;
aFcntl[3] = 0;
db->busyHandler.nBusy = 0;
rc = sqlite3_file_control(db, zDb, SQLITE_FCNTL_PRAGMA, (void*)aFcntl);
if( rc==SQLITE_OK ){
sqlite3VdbeSetNumCols(v, 1);
sqlite3VdbeSetColName(v, 0, COLNAME_NAME, aFcntl[0], SQLITE_TRANSIENT);
returnSingleText(v, aFcntl[0]);
sqlite3_free(aFcntl[0]);
goto pragma_out;
}
if( rc!=SQLITE_NOTFOUND ){
if( aFcntl[0] ){
sqlite3ErrorMsg(pParse, ""%s"", aFcntl[0]);
sqlite3_free(aFcntl[0]);
}
pParse->nErr++;
pParse->rc = rc;
goto pragma_out;
}
pPragma = pragmaLocate(zLeft);
if( pPragma==0 ) goto pragma_out;
if( (pPragma->mPragFlg & PragFlg_NeedSchema)!=0 ){
if( sqlite3ReadSchema(pParse) ) goto pragma_out;
}
if( (pPragma->mPragFlg & PragFlg_NoColumns)==0
&& ((pPragma->mPragFlg & PragFlg_NoColumns1)==0 || zRight==0)
){
setPragmaResultColumnNames(v, pPragma);
}
switch( pPragma->ePragTyp ){
#if !defined(SQLITE_OMIT_PAGER_PRAGMAS) && !defined(SQLITE_OMIT_DEPRECATED)
case PragTyp_DEFAULT_CACHE_SIZE: {
static const int iLn = VDBE_OFFSET_LINENO(2);
static const VdbeOpList getCacheSize[] = {
{ OP_Transaction, 0, 0,        0},
{ OP_ReadCookie,  0, 1,        BTREE_DEFAULT_CACHE_SIZE},
{ OP_IfPos,       1, 8,        0},
{ OP_Integer,     0, 2,        0},
{ OP_Subtract,    1, 2,        1},
{ OP_IfPos,       1, 8,        0},
{ OP_Integer,     0, 1,        0},
{ OP_Noop,        0, 0,        0},
{ OP_ResultRow,   1, 1,        0},
};
VdbeOp *aOp;
sqlite3VdbeUsesBtree(v, iDb);
if( !zRight ){
pParse->nMem += 2;
sqlite3VdbeVerifyNoMallocRequired(v, ArraySize(getCacheSize));
aOp = sqlite3VdbeAddOpList(v, ArraySize(getCacheSize), getCacheSize, iLn);
if( ONLY_IF_REALLOC_STRESS(aOp==0) ) break;
aOp[0].p1 = iDb;
aOp[1].p1 = iDb;
aOp[6].p1 = SQLITE_DEFAULT_CACHE_SIZE;
}else{
int size = sqlite3AbsInt32(sqlite3Atoi(zRight));
sqlite3BeginWriteOperation(pParse, 0, iDb);
sqlite3VdbeAddOp3(v, OP_SetCookie, iDb, BTREE_DEFAULT_CACHE_SIZE, size);
assert( sqlite3SchemaMutexHeld(db, iDb, 0) );
pDb->pSchema->cache_size = size;
sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size);
}
break;
}
#endif /* !SQLITE_OMIT_PAGER_PRAGMAS && !SQLITE_OMIT_DEPRECATED */
#if !defined(SQLITE_OMIT_PAGER_PRAGMAS)
case PragTyp_PAGE_SIZE: {
Btree *pBt = pDb->pBt;
assert( pBt!=0 );
if( !zRight ){
int size = ALWAYS(pBt) ? sqlite3BtreeGetPageSize(pBt) : 0;
returnSingleInt(v, size);
}else{
db->nextPagesize = sqlite3Atoi(zRight);
if( SQLITE_NOMEM==sqlite3BtreeSetPageSize(pBt, db->nextPagesize,-1,0) ){
sqlite3OomFault(db);
}
}
break;
}
case PragTyp_SECURE_DELETE: {
Btree *pBt = pDb->pBt;
int b = -1;
assert( pBt!=0 );
if( zRight ){
if( sqlite3_stricmp(zRight, ""fast"")==0 ){
b = 2;
}else{
b = sqlite3GetBoolean(zRight, 0);
}
}
if( pId2->n==0 && b>=0 ){
int ii;
for(ii=0; ii<db->nDb; ii++){
sqlite3BtreeSecureDelete(db->aDb[ii].pBt, b);
}
}
b = sqlite3BtreeSecureDelete(pBt, b);
returnSingleInt(v, b);
break;
}
case PragTyp_PAGE_COUNT: {
int iReg;
sqlite3CodeVerifySchema(pParse, iDb);
iReg = ++pParse->nMem;
if( sqlite3Tolower(zLeft[0])=='p' ){
sqlite3VdbeAddOp2(v, OP_Pagecount, iDb, iReg);
}else{
sqlite3VdbeAddOp3(v, OP_MaxPgcnt, iDb, iReg,
sqlite3AbsInt32(sqlite3Atoi(zRight)));
}
sqlite3VdbeAddOp2(v, OP_ResultRow, iReg, 1);
break;
}
case PragTyp_LOCKING_MODE: {
const char *zRet = ""normal"";
int eMode = getLockingMode(zRight);
if( pId2->n==0 && eMode==PAGER_LOCKINGMODE_QUERY ){
eMode = db->dfltLockMode;
}else{
Pager *pPager;
if( pId2->n==0 ){
int ii;
assert(pDb==&db->aDb[0]);
for(ii=2; ii<db->nDb; ii++){
pPager = sqlite3BtreePager(db->aDb[ii].pBt);
sqlite3PagerLockingMode(pPager, eMode);
}
db->dfltLockMode = (u8)eMode;
}
pPager = sqlite3BtreePager(pDb->pBt);
eMode = sqlite3PagerLockingMode(pPager, eMode);
}
assert( eMode==PAGER_LOCKINGMODE_NORMAL
|| eMode==PAGER_LOCKINGMODE_EXCLUSIVE );
if( eMode==PAGER_LOCKINGMODE_EXCLUSIVE ){
zRet = ""exclusive"";
}
returnSingleText(v, zRet);
break;
}
case PragTyp_JOURNAL_MODE: {
int eMode;
int ii;
if( zRight==0 ){
eMode = PAGER_JOURNALMODE_QUERY;
}else{
const char *zMode;
int n = sqlite3Strlen30(zRight);
for(eMode=0; (zMode = sqlite3JournalModename(eMode))!=0; eMode++){
if( sqlite3StrNICmp(zRight, zMode, n)==0 ) break;
}
if( !zMode ){
eMode = PAGER_JOURNALMODE_QUERY;
}
if( eMode==PAGER_JOURNALMODE_OFF && (db->flags & SQLITE_Defensive)!=0 ){
eMode = PAGER_JOURNALMODE_QUERY;
}
}
if( eMode==PAGER_JOURNALMODE_QUERY && pId2->n==0 ){
iDb = 0;
pId2->n = 1;
}
for(ii=db->nDb-1; ii>=0; ii--){
if( db->aDb[ii].pBt && (ii==iDb || pId2->n==0) ){
sqlite3VdbeUsesBtree(v, ii);
sqlite3VdbeAddOp3(v, OP_JournalMode, ii, 1, eMode);
}
}
sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 1);
break;
}
case PragTyp_JOURNAL_SIZE_LIMIT: {
Pager *pPager = sqlite3BtreePager(pDb->pBt);
i64 iLimit = -2;
if( zRight ){
sqlite3DecOrHexToI64(zRight, &iLimit);
if( iLimit<-1 ) iLimit = -1;
}
iLimit = sqlite3PagerJournalSizeLimit(pPager, iLimit);
returnSingleInt(v, iLimit);
break;
}
#endif /* SQLITE_OMIT_PAGER_PRAGMAS */
#ifndef SQLITE_OMIT_AUTOVACUUM
case PragTyp_AUTO_VACUUM: {
Btree *pBt = pDb->pBt;
assert( pBt!=0 );
if( !zRight ){
returnSingleInt(v, sqlite3BtreeGetAutoVacuum(pBt));
}else{
int eAuto = getAutoVacuum(zRight);
assert( eAuto>=0 && eAuto<=2 );
db->nextAutovac = (u8)eAuto;
rc = sqlite3BtreeSetAutoVacuum(pBt, eAuto);
if( rc==SQLITE_OK && (eAuto==1 || eAuto==2) ){
static const int iLn = VDBE_OFFSET_LINENO(2);
static const VdbeOpList setMeta6[] = {
{ OP_Transaction,    0,         1,                 0},
{ OP_ReadCookie,     0,         1,         BTREE_LARGEST_ROOT_PAGE},
{ OP_If,             1,         0,                 0},
{ OP_Halt,           SQLITE_OK, OE_Abort,          0},
{ OP_SetCookie,      0,         BTREE_INCR_VACUUM, 0},
};
VdbeOp *aOp;
int iAddr = sqlite3VdbeCurrentAddr(v);
sqlite3VdbeVerifyNoMallocRequired(v, ArraySize(setMeta6));
aOp = sqlite3VdbeAddOpList(v, ArraySize(setMeta6), setMeta6, iLn);
if( ONLY_IF_REALLOC_STRESS(aOp==0) ) break;
aOp[0].p1 = iDb;
aOp[1].p1 = iDb;
aOp[2].p2 = iAddr+4;
aOp[4].p1 = iDb;
aOp[4].p3 = eAuto - 1;
sqlite3VdbeUsesBtree(v, iDb);
}
}
break;
}
#endif
#ifndef SQLITE_OMIT_AUTOVACUUM
case PragTyp_INCREMENTAL_VACUUM: {
int iLimit, addr;
if( zRight==0 || !sqlite3GetInt32(zRight, &iLimit) || iLimit<=0 ){
iLimit = 0x7fffffff;
}
sqlite3BeginWriteOperation(pParse, 0, iDb);
sqlite3VdbeAddOp2(v, OP_Integer, iLimit, 1);
addr = sqlite3VdbeAddOp1(v, OP_IncrVacuum, iDb); VdbeCoverage(v);
sqlite3VdbeAddOp1(v, OP_ResultRow, 1);
sqlite3VdbeAddOp2(v, OP_AddImm, 1, -1);
sqlite3VdbeAddOp2(v, OP_IfPos, 1, addr); VdbeCoverage(v);
sqlite3VdbeJumpHere(v, addr);
break;
}
#endif
#ifndef SQLITE_OMIT_PAGER_PRAGMAS
case PragTyp_CACHE_SIZE: {
assert( sqlite3SchemaMutexHeld(db, iDb, 0) );
if( !zRight ){
returnSingleInt(v, pDb->pSchema->cache_size);
}else{
int size = sqlite3Atoi(zRight);
pDb->pSchema->cache_size = size;
sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size);
}
break;
}
case PragTyp_CACHE_SPILL: {
assert( sqlite3SchemaMutexHeld(db, iDb, 0) );
if( !zRight ){
returnSingleInt(v,
(db->flags & SQLITE_CacheSpill)==0 ? 0 :
sqlite3BtreeSetSpillSize(pDb->pBt,0));
}else{
int size = 1;
if( sqlite3GetInt32(zRight, &size) ){
sqlite3BtreeSetSpillSize(pDb->pBt, size);
}
if( sqlite3GetBoolean(zRight, size!=0) ){
db->flags |= SQLITE_CacheSpill;
}else{
db->flags &= ~(u64)SQLITE_CacheSpill;
}
setAllPagerFlags(db);
}
break;
}
case PragTyp_MMAP_SIZE: {
sqlite3_int64 sz;
#if SQLITE_MAX_MMAP_SIZE>0
assert( sqlite3SchemaMutexHeld(db, iDb, 0) );
if( zRight ){
int ii;
sqlite3DecOrHexToI64(zRight, &sz);
if( sz<0 ) sz = sqlite3GlobalConfig.szMmap;
if( pId2->n==0 ) db->szMmap = sz;
for(ii=db->nDb-1; ii>=0; ii--){
if( db->aDb[ii].pBt && (ii==iDb || pId2->n==0) ){
sqlite3BtreeSetMmapLimit(db->aDb[ii].pBt, sz);
}
}
}
sz = -1;
rc = sqlite3_file_control(db, zDb, SQLITE_FCNTL_MMAP_SIZE, &sz);
#else
sz = 0;
rc = SQLITE_OK;
#endif
if( rc==SQLITE_OK ){
returnSingleInt(v, sz);
}else if( rc!=SQLITE_NOTFOUND ){
pParse->nErr++;
pParse->rc = rc;
}
break;
}
case PragTyp_TEMP_STORE: {
if( !zRight ){
returnSingleInt(v, db->temp_store);
}else{
changeTempStorage(pParse, zRight);
}
break;
}
case PragTyp_TEMP_STORE_DIRECTORY: {
if( !zRight ){
returnSingleText(v, sqlite3_temp_directory);
}else{
#ifndef SQLITE_OMIT_WSD
if( zRight[0] ){
int res;
rc = sqlite3OsAccess(db->pVfs, zRight, SQLITE_ACCESS_READWRITE, &res);
if( rc!=SQLITE_OK || res==0 ){
sqlite3ErrorMsg(pParse, ""not a writable directory"");
goto pragma_out;
}
}
if( SQLITE_TEMP_STORE==0
|| (SQLITE_TEMP_STORE==1 && db->temp_store<=1)
|| (SQLITE_TEMP_STORE==2 && db->temp_store==1)
){
invalidateTempStorage(pParse);
}
sqlite3_free(sqlite3_temp_directory);
if( zRight[0] ){
sqlite3_temp_directory = sqlite3_mprintf(""%s"", zRight);
}else{
sqlite3_temp_directory = 0;
}
#endif /* SQLITE_OMIT_WSD */
}
break;
}
#if SQLITE_OS_WIN
case PragTyp_DATA_STORE_DIRECTORY: {
if( !zRight ){
returnSingleText(v, sqlite3_data_directory);
}else{
#ifndef SQLITE_OMIT_WSD
if( zRight[0] ){
int res;
rc = sqlite3OsAccess(db->pVfs, zRight, SQLITE_ACCESS_READWRITE, &res);
if( rc!=SQLITE_OK || res==0 ){
sqlite3ErrorMsg(pParse, ""not a writable directory"");
goto pragma_out;
}
}
sqlite3_free(sqlite3_data_directory);
if( zRight[0] ){
sqlite3_data_directory = sqlite3_mprintf(""%s"", zRight);
}else{
sqlite3_data_directory = 0;
}
#endif /* SQLITE_OMIT_WSD */
}
break;
}
#endif
#if SQLITE_ENABLE_LOCKING_STYLE
case PragTyp_LOCK_PROXY_FILE: {
if( !zRight ){
Pager *pPager = sqlite3BtreePager(pDb->pBt);
char *proxy_file_path = NULL;
sqlite3_file *pFile = sqlite3PagerFile(pPager);
sqlite3OsFileControlHint(pFile, SQLITE_GET_LOCKPROXYFILE,
&proxy_file_path);
returnSingleText(v, proxy_file_path);
}else{
Pager *pPager = sqlite3BtreePager(pDb->pBt);
sqlite3_file *pFile = sqlite3PagerFile(pPager);
int res;
if( zRight[0] ){
res=sqlite3OsFileControl(pFile, SQLITE_SET_LOCKPROXYFILE,
zRight);
} else {
res=sqlite3OsFileControl(pFile, SQLITE_SET_LOCKPROXYFILE,
NULL);
}
if( res!=SQLITE_OK ){
sqlite3ErrorMsg(pParse, ""failed to set lock proxy file"");
goto pragma_out;
}
}
break;
}
#endif /* SQLITE_ENABLE_LOCKING_STYLE */      
case PragTyp_SYNCHRONOUS: {
if( !zRight ){
returnSingleInt(v, pDb->safety_level-1);
}else{
if( !db->autoCommit ){
sqlite3ErrorMsg(pParse,
""Safety level may not be changed inside a transaction"");
}else if( iDb!=1 ){
int iLevel = (getSafetyLevel(zRight,0,1)+1) & PAGER_SYNCHRONOUS_MASK;
if( iLevel==0 ) iLevel = 1;
pDb->safety_level = iLevel;
pDb->bSyncSet = 1;
setAllPagerFlags(db);
}
}
break;
}
#endif /* SQLITE_OMIT_PAGER_PRAGMAS */
#ifndef SQLITE_OMIT_FLAG_PRAGMAS
case PragTyp_FLAG: {
if( zRight==0 ){
setPragmaResultColumnNames(v, pPragma);
returnSingleInt(v, (db->flags & pPragma->iArg)!=0 );
}else{
u64 mask = pPragma->iArg;
if( db->autoCommit==0 ){
mask &= ~(SQLITE_ForeignKeys);
}
#if SQLITE_USER_AUTHENTICATION
if( db->auth.authLevel==UAUTH_User ){
mask &= ~(SQLITE_WriteSchema);
}
#endif
if( sqlite3GetBoolean(zRight, 0) ){
db->flags |= mask;
}else{
db->flags &= ~mask;
if( mask==SQLITE_DeferFKs ) db->nDeferredImmCons = 0;
}
sqlite3VdbeAddOp0(v, OP_Expire);
setAllPagerFlags(db);
}
break;
}
#endif /* SQLITE_OMIT_FLAG_PRAGMAS */
#ifndef SQLITE_OMIT_SCHEMA_PRAGMAS
case PragTyp_TABLE_INFO: if( zRight ){
Table *pTab;
pTab = sqlite3LocateTable(pParse, LOCATE_NOERR, zRight, zDb);
if( pTab ){
int iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);
int i, k;
int nHidden = 0;
Column *pCol;
Index *pPk = sqlite3PrimaryKeyIndex(pTab);
pParse->nMem = 7;
sqlite3CodeVerifySchema(pParse, iTabDb);
sqlite3ViewGetColumnNames(pParse, pTab);
for(i=0, pCol=pTab->aCol; i<pTab->nCol; i++, pCol++){
int isHidden = 0;
if( pCol->colFlags & COLFLAG_NOINSERT ){
if( pPragma->iArg==0 ){
nHidden++;
continue;
}
if( pCol->colFlags & COLFLAG_VIRTUAL ){
isHidden = 2;
}else if( pCol->colFlags & COLFLAG_STORED ){
isHidden = 3;
}else{ assert( pCol->colFlags & COLFLAG_HIDDEN );
isHidden = 1;
}
}
if( (pCol->colFlags & COLFLAG_PRIMKEY)==0 ){
k = 0;
}else if( pPk==0 ){
k = 1;
}else{
for(k=1; k<=pTab->nCol && pPk->aiColumn[k-1]!=i; k++){}
}
assert( pCol->pDflt==0 || pCol->pDflt->op==TK_SPAN || isHidden>=2 );
sqlite3VdbeMultiLoad(v, 1, pPragma->iArg ? ""issisii"" : ""issisi"",
i-nHidden,
pCol->zName,
sqlite3ColumnType(pCol,""""),
pCol->notNull ? 1 : 0,
pCol->pDflt && isHidden<2 ? pCol->pDflt->u.zToken : 0,
k,
isHidden);
}
}
}
break;
#ifdef SQLITE_DEBUG
case PragTyp_STATS: {
Index *pIdx;
HashElem *i;
pParse->nMem = 5;
sqlite3CodeVerifySchema(pParse, iDb);
for(i=sqliteHashFirst(&pDb->pSchema->tblHash); i; i=sqliteHashNext(i)){
Table *pTab = sqliteHashData(i);
sqlite3VdbeMultiLoad(v, 1, ""ssiii"",
pTab->zName,
0,
pTab->szTabRow,
pTab->nRowLogEst,
pTab->tabFlags);
for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
sqlite3VdbeMultiLoad(v, 2, ""siiiX"",
pIdx->zName,
pIdx->szIdxRow,
pIdx->aiRowLogEst[0],
pIdx->hasStat1);
sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 5);
}
}
}
break;
#endif
case PragTyp_INDEX_INFO: if( zRight ){
Index *pIdx;
Table *pTab;
pIdx = sqlite3FindIndex(db, zRight, zDb);
if( pIdx==0 ){
pTab = sqlite3LocateTable(pParse, LOCATE_NOERR, zRight, zDb);
if( pTab && !HasRowid(pTab) ){
pIdx = sqlite3PrimaryKeyIndex(pTab);
}
}
if( pIdx ){
int iIdxDb = sqlite3SchemaToIndex(db, pIdx->pSchema);
int i;
int mx;
if( pPragma->iArg ){
mx = pIdx->nColumn;
pParse->nMem = 6;
}else{
mx = pIdx->nKeyCol;
pParse->nMem = 3;
}
pTab = pIdx->pTable;
sqlite3CodeVerifySchema(pParse, iIdxDb);
assert( pParse->nMem<=pPragma->nPragCName );
for(i=0; i<mx; i++){
i16 cnum = pIdx->aiColumn[i];
sqlite3VdbeMultiLoad(v, 1, ""iisX"", i, cnum,
cnum<0 ? 0 : pTab->aCol[cnum].zName);
if( pPragma->iArg ){
sqlite3VdbeMultiLoad(v, 4, ""isiX"",
pIdx->aSortOrder[i],
pIdx->azColl[i],
i<pIdx->nKeyCol);
}
sqlite3VdbeAddOp2(v, OP_ResultRow, 1, pParse->nMem);
}
}
}
break;
case PragTyp_INDEX_LIST: if( zRight ){
Index *pIdx;
Table *pTab;
int i;
pTab = sqlite3FindTable(db, zRight, zDb);
if( pTab ){
int iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);
pParse->nMem = 5;
sqlite3CodeVerifySchema(pParse, iTabDb);
for(pIdx=pTab->pIndex, i=0; pIdx; pIdx=pIdx->pNext, i++){
const char *azOrigin[] = { ""c"", ""u"", ""pk"" };
sqlite3VdbeMultiLoad(v, 1, ""isisi"",
i,
pIdx->zName,
IsUniqueIndex(pIdx),
azOrigin[pIdx->idxType],
pIdx->pPartIdxWhere!=0);
}
}
}
break;
case PragTyp_DATABASE_LIST: {
int i;
pParse->nMem = 3;
for(i=0; i<db->nDb; i++){
if( db->aDb[i].pBt==0 ) continue;
assert( db->aDb[i].zDbSName!=0 );
sqlite3VdbeMultiLoad(v, 1, ""iss"",
i,
db->aDb[i].zDbSName,
sqlite3BtreeGetFilename(db->aDb[i].pBt));
}
}
break;
case PragTyp_COLLATION_LIST: {
int i = 0;
HashElem *p;
pParse->nMem = 2;
for(p=sqliteHashFirst(&db->aCollSeq); p; p=sqliteHashNext(p)){
CollSeq *pColl = (CollSeq *)sqliteHashData(p);
sqlite3VdbeMultiLoad(v, 1, ""is"", i++, pColl->zName);
}
}
break;
#ifndef SQLITE_OMIT_INTROSPECTION_PRAGMAS
case PragTyp_FUNCTION_LIST: {
int i;
HashElem *j;
FuncDef *p;
pParse->nMem = 2;
for(i=0; i<SQLITE_FUNC_HASH_SZ; i++){
for(p=sqlite3BuiltinFunctions.a[i]; p; p=p->u.pHash ){
if( p->funcFlags & SQLITE_FUNC_INTERNAL ) continue;
sqlite3VdbeMultiLoad(v, 1, ""si"", p->zName, 1);
}
}
for(j=sqliteHashFirst(&db->aFunc); j; j=sqliteHashNext(j)){
p = (FuncDef*)sqliteHashData(j);
sqlite3VdbeMultiLoad(v, 1, ""si"", p->zName, 0);
}
}
break;
#ifndef SQLITE_OMIT_VIRTUALTABLE
case PragTyp_MODULE_LIST: {
HashElem *j;
pParse->nMem = 1;
for(j=sqliteHashFirst(&db->aModule); j; j=sqliteHashNext(j)){
Module *pMod = (Module*)sqliteHashData(j);
sqlite3VdbeMultiLoad(v, 1, ""s"", pMod->zName);
}
}
break;
#endif /* SQLITE_OMIT_VIRTUALTABLE */
case PragTyp_PRAGMA_LIST: {
int i;
for(i=0; i<ArraySize(aPragmaName); i++){
sqlite3VdbeMultiLoad(v, 1, ""s"", aPragmaName[i].zName);
}
}
break;
#endif /* SQLITE_INTROSPECTION_PRAGMAS */
#endif /* SQLITE_OMIT_SCHEMA_PRAGMAS */
#ifndef SQLITE_OMIT_FOREIGN_KEY
case PragTyp_FOREIGN_KEY_LIST: if( zRight ){
FKey *pFK;
Table *pTab;
pTab = sqlite3FindTable(db, zRight, zDb);
if( pTab ){
pFK = pTab->pFKey;
if( pFK ){
int iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);
int i = 0;
pParse->nMem = 8;
sqlite3CodeVerifySchema(pParse, iTabDb);
while(pFK){
int j;
for(j=0; j<pFK->nCol; j++){
sqlite3VdbeMultiLoad(v, 1, ""iissssss"",
i,
j,
pFK->zTo,
pTab->aCol[pFK->aCol[j].iFrom].zName,
pFK->aCol[j].zCol,
actionName(pFK->aAction[1]),
actionName(pFK->aAction[0]),
""NONE"");
}
++i;
pFK = pFK->pNextFrom;
}
}
}
}
break;
#endif /* !defined(SQLITE_OMIT_FOREIGN_KEY) */
#ifndef SQLITE_OMIT_FOREIGN_KEY
#ifndef SQLITE_OMIT_TRIGGER
case PragTyp_FOREIGN_KEY_CHECK: {
FKey *pFK;
Table *pTab;
Table *pParent;
Index *pIdx;
int i;
int j;
HashElem *k;
int x;
int regResult;
int regKey;
int regRow;
int addrTop;
int addrOk;
int *aiCols;
regResult = pParse->nMem+1;
pParse->nMem += 4;
regKey = ++pParse->nMem;
regRow = ++pParse->nMem;
k = sqliteHashFirst(&db->aDb[iDb].pSchema->tblHash);
while( k ){
int iTabDb;
if( zRight ){
pTab = sqlite3LocateTable(pParse, 0, zRight, zDb);
k = 0;
}else{
pTab = (Table*)sqliteHashData(k);
k = sqliteHashNext(k);
}
if( pTab==0 || pTab->pFKey==0 ) continue;
iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);
sqlite3CodeVerifySchema(pParse, iTabDb);
sqlite3TableLock(pParse, iTabDb, pTab->tnum, 0, pTab->zName);
if( pTab->nCol+regRow>pParse->nMem ) pParse->nMem = pTab->nCol + regRow;
sqlite3OpenTable(pParse, 0, iTabDb, pTab, OP_OpenRead);
sqlite3VdbeLoadString(v, regResult, pTab->zName);
for(i=1, pFK=pTab->pFKey; pFK; i++, pFK=pFK->pNextFrom){
pParent = sqlite3FindTable(db, pFK->zTo, zDb);
if( pParent==0 ) continue;
pIdx = 0;
sqlite3TableLock(pParse, iTabDb, pParent->tnum, 0, pParent->zName);
x = sqlite3FkLocateIndex(pParse, pParent, pFK, &pIdx, 0);
if( x==0 ){
if( pIdx==0 ){
sqlite3OpenTable(pParse, i, iTabDb, pParent, OP_OpenRead);
}else{
sqlite3VdbeAddOp3(v, OP_OpenRead, i, pIdx->tnum, iTabDb);
sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
}
}else{
k = 0;
break;
}
}
assert( pParse->nErr>0 || pFK==0 );
if( pFK ) break;
if( pParse->nTab<i ) pParse->nTab = i;
addrTop = sqlite3VdbeAddOp1(v, OP_Rewind, 0); VdbeCoverage(v);
for(i=1, pFK=pTab->pFKey; pFK; i++, pFK=pFK->pNextFrom){
pParent = sqlite3FindTable(db, pFK->zTo, zDb);
pIdx = 0;
aiCols = 0;
if( pParent ){
x = sqlite3FkLocateIndex(pParse, pParent, pFK, &pIdx, &aiCols);
assert( x==0 );
}
addrOk = sqlite3VdbeMakeLabel(pParse);
for(j=0; j<pFK->nCol; j++){
int iCol = aiCols ? aiCols[j] : pFK->aCol[j].iFrom;
sqlite3ExprCodeGetColumnOfTable(v, pTab, 0, iCol, regRow+j);
sqlite3VdbeAddOp2(v, OP_IsNull, regRow+j, addrOk); VdbeCoverage(v);
}
if( pIdx ){
sqlite3VdbeAddOp4(v, OP_MakeRecord, regRow, pFK->nCol, regKey,
sqlite3IndexAffinityStr(db,pIdx), pFK->nCol);
sqlite3VdbeAddOp4Int(v, OP_Found, i, addrOk, regKey, 0);
VdbeCoverage(v);
}else if( pParent ){
int jmp = sqlite3VdbeCurrentAddr(v)+2;
sqlite3VdbeAddOp3(v, OP_SeekRowid, i, jmp, regRow); VdbeCoverage(v);
sqlite3VdbeGoto(v, addrOk);
assert( pFK->nCol==1 );
}
if( HasRowid(pTab) ){
sqlite3VdbeAddOp2(v, OP_Rowid, 0, regResult+1);
}else{
sqlite3VdbeAddOp2(v, OP_Null, 0, regResult+1);
}
sqlite3VdbeMultiLoad(v, regResult+2, ""siX"", pFK->zTo, i-1);
sqlite3VdbeAddOp2(v, OP_ResultRow, regResult, 4);
sqlite3VdbeResolveLabel(v, addrOk);
sqlite3DbFree(db, aiCols);
}
sqlite3VdbeAddOp2(v, OP_Next, 0, addrTop+1); VdbeCoverage(v);
sqlite3VdbeJumpHere(v, addrTop);
}
}
break;
#endif /* !defined(SQLITE_OMIT_TRIGGER) */
#endif /* !defined(SQLITE_OMIT_FOREIGN_KEY) */
#ifndef SQLITE_OMIT_CASE_SENSITIVE_LIKE_PRAGMA
case PragTyp_CASE_SENSITIVE_LIKE: {
if( zRight ){
sqlite3RegisterLikeFunctions(db, sqlite3GetBoolean(zRight, 0));
}
}
break;
#endif /* SQLITE_OMIT_CASE_SENSITIVE_LIKE_PRAGMA */
#ifndef SQLITE_INTEGRITY_CHECK_ERROR_MAX
# define SQLITE_INTEGRITY_CHECK_ERROR_MAX 100
#endif
#ifndef SQLITE_OMIT_INTEGRITY_CHECK
case PragTyp_INTEGRITY_CHECK: {
int i, j, addr, mxErr;
int isQuick = (sqlite3Tolower(zLeft[0])=='q');
assert( iDb>=0 );
assert( iDb==0 || pId2->z );
if( pId2->z==0 ) iDb = -1;
pParse->nMem = 6;
mxErr = SQLITE_INTEGRITY_CHECK_ERROR_MAX;
if( zRight ){
sqlite3GetInt32(zRight, &mxErr);
if( mxErr<=0 ){
mxErr = SQLITE_INTEGRITY_CHECK_ERROR_MAX;
}
}
sqlite3VdbeAddOp2(v, OP_Integer, mxErr-1, 1);
for(i=0; i<db->nDb; i++){
HashElem *x;
Hash *pTbls;
int *aRoot;
int cnt = 0;
int mxIdx = 0;
if( OMIT_TEMPDB && i==1 ) continue;
if( iDb>=0 && i!=iDb ) continue;
sqlite3CodeVerifySchema(pParse, i);
assert( sqlite3SchemaMutexHeld(db, i, 0) );
pTbls = &db->aDb[i].pSchema->tblHash;
for(cnt=0, x=sqliteHashFirst(pTbls); x; x=sqliteHashNext(x)){
Table *pTab = sqliteHashData(x);
Index *pIdx;
int nIdx;
if( HasRowid(pTab) ) cnt++;
for(nIdx=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, nIdx++){ cnt++; }
if( nIdx>mxIdx ) mxIdx = nIdx;
}
aRoot = sqlite3DbMallocRawNN(db, sizeof(int)*(cnt+1));
if( aRoot==0 ) break;
for(cnt=0, x=sqliteHashFirst(pTbls); x; x=sqliteHashNext(x)){
Table *pTab = sqliteHashData(x);
Index *pIdx;
if( HasRowid(pTab) ) aRoot[++cnt] = pTab->tnum;
for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
aRoot[++cnt] = pIdx->tnum;
}
}
aRoot[0] = cnt;
pParse->nMem = MAX( pParse->nMem, 8+mxIdx );
sqlite3ClearTempRegCache(pParse);
sqlite3VdbeAddOp4(v, OP_IntegrityCk, 2, cnt, 1, (char*)aRoot,P4_INTARRAY);
sqlite3VdbeChangeP5(v, (u8)i);
addr = sqlite3VdbeAddOp1(v, OP_IsNull, 2); VdbeCoverage(v);
sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0,
sqlite3MPrintf(db, ""*** in database %s ***\n"", db->aDb[i].zDbSName),
P4_DYNAMIC);
sqlite3VdbeAddOp3(v, OP_Concat, 2, 3, 3);
integrityCheckResultRow(v);
sqlite3VdbeJumpHere(v, addr);
for(x=sqliteHashFirst(pTbls); x; x=sqliteHashNext(x)){
Table *pTab = sqliteHashData(x);
Index *pIdx, *pPk;
Index *pPrior = 0;
int loopTop;
int iDataCur, iIdxCur;
int r1 = -1;
if( pTab->tnum<1 ) continue;
pPk = HasRowid(pTab) ? 0 : sqlite3PrimaryKeyIndex(pTab);
sqlite3OpenTableAndIndices(pParse, pTab, OP_OpenRead, 0,
1, 0, &iDataCur, &iIdxCur);
sqlite3VdbeAddOp2(v, OP_Integer, 0, 7);
for(j=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, j++){
sqlite3VdbeAddOp2(v, OP_Integer, 0, 8+j);
}
assert( pParse->nMem>=8+j );
assert( sqlite3NoTempsInRange(pParse,1,7+j) );
sqlite3VdbeAddOp2(v, OP_Rewind, iDataCur, 0); VdbeCoverage(v);
loopTop = sqlite3VdbeAddOp2(v, OP_AddImm, 7, 1);
if( !isQuick ){
sqlite3VdbeAddOp3(v, OP_Column, iDataCur, pTab->nNVCol-1,3);
sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);
}
for(j=0; j<pTab->nCol; j++){
char *zErr;
int jmp2;
if( j==pTab->iPKey ) continue;
if( pTab->aCol[j].notNull==0 ) continue;
sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, j, 3);
sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);
jmp2 = sqlite3VdbeAddOp1(v, OP_NotNull, 3); VdbeCoverage(v);
zErr = sqlite3MPrintf(db, ""NULL value in %s.%s"", pTab->zName,
pTab->aCol[j].zName);
sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0, zErr, P4_DYNAMIC);
integrityCheckResultRow(v);
sqlite3VdbeJumpHere(v, jmp2);
}
if( pTab->pCheck && (db->flags & SQLITE_IgnoreChecks)==0 ){
ExprList *pCheck = sqlite3ExprListDup(db, pTab->pCheck, 0);
if( db->mallocFailed==0 ){
int addrCkFault = sqlite3VdbeMakeLabel(pParse);
int addrCkOk = sqlite3VdbeMakeLabel(pParse);
char *zErr;
int k;
pParse->iSelfTab = iDataCur + 1;
for(k=pCheck->nExpr-1; k>0; k--){
sqlite3ExprIfFalse(pParse, pCheck->a[k].pExpr, addrCkFault, 0);
}
sqlite3ExprIfTrue(pParse, pCheck->a[0].pExpr, addrCkOk,
SQLITE_JUMPIFNULL);
sqlite3VdbeResolveLabel(v, addrCkFault);
pParse->iSelfTab = 0;
zErr = sqlite3MPrintf(db, ""CHECK constraint failed in %s"",
pTab->zName);
sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0, zErr, P4_DYNAMIC);
integrityCheckResultRow(v);
sqlite3VdbeResolveLabel(v, addrCkOk);
}
sqlite3ExprListDelete(db, pCheck);
}
if( !isQuick ){
for(j=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, j++){
int jmp2, jmp3, jmp4, jmp5;
int ckUniq = sqlite3VdbeMakeLabel(pParse);
if( pPk==pIdx ) continue;
r1 = sqlite3GenerateIndexKey(pParse, pIdx, iDataCur, 0, 0, &jmp3,
pPrior, r1);
pPrior = pIdx;
sqlite3VdbeAddOp2(v, OP_AddImm, 8+j, 1);
jmp2 = sqlite3VdbeAddOp4Int(v, OP_Found, iIdxCur+j, ckUniq, r1,
pIdx->nColumn); VdbeCoverage(v);
sqlite3VdbeLoadString(v, 3, ""row "");
sqlite3VdbeAddOp3(v, OP_Concat, 7, 3, 3);
sqlite3VdbeLoadString(v, 4, "" missing from index "");
sqlite3VdbeAddOp3(v, OP_Concat, 4, 3, 3);
jmp5 = sqlite3VdbeLoadString(v, 4, pIdx->zName);
sqlite3VdbeAddOp3(v, OP_Concat, 4, 3, 3);
jmp4 = integrityCheckResultRow(v);
sqlite3VdbeJumpHere(v, jmp2);
if( IsUniqueIndex(pIdx) ){
int uniqOk = sqlite3VdbeMakeLabel(pParse);
int jmp6;
int kk;
for(kk=0; kk<pIdx->nKeyCol; kk++){
int iCol = pIdx->aiColumn[kk];
assert( iCol!=XN_ROWID && iCol<pTab->nCol );
if( iCol>=0 && pTab->aCol[iCol].notNull ) continue;
sqlite3VdbeAddOp2(v, OP_IsNull, r1+kk, uniqOk);
VdbeCoverage(v);
}
jmp6 = sqlite3VdbeAddOp1(v, OP_Next, iIdxCur+j); VdbeCoverage(v);
sqlite3VdbeGoto(v, uniqOk);
sqlite3VdbeJumpHere(v, jmp6);
sqlite3VdbeAddOp4Int(v, OP_IdxGT, iIdxCur+j, uniqOk, r1,
pIdx->nKeyCol); VdbeCoverage(v);
sqlite3VdbeLoadString(v, 3, ""non-unique entry in index "");
sqlite3VdbeGoto(v, jmp5);
sqlite3VdbeResolveLabel(v, uniqOk);
}
sqlite3VdbeJumpHere(v, jmp4);
sqlite3ResolvePartIdxLabel(pParse, jmp3);
}
}
sqlite3VdbeAddOp2(v, OP_Next, iDataCur, loopTop); VdbeCoverage(v);
sqlite3VdbeJumpHere(v, loopTop-1);
#ifndef SQLITE_OMIT_BTREECOUNT
if( !isQuick ){
sqlite3VdbeLoadString(v, 2, ""wrong # of entries in index "");
for(j=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, j++){
if( pPk==pIdx ) continue;
sqlite3VdbeAddOp2(v, OP_Count, iIdxCur+j, 3);
addr = sqlite3VdbeAddOp3(v, OP_Eq, 8+j, 0, 3); VdbeCoverage(v);
sqlite3VdbeChangeP5(v, SQLITE_NOTNULL);
sqlite3VdbeLoadString(v, 4, pIdx->zName);
sqlite3VdbeAddOp3(v, OP_Concat, 4, 2, 3);
integrityCheckResultRow(v);
sqlite3VdbeJumpHere(v, addr);
}
}
#endif /* SQLITE_OMIT_BTREECOUNT */
}
}
{
static const int iLn = VDBE_OFFSET_LINENO(2);
static const VdbeOpList endCode[] = {
{ OP_AddImm,      1, 0,        0},
{ OP_IfNotZero,   1, 4,        0},
{ OP_String8,     0, 3,        0},
{ OP_ResultRow,   3, 1,        0},
{ OP_Halt,        0, 0,        0},
{ OP_String8,     0, 3,        0},
{ OP_Goto,        0, 3,        0},
};
VdbeOp *aOp;
aOp = sqlite3VdbeAddOpList(v, ArraySize(endCode), endCode, iLn);
if( aOp ){
aOp[0].p2 = 1-mxErr;
aOp[2].p4type = P4_STATIC;
aOp[2].p4.z = ""ok"";
aOp[5].p4type = P4_STATIC;
aOp[5].p4.z = (char*)sqlite3ErrStr(SQLITE_CORRUPT);
}
sqlite3VdbeChangeP3(v, 0, sqlite3VdbeCurrentAddr(v)-2);
}
}
break;
#endif /* SQLITE_OMIT_INTEGRITY_CHECK */
#ifndef SQLITE_OMIT_UTF16
case PragTyp_ENCODING: {
static const struct EncName {
char *zName;
u8 enc;
} encnames[] = {
{ ""UTF8"",     SQLITE_UTF8        },
{ ""UTF-8"",    SQLITE_UTF8        },
{ ""UTF-16le"", SQLITE_UTF16LE     },
{ ""UTF-16be"", SQLITE_UTF16BE     },
{ ""UTF16le"",  SQLITE_UTF16LE     },
{ ""UTF16be"",  SQLITE_UTF16BE     },
{ ""UTF-16"",   0                  },
{ ""UTF16"",    0                  },
{ 0, 0 }
};
const struct EncName *pEnc;
if( !zRight ){
if( sqlite3ReadSchema(pParse) ) goto pragma_out;
assert( encnames[SQLITE_UTF8].enc==SQLITE_UTF8 );
assert( encnames[SQLITE_UTF16LE].enc==SQLITE_UTF16LE );
assert( encnames[SQLITE_UTF16BE].enc==SQLITE_UTF16BE );
returnSingleText(v, encnames[ENC(pParse->db)].zName);
}else{
if(
!(DbHasProperty(db, 0, DB_SchemaLoaded)) ||
DbHasProperty(db, 0, DB_Empty)
){
for(pEnc=&encnames[0]; pEnc->zName; pEnc++){
if( 0==sqlite3StrICmp(zRight, pEnc->zName) ){
SCHEMA_ENC(db) = ENC(db) =
pEnc->enc ? pEnc->enc : SQLITE_UTF16NATIVE;
break;
}
}
if( !pEnc->zName ){
sqlite3ErrorMsg(pParse, ""unsupported encoding: %s"", zRight);
}
}
}
}
break;
#endif /* SQLITE_OMIT_UTF16 */
#ifndef SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS
case PragTyp_HEADER_VALUE: {
int iCookie = pPragma->iArg;
sqlite3VdbeUsesBtree(v, iDb);
if( zRight && (pPragma->mPragFlg & PragFlg_ReadOnly)==0 ){
static const VdbeOpList setCookie[] = {
{ OP_Transaction,    0,  1,  0},
{ OP_SetCookie,      0,  0,  0},
};
VdbeOp *aOp;
sqlite3VdbeVerifyNoMallocRequired(v, ArraySize(setCookie));
aOp = sqlite3VdbeAddOpList(v, ArraySize(setCookie), setCookie, 0);
if( ONLY_IF_REALLOC_STRESS(aOp==0) ) break;
aOp[0].p1 = iDb;
aOp[1].p1 = iDb;
aOp[1].p2 = iCookie;
aOp[1].p3 = sqlite3Atoi(zRight);
}else{
static const VdbeOpList readCookie[] = {
{ OP_Transaction,     0,  0,  0},
{ OP_ReadCookie,      0,  1,  0},
{ OP_ResultRow,       1,  1,  0}
};
VdbeOp *aOp;
sqlite3VdbeVerifyNoMallocRequired(v, ArraySize(readCookie));
aOp = sqlite3VdbeAddOpList(v, ArraySize(readCookie),readCookie,0);
if( ONLY_IF_REALLOC_STRESS(aOp==0) ) break;
aOp[0].p1 = iDb;
aOp[1].p1 = iDb;
aOp[1].p3 = iCookie;
sqlite3VdbeReusable(v);
}
}
break;
#endif /* SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS */
#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS
case PragTyp_COMPILE_OPTIONS: {
int i = 0;
const char *zOpt;
pParse->nMem = 1;
while( (zOpt = sqlite3_compileoption_get(i++))!=0 ){
sqlite3VdbeLoadString(v, 1, zOpt);
sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 1);
}
sqlite3VdbeReusable(v);
}
break;
#endif /* SQLITE_OMIT_COMPILEOPTION_DIAGS */
#ifndef SQLITE_OMIT_WAL
case PragTyp_WAL_CHECKPOINT: {
int iBt = (pId2->z?iDb:SQLITE_MAX_ATTACHED);
int eMode = SQLITE_CHECKPOINT_PASSIVE;
if( zRight ){
if( sqlite3StrICmp(zRight, ""full"")==0 ){
eMode = SQLITE_CHECKPOINT_FULL;
}else if( sqlite3StrICmp(zRight, ""restart"")==0 ){
eMode = SQLITE_CHECKPOINT_RESTART;
}else if( sqlite3StrICmp(zRight, ""truncate"")==0 ){
eMode = SQLITE_CHECKPOINT_TRUNCATE;
}
}
pParse->nMem = 3;
sqlite3VdbeAddOp3(v, OP_Checkpoint, iBt, eMode, 1);
sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 3);
}
break;
case PragTyp_WAL_AUTOCHECKPOINT: {
if( zRight ){
sqlite3_wal_autocheckpoint(db, sqlite3Atoi(zRight));
}
returnSingleInt(v,
db->xWalCallback==sqlite3WalDefaultHook ?
SQLITE_PTR_TO_INT(db->pWalArg) : 0);
}
break;
#endif
case PragTyp_SHRINK_MEMORY: {
sqlite3_db_release_memory(db);
break;
}
case PragTyp_OPTIMIZE: {
int iDbLast;
int iTabCur;
HashElem *k;
Schema *pSchema;
Table *pTab;
Index *pIdx;
LogEst szThreshold;
char *zSubSql;
u32 opMask;
if( zRight ){
opMask = (u32)sqlite3Atoi(zRight);
if( (opMask & 0x02)==0 ) break;
}else{
opMask = 0xfffe;
}
iTabCur = pParse->nTab++;
for(iDbLast = zDb?iDb:db->nDb-1; iDb<=iDbLast; iDb++){
if( iDb==1 ) continue;
sqlite3CodeVerifySchema(pParse, iDb);
pSchema = db->aDb[iDb].pSchema;
for(k=sqliteHashFirst(&pSchema->tblHash); k; k=sqliteHashNext(k)){
pTab = (Table*)sqliteHashData(k);
if( (pTab->tabFlags & TF_StatsUsed)==0 ) continue;
szThreshold = pTab->nRowLogEst + 46; assert( sqlite3LogEst(25)==46 );
for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
if( !pIdx->hasStat1 ){
szThreshold = 0;
break;
}
}
if( szThreshold ){
sqlite3OpenTable(pParse, iTabCur, iDb, pTab, OP_OpenRead);
sqlite3VdbeAddOp3(v, OP_IfSmaller, iTabCur,
sqlite3VdbeCurrentAddr(v)+2+(opMask&1), szThreshold);
VdbeCoverage(v);
}
zSubSql = sqlite3MPrintf(db, ""ANALYZE \""%w\"".\""%w\"""",
db->aDb[iDb].zDbSName, pTab->zName);
if( opMask & 0x01 ){
int r1 = sqlite3GetTempReg(pParse);
sqlite3VdbeAddOp4(v, OP_String8, 0, r1, 0, zSubSql, P4_DYNAMIC);
sqlite3VdbeAddOp2(v, OP_ResultRow, r1, 1);
}else{
sqlite3VdbeAddOp4(v, OP_SqlExec, 0, 0, 0, zSubSql, P4_DYNAMIC);
}
}
}
sqlite3VdbeAddOp0(v, OP_Expire);
break;
}
default: {
assert( pPragma->ePragTyp==PragTyp_BUSY_TIMEOUT );
if( zRight ){
sqlite3_busy_timeout(db, sqlite3Atoi(zRight));
}
returnSingleInt(v, db->busyTimeout);
break;
}
case PragTyp_SOFT_HEAP_LIMIT: {
sqlite3_int64 N;
if( zRight && sqlite3DecOrHexToI64(zRight, &N)==SQLITE_OK ){
sqlite3_soft_heap_limit64(N);
}
returnSingleInt(v, sqlite3_soft_heap_limit64(-1));
break;
}
case PragTyp_HARD_HEAP_LIMIT: {
sqlite3_int64 N;
if( zRight && sqlite3DecOrHexToI64(zRight, &N)==SQLITE_OK ){
sqlite3_int64 iPrior = sqlite3_hard_heap_limit64(-1);
if( N>0 && (iPrior==0 || iPrior>N) ) sqlite3_hard_heap_limit64(N);
}
returnSingleInt(v, sqlite3_hard_heap_limit64(-1));
break;
}
case PragTyp_THREADS: {
sqlite3_int64 N;
if( zRight
&& sqlite3DecOrHexToI64(zRight, &N)==SQLITE_OK
&& N>=0
){
sqlite3_limit(db, SQLITE_LIMIT_WORKER_THREADS, (int)(N&0x7fffffff));
}
returnSingleInt(v, sqlite3_limit(db, SQLITE_LIMIT_WORKER_THREADS, -1));
break;
}
#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)
case PragTyp_LOCK_STATUS: {
static const char *const azLockName[] = {
""unlocked"", ""shared"", ""reserved"", ""pending"", ""exclusive""
};
int i;
pParse->nMem = 2;
for(i=0; i<db->nDb; i++){
Btree *pBt;
const char *zState = ""unknown"";
int j;
if( db->aDb[i].zDbSName==0 ) continue;
pBt = db->aDb[i].pBt;
if( pBt==0 || sqlite3BtreePager(pBt)==0 ){
zState = ""closed"";
}else if( sqlite3_file_control(db, i ? db->aDb[i].zDbSName : 0,
SQLITE_FCNTL_LOCKSTATE, &j)==SQLITE_OK ){
zState = azLockName[j];
}
sqlite3VdbeMultiLoad(v, 1, ""ss"", db->aDb[i].zDbSName, zState);
}
break;
}
#endif
#ifdef SQLITE_HAS_CODEC
case PragTyp_KEY: {
if( zRight ){
char zBuf[40];
const char *zKey = zRight;
int n;
if( pPragma->iArg==2 || pPragma->iArg==3 ){
u8 iByte;
int i;
for(i=0, iByte=0; i<sizeof(zBuf)*2 && sqlite3Isxdigit(zRight[i]); i++){
iByte = (iByte<<4) + sqlite3HexToInt(zRight[i]);
if( (i&1)!=0 ) zBuf[i/2] = iByte;
}
zKey = zBuf;
n = i/2;
}else{
n = pPragma->iArg<4 ? sqlite3Strlen30(zRight) : -1;
}
if( (pPragma->iArg & 1)==0 ){
rc = sqlite3_key_v2(db, zDb, zKey, n);
}else{
rc = sqlite3_rekey_v2(db, zDb, zKey, n);
}
if( rc==SQLITE_OK && n!=0 ){
sqlite3VdbeSetNumCols(v, 1);
sqlite3VdbeSetColName(v, 0, COLNAME_NAME, ""ok"", SQLITE_STATIC);
returnSingleText(v, ""ok"");
}
}
break;
}
#endif
#if defined(SQLITE_HAS_CODEC) || defined(SQLITE_ENABLE_CEROD)
case PragTyp_ACTIVATE_EXTENSIONS: if( zRight ){
#ifdef SQLITE_HAS_CODEC
if( sqlite3StrNICmp(zRight, ""see-"", 4)==0 ){
sqlite3_activate_see(&zRight[4]);
}
#endif
#ifdef SQLITE_ENABLE_CEROD
if( sqlite3StrNICmp(zRight, ""cerod-"", 6)==0 ){
sqlite3_activate_cerod(&zRight[6]);
}
#endif
}
break;
#endif
}
if( (pPragma->mPragFlg & PragFlg_NoColumns1) && zRight ){
sqlite3VdbeVerifyNoResultRow(v);
}
pragma_out:
sqlite3DbFree(db, zLeft);
sqlite3DbFree(db, zRight);
}",[902],pragma.c in SQLite through 3.30.1 mishandles NOT NULL in an integrity_check PRAGMA command in certain cases of generated columns.,sqlite,CVE-2019-19646,CWE-754
7397,5856,"idn2_to_ascii_4i (const uint32_t * input, size_t inlen, char * output, int flags)
{
uint32_t *input_u32;
uint8_t *input_u8, *output_u8;
size_t length;
int rc;
if (!input)
{
if (output)
*output = 0;
return IDN2_OK;
}
input_u32 = (uint32_t *) malloc ((inlen + 1) * sizeof(uint32_t));
if (!input_u32)
return IDN2_MALLOC;
u32_cpy (input_u32, input, inlen);
input_u32[inlen] = 0;
input_u8 = u32_to_u8 (input_u32, inlen + 1, NULL, &length);
free (input_u32);
if (!input_u8)
{
if (errno == ENOMEM)
return IDN2_MALLOC;
return IDN2_ENCODING_ERROR;
}
rc = idn2_lookup_u8 (input_u8, &output_u8, flags);
free (input_u8);
if (rc == IDN2_OK)
{
if (output)
strcpy (output, (const char *) output_u8);
free(output_u8);
}
return rc;
}","[30, 31, 32]",idn2_to_ascii_4i in lib/lookup.c in GNU libidn2 before 2.1.1 has a heap-based buffer overflow via a long domain string.,libidn2,CVE-2019-18224,CWE-787
7410,8004,"GF_Err stbl_GetSampleInfos(GF_SampleTableBox *stbl, u32 sampleNumber, u64 *offset, u32 *chunkNumber, u32 *descIndex, GF_StscEntry **out_ent)
{
GF_Err e;
u32 i, k, offsetInChunk, size, chunk_num;
GF_ChunkOffsetBox *stco;
GF_ChunkLargeOffsetBox *co64;
GF_StscEntry *ent;
(*offset) = 0;
(*chunkNumber) = (*descIndex) = 0;
if (out_ent) (*out_ent) = NULL;
if (!stbl || !sampleNumber) return GF_BAD_PARAM;
if (!stbl->ChunkOffset || !stbl->SampleToChunk || !stbl->SampleSize) return GF_ISOM_INVALID_FILE;
if (stbl->SampleSize && stbl->SampleToChunk->nb_entries == stbl->SampleSize->sampleCount) {
ent = &stbl->SampleToChunk->entries[sampleNumber-1];
if (!ent) return GF_BAD_PARAM;
(*descIndex) = ent->sampleDescriptionIndex;
(*chunkNumber) = sampleNumber;
if (out_ent) *out_ent = ent;
if ( stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {
stco = (GF_ChunkOffsetBox *)stbl->ChunkOffset;
if (!stco->offsets) return GF_ISOM_INVALID_FILE;
(*offset) = (u64) stco->offsets[sampleNumber - 1];
} else {
co64 = (GF_ChunkLargeOffsetBox *)stbl->ChunkOffset;
if (!co64->offsets) return GF_ISOM_INVALID_FILE;
(*offset) = co64->offsets[sampleNumber - 1];
}
return GF_OK;
}
if (stbl->SampleToChunk->firstSampleInCurrentChunk &&
(stbl->SampleToChunk->firstSampleInCurrentChunk <= sampleNumber)) {
i = stbl->SampleToChunk->currentIndex;
ent = &stbl->SampleToChunk->entries[stbl->SampleToChunk->currentIndex];
GetGhostNum(ent, i, stbl->SampleToChunk->nb_entries, stbl);
k = stbl->SampleToChunk->currentChunk;
}
else {
i = 0;
stbl->SampleToChunk->currentIndex = 0;
stbl->SampleToChunk->currentChunk = 1;
stbl->SampleToChunk->ghostNumber = 1;
stbl->SampleToChunk->firstSampleInCurrentChunk = 1;
ent = &stbl->SampleToChunk->entries[0];
GetGhostNum(ent, 0, stbl->SampleToChunk->nb_entries, stbl);
k = stbl->SampleToChunk->currentChunk;
}
for (; i < stbl->SampleToChunk->nb_entries; i++) {
assert(stbl->SampleToChunk->firstSampleInCurrentChunk <= sampleNumber);
if (k > stbl->SampleToChunk->ghostNumber) {
return GF_ISOM_INVALID_FILE;
}
u32 max_chunks_in_entry = stbl->SampleToChunk->ghostNumber - k;
u32 nb_chunks_for_sample = sampleNumber - stbl->SampleToChunk->firstSampleInCurrentChunk;
if (ent->samplesPerChunk)
nb_chunks_for_sample /= ent->samplesPerChunk;
if (
(nb_chunks_for_sample <= max_chunks_in_entry)
&& (stbl->SampleToChunk->firstSampleInCurrentChunk + (nb_chunks_for_sample+1) * ent->samplesPerChunk > sampleNumber)
) {
stbl->SampleToChunk->firstSampleInCurrentChunk += nb_chunks_for_sample * ent->samplesPerChunk;
stbl->SampleToChunk->currentChunk += nb_chunks_for_sample;
goto sample_found;
}
max_chunks_in_entry += 1;
stbl->SampleToChunk->firstSampleInCurrentChunk += max_chunks_in_entry * ent->samplesPerChunk;
stbl->SampleToChunk->currentChunk += max_chunks_in_entry;
if (i+1 != stbl->SampleToChunk->nb_entries) {
ent = &stbl->SampleToChunk->entries[i+1];
GetGhostNum(ent, i+1, stbl->SampleToChunk->nb_entries, stbl);
stbl->SampleToChunk->currentIndex = i+1;
stbl->SampleToChunk->currentChunk = 1;
k = 1;
}
}
return GF_ISOM_INVALID_FILE;
sample_found:
(*descIndex) = ent->sampleDescriptionIndex;
(*chunkNumber) = chunk_num = ent->firstChunk + stbl->SampleToChunk->currentChunk - 1;
if (out_ent) *out_ent = ent;
if (! *chunkNumber)
return GF_ISOM_INVALID_FILE;
offsetInChunk = 0;
if (stbl->SampleSize && stbl->SampleSize->sampleSize) {
u32 diff = sampleNumber - stbl->SampleToChunk->firstSampleInCurrentChunk;
offsetInChunk += diff * stbl->SampleSize->sampleSize;
} else if ((stbl->r_last_chunk_num == chunk_num) && (stbl->r_last_sample_num == sampleNumber)) {
offsetInChunk = stbl->r_last_offset_in_chunk;
} else if ((stbl->r_last_chunk_num == chunk_num) && (stbl->r_last_sample_num + 1 == sampleNumber)) {
e = stbl_GetSampleSize(stbl->SampleSize, stbl->r_last_sample_num, &size);
if (e) return e;
stbl->r_last_offset_in_chunk += size;
stbl->r_last_sample_num = sampleNumber;
offsetInChunk = stbl->r_last_offset_in_chunk;
} else {
for (i = stbl->SampleToChunk->firstSampleInCurrentChunk; i < sampleNumber; i++) {
e = stbl_GetSampleSize(stbl->SampleSize, i, &size);
if (e) return e;
offsetInChunk += size;
}
stbl->r_last_chunk_num = chunk_num;
stbl->r_last_sample_num = sampleNumber;
stbl->r_last_offset_in_chunk = offsetInChunk;
}
if ( stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {
stco = (GF_ChunkOffsetBox *)stbl->ChunkOffset;
if (stco->nb_entries < (*chunkNumber) ) return GF_ISOM_INVALID_FILE;
(*offset) = (u64) stco->offsets[(*chunkNumber) - 1] + (u64) offsetInChunk;
} else {
co64 = (GF_ChunkLargeOffsetBox *)stbl->ChunkOffset;
if (co64->nb_entries < (*chunkNumber) ) return GF_ISOM_INVALID_FILE;
(*offset) = co64->offsets[(*chunkNumber) - 1] + (u64) offsetInChunk;
}
return GF_OK;
}","[22, 26]",Memory leak in the stbl_GetSampleInfos function in MP4Box in GPAC 1.0.1 allows attackers to read memory via a crafted file.,gpac,CVE-2021-31256,CWE-401
7413,7213,"static void handle_PORT(ctrl_t *ctrl, char *str)
{
int a, b, c, d, e, f;
char addr[INET_ADDRSTRLEN];
struct sockaddr_in sin;
if (ctrl->data_sd > 0) {
uev_io_stop(&ctrl->data_watcher);
close(ctrl->data_sd);
ctrl->data_sd = -1;
}
sscanf(str, ""%d,%d,%d,%d,%d,%d"", &a, &b, &c, &d, &e, &f);
sprintf(addr, ""%d.%d.%d.%d"", a, b, c, d);
if (!inet_aton(addr, &(sin.sin_addr))) {
ERR(0, ""Invalid address '%s' given to PORT command"", addr);
send_msg(ctrl->sd, ""500 Illegal PORT command.\r\n"");
return;
}
strlcpy(ctrl->data_address, addr, sizeof(ctrl->data_address));
ctrl->data_port = e * 256 + f;
DBG(""Client PORT command accepted for %s:%d"", ctrl->data_address, ctrl->data_port);
send_msg(ctrl->sd, ""200 PORT command successful.\r\n"");
}",[12],An unauthenticated stack-based buffer overflow vulnerability in common.c's handle_PORT in uftpd FTP server versions 2.10 and earlier can be abused to cause a crash and could potentially lead to remote code execution.,uftpd,CVE-2020-20276,CWE-787
7425,5989,"static int whereIndexExprTransColumn(Walker *p, Expr *pExpr){
if( pExpr->op==TK_COLUMN ){
IdxExprTrans *pX = p->u.pIdxTrans;
if( pExpr->iTable==pX->iTabCur && pExpr->iColumn==pX->iTabCol ){
pExpr->iTable = pX->iIdxCur;
pExpr->iColumn = pX->iIdxCol;
pExpr->y.pTab = 0;
}
}
return WRC_Continue;
}",[5],"SQLite 3.30.1 mishandles pExpr->y.pTab, as demonstrated by the TK_COLUMN case in sqlite3ExprCodeTarget in expr.c.",sqlite,CVE-2019-19242,CWE-476
7431,5801,"parse_char_class(Node** np, PToken* tok, UChar** src, UChar* end, ScanEnv* env)
{
int r, neg, len, fetched, and_start;
OnigCodePoint v, vs;
UChar *p;
Node* node;
CClassNode *cc, *prev_cc;
CClassNode work_cc;
enum CCSTATE state;
enum CCVALTYPE val_type, in_type;
int val_israw, in_israw;
*np = NULL_NODE;
env->parse_depth++;
if (env->parse_depth > ParseDepthLimit)
return ONIGERR_PARSE_DEPTH_LIMIT_OVER;
prev_cc = (CClassNode* )NULL;
r = fetch_token_in_cc(tok, src, end, env);
if (r == TK_CHAR && tok->u.c == '^' && tok->escaped == 0) {
neg = 1;
r = fetch_token_in_cc(tok, src, end, env);
}
else {
neg = 0;
}
if (r < 0) return r;
if (r == TK_CC_CLOSE) {
if (! code_exist_check((OnigCodePoint )']',
*src, env->pattern_end, 1, env))
return ONIGERR_EMPTY_CHAR_CLASS;
CC_ESC_WARN(env, (UChar* )""]"");
r = tok->type = TK_CHAR;
}
*np = node = node_new_cclass();
CHECK_NULL_RETURN_MEMERR(node);
cc = CCLASS_(node);
and_start = 0;
state = CCS_START;
p = *src;
while (r != TK_CC_CLOSE) {
fetched = 0;
switch (r) {
case TK_CHAR:
any_char_in:
len = ONIGENC_CODE_TO_MBCLEN(env->enc, tok->u.c);
if (len > 1) {
in_type = CCV_CODE_POINT;
}
else if (len < 0) {
r = len;
goto err;
}
else {
in_type = CCV_SB;
}
v = (OnigCodePoint )tok->u.c;
in_israw = 0;
goto val_entry2;
break;
case TK_RAW_BYTE:
if (! ONIGENC_IS_SINGLEBYTE(env->enc) && tok->base != 0) {
int i, j;
UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN];
UChar* bufe = buf + ONIGENC_CODE_TO_MBC_MAXLEN;
UChar* psave = p;
int base = tok->base;
buf[0] = tok->u.c;
for (i = 1; i < ONIGENC_MBC_MAXLEN(env->enc); i++) {
r = fetch_token_in_cc(tok, &p, end, env);
if (r < 0) goto err;
if (r != TK_RAW_BYTE || tok->base != base) {
fetched = 1;
break;
}
buf[i] = tok->u.c;
}
if (i < ONIGENC_MBC_MINLEN(env->enc)) {
r = ONIGERR_TOO_SHORT_MULTI_BYTE_STRING;
goto err;
}
for (j = i; j < ONIGENC_CODE_TO_MBC_MAXLEN; j++) buf[j] = '\0';
len = enclen(env->enc, buf);
if (i < len) {
r = ONIGERR_TOO_SHORT_MULTI_BYTE_STRING;
goto err;
}
else if (i > len) {
p = psave;
for (i = 1; i < len; i++) {
r = fetch_token_in_cc(tok, &p, end, env);
}
fetched = 0;
}
if (i == 1) {
v = (OnigCodePoint )buf[0];
goto raw_single;
}
else {
v = ONIGENC_MBC_TO_CODE(env->enc, buf, bufe);
in_type = CCV_CODE_POINT;
}
}
else {
v = (OnigCodePoint )tok->u.c;
raw_single:
in_type = CCV_SB;
}
in_israw = 1;
goto val_entry2;
break;
case TK_CODE_POINT:
v = tok->u.code;
in_israw = 1;
val_entry:
len = ONIGENC_CODE_TO_MBCLEN(env->enc, v);
if (len < 0) {
r = len;
goto err;
}
in_type = (len == 1 ? CCV_SB : CCV_CODE_POINT);
val_entry2:
r = next_state_val(cc, &vs, v, &val_israw, in_israw, in_type, &val_type,
&state, env);
if (r != 0) goto err;
break;
case TK_POSIX_BRACKET_OPEN:
r = parse_posix_bracket(cc, &p, end, env);
if (r < 0) goto err;
if (r == 1) {
CC_ESC_WARN(env, (UChar* )""["");
p = tok->backp;
v = (OnigCodePoint )tok->u.c;
in_israw = 0;
goto val_entry;
}
goto next_class;
break;
case TK_CHAR_TYPE:
r = add_ctype_to_cc(cc, tok->u.prop.ctype, tok->u.prop.not, env);
if (r != 0) goto err;
next_class:
r = next_state_class(cc, &vs, &val_type, &state, env);
if (r != 0) goto err;
break;
case TK_CHAR_PROPERTY:
{
int ctype = fetch_char_property_to_ctype(&p, end, env);
if (ctype < 0) {
r = ctype;
goto err;
}
r = add_ctype_to_cc(cc, ctype, tok->u.prop.not, env);
if (r != 0) goto err;
goto next_class;
}
break;
case TK_CC_RANGE:
if (state == CCS_VALUE) {
r = fetch_token_in_cc(tok, &p, end, env);
if (r < 0) goto err;
fetched = 1;
if (r == TK_CC_CLOSE) {
range_end_val:
v = (OnigCodePoint )'-';
in_israw = 0;
goto val_entry;
}
else if (r == TK_CC_AND) {
CC_ESC_WARN(env, (UChar* )""-"");
goto range_end_val;
}
if (val_type == CCV_CLASS) {
r = ONIGERR_UNMATCHED_RANGE_SPECIFIER_IN_CHAR_CLASS;
goto err;
}
state = CCS_RANGE;
}
else if (state == CCS_START) {
v = (OnigCodePoint )tok->u.c;
in_israw = 0;
r = fetch_token_in_cc(tok, &p, end, env);
if (r < 0) goto err;
fetched = 1;
if (r == TK_CC_RANGE || and_start != 0)
CC_ESC_WARN(env, (UChar* )""-"");
goto val_entry;
}
else if (state == CCS_RANGE) {
CC_ESC_WARN(env, (UChar* )""-"");
goto any_char_in;
}
else {
r = fetch_token_in_cc(tok, &p, end, env);
if (r < 0) goto err;
fetched = 1;
if (r == TK_CC_CLOSE) goto range_end_val;
else if (r == TK_CC_AND) {
CC_ESC_WARN(env, (UChar* )""-"");
goto range_end_val;
}
if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_DOUBLE_RANGE_OP_IN_CC)) {
CC_ESC_WARN(env, (UChar* )""-"");
goto range_end_val;
}
r = ONIGERR_UNMATCHED_RANGE_SPECIFIER_IN_CHAR_CLASS;
goto err;
}
break;
case TK_CC_CC_OPEN:
{
Node *anode;
CClassNode* acc;
r = parse_char_class(&anode, tok, &p, end, env);
if (r != 0) {
onig_node_free(anode);
goto cc_open_err;
}
acc = CCLASS_(anode);
r = or_cclass(cc, acc, env->enc);
onig_node_free(anode);
cc_open_err:
if (r != 0) goto err;
}
break;
case TK_CC_AND:
{
if (state == CCS_VALUE) {
r = next_state_val(cc, &vs, 0, &val_israw, 0, val_type,
&val_type, &state, env);
if (r != 0) goto err;
}
and_start = 1;
state = CCS_START;
if (IS_NOT_NULL(prev_cc)) {
r = and_cclass(prev_cc, cc, env->enc);
if (r != 0) goto err;
bbuf_free(cc->mbuf);
}
else {
prev_cc = cc;
cc = &work_cc;
}
initialize_cclass(cc);
}
break;
case TK_EOT:
r = ONIGERR_PREMATURE_END_OF_CHAR_CLASS;
goto err;
break;
default:
r = ONIGERR_PARSER_BUG;
goto err;
break;
}
if (fetched)
r = tok->type;
else {
r = fetch_token_in_cc(tok, &p, end, env);
if (r < 0) goto err;
}
}
if (state == CCS_VALUE) {
r = next_state_val(cc, &vs, 0, &val_israw, 0, val_type,
&val_type, &state, env);
if (r != 0) goto err;
}
if (IS_NOT_NULL(prev_cc)) {
r = and_cclass(prev_cc, cc, env->enc);
if (r != 0) goto err;
bbuf_free(cc->mbuf);
cc = prev_cc;
}
if (neg != 0)
NCCLASS_SET_NOT(cc);
else
NCCLASS_CLEAR_NOT(cc);
if (IS_NCCLASS_NOT(cc) &&
IS_SYNTAX_BV(env->syntax, ONIG_SYN_NOT_NEWLINE_IN_NEGATIVE_CC)) {
int is_empty = (IS_NULL(cc->mbuf) ? 1 : 0);
if (is_empty != 0)
BITSET_IS_EMPTY(cc->bs, is_empty);
if (is_empty == 0) {
#define NEWLINE_CODE    0x0a
if (ONIGENC_IS_CODE_NEWLINE(env->enc, NEWLINE_CODE)) {
if (ONIGENC_CODE_TO_MBCLEN(env->enc, NEWLINE_CODE) == 1)
BITSET_SET_BIT(cc->bs, NEWLINE_CODE);
else
add_code_range(&(cc->mbuf), env, NEWLINE_CODE, NEWLINE_CODE);
}
}
}
*src = p;
env->parse_depth--;
return 0;
err:
if (cc != CCLASS_(*np))
bbuf_free(cc->mbuf);
return r;
}",[16],Oniguruma before 6.9.3 allows Stack Exhaustion in regcomp.c because of recursion in regparse.c.,oniguruma,CVE-2019-16163,CWE-674
7434,8579,"sd_markdown_new(
unsigned int extensions,
size_t max_nesting,
size_t max_table_cols,
const struct sd_callbacks *callbacks,
void *opaque)
{
struct sd_markdown *md = NULL;
assert(max_nesting > 0 && max_table_cols > 0 && callbacks);
md = malloc(sizeof(struct sd_markdown));
if (!md)
return NULL;
memcpy(&md->cb, callbacks, sizeof(struct sd_callbacks));
stack_init(&md->work_bufs[BUFFER_BLOCK], 4);
stack_init(&md->work_bufs[BUFFER_SPAN], 8);
memset(md->active_char, 0x0, 256);
if (md->cb.emphasis || md->cb.double_emphasis || md->cb.triple_emphasis) {
md->active_char['*'] = MD_CHAR_EMPHASIS;
md->active_char['_'] = MD_CHAR_EMPHASIS;
md->active_char['>'] = MD_CHAR_EMPHASIS;
if (extensions & MKDEXT_STRIKETHROUGH)
md->active_char['~'] = MD_CHAR_EMPHASIS;
}
if (md->cb.codespan)
md->active_char['`'] = MD_CHAR_CODESPAN;
if (md->cb.linebreak)
md->active_char['\n'] = MD_CHAR_LINEBREAK;
if (md->cb.image || md->cb.link)
md->active_char['['] = MD_CHAR_LINK;
md->active_char['<'] = MD_CHAR_LANGLE;
md->active_char['\\'] = MD_CHAR_ESCAPE;
md->active_char['&'] = MD_CHAR_ENTITITY;
if (extensions & MKDEXT_AUTOLINK) {
if (!(extensions & MKDEXT_NO_EMAIL_AUTOLINK))
md->active_char['@'] = MD_CHAR_AUTOLINK_EMAIL;
md->active_char[':'] = MD_CHAR_AUTOLINK_URL;
md->active_char['w'] = MD_CHAR_AUTOLINK_WWW;
md->active_char['/'] = MD_CHAR_AUTOLINK_SUBREDDIT_OR_USERNAME;
}
if (extensions & MKDEXT_SUPERSCRIPT)
md->active_char['^'] = MD_CHAR_SUPERSCRIPT;
md->ext_flags = extensions;
md->opaque = opaque;
md->max_nesting = max_nesting;
md->max_table_cols = max_table_cols;
md->in_link_body = 0;
return md;
}",[13],"Snudown is a reddit-specific fork of the Sundown Markdown parser used by GitHub, with Python integration added. In affected versions snudown was found to be vulnerable to denial of service attacks to its reference table implementation. References written in markdown ` [reference_name]: https://www.example.com` are inserted into a hash table which was found to have a weak hash function, meaning that an attacker can reliably generate a large number of collisions for it. This makes the hash table vulnerable to a hash-collision DoS attack, a type of algorithmic complexity attack. Further the hash table allowed for duplicate entries resulting in long retrieval times. Proofs of concept and further discussion of the hash collision issue are discussed on the snudown GHSA(https://github.com/reddit/snudown/security/advisories/GHSA-6gvv-9q92-w5f6). Users are advised to update to version 1.7.0.",snudown,CVE-2021-41168,CWE-407
7441,7733,"archive_write_disk_set_acls(struct archive *a, int fd, const char *name,
struct archive_acl *abstract_acl, __LA_MODE_T mode)
{
int  ret = ARCHIVE_OK;
(void)mode;
if ((archive_acl_types(abstract_acl)
& ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {
ret = set_acl(a, fd, name, abstract_acl,
ARCHIVE_ENTRY_ACL_TYPE_POSIX1E, ""posix1e"");
return (ret);
}
#if ARCHIVE_ACL_SUNOS_NFS4
else if ((archive_acl_types(abstract_acl) &
ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {
ret = set_acl(a, fd, name, abstract_acl,
ARCHIVE_ENTRY_ACL_TYPE_NFS4, ""nfs4"");
}
#endif
return (ret);
}","[8, 15]","An improper link resolution flaw while extracting an archive can lead to changing the access control list (ACL) of the target of the link. An attacker may provide a malicious archive to a victim user, who would trigger this flaw when trying to extract the archive. A local attacker may use this flaw to change the ACL of a file on the system and gain more privileges.",libarchive,CVE-2021-23177,CWE-59
7461,8036,"GF_Err gf_isom_get_text_description(GF_ISOFile *movie, u32 trackNumber, u32 descriptionIndex, GF_TextSampleDescriptor **out_desc)
{
GF_TrackBox *trak;
u32 i;
Bool is_qt_text = GF_FALSE;
GF_Tx3gSampleEntryBox *txt;
if (!descriptionIndex || !out_desc) return GF_BAD_PARAM;
trak = gf_isom_get_track_from_file(movie, trackNumber);
if (!trak || !trak->Media) return GF_BAD_PARAM;
switch (trak->Media->handler->handlerType) {
case GF_ISOM_MEDIA_TEXT:
case GF_ISOM_MEDIA_SUBT:
break;
default:
return GF_BAD_PARAM;
}
txt = (GF_Tx3gSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, descriptionIndex - 1);
if (!txt) return GF_BAD_PARAM;
switch (txt->type) {
case GF_ISOM_BOX_TYPE_TX3G:
break;
case GF_ISOM_BOX_TYPE_TEXT:
is_qt_text = GF_TRUE;
break;
default:
return GF_BAD_PARAM;
}
(*out_desc) = (GF_TextSampleDescriptor *) gf_odf_desc_new(GF_ODF_TX3G_TAG);
if (! (*out_desc) ) return GF_OUT_OF_MEM;
(*out_desc)->back_color = txt->back_color;
(*out_desc)->default_pos = txt->default_box;
(*out_desc)->default_style = txt->default_style;
(*out_desc)->displayFlags = txt->displayFlags;
(*out_desc)->vert_justif = txt->vertical_justification;
(*out_desc)->horiz_justif = txt->horizontal_justification;
if (is_qt_text) {
GF_TextSampleEntryBox *qt_txt = (GF_TextSampleEntryBox *) txt;
if (qt_txt->textName) {
(*out_desc)->font_count = 1;
(*out_desc)->fonts = (GF_FontRecord *) gf_malloc(sizeof(GF_FontRecord));
(*out_desc)->fonts[0].fontName = gf_strdup(qt_txt->textName);
}
} else {
(*out_desc)->font_count = txt->font_table->entry_count;
(*out_desc)->fonts = (GF_FontRecord *) gf_malloc(sizeof(GF_FontRecord) * txt->font_table->entry_count);
for (i=0; i<txt->font_table->entry_count; i++) {
(*out_desc)->fonts[i].fontID = txt->font_table->fonts[i].fontID;
if (txt->font_table->fonts[i].fontName)
(*out_desc)->fonts[i].fontName = gf_strdup(txt->font_table->fonts[i].fontName);
}
}
return GF_OK;
}","[5, 6, 23, 30, 31, 32, 33, 34, 35, 36, 37, 44]",The gf_isom_vp_config_get function in GPAC 1.0.1 allows attackers to cause a denial of service (NULL pointer dereference) via a crafted file in the MP4Box command.,gpac,CVE-2021-32139,CWE-476
7477,5992,"str_lower_case_match(OnigEncoding enc, int case_fold_flag,
const UChar* t, const UChar* tend,
const UChar* p, const UChar* end)
{
int lowlen;
UChar *q, lowbuf[ONIGENC_MBC_CASE_FOLD_MAXLEN];
while (t < tend) {
lowlen = ONIGENC_MBC_CASE_FOLD(enc, case_fold_flag, &p, end, lowbuf);
q = lowbuf;
while (lowlen > 0) {
if (*t++ != *q++) return 0;
lowlen--;
}
}
return 1;
}",[11],"Oniguruma through 6.9.3, as used in PHP 7.3.x and other products, has a heap-based buffer over-read in str_lower_case_match in regexec.c.",oniguruma,CVE-2019-19246,CWE-125
7480,9854,"void SFS_ObjectMethodCall(ScriptParser *parser)
{
if (parser->codec->LastError) return;
SFS_Expression(parser);
SFS_AddString(parser, ""."");
SFS_Identifier(parser);
SFS_AddString(parser, ""("");
SFS_Params(parser);
SFS_AddString(parser, "")"");
}",[5],Uncontrolled Recursion in GitHub repository gpac/gpac prior to 2.1.0-DEV.,gpac,CVE-2022-3222,CWE-674
7492,7461,"parse_user_name(char *user_input, char **ret_username)
{
register char *ptr;
register int index = 0;
char username[PAM_MAX_RESP_SIZE];
*ret_username = NULL;
bzero((void *)username, PAM_MAX_RESP_SIZE);
ptr = user_input;
while ((*ptr == ' ') || (*ptr == '\t'))
ptr++;
if (*ptr == '\0') {
return (PAM_BUF_ERR);
}
while (*ptr != '\0') {
if ((*ptr == ' ') || (*ptr == '\t'))
break;
else {
username[index] = *ptr;
index++;
ptr++;
}
}
if ((*ret_username = malloc(index + 1)) == NULL)
return (PAM_BUF_ERR);
(void) strcpy(*ret_username, username);
return (PAM_SUCCESS);
}","[15, 17, 23, 25]","An issue was discovered in illumos before 2020-10-22, as used in OmniOS before r151030by, r151032ay, and r151034y and SmartOS before 20201022. There is a buffer overflow in parse_user_name in lib/libpam/pam_framework.c.",illumos-gate,CVE-2020-27678,CWE-120
7498,8034,"GF_Err Media_CheckDataEntry(GF_MediaBox *mdia, u32 dataEntryIndex)
{
GF_DataEntryURLBox *entry;
GF_DataMap *map;
GF_Err e;
if (!mdia || !dataEntryIndex || dataEntryIndex > gf_list_count(mdia->information->dataInformation->dref->child_boxes)) return GF_BAD_PARAM;
entry = (GF_DataEntryURLBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataEntryIndex - 1);
if (!entry) return GF_ISOM_INVALID_FILE;
if (entry->flags == 1) return GF_OK;
if (entry->type == GF_ISOM_BOX_TYPE_URN) return GF_NOT_SUPPORTED;
if (mdia->mediaTrack->moov->mov->openMode == GF_ISOM_OPEN_WRITE) {
e = gf_isom_datamap_new(entry->location, NULL, GF_ISOM_DATA_MAP_READ, &map);
} else {
e = gf_isom_datamap_new(entry->location, mdia->mediaTrack->moov->mov->fileName, GF_ISOM_DATA_MAP_READ, &map);
}
if (e) return e;
gf_isom_datamap_del(map);
return GF_OK;
}",[10],Heap buffer overflow in the URL_GetProtocolType function in MP4Box in GPAC 1.0.1 allows attackers to cause a denial of service or execute arbitrary code via a crafted file.,gpac,CVE-2021-32137,CWE-787
7501,7814,"void fmtutil_macbitmap_read_pixmap_only_fields(deark *c, dbuf *f, struct fmtutil_macbitmap_info *bi,
i64 pos)
{
i64 pixmap_version;
i64 pack_size;
i64 plane_bytes;
i64 n;
de_dbg(c, ""additional PixMap header fields, at %d"", (int)pos);
de_dbg_indent(c, 1);
pixmap_version = dbuf_getu16be(f, pos+0);
de_dbg(c, ""pixmap version: %d"", (int)pixmap_version);
bi->packing_type = dbuf_getu16be(f, pos+2);
de_dbg(c, ""packing type: %d"", (int)bi->packing_type);
pack_size = dbuf_getu32be(f, pos+4);
de_dbg(c, ""pixel data length: %d"", (int)pack_size);
bi->hdpi = pict_read_fixed(f, pos+8);
bi->vdpi = pict_read_fixed(f, pos+12);
de_dbg(c, ""dpi: %.2f""DE_CHAR_TIMES""%.2f"", bi->hdpi, bi->vdpi);
bi->pixeltype = dbuf_getu16be(f, pos+16);
bi->pixelsize = dbuf_getu16be(f, pos+18);
bi->cmpcount = dbuf_getu16be(f, pos+20);
bi->cmpsize = dbuf_getu16be(f, pos+22);
de_dbg(c, ""pixel type=%d, bits/pixel=%d, components/pixel=%d, bits/comp=%d"",
(int)bi->pixeltype, (int)bi->pixelsize, (int)bi->cmpcount, (int)bi->cmpsize);
bi->pdwidth = (bi->rowbytes*8)/bi->pixelsize;
if(bi->pdwidth < bi->npwidth) {
bi->pdwidth = bi->npwidth;
}
plane_bytes = dbuf_getu32be(f, pos+24);
de_dbg(c, ""plane bytes: %d"", (int)plane_bytes);
bi->pmTable = (u32)dbuf_getu32be(f, pos+28);
de_dbg(c, ""pmTable: 0x%08x"", (unsigned int)bi->pmTable);
n = dbuf_getu32be(f, pos+32);
de_dbg(c, ""pmReserved: 0x%08x"", (unsigned int)n);
de_dbg_indent(c, -1);
}",[25],"In Deark before v1.5.8, a specially crafted input file can cause a division by zero in (src/fmtutil.c) because of the value of pixelsize.",deark,CVE-2021-28856,CWE-369
7508,7553,"void CleanWriters(GF_List *writers)
{
while (gf_list_count(writers)) {
TrackWriter *writer = (TrackWriter*)gf_list_get(writers, 0);
gf_isom_box_del(writer->stco);
gf_isom_box_del((GF_Box *)writer->stsc);
gf_free(writer);
gf_list_rem(writers, 0);
}
}",[5],An issue was discovered in GPAC version 0.8.0 and 1.0.1. There is a use-after-free in the function gf_isom_box_del() in isomedia/box_funcs.c.,gpac,CVE-2020-35980,CWE-416
7517,1851,"sonmp_decode(struct lldpd *cfg, char *frame, int s,
struct lldpd_hardware *hardware,
struct lldpd_chassis **newchassis, struct lldpd_port **newport)
{
const u_int8_t mcastaddr[] = SONMP_MULTICAST_ADDR;
struct lldpd_chassis *chassis;
struct lldpd_port *port;
struct lldpd_mgmt *mgmt;
int length, i;
u_int8_t *pos;
u_int8_t seg[3], rchassis;
struct in_addr address;
log_debug(""sonmp"", ""decode SONMP PDU from %s"",
hardware->h_ifname);
if ((chassis = calloc(1, sizeof(struct lldpd_chassis))) == NULL) {
log_warn(""sonmp"", ""failed to allocate remote chassis"");
return -1;
}
TAILQ_INIT(&chassis->c_mgmt);
if ((port = calloc(1, sizeof(struct lldpd_port))) == NULL) {
log_warn(""sonmp"", ""failed to allocate remote port"");
free(chassis);
return -1;
}
#ifdef ENABLE_DOT1
TAILQ_INIT(&port->p_vlans);
#endif
length = s;
pos = (u_int8_t*)frame;
if (length < SONMP_SIZE) {
log_warnx(""sonmp"", ""too short SONMP frame received on %s"", hardware->h_ifname);
goto malformed;
}
if (PEEK_CMP(mcastaddr, sizeof(mcastaddr)) != 0)
goto malformed;
PEEK_DISCARD(ETHER_ADDR_LEN); PEEK_DISCARD_UINT16;
PEEK_DISCARD(6);
if (PEEK_UINT16 != LLC_PID_SONMP_HELLO) {
log_debug(""sonmp"", ""incorrect LLC protocol ID received for SONMP on %s"",
hardware->h_ifname);
goto malformed;
}
chassis->c_id_subtype = LLDP_CHASSISID_SUBTYPE_ADDR;
if ((chassis->c_id = calloc(1, sizeof(struct in_addr) + 1)) == NULL) {
log_warn(""sonmp"", ""unable to allocate memory for chassis id on %s"",
hardware->h_ifname);
goto malformed;
}
chassis->c_id_len = sizeof(struct in_addr) + 1;
chassis->c_id[0] = 1;
PEEK_BYTES(&address, sizeof(struct in_addr));
memcpy(chassis->c_id + 1, &address, sizeof(struct in_addr));
if (asprintf(&chassis->c_name, ""%s"", inet_ntoa(address)) == -1) {
log_warnx(""sonmp"", ""unable to write chassis name for %s"",
hardware->h_ifname);
goto malformed;
}
PEEK_BYTES(seg, sizeof(seg));
rchassis = PEEK_UINT8;
for (i=0; sonmp_chassis_types[i].type != 0; i++) {
if (sonmp_chassis_types[i].type == rchassis)
break;
}
if (asprintf(&chassis->c_descr, ""%s"",
sonmp_chassis_types[i].description) == -1) {
log_warnx(""sonmp"", ""unable to write chassis description for %s"",
hardware->h_ifname);
goto malformed;
}
mgmt = lldpd_alloc_mgmt(LLDPD_AF_IPV4, &address, sizeof(struct in_addr), 0);
if (mgmt == NULL) {
assert(errno == ENOMEM);
log_warn(""sonmp"", ""unable to allocate memory for management address"");
goto malformed;
}
TAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt, m_entries);
chassis->c_ttl = cfg?(cfg->g_config.c_tx_interval * cfg->g_config.c_tx_hold):
LLDPD_TTL;
port->p_id_subtype = LLDP_PORTID_SUBTYPE_LOCAL;
if (asprintf(&port->p_id, ""%02x-%02x-%02x"",
seg[0], seg[1], seg[2]) == -1) {
log_warn(""sonmp"", ""unable to allocate memory for port id on %s"",
hardware->h_ifname);
goto malformed;
}
port->p_id_len = strlen(port->p_id);
if ((seg[0] == 0) && (seg[1] == 0)) {
if (asprintf(&port->p_descr, ""port %d"",
seg[2]) == -1) {
log_warnx(""sonmp"", ""unable to write port description for %s"",
hardware->h_ifname);
goto malformed;
}
} else if (seg[0] == 0) {
if (asprintf(&port->p_descr, ""port %d/%d"",
seg[1], seg[2]) == -1) {
log_warnx(""sonmp"", ""unable to write port description for %s"",
hardware->h_ifname);
goto malformed;
}
} else {
if (asprintf(&port->p_descr, ""port %x:%x:%x"",
seg[0], seg[1], seg[2]) == -1) {
log_warnx(""sonmp"", ""unable to write port description for %s"",
hardware->h_ifname);
goto malformed;
}
}
*newchassis = chassis;
*newport = port;
return 1;
malformed:
lldpd_chassis_cleanup(chassis, 1);
lldpd_port_cleanup(port, 1);
free(port);
return -1;
}","[72, 73]",lldpd before 0.8.0 allows remote attackers to cause a denial of service (assertion failure and daemon crash) via a malformed packet.,lldpd,CVE-2015-8012,CWE-617
7525,8487,"GF_Err iloc_box_read(GF_Box *s, GF_BitStream *bs)
{
u32 item_count, extent_count, i, j;
GF_ItemLocationBox *ptr = (GF_ItemLocationBox *)s;
ISOM_DECREASE_SIZE(ptr, 2)
ptr->offset_size = gf_bs_read_int(bs, 4);
ptr->length_size = gf_bs_read_int(bs, 4);
ptr->base_offset_size = gf_bs_read_int(bs, 4);
if (ptr->version == 1 || ptr->version == 2) {
ptr->index_size = gf_bs_read_int(bs, 4);
} else {
gf_bs_read_int(bs, 4);
}
if (ptr->version < 2) {
ISOM_DECREASE_SIZE(ptr, 2)
item_count = gf_bs_read_u16(bs);
} else {
ISOM_DECREASE_SIZE(ptr, 4)
item_count = gf_bs_read_u32(bs);
}
for (i = 0; i < item_count; i++) {
GF_ItemLocationEntry *location_entry = (GF_ItemLocationEntry *)gf_malloc(sizeof(GF_ItemLocationEntry));
if (!location_entry) return GF_OUT_OF_MEM;
gf_list_add(ptr->location_entries, location_entry);
if (ptr->version < 2) {
ISOM_DECREASE_SIZE(ptr, 2)
location_entry->item_ID = gf_bs_read_u16(bs);
} else {
ISOM_DECREASE_SIZE(ptr, 4)
location_entry->item_ID = gf_bs_read_u32(bs);
}
if (ptr->version == 1 || ptr->version == 2) {
ISOM_DECREASE_SIZE(ptr, 2)
location_entry->construction_method = gf_bs_read_u16(bs);
}
else {
location_entry->construction_method = 0;
}
ISOM_DECREASE_SIZE(ptr, (2 + ptr->base_offset_size) )
location_entry->data_reference_index = gf_bs_read_u16(bs);
location_entry->base_offset = gf_bs_read_int(bs, 8*ptr->base_offset_size);
#ifndef GPAC_DISABLE_ISOM_WRITE
location_entry->original_base_offset = location_entry->base_offset;
#endif
ISOM_DECREASE_SIZE(ptr, 2)
extent_count = gf_bs_read_u16(bs);
location_entry->extent_entries = gf_list_new();
for (j = 0; j < extent_count; j++) {
GF_ItemExtentEntry *extent_entry = (GF_ItemExtentEntry *)gf_malloc(sizeof(GF_ItemExtentEntry));
if (!extent_entry) return GF_OUT_OF_MEM;
gf_list_add(location_entry->extent_entries, extent_entry);
if ((ptr->version == 1 || ptr->version == 2) && ptr->index_size > 0) {
ISOM_DECREASE_SIZE(ptr, ptr->index_size)
extent_entry->extent_index = gf_bs_read_int(bs, 8 * ptr->index_size);
}
else {
extent_entry->extent_index = 0;
}
ISOM_DECREASE_SIZE(ptr, (ptr->offset_size+ptr->length_size) )
extent_entry->extent_offset = gf_bs_read_int(bs, 8*ptr->offset_size);
extent_entry->extent_length = gf_bs_read_int(bs, 8*ptr->length_size);
#ifndef GPAC_DISABLE_ISOM_WRITE
extent_entry->original_extent_offset = extent_entry->extent_offset;
#endif
}
}
return GF_OK;
}","[22, 49]","The binary MP4Box in Gpac through 1.0.1 has a double-free vulnerability in the iloc_entry_del funciton in box_code_meta.c, which allows attackers to cause a denial of service.",gpac,CVE-2021-40569,CWE-415
7528,8494,"GF_Err mpgviddmx_process(GF_Filter *filter)
{
GF_MPGVidDmxCtx *ctx = gf_filter_get_udta(filter);
GF_FilterPacket *pck, *dst_pck;
u64 byte_offset;
s64 vosh_start = -1;
s64 vosh_end = -1;
GF_Err e;
char *data;
u8 *start;
u32 pck_size;
s32 remain;
if (!ctx->duration.num)
mpgviddmx_check_dur(filter, ctx);
pck = gf_filter_pid_get_packet(ctx->ipid);
if (!pck) {
if (gf_filter_pid_is_eos(ctx->ipid)) {
mpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_TRUE);
if (ctx->opid)
gf_filter_pid_set_eos(ctx->opid);
if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);
ctx->src_pck = NULL;
return GF_EOS;
}
return GF_OK;
}
data = (char *) gf_filter_pck_get_data(pck, &pck_size);
byte_offset = gf_filter_pck_get_byte_offset(pck);
start = data;
remain = pck_size;
if (!ctx->resume_from && ctx->timescale) {
u64 ts = gf_filter_pck_get_cts(pck);
if (ts != GF_FILTER_NO_TS) {
if (!ctx->cts || !ctx->recompute_cts)
ctx->cts = ts;
}
ts = gf_filter_pck_get_dts(pck);
if (ts != GF_FILTER_NO_TS) {
if (!ctx->dts || !ctx->recompute_cts)
ctx->dts = ts;
if (!ctx->prev_dts) ctx->prev_dts = ts;
else if (ctx->prev_dts != ts) {
u64 diff = ts;
diff -= ctx->prev_dts;
if (!ctx->cur_fps.den) ctx->cur_fps.den = (u32) diff;
else if (ctx->cur_fps.den > diff)
ctx->cur_fps.den = (u32) diff;
}
}
gf_filter_pck_get_framing(pck, &ctx->input_is_au_start, &ctx->input_is_au_end);
if (ctx->recompute_cts) ctx->input_is_au_start = GF_FALSE;
if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);
ctx->src_pck = pck;
gf_filter_pck_ref_props(&ctx->src_pck);
}
if (!ctx->resume_from && ctx->hdr_store_size) {
if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size) {
ctx->hdr_store_alloc = ctx->hdr_store_size + pck_size;
ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);
}
memcpy(ctx->hdr_store + ctx->hdr_store_size, data, sizeof(char)*pck_size);
if (byte_offset != GF_FILTER_NO_BO) {
if (byte_offset >= ctx->hdr_store_size)
byte_offset -= ctx->hdr_store_size;
else
byte_offset = GF_FILTER_NO_BO;
}
ctx->hdr_store_size += pck_size;
start = data = ctx->hdr_store;
remain = pck_size = ctx->hdr_store_size;
}
if (ctx->resume_from) {
if (gf_filter_pid_would_block(ctx->opid))
return GF_OK;
if (ctx->hdr_store_size) {
assert(ctx->resume_from <= ctx->hdr_store_size);
start = data = ctx->hdr_store + ctx->resume_from;
remain = pck_size = ctx->hdr_store_size - ctx->resume_from;
} else {
assert(remain >= (s32) ctx->resume_from);
start += ctx->resume_from;
remain -= ctx->resume_from;
}
ctx->resume_from = 0;
}
if (!ctx->bs) {
ctx->bs = gf_bs_new(start, remain, GF_BITSTREAM_READ);
} else {
gf_bs_reassign_buffer(ctx->bs, start, remain);
}
if (!ctx->vparser) {
ctx->vparser = gf_m4v_parser_bs_new(ctx->bs, ctx->is_mpg12);
}
while (remain) {
Bool full_frame;
u8 *pck_data;
s32 current;
u8 sc_type, forced_sc_type=0;
Bool sc_type_forced = GF_FALSE;
Bool skip_pck = GF_FALSE;
u8 ftype;
u32 tinc;
u64 size=0;
u64 fstart;
Bool is_coded;
u32 bytes_from_store = 0;
u32 hdr_offset = 0;
Bool copy_last_bytes = GF_FALSE;
if (remain<5) {
memcpy(ctx->hdr_store, start, remain);
ctx->bytes_in_header = remain;
break;
}
current = -1;
if (ctx->bytes_in_header) {
memcpy(ctx->hdr_store + ctx->bytes_in_header, start, 8 - ctx->bytes_in_header);
current = mpgviddmx_next_start_code(ctx->hdr_store, 8);
if ((current<0) || (current >= (s32) ctx->bytes_in_header) )  {
if (ctx->opid) {
dst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header, &pck_data);
if (!dst_pck) return GF_OUT_OF_MEM;
if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);
memcpy(pck_data, ctx->hdr_store, ctx->bytes_in_header);
gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);
if (byte_offset != GF_FILTER_NO_BO) {
gf_filter_pck_set_byte_offset(dst_pck, byte_offset - ctx->bytes_in_header);
}
mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
}
if (current<0) current = -1;
else current -= ctx->bytes_in_header;
ctx->bytes_in_header = 0;
} else {
hdr_offset = 4 - ctx->bytes_in_header + current;
bytes_from_store = ctx->bytes_in_header;
ctx->bytes_in_header = 0;
if (!hdr_offset) {
forced_sc_type = ctx->hdr_store[current+3];
} else {
forced_sc_type = start[hdr_offset-1];
}
sc_type_forced = GF_TRUE;
}
}
if (current == -1) {
current = mpgviddmx_next_start_code(start, remain);
if (current<0) {
u8 b3, b2, b1;
if (! ctx->frame_started) {
GF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (""[MPGVid] no start code in block and no frame started, discarding data\n"" ));
break;
}
size = remain;
b3 = start[remain-3];
b2 = start[remain-2];
b1 = start[remain-1];
if (!b1 || !b2 || !b3) {
copy_last_bytes = GF_TRUE;
assert(size >= 3);
size -= 3;
ctx->bytes_in_header = 3;
}
dst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data);
if (!dst_pck) return GF_OUT_OF_MEM;
if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
memcpy(pck_data, start, (size_t) size);
gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);
gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);
if (byte_offset != GF_FILTER_NO_BO) {
gf_filter_pck_set_byte_offset(dst_pck, byte_offset);
}
mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
if (copy_last_bytes) {
memcpy(ctx->hdr_store, start+remain-3, 3);
}
break;
}
}
assert(current>=0);
if ((vosh_start>=0) && current) {
assert(remain>=current);
start += current;
remain -= current;
current = 0;
}
if (!ctx->opid && current) {
assert(remain>=current);
start += current;
remain -= current;
current = 0;
}
if (current>0) {
dst_pck = gf_filter_pck_new_alloc(ctx->opid, current, &pck_data);
if (!dst_pck) return GF_OUT_OF_MEM;
if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);
gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_TRUE);
if (bytes_from_store) {
if (byte_offset != GF_FILTER_NO_BO) {
gf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store);
}
assert(bytes_from_store>=(u32) current);
bytes_from_store -= current;
memcpy(pck_data, ctx->hdr_store, current);
} else {
if (byte_offset != GF_FILTER_NO_BO) {
gf_filter_pck_set_byte_offset(dst_pck, byte_offset);
}
memcpy(pck_data, start, current);
assert(remain>=current);
start += current;
remain -= current;
current = 0;
}
gf_filter_pck_set_carousel_version(dst_pck, 1);
mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
}
if (sc_type_forced) {
gf_bs_reassign_buffer(ctx->bs, start + hdr_offset, remain - hdr_offset);
sc_type = forced_sc_type;
} else {
gf_bs_reassign_buffer(ctx->bs, start, remain);
gf_bs_read_int(ctx->bs, 24);
sc_type = gf_bs_read_int(ctx->bs, 8);
}
if (ctx->is_mpg12) {
switch (sc_type) {
case M2V_SEQ_START_CODE:
case M2V_EXT_START_CODE:
gf_bs_reassign_buffer(ctx->bs, start, remain);
e = gf_m4v_parse_config(ctx->vparser, &ctx->dsi);
if (e==GF_EOS) {
if (vosh_start<0) vosh_start = 0;
if (data == ctx->hdr_store) {
memmove(ctx->hdr_store, start, remain);
ctx->hdr_store_size = remain;
} else {
if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {
ctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - vosh_start);
ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);
}
memcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );
ctx->hdr_store_size += pck_size - (u32) vosh_start;
}
gf_filter_pid_drop_packet(ctx->ipid);
return GF_OK;
} else if (e != GF_OK) {
GF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (""[MPGVid] Failed to parse VOS header: %s\n"", gf_error_to_string(e) ));
} else {
mpgviddmx_check_pid(filter, ctx, 0, NULL);
}
break;
case M2V_PIC_START_CODE:
break;
default:
break;
}
} else {
u8 PL;
switch (sc_type) {
case M4V_VOS_START_CODE:
ctx->dsi.VideoPL = (u8) gf_bs_read_u8(ctx->bs);
vosh_start = start - (u8 *)data;
skip_pck = GF_TRUE;
assert(remain>=5);
start += 5;
remain -= 5;
break;
case M4V_VOL_START_CODE:
gf_bs_reassign_buffer(ctx->bs, start, remain);
PL = ctx->dsi.VideoPL;
e = gf_m4v_parse_config(ctx->vparser, &ctx->dsi);
ctx->dsi.VideoPL = PL;
if (e==GF_EOS) {
if (vosh_start<0) vosh_start = 0;
if (data == ctx->hdr_store) {
memmove(ctx->hdr_store, start, remain);
ctx->hdr_store_size = remain;
} else {
if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {
ctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - (u32) vosh_start);
ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);
}
memcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );
ctx->hdr_store_size += pck_size - (u32) vosh_start;
}
gf_filter_pid_drop_packet(ctx->ipid);
return GF_OK;
} else if (e != GF_OK) {
GF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (""[MPGVid] Failed to parse VOS header: %s\n"", gf_error_to_string(e) ));
} else {
u32 obj_size = (u32) gf_m4v_get_object_start(ctx->vparser);
if (vosh_start<0) vosh_start = 0;
vosh_end = start - (u8 *)data + obj_size;
vosh_end -= vosh_start;
mpgviddmx_check_pid(filter, ctx,(u32)  vosh_end, data+vosh_start);
skip_pck = GF_TRUE;
assert(remain>=(s32) obj_size);
start += obj_size;
remain -= obj_size;
}
break;
case M4V_VOP_START_CODE:
case M4V_GOV_START_CODE:
break;
case M4V_VO_START_CODE:
case M4V_VISOBJ_START_CODE:
default:
if (vosh_start>=0) {
skip_pck = GF_TRUE;
assert(remain>=4);
start += 4;
remain -= 4;
}
break;
}
}
if (skip_pck) {
continue;
}
if (!ctx->opid) {
assert(remain>=4);
start += 4;
remain -= 4;
continue;
}
if (!ctx->is_playing) {
ctx->resume_from = (u32) ((char *)start -  (char *)data);
return GF_OK;
}
ctx->hdr_store_size = 0;
if (ctx->in_seek) {
u64 nb_frames_at_seek = (u64) (ctx->start_range * ctx->cur_fps.num);
if (ctx->cts + ctx->cur_fps.den >= nb_frames_at_seek) {
ctx->in_seek = GF_FALSE;
}
}
if (remain<5)
continue;
gf_m4v_parser_reset(ctx->vparser, sc_type_forced ? forced_sc_type + 1 : 0);
size = 0;
e = gf_m4v_parse_frame(ctx->vparser, &ctx->dsi, &ftype, &tinc, &size, &fstart, &is_coded);
if (bytes_from_store) {
size += bytes_from_store + hdr_offset;
}
if ((e == GF_EOS) && !ctx->input_is_au_end) {
u8 b3 = start[remain-3];
u8 b2 = start[remain-2];
u8 b1 = start[remain-1];
if (!b1 || !b2 || !b3) {
copy_last_bytes = GF_TRUE;
assert(size >= 3);
size -= 3;
ctx->bytes_in_header = 3;
}
full_frame = GF_FALSE;
} else {
full_frame = GF_TRUE;
}
if (!is_coded) {
if (ctx->forced_packed && ctx->b_frames) {
ctx->is_packed = GF_TRUE;
assert(remain>=size);
start += size;
remain -= (s32) size;
continue;
}
if (ctx->vfr) {
ctx->is_vfr = GF_TRUE;
mpgviddmx_update_time(ctx);
assert(remain>=size);
start += size;
remain -= (s32) size;
continue;
}
}
if (ftype==2) {
ctx->b_frames++;
ctx->nb_b++;
} else {
mpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_FALSE);
ctx->last_ref_cts = ctx->cts;
if (ctx->max_b < ctx->b_frames) ctx->max_b = ctx->b_frames;
ctx->b_frames = 0;
if (ftype)
ctx->nb_p++;
else
ctx->nb_i++;
}
ctx->nb_frames++;
dst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data);
if (!dst_pck) return GF_OUT_OF_MEM;
if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
if (bytes_from_store) {
memcpy(pck_data, ctx->hdr_store+current, bytes_from_store);
assert(size >= bytes_from_store);
size -= bytes_from_store;
if (byte_offset != GF_FILTER_NO_BO) {
gf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store);
}
memcpy(pck_data + bytes_from_store, start, (size_t) size);
} else {
memcpy(pck_data, start, (size_t) size);
if (byte_offset != GF_FILTER_NO_BO) {
gf_filter_pck_set_byte_offset(dst_pck, byte_offset + start - (u8 *) data);
}
}
assert(pck_data[0] == 0);
assert(pck_data[1] == 0);
assert(pck_data[2] == 0x01);
gf_filter_pck_set_framing(dst_pck, GF_TRUE, (full_frame || ctx->input_is_au_end) ? GF_TRUE : GF_FALSE);
gf_filter_pck_set_cts(dst_pck, ctx->cts);
gf_filter_pck_set_dts(dst_pck, ctx->dts);
if (ctx->input_is_au_start) {
ctx->input_is_au_start = GF_FALSE;
} else {
gf_filter_pck_set_carousel_version(dst_pck, 1);
}
gf_filter_pck_set_sap(dst_pck, ftype ? GF_FILTER_SAP_NONE : GF_FILTER_SAP_1);
gf_filter_pck_set_duration(dst_pck, ctx->cur_fps.den);
if (ctx->in_seek) gf_filter_pck_set_seek_flag(dst_pck, GF_TRUE);
ctx->frame_started = GF_TRUE;
mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
mpgviddmx_update_time(ctx);
if (!full_frame) {
if (copy_last_bytes) {
memcpy(ctx->hdr_store, start+remain-3, 3);
}
break;
}
assert(remain>=size);
start += size;
remain -= (s32) size;
}
gf_filter_pid_drop_packet(ctx->ipid);
return GF_OK;
}",[222],"The binary MP4Box in Gpac 1.0.1 has a null pointer dereference vulnerability in the mpgviddmx_process function in reframe_mpgvid.c, which allows attackers to cause a denial of service. This vulnerability is possibly due to an incomplete fix for CVE-2021-40566.",gpac,CVE-2021-40575,CWE-476
7536,6074,"int sc_pkcs15_decode_prkdf_entry(struct sc_pkcs15_card *p15card,
struct sc_pkcs15_object *obj,
const u8 ** buf, size_t *buflen)
{
sc_context_t *ctx = p15card->card->ctx;
struct sc_pkcs15_prkey_info info;
int r, i, gostr3410_params[3];
struct sc_pkcs15_keyinfo_gostparams *keyinfo_gostparams;
size_t usage_len = sizeof(info.usage);
size_t af_len = sizeof(info.access_flags);
struct sc_asn1_entry asn1_com_key_attr[C_ASN1_COM_KEY_ATTR_SIZE];
struct sc_asn1_entry asn1_com_prkey_attr[C_ASN1_COM_PRKEY_ATTR_SIZE];
struct sc_asn1_entry asn1_rsakey_attr[C_ASN1_RSAKEY_ATTR_SIZE];
struct sc_asn1_entry asn1_prk_rsa_attr[C_ASN1_PRK_RSA_ATTR_SIZE];
struct sc_asn1_entry asn1_dsakey_attr[C_ASN1_DSAKEY_ATTR_SIZE];
struct sc_asn1_entry asn1_prk_dsa_attr[C_ASN1_PRK_DSA_ATTR_SIZE];
struct sc_asn1_entry asn1_dsakey_i_p_attr[C_ASN1_DSAKEY_I_P_ATTR_SIZE];
struct sc_asn1_entry asn1_dsakey_value_attr[C_ASN1_DSAKEY_VALUE_ATTR_SIZE];
struct sc_asn1_entry asn1_gostr3410key_attr[C_ASN1_GOSTR3410KEY_ATTR_SIZE];
struct sc_asn1_entry asn1_prk_gostr3410_attr[C_ASN1_PRK_GOSTR3410_ATTR_SIZE];
struct sc_asn1_entry asn1_ecckey_attr[C_ASN1_ECCKEY_ATTR];
struct sc_asn1_entry asn1_prk_ecc_attr[C_ASN1_PRK_ECC_ATTR];
struct sc_asn1_entry asn1_prkey[C_ASN1_PRKEY_SIZE];
struct sc_asn1_entry asn1_supported_algorithms[C_ASN1_SUPPORTED_ALGORITHMS_SIZE];
struct sc_asn1_pkcs15_object rsa_prkey_obj = {obj, asn1_com_key_attr, asn1_com_prkey_attr, asn1_prk_rsa_attr};
struct sc_asn1_pkcs15_object dsa_prkey_obj = {obj, asn1_com_key_attr, asn1_com_prkey_attr, asn1_prk_dsa_attr};
struct sc_asn1_pkcs15_object gostr3410_prkey_obj = {obj, asn1_com_key_attr, asn1_com_prkey_attr, asn1_prk_gostr3410_attr};
struct sc_asn1_pkcs15_object ecc_prkey_obj = { obj, asn1_com_key_attr, asn1_com_prkey_attr, asn1_prk_ecc_attr };
sc_copy_asn1_entry(c_asn1_prkey, asn1_prkey);
sc_copy_asn1_entry(c_asn1_supported_algorithms, asn1_supported_algorithms);
sc_copy_asn1_entry(c_asn1_prk_rsa_attr, asn1_prk_rsa_attr);
sc_copy_asn1_entry(c_asn1_rsakey_attr, asn1_rsakey_attr);
sc_copy_asn1_entry(c_asn1_prk_dsa_attr, asn1_prk_dsa_attr);
sc_copy_asn1_entry(c_asn1_dsakey_attr, asn1_dsakey_attr);
sc_copy_asn1_entry(c_asn1_dsakey_value_attr, asn1_dsakey_value_attr);
sc_copy_asn1_entry(c_asn1_dsakey_i_p_attr, asn1_dsakey_i_p_attr);
sc_copy_asn1_entry(c_asn1_prk_gostr3410_attr, asn1_prk_gostr3410_attr);
sc_copy_asn1_entry(c_asn1_gostr3410key_attr, asn1_gostr3410key_attr);
sc_copy_asn1_entry(c_asn1_prk_ecc_attr, asn1_prk_ecc_attr);
sc_copy_asn1_entry(c_asn1_ecckey_attr, asn1_ecckey_attr);
sc_copy_asn1_entry(c_asn1_com_prkey_attr, asn1_com_prkey_attr);
sc_copy_asn1_entry(c_asn1_com_key_attr, asn1_com_key_attr);
sc_format_asn1_entry(asn1_prkey + 0, &rsa_prkey_obj, NULL, 0);
sc_format_asn1_entry(asn1_prkey + 1, &ecc_prkey_obj, NULL, 0);
sc_format_asn1_entry(asn1_prkey + 2, &dsa_prkey_obj, NULL, 0);
sc_format_asn1_entry(asn1_prkey + 3, &gostr3410_prkey_obj, NULL, 0);
sc_format_asn1_entry(asn1_prk_rsa_attr + 0, asn1_rsakey_attr, NULL, 0);
sc_format_asn1_entry(asn1_prk_dsa_attr + 0, asn1_dsakey_attr, NULL, 0);
sc_format_asn1_entry(asn1_prk_gostr3410_attr + 0, asn1_gostr3410key_attr, NULL, 0);
sc_format_asn1_entry(asn1_prk_ecc_attr + 0, asn1_ecckey_attr, NULL, 0);
sc_format_asn1_entry(asn1_rsakey_attr + 0, &info.path, NULL, 0);
sc_format_asn1_entry(asn1_rsakey_attr + 1, &info.modulus_length, NULL, 0);
sc_format_asn1_entry(asn1_dsakey_attr + 0, asn1_dsakey_value_attr, NULL, 0);
sc_format_asn1_entry(asn1_dsakey_value_attr + 0, &info.path, NULL, 0);
sc_format_asn1_entry(asn1_dsakey_value_attr + 1, asn1_dsakey_i_p_attr, NULL, 0);
sc_format_asn1_entry(asn1_dsakey_i_p_attr + 0, &info.path, NULL, 0);
sc_format_asn1_entry(asn1_gostr3410key_attr + 0, &info.path, NULL, 0);
sc_format_asn1_entry(asn1_gostr3410key_attr + 1, &gostr3410_params[0], NULL, 0);
sc_format_asn1_entry(asn1_gostr3410key_attr + 2, &gostr3410_params[1], NULL, 0);
sc_format_asn1_entry(asn1_gostr3410key_attr + 3, &gostr3410_params[2], NULL, 0);
sc_format_asn1_entry(asn1_ecckey_attr + 0, &info.path, NULL, 0);
sc_format_asn1_entry(asn1_ecckey_attr + 1, &info.field_length, NULL, 0);
sc_format_asn1_entry(asn1_com_key_attr + 0, &info.id, NULL, 0);
sc_format_asn1_entry(asn1_com_key_attr + 1, &info.usage, &usage_len, 0);
sc_format_asn1_entry(asn1_com_key_attr + 2, &info.native, NULL, 0);
sc_format_asn1_entry(asn1_com_key_attr + 3, &info.access_flags, &af_len, 0);
sc_format_asn1_entry(asn1_com_key_attr + 4, &info.key_reference, NULL, 0);
for (i=0; i<SC_MAX_SUPPORTED_ALGORITHMS && (asn1_supported_algorithms + i)->name; i++)
sc_format_asn1_entry(asn1_supported_algorithms + i, &info.algo_refs[i], NULL, 0);
sc_format_asn1_entry(asn1_com_key_attr + 5, asn1_supported_algorithms, NULL, 0);
sc_format_asn1_entry(asn1_com_prkey_attr + 0, &info.subject.value, &info.subject.len, 0);
memset(&info, 0, sizeof(info));
info.key_reference = -1;
info.native = 1;
memset(gostr3410_params, 0, sizeof(gostr3410_params));
r = sc_asn1_decode_choice(ctx, asn1_prkey, *buf, *buflen, buf, buflen);
if (r < 0) {
if (asn1_com_prkey_attr->flags & SC_ASN1_PRESENT &&
asn1_com_prkey_attr[0].flags & SC_ASN1_PRESENT) {
free(asn1_com_prkey_attr[0].parm);
}
}
if (r == SC_ERROR_ASN1_END_OF_CONTENTS)
return r;
LOG_TEST_RET(ctx, r, ""PrKey DF ASN.1 decoding failed"");
if (asn1_prkey[0].flags & SC_ASN1_PRESENT) {
obj->type = SC_PKCS15_TYPE_PRKEY_RSA;
}
else if (asn1_prkey[1].flags & SC_ASN1_PRESENT) {
obj->type = SC_PKCS15_TYPE_PRKEY_EC;
}
else if (asn1_prkey[2].flags & SC_ASN1_PRESENT) {
obj->type = SC_PKCS15_TYPE_PRKEY_DSA;
if (asn1_dsakey_i_p_attr[0].flags & SC_ASN1_PRESENT)
info.path.type = SC_PATH_TYPE_PATH_PROT;
}
else if (asn1_prkey[3].flags & SC_ASN1_PRESENT) {
obj->type = SC_PKCS15_TYPE_PRKEY_GOSTR3410;
assert(info.modulus_length == 0);
info.modulus_length = SC_PKCS15_GOSTR3410_KEYSIZE;
assert(info.params.len == 0);
info.params.len = sizeof(struct sc_pkcs15_keyinfo_gostparams);
info.params.data = malloc(info.params.len);
if (info.params.data == NULL)
LOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);
assert(sizeof(*keyinfo_gostparams) == info.params.len);
keyinfo_gostparams = info.params.data;
keyinfo_gostparams->gostr3410 = gostr3410_params[0];
keyinfo_gostparams->gostr3411 = gostr3410_params[1];
keyinfo_gostparams->gost28147 = gostr3410_params[2];
}
else {
sc_log(ctx, ""Neither RSA or DSA or GOSTR3410 or ECC key in PrKDF entry."");
LOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_ASN1_OBJECT);
}
if (!p15card->app || !p15card->app->ddo.aid.len)   {
r = sc_pkcs15_make_absolute_path(&p15card->file_app->path, &info.path);
if (r < 0) {
sc_pkcs15_free_key_params(&info.params);
return r;
}
}
else   {
info.path.aid = p15card->app->ddo.aid;
}
sc_log(ctx, ""PrivKey path '%s'"", sc_print_path(&info.path));
if (info.key_reference < -1)
info.key_reference += 256;
if ((obj->flags & SC_PKCS15_CO_FLAG_PRIVATE) && (obj->auth_id.len == 0)) {
sc_log(ctx, ""Private key %s has no auth ID - checking AccessControlRules"",
sc_pkcs15_print_id(&info.id));
for (i = 0; i < SC_PKCS15_MAX_ACCESS_RULES; i++) {
if (obj->access_rules[i].access_mode &
(SC_PKCS15_ACCESS_RULE_MODE_EXECUTE |
SC_PKCS15_ACCESS_RULE_MODE_PSO_CDS |
SC_PKCS15_ACCESS_RULE_MODE_PSO_DECRYPT |
SC_PKCS15_ACCESS_RULE_MODE_INT_AUTH)) {
if (obj->access_rules[i].auth_id.len != 0) {
obj->auth_id = obj->access_rules[i].auth_id;
sc_log(ctx, ""Auth ID found - %s"",
sc_pkcs15_print_id(&obj->auth_id));
break;
}
}
}
if (i == SC_PKCS15_MAX_ACCESS_RULES)
sc_log(ctx, ""Warning: No auth ID found"");
}
obj->data = malloc(sizeof(info));
if (obj->data == NULL) {
sc_pkcs15_free_key_params(&info.params);
LOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);
}
memcpy(obj->data, &info, sizeof(info));
sc_log(ctx, ""Key Subject %s"", sc_dump_hex(info.subject.value, info.subject.len));
sc_log(ctx, ""Key path %s"", sc_print_path(&info.path));
return 0;
}","[78, 79, 80]",An issue was discovered in OpenSC through 0.19.0 and 0.20.x through 0.20.0-rc3. libopensc/pkcs15-prkey.c has an incorrect free operation in sc_pkcs15_decode_prkdf_entry.,OpenSC,CVE-2019-19480,CWE-672
7539,9852,"void SFS_ArrayDeref(ScriptParser *parser)
{
if (parser->codec->LastError) return;
SFS_Expression(parser);
SFS_AddString(parser, ""["");
SFS_CompoundExpression(parser);
SFS_AddString(parser, ""]"");
}",[5],Uncontrolled Recursion in GitHub repository gpac/gpac prior to 2.1.0-DEV.,gpac,CVE-2022-3222,CWE-674
7541,8129,"GF_Err infe_box_read(GF_Box *s, GF_BitStream *bs)
{
char *buf;
u32 buf_len, i, string_len, string_start;
GF_ItemInfoEntryBox *ptr = (GF_ItemInfoEntryBox *)s;
ISOM_DECREASE_SIZE(ptr, 4);
ptr->item_ID = gf_bs_read_u16(bs);
ptr->item_protection_index = gf_bs_read_u16(bs);
if (ptr->version == 2) {
ISOM_DECREASE_SIZE(ptr, 4);
ptr->item_type = gf_bs_read_u32(bs);
}
buf_len = (u32) (ptr->size);
buf = (char*)gf_malloc(buf_len);
if (!buf) return GF_OUT_OF_MEM;
if (buf_len != gf_bs_read_data(bs, buf, buf_len)) {
gf_free(buf);
return GF_ISOM_INVALID_FILE;
}
string_len = 1;
string_start = 0;
for (i = 0; i < buf_len; i++) {
if (buf[i] == 0) {
if (!ptr->item_name) {
ptr->item_name = (char*)gf_malloc(sizeof(char)*string_len);
if (!ptr->item_name) return GF_OUT_OF_MEM;
memcpy(ptr->item_name, buf+string_start, string_len);
} else if (!ptr->content_type) {
ptr->content_type = (char*)gf_malloc(sizeof(char)*string_len);
if (!ptr->content_type) return GF_OUT_OF_MEM;
memcpy(ptr->content_type, buf+string_start, string_len);
} else {
ptr->content_encoding = (char*)gf_malloc(sizeof(char)*string_len);
if (!ptr->content_encoding) return GF_OUT_OF_MEM;
memcpy(ptr->content_encoding, buf+string_start, string_len);
}
string_start += string_len;
string_len = 0;
if (ptr->content_encoding && ptr->version == 1) {
break;
}
}
string_len++;
}
gf_free(buf);
if (!ptr->item_name || (!ptr->content_type && ptr->version < 2)) {
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[isoff] Infe without name or content type !\n""));
}
return GF_OK;
}","[32, 37]",Memory leak in the infe_box_read function in MP4Box in GPAC 1.0.1 allows attackers to read memory via a crafted file.,gpac,CVE-2021-33363,CWE-401
7547,8778,"static void labeljumps(JF, js_JumpList *jump, int baddr, int caddr)
{
while (jump) {
if (jump->type == STM_BREAK)
labelto(J, F, jump->inst, baddr);
if (jump->type == STM_CONTINUE)
labelto(J, F, jump->inst, caddr);
jump = jump->next;
}
}","[3, 4, 8]",Artifex MuJS v1.1.3 was discovered to contain a heap buffer overflow which is caused by conflicting JumpList of nested try/finally statements.,mujs,CVE-2021-45005,CWE-787
7548,7329,"static void nhmldump_send_header(GF_NHMLDumpCtx *ctx)
{
GF_FilterPacket *dst_pck;
char nhml[1024];
u32 size;
u8 *output;
const GF_PropertyValue *p;
ctx->szRootName = ""NHNTStream"";
if (ctx->dims) {
ctx->szRootName = ""DIMSStream"";
}
if (!ctx->filep) {
sprintf(nhml, ""<?xml version=\""1.0\"" encoding=\""UTF-8\"" ?>\n"");
gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));
}
sprintf(nhml, ""<%s version=\""1.0\"" "", ctx->szRootName);
gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));
NHML_PRINT_UINT(GF_PROP_PID_ID, NULL, ""trackID"")
NHML_PRINT_UINT(GF_PROP_PID_TIMESCALE, NULL, ""timeScale"")
p = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_IN_IOD);
if (p && p->value.boolean) {
sprintf(nhml, ""inRootOD=\""yes\"" "");
gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));
}
if (ctx->oti && (ctx->oti<GF_CODECID_LAST_MPEG4_MAPPING)) {
sprintf(nhml, ""streamType=\""%d\"" objectTypeIndication=\""%d\"" "", ctx->streamtype, ctx->oti);
gf_bs_write_data(ctx->bs_w, nhml, (u32)strlen(nhml));
} else {
p = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_SUBTYPE);
if (p) {
sprintf(nhml, ""%s=\""%s\"" "", ""mediaType"", gf_4cc_to_str(p->value.uint));
gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));
NHML_PRINT_4CC(GF_PROP_PID_ISOM_SUBTYPE, ""mediaSubType"", ""mediaSubType"")
} else {
NHML_PRINT_4CC(GF_PROP_PID_CODECID, NULL, ""codecID"")
}
}
if (ctx->w && ctx->h) {
switch (ctx->streamtype) {
case GF_STREAM_VISUAL:
case GF_STREAM_SCENE:
sprintf(nhml, ""width=\""%d\"" height=\""%d\"" "", ctx->w, ctx->h);
gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));
break;
default:
break;
}
}
else if (ctx->sr && ctx->chan) {
sprintf(nhml, ""sampleRate=\""%d\"" numChannels=\""%d\"" "", ctx->sr, ctx->chan);
gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));
sprintf(nhml, ""sampleRate=\""%d\"" numChannels=\""%d\"" "", ctx->sr, ctx->chan);
gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));
p = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_AUDIO_FORMAT);
sprintf(nhml, ""bitsPerSample=\""%d\"" "", gf_audio_fmt_bit_depth(p->value.uint));
gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));
}
NHML_PRINT_4CC(0, ""codec_vendor"", ""codecVendor"")
NHML_PRINT_UINT(0, ""codec_version"", ""codecVersion"")
NHML_PRINT_UINT(0, ""codec_revision"", ""codecRevision"")
NHML_PRINT_STRING(0, ""compressor_name"", ""compressorName"")
NHML_PRINT_UINT(0, ""temporal_quality"", ""temporalQuality"")
NHML_PRINT_UINT(0, ""spatial_quality"", ""spatialQuality"")
NHML_PRINT_UINT(0, ""hres"", ""horizontalResolution"")
NHML_PRINT_UINT(0, ""vres"", ""verticalResolution"")
NHML_PRINT_UINT(GF_PROP_PID_BIT_DEPTH_Y, NULL, ""bitDepth"")
NHML_PRINT_STRING(0, ""meta:xmlns"", ""xml_namespace"")
NHML_PRINT_STRING(0, ""meta:schemaloc"", ""xml_schema_location"")
NHML_PRINT_STRING(0, ""meta:mime"", ""mime_type"")
NHML_PRINT_STRING(0, ""meta:config"", ""config"")
NHML_PRINT_STRING(0, ""meta:aux_mimes"", ""aux_mime_type"")
if (ctx->codecid == GF_CODECID_DIMS) {
if (gf_filter_pid_get_property_str(ctx->ipid, ""meta:xmlns"")==NULL) {
sprintf(nhml, ""xmlns=\""http:www.3gpp.org/richmedia\"" "");
gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));
}
NHML_PRINT_UINT(0, ""dims:profile"", ""profile"")
NHML_PRINT_UINT(0, ""dims:level"", ""level"")
NHML_PRINT_UINT(0, ""dims:pathComponents"", ""pathComponents"")
p = gf_filter_pid_get_property_str(ctx->ipid, ""dims:fullRequestHost"");
if (p) {
sprintf(nhml, ""useFullRequestHost=\""%s\"" "", p->value.boolean ? ""yes"" : ""no"");
gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));
}
p = gf_filter_pid_get_property_str(ctx->ipid, ""dims:streamType"");
if (p) {
sprintf(nhml, ""stream_type=\""%s\"" "", p->value.boolean ? ""primary"" : ""secondary"");
gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));
}
p = gf_filter_pid_get_property_str(ctx->ipid, ""dims:redundant"");
if (p) {
sprintf(nhml, ""contains_redundant=\""%s\"" "", (p->value.uint==1) ? ""main"" : ((p->value.uint==1) ? ""redundant"" : ""main+redundant"") );
gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));
}
NHML_PRINT_UINT(0, ""dims:scriptTypes"", ""scriptTypes"")
}
if (ctx->opid_info) {
sprintf(nhml, ""specificInfoFile=\""%s\"" "", gf_file_basename(ctx->info_file) );
gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));
dst_pck = gf_filter_pck_new_shared(ctx->opid_info, ctx->dcfg, ctx->dcfg_size, NULL);
gf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);
gf_filter_pck_set_readonly(dst_pck);
gf_filter_pck_send(dst_pck);
}
NHML_PRINT_STRING(0, ""meta:encoding"", ""encoding"")
NHML_PRINT_STRING(0, ""meta:contentEncoding"", ""content_encoding"")
ctx->uncompress = GF_FALSE;
if (p) {
if (!strcmp(p->value.string, ""deflate"")) ctx->uncompress = GF_TRUE;
else {
GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (""[NHMLMx] content_encoding %s not supported\n"", p->value.string ));
}
}
if (ctx->opid_mdia) {
sprintf(nhml, ""baseMediaFile=\""%s\"" "", gf_file_basename(ctx->media_file) );
gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));
}
sprintf(nhml, "">\n"");
gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));
gf_bs_get_content_no_truncate(ctx->bs_w, &ctx->nhml_buffer, &size, &ctx->nhml_buffer_size);
if (ctx->filep) {
gf_fwrite(ctx->nhml_buffer, size, ctx->filep);
return;
}
dst_pck = gf_filter_pck_new_alloc(ctx->opid_nhml, size, &output);
memcpy(output, ctx->nhml_buffer, size);
gf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_FALSE);
gf_filter_pck_send(dst_pck);
}",[55],An issue was discovered in gpac through 20200801. A NULL pointer dereference exists in the function nhmldump_send_header located in write_nhml.c. It allows an attacker to cause Denial of Service.,gpac,CVE-2020-23930,CWE-476
7575,6344,"static void *gp_worker_main(void *pvt)
{
struct gp_thread *t = (struct gp_thread *)pvt;
struct gp_query *q = NULL;
char dummy = 0;
int ret;
while (!t->pool->shutdown) {
gp_debug_set_conn_id(0);
pthread_mutex_lock(&t->cond_mutex);
while (t->query == NULL) {
pthread_cond_wait(&t->cond_wakeup, &t->cond_mutex);
if (t->pool->shutdown) {
pthread_exit(NULL);
}
}
q = t->query;
t->query = NULL;
pthread_mutex_unlock(&t->cond_mutex);
gp_debug_set_conn_id(gp_conn_get_cid(q->conn));
GPDEBUGN(3, ""[status] Handling query input: %p (%zu)\n"", q->buffer,
q->buflen);
gp_handle_query(t->pool, q);
GPDEBUGN(3 ,""[status] Handling query output: %p (%zu)\n"", q->buffer,
q->buflen);
pthread_mutex_lock(&t->pool->lock);
q->next = t->pool->reply_list;
t->pool->reply_list = q;
if (!t->pool->shutdown) {
LIST_DEL(t->pool->busy_list, t);
LIST_ADD(t->pool->free_list, t);
}
pthread_mutex_unlock(&t->pool->lock);
ret = write(t->pool->sig_pipe[1], &dummy, 1);
if (ret == -1) {
GPERROR(""Failed to signal dispatcher!"");
}
}
pthread_exit(NULL);
}",[13],"** DISPUTED ** gssproxy (aka gss-proxy) before 0.8.3 does not unlock cond_mutex before pthread exit in gp_worker_main() in gp_workers.c. NOTE: An upstream comment states ""We are already on a shutdown path when running the code in question, so a DoS there doesn't make any sense, and there has been no additional information provided us (as upstream) to indicate why this would be a problem.""",gssproxy,CVE-2020-12658,CWE-667
7576,5368,"static int cbs_av1_read_uvlc(CodedBitstreamContext *ctx, GetBitContext *gbc,
const char *name, uint32_t *write_to,
uint32_t range_min, uint32_t range_max)
{
uint32_t value;
int position, zeroes, i, j;
char bits[65];
if (ctx->trace_enable)
position = get_bits_count(gbc);
zeroes = i = 0;
while (1) {
if (get_bits_left(gbc) < zeroes + 1) {
av_log(ctx->log_ctx, AV_LOG_ERROR, ""Invalid uvlc code at ""
""%s: bitstream ended.\n"", name);
return AVERROR_INVALIDDATA;
}
if (get_bits1(gbc)) {
bits[i++] = '1';
break;
} else {
bits[i++] = '0';
++zeroes;
}
}
if (zeroes >= 32) {
value = MAX_UINT_BITS(32);
} else {
value = get_bits_long(gbc, zeroes);
for (j = 0; j < zeroes; j++)
bits[i++] = (value >> (zeroes - j - 1) & 1) ? '1' : '0';
value += (1 << zeroes) - 1;
}
if (ctx->trace_enable) {
bits[i] = 0;
ff_cbs_trace_syntax_element(ctx, position, name, NULL,
bits, value);
}
if (value < range_min || value > range_max) {
av_log(ctx->log_ctx, AV_LOG_ERROR, ""%s out of range: ""
""%""PRIu32"", but must be in [%""PRIu32"",%""PRIu32""].\n"",
name, value, range_min, range_max);
return AVERROR_INVALIDDATA;
}
*write_to = value;
return 0;
}","[5, 6, 7, 10, 12, 17, 18, 20, 21, 22, 28, 29, 30, 31, 34, 35, 36]",FFMPEG version 4.1 contains a CWE-129: Improper Validation of Array Index vulnerability in libavcodec/cbs_av1.c that can result in Denial of service. This attack appears to be exploitable via specially crafted AV1 file has to be provided as input. This vulnerability appears to have been fixed in after commit b97a4b658814b2de8b9f2a3bce491c002d34de31.,FFmpeg,CVE-2019-1000016,CWE-129
7578,4223,"int   MirrorJob::Do()
{
int  res;
int  m=STALL;
FileInfo *file;
Job  *j;
switch(state)
{
case(INITIAL_STATE):
remove_this_source_dir=(remove_source_dirs && source_dir.last_char()!='/');
if(!strcmp(target_dir,""."") || !strcmp(target_dir,"".."") || (FlagSet(SCAN_ALL_FIRST) && parent_mirror))
create_target_dir=false;
source_session->Chdir(source_dir);
source_redirections=0;
source_session->Roll();
set_state(CHANGING_DIR_SOURCE);
m=MOVED;
case(CHANGING_DIR_SOURCE):
HandleChdir(source_session,source_redirections);
if(state!=CHANGING_DIR_SOURCE)
return MOVED;
if(source_session->IsOpen())
return m;
source_dir.set(source_session->GetCwd().GetDirectory());
pre_MAKE_TARGET_DIR:
{
if(!create_target_dir)
goto pre_CHANGING_DIR_TARGET;
if(target_is_local)
{
struct stat st;
if((FlagSet(RETR_SYMLINKS)?stat:lstat)(target_dir,&st)!=-1)
{
if(S_ISDIR(st.st_mode))
{
if(!script_only && (st.st_mode!=(st.st_mode|0700)))
chmod(target_dir,st.st_mode|0700);
create_target_dir=false;
goto pre_CHANGING_DIR_TARGET;
}
else
{
Report(_(""Removing old local file `%s'""),target_dir.get());
if(script)
{
ArgV args(""rm"");
args.Append(target_session->GetFileURL(target_dir));
xstring_ca cmd(args.CombineQuoted());
fprintf(script,""%s\n"",cmd.get());
}
if(!script_only)
{
if(remove(target_dir)==-1)
eprintf(""mirror: remove(%s): %s\n"",target_dir.get(),strerror(errno));
}
}
}
}
if(FlagSet(DEPTH_FIRST))
goto pre_GETTING_LIST_INFO;
if(target_relative_dir)
Report(_(""Making directory `%s'""),target_relative_dir.get());
bool mkdir_p=(parent_mirror==0 || parent_mirror->create_target_dir);
if(script)
{
ArgV args(""mkdir"");
if(mkdir_p)
args.Append(""-p"");
args.Append(target_session->GetFileURL(target_dir));
xstring_ca cmd(args.CombineQuoted());
fprintf(script,""%s\n"",cmd.get());
if(script_only)
goto pre_CHANGING_DIR_TARGET;
}
target_session->Mkdir(target_dir,mkdir_p);
set_state(MAKE_TARGET_DIR);
m=MOVED;
}
case(MAKE_TARGET_DIR):
res=target_session->Done();
if(res==FA::IN_PROGRESS)
return m;
target_session->Close();
create_target_dir=false;
pre_CHANGING_DIR_TARGET:
target_session->Chdir(target_dir);
target_redirections=0;
target_session->Roll();
set_state(CHANGING_DIR_TARGET);
m=MOVED;
case(CHANGING_DIR_TARGET):
HandleChdir(target_session,target_redirections);
if(state!=CHANGING_DIR_TARGET)
return MOVED;
if(target_session->IsOpen())
return m;
create_target_dir=false;
target_dir.set(target_session->GetCwd().GetDirectory());
pre_GETTING_LIST_INFO:
set_state(GETTING_LIST_INFO);
m=MOVED;
if(!source_set)
HandleListInfoCreation(source_session,source_list_info,source_relative_dir);
if(!target_set && !create_target_dir
&& (!FlagSet(DEPTH_FIRST) || FlagSet(ONLY_EXISTING))
&& !(FlagSet(TARGET_FLAT) && parent_mirror))
HandleListInfoCreation(target_session,target_list_info,target_relative_dir);
if(state!=GETTING_LIST_INFO)
{
source_list_info=0;
target_list_info=0;
}
return m;
case(GETTING_LIST_INFO):
HandleListInfo(source_list_info,source_set);
HandleListInfo(target_list_info,target_set,&target_set_excluded);
if(state!=GETTING_LIST_INFO)
return MOVED;
if(source_list_info || target_list_info)
return m;
MirrorFinished();
if(FlagSet(DEPTH_FIRST) && source_set && !target_set)
{
InitSets();
to_transfer->Unsort();
to_transfer->SubtractNotDirs();
goto pre_WAITING_FOR_TRANSFER;
}
if(parent_mirror)
stats.dirs++;
if(FlagSet(SCAN_ALL_FIRST) && parent_mirror)
{
source_set->PrependPath(source_relative_dir);
if(root_mirror->source_set_recursive)
root_mirror->source_set_recursive->Merge(source_set);
else
root_mirror->source_set_recursive=source_set.borrow();
if(target_set) {
target_set->PrependPath(target_relative_dir);
if(root_mirror->target_set_recursive)
root_mirror->target_set_recursive->Merge(target_set);
else
root_mirror->target_set_recursive=target_set.borrow();
}
if(target_set_excluded) {
target_set_excluded->PrependPath(target_relative_dir);
if(root_mirror->target_set_excluded)
root_mirror->target_set_excluded->Merge(target_set_excluded);
else
root_mirror->target_set_excluded=target_set_excluded.borrow();
}
root_mirror->stats.dirs++;
transfer_count++;
goto pre_DONE;
}
if(source_set_recursive) {
source_set->Merge(source_set_recursive);
source_set_recursive=0;
}
if(target_set_recursive) {
target_set->Merge(target_set_recursive);
target_set_recursive=0;
}
InitSets();
to_transfer->CountBytes(&bytes_to_transfer);
if(parent_mirror)
parent_mirror->AddBytesToTransfer(bytes_to_transfer);
to_rm->Count(&stats.del_dirs,&stats.del_files,&stats.del_symlinks,&stats.del_files);
to_rm->rewind();
to_rm_mismatched->Count(&stats.del_dirs,&stats.del_files,&stats.del_symlinks,&stats.del_files);
to_rm_mismatched->rewind();
target_set->Merge(target_set_excluded);
target_set_excluded=0;
set_state(TARGET_REMOVE_OLD_FIRST);
goto TARGET_REMOVE_OLD_FIRST_label;
pre_TARGET_MKDIR:
if(!to_mkdir)
goto pre_WAITING_FOR_TRANSFER;
to_mkdir->rewind();
set_state(TARGET_MKDIR);
m=MOVED;
case(TARGET_MKDIR):
while((j=FindDoneAwaitedJob())!=0)
{
JobFinished(j);
m=MOVED;
}
if(max_error_count>0 && stats.error_count>=max_error_count)
goto pre_FINISHING;
while(transfer_count<parallel && state==TARGET_MKDIR)
{
file=to_mkdir->curr();
if(!file)
goto pre_WAITING_FOR_TRANSFER;
to_mkdir->next();
if(!file->TypeIs(file->DIRECTORY))
continue;
if(script)
fprintf(script,""mkdir %s\n"",target_session->GetFileURL(file->name).get());
if(!script_only)
{
ArgV *a=new ArgV(""mkdir"");
a->Append(file->name);
mkdirJob *mkj=new mkdirJob(target_session->Clone(),a);
a->CombineTo(mkj->cmdline);
JobStarted(mkj);
m=MOVED;
}
}
break;
pre_WAITING_FOR_TRANSFER:
to_transfer->rewind();
set_state(WAITING_FOR_TRANSFER);
m=MOVED;
case(WAITING_FOR_TRANSFER):
while((j=FindDoneAwaitedJob())!=0)
{
TransferFinished(j);
m=MOVED;
}
if(max_error_count>0 && stats.error_count>=max_error_count)
goto pre_FINISHING;
while(transfer_count<parallel && state==WAITING_FOR_TRANSFER)
{
file=to_transfer->curr();
if(!file)
{
if(waiting_num>0)
break;
if(FlagSet(DEPTH_FIRST))
{
SetFlags(DEPTH_FIRST,false);
SetFlags(NO_RECURSION,true);
if(FlagSet(NO_EMPTY_DIRS) && stats.dirs==0 && only_dirs)
goto pre_FINISHING_FIX_LOCAL;
MirrorStarted();
goto pre_MAKE_TARGET_DIR;
}
goto pre_TARGET_REMOVE_OLD;
}
HandleFile(file);
to_transfer->next();
m=MOVED;
}
break;
pre_TARGET_REMOVE_OLD:
if(FlagSet(REMOVE_FIRST))
goto pre_TARGET_CHMOD;
set_state(TARGET_REMOVE_OLD);
m=MOVED;
case(TARGET_REMOVE_OLD):
case(TARGET_REMOVE_OLD_FIRST):
TARGET_REMOVE_OLD_FIRST_label:
while((j=FindDoneAwaitedJob())!=0)
{
JobFinished(j);
m=MOVED;
}
if(max_error_count>0 && stats.error_count>=max_error_count)
goto pre_FINISHING;
while(transfer_count<parallel && (state==TARGET_REMOVE_OLD || state==TARGET_REMOVE_OLD_FIRST))
{
file=0;
if(!file && state==TARGET_REMOVE_OLD_FIRST)
{
file=to_rm_mismatched->curr();
to_rm_mismatched->next();
}
if(!file && (state==TARGET_REMOVE_OLD || FlagSet(REMOVE_FIRST)))
{
file=to_rm->curr();
to_rm->next();
}
if(!file)
{
if(waiting_num>0)
break;
if(state==TARGET_REMOVE_OLD)
goto pre_TARGET_CHMOD;
goto pre_TARGET_MKDIR;
}
if(!FlagSet(DELETE))
{
if(FlagSet(REPORT_NOT_DELETED))
{
const char *target_name_rel=dir_file(target_relative_dir,file->name);
if(file->TypeIs(file->DIRECTORY))
Report(_(""Old directory `%s' is not removed""),target_name_rel);
else
Report(_(""Old file `%s' is not removed""),target_name_rel);
}
continue;
}
if(script)
{
ArgV args(""rm"");
if(file->TypeIs(file->DIRECTORY))
{
if(recursion_mode==RECURSION_NEVER)
args.setarg(0,""rmdir"");
else
args.Append(""-r"");
}
args.Append(target_session->GetFileURL(file->name));
xstring_ca cmd(args.CombineQuoted());
fprintf(script,""%s\n"",cmd.get());
}
if(!script_only)
{
ArgV *args=new ArgV(""rm"");
args->Append(file->name);
args->seek(1);
rmJob *j=new rmJob(target_session->Clone(),args);
args->CombineTo(j->cmdline);
JobStarted(j);
if(file->TypeIs(file->DIRECTORY))
{
if(recursion_mode==RECURSION_NEVER)
{
args->setarg(0,""rmdir"");
j->Rmdir();
}
else
j->Recurse();
}
}
const char *target_name_rel=dir_file(target_relative_dir,file->name);
if(file->TypeIs(file->DIRECTORY))
Report(_(""Removing old directory `%s'""),target_name_rel);
else
Report(_(""Removing old file `%s'""),target_name_rel);
}
break;
pre_TARGET_CHMOD:
if(FlagSet(NO_PERMS))
goto pre_FINISHING_FIX_LOCAL;
to_transfer->rewind();
if(FlagSet(TARGET_FLAT))
to_transfer->Sort(FileSet::BYNAME_FLAT);
set_state(TARGET_CHMOD);
m=MOVED;
case(TARGET_CHMOD):
while((j=FindDoneAwaitedJob())!=0)
{
JobFinished(j);
m=MOVED;
}
if(max_error_count>0 && stats.error_count>=max_error_count)
goto pre_FINISHING;
while(transfer_count<parallel && state==TARGET_CHMOD)
{
file=to_transfer->curr();
if(!file)
goto pre_FINISHING_FIX_LOCAL;
to_transfer->next();
if(file->TypeIs(file->SYMLINK))
continue;
if(!file->Has(file->MODE))
continue;
mode_t mode_mask=get_mode_mask();
mode_t def_mode=(file->TypeIs(file->DIRECTORY)?0775:0664)&~mode_mask;
if(target_is_local && file->mode==def_mode)
{
struct stat st;
if(!target_is_local || lstat(dir_file(target_dir,file->name),&st)==-1)
continue;
if((st.st_mode&07777)==(file->mode&~mode_mask))
continue;
}
FileInfo *target=target_set->FindByName(file->name);
if(target && target->filetype==file->DIRECTORY && file->filetype==file->DIRECTORY
&& target->mode==(file->mode&~mode_mask) && (target->mode&0200))
continue;
if(script)
{
ArgV args(""chmod"");
args.Append(xstring::format(""%03lo"",(unsigned long)(file->mode&~mode_mask)));
args.Append(target_session->GetFileURL(file->name));
xstring_ca cmd(args.CombineQuoted());
fprintf(script,""%s\n"",cmd.get());
}
if(!script_only)
{
ArgV *a=new ArgV(""chmod"");
a->Append(file->name);
a->seek(1);
ChmodJob *cj=new ChmodJob(target_session->Clone(),
file->mode&~mode_mask,a);
a->CombineTo(cj->cmdline);
if(!verbose_report)
cj->BeQuiet();
JobStarted(cj);
m=MOVED;
}
}
break;
pre_FINISHING_FIX_LOCAL:
if(target_is_local && !script_only)
{
const bool flat=FlagSet(TARGET_FLAT);
to_transfer->Sort(FileSet::BYNAME_FLAT);
to_transfer->LocalUtime(target_dir,              true,flat);
if(FlagSet(ALLOW_CHOWN))
to_transfer->LocalChown(target_dir,flat);
if(!FlagSet(NO_PERMS) && same)
same->LocalChmod(target_dir,get_mode_mask(),flat);
if(FlagSet(ALLOW_CHOWN) && same)
same->LocalChown(target_dir,flat);
}
if(remove_source_files && (same || to_rm_src))
goto pre_SOURCE_REMOVING_SAME;
pre_FINISHING:
set_state(FINISHING);
m=MOVED;
case(FINISHING):
while((j=FindDoneAwaitedJob())!=0)
{
JobFinished(j);
m=MOVED;
}
if(waiting_num>0)
break;
if(remove_this_source_dir) {
remove_this_source_dir=false;
if(script)
{
ArgV args(""rmdir"");
args.Append(source_session->GetFileURL(source_dir));
xstring_ca cmd(args.CombineQuoted());
fprintf(script,""%s\n"",cmd.get());
}
if(!script_only)
{
ArgV *args=new ArgV(""rmdir"");
args->Append(source_dir);
args->seek(1);
rmJob *j=new rmJob(source_session->Clone(),args);
args->CombineTo(j->cmdline);
j->Rmdir();
JobStarted(j);
}
if(source_relative_dir)
Report(_(""Removing source directory `%s'""),source_relative_dir.get());
m=MOVED;
break;
}
transfer_count++;
if(parent_mirror)
parent_mirror->stats.Add(stats);
else
{
if(stats.HaveSomethingDone(flags) && on_change)
{
CmdExec *exec=new CmdExec(source_session->Clone(),0);
AddWaiting(exec);
exec->FeedCmd(on_change);
exec->FeedCmd(""\n"");
set_state(LAST_EXEC);
break;
}
}
goto pre_DONE;
pre_SOURCE_REMOVING_SAME:
if(!same)
same=to_rm_src.borrow();
else if(to_rm_src)
same->Merge(to_rm_src);
same->rewind();
set_state(SOURCE_REMOVING_SAME);
m=MOVED;
case(SOURCE_REMOVING_SAME):
while((j=FindDoneAwaitedJob())!=0)
{
JobFinished(j);
m=MOVED;
}
if(max_error_count>0 && stats.error_count>=max_error_count)
goto pre_FINISHING;
while(transfer_count<parallel && state==SOURCE_REMOVING_SAME)
{
file=same->curr();
same->next();
if(!file)
goto pre_FINISHING;
if(file->TypeIs(file->DIRECTORY))
continue;
if(script)
{
ArgV args(""rm"");
args.Append(source_session->GetFileURL(file->name));
xstring_ca cmd(args.CombineQuoted());
fprintf(script,""%s\n"",cmd.get());
}
if(!script_only)
{
ArgV *args=new ArgV(""rm"");
args->Append(file->name);
args->seek(1);
rmJob *j=new rmJob(source_session->Clone(),args);
args->CombineTo(j->cmdline);
JobStarted(j);
}
const char *source_name_rel=dir_file(source_relative_dir,file->name);
Report(_(""Removing source file `%s'""),source_name_rel);
}
break;
case(LAST_EXEC):
while((j=FindDoneAwaitedJob())!=0)
{
RemoveWaiting(j);
Delete(j);
m=MOVED;
}
if(waiting_num>0)
break;
pre_DONE:
set_state(DONE);
m=MOVED;
bytes_transferred=0;
if(!parent_mirror && FlagSet(LOOP) && stats.HaveSomethingDone(flags) && !stats.error_count)
{
PrintStatus(0,"""");
printf(_(""Retrying mirror...\n""));
stats.Reset();
source_set=0;
target_set=0;
goto pre_GETTING_LIST_INFO;
}
case(DONE):
break;
}
if(transfer_count<parallel && parent_mirror)
m|=parent_mirror->Roll();
return m;
}","[294, 296, 297, 299, 300, 301, 302, 310, 311, 320, 385, 497]","It has been discovered that lftp up to and including version 4.8.3 does not properly sanitize remote file names, leading to a loss of integrity on the local system when reverse mirroring is used. A remote attacker may trick a user to use reverse mirroring on an attacker controlled FTP server, resulting in the removal of all files in the current working directory of the victim's system.",lftp,CVE-2018-10916,CWE-20
7582,4387,"switchGroup(uid_t uid, const struct passwd *userInfo, gid_t gid) {
if (userInfo != NULL) {
bool setgroupsCalled = false;
#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__)
#ifdef __APPLE__
int groups[1024];
int ngroups = sizeof(groups) / sizeof(int);
#else
gid_t groups[1024];
int ngroups = sizeof(groups) / sizeof(gid_t);
#endif
boost::scoped_array<gid_t> gidset;
int ret = getgrouplist(userInfo->pw_name, gid,
groups, &ngroups);
if (ret == -1) {
int e = errno;
fprintf(stderr, ""ERROR: getgrouplist(%s, %d) failed: %s (errno=%d)\n"",
userInfo->pw_name, (int) gid, strerror(e), e);
exit(1);
}
if (ngroups <= NGROUPS_MAX) {
setgroupsCalled = true;
gidset.reset(new gid_t[ngroups]);
if (setgroups(ngroups, gidset.get()) == -1) {
int e = errno;
fprintf(stderr, ""ERROR: setgroups(%d, ...) failed: %s (errno=%d)\n"",
ngroups, strerror(e), e);
exit(1);
}
}
#endif
if (!setgroupsCalled && initgroups(userInfo->pw_name, gid) == -1) {
int e = errno;
fprintf(stderr, ""ERROR: initgroups(%s, %d) failed: %s (errno=%d)\n"",
userInfo->pw_name, (int) gid, strerror(e), e);
exit(1);
}
}
if (setgid(gid) == -1) {
int e = errno;
fprintf(stderr, ""ERROR: setgid(%d) failed: %s (errno=%d)\n"",
(int) gid, strerror(e), e);
exit(1);
}
}",[24],"An issue was discovered in switchGroup() in agent/ExecHelper/ExecHelperMain.cpp in Phusion Passenger before 5.3.2. The set of groups (gidset) is not set correctly, leaving it up to randomness (i.e., uninitialized memory) which supplementary groups are actually being set while lowering privileges.",passenger,CVE-2018-12615,CWE-732
7583,4996,"GF_Err gf_sm_load_init(GF_SceneLoader *load)
{
GF_Err e = GF_NOT_SUPPORTED;
char *ext, szExt[50];
if (!load || (!load->ctx && !load->scene_graph)
#ifndef GPAC_DISABLE_ISOM
|| (!load->fileName && !load->isom && !(load->flags & GF_SM_LOAD_FOR_PLAYBACK) )
#endif
) return GF_BAD_PARAM;
if (!load->type) {
#ifndef GPAC_DISABLE_ISOM
if (load->isom) {
load->type = GF_SM_LOAD_MP4;
} else
#endif
{
ext = (char *)strrchr(load->fileName, '.');
if (!ext) return GF_NOT_SUPPORTED;
if (!stricmp(ext, "".gz"")) {
char *anext;
ext[0] = 0;
anext = (char *)strrchr(load->fileName, '.');
ext[0] = '.';
ext = anext;
}
strcpy(szExt, &ext[1]);
strlwr(szExt);
if (strstr(szExt, ""bt"")) load->type = GF_SM_LOAD_BT;
else if (strstr(szExt, ""wrl"")) load->type = GF_SM_LOAD_VRML;
else if (strstr(szExt, ""x3dv"")) load->type = GF_SM_LOAD_X3DV;
#ifndef GPAC_DISABLE_LOADER_XMT
else if (strstr(szExt, ""xmt"") || strstr(szExt, ""xmta"")) load->type = GF_SM_LOAD_XMTA;
else if (strstr(szExt, ""x3d"")) load->type = GF_SM_LOAD_X3D;
#endif
else if (strstr(szExt, ""swf"")) load->type = GF_SM_LOAD_SWF;
else if (strstr(szExt, ""mov"")) load->type = GF_SM_LOAD_QT;
else if (strstr(szExt, ""svg"")) load->type = GF_SM_LOAD_SVG;
else if (strstr(szExt, ""xsr"")) load->type = GF_SM_LOAD_XSR;
else if (strstr(szExt, ""xbl"")) load->type = GF_SM_LOAD_XBL;
else if (strstr(szExt, ""xml"")) {
char *rtype = gf_xml_get_root_type(load->fileName, &e);
if (rtype) {
if (!strcmp(rtype, ""SAFSession"")) load->type = GF_SM_LOAD_XSR;
else if (!strcmp(rtype, ""XMT-A"")) load->type = GF_SM_LOAD_XMTA;
else if (!strcmp(rtype, ""X3D"")) load->type = GF_SM_LOAD_X3D;
else if (!strcmp(rtype, ""bindings"")) load->type = GF_SM_LOAD_XBL;
gf_free(rtype);
}
}
}
}
if (!load->type) return e;
if (!load->scene_graph) load->scene_graph = load->ctx->scene_graph;
switch (load->type) {
#ifndef GPAC_DISABLE_LOADER_BT
case GF_SM_LOAD_BT:
case GF_SM_LOAD_VRML:
case GF_SM_LOAD_X3DV:
return gf_sm_load_init_bt(load);
#endif
#ifndef GPAC_DISABLE_LOADER_XMT
case GF_SM_LOAD_XMTA:
case GF_SM_LOAD_X3D:
return gf_sm_load_init_xmt(load);
#endif
#ifndef GPAC_DISABLE_SVG
case GF_SM_LOAD_SVG:
case GF_SM_LOAD_XSR:
case GF_SM_LOAD_DIMS:
return gf_sm_load_init_svg(load);
case GF_SM_LOAD_XBL:
e = gf_sm_load_init_xbl(load);
load->process = gf_sm_load_run_xbl;
load->done = gf_sm_load_done_xbl;
return e;
#endif
#ifndef GPAC_DISABLE_SWF_IMPORT
case GF_SM_LOAD_SWF:
return gf_sm_load_init_swf(load);
#endif
#ifndef GPAC_DISABLE_LOADER_ISOM
case GF_SM_LOAD_MP4:
return gf_sm_load_init_isom(load);
#endif
#ifndef GPAC_DISABLE_QTVR
case GF_SM_LOAD_QT:
return gf_sm_load_init_qt(load);
#endif
default:
return GF_NOT_SUPPORTED;
}
return GF_NOT_SUPPORTED;
}",[26],GPAC version 0.7.1 and earlier has a Buffer Overflow vulnerability in the gf_sm_load_init function in scene_manager.c in libgpac_static.a.,gpac,CVE-2018-20761,CWE-119
7597,8274,"static void get_sem_elements(struct sem_data *p)
{
size_t i;
if (!p || !p->sem_nsems || p->sem_perm.id < 0)
return;
p->elements = xcalloc(p->sem_nsems, sizeof(struct sem_elem));
for (i = 0; i < p->sem_nsems; i++) {
struct sem_elem *e = &p->elements[i];
union semun arg = { .val = 0 };
e->semval = semctl(p->sem_perm.id, i, GETVAL, arg);
if (e->semval < 0)
err(EXIT_FAILURE, _(""%s failed""), ""semctl(GETVAL)"");
e->ncount = semctl(p->sem_perm.id, i, GETNCNT, arg);
if (e->ncount < 0)
err(EXIT_FAILURE, _(""%s failed""), ""semctl(GETNCNT)"");
e->zcount = semctl(p->sem_perm.id, i, GETZCNT, arg);
if (e->zcount < 0)
err(EXIT_FAILURE, _(""%s failed""), ""semctl(GETZCNT)"");
e->pid = semctl(p->sem_perm.id, i, GETPID, arg);
if (e->pid < 0)
err(EXIT_FAILURE, _(""%s failed""), ""semctl(GETPID)"");
}
}",[4],"** DISPUTED ** An integer overflow in util-linux through 2.37.1 can potentially cause a buffer overflow if an attacker were able to use system resources in a way that leads to a large number in the /proc/sysvipc/sem file. NOTE: this is unexploitable in GNU C Library environments, and possibly in all realistic environments.",util-linux,CVE-2021-37600,CWE-190
7617,6297,"int secure_decrypt(void *data, unsigned int data_length, int is_signed)
{
at91_aes_key_size_t key_size;
unsigned int cmac_key[8], cipher_key[8];
unsigned int iv[AT91_AES_IV_SIZE_WORD];
unsigned int computed_cmac[AT91_AES_BLOCK_SIZE_WORD];
unsigned int fixed_length;
const unsigned int *cmac;
int rc = -1;
init_keys(&key_size, cipher_key, cmac_key, iv);
at91_aes_init();
if (is_signed) {
if (at91_aes_cmac(data_length, data, computed_cmac,
key_size, cmac_key))
goto exit;
fixed_length = at91_aes_roundup(data_length);
cmac = (const unsigned int *)((char *)data + fixed_length);
if (memcmp(cmac, computed_cmac, AT91_AES_BLOCK_SIZE_BYTE))
goto exit;
}
if (at91_aes_cbc(data_length, data, data, 0,
key_size, cipher_key, iv))
goto exit;
rc = 0;
exit:
at91_aes_cleanup();
memset(cmac_key, 0, sizeof(cmac_key));
memset(cipher_key, 0, sizeof(cipher_key));
memset(iv, 0, sizeof(iv));
return rc;
}",[18],A timing side channel was discovered in AT91bootstrap before 3.9.2. It can be exploited by attackers with physical access to forge CMAC values and subsequently boot arbitrary code on an affected system.,at91bootstrap,CVE-2020-11683,CWE-203
7619,9604,"void jsvRemoveChild(JsVar *parent, JsVar *child) {
assert(jsvHasChildren(parent));
assert(jsvIsName(child));
JsVarRef childref = jsvGetRef(child);
bool wasChild = false;
if (jsvGetFirstChild(parent) == childref) {
jsvSetFirstChild(parent, jsvGetNextSibling(child));
wasChild = true;
}
if (jsvGetLastChild(parent) == childref) {
jsvSetLastChild(parent, jsvGetPrevSibling(child));
wasChild = true;
if (jsvIsArray(parent)) {
JsVarInt l = 0;
if (jsvGetLastChild(parent))
l = jsvGetIntegerAndUnLock(jsvLock(jsvGetLastChild(parent)))+1;
jsvSetArrayLength(parent, l, false);
}
}
if (jsvGetPrevSibling(child)) {
JsVar *v = jsvLock(jsvGetPrevSibling(child));
assert(jsvGetNextSibling(v) == jsvGetRef(child));
jsvSetNextSibling(v, jsvGetNextSibling(child));
jsvUnLock(v);
wasChild = true;
}
if (jsvGetNextSibling(child)) {
JsVar *v = jsvLock(jsvGetNextSibling(child));
assert(jsvGetPrevSibling(v) == jsvGetRef(child));
jsvSetPrevSibling(v, jsvGetPrevSibling(child));
jsvUnLock(v);
wasChild = true;
}
jsvSetPrevSibling(child, 0);
jsvSetNextSibling(child, 0);
if (wasChild)
jsvUnRef(child);
}",[4],Espruino 2v11.251 was discovered to contain a stack buffer overflow via src/jsvar.c in jsvNewFromString.,Espruino,CVE-2022-25044,CWE-787
7633,3028,"parse_tag(char **s, int internal)
{
struct parsed_tag *tag = NULL;
int tag_id;
char tagname[MAX_TAG_LEN], attrname[MAX_TAG_LEN];
char *p, *q;
int i, attr_id = 0, nattr;
q = (*s) + 1;
p = tagname;
if (*q == '/') {
*(p++) = *(q++);
SKIP_BLANKS(q);
}
while (*q && !IS_SPACE(*q) && !(tagname[0] != '/' && *q == '/') &&
*q != '>' && p - tagname < MAX_TAG_LEN - 1) {
*(p++) = TOLOWER(*q);
q++;
}
*p = '\0';
while (*q && !IS_SPACE(*q) && !(tagname[0] != '/' && *q == '/') &&
*q != '>')
q++;
tag_id = getHash_si(&tagtable, tagname, HTML_UNKNOWN);
if (tag_id == HTML_UNKNOWN ||
(!internal && TagMAP[tag_id].flag & TFLG_INT))
goto skip_parse_tagarg;
tag = New(struct parsed_tag);
bzero(tag, sizeof(struct parsed_tag));
tag->tagid = tag_id;
if ((nattr = TagMAP[tag_id].max_attribute) > 0) {
tag->attrid = NewAtom_N(unsigned char, nattr);
tag->value = New_N(char *, nattr);
tag->map = NewAtom_N(unsigned char, MAX_TAGATTR);
memset(tag->map, MAX_TAGATTR, MAX_TAGATTR);
memset(tag->attrid, ATTR_UNKNOWN, nattr);
for (i = 0; i < nattr; i++)
tag->map[TagMAP[tag_id].accept_attribute[i]] = i;
}
SKIP_BLANKS(q);
while (1) {
Str value = NULL, value_tmp = NULL;
if (*q == '>' || *q == '\0')
goto done_parse_tag;
p = attrname;
while (*q && *q != '=' && !IS_SPACE(*q) &&
*q != '>' && p - attrname < MAX_TAG_LEN - 1) {
*(p++) = TOLOWER(*q);
q++;
}
*p = '\0';
while (*q && *q != '=' && !IS_SPACE(*q) && *q != '>')
q++;
SKIP_BLANKS(q);
if (*q == '=') {
value_tmp = Strnew();
q++;
SKIP_BLANKS(q);
if (*q == '""') {
q++;
while (*q && *q != '""') {
Strcat_char(value_tmp, *q);
if (!tag->need_reconstruct && is_html_quote(*q))
tag->need_reconstruct = TRUE;
q++;
}
if (*q == '""')
q++;
}
else if (*q == '\'') {
q++;
while (*q && *q != '\'') {
Strcat_char(value_tmp, *q);
if (!tag->need_reconstruct && is_html_quote(*q))
tag->need_reconstruct = TRUE;
q++;
}
if (*q == '\'')
q++;
}
else if (*q) {
while (*q && !IS_SPACE(*q) && *q != '>') {
Strcat_char(value_tmp, *q);
if (!tag->need_reconstruct && is_html_quote(*q))
tag->need_reconstruct = TRUE;
q++;
}
}
}
for (i = 0; i < nattr; i++) {
if ((tag)->attrid[i] == ATTR_UNKNOWN &&
strcmp(AttrMAP[TagMAP[tag_id].accept_attribute[i]].name,
attrname) == 0) {
attr_id = TagMAP[tag_id].accept_attribute[i];
break;
}
}
if (value_tmp) {
int j, hidden=FALSE;
for (j=0; j<i; j++) {
if (tag->attrid[j] == ATTR_TYPE &&
tag->value[j] &&
strcmp(""hidden"",tag->value[j]) == 0) {
hidden=TRUE;
break;
}
}
if ((tag_id == HTML_INPUT || tag_id == HTML_INPUT_ALT) &&
attr_id == ATTR_VALUE && hidden) {
value = value_tmp;
} else {
char *x;
value = Strnew();
for (x = value_tmp->ptr; *x; x++) {
if (*x != '\n')
Strcat_char(value, *x);
}
}
}
if (i != nattr) {
if (!internal &&
((AttrMAP[attr_id].flag & AFLG_INT) ||
(value && AttrMAP[attr_id].vtype == VTYPE_METHOD &&
!strcasecmp(value->ptr, ""internal"")))) {
tag->need_reconstruct = TRUE;
continue;
}
tag->attrid[i] = attr_id;
if (value)
tag->value[i] = html_unquote(value->ptr);
else
tag->value[i] = NULL;
}
else {
tag->need_reconstruct = TRUE;
}
}
skip_parse_tagarg:
while (*q != '>' && *q)
q++;
done_parse_tag:
if (*q == '>')
q++;
*s = q;
return tag;
}",[8],"The HTMLtagproc1 function in file.c in w3m before 0.5.3+git20161009 does not properly initialize values, which allows remote attackers to crash the application via a crafted html file, related to <dd> tags.",w3m,CVE-2016-9435,CWE-20
7640,7970,"GF_Err adts_dmx_process(GF_Filter *filter)
{
GF_ADTSDmxCtx *ctx = gf_filter_get_udta(filter);
GF_FilterPacket *pck, *dst_pck;
u8 *data, *output;
u8 *start;
u32 pck_size, remain, prev_pck_size;
u64 cts = GF_FILTER_NO_TS;
if (!ctx->duration.num)
adts_dmx_check_dur(filter, ctx);
if (ctx->opid && !ctx->is_playing)
return GF_OK;
pck = gf_filter_pid_get_packet(ctx->ipid);
if (!pck) {
if (gf_filter_pid_is_eos(ctx->ipid)) {
if (!ctx->adts_buffer_size) {
if (ctx->opid)
gf_filter_pid_set_eos(ctx->opid);
if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);
ctx->src_pck = NULL;
return GF_EOS;
}
} else {
return GF_OK;
}
}
prev_pck_size = ctx->adts_buffer_size;
if (pck && !ctx->resume_from) {
data = (char *) gf_filter_pck_get_data(pck, &pck_size);
if (!pck_size) {
gf_filter_pid_drop_packet(ctx->ipid);
return GF_OK;
}
if (ctx->byte_offset != GF_FILTER_NO_BO) {
u64 byte_offset = gf_filter_pck_get_byte_offset(pck);
if (!ctx->adts_buffer_size) {
ctx->byte_offset = byte_offset;
} else if (ctx->byte_offset + ctx->adts_buffer_size != byte_offset) {
ctx->byte_offset = GF_FILTER_NO_BO;
if ((byte_offset != GF_FILTER_NO_BO) && (byte_offset>ctx->adts_buffer_size) ) {
ctx->byte_offset = byte_offset - ctx->adts_buffer_size;
}
}
}
if (ctx->adts_buffer_size + pck_size > ctx->adts_buffer_alloc) {
ctx->adts_buffer_alloc = ctx->adts_buffer_size + pck_size;
ctx->adts_buffer = gf_realloc(ctx->adts_buffer, ctx->adts_buffer_alloc);
}
memcpy(ctx->adts_buffer + ctx->adts_buffer_size, data, pck_size);
ctx->adts_buffer_size += pck_size;
}
if (ctx->timescale && pck) {
cts = gf_filter_pck_get_cts(pck);
}
if (cts == GF_FILTER_NO_TS) {
prev_pck_size = 0;
}
remain = ctx->adts_buffer_size;
start = ctx->adts_buffer;
if (ctx->resume_from) {
start += ctx->resume_from - 1;
remain -= ctx->resume_from - 1;
ctx->resume_from = 0;
}
while (remain) {
u8 *sync;
u32 sync_pos, size, offset, bytes_to_drop=0, nb_blocks_per_frame;
if (!ctx->tag_size && (remain>3)) {
if (start[0] == 'I' && start[1] == 'D' && start[2] == '3') {
if (remain<10)
return GF_OK;
ctx->tag_size = ((start[9] & 0x7f) + ((start[8] & 0x7f) << 7) + ((start[7] & 0x7f) << 14) + ((start[6] & 0x7f) << 21));
bytes_to_drop = 10;
if (ctx->id3_buffer_alloc < ctx->tag_size+10) {
ctx->id3_buffer = gf_realloc(ctx->id3_buffer, ctx->tag_size+10);
ctx->id3_buffer_alloc = ctx->tag_size+10;
}
memcpy(ctx->id3_buffer, start, 10);
ctx->id3_buffer_size = 10;
goto drop_byte;
}
}
if (ctx->tag_size) {
if (ctx->tag_size>remain) {
bytes_to_drop = remain;
ctx->tag_size-=remain;
} else {
bytes_to_drop = ctx->tag_size;
ctx->tag_size = 0;
}
memcpy(ctx->id3_buffer + ctx->id3_buffer_size, start, bytes_to_drop);
ctx->id3_buffer_size += bytes_to_drop;
if (!ctx->tag_size && ctx->opid) {
id3dmx_flush(filter, ctx->id3_buffer, ctx->id3_buffer_size, ctx->opid, ctx->expart ? &ctx->vpid : NULL);
ctx->id3_buffer_size = 0;
}
goto drop_byte;
}
sync = memchr(start, 0xFF, remain);
sync_pos = (u32) (sync ? sync - start : remain);
if (remain - sync_pos < 7) {
break;
}
if ((sync[1] & 0xF0) != 0xF0) {
GF_LOG(ctx->nb_frames ? GF_LOG_WARNING : GF_LOG_DEBUG, GF_LOG_PARSER, (""[ADTSDmx] invalid ADTS sync bytes, resyncing\n""));
ctx->nb_frames = 0;
goto drop_byte;
}
if (!ctx->bs) {
ctx->bs = gf_bs_new(sync + 1, remain - sync_pos - 1, GF_BITSTREAM_READ);
} else {
gf_bs_reassign_buffer(ctx->bs, sync + 1, remain - sync_pos - 1);
}
gf_bs_read_int(ctx->bs, 4);
ctx->hdr.is_mp2 = (Bool)gf_bs_read_int(ctx->bs, 1);
ctx->hdr.is_mp2 = 0;
gf_bs_read_int(ctx->bs, 2);
ctx->hdr.no_crc = (Bool)gf_bs_read_int(ctx->bs, 1);
ctx->hdr.profile = 1 + gf_bs_read_int(ctx->bs, 2);
ctx->hdr.sr_idx = gf_bs_read_int(ctx->bs, 4);
gf_bs_read_int(ctx->bs, 1);
ctx->hdr.nb_ch = gf_bs_read_int(ctx->bs, 3);
gf_bs_read_int(ctx->bs, 4);
ctx->hdr.frame_size = gf_bs_read_int(ctx->bs, 13);
gf_bs_read_int(ctx->bs, 11);
nb_blocks_per_frame = gf_bs_read_int(ctx->bs, 2);
ctx->hdr.hdr_size = 7;
if (!ctx->hdr.no_crc) {
u32 skip;
if (!nb_blocks_per_frame) {
skip = 2;
} else {
skip = 2 + 2*nb_blocks_per_frame;
}
ctx->hdr.hdr_size += skip;
gf_bs_skip_bytes(ctx->bs, skip);
}
if (!ctx->hdr.frame_size || !GF_M4ASampleRates[ctx->hdr.sr_idx]) {
GF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (""[ADTSDmx] Invalid ADTS frame header, resyncing\n""));
ctx->nb_frames = 0;
goto drop_byte;
}
if ((nb_blocks_per_frame>2) || (nb_blocks_per_frame && ctx->hdr.nb_ch)) {
GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (""[ADTSDmx] Unsupported multi-block ADTS frame header - patch welcome\n""));
ctx->nb_frames = 0;
goto drop_byte;
} else if (!nb_blocks_per_frame) {
if (ctx->aacchcfg<0)
ctx->hdr.nb_ch = -ctx->aacchcfg;
else if (!ctx->hdr.nb_ch)
ctx->hdr.nb_ch = ctx->aacchcfg;
if (!ctx->hdr.nb_ch) {
GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (""[ADTSDmx] Missing channel configuration in ADTS frame header, defaulting to stereo - use `--aacchcfg` to force config\n""));
ctx->hdr.nb_ch = ctx->aacchcfg = 2;
}
}
if (nb_blocks_per_frame==2) {
u32 pos = (u32) gf_bs_get_position(ctx->bs);
gf_m4a_parse_program_config_element(ctx->bs, &ctx->acfg);
if (!ctx->hdr.no_crc)
gf_bs_skip_bytes(ctx->bs, 2);
ctx->hdr.hdr_size += (u32) gf_bs_get_position(ctx->bs) - pos;
}
if (ctx->hdr.nb_ch==7)
ctx->hdr.nb_ch = 8;
if (ctx->hdr.frame_size + 1 < remain) {
u32 next_frame = ctx->hdr.frame_size;
if ((sync[next_frame] !=0xFF) || ((sync[next_frame+1] & 0xF0) !=0xF0) ) {
GF_LOG(ctx->nb_frames ? GF_LOG_WARNING : GF_LOG_DEBUG, GF_LOG_PARSER, (""[ADTSDmx] invalid next ADTS frame sync, resyncing\n""));
ctx->nb_frames = 0;
goto drop_byte;
}
}
else if (pck) {
if (ctx->timescale && !prev_pck_size &&  (cts != GF_FILTER_NO_TS) ) {
ctx->cts = cts;
}
break;
}
adts_dmx_check_pid(filter, ctx);
if (!ctx->is_playing) {
ctx->resume_from = 1 + ctx->adts_buffer_size - remain;
return GF_OK;
}
ctx->nb_frames++;
size = ctx->hdr.frame_size - ctx->hdr.hdr_size;
offset = ctx->hdr.hdr_size;
if ((nb_blocks_per_frame==2) && !ctx->hdr.no_crc)
size -= 2;
if (ctx->in_seek) {
u64 nb_samples_at_seek = (u64) (ctx->start_range * GF_M4ASampleRates[ctx->sr_idx]);
if (ctx->cts + ctx->dts_inc >= nb_samples_at_seek) {
ctx->in_seek = GF_FALSE;
}
}
bytes_to_drop = ctx->hdr.frame_size;
if (ctx->timescale && !prev_pck_size &&  (cts != GF_FILTER_NO_TS) ) {
ctx->cts = cts;
cts = GF_FILTER_NO_TS;
}
if (!ctx->in_seek) {
dst_pck = gf_filter_pck_new_alloc(ctx->opid, size, &output);
if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
memcpy(output, sync + offset, size);
gf_filter_pck_set_dts(dst_pck, ctx->cts);
gf_filter_pck_set_cts(dst_pck, ctx->cts);
gf_filter_pck_set_duration(dst_pck, ctx->dts_inc);
gf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);
gf_filter_pck_set_sap(dst_pck, GF_FILTER_SAP_1);
if (ctx->byte_offset != GF_FILTER_NO_BO) {
gf_filter_pck_set_byte_offset(dst_pck, ctx->byte_offset + ctx->hdr.hdr_size);
}
gf_filter_pck_send(dst_pck);
}
adts_dmx_update_cts(ctx);
if (bytes_to_drop>remain) {
GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (""[ADTSDmx] truncated ADTS frame!\n""));
bytes_to_drop=remain;
}
drop_byte:
if (!bytes_to_drop) {
bytes_to_drop = 1;
}
start += bytes_to_drop;
remain -= bytes_to_drop;
if (prev_pck_size) {
if (prev_pck_size > bytes_to_drop) prev_pck_size -= bytes_to_drop;
else {
prev_pck_size=0;
if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);
ctx->src_pck = pck;
if (pck)
gf_filter_pck_ref_props(&ctx->src_pck);
}
}
if (ctx->byte_offset != GF_FILTER_NO_BO)
ctx->byte_offset += bytes_to_drop;
}
if (!pck) {
ctx->adts_buffer_size = 0;
return adts_dmx_process(filter);
} else {
if (remain) {
memmove(ctx->adts_buffer, start, remain);
}
ctx->adts_buffer_size = remain;
gf_filter_pid_drop_packet(ctx->ipid);
}
return GF_OK;
}",[180],"In the adts_dmx_process function in filters/reframe_adts.c in GPAC 1.0.1, a crafted file may cause ctx->hdr.frame_size to be smaller than ctx->hdr.hdr_size, resulting in size to be a negative number and a heap overflow in the memcpy.",gpac,CVE-2021-30019,CWE-787
7643,4346,"static inline bool isMountable(const RemoteFsDevice::Details &d)
{
return RemoteFsDevice::constSshfsProtocol==d.url.scheme() ||
RemoteFsDevice::constSambaProtocol==d.url.scheme() || RemoteFsDevice::constSambaAvahiProtocol==d.url.scheme();
}","[3, 4]","An issue was discovered in the cantata-mounter D-Bus service in Cantata through 2.3.1. The mount target path check in mounter.cpp `mpOk()` is insufficient. A regular user can consequently mount a CIFS filesystem anywhere (e.g., outside of the /home directory tree) by passing directory traversal sequences such as a home/../usr substring.",cantata,CVE-2018-12559,CWE-22
7656,6240,"int ff_htmlmarkup_to_ass(void *log_ctx, AVBPrint *dst, const char *in)
{
char *param, buffer[128], tmp[128];
int len, tag_close, sptr = 1, line_start = 1, an = 0, end = 0;
SrtStack stack[16];
int closing_brace_missing = 0;
stack[0].tag[0] = 0;
strcpy(stack[0].param[PARAM_SIZE],  ""{\\fs}"");
strcpy(stack[0].param[PARAM_COLOR], ""{\\c}"");
strcpy(stack[0].param[PARAM_FACE],  ""{\\fn}"");
for (; !end && *in; in++) {
switch (*in) {
case '\r':
break;
case '\n':
if (line_start) {
end = 1;
break;
}
rstrip_spaces_buf(dst);
av_bprintf(dst, ""\\N"");
line_start = 1;
break;
case ' ':
if (!line_start)
av_bprint_chars(dst, *in, 1);
break;
case '{':
len = 0;
an += sscanf(in, ""{\\an%*1u}%n"", &len) >= 0 && len > 0;
if (!closing_brace_missing) {
if (   (an != 1 && in[1] == '\\')
|| (in[1] && strchr(""CcFfoPSsYy"", in[1]) && in[2] == ':')) {
char *bracep = strchr(in+2, '}');
if (bracep) {
in = bracep;
break;
} else
closing_brace_missing = 1;
}
}
av_bprint_chars(dst, *in, 1);
break;
case '<':
tag_close = in[1] == '/';
len = 0;
if (sscanf(in+tag_close+1, ""%127[^<>]>%n"", buffer, &len) >= 1 && len > 0) {
const char *tagname = buffer;
while (*tagname == ' ')
tagname++;
if ((param = strchr(tagname, ' ')))
*param++ = 0;
if ((!tag_close && sptr < FF_ARRAY_ELEMS(stack) && *tagname) ||
( tag_close && sptr > 0 && !strcmp(stack[sptr-1].tag, tagname))) {
int i, j, unknown = 0;
in += len + tag_close;
if (!tag_close)
memset(stack+sptr, 0, sizeof(*stack));
if (!strcmp(tagname, ""font"")) {
if (tag_close) {
for (i=PARAM_NUMBER-1; i>=0; i--)
if (stack[sptr-1].param[i][0])
for (j=sptr-2; j>=0; j--)
if (stack[j].param[i][0]) {
av_bprintf(dst, ""%s"", stack[j].param[i]);
break;
}
} else {
while (param) {
if (!strncmp(param, ""size="", 5)) {
unsigned font_size;
param += 5 + (param[5] == '""');
if (sscanf(param, ""%u"", &font_size) == 1) {
snprintf(stack[sptr].param[PARAM_SIZE],
sizeof(stack[0].param[PARAM_SIZE]),
""{\\fs%u}"", font_size);
}
} else if (!strncmp(param, ""color="", 6)) {
param += 6 + (param[6] == '""');
snprintf(stack[sptr].param[PARAM_COLOR],
sizeof(stack[0].param[PARAM_COLOR]),
""{\\c&H%X&}"",
html_color_parse(log_ctx, param));
} else if (!strncmp(param, ""face="", 5)) {
param += 5 + (param[5] == '""');
len = strcspn(param,
param[-1] == '""' ? ""\"""" :"" "");
av_strlcpy(tmp, param,
FFMIN(sizeof(tmp), len+1));
param += len;
snprintf(stack[sptr].param[PARAM_FACE],
sizeof(stack[0].param[PARAM_FACE]),
""{\\fn%s}"", tmp);
}
if ((param = strchr(param, ' ')))
param++;
}
for (i=0; i<PARAM_NUMBER; i++)
if (stack[sptr].param[i][0])
av_bprintf(dst, ""%s"", stack[sptr].param[i]);
}
} else if (tagname[0] && !tagname[1] && strspn(tagname, ""bisu"") == 1) {
av_bprintf(dst, ""{\\%c%d}"", tagname[0], !tag_close);
} else {
unknown = 1;
snprintf(tmp, sizeof(tmp), ""</%s>"", tagname);
}
if (tag_close) {
sptr--;
} else if (unknown && !strstr(in, tmp)) {
in -= len + tag_close;
av_bprint_chars(dst, *in, 1);
} else
av_strlcpy(stack[sptr++].tag, tagname,
sizeof(stack[0].tag));
break;
}
}
default:
av_bprint_chars(dst, *in, 1);
break;
}
if (*in != ' ' && *in != '\r' && *in != '\n')
line_start = 0;
}
if (!av_bprint_is_complete(dst))
return AVERROR(ENOMEM);
while (dst->len >= 2 && !strncmp(&dst->str[dst->len - 2], ""\\N"", 2))
dst->len -= 2;
dst->str[dst->len] = 0;
rstrip_spaces_buf(dst);
return 0;
}",[47],"In FFmpeg 3.2 and 4.1, a denial of service in the subtitle decoder allows attackers to hog the CPU via a crafted video file in Matroska format, because ff_htmlmarkup_to_ass in libavcodec/htmlsubtitles.c has a complex format argument to sscanf.",FFmpeg,CVE-2019-9718,CWE-125
7664,6104,"static int multiSelect(
Parse *pParse,
Select *p,
SelectDest *pDest
){
int rc = SQLITE_OK;
Select *pPrior;
Vdbe *v;
SelectDest dest;
Select *pDelete = 0;
sqlite3 *db;
assert( p && p->pPrior );
assert( (p->selFlags & SF_Recursive)==0 || p->op==TK_ALL || p->op==TK_UNION );
assert( p->selFlags & SF_Compound );
db = pParse->db;
pPrior = p->pPrior;
dest = *pDest;
if( pPrior->pOrderBy || pPrior->pLimit ){
sqlite3ErrorMsg(pParse,""%s clause should come after %s not before"",
pPrior->pOrderBy!=0 ? ""ORDER BY"" : ""LIMIT"", selectOpName(p->op));
rc = 1;
goto multi_select_end;
}
v = sqlite3GetVdbe(pParse);
assert( v!=0 );
if( dest.eDest==SRT_EphemTab ){
assert( p->pEList );
sqlite3VdbeAddOp2(v, OP_OpenEphemeral, dest.iSDParm, p->pEList->nExpr);
dest.eDest = SRT_Table;
}
if( p->selFlags & SF_MultiValue ){
rc = multiSelectValues(pParse, p, &dest);
if( rc>=0 ) goto multi_select_end;
rc = SQLITE_OK;
}
assert( p->pEList && pPrior->pEList );
assert( p->pEList->nExpr==pPrior->pEList->nExpr );
#ifndef SQLITE_OMIT_CTE
if( p->selFlags & SF_Recursive ){
generateWithRecursiveQuery(pParse, p, &dest);
}else
#endif
if( p->pOrderBy ){
return multiSelectOrderBy(pParse, p, pDest);
}else{
#ifndef SQLITE_OMIT_EXPLAIN
if( pPrior->pPrior==0 ){
ExplainQueryPlan((pParse, 1, ""COMPOUND QUERY""));
ExplainQueryPlan((pParse, 1, ""LEFT-MOST SUBQUERY""));
}
#endif
switch( p->op ){
case TK_ALL: {
int addr = 0;
int nLimit;
assert( !pPrior->pLimit );
pPrior->iLimit = p->iLimit;
pPrior->iOffset = p->iOffset;
pPrior->pLimit = p->pLimit;
rc = sqlite3Select(pParse, pPrior, &dest);
p->pLimit = 0;
if( rc ){
goto multi_select_end;
}
p->pPrior = 0;
p->iLimit = pPrior->iLimit;
p->iOffset = pPrior->iOffset;
if( p->iLimit ){
addr = sqlite3VdbeAddOp1(v, OP_IfNot, p->iLimit); VdbeCoverage(v);
VdbeComment((v, ""Jump ahead if LIMIT reached""));
if( p->iOffset ){
sqlite3VdbeAddOp3(v, OP_OffsetLimit,
p->iLimit, p->iOffset+1, p->iOffset);
}
}
ExplainQueryPlan((pParse, 1, ""UNION ALL""));
rc = sqlite3Select(pParse, p, &dest);
testcase( rc!=SQLITE_OK );
pDelete = p->pPrior;
p->pPrior = pPrior;
p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);
if( pPrior->pLimit
&& sqlite3ExprIsInteger(pPrior->pLimit->pLeft, &nLimit)
&& nLimit>0 && p->nSelectRow > sqlite3LogEst((u64)nLimit)
){
p->nSelectRow = sqlite3LogEst((u64)nLimit);
}
if( addr ){
sqlite3VdbeJumpHere(v, addr);
}
break;
}
case TK_EXCEPT:
case TK_UNION: {
int unionTab;
u8 op = 0;
int priorOp;
Expr *pLimit;
int addr;
SelectDest uniondest;
testcase( p->op==TK_EXCEPT );
testcase( p->op==TK_UNION );
priorOp = SRT_Union;
if( dest.eDest==priorOp ){
assert( p->pLimit==0 );
unionTab = dest.iSDParm;
}else{
unionTab = pParse->nTab++;
assert( p->pOrderBy==0 );
addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, unionTab, 0);
assert( p->addrOpenEphm[0] == -1 );
p->addrOpenEphm[0] = addr;
findRightmost(p)->selFlags |= SF_UsesEphemeral;
assert( p->pEList );
}
assert( !pPrior->pOrderBy );
sqlite3SelectDestInit(&uniondest, priorOp, unionTab);
rc = sqlite3Select(pParse, pPrior, &uniondest);
if( rc ){
goto multi_select_end;
}
if( p->op==TK_EXCEPT ){
op = SRT_Except;
}else{
assert( p->op==TK_UNION );
op = SRT_Union;
}
p->pPrior = 0;
pLimit = p->pLimit;
p->pLimit = 0;
uniondest.eDest = op;
ExplainQueryPlan((pParse, 1, ""%s USING TEMP B-TREE"",
selectOpName(p->op)));
rc = sqlite3Select(pParse, p, &uniondest);
testcase( rc!=SQLITE_OK );
sqlite3ExprListDelete(db, p->pOrderBy);
pDelete = p->pPrior;
p->pPrior = pPrior;
p->pOrderBy = 0;
if( p->op==TK_UNION ){
p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);
}
sqlite3ExprDelete(db, p->pLimit);
p->pLimit = pLimit;
p->iLimit = 0;
p->iOffset = 0;
assert( unionTab==dest.iSDParm || dest.eDest!=priorOp );
if( dest.eDest!=priorOp ){
int iCont, iBreak, iStart;
assert( p->pEList );
iBreak = sqlite3VdbeMakeLabel(pParse);
iCont = sqlite3VdbeMakeLabel(pParse);
computeLimitRegisters(pParse, p, iBreak);
sqlite3VdbeAddOp2(v, OP_Rewind, unionTab, iBreak); VdbeCoverage(v);
iStart = sqlite3VdbeCurrentAddr(v);
selectInnerLoop(pParse, p, unionTab,
0, 0, &dest, iCont, iBreak);
sqlite3VdbeResolveLabel(v, iCont);
sqlite3VdbeAddOp2(v, OP_Next, unionTab, iStart); VdbeCoverage(v);
sqlite3VdbeResolveLabel(v, iBreak);
sqlite3VdbeAddOp2(v, OP_Close, unionTab, 0);
}
break;
}
default: assert( p->op==TK_INTERSECT ); {
int tab1, tab2;
int iCont, iBreak, iStart;
Expr *pLimit;
int addr;
SelectDest intersectdest;
int r1;
tab1 = pParse->nTab++;
tab2 = pParse->nTab++;
assert( p->pOrderBy==0 );
addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, tab1, 0);
assert( p->addrOpenEphm[0] == -1 );
p->addrOpenEphm[0] = addr;
findRightmost(p)->selFlags |= SF_UsesEphemeral;
assert( p->pEList );
sqlite3SelectDestInit(&intersectdest, SRT_Union, tab1);
rc = sqlite3Select(pParse, pPrior, &intersectdest);
if( rc ){
goto multi_select_end;
}
addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, tab2, 0);
assert( p->addrOpenEphm[1] == -1 );
p->addrOpenEphm[1] = addr;
p->pPrior = 0;
pLimit = p->pLimit;
p->pLimit = 0;
intersectdest.iSDParm = tab2;
ExplainQueryPlan((pParse, 1, ""%s USING TEMP B-TREE"",
selectOpName(p->op)));
rc = sqlite3Select(pParse, p, &intersectdest);
testcase( rc!=SQLITE_OK );
pDelete = p->pPrior;
p->pPrior = pPrior;
if( p->nSelectRow>pPrior->nSelectRow ){
p->nSelectRow = pPrior->nSelectRow;
}
sqlite3ExprDelete(db, p->pLimit);
p->pLimit = pLimit;
assert( p->pEList );
iBreak = sqlite3VdbeMakeLabel(pParse);
iCont = sqlite3VdbeMakeLabel(pParse);
computeLimitRegisters(pParse, p, iBreak);
sqlite3VdbeAddOp2(v, OP_Rewind, tab1, iBreak); VdbeCoverage(v);
r1 = sqlite3GetTempReg(pParse);
iStart = sqlite3VdbeAddOp2(v, OP_RowData, tab1, r1);
sqlite3VdbeAddOp4Int(v, OP_NotFound, tab2, iCont, r1, 0);
VdbeCoverage(v);
sqlite3ReleaseTempReg(pParse, r1);
selectInnerLoop(pParse, p, tab1,
0, 0, &dest, iCont, iBreak);
sqlite3VdbeResolveLabel(v, iCont);
sqlite3VdbeAddOp2(v, OP_Next, tab1, iStart); VdbeCoverage(v);
sqlite3VdbeResolveLabel(v, iBreak);
sqlite3VdbeAddOp2(v, OP_Close, tab2, 0);
sqlite3VdbeAddOp2(v, OP_Close, tab1, 0);
break;
}
}
#ifndef SQLITE_OMIT_EXPLAIN
if( p->pNext==0 ){
ExplainQueryPlanPop(pParse);
}
#endif
}
if( p->selFlags & SF_UsesEphemeral ){
int i;
KeyInfo *pKeyInfo;
Select *pLoop;
CollSeq **apColl;
int nCol;
assert( p->pNext==0 );
nCol = p->pEList->nExpr;
pKeyInfo = sqlite3KeyInfoAlloc(db, nCol, 1);
if( !pKeyInfo ){
rc = SQLITE_NOMEM_BKPT;
goto multi_select_end;
}
for(i=0, apColl=pKeyInfo->aColl; i<nCol; i++, apColl++){
*apColl = multiSelectCollSeq(pParse, p, i);
if( 0==*apColl ){
*apColl = db->pDfltColl;
}
}
for(pLoop=p; pLoop; pLoop=pLoop->pPrior){
for(i=0; i<2; i++){
int addr = pLoop->addrOpenEphm[i];
if( addr<0 ){
assert( pLoop->addrOpenEphm[1]<0 );
break;
}
sqlite3VdbeChangeP2(v, addr, nCol);
sqlite3VdbeChangeP4(v, addr, (char*)sqlite3KeyInfoRef(pKeyInfo),
P4_KEYINFO);
pLoop->addrOpenEphm[i] = -1;
}
}
sqlite3KeyInfoUnref(pKeyInfo);
}
multi_select_end:
pDest->iSdst = dest.iSdst;
pDest->nSdst = dest.nSdst;
sqlite3SelectDelete(db, pDelete);
return rc;
}",[229],"multiSelect in select.c in SQLite 3.30.1 mishandles certain errors during parsing, as demonstrated by errors from sqlite3WindowRewrite() calls. NOTE: this vulnerability exists because of an incomplete fix for CVE-2019-19880.",sqlite,CVE-2019-19926,CWE-476
7666,2947,"static int jpc_siz_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate,
jas_stream_t *in)
{
jpc_siz_t *siz = &ms->parms.siz;
unsigned int i;
uint_fast8_t tmp;
cstate = 0;
if (jpc_getuint16(in, &siz->caps) ||
jpc_getuint32(in, &siz->width) ||
jpc_getuint32(in, &siz->height) ||
jpc_getuint32(in, &siz->xoff) ||
jpc_getuint32(in, &siz->yoff) ||
jpc_getuint32(in, &siz->tilewidth) ||
jpc_getuint32(in, &siz->tileheight) ||
jpc_getuint32(in, &siz->tilexoff) ||
jpc_getuint32(in, &siz->tileyoff) ||
jpc_getuint16(in, &siz->numcomps)) {
return -1;
}
if (!siz->width || !siz->height || !siz->tilewidth ||
!siz->tileheight || !siz->numcomps) {
return -1;
}
if (!(siz->comps = jas_alloc2(siz->numcomps, sizeof(jpc_sizcomp_t)))) {
return -1;
}
for (i = 0; i < siz->numcomps; ++i) {
if (jpc_getuint8(in, &tmp) ||
jpc_getuint8(in, &siz->comps[i].hsamp) ||
jpc_getuint8(in, &siz->comps[i].vsamp)) {
jas_free(siz->comps);
return -1;
}
siz->comps[i].sgnd = (tmp >> 7) & 1;
siz->comps[i].prec = (tmp & 0x7f) + 1;
}
if (jas_stream_eof(in)) {
jas_free(siz->comps);
return -1;
}
return 0;
}",[34],The jpc_dec_process_siz function in libjasper/jpc/jpc_dec.c in JasPer before 1.900.4 allows remote attackers to cause a denial of service (divide-by-zero error and application crash) via a crafted XRsiz value in a BMP image to the imginfo command.,jasper,CVE-2016-8691,CWE-369
7671,3648,"ngx_gmtime(time_t t, ngx_tm_t *tp)
{
ngx_int_t   yday;
ngx_uint_t  sec, min, hour, mday, mon, year, wday, days, leap;
if (t < 0) {
t = 0;
}
days = t / 86400;
sec = t % 86400;
wday = (4 + days) % 7;
hour = sec / 3600;
sec %= 3600;
min = sec / 60;
sec %= 60;
days = days - (31 + 28) + 719527;
year = (days + 2) * 400 / (365 * 400 + 100 - 4 + 1);
yday = days - (365 * year + year / 4 - year / 100 + year / 400);
if (yday < 0) {
leap = (year % 4 == 0) && (year % 100 || (year % 400 == 0));
yday = 365 + leap + yday;
year--;
}
mon = (yday + 31) * 10 / 306;
mday = yday - (367 * mon / 12 - 30) + 1;
if (yday >= 306) {
year++;
mon -= 10;
} else {
mon += 2;
}
tp->ngx_tm_sec = (ngx_tm_sec_t) sec;
tp->ngx_tm_min = (ngx_tm_min_t) min;
tp->ngx_tm_hour = (ngx_tm_hour_t) hour;
tp->ngx_tm_mday = (ngx_tm_mday_t) mday;
tp->ngx_tm_mon = (ngx_tm_mon_t) mon;
tp->ngx_tm_year = (ngx_tm_year_t) year;
tp->ngx_tm_wday = (ngx_tm_wday_t) wday;
}",[10],"NGINX before 1.13.6 has a buffer overflow for years that exceed four digits, as demonstrated by a file with a modification date in 1969 that causes an integer overflow (or a false modification date far in the future), when encountered by the autoindex module.",nginx,CVE-2017-20005,CWE-190
7677,8486,"static s32 svc_parse_slice(GF_BitStream *bs, AVCState *avc, AVCSliceInfo *si)
{
s32 pps_id;
gf_bs_read_ue_log(bs, ""first_mb_in_slice"");
si->slice_type = gf_bs_read_ue_log(bs, ""slice_type"");
if (si->slice_type > 9) return -1;
pps_id = gf_bs_read_ue_log(bs, ""pps_id"");
if (pps_id > 255)
return -1;
si->pps = &avc->pps[pps_id];
si->pps->id = pps_id;
if (!si->pps->slice_group_count)
return -2;
si->sps = &avc->sps[si->pps->sps_id + GF_SVC_SSPS_ID_SHIFT];
if (!si->sps->log2_max_frame_num)
return -2;
si->frame_num = gf_bs_read_int_log(bs, si->sps->log2_max_frame_num, ""frame_num"");
si->field_pic_flag = 0;
if (si->sps->frame_mbs_only_flag) {
}
else {
si->field_pic_flag = gf_bs_read_int_log(bs, 1, ""field_pic_flag"");
if (si->field_pic_flag) si->bottom_field_flag = gf_bs_read_int_log(bs, 1, ""bottom_field_flag"");
}
if (si->nal_unit_type == GF_AVC_NALU_IDR_SLICE || si->NalHeader.idr_pic_flag)
si->idr_pic_id = gf_bs_read_ue_log(bs, ""idr_pic_id"");
if (si->sps->poc_type == 0) {
si->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, ""poc_lsb"");
if (si->pps->pic_order_present && !si->field_pic_flag) {
si->delta_poc_bottom = gf_bs_read_se_log(bs, ""delta_poc_bottom"");
}
}
else if ((si->sps->poc_type == 1) && !si->sps->delta_pic_order_always_zero_flag) {
si->delta_poc[0] = gf_bs_read_se_log(bs, ""delta_poc0"");
if ((si->pps->pic_order_present == 1) && !si->field_pic_flag)
si->delta_poc[1] = gf_bs_read_se_log(bs, ""delta_poc1"");
}
if (si->pps->redundant_pic_cnt_present) {
si->redundant_pic_cnt = gf_bs_read_ue_log(bs, ""redundant_pic_cnt"");
}
return 0;
}",[8],"A buffer overflow vulnerability exists in Gpac through 1.0.1 via a malformed MP4 file in the svc_parse_slice function in av_parsers.c, which allows attackers to cause a denial of service, even code execution and escalation of privileges.",gpac,CVE-2021-40568,CWE-120
7680,6241,"int ff_htmlmarkup_to_ass(void *log_ctx, AVBPrint *dst, const char *in)
{
char *param, buffer[128], tmp[128];
int len, tag_close, sptr = 1, line_start = 1, an = 0, end = 0;
SrtStack stack[16];
int closing_brace_missing = 0;
stack[0].tag[0] = 0;
strcpy(stack[0].param[PARAM_SIZE],  ""{\\fs}"");
strcpy(stack[0].param[PARAM_COLOR], ""{\\c}"");
strcpy(stack[0].param[PARAM_FACE],  ""{\\fn}"");
for (; !end && *in; in++) {
switch (*in) {
case '\r':
break;
case '\n':
if (line_start) {
end = 1;
break;
}
rstrip_spaces_buf(dst);
av_bprintf(dst, ""\\N"");
line_start = 1;
break;
case ' ':
if (!line_start)
av_bprint_chars(dst, *in, 1);
break;
case '{':
len = 0;
an += sscanf(in, ""{\\an%*1u}%n"", &len) >= 0 && len > 0;
if (!closing_brace_missing) {
if (   (an != 1 && in[1] == '\\')
|| (in[1] && strchr(""CcFfoPSsYy"", in[1]) && in[2] == ':')) {
char *bracep = strchr(in+2, '}');
if (bracep) {
in = bracep;
break;
} else
closing_brace_missing = 1;
}
}
av_bprint_chars(dst, *in, 1);
break;
case '<':
tag_close = in[1] == '/';
len = 0;
if (scantag(in+tag_close+1, buffer, &len) && len > 0) {
const char *tagname = buffer;
while (*tagname == ' ')
tagname++;
if ((param = strchr(tagname, ' ')))
*param++ = 0;
if ((!tag_close && sptr < FF_ARRAY_ELEMS(stack) && *tagname) ||
( tag_close && sptr > 0 && !strcmp(stack[sptr-1].tag, tagname))) {
int i, j, unknown = 0;
in += len + tag_close;
if (!tag_close)
memset(stack+sptr, 0, sizeof(*stack));
if (!strcmp(tagname, ""font"")) {
if (tag_close) {
for (i=PARAM_NUMBER-1; i>=0; i--)
if (stack[sptr-1].param[i][0])
for (j=sptr-2; j>=0; j--)
if (stack[j].param[i][0]) {
av_bprintf(dst, ""%s"", stack[j].param[i]);
break;
}
} else {
while (param) {
if (!strncmp(param, ""size="", 5)) {
unsigned font_size;
param += 5 + (param[5] == '""');
if (sscanf(param, ""%u"", &font_size) == 1) {
snprintf(stack[sptr].param[PARAM_SIZE],
sizeof(stack[0].param[PARAM_SIZE]),
""{\\fs%u}"", font_size);
}
} else if (!strncmp(param, ""color="", 6)) {
param += 6 + (param[6] == '""');
snprintf(stack[sptr].param[PARAM_COLOR],
sizeof(stack[0].param[PARAM_COLOR]),
""{\\c&H%X&}"",
html_color_parse(log_ctx, param));
} else if (!strncmp(param, ""face="", 5)) {
param += 5 + (param[5] == '""');
len = strcspn(param,
param[-1] == '""' ? ""\"""" :"" "");
av_strlcpy(tmp, param,
FFMIN(sizeof(tmp), len+1));
param += len;
snprintf(stack[sptr].param[PARAM_FACE],
sizeof(stack[0].param[PARAM_FACE]),
""{\\fn%s}"", tmp);
}
if ((param = strchr(param, ' ')))
param++;
}
for (i=0; i<PARAM_NUMBER; i++)
if (stack[sptr].param[i][0])
av_bprintf(dst, ""%s"", stack[sptr].param[i]);
}
} else if (tagname[0] && !tagname[1] && strspn(tagname, ""bisu"") == 1) {
av_bprintf(dst, ""{\\%c%d}"", tagname[0], !tag_close);
} else {
unknown = 1;
snprintf(tmp, sizeof(tmp), ""</%s>"", tagname);
}
if (tag_close) {
sptr--;
} else if (unknown && !strstr(in, tmp)) {
in -= len + tag_close;
av_bprint_chars(dst, *in, 1);
} else
av_strlcpy(stack[sptr++].tag, tagname,
sizeof(stack[0].tag));
break;
}
}
default:
av_bprint_chars(dst, *in, 1);
break;
}
if (*in != ' ' && *in != '\r' && *in != '\n')
line_start = 0;
}
if (!av_bprint_is_complete(dst))
return AVERROR(ENOMEM);
while (dst->len >= 2 && !strncmp(&dst->str[dst->len - 2], ""\\N"", 2))
dst->len -= 2;
dst->str[dst->len] = 0;
rstrip_spaces_buf(dst);
return 0;
}","[29, 30]","A denial of service in the subtitle decoder in FFmpeg 3.2 and 4.1 allows attackers to hog the CPU via a crafted video file in Matroska format, because handle_open_brace in libavcodec/htmlsubtitles.c has a complex format argument to sscanf.",FFmpeg,CVE-2019-9721,CWE-125
7682,8031,"GF_Err abst_box_read(GF_Box *s, GF_BitStream *bs)
{
GF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;
int i;
u32 tmp_strsize;
char *tmp_str;
Bool zfound=GF_FALSE;
GF_Err e;
ISOM_DECREASE_SIZE(ptr, 25)
ptr->bootstrapinfo_version = gf_bs_read_u32(bs);
ptr->profile = gf_bs_read_int(bs, 2);
ptr->live = gf_bs_read_int(bs, 1);
ptr->update = gf_bs_read_int(bs, 1);
ptr->reserved = gf_bs_read_int(bs, 4);
ptr->time_scale = gf_bs_read_u32(bs);
ptr->current_media_time = gf_bs_read_u64(bs);
ptr->smpte_time_code_offset = gf_bs_read_u64(bs);
i=0;
if (ptr->size<8) return GF_ISOM_INVALID_FILE;
tmp_strsize =(u32)ptr->size;
tmp_str = gf_malloc(sizeof(char)*tmp_strsize);
if (!tmp_str) return GF_OUT_OF_MEM;
memset(tmp_str, 0, sizeof(char)*tmp_strsize);
while (tmp_strsize) {
ISOM_DECREASE_SIZE(ptr, 1)
tmp_str[i] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[i]) {
zfound = GF_TRUE;
break;
}
i++;
}
if (!zfound)
return GF_ISOM_INVALID_FILE;
if (i) {
ptr->movie_identifier = gf_strdup(tmp_str);
}
ISOM_DECREASE_SIZE(ptr, 1)
ptr->server_entry_count = gf_bs_read_u8(bs);
for (i=0; i<ptr->server_entry_count; i++) {
int j=0;
zfound = GF_FALSE;
tmp_strsize=(u32)ptr->size;
while (tmp_strsize) {
ISOM_DECREASE_SIZE(ptr, 1)
tmp_str[j] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[j]) {
zfound = GF_TRUE;
break;
}
j++;
}
if (!zfound)
return GF_ISOM_INVALID_FILE;
if (j) {
gf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);
}
}
ISOM_DECREASE_SIZE(ptr, 1)
ptr->quality_entry_count = gf_bs_read_u8(bs);
for (i=0; i<ptr->quality_entry_count; i++) {
int j=0;
zfound = GF_FALSE;
tmp_strsize=(u32)ptr->size;
while (tmp_strsize) {
ISOM_DECREASE_SIZE(ptr, 1)
tmp_str[j] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[j]) {
zfound = GF_TRUE;
break;
}
j++;
}
if (!zfound)
return GF_ISOM_INVALID_FILE;
if (j) {
gf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);
}
}
i=0;
tmp_strsize=(u32)ptr->size;
zfound = GF_FALSE;
while (tmp_strsize) {
ISOM_DECREASE_SIZE(ptr, 1)
tmp_str[i] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[i]) {
zfound = GF_TRUE;
break;
}
i++;
}
if (!zfound)
return GF_ISOM_INVALID_FILE;
if (i) {
ptr->drm_data = gf_strdup(tmp_str);
}
i=0;
tmp_strsize=(u32)ptr->size;
zfound = GF_FALSE;
while (tmp_strsize) {
ISOM_DECREASE_SIZE(ptr, 1)
tmp_str[i] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[i]) {
zfound = GF_TRUE;
break;
}
i++;
}
if (!zfound)
return GF_ISOM_INVALID_FILE;
if (i) {
ptr->meta_data = gf_strdup(tmp_str);
}
ISOM_DECREASE_SIZE(ptr, 1)
ptr->segment_run_table_count = gf_bs_read_u8(bs);
for (i=0; i<ptr->segment_run_table_count; i++) {
GF_AdobeSegmentRunTableBox *asrt = NULL;
e = gf_isom_box_parse((GF_Box **)&asrt, bs);
if (e) {
if (asrt) gf_isom_box_del((GF_Box*)asrt);
gf_free(tmp_str);
return e;
}
gf_list_add(ptr->segment_run_table_entries, asrt);
}
ISOM_DECREASE_SIZE(ptr, 1)
ptr->fragment_run_table_count = gf_bs_read_u8(bs);
for (i=0; i<ptr->fragment_run_table_count; i++) {
GF_AdobeFragmentRunTableBox *afrt = NULL;
e = gf_isom_box_parse((GF_Box **)&afrt, bs);
if (e) {
if (afrt) gf_isom_box_del((GF_Box*)afrt);
gf_free(tmp_str);
return e;
}
gf_list_add(ptr->fragment_run_table_entries, afrt);
}
gf_free(tmp_str);
return GF_OK;
}","[8, 25, 34, 35, 39, 46, 55, 56, 61, 68, 77, 78, 83, 87, 96, 97, 105, 114, 115, 119, 126, 127, 131, 138, 139, 143, 144]",The abst_box_size function in GPAC 1.0.1 allows attackers to cause a denial of service (NULL pointer dereference) via a crafted file in the MP4Box command.,gpac,CVE-2021-32132,CWE-476
7688,7220,"strncat_from_utf8_libarchive2(struct archive_string *as,
const void *_p, size_t len, struct archive_string_conv *sc)
{
const char *s;
int n;
char *p;
char *end;
uint32_t unicode;
#if HAVE_WCRTOMB
mbstate_t shift_state;
memset(&shift_state, 0, sizeof(shift_state));
#else
wctomb(NULL, L'\0');
#endif
(void)sc;
if (archive_string_ensure(as, as->length + len + 1) == NULL)
return (-1);
s = (const char *)_p;
p = as->s + as->length;
end = as->s + as->buffer_length - MB_CUR_MAX -1;
while ((n = _utf8_to_unicode(&unicode, s, len)) != 0) {
wchar_t wc;
if (p >= end) {
as->length = p - as->s;
if (archive_string_ensure(as,
as->length + len * 2 + 1) == NULL)
return (-1);
p = as->s + as->length;
end = as->s + as->buffer_length - MB_CUR_MAX -1;
}
if (n < 0) {
n *= -1;
wc = L'?';
} else
wc = (wchar_t)unicode;
s += n;
len -= n;
#if HAVE_WCRTOMB
n = (int)wcrtomb(p, wc, &shift_state);
#else
n = (int)wctomb(p, wc);
#endif
if (n == -1)
return (-1);
p += n;
}
as->length = p - as->s;
as->s[as->length] = '\0';
return (0);
}",[26],Heap-based buffer overflow in archive_string_append_from_wcs() (archive_string.c) in libarchive-3.4.1dev allows remote attackers to cause a denial of service (out-of-bounds write in heap memory resulting into a crash) via a crafted archive file. NOTE: this only affects users who downloaded the development code from GitHub. Users of the product's official releases are unaffected.,libarchive,CVE-2020-21674,CWE-787
7697,8574,"hash_link_ref(const uint8_t *link_ref, size_t length)
{
size_t i;
unsigned int hash = 0;
for (i = 0; i < length; ++i)
hash = tolower(link_ref[i]) + (hash << 6) + (hash << 16) - hash;
return hash;
}","[3, 4, 5, 6, 7]","Snudown is a reddit-specific fork of the Sundown Markdown parser used by GitHub, with Python integration added. In affected versions snudown was found to be vulnerable to denial of service attacks to its reference table implementation. References written in markdown ` [reference_name]: https://www.example.com` are inserted into a hash table which was found to have a weak hash function, meaning that an attacker can reliably generate a large number of collisions for it. This makes the hash table vulnerable to a hash-collision DoS attack, a type of algorithmic complexity attack. Further the hash table allowed for duplicate entries resulting in long retrieval times. Proofs of concept and further discussion of the hash collision issue are discussed on the snudown GHSA(https://github.com/reddit/snudown/security/advisories/GHSA-6gvv-9q92-w5f6). Users are advised to update to version 1.7.0.",snudown,CVE-2021-41168,CWE-407
7703,9096,"int avi_parse_input_file(avi_t *AVI, int getIndex)
{
int i, rate, scale, idx_type;
s64 n;
unsigned char *hdrl_data;
u64 header_offset=0;
int hdrl_len=0;
int nvi, nai[AVI_MAX_TRACKS], ioff;
u64 tot[AVI_MAX_TRACKS];
u32 j;
int lasttag = 0;
int vids_strh_seen = 0;
int vids_strf_seen = 0;
int auds_strh_seen = 0;
int num_stream = 0;
char data[256];
s64 oldpos=-1, newpos=-1;
int aud_chunks = 0;
if (!AVI) {
AVI_errno = AVI_ERR_OPEN;
return 0;
}
if (avi_read(AVI->fdes,data,12) != 12 )
ERR_EXIT(AVI_ERR_READ)
if (strnicmp(data  ,""RIFF"",4) !=0 || strnicmp(data+8,""AVI "",4) !=0 )
ERR_EXIT(AVI_ERR_NO_AVI)
hdrl_data = 0;
while(1)
{
if( avi_read(AVI->fdes,data,8) != 8 ) break;
newpos = gf_ftell(AVI->fdes);
if(oldpos==newpos) {
return -1;
}
oldpos=newpos;
n = str2ulong((unsigned char *)data+4);
n = PAD_EVEN(n);
if(strnicmp(data,""LIST"",4) == 0)
{
if( avi_read(AVI->fdes,data,4) != 4 ) ERR_EXIT(AVI_ERR_READ)
n -= 4;
if(strnicmp(data,""hdrl"",4) == 0)
{
hdrl_len = (u32) n;
hdrl_data = (unsigned char *) gf_malloc((u32)n);
if(hdrl_data==0) ERR_EXIT(AVI_ERR_NO_MEM);
header_offset = gf_ftell(AVI->fdes);
if( avi_read(AVI->fdes,(char *)hdrl_data, (u32) n) != n ) ERR_EXIT(AVI_ERR_READ)
}
else if(strnicmp(data,""movi"",4) == 0)
{
AVI->movi_start = gf_ftell(AVI->fdes);
if (gf_fseek(AVI->fdes,n,SEEK_CUR)==(u64)-1) break;
}
else if (gf_fseek(AVI->fdes,n,SEEK_CUR)==(u64)-1) break;
}
else if(strnicmp(data,""idx1"",4) == 0)
{
AVI->n_idx = AVI->max_idx = (u32) (n/16);
AVI->idx = (unsigned  char((*)[16]) ) gf_malloc((u32)n);
if(AVI->idx==0) ERR_EXIT(AVI_ERR_NO_MEM)
if(avi_read(AVI->fdes, (char *) AVI->idx, (u32) n) != n ) {
gf_free( AVI->idx);
AVI->idx=NULL;
AVI->n_idx = 0;
}
}
else
gf_fseek(AVI->fdes,n,SEEK_CUR);
}
if(!hdrl_data      ) ERR_EXIT(AVI_ERR_NO_HDRL)
if(!AVI->movi_start) ERR_EXIT(AVI_ERR_NO_MOVI)
for(i=0; i<hdrl_len;)
{
#ifdef DEBUG_ODML
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[avilib] TAG %c%c%c%c\n"", (hdrl_data+i)[0], (hdrl_data+i)[1], (hdrl_data+i)[2], (hdrl_data+i)[3]));
#endif
if(strnicmp((char *)hdrl_data+i,""LIST"",4)==0) {
i+= 12;
continue;
}
n = str2ulong(hdrl_data+i+4);
n = PAD_EVEN(n);
if(strnicmp((char *)hdrl_data+i,""strh"",4)==0)
{
i += 8;
#ifdef DEBUG_ODML
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[avilib] TAG   %c%c%c%c\n"", (hdrl_data+i)[0], (hdrl_data+i)[1], (hdrl_data+i)[2], (hdrl_data+i)[3]));
#endif
if(strnicmp((char *)hdrl_data+i,""vids"",4) == 0 && !vids_strh_seen)
{
memcpy(AVI->compressor,hdrl_data+i+4,4);
AVI->compressor[4] = 0;
AVI->v_codech_off = header_offset + i+4;
scale = str2ulong(hdrl_data+i+20);
rate  = str2ulong(hdrl_data+i+24);
if(scale!=0) AVI->fps = (double)rate/(double)scale;
AVI->video_frames = str2ulong(hdrl_data+i+32);
AVI->video_strn = num_stream;
AVI->max_len = 0;
vids_strh_seen = 1;
lasttag = 1;
memcpy(&AVI->video_stream_header, hdrl_data + i,
sizeof(alAVISTREAMHEADER));
}
else if (strnicmp ((char *)hdrl_data+i,""auds"",4) ==0 && ! auds_strh_seen)
{
AVI->aptr=AVI->anum;
++AVI->anum;
if(AVI->anum > AVI_MAX_TRACKS) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[avilib] error - only %d audio tracks supported\n"", AVI_MAX_TRACKS));
return(-1);
}
AVI->track[AVI->aptr].audio_bytes = str2ulong(hdrl_data+i+32)*avi_sampsize(AVI, 0);
AVI->track[AVI->aptr].audio_strn = num_stream;
AVI->track[AVI->aptr].a_vbr = !str2ulong(hdrl_data+i+44);
AVI->track[AVI->aptr].padrate = str2ulong(hdrl_data+i+24);
memcpy(&AVI->stream_headers[AVI->aptr], hdrl_data + i,
sizeof(alAVISTREAMHEADER));
lasttag = 2;
AVI->track[AVI->aptr].a_codech_off = header_offset + i;
}
else if (strnicmp ((char*)hdrl_data+i,""iavs"",4) ==0 && ! auds_strh_seen) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[avilib] AVILIB: error - DV AVI Type 1 no supported\n""));
return (-1);
}
else
lasttag = 0;
num_stream++;
}
else if(strnicmp((char*)hdrl_data+i,""dmlh"",4) == 0) {
AVI->total_frames = str2ulong(hdrl_data+i+8);
#ifdef DEBUG_ODML
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[avilib] real number of frames %d\n"", AVI->total_frames));
#endif
i += 8;
}
else if(strnicmp((char *)hdrl_data+i,""strf"",4)==0)
{
i += 8;
if(lasttag == 1)
{
alBITMAPINFOHEADER bih;
memcpy(&bih, hdrl_data + i, sizeof(alBITMAPINFOHEADER));
AVI->bitmap_info_header = (alBITMAPINFOHEADER *)
gf_malloc(str2ulong((unsigned char *)&bih.bi_size));
if (AVI->bitmap_info_header != NULL)
memcpy(AVI->bitmap_info_header, hdrl_data + i,
str2ulong((unsigned char *)&bih.bi_size));
AVI->width  = str2ulong(hdrl_data+i+4);
AVI->height = str2ulong(hdrl_data+i+8);
vids_strf_seen = 1;
AVI->v_codecf_off = header_offset + i+16;
memcpy(AVI->compressor2, hdrl_data+i+16, 4);
AVI->compressor2[4] = 0;
if (n>40) {
AVI->extradata_size = (u32) (n - 40);
AVI->extradata = gf_malloc(sizeof(u8)* AVI->extradata_size);
memcpy(AVI->extradata, hdrl_data + i + 40, AVI->extradata_size);
}
}
else if(lasttag == 2)
{
alWAVEFORMATEX *wfe;
char *nwfe;
int wfes;
if ((u32) (hdrl_len - i) < sizeof(alWAVEFORMATEX))
wfes = hdrl_len - i;
else
wfes = sizeof(alWAVEFORMATEX);
wfe = (alWAVEFORMATEX *)gf_malloc(sizeof(alWAVEFORMATEX));
if (wfe != NULL) {
memset(wfe, 0, sizeof(alWAVEFORMATEX));
memcpy(wfe, hdrl_data + i, wfes);
if (str2ushort((unsigned char *)&wfe->cb_size) != 0) {
nwfe = (char *)
gf_realloc(wfe, sizeof(alWAVEFORMATEX) +
str2ushort((unsigned char *)&wfe->cb_size));
if (nwfe != 0) {
s64 lpos = gf_ftell(AVI->fdes);
gf_fseek(AVI->fdes, header_offset + i + sizeof(alWAVEFORMATEX),
SEEK_SET);
wfe = (alWAVEFORMATEX *)nwfe;
nwfe = &nwfe[sizeof(alWAVEFORMATEX)];
avi_read(AVI->fdes, nwfe,
str2ushort((unsigned char *)&wfe->cb_size));
gf_fseek(AVI->fdes, lpos, SEEK_SET);
}
}
AVI->wave_format_ex[AVI->aptr] = wfe;
}
AVI->track[AVI->aptr].a_fmt   = str2ushort(hdrl_data+i  );
AVI->track[AVI->aptr].a_codecf_off = header_offset + i;
AVI->track[AVI->aptr].a_chans = str2ushort(hdrl_data+i+2);
AVI->track[AVI->aptr].a_rate  = str2ulong (hdrl_data+i+4);
AVI->track[AVI->aptr].mp3rate = 8*str2ulong(hdrl_data+i+8)/1000;
AVI->track[AVI->aptr].a_bits  = str2ushort(hdrl_data+i+14);
}
}
else if(strnicmp((char*)hdrl_data+i,""indx"",4) == 0) {
char *a;
if(lasttag == 1)
{
a = (char*)hdrl_data+i;
AVI->video_superindex = (avisuperindex_chunk *) gf_malloc (sizeof (avisuperindex_chunk));
memset(AVI->video_superindex, 0, sizeof (avisuperindex_chunk));
memcpy (AVI->video_superindex->fcc, a, 4);
a += 4;
AVI->video_superindex->dwSize = str2ulong((unsigned char *)a);
a += 4;
AVI->video_superindex->wLongsPerEntry = str2ushort((unsigned char *)a);
a += 2;
AVI->video_superindex->bIndexSubType = *a;
a += 1;
AVI->video_superindex->bIndexType = *a;
a += 1;
AVI->video_superindex->nEntriesInUse = str2ulong((unsigned char *)a);
a += 4;
memcpy (AVI->video_superindex->dwChunkId, a, 4);
a += 4;
a += 4;
a += 4;
a += 4;
if (AVI->video_superindex->bIndexSubType != 0) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[avilib] Invalid Header, bIndexSubType != 0\n""));
}
AVI->video_superindex->aIndex = (avisuperindex_entry*)
gf_malloc (AVI->video_superindex->wLongsPerEntry * AVI->video_superindex->nEntriesInUse * sizeof (u32));
for (j=0; j<AVI->video_superindex->nEntriesInUse; ++j) {
AVI->video_superindex->aIndex[j].qwOffset = str2ullong ((unsigned char*)a);
a += 8;
AVI->video_superindex->aIndex[j].dwSize = str2ulong ((unsigned char*)a);
a += 4;
AVI->video_superindex->aIndex[j].dwDuration = str2ulong ((unsigned char*)a);
a += 4;
#ifdef DEBUG_ODML
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[avilib] [%d] 0x%llx 0x%lx %lu\n"", j,
(unsigned int long)AVI->video_superindex->aIndex[j].qwOffset,
(unsigned long)AVI->video_superindex->aIndex[j].dwSize,
(unsigned long)AVI->video_superindex->aIndex[j].dwDuration));
#endif
}
#ifdef DEBUG_ODML
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[avilib] FOURCC \""%c%c%c%c\""\n"", AVI->video_superindex->fcc[0], AVI->video_superindex->fcc[1],
AVI->video_superindex->fcc[2], AVI->video_superindex->fcc[3]));
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[avilib] LEN \""%ld\""\n"", (long)AVI->video_superindex->dwSize));
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[avilib] wLongsPerEntry \""%d\""\n"", AVI->video_superindex->wLongsPerEntry));
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[avilib] bIndexSubType \""%d\""\n"", AVI->video_superindex->bIndexSubType));
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[avilib] bIndexType \""%d\""\n"", AVI->video_superindex->bIndexType));
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[avilib] nEntriesInUse \""%ld\""\n"", (long)AVI->video_superindex->nEntriesInUse));
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[avilib] dwChunkId \""%c%c%c%c\""\n"", AVI->video_superindex->dwChunkId[0], AVI->video_superindex->dwChunkId[1],
AVI->video_superindex->dwChunkId[2], AVI->video_superindex->dwChunkId[3]));
#endif
AVI->is_opendml = 1;
}
else if(lasttag == 2)
{
a = (char*) hdrl_data+i;
AVI->track[AVI->aptr].audio_superindex = (avisuperindex_chunk *) gf_malloc (sizeof (avisuperindex_chunk));
memcpy (AVI->track[AVI->aptr].audio_superindex->fcc, a, 4);
a += 4;
AVI->track[AVI->aptr].audio_superindex->dwSize = str2ulong((unsigned char*)a);
a += 4;
AVI->track[AVI->aptr].audio_superindex->wLongsPerEntry = str2ushort((unsigned char*)a);
a += 2;
AVI->track[AVI->aptr].audio_superindex->bIndexSubType = *a;
a += 1;
AVI->track[AVI->aptr].audio_superindex->bIndexType = *a;
a += 1;
AVI->track[AVI->aptr].audio_superindex->nEntriesInUse = str2ulong((unsigned char*)a);
a += 4;
memcpy (AVI->track[AVI->aptr].audio_superindex->dwChunkId, a, 4);
a += 4;
a += 4;
a += 4;
a += 4;
if (AVI->track[AVI->aptr].audio_superindex->bIndexSubType != 0) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[avilib] Invalid Header, bIndexSubType != 0\n""));
}
AVI->track[AVI->aptr].audio_superindex->aIndex = (avisuperindex_entry*)
gf_malloc (AVI->track[AVI->aptr].audio_superindex->wLongsPerEntry *
AVI->track[AVI->aptr].audio_superindex->nEntriesInUse * sizeof (u32));
for (j=0; j<AVI->track[AVI->aptr].audio_superindex->nEntriesInUse; ++j) {
AVI->track[AVI->aptr].audio_superindex->aIndex[j].qwOffset = str2ullong ((unsigned char*)a);
a += 8;
AVI->track[AVI->aptr].audio_superindex->aIndex[j].dwSize = str2ulong ((unsigned char*)a);
a += 4;
AVI->track[AVI->aptr].audio_superindex->aIndex[j].dwDuration = str2ulong ((unsigned char*)a);
a += 4;
#ifdef DEBUG_ODML
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[avilib] [%d] 0x%llx 0x%lx %lu\n"", j,
(unsigned int long)AVI->track[AVI->aptr].audio_superindex->aIndex[j].qwOffset,
(unsigned long)AVI->track[AVI->aptr].audio_superindex->aIndex[j].dwSize,
(unsigned long)AVI->track[AVI->aptr].audio_superindex->aIndex[j].dwDuration));
#endif
}
AVI->track[AVI->aptr].audio_superindex->stdindex = NULL;
#ifdef DEBUG_ODML
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[avilib] FOURCC \""%.4s\""\n"", AVI->track[AVI->aptr].audio_superindex->fcc));
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[avilib] LEN \""%ld\""\n"", (long)AVI->track[AVI->aptr].audio_superindex->dwSize));
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[avilib] wLongsPerEntry \""%d\""\n"", AVI->track[AVI->aptr].audio_superindex->wLongsPerEntry));
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[avilib] bIndexSubType \""%d\""\n"", AVI->track[AVI->aptr].audio_superindex->bIndexSubType));
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[avilib] bIndexType \""%d\""\n"", AVI->track[AVI->aptr].audio_superindex->bIndexType));
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[avilib] nEntriesInUse \""%ld\""\n"", (long)AVI->track[AVI->aptr].audio_superindex->nEntriesInUse));
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[avilib] dwChunkId \""%.4s\""\n"", AVI->track[AVI->aptr].audio_superindex->dwChunkId[0]));
#endif
}
i += 8;
}
else if((strnicmp((char*)hdrl_data+i,""JUNK"",4) == 0) ||
(strnicmp((char*)hdrl_data+i,""strn"",4) == 0) ||
(strnicmp((char*)hdrl_data+i,""vprp"",4) == 0)) {
i += 8;
} else
{
i += 8;
lasttag = 0;
}
i += (u32) n;
}
gf_free(hdrl_data);
if(!vids_strh_seen || !vids_strf_seen) ERR_EXIT(AVI_ERR_NO_VIDS)
AVI->video_tag[0] = AVI->video_strn/10 + '0';
AVI->video_tag[1] = AVI->video_strn%10 + '0';
AVI->video_tag[2] = 'd';
AVI->video_tag[3] = 'b';
if(!AVI->track[0].a_chans) AVI->track[0].audio_strn = 99;
{
int tk=0;
for(j=0; j<AVI->anum+1; ++j) {
if (j == AVI->video_strn) continue;
AVI->track[tk].audio_tag[0] = j/10 + '0';
AVI->track[tk].audio_tag[1] = j%10 + '0';
AVI->track[tk].audio_tag[2] = 'w';
AVI->track[tk].audio_tag[3] = 'b';
++tk;
}
}
gf_fseek(AVI->fdes,AVI->movi_start,SEEK_SET);
if(!getIndex) return(0);
idx_type = 0;
if(AVI->idx)
{
s64 pos, len;
for(i=0; i<AVI->n_idx; i++)
if( strnicmp((char *)AVI->idx[i],(char *)AVI->video_tag,3)==0 ) break;
if(i>=AVI->n_idx) ERR_EXIT(AVI_ERR_NO_VIDS)
pos = str2ulong(AVI->idx[i]+ 8);
len = str2ulong(AVI->idx[i]+12);
gf_fseek(AVI->fdes,pos,SEEK_SET);
if(avi_read(AVI->fdes,data,8)!=8) ERR_EXIT(AVI_ERR_READ)
if( strnicmp(data,(char *)AVI->idx[i],4)==0 && str2ulong((unsigned char *)data+4)==len )
{
idx_type = 1;
}
else
{
gf_fseek(AVI->fdes,pos+AVI->movi_start-4,SEEK_SET);
if(avi_read(AVI->fdes,data,8)!=8) ERR_EXIT(AVI_ERR_READ)
if( strnicmp(data,(char *)AVI->idx[i],4)==0 && str2ulong((unsigned char *)data+4)==len )
{
idx_type = 2;
}
}
}
if(idx_type == 0 && !AVI->is_opendml && !AVI->total_frames)
{
gf_fseek(AVI->fdes, AVI->movi_start, SEEK_SET);
AVI->n_idx = 0;
while(1)
{
if( avi_read(AVI->fdes,data,8) != 8 ) break;
n = str2ulong((unsigned char *)data+4);
if(strnicmp(data,""LIST"",4)==0)
{
gf_fseek(AVI->fdes,4,SEEK_CUR);
continue;
}
if( ( (data[2]=='d' || data[2]=='D') &&
(data[3]=='b' || data[3]=='B' || data[3]=='c' || data[3]=='C') )
|| ( (data[2]=='w' || data[2]=='W') &&
(data[3]=='b' || data[3]=='B') ) )
{
u64 __pos = gf_ftell(AVI->fdes) - 8;
avi_add_index_entry(AVI,(unsigned char *)data,0,__pos,n);
}
gf_fseek(AVI->fdes,PAD_EVEN(n),SEEK_CUR);
}
idx_type = 1;
}
if (AVI->is_opendml) {
u64 offset = 0;
hdrl_len = 4+4+2+1+1+4+4+8+4;
char *en, *chunk_start;
int k = 0;
u32 audtr = 0;
u32 nrEntries = 0;
AVI->video_index = NULL;
nvi = 0;
for(audtr=0; audtr<AVI->anum; ++audtr) {
nai[audtr] = 0;
tot[audtr] = 0;
}
for (j=0; j<AVI->video_superindex->nEntriesInUse; j++) {
chunk_start = en = (char*) gf_malloc ((u32) (AVI->video_superindex->aIndex[j].dwSize+hdrl_len) );
if (gf_fseek(AVI->fdes, AVI->video_superindex->aIndex[j].qwOffset, SEEK_SET) == (u64)-1) {
gf_free(chunk_start);
continue;
}
if (avi_read(AVI->fdes, en, (u32) (AVI->video_superindex->aIndex[j].dwSize+hdrl_len) ) <= 0) {
gf_free(chunk_start);
continue;
}
nrEntries = str2ulong((unsigned char*)en + 12);
#ifdef DEBUG_ODML
#endif
offset = str2ullong((unsigned char*)en + 20);
en += hdrl_len;
nvi += nrEntries;
AVI->video_index = (video_index_entry *) gf_realloc (AVI->video_index, nvi * sizeof (video_index_entry));
if (!AVI->video_index) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[avilib] out of mem (size = %ld)\n"", nvi * sizeof (video_index_entry)));
exit(1);
}
while (k < nvi) {
AVI->video_index[k].pos = offset + str2ulong((unsigned char*)en);
en += 4;
AVI->video_index[k].len = str2ulong_len((unsigned char*)en);
AVI->video_index[k].key = str2ulong_key((unsigned char*)en);
en += 4;
if (AVI->video_index[k].pos-offset == 0 && AVI->video_index[k].len == 0) {
k--;
nvi--;
}
#ifdef DEBUG_ODML
#endif
k++;
}
gf_free(chunk_start);
}
AVI->video_frames = nvi;
if (AVI->video_frames == 0) {
AVI->is_opendml=0;
goto multiple_riff;
}
for(audtr=0; audtr<AVI->anum; ++audtr) {
k = 0;
if (!AVI->track[audtr].audio_superindex) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[avilib] (%s) cannot read audio index for track %d\n"", __FILE__, audtr));
continue;
}
for (j=0; j<AVI->track[audtr].audio_superindex->nEntriesInUse; j++) {
chunk_start = en = (char*)gf_malloc ((u32) (AVI->track[audtr].audio_superindex->aIndex[j].dwSize+hdrl_len));
if (gf_fseek(AVI->fdes, AVI->track[audtr].audio_superindex->aIndex[j].qwOffset, SEEK_SET) == (u64)-1) {
gf_free(chunk_start);
continue;
}
if (avi_read(AVI->fdes, en, (u32) (AVI->track[audtr].audio_superindex->aIndex[j].dwSize+hdrl_len)) <= 0) {
gf_free(chunk_start);
continue;
}
nrEntries = str2ulong((unsigned char*)en + 12);
#ifdef DEBUG_ODML
#endif
offset = str2ullong((unsigned char*)en + 20);
en += hdrl_len;
nai[audtr] += nrEntries;
AVI->track[audtr].audio_index = (audio_index_entry *) gf_realloc (AVI->track[audtr].audio_index, nai[audtr] * sizeof (audio_index_entry));
while (k < nai[audtr]) {
AVI->track[audtr].audio_index[k].pos = offset + str2ulong((unsigned char*)en);
en += 4;
AVI->track[audtr].audio_index[k].len = str2ulong_len((unsigned char*)en);
en += 4;
AVI->track[audtr].audio_index[k].tot = tot[audtr];
tot[audtr] += AVI->track[audtr].audio_index[k].len;
#ifdef DEBUG_ODML
#endif
++k;
}
gf_free(chunk_start);
}
AVI->track[audtr].audio_chunks = nai[audtr];
AVI->track[audtr].audio_bytes = tot[audtr];
}
}
else if (AVI->total_frames && !AVI->is_opendml && idx_type==0) {
multiple_riff:
gf_fseek(AVI->fdes, AVI->movi_start, SEEK_SET);
AVI->n_idx = 0;
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[avilib] Reconstructing index...""));
nvi = AVI->video_frames = AVI->total_frames;
nai[0] = AVI->track[0].audio_chunks = AVI->total_frames;
for(j=1; j<AVI->anum; ++j) AVI->track[j].audio_chunks = 0;
AVI->video_index = (video_index_entry *) gf_malloc(nvi*sizeof(video_index_entry));
if(AVI->video_index==0) ERR_EXIT(AVI_ERR_NO_MEM);
for(j=0; j<AVI->anum; ++j) {
if(AVI->track[j].audio_chunks) {
AVI->track[j].audio_index = (audio_index_entry *) gf_malloc((nai[j]+1)*sizeof(audio_index_entry));
memset(AVI->track[j].audio_index, 0, (nai[j]+1)*(sizeof(audio_index_entry)));
if(AVI->track[j].audio_index==0) ERR_EXIT(AVI_ERR_NO_MEM);
}
}
nvi = 0;
for(j=0; j<AVI->anum; ++j) {
nai[j] = 0;
tot[j] = 0;
}
aud_chunks = AVI->total_frames;
while(1)
{
if (nvi >= AVI->total_frames) break;
if( avi_read(AVI->fdes,data,8) != 8 ) break;
n = str2ulong((unsigned char *)data+4);
j=0;
if (aud_chunks - nai[j] -1 <= 0) {
aud_chunks += AVI->total_frames;
AVI->track[j].audio_index = (audio_index_entry *)
gf_realloc( AVI->track[j].audio_index, (aud_chunks+1)*sizeof(audio_index_entry));
if (!AVI->track[j].audio_index) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[avilib] Internal error in avilib -- no mem\n""));
AVI_errno = AVI_ERR_NO_MEM;
return -1;
}
}
if(
(data[0]=='0' || data[1]=='0') &&
(data[2]=='d' || data[2]=='D') &&
(data[3]=='b' || data[3]=='B' || data[3]=='c' || data[3]=='C') ) {
AVI->video_index[nvi].key = 0x0;
AVI->video_index[nvi].pos = gf_ftell(AVI->fdes);
AVI->video_index[nvi].len = (u32) n;
nvi++;
gf_fseek(AVI->fdes,PAD_EVEN(n),SEEK_CUR);
}
else if(
(data[0]=='0' || data[1]=='1') &&
(data[2]=='w' || data[2]=='W') &&
(data[3]=='b' || data[3]=='B') ) {
AVI->track[j].audio_index[nai[j]].pos = gf_ftell(AVI->fdes);
AVI->track[j].audio_index[nai[j]].len = (u32) n;
AVI->track[j].audio_index[nai[j]].tot = tot[j];
tot[j] += AVI->track[j].audio_index[nai[j]].len;
nai[j]++;
gf_fseek(AVI->fdes,PAD_EVEN(n),SEEK_CUR);
}
else {
gf_fseek(AVI->fdes,-4,SEEK_CUR);
}
}
if (nvi < AVI->total_frames) {
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[avilib] Uh? Some frames seems missing (%ld/%d)\n"",
nvi,  AVI->total_frames));
}
AVI->video_frames = nvi;
AVI->track[0].audio_chunks = nai[0];
for(j=0; j<AVI->anum; ++j) AVI->track[j].audio_bytes = tot[j];
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[avilib] done. nvi=%ld nai=%ld tot=%ld\n"", nvi, nai[0], tot[0]));
}
else
{
nvi = 0;
for(j=0; j<AVI->anum; ++j) nai[j] = 0;
for(i=0; i<AVI->n_idx; i++) {
if(strnicmp((char *)AVI->idx[i],AVI->video_tag,3) == 0) nvi++;
for(j=0; j<AVI->anum; ++j) if(strnicmp((char *)AVI->idx[i], AVI->track[j].audio_tag,4) == 0) nai[j]++;
}
AVI->video_frames = nvi;
for(j=0; j<AVI->anum; ++j) AVI->track[j].audio_chunks = nai[j];
if(AVI->video_frames==0) ERR_EXIT(AVI_ERR_NO_VIDS);
AVI->video_index = (video_index_entry *) gf_malloc(nvi*sizeof(video_index_entry));
if(AVI->video_index==0) ERR_EXIT(AVI_ERR_NO_MEM);
for(j=0; j<AVI->anum; ++j) {
if(AVI->track[j].audio_chunks) {
AVI->track[j].audio_index = (audio_index_entry *) gf_malloc((nai[j]+1)*sizeof(audio_index_entry));
memset(AVI->track[j].audio_index, 0, (nai[j]+1)*(sizeof(audio_index_entry)));
if(AVI->track[j].audio_index==0) ERR_EXIT(AVI_ERR_NO_MEM);
}
}
nvi = 0;
for(j=0; j<AVI->anum; ++j) {
nai[j] = 0;
tot[j] = 0;
}
ioff = idx_type == 1 ? 8 : (u32)AVI->movi_start+4;
for(i=0; i<AVI->n_idx; i++) {
if(strnicmp((char *)AVI->idx[i],AVI->video_tag,3) == 0) {
AVI->video_index[nvi].key = str2ulong(AVI->idx[i]+ 4);
AVI->video_index[nvi].pos = str2ulong(AVI->idx[i]+ 8)+ioff;
AVI->video_index[nvi].len = str2ulong(AVI->idx[i]+12);
nvi++;
}
for(j=0; j<AVI->anum; ++j) {
if(strnicmp((char *)AVI->idx[i],AVI->track[j].audio_tag,4) == 0) {
AVI->track[j].audio_index[nai[j]].pos = str2ulong(AVI->idx[i]+ 8)+ioff;
AVI->track[j].audio_index[nai[j]].len = str2ulong(AVI->idx[i]+12);
AVI->track[j].audio_index[nai[j]].tot = tot[j];
tot[j] += AVI->track[j].audio_index[nai[j]].len;
nai[j]++;
}
}
}
for(j=0; j<AVI->anum; ++j) AVI->track[j].audio_bytes = tot[j];
}
gf_fseek(AVI->fdes,AVI->movi_start,SEEK_SET);
AVI->video_pos = 0;
return(0);
}","[3, 4, 44, 157, 159]",Inf loop in GitHub repository gpac/gpac prior to 2.1.0-DEV.,gpac,CVE-2022-1222,CWE-835
7705,3429,"static void show_frame(WriterContext *w, AVFrame *frame, AVStream *stream,
AVFormatContext *fmt_ctx)
{
AVBPrint pbuf;
char val_str[128];
const char *s;
int i;
av_bprint_init(&pbuf, 1, AV_BPRINT_SIZE_UNLIMITED);
writer_print_section_header(w, SECTION_ID_FRAME);
s = av_get_media_type_string(stream->codecpar->codec_type);
if (s) print_str    (""media_type"", s);
else   print_str_opt(""media_type"", ""unknown"");
print_int(""stream_index"",           stream->index);
print_int(""key_frame"",              frame->key_frame);
print_ts  (""pkt_pts"",               frame->pts);
print_time(""pkt_pts_time"",          frame->pts, &stream->time_base);
print_ts  (""pkt_dts"",               frame->pkt_dts);
print_time(""pkt_dts_time"",          frame->pkt_dts, &stream->time_base);
print_ts  (""best_effort_timestamp"", frame->best_effort_timestamp);
print_time(""best_effort_timestamp_time"", frame->best_effort_timestamp, &stream->time_base);
print_duration_ts  (""pkt_duration"",      frame->pkt_duration);
print_duration_time(""pkt_duration_time"", frame->pkt_duration, &stream->time_base);
if (frame->pkt_pos != -1) print_fmt    (""pkt_pos"", ""%""PRId64, frame->pkt_pos);
else                      print_str_opt(""pkt_pos"", ""N/A"");
if (frame->pkt_size != -1) print_val    (""pkt_size"", frame->pkt_size, unit_byte_str);
else                       print_str_opt(""pkt_size"", ""N/A"");
switch (stream->codecpar->codec_type) {
AVRational sar;
case AVMEDIA_TYPE_VIDEO:
print_int(""width"",                  frame->width);
print_int(""height"",                 frame->height);
s = av_get_pix_fmt_name(frame->format);
if (s) print_str    (""pix_fmt"", s);
else   print_str_opt(""pix_fmt"", ""unknown"");
sar = av_guess_sample_aspect_ratio(fmt_ctx, stream, frame);
if (sar.num) {
print_q(""sample_aspect_ratio"", sar, ':');
} else {
print_str_opt(""sample_aspect_ratio"", ""N/A"");
}
print_fmt(""pict_type"",              ""%c"", av_get_picture_type_char(frame->pict_type));
print_int(""coded_picture_number"",   frame->coded_picture_number);
print_int(""display_picture_number"", frame->display_picture_number);
print_int(""interlaced_frame"",       frame->interlaced_frame);
print_int(""top_field_first"",        frame->top_field_first);
print_int(""repeat_pict"",            frame->repeat_pict);
if (frame->color_range != AVCOL_RANGE_UNSPECIFIED)
print_str(""color_range"", av_color_range_name(frame->color_range));
else
print_str_opt(""color_range"", av_color_range_name(frame->color_range));
if (frame->colorspace != AVCOL_SPC_UNSPECIFIED)
print_str(""color_space"", av_color_space_name(frame->colorspace));
else
print_str_opt(""color_space"", av_color_space_name(frame->colorspace));
if (frame->color_primaries != AVCOL_PRI_UNSPECIFIED)
print_str(""color_primaries"", av_color_primaries_name(frame->color_primaries));
else
print_str_opt(""color_primaries"", av_color_primaries_name(frame->color_primaries));
if (frame->color_trc != AVCOL_TRC_UNSPECIFIED)
print_str(""color_transfer"", av_color_transfer_name(frame->color_trc));
else
print_str_opt(""color_transfer"", av_color_transfer_name(frame->color_trc));
if (frame->chroma_location != AVCHROMA_LOC_UNSPECIFIED)
print_str(""chroma_location"", av_chroma_location_name(frame->chroma_location));
else
print_str_opt(""chroma_location"", av_chroma_location_name(frame->chroma_location));
break;
case AVMEDIA_TYPE_AUDIO:
s = av_get_sample_fmt_name(frame->format);
if (s) print_str    (""sample_fmt"", s);
else   print_str_opt(""sample_fmt"", ""unknown"");
print_int(""nb_samples"",         frame->nb_samples);
print_int(""channels"", frame->channels);
if (frame->channel_layout) {
av_bprint_clear(&pbuf);
av_bprint_channel_layout(&pbuf, frame->channels,
frame->channel_layout);
print_str    (""channel_layout"", pbuf.str);
} else
print_str_opt(""channel_layout"", ""unknown"");
break;
}
if (do_show_frame_tags)
show_tags(w, frame->metadata, SECTION_ID_FRAME_TAGS);
if (do_show_log)
show_log(w, SECTION_ID_FRAME_LOGS, SECTION_ID_FRAME_LOG, do_show_log);
if (frame->nb_side_data) {
writer_print_section_header(w, SECTION_ID_FRAME_SIDE_DATA_LIST);
for (i = 0; i < frame->nb_side_data; i++) {
AVFrameSideData *sd = frame->side_data[i];
const char *name;
writer_print_section_header(w, SECTION_ID_FRAME_SIDE_DATA);
name = av_frame_side_data_name(sd->type);
print_str(""side_data_type"", name ? name : ""unknown"");
if (sd->type == AV_FRAME_DATA_DISPLAYMATRIX && sd->size >= 9*4) {
writer_print_integers(w, ""displaymatrix"", sd->data, 9, "" %11d"", 3, 4, 1);
print_int(""rotation"", av_display_rotation_get((int32_t *)sd->data));
} else if (sd->type == AV_FRAME_DATA_GOP_TIMECODE && sd->size >= 8) {
char tcbuf[AV_TIMECODE_STR_SIZE];
av_timecode_make_mpeg_tc_string(tcbuf, *(int64_t *)(sd->data));
print_str(""timecode"", tcbuf);
} else if (sd->type == AV_FRAME_DATA_MASTERING_DISPLAY_METADATA) {
AVMasteringDisplayMetadata *metadata = (AVMasteringDisplayMetadata *)sd->data;
if (metadata->has_primaries) {
print_q(""red_x"", metadata->display_primaries[0][0], '/');
print_q(""red_y"", metadata->display_primaries[0][1], '/');
print_q(""green_x"", metadata->display_primaries[1][0], '/');
print_q(""green_y"", metadata->display_primaries[1][1], '/');
print_q(""blue_x"", metadata->display_primaries[2][0], '/');
print_q(""blue_y"", metadata->display_primaries[2][1], '/');
print_q(""white_point_x"", metadata->white_point[0], '/');
print_q(""white_point_y"", metadata->white_point[1], '/');
}
if (metadata->has_luminance) {
print_q(""min_luminance"", metadata->min_luminance, '/');
print_q(""max_luminance"", metadata->max_luminance, '/');
}
} else if (sd->type == AV_FRAME_DATA_CONTENT_LIGHT_LEVEL) {
AVContentLightMetadata *metadata = (AVContentLightMetadata *)sd->data;
print_int(""max_content"", metadata->MaxCLL);
print_int(""max_average"", metadata->MaxFALL);
} else if (sd->type == AV_FRAME_DATA_ICC_PROFILE) {
AVDictionaryEntry *tag = av_dict_get(sd->metadata, ""name"", NULL, AV_DICT_MATCH_CASE);
if (tag)
print_str(tag->key, tag->value);
print_int(""size"", sd->size);
}
writer_print_section_footer(w);
}
writer_print_section_footer(w);
}
writer_print_section_footer(w);
av_bprint_finalize(&pbuf, NULL);
fflush(stdout);
}","[55, 56, 57, 58]","The av_color_primaries_name function in libavutil/pixdesc.c in FFmpeg 3.3.3 may return a NULL pointer depending on a value contained in a file, but callers do not anticipate this, as demonstrated by the avcodec_string function in libavcodec/utils.c, leading to a NULL pointer dereference. (It is also conceivable that there is security relevance for a NULL pointer dereference in av_color_primaries_name calls within the ffprobe command-line program.)",FFmpeg,CVE-2017-14225,CWE-476
7708,4347,"RemoteFsDevice::RemoteFsDevice(MusicLibraryModel *m, const DeviceOptions &options, const Details &d)
: FsDevice(m, d.name, createUdi(d.name))
, mountToken(0)
, currentMountStatus(false)
, details(d)
, proc(0)
, mounterIface(0)
, messageSent(false)
{
opts=options;
load();
mount();
icn=MonoIcon::icon(details.isLocalFile()
? FontAwesome::foldero
: constSshfsProtocol==details.url.scheme()
? FontAwesome::linux_os
: FontAwesome::windows, Utils::monoIconColor());
}",[7],"An issue was discovered in the cantata-mounter D-Bus service in Cantata through 2.3.1. The mount target path check in mounter.cpp `mpOk()` is insufficient. A regular user can consequently mount a CIFS filesystem anywhere (e.g., outside of the /home directory tree) by passing directory traversal sequences such as a home/../usr substring.",cantata,CVE-2018-12559,CWE-22
7711,8657,"bool SQClass::NewSlot(SQSharedState *ss,const SQObjectPtr &key,const SQObjectPtr &val,bool bstatic)
{
SQObjectPtr temp;
bool belongs_to_static_table = sq_type(val) == OT_CLOSURE || sq_type(val) == OT_NATIVECLOSURE || bstatic;
if(_locked && !belongs_to_static_table)
return false;
if(_members->Get(key,temp) && _isfield(temp))
{
_defaultvalues[_member_idx(temp)].val = val;
return true;
}
if(belongs_to_static_table) {
SQInteger mmidx;
if((sq_type(val) == OT_CLOSURE || sq_type(val) == OT_NATIVECLOSURE) &&
(mmidx = ss->GetMetaMethodIdxByName(key)) != -1) {
_metamethods[mmidx] = val;
}
else {
SQObjectPtr theval = val;
if(_base && sq_type(val) == OT_CLOSURE) {
theval = _closure(val)->Clone();
_closure(theval)->_base = _base;
__ObjAddRef(_base);
}
if(sq_type(temp) == OT_NULL) {
bool isconstructor;
SQVM::IsEqual(ss->_constructoridx, key, isconstructor);
if(isconstructor) {
_constructoridx = (SQInteger)_methods.size();
}
SQClassMember m;
m.val = theval;
_members->NewSlot(key,SQObjectPtr(_make_method_idx(_methods.size())));
_methods.push_back(m);
}
else {
_methods[_member_idx(temp)].val = theval;
}
}
return true;
}
SQClassMember m;
m.val = val;
_members->NewSlot(key,SQObjectPtr(_make_field_idx(_defaultvalues.size())));
_defaultvalues.push_back(m);
return true;
}",[12],"sqclass.cpp in Squirrel through 2.2.5 and 3.x through 3.1 allows an out-of-bounds read (in the core interpreter) that can lead to Code Execution. If a victim executes an attacker-controlled squirrel script, it is possible for the attacker to break out of the squirrel script sandbox even if all dangerous functionality such as File System functions has been disabled. An attacker might abuse this bug to target (for example) Cloud services that allow customization via SquirrelScripts, or distribute malware through video games that embed a Squirrel Engine.",squirrel,CVE-2021-41556,CWE-125
7712,8042,"GF_Err url_box_read(GF_Box *s, GF_BitStream *bs)
{
GF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;
if (ptr->size) {
ptr->location = (char*)gf_malloc((u32) ptr->size);
if (! ptr->location) return GF_OUT_OF_MEM;
gf_bs_read_data(bs, ptr->location, (u32)ptr->size);
}
return GF_OK;
}",[9],Buffer overflow vulnerability in function gf_fprintf in os_file.c in gpac before 1.0.1 allows attackers to execute arbitrary code. The fixed version is 1.0.1.,gpac,CVE-2021-32268,CWE-787
7716,8575,"add_link_ref(
struct link_ref **references,
const uint8_t *name, size_t name_size)
{
struct link_ref *ref = calloc(1, sizeof(struct link_ref));
if (!ref)
return NULL;
ref->id = hash_link_ref(name, name_size);
ref->next = references[ref->id % REF_TABLE_SIZE];
references[ref->id % REF_TABLE_SIZE] = ref;
return ref;
}","[5, 6, 8]","Snudown is a reddit-specific fork of the Sundown Markdown parser used by GitHub, with Python integration added. In affected versions snudown was found to be vulnerable to denial of service attacks to its reference table implementation. References written in markdown ` [reference_name]: https://www.example.com` are inserted into a hash table which was found to have a weak hash function, meaning that an attacker can reliably generate a large number of collisions for it. This makes the hash table vulnerable to a hash-collision DoS attack, a type of algorithmic complexity attack. Further the hash table allowed for duplicate entries resulting in long retrieval times. Proofs of concept and further discussion of the hash collision issue are discussed on the snudown GHSA(https://github.com/reddit/snudown/security/advisories/GHSA-6gvv-9q92-w5f6). Users are advised to update to version 1.7.0.",snudown,CVE-2021-41168,CWE-407
7717,9670,"int main(int argc, char *argv[])
{
bool lrzcat = false, compat = false, recurse = false;
bool options_file = false, conf_file_compression_set = false;
struct timeval start_time, end_time;
struct sigaction handler;
double seconds,total_time;
bool nice_set = false;
int c, i;
int hours,minutes;
extern int optind;
char *eptr, *av;
char *endptr = NULL;
control = &base_control;
initialise_control(control);
av = basename(argv[0]);
if (!strcmp(av, ""lrunzip""))
control->flags |= FLAG_DECOMPRESS;
else if (!strcmp(av, ""lrzcat"")) {
control->flags |= FLAG_DECOMPRESS | FLAG_STDOUT;
lrzcat = true;
} else if (!strcmp(av, ""lrz"")) {
control->flags &= ~FLAG_SHOW_PROGRESS;
control->flags &= ~FLAG_KEEP_FILES;
compat = true;
long_options[1].name = ""stdout"";
long_options[11].name = ""keep"";
}
CrcGenerateTable();
eptr = getenv(""LRZIP"");
if (eptr == NULL)
options_file = read_config(control);
else if (!strstr(eptr,""NOCONFIG""))
options_file = read_config(control);
if (options_file && (control->flags & FLAG_NOT_LZMA))
conf_file_compression_set = true;
while ((c = getopt_long(argc, argv, compat ? coptions : loptions, long_options, &i)) != -1) {
switch (c) {
case 'b':
case 'g':
case 'l':
case 'n':
case 'z':
if ((control->flags & FLAG_NOT_LZMA) && conf_file_compression_set == false)
failure(""Can only use one of -l, -b, -g, -z or -n\n"");
control->flags &= ~FLAG_NOT_LZMA;
if (c == 'b')
control->flags |= FLAG_BZIP2_COMPRESS;
else if (c == 'g')
control->flags |= FLAG_ZLIB_COMPRESS;
else if (c == 'l')
control->flags |= FLAG_LZO_COMPRESS;
else if (c == 'n')
control->flags |= FLAG_NO_COMPRESS;
else if (c == 'z')
control->flags |= FLAG_ZPAQ_COMPRESS;
conf_file_compression_set = false;
break;
case '/':
control->flags &= ~FLAG_NOT_LZMA;
break;
case 'c':
if (compat) {
control->flags |= FLAG_KEEP_FILES;
set_stdout(control);
break;
}
case 'C':
control->flags |= FLAG_CHECK;
control->flags |= FLAG_HASH;
break;
case 'd':
control->flags |= FLAG_DECOMPRESS;
break;
case 'D':
control->flags &= ~FLAG_KEEP_FILES;
break;
case 'e':
control->flags |= FLAG_ENCRYPT;
control->passphrase = optarg;
break;
case 'f':
control->flags |= FLAG_FORCE_REPLACE;
break;
case 'h':
usage(compat);
exit(0);
break;
case 'H':
control->flags |= FLAG_HASH;
break;
case 'i':
control->flags |= FLAG_INFO;
control->flags &= ~FLAG_DECOMPRESS;
break;
case 'k':
if (compat) {
control->flags |= FLAG_KEEP_FILES;
break;
}
case 'K':
control->flags |= FLAG_KEEP_BROKEN;
break;
case 'L':
if (compat) {
license();
exit(0);
}
control->compression_level = strtol(optarg, &endptr, 10);
if (control->compression_level < 1 || control->compression_level > 9)
failure(""Invalid compression level (must be 1-9)\n"");
if (*endptr)
failure(""Extra characters after compression level: \'%s\'\n"", endptr);
break;
case 'm':
control->ramsize = strtol(optarg, &endptr, 10) * 1024 * 1024 * 100;
if (*endptr)
failure(""Extra characters after ramsize: \'%s\'\n"", endptr);
break;
case 'N':
nice_set = true;
control->nice_val = strtol(optarg, &endptr, 10);
if (control->nice_val < PRIO_MIN || control->nice_val > PRIO_MAX)
failure(""Invalid nice value (must be %d...%d)\n"", PRIO_MIN, PRIO_MAX);
if (*endptr)
failure(""Extra characters after nice level: \'%s\'\n"", endptr);
break;
case 'o':
if (control->outdir)
failure(""Cannot have -o and -O together\n"");
if (unlikely(STDOUT))
failure(""Cannot specify an output filename when outputting to stdout\n"");
control->outname = optarg;
control->suffix = """";
break;
case 'O':
if (control->outname)
failure(""Cannot have options -o and -O together\n"");
if (unlikely(STDOUT))
failure(""Cannot specify an output directory when outputting to stdout\n"");
control->outdir = malloc(strlen(optarg) + 2);
if (control->outdir == NULL)
fatal(""Failed to allocate for outdir\n"");
strcpy(control->outdir,optarg);
if (strcmp(optarg+strlen(optarg) - 1, ""/""))
strcat(control->outdir, ""/"");
break;
case 'p':
control->threads = strtol(optarg, &endptr, 10);
if (control->threads < 1)
failure(""Must have at least one thread\n"");
if (*endptr)
failure(""Extra characters after number of threads: \'%s\'\n"", endptr);
break;
case 'P':
control->flags |= FLAG_SHOW_PROGRESS;
break;
case 'q':
control->flags &= ~FLAG_SHOW_PROGRESS;
break;
case 'r':
recurse = true;
break;
case 'S':
if (control->outname)
failure(""Specified output filename already, can't specify an extension.\n"");
if (unlikely(STDOUT))
failure(""Cannot specify a filename suffix when outputting to stdout\n"");
control->suffix = optarg;
break;
case 't':
if (control->outname)
failure(""Cannot specify an output file name when just testing.\n"");
if (compat)
control->flags |= FLAG_KEEP_FILES;
if (!KEEP_FILES)
failure(""Doubt that you want to delete a file when just testing.\n"");
control->flags |= FLAG_TEST_ONLY;
break;
case 'T':
control->flags &= ~FLAG_THRESHOLD;
break;
case 'U':
control->flags |= FLAG_UNLIMITED;
break;
case 'v':
if (!(control->flags & FLAG_SHOW_PROGRESS))
control->flags |= FLAG_SHOW_PROGRESS;
else if (!(control->flags & FLAG_VERBOSITY) && !(control->flags & FLAG_VERBOSITY_MAX))
control->flags |= FLAG_VERBOSITY;
else if ((control->flags & FLAG_VERBOSITY)) {
control->flags &= ~FLAG_VERBOSITY;
control->flags |= FLAG_VERBOSITY_MAX;
}
break;
case 'V':
control->msgout = stdout;
print_output(""lrzip version %s\n"", PACKAGE_VERSION);
exit(0);
break;
case 'w':
control->window = strtol(optarg, &endptr, 10);
if (control->window < 1)
failure(""Window must be positive\n"");
if (*endptr)
failure(""Extra characters after window size: \'%s\'\n"", endptr);
break;
case '1':
case '2':
case '3':
case '4':
case '5':
case '6':
case '7':
case '8':
case '9':
control->compression_level = c - '0';
break;
default:
usage(compat);
return 2;
}
}
argc -= optind;
argv += optind;
if (control->outname) {
if (argc > 1)
failure(""Cannot specify output filename with more than 1 file\n"");
if (recurse)
failure(""Cannot specify output filename with recursive\n"");
}
if (VERBOSE && !SHOW_PROGRESS) {
print_err(""Cannot have -v and -q options. -v wins.\n"");
control->flags |= FLAG_SHOW_PROGRESS;
}
if (UNLIMITED && control->window) {
print_err(""If -U used, cannot specify a window size with -w.\n"");
control->window = 0;
}
if (argc < 1)
control->flags |= FLAG_STDIN;
if (UNLIMITED && STDIN) {
print_err(""Cannot have -U and stdin, unlimited mode disabled.\n"");
control->flags &= ~FLAG_UNLIMITED;
}
setup_overhead(control);
control->current_priority = getpriority(PRIO_PROCESS, 0);
if (nice_set) {
if (!NO_COMPRESS) {
if (unlikely(setpriority(PRIO_PROCESS, 0, control->nice_val/2) == -1)) {
print_err(""Warning, unable to set nice value %d...Resetting to %d\n"",
control->nice_val, control->current_priority);
setpriority(PRIO_PROCESS, 0, (control->nice_val=control->current_priority));
}
} else {
if (unlikely(setpriority(PRIO_PROCESS, 0, control->nice_val) == -1)) {
print_err(""Warning, unable to set nice value %d...Resetting to %d\n"",
control->nice_val, control->current_priority);
setpriority(PRIO_PROCESS, 0, (control->nice_val=control->current_priority));
}
}
}
for (i = 0; i <= argc; i++) {
char *dirlist = NULL, *infile = NULL;
int direntries = 0, curentry = 0;
if (i < argc)
infile = argv[i];
else if (!(i == 0 && STDIN))
break;
if (infile) {
if ((strcmp(infile, ""-"") == 0))
control->flags |= FLAG_STDIN;
else {
bool isdir = false;
struct stat istat;
if (unlikely(stat(infile, &istat)))
failure(""Failed to stat %s\n"", infile);
isdir = S_ISDIR(istat.st_mode);
if (!recurse && (isdir || !S_ISREG(istat.st_mode))) {
failure(""lrzip only works directly on regular FILES.\n""
""Use -r recursive, lrztar or pipe through tar for compressing directories.\n"");
}
if (recurse && !isdir)
failure(""%s not a directory, -r recursive needs a directory\n"", infile);
}
}
if (recurse) {
if (unlikely(STDIN || STDOUT))
failure(""Cannot use -r recursive with STDIO\n"");
recurse_dirlist(infile, &dirlist, &direntries);
}
if (INFO && STDIN)
failure(""Will not get file info from STDIN\n"");
recursion:
if (recurse) {
if (curentry >= direntries) {
infile = NULL;
continue;
}
infile = dirlist + MAX_PATH_LEN * curentry++;
}
control->infile = infile;
if ((control->outname && (strcmp(control->outname, ""-"") == 0)) ||
(!control->outname && STDIN) || lrzcat)
set_stdout(control);
if (lrzcat) {
control->msgout = stderr;
control->outFILE = stdout;
register_outputfile(control, control->msgout);
}
if (!STDOUT) {
control->msgout = stdout;
register_outputfile(control, control->msgout);
}
if (STDIN)
control->inFILE = stdin;
sigemptyset(&handler.sa_mask);
handler.sa_flags = 0;
handler.sa_handler = &sighandler;
sigaction(SIGTERM, &handler, 0);
sigaction(SIGINT, &handler, 0);
if (!FORCE_REPLACE) {
if (STDIN && isatty(fileno((FILE *)stdin))) {
print_err(""Will not read stdin from a terminal. Use -f to override.\n"");
usage(compat);
exit (1);
}
if (!TEST_ONLY && STDOUT && isatty(fileno((FILE *)stdout)) && !compat) {
print_err(""Will not write stdout to a terminal. Use -f to override.\n"");
usage(compat);
exit (1);
}
}
if (CHECK_FILE) {
if (!DECOMPRESS) {
print_err(""Can only check file written on decompression.\n"");
control->flags &= ~FLAG_CHECK;
} else if (STDOUT) {
print_err(""Can't check file written when writing to stdout. Checking disabled.\n"");
control->flags &= ~FLAG_CHECK;
}
}
setup_ram(control);
show_summary();
gettimeofday(&start_time, NULL);
if (unlikely((STDIN || STDOUT) && ENCRYPT))
failure(""Unable to work from STDIO while reading password\n"");
memcpy(&local_control, &base_control, sizeof(rzip_control));
if (DECOMPRESS || TEST_ONLY)
decompress_file(&local_control);
else if (INFO)
get_fileinfo(&local_control);
else
compress_file(&local_control);
gettimeofday(&end_time, NULL);
total_time = (end_time.tv_sec + (double)end_time.tv_usec / 1000000) -
(start_time.tv_sec + (double)start_time.tv_usec / 1000000);
hours = (int)total_time / 3600;
minutes = (int)(total_time / 60) % 60;
seconds = total_time - hours * 3600 - minutes * 60;
if (!INFO)
print_progress(""Total time: %02d:%02d:%05.2f\n"", hours, minutes, seconds);
if (recurse)
goto recursion;
}
return 0;
}","[134, 169]",Irzip v0.640 was discovered to contain a heap memory corruption via the component lrzip.c:initialise_control.,lrzip,CVE-2022-28044,CWE-787
7721,8002,"GF_Err tenc_box_read(GF_Box *s, GF_BitStream *bs)
{
u8 iv_size;
GF_TrackEncryptionBox *ptr = (GF_TrackEncryptionBox*)s;
ISOM_DECREASE_SIZE(ptr, 3);
gf_bs_read_u8(bs);
if (!ptr->version) {
gf_bs_read_u8(bs);
} else {
ptr->crypt_byte_block = gf_bs_read_int(bs, 4);
ptr->skip_byte_block = gf_bs_read_int(bs, 4);
}
ptr->isProtected = gf_bs_read_u8(bs);
ISOM_DECREASE_SIZE(ptr, 17);
ptr->key_info[0] = 0;
ptr->key_info[1] = 0;
ptr->key_info[2] = 0;
ptr->key_info[3] = iv_size = gf_bs_read_u8(bs);
gf_bs_read_data(bs, ptr->key_info+4, 16);
if (!iv_size && ptr->isProtected) {
ISOM_DECREASE_SIZE(ptr, 1);
iv_size = ptr->key_info[20] = gf_bs_read_u8(bs);
ISOM_DECREASE_SIZE(ptr, ptr->key_info[20]);
gf_bs_read_data(bs, ptr->key_info+21, iv_size);
}
return GF_OK;
}","[24, 26]","Buffer overflow in the tenc_box_read function in MP4Box in GPAC 1.0.1 allows attackers to cause a denial of service or execute arbitrary code via a crafted file, related invalid IV sizes.",gpac,CVE-2021-31254,CWE-787
7724,9537,"GF_Err BD_DecMFFieldVec(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field, Bool is_mem_com)
{
GF_Err e;
u32 NbBits, nbFields;
u32 i;
GF_ChildNodeItem *last;
u8 qp_local, qp_on, initial_qp;
GF_FieldInfo sffield;
memset(&sffield, 0, sizeof(GF_FieldInfo));
sffield.fieldIndex = field->fieldIndex;
sffield.fieldType = gf_sg_vrml_get_sf_type(field->fieldType);
sffield.NDTtype = field->NDTtype;
sffield.name = field->name;
initial_qp = qp_local = qp_on = 0;
NbBits = gf_bs_read_int(bs, 5);
nbFields = gf_bs_read_int(bs, NbBits);
if (codec->ActiveQP) {
initial_qp = 1;
gf_bifs_dec_qp14_set_length(codec, nbFields);
}
if (field->fieldType != GF_SG_VRML_MFNODE) {
e = gf_sg_vrml_mf_alloc(field->far_ptr, field->fieldType, nbFields);
if (e) return e;
for (i=0; i<nbFields; i++) {
e = gf_sg_vrml_mf_get_item(field->far_ptr, field->fieldType, & sffield.far_ptr, i);
if (e) return e;
e = gf_bifs_dec_sf_field(codec, bs, node, &sffield, GF_FALSE);
if (e) return e;
}
} else {
last = NULL;
for (i=0; i<nbFields; i++) {
GF_Node *new_node = gf_bifs_dec_node(codec, bs, field->NDTtype);
if (new_node) {
e = gf_node_register(new_node, is_mem_com ? NULL : node);
if (e) return e;
if (node) {
if (gf_node_get_tag(new_node) == TAG_MPEG4_QuantizationParameter) {
qp_local = ((M_QuantizationParameter *)new_node)->isLocal;
if (qp_on) gf_bifs_dec_qp_remove(codec, GF_FALSE);
e = gf_bifs_dec_qp_set(codec, new_node);
if (e) return e;
qp_on = 1;
if (qp_local) qp_local = 2;
if (codec->force_keep_qp) {
e = gf_node_list_add_child_last(field->far_ptr, new_node, &last);
if (e) return e;
} else {
gf_node_register(new_node, NULL);
gf_node_unregister(new_node, node);
}
} else {
e = gf_node_list_add_child_last(field->far_ptr, new_node, &last);
if (e) return e;
}
}
else if (codec->pCurrentProto) {
e = gf_node_list_add_child_last( (GF_ChildNodeItem **)field->far_ptr, new_node, &last);
if (e) return e;
}
} else {
return codec->LastError ? codec->LastError : GF_NON_COMPLIANT_BITSTREAM;
}
}
if (qp_on && qp_local) {
if (qp_local == 2) {
} else {
gf_bifs_dec_qp_remove(codec, initial_qp);
}
}
}
if (qp_on) gf_bifs_dec_qp_remove(codec, GF_TRUE);
return GF_OK;
}","[30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 52, 54, 57, 58, 59, 61, 62, 65, 66, 67, 68, 72, 73]",Use After Free in GitHub repository gpac/gpac prior to 2.1-DEV.,gpac,CVE-2022-2453,CWE-416
7729,9833,"GF_Err xtra_box_read(GF_Box *s, GF_BitStream *bs)
{
GF_XtraBox *ptr = (GF_XtraBox *)s;
while (ptr->size) {
GF_XtraTag *tag;
u32 prop_type = 0;
char *data=NULL, *data2=NULL;
ISOM_DECREASE_SIZE_NO_ERR(ptr, 8)
s32 tag_size = gf_bs_read_u32(bs);
u32 name_size = gf_bs_read_u32(bs);
if (tag_size < 8) return GF_ISOM_INVALID_FILE;
tag_size -= 8;
if ((tag_size>ptr->size) || (name_size>ptr->size)) {
return GF_ISOM_INVALID_FILE;
}
ISOM_DECREASE_SIZE_NO_ERR(ptr, 10)
ISOM_DECREASE_SIZE_NO_ERR(ptr, name_size)
data = gf_malloc(sizeof(char) * (name_size+1));
gf_bs_read_data(bs, data, name_size);
data[name_size] = 0;
tag_size-=name_size;
u32 flags = gf_bs_read_u32(bs);
u32 prop_size = gf_bs_read_u32(bs);
tag_size-=8;
if (prop_size>4) {
tag_size-=2;
prop_type = gf_bs_read_u16(bs);
prop_size -= 6;
ISOM_DECREASE_SIZE_NO_ERR(ptr, prop_size)
data2 = gf_malloc(sizeof(char) * (prop_size+2));
gf_bs_read_data(bs, data2, prop_size);
data2[prop_size] = 0;
data2[prop_size+1] = 0;
tag_size-=prop_size;
} else {
prop_size = 0;
}
GF_SAFEALLOC(tag, GF_XtraTag)
tag->flags = flags;
tag->name = data;
tag->prop_size = prop_size;
tag->prop_value = data2;
tag->prop_type = prop_type;
gf_list_add(ptr->tags, tag);
if (tag_size) {
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[isom] invalid tag size in Xtra !\n""));
}
}
return GF_OK;
}","[30, 34]",Buffer Over-read in GitHub repository gpac/gpac prior to 2.1.0-DEV.,gpac,CVE-2022-3178,CWE-125
7753,7554,"GF_Err SetupWriters(MovieWriter *mw, GF_List *writers, u8 interleaving)
{
u32 i, trackCount;
TrackWriter *writer;
GF_TrackBox *trak;
GF_ISOFile *movie = mw->movie;
mw->total_samples = mw->nb_done = 0;
if (!movie->moov) return GF_OK;
trackCount = gf_list_count(movie->moov->trackList);
for (i = 0; i < trackCount; i++) {
trak = gf_isom_get_track(movie->moov, i+1);
GF_SAFEALLOC(writer, TrackWriter);
if (!writer) goto exit;
writer->sampleNumber = 1;
writer->mdia = trak->Media;
writer->stbl = trak->Media->information->sampleTable;
writer->timeScale = trak->Media->mediaHeader->timeScale;
writer->all_dref_mode = Media_SelfContainedType(writer->mdia);
if (trak->sample_encryption)
writer->prevent_dispatch = GF_TRUE;
writer->isDone = 0;
writer->DTSprev = 0;
writer->chunkDur = 0;
writer->chunkSize = 0;
writer->constant_size = writer->constant_dur = 0;
if (writer->stbl->SampleSize->sampleSize)
writer->constant_size = writer->stbl->SampleSize->sampleSize;
if (writer->stbl->TimeToSample->nb_entries==1) {
writer->constant_dur = writer->stbl->TimeToSample->entries[0].sampleDelta;
if (writer->constant_dur>1) writer->constant_dur = 0;
}
if (!writer->constant_dur || !writer->constant_size || (writer->constant_size>=10))
writer->constant_size = writer->constant_dur = 0;
writer->stsc = (GF_SampleToChunkBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_STSC);
if (!writer->stsc) return GF_OUT_OF_MEM;
if (writer->stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {
writer->stco = gf_isom_box_new(GF_ISOM_BOX_TYPE_STCO);
} else {
writer->stco = gf_isom_box_new(GF_ISOM_BOX_TYPE_CO64);
}
if (!writer->stco) return GF_OUT_OF_MEM;
if (interleaving) writer->stbl->MaxSamplePerChunk = 0;
if (Media_IsSelfContained(writer->mdia, 1))
mw->total_samples += writer->stbl->SampleSize->sampleCount;
if (movie->storageMode != GF_ISOM_STORE_INTERLEAVED) {
gf_list_add(writers, writer);
} else {
if (writer->mdia->information->InfoHeader && writer->mdia->information->InfoHeader->type == GF_ISOM_BOX_TYPE_SMHD) {
gf_list_add(writers, writer);
} else {
gf_list_insert(writers, writer, 0);
}
}
if (movie->sample_groups_in_traf && trak->Media->information->sampleTable) {
gf_isom_box_array_del_parent(&trak->Media->information->sampleTable->child_boxes, trak->Media->information->sampleTable->sampleGroupsDescription);
trak->Media->information->sampleTable->sampleGroupsDescription = NULL;
}
}
return GF_OK;
exit:
CleanWriters(writers);
return GF_OUT_OF_MEM;
}","[11, 12]",An issue was discovered in GPAC version 0.8.0 and 1.0.1. There is an invalid pointer dereference in the function SetupWriters() in isomedia/isom_store.c.,gpac,CVE-2020-35981,CWE-476
7757,6110,"static int zipfileUpdate(
sqlite3_vtab *pVtab,
int nVal,
sqlite3_value **apVal,
sqlite_int64 *pRowid
){
ZipfileTab *pTab = (ZipfileTab*)pVtab;
int rc = SQLITE_OK;
ZipfileEntry *pNew = 0;
u32 mode = 0;
u32 mTime = 0;
i64 sz = 0;
const char *zPath = 0;
int nPath = 0;
const u8 *pData = 0;
int nData = 0;
int iMethod = 0;
u8 *pFree = 0;
char *zFree = 0;
ZipfileEntry *pOld = 0;
ZipfileEntry *pOld2 = 0;
int bUpdate = 0;
int bIsDir = 0;
u32 iCrc32 = 0;
if( pTab->pWriteFd==0 ){
rc = zipfileBegin(pVtab);
if( rc!=SQLITE_OK ) return rc;
}
if( sqlite3_value_type(apVal[0])!=SQLITE_NULL ){
const char *zDelete = (const char*)sqlite3_value_text(apVal[0]);
int nDelete = (int)strlen(zDelete);
if( nVal>1 ){
const char *zUpdate = (const char*)sqlite3_value_text(apVal[1]);
if( zUpdate && zipfileComparePath(zUpdate, zDelete, nDelete)!=0 ){
bUpdate = 1;
}
}
for(pOld=pTab->pFirstEntry; 1; pOld=pOld->pNext){
if( zipfileComparePath(pOld->cds.zFile, zDelete, nDelete)==0 ){
break;
}
assert( pOld->pNext );
}
}
if( nVal>1 ){
if( sqlite3_value_type(apVal[5])!=SQLITE_NULL ){
zipfileTableErr(pTab, ""sz must be NULL"");
rc = SQLITE_CONSTRAINT;
}
if( sqlite3_value_type(apVal[6])!=SQLITE_NULL ){
zipfileTableErr(pTab, ""rawdata must be NULL"");
rc = SQLITE_CONSTRAINT;
}
if( rc==SQLITE_OK ){
if( sqlite3_value_type(apVal[7])==SQLITE_NULL ){
bIsDir = 1;
}else{
const u8 *aIn = sqlite3_value_blob(apVal[7]);
int nIn = sqlite3_value_bytes(apVal[7]);
int bAuto = sqlite3_value_type(apVal[8])==SQLITE_NULL;
iMethod = sqlite3_value_int(apVal[8]);
sz = nIn;
pData = aIn;
nData = nIn;
if( iMethod!=0 && iMethod!=8 ){
zipfileTableErr(pTab, ""unknown compression method: %d"", iMethod);
rc = SQLITE_CONSTRAINT;
}else{
if( bAuto || iMethod ){
int nCmp;
rc = zipfileDeflate(aIn, nIn, &pFree, &nCmp, &pTab->base.zErrMsg);
if( rc==SQLITE_OK ){
if( iMethod || nCmp<nIn ){
iMethod = 8;
pData = pFree;
nData = nCmp;
}
}
}
iCrc32 = crc32(0, aIn, nIn);
}
}
}
if( rc==SQLITE_OK ){
rc = zipfileGetMode(apVal[3], bIsDir, &mode, &pTab->base.zErrMsg);
}
if( rc==SQLITE_OK ){
zPath = (const char*)sqlite3_value_text(apVal[2]);
if( zPath==0 ) zPath = """";
nPath = (int)strlen(zPath);
mTime = zipfileGetTime(apVal[4]);
}
if( rc==SQLITE_OK && bIsDir ){
if( zPath[nPath-1]!='/' ){
zFree = sqlite3_mprintf(""%s/"", zPath);
if( zFree==0 ){ rc = SQLITE_NOMEM; }
zPath = (const char*)zFree;
nPath++;
}
}
if( (pOld==0 || bUpdate) && rc==SQLITE_OK ){
ZipfileEntry *p;
for(p=pTab->pFirstEntry; p; p=p->pNext){
if( zipfileComparePath(p->cds.zFile, zPath, nPath)==0 ){
switch( sqlite3_vtab_on_conflict(pTab->db) ){
case SQLITE_IGNORE: {
goto zipfile_update_done;
}
case SQLITE_REPLACE: {
pOld2 = p;
break;
}
default: {
zipfileTableErr(pTab, ""duplicate name: \""%s\"""", zPath);
rc = SQLITE_CONSTRAINT;
break;
}
}
break;
}
}
}
if( rc==SQLITE_OK ){
pNew = zipfileNewEntry(zPath);
if( pNew==0 ){
rc = SQLITE_NOMEM;
}else{
pNew->cds.iVersionMadeBy = ZIPFILE_NEWENTRY_MADEBY;
pNew->cds.iVersionExtract = ZIPFILE_NEWENTRY_REQUIRED;
pNew->cds.flags = ZIPFILE_NEWENTRY_FLAGS;
pNew->cds.iCompression = (u16)iMethod;
zipfileMtimeToDos(&pNew->cds, mTime);
pNew->cds.crc32 = iCrc32;
pNew->cds.szCompressed = nData;
pNew->cds.szUncompressed = (u32)sz;
pNew->cds.iExternalAttr = (mode<<16);
pNew->cds.iOffset = (u32)pTab->szCurrent;
pNew->cds.nFile = (u16)nPath;
pNew->mUnixTime = (u32)mTime;
rc = zipfileAppendEntry(pTab, pNew, pData, nData);
zipfileAddEntry(pTab, pOld, pNew);
}
}
}
if( rc==SQLITE_OK && (pOld || pOld2) ){
ZipfileCsr *pCsr;
for(pCsr=pTab->pCsrList; pCsr; pCsr=pCsr->pCsrNext){
if( pCsr->pCurrent && (pCsr->pCurrent==pOld || pCsr->pCurrent==pOld2) ){
pCsr->pCurrent = pCsr->pCurrent->pNext;
pCsr->bNoop = 1;
}
}
zipfileRemoveEntryFromList(pTab, pOld);
zipfileRemoveEntryFromList(pTab, pOld2);
}
zipfile_update_done:
sqlite3_free(pFree);
sqlite3_free(zFree);
return rc;
}",[98],"ext/misc/zipfile.c in SQLite 3.30.1 mishandles certain uses of INSERT INTO in situations involving embedded '\0' characters in filenames, leading to a memory-management error that can be detected by (for example) valgrind.",sqlite,CVE-2019-19959,NVD-CWE-Other
7763,5706,"uint32_t GetPayloadTime(size_t handle, uint32_t index, float *in, float *out)
{
mp4object *mp4 = (mp4object *)handle;
if (mp4 == NULL) return 0;
if (mp4->metaoffsets == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in == NULL || out == NULL) return 1;
*in = (float)((double)index * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);
*out = (float)((double)(index + 1) * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);
return 0;
}","[4, 5, 6, 7, 8]",GoPro GPMF-parser 1.2.2 has a heap-based buffer over-read (4 bytes) in GPMF_Next in GPMF_parser.c.,gpmf-parser,CVE-2019-15146,CWE-125
7766,6154,"bool PackLinuxElf32::calls_crt1(Elf32_Rel const *rel, int sz)
{
if (!dynsym || !dynstr) {
return false;
}
for (unsigned relnum= 0; 0 < sz; (sz -= sizeof(Elf32_Rel)), ++rel, ++relnum) {
unsigned const symnum = get_te32(&rel->r_info) >> 8;
char const *const symnam = get_dynsym_name(symnum, relnum);
if (0==strcmp(symnam, ""__libc_start_main"")
||  0==strcmp(symnam, ""__libc_init"")
||  0==strcmp(symnam, ""__uClibc_main"")
||  0==strcmp(symnam, ""__uClibc_start_main""))
return true;
}
return false;
}",[3],p_lx_elf.cpp in UPX before 3.96 has an integer overflow during unpacking via crafted values in a PT_DYNAMIC segment.,upx,CVE-2019-20805,CWE-190
7772,6152,"PackLinuxElf32::invert_pt_dynamic(Elf32_Dyn const *dynp)
{
if (dt_table[Elf32_Dyn::DT_NULL]) {
return;
}
Elf32_Dyn const *const dynp0 = dynp;
unsigned ndx = 1+ 0;
if (dynp)
for (; ; ++ndx, ++dynp) {
unsigned const d_tag = get_te32(&dynp->d_tag);
if (d_tag < DT_NUM) {
dt_table[d_tag] = ndx;
}
if (Elf32_Dyn::DT_NULL == d_tag) {
break;
}
}
upx_dt_init = 0;
if (dt_table[Elf32_Dyn::DT_INIT])          upx_dt_init = Elf32_Dyn::DT_INIT;
else if (dt_table[Elf32_Dyn::DT_PREINIT_ARRAY]) upx_dt_init = Elf32_Dyn::DT_PREINIT_ARRAY;
else if (dt_table[Elf32_Dyn::DT_INIT_ARRAY])    upx_dt_init = Elf32_Dyn::DT_INIT_ARRAY;
unsigned const z_str = dt_table[Elf32_Dyn::DT_STRSZ];
if (z_str) {
strtab_end = get_te32(&dynp0[-1+ z_str].d_val);
if ((u32_t)file_size <= strtab_end) {
char msg[50]; snprintf(msg, sizeof(msg),
""bad DT_STRSZ %#x"", strtab_end);
throwCantPack(msg);
}
}
unsigned const x_sym = dt_table[Elf32_Dyn::DT_SYMTAB];
unsigned const x_str = dt_table[Elf32_Dyn::DT_STRTAB];
if (x_sym && x_str) {
upx_uint32_t const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);
upx_uint32_t const v_str = get_te32(&dynp0[-1+ x_str].d_val);
unsigned const  z_sym = dt_table[Elf32_Dyn::DT_SYMENT];
unsigned const sz_sym = !z_sym ? sizeof(Elf32_Sym)
: get_te32(&dynp0[-1+ z_sym].d_val);
if (v_sym < v_str) {
symnum_end = (v_str - v_sym) / sz_sym;
}
}
unsigned const v_hsh = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH);
if (v_hsh && file_image) {
hashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_HASH);
unsigned const nbucket = get_te32(&hashtab[0]);
unsigned const *const buckets = &hashtab[2];
unsigned const *const chains = &buckets[nbucket]; (void)chains;
unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);
if (!nbucket
|| (nbucket>>31) || (file_size/sizeof(unsigned)) <= (2*nbucket)
|| ((v_hsh < v_sym) && (v_sym - v_hsh) < (sizeof(unsigned)*2
+ sizeof(*buckets)*nbucket
+ sizeof(*chains) *nbucket
))
) {
char msg[90]; snprintf(msg, sizeof(msg),
""bad DT_HASH nbucket=%#x  len=%#x"",
nbucket, (v_sym - v_hsh));
throwCantPack(msg);
}
}
unsigned const v_gsh = elf_unsigned_dynamic(Elf32_Dyn::DT_GNU_HASH);
if (v_gsh && file_image) {
gashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_GNU_HASH);
unsigned const n_bucket = get_te32(&gashtab[0]);
unsigned const n_bitmask = get_te32(&gashtab[2]);
unsigned const gnu_shift = get_te32(&gashtab[3]);
unsigned const *const bitmask = (unsigned const *)(void const *)&gashtab[4];
unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask];
unsigned     const *const hasharr = &buckets[n_bucket]; (void)hasharr;
unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);
if (!n_bucket || !n_bitmask
|| (-1+ n_bitmask) & n_bitmask
|| 8*sizeof(unsigned) <= gnu_shift
|| (n_bucket>>30)
|| (n_bitmask>>30)
|| (file_size / sizeof(unsigned)) <= (n_bitmask + 2*n_bucket)
|| ((v_gsh < v_sym) && (v_sym - v_gsh) < (sizeof(unsigned)*4
+ sizeof(*bitmask)*n_bitmask
+ sizeof(*buckets)*n_bucket
+ sizeof(*hasharr)*n_bucket
))
) {
char msg[90]; snprintf(msg, sizeof(msg),
""bad DT_GNU_HASH n_bucket=%#x  n_bitmask=%#x  len=%#x"",
n_bucket, n_bitmask, v_sym - v_gsh);
throwCantPack(msg);
}
}
unsigned const e_shstrndx = get_te16(&ehdri.e_shstrndx);
if (e_shnum <= e_shstrndx
&&  !(0==e_shnum && 0==e_shstrndx) ) {
char msg[40]; snprintf(msg, sizeof(msg),
""bad .e_shstrndx %d >= .e_shnum %d"", e_shstrndx, e_shnum);
throwCantPack(msg);
}
}","[12, 43, 45, 66]",p_lx_elf.cpp in UPX before 3.96 has an integer overflow during unpacking via crafted values in a PT_DYNAMIC segment.,upx,CVE-2019-20805,CWE-190
7777,1075,"bit_catenate(VarBit *arg1, VarBit *arg2)
{
VarBit    *result;
int   bitlen1,
bitlen2,
bytelen,
bit1pad,
bit2shift;
bits8    *pr,
*pa;
bitlen1 = VARBITLEN(arg1);
bitlen2 = VARBITLEN(arg2);
bytelen = VARBITTOTALLEN(bitlen1 + bitlen2);
result = (VarBit *) palloc(bytelen);
SET_VARSIZE(result, bytelen);
VARBITLEN(result) = bitlen1 + bitlen2;
memcpy(VARBITS(result), VARBITS(arg1), VARBITBYTES(arg1));
bit1pad = VARBITPAD(arg1);
if (bit1pad == 0)
{
memcpy(VARBITS(result) + VARBITBYTES(arg1), VARBITS(arg2),
VARBITBYTES(arg2));
}
else if (bitlen2 > 0)
{
bit2shift = BITS_PER_BYTE - bit1pad;
pr = VARBITS(result) + VARBITBYTES(arg1) - 1;
for (pa = VARBITS(arg2); pa < VARBITEND(arg2); pa++)
{
*pr |= ((*pa >> bit2shift) & BITMASK);
pr++;
if (pr < VARBITEND(result))
*pr = (*pa << bit1pad) & BITMASK;
}
}
return result;
}",[13],"Multiple integer overflows in the path_in and other unspecified functions in PostgreSQL before 8.4.20, 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact and attack vectors, which trigger a buffer overflow.  NOTE: this identifier has been SPLIT due to different affected versions; use CVE-2014-2669 for the hstore vector.",postgres,CVE-2014-0064,CWE-189
7800,9794,"static int open_cred_file(char *file_name,
struct parsed_mount_info *parsed_info)
{
char *line_buf = NULL;
char *temp_val = NULL;
FILE *fs = NULL;
int i;
const int line_buf_size = 4096;
const int min_non_white = 10;
i = toggle_dac_capability(0, 1);
if (i)
goto return_i;
i = access(file_name, R_OK);
if (i) {
toggle_dac_capability(0, 0);
i = errno;
goto return_i;
}
fs = fopen(file_name, ""r"");
if (fs == NULL) {
toggle_dac_capability(0, 0);
i = errno;
goto return_i;
}
i = toggle_dac_capability(0, 0);
if (i)
goto return_i;
line_buf = (char *)malloc(line_buf_size);
if (line_buf == NULL) {
i = EX_SYSERR;
goto return_i;
}
while (fgets(line_buf, line_buf_size, fs)) {
for (i = 0; i < line_buf_size - min_non_white + 1; i++) {
if ((line_buf[i] != ' ') && (line_buf[i] != '\t'))
break;
}
null_terminate_endl(line_buf);
switch (parse_cred_line(line_buf + i, &temp_val)) {
case CRED_USER:
strlcpy(parsed_info->username, temp_val,
sizeof(parsed_info->username));
parsed_info->got_user = 1;
break;
case CRED_PASS:
i = set_password(parsed_info, temp_val);
if (i)
goto return_i;
break;
case CRED_DOM:
if (parsed_info->verboseflag)
fprintf(stderr, ""domain=%s\n"",
temp_val);
strlcpy(parsed_info->domain, temp_val,
sizeof(parsed_info->domain));
break;
case CRED_UNPARSEABLE:
if (parsed_info->verboseflag)
fprintf(stderr, ""Credential formatted ""
""incorrectly: %s\n"",
temp_val ? temp_val : ""(null)"");
break;
}
}
i = 0;
return_i:
if (fs != NULL)
fclose(fs);
if (line_buf != NULL)
memset(line_buf, 0, line_buf_size);
free(line_buf);
return i;
}","[51, 52, 53, 60, 61]","cifs-utils through 6.14, with verbose logging, can cause an information leak when a file contains = (equal sign) characters but is not a valid credentials file.",cifs-utils,CVE-2022-29869,CWE-532
7805,8009,"void gf_isom_cenc_get_default_info_internal(GF_TrackBox *trak, u32 sampleDescriptionIndex, u32 *container_type, Bool *default_IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size)
{
GF_ProtectionSchemeInfoBox *sinf;
if (default_IsEncrypted) *default_IsEncrypted = GF_FALSE;
if (crypt_byte_block) *crypt_byte_block = 0;
if (skip_byte_block) *skip_byte_block = 0;
if (container_type) *container_type = 0;
if (key_info) *key_info = NULL;
if (key_info_size) *key_info_size = 0;
sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CENC_SCHEME, NULL);
if (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CBC_SCHEME, NULL);
if (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CENS_SCHEME, NULL);
if (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CBCS_SCHEME, NULL);
if (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_PIFF_SCHEME, NULL);
if (!sinf) {
u32 i, nb_stsd = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);
for (i=0; i<nb_stsd; i++) {
GF_ProtectionSchemeInfoBox *a_sinf;
GF_SampleEntryBox *sentry=NULL;
if (i+1==sampleDescriptionIndex) continue;
sentry = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, i);
a_sinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(sentry->child_boxes, GF_ISOM_BOX_TYPE_SINF);
if (!a_sinf) continue;
return;
}
}
if (sinf && sinf->info && sinf->info->tenc) {
if (default_IsEncrypted) *default_IsEncrypted = sinf->info->tenc->isProtected;
if (crypt_byte_block) *crypt_byte_block = sinf->info->tenc->crypt_byte_block;
if (skip_byte_block) *skip_byte_block = sinf->info->tenc->skip_byte_block;
if (key_info) *key_info = sinf->info->tenc->key_info;
if (key_info_size) {
*key_info_size = 20;
if (!sinf->info->tenc->key_info[3])
*key_info_size += 1 + sinf->info->tenc->key_info[20];
}
if (container_type) *container_type = GF_ISOM_BOX_TYPE_SENC;
} else if (sinf && sinf->info && sinf->info->piff_tenc) {
if (default_IsEncrypted) *default_IsEncrypted = GF_TRUE;
if (key_info) *key_info = sinf->info->piff_tenc->key_info;
if (key_info_size) *key_info_size = 19;
if (container_type) *container_type = GF_ISOM_BOX_UUID_PSEC;
} else {
u32 i, count = 0;
GF_CENCSampleEncryptionGroupEntry *seig_entry = NULL;
if (!trak->moov->mov->is_smooth)
count = gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription);
for (i=0; i<count; i++) {
GF_SampleGroupDescriptionBox *sgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, i);
if (sgdesc->grouping_type!=GF_ISOM_SAMPLE_GROUP_SEIG) continue;
if (sgdesc->default_description_index)
seig_entry = gf_list_get(sgdesc->group_descriptions, sgdesc->default_description_index-1);
else
seig_entry = gf_list_get(sgdesc->group_descriptions, 0);
if (!seig_entry->key_info[0])
seig_entry = NULL;
break;
}
if (seig_entry) {
if (default_IsEncrypted) *default_IsEncrypted = seig_entry->IsProtected;
if (crypt_byte_block) *crypt_byte_block = seig_entry->crypt_byte_block;
if (skip_byte_block) *skip_byte_block = seig_entry->skip_byte_block;
if (key_info) *key_info = seig_entry->key_info;
if (key_info_size) *key_info_size = seig_entry->key_info_size;
if (container_type) *container_type = GF_ISOM_BOX_TYPE_SENC;
} else {
if (! trak->moov->mov->is_smooth ) {
trak->moov->mov->is_smooth = GF_TRUE;
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] senc box without tenc, assuming MS smooth+piff\n""));
}
if (default_IsEncrypted) *default_IsEncrypted = GF_TRUE;
if (container_type) *container_type = GF_ISOM_BOX_UUID_PSEC;
}
}
if (container_type && trak->sample_encryption) {
if (trak->sample_encryption->type == GF_ISOM_BOX_TYPE_SENC) *container_type = GF_ISOM_BOX_TYPE_SENC;
else if (trak->sample_encryption->type == GF_ISOM_BOX_TYPE_UUID) *container_type = ((GF_UUIDBox*)trak->sample_encryption)->internal_4cc;
}
}",[55],The gf_isom_cenc_get_default_info_internal function in GPAC 1.0.1 allows attackers to cause a denial of service (NULL pointer dereference) via a crafted file in the MP4Box command.,gpac,CVE-2021-31259,CWE-476
7817,7966,"static s32 gf_media_vvc_read_sps_bs_internal(GF_BitStream *bs, VVCState *vvc, u8 layer_id, u32 *vui_flag_pos)
{
s32 vps_id, sps_id;
u32 i, CtbSizeY;
VVC_SPS *sps;
u8 sps_ptl_dpb_hrd_params_present_flag;
if (vui_flag_pos) *vui_flag_pos = 0;
sps_id = gf_bs_read_int_log(bs, 4, ""sps_id"");
if (sps_id >= 16) {
return -1;
}
vps_id = gf_bs_read_int_log(bs, 4, ""vps_id"");
if (vps_id >= 16) {
return -1;
}
if (!vps_id && !vvc->vps[0].state) {
vvc->vps[0].state = 1;
vvc->vps[0].num_ptl = 1;
vvc->vps[0].max_layers = 1;
vvc->vps[0].all_layers_independent = 1;
}
sps = &vvc->sps[sps_id];
if (!sps->state) {
sps->state = 1;
sps->id = sps_id;
sps->vps_id = vps_id;
}
sps->max_sublayers = 1 + gf_bs_read_int_log(bs, 3, ""max_sublayers_minus1"");
sps->chroma_format_idc = gf_bs_read_int_log(bs, 2, ""chroma_format_idc"");
sps->log2_ctu_size = 5 + gf_bs_read_int_log(bs, 2, ""log2_ctu_size_minus5"");
CtbSizeY = 1<<sps->log2_ctu_size;
sps_ptl_dpb_hrd_params_present_flag = gf_bs_read_int_log(bs, 1, ""sps_ptl_dpb_hrd_params_present_flag"");
if (sps_ptl_dpb_hrd_params_present_flag) {
VVC_ProfileTierLevel ptl, *p_ptl;
if (sps->vps_id) {
p_ptl = &ptl;
} else {
p_ptl = &vvc->vps[0].ptl[0];
}
memset(p_ptl, 0, sizeof(VVC_ProfileTierLevel));
p_ptl->pt_present = 1;
p_ptl->ptl_max_tid = sps->max_sublayers;
vvc_profile_tier_level(bs, p_ptl, 0);
}
sps->gdr_enabled = gf_bs_read_int_log(bs, 1, ""gdr_enabled"");
sps->ref_pic_resampling = gf_bs_read_int_log(bs, 1, ""ref_pic_resampling"");
if (sps->ref_pic_resampling)
sps->res_change_in_clvs = gf_bs_read_int_log(bs, 1, ""res_change_in_clvs"");
sps->width = gf_bs_read_ue_log(bs, ""width"");
sps->height = gf_bs_read_ue_log(bs, ""height"");
sps->conf_window = gf_bs_read_int_log(bs, 1, ""conformance_window_present_flag"");
if (sps->conf_window) {
sps->cw_left = gf_bs_read_ue_log(bs, ""conformance_window_left"");
sps->cw_right = gf_bs_read_ue_log(bs, ""conformance_window_right"");
sps->cw_top = gf_bs_read_ue_log(bs, ""conformance_window_top"");
sps->cw_bottom = gf_bs_read_ue_log(bs, ""conformance_window_bottom"");
}
sps->subpic_info_present = gf_bs_read_int_log(bs, 1, ""subpic_info_present"");
if (sps->subpic_info_present) {
sps->nb_subpics = 1 + gf_bs_read_ue_log(bs, ""nb_subpics_minus1"");
if (sps->nb_subpics>1) {
u32 tmpWidthVal, tmpHeightVal;
sps->independent_subpic_flags = gf_bs_read_int_log(bs, 1, ""independent_subpic_flags"");
sps->subpic_same_size = gf_bs_read_int_log(bs, 1, ""subpic_same_size"");
tmpWidthVal = (sps->width + CtbSizeY-1) / CtbSizeY;
tmpWidthVal = gf_get_bit_size(tmpWidthVal);
tmpHeightVal = (sps->height + CtbSizeY-1) / CtbSizeY;
tmpHeightVal = gf_get_bit_size(tmpHeightVal);
for (i=0; i<sps->nb_subpics; i++) {
if( !sps->subpic_same_size || !i) {
if (i && (sps->width > CtbSizeY))
gf_bs_read_int_log(bs, tmpWidthVal, ""subpic_ctu_top_left_x"");
if (i && (sps->height > CtbSizeY))
gf_bs_read_int_log(bs, tmpHeightVal, ""subpic_ctu_top_left_y"");
if ((i+1 < sps->nb_subpics) && (sps->width > CtbSizeY))
gf_bs_read_int_log(bs, tmpWidthVal, ""subpic_width_minus1"");
if ((i+1 < sps->nb_subpics) && (sps->height > CtbSizeY))
gf_bs_read_int_log(bs, tmpHeightVal, ""subpic_height_minus1"");
}
if (!sps->independent_subpic_flags) {
gf_bs_read_int_log(bs, 1, ""subpic_treated_as_pic_flag"");
gf_bs_read_int_log(bs, 1, ""loop_filter_across_subpic_enabled_flag"");
}
}
sps->subpicid_len = gf_bs_read_ue_log(bs, ""subpic_id_len_minus1"") + 1;
sps->subpicid_mapping_explicit = gf_bs_read_int_log(bs, 1, ""subpic_id_mapping_explicitly_signalled_flag"");
if (sps->subpicid_mapping_explicit) {
sps->subpicid_mapping_present = gf_bs_read_int_log(bs, 1, ""subpic_id_mapping_present_flag"");
if (sps->subpicid_mapping_present) {
for (i=0; i<sps->nb_subpics; i++) {
gf_bs_read_ue_log(bs, ""subpic_id"");
}
}
}
}
}
sps->bitdepth = gf_bs_read_ue_log(bs, ""bitdepth_minus8"") + 8;
gf_bs_read_int_log(bs, 1, ""entropy_coding_sync_enabled_flag"");
gf_bs_read_int_log(bs, 1, ""entry_point_offsets_present_flag"");
sps->log2_max_poc_lsb = 4 + gf_bs_read_int_log(bs, 4, ""log2_max_poc_lsb_minus4"");
if ((sps->poc_msb_cycle_flag = gf_bs_read_int_log(bs, 1, ""poc_msb_cycle_flag"")))
sps->poc_msb_cycle_len = 1 + gf_bs_read_ue_log(bs, ""poc_msb_cycle_len_minus1"");
u8 sps_num_extra_ph_bits = 8 * gf_bs_read_int_log(bs, 2, ""sps_num_extra_ph_bytes"");
for (i=0; i<sps_num_extra_ph_bits; i++) {
if (gf_bs_read_int_log_idx(bs, 1, ""extra_ph_bit_present_flag"", 1))
sps->ph_num_extra_bits++;
}
u8 sps_num_extra_sh_bits = 8 * gf_bs_read_int_log(bs, 2, ""num_extra_sh_bytes"");
for (i=0; i<sps_num_extra_sh_bits; i++) {
if (gf_bs_read_int_log_idx(bs, 1, ""extra_sh_bit_present_flag"", i))
sps->sh_num_extra_bits++;
}
if (sps_ptl_dpb_hrd_params_present_flag) {
u8 sps_sublayer_dpb_params_flag = 0;
if (sps->max_sublayers>1) {
sps_sublayer_dpb_params_flag = gf_bs_read_int_log(bs, 1, ""sps_sublayer_dpb_params_flag"");
}
for (i=(sps_sublayer_dpb_params_flag ? 0 : sps->max_sublayers-1); i < sps->max_sublayers; i++ ) {
gf_bs_read_ue_log_idx(bs, ""dpb_max_dec_pic_buffering_minus1"", i);
gf_bs_read_ue_log_idx(bs, ""dpb_max_num_reorder_pics"", i);
gf_bs_read_ue_log_idx(bs, ""dpb_max_latency_increase_plus1"", i);
}
}
gf_bs_read_ue_log(bs, ""sps_log2_min_luma_coding_block_size_minus2"");
gf_bs_read_int_log(bs, 1, ""sps_partition_constraints_override_enabled_flag"");
gf_bs_read_ue_log(bs, ""sps_log2_min_luma_coding_block_size_minus2"");
u8 sps_max_mtt_hierarchy_depth_intra_slice_luma = gf_bs_read_ue_log(bs, ""sps_max_mtt_hierarchy_depth_intra_slice_luma"");
if (sps_max_mtt_hierarchy_depth_intra_slice_luma != 0) {
gf_bs_read_ue_log(bs, ""sps_log2_diff_max_bt_min_qt_intra_slice_luma"");
gf_bs_read_ue_log(bs, ""sps_log2_diff_max_tt_min_qt_intra_slice_luma"");
}
u8 sps_qtbtt_dual_tree_intra_flag = 0;
if (sps->chroma_format_idc) {
sps_qtbtt_dual_tree_intra_flag = gf_bs_read_int_log(bs, 1, ""sps_qtbtt_dual_tree_intra_flag"");
}
if (sps_qtbtt_dual_tree_intra_flag) {
gf_bs_read_ue_log(bs, ""sps_log2_diff_min_qt_min_cb_intra_slice_chroma"");
u8 sps_max_mtt_hierarchy_depth_intra_slice_chroma = gf_bs_read_ue_log(bs, ""sps_max_mtt_hierarchy_depth_intra_slice_chroma"");
if( sps_max_mtt_hierarchy_depth_intra_slice_chroma != 0) {
gf_bs_read_ue_log(bs, ""sps_log2_diff_max_bt_min_qt_intra_slice_chroma"");
gf_bs_read_ue_log(bs, ""sps_log2_diff_max_tt_min_qt_intra_slice_chroma"");
}
}
gf_bs_read_ue_log(bs, ""sps_log2_diff_min_qt_min_cb_inter_slice"");
u8 sps_max_mtt_hierarchy_depth_inter_slice = gf_bs_read_ue_log(bs, ""sps_max_mtt_hierarchy_depth_inter_slice"");
if (sps_max_mtt_hierarchy_depth_inter_slice != 0) {
gf_bs_read_ue_log(bs, ""sps_log2_diff_max_bt_min_qt_inter_slice"");
gf_bs_read_ue_log(bs, ""sps_log2_diff_max_tt_min_qt_inter_slice"");
}
if (CtbSizeY > 32) {
gf_bs_read_int_log(bs, 1, ""sps_max_luma_transform_size_64_flag"");
}
u8 sps_transform_skip_enabled_flag = gf_bs_read_int_log(bs, 1, ""sps_transform_skip_enabled_flag"");
if (sps_transform_skip_enabled_flag) {
gf_bs_read_ue_log(bs, ""sps_log2_transform_skip_max_size_minus2"");
gf_bs_read_int_log(bs, 1, ""sps_bdpcm_enabled_flag"");
}
if (gf_bs_read_int_log(bs, 1, ""sps_mts_enabled_flag"")) {
gf_bs_read_int_log(bs, 1, ""sps_explicit_mts_intra_enabled_flag"");
gf_bs_read_int_log(bs, 1, ""sps_explicit_mts_inter_enabled_flag"");
}
gf_bs_read_int_log(bs, 1, ""sps_lfnst_enabled_flag"");
if (sps->chroma_format_idc) {
u8 sps_joint_cbcr_enabled_flag = gf_bs_read_int_log(bs, 1, ""sps_joint_cbcr_enabled_flag"");
u8 sps_same_qp_table_for_chroma_flag = gf_bs_read_int_log(bs, 1, ""sps_same_qp_table_for_chroma_flag"");
u32 numQpTables = sps_same_qp_table_for_chroma_flag ? 1 : (sps_joint_cbcr_enabled_flag ? 3 : 2);
for (i=0; i<numQpTables; i++) {
gf_bs_read_se_log_idx(bs, ""sps_qp_table_start_minus26"", i);
u32 j, sps_num_points_in_qp_table = 1 + gf_bs_read_ue_log_idx(bs, ""sps_num_points_in_qp_table_minus1"", i);
for (j=0; j<sps_num_points_in_qp_table; j++) {
gf_bs_read_ue_log_idx2(bs, ""sps_delta_qp_in_val_minus1"", i, j);
gf_bs_read_ue_log_idx2(bs, ""sps_delta_qp_diff_val"", i, j);
}
}
}
gf_bs_read_int_log(bs, 1, ""sps_sao_enabled_flag"");
sps->alf_enabled_flag = gf_bs_read_int_log(bs, 1, ""sps_alf_enabled_flag"");
if (sps->alf_enabled_flag && sps->chroma_format_idc) {
gf_bs_read_int_log(bs, 1, ""sps_ccalf_enabled_flag"");
}
return sps_id;
}","[9, 13]",There is a integer overflow in media_tools/av_parsers.c in the hevc_parse_slice_segment function in GPAC 1.0.1 which results in a crash.,gpac,CVE-2021-30014,CWE-190
7839,3549,"av_cold int ff_vc2enc_init_transforms(VC2TransformContext *s, int p_width, int p_height)
{
s->vc2_subband_dwt[VC2_TRANSFORM_9_7]    = vc2_subband_dwt_97;
s->vc2_subband_dwt[VC2_TRANSFORM_5_3]    = vc2_subband_dwt_53;
s->buffer = av_malloc(2*p_width*p_height*sizeof(dwtcoef));
if (!s->buffer)
return 1;
return 0;
}","[5, 8]","The VC-2 Video Compression encoder in FFmpeg 3.0 and 3.4 allows remote attackers to cause a denial of service (out-of-bounds read) because of incorrect buffer padding for non-Haar wavelets, related to libavcodec/vc2enc.c and libavcodec/vc2enc_dwt.c.",FFmpeg,CVE-2017-16840,CWE-125
7843,6121,"static int selectExpander(Walker *pWalker, Select *p){
Parse *pParse = pWalker->pParse;
int i, j, k;
SrcList *pTabList;
ExprList *pEList;
struct SrcList_item *pFrom;
sqlite3 *db = pParse->db;
Expr *pE, *pRight, *pExpr;
u16 selFlags = p->selFlags;
u32 elistFlags = 0;
p->selFlags |= SF_Expanded;
if( db->mallocFailed  ){
return WRC_Abort;
}
assert( p->pSrc!=0 );
if( (selFlags & SF_Expanded)!=0 ){
return WRC_Prune;
}
if( pWalker->eCode ){
p->selId = ++pParse->nSelect;
}
pTabList = p->pSrc;
pEList = p->pEList;
sqlite3WithPush(pParse, p->pWith, 0);
sqlite3SrcListAssignCursors(pParse, pTabList);
for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){
Table *pTab;
assert( pFrom->fg.isRecursive==0 || pFrom->pTab!=0 );
if( pFrom->fg.isRecursive ) continue;
assert( pFrom->pTab==0 );
#ifndef SQLITE_OMIT_CTE
if( withExpand(pWalker, pFrom) ) return WRC_Abort;
if( pFrom->pTab ) {} else
#endif
if( pFrom->zName==0 ){
#ifndef SQLITE_OMIT_SUBQUERY
Select *pSel = pFrom->pSelect;
assert( pSel!=0 );
assert( pFrom->pTab==0 );
if( sqlite3WalkSelect(pWalker, pSel) ) return WRC_Abort;
if( sqlite3ExpandSubquery(pParse, pFrom) ) return WRC_Abort;
#endif
}else{
assert( pFrom->pTab==0 );
pFrom->pTab = pTab = sqlite3LocateTableItem(pParse, 0, pFrom);
if( pTab==0 ) return WRC_Abort;
if( pTab->nTabRef>=0xffff ){
sqlite3ErrorMsg(pParse, ""too many references to \""%s\"": max 65535"",
pTab->zName);
pFrom->pTab = 0;
return WRC_Abort;
}
pTab->nTabRef++;
if( !IsVirtual(pTab) && cannotBeFunction(pParse, pFrom) ){
return WRC_Abort;
}
#if !defined(SQLITE_OMIT_VIEW) || !defined (SQLITE_OMIT_VIRTUALTABLE)
if( IsVirtual(pTab) || pTab->pSelect ){
i16 nCol;
u8 eCodeOrig = pWalker->eCode;
if( sqlite3ViewGetColumnNames(pParse, pTab) ) return WRC_Abort;
assert( pFrom->pSelect==0 );
if( pTab->pSelect && (db->flags & SQLITE_EnableView)==0 ){
sqlite3ErrorMsg(pParse, ""access to view \""%s\"" prohibited"",
pTab->zName);
}
pFrom->pSelect = sqlite3SelectDup(db, pTab->pSelect, 0);
nCol = pTab->nCol;
pTab->nCol = -1;
pWalker->eCode = 1;
sqlite3WalkSelect(pWalker, pFrom->pSelect);
pWalker->eCode = eCodeOrig;
pTab->nCol = nCol;
}
#endif
}
if( sqlite3IndexedByLookup(pParse, pFrom) ){
return WRC_Abort;
}
}
if( db->mallocFailed || sqliteProcessJoin(pParse, p) ){
return WRC_Abort;
}
for(k=0; k<pEList->nExpr; k++){
pE = pEList->a[k].pExpr;
if( pE->op==TK_ASTERISK ) break;
assert( pE->op!=TK_DOT || pE->pRight!=0 );
assert( pE->op!=TK_DOT || (pE->pLeft!=0 && pE->pLeft->op==TK_ID) );
if( pE->op==TK_DOT && pE->pRight->op==TK_ASTERISK ) break;
elistFlags |= pE->flags;
}
if( k<pEList->nExpr ){
struct ExprList_item *a = pEList->a;
ExprList *pNew = 0;
int flags = pParse->db->flags;
int longNames = (flags & SQLITE_FullColNames)!=0
&& (flags & SQLITE_ShortColNames)==0;
for(k=0; k<pEList->nExpr; k++){
pE = a[k].pExpr;
elistFlags |= pE->flags;
pRight = pE->pRight;
assert( pE->op!=TK_DOT || pRight!=0 );
if( pE->op!=TK_ASTERISK
&& (pE->op!=TK_DOT || pRight->op!=TK_ASTERISK)
){
pNew = sqlite3ExprListAppend(pParse, pNew, a[k].pExpr);
if( pNew ){
pNew->a[pNew->nExpr-1].zName = a[k].zName;
pNew->a[pNew->nExpr-1].zSpan = a[k].zSpan;
a[k].zName = 0;
a[k].zSpan = 0;
}
a[k].pExpr = 0;
}else{
int tableSeen = 0;
char *zTName = 0;
if( pE->op==TK_DOT ){
assert( pE->pLeft!=0 );
assert( !ExprHasProperty(pE->pLeft, EP_IntValue) );
zTName = pE->pLeft->u.zToken;
}
for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){
Table *pTab = pFrom->pTab;
Select *pSub = pFrom->pSelect;
char *zTabName = pFrom->zAlias;
const char *zSchemaName = 0;
int iDb;
if( zTabName==0 ){
zTabName = pTab->zName;
}
if( db->mallocFailed ) break;
if( pSub==0 || (pSub->selFlags & SF_NestedFrom)==0 ){
pSub = 0;
if( zTName && sqlite3StrICmp(zTName, zTabName)!=0 ){
continue;
}
iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
zSchemaName = iDb>=0 ? db->aDb[iDb].zDbSName : ""*"";
}
for(j=0; j<pTab->nCol; j++){
char *zName = pTab->aCol[j].zName;
char *zColname;
char *zToFree;
Token sColname;
assert( zName );
if( zTName && pSub
&& sqlite3MatchSpanName(pSub->pEList->a[j].zSpan, 0, zTName, 0)==0
){
continue;
}
if( (p->selFlags & SF_IncludeHidden)==0
&& IsHiddenColumn(&pTab->aCol[j])
){
continue;
}
tableSeen = 1;
if( i>0 && zTName==0 ){
if( (pFrom->fg.jointype & JT_NATURAL)!=0
&& tableAndColumnIndex(pTabList, i, zName, 0, 0)
){
continue;
}
if( sqlite3IdListIndex(pFrom->pUsing, zName)>=0 ){
continue;
}
}
pRight = sqlite3Expr(db, TK_ID, zName);
zColname = zName;
zToFree = 0;
if( longNames || pTabList->nSrc>1 ){
Expr *pLeft;
pLeft = sqlite3Expr(db, TK_ID, zTabName);
pExpr = sqlite3PExpr(pParse, TK_DOT, pLeft, pRight);
if( zSchemaName ){
pLeft = sqlite3Expr(db, TK_ID, zSchemaName);
pExpr = sqlite3PExpr(pParse, TK_DOT, pLeft, pExpr);
}
if( longNames ){
zColname = sqlite3MPrintf(db, ""%s.%s"", zTabName, zName);
zToFree = zColname;
}
}else{
pExpr = pRight;
}
pNew = sqlite3ExprListAppend(pParse, pNew, pExpr);
sqlite3TokenInit(&sColname, zColname);
sqlite3ExprListSetName(pParse, pNew, &sColname, 0);
if( pNew && (p->selFlags & SF_NestedFrom)!=0 ){
struct ExprList_item *pX = &pNew->a[pNew->nExpr-1];
if( pSub ){
pX->zSpan = sqlite3DbStrDup(db, pSub->pEList->a[j].zSpan);
testcase( pX->zSpan==0 );
}else{
pX->zSpan = sqlite3MPrintf(db, ""%s.%s.%s"",
zSchemaName, zTabName, zColname);
testcase( pX->zSpan==0 );
}
pX->bSpanIsTab = 1;
}
sqlite3DbFree(db, zToFree);
}
}
if( !tableSeen ){
if( zTName ){
sqlite3ErrorMsg(pParse, ""no such table: %s"", zTName);
}else{
sqlite3ErrorMsg(pParse, ""no tables specified"");
}
}
}
}
sqlite3ExprListDelete(db, pEList);
p->pEList = pNew;
}
if( p->pEList ){
if( p->pEList->nExpr>db->aLimit[SQLITE_LIMIT_COLUMN] ){
sqlite3ErrorMsg(pParse, ""too many columns in result set"");
return WRC_Abort;
}
if( (elistFlags & (EP_HasFunc|EP_Subquery))!=0 ){
p->selFlags |= SF_ComplexResult;
}
}
return WRC_Continue;
}",[81],selectExpander in select.c in SQLite 3.30.1 proceeds with WITH stack unwinding even after a parsing error.,sqlite,CVE-2019-20218,CWE-755
7853,8013,"GF_AV1Config *gf_isom_av1_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)
{
GF_TrackBox *trak;
GF_MPEGVisualSampleEntryBox *entry;
if (gf_isom_get_reference_count(the_file, trackNumber, GF_ISOM_REF_TBAS)) {
u32 ref_track;
GF_Err e = gf_isom_get_reference(the_file, trackNumber, GF_ISOM_REF_TBAS, 1, &ref_track);
if (e == GF_OK) {
trackNumber = ref_track;
}
}
trak = gf_isom_get_track_from_file(the_file, trackNumber);
if (!trak || !trak->Media || !DescriptionIndex) return NULL;
entry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex - 1);
if (!entry || !entry->av1_config) return NULL;
return AV1_DuplicateConfig(entry->av1_config->config);
}",[15],The AV1_DuplicateConfig function in GPAC 1.0.1 allows attackers to cause a denial of service (NULL pointer dereference) via a crafted file in the MP4Box command.,gpac,CVE-2021-31262,CWE-476
7855,9072,"GF_Err gf_bifs_dec_sf_field(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field, Bool is_mem_com)
{
GF_Err e;
GF_Node *new_node;
u32 size, length, w, h, i;
char *buffer;
if (codec->ActiveQP && node) {
e = gf_bifs_dec_unquant_field(codec, bs, node, field);
if (e != GF_EOS) return e;
}
switch (field->fieldType) {
case GF_SG_VRML_SFBOOL:
* ((SFBool *) field->far_ptr) = (SFBool) gf_bs_read_int(bs, 1);
break;
case GF_SG_VRML_SFCOLOR:
((SFColor *)field->far_ptr)->red = BD_ReadSFFloat(codec, bs);
((SFColor *)field->far_ptr)->green = BD_ReadSFFloat(codec, bs);
((SFColor *)field->far_ptr)->blue = BD_ReadSFFloat(codec, bs);
break;
case GF_SG_VRML_SFFLOAT:
*((SFFloat *)field->far_ptr) = BD_ReadSFFloat(codec, bs);
break;
case GF_SG_VRML_SFINT32:
*((SFInt32 *)field->far_ptr) = (s32) gf_bs_read_int(bs, 32);
break;
case GF_SG_VRML_SFTIME:
*((SFTime *)field->far_ptr) = gf_bs_read_double(bs);
if (node) BD_CheckSFTimeOffset(codec, node, field);
break;
case GF_SG_VRML_SFVEC2F:
((SFVec2f *)field->far_ptr)->x = BD_ReadSFFloat(codec, bs);
((SFVec2f *)field->far_ptr)->y = BD_ReadSFFloat(codec, bs);
break;
case GF_SG_VRML_SFVEC3F:
((SFVec3f *)field->far_ptr)->x = BD_ReadSFFloat(codec, bs);
((SFVec3f *)field->far_ptr)->y = BD_ReadSFFloat(codec, bs);
((SFVec3f *)field->far_ptr)->z = BD_ReadSFFloat(codec, bs);
break;
case GF_SG_VRML_SFROTATION:
((SFRotation *)field->far_ptr)->x = BD_ReadSFFloat(codec, bs);
((SFRotation *)field->far_ptr)->y = BD_ReadSFFloat(codec, bs);
((SFRotation *)field->far_ptr)->z = BD_ReadSFFloat(codec, bs);
((SFRotation *)field->far_ptr)->q = BD_ReadSFFloat(codec, bs);
break;
case GF_SG_VRML_SFSTRING:
size = gf_bs_read_int(bs, 5);
length = gf_bs_read_int(bs, size);
if (gf_bs_available(bs) < length) return GF_NON_COMPLIANT_BITSTREAM;
if (node && (node->sgprivate->tag==TAG_MPEG4_CacheTexture) && (field->fieldIndex<=2)) {
M_CacheTexture *ct = (M_CacheTexture *) node;
ct->data_len = length;
if (ct->data) gf_free(ct->data);
ct->data = (u8*)gf_malloc(sizeof(char)*length);
gf_bs_read_data(bs, (char*)ct->data, length);
} else if (node && (node->sgprivate->tag==TAG_MPEG4_BitWrapper) ) {
M_BitWrapper *bw = (M_BitWrapper*) node;
if (bw->buffer.buffer) gf_free(bw->buffer.buffer);
bw->buffer_len = length;
bw->buffer.buffer = (char*)gf_malloc(sizeof(char)*length);
gf_bs_read_data(bs, (char*)bw->buffer.buffer, length);
} else {
if ( ((SFString *)field->far_ptr)->buffer ) gf_free( ((SFString *)field->far_ptr)->buffer);
((SFString *)field->far_ptr)->buffer = (char *)gf_malloc(sizeof(char)*(length+1));
memset(((SFString *)field->far_ptr)->buffer , 0, length+1);
for (i=0; i<length; i++) {
((SFString *)field->far_ptr)->buffer[i] = gf_bs_read_int(bs, 8);
}
}
break;
case GF_SG_VRML_SFURL:
{
SFURL *url = (SFURL *) field->far_ptr;
size = gf_bs_read_int(bs, 1);
if (size) {
if (url->url) gf_free(url->url );
url->url = NULL;
length = gf_bs_read_int(bs, 10);
url->OD_ID = length;
} else {
if ( url->OD_ID ) url->OD_ID = (u32) -1;
size = gf_bs_read_int(bs, 5);
length = gf_bs_read_int(bs, size);
if (gf_bs_available(bs) < length) return GF_NON_COMPLIANT_BITSTREAM;
buffer = NULL;
if (length) {
buffer = (char *)gf_malloc(sizeof(char)*(length+1));
memset(buffer, 0, length+1);
for (i=0; i<length; i++) buffer[i] = gf_bs_read_int(bs, 8);
}
if (url->url) gf_free( url->url);
if (buffer && strlen(buffer)) {
url->url = buffer;
} else {
gf_free(buffer);
url->url = NULL;
}
}
}
break;
case GF_SG_VRML_SFIMAGE:
if (((SFImage *)field->far_ptr)->pixels) {
gf_free(((SFImage *)field->far_ptr)->pixels);
((SFImage *)field->far_ptr)->pixels = NULL;
}
w = gf_bs_read_int(bs, 12);
h = gf_bs_read_int(bs, 12);
length = gf_bs_read_int(bs, 2);
if (length > 3) length = 3;
length += 1;
size = w * h * length;
if (gf_bs_available(bs) < size) return GF_NON_COMPLIANT_BITSTREAM;
((SFImage *)field->far_ptr)->width = w;
((SFImage *)field->far_ptr)->height = h;
((SFImage *)field->far_ptr)->numComponents = length;
((SFImage *)field->far_ptr)->pixels = (unsigned char *)gf_malloc(sizeof(char)*size);
for (i=0; i<size; i++) {
((SFImage *)field->far_ptr)->pixels[i] = gf_bs_read_int(bs, 8);
}
break;
case GF_SG_VRML_SFCOMMANDBUFFER:
{
SFCommandBuffer *sfcb = (SFCommandBuffer *)field->far_ptr;
if (!node) return GF_BAD_PARAM;
if (sfcb->buffer) {
gf_free(sfcb->buffer);
sfcb->buffer = NULL;
}
while (gf_list_count(sfcb->commandList)) {
GF_Command *com = (GF_Command*)gf_list_get(sfcb->commandList, 0);
gf_list_rem(sfcb->commandList, 0);
gf_sg_command_del(com);
}
size = gf_bs_read_int(bs, 5);
length = gf_bs_read_int(bs, size);
if (gf_bs_available(bs) < length) return GF_NON_COMPLIANT_BITSTREAM;
sfcb->bufferSize = length;
if (length) {
sfcb->buffer = (unsigned char *)gf_malloc(sizeof(char)*(length));
for (i=0; i<length; i++) {
sfcb->buffer[i] = gf_bs_read_int(bs, 8);
}
}
SFCommandBufferChanged(codec, node);
if (codec->dec_memory_mode || (node->sgprivate->tag==TAG_MPEG4_InputSensor)) {
CommandBufferItem *cbi = (CommandBufferItem *)gf_malloc(sizeof(CommandBufferItem));
cbi->node = node;
gf_node_register(cbi->node, NULL);
cbi->cb = sfcb;
gf_list_add(codec->command_buffers, cbi);
}
}
break;
case GF_SG_VRML_SFNODE:
if (!is_mem_com) {
GF_Node *old_node = *((GF_Node **) field->far_ptr);
if (old_node != NULL) {
u32 i, count = gf_list_count(codec->command_buffers);
for (i=0; i<count; i++) {
CommandBufferItem *cbi = (CommandBufferItem*) gf_list_get(codec->command_buffers, i);
if (cbi->node == old_node) {
gf_list_rem(codec->command_buffers, i);
i--;
count--;
gf_node_unregister(cbi->node, NULL);
gf_free(cbi);
}
}
gf_node_unregister(old_node, node);
*((GF_Node **) field->far_ptr) = NULL;
}
}
new_node = gf_bifs_dec_node(codec, bs, field->NDTtype);
if (new_node) {
e = gf_node_register(new_node, is_mem_com ? NULL : node);
if (e) return e;
}
*((GF_Node **) field->far_ptr) = new_node;
break;
case GF_SG_VRML_SFSCRIPT:
#ifdef GPAC_HAS_QJS
codec->LastError = node ? SFScript_Parse(codec, (SFScript*)field->far_ptr, bs, node) : GF_NON_COMPLIANT_BITSTREAM;
#else
return GF_NOT_SUPPORTED;
#endif
break;
case GF_SG_VRML_SFATTRREF:
{
SFAttrRef *ar = (SFAttrRef *)field->far_ptr;
u32 nodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);
ar->node = gf_sg_find_node(codec->current_graph, nodeID);
if (!ar->node) {
} else {
u32 nbBitsDEF = gf_get_bit_size(gf_node_get_num_fields_in_mode(ar->node, GF_SG_FIELD_CODING_DEF) - 1);
u32 field_ref = gf_bs_read_int(bs, nbBitsDEF);
codec->LastError = gf_bifs_get_field_index(ar->node, field_ref, GF_SG_FIELD_CODING_DEF, &ar->fieldIndex);
}
}
break;
default:
return GF_NON_COMPLIANT_BITSTREAM;
}
return codec->LastError;
}",[128],Null Pointer Dereference Caused Segmentation Fault in GitHub repository gpac/gpac prior to 2.1.0-DEV.,gpac,CVE-2022-1172,CWE-476
7856,9658,"ctcompare(const char *a,
const char *b)
{
int result = 0;
while (*a && *b)
{
result |= *a ^ *b;
a ++;
b ++;
}
return (result);
}",[11],"A logic issue was addressed with improved state management. This issue is fixed in Security Update 2022-003 Catalina, macOS Monterey 12.3, macOS Big Sur 11.6.5. An application may be able to gain elevated privileges.",cups,CVE-2022-26691,CWE-697
7857,6151,"coolkey_add_object(coolkey_private_data_t *priv, unsigned long object_id, const u8 *object_data, size_t object_length, int add_v1_record)
{
sc_cardctl_coolkey_object_t new_object;
int r;
memset(&new_object, 0, sizeof(new_object));
new_object.path = coolkey_template_path;
new_object.path.len = 4;
ulong2bebytes(new_object.path.value, object_id);
new_object.id = object_id;
new_object.length = object_length;
if (object_data) {
new_object.data = malloc(object_length + add_v1_record);
if (new_object.data == NULL) {
return SC_ERROR_OUT_OF_MEMORY;
}
if (add_v1_record) {
new_object.data[0] = COOLKEY_V1_OBJECT;
new_object.length++;
}
memcpy(&new_object.data[add_v1_record], object_data, object_length);
}
r = coolkey_add_object_to_list(&priv->objects_list, &new_object);
if (r != SC_SUCCESS) {
free(new_object.data);
new_object.data = NULL;
}
return r;
}",[11],OpenSC before 0.20.0 has a double free in coolkey_free_private_data because coolkey_add_object in libopensc/card-coolkey.c lacks a uniqueness check.,OpenSC,CVE-2019-20792,CWE-415
7860,7473,"PackLinuxElf64::invert_pt_dynamic(Elf64_Dyn const *dynp)
{
if (dt_table[Elf64_Dyn::DT_NULL]) {
return;
}
Elf64_Dyn const *const dynp0 = dynp;
unsigned ndx = 1+ 0;
if (dynp)
for (; ; ++ndx, ++dynp) {
upx_uint64_t const d_tag = get_te64(&dynp->d_tag);
if (d_tag>>32) {
char msg[50]; snprintf(msg, sizeof(msg),
""bad Elf64_Dyn[%d].d_tag %#lx"", -1+ ndx, (long unsigned)d_tag);
throwCantPack(msg);
}
if (d_tag < DT_NUM) {
if (Elf64_Dyn::DT_NEEDED != d_tag
&&  dt_table[d_tag]
&&    get_te64(&dynp->d_val)
!= get_te64(&dynp0[-1+ dt_table[d_tag]].d_val)) {
char msg[50]; snprintf(msg, sizeof(msg),
""duplicate DT_%#x: [%#x] [%#x]"",
(unsigned)d_tag, -1+ dt_table[d_tag], -1+ ndx);
throwCantPack(msg);
}
dt_table[d_tag] = ndx;
}
if (Elf64_Dyn::DT_NULL == d_tag) {
break;
}
}
upx_dt_init = 0;
if (dt_table[Elf64_Dyn::DT_INIT])          upx_dt_init = Elf64_Dyn::DT_INIT;
else if (dt_table[Elf64_Dyn::DT_PREINIT_ARRAY]) upx_dt_init = Elf64_Dyn::DT_PREINIT_ARRAY;
else if (dt_table[Elf64_Dyn::DT_INIT_ARRAY])    upx_dt_init = Elf64_Dyn::DT_INIT_ARRAY;
unsigned const z_str = dt_table[Elf64_Dyn::DT_STRSZ];
if (z_str) {
strtab_end = get_te64(&dynp0[-1+ z_str].d_val);
if ((u64_t)file_size <= strtab_end) {
char msg[50]; snprintf(msg, sizeof(msg),
""bad DT_STRSZ %#x"", strtab_end);
throwCantPack(msg);
}
}
unsigned const x_sym = dt_table[Elf64_Dyn::DT_SYMTAB];
unsigned const x_str = dt_table[Elf64_Dyn::DT_STRTAB];
if (x_sym && x_str) {
upx_uint64_t const v_sym = get_te64(&dynp0[-1+ x_sym].d_val);
upx_uint64_t const v_str = get_te64(&dynp0[-1+ x_str].d_val);
unsigned const  z_sym = dt_table[Elf64_Dyn::DT_SYMENT];
unsigned const sz_sym = !z_sym ? sizeof(Elf64_Sym)
: get_te64(&dynp0[-1+ z_sym].d_val);
if (v_sym < v_str) {
symnum_end = (v_str - v_sym) / sz_sym;
}
}
unsigned const v_hsh = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH);
if (v_hsh && file_image) {
hashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_HASH);
if (!hashtab) {
char msg[40]; snprintf(msg, sizeof(msg),
""bad DT_HASH %#x"", v_hsh);
throwCantPack(msg);
}
unsigned const nbucket = get_te32(&hashtab[0]);
unsigned const *const buckets = &hashtab[2];
unsigned const *const chains = &buckets[nbucket]; (void)chains;
unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);
if (!nbucket
|| (nbucket>>31) || (file_size/sizeof(unsigned)) <= (2*nbucket)
|| ((v_hsh < v_sym) && (v_sym - v_hsh) < (sizeof(unsigned)*2
+ sizeof(*buckets)*nbucket
+ sizeof(*chains) *nbucket
))
) {
char msg[90]; snprintf(msg, sizeof(msg),
""bad DT_HASH nbucket=%#x  len=%#x"",
nbucket, (v_sym - v_hsh));
throwCantPack(msg);
}
}
unsigned const v_gsh = elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH);
if (v_gsh && file_image) {
gashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_GNU_HASH);
if (!gashtab) {
char msg[40]; snprintf(msg, sizeof(msg),
""bad DT_GNU_HASH %#x"", v_gsh);
throwCantPack(msg);
}
unsigned const n_bucket = get_te32(&gashtab[0]);
unsigned const n_bitmask = get_te32(&gashtab[2]);
unsigned const gnu_shift = get_te32(&gashtab[3]);
upx_uint64_t const *const bitmask = (upx_uint64_t const *)(void const *)&gashtab[4];
unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask];
unsigned     const *const hasharr = &buckets[n_bucket]; (void)hasharr;
upx_uint64_t const v_sym = get_te64(&dynp0[-1+ x_sym].d_val);
if (!n_bucket || !n_bitmask
|| (-1+ n_bitmask) & n_bitmask
|| 8*sizeof(upx_uint64_t) <= gnu_shift
|| (n_bucket>>30)
|| (n_bitmask>>30)
|| (file_size/sizeof(unsigned)) <= ((sizeof(*bitmask)/sizeof(unsigned))*n_bitmask + 2*n_bucket)
|| ((v_gsh < v_sym) && (v_sym - v_gsh) < (sizeof(unsigned)*4
+ sizeof(*bitmask)*n_bitmask
+ sizeof(*buckets)*n_bucket
+ sizeof(*hasharr)*n_bucket
))
) {
char msg[90]; snprintf(msg, sizeof(msg),
""bad DT_GNU_HASH n_bucket=%#x  n_bitmask=%#x  len=%#lx"",
n_bucket, n_bitmask, (long unsigned)(v_sym - v_gsh));
throwCantPack(msg);
}
}
unsigned const e_shstrndx = get_te16(&ehdri.e_shstrndx);
if (e_shnum <= e_shstrndx
&&  !(0==e_shnum && 0==e_shstrndx) ) {
char msg[40]; snprintf(msg, sizeof(msg),
""bad .e_shstrndx %d >= .e_shnum %d"", e_shstrndx, e_shnum);
throwCantPack(msg);
}
}","[53, 57]",A floating point exception issue was discovered in UPX in PackLinuxElf64::invert_pt_dynamic() function of p_lx_elf.cpp file. An attacker with a crafted input file could trigger this issue that could cause a crash leading to a denial of service. The highest impact is to Availability.,upx,CVE-2020-27790,CWE-369
7893,8048,"GF_Err gf_hinter_finalize(GF_ISOFile *file, GF_SDP_IODProfile IOD_Profile, u32 bandwidth)
{
u32 i, sceneT, odT, descIndex, size, size64;
GF_InitialObjectDescriptor *iod;
GF_SLConfig slc;
GF_ISOSample *samp;
Bool remove_ocr;
u8 *buffer;
char buf64[5000], sdpLine[5100];
gf_isom_sdp_clean(file);
if (bandwidth) {
sprintf(buf64, ""b=AS:%d"", bandwidth);
gf_isom_sdp_add_line(file, buf64);
}
if (gf_sys_is_test_mode()) {
sprintf(buf64, ""a=x-copyright: %s"", ""MP4/3GP File hinted with GPAC - (c) Telecom ParisTech (http:gpac.io)"");
} else {
sprintf(buf64, ""a=x-copyright: MP4/3GP File hinted with GPAC %s - %s"", gf_gpac_version(), gf_gpac_copyright() );
}
gf_isom_sdp_add_line(file, buf64);
if (IOD_Profile == GF_SDP_IOD_NONE) return GF_OK;
odT = sceneT = 0;
for (i=0; i<gf_isom_get_track_count(file); i++) {
if (!gf_isom_is_track_in_root_od(file, i+1)) continue;
switch (gf_isom_get_media_type(file,i+1)) {
case GF_ISOM_MEDIA_OD:
odT = i+1;
break;
case GF_ISOM_MEDIA_SCENE:
sceneT = i+1;
break;
}
}
remove_ocr = 0;
if (IOD_Profile == GF_SDP_IOD_ISMA_STRICT) {
IOD_Profile = GF_SDP_IOD_ISMA;
remove_ocr = 1;
}
if ( (IOD_Profile == GF_SDP_IOD_ISMA) && !sceneT ) return GF_BAD_PARAM;
iod = (GF_InitialObjectDescriptor *) gf_isom_get_root_od(file);
if (!iod) return GF_NOT_SUPPORTED;
if (IOD_Profile == GF_SDP_IOD_ISMA) {
GF_ESD *esd;
Bool is_ok = 1;
while (gf_list_count(iod->ESDescriptors)) {
esd = (GF_ESD*)gf_list_get(iod->ESDescriptors, 0);
gf_odf_desc_del((GF_Descriptor *) esd);
gf_list_rem(iod->ESDescriptors, 0);
}
if (odT) {
esd = gf_isom_get_esd(file, odT, 1);
if (gf_isom_get_sample_count(file, odT)==1) {
samp = gf_isom_get_sample(file, odT, 1, &descIndex);
if (samp && gf_hinter_can_embbed_data(samp->data, samp->dataLength, GF_STREAM_OD)) {
InitSL_NULL(&slc);
slc.predefined = 0;
slc.hasRandomAccessUnitsOnlyFlag = 1;
slc.timeScale = slc.timestampResolution = gf_isom_get_media_timescale(file, odT);
slc.OCRResolution = 1000;
slc.startCTS = samp->DTS+samp->CTS_Offset;
slc.startDTS = samp->DTS;
gf_isom_set_extraction_slc(file, odT, 1, &slc);
size64 = gf_base64_encode(samp->data, samp->dataLength, buf64, 2000);
buf64[size64] = 0;
sprintf(sdpLine, ""data:application/mpeg4-od-au;base64,%s"", buf64);
esd->decoderConfig->avgBitrate = 0;
esd->decoderConfig->bufferSizeDB = samp->dataLength;
esd->decoderConfig->maxBitrate = 0;
size64 = (u32) strlen(sdpLine)+1;
esd->URLString = (char*)gf_malloc(sizeof(char) * size64);
strcpy(esd->URLString, sdpLine);
} else {
GF_LOG(GF_LOG_WARNING, GF_LOG_RTP, (""[rtp hinter] OD sample too large to be embedded in IOD - ISMA disabled\n""));
is_ok = 0;
}
gf_isom_sample_del(&samp);
}
if (remove_ocr) esd->OCRESID = 0;
else if (esd->OCRESID == esd->ESID) esd->OCRESID = 0;
gf_list_add(iod->ESDescriptors, esd);
}
esd = gf_isom_get_esd(file, sceneT, 1);
if (gf_isom_get_sample_count(file, sceneT)==1) {
samp = gf_isom_get_sample(file, sceneT, 1, &descIndex);
if (gf_hinter_can_embbed_data(samp->data, samp->dataLength, GF_STREAM_SCENE)) {
slc.timeScale = slc.timestampResolution = gf_isom_get_media_timescale(file, sceneT);
slc.OCRResolution = 1000;
slc.startCTS = samp->DTS+samp->CTS_Offset;
slc.startDTS = samp->DTS;
gf_isom_set_extraction_slc(file, sceneT, 1, &slc);
size64 = gf_base64_encode(samp->data, samp->dataLength, buf64, 2000);
buf64[size64] = 0;
sprintf(sdpLine, ""data:application/mpeg4-bifs-au;base64,%s"", buf64);
esd->decoderConfig->avgBitrate = 0;
esd->decoderConfig->bufferSizeDB = samp->dataLength;
esd->decoderConfig->maxBitrate = 0;
esd->URLString = (char*)gf_malloc(sizeof(char) * (strlen(sdpLine)+1));
strcpy(esd->URLString, sdpLine);
} else {
GF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (""[rtp hinter] Scene description sample too large to be embedded in IOD - ISMA disabled\n""));
is_ok = 0;
}
gf_isom_sample_del(&samp);
}
if (remove_ocr) esd->OCRESID = 0;
else if (esd->OCRESID == esd->ESID) esd->OCRESID = 0;
gf_list_add(iod->ESDescriptors, esd);
if (is_ok) {
u32 has_a, has_v, has_i_a, has_i_v;
has_a = has_v = has_i_a = has_i_v = 0;
for (i=0; i<gf_isom_get_track_count(file); i++) {
esd = gf_isom_get_esd(file, i+1, 1);
if (!esd) continue;
if (esd->decoderConfig->streamType==GF_STREAM_VISUAL) {
if (esd->decoderConfig->objectTypeIndication==GF_CODECID_MPEG4_PART2) has_i_v ++;
else has_v++;
} else if (esd->decoderConfig->streamType==GF_STREAM_AUDIO) {
if (esd->decoderConfig->objectTypeIndication==GF_CODECID_AAC_MPEG4) has_i_a ++;
else has_a++;
}
gf_odf_desc_del((GF_Descriptor *)esd);
}
if (!has_v && !has_a && (has_i_v<=1) && (has_i_a<=1)) {
sprintf(sdpLine, ""a=isma-compliance:1,1.0,1"");
gf_isom_sdp_add_line(file, sdpLine);
}
}
}
buffer = NULL;
size = 0;
gf_odf_desc_write((GF_Descriptor *) iod, &buffer, &size);
gf_odf_desc_del((GF_Descriptor *)iod);
size64 = gf_base64_encode(buffer, size, buf64, 2000);
buf64[size64] = 0;
gf_free(buffer);
sprintf(sdpLine, ""a=mpeg4-iod:\""data:application/mpeg4-iod;base64,%s\"""", buf64);
gf_isom_sdp_add_line(file, sdpLine);
return GF_OK;
}",[85],The gf_hinter_finalize function in GPAC 1.0.1 allows attackers to cause a denial of service (NULL pointer dereference) via a crafted file in the MP4Box command.,gpac,CVE-2021-32437,CWE-476
7899,5104,"int af_get_page(AFFILE *af,int64_t pagenum,unsigned char *data,size_t *bytes)
{
uint32_t arg=0;
size_t page_len=0;
if (af_trace){
fprintf(af_trace,""af_get_page(%p,pagenum=%"" I64d "",buf=%p,bytes=%u)\n"",af,pagenum,data,(int)*bytes);
}
int r = af_get_page_raw(af,pagenum,&arg,0,&page_len);
if(r){
if(data && (af->openmode & AF_BADBLOCK_FILL) && errno == ENOENT)
{
for(size_t i = 0;i <= af->image_pagesize - af->image_sectorsize;
i+= af->image_sectorsize){
memcpy(data+i,af->badflag,af->image_sectorsize);
af->bytes_memcpy += af->image_sectorsize;
}
r = 0;
}
return r;
}
uint32_t pageflag = 0;
if((arg & AF_PAGE_COMPRESSED)==0){
if(data==0){
if(bytes) *bytes = page_len;
return 0;
}
int ret = af_get_page_raw(af,pagenum,&pageflag,data,bytes);
if(*bytes > page_len) *bytes = page_len;
if(ret!=0) return ret;
}
else {
unsigned char *compressed_data = (unsigned char *)malloc(page_len);
size_t compressed_data_len = page_len;
if(compressed_data==0){
return -2;
}
if(af_get_page_raw(af,pagenum,&pageflag,compressed_data,&compressed_data_len)){
free(compressed_data);
return -3;
}
int res = -1;
bool free_data = false;
if(data==0){
data = (unsigned char *)malloc(af->image_pagesize);
free_data = true;
*bytes = af->image_pagesize;
}
switch((pageflag & AF_PAGE_COMP_ALG_MASK)){
case AF_PAGE_COMP_ALG_ZERO:
if(compressed_data_len != 4){
(*af->error_reporter)(""ALG_ZERO compressed data is %d bytes, expected 4."",compressed_data_len);
break;
}
memset(data,0,af->image_pagesize);
*bytes = ntohl(*(long *)compressed_data);
res = 0;
break;
case AF_PAGE_COMP_ALG_ZLIB:
res = uncompress(data,(uLongf *)bytes,compressed_data,compressed_data_len);
switch(res){
case Z_OK:
break;
case Z_ERRNO:
(*af->error_reporter)(""Z_ERRNOR decompressing segment %"" I64d,pagenum);
case Z_STREAM_ERROR:
(*af->error_reporter)(""Z_STREAM_ERROR decompressing segment %"" I64d,pagenum);
case Z_DATA_ERROR:
(*af->error_reporter)(""Z_DATA_ERROR decompressing segment %"" I64d,pagenum);
case Z_MEM_ERROR:
(*af->error_reporter)(""Z_MEM_ERROR decompressing segment %"" I64d,pagenum);
case Z_BUF_ERROR:
(*af->error_reporter)(""Z_BUF_ERROR decompressing segment %"" I64d,pagenum);
case Z_VERSION_ERROR:
(*af->error_reporter)(""Z_VERSION_ERROR decompressing segment %"" I64d,pagenum);
default:
(*af->error_reporter)(""uncompress returned an invalid value in get_segment"");
}
break;
#ifdef USE_LZMA
case AF_PAGE_COMP_ALG_LZMA:
res = lzma_uncompress(data,bytes,compressed_data,compressed_data_len);
if (af_trace) fprintf(af_trace,""   LZMA decompressed page %"" I64d "". %d bytes => %u bytes\n"",
pagenum,(int)compressed_data_len,(int)*bytes);
switch(res){
case 0:break;
case 1:(*af->error_reporter)(""LZMA header error decompressing segment %"" I64d ""\n"",pagenum);
break;
case 2:(*af->error_reporter)(""LZMA memory error decompressing segment %"" I64d ""\n"",pagenum);
break;
}
break;
#endif
default:
(*af->error_reporter)(""Unknown compression algorithm 0x%d"",
pageflag & AF_PAGE_COMP_ALG_MASK);
break;
}
if(free_data){
free(data);
data = 0;
}
free(compressed_data);
af->pages_decompressed++;
if(res!=Z_OK) return -1;
}
if(data && (af->image_pagesize > af->image_sectorsize)){
const int SECTOR_SIZE = af->image_sectorsize;
size_t bytes_left_in_sector = (SECTOR_SIZE - (*bytes % SECTOR_SIZE)) % SECTOR_SIZE;
for(size_t i=0;i<bytes_left_in_sector;i++){
data[*bytes + i] = 0;
}
size_t end_of_data = *bytes + bytes_left_in_sector;
for(size_t i = end_of_data; i <= af->image_pagesize-SECTOR_SIZE; i+=SECTOR_SIZE){
memcpy(data+i,af->badflag,SECTOR_SIZE);
af->bytes_memcpy += SECTOR_SIZE;
}
}
return 0;
}",[41],The af_get_page() function in lib/afflib_pages.cpp in AFFLIB (aka AFFLIBv3) through 3.7.16 allows remote attackers to cause a denial of service (segmentation fault) via a corrupt AFF image that triggers an unexpected pagesize value.,AFFLIBv3,CVE-2018-8050,CWE-20
7907,7210,"Error HeifContext::get_id_of_non_virtual_child_image(heif_item_id id, heif_item_id& out) const
{
std::string image_type = m_heif_file->get_item_type(id);
if (image_type==""grid"" ||
image_type==""iden"" ||
image_type==""iovl"") {
auto iref_box = m_heif_file->get_iref_box();
std::vector<heif_item_id> image_references = iref_box->get_references(id, fourcc(""dimg""));
if (image_references.empty()) {
return Error(heif_error_Invalid_input,
heif_suberror_No_item_data,
""Derived image does not reference any other image items"");
}
else {
return get_id_of_non_virtual_child_image(image_references[0], out);
}
}
else {
out = id;
return Error::Ok;
}
}",[8],"An issue was discovered in heif::Box_iref::get_references in libheif 1.4.0, allows attackers to cause a Denial of Service or possibly other unspecified impact due to an invalid memory read.",libheif,CVE-2020-19499,CWE-125
7908,4742,"exif_data_load_data_content (ExifData *data, ExifIfd ifd,
const unsigned char *d,
unsigned int ds, unsigned int offset, unsigned int recursion_depth)
{
ExifLong o, thumbnail_offset = 0, thumbnail_length = 0;
ExifShort n;
ExifEntry *entry;
unsigned int i;
ExifTag tag;
if (!data || !data->priv)
return;
if ((((int)ifd) < 0) || ( ((int)ifd) >= EXIF_IFD_COUNT))
return;
if (recursion_depth > 12) {
exif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA, ""ExifData"",
""Deep recursion detected!"");
return;
}
if ((offset + 2 < offset) || (offset + 2 < 2) || (offset + 2 > ds)) {
exif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA, ""ExifData"",
""Tag data past end of buffer (%u > %u)"", offset+2, ds);
return;
}
n = exif_get_short (d + offset, data->priv->order);
exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, ""ExifData"",
""Loading %hu entries..."", n);
offset += 2;
if (offset + 12 * n > ds) {
n = (ds - offset) / 12;
exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, ""ExifData"",
""Short data; only loading %hu entries..."", n);
}
for (i = 0; i < n; i++) {
tag = exif_get_short (d + offset + 12 * i, data->priv->order);
switch (tag) {
case EXIF_TAG_EXIF_IFD_POINTER:
case EXIF_TAG_GPS_INFO_IFD_POINTER:
case EXIF_TAG_INTEROPERABILITY_IFD_POINTER:
case EXIF_TAG_JPEG_INTERCHANGE_FORMAT_LENGTH:
case EXIF_TAG_JPEG_INTERCHANGE_FORMAT:
o = exif_get_long (d + offset + 12 * i + 8,
data->priv->order);
exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, ""ExifData"",
""Sub-IFD entry 0x%x ('%s') at %u."", tag,
exif_tag_get_name(tag), o);
switch (tag) {
case EXIF_TAG_EXIF_IFD_POINTER:
CHECK_REC (EXIF_IFD_EXIF);
exif_data_load_data_content (data, EXIF_IFD_EXIF, d, ds, o, recursion_depth + 1);
break;
case EXIF_TAG_GPS_INFO_IFD_POINTER:
CHECK_REC (EXIF_IFD_GPS);
exif_data_load_data_content (data, EXIF_IFD_GPS, d, ds, o, recursion_depth + 1);
break;
case EXIF_TAG_INTEROPERABILITY_IFD_POINTER:
CHECK_REC (EXIF_IFD_INTEROPERABILITY);
exif_data_load_data_content (data, EXIF_IFD_INTEROPERABILITY, d, ds, o, recursion_depth + 1);
break;
case EXIF_TAG_JPEG_INTERCHANGE_FORMAT:
thumbnail_offset = o;
if (thumbnail_offset && thumbnail_length)
exif_data_load_data_thumbnail (data, d,
ds, thumbnail_offset,
thumbnail_length);
break;
case EXIF_TAG_JPEG_INTERCHANGE_FORMAT_LENGTH:
thumbnail_length = o;
if (thumbnail_offset && thumbnail_length)
exif_data_load_data_thumbnail (data, d,
ds, thumbnail_offset,
thumbnail_length);
break;
default:
return;
}
break;
default:
if (!exif_tag_get_name_in_ifd (tag, ifd)) {
if (!memcmp (d + offset + 12 * i, ""\0\0\0\0"", 4)) {
exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, ""ExifData"",
""Skipping empty entry at position %u in '%s'."", i,
exif_ifd_get_name (ifd));
break;
}
exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, ""ExifData"",
""Unknown tag 0x%04x (entry %u in '%s'). Please report this tag ""
""to <libexif-devel@lists.sourceforge.net>."", tag, i,
exif_ifd_get_name (ifd));
if (data->priv->options & EXIF_DATA_OPTION_IGNORE_UNKNOWN_TAGS)
break;
}
entry = exif_entry_new_mem (data->priv->mem);
if (!entry) {
exif_log (data->priv->log, EXIF_LOG_CODE_NO_MEMORY, ""ExifData"",
""Could not allocate memory"");
return;
}
if (exif_data_load_data_entry (data, entry, d, ds,
offset + 12 * i))
exif_content_add_entry (data->ifd[ifd], entry);
exif_entry_unref (entry);
break;
}
}
}","[3, 14, 16, 49, 53, 57]",An error when processing the EXIF_IFD_INTEROPERABILITY and EXIF_IFD_EXIF tags within libexif version 0.6.21 can be exploited to exhaust available CPU resources.,libexif,CVE-2018-20030,CWE-400
7919,7550,"static int decode_frame(AVCodecContext *avctx, void *data,
int *got_frame, AVPacket *avpkt)
{
EXRContext *s = avctx->priv_data;
ThreadFrame frame = { .f = data };
AVFrame *picture = data;
uint8_t *ptr;
int i, y, ret, ymax;
int planes;
int out_line_size;
int nb_blocks;
uint64_t start_offset_table;
uint64_t start_next_scanline;
PutByteContext offset_table_writer;
bytestream2_init(&s->gb, avpkt->data, avpkt->size);
if ((ret = decode_header(s, picture)) < 0)
return ret;
switch (s->pixel_type) {
case EXR_FLOAT:
case EXR_HALF:
if (s->channel_offsets[3] >= 0) {
if (!s->is_luma) {
avctx->pix_fmt = AV_PIX_FMT_GBRAPF32;
} else {
avctx->pix_fmt = AV_PIX_FMT_GBRAPF32;
}
} else {
if (!s->is_luma) {
avctx->pix_fmt = AV_PIX_FMT_GBRPF32;
} else {
avctx->pix_fmt = AV_PIX_FMT_GRAYF32;
}
}
break;
case EXR_UINT:
if (s->channel_offsets[3] >= 0) {
if (!s->is_luma) {
avctx->pix_fmt = AV_PIX_FMT_RGBA64;
} else {
avctx->pix_fmt = AV_PIX_FMT_YA16;
}
} else {
if (!s->is_luma) {
avctx->pix_fmt = AV_PIX_FMT_RGB48;
} else {
avctx->pix_fmt = AV_PIX_FMT_GRAY16;
}
}
break;
default:
av_log(avctx, AV_LOG_ERROR, ""Missing channel list.\n"");
return AVERROR_INVALIDDATA;
}
if (s->apply_trc_type != AVCOL_TRC_UNSPECIFIED)
avctx->color_trc = s->apply_trc_type;
switch (s->compression) {
case EXR_RAW:
case EXR_RLE:
case EXR_ZIP1:
s->scan_lines_per_block = 1;
break;
case EXR_PXR24:
case EXR_ZIP16:
s->scan_lines_per_block = 16;
break;
case EXR_PIZ:
case EXR_B44:
case EXR_B44A:
s->scan_lines_per_block = 32;
break;
default:
avpriv_report_missing_feature(avctx, ""Compression %d"", s->compression);
return AVERROR_PATCHWELCOME;
}
if (s->xmin > s->xmax  || s->ymin > s->ymax ||
s->ydelta == 0xFFFFFFFF || s->xdelta == 0xFFFFFFFF) {
av_log(avctx, AV_LOG_ERROR, ""Wrong or missing size information.\n"");
return AVERROR_INVALIDDATA;
}
if ((ret = ff_set_dimensions(avctx, s->w, s->h)) < 0)
return ret;
s->desc          = av_pix_fmt_desc_get(avctx->pix_fmt);
if (!s->desc)
return AVERROR_INVALIDDATA;
if (s->desc->flags & AV_PIX_FMT_FLAG_FLOAT) {
planes           = s->desc->nb_components;
out_line_size    = avctx->width * 4;
} else {
planes           = 1;
out_line_size    = avctx->width * 2 * s->desc->nb_components;
}
if (s->is_tile) {
nb_blocks = ((s->xdelta + s->tile_attr.xSize - 1) / s->tile_attr.xSize) *
((s->ydelta + s->tile_attr.ySize - 1) / s->tile_attr.ySize);
} else {
nb_blocks = (s->ydelta + s->scan_lines_per_block - 1) /
s->scan_lines_per_block;
}
if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0)
return ret;
if (bytestream2_get_bytes_left(&s->gb)/8 < nb_blocks)
return AVERROR_INVALIDDATA;
if (!s->is_tile && bytestream2_peek_le64(&s->gb) == 0) {
av_log(s->avctx, AV_LOG_DEBUG, ""recreating invalid scanline offset table\n"");
start_offset_table = bytestream2_tell(&s->gb);
start_next_scanline = start_offset_table + nb_blocks * 8;
bytestream2_init_writer(&offset_table_writer, &avpkt->data[start_offset_table], nb_blocks * 8);
for (y = 0; y < nb_blocks; y++) {
bytestream2_put_le64(&offset_table_writer, start_next_scanline);
bytestream2_seek(&s->gb, start_next_scanline + 4, SEEK_SET);
start_next_scanline += (bytestream2_get_le32(&s->gb) + 8);
}
bytestream2_seek(&s->gb, start_offset_table, SEEK_SET);
}
s->buf      = avpkt->data;
s->buf_size = avpkt->size;
for (i = 0; i < planes; i++) {
ptr = picture->data[i];
for (y = 0; y < FFMIN(s->ymin, s->h); y++) {
memset(ptr, 0, out_line_size);
ptr += picture->linesize[i];
}
}
s->picture = picture;
avctx->execute2(avctx, decode_block, s->thread_data, NULL, nb_blocks);
ymax = FFMAX(0, s->ymax + 1);
for (i = 0; i < planes; i++) {
ptr = picture->data[i] + (ymax * picture->linesize[i]);
for (y = ymax; y < avctx->height; y++) {
memset(ptr, 0, out_line_size);
ptr += picture->linesize[i];
}
}
picture->pict_type = AV_PICTURE_TYPE_I;
*got_frame = 1;
return avpkt->size;
}","[127, 128, 129, 130, 131]",decode_frame in libavcodec/exr.c in FFmpeg 4.3.1 has an out-of-bounds write because of errors in calculations of when to perform memset zero operations.,FFmpeg,CVE-2020-35965,CWE-787
7923,9771,"return _buffer_reader.read_exactly(_read_buf, length).then([this] (fragmented_temporary_buffer buf) {
auto linearization_buffer = bytes_ostream();
int32_t uncomp_len = request_reader(buf.get_istream(), linearization_buffer).read_int();
if (uncomp_len < 0) {
throw std::runtime_error(""CQL frame uncompressed length is negative: "" + std::to_string(uncomp_len));
}
buf.remove_prefix(4);
auto in = input_buffer.get_linearized_view(fragmented_temporary_buffer::view(buf));
auto uncomp = output_buffer.make_fragmented_temporary_buffer(uncomp_len, fragmented_temporary_buffer::default_fragment_size, [&] (bytes_mutable_view out) {
auto ret = LZ4_decompress_safe(reinterpret_cast<const char*>(in.data()), reinterpret_cast<char*>(out.data()),
in.size(), out.size());
if (ret < 0) {
throw std::runtime_error(""CQL frame LZ4 uncompression failure"");
}
return out.size();
});
on_compression_buffer_use();
return uncomp;
});",[15],"Scylla is a real-time big data database that is API-compatible with Apache Cassandra and Amazon DynamoDB. When decompressing CQL frame received from user, Scylla assumes that user-provided uncompressed length is correct. If user provides fake length, that is greater than the real one, part of decompression buffer won't be overwritten, and will be left uninitialized. This can be exploited in several ways, depending on the privileges of the user. 1. The main exploit is that an attacker with access to CQL port, but no user account, can bypass authentication, but only if there are other legitimate clients making connections to the cluster, and they use LZ4. 2. Attacker that already has a user account on the cluster can read parts of uninitialized memory, which can contain things like passwords of other users or fragments of other queries / results, which leads to authorization bypass and sensitive information disclosure. The bug has been patched in the following versions: Scylla Enterprise: 2020.1.14, 2021.1.12, 2022.1.0. Scylla Open Source: 4.6.7, 5.0.3. Users unable to upgrade should make sure none of their drivers connect to cluster using LZ4 compression, and that Scylla CQL port is behind firewall. Additionally make sure no untrusted client can connect to Scylla, by setting up authentication and applying workarounds from previous point (firewall, no lz4 compression).",scylladb,CVE-2022-29240,CWE-908
7939,9776,"static u8 BS_ReadByte(GF_BitStream *bs)
{
Bool is_eos;
if (bs->bsmode == GF_BITSTREAM_READ) {
u8 res;
if (bs->position >= bs->size) {
if (bs->EndOfStream) bs->EndOfStream(bs->par);
if (!bs->overflow_state) bs->overflow_state = 1;
return 0;
}
res = bs->original[bs->position++];
if (bs->remove_emul_prevention_byte) {
if ((bs->nb_zeros==2) && (res==0x03) && (bs->position<bs->size) && (bs->original[bs->position]<0x04)) {
bs->nb_zeros = 0;
res = bs->original[bs->position++];
}
if (!res) bs->nb_zeros++;
else bs->nb_zeros = 0;
}
return res;
}
if (bs->cache_write)
bs_flush_write_cache(bs);
is_eos = gf_feof(bs->stream);
if (!is_eos || bs->cache_read) {
u8 res;
Bool loc_eos=GF_FALSE;
assert(bs->position<=bs->size);
bs->position++;
res = gf_bs_load_byte(bs, &loc_eos);
if (loc_eos) goto bs_eof;
if (bs->remove_emul_prevention_byte) {
if ((bs->nb_zeros==2) && (res==0x03) && (bs->position<bs->size)) {
u8 next = gf_bs_load_byte(bs, &loc_eos);
if (next < 0x04) {
bs->nb_zeros = 0;
res = next;
bs->position++;
} else {
gf_bs_seek(bs, bs->position);
}
}
if (!res) bs->nb_zeros++;
else bs->nb_zeros = 0;
}
return res;
}
bs_eof:
if (bs->EndOfStream) {
bs->EndOfStream(bs->par);
if (!bs->overflow_state) bs->overflow_state = 1;
} else {
GF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (""[BS] Attempt to overread bitstream\n""));
}
assert(bs->position <= 1+bs->size);
return 0;
}","[25, 53]","In GPAC 2.1-DEV-rev87-g053aae8-master, function BS_ReadByte() in utils/bitstream.c has a failed assertion, which causes a Denial of Service. This vulnerability was fixed in commit 9ea93a2.",gpac,CVE-2022-29339,CWE-617
7944,8006,"GF_RTPHinter *gf_hinter_track_new(GF_ISOFile *file, u32 TrackNum,
u32 Path_MTU, u32 max_ptime, u32 default_rtp_rate, u32 flags, u8 PayloadID,
Bool copy_media, u32 InterleaveGroupID, u8 InterleaveGroupPriority, GF_Err *e)
{
GF_SLConfig my_sl;
u32 descIndex, MinSize, MaxSize, avgTS, streamType, codecid, const_dur, nb_ch, maxDTSDelta;
u8 OfficialPayloadID;
u32 TrackMediaSubType, TrackMediaType, hintType, nbEdts, required_rate, force_dts_delta, avc_nalu_size, PL_ID, bandwidth, IV_length, KI_length;
const char *url, *urn;
char *mpeg4mode;
Bool is_crypted, has_mpeg4_mapping;
GF_RTPHinter *tmp;
GF_ESD *esd;
*e = GF_BAD_PARAM;
if (!file || !TrackNum || !gf_isom_get_track_id(file, TrackNum)) return NULL;
if (!gf_isom_get_sample_count(file, TrackNum)) {
*e = GF_OK;
return NULL;
}
*e = GF_NOT_SUPPORTED;
nbEdts = gf_isom_get_edits_count(file, TrackNum);
if (nbEdts>1) {
u64 et, sd, mt;
GF_ISOEditType em;
gf_isom_get_edit(file, TrackNum, 1, &et, &sd, &mt, &em);
if ((nbEdts>2) || (em!=GF_ISOM_EDIT_EMPTY)) {
GF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (""[rtp hinter] Cannot hint track whith EditList\n""));
return NULL;
}
}
if (nbEdts) gf_isom_remove_edits(file, TrackNum);
if (!gf_isom_is_track_enabled(file, TrackNum)) return NULL;
PL_ID = 0;
OfficialPayloadID = 0;
force_dts_delta = 0;
streamType = 0;
mpeg4mode = NULL;
required_rate = 0;
is_crypted = 0;
IV_length = KI_length = 0;
codecid = 0;
nb_ch = 0;
avc_nalu_size = 0;
has_mpeg4_mapping = 1;
const_dur = 0;
bandwidth=0;
TrackMediaType = gf_isom_get_media_type(file, TrackNum);
if (!default_rtp_rate) default_rtp_rate = 90000;
if ( (TrackMediaType==GF_ISOM_MEDIA_TEXT) || (TrackMediaType==GF_ISOM_MEDIA_SUBT)) {
hintType = GF_RTP_PAYT_3GPP_TEXT;
codecid = GF_CODECID_TEXT_MPEG4;
streamType = GF_STREAM_TEXT;
PL_ID = 0x10;
} else {
if (gf_isom_get_sample_description_count(file, TrackNum) > 1) return NULL;
TrackMediaSubType = gf_isom_get_media_subtype(file, TrackNum, 1);
switch (TrackMediaSubType) {
case GF_ISOM_SUBTYPE_MPEG4_CRYP:
is_crypted = 1;
case GF_ISOM_SUBTYPE_MPEG4:
esd = gf_isom_get_esd(file, TrackNum, 1);
hintType = GF_RTP_PAYT_MPEG4;
if (esd && esd->decoderConfig) {
streamType = esd->decoderConfig->streamType;
codecid = esd->decoderConfig->objectTypeIndication;
if (esd->URLString) hintType = 0;
if ((streamType==GF_STREAM_AUDIO)
&& esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data
&& ((codecid==GF_CODECID_AAC_MPEG4) || (codecid==GF_CODECID_AAC_MPEG2_MP) || (codecid==GF_CODECID_AAC_MPEG2_LCP) || (codecid==GF_CODECID_AAC_MPEG2_SSRP)) ) {
u32 sample_rate;
GF_M4ADecSpecInfo a_cfg;
gf_m4a_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &a_cfg);
nb_ch = a_cfg.nb_chan;
sample_rate = a_cfg.base_sr;
PL_ID = a_cfg.audioPL;
switch (a_cfg.base_object_type) {
case GF_M4A_AAC_MAIN:
case GF_M4A_AAC_LC:
if (flags & GP_RTP_PCK_USE_LATM_AAC) {
hintType = GF_RTP_PAYT_LATM;
break;
}
case GF_M4A_AAC_SBR:
case GF_M4A_AAC_PS:
case GF_M4A_AAC_LTP:
case GF_M4A_AAC_SCALABLE:
case GF_M4A_ER_AAC_LC:
case GF_M4A_ER_AAC_LTP:
case GF_M4A_ER_AAC_SCALABLE:
mpeg4mode = ""AAC"";
break;
case GF_M4A_CELP:
case GF_M4A_ER_CELP:
mpeg4mode = ""CELP"";
break;
}
required_rate = sample_rate;
}
else if ((streamType==GF_STREAM_AUDIO) && ((codecid==GF_CODECID_MPEG2_PART3) || (codecid==GF_CODECID_MPEG_AUDIO))) {
GF_ISOSample *samp = NULL;
if (!is_crypted)
samp = gf_isom_get_sample(file, TrackNum, 1, NULL);
if (samp && (samp->dataLength>3)) {
u32 hdr = GF_4CC((u32)samp->data[0], (u8)samp->data[1], (u8)samp->data[2], (u8)samp->data[3]);
nb_ch = gf_mp3_num_channels(hdr);
hintType = GF_RTP_PAYT_MPEG12_AUDIO;
OfficialPayloadID = 14;
required_rate = 90000;
}
else {
u32 sample_rate;
gf_isom_get_audio_info(file, TrackNum, 1, &sample_rate, &nb_ch, NULL);
required_rate = sample_rate;
}
if (samp)
gf_isom_sample_del(&samp);
}
else if ((streamType==GF_STREAM_AUDIO) && (codecid==GF_CODECID_QCELP)) {
hintType = GF_RTP_PAYT_QCELP;
OfficialPayloadID = 12;
required_rate = 8000;
streamType = GF_STREAM_AUDIO;
nb_ch = 1;
}
else if ((streamType==GF_STREAM_AUDIO) && ((codecid==GF_CODECID_EVRC) || (codecid==GF_CODECID_SMV)) ) {
hintType = GF_RTP_PAYT_EVRC_SMV;
required_rate = 8000;
streamType = GF_STREAM_AUDIO;
nb_ch = 1;
}
else if (streamType==GF_STREAM_VISUAL) {
if ((codecid==GF_CODECID_MPEG4_PART2) && esd->decoderConfig->decoderSpecificInfo) {
GF_M4VDecSpecInfo dsi;
gf_m4v_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &dsi);
PL_ID = dsi.VideoPL;
}
if ( ((codecid>=GF_CODECID_MPEG2_SIMPLE) && (codecid<=GF_CODECID_MPEG2_422)) || (codecid==GF_CODECID_MPEG1)) {
if (!is_crypted) {
hintType = GF_RTP_PAYT_MPEG12_VIDEO;
OfficialPayloadID = 32;
}
}
if (is_crypted) {
if (codecid==GF_CODECID_MPEG4_PART2) force_dts_delta = 22;
else if ((codecid==GF_CODECID_AVC) || (codecid==GF_CODECID_SVC)) {
flags &= ~GP_RTP_PCK_USE_MULTI;
force_dts_delta = 22;
}
flags |= GP_RTP_PCK_SIGNAL_RAP | GP_RTP_PCK_SIGNAL_TS;
}
required_rate = default_rtp_rate;
}
else if (gf_isom_has_sync_shadows(file, TrackNum) || gf_isom_has_sample_dependency(file, TrackNum)) {
flags |= GP_RTP_PCK_SYSTEMS_CAROUSEL;
}
gf_odf_desc_del((GF_Descriptor*)esd);
}
break;
case GF_ISOM_SUBTYPE_3GP_H263:
hintType = GF_RTP_PAYT_H263;
required_rate = 90000;
streamType = GF_STREAM_VISUAL;
OfficialPayloadID = 34;
codecid = GF_CODECID_MPEG4_PART2;
PL_ID = 0x01;
break;
case GF_ISOM_SUBTYPE_3GP_AMR:
required_rate = 8000;
hintType = GF_RTP_PAYT_AMR;
streamType = GF_STREAM_AUDIO;
has_mpeg4_mapping = 0;
nb_ch = 1;
break;
case GF_ISOM_SUBTYPE_3GP_AMR_WB:
required_rate = 16000;
hintType = GF_RTP_PAYT_AMR_WB;
streamType = GF_STREAM_AUDIO;
has_mpeg4_mapping = 0;
nb_ch = 1;
break;
case GF_ISOM_SUBTYPE_AVC_H264:
case GF_ISOM_SUBTYPE_AVC2_H264:
case GF_ISOM_SUBTYPE_AVC3_H264:
case GF_ISOM_SUBTYPE_AVC4_H264:
case GF_ISOM_SUBTYPE_SVC_H264:
case GF_ISOM_SUBTYPE_MVC_H264:
{
GF_AVCConfig *avcc = gf_isom_avc_config_get(file, TrackNum, 1);
GF_AVCConfig *svcc = gf_isom_svc_config_get(file, TrackNum, 1);
GF_AVCConfig *mvcc = gf_isom_mvc_config_get(file, TrackNum, 1);
if (!avcc && !svcc && !mvcc) {
*e = GF_NON_COMPLIANT_BITSTREAM;
return NULL;
}
required_rate = 90000;
hintType = GF_RTP_PAYT_H264_AVC;
if (TrackMediaSubType==GF_ISOM_SUBTYPE_SVC_H264)
hintType = GF_RTP_PAYT_H264_SVC;
else if (TrackMediaSubType==GF_ISOM_SUBTYPE_MVC_H264)
hintType = GF_RTP_PAYT_H264_SVC;
streamType = GF_STREAM_VISUAL;
avc_nalu_size = avcc ? avcc->nal_unit_size : svcc ? svcc->nal_unit_size : mvcc->nal_unit_size;
codecid = GF_CODECID_AVC;
PL_ID = 0x0F;
gf_odf_avc_cfg_del(avcc);
gf_odf_avc_cfg_del(svcc);
}
break;
case GF_ISOM_SUBTYPE_HVC1:
case GF_ISOM_SUBTYPE_HEV1:
case GF_ISOM_SUBTYPE_HVC2:
case GF_ISOM_SUBTYPE_HEV2:
{
GF_HEVCConfig *hevcc = gf_isom_hevc_config_get(file, TrackNum, 1);
if (!hevcc) {
*e = GF_NON_COMPLIANT_BITSTREAM;
return NULL;
}
required_rate = 90000;
hintType = GF_RTP_PAYT_HEVC;
streamType = GF_STREAM_VISUAL;
avc_nalu_size = hevcc->nal_unit_size;
codecid = GF_CODECID_HEVC;
PL_ID = 0x0F;
flags |= GP_RTP_PCK_USE_MULTI;
gf_odf_hevc_cfg_del(hevcc);
break;
}
break;
case GF_ISOM_SUBTYPE_3GP_QCELP:
required_rate = 8000;
hintType = GF_RTP_PAYT_QCELP;
streamType = GF_STREAM_AUDIO;
codecid = GF_CODECID_QCELP;
OfficialPayloadID = 12;
nb_ch = 1;
break;
case GF_ISOM_SUBTYPE_3GP_EVRC:
case GF_ISOM_SUBTYPE_3GP_SMV:
required_rate = 8000;
hintType = GF_RTP_PAYT_EVRC_SMV;
streamType = GF_STREAM_AUDIO;
codecid = (TrackMediaSubType==GF_ISOM_SUBTYPE_3GP_EVRC) ? GF_CODECID_EVRC : GF_CODECID_SMV;
nb_ch = 1;
break;
case GF_ISOM_SUBTYPE_3GP_DIMS:
#if GPAC_ENABLE_3GPP_DIMS_RTP
hintType = GF_RTP_PAYT_3GPP_DIMS;
streamType = GF_STREAM_SCENE;
#else
hintType = 0;
GF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (""[RTP Packetizer] 3GPP DIMS over RTP disabled in build\n"", streamType));
#endif
break;
case GF_ISOM_SUBTYPE_AC3:
hintType = GF_RTP_PAYT_AC3;
streamType = GF_STREAM_AUDIO;
gf_isom_get_audio_info(file, TrackNum, 1, NULL, &nb_ch, NULL);
break;
case GF_ISOM_SUBTYPE_MP3:
{
GF_ISOSample *samp = gf_isom_get_sample(file, TrackNum, 1, NULL);
if (samp && (samp->dataLength>3)) {
u32 hdr = GF_4CC((u32)samp->data[0], (u8)samp->data[1], (u8)samp->data[2], (u8)samp->data[3]);
nb_ch = gf_mp3_num_channels(hdr);
} else {
u32 bps;
gf_isom_get_audio_info(file, TrackNum, 1, &required_rate, &nb_ch, &bps);
}
hintType = GF_RTP_PAYT_MPEG12_AUDIO;
OfficialPayloadID = 14;
required_rate = 90000;
if (samp)
gf_isom_sample_del(&samp);
}
break;
default:
hintType = 0;
break;
}
}
if (!hintType) return NULL;
gf_isom_get_data_reference(file, TrackNum, 1, &url, &urn);
if (url || urn) return NULL;
*e = GF_OUT_OF_MEM;
GF_SAFEALLOC(tmp, GF_RTPHinter);
if (!tmp) return NULL;
if (has_mpeg4_mapping && (flags & GP_RTP_PCK_FORCE_MPEG4)) {
hintType = GF_RTP_PAYT_MPEG4;
avc_nalu_size = 0;
}
else if (OfficialPayloadID && (flags & GP_RTP_PCK_USE_STATIC_ID) ) {
PayloadID = OfficialPayloadID;
}
tmp->file = file;
tmp->TrackNum = TrackNum;
tmp->avc_nalu_size = avc_nalu_size;
tmp->nb_chan = nb_ch;
tmp->has_ctts = gf_isom_has_time_offset(file, TrackNum);
gf_media_get_sample_average_infos(file, TrackNum, &MinSize, &MaxSize, &avgTS, &maxDTSDelta, &const_dur, &bandwidth);
if (flags & GP_RTP_PCK_SYSTEMS_CAROUSEL) {
flags |= GP_RTP_PCK_SIGNAL_RAP;
}
if (flags & GP_RTP_PCK_USE_MULTI) {
if (MinSize != MaxSize) flags |= GP_RTP_PCK_SIGNAL_SIZE;
if (!const_dur) flags |= GP_RTP_PCK_SIGNAL_TS;
}
if (tmp->has_ctts) flags |= GP_RTP_PCK_SIGNAL_TS;
InitSL_RTP(&my_sl);
my_sl.timestampResolution = gf_isom_get_media_timescale(file, TrackNum);
if (required_rate) {
Double sc = required_rate;
sc /= my_sl.timestampResolution;
maxDTSDelta = (u32) (maxDTSDelta*sc);
my_sl.timestampResolution = required_rate;
}
max_ptime = (u32) (max_ptime * my_sl.timestampResolution / 1000);
my_sl.AUSeqNumLength = gf_get_bit_size(gf_isom_get_sample_count(file, TrackNum));
if (my_sl.AUSeqNumLength>16) my_sl.AUSeqNumLength=16;
my_sl.CUDuration = const_dur;
if (gf_isom_has_sync_points(file, TrackNum)) {
my_sl.useRandomAccessPointFlag = 1;
} else {
my_sl.useRandomAccessPointFlag = 0;
my_sl.hasRandomAccessUnitsOnlyFlag = 1;
}
if (is_crypted) {
Bool use_sel_enc;
gf_isom_get_ismacryp_info(file, TrackNum, 1, NULL, NULL, NULL, NULL, NULL, &use_sel_enc, &IV_length, &KI_length);
if (use_sel_enc) flags |= GP_RTP_PCK_SELECTIVE_ENCRYPTION;
}
tmp->OrigTimeScale = gf_isom_get_media_timescale(file, TrackNum);
tmp->rtp_p = gf_rtp_builder_new(hintType, &my_sl, flags, tmp,
MP4T_OnNewPacket, MP4T_OnPacketDone,
copy_media ? NULL : MP4T_OnDataRef,
MP4T_OnData);
gf_rtp_builder_init(tmp->rtp_p, PayloadID, Path_MTU, max_ptime,
streamType, codecid, PL_ID, MinSize, MaxSize, avgTS, maxDTSDelta, IV_length, KI_length, mpeg4mode);
if (force_dts_delta) tmp->rtp_p->slMap.DTSDeltaLength = force_dts_delta;
tmp->TrackID = gf_isom_get_track_id(file, TrackNum);
tmp->HintID = tmp->TrackID + 65535;
while (gf_isom_get_track_by_id(file, tmp->HintID)) tmp->HintID++;
tmp->HintTrack = gf_isom_new_track(file, tmp->HintID, GF_ISOM_MEDIA_HINT, my_sl.timestampResolution);
gf_isom_setup_hint_track(file, tmp->HintTrack, GF_ISOM_HINT_RTP);
gf_isom_new_hint_description(file, tmp->HintTrack, -1, -1, 0, &descIndex);
gf_isom_rtp_set_timescale(file, tmp->HintTrack, descIndex, my_sl.timestampResolution);
if (hintType==GF_RTP_PAYT_MPEG4) {
tmp->rtp_p->slMap.CodecID = codecid;
gf_isom_set_extraction_slc(file, TrackNum, 1, &my_sl);
}
tmp->bandwidth = bandwidth;
gf_isom_set_track_interleaving_group(file, TrackNum, InterleaveGroupID);
if (!copy_media) {
gf_isom_set_track_interleaving_group(file, tmp->HintTrack, InterleaveGroupID);
} else {
gf_isom_set_track_interleaving_group(file, tmp->HintTrack, InterleaveGroupID + OFFSET_HINT_GROUP_ID);
}
InterleaveGroupPriority*=2;
gf_isom_set_track_priority_in_group(file, TrackNum, InterleaveGroupPriority+1);
gf_isom_set_track_priority_in_group(file, tmp->HintTrack, InterleaveGroupPriority);
#if 0
#endif
*e = GF_OK;
return tmp;
}",[349],The gf_isom_set_extraction_slc function in GPAC 1.0.1 allows attackers to cause a denial of service (NULL pointer dereference) via a crafted file in the MP4Box command.,gpac,CVE-2021-31258,CWE-476
7955,8015,"new_fixup(struct archive_write_disk *a, const char *pathname)
{
struct fixup_entry *fe;
fe = (struct fixup_entry *)calloc(1, sizeof(struct fixup_entry));
if (fe == NULL) {
archive_set_error(&a->archive, ENOMEM,
""Can't allocate memory for a fixup"");
return (NULL);
}
fe->next = a->fixup_list;
a->fixup_list = fe;
fe->fixup = 0;
fe->name = strdup(pathname);
return (fe);
}",[13],"An improper link resolution flaw can occur while extracting an archive leading to changing modes, times, access control lists, and flags of a file outside of the archive. An attacker may provide a malicious archive to a victim user, who would trigger this flaw when trying to extract the archive. A local attacker may use this flaw to gain more privileges in a system.",libarchive,CVE-2021-31566,CWE-59
7958,5857,"disable_priv_mode ()
{
int e;
if (setuid (current_user.uid) < 0)
{
e = errno;
sys_error (_(""cannot set uid to %d: effective uid %d""), current_user.uid, current_user.euid);
#if defined (EXIT_ON_SETUID_FAILURE)
if (e == EAGAIN)
exit (e);
#endif
}
if (setgid (current_user.gid) < 0)
sys_error (_(""cannot set gid to %d: effective gid %d""), current_user.gid, current_user.egid);
current_user.euid = current_user.uid;
current_user.egid = current_user.gid;
}","[4, 6, 13, 14]","An issue was discovered in disable_priv_mode in shell.c in GNU Bash through 5.0 patch 11. By default, if Bash is run with its effective UID not equal to its real UID, it will drop privileges by setting its effective UID to its real UID. However, it does so incorrectly. On Linux and other systems that support ""saved UID"" functionality, the saved UID is not dropped. An attacker with command execution in the shell can use ""enable -f"" for runtime loading of a new builtin, which can be a shared object that calls setuid() and therefore regains privileges. However, binaries running with an effective UID of 0 are unaffected.",bash,CVE-2019-18276,CWE-273
7968,9128,"inline void FurnaceGUI::patternRow(int i, bool isPlaying, float lineHeight, int chans, int ord, const DivPattern** patCache) {
static char id[32];
bool selectedRow=(i>=sel1.y && i<=sel2.y);
ImGui::TableNextRow(0,lineHeight);
ImGui::TableNextColumn();
float cursorPosY=ImGui::GetCursorPos().y-ImGui::GetScrollY();
if (cursorPosY<-lineHeight || cursorPosY>ImGui::GetWindowSize().y) {
return;
}
if (ord<0 || ord>=e->song.ordersLen) {
return;
}
if (i<0 || i>=e->song.patLen) {
return;
}
bool isPushing=false;
ImVec4 activeColor=uiColors[GUI_COLOR_PATTERN_ACTIVE];
ImVec4 inactiveColor=uiColors[GUI_COLOR_PATTERN_INACTIVE];
ImVec4 rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX];
if (e->song.hilightB>0 && !(i%e->song.hilightB)) {
activeColor=uiColors[GUI_COLOR_PATTERN_ACTIVE_HI2];
inactiveColor=uiColors[GUI_COLOR_PATTERN_INACTIVE_HI2];
rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX_HI2];
} else if (e->song.hilightA>0 && !(i%e->song.hilightA)) {
activeColor=uiColors[GUI_COLOR_PATTERN_ACTIVE_HI1];
inactiveColor=uiColors[GUI_COLOR_PATTERN_INACTIVE_HI1];
rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX_HI1];
}
if (settings.overflowHighlight) {
if (edit && cursor.y==i) {
ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_EDITING]));
} else if (isPlaying && oldRow==i) {
ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_PLAY_HEAD]));
} else if (e->song.hilightB>0 && !(i%e->song.hilightB)) {
ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_2]));
} else if (e->song.hilightA>0 && !(i%e->song.hilightA)) {
ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_1]));
}
} else {
isPushing=true;
if (edit && cursor.y==i) {
ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_EDITING]));
} else if (isPlaying && oldRow==i) {
ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_PLAY_HEAD]));
} else if (e->song.hilightB>0 && !(i%e->song.hilightB)) {
ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_2]));
} else if (e->song.hilightA>0 && !(i%e->song.hilightA)) {
ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_1]));
} else {
isPushing=false;
}
}
if (settings.patRowsBase==1) {
ImGui::TextColored(rowIndexColor,"" %.2X "",i);
} else {
ImGui::TextColored(rowIndexColor,""%3d "",i);
}
for (int j=0; j<chans; j++) {
if (!e->song.chanShow[j]) {
patChanX[j]=ImGui::GetCursorPosX();
continue;
}
int chanVolMax=e->getMaxVolumeChan(j);
if (chanVolMax<1) chanVolMax=1;
const DivPattern* pat=patCache[j];
ImGui::TableNextColumn();
patChanX[j]=ImGui::GetCursorPosX();
int sel1XSum=sel1.xCoarse*32+sel1.xFine;
int sel2XSum=sel2.xCoarse*32+sel2.xFine;
int j32=j*32;
bool selectedNote=selectedRow && (j32>=sel1XSum && j32<=sel2XSum);
bool selectedIns=selectedRow && (j32+1>=sel1XSum && j32+1<=sel2XSum);
bool selectedVol=selectedRow && (j32+2>=sel1XSum && j32+2<=sel2XSum);
bool cursorNote=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==0);
bool cursorIns=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==1);
bool cursorVol=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==2);
sprintf(id,""%s##PN_%d_%d"",noteName(pat->data[i][0],pat->data[i][1]),i,j);
if (pat->data[i][0]==0 && pat->data[i][1]==0) {
ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);
} else {
ImGui::PushStyleColor(ImGuiCol_Text,activeColor);
}
if (cursorNote) {
ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);
ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);
ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);
ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,threeChars);
demandX=ImGui::GetCursorPosX();
ImGui::PopStyleColor(3);
} else {
if (selectedNote) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);
ImGui::Selectable(id,isPushing || selectedNote,ImGuiSelectableFlags_NoPadWithHalfSpacing,threeChars);
if (selectedNote) ImGui::PopStyleColor();
}
if (ImGui::IsItemClicked()) {
startSelection(j,0,i);
}
if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {
updateSelection(j,0,i);
}
ImGui::PopStyleColor();
if (!e->song.chanCollapse[j]) {
if (pat->data[i][2]==-1) {
ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);
sprintf(id,""..##PI_%d_%d"",i,j);
} else {
if (pat->data[i][2]<0 || pat->data[i][2]>=e->song.insLen) {
ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_INS_ERROR]);
} else {
DivInstrumentType t=e->song.ins[pat->data[i][2]]->type;
if (t!=DIV_INS_AMIGA && t!=e->getPreferInsType(j)) {
ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_INS_WARN]);
} else {
ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_INS]);
}
}
sprintf(id,""%.2X##PI_%d_%d"",pat->data[i][2],i,j);
}
ImGui::SameLine(0.0f,0.0f);
if (cursorIns) {
ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);
ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);
ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);
ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);
demandX=ImGui::GetCursorPosX();
ImGui::PopStyleColor(3);
} else {
if (selectedIns) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);
ImGui::Selectable(id,isPushing || selectedIns,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);
if (selectedIns) ImGui::PopStyleColor();
}
if (ImGui::IsItemClicked()) {
startSelection(j,1,i);
}
if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {
updateSelection(j,1,i);
}
ImGui::PopStyleColor();
if (pat->data[i][3]==-1) {
sprintf(id,""..##PV_%d_%d"",i,j);
ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);
} else {
int volColor=(pat->data[i][3]*127)/chanVolMax;
if (volColor>127) volColor=127;
if (volColor<0) volColor=0;
sprintf(id,""%.2X##PV_%d_%d"",pat->data[i][3],i,j);
ImGui::PushStyleColor(ImGuiCol_Text,volColors[volColor]);
}
ImGui::SameLine(0.0f,0.0f);
if (cursorVol) {
ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);
ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);
ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);
ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);
demandX=ImGui::GetCursorPosX();
ImGui::PopStyleColor(3);
} else {
if (selectedVol) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);
ImGui::Selectable(id,isPushing || selectedVol,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);
if (selectedVol) ImGui::PopStyleColor();
}
if (ImGui::IsItemClicked()) {
startSelection(j,2,i);
}
if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {
updateSelection(j,2,i);
}
ImGui::PopStyleColor();
for (int k=0; k<e->song.pat[j].effectRows; k++) {
int index=4+(k<<1);
bool selectedEffect=selectedRow && (j32+index-1>=sel1XSum && j32+index-1<=sel2XSum);
bool selectedEffectVal=selectedRow && (j32+index>=sel1XSum && j32+index<=sel2XSum);
bool cursorEffect=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==index-1);
bool cursorEffectVal=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==index);
if (pat->data[i][index]==-1) {
sprintf(id,""..##PE%d_%d_%d"",k,i,j);
ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);
} else {
sprintf(id,""%.2X##PE%d_%d_%d"",pat->data[i][index],k,i,j);
if (pat->data[i][index]<0x10) {
ImGui::PushStyleColor(ImGuiCol_Text,uiColors[fxColors[pat->data[i][index]]]);
} else if (pat->data[i][index]<0x20) {
ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);
} else if (pat->data[i][index]<0x30) {
ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_SECONDARY]);
} else if (pat->data[i][index]<0x48) {
ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);
} else if (pat->data[i][index]<0x90) {
ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);
} else if (pat->data[i][index]<0xa0) {
ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_MISC]);
} else if (pat->data[i][index]<0xc0) {
ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);
} else if (pat->data[i][index]<0xd0) {
ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SPEED]);
} else if (pat->data[i][index]<0xe0) {
ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);
} else {
ImGui::PushStyleColor(ImGuiCol_Text,uiColors[extFxColors[pat->data[i][index]-0xe0]]);
}
}
ImGui::SameLine(0.0f,0.0f);
if (cursorEffect) {
ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);
ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);
ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);
ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);
demandX=ImGui::GetCursorPosX();
ImGui::PopStyleColor(3);
} else {
if (selectedEffect) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);
ImGui::Selectable(id,isPushing || selectedEffect,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);
if (selectedEffect) ImGui::PopStyleColor();
}
if (ImGui::IsItemClicked()) {
startSelection(j,index-1,i);
}
if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {
updateSelection(j,index-1,i);
}
if (pat->data[i][index+1]==-1) {
sprintf(id,""..##PF%d_%d_%d"",k,i,j);
} else {
sprintf(id,""%.2X##PF%d_%d_%d"",pat->data[i][index+1],k,i,j);
}
ImGui::SameLine(0.0f,0.0f);
if (cursorEffectVal) {
ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);
ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);
ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);
ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);
demandX=ImGui::GetCursorPosX();
ImGui::PopStyleColor(3);
} else {
if (selectedEffectVal) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);
ImGui::Selectable(id,isPushing || selectedEffectVal,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);
if (selectedEffectVal) ImGui::PopStyleColor();
}
if (ImGui::IsItemClicked()) {
startSelection(j,index,i);
}
if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {
updateSelection(j,index,i);
}
ImGui::PopStyleColor();
}
}
}
if (isPushing) {
ImGui::PopStyleColor();
}
ImGui::TableNextColumn();
patChanX[chans]=ImGui::GetCursorPosX();
}","[179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 199]",A denial of service vulnerability was found in tildearrow Furnace. It has been classified as problematic. This is due to an incomplete fix of CVE-2022-1211. It is possible to initiate the attack remotely but it requires user interaction. The issue got fixed with the patch 0eb02422d5161767e9983bdaa5c429762d3477ce.,furnace,CVE-2022-1289,NVD-CWE-noinfo
7970,5991,"int sqlite3Select(
Parse *pParse,
Select *p,
SelectDest *pDest
){
int i, j;
WhereInfo *pWInfo;
Vdbe *v;
int isAgg;
ExprList *pEList = 0;
SrcList *pTabList;
Expr *pWhere;
ExprList *pGroupBy;
Expr *pHaving;
int rc = 1;
DistinctCtx sDistinct;
SortCtx sSort;
AggInfo sAggInfo;
int iEnd;
sqlite3 *db;
ExprList *pMinMaxOrderBy = 0;
u8 minMaxFlag;
db = pParse->db;
v = sqlite3GetVdbe(pParse);
if( p==0 || db->mallocFailed || pParse->nErr ){
return 1;
}
if( sqlite3AuthCheck(pParse, SQLITE_SELECT, 0, 0, 0) ) return 1;
memset(&sAggInfo, 0, sizeof(sAggInfo));
#if SELECTTRACE_ENABLED
SELECTTRACE(1,pParse,p, (""begin processing:\n"", pParse->addrExplain));
if( sqlite3SelectTrace & 0x100 ){
sqlite3TreeViewSelect(0, p, 0);
}
#endif
assert( p->pOrderBy==0 || pDest->eDest!=SRT_DistFifo );
assert( p->pOrderBy==0 || pDest->eDest!=SRT_Fifo );
assert( p->pOrderBy==0 || pDest->eDest!=SRT_DistQueue );
assert( p->pOrderBy==0 || pDest->eDest!=SRT_Queue );
if( IgnorableOrderby(pDest) ){
assert(pDest->eDest==SRT_Exists || pDest->eDest==SRT_Union ||
pDest->eDest==SRT_Except || pDest->eDest==SRT_Discard ||
pDest->eDest==SRT_Queue  || pDest->eDest==SRT_DistFifo ||
pDest->eDest==SRT_DistQueue || pDest->eDest==SRT_Fifo);
sqlite3ExprListDelete(db, p->pOrderBy);
p->pOrderBy = 0;
p->selFlags &= ~SF_Distinct;
}
sqlite3SelectPrep(pParse, p, 0);
if( pParse->nErr || db->mallocFailed ){
goto select_end;
}
assert( p->pEList!=0 );
#if SELECTTRACE_ENABLED
if( sqlite3SelectTrace & 0x104 ){
SELECTTRACE(0x104,pParse,p, (""after name resolution:\n""));
sqlite3TreeViewSelect(0, p, 0);
}
#endif
if( pDest->eDest==SRT_Output ){
generateColumnNames(pParse, p);
}
#ifndef SQLITE_OMIT_WINDOWFUNC
if( sqlite3WindowRewrite(pParse, p) ){
goto select_end;
}
#if SELECTTRACE_ENABLED
if( p->pWin && (sqlite3SelectTrace & 0x108)!=0 ){
SELECTTRACE(0x104,pParse,p, (""after window rewrite:\n""));
sqlite3TreeViewSelect(0, p, 0);
}
#endif
#endif /* SQLITE_OMIT_WINDOWFUNC */
pTabList = p->pSrc;
isAgg = (p->selFlags & SF_Aggregate)!=0;
memset(&sSort, 0, sizeof(sSort));
sSort.pOrderBy = p->pOrderBy;
#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)
for(i=0; !p->pPrior && i<pTabList->nSrc; i++){
struct SrcList_item *pItem = &pTabList->a[i];
Select *pSub = pItem->pSelect;
Table *pTab = pItem->pTab;
if( (pItem->fg.jointype & JT_LEFT)!=0
&& sqlite3ExprImpliesNonNullRow(p->pWhere, pItem->iCursor)
&& OptimizationEnabled(db, SQLITE_SimplifyJoin)
){
SELECTTRACE(0x100,pParse,p,
(""LEFT-JOIN simplifies to JOIN on term %d\n"",i));
pItem->fg.jointype &= ~(JT_LEFT|JT_OUTER);
unsetJoinExpr(p->pWhere, pItem->iCursor);
}
if( pSub==0 ) continue;
if( pTab->nCol!=pSub->pEList->nExpr ){
sqlite3ErrorMsg(pParse, ""expected %d columns for '%s' but got %d"",
pTab->nCol, pTab->zName, pSub->pEList->nExpr);
goto select_end;
}
if( (pSub->selFlags & SF_Aggregate)!=0 ) continue;
assert( pSub->pGroupBy==0 );
if( pSub->pOrderBy!=0
&& i==0
&& (p->selFlags & SF_ComplexResult)!=0
&& (pTabList->nSrc==1
|| (pTabList->a[1].fg.jointype&(JT_LEFT|JT_CROSS))!=0)
){
continue;
}
if( flattenSubquery(pParse, p, i, isAgg) ){
if( pParse->nErr ) goto select_end;
i = -1;
}
pTabList = p->pSrc;
if( db->mallocFailed ) goto select_end;
if( !IgnorableOrderby(pDest) ){
sSort.pOrderBy = p->pOrderBy;
}
}
#endif
#ifndef SQLITE_OMIT_COMPOUND_SELECT
if( p->pPrior ){
rc = multiSelect(pParse, p, pDest);
#if SELECTTRACE_ENABLED
SELECTTRACE(0x1,pParse,p,(""end compound-select processing\n""));
if( (sqlite3SelectTrace & 0x2000)!=0 && ExplainQueryPlanParent(pParse)==0 ){
sqlite3TreeViewSelect(0, p, 0);
}
#endif
if( p->pNext==0 ) ExplainQueryPlanPop(pParse);
return rc;
}
#endif
if( pTabList->nSrc>1
&& OptimizationEnabled(db, SQLITE_PropagateConst)
&& propagateConstants(pParse, p)
){
#if SELECTTRACE_ENABLED
if( sqlite3SelectTrace & 0x100 ){
SELECTTRACE(0x100,pParse,p,(""After constant propagation:\n""));
sqlite3TreeViewSelect(0, p, 0);
}
#endif
}else{
SELECTTRACE(0x100,pParse,p,(""Constant propagation not helpful\n""));
}
#ifdef SQLITE_COUNTOFVIEW_OPTIMIZATION
if( OptimizationEnabled(db, SQLITE_QueryFlattener|SQLITE_CountOfView)
&& countOfViewOptimization(pParse, p)
){
if( db->mallocFailed ) goto select_end;
pEList = p->pEList;
pTabList = p->pSrc;
}
#endif
for(i=0; i<pTabList->nSrc; i++){
struct SrcList_item *pItem = &pTabList->a[i];
SelectDest dest;
Select *pSub;
#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)
const char *zSavedAuthContext;
#endif
if( pItem->colUsed==0 && pItem->zName!=0 ){
sqlite3AuthCheck(pParse, SQLITE_READ, pItem->zName, """", pItem->zDatabase);
}
#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)
pSub = pItem->pSelect;
if( pSub==0 ) continue;
testcase( pItem->addrFillSub!=0 );
pParse->nHeight += sqlite3SelectExprHeight(p);
if( OptimizationEnabled(db, SQLITE_PushDown)
&& pushDownWhereTerms(pParse, pSub, p->pWhere, pItem->iCursor,
(pItem->fg.jointype & JT_OUTER)!=0)
){
#if SELECTTRACE_ENABLED
if( sqlite3SelectTrace & 0x100 ){
SELECTTRACE(0x100,pParse,p,
(""After WHERE-clause push-down into subquery %d:\n"", pSub->selId));
sqlite3TreeViewSelect(0, p, 0);
}
#endif
}else{
SELECTTRACE(0x100,pParse,p,(""Push-down not possible\n""));
}
zSavedAuthContext = pParse->zAuthContext;
pParse->zAuthContext = pItem->zName;
if( i==0
&& (pTabList->nSrc==1
|| (pTabList->a[1].fg.jointype&(JT_LEFT|JT_CROSS))!=0)
){
int addrTop = sqlite3VdbeCurrentAddr(v)+1;
pItem->regReturn = ++pParse->nMem;
sqlite3VdbeAddOp3(v, OP_InitCoroutine, pItem->regReturn, 0, addrTop);
VdbeComment((v, ""%s"", pItem->pTab->zName));
pItem->addrFillSub = addrTop;
sqlite3SelectDestInit(&dest, SRT_Coroutine, pItem->regReturn);
ExplainQueryPlan((pParse, 1, ""CO-ROUTINE %u"", pSub->selId));
sqlite3Select(pParse, pSub, &dest);
pItem->pTab->nRowLogEst = pSub->nSelectRow;
pItem->fg.viaCoroutine = 1;
pItem->regResult = dest.iSdst;
sqlite3VdbeEndCoroutine(v, pItem->regReturn);
sqlite3VdbeJumpHere(v, addrTop-1);
sqlite3ClearTempRegCache(pParse);
}else{
int topAddr;
int onceAddr = 0;
int retAddr;
struct SrcList_item *pPrior;
testcase( pItem->addrFillSub==0 );
pItem->regReturn = ++pParse->nMem;
topAddr = sqlite3VdbeAddOp2(v, OP_Integer, 0, pItem->regReturn);
pItem->addrFillSub = topAddr+1;
if( pItem->fg.isCorrelated==0 ){
onceAddr = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);
VdbeComment((v, ""materialize \""%s\"""", pItem->pTab->zName));
}else{
VdbeNoopComment((v, ""materialize \""%s\"""", pItem->pTab->zName));
}
pPrior = isSelfJoinView(pTabList, pItem);
if( pPrior ){
sqlite3VdbeAddOp2(v, OP_OpenDup, pItem->iCursor, pPrior->iCursor);
assert( pPrior->pSelect!=0 );
pSub->nSelectRow = pPrior->pSelect->nSelectRow;
}else{
sqlite3SelectDestInit(&dest, SRT_EphemTab, pItem->iCursor);
ExplainQueryPlan((pParse, 1, ""MATERIALIZE %u"", pSub->selId));
sqlite3Select(pParse, pSub, &dest);
}
pItem->pTab->nRowLogEst = pSub->nSelectRow;
if( onceAddr ) sqlite3VdbeJumpHere(v, onceAddr);
retAddr = sqlite3VdbeAddOp1(v, OP_Return, pItem->regReturn);
VdbeComment((v, ""end %s"", pItem->pTab->zName));
sqlite3VdbeChangeP1(v, topAddr, retAddr);
sqlite3ClearTempRegCache(pParse);
}
if( db->mallocFailed ) goto select_end;
pParse->nHeight -= sqlite3SelectExprHeight(p);
pParse->zAuthContext = zSavedAuthContext;
#endif
}
pEList = p->pEList;
pWhere = p->pWhere;
pGroupBy = p->pGroupBy;
pHaving = p->pHaving;
sDistinct.isTnct = (p->selFlags & SF_Distinct)!=0;
#if SELECTTRACE_ENABLED
if( sqlite3SelectTrace & 0x400 ){
SELECTTRACE(0x400,pParse,p,(""After all FROM-clause analysis:\n""));
sqlite3TreeViewSelect(0, p, 0);
}
#endif
if( (p->selFlags & (SF_Distinct|SF_Aggregate))==SF_Distinct
&& sqlite3ExprListCompare(sSort.pOrderBy, pEList, -1)==0
){
p->selFlags &= ~SF_Distinct;
pGroupBy = p->pGroupBy = sqlite3ExprListDup(db, pEList, 0);
assert( sDistinct.isTnct );
#if SELECTTRACE_ENABLED
if( sqlite3SelectTrace & 0x400 ){
SELECTTRACE(0x400,pParse,p,(""Transform DISTINCT into GROUP BY:\n""));
sqlite3TreeViewSelect(0, p, 0);
}
#endif
}
if( sSort.pOrderBy ){
KeyInfo *pKeyInfo;
pKeyInfo = sqlite3KeyInfoFromExprList(
pParse, sSort.pOrderBy, 0, pEList->nExpr);
sSort.iECursor = pParse->nTab++;
sSort.addrSortIndex =
sqlite3VdbeAddOp4(v, OP_OpenEphemeral,
sSort.iECursor, sSort.pOrderBy->nExpr+1+pEList->nExpr, 0,
(char*)pKeyInfo, P4_KEYINFO
);
}else{
sSort.addrSortIndex = -1;
}
if( pDest->eDest==SRT_EphemTab ){
sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pDest->iSDParm, pEList->nExpr);
}
iEnd = sqlite3VdbeMakeLabel(pParse);
if( (p->selFlags & SF_FixedLimit)==0 ){
p->nSelectRow = 320;
}
computeLimitRegisters(pParse, p, iEnd);
if( p->iLimit==0 && sSort.addrSortIndex>=0 ){
sqlite3VdbeChangeOpcode(v, sSort.addrSortIndex, OP_SorterOpen);
sSort.sortFlags |= SORTFLAG_UseSorter;
}
if( p->selFlags & SF_Distinct ){
sDistinct.tabTnct = pParse->nTab++;
sDistinct.addrTnct = sqlite3VdbeAddOp4(v, OP_OpenEphemeral,
sDistinct.tabTnct, 0, 0,
(char*)sqlite3KeyInfoFromExprList(pParse, p->pEList,0,0),
P4_KEYINFO);
sqlite3VdbeChangeP5(v, BTREE_UNORDERED);
sDistinct.eTnctType = WHERE_DISTINCT_UNORDERED;
}else{
sDistinct.eTnctType = WHERE_DISTINCT_NOOP;
}
if( !isAgg && pGroupBy==0 ){
u16 wctrlFlags = (sDistinct.isTnct ? WHERE_WANT_DISTINCT : 0)
| (p->selFlags & SF_FixedLimit);
#ifndef SQLITE_OMIT_WINDOWFUNC
Window *pWin = p->pWin;
if( pWin ){
sqlite3WindowCodeInit(pParse, pWin);
}
#endif
assert( WHERE_USE_LIMIT==SF_FixedLimit );
SELECTTRACE(1,pParse,p,(""WhereBegin\n""));
pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, sSort.pOrderBy,
p->pEList, wctrlFlags, p->nSelectRow);
if( pWInfo==0 ) goto select_end;
if( sqlite3WhereOutputRowCount(pWInfo) < p->nSelectRow ){
p->nSelectRow = sqlite3WhereOutputRowCount(pWInfo);
}
if( sDistinct.isTnct && sqlite3WhereIsDistinct(pWInfo) ){
sDistinct.eTnctType = sqlite3WhereIsDistinct(pWInfo);
}
if( sSort.pOrderBy ){
sSort.nOBSat = sqlite3WhereIsOrdered(pWInfo);
sSort.labelOBLopt = sqlite3WhereOrderByLimitOptLabel(pWInfo);
if( sSort.nOBSat==sSort.pOrderBy->nExpr ){
sSort.pOrderBy = 0;
}
}
if( sSort.addrSortIndex>=0 && sSort.pOrderBy==0 ){
sqlite3VdbeChangeToNoop(v, sSort.addrSortIndex);
}
assert( p->pEList==pEList );
#ifndef SQLITE_OMIT_WINDOWFUNC
if( pWin ){
int addrGosub = sqlite3VdbeMakeLabel(pParse);
int iCont = sqlite3VdbeMakeLabel(pParse);
int iBreak = sqlite3VdbeMakeLabel(pParse);
int regGosub = ++pParse->nMem;
sqlite3WindowCodeStep(pParse, p, pWInfo, regGosub, addrGosub);
sqlite3VdbeAddOp2(v, OP_Goto, 0, iBreak);
sqlite3VdbeResolveLabel(v, addrGosub);
VdbeNoopComment((v, ""inner-loop subroutine""));
sSort.labelOBLopt = 0;
selectInnerLoop(pParse, p, -1, &sSort, &sDistinct, pDest, iCont, iBreak);
sqlite3VdbeResolveLabel(v, iCont);
sqlite3VdbeAddOp1(v, OP_Return, regGosub);
VdbeComment((v, ""end inner-loop subroutine""));
sqlite3VdbeResolveLabel(v, iBreak);
}else
#endif /* SQLITE_OMIT_WINDOWFUNC */
{
selectInnerLoop(pParse, p, -1, &sSort, &sDistinct, pDest,
sqlite3WhereContinueLabel(pWInfo),
sqlite3WhereBreakLabel(pWInfo));
sqlite3WhereEnd(pWInfo);
}
}else{
NameContext sNC;
int iAMem;
int iBMem;
int iUseFlag;
int iAbortFlag;
int groupBySort;
int addrEnd;
int sortPTab = 0;
int sortOut = 0;
int orderByGrp = 0;
if( pGroupBy ){
int k;
struct ExprList_item *pItem;
for(k=p->pEList->nExpr, pItem=p->pEList->a; k>0; k--, pItem++){
pItem->u.x.iAlias = 0;
}
for(k=pGroupBy->nExpr, pItem=pGroupBy->a; k>0; k--, pItem++){
pItem->u.x.iAlias = 0;
}
assert( 66==sqlite3LogEst(100) );
if( p->nSelectRow>66 ) p->nSelectRow = 66;
if( sSort.pOrderBy && pGroupBy->nExpr==sSort.pOrderBy->nExpr ){
int ii;
for(ii=0; ii<pGroupBy->nExpr; ii++){
u8 sortFlags = sSort.pOrderBy->a[ii].sortFlags & KEYINFO_ORDER_DESC;
pGroupBy->a[ii].sortFlags = sortFlags;
}
if( sqlite3ExprListCompare(pGroupBy, sSort.pOrderBy, -1)==0 ){
orderByGrp = 1;
}
}
}else{
assert( 0==sqlite3LogEst(1) );
p->nSelectRow = 0;
}
addrEnd = sqlite3VdbeMakeLabel(pParse);
memset(&sNC, 0, sizeof(sNC));
sNC.pParse = pParse;
sNC.pSrcList = pTabList;
sNC.uNC.pAggInfo = &sAggInfo;
VVA_ONLY( sNC.ncFlags = NC_UAggInfo; )
sAggInfo.mnReg = pParse->nMem+1;
sAggInfo.nSortingColumn = pGroupBy ? pGroupBy->nExpr : 0;
sAggInfo.pGroupBy = pGroupBy;
sqlite3ExprAnalyzeAggList(&sNC, pEList);
sqlite3ExprAnalyzeAggList(&sNC, sSort.pOrderBy);
if( pHaving ){
if( pGroupBy ){
assert( pWhere==p->pWhere );
assert( pHaving==p->pHaving );
assert( pGroupBy==p->pGroupBy );
havingToWhere(pParse, p);
pWhere = p->pWhere;
}
sqlite3ExprAnalyzeAggregates(&sNC, pHaving);
}
sAggInfo.nAccumulator = sAggInfo.nColumn;
if( p->pGroupBy==0 && p->pHaving==0 && sAggInfo.nFunc==1 ){
minMaxFlag = minMaxQuery(db, sAggInfo.aFunc[0].pExpr, &pMinMaxOrderBy);
}else{
minMaxFlag = WHERE_ORDERBY_NORMAL;
}
for(i=0; i<sAggInfo.nFunc; i++){
Expr *pExpr = sAggInfo.aFunc[i].pExpr;
assert( !ExprHasProperty(pExpr, EP_xIsSelect) );
sNC.ncFlags |= NC_InAggFunc;
sqlite3ExprAnalyzeAggList(&sNC, pExpr->x.pList);
#ifndef SQLITE_OMIT_WINDOWFUNC
assert( !IsWindowFunc(pExpr) );
if( ExprHasProperty(pExpr, EP_WinFunc) ){
sqlite3ExprAnalyzeAggregates(&sNC, pExpr->y.pWin->pFilter);
}
#endif
sNC.ncFlags &= ~NC_InAggFunc;
}
sAggInfo.mxReg = pParse->nMem;
if( db->mallocFailed ) goto select_end;
#if SELECTTRACE_ENABLED
if( sqlite3SelectTrace & 0x400 ){
int ii;
SELECTTRACE(0x400,pParse,p,(""After aggregate analysis:\n""));
sqlite3TreeViewSelect(0, p, 0);
for(ii=0; ii<sAggInfo.nColumn; ii++){
sqlite3DebugPrintf(""agg-column[%d] iMem=%d\n"",
ii, sAggInfo.aCol[ii].iMem);
sqlite3TreeViewExpr(0, sAggInfo.aCol[ii].pExpr, 0);
}
for(ii=0; ii<sAggInfo.nFunc; ii++){
sqlite3DebugPrintf(""agg-func[%d]: iMem=%d\n"",
ii, sAggInfo.aFunc[ii].iMem);
sqlite3TreeViewExpr(0, sAggInfo.aFunc[ii].pExpr, 0);
}
}
#endif
if( pGroupBy ){
KeyInfo *pKeyInfo;
int addr1;
int addrOutputRow;
int regOutputRow;
int addrSetAbort;
int addrTopOfLoop;
int addrSortingIdx;
int addrReset;
int regReset;
sAggInfo.sortingIdx = pParse->nTab++;
pKeyInfo = sqlite3KeyInfoFromExprList(pParse,pGroupBy,0,sAggInfo.nColumn);
addrSortingIdx = sqlite3VdbeAddOp4(v, OP_SorterOpen,
sAggInfo.sortingIdx, sAggInfo.nSortingColumn,
0, (char*)pKeyInfo, P4_KEYINFO);
iUseFlag = ++pParse->nMem;
iAbortFlag = ++pParse->nMem;
regOutputRow = ++pParse->nMem;
addrOutputRow = sqlite3VdbeMakeLabel(pParse);
regReset = ++pParse->nMem;
addrReset = sqlite3VdbeMakeLabel(pParse);
iAMem = pParse->nMem + 1;
pParse->nMem += pGroupBy->nExpr;
iBMem = pParse->nMem + 1;
pParse->nMem += pGroupBy->nExpr;
sqlite3VdbeAddOp2(v, OP_Integer, 0, iAbortFlag);
VdbeComment((v, ""clear abort flag""));
sqlite3VdbeAddOp3(v, OP_Null, 0, iAMem, iAMem+pGroupBy->nExpr-1);
sqlite3VdbeAddOp2(v, OP_Gosub, regReset, addrReset);
SELECTTRACE(1,pParse,p,(""WhereBegin\n""));
pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pGroupBy, 0,
WHERE_GROUPBY | (orderByGrp ? WHERE_SORTBYGROUP : 0), 0
);
if( pWInfo==0 ) goto select_end;
if( sqlite3WhereIsOrdered(pWInfo)==pGroupBy->nExpr ){
groupBySort = 0;
}else{
int regBase;
int regRecord;
int nCol;
int nGroupBy;
explainTempTable(pParse,
(sDistinct.isTnct && (p->selFlags&SF_Distinct)==0) ?
""DISTINCT"" : ""GROUP BY"");
groupBySort = 1;
nGroupBy = pGroupBy->nExpr;
nCol = nGroupBy;
j = nGroupBy;
for(i=0; i<sAggInfo.nColumn; i++){
if( sAggInfo.aCol[i].iSorterColumn>=j ){
nCol++;
j++;
}
}
regBase = sqlite3GetTempRange(pParse, nCol);
sqlite3ExprCodeExprList(pParse, pGroupBy, regBase, 0, 0);
j = nGroupBy;
for(i=0; i<sAggInfo.nColumn; i++){
struct AggInfo_col *pCol = &sAggInfo.aCol[i];
if( pCol->iSorterColumn>=j ){
int r1 = j + regBase;
sqlite3ExprCodeGetColumnOfTable(v,
pCol->pTab, pCol->iTable, pCol->iColumn, r1);
j++;
}
}
regRecord = sqlite3GetTempReg(pParse);
sqlite3VdbeAddOp3(v, OP_MakeRecord, regBase, nCol, regRecord);
sqlite3VdbeAddOp2(v, OP_SorterInsert, sAggInfo.sortingIdx, regRecord);
sqlite3ReleaseTempReg(pParse, regRecord);
sqlite3ReleaseTempRange(pParse, regBase, nCol);
sqlite3WhereEnd(pWInfo);
sAggInfo.sortingIdxPTab = sortPTab = pParse->nTab++;
sortOut = sqlite3GetTempReg(pParse);
sqlite3VdbeAddOp3(v, OP_OpenPseudo, sortPTab, sortOut, nCol);
sqlite3VdbeAddOp2(v, OP_SorterSort, sAggInfo.sortingIdx, addrEnd);
VdbeComment((v, ""GROUP BY sort"")); VdbeCoverage(v);
sAggInfo.useSortingIdx = 1;
}
if( orderByGrp && OptimizationEnabled(db, SQLITE_GroupByOrder)
&& (groupBySort || sqlite3WhereIsSorted(pWInfo))
){
sSort.pOrderBy = 0;
sqlite3VdbeChangeToNoop(v, sSort.addrSortIndex);
}
addrTopOfLoop = sqlite3VdbeCurrentAddr(v);
if( groupBySort ){
sqlite3VdbeAddOp3(v, OP_SorterData, sAggInfo.sortingIdx,
sortOut, sortPTab);
}
for(j=0; j<pGroupBy->nExpr; j++){
if( groupBySort ){
sqlite3VdbeAddOp3(v, OP_Column, sortPTab, j, iBMem+j);
}else{
sAggInfo.directMode = 1;
sqlite3ExprCode(pParse, pGroupBy->a[j].pExpr, iBMem+j);
}
}
sqlite3VdbeAddOp4(v, OP_Compare, iAMem, iBMem, pGroupBy->nExpr,
(char*)sqlite3KeyInfoRef(pKeyInfo), P4_KEYINFO);
addr1 = sqlite3VdbeCurrentAddr(v);
sqlite3VdbeAddOp3(v, OP_Jump, addr1+1, 0, addr1+1); VdbeCoverage(v);
sqlite3ExprCodeMove(pParse, iBMem, iAMem, pGroupBy->nExpr);
sqlite3VdbeAddOp2(v, OP_Gosub, regOutputRow, addrOutputRow);
VdbeComment((v, ""output one row""));
sqlite3VdbeAddOp2(v, OP_IfPos, iAbortFlag, addrEnd); VdbeCoverage(v);
VdbeComment((v, ""check abort flag""));
sqlite3VdbeAddOp2(v, OP_Gosub, regReset, addrReset);
VdbeComment((v, ""reset accumulator""));
sqlite3VdbeJumpHere(v, addr1);
updateAccumulator(pParse, iUseFlag, &sAggInfo);
sqlite3VdbeAddOp2(v, OP_Integer, 1, iUseFlag);
VdbeComment((v, ""indicate data in accumulator""));
if( groupBySort ){
sqlite3VdbeAddOp2(v, OP_SorterNext, sAggInfo.sortingIdx, addrTopOfLoop);
VdbeCoverage(v);
}else{
sqlite3WhereEnd(pWInfo);
sqlite3VdbeChangeToNoop(v, addrSortingIdx);
}
sqlite3VdbeAddOp2(v, OP_Gosub, regOutputRow, addrOutputRow);
VdbeComment((v, ""output final row""));
sqlite3VdbeGoto(v, addrEnd);
addrSetAbort = sqlite3VdbeCurrentAddr(v);
sqlite3VdbeAddOp2(v, OP_Integer, 1, iAbortFlag);
VdbeComment((v, ""set abort flag""));
sqlite3VdbeAddOp1(v, OP_Return, regOutputRow);
sqlite3VdbeResolveLabel(v, addrOutputRow);
addrOutputRow = sqlite3VdbeCurrentAddr(v);
sqlite3VdbeAddOp2(v, OP_IfPos, iUseFlag, addrOutputRow+2);
VdbeCoverage(v);
VdbeComment((v, ""Groupby result generator entry point""));
sqlite3VdbeAddOp1(v, OP_Return, regOutputRow);
finalizeAggFunctions(pParse, &sAggInfo);
sqlite3ExprIfFalse(pParse, pHaving, addrOutputRow+1, SQLITE_JUMPIFNULL);
selectInnerLoop(pParse, p, -1, &sSort,
&sDistinct, pDest,
addrOutputRow+1, addrSetAbort);
sqlite3VdbeAddOp1(v, OP_Return, regOutputRow);
VdbeComment((v, ""end groupby result generator""));
sqlite3VdbeResolveLabel(v, addrReset);
resetAccumulator(pParse, &sAggInfo);
sqlite3VdbeAddOp2(v, OP_Integer, 0, iUseFlag);
VdbeComment((v, ""indicate accumulator empty""));
sqlite3VdbeAddOp1(v, OP_Return, regReset);
}
else {
#ifndef SQLITE_OMIT_BTREECOUNT
Table *pTab;
if( (pTab = isSimpleCount(p, &sAggInfo))!=0 ){
const int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
const int iCsr = pParse->nTab++;
Index *pIdx;
KeyInfo *pKeyInfo = 0;
Index *pBest = 0;
int iRoot = pTab->tnum;
sqlite3CodeVerifySchema(pParse, iDb);
sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);
if( !HasRowid(pTab) ) pBest = sqlite3PrimaryKeyIndex(pTab);
for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
if( pIdx->bUnordered==0
&& pIdx->szIdxRow<pTab->szTabRow
&& pIdx->pPartIdxWhere==0
&& (!pBest || pIdx->szIdxRow<pBest->szIdxRow)
){
pBest = pIdx;
}
}
if( pBest ){
iRoot = pBest->tnum;
pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pBest);
}
sqlite3VdbeAddOp4Int(v, OP_OpenRead, iCsr, iRoot, iDb, 1);
if( pKeyInfo ){
sqlite3VdbeChangeP4(v, -1, (char *)pKeyInfo, P4_KEYINFO);
}
sqlite3VdbeAddOp2(v, OP_Count, iCsr, sAggInfo.aFunc[0].iMem);
sqlite3VdbeAddOp1(v, OP_Close, iCsr);
explainSimpleCount(pParse, pTab, pBest);
}else
#endif /* SQLITE_OMIT_BTREECOUNT */
{
int regAcc = 0;
if( sAggInfo.nAccumulator ){
for(i=0; i<sAggInfo.nFunc; i++){
if( ExprHasProperty(sAggInfo.aFunc[i].pExpr, EP_WinFunc) ) continue;
if( sAggInfo.aFunc[i].pFunc->funcFlags&SQLITE_FUNC_NEEDCOLL ) break;
}
if( i==sAggInfo.nFunc ){
regAcc = ++pParse->nMem;
sqlite3VdbeAddOp2(v, OP_Integer, 0, regAcc);
}
}
assert( p->pGroupBy==0 );
resetAccumulator(pParse, &sAggInfo);
assert( minMaxFlag==WHERE_ORDERBY_NORMAL || pMinMaxOrderBy!=0 );
assert( pMinMaxOrderBy==0 || pMinMaxOrderBy->nExpr==1 );
SELECTTRACE(1,pParse,p,(""WhereBegin\n""));
pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pMinMaxOrderBy,
0, minMaxFlag, 0);
if( pWInfo==0 ){
goto select_end;
}
updateAccumulator(pParse, regAcc, &sAggInfo);
if( regAcc ) sqlite3VdbeAddOp2(v, OP_Integer, 1, regAcc);
if( sqlite3WhereIsOrdered(pWInfo)>0 ){
sqlite3VdbeGoto(v, sqlite3WhereBreakLabel(pWInfo));
VdbeComment((v, ""%s() by index"",
(minMaxFlag==WHERE_ORDERBY_MIN?""min"":""max"")));
}
sqlite3WhereEnd(pWInfo);
finalizeAggFunctions(pParse, &sAggInfo);
}
sSort.pOrderBy = 0;
sqlite3ExprIfFalse(pParse, pHaving, addrEnd, SQLITE_JUMPIFNULL);
selectInnerLoop(pParse, p, -1, 0, 0,
pDest, addrEnd, addrEnd);
}
sqlite3VdbeResolveLabel(v, addrEnd);
}
if( sDistinct.eTnctType==WHERE_DISTINCT_UNORDERED ){
explainTempTable(pParse, ""DISTINCT"");
}
if( sSort.pOrderBy ){
explainTempTable(pParse,
sSort.nOBSat>0 ? ""RIGHT PART OF ORDER BY"":""ORDER BY"");
assert( p->pEList==pEList );
generateSortTail(pParse, p, &sSort, pEList->nExpr, pDest);
}
sqlite3VdbeResolveLabel(v, iEnd);
rc = (pParse->nErr>0);
select_end:
sqlite3ExprListDelete(db, pMinMaxOrderBy);
sqlite3DbFree(db, sAggInfo.aCol);
sqlite3DbFree(db, sAggInfo.aFunc);
#if SELECTTRACE_ENABLED
SELECTTRACE(0x1,pParse,p,(""end processing\n""));
if( (sqlite3SelectTrace & 0x2000)!=0 && ExplainQueryPlanParent(pParse)==0 ){
sqlite3TreeViewSelect(0, p, 0);
}
#endif
ExplainQueryPlanPop(pParse);
return rc;
}",[254],"sqlite3Select in select.c in SQLite 3.30.1 allows a crash if a sub-select uses both DISTINCT and window functions, and also has certain ORDER BY usage.",sqlite,CVE-2019-19244,NVD-CWE-noinfo
7977,3925,"flac_read_loop (SF_PRIVATE *psf, unsigned len)
{ FLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;
pflac->pos = 0 ;
pflac->len = len ;
pflac->remain = len ;
if (pflac->frame != NULL && pflac->bufferpos < pflac->frame->header.blocksize)
flac_buffer_copy (psf) ;
while (pflac->pos < pflac->len)
{ if (FLAC__stream_decoder_process_single (pflac->fsd) == 0)
break ;
if (FLAC__stream_decoder_get_state (pflac->fsd) >= FLAC__STREAM_DECODER_END_OF_STREAM)
break ;
} ;
pflac->ptr = NULL ;
return pflac->pos ;
}","[3, 6, 11, 14]","In libsndfile before 1.0.28, an error in the ""flac_buffer_copy()"" function (flac.c) can be exploited to cause a stack-based buffer overflow via a specially crafted FLAC file.",libsndfile,CVE-2017-7585,CWE-119
7992,8055,"GF_Err Media_RewriteODFrame(GF_MediaBox *mdia, GF_ISOSample *sample)
{
GF_Err e;
GF_ODCodec *ODdecode;
GF_ODCodec *ODencode;
GF_ODCom *com;
GF_ESDUpdate *esdU, *esdU2;
GF_ESDRemove *esdR, *esdR2;
GF_ODUpdate *odU, *odU2;
GF_ObjectDescriptor *od;
GF_IsomObjectDescriptor *isom_od;
GF_ESD *esd;
GF_ES_ID_Ref *ref;
GF_Descriptor *desc;
GF_TrackReferenceTypeBox *mpod;
u32 i, j, skipped;
if (!mdia || !sample || !sample->data || !sample->dataLength) return GF_BAD_PARAM;
mpod = NULL;
e = Track_FindRef(mdia->mediaTrack, GF_ISOM_BOX_TYPE_MPOD, &mpod);
if (e) return e;
if (!mpod || !mpod->trackIDs) return GF_OK;
ODdecode = gf_odf_codec_new();
if (!ODdecode) return GF_OUT_OF_MEM;
ODencode = gf_odf_codec_new();
if (!ODencode) {
gf_odf_codec_del(ODdecode);
return GF_OUT_OF_MEM;
}
e = gf_odf_codec_set_au(ODdecode, sample->data, sample->dataLength);
if (e) goto err_exit;
e = gf_odf_codec_decode(ODdecode);
if (e) goto err_exit;
while (1) {
com = gf_odf_codec_get_com(ODdecode);
if (!com) break;
switch (com->tag) {
case GF_ODF_OD_UPDATE_TAG:
odU = (GF_ODUpdate *) com;
odU2 = (GF_ODUpdate *) gf_odf_com_new(GF_ODF_OD_UPDATE_TAG);
i=0;
while ((desc = (GF_Descriptor*)gf_list_enum(odU->objectDescriptors, &i))) {
switch (desc->tag) {
case GF_ODF_OD_TAG:
case GF_ODF_ISOM_OD_TAG:
case GF_ODF_ISOM_IOD_TAG:
break;
default:
return GF_ISOM_INVALID_FILE;
}
e = gf_odf_desc_copy(desc, (GF_Descriptor **)&isom_od);
if (e) goto err_exit;
if (desc->tag == GF_ODF_ISOM_IOD_TAG) {
od = (GF_ObjectDescriptor *) gf_malloc(sizeof(GF_InitialObjectDescriptor));
} else {
od = (GF_ObjectDescriptor *) gf_malloc(sizeof(GF_ObjectDescriptor));
}
if (!od) {
e = GF_OUT_OF_MEM;
goto err_exit;
}
od->ESDescriptors = gf_list_new();
od->objectDescriptorID = isom_od->objectDescriptorID;
od->tag = GF_ODF_OD_TAG;
od->URLString = isom_od->URLString;
isom_od->URLString = NULL;
od->extensionDescriptors = isom_od->extensionDescriptors;
isom_od->extensionDescriptors = NULL;
od->IPMP_Descriptors = isom_od->IPMP_Descriptors;
isom_od->IPMP_Descriptors = NULL;
od->OCIDescriptors = isom_od->OCIDescriptors;
isom_od->OCIDescriptors = NULL;
if (isom_od->tag == GF_ODF_ISOM_IOD_TAG) {
((GF_InitialObjectDescriptor *)od)->audio_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->audio_profileAndLevel;
((GF_InitialObjectDescriptor *)od)->inlineProfileFlag = ((GF_IsomInitialObjectDescriptor *)isom_od)->inlineProfileFlag;
((GF_InitialObjectDescriptor *)od)->graphics_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->graphics_profileAndLevel;
((GF_InitialObjectDescriptor *)od)->OD_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->OD_profileAndLevel;
((GF_InitialObjectDescriptor *)od)->scene_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->scene_profileAndLevel;
((GF_InitialObjectDescriptor *)od)->visual_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->visual_profileAndLevel;
((GF_InitialObjectDescriptor *)od)->IPMPToolList = ((GF_IsomInitialObjectDescriptor *)isom_od)->IPMPToolList;
((GF_IsomInitialObjectDescriptor *)isom_od)->IPMPToolList = NULL;
}
j=0;
while ((ref = (GF_ES_ID_Ref*)gf_list_enum(isom_od->ES_ID_RefDescriptors, &j))) {
if (!mpod->trackIDs || gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1]) == NULL) continue;
e = GetESDForTime(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1], sample->DTS, &esd);
if (!e) e = gf_odf_desc_add_desc((GF_Descriptor *) od, (GF_Descriptor *) esd);
if (e) {
gf_odf_desc_del((GF_Descriptor *)od);
gf_odf_com_del((GF_ODCom **)&odU2);
gf_odf_desc_del((GF_Descriptor *)isom_od);
gf_odf_com_del((GF_ODCom **)&odU);
goto err_exit;
}
}
gf_odf_desc_del((GF_Descriptor *)isom_od);
gf_list_add(odU2->objectDescriptors, od);
}
gf_odf_com_del((GF_ODCom **)&odU);
gf_odf_codec_add_com(ODencode, (GF_ODCom *)odU2);
break;
case GF_ODF_ESD_UPDATE_TAG:
esdU = (GF_ESDUpdate *) com;
esdU2 = (GF_ESDUpdate *) gf_odf_com_new(GF_ODF_ESD_UPDATE_TAG);
esdU2->ODID = esdU->ODID;
i=0;
while ((ref = (GF_ES_ID_Ref*)gf_list_enum(esdU->ESDescriptors, &i))) {
if (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1]) == NULL) continue;
e = GetESDForTime(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1], sample->DTS, &esd);
if (e) goto err_exit;
gf_list_add(esdU2->ESDescriptors, esd);
}
gf_odf_com_del((GF_ODCom **)&esdU);
gf_odf_codec_add_com(ODencode, (GF_ODCom *)esdU2);
break;
case GF_ODF_ESD_REMOVE_REF_TAG:
esdR = (GF_ESDRemove *) com;
esdR2 = (GF_ESDRemove *) gf_odf_com_new(GF_ODF_ESD_REMOVE_TAG);
esdR2->ODID = esdR->ODID;
esdR2->NbESDs = esdR->NbESDs;
esdR2->ES_ID = (unsigned short*)gf_malloc(sizeof(u32) * esdR->NbESDs);
if (!esdR2->ES_ID) {
e = GF_OUT_OF_MEM;
goto err_exit;
}
skipped = 0;
for (i = 0; i < esdR->NbESDs; i++) {
if (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[esdR->ES_ID[i] - 1]) == NULL) {
skipped ++;
} else {
esdR2->ES_ID[i - skipped] = mpod->trackIDs[esdR->ES_ID[i] - 1];
}
}
if (skipped && (skipped != esdR2->NbESDs) ) {
esdR2->NbESDs -= skipped;
esdR2->ES_ID = (unsigned short*)gf_realloc(esdR2->ES_ID, sizeof(u32) * esdR2->NbESDs);
}
gf_odf_com_del((GF_ODCom **)&esdR);
gf_odf_codec_add_com(ODencode, (GF_ODCom *)esdR2);
break;
default:
e = gf_odf_codec_add_com(ODencode, com);
if (e) goto err_exit;
}
}
e = gf_odf_codec_encode(ODencode, 1);
if (e) goto err_exit;
gf_free(sample->data);
sample->data = NULL;
sample->dataLength = 0;
e = gf_odf_codec_get_au(ODencode, &sample->data, &sample->dataLength);
err_exit:
gf_odf_codec_del(ODdecode);
gf_odf_codec_del(ODencode);
return e;
}","[84, 107, 127]",The Media_RewriteODFrame function in GPAC 1.0.1 allows attackers to cause a denial of service (NULL pointer dereference) via a crafted file in the MP4Box command.,gpac,CVE-2021-32440,CWE-476
8000,8045,"static int parse_line(char *p)
{
struct SYMBOL *s;
char *q, c;
char *dot = NULL;
struct SYMBOL *last_note_sav = NULL;
struct decos dc_sav;
int i, flags, flags_sav = 0, slur;
static char qtb[10] = {0, 1, 3, 2, 3, 0, 2, 0, 3, 0};
colnum = 0;
switch (*p) {
case '\0':
switch (parse.abc_state) {
case ABC_S_GLOBAL:
if (parse.last_sym
&& parse.last_sym->abc_type != ABC_T_NULL)
abc_new(ABC_T_NULL, NULL);
case ABC_S_HEAD:
return 0;
}
return 1;
case '%':
if (p[1] == '%') {
s = abc_new(ABC_T_PSCOM, p);
p += 2;
if (strncasecmp(p, ""decoration "", 11) == 0) {
p += 11;
while (isspace((unsigned char) *p))
p++;
switch (*p) {
case '!':
char_tb['!'] = CHAR_DECOS;
char_tb['+'] = CHAR_BAD;
break;
case '+':
char_tb['+'] = CHAR_DECOS;
char_tb['!'] = CHAR_BAD;
break;
}
return 0;
}
if (strncasecmp(p, ""linebreak "", 10) == 0) {
for (i = 0; i < sizeof char_tb; i++) {
if (char_tb[i] == CHAR_LINEBREAK)
char_tb[i] = i != '!' ?
CHAR_BAD :
CHAR_DECOS;
}
p += 10;
for (;;) {
while (isspace((unsigned char) *p))
p++;
if (*p == '\0')
break;
switch (*p) {
case '!':
case '$':
case '*':
case ';':
case '?':
case '@':
char_tb[(unsigned char) *p++]
= CHAR_LINEBREAK;
break;
case '<':
if (strncmp(p, ""<none>"", 6) == 0)
return 0;
if (strncmp(p, ""<EOL>"", 5) == 0) {
char_tb['\n'] = CHAR_LINEBREAK;
p += 5;
break;
}
default:
if (strcmp(p, ""lock"") != 0)
syntax(""Invalid character in %%%%linebreak"",
p);
return 0;
}
}
return 0;
}
if (strncasecmp(p, ""microscale "", 11) == 0) {
int v;
p += 11;
while (isspace((unsigned char) *p))
p++;
sscanf(p, ""%d"", &v);
if (v < 4 || v >= 256 || v & 1)
syntax(""Invalid value in %%microscale"", p);
else
microscale = v;
return 0;
}
if (strncasecmp(p, ""user "", 5) == 0) {
p += 5;
while (isspace((unsigned char) *p))
p++;
get_user(p, s);
return 0;
}
return 0;
}
case '\\':
return 0;
}
if (p[1] == ':'
&& *p != '|' && *p != ':') {
int new_tune;
new_tune = parse_info(p);
if (*p != 'V'
|| parse.abc_state != ABC_S_TUNE)
return new_tune;
c = p[strlen(p) - 1];
if (c != '|' && c != ']')
return new_tune;
while (!isspace((unsigned char) *p) && *p != '\0')
p++;
while (isspace((unsigned char) *p))
p++;
}
if (parse.abc_state != ABC_S_TUNE)
return 0;
flags = 0;
if (parse.abc_vers <= (2 << 16))
lyric_started = 0;
deco_start = deco_cont = NULL;
slur = 0;
while (*p != '\0') {
colnum = p - abc_line;
switch (char_tb[(unsigned char) *p++]) {
case CHAR_GCHORD:
if (flags & ABC_F_GRACE)
goto bad_char;
p = parse_gchord(p);
break;
case CHAR_GR_ST:
if (flags & ABC_F_GRACE)
goto bad_char;
last_note_sav = curvoice->last_note;
curvoice->last_note = NULL;
memcpy(&dc_sav, &dc, sizeof dc);
dc.n = 0;
flags_sav = flags;
flags = ABC_F_GRACE;
if (*p == '/') {
flags |= ABC_F_SAPPO;
p++;
}
break;
case CHAR_GR_EN:
if (!(flags & ABC_F_GRACE))
goto bad_char;
parse.last_sym->flags |= ABC_F_GR_END;
if (dc.n != 0)
syntax(""Decoration ignored"", p);
curvoice->last_note = last_note_sav;
memcpy(&dc, &dc_sav, sizeof dc);
flags = flags_sav;
break;
case CHAR_DECOS:
if (p[-1] == '!'
&& char_tb['\n'] == CHAR_LINEBREAK
&& check_nl(p)) {
s = abc_new(ABC_T_EOLN, NULL);
s->u.eoln.type = 2;
break;
}
case CHAR_DECO:
if (p[-1] == '.') {
if (*p == '(' || *p == '-') {
dot = p;
break;
}
}
p = parse_deco(p - 1, &dc, -1);
break;
case CHAR_LINEBREAK:
s = abc_new(ABC_T_EOLN, NULL);
break;
case CHAR_NOTE:
p = parse_note(p - 1, flags);
flags &= ABC_F_GRACE;
parse.last_sym->u.note.slur_st = slur;
slur = 0;
if (parse.last_sym->u.note.notes[0].len > 0)
curvoice->last_note = parse.last_sym;
break;
case CHAR_SLASH:
if (flags & ABC_F_GRACE)
goto bad_char;
if (char_tb[(unsigned char) p[-1]] != CHAR_BAR)
goto bad_char;
q = p;
while (*q == '/')
q++;
if (char_tb[(unsigned char) *q] != CHAR_BAR)
goto bad_char;
s = abc_new(ABC_T_MREP, NULL);
s->u.bar.type = 0;
s->u.bar.len = q - p + 1;
syntax(""Non standard measure repeat syntax"", p - 1);
p = q;
break;
case CHAR_BSLASH:
if (*p == '\0')
break;
syntax(""'\\' ignored"", p - 1);
break;
case CHAR_OBRA:
if (*p == '|' || *p == ']' || *p == ':'
|| isdigit((unsigned char) *p) || *p == '""'
|| *p == ' ') {
if (flags & ABC_F_GRACE)
goto bad_char;
p = parse_bar(p);
break;
}
if (p[1] != ':') {
p = parse_note(p - 1, flags);
flags &= ABC_F_GRACE;
parse.last_sym->u.note.slur_st = slur;
slur = 0;
curvoice->last_note = parse.last_sym;
break;
}
#if 0
if (flags & ABC_F_GRACE)
goto bad_char;
#endif
while (p[2] == ' ') {
p[2] = ':';
p[1] = *p;
p++;
}
c = ']';
q = p;
while (*p != '\0' && *p != c)
p++;
if (*p == '\0') {
syntax(""Escape sequence [..] not closed"", q);
c = '\0';
} else {
*p = '\0';
}
parse_info(q);
*p = c;
if (c != '\0')
p++;
break;
case CHAR_BAR:
if (flags & ABC_F_GRACE)
goto bad_char;
p = parse_bar(p);
break;
case CHAR_OPAR:
if (*p > '0' && *p <= '9') {
int pplet, qplet, rplet;
pplet = strtol(p, &q, 10);
p = q;
if ((unsigned) pplet < sizeof qtb / sizeof qtb[0])
qplet = qtb[pplet];
else
qplet = qtb[0];
rplet = pplet;
if (*p == ':') {
p++;
if (isdigit((unsigned char) *p)) {
qplet = strtol(p, &q, 10);
p = q;
}
if (*p == ':') {
p++;
if (isdigit((unsigned char) *p)) {
rplet = strtol(p, &q, 10);
p = q;
}
}
}
if (rplet < 1) {
syntax(""Invalid 'r' in tuplet"", p);
break;
}
if (pplet >= 128 || qplet >= 128 || rplet >= 128) {
syntax(""Invalid 'p:q:r' in tuplet"", p);
break;
}
if (qplet == 0)
qplet = meter % 3 == 0 ? 3 : 2;
s = abc_new(ABC_T_TUPLET, NULL);
s->u.tuplet.p_plet = pplet;
s->u.tuplet.q_plet = qplet;
s->u.tuplet.r_plet = rplet;
s->flags |= flags;
break;
}
if (*p == '&') {
if (flags & ABC_F_GRACE)
goto bad_char;
p++;
if (vover != 0) {
syntax(""Nested voice overlay"", p - 1);
break;
}
s = abc_new(ABC_T_V_OVER, NULL);
s->u.v_over.type = V_OVER_S;
s->u.v_over.voice = curvoice - voice_tb;
vover = -1;
break;
}
slur <<= 4;
if (p == dot + 1 && dc.n == 0)
slur |= SL_DOTTED;
switch (*p) {
case '\'':
slur += SL_ABOVE;
p++;
break;
case ',':
slur += SL_BELOW;
p++;
break;
default:
slur += SL_AUTO;
break;
}
break;
case CHAR_CPAR:
switch (parse.last_sym->abc_type) {
case ABC_T_NOTE:
case ABC_T_REST:
break;
default:
goto bad_char;
}
parse.last_sym->u.note.slur_end++;
break;
case CHAR_VOV:
if (flags & ABC_F_GRACE)
goto bad_char;
if (*p != ')'
|| vover == 0) {
if (!curvoice->last_note) {
syntax(""Bad start of voice overlay"", p);
break;
}
s = abc_new(ABC_T_V_OVER, NULL);
vover_new();
s->u.v_over.voice = curvoice - voice_tb;
if (vover == 0)
vover = 1;
break;
}
p++;
vover = 0;
s = abc_new(ABC_T_V_OVER, NULL);
s->u.v_over.type = V_OVER_E;
s->u.v_over.voice = curvoice->mvoice;
curvoice->last_note = NULL;
curvoice = &voice_tb[curvoice->mvoice];
break;
case CHAR_SPAC:
flags |= ABC_F_SPACE;
break;
case CHAR_MINUS: {
int tie_pos;
if (!curvoice->last_note
|| curvoice->last_note->abc_type != ABC_T_NOTE)
goto bad_char;
if (p == dot + 1 && dc.n == 0)
tie_pos = SL_DOTTED;
else
tie_pos = 0;
switch (*p) {
case '\'':
tie_pos += SL_ABOVE;
p++;
break;
case ',':
tie_pos += SL_BELOW;
p++;
break;
default:
tie_pos += SL_AUTO;
break;
}
for (i = 0; i <= curvoice->last_note->nhd; i++) {
if (curvoice->last_note->u.note.notes[i].ti1 == 0)
curvoice->last_note->u.note.notes[i].ti1 = tie_pos;
else if (curvoice->last_note->nhd == 0)
syntax(""Too many ties"", p);
}
break;
}
case CHAR_BRHY:
if (!curvoice->last_note)
goto bad_char;
i = 1;
while (*p == p[-1]) {
i++;
p++;
}
if (i > 3) {
syntax(""Bad broken rhythm"", p - 1);
i = 3;
}
if (p[-1] == '<')
i = -i;
broken_rhythm(curvoice->last_note, i);
curvoice->last_note->u.note.brhythm = i;
break;
case CHAR_IGN:
break;
default:
bad_char:
syntax((flags & ABC_F_GRACE)
? ""Bad character in grace note sequence""
: ""Bad character"",
p - 1);
break;
}
}
if (flags & ABC_F_GRACE) {
syntax(""EOLN in grace note sequence"", p - 1);
if (curvoice->last_note)
curvoice->last_note->flags |= ABC_F_GR_END;
curvoice->last_note = last_note_sav;
memcpy(&dc, &dc_sav, sizeof dc);
}
s = abc_new(ABC_T_EOLN, NULL);
if (flags & ABC_F_SPACE)
s->flags |= ABC_F_SPACE;
if (p[-1] == '\\'
|| char_tb['\n'] != CHAR_LINEBREAK)
s->u.eoln.type = 1;
return 0;
}","[183, 184, 185, 186, 221, 222, 223]",Stack-based buffer overflow in the function get_key in parse.c of abcm2ps v8.14.11 allows remote attackers to cause a Denial of Service (DoS) via unspecified vectors.,abcm2ps,CVE-2021-32435,CWE-787
8002,8478,"void naludmx_create_avc_decoder_config(GF_NALUDmxCtx *ctx, u8 **dsi, u32 *dsi_size, u8 **dsi_enh, u32 *dsi_enh_size, u32 *max_width, u32 *max_height, u32 *max_enh_width, u32 *max_enh_height, GF_Fraction *sar)
{
u32 i, count;
Bool first = GF_TRUE;
Bool first_svc = GF_TRUE;
GF_AVCConfig *cfg;
GF_AVCConfig *avcc;
GF_AVCConfig *svcc;
u32 max_w, max_h, max_ew, max_eh;
max_w = max_h = max_ew = max_eh = 0;
sar->num = sar->den = 0;
avcc = gf_odf_avc_cfg_new();
svcc = gf_odf_avc_cfg_new();
avcc->nal_unit_size = ctx->nal_length;
svcc->nal_unit_size = ctx->nal_length;
ctx->is_mvc = GF_FALSE;
count = gf_list_count(ctx->sps);
for (i=0; i<count; i++) {
Bool is_svc = GF_FALSE;
GF_NALUFFParam *sl = gf_list_get(ctx->sps, i);
AVC_SPS *sps = &ctx->avc_state->sps[sl->id];
u32 nal_type = sl->data[0] & 0x1F;
if ((sps->profile_idc == 118) || (sps->profile_idc == 128)) {
ctx->is_mvc = GF_TRUE;
}
if (ctx->explicit) {
cfg = svcc;
} else if (nal_type == GF_AVC_NALU_SVC_SUBSEQ_PARAM) {
cfg = svcc;
is_svc = GF_TRUE;
} else {
cfg = avcc;
}
if (first || (is_svc && first_svc) ) {
cfg->configurationVersion = 1;
cfg->profile_compatibility = sps->prof_compat;
cfg->AVCProfileIndication = sps->profile_idc;
cfg->AVCLevelIndication = sps->level_idc;
cfg->chroma_format = sps->chroma_format;
cfg->luma_bit_depth = 8 + sps->luma_bit_depth_m8;
cfg->chroma_bit_depth = 8 + sps->chroma_bit_depth_m8;
if (!gf_avc_is_rext_profile(cfg->AVCProfileIndication)
&& ((cfg->chroma_format>1) || (cfg->luma_bit_depth>8) || (cfg->chroma_bit_depth>8))
) {
if ((cfg->luma_bit_depth>8) || (cfg->chroma_bit_depth>8)) {
cfg->AVCProfileIndication = 110;
} else {
cfg->AVCProfileIndication = (cfg->chroma_format==3) ? 244 : 122;
}
}
if (sps->vui_parameters_present_flag && sps->vui.par_num && sps->vui.par_den) {
sar->num = sps->vui.par_num;
sar->den = sps->vui.par_den;
}
ctx->interlaced = sps->frame_mbs_only_flag ? GF_FALSE : GF_TRUE;
if (first && (!ctx->fps.num || !ctx->fps.den) && sps->vui.timing_info_present_flag
&& (sps->vui.time_scale <= 1000*sps->vui.num_units_in_tick)
) {
u8 DeltaTfiDivisorIdx;
if (!sps->vui.pic_struct_present_flag) {
DeltaTfiDivisorIdx = 1 + (1 - ctx->avc_state->s_info.field_pic_flag);
} else {
if (!ctx->avc_state->sei.pic_timing.pic_struct)
DeltaTfiDivisorIdx = 2;
else if (ctx->avc_state->sei.pic_timing.pic_struct == 8)
DeltaTfiDivisorIdx = 6;
else
DeltaTfiDivisorIdx = (ctx->avc_state->sei.pic_timing.pic_struct+1) / 2;
}
if (!ctx->timescale) {
ctx->cur_fps.num = 2 * sps->vui.time_scale;
ctx->cur_fps.den =  2 * sps->vui.num_units_in_tick * DeltaTfiDivisorIdx;
if (!ctx->fps.num && ctx->dts==ctx->fps.den)
ctx->dts = ctx->cur_fps.den;
}
if (! sps->vui.fixed_frame_rate_flag)
GF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (""[%s] Possible Variable Frame Rate: VUI \""fixed_frame_rate_flag\"" absent\n"", ctx->log_name));
}
ctx->fps = ctx->cur_fps;
}
first = GF_FALSE;
if (is_svc) {
first_svc = GF_FALSE;
if (sps->width > max_ew) max_ew = sps->width;
if (sps->height > max_eh) max_eh = sps->height;
} else {
if (sps->width > max_w) max_w = sps->width;
if (sps->height > max_h) max_h = sps->height;
}
if (!ctx->analyze)
gf_list_add(cfg->sequenceParameterSets, sl);
}
cfg = ctx->explicit ? svcc : avcc;
count = gf_list_count(ctx->sps_ext);
for (i=0; i<count; i++) {
GF_NALUFFParam *sl = gf_list_get(ctx->sps_ext, i);
if (!cfg->sequenceParameterSetExtensions) cfg->sequenceParameterSetExtensions = gf_list_new();
if (!ctx->analyze)
gf_list_add(cfg->sequenceParameterSetExtensions, sl);
}
cfg = ctx->explicit ? svcc : avcc;
count = gf_list_count(ctx->pps);
for (i=0; i<count; i++) {
GF_NALUFFParam *sl = gf_list_get(ctx->pps, i);
if (!ctx->analyze)
gf_list_add(cfg->pictureParameterSets, sl);
}
cfg = svcc;
count = gf_list_count(ctx->pps_svc);
for (i=0; i<count; i++) {
GF_NALUFFParam *sl = gf_list_get(ctx->pps_svc, i);
if (!ctx->analyze)
gf_list_add(cfg->pictureParameterSets, sl);
}
*dsi = *dsi_enh = NULL;
*dsi_size = *dsi_enh_size = 0;
if (ctx->explicit) {
gf_odf_avc_cfg_write(svcc, dsi, dsi_size);
} else {
gf_odf_avc_cfg_write(avcc, dsi, dsi_size);
if (gf_list_count(svcc->sequenceParameterSets) || svcc->sequenceParameterSetExtensions) {
gf_odf_avc_cfg_write(svcc, dsi_enh, dsi_enh_size);
}
}
gf_list_reset(avcc->sequenceParameterSets);
gf_list_reset(avcc->sequenceParameterSetExtensions);
gf_list_reset(avcc->pictureParameterSets);
gf_list_reset(svcc->sequenceParameterSets);
gf_list_reset(svcc->sequenceParameterSetExtensions);
gf_list_reset(svcc->pictureParameterSets);
gf_odf_avc_cfg_del(avcc);
gf_odf_avc_cfg_del(svcc);
*max_width = max_w;
*max_height = max_h;
*max_enh_width = max_ew;
*max_enh_height = max_eh;
}","[70, 72]","A Segmentation fault caused by a floating point exception exists in Gpac through 1.0.1 using mp4box via the naludmx_enqueue_or_dispatch function in reframe_nalu.c, which causes a denial of service.",gpac,CVE-2021-40562,CWE-697
8048,8490,"void gf_av1_reset_state(AV1State *state, Bool is_destroy)
{
GF_List *l1, *l2;
if (state->frame_state.header_obus) {
while (gf_list_count(state->frame_state.header_obus)) {
GF_AV1_OBUArrayEntry *a = (GF_AV1_OBUArrayEntry*)gf_list_pop_back(state->frame_state.header_obus);
if (a->obu) gf_free(a->obu);
gf_free(a);
}
}
if (state->frame_state.frame_obus) {
while (gf_list_count(state->frame_state.frame_obus)) {
GF_AV1_OBUArrayEntry *a = (GF_AV1_OBUArrayEntry*)gf_list_pop_back(state->frame_state.frame_obus);
if (a->obu) gf_free(a->obu);
gf_free(a);
}
}
l1 = state->frame_state.frame_obus;
l2 = state->frame_state.header_obus;
memset(&state->frame_state, 0, sizeof(AV1StateFrame));
state->frame_state.is_first_frame = GF_TRUE;
if (is_destroy) {
gf_list_del(l1);
gf_list_del(l2);
if (state->bs) {
if (gf_bs_get_position(state->bs)) {
u32 size;
gf_bs_get_content_no_truncate(state->bs, &state->frame_obus, &size, &state->frame_obus_alloc);
}
gf_bs_del(state->bs);
}
state->bs = NULL;
}
else {
state->frame_state.frame_obus = l1;
state->frame_state.header_obus = l2;
if (state->bs)
gf_bs_seek(state->bs, 0);
}
}","[26, 27, 28]","The binary MP4Box in Gpac 1.0.1 has a double-free bug in the av1dmx_finalize function in reframe_av1.c, which allows attackers to cause a denial of service.",gpac,CVE-2021-40572,CWE-415
8072,7813,"static void do_iccprofile_item(deark *c, lctx *d, i64 pos, i64 len)
{
i64 selector;
i64 data_len;
if(len<4) return;
selector = de_getu32be(pos);
data_len = len-4;
de_dbg(c, ""ICC profile segment, selector=%d, data len=%d"", (int)selector,
(int)data_len);
if(selector!=1) {
dbuf_close(d->iccprofile_file);
d->iccprofile_file = NULL;
}
if(selector==0) {
d->iccprofile_file = dbuf_create_output_file(c, ""icc"", NULL, DE_CREATEFLAG_IS_AUX);
}
if(selector==0 || selector==1) {
dbuf_copy(c->infile, pos+4, data_len, d->iccprofile_file);
}
}",[18],"In Deark before 1.5.8, a specially crafted input file can cause a NULL pointer dereference in the dbuf_write function (src/deark-dbuf.c).",deark,CVE-2021-28855,CWE-476
8081,6140,"static void gf_m2ts_process_pat(GF_M2TS_Demuxer *ts, GF_M2TS_SECTION_ES *ses, GF_List *sections, u8 table_id, u16 ex_table_id, u8 version_number, u8 last_section_number, u32 status)
{
GF_M2TS_Program *prog;
GF_M2TS_SECTION_ES *pmt;
u32 i, nb_progs, evt_type;
u32 nb_sections;
u32 data_size;
unsigned char *data;
GF_M2TS_Section *section;
if (!(status&GF_M2TS_TABLE_END)) return;
if (status&GF_M2TS_TABLE_REPEAT) {
if (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_PAT_REPEAT, NULL);
return;
}
nb_sections = gf_list_count(sections);
if (nb_sections > 1) {
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""PAT on multiple sections not supported\n""));
}
section = (GF_M2TS_Section *)gf_list_get(sections, 0);
data = section->data;
data_size = section->data_size;
if (!(status&GF_M2TS_TABLE_UPDATE) && gf_list_count(ts->programs)) {
if (ts->pat->demux_restarted) {
ts->pat->demux_restarted = 0;
} else {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""Multiple different PAT on single TS found, ignoring new PAT declaration (table id %d - extended table id %d)\n"", table_id, ex_table_id));
}
return;
}
nb_progs = data_size / 4;
for (i=0; i<nb_progs; i++) {
u16 number, pid;
number = (data[0]<<8) | data[1];
pid = (data[2]&0x1f)<<8 | data[3];
data += 4;
if (number==0) {
if (!ts->nit) {
ts->nit = gf_m2ts_section_filter_new(gf_m2ts_process_nit, 0);
}
} else {
GF_SAFEALLOC(prog, GF_M2TS_Program);
if (!prog) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""Fail to allocate program for pid %d\n"", pid));
return;
}
prog->streams = gf_list_new();
prog->pmt_pid = pid;
prog->number = number;
prog->ts = ts;
gf_list_add(ts->programs, prog);
GF_SAFEALLOC(pmt, GF_M2TS_SECTION_ES);
if (!pmt) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""Fail to allocate pmt filter for pid %d\n"", pid));
return;
}
pmt->flags = GF_M2TS_ES_IS_SECTION;
gf_list_add(prog->streams, pmt);
pmt->pid = prog->pmt_pid;
pmt->program = prog;
ts->ess[pmt->pid] = (GF_M2TS_ES *)pmt;
pmt->sec = gf_m2ts_section_filter_new(gf_m2ts_process_pmt, 0);
}
}
evt_type = (status&GF_M2TS_TABLE_UPDATE) ? GF_M2TS_EVT_PAT_UPDATE : GF_M2TS_EVT_PAT_FOUND;
if (ts->on_event) ts->on_event(ts, evt_type, NULL);
}",[40],"An issue was discovered in libgpac.a in GPAC before 0.8.0, as demonstrated by MP4Box. It contains a Use-After-Free vulnerability in gf_m2ts_process_pmt in media_tools/mpegts.c that can cause a denial of service via a crafted MP4 file.",gpac,CVE-2019-20628,CWE-416
8083,7959,"static s32 gf_avc_read_sps_bs_internal(GF_BitStream *bs, AVCState *avc, u32 subseq_sps, u32 *vui_flag_pos, u32 nal_hdr)
{
AVC_SPS *sps;
s32 mb_width, mb_height, sps_id = -1;
u32 profile_idc, level_idc, pcomp, i, chroma_format_idc, cl = 0, cr = 0, ct = 0, cb = 0, luma_bd, chroma_bd;
u8 separate_colour_plane_flag = 0;
if (!vui_flag_pos) {
gf_bs_enable_emulation_byte_removal(bs, GF_TRUE);
}
if (!bs) {
return -1;
}
if (!nal_hdr) {
gf_bs_read_int_log(bs, 1, ""forbidden_zero_bit"");
gf_bs_read_int_log(bs, 2, ""nal_ref_idc"");
gf_bs_read_int_log(bs, 5, ""nal_unit_type"");
}
profile_idc = gf_bs_read_int_log(bs, 8, ""profile_idc"");
pcomp = gf_bs_read_int_log(bs, 8, ""profile_compatibility"");
if (pcomp & 0x3)
return -1;
level_idc = gf_bs_read_int_log(bs, 8, ""level_idc"");
sps_id = gf_bs_read_ue_log(bs, ""sps_id"") + GF_SVC_SSPS_ID_SHIFT * subseq_sps;
if (sps_id >= 32) {
return -1;
}
if (sps_id < 0) {
return -1;
}
luma_bd = chroma_bd = 0;
sps = &avc->sps[sps_id];
chroma_format_idc = sps->ChromaArrayType = 1;
sps->state |= subseq_sps ? AVC_SUBSPS_PARSED : AVC_SPS_PARSED;
switch (profile_idc) {
case 100:
case 110:
case 122:
case 244:
case 44:
if (pcomp & 0xE0)
return -1;
case 83:
case 86:
case 118:
case 128:
chroma_format_idc = gf_bs_read_ue_log(bs, ""chroma_format_idc"");
sps->ChromaArrayType = chroma_format_idc;
if (chroma_format_idc == 3) {
separate_colour_plane_flag = gf_bs_read_int_log(bs, 1, ""separate_colour_plane_flag"");
if (separate_colour_plane_flag) sps->ChromaArrayType = 0;
}
luma_bd = gf_bs_read_ue_log(bs, ""luma_bit_depth"");
chroma_bd = gf_bs_read_ue_log(bs, ""chroma_bit_depth"");
gf_bs_read_int_log(bs, 1, ""qpprime_y_zero_transform_bypass_flag"");
if (gf_bs_read_int_log(bs, 1, ""seq_scaling_matrix_present_flag"")) {
u32 k;
for (k = 0; k < 8; k++) {
if (gf_bs_read_int_log_idx(bs, 1, ""seq_scaling_list_present_flag"", k)) {
u32 z, last = 8, next = 8;
u32 sl = k < 6 ? 16 : 64;
for (z = 0; z < sl; z++) {
if (next) {
s32 delta = gf_bs_read_se(bs);
next = (last + delta + 256) % 256;
}
last = next ? next : last;
}
}
}
}
break;
}
sps->profile_idc = profile_idc;
sps->level_idc = level_idc;
sps->prof_compat = pcomp;
sps->log2_max_frame_num = gf_bs_read_ue_log(bs, ""log2_max_frame_num"") + 4;
sps->poc_type = gf_bs_read_ue_log(bs, ""poc_type"");
sps->chroma_format = chroma_format_idc;
sps->luma_bit_depth_m8 = luma_bd;
sps->chroma_bit_depth_m8 = chroma_bd;
if (sps->poc_type == 0) {
sps->log2_max_poc_lsb = gf_bs_read_ue_log(bs, ""log2_max_poc_lsb"") + 4;
}
else if (sps->poc_type == 1) {
sps->delta_pic_order_always_zero_flag = gf_bs_read_int_log(bs, 1, ""delta_pic_order_always_zero_flag"");
sps->offset_for_non_ref_pic = gf_bs_read_se_log(bs, ""offset_for_non_ref_pic"");
sps->offset_for_top_to_bottom_field = gf_bs_read_se_log(bs, ""offset_for_top_to_bottom_field"");
sps->poc_cycle_length = gf_bs_read_ue_log(bs, ""poc_cycle_length"");
if (sps->poc_cycle_length > GF_ARRAY_LENGTH(sps->offset_for_ref_frame)) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[avc-h264] offset_for_ref_frame overflow from poc_cycle_length\n""));
return -1;
}
for (i = 0; i < sps->poc_cycle_length; i++)
sps->offset_for_ref_frame[i] = gf_bs_read_se_log_idx(bs, ""offset_for_ref_frame"", i);
}
if (sps->poc_type > 2) {
return -1;
}
sps->max_num_ref_frames = gf_bs_read_ue_log(bs, ""max_num_ref_frames"");
sps->gaps_in_frame_num_value_allowed_flag = gf_bs_read_int_log(bs, 1, ""gaps_in_frame_num_value_allowed_flag"");
mb_width = gf_bs_read_ue_log(bs, ""pic_width_in_mbs_minus1"") + 1;
mb_height = gf_bs_read_ue_log(bs, ""pic_height_in_map_units_minus1"") + 1;
sps->frame_mbs_only_flag = gf_bs_read_int_log(bs, 1, ""frame_mbs_only_flag"");
sps->width = mb_width * 16;
sps->height = (2 - sps->frame_mbs_only_flag) * mb_height * 16;
if (!sps->frame_mbs_only_flag) sps->mb_adaptive_frame_field_flag = gf_bs_read_int_log(bs, 1, ""mb_adaptive_frame_field_flag"");
gf_bs_read_int_log(bs, 1, ""direct_8x8_inference_flag"");
if (gf_bs_read_int_log(bs, 1, ""frame_cropping_flag"")) {
int CropUnitX, CropUnitY, SubWidthC = -1, SubHeightC = -1;
if (chroma_format_idc == 1) {
SubWidthC = 2; SubHeightC = 2;
}
else if (chroma_format_idc == 2) {
SubWidthC = 2; SubHeightC = 1;
}
else if ((chroma_format_idc == 3) && (separate_colour_plane_flag == 0)) {
SubWidthC = 1; SubHeightC = 1;
}
if (sps->ChromaArrayType == 0) {
assert(SubWidthC == -1);
CropUnitX = 1;
CropUnitY = 2 - sps->frame_mbs_only_flag;
}
else {
CropUnitX = SubWidthC;
CropUnitY = SubHeightC * (2 - sps->frame_mbs_only_flag);
}
cl = gf_bs_read_ue_log(bs, ""frame_crop_left_offset"");
cr = gf_bs_read_ue_log(bs, ""frame_crop_right_offset"");
ct = gf_bs_read_ue_log(bs, ""frame_crop_top_offset"");
cb = gf_bs_read_ue_log(bs, ""frame_crop_bottom_offset"");
sps->width -= CropUnitX * (cl + cr);
sps->height -= CropUnitY * (ct + cb);
cl *= CropUnitX;
cr *= CropUnitX;
ct *= CropUnitY;
cb *= CropUnitY;
}
sps->crop.left = cl;
sps->crop.right = cr;
sps->crop.top = ct;
sps->crop.bottom = cb;
if (vui_flag_pos) {
*vui_flag_pos = (u32)gf_bs_get_bit_offset(bs);
}
sps->vui_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""vui_parameters_present_flag"");
if (sps->vui_parameters_present_flag) {
sps->vui.aspect_ratio_info_present_flag = gf_bs_read_int_log(bs, 1, ""aspect_ratio_info_present_flag"");
if (sps->vui.aspect_ratio_info_present_flag) {
s32 aspect_ratio_idc = gf_bs_read_int_log(bs, 8, ""aspect_ratio_idc"");
if (aspect_ratio_idc == 255) {
sps->vui.par_num = gf_bs_read_int_log(bs, 16, ""aspect_ratio_num"");
sps->vui.par_den = gf_bs_read_int_log(bs, 16, ""aspect_ratio_den"");
}
else if (aspect_ratio_idc < GF_ARRAY_LENGTH(avc_hevc_sar) ) {
sps->vui.par_num = avc_hevc_sar[aspect_ratio_idc].w;
sps->vui.par_den = avc_hevc_sar[aspect_ratio_idc].h;
}
else {
GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (""[avc-h264] Unknown aspect_ratio_idc: your video may have a wrong aspect ratio. Contact the GPAC team!\n""));
}
}
sps->vui.overscan_info_present_flag = gf_bs_read_int_log(bs, 1, ""overscan_info_present_flag"");
if (sps->vui.overscan_info_present_flag)
gf_bs_read_int_log(bs, 1, ""overscan_appropriate_flag"");
sps->vui.video_format = 5;
sps->vui.colour_primaries = 2;
sps->vui.transfer_characteristics = 2;
sps->vui.matrix_coefficients = 2;
sps->vui.video_signal_type_present_flag = gf_bs_read_int_log(bs, 1, ""video_signal_type_present_flag"");
if (sps->vui.video_signal_type_present_flag) {
sps->vui.video_format = gf_bs_read_int_log(bs, 3, ""video_format"");
sps->vui.video_full_range_flag = gf_bs_read_int_log(bs, 1, ""video_full_range_flag"");
sps->vui.colour_description_present_flag = gf_bs_read_int_log(bs, 1, ""colour_description_present_flag"");
if (sps->vui.colour_description_present_flag) {
sps->vui.colour_primaries = gf_bs_read_int_log(bs, 8, ""colour_primaries"");
sps->vui.transfer_characteristics = gf_bs_read_int_log(bs, 8, ""transfer_characteristics"");
sps->vui.matrix_coefficients = gf_bs_read_int_log(bs, 8, ""matrix_coefficients"");
}
}
if (gf_bs_read_int_log(bs, 1, ""chroma_location_info_present_flag"")) {
gf_bs_read_ue_log(bs, ""chroma_sample_location_type_top_field"");
gf_bs_read_ue_log(bs, ""chroma_sample_location_type_bottom_field"");
}
sps->vui.timing_info_present_flag = gf_bs_read_int_log(bs, 1, ""timing_info_present_flag"");
if (sps->vui.timing_info_present_flag) {
sps->vui.num_units_in_tick = gf_bs_read_int_log(bs, 32, ""num_units_in_tick"");
sps->vui.time_scale = gf_bs_read_int_log(bs, 32, ""time_scale"");
sps->vui.fixed_frame_rate_flag = gf_bs_read_int_log(bs, 1, ""fixed_frame_rate_flag"");
}
sps->vui.nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""nal_hrd_parameters_present_flag"");
if (sps->vui.nal_hrd_parameters_present_flag)
avc_parse_hrd_parameters(bs, &sps->vui.hrd);
sps->vui.vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""vcl_hrd_parameters_present_flag"");
if (sps->vui.vcl_hrd_parameters_present_flag)
avc_parse_hrd_parameters(bs, &sps->vui.hrd);
if (sps->vui.nal_hrd_parameters_present_flag || sps->vui.vcl_hrd_parameters_present_flag)
sps->vui.low_delay_hrd_flag = gf_bs_read_int_log(bs, 1, ""low_delay_hrd_flag"");
sps->vui.pic_struct_present_flag = gf_bs_read_int_log(bs, 1, ""pic_struct_present_flag"");
}
if (subseq_sps) {
if ((profile_idc == 83) || (profile_idc == 86)) {
u8 extended_spatial_scalability_idc;
gf_bs_read_int_log(bs, 1, ""inter_layer_deblocking_filter_control_present_flag"");
extended_spatial_scalability_idc = gf_bs_read_int_log(bs, 2, ""extended_spatial_scalability_idc"");
if (sps->ChromaArrayType == 1 || sps->ChromaArrayType == 2) {
gf_bs_read_int_log(bs, 1, ""chroma_phase_x_plus1_flag"");
}
if (sps->ChromaArrayType == 1) {
gf_bs_read_int_log(bs, 2, ""chroma_phase_y_plus1"");
}
if (extended_spatial_scalability_idc == 1) {
if (sps->ChromaArrayType > 0) {
gf_bs_read_int_log(bs, 1, ""seq_ref_layer_chroma_phase_x_plus1_flag"");
gf_bs_read_int_log(bs, 2, ""seq_ref_layer_chroma_phase_y_plus1"");
}
gf_bs_read_se_log(bs, ""seq_scaled_ref_layer_left_offset"");
gf_bs_read_se_log(bs, ""seq_scaled_ref_layer_top_offset"");
gf_bs_read_se_log(bs, ""seq_scaled_ref_layer_right_offset"");
gf_bs_read_se_log(bs, ""seq_scaled_ref_layer_bottom_offset"");
}
if (gf_bs_read_int_log(bs, 1, ""seq_tcoeff_level_prediction_flag"")) {
gf_bs_read_int_log(bs, 1, ""adaptive_tcoeff_level_prediction_flag"");
}
gf_bs_read_int_log(bs, 1, ""slice_header_restriction_flag"");
if (gf_bs_read_int_log(bs, 1, ""svc_vui_parameters_present"")) {
u32 vui_ext_num_entries_minus1 = gf_bs_read_ue_log(bs, ""vui_ext_num_entries_minus1"");
for (i = 0; i <= vui_ext_num_entries_minus1; i++) {
u8 vui_ext_nal_hrd_parameters_present_flag, vui_ext_vcl_hrd_parameters_present_flag, vui_ext_timing_info_present_flag;
gf_bs_read_int_log(bs, 3, ""vui_ext_dependency_id"");
gf_bs_read_int_log(bs, 4, ""vui_ext_quality_id"");
gf_bs_read_int_log(bs, 3, ""vui_ext_temporal_id"");
vui_ext_timing_info_present_flag = gf_bs_read_int_log(bs, 1, ""vui_ext_timing_info_present_flag"");
if (vui_ext_timing_info_present_flag) {
gf_bs_read_int_log(bs, 32, ""vui_ext_num_units_in_tick"");
gf_bs_read_int_log(bs, 32, ""vui_ext_time_scale"");
gf_bs_read_int_log(bs, 1, ""vui_ext_fixed_frame_rate_flag"");
}
vui_ext_nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""vui_ext_nal_hrd_parameters_present_flag"");
if (vui_ext_nal_hrd_parameters_present_flag) {
}
vui_ext_vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""vui_ext_vcl_hrd_parameters_present_flag"");
if (vui_ext_vcl_hrd_parameters_present_flag) {
}
if (vui_ext_nal_hrd_parameters_present_flag || vui_ext_vcl_hrd_parameters_present_flag) {
gf_bs_read_int_log(bs, 1, ""vui_ext_low_delay_hrd_flag"");
}
gf_bs_read_int_log(bs, 1, ""vui_ext_pic_struct_present_flag"");
}
}
}
else if ((profile_idc == 118) || (profile_idc == 128)) {
GF_LOG(GF_LOG_INFO, GF_LOG_CODING, (""[avc-h264] MVC parsing not implemented - skipping parsing end of Subset SPS\n""));
return sps_id;
}
if (gf_bs_read_int_log(bs, 1, ""additional_extension2"")) {
GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (""[avc-h264] skipping parsing end of Subset SPS (additional_extension2)\n""));
return sps_id;
}
}
return sps_id;
}","[24, 25, 27]",There is a integer overflow in media_tools/av_parsers.c in the hevc_parse_slice_segment function in GPAC 1.0.1 which results in a crash.,gpac,CVE-2021-30014,CWE-190
8092,7043,"void process_packet_tail(struct msg_digest *md)
{
struct state *st = md->st;
enum state_kind from_state = md->v1_from_state;
const struct state_v1_microcode *smc = md->smc;
bool new_iv_set = md->new_iv_set;
bool self_delete = FALSE;
if (md->hdr.isa_flags & ISAKMP_FLAGS_v1_ENCRYPTION) {
endpoint_buf b;
dbg(""received encrypted packet from %s"", str_endpoint(&md->sender, &b));
if (st == NULL) {
libreswan_log(
""discarding encrypted message for an unknown ISAKMP SA"");
return;
}
if (st->st_skeyid_e_nss == NULL) {
loglog(RC_LOG_SERIOUS,
""discarding encrypted message because we haven't yet negotiated keying material"");
return;
}
md->encrypted = TRUE;
const struct encrypt_desc *e = st->st_oakley.ta_encrypt;
if (pbs_left(&md->message_pbs) % e->enc_blocksize != 0) {
loglog(RC_LOG_SERIOUS, ""malformed message: not a multiple of encryption blocksize"");
return;
}
md->raw_packet = clone_bytes_as_chunk(md->packet_pbs.start,
pbs_room(&md->packet_pbs),
""raw packet"");
if (!new_iv_set) {
if (st->st_v1_iv.len == 0) {
init_phase2_iv(st, &md->hdr.isa_msgid);
} else {
restore_new_iv(st, st->st_v1_iv);
}
}
passert(st->st_v1_new_iv.len >= e->enc_blocksize);
st->st_v1_new_iv.len = e->enc_blocksize;
if (DBGP(DBG_CRYPT)) {
DBG_log(""decrypting %u bytes using algorithm %s"",
(unsigned) pbs_left(&md->message_pbs),
st->st_oakley.ta_encrypt->common.fqn);
DBG_dump_hunk(""IV before:"", st->st_v1_new_iv);
}
e->encrypt_ops->do_crypt(e, md->message_pbs.cur,
pbs_left(&md->message_pbs),
st->st_enc_key_nss,
st->st_v1_new_iv.ptr, FALSE);
if (DBGP(DBG_CRYPT)) {
DBG_dump_hunk(""IV after:"", st->st_v1_new_iv);
DBG_log(""decrypted payload (starts at offset %td):"",
md->message_pbs.cur - md->message_pbs.roof);
DBG_dump(NULL, md->message_pbs.start,
md->message_pbs.roof - md->message_pbs.start);
}
} else {
if (smc->flags & SMF_INPUT_ENCRYPTED) {
loglog(RC_LOG_SERIOUS,
""packet rejected: should have been encrypted"");
SEND_NOTIFICATION(INVALID_FLAGS);
return;
}
}
{
enum next_payload_types_ikev1 np = md->hdr.isa_np;
lset_t needed = smc->req_payloads;
const char *excuse =
LIN(SMF_PSK_AUTH | SMF_FIRST_ENCRYPTED_INPUT,
smc->flags) ?
""probable authentication failure (mismatch of preshared secrets?): ""
:
"""";
while (np != ISAKMP_NEXT_NONE) {
struct_desc *sd = v1_payload_desc(np);
if (md->digest_roof >= elemsof(md->digest)) {
loglog(RC_LOG_SERIOUS,
""more than %zu payloads in message; ignored"",
elemsof(md->digest));
if (!md->encrypted) {
SEND_NOTIFICATION(PAYLOAD_MALFORMED);
}
return;
}
struct payload_digest *const pd = md->digest + md->digest_roof;
if (st != NULL && st->st_connection != NULL &&
(st->st_connection->policy & POLICY_AGGRESSIVE) == LEMPTY)
{
switch (np) {
case ISAKMP_NEXT_NATD_RFC:
case ISAKMP_NEXT_NATOA_RFC:
if ((st->hidden_variables.st_nat_traversal & NAT_T_WITH_RFC_VALUES) == LEMPTY) {
DBG(DBG_NATT,
DBG_log(""st_nat_traversal was: %s"",
bitnamesof(natt_bit_names,
st->hidden_variables.st_nat_traversal)));
sd = NULL;
}
break;
default:
break;
}
}
if (sd == NULL) {
switch (np) {
case ISAKMP_NEXT_ID:
sd = (IS_PHASE1(from_state) ||
IS_PHASE15(from_state)) ?
&isakmp_identification_desc :
&isakmp_ipsec_identification_desc;
break;
case ISAKMP_NEXT_NATD_DRAFTS:
np = ISAKMP_NEXT_NATD_RFC;
sd = &isakmp_nat_d_drafts;
break;
case ISAKMP_NEXT_NATOA_DRAFTS:
np = ISAKMP_NEXT_NATOA_RFC;
sd = &isakmp_nat_oa_drafts;
break;
case ISAKMP_NEXT_SAK:
loglog(RC_LOG_SERIOUS,
""%smessage with unsupported payload ISAKMP_NEXT_SAK (or ISAKMP_NEXT_NATD_BADDRAFTS) ignored"",
excuse);
if (!in_struct(&pd->payload, &isakmp_ignore_desc, &md->message_pbs,
&pd->pbs)) {
loglog(RC_LOG_SERIOUS,
""%smalformed payload in packet"",
excuse);
if (!md->encrypted) {
SEND_NOTIFICATION(PAYLOAD_MALFORMED);
}
return;
}
np = pd->payload.generic.isag_np;
continue;
default:
loglog(RC_LOG_SERIOUS,
""%smessage ignored because it contains an unknown or unexpected payload type (%s) at the outermost level"",
excuse,
enum_show(&ikev1_payload_names, np));
if (!md->encrypted) {
SEND_NOTIFICATION(INVALID_PAYLOAD_TYPE);
}
return;
}
passert(sd != NULL);
}
passert(np < LELEM_ROOF);
{
lset_t s = LELEM(np);
if (LDISJOINT(s,
needed | smc->opt_payloads |
LELEM(ISAKMP_NEXT_VID) |
LELEM(ISAKMP_NEXT_N) |
LELEM(ISAKMP_NEXT_D) |
LELEM(ISAKMP_NEXT_CR) |
LELEM(ISAKMP_NEXT_CERT))) {
loglog(RC_LOG_SERIOUS,
""%smessage ignored because it contains a payload type (%s) unexpected by state %s"",
excuse,
enum_show(&ikev1_payload_names, np),
st->st_state->name);
if (!md->encrypted) {
SEND_NOTIFICATION(INVALID_PAYLOAD_TYPE);
}
return;
}
DBG(DBG_PARSING,
DBG_log(""got payload 0x%"" PRIxLSET""  (%s) needed: 0x%"" PRIxLSET "" opt: 0x%"" PRIxLSET,
s, enum_show(&ikev1_payload_names, np),
needed, smc->opt_payloads));
needed &= ~s;
}
pd->payload_type = np;
if (!in_struct(&pd->payload, sd, &md->message_pbs,
&pd->pbs)) {
loglog(RC_LOG_SERIOUS,
""%smalformed payload in packet"",
excuse);
if (!md->encrypted) {
SEND_NOTIFICATION(PAYLOAD_MALFORMED);
}
return;
}
switch (np) {
case ISAKMP_NEXT_ID:
case ISAKMP_NEXT_NATOA_RFC:
DBG(DBG_PARSING,
DBG_dump(""     obj: "", pd->pbs.cur,
pbs_left(&pd->pbs)));
break;
default:
break;
}
{
passert(np < elemsof(md->chain));
struct payload_digest **p = &md->chain[np];
while (*p != NULL)
p = &(*p)->next;
*p = pd;
pd->next = NULL;
}
np = pd->payload.generic.isag_np;
md->digest_roof++;
excuse = """";
}
DBG(DBG_PARSING, {
if (pbs_left(&md->message_pbs) != 0)
DBG_log(""removing %d bytes of padding"",
(int) pbs_left(&md->message_pbs));
});
md->message_pbs.roof = md->message_pbs.cur;
if (needed != 0) {
loglog(RC_LOG_SERIOUS,
""message for %s is missing payloads %s"",
finite_states[from_state]->name,
bitnamesof(payload_name_ikev1, needed));
if (!md->encrypted) {
SEND_NOTIFICATION(PAYLOAD_MALFORMED);
}
return;
}
}
if (!check_v1_HASH(smc->hash_type, smc->message, st, md)) {
return;
}
if (IS_PHASE1(from_state) || IS_PHASE15(from_state)) {
if (md->chain[ISAKMP_NEXT_SA] != NULL &&
md->hdr.isa_np != ISAKMP_NEXT_SA) {
loglog(RC_LOG_SERIOUS,
""malformed Phase 1 message: does not start with an SA payload"");
if (!md->encrypted) {
SEND_NOTIFICATION(PAYLOAD_MALFORMED);
}
return;
}
} else if (IS_QUICK(from_state)) {
if (md->hdr.isa_np != ISAKMP_NEXT_HASH) {
loglog(RC_LOG_SERIOUS,
""malformed Quick Mode message: does not start with a HASH payload"");
if (!md->encrypted) {
SEND_NOTIFICATION(PAYLOAD_MALFORMED);
}
return;
}
{
struct payload_digest *p;
int i;
p = md->chain[ISAKMP_NEXT_SA];
i = 1;
while (p != NULL) {
if (p != &md->digest[i]) {
loglog(RC_LOG_SERIOUS,
""malformed Quick Mode message: SA payload is in wrong position"");
if (!md->encrypted) {
SEND_NOTIFICATION(PAYLOAD_MALFORMED);
}
return;
}
p = p->next;
i++;
}
}
{
struct payload_digest *id = md->chain[ISAKMP_NEXT_ID];
if (id != NULL) {
if (id->next == NULL ||
id->next->next != NULL) {
loglog(RC_LOG_SERIOUS,
""malformed Quick Mode message: if any ID payload is present, there must be exactly two"");
SEND_NOTIFICATION(PAYLOAD_MALFORMED);
return;
}
if (id + 1 != id->next) {
loglog(RC_LOG_SERIOUS,
""malformed Quick Mode message: the ID payloads are not adjacent"");
SEND_NOTIFICATION(PAYLOAD_MALFORMED);
return;
}
}
}
}
{
struct payload_digest *p = md->chain[ISAKMP_NEXT_N];
while (p != NULL) {
switch (p->payload.notification.isan_type) {
case R_U_THERE:
case R_U_THERE_ACK:
case ISAKMP_N_CISCO_LOAD_BALANCE:
case PAYLOAD_MALFORMED:
case INVALID_MESSAGE_ID:
case IPSEC_RESPONDER_LIFETIME:
if (md->hdr.isa_xchg == ISAKMP_XCHG_INFO) {
break;
}
default:
if (st == NULL) {
DBG(DBG_CONTROL, DBG_log(
""ignoring informational payload %s, no corresponding state"",
enum_show(& ikev1_notify_names,
p->payload.notification.isan_type)));
} else {
loglog(RC_LOG_SERIOUS,
""ignoring informational payload %s, msgid=%08"" PRIx32 "", length=%d"",
enum_show(&ikev1_notify_names,
p->payload.notification.isan_type),
st->st_v1_msgid.id,
p->payload.notification.isan_length);
DBG_dump_pbs(&p->pbs);
}
}
if (DBGP(DBG_BASE)) {
DBG_dump(""info:"", p->pbs.cur,
pbs_left(&p->pbs));
}
p = p->next;
}
p = md->chain[ISAKMP_NEXT_D];
while (p != NULL) {
self_delete |= accept_delete(md, p);
if (DBGP(DBG_BASE)) {
DBG_dump(""del:"", p->pbs.cur,
pbs_left(&p->pbs));
}
if (md->st != st) {
pexpect(md->st == NULL);
dbg(""zapping ST as accept_delete() zapped MD.ST"");
st = md->st;
}
p = p->next;
}
p = md->chain[ISAKMP_NEXT_VID];
while (p != NULL) {
handle_vendorid(md, (char *)p->pbs.cur,
pbs_left(&p->pbs), FALSE);
p = p->next;
}
}
if (self_delete) {
accept_self_delete(md);
st = md->st;
}
pexpect(st == md->st);
statetime_t start = statetime_start(md->st);
complete_v1_state_transition(md, smc->processor(st, md));
statetime_stop(&start, ""%s()"", __func__);
}",[161],"An out-of-bounds buffer read flaw was found in the pluto daemon of libreswan from versions 3.27 till 3.31 where, an unauthenticated attacker could use this flaw to crash libreswan by sending specially-crafted IKEv1 Informational Exchange packets. The daemon respawns after the crash.",libreswan,CVE-2020-1763,CWE-125
8099,1679,"void CtcpParser::query(CoreNetwork *net, const QString &bufname, const QString &ctcpTag, const QString &message)
{
QList<QByteArray> params;
params << net->serverEncode(bufname) << lowLevelQuote(pack(net->serverEncode(ctcpTag), net->userEncode(bufname, message)));
static const char *splitter = "" .,-!?"";
int maxSplitPos = message.count();
int splitPos = maxSplitPos;
int overrun = net->userInputHandler()->lastParamOverrun(""PRIVMSG"", params);
if (overrun) {
maxSplitPos = message.count() - overrun -2;
splitPos = -1;
for (const char *splitChar = splitter; *splitChar != 0; splitChar++) {
splitPos = qMax(splitPos, message.lastIndexOf(*splitChar, maxSplitPos) + 1);
}
if (splitPos <= 0 || splitPos > maxSplitPos)
splitPos = maxSplitPos;
params = params.mid(0, 1) <<  lowLevelQuote(pack(net->serverEncode(ctcpTag), net->userEncode(bufname, message.left(splitPos))));
}
net->putCmd(""PRIVMSG"", params);
if (splitPos < message.count())
query(net, bufname, ctcpTag, message.mid(splitPos));
}","[3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 15, 16, 17, 19, 20, 21]","Quassel before 0.12-rc1 uses an incorrect data-type size when splitting a message, which allows remote attackers to cause a denial of service (crash) via a long CTCP query containing only multibyte characters.",quassel,CVE-2015-2778,CWE-399
8100,8479,"static void naludmx_queue_param_set(GF_NALUDmxCtx *ctx, char *data, u32 size, u32 ps_type, s32 ps_id)
{
GF_List *list = NULL, *alt_list = NULL;
GF_NALUFFParam *sl;
u32 i, count;
u32 crc = gf_crc_32(data, size);
if (ctx->codecid==GF_CODECID_HEVC) {
switch (ps_type) {
case GF_HEVC_NALU_VID_PARAM:
if (!ctx->vps) ctx->vps = gf_list_new();
list = ctx->vps;
break;
case GF_HEVC_NALU_SEQ_PARAM:
list = ctx->sps;
break;
case GF_HEVC_NALU_PIC_PARAM:
list = ctx->pps;
break;
default:
assert(0);
return;
}
} else if (ctx->codecid==GF_CODECID_VVC) {
switch (ps_type) {
case GF_VVC_NALU_VID_PARAM:
if (!ctx->vps) ctx->vps = gf_list_new();
list = ctx->vps;
break;
case GF_VVC_NALU_SEQ_PARAM:
list = ctx->sps;
break;
case GF_VVC_NALU_PIC_PARAM:
list = ctx->pps;
break;
case GF_VVC_NALU_DEC_PARAM:
if (!ctx->vvc_dci) ctx->vvc_dci = gf_list_new();
list = ctx->vvc_dci;
break;
case GF_VVC_NALU_APS_PREFIX:
if (!ctx->vvc_aps_pre) ctx->vvc_aps_pre = gf_list_new();
list = ctx->vvc_aps_pre;
break;
default:
assert(0);
return;
}
} else {
switch (ps_type) {
case GF_AVC_NALU_SVC_SUBSEQ_PARAM:
case GF_AVC_NALU_SEQ_PARAM:
list = ctx->sps;
break;
case GF_AVC_NALU_PIC_PARAM:
list = ctx->pps;
alt_list = ctx->pps_svc;
break;
case GF_AVC_NALU_SEQ_PARAM_EXT:
if (!ctx->sps_ext) ctx->sps_ext = gf_list_new();
list = ctx->sps_ext;
break;
default:
assert(0);
return;
}
}
sl = NULL;
count = gf_list_count(list);
for (i=0; i<count; i++) {
sl = gf_list_get(list, i);
if (sl->id != ps_id) {
sl = NULL;
continue;
}
if (sl->crc == crc) return;
break;
}
if (!sl && alt_list) {
count = gf_list_count(alt_list);
for (i=0; i<count; i++) {
sl = gf_list_get(alt_list, i);
if (sl->id != ps_id) {
sl = NULL;
continue;
}
if (sl->crc == crc) return;
break;
}
}
if (sl) {
sl->data = gf_realloc(sl->data, size);
memcpy(sl->data, data, size);
sl->size = size;
sl->crc = crc;
ctx->ps_modified = GF_TRUE;
return;
}
GF_SAFEALLOC(sl, GF_NALUFFParam);
if (!sl) return;
sl->data = gf_malloc(sizeof(char) * size);
if (!sl->data) {
gf_free(sl);
return;
}
memcpy(sl->data, data, size);
sl->size = size;
sl->id = ps_id;
sl->crc = crc;
ctx->ps_modified = GF_TRUE;
gf_list_add(list, sl);
}","[5, 6]","A Segmentation fault exists casued by null pointer dereference exists in Gpac through 1.0.1 via the naludmx_create_avc_decoder_config function in reframe_nalu.c when using mp4box, which causes a denial of service.",gpac,CVE-2021-40563,CWE-476
8113,8414,"static int adts_decode_extradata(AVFormatContext *s, ADTSContext *adts, const uint8_t *buf, int size)
{
GetBitContext gb;
PutBitContext pb;
MPEG4AudioConfig m4ac;
int off;
init_get_bits(&gb, buf, size * 8);
off = avpriv_mpeg4audio_get_config2(&m4ac, buf, size, 1, s);
if (off < 0)
return off;
skip_bits_long(&gb, off);
adts->objecttype        = m4ac.object_type - 1;
adts->sample_rate_index = m4ac.sampling_index;
adts->channel_conf      = m4ac.chan_config;
if (adts->objecttype > 3U) {
av_log(s, AV_LOG_ERROR, ""MPEG-4 AOT %d is not allowed in ADTS\n"", adts->objecttype+1);
return AVERROR_INVALIDDATA;
}
if (adts->sample_rate_index == 15) {
av_log(s, AV_LOG_ERROR, ""Escape sample rate index illegal in ADTS\n"");
return AVERROR_INVALIDDATA;
}
if (get_bits(&gb, 1)) {
av_log(s, AV_LOG_ERROR, ""960/120 MDCT window is not allowed in ADTS\n"");
return AVERROR_INVALIDDATA;
}
if (get_bits(&gb, 1)) {
av_log(s, AV_LOG_ERROR, ""Scalable configurations are not allowed in ADTS\n"");
return AVERROR_INVALIDDATA;
}
if (get_bits(&gb, 1)) {
av_log(s, AV_LOG_ERROR, ""Extension flag is not allowed in ADTS\n"");
return AVERROR_INVALIDDATA;
}
if (!adts->channel_conf) {
init_put_bits(&pb, adts->pce_data, MAX_PCE_SIZE);
put_bits(&pb, 3, 5);
adts->pce_size = (ff_copy_pce_data(&pb, &gb) + 3) / 8;
flush_put_bits(&pb);
}
adts->write_adts = 1;
return 0;
}","[6, 7]","adts_decode_extradata in libavformat/adtsenc.c in FFmpeg 4.4 does not check the init_get_bits return value, which is a necessary step because the second argument to init_get_bits can be crafted.",FFmpeg,CVE-2021-38171,CWE-252
8118,6317,"static int cbs_jpeg_split_fragment(CodedBitstreamContext *ctx,
CodedBitstreamFragment *frag,
int header)
{
AVBufferRef *data_ref;
uint8_t *data;
size_t data_size;
int unit, start, end, marker, next_start, next_marker;
int err, i, j, length;
if (frag->data_size < 4) {
return AVERROR_INVALIDDATA;
}
for (i = 0; i + 1 < frag->data_size && frag->data[i] != 0xff; i++);
if (i > 0) {
av_log(ctx->log_ctx, AV_LOG_WARNING, ""Discarding %d bytes at ""
""beginning of image.\n"", i);
}
for (++i; i + 1 < frag->data_size && frag->data[i] == 0xff; i++);
if (i + 1 >= frag->data_size && frag->data[i]) {
av_log(ctx->log_ctx, AV_LOG_ERROR, ""Invalid JPEG image: ""
""no SOI marker found.\n"");
return AVERROR_INVALIDDATA;
}
marker = frag->data[i];
if (marker != JPEG_MARKER_SOI) {
av_log(ctx->log_ctx, AV_LOG_ERROR, ""Invalid JPEG image: first ""
""marker is %02x, should be SOI.\n"", marker);
return AVERROR_INVALIDDATA;
}
for (++i; i + 1 < frag->data_size && frag->data[i] == 0xff; i++);
if (i + 1 >= frag->data_size) {
av_log(ctx->log_ctx, AV_LOG_ERROR, ""Invalid JPEG image: ""
""no image content found.\n"");
return AVERROR_INVALIDDATA;
}
marker = frag->data[i];
start  = i + 1;
for (unit = 0;; unit++) {
if (marker == JPEG_MARKER_EOI) {
break;
} else if (marker == JPEG_MARKER_SOS) {
for (i = start; i + 1 < frag->data_size; i++) {
if (frag->data[i] != 0xff)
continue;
end = i;
for (++i; i + 1 < frag->data_size &&
frag->data[i] == 0xff; i++);
if (i + 1 >= frag->data_size) {
next_marker = -1;
} else {
if (frag->data[i] == 0x00)
continue;
next_marker = frag->data[i];
next_start  = i + 1;
}
break;
}
} else {
i = start;
if (i + 2 > frag->data_size) {
av_log(ctx->log_ctx, AV_LOG_ERROR, ""Invalid JPEG image: ""
""truncated at %02x marker.\n"", marker);
return AVERROR_INVALIDDATA;
}
length = AV_RB16(frag->data + i);
if (i + length > frag->data_size) {
av_log(ctx->log_ctx, AV_LOG_ERROR, ""Invalid JPEG image: ""
""truncated at %02x marker segment.\n"", marker);
return AVERROR_INVALIDDATA;
}
end = start + length;
i = end;
if (frag->data[i] != 0xff) {
next_marker = -1;
} else {
for (++i; i + 1 < frag->data_size &&
frag->data[i] == 0xff; i++);
if (i + 1 >= frag->data_size) {
next_marker = -1;
} else {
next_marker = frag->data[i];
next_start  = i + 1;
}
}
}
if (marker == JPEG_MARKER_SOS) {
length = AV_RB16(frag->data + start);
data_ref = NULL;
data     = av_malloc(end - start +
AV_INPUT_BUFFER_PADDING_SIZE);
if (!data)
return AVERROR(ENOMEM);
memcpy(data, frag->data + start, length);
for (i = start + length, j = length; i < end; i++, j++) {
if (frag->data[i] == 0xff) {
while (frag->data[i] == 0xff)
++i;
data[j] = 0xff;
} else {
data[j] = frag->data[i];
}
}
data_size = j;
memset(data + data_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);
} else {
data      = frag->data + start;
data_size = end - start;
data_ref  = frag->data_ref;
}
err = ff_cbs_insert_unit_data(ctx, frag, unit, marker,
data, data_size, data_ref);
if (err < 0) {
if (!data_ref)
av_freep(&data);
return err;
}
if (next_marker == -1)
break;
marker = next_marker;
start  = next_start;
}
return 0;
}",[88],cbs_jpeg_split_fragment in libavcodec/cbs_jpeg.c in FFmpeg 4.1 and 4.2.2 has a heap-based buffer overflow during JPEG_MARKER_SOS handling because of a missing length check.,FFmpeg,CVE-2020-12284,CWE-787
8123,7748,"ProcessStartupPacket(Port *port, bool ssl_done, bool gss_done)
{
int32  len;
char    *buf;
ProtocolVersion proto;
MemoryContext oldcontext;
pq_startmsgread();
if (pq_getbytes((char *) &len, 1) == EOF)
{
return STATUS_ERROR;
}
if (pq_getbytes(((char *) &len) + 1, 3) == EOF)
{
if (!ssl_done && !gss_done)
ereport(COMMERROR,
(errcode(ERRCODE_PROTOCOL_VIOLATION),
errmsg(""incomplete startup packet"")));
return STATUS_ERROR;
}
len = pg_ntoh32(len);
len -= 4;
if (len < (int32) sizeof(ProtocolVersion) ||
len > MAX_STARTUP_PACKET_LENGTH)
{
ereport(COMMERROR,
(errcode(ERRCODE_PROTOCOL_VIOLATION),
errmsg(""invalid length of startup packet"")));
return STATUS_ERROR;
}
buf = palloc(len + 1);
buf[len] = '\0';
if (pq_getbytes(buf, len) == EOF)
{
ereport(COMMERROR,
(errcode(ERRCODE_PROTOCOL_VIOLATION),
errmsg(""incomplete startup packet"")));
return STATUS_ERROR;
}
pq_endmsgread();
port->proto = proto = pg_ntoh32(*((ProtocolVersion *) buf));
if (proto == CANCEL_REQUEST_CODE)
{
processCancelRequest(port, buf);
return STATUS_ERROR;
}
if (proto == NEGOTIATE_SSL_CODE && !ssl_done)
{
char  SSLok;
#ifdef USE_SSL
if (!LoadedSSL || IS_AF_UNIX(port->laddr.addr.ss_family))
SSLok = 'N';
else
SSLok = 'S';
#else
SSLok = 'N';
#endif
retry1:
if (send(port->sock, &SSLok, 1, 0) != 1)
{
if (errno == EINTR)
goto retry1;
ereport(COMMERROR,
(errcode_for_socket_access(),
errmsg(""failed to send SSL negotiation response: %m"")));
return STATUS_ERROR;
}
#ifdef USE_SSL
if (SSLok == 'S' && secure_open_server(port) == -1)
return STATUS_ERROR;
#endif
return ProcessStartupPacket(port, true, SSLok == 'S');
}
else if (proto == NEGOTIATE_GSS_CODE && !gss_done)
{
char  GSSok = 'N';
#ifdef ENABLE_GSS
if (!IS_AF_UNIX(port->laddr.addr.ss_family))
GSSok = 'G';
#endif
while (send(port->sock, &GSSok, 1, 0) != 1)
{
if (errno == EINTR)
continue;
ereport(COMMERROR,
(errcode_for_socket_access(),
errmsg(""failed to send GSSAPI negotiation response: %m"")));
return STATUS_ERROR;
}
#ifdef ENABLE_GSS
if (GSSok == 'G' && secure_open_gssapi(port) == -1)
return STATUS_ERROR;
#endif
return ProcessStartupPacket(port, GSSok == 'G', true);
}
FrontendProtocol = proto;
if (PG_PROTOCOL_MAJOR(proto) < PG_PROTOCOL_MAJOR(PG_PROTOCOL_EARLIEST) ||
PG_PROTOCOL_MAJOR(proto) > PG_PROTOCOL_MAJOR(PG_PROTOCOL_LATEST))
ereport(FATAL,
(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
errmsg(""unsupported frontend protocol %u.%u: server supports %u.0 to %u.%u"",
PG_PROTOCOL_MAJOR(proto), PG_PROTOCOL_MINOR(proto),
PG_PROTOCOL_MAJOR(PG_PROTOCOL_EARLIEST),
PG_PROTOCOL_MAJOR(PG_PROTOCOL_LATEST),
PG_PROTOCOL_MINOR(PG_PROTOCOL_LATEST))));
oldcontext = MemoryContextSwitchTo(TopMemoryContext);
{
int32  offset = sizeof(ProtocolVersion);
List    *unrecognized_protocol_options = NIL;
port->guc_options = NIL;
while (offset < len)
{
char    *nameptr = buf + offset;
int32  valoffset;
char    *valptr;
if (*nameptr == '\0')
break;
valoffset = offset + strlen(nameptr) + 1;
if (valoffset >= len)
break;
valptr = buf + valoffset;
if (strcmp(nameptr, ""database"") == 0)
port->database_name = pstrdup(valptr);
else if (strcmp(nameptr, ""user"") == 0)
port->user_name = pstrdup(valptr);
else if (strcmp(nameptr, ""options"") == 0)
port->cmdline_options = pstrdup(valptr);
else if (strcmp(nameptr, ""replication"") == 0)
{
if (strcmp(valptr, ""database"") == 0)
{
am_walsender = true;
am_db_walsender = true;
}
else if (!parse_bool(valptr, &am_walsender))
ereport(FATAL,
(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
errmsg(""invalid value for parameter \""%s\"": \""%s\"""",
""replication"",
valptr),
errhint(""Valid values are: \""false\"", 0, \""true\"", 1, \""database\""."")));
}
else if (strncmp(nameptr, ""_pq_."", 5) == 0)
{
unrecognized_protocol_options =
lappend(unrecognized_protocol_options, pstrdup(nameptr));
}
else
{
port->guc_options = lappend(port->guc_options,
pstrdup(nameptr));
port->guc_options = lappend(port->guc_options,
pstrdup(valptr));
if (strcmp(nameptr, ""application_name"") == 0)
{
char    *tmp_app_name = pstrdup(valptr);
pg_clean_ascii(tmp_app_name);
port->application_name = tmp_app_name;
}
}
offset = valoffset + strlen(valptr) + 1;
}
if (offset != len - 1)
ereport(FATAL,
(errcode(ERRCODE_PROTOCOL_VIOLATION),
errmsg(""invalid startup packet layout: expected terminator as last byte"")));
if (PG_PROTOCOL_MINOR(proto) > PG_PROTOCOL_MINOR(PG_PROTOCOL_LATEST) ||
unrecognized_protocol_options != NIL)
SendNegotiateProtocolVersion(unrecognized_protocol_options);
}
if (port->user_name == NULL || port->user_name[0] == '\0')
ereport(FATAL,
(errcode(ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION),
errmsg(""no PostgreSQL user name specified in startup packet"")));
if (port->database_name == NULL || port->database_name[0] == '\0')
port->database_name = pstrdup(port->user_name);
if (Db_user_namespace)
{
if (strchr(port->user_name, '@') ==
port->user_name + strlen(port->user_name) - 1)
*strchr(port->user_name, '@') = '\0';
else
{
port->user_name = psprintf(""%s@%s"", port->user_name, port->database_name);
}
}
if (strlen(port->database_name) >= NAMEDATALEN)
port->database_name[NAMEDATALEN - 1] = '\0';
if (strlen(port->user_name) >= NAMEDATALEN)
port->user_name[NAMEDATALEN - 1] = '\0';
if (am_walsender)
MyBackendType = B_WAL_SENDER;
else
MyBackendType = B_BACKEND;
if (am_walsender && !am_db_walsender)
port->database_name[0] = '\0';
MemoryContextSwitchTo(oldcontext);
switch (port->canAcceptConnections)
{
case CAC_STARTUP:
ereport(FATAL,
(errcode(ERRCODE_CANNOT_CONNECT_NOW),
errmsg(""the database system is starting up"")));
break;
case CAC_NOTCONSISTENT:
if (EnableHotStandby)
ereport(FATAL,
(errcode(ERRCODE_CANNOT_CONNECT_NOW),
errmsg(""the database system is not yet accepting connections""),
errdetail(""Consistent recovery state has not been yet reached."")));
else
ereport(FATAL,
(errcode(ERRCODE_CANNOT_CONNECT_NOW),
errmsg(""the database system is not accepting connections""),
errdetail(""Hot standby mode is disabled."")));
break;
case CAC_SHUTDOWN:
ereport(FATAL,
(errcode(ERRCODE_CANNOT_CONNECT_NOW),
errmsg(""the database system is shutting down"")));
break;
case CAC_RECOVERY:
ereport(FATAL,
(errcode(ERRCODE_CANNOT_CONNECT_NOW),
errmsg(""the database system is in recovery mode"")));
break;
case CAC_TOOMANY:
ereport(FATAL,
(errcode(ERRCODE_TOO_MANY_CONNECTIONS),
errmsg(""sorry, too many clients already"")));
break;
case CAC_SUPERUSER:
break;
case CAC_OK:
break;
}
return STATUS_OK;
}","[71, 93]","When the server is configured to use trust authentication with a clientcert requirement or to use cert authentication, a man-in-the-middle attacker can inject arbitrary SQL queries when a connection is first established, despite the use of SSL certificate verification and encryption.",postgres,CVE-2021-23214,CWE-89
8128,3430,"static int show_stream(WriterContext *w, AVFormatContext *fmt_ctx, int stream_idx, InputStream *ist, int in_program)
{
AVStream *stream = ist->st;
AVCodecParameters *par;
AVCodecContext *dec_ctx;
char val_str[128];
const char *s;
AVRational sar, dar;
AVBPrint pbuf;
const AVCodecDescriptor *cd;
int ret = 0;
const char *profile = NULL;
av_bprint_init(&pbuf, 1, AV_BPRINT_SIZE_UNLIMITED);
writer_print_section_header(w, in_program ? SECTION_ID_PROGRAM_STREAM : SECTION_ID_STREAM);
print_int(""index"", stream->index);
par     = stream->codecpar;
dec_ctx = ist->dec_ctx;
if (cd = avcodec_descriptor_get(par->codec_id)) {
print_str(""codec_name"", cd->name);
if (!do_bitexact) {
print_str(""codec_long_name"",
cd->long_name ? cd->long_name : ""unknown"");
}
} else {
print_str_opt(""codec_name"", ""unknown"");
if (!do_bitexact) {
print_str_opt(""codec_long_name"", ""unknown"");
}
}
if (!do_bitexact && (profile = avcodec_profile_name(par->codec_id, par->profile)))
print_str(""profile"", profile);
else {
if (par->profile != FF_PROFILE_UNKNOWN) {
char profile_num[12];
snprintf(profile_num, sizeof(profile_num), ""%d"", par->profile);
print_str(""profile"", profile_num);
} else
print_str_opt(""profile"", ""unknown"");
}
s = av_get_media_type_string(par->codec_type);
if (s) print_str    (""codec_type"", s);
else   print_str_opt(""codec_type"", ""unknown"");
#if FF_API_LAVF_AVCTX
if (dec_ctx)
print_q(""codec_time_base"", dec_ctx->time_base, '/');
#endif
print_str(""codec_tag_string"",    av_fourcc2str(par->codec_tag));
print_fmt(""codec_tag"", ""0x%04""PRIx32, par->codec_tag);
switch (par->codec_type) {
case AVMEDIA_TYPE_VIDEO:
print_int(""width"",        par->width);
print_int(""height"",       par->height);
if (dec_ctx) {
print_int(""coded_width"",  dec_ctx->coded_width);
print_int(""coded_height"", dec_ctx->coded_height);
}
print_int(""has_b_frames"", par->video_delay);
sar = av_guess_sample_aspect_ratio(fmt_ctx, stream, NULL);
if (sar.den) {
print_q(""sample_aspect_ratio"", sar, ':');
av_reduce(&dar.num, &dar.den,
par->width  * sar.num,
par->height * sar.den,
1024*1024);
print_q(""display_aspect_ratio"", dar, ':');
} else {
print_str_opt(""sample_aspect_ratio"", ""N/A"");
print_str_opt(""display_aspect_ratio"", ""N/A"");
}
s = av_get_pix_fmt_name(par->format);
if (s) print_str    (""pix_fmt"", s);
else   print_str_opt(""pix_fmt"", ""unknown"");
print_int(""level"",   par->level);
if (par->color_range != AVCOL_RANGE_UNSPECIFIED)
print_str    (""color_range"", av_color_range_name(par->color_range));
else
print_str_opt(""color_range"", ""N/A"");
if (par->color_space != AVCOL_SPC_UNSPECIFIED)
print_str(""color_space"", av_color_space_name(par->color_space));
else
print_str_opt(""color_space"", av_color_space_name(par->color_space));
if (par->color_trc != AVCOL_TRC_UNSPECIFIED)
print_str(""color_transfer"", av_color_transfer_name(par->color_trc));
else
print_str_opt(""color_transfer"", av_color_transfer_name(par->color_trc));
if (par->color_primaries != AVCOL_PRI_UNSPECIFIED)
print_str(""color_primaries"", av_color_primaries_name(par->color_primaries));
else
print_str_opt(""color_primaries"", av_color_primaries_name(par->color_primaries));
if (par->chroma_location != AVCHROMA_LOC_UNSPECIFIED)
print_str(""chroma_location"", av_chroma_location_name(par->chroma_location));
else
print_str_opt(""chroma_location"", av_chroma_location_name(par->chroma_location));
if (par->field_order == AV_FIELD_PROGRESSIVE)
print_str(""field_order"", ""progressive"");
else if (par->field_order == AV_FIELD_TT)
print_str(""field_order"", ""tt"");
else if (par->field_order == AV_FIELD_BB)
print_str(""field_order"", ""bb"");
else if (par->field_order == AV_FIELD_TB)
print_str(""field_order"", ""tb"");
else if (par->field_order == AV_FIELD_BT)
print_str(""field_order"", ""bt"");
else
print_str_opt(""field_order"", ""unknown"");
#if FF_API_PRIVATE_OPT
if (dec_ctx && dec_ctx->timecode_frame_start >= 0) {
char tcbuf[AV_TIMECODE_STR_SIZE];
av_timecode_make_mpeg_tc_string(tcbuf, dec_ctx->timecode_frame_start);
print_str(""timecode"", tcbuf);
} else {
print_str_opt(""timecode"", ""N/A"");
}
#endif
if (dec_ctx)
print_int(""refs"", dec_ctx->refs);
break;
case AVMEDIA_TYPE_AUDIO:
s = av_get_sample_fmt_name(par->format);
if (s) print_str    (""sample_fmt"", s);
else   print_str_opt(""sample_fmt"", ""unknown"");
print_val(""sample_rate"",     par->sample_rate, unit_hertz_str);
print_int(""channels"",        par->channels);
if (par->channel_layout) {
av_bprint_clear(&pbuf);
av_bprint_channel_layout(&pbuf, par->channels, par->channel_layout);
print_str    (""channel_layout"", pbuf.str);
} else {
print_str_opt(""channel_layout"", ""unknown"");
}
print_int(""bits_per_sample"", av_get_bits_per_sample(par->codec_id));
break;
case AVMEDIA_TYPE_SUBTITLE:
if (par->width)
print_int(""width"",       par->width);
else
print_str_opt(""width"",   ""N/A"");
if (par->height)
print_int(""height"",      par->height);
else
print_str_opt(""height"",  ""N/A"");
break;
}
if (dec_ctx && dec_ctx->codec && dec_ctx->codec->priv_class && show_private_data) {
const AVOption *opt = NULL;
while (opt = av_opt_next(dec_ctx->priv_data,opt)) {
uint8_t *str;
if (opt->flags) continue;
if (av_opt_get(dec_ctx->priv_data, opt->name, 0, &str) >= 0) {
print_str(opt->name, str);
av_free(str);
}
}
}
if (fmt_ctx->iformat->flags & AVFMT_SHOW_IDS) print_fmt    (""id"", ""0x%x"", stream->id);
else                                          print_str_opt(""id"", ""N/A"");
print_q(""r_frame_rate"",   stream->r_frame_rate,   '/');
print_q(""avg_frame_rate"", stream->avg_frame_rate, '/');
print_q(""time_base"",      stream->time_base,      '/');
print_ts  (""start_pts"",   stream->start_time);
print_time(""start_time"",  stream->start_time, &stream->time_base);
print_ts  (""duration_ts"", stream->duration);
print_time(""duration"",    stream->duration, &stream->time_base);
if (par->bit_rate > 0)     print_val    (""bit_rate"", par->bit_rate, unit_bit_per_second_str);
else                       print_str_opt(""bit_rate"", ""N/A"");
#if FF_API_LAVF_AVCTX
if (stream->codec->rc_max_rate > 0) print_val (""max_bit_rate"", stream->codec->rc_max_rate, unit_bit_per_second_str);
else                                print_str_opt(""max_bit_rate"", ""N/A"");
#endif
if (dec_ctx && dec_ctx->bits_per_raw_sample > 0) print_fmt(""bits_per_raw_sample"", ""%d"", dec_ctx->bits_per_raw_sample);
else                                             print_str_opt(""bits_per_raw_sample"", ""N/A"");
if (stream->nb_frames) print_fmt    (""nb_frames"", ""%""PRId64, stream->nb_frames);
else                   print_str_opt(""nb_frames"", ""N/A"");
if (nb_streams_frames[stream_idx])  print_fmt    (""nb_read_frames"", ""%""PRIu64, nb_streams_frames[stream_idx]);
else                                print_str_opt(""nb_read_frames"", ""N/A"");
if (nb_streams_packets[stream_idx]) print_fmt    (""nb_read_packets"", ""%""PRIu64, nb_streams_packets[stream_idx]);
else                                print_str_opt(""nb_read_packets"", ""N/A"");
if (do_show_data)
writer_print_data(w, ""extradata"", par->extradata,
par->extradata_size);
writer_print_data_hash(w, ""extradata_hash"", par->extradata,
par->extradata_size);
#define PRINT_DISPOSITION(flagname, name) do {                                \
        print_int(name, !!(stream->disposition & AV_DISPOSITION_##flagname)); \
    } while (0)
if (do_show_stream_disposition) {
writer_print_section_header(w, in_program ? SECTION_ID_PROGRAM_STREAM_DISPOSITION : SECTION_ID_STREAM_DISPOSITION);
PRINT_DISPOSITION(DEFAULT,          ""default"");
PRINT_DISPOSITION(DUB,              ""dub"");
PRINT_DISPOSITION(ORIGINAL,         ""original"");
PRINT_DISPOSITION(COMMENT,          ""comment"");
PRINT_DISPOSITION(LYRICS,           ""lyrics"");
PRINT_DISPOSITION(KARAOKE,          ""karaoke"");
PRINT_DISPOSITION(FORCED,           ""forced"");
PRINT_DISPOSITION(HEARING_IMPAIRED, ""hearing_impaired"");
PRINT_DISPOSITION(VISUAL_IMPAIRED,  ""visual_impaired"");
PRINT_DISPOSITION(CLEAN_EFFECTS,    ""clean_effects"");
PRINT_DISPOSITION(ATTACHED_PIC,     ""attached_pic"");
PRINT_DISPOSITION(TIMED_THUMBNAILS, ""timed_thumbnails"");
writer_print_section_footer(w);
}
if (do_show_stream_tags)
ret = show_tags(w, stream->metadata, in_program ? SECTION_ID_PROGRAM_STREAM_TAGS : SECTION_ID_STREAM_TAGS);
if (stream->nb_side_data) {
print_pkt_side_data(w, stream->codecpar, stream->side_data, stream->nb_side_data,
SECTION_ID_STREAM_SIDE_DATA_LIST,
SECTION_ID_STREAM_SIDE_DATA);
}
writer_print_section_footer(w);
av_bprint_finalize(&pbuf, NULL);
fflush(stdout);
return ret;
}","[86, 87, 88, 89]","The av_color_primaries_name function in libavutil/pixdesc.c in FFmpeg 3.3.3 may return a NULL pointer depending on a value contained in a file, but callers do not anticipate this, as demonstrated by the avcodec_string function in libavcodec/utils.c, leading to a NULL pointer dereference. (It is also conceivable that there is security relevance for a NULL pointer dereference in av_color_primaries_name calls within the ffprobe command-line program.)",FFmpeg,CVE-2017-14225,CWE-476
8140,5705,"size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)
{
mp4object *mp4 = (mp4object *)malloc(sizeof(mp4object));
if (mp4 == NULL) return 0;
memset(mp4, 0, sizeof(mp4object));
#ifdef _WINDOWS
fopen_s(&mp4->mediafp, filename, ""rb"");
#else
mp4->mediafp = fopen(filename, ""rb"");
#endif
if (mp4->mediafp)
{
uint32_t qttag, qtsize32, skip, type = 0, subtype = 0, num;
size_t len;
int32_t nest = 0;
uint64_t nestsize[MAX_NEST_LEVEL] = { 0 };
uint64_t lastsize = 0, qtsize;
do
{
len = fread(&qtsize32, 1, 4, mp4->mediafp);
len += fread(&qttag, 1, 4, mp4->mediafp);
if (len == 8)
{
if (!VALID_FOURCC(qttag))
{
LONGSEEK(mp4->mediafp, lastsize - 8 - 8, SEEK_CUR);
NESTSIZE(lastsize - 8);
continue;
}
qtsize32 = BYTESWAP32(qtsize32);
if (qtsize32 == 1)
{
fread(&qtsize, 1, 8, mp4->mediafp);
qtsize = BYTESWAP64(qtsize) - 8;
}
else
qtsize = qtsize32;
nest++;
if (qtsize < 8) break;
if (nest >= MAX_NEST_LEVEL) break;
nestsize[nest] = qtsize;
lastsize = qtsize;
#if PRINT_MP4_STRUCTURE	
for (int i = 1; i < nest; i++) printf(""    "");
printf(""%c%c%c%c (%lld)\n"", (qttag & 0xff), ((qttag >> 8) & 0xff), ((qttag >> 16) & 0xff), ((qttag >> 24) & 0xff), qtsize);
if (qttag == MAKEID('m', 'd', 'a', 't') ||
qttag == MAKEID('f', 't', 'y', 'p') ||
qttag == MAKEID('u', 'd', 't', 'a'))
{
LONGSEEK(mediafp, qtsize - 8, SEEK_CUR);
NESTSIZE(qtsize);
continue;
}
#else
if (qttag != MAKEID('m', 'o', 'o', 'v') &&
qttag != MAKEID('m', 'v', 'h', 'd') &&
qttag != MAKEID('t', 'r', 'a', 'k') &&
qttag != MAKEID('m', 'd', 'i', 'a') &&
qttag != MAKEID('m', 'd', 'h', 'd') &&
qttag != MAKEID('m', 'i', 'n', 'f') &&
qttag != MAKEID('g', 'm', 'i', 'n') &&
qttag != MAKEID('d', 'i', 'n', 'f') &&
qttag != MAKEID('a', 'l', 'i', 's') &&
qttag != MAKEID('s', 't', 's', 'd') &&
qttag != MAKEID('a', 'l', 'i', 's') &&
qttag != MAKEID('a', 'l', 'i', 's') &&
qttag != MAKEID('s', 't', 'b', 'l') &&
qttag != MAKEID('s', 't', 't', 's') &&
qttag != MAKEID('s', 't', 's', 'c') &&
qttag != MAKEID('s', 't', 's', 'z') &&
qttag != MAKEID('s', 't', 'c', 'o') &&
qttag != MAKEID('c', 'o', '6', '4') &&
qttag != MAKEID('h', 'd', 'l', 'r'))
{
LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
NESTSIZE(qtsize);
}
else
#endif
if (qttag == MAKEID('m', 'v', 'h', 'd'))
{
len = fread(&skip, 1, 4, mp4->mediafp);
len += fread(&skip, 1, 4, mp4->mediafp);
len += fread(&skip, 1, 4, mp4->mediafp);
len += fread(&mp4->clockdemon, 1, 4, mp4->mediafp); mp4->clockdemon = BYTESWAP32(mp4->clockdemon);
len += fread(&mp4->clockcount, 1, 4, mp4->mediafp); mp4->clockcount = BYTESWAP32(mp4->clockcount);
LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);
NESTSIZE(qtsize);
}
else if (qttag == MAKEID('m', 'd', 'h', 'd'))
{
media_header md;
len = fread(&md, 1, sizeof(md), mp4->mediafp);
if (len == sizeof(md))
{
md.creation_time = BYTESWAP32(md.creation_time);
md.modification_time = BYTESWAP32(md.modification_time);
md.time_scale = BYTESWAP32(md.time_scale);
md.duration = BYTESWAP32(md.duration);
mp4->trak_clockdemon = md.time_scale;
mp4->trak_clockcount = md.duration;
if (mp4->videolength == 0.0)
{
mp4->videolength = (float)((double)mp4->trak_clockcount / (double)mp4->trak_clockdemon);
}
}
LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);
NESTSIZE(qtsize);
}
else if (qttag == MAKEID('h', 'd', 'l', 'r'))
{
uint32_t temp;
len = fread(&skip, 1, 4, mp4->mediafp);
len += fread(&skip, 1, 4, mp4->mediafp);
len += fread(&temp, 1, 4, mp4->mediafp);
if (temp != MAKEID('a', 'l', 'i', 's'))
type = temp;
LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);
NESTSIZE(qtsize);
}
else if (qttag == MAKEID('s', 't', 's', 'd'))
{
if (type == traktype)
{
len = fread(&skip, 1, 4, mp4->mediafp);
len += fread(&skip, 1, 4, mp4->mediafp);
len += fread(&skip, 1, 4, mp4->mediafp);
len += fread(&subtype, 1, 4, mp4->mediafp);
if (len == 16)
{
if (subtype != traksubtype)
{
type = 0;
}
}
LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);
}
else
LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
NESTSIZE(qtsize);
}
else if (qttag == MAKEID('s', 't', 's', 'c'))
{
if (type == traktype)
{
len = fread(&skip, 1, 4, mp4->mediafp);
len += fread(&num, 1, 4, mp4->mediafp);
num = BYTESWAP32(num);
if (num * 12 <= qtsize - 8 - len)
{
mp4->metastsc_count = num;
if (mp4->metastsc) free(mp4->metastsc);
mp4->metastsc = (SampleToChunk *)malloc(num * 12);
if (mp4->metastsc)
{
uint32_t total_stsc = num;
len += fread(mp4->metastsc, 1, num * sizeof(SampleToChunk), mp4->mediafp);
do
{
num--;
mp4->metastsc[num].chunk_num = BYTESWAP32(mp4->metastsc[num].chunk_num);
mp4->metastsc[num].samples = BYTESWAP32(mp4->metastsc[num].samples);
mp4->metastsc[num].id = BYTESWAP32(mp4->metastsc[num].id);
} while (num > 0);
}
if (mp4->metastsc_count == 1 && mp4->metastsc[0].samples == 1)
{
if (mp4->metastsc) free(mp4->metastsc);
mp4->metastsc = NULL;
mp4->metastsc_count = 0;
}
}
LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);
}
else
LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
NESTSIZE(qtsize);
}
else if (qttag == MAKEID('s', 't', 's', 'z'))
{
if (type == traktype)
{
uint32_t equalsamplesize;
len = fread(&skip, 1, 4, mp4->mediafp);
len += fread(&equalsamplesize, 1, 4, mp4->mediafp);
len += fread(&num, 1, 4, mp4->mediafp);
num = BYTESWAP32(num);
if (num * 4 <= qtsize - 8 - len)
{
mp4->metasize_count = num;
if (mp4->metasizes) free(mp4->metasizes);
mp4->metasizes = (uint32_t *)malloc(num * 4);
if (mp4->metasizes)
{
if (equalsamplesize == 0)
{
len += fread(mp4->metasizes, 1, num * 4, mp4->mediafp);
do
{
num--;
mp4->metasizes[num] = BYTESWAP32(mp4->metasizes[num]);
} while (num > 0);
}
else
{
equalsamplesize = BYTESWAP32(equalsamplesize);
do
{
num--;
mp4->metasizes[num] = equalsamplesize;
} while (num > 0);
}
}
}
LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);
}
else
LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
NESTSIZE(qtsize);
}
else if (qttag == MAKEID('s', 't', 'c', 'o'))
{
if (type == traktype)
{
len = fread(&skip, 1, 4, mp4->mediafp);
len += fread(&num, 1, 4, mp4->mediafp);
num = BYTESWAP32(num);
if (num * 4 <= qtsize - 8 - len)
{
if (mp4->metastsc_count > 0 && num != mp4->metasize_count)
{
mp4->indexcount = mp4->metasize_count;
if (mp4->metaoffsets) free(mp4->metaoffsets);
mp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);
if (mp4->metaoffsets)
{
uint32_t *metaoffsets32 = NULL;
metaoffsets32 = (uint32_t *)malloc(num * 4);
if (metaoffsets32)
{
uint64_t fileoffset = 0;
int stsc_pos = 0;
int stco_pos = 0;
int repeat = 1;
len += fread(metaoffsets32, 1, num * 4, mp4->mediafp);
do
{
num--;
metaoffsets32[num] = BYTESWAP32(metaoffsets32[num]);
} while (num > 0);
mp4->metaoffsets[0] = fileoffset = metaoffsets32[stco_pos];
num = 1;
while (num < mp4->metasize_count)
{
if (stsc_pos + 1 < (int)mp4->metastsc_count && num == stsc_pos)
{
stco_pos++; stsc_pos++;
fileoffset = (uint64_t)metaoffsets32[stco_pos];
repeat = 1;
}
else if (repeat == mp4->metastsc[stsc_pos].samples)
{
stco_pos++;
fileoffset = (uint64_t)metaoffsets32[stco_pos];
repeat = 1;
}
else
{
fileoffset += (uint64_t)mp4->metasizes[num - 1];
repeat++;
}
mp4->metaoffsets[num] = fileoffset;
num++;
}
if (mp4->metastsc) free(mp4->metastsc);
mp4->metastsc = NULL;
mp4->metastsc_count = 0;
free(metaoffsets32);
}
}
}
else
{
mp4->indexcount = num;
if (mp4->metaoffsets) free(mp4->metaoffsets);
mp4->metaoffsets = (uint64_t *)malloc(num * 8);
if (mp4->metaoffsets)
{
uint32_t *metaoffsets32 = NULL;
metaoffsets32 = (uint32_t *)malloc(num * 4);
if (metaoffsets32)
{
size_t readlen = fread(metaoffsets32, 1, num * 4, mp4->mediafp);
len += readlen;
do
{
num--;
mp4->metaoffsets[num] = BYTESWAP32(metaoffsets32[num]);
} while (num > 0);
free(metaoffsets32);
}
}
}
}
LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);
}
else
LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
NESTSIZE(qtsize);
}
else if (qttag == MAKEID('c', 'o', '6', '4'))
{
if (type == traktype)
{
len = fread(&skip, 1, 4, mp4->mediafp);
len += fread(&num, 1, 4, mp4->mediafp);
num = BYTESWAP32(num);
if (num * 8 <= qtsize - 8 - len)
{
if (mp4->metastsc_count > 0 && num != mp4->metasize_count)
{
mp4->indexcount = mp4->metasize_count;
if (mp4->metaoffsets) free(mp4->metaoffsets);
mp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);
if (mp4->metaoffsets)
{
uint64_t *metaoffsets64 = NULL;
metaoffsets64 = (uint64_t *)malloc(num * 8);
if (metaoffsets64)
{
uint64_t fileoffset = 0;
int stsc_pos = 0;
int stco_pos = 0;
len += fread(metaoffsets64, 1, num * 8, mp4->mediafp);
do
{
num--;
metaoffsets64[num] = BYTESWAP64(metaoffsets64[num]);
} while (num > 0);
fileoffset = metaoffsets64[0];
mp4->metaoffsets[0] = fileoffset;
num = 1;
while (num < mp4->metasize_count)
{
if (num != mp4->metastsc[stsc_pos].chunk_num - 1 && 0 == (num - (mp4->metastsc[stsc_pos].chunk_num - 1)) % mp4->metastsc[stsc_pos].samples)
{
stco_pos++;
fileoffset = (uint64_t)metaoffsets64[stco_pos];
}
else
{
fileoffset += (uint64_t)mp4->metasizes[num - 1];
}
mp4->metaoffsets[num] = fileoffset;
num++;
}
if (mp4->metastsc) free(mp4->metastsc);
mp4->metastsc = NULL;
mp4->metastsc_count = 0;
free(metaoffsets64);
}
}
}
else
{
mp4->indexcount = num;
if (mp4->metaoffsets) free(mp4->metaoffsets);
mp4->metaoffsets = (uint64_t *)malloc(num * 8);
if (mp4->metaoffsets)
{
len += fread(mp4->metaoffsets, 1, num * 8, mp4->mediafp);
do
{
num--;
mp4->metaoffsets[num] = BYTESWAP64(mp4->metaoffsets[num]);
} while (num > 0);
}
}
}
LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);
}
else
LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
NESTSIZE(qtsize);
}
else if (qttag == MAKEID('s', 't', 't', 's'))
{
if (type == traktype)
{
uint32_t totaldur = 0, samples = 0;
int32_t entries = 0;
len = fread(&skip, 1, 4, mp4->mediafp);
len += fread(&num, 1, 4, mp4->mediafp);
num = BYTESWAP32(num);
if (num * 8 <= qtsize - 8 - len)
{
entries = num;
mp4->meta_clockdemon = mp4->trak_clockdemon;
mp4->meta_clockcount = mp4->trak_clockcount;
while (entries > 0)
{
int32_t samplecount;
int32_t duration;
len += fread(&samplecount, 1, 4, mp4->mediafp);
samplecount = BYTESWAP32(samplecount);
len += fread(&duration, 1, 4, mp4->mediafp);
duration = BYTESWAP32(duration);
samples += samplecount;
entries--;
totaldur += duration;
mp4->metadatalength += (double)((double)samplecount * (double)duration / (double)mp4->meta_clockdemon);
}
mp4->basemetadataduration = mp4->metadatalength * (double)mp4->meta_clockdemon / (double)samples;
}
LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR);
}
else
LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
NESTSIZE(qtsize);
}
else
{
NESTSIZE(8);
}
}
else
{
break;
}
} while (len > 0);
}
else
{
free(mp4);
mp4 = NULL;
}
return (size_t)mp4;
}","[6, 18, 22, 26, 27, 28, 33, 48, 50, 65, 66, 75, 87, 107, 116, 118, 136, 139, 153, 154, 156, 157, 158, 160, 161, 162, 163, 164, 166, 168, 169, 170, 173, 176, 192, 193, 195, 197, 198, 200, 201, 202, 204, 206, 207, 209, 210, 211, 215, 218, 230, 232, 234, 235, 237, 238, 239, 241, 242, 243, 244, 245, 246, 248, 249, 250, 251, 252, 253, 255, 257, 258, 259, 261, 263, 264, 265, 267, 269, 270, 272, 273, 275, 276, 277, 278, 282, 286, 287, 289, 290, 291, 293, 294, 295, 297, 298, 299, 300, 305, 308, 318, 324, 325, 327, 328, 329, 331, 332, 333, 334, 335, 337, 338, 339, 340, 341, 342, 343, 345, 347, 348, 350, 352, 354, 355, 357, 358, 359, 360, 364, 380, 383, 415, 418, 432]",GoPro GPMF-parser 1.2.2 has a heap-based buffer over-read (4 bytes) in GPMF_Next in GPMF_parser.c.,gpmf-parser,CVE-2019-15146,CWE-125
8154,6099,"static int flattenSubquery(
Parse *pParse,
Select *p,
int iFrom,
int isAgg
){
const char *zSavedAuthContext = pParse->zAuthContext;
Select *pParent;
Select *pSub;
Select *pSub1;
SrcList *pSrc;
SrcList *pSubSrc;
int iParent;
int iNewParent = -1;
int isLeftJoin = 0;
int i;
Expr *pWhere;
struct SrcList_item *pSubitem;
sqlite3 *db = pParse->db;
assert( p!=0 );
assert( p->pPrior==0 );
if( OptimizationDisabled(db, SQLITE_QueryFlattener) ) return 0;
pSrc = p->pSrc;
assert( pSrc && iFrom>=0 && iFrom<pSrc->nSrc );
pSubitem = &pSrc->a[iFrom];
iParent = pSubitem->iCursor;
pSub = pSubitem->pSelect;
assert( pSub!=0 );
#ifndef SQLITE_OMIT_WINDOWFUNC
if( p->pWin || pSub->pWin ) return 0;
#endif
pSubSrc = pSub->pSrc;
assert( pSubSrc );
if( pSub->pLimit && p->pLimit ) return 0;
if( pSub->pLimit && pSub->pLimit->pRight ) return 0;
if( (p->selFlags & SF_Compound)!=0 && pSub->pLimit ){
return 0;
}
if( pSubSrc->nSrc==0 ) return 0;
if( pSub->selFlags & SF_Distinct ) return 0;
if( pSub->pLimit && (pSrc->nSrc>1 || isAgg) ){
return 0;
}
if( p->pOrderBy && pSub->pOrderBy ){
return 0;
}
if( isAgg && pSub->pOrderBy ) return 0;
if( pSub->pLimit && p->pWhere ) return 0;
if( pSub->pLimit && (p->selFlags & SF_Distinct)!=0 ){
return 0;
}
if( pSub->selFlags & (SF_Recursive) ){
return 0;
}
if( (pSubitem->fg.jointype & JT_OUTER)!=0 ){
isLeftJoin = 1;
if( pSubSrc->nSrc>1 || isAgg || IsVirtual(pSubSrc->a[0].pTab) ){
return 0;
}
}
#ifdef SQLITE_EXTRA_IFNULLROW
else if( iFrom>0 && !isAgg ){
isLeftJoin = -1;
}
#endif
if( pSub->pPrior ){
if( pSub->pOrderBy ){
return 0;
}
if( isAgg || (p->selFlags & SF_Distinct)!=0 || pSrc->nSrc!=1 ){
return 0;
}
for(pSub1=pSub; pSub1; pSub1=pSub1->pPrior){
testcase( (pSub1->selFlags & (SF_Distinct|SF_Aggregate))==SF_Distinct );
testcase( (pSub1->selFlags & (SF_Distinct|SF_Aggregate))==SF_Aggregate );
assert( pSub->pSrc!=0 );
assert( pSub->pEList->nExpr==pSub1->pEList->nExpr );
if( (pSub1->selFlags & (SF_Distinct|SF_Aggregate))!=0
|| (pSub1->pPrior && pSub1->op!=TK_ALL)
|| pSub1->pSrc->nSrc<1
){
return 0;
}
testcase( pSub1->pSrc->nSrc>1 );
}
if( p->pOrderBy ){
int ii;
for(ii=0; ii<p->pOrderBy->nExpr; ii++){
if( p->pOrderBy->a[ii].u.x.iOrderByCol==0 ) return 0;
}
}
}
assert( (p->selFlags & SF_Recursive)==0 || pSub->pPrior==0 );
SELECTTRACE(1,pParse,p,(""flatten %u.%p from term %d\n"",
pSub->selId, pSub, iFrom));
pParse->zAuthContext = pSubitem->zName;
TESTONLY(i =) sqlite3AuthCheck(pParse, SQLITE_SELECT, 0, 0, 0);
testcase( i==SQLITE_DENY );
pParse->zAuthContext = zSavedAuthContext;
for(pSub=pSub->pPrior; pSub; pSub=pSub->pPrior){
Select *pNew;
ExprList *pOrderBy = p->pOrderBy;
Expr *pLimit = p->pLimit;
Select *pPrior = p->pPrior;
p->pOrderBy = 0;
p->pSrc = 0;
p->pPrior = 0;
p->pLimit = 0;
pNew = sqlite3SelectDup(db, p, 0);
p->pLimit = pLimit;
p->pOrderBy = pOrderBy;
p->pSrc = pSrc;
p->op = TK_ALL;
if( pNew==0 ){
p->pPrior = pPrior;
}else{
pNew->pPrior = pPrior;
if( pPrior ) pPrior->pNext = pNew;
pNew->pNext = p;
p->pPrior = pNew;
SELECTTRACE(2,pParse,p,(""compound-subquery flattener""
"" creates %u as peer\n"",pNew->selId));
}
if( db->mallocFailed ) return 1;
}
pSub = pSub1 = pSubitem->pSelect;
sqlite3DbFree(db, pSubitem->zDatabase);
sqlite3DbFree(db, pSubitem->zName);
sqlite3DbFree(db, pSubitem->zAlias);
pSubitem->zDatabase = 0;
pSubitem->zName = 0;
pSubitem->zAlias = 0;
pSubitem->pSelect = 0;
if( ALWAYS(pSubitem->pTab!=0) ){
Table *pTabToDel = pSubitem->pTab;
if( pTabToDel->nTabRef==1 ){
Parse *pToplevel = sqlite3ParseToplevel(pParse);
pTabToDel->pNextZombie = pToplevel->pZombieTab;
pToplevel->pZombieTab = pTabToDel;
}else{
pTabToDel->nTabRef--;
}
pSubitem->pTab = 0;
}
for(pParent=p; pParent; pParent=pParent->pPrior, pSub=pSub->pPrior){
int nSubSrc;
u8 jointype = 0;
assert( pSub!=0 );
pSubSrc = pSub->pSrc;
nSubSrc = pSubSrc->nSrc;
pSrc = pParent->pSrc;
if( pSrc ){
assert( pParent==p );
jointype = pSubitem->fg.jointype;
}else{
assert( pParent!=p );
pSrc = sqlite3SrcListAppend(pParse, 0, 0, 0);
if( pSrc==0 ) break;
pParent->pSrc = pSrc;
}
if( nSubSrc>1 ){
pSrc = sqlite3SrcListEnlarge(pParse, pSrc, nSubSrc-1,iFrom+1);
if( pSrc==0 ) break;
pParent->pSrc = pSrc;
}
for(i=0; i<nSubSrc; i++){
sqlite3IdListDelete(db, pSrc->a[i+iFrom].pUsing);
assert( pSrc->a[i+iFrom].fg.isTabFunc==0 );
pSrc->a[i+iFrom] = pSubSrc->a[i];
iNewParent = pSubSrc->a[i].iCursor;
memset(&pSubSrc->a[i], 0, sizeof(pSubSrc->a[i]));
}
pSrc->a[iFrom].fg.jointype = jointype;
if( pSub->pOrderBy ){
ExprList *pOrderBy = pSub->pOrderBy;
for(i=0; i<pOrderBy->nExpr; i++){
pOrderBy->a[i].u.x.iOrderByCol = 0;
}
assert( pParent->pOrderBy==0 );
pParent->pOrderBy = pOrderBy;
pSub->pOrderBy = 0;
}
pWhere = pSub->pWhere;
pSub->pWhere = 0;
if( isLeftJoin>0 ){
sqlite3SetJoinExpr(pWhere, iNewParent);
}
pParent->pWhere = sqlite3ExprAnd(pParse, pWhere, pParent->pWhere);
if( db->mallocFailed==0 ){
SubstContext x;
x.pParse = pParse;
x.iTable = iParent;
x.iNewTable = iNewParent;
x.isLeftJoin = isLeftJoin;
x.pEList = pSub->pEList;
substSelect(&x, pParent, 0);
}
pParent->selFlags |= pSub->selFlags & SF_Compound;
assert( (pSub->selFlags & SF_Distinct)==0 );
if( pSub->pLimit ){
pParent->pLimit = pSub->pLimit;
pSub->pLimit = 0;
}
}
sqlite3SelectDelete(db, pSub1);
#if SELECTTRACE_ENABLED
if( sqlite3SelectTrace & 0x100 ){
SELECTTRACE(0x100,pParse,p,(""After flattening:\n""));
sqlite3TreeViewSelect(0, p, 0);
}
#endif
return 1;
}",[57],flattenSubquery in select.c in SQLite 3.30.1 mishandles certain uses of SELECT DISTINCT involving a LEFT JOIN in which the right-hand side is a view. This can cause a NULL pointer dereference (or incorrect results).,sqlite,CVE-2019-19923,CWE-476
8157,7996,"int PackLinuxElf64::canUnpack()
{
if (super::canUnpack()) {
return true;
}
if (Elf64_Ehdr::ET_DYN==get_te16(&ehdri.e_type)) {
PackLinuxElf64help1(fi);
Elf64_Phdr const *phdr = phdri, *last_LOAD = nullptr;
for (unsigned j = 0; j < e_phnum; ++phdr, ++j)
if (Elf64_Phdr::PT_LOAD==get_te32(&phdr->p_type)) {
last_LOAD = phdr;
}
if (!last_LOAD)
return false;
off_t offset = get_te64(&last_LOAD->p_offset);
unsigned filesz = get_te64(&last_LOAD->p_filesz);
fi->seek(filesz+offset, SEEK_SET);
MemBuffer buf(32 + sizeof(overlay_offset));
fi->readx(buf, buf.getSize());
return PackUnix::find_overlay_offset(buf);
}
return false;
}","[3, 4, 20]","Null pointer dereference was found in upx PackLinuxElf::canUnpack() in p_lx_elf.cpp,in version UPX 4.0.0. That allow attackers to execute arbitrary code and cause a denial of service via a crafted file.",upx,CVE-2021-30500,CWE-476
8172,5564,"static __forceinline void draw_line(float *output, int x0, int y0, int x1, int y1, int n)
{
int dy = y1 - y0;
int adx = x1 - x0;
int ady = abs(dy);
int base;
int x=x0,y=y0;
int err = 0;
int sy;
#ifdef STB_VORBIS_DIVIDE_TABLE
if (adx < DIVTAB_DENOM && ady < DIVTAB_NUMER) {
if (dy < 0) {
base = -integer_divide_table[ady][adx];
sy = base-1;
} else {
base =  integer_divide_table[ady][adx];
sy = base+1;
}
} else {
base = dy / adx;
if (dy < 0)
sy = base - 1;
else
sy = base+1;
}
#else
base = dy / adx;
if (dy < 0)
sy = base - 1;
else
sy = base+1;
#endif
ady -= abs(base) * adx;
if (x1 > n) x1 = n;
if (x < x1) {
LINE_OP(output[x], inverse_db_table[y]);
for (++x; x < x1; ++x) {
err += ady;
if (err >= adx) {
err -= adx;
y += sy;
} else
y += base;
LINE_OP(output[x], inverse_db_table[y]);
}
}
}","[36, 44]",A heap buffer overflow in the start_decoder function in stb_vorbis through 2019-03-04 allows an attacker to cause a denial of service or execute arbitrary code by opening a crafted Ogg Vorbis file.,stb,CVE-2019-13217,CWE-787
8177,8011,"GF_RTPHinter *gf_hinter_track_new(GF_ISOFile *file, u32 TrackNum,
u32 Path_MTU, u32 max_ptime, u32 default_rtp_rate, u32 flags, u8 PayloadID,
Bool copy_media, u32 InterleaveGroupID, u8 InterleaveGroupPriority, GF_Err *e)
{
GF_SLConfig my_sl;
u32 descIndex, MinSize, MaxSize, avgTS, streamType, codecid, const_dur, nb_ch, maxDTSDelta;
u8 OfficialPayloadID;
u32 TrackMediaSubType, TrackMediaType, hintType, nbEdts, required_rate, force_dts_delta, avc_nalu_size, PL_ID, bandwidth, IV_length, KI_length;
const char *url, *urn;
char *mpeg4mode;
Bool is_crypted, has_mpeg4_mapping;
GF_RTPHinter *tmp;
GF_ESD *esd;
*e = GF_BAD_PARAM;
if (!file || !TrackNum || !gf_isom_get_track_id(file, TrackNum)) return NULL;
if (!gf_isom_get_sample_count(file, TrackNum)) {
*e = GF_OK;
return NULL;
}
*e = GF_NOT_SUPPORTED;
nbEdts = gf_isom_get_edits_count(file, TrackNum);
if (nbEdts>1) {
u64 et, sd, mt;
GF_ISOEditType em;
gf_isom_get_edit(file, TrackNum, 1, &et, &sd, &mt, &em);
if ((nbEdts>2) || (em!=GF_ISOM_EDIT_EMPTY)) {
GF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (""[rtp hinter] Cannot hint track whith EditList\n""));
return NULL;
}
}
if (nbEdts) gf_isom_remove_edits(file, TrackNum);
if (!gf_isom_is_track_enabled(file, TrackNum)) return NULL;
PL_ID = 0;
OfficialPayloadID = 0;
force_dts_delta = 0;
streamType = 0;
mpeg4mode = NULL;
required_rate = 0;
is_crypted = 0;
IV_length = KI_length = 0;
codecid = 0;
nb_ch = 0;
avc_nalu_size = 0;
has_mpeg4_mapping = 1;
const_dur = 0;
bandwidth=0;
TrackMediaType = gf_isom_get_media_type(file, TrackNum);
if (!default_rtp_rate) default_rtp_rate = 90000;
if ( (TrackMediaType==GF_ISOM_MEDIA_TEXT) || (TrackMediaType==GF_ISOM_MEDIA_SUBT)) {
hintType = GF_RTP_PAYT_3GPP_TEXT;
codecid = GF_CODECID_TEXT_MPEG4;
streamType = GF_STREAM_TEXT;
PL_ID = 0x10;
} else {
if (gf_isom_get_sample_description_count(file, TrackNum) > 1) return NULL;
TrackMediaSubType = gf_isom_get_media_subtype(file, TrackNum, 1);
switch (TrackMediaSubType) {
case GF_ISOM_SUBTYPE_MPEG4_CRYP:
is_crypted = 1;
case GF_ISOM_SUBTYPE_MPEG4:
esd = gf_isom_get_esd(file, TrackNum, 1);
hintType = GF_RTP_PAYT_MPEG4;
if (esd && esd->decoderConfig) {
streamType = esd->decoderConfig->streamType;
codecid = esd->decoderConfig->objectTypeIndication;
if (esd->URLString) hintType = 0;
if ((streamType==GF_STREAM_AUDIO)
&& esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data
&& ((codecid==GF_CODECID_AAC_MPEG4) || (codecid==GF_CODECID_AAC_MPEG2_MP) || (codecid==GF_CODECID_AAC_MPEG2_LCP) || (codecid==GF_CODECID_AAC_MPEG2_SSRP)) ) {
u32 sample_rate;
GF_M4ADecSpecInfo a_cfg;
gf_m4a_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &a_cfg);
nb_ch = a_cfg.nb_chan;
sample_rate = a_cfg.base_sr;
PL_ID = a_cfg.audioPL;
switch (a_cfg.base_object_type) {
case GF_M4A_AAC_MAIN:
case GF_M4A_AAC_LC:
if (flags & GP_RTP_PCK_USE_LATM_AAC) {
hintType = GF_RTP_PAYT_LATM;
break;
}
case GF_M4A_AAC_SBR:
case GF_M4A_AAC_PS:
case GF_M4A_AAC_LTP:
case GF_M4A_AAC_SCALABLE:
case GF_M4A_ER_AAC_LC:
case GF_M4A_ER_AAC_LTP:
case GF_M4A_ER_AAC_SCALABLE:
mpeg4mode = ""AAC"";
break;
case GF_M4A_CELP:
case GF_M4A_ER_CELP:
mpeg4mode = ""CELP"";
break;
}
required_rate = sample_rate;
}
else if ((streamType==GF_STREAM_AUDIO) && ((codecid==GF_CODECID_MPEG2_PART3) || (codecid==GF_CODECID_MPEG_AUDIO))) {
GF_ISOSample *samp = NULL;
if (!is_crypted)
samp = gf_isom_get_sample(file, TrackNum, 1, NULL);
if (samp && (samp->dataLength>3)) {
u32 hdr = GF_4CC((u32)samp->data[0], (u8)samp->data[1], (u8)samp->data[2], (u8)samp->data[3]);
nb_ch = gf_mp3_num_channels(hdr);
hintType = GF_RTP_PAYT_MPEG12_AUDIO;
OfficialPayloadID = 14;
required_rate = 90000;
}
else {
u32 sample_rate;
gf_isom_get_audio_info(file, TrackNum, 1, &sample_rate, &nb_ch, NULL);
required_rate = sample_rate;
}
if (samp)
gf_isom_sample_del(&samp);
}
else if ((streamType==GF_STREAM_AUDIO) && (codecid==GF_CODECID_QCELP)) {
hintType = GF_RTP_PAYT_QCELP;
OfficialPayloadID = 12;
required_rate = 8000;
streamType = GF_STREAM_AUDIO;
nb_ch = 1;
}
else if ((streamType==GF_STREAM_AUDIO) && ((codecid==GF_CODECID_EVRC) || (codecid==GF_CODECID_SMV)) ) {
hintType = GF_RTP_PAYT_EVRC_SMV;
required_rate = 8000;
streamType = GF_STREAM_AUDIO;
nb_ch = 1;
}
else if (streamType==GF_STREAM_VISUAL) {
if ((codecid==GF_CODECID_MPEG4_PART2) && esd->decoderConfig->decoderSpecificInfo) {
GF_M4VDecSpecInfo dsi;
gf_m4v_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &dsi);
PL_ID = dsi.VideoPL;
}
if ( ((codecid>=GF_CODECID_MPEG2_SIMPLE) && (codecid<=GF_CODECID_MPEG2_422)) || (codecid==GF_CODECID_MPEG1)) {
if (!is_crypted) {
hintType = GF_RTP_PAYT_MPEG12_VIDEO;
OfficialPayloadID = 32;
}
}
if (is_crypted) {
if (codecid==GF_CODECID_MPEG4_PART2) force_dts_delta = 22;
else if ((codecid==GF_CODECID_AVC) || (codecid==GF_CODECID_SVC)) {
flags &= ~GP_RTP_PCK_USE_MULTI;
force_dts_delta = 22;
}
flags |= GP_RTP_PCK_SIGNAL_RAP | GP_RTP_PCK_SIGNAL_TS;
}
required_rate = default_rtp_rate;
}
else if (gf_isom_has_sync_shadows(file, TrackNum) || gf_isom_has_sample_dependency(file, TrackNum)) {
flags |= GP_RTP_PCK_SYSTEMS_CAROUSEL;
}
gf_odf_desc_del((GF_Descriptor*)esd);
}
break;
case GF_ISOM_SUBTYPE_3GP_H263:
hintType = GF_RTP_PAYT_H263;
required_rate = 90000;
streamType = GF_STREAM_VISUAL;
OfficialPayloadID = 34;
codecid = GF_CODECID_MPEG4_PART2;
PL_ID = 0x01;
break;
case GF_ISOM_SUBTYPE_3GP_AMR:
required_rate = 8000;
hintType = GF_RTP_PAYT_AMR;
streamType = GF_STREAM_AUDIO;
has_mpeg4_mapping = 0;
nb_ch = 1;
break;
case GF_ISOM_SUBTYPE_3GP_AMR_WB:
required_rate = 16000;
hintType = GF_RTP_PAYT_AMR_WB;
streamType = GF_STREAM_AUDIO;
has_mpeg4_mapping = 0;
nb_ch = 1;
break;
case GF_ISOM_SUBTYPE_AVC_H264:
case GF_ISOM_SUBTYPE_AVC2_H264:
case GF_ISOM_SUBTYPE_AVC3_H264:
case GF_ISOM_SUBTYPE_AVC4_H264:
case GF_ISOM_SUBTYPE_SVC_H264:
case GF_ISOM_SUBTYPE_MVC_H264:
{
GF_AVCConfig *avcc = gf_isom_avc_config_get(file, TrackNum, 1);
GF_AVCConfig *svcc = gf_isom_svc_config_get(file, TrackNum, 1);
GF_AVCConfig *mvcc = gf_isom_mvc_config_get(file, TrackNum, 1);
if (!avcc && !svcc && !mvcc) {
*e = GF_NON_COMPLIANT_BITSTREAM;
return NULL;
}
required_rate = 90000;
hintType = GF_RTP_PAYT_H264_AVC;
if (TrackMediaSubType==GF_ISOM_SUBTYPE_SVC_H264)
hintType = GF_RTP_PAYT_H264_SVC;
else if (TrackMediaSubType==GF_ISOM_SUBTYPE_MVC_H264)
hintType = GF_RTP_PAYT_H264_SVC;
streamType = GF_STREAM_VISUAL;
avc_nalu_size = avcc ? avcc->nal_unit_size : svcc ? svcc->nal_unit_size : mvcc->nal_unit_size;
codecid = GF_CODECID_AVC;
PL_ID = 0x0F;
gf_odf_avc_cfg_del(avcc);
gf_odf_avc_cfg_del(svcc);
}
break;
case GF_ISOM_SUBTYPE_HVC1:
case GF_ISOM_SUBTYPE_HEV1:
case GF_ISOM_SUBTYPE_HVC2:
case GF_ISOM_SUBTYPE_HEV2:
{
GF_HEVCConfig *hevcc = gf_isom_hevc_config_get(file, TrackNum, 1);
if (!hevcc) {
*e = GF_NON_COMPLIANT_BITSTREAM;
return NULL;
}
required_rate = 90000;
hintType = GF_RTP_PAYT_HEVC;
streamType = GF_STREAM_VISUAL;
avc_nalu_size = hevcc->nal_unit_size;
codecid = GF_CODECID_HEVC;
PL_ID = 0x0F;
flags |= GP_RTP_PCK_USE_MULTI;
gf_odf_hevc_cfg_del(hevcc);
break;
}
break;
case GF_ISOM_SUBTYPE_3GP_QCELP:
required_rate = 8000;
hintType = GF_RTP_PAYT_QCELP;
streamType = GF_STREAM_AUDIO;
codecid = GF_CODECID_QCELP;
OfficialPayloadID = 12;
nb_ch = 1;
break;
case GF_ISOM_SUBTYPE_3GP_EVRC:
case GF_ISOM_SUBTYPE_3GP_SMV:
required_rate = 8000;
hintType = GF_RTP_PAYT_EVRC_SMV;
streamType = GF_STREAM_AUDIO;
codecid = (TrackMediaSubType==GF_ISOM_SUBTYPE_3GP_EVRC) ? GF_CODECID_EVRC : GF_CODECID_SMV;
nb_ch = 1;
break;
case GF_ISOM_SUBTYPE_3GP_DIMS:
#if GPAC_ENABLE_3GPP_DIMS_RTP
hintType = GF_RTP_PAYT_3GPP_DIMS;
streamType = GF_STREAM_SCENE;
#else
hintType = 0;
GF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (""[RTP Packetizer] 3GPP DIMS over RTP disabled in build\n"", streamType));
#endif
break;
case GF_ISOM_SUBTYPE_AC3:
hintType = GF_RTP_PAYT_AC3;
streamType = GF_STREAM_AUDIO;
gf_isom_get_audio_info(file, TrackNum, 1, NULL, &nb_ch, NULL);
break;
case GF_ISOM_SUBTYPE_MP3:
{
GF_ISOSample *samp = gf_isom_get_sample(file, TrackNum, 1, NULL);
if (samp && (samp->dataLength>3)) {
u32 hdr = GF_4CC((u32)samp->data[0], (u8)samp->data[1], (u8)samp->data[2], (u8)samp->data[3]);
nb_ch = gf_mp3_num_channels(hdr);
} else {
u32 bps;
gf_isom_get_audio_info(file, TrackNum, 1, &required_rate, &nb_ch, &bps);
}
hintType = GF_RTP_PAYT_MPEG12_AUDIO;
OfficialPayloadID = 14;
required_rate = 90000;
if (samp)
gf_isom_sample_del(&samp);
}
break;
default:
hintType = 0;
break;
}
}
if (!hintType) return NULL;
gf_isom_get_data_reference(file, TrackNum, 1, &url, &urn);
if (url || urn) return NULL;
*e = GF_OUT_OF_MEM;
GF_SAFEALLOC(tmp, GF_RTPHinter);
if (!tmp) return NULL;
if (has_mpeg4_mapping && (flags & GP_RTP_PCK_FORCE_MPEG4)) {
hintType = GF_RTP_PAYT_MPEG4;
avc_nalu_size = 0;
}
else if (OfficialPayloadID && (flags & GP_RTP_PCK_USE_STATIC_ID) ) {
PayloadID = OfficialPayloadID;
}
tmp->file = file;
tmp->TrackNum = TrackNum;
tmp->avc_nalu_size = avc_nalu_size;
tmp->nb_chan = nb_ch;
tmp->has_ctts = gf_isom_has_time_offset(file, TrackNum);
gf_media_get_sample_average_infos(file, TrackNum, &MinSize, &MaxSize, &avgTS, &maxDTSDelta, &const_dur, &bandwidth);
if (flags & GP_RTP_PCK_SYSTEMS_CAROUSEL) {
flags |= GP_RTP_PCK_SIGNAL_RAP;
}
if (flags & GP_RTP_PCK_USE_MULTI) {
if (MinSize != MaxSize) flags |= GP_RTP_PCK_SIGNAL_SIZE;
if (!const_dur) flags |= GP_RTP_PCK_SIGNAL_TS;
}
if (tmp->has_ctts) flags |= GP_RTP_PCK_SIGNAL_TS;
InitSL_RTP(&my_sl);
my_sl.timestampResolution = gf_isom_get_media_timescale(file, TrackNum);
if (required_rate) {
Double sc = required_rate;
sc /= my_sl.timestampResolution;
maxDTSDelta = (u32) (maxDTSDelta*sc);
my_sl.timestampResolution = required_rate;
}
max_ptime = (u32) (max_ptime * my_sl.timestampResolution / 1000);
my_sl.AUSeqNumLength = gf_get_bit_size(gf_isom_get_sample_count(file, TrackNum));
if (my_sl.AUSeqNumLength>16) my_sl.AUSeqNumLength=16;
my_sl.CUDuration = const_dur;
if (gf_isom_has_sync_points(file, TrackNum)) {
my_sl.useRandomAccessPointFlag = 1;
} else {
my_sl.useRandomAccessPointFlag = 0;
my_sl.hasRandomAccessUnitsOnlyFlag = 1;
}
if (is_crypted) {
Bool use_sel_enc;
gf_isom_get_ismacryp_info(file, TrackNum, 1, NULL, NULL, NULL, NULL, NULL, &use_sel_enc, &IV_length, &KI_length);
if (use_sel_enc) flags |= GP_RTP_PCK_SELECTIVE_ENCRYPTION;
}
tmp->OrigTimeScale = gf_isom_get_media_timescale(file, TrackNum);
tmp->rtp_p = gf_rtp_builder_new(hintType, &my_sl, flags, tmp,
MP4T_OnNewPacket, MP4T_OnPacketDone,
copy_media ? NULL : MP4T_OnDataRef,
MP4T_OnData);
gf_rtp_builder_init(tmp->rtp_p, PayloadID, Path_MTU, max_ptime,
streamType, codecid, PL_ID, MinSize, MaxSize, avgTS, maxDTSDelta, IV_length, KI_length, mpeg4mode);
if (force_dts_delta) tmp->rtp_p->slMap.DTSDeltaLength = force_dts_delta;
tmp->TrackID = gf_isom_get_track_id(file, TrackNum);
tmp->HintID = tmp->TrackID + 65535;
while (gf_isom_get_track_by_id(file, tmp->HintID)) tmp->HintID++;
tmp->HintTrack = gf_isom_new_track(file, tmp->HintID, GF_ISOM_MEDIA_HINT, my_sl.timestampResolution);
gf_isom_setup_hint_track(file, tmp->HintTrack, GF_ISOM_HINT_RTP);
gf_isom_new_hint_description(file, tmp->HintTrack, -1, -1, 0, &descIndex);
gf_isom_rtp_set_timescale(file, tmp->HintTrack, descIndex, my_sl.timestampResolution);
if (hintType==GF_RTP_PAYT_MPEG4) {
tmp->rtp_p->slMap.CodecID = codecid;
*e = gf_isom_set_extraction_slc(file, TrackNum, 1, &my_sl);
if (*e) {
gf_hinter_track_del(tmp);
return NULL;
}
}
tmp->bandwidth = bandwidth;
gf_isom_set_track_interleaving_group(file, TrackNum, InterleaveGroupID);
if (!copy_media) {
gf_isom_set_track_interleaving_group(file, tmp->HintTrack, InterleaveGroupID);
} else {
gf_isom_set_track_interleaving_group(file, tmp->HintTrack, InterleaveGroupID + OFFSET_HINT_GROUP_ID);
}
InterleaveGroupPriority*=2;
gf_isom_set_track_priority_in_group(file, TrackNum, InterleaveGroupPriority+1);
gf_isom_set_track_priority_in_group(file, tmp->HintTrack, InterleaveGroupPriority);
*e = GF_OK;
return tmp;
}","[156, 158]",The gf_hinter_track_new function in GPAC 1.0.1 allows attackers to read memory via a crafted file in the MP4Box command.,gpac,CVE-2021-31261,CWE-119
8202,8053,"GF_Err stbl_AppendTime(GF_SampleTableBox *stbl, u32 duration, u32 nb_pack)
{
GF_TimeToSampleBox *stts = stbl->TimeToSample;
if (!nb_pack) nb_pack = 1;
if (stts->nb_entries) {
if (stts->entries[stts->nb_entries-1].sampleDelta == duration) {
stts->entries[stts->nb_entries-1].sampleCount += nb_pack;
return GF_OK;
}
}
if (stts->nb_entries==stts->alloc_size) {
ALLOC_INC(stts->alloc_size);
stts->entries = gf_realloc(stts->entries, sizeof(GF_SttsEntry)*stts->alloc_size);
if (!stts->entries) return GF_OUT_OF_MEM;
memset(&stts->entries[stts->nb_entries], 0, sizeof(GF_SttsEntry)*(stts->alloc_size-stts->nb_entries) );
}
stts->entries[stts->nb_entries].sampleCount = nb_pack;
stts->entries[stts->nb_entries].sampleDelta = duration;
stts->nb_entries++;
if (stts->max_ts_delta < duration ) stts->max_ts_delta = duration;
return GF_OK;
}",[4],Buffer overflow in the stbl_AppendSize function in MP4Box in GPAC 1.0.1 allows attackers to cause a denial of service or execute arbitrary code via a crafted file.,gpac,CVE-2021-32439,CWE-120
8209,8037,"static void gf_isom_write_tx3g(GF_Tx3gSampleEntryBox *a, GF_BitStream *bs, u32 sidx, u32 sidx_offset)
{
u32 size, j, fount_count;
Bool is_qt_text = (a->type==GF_ISOM_BOX_TYPE_TEXT) ? GF_TRUE : GF_FALSE;
const char *qt_fontname = NULL;
void gpp_write_rgba(GF_BitStream *bs, u32 col);
void gpp_write_box(GF_BitStream *bs, GF_BoxRecord *rec);
void gpp_write_style(GF_BitStream *bs, GF_StyleRecord *rec);
if (sidx_offset) gf_bs_write_u8(bs, sidx + sidx_offset);
size = 8 + 18 + 8 + 12;
size += 8 + 2;
fount_count = 0;
if (is_qt_text) {
GF_TextSampleEntryBox *qt = (GF_TextSampleEntryBox *)a;
if (qt->textName) {
qt_fontname = qt->textName;
fount_count = 1;
}
} else {
if (a->font_table) {
fount_count = a->font_table->entry_count;
for (j=0; j<fount_count; j++) {
size += 3;
if (a->font_table->fonts[j].fontName) size += (u32) strlen(a->font_table->fonts[j].fontName);
}
}
}
gf_bs_write_u32(bs, size);
gf_bs_write_u32(bs, a->type);
gf_bs_write_data(bs, a->reserved, 6);
gf_bs_write_u16(bs, a->dataReferenceIndex);
gf_bs_write_u32(bs, a->displayFlags);
gf_bs_write_u8(bs, a->horizontal_justification);
gf_bs_write_u8(bs, a->vertical_justification);
gpp_write_rgba(bs, a->back_color);
gpp_write_box(bs, &a->default_box);
gpp_write_style(bs, &a->default_style);
size -= (8 + 18 + 8 + 12);
gf_bs_write_u32(bs, size);
gf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_FTAB);
gf_bs_write_u16(bs, fount_count);
for (j=0; j<fount_count; j++) {
if (is_qt_text) {
gf_bs_write_u16(bs, 0);
if (qt_fontname) {
u32 len = (u32) strlen(qt_fontname);
gf_bs_write_u8(bs, len);
gf_bs_write_data(bs, qt_fontname, len);
} else {
gf_bs_write_u8(bs, 0);
}
} else {
gf_bs_write_u16(bs, a->font_table->fonts[j].fontID);
if (a->font_table->fonts[j].fontName) {
u32 len = (u32) strlen(a->font_table->fonts[j].fontName);
gf_bs_write_u8(bs, len);
gf_bs_write_data(bs, a->font_table->fonts[j].fontName, len);
} else {
gf_bs_write_u8(bs, 0);
}
}
}
}","[4, 9, 13, 14, 15, 16, 17, 19, 20, 21, 22, 23, 24, 29, 30, 31, 32, 33, 34, 35, 36, 37, 43, 53, 54, 55, 57]",The gf_isom_vp_config_get function in GPAC 1.0.1 allows attackers to cause a denial of service (NULL pointer dereference) via a crafted file in the MP4Box command.,gpac,CVE-2021-32139,CWE-476
8211,1415,"QByteArray Cipher::blowfishECB(QByteArray cipherText, bool direction)
{
QCA::Initializer init;
QByteArray temp = cipherText;
if (direction)
{
while ((temp.length() % 8) != 0) temp.append('\0');
}
else
{
temp = b64ToByte(temp);
while ((temp.length() % 8) != 0) temp.append('\0');
}
QCA::Direction dir = (direction) ? QCA::Encode : QCA::Decode;
QCA::Cipher cipher(m_type, QCA::Cipher::ECB, QCA::Cipher::NoPadding, dir, m_key);
QByteArray temp2 = cipher.update(QCA::MemoryRegion(temp)).toByteArray();
temp2 += cipher.final().toByteArray();
if (!cipher.ok())
return cipherText;
if (direction)
temp2 = byteToB64(temp2);
return temp2;
}","[11, 20, 22]",The blowfishECB function in core/cipher.cpp in Quassel IRC 0.10.0 allows remote attackers to cause a denial of service (out-of-bounds read) via a malformed string.,quassel,CVE-2014-8483,CWE-125
8227,8411,"static int dnxhd_init_vlc(DNXHDContext *ctx, uint32_t cid, int bitdepth)
{
if (cid != ctx->cid) {
const CIDEntry *cid_table = ff_dnxhd_get_cid_table(cid);
if (!cid_table) {
av_log(ctx->avctx, AV_LOG_ERROR, ""unsupported cid %""PRIu32""\n"", cid);
return AVERROR(ENOSYS);
}
if (cid_table->bit_depth != bitdepth &&
cid_table->bit_depth != DNXHD_VARIABLE) {
av_log(ctx->avctx, AV_LOG_ERROR, ""bit depth mismatches %d %d\n"",
cid_table->bit_depth, bitdepth);
return AVERROR_INVALIDDATA;
}
ctx->cid_table = cid_table;
av_log(ctx->avctx, AV_LOG_VERBOSE, ""Profile cid %""PRIu32"".\n"", cid);
ff_free_vlc(&ctx->ac_vlc);
ff_free_vlc(&ctx->dc_vlc);
ff_free_vlc(&ctx->run_vlc);
init_vlc(&ctx->ac_vlc, DNXHD_VLC_BITS, 257,
ctx->cid_table->ac_bits, 1, 1,
ctx->cid_table->ac_codes, 2, 2, 0);
init_vlc(&ctx->dc_vlc, DNXHD_DC_VLC_BITS, bitdepth > 8 ? 14 : 12,
ctx->cid_table->dc_bits, 1, 1,
ctx->cid_table->dc_codes, 1, 1, 0);
init_vlc(&ctx->run_vlc, DNXHD_VLC_BITS, 62,
ctx->cid_table->run_bits, 1, 1,
ctx->cid_table->run_codes, 2, 2, 0);
ctx->cid = cid;
}
return 0;
}","[3, 20, 22, 23, 25, 26, 28, 31]","libavcodec/dnxhddec.c in FFmpeg 4.4 does not check the return value of the init_vlc function, a similar issue to CVE-2013-0868.",FFmpeg,CVE-2021-38114,CWE-252
8228,6103,"static int zipfileUpdate(
sqlite3_vtab *pVtab,
int nVal,
sqlite3_value **apVal,
sqlite_int64 *pRowid
){
ZipfileTab *pTab = (ZipfileTab*)pVtab;
int rc = SQLITE_OK;
ZipfileEntry *pNew = 0;
u32 mode = 0;
u32 mTime = 0;
i64 sz = 0;
const char *zPath = 0;
int nPath = 0;
const u8 *pData = 0;
int nData = 0;
int iMethod = 0;
u8 *pFree = 0;
char *zFree = 0;
ZipfileEntry *pOld = 0;
ZipfileEntry *pOld2 = 0;
int bUpdate = 0;
int bIsDir = 0;
u32 iCrc32 = 0;
if( pTab->pWriteFd==0 ){
rc = zipfileBegin(pVtab);
if( rc!=SQLITE_OK ) return rc;
}
if( sqlite3_value_type(apVal[0])!=SQLITE_NULL ){
const char *zDelete = (const char*)sqlite3_value_text(apVal[0]);
int nDelete = (int)strlen(zDelete);
if( nVal>1 ){
const char *zUpdate = (const char*)sqlite3_value_text(apVal[1]);
if( zUpdate && zipfileComparePath(zUpdate, zDelete, nDelete)!=0 ){
bUpdate = 1;
}
}
for(pOld=pTab->pFirstEntry; 1; pOld=pOld->pNext){
if( zipfileComparePath(pOld->cds.zFile, zDelete, nDelete)==0 ){
break;
}
assert( pOld->pNext );
}
}
if( nVal>1 ){
if( sqlite3_value_type(apVal[5])!=SQLITE_NULL ){
zipfileTableErr(pTab, ""sz must be NULL"");
rc = SQLITE_CONSTRAINT;
}
if( sqlite3_value_type(apVal[6])!=SQLITE_NULL ){
zipfileTableErr(pTab, ""rawdata must be NULL"");
rc = SQLITE_CONSTRAINT;
}
if( rc==SQLITE_OK ){
if( sqlite3_value_type(apVal[7])==SQLITE_NULL ){
bIsDir = 1;
}else{
const u8 *aIn = sqlite3_value_blob(apVal[7]);
int nIn = sqlite3_value_bytes(apVal[7]);
int bAuto = sqlite3_value_type(apVal[8])==SQLITE_NULL;
iMethod = sqlite3_value_int(apVal[8]);
sz = nIn;
pData = aIn;
nData = nIn;
if( iMethod!=0 && iMethod!=8 ){
zipfileTableErr(pTab, ""unknown compression method: %d"", iMethod);
rc = SQLITE_CONSTRAINT;
}else{
if( bAuto || iMethod ){
int nCmp;
rc = zipfileDeflate(aIn, nIn, &pFree, &nCmp, &pTab->base.zErrMsg);
if( rc==SQLITE_OK ){
if( iMethod || nCmp<nIn ){
iMethod = 8;
pData = pFree;
nData = nCmp;
}
}
}
iCrc32 = crc32(0, aIn, nIn);
}
}
}
if( rc==SQLITE_OK ){
rc = zipfileGetMode(apVal[3], bIsDir, &mode, &pTab->base.zErrMsg);
}
if( rc==SQLITE_OK ){
zPath = (const char*)sqlite3_value_text(apVal[2]);
nPath = (int)strlen(zPath);
mTime = zipfileGetTime(apVal[4]);
}
if( rc==SQLITE_OK && bIsDir ){
if( zPath[nPath-1]!='/' ){
zFree = sqlite3_mprintf(""%s/"", zPath);
if( zFree==0 ){ rc = SQLITE_NOMEM; }
zPath = (const char*)zFree;
nPath++;
}
}
if( (pOld==0 || bUpdate) && rc==SQLITE_OK ){
ZipfileEntry *p;
for(p=pTab->pFirstEntry; p; p=p->pNext){
if( zipfileComparePath(p->cds.zFile, zPath, nPath)==0 ){
switch( sqlite3_vtab_on_conflict(pTab->db) ){
case SQLITE_IGNORE: {
goto zipfile_update_done;
}
case SQLITE_REPLACE: {
pOld2 = p;
break;
}
default: {
zipfileTableErr(pTab, ""duplicate name: \""%s\"""", zPath);
rc = SQLITE_CONSTRAINT;
break;
}
}
break;
}
}
}
if( rc==SQLITE_OK ){
pNew = zipfileNewEntry(zPath);
if( pNew==0 ){
rc = SQLITE_NOMEM;
}else{
pNew->cds.iVersionMadeBy = ZIPFILE_NEWENTRY_MADEBY;
pNew->cds.iVersionExtract = ZIPFILE_NEWENTRY_REQUIRED;
pNew->cds.flags = ZIPFILE_NEWENTRY_FLAGS;
pNew->cds.iCompression = (u16)iMethod;
zipfileMtimeToDos(&pNew->cds, mTime);
pNew->cds.crc32 = iCrc32;
pNew->cds.szCompressed = nData;
pNew->cds.szUncompressed = (u32)sz;
pNew->cds.iExternalAttr = (mode<<16);
pNew->cds.iOffset = (u32)pTab->szCurrent;
pNew->cds.nFile = (u16)nPath;
pNew->mUnixTime = (u32)mTime;
rc = zipfileAppendEntry(pTab, pNew, pData, nData);
zipfileAddEntry(pTab, pOld, pNew);
}
}
}
if( rc==SQLITE_OK && (pOld || pOld2) ){
ZipfileCsr *pCsr;
for(pCsr=pTab->pCsrList; pCsr; pCsr=pCsr->pCsrNext){
if( pCsr->pCurrent && (pCsr->pCurrent==pOld || pCsr->pCurrent==pOld2) ){
pCsr->pCurrent = pCsr->pCurrent->pNext;
pCsr->bNoop = 1;
}
}
zipfileRemoveEntryFromList(pTab, pOld);
zipfileRemoveEntryFromList(pTab, pOld2);
}
zipfile_update_done:
sqlite3_free(pFree);
sqlite3_free(zFree);
return rc;
}",[89],zipfileUpdate in ext/misc/zipfile.c in SQLite 3.30.1 mishandles a NULL pathname during an update of a ZIP archive.,sqlite,CVE-2019-19925,CWE-434
8232,9208,"static GF_Err BM_ParseGlobalQuantizer(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)
{
GF_Node *node;
GF_Command *com;
GF_CommandField *inf;
node = gf_bifs_dec_node(codec, bs, NDT_SFWorldNode);
if (!node) return GF_NON_COMPLIANT_BITSTREAM;
if (codec->scenegraph->global_qp) {
gf_node_unregister(codec->scenegraph->global_qp, NULL);
}
codec->ActiveQP = NULL;
codec->scenegraph->global_qp = NULL;
if (gf_node_get_tag(node) != TAG_MPEG4_QuantizationParameter) {
gf_node_unregister(node, NULL);
return GF_NON_COMPLIANT_BITSTREAM;
}
codec->ActiveQP = (M_QuantizationParameter *) node;
codec->ActiveQP->isLocal = 0;
codec->scenegraph->global_qp = node;
node->sgprivate->num_instances = 2;
com = gf_sg_command_new(codec->current_graph, GF_SG_GLOBAL_QUANTIZER);
inf = gf_sg_command_field_new(com);
inf->new_node = node;
inf->field_ptr = &inf->new_node;
inf->fieldType = GF_SG_VRML_SFNODE;
gf_list_add(com_list, com);
return GF_OK;
}","[14, 20]",Use After Free in GitHub repository gpac/gpac prior to v2.1.0-DEV.,gpac,CVE-2022-1795,CWE-416
8241,5565,"static float *get_window(vorb *f, int len)
{
len <<= 1;
if (len == f->blocksize_0) return f->window[0];
if (len == f->blocksize_1) return f->window[1];
assert(0);
return NULL;
}",[6],A heap buffer overflow in the start_decoder function in stb_vorbis through 2019-03-04 allows an attacker to cause a denial of service or execute arbitrary code by opening a crafted Ogg Vorbis file.,stb,CVE-2019-13217,CWE-787
8244,7214,"char *compose_path(ctrl_t *ctrl, char *path)
{
struct stat st;
static char rpath[PATH_MAX];
char *name, *ptr;
char dir[PATH_MAX] = { 0 };
strlcpy(dir, ctrl->cwd, sizeof(dir));
DBG(""Compose path from cwd: %s, arg: %s"", ctrl->cwd, path ?: """");
if (!path || !strlen(path))
goto check;
if (path) {
if (path[0] != '/') {
if (dir[strlen(dir) - 1] != '/')
strlcat(dir, ""/"", sizeof(dir));
}
strlcat(dir, path, sizeof(dir));
}
check:
while ((ptr = strstr(dir, """")))
memmove(ptr, &ptr[1], strlen(&ptr[1]) + 1);
if (!chrooted) {
size_t len = strlen(home);
DBG(""Server path from CWD: %s"", dir);
if (len > 0 && home[len - 1] == '/')
len--;
memmove(dir + len, dir, strlen(dir) + 1);
memcpy(dir, home, len);
DBG(""Resulting non-chroot path: %s"", dir);
}
if (!stat(dir, &st) && S_ISDIR(st.st_mode)) {
if (!realpath(dir, rpath))
return NULL;
} else {
name = basename(path);
ptr = dirname(dir);
memset(rpath, 0, sizeof(rpath));
if (!realpath(ptr, rpath)) {
INFO(""Failed realpath(%s): %m"", ptr);
return NULL;
}
if (rpath[1] != 0)
strlcat(rpath, ""/"", sizeof(rpath));
strlcat(rpath, name, sizeof(rpath));
}
if (!chrooted && strncmp(dir, home, strlen(home))) {
DBG(""Failed non-chroot dir:%s vs home:%s"", dir, home);
return NULL;
}
return rpath;
}",[45],"There are multiple unauthenticated directory traversal vulnerabilities in different FTP commands in uftpd FTP server versions 2.7 to 2.10 due to improper implementation of a chroot jail in common.c's compose_abspath function that can be abused to read or write to arbitrary files on the filesystem, leak process memory, or potentially lead to remote code execution.",uftpd,CVE-2020-20277,CWE-22
8251,8576,"find_link_ref(struct link_ref **references, uint8_t *name, size_t length)
{
unsigned int hash = hash_link_ref(name, length);
struct link_ref *ref = NULL;
ref = references[hash % REF_TABLE_SIZE];
while (ref != NULL) {
if (ref->id == hash)
return ref;
ref = ref->next;
}
return NULL;
}","[7, 8]","Snudown is a reddit-specific fork of the Sundown Markdown parser used by GitHub, with Python integration added. In affected versions snudown was found to be vulnerable to denial of service attacks to its reference table implementation. References written in markdown ` [reference_name]: https://www.example.com` are inserted into a hash table which was found to have a weak hash function, meaning that an attacker can reliably generate a large number of collisions for it. This makes the hash table vulnerable to a hash-collision DoS attack, a type of algorithmic complexity attack. Further the hash table allowed for duplicate entries resulting in long retrieval times. Proofs of concept and further discussion of the hash collision issue are discussed on the snudown GHSA(https://github.com/reddit/snudown/security/advisories/GHSA-6gvv-9q92-w5f6). Users are advised to update to version 1.7.0.",snudown,CVE-2021-41168,CWE-407
8255,9849,"GF_Err SFScript_Parse(GF_BifsDecoder *codec, SFScript *script_field, GF_BitStream *bs, GF_Node *n)
{
GF_Err e;
u32 i, count, nbBits;
char *ptr;
ScriptParser parser;
e = GF_OK;
if (gf_node_get_tag(n) != TAG_MPEG4_Script) return GF_NON_COMPLIANT_BITSTREAM;
parser.codec = codec;
parser.script = n;
parser.bs = bs;
parser.length = 500;
parser.string = (char *) gf_malloc(sizeof(char)* parser.length);
parser.string[0] = 0;
parser.identifiers = gf_list_new();
parser.new_line = (char *) (codec->dec_memory_mode ? ""\n"" : NULL);
parser.indent = 0;
if (gf_bs_read_int(bs, 1)) {
while (!gf_bs_read_int(bs, 1)) {
e = ParseScriptField(&parser);
if (e) goto exit;
}
} else {
nbBits = gf_bs_read_int(bs, 4);
count = gf_bs_read_int(bs, nbBits);
for (i=0; i<count; i++) {
e = ParseScriptField(&parser);
if (e) goto exit;
}
}
gf_bs_read_int(bs, 1);
SFS_AddString(&parser, ""javascript:"");
SFS_AddString(&parser, parser.new_line);
while (gf_bs_read_int(bs, 1)) {
SFS_AddString(&parser, ""function "");
SFS_Identifier(&parser);
SFS_Arguments(&parser, GF_FALSE);
SFS_Space(&parser);
SFS_StatementBlock(&parser, GF_TRUE);
SFS_Line(&parser);
}
SFS_Line(&parser);
if (script_field->script_text) gf_free(script_field->script_text);
script_field->script_text = (char *) gf_strdup(parser.string);
exit:
while (gf_list_count(parser.identifiers)) {
ptr = (char *)gf_list_get(parser.identifiers, 0);
gf_free(ptr);
gf_list_rem(parser.identifiers, 0);
}
gf_list_del(parser.identifiers);
if (parser.string) gf_free(parser.string);
return e;
}","[9, 42]",Uncontrolled Recursion in GitHub repository gpac/gpac prior to 2.1.0-DEV.,gpac,CVE-2022-3222,CWE-674
8270,4995,"char *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicode_type)
{
u32 i, j, len;
char *sOK;
char szLineConv[1024];
unsigned short *sptr;
memset(szLine, 0, sizeof(char)*lineSize);
sOK = fgets(szLine, lineSize, txt_in);
if (!sOK) return NULL;
if (unicode_type<=1) {
j=0;
len = (u32) strlen(szLine);
for (i=0; i<len; i++) {
if (!unicode_type && (szLine[i] & 0x80)) {
if ((szLine[i+1] & 0xc0) != 0x80) {
szLineConv[j] = 0xc0 | ( (szLine[i] >> 6) & 0x3 );
j++;
szLine[i] &= 0xbf;
}
else if ( (szLine[i] & 0xe0) == 0xc0) {
szLineConv[j] = szLine[i];
i++;
j++;
}
else if ( (szLine[i] & 0xf0) == 0xe0) {
szLineConv[j] = szLine[i];
i++;
j++;
szLineConv[j] = szLine[i];
i++;
j++;
}
else if ( (szLine[i] & 0xf8) == 0xf0) {
szLineConv[j] = szLine[i];
i++;
j++;
szLineConv[j] = szLine[i];
i++;
j++;
szLineConv[j] = szLine[i];
i++;
j++;
} else {
i+=1;
continue;
}
}
szLineConv[j] = szLine[i];
j++;
}
szLineConv[j] = 0;
strcpy(szLine, szLineConv);
return sOK;
}
#ifdef GPAC_BIG_ENDIAN
if (unicode_type==3) {
#else
if (unicode_type==2) {
#endif
i=0;
while (1) {
char c;
if (!szLine[i] && !szLine[i+1]) break;
c = szLine[i+1];
szLine[i+1] = szLine[i];
szLine[i] = c;
i+=2;
}
}
sptr = (u16 *)szLine;
i = (u32) gf_utf8_wcstombs(szLineConv, 1024, (const unsigned short **) &sptr);
szLineConv[i] = 0;
strcpy(szLine, szLineConv);
if (unicode_type==3) fgetc(txt_in);
return sOK;
}",[72],"In GPAC 0.7.1 and earlier, gf_text_get_utf8_line in media_tools/text_import.c in libgpac_static.a allows an out-of-bounds write because a certain -1 return value is mishandled.",gpac,CVE-2018-20760,CWE-787
8289,4725,"Expression_Obj Parser::parse_value()
{
lex< css_comments >(false);
if (lex< ampersand >())
{
if (match< ampersand >()) {
warning(""In Sass, \""&&\"" means two copies of the parent selector. You probably want to use \""and\"" instead."", pstate);
}
return SASS_MEMORY_NEW(Parent_Selector, pstate); }
if (lex< kwd_important >())
{ return SASS_MEMORY_NEW(String_Constant, pstate, ""!important""); }
if (lex< sequence < percentage, lookahead < number > > >())
{ return lexed_percentage(lexed); }
if (lex< sequence < number, lookahead< sequence < op, number > > > >())
{ return lexed_number(lexed); }
if (lex< sequence < quoted_string, lookahead < exactly <'-'> > > >())
{ return parse_string(); }
if (const char* stop = peek< value_schema >())
{ return parse_value_schema(stop); }
if (lex< quoted_string >())
{ return parse_string(); }
if (lex< kwd_true >())
{ return SASS_MEMORY_NEW(Boolean, pstate, true); }
if (lex< kwd_false >())
{ return SASS_MEMORY_NEW(Boolean, pstate, false); }
if (lex< kwd_null >())
{ return SASS_MEMORY_NEW(Null, pstate); }
if (lex< identifier >()) {
return color_or_string(lexed);
}
if (lex< percentage >())
{ return lexed_percentage(lexed); }
if (lex< sequence < alternatives< hex, hex0 >, negate < exactly<'-'> > > >())
{ return lexed_hex_color(lexed); }
if (lex< hexa >())
{
std::string s = lexed.to_string();
deprecated(
""The value \""""+s+""\"" is currently parsed as a string, but it will be parsed as a color in"",
""future versions of Sass. Use \""unquote('""+s+""')\"" to continue parsing it as a string."",
true, pstate
);
return SASS_MEMORY_NEW(String_Quoted, pstate, lexed);
}
if (lex< sequence < exactly <'#'>, identifier > >())
{ return SASS_MEMORY_NEW(String_Quoted, pstate, lexed); }
if (lex< sequence< dimension, optional< sequence< exactly<'-'>, lookahead< alternatives < space > > > > > >())
{ return lexed_dimension(lexed); }
if (lex< sequence< static_component, one_plus< strict_identifier > > >())
{ return SASS_MEMORY_NEW(String_Constant, pstate, lexed); }
if (lex< number >())
{ return lexed_number(lexed); }
if (lex< variable >())
{ return SASS_MEMORY_NEW(Variable, pstate, Util::normalize_underscores(lexed)); }
if (lex< sequence< exactly<'%'>, optional< percentage > > >())
{ return SASS_MEMORY_NEW(String_Constant, pstate, lexed); }
css_error(""Invalid CSS"", "" after "", "": expected expression (e.g. 1px, bold), was "");
return 0;
}","[55, 56]","In LibSass prior to 3.5.5, Sass::Eval::operator()(Sass::Binary_Expression*) inside eval.cpp allows attackers to cause a denial-of-service resulting from stack consumption via a crafted sass file, because of certain incorrect parsing of '%' as a modulo operator in parser.cpp.",libsass,CVE-2018-19837,CWE-400
8296,2479,"void CoreAuthHandler::onReadyRead()
{
if (socket()->bytesAvailable() < 4)
return;
if (_peer)
return;
if (!_magicReceived) {
quint32 magic;
socket()->peek((char*)&magic, 4);
magic = qFromBigEndian<quint32>(magic);
if ((magic & 0xffffff00) != Protocol::magic) {
qDebug() << ""Legacy client detected, switching to compatibility mode"";
_legacy = true;
RemotePeer *peer = PeerFactory::createPeer(PeerFactory::ProtoDescriptor(Protocol::LegacyProtocol, 0), this, socket(), Compressor::NoCompression, this);
connect(peer, SIGNAL(protocolVersionMismatch(int,int)), SLOT(onProtocolVersionMismatch(int,int)));
setPeer(peer);
return;
}
_magicReceived = true;
quint8 features = magic & 0xff;
if (Core::sslSupported() && (features & Protocol::Encryption))
_connectionFeatures |= Protocol::Encryption;
if (features & Protocol::Compression)
_connectionFeatures |= Protocol::Compression;
socket()->read((char*)&magic, 4);
}
while (socket()->bytesAvailable() >= 4) {
quint32 data;
socket()->read((char*)&data, 4);
data = qFromBigEndian<quint32>(data);
Protocol::Type type = static_cast<Protocol::Type>(data & 0xff);
quint16 protoFeatures = static_cast<quint16>(data>>8 & 0xffff);
_supportedProtos.append(PeerFactory::ProtoDescriptor(type, protoFeatures));
if (data >= 0x80000000) {
Compressor::CompressionLevel level;
if (_connectionFeatures & Protocol::Compression)
level = Compressor::BestCompression;
else
level = Compressor::NoCompression;
RemotePeer *peer = PeerFactory::createPeer(_supportedProtos, this, socket(), level, this);
if (peer->protocol() == Protocol::LegacyProtocol) {
_legacy = true;
connect(peer, SIGNAL(protocolVersionMismatch(int,int)), SLOT(onProtocolVersionMismatch(int,int)));
}
setPeer(peer);
quint32 reply = peer->protocol() | peer->enabledFeatures()<<8 | _connectionFeatures<<24;
reply = qToBigEndian<quint32>(reply);
socket()->write((char*)&reply, 4);
socket()->flush();
if (!_legacy && (_connectionFeatures & Protocol::Encryption))
startSsl();
return;
}
}
}","[27, 41]",The onReadyRead function in core/coreauthhandler.cpp in Quassel before 0.12.4 allows remote attackers to cause a denial of service (NULL pointer dereference and crash) via invalid handshake data.,quassel,CVE-2016-4414,NVD-CWE-Other
8300,8231,"Status DecodeImageAPNG(Span<const uint8_t> bytes, ThreadPool* pool,
CodecInOut* io) {
Reader r;
unsigned int id, i, j, w, h, w0, h0, x0, y0;
unsigned int delay_num, delay_den, dop, bop, rowbytes, imagesize;
unsigned char sig[8];
png_structp png_ptr;
png_infop info_ptr;
CHUNK chunk;
CHUNK chunkIHDR;
std::vector<CHUNK> chunksInfo;
bool isAnimated = false;
bool skipFirst = false;
bool hasInfo = false;
bool all_dispose_bg = true;
APNGFrame frameRaw = {};
r = {bytes.data(), bytes.data() + bytes.size()};
unsigned char png_signature[8] = {137, 80, 78, 71, 13, 10, 26, 10};
if (r.Read(sig, 8) || memcmp(sig, png_signature, 8) != 0) {
return false;
}
id = read_chunk(&r, &chunkIHDR);
io->frames.clear();
io->dec_pixels = 0;
io->metadata.m.SetUintSamples(8);
io->metadata.m.SetAlphaBits(8);
io->metadata.m.color_encoding =
ColorEncoding::SRGB();
(void)io->dec_hints.Foreach(
[](const std::string& key, const std::string&          ) {
JXL_WARNING(""APNG decoder ignoring %s hint"", key.c_str());
return true;
});
bool errorstate = true;
if (id == kId_IHDR && chunkIHDR.size == 25) {
w0 = w = png_get_uint_32(chunkIHDR.p + 8);
h0 = h = png_get_uint_32(chunkIHDR.p + 12);
if (w > cMaxPNGSize || h > cMaxPNGSize) {
return false;
}
x0 = 0;
y0 = 0;
delay_num = 1;
delay_den = 10;
dop = 0;
bop = 0;
rowbytes = w * 4;
imagesize = h * rowbytes;
frameRaw.p = new unsigned char[imagesize];
frameRaw.rows = new png_bytep[h * sizeof(png_bytep)];
for (j = 0; j < h; j++) frameRaw.rows[j] = frameRaw.p + j * rowbytes;
if (!processing_start(png_ptr, info_ptr, (void*)&frameRaw, hasInfo,
chunkIHDR, chunksInfo)) {
bool last_base_was_none = true;
while (!r.Eof()) {
id = read_chunk(&r, &chunk);
if (!id) break;
JXL_ASSERT(chunk.p != nullptr);
if (id == kId_acTL && !hasInfo && !isAnimated) {
isAnimated = true;
skipFirst = true;
io->metadata.m.have_animation = true;
io->metadata.m.animation.tps_numerator = 1000;
} else if (id == kId_IEND ||
(id == kId_fcTL && (!hasInfo || isAnimated))) {
if (hasInfo) {
if (!processing_finish(png_ptr, info_ptr)) {
ImageBundle bundle(&io->metadata.m);
bundle.duration = delay_num * 1000 / delay_den;
bundle.origin.x0 = x0;
bundle.origin.y0 = y0;
if (last_base_was_none && !all_dispose_bg &&
(x0 != 0 || y0 != 0 || w0 != w || h0 != h || bop != 0)) {
return JXL_FAILURE(
""APNG with dispose-to-0 is not supported for non-full or ""
""blended frames"");
}
switch (dop) {
case 0:
bundle.use_for_next_frame = true;
last_base_was_none = false;
all_dispose_bg = false;
break;
case 2:
bundle.use_for_next_frame = false;
all_dispose_bg = false;
break;
default:
bundle.use_for_next_frame = false;
last_base_was_none = true;
}
bundle.blend = bop != 0;
io->dec_pixels += w0 * h0;
Image3F sub_frame(w0, h0);
ImageF sub_frame_alpha(w0, h0);
for (size_t y = 0; y < h0; ++y) {
float* const JXL_RESTRICT row_r = sub_frame.PlaneRow(0, y);
float* const JXL_RESTRICT row_g = sub_frame.PlaneRow(1, y);
float* const JXL_RESTRICT row_b = sub_frame.PlaneRow(2, y);
float* const JXL_RESTRICT row_alpha = sub_frame_alpha.Row(y);
uint8_t* const f = frameRaw.rows[y];
for (size_t x = 0; x < w0; ++x) {
if (f[4 * x + 3] == 0) {
row_alpha[x] = 0;
row_r[x] = 0;
row_g[x] = 0;
row_b[x] = 0;
continue;
}
row_r[x] = f[4 * x + 0] * (1.f / 255);
row_g[x] = f[4 * x + 1] * (1.f / 255);
row_b[x] = f[4 * x + 2] * (1.f / 255);
row_alpha[x] = f[4 * x + 3] * (1.f / 255);
}
}
bundle.SetFromImage(std::move(sub_frame), ColorEncoding::SRGB());
bundle.SetAlpha(std::move(sub_frame_alpha),
false);
io->frames.push_back(std::move(bundle));
} else {
delete[] chunk.p;
break;
}
}
if (id == kId_IEND) {
errorstate = false;
break;
}
w0 = png_get_uint_32(chunk.p + 12);
h0 = png_get_uint_32(chunk.p + 16);
x0 = png_get_uint_32(chunk.p + 20);
y0 = png_get_uint_32(chunk.p + 24);
delay_num = png_get_uint_16(chunk.p + 28);
delay_den = png_get_uint_16(chunk.p + 30);
dop = chunk.p[32];
bop = chunk.p[33];
if (w0 > cMaxPNGSize || h0 > cMaxPNGSize || x0 > cMaxPNGSize ||
y0 > cMaxPNGSize || x0 + w0 > w || y0 + h0 > h || dop > 2 ||
bop > 1) {
delete[] chunk.p;
break;
}
if (hasInfo) {
memcpy(chunkIHDR.p + 8, chunk.p + 12, 8);
if (processing_start(png_ptr, info_ptr, (void*)&frameRaw, hasInfo,
chunkIHDR, chunksInfo)) {
delete[] chunk.p;
break;
}
} else
skipFirst = false;
if (io->frames.size() == (skipFirst ? 1 : 0)) {
bop = 0;
if (dop == 2) dop = 1;
}
} else if (id == kId_IDAT) {
hasInfo = true;
if (processing_data(png_ptr, info_ptr, chunk.p, chunk.size)) {
delete[] chunk.p;
break;
}
} else if (id == kId_fdAT && isAnimated) {
png_save_uint_32(chunk.p + 4, chunk.size - 16);
memcpy(chunk.p + 8, ""IDAT"", 4);
if (processing_data(png_ptr, info_ptr, chunk.p + 4, chunk.size - 4)) {
delete[] chunk.p;
break;
}
} else if (!isAbc(chunk.p[4]) || !isAbc(chunk.p[5]) ||
!isAbc(chunk.p[6]) || !isAbc(chunk.p[7])) {
delete[] chunk.p;
break;
} else if (!hasInfo) {
if (processing_data(png_ptr, info_ptr, chunk.p, chunk.size)) {
delete[] chunk.p;
break;
}
chunksInfo.push_back(chunk);
continue;
}
delete[] chunk.p;
}
}
delete[] frameRaw.rows;
delete[] frameRaw.p;
}
for (i = 0; i < chunksInfo.size(); i++) delete[] chunksInfo[i].p;
chunksInfo.clear();
delete[] chunkIHDR.p;
if (errorstate) return false;
SetIntensityTarget(io);
return true;
}",[137],"libjxl v0.3.7 is affected by a Divide By Zero in issue in lib/extras/codec_apng.cc jxl::DecodeImageAPNG(). When encoding a malicous APNG file using cjxl, an attacker can trigger a denial of service.",libjxl,CVE-2021-36692,CWE-369
8302,9633,"static void gf_dump_vrml_dyn_field(GF_SceneDumper *sdump, GF_Node *node, GF_FieldInfo field, Bool has_sublist)
{
u32 i, sf_type;
void *slot_ptr;
if (gf_sg_vrml_is_sf_field(field.fieldType)) {
DUMP_IND(sdump);
if (sdump->XMLDump) {
if (sdump->X3DDump) {
gf_fprintf(sdump->trace, ""<field name=\""%s\"" type=\""%s\"" accessType=\""%s\"""",
field.name, gf_sg_vrml_get_field_type_name(field.fieldType), gf_sg_vrml_get_event_type_name(field.eventType, 1));
} else {
gf_fprintf(sdump->trace, ""<field name=\""%s\"" type=\""%s\"" vrml97Hint=\""%s\"""",
field.name, GetXMTFieldTypeName(field.fieldType), gf_sg_vrml_get_event_type_name(field.eventType, 0));
}
if ((field.eventType == GF_SG_EVENT_FIELD) || (field.eventType == GF_SG_EVENT_EXPOSED_FIELD)) {
if (field.fieldType == GF_SG_VRML_SFNODE) {
if (!sdump->X3DDump) {
gf_fprintf(sdump->trace, "">\n"");
sdump->indent++;
gf_fprintf(sdump->trace, ""<node>"");
gf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL);
gf_fprintf(sdump->trace, ""</node>"");
sdump->indent--;
if (!has_sublist)
gf_fprintf(sdump->trace, ""</field>\n"");
} else {
if (field.far_ptr) {
gf_fprintf(sdump->trace, "">\n"");
gf_dump_vrml_node(sdump, *(GF_Node **)field.far_ptr, 0, NULL);
gf_fprintf(sdump->trace, ""</field>\n"");
} else {
gf_fprintf(sdump->trace, ""/>\n"");
}
}
DUMP_IND(sdump);
} else {
if (sdump->X3DDump) {
gf_fprintf(sdump->trace, "" value=\"""");
} else {
gf_fprintf(sdump->trace, "" %s=\"""", GetXMTFieldTypeValueName(field.fieldType));
}
if (field.far_ptr)
gf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, node);
if (has_sublist)
gf_fprintf(sdump->trace, ""\"">\n"");
else
gf_fprintf(sdump->trace, ""\""/>\n"");
}
} else {
gf_fprintf(sdump->trace, ""/>\n"");
}
} else {
gf_fprintf(sdump->trace, ""%s %s %s"", gf_sg_vrml_get_event_type_name(field.eventType, sdump->X3DDump), gf_sg_vrml_get_field_type_name(field.fieldType), field.name);
if ((field.eventType==GF_SG_EVENT_FIELD) || (field.eventType==GF_SG_EVENT_EXPOSED_FIELD)) {
gf_fprintf(sdump->trace, "" "");
if (field.fieldType == GF_SG_VRML_SFNODE) {
gf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL);
} else if (field.far_ptr) {
gf_dump_vrml_simple_field(sdump, field, node);
}
}
gf_fprintf(sdump->trace, ""\n"");
}
} else if (field.far_ptr) {
GenMFField *mffield = (GenMFField *) field.far_ptr;
sf_type = gf_sg_vrml_get_sf_type(field.fieldType);
DUMP_IND(sdump);
if (!sdump->XMLDump) {
gf_fprintf(sdump->trace, ""%s %s %s"", gf_sg_vrml_get_event_type_name(field.eventType, sdump->X3DDump), gf_sg_vrml_get_field_type_name(field.fieldType), field.name);
if ((field.eventType==GF_SG_EVENT_FIELD) || (field.eventType==GF_SG_EVENT_EXPOSED_FIELD)) {
gf_fprintf(sdump->trace, "" ["");
if (sf_type == GF_SG_VRML_SFNODE) {
GF_ChildNodeItem *l = *(GF_ChildNodeItem **)field.far_ptr;
gf_fprintf(sdump->trace, ""\n"");
sdump->indent++;
while (l) {
gf_dump_vrml_node(sdump, l->node, 1, NULL);
l = l->next;
}
sdump->indent--;
DUMP_IND(sdump);
} else {
for (i=0; i<mffield->count; i++) {
if (i) gf_fprintf(sdump->trace, "" "");
if (field.fieldType != GF_SG_VRML_MFNODE) {
gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);
gf_dump_vrml_sffield(sdump, sf_type, slot_ptr, (mffield->count>1) ? 1 : 0, node);
}
}
}
gf_fprintf(sdump->trace, ""]"");
}
gf_fprintf(sdump->trace, ""\n"");
} else {
if (sdump->X3DDump) {
gf_fprintf(sdump->trace, ""<field name=\""%s\"" type=\""%s\"" accessType=\""%s\"""",
field.name, gf_sg_vrml_get_field_type_name(field.fieldType), gf_sg_vrml_get_event_type_name(field.eventType, 1));
} else {
gf_fprintf(sdump->trace, ""<field name=\""%s\"" type=\""%s\"" vrml97Hint=\""%s\"""",
field.name, GetXMTFieldTypeName(field.fieldType), gf_sg_vrml_get_event_type_name(field.eventType, 0));
}
if ((field.eventType==GF_SG_EVENT_FIELD) || (field.eventType==GF_SG_EVENT_EXPOSED_FIELD)) {
if (sf_type == GF_SG_VRML_SFNODE) {
GF_ChildNodeItem *list = *(GF_ChildNodeItem **)field.far_ptr;
gf_fprintf(sdump->trace, "">\n"");
sdump->indent++;
if (!sdump->X3DDump) gf_fprintf(sdump->trace, ""<nodes>"");
while (list) {
gf_dump_vrml_node(sdump, list->node, 1, NULL);
list = list->next;
}
if (!sdump->X3DDump) gf_fprintf(sdump->trace, ""</nodes>"");
sdump->indent++;
DUMP_IND(sdump);
if (!has_sublist)
gf_fprintf(sdump->trace, ""</field>\n"");
} else {
if (sdump->X3DDump) {
gf_fprintf(sdump->trace, "" value=\"""");
} else {
gf_fprintf(sdump->trace, "" %s=\"""", GetXMTFieldTypeValueName(field.fieldType));
}
for (i=0; i<mffield->count; i++) {
if (i) gf_fprintf(sdump->trace, "" "");
if (field.fieldType != GF_SG_VRML_MFNODE) {
gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);
gf_dump_vrml_sffield(sdump, sf_type, slot_ptr, (mffield->count>1) ? 1 : 0, node);
}
}
if (has_sublist)
gf_fprintf(sdump->trace, ""\"">\n"");
else
gf_fprintf(sdump->trace, ""\""/>\n"");
}
} else {
gf_fprintf(sdump->trace, ""/>\n"");
}
}
}
}","[83, 123]",NULL Pointer Dereference in GitHub repository gpac/gpac prior to v2.1.0-DEV.,gpac,CVE-2022-2549,CWE-476
8321,8052,"GF_Err stbl_AddChunkOffset(GF_MediaBox *mdia, u32 sampleNumber, u32 StreamDescIndex, u64 offset, u32 nb_pack_samples)
{
GF_SampleTableBox *stbl;
GF_ChunkOffsetBox *stco;
GF_SampleToChunkBox *stsc;
GF_ChunkLargeOffsetBox *co64;
GF_StscEntry *ent;
u32 i, k, *newOff, new_chunk_idx=0;
u64 *newLarge;
s32 insert_idx = -1;
stbl = mdia->information->sampleTable;
stsc = stbl->SampleToChunk;
if (!nb_pack_samples)
nb_pack_samples = 1;
if (!stsc->nb_entries || (stsc->nb_entries + 2 >= stsc->alloc_size)) {
if (!stsc->alloc_size) stsc->alloc_size = 1;
ALLOC_INC(stsc->alloc_size);
stsc->entries = gf_realloc(stsc->entries, sizeof(GF_StscEntry)*stsc->alloc_size);
if (!stsc->entries) return GF_OUT_OF_MEM;
memset(&stsc->entries[stsc->nb_entries], 0, sizeof(GF_StscEntry)*(stsc->alloc_size-stsc->nb_entries) );
}
if (sampleNumber == stsc->w_lastSampleNumber + 1) {
ent = &stsc->entries[stsc->nb_entries];
stsc->w_lastChunkNumber ++;
ent->firstChunk = stsc->w_lastChunkNumber;
if (stsc->nb_entries) stsc->entries[stsc->nb_entries-1].nextChunk = stsc->w_lastChunkNumber;
new_chunk_idx = stsc->w_lastChunkNumber;
stsc->w_lastSampleNumber = sampleNumber + nb_pack_samples-1;
stsc->nb_entries += 1;
} else {
u32 cur_samp = 1;
u32 samples_in_next_entry = 0;
u32 next_entry_first_chunk = 1;
for (i=0; i<stsc->nb_entries; i++) {
u32 nb_chunks = 1;
ent = &stsc->entries[i];
if (i+1<stsc->nb_entries) nb_chunks = stsc->entries[i+1].firstChunk - ent->firstChunk;
for (k=0; k<nb_chunks; k++) {
if ((cur_samp <= sampleNumber) && (ent->samplesPerChunk + cur_samp > sampleNumber)) {
insert_idx = i;
if (sampleNumber>cur_samp) {
samples_in_next_entry = ent->samplesPerChunk - (sampleNumber-cur_samp);
ent->samplesPerChunk = sampleNumber-cur_samp;
}
break;
}
cur_samp += ent->samplesPerChunk;
next_entry_first_chunk++;
}
if (insert_idx>=0) break;
}
if (samples_in_next_entry) {
memmove(&stsc->entries[insert_idx+3], &stsc->entries[insert_idx+1], sizeof(GF_StscEntry)*(stsc->nb_entries - insert_idx - 1));
ent = &stsc->entries[insert_idx];
stsc->entries[insert_idx+2] = *ent;
stsc->entries[insert_idx+2].samplesPerChunk = samples_in_next_entry;
stsc->entries[insert_idx+2].firstChunk = next_entry_first_chunk + 1;
ent = &stsc->entries[insert_idx+1];
ent->firstChunk = next_entry_first_chunk;
stsc->nb_entries += 2;
} else {
if (insert_idx<0) {
ent = &stsc->entries[stsc->nb_entries];
insert_idx = stsc->nb_entries;
} else {
memmove(&stsc->entries[insert_idx+1], &stsc->entries[insert_idx], sizeof(GF_StscEntry)*(stsc->nb_entries+1-insert_idx));
ent = &stsc->entries[insert_idx+1];
}
ent->firstChunk = next_entry_first_chunk;
stsc->nb_entries += 1;
}
new_chunk_idx = next_entry_first_chunk;
}
ent->isEdited = (Media_IsSelfContained(mdia, StreamDescIndex)) ? 1 : 0;
ent->sampleDescriptionIndex = StreamDescIndex;
ent->samplesPerChunk = nb_pack_samples;
ent->nextChunk = ent->firstChunk+1;
if (sampleNumber + nb_pack_samples - 1 == stsc->w_lastSampleNumber) {
if (stsc->nb_entries)
stsc->entries[stsc->nb_entries-1].nextChunk = ent->firstChunk;
stbl->SampleToChunk->currentIndex = stsc->nb_entries-1;
stbl->SampleToChunk->firstSampleInCurrentChunk = sampleNumber;
stbl->SampleToChunk->currentChunk = stsc->w_lastChunkNumber;
stbl->SampleToChunk->ghostNumber = 1;
} else {
for (i = insert_idx+1; i<stsc->nb_entries+1; i++) {
stsc->entries[i].firstChunk++;
if (i+1<stsc->nb_entries)
stsc->entries[i-1].nextChunk = stsc->entries[i].firstChunk;
}
}
if (stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {
stco = (GF_ChunkOffsetBox *)stbl->ChunkOffset;
if (offset > 0xFFFFFFFF) {
co64 = (GF_ChunkLargeOffsetBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_CO64);
if (!co64) return GF_OUT_OF_MEM;
co64->nb_entries = stco->nb_entries + 1;
co64->alloc_size = co64->nb_entries;
co64->offsets = (u64*)gf_malloc(sizeof(u64) * co64->nb_entries);
if (!co64->offsets) return GF_OUT_OF_MEM;
k = 0;
for (i=0; i<stco->nb_entries; i++) {
if (i + 1 == new_chunk_idx) {
co64->offsets[i] = offset;
k = 1;
}
co64->offsets[i+k] = (u64) stco->offsets[i];
}
if (!k) co64->offsets[co64->nb_entries - 1] = offset;
gf_isom_box_del_parent(&stbl->child_boxes, stbl->ChunkOffset);
stbl->ChunkOffset = (GF_Box *) co64;
} else {
if (new_chunk_idx > stco->nb_entries) {
if (!stco->alloc_size) stco->alloc_size = stco->nb_entries;
if (stco->nb_entries == stco->alloc_size) {
ALLOC_INC(stco->alloc_size);
stco->offsets = (u32*)gf_realloc(stco->offsets, sizeof(u32) * stco->alloc_size);
if (!stco->offsets) return GF_OUT_OF_MEM;
memset(&stco->offsets[stco->nb_entries], 0, sizeof(u32) * (stco->alloc_size-stco->nb_entries) );
}
stco->offsets[stco->nb_entries] = (u32) offset;
stco->nb_entries += 1;
} else {
newOff = (u32*)gf_malloc(sizeof(u32) * (stco->nb_entries + 1));
if (!newOff) return GF_OUT_OF_MEM;
k=0;
for (i=0; i<stco->nb_entries; i++) {
if (i+1 == new_chunk_idx) {
newOff[i] = (u32) offset;
k=1;
}
newOff[i+k] = stco->offsets[i];
}
gf_free(stco->offsets);
stco->offsets = newOff;
stco->nb_entries ++;
stco->alloc_size = stco->nb_entries;
}
}
} else {
co64 = (GF_ChunkLargeOffsetBox *)stbl->ChunkOffset;
if (sampleNumber > co64->nb_entries) {
if (!co64->alloc_size) co64->alloc_size = co64->nb_entries;
if (co64->nb_entries == co64->alloc_size) {
ALLOC_INC(co64->alloc_size);
co64->offsets = (u64*)gf_realloc(co64->offsets, sizeof(u64) * co64->alloc_size);
if (!co64->offsets) return GF_OUT_OF_MEM;
memset(&co64->offsets[co64->nb_entries], 0, sizeof(u64) * (co64->alloc_size - co64->nb_entries) );
}
co64->offsets[co64->nb_entries] = offset;
co64->nb_entries += 1;
} else {
newLarge = (u64*)gf_malloc(sizeof(u64) * (co64->nb_entries + 1));
if (!newLarge) return GF_OUT_OF_MEM;
k=0;
for (i=0; i<co64->nb_entries; i++) {
if (i+1 == new_chunk_idx) {
newLarge[i] = offset;
k=1;
}
newLarge[i+k] = co64->offsets[i];
}
gf_free(co64->offsets);
co64->offsets = newLarge;
co64->nb_entries++;
co64->alloc_size++;
}
}
return GF_OK;
}","[13, 14, 28, 76, 78]",Buffer overflow in the stbl_AppendSize function in MP4Box in GPAC 1.0.1 allows attackers to cause a denial of service or execute arbitrary code via a crafted file.,gpac,CVE-2021-32439,CWE-120
8323,9650,"static int vidioc_querycap(struct file *file, void *priv,
struct v4l2_capability *cap)
{
struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
int labellen = (sizeof(cap->card) < sizeof(dev->card_label)) ?
sizeof(cap->card) :
sizeof(dev->card_label);
int device_nr =
((struct v4l2loopback_private *)video_get_drvdata(dev->vdev))
->device_nr;
__u32 capabilities = V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;
strlcpy(cap->driver, ""v4l2 loopback"", sizeof(cap->driver));
snprintf(cap->card, labellen, dev->card_label);
snprintf(cap->bus_info, sizeof(cap->bus_info),
""platform:v4l2loopback-%03d"", device_nr);
#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 1, 0)
cap->version = V4L2LOOPBACK_VERSION_CODE;
#endif
#ifdef V4L2_CAP_VIDEO_M2M
capabilities |= V4L2_CAP_VIDEO_M2M;
#endif /* V4L2_CAP_VIDEO_M2M */
if (dev->announce_all_caps) {
capabilities |= V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_OUTPUT;
} else {
if (dev->ready_for_capture) {
capabilities |= V4L2_CAP_VIDEO_CAPTURE;
}
if (dev->ready_for_output) {
capabilities |= V4L2_CAP_VIDEO_OUTPUT;
}
}
#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
dev->vdev->device_caps =
#endif /* >=linux-4.7.0 */
cap->device_caps = cap->capabilities = capabilities;
#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0)
cap->capabilities |= V4L2_CAP_DEVICE_CAPS;
#endif
memset(cap->reserved, 0, sizeof(cap->reserved));
return 0;
}",[13],Depending on the way the format strings in the card label are crafted it's possible to leak kernel stack memory. There is also the possibility for DoS due to the v4l2loopback kernel module crashing when providing the card label on request (reproduce e.g. with many %s modifiers in a row).,v4l2loopback,CVE-2022-2652,CWE-134
8327,6156,"PackLinuxElf64::invert_pt_dynamic(Elf64_Dyn const *dynp)
{
if (dt_table[Elf64_Dyn::DT_NULL]) {
return;
}
Elf64_Dyn const *const dynp0 = dynp;
unsigned ndx = 1+ 0;
if (dynp)
for (; ; ++ndx, ++dynp) {
upx_uint64_t const d_tag = get_te64(&dynp->d_tag);
if (d_tag>>32) {
char msg[50]; snprintf(msg, sizeof(msg),
""bad Elf64_Dyn[%d].d_tag %#lx"", -1+ ndx, (long unsigned)d_tag);
throwCantPack(msg);
}
if (d_tag < DT_NUM) {
dt_table[d_tag] = ndx;
}
if (Elf64_Dyn::DT_NULL == d_tag) {
break;
}
}
upx_dt_init = 0;
if (dt_table[Elf64_Dyn::DT_INIT])          upx_dt_init = Elf64_Dyn::DT_INIT;
else if (dt_table[Elf64_Dyn::DT_PREINIT_ARRAY]) upx_dt_init = Elf64_Dyn::DT_PREINIT_ARRAY;
else if (dt_table[Elf64_Dyn::DT_INIT_ARRAY])    upx_dt_init = Elf64_Dyn::DT_INIT_ARRAY;
unsigned const z_str = dt_table[Elf64_Dyn::DT_STRSZ];
if (z_str) {
strtab_end = get_te64(&dynp0[-1+ z_str].d_val);
if ((u64_t)file_size <= strtab_end) {
char msg[50]; snprintf(msg, sizeof(msg),
""bad DT_STRSZ %#x"", strtab_end);
throwCantPack(msg);
}
}
unsigned const x_sym = dt_table[Elf64_Dyn::DT_SYMTAB];
unsigned const x_str = dt_table[Elf64_Dyn::DT_STRTAB];
if (x_sym && x_str) {
upx_uint64_t const v_sym = get_te64(&dynp0[-1+ x_sym].d_val);
upx_uint64_t const v_str = get_te64(&dynp0[-1+ x_str].d_val);
unsigned const  z_sym = dt_table[Elf64_Dyn::DT_SYMENT];
unsigned const sz_sym = !z_sym ? sizeof(Elf64_Sym)
: get_te64(&dynp0[-1+ z_sym].d_val);
if (v_sym < v_str) {
symnum_end = (v_str - v_sym) / sz_sym;
}
}
unsigned const v_hsh = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH);
if (v_hsh && file_image) {
hashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_HASH);
unsigned const nbucket = get_te32(&hashtab[0]);
unsigned const *const buckets = &hashtab[2];
unsigned const *const chains = &buckets[nbucket]; (void)chains;
unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);
if (!nbucket
|| (nbucket>>31) || (file_size/sizeof(unsigned)) <= (2*nbucket)
|| ((v_hsh < v_sym) && (v_sym - v_hsh) < (sizeof(unsigned)*2
+ sizeof(*buckets)*nbucket
+ sizeof(*chains) *nbucket
))
) {
char msg[90]; snprintf(msg, sizeof(msg),
""bad DT_HASH nbucket=%#x  len=%#x"",
nbucket, (v_sym - v_hsh));
throwCantPack(msg);
}
}
unsigned const v_gsh = elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH);
if (v_gsh && file_image) {
gashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_GNU_HASH);
unsigned const n_bucket = get_te32(&gashtab[0]);
unsigned const n_bitmask = get_te32(&gashtab[2]);
unsigned const gnu_shift = get_te32(&gashtab[3]);
upx_uint64_t const *const bitmask = (upx_uint64_t const *)(void const *)&gashtab[4];
unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask];
unsigned     const *const hasharr = &buckets[n_bucket]; (void)hasharr;
upx_uint64_t const v_sym = get_te64(&dynp0[-1+ x_sym].d_val);
if (!n_bucket || !n_bitmask
|| (-1+ n_bitmask) & n_bitmask
|| 8*sizeof(upx_uint64_t) <= gnu_shift
|| (n_bucket>>30)
|| (n_bitmask>>30)
|| (file_size/sizeof(unsigned)) <= ((sizeof(*bitmask)/sizeof(unsigned))*n_bitmask + 2*n_bucket)
|| ((v_gsh < v_sym) && (v_sym - v_gsh) < (sizeof(unsigned)*4
+ sizeof(*bitmask)*n_bitmask
+ sizeof(*buckets)*n_bucket
+ sizeof(*hasharr)*n_bucket
))
) {
char msg[90]; snprintf(msg, sizeof(msg),
""bad DT_GNU_HASH n_bucket=%#x  n_bitmask=%#x  len=%#lx"",
n_bucket, n_bitmask, (long unsigned)(v_sym - v_gsh));
throwCantPack(msg);
}
}
unsigned const e_shstrndx = get_te16(&ehdri.e_shstrndx);
if (e_shnum <= e_shstrndx
&&  !(0==e_shnum && 0==e_shstrndx) ) {
char msg[40]; snprintf(msg, sizeof(msg),
""bad .e_shstrndx %d >= .e_shnum %d"", e_shstrndx, e_shnum);
throwCantPack(msg);
}
}","[17, 51, 71]",p_lx_elf.cpp in UPX before 3.96 has an integer overflow during unpacking via crafted values in a PT_DYNAMIC segment.,upx,CVE-2019-20805,CWE-190
8330,3923,"flac_buffer_copy (SF_PRIVATE *psf)
{ FLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;
const FLAC__Frame *frame = pflac->frame ;
const int32_t* const *buffer = pflac->wbuffer ;
unsigned i = 0, j, offset, channels, len ;
if (frame->header.blocksize > FLAC__MAX_BLOCK_SIZE)
{ psf_log_printf (psf, ""Ooops : frame->header.blocksize (%d) > FLAC__MAX_BLOCK_SIZE (%d)\n"", __func__, __LINE__, frame->header.blocksize, FLAC__MAX_BLOCK_SIZE) ;
psf->error = SFE_INTERNAL ;
return 0 ;
} ;
if (frame->header.channels > FLAC__MAX_CHANNELS)
psf_log_printf (psf, ""Ooops : frame->header.channels (%d) > FLAC__MAX_BLOCK_SIZE (%d)\n"", __func__, __LINE__, frame->header.channels, FLAC__MAX_CHANNELS) ;
channels = SF_MIN (frame->header.channels, FLAC__MAX_CHANNELS) ;
if (pflac->ptr == NULL)
{
pflac->bufferbackup = SF_TRUE ;
for (i = 0 ; i < channels ; i++)
{
if (pflac->rbuffer [i] == NULL)
pflac->rbuffer [i] = calloc (FLAC__MAX_BLOCK_SIZE, sizeof (int32_t)) ;
memcpy (pflac->rbuffer [i], buffer [i], frame->header.blocksize * sizeof (int32_t)) ;
} ;
pflac->wbuffer = (const int32_t* const*) pflac->rbuffer ;
return 0 ;
} ;
len = SF_MIN (pflac->len, frame->header.blocksize) ;
switch (pflac->pcmtype)
{ case PFLAC_PCM_SHORT :
{ short *retpcm = (short*) pflac->ptr ;
int shift = 16 - frame->header.bits_per_sample ;
if (shift < 0)
{ shift = abs (shift) ;
for (i = 0 ; i < len && pflac->remain > 0 ; i++)
{ offset = pflac->pos + i * channels ;
if (pflac->bufferpos >= frame->header.blocksize)
break ;
if (offset + channels > pflac->len)
break ;
for (j = 0 ; j < channels ; j++)
retpcm [offset + j] = buffer [j][pflac->bufferpos] >> shift ;
pflac->remain -= channels ;
pflac->bufferpos++ ;
}
}
else
{ for (i = 0 ; i < len && pflac->remain > 0 ; i++)
{ offset = pflac->pos + i * channels ;
if (pflac->bufferpos >= frame->header.blocksize)
break ;
if (offset + channels > pflac->len)
break ;
for (j = 0 ; j < channels ; j++)
retpcm [offset + j] = ((uint16_t) buffer [j][pflac->bufferpos]) << shift ;
pflac->remain -= channels ;
pflac->bufferpos++ ;
} ;
} ;
} ;
break ;
case PFLAC_PCM_INT :
{ int *retpcm = (int*) pflac->ptr ;
int shift = 32 - frame->header.bits_per_sample ;
for (i = 0 ; i < len && pflac->remain > 0 ; i++)
{ offset = pflac->pos + i * channels ;
if (pflac->bufferpos >= frame->header.blocksize)
break ;
if (offset + channels > pflac->len)
break ;
for (j = 0 ; j < channels ; j++)
retpcm [offset + j] = ((uint32_t) buffer [j][pflac->bufferpos]) << shift ;
pflac->remain -= channels ;
pflac->bufferpos++ ;
} ;
} ;
break ;
case PFLAC_PCM_FLOAT :
{ float *retpcm = (float*) pflac->ptr ;
float norm = (psf->norm_float == SF_TRUE) ? 1.0 / (1 << (frame->header.bits_per_sample - 1)) : 1.0 ;
for (i = 0 ; i < len && pflac->remain > 0 ; i++)
{ offset = pflac->pos + i * channels ;
if (pflac->bufferpos >= frame->header.blocksize)
break ;
if (offset + channels > pflac->len)
break ;
for (j = 0 ; j < channels ; j++)
retpcm [offset + j] = buffer [j][pflac->bufferpos] * norm ;
pflac->remain -= channels ;
pflac->bufferpos++ ;
} ;
} ;
break ;
case PFLAC_PCM_DOUBLE :
{ double *retpcm = (double*) pflac->ptr ;
double norm = (psf->norm_double == SF_TRUE) ? 1.0 / (1 << (frame->header.bits_per_sample - 1)) : 1.0 ;
for (i = 0 ; i < len && pflac->remain > 0 ; i++)
{ offset = pflac->pos + i * channels ;
if (pflac->bufferpos >= frame->header.blocksize)
break ;
if (offset + channels > pflac->len)
break ;
for (j = 0 ; j < channels ; j++)
retpcm [offset + j] = buffer [j][pflac->bufferpos] * norm ;
pflac->remain -= channels ;
pflac->bufferpos++ ;
} ;
} ;
break ;
default :
return 0 ;
} ;
offset = i * channels ;
pflac->pos += i * channels ;
return offset ;
}","[16, 27]","In libsndfile before 1.0.28, an error in the ""flac_buffer_copy()"" function (flac.c) can be exploited to cause a stack-based buffer overflow via a specially crafted FLAC file.",libsndfile,CVE-2017-7585,CWE-119
8334,7995,"int PackLinuxElf32::canUnpack()
{
if (super::canUnpack()) {
return true;
}
if (Elf32_Ehdr::ET_DYN==get_te16(&ehdri.e_type)) {
PackLinuxElf32help1(fi);
}
return false;
}","[3, 4, 6, 9]","Null pointer dereference was found in upx PackLinuxElf::canUnpack() in p_lx_elf.cpp,in version UPX 4.0.0. That allow attackers to execute arbitrary code and cause a denial of service via a crafted file.",upx,CVE-2021-30500,CWE-476
8344,5707,"size_t OpenMP4SourceUDTA(char *filename)
{
mp4object *mp4 = (mp4object *)malloc(sizeof(mp4object));
if (mp4 == NULL) return 0;
memset(mp4, 0, sizeof(mp4object));
#ifdef _WINDOWS
fopen_s(&mp4->mediafp, filename, ""rb"");
#else
mp4->mediafp = fopen(filename, ""rb"");
#endif
if (mp4->mediafp)
{
uint32_t qttag, qtsize32, len;
int32_t nest = 0;
uint64_t nestsize[MAX_NEST_LEVEL] = { 0 };
uint64_t lastsize = 0, qtsize;
do
{
len = fread(&qtsize32, 1, 4, mp4->mediafp);
len += fread(&qttag, 1, 4, mp4->mediafp);
if (len == 8)
{
if (!GPMF_VALID_FOURCC(qttag))
{
LONGSEEK(mp4->mediafp, lastsize - 8 - 8, SEEK_CUR);
NESTSIZE(lastsize - 8);
continue;
}
qtsize32 = BYTESWAP32(qtsize32);
if (qtsize32 == 1)
{
fread(&qtsize, 1, 8, mp4->mediafp);
qtsize = BYTESWAP64(qtsize) - 8;
}
else
qtsize = qtsize32;
nest++;
if (qtsize < 8) break;
if (nest >= MAX_NEST_LEVEL) break;
nestsize[nest] = qtsize;
lastsize = qtsize;
if (qttag == MAKEID('m', 'd', 'a', 't') ||
qttag == MAKEID('f', 't', 'y', 'p'))
{
LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
NESTSIZE(qtsize);
continue;
}
if (qttag == MAKEID('G', 'P', 'M', 'F'))
{
mp4->videolength += 1.0;
mp4->metadatalength += 1.0;
mp4->indexcount = (int)mp4->metadatalength;
mp4->metasizes = (uint32_t *)malloc(mp4->indexcount * 4 + 4);  memset(mp4->metasizes, 0, mp4->indexcount * 4 + 4);
mp4->metaoffsets = (uint64_t *)malloc(mp4->indexcount * 8 + 8);  memset(mp4->metaoffsets, 0, mp4->indexcount * 8 + 8);
mp4->metasizes[0] = (int)qtsize - 8;
mp4->metaoffsets[0] = ftell(mp4->mediafp);
mp4->metasize_count = 1;
return (size_t)mp4;
}
if (qttag != MAKEID('m', 'o', 'o', 'v') &&
qttag != MAKEID('u', 'd', 't', 'a'))
{
LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);
NESTSIZE(qtsize);
continue;
}
else
{
NESTSIZE(8);
}
}
} while (len > 0);
}
return (size_t)mp4;
}","[13, 25, 45, 64]",GoPro GPMF-parser 1.2.2 has a heap-based buffer over-read (4 bytes) in GPMF_Next in GPMF_parser.c.,gpmf-parser,CVE-2019-15146,CWE-125
8356,5444,"Error HeifContext::interpret_heif_file()
{
m_all_images.clear();
m_top_level_images.clear();
m_primary_image.reset();
std::vector<heif_item_id> image_IDs = m_heif_file->get_item_IDs();
bool primary_is_grid = false;
for (heif_item_id id : image_IDs) {
auto infe_box = m_heif_file->get_infe_box(id);
if (!infe_box) {
continue;
}
if (item_type_is_image(infe_box->get_item_type())) {
auto image = std::make_shared<Image>(this, id);
m_all_images.insert(std::make_pair(id, image));
if (!infe_box->is_hidden_item()) {
if (id==m_heif_file->get_primary_image_ID()) {
image->set_primary(true);
m_primary_image = image;
primary_is_grid = infe_box->get_item_type() == ""grid"";
}
m_top_level_images.push_back(image);
}
}
}
if (!m_primary_image) {
return Error(heif_error_Invalid_input,
heif_suberror_Nonexisting_item_referenced,
""'pitm' box references a non-existing image"");
}
auto iref_box = m_heif_file->get_iref_box();
if (iref_box) {
for (auto& pair : m_all_images) {
auto& image = pair.second;
std::vector<Box_iref::Reference> references = iref_box->get_references_from(image->get_id());
for (const Box_iref::Reference& ref : references) {
uint32_t type = ref.header.get_short_type();
if (type==fourcc(""thmb"")) {
std::vector<heif_item_id> refs = ref.to_item_ID;
if (refs.size() != 1) {
return Error(heif_error_Invalid_input,
heif_suberror_Unspecified,
""Too many thumbnail references"");
}
image->set_is_thumbnail_of(refs[0]);
auto master_iter = m_all_images.find(refs[0]);
if (master_iter == m_all_images.end()) {
return Error(heif_error_Invalid_input,
heif_suberror_Nonexisting_item_referenced,
""Thumbnail references a non-existing image"");
}
if (master_iter->second->is_thumbnail()) {
return Error(heif_error_Invalid_input,
heif_suberror_Nonexisting_item_referenced,
""Thumbnail references another thumbnail"");
}
if (image.get() == master_iter->second.get()) {
return Error(heif_error_Invalid_input,
heif_suberror_Nonexisting_item_referenced,
""Recursive thumbnail image detected"");
}
master_iter->second->add_thumbnail(image);
remove_top_level_image(image);
}
else if (type==fourcc(""auxl"")) {
std::vector<Box_ipco::Property> properties;
Error err = m_heif_file->get_properties(image->get_id(), properties);
if (err) {
return err;
}
std::shared_ptr<Box_auxC> auxC_property;
for (const auto& property : properties) {
auto auxC = std::dynamic_pointer_cast<Box_auxC>(property.property);
if (auxC) {
auxC_property = auxC;
}
}
if (!auxC_property) {
std::stringstream sstr;
sstr << ""No auxC property for image "" << image->get_id();
return Error(heif_error_Invalid_input,
heif_suberror_Auxiliary_image_type_unspecified,
sstr.str());
}
std::vector<heif_item_id> refs = ref.to_item_ID;
if (refs.size() != 1) {
return Error(heif_error_Invalid_input,
heif_suberror_Unspecified,
""Too many auxiliary image references"");
}
if (auxC_property->get_aux_type() == ""urn:mpeg:avc:2015:auxid:1"" ||
auxC_property->get_aux_type() == ""urn:mpeg:hevc:2015:auxid:1"") {
image->set_is_alpha_channel_of(refs[0]);
auto master_iter = m_all_images.find(refs[0]);
if (image.get() == master_iter->second.get()) {
return Error(heif_error_Invalid_input,
heif_suberror_Nonexisting_item_referenced,
""Recursive alpha image detected"");
}
master_iter->second->set_alpha_channel(image);
}
if (auxC_property->get_aux_type() == ""urn:mpeg:hevc:2015:auxid:2"") {
image->set_is_depth_channel_of(refs[0]);
auto master_iter = m_all_images.find(refs[0]);
if (image.get() == master_iter->second.get()) {
return Error(heif_error_Invalid_input,
heif_suberror_Nonexisting_item_referenced,
""Recursive depth image detected"");
}
master_iter->second->set_depth_channel(image);
auto subtypes = auxC_property->get_subtypes();
std::vector<std::shared_ptr<SEIMessage>> sei_messages;
Error err = decode_hevc_aux_sei_messages(subtypes, sei_messages);
for (auto& msg : sei_messages) {
auto depth_msg = std::dynamic_pointer_cast<SEIMessage_depth_representation_info>(msg);
if (depth_msg) {
image->set_depth_representation_info(*depth_msg);
}
}
}
remove_top_level_image(image);
}
else {
}
}
}
}
for (auto& pair : m_all_images) {
auto& image = pair.second;
std::shared_ptr<Box_infe> infe = m_heif_file->get_infe_box(image->get_id());
if (infe->get_item_type() == ""hvc1"") {
auto ipma = m_heif_file->get_ipma_box();
auto ipco = m_heif_file->get_ipco_box();
if (!ipco->get_property_for_item_ID(image->get_id(), ipma, fourcc(""hvcC""))) {
return Error(heif_error_Invalid_input,
heif_suberror_No_hvcC_box,
""No hvcC property in hvc1 type image"");
}
}
}
for (auto& pair : m_all_images) {
auto& image = pair.second;
std::vector<Box_ipco::Property> properties;
Error err = m_heif_file->get_properties(pair.first, properties);
if (err) {
return err;
}
bool ispe_read = false;
bool primary_colr_set = false;
for (const auto& prop : properties) {
auto ispe = std::dynamic_pointer_cast<Box_ispe>(prop.property);
if (ispe) {
uint32_t width = ispe->get_width();
uint32_t height = ispe->get_height();
if (width  >= static_cast<uint32_t>(MAX_IMAGE_WIDTH) ||
height >= static_cast<uint32_t>(MAX_IMAGE_HEIGHT)) {
std::stringstream sstr;
sstr << ""Image size "" << width << ""x"" << height << "" exceeds the maximum image size ""
<< MAX_IMAGE_WIDTH << ""x"" << MAX_IMAGE_HEIGHT << ""\n"";
return Error(heif_error_Memory_allocation_error,
heif_suberror_Security_limit_exceeded,
sstr.str());
}
image->set_resolution(width, height);
image->set_ispe_resolution(width, height);
ispe_read = true;
}
if (ispe_read) {
auto clap = std::dynamic_pointer_cast<Box_clap>(prop.property);
if (clap) {
image->set_resolution( clap->get_width_rounded(),
clap->get_height_rounded() );
}
auto irot = std::dynamic_pointer_cast<Box_irot>(prop.property);
if (irot) {
if (irot->get_rotation()==90 ||
irot->get_rotation()==270) {
image->set_resolution( image->get_height(),
image->get_width() );
}
}
}
auto colr = std::dynamic_pointer_cast<Box_colr>(prop.property);
if (colr) {
auto profile = colr->get_color_profile();
image->set_color_profile(profile);
const bool is_grid_item = !image->is_primary() && !image->is_alpha_channel() && !image->is_depth_channel();
if (primary_is_grid &&
!primary_colr_set &&
is_grid_item) {
m_primary_image->set_color_profile(profile);
primary_colr_set = true;
}
}
}
}
for (heif_item_id id : image_IDs) {
std::string item_type    = m_heif_file->get_item_type(id);
std::string content_type = m_heif_file->get_content_type(id);
if (item_type == ""Exif"" ||
(item_type==""mime"" && content_type==""application/rdf+xml"")) {
std::shared_ptr<ImageMetadata> metadata = std::make_shared<ImageMetadata>();
metadata->item_id = id;
metadata->item_type = item_type;
metadata->content_type = content_type;
Error err = m_heif_file->get_compressed_image_data(id, &(metadata->m_data));
if (err) {
return err;
}
if (iref_box) {
std::vector<Box_iref::Reference> references = iref_box->get_references_from(id);
for (const auto& ref : references) {
if (ref.header.get_short_type() == fourcc(""cdsc"")) {
std::vector<uint32_t> refs = ref.to_item_ID;
if (refs.size() != 1) {
return Error(heif_error_Invalid_input,
heif_suberror_Unspecified,
""Exif data not correctly assigned to image"");
}
uint32_t exif_image_id = refs[0];
auto img_iter = m_all_images.find(exif_image_id);
if (img_iter == m_all_images.end()) {
return Error(heif_error_Invalid_input,
heif_suberror_Nonexisting_item_referenced,
""Exif data assigned to non-existing image"");
}
img_iter->second->add_metadata(metadata);
}
}
}
}
}
return Error::Ok;
}",[95],libheif 1.4.0 has a use-after-free in heif::HeifContext::Image::set_alpha_channel in heif_context.h because heif_context.cc mishandles references to non-existing alpha images.,libheif,CVE-2019-11471,CWE-416
8358,8483,"GF_Err mpgviddmx_process(GF_Filter *filter)
{
GF_MPGVidDmxCtx *ctx = gf_filter_get_udta(filter);
GF_FilterPacket *pck, *dst_pck;
u64 byte_offset;
s64 vosh_start = -1;
s64 vosh_end = -1;
GF_Err e;
char *data;
u8 *start;
u32 pck_size;
s32 remain;
if (!ctx->duration.num)
mpgviddmx_check_dur(filter, ctx);
pck = gf_filter_pid_get_packet(ctx->ipid);
if (!pck) {
if (gf_filter_pid_is_eos(ctx->ipid)) {
mpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_TRUE);
if (ctx->opid)
gf_filter_pid_set_eos(ctx->opid);
if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);
ctx->src_pck = NULL;
return GF_EOS;
}
return GF_OK;
}
data = (char *) gf_filter_pck_get_data(pck, &pck_size);
byte_offset = gf_filter_pck_get_byte_offset(pck);
start = data;
remain = pck_size;
if (!ctx->resume_from && ctx->timescale) {
u64 ts = gf_filter_pck_get_cts(pck);
if (ts != GF_FILTER_NO_TS) {
if (!ctx->cts || !ctx->recompute_cts)
ctx->cts = ts;
}
ts = gf_filter_pck_get_dts(pck);
if (ts != GF_FILTER_NO_TS) {
if (!ctx->dts || !ctx->recompute_cts)
ctx->dts = ts;
if (!ctx->prev_dts) ctx->prev_dts = ts;
else if (ctx->prev_dts != ts) {
u64 diff = ts;
diff -= ctx->prev_dts;
if (!ctx->cur_fps.den) ctx->cur_fps.den = (u32) diff;
else if (ctx->cur_fps.den > diff)
ctx->cur_fps.den = (u32) diff;
}
}
gf_filter_pck_get_framing(pck, &ctx->input_is_au_start, &ctx->input_is_au_end);
if (ctx->recompute_cts) ctx->input_is_au_start = GF_FALSE;
if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);
ctx->src_pck = pck;
gf_filter_pck_ref_props(&ctx->src_pck);
}
if (!ctx->resume_from && ctx->hdr_store_size) {
if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size) {
ctx->hdr_store_alloc = ctx->hdr_store_size + pck_size;
ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);
}
memcpy(ctx->hdr_store + ctx->hdr_store_size, data, sizeof(char)*pck_size);
if (byte_offset != GF_FILTER_NO_BO) {
if (byte_offset >= ctx->hdr_store_size)
byte_offset -= ctx->hdr_store_size;
else
byte_offset = GF_FILTER_NO_BO;
}
ctx->hdr_store_size += pck_size;
start = data = ctx->hdr_store;
remain = pck_size = ctx->hdr_store_size;
}
if (ctx->resume_from) {
if (gf_filter_pid_would_block(ctx->opid))
return GF_OK;
if (ctx->hdr_store_size) {
assert(ctx->resume_from <= ctx->hdr_store_size);
start = data = ctx->hdr_store + ctx->resume_from;
remain = pck_size = ctx->hdr_store_size - ctx->resume_from;
} else {
assert(remain >= (s32) ctx->resume_from);
start += ctx->resume_from;
remain -= ctx->resume_from;
}
ctx->resume_from = 0;
}
if (!ctx->bs) {
ctx->bs = gf_bs_new(start, remain, GF_BITSTREAM_READ);
} else {
gf_bs_reassign_buffer(ctx->bs, start, remain);
}
if (!ctx->vparser) {
ctx->vparser = gf_m4v_parser_bs_new(ctx->bs, ctx->is_mpg12);
}
while (remain) {
Bool full_frame;
u8 *pck_data;
s32 current;
u8 sc_type, forced_sc_type=0;
Bool sc_type_forced = GF_FALSE;
Bool skip_pck = GF_FALSE;
u8 ftype;
u32 tinc;
u64 size=0;
u64 fstart;
Bool is_coded;
u32 bytes_from_store = 0;
u32 hdr_offset = 0;
Bool copy_last_bytes = GF_FALSE;
if (remain<5) {
memcpy(ctx->hdr_store, start, remain);
ctx->bytes_in_header = remain;
break;
}
current = -1;
if (ctx->bytes_in_header) {
memcpy(ctx->hdr_store + ctx->bytes_in_header, start, 8 - ctx->bytes_in_header);
current = mpgviddmx_next_start_code(ctx->hdr_store, 8);
if ((current<0) || (current >= (s32) ctx->bytes_in_header) )  {
if (ctx->opid) {
dst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header, &pck_data);
if (!dst_pck) return GF_OUT_OF_MEM;
if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);
memcpy(pck_data, ctx->hdr_store, ctx->bytes_in_header);
gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);
if (byte_offset != GF_FILTER_NO_BO) {
gf_filter_pck_set_byte_offset(dst_pck, byte_offset - ctx->bytes_in_header);
}
mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
}
if (current<0) current = -1;
else current -= ctx->bytes_in_header;
ctx->bytes_in_header = 0;
} else {
hdr_offset = 4 - ctx->bytes_in_header + current;
bytes_from_store = ctx->bytes_in_header;
ctx->bytes_in_header = 0;
if (!hdr_offset) {
forced_sc_type = ctx->hdr_store[current+3];
} else {
forced_sc_type = start[hdr_offset-1];
}
sc_type_forced = GF_TRUE;
}
}
if (current == -1) {
current = mpgviddmx_next_start_code(start, remain);
if (current<0) {
u8 b3, b2, b1;
if (! ctx->frame_started) {
GF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (""[MPGVid] no start code in block and no frame started, discarding data\n"" ));
break;
}
size = remain;
b3 = start[remain-3];
b2 = start[remain-2];
b1 = start[remain-1];
if (!b1 || !b2 || !b3) {
copy_last_bytes = GF_TRUE;
assert(size >= 3);
size -= 3;
ctx->bytes_in_header = 3;
}
dst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data);
if (!dst_pck) return GF_OUT_OF_MEM;
if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
memcpy(pck_data, start, (size_t) size);
gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);
gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);
if (byte_offset != GF_FILTER_NO_BO) {
gf_filter_pck_set_byte_offset(dst_pck, byte_offset);
}
mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
if (copy_last_bytes) {
memcpy(ctx->hdr_store, start+remain-3, 3);
}
break;
}
}
assert(current>=0);
if ((vosh_start>=0) && current) {
assert(remain>=current);
start += current;
remain -= current;
current = 0;
}
if (!ctx->opid && current) {
assert(remain>=current);
start += current;
remain -= current;
current = 0;
}
if (current>0) {
dst_pck = gf_filter_pck_new_alloc(ctx->opid, current, &pck_data);
if (!dst_pck) return GF_OUT_OF_MEM;
if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);
gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_TRUE);
if (bytes_from_store) {
if (byte_offset != GF_FILTER_NO_BO) {
gf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store);
}
assert(bytes_from_store>=(u32) current);
bytes_from_store -= current;
memcpy(pck_data, ctx->hdr_store, current);
} else {
if (byte_offset != GF_FILTER_NO_BO) {
gf_filter_pck_set_byte_offset(dst_pck, byte_offset);
}
memcpy(pck_data, start, current);
assert(remain>=current);
start += current;
remain -= current;
current = 0;
}
gf_filter_pck_set_carousel_version(dst_pck, 1);
mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
}
if (sc_type_forced) {
gf_bs_reassign_buffer(ctx->bs, start + hdr_offset, remain - hdr_offset);
sc_type = forced_sc_type;
} else {
gf_bs_reassign_buffer(ctx->bs, start, remain);
gf_bs_read_int(ctx->bs, 24);
sc_type = gf_bs_read_int(ctx->bs, 8);
}
if (ctx->is_mpg12) {
switch (sc_type) {
case M2V_SEQ_START_CODE:
case M2V_EXT_START_CODE:
gf_bs_reassign_buffer(ctx->bs, start, remain);
e = gf_m4v_parse_config(ctx->vparser, &ctx->dsi);
if (e==GF_EOS) {
if (vosh_start<0) vosh_start = 0;
if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {
ctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - vosh_start);
ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);
}
memcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );
ctx->hdr_store_size += pck_size - (u32) vosh_start;
gf_filter_pid_drop_packet(ctx->ipid);
return GF_OK;
} else if (e != GF_OK) {
GF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (""[MPGVid] Failed to parse VOS header: %s\n"", gf_error_to_string(e) ));
} else {
mpgviddmx_check_pid(filter, ctx, 0, NULL);
}
break;
case M2V_PIC_START_CODE:
break;
default:
break;
}
} else {
u8 PL;
switch (sc_type) {
case M4V_VOS_START_CODE:
ctx->dsi.VideoPL = (u8) gf_bs_read_u8(ctx->bs);
vosh_start = start - (u8 *)data;
skip_pck = GF_TRUE;
assert(remain>=5);
start += 5;
remain -= 5;
break;
case M4V_VOL_START_CODE:
gf_bs_reassign_buffer(ctx->bs, start, remain);
PL = ctx->dsi.VideoPL;
e = gf_m4v_parse_config(ctx->vparser, &ctx->dsi);
ctx->dsi.VideoPL = PL;
if (e==GF_EOS) {
if (vosh_start<0) vosh_start = 0;
if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {
ctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - (u32) vosh_start);
ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);
}
memcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );
ctx->hdr_store_size += pck_size - (u32) vosh_start;
gf_filter_pid_drop_packet(ctx->ipid);
return GF_OK;
} else if (e != GF_OK) {
GF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (""[MPGVid] Failed to parse VOS header: %s\n"", gf_error_to_string(e) ));
} else {
u32 obj_size = (u32) gf_m4v_get_object_start(ctx->vparser);
if (vosh_start<0) vosh_start = 0;
vosh_end = start - (u8 *)data + obj_size;
vosh_end -= vosh_start;
mpgviddmx_check_pid(filter, ctx,(u32)  vosh_end, data+vosh_start);
skip_pck = GF_TRUE;
assert(remain>=(s32) obj_size);
start += obj_size;
remain -= obj_size;
}
break;
case M4V_VOP_START_CODE:
case M4V_GOV_START_CODE:
break;
case M4V_VO_START_CODE:
case M4V_VISOBJ_START_CODE:
default:
if (vosh_start>=0) {
skip_pck = GF_TRUE;
assert(remain>=4);
start += 4;
remain -= 4;
}
break;
}
}
if (skip_pck) {
continue;
}
if (!ctx->opid) {
assert(remain>=4);
start += 4;
remain -= 4;
continue;
}
if (!ctx->is_playing) {
ctx->resume_from = (u32) ((char *)start -  (char *)data);
return GF_OK;
}
ctx->hdr_store_size = 0;
if (ctx->in_seek) {
u64 nb_frames_at_seek = (u64) (ctx->start_range * ctx->cur_fps.num);
if (ctx->cts + ctx->cur_fps.den >= nb_frames_at_seek) {
ctx->in_seek = GF_FALSE;
}
}
if (remain<5)
continue;
gf_m4v_parser_reset(ctx->vparser, sc_type_forced ? forced_sc_type + 1 : 0);
size = 0;
e = gf_m4v_parse_frame(ctx->vparser, &ctx->dsi, &ftype, &tinc, &size, &fstart, &is_coded);
if (bytes_from_store) {
size += bytes_from_store + hdr_offset;
}
if ((e == GF_EOS) && !ctx->input_is_au_end) {
u8 b3 = start[remain-3];
u8 b2 = start[remain-2];
u8 b1 = start[remain-1];
if (!b1 || !b2 || !b3) {
copy_last_bytes = GF_TRUE;
assert(size >= 3);
size -= 3;
ctx->bytes_in_header = 3;
}
full_frame = GF_FALSE;
} else {
full_frame = GF_TRUE;
}
if (!is_coded) {
if (ctx->forced_packed && ctx->b_frames) {
ctx->is_packed = GF_TRUE;
assert(remain>=size);
start += size;
remain -= (s32) size;
continue;
}
if (ctx->vfr) {
ctx->is_vfr = GF_TRUE;
mpgviddmx_update_time(ctx);
assert(remain>=size);
start += size;
remain -= (s32) size;
continue;
}
}
if (ftype==2) {
ctx->b_frames++;
ctx->nb_b++;
} else {
mpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_FALSE);
ctx->last_ref_cts = ctx->cts;
if (ctx->max_b < ctx->b_frames) ctx->max_b = ctx->b_frames;
ctx->b_frames = 0;
if (ftype)
ctx->nb_p++;
else
ctx->nb_i++;
}
ctx->nb_frames++;
dst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data);
if (!dst_pck) return GF_OUT_OF_MEM;
if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
if (bytes_from_store) {
memcpy(pck_data, ctx->hdr_store+current, bytes_from_store);
assert(size >= bytes_from_store);
size -= bytes_from_store;
if (byte_offset != GF_FILTER_NO_BO) {
gf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store);
}
memcpy(pck_data + bytes_from_store, start, (size_t) size);
} else {
memcpy(pck_data, start, (size_t) size);
if (byte_offset != GF_FILTER_NO_BO) {
gf_filter_pck_set_byte_offset(dst_pck, byte_offset + start - (u8 *) data);
}
}
assert(pck_data[0] == 0);
assert(pck_data[1] == 0);
assert(pck_data[2] == 0x01);
gf_filter_pck_set_framing(dst_pck, GF_TRUE, (full_frame || ctx->input_is_au_end) ? GF_TRUE : GF_FALSE);
gf_filter_pck_set_cts(dst_pck, ctx->cts);
gf_filter_pck_set_dts(dst_pck, ctx->dts);
if (ctx->input_is_au_start) {
ctx->input_is_au_start = GF_FALSE;
} else {
gf_filter_pck_set_carousel_version(dst_pck, 1);
}
gf_filter_pck_set_sap(dst_pck, ftype ? GF_FILTER_SAP_NONE : GF_FILTER_SAP_1);
gf_filter_pck_set_duration(dst_pck, ctx->cur_fps.den);
if (ctx->in_seek) gf_filter_pck_set_seek_flag(dst_pck, GF_TRUE);
ctx->frame_started = GF_TRUE;
mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
mpgviddmx_update_time(ctx);
if (!full_frame) {
if (copy_last_bytes) {
memcpy(ctx->hdr_store, start+remain-3, 3);
}
break;
}
assert(remain>=size);
start += size;
remain -= (s32) size;
}
gf_filter_pid_drop_packet(ctx->ipid);
return GF_OK;
}","[238, 239, 240, 242, 243, 275, 276, 277, 279, 280]","A Segmentation fault casued by heap use after free vulnerability exists in Gpac through 1.0.1 via the mpgviddmx_process function in reframe_mpgvid.c when using mp4box, which causes a denial of service.",gpac,CVE-2021-40566,CWE-416
8374,8496,"void isor_reader_get_sample(ISOMChannel *ch)
{
GF_Err e;
u32 sample_desc_index;
if (ch->sample) return;
if (ch->next_track) {
ch->track = ch->next_track;
ch->next_track = 0;
}
if (ch->to_init) {
init_reader(ch);
sample_desc_index = ch->last_sample_desc_index;
} else if (ch->speed < 0) {
if (ch->last_state == GF_EOS) {
ch->sample = NULL;
return;
}
if (ch->static_sample->IsRAP) {
ch->last_rap_sample_time = ch->sample_time;
}
e = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + 1, &sample_desc_index, GF_ISOM_SEARCH_FORWARD, &ch->static_sample, &ch->sample_num, NULL);
if ((e==GF_EOS) || (ch->static_sample->IsRAP)) {
if (!ch->last_rap_sample_time) {
e = GF_EOS;
} else {
e = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->last_rap_sample_time - 1, &sample_desc_index, GF_ISOM_SEARCH_SYNC_BACKWARD, &ch->static_sample, &ch->sample_num, NULL);
}
}
if (e) {
if ((e==GF_EOS) && !ch->owner->frag_type) {
ch->last_state = GF_EOS;
}
ch->sample = NULL;
return;
}
ch->sample = ch->static_sample;
if (ch->sample->DTS == ch->sample_time) {
if (!ch->owner->frag_type) {
ch->last_state = GF_EOS;
}
}
if (ch->sample) {
ch->sample_time = ch->sample->DTS;
}
} else if (ch->has_edit_list) {
u32 prev_sample = ch->sample_num;
e = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + 1, &sample_desc_index, GF_ISOM_SEARCH_FORWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);
if (e == GF_OK) {
ch->sample = ch->static_sample;
if (ch->edit_sync_frame) {
ch->edit_sync_frame++;
if (ch->edit_sync_frame < ch->sample_num) {
ch->sample = gf_isom_get_sample_ex(ch->owner->mov, ch->track, ch->edit_sync_frame, &sample_desc_index, ch->static_sample, &ch->sample_data_offset);
ch->sample->DTS = ch->sample_time;
ch->sample->CTS_Offset = 0;
} else {
ch->edit_sync_frame = 0;
if (ch->sample) ch->sample_time = ch->sample->DTS;
}
} else {
if (prev_sample == ch->sample_num) {
if (ch->owner->frag_type && (ch->sample_num==gf_isom_get_sample_count(ch->owner->mov, ch->track))) {
ch->sample = NULL;
} else {
u32 sample_num = ch->sample_num ? ch->sample_num : 1;
if (sample_num >= gf_isom_get_sample_count(ch->owner->mov, ch->track) ) {
} else {
u32 time_diff = gf_isom_get_sample_duration(ch->owner->mov, ch->track, sample_num);
e = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + time_diff, &sample_desc_index, GF_ISOM_SEARCH_FORWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);
if (e==GF_OK) {
if (ch->sample_num == prev_sample) {
ch->sample_time += time_diff;
ch->sample = NULL;
return;
} else {
ch->sample = ch->static_sample;
}
}
}
}
}
if (ch->sample && !ch->sample->IsRAP && ch->has_rap && (ch->sample_num != prev_sample+1)) {
GF_ISOSample *found = ch->static_sample;
u32 samp_num = ch->sample_num;
ch->sample = NULL;
e = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + 1, &sample_desc_index, GF_ISOM_SEARCH_SYNC_BACKWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);
if (e == GF_OK) ch->sample = ch->static_sample;
if (!ch->sample || !ch->sample->data) {
ch->sample = ch->static_sample = found;
ch->sample_time = ch->sample->DTS;
ch->sample_num = samp_num;
} else {
ch->sample = ch->static_sample;
ch->edit_sync_frame = ch->sample_num;
ch->sample->DTS = ch->sample_time;
ch->sample->CTS_Offset = 0;
}
} else {
if (ch->sample) ch->sample_time = ch->sample->DTS;
}
}
}
} else {
Bool do_fetch = GF_TRUE;
ch->sample_num++;
if (ch->sap_only) {
Bool is_rap = gf_isom_get_sample_sync(ch->owner->mov, ch->track, ch->sample_num);
if (!is_rap) {
GF_ISOSampleRollType roll_type;
gf_isom_get_sample_rap_roll_info(ch->owner->mov, ch->track, ch->sample_num, &is_rap, &roll_type, NULL);
if (roll_type) is_rap = GF_TRUE;
}
if (!is_rap) {
do_fetch = GF_FALSE;
} else if (ch->sap_only==2) {
ch->sap_only = 0;
}
}
if (do_fetch) {
if (ch->owner->nodata) {
ch->sample = gf_isom_get_sample_info_ex(ch->owner->mov, ch->track, ch->sample_num, &sample_desc_index, &ch->sample_data_offset, ch->static_sample);
} else {
ch->sample = gf_isom_get_sample_ex(ch->owner->mov, ch->track, ch->sample_num, &sample_desc_index, ch->static_sample, &ch->sample_data_offset);
}
if (ch->sample && (ch->sample->IsRAP==RAP_REDUNDANT)) {
ch->sample = NULL;
ch->sample_num++;
isor_reader_get_sample(ch);
return;
}
}
}
if (ch->sample && ch->sample->IsRAP && ch->next_track) {
ch->track = ch->next_track;
ch->next_track = 0;
ch->sample = NULL;
isor_reader_get_sample(ch);
return;
}
if (!ch->sample) {
u32 sample_count = gf_isom_get_sample_count(ch->owner->mov, ch->track);
ch->sample_data_offset = 0;
if (gf_isom_get_missing_bytes(ch->owner->mov, ch->track)) {
ch->last_state = GF_ISOM_INCOMPLETE_FILE;
if (ch->owner->mem_load_mode==2)
ch->owner->force_fetch = GF_TRUE;
if (!ch->owner->input_loaded) {
ch->last_state = GF_OK;
if (!ch->has_edit_list && ch->sample_num)
ch->sample_num--;
} else {
if (ch->sample_num >= gf_isom_get_sample_count(ch->owner->mov, ch->track)) {
ch->last_state = GF_EOS;
}
}
}
else if (!ch->sample_num
|| ((ch->speed >= 0) && (ch->sample_num >= sample_count))
|| ((ch->speed < 0) && (ch->sample_time == gf_isom_get_current_tfdt(ch->owner->mov, ch->track) ))
) {
if (ch->owner->frag_type==1) {
if (ch->sample_num) ch->sample_num--;
ch->last_state = GF_EOS;
} else if (ch->last_state != GF_EOS) {
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[IsoMedia] Track #%d end of stream reached\n"", ch->track));
ch->last_state = GF_EOS;
if (ch->sample_num>sample_count) ch->sample_num = sample_count;
} else {
if (ch->sample_num>sample_count) ch->sample_num = sample_count;
}
} else {
e = gf_isom_last_error(ch->owner->mov);
GF_LOG((e==GF_ISOM_INCOMPLETE_FILE) ? GF_LOG_DEBUG : GF_LOG_WARNING, GF_LOG_DASH, (""[IsoMedia] Track #%d fail to fetch sample %d / %d: %s\n"", ch->track, ch->sample_num, gf_isom_get_sample_count(ch->owner->mov, ch->track), gf_error_to_string(e) ));
}
return;
}
if (sample_desc_index != ch->last_sample_desc_index) {
if (!ch->owner->stsd) {
if (!ch->last_sample_desc_index && (sample_desc_index==1)) {
} else {
ch->needs_pid_reconfig = GF_TRUE;
}
}
ch->last_sample_desc_index = sample_desc_index;
}
ch->last_state = GF_OK;
ch->au_duration = gf_isom_get_sample_duration(ch->owner->mov, ch->track, ch->sample_num);
ch->sap_3 = GF_FALSE;
ch->sap_4_type = 0;
ch->roll = 0;
ch->set_disc = ch->owner->clock_discontinuity ? 2 : 0;
ch->owner->clock_discontinuity = 0;
if (ch->sample) {
gf_isom_get_sample_rap_roll_info(ch->owner->mov, ch->track, ch->sample_num, &ch->sap_3, &ch->sap_4_type, &ch->roll);
if ((ch->speed < 0) || (ch->start <= ch->sample->DTS + ch->sample->CTS_Offset)) {
ch->dts = ch->sample->DTS;
ch->cts = ch->sample->DTS + ch->sample->CTS_Offset;
ch->seek_flag = 0;
} else {
ch->cts = ch->start;
ch->seek_flag = 1;
ch->dts = ch->start;
}
if (ch->end && (ch->end < ch->sample->DTS + ch->sample->CTS_Offset + ch->au_duration)) {
GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (""[IsoMedia] End of Channel ""LLD"" (CTS ""LLD"")\n"", ch->end, ch->sample->DTS + ch->sample->CTS_Offset));
ch->sample = NULL;
ch->last_state = GF_EOS;
ch->playing = 2;
return;
}
}
if (ch->owner->last_sender_ntp && ch->cts==ch->owner->cts_for_last_sender_ntp) {
ch->sender_ntp = ch->owner->last_sender_ntp;
ch->ntp_at_server_ntp = ch->owner->ntp_at_last_sender_ntp;
} else if (ch->owner->last_sender_ntp && ch->dts==ch->owner->cts_for_last_sender_ntp) {
ch->sender_ntp = ch->owner->last_sender_ntp;
ch->ntp_at_server_ntp = ch->owner->ntp_at_last_sender_ntp;
} else {
ch->sender_ntp = ch->ntp_at_server_ntp = 0;
}
if (!ch->sample_num) return;
gf_isom_get_sample_flags(ch->owner->mov, ch->track, ch->sample_num, &ch->isLeading, &ch->dependsOn, &ch->dependedOn, &ch->redundant);
if (ch->is_encrypted) {
if (gf_isom_is_cenc_media(ch->owner->mov, ch->track, ch->last_sample_desc_index)) {
isor_update_cenc_info(ch, GF_FALSE);
} else if (gf_isom_is_media_encrypted(ch->owner->mov, ch->track, ch->last_sample_desc_index)) {
ch->pck_encrypted = GF_TRUE;
} else {
ch->pck_encrypted = GF_FALSE;
}
}
if (ch->sample && ch->sample->nb_pack)
ch->sample_num += ch->sample->nb_pack-1;
}",[152],"GPAC version before commit 71460d72ec07df766dab0a4d52687529f3efcf0a (version v1.0.1 onwards) contains loop with unreachable exit condition ('infinite loop') vulnerability in ISOBMFF reader filter, isoffin_read.c. Function isoffin_process() can result in DoS by infinite loop. To exploit, the victim must open a specially crafted mp4 file.",gpac,CVE-2021-40592,CWE-835
8377,7545,"handle_add_command(GraphicsManager *self, const GraphicsCommand *g, const uint8_t *payload, bool *is_dirty, uint32_t iid) {
#define ABRT(code, ...) { set_add_response(#code, __VA_ARGS__); self->loading_image = 0; if (img) img->data_loaded = false; return NULL; }
#define MAX_DATA_SZ (4u * 100000000u)
has_add_respose = false;
bool existing, init_img = true;
Image *img = NULL;
unsigned char tt = g->transmission_type ? g->transmission_type : 'd';
enum FORMATS { RGB=24, RGBA=32, PNG=100 };
uint32_t fmt = g->format ? g->format : RGBA;
if (tt == 'd' && self->loading_image) init_img = false;
if (init_img) {
self->last_init_graphics_command = *g;
self->last_init_graphics_command.id = iid;
self->loading_image = 0;
if (g->data_width > 10000 || g->data_height > 10000) ABRT(EINVAL, ""Image too large"");
remove_images(self, add_trim_predicate, 0);
img = find_or_create_image(self, iid, &existing);
if (existing) {
free_load_data(&img->load_data);
img->data_loaded = false;
free_refs_data(img);
*is_dirty = true;
self->layers_dirty = true;
} else {
img->internal_id = internal_id_counter++;
img->client_id = iid;
}
img->atime = monotonic(); img->used_storage = 0;
img->width = g->data_width; img->height = g->data_height;
switch(fmt) {
case PNG:
if (g->data_sz > MAX_DATA_SZ) ABRT(EINVAL, ""PNG data size too large"");
img->load_data.is_4byte_aligned = true;
img->load_data.is_opaque = false;
img->load_data.data_sz = g->data_sz ? g->data_sz : 1024 * 100;
break;
case RGB:
case RGBA:
img->load_data.data_sz = (size_t)g->data_width * g->data_height * (fmt / 8);
if (!img->load_data.data_sz) ABRT(EINVAL, ""Zero width/height not allowed"");
img->load_data.is_4byte_aligned = fmt == RGBA || (img->width % 4 == 0);
img->load_data.is_opaque = fmt == RGB;
break;
default:
ABRT(EINVAL, ""Unknown image format: %u"", fmt);
}
if (tt == 'd') {
if (g->more) self->loading_image = img->internal_id;
img->load_data.buf_capacity = img->load_data.data_sz + (g->compressed ? 1024 : 10);
img->load_data.buf = malloc(img->load_data.buf_capacity);
img->load_data.buf_used = 0;
if (img->load_data.buf == NULL) {
ABRT(ENOMEM, ""Out of memory"");
img->load_data.buf_capacity = 0; img->load_data.buf_used = 0;
}
}
} else {
self->last_init_graphics_command.more = g->more;
self->last_init_graphics_command.payload_sz = g->payload_sz;
g = &self->last_init_graphics_command;
tt = g->transmission_type ? g->transmission_type : 'd';
fmt = g->format ? g->format : RGBA;
img = img_by_internal_id(self, self->loading_image);
if (img == NULL) {
self->loading_image = 0;
ABRT(EILSEQ, ""More payload loading refers to non-existent image"");
}
}
int fd;
static char fname[2056] = {0};
switch(tt) {
case 'd':
if (img->load_data.buf_capacity - img->load_data.buf_used < g->payload_sz) {
if (img->load_data.buf_used + g->payload_sz > MAX_DATA_SZ || fmt != PNG) ABRT(EFBIG, ""Too much data"");
img->load_data.buf_capacity = MIN(2 * img->load_data.buf_capacity, MAX_DATA_SZ);
img->load_data.buf = realloc(img->load_data.buf, img->load_data.buf_capacity);
if (img->load_data.buf == NULL) {
ABRT(ENOMEM, ""Out of memory"");
img->load_data.buf_capacity = 0; img->load_data.buf_used = 0;
}
}
memcpy(img->load_data.buf + img->load_data.buf_used, payload, g->payload_sz);
img->load_data.buf_used += g->payload_sz;
if (!g->more) { img->data_loaded = true; self->loading_image = 0; }
break;
case 'f':
case 't':
case 's':
if (g->payload_sz > 2048) ABRT(EINVAL, ""Filename too long"");
snprintf(fname, sizeof(fname)/sizeof(fname[0]), ""%.*s"", (int)g->payload_sz, payload);
if (tt == 's') fd = shm_open(fname, O_RDONLY, 0);
else fd = open(fname, O_CLOEXEC | O_RDONLY);
if (fd == -1) ABRT(EBADF, ""Failed to open file %s for graphics transmission with error: [%d] %s"", fname, errno, strerror(errno));
img->data_loaded = mmap_img_file(self, img, fd, g->data_sz, g->data_offset);
safe_close(fd, __FILE__, __LINE__);
if (tt == 't') {
if (global_state.boss) { call_boss(safe_delete_temp_file, ""s"", fname); }
else unlink(fname);
}
else if (tt == 's') shm_unlink(fname);
break;
default:
ABRT(EINVAL, ""Unknown transmission type: %c"", g->transmission_type);
}
if (!img->data_loaded) return NULL;
self->loading_image = 0;
bool needs_processing = g->compressed || fmt == PNG;
if (needs_processing) {
uint8_t *buf; size_t bufsz;
#define IB { if (img->load_data.buf) { buf = img->load_data.buf; bufsz = img->load_data.buf_used; } else { buf = img->load_data.mapped_file; bufsz = img->load_data.mapped_file_sz; } }
switch(g->compressed) {
case 'z':
IB;
if (!inflate_zlib(self, img, buf, bufsz)) {
img->data_loaded = false; return NULL;
}
break;
case 0:
break;
default:
ABRT(EINVAL, ""Unknown image compression: %c"", g->compressed);
}
switch(fmt) {
case PNG:
IB;
if (!inflate_png(self, img, buf, bufsz)) {
img->data_loaded = false; return NULL;
}
break;
default: break;
}
#undef IB
img->load_data.data = img->load_data.buf;
if (img->load_data.buf_used < img->load_data.data_sz) {
ABRT(ENODATA, ""Insufficient image data: %zu < %zu"", img->load_data.buf_used, img->load_data.data_sz);
}
if (img->load_data.mapped_file) {
munmap(img->load_data.mapped_file, img->load_data.mapped_file_sz);
img->load_data.mapped_file = NULL; img->load_data.mapped_file_sz = 0;
}
} else {
if (tt == 'd') {
if (img->load_data.buf_used < img->load_data.data_sz) {
ABRT(ENODATA, ""Insufficient image data: %zu < %zu"",  img->load_data.buf_used, img->load_data.data_sz);
} else img->load_data.data = img->load_data.buf;
} else {
if (img->load_data.mapped_file_sz < img->load_data.data_sz) {
ABRT(ENODATA, ""Insufficient image data: %zu < %zu"",  img->load_data.mapped_file_sz, img->load_data.data_sz);
} else img->load_data.data = img->load_data.mapped_file;
}
}
size_t required_sz = (size_t)(img->load_data.is_opaque ? 3 : 4) * img->width * img->height;
if (img->load_data.data_sz != required_sz) ABRT(EINVAL, ""Image dimensions: %ux%u do not match data size: %zu, expected size: %zu"", img->width, img->height, img->load_data.data_sz, required_sz);
if (LIKELY(img->data_loaded && send_to_gpu)) {
send_image_to_gpu(&img->texture_id, img->load_data.data, img->width, img->height, img->load_data.is_opaque, img->load_data.is_4byte_aligned, false, REPEAT_CLAMP);
free_load_data(&img->load_data);
self->used_storage += required_sz;
img->used_storage = required_sz;
}
return img;
#undef MAX_DATA_SZ
#undef ABRT
}",[93],The Graphics Protocol feature in graphics.c in kitty before 0.19.3 allows remote attackers to execute arbitrary code because a filename containing special characters can be included in an error message.,kitty,CVE-2020-35605,NVD-CWE-Other
8380,9651,"static int v4l2_loopback_add(struct v4l2_loopback_config *conf, int *ret_nr)
{
struct v4l2_loopback_device *dev;
struct v4l2_ctrl_handler *hdl;
struct v4l2loopback_private *vdev_priv = NULL;
int err = -ENOMEM;
int _max_width = DEFAULT_FROM_CONF(
max_width, < V4L2LOOPBACK_SIZE_MIN_WIDTH, max_width);
int _max_height = DEFAULT_FROM_CONF(
max_height, < V4L2LOOPBACK_SIZE_MIN_HEIGHT, max_height);
bool _announce_all_caps = (conf && conf->announce_all_caps >= 0) ?
(conf->announce_all_caps) :
V4L2LOOPBACK_DEFAULT_EXCLUSIVECAPS;
int _max_buffers = DEFAULT_FROM_CONF(max_buffers, <= 0, max_buffers);
int _max_openers = DEFAULT_FROM_CONF(max_openers, <= 0, max_openers);
int nr = -1;
_announce_all_caps = (!!_announce_all_caps);
if (conf) {
if (conf->capture_nr >= 0 &&
conf->output_nr == conf->capture_nr) {
nr = conf->capture_nr;
} else if (conf->capture_nr < 0 && conf->output_nr < 0) {
nr = -1;
} else if (conf->capture_nr < 0) {
nr = conf->output_nr;
} else if (conf->output_nr < 0) {
nr = conf->capture_nr;
} else {
printk(KERN_ERR
""split OUTPUT and CAPTURE devices not yet supported."");
printk(KERN_INFO
""both devices must have the same number (%d != %d)."",
conf->output_nr, conf->capture_nr);
return -EINVAL;
}
}
if (idr_find(&v4l2loopback_index_idr, nr))
return -EEXIST;
dprintk(""creating v4l2loopback-device #%d\n"", nr);
dev = kzalloc(sizeof(*dev), GFP_KERNEL);
if (!dev)
return -ENOMEM;
if (nr >= 0) {
err = idr_alloc(&v4l2loopback_index_idr, dev, nr, nr + 1,
GFP_KERNEL);
if (err == -ENOSPC)
err = -EEXIST;
} else {
err = idr_alloc(&v4l2loopback_index_idr, dev, 0, 0, GFP_KERNEL);
}
if (err < 0)
goto out_free_dev;
nr = err;
err = -ENOMEM;
if (conf && conf->card_label && *(conf->card_label)) {
snprintf(dev->card_label, sizeof(dev->card_label), ""%s"",
conf->card_label);
} else {
snprintf(dev->card_label, sizeof(dev->card_label),
""Dummy video device (0x%04X)"", nr);
}
snprintf(dev->v4l2_dev.name, sizeof(dev->v4l2_dev.name),
""v4l2loopback-%03d"", nr);
err = v4l2_device_register(NULL, &dev->v4l2_dev);
if (err)
goto out_free_idr;
MARK();
dev->vdev = video_device_alloc();
if (dev->vdev == NULL) {
err = -ENOMEM;
goto out_unregister;
}
vdev_priv = kzalloc(sizeof(struct v4l2loopback_private), GFP_KERNEL);
if (vdev_priv == NULL) {
err = -ENOMEM;
goto out_unregister;
}
video_set_drvdata(dev->vdev, vdev_priv);
if (video_get_drvdata(dev->vdev) == NULL) {
err = -ENOMEM;
goto out_unregister;
}
MARK();
snprintf(dev->vdev->name, sizeof(dev->vdev->name), dev->card_label);
vdev_priv->device_nr = nr;
init_vdev(dev->vdev, nr);
dev->vdev->v4l2_dev = &dev->v4l2_dev;
init_capture_param(&dev->capture_param);
err = set_timeperframe(dev, &dev->capture_param.timeperframe);
if (err)
goto out_unregister;
dev->keep_format = 0;
dev->sustain_framerate = 0;
dev->announce_all_caps = _announce_all_caps;
dev->max_width = _max_width;
dev->max_height = _max_height;
dev->max_openers = _max_openers;
dev->buffers_number = dev->used_buffers = _max_buffers;
dev->write_position = 0;
MARK();
spin_lock_init(&dev->lock);
INIT_LIST_HEAD(&dev->outbufs_list);
if (list_empty(&dev->outbufs_list)) {
int i;
for (i = 0; i < dev->used_buffers; ++i)
list_add_tail(&dev->buffers[i].list_head,
&dev->outbufs_list);
}
memset(dev->bufpos2index, 0, sizeof(dev->bufpos2index));
atomic_set(&dev->open_count, 0);
dev->ready_for_capture = 0;
dev->ready_for_output = 1;
dev->buffer_size = 0;
dev->image = NULL;
dev->imagesize = 0;
#ifdef HAVE_TIMER_SETUP
timer_setup(&dev->sustain_timer, sustain_timer_clb, 0);
timer_setup(&dev->timeout_timer, timeout_timer_clb, 0);
#else
setup_timer(&dev->sustain_timer, sustain_timer_clb, nr);
setup_timer(&dev->timeout_timer, timeout_timer_clb, nr);
#endif
dev->reread_count = 0;
dev->timeout_jiffies = 0;
dev->timeout_image = NULL;
dev->timeout_happened = 0;
hdl = &dev->ctrl_handler;
err = v4l2_ctrl_handler_init(hdl, 4);
if (err)
goto out_unregister;
v4l2_ctrl_new_custom(hdl, &v4l2loopback_ctrl_keepformat, NULL);
v4l2_ctrl_new_custom(hdl, &v4l2loopback_ctrl_sustainframerate, NULL);
v4l2_ctrl_new_custom(hdl, &v4l2loopback_ctrl_timeout, NULL);
v4l2_ctrl_new_custom(hdl, &v4l2loopback_ctrl_timeoutimageio, NULL);
if (hdl->error) {
err = hdl->error;
goto out_free_handler;
}
dev->v4l2_dev.ctrl_handler = hdl;
err = v4l2_ctrl_handler_setup(hdl);
if (err)
goto out_free_handler;
dev->pix_format.width = 0;
dev->pix_format.height = 0;
dev->pix_format.pixelformat = formats[0].fourcc;
dev->pix_format.colorspace =
V4L2_COLORSPACE_SRGB;
dev->pix_format.field = V4L2_FIELD_NONE;
dev->buffer_size = PAGE_ALIGN(dev->pix_format.sizeimage);
dprintk(""buffer_size = %ld (=%d)\n"", dev->buffer_size,
dev->pix_format.sizeimage);
if (dev->buffer_size && ((err = allocate_buffers(dev)) < 0))
goto out_free_handler;
init_waitqueue_head(&dev->read_event);
if (video_register_device(dev->vdev, VFL_TYPE_VIDEO, nr) < 0) {
printk(KERN_ERR
""v4l2loopback: failed video_register_device()\n"");
err = -EFAULT;
goto out_free_device;
}
v4l2loopback_create_sysfs(dev->vdev);
MARK();
if (ret_nr)
*ret_nr = dev->vdev->num;
return 0;
out_free_device:
video_device_release(dev->vdev);
out_free_handler:
v4l2_ctrl_handler_free(&dev->ctrl_handler);
out_unregister:
video_set_drvdata(dev->vdev, NULL);
if (vdev_priv != NULL)
kfree(vdev_priv);
v4l2_device_unregister(&dev->v4l2_dev);
out_free_idr:
idr_remove(&v4l2loopback_index_idr, nr);
out_free_dev:
kfree(dev);
return err;
}",[84],Depending on the way the format strings in the card label are crafted it's possible to leak kernel stack memory. There is also the possibility for DoS due to the v4l2loopback kernel module crashing when providing the card label on request (reproduce e.g. with many %s modifiers in a row).,v4l2loopback,CVE-2022-2652,CWE-134
8382,1362,"FUNC_DECODER(dissector_postgresql)
{
DECLARE_DISP_PTR(ptr);
struct ec_session *s = NULL;
void *ident = NULL;
char tmp[MAX_ASCII_ADDR_LEN];
struct postgresql_status *conn_status;
(void) DECODE_DATA;
(void) DECODE_DATALEN;
(void) DECODED_LEN;
if (FROM_CLIENT(""postgresql"", PACKET)) {
if (PACKET->DATA.len < 4)
return NULL;
dissect_create_ident(&ident, PACKET, DISSECT_CODE(dissector_postgresql));
if (session_get(&s, ident, DISSECT_IDENT_LEN) == -ENOTFOUND) {
unsigned char *u = memmem(ptr, PACKET->DATA.len, ""user"", 4);
unsigned char *d = memmem(ptr, PACKET->DATA.len, ""database"", 8);
if (!memcmp(ptr + 4, ""\x00\x03\x00\x00"", 4) && u && d) {
dissect_create_session(&s, PACKET, DISSECT_CODE(dissector_postgresql));
SAFE_CALLOC(s->data, 1, sizeof(struct postgresql_status));
conn_status = (struct postgresql_status *) s->data;
conn_status->status = WAIT_AUTH;
strncpy((char*)conn_status->user, (char*)(u + 5), 65);
conn_status->user[64] = 0;
strncpy((char*)conn_status->database, (char*)(d + 9), 65);
conn_status->database[64] = 0;
session_put(s);
}
} else {
conn_status = (struct postgresql_status *) s->data;
if (conn_status->status == WAIT_RESPONSE) {
if (ptr[0] == 'p' && conn_status->type == MD5) {
DEBUG_MSG(""\tDissector_postgresql RESPONSE type is MD5"");
if(memcmp(ptr + 1, ""\x00\x00\x00\x28"", 4)) {
DEBUG_MSG(""\tDissector_postgresql BUG, expected length is 40"");
return NULL;
}
if (PACKET->DATA.len < 40) {
DEBUG_MSG(""\tDissector_postgresql BUG, expected length is 40"");
return NULL;
}
memcpy(conn_status->hash, ptr + 5 + 3, 32);
conn_status->hash[32] = 0;
DISSECT_MSG(""%s:$postgres$%s*%s*%s:%s:%d\n"", conn_status->user, conn_status->user, conn_status->salt, conn_status->hash, ip_addr_ntoa(&PACKET->L3.dst, tmp), ntohs(PACKET->L4.dst));
dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));
}
else if (ptr[0] == 'p' && conn_status->type == CT) {
int length;
DEBUG_MSG(""\tDissector_postgresql RESPONSE type is clear-text!"");
GET_ULONG_BE(length, ptr, 1);
strncpy((char*)conn_status->password, (char*)(ptr + 5), length - 4);
conn_status->password[length - 4] = 0;
DISSECT_MSG(""PostgreSQL credentials:%s-%d:%s:%s\n"", ip_addr_ntoa(&PACKET->L3.dst, tmp), ntohs(PACKET->L4.dst), conn_status->user, conn_status->password);
dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));
}
}
}
} else {
if (PACKET->DATA.len < 9)
return NULL;
dissect_create_ident(&ident, PACKET, DISSECT_CODE(dissector_postgresql));
if (session_get(&s, ident, DISSECT_IDENT_LEN) == ESUCCESS) {
conn_status = (struct postgresql_status *) s->data;
if (conn_status->status == WAIT_AUTH &&
ptr[0] == 'R' && !memcmp(ptr + 1, ""\x00\x00\x00\x0c"", 4)  &&
!memcmp(ptr + 5, ""\x00\x00\x00\x05"", 4)) {
conn_status->status = WAIT_RESPONSE;
conn_status->type = MD5;
DEBUG_MSG(""\tDissector_postgresql AUTH type is MD5"");
hex_encode(ptr + 9, 4, conn_status->salt);
}
else if (conn_status->status == WAIT_AUTH &&
ptr[0] == 'R' && !memcmp(ptr + 1, ""\x00\x00\x00\x08"", 4)  &&
!memcmp(ptr + 5, ""\x00\x00\x00\x03"", 4)) {
conn_status->status = WAIT_RESPONSE;
conn_status->type = CT;
DEBUG_MSG(""\tDissector_postgresql AUTH type is clear-text!"");
}
}
}
SAFE_FREE(ident);
return NULL;
}","[51, 52]",Heap-based buffer overflow in the dissector_postgresql function in dissectors/ec_postgresql.c in Ettercap before 0.8.1 allows remote attackers to cause a denial of service or possibly execute arbitrary code via a crafted password length value that is inconsistent with the actual length of the password.,ettercap,CVE-2014-6395,CWE-119
8388,7361,"GF_Err gf_isom_box_parse_ex(GF_Box **outBox, GF_BitStream *bs, u32 parent_type, Bool is_root_box)
{
u32 type, uuid_type, hdr_size;
u64 size, start, payload_start, end;
char uuid[16];
GF_Err e;
GF_Box *newBox;
Bool skip_logs = gf_bs_get_cookie(bs) ? GF_TRUE : GF_FALSE;
Bool is_special = GF_TRUE;
if ((bs == NULL) || (outBox == NULL) ) return GF_BAD_PARAM;
*outBox = NULL;
if (gf_bs_available(bs) < 8) {
return GF_ISOM_INCOMPLETE_FILE;
}
start = gf_bs_get_position(bs);
uuid_type = 0;
size = (u64) gf_bs_read_u32(bs);
hdr_size = 4;
if ((size >= 2) && (size <= 4)) {
size = 4;
type = GF_ISOM_BOX_TYPE_VOID;
} else {
type = gf_bs_read_u32(bs);
hdr_size += 4;
if (type == GF_ISOM_BOX_TYPE_TOTL)
size = 12;
if (!size) {
if (is_root_box) {
if (!skip_logs) {
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Warning Read Box type %s (0x%08X) size 0 reading till the end of file\n"", gf_4cc_to_str(type), type));
}
size = gf_bs_available(bs) + 8;
} else {
if (!skip_logs) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Read Box type %s (0x%08X) at position ""LLU"" has size 0 but is not at root/file level, skipping\n"", gf_4cc_to_str(type), type, start));
}
return GF_OK;
}
}
}
memset(uuid, 0, 16);
if (type == GF_ISOM_BOX_TYPE_UUID ) {
if (gf_bs_available(bs) < 16) {
return GF_ISOM_INCOMPLETE_FILE;
}
gf_bs_read_data(bs, uuid, 16);
hdr_size += 16;
uuid_type = gf_isom_solve_uuid_box(uuid);
}
if (size == 1) {
if (gf_bs_available(bs) < 8) {
return GF_ISOM_INCOMPLETE_FILE;
}
size = gf_bs_read_u64(bs);
hdr_size += 8;
}
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Read Box type %s size ""LLD"" start ""LLD""\n"", gf_4cc_to_str(type), LLD_CAST size, LLD_CAST start));
if ( size < hdr_size ) {
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Box size ""LLD"" less than box header size %d\n"", LLD_CAST size, hdr_size));
return GF_ISOM_INVALID_FILE;
}
if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TREF)) {
newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFT);
if (!newBox) return GF_OUT_OF_MEM;
((GF_TrackReferenceTypeBox*)newBox)->reference_type = type;
} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_IREF)) {
newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFI);
if (!newBox) return GF_OUT_OF_MEM;
((GF_ItemReferenceTypeBox*)newBox)->reference_type = type;
} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TRGR)) {
newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_TRGT);
if (!newBox) return GF_OUT_OF_MEM;
((GF_TrackGroupTypeBox*)newBox)->group_type = type;
} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_GRPL)) {
newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_GRPT);
if (!newBox) return GF_OUT_OF_MEM;
((GF_EntityToGroupTypeBox*)newBox)->grouping_type = type;
} else {
is_special = GF_FALSE;
newBox = gf_isom_box_new_ex(uuid_type ? uuid_type : type, parent_type, skip_logs, is_root_box);
if (!newBox) return GF_OUT_OF_MEM;
}
if (type==GF_ISOM_BOX_TYPE_UUID && !is_special) {
memcpy(((GF_UUIDBox *)newBox)->uuid, uuid, 16);
((GF_UUIDBox *)newBox)->internal_4cc = uuid_type;
}
if (!newBox->type) newBox->type = type;
payload_start = gf_bs_get_position(bs);
retry_unknown_box:
end = gf_bs_available(bs);
if (size - hdr_size > end ) {
newBox->size = size - hdr_size - end;
*outBox = newBox;
return GF_ISOM_INCOMPLETE_FILE;
}
newBox->size = size - hdr_size;
if (newBox->size) {
e = gf_isom_full_box_read(newBox, bs);
if (!e) e = gf_isom_box_read(newBox, bs);
newBox->size = size;
end = gf_bs_get_position(bs);
} else {
newBox->size = size;
e = GF_OK;
end = gf_bs_get_position(bs);
}
if (e && (e != GF_ISOM_INCOMPLETE_FILE)) {
gf_isom_box_del(newBox);
*outBox = NULL;
if (parent_type==GF_ISOM_BOX_TYPE_STSD) {
newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_UNKNOWN);
((GF_UnknownBox *)newBox)->original_4cc = type;
newBox->size = size;
gf_bs_seek(bs, payload_start);
goto retry_unknown_box;
}
if (!skip_logs) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Read Box \""%s\"" (start ""LLU"") failed (%s) - skipping\n"", gf_4cc_to_str(type), start, gf_error_to_string(e)));
}
return e;
}
if (end-start > size) {
if (!skip_logs) {
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] Box \""%s\"" size ""LLU"" (start ""LLU"") invalid (read ""LLU"")\n"", gf_4cc_to_str(type), LLU_CAST size, start, LLU_CAST (end-start) ));
}
gf_bs_seek(bs, start+size);
} else if (end-start < size) {
u32 to_skip = (u32) (size-(end-start));
if (!skip_logs) {
if ((to_skip!=4) || gf_bs_peek_bits(bs, 32, 0)) {
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] Box \""%s\"" (start ""LLU"") has %u extra bytes\n"", gf_4cc_to_str(type), start, to_skip));
}
}
gf_bs_skip_bytes(bs, to_skip);
}
*outBox = newBox;
return e;
}","[97, 98, 99, 100, 101, 102, 103, 104, 105]","A Null pointer dereference vulnerability exits in MP4Box - GPAC version 0.8.0-rev177-g51a8ef874-master via the gf_isom_get_track_id function, which causes a denial of service.",gpac,CVE-2020-25427,CWE-476
8392,8035,"void DumpTrackInfo(GF_ISOFile *file, GF_ISOTrackID trackID, Bool full_dump, Bool is_track_num, Bool dump_m4sys)
{
char szCodec[RFC6381_CODEC_NAME_SIZE_MAX];
Double scale, max_rate, rate;
Bool is_od_track = 0;
u32 trackNum, i, j, ts, mtype, msub_type, timescale, sr, nb_ch, count, alt_group, nb_groups, nb_edits, cdur, csize, bps, pfmt, codecid;
u64 time_slice, dur, size;
s32 cts_shift;
GF_ESD *esd;
char szDur[50];
char *lang;
if (!is_track_num) {
trackNum = gf_isom_get_track_by_id(file, trackID);
} else {
trackNum = trackID;
trackID = gf_isom_get_track_id(file, trackNum);
}
if (!trackNum) {
M4_LOG(GF_LOG_ERROR, (""No track with ID %d found\n"", trackID));
return;
}
timescale = gf_isom_get_media_timescale(file, trackNum);
fprintf(stderr, ""# Track %d Info - ID %d - TimeScale %d\n"", trackNum, trackID, timescale);
dur = gf_isom_get_media_original_duration(file, trackNum);
size = gf_isom_get_media_duration(file, trackNum);
fprintf(stderr, ""Media Duration %s "", format_duration(dur, timescale, szDur));
if (dur != size)
fprintf(stderr, "" (recomputed %s)"", format_duration(size, timescale, szDur));
fprintf(stderr, ""\n"");
if (gf_isom_check_data_reference(file, trackNum, 1) != GF_OK) {
M4_LOG(GF_LOG_WARNING, (""Track uses external data reference not supported by GPAC!\n""));
}
nb_edits = gf_isom_get_edits_count(file, trackNum);
if (nb_edits)
fprintf(stderr, ""Track has %d edits: track duration is %s\n"", nb_edits, format_duration(gf_isom_get_track_duration(file, trackNum), gf_isom_get_timescale(file), szDur));
cts_shift = gf_isom_get_composition_offset_shift(file, trackNum);
if (cts_shift)
fprintf(stderr, ""Track composition offset shift (negative CTS offset): %d\n"", cts_shift);
if (gf_isom_is_track_in_root_od(file, trackNum) ) fprintf(stderr, ""Track is present in Root OD\n"");
if (!gf_isom_is_track_enabled(file, trackNum))  fprintf(stderr, ""Track is disabled\n"");
gf_isom_get_media_language(file, trackNum, &lang);
fprintf(stderr, ""Media Info: Language \""%s (%s)\"" - "", GetLanguage(lang), lang );
gf_free(lang);
mtype = gf_isom_get_media_type(file, trackNum);
fprintf(stderr, ""Type \""%s:"", gf_4cc_to_str(mtype));
msub_type = gf_isom_get_mpeg4_subtype(file, trackNum, 1);
if (!msub_type) msub_type = gf_isom_get_media_subtype(file, trackNum, 1);
fprintf(stderr, ""%s\"" - %d samples\n"", gf_4cc_to_str(msub_type), gf_isom_get_sample_count(file, trackNum));
pfmt = gf_pixel_fmt_from_qt_type(msub_type);
codecid = gf_codec_id_from_isobmf(msub_type);
count = gf_isom_get_track_kind_count(file, trackNum);
for (i = 0; i < count; i++) {
char *kind_scheme, *kind_value;
gf_isom_get_track_kind(file, trackNum, i, &kind_scheme, &kind_value);
fprintf(stderr, ""Kind: %s - %s\n"", kind_scheme ? kind_scheme : ""null"", kind_value ? kind_value : ""null"");
if (kind_scheme) gf_free(kind_scheme);
if (kind_value) gf_free(kind_value);
}
if (gf_isom_is_track_fragmented(file, trackID) ) {
u32 defaultDuration, defaultSize, defaultDescriptionIndex, defaultRandomAccess;
u8 defaultPadding;
u16 defaultDegradationPriority;
u32 frag_samples;
u64 frag_duration;
gf_isom_get_fragmented_samples_info(file, trackID, &frag_samples, &frag_duration);
fprintf(stderr, ""Fragmented track: %d samples - Media Duration %s\n"", frag_samples, format_duration(frag_duration, timescale, szDur));
gf_isom_get_fragment_defaults(file, trackNum, &defaultDuration, &defaultSize, &defaultDescriptionIndex, &defaultRandomAccess, &defaultPadding, &defaultDegradationPriority);
fprintf(stderr, ""Fragment sample defaults: duration %d size %d stsd %d sync %d padding %d degradation_priority %d\n"",
defaultDuration, defaultSize, defaultDescriptionIndex, defaultRandomAccess,
(u32) defaultPadding, (u32) defaultDegradationPriority
);
}
if (!gf_isom_is_self_contained(file, trackNum, 1)) {
const char *url, *urn;
gf_isom_get_data_reference(file, trackNum, 1, &url, &urn);
fprintf(stderr, ""Media Data Location: %s\n"", url ? url : urn);
}
if (full_dump) {
const char *handler_name;
gf_isom_get_handler_name(file, trackNum, &handler_name);
fprintf(stderr, ""Handler name: %s\n"", handler_name);
}
print_udta(file, trackNum, GF_FALSE);
if (gf_isom_is_video_handler_type(mtype) ) {
s32 tx, ty;
u32 w, h;
u16 bit_depth;
gf_isom_get_visual_info(file, trackNum, 1, &w, &h);
gf_isom_get_visual_bit_depth(file, trackNum, 1, &bit_depth);
fprintf(stderr, ""Visual Sample Entry Info: width=%d height=%d (depth=%d bits)\n"", w, h, (int)bit_depth);
gf_isom_get_track_layout_info(file, trackNum, &w, &h, &tx, &ty, NULL);
fprintf(stderr, ""Visual Track layout: x=%d y=%d width=%d height=%d\n"", tx, ty, w, h);
}
gf_isom_get_audio_info(file, trackNum, 1, &sr, &nb_ch, &bps);
gf_isom_set_nalu_extract_mode(file, trackNum, GF_ISOM_NALU_EXTRACT_INSPECT);
msub_type = gf_isom_get_media_subtype(file, trackNum, 1);
if (msub_type==GF_ISOM_SUBTYPE_MPEG4_CRYP)
gf_isom_get_original_format_type(file, trackNum, 1, &msub_type);
if ((msub_type==GF_ISOM_SUBTYPE_MPEG4)
|| (msub_type==GF_ISOM_SUBTYPE_AVC_H264)
|| (msub_type==GF_ISOM_SUBTYPE_AVC2_H264)
|| (msub_type==GF_ISOM_SUBTYPE_AVC3_H264)
|| (msub_type==GF_ISOM_SUBTYPE_AVC4_H264)
|| (msub_type==GF_ISOM_SUBTYPE_SVC_H264)
|| (msub_type==GF_ISOM_SUBTYPE_MVC_H264)
|| (msub_type==GF_ISOM_SUBTYPE_LSR1)
|| (msub_type==GF_ISOM_SUBTYPE_HVC1)
|| (msub_type==GF_ISOM_SUBTYPE_HEV1)
|| (msub_type==GF_ISOM_SUBTYPE_HVC2)
|| (msub_type==GF_ISOM_SUBTYPE_HEV2)
|| (msub_type==GF_ISOM_SUBTYPE_LHV1)
|| (msub_type==GF_ISOM_SUBTYPE_LHE1)
|| (msub_type==GF_ISOM_SUBTYPE_HVT1)
)  {
esd = gf_isom_get_esd(file, trackNum, 1);
if (!esd || !esd->decoderConfig) {
M4_LOG(GF_LOG_WARNING, (""WARNING: Broken MPEG-4 Track\n""));
if (esd) gf_odf_desc_del((GF_Descriptor *)esd);
} else {
const char *st = gf_stream_type_name(esd->decoderConfig->streamType);
if (dump_m4sys) {
if (st) {
fprintf(stderr, ""MPEG-4 Config%s%s Stream - ObjectTypeIndication 0x%02x\n"",
full_dump ? ""\n\t"" : "": "", st, esd->decoderConfig->objectTypeIndication);
} else {
fprintf(stderr, ""MPEG-4 Config%sStream Type 0x%02x - ObjectTypeIndication 0x%02x\n"",
full_dump ? ""\n\t"" : "": "", esd->decoderConfig->streamType, esd->decoderConfig->objectTypeIndication);
}
}
if (esd->decoderConfig->streamType==GF_STREAM_OD)
is_od_track=1;
if (esd->decoderConfig->streamType==GF_STREAM_VISUAL) {
u32 w, h;
u16 rvc_predef;
w = h = 0;
if (esd->decoderConfig->objectTypeIndication==GF_CODECID_MPEG4_PART2) {
#ifndef GPAC_DISABLE_AV_PARSERS
if (!esd->decoderConfig->decoderSpecificInfo) {
#else
gf_isom_get_visual_info(file, trackNum, 1, &w, &h);
fprintf(stderr, ""MPEG-4 Visual Size %d x %d\n"", w, h);
#endif
M4_LOG(GF_LOG_WARNING, (""Non-compliant MPEG-4 Visual track: video_object_layer infos not found in sample description\n""));
#ifndef GPAC_DISABLE_AV_PARSERS
} else {
GF_M4VDecSpecInfo dsi;
gf_m4v_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &dsi);
if (full_dump) fprintf(stderr, ""\t"");
w = dsi.width;
h = dsi.height;
fprintf(stderr, ""MPEG-4 Visual Size %d x %d - %s\n"", w, h, gf_m4v_get_profile_name(dsi.VideoPL));
if (dsi.par_den && dsi.par_num) {
u32 tw, th;
gf_isom_get_track_layout_info(file, trackNum, &tw, &th, NULL, NULL, NULL);
fprintf(stderr, ""Pixel Aspect Ratio %d:%d - Indicated track size %d x %d\n"", dsi.par_num, dsi.par_den, tw, th);
}
}
#endif
} else if (gf_isom_get_avc_svc_type(file, trackNum, 1) != GF_ISOM_AVCTYPE_NONE) {
GF_AVCConfig *avccfg, *svccfg, *mvccfg;
gf_isom_get_visual_info(file, trackNum, 1, &w, &h);
if (full_dump) fprintf(stderr, ""\t"");
fprintf(stderr, ""AVC/H264 Video - Visual Size %d x %d\n"", w, h);
avccfg = gf_isom_avc_config_get(file, trackNum, 1);
svccfg = gf_isom_svc_config_get(file, trackNum, 1);
mvccfg = gf_isom_mvc_config_get(file, trackNum, 1);
if (!avccfg && !svccfg && !mvccfg) {
M4_LOG(GF_LOG_ERROR, (""\tNon-compliant AVC track: SPS/PPS not found in sample description\n""));
} else if (avccfg) {
fprintf(stderr, ""\tAVC Info: %d SPS - %d PPS"", gf_list_count(avccfg->sequenceParameterSets) , gf_list_count(avccfg->pictureParameterSets) );
fprintf(stderr, "" - Profile %s @ Level %g\n"", gf_avc_get_profile_name(avccfg->AVCProfileIndication), ((Double)avccfg->AVCLevelIndication)/10.0 );
fprintf(stderr, ""\tNAL Unit length bits: %d\n"", 8*avccfg->nal_unit_size);
#ifndef GPAC_DISABLE_AV_PARSERS
for (i=0; i<gf_list_count(avccfg->sequenceParameterSets); i++) {
s32 par_n, par_d;
GF_NALUFFParam *slc = gf_list_get(avccfg->sequenceParameterSets, i);
gf_avc_get_sps_info(slc->data, slc->size, NULL, NULL, NULL, &par_n, &par_d);
if ((par_n>0) && (par_d>0)) {
u32 tw, th;
gf_isom_get_track_layout_info(file, trackNum, &tw, &th, NULL, NULL, NULL);
fprintf(stderr, ""\tPixel Aspect Ratio %d:%d - Indicated track size %d x %d\n"", par_n, par_d, tw, th);
}
if (!full_dump) break;
}
#endif
if (avccfg->chroma_bit_depth) {
fprintf(stderr, ""\tChroma format %s - Luma bit depth %d - chroma bit depth %d\n"", gf_avc_hevc_get_chroma_format_name(avccfg->chroma_format), avccfg->luma_bit_depth, avccfg->chroma_bit_depth);
}
print_config_hash(avccfg->sequenceParameterSets, ""SPS"");
print_config_hash(avccfg->pictureParameterSets, ""PPS"");
gf_odf_avc_cfg_del(avccfg);
}
if (svccfg) {
fprintf(stderr, ""\n\tSVC Info: %d SPS - %d PPS - Profile %s @ Level %g\n"", gf_list_count(svccfg->sequenceParameterSets) , gf_list_count(svccfg->pictureParameterSets), gf_avc_get_profile_name(svccfg->AVCProfileIndication), ((Double)svccfg->AVCLevelIndication)/10.0 );
fprintf(stderr, ""\tSVC NAL Unit length bits: %d\n"", 8*svccfg->nal_unit_size);
#ifndef GPAC_DISABLE_AV_PARSERS
for (i=0; i<gf_list_count(svccfg->sequenceParameterSets); i++) {
GF_NALUFFParam *slc = gf_list_get(svccfg->sequenceParameterSets, i);
if (slc) {
s32 par_n, par_d;
u32 s_w, s_h, sps_id;
gf_avc_get_sps_info(slc->data, slc->size, &sps_id, &s_w, &s_h, &par_n, &par_d);
fprintf(stderr, ""\t\tSPS ID %d - Visual Size %d x %d\n"", sps_id, s_w, s_h);
if ((par_n>0) && (par_d>0)) {
u32 tw, th;
gf_isom_get_track_layout_info(file, trackNum, &tw, &th, NULL, NULL, NULL);
fprintf(stderr, ""\tPixel Aspect Ratio %d:%d - Indicated track size %d x %d\n"", par_n, par_d, tw, th);
}
}
}
#endif
print_config_hash(svccfg->sequenceParameterSets, ""SPS"");
print_config_hash(svccfg->pictureParameterSets, ""PPS"");
print_config_hash(svccfg->sequenceParameterSetExtensions, ""SPSEx"");
gf_odf_avc_cfg_del(svccfg);
}
if (mvccfg) {
fprintf(stderr, ""\n\tMVC Info: %d SPS - %d PPS - Profile %s @ Level %g\n"", gf_list_count(mvccfg->sequenceParameterSets) , gf_list_count(mvccfg->pictureParameterSets), gf_avc_get_profile_name(mvccfg->AVCProfileIndication), ((Double)mvccfg->AVCLevelIndication)/10.0 );
fprintf(stderr, ""\tMVC NAL Unit length bits: %d\n"", 8*mvccfg->nal_unit_size);
#ifndef GPAC_DISABLE_AV_PARSERS
for (i=0; i<gf_list_count(mvccfg->sequenceParameterSets); i++) {
GF_NALUFFParam *slc = gf_list_get(mvccfg->sequenceParameterSets, i);
if (slc) {
u32 s_w, s_h, sps_id;
s32 par_n, par_d;
gf_avc_get_sps_info(slc->data, slc->size, &sps_id, &s_w, &s_h, &par_n, &par_d);
fprintf(stderr, ""\t\tSPS ID %d - Visual Size %d x %d\n"", sps_id, s_w, s_h);
if ((par_n>0) && (par_d>0)) {
u32 tw, th;
gf_isom_get_track_layout_info(file, trackNum, &tw, &th, NULL, NULL, NULL);
fprintf(stderr, ""\tPixel Aspect Ratio %d:%d - Indicated track size %d x %d\n"", par_n, par_d, tw, th);
}
}
}
#endif
print_config_hash(mvccfg->sequenceParameterSets, ""SPS"");
print_config_hash(mvccfg->pictureParameterSets, ""PPS"");
gf_odf_avc_cfg_del(mvccfg);
}
} else if ((esd->decoderConfig->objectTypeIndication==GF_CODECID_HEVC)
|| (esd->decoderConfig->objectTypeIndication==GF_CODECID_LHVC)
) {
GF_HEVCConfig *hevccfg, *lhvccfg;
GF_OperatingPointsInformation *oinf;
#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_HEVC)
HEVCState hevc_state;
memset(&hevc_state, 0, sizeof(HEVCState));
hevc_state.sps_active_idx = -1;
#endif
gf_isom_get_visual_info(file, trackNum, 1, &w, &h);
if (full_dump) fprintf(stderr, ""\t"");
fprintf(stderr, ""HEVC Video - Visual Size %d x %d\n"", w, h);
hevccfg = gf_isom_hevc_config_get(file, trackNum, 1);
lhvccfg = gf_isom_lhvc_config_get(file, trackNum, 1);
if (msub_type==GF_ISOM_SUBTYPE_HVT1) {
const u8 *data;
u32 tsize;
u32  is_default, tx,ty,tw,th, id, independent;
Bool full_frame;
if (gf_isom_get_tile_info(file, trackNum, 1, &is_default, &id, &independent, &full_frame, &tx, &ty, &tw, &th)) {
fprintf(stderr, ""\tHEVC Tile - ID %d independent %d (x,y,w,h)=%d,%d,%d,%d \n"", id, independent, tx, ty, tw, th);
} else if (gf_isom_get_sample_group_info(file, trackNum, 1, GF_ISOM_SAMPLE_GROUP_TRIF, &is_default, &data, &tsize)) {
fprintf(stderr, ""\tHEVC Tile track containing a tile set\n"");
} else {
fprintf(stderr, ""\tHEVC Tile track without tiling info\n"");
}
} else if (!hevccfg && !lhvccfg) {
M4_LOG(GF_LOG_ERROR, (""\tNon-compliant HEVC track: No hvcC or shcC found in sample description\n""));
}
if (gf_isom_get_reference_count(file, trackNum, GF_ISOM_REF_SABT)) {
fprintf(stderr, ""\tHEVC Tile base track\n"");
}
if (hevccfg) {
dump_hevc_track_info(file, trackNum, hevccfg
#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_HEVC)
, &hevc_state
#endif
);
gf_odf_hevc_cfg_del(hevccfg);
fprintf(stderr, ""\n"");
}
if (lhvccfg) {
dump_hevc_track_info(file, trackNum, lhvccfg
#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_HEVC)
, &hevc_state
#endif
);
gf_odf_hevc_cfg_del(lhvccfg);
}
if (gf_isom_get_oinf_info(file, trackNum, &oinf)) {
fprintf(stderr, ""\n\tOperating Points Information -"");
fprintf(stderr, "" scalability_mask %d ("", oinf->scalability_mask);
switch (oinf->scalability_mask) {
case 2:
fprintf(stderr, ""Multiview"");
break;
case 4:
fprintf(stderr, ""Spatial scalability"");
break;
case 8:
fprintf(stderr, ""Auxilary"");
break;
default:
fprintf(stderr, ""unknown"");
}
fprintf(stderr, "") num_profile_tier_level %d "", gf_list_count(oinf->profile_tier_levels) );
fprintf(stderr, "" num_operating_points %d dependency layers %d \n"", gf_list_count(oinf->operating_points), gf_list_count(oinf->dependency_layers) );
}
}
else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_THEORA) {
char *szName;
gf_isom_get_visual_info(file, trackNum, 1, &w, &h);
if (full_dump) fprintf(stderr, ""\t"");
if (!strnicmp((char *) &esd->decoderConfig->decoderSpecificInfo->data[3], ""theora"", 6)) szName = ""Theora"";
else szName = ""Unknown"";
fprintf(stderr, ""Ogg/%s video / GPAC Mux  - Visual Size %d x %d\n"", szName, w, h);
}
else {
u32 codec_id = gf_codecid_from_oti(GF_STREAM_VISUAL, esd->decoderConfig->objectTypeIndication);
if (codec_id) {
gf_isom_get_visual_info(file, trackNum, 1, &w, &h);
fprintf(stderr, ""%s - Visual Size %d x %d\n"", gf_codecid_name(codec_id), w, h);
}
}
if (!w || !h) {
gf_isom_get_visual_info(file, trackNum, 1, &w, &h);
if (full_dump) fprintf(stderr, ""\t"");
fprintf(stderr, ""Visual Size %d x %d\n"", w, h);
}
if (gf_isom_get_rvc_config(file, trackNum, 1, &rvc_predef, NULL, NULL, NULL)==GF_OK) {
fprintf(stderr, ""Has RVC signaled - Predefined configuration %d\n"", rvc_predef);
}
} else if (esd->decoderConfig->streamType==GF_STREAM_AUDIO) {
#ifndef GPAC_DISABLE_AV_PARSERS
GF_M4ADecSpecInfo a_cfg;
GF_Err e;
u32 oti;
#endif
u32 codec_id;
Bool is_mp2 = GF_FALSE;
switch (esd->decoderConfig->objectTypeIndication) {
case GF_CODECID_AAC_MPEG2_MP:
case GF_CODECID_AAC_MPEG2_LCP:
case GF_CODECID_AAC_MPEG2_SSRP:
is_mp2 = GF_TRUE;
case GF_CODECID_AAC_MPEG4:
#ifndef GPAC_DISABLE_AV_PARSERS
if (!esd->decoderConfig->decoderSpecificInfo)
e = GF_NON_COMPLIANT_BITSTREAM;
else
e = gf_m4a_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &a_cfg);
if (full_dump) fprintf(stderr, ""\t"");
if (e) {
M4_LOG(GF_LOG_ERROR, (""Corrupted AAC Config\n""));
} else {
char *signaling = ""implicit"";
char *heaac = """";
if (!is_mp2 && a_cfg.has_sbr) {
if (a_cfg.has_ps) heaac = ""(HE-AAC v2) "";
else heaac = ""(HE-AAC v1) "";
}
if (a_cfg.base_object_type==2) {
if (a_cfg.has_ps || a_cfg.has_sbr)
signaling = ""backward compatible"";
} else {
signaling = ""hierarchical"";
}
fprintf(stderr, ""%s (AOT=%d %s) %s- %d Channel(s) - SampleRate %d"", gf_m4a_object_type_name(a_cfg.base_object_type), a_cfg.base_object_type, signaling, heaac, a_cfg.nb_chan, a_cfg.base_sr);
if (is_mp2) fprintf(stderr, "" (MPEG-2 Signaling)"");
if (a_cfg.has_sbr) fprintf(stderr, "" - SBR: SampleRate %d Type %s"", a_cfg.sbr_sr, gf_m4a_object_type_name(a_cfg.sbr_object_type));
if (a_cfg.has_ps) fprintf(stderr, "" - PS"");
fprintf(stderr, ""\n"");
}
#else
fprintf(stderr, ""MPEG-2/4 Audio - %d Channels - SampleRate %d\n"", nb_ch, sr);
#endif
break;
case GF_CODECID_MPEG2_PART3:
case GF_CODECID_MPEG_AUDIO:
if (msub_type == GF_ISOM_SUBTYPE_MPEG4_CRYP) {
fprintf(stderr, ""MPEG-1/2 Audio - %d Channels - SampleRate %d\n"", nb_ch, sr);
} else {
#ifndef GPAC_DISABLE_AV_PARSERS
GF_ISOSample *samp = gf_isom_get_sample(file, trackNum, 1, &oti);
if (samp) {
u32 mhdr = GF_4CC((u8)samp->data[0], (u8)samp->data[1], (u8)samp->data[2], (u8)samp->data[3]);
if (full_dump) fprintf(stderr, ""\t"");
fprintf(stderr, ""%s Audio - %d Channel(s) - SampleRate %d - Layer %d\n"",
gf_mp3_version_name(mhdr),
gf_mp3_num_channels(mhdr),
gf_mp3_sampling_rate(mhdr),
gf_mp3_layer(mhdr)
);
gf_isom_sample_del(&samp);
} else {
M4_LOG(GF_LOG_ERROR, (""Error fetching sample: %s\n"", gf_error_to_string(gf_isom_last_error(file)) ));
}
#else
fprintf(stderr, ""MPEG-1/2 Audio - %d Channels - SampleRate %d\n"", nb_ch, sr);
#endif
}
break;
case GF_CODECID_EVRC:
fprintf(stderr, ""EVRC Audio - Sample Rate 8000 - 1 channel\n"");
break;
case GF_CODECID_SMV:
fprintf(stderr, ""SMV Audio - Sample Rate 8000 - 1 channel\n"");
break;
case GF_CODECID_QCELP:
fprintf(stderr, ""QCELP Audio - Sample Rate 8000 - 1 channel\n"");
break;
case GF_CODECID_EVRC_PV:
if (esd->decoderConfig->decoderSpecificInfo && (esd->decoderConfig->decoderSpecificInfo->dataLength==8)
&& !strnicmp((char *)esd->decoderConfig->decoderSpecificInfo->data, ""pvmm"", 4)) {
if (full_dump) fprintf(stderr, ""\t"");
fprintf(stderr, ""EVRC Audio (PacketVideo Mux) - Sample Rate 8000 - 1 channel\n"");
}
break;
default:
codec_id = gf_codecid_from_oti(GF_STREAM_AUDIO, esd->decoderConfig->objectTypeIndication);
if (codec_id) {
fprintf(stderr, ""%s - Sample Rate %d - %d channel(s)\n"", gf_codecid_name(codec_id), sr, nb_ch);
}
break;
}
}
else if (esd->decoderConfig->streamType==GF_STREAM_SCENE) {
if (esd->decoderConfig->objectTypeIndication<=4) {
GF_BIFSConfig *b_cfg = gf_odf_get_bifs_config(esd->decoderConfig->decoderSpecificInfo, esd->decoderConfig->objectTypeIndication);
fprintf(stderr, ""BIFS Scene description - %s stream\n"", b_cfg->elementaryMasks ? ""Animation"" : ""Command"");
if (full_dump && !b_cfg->elementaryMasks) {
fprintf(stderr, ""\tWidth %d Height %d Pixel Metrics %s\n"", b_cfg->pixelWidth, b_cfg->pixelHeight, b_cfg->pixelMetrics ? ""yes"" : ""no"");
}
gf_odf_desc_del((GF_Descriptor *)b_cfg);
} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_AFX) {
u8 tag = esd->decoderConfig->decoderSpecificInfo ? esd->decoderConfig->decoderSpecificInfo->data[0] : 0xFF;
const char *afxtype = gf_stream_type_afx_name(tag);
fprintf(stderr, ""AFX Stream - type %s (%d)\n"", afxtype, tag);
} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_FONT) {
fprintf(stderr, ""Font Data stream\n"");
} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_LASER) {
GF_LASERConfig l_cfg;
gf_odf_get_laser_config(esd->decoderConfig->decoderSpecificInfo, &l_cfg);
fprintf(stderr, ""LASER Stream - %s\n"", l_cfg.newSceneIndicator ? ""Full Scene"" : ""Scene Segment"");
} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_TEXT_MPEG4) {
fprintf(stderr, ""MPEG-4 Streaming Text stream\n"");
} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_SYNTHESIZED_TEXTURE) {
fprintf(stderr, ""Synthetized Texture stream stream\n"");
} else {
M4_LOG(GF_LOG_WARNING, (""Unknown Systems stream OTI %d\n"", esd->decoderConfig->objectTypeIndication));
}
}
if (!full_dump) {
if (dump_m4sys) {
if (!esd->OCRESID || (esd->OCRESID == esd->ESID))
fprintf(stderr, ""Self-synchronized\n"");
else
fprintf(stderr, ""Synchronized on stream %d\n"", esd->OCRESID);
}
} else {
fprintf(stderr, ""\tDecoding Buffer size %d - Bitrate: avg %d - max %d kbps\n"", esd->decoderConfig->bufferSizeDB, esd->decoderConfig->avgBitrate/1000, esd->decoderConfig->maxBitrate/1000);
if (esd->dependsOnESID)
fprintf(stderr, ""\tDepends on stream %d for decoding\n"", esd->dependsOnESID);
else
fprintf(stderr, ""\tNo stream dependencies for decoding\n"");
fprintf(stderr, ""\tStreamPriority %d\n"", esd->streamPriority);
if (esd->URLString) fprintf(stderr, ""\tRemote Data Source %s\n"", esd->URLString);
}
gf_odf_desc_del((GF_Descriptor *) esd);
}
} else if (msub_type == GF_ISOM_SUBTYPE_AV01) {
GF_AV1Config *av1c;
u32 w, h;
gf_isom_get_visual_info(file, trackNum, 1, &w, &h);
fprintf(stderr, ""\tAOM AV1 stream - Resolution %d x %d\n"", w, h);
av1c = gf_isom_av1_config_get(file, trackNum, 1);
fprintf(stderr, ""\tversion=%u, profile=%u, level_idx0=%u, tier=%u\n"", (u32)av1c->version, (u32)av1c->seq_profile, (u32)av1c->seq_level_idx_0, (u32)av1c->seq_tier_0);
fprintf(stderr, ""\thigh_bitdepth=%u, twelve_bit=%u, monochrome=%u\n"", (u32)av1c->high_bitdepth, (u32)av1c->twelve_bit, (u32)av1c->monochrome);
fprintf(stderr, ""\tchroma: subsampling_x=%u, subsampling_y=%u, sample_position=%u\n"", (u32)av1c->chroma_subsampling_x, (u32)av1c->chroma_subsampling_y, (u32)av1c->chroma_sample_position);
if (av1c->initial_presentation_delay_present)
fprintf(stderr, ""\tInitial presentation delay %u\n"", (u32) av1c->initial_presentation_delay_minus_one+1);
count = gf_list_count(av1c->obu_array);
for (i=0; i<count; i++) {
u8 hash[20];
GF_AV1_OBUArrayEntry *obu = gf_list_get(av1c->obu_array, i);
gf_sha1_csum((u8*)obu->obu, (u32)obu->obu_length, hash);
fprintf(stderr, ""\tOBU#%d %s hash: "", i+1, gf_av1_get_obu_name(obu->obu_type) );
for (j=0; j<20; j++) fprintf(stderr, ""%02X"", hash[j]);
fprintf(stderr, ""\n"");
}
gf_odf_av1_cfg_del(av1c);
} else if (msub_type == GF_ISOM_SUBTYPE_3GP_H263) {
u32 w, h;
gf_isom_get_visual_info(file, trackNum, 1, &w, &h);
fprintf(stderr, ""\t3GPP H263 stream - Resolution %d x %d\n"", w, h);
} else if (msub_type == GF_ISOM_SUBTYPE_MJP2) {
u32 w, h;
gf_isom_get_visual_info(file, trackNum, 1, &w, &h);
fprintf(stderr, ""\tMotionJPEG2000 stream - Resolution %d x %d\n"", w, h);
} else if ((msub_type == GF_ISOM_SUBTYPE_3GP_AMR) || (msub_type == GF_ISOM_SUBTYPE_3GP_AMR_WB)) {
fprintf(stderr, ""\t3GPP AMR%s stream - Sample Rate %d - %d channel(s) %d bps\n"", (msub_type == GF_ISOM_SUBTYPE_3GP_AMR_WB) ? "" Wide Band"" : """", sr, nb_ch, (u32) bps);
} else if (msub_type == GF_ISOM_SUBTYPE_3GP_EVRC) {
fprintf(stderr, ""\t3GPP EVRC stream - Sample Rate %d - %d channel(s) %d bps\n"", sr, nb_ch, (u32) bps);
} else if (msub_type == GF_ISOM_SUBTYPE_3GP_QCELP) {
fprintf(stderr, ""\t3GPP QCELP stream - Sample Rate %d - %d channel(s) %d bps\n"", sr, nb_ch, (u32) bps);
} else if (msub_type == GF_ISOM_SUBTYPE_MP3) {
fprintf(stderr, ""\tMPEG 1/2 Audio stream - Sample Rate %d - %d channel(s) %d bps\n"", sr, nb_ch, (u32) bps);
} else if ((msub_type == GF_ISOM_SUBTYPE_AC3) || (msub_type == GF_ISOM_SUBTYPE_EC3)) {
u32 br = 0;
const char *lfe = """";
Bool is_ec3 = (msub_type == GF_ISOM_SUBTYPE_EC3) ? GF_TRUE : GF_FALSE;
#ifndef GPAC_DISABLE_AV_PARSERS
GF_AC3Config *ac3 = gf_isom_ac3_config_get(file, trackNum, 1);
if (ac3) {
nb_ch = gf_ac3_get_channels(ac3->streams[0].acmod);
for (i=0; i<ac3->streams[0].nb_dep_sub; ++i) {
assert(ac3->streams[0].nb_dep_sub == 1);
nb_ch += gf_ac3_get_channels(ac3->streams[0].chan_loc);
}
if (ac3->streams[0].lfon) lfe = "".1"";
br = ac3->is_ec3 ? ac3->brcode : gf_ac3_get_bitrate(ac3->brcode);
is_ec3 = ac3->is_ec3;
gf_free(ac3);
}
#endif
fprintf(stderr, ""\t%s stream - Sample Rate %d - %d%s channel(s) - bitrate %d\n"", is_ec3 ? ""EC-3"" : ""AC-3"", sr, nb_ch, lfe, br);
} else if (msub_type == GF_ISOM_SUBTYPE_3GP_SMV) {
fprintf(stderr, ""\t3GPP SMV stream - Sample Rate %d - %d channel(s) %d bits per samples\n"", sr, nb_ch, (u32) bps);
} else if (msub_type == GF_ISOM_SUBTYPE_3GP_DIMS) {
u32 w, h;
GF_DIMSDescription dims;
gf_isom_get_visual_info(file, trackNum, 1, &w, &h);
gf_isom_get_dims_description(file, trackNum, 1, &dims);
fprintf(stderr, ""\t3GPP DIMS stream - size %d x %d - Profile %d - Level %d\n"", w, h, dims.profile, dims.level);
fprintf(stderr, ""\tpathComponents: %d - useFullRequestHost: %s\n"", dims.pathComponents, dims.fullRequestHost ? ""yes"" : ""no"");
fprintf(stderr, ""\tstream type: %s - redundant: %s\n"", dims.streamType ? ""primary"" : ""secondary"", (dims.containsRedundant==1) ? ""main"" : ((dims.containsRedundant==2) ? ""redundant"" : ""main+redundant"") );
if (dims.textEncoding[0]) fprintf(stderr, ""\ttext encoding %s\n"", dims.textEncoding);
if (dims.contentEncoding[0]) fprintf(stderr, ""\tcontent encoding %s\n"", dims.contentEncoding);
if (dims.content_script_types) fprintf(stderr, ""\tscript languages %s\n"", dims.content_script_types);
} else if (mtype==GF_ISOM_MEDIA_HINT) {
u32 refTrack;
s32 refCount = gf_isom_get_reference_count(file, trackNum, GF_ISOM_REF_HINT);
if (refCount>0) {
fprintf(stderr, ""Streaming Hint Track for track%s "", (refCount>1) ? ""s"" :"""");
for (i=0; i<(u32) refCount; i++) {
gf_isom_get_reference(file, trackNum, GF_ISOM_REF_HINT, i+1, &refTrack);
if (i) fprintf(stderr, "" - "");
fprintf(stderr, ""ID %d"", gf_isom_get_track_id(file, refTrack));
}
fprintf(stderr, ""\n"");
} else {
fprintf(stderr, ""Streaming Hint Track (no refs)\n"");
}
#ifndef GPAC_DISABLE_ISOM_HINTING
refCount = gf_isom_get_payt_count(file, trackNum);
if (refCount>0) {
for (i=0; i<(u32) refCount; i++) {
const char *name = gf_isom_get_payt_info(file, trackNum, i+1, &refTrack);
fprintf(stderr, ""\tPayload ID %d: type %s\n"", refTrack, name);
}
}
#endif
} else if (mtype==GF_ISOM_MEDIA_FLASH) {
fprintf(stderr, ""Macromedia Flash Movie\n"");
} else if ((mtype==GF_ISOM_MEDIA_TEXT) || (mtype==GF_ISOM_MEDIA_SUBT) || (mtype==GF_ISOM_MEDIA_MPEG_SUBT)) {
u32 w, h;
s16 l;
s32 tx, ty;
const char *content_encoding = NULL;
const char *mime = NULL;
const char *config  = NULL;
const char *_namespace = NULL;
const char *schema_loc = NULL;
const char *auxiliary_mimes = NULL;
gf_isom_get_track_layout_info(file, trackNum, &w, &h, &tx, &ty, &l);
if (msub_type == GF_ISOM_SUBTYPE_SBTT) {
gf_isom_stxt_get_description(file, trackNum, 1, &mime, &content_encoding, &config);
fprintf(stderr, ""Textual Subtitle Stream "");
fprintf(stderr, ""- mime %s"", mime);
if (content_encoding != NULL) {
fprintf(stderr, "" - encoding %s"", content_encoding);
}
if (config != NULL) {
fprintf(stderr, "" - %d bytes config"", (u32) strlen(config));
}
} else if (msub_type == GF_ISOM_SUBTYPE_STXT) {
gf_isom_stxt_get_description(file, trackNum, 1, &mime, &content_encoding, &config);
fprintf(stderr, ""Simple Timed Text Stream "");
fprintf(stderr, ""- mime %s"", mime);
if (content_encoding != NULL) {
fprintf(stderr, "" - encoding %s"", content_encoding);
}
if (config != NULL) {
fprintf(stderr, "" - %d bytes config"", (u32) strlen(config));
}
} else if (msub_type == GF_ISOM_SUBTYPE_STPP) {
gf_isom_xml_subtitle_get_description(file, trackNum, 1, &_namespace, &schema_loc, &auxiliary_mimes);
fprintf(stderr, ""XML Subtitle Stream "");
fprintf(stderr, ""- namespace %s"", _namespace);
if (schema_loc != NULL) {
fprintf(stderr, "" - schema-location %s"", schema_loc);
}
if (auxiliary_mimes != NULL) {
fprintf(stderr, "" - auxiliary-mime-types %s"", auxiliary_mimes);
}
} else {
fprintf(stderr, ""Unknown Text Stream"");
}
fprintf(stderr, ""\n Size %d x %d - Translation X=%d Y=%d - Layer %d\n"", w, h, tx, ty, l);
} else if (mtype == GF_ISOM_MEDIA_META) {
const char *content_encoding = NULL;
if (msub_type == GF_ISOM_SUBTYPE_METT) {
const char *mime = NULL;
const char *config  = NULL;
gf_isom_stxt_get_description(file, trackNum, 1, &mime, &content_encoding, &config);
fprintf(stderr, ""Textual Metadata Stream - mime %s"", mime);
if (content_encoding != NULL) {
fprintf(stderr, "" - encoding %s"", content_encoding);
}
if (config != NULL) {
fprintf(stderr, "" - %d bytes config"", (u32) strlen(config));
}
fprintf(stderr, ""\n"");
} else if (msub_type == GF_ISOM_SUBTYPE_METX) {
const char *_namespace = NULL;
const char *schema_loc = NULL;
gf_isom_get_xml_metadata_description(file, trackNum, 1, &_namespace, &schema_loc, &content_encoding);
fprintf(stderr, ""XML Metadata Stream - namespace %s"", _namespace);
if (content_encoding != NULL) {
fprintf(stderr, "" - encoding %s"", content_encoding);
}
if (schema_loc != NULL) {
fprintf(stderr, "" - schema-location %s"", schema_loc);
}
fprintf(stderr, ""\n"");
} else {
fprintf(stderr, ""Unknown Metadata Stream\n"");
}
} else if ((msub_type==GF_ISOM_SUBTYPE_VVC1) || (msub_type==GF_ISOM_SUBTYPE_VVI1)) {
GF_VVCConfig *vvccfg;
u32 w, h;
#if !defined(GPAC_DISABLE_AV_PARSERS)
VVCState *vvc_state;
GF_SAFEALLOC(vvc_state, VVCState);
if (vvc_state) vvc_state->sps_active_idx = -1;
#endif
gf_isom_get_visual_info(file, trackNum, 1, &w, &h);
if (full_dump) fprintf(stderr, ""\t"");
fprintf(stderr, ""VVC Video - Visual Size %d x %d\n"", w, h);
vvccfg = gf_isom_vvc_config_get(file, trackNum, 1);
if (!vvccfg) {
M4_LOG(GF_LOG_ERROR, (""Non-compliant VVC track: No vvcC found in sample description\n""));
} else {
dump_vvc_track_info(file, trackNum, vvccfg
#if !defined(GPAC_DISABLE_AV_PARSERS)
, vvc_state
#endif
);
gf_odf_vvc_cfg_del(vvccfg);
fprintf(stderr, ""\n"");
}
#if !defined(GPAC_DISABLE_AV_PARSERS)
if (vvc_state) gf_free(vvc_state);
#endif
} else if ((msub_type == GF_ISOM_SUBTYPE_MH3D_MHA1) || (msub_type == GF_ISOM_SUBTYPE_MH3D_MHA2)
|| (msub_type == GF_ISOM_SUBTYPE_MH3D_MHM1) || (msub_type == GF_ISOM_SUBTYPE_MH3D_MHM2)
) {
const u8 *compat_profiles;
u32 nb_compat_profiles;
Bool valid = GF_FALSE;
Bool allow_inband = GF_FALSE;
if ( (msub_type == GF_ISOM_SUBTYPE_MH3D_MHM1) || (msub_type == GF_ISOM_SUBTYPE_MH3D_MHM2))
allow_inband = GF_TRUE;
fprintf(stderr, ""\tMPEG-H Audio stream - Sample Rate %d\n"", sr);
esd = gf_media_map_esd(file, trackNum, 1);
if (!esd || !esd->decoderConfig || !esd->decoderConfig->decoderSpecificInfo
|| !esd->decoderConfig->decoderSpecificInfo->data
) {
if (allow_inband) {
GF_ISOSample *samp = gf_isom_get_sample(file, trackNum, 1, NULL);
if (samp) {
u64 ch_layout=0;
s32 PL = gf_mpegh_get_mhas_pl(samp->data, samp->dataLength, &ch_layout);
if (PL>=0) {
fprintf(stderr, ""\tProfileLevelIndication: 0x%02X"", PL);
if (ch_layout)
fprintf(stderr, "" - Reference Channel Layout %s"", gf_audio_fmt_get_layout_name(ch_layout) );
fprintf(stderr, ""\n"");
}
gf_isom_sample_del(&samp);
}
valid = GF_TRUE;
}
} else if (esd->decoderConfig->decoderSpecificInfo->dataLength>=5) {
fprintf(stderr, ""\tProfileLevelIndication: 0x%02X - Reference Channel Layout %s\n"", esd->decoderConfig->decoderSpecificInfo->data[1]
, gf_audio_fmt_get_layout_name_from_cicp(esd->decoderConfig->decoderSpecificInfo->data[2])
);
valid = GF_TRUE;
}
if (!valid) {
M4_LOG(GF_LOG_ERROR, (""Invalid MPEG-H audio config\n""));
}
if (esd) gf_odf_desc_del((GF_Descriptor *)esd);
compat_profiles = gf_isom_get_mpegh_compatible_profiles(file, trackNum, 1, &nb_compat_profiles);
for (i=0; i<nb_compat_profiles; i++) {
if (!i)
fprintf(stderr, ""\tCompatible profiles:"");
fprintf(stderr, "" 0x%02X"", compat_profiles[i]);
}
if (i) fprintf(stderr, ""\n"");
} else if (msub_type==GF_ISOM_SUBTYPE_MLPA) {
u32 fmt, prate;
if (gf_isom_truehd_config_get(file, trackNum, 1, &fmt, &prate) != GF_OK) {
fprintf(stderr, ""\tInvalid TrueHD audio config\n"");
}
fprintf(stderr, ""TrueHD Audio stream - Sample Rate %u - channels %u - format %u peak rate %u\n"", sr, nb_ch, fmt, prate);
} else if (codecid) {
if (gf_isom_is_video_handler_type(mtype) ) {
u32 w, h;
gf_isom_get_visual_info(file, trackNum, 1, &w, &h);
fprintf(stderr, ""%s - Resolution %d x %d\n"", gf_codecid_name(codecid), w, h);
} else if (mtype==GF_ISOM_MEDIA_AUDIO) {
gf_isom_get_audio_info(file, trackNum, 1, &sr, &nb_ch, NULL);
fprintf(stderr, ""%s - Sample Rate %d - %d channel(s)\n"", gf_codecid_name(codecid), sr, nb_ch);
} else {
fprintf(stderr, ""%s\n"", gf_codecid_name(codecid) );
}
} else if (pfmt) {
u32 w, h;
gf_isom_get_visual_info(file, trackNum, 1, &w, &h);
fprintf(stderr, ""Raw video %s - Resolution %d x %d\n"", gf_pixel_fmt_name(pfmt), w, h);
} else if (msub_type==GF_QT_SUBTYPE_TMCD) {
u32 stsd_idx;
GF_ISOSample *sample = gf_isom_get_sample(file, trackNum, 1, &stsd_idx);
fprintf(stderr, ""Time Code stream\n"");
if (sample) {
char szTimecode[100];
u32 tmcd_flags, tmcd_num, tmcd_den, tmcd_fpt;
gf_isom_get_tmcd_config(file, trackNum, stsd_idx, &tmcd_flags, &tmcd_num, &tmcd_den, &tmcd_fpt);
gf_inspect_format_timecode(sample->data, sample->dataLength, tmcd_flags, tmcd_num, tmcd_den, tmcd_fpt, szTimecode);
gf_isom_sample_del(&sample);
fprintf(stderr, ""\tFirst timecode: %s\n"", szTimecode);
}
} else {
GF_GenericSampleDescription *udesc;
udesc = gf_isom_get_generic_sample_description(file, trackNum, 1);
if (udesc) {
if (gf_isom_is_video_handler_type(mtype) ) {
fprintf(stderr, ""%s - Compressor \""%s\"" - Resolution %d x %d\n"",
( (mtype == GF_ISOM_MEDIA_VISUAL ? ""Visual"" : ""Auxiliary Video"") ),
udesc->compressor_name, udesc->width, udesc->height);
} else if (mtype==GF_ISOM_MEDIA_AUDIO) {
fprintf(stderr, ""Audio - Sample Rate %d - %d channel(s)\n"", udesc->samplerate, udesc->nb_channels);
} else {
fprintf(stderr, ""Unknown media type\n"");
}
if (udesc->vendor_code)
fprintf(stderr, ""\tVendor code \""%s\"" - Version %d - revision %d\n"", gf_4cc_to_str(udesc->vendor_code), udesc->version, udesc->revision);
if (udesc->extension_buf) {
fprintf(stderr, ""\tCodec configuration data size: %d bytes\n"", udesc->extension_buf_size);
gf_free(udesc->extension_buf);
}
gf_free(udesc);
} else {
fprintf(stderr, ""Unknown track type\n"");
}
}
if (gf_isom_is_track_encrypted(file, trackNum)) {
const char *scheme_URI, *KMS_URI;
u32 scheme_type, version;
u32 IV_size;
Bool use_sel_enc;
if (gf_isom_is_ismacryp_media(file, trackNum, 1)) {
gf_isom_get_ismacryp_info(file, trackNum, 1, NULL, &scheme_type, &version, &scheme_URI, &KMS_URI, &use_sel_enc, &IV_size, NULL);
fprintf(stderr, ""\n\tProtected by ISMA E&A scheme %s (version %d)\n"", gf_4cc_to_str(scheme_type), version);
if (scheme_URI) fprintf(stderr, ""scheme location: %s\n"", scheme_URI);
if (KMS_URI) {
if (!strnicmp(KMS_URI, ""(key)"", 5)) fprintf(stderr, ""\tKMS location: key in file\n"");
else fprintf(stderr, ""\tKMS location: %s\n"", KMS_URI);
}
fprintf(stderr, ""\tSelective Encryption: %s\n"", use_sel_enc ? ""Yes"" : ""No"");
if (IV_size) fprintf(stderr, ""\tInitialization Vector size: %d bits\n"", IV_size*8);
} else if (gf_isom_is_omadrm_media(file, trackNum, 1)) {
const char *textHdrs;
u32 enc_type, hdr_len;
u64 orig_len;
gf_isom_get_omadrm_info(file, trackNum, 1, NULL, &scheme_type, &version, &scheme_URI, &KMS_URI, &textHdrs, &hdr_len, &orig_len, &enc_type, &use_sel_enc, &IV_size, NULL);
fprintf(stderr, ""\n\tProtected by OMA DRM scheme %s (version %d)\n"", gf_4cc_to_str(scheme_type), version);
fprintf(stderr, ""\tRights Issuer: %s\n"", KMS_URI);
fprintf(stderr, ""\tContent ID: %s\n"", scheme_URI);
if (textHdrs) {
u32 offset;
const char *start = textHdrs;
fprintf(stderr, ""\tOMA Textual Headers:\n"");
i=0;
offset=0;
while (i<hdr_len) {
if (start[i]==0) {
fprintf(stderr, ""\t\t%s\n"", start+offset);
offset=i+1;
}
i++;
}
fprintf(stderr, ""\\tt%s\n"", start+offset);
}
if (orig_len) fprintf(stderr, ""\tOriginal media size ""LLD""\n"", orig_len);
fprintf(stderr, ""\tEncryption algorithm %s\n"", (enc_type==1) ? ""AEA 128 CBC"" : (enc_type ? ""AEA 128 CTR"" : ""None""));
fprintf(stderr, ""\tSelective Encryption: %s\n"", use_sel_enc ? ""Yes"" : ""No"");
if (IV_size) fprintf(stderr, ""\tInitialization Vector size: %d bits\n"", IV_size*8);
} else if(gf_isom_is_cenc_media(file, trackNum, 1)) {
const u8 *def_key;
u32 def_key_size;
Bool IsEncrypted;
u8 crypt_byte_block, skip_byte_block;
IV_size = 0;
gf_isom_get_cenc_info(file, trackNum, 1, NULL, &scheme_type, &version);
gf_isom_cenc_get_default_info(file, trackNum, 1, NULL, &IsEncrypted, &crypt_byte_block, &skip_byte_block, &def_key, &def_key_size);
fprintf(stderr, ""\n\tProtected by CENC scheme %s version 0x%08X"", gf_4cc_to_str(scheme_type), version);
if (crypt_byte_block && skip_byte_block)
fprintf(stderr, "" - Pattern %d:%d"", (u32) skip_byte_block, (u32) crypt_byte_block);
if (def_key && def_key[0])
fprintf(stderr, "" - MultiKey"");
fprintf(stderr, ""\n"");
dump_key_info(def_key, def_key_size, IsEncrypted);
} else if(gf_isom_is_adobe_protection_media(file, trackNum, 1)) {
gf_isom_get_adobe_protection_info(file, trackNum, 1, NULL, &scheme_type, &version, NULL);
fprintf(stderr, ""\nProtected by Adobe scheme %s (version %d)\n"", gf_4cc_to_str(scheme_type), version);
} else {
fprintf(stderr, ""\nProtected by unknown scheme %s\n"", gf_4cc_to_str(gf_isom_is_media_encrypted(file, trackNum, 0) ));
}
fprintf(stderr, ""\n"");
}
if ( gf_media_get_rfc_6381_codec_name(file, trackNum, szCodec, GF_FALSE, GF_FALSE) == GF_OK) {
fprintf(stderr, ""\tRFC6381 Codec Parameters: %s\n"", szCodec);
}
DumpMetaItem(file, 0, trackNum, ""\tTrack Meta"");
gf_isom_get_track_switch_group_count(file, trackNum, &alt_group, &nb_groups);
if (alt_group) {
fprintf(stderr, ""Alternate Group ID %d\n"", alt_group);
for (i=0; i<nb_groups; i++) {
u32 nb_crit, switchGroupID;
const u32 *criterias = gf_isom_get_track_switch_parameter(file, trackNum, i+1, &switchGroupID, &nb_crit);
if (!nb_crit) {
fprintf(stderr, ""\tNo criteria in %s group\n"", switchGroupID ? ""switch"" : ""alternate"");
} else {
if (switchGroupID) {
fprintf(stderr, ""\tSwitchGroup ID %d criterias: "", switchGroupID);
} else {
fprintf(stderr, ""\tAlternate Group criterias: "");
}
for (j=0; j<nb_crit; j++) {
if (j) fprintf(stderr, "" "");
fprintf(stderr, ""%s"", gf_4cc_to_str(criterias[j]) );
}
fprintf(stderr, ""\n"");
}
}
}
switch (gf_isom_has_sync_points(file, trackNum)) {
case 0:
fprintf(stderr, ""\tAll samples are sync\n"");
break;
case 1:
{
u32 nb_sync = gf_isom_get_sync_point_count(file, trackNum) - 1;
if (! nb_sync) {
fprintf(stderr, ""\tOnly one sync sample\n"");
} else {
fprintf(stderr, ""\tAverage GOP length: %d samples\n"", gf_isom_get_sample_count(file, trackNum) / nb_sync);
}
}
break;
case 2:
fprintf(stderr, ""\tNo sync sample found\n"");
break;
}
fprintf(stderr, ""\tMax sample duration: %d / %d\n"", gf_isom_get_max_sample_delta(file, trackNum), timescale);
if (!full_dump) {
fprintf(stderr, ""\n"");
return;
}
dur = size = 0;
max_rate = rate = 0;
time_slice = 0;
ts = gf_isom_get_media_timescale(file, trackNum);
csize = gf_isom_get_constant_sample_size(file, trackNum);
cdur = gf_isom_get_constant_sample_duration(file, trackNum);
count = gf_isom_get_sample_count(file, trackNum);
if (csize && cdur) {
size = count * csize;
dur = cdur * count;
} else {
for (j=0; j<count; j++) {
GF_ISOSample *samp;
if (is_od_track) {
samp = gf_isom_get_sample(file, trackNum, j+1, NULL);
} else {
samp = gf_isom_get_sample_info(file, trackNum, j+1, NULL, NULL);
}
if (!samp) {
M4_LOG(GF_LOG_ERROR, (""Failed to fetch sample %d\n"", j+1));
return;
}
dur = samp->DTS+samp->CTS_Offset;
size += samp->dataLength;
rate += samp->dataLength;
if (samp->DTS - time_slice > ts) {
Double max_tmp = rate * ts / (samp->DTS - time_slice);
if (max_rate < max_tmp )
max_rate = max_tmp;
rate = 0;
time_slice = samp->DTS;
}
gf_isom_sample_del(&samp);
}
}
fprintf(stderr, ""\nComputed info from media:\n"");
if (csize && cdur) {
fprintf(stderr, ""\tConstant sample size %d bytes and dur %d / %d\n"", csize, cdur, ts);
}
scale = 1000.0 / ts;
dur = (u64) (scale * dur);
fprintf(stderr, ""\tTotal size ""LLU"" bytes - Total samples duration ""LLU"" ms\n"", size, dur);
if (!dur) {
fprintf(stderr, ""\n"");
return;
}
rate = 8000.0 * size / dur;
if (!max_rate)
max_rate = rate;
else
max_rate *= 8.0;
if (rate >= 1500) {
fprintf(stderr, ""\tAverage rate %.2f kbps - Max Rate %.2f kbps\n"", rate/1000, max_rate/1000);
} else {
fprintf(stderr, ""\tAverage rate %.2f bps - Max Rate %.2f bps\n"", rate, max_rate);
}
{
u32 dmin, dmax, davg, smin, smax, savg;
gf_isom_get_chunks_infos(file, trackNum, &dmin, &davg, &dmax, &smin, &savg, &smax);
fprintf(stderr, ""\tChunk durations: min %d ms - max %d ms - average %d ms\n"", (1000*dmin)/ts, (1000*dmax)/ts, (1000*davg)/ts);
fprintf(stderr, ""\tChunk sizes (bytes): min %d - max %d - average %d\n"", smin, smax, savg);
}
fprintf(stderr, ""\n"");
count = gf_isom_get_chapter_count(file, trackNum);
if (count) {
const char *name;
u64 time;
fprintf(stderr, ""\nChapters:\n"");
for (j=0; j<count; j++) {
gf_isom_get_chapter(file, trackNum, j+1, &time, &name);
fprintf(stderr, ""\tChapter #%d - %s - \""%s\""\n"", j+1, format_duration(time, 1000, szDur), name);
}
}
}","[477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 491]",The DumpTrackInfo function in GPAC 1.0.1 allows attackers to cause a denial of service (NULL pointer dereference) via a crafted file in the MP4Box command.,gpac,CVE-2021-32138,CWE-476
8400,6073,"static void parse_sec_attr_44(sc_file_t *file, const u8 *buf, size_t len)
{
const int df_idx[8] = {
SC_AC_OP_DELETE, SC_AC_OP_CREATE, SC_AC_OP_CREATE,
SC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE,
SC_AC_OP_LOCK, SC_AC_OP_DELETE, -1};
const int ef_idx[8] = {
SC_AC_OP_READ, SC_AC_OP_UPDATE, SC_AC_OP_WRITE,
SC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE,
-1, SC_AC_OP_ERASE, -1};
const int efi_idx[8] = {
SC_AC_OP_READ, SC_AC_OP_ERASE, SC_AC_OP_UPDATE,
SC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE,
-1, SC_AC_OP_ERASE, -1};
u8  bValue;
int  i;
int  iKeyRef = 0;
int  iMethod;
int  iPinCount;
int  iOffset = 0;
int  iOperation;
const int* p_idx;
while (len > 1) {
size_t iACLen   = buf[iOffset] & 0x0F;
if (iACLen > len)
break;
iMethod = SC_AC_NONE;
if (buf[iOffset] & 0X80) {
size_t iParmLen = 1;
size_t iKeyLen  = 0;
if (buf[iOffset]   & 0x20) iKeyLen++;
if (buf[iOffset+1] & 0x40) iParmLen++;
if (buf[iOffset+1] & 0x20) iParmLen++;
if (buf[iOffset+1] & 0x10) iParmLen++;
if (buf[iOffset+1] & 0x08) iParmLen++;
if(iKeyLen) {
int iSC;
if (len < 1+(size_t)iACLen)
break;
iSC = buf[iOffset+iACLen];
switch( (iSC>>5) & 0x03 ){
case 0:
iMethod = SC_AC_TERM;
break;
case 1:
iMethod = SC_AC_AUT;
break;
case 2:
case 3:
iMethod = SC_AC_PRO;
break;
}
iKeyRef = iSC & 0x1F;
}
if (iACLen > (1+iParmLen+iKeyLen)) {
if (len < 1+1+1+(size_t)iParmLen)
break;
iKeyRef = buf[iOffset+1+1+iParmLen];
iMethod = SC_AC_CHV;
}
if (len < 1+2)
break;
switch(buf[iOffset+2]){
case 0x2A:
iOperation = SC_AC_OP_CRYPTO;
break;
case 0x46:
iOperation = SC_AC_OP_UPDATE;
break;
default:
iOperation = SC_AC_OP_SELECT;
break;
}
sc_file_add_acl_entry(file, iOperation, iMethod, iKeyRef);
}
else {
switch (file->type) {
case SC_FILE_TYPE_DF:
p_idx = df_idx;
break;
case SC_FILE_TYPE_INTERNAL_EF:
p_idx = efi_idx;
break;
default:
p_idx = ef_idx;
break;
}
iPinCount = iACLen - 1;
if (buf[iOffset] & 0x20) {
int iSC;
if (len < 1 + (size_t)iACLen)
break;
iSC = buf[iOffset + iACLen];
switch( (iSC>>5) & 0x03 ) {
case 0:
iMethod = SC_AC_TERM;
break;
case 1:
iMethod = SC_AC_AUT;
break;
case 2:
case 3:
iMethod = SC_AC_PRO;
break;
}
iKeyRef = iSC & 0x1F;
iPinCount--;
}
if ( iPinCount > 0 ) {
if (len < 1 + 2)
break;
iKeyRef = buf[iOffset + 2];
iMethod = SC_AC_CHV;
}
bValue = buf[iOffset + 1];
for (i = 0; i < 8; i++) {
if((bValue & 1) && (p_idx[i] >= 0))
sc_file_add_acl_entry(file, p_idx[i], iMethod, iKeyRef);
bValue >>= 1;
}
}
iOffset += iACLen +1;
len     -= iACLen +1;
}
}",[88],An issue was discovered in OpenSC through 0.19.0 and 0.20.x through 0.20.0-rc3. libopensc/card-setcos.c has an incorrect read operation during parsing of a SETCOS file attribute.,OpenSC,CVE-2019-19479,CWE-125
8403,1850,"lldp_decode(struct lldpd *cfg, char *frame, int s,
struct lldpd_hardware *hardware,
struct lldpd_chassis **newchassis, struct lldpd_port **newport)
{
struct lldpd_chassis *chassis;
struct lldpd_port *port;
const char lldpaddr[] = LLDP_MULTICAST_ADDR;
const char dot1[] = LLDP_TLV_ORG_DOT1;
const char dot3[] = LLDP_TLV_ORG_DOT3;
const char med[] = LLDP_TLV_ORG_MED;
const char dcbx[] = LLDP_TLV_ORG_DCBX;
unsigned char orgid[3];
int length, gotend = 0, ttl_received = 0;
int tlv_size, tlv_type, tlv_subtype;
u_int8_t *pos, *tlv;
char *b;
#ifdef ENABLE_DOT1
struct lldpd_vlan *vlan = NULL;
int vlan_len;
struct lldpd_ppvid *ppvid;
struct lldpd_pi *pi = NULL;
#endif
struct lldpd_mgmt *mgmt;
int af;
u_int8_t addr_str_length, addr_str_buffer[32];
u_int8_t addr_family, addr_length, *addr_ptr, iface_subtype;
u_int32_t iface_number, iface;
#ifdef ENABLE_CUSTOM
struct lldpd_custom *custom = NULL;
#endif
log_debug(""lldp"", ""receive LLDP PDU on %s"",
hardware->h_ifname);
if ((chassis = calloc(1, sizeof(struct lldpd_chassis))) == NULL) {
log_warn(""lldp"", ""failed to allocate remote chassis"");
return -1;
}
TAILQ_INIT(&chassis->c_mgmt);
if ((port = calloc(1, sizeof(struct lldpd_port))) == NULL) {
log_warn(""lldp"", ""failed to allocate remote port"");
free(chassis);
return -1;
}
#ifdef ENABLE_DOT1
TAILQ_INIT(&port->p_vlans);
TAILQ_INIT(&port->p_ppvids);
TAILQ_INIT(&port->p_pids);
#endif
#ifdef ENABLE_CUSTOM
TAILQ_INIT(&port->p_custom_list);
#endif
length = s;
pos = (u_int8_t*)frame;
if (length < 2*ETHER_ADDR_LEN + sizeof(u_int16_t)) {
log_warnx(""lldp"", ""too short frame received on %s"", hardware->h_ifname);
goto malformed;
}
if (PEEK_CMP(lldpaddr, ETHER_ADDR_LEN) != 0) {
log_info(""lldp"", ""frame not targeted at LLDP multicast address received on %s"",
hardware->h_ifname);
goto malformed;
}
PEEK_DISCARD(ETHER_ADDR_LEN);
if (PEEK_UINT16 != ETHERTYPE_LLDP) {
log_info(""lldp"", ""non LLDP frame received on %s"",
hardware->h_ifname);
goto malformed;
}
while (length && (!gotend)) {
if (length < 2) {
log_warnx(""lldp"", ""tlv header too short received on %s"",
hardware->h_ifname);
goto malformed;
}
tlv_size = PEEK_UINT16;
tlv_type = tlv_size >> 9;
tlv_size = tlv_size & 0x1ff;
(void)PEEK_SAVE(tlv);
if (length < tlv_size) {
log_warnx(""lldp"", ""frame too short for tlv received on %s"",
hardware->h_ifname);
goto malformed;
}
switch (tlv_type) {
case LLDP_TLV_END:
if (tlv_size != 0) {
log_warnx(""lldp"", ""lldp end received with size not null on %s"",
hardware->h_ifname);
goto malformed;
}
if (length)
log_debug(""lldp"", ""extra data after lldp end on %s"",
hardware->h_ifname);
gotend = 1;
break;
case LLDP_TLV_CHASSIS_ID:
case LLDP_TLV_PORT_ID:
CHECK_TLV_SIZE(2, ""Port Id"");
tlv_subtype = PEEK_UINT8;
if ((tlv_subtype == 0) || (tlv_subtype > 7)) {
log_warnx(""lldp"", ""unknown subtype for tlv id received on %s"",
hardware->h_ifname);
goto malformed;
}
if ((b = (char *)calloc(1, tlv_size - 1)) == NULL) {
log_warn(""lldp"", ""unable to allocate memory for id tlv ""
""received on %s"",
hardware->h_ifname);
goto malformed;
}
PEEK_BYTES(b, tlv_size - 1);
if (tlv_type == LLDP_TLV_PORT_ID) {
port->p_id_subtype = tlv_subtype;
port->p_id = b;
port->p_id_len = tlv_size - 1;
} else {
chassis->c_id_subtype = tlv_subtype;
chassis->c_id = b;
chassis->c_id_len = tlv_size - 1;
}
break;
case LLDP_TLV_TTL:
CHECK_TLV_SIZE(2, ""TTL"");
chassis->c_ttl = PEEK_UINT16;
ttl_received = 1;
break;
case LLDP_TLV_PORT_DESCR:
case LLDP_TLV_SYSTEM_NAME:
case LLDP_TLV_SYSTEM_DESCR:
if (tlv_size < 1) {
log_debug(""lldp"", ""empty tlv received on %s"",
hardware->h_ifname);
break;
}
if ((b = (char *)calloc(1, tlv_size + 1)) == NULL) {
log_warn(""lldp"", ""unable to allocate memory for string tlv ""
""received on %s"",
hardware->h_ifname);
goto malformed;
}
PEEK_BYTES(b, tlv_size);
if (tlv_type == LLDP_TLV_PORT_DESCR)
port->p_descr = b;
else if (tlv_type == LLDP_TLV_SYSTEM_NAME)
chassis->c_name = b;
else chassis->c_descr = b;
break;
case LLDP_TLV_SYSTEM_CAP:
CHECK_TLV_SIZE(4, ""System capabilities"");
chassis->c_cap_available = PEEK_UINT16;
chassis->c_cap_enabled = PEEK_UINT16;
break;
case LLDP_TLV_MGMT_ADDR:
CHECK_TLV_SIZE(1, ""Management address"");
addr_str_length = PEEK_UINT8;
CHECK_TLV_SIZE(1 + addr_str_length, ""Management address"");
PEEK_BYTES(addr_str_buffer, addr_str_length);
addr_length = addr_str_length - 1;
addr_family = addr_str_buffer[0];
addr_ptr = &addr_str_buffer[1];
CHECK_TLV_SIZE(1 + addr_str_length + 5, ""Management address"");
iface_subtype = PEEK_UINT8;
iface_number = PEEK_UINT32;
af = lldpd_af_from_lldp_proto(addr_family);
if (af == LLDPD_AF_UNSPEC)
break;
if (iface_subtype == LLDP_MGMT_IFACE_IFINDEX)
iface = iface_number;
else
iface = 0;
mgmt = lldpd_alloc_mgmt(af, addr_ptr, addr_length, iface);
if (mgmt == NULL) {
assert(errno == ENOMEM);
log_warn(""lldp"", ""unable to allocate memory ""
""for management address"");
goto malformed;
}
TAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt, m_entries);
break;
case LLDP_TLV_ORG:
CHECK_TLV_SIZE(4, ""Organisational"");
PEEK_BYTES(orgid, sizeof(orgid));
tlv_subtype = PEEK_UINT8;
if (memcmp(dot1, orgid, sizeof(orgid)) == 0) {
#ifndef ENABLE_DOT1
hardware->h_rx_unrecognized_cnt++;
#else
switch (tlv_subtype) {
case LLDP_TLV_DOT1_VLANNAME:
CHECK_TLV_SIZE(7, ""VLAN"");
if ((vlan = (struct lldpd_vlan *)calloc(1,
sizeof(struct lldpd_vlan))) == NULL) {
log_warn(""lldp"", ""unable to alloc vlan ""
""structure for ""
""tlv received on %s"",
hardware->h_ifname);
goto malformed;
}
vlan->v_vid = PEEK_UINT16;
vlan_len = PEEK_UINT8;
CHECK_TLV_SIZE(7 + vlan_len, ""VLAN"");
if ((vlan->v_name =
(char *)calloc(1, vlan_len + 1)) == NULL) {
log_warn(""lldp"", ""unable to alloc vlan name for ""
""tlv received on %s"",
hardware->h_ifname);
goto malformed;
}
PEEK_BYTES(vlan->v_name, vlan_len);
TAILQ_INSERT_TAIL(&port->p_vlans,
vlan, v_entries);
vlan = NULL;
break;
case LLDP_TLV_DOT1_PVID:
CHECK_TLV_SIZE(6, ""PVID"");
port->p_pvid = PEEK_UINT16;
break;
case LLDP_TLV_DOT1_PPVID:
CHECK_TLV_SIZE(7, ""PPVID"");
if ((ppvid = (struct lldpd_ppvid *)calloc(1,
sizeof(struct lldpd_ppvid))) == NULL) {
log_warn(""lldp"", ""unable to alloc ppvid ""
""structure for ""
""tlv received on %s"",
hardware->h_ifname);
goto malformed;
}
ppvid->p_cap_status = PEEK_UINT8;
ppvid->p_ppvid = PEEK_UINT16;
TAILQ_INSERT_TAIL(&port->p_ppvids,
ppvid, p_entries);
break;
case LLDP_TLV_DOT1_PI:
CHECK_TLV_SIZE(5, ""PI"");
if ((pi = (struct lldpd_pi *)calloc(1,
sizeof(struct lldpd_pi))) == NULL) {
log_warn(""lldp"", ""unable to alloc PI ""
""structure for ""
""tlv received on %s"",
hardware->h_ifname);
goto malformed;
}
pi->p_pi_len = PEEK_UINT8;
CHECK_TLV_SIZE(5 + pi->p_pi_len, ""PI"");
if ((pi->p_pi =
(char *)calloc(1, pi->p_pi_len)) == NULL) {
log_warn(""lldp"", ""unable to alloc pid name for ""
""tlv received on %s"",
hardware->h_ifname);
goto malformed;
}
PEEK_BYTES(pi->p_pi, pi->p_pi_len);
TAILQ_INSERT_TAIL(&port->p_pids,
pi, p_entries);
pi = NULL;
break;
default:
hardware->h_rx_unrecognized_cnt++;
}
#endif
} else if (memcmp(dot3, orgid, sizeof(orgid)) == 0) {
#ifndef ENABLE_DOT3
hardware->h_rx_unrecognized_cnt++;
#else
switch (tlv_subtype) {
case LLDP_TLV_DOT3_MAC:
CHECK_TLV_SIZE(9, ""MAC/PHY"");
port->p_macphy.autoneg_support = PEEK_UINT8;
port->p_macphy.autoneg_enabled =
(port->p_macphy.autoneg_support & 0x2) >> 1;
port->p_macphy.autoneg_support =
port->p_macphy.autoneg_support & 0x1;
port->p_macphy.autoneg_advertised =
PEEK_UINT16;
port->p_macphy.mau_type = PEEK_UINT16;
break;
case LLDP_TLV_DOT3_LA:
CHECK_TLV_SIZE(9, ""Link aggregation"");
PEEK_DISCARD_UINT8;
port->p_aggregid = PEEK_UINT32;
break;
case LLDP_TLV_DOT3_MFS:
CHECK_TLV_SIZE(6, ""MFS"");
port->p_mfs = PEEK_UINT16;
break;
case LLDP_TLV_DOT3_POWER:
CHECK_TLV_SIZE(7, ""Power"");
port->p_power.devicetype = PEEK_UINT8;
port->p_power.supported =
(port->p_power.devicetype & 0x2) >> 1;
port->p_power.enabled =
(port->p_power.devicetype & 0x4) >> 2;
port->p_power.paircontrol =
(port->p_power.devicetype & 0x8) >> 3;
port->p_power.devicetype =
(port->p_power.devicetype & 0x1)?
LLDP_DOT3_POWER_PSE:LLDP_DOT3_POWER_PD;
port->p_power.pairs = PEEK_UINT8;
port->p_power.class = PEEK_UINT8;
if (tlv_size >= 12) {
port->p_power.powertype = PEEK_UINT8;
port->p_power.source =
(port->p_power.powertype & (1<<5 | 1<<4)) >> 4;
port->p_power.priority =
(port->p_power.powertype & (1<<1 | 1<<0));
port->p_power.powertype =
(port->p_power.powertype & (1<<7))?
LLDP_DOT3_POWER_8023AT_TYPE1:
LLDP_DOT3_POWER_8023AT_TYPE2;
port->p_power.requested = PEEK_UINT16;
port->p_power.allocated = PEEK_UINT16;
} else
port->p_power.powertype =
LLDP_DOT3_POWER_8023AT_OFF;
break;
default:
hardware->h_rx_unrecognized_cnt++;
}
#endif
} else if (memcmp(med, orgid, sizeof(orgid)) == 0) {
#ifndef ENABLE_LLDPMED
hardware->h_rx_unrecognized_cnt++;
#else
u_int32_t policy;
unsigned loctype;
unsigned power;
switch (tlv_subtype) {
case LLDP_TLV_MED_CAP:
CHECK_TLV_SIZE(7, ""LLDP-MED capabilities"");
chassis->c_med_cap_available = PEEK_UINT16;
chassis->c_med_type = PEEK_UINT8;
port->p_med_cap_enabled |=
LLDP_MED_CAP_CAP;
break;
case LLDP_TLV_MED_POLICY:
CHECK_TLV_SIZE(8, ""LLDP-MED policy"");
policy = PEEK_UINT32;
if (((policy >> 24) < 1) ||
((policy >> 24) > LLDP_MED_APPTYPE_LAST)) {
log_info(""lldp"", ""unknown policy field %d ""
""received on %s"",
policy,
hardware->h_ifname);
break;
}
port->p_med_policy[(policy >> 24) - 1].type =
(policy >> 24);
port->p_med_policy[(policy >> 24) - 1].unknown =
((policy & 0x800000) != 0);
port->p_med_policy[(policy >> 24) - 1].tagged =
((policy & 0x400000) != 0);
port->p_med_policy[(policy >> 24) - 1].vid =
(policy & 0x001FFE00) >> 9;
port->p_med_policy[(policy >> 24) - 1].priority =
(policy & 0x1C0) >> 6;
port->p_med_policy[(policy >> 24) - 1].dscp =
policy & 0x3F;
port->p_med_cap_enabled |=
LLDP_MED_CAP_POLICY;
break;
case LLDP_TLV_MED_LOCATION:
CHECK_TLV_SIZE(5, ""LLDP-MED Location"");
loctype = PEEK_UINT8;
if ((loctype < 1) ||
(loctype > LLDP_MED_LOCFORMAT_LAST)) {
log_info(""lldp"", ""unknown location type ""
""received on %s"",
hardware->h_ifname);
break;
}
if ((port->p_med_location[loctype - 1].data =
(char*)malloc(tlv_size - 5)) == NULL) {
log_warn(""lldp"", ""unable to allocate memory ""
""for LLDP-MED location for ""
""frame received on %s"",
hardware->h_ifname);
goto malformed;
}
PEEK_BYTES(port->p_med_location[loctype - 1].data,
tlv_size - 5);
port->p_med_location[loctype - 1].data_len =
tlv_size - 5;
port->p_med_location[loctype - 1].format = loctype;
port->p_med_cap_enabled |=
LLDP_MED_CAP_LOCATION;
break;
case LLDP_TLV_MED_MDI:
CHECK_TLV_SIZE(7, ""LLDP-MED PoE-MDI"");
power = PEEK_UINT8;
switch (power & 0xC0) {
case 0x0:
port->p_med_power.devicetype = LLDP_MED_POW_TYPE_PSE;
port->p_med_cap_enabled |=
LLDP_MED_CAP_MDI_PSE;
switch (power & 0x30) {
case 0x0:
port->p_med_power.source =
LLDP_MED_POW_SOURCE_UNKNOWN;
break;
case 0x10:
port->p_med_power.source =
LLDP_MED_POW_SOURCE_PRIMARY;
break;
case 0x20:
port->p_med_power.source =
LLDP_MED_POW_SOURCE_BACKUP;
break;
default:
port->p_med_power.source =
LLDP_MED_POW_SOURCE_RESERVED;
}
break;
case 0x40:
port->p_med_power.devicetype = LLDP_MED_POW_TYPE_PD;
port->p_med_cap_enabled |=
LLDP_MED_CAP_MDI_PD;
switch (power & 0x30) {
case 0x0:
port->p_med_power.source =
LLDP_MED_POW_SOURCE_UNKNOWN;
break;
case 0x10:
port->p_med_power.source =
LLDP_MED_POW_SOURCE_PSE;
break;
case 0x20:
port->p_med_power.source =
LLDP_MED_POW_SOURCE_LOCAL;
break;
default:
port->p_med_power.source =
LLDP_MED_POW_SOURCE_BOTH;
}
break;
default:
port->p_med_power.devicetype =
LLDP_MED_POW_TYPE_RESERVED;
}
if ((power & 0x0F) > LLDP_MED_POW_PRIO_LOW)
port->p_med_power.priority =
LLDP_MED_POW_PRIO_UNKNOWN;
else
port->p_med_power.priority =
power & 0x0F;
port->p_med_power.val = PEEK_UINT16;
break;
case LLDP_TLV_MED_IV_HW:
case LLDP_TLV_MED_IV_SW:
case LLDP_TLV_MED_IV_FW:
case LLDP_TLV_MED_IV_SN:
case LLDP_TLV_MED_IV_MANUF:
case LLDP_TLV_MED_IV_MODEL:
case LLDP_TLV_MED_IV_ASSET:
if (tlv_size <= 4)
b = NULL;
else {
if ((b = (char*)malloc(tlv_size - 3)) ==
NULL) {
log_warn(""lldp"", ""unable to allocate ""
""memory for LLDP-MED ""
""inventory for frame ""
""received on %s"",
hardware->h_ifname);
goto malformed;
}
PEEK_BYTES(b, tlv_size - 4);
b[tlv_size - 4] = '\0';
}
switch (tlv_subtype) {
case LLDP_TLV_MED_IV_HW:
chassis->c_med_hw = b;
break;
case LLDP_TLV_MED_IV_FW:
chassis->c_med_fw = b;
break;
case LLDP_TLV_MED_IV_SW:
chassis->c_med_sw = b;
break;
case LLDP_TLV_MED_IV_SN:
chassis->c_med_sn = b;
break;
case LLDP_TLV_MED_IV_MANUF:
chassis->c_med_manuf = b;
break;
case LLDP_TLV_MED_IV_MODEL:
chassis->c_med_model = b;
break;
case LLDP_TLV_MED_IV_ASSET:
chassis->c_med_asset = b;
break;
}
port->p_med_cap_enabled |=
LLDP_MED_CAP_IV;
break;
default:
hardware->h_rx_unrecognized_cnt++;
}
#endif /* ENABLE_LLDPMED */
} else if (memcmp(dcbx, orgid, sizeof(orgid)) == 0) {
log_debug(""lldp"", ""unsupported DCBX tlv received on %s - ignore"",
hardware->h_ifname);
hardware->h_rx_unrecognized_cnt++;
} else {
log_debug(""lldp"", ""unknown org tlv [%02x:%02x:%02x] received on %s"",
orgid[0], orgid[1], orgid[2],
hardware->h_ifname);
hardware->h_rx_unrecognized_cnt++;
#ifdef ENABLE_CUSTOM
custom = (struct lldpd_custom*)calloc(1, sizeof(struct lldpd_custom));
if (!custom) {
log_warn(""lldp"",
""unable to allocate memory for custom TLV"");
goto malformed;
}
custom->oui_info_len = tlv_size > 4 ? tlv_size - 4 : 0;
memcpy(custom->oui, orgid, sizeof(custom->oui));
custom->subtype = tlv_subtype;
if (custom->oui_info_len > 0) {
custom->oui_info = malloc(custom->oui_info_len);
if (!custom->oui_info) {
log_warn(""lldp"",
""unable to allocate memory for custom TLV data"");
goto malformed;
}
PEEK_BYTES(custom->oui_info, custom->oui_info_len);
}
TAILQ_INSERT_TAIL(&port->p_custom_list, custom, next);
custom = NULL;
#endif
}
break;
default:
log_warnx(""lldp"", ""unknown tlv (%d) received on %s"",
tlv_type, hardware->h_ifname);
goto malformed;
}
if (pos > tlv + tlv_size) {
log_warnx(""lldp"", ""BUG: already past TLV!"");
goto malformed;
}
PEEK_DISCARD(tlv + tlv_size - pos);
}
if ((chassis->c_id == NULL) ||
(port->p_id == NULL) ||
(!ttl_received) ||
(gotend == 0)) {
log_warnx(""lldp"", ""some mandatory tlv are missing for frame received on %s"",
hardware->h_ifname);
goto malformed;
}
*newchassis = chassis;
*newport = port;
return 1;
malformed:
#ifdef ENABLE_CUSTOM
free(custom);
#endif
#ifdef ENABLE_DOT1
free(vlan);
free(pi);
#endif
lldpd_chassis_cleanup(chassis, 1);
lldpd_port_cleanup(port, 1);
free(port);
return -1;
}","[155, 180]",Buffer overflow in the lldp_decode function in daemon/protocols/lldp.c in lldpd before 0.8.0 allows remote attackers to cause a denial of service (daemon crash) and possibly execute arbitrary code via vectors involving large management addresses and TLV boundaries.,lldpd,CVE-2015-8011,CWE-120
8411,8578,"is_ref(const uint8_t *data, size_t beg, size_t end, size_t *last, struct link_ref **refs)
{
size_t i = 0;
size_t id_offset, id_end;
size_t link_offset, link_end;
size_t title_offset, title_end;
size_t line_end;
if (beg + 3 >= end) return 0;
if (data[beg] == ' ') { i = 1;
if (data[beg + 1] == ' ') { i = 2;
if (data[beg + 2] == ' ') { i = 3;
if (data[beg + 3] == ' ') return 0; } } }
i += beg;
if (data[i] != '[') return 0;
i++;
id_offset = i;
while (i < end && data[i] != '\n' && data[i] != '\r' && data[i] != ']')
i++;
if (i >= end || data[i] != ']') return 0;
id_end = i;
i++;
if (i >= end || data[i] != ':') return 0;
i++;
while (i < end && data[i] == ' ') i++;
if (i < end && (data[i] == '\n' || data[i] == '\r')) {
i++;
if (i < end && data[i] == '\r' && data[i - 1] == '\n') i++; }
while (i < end && data[i] == ' ') i++;
if (i >= end) return 0;
if (data[i] == '<')
i++;
link_offset = i;
while (i < end && data[i] != ' ' && data[i] != '\n' && data[i] != '\r')
i++;
if (data[i - 1] == '>') link_end = i - 1;
else link_end = i;
while (i < end && data[i] == ' ') i++;
if (i < end && data[i] != '\n' && data[i] != '\r'
&& data[i] != '\'' && data[i] != '""' && data[i] != '(')
return 0;
line_end = 0;
if (i >= end || data[i] == '\r' || data[i] == '\n') line_end = i;
if (i + 1 < end && data[i] == '\n' && data[i + 1] == '\r')
line_end = i + 1;
if (line_end) {
i = line_end + 1;
while (i < end && data[i] == ' ') i++; }
title_offset = title_end = 0;
if (i + 1 < end
&& (data[i] == '\'' || data[i] == '""' || data[i] == '(')) {
i++;
title_offset = i;
while (i < end && data[i] != '\n' && data[i] != '\r') i++;
if (i + 1 < end && data[i] == '\n' && data[i + 1] == '\r')
title_end = i + 1;
else title_end = i;
i -= 1;
while (i > title_offset && data[i] == ' ')
i -= 1;
if (i > title_offset
&& (data[i] == '\'' || data[i] == '""' || data[i] == ')')) {
line_end = title_end;
title_end = i; } }
if (!line_end || link_end == link_offset)
return 0;
if (last)
*last = line_end;
if (refs) {
struct link_ref *ref;
ref = add_link_ref(refs, data + id_offset, id_end - id_offset);
if (!ref)
return 0;
ref->link = bufnew(link_end - link_offset);
bufput(ref->link, data + link_offset, link_end - link_offset);
if (title_end > title_offset) {
ref->title = bufnew(title_end - title_offset);
bufput(ref->title, data + title_offset, title_end - title_offset);
}
}
return 1;
}",[73],"Snudown is a reddit-specific fork of the Sundown Markdown parser used by GitHub, with Python integration added. In affected versions snudown was found to be vulnerable to denial of service attacks to its reference table implementation. References written in markdown ` [reference_name]: https://www.example.com` are inserted into a hash table which was found to have a weak hash function, meaning that an attacker can reliably generate a large number of collisions for it. This makes the hash table vulnerable to a hash-collision DoS attack, a type of algorithmic complexity attack. Further the hash table allowed for duplicate entries resulting in long retrieval times. Proofs of concept and further discussion of the hash collision issue are discussed on the snudown GHSA(https://github.com/reddit/snudown/security/advisories/GHSA-6gvv-9q92-w5f6). Users are advised to update to version 1.7.0.",snudown,CVE-2021-41168,CWE-407
8419,7804,"int main(int argc, char *argv[])
{
int result;
int infoOnly = 0;
int writeToStdio = 0;
int readFromStdin = 0;
int object_type = LC;
int def_srate = 0;
int downMatrix = 0;
int format = 1;
int outputFormat = FAAD_FMT_16BIT;
int outfile_set = 0;
int adts_out = 0;
int old_format = 0;
int showHelp = 0;
int mp4file = 0;
int noGapless = 0;
char *fnp;
char aacFileName[255];
char audioFileName[255];
char adtsFileName[255];
unsigned char header[8];
float length = 0;
FILE *hMP4File;
#ifdef _WIN32
long begin;
#else
clock_t begin;
#endif
unsigned long cap = NeAACDecGetCapabilities();
progName = argv[0];
while (1) {
int c = -1;
int option_index = 0;
static struct option long_options[] = {
{ ""quiet"",      0, 0, 'q' },
{ ""outfile"",    0, 0, 'o' },
{ ""adtsout"",    0, 0, 'a' },
{ ""oldformat"",  0, 0, 't' },
{ ""format"",     0, 0, 'f' },
{ ""bits"",       0, 0, 'b' },
{ ""samplerate"", 0, 0, 's' },
{ ""objecttype"", 0, 0, 'l' },
{ ""downmix"",    0, 0, 'd' },
{ ""info"",       0, 0, 'i' },
{ ""stdio"",      0, 0, 'w' },
{ ""stdio"",      0, 0, 'g' },
{ ""help"",       0, 0, 'h' },
{ 0, 0, 0, 0 }
};
c = getopt_long(argc, argv, ""o:a:s:f:b:l:wgdhitq"",
long_options, &option_index);
if (c == -1)
break;
switch (c) {
case 'o':
if (optarg)
{
outfile_set = 1;
strcpy(audioFileName, optarg);
}
break;
case 'a':
if (optarg)
{
adts_out = 1;
strcpy(adtsFileName, optarg);
}
break;
case 's':
if (optarg)
{
char dr[10];
if (sscanf(optarg, ""%s"", dr) < 1) {
def_srate = 0;
} else {
def_srate = atoi(dr);
}
}
break;
case 'f':
if (optarg)
{
char dr[10];
if (sscanf(optarg, ""%s"", dr) < 1)
{
format = 1;
} else {
format = atoi(dr);
if ((format < 1) || (format > 2))
showHelp = 1;
}
}
break;
case 'b':
if (optarg)
{
char dr[10];
if (sscanf(optarg, ""%s"", dr) < 1)
{
outputFormat = FAAD_FMT_16BIT;
} else {
outputFormat = atoi(dr);
if ((outputFormat < 1) || (outputFormat > 5))
showHelp = 1;
}
}
break;
case 'l':
if (optarg)
{
char dr[10];
if (sscanf(optarg, ""%s"", dr) < 1)
{
object_type = LC;
} else {
object_type = atoi(dr);
if ((object_type != LC) &&
(object_type != MAIN) &&
(object_type != LTP) &&
(object_type != LD))
{
showHelp = 1;
}
}
}
break;
case 't':
old_format = 1;
break;
case 'd':
downMatrix = 1;
break;
case 'w':
writeToStdio = 1;
break;
case 'g':
noGapless = 1;
break;
case 'i':
infoOnly = 1;
break;
case 'h':
showHelp = 1;
break;
case 'q':
quiet = 1;
break;
default:
break;
}
}
faad_fprintf(stderr, "" *********** Ahead Software MPEG-4 AAC Decoder V%s ******************\n\n"", FAAD2_VERSION);
faad_fprintf(stderr, "" Build: %s\n"", __DATE__);
faad_fprintf(stderr, "" Copyright 2002-2004: Ahead Software AG\n"");
faad_fprintf(stderr, "" http:www.audiocoding.com\n"");
if (cap & FIXED_POINT_CAP)
faad_fprintf(stderr, "" Fixed point version\n"");
else
faad_fprintf(stderr, "" Floating point version\n"");
faad_fprintf(stderr, ""\n"");
faad_fprintf(stderr, "" This program is free software; you can redistribute it and/or modify\n"");
faad_fprintf(stderr, "" it under the terms of the GNU General Public License.\n"");
faad_fprintf(stderr, ""\n"");
faad_fprintf(stderr, "" **************************************************************************\n\n"");
if (((argc - optind) < 1) || showHelp)
{
usage();
return 1;
}
#if 0
if (writeToStdio == 1)
{
format = 2;
}
#endif
strcpy(aacFileName, argv[optind]);
#ifdef _WIN32
begin = GetTickCount();
#else
begin = clock();
#endif
if(!writeToStdio && !outfile_set)
{
strcpy(audioFileName, aacFileName);
fnp = (char *)strrchr(audioFileName,'.');
if (fnp)
fnp[0] = '\0';
strcat(audioFileName, file_ext[format]);
}
if (0 == strcmp(aacFileName, ""-"")) {
faad_fprintf(stderr, ""Reading from stdin: %s\n"", aacFileName);
readFromStdin = 1;
hMP4File  = stdin;
#ifdef _WIN32
setmode(fileno(stdin), O_BINARY);
#endif
} else {
mp4file = 0;
hMP4File = fopen(aacFileName, ""rb"");
if (!hMP4File)
{
faad_fprintf(stderr, ""Error opening file: %s\n"", aacFileName);
return 1;
}
}
fread(header, 1, 8, hMP4File);
if (! readFromStdin )
fclose(hMP4File);
if (header[4] == 'f' && header[5] == 't' && header[6] == 'y' && header[7] == 'p')
mp4file = 1;
if (mp4file)
{
result = decodeMP4file(aacFileName, audioFileName, adtsFileName, writeToStdio,
outputFormat, format, downMatrix, noGapless, infoOnly, adts_out, &length);
} else {
if (readFromStdin == 1) {
ungetc(header[7],hMP4File);
ungetc(header[6],hMP4File);
ungetc(header[5],hMP4File);
ungetc(header[4],hMP4File);
ungetc(header[3],hMP4File);
ungetc(header[2],hMP4File);
ungetc(header[1],hMP4File);
ungetc(header[0],hMP4File);
}
result = decodeAACfile(aacFileName, audioFileName, adtsFileName, writeToStdio,
def_srate, object_type, outputFormat, format, downMatrix, infoOnly, adts_out,
old_format, &length);
}
if (!result && !infoOnly)
{
#ifdef _WIN32
float dec_length = (float)(GetTickCount()-begin)/1000.0;
SetConsoleTitle(""FAAD"");
#else
float dec_length = (float)(clock() - begin)/(float)CLOCKS_PER_SEC;
#endif
faad_fprintf(stderr, ""Decoding %s took: %5.2f sec. %5.2fx real-time.\n"", aacFileName,
dec_length, length/dec_length);
}
return 0;
}","[19, 20, 21, 60, 67, 177, 185, 231, 242]",Stack-based buffer overflow vulnerability in frontend/main.c in faad2 before 2.2.7.1 allow local attackers to execute arbitrary code via filename and pathname options.,faad2,CVE-2021-26567,CWE-787
8425,4484,"static void* swoole_unserialize_arr(void *buffer, zval *zvalue, uint32_t nNumOfElements, long flag)
{
zend_ulong h, nIndex, max_index = 0;
uint32_t size = cp_zend_hash_check_size(nNumOfElements);
if (!size)
{
return NULL;
}
if (!buffer)
{
php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""illegal unserialize data"");
return NULL;
}
ZVAL_NEW_ARR(zvalue);
zend_array *ht = Z_ARR_P(zvalue);
ht->nTableSize = size;
ht->nNumUsed = nNumOfElements;
ht->nNumOfElements = nNumOfElements;
ht->nNextFreeElement = 0;
#ifdef HASH_FLAG_APPLY_PROTECTION
ht->u.flags = HASH_FLAG_APPLY_PROTECTION;
#endif
ht->nTableMask = -(ht->nTableSize);
ht->pDestructor = ZVAL_PTR_DTOR;
GC_SET_REFCOUNT(ht, 1);
GC_TYPE_INFO(ht) = IS_ARRAY;
HT_SET_DATA_ADDR(ht, emalloc(HT_SIZE(ht)));
ht->u.flags |= HASH_FLAG_INITIALIZED;
int ht_hash_size = HT_HASH_SIZE((ht)->nTableMask);
if (ht_hash_size <= 0)
{
php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""illegal unserialize data"");
return NULL;
}
HT_HASH_RESET(ht);
int idx;
Bucket *p;
for(idx = 0; idx < nNumOfElements; idx++)
{
if (!buffer)
{
php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""illegal array unserialize data"");
return NULL;
}
SBucketType type = *((SBucketType*) buffer);
buffer += sizeof (SBucketType);
p = ht->arData + idx;
if (type.key_type == KEY_TYPE_STRING)
{
size_t key_len;
if (type.key_len == 3)
{
void *str_pool_addr = get_pack_string_len_addr(&buffer, &key_len);
p->key = zend_string_init((char*) str_pool_addr, key_len, 0);
h = zend_inline_hash_func((char*) str_pool_addr, key_len);
p->key->h = p->h = h;
}
else
{
if (type.key_len == 1)
{
key_len = *((zend_uchar*) buffer);
buffer += sizeof (zend_uchar);
}
else if (type.key_len == 2)
{
key_len = *((unsigned short*) buffer);
buffer += sizeof (unsigned short);
}
else
{
key_len = *((size_t*) buffer);
buffer += sizeof (size_t);
}
p->key = zend_string_init((char*) buffer, key_len, 0);
h = zend_inline_hash_func((char*) buffer, key_len);
buffer += key_len;
p->key->h = p->h = h;
}
}
else
{
if (type.key_len == 0)
{
h = p->h = idx;
p->key = NULL;
max_index = p->h + 1;
}
else
{
if (type.key_len == 1)
{
h = *((zend_uchar*) buffer);
buffer += sizeof (zend_uchar);
}
else if (type.key_len == 2)
{
h = *((unsigned short*) buffer);
buffer += sizeof (unsigned short);
}
else
{
h = *((zend_ulong*) buffer);
buffer += sizeof (zend_ulong);
}
p->h = h;
p->key = NULL;
if (h >= max_index)
{
max_index = h + 1;
}
}
}
nIndex = h | ht->nTableMask;
Z_NEXT(p->val) = HT_HASH(ht, nIndex);
HT_HASH(ht, nIndex) = HT_IDX_TO_HASH(idx);
p->val.u1.v.type = type.data_type;
Z_TYPE_FLAGS(p->val) = 0;
if (type.data_type == IS_STRING)
{
size_t data_len;
if (type.data_len == 3)
{
void *str_pool_addr = get_pack_string_len_addr(&buffer, &data_len);
p->val.value.str = zend_string_init((char*) str_pool_addr, data_len, 0);
}
else
{
if (type.data_len == 1)
{
data_len = *((zend_uchar*) buffer);
buffer += sizeof (zend_uchar);
}
else if (type.data_len == 2)
{
data_len = *((unsigned short*) buffer);
buffer += sizeof (unsigned short);
}
else
{
data_len = *((size_t*) buffer);
buffer += sizeof (size_t);
}
p->val.value.str = zend_string_init((char*) buffer, data_len, 0);
buffer += data_len;
}
Z_TYPE_INFO(p->val) = IS_STRING_EX;
}
else if (type.data_type == IS_ARRAY)
{
uint32_t num = 0;
buffer = get_array_real_len(buffer, type.data_len, &num);
buffer = swoole_unserialize_arr(buffer, &p->val, num, flag);
}
else if (type.data_type == IS_LONG)
{
buffer = swoole_unserialize_long(buffer, &p->val, type);
}
else if (type.data_type == IS_DOUBLE)
{
p->val.value = *((zend_value*) buffer);
buffer += sizeof (zend_value);
}
else if (type.data_type == IS_UNDEF)
{
buffer = swoole_unserialize_object(buffer, &p->val, type.data_len, NULL, flag);
Z_TYPE_INFO(p->val) = IS_OBJECT_EX;
}
}
ht->nNextFreeElement = max_index;
return buffer;
}","[5, 75, 144, 171]",The unpack implementation in Swoole version 4.0.4 lacks correct size checks in the deserialization process. An attacker can craft a serialized object to exploit this vulnerability and cause a SEGV.,swoole-src,CVE-2018-15503,CWE-502
8427,9059,"static void gf_dump_vrml_simple_field(GF_SceneDumper *sdump, GF_FieldInfo field, GF_Node *parent)
{
u32 i, sf_type;
GF_ChildNodeItem *list;
void *slot_ptr;
switch (field.fieldType) {
case GF_SG_VRML_SFNODE:
assert ( *(GF_Node **)field.far_ptr);
gf_dump_vrml_node(sdump, *(GF_Node **)field.far_ptr, 0, NULL);
return;
case GF_SG_VRML_MFNODE:
list = * ((GF_ChildNodeItem **) field.far_ptr);
assert( list );
sdump->indent++;
while (list) {
gf_dump_vrml_node(sdump, list->node, 1, NULL);
list = list->next;
}
sdump->indent--;
return;
case GF_SG_VRML_SFCOMMANDBUFFER:
return;
}
if (gf_sg_vrml_is_sf_field(field.fieldType)) {
if (sdump->XMLDump) StartAttribute(sdump, ""value"");
gf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, parent);
if (sdump->XMLDump) EndAttribute(sdump);
} else {
GenMFField *mffield;
mffield = (GenMFField *) field.far_ptr;
sf_type = gf_sg_vrml_get_sf_type(field.fieldType);
if (!sdump->XMLDump) {
gf_fprintf(sdump->trace, ""["");
} else if (sf_type==GF_SG_VRML_SFSTRING) {
gf_fprintf(sdump->trace, "" value=\'"");
} else {
StartAttribute(sdump, ""value"");
}
for (i=0; i<mffield->count; i++) {
if (i) gf_fprintf(sdump->trace, "" "");
gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);
gf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, parent);
}
if (!sdump->XMLDump) {
gf_fprintf(sdump->trace, ""]"");
} else if (sf_type==GF_SG_VRML_SFSTRING) {
gf_fprintf(sdump->trace, ""\'"");
} else {
EndAttribute(sdump);
}
}
}","[8, 9]",Segmentation Fault caused by MP4Box -lsr in GitHub repository gpac/gpac prior to 2.1.0-DEV.,gpac,CVE-2022-1035,CWE-476
8437,4348,"RemoteFsDevice::RemoteFsDevice(MusicLibraryModel *m, const Details &d)
: FsDevice(m, d.name, createUdi(d.name))
, mountToken(0)
, currentMountStatus(false)
, details(d)
, proc(0)
, mounterIface(0)
, messageSent(false)
{
setup();
icn=MonoIcon::icon(details.isLocalFile()
? FontAwesome::foldero
: constSshfsProtocol==details.url.scheme()
? FontAwesome::linux_os
: FontAwesome::windows, Utils::monoIconColor());
}",[7],"An issue was discovered in the cantata-mounter D-Bus service in Cantata through 2.3.1. The mount target path check in mounter.cpp `mpOk()` is insufficient. A regular user can consequently mount a CIFS filesystem anywhere (e.g., outside of the /home directory tree) by passing directory traversal sequences such as a home/../usr substring.",cantata,CVE-2018-12559,CWE-22
8449,8495,"u32 GetHintFormat(GF_TrackBox *trak)
{
GF_HintMediaHeaderBox *hmhd = (GF_HintMediaHeaderBox *)trak->Media->information->InfoHeader;
if (hmhd->type != GF_ISOM_BOX_TYPE_HMHD)
return 0;
if (!hmhd || !hmhd->subType) {
GF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);
if (!hmhd) return a ? a->type : 0;
if (a) hmhd->subType = a->type;
return hmhd->subType;
}
return hmhd->subType;
}",[4],"The binary MP4Box in Gpac 1.0.1 has a null pointer dereference vulnerability in the gf_isom_get_payt_count function in hint_track.c, which allows attackers to cause a denial of service.",gpac,CVE-2021-40576,CWE-476
8460,7965,"static s32 gf_media_vvc_read_vps_bs_internal(GF_BitStream *bs, VVCState *vvc, Bool stop_at_vps_ext)
{
u32 i, j;
s32 vps_id;
VVC_VPS *vps;
Bool vps_default_ptl_dpb_hrd_max_tid_flag=0;
vps_id = gf_bs_read_int_log(bs, 4, ""vps_id"");
if (vps_id >= 16) return -1;
if (!vps_id) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[VVC] VPS ID 0 is forbidden\n""));
return -1;
}
vps = &vvc->vps[vps_id];
if (!vps->state) {
vps->id = vps_id;
vps->state = 1;
}
vps->max_layers = 1 + gf_bs_read_int_log(bs, 6, ""max_layers"");
if (vps->max_layers > MAX_LHVC_LAYERS) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[VVC] sorry, %d layers in VPS but only %d supported\n"", vps->max_layers, MAX_LHVC_LAYERS));
return -1;
}
vps->max_sub_layers = gf_bs_read_int_log(bs, 3, ""max_sub_layers_minus1"") + 1;
if ((vps->max_layers>1) && (vps->max_sub_layers>1))
vps_default_ptl_dpb_hrd_max_tid_flag = gf_bs_read_int_log(bs, 1, ""vps_default_ptl_dpb_hrd_max_tid_flag"");
if (vps->max_layers>1)
vps->all_layers_independent = gf_bs_read_int_log(bs, 1, ""all_layers_independent"");
for (i=0; i<vps->max_layers; i++) {
u32 layer_id = gf_bs_read_int_log_idx(bs, 6, ""layer_id"", i);
if (layer_id>vps->max_layer_id) vps->max_layer_id = layer_id;
if (i && !vps->all_layers_independent) {
Bool layer_indep = gf_bs_read_int_log_idx(bs, 1, ""layer_independent"", i);
if (!layer_indep) {
Bool vps_max_tid_ref_present_flag = gf_bs_read_int_log_idx(bs, 1, ""vps_max_tid_ref_present_flag"", i);
for (j=0; j<i; j++) {
Bool vps_direct_ref_layer_flag = gf_bs_read_int_log_idx2(bs, 1, ""vps_direct_ref_layer_flag"", i, j);
if (vps_max_tid_ref_present_flag && vps_direct_ref_layer_flag) {
gf_bs_read_int_log_idx2(bs, 3, ""vps_max_tid_il_ref_pics_plus1"", i, j);
}
}
}
}
}
vps->num_ptl = 1;
if (vps->max_layers > 1) {
if (vps->all_layers_independent) {
vps->each_layer_is_ols = gf_bs_read_int_log(bs, 1, ""each_layer_is_ols"");
}
if (!vps->each_layer_is_ols) {
u32 vps_ols_mode_idc = 2;
if (!vps->all_layers_independent) {
vps_ols_mode_idc = gf_bs_read_int_log(bs, 2, ""vps_ols_mode_idc"");
}
if (vps_ols_mode_idc==2) {
u8 vps_num_output_layer_sets = 2 + gf_bs_read_int_log(bs, 8, ""vps_num_output_layer_sets_minus2"");
for (i=0; i<vps_num_output_layer_sets; i++) {
for (j=0; j<vps->max_layers; j++) {
gf_bs_read_int_log_idx2(bs, 1, ""vps_ols_output_layer_flag"", i, j);
}
}
}
}
vps->num_ptl = 1 + gf_bs_read_int_log(bs, 8, ""num_ptl_minus1"");
}
vps->ptl[0].pt_present = 1;
for (i=0; i<vps->num_ptl; i++) {
if (i)
vps->ptl[i].pt_present = gf_bs_read_int_log_idx(bs, 1, ""pt_present"", i);
if (!vps_default_ptl_dpb_hrd_max_tid_flag)
vps->ptl[i].ptl_max_tid = gf_bs_read_int_log_idx(bs, 3, ""ptl_max_tid"", i);
else
vps->ptl[i].ptl_max_tid = vps->max_sub_layers - 1;;
}
gf_bs_align(bs);
for (i=0; i<vps->num_ptl; i++) {
vvc_profile_tier_level(bs, &vps->ptl[i], i);
}
return vps_id;
}",[8],There is a integer overflow in media_tools/av_parsers.c in the hevc_parse_slice_segment function in GPAC 1.0.1 which results in a crash.,gpac,CVE-2021-30014,CWE-190
8469,7961,"s32 hevc_parse_slice_segment(GF_BitStream *bs, HEVCState *hevc, HEVCSliceInfo *si)
{
u32 i, j;
u32 num_ref_idx_l0_active = 0, num_ref_idx_l1_active = 0;
HEVC_PPS *pps;
HEVC_SPS *sps;
s32 pps_id;
Bool RapPicFlag = GF_FALSE;
Bool IDRPicFlag = GF_FALSE;
si->first_slice_segment_in_pic_flag = gf_bs_read_int_log(bs, 1, ""first_slice_segment_in_pic_flag"");
switch (si->nal_unit_type) {
case GF_HEVC_NALU_SLICE_IDR_W_DLP:
case GF_HEVC_NALU_SLICE_IDR_N_LP:
IDRPicFlag = GF_TRUE;
RapPicFlag = GF_TRUE;
break;
case GF_HEVC_NALU_SLICE_BLA_W_LP:
case GF_HEVC_NALU_SLICE_BLA_W_DLP:
case GF_HEVC_NALU_SLICE_BLA_N_LP:
case GF_HEVC_NALU_SLICE_CRA:
RapPicFlag = GF_TRUE;
break;
}
if (RapPicFlag) {
gf_bs_read_int_log(bs, 1, ""no_output_of_prior_pics_flag"");
}
pps_id = gf_bs_read_ue_log(bs, ""pps_id"");
if (pps_id >= 64)
return -1;
pps = &hevc->pps[pps_id];
sps = &hevc->sps[pps->sps_id];
si->sps = sps;
si->pps = pps;
if (!si->first_slice_segment_in_pic_flag && pps->dependent_slice_segments_enabled_flag) {
si->dependent_slice_segment_flag = gf_bs_read_int_log(bs, 1, ""dependent_slice_segment_flag"");
}
else {
si->dependent_slice_segment_flag = GF_FALSE;
}
if (!si->first_slice_segment_in_pic_flag) {
si->slice_segment_address = gf_bs_read_int_log(bs, sps->bitsSliceSegmentAddress, ""slice_segment_address"");
}
else {
si->slice_segment_address = 0;
}
if (!si->dependent_slice_segment_flag) {
Bool deblocking_filter_override_flag = 0;
Bool slice_temporal_mvp_enabled_flag = 0;
Bool slice_sao_luma_flag = 0;
Bool slice_sao_chroma_flag = 0;
Bool slice_deblocking_filter_disabled_flag = 0;
gf_bs_read_int_log(bs, pps->num_extra_slice_header_bits, ""slice_reserved_undetermined_flag"");
si->slice_type = gf_bs_read_ue_log(bs, ""slice_type"");
if (pps->output_flag_present_flag)
gf_bs_read_int_log(bs, 1, ""pic_output_flag"");
if (sps->separate_colour_plane_flag == 1)
gf_bs_read_int_log(bs, 2, ""colour_plane_id"");
if (IDRPicFlag) {
si->poc_lsb = 0;
if (!hevc->full_slice_header_parse) return 0;
}
else {
si->poc_lsb = gf_bs_read_int_log(bs, sps->log2_max_pic_order_cnt_lsb, ""poc_lsb"");
if (!hevc->full_slice_header_parse) return 0;
if (gf_bs_read_int_log(bs, 1, ""short_term_ref_pic_set_sps_flag"") == 0) {
Bool ret = hevc_parse_short_term_ref_pic_set(bs, sps, sps->num_short_term_ref_pic_sets);
if (!ret)
return -1;
}
else if (sps->num_short_term_ref_pic_sets > 1) {
u32 numbits = 0;
while ((u32)(1 << numbits) < sps->num_short_term_ref_pic_sets)
numbits++;
if (numbits > 0)
gf_bs_read_int_log(bs, numbits, ""short_term_ref_pic_set_idx"");
}
if (sps->long_term_ref_pics_present_flag) {
u8 DeltaPocMsbCycleLt[32];
u32 num_long_term_sps = 0;
u32 num_long_term_pics = 0;
memset(DeltaPocMsbCycleLt, 0, sizeof(u8) * 32);
if (sps->num_long_term_ref_pic_sps > 0) {
num_long_term_sps = gf_bs_read_ue_log(bs, ""num_long_term_sps"");
}
num_long_term_pics = gf_bs_read_ue_log(bs, ""num_long_term_pics"");
for (i = 0; i < num_long_term_sps + num_long_term_pics; i++) {
if (i < num_long_term_sps) {
if (sps->num_long_term_ref_pic_sps > 1)
gf_bs_read_int_log_idx(bs, gf_get_bit_size(sps->num_long_term_ref_pic_sps), ""lt_idx_sps"", i);
}
else {
gf_bs_read_int_log_idx(bs, sps->log2_max_pic_order_cnt_lsb, ""PocLsbLt"", i);
gf_bs_read_int_log_idx(bs, 1, ""UsedByCurrPicLt"", i);
}
if (gf_bs_read_int_log_idx(bs, 1, ""delta_poc_msb_present_flag"", i)) {
if (i == 0 || i == num_long_term_sps)
DeltaPocMsbCycleLt[i] = gf_bs_read_ue_log_idx(bs, ""DeltaPocMsbCycleLt"", i);
else
DeltaPocMsbCycleLt[i] = gf_bs_read_ue_log_idx(bs, ""DeltaPocMsbCycleLt"", i) + DeltaPocMsbCycleLt[i - 1];
}
}
}
if (sps->temporal_mvp_enable_flag)
slice_temporal_mvp_enabled_flag = gf_bs_read_int_log(bs, 1, ""slice_temporal_mvp_enabled_flag"");
}
if (sps->sample_adaptive_offset_enabled_flag) {
u32 ChromaArrayType = sps->separate_colour_plane_flag ? 0 : sps->chroma_format_idc;
slice_sao_luma_flag = gf_bs_read_int_log(bs, 1, ""slice_sao_luma_flag"");
if (ChromaArrayType != 0)
slice_sao_chroma_flag = gf_bs_read_int_log(bs, 1, ""slice_sao_chroma_flag"");
}
if (si->slice_type == GF_HEVC_SLICE_TYPE_P || si->slice_type == GF_HEVC_SLICE_TYPE_B) {
num_ref_idx_l0_active = pps->num_ref_idx_l0_default_active;
num_ref_idx_l1_active = 0;
if (si->slice_type == GF_HEVC_SLICE_TYPE_B)
num_ref_idx_l1_active = pps->num_ref_idx_l1_default_active;
if (gf_bs_read_int_log(bs, 1, ""num_ref_idx_active_override_flag"")) {
num_ref_idx_l0_active = 1 + gf_bs_read_ue_log(bs, ""num_ref_idx_l0_active"");
if (si->slice_type == GF_HEVC_SLICE_TYPE_B)
num_ref_idx_l1_active = 1 + gf_bs_read_ue_log(bs, ""num_ref_idx_l1_active"");
}
if (pps->lists_modification_present_flag                                 ) {
if (!ref_pic_lists_modification(bs, si->slice_type, num_ref_idx_l0_active, num_ref_idx_l1_active)) {
GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (""[hevc] ref_pic_lists_modification( ) not implemented\n""));
return -1;
}
}
if (si->slice_type == GF_HEVC_SLICE_TYPE_B)
gf_bs_read_int_log(bs, 1, ""mvd_l1_zero_flag"");
if (pps->cabac_init_present_flag)
gf_bs_read_int_log(bs, 1, ""cabac_init_flag"");
if (slice_temporal_mvp_enabled_flag) {
Bool collocated_from_l0_flag = 1;
if (si->slice_type == GF_HEVC_SLICE_TYPE_B)
collocated_from_l0_flag = gf_bs_read_int_log(bs, 1, ""collocated_from_l0_flag"");
if ((collocated_from_l0_flag && (num_ref_idx_l0_active > 1))
|| (!collocated_from_l0_flag && (num_ref_idx_l1_active > 1))
) {
gf_bs_read_ue_log(bs, ""collocated_ref_idx"");
}
}
if ((pps->weighted_pred_flag && si->slice_type == GF_HEVC_SLICE_TYPE_P)
|| (pps->weighted_bipred_flag && si->slice_type == GF_HEVC_SLICE_TYPE_B)
) {
hevc_pred_weight_table(bs, hevc, si, pps, sps, num_ref_idx_l0_active, num_ref_idx_l1_active);
}
gf_bs_read_ue_log(bs, ""five_minus_max_num_merge_cand"");
}
si->slice_qp_delta_start_bits = (s32) (gf_bs_get_position(bs) - 1) * 8 + gf_bs_get_bit_position(bs);
si->slice_qp_delta = gf_bs_read_se_log(bs, ""slice_qp_delta"");
if (pps->slice_chroma_qp_offsets_present_flag) {
gf_bs_read_se_log(bs, ""slice_cb_qp_offset"");
gf_bs_read_se_log(bs, ""slice_cr_qp_offset"");
}
if (pps->deblocking_filter_override_enabled_flag) {
deblocking_filter_override_flag = gf_bs_read_int_log(bs, 1, ""deblocking_filter_override_flag"");
}
if (deblocking_filter_override_flag) {
slice_deblocking_filter_disabled_flag = gf_bs_read_int_log(bs, 1, ""slice_deblocking_filter_disabled_flag"");
if (!slice_deblocking_filter_disabled_flag) {
gf_bs_read_se_log(bs, ""slice_beta_offset_div2"");
gf_bs_read_se_log(bs, ""slice_tc_offset_div2"");
}
}
if (pps->loop_filter_across_slices_enabled_flag
&& (slice_sao_luma_flag || slice_sao_chroma_flag || !slice_deblocking_filter_disabled_flag)
) {
gf_bs_read_int_log(bs, 1, ""slice_loop_filter_across_slices_enabled_flag"");
}
}
else {
if (!hevc->full_slice_header_parse) return 0;
}
si->entry_point_start_bits = ((u32)gf_bs_get_position(bs) - 1) * 8 + gf_bs_get_bit_position(bs);
if (pps->tiles_enabled_flag || pps->entropy_coding_sync_enabled_flag) {
u32 num_entry_point_offsets = gf_bs_read_ue_log(bs, ""num_entry_point_offsets"");
if (num_entry_point_offsets > 0) {
u32 offset = gf_bs_read_ue_log(bs, ""offset"") + 1;
u32 segments = offset >> 4;
s32 remain = (offset & 15);
for (i = 0; i < num_entry_point_offsets; i++) {
for (j = 0; j < segments; j++) {
gf_bs_read_int(bs, 16);
}
if (remain) {
gf_bs_read_int(bs, remain);
}
}
}
}
if (pps->slice_segment_header_extension_present_flag) {
u32 size_ext = gf_bs_read_ue_log(bs, ""size_ext"");
while (size_ext) {
gf_bs_read_int(bs, 8);
size_ext--;
}
}
si->header_size_bits = (gf_bs_get_position(bs) - 1) * 8 + gf_bs_get_bit_position(bs);
if (gf_bs_read_int_log(bs, 1, ""byte_align"") == 0) {
GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (""Error parsing slice header: byte_align not found at end of header !\n""));
}
gf_bs_align(bs);
si->payload_start_offset = (s32)gf_bs_get_position(bs);
return 0;
}",[28],There is a integer overflow in media_tools/av_parsers.c in the hevc_parse_slice_segment function in GPAC 1.0.1 which results in a crash.,gpac,CVE-2021-30014,CWE-190
8473,7798,"void ServerFeature::collectOptions(std::shared_ptr<ProgramOptions> options) {
options->addOption(""--console"", ""start a JavaScript emergency console"",
new BooleanParameter(&_console));
options->addSection(""server"", ""server features"");
options->addOption(""--server.rest-server"", ""start a rest-server"",
new BooleanParameter(&_restServer),
arangodb::options::makeDefaultFlags(arangodb::options::Flags::Hidden));
options->addOption(""--server.validate-utf8-strings"", ""perform UTF-8 string validation for incoming JSON and VelocyPack data"",
new BooleanParameter(&_validateUtf8Strings),
arangodb::options::makeDefaultFlags(arangodb::options::Flags::Hidden)).setIntroducedIn(30700);
options->addOption(""--javascript.script"", ""run scripts and exit"",
new VectorParameter<StringParameter>(&_scripts));
#if _WIN32
options->addOption(""--console.code-page"",
""Windows code page to use; defaults to UTF8"",
new UInt16Parameter(&_codePage),
arangodb::options::makeDefaultFlags(arangodb::options::Flags::Hidden));
#endif
options->addSection(""vst"", ""VelocyStream protocol"", """", true, true);
options->addObsoleteOption(""--vst.maxsize"", ""maximal size (in bytes) ""
""for a VelocyPack chunk"", true);
options->addObsoleteOption(
""--server.session-timeout"",
""timeout of web interface server sessions (in seconds)"", true);
options->addSection(""wal"", ""WAL of the MMFiles engine"", """", true, true);
options->addObsoleteOption(""--wal.allow-oversize-entries"",
""allow entries that are bigger than '--wal.logfile-size'"", false);
options->addObsoleteOption(""--wal.use-mlock"",
""mlock WAL logfiles in memory (may require elevated privileges or limits)"", false);
options->addObsoleteOption(""--wal.directory"", ""logfile directory"", true);
options->addObsoleteOption(""--wal.historic-logfiles"", ""maximum number of historic logfiles to keep after collection"", true);
options->addObsoleteOption(""--wal.ignore-logfile-errors"",
""ignore logfile errors. this will read recoverable data from corrupted logfiles but ignore any unrecoverable data"", false);
options->addObsoleteOption(""--wal.ignore-recovery-errors"", ""continue recovery even if re-applying operations fails"", false);
options->addObsoleteOption(""--wal.flush-timeout"", ""flush timeout (in milliseconds)"", true);
options->addObsoleteOption(""--wal.logfile-size"", ""size of each logfile (in bytes)"", true);
options->addObsoleteOption(""--wal.open-logfiles"", ""maximum number of parallel open logfiles"", true);
options->addObsoleteOption(""--wal.reserve-logfiles"", ""maximum number of reserve logfiles to maintain"", true);
options->addObsoleteOption(""--wal.slots"", ""number of logfile slots to use"", true);
options->addObsoleteOption(""--wal.sync-interval"", ""interval for automatic, non-requested disk syncs (in milliseconds)"", true);
options->addObsoleteOption(""--wal.throttle-when-pending"",
""throttle writes when at least this many operations are waiting for collection (set to 0 to deactivate write-throttling)"", true);
options->addObsoleteOption(""--wal.throttle-wait"", ""maximum wait time per operation when write-throttled (in milliseconds)"", true);
}","[22, 23, 24]","In ArangoDB, versions v3.7.6 through v3.8.3 are vulnerable to Insufficient Session Expiration. When a user&#8217;s password is changed by the administrator, the session isn&#8217;t invalidated, allowing a malicious user to still be logged in and perform arbitrary actions within the system.",arangodb,CVE-2021-25940,CWE-613
8474,8005,"GF_Err HintFile(GF_ISOFile *file, u32 MTUSize, u32 max_ptime, u32 rtp_rate, u32 base_flags, Bool copy_data, Bool interleave, Bool regular_iod, Bool single_group, Bool hint_no_offset)
{
GF_ESD *esd;
GF_InitialObjectDescriptor *iod;
u32 i, val, res, streamType;
u32 sl_mode, prev_ocr, single_ocr, nb_done, tot_bw, bw, flags, spec_type;
GF_Err e;
char szPayload[30];
GF_RTPHinter *hinter;
Bool copy, has_iod, single_av;
u8 init_payt = BASE_PAYT;
u32 mtype;
GF_SDP_IODProfile iod_mode = GF_SDP_IOD_NONE;
u32 media_group = 0;
u8 media_prio = 0;
tot_bw = 0;
prev_ocr = 0;
single_ocr = 1;
has_iod = 1;
iod = (GF_InitialObjectDescriptor *) gf_isom_get_root_od(file);
if (!iod) has_iod = 0;
else {
if (!gf_list_count(iod->ESDescriptors)) has_iod = 0;
gf_odf_desc_del((GF_Descriptor *) iod);
}
spec_type = gf_isom_guess_specification(file);
single_av = single_group ? 1 : gf_isom_is_single_av(file);
for (i=0; i<gf_isom_get_track_count(file); i++) {
res = gf_isom_get_media_type(file, i+1);
if ((res==GF_ISOM_MEDIA_SCENE) || (res==GF_ISOM_MEDIA_OD)) {
if (gf_isom_is_track_in_root_od(file, i+1)) {
gf_isom_set_default_sync_track(file, i+1);
break;
}
}
}
nb_done = 0;
for (i=0; i<gf_isom_get_track_count(file); i++) {
sl_mode = base_flags;
copy = copy_data;
if (!gf_isom_get_sample_count(file, i+1)) continue;
if (!gf_isom_is_track_enabled(file, i+1)) {
M4_LOG(GF_LOG_INFO, (""Track ID %d disabled - skipping hint\n"", gf_isom_get_track_id(file, i+1) ));
continue;
}
mtype = gf_isom_get_media_type(file, i+1);
switch (mtype) {
case GF_ISOM_MEDIA_VISUAL:
if (single_av) {
media_group = 2;
media_prio = 2;
}
break;
case GF_ISOM_MEDIA_AUXV:
if (single_av) {
media_group = 2;
media_prio = 3;
}
break;
case GF_ISOM_MEDIA_PICT:
if (single_av) {
media_group = 2;
media_prio = 4;
}
break;
case GF_ISOM_MEDIA_AUDIO:
if (single_av) {
media_group = 2;
media_prio = 1;
}
break;
case GF_ISOM_MEDIA_HINT:
continue;
default:
if (spec_type==GF_ISOM_BRAND_ISMA) continue;
}
mtype = gf_isom_get_media_subtype(file, i+1, 1);
if ((mtype==GF_ISOM_SUBTYPE_MPEG4) || (mtype==GF_ISOM_SUBTYPE_MPEG4_CRYP) ) mtype = gf_isom_get_mpeg4_subtype(file, i+1, 1);
if (!single_av) {
media_group ++;
media_prio = 1;
}
streamType = 0;
esd = gf_isom_get_esd(file, i+1, 1);
if (esd) {
streamType = esd->decoderConfig->streamType;
if (!prev_ocr) {
prev_ocr = esd->OCRESID;
if (!esd->OCRESID) prev_ocr = esd->ESID;
} else if (esd->OCRESID && prev_ocr != esd->OCRESID) {
single_ocr = 0;
}
if (streamType==1) copy = 1;
}
gf_odf_desc_del((GF_Descriptor *) esd);
if (!regular_iod && gf_isom_is_track_in_root_od(file, i+1)) {
if (gf_isom_get_sample_count(file, i+1)==1) {
GF_ISOSample *samp = gf_isom_get_sample(file, i+1, 1, &val);
if (streamType) {
res = gf_hinter_can_embbed_data(samp->data, samp->dataLength, streamType);
} else {
res = 0;
}
if (samp) gf_isom_sample_del(&samp);
if (res) continue;
}
}
if (interleave) sl_mode |= GP_RTP_PCK_USE_INTERLEAVING;
hinter = gf_hinter_track_new(file, i+1, MTUSize, max_ptime, rtp_rate, sl_mode, init_payt, copy, media_group, media_prio, &e);
if (!hinter) {
if (e) {
M4_LOG(nb_done ? GF_LOG_WARNING : GF_LOG_ERROR, (""Cannot create hinter (%s)\n"", gf_error_to_string(e) ));
if (!nb_done) return e;
}
continue;
}
if (hint_no_offset)
gf_hinter_track_force_no_offsets(hinter);
bw = gf_hinter_track_get_bandwidth(hinter);
tot_bw += bw;
flags = gf_hinter_track_get_flags(hinter);
gf_isom_set_nalu_extract_mode(file, i+1, GF_ISOM_NALU_EXTRACT_LAYER_ONLY);
gf_hinter_track_get_payload_name(hinter, szPayload);
M4_LOG(GF_LOG_INFO, (""Hinting track ID %d - Type \""%s:%s\"" (%s) - BW %d kbps\n"", gf_isom_get_track_id(file, i+1), gf_4cc_to_str(mtype), gf_4cc_to_str(mtype), szPayload, bw));
if (flags & GP_RTP_PCK_SYSTEMS_CAROUSEL) M4_LOG(GF_LOG_INFO, (""\tMPEG-4 Systems stream carousel enabled\n""));
e = gf_hinter_track_process(hinter);
if (!e) e = gf_hinter_track_finalize(hinter, has_iod);
gf_hinter_track_del(hinter);
if (e) {
M4_LOG(GF_LOG_ERROR, (""Error while hinting (%s)\n"", gf_error_to_string(e)));
if (!nb_done) return e;
}
init_payt++;
nb_done ++;
}
if (has_iod) {
iod_mode = GF_SDP_IOD_ISMA;
if (regular_iod) iod_mode = GF_SDP_IOD_REGULAR;
} else {
iod_mode = GF_SDP_IOD_NONE;
}
gf_hinter_finalize(file, iod_mode, tot_bw);
if (!single_ocr)
M4_LOG(GF_LOG_WARNING, (""Warning: at least 2 timelines found in the file\nThis may not be supported by servers/players\n\n""));
return GF_OK;
}",[85],The HintFile function in GPAC 1.0.1 allows attackers to cause a denial of service (NULL pointer dereference) via a crafted file in the MP4Box command.,gpac,CVE-2021-31257,CWE-476
8484,6300,"int secure_check(void *data)
{
const at91_secure_header_t *header;
void *file;
if (secure_decrypt(data, sizeof(*header), 0))
return -1;
header = (const at91_secure_header_t *)data;
if (header->magic != AT91_SECURE_MAGIC)
return -1;
file = (unsigned char *)data + sizeof(*header);
return secure_decrypt(file, header->file_size, 1);
}","[5, 6, 9, 11]",AT91bootstrap before 3.9.2 does not properly wipe encryption and authentication keys from memory before passing control to a less privileged software component. This can be exploited to disclose these keys and subsequently encrypt and sign the next boot stage (such as the bootloader).,at91bootstrap,CVE-2020-11684,CWE-326
8485,4099,"fetch_token(OnigToken* tok, UChar** src, UChar* end, ScanEnv* env)
{
int r, num;
OnigCodePoint c;
OnigEncoding enc = env->enc;
OnigSyntaxType* syn = env->syntax;
UChar* prev;
UChar* p = *src;
PFETCH_READY;
start:
if (PEND) {
tok->type = TK_EOT;
return tok->type;
}
tok->type  = TK_STRING;
tok->base  = 0;
tok->backp = p;
PFETCH(c);
if (IS_MC_ESC_CODE(c, syn)) {
if (PEND) return ONIGERR_END_PATTERN_AT_ESCAPE;
tok->backp = p;
PFETCH(c);
tok->u.c = c;
tok->escaped = 1;
switch (c) {
case '*':
if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_ASTERISK_ZERO_INF)) break;
tok->type = TK_OP_REPEAT;
tok->u.repeat.lower = 0;
tok->u.repeat.upper = REPEAT_INFINITE;
goto greedy_check;
break;
case '+':
if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_PLUS_ONE_INF)) break;
tok->type = TK_OP_REPEAT;
tok->u.repeat.lower = 1;
tok->u.repeat.upper = REPEAT_INFINITE;
goto greedy_check;
break;
case '?':
if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_QMARK_ZERO_ONE)) break;
tok->type = TK_OP_REPEAT;
tok->u.repeat.lower = 0;
tok->u.repeat.upper = 1;
greedy_check:
if (!PEND && PPEEK_IS('?') &&
IS_SYNTAX_OP(syn, ONIG_SYN_OP_QMARK_NON_GREEDY)) {
PFETCH(c);
tok->u.repeat.greedy     = 0;
tok->u.repeat.possessive = 0;
}
else {
possessive_check:
if (!PEND && PPEEK_IS('+') &&
((IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_PLUS_POSSESSIVE_REPEAT) &&
tok->type != TK_INTERVAL)  ||
(IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_PLUS_POSSESSIVE_INTERVAL) &&
tok->type == TK_INTERVAL))) {
PFETCH(c);
tok->u.repeat.greedy     = 1;
tok->u.repeat.possessive = 1;
}
else {
tok->u.repeat.greedy     = 1;
tok->u.repeat.possessive = 0;
}
}
break;
case '{':
if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_BRACE_INTERVAL)) break;
r = fetch_range_quantifier(&p, end, tok, env);
if (r < 0) return r;
if (r == 0) goto greedy_check;
else if (r == 2) {
if (IS_SYNTAX_BV(syn, ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY))
goto possessive_check;
goto greedy_check;
}
break;
case '|':
if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_VBAR_ALT)) break;
tok->type = TK_ALT;
break;
case '(':
if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LPAREN_SUBEXP)) break;
tok->type = TK_SUBEXP_OPEN;
break;
case ')':
if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LPAREN_SUBEXP)) break;
tok->type = TK_SUBEXP_CLOSE;
break;
case 'w':
if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_W_WORD)) break;
tok->type = TK_CHAR_TYPE;
tok->u.prop.ctype = ONIGENC_CTYPE_WORD;
tok->u.prop.not   = 0;
break;
case 'W':
if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_W_WORD)) break;
tok->type = TK_CHAR_TYPE;
tok->u.prop.ctype = ONIGENC_CTYPE_WORD;
tok->u.prop.not   = 1;
break;
case 'b':
if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_B_WORD_BOUND)) break;
tok->type = TK_ANCHOR;
tok->u.anchor = ANCHOR_WORD_BOUND;
break;
case 'B':
if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_B_WORD_BOUND)) break;
tok->type = TK_ANCHOR;
tok->u.anchor = ANCHOR_NOT_WORD_BOUND;
break;
#ifdef USE_WORD_BEGIN_END
case '<':
if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END)) break;
tok->type = TK_ANCHOR;
tok->u.anchor = ANCHOR_WORD_BEGIN;
break;
case '>':
if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END)) break;
tok->type = TK_ANCHOR;
tok->u.anchor = ANCHOR_WORD_END;
break;
#endif
case 's':
if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_S_WHITE_SPACE)) break;
tok->type = TK_CHAR_TYPE;
tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;
tok->u.prop.not   = 0;
break;
case 'S':
if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_S_WHITE_SPACE)) break;
tok->type = TK_CHAR_TYPE;
tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;
tok->u.prop.not   = 1;
break;
case 'd':
if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_D_DIGIT)) break;
tok->type = TK_CHAR_TYPE;
tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;
tok->u.prop.not   = 0;
break;
case 'D':
if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_D_DIGIT)) break;
tok->type = TK_CHAR_TYPE;
tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;
tok->u.prop.not   = 1;
break;
case 'h':
if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;
tok->type = TK_CHAR_TYPE;
tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;
tok->u.prop.not   = 0;
break;
case 'H':
if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;
tok->type = TK_CHAR_TYPE;
tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;
tok->u.prop.not   = 1;
break;
case 'A':
if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR)) break;
begin_buf:
tok->type = TK_ANCHOR;
tok->u.subtype = ANCHOR_BEGIN_BUF;
break;
case 'Z':
if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR)) break;
tok->type = TK_ANCHOR;
tok->u.subtype = ANCHOR_SEMI_END_BUF;
break;
case 'z':
if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR)) break;
end_buf:
tok->type = TK_ANCHOR;
tok->u.subtype = ANCHOR_END_BUF;
break;
case 'G':
if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_CAPITAL_G_BEGIN_ANCHOR)) break;
tok->type = TK_ANCHOR;
tok->u.subtype = ANCHOR_BEGIN_POSITION;
break;
case '`':
if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR)) break;
goto begin_buf;
break;
case '\'':
if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR)) break;
goto end_buf;
break;
case 'x':
if (PEND) break;
prev = p;
if (PPEEK_IS('{') && IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_BRACE_HEX8)) {
PINC;
num = scan_unsigned_hexadecimal_number(&p, end, 8, enc);
if (num < 0) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;
if (!PEND) {
if (ONIGENC_IS_CODE_XDIGIT(enc, PPEEK))
return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE;
}
if ((p > prev + enclen(enc, prev)) && !PEND && PPEEK_IS('}')) {
PINC;
tok->type   = TK_CODE_POINT;
tok->u.code = (OnigCodePoint )num;
}
else {
p = prev;
}
}
else if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_HEX2)) {
num = scan_unsigned_hexadecimal_number(&p, end, 2, enc);
if (num < 0) return ONIGERR_TOO_BIG_NUMBER;
if (p == prev) {
num = 0;
}
tok->type = TK_RAW_BYTE;
tok->base = 16;
tok->u.c  = num;
}
break;
case 'u':
if (PEND) break;
prev = p;
if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_U_HEX4)) {
num = scan_unsigned_hexadecimal_number(&p, end, 4, enc);
if (num < 0) return ONIGERR_TOO_BIG_NUMBER;
if (p == prev) {
num = 0;
}
tok->type   = TK_CODE_POINT;
tok->base   = 16;
tok->u.code = (OnigCodePoint )num;
}
break;
case '1': case '2': case '3': case '4':
case '5': case '6': case '7': case '8': case '9':
PUNFETCH;
prev = p;
num = onig_scan_unsigned_number(&p, end, enc);
if (num < 0 || num > ONIG_MAX_BACKREF_NUM) {
goto skip_backref;
}
if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_DECIMAL_BACKREF) &&
(num <= env->num_mem || num <= 9)) {
if (IS_SYNTAX_BV(syn, ONIG_SYN_STRICT_CHECK_BACKREF)) {
if (num > env->num_mem || IS_NULL(SCANENV_MEM_NODES(env)[num]))
return ONIGERR_INVALID_BACKREF;
}
tok->type = TK_BACKREF;
tok->u.backref.num     = 1;
tok->u.backref.ref1    = num;
tok->u.backref.by_name = 0;
#ifdef USE_BACKREF_WITH_LEVEL
tok->u.backref.exist_level = 0;
#endif
break;
}
skip_backref:
if (c == '8' || c == '9') {
p = prev; PINC;
break;
}
p = prev;
case '0':
if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_OCTAL3)) {
prev = p;
num = scan_unsigned_octal_number(&p, end, (c == '0' ? 2:3), enc);
if (num < 0) return ONIGERR_TOO_BIG_NUMBER;
if (p == prev) {
num = 0;
}
tok->type = TK_RAW_BYTE;
tok->base = 8;
tok->u.c  = num;
}
else if (c != '0') {
PINC;
}
break;
#ifdef USE_NAMED_GROUP
case 'k':
if (!PEND && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_K_NAMED_BACKREF)) {
PFETCH(c);
if (c == '<' || c == '\'') {
UChar* name_end;
int* backs;
int back_num;
prev = p;
#ifdef USE_BACKREF_WITH_LEVEL
name_end = NULL_UCHARP;
r = fetch_name_with_level((OnigCodePoint )c, &p, end, &name_end,
env, &back_num, &tok->u.backref.level);
if (r == 1) tok->u.backref.exist_level = 1;
else        tok->u.backref.exist_level = 0;
#else
r = fetch_name(&p, end, &name_end, env, &back_num, 1);
#endif
if (r < 0) return r;
if (back_num != 0) {
if (back_num < 0) {
back_num = BACKREF_REL_TO_ABS(back_num, env);
if (back_num <= 0)
return ONIGERR_INVALID_BACKREF;
}
if (IS_SYNTAX_BV(syn, ONIG_SYN_STRICT_CHECK_BACKREF)) {
if (back_num > env->num_mem ||
IS_NULL(SCANENV_MEM_NODES(env)[back_num]))
return ONIGERR_INVALID_BACKREF;
}
tok->type = TK_BACKREF;
tok->u.backref.by_name = 0;
tok->u.backref.num  = 1;
tok->u.backref.ref1 = back_num;
}
else {
num = onig_name_to_group_numbers(env->reg, prev, name_end, &backs);
if (num <= 0) {
onig_scan_env_set_error_string(env,
ONIGERR_UNDEFINED_NAME_REFERENCE, prev, name_end);
return ONIGERR_UNDEFINED_NAME_REFERENCE;
}
if (IS_SYNTAX_BV(syn, ONIG_SYN_STRICT_CHECK_BACKREF)) {
int i;
for (i = 0; i < num; i++) {
if (backs[i] > env->num_mem ||
IS_NULL(SCANENV_MEM_NODES(env)[backs[i]]))
return ONIGERR_INVALID_BACKREF;
}
}
tok->type = TK_BACKREF;
tok->u.backref.by_name = 1;
if (num == 1) {
tok->u.backref.num  = 1;
tok->u.backref.ref1 = backs[0];
}
else {
tok->u.backref.num  = num;
tok->u.backref.refs = backs;
}
}
}
else
PUNFETCH;
}
break;
#endif
#ifdef USE_SUBEXP_CALL
case 'g':
if (!PEND && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_G_SUBEXP_CALL)) {
PFETCH(c);
if (c == '<' || c == '\'') {
int gnum;
UChar* name_end;
prev = p;
r = fetch_name((OnigCodePoint )c, &p, end, &name_end, env, &gnum, 1);
if (r < 0) return r;
tok->type = TK_CALL;
tok->u.call.name     = prev;
tok->u.call.name_end = name_end;
tok->u.call.gnum     = gnum;
}
else
PUNFETCH;
}
break;
#endif
case 'Q':
if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_CAPITAL_Q_QUOTE)) {
tok->type = TK_QUOTE_OPEN;
}
break;
case 'p':
case 'P':
if (!PEND && PPEEK_IS('{') &&
IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY)) {
PINC;
tok->type = TK_CHAR_PROPERTY;
tok->u.prop.not = (c == 'P' ? 1 : 0);
if (!PEND &&
IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT)) {
PFETCH(c);
if (c == '^') {
tok->u.prop.not = (tok->u.prop.not == 0 ? 1 : 0);
}
else
PUNFETCH;
}
}
break;
default:
{
OnigCodePoint c2;
PUNFETCH;
num = fetch_escaped_value(&p, end, env, &c2);
if (num < 0) return num;
if (tok->u.c != c2) {
tok->type = TK_CODE_POINT;
tok->u.code = c2;
}
else {
p = tok->backp + enclen(enc, tok->backp);
}
}
break;
}
}
else {
tok->u.c = c;
tok->escaped = 0;
#ifdef USE_VARIABLE_META_CHARS
if ((c != ONIG_INEFFECTIVE_META_CHAR) &&
IS_SYNTAX_OP(syn, ONIG_SYN_OP_VARIABLE_META_CHARACTERS)) {
if (c == MC_ANYCHAR(syn))
goto any_char;
else if (c == MC_ANYTIME(syn))
goto anytime;
else if (c == MC_ZERO_OR_ONE_TIME(syn))
goto zero_or_one_time;
else if (c == MC_ONE_OR_MORE_TIME(syn))
goto one_or_more_time;
else if (c == MC_ANYCHAR_ANYTIME(syn)) {
tok->type = TK_ANYCHAR_ANYTIME;
goto out;
}
}
#endif
switch (c) {
case '.':
if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_DOT_ANYCHAR)) break;
#ifdef USE_VARIABLE_META_CHARS
any_char:
#endif
tok->type = TK_ANYCHAR;
break;
case '*':
if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ASTERISK_ZERO_INF)) break;
#ifdef USE_VARIABLE_META_CHARS
anytime:
#endif
tok->type = TK_OP_REPEAT;
tok->u.repeat.lower = 0;
tok->u.repeat.upper = REPEAT_INFINITE;
goto greedy_check;
break;
case '+':
if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_PLUS_ONE_INF)) break;
#ifdef USE_VARIABLE_META_CHARS
one_or_more_time:
#endif
tok->type = TK_OP_REPEAT;
tok->u.repeat.lower = 1;
tok->u.repeat.upper = REPEAT_INFINITE;
goto greedy_check;
break;
case '?':
if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_QMARK_ZERO_ONE)) break;
#ifdef USE_VARIABLE_META_CHARS
zero_or_one_time:
#endif
tok->type = TK_OP_REPEAT;
tok->u.repeat.lower = 0;
tok->u.repeat.upper = 1;
goto greedy_check;
break;
case '{':
if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_BRACE_INTERVAL)) break;
r = fetch_range_quantifier(&p, end, tok, env);
if (r < 0) return r;
if (r == 0) goto greedy_check;
else if (r == 2) {
if (IS_SYNTAX_BV(syn, ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY))
goto possessive_check;
goto greedy_check;
}
break;
case '|':
if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_VBAR_ALT)) break;
tok->type = TK_ALT;
break;
case '(':
if (!PEND && PPEEK_IS('?') &&
IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_QMARK_GROUP_EFFECT)) {
PINC;
if (!PEND && PPEEK_IS('#')) {
PFETCH(c);
while (1) {
if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;
PFETCH(c);
if (c == MC_ESC(syn)) {
if (!PEND) PFETCH(c);
}
else {
if (c == ')') break;
}
}
goto start;
}
PUNFETCH;
}
if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LPAREN_SUBEXP)) break;
tok->type = TK_SUBEXP_OPEN;
break;
case ')':
if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LPAREN_SUBEXP)) break;
tok->type = TK_SUBEXP_CLOSE;
break;
case '^':
if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LINE_ANCHOR)) break;
tok->type = TK_ANCHOR;
tok->u.subtype = (IS_SINGLELINE(env->option)
? ANCHOR_BEGIN_BUF : ANCHOR_BEGIN_LINE);
break;
case '$':
if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LINE_ANCHOR)) break;
tok->type = TK_ANCHOR;
tok->u.subtype = (IS_SINGLELINE(env->option)
? ANCHOR_SEMI_END_BUF : ANCHOR_END_LINE);
break;
case '[':
if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_BRACKET_CC)) break;
tok->type = TK_CC_OPEN;
break;
case ']':
if (*src > env->pattern)
CLOSE_BRACKET_WITHOUT_ESC_WARN(env, (UChar* )""]"");
break;
case '#':
if (IS_EXTEND(env->option)) {
while (!PEND) {
PFETCH(c);
if (ONIGENC_IS_CODE_NEWLINE(enc, c))
break;
}
goto start;
break;
}
break;
case ' ': case '\t': case '\n': case '\r': case '\f':
if (IS_EXTEND(env->option))
goto start;
break;
default:
break;
}
}
#ifdef USE_VARIABLE_META_CHARS
out:
#endif
*src = p;
return tok->type;
}",[270],"An issue was discovered in Oniguruma 6.2.0, as used in Oniguruma-mod in Ruby through 2.4.1 and mbstring in PHP through 7.1.5. A heap out-of-bounds write or read occurs in next_state_val() during regular expression compilation. Octal numbers larger than 0xff are not handled correctly in fetch_token() and fetch_token_in_cc(). A malformed regular expression containing an octal number in the form of '\700' would produce an invalid code point value larger than 0xff in next_state_val(), resulting in an out-of-bounds write memory corruption.",oniguruma,CVE-2017-9226,CWE-787
8489,9770,"future<fragmented_temporary_buffer> cql_server::connection::read_and_decompress_frame(size_t length, uint8_t flags)
{
using namespace compression_buffers;
if (flags & cql_frame_flags::compression) {
if (_compression == cql_compression::lz4) {
if (length < 4) {
throw std::runtime_error(fmt::format(""CQL frame truncated: expected to have at least 4 bytes, got {}"", length));
}
return _buffer_reader.read_exactly(_read_buf, length).then([this] (fragmented_temporary_buffer buf) {
auto linearization_buffer = bytes_ostream();
int32_t uncomp_len = request_reader(buf.get_istream(), linearization_buffer).read_int();
if (uncomp_len < 0) {
throw std::runtime_error(""CQL frame uncompressed length is negative: "" + std::to_string(uncomp_len));
}
buf.remove_prefix(4);
auto in = input_buffer.get_linearized_view(fragmented_temporary_buffer::view(buf));
auto uncomp = output_buffer.make_fragmented_temporary_buffer(uncomp_len, fragmented_temporary_buffer::default_fragment_size, [&] (bytes_mutable_view out) {
auto ret = LZ4_decompress_safe(reinterpret_cast<const char*>(in.data()), reinterpret_cast<char*>(out.data()),
in.size(), out.size());
if (ret < 0) {
throw std::runtime_error(""CQL frame LZ4 uncompression failure"");
}
return out.size();
});
on_compression_buffer_use();
return uncomp;
});
} else if (_compression == cql_compression::snappy) {
return _buffer_reader.read_exactly(_read_buf, length).then([this] (fragmented_temporary_buffer buf) {
auto in = input_buffer.get_linearized_view(fragmented_temporary_buffer::view(buf));
size_t uncomp_len;
if (snappy_uncompressed_length(reinterpret_cast<const char*>(in.data()), in.size(), &uncomp_len) != SNAPPY_OK) {
throw std::runtime_error(""CQL frame Snappy uncompressed size is unknown"");
}
auto uncomp = output_buffer.make_fragmented_temporary_buffer(uncomp_len, fragmented_temporary_buffer::default_fragment_size, [&] (bytes_mutable_view out) {
size_t output_len = out.size();
if (snappy_uncompress(reinterpret_cast<const char*>(in.data()), in.size(), reinterpret_cast<char*>(out.data()), &output_len) != SNAPPY_OK) {
throw std::runtime_error(""CQL frame Snappy uncompression failure"");
}
return output_len;
});
on_compression_buffer_use();
return uncomp;
});
} else {
throw exceptions::protocol_exception(format(""Unknown compression algorithm""));
}
}
return _buffer_reader.read_exactly(_read_buf, length);
}",[23],"Scylla is a real-time big data database that is API-compatible with Apache Cassandra and Amazon DynamoDB. When decompressing CQL frame received from user, Scylla assumes that user-provided uncompressed length is correct. If user provides fake length, that is greater than the real one, part of decompression buffer won't be overwritten, and will be left uninitialized. This can be exploited in several ways, depending on the privileges of the user. 1. The main exploit is that an attacker with access to CQL port, but no user account, can bypass authentication, but only if there are other legitimate clients making connections to the cluster, and they use LZ4. 2. Attacker that already has a user account on the cluster can read parts of uninitialized memory, which can contain things like passwords of other users or fragments of other queries / results, which leads to authorization bypass and sensitive information disclosure. The bug has been patched in the following versions: Scylla Enterprise: 2020.1.14, 2021.1.12, 2022.1.0. Scylla Open Source: 4.6.7, 5.0.3. Users unable to upgrade should make sure none of their drivers connect to cluster using LZ4 compression, and that Scylla CQL port is behind firewall. Additionally make sure no untrusted client can connect to Scylla, by setting up authentication and applying workarounds from previous point (firewall, no lz4 compression).",scylladb,CVE-2022-29240,CWE-908
8494,7331,"GF_Err abst_box_read(GF_Box *s, GF_BitStream *bs)
{
GF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;
int i;
u32 tmp_strsize;
char *tmp_str;
GF_Err e;
ISOM_DECREASE_SIZE(ptr, 25)
ptr->bootstrapinfo_version = gf_bs_read_u32(bs);
ptr->profile = gf_bs_read_int(bs, 2);
ptr->live = gf_bs_read_int(bs, 1);
ptr->update = gf_bs_read_int(bs, 1);
ptr->reserved = gf_bs_read_int(bs, 4);
ptr->time_scale = gf_bs_read_u32(bs);
ptr->current_media_time = gf_bs_read_u64(bs);
ptr->smpte_time_code_offset = gf_bs_read_u64(bs);
i=0;
if (ptr->size<8) return GF_ISOM_INVALID_FILE;
tmp_strsize =(u32)ptr->size-8;
tmp_str = gf_malloc(sizeof(char)*tmp_strsize);
if (!tmp_str) return GF_OUT_OF_MEM;
memset(tmp_str, 0, sizeof(char)*tmp_strsize);
while (tmp_strsize) {
tmp_str[i] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[i])
break;
i++;
}
if (i) {
ptr->movie_identifier = gf_strdup(tmp_str);
}
ptr->server_entry_count = gf_bs_read_u8(bs);
for (i=0; i<ptr->server_entry_count; i++) {
int j=0;
tmp_strsize=(u32)ptr->size-8;
while (tmp_strsize) {
tmp_str[j] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[j])
break;
j++;
}
if (j) {
gf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);
}
}
ptr->quality_entry_count = gf_bs_read_u8(bs);
for (i=0; i<ptr->quality_entry_count; i++) {
int j=0;
tmp_strsize=(u32)ptr->size-8;
while (tmp_strsize) {
tmp_str[j] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[j])
break;
j++;
}
if (j) {
gf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);
}
}
i=0;
tmp_strsize=(u32)ptr->size-8;
while (tmp_strsize) {
tmp_str[i] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[i])
break;
i++;
}
if (i) {
ptr->drm_data = gf_strdup(tmp_str);
}
i=0;
tmp_strsize=(u32)ptr->size-8;
while (tmp_strsize) {
tmp_str[i] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[i])
break;
i++;
}
if (i) {
ptr->meta_data = gf_strdup(tmp_str);
}
ptr->segment_run_table_count = gf_bs_read_u8(bs);
for (i=0; i<ptr->segment_run_table_count; i++) {
GF_AdobeSegmentRunTableBox *asrt = NULL;
e = gf_isom_box_parse((GF_Box **)&asrt, bs);
if (e) {
if (asrt) gf_isom_box_del((GF_Box*)asrt);
gf_free(tmp_str);
return e;
}
gf_list_add(ptr->segment_run_table_entries, asrt);
}
ptr->fragment_run_table_count = gf_bs_read_u8(bs);
for (i=0; i<ptr->fragment_run_table_count; i++) {
GF_AdobeFragmentRunTableBox *afrt = NULL;
e = gf_isom_box_parse((GF_Box **)&afrt, bs);
if (e) {
if (afrt) gf_isom_box_del((GF_Box*)afrt);
gf_free(tmp_str);
return e;
}
gf_list_add(ptr->fragment_run_table_entries, afrt);
}
gf_free(tmp_str);
return GF_OK;
}","[24, 33, 36, 38, 48, 51, 53, 64, 66, 76, 78, 87, 98]",An issue was discovered in gpac before 1.0.1. The abst_box_read function in box_code_adobe.c has a heap-based buffer over-read.,gpac,CVE-2020-23931,CWE-125
8499,8054,"GF_Err stbl_AppendSize(GF_SampleTableBox *stbl, u32 size, u32 nb_pack)
{
u32 i;
if (!nb_pack) nb_pack = 1;
if (!stbl->SampleSize->sampleCount) {
stbl->SampleSize->sampleSize = size;
stbl->SampleSize->sampleCount += nb_pack;
return GF_OK;
}
if (stbl->SampleSize->sampleSize && (stbl->SampleSize->sampleSize==size)) {
stbl->SampleSize->sampleCount += nb_pack;
return GF_OK;
}
if (!stbl->SampleSize->sizes || (stbl->SampleSize->sampleCount+nb_pack > stbl->SampleSize->alloc_size)) {
Bool init_table = (stbl->SampleSize->sizes==NULL) ? 1 : 0;
ALLOC_INC(stbl->SampleSize->alloc_size);
if (stbl->SampleSize->sampleCount+nb_pack > stbl->SampleSize->alloc_size)
stbl->SampleSize->alloc_size = stbl->SampleSize->sampleCount+nb_pack;
stbl->SampleSize->sizes = (u32 *)gf_realloc(stbl->SampleSize->sizes, sizeof(u32)*stbl->SampleSize->alloc_size);
if (!stbl->SampleSize->sizes) return GF_OUT_OF_MEM;
memset(&stbl->SampleSize->sizes[stbl->SampleSize->sampleCount], 0, sizeof(u32) * (stbl->SampleSize->alloc_size - stbl->SampleSize->sampleCount) );
if (init_table) {
for (i=0; i<stbl->SampleSize->sampleCount; i++)
stbl->SampleSize->sizes[i] = stbl->SampleSize->sampleSize;
}
}
stbl->SampleSize->sampleSize = 0;
for (i=0; i<nb_pack; i++) {
stbl->SampleSize->sizes[stbl->SampleSize->sampleCount+i] = size;
}
stbl->SampleSize->sampleCount += nb_pack;
if (size > stbl->SampleSize->max_size)
stbl->SampleSize->max_size = size;
stbl->SampleSize->total_size += size;
stbl->SampleSize->total_samples += nb_pack;
return GF_OK;
}","[4, 14, 17, 19]",Buffer overflow in the stbl_AppendSize function in MP4Box in GPAC 1.0.1 allows attackers to cause a denial of service or execute arbitrary code via a crafted file.,gpac,CVE-2021-32439,CWE-120
8504,7472,"PackLinuxElf32::invert_pt_dynamic(Elf32_Dyn const *dynp)
{
if (dt_table[Elf32_Dyn::DT_NULL]) {
return;
}
Elf32_Dyn const *const dynp0 = dynp;
unsigned ndx = 1+ 0;
if (dynp)
for (; ; ++ndx, ++dynp) {
unsigned const d_tag = get_te32(&dynp->d_tag);
if (d_tag < DT_NUM) {
if (Elf32_Dyn::DT_NEEDED != d_tag
&&  dt_table[d_tag]
&&    get_te32(&dynp->d_val)
!= get_te32(&dynp0[-1+ dt_table[d_tag]].d_val)) {
char msg[50]; snprintf(msg, sizeof(msg),
""duplicate DT_%#x: [%#x] [%#x]"",
d_tag, -1+ dt_table[d_tag], -1+ ndx);
throwCantPack(msg);
}
dt_table[d_tag] = ndx;
}
if (Elf32_Dyn::DT_NULL == d_tag) {
break;
}
}
upx_dt_init = 0;
if (dt_table[Elf32_Dyn::DT_INIT])          upx_dt_init = Elf32_Dyn::DT_INIT;
else if (dt_table[Elf32_Dyn::DT_PREINIT_ARRAY]) upx_dt_init = Elf32_Dyn::DT_PREINIT_ARRAY;
else if (dt_table[Elf32_Dyn::DT_INIT_ARRAY])    upx_dt_init = Elf32_Dyn::DT_INIT_ARRAY;
unsigned const z_str = dt_table[Elf32_Dyn::DT_STRSZ];
if (z_str) {
strtab_end = get_te32(&dynp0[-1+ z_str].d_val);
if ((u32_t)file_size <= strtab_end) {
char msg[50]; snprintf(msg, sizeof(msg),
""bad DT_STRSZ %#x"", strtab_end);
throwCantPack(msg);
}
}
unsigned const x_sym = dt_table[Elf32_Dyn::DT_SYMTAB];
unsigned const x_str = dt_table[Elf32_Dyn::DT_STRTAB];
if (x_sym && x_str) {
upx_uint32_t const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);
upx_uint32_t const v_str = get_te32(&dynp0[-1+ x_str].d_val);
unsigned const  z_sym = dt_table[Elf32_Dyn::DT_SYMENT];
unsigned const sz_sym = !z_sym ? sizeof(Elf32_Sym)
: get_te32(&dynp0[-1+ z_sym].d_val);
if (v_sym < v_str) {
symnum_end = (v_str - v_sym) / sz_sym;
}
}
unsigned const v_hsh = elf_unsigned_dynamic(Elf32_Dyn::DT_HASH);
if (v_hsh && file_image) {
hashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_HASH);
if (!hashtab) {
char msg[40]; snprintf(msg, sizeof(msg),
""bad DT_HASH %#x"", v_hsh);
throwCantPack(msg);
}
unsigned const nbucket = get_te32(&hashtab[0]);
unsigned const *const buckets = &hashtab[2];
unsigned const *const chains = &buckets[nbucket]; (void)chains;
unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);
if (!nbucket
|| (nbucket>>31) || (file_size/sizeof(unsigned)) <= (2*nbucket)
|| ((v_hsh < v_sym) && (v_sym - v_hsh) < (sizeof(unsigned)*2
+ sizeof(*buckets)*nbucket
+ sizeof(*chains) *nbucket
))
) {
char msg[90]; snprintf(msg, sizeof(msg),
""bad DT_HASH nbucket=%#x  len=%#x"",
nbucket, (v_sym - v_hsh));
throwCantPack(msg);
}
}
unsigned const v_gsh = elf_unsigned_dynamic(Elf32_Dyn::DT_GNU_HASH);
if (v_gsh && file_image) {
gashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_GNU_HASH);
if (!gashtab) {
char msg[40]; snprintf(msg, sizeof(msg),
""bad DT_GNU_HASH %#x"", v_gsh);
throwCantPack(msg);
}
unsigned const n_bucket = get_te32(&gashtab[0]);
unsigned const n_bitmask = get_te32(&gashtab[2]);
unsigned const gnu_shift = get_te32(&gashtab[3]);
unsigned const *const bitmask = (unsigned const *)(void const *)&gashtab[4];
unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask];
unsigned     const *const hasharr = &buckets[n_bucket]; (void)hasharr;
unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);
if (!n_bucket || !n_bitmask
|| (-1+ n_bitmask) & n_bitmask
|| 8*sizeof(unsigned) <= gnu_shift
|| (n_bucket>>30)
|| (n_bitmask>>30)
|| (file_size / sizeof(unsigned)) <= (n_bitmask + 2*n_bucket)
|| ((v_gsh < v_sym) && (v_sym - v_gsh) < (sizeof(unsigned)*4
+ sizeof(*bitmask)*n_bitmask
+ sizeof(*buckets)*n_bucket
+ sizeof(*hasharr)*n_bucket
))
) {
char msg[90]; snprintf(msg, sizeof(msg),
""bad DT_GNU_HASH n_bucket=%#x  n_bitmask=%#x  len=%#x"",
n_bucket, n_bitmask, v_sym - v_gsh);
throwCantPack(msg);
}
}
unsigned const e_shstrndx = get_te16(&ehdri.e_shstrndx);
if (e_shnum <= e_shstrndx
&&  !(0==e_shnum && 0==e_shstrndx) ) {
char msg[40]; snprintf(msg, sizeof(msg),
""bad .e_shstrndx %d >= .e_shnum %d"", e_shstrndx, e_shnum);
throwCantPack(msg);
}
}","[48, 52]",A floating point exception issue was discovered in UPX in PackLinuxElf64::invert_pt_dynamic() function of p_lx_elf.cpp file. An attacker with a crafted input file could trigger this issue that could cause a crash leading to a denial of service. The highest impact is to Availability.,upx,CVE-2020-27790,CWE-369
8506,6153,"bool PackLinuxElf64::calls_crt1(Elf64_Rela const *rela, int sz)
{
if (!dynsym || !dynstr) {
return false;
}
for (unsigned relnum= 0; 0 < sz; (sz -= sizeof(Elf64_Rela)), ++rela, ++relnum) {
unsigned const symnum = get_te64(&rela->r_info) >> 32;
char const *const symnam = get_dynsym_name(symnum, relnum);
if (0==strcmp(symnam, ""__libc_start_main"")
||  0==strcmp(symnam, ""__libc_init"")
||  0==strcmp(symnam, ""__uClibc_main"")
||  0==strcmp(symnam, ""__uClibc_start_main""))
return true;
}
return false;
}",[3],p_lx_elf.cpp in UPX before 3.96 has an integer overflow during unpacking via crafted values in a PT_DYNAMIC segment.,upx,CVE-2019-20805,CWE-190
8518,8044,"static void get_over(struct SYMBOL *s)
{
struct VOICE_S *p_voice, *p_voice2, *p_voice3;
int range, voice, voice2, voice3;
static char tx_wrong_dur[] = ""Wrong duration in voice overlay"";
static char txt_no_note[] = ""No note in voice overlay"";
p_voice = curvoice;
if (p_voice->ignore)
return;
if (s->abc_type == ABC_T_BAR
|| s->u.v_over.type == V_OVER_E)  {
if (!p_voice->last_sym) {
error(1, s, txt_no_note);
return;
}
p_voice->last_sym->sflags |= S_BEAM_END;
over_bar = 0;
if (over_time < 0) {
error(1, s, ""Erroneous end of voice overlap"");
return;
}
if (p_voice->time != over_mxtime)
error(1, s, tx_wrong_dur);
curvoice = &voice_tb[over_voice];
over_mxtime = 0;
over_voice = -1;
over_time = -1;
return;
}
if (s->u.v_over.type == V_OVER_S) {
over_voice = p_voice - voice_tb;
over_time = p_voice->time;
return;
}
if (!p_voice->last_sym) {
error(1, s, txt_no_note);
return;
}
p_voice->last_sym->sflags |= S_BEAM_END;
voice2 = s->u.v_over.voice;
p_voice2 = &voice_tb[voice2];
if (parsys->voice[voice2].range < 0) {
int clone;
if (cfmt.abc2pscompat) {
error(1, s, ""Cannot have %%%%abc2pscompat"");
cfmt.abc2pscompat = 0;
}
clone = p_voice->clone >= 0;
p_voice2->id[0] = '&';
p_voice2->id[1] = '\0';
p_voice2->second = 1;
parsys->voice[voice2].second = 1;
p_voice2->scale = p_voice->scale;
p_voice2->octave = p_voice->octave;
p_voice2->transpose = p_voice->transpose;
memcpy(&p_voice2->key, &p_voice->key,
sizeof p_voice2->key);
memcpy(&p_voice2->ckey, &p_voice->ckey,
sizeof p_voice2->ckey);
memcpy(&p_voice2->okey, &p_voice->okey,
sizeof p_voice2->okey);
p_voice2->posit = p_voice->posit;
p_voice2->staff = p_voice->staff;
p_voice2->cstaff = p_voice->cstaff;
p_voice2->color = p_voice->color;
p_voice2->map_name = p_voice->map_name;
range = parsys->voice[p_voice - voice_tb].range;
for (voice = 0; voice < MAXVOICE; voice++) {
if (parsys->voice[voice].range > range)
parsys->voice[voice].range += clone + 1;
}
parsys->voice[voice2].range = range + 1;
voice_link(p_voice2);
if (clone) {
for (voice3 = MAXVOICE; --voice3 >= 0; ) {
if (parsys->voice[voice3].range < 0)
break;
}
if (voice3 > 0) {
p_voice3 = &voice_tb[voice3];
strcpy(p_voice3->id, p_voice2->id);
p_voice3->second = 1;
parsys->voice[voice3].second = 1;
p_voice3->scale = voice_tb[p_voice->clone].scale;
parsys->voice[voice3].range = range + 2;
voice_link(p_voice3);
p_voice2->clone = voice3;
} else {
error(1, s,
""Too many voices for overlay cloning"");
}
}
}
voice = p_voice - voice_tb;
if (over_time < 0) {
int time;
over_bar = 1;
over_mxtime = p_voice->time;
over_voice = voice;
time = p_voice2->time;
for (s = p_voice->last_sym;      ; s = s->prev) {
if (s->type == BAR
|| s->time <= time)
break;
}
over_time = s->time;
} else {
if (over_mxtime == 0)
over_mxtime = p_voice->time;
else if (p_voice->time != over_mxtime)
error(1, s, tx_wrong_dur);
}
p_voice2->time = over_time;
curvoice = p_voice2;
}","[22, 23, 25]",abcm2ps v8.14.11 was discovered to contain an out-of-bounds read in the function calculate_beam at draw.c.,abcm2ps,CVE-2021-32434,CWE-125
8520,7964,"static s32 gf_hevc_read_pps_bs_internal(GF_BitStream *bs, HEVCState *hevc)
{
u32 i;
s32 pps_id;
HEVC_PPS *pps;
pps_id = gf_bs_read_ue_log(bs, ""pps_id"");
if ((pps_id < 0) || (pps_id >= 64)) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[HEVC] wrong PPS ID %d in PPS\n"", pps_id));
return -1;
}
pps = &hevc->pps[pps_id];
if (!pps->state) {
pps->id = pps_id;
pps->state = 1;
}
pps->sps_id = gf_bs_read_ue_log(bs, ""sps_id"");
if (pps->sps_id >= 16) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[HEVC] wrong SPS ID %d in PPS\n"", pps->sps_id));
pps->sps_id=0;
return -1;
}
hevc->sps_active_idx = pps->sps_id;
pps->dependent_slice_segments_enabled_flag = gf_bs_read_int_log(bs, 1, ""dependent_slice_segments_enabled_flag"");
pps->output_flag_present_flag = gf_bs_read_int_log(bs, 1, ""output_flag_present_flag"");
pps->num_extra_slice_header_bits = gf_bs_read_int_log(bs, 3, ""num_extra_slice_header_bits"");
pps->sign_data_hiding_flag = gf_bs_read_int_log(bs, 1, ""sign_data_hiding_flag"");
pps->cabac_init_present_flag = gf_bs_read_int_log(bs, 1, ""cabac_init_present_flag"");
pps->num_ref_idx_l0_default_active = 1 + gf_bs_read_ue_log(bs, ""num_ref_idx_l0_default_active"");
pps->num_ref_idx_l1_default_active = 1 + gf_bs_read_ue_log(bs, ""num_ref_idx_l1_default_active"");
pps->pic_init_qp_minus26 = gf_bs_read_se_log(bs, ""pic_init_qp_minus26"");
pps->constrained_intra_pred_flag = gf_bs_read_int_log(bs, 1, ""constrained_intra_pred_flag"");
pps->transform_skip_enabled_flag = gf_bs_read_int_log(bs, 1, ""transform_skip_enabled_flag"");
if ((pps->cu_qp_delta_enabled_flag = gf_bs_read_int_log(bs, 1, ""cu_qp_delta_enabled_flag"")))
pps->diff_cu_qp_delta_depth = gf_bs_read_ue_log(bs, ""diff_cu_qp_delta_depth"");
pps->pic_cb_qp_offset = gf_bs_read_se_log(bs, ""pic_cb_qp_offset"");
pps->pic_cr_qp_offset = gf_bs_read_se_log(bs, ""pic_cr_qp_offset"");
pps->slice_chroma_qp_offsets_present_flag = gf_bs_read_int_log(bs, 1, ""slice_chroma_qp_offsets_present_flag"");
pps->weighted_pred_flag = gf_bs_read_int_log(bs, 1, ""weighted_pred_flag"");
pps->weighted_bipred_flag = gf_bs_read_int_log(bs, 1, ""weighted_bipred_flag"");
pps->transquant_bypass_enable_flag = gf_bs_read_int_log(bs, 1, ""transquant_bypass_enable_flag"");
pps->tiles_enabled_flag = gf_bs_read_int_log(bs, 1, ""tiles_enabled_flag"");
pps->entropy_coding_sync_enabled_flag = gf_bs_read_int_log(bs, 1, ""entropy_coding_sync_enabled_flag"");
if (pps->tiles_enabled_flag) {
pps->num_tile_columns = 1 + gf_bs_read_ue_log(bs, ""num_tile_columns_minus1"");
pps->num_tile_rows = 1 + gf_bs_read_ue_log(bs, ""num_tile_rows_minus1"");
pps->uniform_spacing_flag = gf_bs_read_int_log(bs, 1, ""uniform_spacing_flag"");
if (!pps->uniform_spacing_flag) {
for (i = 0; i < pps->num_tile_columns - 1; i++) {
pps->column_width[i] = 1 + gf_bs_read_ue_log_idx(bs, ""column_width_minus1"", i);
}
for (i = 0; i < pps->num_tile_rows - 1; i++) {
pps->row_height[i] = 1 + gf_bs_read_ue_log_idx(bs, ""row_height_minus1"", i);
}
}
pps->loop_filter_across_tiles_enabled_flag = gf_bs_read_int_log(bs, 1, ""loop_filter_across_tiles_enabled_flag"");
}
pps->loop_filter_across_slices_enabled_flag = gf_bs_read_int_log(bs, 1, ""loop_filter_across_slices_enabled_flag"");
if ((pps->deblocking_filter_control_present_flag = gf_bs_read_int_log(bs, 1, ""deblocking_filter_control_present_flag""))) {
pps->deblocking_filter_override_enabled_flag = gf_bs_read_int_log(bs, 1, ""deblocking_filter_override_enabled_flag"");
if (! (pps->pic_disable_deblocking_filter_flag = gf_bs_read_int_log(bs, 1, ""pic_disable_deblocking_filter_flag""))) {
pps->beta_offset_div2 = gf_bs_read_se_log(bs, ""beta_offset_div2"");
pps->tc_offset_div2 = gf_bs_read_se_log(bs, ""tc_offset_div2"");
}
}
if ((pps->pic_scaling_list_data_present_flag = gf_bs_read_int_log(bs, 1, ""pic_scaling_list_data_present_flag""))) {
hevc_scaling_list_data(bs);
}
pps->lists_modification_present_flag = gf_bs_read_int_log(bs, 1, ""lists_modification_present_flag"");
pps->log2_parallel_merge_level_minus2 = gf_bs_read_ue_log(bs, ""log2_parallel_merge_level_minus2"");
pps->slice_segment_header_extension_present_flag = gf_bs_read_int_log(bs, 1, ""slice_segment_header_extension_present_flag"");
if (gf_bs_read_int_log(bs, 1, ""pps_extension_flag"")) {
#if 0
while (gf_bs_available(bs)) {
gf_bs_read_int(bs, 1);
}
#endif
}
return pps_id;
}",[17],There is a integer overflow in media_tools/av_parsers.c in the hevc_parse_slice_segment function in GPAC 1.0.1 which results in a crash.,gpac,CVE-2021-30014,CWE-190
8523,8144,"int main(int argc, char **argv)
{
int opt, timeout = 1800, family = AF_UNSPEC, hashlength = 0, hashmin = 0;
int daemonize = FALSE, always_rewrite = FALSE;
char *listen_addr = NULL, *forward_service = NULL, *reverse_service = NULL,
*user = NULL, *domain = NULL, *chroot_dir = NULL;
char separator = '=';
char *secret_file = NULL, *pid_file = NULL;
FILE *pf = NULL, *sf = NULL;
struct passwd *pwd = NULL;
char secretbuf[1024], *secret = NULL;
char *tmp;
time_t now;
srs_t *srs;
const char **excludes;
size_t s1 = 0, s2 = 1;
struct pollfd fds[4];
size_t socket_count = 0, sc;
int sockets[4] = {-1, -1, -1, -1};
handle_t handler[4] = {0, 0, 0, 0};
int fd, maxfd;
excludes = (const char **)calloc(1, sizeof(char *));
tmp = strrchr(argv[0], '/');
if (tmp)
self = strdup(tmp + 1);
else
self = strdup(argv[0]);
while ((opt = getopt(argc, argv, ""46d:a:l:f:r:s:n:N:u:t:p:c:X::ADhev""))
!= -1)
{
switch (opt)
{
case '?':
return EXIT_FAILURE;
case '4':
family = AF_INET;
break;
case '6':
family = AF_INET6;
break;
case 'd':
domain = strdup(optarg);
break;
case 'a':
separator = *optarg;
break;
case 'l':
listen_addr = strdup(optarg);
break;
case 'f':
forward_service = strdup(optarg);
break;
case 'r':
reverse_service = strdup(optarg);
break;
case 't':
timeout = atoi(optarg);
break;
case 's':
secret_file = strdup(optarg);
break;
case 'n':
hashlength = atoi(optarg);
break;
case 'N':
hashmin = atoi(optarg);
break;
case 'p':
pid_file = strdup(optarg);
break;
case 'u':
user = strdup(optarg);
break;
case 'c':
chroot_dir = strdup(optarg);
break;
case 'D':
daemonize = TRUE;
break;
case 'A':
always_rewrite = TRUE;
break;
case 'h':
show_help();
return EXIT_SUCCESS;
case 'X':
if (optarg != NULL)
{
tmp = strtok(optarg, "",; \t\r\n"");
while (tmp)
{
if (s1 + 1 >= s2)
{
s2 *= 2;
excludes = (const char **)realloc(
excludes, s2 * sizeof(char *));
if (excludes == NULL)
{
fprintf(stderr, ""%s: Out of memory\n\n"", self);
return EXIT_FAILURE;
}
}
excludes[s1++] = strdup(tmp);
tmp = strtok(NULL, "",; \t\r\n"");
}
excludes[s1] = NULL;
}
break;
case 'e':
if (getenv(""SRS_DOMAIN"") != NULL)
domain = strdup(getenv(""SRS_DOMAIN""));
if (getenv(""SRS_SEPARATOR"") != NULL)
separator = *getenv(""SRS_SEPARATOR"");
if (getenv(""SRS_HASHLENGTH"") != NULL)
hashlength = atoi(getenv(""SRS_HASHLENGTH""));
if (getenv(""SRS_HASHMIN"") != NULL)
hashmin = atoi(getenv(""SRS_HASHMIN""));
if (getenv(""SRS_FORWARD_PORT"") != NULL)
forward_service = strdup(getenv(""SRS_FORWARD_PORT""));
if (getenv(""SRS_REVERSE_PORT"") != NULL)
reverse_service = strdup(getenv(""SRS_REVERSE_PORT""));
if (getenv(""SRS_TIMEOUT"") != NULL)
timeout = atoi(getenv(""SRS_TIMEOUT""));
if (getenv(""SRS_SECRET"") != NULL)
secret_file = strdup(getenv(""SRS_SECRET""));
if (getenv(""SRS_PID_FILE"") != NULL)
pid_file = strdup(getenv(""SRS_PID_FILE""));
if (getenv(""RUN_AS"") != NULL)
user = strdup(getenv(""RUN_AS""));
if (getenv(""CHROOT"") != NULL)
chroot_dir = strdup(getenv(""CHROOT""));
if (getenv(""SRS_EXCLUDE_DOMAINS"") != NULL)
{
tmp = strtok(getenv(""SRS_EXCLUDE_DOMAINS""), "",; \t\r\n"");
while (tmp)
{
if (s1 + 1 >= s2)
{
s2 *= 2;
excludes = (const char **)realloc(
excludes, s2 * sizeof(char *));
if (excludes == NULL)
{
fprintf(stderr, ""%s: Out of memory\n\n"", self);
return EXIT_FAILURE;
}
}
excludes[s1++] = strdup(tmp);
tmp = strtok(NULL, "",; \t\r\n"");
}
excludes[s1] = NULL;
}
break;
case 'v':
fprintf(stdout, ""%s\n"", POSTSRSD_VERSION);
return EXIT_SUCCESS;
}
}
if (optind < argc)
{
fprintf(stderr, ""%s: extra argument on command line: %s\n"", self,
argv[optind]);
return EXIT_FAILURE;
}
if (domain == NULL || *domain == 0)
{
fprintf(stderr, ""%s: You must set a home domain (-d)\n"", self);
return EXIT_FAILURE;
}
if (separator != '=' && separator != '+' && separator != '-')
{
fprintf(stderr, ""%s: SRS separator character must be one of '=+-'\n"",
self);
return EXIT_FAILURE;
}
if (forward_service == NULL)
forward_service = strdup(""10001"");
if (reverse_service == NULL)
reverse_service = strdup(""10002"");
maxfd = sysconf(_SC_OPEN_MAX);
for (fd = 3; fd < maxfd; fd++)
close(fd);
if (pid_file)
{
pf = fopen(pid_file, ""w"");
if (pf == NULL)
{
fprintf(stderr, ""%s: Cannot write PID: %s\n\n"", self, pid_file);
return EXIT_FAILURE;
}
}
if (secret_file != NULL)
{
sf = fopen(secret_file, ""rb"");
if (sf == NULL)
{
fprintf(stderr, ""%s: Cannot open file with secret: %s\n"", self,
secret_file);
return EXIT_FAILURE;
}
}
else
{
fprintf(stderr, ""%s: You must set a secret (-s)\n"", self);
return EXIT_FAILURE;
}
sc = bind_service(listen_addr, forward_service, family,
&sockets[socket_count], 4 - socket_count);
if (sc == 0)
return EXIT_FAILURE;
while (sc-- > 0)
handler[socket_count++] = handle_forward;
free(forward_service);
sc = bind_service(listen_addr, reverse_service, family,
&sockets[socket_count], 4 - socket_count);
if (sc == 0)
return EXIT_FAILURE;
while (sc-- > 0)
handler[socket_count++] = handle_reverse;
free(reverse_service);
openlog(self, LOG_PID | LOG_NDELAY, LOG_MAIL);
now = time(NULL);
localtime(&now);
if (user)
{
errno = 0;
pwd = getpwnam(user);
if (pwd == NULL)
{
if (errno != 0)
fprintf(stderr, ""%s: Failed to lookup user: %s\n"", self,
strerror(errno));
else
fprintf(stderr, ""%s: No such user: %s\n"", self, user);
return EXIT_FAILURE;
}
}
if (chroot_dir)
{
if (chdir(chroot_dir) < 0)
{
fprintf(stderr, ""%s: Cannot change to chroot: %s\n"", self,
strerror(errno));
return EXIT_FAILURE;
}
if (chroot(chroot_dir) < 0)
{
fprintf(stderr, ""%s: Failed to enable chroot: %s\n"", self,
strerror(errno));
return EXIT_FAILURE;
}
}
if (pwd)
{
if (setgid(pwd->pw_gid) < 0)
{
fprintf(stderr, ""%s: Failed to switch group id: %s\n"", self,
strerror(errno));
return EXIT_FAILURE;
}
if (setuid(pwd->pw_uid) < 0)
{
fprintf(stderr, ""%s: Failed to switch user id: %s\n"", self,
strerror(errno));
return EXIT_FAILURE;
}
}
if (daemonize)
{
close(0);
close(1);
close(2);
if (fork() != 0)
return EXIT_SUCCESS;
setsid();
if (fork() != 0)
return EXIT_SUCCESS;
}
if (pf)
{
fprintf(pf, ""%d"", (int)getpid());
fclose(pf);
}
srs = srs_new();
while ((secret = fgets(secretbuf, sizeof(secretbuf), sf)))
{
secret = strtok(secret, ""\r\n"");
if (secret)
srs_add_secret(srs, secret);
}
fclose(sf);
srs_set_alwaysrewrite(srs, always_rewrite);
srs_set_separator(srs, separator);
if (hashlength)
srs_set_hashlength(srs, hashlength);
if (hashmin)
srs_set_hashmin(srs, hashmin);
for (sc = 0; sc < socket_count; ++sc)
{
fds[sc].fd = sockets[sc];
fds[sc].events = POLLIN;
}
while (TRUE)
{
int conn;
FILE *fp;
char linebuf[1024], *line;
char keybuf[1024], *key;
if (poll(fds, socket_count, 1000) < 0)
{
if (errno == EINTR)
continue;
if (daemonize)
syslog(LOG_MAIL | LOG_ERR, ""Poll failure: %s"", strerror(errno));
else
fprintf(stderr, ""%s: Poll failure: %s\n"", self,
strerror(errno));
return EXIT_FAILURE;
}
for (sc = 0; sc < socket_count; ++sc)
{
if (fds[sc].revents)
{
conn = accept(fds[sc].fd, NULL, NULL);
if (conn < 0)
continue;
if (fork() == 0)
{
int i;
for (i = 0; i < socket_count; ++i)
close(sockets[i]);
fp = fdopen(conn, ""r+"");
if (fp == NULL)
exit(EXIT_FAILURE);
fds[0].fd = conn;
fds[0].events = POLLIN;
if (poll(fds, 1, timeout * 1000) <= 0)
return EXIT_FAILURE;
line = fgets(linebuf, sizeof(linebuf), fp);
while (line)
{
fseek(fp, 0, SEEK_CUR);
char *token;
token = strtok(line, "" \r\n"");
if (token == NULL || strcmp(token, ""get"") != 0)
{
fprintf(fp, ""500 Invalid request\n"");
fflush(fp);
return EXIT_FAILURE;
}
token = strtok(NULL, ""\r\n"");
if (!token)
{
fprintf(fp, ""500 Invalid request\n"");
fflush(fp);
return EXIT_FAILURE;
}
key = url_decode(keybuf, sizeof(keybuf), token);
if (!key)
{
fprintf(fp, ""500 Invalid request\n"");
fflush(fp);
return EXIT_FAILURE;
}
handler[sc](srs, fp, key, domain, excludes);
fflush(fp);
if (poll(fds, 1, timeout * 1000) <= 0)
break;
line = fgets(linebuf, sizeof(linebuf), fp);
}
fclose(fp);
return EXIT_SUCCESS;
}
close(conn);
}
}
waitpid(-1, NULL, WNOHANG);
}
return EXIT_SUCCESS;
}","[306, 332, 333, 334, 335, 336, 337, 339, 340, 342, 344, 347, 348, 354, 355, 361, 362, 365, 366, 367, 368, 369, 371]","PostSRSd before 1.11 allows a denial of service (subprocess hang) if Postfix sends certain long data fields such as multiple concatenated email addresses. NOTE: the PostSRSd maintainer acknowledges ""theoretically, this error should never occur ... I'm not sure if there's a reliable way to trigger this condition by an external attacker, but it is a security bug in PostSRSd nevertheless.""",postsrsd,CVE-2021-35525,NVD-CWE-noinfo
8531,8151,"int flb_parser_json_do(struct flb_parser *parser,
const char *in_buf, size_t in_size,
void **out_buf, size_t *out_size,
struct flb_time *out_time)
{
int i;
int skip;
int ret;
int slen;
int root_type;
int records;
double tmfrac = 0;
char *mp_buf = NULL;
char *time_key;
char *tmp_out_buf = NULL;
char tmp[255];
size_t tmp_out_size = 0;
size_t off = 0;
size_t map_size;
size_t mp_size;
size_t len;
msgpack_sbuffer mp_sbuf;
msgpack_packer  mp_pck;
msgpack_unpacked result;
msgpack_object map;
msgpack_object *k = NULL;
msgpack_object *v = NULL;
time_t time_lookup;
struct tm tm = {0};
struct flb_time *t;
ret = flb_pack_json_recs(in_buf, in_size, &mp_buf, &mp_size, &root_type,
&records);
if (ret != 0) {
return -1;
}
if (records != 1) {
flb_free(mp_buf);
return -1;
}
msgpack_unpacked_init(&result);
if (msgpack_unpack_next(&result, mp_buf, mp_size, &off) == MSGPACK_UNPACK_SUCCESS) {
map = result.data;
if (map.type != MSGPACK_OBJECT_MAP) {
flb_free(mp_buf);
msgpack_unpacked_destroy(&result);
return -1;
}
}
else {
if (mp_size > 0) {
flb_free(mp_buf);
}
msgpack_unpacked_destroy(&result);
return -1;
}
tmp_out_buf = mp_buf;
tmp_out_size = mp_size;
if (parser->decoders) {
ret = flb_parser_decoder_do(parser->decoders,
mp_buf, mp_size,
&tmp_out_buf, &tmp_out_size);
if (ret == 0) {
off = 0;
msgpack_unpacked_destroy(&result);
msgpack_unpacked_init(&result);
msgpack_unpack_next(&result, tmp_out_buf, tmp_out_size, &off);
map = result.data;
}
}
*out_buf = tmp_out_buf;
*out_size = tmp_out_size;
if (mp_buf != tmp_out_buf) {
flb_free(mp_buf);
}
if (!parser->time_fmt) {
msgpack_unpacked_destroy(&result);
return *out_size;
}
if (parser->time_key) {
time_key = parser->time_key;
}
else {
time_key = ""time"";
}
slen = strlen(time_key);
map_size = map.via.map.size;
skip = map_size;
for (i = 0; i < map_size; i++) {
k = &map.via.map.ptr[i].key;
v = &map.via.map.ptr[i].val;
if (k->via.str.size != slen) {
continue;
}
if (k->via.str.ptr == NULL) {
flb_free(mp_buf);
*out_buf = NULL;
msgpack_unpacked_destroy(&result);
return -1;
}
if (strncmp(k->via.str.ptr, time_key, k->via.str.size) == 0) {
if (parser->time_keep == FLB_FALSE) {
skip = i;
break;
}
else {
skip = -1;
}
break;
}
k = NULL;
v = NULL;
}
if (i >= map_size || !k || !v) {
msgpack_unpacked_destroy(&result);
return *out_size;
}
if (v->type != MSGPACK_OBJECT_STR) {
msgpack_unpacked_destroy(&result);
return *out_size;
}
ret = flb_parser_time_lookup(v->via.str.ptr, v->via.str.size,
0, parser, &tm, &tmfrac);
if (ret == -1) {
len = v->via.str.size;
if (len > sizeof(tmp) - 1) {
len = sizeof(tmp) - 1;
}
memcpy(tmp, v->via.str.ptr, len);
tmp[len] = '\0';
flb_warn(""[parser:%s] invalid time format %s for '%s'"",
parser->name, parser->time_fmt_full, tmp);
time_lookup = 0;
}
else {
time_lookup = flb_parser_tm2time(&tm);
}
msgpack_sbuffer_init(&mp_sbuf);
msgpack_packer_init(&mp_pck, &mp_sbuf, msgpack_sbuffer_write);
if (parser->time_keep == FLB_FALSE) {
msgpack_pack_map(&mp_pck, map_size - 1);
}
else {
msgpack_pack_map(&mp_pck, map_size);
}
for (i = 0; i < map_size; i++) {
if (i == skip) {
continue;
}
msgpack_pack_object(&mp_pck, map.via.map.ptr[i].key);
msgpack_pack_object(&mp_pck, map.via.map.ptr[i].val);
}
flb_free(tmp_out_buf);
*out_buf = mp_sbuf.data;
*out_size = mp_sbuf.size;
t = out_time;
t->tm.tv_sec  = time_lookup;
t->tm.tv_nsec = (tmfrac * 1000000000);
msgpack_unpacked_destroy(&result);
return *out_size;
}","[75, 96]","Fluent Bit (aka fluent-bit) 1.7.0 through 1.7,4 has a double free in flb_free (called from flb_parser_json_do and flb_parser_do).",fluent-bit,CVE-2021-36088,CWE-415
8546,7332,"void dump_isom_sdp(GF_ISOFile *file, char *inName, Bool is_final_name)
{
const char *sdp;
u32 size, i;
FILE *dump;
if (inName) {
char szBuf[1024];
strcpy(szBuf, inName);
if (!is_final_name) {
char *ext = strchr(szBuf, '.');
if (ext) ext[0] = 0;
strcat(szBuf, ""_sdp.txt"");
}
dump = gf_fopen(szBuf, ""wt"");
if (!dump) {
fprintf(stderr, ""Failed to open %s for dumping\n"", szBuf);
return;
}
} else {
dump = stdout;
fprintf(dump, ""* File SDP content *\n\n"");
}
gf_isom_sdp_get(file, &sdp, &size);
fprintf(dump, ""%s"", sdp);
fprintf(dump, ""\r\n"");
for (i=0; i<gf_isom_get_track_count(file); i++) {
if (gf_isom_get_media_type(file, i+1) != GF_ISOM_MEDIA_HINT) continue;
gf_isom_sdp_track_get(file, i+1, &sdp, &size);
fprintf(dump, ""%s"", sdp);
}
fprintf(dump, ""\n\n"");
if (inName) gf_fclose(dump);
}",[24],An issue was discovered in gpac before 1.0.1. A NULL pointer dereference exists in the function dump_isom_sdp located in filedump.c. It allows an attacker to cause Denial of Service.,gpac,CVE-2020-23932,CWE-476
8551,8485,"u32 gf_bs_read_ue_log_idx3(GF_BitStream *bs, const char *fname, s32 idx1, s32 idx2, s32 idx3)
{
u32 val=0, code;
s32 nb_lead = -1;
u32 bits = 0;
for (code=0; !code; nb_lead++) {
if (nb_lead>=32) {
if (!gf_bs_available(bs)) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[Core] exp-golomb read failed, not enough bits in bitstream !\n""));
} else {
GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[Core] corrupted exp-golomb code, %d leading zeros, max 31 allowed !\n"", nb_lead));
}
return 0;
}
code = gf_bs_read_int(bs, 1);
bits++;
}
if (nb_lead) {
u32 leads=1;
val = gf_bs_read_int(bs, nb_lead);
leads <<= nb_lead;
leads -= 1;
val += leads;
bits += nb_lead;
}
if (fname) {
gf_bs_log_idx(bs, bits, fname, val, idx1, idx2, idx3);
}
return val;
}","[8, 9, 10, 11, 13, 18]","A buffer overflow vulnerability exists in Gpac through 1.0.1 via a malformed MP4 file in the svc_parse_slice function in av_parsers.c, which allows attackers to cause a denial of service, even code execution and escalation of privileges.",gpac,CVE-2021-40568,CWE-120
8557,9459,"xmlAddID(xmlValidCtxtPtr ctxt, xmlDocPtr doc, const xmlChar *value,
xmlAttrPtr attr) {
xmlIDPtr ret;
xmlIDTablePtr table;
if (doc == NULL) {
return(NULL);
}
if (value == NULL) {
return(NULL);
}
if (attr == NULL) {
return(NULL);
}
table = (xmlIDTablePtr) doc->ids;
if (table == NULL)  {
doc->ids = table = xmlHashCreateDict(0, doc->dict);
}
if (table == NULL) {
xmlVErrMemory(ctxt,
""xmlAddID: Table creation failed!\n"");
return(NULL);
}
ret = (xmlIDPtr) xmlMalloc(sizeof(xmlID));
if (ret == NULL) {
xmlVErrMemory(ctxt, ""malloc failed"");
return(NULL);
}
ret->value = xmlStrdup(value);
ret->doc = doc;
if ((ctxt != NULL) && (ctxt->vstateNr != 0)) {
if (doc->dict != NULL)
ret->name = xmlDictLookup(doc->dict, attr->name, -1);
else
ret->name = xmlStrdup(attr->name);
ret->attr = NULL;
} else {
ret->attr = attr;
ret->name = NULL;
}
ret->lineno = xmlGetLineNo(attr->parent);
if (xmlHashAddEntry(table, value, ret) < 0) {
#ifdef LIBXML_VALID_ENABLED
if (ctxt != NULL) {
xmlErrValidNode(ctxt, attr->parent, XML_DTD_ID_REDEFINED,
""ID %s already defined\n"", value, NULL, NULL);
}
#endif /* LIBXML_VALID_ENABLED */
xmlFreeID(ret);
return(NULL);
}
if (attr != NULL)
attr->atype = XML_ATTRIBUTE_ID;
return(ret);
}","[8, 30]",valid.c in libxml2 before 2.9.13 has a use-after-free of ID and IDREF attributes.,libxml2,CVE-2022-23308,CWE-416
8567,8014,"_archive_write_disk_close(struct archive *_a)
{
struct archive_write_disk *a = (struct archive_write_disk *)_a;
struct fixup_entry *next, *p;
int fd, ret;
archive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,
ARCHIVE_STATE_HEADER | ARCHIVE_STATE_DATA,
""archive_write_disk_close"");
ret = _archive_write_disk_finish_entry(&a->archive);
p = sort_dir_list(a->fixup_list);
while (p != NULL) {
fd = -1;
a->pst = NULL;
if (p->fixup &
(TODO_TIMES | TODO_MODE_BASE | TODO_ACLS | TODO_FFLAGS)) {
fd = open(p->name,
O_WRONLY | O_BINARY | O_NOFOLLOW | O_CLOEXEC);
}
if (p->fixup & TODO_TIMES) {
set_times(a, fd, p->mode, p->name,
p->atime, p->atime_nanos,
p->birthtime, p->birthtime_nanos,
p->mtime, p->mtime_nanos,
p->ctime, p->ctime_nanos);
}
if (p->fixup & TODO_MODE_BASE) {
#ifdef HAVE_FCHMOD
if (fd >= 0)
fchmod(fd, p->mode);
else
#endif
chmod(p->name, p->mode);
}
if (p->fixup & TODO_ACLS)
archive_write_disk_set_acls(&a->archive, fd,
p->name, &p->acl, p->mode);
if (p->fixup & TODO_FFLAGS)
set_fflags_platform(a, fd, p->name,
p->mode, p->fflags_set, 0);
if (p->fixup & TODO_MAC_METADATA)
set_mac_metadata(a, p->name, p->mac_metadata,
p->mac_metadata_size);
next = p->next;
archive_acl_clear(&p->acl);
free(p->mac_metadata);
free(p->name);
if (fd >= 0)
close(fd);
free(p);
p = next;
}
a->fixup_list = NULL;
return (ret);
}","[5, 19, 32, 43]","An improper link resolution flaw can occur while extracting an archive leading to changing modes, times, access control lists, and flags of a file outside of the archive. An attacker may provide a malicious archive to a victim user, who would trigger this flaw when trying to extract the archive. A local attacker may use this flaw to gain more privileges in a system.",libarchive,CVE-2021-31566,CWE-59
8570,7549,"static int track_header(VividasDemuxContext *viv, AVFormatContext *s,  uint8_t *buf, int size)
{
int i, j, ret;
int64_t off;
int val_1;
int num_video;
AVIOContext pb0, *pb = &pb0;
ffio_init_context(pb, buf, size, 0, NULL, NULL, NULL, NULL);
ffio_read_varlen(pb);
avio_r8(pb);
val_1 = ffio_read_varlen(pb);
for (i=0;i<val_1;i++) {
int c = avio_r8(pb);
if (avio_feof(pb))
return AVERROR_EOF;
for (j=0;j<c;j++) {
if (avio_feof(pb))
return AVERROR_EOF;
avio_r8(pb);
avio_r8(pb);
}
}
avio_r8(pb);
off = avio_tell(pb);
off += ffio_read_varlen(pb);
avio_r8(pb);
num_video = avio_r8(pb);
avio_seek(pb, off, SEEK_SET);
if (num_video != 1) {
av_log(s, AV_LOG_ERROR, ""number of video tracks %d is not 1\n"", num_video);
return AVERROR_PATCHWELCOME;
}
for (i = 0; i < num_video; i++) {
AVStream *st = avformat_new_stream(s, NULL);
int num, den;
if (!st)
return AVERROR(ENOMEM);
st->id = i;
st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;
st->codecpar->codec_id = AV_CODEC_ID_VP6;
off = avio_tell(pb);
off += ffio_read_varlen(pb);
avio_r8(pb);
avio_r8(pb);
num = avio_rl32(pb);
den = avio_rl32(pb);
avpriv_set_pts_info(st, 64, num, den);
st->nb_frames = avio_rl32(pb);
st->codecpar->width = avio_rl16(pb);
st->codecpar->height = avio_rl16(pb);
avio_r8(pb);
avio_rl32(pb);
avio_seek(pb, off, SEEK_SET);
}
off = avio_tell(pb);
off += ffio_read_varlen(pb);
avio_r8(pb);
viv->num_audio = avio_r8(pb);
avio_seek(pb, off, SEEK_SET);
if (viv->num_audio != 1)
av_log(s, AV_LOG_WARNING, ""number of audio tracks %d is not 1\n"", viv->num_audio);
for(i=0;i<viv->num_audio;i++) {
int q;
AVStream *st = avformat_new_stream(s, NULL);
if (!st)
return AVERROR(ENOMEM);
st->id = num_video + i;
st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;
st->codecpar->codec_id = AV_CODEC_ID_VORBIS;
off = avio_tell(pb);
off += ffio_read_varlen(pb);
avio_r8(pb);
avio_r8(pb);
avio_rl16(pb);
st->codecpar->channels = avio_rl16(pb);
st->codecpar->sample_rate = avio_rl32(pb);
avio_seek(pb, 10, SEEK_CUR);
q = avio_r8(pb);
avio_seek(pb, q, SEEK_CUR);
avio_r8(pb);
if (avio_tell(pb) < off) {
int num_data;
int xd_size = 0;
int data_len[256];
int offset = 1;
uint8_t *p;
ffio_read_varlen(pb);
avio_r8(pb);
ffio_read_varlen(pb);
num_data = avio_r8(pb);
for (j = 0; j < num_data; j++) {
uint64_t len = ffio_read_varlen(pb);
if (len > INT_MAX/2 - xd_size) {
return AVERROR_INVALIDDATA;
}
data_len[j] = len;
xd_size += len;
}
ret = ff_alloc_extradata(st->codecpar, 64 + xd_size + xd_size / 255);
if (ret < 0)
return ret;
p = st->codecpar->extradata;
p[0] = 2;
for (j = 0; j < num_data - 1; j++) {
unsigned delta = av_xiphlacing(&p[offset], data_len[j]);
if (delta > data_len[j]) {
return AVERROR_INVALIDDATA;
}
offset += delta;
}
for (j = 0; j < num_data; j++) {
int ret = avio_read(pb, &p[offset], data_len[j]);
if (ret < data_len[j]) {
st->codecpar->extradata_size = 0;
av_freep(&st->codecpar->extradata);
break;
}
offset += data_len[j];
}
if (offset < st->codecpar->extradata_size)
st->codecpar->extradata_size = offset;
}
}
return 0;
}","[83, 97, 99, 106, 107, 118]",track_header in libavformat/vividas.c in FFmpeg 4.3.1 has an out-of-bounds write because of incorrect extradata packing.,FFmpeg,CVE-2020-35964,CWE-787
8573,7960,"static s32 gf_avc_read_pps_bs_internal(GF_BitStream *bs, AVCState *avc, u32 nal_hdr)
{
s32 pps_id;
AVC_PPS *pps;
gf_bs_enable_emulation_byte_removal(bs, GF_TRUE);
if (!nal_hdr) {
gf_bs_read_int_log(bs, 1, ""forbidden_zero_bit"");
gf_bs_read_int_log(bs, 2, ""nal_ref_idc"");
gf_bs_read_int_log(bs, 5, ""nal_unit_type"");
}
pps_id = gf_bs_read_ue_log(bs, ""pps_id"");
if (pps_id >= 255) {
return -1;
}
pps = &avc->pps[pps_id];
pps->id = pps_id;
if (!pps->status) pps->status = 1;
pps->sps_id = gf_bs_read_ue_log(bs, ""sps_id"");
if (pps->sps_id >= 32) {
pps->sps_id = 0;
return -1;
}
if (!avc->sps[pps->sps_id].state && !avc->sps[pps->sps_id + GF_SVC_SSPS_ID_SHIFT].state) {
return -1;
}
avc->pps_active_idx = pps->id;
avc->sps_active_idx = pps->sps_id;
pps->entropy_coding_mode_flag = gf_bs_read_int_log(bs, 1, ""entropy_coding_mode_flag"");
pps->pic_order_present = gf_bs_read_int_log(bs, 1, ""pic_order_present"");
pps->slice_group_count = gf_bs_read_ue_log(bs, ""slice_group_count_minus1"") + 1;
if (pps->slice_group_count > 1) {
u32 iGroup;
pps->mb_slice_group_map_type = gf_bs_read_ue_log(bs, ""mb_slice_group_map_type"");
if (pps->mb_slice_group_map_type == 0) {
for (iGroup = 0; iGroup <= pps->slice_group_count - 1; iGroup++)
gf_bs_read_ue_log_idx(bs, ""run_length_minus1"", iGroup);
}
else if (pps->mb_slice_group_map_type == 2) {
for (iGroup = 0; iGroup < pps->slice_group_count - 1; iGroup++) {
gf_bs_read_ue_log_idx(bs, ""top_left"", iGroup);
gf_bs_read_ue_log_idx(bs, ""bottom_right"", iGroup);
}
}
else if (pps->mb_slice_group_map_type == 3 || pps->mb_slice_group_map_type == 4 || pps->mb_slice_group_map_type == 5) {
gf_bs_read_int_log(bs, 1, ""slice_group_change_direction_flag"");
gf_bs_read_ue_log(bs, ""slice_group_change_rate_minus1"");
}
else if (pps->mb_slice_group_map_type == 6) {
u32 i;
pps->pic_size_in_map_units_minus1 = gf_bs_read_ue_log(bs, ""pic_size_in_map_units_minus1"");
for (i = 0; i <= pps->pic_size_in_map_units_minus1; i++) {
gf_bs_read_int_log_idx(bs, (u32)ceil(log(pps->slice_group_count) / log(2)), ""slice_group_id"", i);
}
}
}
pps->num_ref_idx_l0_default_active_minus1 = gf_bs_read_ue_log(bs, ""num_ref_idx_l0_default_active_minus1"");
pps->num_ref_idx_l1_default_active_minus1 = gf_bs_read_ue_log(bs, ""num_ref_idx_l1_default_active_minus1"");
pps->weighted_pred_flag = gf_bs_read_int_log(bs, 1, ""weighted_pred_flag"");
gf_bs_read_int_log(bs, 2, ""weighted_bipred_idc"");
gf_bs_read_se_log(bs, ""init_qp_minus26"");
gf_bs_read_se_log(bs, ""init_qs_minus26"");
gf_bs_read_se_log(bs, ""chroma_qp_index_offset"");
pps->deblocking_filter_control_present_flag = gf_bs_read_int_log(bs, 1, ""deblocking_filter_control_present_flag"");
gf_bs_read_int_log(bs, 1, ""constrained_intra_pred"");
pps->redundant_pic_cnt_present = gf_bs_read_int_log(bs, 1, ""redundant_pic_cnt_present"");
return pps_id;
}","[12, 19]",There is a integer overflow in media_tools/av_parsers.c in the hevc_parse_slice_segment function in GPAC 1.0.1 which results in a crash.,gpac,CVE-2021-30014,CWE-190
8583,6237,"exif_data_load_data_thumbnail (ExifData *data, const unsigned char *d,
unsigned int ds, ExifLong o, ExifLong s)
{
if ((o + s < o) || (o + s < s) || (o + s > ds) || (o > ds)) {
exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, ""ExifData"",
""Bogus thumbnail offset (%u) or size (%u)."",
o, s);
return;
}
if (data->data)
exif_mem_free (data->priv->mem, data->data);
if (!(data->data = exif_data_alloc (data, s))) {
EXIF_LOG_NO_MEMORY (data->priv->log, ""ExifData"", s);
data->size = 0;
return;
}
data->size = s;
memcpy (data->data, d + o, s);
}","[4, 5, 6, 7]","In libexif, there is a possible out of bounds write due to an integer overflow. This could lead to remote escalation of privilege in the media content provider with no additional execution privileges needed. User interaction is needed for exploitation. Product: AndroidVersions: Android-10Android ID: A-112537774",libexif,CVE-2019-9278,CWE-190
8586,7401,"static int tcos_decipher(sc_card_t *card, const u8 * crgram, size_t crgram_len, u8 * out, size_t outlen)
{
sc_context_t *ctx;
sc_apdu_t apdu;
u8 rbuf[SC_MAX_APDU_BUFFER_SIZE];
u8 sbuf[SC_MAX_APDU_BUFFER_SIZE];
tcos_data *data;
int tcos3, r;
assert(card != NULL && crgram != NULL && out != NULL);
ctx = card->ctx;
tcos3=(card->type==SC_CARD_TYPE_TCOS_V3);
data=(tcos_data *)card->drv_data;
LOG_FUNC_CALLED(ctx);
sc_log(ctx,
""TCOS3:%d PKCS1:%d\n"",tcos3,
!!(data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1));
sc_format_apdu(card, &apdu, crgram_len>255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT, 0x2A, 0x80, 0x86);
apdu.resp = rbuf;
apdu.resplen = sizeof(rbuf);
apdu.le = crgram_len;
apdu.data = sbuf;
apdu.lc = apdu.datalen = crgram_len+1;
sbuf[0] = tcos3 ? 0x00 : ((data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1) ? 0x81 : 0x02);
memcpy(sbuf+1, crgram, crgram_len);
r = sc_transmit_apdu(card, &apdu);
LOG_TEST_RET(card->ctx, r, ""APDU transmit failed"");
if (apdu.sw1==0x90 && apdu.sw2==0x00) {
size_t len= (apdu.resplen>outlen) ? outlen : apdu.resplen;
unsigned int offset=0;
if(tcos3 && (data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1) && apdu.resp[0]==0 && apdu.resp[1]==2) {
offset=2; while(offset<len && apdu.resp[offset]!=0) ++offset;
offset=(offset<len-1) ? offset+1 : 0;
}
memcpy(out, apdu.resp+offset, len-offset);
SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, len-offset);
}
SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, sc_check_sw(card, apdu.sw1, apdu.sw2));
}",[24],The TCOS smart card software driver in OpenSC before 0.21.0-rc1 has a stack-based buffer overflow in tcos_decipher.,OpenSC,CVE-2020-26572,CWE-787
8588,7464,"PackLinuxElf32::invert_pt_dynamic(Elf32_Dyn const *dynp)
{
if (dt_table[Elf32_Dyn::DT_NULL]) {
return;
}
Elf32_Dyn const *const dynp0 = dynp;
unsigned ndx = 1+ 0;
if (dynp)
for (; ; ++ndx, ++dynp) {
unsigned const d_tag = get_te32(&dynp->d_tag);
if (d_tag < DT_NUM) {
if (Elf32_Dyn::DT_NEEDED != d_tag
&&  dt_table[d_tag]
&&    get_te32(&dynp->d_val)
!= get_te32(&dynp0[-1+ dt_table[d_tag]].d_val)) {
char msg[50]; snprintf(msg, sizeof(msg),
""duplicate DT_%#x: [%#x] [%#x]"",
d_tag, -1+ dt_table[d_tag], -1+ ndx);
throwCantPack(msg);
}
dt_table[d_tag] = ndx;
}
if (Elf32_Dyn::DT_NULL == d_tag) {
break;
}
}
upx_dt_init = 0;
if (dt_table[Elf32_Dyn::DT_INIT])          upx_dt_init = Elf32_Dyn::DT_INIT;
else if (dt_table[Elf32_Dyn::DT_PREINIT_ARRAY]) upx_dt_init = Elf32_Dyn::DT_PREINIT_ARRAY;
else if (dt_table[Elf32_Dyn::DT_INIT_ARRAY])    upx_dt_init = Elf32_Dyn::DT_INIT_ARRAY;
unsigned const z_str = dt_table[Elf32_Dyn::DT_STRSZ];
if (z_str) {
strtab_end = get_te32(&dynp0[-1+ z_str].d_val);
if ((u32_t)file_size <= strtab_end) {
char msg[50]; snprintf(msg, sizeof(msg),
""bad DT_STRSZ %#x"", strtab_end);
throwCantPack(msg);
}
}
unsigned const x_sym = dt_table[Elf32_Dyn::DT_SYMTAB];
unsigned const x_str = dt_table[Elf32_Dyn::DT_STRTAB];
if (x_sym && x_str) {
upx_uint32_t const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);
upx_uint32_t const v_str = get_te32(&dynp0[-1+ x_str].d_val);
unsigned const  z_sym = dt_table[Elf32_Dyn::DT_SYMENT];
unsigned const sz_sym = !z_sym ? sizeof(Elf32_Sym)
: get_te32(&dynp0[-1+ z_sym].d_val);
if (sz_sym < sizeof(Elf32_Sym)) {
char msg[50]; snprintf(msg, sizeof(msg),
""bad DT_SYMENT %x"", sz_sym);
throwCantPack(msg);
}
if (v_sym < v_str) {
symnum_end = (v_str - v_sym) / sz_sym;
}
if (symnum_end < 1) {
throwCantPack(""bad DT_SYMTAB"");
}
}
unsigned const v_hsh = elf_unsigned_dynamic(Elf32_Dyn::DT_HASH);
if (v_hsh && file_image) {
hashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_HASH);
if (!hashtab) {
char msg[40]; snprintf(msg, sizeof(msg),
""bad DT_HASH %#x"", v_hsh);
throwCantPack(msg);
}
unsigned const nbucket = get_te32(&hashtab[0]);
unsigned const *const buckets = &hashtab[2];
unsigned const *const chains = &buckets[nbucket]; (void)chains;
unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);
if (!nbucket
|| (nbucket>>31) || (file_size/sizeof(unsigned)) <= (2*nbucket)
|| ((v_hsh < v_sym) && (v_sym - v_hsh) < (sizeof(unsigned)*2
+ sizeof(*buckets)*nbucket
+ sizeof(*chains) *nbucket
))
) {
char msg[90]; snprintf(msg, sizeof(msg),
""bad DT_HASH nbucket=%#x  len=%#x"",
nbucket, (v_sym - v_hsh));
throwCantPack(msg);
}
}
unsigned const v_gsh = elf_unsigned_dynamic(Elf32_Dyn::DT_GNU_HASH);
if (v_gsh && file_image) {
gashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_GNU_HASH);
if (!gashtab) {
char msg[40]; snprintf(msg, sizeof(msg),
""bad DT_GNU_HASH %#x"", v_gsh);
throwCantPack(msg);
}
unsigned const n_bucket = get_te32(&gashtab[0]);
unsigned const n_bitmask = get_te32(&gashtab[2]);
unsigned const gnu_shift = get_te32(&gashtab[3]);
unsigned const *const bitmask = (unsigned const *)(void const *)&gashtab[4];
unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask];
unsigned     const *const hasharr = &buckets[n_bucket]; (void)hasharr;
unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);
if (!n_bucket || !n_bitmask
|| (-1+ n_bitmask) & n_bitmask
|| 8*sizeof(unsigned) <= gnu_shift
|| (n_bucket>>30)
|| (n_bitmask>>30)
|| (file_size / sizeof(unsigned)) <= (n_bitmask + 2*n_bucket)
|| ((v_gsh < v_sym) && (v_sym - v_gsh) < (sizeof(unsigned)*4
+ sizeof(*bitmask)*n_bitmask
+ sizeof(*buckets)*n_bucket
+ sizeof(*hasharr)*n_bucket
))
) {
char msg[90]; snprintf(msg, sizeof(msg),
""bad DT_GNU_HASH n_bucket=%#x  n_bitmask=%#x  len=%#x"",
n_bucket, n_bitmask, v_sym - v_gsh);
throwCantPack(msg);
}
}
unsigned const e_shstrndx = get_te16(&ehdri.e_shstrndx);
if (e_shnum <= e_shstrndx
&&  !(0==e_shnum && 0==e_shstrndx) ) {
char msg[40]; snprintf(msg, sizeof(msg),
""bad .e_shstrndx %d >= .e_shnum %d"", e_shstrndx, e_shnum);
throwCantPack(msg);
}
}","[71, 72, 99, 100]",A Segmentaation fault was found in UPX in invert_pt_dynamic() function in p_lx_elf.cpp. An attacker with a crafted input file allows invalid memory address access that could lead to a denial of service.,upx,CVE-2020-27787,NVD-CWE-noinfo
8600,7400,"sc_oberthur_read_file(struct sc_pkcs15_card *p15card, const char *in_path,
unsigned char **out, size_t *out_len,
int verify_pin)
{
struct sc_context *ctx = p15card->card->ctx;
struct sc_card *card = p15card->card;
struct sc_file *file = NULL;
struct sc_path path;
size_t sz;
int rv;
LOG_FUNC_CALLED(ctx);
if (!in_path || !out || !out_len)
LOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, ""Cannot read oberthur file"");
sc_log(ctx, ""read file '%s'; verify_pin:%i"", in_path, verify_pin);
*out = NULL;
*out_len = 0;
sc_format_path(in_path, &path);
rv = sc_select_file(card, &path, &file);
if (rv != SC_SUCCESS) {
sc_file_free(file);
LOG_TEST_RET(ctx, rv, ""Cannot select oberthur file to read"");
}
if (file->ef_structure == SC_FILE_EF_TRANSPARENT)
sz = file->size;
else
sz = (file->record_length + 2) * file->record_count;
*out = calloc(sz, 1);
if (*out == NULL) {
sc_file_free(file);
LOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, ""Cannot read oberthur file"");
}
if (file->ef_structure == SC_FILE_EF_TRANSPARENT)   {
rv = sc_read_binary(card, 0, *out, sz, 0);
}
else {
int rec;
int offs = 0;
int rec_len = file->record_length;
for (rec = 1; ; rec++)   {
rv = sc_read_record(card, rec, *out + offs + 2, rec_len, SC_RECORD_BY_REC_NR);
if (rv == SC_ERROR_RECORD_NOT_FOUND)   {
rv = 0;
break;
}
else if (rv < 0)   {
break;
}
rec_len = rv;
*(*out + offs) = 'R';
*(*out + offs + 1) = rv;
offs += rv + 2;
}
sz = offs;
}
sc_log(ctx, ""read oberthur file result %i"", rv);
if (verify_pin && rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)   {
struct sc_pkcs15_object *objs[0x10], *pin_obj = NULL;
const struct sc_acl_entry *acl = sc_file_get_acl_entry(file, SC_AC_OP_READ);
int ii;
rv = sc_pkcs15_get_objects(p15card, SC_PKCS15_TYPE_AUTH_PIN, objs, 0x10);
if (rv != SC_SUCCESS) {
sc_file_free(file);
LOG_TEST_RET(ctx, rv, ""Cannot read oberthur file: get AUTH objects error"");
}
for (ii=0; ii<rv; ii++)   {
struct sc_pkcs15_auth_info *auth_info = (struct sc_pkcs15_auth_info *) objs[ii]->data;
sc_log(ctx, ""compare PIN/ACL refs:%i/%i, method:%i/%i"",
auth_info->attrs.pin.reference, acl->key_ref, auth_info->auth_method, acl->method);
if (auth_info->attrs.pin.reference == (int)acl->key_ref && auth_info->auth_method == (unsigned)acl->method)   {
pin_obj = objs[ii];
break;
}
}
if (!pin_obj || !pin_obj->content.value)    {
rv = SC_ERROR_SECURITY_STATUS_NOT_SATISFIED;
}
else    {
rv = sc_pkcs15_verify_pin(p15card, pin_obj, pin_obj->content.value, pin_obj->content.len);
if (!rv)
rv = sc_oberthur_read_file(p15card, in_path, out, out_len, 0);
}
};
sc_file_free(file);
if (rv < 0)   {
free(*out);
*out = NULL;
*out_len = 0;
}
*out_len = sz;
LOG_FUNC_RETURN(ctx, rv);
}","[36, 37, 38, 40]",The Oberthur smart card software driver in OpenSC before 0.21.0-rc1 has a heap-based buffer overflow in sc_oberthur_read_file.,OpenSC,CVE-2020-26570,CWE-787
8611,7548,"int flb_gzip_compress(void *in_data, size_t in_len,
void **out_data, size_t *out_len)
{
int flush;
int status;
int footer_start;
uint8_t *pb;
size_t out_size;
void *out_buf;
z_stream strm;
mz_ulong crc;
out_size = in_len + 32;
out_buf = flb_malloc(out_size);
if (!out_buf) {
flb_errno();
flb_error(""[gzip] could not allocate outgoing buffer"");
return -1;
}
memset(&strm, '\0', sizeof(strm));
strm.zalloc    = Z_NULL;
strm.zfree     = Z_NULL;
strm.opaque    = Z_NULL;
strm.next_in   = in_data;
strm.avail_in  = in_len;
strm.total_out = 0;
deflateInit2(&strm, Z_DEFAULT_COMPRESSION,
Z_DEFLATED, -Z_DEFAULT_WINDOW_BITS, 9, Z_DEFAULT_STRATEGY);
gzip_header(out_buf);
pb = (uint8_t *) out_buf + FLB_GZIP_HEADER_OFFSET;
flush = Z_NO_FLUSH;
while (1) {
strm.next_out  = pb + strm.total_out;
strm.avail_out = out_size - (pb - (uint8_t *) out_buf);
if (strm.avail_in == 0) {
flush = Z_FINISH;
}
status = deflate(&strm, flush);
if (status == Z_STREAM_END) {
break;
}
else if (status != Z_OK) {
deflateEnd(&strm);
return -1;
}
}
if (deflateEnd(&strm) != Z_OK) {
flb_free(out_buf);
return -1;
}
*out_len = strm.total_out;
footer_start = FLB_GZIP_HEADER_OFFSET + *out_len;
pb = (uint8_t *) out_buf + footer_start;
crc = mz_crc32(MZ_CRC32_INIT, in_data, in_len);
*pb++ = crc & 0xFF;
*pb++ = (crc >> 8) & 0xFF;
*pb++ = (crc >> 16) & 0xFF;
*pb++ = (crc >> 24) & 0xFF;
*pb++ = in_len & 0xFF;
*pb++ = (in_len >> 8) & 0xFF;
*pb++ = (in_len >> 16) & 0xFF;
*pb++ = (in_len >> 24) & 0xFF;
*out_len += FLB_GZIP_HEADER_OFFSET + 8;
*out_data = out_buf;
return 0;
}","[12, 14]",flb_gzip_compress in flb_gzip.c in Fluent Bit before 1.6.4 has an out-of-bounds write because it does not use the correct calculation of the maximum gzip data-size expansion.,fluent-bit,CVE-2020-35963,CWE-787
8612,4746,"sec_decrypt(uint8 * data, int length)
{
if (g_sec_decrypt_use_count == 4096)
{
sec_update(g_sec_decrypt_key, g_sec_decrypt_update_key);
rdssl_rc4_set_key(&g_rc4_decrypt_key, g_sec_decrypt_key, g_rc4_key_len);
g_sec_decrypt_use_count = 0;
}
rdssl_rc4_crypt(&g_rc4_decrypt_key, data, data, length);
g_sec_decrypt_use_count++;
}",[3],rdesktop versions up to and including v1.8.3 contain an Out-Of-Bounds Read in the function ui_clip_handle_data() that results in an information leak.,rdesktop,CVE-2018-20174,CWE-125
8621,8130,"static GF_Err gf_isom_parse_movie_boxes_internal(GF_ISOFile *mov, u32 *boxType, u64 *bytesMissing, Bool progressive_mode)
{
GF_Box *a;
u64 totSize, mdat_end=0;
GF_Err e = GF_OK;
#ifndef	GPAC_DISABLE_ISOM_FRAGMENTS
if (mov->single_moof_mode && mov->single_moof_state == 2) {
return e;
}
totSize = mov->current_top_box_start;
if (mov->bytes_removed) {
assert(totSize >= mov->bytes_removed);
totSize -= mov->bytes_removed;
}
gf_bs_seek(mov->movieFileMap->bs, totSize);
#endif
while (gf_bs_available(mov->movieFileMap->bs)) {
*bytesMissing = 0;
#ifndef	GPAC_DISABLE_ISOM_FRAGMENTS
mov->current_top_box_start = gf_bs_get_position(mov->movieFileMap->bs) + mov->bytes_removed;
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Parsing a top-level box at position %d\n"", mov->current_top_box_start));
#endif
e = gf_isom_parse_root_box(&a, mov->movieFileMap->bs, boxType, bytesMissing, progressive_mode);
if (e >= 0) {
} else if (e == GF_ISOM_INCOMPLETE_FILE) {
if (mov->openMode != GF_ISOM_OPEN_READ) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Incomplete MDAT while file is not read-only\n""));
return GF_ISOM_INVALID_FILE;
}
if ((mov->openMode == GF_ISOM_OPEN_READ) && !progressive_mode) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Incomplete file while reading for dump - aborting parsing\n""));
break;
}
return e;
} else {
return e;
}
switch (a->type) {
case GF_ISOM_BOX_TYPE_MOOV:
if (mov->moov) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Duplicate MOOV detected!\n""));
gf_isom_box_del(a);
return GF_ISOM_INVALID_FILE;
}
mov->moov = (GF_MovieBox *)a;
mov->original_moov_offset = mov->current_top_box_start;
mov->moov->mov = mov;
#ifndef GPAC_DISABLE_ISOM_FRAGMENTS
if (mov->moov->mvex) mov->moov->mvex->mov = mov;
#ifdef GF_ENABLE_CTRN
if (! (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {
gf_isom_setup_traf_inheritance(mov);
}
#endif
#endif
e = gf_list_add(mov->TopBoxes, a);
if (e) return e;
totSize += a->size;
if (!mov->moov->mvhd) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Missing MovieHeaderBox\n""));
return GF_ISOM_INVALID_FILE;
}
if (mov->meta) {
gf_isom_meta_restore_items_ref(mov, mov->meta);
}
if (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {
u32 k;
for (k=0; k<gf_list_count(mov->moov->trackList); k++) {
GF_TrackBox *trak = (GF_TrackBox *)gf_list_get(mov->moov->trackList, k);
if (trak->sample_encryption) {
e = senc_Parse(mov->movieFileMap->bs, trak, NULL, trak->sample_encryption);
if (e) return e;
}
}
} else {
u32 k;
for (k=0; k<gf_list_count(mov->moov->trackList); k++) {
GF_TrackBox *trak = (GF_TrackBox *)gf_list_get(mov->moov->trackList, k);
if (trak->Media->information->sampleTable->sampleGroups) {
convert_compact_sample_groups(trak->Media->information->sampleTable->child_boxes, trak->Media->information->sampleTable->sampleGroups);
}
}
}
if (mdat_end && mov->signal_frag_bounds && !(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) ) {
gf_isom_push_mdat_end(mov, mdat_end);
mdat_end=0;
}
break;
case GF_ISOM_BOX_TYPE_META:
if (mov->meta) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Duplicate META detected!\n""));
gf_isom_box_del(a);
return GF_ISOM_INVALID_FILE;
}
mov->meta = (GF_MetaBox *)a;
mov->original_meta_offset = mov->current_top_box_start;
e = gf_list_add(mov->TopBoxes, a);
if (e) {
return e;
}
totSize += a->size;
if (mov->moov) {
gf_isom_meta_restore_items_ref(mov, mov->meta);
}
break;
case GF_ISOM_BOX_TYPE_MDAT:
if (!mov->first_data_toplevel_offset) {
mov->first_data_toplevel_offset = mov->current_top_box_start;
mov->first_data_toplevel_size = a->size;
}
totSize += a->size;
if (mov->openMode == GF_ISOM_OPEN_READ) {
if (!mov->mdat) {
mov->mdat = (GF_MediaDataBox *) a;
e = gf_list_add(mov->TopBoxes, mov->mdat);
if (e) {
return e;
}
}
#ifndef	GPAC_DISABLE_ISOM_FRAGMENTS
else if (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) gf_list_add(mov->TopBoxes, a);
#endif
else gf_isom_box_del(a);
if (mov->signal_frag_bounds && !(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) ) {
mdat_end = gf_bs_get_position(mov->movieFileMap->bs);
if (mov->moov) {
gf_isom_push_mdat_end(mov, mdat_end);
mdat_end=0;
}
}
}
else if (!mov->mdat && (mov->openMode != GF_ISOM_OPEN_READ) && (mov->openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS)) {
gf_isom_box_del(a);
mov->mdat = (GF_MediaDataBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MDAT);
if (!mov->mdat) return GF_OUT_OF_MEM;
e = gf_list_add(mov->TopBoxes, mov->mdat);
if (e) {
return e;
}
} else {
gf_isom_box_del(a);
}
break;
case GF_ISOM_BOX_TYPE_FTYP:
if (mov->brand) {
gf_isom_box_del(a);
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Duplicate 'ftyp' detected!\n""));
return GF_ISOM_INVALID_FILE;
}
mov->brand = (GF_FileTypeBox *)a;
totSize += a->size;
e = gf_list_add(mov->TopBoxes, a);
if (e) return e;
break;
case GF_ISOM_BOX_TYPE_OTYP:
if (mov->otyp) {
gf_isom_box_del(a);
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Duplicate 'otyp' detected!\n""));
return GF_ISOM_INVALID_FILE;
}
if (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {
mov->otyp = (GF_Box *)a;
totSize += a->size;
e = gf_list_add(mov->TopBoxes, a);
if (e) return e;
} else {
GF_FileTypeBox *brand = (GF_FileTypeBox *) gf_isom_box_find_child(a->child_boxes, GF_ISOM_BOX_TYPE_FTYP);
if (brand) {
s32 pos;
gf_list_del_item(a->child_boxes, brand);
pos = gf_list_del_item(mov->TopBoxes, mov->brand);
gf_isom_box_del((GF_Box *) mov->brand);
mov->brand = brand;
if (pos<0) pos=0;
gf_list_insert(mov->TopBoxes, brand, pos);
}
}
break;
case GF_ISOM_BOX_TYPE_PDIN:
if (mov->pdin) {
gf_isom_box_del(a);
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Duplicate 'pdin'' detected!\n""));
return GF_ISOM_INVALID_FILE;
}
mov->pdin = (GF_ProgressiveDownloadBox *) a;
totSize += a->size;
e = gf_list_add(mov->TopBoxes, a);
if (e) return e;
break;
#ifndef	GPAC_DISABLE_ISOM_FRAGMENTS
case GF_ISOM_BOX_TYPE_STYP:
{
u32 brand = ((GF_FileTypeBox *)a)->majorBrand;
switch (brand) {
case GF_ISOM_BRAND_SISX:
case GF_ISOM_BRAND_RISX:
case GF_ISOM_BRAND_SSSS:
mov->is_index_segment = GF_TRUE;
break;
default:
break;
}
}
case GF_ISOM_BOX_TYPE_SIDX:
case GF_ISOM_BOX_TYPE_SSIX:
if (mov->moov && !mov->first_data_toplevel_offset) {
mov->first_data_toplevel_offset = mov->current_top_box_start;
mov->first_data_toplevel_size = a->size;
}
totSize += a->size;
if (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {
e = gf_list_add(mov->TopBoxes, a);
if (e) return e;
} else if (mov->signal_frag_bounds && !(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)  && (mov->openMode!=GF_ISOM_OPEN_KEEP_FRAGMENTS)
) {
if (a->type==GF_ISOM_BOX_TYPE_SIDX) {
if (mov->root_sidx) gf_isom_box_del( (GF_Box *) mov->root_sidx);
mov->root_sidx = (GF_SegmentIndexBox *) a;
mov->sidx_start_offset = mov->current_top_box_start;
mov->sidx_end_offset = gf_bs_get_position(mov->movieFileMap->bs);
}
else if (a->type==GF_ISOM_BOX_TYPE_STYP) {
mov->styp_start_offset = mov->current_top_box_start;
if (mov->seg_styp) gf_isom_box_del(mov->seg_styp);
mov->seg_styp = a;
} else if (a->type==GF_ISOM_BOX_TYPE_SSIX) {
if (mov->seg_ssix) gf_isom_box_del(mov->seg_ssix);
mov->seg_ssix = a;
} else {
gf_isom_box_del(a);
}
gf_isom_push_mdat_end(mov, mov->current_top_box_start);
} else if (!mov->NextMoofNumber && (a->type==GF_ISOM_BOX_TYPE_SIDX)) {
if (mov->main_sidx) gf_isom_box_del( (GF_Box *) mov->main_sidx);
mov->main_sidx = (GF_SegmentIndexBox *) a;
mov->main_sidx_end_pos = mov->current_top_box_start + a->size;
} else {
gf_isom_box_del(a);
}
break;
case GF_ISOM_BOX_TYPE_MOOF:
gf_isom_disable_inplace_rewrite(mov);
if (!mov->moov) {
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] Movie fragment but no moov (yet) - possibly broken parsing!\n""));
}
if (mov->single_moof_mode) {
mov->single_moof_state++;
if (mov->single_moof_state > 1) {
gf_isom_box_del(a);
return GF_OK;
}
}
((GF_MovieFragmentBox *)a)->mov = mov;
totSize += a->size;
mov->moof = (GF_MovieFragmentBox *) a;
FixTrackID(mov);
if (! (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {
FixSDTPInTRAF(mov->moof);
} else {
u32 k;
for (k=0; k<gf_list_count(mov->moof->TrackList); k++) {
GF_TrackFragmentBox *traf = (GF_TrackFragmentBox *)gf_list_get(mov->moof->TrackList, k);
if (traf->sampleGroups) {
convert_compact_sample_groups(traf->child_boxes, traf->sampleGroups);
}
}
}
if (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {
u32 k;
gf_list_add(mov->TopBoxes, a);
if (mov->moov) {
for (k=0; k<gf_list_count(mov->moof->TrackList); k++) {
GF_TrackFragmentBox *traf = gf_list_get(mov->moof->TrackList, k);
if (traf->tfhd && mov->moov->mvex && mov->moov->mvex->TrackExList) {
GF_TrackBox *trak = gf_isom_get_track_from_id(mov->moov, traf->tfhd->trackID);
u32 j=0;
while ((traf->trex = (GF_TrackExtendsBox*)gf_list_enum(mov->moov->mvex->TrackExList, &j))) {
if (traf->trex->trackID == traf->tfhd->trackID) {
if (!traf->trex->track) traf->trex->track = trak;
break;
}
traf->trex = NULL;
}
}
if (traf->trex && traf->tfhd && traf->trex->track && traf->sample_encryption) {
GF_TrackBox *trak = GetTrackbyID(mov->moov, traf->tfhd->trackID);
trak->current_traf_stsd_idx = traf->tfhd->sample_desc_index ? traf->tfhd->sample_desc_index : traf->trex->def_sample_desc_index;
e = senc_Parse(mov->movieFileMap->bs, trak, traf, traf->sample_encryption);
if (e) return e;
trak->current_traf_stsd_idx = 0;
}
}
} else {
for (k=0; k<gf_list_count(mov->moof->TrackList); k++) {
GF_TrackFragmentBox *traf = gf_list_get(mov->moof->TrackList, k);
if (traf->sample_encryption) {
e = senc_Parse(mov->movieFileMap->bs, NULL, traf, traf->sample_encryption);
if (e) return e;
}
}
}
} else if (mov->openMode==GF_ISOM_OPEN_KEEP_FRAGMENTS) {
mov->NextMoofNumber = mov->moof->mfhd->sequence_number+1;
mov->moof = NULL;
gf_isom_box_del(a);
} else {
e = MergeFragment((GF_MovieFragmentBox *)a, mov);
gf_isom_box_del(a);
if (e) return e;
}
if (mov->root_sidx) {
gf_isom_box_del((GF_Box *) mov->root_sidx);
mov->root_sidx = NULL;
}
if (mov->root_ssix) {
gf_isom_box_del(mov->seg_ssix);
mov->root_ssix = NULL;
}
if (mov->seg_styp) {
gf_isom_box_del(mov->seg_styp);
mov->seg_styp = NULL;
}
mov->sidx_start_offset = 0;
mov->sidx_end_offset = 0;
mov->styp_start_offset = 0;
break;
#endif
case GF_ISOM_BOX_TYPE_UNKNOWN:
{
GF_UnknownBox *box = (GF_UnknownBox*)a;
if (box->original_4cc == GF_ISOM_BOX_TYPE_JP) {
u8 *c = (u8 *) box->data;
if ((box->dataSize==4) && (GF_4CC(c[0],c[1],c[2],c[3])==(u32)0x0D0A870A))
mov->is_jp2 = 1;
gf_isom_box_del(a);
} else {
e = gf_list_add(mov->TopBoxes, a);
if (e) return e;
}
}
break;
case GF_ISOM_BOX_TYPE_PRFT:
#ifndef GPAC_DISABLE_ISOM_FRAGMENTS
if (!(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {
if (mov->last_producer_ref_time)
gf_isom_box_del(a);
else
mov->last_producer_ref_time = (GF_ProducerReferenceTimeBox *)a;
break;
}
#endif
default:
totSize += a->size;
e = gf_list_add(mov->TopBoxes, a);
if (e) return e;
break;
}
#ifndef	GPAC_DISABLE_ISOM_FRAGMENTS
mov->current_top_box_start = gf_bs_get_position(mov->movieFileMap->bs) + mov->bytes_removed;
#endif
}
if (!mov->moov && !mov->meta
#ifndef GPAC_DISABLE_ISOM_FRAGMENTS
&& !mov->moof && !mov->is_index_segment
#endif
) {
return GF_ISOM_INCOMPLETE_FILE;
}
if (!gf_opts_get_bool(""core"", ""no-check"")) {
if (mov->moov && !mov->moov->mvhd) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Missing MVHD in MOOV!\n""));
return GF_ISOM_INVALID_FILE;
}
if (mov->meta && !mov->meta->handler) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Missing handler in META!\n""));
return GF_ISOM_INVALID_FILE;
}
}
#ifndef GPAC_DISABLE_ISOM_WRITE
if (mov->moov) {
mov->interleavingTime = mov->moov->mvhd->timeScale;
#ifndef	GPAC_DISABLE_ISOM_FRAGMENTS
if ((mov->openMode > GF_ISOM_OPEN_READ) && (mov->openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS) && mov->moov->mvex) {
gf_isom_box_del_parent(&mov->moov->child_boxes, (GF_Box *)mov->moov->mvex);
mov->moov->mvex = NULL;
}
#endif
}
if (!mov->mdat && (mov->openMode != GF_ISOM_OPEN_READ) && (mov->openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS)) {
mov->mdat = (GF_MediaDataBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MDAT);
if (!mov->mdat) return GF_OUT_OF_MEM;
e = gf_list_add(mov->TopBoxes, mov->mdat);
if (e) return e;
}
#endif /*GPAC_DISABLE_ISOM_WRITE*/
return GF_OK;
}",[178],Memory leak in the def_parent_box_new function in MP4Box in GPAC 1.0.1 allows attackers to read memory via a crafted file.,gpac,CVE-2021-33364,CWE-401
8635,6086,"static ExprList *exprListAppendList(
Parse *pParse,
ExprList *pList,
ExprList *pAppend,
int bIntToNull
){
if( pAppend ){
int i;
int nInit = pList ? pList->nExpr : 0;
for(i=0; i<pAppend->nExpr; i++){
Expr *pDup = sqlite3ExprDup(pParse->db, pAppend->a[i].pExpr, 0);
if( bIntToNull && pDup && pDup->op==TK_INTEGER ){
pDup->op = TK_NULL;
pDup->flags &= ~(EP_IntValue|EP_IsTrue|EP_IsFalse);
}
pList = sqlite3ExprListAppend(pParse, pList, pDup);
if( pList ) pList->a[nInit+i].sortFlags = pAppend->a[i].sortFlags;
}
}
return pList;
}","[12, 16]",exprListAppendList in window.c in SQLite 3.30.1 allows attackers to trigger an invalid pointer dereference because constant integer values in ORDER BY clauses of window definitions are mishandled.,sqlite,CVE-2019-19880,CWE-476
8636,4312,"NO_INLINE JsVar *jspeStatement() {
#ifdef USE_DEBUGGER
if (execInfo.execute&EXEC_DEBUGGER_NEXT_LINE &&
lex->tk!=';' &&
JSP_SHOULD_EXECUTE) {
lex->tokenLastStart = jsvStringIteratorGetIndex(&lex->tokenStart.it)-1;
jsiDebuggerLoop();
}
#endif
if (lex->tk==LEX_ID ||
lex->tk==LEX_INT ||
lex->tk==LEX_FLOAT ||
lex->tk==LEX_STR ||
lex->tk==LEX_TEMPLATE_LITERAL ||
lex->tk==LEX_REGEX ||
lex->tk==LEX_R_NEW ||
lex->tk==LEX_R_NULL ||
lex->tk==LEX_R_UNDEFINED ||
lex->tk==LEX_R_TRUE ||
lex->tk==LEX_R_FALSE ||
lex->tk==LEX_R_THIS ||
lex->tk==LEX_R_DELETE ||
lex->tk==LEX_R_TYPEOF ||
lex->tk==LEX_R_VOID ||
lex->tk==LEX_R_SUPER ||
lex->tk==LEX_PLUSPLUS ||
lex->tk==LEX_MINUSMINUS ||
lex->tk=='!' ||
lex->tk=='-' ||
lex->tk=='+' ||
lex->tk=='~' ||
lex->tk=='[' ||
lex->tk=='(') {
return jspeExpression();
} else if (lex->tk=='{') {
jspeBlock();
return 0;
} else if (lex->tk==';') {
JSP_ASSERT_MATCH(';');
return 0;
} else if (lex->tk==LEX_R_VAR ||
lex->tk==LEX_R_LET ||
lex->tk==LEX_R_CONST) {
return jspeStatementVar();
} else if (lex->tk==LEX_R_IF) {
return jspeStatementIf();
} else if (lex->tk==LEX_R_DO) {
return jspeStatementDoOrWhile(false);
} else if (lex->tk==LEX_R_WHILE) {
return jspeStatementDoOrWhile(true);
} else if (lex->tk==LEX_R_FOR) {
return jspeStatementFor();
} else if (lex->tk==LEX_R_TRY) {
return jspeStatementTry();
} else if (lex->tk==LEX_R_RETURN) {
return jspeStatementReturn();
} else if (lex->tk==LEX_R_THROW) {
return jspeStatementThrow();
} else if (lex->tk==LEX_R_FUNCTION) {
return jspeStatementFunctionDecl(false              );
#ifndef SAVE_ON_FLASH
} else if (lex->tk==LEX_R_CLASS) {
return jspeStatementFunctionDecl(true           );
#endif
} else if (lex->tk==LEX_R_CONTINUE) {
JSP_ASSERT_MATCH(LEX_R_CONTINUE);
if (JSP_SHOULD_EXECUTE) {
if (!(execInfo.execute & EXEC_IN_LOOP))
jsExceptionHere(JSET_SYNTAXERROR, ""CONTINUE statement outside of FOR or WHILE loop"");
else
execInfo.execute = (execInfo.execute & (JsExecFlags)~EXEC_RUN_MASK) | EXEC_CONTINUE;
}
} else if (lex->tk==LEX_R_BREAK) {
JSP_ASSERT_MATCH(LEX_R_BREAK);
if (JSP_SHOULD_EXECUTE) {
if (!(execInfo.execute & (EXEC_IN_LOOP|EXEC_IN_SWITCH)))
jsExceptionHere(JSET_SYNTAXERROR, ""BREAK statement outside of SWITCH, FOR or WHILE loop"");
else
execInfo.execute = (execInfo.execute & (JsExecFlags)~EXEC_RUN_MASK) | EXEC_BREAK;
}
} else if (lex->tk==LEX_R_SWITCH) {
return jspeStatementSwitch();
} else if (lex->tk==LEX_R_DEBUGGER) {
JSP_ASSERT_MATCH(LEX_R_DEBUGGER);
#ifdef USE_DEBUGGER
if (JSP_SHOULD_EXECUTE)
jsiDebuggerLoop();
#endif
} else JSP_MATCH(LEX_EOF);
return 0;
}",[36],Espruino before 1.99 allows attackers to cause a denial of service (application crash) with a user crafted input file via a Buffer Overflow during syntax parsing because of a missing check for stack exhaustion with many '{' characters in jsparse.c.,Espruino,CVE-2018-11597,CWE-674
8642,6238,"exif_data_load_data (ExifData *data, const unsigned char *d_orig,
unsigned int ds)
{
unsigned int l;
ExifLong offset;
ExifShort n;
const unsigned char *d = d_orig;
unsigned int len, fullds;
if (!data || !data->priv || !d || !ds)
return;
exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, ""ExifData"",
""Parsing %i byte(s) EXIF data...\n"", ds);
if (ds < 6) {
LOG_TOO_SMALL;
return;
}
if (!memcmp (d, ExifHeader, 6)) {
exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, ""ExifData"",
""Found EXIF header at start."");
} else {
while (ds >= 3) {
while (ds && (d[0] == 0xff)) {
d++;
ds--;
}
if (ds && d[0] == JPEG_MARKER_SOI) {
d++;
ds--;
continue;
}
if (ds && d[0] == JPEG_MARKER_APP1)
break;
if (ds >= 3 && d[0] >= 0xe0 && d[0] <= 0xef) {
d++;
ds--;
l = (d[0] << 8) | d[1];
if (l > ds)
return;
d += l;
ds -= l;
continue;
}
exif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA,
""ExifData"", _(""EXIF marker not found.""));
return;
}
if (ds < 3) {
LOG_TOO_SMALL;
return;
}
d++;
ds--;
len = (d[0] << 8) | d[1];
exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, ""ExifData"",
""We have to deal with %i byte(s) of EXIF data."",
len);
d += 2;
ds -= 2;
}
if (ds < 6) {
LOG_TOO_SMALL;
return;
}
if (memcmp (d, ExifHeader, 6)) {
exif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA,
""ExifData"", _(""EXIF header not found.""));
return;
}
exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, ""ExifData"",
""Found EXIF header."");
if (ds < 14)
return;
fullds = ds;
if (ds > 0xfffe)
ds = 0xfffe;
if (!memcmp (d + 6, ""II"", 2))
data->priv->order = EXIF_BYTE_ORDER_INTEL;
else if (!memcmp (d + 6, ""MM"", 2))
data->priv->order = EXIF_BYTE_ORDER_MOTOROLA;
else {
exif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA,
""ExifData"", _(""Unknown encoding.""));
return;
}
if (exif_get_short (d + 8, data->priv->order) != 0x002a)
return;
offset = exif_get_long (d + 10, data->priv->order);
exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, ""ExifData"",
""IFD 0 at %i."", (int) offset);
if (offset > ds || offset + 6 + 2 > ds)
return;
exif_data_load_data_content (data, EXIF_IFD_0, d + 6, ds - 6, offset, 0);
n = exif_get_short (d + 6 + offset, data->priv->order);
if (offset + 6 + 2 + 12 * n + 4 > ds)
return;
offset = exif_get_long (d + 6 + offset + 2 + 12 * n, data->priv->order);
if (offset) {
exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, ""ExifData"",
""IFD 1 at %i."", (int) offset);
if (offset > ds || offset + 6 > ds) {
exif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA,
""ExifData"", ""Bogus offset of IFD1."");
} else {
exif_data_load_data_content (data, EXIF_IFD_1, d + 6, ds - 6, offset, 0);
}
}
interpret_maker_note(data, d, fullds);
if (data->priv->options & EXIF_DATA_OPTION_FOLLOW_SPECIFICATION)
exif_data_fix (data);
}","[94, 100]","In libexif, there is a possible out of bounds write due to an integer overflow. This could lead to remote escalation of privilege in the media content provider with no additional execution privileges needed. User interaction is needed for exploitation. Product: AndroidVersions: Android-10Android ID: A-112537774",libexif,CVE-2019-9278,CWE-190
8647,6077,"int sqlite3CheckObjectName(
Parse *pParse,
const char *zName,
const char *zType,
const char *zTblName
){
sqlite3 *db = pParse->db;
if( sqlite3WritableSchema(db) || db->init.imposterTable ){
return SQLITE_OK;
}
if( db->init.busy ){
if( sqlite3_stricmp(zType, db->init.azInit[0])
|| sqlite3_stricmp(zName, db->init.azInit[1])
|| sqlite3_stricmp(zTblName, db->init.azInit[2])
){
if( sqlite3Config.bExtraSchemaChecks ){
sqlite3ErrorMsg(pParse, """");
return SQLITE_ERROR;
}
}
}else{
if( pParse->nested==0
&& 0==sqlite3StrNICmp(zName, ""sqlite_"", 7)
){
sqlite3ErrorMsg(pParse, ""object name reserved for internal use: %s"",
zName);
return SQLITE_ERROR;
}
}
return SQLITE_OK;
}","[22, 23, 30]","SQLite 3.30.1 mishandles certain SELECT statements with a nonexistent VIEW, leading to an application crash.",sqlite,CVE-2019-19603,NVD-CWE-noinfo
4,179643," static void ikev2_parent_inI2outR2_continue(struct pluto_crypto_req_cont *pcrc,
 					    struct pluto_crypto_req *r,
 					    err_t ugh)
 {
 	struct dh_continuation *dh = (struct dh_continuation *)pcrc;
 	struct msg_digest *md = dh->md;
 	struct state *const st = md->st;
 	stf_status e;
 	DBG(DBG_CONTROLMORE,
 	    DBG_log(""ikev2 parent inI2outR2: calculating g^{xy}, sending R2""));
 	if (st == NULL) {
 		loglog(RC_LOG_SERIOUS,
 		       ""%s: Request was disconnected from state"",
 		       __FUNCTION__);
 		if (dh->md)
 			release_md(dh->md);
 		return;
 	}
 	passert(ugh == NULL);
 	passert(cur_state == NULL);
 	passert(st != NULL);
 	passert(st->st_suspended_md == dh->md);
 	set_suspended(st, NULL);  
 	set_cur_state(st);
 	st->st_calculating = FALSE;
 	e = ikev2_parent_inI2outR2_tail(pcrc, r);
 	if ( e > STF_FAIL) {
 		int v2_notify_num = e - STF_FAIL;
 		DBG_log(
 			""ikev2_parent_inI2outR2_tail returned STF_FAIL with %s"",
 			enum_name(&ikev2_notify_names, v2_notify_num));
 	} else if ( e != STF_OK) {
 		DBG_log(""ikev2_parent_inI2outR2_tail returned %s"",
 			enum_name(&stfstatus_name, e));
 	}
 	if (dh->md != NULL) {
 		complete_v2_state_transition(&dh->md, e);
 		if (dh->md)
  			release_md(dh->md);
  	}
  	reset_globals();
	passert(GLOBALS_ARE_RESET());
  }",[42],The ikev2parent_inI1outR1 function in pluto/ikev2_parent.c in libreswan before 3.7 allows remote attackers to cause a denial of service (restart) via an IKEv2 I1 notification without a KE payload.,libreswan,CVE-2013-7294,CWE-20
46,180618," zip_read_mac_metadata(struct archive_read *a, struct archive_entry *entry,
     struct zip_entry *rsrc)
 {
 	struct zip *zip = (struct zip *)a->format->data;
 	unsigned char *metadata, *mp;
 	int64_t offset = archive_filter_bytes(&a->archive, 0);
 	size_t remaining_bytes, metadata_bytes;
 	ssize_t hsize;
 	int ret = ARCHIVE_OK, eof;
  	switch(rsrc->compression) {
  	case 0:   
 		if (rsrc->uncompressed_size != rsrc->compressed_size) {
 			archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
 			    ""Malformed OS X metadata entry: inconsistent size"");
 			return (ARCHIVE_FATAL);
 		}
  #ifdef HAVE_ZLIB_H
  	case 8:  
  #endif
 		break;
 	default:  
 		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
 		    ""Unsupported ZIP compression method (%s)"",
 		    compression_name(rsrc->compression));
 		return (ARCHIVE_WARN);
 	}
 	if (rsrc->uncompressed_size > (4 * 1024 * 1024)) {
 		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
 		    ""Mac metadata is too large: %jd > 4M bytes"",
  		    (intmax_t)rsrc->uncompressed_size);
  		return (ARCHIVE_WARN);
  	}
 	if (rsrc->compressed_size > (4 * 1024 * 1024)) {
 		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
 		    ""Mac metadata is too large: %jd > 4M bytes"",
 		    (intmax_t)rsrc->compressed_size);
 		return (ARCHIVE_WARN);
 	}
  	metadata = malloc((size_t)rsrc->uncompressed_size);
  	if (metadata == NULL) {
 		archive_set_error(&a->archive, ENOMEM,
 		    ""Can't allocate memory for Mac metadata"");
 		return (ARCHIVE_FATAL);
 	}
 	if (offset < rsrc->local_header_offset)
 		__archive_read_consume(a, rsrc->local_header_offset - offset);
 	else if (offset != rsrc->local_header_offset) {
 		__archive_read_seek(a, rsrc->local_header_offset, SEEK_SET);
 	}
 	hsize = zip_get_local_file_header_size(a, 0);
 	__archive_read_consume(a, hsize);
 	remaining_bytes = (size_t)rsrc->compressed_size;
 	metadata_bytes = (size_t)rsrc->uncompressed_size;
 	mp = metadata;
 	eof = 0;
 	while (!eof && remaining_bytes) {
 		const unsigned char *p;
 		ssize_t bytes_avail;
 		size_t bytes_used;
 		p = __archive_read_ahead(a, 1, &bytes_avail);
 		if (p == NULL) {
 			archive_set_error(&a->archive,
 			    ARCHIVE_ERRNO_FILE_FORMAT,
 			    ""Truncated ZIP file header"");
 			ret = ARCHIVE_WARN;
 			goto exit_mac_metadata;
 		}
 		if ((size_t)bytes_avail > remaining_bytes)
  			bytes_avail = remaining_bytes;
  		switch(rsrc->compression) {
  		case 0:   
 			if ((size_t)bytes_avail > metadata_bytes)
 				bytes_avail = metadata_bytes;
  			memcpy(mp, p, bytes_avail);
  			bytes_used = (size_t)bytes_avail;
  			metadata_bytes -= bytes_used;
 			mp += bytes_used;
 			if (metadata_bytes == 0)
 				eof = 1;
 			break;
 #ifdef HAVE_ZLIB_H
 		case 8:  
 		{
 			int r;
 			ret = zip_deflate_init(a, zip);
 			if (ret != ARCHIVE_OK)
 				goto exit_mac_metadata;
 			zip->stream.next_in =
 			    (Bytef *)(uintptr_t)(const void *)p;
 			zip->stream.avail_in = (uInt)bytes_avail;
 			zip->stream.total_in = 0;
 			zip->stream.next_out = mp;
 			zip->stream.avail_out = (uInt)metadata_bytes;
 			zip->stream.total_out = 0;
 			r = inflate(&zip->stream, 0);
 			switch (r) {
 			case Z_OK:
 				break;
 			case Z_STREAM_END:
 				eof = 1;
 				break;
 			case Z_MEM_ERROR:
 				archive_set_error(&a->archive, ENOMEM,
 				    ""Out of memory for ZIP decompression"");
 				ret = ARCHIVE_FATAL;
 				goto exit_mac_metadata;
 			default:
 				archive_set_error(&a->archive,
 				    ARCHIVE_ERRNO_MISC,
 				    ""ZIP decompression failed (%d)"", r);
 				ret = ARCHIVE_FATAL;
 				goto exit_mac_metadata;
 			}
 			bytes_used = zip->stream.total_in;
 			metadata_bytes -= zip->stream.total_out;
 			mp += zip->stream.total_out;
 			break;
 		}
 #endif
 		default:
 			bytes_used = 0;
 			break;
 		}
 		__archive_read_consume(a, bytes_used);
 		remaining_bytes -= bytes_used;
 	}
 	archive_entry_copy_mac_metadata(entry, metadata,
 	    (size_t)rsrc->uncompressed_size - metadata_bytes);
 exit_mac_metadata:
 	__archive_read_seek(a, offset, SEEK_SET);
 	zip->decompress_init = 0;
 	free(metadata);
 	return (ret);
 }","[12, 13, 14, 15, 16, 33, 34, 35, 36, 37, 38, 72, 73]",Heap-based buffer overflow in the zip_read_mac_metadata function in archive_read_support_format_zip.c in libarchive before 3.2.0 allows remote attackers to execute arbitrary code via crafted entry-size values in a ZIP archive.,libarchive,CVE-2016-1541,CWE-20
75,179102," static void diff_bytes_c(uint8_t *dst, const uint8_t *src1, const uint8_t *src2, int w){
     long i;
 #if !HAVE_FAST_UNALIGNED
     if((long)src2 & (sizeof(long)-1)){
         for(i=0; i+7<w; i+=8){
             dst[i+0] = src1[i+0]-src2[i+0];
             dst[i+1] = src1[i+1]-src2[i+1];
             dst[i+2] = src1[i+2]-src2[i+2];
             dst[i+3] = src1[i+3]-src2[i+3];
             dst[i+4] = src1[i+4]-src2[i+4];
             dst[i+5] = src1[i+5]-src2[i+5];
             dst[i+6] = src1[i+6]-src2[i+6];
             dst[i+7] = src1[i+7]-src2[i+7];
          }
      }else
  #endif
    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){
     for(i=0; i<=w-(int)sizeof(long); i+=sizeof(long)){
          long a = *(long*)(src1+i);
          long b = *(long*)(src2+i);
          *(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);
     }
     for(; i<w; i++)
         dst[i+0] = src1[i+0]-src2[i+0];
 }","[17, 18]",Multiple integer signedness errors in libavcodec/dsputil.c in FFmpeg before 2.1 allow remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted data.,FFmpeg,CVE-2013-7010,CWE-189
91,178127," static void vrend_renderer_init_blit_ctx(struct vrend_blitter_ctx *blit_ctx)
 {
    struct virgl_gl_ctx_param ctx_params;
    int i;
    if (blit_ctx->initialised) {
       vrend_clicbs->make_current(0, blit_ctx->gl_context);
        return;
     }
    blit_ctx->initialised = true;
     ctx_params.shared = true;
     ctx_params.major_ver = VREND_GL_VER_MAJOR;
     ctx_params.minor_ver = VREND_GL_VER_MINOR;
    vrend_clicbs->make_current(0, blit_ctx->gl_context);
    glGenVertexArrays(1, &blit_ctx->vaoid);
    glGenFramebuffers(1, &blit_ctx->fb_id);
    glGenBuffers(1, &blit_ctx->vbo_id);
    blit_build_vs_passthrough(blit_ctx);
    for (i = 0; i < 4; i++)
       blit_ctx->vertices[i][0][3] = 1;  
    glBindVertexArray(blit_ctx->vaoid);
    glBindBuffer(GL_ARRAY_BUFFER, blit_ctx->vbo_id);
 }",[9],Memory leak in the vrend_renderer_init_blit_ctx function in vrend_blitter.c in virglrenderer before 0.6.0 allows local guest OS users to cause a denial of service (host memory consumption) via a large number of VIRGL_CCMD_BLIT commands.,virglrenderer,CVE-2017-5993,CWE-772
94,182331," static int handle_eac3(MOVMuxContext *mov, AVPacket *pkt, MOVTrack *track)
 {
     AC3HeaderInfo *hdr = NULL;
     struct eac3_info *info;
     int num_blocks, ret;
     if (!track->eac3_priv && !(track->eac3_priv = av_mallocz(sizeof(*info))))
         return AVERROR(ENOMEM);
     info = track->eac3_priv;
     if (avpriv_ac3_parse_header(&hdr, pkt->data, pkt->size) < 0) {
         if (!track->entry) {
             av_log(mov, AV_LOG_WARNING, ""Dropping invalid packet from start of the stream\n"");
             ret = 0;
         } else
             ret = AVERROR_INVALIDDATA;
         goto end;
     }
     info->data_rate = FFMAX(info->data_rate, hdr->bit_rate / 1000);
     num_blocks = hdr->num_blocks;
     if (!info->ec3_done) {
         if (hdr->bitstream_id <= 10 && hdr->substreamid != 0) {
             ret = AVERROR(EINVAL);
             goto end;
         }
         if (hdr->frame_type == EAC3_FRAME_TYPE_INDEPENDENT) {
             if (hdr->substreamid > info->num_ind_sub + 1) {
                 ret = AVERROR(EINVAL);
                 goto end;
             }
             if (hdr->substreamid == info->num_ind_sub + 1) {
                 avpriv_request_sample(track->par, ""Multiple independent substreams"");
                 ret = AVERROR_PATCHWELCOME;
                 goto end;
             } else if (hdr->substreamid < info->num_ind_sub ||
                        hdr->substreamid == 0 && info->substream[0].bsid) {
                  info->ec3_done = 1;
                  goto concatenate;
              }
         } else {
             if (hdr->substreamid != 0) {
                 avpriv_request_sample(mov->fc, ""Multiple non EAC3 independent substreams"");
                 ret = AVERROR_PATCHWELCOME;
                 goto end;
             }
          }
         info->substream[hdr->substreamid].fscod = hdr->sr_code;
         info->substream[hdr->substreamid].bsid  = hdr->bitstream_id;
         info->substream[hdr->substreamid].bsmod = hdr->bitstream_mode;
         info->substream[hdr->substreamid].acmod = hdr->channel_mode;
         info->substream[hdr->substreamid].lfeon = hdr->lfe_on;
         if (pkt->size != hdr->frame_size) {
             int cumul_size = hdr->frame_size;
             int parent = hdr->substreamid;
             while (cumul_size != pkt->size) {
                 GetBitContext gbc;
                 int i;
                 ret = avpriv_ac3_parse_header(&hdr, pkt->data + cumul_size, pkt->size - cumul_size);
                 if (ret < 0)
                     goto end;
                 if (hdr->frame_type != EAC3_FRAME_TYPE_DEPENDENT) {
                     ret = AVERROR(EINVAL);
                     goto end;
                 }
                 info->substream[parent].num_dep_sub++;
                 ret /= 8;
                 init_get_bits8(&gbc, pkt->data + cumul_size + ret, pkt->size - cumul_size - ret);
                 skip_bits(&gbc, 5);
                 for (i = 0; i < (hdr->channel_mode ? 1 : 2); i++) {
                     skip_bits(&gbc, 5);  
                     if (get_bits1(&gbc)) {
                         skip_bits(&gbc, 8);  
                     }
                 }
                 if (get_bits1(&gbc))
                     info->substream[parent].chan_loc |= (get_bits(&gbc, 16) >> 5) & 0x1f;
                 else
                     info->substream[parent].chan_loc |= hdr->channel_mode;
                 cumul_size += hdr->frame_size;
             }
         }
     }
 concatenate:
     if (!info->num_blocks && num_blocks == 6) {
         ret = pkt->size;
         goto end;
     }
     else if (info->num_blocks + num_blocks > 6) {
         ret = AVERROR_INVALIDDATA;
         goto end;
     }
     if (!info->num_blocks) {
         ret = av_packet_ref(&info->pkt, pkt);
         if (!ret)
             info->num_blocks = num_blocks;
         goto end;
     } else {
         if ((ret = av_grow_packet(&info->pkt, pkt->size)) < 0)
             goto end;
         memcpy(info->pkt.data + info->pkt.size - pkt->size, pkt->data, pkt->size);
         info->num_blocks += num_blocks;
         info->pkt.duration += pkt->duration;
         if ((ret = av_copy_packet_side_data(&info->pkt, pkt)) < 0)
             goto end;
         if (info->num_blocks != 6)
             goto end;
         av_packet_unref(pkt);
         av_packet_move_ref(pkt, &info->pkt);
         info->num_blocks = 0;
     }
     ret = pkt->size;
 end:
     av_free(hdr);
     return ret;
 }","[38, 39, 40, 41, 42, 43]","In FFmpeg 4.0.1, improper handling of frame types (other than EAC3_FRAME_TYPE_INDEPENDENT) that have multiple independent substreams in the handle_eac3 function in libavformat/movenc.c may trigger an out-of-array access while converting a crafted AVI file to MPEG4, leading to a denial of service or possibly unspecified other impact.",FFmpeg,CVE-2018-13302,CWE-129
107,183313," USHORT CNB::QueryL4HeaderOffset(PVOID PacketData, ULONG IpHeaderOffset) const
  {
      USHORT Res;
      auto ppr = ParaNdis_ReviewIPPacket(RtlOffsetToPointer(PacketData, IpHeaderOffset),
                                       GetDataLength(), __FUNCTION__);
                                        GetDataLength(), FALSE, __FUNCTION__);
      if (ppr.ipStatus != ppresNotIP)
      {
          Res = static_cast<USHORT>(IpHeaderOffset + ppr.ipHeaderSize);
     }
     else
     {
         DPrintf(0, (""[%s] ERROR: NOT an IP packet - expected troubles!\n"", __FUNCTION__));
         Res = 0;
     }
     return Res;
 }","[5, 6]","The NetKVM Windows Virtio driver allows remote attackers to cause a denial of service (guest crash) via a crafted length value in an IP packet, as demonstrated by a value that does not account for the size of the IP options.",kvm-guest-drivers-windows,CVE-2015-3215,CWE-20
121,181861," static int jas_iccputsint(jas_stream_t *out, int n, longlong val)
 static int jas_iccputsint(jas_stream_t *out, int n, jas_longlong val)
  {
	ulonglong tmp;
 	jas_ulonglong tmp;
  	tmp = (val < 0) ? (abort(), 0) : val;
  	return jas_iccputuint(out, n, tmp);
  }","[2, 4, 5]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
124,182253," static int read_public_key(RSA *rsa)
 {
 	int r;
 	sc_path_t path;
 	sc_file_t *file;
 	u8 buf[2048], *p = buf;
 	size_t bufsize, keysize;
 	r = select_app_df();
 	if (r)
 		return 1;
 	sc_format_path(""I1012"", &path);
 	r = sc_select_file(card, &path, &file);
 	if (r) {
  		fprintf(stderr, ""Unable to select public key file: %s\n"", sc_strerror(r));
  		return 2;
  	}
	bufsize = file->size;
 	bufsize = MIN(file->size, sizeof buf);
  	sc_file_free(file);
  	r = sc_read_binary(card, 0, buf, bufsize, 0);
  	if (r < 0) {
 		fprintf(stderr, ""Unable to read public key file: %s\n"", sc_strerror(r));
 		return 2;
 	}
 	bufsize = r;
 	do {
 		if (bufsize < 4)
 			return 3;
 		keysize = (p[0] << 8) | p[1];
 		if (keysize == 0)
 			break;
 		if (keysize < 3)
 			return 3;
 		if (p[2] == opt_key_num)
 			break;
 		p += keysize;
 		bufsize -= keysize;
 	} while (1);
 	if (keysize == 0) {
 		printf(""Key number %d not found.\n"", opt_key_num);
 		return 2;
 	}
 	return parse_public_key(p, keysize, rsa);
 }","[17, 18]",A double free when handling responses from an HSM Card in sc_pkcs15emu_sc_hsm_init in libopensc/pkcs15-sc-hsm.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.,OpenSC,CVE-2018-16425,CWE-415
164,181862," static int jas_iccputuint(jas_stream_t *out, int n, ulonglong val)
 static int jas_iccputuint(jas_stream_t *out, int n, jas_ulonglong val)
  {
  	int i;
  	int c;
 	for (i = n; i > 0; --i) {
 		c = (val >> (8 * (i - 1))) & 0xff;
 		if (jas_stream_putc(out, c) == EOF)
 			return -1;
 	}
  	return 0;
  }",[2],Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
167,178811," initpyfribidi (void)
 init_pyfribidi (void)
  {
	PyObject *module;
	module = Py_InitModule3 (""pyfribidi"", PyfribidiMethods,
				 _pyfribidi__doc__);
         PyObject *module = Py_InitModule (""_pyfribidi"", PyfribidiMethods);
  	PyModule_AddIntConstant (module, ""RTL"", (long) FRIBIDI_TYPE_RTL);
  	PyModule_AddIntConstant (module, ""LTR"", (long) FRIBIDI_TYPE_LTR);
  	PyModule_AddIntConstant (module, ""ON"", (long) FRIBIDI_TYPE_ON);
	PyModule_AddStringConstant (module, ""__author__"",
				    ""Yaacov Zamir and Nir Soffer"");
  }","[2, 4, 5, 6, 7, 11, 12]",Buffer overflow in the fribidi_utf8_to_unicode function in PyFriBidi before 0.11.0 allows remote attackers to cause a denial of service (application crash) via a 4-byte utf-8 sequence.,pyfribidi,CVE-2012-1176,CWE-119
179,182871," static void Sp_replace_regexp(js_State *J)
 {
 	js_Regexp *re;
 	const char *source, *s, *r;
 	js_Buffer *sb = NULL;
 	int n, x;
 	Resub m;
  	source = checkstring(J, 0);
  	re = js_toregexp(J, 1);
	if (js_regexec(re->prog, source, &m, 0)) {
 	if (js_doregexec(J, re->prog, source, &m, 0)) {
  		js_copy(J, 0);
  		return;
  	}
 	re->last = 0;
 loop:
 	s = m.sub[0].sp;
 	n = m.sub[0].ep - m.sub[0].sp;
 	if (js_iscallable(J, 2)) {
 		js_copy(J, 2);
 		js_pushundefined(J);
 		for (x = 0; m.sub[x].sp; ++x)  
 			js_pushlstring(J, m.sub[x].sp, m.sub[x].ep - m.sub[x].sp);
 		js_pushnumber(J, s - source);  
 		js_copy(J, 0);  
 		js_call(J, 2 + x);
 		r = js_tostring(J, -1);
 		js_putm(J, &sb, source, s);
 		js_puts(J, &sb, r);
 		js_pop(J, 1);
 	} else {
 		r = js_tostring(J, 2);
 		js_putm(J, &sb, source, s);
 		while (*r) {
 			if (*r == '$') {
 				switch (*(++r)) {
 				case 0: --r;  
 				case '$': js_putc(J, &sb, '$'); break;
 				case '`': js_putm(J, &sb, source, s); break;
 				case '\'': js_puts(J, &sb, s + n); break;
 				case '&':
 					js_putm(J, &sb, s, s + n);
 					break;
 				case '0': case '1': case '2': case '3': case '4':
 				case '5': case '6': case '7': case '8': case '9':
 					x = *r - '0';
 					if (r[1] >= '0' && r[1] <= '9')
 						x = x * 10 + *(++r) - '0';
 					if (x > 0 && x < m.nsub) {
 						js_putm(J, &sb, m.sub[x].sp, m.sub[x].ep);
 					} else {
 						js_putc(J, &sb, '$');
 						if (x > 10) {
 							js_putc(J, &sb, '0' + x / 10);
 							js_putc(J, &sb, '0' + x % 10);
 						} else {
 							js_putc(J, &sb, '0' + x);
 						}
 					}
 					break;
 				default:
 					js_putc(J, &sb, '$');
 					js_putc(J, &sb, *r);
 					break;
 				}
 				++r;
 			} else {
 				js_putc(J, &sb, *r++);
 			}
 		}
 	}
 	if (re->flags & JS_REGEXP_G) {
 		source = m.sub[0].ep;
 		if (n == 0) {
 			if (*source)
 				js_putc(J, &sb, *source++);
  			else
  				goto end;
  		}
		if (!js_regexec(re->prog, source, &m, REG_NOTBOL))
 		if (!js_doregexec(J, re->prog, source, &m, REG_NOTBOL))
  			goto loop;
  	}
 end:
 	js_puts(J, &sb, s + n);
 	js_putc(J, &sb, 0);
 	if (js_try(J)) {
 		js_free(J, sb);
 		js_throw(J);
 	}
 	js_pushstring(J, sb ? sb->s : """");
 	js_endtry(J);
 	js_free(J, sb);
 }","[10, 11, 80, 81]",An issue was discovered in Artifex MuJS 1.0.5. It has unlimited recursion because the match function in regexp.c lacks a depth check.,mujs,CVE-2019-11413,CWE-400
215,183217," static int dnxhd_find_frame_end(DNXHDParserContext *dctx,
                                 const uint8_t *buf, int buf_size)
 {
     ParseContext *pc = &dctx->pc;
     uint64_t state = pc->state64;
     int pic_found = pc->frame_start_found;
     int i = 0;
     if (!pic_found) {
         for (i = 0; i < buf_size; i++) {
             state = (state << 8) | buf[i];
             if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {
                 i++;
                 pic_found = 1;
                 dctx->cur_byte = 0;
                 dctx->remaining = 0;
                 break;
             }
         }
     }
     if (pic_found && !dctx->remaining) {
         if (!buf_size)  
             return 0;
         for (; i < buf_size; i++) {
             dctx->cur_byte++;
             state = (state << 8) | buf[i];
             if (dctx->cur_byte == 24) {
                 dctx->h = (state >> 32) & 0xFFFF;
             } else if (dctx->cur_byte == 26) {
                  dctx->w = (state >> 32) & 0xFFFF;
              } else if (dctx->cur_byte == 42) {
                  int cid = (state >> 32) & 0xFFFFFFFF;
                 int remaining;
                  if (cid <= 0)
                      continue;
                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);
                if (dctx->remaining <= 0) {
                    dctx->remaining = ff_dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
                    if (dctx->remaining <= 0)
                        return dctx->remaining;
                 remaining = avpriv_dnxhd_get_frame_size(cid);
                 if (remaining <= 0) {
                     remaining = ff_dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
                     if (remaining <= 0)
                         continue;
                  }
                 dctx->remaining = remaining;
                  if (buf_size - i + 47 >= dctx->remaining) {
                      int remaining = dctx->remaining;
                     pc->frame_start_found = 0;
                     pc->state64 = -1;
                     dctx->cur_byte = 0;
                     dctx->remaining = 0;
                     return remaining;
                 } else {
                     dctx->remaining -= buf_size;
                 }
             }
         }
     } else if (pic_found) {
         if (dctx->remaining > buf_size) {
             dctx->remaining -= buf_size;
         } else {
             int remaining = dctx->remaining;
             pc->frame_start_found = 0;
             pc->state64 = -1;
             dctx->cur_byte = 0;
             dctx->remaining = 0;
             return remaining;
         }
     }
     pc->frame_start_found = pic_found;
     pc->state64 = state;
     return END_NOT_FOUND;
 }","[32, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 46]","The dnxhd decoder in FFmpeg before 3.2.6, and 3.3.x before 3.3.3 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted mov file.",FFmpeg,CVE-2017-9608,CWE-476
220,178117," int vrend_create_shader(struct vrend_context *ctx,
                         uint32_t handle,
                         const struct pipe_stream_output_info *so_info,
                         const char *shd_text, uint32_t offlen, uint32_t num_tokens,
                         uint32_t type, uint32_t pkt_length)
 {
    struct vrend_shader_selector *sel = NULL;
    int ret_handle;
    bool new_shader = true, long_shader = false;
    bool finished = false;
    int ret;
    if (type > PIPE_SHADER_GEOMETRY)
       return EINVAL;
    if (offlen & VIRGL_OBJ_SHADER_OFFSET_CONT)
       new_shader = false;
    else if (((offlen + 3) / 4) > pkt_length)
       long_shader = true;
    if (ctx->sub->long_shader_in_progress_handle[type]) {
       if (new_shader == true)
          return EINVAL;
       if (handle != ctx->sub->long_shader_in_progress_handle[type])
          return EINVAL;
    }
    if (new_shader) {
      sel = vrend_create_shader_state(ctx, so_info, type);
      if (sel == NULL)
        return ENOMEM;
      if (long_shader) {
         sel->buf_len = ((offlen + 3) / 4) * 4;  
         sel->tmp_buf = malloc(sel->buf_len);
         if (!sel->tmp_buf) {
            ret = ENOMEM;
            goto error;
         }
         memcpy(sel->tmp_buf, shd_text, pkt_length * 4);
         sel->buf_offset = pkt_length * 4;
         ctx->sub->long_shader_in_progress_handle[type] = handle;
      } else
         finished = true;
    } else {
       sel = vrend_object_lookup(ctx->sub->object_hash, handle, VIRGL_OBJECT_SHADER);
       if (!sel) {
          fprintf(stderr, ""got continuation without original shader %d\n"", handle);
          ret = EINVAL;
          goto error;
       }
       offlen &= ~VIRGL_OBJ_SHADER_OFFSET_CONT;
       if (offlen != sel->buf_offset) {
          fprintf(stderr, ""Got mismatched shader continuation %d vs %d\n"",
                  offlen, sel->buf_offset);
           ret = EINVAL;
           goto error;
        }
       if (pkt_length * 4 < pkt_length ||
           pkt_length * 4 + sel->buf_offset < pkt_length * 4 ||
           pkt_length * 4 + sel->buf_offset < sel->buf_offset) {
             ret = EINVAL;
             goto error;
           }
        if ((pkt_length * 4 + sel->buf_offset) > sel->buf_len) {
           fprintf(stderr, ""Got too large shader continuation %d vs %d\n"",
                   pkt_length * 4 + sel->buf_offset, sel->buf_len);
          shd_text = sel->tmp_buf;
       }
    }
    if (finished) {
       struct tgsi_token *tokens;
       tokens = calloc(num_tokens + 10, sizeof(struct tgsi_token));
       if (!tokens) {
          ret = ENOMEM;
          goto error;
       }
       if (vrend_dump_shaders)
          fprintf(stderr,""shader\n%s\n"", shd_text);
       if (!tgsi_text_translate((const char *)shd_text, tokens, num_tokens + 10)) {
          free(tokens);
          ret = EINVAL;
          goto error;
       }
       if (vrend_finish_shader(ctx, sel, tokens)) {
          free(tokens);
          ret = EINVAL;
          goto error;
       } else {
          free(sel->tmp_buf);
          sel->tmp_buf = NULL;
       }
       free(tokens);
       ctx->sub->long_shader_in_progress_handle[type] = 0;
    }
    if (new_shader) {
       ret_handle = vrend_renderer_object_insert(ctx, sel, sizeof(*sel), handle, VIRGL_OBJECT_SHADER);
       if (ret_handle == 0) {
          ret = ENOMEM;
          goto error;
       }
    }
    return 0;
 error:
    if (new_shader)
       vrend_destroy_shader_selector(sel);
    else
       vrend_renderer_object_destroy(ctx, handle);
    return ret;
 }","[54, 55, 56, 57, 58, 59]","Integer overflow in the vrend_create_shader function in vrend_renderer.c in virglrenderer before 0.6.0 allows local guest OS users to cause a denial of service (process crash) via crafted pkt_length and offlen values, which trigger an out-of-bounds access.",virglrenderer,CVE-2017-6355,CWE-190
241,181274," int yr_re_ast_create(
     RE_AST** re_ast)
 {
   *re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));
   if (*re_ast == NULL)
      return ERROR_INSUFFICIENT_MEMORY;
    (*re_ast)->flags = 0;
   (*re_ast)->levels = 0;
    (*re_ast)->root_node = NULL;
    return ERROR_SUCCESS;
 }",[8],libyara/re.c in the regexp module in YARA 3.5.0 allows remote attackers to cause a denial of service (stack consumption) via a crafted rule that is mishandled in the _yr_re_emit function.,yara,CVE-2017-9304,CWE-674
255,183233,"  header_read (SF_PRIVATE *psf, void *ptr, int bytes)
  {	int count = 0 ;
	if (psf->headindex >= SIGNED_SIZEOF (psf->header))
		return psf_fread (ptr, 1, bytes, psf) ;
	if (psf->headindex + bytes > SIGNED_SIZEOF (psf->header))
	{	int most ;
 	if (psf->header.indx + bytes >= psf->header.len && psf_bump_header_allocation (psf, bytes))
 		return count ;
		most = SIGNED_SIZEOF (psf->header) - psf->headend ;
		psf_fread (psf->header + psf->headend, 1, most, psf) ;
		memcpy (ptr, psf->header + psf->headend, most) ;
		psf->headend = psf->headindex += most ;
		psf_fread ((char *) ptr + most, bytes - most, 1, psf) ;
		return bytes ;
		} ;
	if (psf->headindex + bytes > psf->headend)
	{	count = psf_fread (psf->header + psf->headend, 1, bytes - (psf->headend - psf->headindex), psf) ;
		if (count != bytes - (int) (psf->headend - psf->headindex))
 	if (psf->header.indx + bytes > psf->header.end)
 	{	count = psf_fread (psf->header.ptr + psf->header.end, 1, bytes - (psf->header.end - psf->header.indx), psf) ;
 		if (count != bytes - (int) (psf->header.end - psf->header.indx))
  		{	psf_log_printf (psf, ""Error : psf_fread returned short count.\n"") ;
  			return count ;
  			} ;
		psf->headend += count ;
 		psf->header.end += count ;
  		} ;
	memcpy (ptr, psf->header + psf->headindex, bytes) ;
	psf->headindex += bytes ;
 	memcpy (ptr, psf->header.ptr + psf->header.indx, bytes) ;
 	psf->header.indx += bytes ;
  	return bytes ;
  }  ","[3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 25, 26, 28, 29, 30, 31]","In libsndfile before 1.0.28, an error in the *header_read()* function (common.c) when handling ID3 tags can be exploited to cause a stack-based buffer overflow via a specially crafted FLAC file.",libsndfile,CVE-2017-7586,CWE-119
260,182225," construct_mac_tlv(struct sc_card *card, unsigned char *apdu_buf, size_t data_tlv_len, size_t le_tlv_len,
 		unsigned char *mac_tlv, size_t * mac_tlv_len, const unsigned char key_type)
 {
 	size_t block_size = (KEY_TYPE_AES == key_type ? 16 : 8);
 	unsigned char mac[4096] = { 0 };
 	size_t mac_len;
 	unsigned char icv[16] = { 0 };
 	int i = (KEY_TYPE_AES == key_type ? 15 : 7);
 	epass2003_exdata *exdata = NULL;
 	if (!card->drv_data) 
 		return SC_ERROR_INVALID_ARGUMENTS;
 	exdata = (epass2003_exdata *)card->drv_data;
 	if (0 == data_tlv_len && 0 == le_tlv_len) {
 		mac_len = block_size;
 	}
 	else {
 		*(apdu_buf + block_size + data_tlv_len + le_tlv_len) = 0x80;
 		if ((data_tlv_len + le_tlv_len + 1) % block_size)
 			mac_len = (((data_tlv_len + le_tlv_len + 1) / block_size) +
 					1) * block_size + block_size;
 		else
 			mac_len = data_tlv_len + le_tlv_len + 1 + block_size;
 		memset((apdu_buf + block_size + data_tlv_len + le_tlv_len + 1),
 		       0, (mac_len - (data_tlv_len + le_tlv_len + 1)));
 	}
 	for (; i >= 0; i--) {
 		if (exdata->icv_mac[i] == 0xff) {
 			exdata->icv_mac[i] = 0;
 		}
 		else {
 			exdata->icv_mac[i]++;
 			break;
 		}
 	}
 	memset(icv, 0, sizeof(icv));
 	memcpy(icv, exdata->icv_mac, 16);
 	if (KEY_TYPE_AES == key_type) {
 		aes128_encrypt_cbc(exdata->sk_mac, 16, icv, apdu_buf, mac_len, mac);
  		memcpy(mac_tlv + 2, &mac[mac_len - 16], 8);
  	}
  	else {
		unsigned char iv[8] = { 0 };
 		unsigned char iv[EVP_MAX_IV_LENGTH] = { 0 };
  		unsigned char tmp[8] = { 0 };
  		des_encrypt_cbc(exdata->sk_mac, 8, icv, apdu_buf, mac_len, mac);
  		des_decrypt_cbc(&exdata->sk_mac[8], 8, iv, &mac[mac_len - 8], 8, tmp);
		memset(iv, 0x00, 8);
 		memset(iv, 0x00, sizeof iv);
  		des_encrypt_cbc(exdata->sk_mac, 8, iv, tmp, 8, mac_tlv + 2);
  	}
 	*mac_tlv_len = 2 + 8;
 	return 0;
 }","[42, 43, 47, 48]",Various out of bounds reads when handling responses in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to potentially crash the opensc library using programs.,OpenSC,CVE-2018-16427,CWE-125
266,179878," static int cg_open(const char *path, struct fuse_file_info *fi)
 {
 	const char *cgroup;
 	char *fpath = NULL, *path1, *path2, * cgdir = NULL, *controller;
 	struct cgfs_files *k = NULL;
 	struct file_info *file_info;
 	struct fuse_context *fc = fuse_get_context();
 	int ret;
 	if (!fc)
 		return -EIO;
 	controller = pick_controller_from_path(fc, path);
 	if (!controller)
 		return -EIO;
 	cgroup = find_cgroup_in_path(path);
 	if (!cgroup)
 		return -EINVAL;
 	get_cgdir_and_path(cgroup, &cgdir, &fpath);
 	if (!fpath) {
 		path1 = ""/"";
 		path2 = cgdir;
 	} else {
 		path1 = cgdir;
 		path2 = fpath;
 	}
 	k = cgfs_get_key(controller, path1, path2);
 	if (!k) {
 		ret = -EINVAL;
 		goto out;
  	}
  	free_key(k);
 	if (!caller_may_see_dir(fc->pid, controller, path1)) {
 		ret = -ENOENT;
 		goto out;
 	}
  	if (!fc_may_access(fc, controller, path1, path2, fi->flags)) {
  		ret = -EACCES;
 		goto out;
 	}
 	file_info = malloc(sizeof(*file_info));
 	if (!file_info) {
 		ret = -ENOMEM;
 		goto out;
 	}
 	file_info->controller = must_copy_string(controller);
 	file_info->cgroup = must_copy_string(path1);
 	file_info->file = must_copy_string(path2);
 	file_info->type = LXC_TYPE_CGFILE;
 	file_info->buf = NULL;
 	file_info->buflen = 0;
 	fi->fh = (unsigned long)file_info;
 	ret = 0;
 out:
 	free(cgdir);
 	return ret;
 }","[31, 32, 33, 34]","LXCFS before 0.12 does not properly enforce directory escapes, which might allow local users to gain privileges by (1) querying or (2) updating a cgroup.",lxcfs,CVE-2015-1342,CWE-264
311,180114,"  choose_filters(struct archive_read *a)
  {
	int number_bidders, i, bid, best_bid;
 	int number_bidders, i, bid, best_bid, n;
  	struct archive_read_filter_bidder *bidder, *best_bidder;
  	struct archive_read_filter *filter;
  	ssize_t avail;
  	int r;
	for (;;) {
 	for (n = 0; n < 25; ++n) {
  		number_bidders = sizeof(a->bidders) / sizeof(a->bidders[0]);
  		best_bid = 0;
 		best_bidder = NULL;
 		bidder = a->bidders;
 		for (i = 0; i < number_bidders; i++, bidder++) {
 			if (bidder->bid != NULL) {
 				bid = (bidder->bid)(bidder, a->filter);
 				if (bid > best_bid) {
 					best_bid = bid;
 					best_bidder = bidder;
 				}
 			}
 		}
 		if (best_bidder == NULL) {
 			__archive_read_filter_ahead(a->filter, 1, &avail);
 			if (avail < 0) {
 				__archive_read_close_filters(a);
 				__archive_read_free_filters(a);
 				return (ARCHIVE_FATAL);
 			}
 			a->archive.compression_name = a->filter->name;
 			a->archive.compression_code = a->filter->code;
 			return (ARCHIVE_OK);
 		}
 		filter
 		    = (struct archive_read_filter *)calloc(1, sizeof(*filter));
 		if (filter == NULL)
 			return (ARCHIVE_FATAL);
 		filter->bidder = best_bidder;
 		filter->archive = a;
 		filter->upstream = a->filter;
 		a->filter = filter;
 		r = (best_bidder->init)(a->filter);
 		if (r != ARCHIVE_OK) {
 			__archive_read_close_filters(a);
 			__archive_read_free_filters(a);
  			return (ARCHIVE_FATAL);
  		}
  	}
 	archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
 	    ""Input requires too many filters for decoding"");
 	return (ARCHIVE_FATAL);
  }","[3, 4, 9, 10, 50, 51, 52]","libarchive before 3.2.0 does not limit the number of recursive decompressions, which allows remote attackers to cause a denial of service (memory consumption and application crash) via a crafted gzip file.",libarchive,CVE-2016-7166,CWE-399
312,182965," GF_Err gf_sm_load_init(GF_SceneLoader *load)
 {
 	GF_Err e = GF_NOT_SUPPORTED;
 	char *ext, szExt[50];
 	if (!load || (!load->ctx && !load->scene_graph)
 #ifndef GPAC_DISABLE_ISOM
 	        || (!load->fileName && !load->isom && !(load->flags & GF_SM_LOAD_FOR_PLAYBACK) )
 #endif
 	   ) return GF_BAD_PARAM;
 	if (!load->type) {
 #ifndef GPAC_DISABLE_ISOM
 		if (load->isom) {
 			load->type = GF_SM_LOAD_MP4;
 		} else
 #endif
 		{
 			ext = (char *)strrchr(load->fileName, '.');
 			if (!ext) return GF_NOT_SUPPORTED;
 			if (!stricmp(ext, "".gz"")) {
 				char *anext;
 				ext[0] = 0;
 				anext = (char *)strrchr(load->fileName, '.');
  				ext[0] = '.';
  				ext = anext;
  			}
 			if (strlen(ext) < 2 || strlen(ext) > sizeof(szExt)) {
 				GF_LOG(GF_LOG_ERROR, GF_LOG_SCENE, (""[Scene Manager] invalid extension in file name %s\n"", load->fileName));
 				return GF_NOT_SUPPORTED;
 			}
  			strcpy(szExt, &ext[1]);
  			strlwr(szExt);
  			if (strstr(szExt, ""bt"")) load->type = GF_SM_LOAD_BT;
 			else if (strstr(szExt, ""wrl"")) load->type = GF_SM_LOAD_VRML;
 			else if (strstr(szExt, ""x3dv"")) load->type = GF_SM_LOAD_X3DV;
 #ifndef GPAC_DISABLE_LOADER_XMT
 			else if (strstr(szExt, ""xmt"") || strstr(szExt, ""xmta"")) load->type = GF_SM_LOAD_XMTA;
 			else if (strstr(szExt, ""x3d"")) load->type = GF_SM_LOAD_X3D;
 #endif
 			else if (strstr(szExt, ""swf"")) load->type = GF_SM_LOAD_SWF;
 			else if (strstr(szExt, ""mov"")) load->type = GF_SM_LOAD_QT;
 			else if (strstr(szExt, ""svg"")) load->type = GF_SM_LOAD_SVG;
 			else if (strstr(szExt, ""xsr"")) load->type = GF_SM_LOAD_XSR;
 			else if (strstr(szExt, ""xbl"")) load->type = GF_SM_LOAD_XBL;
 			else if (strstr(szExt, ""xml"")) {
 				char *rtype = gf_xml_get_root_type(load->fileName, &e);
 				if (rtype) {
 					if (!strcmp(rtype, ""SAFSession"")) load->type = GF_SM_LOAD_XSR;
 					else if (!strcmp(rtype, ""XMT-A"")) load->type = GF_SM_LOAD_XMTA;
 					else if (!strcmp(rtype, ""X3D"")) load->type = GF_SM_LOAD_X3D;
 					else if (!strcmp(rtype, ""bindings"")) load->type = GF_SM_LOAD_XBL;
 					gf_free(rtype);
 				}
 			}
 		}
 	}
 	if (!load->type) return e;
 	if (!load->scene_graph) load->scene_graph = load->ctx->scene_graph;
 	switch (load->type) {
 #ifndef GPAC_DISABLE_LOADER_BT
 	case GF_SM_LOAD_BT:
 	case GF_SM_LOAD_VRML:
 	case GF_SM_LOAD_X3DV:
 		return gf_sm_load_init_bt(load);
 #endif
 #ifndef GPAC_DISABLE_LOADER_XMT
 	case GF_SM_LOAD_XMTA:
 	case GF_SM_LOAD_X3D:
 		return gf_sm_load_init_xmt(load);
 #endif
 #ifndef GPAC_DISABLE_SVG
 	case GF_SM_LOAD_SVG:
 	case GF_SM_LOAD_XSR:
 	case GF_SM_LOAD_DIMS:
 		return gf_sm_load_init_svg(load);
 	case GF_SM_LOAD_XBL:
 		e = gf_sm_load_init_xbl(load);
 		load->process = gf_sm_load_run_xbl;
 		load->done = gf_sm_load_done_xbl;
 		return e;
 #endif
 #ifndef GPAC_DISABLE_SWF_IMPORT
 	case GF_SM_LOAD_SWF:
 		return gf_sm_load_init_swf(load);
 #endif
 #ifndef GPAC_DISABLE_LOADER_ISOM
 	case GF_SM_LOAD_MP4:
 		return gf_sm_load_init_isom(load);
 #endif
 #ifndef GPAC_DISABLE_QTVR
 	case GF_SM_LOAD_QT:
 		return gf_sm_load_init_qt(load);
 #endif
 	default:
 		return GF_NOT_SUPPORTED;
 	}
 	return GF_NOT_SUPPORTED;
 }","[26, 27, 28, 29]",GPAC version 0.7.1 and earlier has a buffer overflow vulnerability in the cat_multiple_files function in applications/mp4box/fileimport.c when MP4Box is used for a local directory containing crafted filenames.,gpac,CVE-2018-20762,CWE-119
336,180931," static int read_tfra(MOVContext *mov, AVIOContext *f)
 {
     MOVFragmentIndex* index = NULL;
     int version, fieldlength, i, j;
     int64_t pos = avio_tell(f);
     uint32_t size = avio_rb32(f);
     void *tmp;
     if (avio_rb32(f) != MKBETAG('t', 'f', 'r', 'a')) {
         return 1;
     }
     av_log(mov->fc, AV_LOG_VERBOSE, ""found tfra\n"");
     index = av_mallocz(sizeof(MOVFragmentIndex));
     if (!index) {
         return AVERROR(ENOMEM);
     }
     tmp = av_realloc_array(mov->fragment_index_data,
                            mov->fragment_index_count + 1,
                            sizeof(MOVFragmentIndex*));
     if (!tmp) {
         av_freep(&index);
         return AVERROR(ENOMEM);
     }
     mov->fragment_index_data = tmp;
     mov->fragment_index_data[mov->fragment_index_count++] = index;
     version = avio_r8(f);
     avio_rb24(f);
     index->track_id = avio_rb32(f);
     fieldlength = avio_rb32(f);
     index->item_count = avio_rb32(f);
     index->items = av_mallocz_array(
             index->item_count, sizeof(MOVFragmentIndexItem));
     if (!index->items) {
         index->item_count = 0;
         return AVERROR(ENOMEM);
      }
      for (i = 0; i < index->item_count; i++) {
          int64_t time, offset;
         if (avio_feof(f)) {
             index->item_count = 0;
             av_freep(&index->items);
             return AVERROR_INVALIDDATA;
         }
          if (version == 1) {
              time   = avio_rb64(f);
              offset = avio_rb64(f);
         } else {
             time   = avio_rb32(f);
             offset = avio_rb32(f);
         }
         index->items[i].time = time;
         index->items[i].moof_offset = offset;
         for (j = 0; j < ((fieldlength >> 4) & 3) + 1; j++)
             avio_r8(f);
         for (j = 0; j < ((fieldlength >> 2) & 3) + 1; j++)
             avio_r8(f);
         for (j = 0; j < ((fieldlength >> 0) & 3) + 1; j++)
             avio_r8(f);
     }
     avio_seek(f, pos + size, SEEK_SET);
     return 0;
 }","[38, 39, 40, 41, 42]","In libavformat/mov.c in FFmpeg 3.3.3, a DoS in read_tfra() due to lack of an EOF (End of File) check might cause huge CPU and memory consumption. When a crafted MOV file, which claims a large *item_count* field in the header but does not contain sufficient backing data, is provided, the loop would consume huge CPU and memory resources, since there is no EOF check inside the loop.",FFmpeg,CVE-2017-14222,CWE-834
351,182687," static int decode_bit_string(const u8 * inbuf, size_t inlen, void *outbuf,
 			     size_t outlen, int invert)
  {
  	const u8 *in = inbuf;
  	u8 *out = (u8 *) outbuf;
	int zero_bits = *in & 0x07;
	size_t octets_left = inlen - 1;
  	int i, count = 0;
 	int zero_bits;
 	size_t octets_left;
	memset(outbuf, 0, outlen);
	in++;
  	if (outlen < octets_left)
  		return SC_ERROR_BUFFER_TOO_SMALL;
  	if (inlen < 1)
  		return SC_ERROR_INVALID_ASN1_OBJECT;
 	zero_bits = *in & 0x07;
 	octets_left = inlen - 1;
 	in++;
 	memset(outbuf, 0, outlen);
  	while (octets_left) {
 		int bits_to_go;
 		*out = 0;
 		if (octets_left == 1)
 			bits_to_go = 8 - zero_bits;
 		else
 			bits_to_go = 8;
 		if (invert)
 			for (i = 0; i < bits_to_go; i++) {
 				*out |= ((*in >> (7 - i)) & 1) << i;
 			}
 		else {
 			*out = *in;
 		}
 		out++;
 		in++;
 		octets_left--;
 		count++;
 	}
 	return (count * 8) - zero_bits;
 }","[6, 7, 9, 10, 11, 12, 17, 18, 19, 20]",OpenSC before 0.20.0-rc1 has an out-of-bounds access of an ASN.1 Bitstring in decode_bit_string in libopensc/asn1.c.,OpenSC,CVE-2019-15945,CWE-119
358,177802,"  static void build_l4proto_icmp(const struct nf_conntrack *ct, struct nethdr *n)
  {
 	if (!nfct_attr_is_set(ct, ATTR_ICMP_TYPE))
 		return;
  	ct_build_u8(ct, ATTR_ICMP_TYPE, n, NTA_ICMP_TYPE);
  	ct_build_u8(ct, ATTR_ICMP_CODE, n, NTA_ICMP_CODE);
  	ct_build_u16(ct, ATTR_ICMP_ID, n, NTA_ICMP_ID);
 	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
 		      sizeof(struct nfct_attr_grp_port));
 }","[3, 4]","conntrackd in conntrack-tools 1.4.2 and earlier does not ensure that the optional kernel modules are loaded before using them, which allows remote attackers to cause a denial of service (crash) via a (1) DCCP, (2) SCTP, or (3) ICMPv6 packet.",netfilter,CVE-2015-6496,CWE-17
370,182828," static int aa_read_header(AVFormatContext *s)
 {
     int i, j, idx, largest_idx = -1;
     uint32_t nkey, nval, toc_size, npairs, header_seed = 0, start;
     char key[128], val[128], codec_name[64] = {0};
     uint8_t output[24], dst[8], src[8];
     int64_t largest_size = -1, current_size = -1, chapter_pos;
     struct toc_entry {
         uint32_t offset;
         uint32_t size;
     } TOC[MAX_TOC_ENTRIES];
     uint32_t header_key_part[4];
     uint8_t header_key[16] = {0};
      AADemuxContext *c = s->priv_data;
      AVIOContext *pb = s->pb;
      AVStream *st;
     int ret;
      avio_skip(pb, 4);  
     avio_skip(pb, 4);  
     toc_size = avio_rb32(pb);  
     avio_skip(pb, 4);  
     if (toc_size > MAX_TOC_ENTRIES)
         return AVERROR_INVALIDDATA;
     for (i = 0; i < toc_size; i++) {  
         avio_skip(pb, 4);  
         TOC[i].offset = avio_rb32(pb);  
         TOC[i].size = avio_rb32(pb);  
     }
     avio_skip(pb, 24);  
     npairs = avio_rb32(pb);  
     if (npairs > MAX_DICTIONARY_ENTRIES)
         return AVERROR_INVALIDDATA;
     for (i = 0; i < npairs; i++) {
         memset(val, 0, sizeof(val));
         memset(key, 0, sizeof(key));
         avio_skip(pb, 1);  
         nkey = avio_rb32(pb);  
         nval = avio_rb32(pb);  
         avio_get_str(pb, nkey, key, sizeof(key));
         avio_get_str(pb, nval, val, sizeof(val));
         if (!strcmp(key, ""codec"")) {
             av_log(s, AV_LOG_DEBUG, ""Codec is <%s>\n"", val);
             strncpy(codec_name, val, sizeof(codec_name) - 1);
         } else if (!strcmp(key, ""HeaderSeed"")) {
             av_log(s, AV_LOG_DEBUG, ""HeaderSeed is <%s>\n"", val);
              header_seed = atoi(val);
          } else if (!strcmp(key, ""HeaderKey"")) {  
              av_log(s, AV_LOG_DEBUG, ""HeaderKey is <%s>\n"", val);
            sscanf(val, ""%""SCNu32""%""SCNu32""%""SCNu32""%""SCNu32,
             ret = sscanf(val, ""%""SCNu32""%""SCNu32""%""SCNu32""%""SCNu32,
                     &header_key_part[0], &header_key_part[1], &header_key_part[2], &header_key_part[3]);
             if (ret != 4)
                 return AVERROR_INVALIDDATA;
              for (idx = 0; idx < 4; idx++) {
                  AV_WB32(&header_key[idx * 4], header_key_part[idx]);  
              }
             av_log(s, AV_LOG_DEBUG, ""Processed HeaderKey is "");
             for (i = 0; i < 16; i++)
                 av_log(s, AV_LOG_DEBUG, ""%02x"", header_key[i]);
             av_log(s, AV_LOG_DEBUG, ""\n"");
         } else {
             av_dict_set(&s->metadata, key, val, 0);
         }
     }
     if (c->aa_fixed_key_len != 16) {
         av_log(s, AV_LOG_ERROR, ""aa_fixed_key value needs to be 16 bytes!\n"");
         return AVERROR(EINVAL);
     }
     if ((c->codec_second_size = get_second_size(codec_name)) == -1) {
         av_log(s, AV_LOG_ERROR, ""unknown codec <%s>!\n"", codec_name);
         return AVERROR(EINVAL);
     }
     c->tea_ctx = av_tea_alloc();
     if (!c->tea_ctx)
         return AVERROR(ENOMEM);
     av_tea_init(c->tea_ctx, c->aa_fixed_key, 16);
     output[0] = output[1] = 0;  
     memcpy(output + 2, header_key, 16);
     idx = 0;
     for (i = 0; i < 3; i++) {  
         AV_WB32(src, header_seed);
         AV_WB32(src + 4, header_seed + 1);
         header_seed += 2;
         av_tea_crypt(c->tea_ctx, dst, src, 1, NULL, 0);  
         for (j = 0; j < TEA_BLOCK_SIZE && idx < 18; j+=1, idx+=1) {
             output[idx] = output[idx] ^ dst[j];
         }
     }
     memcpy(c->file_key, output + 2, 16);  
     av_log(s, AV_LOG_DEBUG, ""File key is "");
     for (i = 0; i < 16; i++)
         av_log(s, AV_LOG_DEBUG, ""%02x"", c->file_key[i]);
     av_log(s, AV_LOG_DEBUG, ""\n"");
     st = avformat_new_stream(s, NULL);
     if (!st) {
         av_freep(&c->tea_ctx);
         return AVERROR(ENOMEM);
     }
     st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;
     if (!strcmp(codec_name, ""mp332"")) {
         st->codecpar->codec_id = AV_CODEC_ID_MP3;
         st->codecpar->sample_rate = 22050;
         st->need_parsing = AVSTREAM_PARSE_FULL_RAW;
         avpriv_set_pts_info(st, 64, 8, 32000 * TIMEPREC);
     } else if (!strcmp(codec_name, ""acelp85"")) {
         st->codecpar->codec_id = AV_CODEC_ID_SIPR;
         st->codecpar->block_align = 19;
         st->codecpar->channels = 1;
         st->codecpar->sample_rate = 8500;
         st->codecpar->bit_rate = 8500;
         st->need_parsing = AVSTREAM_PARSE_FULL_RAW;
         avpriv_set_pts_info(st, 64, 8, 8500 * TIMEPREC);
     } else if (!strcmp(codec_name, ""acelp16"")) {
         st->codecpar->codec_id = AV_CODEC_ID_SIPR;
         st->codecpar->block_align = 20;
         st->codecpar->channels = 1;
         st->codecpar->sample_rate = 16000;
         st->codecpar->bit_rate = 16000;
         st->need_parsing = AVSTREAM_PARSE_FULL_RAW;
         avpriv_set_pts_info(st, 64, 8, 16000 * TIMEPREC);
     }
     for (i = 1; i < toc_size; i++) {  
         current_size = TOC[i].size;
         if (current_size > largest_size) {
             largest_idx = i;
             largest_size = current_size;
         }
     }
     start = TOC[largest_idx].offset;
     avio_seek(pb, start, SEEK_SET);
     st->start_time = 0;
     c->content_start = start;
     c->content_end = start + largest_size;
     while ((chapter_pos = avio_tell(pb)) >= 0 && chapter_pos < c->content_end) {
         int chapter_idx = s->nb_chapters;
         uint32_t chapter_size = avio_rb32(pb);
         if (chapter_size == 0) break;
         chapter_pos -= start + CHAPTER_HEADER_SIZE * chapter_idx;
         avio_skip(pb, 4 + chapter_size);
         if (!avpriv_new_chapter(s, chapter_idx, st->time_base,
             chapter_pos * TIMEPREC, (chapter_pos + chapter_size) * TIMEPREC, NULL))
                 return AVERROR(ENOMEM);
     }
     st->duration = (largest_size - CHAPTER_HEADER_SIZE * s->nb_chapters) * TIMEPREC;
     ff_update_cur_dts(s, st, 0);
     avio_seek(pb, start, SEEK_SET);
     c->current_chapter_size = 0;
     c->seek_offset = 0;
     return 0;
 }","[17, 49, 50, 52, 53]",aa_read_header in libavformat/aadec.c in FFmpeg before 3.2.14 and 4.x before 4.1.4 does not check for sscanf failure and consequently allows use of uninitialized variables.,FFmpeg,CVE-2019-12730,CWE-665
388,182218," int sc_asn1_read_tag(const u8 ** buf, size_t buflen, unsigned int *cla_out,
 		     unsigned int *tag_out, size_t *taglen)
 {
 	const u8 *p = *buf;
 	size_t left = buflen, len;
 	unsigned int cla, tag, i;
 	if (left < 2)
 		return SC_ERROR_INVALID_ASN1_OBJECT;
 	*buf = NULL;
 	if (*p == 0xff || *p == 0) {
 		*taglen = 0;
 		*tag_out = SC_ASN1_TAG_EOC;
 		return SC_SUCCESS;
 	}
 	cla = (*p & SC_ASN1_TAG_CLASS) | (*p & SC_ASN1_TAG_CONSTRUCTED);
 	tag = *p & SC_ASN1_TAG_PRIMITIVE;
 	p++;
 	left--;
 	if (tag == SC_ASN1_TAG_PRIMITIVE) {
 		size_t n = SC_ASN1_TAGNUM_SIZE - 1;
 		while (left-- != 0 && n != 0) {
 			tag <<= 8;
 			tag |= *p;
 			if ((*p++ & 0x80) == 0)
 				break;
 			n--;
 		}
 		if (left == 0 || n == 0)
 			return SC_ERROR_INVALID_ASN1_OBJECT;
 	}
  	len = *p & 0x7f;
  	if (*p++ & 0x80) {
  		unsigned int a = 0;
 		left--;
  		if (len > 4 || len > left)
  			return SC_ERROR_INVALID_ASN1_OBJECT;
  		left -= len;
 		for (i = 0; i < len; i++) {
 			a <<= 8;
 			a |= *p;
 			p++;
 		}
 		len = a;
 	}
 	*cla_out = cla;
 	*tag_out = tag;
 	*taglen = len;
 	*buf = p;
 	if (len > left)
 		return SC_ERROR_ASN1_END_OF_CONTENTS;
 	return SC_SUCCESS;
 }",[34],Various out of bounds reads when handling responses in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to potentially crash the opensc library using programs.,OpenSC,CVE-2018-16427,CWE-125
397,182362,"  av_cold void ff_mpv_idct_init(MpegEncContext *s)
  {
     if (s->codec_id == AV_CODEC_ID_MPEG4)
         s->idsp.mpeg4_studio_profile = s->studio_profile;
      ff_idctdsp_init(&s->idsp, s->avctx);
     if (s->alternate_scan) {
         ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_alternate_vertical_scan);
         ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_alternate_vertical_scan);
     } else {
         ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_zigzag_direct);
         ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_zigzag_direct);
     }
     ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan);
     ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);
 }","[3, 4]","libavcodec in FFmpeg 4.0 may trigger a NULL pointer dereference if the studio profile is incorrectly detected while converting a crafted AVI file to MPEG4, leading to a denial of service, related to idctdsp.c and mpegvideo.c.",FFmpeg,CVE-2018-12460,CWE-476
413,180939," atol10(const char *p, size_t char_cnt)
 {
  	uint64_t l;
  	int digit;
 	if (char_cnt == 0)
 		return (0);
  	l = 0;
  	digit = *p - '0';
  	while (digit >= 0 && digit < 10  && char_cnt-- > 0) {
 		l = (l * 10) + digit;
 		digit = *++p - '0';
 	}
 	return (l);
 }","[5, 6]","libarchive 3.3.2 allows remote attackers to cause a denial of service (xml_data heap-based buffer over-read and application crash) via a crafted xar archive, related to the mishandling of empty strings in the atol8 function in archive_read_support_format_xar.c.",libarchive,CVE-2017-14166,CWE-125
423,179587," txid_current_snapshot(PG_FUNCTION_ARGS)
 {
 	TxidSnapshot *snap;
 	uint32		nxip,
 				i,
 				size;
 	TxidEpoch	state;
 	Snapshot	cur;
 	cur = GetActiveSnapshot();
 	if (cur == NULL)
 		elog(ERROR, ""no active snapshot set"");
  	load_xid_epoch(&state);
 	StaticAssertStmt(MAX_BACKENDS * 2 <= TXID_SNAPSHOT_MAX_NXIP,
 					 ""possible overflow in txid_current_snapshot()"");
  	nxip = cur->xcnt;
  	size = TXID_SNAPSHOT_SIZE(nxip);
 	snap = palloc(size);
 	SET_VARSIZE(snap, size);
 	snap->xmin = convert_xid(cur->xmin, &state);
 	snap->xmax = convert_xid(cur->xmax, &state);
 	snap->nxip = nxip;
 	for (i = 0; i < nxip; i++)
 		snap->xip[i] = convert_xid(cur->xip[i], &state);
 	sort_snapshot(snap);
 	PG_RETURN_POINTER(snap);
 }","[13, 14]","Multiple integer overflows in contrib/hstore/hstore_io.c in PostgreSQL 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact via vectors related to the (1) hstore_recv, (2) hstore_from_arrays, and (3) hstore_from_array functions in contrib/hstore/hstore_io.c; and the (4) hstoreArrayToPairs function in contrib/hstore/hstore_op.c, which triggers a buffer overflow.  NOTE: this issue was SPLIT from CVE-2014-0064 because it has a different set of affected versions.",postgres,CVE-2014-2669,CWE-189
454,181897,"  int mif_validate(jas_stream_t *in)
  {
	uchar buf[MIF_MAGICLEN];
 	jas_uchar buf[MIF_MAGICLEN];
  	uint_fast32_t magic;
  	int i;
  	int n;
 	assert(JAS_STREAM_MAXPUTBACK >= MIF_MAGICLEN);
 	if ((n = jas_stream_read(in, buf, MIF_MAGICLEN)) < 0) {
 		return -1;
 	}
 	for (i = n - 1; i >= 0; --i) {
 		if (jas_stream_ungetc(in, buf[i]) == EOF) {
 			return -1;
 		}
 	}
 	if (n < MIF_MAGICLEN) {
 		return -1;
 	}
 	magic = (JAS_CAST(uint_fast32_t, buf[0]) << 24) |
 	  (JAS_CAST(uint_fast32_t, buf[1]) << 16) |
 	  (JAS_CAST(uint_fast32_t, buf[2]) << 8) |
 	  buf[3];
 	if (magic != MIF_MAGIC) {
 		return -1;
 	}
 	return 0;
 }","[3, 4]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
486,178053," void CtcpHandler::parse(Message::Type messageType, const QString &prefix, const QString &target, const QByteArray &message) {
   QByteArray ctcp;
   QByteArray dequotedMessage = lowLevelDequote(message);
   CtcpType ctcptype = messageType == Message::Notice
     ? CtcpReply
     : CtcpQuery;
   Message::Flags flags = (messageType == Message::Notice && !network()->isChannelName(target))
     ? Message::Redirected
     : Message::None;
    int xdelimPos = -1;
    int xdelimEndPos = -1;
    int spacePos = -1;
   QList<QByteArray> replies;
    while((xdelimPos = dequotedMessage.indexOf(XDELIM)) != -1) {
      if(xdelimPos > 0)
        displayMsg(messageType, target, userDecode(target, dequotedMessage.left(xdelimPos)), prefix, flags);
     xdelimEndPos = dequotedMessage.indexOf(XDELIM, xdelimPos + 1);
     if(xdelimEndPos == -1) {
       xdelimEndPos = dequotedMessage.count();
     }
     ctcp = xdelimDequote(dequotedMessage.mid(xdelimPos + 1, xdelimEndPos - xdelimPos - 1));
     dequotedMessage = dequotedMessage.mid(xdelimEndPos + 1);
     QString ctcpcmd = userDecode(target, ctcp.left(spacePos));
     QString ctcpparam = userDecode(target, ctcp.mid(spacePos + 1));
     spacePos = ctcp.indexOf(' ');
     if(spacePos != -1) {
       ctcpcmd = userDecode(target, ctcp.left(spacePos));
       ctcpparam = userDecode(target, ctcp.mid(spacePos + 1));
     } else {
       ctcpcmd = userDecode(target, ctcp);
       ctcpparam = QString();
        ctcpparam = QString();
      }
    handle(ctcpcmd, Q_ARG(CtcpType, ctcptype), Q_ARG(QString, prefix), Q_ARG(QString, target), Q_ARG(QString, ctcpparam));
     if(!_ignoreListManager->ctcpMatch(prefix, network()->networkName(), ctcpcmd.toUpper())) {
       QString reply_;
       handle(ctcpcmd, Q_ARG(CtcpType, ctcptype), Q_ARG(QString, prefix), Q_ARG(QString, target), Q_ARG(QString, ctcpparam), Q_ARG(QString, reply_));
       if(ctcptype == CtcpQuery && !reply_.isNull()) {
         replies << lowLevelQuote(pack(serverEncode(ctcpcmd), userEncode(nickFromMask(prefix), reply_)));
       }
     }
   }
   if(ctcptype == CtcpQuery && !replies.isEmpty()) {
     packedReply(nickFromMask(prefix), replies);
    }
    if(!dequotedMessage.isEmpty())
 void CtcpHandler::query(const QString &bufname, const QString &ctcpTag, const QString &message) {
   QList<QByteArray> params;
   params << serverEncode(bufname) << lowLevelQuote(pack(serverEncode(ctcpTag), userEncode(bufname, message)));
   emit putCmd(""PRIVMSG"", params);
 }
 void CtcpHandler::reply(const QString &bufname, const QString &ctcpTag, const QString &message) {
   QList<QByteArray> params;
   params << serverEncode(bufname) << lowLevelQuote(pack(serverEncode(ctcpTag), userEncode(bufname, message)));
   emit putCmd(""NOTICE"", params);
 }
 void CtcpHandler::handleAction(CtcpType ctcptype, const QString &prefix, const QString &target, const QString &param) {
   Q_UNUSED(ctcptype)
   emit displayMsg(Message::Action, typeByTarget(target), target, param, prefix);
 }
    emit putCmd(""NOTICE"", params);
  }","[13, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44]",ctcphandler.cpp in Quassel before 0.6.3 and 0.7.x before 0.7.1 allows remote attackers to cause a denial of service (unresponsive IRC) via multiple Client-To-Client Protocol (CTCP) requests in a PRIVMSG message.,quassel,CVE-2010-3443,CWE-399
508,179169," static int filter_frame(AVFilterLink *inlink, AVFrame *in)
 {
     AVFilterContext *ctx = inlink->dst;
     BoxBlurContext *s = ctx->priv;
     AVFilterLink *outlink = inlink->dst->outputs[0];
     AVFrame *out;
     int plane;
     int cw = FF_CEIL_RSHIFT(inlink->w, s->hsub), ch = FF_CEIL_RSHIFT(in->height, s->vsub);
     int w[4] = { inlink->w, cw, cw, inlink->w };
     int h[4] = { in->height, ch, ch, in->height };
     out = ff_get_video_buffer(outlink, outlink->w, outlink->h);
     if (!out) {
         av_frame_free(&in);
         return AVERROR(ENOMEM);
      }
      av_frame_copy_props(out, in);
    for (plane = 0; in->data[plane] && plane < 4; plane++)
     for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++)
          hblur(out->data[plane], out->linesize[plane],
                in ->data[plane], in ->linesize[plane],
                w[plane], h[plane], s->radius[plane], s->power[plane],
                s->temp);
    for (plane = 0; in->data[plane] && plane < 4; plane++)
     for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++)
          vblur(out->data[plane], out->linesize[plane],
                out->data[plane], out->linesize[plane],
                w[plane], h[plane], s->radius[plane], s->power[plane],
               s->temp);
     av_frame_free(&in);
     return ff_filter_frame(outlink, out);
 }","[17, 18, 23, 24]","libavfilter in FFmpeg before 2.0.1 has unspecified impact and remote vectors related to a crafted *plane,* which triggers an out-of-bounds heap write.",FFmpeg,CVE-2013-4263,CWE-119
517,177922,"  void add_param_to_argv(char *parsestart, int line)
  {
	int quote_open = 0, escaped = 0, param_len = 0;
	char param_buffer[1024], *curchar;
 	int quote_open = 0, escaped = 0;
 	struct xt_param_buf param = {};
 	char *curchar;
 			param_buffer[param_len++] = *curchar;
 			if (param_len >= sizeof(param_buffer))
 				xtables_error(PARAMETER_PROBLEM,
  		case ' ':
  		case '\t':
  		case '\n':
			if (!param_len) {
 			if (!param.len) {
  				continue;
  			}
  			break;
  		default:
			param_buffer[param_len++] = *curchar;
			if (param_len >= sizeof(param_buffer))
				xtables_error(PARAMETER_PROBLEM,
					      ""Parameter too long!"");
 			add_param(&param, curchar);
  			continue;
  		}
		param_buffer[param_len] = '\0';
 		param.buffer[param.len] = '\0';
		if ((param_buffer[0] == '-' &&
		     param_buffer[1] != '-' &&
		     strchr(param_buffer, 't')) ||
		    (!strncmp(param_buffer, ""--t"", 3) &&
		     !strncmp(param_buffer, ""--table"", strlen(param_buffer)))) {
 		if ((param.buffer[0] == '-' &&
 		     param.buffer[1] != '-' &&
 		     strchr(param.buffer, 't')) ||
 		    (!strncmp(param.buffer, ""--t"", 3) &&
 		     !strncmp(param.buffer, ""--table"", strlen(param.buffer)))) {
  			xtables_error(PARAMETER_PROBLEM,
  				      ""The -t option (seen in line %u) cannot be used in %s.\n"",
  				      line, xt_params->program_name);
  		}
		add_argv(param_buffer, 0);
		param_len = 0;
 		add_argv(param.buffer, 0);
 		param.len = 0;
  	}","[3, 4, 5, 6, 7, 14, 15, 20, 21, 22, 23, 24, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 43, 44, 45, 46]",A buffer overflow in iptables-restore in netfilter iptables 1.8.2 allows an attacker to (at least) crash the program or potentially gain code execution via a specially crafted iptables-save file. This is related to add_param_to_argv in xshared.c.,netfilter,CVE-2019-11360,CWE-119
518,181650,"  int jpc_tsfb_synthesize(jpc_tsfb_t *tsfb, jas_seq2d_t *a)
  {
	return (tsfb->numlvls > 0) ? jpc_tsfb_synthesize2(tsfb,
 	return (tsfb->numlvls > 0 && jas_seq2d_size(a)) ?
 	  jpc_tsfb_synthesize2(tsfb,
  	  jas_seq2d_getref(a, jas_seq2d_xstart(a), jas_seq2d_ystart(a)),
  	  jas_seq2d_xstart(a), jas_seq2d_ystart(a), jas_seq2d_width(a),
  	  jas_seq2d_height(a), jas_seq2d_rowstep(a), tsfb->numlvls - 1) : 0;
 }","[3, 4, 5]",The jpc_tsfb_synthesize function in jpc_tsfb.c in JasPer before 1.900.9 allows remote attackers to cause a denial of service (NULL pointer dereference) via vectors involving an empty sequence.,jasper,CVE-2016-10248,CWE-476
539,181935," static int bmp_getint32(jas_stream_t *in, int_fast32_t *val)
 {
 	int n;
 	uint_fast32_t v;
 	int c;
 	for (n = 4, v = 0;;) {
  		if ((c = jas_stream_getc(in)) == EOF) {
  			return -1;
  		}
		v |= (c << 24);
 		v |= (JAS_CAST(uint_fast32_t, c) << 24);
  		if (--n <= 0) {
  			break;
  		}
 		v >>= 8;
 	}
 	if (val) {
 		*val = v;
 	}
 	return 0;
 }","[10, 11]",The bmp_getdata function in libjasper/bmp/bmp_dec.c in JasPer before 1.900.5 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted BMP image in an imginfo command.,jasper,CVE-2016-8690,CWE-476
544,181653," yyparse (void *yyscanner, YR_COMPILER* compiler)
 {
 int yychar;
 YY_INITIAL_VALUE (static YYSTYPE yyval_default;)
 YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
     int yynerrs;
     int yystate;
     int yyerrstatus;
     yytype_int16 yyssa[YYINITDEPTH];
     yytype_int16 *yyss;
     yytype_int16 *yyssp;
     YYSTYPE yyvsa[YYINITDEPTH];
     YYSTYPE *yyvs;
     YYSTYPE *yyvsp;
     YYSIZE_T yystacksize;
   int yyn;
   int yyresult;
   int yytoken = 0;
   YYSTYPE yyval;
 #if YYERROR_VERBOSE
   char yymsgbuf[128];
   char *yymsg = yymsgbuf;
   YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
 #endif
 #define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
   int yylen = 0;
   yyssp = yyss = yyssa;
   yyvsp = yyvs = yyvsa;
   yystacksize = YYINITDEPTH;
   YYDPRINTF ((stderr, ""Starting parse\n""));
   yystate = 0;
   yyerrstatus = 0;
   yynerrs = 0;
   yychar = YYEMPTY;  
   goto yysetstate;
  yynewstate:
   yyssp++;
  yysetstate:
   *yyssp = yystate;
   if (yyss + yystacksize - 1 <= yyssp)
     {
       YYSIZE_T yysize = yyssp - yyss + 1;
 #ifdef yyoverflow
       {
         YYSTYPE *yyvs1 = yyvs;
         yytype_int16 *yyss1 = yyss;
         yyoverflow (YY_(""memory exhausted""),
                     &yyss1, yysize * sizeof (*yyssp),
                     &yyvs1, yysize * sizeof (*yyvsp),
                     &yystacksize);
         yyss = yyss1;
         yyvs = yyvs1;
       }
 #else  
 # ifndef YYSTACK_RELOCATE
       goto yyexhaustedlab;
 # else
       if (YYMAXDEPTH <= yystacksize)
         goto yyexhaustedlab;
       yystacksize *= 2;
       if (YYMAXDEPTH < yystacksize)
         yystacksize = YYMAXDEPTH;
       {
         yytype_int16 *yyss1 = yyss;
         union yyalloc *yyptr =
           (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
         if (! yyptr)
           goto yyexhaustedlab;
         YYSTACK_RELOCATE (yyss_alloc, yyss);
         YYSTACK_RELOCATE (yyvs_alloc, yyvs);
 #  undef YYSTACK_RELOCATE
         if (yyss1 != yyssa)
           YYSTACK_FREE (yyss1);
       }
 # endif
 #endif  
       yyssp = yyss + yysize - 1;
       yyvsp = yyvs + yysize - 1;
       YYDPRINTF ((stderr, ""Stack size increased to %lu\n"",
                   (unsigned long int) yystacksize));
       if (yyss + yystacksize - 1 <= yyssp)
         YYABORT;
     }
   YYDPRINTF ((stderr, ""Entering state %d\n"", yystate));
   if (yystate == YYFINAL)
     YYACCEPT;
   goto yybackup;
 yybackup:
   yyn = yypact[yystate];
   if (yypact_value_is_default (yyn))
     goto yydefault;
   if (yychar == YYEMPTY)
     {
       YYDPRINTF ((stderr, ""Reading a token: ""));
       yychar = yylex (&yylval, yyscanner, compiler);
     }
   if (yychar <= YYEOF)
     {
       yychar = yytoken = YYEOF;
       YYDPRINTF ((stderr, ""Now at end of input.\n""));
     }
   else
     {
       yytoken = YYTRANSLATE (yychar);
       YY_SYMBOL_PRINT (""Next token is"", yytoken, &yylval, &yylloc);
     }
   yyn += yytoken;
   if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
     goto yydefault;
   yyn = yytable[yyn];
   if (yyn <= 0)
     {
       if (yytable_value_is_error (yyn))
         goto yyerrlab;
       yyn = -yyn;
       goto yyreduce;
     }
   if (yyerrstatus)
     yyerrstatus--;
   YY_SYMBOL_PRINT (""Shifting"", yytoken, &yylval, &yylloc);
   yychar = YYEMPTY;
   yystate = yyn;
   YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
   *++yyvsp = yylval;
   YY_IGNORE_MAYBE_UNINITIALIZED_END
   goto yynewstate;
 yydefault:
   yyn = yydefact[yystate];
   if (yyn == 0)
     goto yyerrlab;
   goto yyreduce;
 yyreduce:
   yylen = yyr2[yyn];
   yyval = yyvsp[1-yylen];
   YY_REDUCE_PRINT (yyn);
   switch (yyn)
     {
         case 8:
 #line 230 ""grammar.y""  
     {
         int result = yr_parser_reduce_import(yyscanner, (yyvsp[0].sized_string));
         yr_free((yyvsp[0].sized_string));
         ERROR_IF(result != ERROR_SUCCESS);
       }
 #line 1661 ""grammar.c""  
     break;
   case 9:
 #line 242 ""grammar.y""  
     {
         YR_RULE* rule = yr_parser_reduce_rule_declaration_phase_1(
             yyscanner, (int32_t) (yyvsp[-2].integer), (yyvsp[0].c_string));
         ERROR_IF(rule == NULL);
         (yyval.rule) = rule;
       }
 #line 1674 ""grammar.c""  
     break;
   case 10:
 #line 251 ""grammar.y""  
     {
         YR_RULE* rule = (yyvsp[-4].rule);  
         rule->tags = (yyvsp[-3].c_string);
         rule->metas = (yyvsp[-1].meta);
         rule->strings = (yyvsp[0].string);
       }
 #line 1686 ""grammar.c""  
     break;
   case 11:
 #line 259 ""grammar.y""  
     {
         YR_RULE* rule = (yyvsp[-7].rule);  
         compiler->last_result = yr_parser_reduce_rule_declaration_phase_2(
             yyscanner, rule);
         yr_free((yyvsp[-8].c_string));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
 #line 1701 ""grammar.c""  
     break;
   case 12:
 #line 274 ""grammar.y""  
     {
         (yyval.meta) = NULL;
       }
 #line 1709 ""grammar.c""  
     break;
   case 13:
 #line 278 ""grammar.y""  
     {
         YR_META null_meta;
         memset(&null_meta, 0xFF, sizeof(YR_META));
         null_meta.type = META_TYPE_NULL;
         compiler->last_result = yr_arena_write_data(
             compiler->metas_arena,
             &null_meta,
             sizeof(YR_META),
             NULL);
         (yyval.meta) = (yyvsp[0].meta);
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
 #line 1736 ""grammar.c""  
     break;
   case 14:
 #line 305 ""grammar.y""  
     {
         (yyval.string) = NULL;
       }
 #line 1744 ""grammar.c""  
     break;
   case 15:
 #line 309 ""grammar.y""  
     {
         YR_STRING null_string;
         memset(&null_string, 0xFF, sizeof(YR_STRING));
         null_string.g_flags = STRING_GFLAGS_NULL;
         compiler->last_result = yr_arena_write_data(
             compiler->strings_arena,
             &null_string,
             sizeof(YR_STRING),
             NULL);
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         (yyval.string) = (yyvsp[0].string);
       }
 #line 1771 ""grammar.c""  
     break;
   case 17:
 #line 340 ""grammar.y""  
     { (yyval.integer) = 0;  }
 #line 1777 ""grammar.c""  
     break;
   case 18:
 #line 341 ""grammar.y""  
     { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }
 #line 1783 ""grammar.c""  
     break;
   case 19:
 #line 346 ""grammar.y""  
     { (yyval.integer) = RULE_GFLAGS_PRIVATE; }
 #line 1789 ""grammar.c""  
     break;
   case 20:
 #line 347 ""grammar.y""  
     { (yyval.integer) = RULE_GFLAGS_GLOBAL; }
 #line 1795 ""grammar.c""  
     break;
   case 21:
 #line 353 ""grammar.y""  
     {
         (yyval.c_string) = NULL;
       }
 #line 1803 ""grammar.c""  
     break;
   case 22:
 #line 357 ""grammar.y""  
     {
         compiler->last_result = yr_arena_write_string(
             yyget_extra(yyscanner)->sz_arena, """", NULL);
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         (yyval.c_string) = (yyvsp[0].c_string);
       }
 #line 1821 ""grammar.c""  
     break;
   case 23:
 #line 375 ""grammar.y""  
     {
         char* identifier;
         compiler->last_result = yr_arena_write_string(
             yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), &identifier);
         yr_free((yyvsp[0].c_string));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         (yyval.c_string) = identifier;
       }
 #line 1838 ""grammar.c""  
     break;
   case 24:
 #line 388 ""grammar.y""  
     {
         char* tag_name = (yyvsp[-1].c_string);
         size_t tag_length = tag_name != NULL ? strlen(tag_name) : 0;
         while (tag_length > 0)
         {
           if (strcmp(tag_name, (yyvsp[0].c_string)) == 0)
           {
             yr_compiler_set_error_extra_info(compiler, tag_name);
             compiler->last_result = ERROR_DUPLICATED_TAG_IDENTIFIER;
             break;
           }
           tag_name = (char*) yr_arena_next_address(
               yyget_extra(yyscanner)->sz_arena,
               tag_name,
               tag_length + 1);
           tag_length = tag_name != NULL ? strlen(tag_name) : 0;
         }
         if (compiler->last_result == ERROR_SUCCESS)
           compiler->last_result = yr_arena_write_string(
               yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), NULL);
         yr_free((yyvsp[0].c_string));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         (yyval.c_string) = (yyvsp[-1].c_string);
       }
 #line 1874 ""grammar.c""  
     break;
   case 25:
 #line 424 ""grammar.y""  
     {  (yyval.meta) = (yyvsp[0].meta); }
 #line 1880 ""grammar.c""  
     break;
   case 26:
 #line 425 ""grammar.y""  
     {  (yyval.meta) = (yyvsp[-1].meta); }
 #line 1886 ""grammar.c""  
     break;
   case 27:
 #line 431 ""grammar.y""  
     {
         SIZED_STRING* sized_string = (yyvsp[0].sized_string);
         (yyval.meta) = yr_parser_reduce_meta_declaration(
             yyscanner,
             META_TYPE_STRING,
             (yyvsp[-2].c_string),
             sized_string->c_string,
             0);
         yr_free((yyvsp[-2].c_string));
         yr_free((yyvsp[0].sized_string));
         ERROR_IF((yyval.meta) == NULL);
       }
 #line 1906 ""grammar.c""  
     break;
   case 28:
 #line 447 ""grammar.y""  
     {
         (yyval.meta) = yr_parser_reduce_meta_declaration(
             yyscanner,
             META_TYPE_INTEGER,
             (yyvsp[-2].c_string),
             NULL,
             (yyvsp[0].integer));
         yr_free((yyvsp[-2].c_string));
         ERROR_IF((yyval.meta) == NULL);
       }
 #line 1923 ""grammar.c""  
     break;
   case 29:
 #line 460 ""grammar.y""  
     {
         (yyval.meta) = yr_parser_reduce_meta_declaration(
             yyscanner,
             META_TYPE_INTEGER,
             (yyvsp[-3].c_string),
             NULL,
             -(yyvsp[0].integer));
         yr_free((yyvsp[-3].c_string));
         ERROR_IF((yyval.meta) == NULL);
       }
 #line 1940 ""grammar.c""  
     break;
   case 30:
 #line 473 ""grammar.y""  
     {
         (yyval.meta) = yr_parser_reduce_meta_declaration(
             yyscanner,
             META_TYPE_BOOLEAN,
             (yyvsp[-2].c_string),
             NULL,
             TRUE);
         yr_free((yyvsp[-2].c_string));
         ERROR_IF((yyval.meta) == NULL);
       }
 #line 1957 ""grammar.c""  
     break;
   case 31:
 #line 486 ""grammar.y""  
     {
         (yyval.meta) = yr_parser_reduce_meta_declaration(
             yyscanner,
             META_TYPE_BOOLEAN,
             (yyvsp[-2].c_string),
             NULL,
             FALSE);
         yr_free((yyvsp[-2].c_string));
         ERROR_IF((yyval.meta) == NULL);
       }
 #line 1974 ""grammar.c""  
     break;
   case 32:
 #line 502 ""grammar.y""  
     { (yyval.string) = (yyvsp[0].string); }
 #line 1980 ""grammar.c""  
     break;
   case 33:
 #line 503 ""grammar.y""  
     { (yyval.string) = (yyvsp[-1].string); }
 #line 1986 ""grammar.c""  
     break;
   case 34:
 #line 509 ""grammar.y""  
     {
         compiler->error_line = yyget_lineno(yyscanner);
       }
 #line 1994 ""grammar.c""  
     break;
   case 35:
 #line 513 ""grammar.y""  
     {
         (yyval.string) = yr_parser_reduce_string_declaration(
             yyscanner, (int32_t) (yyvsp[0].integer), (yyvsp[-4].c_string), (yyvsp[-1].sized_string));
         yr_free((yyvsp[-4].c_string));
         yr_free((yyvsp[-1].sized_string));
         ERROR_IF((yyval.string) == NULL);
         compiler->error_line = 0;
       }
 #line 2009 ""grammar.c""  
     break;
   case 36:
 #line 524 ""grammar.y""  
     {
         compiler->error_line = yyget_lineno(yyscanner);
       }
 #line 2017 ""grammar.c""  
     break;
   case 37:
 #line 528 ""grammar.y""  
     {
         (yyval.string) = yr_parser_reduce_string_declaration(
             yyscanner, (int32_t) (yyvsp[0].integer) | STRING_GFLAGS_REGEXP, (yyvsp[-4].c_string), (yyvsp[-1].sized_string));
         yr_free((yyvsp[-4].c_string));
         yr_free((yyvsp[-1].sized_string));
         ERROR_IF((yyval.string) == NULL);
         compiler->error_line = 0;
       }
 #line 2033 ""grammar.c""  
     break;
   case 38:
 #line 540 ""grammar.y""  
     {
         (yyval.string) = yr_parser_reduce_string_declaration(
             yyscanner, STRING_GFLAGS_HEXADECIMAL, (yyvsp[-2].c_string), (yyvsp[0].sized_string));
         yr_free((yyvsp[-2].c_string));
         yr_free((yyvsp[0].sized_string));
         ERROR_IF((yyval.string) == NULL);
       }
 #line 2047 ""grammar.c""  
     break;
   case 39:
 #line 553 ""grammar.y""  
     { (yyval.integer) = 0; }
 #line 2053 ""grammar.c""  
     break;
   case 40:
 #line 554 ""grammar.y""  
     { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }
 #line 2059 ""grammar.c""  
     break;
   case 41:
 #line 559 ""grammar.y""  
     { (yyval.integer) = STRING_GFLAGS_WIDE; }
 #line 2065 ""grammar.c""  
     break;
   case 42:
 #line 560 ""grammar.y""  
     { (yyval.integer) = STRING_GFLAGS_ASCII; }
 #line 2071 ""grammar.c""  
     break;
   case 43:
 #line 561 ""grammar.y""  
     { (yyval.integer) = STRING_GFLAGS_NO_CASE; }
 #line 2077 ""grammar.c""  
     break;
   case 44:
 #line 562 ""grammar.y""  
     { (yyval.integer) = STRING_GFLAGS_FULL_WORD; }
 #line 2083 ""grammar.c""  
     break;
   case 45:
 #line 568 ""grammar.y""  
     {
         int var_index = yr_parser_lookup_loop_variable(yyscanner, (yyvsp[0].c_string));
         if (var_index >= 0)
         {
           compiler->last_result = yr_parser_emit_with_arg(
               yyscanner,
               OP_PUSH_M,
               LOOP_LOCAL_VARS * var_index,
               NULL,
               NULL);
           (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
           (yyval.expression).value.integer = UNDEFINED;
           (yyval.expression).identifier = compiler->loop_identifier[var_index];
         }
         else
         {
           YR_OBJECT* object = (YR_OBJECT*) yr_hash_table_lookup(
               compiler->objects_table, (yyvsp[0].c_string), NULL);
           if (object == NULL)
           {
             char* ns = compiler->current_namespace->name;
             object = (YR_OBJECT*) yr_hash_table_lookup(
                 compiler->objects_table, (yyvsp[0].c_string), ns);
           }
           if (object != NULL)
           {
             char* id;
             compiler->last_result = yr_arena_write_string(
                 compiler->sz_arena, (yyvsp[0].c_string), &id);
             if (compiler->last_result == ERROR_SUCCESS)
               compiler->last_result = yr_parser_emit_with_arg_reloc(
                   yyscanner,
                   OP_OBJ_LOAD,
                   id,
                   NULL,
                   NULL);
             (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
             (yyval.expression).value.object = object;
             (yyval.expression).identifier = object->identifier;
           }
           else
           {
             YR_RULE* rule = (YR_RULE*) yr_hash_table_lookup(
                 compiler->rules_table,
                 (yyvsp[0].c_string),
                 compiler->current_namespace->name);
             if (rule != NULL)
             {
               compiler->last_result = yr_parser_emit_with_arg_reloc(
                   yyscanner,
                   OP_PUSH_RULE,
                   rule,
                   NULL,
                   NULL);
               (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
               (yyval.expression).value.integer = UNDEFINED;
               (yyval.expression).identifier = rule->identifier;
             }
             else
             {
               yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
               compiler->last_result = ERROR_UNDEFINED_IDENTIFIER;
             }
           }
         }
         yr_free((yyvsp[0].c_string));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
 #line 2172 ""grammar.c""  
     break;
   case 46:
 #line 653 ""grammar.y""  
     {
         YR_OBJECT* field = NULL;
         if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_OBJECT &&
             (yyvsp[-2].expression).value.object->type == OBJECT_TYPE_STRUCTURE)
         {
           field = yr_object_lookup_field((yyvsp[-2].expression).value.object, (yyvsp[0].c_string));
           if (field != NULL)
           {
             char* ident;
             compiler->last_result = yr_arena_write_string(
               compiler->sz_arena, (yyvsp[0].c_string), &ident);
             if (compiler->last_result == ERROR_SUCCESS)
               compiler->last_result = yr_parser_emit_with_arg_reloc(
                   yyscanner,
                   OP_OBJ_FIELD,
                   ident,
                   NULL,
                   NULL);
             (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
             (yyval.expression).value.object = field;
             (yyval.expression).identifier = field->identifier;
           }
           else
           {
             yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
             compiler->last_result = ERROR_INVALID_FIELD_NAME;
           }
         }
         else
         {
           yr_compiler_set_error_extra_info(
               compiler, (yyvsp[-2].expression).identifier);
           compiler->last_result = ERROR_NOT_A_STRUCTURE;
         }
         yr_free((yyvsp[0].c_string));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
 #line 2222 ""grammar.c""  
     break;
   case 47:
 #line 699 ""grammar.y""  
     {
         YR_OBJECT_ARRAY* array;
         YR_OBJECT_DICTIONARY* dict;
         if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
             (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_ARRAY)
         {
           if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)
           {
             yr_compiler_set_error_extra_info(
                 compiler, ""array indexes must be of integer type"");
             compiler->last_result = ERROR_WRONG_TYPE;
           }
           ERROR_IF(compiler->last_result != ERROR_SUCCESS);
           compiler->last_result = yr_parser_emit(
               yyscanner, OP_INDEX_ARRAY, NULL);
           array = (YR_OBJECT_ARRAY*) (yyvsp[-3].expression).value.object;
           (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
           (yyval.expression).value.object = array->prototype_item;
           (yyval.expression).identifier = array->identifier;
         }
         else if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
                  (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_DICTIONARY)
         {
           if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_STRING)
           {
             yr_compiler_set_error_extra_info(
                 compiler, ""dictionary keys must be of string type"");
             compiler->last_result = ERROR_WRONG_TYPE;
           }
           ERROR_IF(compiler->last_result != ERROR_SUCCESS);
           compiler->last_result = yr_parser_emit(
               yyscanner, OP_LOOKUP_DICT, NULL);
           dict = (YR_OBJECT_DICTIONARY*) (yyvsp[-3].expression).value.object;
           (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
           (yyval.expression).value.object = dict->prototype_item;
           (yyval.expression).identifier = dict->identifier;
         }
         else
         {
           yr_compiler_set_error_extra_info(
               compiler, (yyvsp[-3].expression).identifier);
           compiler->last_result = ERROR_NOT_INDEXABLE;
         }
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
 #line 2283 ""grammar.c""  
     break;
   case 48:
 #line 757 ""grammar.y""  
     {
         YR_OBJECT_FUNCTION* function;
         char* args_fmt;
         if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
             (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_FUNCTION)
         {
           compiler->last_result = yr_parser_check_types(
               compiler, (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object, (yyvsp[-1].c_string));
           if (compiler->last_result == ERROR_SUCCESS)
             compiler->last_result = yr_arena_write_string(
               compiler->sz_arena, (yyvsp[-1].c_string), &args_fmt);
           if (compiler->last_result == ERROR_SUCCESS)
             compiler->last_result = yr_parser_emit_with_arg_reloc(
                 yyscanner,
                 OP_CALL,
                 args_fmt,
                 NULL,
                 NULL);
           function = (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object;
           (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
           (yyval.expression).value.object = function->return_obj;
           (yyval.expression).identifier = function->identifier;
         }
         else
         {
           yr_compiler_set_error_extra_info(
               compiler, (yyvsp[-3].expression).identifier);
           compiler->last_result = ERROR_NOT_A_FUNCTION;
         }
         yr_free((yyvsp[-1].c_string));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
 #line 2328 ""grammar.c""  
     break;
   case 49:
 #line 801 ""grammar.y""  
     { (yyval.c_string) = yr_strdup(""""); }
 #line 2334 ""grammar.c""  
     break;
   case 50:
 #line 802 ""grammar.y""  
     { (yyval.c_string) = (yyvsp[0].c_string); }
 #line 2340 ""grammar.c""  
     break;
   case 51:
 #line 807 ""grammar.y""  
     {
         (yyval.c_string) = (char*) yr_malloc(MAX_FUNCTION_ARGS + 1);
         switch((yyvsp[0].expression).type)
         {
           case EXPRESSION_TYPE_INTEGER:
             strlcpy((yyval.c_string), ""i"", MAX_FUNCTION_ARGS);
             break;
           case EXPRESSION_TYPE_FLOAT:
             strlcpy((yyval.c_string), ""f"", MAX_FUNCTION_ARGS);
             break;
           case EXPRESSION_TYPE_BOOLEAN:
             strlcpy((yyval.c_string), ""b"", MAX_FUNCTION_ARGS);
             break;
           case EXPRESSION_TYPE_STRING:
             strlcpy((yyval.c_string), ""s"", MAX_FUNCTION_ARGS);
             break;
           case EXPRESSION_TYPE_REGEXP:
             strlcpy((yyval.c_string), ""r"", MAX_FUNCTION_ARGS);
             break;
         }
         ERROR_IF((yyval.c_string) == NULL);
       }
 #line 2369 ""grammar.c""  
     break;
   case 52:
 #line 832 ""grammar.y""  
     {
         if (strlen((yyvsp[-2].c_string)) == MAX_FUNCTION_ARGS)
         {
           compiler->last_result = ERROR_TOO_MANY_ARGUMENTS;
         }
         else
         {
           switch((yyvsp[0].expression).type)
           {
             case EXPRESSION_TYPE_INTEGER:
               strlcat((yyvsp[-2].c_string), ""i"", MAX_FUNCTION_ARGS);
               break;
             case EXPRESSION_TYPE_FLOAT:
               strlcat((yyvsp[-2].c_string), ""f"", MAX_FUNCTION_ARGS);
               break;
             case EXPRESSION_TYPE_BOOLEAN:
               strlcat((yyvsp[-2].c_string), ""b"", MAX_FUNCTION_ARGS);
               break;
             case EXPRESSION_TYPE_STRING:
               strlcat((yyvsp[-2].c_string), ""s"", MAX_FUNCTION_ARGS);
               break;
             case EXPRESSION_TYPE_REGEXP:
               strlcat((yyvsp[-2].c_string), ""r"", MAX_FUNCTION_ARGS);
               break;
           }
         }
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         (yyval.c_string) = (yyvsp[-2].c_string);
       }
 #line 2405 ""grammar.c""  
     break;
   case 53:
 #line 868 ""grammar.y""  
     {
         SIZED_STRING* sized_string = (yyvsp[0].sized_string);
         RE* re;
         RE_ERROR error;
         int re_flags = 0;
         if (sized_string->flags & SIZED_STRING_FLAGS_NO_CASE)
           re_flags |= RE_FLAGS_NO_CASE;
         if (sized_string->flags & SIZED_STRING_FLAGS_DOT_ALL)
           re_flags |= RE_FLAGS_DOT_ALL;
         compiler->last_result = yr_re_compile(
             sized_string->c_string,
             re_flags,
             compiler->re_code_arena,
             &re,
             &error);
         yr_free((yyvsp[0].sized_string));
         if (compiler->last_result == ERROR_INVALID_REGULAR_EXPRESSION)
           yr_compiler_set_error_extra_info(compiler, error.message);
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         if (compiler->last_result == ERROR_SUCCESS)
           compiler->last_result = yr_parser_emit_with_arg_reloc(
               yyscanner,
               OP_PUSH,
               re->root_node->forward_code,
               NULL,
               NULL);
         yr_re_destroy(re);
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         (yyval.expression).type = EXPRESSION_TYPE_REGEXP;
       }
 #line 2451 ""grammar.c""  
     break;
   case 54:
 #line 914 ""grammar.y""  
     {
         if ((yyvsp[0].expression).type == EXPRESSION_TYPE_STRING)
         {
           if ((yyvsp[0].expression).value.sized_string != NULL)
           {
             yywarning(yyscanner,
               ""Using literal string \""%s\"" in a boolean operation."",
               (yyvsp[0].expression).value.sized_string->c_string);
           }
           compiler->last_result = yr_parser_emit(
               yyscanner, OP_STR_TO_BOOL, NULL);
           ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         }
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
 #line 2474 ""grammar.c""  
     break;
   case 55:
 #line 936 ""grammar.y""  
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, 1, NULL, NULL);
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
 #line 2487 ""grammar.c""  
     break;
   case 56:
 #line 945 ""grammar.y""  
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, 0, NULL, NULL);
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
 #line 2500 ""grammar.c""  
     break;
   case 57:
 #line 954 ""grammar.y""  
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, ""matches"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_REGEXP, ""matches"");
         if (compiler->last_result == ERROR_SUCCESS)
           compiler->last_result = yr_parser_emit(
               yyscanner,
               OP_MATCHES,
               NULL);
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
 #line 2519 ""grammar.c""  
     break;
   case 58:
 #line 969 ""grammar.y""  
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, ""contains"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_STRING, ""contains"");
         compiler->last_result = yr_parser_emit(
             yyscanner, OP_CONTAINS, NULL);
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
 #line 2535 ""grammar.c""  
     break;
   case 59:
 #line 981 ""grammar.y""  
     {
         int result = yr_parser_reduce_string_identifier(
             yyscanner,
             (yyvsp[0].c_string),
             OP_FOUND,
             UNDEFINED);
         yr_free((yyvsp[0].c_string));
         ERROR_IF(result != ERROR_SUCCESS);
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
 #line 2553 ""grammar.c""  
     break;
   case 60:
 #line 995 ""grammar.y""  
     {
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""at"");
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[-2].c_string), OP_FOUND_AT, (yyvsp[0].expression).value.integer);
         yr_free((yyvsp[-2].c_string));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
 #line 2570 ""grammar.c""  
     break;
   case 61:
 #line 1008 ""grammar.y""  
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[-2].c_string), OP_FOUND_IN, UNDEFINED);
         yr_free((yyvsp[-2].c_string));
         ERROR_IF(compiler->last_result!= ERROR_SUCCESS);
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
 #line 2585 ""grammar.c""  
     break;
    case 62:
  #line 1019 ""grammar.y""  
     {
         compiler->loop_depth--;
         compiler->loop_identifier[compiler->loop_depth] = NULL;
       }
 #line 2594 ""grammar.c""  
     break;
   case 63:
 #line 1024 ""grammar.y""  
      {
          int var_index;
         if (compiler->loop_depth == MAX_LOOP_NESTING)
           compiler->last_result = \
               ERROR_LOOP_NESTING_LIMIT_EXCEEDED;
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         var_index = yr_parser_lookup_loop_variable(
             yyscanner, (yyvsp[-1].c_string));
         if (var_index >= 0)
         {
           yr_compiler_set_error_extra_info(
               compiler, (yyvsp[-1].c_string));
           compiler->last_result = \
               ERROR_DUPLICATED_LOOP_IDENTIFIER;
         }
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
          ERROR_IF(compiler->last_result != ERROR_SUCCESS);
        }
#line 2619 ""grammar.c""  
 #line 2628 ""grammar.c""  
      break;
  case 63:
#line 1049 ""grammar.y""  
   case 64:
 #line 1054 ""grammar.y""  
      {
          int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
          uint8_t* addr;
         yr_parser_emit_with_arg(
             yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);
         yr_parser_emit_with_arg(
             yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);
         if ((yyvsp[-1].integer) == INTEGER_SET_ENUMERATION)
         {
           yr_parser_emit_with_arg(
               yyscanner, OP_POP_M, mem_offset, &addr, NULL);
         }
         else  
         {
           yr_parser_emit_with_arg(
               yyscanner, OP_POP_M, mem_offset + 3, &addr, NULL);
           yr_parser_emit_with_arg(
               yyscanner, OP_POP_M, mem_offset, NULL, NULL);
         }
         compiler->loop_address[compiler->loop_depth] = addr;
          compiler->loop_identifier[compiler->loop_depth] = (yyvsp[-4].c_string);
          compiler->loop_depth++;
        }
#line 2658 ""grammar.c""  
 #line 2667 ""grammar.c""  
      break;
  case 64:
#line 1084 ""grammar.y""  
   case 65:
 #line 1089 ""grammar.y""  
      {
          int mem_offset;
         compiler->loop_depth--;
         mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
         yr_parser_emit_with_arg(
             yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);
         yr_parser_emit_with_arg(
             yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);
         if ((yyvsp[-5].integer) == INTEGER_SET_ENUMERATION)
         {
           yr_parser_emit_with_arg_reloc(
               yyscanner,
               OP_JNUNDEF,
               compiler->loop_address[compiler->loop_depth],
               NULL,
               NULL);
         }
         else  
         {
           yr_parser_emit_with_arg(
               yyscanner, OP_INCR_M, mem_offset, NULL, NULL);
           yr_parser_emit_with_arg(
               yyscanner, OP_PUSH_M, mem_offset, NULL, NULL);
           yr_parser_emit_with_arg(
               yyscanner, OP_PUSH_M, mem_offset + 3, NULL, NULL);
           yr_parser_emit_with_arg_reloc(
               yyscanner,
               OP_JLE,
               compiler->loop_address[compiler->loop_depth],
               NULL,
               NULL);
           yr_parser_emit(yyscanner, OP_POP, NULL);
           yr_parser_emit(yyscanner, OP_POP, NULL);
         }
         yr_parser_emit(yyscanner, OP_POP, NULL);
         yr_parser_emit_with_arg(
             yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);
         yr_parser_emit_with_arg(
             yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);
         yr_parser_emit(yyscanner, OP_INT_LE, NULL);
         compiler->loop_identifier[compiler->loop_depth] = NULL;
         yr_free((yyvsp[-8].c_string));
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        }
#line 2741 ""grammar.c""  
 #line 2750 ""grammar.c""  
      break;
  case 65:
#line 1163 ""grammar.y""  
   case 66:
 #line 1168 ""grammar.y""  
      {
          int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
          uint8_t* addr;
         if (compiler->loop_depth == MAX_LOOP_NESTING)
           compiler->last_result = \
             ERROR_LOOP_NESTING_LIMIT_EXCEEDED;
         if (compiler->loop_for_of_mem_offset != -1)
           compiler->last_result = \
             ERROR_NESTED_FOR_OF_LOOP;
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         yr_parser_emit_with_arg(
             yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);
         yr_parser_emit_with_arg(
             yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);
         yr_parser_emit_with_arg(
             yyscanner, OP_POP_M, mem_offset, &addr, NULL);
         compiler->loop_for_of_mem_offset = mem_offset;
         compiler->loop_address[compiler->loop_depth] = addr;
          compiler->loop_identifier[compiler->loop_depth] = NULL;
          compiler->loop_depth++;
        }
#line 2775 ""grammar.c""  
 #line 2784 ""grammar.c""  
      break;
  case 66:
#line 1193 ""grammar.y""  
   case 67:
 #line 1198 ""grammar.y""  
      {
          int mem_offset;
         compiler->loop_depth--;
         compiler->loop_for_of_mem_offset = -1;
         mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
         yr_parser_emit_with_arg(
             yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);
         yr_parser_emit_with_arg(
             yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);
         yr_parser_emit_with_arg_reloc(
             yyscanner,
             OP_JNUNDEF,
             compiler->loop_address[compiler->loop_depth],
             NULL,
             NULL);
         yr_parser_emit(yyscanner, OP_POP, NULL);
         yr_parser_emit_with_arg(
             yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);
         yr_parser_emit_with_arg(
             yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);
         yr_parser_emit(yyscanner, OP_INT_LE, NULL);
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        }
#line 2828 ""grammar.c""  
 #line 2837 ""grammar.c""  
      break;
  case 67:
#line 1242 ""grammar.y""  
   case 68:
 #line 1247 ""grammar.y""  
      {
          yr_parser_emit(yyscanner, OP_OF, NULL);
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        }
#line 2838 ""grammar.c""  
 #line 2847 ""grammar.c""  
      break;
  case 68:
#line 1248 ""grammar.y""  
   case 69:
 #line 1253 ""grammar.y""  
      {
          yr_parser_emit(yyscanner, OP_NOT, NULL);
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        }
#line 2848 ""grammar.c""  
 #line 2857 ""grammar.c""  
      break;
  case 69:
#line 1254 ""grammar.y""  
   case 70:
 #line 1259 ""grammar.y""  
      {
          YR_FIXUP* fixup;
          void* jmp_destination_addr;
         compiler->last_result = yr_parser_emit_with_arg_reloc(
             yyscanner,
             OP_JFALSE,
             0,           
             NULL,
             &jmp_destination_addr);
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));
         if (fixup == NULL)
           compiler->last_error = ERROR_INSUFFICIENT_MEMORY;
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         fixup->address = jmp_destination_addr;
          fixup->next = compiler->fixup_stack_head;
          compiler->fixup_stack_head = fixup;
        }
#line 2878 ""grammar.c""  
 #line 2887 ""grammar.c""  
      break;
  case 70:
#line 1280 ""grammar.y""  
   case 71:
 #line 1285 ""grammar.y""  
      {
          YR_FIXUP* fixup;
          uint8_t* and_addr;
         compiler->last_result = yr_arena_reserve_memory(
             compiler->code_arena, 2);
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         compiler->last_result = yr_parser_emit(yyscanner, OP_AND, &and_addr);
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         fixup = compiler->fixup_stack_head;
         *(void**)(fixup->address) = (void*)(and_addr + 1);
         compiler->fixup_stack_head = fixup->next;
         yr_free(fixup);
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        }
#line 2918 ""grammar.c""  
 #line 2927 ""grammar.c""  
      break;
  case 71:
#line 1316 ""grammar.y""  
   case 72:
 #line 1321 ""grammar.y""  
      {
          YR_FIXUP* fixup;
          void* jmp_destination_addr;
         compiler->last_result = yr_parser_emit_with_arg_reloc(
             yyscanner,
             OP_JTRUE,
             0,          
             NULL,
             &jmp_destination_addr);
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));
         if (fixup == NULL)
           compiler->last_error = ERROR_INSUFFICIENT_MEMORY;
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         fixup->address = jmp_destination_addr;
          fixup->next = compiler->fixup_stack_head;
          compiler->fixup_stack_head = fixup;
        }
#line 2947 ""grammar.c""  
 #line 2956 ""grammar.c""  
      break;
  case 72:
#line 1341 ""grammar.y""  
   case 73:
 #line 1346 ""grammar.y""  
      {
          YR_FIXUP* fixup;
          uint8_t* or_addr;
         compiler->last_result = yr_arena_reserve_memory(
             compiler->code_arena, 2);
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         compiler->last_result = yr_parser_emit(yyscanner, OP_OR, &or_addr);
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         fixup = compiler->fixup_stack_head;
         *(void**)(fixup->address) = (void*)(or_addr + 1);
         compiler->fixup_stack_head = fixup->next;
         yr_free(fixup);
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        }
#line 2987 ""grammar.c""  
 #line 2996 ""grammar.c""  
      break;
  case 73:
#line 1377 ""grammar.y""  
   case 74:
 #line 1382 ""grammar.y""  
      {
          compiler->last_result = yr_parser_reduce_operation(
              yyscanner, ""<"", (yyvsp[-2].expression), (yyvsp[0].expression));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        }
#line 3000 ""grammar.c""  
 #line 3009 ""grammar.c""  
      break;
  case 74:
#line 1386 ""grammar.y""  
   case 75:
 #line 1391 ""grammar.y""  
      {
          compiler->last_result = yr_parser_reduce_operation(
              yyscanner, "">"", (yyvsp[-2].expression), (yyvsp[0].expression));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        }
#line 3013 ""grammar.c""  
 #line 3022 ""grammar.c""  
      break;
  case 75:
#line 1395 ""grammar.y""  
   case 76:
 #line 1400 ""grammar.y""  
      {
          compiler->last_result = yr_parser_reduce_operation(
              yyscanner, ""<="", (yyvsp[-2].expression), (yyvsp[0].expression));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        }
#line 3026 ""grammar.c""  
 #line 3035 ""grammar.c""  
      break;
  case 76:
#line 1404 ""grammar.y""  
   case 77:
 #line 1409 ""grammar.y""  
      {
          compiler->last_result = yr_parser_reduce_operation(
              yyscanner, "">="", (yyvsp[-2].expression), (yyvsp[0].expression));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        }
#line 3039 ""grammar.c""  
 #line 3048 ""grammar.c""  
      break;
  case 77:
#line 1413 ""grammar.y""  
   case 78:
 #line 1418 ""grammar.y""  
      {
          compiler->last_result = yr_parser_reduce_operation(
              yyscanner, ""=="", (yyvsp[-2].expression), (yyvsp[0].expression));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        }
#line 3052 ""grammar.c""  
 #line 3061 ""grammar.c""  
      break;
  case 78:
#line 1422 ""grammar.y""  
   case 79:
 #line 1427 ""grammar.y""  
      {
          compiler->last_result = yr_parser_reduce_operation(
              yyscanner, ""!="", (yyvsp[-2].expression), (yyvsp[0].expression));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        }
#line 3065 ""grammar.c""  
 #line 3074 ""grammar.c""  
      break;
  case 79:
#line 1431 ""grammar.y""  
   case 80:
 #line 1436 ""grammar.y""  
      {
          (yyval.expression) = (yyvsp[0].expression);
        }
#line 3073 ""grammar.c""  
 #line 3082 ""grammar.c""  
      break;
  case 80:
#line 1435 ""grammar.y""  
   case 81:
 #line 1440 ""grammar.y""  
      {
          (yyval.expression) = (yyvsp[-1].expression);
        }
#line 3081 ""grammar.c""  
 #line 3090 ""grammar.c""  
      break;
  case 81:
#line 1442 ""grammar.y""  
   case 82:
 #line 1447 ""grammar.y""  
      { (yyval.integer) = INTEGER_SET_ENUMERATION; }
#line 3087 ""grammar.c""  
 #line 3096 ""grammar.c""  
      break;
  case 82:
#line 1443 ""grammar.y""  
   case 83:
 #line 1448 ""grammar.y""  
      { (yyval.integer) = INTEGER_SET_RANGE; }
#line 3093 ""grammar.c""  
 #line 3102 ""grammar.c""  
      break;
  case 83:
#line 1449 ""grammar.y""  
   case 84:
 #line 1454 ""grammar.y""  
      {
          if ((yyvsp[-3].expression).type != EXPRESSION_TYPE_INTEGER)
          {
           yr_compiler_set_error_extra_info(
               compiler, ""wrong type for range's lower bound"");
           compiler->last_result = ERROR_WRONG_TYPE;
         }
         if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)
         {
           yr_compiler_set_error_extra_info(
               compiler, ""wrong type for range's upper bound"");
           compiler->last_result = ERROR_WRONG_TYPE;
         }
          ERROR_IF(compiler->last_result != ERROR_SUCCESS);
        }
#line 3115 ""grammar.c""  
 #line 3124 ""grammar.c""  
      break;
  case 84:
#line 1471 ""grammar.y""  
   case 85:
 #line 1476 ""grammar.y""  
      {
          if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
          {
           yr_compiler_set_error_extra_info(
               compiler, ""wrong type for enumeration item"");
           compiler->last_result = ERROR_WRONG_TYPE;
         }
          ERROR_IF(compiler->last_result != ERROR_SUCCESS);
        }
#line 3131 ""grammar.c""  
 #line 3140 ""grammar.c""  
      break;
  case 85:
#line 1483 ""grammar.y""  
   case 86:
 #line 1488 ""grammar.y""  
      {
          if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
          {
           yr_compiler_set_error_extra_info(
               compiler, ""wrong type for enumeration item"");
           compiler->last_result = ERROR_WRONG_TYPE;
         }
          ERROR_IF(compiler->last_result != ERROR_SUCCESS);
        }
#line 3146 ""grammar.c""  
 #line 3155 ""grammar.c""  
      break;
  case 86:
#line 1498 ""grammar.y""  
   case 87:
 #line 1503 ""grammar.y""  
      {
          yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
        }
#line 3155 ""grammar.c""  
 #line 3164 ""grammar.c""  
      break;
  case 88:
#line 1504 ""grammar.y""  
   case 89:
 #line 1509 ""grammar.y""  
      {
          yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
          yr_parser_emit_pushes_for_strings(yyscanner, ""$*"");
          ERROR_IF(compiler->last_result != ERROR_SUCCESS);
        }
#line 3166 ""grammar.c""  
 #line 3175 ""grammar.c""  
      break;
  case 91:
#line 1521 ""grammar.y""  
   case 92:
 #line 1526 ""grammar.y""  
      {
          yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
          yr_free((yyvsp[0].c_string));
          ERROR_IF(compiler->last_result != ERROR_SUCCESS);
        }
#line 3177 ""grammar.c""  
 #line 3186 ""grammar.c""  
      break;
  case 92:
#line 1528 ""grammar.y""  
   case 93:
 #line 1533 ""grammar.y""  
      {
          yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
          yr_free((yyvsp[0].c_string));
          ERROR_IF(compiler->last_result != ERROR_SUCCESS);
        }
#line 3188 ""grammar.c""  
 #line 3197 ""grammar.c""  
      break;
  case 94:
#line 1540 ""grammar.y""  
   case 95:
 #line 1545 ""grammar.y""  
      {
          yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
        }
#line 3196 ""grammar.c""  
 #line 3205 ""grammar.c""  
      break;
  case 95:
#line 1544 ""grammar.y""  
   case 96:
 #line 1549 ""grammar.y""  
      {
          yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);
        }
#line 3204 ""grammar.c""  
 #line 3213 ""grammar.c""  
      break;
  case 96:
#line 1552 ""grammar.y""  
   case 97:
 #line 1557 ""grammar.y""  
      {
          (yyval.expression) = (yyvsp[-1].expression);
        }
#line 3212 ""grammar.c""  
 #line 3221 ""grammar.c""  
      break;
  case 97:
#line 1556 ""grammar.y""  
   case 98:
 #line 1561 ""grammar.y""  
      {
          compiler->last_result = yr_parser_emit(
              yyscanner, OP_FILESIZE, NULL);
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
        }
#line 3226 ""grammar.c""  
 #line 3235 ""grammar.c""  
      break;
  case 98:
#line 1566 ""grammar.y""  
   case 99:
 #line 1571 ""grammar.y""  
      {
          yywarning(yyscanner,
              ""Using deprecated \""entrypoint\"" keyword. Use the \""entry_point\"" ""
             ""function from PE module instead."");
         compiler->last_result = yr_parser_emit(
             yyscanner, OP_ENTRYPOINT, NULL);
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
        }
#line 3244 ""grammar.c""  
 #line 3253 ""grammar.c""  
      break;
  case 99:
#line 1580 ""grammar.y""  
   case 100:
 #line 1585 ""grammar.y""  
      {
          CHECK_TYPE((yyvsp[-1].expression), EXPRESSION_TYPE_INTEGER, ""intXXXX or uintXXXX"");
         compiler->last_result = yr_parser_emit(
             yyscanner, (uint8_t) (OP_READ_INT + (yyvsp[-3].integer)), NULL);
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
        }
#line 3264 ""grammar.c""  
 #line 3273 ""grammar.c""  
      break;
  case 100:
#line 1596 ""grammar.y""  
   case 101:
 #line 1601 ""grammar.y""  
      {
          compiler->last_result = yr_parser_emit_with_arg(
              yyscanner, OP_PUSH, (yyvsp[0].integer), NULL, NULL);
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = (yyvsp[0].integer);
        }
#line 3278 ""grammar.c""  
 #line 3287 ""grammar.c""  
      break;
  case 101:
#line 1606 ""grammar.y""  
   case 102:
 #line 1611 ""grammar.y""  
      {
          compiler->last_result = yr_parser_emit_with_arg_double(
              yyscanner, OP_PUSH, (yyvsp[0].double_), NULL, NULL);
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        }
#line 3291 ""grammar.c""  
 #line 3300 ""grammar.c""  
      break;
  case 102:
#line 1615 ""grammar.y""  
   case 103:
 #line 1620 ""grammar.y""  
      {
          SIZED_STRING* sized_string;
         compiler->last_result = yr_arena_write_data(
             compiler->sz_arena,
             (yyvsp[0].sized_string),
             (yyvsp[0].sized_string)->length + sizeof(SIZED_STRING),
             (void**) &sized_string);
         yr_free((yyvsp[0].sized_string));
         if (compiler->last_result == ERROR_SUCCESS)
           compiler->last_result = yr_parser_emit_with_arg_reloc(
               yyscanner,
               OP_PUSH,
               sized_string,
               NULL,
               NULL);
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          (yyval.expression).type = EXPRESSION_TYPE_STRING;
          (yyval.expression).value.sized_string = sized_string;
        }
#line 3320 ""grammar.c""  
 #line 3329 ""grammar.c""  
      break;
  case 103:
#line 1640 ""grammar.y""  
   case 104:
 #line 1645 ""grammar.y""  
      {
          compiler->last_result = yr_parser_reduce_string_identifier(
              yyscanner, (yyvsp[0].c_string), OP_COUNT, UNDEFINED);
         yr_free((yyvsp[0].c_string));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
        }
#line 3336 ""grammar.c""  
 #line 3345 ""grammar.c""  
      break;
  case 104:
#line 1652 ""grammar.y""  
   case 105:
 #line 1657 ""grammar.y""  
      {
          compiler->last_result = yr_parser_reduce_string_identifier(
              yyscanner, (yyvsp[-3].c_string), OP_OFFSET, UNDEFINED);
         yr_free((yyvsp[-3].c_string));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
        }
#line 3352 ""grammar.c""  
 #line 3361 ""grammar.c""  
      break;
  case 105:
#line 1664 ""grammar.y""  
   case 106:
 #line 1669 ""grammar.y""  
      {
          compiler->last_result = yr_parser_emit_with_arg(
              yyscanner, OP_PUSH, 1, NULL, NULL);
         if (compiler->last_result == ERROR_SUCCESS)
           compiler->last_result = yr_parser_reduce_string_identifier(
               yyscanner, (yyvsp[0].c_string), OP_OFFSET, UNDEFINED);
         yr_free((yyvsp[0].c_string));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
        }
#line 3372 ""grammar.c""  
 #line 3381 ""grammar.c""  
      break;
  case 106:
#line 1680 ""grammar.y""  
   case 107:
 #line 1685 ""grammar.y""  
      {
          compiler->last_result = yr_parser_reduce_string_identifier(
              yyscanner, (yyvsp[-3].c_string), OP_LENGTH, UNDEFINED);
         yr_free((yyvsp[-3].c_string));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
        }
#line 3388 ""grammar.c""  
 #line 3397 ""grammar.c""  
      break;
  case 107:
#line 1692 ""grammar.y""  
   case 108:
 #line 1697 ""grammar.y""  
      {
          compiler->last_result = yr_parser_emit_with_arg(
              yyscanner, OP_PUSH, 1, NULL, NULL);
         if (compiler->last_result == ERROR_SUCCESS)
           compiler->last_result = yr_parser_reduce_string_identifier(
               yyscanner, (yyvsp[0].c_string), OP_LENGTH, UNDEFINED);
         yr_free((yyvsp[0].c_string));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
        }
#line 3408 ""grammar.c""  
 #line 3417 ""grammar.c""  
      break;
  case 108:
#line 1708 ""grammar.y""  
   case 109:
 #line 1713 ""grammar.y""  
      {
          if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)   
          {
           (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
           (yyval.expression).value.integer = UNDEFINED;
         }
         else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_BOOLEAN)   
         {
           (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
           (yyval.expression).value.integer = UNDEFINED;
         }
         else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_OBJECT)
         {
           compiler->last_result = yr_parser_emit(
               yyscanner, OP_OBJ_VALUE, NULL);
           switch((yyvsp[0].expression).value.object->type)
           {
             case OBJECT_TYPE_INTEGER:
               (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
               (yyval.expression).value.integer = UNDEFINED;
               break;
             case OBJECT_TYPE_FLOAT:
               (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
               break;
             case OBJECT_TYPE_STRING:
               (yyval.expression).type = EXPRESSION_TYPE_STRING;
               (yyval.expression).value.sized_string = NULL;
               break;
             default:
               yr_compiler_set_error_extra_info_fmt(
                   compiler,
                   ""wrong usage of identifier \""%s\"""",
                   (yyvsp[0].expression).identifier);
               compiler->last_result = ERROR_WRONG_TYPE;
           }
         }
         else
         {
           assert(FALSE);
         }
          ERROR_IF(compiler->last_result != ERROR_SUCCESS);
        }
#line 3457 ""grammar.c""  
 #line 3466 ""grammar.c""  
      break;
  case 109:
#line 1753 ""grammar.y""  
   case 110:
 #line 1758 ""grammar.y""  
      {
          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, ""-"");
         if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
         {
           (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
           (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
               UNDEFINED : -((yyvsp[0].expression).value.integer);
           compiler->last_result = yr_parser_emit(yyscanner, OP_INT_MINUS, NULL);
         }
         else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_FLOAT)
         {
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
           compiler->last_result = yr_parser_emit(yyscanner, OP_DBL_MINUS, NULL);
         }
          ERROR_IF(compiler->last_result != ERROR_SUCCESS);
        }
#line 3480 ""grammar.c""  
 #line 3489 ""grammar.c""  
      break;
  case 110:
#line 1772 ""grammar.y""  
   case 111:
 #line 1777 ""grammar.y""  
      {
          compiler->last_result = yr_parser_reduce_operation(
              yyscanner, ""+"", (yyvsp[-2].expression), (yyvsp[0].expression));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
             (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
         {
           (yyval.expression).value.integer = OPERATION(+, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
           (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         }
         else
         {
            (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
          }
        }
#line 3502 ""grammar.c""  
 #line 3511 ""grammar.c""  
      break;
  case 111:
#line 1790 ""grammar.y""  
   case 112:
 #line 1795 ""grammar.y""  
      {
          compiler->last_result = yr_parser_reduce_operation(
              yyscanner, ""-"", (yyvsp[-2].expression), (yyvsp[0].expression));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
             (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
         {
           (yyval.expression).value.integer = OPERATION(-, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
           (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         }
         else
         {
            (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
          }
        }
#line 3524 ""grammar.c""  
 #line 3533 ""grammar.c""  
      break;
  case 112:
#line 1808 ""grammar.y""  
   case 113:
 #line 1813 ""grammar.y""  
      {
          compiler->last_result = yr_parser_reduce_operation(
              yyscanner, ""*"", (yyvsp[-2].expression), (yyvsp[0].expression));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
             (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
         {
           (yyval.expression).value.integer = OPERATION(*, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
           (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         }
         else
         {
            (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
          }
        }
#line 3546 ""grammar.c""  
 #line 3555 ""grammar.c""  
      break;
  case 113:
#line 1826 ""grammar.y""  
   case 114:
 #line 1831 ""grammar.y""  
      {
          compiler->last_result = yr_parser_reduce_operation(
              yyscanner, ""\\"", (yyvsp[-2].expression), (yyvsp[0].expression));
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
             (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
         {
           if ((yyvsp[0].expression).value.integer != 0)
           {
             (yyval.expression).value.integer = OPERATION(/, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
             (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
           }
           else
           {
             compiler->last_result = ERROR_DIVISION_BY_ZERO;
             ERROR_IF(compiler->last_result != ERROR_SUCCESS);
           }
         }
         else
         {
            (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
          }
        }
#line 3576 ""grammar.c""  
 #line 3585 ""grammar.c""  
      break;
  case 114:
#line 1852 ""grammar.y""  
   case 115:
 #line 1857 ""grammar.y""  
      {
          CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""%"");
          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""%"");
         yr_parser_emit(yyscanner, OP_MOD, NULL);
         if ((yyvsp[0].expression).value.integer != 0)
         {
           (yyval.expression).value.integer = OPERATION(%, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
           (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         }
         else
         {
           compiler->last_result = ERROR_DIVISION_BY_ZERO;
            ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          }
        }
#line 3598 ""grammar.c""  
 #line 3607 ""grammar.c""  
      break;
  case 115:
#line 1870 ""grammar.y""  
   case 116:
 #line 1875 ""grammar.y""  
      {
          CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""^"");
          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""^"");
         yr_parser_emit(yyscanner, OP_BITWISE_XOR, NULL);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = OPERATION(^, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        }
#line 3612 ""grammar.c""  
 #line 3621 ""grammar.c""  
      break;
  case 116:
#line 1880 ""grammar.y""  
   case 117:
 #line 1885 ""grammar.y""  
      {
          CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""^"");
          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""^"");
         yr_parser_emit(yyscanner, OP_BITWISE_AND, NULL);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = OPERATION(&, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        }
#line 3626 ""grammar.c""  
 #line 3635 ""grammar.c""  
      break;
  case 117:
#line 1890 ""grammar.y""  
   case 118:
 #line 1895 ""grammar.y""  
      {
          CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""|"");
          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""|"");
         yr_parser_emit(yyscanner, OP_BITWISE_OR, NULL);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = OPERATION(|, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        }
#line 3640 ""grammar.c""  
 #line 3649 ""grammar.c""  
      break;
  case 118:
#line 1900 ""grammar.y""  
   case 119:
 #line 1905 ""grammar.y""  
      {
          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""~"");
         yr_parser_emit(yyscanner, OP_BITWISE_NOT, NULL);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
              UNDEFINED : ~((yyvsp[0].expression).value.integer);
        }
#line 3654 ""grammar.c""  
 #line 3663 ""grammar.c""  
      break;
  case 119:
#line 1910 ""grammar.y""  
   case 120:
 #line 1915 ""grammar.y""  
      {
          CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""<<"");
          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""<<"");
         yr_parser_emit(yyscanner, OP_SHL, NULL);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        }
#line 3668 ""grammar.c""  
 #line 3677 ""grammar.c""  
      break;
  case 120:
#line 1920 ""grammar.y""  
   case 121:
 #line 1925 ""grammar.y""  
      {
          CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "">>"");
          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "">>"");
         yr_parser_emit(yyscanner, OP_SHR, NULL);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = OPERATION(>>, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        }
#line 3682 ""grammar.c""  
 #line 3691 ""grammar.c""  
      break;
  case 121:
#line 1930 ""grammar.y""  
   case 122:
 #line 1935 ""grammar.y""  
      {
          (yyval.expression) = (yyvsp[0].expression);
        }
#line 3690 ""grammar.c""  
 #line 3699 ""grammar.c""  
      break;
#line 3694 ""grammar.c""  
 #line 3703 ""grammar.c""  
        default: break;
      }
   YY_SYMBOL_PRINT (""-> $$ ="", yyr1[yyn], &yyval, &yyloc);
   YYPOPSTACK (yylen);
   yylen = 0;
   YY_STACK_PRINT (yyss, yyssp);
   *++yyvsp = yyval;
   yyn = yyr1[yyn];
   yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
   if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
     yystate = yytable[yystate];
   else
     yystate = yydefgoto[yyn - YYNTOKENS];
   goto yynewstate;
 yyerrlab:
   yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
   if (!yyerrstatus)
     {
       ++yynerrs;
 #if ! YYERROR_VERBOSE
       yyerror (yyscanner, compiler, YY_(""syntax error""));
 #else
 # define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
                                         yyssp, yytoken)
       {
         char const *yymsgp = YY_(""syntax error"");
         int yysyntax_error_status;
         yysyntax_error_status = YYSYNTAX_ERROR;
         if (yysyntax_error_status == 0)
           yymsgp = yymsg;
         else if (yysyntax_error_status == 1)
           {
             if (yymsg != yymsgbuf)
               YYSTACK_FREE (yymsg);
             yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
             if (!yymsg)
               {
                 yymsg = yymsgbuf;
                 yymsg_alloc = sizeof yymsgbuf;
                 yysyntax_error_status = 2;
               }
             else
               {
                 yysyntax_error_status = YYSYNTAX_ERROR;
                 yymsgp = yymsg;
               }
           }
         yyerror (yyscanner, compiler, yymsgp);
         if (yysyntax_error_status == 2)
           goto yyexhaustedlab;
       }
 # undef YYSYNTAX_ERROR
 #endif
     }
   if (yyerrstatus == 3)
     {
       if (yychar <= YYEOF)
         {
           if (yychar == YYEOF)
             YYABORT;
         }
       else
         {
           yydestruct (""Error: discarding"",
                       yytoken, &yylval, yyscanner, compiler);
           yychar = YYEMPTY;
         }
     }
   goto yyerrlab1;
 yyerrorlab:
   if (  0)
      goto yyerrorlab;
   YYPOPSTACK (yylen);
   yylen = 0;
   YY_STACK_PRINT (yyss, yyssp);
   yystate = *yyssp;
   goto yyerrlab1;
 yyerrlab1:
   yyerrstatus = 3;       
   for (;;)
     {
       yyn = yypact[yystate];
       if (!yypact_value_is_default (yyn))
         {
           yyn += YYTERROR;
           if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
             {
               yyn = yytable[yyn];
               if (0 < yyn)
                 break;
             }
         }
       if (yyssp == yyss)
         YYABORT;
       yydestruct (""Error: popping"",
                   yystos[yystate], yyvsp, yyscanner, compiler);
       YYPOPSTACK (1);
       yystate = *yyssp;
       YY_STACK_PRINT (yyss, yyssp);
     }
   YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
   *++yyvsp = yylval;
   YY_IGNORE_MAYBE_UNINITIALIZED_END
   YY_SYMBOL_PRINT (""Shifting"", yystos[yyn], yyvsp, yylsp);
   yystate = yyn;
   goto yynewstate;
 yyacceptlab:
   yyresult = 0;
   goto yyreturn;
 yyabortlab:
   yyresult = 1;
   goto yyreturn;
 #if !defined yyoverflow || YYERROR_VERBOSE
 yyexhaustedlab:
   yyerror (yyscanner, compiler, YY_(""memory exhausted""));
   yyresult = 2;
 #endif
 yyreturn:
   if (yychar != YYEMPTY)
     {
       yytoken = YYTRANSLATE (yychar);
       yydestruct (""Cleanup: discarding lookahead"",
                   yytoken, &yylval, yyscanner, compiler);
     }
   YYPOPSTACK (yylen);
   YY_STACK_PRINT (yyss, yyssp);
   while (yyssp != yyss)
     {
       yydestruct (""Cleanup: popping"",
                   yystos[*yyssp], yyvsp, yyscanner, compiler);
       YYPOPSTACK (1);
     }
 #ifndef yyoverflow
   if (yyss != yyssa)
     YYSTACK_FREE (yyss);
 #endif
 #if YYERROR_VERBOSE
   if (yymsg != yymsgbuf)
     YYSTACK_FREE (yymsg);
  #endif
    return yyresult;
  }","[878, 879, 880, 881, 882, 883, 884, 885, 906, 907, 909, 910, 911, 912, 936, 937, 939, 940, 941, 942, 987, 988, 990, 991, 992, 993, 1015, 1016, 1018, 1019, 1020, 1021, 1045, 1046, 1048, 1049, 1050, 1051, 1056, 1057, 1059, 1060, 1061, 1062, 1067, 1068, 1070, 1071, 1072, 1073, 1092, 1093, 1095, 1096, 1097, 1098, 1113, 1114, 1116, 1117, 1118, 1119, 1138, 1139, 1141, 1142, 1143, 1144, 1159, 1160, 1162, 1163, 1164, 1165, 1172, 1173, 1175, 1176, 1177, 1178, 1185, 1186, 1188, 1189, 1190, 1191, 1198, 1199, 1201, 1202, 1203, 1204, 1211, 1212, 1214, 1215, 1216, 1217, 1224, 1225, 1227, 1228, 1229, 1230, 1237, 1238, 1240, 1241, 1242, 1243, 1247, 1248, 1250, 1251, 1252, 1253, 1257, 1258, 1260, 1261, 1262, 1263, 1265, 1266, 1268, 1269, 1270, 1271, 1273, 1274, 1276, 1277, 1278, 1279, 1295, 1296, 1298, 1299, 1300, 1301, 1311, 1312, 1314, 1315, 1316, 1317, 1327, 1328, 1330, 1331, 1332, 1333, 1337, 1338, 1340, 1341, 1342, 1343, 1349, 1350, 1352, 1353, 1354, 1355, 1361, 1362, 1364, 1365, 1366, 1367, 1373, 1374, 1376, 1377, 1378, 1379, 1383, 1384, 1386, 1387, 1388, 1389, 1393, 1394, 1396, 1397, 1398, 1399, 1403, 1404, 1406, 1407, 1408, 1409, 1417, 1418, 1420, 1421, 1422, 1423, 1434, 1435, 1437, 1438, 1439, 1440, 1449, 1450, 1452, 1453, 1454, 1455, 1463, 1464, 1466, 1467, 1468, 1469, 1476, 1477, 1479, 1480, 1481, 1482, 1502, 1503, 1505, 1506, 1507, 1508, 1517, 1518, 1520, 1521, 1522, 1523, 1532, 1533, 1535, 1536, 1537, 1538, 1550, 1551, 1553, 1554, 1555, 1556, 1565, 1566, 1568, 1569, 1570, 1571, 1583, 1584, 1586, 1587, 1588, 1589, 1632, 1633, 1635, 1636, 1637, 1638, 1655, 1656, 1658, 1659, 1660, 1661, 1677, 1678, 1680, 1681, 1682, 1683, 1699, 1700, 1702, 1703, 1704, 1705, 1721, 1722, 1724, 1725, 1726, 1727, 1751, 1752, 1754, 1755, 1756, 1757, 1773, 1774, 1776, 1777, 1778, 1779, 1787, 1788, 1790, 1791, 1792, 1793, 1801, 1802, 1804, 1805, 1806, 1807, 1815, 1816, 1818, 1819, 1820, 1821, 1829, 1830, 1832, 1833, 1834, 1835, 1843, 1844, 1846, 1847, 1848, 1849, 1857, 1858, 1860, 1861, 1862, 1863, 1867, 1868, 1870, 1871]",libyara/grammar.y in YARA 3.5.0 allows remote attackers to cause a denial of service (use-after-free and application crash) via a crafted rule that is mishandled in the yr_parser_lookup_loop_variable function.,yara,CVE-2016-10211,CWE-416
547,182056," static void set_own_dir(const char *argv0) {
 	size_t l = strlen(argv0);
  	while(l && argv0[l - 1] != '/')
  		l--;
  	if(l == 0)
 #ifdef SUPER_SECURE
 		memcpy(own_dir, ""/dev/null/"", 2);
 #else
  		memcpy(own_dir, ""."", 2);
 #endif
  	else {
  		memcpy(own_dir, argv0, l - 1);
  		own_dir[l] = 0;
 	}
 }","[6, 7, 8, 10]","Untrusted search path vulnerability in ProxyChains-NG before 4.9 allows local users to gain privileges via a Trojan horse libproxychains4.so library in the current working directory, which is referenced in the LD_PRELOAD path.",proxychains-ng,CVE-2015-3887,CWE-426
563,180174," static int parse_packet (sockent_t *se,  
 		void *buffer, size_t buffer_size, int flags,
 		const char *username)
 {
 	int status;
 	value_list_t vl = VALUE_LIST_INIT;
 	notification_t n;
 #if HAVE_LIBGCRYPT
 	int packet_was_signed = (flags & PP_SIGNED);
         int packet_was_encrypted = (flags & PP_ENCRYPTED);
 	int printed_ignore_warning = 0;
 #endif  
 	memset (&vl, '\0', sizeof (vl));
 	memset (&n, '\0', sizeof (n));
 	status = 0;
 	while ((status == 0) && (0 < buffer_size)
 			&& ((unsigned int) buffer_size > sizeof (part_header_t)))
 	{
 		uint16_t pkg_length;
 		uint16_t pkg_type;
 		memcpy ((void *) &pkg_type,
 				(void *) buffer,
 				sizeof (pkg_type));
 		memcpy ((void *) &pkg_length,
 				(void *) (buffer + sizeof (pkg_type)),
 				sizeof (pkg_length));
 		pkg_length = ntohs (pkg_length);
 		pkg_type = ntohs (pkg_type);
 		if (pkg_length > buffer_size)
 			break;
 		if (pkg_length < (2 * sizeof (uint16_t)))
 			break;
 		if (pkg_type == TYPE_ENCR_AES256)
 		{
 			status = parse_part_encr_aes256 (se,
 					&buffer, &buffer_size, flags);
 			if (status != 0)
 			{
 				ERROR (""network plugin: Decrypting AES256 ""
 						""part failed ""
 						""with status %i."", status);
 				break;
 			}
 		}
 #if HAVE_LIBGCRYPT
 		else if ((se->data.server.security_level == SECURITY_LEVEL_ENCRYPT)
 				&& (packet_was_encrypted == 0))
 		{
 			if (printed_ignore_warning == 0)
 			{
 				INFO (""network plugin: Unencrypted packet or ""
 						""part has been ignored."");
  				printed_ignore_warning = 1;
  			}
  			buffer = ((char *) buffer) + pkg_length;
 			buffer_size -= (size_t) pkg_length;
  			continue;
  		}
  #endif  
 		else if (pkg_type == TYPE_SIGN_SHA256)
 		{
 			status = parse_part_sign_sha256 (se,
                                         &buffer, &buffer_size, flags);
 			if (status != 0)
 			{
 				ERROR (""network plugin: Verifying HMAC-SHA-256 ""
 						""signature failed ""
 						""with status %i."", status);
 				break;
 			}
 		}
 #if HAVE_LIBGCRYPT
 		else if ((se->data.server.security_level == SECURITY_LEVEL_SIGN)
 				&& (packet_was_encrypted == 0)
 				&& (packet_was_signed == 0))
 		{
 			if (printed_ignore_warning == 0)
 			{
 				INFO (""network plugin: Unsigned packet or ""
 						""part has been ignored."");
  				printed_ignore_warning = 1;
  			}
  			buffer = ((char *) buffer) + pkg_length;
 			buffer_size -= (size_t) pkg_length;
  			continue;
  		}
  #endif  
 		else if (pkg_type == TYPE_VALUES)
 		{
 			status = parse_part_values (&buffer, &buffer_size,
 					&vl.values, &vl.values_len);
 			if (status != 0)
 				break;
 			network_dispatch_values (&vl, username);
 			sfree (vl.values);
 		}
 		else if (pkg_type == TYPE_TIME)
 		{
 			uint64_t tmp = 0;
 			status = parse_part_number (&buffer, &buffer_size,
 					&tmp);
 			if (status == 0)
 			{
 				vl.time = TIME_T_TO_CDTIME_T (tmp);
 				n.time  = TIME_T_TO_CDTIME_T (tmp);
 			}
 		}
 		else if (pkg_type == TYPE_TIME_HR)
 		{
 			uint64_t tmp = 0;
 			status = parse_part_number (&buffer, &buffer_size,
 					&tmp);
 			if (status == 0)
 			{
 				vl.time = (cdtime_t) tmp;
 				n.time  = (cdtime_t) tmp;
 			}
 		}
 		else if (pkg_type == TYPE_INTERVAL)
 		{
 			uint64_t tmp = 0;
 			status = parse_part_number (&buffer, &buffer_size,
 					&tmp);
 			if (status == 0)
 				vl.interval = TIME_T_TO_CDTIME_T (tmp);
 		}
 		else if (pkg_type == TYPE_INTERVAL_HR)
 		{
 			uint64_t tmp = 0;
 			status = parse_part_number (&buffer, &buffer_size,
 					&tmp);
 			if (status == 0)
 				vl.interval = (cdtime_t) tmp;
 		}
 		else if (pkg_type == TYPE_HOST)
 		{
 			status = parse_part_string (&buffer, &buffer_size,
 					vl.host, sizeof (vl.host));
 			if (status == 0)
 				sstrncpy (n.host, vl.host, sizeof (n.host));
 		}
 		else if (pkg_type == TYPE_PLUGIN)
 		{
 			status = parse_part_string (&buffer, &buffer_size,
 					vl.plugin, sizeof (vl.plugin));
 			if (status == 0)
 				sstrncpy (n.plugin, vl.plugin,
 						sizeof (n.plugin));
 		}
 		else if (pkg_type == TYPE_PLUGIN_INSTANCE)
 		{
 			status = parse_part_string (&buffer, &buffer_size,
 					vl.plugin_instance,
 					sizeof (vl.plugin_instance));
 			if (status == 0)
 				sstrncpy (n.plugin_instance,
 						vl.plugin_instance,
 						sizeof (n.plugin_instance));
 		}
 		else if (pkg_type == TYPE_TYPE)
 		{
 			status = parse_part_string (&buffer, &buffer_size,
 					vl.type, sizeof (vl.type));
 			if (status == 0)
 				sstrncpy (n.type, vl.type, sizeof (n.type));
 		}
 		else if (pkg_type == TYPE_TYPE_INSTANCE)
 		{
 			status = parse_part_string (&buffer, &buffer_size,
 					vl.type_instance,
 					sizeof (vl.type_instance));
 			if (status == 0)
 				sstrncpy (n.type_instance, vl.type_instance,
 						sizeof (n.type_instance));
 		}
 		else if (pkg_type == TYPE_MESSAGE)
 		{
 			status = parse_part_string (&buffer, &buffer_size,
 					n.message, sizeof (n.message));
 			if (status != 0)
 			{
 			}
 			else if ((n.severity != NOTIF_FAILURE)
 					&& (n.severity != NOTIF_WARNING)
 					&& (n.severity != NOTIF_OKAY))
 			{
 				INFO (""network plugin: ""
 						""Ignoring notification with ""
 						""unknown severity %i."",
 						n.severity);
 			}
 			else if (n.time <= 0)
 			{
 				INFO (""network plugin: ""
 						""Ignoring notification with ""
 						""time == 0."");
 			}
 			else if (strlen (n.message) <= 0)
 			{
 				INFO (""network plugin: ""
 						""Ignoring notification with ""
 						""an empty message."");
 			}
 			else
 			{
 				network_dispatch_notification (&n);
 			}
 		}
 		else if (pkg_type == TYPE_SEVERITY)
 		{
 			uint64_t tmp = 0;
 			status = parse_part_number (&buffer, &buffer_size,
 					&tmp);
 			if (status == 0)
 				n.severity = (int) tmp;
 		}
 		else
 		{
  			DEBUG (""network plugin: parse_packet: Unknown part""
  					"" type: 0x%04hx"", pkg_type);
  			buffer = ((char *) buffer) + pkg_length;
 			buffer_size -= (size_t) pkg_length;
  		}
  	}  
 	if (status == 0 && buffer_size > 0)
 		WARNING (""network plugin: parse_packet: Received truncated ""
 				""packet, try increasing `MaxPacketSize'"");
 	return (status);
 }  ","[56, 84, 222]",Heap-based buffer overflow in the parse_packet function in network.c in collectd before 5.4.3 and 5.x before 5.5.2 allows remote attackers to cause a denial of service (daemon crash) or possibly execute arbitrary code via a crafted network packet.,collectd,CVE-2016-6254,CWE-119
577,181675," static void parse_content_range(URLContext *h, const char *p)
 {
     HTTPContext *s = h->priv_data;
     const char *slash;
      if (!strncmp(p, ""bytes "", 6)) {
          p     += 6;
        s->off = strtoll(p, NULL, 10);
         s->off = strtoull(p, NULL, 10);
          if ((slash = strchr(p, '/')) && strlen(slash) > 0)
            s->filesize = strtoll(slash + 1, NULL, 10);
             s->filesize = strtoull(slash + 1, NULL, 10);
      }
      if (s->seekable == -1 && (!s->is_akamai || s->filesize != 2147483647))
          h->is_streamed = 0;  
 }","[7, 8, 10, 11]","Heap-based buffer overflow in libavformat/http.c in FFmpeg before 2.8.10, 3.0.x before 3.0.5, 3.1.x before 3.1.6, and 3.2.x before 3.2.2 allows remote web servers to execute arbitrary code via a negative chunk size in an HTTP response.",FFmpeg,CVE-2016-10190,CWE-119
599,181375," int yr_re_match(
     RE* re,
     const char* target)
 {
   return yr_re_exec(
        re->code,
        (uint8_t*) target,
        strlen(target),
       0,
        re->flags | RE_FLAGS_SCAN,
        NULL,
        NULL);
 }",[9],libyara/re.c in the regex component in YARA 3.5.0 allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted rule that is mishandled in the yr_re_exec function.,yara,CVE-2017-8294,CWE-125
603,181938," safe_fprintf(FILE *f, const char *fmt, ...)
 {
 	char fmtbuff_stack[256];  
 	char outbuff[256];  
 	char *fmtbuff_heap;  
 	char *fmtbuff;   
 	int fmtbuff_length;
 	int length, n;
 	va_list ap;
 	const char *p;
 	unsigned i;
 	wchar_t wc;
 	char try_wc;
 	fmtbuff_heap = NULL;
 	fmtbuff_length = sizeof(fmtbuff_stack);
 	fmtbuff = fmtbuff_stack;
 	va_start(ap, fmt);
 	length = vsnprintf(fmtbuff, fmtbuff_length, fmt, ap);
 	va_end(ap);
 	while (length < 0 || length >= fmtbuff_length) {
 		if (length >= fmtbuff_length)
 			fmtbuff_length = length+1;
 		else if (fmtbuff_length < 8192)
 			fmtbuff_length *= 2;
 		else if (fmtbuff_length < 1000000)
 			fmtbuff_length += fmtbuff_length / 4;
 		else {
 			length = fmtbuff_length;
 			fmtbuff_heap[length-1] = '\0';
 			break;
 		}
 		free(fmtbuff_heap);
 		fmtbuff_heap = malloc(fmtbuff_length);
 		if (fmtbuff_heap != NULL) {
 			fmtbuff = fmtbuff_heap;
 			va_start(ap, fmt);
 			length = vsnprintf(fmtbuff, fmtbuff_length, fmt, ap);
 			va_end(ap);
 		} else {
 			length = sizeof(fmtbuff_stack) - 1;
 			break;
 		}
 	}
 	if (mbtowc(NULL, NULL, 1) == -1) {  
 		free(fmtbuff_heap);
 		return;
 	}
 	p = fmtbuff;
 	i = 0;
 	try_wc = 1;
 	while (*p != '\0') {
 		if (try_wc && (n = mbtowc(&wc, p, length)) != -1) {
 			length -= n;
 			if (iswprint(wc) && wc != L'\\') {
 				while (n-- > 0)
 					outbuff[i++] = *p++;
 			} else {
 				while (n-- > 0)
 					i += (unsigned)bsdtar_expand_char(
 					    outbuff, i, *p++);
 			}
 		} else {
 			i += (unsigned)bsdtar_expand_char(outbuff, i, *p++);
 			try_wc = 0;
  		}
		if (i > (sizeof(outbuff) - 20)) {
 		if (i > (sizeof(outbuff) - 128)) {
  			outbuff[i] = '\0';
  			fprintf(f, ""%s"", outbuff);
  			i = 0;
 		}
 	}
 	outbuff[i] = '\0';
 	fprintf(f, ""%s"", outbuff);
 	free(fmtbuff_heap);
 }","[66, 67]",Stack-based buffer overflow in the safe_fprintf function in tar/util.c in libarchive 3.2.1 allows remote attackers to cause a denial of service via a crafted non-printable multibyte character in a filename.,libarchive,CVE-2016-8687,CWE-119
604,179586," QTN2QT(QTNode *in)
 {
 	TSQuery		out;
 	int			len;
 	int			sumlen = 0,
 				nnode = 0;
  	QTN2QTState state;
  	cntsize(in, &sumlen, &nnode);
 	if (TSQUERY_TOO_BIG(nnode, sumlen))
 		ereport(ERROR,
 				(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),
 				 errmsg(""tsquery is too large"")));
  	len = COMPUTESIZE(nnode, sumlen);
  	out = (TSQuery) palloc0(len);
 	SET_VARSIZE(out, len);
 	out->size = nnode;
 	state.curitem = GETQUERY(out);
 	state.operand = state.curoperand = GETOPERAND(out);
 	fillQT(&state, in);
 	return out;
 }","[9, 10, 11, 12]","Multiple integer overflows in contrib/hstore/hstore_io.c in PostgreSQL 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact via vectors related to the (1) hstore_recv, (2) hstore_from_arrays, and (3) hstore_from_array functions in contrib/hstore/hstore_io.c; and the (4) hstoreArrayToPairs function in contrib/hstore/hstore_op.c, which triggers a buffer overflow.  NOTE: this issue was SPLIT from CVE-2014-0064 because it has a different set of affected versions.",postgres,CVE-2014-2669,CWE-189
613,179249,"  PHP_FUNCTION(radius_get_vendor_attr)
  {
	int res;
	const void *data;
 	const void *data, *raw;
  	int len;
  	u_int32_t vendor;
 	unsigned char type;
 	size_t data_len;
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &data, &len) == FAILURE) {
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &raw, &len) == FAILURE) {
  		return;
  	}
	res = rad_get_vendor_attr(&vendor, &data, (size_t *) &len);
	if (res == -1) {
 	if (rad_get_vendor_attr(&vendor, &type, &data, &data_len, raw, len) == -1) {
  		RETURN_FALSE;
  	} else {
  		array_init(return_value);
		add_assoc_long(return_value, ""attr"", res);
 		add_assoc_long(return_value, ""attr"", type);
  		add_assoc_long(return_value, ""vendor"", vendor);
		add_assoc_stringl(return_value, ""data"", (char *) data, len, 1);
 		add_assoc_stringl(return_value, ""data"", (char *) data, data_len, 1);
  		return;
  	}
  }","[3, 4, 5, 8, 9, 10, 11, 14, 15, 16, 20, 21, 23, 24]",Buffer overflow in the radius_get_vendor_attr function in the Radius extension before 1.2.7 for PHP allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a large Vendor Specific Attributes (VSA) length value.,php-radius,CVE-2013-2220,CWE-119
625,182270," static int flv_write_packet(AVFormatContext *s, AVPacket *pkt)
 {
     AVIOContext *pb      = s->pb;
     AVCodecParameters *par = s->streams[pkt->stream_index]->codecpar;
     FLVContext *flv      = s->priv_data;
     FLVStreamContext *sc = s->streams[pkt->stream_index]->priv_data;
     unsigned ts;
     int size = pkt->size;
     uint8_t *data = NULL;
      int flags = -1, flags_size, ret;
      int64_t cur_offset = avio_tell(pb);
     if (par->codec_type == AVMEDIA_TYPE_AUDIO && !pkt->size) {
         av_log(s, AV_LOG_WARNING, ""Empty audio Packet\n"");
         return AVERROR(EINVAL);
     }
      if (par->codec_id == AV_CODEC_ID_VP6F || par->codec_id == AV_CODEC_ID_VP6A ||
          par->codec_id == AV_CODEC_ID_VP6  || par->codec_id == AV_CODEC_ID_AAC)
          flags_size = 2;
     else if (par->codec_id == AV_CODEC_ID_H264 || par->codec_id == AV_CODEC_ID_MPEG4)
         flags_size = 5;
     else
         flags_size = 1;
     if (par->codec_id == AV_CODEC_ID_AAC || par->codec_id == AV_CODEC_ID_H264
             || par->codec_id == AV_CODEC_ID_MPEG4) {
         int side_size = 0;
         uint8_t *side = av_packet_get_side_data(pkt, AV_PKT_DATA_NEW_EXTRADATA, &side_size);
         if (side && side_size > 0 && (side_size != par->extradata_size || memcmp(side, par->extradata, side_size))) {
             av_free(par->extradata);
             par->extradata = av_mallocz(side_size + AV_INPUT_BUFFER_PADDING_SIZE);
             if (!par->extradata) {
                 par->extradata_size = 0;
                 return AVERROR(ENOMEM);
             }
             memcpy(par->extradata, side, side_size);
             par->extradata_size = side_size;
             flv_write_codec_header(s, par, pkt->dts);
         }
     }
     if (flv->delay == AV_NOPTS_VALUE)
         flv->delay = -pkt->dts;
     if (pkt->dts < -flv->delay) {
         av_log(s, AV_LOG_WARNING,
                ""Packets are not in the proper order with respect to DTS\n"");
         return AVERROR(EINVAL);
     }
     ts = pkt->dts;
     if (s->event_flags & AVSTREAM_EVENT_FLAG_METADATA_UPDATED) {
         write_metadata(s, ts);
         s->event_flags &= ~AVSTREAM_EVENT_FLAG_METADATA_UPDATED;
     }
     avio_write_marker(pb, av_rescale(ts, AV_TIME_BASE, 1000),
                       pkt->flags & AV_PKT_FLAG_KEY && (flv->video_par ? par->codec_type == AVMEDIA_TYPE_VIDEO : 1) ? AVIO_DATA_MARKER_SYNC_POINT : AVIO_DATA_MARKER_BOUNDARY_POINT);
     switch (par->codec_type) {
     case AVMEDIA_TYPE_VIDEO:
         avio_w8(pb, FLV_TAG_TYPE_VIDEO);
         flags = ff_codec_get_tag(flv_video_codec_ids, par->codec_id);
         flags |= pkt->flags & AV_PKT_FLAG_KEY ? FLV_FRAME_KEY : FLV_FRAME_INTER;
         break;
     case AVMEDIA_TYPE_AUDIO:
         flags = get_audio_flags(s, par);
         av_assert0(size);
         avio_w8(pb, FLV_TAG_TYPE_AUDIO);
         break;
     case AVMEDIA_TYPE_SUBTITLE:
     case AVMEDIA_TYPE_DATA:
         avio_w8(pb, FLV_TAG_TYPE_META);
         break;
     default:
         return AVERROR(EINVAL);
     }
     if (par->codec_id == AV_CODEC_ID_H264 || par->codec_id == AV_CODEC_ID_MPEG4) {
         if (par->extradata_size > 0 && *(uint8_t*)par->extradata != 1)
             if ((ret = ff_avc_parse_nal_units_buf(pkt->data, &data, &size)) < 0)
                 return ret;
     } else if (par->codec_id == AV_CODEC_ID_AAC && pkt->size > 2 &&
                (AV_RB16(pkt->data) & 0xfff0) == 0xfff0) {
         if (!s->streams[pkt->stream_index]->nb_frames) {
         av_log(s, AV_LOG_ERROR, ""Malformed AAC bitstream detected: ""
                ""use the audio bitstream filter 'aac_adtstoasc' to fix it ""
                ""('-bsf:a aac_adtstoasc' option with ffmpeg)\n"");
         return AVERROR_INVALIDDATA;
         }
         av_log(s, AV_LOG_WARNING, ""aac bitstream error\n"");
     }
     if (par->codec_id == AV_CODEC_ID_SPEEX && ts - sc->last_ts > 160)
         av_log(s, AV_LOG_WARNING, ""Warning: Speex stream has more than ""
                                   ""8 frames per packet. Adobe Flash ""
                                   ""Player cannot handle this!\n"");
     if (sc->last_ts < ts)
         sc->last_ts = ts;
     if (size + flags_size >= 1<<24) {
         av_log(s, AV_LOG_ERROR, ""Too large packet with size %u >= %u\n"",
                size + flags_size, 1<<24);
         return AVERROR(EINVAL);
     }
     avio_wb24(pb, size + flags_size);
     put_timestamp(pb, ts);
     avio_wb24(pb, flv->reserved);
     if (par->codec_type == AVMEDIA_TYPE_DATA ||
         par->codec_type == AVMEDIA_TYPE_SUBTITLE ) {
         int data_size;
         int64_t metadata_size_pos = avio_tell(pb);
         if (par->codec_id == AV_CODEC_ID_TEXT) {
             avio_w8(pb, AMF_DATA_TYPE_STRING);
             put_amf_string(pb, ""onTextData"");
             avio_w8(pb, AMF_DATA_TYPE_MIXEDARRAY);
             avio_wb32(pb, 2);
             put_amf_string(pb, ""type"");
             avio_w8(pb, AMF_DATA_TYPE_STRING);
             put_amf_string(pb, ""Text"");
             put_amf_string(pb, ""text"");
             avio_w8(pb, AMF_DATA_TYPE_STRING);
             put_amf_string(pb, pkt->data);
             put_amf_string(pb, """");
             avio_w8(pb, AMF_END_OF_OBJECT);
         } else {
             avio_write(pb, data ? data : pkt->data, size);
         }
         data_size = avio_tell(pb) - metadata_size_pos;
         avio_seek(pb, metadata_size_pos - 10, SEEK_SET);
         avio_wb24(pb, data_size);
         avio_seek(pb, data_size + 10 - 3, SEEK_CUR);
         avio_wb32(pb, data_size + 11);
     } else {
         av_assert1(flags>=0);
         avio_w8(pb,flags);
         if (par->codec_id == AV_CODEC_ID_VP6)
             avio_w8(pb,0);
         if (par->codec_id == AV_CODEC_ID_VP6F || par->codec_id == AV_CODEC_ID_VP6A) {
             if (par->extradata_size)
                 avio_w8(pb, par->extradata[0]);
             else
                 avio_w8(pb, ((FFALIGN(par->width,  16) - par->width) << 4) |
                              (FFALIGN(par->height, 16) - par->height));
         } else if (par->codec_id == AV_CODEC_ID_AAC)
             avio_w8(pb, 1);  
         else if (par->codec_id == AV_CODEC_ID_H264 || par->codec_id == AV_CODEC_ID_MPEG4) {
             avio_w8(pb, 1);  
             avio_wb24(pb, pkt->pts - pkt->dts);
         }
         avio_write(pb, data ? data : pkt->data, size);
         avio_wb32(pb, size + flags_size + 11);  
         flv->duration = FFMAX(flv->duration,
                               pkt->pts + flv->delay + pkt->duration);
     }
     if (flv->flags & FLV_ADD_KEYFRAME_INDEX) {
         switch (par->codec_type) {
             case AVMEDIA_TYPE_VIDEO:
                 flv->videosize += (avio_tell(pb) - cur_offset);
                 flv->lasttimestamp = flv->acurframeindex / flv->framerate;
                 if (pkt->flags & AV_PKT_FLAG_KEY) {
                     double ts = flv->acurframeindex / flv->framerate;
                     int64_t pos = cur_offset;
                     flv->lastkeyframetimestamp = flv->acurframeindex / flv->framerate;
                     flv->lastkeyframelocation = pos;
                     flv_append_keyframe_info(s, flv, ts, pos);
                 }
                 flv->acurframeindex++;
                 break;
             case AVMEDIA_TYPE_AUDIO:
                 flv->audiosize += (avio_tell(pb) - cur_offset);
                 break;
             default:
                 av_log(s, AV_LOG_WARNING, ""par->codec_type is type = [%d]\n"", par->codec_type);
                 break;
         }
     }
     av_free(data);
     return pb->error;
 }","[12, 13, 14, 15]","The flv_write_packet function in libavformat/flvenc.c in FFmpeg through 4.0.2 does not check for an empty audio packet, leading to an assertion failure.",FFmpeg,CVE-2018-15822,CWE-617
629,180492," parse_device(dev_t *pdev, struct archive *a, char *val)
 {
 #define MAX_PACK_ARGS 3
 	unsigned long numbers[MAX_PACK_ARGS];
 	char *p, *dev;
 	int argc;
 	pack_t *pack;
 	dev_t result;
 	const char *error = NULL;
 	memset(pdev, 0, sizeof(*pdev));
 	if ((dev = strchr(val, ',')) != NULL) {
 		*dev++ = '\0';
 		if ((pack = pack_find(val)) == NULL) {
 			archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
 			    ""Unknown format `%s'"", val);
 			return ARCHIVE_WARN;
 		}
 		argc = 0;
 		while ((p = la_strsep(&dev, "","")) != NULL) {
 			if (*p == '\0') {
 				archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
  				    ""Missing number"");
  				return ARCHIVE_WARN;
  			}
			numbers[argc++] = (unsigned long)mtree_atol(&p);
			if (argc > MAX_PACK_ARGS) {
 			if (argc >= MAX_PACK_ARGS) {
  				archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
  				    ""Too many arguments"");
  				return ARCHIVE_WARN;
  			}
 			numbers[argc++] = (unsigned long)mtree_atol(&p);
  		}
  		if (argc < 2) {
  			archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
 			    ""Not enough arguments"");
 			return ARCHIVE_WARN;
 		}
 		result = (*pack)(argc, numbers, &error);
 		if (error != NULL) {
 			archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
 			    ""%s"", error);
 			return ARCHIVE_WARN;
 		}
 	} else {
 		result = (dev_t)mtree_atol(&val);
 	}
 	*pdev = result;
 	return ARCHIVE_OK;
 #undef MAX_PACK_ARGS
 }","[25, 26, 27, 32]",Stack-based buffer overflow in the parse_device function in archive_read_support_format_mtree.c in libarchive before 3.2.1 allows remote attackers to execute arbitrary code via a crafted mtree file.,libarchive,CVE-2016-4301,CWE-119
637,181491," int jp2_box_put(jp2_box_t *box, jas_stream_t *out)
 {
 	jas_stream_t *tmpstream;
 	bool extlen;
 	bool dataflag;
 	tmpstream = 0;
 	dataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));
 	if (dataflag) {
 		if (!(tmpstream = jas_stream_memopen(0, 0))) {
 			goto error;
 		}
 		if (box->ops->putdata) {
 			if ((*box->ops->putdata)(box, tmpstream)) {
 				goto error;
 			}
 		}
 		box->len = jas_stream_tell(tmpstream) + JP2_BOX_HDRLEN(false);
 		jas_stream_rewind(tmpstream);
 	}
 	extlen = (box->len >= (((uint_fast64_t)1) << 32)) != 0;
 	if (jp2_putuint32(out, extlen ? 1 : box->len)) {
 		goto error;
 	}
 	if (jp2_putuint32(out, box->type)) {
 		goto error;
 	}
 	if (extlen) {
 		if (jp2_putuint64(out, box->len)) {
 			goto error;
 		}
  	}
  	if (dataflag) {
		if (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) {
 		if (jas_stream_copy(out, tmpstream, box->len -
 		  JP2_BOX_HDRLEN(false))) {
 			jas_eprintf(""cannot copy box data\n"");
  			goto error;
  		}
  		jas_stream_close(tmpstream);
 	}
 	return 0;
 error:
 	if (tmpstream) {
 		jas_stream_close(tmpstream);
 	}
 	return -1;
 }","[33, 34, 35, 36]",The jp2_cdef_destroy function in jp2_cod.c in JasPer before 2.0.13 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted image.,jasper,CVE-2017-6850,CWE-476
649,181242," static int decompress_i(AVCodecContext *avctx, uint32_t *dst, int linesize)
 {
     SCPRContext *s = avctx->priv_data;
     GetByteContext *gb = &s->gb;
     int cx = 0, cx1 = 0, k = 0, clr = 0;
     int run, r, g, b, off, y = 0, x = 0, z, ret;
     unsigned backstep = linesize - avctx->width;
     const int cxshift = s->cxshift;
     unsigned lx, ly, ptype;
     reinit_tables(s);
     bytestream2_skip(gb, 2);
     init_rangecoder(&s->rc, gb);
     while (k < avctx->width + 1) {
         ret = decode_unit(s, &s->pixel_model[0][cx + cx1], 400, &r);
         if (ret < 0)
             return ret;
         cx1 = (cx << 6) & 0xFC0;
         cx = r >> cxshift;
         ret = decode_unit(s, &s->pixel_model[1][cx + cx1], 400, &g);
         if (ret < 0)
             return ret;
         cx1 = (cx << 6) & 0xFC0;
         cx = g >> cxshift;
         ret = decode_unit(s, &s->pixel_model[2][cx + cx1], 400, &b);
         if (ret < 0)
             return ret;
         cx1 = (cx << 6) & 0xFC0;
         cx = b >> cxshift;
         ret = decode_value(s, s->run_model[0], 256, 400, &run);
         if (ret < 0)
             return ret;
          clr = (b << 16) + (g << 8) + r;
          k += run;
          while (run-- > 0) {
             if (y >= avctx->height)
                 return AVERROR_INVALIDDATA;
              dst[y * linesize + x] = clr;
              lx = x;
              ly = y;
             x++;
             if (x >= avctx->width) {
                 x = 0;
                 y++;
             }
         }
     }
     off = -linesize - 1;
     ptype = 0;
     while (x < avctx->width && y < avctx->height) {
         ret = decode_value(s, s->op_model[ptype], 6, 1000, &ptype);
         if (ret < 0)
             return ret;
         if (ptype == 0) {
             ret = decode_unit(s, &s->pixel_model[0][cx + cx1], 400, &r);
             if (ret < 0)
                 return ret;
             cx1 = (cx << 6) & 0xFC0;
             cx = r >> cxshift;
             ret = decode_unit(s, &s->pixel_model[1][cx + cx1], 400, &g);
             if (ret < 0)
                 return ret;
             cx1 = (cx << 6) & 0xFC0;
             cx = g >> cxshift;
             ret = decode_unit(s, &s->pixel_model[2][cx + cx1], 400, &b);
             if (ret < 0)
                 return ret;
             clr = (b << 16) + (g << 8) + r;
         }
         if (ptype > 5)
             return AVERROR_INVALIDDATA;
         ret = decode_value(s, s->run_model[ptype], 256, 400, &run);
         if (ret < 0)
             return ret;
         switch (ptype) {
         case 0:
             while (run-- > 0) {
                 if (y >= avctx->height)
                     return AVERROR_INVALIDDATA;
                 dst[y * linesize + x] = clr;
                 lx = x;
                 ly = y;
                 x++;
                 if (x >= avctx->width) {
                     x = 0;
                     y++;
                 }
             }
             break;
         case 1:
             while (run-- > 0) {
                 if (y >= avctx->height)
                     return AVERROR_INVALIDDATA;
                 dst[y * linesize + x] = dst[ly * linesize + lx];
                 lx = x;
                 ly = y;
                 x++;
                 if (x >= avctx->width) {
                     x = 0;
                     y++;
                 }
             }
             clr = dst[ly * linesize + lx];
             break;
         case 2:
             while (run-- > 0) {
                 if (y < 1 || y >= avctx->height)
                     return AVERROR_INVALIDDATA;
                 clr = dst[y * linesize + x + off + 1];
                 dst[y * linesize + x] = clr;
                 lx = x;
                 ly = y;
                 x++;
                 if (x >= avctx->width) {
                     x = 0;
                     y++;
                 }
             }
             break;
         case 4:
             while (run-- > 0) {
                 uint8_t *odst = (uint8_t *)dst;
                 if (y < 1 || y >= avctx->height ||
                     (y == 1 && x == 0))
                     return AVERROR_INVALIDDATA;
                 if (x == 0) {
                     z = backstep;
                 } else {
                     z = 0;
                 }
                 r = odst[(ly * linesize + lx) * 4] +
                     odst[((y * linesize + x) + off - z) * 4 + 4] -
                     odst[((y * linesize + x) + off - z) * 4];
                 g = odst[(ly * linesize + lx) * 4 + 1] +
                     odst[((y * linesize + x) + off - z) * 4 + 5] -
                     odst[((y * linesize + x) + off - z) * 4 + 1];
                 b = odst[(ly * linesize + lx) * 4 + 2] +
                     odst[((y * linesize + x) + off - z) * 4 + 6] -
                     odst[((y * linesize + x) + off - z) * 4 + 2];
                 clr = ((b & 0xFF) << 16) + ((g & 0xFF) << 8) + (r & 0xFF);
                 dst[y * linesize + x] = clr;
                 lx = x;
                 ly = y;
                 x++;
                 if (x >= avctx->width) {
                     x = 0;
                     y++;
                 }
             }
             break;
         case 5:
             while (run-- > 0) {
                 if (y < 1 || y >= avctx->height ||
                     (y == 1 && x == 0))
                     return AVERROR_INVALIDDATA;
                 if (x == 0) {
                     z = backstep;
                 } else {
                     z = 0;
                 }
                 clr = dst[y * linesize + x + off - z];
                 dst[y * linesize + x] = clr;
                 lx = x;
                 ly = y;
                 x++;
                 if (x >= avctx->width) {
                     x = 0;
                     y++;
                 }
             }
             break;
         }
         if (avctx->bits_per_coded_sample == 16) {
             cx1 = (clr & 0x3F00) >> 2;
             cx = (clr & 0xFFFFFF) >> 16;
         } else {
             cx1 = (clr & 0xFC00) >> 4;
             cx = (clr & 0xFFFFFF) >> 18;
         }
     }
     return 0;
 }","[35, 36]","libavcodec/scpr.c in FFmpeg 3.3 before 3.3.1 does not properly validate height and width data, which allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted file.",FFmpeg,CVE-2017-9995,CWE-119
658,179168," static int kempf_decode_tile(G2MContext *c, int tile_x, int tile_y,
                              const uint8_t *src, int src_size)
 {
     int width, height;
     int hdr, zsize, npal, tidx = -1, ret;
     int i, j;
     const uint8_t *src_end = src + src_size;
     uint8_t pal[768], transp[3];
     uLongf dlen = (c->tile_width + 1) * c->tile_height;
     int sub_type;
     int nblocks, cblocks, bstride;
     int bits, bitbuf, coded;
     uint8_t *dst = c->framebuf + tile_x * c->tile_width * 3 +
                    tile_y * c->tile_height * c->framebuf_stride;
     if (src_size < 2)
         return AVERROR_INVALIDDATA;
     width  = FFMIN(c->width  - tile_x * c->tile_width,  c->tile_width);
     height = FFMIN(c->height - tile_y * c->tile_height, c->tile_height);
     hdr = *src++;
     sub_type = hdr >> 5;
     if (sub_type == 0) {
         int j;
         memcpy(transp, src, 3);
         src += 3;
         for (j = 0; j < height; j++, dst += c->framebuf_stride)
             for (i = 0; i < width; i++)
                 memcpy(dst + i * 3, transp, 3);
         return 0;
     } else if (sub_type == 1) {
         return jpg_decode_data(&c->jc, width, height, src, src_end - src,
                                dst, c->framebuf_stride, NULL, 0, 0, 0);
     }
     if (sub_type != 2) {
         memcpy(transp, src, 3);
         src += 3;
     }
     npal = *src++ + 1;
     memcpy(pal, src, npal * 3); src += npal * 3;
     if (sub_type != 2) {
         for (i = 0; i < npal; i++) {
             if (!memcmp(pal + i * 3, transp, 3)) {
                tidx = i;
                break;
             }
         }
     }
     if (src_end - src < 2)
          return 0;
      zsize = (src[0] << 8) | src[1]; src += 2;
    if (src_end - src < zsize)
     if (src_end - src < zsize + (sub_type != 2))
          return AVERROR_INVALIDDATA;
      ret = uncompress(c->kempf_buf, &dlen, src, zsize);
     if (ret)
         return AVERROR_INVALIDDATA;
     src += zsize;
     if (sub_type == 2) {
         kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride,
                           NULL, 0, width, height, pal, npal, tidx);
         return 0;
     }
     nblocks = *src++ + 1;
     cblocks = 0;
     bstride = FFALIGN(width, 16) >> 4;
     bits = 0;
      for (i = 0; i < (FFALIGN(height, 16) >> 4); i++) {
          for (j = 0; j < (FFALIGN(width, 16) >> 4); j++) {
              if (!bits) {
                 if (src >= src_end)
                     return AVERROR_INVALIDDATA;
                  bitbuf = *src++;
                  bits   = 8;
              }
             coded = bitbuf & 1;
             bits--;
             bitbuf >>= 1;
             cblocks += coded;
             if (cblocks > nblocks)
                 return AVERROR_INVALIDDATA;
             c->kempf_flags[j + i * bstride] = coded;
         }
     }
     memset(c->jpeg_tile, 0, c->tile_stride * height);
     jpg_decode_data(&c->jc, width, height, src, src_end - src,
                     c->jpeg_tile, c->tile_stride,
                     c->kempf_flags, bstride, nblocks, 0);
     kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride,
                       c->jpeg_tile, c->tile_stride,
                       width, height, pal, npal, tidx);
     return 0;
 }","[50, 51, 69, 70]",The kempf_decode_tile function in libavcodec/g2meet.c in FFmpeg before 2.0.1 allows remote attackers to cause a denial of service (out-of-bounds heap write) via a G2M4 encoded file.,FFmpeg,CVE-2013-4264,CWE-119
668,179098," static int g2m_init_buffers(G2MContext *c)
 {
     int aligned_height;
     if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) {
         c->framebuf_stride = FFALIGN(c->width * 3, 16);
         aligned_height     = FFALIGN(c->height,    16);
         av_free(c->framebuf);
         c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);
         if (!c->framebuf)
             return AVERROR(ENOMEM);
     }
      if (!c->synth_tile || !c->jpeg_tile ||
          c->old_tile_w < c->tile_width ||
          c->old_tile_h < c->tile_height) {
        c->tile_stride = FFALIGN(c->tile_width * 3, 16);
         c->tile_stride = FFALIGN(c->tile_width, 16) * 3;
          aligned_height = FFALIGN(c->tile_height,    16);
          av_free(c->synth_tile);
          av_free(c->jpeg_tile);
         av_free(c->kempf_buf);
         av_free(c->kempf_flags);
         c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);
         c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);
         c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height
                                     + FF_INPUT_BUFFER_PADDING_SIZE);
         c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);
         if (!c->synth_tile || !c->jpeg_tile ||
             !c->kempf_buf || !c->kempf_flags)
             return AVERROR(ENOMEM);
     }
     return 0;
 }","[15, 16]","The g2m_init_buffers function in libavcodec/g2meet.c in FFmpeg before 2.1 uses an incorrect ordering of arithmetic operations, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted Go2Webinar data.",FFmpeg,CVE-2013-7013,CWE-189
672,180116," m_authenticate(struct Client *client_p, struct Client *source_p,
 	int parc, const char *parv[])
 {
 	struct Client *agent_p = NULL;
 	struct Client *saslserv_p = NULL;
 	if(!IsCapable(source_p, CLICAP_SASL))
 		return 0;
 	if (strlen(client_p->id) == 3)
 	{
 		exit_client(client_p, client_p, client_p, ""Mixing client and server protocol"");
  		return 0;
  	}
 	if (*parv[1] == ':' || strchr(parv[1], ' '))
 	{
 		exit_client(client_p, client_p, client_p, ""Malformed AUTHENTICATE"");
 		return 0;
 	}
  	saslserv_p = find_named_client(ConfigFileEntry.sasl_service);
  	if (saslserv_p == NULL || !IsService(saslserv_p))
  	{
 		sendto_one(source_p, form_str(ERR_SASLABORTED), me.name, EmptyString(source_p->name) ? ""*"" : source_p->name);
 		return 0;
 	}
 	if(source_p->localClient->sasl_complete)
 	{
 		*source_p->localClient->sasl_agent = '\0';
 		source_p->localClient->sasl_complete = 0;
 	}
 	if(strlen(parv[1]) > 400)
 	{
 		sendto_one(source_p, form_str(ERR_SASLTOOLONG), me.name, EmptyString(source_p->name) ? ""*"" : source_p->name);
 		return 0;
 	}
 	if(!*source_p->id)
 	{
 		strcpy(source_p->id, generate_uid());
 		add_to_id_hash(source_p->id, source_p);
 	}
 	if(*source_p->localClient->sasl_agent)
 		agent_p = find_id(source_p->localClient->sasl_agent);
 	if(agent_p == NULL)
 	{
 		sendto_one(saslserv_p, "":%s ENCAP %s SASL %s %s H %s %s"",
 					me.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,
 					source_p->host, source_p->sockhost);
 		if (!strcmp(parv[1], ""EXTERNAL"") && source_p->certfp != NULL)
 			sendto_one(saslserv_p, "":%s ENCAP %s SASL %s %s S %s %s"",
 						me.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,
 						parv[1], source_p->certfp);
 		else
 			sendto_one(saslserv_p, "":%s ENCAP %s SASL %s %s S %s"",
 						me.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,
 						parv[1]);
 		rb_strlcpy(source_p->localClient->sasl_agent, saslserv_p->id, IDLEN);
 	}
 	else
 		sendto_one(agent_p, "":%s ENCAP %s SASL %s %s C %s"",
 				me.id, agent_p->servptr->name, source_p->id, agent_p->id,
 				parv[1]);
 	source_p->localClient->sasl_out++;
 	return 0;
 }","[13, 14, 15, 16, 17]",The m_authenticate function in modules/m_sasl.c in Charybdis before 3.5.3 allows remote attackers to spoof certificate fingerprints and consequently log in as another user via a crafted AUTHENTICATE parameter.,charybdis,CVE-2016-7143,CWE-285
695,182880," GF_Err gf_bin128_parse(const char *string, bin128 value)
 {
 	u32 len;
 	u32	i=0;
 	if (!strnicmp(string, ""0x"", 2)) string += 2;
 	len = (u32) strlen(string);
 	if (len >= 32) {
 		u32 j;
 		for (j=0; j<len; j+=2) {
 			u32 v;
 			char szV[5];
 			while (string[j] && !isalnum(string[j]))
 				j++;
 			if (!string[j])
 				break;
 			sprintf(szV, ""%c%c"", string[j], string[j+1]);
  			sscanf(szV, ""%x"", &v);
  			value[i] = v;
  			i++;
 			if (i > 15) {
 				i++;
 				break;
 			}
  		}
  	}
  	if (i != 16) {
 		GF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (""[CORE] 128bit blob is not 16-bytes long: %s\n"", string));
 		return GF_BAD_PARAM;
 	}
 	return GF_OK;
 }","[20, 21, 22, 23]",gf_bin128_parse in utils/os_divers.c in GPAC 0.7.1 has a buffer overflow issue for the crypt feature when encountering a crafted_drm_file.xml file.,gpac,CVE-2019-11222,CWE-119
698,181858,"  static int jas_iccgetuint32(jas_stream_t *in, jas_iccuint32_t *val)
  {
	ulonglong tmp;
 	jas_ulonglong tmp;
  	if (jas_iccgetuint(in, 4, &tmp))
  		return -1;
  	*val = tmp;
 	return 0;
 }","[3, 4]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
701,179926," psf_fwrite (const void *ptr, sf_count_t bytes, sf_count_t items, SF_PRIVATE *psf)
  {	sf_count_t total = 0 ;
  	ssize_t	count ;
 	if (bytes == 0 || items == 0)
 		return 0 ;
  	if (psf->virtual_io)
  		return psf->vio.write (ptr, bytes*items, psf->vio_user_data) / bytes ;
 	items *= bytes ;
 	if (items <= 0)
 		return 0 ;
 	while (items > 0)
 	{	 
 		count = (items > SENSIBLE_SIZE) ? SENSIBLE_SIZE : items ;
 		count = write (psf->file.filedes, ((const char*) ptr) + total, count) ;
 		if (count == -1)
 		{	if (errno == EINTR)
 				continue ;
 			psf_log_syserr (psf, errno) ;
 			break ;
 			} ;
 		if (count == 0)
 			break ;
 		total += count ;
 		items -= count ;
 		} ;
 	if (psf->is_pipe)
 		psf->pipeoffset += total ;
 	return total / bytes ;
 }  ","[4, 5]",The psf_fwrite function in file_io.c in libsndfile allows attackers to cause a denial of service (divide-by-zero error and application crash) via unspecified vectors related to the headindex variable.,libsndfile,CVE-2014-9756,CWE-189
715,182607," create_watching_parent (void)
 {
   pid_t child;
   sigset_t ourset;
   struct sigaction oldact[3];
   int status = 0;
   int retval;
   retval = pam_open_session (pamh, 0);
   if (is_pam_failure(retval))
     {
       cleanup_pam (retval);
       errx (EXIT_FAILURE, _(""cannot open session: %s""),
 	     pam_strerror (pamh, retval));
     }
   else
     _pam_session_opened = 1;
   memset(oldact, 0, sizeof(oldact));
   child = fork ();
   if (child == (pid_t) -1)
     {
       cleanup_pam (PAM_ABORT);
       err (EXIT_FAILURE, _(""cannot create child process""));
     }
   if (child == 0)
     return;
   if (chdir (""/"") != 0)
     warn (_(""cannot change directory to %s""), ""/"");
   sigfillset (&ourset);
   if (sigprocmask (SIG_BLOCK, &ourset, NULL))
     {
       warn (_(""cannot block signals""));
       caught_signal = true;
     }
   if (!caught_signal)
     {
       struct sigaction action;
       action.sa_handler = su_catch_sig;
       sigemptyset (&action.sa_mask);
       action.sa_flags = 0;
       sigemptyset (&ourset);
     if (!same_session)
       {
         if (sigaddset(&ourset, SIGINT) || sigaddset(&ourset, SIGQUIT))
           {
             warn (_(""cannot set signal handler""));
             caught_signal = true;
           }
       }
     if (!caught_signal && (sigaddset(&ourset, SIGTERM)
                     || sigaddset(&ourset, SIGALRM)
                     || sigaction(SIGTERM, &action, &oldact[0])
                     || sigprocmask(SIG_UNBLOCK, &ourset, NULL))) {
 	  warn (_(""cannot set signal handler""));
 	  caught_signal = true;
 	}
     if (!caught_signal && !same_session && (sigaction(SIGINT, &action, &oldact[1])
                                      || sigaction(SIGQUIT, &action, &oldact[2])))
       {
         warn (_(""cannot set signal handler""));
         caught_signal = true;
       }
     }
   if (!caught_signal)
     {
       pid_t pid;
       for (;;)
 	{
 	  pid = waitpid (child, &status, WUNTRACED);
 	  if (pid != (pid_t)-1 && WIFSTOPPED (status))
 	    {
 	      kill (getpid (), SIGSTOP);
 	      kill (pid, SIGCONT);
 	    }
 	  else
 	    break;
 	}
       if (pid != (pid_t)-1)
         {
           if (WIFSIGNALED (status))
             {
               fprintf (stderr, ""%s%s\n"", strsignal (WTERMSIG (status)),
                        WCOREDUMP (status) ? _("" (core dumped)"") : """");
               status = WTERMSIG (status) + 128;
              }
            else
              status = WEXITSTATUS (status);
 	  child = (pid_t) -1;
          }
        else if (caught_signal)
          status = caught_signal + 128;
       else
         status = 1;
     }
    else
      status = 1;
  if (caught_signal)
   if (caught_signal && child != (pid_t)-1)
      {
        fprintf (stderr, _(""\nSession terminated, killing shell...""));
        kill (child, SIGTERM);
     }
   cleanup_pam (PAM_SUCCESS);
    if (caught_signal)
      {
      sleep (2);
      kill (child, SIGKILL);
      fprintf (stderr, _("" ...killed.\n""));
       if (child != (pid_t)-1)
 	{
 	  sleep (2);
 	  kill (child, SIGKILL);
 	  fprintf (stderr, _("" ...killed.\n""));
 	}
       switch (caught_signal) {
         case SIGTERM:
           sigaction(SIGTERM, &oldact[0], NULL);
           break;
         case SIGINT:
           sigaction(SIGINT, &oldact[1], NULL);
           break;
         case SIGQUIT:
           sigaction(SIGQUIT, &oldact[2], NULL);
           break;
         default:
           caught_signal = SIGKILL;
           break;
       }
       kill(getpid(), caught_signal);
     }
   exit (status);
 }","[87, 96, 97, 105, 106, 107, 108, 109, 110, 111, 112, 113]",A race condition was found in util-linux before 2.32.1 in the way su handled the management of child processes. A local authenticated attacker could use this flaw to kill other processes with root privileges under specific conditions.,util-linux,CVE-2017-2616,CWE-362
731,179956," sd2_parse_rsrc_fork (SF_PRIVATE *psf)
 {	SD2_RSRC rsrc ;
 	int k, marker, error = 0 ;
 	psf_use_rsrc (psf, SF_TRUE) ;
 	memset (&rsrc, 0, sizeof (rsrc)) ;
 	rsrc.rsrc_len = psf_get_filelen (psf) ;
 	psf_log_printf (psf, ""Resource length : %d (0x%04X)\n"", rsrc.rsrc_len, rsrc.rsrc_len) ;
 	if (rsrc.rsrc_len > SIGNED_SIZEOF (psf->header))
 	{	rsrc.rsrc_data = calloc (1, rsrc.rsrc_len) ;
 		rsrc.need_to_free_rsrc_data = SF_TRUE ;
 		}
 	else
 	{
 		rsrc.rsrc_data = psf->header ;
 		rsrc.need_to_free_rsrc_data = SF_FALSE ;
 		} ;
 	psf_fread (rsrc.rsrc_data, rsrc.rsrc_len, 1, psf) ;
 	psf->headindex = psf->headend = rsrc.rsrc_len ;
 	rsrc.data_offset = read_rsrc_int (&rsrc, 0) ;
 	rsrc.map_offset = read_rsrc_int (&rsrc, 4) ;
 	rsrc.data_length = read_rsrc_int (&rsrc, 8) ;
 	rsrc.map_length = read_rsrc_int (&rsrc, 12) ;
 	if (rsrc.data_offset == 0x51607 && rsrc.map_offset == 0x20000)
 	{	psf_log_printf (psf, ""Trying offset of 0x52 bytes.\n"") ;
 		rsrc.data_offset = read_rsrc_int (&rsrc, 0x52 + 0) + 0x52 ;
 		rsrc.map_offset = read_rsrc_int (&rsrc, 0x52 + 4) + 0x52 ;
 		rsrc.data_length = read_rsrc_int (&rsrc, 0x52 + 8) ;
 		rsrc.map_length = read_rsrc_int (&rsrc, 0x52 + 12) ;
 		} ;
 	psf_log_printf (psf, ""  data offset : 0x%04X\n  map  offset : 0x%04X\n""
 				""  data length : 0x%04X\n  map  length : 0x%04X\n"",
 				rsrc.data_offset, rsrc.map_offset, rsrc.data_length, rsrc.map_length) ;
 	if (rsrc.data_offset > rsrc.rsrc_len)
 	{	psf_log_printf (psf, ""Error : rsrc.data_offset (%d, 0x%x) > len\n"", rsrc.data_offset, rsrc.data_offset) ;
 		error = SFE_SD2_BAD_DATA_OFFSET ;
 		goto parse_rsrc_fork_cleanup ;
 		} ;
 	if (rsrc.map_offset > rsrc.rsrc_len)
 	{	psf_log_printf (psf, ""Error : rsrc.map_offset > len\n"") ;
 		error = SFE_SD2_BAD_MAP_OFFSET ;
 		goto parse_rsrc_fork_cleanup ;
 		} ;
 	if (rsrc.data_length > rsrc.rsrc_len)
 	{	psf_log_printf (psf, ""Error : rsrc.data_length > len\n"") ;
 		error = SFE_SD2_BAD_DATA_LENGTH ;
 		goto parse_rsrc_fork_cleanup ;
 		} ;
 	if (rsrc.map_length > rsrc.rsrc_len)
 	{	psf_log_printf (psf, ""Error : rsrc.map_length > len\n"") ;
 		error = SFE_SD2_BAD_MAP_LENGTH ;
 		goto parse_rsrc_fork_cleanup ;
 		} ;
 	if (rsrc.data_offset + rsrc.data_length != rsrc.map_offset || rsrc.map_offset + rsrc.map_length != rsrc.rsrc_len)
 	{	psf_log_printf (psf, ""Error : This does not look like a MacOSX resource fork.\n"") ;
 		error = SFE_SD2_BAD_RSRC ;
 		goto parse_rsrc_fork_cleanup ;
 		} ;
 	if (rsrc.map_offset + 28 >= rsrc.rsrc_len)
 	{	psf_log_printf (psf, ""Bad map offset (%d + 28 > %d).\n"", rsrc.map_offset, rsrc.rsrc_len) ;
 		error = SFE_SD2_BAD_RSRC ;
 		goto parse_rsrc_fork_cleanup ;
 		} ;
 	rsrc.string_offset = rsrc.map_offset + read_rsrc_short (&rsrc, rsrc.map_offset + 26) ;
 	if (rsrc.string_offset > rsrc.rsrc_len)
 	{	psf_log_printf (psf, ""Bad string offset (%d).\n"", rsrc.string_offset) ;
 		error = SFE_SD2_BAD_RSRC ;
 		goto parse_rsrc_fork_cleanup ;
 		} ;
  	rsrc.type_offset = rsrc.map_offset + 30 ;
 	if (rsrc.map_offset + 28 > rsrc.rsrc_len)
 	{	psf_log_printf (psf, ""Bad map offset.\n"") ;
 		goto parse_rsrc_fork_cleanup ;
 		} ;
  	rsrc.type_count = read_rsrc_short (&rsrc, rsrc.map_offset + 28) + 1 ;
  	if (rsrc.type_count < 1)
  	{	psf_log_printf (psf, ""Bad type count.\n"") ;
 		error = SFE_SD2_BAD_RSRC ;
 		goto parse_rsrc_fork_cleanup ;
 		} ;
 	rsrc.item_offset = rsrc.type_offset + rsrc.type_count * 8 ;
 	if (rsrc.item_offset < 0 || rsrc.item_offset > rsrc.rsrc_len)
 	{	psf_log_printf (psf, ""Bad item offset (%d).\n"", rsrc.item_offset) ;
 		error = SFE_SD2_BAD_RSRC ;
 		goto parse_rsrc_fork_cleanup ;
 		} ;
  	rsrc.str_index = -1 ;
  	for (k = 0 ; k < rsrc.type_count ; k ++)
	{	marker = read_rsrc_marker (&rsrc, rsrc.type_offset + k * 8) ;
 	{	if (rsrc.type_offset + k * 8 > rsrc.rsrc_len)
 		{	psf_log_printf (psf, ""Bad rsrc marker.\n"") ;
 			goto parse_rsrc_fork_cleanup ;
 			} ;
 		marker = read_rsrc_marker (&rsrc, rsrc.type_offset + k * 8) ;
  		if (marker == STR_MARKER)
  		{	rsrc.str_index = k ;
 			rsrc.str_count = read_rsrc_short (&rsrc, rsrc.type_offset + k * 8 + 4) + 1 ;
 			error = parse_str_rsrc (psf, &rsrc) ;
 			goto parse_rsrc_fork_cleanup ;
 			} ;
 		} ;
 	psf_log_printf (psf, ""No 'STR ' resource.\n"") ;
 	error = SFE_SD2_BAD_RSRC ;
 parse_rsrc_fork_cleanup :
 	psf_use_rsrc (psf, SF_FALSE) ;
 	if (rsrc.need_to_free_rsrc_data)
 		free (rsrc.rsrc_data) ;
 	return error ;
 }  ","[70, 71, 72, 73, 88, 89, 90, 91, 92, 93]","The sd2_parse_rsrc_fork function in sd2.c in libsndfile allows attackers to have unspecified impact via vectors related to a (1) map offset or (2) rsrc marker, which triggers an out-of-bounds read.",libsndfile,CVE-2014-9496,CWE-119
736,182982,"  sec_decrypt(uint8 * data, int length)
  {
 	if (length <= 0)
 		return;
  	if (g_sec_decrypt_use_count == 4096)
  	{
  		sec_update(g_sec_decrypt_key, g_sec_decrypt_update_key);
 		rdssl_rc4_set_key(&g_rc4_decrypt_key, g_sec_decrypt_key, g_rc4_key_len);
 		g_sec_decrypt_use_count = 0;
 	}
 	rdssl_rc4_crypt(&g_rc4_decrypt_key, data, data, length);
 	g_sec_decrypt_use_count++;
 }","[3, 4]",rdesktop versions up to and including v1.8.3 contain a Buffer Overflow over the global variables in the function seamless_process_line() that results in memory corruption and probably even a remote code execution.,rdesktop,CVE-2018-20182,CWE-119
746,180806," on_unregister_handler(TCMUService1HandlerManager1 *interface,
 		      GDBusMethodInvocation *invocation,
 		      gchar *subtype,
 		      gpointer user_data)
 {
 	struct tcmur_handler *handler = find_handler_by_subtype(subtype);
 	struct dbus_info *info = handler ? handler->opaque : NULL;
 	if (!handler) {
 		g_dbus_method_invocation_return_value(invocation,
 			g_variant_new(""(bs)"", FALSE,
  				      ""unknown subtype""));
  		return TRUE;
  	}
 	else if (handler->_is_dbus_handler != 1) {
 		g_dbus_method_invocation_return_value(invocation,
 			g_variant_new(""(bs)"", FALSE,
 				      ""cannot unregister internal handler""));
 		return TRUE;
 	}
  	dbus_unexport_handler(handler);
	tcmur_unregister_handler(handler);
 	tcmur_unregister_dbus_handler(handler);
  	g_bus_unwatch_name(info->watcher_id);
  	g_free(info);
  	g_free(handler);
 	g_dbus_method_invocation_return_value(invocation,
 		g_variant_new(""(bs)"", TRUE, ""succeeded""));
 	return TRUE;
 }","[14, 15, 16, 17, 18, 19, 21, 22]",tcmu-runner version 1.0.5 to 1.2.0 is vulnerable to a dbus triggered NULL pointer dereference in the tcmu-runner daemon's on_unregister_handler() function resulting in denial of service,tcmu-runner,CVE-2017-1000200,CWE-476
750,179439," FUNC_DECODER(dissector_postgresql)
 {
    DECLARE_DISP_PTR(ptr);
    struct ec_session *s = NULL;
    void *ident = NULL;
    char tmp[MAX_ASCII_ADDR_LEN];
    struct postgresql_status *conn_status;
    (void) DECODE_DATA; 
    (void) DECODE_DATALEN;
    (void) DECODED_LEN;
    if (FROM_CLIENT(""postgresql"", PACKET)) {
       if (PACKET->DATA.len < 4)
          return NULL;
       dissect_create_ident(&ident, PACKET, DISSECT_CODE(dissector_postgresql));
       if (session_get(&s, ident, DISSECT_IDENT_LEN) == -ENOTFOUND) {
          unsigned char *u = memmem(ptr, PACKET->DATA.len, ""user"", 4);
          unsigned char *d = memmem(ptr, PACKET->DATA.len, ""database"", 8);
          if (!memcmp(ptr + 4, ""\x00\x03\x00\x00"", 4) && u && d) {
             dissect_create_session(&s, PACKET, DISSECT_CODE(dissector_postgresql));
             SAFE_CALLOC(s->data, 1, sizeof(struct postgresql_status));
             conn_status = (struct postgresql_status *) s->data;
             conn_status->status = WAIT_AUTH;
             strncpy((char*)conn_status->user, (char*)(u + 5), 65);
             conn_status->user[64] = 0;
             strncpy((char*)conn_status->database, (char*)(d + 9), 65);
             conn_status->database[64] = 0;
             session_put(s);
          }
       } else {
          conn_status = (struct postgresql_status *) s->data;
          if (conn_status->status == WAIT_RESPONSE) {
             if (ptr[0] == 'p' && conn_status->type == MD5) {
                DEBUG_MSG(""\tDissector_postgresql RESPONSE type is MD5"");
                if(memcmp(ptr + 1, ""\x00\x00\x00\x28"", 4)) {
                   DEBUG_MSG(""\tDissector_postgresql BUG, expected length is 40"");
                   return NULL;
                }
                if (PACKET->DATA.len < 40) {
                   DEBUG_MSG(""\tDissector_postgresql BUG, expected length is 40"");
                   return NULL;
                }
                memcpy(conn_status->hash, ptr + 5 + 3, 32);
                conn_status->hash[32] = 0;
                DISSECT_MSG(""%s:$postgres$%s*%s*%s:%s:%d\n"", conn_status->user, conn_status->user, conn_status->salt, conn_status->hash, ip_addr_ntoa(&PACKET->L3.dst, tmp), ntohs(PACKET->L4.dst));
                dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));
             }
             else if (ptr[0] == 'p' && conn_status->type == CT) {
                 int length;
                 DEBUG_MSG(""\tDissector_postgresql RESPONSE type is clear-text!"");
                 GET_ULONG_BE(length, ptr, 1);
               strncpy((char*)conn_status->password, (char*)(ptr + 5), length - 4);
               conn_status->password[length - 4] = 0;
                length -= 4;
                if (length < 0 || length > 65 || PACKET->DATA.len < length+5) {
                    dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));
                    return NULL;
                }
                snprintf((char*)conn_status->password, length+1, ""%s"", (char*)(ptr + 5));
                 DISSECT_MSG(""PostgreSQL credentials:%s-%d:%s:%s\n"", ip_addr_ntoa(&PACKET->L3.dst, tmp), ntohs(PACKET->L4.dst), conn_status->user, conn_status->password);
                 dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));
              }
          }
       }
    } else {  
       if (PACKET->DATA.len < 9)
          return NULL;
       dissect_create_ident(&ident, PACKET, DISSECT_CODE(dissector_postgresql));
       if (session_get(&s, ident, DISSECT_IDENT_LEN) == ESUCCESS) {
          conn_status = (struct postgresql_status *) s->data;
          if (conn_status->status == WAIT_AUTH &&
                ptr[0] == 'R' && !memcmp(ptr + 1, ""\x00\x00\x00\x0c"", 4)  &&
                !memcmp(ptr + 5, ""\x00\x00\x00\x05"", 4)) {
             conn_status->status = WAIT_RESPONSE;
             conn_status->type = MD5;
             DEBUG_MSG(""\tDissector_postgresql AUTH type is MD5"");
             hex_encode(ptr + 9, 4, conn_status->salt);  
          }
          else if (conn_status->status == WAIT_AUTH &&
                ptr[0] == 'R' && !memcmp(ptr + 1, ""\x00\x00\x00\x08"", 4)  &&
                !memcmp(ptr + 5, ""\x00\x00\x00\x03"", 4)) {
             conn_status->status = WAIT_RESPONSE;
             conn_status->type = CT;
             DEBUG_MSG(""\tDissector_postgresql AUTH type is clear-text!"");
          }
       }
    }
    SAFE_FREE(ident);
    return NULL;
 }","[51, 52, 53, 54, 55, 56, 57, 58]","The dissector_postgresql function in dissectors/ec_postgresql.c in Ettercap before 0.8.1 allows remote attackers to cause a denial of service and possibly execute arbitrary code via a crafted password length, which triggers a 0 character to be written to an arbitrary memory location.",ettercap,CVE-2014-6396,CWE-119
765,181901,"  int ras_validate(jas_stream_t *in)
  {
	uchar buf[RAS_MAGICLEN];
 	jas_uchar buf[RAS_MAGICLEN];
  	int i;
  	int n;
  	uint_fast32_t magic;
 	assert(JAS_STREAM_MAXPUTBACK >= RAS_MAGICLEN);
 	if ((n = jas_stream_read(in, buf, RAS_MAGICLEN)) < 0) {
 		return -1;
 	}
 	for (i = n - 1; i >= 0; --i) {
 		if (jas_stream_ungetc(in, buf[i]) == EOF) {
 			return -1;
 		}
 	}
 	if (n < RAS_MAGICLEN) {
 		return -1;
 	}
 	magic = (JAS_CAST(uint_fast32_t, buf[0]) << 24) |
 	  (JAS_CAST(uint_fast32_t, buf[1]) << 16) |
 	  (JAS_CAST(uint_fast32_t, buf[2]) << 8) |
 	  buf[3];
 	if (magic != RAS_MAGIC) {
 		return -1;
 	}
 	return 0;
 }","[3, 4]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
801,182229," iasecc_get_serialnr(struct sc_card *card, struct sc_serial_number *serial)
 {
 	struct sc_context *ctx = card->ctx;
 	struct sc_iin *iin = &card->serialnr.iin;
 	struct sc_apdu apdu;
 	unsigned char rbuf[0xC0];
 	size_t ii, offs;
 	int rv;
 	LOG_FUNC_CALLED(ctx);
 	if (card->serialnr.len)
 		goto end;
 	memset(&card->serialnr, 0, sizeof(card->serialnr));
 	sc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xB0, 0x80 | IASECC_SFI_EF_SN, 0);
 	apdu.le = sizeof(rbuf);
 	apdu.resp = rbuf;
 	apdu.resplen = sizeof(rbuf);
 	rv = sc_transmit_apdu(card, &apdu);
 	LOG_TEST_RET(ctx, rv, ""APDU transmit failed"");
 	rv = sc_check_sw(card, apdu.sw1, apdu.sw2);
 	LOG_TEST_RET(ctx, rv, ""Get 'serial number' data failed"");
 	if (rbuf[0] != ISO7812_PAN_SN_TAG)
 		LOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, ""serial number parse error"");
 	iin->mii = (rbuf[2] >> 4) & 0x0F;
 	iin->country = 0;
 	for (ii=5; ii<8; ii++)   {
 		iin->country *= 10;
 		iin->country += (rbuf[ii/2] >> ((ii & 0x01) ? 0 : 4)) & 0x0F;
 	}
 	iin->issuer_id = 0;
 	for (ii=8; ii<10; ii++)   {
 		iin->issuer_id *= 10;
 		iin->issuer_id += (rbuf[ii/2] >> (ii & 0x01 ? 0 : 4)) & 0x0F;
 	}
 	offs = rbuf[1] > 8 ? rbuf[1] - 8 : 0;
  	if (card->type == SC_CARD_TYPE_IASECC_SAGEM)   {
		for (ii=0; ii < rbuf[1] - offs; ii++)
 		for (ii=0; (ii < rbuf[1] - offs) && (ii + offs + 2 < sizeof(rbuf)); ii++)
  			*(card->serialnr.value + ii) = ((rbuf[ii + offs + 1] & 0x0F) << 4)
  				+ ((rbuf[ii + offs + 2] & 0xF0) >> 4) ;
  		card->serialnr.len = ii;
 	}
 	else   {
 		for (ii=0; ii < rbuf[1] - offs; ii++)
 			*(card->serialnr.value + ii) = rbuf[ii + offs + 2];
 		card->serialnr.len = ii;
 	}
 	do  {
 		char txt[0x200];
 		for (ii=0;ii<card->serialnr.len;ii++)
 			sprintf(txt + ii*2, ""%02X"", *(card->serialnr.value + ii));
 		sc_log(ctx, ""serial number '%s'; mii %i; country %i; issuer_id %li"", txt, iin->mii, iin->country, iin->issuer_id);
 	} while(0);
 end:
 	if (serial)
 		memcpy(serial, &card->serialnr, sizeof(*serial));
 	LOG_FUNC_RETURN(ctx, SC_SUCCESS);
 }","[36, 37]",Various out of bounds reads when handling responses in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to potentially crash the opensc library using programs.,OpenSC,CVE-2018-16427,CWE-125
822,182872," static void Sp_search(js_State *J)
 {
 	js_Regexp *re;
 	const char *text;
 	Resub m;
 	text = checkstring(J, 0);
 	if (js_isregexp(J, 1))
 		js_copy(J, 1);
 	else if (js_isundefined(J, 1))
 		js_newregexp(J, """", 0);
 	else
 		js_newregexp(J, js_tostring(J, 1), 0);
  	re = js_toregexp(J, -1);
	if (!js_regexec(re->prog, text, &m, 0))
 	if (!js_doregexec(J, re->prog, text, &m, 0))
  		js_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));
  	else
  		js_pushnumber(J, -1);
 }","[14, 15]",An issue was discovered in Artifex MuJS 1.0.5. It has unlimited recursion because the match function in regexp.c lacks a depth check.,mujs,CVE-2019-11413,CWE-400
859,181484," aiff_read_chanmap (SF_PRIVATE * psf, unsigned dword)
 {	const AIFF_CAF_CHANNEL_MAP * map_info ;
 	unsigned channel_bitmap, channel_decriptions, bytesread ;
 	int layout_tag ;
 	bytesread = psf_binheader_readf (psf, ""444"", &layout_tag, &channel_bitmap, &channel_decriptions) ;
 	if ((map_info = aiff_caf_of_channel_layout_tag (layout_tag)) == NULL)
 		return 0 ;
 	psf_log_printf (psf, ""  Tag    : %x\n"", layout_tag) ;
 	if (map_info)
 		psf_log_printf (psf, ""  Layout : %s\n"", map_info->name) ;
 	if (bytesread < dword)
  		psf_binheader_readf (psf, ""j"", dword - bytesread) ;
  	if (map_info->channel_map != NULL)
	{	size_t chanmap_size = psf->sf.channels * sizeof (psf->channel_map [0]) ;
 	{	size_t chanmap_size = SF_MIN (psf->sf.channels, layout_tag & 0xffff) * sizeof (psf->channel_map [0]) ;
  		free (psf->channel_map) ;
 		if ((psf->channel_map = malloc (chanmap_size)) == NULL)
 			return SFE_MALLOC_FAILED ;
 		memcpy (psf->channel_map, map_info->channel_map, chanmap_size) ;
 		} ;
 	return 0 ;
 }  ","[14, 15]","In libsndfile version 1.0.28, an error in the *aiff_read_chanmap()* function (aiff.c) can be exploited to cause an out-of-bounds read memory access via a specially crafted AIFF file.",libsndfile,CVE-2017-6892,CWE-119
861,180938," static int mxf_read_primer_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)
 {
     MXFContext *mxf = arg;
     int item_num = avio_rb32(pb);
     int item_len = avio_rb32(pb);
     if (item_len != 18) {
          avpriv_request_sample(pb, ""Primer pack item length %d"", item_len);
          return AVERROR_PATCHWELCOME;
      }
    if (item_num > 65536) {
     if (item_num > 65536 || item_num < 0) {
          av_log(mxf->fc, AV_LOG_ERROR, ""item_num %d is too large\n"", item_num);
          return AVERROR_INVALIDDATA;
      }
     if (mxf->local_tags)
         av_log(mxf->fc, AV_LOG_VERBOSE, ""Multiple primer packs\n"");
     av_free(mxf->local_tags);
     mxf->local_tags_count = 0;
     mxf->local_tags = av_calloc(item_num, item_len);
     if (!mxf->local_tags)
         return AVERROR(ENOMEM);
     mxf->local_tags_count = item_num;
     avio_read(pb, mxf->local_tags, item_num*item_len);
     return 0;
 }","[10, 11]","In the mxf_read_primer_pack function in libavformat/mxfdec.c in FFmpeg 3.3.3, an integer signedness error might occur when a crafted file, which claims a large *item_num* field such as 0xffffffff, is provided. As a result, the variable *item_num* turns negative, bypassing the check for a large value.",FFmpeg,CVE-2017-14169,CWE-20
875,8132,"GF_Err gf_isom_oinf_read_entry(void *entry, GF_BitStream *bs)
{
GF_OperatingPointsInformation* ptr = (GF_OperatingPointsInformation *)entry;
u32 i, j, count;
if (!ptr) return GF_BAD_PARAM;
ptr->scalability_mask = gf_bs_read_u16(bs);
gf_bs_read_int(bs, 2);
count = gf_bs_read_int(bs, 6);
for (i = 0; i < count; i++) {
LHEVC_ProfileTierLevel *ptl;
GF_SAFEALLOC(ptl, LHEVC_ProfileTierLevel);
if (!ptl) return GF_OUT_OF_MEM;
ptl->general_profile_space = gf_bs_read_int(bs, 2);
ptl->general_tier_flag= gf_bs_read_int(bs, 1);
ptl->general_profile_idc = gf_bs_read_int(bs, 5);
ptl->general_profile_compatibility_flags = gf_bs_read_u32(bs);
ptl->general_constraint_indicator_flags = gf_bs_read_long_int(bs, 48);
ptl->general_level_idc = gf_bs_read_u8(bs);
gf_list_add(ptr->profile_tier_levels, ptl);
}
count = gf_bs_read_u16(bs);
for (i = 0; i < count; i++) {
LHEVC_OperatingPoint *op;
GF_SAFEALLOC(op, LHEVC_OperatingPoint);
if (!op) return GF_OUT_OF_MEM;
op->output_layer_set_idx = gf_bs_read_u16(bs);
op->max_temporal_id = gf_bs_read_u8(bs);
op->layer_count = gf_bs_read_u8(bs);
if (op->layer_count > GF_ARRAY_LENGTH(op->layers_info))
return GF_NON_COMPLIANT_BITSTREAM;
for (j = 0; j < op->layer_count; j++) {
op->layers_info[j].ptl_idx = gf_bs_read_u8(bs);
op->layers_info[j].layer_id = gf_bs_read_int(bs, 6);
op->layers_info[j].is_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;
op->layers_info[j].is_alternate_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;
}
op->minPicWidth = gf_bs_read_u16(bs);
op->minPicHeight = gf_bs_read_u16(bs);
op->maxPicWidth = gf_bs_read_u16(bs);
op->maxPicHeight = gf_bs_read_u16(bs);
op->maxChromaFormat = gf_bs_read_int(bs, 2);
op->maxBitDepth = gf_bs_read_int(bs, 3) + 8;
gf_bs_read_int(bs, 1);
op->frame_rate_info_flag = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;
op->bit_rate_info_flag = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;
if (op->frame_rate_info_flag) {
op->avgFrameRate = gf_bs_read_u16(bs);
gf_bs_read_int(bs, 6);
op->constantFrameRate = gf_bs_read_int(bs, 2);
}
if (op->bit_rate_info_flag) {
op->maxBitRate = gf_bs_read_u32(bs);
op->avgBitRate = gf_bs_read_u32(bs);
}
gf_list_add(ptr->operating_points, op);
}
count = gf_bs_read_u8(bs);
for (i = 0; i < count; i++) {
LHEVC_DependentLayer *dep;
GF_SAFEALLOC(dep, LHEVC_DependentLayer);
if (!dep) return GF_OUT_OF_MEM;
dep->dependent_layerID = gf_bs_read_u8(bs);
dep->num_layers_dependent_on = gf_bs_read_u8(bs);
if (dep->num_layers_dependent_on > GF_ARRAY_LENGTH(dep->dependent_on_layerID)) {
gf_free(dep);
return GF_NON_COMPLIANT_BITSTREAM;
}
for (j = 0; j < dep->num_layers_dependent_on; j++)
dep->dependent_on_layerID[j] = gf_bs_read_u8(bs);
for (j = 0; j < 16; j++) {
if (ptr->scalability_mask & (1 << j))
dep->dimension_identifier[j] = gf_bs_read_u8(bs);
}
gf_list_add(ptr->dependency_layers, dep);
}
return GF_OK;
}","[29, 31]",Memory leak in the gf_isom_oinf_read_entry function in MP4Box in GPAC 1.0.1 allows attackers to read memory via a crafted file.,gpac,CVE-2021-33366,CWE-401
878,5563,"static int lookup1_values(int entries, int dim)
{
int r = (int) floor(exp((float) log((float) entries) / dim));
if ((int) floor(pow((float) r+1, dim)) <= entries)
++r;
assert(pow((float) r+1, dim) > entries);
assert((int) floor(pow((float) r, dim)) <= entries);
return r;
}","[6, 7]",A heap buffer overflow in the start_decoder function in stb_vorbis through 2019-03-04 allows an attacker to cause a denial of service or execute arbitrary code by opening a crafted Ogg Vorbis file.,stb,CVE-2019-13217,CWE-787
886,4511,"const char * util_acl_to_str(const sc_acl_entry_t *e)
{
static char line[80], buf[20];
unsigned int acl;
if (e == NULL)
return ""N/A"";
line[0] = 0;
while (e != NULL) {
acl = e->method;
switch (acl) {
case SC_AC_UNKNOWN:
return ""N/A"";
case SC_AC_NEVER:
return ""NEVR"";
case SC_AC_NONE:
return ""NONE"";
case SC_AC_CHV:
strcpy(buf, ""CHV"");
if (e->key_ref != SC_AC_KEY_REF_NONE)
sprintf(buf + 3, ""%d"", e->key_ref);
break;
case SC_AC_TERM:
strcpy(buf, ""TERM"");
break;
case SC_AC_PRO:
strcpy(buf, ""PROT"");
break;
case SC_AC_AUT:
strcpy(buf, ""AUTH"");
if (e->key_ref != SC_AC_KEY_REF_NONE)
sprintf(buf + 4, ""%d"", e->key_ref);
break;
case SC_AC_SEN:
strcpy(buf, ""Sec.Env. "");
if (e->key_ref != SC_AC_KEY_REF_NONE)
sprintf(buf + 3, ""#%d"", e->key_ref);
break;
case SC_AC_SCB:
strcpy(buf, ""Sec.ControlByte "");
if (e->key_ref != SC_AC_KEY_REF_NONE)
sprintf(buf + 3, ""Ox%X"", e->key_ref);
break;
case SC_AC_IDA:
strcpy(buf, ""PKCS#15 AuthID "");
if (e->key_ref != SC_AC_KEY_REF_NONE)
sprintf(buf + 3, ""#%d"", e->key_ref);
break;
default:
strcpy(buf, ""????"");
break;
}
strcat(line, buf);
strcat(line, "" "");
e = e->next;
}
line[strlen(line)-1] = 0;
return line;
}","[52, 53, 56]",Several buffer overflows when handling responses from a Muscle Card in muscle_list_files in libopensc/card-muscle.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.,OpenSC,CVE-2018-16391,CWE-119
891,8577,"free_link_refs(struct link_ref **references)
{
size_t i;
for (i = 0; i < REF_TABLE_SIZE; ++i) {
struct link_ref *r = references[i];
struct link_ref *next;
while (r) {
next = r->next;
bufrelease(r->link);
bufrelease(r->title);
free(r);
r = next;
}
}
}",[9],"Snudown is a reddit-specific fork of the Sundown Markdown parser used by GitHub, with Python integration added. In affected versions snudown was found to be vulnerable to denial of service attacks to its reference table implementation. References written in markdown ` [reference_name]: https://www.example.com` are inserted into a hash table which was found to have a weak hash function, meaning that an attacker can reliably generate a large number of collisions for it. This makes the hash table vulnerable to a hash-collision DoS attack, a type of algorithmic complexity attack. Further the hash table allowed for duplicate entries resulting in long retrieval times. Proofs of concept and further discussion of the hash collision issue are discussed on the snudown GHSA(https://github.com/reddit/snudown/security/advisories/GHSA-6gvv-9q92-w5f6). Users are advised to update to version 1.7.0.",snudown,CVE-2021-41168,CWE-407
900,4350,"void RemoteFsDevice::unmount()
{
if (details.isLocalFile()) {
return;
}
if (!isConnected() || proc) {
return;
}
if (messageSent) {
return;
}
if (constSambaProtocol==details.url.scheme() || constSambaAvahiProtocol==details.url.scheme()) {
mounter()->umount(mountPoint(details, false), getpid());
setStatusMessage(tr(""Disconnecting...""));
messageSent=true;
return;
}
QString cmd;
QStringList args;
if (!details.isLocalFile()) {
QString mp=mountPoint(details, false);
if (!mp.isEmpty()) {
cmd=Utils::findExe(""fusermount"");
if (!cmd.isEmpty()) {
args << QLatin1String(""-u"") << QLatin1String(""-z"") << mp;
} else {
emit error(tr(""\""fusermount\"" is not installed!""));
}
}
}
if (!cmd.isEmpty()) {
setStatusMessage(tr(""Disconnecting...""));
proc=new QProcess(this);
proc->setProperty(""unmount"", true);
connect(proc, SIGNAL(finished(int)), SLOT(procFinished(int)));
proc->start(cmd, args, QIODevice::ReadOnly);
}
}","[12, 13, 14, 15, 16]","An issue was discovered in the cantata-mounter D-Bus service in Cantata through 2.3.1. The mount target path check in mounter.cpp `mpOk()` is insufficient. A regular user can consequently mount a CIFS filesystem anywhere (e.g., outside of the /home directory tree) by passing directory traversal sequences such as a home/../usr substring.",cantata,CVE-2018-12559,CWE-22
903,7505,"static int shm_create(XShmSegmentInfo *shm, XImage **ximg_ptr, int w, int h,
char *name) {
XImage *xim;
static int reported_flip = 0;
int db = 0;
shm->shmid = -1;
shm->shmaddr = (char *) -1;
*ximg_ptr = NULL;
if (nofb) {
return 1;
}
X_LOCK;
if (! using_shm || xform24to32 || raw_fb) {
xim = XCreateImage_wr(dpy, default_visual, depth, ZPixmap,
0, NULL, w, h, raw_fb ? 32 : BitmapPad(dpy), 0);
X_UNLOCK;
if (xim == NULL) {
rfbErr(""XCreateImage(%s) failed.\n"", name);
if (quiet) {
fprintf(stderr, ""XCreateImage(%s) failed.\n"",
name);
}
return 0;
}
if (db) fprintf(stderr, ""shm_create simple %d %d\t%p %s\n"", w, h, (void *)xim, name);
xim->data = (char *) malloc(xim->bytes_per_line * xim->height);
if (xim->data == NULL) {
rfbErr(""XCreateImage(%s) data malloc failed.\n"", name);
if (quiet) {
fprintf(stderr, ""XCreateImage(%s) data malloc""
"" failed.\n"", name);
}
return 0;
}
if (flip_byte_order) {
char *order = flip_ximage_byte_order(xim);
if (! reported_flip && ! quiet) {
rfbLog(""Changing XImage byte order""
"" to %s\n"", order);
reported_flip = 1;
}
}
*ximg_ptr = xim;
return 1;
}
if (! dpy) {
X_UNLOCK;
return 0;
}
xim = XShmCreateImage_wr(dpy, default_visual, depth, ZPixmap, NULL,
shm, w, h);
if (xim == NULL) {
rfbErr(""XShmCreateImage(%s) failed.\n"", name);
if (quiet) {
fprintf(stderr, ""XShmCreateImage(%s) failed.\n"", name);
}
X_UNLOCK;
return 0;
}
*ximg_ptr = xim;
#if HAVE_XSHM
shm->shmid = shmget(IPC_PRIVATE,
xim->bytes_per_line * xim->height, IPC_CREAT | 0777);
if (shm->shmid == -1) {
rfbErr(""shmget(%s) failed.\n"", name);
rfbLogPerror(""shmget"");
XDestroyImage(xim);
*ximg_ptr = NULL;
X_UNLOCK;
return 0;
}
shm->shmaddr = xim->data = (char *) shmat(shm->shmid, 0, 0);
if (shm->shmaddr == (char *)-1) {
rfbErr(""shmat(%s) failed.\n"", name);
rfbLogPerror(""shmat"");
XDestroyImage(xim);
*ximg_ptr = NULL;
shmctl(shm->shmid, IPC_RMID, 0);
shm->shmid = -1;
X_UNLOCK;
return 0;
}
shm->readOnly = False;
if (! XShmAttach_wr(dpy, shm)) {
rfbErr(""XShmAttach(%s) failed.\n"", name);
XDestroyImage(xim);
*ximg_ptr = NULL;
shmdt(shm->shmaddr);
shm->shmaddr = (char *) -1;
shmctl(shm->shmid, IPC_RMID, 0);
shm->shmid = -1;
X_UNLOCK;
return 0;
}
#endif
X_UNLOCK;
return 1;
}",[63],"scan.c in x11vnc 0.9.16 uses IPC_CREAT|0777 in shmget calls, which allows access by actors other than the current user.",x11vnc,CVE-2020-29074,CWE-862
904,8482,"s32 gf_avc_parse_nalu(GF_BitStream *bs, AVCState *avc)
{
u8 idr_flag;
s32 slice, ret;
u32 nal_hdr;
AVCSliceInfo n_state;
gf_bs_enable_emulation_byte_removal(bs, GF_TRUE);
nal_hdr = gf_bs_read_u8(bs);
slice = 0;
memcpy(&n_state, &avc->s_info, sizeof(AVCSliceInfo));
avc->last_nal_type_parsed = n_state.nal_unit_type = nal_hdr & 0x1F;
n_state.nal_ref_idc = (nal_hdr >> 5) & 0x3;
idr_flag = 0;
switch (n_state.nal_unit_type) {
case GF_AVC_NALU_ACCESS_UNIT:
case GF_AVC_NALU_END_OF_SEQ:
case GF_AVC_NALU_END_OF_STREAM:
ret = 1;
break;
case GF_AVC_NALU_SVC_SLICE:
SVC_ReadNal_header_extension(bs, &n_state.NalHeader);
svc_parse_slice(bs, avc, &n_state);
if (avc->s_info.nal_ref_idc) {
n_state.poc_lsb_prev = avc->s_info.poc_lsb;
n_state.poc_msb_prev = avc->s_info.poc_msb;
}
avc_compute_poc(&n_state);
if (avc->s_info.poc != n_state.poc) {
memcpy(&avc->s_info, &n_state, sizeof(AVCSliceInfo));
return 1;
}
memcpy(&avc->s_info, &n_state, sizeof(AVCSliceInfo));
return 0;
case GF_AVC_NALU_SVC_PREFIX_NALU:
SVC_ReadNal_header_extension(bs, &n_state.NalHeader);
return 0;
case GF_AVC_NALU_IDR_SLICE:
case GF_AVC_NALU_NON_IDR_SLICE:
case GF_AVC_NALU_DP_A_SLICE:
case GF_AVC_NALU_DP_B_SLICE:
case GF_AVC_NALU_DP_C_SLICE:
slice = 1;
ret = avc_parse_slice(bs, avc, idr_flag, &n_state);
if (ret < 0) return ret;
ret = 0;
if (
((avc->s_info.nal_unit_type > GF_AVC_NALU_IDR_SLICE) || (avc->s_info.nal_unit_type < GF_AVC_NALU_NON_IDR_SLICE))
&& (avc->s_info.nal_unit_type != GF_AVC_NALU_SVC_SLICE)
) {
break;
}
if (avc->s_info.frame_num != n_state.frame_num) {
ret = 1;
break;
}
if (avc->s_info.field_pic_flag != n_state.field_pic_flag) {
ret = 1;
break;
}
if ((avc->s_info.nal_ref_idc != n_state.nal_ref_idc) &&
(!avc->s_info.nal_ref_idc || !n_state.nal_ref_idc)) {
ret = 1;
break;
}
assert(avc->s_info.sps);
if (avc->s_info.sps->poc_type == n_state.sps->poc_type) {
if (!avc->s_info.sps->poc_type) {
if (!n_state.bottom_field_flag && (avc->s_info.poc_lsb != n_state.poc_lsb)) {
ret = 1;
break;
}
if (avc->s_info.delta_poc_bottom != n_state.delta_poc_bottom) {
ret = 1;
break;
}
}
else if (avc->s_info.sps->poc_type == 1) {
if (avc->s_info.delta_poc[0] != n_state.delta_poc[0]) {
ret = 1;
break;
}
if (avc->s_info.delta_poc[1] != n_state.delta_poc[1]) {
ret = 1;
break;
}
}
}
if (n_state.nal_unit_type == GF_AVC_NALU_IDR_SLICE) {
if (avc->s_info.nal_unit_type != GF_AVC_NALU_IDR_SLICE) {
ret = 1;
break;
}
else if (avc->s_info.idr_pic_id != n_state.idr_pic_id) {
ret = 1;
break;
}
}
break;
case GF_AVC_NALU_SEQ_PARAM:
avc->last_ps_idx = gf_avc_read_sps_bs_internal(bs, avc, 0, NULL, nal_hdr);
if (avc->last_ps_idx < 0) return -1;
return 0;
case GF_AVC_NALU_PIC_PARAM:
avc->last_ps_idx = gf_avc_read_pps_bs_internal(bs, avc, nal_hdr);
if (avc->last_ps_idx < 0) return -1;
return 0;
case GF_AVC_NALU_SVC_SUBSEQ_PARAM:
avc->last_ps_idx = gf_avc_read_sps_bs_internal(bs, avc, 1, NULL, nal_hdr);
if (avc->last_ps_idx < 0) return -1;
return 0;
case GF_AVC_NALU_SEQ_PARAM_EXT:
avc->last_ps_idx = (s32) gf_bs_read_ue(bs);
if (avc->last_ps_idx < 0) return -1;
return 0;
case GF_AVC_NALU_SEI:
case GF_AVC_NALU_FILLER_DATA:
return 0;
default:
if (avc->s_info.nal_unit_type <= GF_AVC_NALU_IDR_SLICE) ret = 1;
else if ((nal_hdr & 0x1F) == GF_AVC_NALU_SEI && avc->s_info.nal_unit_type == GF_AVC_NALU_SVC_SLICE)
ret = 1;
else if ((nal_hdr & 0x1F) == GF_AVC_NALU_SEQ_PARAM && avc->s_info.nal_unit_type == GF_AVC_NALU_SVC_SLICE)
ret = 1;
else
ret = 0;
break;
}
if (ret && avc->s_info.sps) {
n_state.frame_num_offset_prev = avc->s_info.frame_num_offset;
if ((avc->s_info.sps->poc_type != 2) || (avc->s_info.nal_ref_idc != 0))
n_state.frame_num_prev = avc->s_info.frame_num;
if (avc->s_info.nal_ref_idc) {
n_state.poc_lsb_prev = avc->s_info.poc_lsb;
n_state.poc_msb_prev = avc->s_info.poc_msb;
}
}
if (slice)
avc_compute_poc(&n_state);
memcpy(&avc->s_info, &n_state, sizeof(AVCSliceInfo));
return ret;
}",[65],"A Segmentation fault caused by a null pointer dereference vulnerability exists in Gpac through 1.0.1 via the gf_avc_parse_nalu function in av_parsers.c when using mp4box, which causes a denial of service.",gpac,CVE-2021-40565,CWE-476
905,4747,"sec_recv(RD_BOOL * is_fastpath)
{
uint8 fastpath_hdr, fastpath_flags;
uint16 sec_flags;
uint16 channel;
STREAM s;
while ((s = mcs_recv(&channel, is_fastpath, &fastpath_hdr)) != NULL)
{
if (*is_fastpath == True)
{
fastpath_flags = (fastpath_hdr & 0xC0) >> 6;
if (fastpath_flags & FASTPATH_OUTPUT_ENCRYPTED)
{
in_uint8s(s, 8);
sec_decrypt(s->p, s->end - s->p);
}
return s;
}
if (g_encryption || (!g_licence_issued && !g_licence_error_result))
{
in_uint16_le(s, sec_flags);
in_uint8s(s, 2);
if (g_encryption)
{
if (sec_flags & SEC_ENCRYPT)
{
in_uint8s(s, 8);
sec_decrypt(s->p, s->end - s->p);
}
if (sec_flags & SEC_LICENSE_PKT)
{
licence_process(s);
continue;
}
if (sec_flags & SEC_REDIRECTION_PKT)
{
uint8 swapbyte;
in_uint8s(s, 8);
sec_decrypt(s->p, s->end - s->p);
if (s->p[0] == 0 && s->p[1] == 4)
{
swapbyte = s->p[0];
s->p[0] = s->p[2];
s->p[2] = swapbyte;
swapbyte = s->p[1];
s->p[1] = s->p[3];
s->p[3] = swapbyte;
swapbyte = s->p[2];
s->p[2] = s->p[3];
s->p[3] = swapbyte;
}
}
}
else
{
if (sec_flags & SEC_LICENSE_PKT)
{
licence_process(s);
continue;
}
s->p -= 4;
}
}
if (channel != MCS_GLOBAL_CHANNEL)
{
channel_process(s, channel);
continue;
}
return s;
}
return NULL;
}","[7, 9, 14, 27, 38]",rdesktop versions up to and including v1.8.3 contain an Out-Of-Bounds Read in the function ui_clip_handle_data() that results in an information leak.,rdesktop,CVE-2018-20174,CWE-125
907,9460,"xmlRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {
xmlIDTablePtr table;
xmlIDPtr id;
xmlChar *ID;
if (doc == NULL) return(-1);
if (attr == NULL) return(-1);
table = (xmlIDTablePtr) doc->ids;
if (table == NULL)
return(-1);
ID = xmlNodeListGetString(doc, attr->children, 1);
if (ID == NULL)
return(-1);
id = xmlHashLookup(table, ID);
if (id == NULL || id->attr != attr) {
xmlFree(ID);
return(-1);
}
xmlHashRemoveEntry(table, ID, xmlFreeIDTableEntry);
xmlFree(ID);
attr->atype = 0;
return(0);
}",[13],valid.c in libxml2 before 2.9.13 has a use-after-free of ID and IDREF attributes.,libxml2,CVE-2022-23308,CWE-416
911,7808,"static bool MR_primality_test(UnsignedBigInteger n, const Vector<UnsignedBigInteger, 256>& tests)
{
ASSERT(!(n < 4));
auto predecessor = n.minus({ 1 });
auto d = predecessor;
size_t r = 0;
{
auto div_result = d.divided_by(2);
while (div_result.remainder == 0) {
d = div_result.quotient;
div_result = d.divided_by(2);
++r;
}
}
if (r == 0) {
return n == 2;
}
for (auto a : tests) {
ASSERT(a < n);
auto x = ModularPower(a, d, n);
if (x == 1 || x == predecessor)
continue;
bool skip_this_witness = false;
for (size_t i = 0; i < r - 1; ++i) {
x = ModularPower(x, 2, n);
if (x == predecessor) {
skip_this_witness = true;
break;
}
}
if (skip_this_witness)
continue;
return false;
}
return true;
}",[18],SerenityOS Unspecified is affected by: Buffer Overflow. The impact is: obtain sensitive information (context-dependent). The component is: /Userland/Libraries/LibCrypto/ASN1/DER.h Crypto::der_decode_sequence() function. The attack vector is: Parsing RSA Key ASN.1.,serenity,CVE-2021-27343,CWE-120
924,6157,"PackLinuxElf64::elf_find_dynamic(unsigned int key) const
{
Elf64_Dyn const *dynp= dynseg;
if (dynp)
for (; (unsigned)((char const *)dynp - (char const *)dynseg) < sz_dynseg
&& Elf64_Dyn::DT_NULL!=dynp->d_tag; ++dynp) if (get_te64(&dynp->d_tag)==key) {
upx_uint64_t const t= elf_get_offset_from_address(get_te64(&dynp->d_val));
if (t) {
return &((unsigned char const *)file_image)[(size_t)t];
}
break;
}
return 0;
}","[8, 9]",p_lx_elf.cpp in UPX before 3.96 has an integer overflow during unpacking via crafted values in a PT_DYNAMIC segment.,upx,CVE-2019-20805,CWE-190
925,3650,"_forceinline void Unpack::CopyString(uint Length,uint Distance)
{
size_t SrcPtr=UnpPtr-Distance;
if (SrcPtr<MaxWinSize-MAX_LZ_MATCH && UnpPtr<MaxWinSize-MAX_LZ_MATCH)
{
byte *Src=Window+SrcPtr;
byte *Dest=Window+UnpPtr;
UnpPtr+=Length;
#ifdef FAST_MEMCPY
if (Distance<Length)
#endif
while (Length>=8)
{
Dest[0]=Src[0];
Dest[1]=Src[1];
Dest[2]=Src[2];
Dest[3]=Src[3];
Dest[4]=Src[4];
Dest[5]=Src[5];
Dest[6]=Src[6];
Dest[7]=Src[7];
Src+=8;
Dest+=8;
Length-=8;
}
#ifdef FAST_MEMCPY
else
while (Length>=8)
{
memcpy(Dest,Src,8);
Src+=8;
Dest+=8;
Length-=8;
}
#endif
if (Length>0) { Dest[0]=Src[0];
if (Length>1) { Dest[1]=Src[1];
if (Length>2) { Dest[2]=Src[2];
if (Length>3) { Dest[3]=Src[3];
if (Length>4) { Dest[4]=Src[4];
if (Length>5) { Dest[5]=Src[5];
if (Length>6) { Dest[6]=Src[6]; } } } } } } }
}
else
while (Length-- > 0)
{
Window[UnpPtr]=Window[SrcPtr++ & MaxWinMask];
UnpPtr=(UnpPtr+1) & MaxWinMask;
}
}",[4],UnRAR 5.6.1.2 and 5.6.1.3 has a heap-based buffer overflow in Unpack::CopyString (called from Unpack::Unpack5 and CmdExtract::ExtractCurrentFile).,unrar,CVE-2017-20006,CWE-787
933,7752,"PQconnectPoll(PGconn *conn)
{
bool  reset_connection_state_machine = false;
bool  need_new_connection = false;
PGresult   *res;
char  sebuf[PG_STRERROR_R_BUFLEN];
int   optval;
if (conn == NULL)
return PGRES_POLLING_FAILED;
switch (conn->status)
{
case CONNECTION_BAD:
return PGRES_POLLING_FAILED;
case CONNECTION_OK:
return PGRES_POLLING_OK;
case CONNECTION_AWAITING_RESPONSE:
case CONNECTION_AUTH_OK:
case CONNECTION_CHECK_WRITABLE:
case CONNECTION_CONSUME:
case CONNECTION_CHECK_STANDBY:
{
int   n = pqReadData(conn);
if (n < 0)
goto error_return;
if (n == 0)
return PGRES_POLLING_READING;
break;
}
case CONNECTION_STARTED:
case CONNECTION_MADE:
break;
case CONNECTION_SSL_STARTUP:
case CONNECTION_NEEDED:
case CONNECTION_GSS_STARTUP:
case CONNECTION_CHECK_TARGET:
break;
default:
appendPQExpBufferStr(&conn->errorMessage,
libpq_gettext(""invalid connection state, probably indicative of memory corruption\n""));
goto error_return;
}
keep_going:
if (conn->try_next_addr)
{
if (conn->addr_cur && conn->addr_cur->ai_next)
{
conn->addr_cur = conn->addr_cur->ai_next;
reset_connection_state_machine = true;
}
else
conn->try_next_host = true;
conn->try_next_addr = false;
}
if (conn->try_next_host)
{
pg_conn_host *ch;
struct addrinfo hint;
int   thisport;
int   ret;
char  portstr[MAXPGPATH];
if (conn->whichhost + 1 < conn->nconnhost)
conn->whichhost++;
else
{
if (conn->target_server_type == SERVER_TYPE_PREFER_STANDBY &&
conn->nconnhost > 0)
{
conn->target_server_type = SERVER_TYPE_PREFER_STANDBY_PASS2;
conn->whichhost = 0;
}
else
goto error_return;
}
release_conn_addrinfo(conn);
ch = &conn->connhost[conn->whichhost];
MemSet(&hint, 0, sizeof(hint));
hint.ai_socktype = SOCK_STREAM;
conn->addrlist_family = hint.ai_family = AF_UNSPEC;
if (ch->port == NULL || ch->port[0] == '\0')
thisport = DEF_PGPORT;
else
{
if (!parse_int_param(ch->port, &thisport, conn, ""port""))
goto error_return;
if (thisport < 1 || thisport > 65535)
{
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""invalid port number: \""%s\""\n""),
ch->port);
goto keep_going;
}
}
snprintf(portstr, sizeof(portstr), ""%d"", thisport);
switch (ch->type)
{
case CHT_HOST_NAME:
ret = pg_getaddrinfo_all(ch->host, portstr, &hint,
&conn->addrlist);
if (ret || !conn->addrlist)
{
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""could not translate host name \""%s\"" to address: %s\n""),
ch->host, gai_strerror(ret));
goto keep_going;
}
break;
case CHT_HOST_ADDRESS:
hint.ai_flags = AI_NUMERICHOST;
ret = pg_getaddrinfo_all(ch->hostaddr, portstr, &hint,
&conn->addrlist);
if (ret || !conn->addrlist)
{
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""could not parse network address \""%s\"": %s\n""),
ch->hostaddr, gai_strerror(ret));
goto keep_going;
}
break;
case CHT_UNIX_SOCKET:
#ifdef HAVE_UNIX_SOCKETS
conn->addrlist_family = hint.ai_family = AF_UNIX;
UNIXSOCK_PATH(portstr, thisport, ch->host);
if (strlen(portstr) >= UNIXSOCK_PATH_BUFLEN)
{
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""Unix-domain socket path \""%s\"" is too long (maximum %d bytes)\n""),
portstr,
(int) (UNIXSOCK_PATH_BUFLEN - 1));
goto keep_going;
}
ret = pg_getaddrinfo_all(NULL, portstr, &hint,
&conn->addrlist);
if (ret || !conn->addrlist)
{
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""could not translate Unix-domain socket path \""%s\"" to address: %s\n""),
portstr, gai_strerror(ret));
goto keep_going;
}
#else
Assert(false);
#endif
break;
}
conn->addr_cur = conn->addrlist;
reset_connection_state_machine = true;
conn->try_next_host = false;
}
if (reset_connection_state_machine)
{
conn->pversion = PG_PROTOCOL(3, 0);
conn->send_appname = true;
#ifdef USE_SSL
conn->allow_ssl_try = (conn->sslmode[0] != 'd');
conn->wait_ssl_try = (conn->sslmode[0] == 'a');
#endif
#ifdef ENABLE_GSS
conn->try_gss = (conn->gssencmode[0] != 'd');
#endif
reset_connection_state_machine = false;
need_new_connection = true;
}
if (need_new_connection)
{
pqDropConnection(conn, true);
pqDropServerData(conn);
conn->asyncStatus = PGASYNC_IDLE;
conn->xactStatus = PQTRANS_IDLE;
conn->pipelineStatus = PQ_PIPELINE_OFF;
pqClearAsyncResult(conn);
conn->status = CONNECTION_NEEDED;
need_new_connection = false;
}
switch (conn->status)
{
case CONNECTION_NEEDED:
{
{
struct addrinfo *addr_cur = conn->addr_cur;
char  host_addr[NI_MAXHOST];
if (addr_cur == NULL)
{
conn->try_next_host = true;
goto keep_going;
}
memcpy(&conn->raddr.addr, addr_cur->ai_addr,
addr_cur->ai_addrlen);
conn->raddr.salen = addr_cur->ai_addrlen;
if (conn->connip != NULL)
{
free(conn->connip);
conn->connip = NULL;
}
getHostaddr(conn, host_addr, NI_MAXHOST);
if (host_addr[0])
conn->connip = strdup(host_addr);
conn->sock = socket(addr_cur->ai_family, SOCK_STREAM, 0);
if (conn->sock == PGINVALID_SOCKET)
{
int   errorno = SOCK_ERRNO;
if (addr_cur->ai_next != NULL ||
conn->whichhost + 1 < conn->nconnhost)
{
conn->try_next_addr = true;
goto keep_going;
}
emitHostIdentityInfo(conn, host_addr);
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""could not create socket: %s\n""),
SOCK_STRERROR(errorno, sebuf, sizeof(sebuf)));
goto error_return;
}
emitHostIdentityInfo(conn, host_addr);
if (!IS_AF_UNIX(addr_cur->ai_family))
{
if (!connectNoDelay(conn))
{
conn->try_next_addr = true;
goto keep_going;
}
}
if (!pg_set_noblock(conn->sock))
{
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""could not set socket to nonblocking mode: %s\n""),
SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));
conn->try_next_addr = true;
goto keep_going;
}
#ifdef F_SETFD
if (fcntl(conn->sock, F_SETFD, FD_CLOEXEC) == -1)
{
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""could not set socket to close-on-exec mode: %s\n""),
SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));
conn->try_next_addr = true;
goto keep_going;
}
#endif							/* F_SETFD */
if (!IS_AF_UNIX(addr_cur->ai_family))
{
#ifndef WIN32
int   on = 1;
#endif
int   usekeepalives = useKeepalives(conn);
int   err = 0;
if (usekeepalives < 0)
{
appendPQExpBufferStr(&conn->errorMessage,
libpq_gettext(""keepalives parameter must be an integer\n""));
err = 1;
}
else if (usekeepalives == 0)
{
}
#ifndef WIN32
else if (setsockopt(conn->sock,
SOL_SOCKET, SO_KEEPALIVE,
(char *) &on, sizeof(on)) < 0)
{
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""%s(%s) failed: %s\n""),
""setsockopt"",
""SO_KEEPALIVE"",
SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));
err = 1;
}
else if (!setKeepalivesIdle(conn)
|| !setKeepalivesInterval(conn)
|| !setKeepalivesCount(conn))
err = 1;
#else							/* WIN32 */
#ifdef SIO_KEEPALIVE_VALS
else if (!setKeepalivesWin32(conn))
err = 1;
#endif							/* SIO_KEEPALIVE_VALS */
#endif							/* WIN32 */
else if (!setTCPUserTimeout(conn))
err = 1;
if (err)
{
conn->try_next_addr = true;
goto keep_going;
}
}
conn->sigpipe_so = false;
#ifdef MSG_NOSIGNAL
conn->sigpipe_flag = true;
#else
conn->sigpipe_flag = false;
#endif							/* MSG_NOSIGNAL */
#ifdef SO_NOSIGPIPE
optval = 1;
if (setsockopt(conn->sock, SOL_SOCKET, SO_NOSIGPIPE,
(char *) &optval, sizeof(optval)) == 0)
{
conn->sigpipe_so = true;
conn->sigpipe_flag = false;
}
#endif							/* SO_NOSIGPIPE */
if (connect(conn->sock, addr_cur->ai_addr,
addr_cur->ai_addrlen) < 0)
{
if (SOCK_ERRNO == EINPROGRESS ||
#ifdef WIN32
SOCK_ERRNO == EWOULDBLOCK ||
#endif
SOCK_ERRNO == EINTR)
{
conn->status = CONNECTION_STARTED;
return PGRES_POLLING_WRITING;
}
}
else
{
conn->status = CONNECTION_STARTED;
goto keep_going;
}
connectFailureMessage(conn, SOCK_ERRNO);
conn->try_next_addr = true;
goto keep_going;
}
}
case CONNECTION_STARTED:
{
ACCEPT_TYPE_ARG3 optlen = sizeof(optval);
if (getsockopt(conn->sock, SOL_SOCKET, SO_ERROR,
(char *) &optval, &optlen) == -1)
{
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""could not get socket error status: %s\n""),
SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));
goto error_return;
}
else if (optval != 0)
{
connectFailureMessage(conn, optval);
conn->try_next_addr = true;
goto keep_going;
}
conn->laddr.salen = sizeof(conn->laddr.addr);
if (getsockname(conn->sock,
(struct sockaddr *) &conn->laddr.addr,
&conn->laddr.salen) < 0)
{
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""could not get client address from socket: %s\n""),
SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));
goto error_return;
}
conn->status = CONNECTION_MADE;
return PGRES_POLLING_WRITING;
}
case CONNECTION_MADE:
{
char    *startpacket;
int   packetlen;
if (conn->requirepeer && conn->requirepeer[0] &&
IS_AF_UNIX(conn->raddr.addr.ss_family))
{
#ifndef WIN32
char  pwdbuf[BUFSIZ];
struct passwd pass_buf;
struct passwd *pass;
int   passerr;
#endif
uid_t  uid;
gid_t  gid;
errno = 0;
if (getpeereid(conn->sock, &uid, &gid) != 0)
{
if (errno == ENOSYS)
appendPQExpBufferStr(&conn->errorMessage,
libpq_gettext(""requirepeer parameter is not supported on this platform\n""));
else
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""could not get peer credentials: %s\n""),
strerror_r(errno, sebuf, sizeof(sebuf)));
goto error_return;
}
#ifndef WIN32
passerr = pqGetpwuid(uid, &pass_buf, pwdbuf, sizeof(pwdbuf), &pass);
if (pass == NULL)
{
if (passerr != 0)
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""could not look up local user ID %d: %s\n""),
(int) uid,
strerror_r(passerr, sebuf, sizeof(sebuf)));
else
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""local user with ID %d does not exist\n""),
(int) uid);
goto error_return;
}
if (strcmp(pass->pw_name, conn->requirepeer) != 0)
{
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""requirepeer specifies \""%s\"", but actual peer user name is \""%s\""\n""),
conn->requirepeer, pass->pw_name);
goto error_return;
}
#else							/* WIN32 */
Assert(false);
#endif							/* WIN32 */
}
if (IS_AF_UNIX(conn->raddr.addr.ss_family))
{
#ifdef USE_SSL
conn->allow_ssl_try = false;
#endif
#ifdef ENABLE_GSS
conn->try_gss = false;
#endif
}
#ifdef ENABLE_GSS
if (conn->try_gss && !conn->gctx)
conn->try_gss = pg_GSS_have_cred_cache(&conn->gcred);
if (conn->try_gss && !conn->gctx)
{
ProtocolVersion pv = pg_hton32(NEGOTIATE_GSS_CODE);
if (pqPacketSend(conn, 0, &pv, sizeof(pv)) != STATUS_OK)
{
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""could not send GSSAPI negotiation packet: %s\n""),
SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));
goto error_return;
}
conn->status = CONNECTION_GSS_STARTUP;
return PGRES_POLLING_READING;
}
else if (!conn->gctx && conn->gssencmode[0] == 'r')
{
appendPQExpBufferStr(&conn->errorMessage,
libpq_gettext(""GSSAPI encryption required but was impossible (possibly no credential cache, no server support, or using a local socket)\n""));
goto error_return;
}
#endif
#ifdef USE_SSL
if (pqsecure_initialize(conn, false, true) < 0)
goto error_return;
if (conn->allow_ssl_try && !conn->wait_ssl_try &&
!conn->ssl_in_use
#ifdef ENABLE_GSS
&& !conn->gssenc
#endif
)
{
ProtocolVersion pv;
pv = pg_hton32(NEGOTIATE_SSL_CODE);
if (pqPacketSend(conn, 0, &pv, sizeof(pv)) != STATUS_OK)
{
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""could not send SSL negotiation packet: %s\n""),
SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));
goto error_return;
}
conn->status = CONNECTION_SSL_STARTUP;
return PGRES_POLLING_READING;
}
#endif							/* USE_SSL */
startpacket = pqBuildStartupPacket3(conn, &packetlen,
EnvironmentOptions);
if (!startpacket)
{
appendPQExpBufferStr(&conn->errorMessage,
libpq_gettext(""out of memory\n""));
goto error_return;
}
if (pqPacketSend(conn, 0, startpacket, packetlen) != STATUS_OK)
{
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""could not send startup packet: %s\n""),
SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));
free(startpacket);
goto error_return;
}
free(startpacket);
conn->status = CONNECTION_AWAITING_RESPONSE;
return PGRES_POLLING_READING;
}
case CONNECTION_SSL_STARTUP:
{
#ifdef USE_SSL
PostgresPollingStatusType pollres;
if (!conn->ssl_in_use)
{
char  SSLok;
int   rdresult;
rdresult = pqReadData(conn);
if (rdresult < 0)
{
goto error_return;
}
if (rdresult == 0)
{
return PGRES_POLLING_READING;
}
if (pqGetc(&SSLok, conn) < 0)
{
return PGRES_POLLING_READING;
}
if (SSLok == 'S')
{
conn->inStart = conn->inCursor;
if (pqsecure_initialize(conn, true, false) != 0)
goto error_return;
}
else if (SSLok == 'N')
{
conn->inStart = conn->inCursor;
if (conn->sslmode[0] == 'r' ||
conn->sslmode[0] == 'v')
{
appendPQExpBufferStr(&conn->errorMessage,
libpq_gettext(""server does not support SSL, but SSL was required\n""));
goto error_return;
}
conn->allow_ssl_try = false;
conn->status = CONNECTION_MADE;
return PGRES_POLLING_WRITING;
}
else if (SSLok == 'E')
{
conn->status = CONNECTION_AWAITING_RESPONSE;
goto keep_going;
}
else
{
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""received invalid response to SSL negotiation: %c\n""),
SSLok);
goto error_return;
}
}
pollres = pqsecure_open_client(conn);
if (pollres == PGRES_POLLING_OK)
{
conn->status = CONNECTION_MADE;
return PGRES_POLLING_WRITING;
}
if (pollres == PGRES_POLLING_FAILED)
{
if (conn->sslmode[0] == 'p'
&& conn->allow_ssl_try
&& !conn->wait_ssl_try)
{
conn->allow_ssl_try = false;
need_new_connection = true;
goto keep_going;
}
goto error_return;
}
return pollres;
#else							/* !USE_SSL */
goto error_return;
#endif							/* USE_SSL */
}
case CONNECTION_GSS_STARTUP:
{
#ifdef ENABLE_GSS
PostgresPollingStatusType pollres;
if (conn->try_gss && !conn->gctx)
{
char  gss_ok;
int   rdresult = pqReadData(conn);
if (rdresult < 0)
goto error_return;
else if (rdresult == 0)
return PGRES_POLLING_READING;
if (pqGetc(&gss_ok, conn) < 0)
return PGRES_POLLING_READING;
if (gss_ok == 'E')
{
conn->try_gss = false;
need_new_connection = true;
goto keep_going;
}
conn->inStart = conn->inCursor;
if (gss_ok == 'N')
{
if (conn->gssencmode[0] == 'r')
{
appendPQExpBufferStr(&conn->errorMessage,
libpq_gettext(""server doesn't support GSSAPI encryption, but it was required\n""));
goto error_return;
}
conn->try_gss = false;
conn->status = CONNECTION_MADE;
return PGRES_POLLING_WRITING;
}
else if (gss_ok != 'G')
{
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""received invalid response to GSSAPI negotiation: %c\n""),
gss_ok);
goto error_return;
}
}
pollres = pqsecure_open_gss(conn);
if (pollres == PGRES_POLLING_OK)
{
conn->status = CONNECTION_MADE;
return PGRES_POLLING_WRITING;
}
else if (pollres == PGRES_POLLING_FAILED &&
conn->gssencmode[0] == 'p')
{
conn->try_gss = false;
need_new_connection = true;
goto keep_going;
}
return pollres;
#else							/* !ENABLE_GSS */
goto error_return;
#endif							/* ENABLE_GSS */
}
case CONNECTION_AWAITING_RESPONSE:
{
char  beresp;
int   msgLength;
int   avail;
AuthRequest areq;
int   res;
conn->inCursor = conn->inStart;
if (pqGetc(&beresp, conn))
{
return PGRES_POLLING_READING;
}
if (!(beresp == 'R' || beresp == 'E'))
{
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""expected authentication request from server, but received %c\n""),
beresp);
goto error_return;
}
if (pqGetInt(&msgLength, 4, conn))
{
return PGRES_POLLING_READING;
}
if (beresp == 'R' && (msgLength < 8 || msgLength > 2000))
{
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""expected authentication request from server, but received %c\n""),
beresp);
goto error_return;
}
if (beresp == 'E' && (msgLength < 8 || msgLength > 30000))
{
conn->inCursor = conn->inStart + 1;
if (pqGets_append(&conn->errorMessage, conn))
{
return PGRES_POLLING_READING;
}
conn->inStart = conn->inCursor;
if (conn->errorMessage.len == 0 ||
conn->errorMessage.data[conn->errorMessage.len - 1] != '\n')
{
appendPQExpBufferChar(&conn->errorMessage, '\n');
}
goto error_return;
}
msgLength -= 4;
avail = conn->inEnd - conn->inCursor;
if (avail < msgLength)
{
if (pqCheckInBufferSpace(conn->inCursor + (size_t) msgLength,
conn))
goto error_return;
return PGRES_POLLING_READING;
}
if (beresp == 'E')
{
if (pqGetErrorNotice3(conn, true))
{
return PGRES_POLLING_READING;
}
conn->inStart = conn->inCursor;
if (strcmp(conn->last_sqlstate,
ERRCODE_CANNOT_CONNECT_NOW) == 0)
{
conn->try_next_host = true;
goto keep_going;
}
pgpassfileWarning(conn);
#ifdef ENABLE_GSS
if (conn->gssenc && conn->gssencmode[0] == 'p')
{
conn->try_gss = false;
need_new_connection = true;
goto keep_going;
}
#endif
#ifdef USE_SSL
if (conn->sslmode[0] == 'a'
&& !conn->ssl_in_use
&& conn->allow_ssl_try
&& conn->wait_ssl_try)
{
conn->wait_ssl_try = false;
need_new_connection = true;
goto keep_going;
}
if (conn->sslmode[0] == 'p'
&& conn->ssl_in_use
&& conn->allow_ssl_try
&& !conn->wait_ssl_try)
{
conn->allow_ssl_try = false;
need_new_connection = true;
goto keep_going;
}
#endif
goto error_return;
}
conn->auth_req_received = true;
if (pqGetInt((int *) &areq, 4, conn))
{
return PGRES_POLLING_READING;
}
msgLength -= 4;
res = pg_fe_sendauth(areq, msgLength, conn);
conn->inStart = conn->inCursor;
if (res != STATUS_OK)
goto error_return;
if (pqFlush(conn))
goto error_return;
if (areq == AUTH_REQ_OK)
{
conn->status = CONNECTION_AUTH_OK;
conn->asyncStatus = PGASYNC_BUSY;
}
goto keep_going;
}
case CONNECTION_AUTH_OK:
{
if (PQisBusy(conn))
return PGRES_POLLING_READING;
res = PQgetResult(conn);
if (res)
{
if (res->resultStatus != PGRES_FATAL_ERROR)
appendPQExpBufferStr(&conn->errorMessage,
libpq_gettext(""unexpected message from server during startup\n""));
else if (conn->send_appname &&
(conn->appname || conn->fbappname))
{
const char *sqlstate;
sqlstate = PQresultErrorField(res, PG_DIAG_SQLSTATE);
if (sqlstate &&
strcmp(sqlstate, ERRCODE_APPNAME_UNKNOWN) == 0)
{
PQclear(res);
conn->send_appname = false;
need_new_connection = true;
goto keep_going;
}
}
if (conn->errorMessage.len <= 0 ||
conn->errorMessage.data[conn->errorMessage.len - 1] != '\n')
appendPQExpBufferChar(&conn->errorMessage, '\n');
PQclear(res);
goto error_return;
}
conn->status = CONNECTION_CHECK_TARGET;
goto keep_going;
}
case CONNECTION_CHECK_TARGET:
{
if (conn->target_server_type == SERVER_TYPE_READ_WRITE ||
conn->target_server_type == SERVER_TYPE_READ_ONLY)
{
bool  read_only_server;
if (conn->default_transaction_read_only == PG_BOOL_UNKNOWN ||
conn->in_hot_standby == PG_BOOL_UNKNOWN)
{
conn->status = CONNECTION_OK;
if (!PQsendQueryContinue(conn,
""SHOW transaction_read_only""))
goto error_return;
conn->status = CONNECTION_CHECK_WRITABLE;
return PGRES_POLLING_READING;
}
read_only_server =
(conn->default_transaction_read_only == PG_BOOL_YES ||
conn->in_hot_standby == PG_BOOL_YES);
if ((conn->target_server_type == SERVER_TYPE_READ_WRITE) ?
read_only_server : !read_only_server)
{
if (conn->target_server_type == SERVER_TYPE_READ_WRITE)
appendPQExpBufferStr(&conn->errorMessage,
libpq_gettext(""session is read-only\n""));
else
appendPQExpBufferStr(&conn->errorMessage,
libpq_gettext(""session is not read-only\n""));
conn->status = CONNECTION_OK;
sendTerminateConn(conn);
conn->try_next_host = true;
goto keep_going;
}
}
else if (conn->target_server_type == SERVER_TYPE_PRIMARY ||
conn->target_server_type == SERVER_TYPE_STANDBY ||
conn->target_server_type == SERVER_TYPE_PREFER_STANDBY)
{
if (conn->sversion < 90000)
conn->in_hot_standby = PG_BOOL_NO;
if (conn->in_hot_standby == PG_BOOL_UNKNOWN)
{
conn->status = CONNECTION_OK;
if (!PQsendQueryContinue(conn,
""SELECT pg_catalog.pg_is_in_recovery()""))
goto error_return;
conn->status = CONNECTION_CHECK_STANDBY;
return PGRES_POLLING_READING;
}
if ((conn->target_server_type == SERVER_TYPE_PRIMARY) ?
(conn->in_hot_standby == PG_BOOL_YES) :
(conn->in_hot_standby == PG_BOOL_NO))
{
if (conn->target_server_type == SERVER_TYPE_PRIMARY)
appendPQExpBufferStr(&conn->errorMessage,
libpq_gettext(""server is in hot standby mode\n""));
else
appendPQExpBufferStr(&conn->errorMessage,
libpq_gettext(""server is not in hot standby mode\n""));
conn->status = CONNECTION_OK;
sendTerminateConn(conn);
conn->try_next_host = true;
goto keep_going;
}
}
release_conn_addrinfo(conn);
resetPQExpBuffer(&conn->errorMessage);
conn->status = CONNECTION_OK;
return PGRES_POLLING_OK;
}
case CONNECTION_CONSUME:
{
conn->status = CONNECTION_OK;
if (!PQconsumeInput(conn))
goto error_return;
if (PQisBusy(conn))
{
conn->status = CONNECTION_CONSUME;
return PGRES_POLLING_READING;
}
res = PQgetResult(conn);
if (res != NULL)
{
PQclear(res);
conn->status = CONNECTION_CONSUME;
return PGRES_POLLING_READING;
}
conn->status = CONNECTION_CHECK_TARGET;
goto keep_going;
}
case CONNECTION_CHECK_WRITABLE:
{
conn->status = CONNECTION_OK;
if (!PQconsumeInput(conn))
goto error_return;
if (PQisBusy(conn))
{
conn->status = CONNECTION_CHECK_WRITABLE;
return PGRES_POLLING_READING;
}
res = PQgetResult(conn);
if (res && PQresultStatus(res) == PGRES_TUPLES_OK &&
PQntuples(res) == 1)
{
char    *val = PQgetvalue(res, 0, 0);
if (strncmp(val, ""on"", 2) == 0)
{
conn->default_transaction_read_only = PG_BOOL_YES;
conn->in_hot_standby = PG_BOOL_YES;
}
else
{
conn->default_transaction_read_only = PG_BOOL_NO;
conn->in_hot_standby = PG_BOOL_NO;
}
PQclear(res);
conn->status = CONNECTION_CONSUME;
goto keep_going;
}
if (res)
PQclear(res);
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""\""%s\"" failed\n""),
""SHOW transaction_read_only"");
conn->status = CONNECTION_OK;
sendTerminateConn(conn);
conn->try_next_host = true;
goto keep_going;
}
case CONNECTION_CHECK_STANDBY:
{
conn->status = CONNECTION_OK;
if (!PQconsumeInput(conn))
goto error_return;
if (PQisBusy(conn))
{
conn->status = CONNECTION_CHECK_STANDBY;
return PGRES_POLLING_READING;
}
res = PQgetResult(conn);
if (res && PQresultStatus(res) == PGRES_TUPLES_OK &&
PQntuples(res) == 1)
{
char    *val = PQgetvalue(res, 0, 0);
if (strncmp(val, ""t"", 1) == 0)
conn->in_hot_standby = PG_BOOL_YES;
else
conn->in_hot_standby = PG_BOOL_NO;
PQclear(res);
conn->status = CONNECTION_CONSUME;
goto keep_going;
}
if (res)
PQclear(res);
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""\""%s\"" failed\n""),
""SELECT pg_is_in_recovery()"");
conn->status = CONNECTION_OK;
sendTerminateConn(conn);
conn->try_next_host = true;
goto keep_going;
}
default:
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""invalid connection state %d, ""
""probably indicative of memory corruption\n""),
conn->status);
goto error_return;
}
error_return:
conn->status = CONNECTION_BAD;
return PGRES_POLLING_FAILED;
}","[539, 603]","A man-in-the-middle attacker can inject false responses to the client's first few queries, despite the use of SSL certificate verification and encryption.",postgres,CVE-2021-23222,CWE-522
934,6321,"void pointZZ_pAdd(PointZZ_p * rop, const PointZZ_p * op1, const PointZZ_p * op2, const CurveZZ_p * curve) {
mpz_t xdiff, ydiff, lambda;
mpz_inits(xdiff, ydiff, lambda, NULL);
mpz_sub(ydiff, op2->y, op1->y);
mpz_sub(xdiff, op2->x, op1->x);
mpz_invert(xdiff, xdiff, curve->p);
mpz_mul(lambda, ydiff, xdiff);
mpz_mod(lambda, lambda, curve->p);
mpz_mul(rop->x, lambda, lambda);
mpz_sub(rop->x, rop->x, op1->x);
mpz_sub(rop->x, rop->x, op2->x);
mpz_mod(rop->x, rop->x, curve->p);
mpz_sub(rop->y, op1->x, rop->x);
mpz_mul(rop->y, lambda, rop->y);
mpz_sub(rop->y, rop->y, op1->y);
mpz_mod(rop->y, rop->y, curve->p);
mpz_clears(xdiff, ydiff, lambda, NULL);
}",[17],"An issue was discovered in fastecdsa before 2.1.2. When using the NIST P-256 curve in the ECDSA implementation, the point at infinity is mishandled. This means that for an extreme value in k and s^-1, the signature verification fails even if the signature is correct. This behavior is not solely a usability problem. There are some threat models where an attacker can benefit by successfully guessing users for whom signature verification will fail.",fastecdsa,CVE-2020-12607,CWE-347
936,9603,"void jsvAddName(JsVar *parent, JsVar *namedChild) {
namedChild = jsvRef(namedChild);
assert(jsvIsName(namedChild));
if (jsvIsArray(parent) && jsvIsInt(namedChild)) {
JsVarInt index = namedChild->varData.integer;
if (index >= jsvGetArrayLength(parent)) {
jsvSetArrayLength(parent, index + 1, false);
}
}
if (jsvGetLastChild(parent)) {
JsVar *insertAfter = jsvLock(jsvGetLastChild(parent));
if (jsvIsArray(parent)) {
while (insertAfter && jsvCompareInteger(namedChild, insertAfter)<0) {
JsVarRef prev = jsvGetPrevSibling(insertAfter);
jsvUnLock(insertAfter);
insertAfter = jsvLockSafe(prev);
}
}
if (insertAfter) {
if (jsvGetNextSibling(insertAfter)) {
JsVar *insertBefore = jsvLock(jsvGetNextSibling(insertAfter));
jsvSetPrevSibling(insertBefore, jsvGetRef(namedChild));
jsvSetNextSibling(namedChild, jsvGetRef(insertBefore));
jsvUnLock(insertBefore);
} else {
jsvSetLastChild(parent, jsvGetRef(namedChild));
}
jsvSetNextSibling(insertAfter, jsvGetRef(namedChild));
jsvSetPrevSibling(namedChild, jsvGetRef(insertAfter));
jsvUnLock(insertAfter);
} else {
JsVar *firstChild = jsvLock(jsvGetFirstChild(parent));
jsvSetPrevSibling(firstChild, jsvGetRef(namedChild));
jsvUnLock(firstChild);
jsvSetNextSibling(namedChild, jsvGetFirstChild(parent));
jsvSetFirstChild(parent, jsvGetRef(namedChild));
}
} else {
JsVarRef r = jsvGetRef(namedChild);
jsvSetFirstChild(parent, r);
jsvSetLastChild(parent, r);
}
}",[20],Espruino 2v11.251 was discovered to contain a stack buffer overflow via src/jsvar.c in jsvNewFromString.,Espruino,CVE-2022-25044,CWE-787
937,8003,"GF_Err abst_box_read(GF_Box *s, GF_BitStream *bs)
{
GF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;
int i;
u32 tmp_strsize;
char *tmp_str;
GF_Err e;
ISOM_DECREASE_SIZE(ptr, 25)
ptr->bootstrapinfo_version = gf_bs_read_u32(bs);
ptr->profile = gf_bs_read_int(bs, 2);
ptr->live = gf_bs_read_int(bs, 1);
ptr->update = gf_bs_read_int(bs, 1);
ptr->reserved = gf_bs_read_int(bs, 4);
ptr->time_scale = gf_bs_read_u32(bs);
ptr->current_media_time = gf_bs_read_u64(bs);
ptr->smpte_time_code_offset = gf_bs_read_u64(bs);
i=0;
if (ptr->size<8) return GF_ISOM_INVALID_FILE;
tmp_strsize =(u32)ptr->size;
tmp_str = gf_malloc(sizeof(char)*tmp_strsize);
if (!tmp_str) return GF_OUT_OF_MEM;
memset(tmp_str, 0, sizeof(char)*tmp_strsize);
while (tmp_strsize) {
ISOM_DECREASE_SIZE(ptr, 1)
tmp_str[i] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[i])
break;
i++;
}
if (i) {
ptr->movie_identifier = gf_strdup(tmp_str);
}
ISOM_DECREASE_SIZE(ptr, 1)
ptr->server_entry_count = gf_bs_read_u8(bs);
for (i=0; i<ptr->server_entry_count; i++) {
int j=0;
tmp_strsize=(u32)ptr->size;
while (tmp_strsize) {
ISOM_DECREASE_SIZE(ptr, 1)
tmp_str[j] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[j])
break;
j++;
}
if (j) {
gf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);
}
}
ISOM_DECREASE_SIZE(ptr, 1)
ptr->quality_entry_count = gf_bs_read_u8(bs);
for (i=0; i<ptr->quality_entry_count; i++) {
int j=0;
tmp_strsize=(u32)ptr->size;
while (tmp_strsize) {
ISOM_DECREASE_SIZE(ptr, 1)
tmp_str[j] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[j])
break;
j++;
}
if (j) {
gf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);
}
}
i=0;
tmp_strsize=(u32)ptr->size;
while (tmp_strsize) {
ISOM_DECREASE_SIZE(ptr, 1)
tmp_str[i] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[i])
break;
i++;
}
if (i) {
ptr->drm_data = gf_strdup(tmp_str);
}
i=0;
tmp_strsize=(u32)ptr->size;
while (tmp_strsize) {
ISOM_DECREASE_SIZE(ptr, 1)
tmp_str[i] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[i])
break;
i++;
}
if (i) {
ptr->meta_data = gf_strdup(tmp_str);
}
ISOM_DECREASE_SIZE(ptr, 1)
ptr->segment_run_table_count = gf_bs_read_u8(bs);
for (i=0; i<ptr->segment_run_table_count; i++) {
GF_AdobeSegmentRunTableBox *asrt = NULL;
e = gf_isom_box_parse((GF_Box **)&asrt, bs);
if (e) {
if (asrt) gf_isom_box_del((GF_Box*)asrt);
gf_free(tmp_str);
return e;
}
gf_list_add(ptr->segment_run_table_entries, asrt);
}
ISOM_DECREASE_SIZE(ptr, 1)
ptr->fragment_run_table_count = gf_bs_read_u8(bs);
for (i=0; i<ptr->fragment_run_table_count; i++) {
GF_AdobeFragmentRunTableBox *afrt = NULL;
e = gf_isom_box_parse((GF_Box **)&afrt, bs);
if (e) {
if (afrt) gf_isom_box_del((GF_Box*)afrt);
gf_free(tmp_str);
return e;
}
gf_list_add(ptr->fragment_run_table_entries, afrt);
}
gf_free(tmp_str);
return GF_OK;
}","[7, 27, 29, 31, 38, 43, 45, 47, 55, 60, 62, 64, 70, 74, 76, 78, 83, 87, 89, 91]",Buffer overflow in the abst_box_read function in MP4Box in GPAC 1.0.1 allows attackers to cause a denial of service or execute arbitrary code via a crafted file.,gpac,CVE-2021-31255,CWE-120
951,8480,"u32 gf_bs_read_ue_log_idx3(GF_BitStream *bs, const char *fname, s32 idx1, s32 idx2, s32 idx3)
{
u32 val=0, code;
s32 nb_lead = -1;
u32 bits = 0;
for (code=0; !code; nb_lead++) {
if (nb_lead>=32) {
if (!gf_bs_available(bs)) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[Core] exp-golomb read failed, not enough bits in bitstream !\n""));
} else {
GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[Core] corrupted exp-golomb code, %d leading zeros, max 31 allowed !\n"", nb_lead));
}
return 0;
}
code = gf_bs_read_int(bs, 1);
bits++;
}
if (nb_lead) {
val = gf_bs_read_int(bs, nb_lead);
val += (1 << nb_lead) - 1;
bits += nb_lead;
}
if (fname) {
gf_bs_log_idx(bs, bits, fname, val, idx1, idx2, idx3);
}
return val;
}","[19, 20]","A Segmentation fault caused by null pointer dereference vulnerability eists in Gpac through 1.0.2 via the avc_parse_slice function in av_parsers.c when using mp4box, which causes a denial of service.",gpac,CVE-2021-40564,CWE-476
955,8046,"static char *parse_note(char *p,
int flags)
{
struct SYMBOL *s;
char *q;
int pit = 0, len, acc, nostem, chord, j, m, n;
if (flags & ABC_F_GRACE) {
s = abc_new(ABC_T_NOTE, NULL);
} else {
s = abc_new(ABC_T_NOTE, gchord);
if (gchord)
gchord = NULL;
}
s->flags |= flags;
s->u.note.notes[0].color = -1;
if (!lyric_started) {
lyric_started = 1;
s->flags |= ABC_F_LYRIC_START;
}
if (*p != 'X' && *p != 'Z'
&& !(flags & ABC_F_GRACE)) {
if (!deco_start)
deco_start = s;
}
chord = 0;
switch (*p) {
case 'X':
s->flags |= ABC_F_INVIS;
case 'Z':
s->abc_type = ABC_T_MREST;
p++;
len = 1;
if (isdigit((unsigned char) *p)) {
len = strtol(p, &q, 10);
if (len == 0 || len > 100) {
syntax(""Bad number of measures"", p);
len = 1;
}
p = q;
}
s->u.bar.type = 0;
s->u.bar.len = len;
goto add_deco;
case 'y':
s->abc_type = ABC_T_REST;
s->flags |= ABC_F_INVIS;
p++;
if (isdigit((unsigned char) *p)
|| *p == '-') {
s->u.note.notes[0].shhd = strtol(p, &q, 10);
p = q;
} else {
s->u.note.notes[0].shhd = 10;
}
goto add_deco;
case 'x':
s->flags |= ABC_F_INVIS;
case 'z':
s->abc_type = ABC_T_REST;
p = parse_len(p + 1, ulen, &len);
s->u.note.notes[0].len = len;
goto do_brhythm;
case '[':
chord = 1;
p++;
break;
}
q = p;
m = 0;
nostem = 0;
for (;;) {
if (chord) {
if (m >= MAXHD) {
syntax(""Too many notes in chord"", p);
m--;
}
n = 0;
if (*p == '.') {
n = SL_DOTTED;
p++;
}
if (*p == '(') {
p++;
switch (*p) {
case '\'':
n += SL_ABOVE;
p++;
break;
case ',':
n += SL_BELOW;
p++;
break;
default:
n += SL_AUTO;
break;
}
s->u.note.notes[m].sl1 = (s->u.note.notes[m].sl1 << 3)
+ n;
}
}
p = parse_deco(p, &dc, m);
p = parse_acc_pit(p, &pit, &acc);
if (*p == '0') {
nostem = 1;
p++;
}
p = parse_len(p, (flags & ABC_F_GRACE) ?
BASE_LEN / 8 :
ulen,
&len);
s->u.note.notes[m].pit = pit;
s->pits[m] = pit;
s->u.note.notes[m].len = len;
s->u.note.notes[m].acc = acc;
s->u.note.notes[m].color = -1;
if (chord) {
for (;;) {
if (*p == '.') {
if (p[1] != '-')
break;
p++;
}
if (*p == '-') {
switch (p[1]) {
case '\'':
s->u.note.notes[m].ti1 = SL_ABOVE;
p++;
break;
case ',':
s->u.note.notes[m].ti1 = SL_BELOW;
p++;
break;
default:
s->u.note.notes[m].ti1 = SL_AUTO;
break;
}
} else if (*p == ')') {
s->u.note.notes[m].sl2++;
} else {
break;
}
p++;
}
}
if (acc >= 0)
m++;
if (!chord)
break;
if (*p == ']') {
p++;
if (*p == '0') {
nostem = 1;
p++;
}
if (*p == '/' || isdigit((unsigned char) *p)) {
p = parse_len(p, ulen, &len);
for (j = 0; j < m; j++) {
s->u.note.notes[j].len =
len * s->u.note.notes[j].len / ulen;
}
}
break;
}
if (*p == '\0') {
syntax(""Chord not closed"", q);
break;
}
}
if (nostem)
s->flags |= ABC_F_STEMLESS;
if (m == 0)
goto err;
s->u.note.microscale = microscale;
s->nhd = m - 1;
do_brhythm:
if (curvoice->last_note
&& curvoice->last_note->u.note.brhythm != 0)
broken_rhythm(s, -curvoice->last_note->u.note.brhythm);
add_deco:
if (dc.n > 0) {
memcpy(s->abc_type != ABC_T_MREST ? &s->u.note.dc
: &s->u.bar.dc,
&dc, sizeof dc);
dc.n = 0;
}
if (s->abc_type != ABC_T_NOTE && (flags & ABC_F_GRACE)) {
syntax(""Not a note in grace note sequence"", p);
goto err;
}
return p;
err:
if ((parse.last_sym = s->abc_prev) == NULL) {
parse.first_sym = NULL;
} else {
s->abc_prev->abc_next = NULL;
s->abc_prev->flags |= (s->flags & ABC_F_ERROR);
}
return p;
}",[190],Stack-based buffer overflow in the function get_key in parse.c of abcm2ps v8.14.11 allows remote attackers to cause a Denial of Service (DoS) via unspecified vectors.,abcm2ps,CVE-2021-32435,CWE-787
959,8677,"static int insert_pin(
sc_pkcs15_card_t *p15card,
const char       *path,
unsigned char     id,
unsigned char     auth_id,
unsigned char     pin_reference,
int               min_length,
const char       *label,
int               pin_flags
){
sc_card_t *card=p15card->card;
sc_context_t *ctx=p15card->card->ctx;
sc_file_t *f = NULL;
struct sc_pkcs15_auth_info pin_info;
struct sc_pkcs15_object pin_obj;
int r;
memset(&pin_info, 0, sizeof(pin_info));
pin_info.auth_id.len      = 1;
pin_info.auth_id.value[0] = id;
pin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;
pin_info.attrs.pin.reference        = pin_reference;
pin_info.attrs.pin.flags            = pin_flags;
pin_info.attrs.pin.type             = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;
pin_info.attrs.pin.min_length       = min_length;
pin_info.attrs.pin.stored_length    = 16;
pin_info.attrs.pin.max_length       = 16;
pin_info.attrs.pin.pad_char         = '\0';
pin_info.logged_in = SC_PIN_STATE_UNKNOWN;
sc_format_path(path, &pin_info.path);
memset(&pin_obj, 0, sizeof(pin_obj));
strlcpy(pin_obj.label, label, sizeof(pin_obj.label));
pin_obj.flags            = SC_PKCS15_CO_FLAG_MODIFIABLE | SC_PKCS15_CO_FLAG_PRIVATE;
pin_obj.auth_id.len      = auth_id ? 0 : 1;
pin_obj.auth_id.value[0] = auth_id;
if(card->type == SC_CARD_TYPE_TCOS_V3) {
unsigned char buf[256];
int i, rec_no=0;
if (pin_info.path.len >= 2) {
pin_info.path.len -= 2;
}
sc_append_file_id(&pin_info.path, 0x5049);
if (sc_select_file(card, &pin_info.path, NULL) != SC_SUCCESS) {
sc_log(ctx,
""Select(%s) failed\n"",
sc_print_path(&pin_info.path));
return 1;
}
sc_log(ctx,
""Searching for PIN-Ref %02X\n"", pin_reference);
while ((r = sc_read_record(card, ++rec_no, buf, sizeof(buf), SC_RECORD_BY_REC_NR)) > 0) {
int found = 0, fbz = -1;
if (buf[0] != 0xA0)
continue;
for (i = 2; i < buf[1] + 2; i += 2 + buf[i + 1]) {
if (buf[i] == 0x83 && buf[i + 1] == 1 && buf[i + 2] == pin_reference) {
++found;
}
if (buf[i] == 0x90) {
fbz = buf[i + 1 + buf[i + 1]];
}
}
if (found) {
pin_info.tries_left = fbz;
break;
}
}
if (r <= 0) {
sc_log(ctx, ""No EF_PWDD-Record found\n"");
return 1;
}
} else {
if (sc_select_file(card, &pin_info.path, &f) != SC_SUCCESS
|| !f->prop_attr || f->prop_attr_len < 4){
sc_log(ctx, ""Select(%s) failed\n"", path);
sc_file_free(f);
return 1;
}
pin_info.tries_left = f->prop_attr[3];
sc_file_free(f);
}
r=sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);
if(r!=SC_SUCCESS){
sc_log(ctx,  ""sc_pkcs15emu_add_pin_obj(%s) failed\n"", path);
return 4;
}
sc_log(ctx,  ""%s: OK, FBZ=%d\n"", path, pin_info.tries_left);
return 0;
}","[52, 54, 58]",A use after return issue was found in Opensc before version 0.22.0 in insert_pin function that could potentially crash programs using the library.,OpenSC,CVE-2021-42780,CWE-252
961,9292,"int __close_fd_get_file(unsigned int fd, struct file **res)
{
struct files_struct *files = current->files;
struct file *file;
struct fdtable *fdt;
spin_lock(&files->file_lock);
fdt = files_fdtable(files);
if (fd >= fdt->max_fds)
goto out_unlock;
file = fdt->fd[fd];
if (!file)
goto out_unlock;
rcu_assign_pointer(fdt->fd[fd], NULL);
__put_unused_fd(files, fd);
spin_unlock(&files->file_lock);
get_file(file);
*res = file;
return filp_close(file, files);
out_unlock:
spin_unlock(&files->file_lock);
*res = NULL;
return -ENOENT;
}",[18],"The code in UEK6 U3 was missing an appropiate file descriptor count to be missing. This resulted in a use count error that allowed a file descriptor to a socket to be closed and freed while it was still in use by another portion of the kernel. An attack with local access can operate on the socket, and cause a denial of service. CVSS 3.1 Base Score 5.5 (Availability impacts). CVSS Vector: (CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H).",linux-uek,CVE-2022-21504,CWE-416
964,8136,"static int dwa_uncompress(EXRContext *s, const uint8_t *src, int compressed_size,
int uncompressed_size, EXRThreadData *td)
{
int64_t version, lo_usize, lo_size;
int64_t ac_size, dc_size, rle_usize, rle_csize, rle_raw_size;
int64_t ac_count, dc_count, ac_compression;
const int dc_w = td->xsize >> 3;
const int dc_h = td->ysize >> 3;
GetByteContext gb, agb;
int skip, ret;
if (compressed_size <= 88)
return AVERROR_INVALIDDATA;
version = AV_RL64(src + 0);
if (version != 2)
return AVERROR_INVALIDDATA;
lo_usize = AV_RL64(src + 8);
lo_size = AV_RL64(src + 16);
ac_size = AV_RL64(src + 24);
dc_size = AV_RL64(src + 32);
rle_csize = AV_RL64(src + 40);
rle_usize = AV_RL64(src + 48);
rle_raw_size = AV_RL64(src + 56);
ac_count = AV_RL64(src + 64);
dc_count = AV_RL64(src + 72);
ac_compression = AV_RL64(src + 80);
if (compressed_size < 88LL + lo_size + ac_size + dc_size + rle_csize)
return AVERROR_INVALIDDATA;
bytestream2_init(&gb, src + 88, compressed_size - 88);
skip = bytestream2_get_le16(&gb);
if (skip < 2)
return AVERROR_INVALIDDATA;
bytestream2_skip(&gb, skip - 2);
if (lo_size > 0) {
if (lo_usize > uncompressed_size)
return AVERROR_INVALIDDATA;
bytestream2_skip(&gb, lo_size);
}
if (ac_size > 0) {
unsigned long dest_len = ac_count * 2LL;
GetByteContext agb = gb;
if (ac_count > 3LL * td->xsize * s->scan_lines_per_block)
return AVERROR_INVALIDDATA;
av_fast_padded_malloc(&td->ac_data, &td->ac_size, dest_len);
if (!td->ac_data)
return AVERROR(ENOMEM);
switch (ac_compression) {
case 0:
ret = huf_uncompress(s, td, &agb, (int16_t *)td->ac_data, ac_count);
if (ret < 0)
return ret;
break;
case 1:
if (uncompress(td->ac_data, &dest_len, agb.buffer, ac_size) != Z_OK ||
dest_len != ac_count * 2LL)
return AVERROR_INVALIDDATA;
break;
default:
return AVERROR_INVALIDDATA;
}
bytestream2_skip(&gb, ac_size);
}
if (dc_size > 0) {
unsigned long dest_len = dc_count * 2LL;
GetByteContext agb = gb;
if (dc_count > (6LL * td->xsize * td->ysize + 63) / 64)
return AVERROR_INVALIDDATA;
av_fast_padded_malloc(&td->dc_data, &td->dc_size, FFALIGN(dest_len, 64) * 2);
if (!td->dc_data)
return AVERROR(ENOMEM);
if (uncompress(td->dc_data + FFALIGN(dest_len, 64), &dest_len, agb.buffer, dc_size) != Z_OK ||
(dest_len != dc_count * 2LL))
return AVERROR_INVALIDDATA;
s->dsp.predictor(td->dc_data + FFALIGN(dest_len, 64), dest_len);
s->dsp.reorder_pixels(td->dc_data, td->dc_data + FFALIGN(dest_len, 64), dest_len);
bytestream2_skip(&gb, dc_size);
}
if (rle_raw_size > 0 && rle_csize > 0 && rle_usize > 0) {
unsigned long dest_len = rle_usize;
av_fast_padded_malloc(&td->rle_data, &td->rle_size, rle_usize);
if (!td->rle_data)
return AVERROR(ENOMEM);
av_fast_padded_malloc(&td->rle_raw_data, &td->rle_raw_size, rle_raw_size);
if (!td->rle_raw_data)
return AVERROR(ENOMEM);
if (uncompress(td->rle_data, &dest_len, gb.buffer, rle_csize) != Z_OK ||
(dest_len != rle_usize))
return AVERROR_INVALIDDATA;
ret = rle(td->rle_raw_data, td->rle_data, rle_usize, rle_raw_size);
if (ret < 0)
return ret;
bytestream2_skip(&gb, rle_csize);
}
bytestream2_init(&agb, td->ac_data, ac_count * 2);
for (int y = 0; y < td->ysize; y += 8) {
for (int x = 0; x < td->xsize; x += 8) {
memset(td->block, 0, sizeof(td->block));
for (int j = 0; j < 3; j++) {
float *block = td->block[j];
const int idx = (x >> 3) + (y >> 3) * dc_w + dc_w * dc_h * j;
uint16_t *dc = (uint16_t *)td->dc_data;
union av_intfloat32 dc_val;
dc_val.i = half2float(dc[idx], s->mantissatable,
s->exponenttable, s->offsettable);
block[0] = dc_val.f;
ac_uncompress(s, &agb, block);
dct_inverse(block);
}
{
const float scale = s->pixel_type == EXR_FLOAT ? 2.f : 1.f;
const int o = s->nb_channels == 4;
float *bo = ((float *)td->uncompressed_data) +
y * td->xsize * s->nb_channels + td->xsize * (o + 0) + x;
float *go = ((float *)td->uncompressed_data) +
y * td->xsize * s->nb_channels + td->xsize * (o + 1) + x;
float *ro = ((float *)td->uncompressed_data) +
y * td->xsize * s->nb_channels + td->xsize * (o + 2) + x;
float *yb = td->block[0];
float *ub = td->block[1];
float *vb = td->block[2];
for (int yy = 0; yy < 8; yy++) {
for (int xx = 0; xx < 8; xx++) {
const int idx = xx + yy * 8;
convert(yb[idx], ub[idx], vb[idx], &bo[xx], &go[xx], &ro[xx]);
bo[xx] = to_linear(bo[xx], scale);
go[xx] = to_linear(go[xx], scale);
ro[xx] = to_linear(ro[xx], scale);
}
bo += td->xsize * s->nb_channels;
go += td->xsize * s->nb_channels;
ro += td->xsize * s->nb_channels;
}
}
}
}
if (s->nb_channels < 4)
return 0;
for (int y = 0; y < td->ysize && td->rle_raw_data; y++) {
uint32_t *ao = ((uint32_t *)td->uncompressed_data) + y * td->xsize * s->nb_channels;
uint8_t *ai0 = td->rle_raw_data + y * td->xsize;
uint8_t *ai1 = td->rle_raw_data + y * td->xsize + rle_raw_size / 2;
for (int x = 0; x < td->xsize; x++) {
uint16_t ha = ai0[x] | (ai1[x] << 8);
ao[x] = half2float(ha, s->mantissatable, s->exponenttable, s->offsettable);
}
}
return 0;
}","[62, 65]",dwa_uncompress in libavcodec/exr.c in FFmpeg 4.4 allows an out-of-bounds array access because dc_count is not strictly checked.,FFmpeg,CVE-2021-33815,CWE-129
966,9463,"xmlValidNormalizeAttributeValue(xmlDocPtr doc, xmlNodePtr elem,
const xmlChar *name, const xmlChar *value) {
xmlChar *ret, *dst;
const xmlChar *src;
xmlAttributePtr attrDecl = NULL;
if (doc == NULL) return(NULL);
if (elem == NULL) return(NULL);
if (name == NULL) return(NULL);
if (value == NULL) return(NULL);
if ((elem->ns != NULL) && (elem->ns->prefix != NULL)) {
xmlChar fn[50];
xmlChar *fullname;
fullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);
if (fullname == NULL)
return(NULL);
if ((fullname != fn) && (fullname != elem->name))
xmlFree(fullname);
}
attrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, name);
if ((attrDecl == NULL) && (doc->extSubset != NULL))
attrDecl = xmlGetDtdAttrDesc(doc->extSubset, elem->name, name);
if (attrDecl == NULL)
return(NULL);
if (attrDecl->atype == XML_ATTRIBUTE_CDATA)
return(NULL);
ret = xmlStrdup(value);
if (ret == NULL)
return(NULL);
src = value;
dst = ret;
while (*src == 0x20) src++;
while (*src != 0) {
if (*src == 0x20) {
while (*src == 0x20) src++;
if (*src != 0)
*dst++ = 0x20;
} else {
*dst++ = *src++;
}
}
*dst = 0;
return(ret);
}","[3, 4, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 41]",valid.c in libxml2 before 2.9.13 has a use-after-free of ID and IDREF attributes.,libxml2,CVE-2022-23308,CWE-416
972,6314,"jbig2_image_compose(Jbig2Ctx *ctx, Jbig2Image *dst, Jbig2Image *src, int x, int y, Jbig2ComposeOp op)
{
uint32_t w, h;
uint32_t shift;
uint32_t leftbyte;
uint8_t *ss;
uint8_t *dd;
uint8_t leftmask, rightmask;
int early = x >= 0;
int late;
uint32_t bytewidth;
uint32_t syoffset = 0;
if (src == NULL)
return 0;
w = src->width;
h = src->height;
shift = (x & 7);
ss = src->data - early;
if (x < 0) {
if (w < (uint32_t) -x)
w = 0;
else
w += x;
ss += (-x-1)>>3;
x = 0;
}
if (y < 0) {
if (h < (uint32_t) -y)
h = 0;
else
h += y;
syoffset = -y * src->stride;
y = 0;
}
if ((uint32_t)x + w > dst->width)
{
if (dst->width < (uint32_t)x)
w = 0;
else
w = dst->width - x;
}
if ((uint32_t)y + h > dst->height)
{
if (dst->height < (uint32_t)y)
h = 0;
else
h = dst->height - y;
}
#ifdef JBIG2_DEBUG
jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, ""compositing %dx%d at (%d, %d) after clipping"", w, h, x, y);
#endif
if ((w <= 0) || (h <= 0)) {
#ifdef JBIG2_DEBUG
jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, ""zero clipping region"");
#endif
return 0;
}
leftbyte = (uint32_t) x >> 3;
dd = dst->data + y * dst->stride + leftbyte;
bytewidth = (((uint32_t) x + w - 1) >> 3) - leftbyte + 1;
leftmask = 255>>(x&7);
rightmask = (((x+w)&7) == 0) ? 255 : ~(255>>((x+w)&7));
if (bytewidth == 1)
leftmask &= rightmask;
late = (ss + bytewidth >= src->data + ((src->width+7)>>3));
ss += syoffset;
switch(op)
{
case JBIG2_COMPOSE_OR:
jbig2_image_compose_opt_OR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);
break;
case JBIG2_COMPOSE_AND:
jbig2_image_compose_opt_AND(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);
break;
case JBIG2_COMPOSE_XOR:
jbig2_image_compose_opt_XOR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);
break;
case JBIG2_COMPOSE_XNOR:
jbig2_image_compose_opt_XNOR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);
break;
case JBIG2_COMPOSE_REPLACE:
jbig2_image_compose_opt_REPLACE(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);
break;
}
return 0;
}",[15],jbig2_image_compose in jbig2_image.c in Artifex jbig2dec before 0.18 has a heap-based buffer overflow.,jbig2dec,CVE-2020-12268,CWE-787
974,7555,"GF_Err gf_hinter_track_finalize(GF_RTPHinter *tkHint, Bool AddSystemInfo)
{
u32 Width, Height;
GF_ESD *esd;
char sdpLine[20000];
char mediaName[30], payloadName[30];
u32 mtype;
Width = Height = 0;
gf_isom_sdp_clean_track(tkHint->file, tkHint->TrackNum);
mtype = gf_isom_get_media_type(tkHint->file, tkHint->TrackNum);
if (gf_isom_is_video_handler_type(mtype))
gf_isom_get_visual_info(tkHint->file, tkHint->TrackNum, 1, &Width, &Height);
gf_rtp_builder_get_payload_name(tkHint->rtp_p, payloadName, mediaName);
sprintf(sdpLine, ""m=%s 0 RTP/%s %d"", mediaName, tkHint->rtp_p->slMap.IV_length ? ""SAVP"" : ""AVP"", tkHint->rtp_p->PayloadType);
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
if (tkHint->bandwidth) {
sprintf(sdpLine, ""b=AS:%d"", tkHint->bandwidth);
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
}
if (tkHint->nb_chan) {
sprintf(sdpLine, ""a=rtpmap:%d %s/%d/%d"", tkHint->rtp_p->PayloadType, payloadName, tkHint->rtp_p->sl_config.timestampResolution, tkHint->nb_chan);
} else {
sprintf(sdpLine, ""a=rtpmap:%d %s/%d"", tkHint->rtp_p->PayloadType, payloadName, tkHint->rtp_p->sl_config.timestampResolution);
}
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
if (AddSystemInfo) {
sprintf(sdpLine, ""a=mpeg4-esid:%d"", gf_isom_get_track_id(tkHint->file, tkHint->TrackNum));
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
}
sprintf(sdpLine, ""a=control:trackID=%d"", gf_isom_get_track_id(tkHint->file, tkHint->HintTrack));
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
if (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_H263) {
sprintf(sdpLine, ""a=cliprect:0,0,%d,%d"", Height, Width);
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
}
else if ((tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_AMR) || (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_AMR_WB)) {
sprintf(sdpLine, ""a=fmtp:%d octet-align=1"", tkHint->rtp_p->PayloadType);
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
}
else if (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_3GPP_TEXT) {
u32 w, h, i, m_w, m_h;
s32 tx, ty;
s16 l;
gf_isom_get_track_layout_info(tkHint->file, tkHint->TrackNum, &w, &h, &tx, &ty, &l);
m_w = w;
m_h = h;
for (i=0; i<gf_isom_get_track_count(tkHint->file); i++) {
switch (gf_isom_get_media_type(tkHint->file, i+1)) {
case GF_ISOM_MEDIA_SCENE:
case GF_ISOM_MEDIA_VISUAL:
case GF_ISOM_MEDIA_AUXV:
case GF_ISOM_MEDIA_PICT:
gf_isom_get_track_layout_info(tkHint->file, i+1, &w, &h, &tx, &ty, &l);
if (w>m_w) m_w = w;
if (h>m_h) m_h = h;
break;
default:
break;
}
}
gf_media_format_ttxt_sdp(tkHint->rtp_p, payloadName, sdpLine, w, h, tx, ty, l, m_w, m_h, NULL);
strcat(sdpLine, ""; tx3g="");
for (i=0; i<gf_isom_get_sample_description_count(tkHint->file, tkHint->TrackNum); i++) {
u8 *tx3g;
char buffer[2000];
u32 tx3g_len, len;
gf_isom_text_get_encoded_tx3g(tkHint->file, tkHint->TrackNum, i+1, GF_RTP_TX3G_SIDX_OFFSET, &tx3g, &tx3g_len);
len = gf_base64_encode(tx3g, tx3g_len, buffer, 2000);
gf_free(tx3g);
buffer[len] = 0;
if (i) strcat(sdpLine, "", "");
strcat(sdpLine, buffer);
}
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
}
else if ((tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_EVRC_SMV) && (tkHint->rtp_p->auh_size>1)) {
sprintf(sdpLine, ""a=fmtp:%d maxptime=%d"", tkHint->rtp_p->PayloadType, tkHint->rtp_p->auh_size*20);
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
}
else if ((tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_H264_AVC) || (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_H264_SVC))  {
GF_AVCConfig *avcc = gf_isom_avc_config_get(tkHint->file, tkHint->TrackNum, 1);
GF_AVCConfig *svcc = gf_isom_svc_config_get(tkHint->file, tkHint->TrackNum, 1);
if (avcc) {
sprintf(sdpLine, ""a=fmtp:%d profile-level-id=%02X%02X%02X; packetization-mode=1"", tkHint->rtp_p->PayloadType, avcc->AVCProfileIndication, avcc->profile_compatibility, avcc->AVCLevelIndication);
} else {
sprintf(sdpLine, ""a=fmtp:%d profile-level-id=%02X%02X%02X; packetization-mode=1"", tkHint->rtp_p->PayloadType, svcc->AVCProfileIndication, svcc->profile_compatibility, svcc->AVCLevelIndication);
}
write_avc_config(sdpLine, avcc, svcc);
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
gf_odf_avc_cfg_del(avcc);
gf_odf_avc_cfg_del(svcc);
}
else if (tkHint->rtp_p->rtp_payt==GF_RTP_PAYT_MPEG4) {
esd = gf_isom_get_esd(tkHint->file, tkHint->TrackNum, 1);
if (esd && esd->decoderConfig && esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data) {
gf_rtp_builder_format_sdp(tkHint->rtp_p, payloadName, sdpLine, esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength);
} else {
gf_rtp_builder_format_sdp(tkHint->rtp_p, payloadName, sdpLine, NULL, 0);
}
if (esd) gf_odf_desc_del((GF_Descriptor *)esd);
if (tkHint->rtp_p->slMap.IV_length) {
const char *kms;
gf_isom_get_ismacryp_info(tkHint->file, tkHint->TrackNum, 1, NULL, NULL, NULL, NULL, &kms, NULL, NULL, NULL);
if (!strnicmp(kms, ""(key)"", 5) || !strnicmp(kms, ""(ipmp)"", 6) || !strnicmp(kms, ""(uri)"", 5)) {
strcat(sdpLine, ""; ISMACrypKey="");
} else {
strcat(sdpLine, ""; ISMACrypKey=(uri)"");
}
strcat(sdpLine, kms);
}
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
}
else if (tkHint->rtp_p->rtp_payt==GF_RTP_PAYT_LATM) {
GF_BitStream *bs;
u8 *config_bytes;
u32 config_size;
bs = gf_bs_new(NULL, 32, GF_BITSTREAM_WRITE);
gf_bs_write_int(bs, 0, 1);
gf_bs_write_int(bs, 1, 1);
gf_bs_write_int(bs, 0, 6);
gf_bs_write_int(bs, 0, 4);
gf_bs_write_int(bs, 0, 3);
esd = gf_isom_get_esd(tkHint->file, tkHint->TrackNum, 1);
if (esd && esd->decoderConfig && esd->decoderConfig->decoderSpecificInfo) {
gf_bs_write_data(bs, esd->decoderConfig->decoderSpecificInfo->data, MIN(esd->decoderConfig->decoderSpecificInfo->dataLength, 2) );
}
if (esd) gf_odf_desc_del((GF_Descriptor *)esd);
gf_bs_write_int(bs, 0, 3);
gf_bs_write_int(bs, 0xff, 8);
gf_bs_write_int(bs, 0, 1);
gf_bs_write_int(bs, 0, 1);
gf_bs_get_content(bs, &config_bytes, &config_size);
gf_bs_del(bs);
gf_rtp_builder_format_sdp(tkHint->rtp_p, payloadName, sdpLine, config_bytes, config_size);
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
gf_free(config_bytes);
}
#if GPAC_ENABLE_3GPP_DIMS_RTP
else if (tkHint->rtp_p->rtp_payt==GF_RTP_PAYT_3GPP_DIMS) {
GF_DIMSDescription dims;
gf_isom_get_visual_info(tkHint->file, tkHint->TrackNum, 1, &Width, &Height);
gf_isom_get_dims_description(tkHint->file, tkHint->TrackNum, 1, &dims);
sprintf(sdpLine, ""a=fmtp:%d Version-profile=%d"", tkHint->rtp_p->PayloadType, dims.profile);
if (! dims.fullRequestHost) {
char fmt[200];
strcat(sdpLine, "";useFullRequestHost=0"");
sprintf(fmt, "";pathComponents=%d"", dims.pathComponents);
strcat(sdpLine, fmt);
}
if (!dims.streamType) strcat(sdpLine, "";stream-type=secondary"");
if (dims.containsRedundant == 1) strcat(sdpLine, "";contains-redundant=main"");
else if (dims.containsRedundant == 2) strcat(sdpLine, "";contains-redundant=redundant"");
if (dims.textEncoding && strlen(dims.textEncoding)) {
strcat(sdpLine, "";text-encoding="");
strcat(sdpLine, dims.textEncoding);
}
if (dims.contentEncoding && strlen(dims.contentEncoding)) {
strcat(sdpLine, "";content-coding="");
strcat(sdpLine, dims.contentEncoding);
}
if (dims.contentEncoding && dims.content_script_types && strlen(dims.content_script_types) ) {
strcat(sdpLine, "";content-script-types="");
strcat(sdpLine, dims.contentEncoding);
}
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
}
#endif
if (Width && Height) {
sprintf(sdpLine, ""a=framesize:%d %d-%d"", tkHint->rtp_p->PayloadType, Width, Height);
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
}
esd = gf_isom_get_esd(tkHint->file, tkHint->TrackNum, 1);
if (esd && esd->decoderConfig && (esd->decoderConfig->rvc_config || esd->decoderConfig->predefined_rvc_config)) {
if (esd->decoderConfig->predefined_rvc_config) {
sprintf(sdpLine, ""a=rvc-config-predef:%d"", esd->decoderConfig->predefined_rvc_config);
} else {
if ((esd->decoderConfig->objectTypeIndication==GF_CODECID_AVC) || (esd->decoderConfig->objectTypeIndication==GF_CODECID_SVC)) {
sprintf(sdpLine, ""a=rvc-config:%s"", ""http:download.tsi.telecom-paristech.fr/gpac/RVC/rvc_config_avc.xml"");
} else {
sprintf(sdpLine, ""a=rvc-config:%s"", ""http:download.tsi.telecom-paristech.fr/gpac/RVC/rvc_config_sp.xml"");
}
}
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
}
if (esd) gf_odf_desc_del((GF_Descriptor *)esd);
gf_isom_set_track_enabled(tkHint->file, tkHint->HintTrack, GF_TRUE);
return GF_OK;
}",[86],An issue was discovered in GPAC version 0.8.0 and 1.0.1. There is an invalid pointer dereference in the function gf_hinter_track_finalize() in media_tools/isom_hinter.c.,gpac,CVE-2020-35982,CWE-476
977,9634,"static void gf_dump_vrml_proto_field(GF_SceneDumper *sdump, GF_Node *node, GF_FieldInfo field)
{
u32 i, sf_type;
void *slot_ptr;
DUMP_IND(sdump);
gf_fprintf(sdump->trace, ""<fieldValue name=\""%s\"" "", field.name);
if (gf_sg_vrml_is_sf_field(field.fieldType)) {
if (field.fieldType == GF_SG_VRML_SFNODE) {
gf_fprintf(sdump->trace, "">\n"");
sdump->indent++;
if (!sdump->X3DDump) gf_fprintf(sdump->trace, ""<node>"");
gf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL);
if (!sdump->X3DDump) gf_fprintf(sdump->trace, ""</node>"");
sdump->indent--;
DUMP_IND(sdump);
gf_fprintf(sdump->trace, ""</fieldValue>\n"");
} else {
if (sdump->X3DDump) {
gf_fprintf(sdump->trace, "" value=\"""");
} else {
gf_fprintf(sdump->trace, "" %s=\"""", GetXMTFieldTypeValueName(field.fieldType));
}
gf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, node);
gf_fprintf(sdump->trace, ""\""/>\n"");
}
} else {
GenMFField *mffield = (GenMFField *) field.far_ptr;
sf_type = gf_sg_vrml_get_sf_type(field.fieldType);
if ((field.eventType==GF_SG_EVENT_FIELD) || (field.eventType==GF_SG_EVENT_EXPOSED_FIELD)) {
if (sf_type == GF_SG_VRML_SFNODE) {
GF_ChildNodeItem *list = *(GF_ChildNodeItem **)field.far_ptr;
gf_fprintf(sdump->trace, "">\n"");
sdump->indent++;
if (!sdump->X3DDump) gf_fprintf(sdump->trace, ""<nodes>"");
while (list) {
gf_dump_vrml_node(sdump, list->node, 1, NULL);
list = list->next;
}
if (!sdump->X3DDump) gf_fprintf(sdump->trace, ""</nodes>"");
sdump->indent--;
DUMP_IND(sdump);
gf_fprintf(sdump->trace, ""</fieldValue>\n"");
} else {
if (sdump->X3DDump) {
gf_fprintf(sdump->trace, "" value=\"""");
} else {
gf_fprintf(sdump->trace, "" %s=\"""", GetXMTFieldTypeValueName(field.fieldType));
}
if (mffield) {
for (i=0; i<mffield->count; i++) {
if (i) gf_fprintf(sdump->trace, "" "");
if (field.fieldType != GF_SG_VRML_MFNODE) {
gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);
gf_dump_vrml_sffield(sdump, sf_type, slot_ptr, (mffield->count>1) ? 1 : 0, node);
}
}
}
gf_fprintf(sdump->trace, ""\""/>\n"");
}
}
}
}","[49, 50, 51, 52, 53, 54]",NULL Pointer Dereference in GitHub repository gpac/gpac prior to v2.1.0-DEV.,gpac,CVE-2022-2549,CWE-476
980,1833,"Controller::constructHeaderForSessionProtocol(Request *req, char * restrict buffer,
unsigned int &size, const SessionProtocolWorkingState &state, string delta_monotonic)
{
char *pos = buffer;
const char *end = buffer + size;
pos += sizeof(boost::uint32_t);
pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""REQUEST_URI""));
pos = appendData(pos, end, req->path.start->data, req->path.size);
pos = appendData(pos, end, """", 1);
pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""PATH_INFO""));
pos = appendData(pos, end, state.path.data(), state.path.size());
pos = appendData(pos, end, """", 1);
pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""SCRIPT_NAME""));
if (state.hasBaseURI) {
pos = appendData(pos, end, req->options.baseURI);
pos = appendData(pos, end, """", 1);
} else {
pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""""));
}
pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""QUERY_STRING""));
pos = appendData(pos, end, state.queryString.data(), state.queryString.size());
pos = appendData(pos, end, """", 1);
pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""REQUEST_METHOD""));
pos = appendData(pos, end, state.methodStr);
pos = appendData(pos, end, """", 1);
pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""SERVER_NAME""));
pos = appendData(pos, end, state.serverName);
pos = appendData(pos, end, """", 1);
pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""SERVER_PORT""));
pos = appendData(pos, end, state.serverPort);
pos = appendData(pos, end, """", 1);
pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""SERVER_SOFTWARE""));
pos = appendData(pos, end, serverSoftware);
pos = appendData(pos, end, """", 1);
pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""SERVER_PROTOCOL""));
pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""HTTP/1.1""));
pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""REMOTE_ADDR""));
if (state.remoteAddr != NULL) {
pos = appendData(pos, end, state.remoteAddr);
pos = appendData(pos, end, """", 1);
} else {
pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""127.0.0.1""));
}
pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""REMOTE_PORT""));
if (state.remotePort != NULL) {
pos = appendData(pos, end, state.remotePort);
pos = appendData(pos, end, """", 1);
} else {
pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""0""));
}
if (state.remoteUser != NULL) {
pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""REMOTE_USER""));
pos = appendData(pos, end, state.remoteUser);
pos = appendData(pos, end, """", 1);
}
if (state.contentType != NULL) {
pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""CONTENT_TYPE""));
pos = appendData(pos, end, state.contentType);
pos = appendData(pos, end, """", 1);
}
if (state.contentLength != NULL) {
pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""CONTENT_LENGTH""));
pos = appendData(pos, end, state.contentLength);
pos = appendData(pos, end, """", 1);
}
pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""PASSENGER_CONNECT_PASSWORD""));
pos = appendData(pos, end, req->session->getApiKey().toStaticString());
pos = appendData(pos, end, """", 1);
if (req->https) {
pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""HTTPS""));
pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""on""));
}
if (req->options.analytics) {
pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""PASSENGER_TXN_ID""));
pos = appendData(pos, end, req->options.transaction->getTxnId());
pos = appendData(pos, end, """", 1);
pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""PASSENGER_DELTA_MONOTONIC""));
pos = appendData(pos, end, delta_monotonic);
pos = appendData(pos, end, """", 1);
}
if (req->upgraded()) {
pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""HTTP_CONNECTION""));
pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""upgrade""));
}
ServerKit::HeaderTable::Iterator it(req->headers);
while (*it != NULL) {
if ((it->header->hash == HTTP_CONTENT_LENGTH.hash()
|| it->header->hash == HTTP_CONTENT_TYPE.hash()
|| it->header->hash == HTTP_CONNECTION.hash())
&& (psg_lstr_cmp(&it->header->key, P_STATIC_STRING(""content-type""))
|| psg_lstr_cmp(&it->header->key, P_STATIC_STRING(""content-length""))
|| psg_lstr_cmp(&it->header->key, P_STATIC_STRING(""connection""))))
{
it.next();
continue;
}
pos = appendData(pos, end, P_STATIC_STRING(""HTTP_""));
const LString::Part *part = it->header->key.start;
while (part != NULL) {
char *start = pos;
pos = appendData(pos, end, part->data, part->size);
httpHeaderToScgiUpperCase((unsigned char *) start, pos - start);
part = part->next;
}
pos = appendData(pos, end, """", 1);
part = it->header->val.start;
while (part != NULL) {
pos = appendData(pos, end, part->data, part->size);
part = part->next;
}
pos = appendData(pos, end, """", 1);
it.next();
}
if (state.environmentVariablesData != NULL) {
pos = appendData(pos, end, state.environmentVariablesData, state.environmentVariablesSize);
}
Uint32Message::generate(buffer, pos - buffer - sizeof(boost::uint32_t));
size = pos - buffer;
return pos < end;
}","[87, 88, 89, 90, 91, 92]","agent/Core/Controller/SendRequest.cpp in Phusion Passenger before 4.0.60 and 5.0.x before 5.0.22, when used in Apache integration mode or in standalone mode without a filtering proxy, allows remote attackers to spoof headers passed to applications by using an _ (underscore) character instead of a - (dash) character in an HTTP header, as demonstrated by an X_User header.",passenger,CVE-2015-7519,CWE-20
981,6078,"void sqlite3EndTable(
Parse *pParse,
Token *pCons,
Token *pEnd,
u8 tabOpts,
Select *pSelect
){
Table *p;
sqlite3 *db = pParse->db;
int iDb;
Index *pIdx;
if( pEnd==0 && pSelect==0 ){
return;
}
assert( !db->mallocFailed );
p = pParse->pNewTable;
if( p==0 ) return;
if( pSelect==0 && isShadowTableName(db, p->zName) ){
p->tabFlags |= TF_Shadow;
}
if( db->init.busy ){
if( pSelect ){
sqlite3ErrorMsg(pParse, """");
return;
}
p->tnum = db->init.newTnum;
if( p->tnum==1 ) p->tabFlags |= TF_Readonly;
}
assert( (p->tabFlags & TF_HasPrimaryKey)==0
|| p->iPKey>=0 || sqlite3PrimaryKeyIndex(p)!=0 );
assert( (p->tabFlags & TF_HasPrimaryKey)!=0
|| (p->iPKey<0 && sqlite3PrimaryKeyIndex(p)==0) );
if( tabOpts & TF_WithoutRowid ){
if( (p->tabFlags & TF_Autoincrement) ){
sqlite3ErrorMsg(pParse,
""AUTOINCREMENT not allowed on WITHOUT ROWID tables"");
return;
}
if( (p->tabFlags & TF_HasPrimaryKey)==0 ){
sqlite3ErrorMsg(pParse, ""PRIMARY KEY missing on table %s"", p->zName);
return;
}
p->tabFlags |= TF_WithoutRowid | TF_NoVisibleRowid;
convertToWithoutRowidTable(pParse, p);
}
iDb = sqlite3SchemaToIndex(db, p->pSchema);
#ifndef SQLITE_OMIT_CHECK
if( p->pCheck ){
sqlite3ResolveSelfReference(pParse, p, NC_IsCheck, 0, p->pCheck);
}
#endif /* !defined(SQLITE_OMIT_CHECK) */
#ifndef SQLITE_OMIT_GENERATED_COLUMNS
if( p->tabFlags & TF_HasGenerated ){
int ii, nNG = 0;
testcase( p->tabFlags & TF_HasVirtual );
testcase( p->tabFlags & TF_HasStored );
for(ii=0; ii<p->nCol; ii++){
u32 colFlags = p->aCol[ii].colFlags;
if( (colFlags & COLFLAG_GENERATED)!=0 ){
testcase( colFlags & COLFLAG_VIRTUAL );
testcase( colFlags & COLFLAG_STORED );
sqlite3ResolveSelfReference(pParse, p, NC_GenCol,
p->aCol[ii].pDflt, 0);
}else{
nNG++;
}
}
if( nNG==0 ){
sqlite3ErrorMsg(pParse, ""must have at least one non-generated column"");
return;
}
}
#endif
estimateTableWidth(p);
for(pIdx=p->pIndex; pIdx; pIdx=pIdx->pNext){
estimateIndexWidth(pIdx);
}
if( !db->init.busy ){
int n;
Vdbe *v;
char *zType;
char *zType2;
char *zStmt;
v = sqlite3GetVdbe(pParse);
if( NEVER(v==0) ) return;
sqlite3VdbeAddOp1(v, OP_Close, 0);
if( p->pSelect==0 ){
zType = ""table"";
zType2 = ""TABLE"";
#ifndef SQLITE_OMIT_VIEW
}else{
zType = ""view"";
zType2 = ""VIEW"";
#endif
}
if( pSelect ){
SelectDest dest;
int regYield;
int addrTop;
int regRec;
int regRowid;
int addrInsLoop;
Table *pSelTab;
regYield = ++pParse->nMem;
regRec = ++pParse->nMem;
regRowid = ++pParse->nMem;
assert(pParse->nTab==1);
sqlite3MayAbort(pParse);
sqlite3VdbeAddOp3(v, OP_OpenWrite, 1, pParse->regRoot, iDb);
sqlite3VdbeChangeP5(v, OPFLAG_P2ISREG);
pParse->nTab = 2;
addrTop = sqlite3VdbeCurrentAddr(v) + 1;
sqlite3VdbeAddOp3(v, OP_InitCoroutine, regYield, 0, addrTop);
if( pParse->nErr ) return;
pSelTab = sqlite3ResultSetOfSelect(pParse, pSelect, SQLITE_AFF_BLOB);
if( pSelTab==0 ) return;
assert( p->aCol==0 );
p->nCol = p->nNVCol = pSelTab->nCol;
p->aCol = pSelTab->aCol;
pSelTab->nCol = 0;
pSelTab->aCol = 0;
sqlite3DeleteTable(db, pSelTab);
sqlite3SelectDestInit(&dest, SRT_Coroutine, regYield);
sqlite3Select(pParse, pSelect, &dest);
if( pParse->nErr ) return;
sqlite3VdbeEndCoroutine(v, regYield);
sqlite3VdbeJumpHere(v, addrTop - 1);
addrInsLoop = sqlite3VdbeAddOp1(v, OP_Yield, dest.iSDParm);
VdbeCoverage(v);
sqlite3VdbeAddOp3(v, OP_MakeRecord, dest.iSdst, dest.nSdst, regRec);
sqlite3TableAffinity(v, p, 0);
sqlite3VdbeAddOp2(v, OP_NewRowid, 1, regRowid);
sqlite3VdbeAddOp3(v, OP_Insert, 1, regRec, regRowid);
sqlite3VdbeGoto(v, addrInsLoop);
sqlite3VdbeJumpHere(v, addrInsLoop);
sqlite3VdbeAddOp1(v, OP_Close, 1);
}
if( pSelect ){
zStmt = createTableStmt(db, p);
}else{
Token *pEnd2 = tabOpts ? &pParse->sLastToken : pEnd;
n = (int)(pEnd2->z - pParse->sNameToken.z);
if( pEnd2->z[0]!=';' ) n += pEnd2->n;
zStmt = sqlite3MPrintf(db,
""CREATE %s %.*s"", zType2, n, pParse->sNameToken.z
);
}
sqlite3NestedParse(pParse,
""UPDATE %Q.%s ""
""SET type='%s', name=%Q, tbl_name=%Q, rootpage=#%d, sql=%Q ""
""WHERE rowid=#%d"",
db->aDb[iDb].zDbSName, MASTER_NAME,
zType,
p->zName,
p->zName,
pParse->regRoot,
zStmt,
pParse->regRowid
);
sqlite3DbFree(db, zStmt);
sqlite3ChangeCookie(pParse, iDb);
#ifndef SQLITE_OMIT_AUTOINCREMENT
if( (p->tabFlags & TF_Autoincrement)!=0 ){
Db *pDb = &db->aDb[iDb];
assert( sqlite3SchemaMutexHeld(db, iDb, 0) );
if( pDb->pSchema->pSeqTab==0 ){
sqlite3NestedParse(pParse,
""CREATE TABLE %Q.sqlite_sequence(name,seq)"",
pDb->zDbSName
);
}
}
#endif
sqlite3VdbeAddParseSchemaOp(v, iDb,
sqlite3MPrintf(db, ""tbl_name='%q' AND type!='trigger'"", p->zName));
}
if( db->init.busy ){
Table *pOld;
Schema *pSchema = p->pSchema;
assert( sqlite3SchemaMutexHeld(db, iDb, 0) );
pOld = sqlite3HashInsert(&pSchema->tblHash, p->zName, p);
if( pOld ){
assert( p==pOld );
sqlite3OomFault(db);
return;
}
pParse->pNewTable = 0;
db->mDbFlags |= DBFLAG_SchemaChange;
#ifndef SQLITE_OMIT_ALTERTABLE
if( !p->pSelect ){
const char *zName = (const char *)pParse->sNameToken.z;
int nName;
assert( !pSelect && pCons && pEnd );
if( pCons->z==0 ){
pCons = pEnd;
}
nName = (int)((const char *)pCons->z - zName);
p->addColOffset = 13 + sqlite3Utf8CharLen(zName, nName);
}
#endif
}
}",[18],"SQLite 3.30.1 mishandles certain SELECT statements with a nonexistent VIEW, leading to an application crash.",sqlite,CVE-2019-19603,NVD-CWE-noinfo
990,8675,"sc_oberthur_read_file(struct sc_pkcs15_card *p15card, const char *in_path,
unsigned char **out, size_t *out_len,
int verify_pin)
{
struct sc_context *ctx = p15card->card->ctx;
struct sc_card *card = p15card->card;
struct sc_file *file = NULL;
struct sc_path path;
size_t sz;
int rv;
LOG_FUNC_CALLED(ctx);
if (!in_path || !out || !out_len)
LOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, ""Cannot read oberthur file"");
sc_log(ctx, ""read file '%s'; verify_pin:%i"", in_path, verify_pin);
*out = NULL;
*out_len = 0;
sc_format_path(in_path, &path);
rv = sc_select_file(card, &path, &file);
if (rv != SC_SUCCESS) {
sc_file_free(file);
LOG_TEST_RET(ctx, rv, ""Cannot select oberthur file to read"");
}
if (file->ef_structure == SC_FILE_EF_TRANSPARENT)
sz = file->size;
else
sz = (file->record_length + 2) * file->record_count;
*out = calloc(sz, 1);
if (*out == NULL) {
sc_file_free(file);
LOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, ""Cannot read oberthur file"");
}
if (file->ef_structure == SC_FILE_EF_TRANSPARENT)   {
rv = sc_read_binary(card, 0, *out, sz, 0);
}
else {
size_t rec;
size_t offs = 0;
size_t rec_len = file->record_length;
for (rec = 1; ; rec++)   {
if (rec > file->record_count) {
rv = 0;
break;
}
rv = sc_read_record(card, rec, *out + offs + 2, rec_len, SC_RECORD_BY_REC_NR);
if (rv == SC_ERROR_RECORD_NOT_FOUND)   {
rv = 0;
break;
}
else if (rv < 0)   {
break;
}
rec_len = rv;
*(*out + offs) = 'R';
*(*out + offs + 1) = rv;
offs += rv + 2;
}
sz = offs;
}
sc_log(ctx, ""read oberthur file result %i"", rv);
if (verify_pin && rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)   {
struct sc_pkcs15_object *objs[0x10], *pin_obj = NULL;
const struct sc_acl_entry *acl = sc_file_get_acl_entry(file, SC_AC_OP_READ);
int ii;
if (acl == NULL) {
sc_file_free(file);
free(*out);
*out = NULL;
LOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_DATA);
}
rv = sc_pkcs15_get_objects(p15card, SC_PKCS15_TYPE_AUTH_PIN, objs, 0x10);
if (rv != SC_SUCCESS) {
sc_file_free(file);
free(*out);
*out = NULL;
LOG_TEST_RET(ctx, rv, ""Cannot read oberthur file: get AUTH objects error"");
}
for (ii=0; ii<rv; ii++)   {
struct sc_pkcs15_auth_info *auth_info = (struct sc_pkcs15_auth_info *) objs[ii]->data;
sc_log(ctx, ""compare PIN/ACL refs:%i/%i, method:%i/%i"",
auth_info->attrs.pin.reference, acl->key_ref, auth_info->auth_method, acl->method);
if (auth_info->attrs.pin.reference == (int)acl->key_ref && auth_info->auth_method == (unsigned)acl->method)   {
pin_obj = objs[ii];
break;
}
}
if (!pin_obj || !pin_obj->content.value)    {
rv = SC_ERROR_SECURITY_STATUS_NOT_SATISFIED;
}
else    {
rv = sc_pkcs15_verify_pin(p15card, pin_obj, pin_obj->content.value, pin_obj->content.len);
if (!rv)
rv = sc_oberthur_read_file(p15card, in_path, out, out_len, 0);
}
}
sc_file_free(file);
if (rv < 0)   {
free(*out);
*out = NULL;
*out_len = 0;
}
*out_len = sz;
LOG_FUNC_RETURN(ctx, rv);
}","[63, 70, 71, 75, 77, 80]",A heap use after free issue was found in Opensc before version 0.22.0 in sc_file_valid.,OpenSC,CVE-2021-42779,CWE-416
1015,7992,"GF_Err latm_dmx_process(GF_Filter *filter)
{
GF_LATMDmxCtx *ctx = gf_filter_get_udta(filter);
GF_FilterPacket *pck, *dst_pck;
u32 pos;
u8 *data, *output;
u32 pck_size, prev_pck_size;
u64 cts = GF_FILTER_NO_TS;
if (ctx->in_error)
return ctx->in_error;
if (!ctx->duration.num)
latm_dmx_check_dur(filter, ctx);
if (ctx->opid && !ctx->is_playing)
return GF_OK;
pck = gf_filter_pid_get_packet(ctx->ipid);
if (!pck) {
if (gf_filter_pid_is_eos(ctx->ipid)) {
if (!ctx->latm_buffer_size) {
if (ctx->opid)
gf_filter_pid_set_eos(ctx->opid);
if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);
ctx->src_pck = NULL;
return GF_EOS;
}
} else {
return GF_OK;
}
}
data = (char *) gf_filter_pck_get_data(pck, &pck_size);
if (ctx->timescale && pck) {
cts = gf_filter_pck_get_cts(pck);
}
prev_pck_size = ctx->latm_buffer_size;
if (pck && !ctx->resume_from) {
if (ctx->latm_buffer_size + pck_size > ctx->latm_buffer_alloc) {
ctx->latm_buffer_alloc = ctx->latm_buffer_size + pck_size;
ctx->latm_buffer = gf_realloc(ctx->latm_buffer, ctx->latm_buffer_alloc);
}
memcpy(ctx->latm_buffer + ctx->latm_buffer_size, data, pck_size);
ctx->latm_buffer_size += pck_size;
}
if (!ctx->bs) ctx->bs = gf_bs_new(ctx->latm_buffer, ctx->latm_buffer_size, GF_BITSTREAM_READ);
else gf_bs_reassign_buffer(ctx->bs, ctx->latm_buffer, ctx->latm_buffer_size);
if (ctx->resume_from) {
gf_bs_seek(ctx->bs, ctx->resume_from-1);
ctx->resume_from = 0;
}
if (cts == GF_FILTER_NO_TS)
prev_pck_size = 0;
while (1) {
pos = (u32) gf_bs_get_position(ctx->bs);
u8 latm_buffer[4096];
u32 latm_frame_size = 4096;
if (!latm_dmx_sync_frame_bs(ctx->bs,&ctx->acfg, &latm_frame_size, latm_buffer, NULL)) break;
if (ctx->in_seek) {
u64 nb_samples_at_seek = (u64) (ctx->start_range * GF_M4ASampleRates[ctx->sr_idx]);
if (ctx->cts + ctx->dts_inc >= nb_samples_at_seek) {
ctx->in_seek = GF_FALSE;
}
}
latm_dmx_check_pid(filter, ctx);
if (!ctx->is_playing) {
ctx->resume_from = pos+1;
return GF_OK;
}
if (!ctx->in_seek) {
GF_FilterSAPType sap = GF_FILTER_SAP_1;
dst_pck = gf_filter_pck_new_alloc(ctx->opid, latm_frame_size, &output);
if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
memcpy(output, latm_buffer, latm_frame_size);
gf_filter_pck_set_cts(dst_pck, ctx->cts);
gf_filter_pck_set_duration(dst_pck, ctx->dts_inc);
gf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);
if (ctx->acfg.base_object_type==GF_CODECID_USAC) {
if (latm_frame_size && (output[0] & 0x80) && !ctx->prev_sap) {
sap = GF_FILTER_SAP_1;
ctx->prev_sap = GF_TRUE;
} else {
sap = GF_FILTER_SAP_NONE;
ctx->prev_sap = GF_FALSE;
}
}
gf_filter_pck_set_sap(dst_pck, sap);
gf_filter_pck_send(dst_pck);
}
latm_dmx_update_cts(ctx);
if (prev_pck_size) {
pos = (u32) gf_bs_get_position(ctx->bs);
if (prev_pck_size<=pos) {
prev_pck_size=0;
if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);
ctx->src_pck = pck;
if (pck)
gf_filter_pck_ref_props(&ctx->src_pck);
}
}
}
if (pck) {
pos = (u32) gf_bs_get_position(ctx->bs);
assert(ctx->latm_buffer_size >= pos);
memmove(ctx->latm_buffer, ctx->latm_buffer+pos, ctx->latm_buffer_size - pos);
ctx->latm_buffer_size -= pos;
gf_filter_pid_drop_packet(ctx->ipid);
assert(!ctx->resume_from);
} else {
ctx->latm_buffer_size = 0;
return latm_dmx_process(filter);
}
return GF_OK;
}","[6, 7, 29]","In filters/reframe_latm.c in GPAC 1.0.1 there is a Null Pointer Dereference, when gf_filter_pck_get_data is called. The first arg pck may be null with a crafted mp4 file,which results in a crash.",gpac,CVE-2021-30199,CWE-476
1017,7967,"static s32 gf_media_vvc_read_pps_bs_internal(GF_BitStream *bs, VVCState *vvc)
{
u32 i;
s32 pps_id;
VVC_PPS *pps;
pps_id = gf_bs_read_int_log(bs, 6, ""pps_id"");
if ((pps_id < 0) || (pps_id >= 64)) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[VVC] wrong PPS ID %d in PPS\n"", pps_id));
return -1;
}
pps = &vvc->pps[pps_id];
if (!pps->state) {
pps->id = pps_id;
pps->state = 1;
}
pps->sps_id = gf_bs_read_int_log(bs, 4, ""sps_id"");
if (pps->sps_id >= 16) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[VVC] wrong SPS ID %d in PPS\n"", pps->sps_id));
pps->sps_id=0;
return -1;
}
vvc->sps_active_idx = pps->sps_id;
pps->mixed_nal_types = gf_bs_read_int_log(bs, 1, ""mixed_nal_types"");
pps->width = gf_bs_read_ue_log(bs, ""width"");
pps->height = gf_bs_read_ue_log(bs, ""height"");
pps->conf_window = gf_bs_read_int_log(bs, 1, ""conformance_window_flag"");
if (pps->conf_window) {
pps->cw_left = gf_bs_read_ue_log(bs, ""conf_win_left_offset"");
pps->cw_right = gf_bs_read_ue_log(bs, ""conf_win_right_offset"");
pps->cw_top = gf_bs_read_ue_log(bs, ""conf_win_top_offset"");
pps->cw_bottom = gf_bs_read_ue_log(bs, ""conf_win_bottom_offset"");
}
if (gf_bs_read_int_log(bs, 1, ""scaling_window_explicit_signalling_flag"")) {
gf_bs_read_se_log(bs, ""scaling_win_left_offset"");
gf_bs_read_se_log(bs, ""scaling_win_right_offset"");
gf_bs_read_se_log(bs, ""scaling_win_top_offset"");
gf_bs_read_se_log(bs, ""scaling_win_bottom_offset"");
}
pps->output_flag_present_flag = gf_bs_read_int_log(bs, 1, ""output_flag_present_flag"");
pps->no_pic_partition_flag = gf_bs_read_int_log(bs, 1, ""no_pic_partition_flag"");
pps->subpic_id_mapping_present_flag = gf_bs_read_int_log(bs, 1, ""subpic_id_mapping_present_flag"");
if (pps->subpic_id_mapping_present_flag) {
u32 pps_subpic_id_len, pps_num_subpics=0;
if (!pps->no_pic_partition_flag) {
pps_num_subpics = 1+gf_bs_read_ue_log(bs, ""pps_num_subpics_minus1"");
}
pps_subpic_id_len = 1 + gf_bs_read_ue(bs);
for (i=0; i<pps_num_subpics; i++) {
gf_bs_read_int_log_idx(bs, pps_subpic_id_len, ""subpic_id"", i);
}
}
if (!pps->no_pic_partition_flag) {
gf_bs_read_int_log(bs, 2, ""pps_log2_ctu_size_minus5"");
u32 num_exp_tile_columns = 1 + gf_bs_read_ue_log(bs, ""num_exp_tile_columns_minus1"");
u32 num_exp_tile_rows = 1 + gf_bs_read_ue_log(bs, ""num_exp_tile_rows_minus1"");
for (i=0; i<num_exp_tile_columns; i++)
gf_bs_read_ue_log_idx(bs, ""tile_column_width_minus1"", i);
for (i=0; i<num_exp_tile_rows; i++)
gf_bs_read_ue_log_idx(bs, ""tile_row_height_minus1"", i);
return pps_id;
}
return pps_id;
}",[17],There is a integer overflow in media_tools/av_parsers.c in the hevc_parse_slice_segment function in GPAC 1.0.1 which results in a crash.,gpac,CVE-2021-30014,CWE-190
1018,6120,"static void listdir(unsigned int depth, int f, void * const tls_fd,
const char *name)
{
PureFileInfo *dir;
char *names;
PureFileInfo *s;
PureFileInfo *r;
int d;
if (depth >= max_ls_depth || matches >= max_ls_files) {
return;
}
if ((dir = sreaddir(&names)) == NULL) {
addreply(226, MSG_CANT_READ_FILE, name);
return;
}
s = dir;
while (s->name_offset != (size_t) -1) {
d = 0;
if (FI_NAME(s)[0] != '.') {
d = listfile(s, NULL);
} else if (opt_a) {
if (FI_NAME(s)[1] == 0 ||
(FI_NAME(s)[1] == '.' && FI_NAME(s)[2] == 0)) {
listfile(s, NULL);
} else {
d = listfile(s, NULL);
}
}
if (!d) {
s->name_offset = (size_t) -1;
}
s++;
}
outputfiles(f, tls_fd);
r = dir;
while (opt_R && r != s) {
if (r->name_offset != (size_t) -1 && !chdir(FI_NAME(r))) {
char *alloca_subdir;
const size_t sizeof_subdir = PATH_MAX + 1U;
if ((alloca_subdir = ALLOCA(sizeof_subdir)) == NULL) {
goto toomany;
}
if (SNCHECK(snprintf(alloca_subdir, sizeof_subdir, ""%s/%s"",
name, FI_NAME(r)), sizeof_subdir)) {
goto nolist;
}
wrstr(f, tls_fd, ""\r\n\r\n"");
wrstr(f, tls_fd, alloca_subdir);
wrstr(f, tls_fd, "":\r\n\r\n"");
listdir(depth + 1U, f, tls_fd, alloca_subdir);
nolist:
ALLOCA_FREE(alloca_subdir);
if (matches >= max_ls_files) {
goto toomany;
}
if (chdir("".."")) {
if (chdir(wd) || chdir(name)) {
die(421, LOG_ERR, ""chdir: %s"", strerror(errno));
}
}
}
r++;
}
toomany:
free(names);
free(dir);
names = NULL;
}","[8, 36, 38, 39, 40, 41, 51, 52, 65]","In Pure-FTPd 1.0.49, a stack exhaustion issue was discovered in the listdir function in ls.c.",pure-ftpd,CVE-2019-20176,CWE-400
1020,9148,"GF_Err diST_box_read(GF_Box *s, GF_BitStream *bs)
{
u32 i;
char str[1024];
GF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s;
i=0;
str[0]=0;
while (1) {
str[i] = gf_bs_read_u8(bs);
if (!str[i]) break;
i++;
}
ISOM_DECREASE_SIZE(p, i);
p->content_script_types = gf_strdup(str);
return GF_OK;
}","[3, 4, 6, 7, 8, 9, 10, 11, 13, 14]","MP4Box is a component of GPAC-2.0.0, which is a widely-used third-party package on RPM Fusion. When MP4Box tries to parse a MP4 file, it calls the function `diST_box_read()` to read from video. In this function, it allocates a buffer `str` with fixed length. However, content read from `bs` is controllable by user, so is the length, which causes a buffer overflow.",gpac,CVE-2022-1441,CWE-125
1043,8779,"static void cstm(JF, js_Ast *stm)
{
js_Ast *target;
int loop, cont, then, end;
emitline(J, F, stm);
switch (stm->type) {
case AST_FUNDEC:
break;
case STM_BLOCK:
cstmlist(J, F, stm->a);
break;
case STM_EMPTY:
if (F->script) {
emitline(J, F, stm);
emit(J, F, OP_POP);
emit(J, F, OP_UNDEF);
}
break;
case STM_VAR:
cvarinit(J, F, stm->a);
break;
case STM_IF:
if (stm->c) {
cexp(J, F, stm->a);
emitline(J, F, stm);
then = emitjump(J, F, OP_JTRUE);
cstm(J, F, stm->c);
emitline(J, F, stm);
end = emitjump(J, F, OP_JUMP);
label(J, F, then);
cstm(J, F, stm->b);
label(J, F, end);
} else {
cexp(J, F, stm->a);
emitline(J, F, stm);
end = emitjump(J, F, OP_JFALSE);
cstm(J, F, stm->b);
label(J, F, end);
}
break;
case STM_DO:
loop = here(J, F);
cstm(J, F, stm->a);
cont = here(J, F);
cexp(J, F, stm->b);
emitline(J, F, stm);
emitjumpto(J, F, OP_JTRUE, loop);
labeljumps(J, F, stm->jumps, here(J,F), cont);
break;
case STM_WHILE:
loop = here(J, F);
cexp(J, F, stm->a);
emitline(J, F, stm);
end = emitjump(J, F, OP_JFALSE);
cstm(J, F, stm->b);
emitline(J, F, stm);
emitjumpto(J, F, OP_JUMP, loop);
label(J, F, end);
labeljumps(J, F, stm->jumps, here(J,F), loop);
break;
case STM_FOR:
case STM_FOR_VAR:
if (stm->type == STM_FOR_VAR) {
cvarinit(J, F, stm->a);
} else {
if (stm->a) {
cexp(J, F, stm->a);
emit(J, F, OP_POP);
}
}
loop = here(J, F);
if (stm->b) {
cexp(J, F, stm->b);
emitline(J, F, stm);
end = emitjump(J, F, OP_JFALSE);
} else {
end = 0;
}
cstm(J, F, stm->d);
cont = here(J, F);
if (stm->c) {
cexp(J, F, stm->c);
emit(J, F, OP_POP);
}
emitline(J, F, stm);
emitjumpto(J, F, OP_JUMP, loop);
if (end)
label(J, F, end);
labeljumps(J, F, stm->jumps, here(J,F), cont);
break;
case STM_FOR_IN:
case STM_FOR_IN_VAR:
cexp(J, F, stm->b);
emitline(J, F, stm);
emit(J, F, OP_ITERATOR);
loop = here(J, F);
{
emitline(J, F, stm);
emit(J, F, OP_NEXTITER);
end = emitjump(J, F, OP_JFALSE);
cassignforin(J, F, stm);
if (F->script) {
emit(J, F, OP_ROT2);
cstm(J, F, stm->c);
emit(J, F, OP_ROT2);
} else {
cstm(J, F, stm->c);
}
emitline(J, F, stm);
emitjumpto(J, F, OP_JUMP, loop);
}
label(J, F, end);
labeljumps(J, F, stm->jumps, here(J,F), loop);
break;
case STM_SWITCH:
cswitch(J, F, stm->a, stm->b);
labeljumps(J, F, stm->jumps, here(J,F), 0);
break;
case STM_LABEL:
cstm(J, F, stm->b);
while (stm->type == STM_LABEL)
stm = stm->b;
if (!isloop(stm->type) && stm->type != STM_SWITCH)
labeljumps(J, F, stm->jumps, here(J,F), 0);
break;
case STM_BREAK:
if (stm->a) {
checkfutureword(J, F, stm->a);
target = breaktarget(J, F, stm->parent, stm->a->string);
if (!target)
jsC_error(J, stm, ""break label '%s' not found"", stm->a->string);
} else {
target = breaktarget(J, F, stm->parent, NULL);
if (!target)
jsC_error(J, stm, ""unlabelled break must be inside loop or switch"");
}
cexit(J, F, STM_BREAK, stm, target);
emitline(J, F, stm);
addjump(J, F, STM_BREAK, target, emitjump(J, F, OP_JUMP));
break;
case STM_CONTINUE:
if (stm->a) {
checkfutureword(J, F, stm->a);
target = continuetarget(J, F, stm->parent, stm->a->string);
if (!target)
jsC_error(J, stm, ""continue label '%s' not found"", stm->a->string);
} else {
target = continuetarget(J, F, stm->parent, NULL);
if (!target)
jsC_error(J, stm, ""continue must be inside loop"");
}
cexit(J, F, STM_CONTINUE, stm, target);
emitline(J, F, stm);
addjump(J, F, STM_CONTINUE, target, emitjump(J, F, OP_JUMP));
break;
case STM_RETURN:
if (stm->a)
cexp(J, F, stm->a);
else
emit(J, F, OP_UNDEF);
target = returntarget(J, F, stm->parent);
if (!target)
jsC_error(J, stm, ""return not in function"");
cexit(J, F, STM_RETURN, stm, target);
emitline(J, F, stm);
emit(J, F, OP_RETURN);
break;
case STM_THROW:
cexp(J, F, stm->a);
emitline(J, F, stm);
emit(J, F, OP_THROW);
break;
case STM_WITH:
F->lightweight = 0;
if (F->strict)
jsC_error(J, stm->a, ""'with' statements are not allowed in strict mode"");
cexp(J, F, stm->a);
emitline(J, F, stm);
emit(J, F, OP_WITH);
cstm(J, F, stm->b);
emitline(J, F, stm);
emit(J, F, OP_ENDWITH);
break;
case STM_TRY:
emitline(J, F, stm);
if (stm->b && stm->c) {
F->lightweight = 0;
if (stm->d)
ctrycatchfinally(J, F, stm->a, stm->b, stm->c, stm->d);
else
ctrycatch(J, F, stm->a, stm->b, stm->c);
} else {
ctryfinally(J, F, stm->a, stm->d);
}
break;
case STM_DEBUGGER:
emitline(J, F, stm);
emit(J, F, OP_DEBUGGER);
break;
default:
if (F->script) {
emitline(J, F, stm);
emit(J, F, OP_POP);
cexp(J, F, stm);
} else {
cexp(J, F, stm);
emitline(J, F, stm);
emit(J, F, OP_POP);
}
break;
}
}","[48, 59, 89, 113, 117, 124]",Artifex MuJS v1.1.3 was discovered to contain a heap buffer overflow which is caused by conflicting JumpList of nested try/finally statements.,mujs,CVE-2021-45005,CWE-787
1049,3485,"static int read_header(FFV1Context *f)
{
uint8_t state[CONTEXT_SIZE];
int i, j, context_count = -1;
RangeCoder *const c = &f->slice_context[0]->c;
memset(state, 128, sizeof(state));
if (f->version < 2) {
int chroma_planes, chroma_h_shift, chroma_v_shift, transparency, colorspace, bits_per_raw_sample;
unsigned v= get_symbol(c, state, 0);
if (v >= 2) {
av_log(f->avctx, AV_LOG_ERROR, ""invalid version %d in ver01 header\n"", v);
return AVERROR_INVALIDDATA;
}
f->version = v;
f->ac      = f->avctx->coder_type = get_symbol(c, state, 0);
if (f->ac > 1) {
for (i = 1; i < 256; i++)
f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];
}
colorspace          = get_symbol(c, state, 0);
bits_per_raw_sample = f->version > 0 ? get_symbol(c, state, 0) : f->avctx->bits_per_raw_sample;
chroma_planes       = get_rac(c, state);
chroma_h_shift      = get_symbol(c, state, 0);
chroma_v_shift      = get_symbol(c, state, 0);
transparency        = get_rac(c, state);
if (f->plane_count) {
if (colorspace          != f->colorspace                 ||
bits_per_raw_sample != f->avctx->bits_per_raw_sample ||
chroma_planes       != f->chroma_planes              ||
chroma_h_shift      != f->chroma_h_shift             ||
chroma_v_shift      != f->chroma_v_shift             ||
transparency        != f->transparency) {
av_log(f->avctx, AV_LOG_ERROR, ""Invalid change of global parameters\n"");
return AVERROR_INVALIDDATA;
}
}
if (chroma_h_shift > 4U || chroma_v_shift > 4U) {
av_log(f->avctx, AV_LOG_ERROR, ""chroma shift parameters %d %d are invalid\n"",
chroma_h_shift, chroma_v_shift);
return AVERROR_INVALIDDATA;
}
f->colorspace                 = colorspace;
f->avctx->bits_per_raw_sample = bits_per_raw_sample;
f->chroma_planes              = chroma_planes;
f->chroma_h_shift             = chroma_h_shift;
f->chroma_v_shift             = chroma_v_shift;
f->transparency               = transparency;
f->plane_count    = 2 + f->transparency;
}
if (f->colorspace == 0) {
if (f->avctx->skip_alpha) f->transparency = 0;
if (!f->transparency && !f->chroma_planes) {
if (f->avctx->bits_per_raw_sample <= 8)
f->avctx->pix_fmt = AV_PIX_FMT_GRAY8;
else
f->avctx->pix_fmt = AV_PIX_FMT_GRAY16;
} else if (f->avctx->bits_per_raw_sample<=8 && !f->transparency) {
switch(16 * f->chroma_h_shift + f->chroma_v_shift) {
case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P; break;
case 0x01: f->avctx->pix_fmt = AV_PIX_FMT_YUV440P; break;
case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P; break;
case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P; break;
case 0x20: f->avctx->pix_fmt = AV_PIX_FMT_YUV411P; break;
case 0x22: f->avctx->pix_fmt = AV_PIX_FMT_YUV410P; break;
}
} else if (f->avctx->bits_per_raw_sample <= 8 && f->transparency) {
switch(16*f->chroma_h_shift + f->chroma_v_shift) {
case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P; break;
case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P; break;
case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P; break;
}
} else if (f->avctx->bits_per_raw_sample == 9 && !f->transparency) {
f->packed_at_lsb = 1;
switch(16 * f->chroma_h_shift + f->chroma_v_shift) {
case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P9; break;
case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P9; break;
case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P9; break;
}
} else if (f->avctx->bits_per_raw_sample == 9 && f->transparency) {
f->packed_at_lsb = 1;
switch(16 * f->chroma_h_shift + f->chroma_v_shift) {
case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P9; break;
case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P9; break;
case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P9; break;
}
} else if (f->avctx->bits_per_raw_sample == 10 && !f->transparency) {
f->packed_at_lsb = 1;
switch(16 * f->chroma_h_shift + f->chroma_v_shift) {
case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P10; break;
case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P10; break;
case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P10; break;
}
} else if (f->avctx->bits_per_raw_sample == 10 && f->transparency) {
f->packed_at_lsb = 1;
switch(16 * f->chroma_h_shift + f->chroma_v_shift) {
case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P10; break;
case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P10; break;
case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P10; break;
}
} else if (f->avctx->bits_per_raw_sample == 16 && !f->transparency){
switch(16 * f->chroma_h_shift + f->chroma_v_shift) {
case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P16; break;
case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P16; break;
case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P16; break;
}
} else if (f->avctx->bits_per_raw_sample == 16 && f->transparency){
switch(16 * f->chroma_h_shift + f->chroma_v_shift) {
case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P16; break;
case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P16; break;
case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P16; break;
}
}
} else if (f->colorspace == 1) {
if (f->chroma_h_shift || f->chroma_v_shift) {
av_log(f->avctx, AV_LOG_ERROR,
""chroma subsampling not supported in this colorspace\n"");
return AVERROR(ENOSYS);
}
if (     f->avctx->bits_per_raw_sample ==  9)
f->avctx->pix_fmt = AV_PIX_FMT_GBRP9;
else if (f->avctx->bits_per_raw_sample == 10)
f->avctx->pix_fmt = AV_PIX_FMT_GBRP10;
else if (f->avctx->bits_per_raw_sample == 12)
f->avctx->pix_fmt = AV_PIX_FMT_GBRP12;
else if (f->avctx->bits_per_raw_sample == 14)
f->avctx->pix_fmt = AV_PIX_FMT_GBRP14;
else
if (f->transparency) f->avctx->pix_fmt = AV_PIX_FMT_RGB32;
else                 f->avctx->pix_fmt = AV_PIX_FMT_0RGB32;
} else {
av_log(f->avctx, AV_LOG_ERROR, ""colorspace not supported\n"");
return AVERROR(ENOSYS);
}
if (f->avctx->pix_fmt == AV_PIX_FMT_NONE) {
av_log(f->avctx, AV_LOG_ERROR, ""format not supported\n"");
return AVERROR(ENOSYS);
}
av_dlog(f->avctx, ""%d %d %d\n"",
f->chroma_h_shift, f->chroma_v_shift, f->avctx->pix_fmt);
if (f->version < 2) {
context_count = read_quant_tables(c, f->quant_table);
if (context_count < 0) {
av_log(f->avctx, AV_LOG_ERROR, ""read_quant_table error\n"");
return AVERROR_INVALIDDATA;
}
f->slice_count = f->max_slice_count;
} else if (f->version < 3) {
f->slice_count = get_symbol(c, state, 0);
} else {
const uint8_t *p = c->bytestream_end;
for (f->slice_count = 0;
f->slice_count < MAX_SLICES && 3 < p - c->bytestream_start;
f->slice_count++) {
int trailer = 3 + 5*!!f->ec;
int size = AV_RB24(p-trailer);
if (size + trailer > p - c->bytestream_start)
break;
p -= size + trailer;
}
}
if (f->slice_count > (unsigned)MAX_SLICES || f->slice_count <= 0 || f->slice_count > f->max_slice_count) {
av_log(f->avctx, AV_LOG_ERROR, ""slice count %d is invalid (max=%d)\n"", f->slice_count, f->max_slice_count);
return AVERROR_INVALIDDATA;
}
for (j = 0; j < f->slice_count; j++) {
FFV1Context *fs = f->slice_context[j];
fs->ac            = f->ac;
fs->packed_at_lsb = f->packed_at_lsb;
fs->slice_damaged = 0;
if (f->version == 2) {
fs->slice_x      =  get_symbol(c, state, 0)      * f->width ;
fs->slice_y      =  get_symbol(c, state, 0)      * f->height;
fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width  + fs->slice_x;
fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;
fs->slice_x     /= f->num_h_slices;
fs->slice_y     /= f->num_v_slices;
fs->slice_width  = fs->slice_width  / f->num_h_slices - fs->slice_x;
fs->slice_height = fs->slice_height / f->num_v_slices - fs->slice_y;
if ((unsigned)fs->slice_width  > f->width ||
(unsigned)fs->slice_height > f->height)
return AVERROR_INVALIDDATA;
if (   (unsigned)fs->slice_x + (uint64_t)fs->slice_width  > f->width
|| (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height)
return AVERROR_INVALIDDATA;
}
for (i = 0; i < f->plane_count; i++) {
PlaneContext *const p = &fs->plane[i];
if (f->version == 2) {
int idx = get_symbol(c, state, 0);
if (idx > (unsigned)f->quant_table_count) {
av_log(f->avctx, AV_LOG_ERROR,
""quant_table_index out of range\n"");
return AVERROR_INVALIDDATA;
}
p->quant_table_index = idx;
memcpy(p->quant_table, f->quant_tables[idx],
sizeof(p->quant_table));
context_count = f->context_count[idx];
} else {
memcpy(p->quant_table, f->quant_table, sizeof(p->quant_table));
}
if (f->version <= 2) {
av_assert0(context_count >= 0);
if (p->context_count < context_count) {
av_freep(&p->state);
av_freep(&p->vlc_state);
}
p->context_count = context_count;
}
}
}
return 0;
}",[152],"The read_header function in libavcodec/ffv1dec.c in FFmpeg 2.4 and 3.3.4 and possibly earlier allows remote attackers to have unspecified impact via a crafted MP4 file, which triggers an out-of-bounds read.",FFmpeg,CVE-2017-15672,CWE-125
1052,5802,"parse_exp(Node** np, PToken* tok, int term, UChar** src, UChar* end,
ScanEnv* env, int group_head)
{
int r, len, group = 0;
Node* qn;
Node** tp;
*np = NULL;
if (tok->type == (enum TokenSyms )term)
goto end_of_token;
switch (tok->type) {
case TK_ALT:
case TK_EOT:
end_of_token:
*np = node_new_empty();
CHECK_NULL_RETURN_MEMERR(*np);
return tok->type;
break;
case TK_SUBEXP_OPEN:
r = parse_bag(np, tok, TK_SUBEXP_CLOSE, src, end, env);
if (r < 0) return r;
if (r == 1) {
if (group_head == 0)
group = 1;
else {
Node* target = *np;
*np = node_new_group(target);
if (IS_NULL(*np)) {
onig_node_free(target);
return ONIGERR_MEMORY;
}
group = 2;
}
}
else if (r == 2) {
Node* target;
OnigOptionType prev = env->options;
env->options = BAG_(*np)->o.options;
r = fetch_token(tok, src, end, env);
if (r < 0) return r;
r = parse_subexp(&target, tok, term, src, end, env, 0);
env->options = prev;
if (r < 0) {
onig_node_free(target);
return r;
}
NODE_BODY(*np) = target;
return tok->type;
}
break;
case TK_SUBEXP_CLOSE:
if (! IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_UNMATCHED_CLOSE_SUBEXP))
return ONIGERR_UNMATCHED_CLOSE_PARENTHESIS;
if (tok->escaped) goto tk_raw_byte;
else goto tk_byte;
break;
case TK_STRING:
tk_byte:
{
*np = node_new_str(tok->backp, *src);
CHECK_NULL_RETURN_MEMERR(*np);
while (1) {
r = fetch_token(tok, src, end, env);
if (r < 0) return r;
if (r != TK_STRING) break;
r = onig_node_str_cat(*np, tok->backp, *src);
if (r < 0) return r;
}
string_end:
tp = np;
goto repeat;
}
break;
case TK_RAW_BYTE:
tk_raw_byte:
{
*np = node_new_str_raw_char((UChar )tok->u.c);
CHECK_NULL_RETURN_MEMERR(*np);
len = 1;
while (1) {
if (len >= ONIGENC_MBC_MINLEN(env->enc)) {
if (len == enclen(env->enc, STR_(*np)->s)) {
r = fetch_token(tok, src, end, env);
goto tk_raw_byte_end;
}
}
r = fetch_token(tok, src, end, env);
if (r < 0) return r;
if (r != TK_RAW_BYTE)
return ONIGERR_TOO_SHORT_MULTI_BYTE_STRING;
r = node_str_cat_char(*np, (UChar )tok->u.c);
if (r < 0) return r;
len++;
}
tk_raw_byte_end:
if (! ONIGENC_IS_VALID_MBC_STRING(env->enc, STR_(*np)->s, STR_(*np)->end))
return ONIGERR_INVALID_WIDE_CHAR_VALUE;
NODE_STRING_CLEAR_RAW(*np);
goto string_end;
}
break;
case TK_CODE_POINT:
{
UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN];
len = ONIGENC_CODE_TO_MBC(env->enc, tok->u.code, buf);
if (len < 0) return len;
#ifdef NUMBERED_CHAR_IS_NOT_CASE_AMBIG
*np = node_new_str_raw(buf, buf + len);
#else
*np = node_new_str(buf, buf + len);
#endif
CHECK_NULL_RETURN_MEMERR(*np);
}
break;
case TK_QUOTE_OPEN:
{
OnigCodePoint end_op[2];
UChar *qstart, *qend, *nextp;
end_op[0] = (OnigCodePoint )MC_ESC(env->syntax);
end_op[1] = (OnigCodePoint )'E';
qstart = *src;
qend = find_str_position(end_op, 2, qstart, end, &nextp, env->enc);
if (IS_NULL(qend)) {
nextp = qend = end;
}
*np = node_new_str(qstart, qend);
CHECK_NULL_RETURN_MEMERR(*np);
*src = nextp;
}
break;
case TK_CHAR_TYPE:
{
switch (tok->u.prop.ctype) {
case ONIGENC_CTYPE_WORD:
*np = node_new_ctype(tok->u.prop.ctype, tok->u.prop.not, env->options);
CHECK_NULL_RETURN_MEMERR(*np);
break;
case ONIGENC_CTYPE_SPACE:
case ONIGENC_CTYPE_DIGIT:
case ONIGENC_CTYPE_XDIGIT:
{
CClassNode* cc;
*np = node_new_cclass();
CHECK_NULL_RETURN_MEMERR(*np);
cc = CCLASS_(*np);
add_ctype_to_cc(cc, tok->u.prop.ctype, 0, env);
if (tok->u.prop.not != 0) NCCLASS_SET_NOT(cc);
}
break;
default:
return ONIGERR_PARSER_BUG;
break;
}
}
break;
case TK_CHAR_PROPERTY:
r = parse_char_property(np, tok, src, end, env);
if (r != 0) return r;
break;
case TK_CC_OPEN:
{
CClassNode* cc;
r = parse_char_class(np, tok, src, end, env);
if (r != 0) return r;
cc = CCLASS_(*np);
if (IS_IGNORECASE(env->options)) {
IApplyCaseFoldArg iarg;
iarg.env      = env;
iarg.cc       = cc;
iarg.alt_root = NULL_NODE;
iarg.ptail    = &(iarg.alt_root);
r = ONIGENC_APPLY_ALL_CASE_FOLD(env->enc, env->case_fold_flag,
i_apply_case_fold, &iarg);
if (r != 0) {
onig_node_free(iarg.alt_root);
return r;
}
if (IS_NOT_NULL(iarg.alt_root)) {
Node* work = onig_node_new_alt(*np, iarg.alt_root);
if (IS_NULL(work)) {
onig_node_free(iarg.alt_root);
return ONIGERR_MEMORY;
}
*np = work;
}
}
}
break;
case TK_ANYCHAR:
*np = node_new_anychar();
CHECK_NULL_RETURN_MEMERR(*np);
break;
case TK_ANYCHAR_ANYTIME:
*np = node_new_anychar();
CHECK_NULL_RETURN_MEMERR(*np);
qn = node_new_quantifier(0, INFINITE_REPEAT, 0);
CHECK_NULL_RETURN_MEMERR(qn);
NODE_BODY(qn) = *np;
*np = qn;
break;
case TK_BACKREF:
len = tok->u.backref.num;
*np = node_new_backref(len,
(len > 1 ? tok->u.backref.refs : &(tok->u.backref.ref1)),
tok->u.backref.by_name,
#ifdef USE_BACKREF_WITH_LEVEL
tok->u.backref.exist_level,
tok->u.backref.level,
#endif
env);
CHECK_NULL_RETURN_MEMERR(*np);
break;
#ifdef USE_CALL
case TK_CALL:
{
int gnum = tok->u.call.gnum;
*np = node_new_call(tok->u.call.name, tok->u.call.name_end,
gnum, tok->u.call.by_number);
CHECK_NULL_RETURN_MEMERR(*np);
env->num_call++;
if (tok->u.call.by_number != 0 && gnum == 0) {
env->has_call_zero = 1;
}
}
break;
#endif
case TK_ANCHOR:
{
int ascii_mode =
IS_WORD_ASCII(env->options) && IS_WORD_ANCHOR_TYPE(tok->u.anchor) ? 1 : 0;
*np = onig_node_new_anchor(tok->u.anchor, ascii_mode);
CHECK_NULL_RETURN_MEMERR(*np);
}
break;
case TK_REPEAT:
case TK_INTERVAL:
if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_CONTEXT_INDEP_REPEAT_OPS)) {
if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_CONTEXT_INVALID_REPEAT_OPS))
return ONIGERR_TARGET_OF_REPEAT_OPERATOR_NOT_SPECIFIED;
else {
*np = node_new_empty();
CHECK_NULL_RETURN_MEMERR(*np);
}
}
else {
goto tk_byte;
}
break;
case TK_KEEP:
r = node_new_keep(np, env);
if (r < 0) return r;
break;
case TK_GENERAL_NEWLINE:
r = node_new_general_newline(np, env);
if (r < 0) return r;
break;
case TK_NO_NEWLINE:
r = node_new_no_newline(np, env);
if (r < 0) return r;
break;
case TK_TRUE_ANYCHAR:
r = node_new_true_anychar(np, env);
if (r < 0) return r;
break;
case TK_TEXT_SEGMENT:
r = make_text_segment(np, env);
if (r < 0) return r;
break;
default:
return ONIGERR_PARSER_BUG;
break;
}
{
tp = np;
re_entry:
r = fetch_token(tok, src, end, env);
if (r < 0) return r;
repeat:
if (r == TK_REPEAT || r == TK_INTERVAL) {
Node* target;
if (is_invalid_quantifier_target(*tp))
return ONIGERR_TARGET_OF_REPEAT_OPERATOR_INVALID;
qn = node_new_quantifier(tok->u.repeat.lower, tok->u.repeat.upper,
r == TK_INTERVAL);
CHECK_NULL_RETURN_MEMERR(qn);
QUANT_(qn)->greedy = tok->u.repeat.greedy;
if (group == 2) {
target = node_drop_group(*tp);
*tp = NULL_NODE;
}
else {
target = *tp;
}
r = set_quantifier(qn, target, group, env);
if (r < 0) {
onig_node_free(qn);
return r;
}
if (tok->u.repeat.possessive != 0) {
Node* en;
en = node_new_bag(BAG_STOP_BACKTRACK);
if (IS_NULL(en)) {
onig_node_free(qn);
return ONIGERR_MEMORY;
}
NODE_BODY(en) = qn;
qn = en;
}
if (r == 0) {
*tp = qn;
}
else if (r == 1) {
onig_node_free(qn);
*tp = target;
}
else if (r == 2) {
Node *tmp;
*tp = node_new_list(*tp, NULL);
if (IS_NULL(*tp)) {
onig_node_free(qn);
return ONIGERR_MEMORY;
}
tmp = NODE_CDR(*tp) = node_new_list(qn, NULL);
if (IS_NULL(tmp)) {
onig_node_free(qn);
return ONIGERR_MEMORY;
}
tp = &(NODE_CAR(tmp));
}
group = 0;
goto re_entry;
}
}
return r;
}","[4, 7, 10, 282]",Oniguruma before 6.9.3 allows Stack Exhaustion in regcomp.c because of recursion in regparse.c.,oniguruma,CVE-2019-16163,CWE-674
1057,5709,"double GetGPMFSampleRateAndTimes(size_t handle, GPMF_stream *gs, double rate, uint32_t index, double *in, double *out)
{
mp4object *mp4 = (mp4object *)handle;
if (mp4 == NULL) return 0.0;
uint32_t key, insamples;
uint32_t repeat, outsamples;
GPMF_stream find_stream;
if (gs == NULL || mp4->metaoffsets == 0 || mp4->indexcount == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in == NULL || out == NULL) return 0.0;
key = GPMF_Key(gs);
repeat = GPMF_Repeat(gs);
if (rate == 0.0)
rate = GetGPMFSampleRate(handle, key, GPMF_SAMPLE_RATE_FAST);
if (rate == 0.0)
{
*in = *out = 0.0;
return 0.0;
}
GPMF_CopyState(gs, &find_stream);
if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))
{
outsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream));
insamples = outsamples - repeat;
*in = ((double)insamples / (double)rate);
*out = ((double)outsamples / (double)rate);
}
else
{
*in = ((double)index * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);
*out = ((double)(index + 1) * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);
}
return rate;
}","[5, 6, 7, 8, 9, 10, 11, 12, 13, 15, 16, 18, 19, 21, 22, 23, 24, 26, 28, 29]",GoPro GPMF-parser 1.2.2 has a heap-based buffer over-read (4 bytes) in GPMF_Next in GPMF_parser.c.,gpmf-parser,CVE-2019-15146,CWE-125
1060,4098,"fetch_token_in_cc(OnigToken* tok, UChar** src, UChar* end, ScanEnv* env)
{
int num;
OnigCodePoint c, c2;
OnigSyntaxType* syn = env->syntax;
OnigEncoding enc = env->enc;
UChar* prev;
UChar* p = *src;
PFETCH_READY;
if (PEND) {
tok->type = TK_EOT;
return tok->type;
}
PFETCH(c);
tok->type = TK_CHAR;
tok->base = 0;
tok->u.c  = c;
tok->escaped = 0;
if (c == ']') {
tok->type = TK_CC_CLOSE;
}
else if (c == '-') {
tok->type = TK_CC_RANGE;
}
else if (c == MC_ESC(syn)) {
if (! IS_SYNTAX_BV(syn, ONIG_SYN_BACKSLASH_ESCAPE_IN_CC))
goto end;
if (PEND) return ONIGERR_END_PATTERN_AT_ESCAPE;
PFETCH(c);
tok->escaped = 1;
tok->u.c = c;
switch (c) {
case 'w':
tok->type = TK_CHAR_TYPE;
tok->u.prop.ctype = ONIGENC_CTYPE_WORD;
tok->u.prop.not   = 0;
break;
case 'W':
tok->type = TK_CHAR_TYPE;
tok->u.prop.ctype = ONIGENC_CTYPE_WORD;
tok->u.prop.not   = 1;
break;
case 'd':
tok->type = TK_CHAR_TYPE;
tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;
tok->u.prop.not   = 0;
break;
case 'D':
tok->type = TK_CHAR_TYPE;
tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;
tok->u.prop.not   = 1;
break;
case 's':
tok->type = TK_CHAR_TYPE;
tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;
tok->u.prop.not   = 0;
break;
case 'S':
tok->type = TK_CHAR_TYPE;
tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;
tok->u.prop.not   = 1;
break;
case 'h':
if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;
tok->type = TK_CHAR_TYPE;
tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;
tok->u.prop.not   = 0;
break;
case 'H':
if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;
tok->type = TK_CHAR_TYPE;
tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;
tok->u.prop.not   = 1;
break;
case 'p':
case 'P':
if (PEND) break;
c2 = PPEEK;
if (c2 == '{' &&
IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY)) {
PINC;
tok->type = TK_CHAR_PROPERTY;
tok->u.prop.not = (c == 'P' ? 1 : 0);
if (!PEND && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT)) {
PFETCH(c2);
if (c2 == '^') {
tok->u.prop.not = (tok->u.prop.not == 0 ? 1 : 0);
}
else
PUNFETCH;
}
}
break;
case 'x':
if (PEND) break;
prev = p;
if (PPEEK_IS('{') && IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_BRACE_HEX8)) {
PINC;
num = scan_unsigned_hexadecimal_number(&p, end, 8, enc);
if (num < 0) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;
if (!PEND) {
c2 = PPEEK;
if (ONIGENC_IS_CODE_XDIGIT(enc, c2))
return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE;
}
if (p > prev + enclen(enc, prev) && !PEND && (PPEEK_IS('}'))) {
PINC;
tok->type   = TK_CODE_POINT;
tok->base   = 16;
tok->u.code = (OnigCodePoint )num;
}
else {
p = prev;
}
}
else if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_HEX2)) {
num = scan_unsigned_hexadecimal_number(&p, end, 2, enc);
if (num < 0) return ONIGERR_TOO_BIG_NUMBER;
if (p == prev) {
num = 0;
}
tok->type = TK_RAW_BYTE;
tok->base = 16;
tok->u.c  = num;
}
break;
case 'u':
if (PEND) break;
prev = p;
if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_U_HEX4)) {
num = scan_unsigned_hexadecimal_number(&p, end, 4, enc);
if (num < 0) return ONIGERR_TOO_BIG_NUMBER;
if (p == prev) {
num = 0;
}
tok->type   = TK_CODE_POINT;
tok->base   = 16;
tok->u.code = (OnigCodePoint )num;
}
break;
case '0':
case '1': case '2': case '3': case '4': case '5': case '6': case '7':
if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_OCTAL3)) {
PUNFETCH;
prev = p;
num = scan_unsigned_octal_number(&p, end, 3, enc);
if (num < 0) return ONIGERR_TOO_BIG_NUMBER;
if (p == prev) {
num = 0;
}
tok->type = TK_RAW_BYTE;
tok->base = 8;
tok->u.c  = num;
}
break;
default:
PUNFETCH;
num = fetch_escaped_value(&p, end, env, &c2);
if (num < 0) return num;
if (tok->u.c != c2) {
tok->u.code = c2;
tok->type   = TK_CODE_POINT;
}
break;
}
}
else if (c == '[') {
if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_POSIX_BRACKET) && (PPEEK_IS(':'))) {
OnigCodePoint send[] = { (OnigCodePoint )':', (OnigCodePoint )']' };
tok->backp = p;
PINC;
if (str_exist_check_with_esc(send, 2, p, end,
(OnigCodePoint )']', enc, syn)) {
tok->type = TK_POSIX_BRACKET_OPEN;
}
else {
PUNFETCH;
goto cc_in_cc;
}
}
else {
cc_in_cc:
if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_CCLASS_SET_OP)) {
tok->type = TK_CC_CC_OPEN;
}
else {
CC_ESC_WARN(env, (UChar* )""["");
}
}
}
else if (c == '&') {
if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_CCLASS_SET_OP) &&
!PEND && (PPEEK_IS('&'))) {
PINC;
tok->type = TK_CC_AND;
}
}
end:
*src = p;
return tok->type;
}",[147],"An issue was discovered in Oniguruma 6.2.0, as used in Oniguruma-mod in Ruby through 2.4.1 and mbstring in PHP through 7.1.5. A heap out-of-bounds write or read occurs in next_state_val() during regular expression compilation. Octal numbers larger than 0xff are not handled correctly in fetch_token() and fetch_token_in_cc(). A malformed regular expression containing an octal number in the form of '\700' would produce an invalid code point value larger than 0xff in next_state_val(), resulting in an out-of-bounds write memory corruption.",oniguruma,CVE-2017-9226,CWE-787
1071,8128,"static Bool hevc_parse_vps_extension(HEVC_VPS *vps, GF_BitStream *bs)
{
u8 splitting_flag, vps_nuh_layer_id_present_flag, view_id_len;
u32 i, j, num_scalability_types, num_add_olss, num_add_layer_set, num_indepentdent_layers, nb_bits, default_output_layer_idc = 0;
u8 dimension_id_len[16], dim_bit_offset[16];
u8                          NumLayerSets,                                           rep_format_idx_present_flag, ols_ids_to_ls_idx;
u8 layer_set_idx_for_ols_minus1[MAX_LHVC_LAYERS];
u8 nb_output_layers_in_output_layer_set[MAX_LHVC_LAYERS + 1];
u8 ols_highest_output_layer_id[MAX_LHVC_LAYERS + 1];
u32 k, d, r, p, iNuhLId, jNuhLId;
u8 num_direct_ref_layers[64], num_pred_layers[64], num_layers_in_tree_partition[MAX_LHVC_LAYERS];
u8 dependency_flag[MAX_LHVC_LAYERS][MAX_LHVC_LAYERS], id_pred_layers[64][MAX_LHVC_LAYERS];
u8 layer_id_in_list_flag[64];
Bool OutputLayerFlag[MAX_LHVC_LAYERS][MAX_LHVC_LAYERS];
vps->vps_extension_found = 1;
if ((vps->max_layers > 1) && vps->base_layer_internal_flag)
hevc_profile_tier_level(bs, 0, vps->max_sub_layers - 1, &vps->ext_ptl[0], 0);
splitting_flag = gf_bs_read_int_log(bs, 1, ""splitting_flag"");
num_scalability_types = 0;
for (i = 0; i < 16; i++) {
vps->scalability_mask[i] = gf_bs_read_int_log_idx(bs, 1, ""scalability_mask"", i);
num_scalability_types += vps->scalability_mask[i];
}
if (num_scalability_types >= 16) {
num_scalability_types = 16;
}
dimension_id_len[0] = 0;
for (i = 0; i < (num_scalability_types - splitting_flag); i++) {
dimension_id_len[i] = 1 + gf_bs_read_int_log_idx(bs, 3, ""dimension_id_len_minus1"", i);
}
if (splitting_flag) {
for (i = 0; i < num_scalability_types; i++) {
dim_bit_offset[i] = 0;
for (j = 0; j < i; j++)
dim_bit_offset[i] += dimension_id_len[j];
}
dimension_id_len[num_scalability_types - 1] = 1 + (5 - dim_bit_offset[num_scalability_types - 1]);
dim_bit_offset[num_scalability_types] = 6;
}
vps_nuh_layer_id_present_flag = gf_bs_read_int_log(bs, 1, ""vps_nuh_layer_id_present_flag"");
vps->layer_id_in_nuh[0] = 0;
vps->layer_id_in_vps[0] = 0;
for (i = 1; i < vps->max_layers; i++) {
if (vps_nuh_layer_id_present_flag) {
vps->layer_id_in_nuh[i] = gf_bs_read_int_log_idx(bs, 6, ""layer_id_in_nuh"", i);
}
else {
vps->layer_id_in_nuh[i] = i;
}
vps->layer_id_in_vps[vps->layer_id_in_nuh[i]] = i;
if (!splitting_flag) {
for (j = 0; j < num_scalability_types; j++) {
vps->dimension_id[i][j] = gf_bs_read_int_log_idx2(bs, dimension_id_len[j], ""dimension_id"", i, j);
}
}
}
if (splitting_flag) {
for (i = 0; i < vps->max_layers; i++)
for (j = 0; j < num_scalability_types; j++)
vps->dimension_id[i][j] = ((vps->layer_id_in_nuh[i] & ((1 << dim_bit_offset[j + 1]) - 1)) >> dim_bit_offset[j]);
}
else {
for (j = 0; j < num_scalability_types; j++)
vps->dimension_id[0][j] = 0;
}
view_id_len = gf_bs_read_int_log(bs, 4, ""view_id_len"");
if (view_id_len > 0) {
for (i = 0; i < lhvc_get_num_views(vps); i++) {
gf_bs_read_int_log_idx(bs, view_id_len, ""view_id_val"", i);
}
}
for (i = 1; i < vps->max_layers; i++) {
for (j = 0; j < i; j++) {
vps->direct_dependency_flag[i][j] = gf_bs_read_int_log_idx(bs, 1, ""direct_dependency_flag"", i);
}
}
for (i = 0; i < MAX_LHVC_LAYERS; i++) {
if (i >= vps->max_layers) break;
for (j = 0; j < vps->max_layers; j++) {
dependency_flag[i][j] = vps->direct_dependency_flag[i][j];
for (k = 0; k < i; k++)
if (vps->direct_dependency_flag[i][k] && vps->direct_dependency_flag[k][j])
dependency_flag[i][j] = 1;
}
}
for (i = 0; i < vps->max_layers; i++) {
iNuhLId = vps->layer_id_in_nuh[i];
d = r = p = 0;
for (j = 0; j < vps->max_layers; j++) {
jNuhLId = vps->layer_id_in_nuh[j];
if (vps->direct_dependency_flag[i][j]) {
d++;
}
if (dependency_flag[i][j]) {
r++;
}
if (dependency_flag[j][i])
id_pred_layers[iNuhLId][p++] = jNuhLId;
}
num_direct_ref_layers[iNuhLId] = d;
num_pred_layers[iNuhLId] = p;
}
memset(layer_id_in_list_flag, 0, 64 * sizeof(u8));
k = 0;
for (i = 0; i < vps->max_layers; i++) {
iNuhLId = vps->layer_id_in_nuh[i];
if (!num_direct_ref_layers[iNuhLId]) {
u32 h = 1;
for (j = 0; j < num_pred_layers[iNuhLId]; j++) {
u32 predLId = id_pred_layers[iNuhLId][j];
if (!layer_id_in_list_flag[predLId]) {
layer_id_in_list_flag[predLId] = 1;
}
}
num_layers_in_tree_partition[k++] = h;
}
}
num_indepentdent_layers = k;
num_add_layer_set = 0;
if (num_indepentdent_layers > 1)
num_add_layer_set = gf_bs_read_ue_log(bs, ""num_add_layer_set"");
for (i = 0; i < num_add_layer_set; i++)
for (j = 1; j < num_indepentdent_layers; j++) {
nb_bits = 1;
while ((1 << nb_bits) < (num_layers_in_tree_partition[j] + 1))
nb_bits++;
gf_bs_read_int_log_idx2(bs, nb_bits, ""highest_layer_idx_plus1"", i, j);
}
if (gf_bs_read_int_log(bs, 1, ""vps_sub_layers_max_minus1_present_flag"")) {
for (i = 0; i < vps->max_layers; i++) {
gf_bs_read_int_log_idx(bs, 3, ""sub_layers_vps_max_minus1"", i);
}
}
if (gf_bs_read_int_log(bs, 1, ""max_tid_ref_present_flag"")) {
for (i = 0; i < (vps->max_layers - 1); i++) {
for (j = i + 1; j < vps->max_layers; j++) {
if (vps->direct_dependency_flag[j][i])
gf_bs_read_int_log_idx2(bs, 3, ""max_tid_il_ref_pics_plus1"", i, j);
}
}
}
gf_bs_read_int_log(bs, 1, ""default_ref_layers_active_flag"");
vps->num_profile_tier_level = 1 + gf_bs_read_ue_log(bs, ""num_profile_tier_level"");
if (vps->num_profile_tier_level > MAX_LHVC_LAYERS) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[HEVC] Wrong number of PTLs in VPS %d\n"", vps->num_profile_tier_level));
vps->num_profile_tier_level = 1;
return GF_FALSE;
}
for (i = vps->base_layer_internal_flag ? 2 : 1; i < vps->num_profile_tier_level; i++) {
Bool vps_profile_present_flag = gf_bs_read_int_log_idx(bs, 1, ""vps_profile_present_flag"", i);
hevc_profile_tier_level(bs, vps_profile_present_flag, vps->max_sub_layers - 1, &vps->ext_ptl[i - 1], i-1);
}
NumLayerSets = vps->num_layer_sets + num_add_layer_set;
num_add_olss = 0;
if (NumLayerSets > 1) {
num_add_olss = gf_bs_read_ue_log(bs, ""num_add_olss"");
default_output_layer_idc = gf_bs_read_int_log(bs, 2, ""default_output_layer_idc"");
default_output_layer_idc = default_output_layer_idc < 2 ? default_output_layer_idc : 2;
}
vps->num_output_layer_sets = num_add_olss + NumLayerSets;
layer_set_idx_for_ols_minus1[0] = 1;
vps->output_layer_flag[0][0] = 1;
for (i = 0; i < vps->num_output_layer_sets; i++) {
if ((NumLayerSets > 2) && (i >= NumLayerSets)) {
nb_bits = 1;
while ((1 << nb_bits) < (NumLayerSets - 1))
nb_bits++;
layer_set_idx_for_ols_minus1[i] = gf_bs_read_int_log_idx(bs, nb_bits, ""layer_set_idx_for_ols_minus1"", i);
}
else
layer_set_idx_for_ols_minus1[i] = 0;
ols_ids_to_ls_idx = i < NumLayerSets ? i : layer_set_idx_for_ols_minus1[i] + 1;
if ((i > (vps->num_layer_sets - 1)) || (default_output_layer_idc == 2)) {
for (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++)
vps->output_layer_flag[i][j] = gf_bs_read_int_log_idx2(bs, 1, ""output_layer_flag"", i, j);
}
if ((default_output_layer_idc == 0) || (default_output_layer_idc == 1)) {
for (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {
if ((default_output_layer_idc == 0) || (vps->LayerSetLayerIdList[i][j] == vps->LayerSetLayerIdListMax[i]))
OutputLayerFlag[i][j] = GF_TRUE;
else
OutputLayerFlag[i][j] = GF_FALSE;
}
}
for (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {
if (OutputLayerFlag[i][j]) {
u32 curLayerID;
vps->necessary_layers_flag[i][j] = GF_TRUE;
curLayerID = vps->LayerSetLayerIdList[i][j];
for (k = 0; k < j; k++) {
u32 refLayerId = vps->LayerSetLayerIdList[i][k];
if (dependency_flag[vps->layer_id_in_vps[curLayerID]][vps->layer_id_in_vps[refLayerId]])
vps->necessary_layers_flag[i][k] = GF_TRUE;
}
}
}
vps->num_necessary_layers[i] = 0;
for (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {
if (vps->necessary_layers_flag[i][j])
vps->num_necessary_layers[i] += 1;
}
if (i == 0) {
if (vps->base_layer_internal_flag) {
if (vps->max_layers > 1)
vps->profile_tier_level_idx[0][0] = 1;
else
vps->profile_tier_level_idx[0][0] = 0;
}
continue;
}
nb_bits = 1;
while ((u32)(1 << nb_bits) < vps->num_profile_tier_level)
nb_bits++;
for (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++)
if (vps->necessary_layers_flag[i][j] && vps->num_profile_tier_level)
vps->profile_tier_level_idx[i][j] = gf_bs_read_int_log_idx2(bs, nb_bits, ""profile_tier_level_idx"", i, j);
else
vps->profile_tier_level_idx[i][j] = 0;
nb_output_layers_in_output_layer_set[i] = 0;
for (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {
nb_output_layers_in_output_layer_set[i] += OutputLayerFlag[i][j];
if (OutputLayerFlag[i][j]) {
ols_highest_output_layer_id[i] = vps->LayerSetLayerIdList[ols_ids_to_ls_idx][j];
}
}
if (nb_output_layers_in_output_layer_set[i] == 1 && ols_highest_output_layer_id[i] > 0)
vps->alt_output_layer_flag[i] = gf_bs_read_int_log_idx(bs, 1, ""alt_output_layer_flag"", i);
}
vps->num_rep_formats = 1 + gf_bs_read_ue_log(bs, ""num_rep_formats_minus1"");
if (vps->num_rep_formats > 16) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[HEVC] Wrong number of rep formats in VPS %d\n"", vps->num_rep_formats));
vps->num_rep_formats = 0;
return GF_FALSE;
}
for (i = 0; i < vps->num_rep_formats; i++) {
lhvc_parse_rep_format(&vps->rep_formats[i], bs, i);
}
if (vps->num_rep_formats > 1)
rep_format_idx_present_flag = gf_bs_read_int_log(bs, 1, ""rep_format_idx_present_flag"");
else
rep_format_idx_present_flag = 0;
vps->rep_format_idx[0] = 0;
nb_bits = 1;
while ((u32)(1 << nb_bits) < vps->num_rep_formats)
nb_bits++;
for (i = vps->base_layer_internal_flag ? 1 : 0; i < vps->max_layers; i++) {
if (rep_format_idx_present_flag) {
vps->rep_format_idx[i] = gf_bs_read_int_log_idx(bs, nb_bits, ""rep_format_idx"", i);
}
else {
vps->rep_format_idx[i] = i < vps->num_rep_formats - 1 ? i : vps->num_rep_formats - 1;
}
}
return GF_TRUE;
}",[161],Stack buffer overflow in the hevc_parse_vps_extension function in MP4Box in GPAC 1.0.1 allows attackers to cause a denial of service or execute arbitrary code via a crafted file.,gpac,CVE-2021-33362,CWE-787
32,181886," int bmp_validate(jas_stream_t *in)
  {
  	int n;
  	int i;
	uchar buf[2];
 	jas_uchar buf[2];
  	assert(JAS_STREAM_MAXPUTBACK >= 2);
 	if ((n = jas_stream_read(in, (char *) buf, 2)) < 0) {
 		return -1;
 	}
 	for (i = n - 1; i >= 0; --i) {
 		if (jas_stream_ungetc(in, buf[i]) == EOF) {
 			return -1;
 		}
 	}
 	if (n < 2) {
 		return -1;
 	}
 	if (buf[0] == (BMP_MAGIC & 0xff) && buf[1] == (BMP_MAGIC >> 8)) {
 		return 0;
 	}
 	return -1;
 }","[5, 6]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
51,177804,"  static void build_l4proto_tcp(const struct nf_conntrack *ct, struct nethdr *n)
  {
	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
		      sizeof(struct nfct_attr_grp_port));
  	if (!nfct_attr_is_set(ct, ATTR_TCP_STATE))
  		return;
 	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
 		      sizeof(struct nfct_attr_grp_port));
  	ct_build_u8(ct, ATTR_TCP_STATE, n, NTA_TCP_STATE);
  	if (CONFIG(sync).tcp_window_tracking) {
  		ct_build_u8(ct, ATTR_TCP_WSCALE_ORIG, n, NTA_TCP_WSCALE_ORIG);
 		ct_build_u8(ct, ATTR_TCP_WSCALE_REPL, n, NTA_TCP_WSCALE_REPL);
 	}
 }","[3, 4, 7, 8]","conntrackd in conntrack-tools 1.4.2 and earlier does not ensure that the optional kernel modules are loaded before using them, which allows remote attackers to cause a denial of service (crash) via a (1) DCCP, (2) SCTP, or (3) ICMPv6 packet.",netfilter,CVE-2015-6496,CWE-17
53,179568," hstore_from_array(PG_FUNCTION_ARGS)
 {
 	ArrayType  *in_array = PG_GETARG_ARRAYTYPE_P(0);
 	int			ndims = ARR_NDIM(in_array);
 	int			count;
 	int32		buflen;
 	HStore	   *out;
 	Pairs	   *pairs;
 	Datum	   *in_datums;
 	bool	   *in_nulls;
 	int			in_count;
 	int			i;
 	Assert(ARR_ELEMTYPE(in_array) == TEXTOID);
 	switch (ndims)
 	{
 		case 0:
 			out = hstorePairs(NULL, 0, 0);
 			PG_RETURN_POINTER(out);
 		case 1:
 			if ((ARR_DIMS(in_array)[0]) % 2)
 				ereport(ERROR,
 						(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),
 						 errmsg(""array must have even number of elements"")));
 			break;
 		case 2:
 			if ((ARR_DIMS(in_array)[1]) != 2)
 				ereport(ERROR,
 						(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),
 						 errmsg(""array must have two columns"")));
 			break;
 		default:
 			ereport(ERROR,
 					(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),
 					 errmsg(""wrong number of array subscripts"")));
 	}
 	deconstruct_array(in_array,
 					  TEXTOID, -1, false, 'i',
 					  &in_datums, &in_nulls, &in_count);
  	count = in_count / 2;
 	if (count > MaxAllocSize / sizeof(Pairs))
 		ereport(ERROR,
 				(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),
 			  errmsg(""number of pairs (%d) exceeds the maximum allowed (%d)"",
 					 count, (int) (MaxAllocSize / sizeof(Pairs)))));
  	pairs = palloc(count * sizeof(Pairs));
  	for (i = 0; i < count; ++i)
 	{
 		if (in_nulls[i * 2])
 			ereport(ERROR,
 					(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),
 					 errmsg(""null value not allowed for hstore key"")));
 		if (in_nulls[i * 2 + 1])
 		{
 			pairs[i].key = VARDATA_ANY(in_datums[i * 2]);
 			pairs[i].val = NULL;
 			pairs[i].keylen = hstoreCheckKeyLen(VARSIZE_ANY_EXHDR(in_datums[i * 2]));
 			pairs[i].vallen = 4;
 			pairs[i].isnull = true;
 			pairs[i].needfree = false;
 		}
 		else
 		{
 			pairs[i].key = VARDATA_ANY(in_datums[i * 2]);
 			pairs[i].val = VARDATA_ANY(in_datums[i * 2 + 1]);
 			pairs[i].keylen = hstoreCheckKeyLen(VARSIZE_ANY_EXHDR(in_datums[i * 2]));
 			pairs[i].vallen = hstoreCheckValLen(VARSIZE_ANY_EXHDR(in_datums[i * 2 + 1]));
 			pairs[i].isnull = false;
 			pairs[i].needfree = false;
 		}
 	}
 	count = hstoreUniquePairs(pairs, count, &buflen);
 	out = hstorePairs(pairs, count, buflen);
 	PG_RETURN_POINTER(out);
 }","[40, 41, 42, 43, 44]","Multiple integer overflows in contrib/hstore/hstore_io.c in PostgreSQL 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact via vectors related to the (1) hstore_recv, (2) hstore_from_arrays, and (3) hstore_from_array functions in contrib/hstore/hstore_io.c; and the (4) hstoreArrayToPairs function in contrib/hstore/hstore_op.c, which triggers a buffer overflow.  NOTE: this issue was SPLIT from CVE-2014-0064 because it has a different set of affected versions.",postgres,CVE-2014-2669,CWE-189
72,183238," psf_close (SF_PRIVATE *psf)
 {	uint32_t k ;
 	int	error = 0 ;
 	if (psf->codec_close)
 	{	error = psf->codec_close (psf) ;
 		psf->codec_close = NULL ;
 		} ;
 	if (psf->container_close)
 		error = psf->container_close (psf) ;
 	error = psf_fclose (psf) ;
  	psf_close_rsrc (psf) ;
 	free (psf->header.ptr) ;
  	free (psf->container_data) ;
  	free (psf->codec_data) ;
  	free (psf->interleave) ;
 	free (psf->dither) ;
 	free (psf->peak_info) ;
 	free (psf->broadcast_16k) ;
 	free (psf->loop_info) ;
 	free (psf->instrument) ;
 	free (psf->cues) ;
 	free (psf->channel_map) ;
 	free (psf->format_desc) ;
 	free (psf->strings.storage) ;
 	if (psf->wchunks.chunks)
 		for (k = 0 ; k < psf->wchunks.used ; k++)
 			free (psf->wchunks.chunks [k].data) ;
 	free (psf->rchunks.chunks) ;
 	free (psf->wchunks.chunks) ;
 	free (psf->iterator) ;
 	free (psf->cart_16k) ;
 	memset (psf, 0, sizeof (SF_PRIVATE)) ;
 	free (psf) ;
 	return error ;
 }  ",[12],"In libsndfile before 1.0.28, an error in the *header_read()* function (common.c) when handling ID3 tags can be exploited to cause a stack-based buffer overflow via a specially crafted FLAC file.",libsndfile,CVE-2017-7586,CWE-119
73,182843," ZSTD_buildCTable(void* dst, size_t dstCapacity,
                 FSE_CTable* nextCTable, U32 FSELog, symbolEncodingType_e type,
                 U32* count, U32 max,
                 const BYTE* codeTable, size_t nbSeq,
                 const S16* defaultNorm, U32 defaultNormLog, U32 defaultMax,
                 const FSE_CTable* prevCTable, size_t prevCTableSize,
                 void* workspace, size_t workspaceSize)
  {
      BYTE* op = (BYTE*)dst;
      const BYTE* const oend = op + dstCapacity;
     DEBUGLOG(6, ""ZSTD_buildCTable (dstCapacity=%u)"", (unsigned)dstCapacity);
      switch (type) {
      case set_rle:
        *op = codeTable[0];
          CHECK_F(FSE_buildCTable_rle(nextCTable, (BYTE)max));
         if (dstCapacity==0) return ERROR(dstSize_tooSmall);
         *op = codeTable[0];
          return 1;
      case set_repeat:
          memcpy(nextCTable, prevCTable, prevCTableSize);
         return 0;
     case set_basic:
         CHECK_F(FSE_buildCTable_wksp(nextCTable, defaultNorm, defaultMax, defaultNormLog, workspace, workspaceSize));   
         return 0;
     case set_compressed: {
         S16 norm[MaxSeq + 1];
         size_t nbSeq_1 = nbSeq;
         const U32 tableLog = FSE_optimalTableLog(FSELog, nbSeq, max);
         if (count[codeTable[nbSeq-1]] > 1) {
             count[codeTable[nbSeq-1]]--;
             nbSeq_1--;
         }
         assert(nbSeq_1 > 1);
         CHECK_F(FSE_normalizeCount(norm, tableLog, count, nbSeq_1, max));
         {   size_t const NCountSize = FSE_writeNCount(op, oend - op, norm, max, tableLog);    
             if (FSE_isError(NCountSize)) return NCountSize;
             CHECK_F(FSE_buildCTable_wksp(nextCTable, norm, max, tableLog, workspace, workspaceSize));
             return NCountSize;
         }
     }
     default: return assert(0), ERROR(GENERIC);
     }
 }","[11, 14, 16, 17]",A race condition in the one-pass compression functions of Zstandard prior to version 1.3.8 could allow an attacker to write bytes out of bounds if an output buffer smaller than the recommended size was used.,zstd,CVE-2019-11922,CWE-362
75,181869,"  void jas_matrix_asl(jas_matrix_t *matrix, int n)
  {
	int i;
	int j;
 	jas_matind_t i;
 	jas_matind_t j;
  	jas_seqent_t *rowstart;
	int rowstep;
 	jas_matind_t rowstep;
  	jas_seqent_t *data;
  	if (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {
 		assert(matrix->rows_);
 		rowstep = jas_matrix_rowstep(matrix);
 		for (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,
 		  rowstart += rowstep) {
 			for (j = matrix->numcols_, data = rowstart; j > 0; --j,
 			  ++data) {
 				*data = jas_seqent_asl(*data, n);
 			}
 		}
 	}
 }","[3, 4, 5, 6, 8, 9]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
97,182931," GF_Err dinf_Read(GF_Box *s, GF_BitStream *bs)
 {
 	GF_Err e = gf_isom_box_array_read(s, bs, dinf_AddBox);
 	if (e) {
  		return e;
  	}
  	if (!((GF_DataInformationBox *)s)->dref) {
 		GF_Box* dref;
  		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Missing dref box in dinf\n""));
		((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);
 		dref = gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);
 		((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)dref;
 		gf_isom_box_add_for_dump_mode(s, dref);
  	}
  	return GF_OK;
  }","[8, 10, 11, 12, 13]",GPAC 0.7.1 has a memory leak in dinf_Read in isomedia/box_code_base.c.,gpac,CVE-2018-21017,CWE-400
169,181489," jp2_box_t *jp2_box_create(int type)
 jp2_box_t *jp2_box_create0()
  {
  	jp2_box_t *box;
	jp2_boxinfo_t *boxinfo;
  	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
  		return 0;
  	}
  	memset(box, 0, sizeof(jp2_box_t));
 	box->type = 0;
 	box->len = 0;
 	box->ops = &jp2_boxinfo_unk.ops;
 	return box;
 }
 jp2_box_t *jp2_box_create(int type)
 {
 	jp2_box_t *box;
 	jp2_boxinfo_t *boxinfo;
 	if (!(box = jp2_box_create0())) {
 		return 0;
 	}
  	box->type = type;
  	box->len = 0;
  	if (!(boxinfo = jp2_boxinfolookup(type))) {
 		return 0;
 	}
 	box->info = boxinfo;
 	box->ops = &boxinfo->ops;
 	return box;
 }","[2, 5, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21]",The jp2_cdef_destroy function in jp2_cod.c in JasPer before 2.0.13 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted image.,jasper,CVE-2017-6850,CWE-476
209,182244," decrypt_response(struct sc_card *card, unsigned char *in, size_t inlen, unsigned char *out, size_t * out_len)
 {
 	size_t cipher_len;
 	size_t i;
 	unsigned char iv[16] = { 0 };
 	unsigned char plaintext[4096] = { 0 };
 	epass2003_exdata *exdata = NULL;
 	if (!card->drv_data) 
 		return SC_ERROR_INVALID_ARGUMENTS;
 	exdata = (epass2003_exdata *)card->drv_data;
 	if (in[0] == 0x99)
 		return 0;
 	if (0x01 == in[2] && 0x82 != in[1]) {
 		cipher_len = in[1];
 		i = 3;
 	}
 	else if (0x01 == in[3] && 0x81 == in[1]) {
 		cipher_len = in[2];
 		i = 4;
 	}
 	else if (0x01 == in[4] && 0x82 == in[1]) {
 		cipher_len = in[2] * 0x100;
 		cipher_len += in[3];
 		i = 5;
 	}
 	else {
 		return -1;
 	}
 	if (cipher_len < 2 || i+cipher_len > inlen || cipher_len > sizeof plaintext)
 		return -1;
 	if (KEY_TYPE_AES == exdata->smtype)
 		aes128_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], cipher_len - 1, plaintext);
 	else
 		des3_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], cipher_len - 1, plaintext);
  	while (0x80 != plaintext[cipher_len - 2] && (cipher_len - 2 > 0))
  		cipher_len--;
	if (2 == cipher_len)
 	if (2 == cipher_len || *out_len < cipher_len - 2)
  		return -1;
  	memcpy(out, plaintext, cipher_len - 2);
 	*out_len = cipher_len - 2;
 	return 0;
 }","[37, 38]",A double free when handling responses from an HSM Card in sc_pkcs15emu_sc_hsm_init in libopensc/pkcs15-sc-hsm.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.,OpenSC,CVE-2018-16425,CWE-415
210,181172," static int dnxhd_decode_header(DNXHDContext *ctx, AVFrame *frame,
                                const uint8_t *buf, int buf_size,
                                int first_field)
 {
     int i, cid, ret;
     int old_bit_depth = ctx->bit_depth, bitdepth;
     uint64_t header_prefix;
     if (buf_size < 0x280) {
         av_log(ctx->avctx, AV_LOG_ERROR,
                ""buffer too small (%d < 640).\n"", buf_size);
         return AVERROR_INVALIDDATA;
     }
     header_prefix = ff_dnxhd_parse_header_prefix(buf);
     if (header_prefix == 0) {
         av_log(ctx->avctx, AV_LOG_ERROR,
                ""unknown header 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X\n"",
                buf[0], buf[1], buf[2], buf[3], buf[4]);
         return AVERROR_INVALIDDATA;
     }
     if (buf[5] & 2) {  
         ctx->cur_field = buf[5] & 1;
         frame->interlaced_frame = 1;
         frame->top_field_first  = first_field ^ ctx->cur_field;
         av_log(ctx->avctx, AV_LOG_DEBUG,
                ""interlaced %d, cur field %d\n"", buf[5] & 3, ctx->cur_field);
     } else {
         ctx->cur_field = 0;
     }
     ctx->mbaff = (buf[0x6] >> 5) & 1;
     ctx->height = AV_RB16(buf + 0x18);
     ctx->width  = AV_RB16(buf + 0x1a);
     switch(buf[0x21] >> 5) {
     case 1: bitdepth = 8; break;
     case 2: bitdepth = 10; break;
     case 3: bitdepth = 12; break;
     default:
         av_log(ctx->avctx, AV_LOG_ERROR,
                ""Unknown bitdepth indicator (%d)\n"", buf[0x21] >> 5);
         return AVERROR_INVALIDDATA;
     }
     cid = AV_RB32(buf + 0x28);
     ctx->avctx->profile = dnxhd_get_profile(cid);
     if ((ret = dnxhd_init_vlc(ctx, cid, bitdepth)) < 0)
         return ret;
     if (ctx->mbaff && ctx->cid_table->cid != 1260)
         av_log(ctx->avctx, AV_LOG_WARNING,
                ""Adaptive MB interlace flag in an unsupported profile.\n"");
     ctx->act = buf[0x2C] & 7;
     if (ctx->act && ctx->cid_table->cid != 1256 && ctx->cid_table->cid != 1270)
         av_log(ctx->avctx, AV_LOG_WARNING,
                ""Adaptive color transform in an unsupported profile.\n"");
     ctx->is_444 = (buf[0x2C] >> 6) & 1;
     if (ctx->is_444) {
         if (bitdepth == 8) {
             avpriv_request_sample(ctx->avctx, ""4:4:4 8 bits"");
             return AVERROR_INVALIDDATA;
         } else if (bitdepth == 10) {
             ctx->decode_dct_block = dnxhd_decode_dct_block_10_444;
             ctx->pix_fmt = ctx->act ? AV_PIX_FMT_YUV444P10
                                     : AV_PIX_FMT_GBRP10;
         } else {
             ctx->decode_dct_block = dnxhd_decode_dct_block_12_444;
             ctx->pix_fmt = ctx->act ? AV_PIX_FMT_YUV444P12
                                     : AV_PIX_FMT_GBRP12;
         }
     } else if (bitdepth == 12) {
         ctx->decode_dct_block = dnxhd_decode_dct_block_12;
         ctx->pix_fmt = AV_PIX_FMT_YUV422P12;
     } else if (bitdepth == 10) {
         if (ctx->avctx->profile == FF_PROFILE_DNXHR_HQX)
             ctx->decode_dct_block = dnxhd_decode_dct_block_10_444;
         else
             ctx->decode_dct_block = dnxhd_decode_dct_block_10;
         ctx->pix_fmt = AV_PIX_FMT_YUV422P10;
     } else {
         ctx->decode_dct_block = dnxhd_decode_dct_block_8;
         ctx->pix_fmt = AV_PIX_FMT_YUV422P;
     }
     ctx->avctx->bits_per_raw_sample = ctx->bit_depth = bitdepth;
     if (ctx->bit_depth != old_bit_depth) {
         ff_blockdsp_init(&ctx->bdsp, ctx->avctx);
         ff_idctdsp_init(&ctx->idsp, ctx->avctx);
         ff_init_scantable(ctx->idsp.idct_permutation, &ctx->scantable,
                           ff_zigzag_direct);
     }
     if (ctx->width != ctx->cid_table->width &&
         ctx->cid_table->width != DNXHD_VARIABLE) {
         av_reduce(&ctx->avctx->sample_aspect_ratio.num,
                   &ctx->avctx->sample_aspect_ratio.den,
                   ctx->width, ctx->cid_table->width, 255);
         ctx->width = ctx->cid_table->width;
     }
     if (buf_size < ctx->cid_table->coding_unit_size) {
         av_log(ctx->avctx, AV_LOG_ERROR, ""incorrect frame size (%d < %u).\n"",
                buf_size, ctx->cid_table->coding_unit_size);
         return AVERROR_INVALIDDATA;
     }
     ctx->mb_width  = (ctx->width + 15)>> 4;
     ctx->mb_height = AV_RB16(buf + 0x16c);
     if ((ctx->height + 15) >> 4 == ctx->mb_height && frame->interlaced_frame)
         ctx->height <<= 1;
     av_log(ctx->avctx, AV_LOG_VERBOSE, ""%dx%d, 4:%s %d bits, MBAFF=%d ACT=%d\n"",
            ctx->width, ctx->height, ctx->is_444 ? ""4:4"" : ""2:2"",
            ctx->bit_depth, ctx->mbaff, ctx->act);
      if (ctx->mb_height > 68 && ff_dnxhd_check_header_prefix_hr(header_prefix)) {
          ctx->data_offset = 0x170 + (ctx->mb_height << 2);
      } else {
        if (ctx->mb_height > 68 ||
            (ctx->mb_height << frame->interlaced_frame) > (ctx->height + 15) >> 4) {
         if (ctx->mb_height > 68) {
              av_log(ctx->avctx, AV_LOG_ERROR,
                     ""mb height too big: %d\n"", ctx->mb_height);
              return AVERROR_INVALIDDATA;
          }
          ctx->data_offset = 0x280;
      }
     if ((ctx->mb_height << frame->interlaced_frame) > (ctx->height + 15) >> 4) {
         av_log(ctx->avctx, AV_LOG_ERROR,
                 ""mb height too big: %d\n"", ctx->mb_height);
         return AVERROR_INVALIDDATA;
     }
      if (buf_size < ctx->data_offset) {
          av_log(ctx->avctx, AV_LOG_ERROR,
                ""buffer too small (%d < %d).\n"", buf_size, ctx->data_offset);
         return AVERROR_INVALIDDATA;
     }
     if (ctx->mb_height > FF_ARRAY_ELEMS(ctx->mb_scan_index)) {
         av_log(ctx->avctx, AV_LOG_ERROR,
                ""mb_height too big (%d > %""SIZE_SPECIFIER"").\n"", ctx->mb_height, FF_ARRAY_ELEMS(ctx->mb_scan_index));
         return AVERROR_INVALIDDATA;
     }
     for (i = 0; i < ctx->mb_height; i++) {
         ctx->mb_scan_index[i] = AV_RB32(buf + 0x170 + (i << 2));
         ff_dlog(ctx->avctx, ""mb scan index %d, pos %d: %""PRIu32""\n"",
                 i, 0x170 + (i << 2), ctx->mb_scan_index[i]);
         if (buf_size - ctx->data_offset < ctx->mb_scan_index[i]) {
             av_log(ctx->avctx, AV_LOG_ERROR,
                    ""invalid mb scan index (%""PRIu32"" vs %u).\n"",
                    ctx->mb_scan_index[i], buf_size - ctx->data_offset);
             return AVERROR_INVALIDDATA;
         }
     }
     return 0;
 }","[108, 109, 110, 117, 118, 119, 120, 121]",The dnxhd_decode_header function in libavcodec/dnxhddec.c in FFmpeg through 3.3.2 allows remote attackers to cause a denial of service (out-of-array access) or possibly have unspecified other impact via a crafted DNxHD file.,FFmpeg,CVE-2017-11719,CWE-125
216,179876," static int cg_getattr(const char *path, struct stat *sb)
 {
 	struct timespec now;
 	struct fuse_context *fc = fuse_get_context();
 	char * cgdir = NULL;
 	char *fpath = NULL, *path1, *path2;
 	struct cgfs_files *k = NULL;
 	const char *cgroup;
 	const char *controller = NULL;
 	int ret = -ENOENT;
 	if (!fc)
 		return -EIO;
 	memset(sb, 0, sizeof(struct stat));
 	if (clock_gettime(CLOCK_REALTIME, &now) < 0)
 		return -EINVAL;
 	sb->st_uid = sb->st_gid = 0;
 	sb->st_atim = sb->st_mtim = sb->st_ctim = now;
 	sb->st_size = 0;
 	if (strcmp(path, ""/cgroup"") == 0) {
 		sb->st_mode = S_IFDIR | 00755;
 		sb->st_nlink = 2;
 		return 0;
 	}
 	controller = pick_controller_from_path(fc, path);
 	if (!controller)
 		return -EIO;
 	cgroup = find_cgroup_in_path(path);
 	if (!cgroup) {
 		sb->st_mode = S_IFDIR | 00755;
 		sb->st_nlink = 2;
 		return 0;
 	}
 	get_cgdir_and_path(cgroup, &cgdir, &fpath);
 	if (!fpath) {
 		path1 = ""/"";
 		path2 = cgdir;
 	} else {
 		path1 = cgdir;
 		path2 = fpath;
 	}
  	if (is_child_cgroup(controller, path1, path2)) {
 		if (!caller_may_see_dir(fc->pid, controller, cgroup)) {
 			ret = -ENOENT;
 			goto out;
 		}
  		if (!caller_is_in_ancestor(fc->pid, controller, cgroup, NULL)) {
  			sb->st_mode = S_IFDIR | 00555;
 			sb->st_nlink = 2;
 			ret = 0;
 			goto out;
 		}
 		if (!fc_may_access(fc, controller, cgroup, NULL, O_RDONLY)) {
 			ret = -EACCES;
 			goto out;
 		}
 		sb->st_mode = S_IFDIR | 00755;
 		k = cgfs_get_key(controller, cgroup, ""tasks"");
 		if (!k) {
 			sb->st_uid = sb->st_gid = 0;
 		} else {
 			sb->st_uid = k->uid;
 			sb->st_gid = k->gid;
 		}
 		free_key(k);
 		sb->st_nlink = 2;
 		ret = 0;
 		goto out;
 	}
 	if ((k = cgfs_get_key(controller, path1, path2)) != NULL) {
 		sb->st_mode = S_IFREG | k->mode;
 		sb->st_nlink = 1;
 		sb->st_uid = k->uid;
 		sb->st_gid = k->gid;
 		sb->st_size = 0;
 		free_key(k);
 		if (!caller_is_in_ancestor(fc->pid, controller, path1, NULL)) {
 			ret = -ENOENT;
 			goto out;
 		}
 		if (!fc_may_access(fc, controller, path1, path2, O_RDONLY)) {
 			ret = -EACCES;
 			goto out;
 		}
 		ret = 0;
 	}
 out:
 	free(cgdir);
 	return ret;
 }","[42, 43, 44, 45]","LXCFS before 0.12 does not properly enforce directory escapes, which might allow local users to gain privileges by (1) querying or (2) updating a cgroup.",lxcfs,CVE-2015-1342,CWE-264
229,180948," static av_cold int rl2_read_header(AVFormatContext *s)
 {
     AVIOContext *pb = s->pb;
     AVStream *st;
     unsigned int frame_count;
     unsigned int audio_frame_counter = 0;
     unsigned int video_frame_counter = 0;
     unsigned int back_size;
     unsigned short sound_rate;
     unsigned short rate;
     unsigned short channels;
     unsigned short def_sound_size;
     unsigned int signature;
     unsigned int pts_den = 11025;  
     unsigned int pts_num = 1103;
     unsigned int* chunk_offset = NULL;
     int* chunk_size = NULL;
     int* audio_size = NULL;
     int i;
     int ret = 0;
     avio_skip(pb,4);           
     back_size = avio_rl32(pb);  
     signature = avio_rb32(pb);
     avio_skip(pb, 4);          
     frame_count = avio_rl32(pb);
     if(back_size > INT_MAX/2  || frame_count > INT_MAX / sizeof(uint32_t))
         return AVERROR_INVALIDDATA;
     avio_skip(pb, 2);          
     sound_rate = avio_rl16(pb);
     rate = avio_rl16(pb);
     channels = avio_rl16(pb);
     def_sound_size = avio_rl16(pb);
     st = avformat_new_stream(s, NULL);
     if(!st)
          return AVERROR(ENOMEM);
     st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;
     st->codecpar->codec_id = AV_CODEC_ID_RL2;
     st->codecpar->codec_tag = 0;   
     st->codecpar->width = 320;
     st->codecpar->height = 200;
     st->codecpar->extradata_size = EXTRADATA1_SIZE;
     if(signature == RLV3_TAG && back_size > 0)
         st->codecpar->extradata_size += back_size;
     if(ff_get_extradata(s, st->codecpar, pb, st->codecpar->extradata_size) < 0)
         return AVERROR(ENOMEM);
     if(sound_rate){
         if (!channels || channels > 42) {
             av_log(s, AV_LOG_ERROR, ""Invalid number of channels: %d\n"", channels);
             return AVERROR_INVALIDDATA;
         }
         pts_num = def_sound_size;
         pts_den = rate;
         st = avformat_new_stream(s, NULL);
         if (!st)
             return AVERROR(ENOMEM);
         st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;
         st->codecpar->codec_id = AV_CODEC_ID_PCM_U8;
         st->codecpar->codec_tag = 1;
         st->codecpar->channels = channels;
         st->codecpar->bits_per_coded_sample = 8;
         st->codecpar->sample_rate = rate;
         st->codecpar->bit_rate = st->codecpar->channels * st->codecpar->sample_rate *
             st->codecpar->bits_per_coded_sample;
         st->codecpar->block_align = st->codecpar->channels *
             st->codecpar->bits_per_coded_sample / 8;
         avpriv_set_pts_info(st,32,1,rate);
     }
     avpriv_set_pts_info(s->streams[0], 32, pts_num, pts_den);
     chunk_size =   av_malloc(frame_count * sizeof(uint32_t));
     audio_size =   av_malloc(frame_count * sizeof(uint32_t));
     chunk_offset = av_malloc(frame_count * sizeof(uint32_t));
     if(!chunk_size || !audio_size || !chunk_offset){
         av_free(chunk_size);
         av_free(audio_size);
         av_free(chunk_offset);
         return AVERROR(ENOMEM);
      }
    for(i=0; i < frame_count;i++)
     for(i=0; i < frame_count;i++) {
         if (avio_feof(pb))
             return AVERROR_INVALIDDATA;
          chunk_size[i] = avio_rl32(pb);
    for(i=0; i < frame_count;i++)
     }
     for(i=0; i < frame_count;i++) {
         if (avio_feof(pb))
             return AVERROR_INVALIDDATA;
          chunk_offset[i] = avio_rl32(pb);
    for(i=0; i < frame_count;i++)
     }
     for(i=0; i < frame_count;i++) {
         if (avio_feof(pb))
             return AVERROR_INVALIDDATA;
          audio_size[i] = avio_rl32(pb) & 0xFFFF;
     }
      for(i=0;i<frame_count;i++){
         if(chunk_size[i] < 0 || audio_size[i] > chunk_size[i]){
             ret = AVERROR_INVALIDDATA;
             break;
         }
         if(sound_rate && audio_size[i]){
             av_add_index_entry(s->streams[1], chunk_offset[i],
                 audio_frame_counter,audio_size[i], 0, AVINDEX_KEYFRAME);
             audio_frame_counter += audio_size[i] / channels;
         }
         av_add_index_entry(s->streams[0], chunk_offset[i] + audio_size[i],
             video_frame_counter,chunk_size[i]-audio_size[i],0,AVINDEX_KEYFRAME);
         ++video_frame_counter;
     }
     av_free(chunk_size);
     av_free(audio_size);
     av_free(chunk_offset);
     return ret;
 }","[78, 79, 80, 81, 83, 84, 85, 86, 87, 89, 90, 91, 92, 93, 95]","In libavformat/rl2.c in FFmpeg 3.3.3, a DoS in rl2_read_header() due to lack of an EOF (End of File) check might cause huge CPU and memory consumption. When a crafted RL2 file, which claims a large *frame_count* field in the header but does not contain sufficient backing data, is provided, the loops (for offset and size tables) would consume huge CPU and memory resources, since there is no EOF check inside these loops.",FFmpeg,CVE-2017-14056,CWE-834
246,182234," static int piv_match_card_continued(sc_card_t *card)
 {
 	int i;
 	int type  = -1;
 	piv_private_data_t *priv = NULL;
 	int saved_type = card->type;
 	card->ops->logout = NULL;
 	switch (card->type) {
 		case -1:
 		case SC_CARD_TYPE_PIV_II_GENERIC:
 		case SC_CARD_TYPE_PIV_II_HIST:
 		case SC_CARD_TYPE_PIV_II_NEO:
 		case SC_CARD_TYPE_PIV_II_YUBIKEY4:
 		case SC_CARD_TYPE_PIV_II_GI_DE:
 			type = card->type;
 			break;
 		default:
 			return 0;  
 	}
 	if (type == -1) {
 		if (card->reader->atr_info.hist_bytes != NULL) {
 			if (card->reader->atr_info.hist_bytes_len == 8 &&
 					!(memcmp(card->reader->atr_info.hist_bytes, ""Yubikey4"", 8))) {
 				type = SC_CARD_TYPE_PIV_II_YUBIKEY4;
 			}
 			else if (card->reader->atr_info.hist_bytes_len >= 7 &&
 					!(memcmp(card->reader->atr_info.hist_bytes, ""Yubikey"", 7))) {
 				type = SC_CARD_TYPE_PIV_II_NEO;
 			}
			else if (card->reader->atr_info.hist_bytes_len >= 4 &&
					!(memcmp(card->reader->atr_info.hist_bytes, ""sfte"", 4))) {
 			else if (card->reader->atr_info.hist_bytes_len >= 4
 					&& !(memcmp(card->reader->atr_info.hist_bytes, ""sfte"", 4))) {
  				type = SC_CARD_TYPE_PIV_II_GI_DE;
  			}
			else if (card->reader->atr_info.hist_bytes[0] == 0x80u) {  
 			else if (card->reader->atr_info.hist_bytes_len > 0
 					&& card->reader->atr_info.hist_bytes[0] == 0x80u) {  
  				size_t datalen;
  				const u8 *data = sc_compacttlv_find_tag(card->reader->atr_info.hist_bytes + 1,
  									card->reader->atr_info.hist_bytes_len - 1,
 									0xF0, &datalen);
 				if (data != NULL) {
 					int k;
 					for (k = 0; piv_aids[k].len_long != 0; k++) {
 						if (datalen == piv_aids[k].len_long
 							&& !memcmp(data, piv_aids[k].value, datalen)) {
 							type = SC_CARD_TYPE_PIV_II_HIST;
 							break;
 						}
 					}
 				}
 			}
 		}
 		if (type == -1)
 			type = SC_CARD_TYPE_PIV_II_GENERIC;
 	}
 	priv = calloc(1, sizeof(piv_private_data_t));
 	if (!priv)
 		LOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);
 	if (card->type == -1)
 		card->type = type;
 	card->drv_data = priv;  
 	priv->aid_file = sc_file_new();
 	priv->selected_obj = -1;
 	priv->pin_preference = 0x80;  
 	priv->logged_in = SC_PIN_STATE_UNKNOWN;
 	priv->tries_left = 10;  
 	priv->pstate = PIV_STATE_MATCH;
 	for (i=0; i < PIV_OBJ_LAST_ENUM -1; i++)
 		if(piv_objects[i].flags & PIV_OBJECT_NOT_PRESENT)
 			priv->obj_cache[i].flags |= PIV_OBJ_CACHE_NOT_PRESENT;
 	sc_lock(card);
 	i = piv_find_discovery(card);
 	if (i < 0) {
 		sc_file_t aidfile;
 		i = piv_find_aid(card, &aidfile);
 	}
 	if (i >= 0) {
 		int i7e = piv_find_discovery(card);
 		if (i7e != 0 && i7e !=  SC_ERROR_FILE_NOT_FOUND) {
 			priv->card_issues |= CI_DISCOVERY_USELESS;
 			priv->obj_cache[PIV_OBJ_DISCOVERY].flags |= PIV_OBJ_CACHE_NOT_PRESENT;
 		}
 	}
 	if (i < 0) {
 		sc_unlock(card);
 		piv_finish(card);
 		card->type = saved_type;
 		return 0;
 	}
 	priv->pstate=PIV_STATE_INIT;
 	return 1;  
 }","[30, 31, 32, 33, 36, 37, 38]",Various out of bounds reads when handling responses in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to potentially crash the opensc library using programs.,OpenSC,CVE-2018-16427,CWE-125
247,180916," static int sdp_parse_fmtp_config_h264(AVFormatContext *s,
                                       AVStream *stream,
                                       PayloadContext *h264_data,
                                       const char *attr, const char *value)
 {
     AVCodecParameters *par = stream->codecpar;
     if (!strcmp(attr, ""packetization-mode"")) {
         av_log(s, AV_LOG_DEBUG, ""RTP Packetization Mode: %d\n"", atoi(value));
         h264_data->packetization_mode = atoi(value);
         if (h264_data->packetization_mode > 1)
             av_log(s, AV_LOG_ERROR,
                    ""Interleaved RTP mode is not supported yet.\n"");
     } else if (!strcmp(attr, ""profile-level-id"")) {
         if (strlen(value) == 6)
              parse_profile_level_id(s, h264_data, value);
      } else if (!strcmp(attr, ""sprop-parameter-sets"")) {
          int ret;
        if (value[strlen(value) - 1] == ',') {
         if (*value == 0 || value[strlen(value) - 1] == ',') {
              av_log(s, AV_LOG_WARNING, ""Missing PPS in sprop-parameter-sets, ignoring\n"");
              return 0;
          }
         par->extradata_size = 0;
         av_freep(&par->extradata);
         ret = ff_h264_parse_sprop_parameter_sets(s, &par->extradata,
                                                  &par->extradata_size, value);
         av_log(s, AV_LOG_DEBUG, ""Extradata set to %p (size: %d)\n"",
                par->extradata, par->extradata_size);
         return ret;
     }
     return 0;
 }","[18, 19]","The sdp_parse_fmtp_config_h264 function in libavformat/rtpdec_h264.c in FFmpeg before 3.3.4 mishandles empty sprop-parameter-sets values, which allows remote attackers to cause a denial of service (heap buffer overflow) or possibly have unspecified other impact via a crafted sdp file.",FFmpeg,CVE-2017-14767,CWE-119
262,178617," SProcXIBarrierReleasePointer(ClientPtr client)
 {
     xXIBarrierReleasePointerInfo *info;
     REQUEST(xXIBarrierReleasePointerReq);
     int i;
     swaps(&stuff->length);
      REQUEST_AT_LEAST_SIZE(xXIBarrierReleasePointerReq);
      swapl(&stuff->num_barriers);
     if (stuff->num_barriers > UINT32_MAX / sizeof(xXIBarrierReleasePointerInfo))
         return BadLength;
      REQUEST_FIXED_SIZE(xXIBarrierReleasePointerReq, stuff->num_barriers * sizeof(xXIBarrierReleasePointerInfo));
      info = (xXIBarrierReleasePointerInfo*) &stuff[1];
         swapl(&info->barrier);
         swapl(&info->eventid);
     }","[9, 10]",xorg-x11-server before 1.19.5 was vulnerable to integer overflow in (S)ProcXIBarrierReleasePointer functions allowing malicious X client to cause X server to crash or possibly execute arbitrary code.,xserver,CVE-2017-12179,CWE-190
265,182589," valid_host(cupsd_client_t *con)		 
 {
   cupsd_alias_t	*a;			 
   cupsd_netif_t	*netif;			 
   const char	*end;			 
   char		*ptr;			 
   strlcpy(con->clientname, httpGetField(con->http, HTTP_FIELD_HOST),
           sizeof(con->clientname));
   if ((ptr = strrchr(con->clientname, ':')) != NULL && !strchr(ptr, ']'))
   {
     *ptr++ = '\0';
     con->clientport = atoi(ptr);
   }
   else
     con->clientport = con->serverport;
   if (httpAddrLocalhost(httpGetAddress(con->http)))
   {
      return (!_cups_strcasecmp(con->clientname, ""localhost"") ||
  	    !_cups_strcasecmp(con->clientname, ""localhost."") ||
#ifdef __linux
	    !_cups_strcasecmp(con->clientname, ""localhost.localdomain"") ||
#endif  
              !strcmp(con->clientname, ""127.0.0.1"") ||
  	    !strcmp(con->clientname, ""[::1]""));
    }
 #if defined(HAVE_DNSSD) || defined(HAVE_AVAHI)
   if ((end = strrchr(con->clientname, '.')) != NULL && end > con->clientname &&
       !end[1])
   {
     for (end --; end > con->clientname && *end != '.'; end --);
   }
   if (end && (!_cups_strcasecmp(end, "".local"") ||
 	      !_cups_strcasecmp(end, "".local."")))
     return (1);
 #endif  
   if (isdigit(con->clientname[0] & 255) || con->clientname[0] == '[')
   {
     http_addrlist_t *addrlist;		 
     if ((addrlist = httpAddrGetList(con->clientname, AF_UNSPEC, NULL)) != NULL)
     {
       httpAddrFreeList(addrlist);
       return (1);
     }
   }
   for (a = (cupsd_alias_t *)cupsArrayFirst(ServerAlias);
        a;
        a = (cupsd_alias_t *)cupsArrayNext(ServerAlias))
   {
     if (!strcmp(a->name, ""*""))
       return (1);
     if (!_cups_strncasecmp(con->clientname, a->name, a->namelen))
     {
       end = con->clientname + a->namelen;
       if (!*end || (*end == '.' && !end[1]))
         return (1);
     }
   }
 #if defined(HAVE_DNSSD) || defined(HAVE_AVAHI)
   for (a = (cupsd_alias_t *)cupsArrayFirst(DNSSDAlias);
        a;
        a = (cupsd_alias_t *)cupsArrayNext(DNSSDAlias))
   {
     if (!strcmp(a->name, ""*""))
       return (1);
     if (!_cups_strncasecmp(con->clientname, a->name, a->namelen))
     {
       end = con->clientname + a->namelen;
       if (!*end || (*end == '.' && !end[1]))
         return (1);
     }
   }
 #endif  
   for (netif = (cupsd_netif_t *)cupsArrayFirst(NetIFList);
        netif;
        netif = (cupsd_netif_t *)cupsArrayNext(NetIFList))
   {
     if (!_cups_strncasecmp(con->clientname, netif->hostname, netif->hostlen))
     {
       end = con->clientname + netif->hostlen;
       if (!*end || (*end == '.' && !end[1]))
         return (1);
     }
   }
   return (0);
 }","[20, 21, 22]",A localhost.localdomain whitelist entry in valid_host() in scheduler/client.c in CUPS before 2.2.2 allows remote attackers to execute arbitrary IPP commands by sending POST requests to the CUPS daemon in conjunction with DNS rebinding. The localhost.localdomain name is often resolved via a DNS server (neither the OS nor the web browser is responsible for ensuring that localhost.localdomain is 127.0.0.1).,cups,CVE-2017-18190,CWE-290
326,179588," txid_snapshot_recv(PG_FUNCTION_ARGS)
 {
 	StringInfo	buf = (StringInfo) PG_GETARG_POINTER(0);
 	TxidSnapshot *snap;
  	txid		last = 0;
  	int			nxip;
  	int			i;
	int			avail;
	int			expect;
  	txid		xmin,
  				xmax;
  	nxip = pq_getmsgint(buf, 4);
	avail = buf->len - buf->cursor;
	expect = 8 + 8 + nxip * 8;
	if (nxip < 0 || nxip > avail || expect > avail)
 	if (nxip < 0 || nxip > TXID_SNAPSHOT_MAX_NXIP)
  		goto bad_format;
  	xmin = pq_getmsgint64(buf);
 	xmax = pq_getmsgint64(buf);
 	if (xmin == 0 || xmax == 0 || xmin > xmax || xmax > MAX_TXID)
 		goto bad_format;
 	snap = palloc(TXID_SNAPSHOT_SIZE(nxip));
 	snap->xmin = xmin;
 	snap->xmax = xmax;
 	snap->nxip = nxip;
 	SET_VARSIZE(snap, TXID_SNAPSHOT_SIZE(nxip));
 	for (i = 0; i < nxip; i++)
 	{
 		txid		cur = pq_getmsgint64(buf);
 		if (cur <= last || cur < xmin || cur >= xmax)
 			goto bad_format;
 		snap->xip[i] = cur;
 		last = cur;
 	}
 	PG_RETURN_POINTER(snap);
 bad_format:
 	elog(ERROR, ""invalid snapshot data"");
 	return (Datum) NULL;
 }","[8, 9, 13, 14, 15, 16]","Multiple integer overflows in contrib/hstore/hstore_io.c in PostgreSQL 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact via vectors related to the (1) hstore_recv, (2) hstore_from_arrays, and (3) hstore_from_array functions in contrib/hstore/hstore_io.c; and the (4) hstoreArrayToPairs function in contrib/hstore/hstore_op.c, which triggers a buffer overflow.  NOTE: this issue was SPLIT from CVE-2014-0064 because it has a different set of affected versions.",postgres,CVE-2014-2669,CWE-189
328,181866," jas_image_t *jas_image_create(int numcmpts, jas_image_cmptparm_t *cmptparms,
    int clrspc)
  {
  	jas_image_t *image;
	uint_fast32_t rawsize;
 	size_t rawsize;
  	uint_fast32_t inmem;
  	int cmptno;
  	jas_image_cmptparm_t *cmptparm;
 	image = 0;
 	JAS_DBGLOG(100, (""jas_image_create(%d, %p, %d)\n"", numcmpts, cmptparms,
 	  clrspc));
  	if (!(image = jas_image_create0())) {
		return 0;
 		goto error;
  	}
  	image->clrspc_ = clrspc;
  	image->maxcmpts_ = numcmpts;
	image->inmem_ = true;
  	if (!(image->cmpts_ = jas_alloc2(image->maxcmpts_,
  	  sizeof(jas_image_cmpt_t *)))) {
		jas_image_destroy(image);
		return 0;
 		goto error;
  	}
  	for (cmptno = 0; cmptno < image->maxcmpts_; ++cmptno) {
  		image->cmpts_[cmptno] = 0;
  	}
 #if 0
  	rawsize = 0;
  	for (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,
 	  ++cmptparm) {
 		rawsize += cmptparm->width * cmptparm->height *
 		  (cmptparm->prec + 7) / 8;
 	}
  	inmem = (rawsize < JAS_IMAGE_INMEMTHRESH);
 #endif
  	for (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,
  	  ++cmptparm) {
 		if (!jas_safe_size_mul3(cmptparm->width, cmptparm->height,
 		  (cmptparm->prec + 7), &rawsize)) {
 			goto error;
 		}
 		rawsize /= 8;
 		inmem = (rawsize < JAS_IMAGE_INMEMTHRESH);
  		if (!(image->cmpts_[cmptno] = jas_image_cmpt_create(cmptparm->tlx,
  		  cmptparm->tly, cmptparm->hstep, cmptparm->vstep,
  		  cmptparm->width, cmptparm->height, cmptparm->prec,
  		  cmptparm->sgnd, inmem))) {
			jas_image_destroy(image);
			return 0;
 			goto error;
  		}
  		++image->numcmpts_;
  	}
  	jas_image_setbbox(image);
  	return image;
 error:
 	if (image) {
 		jas_image_destroy(image);
 	}
 	return 0;
  }","[5, 6, 10, 11, 12, 14, 15, 19, 22, 23, 24, 29, 37, 40, 41, 42, 43, 44, 45, 50, 51, 52, 58, 59, 60, 61, 62]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
329,182721," uint32_t GetPayloadTime(size_t handle, uint32_t index, float *in, float *out)
 uint32_t GetPayloadTime(size_t handle, uint32_t index, double *in, double *out)
  {
  	mp4object *mp4 = (mp4object *)handle;
	if (mp4 == NULL) return 0;
 	if (mp4 == NULL) return GPMF_ERROR_MEMORY;
	if (mp4->metaoffsets == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in == NULL || out == NULL) return 1;
 	if (mp4->metaoffsets == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in == NULL || out == NULL) return GPMF_ERROR_MEMORY;
	*in = (float)((double)index * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);
	*out = (float)((double)(index + 1) * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);
	return 0;
 	*in = ((double)index * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);
 	*out = ((double)(index + 1) * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);
 	return GPMF_OK;
  }","[2, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]",GoPro GPMF-parser 1.2.2 has an out-of-bounds write in OpenMP4Source in demo/GPMF_mp4reader.c.,gpmf-parser,CVE-2019-15148,CWE-787
330,182233," static int piv_general_io(sc_card_t *card, int ins, int p1, int p2,
 	const u8 * sendbuf, size_t sendbuflen, u8 ** recvbuf,
 	size_t * recvbuflen)
 {
 	int r;
 	sc_apdu_t apdu;
 	u8 rbufinitbuf[4096];
 	u8 *rbuf;
 	size_t rbuflen;
 	unsigned int cla_out, tag_out;
 	const u8 *body;
 	size_t bodylen;
 	int find_len = 0;
 	piv_private_data_t * priv = PIV_DATA(card);
 	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
 	sc_log(card->ctx,
 	       ""%02x %02x %02x %""SC_FORMAT_LEN_SIZE_T""u : %""SC_FORMAT_LEN_SIZE_T""u %""SC_FORMAT_LEN_SIZE_T""u"",
 	       ins, p1, p2, sendbuflen, card->max_send_size,
 	       card->max_recv_size);
 	rbuf = rbufinitbuf;
 	rbuflen = sizeof(rbufinitbuf);
 	if (recvbuf && *recvbuf && recvbuflen && *recvbuflen) {
 		rbuf = *recvbuf;
 		rbuflen = *recvbuflen;
 	}
 	r = sc_lock(card);
 	if (r != SC_SUCCESS)
 		LOG_FUNC_RETURN(card->ctx, r);
 	sc_format_apdu(card, &apdu,
 			recvbuf ? SC_APDU_CASE_4_SHORT: SC_APDU_CASE_3_SHORT,
 			ins, p1, p2);
 	apdu.flags |= SC_APDU_FLAGS_CHAINING;
 	if (rbuflen == 8 && card->reader->active_protocol == SC_PROTO_T1) {
 		apdu.flags |= SC_APDU_FLAGS_NO_GET_RESP;
 		find_len = 1;
 	}
 	apdu.lc = sendbuflen;
 	apdu.datalen = sendbuflen;
 	apdu.data = sendbuf;
 	if (recvbuf) {
 		apdu.resp = rbuf;
 		apdu.le = (rbuflen > 256) ? 256 : rbuflen;
 		apdu.resplen = rbuflen;
 	} else {
 		 apdu.resp =  rbuf;
 		 apdu.le = 0;
 		 apdu.resplen = 0;
 	}
 	sc_log(card->ctx,
 	       ""calling sc_transmit_apdu flags=%lx le=%""SC_FORMAT_LEN_SIZE_T""u, resplen=%""SC_FORMAT_LEN_SIZE_T""u, resp=%p"",
 	       apdu.flags, apdu.le, apdu.resplen, apdu.resp);
 	r = sc_transmit_apdu(card, &apdu);
 	sc_log(card->ctx,
 	       ""DEE r=%d apdu.resplen=%""SC_FORMAT_LEN_SIZE_T""u sw1=%02x sw2=%02x"",
 	       r, apdu.resplen, apdu.sw1, apdu.sw2);
 	if (r < 0) {
 		sc_log(card->ctx, ""Transmit failed"");
 		goto err;
 	}
 	if (!(find_len && apdu.sw1 == 0x61))
 	    r = sc_check_sw(card, apdu.sw1, apdu.sw2);
 	if (r < 0) {
 		sc_log(card->ctx, ""Card returned error "");
 		goto err;
 	}
 	rbuflen = 0;   
 	if ( recvbuflen && recvbuf && apdu.resplen > 3 && priv->pin_cmd_noparse != 1) {
 		*recvbuflen = 0;
  		body = rbuf;
		if (sc_asn1_read_tag(&body, 0xffff, &cla_out, &tag_out, &bodylen) !=  SC_SUCCESS
 		if (sc_asn1_read_tag(&body, rbuflen, &cla_out, &tag_out, &bodylen) !=  SC_SUCCESS
  				|| body == NULL)  {
  			sc_log(card->ctx, ""***** received buffer tag MISSING "");
 			body = rbuf;
 			if (apdu.sw1 == 0x61  || apdu.sw2 == 0x6c )
 				bodylen = 12000;
 			else
 				bodylen = apdu.resplen;
 		}
 		rbuflen = body - rbuf + bodylen;
 		if (rbuf == rbufinitbuf) {
 			*recvbuf = malloc(rbuflen);
 			if (*recvbuf == NULL) {
 				r = SC_ERROR_OUT_OF_MEMORY;
 				goto err;
 			}
 			memcpy(*recvbuf, rbuf, rbuflen);  
 		}
 	}
 	if (recvbuflen) {
 		*recvbuflen =  rbuflen;
 		r = *recvbuflen;
 	}
 err:
 	sc_unlock(card);
 	LOG_FUNC_RETURN(card->ctx, r);
 }","[70, 71]",Various out of bounds reads when handling responses in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to potentially crash the opensc library using programs.,OpenSC,CVE-2018-16427,CWE-125
343,180400," archive_read_format_cpio_read_header(struct archive_read *a,
     struct archive_entry *entry)
 {
 	struct cpio *cpio;
 	const void *h;
 	struct archive_string_conv *sconv;
 	size_t namelength;
 	size_t name_pad;
 	int r;
 	cpio = (struct cpio *)(a->format->data);
 	sconv = cpio->opt_sconv;
 	if (sconv == NULL) {
 		if (!cpio->init_default_conversion) {
 			cpio->sconv_default =
 			    archive_string_default_conversion_for_read(
 			      &(a->archive));
 			cpio->init_default_conversion = 1;
 		}
 		sconv = cpio->sconv_default;
 	}
 	r = (cpio->read_header(a, cpio, entry, &namelength, &name_pad));
 	if (r < ARCHIVE_WARN)
 		return (r);
 	h = __archive_read_ahead(a, namelength + name_pad, NULL);
 	if (h == NULL)
 	    return (ARCHIVE_FATAL);
 	if (archive_entry_copy_pathname_l(entry,
 	    (const char *)h, namelength, sconv) != 0) {
 		if (errno == ENOMEM) {
 			archive_set_error(&a->archive, ENOMEM,
 			    ""Can't allocate memory for Pathname"");
 			return (ARCHIVE_FATAL);
 		}
 		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
 		    ""Pathname can't be converted from %s to current locale."",
 		    archive_string_conversion_charset_name(sconv));
 		r = ARCHIVE_WARN;
 	}
 	cpio->entry_offset = 0;
 	__archive_read_consume(a, namelength + name_pad);
  	if (archive_entry_filetype(entry) == AE_IFLNK) {
 		if (cpio->entry_bytes_remaining > 1024 * 1024) {
 			archive_set_error(&a->archive, ENOMEM,
 			    ""Rejecting malformed cpio archive: symlink contents exceed 1 megabyte"");
 			return (ARCHIVE_FATAL);
 		}
  		h = __archive_read_ahead(a,
  			(size_t)cpio->entry_bytes_remaining, NULL);
  		if (h == NULL)
 			return (ARCHIVE_FATAL);
 		if (archive_entry_copy_symlink_l(entry, (const char *)h,
 		    (size_t)cpio->entry_bytes_remaining, sconv) != 0) {
 			if (errno == ENOMEM) {
 				archive_set_error(&a->archive, ENOMEM,
 				    ""Can't allocate memory for Linkname"");
 				return (ARCHIVE_FATAL);
 			}
 			archive_set_error(&a->archive,
 			    ARCHIVE_ERRNO_FILE_FORMAT,
 			    ""Linkname can't be converted from %s to ""
 			    ""current locale."",
 			    archive_string_conversion_charset_name(sconv));
 			r = ARCHIVE_WARN;
 		}
 		__archive_read_consume(a, cpio->entry_bytes_remaining);
 		cpio->entry_bytes_remaining = 0;
 	}
 	if (namelength == 11 && strcmp((const char *)h, ""TRAILER!!!"") == 0) {
 		archive_clear_error(&a->archive);
 		return (ARCHIVE_EOF);
 	}
 	if (record_hardlink(a, cpio, entry) != ARCHIVE_OK) {
 		return (ARCHIVE_FATAL);
 	}
 	return (r);
 }","[42, 43, 44, 45, 46]",The archive_read_format_cpio_read_header function in archive_read_support_format_cpio.c in libarchive before 3.2.1 allows remote attackers to cause a denial of service (application crash) via a CPIO archive with a large symlink.,libarchive,CVE-2016-4809,CWE-20
347,183314," void CNB::SetupLSO(virtio_net_hdr_basic *VirtioHeader, PVOID IpHeader, ULONG EthPayloadLength) const
 {
     PopulateIPLength(reinterpret_cast<IPv4Header*>(IpHeader), static_cast<USHORT>(EthPayloadLength));
      tTcpIpPacketParsingResult packetReview;
      packetReview = ParaNdis_CheckSumVerifyFlat(reinterpret_cast<IPv4Header*>(IpHeader), EthPayloadLength,
                                                 pcrIpChecksum | pcrFixIPChecksum | pcrTcpChecksum | pcrFixPHChecksum,
                                                FALSE,
                                                 __FUNCTION__);
      if (packetReview.xxpCheckSum == ppresPCSOK || packetReview.fixedXxpCS)
     {
         auto IpHeaderOffset = m_Context->Offload.ipHeaderOffset;
         auto VHeader = static_cast<virtio_net_hdr_basic*>(VirtioHeader);
         auto PriorityHdrLen = (m_ParentNBL->TCI() != 0) ? ETH_PRIORITY_HEADER_SIZE : 0;
         VHeader->flags = VIRTIO_NET_HDR_F_NEEDS_CSUM;
         VHeader->gso_type = packetReview.ipStatus == ppresIPV4 ? VIRTIO_NET_HDR_GSO_TCPV4 : VIRTIO_NET_HDR_GSO_TCPV6;
         VHeader->hdr_len = (USHORT)(packetReview.XxpIpHeaderSize + IpHeaderOffset + PriorityHdrLen);
         VHeader->gso_size = (USHORT)m_ParentNBL->MSS();
         VHeader->csum_start = (USHORT)(m_ParentNBL->TCPHeaderOffset() + PriorityHdrLen);
         VHeader->csum_offset = TCP_CHECKSUM_OFFSET;
     }
 }",[7],"The NetKVM Windows Virtio driver allows remote attackers to cause a denial of service (guest crash) via a crafted length value in an IP packet, as demonstrated by a value that does not account for the size of the IP options.",kvm-guest-drivers-windows,CVE-2015-3215,CWE-20
369,179644," static void ikev2_parent_inR1outI2_continue(struct pluto_crypto_req_cont *pcrc,
 					    struct pluto_crypto_req *r,
 					    err_t ugh)
 {
 	struct dh_continuation *dh = (struct dh_continuation *)pcrc;
 	struct msg_digest *md = dh->md;
 	struct state *const st = md->st;
 	stf_status e;
 	DBG(DBG_CONTROLMORE,
 	    DBG_log(""ikev2 parent inR1outI2: calculating g^{xy}, sending I2""));
 	if (st == NULL) {
 		loglog(RC_LOG_SERIOUS,
 		       ""%s: Request was disconnected from state"",
 		       __FUNCTION__);
 		if (dh->md)
 			release_md(dh->md);
 		return;
 	}
 	passert(ugh == NULL);
 	passert(cur_state == NULL);
 	passert(st != NULL);
 	passert(st->st_suspended_md == dh->md);
 	set_suspended(st, NULL);  
 	set_cur_state(st);
 	st->st_calculating = FALSE;
 	e = ikev2_parent_inR1outI2_tail(pcrc, r);
 	if (dh->md != NULL) {
 		complete_v2_state_transition(&dh->md, e);
 		if (dh->md)
  			release_md(dh->md);
  	}
  	reset_globals();
	passert(GLOBALS_ARE_RESET());
  }",[33],The ikev2parent_inI1outR1 function in pluto/ikev2_parent.c in libreswan before 3.7 allows remote attackers to cause a denial of service (restart) via an IKEv2 I1 notification without a KE payload.,libreswan,CVE-2013-7294,CWE-20
392,181903," static int jpc_siz_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate,
   jas_stream_t *in)
 {
 	jpc_siz_t *siz = &ms->parms.siz;
  	unsigned int i;
  	uint_fast8_t tmp;
 	siz->comps = 0;
  	cstate = 0;
 	if (jpc_getuint16(in, &siz->caps) ||
 	  jpc_getuint32(in, &siz->width) ||
 	  jpc_getuint32(in, &siz->height) ||
 	  jpc_getuint32(in, &siz->xoff) ||
 	  jpc_getuint32(in, &siz->yoff) ||
 	  jpc_getuint32(in, &siz->tilewidth) ||
 	  jpc_getuint32(in, &siz->tileheight) ||
  	  jpc_getuint32(in, &siz->tilexoff) ||
  	  jpc_getuint32(in, &siz->tileyoff) ||
  	  jpc_getuint16(in, &siz->numcomps)) {
		return -1;
 		goto error;
  	}
	if (!siz->width || !siz->height || !siz->tilewidth ||
	  !siz->tileheight || !siz->numcomps || siz->numcomps > 16384) {
		return -1;
 	if (!siz->width || !siz->height) {
 		jas_eprintf(""reference grid cannot have zero area\n"");
 		goto error;
  	}
	if (siz->tilexoff >= siz->width || siz->tileyoff >= siz->height) {
		jas_eprintf(""all tiles are outside the image area\n"");
		return -1;
 	if (!siz->tilewidth || !siz->tileheight) {
 		jas_eprintf(""tile cannot have zero area\n"");
 		goto error;
 	}
 	if (!siz->numcomps || siz->numcomps > 16384) {
 		jas_eprintf(""number of components not in permissible range\n"");
 		goto error;
  	}
 	if (siz->xoff >= siz->width) {
 		jas_eprintf(""XOsiz not in permissible range\n"");
 		goto error;
 	}
 	if (siz->yoff >= siz->height) {
 		jas_eprintf(""YOsiz not in permissible range\n"");
 		goto error;
 	}
 	if (siz->tilexoff > siz->xoff || siz->tilexoff + siz->tilewidth <= siz->xoff) {
 		jas_eprintf(""XTOsiz not in permissible range\n"");
 		goto error;
 	}
 	if (siz->tileyoff > siz->yoff || siz->tileyoff + siz->tileheight <= siz->yoff) {
 		jas_eprintf(""YTOsiz not in permissible range\n"");
 		goto error;
 	}
  	if (!(siz->comps = jas_alloc2(siz->numcomps, sizeof(jpc_sizcomp_t)))) {
		return -1;
 		goto error;
  	}
  	for (i = 0; i < siz->numcomps; ++i) {
  		if (jpc_getuint8(in, &tmp) ||
  		  jpc_getuint8(in, &siz->comps[i].hsamp) ||
  		  jpc_getuint8(in, &siz->comps[i].vsamp)) {
			jas_free(siz->comps);
			return -1;
 			goto error;
  		}
  		if (siz->comps[i].hsamp == 0 || siz->comps[i].hsamp > 255) {
  			jas_eprintf(""invalid XRsiz value %d\n"", siz->comps[i].hsamp);
			jas_free(siz->comps);
			return -1;
 			goto error;
  		}
  		if (siz->comps[i].vsamp == 0 || siz->comps[i].vsamp > 255) {
  			jas_eprintf(""invalid YRsiz value %d\n"", siz->comps[i].vsamp);
			jas_free(siz->comps);
			return -1;
 			goto error;
  		}
  		siz->comps[i].sgnd = (tmp >> 7) & 1;
  		siz->comps[i].prec = (tmp & 0x7f) + 1;
  	}
  	if (jas_stream_eof(in)) {
		jas_free(siz->comps);
		return -1;
 		goto error;
  	}
  	return 0;
 error:
 	if (siz->comps) {
 		jas_free(siz->comps);
 	}
 	return -1;
  }","[7, 19, 20, 22, 23, 24, 25, 26, 27, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 57, 58, 64, 65, 66, 70, 71, 72, 76, 77, 78, 84, 85, 86, 89, 90, 91, 92, 93]",The jas_seq2d_create function in jas_seq.c in JasPer before 1.900.17 allows remote attackers to cause a denial of service (assertion failure) via a crafted file.,jasper,CVE-2016-9394,CWE-20
395,182875,"  static void Np_toString(js_State *J)
  {
	char buf[32];
 	char buf[100];
  	js_Object *self = js_toobject(J, 0);
  	int radix = js_isundefined(J, 1) ? 10 : js_tointeger(J, 1);
  	if (self->type != JS_CNUMBER)
 		js_typeerror(J, ""not a number"");
 	if (radix == 10) {
 		js_pushstring(J, jsV_numbertostring(J, buf, self->u.number));
 		return;
 	}
 	if (radix < 2 || radix > 36)
 		js_rangeerror(J, ""invalid radix"");
  	{
  		static const char digits[] = ""0123456789abcdefghijklmnopqrstuvwxyz"";
		char buf[100];
  		double number = self->u.number;
  		int sign = self->u.number < 0;
  		js_Buffer *sb = NULL;
 		uint64_t u, limit = ((uint64_t)1<<52);
 		int ndigits, exp, point;
 		if (number == 0) { js_pushstring(J, ""0""); return; }
 		if (isnan(number)) { js_pushstring(J, ""NaN""); return; }
 		if (isinf(number)) { js_pushstring(J, sign ? ""-Infinity"" : ""Infinity""); return; }
 		if (sign)
 			number = -number;
 		exp = 0;
 		while (number * pow(radix, exp) > limit)
 			--exp;
 		while (number * pow(radix, exp+1) < limit)
 			++exp;
 		u = number * pow(radix, exp) + 0.5;
 		while (u > 0 && (u % radix) == 0) {
 			u /= radix;
 			--exp;
 		}
 		ndigits = 0;
 		while (u > 0) {
 			buf[ndigits++] = digits[u % radix];
 			u /= radix;
 		}
 		point = ndigits - exp;
 		if (js_try(J)) {
 			js_free(J, sb);
 			js_throw(J);
 		}
 		if (sign)
 			js_putc(J, &sb, '-');
 		if (point <= 0) {
 			js_putc(J, &sb, '0');
 			js_putc(J, &sb, '.');
 			while (point++ < 0)
 				js_putc(J, &sb, '0');
 			while (ndigits-- > 0)
 				js_putc(J, &sb, buf[ndigits]);
 		} else {
 			while (ndigits-- > 0) {
 				js_putc(J, &sb, buf[ndigits]);
 				if (--point == 0 && ndigits > 0)
 					js_putc(J, &sb, '.');
 			}
 			while (point-- > 0)
 				js_putc(J, &sb, '0');
 		}
 		js_putc(J, &sb, 0);
 		js_pushstring(J, sb->s);
 		js_endtry(J);
 		js_free(J, sb);
 	}
 }","[3, 4, 17]",An issue was discovered in Artifex MuJS 1.0.5. The Number#toFixed() and numtostr implementations in jsnumber.c have a stack-based buffer overflow.,mujs,CVE-2019-11411,CWE-119
404,181874,"  jas_matrix_t *jas_matrix_copy(jas_matrix_t *x)
  {
  	jas_matrix_t *y;
	int i;
	int j;
 	jas_matind_t i;
 	jas_matind_t j;
  	y = jas_matrix_create(x->numrows_, x->numcols_);
  	for (i = 0; i < x->numrows_; ++i) {
  		for (j = 0; j < x->numcols_; ++j) {
 			*jas_matrix_getref(y, i, j) = jas_matrix_get(x, i, j);
 		}
 	}
 	return y;
 }","[4, 5, 6, 7]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
440,178606," ProcXResQueryResourceBytes (ClientPtr client)
 {
     REQUEST(xXResQueryResourceBytesReq);
     int                          rc;
      ConstructResourceBytesCtx    ctx;
      REQUEST_AT_LEAST_SIZE(xXResQueryResourceBytesReq);
     if (stuff->numSpecs > UINT32_MAX / sizeof(ctx.specs[0]))
         return BadLength;
      REQUEST_FIXED_SIZE(xXResQueryResourceBytesReq,
                         stuff->numSpecs * sizeof(ctx.specs[0]));
                                        (void*) ((char*) stuff +
                                                 sz_xXResQueryResourceBytesReq))) {
         return BadAlloc;
     }
     rc = ConstructResourceBytes(stuff->client, &ctx);
     if (rc == Success) {
         xXResQueryResourceBytesReply rep = {
             .type = X_Reply,
             .sequenceNumber = client->sequence,
             .length = bytes_to_int32(ctx.resultBytes),
             .numSizes = ctx.numSizes
         };
         if (client->swapped) {
             swaps (&rep.sequenceNumber);
             swapl (&rep.length);
             swapl (&rep.numSizes);
             SwapXResQueryResourceBytes(&ctx.response);
         }
         WriteToClient(client, sizeof(rep), &rep);
         WriteFragmentsToClient(client, &ctx.response);
     }
     DestroyConstructResourceBytesCtx(&ctx);
     return rc;
 }","[7, 8]",xorg-x11-server before 1.19.5 was missing length validation in RENDER extension allowing malicious X client to cause X server to crash or possibly execute arbitrary code.,xserver,CVE-2017-12187,CWE-20
445,181417," static int decode_zbuf(AVBPrint *bp, const uint8_t *data,
                        const uint8_t *data_end)
 {
     z_stream zstream;
     unsigned char *buf;
     unsigned buf_size;
     int ret;
     zstream.zalloc = ff_png_zalloc;
     zstream.zfree  = ff_png_zfree;
     zstream.opaque = NULL;
     if (inflateInit(&zstream) != Z_OK)
         return AVERROR_EXTERNAL;
     zstream.next_in  = (unsigned char *)data;
     zstream.avail_in = data_end - data;
      av_bprint_init(bp, 0, -1);
      while (zstream.avail_in > 0) {
        av_bprint_get_buffer(bp, 1, &buf, &buf_size);
        if (!buf_size) {
         av_bprint_get_buffer(bp, 2, &buf, &buf_size);
         if (buf_size < 2) {
              ret = AVERROR(ENOMEM);
              goto fail;
          }
          zstream.next_out  = buf;
        zstream.avail_out = buf_size;
         zstream.avail_out = buf_size - 1;
          ret = inflate(&zstream, Z_PARTIAL_FLUSH);
          if (ret != Z_OK && ret != Z_STREAM_END) {
              ret = AVERROR_EXTERNAL;
             goto fail;
         }
         bp->len += zstream.next_out - buf;
         if (ret == Z_STREAM_END)
             break;
     }
     inflateEnd(&zstream);
     bp->str[bp->len] = 0;
     return 0;
 fail:
     inflateEnd(&zstream);
     av_bprint_finalize(bp, NULL);
     return ret;
 }","[17, 18, 19, 20, 25, 26]",FFmpeg before 2017-01-23 has an out-of-bounds write caused by a stack-based buffer overflow related to the decode_zbuf function in libavcodec/pngdec.c.,FFmpeg,CVE-2017-7866,CWE-787
450,179579," makepol(QPRS_STATE *state)
 {
 	int32		val = 0,
 				type;
 	int32		lenval = 0;
 	char	   *strval = NULL;
 	int32		stack[STACKDEPTH];
  	int32		lenstack = 0;
  	uint16		flag = 0;
 	check_stack_depth();
  	while ((type = gettoken_query(state, &val, &lenval, &strval, &flag)) != END)
  	{
  		switch (type)
 		{
 			case VAL:
 				pushval_asis(state, VAL, strval, lenval, flag);
 				while (lenstack && (stack[lenstack - 1] == (int32) '&' ||
 									stack[lenstack - 1] == (int32) '!'))
 				{
 					lenstack--;
 					pushquery(state, OPR, stack[lenstack], 0, 0, 0);
 				}
 				break;
 			case OPR:
 				if (lenstack && val == (int32) '|')
 					pushquery(state, OPR, val, 0, 0, 0);
 				else
 				{
 					if (lenstack == STACKDEPTH)
 						elog(ERROR, ""stack too short"");
 					stack[lenstack] = val;
 					lenstack++;
 				}
 				break;
 			case OPEN:
 				if (makepol(state) == ERR)
 					return ERR;
 				while (lenstack && (stack[lenstack - 1] == (int32) '&' ||
 									stack[lenstack - 1] == (int32) '!'))
 				{
 					lenstack--;
 					pushquery(state, OPR, stack[lenstack], 0, 0, 0);
 				}
 				break;
 			case CLOSE:
 				while (lenstack)
 				{
 					lenstack--;
 					pushquery(state, OPR, stack[lenstack], 0, 0, 0);
 				};
 				return END;
 				break;
 			case ERR:
 			default:
 				ereport(ERROR,
 						(errcode(ERRCODE_SYNTAX_ERROR),
 						 errmsg(""syntax error"")));
 				return ERR;
 		}
 	}
 	while (lenstack)
 	{
 		lenstack--;
 		pushquery(state, OPR, stack[lenstack], 0, 0, 0);
 	};
 	return END;
 }",[10],"Multiple integer overflows in contrib/hstore/hstore_io.c in PostgreSQL 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact via vectors related to the (1) hstore_recv, (2) hstore_from_arrays, and (3) hstore_from_array functions in contrib/hstore/hstore_io.c; and the (4) hstoreArrayToPairs function in contrib/hstore/hstore_op.c, which triggers a buffer overflow.  NOTE: this issue was SPLIT from CVE-2014-0064 because it has a different set of affected versions.",postgres,CVE-2014-2669,CWE-189
459,182702," externalParEntProcessor(XML_Parser parser, const char *s, const char *end,
                         const char **nextPtr) {
   const char *next = s;
   int tok;
   tok = XmlPrologTok(parser->m_encoding, s, end, &next);
   if (tok <= 0) {
     if (! parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {
       *nextPtr = s;
       return XML_ERROR_NONE;
     }
     switch (tok) {
     case XML_TOK_INVALID:
       return XML_ERROR_INVALID_TOKEN;
     case XML_TOK_PARTIAL:
       return XML_ERROR_UNCLOSED_TOKEN;
     case XML_TOK_PARTIAL_CHAR:
       return XML_ERROR_PARTIAL_CHAR;
     case XML_TOK_NONE:  
     default:
       break;
     }
   }
   else if (tok == XML_TOK_BOM) {
     s = next;
     tok = XmlPrologTok(parser->m_encoding, s, end, &next);
   }
    parser->m_processor = prologProcessor;
    return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,
                  (XML_Bool)! parser->m_parsingStatus.finalBuffer);
                   (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE);
  }","[29, 30]","In libexpat before 2.2.8, crafted XML input could fool the parser into changing from DTD parsing to document parsing too early; a consecutive call to XML_GetCurrentLineNumber (or XML_GetCurrentColumnNumber) then resulted in a heap-based buffer over-read.",libexpat,CVE-2019-15903,CWE-611
470,182330," int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,
                             size_t size)
 {
     GetBitContext gb;
     AC3HeaderInfo *hdr;
     int err;
     if (!*phdr)
         *phdr = av_mallocz(sizeof(AC3HeaderInfo));
     if (!*phdr)
          return AVERROR(ENOMEM);
      hdr = *phdr;
    init_get_bits8(&gb, buf, size);
     err = init_get_bits8(&gb, buf, size);
     if (err < 0)
         return AVERROR_INVALIDDATA;
      err = ff_ac3_parse_header(&gb, hdr);
      if (err < 0)
          return AVERROR_INVALIDDATA;
     return get_bits_count(&gb);
 }","[12, 13, 14, 15]","In FFmpeg 4.0.1, a missing check for failure of a call to init_get_bits8() in the avpriv_ac3_parse_header function in libavcodec/ac3_parser.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.",FFmpeg,CVE-2018-13303,CWE-476
478,183239," sf_open	(const char *path, int mode, SF_INFO *sfinfo)
 {	SF_PRIVATE 	*psf ;
  	assert (sizeof (sf_count_t) == 8) ;
	if ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)
 	if ((psf = psf_allocate ()) == NULL)
  	{	sf_errno = SFE_MALLOC_FAILED ;
  		return	NULL ;
  		} ;
 	psf_init_files (psf) ;
 	psf_log_printf (psf, ""File : %s\n"", path) ;
 	if (copy_filename (psf, path) != 0)
 	{	sf_errno = psf->error ;
 		return	NULL ;
 		} ;
 	psf->file.mode = mode ;
 	if (strcmp (path, ""-"") == 0)
 		psf->error = psf_set_stdio (psf) ;
 	else
 		psf->error = psf_fopen (psf) ;
 	return psf_open_file (psf, sfinfo) ;
 }  ","[4, 5]","In libsndfile before 1.0.28, an error in the *header_read()* function (common.c) when handling ID3 tags can be exploited to cause a stack-based buffer overflow via a specially crafted FLAC file.",libsndfile,CVE-2017-7586,CWE-119
481,179094," int ff_jpeg2000_init_component(Jpeg2000Component *comp,
                                Jpeg2000CodingStyle *codsty,
                                Jpeg2000QuantStyle *qntsty,
                                int cbps, int dx, int dy,
                                AVCodecContext *avctx)
 {
     uint8_t log2_band_prec_width, log2_band_prec_height;
     int reslevelno, bandno, gbandno = 0, ret, i, j;
     uint32_t csize;
     if (codsty->nreslevels2decode <= 0) {
         av_log(avctx, AV_LOG_ERROR, ""nreslevels2decode %d invalid or uninitialized\n"", codsty->nreslevels2decode);
         return AVERROR_INVALIDDATA;
     }
     if (ret = ff_jpeg2000_dwt_init(&comp->dwt, comp->coord,
                                    codsty->nreslevels2decode - 1,
                                    codsty->transform))
         return ret;
     csize = (comp->coord[0][1] - comp->coord[0][0]) *
             (comp->coord[1][1] - comp->coord[1][0]);
     if (codsty->transform == FF_DWT97) {
         comp->i_data = NULL;
         comp->f_data = av_malloc_array(csize, sizeof(*comp->f_data));
         if (!comp->f_data)
             return AVERROR(ENOMEM);
     } else {
         comp->f_data = NULL;
         comp->i_data = av_malloc_array(csize, sizeof(*comp->i_data));
         if (!comp->i_data)
             return AVERROR(ENOMEM);
     }
     comp->reslevel = av_malloc_array(codsty->nreslevels, sizeof(*comp->reslevel));
     if (!comp->reslevel)
         return AVERROR(ENOMEM);
     for (reslevelno = 0; reslevelno < codsty->nreslevels; reslevelno++) {
         int declvl = codsty->nreslevels - reslevelno;     
         Jpeg2000ResLevel *reslevel = comp->reslevel + reslevelno;
         for (i = 0; i < 2; i++)
             for (j = 0; j < 2; j++)
                 reslevel->coord[i][j] =
                     ff_jpeg2000_ceildivpow2(comp->coord_o[i][j], declvl - 1);
         reslevel->log2_prec_width  = codsty->log2_prec_widths[reslevelno];
         reslevel->log2_prec_height = codsty->log2_prec_heights[reslevelno];
         if (reslevelno == 0)
             reslevel->nbands = 1;
         else
             reslevel->nbands = 3;
         if (reslevel->coord[0][1] == reslevel->coord[0][0])
             reslevel->num_precincts_x = 0;
         else
             reslevel->num_precincts_x =
                 ff_jpeg2000_ceildivpow2(reslevel->coord[0][1],
                                         reslevel->log2_prec_width) -
                 (reslevel->coord[0][0] >> reslevel->log2_prec_width);
         if (reslevel->coord[1][1] == reslevel->coord[1][0])
             reslevel->num_precincts_y = 0;
         else
             reslevel->num_precincts_y =
                 ff_jpeg2000_ceildivpow2(reslevel->coord[1][1],
                                          reslevel->log2_prec_height) -
                  (reslevel->coord[1][0] >> reslevel->log2_prec_height);
        reslevel->band = av_malloc_array(reslevel->nbands, sizeof(*reslevel->band));
         reslevel->band = av_calloc(reslevel->nbands, sizeof(*reslevel->band));
          if (!reslevel->band)
              return AVERROR(ENOMEM);
         for (bandno = 0; bandno < reslevel->nbands; bandno++, gbandno++) {
             Jpeg2000Band *band = reslevel->band + bandno;
             int cblkno, precno;
             int nb_precincts;
             switch (qntsty->quantsty) {
                 uint8_t gain;
                 int numbps;
             case JPEG2000_QSTY_NONE:
                 band->f_stepsize = 1;
                 break;
             case JPEG2000_QSTY_SI:
                 numbps = cbps +
                          lut_gain[codsty->transform == FF_DWT53][bandno + (reslevelno > 0)];
                 band->f_stepsize = SHL(2048 + qntsty->mant[gbandno],
                                        2 + numbps - qntsty->expn[gbandno]);
                 break;
             case JPEG2000_QSTY_SE:
                 gain            = cbps;
                 band->f_stepsize  = pow(2.0, gain - qntsty->expn[gbandno]);
                 band->f_stepsize *= qntsty->mant[gbandno] / 2048.0 + 1.0;
                 break;
             default:
                 band->f_stepsize = 0;
                 av_log(avctx, AV_LOG_ERROR, ""Unknown quantization format\n"");
                 break;
             }
             if (!av_codec_is_encoder(avctx->codec))
                 band->f_stepsize *= 0.5;
             band->i_stepsize = band->f_stepsize * (1 << 15);
             if (reslevelno == 0) {
                 for (i = 0; i < 2; i++)
                     for (j = 0; j < 2; j++)
                         band->coord[i][j] =
                             ff_jpeg2000_ceildivpow2(comp->coord_o[i][j] - comp->coord_o[i][0],
                                                     declvl - 1);
                 log2_band_prec_width  = reslevel->log2_prec_width;
                 log2_band_prec_height = reslevel->log2_prec_height;
                 band->log2_cblk_width  = FFMIN(codsty->log2_cblk_width,
                                                reslevel->log2_prec_width);
                 band->log2_cblk_height = FFMIN(codsty->log2_cblk_height,
                                                reslevel->log2_prec_height);
             } else {
                 for (i = 0; i < 2; i++)
                     for (j = 0; j < 2; j++)
                         band->coord[i][j] =
                             ff_jpeg2000_ceildivpow2(comp->coord_o[i][j] - comp->coord_o[i][0] -
                                                     (((bandno + 1 >> i) & 1) << declvl - 1),
                                                     declvl);
                 band->log2_cblk_width  = FFMIN(codsty->log2_cblk_width,
                                                reslevel->log2_prec_width - 1);
                 band->log2_cblk_height = FFMIN(codsty->log2_cblk_height,
                                                reslevel->log2_prec_height - 1);
                 log2_band_prec_width  = reslevel->log2_prec_width  - 1;
                 log2_band_prec_height = reslevel->log2_prec_height - 1;
             }
             for (j = 0; j < 2; j++)
                 band->coord[0][j] = ff_jpeg2000_ceildiv(band->coord[0][j], dx);
              for (j = 0; j < 2; j++)
                  band->coord[1][j] = ff_jpeg2000_ceildiv(band->coord[1][j], dy);
            band->prec = av_malloc_array(reslevel->num_precincts_x *
             band->prec = av_calloc(reslevel->num_precincts_x *
                                           (uint64_t)reslevel->num_precincts_y,
                                           sizeof(*band->prec));
              if (!band->prec)
                 return AVERROR(ENOMEM);
             nb_precincts = reslevel->num_precincts_x * reslevel->num_precincts_y;
             for (precno = 0; precno < nb_precincts; precno++) {
                 Jpeg2000Prec *prec = band->prec + precno;
                 prec->coord[0][0] = (precno % reslevel->num_precincts_x) *
                                     (1 << log2_band_prec_width);
                 prec->coord[0][0] = FFMAX(prec->coord[0][0], band->coord[0][0]);
                 prec->coord[1][0] = (precno / reslevel->num_precincts_x) *
                                     (1 << log2_band_prec_height);
                 prec->coord[1][0] = FFMAX(prec->coord[1][0], band->coord[1][0]);
                 prec->coord[0][1] = prec->coord[0][0] +
                                     (1 << log2_band_prec_width);
                 prec->coord[0][1] = FFMIN(prec->coord[0][1], band->coord[0][1]);
                 prec->coord[1][1] = prec->coord[1][0] +
                                     (1 << log2_band_prec_height);
                 prec->coord[1][1] = FFMIN(prec->coord[1][1], band->coord[1][1]);
                 prec->nb_codeblocks_width =
                     ff_jpeg2000_ceildivpow2(prec->coord[0][1] -
                                             prec->coord[0][0],
                                             band->log2_cblk_width);
                 prec->nb_codeblocks_height =
                     ff_jpeg2000_ceildivpow2(prec->coord[1][1] -
                                             prec->coord[1][0],
                                             band->log2_cblk_height);
                 prec->cblkincl =
                     ff_jpeg2000_tag_tree_init(prec->nb_codeblocks_width,
                                               prec->nb_codeblocks_height);
                 if (!prec->cblkincl)
                     return AVERROR(ENOMEM);
                 prec->zerobits =
                     ff_jpeg2000_tag_tree_init(prec->nb_codeblocks_width,
                                               prec->nb_codeblocks_height);
                 if (!prec->zerobits)
                     return AVERROR(ENOMEM);
                 prec->cblk = av_mallocz_array(prec->nb_codeblocks_width *
                                               (uint64_t)prec->nb_codeblocks_height,
                                               sizeof(*prec->cblk));
                 if (!prec->cblk)
                     return AVERROR(ENOMEM);
                 for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) {
                     Jpeg2000Cblk *cblk = prec->cblk + cblkno;
                     uint16_t Cx0, Cy0;
                     Cx0 = (prec->coord[0][0] >> band->log2_cblk_width) << band->log2_cblk_width;
                     Cx0 = Cx0 + ((cblkno % prec->nb_codeblocks_width)  << band->log2_cblk_width);
                     cblk->coord[0][0] = FFMAX(Cx0, prec->coord[0][0]);
                     Cy0 = (prec->coord[1][0] >> band->log2_cblk_height) << band->log2_cblk_height;
                     Cy0 = Cy0 + ((cblkno / prec->nb_codeblocks_width)   << band->log2_cblk_height);
                     cblk->coord[1][0] = FFMAX(Cy0, prec->coord[1][0]);
                     cblk->coord[0][1] = FFMIN(Cx0 + (1 << band->log2_cblk_width),
                                               prec->coord[0][1]);
                     cblk->coord[1][1] = FFMIN(Cy0 + (1 << band->log2_cblk_height),
                                               prec->coord[1][1]);
                     if ((bandno + !!reslevelno) & 1) {
                         cblk->coord[0][0] += comp->reslevel[reslevelno-1].coord[0][1] -
                                              comp->reslevel[reslevelno-1].coord[0][0];
                         cblk->coord[0][1] += comp->reslevel[reslevelno-1].coord[0][1] -
                                              comp->reslevel[reslevelno-1].coord[0][0];
                     }
                     if ((bandno + !!reslevelno) & 2) {
                         cblk->coord[1][0] += comp->reslevel[reslevelno-1].coord[1][1] -
                                              comp->reslevel[reslevelno-1].coord[1][0];
                         cblk->coord[1][1] += comp->reslevel[reslevelno-1].coord[1][1] -
                                              comp->reslevel[reslevelno-1].coord[1][0];
                     }
                     cblk->zero      = 0;
                     cblk->lblock    = 3;
                     cblk->length    = 0;
                     cblk->lengthinc = 0;
                     cblk->npasses   = 0;
                 }
             }
         }
     }
     return 0;
 }","[61, 62, 124, 125]",libavcodec/jpeg2000.c in FFmpeg before 2.1 allows remote attackers to cause a denial of service (invalid pointer dereference) or possibly have unspecified other impact via crafted JPEG2000 data.,FFmpeg,CVE-2013-7017,
497,177824," static int dns_parse_callback(void *c, int rr, const void *data, int len, const void *packet)
  {
  	char tmp[256];
  	struct dpc_ctx *ctx = c;
 	if (ctx->cnt >= MAXADDRS) return -1;
  	switch (rr) {
  	case RR_A:
  		if (len != 4) return -1;
 		ctx->addrs[ctx->cnt].scopeid = 0;
 		memcpy(ctx->addrs[ctx->cnt++].addr, data, 4);
 		break;
 	case RR_AAAA:
 		if (len != 16) return -1;
 		ctx->addrs[ctx->cnt].family = AF_INET6;
 		ctx->addrs[ctx->cnt].scopeid = 0;
 		memcpy(ctx->addrs[ctx->cnt++].addr, data, 16);
 		break;
 	case RR_CNAME:
 		if (__dn_expand(packet, (const unsigned char *)packet + 512,
 		    data, tmp, sizeof tmp) > 0 && is_valid_hostname(tmp))
 			strcpy(ctx->canon, tmp);
 		break;
 	}
 	return 0;
 }",[5],"musl libc before 1.1.17 has a buffer overflow via crafted DNS replies because dns_parse_callback in network/lookup_name.c does not restrict the number of addresses, and thus an attacker can provide an unexpected number by sending A records in a reply to an AAAA query.",musl,CVE-2017-15650,CWE-119
510,178608," XineramaXvShmPutImage(ClientPtr client)
  {
      REQUEST(xvShmPutImageReq);
      PanoramiXRes *draw, *gc, *port;
    Bool send_event = stuff->send_event;
     Bool send_event;
      Bool isRoot;
      int result, i, x, y;
      REQUEST_SIZE_MATCH(xvShmPutImageReq);
     send_event = stuff->send_event;
      result = dixLookupResourceByClass((void **) &draw, stuff->drawable,
                                        XRC_DRAWABLE, client, DixWriteAccess);
      if (result != Success)
     result = dixLookupResourceByType((void **) &gc, stuff->gc,
                                      XRT_GC, client, DixReadAccess);
     if (result != Success)
         return result;
     result = dixLookupResourceByType((void **) &port, stuff->port,
                                      XvXRTPort, client, DixReadAccess);
     if (result != Success)
         return result;
     isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;
     x = stuff->drw_x;
     y = stuff->drw_y;
     FOR_NSCREENS_BACKWARD(i) {
         if (port->info[i].id) {
             stuff->drawable = draw->info[i].id;
             stuff->port = port->info[i].id;
             stuff->gc = gc->info[i].id;
             stuff->drw_x = x;
             stuff->drw_y = y;
             if (isRoot) {
                 stuff->drw_x -= screenInfo.screens[i]->x;
                 stuff->drw_y -= screenInfo.screens[i]->y;
             }
             stuff->send_event = (send_event && !i) ? 1 : 0;
             result = ProcXvShmPutImage(client);
         }
     }
     return result;
 }","[5, 6, 10]",xorg-x11-server before 1.19.5 was missing length validation in RENDER extension allowing malicious X client to cause X server to crash or possibly execute arbitrary code.,xserver,CVE-2017-12187,CWE-20
519,179879," static int cg_opendir(const char *path, struct fuse_file_info *fi)
 {
 	struct fuse_context *fc = fuse_get_context();
 	const char *cgroup;
 	struct file_info *dir_info;
 	char *controller = NULL;
 	if (!fc)
 		return -EIO;
 	if (strcmp(path, ""/cgroup"") == 0) {
 		cgroup = NULL;
 		controller = NULL;
 	} else {
 		controller = pick_controller_from_path(fc, path);
 		if (!controller)
 			return -EIO;
 		cgroup = find_cgroup_in_path(path);
 		if (!cgroup) {
 			cgroup = ""/"";
  		}
  	}
	if (cgroup && !fc_may_access(fc, controller, cgroup, NULL, O_RDONLY)) {
		return -EACCES;
 	if (cgroup) {
 		if (!caller_may_see_dir(fc->pid, controller, cgroup))
 			return -ENOENT;
 		if (!fc_may_access(fc, controller, cgroup, NULL, O_RDONLY))
 			return -EACCES;
  	}
 	dir_info = malloc(sizeof(*dir_info));
 	if (!dir_info)
 		return -ENOMEM;
 	dir_info->controller = must_copy_string(controller);
 	dir_info->cgroup = must_copy_string(cgroup);
 	dir_info->type = LXC_TYPE_CGDIR;
 	dir_info->buf = NULL;
 	dir_info->file = NULL;
 	dir_info->buflen = 0;
 	fi->fh = (unsigned long)dir_info;
 	return 0;
 }","[21, 22, 23, 24, 25, 26, 27]","LXCFS before 0.12 does not properly enforce directory escapes, which might allow local users to gain privileges by (1) querying or (2) updating a cgroup.",lxcfs,CVE-2015-1342,CWE-264
559,181217," int yr_object_array_set_item(
     YR_OBJECT* object,
     YR_OBJECT* item,
     int index)
 {
   YR_OBJECT_ARRAY* array;
   int i;
   int count;
   assert(index >= 0);
   assert(object->type == OBJECT_TYPE_ARRAY);
   array = object_as_array(object);
    if (array->items == NULL)
    {
    count = yr_max(64, (index + 1) * 2);
     count = 64;
     while (count <= index)
       count *= 2;
      array->items = (YR_ARRAY_ITEMS*) yr_malloc(
          sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));
     if (array->items == NULL)
       return ERROR_INSUFFICIENT_MEMORY;
     memset(array->items->objects, 0, count * sizeof(YR_OBJECT*));
     array->items->count = count;
   }
    else if (index >= array->items->count)
    {
      count = array->items->count * 2;
     while (count <= index)
       count *= 2;
      array->items = (YR_ARRAY_ITEMS*) yr_realloc(
          array->items,
          sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));
     if (array->items == NULL)
       return ERROR_INSUFFICIENT_MEMORY;
     for (i = array->items->count; i < count; i++)
       array->items->objects[i] = NULL;
     array->items->count = count;
   }
   item->parent = object;
   array->items->objects[index] = item;
   return ERROR_SUCCESS;
 }","[14, 15, 16, 17, 28, 29]",Heap buffer overflow in the yr_object_array_set_item() function in object.c in YARA 3.x allows a denial-of-service attack by scanning a crafted .NET file.,yara,CVE-2017-11328,CWE-119
585,181673," static int http_read_stream(URLContext *h, uint8_t *buf, int size)
 {
     HTTPContext *s = h->priv_data;
     int err, new_location, read_ret;
     int64_t seek_ret;
     if (!s->hd)
         return AVERROR_EOF;
     if (s->end_chunked_post && !s->end_header) {
         err = http_read_header(h, &new_location);
         if (err < 0)
              return err;
      }
    if (s->chunksize >= 0) {
     if (s->chunksize != UINT64_MAX) {
          if (!s->chunksize) {
              char line[32];
                 do {
                     if ((err = http_get_line(s, line, sizeof(line))) < 0)
                          return err;
                  } while (!*line);     
                s->chunksize = strtoll(line, NULL, 16);
                 s->chunksize = strtoull(line, NULL, 16);
                av_log(NULL, AV_LOG_TRACE, ""Chunked encoding data size: %""PRId64""'\n"",
                 av_log(h, AV_LOG_TRACE,
                        ""Chunked encoding data size: %""PRIu64""'\n"",
                          s->chunksize);
                  if (!s->chunksize)
                      return 0;
                 else if (s->chunksize == UINT64_MAX) {
                     av_log(h, AV_LOG_ERROR, ""Invalid chunk size %""PRIu64""\n"",
                            s->chunksize);
                     return AVERROR(EINVAL);
                 }
          }
          size = FFMIN(size, s->chunksize);
      }
 #if CONFIG_ZLIB
     if (s->compressed)
         return http_buf_read_compressed(h, buf, size);
 #endif  
      read_ret = http_buf_read(h, buf, size);
      if (   (read_ret  < 0 && s->reconnect        && (!h->is_streamed || s->reconnect_streamed) && s->filesize > 0 && s->off < s->filesize)
          || (read_ret == 0 && s->reconnect_at_eof && (!h->is_streamed || s->reconnect_streamed))) {
        int64_t target = h->is_streamed ? 0 : s->off;
         uint64_t target = h->is_streamed ? 0 : s->off;
          if (s->reconnect_delay > s->reconnect_delay_max)
              return AVERROR(EIO);
        av_log(h, AV_LOG_INFO, ""Will reconnect at %""PRId64"" error=%s.\n"", s->off, av_err2str(read_ret));
         av_log(h, AV_LOG_INFO, ""Will reconnect at %""PRIu64"" error=%s.\n"", s->off, av_err2str(read_ret));
          av_usleep(1000U*1000*s->reconnect_delay);
          s->reconnect_delay = 1 + 2*s->reconnect_delay;
          seek_ret = http_seek_internal(h, target, SEEK_SET, 1);
          if (seek_ret != target) {
            av_log(h, AV_LOG_ERROR, ""Failed to reconnect at %""PRId64"".\n"", target);
             av_log(h, AV_LOG_ERROR, ""Failed to reconnect at %""PRIu64"".\n"", target);
              return read_ret;
          }
         read_ret = http_buf_read(h, buf, size);
     } else
         s->reconnect_delay = 0;
     return read_ret;
 }","[13, 14, 21, 22, 23, 24, 25, 29, 30, 31, 32, 33, 44, 45, 48, 49, 54, 55]","Heap-based buffer overflow in libavformat/http.c in FFmpeg before 2.8.10, 3.0.x before 3.0.5, 3.1.x before 3.1.6, and 3.2.x before 3.2.2 allows remote web servers to execute arbitrary code via a negative chunk size in an HTTP response.",FFmpeg,CVE-2016-10190,CWE-119
613,182441," int_x509_param_set_hosts(X509_VERIFY_PARAM_ID *id, int mode,
     const char *name, size_t namelen)
  {
  	char *copy;
 	if (name != NULL && namelen == 0)
 		namelen = strlen(name);
 	if (name && memchr(name, '\0', namelen))
 		return 0;
 	if (mode == SET_HOST && id->hosts) {
 		string_stack_free(id->hosts);
 		id->hosts = NULL;
 	}
 	if (name == NULL || namelen == 0)
 		return 1;
 	copy = strndup(name, namelen);
 	if (copy == NULL)
 		return 0;
 	if (id->hosts == NULL &&
 	    (id->hosts = sk_OPENSSL_STRING_new_null()) == NULL) {
 		free(copy);
 		return 0;
 	}
 	if (!sk_OPENSSL_STRING_push(id->hosts, copy)) {
 		free(copy);
 		if (sk_OPENSSL_STRING_num(id->hosts) == 0) {
 			sk_OPENSSL_STRING_free(id->hosts);
 			id->hosts = NULL;
 		}
 		return 0;
 	}
 	return 1;
 }","[5, 6]","The int_x509_param_set_hosts function in lib/libcrypto/x509/x509_vpm.c in LibreSSL 2.7.0 before 2.7.1 does not support a certain special case of a zero name length, which causes silent omission of hostname verification, and consequently allows man-in-the-middle attackers to spoof servers and obtain sensitive information via a crafted certificate. NOTE: the LibreSSL documentation indicates that this special case is supported, but the BoringSSL documentation does not.",openbsd,CVE-2018-8970,CWE-295
623,181857,"  static int jas_iccgetuint16(jas_stream_t *in, jas_iccuint16_t *val)
  {
	ulonglong tmp;
 	jas_ulonglong tmp;
  	if (jas_iccgetuint(in, 2, &tmp))
  		return -1;
  	*val = tmp;
 	return 0;
 }","[3, 4]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
647,179038," const char *string_of_NPPVariable(int variable)
 {
   const char *str;
   switch (variable) {
 #define _(VAL) case VAL: str = #VAL; break;
 	_(NPPVpluginNameString);
 	_(NPPVpluginDescriptionString);
 	_(NPPVpluginWindowBool);
 	_(NPPVpluginTransparentBool);
 	_(NPPVjavaClass);
 	_(NPPVpluginWindowSize);
 	_(NPPVpluginTimerInterval);
 	_(NPPVpluginScriptableInstance);
 	_(NPPVpluginScriptableIID);
 	_(NPPVjavascriptPushCallerBool);
 	_(NPPVpluginKeepLibraryInMemory);
  	_(NPPVpluginNeedsXEmbed);
  	_(NPPVpluginScriptableNPObject);
  	_(NPPVformValue);
 	_(NPPVpluginUrlRequestsDisplayedBool);
 	_(NPPVpluginWantsAllNetworkStreams);
 	_(NPPVpluginNativeAccessibleAtkPlugId);
 	_(NPPVpluginCancelSrcStream);
 	_(NPPVSupportsAdvancedKeyHandling);
  #undef _
    default:
  	switch (variable & 0xff) {
 #define _(VAL, VAR) case VAL: str = #VAR; break
 	  _(10, NPPVpluginScriptableInstance);
 #undef _
 	default:
 	  str = ""<unknown variable>"";
 	  break;
 	}
 	break;
   }
   return str;
 }","[20, 21, 22, 23, 24]","nspluginwrapper before 1.4.4 does not properly provide access to NPNVprivateModeBool variable settings, which could prevent Firefox plugins from determining if they should run in Private Browsing mode and allow remote attackers to bypass intended access restrictions, as demonstrated using Flash.",nspluginwrapper,CVE-2011-2486,CWE-264
656,182703," internalEntityProcessor(XML_Parser parser, const char *s, const char *end,
                         const char **nextPtr) {
   ENTITY *entity;
   const char *textStart, *textEnd;
   const char *next;
   enum XML_Error result;
   OPEN_INTERNAL_ENTITY *openEntity = parser->m_openInternalEntities;
   if (! openEntity)
     return XML_ERROR_UNEXPECTED_STATE;
   entity = openEntity->entity;
   textStart = ((char *)entity->textPtr) + entity->processed;
   textEnd = (char *)(entity->textPtr + entity->textLen);
   next = textStart;
 #ifdef XML_DTD
   if (entity->is_param) {
      int tok
          = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);
      result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,
                      tok, next, &next, XML_FALSE);
                       tok, next, &next, XML_FALSE, XML_TRUE);
    } else
  #endif  
      result = doContent(parser, openEntity->startTagLevel,
                        parser->m_internalEncoding, textStart, textEnd, &next,
                        XML_FALSE);
   if (result != XML_ERROR_NONE)
     return result;
   else if (textEnd != next
            && parser->m_parsingStatus.parsing == XML_SUSPENDED) {
     entity->processed = (int)(next - (char *)entity->textPtr);
     return result;
   } else {
     entity->open = XML_FALSE;
     parser->m_openInternalEntities = openEntity->next;
     openEntity->next = parser->m_freeInternalEntities;
     parser->m_freeInternalEntities = openEntity;
   }
 #ifdef XML_DTD
   if (entity->is_param) {
     int tok;
      parser->m_processor = prologProcessor;
      tok = XmlPrologTok(parser->m_encoding, s, end, &next);
      return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,
                    (XML_Bool)! parser->m_parsingStatus.finalBuffer);
                     (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE);
    } else
  #endif  
    {
     parser->m_processor = contentProcessor;
     return doContent(parser, parser->m_parentParser ? 1 : 0, parser->m_encoding,
                      s, end, nextPtr,
                      (XML_Bool)! parser->m_parsingStatus.finalBuffer);
   }
 }","[19, 20, 44, 45]","In libexpat before 2.2.8, crafted XML input could fool the parser into changing from DTD parsing to document parsing too early; a consecutive call to XML_GetCurrentLineNumber (or XML_GetCurrentColumnNumber) then resulted in a heap-based buffer over-read.",libexpat,CVE-2019-15903,CWE-611
662,182552," add_job(cupsd_client_t  *con,		 
 	cupsd_printer_t *printer,	 
 	mime_type_t     *filetype)	 
 {
   http_status_t	status;			 
   ipp_attribute_t *attr,		 
 		*auth_info;		 
   const char	*mandatory;		 
   const char	*val;			 
   int		priority;		 
   cupsd_job_t	*job;			 
   char		job_uri[HTTP_MAX_URI];	 
   int		kbytes;			 
   int		i;			 
   int		lowerpagerange;		 
   int		exact;			 
   ipp_attribute_t *media_col,		 
 		*media_margin;		 
   ipp_t		*unsup_col;		 
   static const char * const readonly[] = 
   {
     ""date-time-at-completed"",
     ""date-time-at-creation"",
     ""date-time-at-processing"",
     ""job-detailed-status-messages"",
     ""job-document-access-errors"",
     ""job-id"",
     ""job-impressions-completed"",
     ""job-k-octets-completed"",
     ""job-media-sheets-completed"",
     ""job-pages-completed"",
     ""job-printer-up-time"",
     ""job-printer-uri"",
     ""job-state"",
     ""job-state-message"",
     ""job-state-reasons"",
     ""job-uri"",
     ""number-of-documents"",
     ""number-of-intervening-jobs"",
     ""output-device-assigned"",
     ""time-at-completed"",
     ""time-at-creation"",
     ""time-at-processing""
   };
   cupsdLogMessage(CUPSD_LOG_DEBUG2, ""add_job(%p[%d], %p(%s), %p(%s/%s))"",
                   con, con->number, printer, printer->name,
 		  filetype, filetype ? filetype->super : ""none"",
 		  filetype ? filetype->type : ""none"");
   if (!printer->shared &&
       _cups_strcasecmp(con->http->hostname, ""localhost"") &&
       _cups_strcasecmp(con->http->hostname, ServerName))
   {
     send_ipp_status(con, IPP_NOT_AUTHORIZED,
                     _(""The printer or class is not shared.""));
     return (NULL);
   }
   auth_info = ippFindAttribute(con->request, ""auth-info"", IPP_TAG_TEXT);
   if ((status = cupsdCheckPolicy(printer->op_policy_ptr, con, NULL)) != HTTP_OK)
   {
     send_http_error(con, status, printer);
     return (NULL);
   }
   else if (printer->num_auth_info_required == 1 &&
            !strcmp(printer->auth_info_required[0], ""negotiate"") &&
            !con->username[0])
   {
     send_http_error(con, HTTP_UNAUTHORIZED, printer);
     return (NULL);
   }
 #ifdef HAVE_SSL
   else if (auth_info && !con->http->tls &&
            !httpAddrLocalhost(con->http->hostaddr))
   {
     send_http_error(con, HTTP_UPGRADE_REQUIRED, printer);
     return (NULL);
   }
 #endif  
   if (!printer->accepting)
   {
     send_ipp_status(con, IPP_NOT_ACCEPTING,
                     _(""Destination \""%s\"" is not accepting jobs.""),
                     printer->name);
     return (NULL);
   }
   for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++)
   {
     if ((attr = ippFindAttribute(con->request, readonly[i], IPP_TAG_ZERO)) != NULL)
     {
       ippDeleteAttribute(con->request, attr);
       if (StrictConformance)
       {
 	send_ipp_status(con, IPP_BAD_REQUEST, _(""The '%s' Job Status attribute cannot be supplied in a job creation request.""), readonly[i]);
 	return (NULL);
       }
       cupsdLogMessage(CUPSD_LOG_INFO, ""Unexpected '%s' Job Status attribute in a job creation request."", readonly[i]);
     }
   }
   if (printer->pc)
   {
     for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
 	 mandatory;
 	 mandatory = (char *)cupsArrayNext(printer->pc->mandatory))
     {
       if (!ippFindAttribute(con->request, mandatory, IPP_TAG_ZERO))
       {
 	send_ipp_status(con, IPP_CONFLICT,
 			_(""The \""%s\"" attribute is required for print jobs.""),
 			mandatory);
 	return (NULL);
       }
     }
   }
   if (filetype && printer->filetypes &&
       !cupsArrayFind(printer->filetypes, filetype))
   {
     char	mimetype[MIME_MAX_SUPER + MIME_MAX_TYPE + 2];
     snprintf(mimetype, sizeof(mimetype), ""%s/%s"", filetype->super,
              filetype->type);
     send_ipp_status(con, IPP_DOCUMENT_FORMAT,
                     _(""Unsupported format \""%s\"".""), mimetype);
     ippAddString(con->response, IPP_TAG_UNSUPPORTED_GROUP, IPP_TAG_MIMETYPE,
                  ""document-format"", NULL, mimetype);
     return (NULL);
   }
   if ((attr = ippFindAttribute(con->request, ""copies"",
                                IPP_TAG_INTEGER)) != NULL)
   {
     if (attr->values[0].integer < 1 || attr->values[0].integer > MaxCopies)
     {
       send_ipp_status(con, IPP_ATTRIBUTES, _(""Bad copies value %d.""),
                       attr->values[0].integer);
       ippAddInteger(con->response, IPP_TAG_UNSUPPORTED_GROUP, IPP_TAG_INTEGER,
 	            ""copies"", attr->values[0].integer);
       return (NULL);
     }
   }
   if ((attr = ippFindAttribute(con->request, ""job-sheets"",
                                IPP_TAG_ZERO)) != NULL)
   {
     if (attr->value_tag != IPP_TAG_KEYWORD &&
         attr->value_tag != IPP_TAG_NAME)
     {
       send_ipp_status(con, IPP_BAD_REQUEST, _(""Bad job-sheets value type.""));
       return (NULL);
     }
     if (attr->num_values > 2)
     {
       send_ipp_status(con, IPP_BAD_REQUEST,
                       _(""Too many job-sheets values (%d > 2).""),
 		      attr->num_values);
       return (NULL);
     }
     for (i = 0; i < attr->num_values; i ++)
       if (strcmp(attr->values[i].string.text, ""none"") &&
           !cupsdFindBanner(attr->values[i].string.text))
       {
 	send_ipp_status(con, IPP_BAD_REQUEST, _(""Bad job-sheets value \""%s\"".""),
 			attr->values[i].string.text);
 	return (NULL);
       }
   }
   if ((attr = ippFindAttribute(con->request, ""number-up"",
                                IPP_TAG_INTEGER)) != NULL)
   {
     if (attr->values[0].integer != 1 &&
         attr->values[0].integer != 2 &&
         attr->values[0].integer != 4 &&
         attr->values[0].integer != 6 &&
         attr->values[0].integer != 9 &&
         attr->values[0].integer != 16)
     {
       send_ipp_status(con, IPP_ATTRIBUTES, _(""Bad number-up value %d.""),
                       attr->values[0].integer);
       ippAddInteger(con->response, IPP_TAG_UNSUPPORTED_GROUP, IPP_TAG_INTEGER,
 	            ""number-up"", attr->values[0].integer);
       return (NULL);
     }
   }
   if ((attr = ippFindAttribute(con->request, ""page-ranges"",
                                IPP_TAG_RANGE)) != NULL)
   {
     for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++)
     {
       if (attr->values[i].range.lower < lowerpagerange ||
 	  attr->values[i].range.lower > attr->values[i].range.upper)
       {
 	send_ipp_status(con, IPP_BAD_REQUEST,
 	                _(""Bad page-ranges values %d-%d.""),
 	                attr->values[i].range.lower,
 			attr->values[i].range.upper);
 	return (NULL);
       }
       lowerpagerange = attr->values[i].range.upper + 1;
     }
   }
   if (!ippFindAttribute(con->request, ""PageRegion"", IPP_TAG_ZERO) &&
       !ippFindAttribute(con->request, ""PageSize"", IPP_TAG_ZERO) &&
       _ppdCacheGetPageSize(printer->pc, con->request, NULL, &exact))
   {
     if (!exact &&
         (media_col = ippFindAttribute(con->request, ""media-col"",
 	                              IPP_TAG_BEGIN_COLLECTION)) != NULL)
     {
       send_ipp_status(con, IPP_OK_SUBST, _(""Unsupported margins.""));
       unsup_col = ippNew();
       if ((media_margin = ippFindAttribute(media_col->values[0].collection,
                                            ""media-bottom-margin"",
 					   IPP_TAG_INTEGER)) != NULL)
         ippAddInteger(unsup_col, IPP_TAG_ZERO, IPP_TAG_INTEGER,
 	              ""media-bottom-margin"", media_margin->values[0].integer);
       if ((media_margin = ippFindAttribute(media_col->values[0].collection,
                                            ""media-left-margin"",
 					   IPP_TAG_INTEGER)) != NULL)
         ippAddInteger(unsup_col, IPP_TAG_ZERO, IPP_TAG_INTEGER,
 	              ""media-left-margin"", media_margin->values[0].integer);
       if ((media_margin = ippFindAttribute(media_col->values[0].collection,
                                            ""media-right-margin"",
 					   IPP_TAG_INTEGER)) != NULL)
         ippAddInteger(unsup_col, IPP_TAG_ZERO, IPP_TAG_INTEGER,
 	              ""media-right-margin"", media_margin->values[0].integer);
       if ((media_margin = ippFindAttribute(media_col->values[0].collection,
                                            ""media-top-margin"",
 					   IPP_TAG_INTEGER)) != NULL)
         ippAddInteger(unsup_col, IPP_TAG_ZERO, IPP_TAG_INTEGER,
 	              ""media-top-margin"", media_margin->values[0].integer);
       ippAddCollection(con->response, IPP_TAG_UNSUPPORTED_GROUP, ""media-col"",
                        unsup_col);
       ippDelete(unsup_col);
     }
   }
   if (MaxJobs && cupsArrayCount(Jobs) >= MaxJobs)
     cupsdCleanJobs();
   if (MaxJobs && cupsArrayCount(Jobs) >= MaxJobs)
   {
     send_ipp_status(con, IPP_NOT_POSSIBLE, _(""Too many active jobs.""));
     return (NULL);
   }
   if ((i = check_quotas(con, printer)) < 0)
   {
     send_ipp_status(con, IPP_NOT_POSSIBLE, _(""Quota limit reached.""));
     return (NULL);
   }
   else if (i == 0)
   {
     send_ipp_status(con, IPP_NOT_AUTHORIZED, _(""Not allowed to print.""));
     return (NULL);
   }
   if ((attr = ippFindAttribute(con->request, ""job-priority"",
                                IPP_TAG_INTEGER)) != NULL)
     priority = attr->values[0].integer;
   else
   {
     if ((val = cupsGetOption(""job-priority"", printer->num_options,
                              printer->options)) != NULL)
       priority = atoi(val);
     else
       priority = 50;
     ippAddInteger(con->request, IPP_TAG_JOB, IPP_TAG_INTEGER, ""job-priority"",
                   priority);
   }
   if ((attr = ippFindAttribute(con->request, ""job-name"", IPP_TAG_ZERO)) == NULL)
     ippAddString(con->request, IPP_TAG_JOB, IPP_TAG_NAME, ""job-name"", NULL, ""Untitled"");
   else if ((attr->value_tag != IPP_TAG_NAME &&
             attr->value_tag != IPP_TAG_NAMELANG) ||
            attr->num_values != 1)
   {
     send_ipp_status(con, IPP_ATTRIBUTES,
                     _(""Bad job-name value: Wrong type or count.""));
     if ((attr = ippCopyAttribute(con->response, attr, 0)) != NULL)
       attr->group_tag = IPP_TAG_UNSUPPORTED_GROUP;
     return (NULL);
   }
   else if (!ippValidateAttribute(attr))
   {
     send_ipp_status(con, IPP_ATTRIBUTES, _(""Bad job-name value: %s""),
                     cupsLastErrorString());
     if ((attr = ippCopyAttribute(con->response, attr, 0)) != NULL)
       attr->group_tag = IPP_TAG_UNSUPPORTED_GROUP;
      return (NULL);
    }
   attr = ippFindAttribute(con->request, ""requesting-user-name"", IPP_TAG_NAME);
   if (attr && !ippValidateAttribute(attr))
   {
     send_ipp_status(con, IPP_ATTRIBUTES, _(""Bad requesting-user-name value: %s""), cupsLastErrorString());
     if ((attr = ippCopyAttribute(con->response, attr, 0)) != NULL)
       attr->group_tag = IPP_TAG_UNSUPPORTED_GROUP;
     return (NULL);
   }
    if ((job = cupsdAddJob(priority, printer->name)) == NULL)
    {
      send_ipp_status(con, IPP_INTERNAL_ERROR,
                     _(""Unable to add job for destination \""%s\"".""),
 		    printer->name);
     return (NULL);
   }
   job->dtype   = printer->type & (CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE);
   job->attrs   = con->request;
   job->dirty   = 1;
   con->request = ippNewRequest(job->attrs->request.op.operation_id);
   cupsdMarkDirty(CUPSD_DIRTY_JOBS);
    add_job_uuid(job);
    apply_printer_defaults(printer, job);
  attr = ippFindAttribute(job->attrs, ""requesting-user-name"", IPP_TAG_NAME);
    if (con->username[0])
    {
      cupsdSetString(&job->username, con->username);
     if (attr)
       ippSetString(job->attrs, &attr, 0, con->username);
   }
   else if (attr)
   {
     cupsdLogMessage(CUPSD_LOG_DEBUG,
                     ""add_job: requesting-user-name=\""%s\"""",
                     attr->values[0].string.text);
     cupsdSetString(&job->username, attr->values[0].string.text);
   }
   else
     cupsdSetString(&job->username, ""anonymous"");
   if (!attr)
     ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_NAME,
                  ""job-originating-user-name"", NULL, job->username);
   else
   {
     ippSetGroupTag(job->attrs, &attr, IPP_TAG_JOB);
     ippSetName(job->attrs, &attr, ""job-originating-user-name"");
   }
   if (con->username[0] || auth_info)
   {
     save_auth_info(con, job, auth_info);
     if (auth_info)
       ippDeleteAttribute(job->attrs, auth_info);
   }
   if ((attr = ippFindAttribute(con->request, ""job-name"", IPP_TAG_NAME)) != NULL)
     cupsdSetString(&(job->name), attr->values[0].string.text);
   if ((attr = ippFindAttribute(job->attrs, ""job-originating-host-name"",
                                IPP_TAG_ZERO)) != NULL)
   {
     if (attr->value_tag != IPP_TAG_NAME ||
         attr->num_values != 1 ||
         strcmp(con->http->hostname, ""localhost""))
     {
       ippDeleteAttribute(job->attrs, attr);
       ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_NAME, ""job-originating-host-name"", NULL, con->http->hostname);
     }
     else
       ippSetGroupTag(job->attrs, &attr, IPP_TAG_JOB);
   }
   else
   {
     ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_NAME,
         	 ""job-originating-host-name"", NULL, con->http->hostname);
   }
   ippAddOutOfBand(job->attrs, IPP_TAG_JOB, IPP_TAG_NOVALUE, ""date-time-at-completed"");
   ippAddDate(job->attrs, IPP_TAG_JOB, ""date-time-at-creation"", ippTimeToDate(time(NULL)));
   ippAddOutOfBand(job->attrs, IPP_TAG_JOB, IPP_TAG_NOVALUE, ""date-time-at-processing"");
   ippAddOutOfBand(job->attrs, IPP_TAG_JOB, IPP_TAG_NOVALUE, ""time-at-completed"");
   ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_INTEGER, ""time-at-creation"", time(NULL));
   ippAddOutOfBand(job->attrs, IPP_TAG_JOB, IPP_TAG_NOVALUE, ""time-at-processing"");
   ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_INTEGER, ""job-id"", job->id);
   job->state = ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_ENUM,
                              ""job-state"", IPP_JOB_STOPPED);
   job->state_value = (ipp_jstate_t)job->state->values[0].integer;
   job->reasons = ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_KEYWORD,
                               ""job-state-reasons"", NULL, ""job-incoming"");
   job->impressions = ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_INTEGER, ""job-impressions-completed"", 0);
   job->sheets = ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_INTEGER,
                               ""job-media-sheets-completed"", 0);
   ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_URI, ""job-printer-uri"", NULL,
                printer->uri);
   if ((attr = ippFindAttribute(job->attrs, ""job-k-octets"", IPP_TAG_INTEGER)) != NULL)
     attr->values[0].integer = 0;
   else
     ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_INTEGER, ""job-k-octets"", 0);
   if ((attr = ippFindAttribute(job->attrs, ""job-hold-until"",
                                IPP_TAG_KEYWORD)) == NULL)
     attr = ippFindAttribute(job->attrs, ""job-hold-until"", IPP_TAG_NAME);
   if (!attr)
   {
     if ((val = cupsGetOption(""job-hold-until"", printer->num_options,
                              printer->options)) == NULL)
       val = ""no-hold"";
     attr = ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_KEYWORD,
                         ""job-hold-until"", NULL, val);
   }
   if (printer->holding_new_jobs)
   {
     if (attr && strcmp(attr->values[0].string.text, ""no-hold""))
       cupsdSetJobHoldUntil(job, ippGetString(attr, 0, NULL), 0);
     else
       cupsdSetJobHoldUntil(job, ""indefinite"", 0);
     job->state->values[0].integer = IPP_JOB_HELD;
     job->state_value              = IPP_JOB_HELD;
     ippSetString(job->attrs, &job->reasons, 0, ""job-held-on-create"");
   }
   else if (attr && strcmp(attr->values[0].string.text, ""no-hold""))
   {
     cupsdSetJobHoldUntil(job, attr->values[0].string.text, 0);
     job->state->values[0].integer = IPP_JOB_HELD;
     job->state_value              = IPP_JOB_HELD;
     ippSetString(job->attrs, &job->reasons, 0, ""job-hold-until-specified"");
   }
   else if (job->attrs->request.op.operation_id == IPP_CREATE_JOB)
   {
     job->hold_until               = time(NULL) + MultipleOperationTimeout;
     job->state->values[0].integer = IPP_JOB_HELD;
     job->state_value              = IPP_JOB_HELD;
   }
   else
   {
     job->state->values[0].integer = IPP_JOB_PENDING;
     job->state_value              = IPP_JOB_PENDING;
     ippSetString(job->attrs, &job->reasons, 0, ""none"");
   }
   if (!(printer->type & CUPS_PRINTER_REMOTE) || Classification)
   {
     if ((attr = ippFindAttribute(job->attrs, ""job-sheets"",
                                  IPP_TAG_ZERO)) == NULL)
     {
       cupsdLogMessage(CUPSD_LOG_DEBUG,
                       ""Adding default job-sheets values \""%s,%s\""..."",
                       printer->job_sheets[0], printer->job_sheets[1]);
       attr = ippAddStrings(job->attrs, IPP_TAG_JOB, IPP_TAG_NAME, ""job-sheets"",
                            2, NULL, NULL);
       ippSetString(job->attrs, &attr, 0, printer->job_sheets[0]);
       ippSetString(job->attrs, &attr, 1, printer->job_sheets[1]);
     }
     job->job_sheets = attr;
     if (Classification)
     {
       cupsdLogMessage(CUPSD_LOG_INFO,
                       ""Classification=\""%s\"", ClassifyOverride=%d"",
                       Classification ? Classification : ""(null)"",
 		      ClassifyOverride);
       if (ClassifyOverride)
       {
         if (!strcmp(attr->values[0].string.text, ""none"") &&
 	    (attr->num_values == 1 ||
 	     !strcmp(attr->values[1].string.text, ""none"")))
         {
           ippSetString(job->attrs, &attr, 0, Classification);
 	  cupsdLogJob(job, CUPSD_LOG_NOTICE, ""CLASSIFICATION FORCED ""
 	                		     ""job-sheets=\""%s,none\"", ""
 					     ""job-originating-user-name=\""%s\"""",
 	              Classification, job->username);
 	}
 	else if (attr->num_values == 2 &&
 	         strcmp(attr->values[0].string.text,
 		        attr->values[1].string.text) &&
 		 strcmp(attr->values[0].string.text, ""none"") &&
 		 strcmp(attr->values[1].string.text, ""none""))
         {
           ippSetString(job->attrs, &attr, 1, attr->values[0].string.text);
 	  cupsdLogJob(job, CUPSD_LOG_NOTICE, ""CLASSIFICATION FORCED ""
 	                		     ""job-sheets=\""%s,%s\"", ""
 					     ""job-originating-user-name=\""%s\"""",
 		      attr->values[0].string.text,
 		      attr->values[1].string.text, job->username);
 	}
 	else if (strcmp(attr->values[0].string.text, Classification) &&
 	         strcmp(attr->values[0].string.text, ""none"") &&
 		 (attr->num_values == 1 ||
 	          (strcmp(attr->values[1].string.text, Classification) &&
 	           strcmp(attr->values[1].string.text, ""none""))))
         {
 	  if (attr->num_values == 1)
             cupsdLogJob(job, CUPSD_LOG_NOTICE,
 			""CLASSIFICATION OVERRIDDEN ""
 			""job-sheets=\""%s\"", ""
 			""job-originating-user-name=\""%s\"""",
 	                attr->values[0].string.text, job->username);
           else
             cupsdLogJob(job, CUPSD_LOG_NOTICE,
 			""CLASSIFICATION OVERRIDDEN ""
 			""job-sheets=\""%s,%s\"",fffff ""
 			""job-originating-user-name=\""%s\"""",
 			attr->values[0].string.text,
 			attr->values[1].string.text, job->username);
         }
       }
       else if (strcmp(attr->values[0].string.text, Classification) &&
                (attr->num_values == 1 ||
 	       strcmp(attr->values[1].string.text, Classification)))
       {
         if (attr->num_values > 1 &&
 	    !strcmp(attr->values[0].string.text, attr->values[1].string.text))
 	{
           ippSetString(job->attrs, &attr, 0, Classification);
           ippSetString(job->attrs, &attr, 1, Classification);
 	}
         else
 	{
           if (attr->num_values == 1 ||
 	      strcmp(attr->values[0].string.text, ""none""))
             ippSetString(job->attrs, &attr, 0, Classification);
           if (attr->num_values > 1 &&
 	      strcmp(attr->values[1].string.text, ""none""))
 	    ippSetString(job->attrs, &attr, 1, Classification);
         }
         if (attr->num_values > 1)
 	  cupsdLogJob(job, CUPSD_LOG_NOTICE,
 		      ""CLASSIFICATION FORCED ""
 		      ""job-sheets=\""%s,%s\"", ""
 		      ""job-originating-user-name=\""%s\"""",
 		      attr->values[0].string.text,
 		      attr->values[1].string.text, job->username);
         else
 	  cupsdLogJob(job, CUPSD_LOG_NOTICE,
 		      ""CLASSIFICATION FORCED ""
 		      ""job-sheets=\""%s\"", ""
 		      ""job-originating-user-name=\""%s\"""",
 		      Classification, job->username);
       }
     }
     if (!(printer->type & CUPS_PRINTER_REMOTE))
     {
       cupsdLogJob(job, CUPSD_LOG_INFO, ""Adding start banner page \""%s\""."",
 		  attr->values[0].string.text);
       if ((kbytes = copy_banner(con, job, attr->values[0].string.text)) < 0)
       {
         cupsdSetJobState(job, IPP_JOB_ABORTED, CUPSD_JOB_PURGE,
 	                 ""Aborting job because the start banner could not be ""
 			 ""copied."");
         return (NULL);
       }
       cupsdUpdateQuota(printer, job->username, 0, kbytes);
     }
   }
   else if ((attr = ippFindAttribute(job->attrs, ""job-sheets"",
                                     IPP_TAG_ZERO)) != NULL)
     job->job_sheets = attr;
   httpAssembleURIf(HTTP_URI_CODING_ALL, job_uri, sizeof(job_uri), ""ipp"", NULL,
                    con->clientname, con->clientport, ""/jobs/%d"", job->id);
   ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_URI, ""job-uri"", NULL,
                job_uri);
   ippAddInteger(con->response, IPP_TAG_JOB, IPP_TAG_INTEGER, ""job-id"", job->id);
   ippAddInteger(con->response, IPP_TAG_JOB, IPP_TAG_ENUM, ""job-state"",
                 job->state_value);
   ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_TEXT, ""job-state-message"", NULL, """");
   ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_KEYWORD, ""job-state-reasons"",
                NULL, job->reasons->values[0].string.text);
   con->response->request.status.status_code = IPP_OK;
   add_job_subscriptions(con, job);
   for (attr = job->attrs->attrs->next->next; attr; attr = attr->next)
     attr->group_tag = IPP_TAG_JOB;
   cupsdAddEvent(CUPSD_EVENT_JOB_CREATED, printer, job, ""Job created."");
   return (job);
 }","[281, 282, 283, 284, 285, 286, 287, 288, 303]","The add_job function in scheduler/ipp.c in CUPS before 2.2.6, when D-Bus support is enabled, can be crashed by remote attackers by sending print jobs with an invalid username, related to a D-Bus notification.",cups,CVE-2017-18248,CWE-20
724,181420," static int decode_trns_chunk(AVCodecContext *avctx, PNGDecContext *s,
                              uint32_t length)
  {
      int v, i;
     if (!(s->state & PNG_IHDR)) {
         av_log(avctx, AV_LOG_ERROR, ""trns before IHDR\n"");
         return AVERROR_INVALIDDATA;
     }
     if (s->state & PNG_IDAT) {
         av_log(avctx, AV_LOG_ERROR, ""trns after IDAT\n"");
         return AVERROR_INVALIDDATA;
     }
      if (s->color_type == PNG_COLOR_TYPE_PALETTE) {
          if (length > 256 || !(s->state & PNG_PLTE))
              return AVERROR_INVALIDDATA;
         for (i = 0; i < length; i++) {
             v = bytestream2_get_byte(&s->gb);
             s->palette[i] = (s->palette[i] & 0x00ffffff) | (v << 24);
          }
      } else if (s->color_type == PNG_COLOR_TYPE_GRAY || s->color_type == PNG_COLOR_TYPE_RGB) {
          if ((s->color_type == PNG_COLOR_TYPE_GRAY && length != 2) ||
            (s->color_type == PNG_COLOR_TYPE_RGB && length != 6))
             (s->color_type == PNG_COLOR_TYPE_RGB && length != 6) ||
             s->bit_depth == 1)
              return AVERROR_INVALIDDATA;
          for (i = 0; i < length / 2; i++) {
             v = av_mod_uintp2(bytestream2_get_be16(&s->gb), s->bit_depth);
             if (s->bit_depth > 8)
                 AV_WB16(&s->transparent_color_be[2 * i], v);
             else
                 s->transparent_color_be[i] = v;
         }
     } else {
         return AVERROR_INVALIDDATA;
     }
     bytestream2_skip(&s->gb, 4);  
     s->has_trns = 1;
     return 0;
 }","[5, 6, 7, 8, 9, 10, 11, 12, 22, 23, 24]",FFmpeg before 2017-02-04 has an out-of-bounds write caused by a heap-based buffer overflow related to the decode_frame_common function in libavcodec/pngdec.c.,FFmpeg,CVE-2017-7863,CWE-787
725,181917,"  int jas_stream_gobble(jas_stream_t *stream, int n)
  {
  	int m;
 	if (n < 0) {
 		jas_deprecated(""negative count for jas_stream_gobble"");
 	}
  	m = n;
  	for (m = n; m > 0; --m) {
  		if (jas_stream_getc(stream) == EOF) {
 			return n - m;
 		}
 	}
 	return n;
 }","[4, 5, 6]","Multiple integer overflows in the (1) jas_realloc function in base/jas_malloc.c and (2) mem_resize function in base/jas_stream.c in JasPer before 1.900.22 allow remote attackers to cause a denial of service via a crafted image, which triggers use after free vulnerabilities.",jasper,CVE-2016-9262,CWE-190
728,179574," bqarr_in(PG_FUNCTION_ARGS)
 {
 	char	   *buf = (char *) PG_GETARG_POINTER(0);
 	WORKSTATE	state;
 	int32		i;
 	QUERYTYPE  *query;
 	int32		commonlen;
 	ITEM	   *ptr;
 	NODE	   *tmp;
 	int32		pos = 0;
 #ifdef BS_DEBUG
 	StringInfoData pbuf;
 #endif
 	state.buf = buf;
 	state.state = WAITOPERAND;
 	state.count = 0;
 	state.num = 0;
 	state.str = NULL;
 	makepol(&state);
 	if (!state.num)
 		ereport(ERROR,
  				(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
  				 errmsg(""empty query"")));
 	if (state.num > QUERYTYPEMAXITEMS)
 		ereport(ERROR,
 				(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),
 		errmsg(""number of query items (%d) exceeds the maximum allowed (%d)"",
 			   state.num, (int) QUERYTYPEMAXITEMS)));
  	commonlen = COMPUTESIZE(state.num);
  	query = (QUERYTYPE *) palloc(commonlen);
  	SET_VARSIZE(query, commonlen);
  	query->size = state.num;
 	ptr = GETQUERY(query);
 	for (i = state.num - 1; i >= 0; i--)
 	{
 		ptr[i].type = state.str->type;
 		ptr[i].val = state.str->val;
 		tmp = state.str->next;
 		pfree(state.str);
 		state.str = tmp;
 	}
 	pos = query->size - 1;
 	findoprnd(ptr, &pos);
 #ifdef BS_DEBUG
 	initStringInfo(&pbuf);
 	for (i = 0; i < query->size; i++)
 	{
 		if (ptr[i].type == OPR)
 			appendStringInfo(&pbuf, ""%c(%d) "", ptr[i].val, ptr[i].left);
 		else
 			appendStringInfo(&pbuf, ""%d "", ptr[i].val);
 	}
 	elog(DEBUG3, ""POR: %s"", pbuf.data);
 	pfree(pbuf.data);
 #endif
 	PG_RETURN_POINTER(query);
 }","[24, 25, 26, 27, 28]","Multiple integer overflows in contrib/hstore/hstore_io.c in PostgreSQL 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact via vectors related to the (1) hstore_recv, (2) hstore_from_arrays, and (3) hstore_from_array functions in contrib/hstore/hstore_io.c; and the (4) hstoreArrayToPairs function in contrib/hstore/hstore_op.c, which triggers a buffer overflow.  NOTE: this issue was SPLIT from CVE-2014-0064 because it has a different set of affected versions.",postgres,CVE-2014-2669,CWE-189
753,180175," isoent_gen_joliet_identifier(struct archive_write *a, struct isoent *isoent,
     struct idr *idr)
 {
 	struct iso9660 *iso9660;
 	struct isoent *np;
  	unsigned char *p;
  	size_t l;
  	int r;
	int ffmax, parent_len;
 	size_t ffmax, parent_len;
  	static const struct archive_rb_tree_ops rb_ops = {
  		isoent_cmp_node_joliet, isoent_cmp_key_joliet
  	};
 	if (isoent->children.cnt == 0)
 		return (0);
 	iso9660 = a->format_data;
 	if (iso9660->opt.joliet == OPT_JOLIET_LONGNAME)
 		ffmax = 206;
  	else
  		ffmax = 128;
	r = idr_start(a, idr, isoent->children.cnt, ffmax, 6, 2, &rb_ops);
 	r = idr_start(a, idr, isoent->children.cnt, (int)ffmax, 6, 2, &rb_ops);
  	if (r < 0)
  		return (r);
 	parent_len = 1;
 	for (np = isoent; np->parent != np; np = np->parent)
 		parent_len += np->mb_len + 1;
 	for (np = isoent->children.first; np != NULL; np = np->chnext) {
 		unsigned char *dot;
  		int ext_off, noff, weight;
  		size_t lt;
		if ((int)(l = np->file->basename_utf16.length) > ffmax)
 		if ((l = np->file->basename_utf16.length) > ffmax)
  			l = ffmax;
  		p = malloc((l+1)*2);
 		if (p == NULL) {
 			archive_set_error(&a->archive, ENOMEM,
 			    ""Can't allocate memory"");
 			return (ARCHIVE_FATAL);
 		}
 		memcpy(p, np->file->basename_utf16.s, l);
 		p[l] = 0;
 		p[l+1] = 0;
 		np->identifier = (char *)p;
 		lt = l;
 		dot = p + l;
 		weight = 0;
 		while (lt > 0) {
 			if (!joliet_allowed_char(p[0], p[1]))
 				archive_be16enc(p, 0x005F);  
 			else if (p[0] == 0 && p[1] == 0x2E)  
 				dot = p;
 			p += 2;
 			lt -= 2;
 		}
 		ext_off = (int)(dot - (unsigned char *)np->identifier);
 		np->ext_off = ext_off;
 		np->ext_len = (int)l - ext_off;
 		np->id_len = (int)l;
		if ((int)np->file->basename_utf16.length > ffmax) {
 		if (np->file->basename_utf16.length > ffmax) {
  			if (archive_strncpy_l(&iso9660->mbs,
  			    (const char *)np->identifier, l,
  				iso9660->sconv_from_utf16be) != 0 &&
 			    errno == ENOMEM) {
 				archive_set_error(&a->archive, errno,
 				    ""No memory"");
 				return (ARCHIVE_FATAL);
 			}
 			np->mb_len = (int)iso9660->mbs.length;
 			if (np->mb_len != (int)np->file->basename.length)
 				weight = np->mb_len;
 		} else
 			np->mb_len = (int)np->file->basename.length;
		if (parent_len + np->mb_len > 240) {
 		if (parent_len > 240
 		    || np->mb_len > 240
 		    || parent_len + np->mb_len > 240) {
  			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
  			    ""The regulation of Joliet extensions;""
  			    "" A length of a full-pathname of `%s' is ""
 			    ""longer than 240 bytes, (p=%d, b=%d)"",
 			    archive_entry_pathname(np->file->entry),
 			    (int)parent_len, (int)np->mb_len);
 			return (ARCHIVE_FATAL);
 		}
		if ((int)l == ffmax)
 		if (l == ffmax)
  			noff = ext_off - 6;
		else if ((int)l == ffmax-2)
 		else if (l == ffmax-2)
  			noff = ext_off - 4;
		else if ((int)l == ffmax-4)
 		else if (l == ffmax-4)
  			noff = ext_off - 2;
  		else
  			noff = ext_off;
 		idr_register(idr, np, weight, noff);
 	}
 	idr_resolve(idr, idr_set_num_beutf16);
 	return (ARCHIVE_OK);
 }","[9, 10, 21, 22, 32, 33, 60, 61, 75, 76, 77, 78, 87, 88, 90, 91, 93, 94]","Integer overflow in the ISO9660 writer in libarchive before 3.2.1 allows remote attackers to cause a denial of service (application crash) or execute arbitrary code via vectors related to verifying filename lengths when writing an ISO9660 archive, which trigger a buffer overflow.",libarchive,CVE-2016-6250,CWE-190
771,182379," NO_INLINE JsVar *__jspeAssignmentExpression(JsVar *lhs) {
   if (lex->tk=='=' || lex->tk==LEX_PLUSEQUAL || lex->tk==LEX_MINUSEQUAL ||
       lex->tk==LEX_MULEQUAL || lex->tk==LEX_DIVEQUAL || lex->tk==LEX_MODEQUAL ||
       lex->tk==LEX_ANDEQUAL || lex->tk==LEX_OREQUAL ||
       lex->tk==LEX_XOREQUAL || lex->tk==LEX_RSHIFTEQUAL ||
       lex->tk==LEX_LSHIFTEQUAL || lex->tk==LEX_RSHIFTUNSIGNEDEQUAL) {
     JsVar *rhs;
     int op = lex->tk;
     JSP_ASSERT_MATCH(op);
     rhs = jspeAssignmentExpression();
     rhs = jsvSkipNameAndUnLock(rhs);  
      if (JSP_SHOULD_EXECUTE && lhs) {
        if (op=='=') {
        if (!jsvGetRefs(lhs) && jsvIsName(lhs)) {
          if (!jsvIsArrayBufferName(lhs) && !jsvIsNewChild(lhs))
            jsvAddName(execInfo.root, lhs);
        }
        jspReplaceWith(lhs, rhs);
         jspReplaceWithOrAddToRoot(lhs, rhs);
        } else {
          if (op==LEX_PLUSEQUAL) op='+';
          else if (op==LEX_MINUSEQUAL) op='-';
         else if (op==LEX_MULEQUAL) op='*';
         else if (op==LEX_DIVEQUAL) op='/';
         else if (op==LEX_MODEQUAL) op='%';
         else if (op==LEX_ANDEQUAL) op='&';
         else if (op==LEX_OREQUAL) op='|';
         else if (op==LEX_XOREQUAL) op='^';
         else if (op==LEX_RSHIFTEQUAL) op=LEX_RSHIFT;
         else if (op==LEX_LSHIFTEQUAL) op=LEX_LSHIFT;
         else if (op==LEX_RSHIFTUNSIGNEDEQUAL) op=LEX_RSHIFTUNSIGNED;
         if (op=='+' && jsvIsName(lhs)) {
           JsVar *currentValue = jsvSkipName(lhs);
           if (jsvIsString(currentValue) && !jsvIsFlatString(currentValue) && jsvGetRefs(currentValue)==1 && rhs!=currentValue) {
             JsVar *str = jsvAsString(rhs, false);
             jsvAppendStringVarComplete(currentValue, str);
             jsvUnLock(str);
             op = 0;
           }
           jsvUnLock(currentValue);
         }
         if (op) {
           JsVar *res = jsvMathsOpSkipNames(lhs,rhs,op);
           jspReplaceWith(lhs, res);
           jsvUnLock(res);
         }
       }
     }
     jsvUnLock(rhs);
   }
   return lhs;
 }","[14, 15, 16, 17, 18, 19]",Espruino before 1.99 allows attackers to cause a denial of service (application crash) and a potential Information Disclosure with user crafted input files via a Buffer Overflow or Out-of-bounds Read during syntax parsing of certain for loops in jsparse.c.,Espruino,CVE-2018-11598,CWE-125
777,182237," sc_parse_ef_gdo_content(const unsigned char *gdo, size_t gdo_len,
 		unsigned char *iccsn, size_t *iccsn_len,
 		unsigned char *chn, size_t *chn_len)
 {
 	int r = SC_SUCCESS, iccsn_found = 0, chn_found = 0;
 	const unsigned char *p = gdo;
 	size_t left = gdo_len;
 	while (left >= 2) {
 		unsigned int cla, tag;
 		size_t tag_len;
 		r = sc_asn1_read_tag(&p, left, &cla, &tag, &tag_len);
 		if (r != SC_SUCCESS) {
 			if (r == SC_ERROR_ASN1_END_OF_CONTENTS) {
 				r = SC_SUCCESS;
 			}
 			break;
 		}
 		if (p == NULL) {
 			break;
 		}
 		if (cla == SC_ASN1_TAG_APPLICATION) {
 			switch (tag) {
 				case 0x1A:
 					iccsn_found = 1;
 					if (iccsn && iccsn_len) {
 						memcpy(iccsn, p, MIN(tag_len, *iccsn_len));
 						*iccsn_len = MIN(tag_len, *iccsn_len);
 					}
 					break;
 				case 0x1F20:
 					chn_found = 1;
 					if (chn && chn_len) {
 						memcpy(chn, p, MIN(tag_len, *chn_len));
 						*chn_len = MIN(tag_len, *chn_len);
 					}
 					break;
 			}
  		}
  		p += tag_len;
		left -= (p - gdo);
 		left = gdo_len - (p - gdo);
  	}
  	if (!iccsn_found && iccsn_len)
 		*iccsn_len = 0;
 	if (!chn_found && chn_len)
 		*chn_len = 0;
 	return r;
 }","[40, 41]",Various out of bounds reads when handling responses in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to potentially crash the opensc library using programs.,OpenSC,CVE-2018-16427,CWE-125
780,182038,"  dwarf_elf_object_access_load_section(void* obj_in,
      Dwarf_Half section_index,
     Dwarf_Small** section_data,
     int* error)
 {
     dwarf_elf_object_access_internals_t*obj =
         (dwarf_elf_object_access_internals_t*)obj_in;
     if (section_index == 0) {
         return DW_DLV_NO_ENTRY;
     }
     {
         Elf_Scn *scn = 0;
         Elf_Data *data = 0;
         scn = elf_getscn(obj->elf, section_index);
         if (scn == NULL) {
             *error = DW_DLE_MDE;
             return DW_DLV_ERROR;
         }
         data = elf_getdata(scn, NULL);
         if (data == NULL) {
              *error = DW_DLE_MDE;
              return DW_DLV_ERROR;
          }
         if (!data->d_buf) {
             *error = DW_DLE_MDE;
             return DW_DLV_ERROR;
         }
          *section_data = data->d_buf;
      }
      return DW_DLV_OK;
 }","[24, 25, 26, 27]",libdwarf 20151114 and earlier allows remote attackers to cause a denial of service (NULL pointer dereference and crash) via a debug_abbrev section marked NOBITS in an ELF file.,libdwarf,CVE-2015-8750,CWE-476
799,182363," int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)
 {
     MpegEncContext *s = &ctx->m;
     unsigned startcode, v;
     int ret;
     int vol = 0;
      align_get_bits(gb);
     if (!s->studio_profile && s->avctx->bits_per_raw_sample != 8)
         s->avctx->bits_per_raw_sample = 0;
      if (s->codec_tag == AV_RL32(""WV1F"") && show_bits(gb, 24) == 0x575630) {
          skip_bits(gb, 24);
          if (get_bits(gb, 8) == 0xF0)
             goto end;
     }
     startcode = 0xff;
     for (;;) {
         if (get_bits_count(gb) >= gb->size_in_bits) {
             if (gb->size_in_bits == 8 &&
                 (ctx->divx_version >= 0 || ctx->xvid_build >= 0) || s->codec_tag == AV_RL32(""QMP4"")) {
                 av_log(s->avctx, AV_LOG_VERBOSE, ""frame skip %d\n"", gb->size_in_bits);
                 return FRAME_SKIPPED;   
             } else
                 return AVERROR_INVALIDDATA;   
         }
         v = get_bits(gb, 8);
         startcode = ((startcode << 8) | v) & 0xffffffff;
         if ((startcode & 0xFFFFFF00) != 0x100)
             continue;   
         if (s->avctx->debug & FF_DEBUG_STARTCODE) {
             av_log(s->avctx, AV_LOG_DEBUG, ""startcode: %3X "", startcode);
             if (startcode <= 0x11F)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Video Object Start"");
             else if (startcode <= 0x12F)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Video Object Layer Start"");
             else if (startcode <= 0x13F)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Reserved"");
             else if (startcode <= 0x15F)
                 av_log(s->avctx, AV_LOG_DEBUG, ""FGS bp start"");
             else if (startcode <= 0x1AF)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Reserved"");
             else if (startcode == 0x1B0)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Visual Object Seq Start"");
             else if (startcode == 0x1B1)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Visual Object Seq End"");
             else if (startcode == 0x1B2)
                 av_log(s->avctx, AV_LOG_DEBUG, ""User Data"");
             else if (startcode == 0x1B3)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Group of VOP start"");
             else if (startcode == 0x1B4)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Video Session Error"");
             else if (startcode == 0x1B5)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Visual Object Start"");
             else if (startcode == 0x1B6)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Video Object Plane start"");
             else if (startcode == 0x1B7)
                 av_log(s->avctx, AV_LOG_DEBUG, ""slice start"");
             else if (startcode == 0x1B8)
                 av_log(s->avctx, AV_LOG_DEBUG, ""extension start"");
             else if (startcode == 0x1B9)
                 av_log(s->avctx, AV_LOG_DEBUG, ""fgs start"");
             else if (startcode == 0x1BA)
                 av_log(s->avctx, AV_LOG_DEBUG, ""FBA Object start"");
             else if (startcode == 0x1BB)
                 av_log(s->avctx, AV_LOG_DEBUG, ""FBA Object Plane start"");
             else if (startcode == 0x1BC)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Mesh Object start"");
             else if (startcode == 0x1BD)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Mesh Object Plane start"");
             else if (startcode == 0x1BE)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Still Texture Object start"");
             else if (startcode == 0x1BF)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Texture Spatial Layer start"");
             else if (startcode == 0x1C0)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Texture SNR Layer start"");
             else if (startcode == 0x1C1)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Texture Tile start"");
             else if (startcode == 0x1C2)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Texture Shape Layer start"");
             else if (startcode == 0x1C3)
                 av_log(s->avctx, AV_LOG_DEBUG, ""stuffing start"");
             else if (startcode <= 0x1C5)
                 av_log(s->avctx, AV_LOG_DEBUG, ""reserved"");
             else if (startcode <= 0x1FF)
                 av_log(s->avctx, AV_LOG_DEBUG, ""System start"");
             av_log(s->avctx, AV_LOG_DEBUG, "" at %d\n"", get_bits_count(gb));
         }
         if (startcode >= 0x120 && startcode <= 0x12F) {
             if (vol) {
                 av_log(s->avctx, AV_LOG_WARNING, ""Ignoring multiple VOL headers\n"");
                 continue;
             }
             vol++;
             if ((ret = decode_vol_header(ctx, gb)) < 0)
                 return ret;
         } else if (startcode == USER_DATA_STARTCODE) {
             decode_user_data(ctx, gb);
         } else if (startcode == GOP_STARTCODE) {
             mpeg4_decode_gop_header(s, gb);
         } else if (startcode == VOS_STARTCODE) {
             mpeg4_decode_profile_level(s, gb);
             if (s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&
                 (s->avctx->level > 0 && s->avctx->level < 9)) {
                 s->studio_profile = 1;
                 next_start_code_studio(gb);
                 extension_and_user_data(s, gb, 0);
             }
         } else if (startcode == VISUAL_OBJ_STARTCODE) {
             if (s->studio_profile) {
                 if ((ret = decode_studiovisualobject(ctx, gb)) < 0)
                     return ret;
             } else
                 mpeg4_decode_visual_object(s, gb);
         } else if (startcode == VOP_STARTCODE) {
             break;
         }
         align_get_bits(gb);
         startcode = 0xff;
     }
 end:
     if (s->avctx->flags & AV_CODEC_FLAG_LOW_DELAY)
         s->low_delay = 1;
     s->avctx->has_b_frames = !s->low_delay;
     if (s->studio_profile) {
         if (!s->avctx->bits_per_raw_sample) {
             av_log(s->avctx, AV_LOG_ERROR, ""Missing VOL header\n"");
             return AVERROR_INVALIDDATA;
         }
         return decode_studio_vop_header(ctx, gb);
     } else
         return decode_vop_header(ctx, gb);
 }","[8, 9]","An inconsistent bits-per-sample value in the ff_mpeg4_decode_picture_header function in libavcodec/mpeg4videodec.c in FFmpeg 4.0 may trigger an assertion violation while converting a crafted AVI file to MPEG4, leading to a denial of service.",FFmpeg,CVE-2018-12459,CWE-20
800,181891,"  jpc_streamlist_t *jpc_ppmstabtostreams(jpc_ppxstab_t *tab)
  {
  	jpc_streamlist_t *streams;
	uchar *dataptr;
 	jas_uchar *dataptr;
  	uint_fast32_t datacnt;
  	uint_fast32_t tpcnt;
  	jpc_ppxstabent_t *ent;
 	int entno;
 	jas_stream_t *stream;
 	int n;
 	if (!(streams = jpc_streamlist_create())) {
 		goto error;
 	}
 	if (!tab->numents) {
 		return streams;
 	}
 	entno = 0;
 	ent = tab->ents[entno];
 	dataptr = ent->data;
 	datacnt = ent->len;
 	for (;;) {
 		if (datacnt < 4) {
 			goto error;
 		}
 		if (!(stream = jas_stream_memopen(0, 0))) {
 			goto error;
 		}
 		if (jpc_streamlist_insert(streams, jpc_streamlist_numstreams(streams),
 		  stream)) {
 			goto error;
 		}
 		tpcnt = (dataptr[0] << 24) | (dataptr[1] << 16) | (dataptr[2] << 8)
 		  | dataptr[3];
 		datacnt -= 4;
 		dataptr += 4;
 		while (tpcnt) {
 			if (!datacnt) {
 				if (++entno >= tab->numents) {
 					goto error;
 				}
 				ent = tab->ents[entno];
 				dataptr = ent->data;
 				datacnt = ent->len;
 			}
 			n = JAS_MIN(tpcnt, datacnt);
 			if (jas_stream_write(stream, dataptr, n) != n) {
 				goto error;
 			}
 			tpcnt -= n;
 			dataptr += n;
 			datacnt -= n;
 		}
 		jas_stream_rewind(stream);
 		if (!datacnt) {
 			if (++entno >= tab->numents) {
 				break;
 			}
 			ent = tab->ents[entno];
 			dataptr = ent->data;
 			datacnt = ent->len;
 		}
 	}
 	return streams;
 error:
 	if (streams) {
 		jpc_streamlist_destroy(streams);
 	}
 	return 0;
 }","[4, 5]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
801,182975," process_demand_active(STREAM s)
  {
  	uint8 type;
  	uint16 len_src_descriptor, len_combined_caps;
 	struct stream packet = *s;
  	rd_create_ui();
  	in_uint32_le(s, g_rdp_shareid);
  	in_uint16_le(s, len_src_descriptor);
  	in_uint16_le(s, len_combined_caps);
 	if (!s_check_rem(s, len_src_descriptor))
 	{
 		rdp_protocol_error(""rdp_demand_active(), consume of source descriptor from stream would overrun"", &packet);
 	}
  	in_uint8s(s, len_src_descriptor);
  	logger(Protocol, Debug, ""process_demand_active(), shareid=0x%x"", g_rdp_shareid);
 	rdp_process_server_caps(s, len_combined_caps);
 	rdp_send_confirm_active();
 	rdp_send_synchronise();
 	rdp_send_control(RDP_CTL_COOPERATE);
 	rdp_send_control(RDP_CTL_REQUEST_CONTROL);
 	rdp_recv(&type);	 
 	rdp_recv(&type);	 
 	rdp_recv(&type);	 
 	rdp_send_input(0, RDP_INPUT_SYNCHRONIZE, 0,
 		       g_numlock_sync ? ui_get_numlock_state(read_keyboard_state()) : 0, 0);
 	if (g_rdp_version >= RDP_V5)
 	{
 		rdp_enum_bmpcache2();
 		rdp_send_fonts(3);
 	}
 	else
 	{
 		rdp_send_fonts(1);
 		rdp_send_fonts(2);
 	}
 	rdp_recv(&type);	 
 	reset_order_state();
 }","[5, 10, 11, 12, 13]",rdesktop versions up to and including v1.8.3 contain a Buffer Overflow over the global variables in the function seamless_process_line() that results in memory corruption and probably even a remote code execution.,rdesktop,CVE-2018-20182,CWE-119
807,182968," cliprdr_process(STREAM s)
 {
  	uint16 type, status;
  	uint32 length, format;
  	uint8 *data;
 	struct stream packet = *s;
  	in_uint16_le(s, type);
  	in_uint16_le(s, status);
 	in_uint32_le(s, length);
 	data = s->p;
  	logger(Clipboard, Debug, ""cliprdr_process(), type=%d, status=%d, length=%d"", type, status,
  	       length);
 	if (!s_check_rem(s, length))
 	{
 		rdp_protocol_error(""cliprdr_process(), consume of packet from stream would overrun"", &packet);
 	}
  	if (status == CLIPRDR_ERROR)
  	{
  		switch (type)
 		{
 			case CLIPRDR_FORMAT_ACK:
 				cliprdr_send_native_format_announce(last_formats,
 								    last_formats_length);
 				break;
 			case CLIPRDR_DATA_RESPONSE:
 				ui_clip_request_failed();
 				break;
 			default:
 				logger(Clipboard, Warning,
 				       ""cliprdr_process(), unhandled error (type=%d)"", type);
 		}
 		return;
 	}
 	switch (type)
 	{
 		case CLIPRDR_CONNECT:
 			ui_clip_sync();
 			break;
 		case CLIPRDR_FORMAT_ANNOUNCE:
 			ui_clip_format_announce(data, length);
 			cliprdr_send_packet(CLIPRDR_FORMAT_ACK, CLIPRDR_RESPONSE, NULL, 0);
 			return;
 		case CLIPRDR_FORMAT_ACK:
 			break;
 		case CLIPRDR_DATA_REQUEST:
 			in_uint32_le(s, format);
 			ui_clip_request_data(format);
 			break;
 		case CLIPRDR_DATA_RESPONSE:
 			ui_clip_handle_data(data, length);
 			break;
 		case 7:	 
 			break;
 		default:
 			logger(Clipboard, Warning, ""cliprdr_process(), unhandled packet type %d"",
 			       type);
 	}
 }","[6, 13, 14, 15, 16]",rdesktop versions up to and including v1.8.3 contain a Buffer Overflow over the global variables in the function seamless_process_line() that results in memory corruption and probably even a remote code execution.,rdesktop,CVE-2018-20182,CWE-119
817,181871," void jas_matrix_bindsub(jas_matrix_t *mat0, jas_matrix_t *mat1, int r0,
  int c0, int r1, int c1)
 void jas_matrix_bindsub(jas_matrix_t *mat0, jas_matrix_t *mat1,
   jas_matind_t r0, jas_matind_t c0, jas_matind_t r1, jas_matind_t c1)
  {
	int i;
 	jas_matind_t i;
  	if (mat0->data_) {
  		if (!(mat0->flags_ & JAS_MATRIX_REF)) {
 			jas_free(mat0->data_);
 		}
 		mat0->data_ = 0;
 		mat0->datasize_ = 0;
 	}
 	if (mat0->rows_) {
 		jas_free(mat0->rows_);
 		mat0->rows_ = 0;
 	}
 	mat0->flags_ |= JAS_MATRIX_REF;
 	mat0->numrows_ = r1 - r0 + 1;
 	mat0->numcols_ = c1 - c0 + 1;
 	mat0->maxrows_ = mat0->numrows_;
 	if (!(mat0->rows_ = jas_alloc2(mat0->maxrows_, sizeof(jas_seqent_t *)))) {
 		abort();
 	}
 	for (i = 0; i < mat0->numrows_; ++i) {
 		mat0->rows_[i] = mat1->rows_[r0 + i] + c0;
 	}
 	mat0->xstart_ = mat1->xstart_ + c0;
 	mat0->ystart_ = mat1->ystart_ + r0;
 	mat0->xend_ = mat0->xstart_ + mat0->numcols_;
 	mat0->yend_ = mat0->ystart_ + mat0->numrows_;
 }","[2, 3, 4, 6, 7]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.,jasper,CVE-2016-9557,CWE-190
818,179348,"  _archive_write_data(struct archive *_a, const void *buff, size_t s)
  {
  	struct archive_write *a = (struct archive_write *)_a;
 	const size_t max_write = INT_MAX;
  	archive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,
  	    ARCHIVE_STATE_DATA, ""archive_write_data"");
 	if (s > max_write)
 		s = max_write;
  	archive_clear_error(&a->archive);
  	return ((a->format_write_data)(a, buff, s));
  }","[4, 7, 8]","Integer signedness error in the archive_write_zip_data function in archive_write_set_format_zip.c in libarchive 3.1.2 and earlier, when running on 64-bit machines, allows context-dependent attackers to cause a denial of service (crash) via unspecified vectors, which triggers an improper conversion between unsigned and signed types, leading to a buffer overflow.",libarchive,CVE-2013-0211,CWE-189
822,178679," _XcursorThemeInherits (const char *full)
 {
     char    line[8192];
     char    *result = NULL;
     FILE    *f;
     if (!full)
         return NULL;
     f = fopen (full, ""r"");
     if (f)
     {
 	while (fgets (line, sizeof (line), f))
 	{
 	    if (!strncmp (line, ""Inherits"", 8))
 	    {
 		char    *l = line + 8;
 		char    *r;
 		while (*l == ' ') l++;
  		if (*l != '=') continue;
  		l++;
  		while (*l == ' ') l++;
		result = malloc (strlen (l));
 		result = malloc (strlen (l) + 1);
  		if (result)
  		{
  		    r = result;
 		    while (*l)
 		    {
 			while (XcursorSep(*l) || XcursorWhite (*l)) l++;
 			if (!*l)
 			    break;
 			if (r != result)
 			    *r++ = ':';
 			while (*l && !XcursorWhite(*l) &&
 			       !XcursorSep(*l))
 			    *r++ = *l++;
 		    }
 		    *r++ = '\0';
 		}
 		break;
 	    }
 	}
 	fclose (f);
     }
     return result;
 }","[21, 22]",_XcursorThemeInherits in library.c in libXcursor before 1.1.15 allows remote attackers to cause denial of service or potentially code execution via a one-byte heap overflow.,xcursor,CVE-2015-9262,CWE-119
827,179899," local void process(char *path)
 {
     int method = -1;                 
     size_t len;                      
     struct stat st;                  
     static char *sufs[] = {"".z"", ""-z"", ""_z"", "".Z"", "".gz"", ""-gz"", "".zz"", ""-zz"",
                            "".zip"", "".ZIP"", "".tgz"", NULL};
     if (path == NULL) {
         strcpy(g.inf, ""<stdin>"");
         g.ind = 0;
         g.name = NULL;
         g.mtime = g.headis & 2 ?
                   (fstat(g.ind, &st) ? time(NULL) : st.st_mtime) : 0;
         len = 0;
     }
     else {
         if (path != g.inf) {
             strncpy(g.inf, path, sizeof(g.inf));
             if (g.inf[sizeof(g.inf) - 1])
                 bail(""name too long: "", path);
         }
         len = strlen(g.inf);
         if (lstat(g.inf, &st)) {
             if (errno == ENOENT && (g.list || g.decode)) {
                 char **try = sufs;
                 do {
                     if (*try == NULL || len + strlen(*try) >= sizeof(g.inf))
                         break;
                     strcpy(g.inf + len, *try++);
                     errno = 0;
                 } while (lstat(g.inf, &st) && errno == ENOENT);
             }
 #ifdef EOVERFLOW
             if (errno == EOVERFLOW || errno == EFBIG)
                 bail(g.inf,
                     "" too large -- not compiled with large file support"");
 #endif
             if (errno) {
                 g.inf[len] = 0;
                 complain(""%s does not exist -- skipping"", g.inf);
                 return;
             }
             len = strlen(g.inf);
         }
         if ((st.st_mode & S_IFMT) != S_IFREG &&
             (st.st_mode & S_IFMT) != S_IFLNK &&
             (st.st_mode & S_IFMT) != S_IFDIR) {
             complain(""%s is a special file or device -- skipping"", g.inf);
             return;
         }
         if ((st.st_mode & S_IFMT) == S_IFLNK && !g.force && !g.pipeout) {
             complain(""%s is a symbolic link -- skipping"", g.inf);
             return;
         }
         if ((st.st_mode & S_IFMT) == S_IFDIR && !g.recurse) {
             complain(""%s is a directory -- skipping"", g.inf);
             return;
         }
         if ((st.st_mode & S_IFMT) == S_IFDIR) {
             char *roll, *item, *cut, *base, *bigger;
             size_t len, hold;
             DIR *here;
             struct dirent *next;
             here = opendir(g.inf);
             if (here == NULL)
                 return;
             hold = 512;
             roll = MALLOC(hold);
             if (roll == NULL)
                 bail(""not enough memory"", """");
             *roll = 0;
             item = roll;
             while ((next = readdir(here)) != NULL) {
                 if (next->d_name[0] == 0 ||
                     (next->d_name[0] == '.' && (next->d_name[1] == 0 ||
                      (next->d_name[1] == '.' && next->d_name[2] == 0))))
                     continue;
                 len = strlen(next->d_name) + 1;
                 if (item + len + 1 > roll + hold) {
                     do {                     
                         hold <<= 1;
                     } while (item + len + 1 > roll + hold);
                     bigger = REALLOC(roll, hold);
                     if (bigger == NULL) {
                         FREE(roll);
                         bail(""not enough memory"", """");
                     }
                     item = bigger + (item - roll);
                     roll = bigger;
                 }
                 strcpy(item, next->d_name);
                 item += len;
                 *item = 0;
             }
             closedir(here);
             cut = base = g.inf + strlen(g.inf);
             if (base > g.inf && base[-1] != (unsigned char)'/') {
                 if ((size_t)(base - g.inf) >= sizeof(g.inf))
                     bail(""path too long"", g.inf);
                 *base++ = '/';
             }
             item = roll;
             while (*item) {
                 strncpy(base, item, sizeof(g.inf) - (base - g.inf));
                 if (g.inf[sizeof(g.inf) - 1]) {
                     strcpy(g.inf + (sizeof(g.inf) - 4), ""..."");
                     bail(""path too long: "", g.inf);
                 }
                 process(g.inf);
                 item += strlen(item) + 1;
             }
             *cut = 0;
             FREE(roll);
             return;
         }
         if (!(g.force || g.list || g.decode) && len >= strlen(g.sufx) &&
                 strcmp(g.inf + len - strlen(g.sufx), g.sufx) == 0) {
             complain(""%s ends with %s -- skipping"", g.inf, g.sufx);
             return;
         }
         if (g.decode == 1 && !g.pipeout && !g.list) {
             int suf = compressed_suffix(g.inf);
             if (suf == 0) {
                 complain(""%s does not have compressed suffix -- skipping"",
                          g.inf);
                 return;
             }
             len -= suf;
         }
         g.ind = open(g.inf, O_RDONLY, 0);
         if (g.ind < 0)
             bail(""read error on "", g.inf);
         g.name = g.headis & 1 ? justname(g.inf) : NULL;
         g.mtime = g.headis & 2 ? st.st_mtime : 0;
     }
     SET_BINARY_MODE(g.ind);
     g.hname = NULL;
     if (g.decode) {
         in_init();
         method = get_header(1);
         if (method != 8 && method != 257 &&
                 !(method == -2 && g.force && g.pipeout && g.decode != 2 &&
                   !g.list)) {
             RELEASE(g.hname);
             if (g.ind != 0)
                 close(g.ind);
             if (method != -1)
                 complain(method < 0 ? ""%s is not compressed -- skipping"" :
                          ""%s has unknown compression method -- skipping"",
                          g.inf);
             return;
         }
         if (g.decode == 2) {
             if (method == 8)
                 infchk();
             else {
                 unlzw();
                 if (g.list) {
                     g.in_tot -= 3;
                     show_info(method, 0, g.out_tot, 0);
                 }
             }
             RELEASE(g.hname);
             if (g.ind != 0)
                 close(g.ind);
             return;
         }
     }
     if (g.list) {
         list_info();
         RELEASE(g.hname);
         if (g.ind != 0)
             close(g.ind);
         return;
     }
     if (path == NULL || g.pipeout) {
         g.outf = MALLOC(strlen(""<stdout>"") + 1);
         if (g.outf == NULL)
             bail(""not enough memory"", """");
         strcpy(g.outf, ""<stdout>"");
         g.outd = 1;
         if (!g.decode && !g.force && isatty(g.outd))
             bail(""trying to write compressed data to a terminal"",
                   "" (use -f to force)"");
      }
      else {
        char *to, *repl;
         char *to = g.inf, *sufx = """";
         size_t pre = 0;
        to = g.inf;
        if (g.decode && (g.headis & 1) != 0 && g.hname != NULL) {
            to = g.hname;
            len = strlen(g.hname);
         if (g.decode) {
             if ((g.headis & 1) != 0 && g.hname != NULL) {
                 pre = justname(g.inf) - g.inf;
                 to = justname(g.hname);
                 len = strlen(to);
             }
             else if (strcmp(to + len, "".tgz"") == 0)
                 sufx = "".tar"";
          }
        repl = g.decode && strcmp(to + len, "".tgz"") ? """" : "".tar"";
         else
             sufx = g.sufx;
        g.outf = MALLOC(len + (g.decode ? strlen(repl) : strlen(g.sufx)) + 1);
         g.outf = MALLOC(pre + len + strlen(sufx) + 1);
          if (g.outf == NULL)
              bail(""not enough memory"", """");
        memcpy(g.outf, to, len);
        strcpy(g.outf + len, g.decode ? repl : g.sufx);
         memcpy(g.outf, g.inf, pre);
         memcpy(g.outf + pre, to, len);
         strcpy(g.outf + pre + len, sufx);
          g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |
                             (g.force ? 0 : O_EXCL), 0600);
                               (g.force ? 0 : O_EXCL), 0600);
          if (g.outd < 0 && errno == EEXIST && isatty(0) && g.verbosity) {
             int ch, reply;
             fprintf(stderr, ""%s exists -- overwrite (y/n)? "", g.outf);
             fflush(stderr);
             reply = -1;
             do {
                 ch = getchar();
                 if (reply < 0 && ch != ' ' && ch != '\t')
                     reply = ch == 'y' || ch == 'Y' ? 1 : 0;
             } while (ch != EOF && ch != '\n' && ch != '\r');
             if (reply == 1)
                 g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY,
                               0600);
         }
         if (g.outd < 0 && errno == EEXIST) {
             complain(""%s exists -- skipping"", g.outf);
             RELEASE(g.outf);
             RELEASE(g.hname);
             if (g.ind != 0)
                 close(g.ind);
             return;
         }
         if (g.outd < 0)
             bail(""write error on "", g.outf);
     }
     SET_BINARY_MODE(g.outd);
     RELEASE(g.hname);
     if (g.verbosity > 1)
         fprintf(stderr, ""%s to %s "", g.inf, g.outf);
     if (g.decode) {
         if (method == 8)
             infchk();
         else if (method == 257)
             unlzw();
         else
             cat();
     }
 #ifndef NOTHREAD
     else if (g.procs > 1)
         parallel_compress();
 #endif
     else
         single_compress(0);
     if (g.verbosity > 1) {
         putc('\n', stderr);
         fflush(stderr);
     }
     if (g.ind != 0)
         close(g.ind);
     if (g.outd != 1) {
         if (close(g.outd))
             bail(""write error on "", g.outf);
         g.outd = -1;             
         if (g.ind != 0) {
             copymeta(g.inf, g.outf);
             if (!g.keep)
                 unlink(g.inf);
         }
         if (g.decode && (g.headis & 2) != 0 && g.stamp)
             touch(g.outf, g.stamp);
     }
     RELEASE(g.outf);
 }","[187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 203, 204, 205, 206, 207, 210, 211, 212, 213, 214, 216, 217]",Multiple directory traversal vulnerabilities in pigz 2.3.1 allow remote attackers to write to arbitrary files via a (1) full pathname or (2) .. (dot dot) in an archive.,pigz,CVE-2015-1191,CWE-22
830,182252," static int read_private_key(RSA *rsa)
 {
 	int r;
 	sc_path_t path;
 	sc_file_t *file;
 	const sc_acl_entry_t *e;
 	u8 buf[2048], *p = buf;
 	size_t bufsize, keysize;
 	r = select_app_df();
 	if (r)
 		return 1;
 	sc_format_path(""I0012"", &path);
 	r = sc_select_file(card, &path, &file);
 	if (r) {
 		fprintf(stderr, ""Unable to select private key file: %s\n"", sc_strerror(r));
 		return 2;
 	}
  	e = sc_file_get_acl_entry(file, SC_AC_OP_READ);
  	if (e == NULL || e->method == SC_AC_NEVER)
  		return 10;
	bufsize = file->size;
 	bufsize = MIN(file->size, sizeof buf);
  	sc_file_free(file);
  	r = sc_read_binary(card, 0, buf, bufsize, 0);
  	if (r < 0) {
 		fprintf(stderr, ""Unable to read private key file: %s\n"", sc_strerror(r));
 		return 2;
 	}
 	bufsize = r;
 	do {
 		if (bufsize < 4)
 			return 3;
 		keysize = (p[0] << 8) | p[1];
 		if (keysize == 0)
 			break;
 		if (keysize < 3)
 			return 3;
 		if (p[2] == opt_key_num)
 			break;
 		p += keysize;
 		bufsize -= keysize;
 	} while (1);
 	if (keysize == 0) {
 		printf(""Key number %d not found.\n"", opt_key_num);
 		return 2;
 	}
 	return parse_private_key(p, keysize, rsa);
 }","[21, 22]",A double free when handling responses from an HSM Card in sc_pkcs15emu_sc_hsm_init in libopensc/pkcs15-sc-hsm.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.,OpenSC,CVE-2018-16425,CWE-415
858,5704,"void SavePayload(size_t handle, uint32_t *payload, uint32_t index)
{
mp4object *mp4 = (mp4object *)handle;
if (mp4 == NULL) return;
uint32_t *MP4buffer = NULL;
if (index < mp4->indexcount && mp4->mediafp && payload)
{
LONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);
fwrite(payload, 1, mp4->metasizes[index], mp4->mediafp);
}
return;
}","[3, 4, 5, 6, 8, 9, 11]",GoPro GPMF-parser 1.2.2 has a heap-based buffer over-read (4 bytes) in GPMF_Next in GPMF_parser.c.,gpmf-parser,CVE-2019-15146,CWE-125
861,7999,"int PackMachBase<T>::canUnpack()
{
unsigned const lc_seg = lc_segment[sizeof(Addr)>>3];
fi->seek(0, SEEK_SET);
fi->readx(&mhdri, sizeof(mhdri));
if (((unsigned) Mach_header::MH_MAGIC + (sizeof(Addr)>>3)) !=mhdri.magic
||  my_cputype   !=mhdri.cputype
||  my_filetype  !=mhdri.filetype
)
return false;
my_cpusubtype = mhdri.cpusubtype;
unsigned const ncmds = mhdri.ncmds;
int headway = (int)mhdri.sizeofcmds;
if ((2 == ncmds
&& headway < (int)(sizeof(Mach_segment_command) + 4*4))
||  (3 <= ncmds
&& headway < (int)(3 * sizeof(Mach_segment_command)
+ sizeof(Mach_main_command)))) {
infoWarning(""Mach_header.sizeofcmds = %d too small"", headway);
throwCantUnpack(""file corrupted"");
}
sz_mach_headers = headway + sizeof(mhdri);
if (2048 < headway) {
infoWarning(""Mach_header.sizeofcmds(%d) > 2048"", headway);
}
rawmseg_buf.alloc(mhdri.sizeofcmds);
rawmseg = (Mach_segment_command *)rawmseg_buf.getVoidPtr();
fi->readx(rawmseg, mhdri.sizeofcmds);
Mach_segment_command const *ptrTEXT = nullptr;
upx_uint64_t rip = 0;
unsigned style = 0;
off_t offLINK = 0;
unsigned pos_next = 0;
unsigned nseg = 0;
Mach_command const *ptr = (Mach_command const *)rawmseg;
for (unsigned j= 0; j < ncmds;
ptr = (Mach_command const *)(ptr->cmdsize + (char const *)ptr), ++j) {
if ((unsigned)headway < ptr->cmdsize) {
infoWarning(""bad Mach_command[%u]{@0x%lx,+0x%x}: file_size=0x%lx  cmdsize=0x%lx"",
j, (unsigned long) (sizeof(mhdri) + ((char const *)ptr - (char const *)rawmseg)), headway,
(unsigned long) file_size, (unsigned long)ptr->cmdsize);
throwCantUnpack(""file corrupted"");
}
if (lc_seg == ptr->cmd) {
Mach_segment_command const *const segptr = (Mach_segment_command const *)ptr;
if ((unsigned long)file_size < segptr->filesize
||  (unsigned long)file_size < segptr->fileoff
||  (unsigned long)file_size < (segptr->filesize + segptr->fileoff)) {
infoWarning(""bad Mach_segment_command[%u]{@0x%lx,+0x%x}: file_size=0x%lx  cmdsize=0x%lx""
""  filesize=0x%lx  fileoff=0x%lx"",
j, (unsigned long) (sizeof(mhdri) + ((char const *)ptr - (char const *)rawmseg)), headway,
(unsigned long) file_size, (unsigned long)ptr->cmdsize,
(unsigned long)segptr->filesize, (unsigned long)segptr->fileoff);
throwCantUnpack(""file corrupted"");
}
++nseg;
if (!strcmp(""__XHDR"", segptr->segname)) {
style = 391;
}
if (!strcmp(""__TEXT"", segptr->segname)) {
ptrTEXT = segptr;
style = 391;
}
if (!strcmp(""UPX_DATA"", segptr->segname)) {
style = 392;
}
if (!strcmp(""__LINKEDIT"", segptr->segname)) {
offLINK = segptr->fileoff;
if (segptr->filesize == blankLINK) {
style = 395;
}
if (offLINK < (off_t) pos_next) {
offLINK = pos_next;
}
}
pos_next = segptr->filesize + segptr->fileoff;
if ((headway -= ptr->cmdsize) < 0) {
infoWarning(""Mach_command[%u]{@%lu}.cmdsize = %u"", j,
(unsigned long) (sizeof(mhdri) + mhdri.sizeofcmds - (headway + ptr->cmdsize)),
(unsigned)ptr->cmdsize);
throwCantUnpack(""sum(.cmdsize) exceeds .sizeofcmds"");
}
}
else if (Mach_command::LC_UNIXTHREAD==ptr->cmd) {
rip = entryVMA = threadc_getPC(ptr);
}
}
if (3==nseg && 395 != style) {
style = 392;
}
if (391==style && 0==offLINK && 2==ncmds && ptrTEXT) {
offLINK = ptrTEXT->fileoff + ptrTEXT->filesize;
}
if (0 == style || 0 == offLINK) {
return false;
}
int const small = 32 + sizeof(overlay_offset);
unsigned bufsize = 4096;
if (391 == style) {
fi->seek(offLINK - bufsize, SEEK_SET);
} else
if (392 == style) {
if (MH_DYLIB == my_filetype) {
fi->seek(fi->st_size() - bufsize, SEEK_SET);
}
else {
if ((off_t)bufsize > (fi->st_size() - offLINK)) {
bufsize = fi->st_size() - offLINK;
}
fi->seek(offLINK, SEEK_SET);
}
} else
if (395 == style) {
fi->seek(offLINK - bufsize - sizeof(PackHeader), SEEK_SET);
}
MemBuffer buf(bufsize);
fi->readx(buf, bufsize);
int i = bufsize;
while (i > small && 0 == buf[--i]) { }
i -= small;
if (i < 1 || !getPackHeader(buf + i, bufsize - i, true)) {
upx_uint64_t const rip_off = ptrTEXT ? (rip - ptrTEXT->vmaddr) : 0;
if (ptrTEXT && rip && rip_off < ptrTEXT->vmsize) {
fi->seek(ptrTEXT->fileoff + rip_off, SEEK_SET);
fi->readx(buf, bufsize);
unsigned char const *b = &buf[0];
unsigned disp = *(TE32 const *)&b[1];
if (0xe8==b[0] && disp < bufsize
&&  0x5d==b[5+disp] && 0xe8==b[6+disp]) {
unsigned disp2 = 0u - *(TE32 const *)&b[7+disp];
if (disp2 < (12+disp) && 0x5b==b[11+disp-disp2]) {
struct b_info const *bptr = (struct b_info const *)&b[11+disp];
if (bptr->sz_cpr < bptr->sz_unc && bptr->sz_unc < 0x1000) {
b = bptr->sz_cpr + (unsigned char const *)(1+ bptr);
overlay_offset = *(TE32 const *)(32 + b);
if (overlay_offset < 0x1000) {
return true;
}
overlay_offset = 0;
}
}
}
}
if (391==style) {
TE32 const *uptr = (TE32 const *)&buf[bufsize];
while (0==*--uptr)           ;
overlay_offset = *uptr;
if (mhdri.sizeofcmds <= overlay_offset && overlay_offset < 0x1000) {
return true;
}
overlay_offset = 0;
return false;
}
if (392==style) {
overlay_offset = 0x100c;
fi->seek(overlay_offset, SEEK_SET);
fi->readx(buf, bufsize);
struct p_info const *const p_ptr = (struct p_info const *)&buf[0];
struct b_info const *const b_ptr = (struct b_info const *)(1+ p_ptr);
TE32 const *uptr = (TE32 const *)(1+ b_ptr);
if (b_ptr->sz_unc < 0x4000
&&  b_ptr->sz_cpr < b_ptr->sz_unc ) {
unsigned const method = b_ptr->b_method;
if ((M_NRV2B_LE32 == method || M_NRV2E_LE32 == method)
&&  (0xff>>2)==(uptr[0] >> (2+ 24))
&&  (Mach_header::MH_MAGIC + (sizeof(Addr)>>3)) == uptr[1]) {
return true;
}
unsigned const magic = get_te32(1+ (char const *)uptr);
if ((M_NRV2B_8 == method || M_NRV2E_8 == method)
&& 0xfc==(0xfc & uptr[0])
&&  (Mach_header::MH_MAGIC + (sizeof(Addr)>>3)) == magic) {
return true;
}
}
overlay_offset = 0;
fi->seek(offLINK - 0x1000, SEEK_SET);
fi->readx(buf, 0x1000);
unsigned const *const lo = (unsigned const *)&buf[0];
unsigned const *p;
for (p = (unsigned const *)&buf[0x1000]; p > lo; ) if (*--p) {
overlay_offset  = *(TE32 const *)p;
if ((off_t)overlay_offset < offLINK) {
overlay_offset = ((char const *)p - (char const *)lo) +
(offLINK - 0x1000) - overlay_offset + sizeof(l_info);
fi->seek(overlay_offset, SEEK_SET);
fi->readx(buf, bufsize);
if (b_ptr->sz_unc < 0x4000
&&  b_ptr->sz_cpr < b_ptr->sz_unc ) {
return true;
}
}
}
}
}
overlay_offset = 0;
int l = ph.buf_offset + ph.getPackHeaderSize();
if (0 <= l && (unsigned)(l + sizeof(TE32)) <=bufsize) {
overlay_offset = get_te32(buf + i + l);
}
if (       overlay_offset < sz_mach_headers
||  (off_t)overlay_offset >= file_size) {
infoWarning(""file corrupted"");
MemBuffer buf2(umin(1<<14, file_size));
fi->seek(sz_mach_headers, SEEK_SET);
fi->readx(buf2, buf2.getSize());
unsigned const *p = (unsigned const *)&buf2[0];
unsigned const *const e_buf2 = (unsigned const *)&buf2[buf2.getSize() - 4*sizeof(*p)];
for (; p <= e_buf2; ++p)
if (   0==p[0]
&&     0!=p[1]
&&  p[2]==p[1]
&&  (unsigned)file_size < get_te32(&p[1])
&&  sz_mach_headers==get_te32(&p[3])
) {
overlay_offset = ((char const *)p - (char const *)&buf2[0]) + sz_mach_headers;
if (!(3&overlay_offset
||        overlay_offset < sz_mach_headers
|| (off_t)overlay_offset >= file_size)) {
infoWarning(""attempting recovery, overlay_offset = %#x"", overlay_offset);
return true;
}
}
throwCantUnpack(""file corrupted"");
}
return true;
}",[26],"An assertion abort was found in upx MemBuffer::alloc() in mem.cpp, in version UPX 4.0.0. The flow allows attackers to cause a denial of service (abort) via a crafted file.",upx,CVE-2021-30501,CWE-617
864,8050,"GF_Err stbl_AddDTS(GF_SampleTableBox *stbl, u64 DTS, u32 *sampleNumber, u32 LastAUDefDuration, u32 nb_packed_samples)
{
u32 i, j, sampNum;
u64 *DTSs, curDTS;
Bool inserted;
GF_SttsEntry *ent;
GF_TimeToSampleBox *stts = stbl->TimeToSample;
stts->r_FirstSampleInEntry = 0;
*sampleNumber = 0;
if (!nb_packed_samples)
nb_packed_samples=1;
if (!stts->nb_entries) {
if (DTS) return GF_BAD_PARAM;
stts->alloc_size = 1;
stts->nb_entries = 1;
stts->entries = gf_malloc(sizeof(GF_SttsEntry));
if (!stts->entries) return GF_OUT_OF_MEM;
stts->entries[0].sampleCount = nb_packed_samples;
stts->entries[0].sampleDelta = (nb_packed_samples>1) ? 0 : LastAUDefDuration;
(*sampleNumber) = 1;
stts->w_currentSampleNum = nb_packed_samples;
return GF_OK;
}
if (DTS >= stts->w_LastDTS) {
u32 nb_extra = 0;
ent = &stts->entries[stts->nb_entries-1];
if (!ent->sampleDelta && (ent->sampleCount>1)) {
ent->sampleDelta = (u32) ( DTS / ent->sampleCount);
stts->w_LastDTS = DTS - ent->sampleDelta;
}
if ((DTS == stts->w_LastDTS + ent->sampleDelta)
|| ((nb_packed_samples>1) && ((DTS == stts->w_LastDTS) || (DTS == stts->w_LastDTS + 2*ent->sampleDelta) ))
) {
(*sampleNumber) = stts->w_currentSampleNum + 1;
ent->sampleCount += nb_packed_samples;
stts->w_currentSampleNum += nb_packed_samples;
stts->w_LastDTS = DTS + ent->sampleDelta * (nb_packed_samples-1);
return GF_OK;
}
if (ent->sampleCount == 1) {
#if 0
if (stts->w_LastDTS)
ent->sampleDelta += (u32) (DTS - stts->w_LastDTS);
else
ent->sampleDelta = (u32) DTS;
#else
ent->sampleDelta = (u32) (DTS - stts->w_LastDTS);
#endif
ent->sampleCount ++;
if ((stts->nb_entries>=2) && (ent->sampleDelta== stts->entries[stts->nb_entries-2].sampleDelta)) {
stts->entries[stts->nb_entries-2].sampleCount += ent->sampleCount;
stts->nb_entries--;
}
stts->w_currentSampleNum ++;
stts->w_LastDTS = DTS;
(*sampleNumber) = stts->w_currentSampleNum;
return GF_OK;
}
ent->sampleCount --;
if (nb_packed_samples>1)
nb_extra = 1;
if (stts->alloc_size <= stts->nb_entries + nb_extra) {
ALLOC_INC(stts->alloc_size);
stts->entries = gf_realloc(stts->entries, sizeof(GF_SttsEntry)*stts->alloc_size);
if (!stts->entries) return GF_OUT_OF_MEM;
memset(&stts->entries[stts->nb_entries], 0, sizeof(GF_SttsEntry)*(stts->alloc_size-stts->nb_entries) );
}
if (nb_extra)
nb_extra = stts->entries[stts->nb_entries-1].sampleDelta;
ent = &stts->entries[stts->nb_entries];
stts->nb_entries++;
if (nb_packed_samples==1) {
ent->sampleCount = 2;
ent->sampleDelta = (u32) (DTS - stts->w_LastDTS);
stts->w_LastDTS = DTS;
(*sampleNumber) = stts->w_currentSampleNum+1;
stts->w_currentSampleNum += 1;
return GF_OK;
}
ent->sampleCount = 1;
ent->sampleDelta = (u32) (DTS - stts->w_LastDTS);
ent = &stts->entries[stts->nb_entries];
stts->nb_entries++;
ent->sampleCount = nb_packed_samples;
ent->sampleDelta = nb_extra;
stts->w_LastDTS = DTS;
(*sampleNumber) = stts->w_currentSampleNum + 1;
stts->w_currentSampleNum += nb_packed_samples;
return GF_OK;
}
DTSs = (u64*)gf_malloc(sizeof(u64) * (stbl->SampleSize->sampleCount+2) );
if (!DTSs) return GF_OUT_OF_MEM;
curDTS = 0;
sampNum = 0;
ent = NULL;
inserted = 0;
for (i=0; i<stts->nb_entries; i++) {
ent = & stts->entries[i];
for (j = 0; j<ent->sampleCount; j++) {
if (!inserted && (curDTS > DTS)) {
DTSs[sampNum] = DTS;
sampNum++;
*sampleNumber = sampNum;
inserted = 1;
}
DTSs[sampNum] = curDTS;
curDTS += ent->sampleDelta;
sampNum ++;
}
}
if (!inserted) {
gf_free(DTSs);
return GF_BAD_PARAM;
}
if (stts->nb_entries+3 >= stts->alloc_size) {
stts->alloc_size += 3;
stts->entries = gf_realloc(stts->entries, sizeof(GF_SttsEntry)*stts->alloc_size);
if (!stts->entries) return GF_OUT_OF_MEM;
memset(&stts->entries[stts->nb_entries], 0, sizeof(GF_SttsEntry)*(stts->alloc_size - stts->nb_entries) );
}
j=0;
stts->nb_entries = 1;
stts->entries[0].sampleCount = 1;
stts->entries[0].sampleDelta = (u32) DTSs[1]                           ;
for (i=1; i<stbl->SampleSize->sampleCount+1; i++) {
if (i == stbl->SampleSize->sampleCount) {
stts->entries[j].sampleCount++;
} else if (stts->entries[j].sampleDelta == (u32) ( DTSs[i+1] - DTSs[i]) ) {
stts->entries[j].sampleCount ++;
} else {
stts->nb_entries ++;
j++;
stts->entries[j].sampleCount = 1;
stts->entries[j].sampleDelta = (u32) (DTSs[i+1] - DTSs[i]);
}
}
gf_free(DTSs);
stts->w_currentSampleNum = stbl->SampleSize->sampleCount + 1;
return GF_OK;
}","[10, 11, 18, 19, 21, 32, 35, 36, 37, 60, 72, 84, 88]",Buffer overflow in the stbl_AppendSize function in MP4Box in GPAC 1.0.1 allows attackers to cause a denial of service or execute arbitrary code via a crafted file.,gpac,CVE-2021-32439,CWE-120
868,9461,"xmlAddRef(xmlValidCtxtPtr ctxt, xmlDocPtr doc, const xmlChar *value,
xmlAttrPtr attr) {
xmlRefPtr ret;
xmlRefTablePtr table;
xmlListPtr ref_list;
if (doc == NULL) {
return(NULL);
}
if (value == NULL) {
return(NULL);
}
if (attr == NULL) {
return(NULL);
}
table = (xmlRefTablePtr) doc->refs;
if (table == NULL) {
doc->refs = table = xmlHashCreateDict(0, doc->dict);
}
if (table == NULL) {
xmlVErrMemory(ctxt,
""xmlAddRef: Table creation failed!\n"");
return(NULL);
}
ret = (xmlRefPtr) xmlMalloc(sizeof(xmlRef));
if (ret == NULL) {
xmlVErrMemory(ctxt, ""malloc failed"");
return(NULL);
}
ret->value = xmlStrdup(value);
if ((ctxt != NULL) && (ctxt->vstateNr != 0)) {
ret->name = xmlStrdup(attr->name);
ret->attr = NULL;
} else {
ret->name = NULL;
ret->attr = attr;
}
ret->lineno = xmlGetLineNo(attr->parent);
if (NULL == (ref_list = xmlHashLookup(table, value))) {
if (NULL == (ref_list = xmlListCreate(xmlFreeRef, xmlDummyCompare))) {
xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
""xmlAddRef: Reference list creation failed!\n"",
NULL);
goto failed;
}
if (xmlHashAddEntry(table, value, ref_list) < 0) {
xmlListDelete(ref_list);
xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
""xmlAddRef: Reference list insertion failed!\n"",
NULL);
goto failed;
}
}
if (xmlListAppend(ref_list, ret) != 0) {
xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
""xmlAddRef: Reference list insertion failed!\n"",
NULL);
goto failed;
}
return(ret);
failed:
if (ret != NULL) {
if (ret->value != NULL)
xmlFree((char *)ret->value);
if (ret->name != NULL)
xmlFree((char *)ret->name);
xmlFree(ret);
}
return(NULL);
}",[30],valid.c in libxml2 before 2.9.13 has a use-after-free of ID and IDREF attributes.,libxml2,CVE-2022-23308,CWE-416
874,7630,"int init_aliases(void)
{
FILE *fp;
char alias[MAXALIASLEN + 1U];
char dir[PATH_MAX + 1U];
if ((fp = fopen(ALIASES_FILE, ""r"")) == NULL) {
return 0;
}
while (fgets(alias, sizeof alias, fp) != NULL) {
if (*alias == '#' || *alias == '\n' || *alias == 0) {
continue;
}
{
char * const z = alias + strlen(alias) - 1U;
if (*z != '\n') {
goto bad;
}
*z = 0;
}
do {
if (fgets(dir, sizeof dir, fp) == NULL || *dir == 0) {
goto bad;
}
{
char * const z = dir + strlen(dir) - 1U;
if (*z == '\n') {
*z = 0;
}
}
} while (*dir == '#' || *dir == 0);
if (head == NULL) {
if ((head = tail = malloc(sizeof *head)) == NULL ||
(tail->alias = strdup(alias)) == NULL ||
(tail->dir = strdup(dir)) == NULL) {
die_mem();
}
tail->next = NULL;
} else {
DirAlias *curr;
if ((curr = malloc(sizeof *curr)) == NULL ||
(curr->alias = strdup(alias)) == NULL ||
(curr->dir = strdup(dir)) == NULL) {
die_mem();
}
tail->next = curr;
tail = curr;
}
}
fclose(fp);
aliases_up++;
return 0;
bad:
fclose(fp);
logfile(LOG_ERR, MSG_ALIASES_BROKEN_FILE "" ["" ALIASES_FILE ""]"");
return -1;
}","[37, 49]","An issue was discovered in Pure-FTPd 1.0.49. An uninitialized pointer vulnerability has been detected in the diraliases linked list. When the *lookup_alias(const char alias) or print_aliases(void) function is called, they fail to correctly detect the end of the linked list and try to access a non-existent list member. This is related to init_aliases in diraliases.c.",pure-ftpd,CVE-2020-9274,CWE-824
875,5866,"archive_read_format_rar_read_data(struct archive_read *a, const void **buff,
size_t *size, int64_t *offset)
{
struct rar *rar = (struct rar *)(a->format->data);
int ret;
if (rar->has_encrypted_entries == ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW) {
rar->has_encrypted_entries = 0;
}
if (rar->bytes_unconsumed > 0) {
__archive_read_consume(a, rar->bytes_unconsumed);
rar->bytes_unconsumed = 0;
}
*buff = NULL;
if (rar->entry_eof || rar->offset_seek >= rar->unp_size) {
*size = 0;
*offset = rar->offset;
if (*offset < rar->unp_size)
*offset = rar->unp_size;
return (ARCHIVE_EOF);
}
switch (rar->compression_method)
{
case COMPRESS_METHOD_STORE:
ret = read_data_stored(a, buff, size, offset);
break;
case COMPRESS_METHOD_FASTEST:
case COMPRESS_METHOD_FAST:
case COMPRESS_METHOD_NORMAL:
case COMPRESS_METHOD_GOOD:
case COMPRESS_METHOD_BEST:
ret = read_data_compressed(a, buff, size, offset);
if (ret != ARCHIVE_OK && ret != ARCHIVE_WARN)
__archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context);
break;
default:
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
""Unsupported compression method for RAR file."");
ret = ARCHIVE_FATAL;
break;
}
return (ret);
}","[32, 34]","archive_read_format_rar_read_data in archive_read_support_format_rar.c in libarchive before 3.4.0 has a use-after-free in a certain ARCHIVE_FAILED situation, related to Ppmd7_DecodeSymbol.",libarchive,CVE-2019-18408,CWE-416
877,6143,"static void gf_m2ts_process_pmt(GF_M2TS_Demuxer *ts, GF_M2TS_SECTION_ES *pmt, GF_List *sections, u8 table_id, u16 ex_table_id, u8 version_number, u8 last_section_number, u32 status)
{
u32 info_length, pos, desc_len, evt_type, nb_es,i;
u32 nb_sections;
u32 data_size;
u32 nb_hevc, nb_hevc_temp, nb_shvc, nb_shvc_temp, nb_mhvc, nb_mhvc_temp;
unsigned char *data;
GF_M2TS_Section *section;
GF_Err e = GF_OK;
if (!(status&GF_M2TS_TABLE_END)) return;
nb_es = 0;
if ((status&GF_M2TS_TABLE_REPEAT) && !(status&GF_M2TS_TABLE_UPDATE))  {
if (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_PMT_REPEAT, pmt->program);
return;
}
if (pmt->sec->demux_restarted) {
pmt->sec->demux_restarted = 0;
return;
}
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[MPEG-2 TS] PMT Found or updated\n""));
nb_sections = gf_list_count(sections);
if (nb_sections > 1) {
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""PMT on multiple sections not supported\n""));
}
section = (GF_M2TS_Section *)gf_list_get(sections, 0);
data = section->data;
data_size = section->data_size;
pmt->program->pcr_pid = ((data[0] & 0x1f) << 8) | data[1];
info_length = ((data[2]&0xf)<<8) | data[3];
if (info_length != 0) {
u8 tag, len;
u32 first_loop_len = 0;
tag = data[4];
len = data[5];
while (info_length > first_loop_len) {
if (tag == GF_M2TS_MPEG4_IOD_DESCRIPTOR) {
u32 size;
GF_BitStream *iod_bs;
iod_bs = gf_bs_new((char *)data+8, len-2, GF_BITSTREAM_READ);
if (pmt->program->pmt_iod) gf_odf_desc_del((GF_Descriptor *)pmt->program->pmt_iod);
e = gf_odf_parse_descriptor(iod_bs , (GF_Descriptor **) &pmt->program->pmt_iod, &size);
gf_bs_del(iod_bs );
if (e==GF_OK) {
if (pmt->program->pmt_iod) pmt->program->pmt_iod->ServiceID = pmt->program->number;
if (!gf_list_count(pmt->program->pmt_iod->ESDescriptors)) {
gf_odf_desc_del((GF_Descriptor *)pmt->program->pmt_iod);
pmt->program->pmt_iod = NULL;
}
}
} else if (tag == GF_M2TS_METADATA_POINTER_DESCRIPTOR) {
GF_BitStream *metadatapd_bs;
GF_M2TS_MetadataPointerDescriptor *metapd;
metadatapd_bs = gf_bs_new((char *)data+6, len, GF_BITSTREAM_READ);
metapd = gf_m2ts_read_metadata_pointer_descriptor(metadatapd_bs, len);
gf_bs_del(metadatapd_bs);
if (metapd->application_format_identifier == GF_M2TS_META_ID3 &&
metapd->format_identifier == GF_M2TS_META_ID3 &&
metapd->carriage_flag == METADATA_CARRIAGE_SAME_TS) {
pmt->program->metadata_pointer_descriptor = metapd;
} else {
gf_m2ts_metadata_pointer_descriptor_del(metapd);
}
} else {
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[MPEG-2 TS] Skipping descriptor (0x%x) and others not supported\n"", tag));
}
first_loop_len += 2 + len;
}
}
if (data_size <= 4 + info_length) return;
data += 4 + info_length;
data_size -= 4 + info_length;
pos = 0;
for(i=0; i<gf_list_count(ts->programs); i++) {
GF_M2TS_Program *prog = (GF_M2TS_Program *)gf_list_get(ts->programs,i);
if(prog->pmt_pid == pmt->pid) {
break;
}
}
nb_hevc = nb_hevc_temp = nb_shvc = nb_shvc_temp = nb_mhvc = nb_mhvc_temp = 0;
while (pos<data_size) {
GF_M2TS_PES *pes = NULL;
GF_M2TS_SECTION_ES *ses = NULL;
GF_M2TS_ES *es = NULL;
Bool inherit_pcr = 0;
u32 pid, stream_type, reg_desc_format;
if (pos + 5 > data_size) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""Broken PMT! size %d but position %d and need at least 5 bytes to declare es\n"", data_size, pos));
break;
}
stream_type = data[0];
pid = ((data[1] & 0x1f) << 8) | data[2];
desc_len = ((data[3] & 0xf) << 8) | data[4];
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""stream_type :%d \n"",stream_type));
switch (stream_type) {
case GF_M2TS_VIDEO_MPEG1:
case GF_M2TS_VIDEO_MPEG2:
case GF_M2TS_VIDEO_DCII:
case GF_M2TS_VIDEO_MPEG4:
case GF_M2TS_SYSTEMS_MPEG4_PES:
case GF_M2TS_VIDEO_H264:
case GF_M2TS_VIDEO_SVC:
case GF_M2TS_VIDEO_MVCD:
case GF_M2TS_VIDEO_HEVC:
case GF_M2TS_VIDEO_HEVC_MCTS:
case GF_M2TS_VIDEO_HEVC_TEMPORAL:
case GF_M2TS_VIDEO_SHVC:
case GF_M2TS_VIDEO_SHVC_TEMPORAL:
case GF_M2TS_VIDEO_MHVC:
case GF_M2TS_VIDEO_MHVC_TEMPORAL:
inherit_pcr = 1;
case GF_M2TS_AUDIO_MPEG1:
case GF_M2TS_AUDIO_MPEG2:
case GF_M2TS_AUDIO_AAC:
case GF_M2TS_AUDIO_LATM_AAC:
case GF_M2TS_AUDIO_AC3:
case GF_M2TS_AUDIO_DTS:
case GF_M2TS_MHAS_MAIN:
case GF_M2TS_MHAS_AUX:
case GF_M2TS_SUBTITLE_DVB:
case GF_M2TS_METADATA_PES:
GF_SAFEALLOC(pes, GF_M2TS_PES);
if (!pes) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[MPEG2TS] Failed to allocate ES for pid %d\n"", pid));
return;
}
pes->cc = -1;
pes->flags = GF_M2TS_ES_IS_PES;
if (inherit_pcr)
pes->flags |= GF_M2TS_INHERIT_PCR;
es = (GF_M2TS_ES *)pes;
break;
case GF_M2TS_PRIVATE_DATA:
GF_SAFEALLOC(pes, GF_M2TS_PES);
if (!pes) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[MPEG2TS] Failed to allocate ES for pid %d\n"", pid));
return;
}
pes->cc = -1;
pes->flags = GF_M2TS_ES_IS_PES;
es = (GF_M2TS_ES *)pes;
break;
case GF_M2TS_SYSTEMS_MPEG4_SECTIONS:
GF_SAFEALLOC(ses, GF_M2TS_SECTION_ES);
if (!ses) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[MPEG2TS] Failed to allocate ES for pid %d\n"", pid));
return;
}
es = (GF_M2TS_ES *)ses;
es->flags |= GF_M2TS_ES_IS_SECTION;
if (stream_type == GF_M2TS_SYSTEMS_MPEG4_SECTIONS) {
ses->sec = gf_m2ts_section_filter_new(gf_m2ts_process_mpeg4section, 0);
if (!pmt->program->additional_ods) {
pmt->program->additional_ods = gf_list_new();
ts->has_4on2 = 1;
}
}
break;
case GF_M2TS_13818_6_ANNEX_A:
case GF_M2TS_13818_6_ANNEX_B:
case GF_M2TS_13818_6_ANNEX_C:
case GF_M2TS_13818_6_ANNEX_D:
case GF_M2TS_PRIVATE_SECTION:
case GF_M2TS_QUALITY_SEC:
case GF_M2TS_MORE_SEC:
GF_SAFEALLOC(ses, GF_M2TS_SECTION_ES);
if (!ses) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[MPEG2TS] Failed to allocate ES for pid %d\n"", pid));
return;
}
es = (GF_M2TS_ES *)ses;
es->flags |= GF_M2TS_ES_IS_SECTION;
es->pid = pid;
es->service_id = pmt->program->number;
if (stream_type == GF_M2TS_PRIVATE_SECTION) {
GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (""AIT sections on pid %d\n"", pid));
} else if (stream_type == GF_M2TS_QUALITY_SEC) {
GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (""Quality metadata sections on pid %d\n"", pid));
} else if (stream_type == GF_M2TS_MORE_SEC) {
GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (""MORE sections on pid %d\n"", pid));
} else {
GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (""stream type DSM CC user private sections on pid %d \n"", pid));
}
ses->sec = gf_m2ts_section_filter_new(NULL, 1);
break;
case GF_M2TS_MPE_SECTIONS:
if (! ts->prefix_present) {
GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (""stream type MPE found : pid = %d \n"", pid));
#ifdef GPAC_ENABLE_MPE
es = gf_dvb_mpe_section_new();
if (es->flags & GF_M2TS_ES_IS_SECTION) {
((GF_M2TS_SECTION_ES*)es)->sec = gf_m2ts_section_filter_new(NULL, 1);
}
#endif
break;
}
default:
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[MPEG-2 TS] Stream type (0x%x) for PID %d not supported\n"", stream_type, pid ) );
break;
}
if (es) {
es->stream_type = (stream_type==GF_M2TS_PRIVATE_DATA) ? 0 : stream_type;
es->program = pmt->program;
es->pid = pid;
es->component_tag = -1;
}
pos += 5;
data += 5;
while (desc_len) {
if (pos + 2 > data_size) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""Broken PMT descriptor! size %d but position %d and need at least 2 bytes to parse descritpor\n"", data_size, pos));
break;
}
u8 tag = data[0];
u32 len = data[1];
if (pos + 2 + len > data_size) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""Broken PMT descriptor! size %d, desc size %d but position %d\n"", data_size, len, pos));
break;
}
if (es) {
switch (tag) {
case GF_M2TS_ISO_639_LANGUAGE_DESCRIPTOR:
if (pes && (len>=3) )
pes->lang = GF_4CC(' ', data[2], data[3], data[4]);
break;
case GF_M2TS_MPEG4_SL_DESCRIPTOR:
if (len>=2) {
es->mpeg4_es_id = ( (u32) data[2] & 0x1f) << 8  | data[3];
es->flags |= GF_M2TS_ES_IS_SL;
}
break;
case GF_M2TS_REGISTRATION_DESCRIPTOR:
if (len>=4) {
reg_desc_format = GF_4CC(data[2], data[3], data[4], data[5]);
switch (reg_desc_format) {
case GF_M2TS_RA_STREAM_AC3:
es->stream_type = GF_M2TS_AUDIO_AC3;
break;
case GF_M2TS_RA_STREAM_VC1:
es->stream_type = GF_M2TS_VIDEO_VC1;
break;
case GF_M2TS_RA_STREAM_GPAC:
if (len==8) {
es->stream_type = GF_4CC(data[6], data[7], data[8], data[9]);
es->flags |= GF_M2TS_GPAC_CODEC_ID;
break;
}
default:
GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (""Unknown registration descriptor %s\n"", gf_4cc_to_str(reg_desc_format) ));
break;
}
}
break;
case GF_M2TS_DVB_EAC3_DESCRIPTOR:
es->stream_type = GF_M2TS_AUDIO_EC3;
break;
case GF_M2TS_DVB_DATA_BROADCAST_ID_DESCRIPTOR:
if (len>=2) {
u32 id = data[2]<<8 | data[3];
if ((id == 0xB) && ses && !ses->sec) {
ses->sec = gf_m2ts_section_filter_new(NULL, 1);
}
}
break;
case GF_M2TS_DVB_SUBTITLING_DESCRIPTOR:
if (pes && (len>=8)) {
pes->sub.language[0] = data[2];
pes->sub.language[1] = data[3];
pes->sub.language[2] = data[4];
pes->sub.type = data[5];
pes->sub.composition_page_id = (data[6]<<8) | data[7];
pes->sub.ancillary_page_id = (data[8]<<8) | data[9];
}
es->stream_type = GF_M2TS_DVB_SUBTITLE;
break;
case GF_M2TS_DVB_STREAM_IDENTIFIER_DESCRIPTOR:
if (len>=1) {
es->component_tag = data[2];
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""Component Tag: %d on Program %d\n"", es->component_tag, es->program->number));
}
break;
case GF_M2TS_DVB_TELETEXT_DESCRIPTOR:
es->stream_type = GF_M2TS_DVB_TELETEXT;
break;
case GF_M2TS_DVB_VBI_DATA_DESCRIPTOR:
es->stream_type = GF_M2TS_DVB_VBI;
break;
case GF_M2TS_HIERARCHY_DESCRIPTOR:
if (pes && (len>=4)) {
u8 hierarchy_embedded_layer_index;
GF_BitStream *hbs = gf_bs_new((const char *)data, data_size, GF_BITSTREAM_READ);
gf_bs_read_int(hbs, 16);
gf_bs_read_int(hbs, 1);
gf_bs_read_int(hbs, 1);
gf_bs_read_int(hbs, 1);
gf_bs_read_int(hbs, 1);
gf_bs_read_int(hbs, 4);
gf_bs_read_int(hbs, 2);
gf_bs_read_int(hbs, 6);
gf_bs_read_int(hbs, 1);
gf_bs_read_int(hbs, 1);
hierarchy_embedded_layer_index = gf_bs_read_int(hbs, 6);
gf_bs_read_int(hbs, 2);
gf_bs_read_int(hbs, 6);
gf_bs_del(hbs);
pes->depends_on_pid = 1+hierarchy_embedded_layer_index;
}
break;
case GF_M2TS_METADATA_DESCRIPTOR:
{
GF_BitStream *metadatad_bs;
GF_M2TS_MetadataDescriptor *metad;
metadatad_bs = gf_bs_new((char *)data+2, len, GF_BITSTREAM_READ);
metad = gf_m2ts_read_metadata_descriptor(metadatad_bs, len);
gf_bs_del(metadatad_bs);
if (metad->application_format_identifier == GF_M2TS_META_ID3 &&
metad->format_identifier == GF_M2TS_META_ID3) {
if (pes) {
pes->metadata_descriptor = metad;
pes->stream_type = GF_M2TS_METADATA_ID3_HLS;
}
} else {
gf_m2ts_metadata_descriptor_del(metad);
}
}
break;
default:
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[MPEG-2 TS] skipping descriptor (0x%x) not supported\n"", tag));
break;
}
}
data += len+2;
pos += len+2;
if (desc_len < len+2) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[MPEG-2 TS] Invalid PMT es descriptor size for PID %d\n"", pid ) );
break;
}
desc_len-=len+2;
}
if (es && !es->stream_type) {
gf_free(es);
es = NULL;
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[MPEG-2 TS] Private Stream type (0x%x) for PID %d not supported\n"", stream_type, pid ) );
}
if (!es) continue;
if (ts->ess[pid]) {
if (status & GF_M2TS_TABLE_FOUND) {
GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (""[MPEG-2 TS] PID %d reused across programs %d and %d, not completely supported\n"", pid, ts->ess[pid]->program->number, es->program->number ) );
gf_list_add(pmt->program->streams, es);
if (!(es->flags & GF_M2TS_ES_IS_SECTION) ) gf_m2ts_set_pes_framing(pes, GF_M2TS_PES_FRAMING_SKIP);
nb_es++;
es = NULL;
}
else {
GF_M2TS_ES *o_es = ts->ess[es->pid];
if ((o_es->stream_type == es->stream_type)
&& ((o_es->flags & GF_M2TS_ES_STATIC_FLAGS_MASK) == (es->flags & GF_M2TS_ES_STATIC_FLAGS_MASK))
&& (o_es->mpeg4_es_id == es->mpeg4_es_id)
&& ((o_es->flags & GF_M2TS_ES_IS_SECTION) || ((GF_M2TS_PES *)o_es)->lang == ((GF_M2TS_PES *)es)->lang)
) {
gf_free(es);
es = NULL;
} else {
gf_m2ts_es_del(o_es, ts);
ts->ess[es->pid] = NULL;
}
}
}
if (es) {
ts->ess[es->pid] = es;
gf_list_add(pmt->program->streams, es);
if (!(es->flags & GF_M2TS_ES_IS_SECTION) ) gf_m2ts_set_pes_framing(pes, GF_M2TS_PES_FRAMING_SKIP);
nb_es++;
if (es->stream_type == GF_M2TS_VIDEO_HEVC) nb_hevc++;
else if (es->stream_type == GF_M2TS_VIDEO_HEVC_TEMPORAL) nb_hevc_temp++;
else if (es->stream_type == GF_M2TS_VIDEO_SHVC) nb_shvc++;
else if (es->stream_type == GF_M2TS_VIDEO_SHVC_TEMPORAL) nb_shvc_temp++;
else if (es->stream_type == GF_M2TS_VIDEO_MHVC) nb_mhvc++;
else if (es->stream_type == GF_M2TS_VIDEO_MHVC_TEMPORAL) nb_mhvc_temp++;
}
}
if (nb_hevc_temp + nb_shvc + nb_shvc_temp + nb_mhvc+ nb_mhvc_temp) {
for (i=0; i<gf_list_count(pmt->program->streams); i++) {
GF_M2TS_PES *es = (GF_M2TS_PES *)gf_list_get(pmt->program->streams, i);
if ( !(es->flags & GF_M2TS_ES_IS_PES)) continue;
if (es->depends_on_pid) continue;
switch (es->stream_type) {
case GF_M2TS_VIDEO_HEVC_TEMPORAL:
es->depends_on_pid = 1;
break;
case GF_M2TS_VIDEO_SHVC:
if (!nb_hevc_temp) es->depends_on_pid = 1;
else es->depends_on_pid = 2;
break;
case GF_M2TS_VIDEO_SHVC_TEMPORAL:
es->depends_on_pid = 3;
break;
case GF_M2TS_VIDEO_MHVC:
if (!nb_hevc_temp) es->depends_on_pid = 1;
else es->depends_on_pid = 2;
break;
case GF_M2TS_VIDEO_MHVC_TEMPORAL:
if (!nb_hevc_temp) es->depends_on_pid = 2;
else es->depends_on_pid = 3;
break;
}
}
}
if (nb_es) {
u32 i;
for (i=0; i<gf_list_count(pmt->program->streams); i++) {
GF_M2TS_PES *an_es = NULL;
GF_M2TS_PES *es = (GF_M2TS_PES *)gf_list_get(pmt->program->streams, i);
if ( !(es->flags & GF_M2TS_ES_IS_PES)) continue;
if (!es->depends_on_pid) continue;
an_es =  (GF_M2TS_PES *)gf_list_get(pmt->program->streams, es->depends_on_pid);
if (an_es) {
es->depends_on_pid = an_es->pid;
} else {
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[M2TS] Wrong dependency index in hierarchy descriptor, assuming non-scalable stream\n""));
es->depends_on_pid = 0;
}
}
evt_type = (status&GF_M2TS_TABLE_FOUND) ? GF_M2TS_EVT_PMT_FOUND : GF_M2TS_EVT_PMT_UPDATE;
if (ts->on_event) ts->on_event(ts, evt_type, pmt->program);
} else {
if (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_PMT_REPEAT, pmt->program);
}
}","[30, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 50]","An issue was discovered in libgpac.a in GPAC before 0.8.0, as demonstrated by MP4Box. It contains a heap-based buffer over-read in BS_ReadByte (called from gf_bs_read_bit) in utils/bitstream.c that can cause a denial of service via a crafted MP4 file.",gpac,CVE-2019-20630,CWE-125
889,7218,"static int src_parser_trans_stage_1_2_3(const int tmp_fd, const char *src, const struct trans_config cfg)
{
struct parser_buf pbuf = {
.f_indx = 0,
.tmp_indx = 0,
.f_read_size = 0
};
int write_count = 0;
int src_fd;
int p_state = P_STATE_CODE;
src_fd = open(src, O_RDONLY);
if (src_fd == -1) {
fprintf(stderr, ""**Error: Could not open source file: %s.\n"", src);
return -1;
}
while (p_buf_refill(&pbuf, src_fd) > 0) {
while (PBUF_F_REMD(pbuf)) {
switch (p_state) {
case P_STATE_COMMENT_C:
switch (PBUF_F_CHAR(pbuf)) {
case '*':
p_buf_push_tmp_char(&pbuf, '*');
continue;
case '/':
if (pbuf.tmp_indx && (PBUF_TMP_PREV_CHAR(pbuf) == '*')) {
pbuf.tmp_indx--;
p_state = P_STATE_CODE;
}
break;
default:
if (pbuf.tmp_indx && (PBUF_TMP_PREV_CHAR(pbuf) == '*'))
pbuf.tmp_indx--;
break;
}
pbuf.f_indx++;
case P_STATE_CODE:
default:
switch (PBUF_F_CHAR(pbuf)) {
case ' ':
case '\t':
if (pbuf.tmp_indx &&
(PBUF_TMP_PREV_CHAR(pbuf) == ' ' || PBUF_TMP_PREV_CHAR(pbuf) == '\t' ||
PBUF_TMP_PREV_CHAR(pbuf) == '\n'))
pbuf.f_indx++;
else
p_buf_push_tmp_char(&pbuf, ' ');
continue;
case '\r':
case '\n':
if (pbuf.tmp_indx &&
(PBUF_TMP_PREV_CHAR(pbuf) == ' ' || PBUF_TMP_PREV_CHAR(pbuf) == '\t' ||
PBUF_TMP_PREV_CHAR(pbuf) == '\n')) {
pbuf.f_indx++;
} else if (pbuf.tmp_indx &&
(PBUF_TMP_PREV_CHAR(pbuf) == '\\')) {
pbuf.tmp_indx--;
pbuf.f_indx++;
} else {
p_buf_push_tmp_char(&pbuf, '\n');
}
continue;
case '\\':
p_buf_push_tmp_char(&pbuf, '\\');
continue;
case '/':
p_buf_push_tmp_char(&pbuf, '/');
continue;
case '*':
if (pbuf.tmp_indx &&
(PBUF_TMP_PREV_CHAR(pbuf) == '/')) {
pbuf.tmp_indx--;
pbuf.f_indx++;
p_state = P_STATE_COMMENT_C;
continue;
}
default:
break;
}
p_buf_write_tmp(&pbuf, tmp_fd);
p_buf_write_f_char(&pbuf, tmp_fd);
}
}
}
p_buf_write_tmp(&pbuf, tmp_fd);
return 0;
}","[54, 63, 66]","Buffer overflow vulnerability in function src_parser_trans_stage_1_2_3 trgil gilcc before commit 803969389ca9c06237075a7f8eeb1a19e6651759, allows attackers to cause a denial of service.",gilcc,CVE-2020-21572,CWE-120
891,6122,"ngx_http_send_error_page(ngx_http_request_t *r, ngx_http_err_page_t *err_page)
{
ngx_int_t                  overwrite;
ngx_str_t                  uri, args;
ngx_table_elt_t           *location;
ngx_http_core_loc_conf_t  *clcf;
overwrite = err_page->overwrite;
if (overwrite && overwrite != NGX_HTTP_OK) {
r->expect_tested = 1;
}
if (overwrite >= 0) {
r->err_status = overwrite;
}
if (ngx_http_complex_value(r, &err_page->value, &uri) != NGX_OK) {
return NGX_ERROR;
}
if (uri.len && uri.data[0] == '/') {
if (err_page->value.lengths) {
ngx_http_split_args(r, &uri, &args);
} else {
args = err_page->args;
}
if (r->method != NGX_HTTP_HEAD) {
r->method = NGX_HTTP_GET;
r->method_name = ngx_http_core_get_method;
}
return ngx_http_internal_redirect(r, &uri, &args);
}
if (uri.len && uri.data[0] == '@') {
return ngx_http_named_location(r, &uri);
}
location = ngx_list_push(&r->headers_out.headers);
if (location == NULL) {
return NGX_ERROR;
}
if (overwrite != NGX_HTTP_MOVED_PERMANENTLY
&& overwrite != NGX_HTTP_MOVED_TEMPORARILY
&& overwrite != NGX_HTTP_SEE_OTHER
&& overwrite != NGX_HTTP_TEMPORARY_REDIRECT
&& overwrite != NGX_HTTP_PERMANENT_REDIRECT)
{
r->err_status = NGX_HTTP_MOVED_TEMPORARILY;
}
location->hash = 1;
ngx_str_set(&location->key, ""Location"");
location->value = uri;
ngx_http_clear_location(r);
r->headers_out.location = location;
clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);
if (clcf->msie_refresh && r->headers_in.msie) {
return ngx_http_send_refresh(r);
}
return ngx_http_send_special_response(r, clcf, r->err_status
- NGX_HTTP_MOVED_PERMANENTLY
+ NGX_HTTP_OFF_3XX);
}",[32],"NGINX before 1.17.7, with certain error_page configurations, allows HTTP request smuggling, as demonstrated by the ability of an attacker to read unauthorized web pages in environments where NGINX is being fronted by a load balancer.",nginx,CVE-2019-20372,CWE-444
896,9179,"int virtualbox_get_guest_property(char *name, void **value, size_t *size) {
errno = 0;
int _cleanup_close_ fd = open(""/dev/vboxguest"", O_RDWR | O_CLOEXEC);
if (fd == -1) {
return VERR_GENERAL_FAILURE;
}
int ret = version_info(fd);
if (ret != VINF_SUCCESS) {
return ret;
}
uint32_t client_id;
ret = connect(fd, &client_id);
if (ret != VINF_SUCCESS) {
return ret;
}
ret = get_prop(fd, client_id, name, value, size);
if (ret != VINF_SUCCESS) {
disconnect(fd, client_id);
return ret;
}
ret = disconnect(fd, client_id);
if (ret != VINF_SUCCESS) {
free(*value);
*value = NULL;
return ret;
}
errno = 0;
return 0;
}","[11, 12, 16]",A vulnerability was found in Ignition where ignition configs are accessible from unprivileged containers in VMs running on VMware products. This issue is only relevant in user environments where the Ignition config contains secrets. The highest threat from this vulnerability is to data confidentiality. Possible workaround is to not put secrets in the Ignition config.,ignition,CVE-2022-1706,CWE-863
910,7815,"String UTF16BEDecoder::to_utf8(const StringView& input)
{
StringBuilder builder(input.length() / 2);
for (size_t i = 0; i < input.length(); i += 2) {
u16 code_point = (input[i] << 8) | input[i + 1];
builder.append_code_point(code_point);
}
return builder.to_string();
}",[4],SerenityOS fixed as of c9f25bca048443e317f1994ba9b106f2386688c3 contains a buffer overflow vulnerability in LibTextCode through opening a crafted file.,serenity,CVE-2021-28874,CWE-120
924,8493,"static GF_Err gf_text_process_sub(GF_Filter *filter, GF_TXTIn *ctx)
{
u32 i, j, len, line;
GF_TextSample *samp;
Double ts_scale;
char szLine[2048], szTime[20], szText[2048];
if (!ctx->is_setup) {
ctx->is_setup = GF_TRUE;
return txtin_setup_srt(filter, ctx);
}
if (!ctx->opid) return GF_NOT_SUPPORTED;
if (!ctx->playstate) return GF_OK;
else if (ctx->playstate==2) return GF_EOS;
if (ctx->seek_state==1) {
ctx->seek_state = 2;
gf_fseek(ctx->src, 0, SEEK_SET);
}
if (ctx->fps.den && ctx->fps.num) {
ts_scale = ((Double) ctx->fps.num) / ctx->fps.den;
} else {
ts_scale = 25;
}
line = 0;
while (1) {
char *sOK = gf_text_get_utf8_line(szLine, 2048, ctx->src, ctx->unicode_type);
if (!sOK) break;
REM_TRAIL_MARKS(szLine, ""\r\n\t "")
line++;
len = (u32) strlen(szLine);
if (!len) continue;
i=0;
if (szLine[i] != '{') {
GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (""[TXTIn] Bad SUB file (line %d): expecting \""{\"" got \""%c\""\n"", line, szLine[i]));
continue;
}
while (szLine[i+1] && szLine[i+1]!='}') {
szTime[i] = szLine[i+1];
i++;
}
szTime[i] = 0;
ctx->start = atoi(szTime);
if (ctx->start < ctx->end) {
GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (""[TXTIn] corrupted SUB frame (line %d) - starts (at %d ms) before end of previous one (%d ms) - adjusting time stamps\n"", line, ctx->start, ctx->end));
ctx->start = ctx->end;
}
j=i+2;
i=0;
if (szLine[i+j] != '{') {
GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (""[TXTIn] Bad SUB file - expecting \""{\"" got \""%c\""\n"", szLine[i]));
continue;
}
while (szLine[i+1+j] && szLine[i+1+j]!='}') {
szTime[i] = szLine[i+1+j];
i++;
}
szTime[i] = 0;
ctx->end = atoi(szTime);
j+=i+2;
if (ctx->start > ctx->end) {
GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (""[TXTIn] corrupted SUB frame (line %d) - ends (at %d ms) before start of current frame (%d ms) - skipping\n"", line, ctx->end, ctx->start));
continue;
}
if (ctx->start && ctx->first_samp) {
samp = gf_isom_new_text_sample();
txtin_process_send_text_sample(ctx, samp, 0, (u32) (ts_scale*ctx->start), GF_TRUE);
ctx->first_samp = GF_FALSE;
gf_isom_delete_text_sample(samp);
}
for (i=j; i<len; i++) {
if (szLine[i]=='|') {
szText[i-j] = '\n';
} else {
szText[i-j] = szLine[i];
}
}
szText[i-j] = 0;
if (ctx->prev_end) {
samp = gf_isom_new_text_sample();
txtin_process_send_text_sample(ctx, samp, (u64) (ts_scale*(s64)ctx->prev_end), (u32) (ts_scale*(ctx->start - ctx->prev_end)), GF_TRUE);
gf_isom_delete_text_sample(samp);
}
samp = gf_isom_new_text_sample();
gf_isom_text_add_text(samp, szText, (u32) strlen(szText) );
txtin_process_send_text_sample(ctx, samp, (u64) (ts_scale*(s64)ctx->start), (u32) (ts_scale*(ctx->end - ctx->start)), GF_TRUE);
gf_isom_delete_text_sample(samp);
ctx->prev_end = ctx->end;
gf_filter_pid_set_info(ctx->opid, GF_PROP_PID_DOWN_BYTES, &PROP_LONGUINT( gf_ftell(ctx->src )) );
if (gf_filter_pid_would_block(ctx->opid))
return GF_OK;
}
if (ctx->end && !ctx->noflush) {
samp = gf_isom_new_text_sample();
txtin_process_send_text_sample(ctx, samp, (u64) (ts_scale*(s64)ctx->end), 0, GF_TRUE);
gf_isom_delete_text_sample(samp);
}
gf_filter_pid_set_info_str( ctx->opid, ""ttxt:last_dur"", &PROP_UINT(0) );
return GF_EOS;
}",[40],"The binary MP4Box in Gpac 1.0.1 has a double-free vulnerability in the gf_text_get_utf8_line function in load_text.c, which allows attackers to cause a denial of service, even code execution and escalation of privileges.",gpac,CVE-2021-40574,CWE-415
929,7469,"PackLinuxElf64::canPack()
{
union {
unsigned char buf[sizeof(Elf64_Ehdr) + 14*sizeof(Elf64_Phdr)];
} u;
COMPILE_TIME_ASSERT(sizeof(u) <= 1024)
fi->readx(u.buf, sizeof(u.buf));
fi->seek(0, SEEK_SET);
Elf64_Ehdr const *const ehdr = (Elf64_Ehdr *) u.buf;
if (checkEhdr(ehdr) != 0)
return false;
if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) {
throwCantPack(""invalid Ehdr e_ehsize; try '--force-execve'"");
return false;
}
if (e_phoff != sizeof(*ehdr)) {
throwCantPack(""non-contiguous Ehdr/Phdr; try '--force-execve'"");
return false;
}
Elf64_Phdr const *phdr = phdri;
for (unsigned j=0; j < e_phnum; ++phdr, ++j) {
if (j >= 14) {
throwCantPack(""too many ElfXX_Phdr; try '--force-execve'"");
return false;
}
unsigned const p_type = get_te32(&phdr->p_type);
if (1!=exetype && PT_LOAD64 == p_type) {
exetype = 1;
load_va = get_te64(&phdr->p_vaddr);
upx_uint64_t const p_offset = get_te64(&phdr->p_offset);
upx_uint64_t const off = ~page_mask & load_va;
if (off && off == p_offset) {
throwCantPack(""Go-language PT_LOAD: try hemfix.c, or try '--force-execve'"");
return false;
}
if (0 != p_offset) {
throwCantPack(""first PT_LOAD.p_offset != 0; try '--force-execve'"");
return false;
}
hatch_off = ~3ul & (3+ get_te64(&phdr->p_memsz));
break;
}
}
if (Elf64_Ehdr::ET_DYN==get_te16(&ehdr->e_type)) {
alloc_file_image(file_image, file_size);
fi->seek(0, SEEK_SET);
fi->readx(file_image, file_size);
memcpy(&ehdri, ehdr, sizeof(Elf64_Ehdr));
phdri= (Elf64_Phdr *)((size_t)e_phoff + file_image);
shdri= (Elf64_Shdr *)((size_t)e_shoff + file_image);
sec_strndx = NULL;
shstrtab = NULL;
if (e_shnum) {
unsigned const e_shstrndx = get_te16(&ehdr->e_shstrndx);
if (e_shstrndx) {
if (e_shnum <= e_shstrndx) {
char msg[40]; snprintf(msg, sizeof(msg),
""bad e_shstrndx %#x >= e_shnum %d"", e_shstrndx, e_shnum);
throwCantPack(msg);
}
sec_strndx = &shdri[e_shstrndx];
upx_uint64_t sh_offset = get_te64(&sec_strndx->sh_offset);
if ((u64_t)file_size <= sh_offset) {
char msg[50]; snprintf(msg, sizeof(msg),
""bad .e_shstrndx->sh_offset %#lx"", (long unsigned)sh_offset);
throwCantPack(msg);
}
shstrtab = (char const *)(sh_offset + file_image);
}
sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM);
if (sec_dynsym) {
upx_uint64_t const sh_link = get_te64(&sec_dynsym->sh_link);
if (e_shnum <= sh_link) {
char msg[50]; snprintf(msg, sizeof(msg),
""bad SHT_DYNSYM.sh_link %#lx"", (long unsigned)sh_link);
}
sec_dynstr = &shdri[sh_link];
}
if (sec_strndx) {
unsigned const sh_name = get_te32(&sec_strndx->sh_name);
if (Elf64_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type)
|| (u32_t)file_size <= sh_name
|| (sh_name
&& 0!=strcmp((char const *)"".shstrtab"", &shstrtab[sh_name]))
) {
throwCantPack(""bad e_shstrndx"");
}
}
}
Elf64_Phdr const *pload_x0(0);
phdr= phdri;
for (int j= e_phnum; --j>=0; ++phdr)
if (Elf64_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {
dynseg= (Elf64_Dyn const *)(check_pt_dynamic(phdr) + file_image);
invert_pt_dynamic(dynseg);
}
else if (PT_LOAD64==get_te32(&phdr->p_type)) {
if (!pload_x0
&&  Elf32_Phdr::PF_X & get_te32(&phdr->p_flags)
) {
pload_x0 = phdr;
}
check_pt_load(phdr);
}
dynstr=          (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);
dynsym=     (Elf64_Sym const *)elf_find_dynamic(Elf64_Dyn::DT_SYMTAB);
if (opt->o_unix.force_pie
||       Elf64_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf64_Dyn::DT_FLAGS_1)
||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_RELA),
(int)elf_unsigned_dynamic(Elf64_Dyn::DT_RELASZ))
||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_JMPREL),
(int)elf_unsigned_dynamic(Elf64_Dyn::DT_PLTRELSZ))) {
is_pie = true;
goto proceed;
}
if (elf_find_dynamic(upx_dt_init)) {
if (elf_has_dynamic(Elf64_Dyn::DT_TEXTREL)) {
throwCantPack(""DT_TEXTREL found; re-compile with -fPIC"");
goto abandon;
}
if (!(Elf64_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf64_Dyn::DT_FLAGS_1))) {
if (Elf64_Ehdr::EM_AARCH64 == e_machine
&&  !opt->o_unix.android_shlib
) {
opt->info_mode++;
info(""note: use --android-shlib if appropriate"");
opt->info_mode--;
}
}
Elf64_Shdr const *shdr = shdri;
xct_va = ~0ull;
if (e_shnum) {
for (int j= e_shnum; --j>=0; ++shdr) {
unsigned const sh_type = get_te32(&shdr->sh_type);
if (Elf64_Shdr::SHF_EXECINSTR & get_te64(&shdr->sh_flags)) {
xct_va = umin(xct_va, get_te64(&shdr->sh_addr));
}
if ((     Elf64_Dyn::DT_PREINIT_ARRAY==upx_dt_init
&&  Elf64_Shdr::SHT_PREINIT_ARRAY==sh_type)
||  (     Elf64_Dyn::DT_INIT_ARRAY   ==upx_dt_init
&&  Elf64_Shdr::SHT_INIT_ARRAY   ==sh_type) ) {
unsigned user_init_ava = get_te32(&shdr->sh_addr);
user_init_off = get_te64(&shdr->sh_offset);
if ((u64_t)file_size <= user_init_off) {
char msg[70]; snprintf(msg, sizeof(msg),
""bad Elf64_Shdr[%d].sh_offset %#x"",
-1+ e_shnum - j, user_init_off);
throwCantPack(msg);
}
int z_rel = dt_table[Elf64_Dyn::DT_RELA];
int z_rsz = dt_table[Elf64_Dyn::DT_RELASZ];
if (z_rel && z_rsz) {
unsigned rel_off = get_te64(&dynseg[-1+ z_rel].d_val);
Elf64_Rela *rp = (Elf64_Rela *)&file_image[rel_off];
unsigned relsz   = get_te64(&dynseg[-1+ z_rsz].d_val);
Elf64_Rela *last = (Elf64_Rela *)(relsz + (char *)rp);
for (; rp < last; ++rp) {
unsigned r_va = get_te64(&rp->r_offset);
if (r_va == user_init_ava) {
unsigned r_info = get_te64(&rp->r_info);
unsigned r_type = ELF64_R_TYPE(r_info);
if (Elf64_Ehdr::EM_AARCH64 == e_machine
&&  R_AARCH64_RELATIVE == r_type) {
user_init_va = get_te64(&rp->r_addend);
}
else if (Elf64_Ehdr::EM_AARCH64 == e_machine
&&  R_AARCH64_ABS64 == r_type) {
user_init_va = get_te64(&file_image[user_init_off]);
}
else {
char msg[50]; snprintf(msg, sizeof(msg),
""bad relocation %#x DT_INIT_ARRAY[0]"",
r_info);
throwCantPack(msg);
}
break;
}
}
}
unsigned const p_filesz = get_te64(&pload_x0->p_filesz);
if (!((user_init_va - xct_va) < p_filesz)) {
if (0==user_init_va && opt->o_unix.android_shlib) {
upx_dt_init = 0;
}
else {
char msg[70]; snprintf(msg, sizeof(msg),
""bad init address %#x in Elf64_Shdr[%d].%#x\n"",
(unsigned)user_init_va, -1+ e_shnum - j, user_init_off);
throwCantPack(msg);
}
}
}
if ((Elf64_Dyn::DT_INIT==upx_dt_init || !upx_dt_init)
&&  Elf64_Shdr::SHT_DYNAMIC == sh_type) {
unsigned const n = get_te64(&shdr->sh_size) / sizeof(Elf64_Dyn);
Elf64_Dyn *dynp = (Elf64_Dyn *)&file_image[get_te64(&shdr->sh_offset)];
for (; Elf64_Dyn::DT_NULL != dynp->d_tag; ++dynp) {
if (upx_dt_init == get_te64(&dynp->d_tag)) {
break;
}
}
if ((1+ dynp) < (n+ dynseg)) {
user_init_va = get_te64(&dynp->d_val);
set_te64(&dynp->d_tag, upx_dt_init = Elf64_Dyn::DT_INIT);
user_init_off = (char const *)&dynp->d_val - (char const *)&file_image[0];
}
}
}
}
else {
upx_uint64_t const strsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_STRSZ);
upx_uint64_t const strtab = elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB);
upx_uint64_t const relsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_RELSZ);
upx_uint64_t const rel    = elf_unsigned_dynamic(Elf64_Dyn::DT_REL);
upx_uint64_t const init   = elf_unsigned_dynamic(upx_dt_init);
if ((init == (relsz + rel   ) && rel    == (strsz + strtab))
||  (init == (strsz + strtab) && strtab == (relsz + rel   ))
) {
xct_va = init;
user_init_va = init;
user_init_off = elf_get_offset_from_address(init);
}
}
upx_uint64_t const va_gash = elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH);
upx_uint64_t const va_hash = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH);
unsigned y = 0;
if ((y=1, xct_va < va_gash)  ||  (y=2, (0==va_gash && xct_va < va_hash))
||  (y=3, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB))
||  (y=4, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_SYMTAB))
||  (y=5, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_REL))
||  (y=6, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_RELA))
||  (y=7, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_JMPREL))
||  (y=8, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERDEF))
||  (y=9, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERSYM))
||  (y=10, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERNEEDED)) ) {
static char const *which[] = {
""unknown"",
""DT_GNU_HASH"",
""DT_HASH"",
""DT_STRTAB"",
""DT_SYMTAB"",
""DT_REL"",
""DT_RELA"",
""DT_JMPREL"",
""DT_VERDEF"",
""DT_VERSYM"",
""DT_VERNEEDED"",
};
char buf[30]; snprintf(buf, sizeof(buf), ""%s above stub"", which[y]);
throwCantPack(buf);
goto abandon;
}
if (!opt->o_unix.android_shlib) {
phdr = phdri;
for (unsigned j= 0; j < e_phnum; ++phdr, ++j) {
upx_uint64_t const vaddr = get_te64(&phdr->p_vaddr);
if (PT_NOTE64 == get_te32(&phdr->p_type)
&& xct_va < vaddr) {
char buf[40]; snprintf(buf, sizeof(buf),
""PT_NOTE %#lx above stub"", (unsigned long)vaddr);
throwCantPack(buf);
goto abandon;
}
}
}
xct_off = elf_get_offset_from_address(xct_va);
if (opt->debug.debug_level) {
fprintf(stderr, ""shlib canPack: xct_va=%#lx  xct_off=%#lx\n"",
(long)xct_va, (long)xct_off);
}
goto proceed;
}
else
throwCantPack(""need DT_INIT; try \""void _init(void){}\"""");
abandon:
return false;
proceed: ;
}
if (!super::canPack())
return false;
assert(exetype == 1);
exetype = 0;
opt->o_unix.blocksize = blocksize = file_size;
return true;
}","[82, 86]",An out-of-bounds read access vulnerability was discovered in UPX in PackLinuxElf64::canPack() function of p_lx_elf.cpp file. An attacker with a crafted input file could trigger this issue that could cause a crash leading to a denial of service.,upx,CVE-2020-27788,CWE-125
947,5376,"int data_on_connection(int fd, callback_remove_handler remove)
{
int nread;
char *network_packet;
char network_line[8192];
char *p;
unsigned long id;
char string[1024];
unsigned long msg_id = UINT32_MAX;
enum network_protocol version = network_client_get_version(fd);
ioctl(fd, FIONREAD, &nread);
univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""new connection data = %d\n"",nread);
if(nread == 0)
{
univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_PROCESS, ""%d failed, got 0 close connection to listener "", fd);
close(fd);
FD_CLR(fd, &readfds);
remove(fd);
network_client_dump ();
return 0;
}
if ( nread >= 8192 ) {
univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ERROR, ""%d failed, more than 8192 close connection to listener "", fd);
close(fd);
FD_CLR(fd, &readfds);
remove(fd);
return 0;
}
network_packet=malloc((nread+1) * sizeof(char));
read(fd, network_packet, nread);
network_packet[nread]='\0';
memset(network_line, 0, 8192);
p=network_packet;
p_sem(sem_id);
while ( get_network_line(p, network_line) ) {
if ( strlen(network_line) > 0 ) {
univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""line = [%s]"",network_line);
}
if ( !strncmp(network_line, ""MSGID: "", strlen(""MSGID: "")) ) {
msg_id=strtoul(&(network_line[strlen(""MSGID: "")]), NULL, 10);
p+=strlen(network_line);
} else if ( !strncmp(network_line, ""Version: "", strlen(""Version: "")) ) {
char *head = network_line, *end;
univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""RECV: VERSION"");
version = strtoul(head + 9, &end, 10);
if (!head[9] || *end)
goto failed;
univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""VERSION=%d"", version);
if (version < network_procotol_version) {
univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_PROCESS, ""Forbidden VERSION=%d < %d, close connection to listener"", version, network_procotol_version);
goto close;
} else if (version >= PROTOCOL_LAST) {
univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_PROCESS, ""Future VERSION=%d"", version);
version = PROTOCOL_LAST - 1;
}
network_client_set_version(fd, version);
msg_id = UINT32_MAX;
p+=strlen(network_line);
} else if ( !strncmp(network_line, ""Capabilities: "", strlen(""Capabilities: "")) ) {
univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""RECV: Capabilities"");
if ( version > PROTOCOL_UNKNOWN ) {
memset(string, 0, sizeof(string));
snprintf(string, sizeof(string), ""Version: %d\nCapabilities: \n\n"", version);
univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""SEND: %s"", string);
write(fd, string, strlen(string));
} else {
univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""Capabilities recv, but no version line"");
}
p+=strlen(network_line);
} else if ( !strncmp(network_line, ""GET_DN "", strlen(""GET_DN "")) && msg_id != UINT32_MAX && network_client_get_version(fd) > 0) {
univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""RECV: GET_DN"");
id=strtoul(&(network_line[strlen(""GET_DN "")]), NULL, 10);
univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""id: %ld"",id);
if ( id <= notify_last_id.id) {
char *dn_string = NULL;
univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""try to read %ld from cache"", id);
if ( (dn_string = notifier_cache_get(id)) == NULL ) {
univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""%ld not found in cache"", id);
univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""%ld get one dn"", id);
if( (dn_string=notify_transcation_get_one_dn ( id )) == NULL ) {
univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""%ld failed "", id);
univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ERROR, ""%d failed, close connection to listener "", fd);
close(fd);
FD_CLR(fd, &readfds);
remove(fd);
return 0;
}
}
if ( dn_string != NULL ) {
snprintf(string, sizeof(string), ""MSGID: %ld\n%s\n\n"",msg_id,dn_string);
univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""--> %d: [%s]"",fd, string);
write(fd, string, strlen(string));
free(dn_string);
}
} else {
network_client_set_next_id(fd, id);
network_client_set_msg_id(fd, msg_id);
}
p+=strlen(network_line)+1;
msg_id = UINT32_MAX;
} else if (!strncmp(p, ""WAIT_ID "", 8) && msg_id != UINT32_MAX && version >= PROTOCOL_3) {
char *head = network_line, *end;
univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""RECV: WAIT_ID"");
id = strtoul(head + 8, &end, 10);
if (!head[8] || *end)
goto failed;
univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""id: %ld"", id);
if (id <= notify_last_id.id) {
snprintf(string, sizeof(string), ""MSGID: %ld\n%ld\n\n"", msg_id, notify_last_id.id);
write(fd, string, strlen(string));
} else {
network_client_set_next_id(fd, id);
network_client_set_msg_id(fd, msg_id);
}
p += strlen(network_line) + 1;
msg_id = UINT32_MAX;
} else if ( !strncmp(network_line, ""GET_ID"", strlen(""GET_ID"")) && msg_id != UINT32_MAX  && network_client_get_version(fd) > 0) {
univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""RECV: GET_ID"");
memset(string, 0, sizeof(string));
snprintf(string, sizeof(string), ""MSGID: %ld\n%ld\n\n"",msg_id,notify_last_id.id);
write(fd, string, strlen(string));
p+=strlen(network_line)+1;
msg_id = UINT32_MAX;
} else if ( !strncmp(network_line, ""GET_SCHEMA_ID"", strlen(""GET_SCHEMA_ID"")) && msg_id != UINT32_MAX  && network_client_get_version(fd) > 0) {
univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""RECV: GET_SCHEMA_ID"");
memset(string, 0, sizeof(string));
snprintf(string, sizeof(string), ""MSGID: %ld\n%ld\n\n"",msg_id,SCHEMA_ID);
univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""--> %d: [%s]"",fd, string);
write(fd, string, strlen(string));
p+=strlen(network_line)+1;
msg_id = UINT32_MAX;
} else if ( !strncmp(network_line, ""ALIVE"", strlen(""ALIVE"")) && msg_id != UINT32_MAX  && network_client_get_version(fd) > 0) {
univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""RECV: ALIVE"");
snprintf(string, sizeof(string), ""MSGID: %ld\nOKAY\n\n"",msg_id);
write(fd, string, strlen(string));
p+=strlen(network_line)+1;
msg_id = UINT32_MAX;
} else {
p+=strlen(network_line);
if (strlen(network_line) == 0 ) {
p+=1;
} else {
univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ERROR, ""Drop package [%s]"", network_line);
}
}
}
v_sem(sem_id);
univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""END Package"");
network_client_dump ();
return 0;
failed:
univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_PROCESS, ""Failed parsing [%s]"", p);
close:
close(fd);
FD_CLR(fd, &readfds);
remove(fd);
return 0;
}",[70],Univention Corporate Server univention-directory-notifier 12.0.1-3 and earlier is affected by: CWE-213: Intentional Information Exposure. The impact is: Loss of Confidentiality. The component is: function data_on_connection() in src/callback.c. The attack vector is: network connectivity. The fixed version is: 12.0.1-4 and later.,univention-corporate-server,CVE-2019-1010283,CWE-200
954,6069,"static int lookupName(
Parse *pParse,
const char *zDb,
const char *zTab,
const char *zCol,
NameContext *pNC,
Expr *pExpr
){
int i, j;
int cnt = 0;
int cntTab = 0;
int nSubquery = 0;
sqlite3 *db = pParse->db;
struct SrcList_item *pItem;
struct SrcList_item *pMatch = 0;
NameContext *pTopNC = pNC;
Schema *pSchema = 0;
int eNewExprOp = TK_COLUMN;
Table *pTab = 0;
Column *pCol;
assert( pNC );
assert( zCol );
assert( !ExprHasProperty(pExpr, EP_TokenOnly|EP_Reduced) );
pExpr->iTable = -1;
ExprSetVVAProperty(pExpr, EP_NoReduce);
if( zDb ){
testcase( pNC->ncFlags & NC_PartIdx );
testcase( pNC->ncFlags & NC_IsCheck );
if( (pNC->ncFlags & (NC_PartIdx|NC_IsCheck))!=0 ){
zDb = 0;
}else{
for(i=0; i<db->nDb; i++){
assert( db->aDb[i].zDbSName );
if( sqlite3StrICmp(db->aDb[i].zDbSName,zDb)==0 ){
pSchema = db->aDb[i].pSchema;
break;
}
}
}
}
assert( pNC && cnt==0 );
do{
ExprList *pEList;
SrcList *pSrcList = pNC->pSrcList;
if( pSrcList ){
for(i=0, pItem=pSrcList->a; i<pSrcList->nSrc; i++, pItem++){
pTab = pItem->pTab;
assert( pTab!=0 && pTab->zName!=0 );
assert( pTab->nCol>0 );
if( pItem->pSelect && (pItem->pSelect->selFlags & SF_NestedFrom)!=0 ){
int hit = 0;
pEList = pItem->pSelect->pEList;
for(j=0; j<pEList->nExpr; j++){
if( sqlite3MatchSpanName(pEList->a[j].zSpan, zCol, zTab, zDb) ){
cnt++;
cntTab = 2;
pMatch = pItem;
pExpr->iColumn = j;
hit = 1;
}
}
if( hit || zTab==0 ) continue;
}
if( zDb && pTab->pSchema!=pSchema ){
continue;
}
if( zTab ){
const char *zTabName = pItem->zAlias ? pItem->zAlias : pTab->zName;
assert( zTabName!=0 );
if( sqlite3StrICmp(zTabName, zTab)!=0 ){
continue;
}
if( IN_RENAME_OBJECT && pItem->zAlias ){
sqlite3RenameTokenRemap(pParse, 0, (void*)&pExpr->y.pTab);
}
}
if( 0==(cntTab++) ){
pMatch = pItem;
}
for(j=0, pCol=pTab->aCol; j<pTab->nCol; j++, pCol++){
if( sqlite3StrICmp(pCol->zName, zCol)==0 ){
if( cnt==1 ){
if( pItem->fg.jointype & JT_NATURAL ) continue;
if( nameInUsingClause(pItem->pUsing, zCol) ) continue;
}
cnt++;
pMatch = pItem;
pExpr->iColumn = j==pTab->iPKey ? -1 : (i16)j;
break;
}
}
}
if( pMatch ){
pExpr->iTable = pMatch->iCursor;
pExpr->y.pTab = pMatch->pTab;
assert( (pMatch->fg.jointype & JT_RIGHT)==0 );
if( (pMatch->fg.jointype & JT_LEFT)!=0 ){
ExprSetProperty(pExpr, EP_CanBeNull);
}
pSchema = pExpr->y.pTab->pSchema;
}
}
#if !defined(SQLITE_OMIT_TRIGGER) || !defined(SQLITE_OMIT_UPSERT)
if( zDb==0 && zTab!=0 && cntTab==0 ){
pTab = 0;
#ifndef SQLITE_OMIT_TRIGGER
if( pParse->pTriggerTab!=0 ){
int op = pParse->eTriggerOp;
assert( op==TK_DELETE || op==TK_UPDATE || op==TK_INSERT );
if( op!=TK_DELETE && sqlite3StrICmp(""new"",zTab) == 0 ){
pExpr->iTable = 1;
pTab = pParse->pTriggerTab;
}else if( op!=TK_INSERT && sqlite3StrICmp(""old"",zTab)==0 ){
pExpr->iTable = 0;
pTab = pParse->pTriggerTab;
}
}
#endif /* SQLITE_OMIT_TRIGGER */
#ifndef SQLITE_OMIT_UPSERT
if( (pNC->ncFlags & NC_UUpsert)!=0 ){
Upsert *pUpsert = pNC->uNC.pUpsert;
if( pUpsert && sqlite3StrICmp(""excluded"",zTab)==0 ){
pTab = pUpsert->pUpsertSrc->a[0].pTab;
pExpr->iTable = 2;
}
}
#endif /* SQLITE_OMIT_UPSERT */
if( pTab ){
int iCol;
pSchema = pTab->pSchema;
cntTab++;
for(iCol=0, pCol=pTab->aCol; iCol<pTab->nCol; iCol++, pCol++){
if( sqlite3StrICmp(pCol->zName, zCol)==0 ){
if( iCol==pTab->iPKey ){
iCol = -1;
}
break;
}
}
if( iCol>=pTab->nCol && sqlite3IsRowid(zCol) && VisibleRowid(pTab) ){
iCol = -1;
}
if( iCol<pTab->nCol ){
cnt++;
#ifndef SQLITE_OMIT_UPSERT
if( pExpr->iTable==2 ){
testcase( iCol==(-1) );
if( IN_RENAME_OBJECT ){
pExpr->iColumn = iCol;
pExpr->y.pTab = pTab;
eNewExprOp = TK_COLUMN;
}else{
pExpr->iTable = pNC->uNC.pUpsert->regData + iCol;
eNewExprOp = TK_REGISTER;
ExprSetProperty(pExpr, EP_Alias);
}
}else
#endif /* SQLITE_OMIT_UPSERT */
{
#ifndef SQLITE_OMIT_TRIGGER
if( iCol<0 ){
pExpr->affExpr = SQLITE_AFF_INTEGER;
}else if( pExpr->iTable==0 ){
testcase( iCol==31 );
testcase( iCol==32 );
pParse->oldmask |= (iCol>=32 ? 0xffffffff : (((u32)1)<<iCol));
}else{
testcase( iCol==31 );
testcase( iCol==32 );
pParse->newmask |= (iCol>=32 ? 0xffffffff : (((u32)1)<<iCol));
}
pExpr->y.pTab = pTab;
pExpr->iColumn = (i16)iCol;
eNewExprOp = TK_TRIGGER;
#endif /* SQLITE_OMIT_TRIGGER */
}
}
}
}
#endif /* !defined(SQLITE_OMIT_TRIGGER) || !defined(SQLITE_OMIT_UPSERT) */
if( cnt==0
&& cntTab==1
&& pMatch
&& (pNC->ncFlags & (NC_IdxExpr|NC_GenCol))==0
&& sqlite3IsRowid(zCol)
&& VisibleRowid(pMatch->pTab)
){
cnt = 1;
pExpr->iColumn = -1;
pExpr->affExpr = SQLITE_AFF_INTEGER;
}
if( (pNC->ncFlags & NC_UEList)!=0
&& cnt==0
&& zTab==0
){
pEList = pNC->uNC.pEList;
assert( pEList!=0 );
for(j=0; j<pEList->nExpr; j++){
char *zAs = pEList->a[j].zName;
if( zAs!=0 && sqlite3StrICmp(zAs, zCol)==0 ){
Expr *pOrig;
assert( pExpr->pLeft==0 && pExpr->pRight==0 );
assert( pExpr->x.pList==0 );
assert( pExpr->x.pSelect==0 );
pOrig = pEList->a[j].pExpr;
if( (pNC->ncFlags&NC_AllowAgg)==0 && ExprHasProperty(pOrig, EP_Agg) ){
sqlite3ErrorMsg(pParse, ""misuse of aliased aggregate %s"", zAs);
return WRC_Abort;
}
if( (pNC->ncFlags&NC_AllowWin)==0 && ExprHasProperty(pOrig, EP_Win) ){
sqlite3ErrorMsg(pParse, ""misuse of aliased window function %s"",zAs);
return WRC_Abort;
}
if( sqlite3ExprVectorSize(pOrig)!=1 ){
sqlite3ErrorMsg(pParse, ""row value misused"");
return WRC_Abort;
}
resolveAlias(pParse, pEList, j, pExpr, """", nSubquery);
cnt = 1;
pMatch = 0;
assert( zTab==0 && zDb==0 );
if( IN_RENAME_OBJECT ){
sqlite3RenameTokenRemap(pParse, 0, (void*)pExpr);
}
goto lookupname_end;
}
}
}
if( cnt ) break;
pNC = pNC->pNext;
nSubquery++;
}while( pNC );
if( cnt==0 && zTab==0 ){
assert( pExpr->op==TK_ID );
if( ExprHasProperty(pExpr,EP_DblQuoted)
&& areDoubleQuotedStringsEnabled(db, pTopNC)
){
sqlite3_log(SQLITE_WARNING,
""double-quoted string literal: \""%w\"""", zCol);
#ifdef SQLITE_ENABLE_NORMALIZE
sqlite3VdbeAddDblquoteStr(db, pParse->pVdbe, zCol);
#endif
pExpr->op = TK_STRING;
pExpr->y.pTab = 0;
return WRC_Prune;
}
if( sqlite3ExprIdToTrueFalse(pExpr) ){
return WRC_Prune;
}
}
if( cnt!=1 ){
const char *zErr;
zErr = cnt==0 ? ""no such column"" : ""ambiguous column name"";
if( zDb ){
sqlite3ErrorMsg(pParse, ""%s: %s.%s.%s"", zErr, zDb, zTab, zCol);
}else if( zTab ){
sqlite3ErrorMsg(pParse, ""%s: %s.%s"", zErr, zTab, zCol);
}else{
sqlite3ErrorMsg(pParse, ""%s: %s"", zErr, zCol);
}
pParse->checkSchema = 1;
pTopNC->nErr++;
}
if( pExpr->iColumn>=0 && pMatch!=0 ){
int n = pExpr->iColumn;
testcase( n==BMS-1 );
if( n>=BMS ){
n = BMS-1;
}
assert( pMatch->iCursor==pExpr->iTable );
pMatch->colUsed |= ((Bitmask)1)<<n;
}
sqlite3ExprDelete(db, pExpr->pLeft);
pExpr->pLeft = 0;
sqlite3ExprDelete(db, pExpr->pRight);
pExpr->pRight = 0;
pExpr->op = eNewExprOp;
ExprSetProperty(pExpr, EP_Leaf);
lookupname_end:
if( cnt==1 ){
assert( pNC!=0 );
if( !ExprHasProperty(pExpr, EP_Alias) ){
sqlite3AuthRead(pParse, pExpr, pSchema, pNC->pSrcList);
}
for(;;){
assert( pTopNC!=0 );
pTopNC->nRef++;
if( pTopNC==pNC ) break;
pTopNC = pTopNC->pNext;
}
return WRC_Prune;
} else {
return WRC_Abort;
}
}","[270, 271]","lookupName in resolve.c in SQLite 3.30.1 omits bits from the colUsed bitmask in the case of a generated column, which allows attackers to cause a denial of service or possibly have unspecified other impact.",sqlite,CVE-2019-19317,CWE-681
955,8245,"void APar_ExtractDetails(FILE *isofile, uint8_t optional_output) {
char uint32_buffer[5];
Trackage track = {0};
AtomicInfo *mvhdAtom = APar_FindAtom(""moov.mvhd"", false, VERSIONED_ATOM, 0);
if (mvhdAtom != NULL) {
APar_ExtractMovieDetails(uint32_buffer, isofile, mvhdAtom);
fprintf(stdout,
""Movie duration: %.3lf seconds (%s) - %.2lf* kbp/sec bitrate ""
""(*=approximate)\n"",
movie_info.seconds,
secsTOtime(movie_info.seconds),
movie_info.simple_bitrate_calc);
if (optional_output & SHOW_DATE_INFO) {
fprintf(stdout,
""  Presentation Creation Date (UTC):     %s\n"",
APar_extract_UTC(movie_info.creation_time));
fprintf(stdout,
""  Presentation Modification Date (UTC): %s\n"",
APar_extract_UTC(movie_info.modified_time));
}
}
AtomicInfo *iodsAtom = APar_FindAtom(""moov.iods"", false, VERSIONED_ATOM, 0);
if (iodsAtom != NULL) {
movie_info.contains_iods = true;
APar_Extract_iods_Info(isofile, iodsAtom);
}
if (optional_output & SHOW_TRACK_INFO) {
APar_TrackLevelInfo(&track,
NULL);
fprintf(
stdout, ""Low-level details. Total tracks: %u\n"", track.total_tracks);
fprintf(stdout,
""Trk  Type  Handler                    Kind  Lang  Bytes\n"");
if (track.total_tracks > 0) {
while (track.total_tracks > track.track_num) {
track.track_num += 1;
TrackInfo track_info = {0};
APar_ExtractTrackDetails(uint32_buffer, isofile, &track, &track_info);
uint16_t more_whitespace =
purge_extraneous_characters(track_info.track_hdlr_name);
if (strlen(track_info.track_hdlr_name) == 0) {
memcpy(track_info.track_hdlr_name, ""[none listed]"", 13);
}
fprintf(stdout,
""%u    %s  %s"",
track.track_num,
uint32tochar4(track_info.track_type, uint32_buffer),
track_info.track_hdlr_name);
uint16_t handler_len = strlen(track_info.track_hdlr_name);
if (handler_len < 25 + more_whitespace) {
for (uint16_t i = handler_len; i < 25 + more_whitespace; i++) {
fprintf(stdout, "" "");
}
}
fprintf(stdout,
""  %s  %s   %"" PRIu64,
uint32tochar4(track_info.track_codec, uint32_buffer),
track_info.unpacked_lang,
track_info.sample_aggregate);
if (track_info.encoder_name[0] != 0 && track_info.contains_esds) {
purge_extraneous_characters(track_info.encoder_name);
fprintf(stdout, ""   Encoder: %s"", track_info.encoder_name);
}
if (track_info.type_of_track & DRM_PROTECTED_TRACK) {
fprintf(stdout,
"" (protected %s)"",
uint32tochar4(track_info.protected_codec, uint32_buffer));
}
fprintf(stdout, ""\n"");
if (track_info.type_of_track & VIDEO_TRACK ||
track_info.type_of_track & AUDIO_TRACK) {
APar_Print_TrackDetails(&track_info);
}
if (optional_output & SHOW_DATE_INFO) {
fprintf(stdout,
""       Creation Date (UTC):     %s\n"",
APar_extract_UTC(track_info.creation_time));
fprintf(stdout,
""       Modification Date (UTC): %s\n"",
APar_extract_UTC(track_info.modified_time));
}
}
}
}
}",[2],A stack overflow vulnerability occurs in Atomicparsley 20210124.204813.840499f through APar_read64() in src/util.cpp due to the lack of buffer size of uint32_buffer while reading more bytes in APar_read64.,atomicparsley,CVE-2021-37232,CWE-787
969,6288,"GF_Err audio_sample_entry_Read(GF_Box *s, GF_BitStream *bs)
{
GF_MPEGAudioSampleEntryBox *ptr;
char *data;
u8 a, b, c, d;
u32 i, size, v, nb_alnum;
GF_Err e;
u64 pos, start;
ptr = (GF_MPEGAudioSampleEntryBox *)s;
start = gf_bs_get_position(bs);
gf_bs_seek(bs, start + 8);
v = gf_bs_read_u16(bs);
if (v)
ptr->is_qtff = 1;
if (v==1) {
gf_bs_seek(bs, start + 8 + 20  + 4);
a = gf_bs_read_u8(bs);
b = gf_bs_read_u8(bs);
c = gf_bs_read_u8(bs);
d = gf_bs_read_u8(bs);
nb_alnum = 0;
if (isalnum(a)) nb_alnum++;
if (isalnum(b)) nb_alnum++;
if (isalnum(c)) nb_alnum++;
if (isalnum(d)) nb_alnum++;
if (nb_alnum>2) ptr->is_qtff = 0;
}
gf_bs_seek(bs, start);
e = gf_isom_audio_sample_entry_read((GF_AudioSampleEntryBox*)s, bs);
if (e) return e;
pos = gf_bs_get_position(bs);
size = (u32) s->size;
if (gf_bs_get_cookie(bs)) {
ptr->is_qtff |= 1<<16;
}
e = gf_isom_box_array_read(s, bs, audio_sample_entry_AddBox);
if (!e) return GF_OK;
if (size<8) return GF_ISOM_INVALID_FILE;
gf_bs_seek(bs, pos);
data = (char*)gf_malloc(sizeof(char) * size);
gf_bs_read_data(bs, data, size);
for (i=0; i<size-8; i++) {
if (GF_4CC((u32)data[i+4], (u8)data[i+5], (u8)data[i+6], (u8)data[i+7]) == GF_ISOM_BOX_TYPE_ESDS) {
GF_BitStream *mybs = gf_bs_new(data + i, size - i, GF_BITSTREAM_READ);
if (ptr->esd) {
gf_isom_box_del((GF_Box *)ptr->esd);
ptr->esd=NULL;
}
e = gf_isom_box_parse((GF_Box **)&ptr->esd, mybs);
if (e==GF_OK) {
gf_isom_box_add_for_dump_mode((GF_Box*)ptr, (GF_Box*)ptr->esd);
} else if (ptr->esd) {
gf_isom_box_del((GF_Box *)ptr->esd);
ptr->esd=NULL;
}
gf_bs_del(mybs);
break;
}
}
gf_free(data);
return e;
}","[44, 46]","An issue was discovered in libgpac.a in GPAC 0.8.0, as demonstrated by MP4Box. audio_sample_entry_Read in isomedia/box_code_base.c does not properly decide when to make gf_isom_box_del calls. This leads to various use-after-free outcomes involving mdia_Read, gf_isom_delete_movie, and gf_isom_parse_movie_boxes.",gpac,CVE-2020-11558,CWE-416
972,6298,"static inline void init_keys(at91_aes_key_size_t *key_size,
unsigned int *cipher_key,
unsigned int *cmac_key,
unsigned int *iv)
{
#if defined(CONFIG_AES_KEY_SIZE_128)
*key_size = AT91_AES_KEY_SIZE_128;
#elif defined(CONFIG_AES_KEY_SIZE_192)
*key_size = AT91_AES_KEY_SIZE_192;
#elif defined(CONFIG_AES_KEY_SIZE_256)
*key_size = AT91_AES_KEY_SIZE_256;
#else
#error ""bad AES key size""
#endif
iv[0]  = CONFIG_AES_IV_WORD0;
iv[1]  = CONFIG_AES_IV_WORD1;
iv[2]  = CONFIG_AES_IV_WORD2;
iv[3]  = CONFIG_AES_IV_WORD3;
cipher_key[0] = CONFIG_AES_CIPHER_KEY_WORD0;
cmac_key[0] = CONFIG_AES_CMAC_KEY_WORD0;
cipher_key[1] = CONFIG_AES_CIPHER_KEY_WORD1;
cmac_key[1] = CONFIG_AES_CMAC_KEY_WORD1;
cipher_key[2] = CONFIG_AES_CIPHER_KEY_WORD2;
cmac_key[2] = CONFIG_AES_CMAC_KEY_WORD2;
cipher_key[3] = CONFIG_AES_CIPHER_KEY_WORD3;
cmac_key[3] = CONFIG_AES_CMAC_KEY_WORD3;
#if defined(CONFIG_AES_KEY_SIZE_192) || defined(CONFIG_AES_KEY_SIZE_256)
cipher_key[4] = CONFIG_AES_CIPHER_KEY_WORD4;
cmac_key[4] = CONFIG_AES_CMAC_KEY_WORD4;
cipher_key[5] = CONFIG_AES_CIPHER_KEY_WORD5;
cmac_key[5] = CONFIG_AES_CMAC_KEY_WORD5;
#endif
#if defined(CONFIG_AES_KEY_SIZE_256)
cipher_key[6] = CONFIG_AES_CIPHER_KEY_WORD6;
cmac_key[6] = CONFIG_AES_CMAC_KEY_WORD6;
cipher_key[7] = CONFIG_AES_CIPHER_KEY_WORD7;
cmac_key[7] = CONFIG_AES_CMAC_KEY_WORD7;
#endif
}","[15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 28, 29, 30, 31, 34, 35, 36, 37]",AT91bootstrap before 3.9.2 does not properly wipe encryption and authentication keys from memory before passing control to a less privileged software component. This can be exploited to disclose these keys and subsequently encrypt and sign the next boot stage (such as the bootloader).,at91bootstrap,CVE-2020-11684,CWE-326
988,6076,"static int cac_read_binary(sc_card_t *card, unsigned int idx,
unsigned char *buf, size_t count, unsigned long flags)
{
cac_private_data_t * priv = CAC_DATA(card);
int r = 0;
u8 *val = NULL;
u8 *cert_ptr;
size_t val_len;
size_t len, cert_len;
u8 cert_type;
SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
if (priv->cached) {
sc_log(card->ctx,
""returning cached value idx=%d count=%""SC_FORMAT_LEN_SIZE_T""u"",
idx, count);
if (idx > priv->cache_buf_len) {
LOG_FUNC_RETURN(card->ctx, SC_ERROR_FILE_END_REACHED);
}
len = MIN(count, priv->cache_buf_len-idx);
memcpy(buf, &priv->cache_buf[idx], len);
LOG_FUNC_RETURN(card->ctx, len);
}
sc_log(card->ctx,
""clearing cache idx=%d count=%""SC_FORMAT_LEN_SIZE_T""u"",
idx, count);
free(priv->cache_buf);
priv->cache_buf = NULL;
priv->cache_buf_len = 0;
r = cac_cac1_get_certificate(card, &val, &val_len);
if (r < 0)
goto done;
if (val_len < 1) {
r = SC_ERROR_INVALID_DATA;
goto done;
}
cert_type = val[0];
cert_ptr = val + 1;
cert_len = val_len - 1;
if ((cert_type & 0x3) == 1) {
#ifdef ENABLE_ZLIB
r = sc_decompress_alloc(&priv->cache_buf, &priv->cache_buf_len,
cert_ptr, cert_len, COMPRESSION_AUTO);
#else
sc_log(card->ctx, ""CAC compression not supported, no zlib"");
r = SC_ERROR_NOT_SUPPORTED;
#endif
if (r)
goto done;
} else if (cert_len > 0) {
priv->cache_buf = malloc(cert_len);
if (priv->cache_buf == NULL) {
r = SC_ERROR_OUT_OF_MEMORY;
goto done;
}
priv->cache_buf_len = cert_len;
memcpy(priv->cache_buf, cert_ptr, cert_len);
}
priv->cached = 1;
len = MIN(count, priv->cache_buf_len-idx);
if (len && priv->cache_buf)
memcpy(buf, &priv->cache_buf[idx], len);
r = len;
done:
if (val)
free(val);
LOG_FUNC_RETURN(card->ctx, r);
}",[8],An issue was discovered in OpenSC through 0.19.0 and 0.20.x through 0.20.0-rc3. libopensc/card-cac1.c mishandles buffer limits for CAC certificates.,OpenSC,CVE-2019-19481,CWE-119
1002,7512,"send_ldap_result_ext(
Slapi_PBlock *pb,
int err,
char *matched,
char *text,
int nentries,
struct berval **urls,
BerElement *ber)
{
Slapi_Operation *operation;
passwdPolicy *pwpolicy = NULL;
Connection *conn = NULL;
Slapi_DN *sdn = NULL;
const char *dn = NULL;
ber_tag_t tag;
int flush_ber_element = 1;
ber_tag_t bind_method = 0;
int internal_op;
int i, rc, logit = 0;
char *pbtext;
slapi_pblock_get(pb, SLAPI_BIND_METHOD, &bind_method);
slapi_pblock_get(pb, SLAPI_OPERATION, &operation);
slapi_pblock_get(pb, SLAPI_CONNECTION, &conn);
if (text) {
pbtext = text;
} else {
slapi_pblock_get(pb, SLAPI_PB_RESULT_TEXT, &pbtext);
}
if (operation == NULL) {
slapi_log_err(SLAPI_LOG_ERR, ""send_ldap_result_ext"", ""No operation found: slapi_search_internal_set_pb was incomplete (invalid 'base' ?)\n"");
return;
}
if (operation->o_status == SLAPI_OP_STATUS_RESULT_SENT) {
return;
}
if (ber != NULL) {
flush_ber_element = 0;
}
if (err != LDAP_SUCCESS) {
if (err == LDAP_INVALID_CREDENTIALS || err == LDAP_INAPPROPRIATE_AUTH || err == LDAP_AUTH_METHOD_NOT_SUPPORTED || err == LDAP_STRONG_AUTH_NOT_SUPPORTED || err == LDAP_STRONG_AUTH_REQUIRED || err == LDAP_CONFIDENTIALITY_REQUIRED || err == LDAP_INSUFFICIENT_ACCESS || err == LDAP_AUTH_UNKNOWN) {
slapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsSecurityErrors);
} else if (err != LDAP_REFERRAL && err != LDAP_OPT_REFERRALS && err != LDAP_PARTIAL_RESULTS) {
slapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsErrors);
}
}
slapi_log_err(SLAPI_LOG_TRACE, ""send_ldap_result_ext"", ""=> %d:%s:%s\n"", err,
matched ? matched : """", text ? text : """");
switch (operation->o_tag) {
case LBER_DEFAULT:
tag = LBER_SEQUENCE;
break;
case LDAP_REQ_SEARCH:
tag = LDAP_RES_SEARCH_RESULT;
break;
case LDAP_REQ_DELETE:
tag = LDAP_RES_DELETE;
break;
case LDAP_REFERRAL:
if (conn && conn->c_ldapversion > LDAP_VERSION2) {
tag = LDAP_TAG_REFERRAL;
break;
}
default:
tag = operation->o_tag + 1;
break;
}
internal_op = operation_is_flag_set(operation, OP_FLAG_INTERNAL);
if ((conn == NULL) || (internal_op)) {
if (operation->o_result_handler != NULL) {
operation->o_result_handler(conn, operation, err,
matched, text, nentries, urls);
logit = 1;
}
goto log_and_return;
}
if ((err == LDAP_INVALID_CREDENTIALS) && (bind_method != LDAP_AUTH_SASL)) {
slapi_pblock_get(pb, SLAPI_TARGET_SDN, &sdn);
dn = slapi_sdn_get_dn(sdn);
pwpolicy = new_passwdPolicy(pb, dn);
if (pwpolicy && (pwpolicy->pw_lockout == 1)) {
if (update_pw_retry(pb) == LDAP_CONSTRAINT_VIOLATION && !pwpolicy->pw_is_legacy) {
err = LDAP_CONSTRAINT_VIOLATION;
text = ""Invalid credentials, you now have exceeded the password retry limit."";
}
}
}
if (ber == NULL) {
if ((ber = der_alloc()) == NULL) {
slapi_log_err(SLAPI_LOG_ERR, ""send_ldap_result_ext"", ""ber_alloc failed\n"");
goto log_and_return;
}
}
if (err == LDAP_ADMINLIMIT_EXCEEDED &&
conn->c_ldapversion < LDAP_VERSION3) {
err = LDAP_SIZELIMIT_EXCEEDED;
}
if (conn->c_ldapversion < LDAP_VERSION3 || urls == NULL) {
char *save, *buf = NULL;
if (urls != NULL) {
int len;
slapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsReferrals);
len = 10;
for (i = 0; urls[i] != NULL; i++) {
len += urls[i]->bv_len + 1;
}
if (text != NULL) {
len += strlen(text) + 1;
}
buf = slapi_ch_malloc(len);
*buf = '\0';
if (text != NULL) {
strcpy(buf, text);
strcat(buf, ""\n"");
}
strcat(buf, ""Referral:"");
for (i = 0; urls[i] != NULL; i++) {
strcat(buf, ""\n"");
strcat(buf, urls[i]->bv_val);
}
save = text;
text = buf;
}
if ((conn->c_ldapversion < LDAP_VERSION3 &&
err == LDAP_REFERRAL) ||
urls != NULL) {
err = LDAP_PARTIAL_RESULTS;
}
rc = ber_printf(ber, ""{it{ess"", operation->o_msgid, tag, err,
matched ? matched : """", pbtext ? pbtext : """");
if (rc != LBER_ERROR) {
rc = check_and_send_extended_result(pb, tag, ber);
}
if (rc != LBER_ERROR) {
rc = check_and_send_SASL_response(pb, tag, ber, conn);
}
if (rc != LBER_ERROR) {
rc = ber_printf(ber, ""}"");
}
if (buf != NULL) {
text = save;
slapi_ch_free((void **)&buf);
}
} else {
if (!config_check_referral_mode())
slapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsReferrals);
rc = ber_printf(ber, ""{it{esst{s"", operation->o_msgid, tag, err,
matched ? matched : """", text ? text : """", LDAP_TAG_REFERRAL,
urls[0]->bv_val);
for (i = 1; urls[i] != NULL && rc != LBER_ERROR; i++) {
rc = ber_printf(ber, ""s"", urls[i]->bv_val);
}
if (rc != LBER_ERROR) {
rc = ber_printf(ber, ""}"");
}
if (rc != LBER_ERROR) {
rc = check_and_send_extended_result(pb, tag, ber);
}
if (rc != LBER_ERROR) {
rc = check_and_send_SASL_response(pb, tag, ber, conn);
}
if (rc != LBER_ERROR) {
rc = ber_printf(ber, ""}"");
}
}
if (err == LDAP_SUCCESS) {
if (process_read_entry_controls(pb, LDAP_CONTROL_PRE_READ_ENTRY)) {
err = LDAP_UNAVAILABLE_CRITICAL_EXTENSION;
goto log_and_return;
}
if (process_read_entry_controls(pb, LDAP_CONTROL_POST_READ_ENTRY)) {
err = LDAP_UNAVAILABLE_CRITICAL_EXTENSION;
goto log_and_return;
}
}
if (operation->o_results.result_controls != NULL && conn->c_ldapversion >= LDAP_VERSION3 && write_controls(ber, operation->o_results.result_controls) != 0) {
rc = (int)LBER_ERROR;
}
if (rc != LBER_ERROR) {
rc = ber_put_seq(ber);
}
if (rc == LBER_ERROR) {
slapi_log_err(SLAPI_LOG_ERR, ""send_ldap_result_ext"", ""ber_printf failed 1\n"");
if (flush_ber_element == 1) {
ber_free(ber, 1              );
}
goto log_and_return;
}
if (flush_ber_element) {
if (flush_ber(pb, conn, operation, ber, _LDAP_SEND_RESULT) == 0) {
logit = 1;
}
}
log_and_return:
operation->o_status = SLAPI_OP_STATUS_RESULT_SENT;
if (logit && (operation_is_flag_set(operation, OP_FLAG_ACTION_LOG_ACCESS) ||
(internal_op && config_get_plugin_logging()))) {
log_result(pb, operation, err, tag, nentries);
}
slapi_log_err(SLAPI_LOG_TRACE, ""send_ldap_result_ext"", ""<= %d\n"", err);
}",[27],"When binding against a DN during authentication, the reply from 389-ds-base will be different whether the DN exists or not. This can be used by an unauthenticated attacker to check the existence of an entry in the LDAP database.",389-ds-base,CVE-2020-35518,CWE-203
1003,31,"void gtkui_icmp_redir(void)
{
GtkWidget *dialog, *table, *hbox, *image, *label, *entry1, *entry2, *frame;
gint response = 0;
DEBUG_MSG(""gtk_icmp_redir"");
dialog = gtk_dialog_new_with_buttons(""MITM Attack: ICMP Redirect"", GTK_WINDOW (window),
GTK_DIALOG_MODAL, GTK_STOCK_OK, GTK_RESPONSE_OK,
GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL, NULL);
gtk_container_set_border_width(GTK_CONTAINER (dialog), 5);
gtk_dialog_set_has_separator(GTK_DIALOG (dialog), FALSE);
hbox = gtk_hbox_new (FALSE, 5);
gtk_box_pack_start (GTK_BOX (GTK_DIALOG (dialog)->vbox), hbox, FALSE, FALSE, 0);
gtk_widget_show(hbox);
image = gtk_image_new_from_stock (GTK_STOCK_DIALOG_QUESTION, GTK_ICON_SIZE_DIALOG);
gtk_misc_set_alignment (GTK_MISC (image), 0.5, 0.1);
gtk_box_pack_start (GTK_BOX (hbox), image, FALSE, FALSE, 5);
gtk_widget_show(image);
frame = gtk_frame_new(""Gateway Information"");
gtk_container_set_border_width(GTK_CONTAINER (frame), 5);
gtk_box_pack_start (GTK_BOX (hbox), frame, TRUE, TRUE, 0);
gtk_widget_show(frame);
table = gtk_table_new(2, 2, FALSE);
gtk_table_set_row_spacings(GTK_TABLE (table), 5);
gtk_table_set_col_spacings(GTK_TABLE (table), 5);
gtk_container_set_border_width(GTK_CONTAINER (table), 8);
gtk_container_add(GTK_CONTAINER (frame), table);
gtk_widget_show(table);
label = gtk_label_new(""MAC Address"");
gtk_misc_set_alignment(GTK_MISC (label), 0, 0.5);
gtk_table_attach(GTK_TABLE (table), label, 0, 1, 0, 1, GTK_FILL, GTK_FILL, 0, 0);
gtk_widget_show(label);
entry1 = gtk_entry_new();
gtk_entry_set_max_length(GTK_ENTRY (entry1), ETH_ASCII_ADDR_LEN);
gtk_table_attach_defaults(GTK_TABLE (table), entry1, 1, 2, 0, 1);
gtk_widget_show(entry1);
label = gtk_label_new(""IP Address"");
gtk_misc_set_alignment(GTK_MISC (label), 0, 0.5);
gtk_table_attach(GTK_TABLE (table), label, 0, 1, 1, 2, GTK_FILL, GTK_FILL, 0, 0);
gtk_widget_show(label);
entry2 = gtk_entry_new();
gtk_entry_set_max_length(GTK_ENTRY (entry2), IP6_ASCII_ADDR_LEN);
gtk_table_attach_defaults(GTK_TABLE (table), entry2, 1, 2, 1, 2);
gtk_widget_show(entry2);
response = gtk_dialog_run(GTK_DIALOG(dialog));
if(response == GTK_RESPONSE_OK) {
gtk_widget_hide(dialog);
snprintf(params, 6, ""icmp:"");
strncat(params, gtk_entry_get_text(GTK_ENTRY(entry1)), PARAMS_LEN);
strncat(params, ""/"", PARAMS_LEN);
strncat(params, gtk_entry_get_text(GTK_ENTRY(entry2)), PARAMS_LEN);
gtkui_start_mitm();
}
gtk_widget_destroy(dialog);
}","[48, 49, 50]",An unchecked sscanf() call in ettercap before 0.7.5 allows an insecure temporary settings file to overflow a static-sized buffer on the stack.,ettercap,CVE-2010-3844,CWE-120
1007,7468,"bool PackLinuxElf32::canPack()
{
union {
unsigned char buf[sizeof(Elf32_Ehdr) + 14*sizeof(Elf32_Phdr)];
} u;
COMPILE_TIME_ASSERT(sizeof(u.buf) <= 512)
fi->seek(0, SEEK_SET);
fi->readx(u.buf, sizeof(u.buf));
fi->seek(0, SEEK_SET);
Elf32_Ehdr const *const ehdr = (Elf32_Ehdr *) u.buf;
if (checkEhdr(ehdr) != 0)
return false;
if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) {
throwCantPack(""invalid Ehdr e_ehsize; try '--force-execve'"");
return false;
}
if (e_phoff != sizeof(*ehdr)) {
throwCantPack(""non-contiguous Ehdr/Phdr; try '--force-execve'"");
return false;
}
unsigned char osabi0 = u.buf[Elf32_Ehdr::EI_OSABI];
Elf32_Phdr const *phdr = phdri;
note_size = 0;
for (unsigned j=0; j < e_phnum; ++phdr, ++j) {
if (j >= 14) {
throwCantPack(""too many ElfXX_Phdr; try '--force-execve'"");
return false;
}
unsigned const p_type = get_te32(&phdr->p_type);
unsigned const p_offset = get_te32(&phdr->p_offset);
if (1!=exetype && PT_LOAD32 == p_type) {
exetype = 1;
load_va = get_te32(&phdr->p_vaddr);
unsigned const off = ~page_mask & (unsigned)load_va;
if (off && off == p_offset) {
throwCantPack(""Go-language PT_LOAD: try hemfix.c, or try '--force-execve'"");
return false;
}
if (0 != p_offset) {
throwCantPack(""first PT_LOAD.p_offset != 0; try '--force-execve'"");
return false;
}
hatch_off = ~3u & (3+ get_te32(&phdr->p_memsz));
}
if (PT_NOTE32 == p_type) {
unsigned const x = get_te32(&phdr->p_memsz);
if ( sizeof(elfout.notes) < x
||  (sizeof(elfout.notes) < (note_size += x)) ) {
throwCantPack(""PT_NOTEs too big; try '--force-execve'"");
return false;
}
if (osabi_note && Elf32_Ehdr::ELFOSABI_NONE==osabi0) {
struct {
struct Elf32_Nhdr nhdr;
char name[8];
unsigned body;
} note;
memset(&note, 0, sizeof(note));
fi->seek(p_offset, SEEK_SET);
fi->readx(&note, sizeof(note));
fi->seek(0, SEEK_SET);
if (4==get_te32(&note.nhdr.descsz)
&&  1==get_te32(&note.nhdr.type)
&&  (1+ strlen(osabi_note))==get_te32(&note.nhdr.namesz)
&&  0==strcmp(osabi_note, (char const *)&note.name[0])
) {
osabi0 = ei_osabi;
}
}
}
}
if (Elf32_Ehdr::ELFOSABI_NONE ==osabi0
||  Elf32_Ehdr::ELFOSABI_LINUX==osabi0) {
unsigned const arm_eabi = 0xff000000u & get_te32(&ehdr->e_flags);
if (Elf32_Ehdr::EM_ARM==e_machine
&&   (EF_ARM_EABI_VER5==arm_eabi
||  EF_ARM_EABI_VER4==arm_eabi ) ) {
ei_osabi = osabi0 = Elf32_Ehdr::ELFOSABI_LINUX;
}
else {
osabi0 = opt->o_unix.osabi0;
}
}
if (osabi0!=ei_osabi) {
return false;
}
if (Elf32_Ehdr::ET_DYN==get_te16(&ehdr->e_type)) {
alloc_file_image(file_image, file_size);
fi->seek(0, SEEK_SET);
fi->readx(file_image, file_size);
memcpy(&ehdri, ehdr, sizeof(Elf32_Ehdr));
phdri= (Elf32_Phdr *)((size_t)e_phoff + file_image);
shdri= (Elf32_Shdr *)((size_t)e_shoff + file_image);
sec_strndx = NULL;
shstrtab = NULL;
if (e_shnum) {
unsigned const e_shstrndx = get_te16(&ehdr->e_shstrndx);
if (e_shstrndx) {
if (e_shnum <= e_shstrndx) {
char msg[40]; snprintf(msg, sizeof(msg),
""bad e_shstrndx %#x >= e_shnum %d"", e_shstrndx, e_shnum);
throwCantPack(msg);
}
sec_strndx = &shdri[e_shstrndx];
unsigned const sh_offset = get_te32(&sec_strndx->sh_offset);
if ((u32_t)file_size <= sh_offset) {
char msg[50]; snprintf(msg, sizeof(msg),
""bad .e_shstrndx->sh_offset %#x"", sh_offset);
throwCantPack(msg);
}
shstrtab = (char const *)(sh_offset + file_image);
}
sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);
if (sec_dynsym) {
unsigned const sh_link = get_te32(&sec_dynsym->sh_link);
if (e_shnum <= sh_link) {
char msg[50]; snprintf(msg, sizeof(msg),
""bad SHT_DYNSYM.sh_link %#x"", sh_link);
}
sec_dynstr = &shdri[sh_link];
}
if (sec_strndx) {
unsigned const sh_name = get_te32(&sec_strndx->sh_name);
if (Elf32_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type)
|| (u32_t)file_size <= sh_name
|| (sh_name
&& 0!=strcmp((char const *)"".shstrtab"", &shstrtab[sh_name]))
) {
throwCantPack(""bad e_shstrndx"");
}
}
}
Elf32_Phdr const *pload_x0(0);
phdr= phdri;
for (int j= e_phnum; --j>=0; ++phdr)
if (Elf32_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {
dynseg= (Elf32_Dyn const *)(check_pt_dynamic(phdr) + file_image);
invert_pt_dynamic(dynseg);
}
else if (PT_LOAD32==get_te32(&phdr->p_type)) {
if (!pload_x0
&&  Elf32_Phdr::PF_X & get_te32(&phdr->p_flags)
) {
pload_x0 = phdr;
}
check_pt_load(phdr);
}
dynstr=          (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);
dynsym=     (Elf32_Sym const *)elf_find_dynamic(Elf32_Dyn::DT_SYMTAB);
if (opt->o_unix.force_pie
||      Elf32_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf32_Dyn::DT_FLAGS_1)
||  calls_crt1((Elf32_Rel const *)elf_find_dynamic(Elf32_Dyn::DT_REL),
(int)elf_unsigned_dynamic(Elf32_Dyn::DT_RELSZ))
||  calls_crt1((Elf32_Rel const *)elf_find_dynamic(Elf32_Dyn::DT_JMPREL),
(int)elf_unsigned_dynamic(Elf32_Dyn::DT_PLTRELSZ))) {
is_pie = true;
goto proceed;
}
if (                      elf_find_dynamic(upx_dt_init)) {
if (this->e_machine!=Elf32_Ehdr::EM_386
&&  this->e_machine!=Elf32_Ehdr::EM_MIPS
&&  this->e_machine!=Elf32_Ehdr::EM_ARM)
goto abandon;
if (elf_has_dynamic(Elf32_Dyn::DT_TEXTREL)) {
throwCantPack(""DT_TEXTREL found; re-compile with -fPIC"");
goto abandon;
}
if (!(Elf32_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf32_Dyn::DT_FLAGS_1))) {
if (Elf32_Ehdr::EM_ARM == e_machine
&&  !opt->o_unix.android_shlib
) {
opt->info_mode++;
info(""note: use --android-shlib if appropriate"");
opt->info_mode--;
}
}
Elf32_Shdr const *shdr = shdri;
xct_va = ~0u;
if (e_shnum) {
for (int j= e_shnum; --j>=0; ++shdr) {
unsigned const sh_type = get_te32(&shdr->sh_type);
if (Elf32_Shdr::SHF_EXECINSTR & get_te32(&shdr->sh_flags)) {
xct_va = umin(xct_va, get_te32(&shdr->sh_addr));
}
if ((     Elf32_Dyn::DT_PREINIT_ARRAY==upx_dt_init
&&  Elf32_Shdr::SHT_PREINIT_ARRAY==sh_type)
||  (     Elf32_Dyn::DT_INIT_ARRAY   ==upx_dt_init
&&  Elf32_Shdr::SHT_INIT_ARRAY   ==sh_type) ) {
unsigned user_init_ava = get_te32(&shdr->sh_addr);
user_init_off = get_te32(&shdr->sh_offset);
if ((u32_t)file_size <= user_init_off) {
char msg[70]; snprintf(msg, sizeof(msg),
""bad Elf32_Shdr[%d].sh_offset %#x"",
-1+ e_shnum - j, user_init_off);
throwCantPack(msg);
}
int z_rel = dt_table[Elf32_Dyn::DT_REL];
int z_rsz = dt_table[Elf32_Dyn::DT_RELSZ];
if (z_rel && z_rsz) {
unsigned rel_off = get_te32(&dynseg[-1+ z_rel].d_val);
Elf32_Rel *rp = (Elf32_Rel *)&file_image[rel_off];
unsigned relsz   = get_te32(&dynseg[-1+ z_rsz].d_val);
Elf32_Rel *last = (Elf32_Rel *)(relsz + (char *)rp);
for (; rp < last; ++rp) {
unsigned r_va = get_te32(&rp->r_offset);
if (r_va == user_init_ava) {
unsigned r_info = get_te32(&rp->r_info);
unsigned r_type = ELF32_R_TYPE(r_info);
if (Elf32_Ehdr::EM_ARM == e_machine
&&  R_ARM_RELATIVE == r_type) {
user_init_va = get_te32(&file_image[user_init_off]);
}
else {
char msg[50]; snprintf(msg, sizeof(msg),
""bad relocation %#x DT_INIT_ARRAY[0]"",
r_info);
throwCantPack(msg);
}
break;
}
}
}
unsigned const p_filesz = get_te32(&pload_x0->p_filesz);
if (!((user_init_va - xct_va) < p_filesz)) {
if (0==user_init_va && opt->o_unix.android_shlib) {
upx_dt_init = 0;
}
else {
char msg[70]; snprintf(msg, sizeof(msg),
""bad init address %#x in Elf32_Shdr[%d].%#x\n"",
(unsigned)user_init_va, -1+ e_shnum - j, user_init_off);
throwCantPack(msg);
}
}
}
if ((Elf32_Dyn::DT_INIT==upx_dt_init || !upx_dt_init)
&&  Elf32_Shdr::SHT_DYNAMIC == sh_type) {
unsigned const n = get_te32(&shdr->sh_size) / sizeof(Elf32_Dyn);
Elf32_Dyn *dynp = (Elf32_Dyn *)&file_image[get_te32(&shdr->sh_offset)];
for (; Elf32_Dyn::DT_NULL != dynp->d_tag; ++dynp) {
if (upx_dt_init == get_te32(&dynp->d_tag)) {
break;
}
}
if ((1+ dynp) < (n+ dynseg)) {
user_init_va = get_te32(&dynp->d_val);
set_te32(&dynp->d_tag, upx_dt_init = Elf32_Dyn::DT_INIT);
user_init_off = (char const *)&dynp->d_val - (char const *)&file_image[0];
}
}
}
}
else {
unsigned const strsz  = elf_unsigned_dynamic(Elf32_Dyn::DT_STRSZ);
unsigned const strtab = elf_unsigned_dynamic(Elf32_Dyn::DT_STRTAB);
unsigned const relsz  = elf_unsigned_dynamic(Elf32_Dyn::DT_RELSZ);
unsigned const rel    = elf_unsigned_dynamic(Elf32_Dyn::DT_REL);
unsigned const init   = elf_unsigned_dynamic(upx_dt_init);
if ((init == (relsz + rel   ) && rel    == (strsz + strtab))
||  (init == (strsz + strtab) && strtab == (relsz + rel   ))
) {
xct_va = init;
user_init_va = init;
user_init_off = elf_get_offset_from_address(init);
}
}
unsigned const va_gash = elf_unsigned_dynamic(Elf32_Dyn::DT_GNU_HASH);
unsigned const va_hash = elf_unsigned_dynamic(Elf32_Dyn::DT_HASH);
unsigned y = 0;
if ((y=1, xct_va < va_gash)  ||  (y=2, (0==va_gash && xct_va < va_hash))
||  (y=3, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_STRTAB))
||  (y=4, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_SYMTAB))
||  (y=5, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_REL))
||  (y=6, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_RELA))
||  (y=7, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_JMPREL))
||  (y=8, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERDEF))
||  (y=9, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERSYM))
||  (y=10, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERNEEDED)) ) {
static char const *which[] = {
""unknown"",
""DT_GNU_HASH"",
""DT_HASH"",
""DT_STRTAB"",
""DT_SYMTAB"",
""DT_REL"",
""DT_RELA"",
""DT_JMPREL"",
""DT_VERDEF"",
""DT_VERSYM"",
""DT_VERNEEDED"",
};
char buf[30]; snprintf(buf, sizeof(buf), ""%s above stub"", which[y]);
throwCantPack(buf);
goto abandon;
}
if (!opt->o_unix.android_shlib) {
phdr = phdri;
for (unsigned j= 0; j < e_phnum; ++phdr, ++j) {
unsigned const vaddr = get_te32(&phdr->p_vaddr);
if (PT_NOTE32 == get_te32(&phdr->p_type)
&& xct_va < vaddr) {
char buf[40]; snprintf(buf, sizeof(buf),
""PT_NOTE %#x above stub"", vaddr);
throwCantPack(buf);
goto abandon;
}
}
}
xct_off = elf_get_offset_from_address(xct_va);
if (opt->debug.debug_level) {
fprintf(stderr, ""shlib canPack: xct_va=%#lx  xct_off=%#lx\n"",
(long)xct_va, (long)xct_off);
}
goto proceed;
}
else
throwCantPack(""need DT_INIT; try \""void _init(void){}\"""");
abandon:
return false;
proceed: ;
}
if (!super::canPack())
return false;
assert(exetype == 1);
exetype = 0;
opt->o_unix.blocksize = blocksize = file_size;
return true;
}","[125, 129]",An out-of-bounds read access vulnerability was discovered in UPX in PackLinuxElf64::canPack() function of p_lx_elf.cpp file. An attacker with a crafted input file could trigger this issue that could cause a crash leading to a denial of service.,upx,CVE-2020-27788,CWE-125
1027,1887,"void CoreUserInputHandler::doMode(const BufferInfo &bufferInfo, const QChar& addOrRemove, const QChar& mode, const QString &nicks)
{
QString m;
bool isNumber;
int maxModes = network()->support(""MODES"").toInt(&isNumber);
if (!isNumber || maxModes == 0) maxModes = 1;
QStringList nickList;
if (nicks == ""*"") {
const QList<IrcUser*> users = network()->ircChannel(bufferInfo.bufferName())->ircUsers();
foreach(IrcUser *user, users) {
if ((addOrRemove == '+' && !network()->ircChannel(bufferInfo.bufferName())->userModes(user).contains(mode))
|| (addOrRemove == '-' && network()->ircChannel(bufferInfo.bufferName())->userModes(user).contains(mode)))
nickList.append(user->nick());
}
} else {
nickList = nicks.split(' ', QString::SkipEmptyParts);
}
if (nickList.count() == 0) return;
while (!nickList.isEmpty()) {
int amount = qMin(nickList.count(), maxModes);
QString m = addOrRemove; for(int i = 0; i < amount; i++) m += mode;
QStringList params;
params << bufferInfo.bufferName() << m;
for(int i = 0; i < amount; i++) params << nickList.takeFirst();
emit putCmd(""MODE"", serverEncode(params));
}
}",[8],"The CoreUserInputHandler::doMode function in core/coreuserinputhandler.cpp in Quassel 0.10.0 allows remote attackers to cause a denial of service (application crash) via the ""/op *"" command in a query.",quassel,CVE-2015-8547,CWE-17
1028,7816,"GF_Err flac_dmx_process(GF_Filter *filter)
{
GF_FLACDmxCtx *ctx = gf_filter_get_udta(filter);
GF_FilterPacket *pck, *dst_pck;
u8 *output;
u8 *start;
Bool final_flush=GF_FALSE;
u32 pck_size, remain, prev_pck_size;
u64 cts = GF_FILTER_NO_TS;
FLACHeader hdr;
if (!ctx->duration.num)
flac_dmx_check_dur(filter, ctx);
if (ctx->opid && !ctx->is_playing)
return GF_OK;
pck = gf_filter_pid_get_packet(ctx->ipid);
if (!pck) {
if (gf_filter_pid_is_eos(ctx->ipid)) {
if (!ctx->flac_buffer_size) {
if (ctx->opid)
gf_filter_pid_set_eos(ctx->opid);
if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);
ctx->src_pck = NULL;
return GF_EOS;
}
final_flush = GF_TRUE;
} else {
return GF_OK;
}
}
prev_pck_size = ctx->flac_buffer_size;
if (pck && !ctx->resume_from) {
u8 *data = (u8 *) gf_filter_pck_get_data(pck, &pck_size);
if (ctx->byte_offset != GF_FILTER_NO_BO) {
u64 byte_offset = gf_filter_pck_get_byte_offset(pck);
if (!ctx->flac_buffer_size) {
ctx->byte_offset = byte_offset;
} else if (ctx->byte_offset + ctx->flac_buffer_size != byte_offset) {
ctx->byte_offset = GF_FILTER_NO_BO;
if ((byte_offset != GF_FILTER_NO_BO) && (byte_offset>ctx->flac_buffer_size) ) {
ctx->byte_offset = byte_offset - ctx->flac_buffer_size;
}
}
}
if (ctx->flac_buffer_size + pck_size > ctx->flac_buffer_alloc) {
ctx->flac_buffer_alloc = ctx->flac_buffer_size + pck_size;
ctx->flac_buffer = gf_realloc(ctx->flac_buffer, ctx->flac_buffer_alloc);
}
memcpy(ctx->flac_buffer + ctx->flac_buffer_size, data, pck_size);
ctx->flac_buffer_size += pck_size;
}
if (ctx->timescale && pck) {
cts = gf_filter_pck_get_cts(pck);
}
if (cts == GF_FILTER_NO_TS) {
prev_pck_size = 0;
}
remain = ctx->flac_buffer_size;
start = ctx->flac_buffer;
if (ctx->resume_from) {
start += ctx->resume_from - 1;
remain -= ctx->resume_from - 1;
ctx->resume_from = 0;
}
while (remain>2) {
u32 next_frame=0, nb_samp;
u32 cur_size = remain-2;
u8 *cur_buf = start+2;
u8 *hdr_start = NULL;
if (final_flush) {
next_frame = remain;
} else {
while (cur_size) {
hdr_start = memchr(cur_buf, 0xFF, cur_size);
if (!hdr_start) break;
next_frame = (u32) (hdr_start-start);
if (next_frame == remain)
break;
if ((hdr_start[1]&0xFC) == 0xF8) {
if (flac_parse_header(ctx, hdr_start, (u32) remain - next_frame, &hdr))
break;
}
cur_buf = hdr_start+1;
cur_size = (u32) (cur_buf - start);
assert(cur_size<=remain);
cur_size = remain - cur_size;
hdr_start = NULL;
}
if (!hdr_start) break;
if (next_frame == remain)
break;
}
if (!ctx->initialized) {
u32 size = next_frame;
u32 dsi_end = 0;
gf_bs_reassign_buffer(ctx->bs, ctx->flac_buffer, size);
u32 magic = gf_bs_read_u32(ctx->bs);
if (magic != GF_4CC('f','L','a','C')) {
}
while (gf_bs_available(ctx->bs)) {
Bool last = gf_bs_read_int(ctx->bs, 1);
u32 type = gf_bs_read_int(ctx->bs, 7);
u32 len = gf_bs_read_int(ctx->bs, 24);
if (type==0) {
u16 min_block_size = gf_bs_read_u16(ctx->bs);
u16 max_block_size = gf_bs_read_u16(ctx->bs);
gf_bs_read_u24(ctx->bs);
gf_bs_read_u24(ctx->bs);
ctx->sample_rate = gf_bs_read_int(ctx->bs, 20);
ctx->nb_channels = 1 + gf_bs_read_int(ctx->bs, 3);
ctx->bits_per_sample = 1 + gf_bs_read_int(ctx->bs, 5);
if (min_block_size==max_block_size) ctx->block_size = min_block_size;
else ctx->block_size = 0;
ctx->duration.num = gf_bs_read_long_int(ctx->bs, 36);
ctx->duration.den = ctx->sample_rate;
gf_bs_skip_bytes(ctx->bs, 16);
dsi_end = (u32) gf_bs_get_position(ctx->bs);
} else {
gf_bs_skip_bytes(ctx->bs, len);
}
if (last) break;
}
flac_dmx_check_pid(filter, ctx, ctx->flac_buffer+4, dsi_end-4);
remain -= size;
start += size;
ctx->initialized = GF_TRUE;
if (!ctx->is_playing) break;
continue;
}
if ((start[0] != 0xFF) && ((start[1]&0xFC) != 0xF8)) {
GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (""[FLACDmx] invalid frame, droping %d bytes and resyncing\n"", next_frame));
start += next_frame;
remain -= next_frame;
continue;
}
flac_parse_header(ctx,start, next_frame, &hdr);
if (hdr.sample_rate != ctx->sample_rate) {
ctx->sample_rate = hdr.sample_rate;
gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAMPLE_RATE, & PROP_UINT(ctx->sample_rate));
}
nb_samp = hdr.block_size;
if (ctx->in_seek) {
u64 nb_samples_at_seek = (u64) (ctx->start_range * ctx->sample_rate);
if (ctx->cts + nb_samp >= nb_samples_at_seek) {
ctx->in_seek = GF_FALSE;
}
}
if (ctx->timescale && !prev_pck_size && (cts != GF_FILTER_NO_TS) ) {
ctx->cts = cts;
cts = GF_FILTER_NO_TS;
}
if (!ctx->in_seek) {
dst_pck = gf_filter_pck_new_alloc(ctx->opid, next_frame, &output);
memcpy(output, start, next_frame);
gf_filter_pck_set_cts(dst_pck, ctx->cts);
if (!ctx->timescale || (ctx->timescale==ctx->sample_rate) )
gf_filter_pck_set_duration(dst_pck, nb_samp);
else {
gf_filter_pck_set_duration(dst_pck, (nb_samp * ctx->timescale) / ctx->sample_rate);
}
gf_filter_pck_set_sap(dst_pck, GF_FILTER_SAP_1);
gf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);
if (ctx->byte_offset != GF_FILTER_NO_BO) {
gf_filter_pck_set_byte_offset(dst_pck, ctx->byte_offset);
}
gf_filter_pck_send(dst_pck);
}
flac_dmx_update_cts(ctx, nb_samp);
assert (start[0] == 0xFF);
assert((start[1]&0xFC) == 0xF8);
start += next_frame;
assert(remain >= next_frame);
remain -= next_frame;
}
if (!pck) {
ctx->flac_buffer_size = 0;
return flac_dmx_process(filter);
} else {
if (remain < ctx->flac_buffer_size) {
memmove(ctx->flac_buffer, start, remain);
}
ctx->flac_buffer_size = remain;
gf_filter_pid_drop_packet(ctx->ipid);
}
return GF_OK;
}","[11, 122]","There is a integer overflow in function filter_core/filter_props.c:gf_props_assign_value in GPAC 1.0.1. In which, the arg const GF_PropertyValue *value,maybe value->value.data.size is a negative number. In result, memcpy in gf_props_assign_value failed.",gpac,CVE-2021-29279,CWE-190
1029,9853,"void SFS_ObjectMemberAccess(ScriptParser *parser)
{
if (parser->codec->LastError) return;
SFS_Expression(parser);
SFS_AddString(parser, ""."");
SFS_Identifier(parser);
}",[5],Uncontrolled Recursion in GitHub repository gpac/gpac prior to 2.1.0-DEV.,gpac,CVE-2022-3222,CWE-674
1031,1579,"bool Greeter::start() {
if (m_started)
return false;
if (daemonApp->testing()) {
m_process = new QProcess(this);
connect(m_process, SIGNAL(finished(int,QProcess::ExitStatus)), this, SLOT(finished()));
connect(m_process, SIGNAL(readyReadStandardOutput()), SLOT(onReadyReadStandardOutput()));
connect(m_process, SIGNAL(readyReadStandardError()), SLOT(onReadyReadStandardError()));
qDebug() << ""Greeter starting..."";
QProcessEnvironment env = QProcessEnvironment::systemEnvironment();
env.insert(QStringLiteral(""DISPLAY""), m_display->name());
env.insert(QStringLiteral(""XAUTHORITY""), m_authPath);
env.insert(QStringLiteral(""XCURSOR_THEME""), mainConfig.Theme.CursorTheme.get());
m_process->setProcessEnvironment(env);
QStringList args;
if (daemonApp->testing())
args << QStringLiteral(""--test-mode"");
args << QStringLiteral(""--socket"") << m_socket
<< QStringLiteral(""--theme"") << m_theme;
m_process->start(QStringLiteral(""%1/sddm-greeter"").arg(QStringLiteral(BIN_INSTALL_DIR)), args);
if (m_process->state() == QProcess::NotRunning) {
qCritical() << ""Greeter failed to launch."";
return false;
}
if (!m_process->waitForStarted()) {
qCritical() << ""Failed to start greeter."";
return false;
}
qDebug() << ""Greeter started."";
m_started = true;
} else {
m_auth = new Auth(this);
m_auth->setVerbose(true);
connect(m_auth, SIGNAL(requestChanged()), this, SLOT(onRequestChanged()));
connect(m_auth, SIGNAL(session(bool)), this, SLOT(onSessionStarted(bool)));
connect(m_auth, SIGNAL(finished(Auth::HelperExitStatus)), this, SLOT(onHelperFinished(Auth::HelperExitStatus)));
connect(m_auth, SIGNAL(info(QString,Auth::Info)), this, SLOT(authInfo(QString,Auth::Info)));
connect(m_auth, SIGNAL(error(QString,Auth::Error)), this, SLOT(authError(QString,Auth::Error)));
QStringList args;
args << QStringLiteral(""%1/sddm-greeter"").arg(QStringLiteral(BIN_INSTALL_DIR));
args << QStringLiteral(""--socket"") << m_socket
<< QStringLiteral(""--theme"") << m_theme;
QProcessEnvironment env;
QProcessEnvironment sysenv = QProcessEnvironment::systemEnvironment();
insertEnvironmentList({QStringLiteral(""LANG""), QStringLiteral(""LANGUAGE""),
QStringLiteral(""LC_CTYPE""), QStringLiteral(""LC_NUMERIC""), QStringLiteral(""LC_TIME""), QStringLiteral(""LC_COLLATE""),
QStringLiteral(""LC_MONETARY""), QStringLiteral(""LC_MESSAGES""), QStringLiteral(""LC_PAPER""), QStringLiteral(""LC_NAME""),
QStringLiteral(""LC_ADDRESS""), QStringLiteral(""LC_TELEPHONE""), QStringLiteral(""LC_MEASUREMENT""), QStringLiteral(""LC_IDENTIFICATION""),
QStringLiteral(""LD_LIBRARY_PATH""),
QStringLiteral(""QML2_IMPORT_PATH""),
QStringLiteral(""QT_PLUGIN_PATH""),
QStringLiteral(""XDG_DATA_DIRS"")
}, sysenv, env);
env.insert(QStringLiteral(""PATH""), mainConfig.Users.DefaultPath.get());
env.insert(QStringLiteral(""DISPLAY""), m_display->name());
env.insert(QStringLiteral(""XAUTHORITY""), m_authPath);
env.insert(QStringLiteral(""XCURSOR_THEME""), mainConfig.Theme.CursorTheme.get());
env.insert(QStringLiteral(""XDG_SEAT""), m_display->seat()->name());
env.insert(QStringLiteral(""XDG_SEAT_PATH""), daemonApp->displayManager()->seatPath(m_display->seat()->name()));
env.insert(QStringLiteral(""XDG_SESSION_PATH""), daemonApp->displayManager()->sessionPath(QStringLiteral(""Session%1"").arg(daemonApp->newSessionId())));
env.insert(QStringLiteral(""XDG_VTNR""), QString::number(m_display->terminalId()));
env.insert(QStringLiteral(""XDG_SESSION_CLASS""), QStringLiteral(""greeter""));
env.insert(QStringLiteral(""XDG_SESSION_TYPE""), m_display->sessionType());
m_auth->insertEnvironment(env);
qDebug() << ""Greeter starting..."";
m_auth->setUser(QStringLiteral(""sddm""));
m_auth->setGreeter(true);
m_auth->setSession(args.join(QLatin1Char(' ')));
m_auth->start();
}
return true;
}",[64],"daemon/Greeter.cpp in sddm before 0.13.0 does not properly disable the KDE crash handler, which allows local users to gain privileges by crashing a greeter when using certain themes, as demonstrated by the plasma-workspace breeze theme.",sddm,CVE-2015-0856,CWE-264
1033,5090,"static av_cold int decode_init(AVCodecContext *avctx)
{
UtvideoContext * const c = avctx->priv_data;
c->avctx = avctx;
ff_bswapdsp_init(&c->bdsp);
if (avctx->extradata_size < 16) {
av_log(avctx, AV_LOG_ERROR,
""Insufficient extradata size %d, should be at least 16\n"",
avctx->extradata_size);
return AVERROR_INVALIDDATA;
}
av_log(avctx, AV_LOG_DEBUG, ""Encoder version %d.%d.%d.%d\n"",
avctx->extradata[3], avctx->extradata[2],
avctx->extradata[1], avctx->extradata[0]);
av_log(avctx, AV_LOG_DEBUG, ""Original format %""PRIX32""\n"",
AV_RB32(avctx->extradata + 4));
c->frame_info_size = AV_RL32(avctx->extradata + 8);
c->flags           = AV_RL32(avctx->extradata + 12);
if (c->frame_info_size != 4)
avpriv_request_sample(avctx, ""Frame info not 4 bytes"");
av_log(avctx, AV_LOG_DEBUG, ""Encoding parameters %08""PRIX32""\n"", c->flags);
c->slices      = (c->flags >> 24) + 1;
c->compression = c->flags & 1;
c->interlaced  = c->flags & 0x800;
c->slice_bits_size = 0;
switch (avctx->codec_tag) {
case MKTAG('U', 'L', 'R', 'G'):
c->planes      = 3;
avctx->pix_fmt = AV_PIX_FMT_RGB24;
break;
case MKTAG('U', 'L', 'R', 'A'):
c->planes      = 4;
avctx->pix_fmt = AV_PIX_FMT_RGBA;
break;
case MKTAG('U', 'L', 'Y', '0'):
c->planes      = 3;
avctx->pix_fmt = AV_PIX_FMT_YUV420P;
avctx->colorspace = AVCOL_SPC_BT470BG;
break;
case MKTAG('U', 'L', 'Y', '2'):
c->planes      = 3;
avctx->pix_fmt = AV_PIX_FMT_YUV422P;
avctx->colorspace = AVCOL_SPC_BT470BG;
break;
case MKTAG('U', 'L', 'H', '0'):
c->planes      = 3;
avctx->pix_fmt = AV_PIX_FMT_YUV420P;
avctx->colorspace = AVCOL_SPC_BT709;
break;
case MKTAG('U', 'L', 'H', '2'):
c->planes      = 3;
avctx->pix_fmt = AV_PIX_FMT_YUV422P;
avctx->colorspace = AVCOL_SPC_BT709;
break;
default:
av_log(avctx, AV_LOG_ERROR, ""Unknown Ut Video FOURCC provided (%08X)\n"",
avctx->codec_tag);
return AVERROR_INVALIDDATA;
}
return 0;
}","[4, 60]",The decode_init function in libavcodec/utvideodec.c in FFmpeg 2.8 through 3.4.2 allows remote attackers to cause a denial of service (Out of array read) via an AVI file with crafted dimensions within chroma subsampling data.,FFmpeg,CVE-2018-7557,CWE-125
1048,7646,"void sqlite3Fts5UnicodeAscii(u8 *aArray, u8 *aAscii){
int i = 0;
int iTbl = 0;
while( i<128 ){
int bToken = aArray[ aFts5UnicodeData[iTbl] & 0x1F ];
int n = (aFts5UnicodeData[iTbl] >> 5) + i;
for(; i<128 && i<n; i++){
aAscii[i] = (u8)bToken;
}
iTbl++;
}
}",[10],"An issue was found in fts5UnicodeTokenize() in ext/fts5/fts5_tokenize.c in Sqlite. A unicode61 tokenizer configured to treat unicode ""control-characters"" (class Cc), was treating embedded nul characters as tokens. The issue was fixed in sqlite-3.34.0 and later.",sqlite,CVE-2021-20223,Unknown
1055,9631,"static void gf_dump_vrml_simple_field(GF_SceneDumper *sdump, GF_FieldInfo field, GF_Node *parent)
{
u32 i, sf_type;
GF_ChildNodeItem *list;
void *slot_ptr;
switch (field.fieldType) {
case GF_SG_VRML_SFNODE:
gf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL);
return;
case GF_SG_VRML_MFNODE:
list = * ((GF_ChildNodeItem **) field.far_ptr);
assert( list );
sdump->indent++;
while (list) {
gf_dump_vrml_node(sdump, list->node, 1, NULL);
list = list->next;
}
sdump->indent--;
return;
case GF_SG_VRML_SFCOMMANDBUFFER:
return;
}
if (gf_sg_vrml_is_sf_field(field.fieldType)) {
if (sdump->XMLDump) StartAttribute(sdump, ""value"");
gf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, parent);
if (sdump->XMLDump) EndAttribute(sdump);
} else {
GenMFField *mffield;
mffield = (GenMFField *) field.far_ptr;
sf_type = gf_sg_vrml_get_sf_type(field.fieldType);
if (!sdump->XMLDump) {
gf_fprintf(sdump->trace, ""["");
} else if (sf_type==GF_SG_VRML_SFSTRING) {
gf_fprintf(sdump->trace, "" value=\'"");
} else {
StartAttribute(sdump, ""value"");
}
for (i=0; i<mffield->count; i++) {
if (i) gf_fprintf(sdump->trace, "" "");
gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);
gf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, parent);
}
if (!sdump->XMLDump) {
gf_fprintf(sdump->trace, ""]"");
} else if (sf_type==GF_SG_VRML_SFSTRING) {
gf_fprintf(sdump->trace, ""\'"");
} else {
EndAttribute(sdump);
}
}
}",[38],NULL Pointer Dereference in GitHub repository gpac/gpac prior to v2.1.0-DEV.,gpac,CVE-2022-2549,CWE-476
1058,8033,"void print_udta(GF_ISOFile *file, u32 track_number, Bool has_itags)
{
u32 i, count;
count =  gf_isom_get_udta_count(file, track_number);
if (!count) return;
if (has_itags) {
for (i=0; i<count; i++) {
u32 type;
bin128 uuid;
gf_isom_get_udta_type(file, track_number, i+1, &type, &uuid);
if (type == GF_ISOM_BOX_TYPE_META) {
count--;
break;
}
}
if (!count) return;
}
fprintf(stderr, ""%d UDTA types: "", count);
for (i=0; i<count; i++) {
u32 j, type, nb_items, first=GF_TRUE;
bin128 uuid;
gf_isom_get_udta_type(file, track_number, i+1, &type, &uuid);
nb_items = gf_isom_get_user_data_count(file, track_number, type, uuid);
fprintf(stderr, ""%s (%d) "", gf_4cc_to_str(type), nb_items);
for (j=0; j<nb_items; j++) {
u8 *udta=NULL;
u32 udta_size;
gf_isom_get_user_data(file, track_number, type, uuid, j+1, &udta, &udta_size);
if (!udta) continue;
if (gf_utf8_is_legal(udta, udta_size)) {
if (first) {
fprintf(stderr, ""\n"");
first = GF_FALSE;
}
fprintf(stderr, ""\t%s\n"", (char *) udta);
}
gf_free(udta);
}
}
fprintf(stderr, ""\n"");
}","[30, 35]",Heap buffer overflow in the print_udta function in MP4Box in GPAC 1.0.1 allows attackers to cause a denial of service or execute arbitrary code via a crafted file.,gpac,CVE-2021-32136,CWE-787
1061,8012,"void AV1_RewriteESDescriptorEx(GF_MPEGVisualSampleEntryBox *av1, GF_MediaBox *mdia)
{
GF_BitRateBox *btrt = gf_isom_sample_entry_get_bitrate((GF_SampleEntryBox *)av1, GF_FALSE);
if (av1->emul_esd) gf_odf_desc_del((GF_Descriptor *)av1->emul_esd);
av1->emul_esd = gf_odf_desc_esd_new(2);
av1->emul_esd->decoderConfig->streamType = GF_STREAM_VISUAL;
av1->emul_esd->decoderConfig->objectTypeIndication = GF_CODECID_AV1;
if (btrt) {
av1->emul_esd->decoderConfig->bufferSizeDB = btrt->bufferSizeDB;
av1->emul_esd->decoderConfig->avgBitrate = btrt->avgBitrate;
av1->emul_esd->decoderConfig->maxBitrate = btrt->maxBitrate;
}
if (av1->av1_config) {
GF_AV1Config *av1_cfg = AV1_DuplicateConfig(av1->av1_config->config);
if (av1_cfg) {
gf_odf_av1_cfg_write(av1_cfg, &av1->emul_esd->decoderConfig->decoderSpecificInfo->data, &av1->emul_esd->decoderConfig->decoderSpecificInfo->dataLength);
gf_odf_av1_cfg_del(av1_cfg);
}
}
}",[13],The AV1_DuplicateConfig function in GPAC 1.0.1 allows attackers to cause a denial of service (NULL pointer dereference) via a crafted file in the MP4Box command.,gpac,CVE-2021-31262,CWE-476
1064,9850,"void SFS_CompoundExpression(ScriptParser *parser)
{
if (parser->codec->LastError) return;
SFS_Expression(parser);
if (! gf_bs_read_int(parser->bs, 1)) return;
SFS_AddString(parser, "","");
SFS_CompoundExpression(parser);
}",[6],Uncontrolled Recursion in GitHub repository gpac/gpac prior to 2.1.0-DEV.,gpac,CVE-2022-3222,CWE-674
