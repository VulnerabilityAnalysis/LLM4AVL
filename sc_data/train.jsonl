{"tokens": ["    function handoutExcessAssets(IERC20[] calldata erc20s) private {", "        /**", "         * Assumptions:", "         *   - Fully collateralized. All collateral meet balance requirements.", "         *   - All backing capital is held at BackingManager's address. No capital is out on-trade", "         *   - Neither RToken nor RSR are in the basket", "         *   - Each address in erc20s is unique", "         *", "         * Steps:", "         *   1. Forward all held RSR to the RSR trader to prevent using it for RToken appreciation", "         *      (action: send rsr().balanceOf(this) to rsrTrader)", "         *   2. Using whatever balances of collateral are there, fast-issue all RToken possible.", "         *      (in detail: mint RToken and set basketsNeeded so that the BU/rtok exchange rate is", "         *       roughly constant, and strictly does not decrease,", "         *   3. Handout all surplus asset balances (including collateral and RToken) to the", "         *      RSR and RToken traders according to the distribution totals.", "         */", "", "        // Forward any RSR held to StRSR pool; RSR should never be sold for RToken yield", "        if (rsr.balanceOf(address(this)) > 0) {", "            // For CEI, this is an interaction \"within our system\" even though RSR is already live", "            IERC20Upgradeable(address(rsr)).safeTransfer(", "                address(rsrTrader),", "                rsr.balanceOf(address(this))", "            );", "        }", "", "        // Mint revenue RToken and update `basketsNeeded`", "        // across this block:", "        //   where rate(R) == R.basketsNeeded / R.totalSupply,", "        //   rate(rToken') >== rate(rToken)", "        //   (>== is \"no less than, and nearly equal to\")", "        //    and rToken'.basketsNeeded <= basketHandler.basketsHeldBy(this)", "        // and rToken'.totalSupply is maximal satisfying this.", "        uint192 needed; // {BU}", "        {", "            needed = rToken.basketsNeeded(); // {BU}", "            uint192 held = basketHandler.basketsHeldBy(address(this)); // {BU}", "            if (held.gt(needed)) {", "                // gas-optimization: RToken is known to have 18 decimals, the same as FixLib", "                uint192 totalSupply = _safeWrap(rToken.totalSupply()); // {rTok}", "", "                // {BU} = {BU} - {BU}", "                uint192 extraBUs = held.minus(needed);", "", "                // {rTok} = {BU} * {rTok / BU} (if needed == 0, conv rate is 1 rTok/BU)", "                uint192 rTok = (needed > 0) ? extraBUs.mulDiv(totalSupply, needed) : extraBUs;", "", "                // gas-optimization: RToken is known to have 18 decimals, same as FixLib", "                rToken.mint(address(this), uint256(rTok));", "                rToken.setBasketsNeeded(held);", "                needed = held;", "            }", "        }", "", "        // At this point, even though basketsNeeded may have changed:", "        // - We're fully collateralized", "        // - The BU exchange rate {BU/rTok} did not decrease", "", "        // Keep a small buffer of individual collateral; \"excess\" assets are beyond the buffer.", "        needed = needed.mul(FIX_ONE.plus(backingBuffer));", "", "        // Handout excess assets above what is needed, including any recently minted RToken", "        uint256 length = erc20s.length;", "        RevenueTotals memory totals = distributor.totals();", "        uint256[] memory toRSR = new uint256[](length);", "        uint256[] memory toRToken = new uint256[](length);", "        for (uint256 i = 0; i < length; ++i) {", "            IAsset asset = assetRegistry.toAsset(erc20s[i]);", "", "            uint192 req = needed.mul(basketHandler.quantity(erc20s[i]), CEIL);", "            if (asset.bal(address(this)).gt(req)) {", "                // delta: {qTok}, the excess quantity of this asset that we hold", "                uint256 delta = asset.bal(address(this)).minus(req).shiftl_toUint(", "                    int8(IERC20Metadata(address(erc20s[i])).decimals())", "                );", "                // no div-by-0: Distributor guarantees (totals.rTokenTotal + totals.rsrTotal) > 0", "                // initial division is intentional here! We'd rather save the dust than be unfair", "                toRSR[i] = (delta / (totals.rTokenTotal + totals.rsrTotal)) * totals.rsrTotal;", "                toRToken[i] = (delta / (totals.rTokenTotal + totals.rsrTotal)) * totals.rTokenTotal;", "            }", "        }", "", "        // == Interactions ==", "        for (uint256 i = 0; i < length; ++i) {", "            IERC20Upgradeable erc20 = IERC20Upgradeable(address(erc20s[i]));", "            if (toRToken[i] > 0) erc20.safeTransfer(address(rTokenTrader), toRToken[i]);", "            if (toRSR[i] > 0) erc20.safeTransfer(address(rsrTrader), toRSR[i]);", "        }", "", "        // It's okay if there is leftover dust for RToken or a surplus asset (not RSR)", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function leave(address _vault, uint256 _proposalId) external {", "        // Reverts if address is not a registered vault", "        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(", "            _vault", "        );", "        if (id == 0) revert NotVault(_vault);", "        // Reverts if buyout state is not inactive", "        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);", "        State required = State.INACTIVE;", "        if (current != required) revert IBuyout.InvalidState(required, current);", "", "        // Gets the migration proposal for the given ID", "        Proposal storage proposal = migrationInfo[_vault][_proposalId];", "        // Updates fraction balances of the proposal and caller", "        uint256 amount = userProposalFractions[_proposalId][msg.sender];", "        proposal.totalFractions -= amount;", "        userProposalFractions[_proposalId][msg.sender] = 0;", "        // Updates ether balances of the proposal and caller", "        uint256 ethAmount = userProposalEth[_proposalId][msg.sender];", "        proposal.totalEth -= ethAmount;", "        userProposalEth[_proposalId][msg.sender] = 0;", "", "        // Withdraws fractions from contract back to caller", "        IFERC1155(token).safeTransferFrom(", "            address(this),", "            msg.sender,", "            id,", "            amount,", "            \"\"", "        );", "        // Withdraws ether from contract back to caller", "        payable(msg.sender).transfer(ethAmount);", "    }"], "ner_tags": [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _isUnanimousVotes(uint96 totalVotes, uint96 totalVotingPower)", "        private", "        pure", "        returns (bool)", "    {", "        uint256 acceptanceRatio = (totalVotes * 1e4) / totalVotingPower;", "        // If >= 99.99% acceptance, consider it unanimous.", "        // The minting formula for voting power is a bit lossy, so we check", "        // for slightly less than 100%.", "        return acceptanceRatio >= 0.9999e4;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["    function setComplete(bytes calldata _data, bytes calldata _signature)", "        external", "        override", "    {", "        // Decode params from _data", "        (uint256 _taskID, address _projectAddress) = abi.decode(", "            _data,", "            (uint256, address)", "        );", "", "        // Revert if decoded project address does not match this contract. Indicating incorrect _data.", "        require(_projectAddress == address(this), \"Project::!Project\");", "", "        // If the sender is disputes contract, then do not check for signatures.", "        if (_msgSender() != disputes) {", "            // Check signatures.", "            checkSignatureTask(_data, _signature, _taskID);", "        }", "", "        // Mark task as complete. Only works when task is active.", "        tasks[_taskID].setComplete();", "", "        // Transfer funds to subcontractor.", "        currency.safeTransfer(", "            tasks[_taskID].subcontractor,", "            tasks[_taskID].cost", "        );", "", "        emit TaskComplete(_taskID);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function withdrawFor(address payable user) public nonReentrant {", "    uint256 amount = pendingWithdrawals[user];", "    if (amount == 0) {", "      revert SendValueWithFallbackWithdraw_No_Funds_Available();", "    }", "    pendingWithdrawals[user] = 0;", "    user.sendValue(amount);", "    emit Withdrawal(user, amount);", "  }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function _removeFeeder(address _feeder)", "        internal", "        onlyWhenFeederExisted(_feeder)", "    {", "        uint8 feederIndex = feederPositionMap[_feeder].index;", "        if (feederIndex >= 0 && feeders[feederIndex] == _feeder) {", "            feeders[feederIndex] = feeders[feeders.length - 1];", "            feeders.pop();", "        }", "        delete feederPositionMap[_feeder];", "        revokeRole(UPDATER_ROLE, _feeder);", "        emit FeederRemoved(_feeder);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["    function publishProject(bytes calldata _data, bytes calldata _signature)", "        external", "        virtual", "        override", "        whenNotPaused", "    {", "        // Compute hash from bytes", "        bytes32 _hash = keccak256(_data);", "", "        // Decode params from _data", "        (", "            uint256 _communityID,", "            address _project,", "            uint256 _apr,", "            uint256 _publishFee,", "            uint256 _publishNonce,", "            bytes memory _messageHash", "        ) = abi.decode(", "                _data,", "                (uint256, address, uint256, uint256, uint256, bytes)", "            );", "", "        // Local instance of community and community  project details. For saving gas.", "        CommunityStruct storage _community = _communities[_communityID];", "        ProjectDetails storage _communityProject = _community.projectDetails[", "            _project", "        ];", "", "        // Revert if decoded nonce is incorrect. This indicates wrong _data.", "        require(", "            _publishNonce == _community.publishNonce,", "            \"Community::invalid publishNonce\"", "        );", "", "        // Reverts if _project not originated from HomeFi", "        require(homeFi.isProjectExist(_project), \"Community::Project !Exists\");", "", "        // Local instance of variables. For saving gas.", "        IProject _projectInstance = IProject(_project);", "        address _builder = _projectInstance.builder();", "", "        // Revert if project builder is not community member", "        require(_community.isMember[_builder], \"Community::!Member\");", "", "        // Revert if project currency does not match community currency", "        require(", "            _projectInstance.currency() == _community.currency,", "            \"Community::!Currency\"", "        );", "", "        // check signatures", "        checkSignatureValidity(_community.owner, _hash, _signature, 0); // must be community owner", "        checkSignatureValidity(_builder, _hash, _signature, 1); // must be project builder", "", "        // If already published then unpublish first", "        if (projectPublished[_project] > 0) {", "            _unpublishProject(_project);", "        }", "", "        // Store updated details", "        _community.publishNonce = ++_community.publishNonce;", "        _communityProject.apr = _apr;", "        _communityProject.publishFee = _publishFee;", "        projectPublished[_project] = _communityID;", "", "        // If _publishFee is zero than mark publish fee as paid", "        if (_publishFee == 0) _communityProject.publishFeePaid = true;", "", "        emit ProjectPublished(", "            _communityID,", "            _project,", "            _apr,", "            _publishFee,", "            _communityProject.publishFeePaid,", "            _messageHash", "        );", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function createLot(uint256 _sdAmount) external override whenNotPaused {", "        lots[nextLot].startBlock = block.number;", "        lots[nextLot].endBlock = block.number + duration;", "        lots[nextLot].sdAmount = _sdAmount;", "", "        LotItem storage lotItem = lots[nextLot];", "", "        if (!IERC20(staderConfig.getStaderToken()).transferFrom(msg.sender, address(this), _sdAmount)) {", "            revert SDTransferFailed();", "        }", "        emit LotCreated(nextLot, lotItem.sdAmount, lotItem.startBlock, lotItem.endBlock, bidIncrement);", "        nextLot++;", "    }"], "ner_tags": [1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function initialize(address _controller) external onlyImpl {", "        Managed._initialize(_controller);", "        _paused = true;", "    }"], "ner_tags": [1, 0, 0, 0]}
{"tokens": ["    function multiStakerClaim(uint256[] memory tokenids, uint256[] memory epochs) public {", "        require(address(ve) != address(0), ' VE not added yet');", "", "        uint256 reward = 0;", "        uint256 rewardEth = 0;", "        address tokenowner = ve.ownerOf(tokenids[0]);", "", "        // for each tokenid", "        for (uint256 tindex = 0; tindex < tokenids.length; tindex++) {", "            require(tokenowner == ve.ownerOf(tokenids[tindex]), 'Can only claim for a single Address together');", "            // for each epoch", "            for (uint256 index = 0; index < epochs.length; index++) {", "                require(epochs[index] < epoch, 'cant claim for future epochs');", "                require(claimed[tokenids[tindex]][epochs[index]] == 0, 'cant claim if already claimed');", "                claimed[tokenids[tindex]][epochs[index]] = 1;", "                if (epochs[index] == 0){", "                    rewardEth =", "                        rewardEth +", "                        (epochTotalFee[0] *", "                            ve.balanceOfAtNFT(tokenids[tindex], epochBeginTime[1])) /", "                        ve.totalSupplyAt(epochBeginTime[1]);", "", "                }else{", "                    reward =", "                        reward +", "                        (rewardStaker[epochs[index]] * ve.balanceOfAtNFT(tokenids[tindex], epochBeginTime[epochs[index]])) /", "                        ve.totalSupplyAt(epochBeginTime[epochs[index]]);", "                    rewardEth =", "                        rewardEth +", "                        (epochTotalFee[epochs[index]] *", "                            ve.balanceOfAtNFT(tokenids[tindex], epochBeginTime[epochs[index]])) /", "                        ve.totalSupplyAt(epochBeginTime[epochs[index]]);", "                }", "", "            }", "        }", "        rewardToken.transfer(tokenowner, reward);", "        weth.transfer(tokenowner, rewardEth);", "    }"], "ner_tags": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function adjustPrice(uint256 newPrice) public onlyOwner noChallenge {", "        if (newPrice > price) {", "            restrictMinting(3 days);", "        } else {", "            checkCollateral(collateralBalance(), newPrice);", "        }", "        price = newPrice;", "        emitUpdate();", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function sell(uint256 _amtIn, uint256 _minAmtOut, address payable _to) external override notBoughtOut whenNotPaused returns(uint256 _saleReturn) {", "        //Make update on the first tx of the block", "        if (status == Status.buyout) {", "            uint32 _blockTimestamp = uint32(block.timestamp % 2**32);", "            if (_blockTimestamp != lastBlockTimeStamp) {", "                _updateTWAV(getCurrentValuation(), _blockTimestamp);   ", "                _rejectBuyout(); //For the case when TWAV goes up when updated on sell", "            }", "        }", "        uint256 _initialTokenSupply = initialTokenSupply;", "        uint256 _totalSupply = totalSupply();", "        if(_totalSupply > _initialTokenSupply) {", "            if ((_initialTokenSupply + _amtIn) <= _totalSupply) {", "                _saleReturn = _sellPrimaryCurve(_amtIn, _totalSupply);", "            } else {", "                //Gas Optimization", "                uint256 _tokensPrimaryCurve = _totalSupply - _initialTokenSupply;", "                _saleReturn = primaryReserveBalance - fictitiousPrimaryReserveBalance;", "                primaryReserveBalance -= _saleReturn;", "                _saleReturn = _chargeFee(_saleReturn);", "                // _saleReturn = _sellPrimaryCurve(_tokensPrimaryCurve);", "                _saleReturn += _sellSecondaryCurve(_amtIn - _tokensPrimaryCurve, _initialTokenSupply);", "            } } else {", "                _saleReturn = _sellSecondaryCurve(_amtIn,_totalSupply);", "        }", "        require(_saleReturn >= _minAmtOut, \"NibblVault: Return too low\");", "        _burn(msg.sender, _amtIn);", "        safeTransferETH(_to, _saleReturn); //send _saleReturn to _to", "        emit Sell(msg.sender, _amtIn, _saleReturn);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function safeTransferFrom(", "    address account,", "    address recipient,", "    uint256 amount,", "    bytes memory data", "  ) public returns (bool) {", "    if (account != msg.sender) {", "      if (msg.sender != _holograph().getBridge() && msg.sender != _holograph().getOperator()) {", "        uint256 currentAllowance = _allowances[account][msg.sender];", "        require(currentAllowance >= amount, \"ERC20: amount exceeds allowance\");", "        unchecked {", "          _allowances[account][msg.sender] = currentAllowance - amount;", "        }", "      }", "    }", "    if (_isEventRegistered(HolographERC20Event.beforeSafeTransfer)) {", "      require(SourceERC20().beforeSafeTransfer(account, recipient, amount, data));", "    }", "    _transfer(account, recipient, amount);", "    require(_checkOnERC20Received(account, recipient, amount, data), \"ERC20: non ERC20Receiver\");", "    if (_isEventRegistered(HolographERC20Event.afterSafeTransfer)) {", "      require(SourceERC20().afterSafeTransfer(account, recipient, amount, data));", "    }", "    return true;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function commit(address _vault, uint256 _proposalId)", "        external", "        returns (bool started)", "    {", "        // Reverts if address is not a registered vault", "        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(", "            _vault", "        );", "        if (id == 0) revert NotVault(_vault);", "        // Reverts if buyout state is not inactive", "        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);", "        State required = State.INACTIVE;", "        if (current != required) revert IBuyout.InvalidState(required, current);", "        // Reverts if migration is passed proposal period", "        Proposal storage proposal = migrationInfo[_vault][_proposalId];", "        if (block.timestamp > proposal.startTime + PROPOSAL_PERIOD)", "            revert ProposalOver();", "", "        // Calculates current price of the proposal based on total supply", "        uint256 currentPrice = _calculateTotal(", "            100,", "            IVaultRegistry(registry).totalSupply(_vault),", "            proposal.totalEth,", "            proposal.totalFractions", "        );", "", "        // Checks if the current price is greater than target price of the proposal", "        if (currentPrice > proposal.targetPrice) {", "            // Sets token approval to the buyout contract", "            IFERC1155(token).setApprovalFor(address(buyout), id, true);", "            // Starts the buyout process", "            IBuyout(buyout).start{value: proposal.totalEth}(_vault);", "            proposal.isCommited = true;", "            started = true;", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["    function _aggregateValidFulfillmentOfferItems(", "        AdvancedOrder[] memory advancedOrders,", "        FulfillmentComponent[] memory offerComponents,", "        Execution memory execution", "    ) internal view {", "        assembly {", "            // Declare function for reverts on invalid fulfillment data.", "            function throwInvalidFulfillmentComponentData() {", "                // Store the InvalidFulfillmentComponentData error signature.", "                mstore(0, InvalidFulfillmentComponentData_error_signature)", "", "                // Return, supplying InvalidFulfillmentComponentData signature.", "                revert(0, InvalidFulfillmentComponentData_error_len)", "            }", "", "            // Declare function for reverts due to arithmetic overflows.", "            function throwOverflow() {", "                // Store the Panic error signature.", "                mstore(0, Panic_error_signature)", "", "                // Store the arithmetic (0x11) panic code as initial argument.", "                mstore(Panic_error_offset, Panic_arithmetic)", "", "                // Return, supplying Panic signature and arithmetic code.", "                revert(0, Panic_error_length)", "            }", "", "            // Get position in offerComponents head.", "            let fulfillmentHeadPtr := add(offerComponents, OneWord)", "", "            // Retrieve the order index using the fulfillment pointer.", "            let orderIndex := mload(mload(fulfillmentHeadPtr))", "", "            // Ensure that the order index is not out of range.", "            if iszero(lt(orderIndex, mload(advancedOrders))) {", "                throwInvalidFulfillmentComponentData()", "            }", "", "            // Read advancedOrders[orderIndex] pointer from its array head.", "            let orderPtr := mload(", "                // Calculate head position of advancedOrders[orderIndex].", "                add(add(advancedOrders, OneWord), mul(orderIndex, OneWord))", "            )", "", "            // Read the pointer to OrderParameters from the AdvancedOrder.", "            let paramsPtr := mload(orderPtr)", "", "            // Load the offer array pointer.", "            let offerArrPtr := mload(", "                add(paramsPtr, OrderParameters_offer_head_offset)", "            )", "", "            // Retrieve item index using an offset of the fulfillment pointer.", "            let itemIndex := mload(", "                add(mload(fulfillmentHeadPtr), Fulfillment_itemIndex_offset)", "            )", "", "            // Only continue if the fulfillment is not invalid.", "            if iszero(lt(itemIndex, mload(offerArrPtr))) {", "                throwInvalidFulfillmentComponentData()", "            }", "", "            // Retrieve consideration item pointer using the item index.", "            let offerItemPtr := mload(", "                add(", "                    // Get pointer to beginning of receivedItem.", "                    add(offerArrPtr, OneWord),", "                    // Calculate offset to pointer for desired order.", "                    mul(itemIndex, OneWord)", "                )", "            )", "", "            // Declare a variable for the final aggregated item amount.", "            let amount := 0", "", "            // Create variable to track errors encountered with amount.", "            let errorBuffer := 0", "", "            // Only add offer amount to execution amount on a nonzero numerator.", "            if mload(add(orderPtr, AdvancedOrder_numerator_offset)) {", "                // Retrieve amount pointer using consideration item pointer.", "                let amountPtr := add(offerItemPtr, Common_amount_offset)", "", "                // Set the amount.", "                amount := mload(amountPtr)", "", "                // Zero out amount on item to indicate it is credited.", "                mstore(amountPtr, 0)", "", "                // Buffer indicating whether issues were found.", "                errorBuffer := iszero(amount)", "            }", "", "            // Retrieve the received item pointer.", "            let receivedItemPtr := mload(execution)", "", "            // Set the caller as the recipient on the received item.", "            mstore(", "                add(receivedItemPtr, ReceivedItem_recipient_offset),", "                caller()", "            )", "", "            // Set the item type on the received item.", "            mstore(receivedItemPtr, mload(offerItemPtr))", "", "            // Set the token on the received item.", "            mstore(", "                add(receivedItemPtr, Common_token_offset),", "                mload(add(offerItemPtr, Common_token_offset))", "            )", "", "            // Set the identifier on the received item.", "            mstore(", "                add(receivedItemPtr, Common_identifier_offset),", "                mload(add(offerItemPtr, Common_identifier_offset))", "            )", "", "            // Set the offerer on returned execution using order pointer.", "            mstore(add(execution, Execution_offerer_offset), mload(paramsPtr))", "", "            // Set conduitKey on returned execution via offset of order pointer.", "            mstore(", "                add(execution, Execution_conduit_offset),", "                mload(add(paramsPtr, OrderParameters_conduit_offset))", "            )", "", "            // Calculate the hash of (itemType, token, identifier).", "            let dataHash := keccak256(", "                receivedItemPtr,", "                ReceivedItem_CommonParams_size", "            )", "", "            // Get position one word past last element in head of array.", "            let endPtr := add(", "                offerComponents,", "                mul(mload(offerComponents), OneWord)", "            )", "", "            // Iterate over remaining offer components.", "            // prettier-ignore", "            for {} lt(fulfillmentHeadPtr,  endPtr) {} {", "                // Increment the pointer to the fulfillment head by one word.", "                fulfillmentHeadPtr := add(fulfillmentHeadPtr, OneWord)", "", "                // Get the order index using the fulfillment pointer.", "                orderIndex := mload(mload(fulfillmentHeadPtr))", "", "                // Ensure the order index is in range.", "                if iszero(lt(orderIndex, mload(advancedOrders))) {", "                  throwInvalidFulfillmentComponentData()", "                }", "", "                // Get pointer to AdvancedOrder element.", "                orderPtr := mload(", "                    add(", "                        add(advancedOrders, OneWord),", "                        mul(orderIndex, OneWord)", "                    )", "                )", "", "                // Only continue if numerator is not zero.", "                if iszero(mload(", "                    add(orderPtr, AdvancedOrder_numerator_offset)", "                )) {", "                  continue", "                }", "", "                // Read the pointer to OrderParameters from the AdvancedOrder.", "                paramsPtr := mload(orderPtr)", "", "                // Load offer array pointer.", "                offerArrPtr := mload(", "                    add(", "                        paramsPtr,", "                        OrderParameters_offer_head_offset", "                    )", "                )", "", "                // Get the item index using the fulfillment pointer.", "                itemIndex := mload(add(mload(fulfillmentHeadPtr), OneWord))", "", "                // Throw if itemIndex is out of the range of array.", "                if iszero(", "                    lt(itemIndex, mload(offerArrPtr))", "                ) {", "                    throwInvalidFulfillmentComponentData()", "                }", "", "                // Retrieve offer item pointer using index.", "                offerItemPtr := mload(", "                    add(", "                        // Get pointer to beginning of receivedItem.", "                        add(offerArrPtr, OneWord),", "                        // Use offset to pointer for desired order.", "                        mul(itemIndex, OneWord)", "                    )", "                )", "", "                // Retrieve amount pointer using offer item pointer.", "                let amountPtr := add(", "                      offerItemPtr,", "                      Common_amount_offset", "                )", "", "                // Add offer amount to execution amount.", "                let newAmount := add(amount, mload(amountPtr))", "", "                // Update error buffer (1 = zero amount, 2 = overflow).", "                errorBuffer := or(", "                  errorBuffer,", "                  or(", "                    shl(1, lt(newAmount, amount)),", "                    iszero(mload(amountPtr))", "                  )", "                )", "", "                // Update the amount to the new, summed amount.", "                amount := newAmount", "", "                // Zero out amount on original item to indicate it is credited.", "                mstore(amountPtr, 0)", "", "                // Ensure the indicated item matches original item.", "                if iszero(", "                    and(", "                        and(", "                          // The offerer must match on both items.", "                          eq(", "                              mload(paramsPtr),", "                              mload(", "                                  add(execution, Execution_offerer_offset)", "                              )", "                          ),", "                          // The conduit key must match on both items.", "                          eq(", "                              mload(", "                                  add(", "                                      paramsPtr,", "                                      OrderParameters_conduit_offset", "                                  )", "                              ),", "                              mload(", "                                  add(", "                                      execution,", "                                      Execution_conduit_offset", "                                  )", "                              )", "                          )", "                        ),", "                        // The itemType, token, and identifier must match.", "                        eq(", "                            dataHash,", "                            keccak256(", "                                offerItemPtr,", "                                ReceivedItem_CommonParams_size", "                            )", "                        )", "                    )", "                ) {", "                    // Throw if any of the requirements are not met.", "                    throwInvalidFulfillmentComponentData()", "                }", "            }", "            // Write final amount to execution.", "            mstore(add(mload(execution), Common_amount_offset), amount)", "", "            // Determine if an error code is contained in the error buffer.", "            switch errorBuffer", "            case 1 {", "                // Store the MissingItemAmount error signature.", "                mstore(0, MissingItemAmount_error_signature)", "", "                // Return, supplying MissingItemAmount signature.", "                revert(0, MissingItemAmount_error_len)", "            }", "            case 2 {", "                // If the sum overflowed, panic.", "                throwOverflow()", "            }", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function notifyRewardAmount(address token, uint amount) external lock {", "        require(token != stake);", "        require(amount > 0);", "        if (!isReward[token]) {", "            require(rewards.length < MAX_REWARD_TOKENS, \"too many rewards tokens\");", "        }", "        // rewards accrue only during the bribe period", "        uint bribeStart = block.timestamp - (block.timestamp % (7 days)) + BRIBE_LAG;", "        uint adjustedTstamp = block.timestamp < bribeStart ? bribeStart : bribeStart + 7 days;", "        if (rewardRate[token] == 0) _writeRewardPerTokenCheckpoint(token, 0, adjustedTstamp);", "        (rewardPerTokenStored[token], lastUpdateTime[token]) = _updateRewardPerToken(token);", "        _claimFees();", "", "        if (block.timestamp >= periodFinish[token]) {", "            _safeTransferFrom(token, msg.sender, address(this), amount);", "            rewardRate[token] = amount / DURATION;", "        } else {", "            uint _remaining = periodFinish[token] - block.timestamp;", "            uint _left = _remaining * rewardRate[token];", "            require(amount > _left);", "            _safeTransferFrom(token, msg.sender, address(this), amount);", "            rewardRate[token] = (amount + _left) / DURATION;", "        }", "        require(rewardRate[token] > 0);", "        uint balance = IERC20(token).balanceOf(address(this));", "        require(rewardRate[token] <= balance / DURATION, \"Provided reward too high\");", "        periodFinish[token] = adjustedTstamp + DURATION;", "        if (!isReward[token]) {", "            isReward[token] = true;", "            rewards.push(token);", "            IBribe(bribe).addRewardToken(token);", "        }", "", "        emit NotifyReward(msg.sender, token, amount);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function transfer(address account, uint256 amount) external override notPaused returns (bool) {", "        require(msg.sender != account, Error.SELF_TRANSFER_NOT_ALLOWED);", "        require(balances[msg.sender] >= amount, Error.INSUFFICIENT_BALANCE);", "", "        ILiquidityPool pool = controller.addressProvider().getPoolForToken(token);", "        pool.handleLpTokenTransfer(msg.sender, account, amount);", "", "        balances[msg.sender] -= amount;", "        balances[account] += amount;", "", "        address lpGauge = currentAddresses[_LP_GAUGE];", "        if (lpGauge != address(0)) {", "            ILpGauge(lpGauge).userCheckpoint(msg.sender);", "            ILpGauge(lpGauge).userCheckpoint(account);", "        }", "", "        emit Transfer(msg.sender, account, amount);", "        return true;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": ["  function _transferAndDepositAssetIfAble(", "    RouterStorage storage s,", "    address tokenContract,", "    uint256 tokenId", "  ) internal {", "    ERC721 token = ERC721(tokenContract);", "    if (token.ownerOf(tokenId) == msg.sender) {", "      token.safeTransferFrom(", "        msg.sender,", "        address(s.COLLATERAL_TOKEN),", "        tokenId,", "        \"\"", "      );", "    }", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    constructor(", "        string memory contractName,", "        string memory contractSymbol", "    ) initializer", "    {", "        AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init();", "        ERC20Upgradeable.__ERC20_init(contractName, contractSymbol);", "        ERC20BurnableUpgradeable.__ERC20Burnable_init();", "        _setRoleAdmin(MINTER_ROLE, MINTER_ROLE);", "        _setupRole(MINTER_ROLE, _msgSender());", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0]}
{"tokens": ["    function allVestingRecipients() external view returns (address[] memory) {", "        return vestingRecipients;", "    }"], "ner_tags": [0, 1, 0]}
{"tokens": ["    function earned(address token, address account) public view returns (uint) {", "        uint _startTimestamp = Math.max(lastEarn[token][account], rewardPerTokenCheckpoints[token][0].timestamp);", "        if (numCheckpoints[account] == 0) {", "            return 0;", "        }", "", "        uint _startIndex = getPriorBalanceIndex(account, _startTimestamp);", "        uint _endIndex = numCheckpoints[account]-1;", "", "        uint reward = 0;", "", "        if (_endIndex > 0) {", "            for (uint i = _startIndex; i < _endIndex; i++) {", "                Checkpoint memory cp0 = checkpoints[account][i];", "                Checkpoint memory cp1 = checkpoints[account][i+1];", "                (uint _rewardPerTokenStored0,) = getPriorRewardPerToken(token, cp0.timestamp);", "                (uint _rewardPerTokenStored1,) = getPriorRewardPerToken(token, cp1.timestamp);", "                if (cp0.voted) {", "                    reward += cp0.balanceOf * (_rewardPerTokenStored1 - _rewardPerTokenStored0) / PRECISION;", "                }", "            }", "        }", "", "        Checkpoint memory cp = checkpoints[account][_endIndex];", "        uint lastCpWeeksVoteEnd = cp.timestamp - (cp.timestamp % (7 days)) + BRIBE_LAG + DURATION;", "        if (block.timestamp > lastCpWeeksVoteEnd) {", "            (uint _rewardPerTokenStored,) = getPriorRewardPerToken(token, cp.timestamp);", "            if (cp.voted) {", "                reward += cp.balanceOf * (rewardPerToken(token) - Math.max(_rewardPerTokenStored, userRewardPerTokenStored[token][account])) / PRECISION;", "            }", "        }", "", "        return reward;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function increaseCredit(bytes32 id, uint256 amount)", "      external", "      payable", "      override", "      whileActive", "      mutualConsentById(id)", "      returns (bool)", "    {", "        Credit memory credit = credits[id];", "        credit = _accrue(credit, id);", "", "        credit.deposit += amount;", "        ", "        credits[id] = credit;", "", "        LineLib.receiveTokenOrETH(credit.token, credit.lender, amount);", "", "        emit IncreaseCredit(id, amount);", "", "        return true;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function liquidate(", "    uint256 vaultId,", "    uint256 amount,", "    uint256 dexIndex,", "    bytes calldata dexTxData", "  ) public {", "    uint256 parBalanceBefore = _par.balanceOf(address(this));", "", "    IVaultsDataProvider.Vault memory vault = _a.parallel().vaultsData().vaults(vaultId);", "    IERC20 collateralToken = IERC20(vault.collateralType);", "    _a.parallel().core().liquidatePartial(vaultId, amount);", "", "    (address proxy, address router) = _dexAP.dexMapping(dexIndex);", "    collateralToken.approve(proxy, collateralToken.balanceOf(address(this)));", "    router.call(dexTxData);", "    _par.safeTransfer(msg.sender, _liquidateCallerReward);", "    require(_par.balanceOf(address(this)) > parBalanceBefore, \"LM104\");", "    _refreshPAR(_totalStake);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["    function rewardPerToken() public view override returns (uint256 _rewardPerToken) {", "        uint256 _totalSupply = totalSupply();", "        if (_totalSupply == 0) {", "            return rewardPerTokenStored;", "        }", "", "        uint256 ticketsSoldSinceUpdate = lottery.nextTicketId() - lastUpdateTicketId;", "        uint256 unclaimedRewards =", "            LotteryMath.calculateRewards(lottery.ticketPrice(), ticketsSoldSinceUpdate, LotteryRewardType.STAKING);", "", "        return rewardPerTokenStored + (unclaimedRewards * 1e18 / _totalSupply);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function mint(address u, uint256 m, uint256 uA, uint256 ptA, uint256 minRatio, uint256 maxRatio) external returns (uint256, uint256, uint256) {", "        IPool pool = IPool(pools[u][m]);", "        Safe.transferFrom(ERC20(address(pool.base())), msg.sender, address(pool), uA);  ", "        Safe.transferFrom(ERC20(address(pool.fyToken())), msg.sender, address(pool), ptA);", "        return pool.mint(msg.sender, msg.sender, minRatio, maxRatio);", "    }"], "ner_tags": [0, 0, 1, 1, 0, 0]}
{"tokens": ["    function add(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 minLpTokenAmount)", "        public", "        payable", "        returns (uint256 lpTokenAmount)", "    {", "        // *** Checks *** //", "", "        // check the token amount inputs are not zero", "        require(baseTokenAmount > 0 && fractionalTokenAmount > 0, \"Input token amount is zero\");", "", "        // check that correct eth input was sent - if the baseToken equals address(0) then native ETH is used", "        require(baseToken == address(0) ? msg.value == baseTokenAmount : msg.value == 0, \"Invalid ether input\");", "", "        // calculate the lp token shares to mint", "        lpTokenAmount = addQuote(baseTokenAmount, fractionalTokenAmount);", "", "        // check that the amount of lp tokens outputted is greater than the min amount", "        require(lpTokenAmount >= minLpTokenAmount, \"Slippage: lp token amount out\");", "", "        // *** Effects *** //", "", "        // transfer fractional tokens in", "        _transferFrom(msg.sender, address(this), fractionalTokenAmount);", "", "        // *** Interactions *** //", "", "        // mint lp tokens to sender", "        lpToken.mint(msg.sender, lpTokenAmount);", "", "        // transfer base tokens in if the base token is not ETH", "        if (baseToken != address(0)) {", "            // transfer base tokens in", "            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), baseTokenAmount);", "        }", "", "        emit Add(baseTokenAmount, fractionalTokenAmount, lpTokenAmount);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["  function burn(address to, uint256 liquidity) internal returns (uint256 amount0, uint256 amount1) {", "    uint120 _reserve0 = reserve0; // SLOAD", "    uint120 _reserve1 = reserve1; // SLOAD", "    uint256 _totalLiquidity = totalLiquidity; // SLOAD", "", "    amount0 = FullMath.mulDiv(_reserve0, liquidity, _totalLiquidity);", "    amount1 = FullMath.mulDiv(_reserve1, liquidity, _totalLiquidity);", "    if (amount0 == 0 && amount1 == 0) revert InsufficientOutputError();", "", "    if (amount0 > 0) SafeTransferLib.safeTransfer(token0, to, amount0);", "    if (amount1 > 0) SafeTransferLib.safeTransfer(token1, to, amount1);", "", "    // Extra check of the invariant", "    if (!invariant(_reserve0 - amount0, _reserve1 - amount1, _totalLiquidity - liquidity)) revert InvariantError();", "", "    reserve0 = _reserve0 - SafeCast.toUint120(amount0); // SSTORE", "    reserve1 = _reserve1 - SafeCast.toUint120(amount1); // SSTORE", "    totalLiquidity = _totalLiquidity - liquidity; // SSTORE", "", "    emit Burn(amount0, amount1, liquidity, to);", "  }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function mul(FixedPointInt memory a, FixedPointInt memory b)", "        internal", "        pure", "        returns (FixedPointInt memory)", "    {", "        return FixedPointInt((a.value * b.value) / _SCALING_FACTOR);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["    function calculateMultiplier(address account, bool enforce) public view returns (uint256) {", "        require(account != address(0), \"MuteAmplifier::calculateMultiplier: missing account\");", "", "        uint256 accountDTokenValue;", "", "        // zkSync block.number = L1 batch number. This at times is the same for a few minutes. To avoid breaking the call to the dMute contract", "        // we take the previous block into account", "        uint256 staked_block =  _userStakedBlock[account] == block.number ? _userStakedBlock[account] - 1 : _userStakedBlock[account];", "", "        if(staked_block != 0 && enforce)", "          accountDTokenValue = IDMute(dToken).getPriorVotes(account, staked_block);", "        else", "          accountDTokenValue = IDMute(dToken).getPriorVotes(account, block.number - 1);", "", "        if(accountDTokenValue == 0){", "          return _stakeDivisor;", "        }", "", "        uint256 stakeDifference = _stakeDivisor.sub(10 ** 18);", "", "        // ratio of dMute holdings to pool", "        uint256 tokenRatio = accountDTokenValue.mul(10**18).div(totalRewards);", "", "        stakeDifference = stakeDifference.mul(clamp_value(tokenRatio, 10**18)).div(10**18);", "", "        return _stakeDivisor.sub(stakeDifference);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function setLowestPrice(uint256 _newPrice) public onlyOwner {", "        lowestPrice = _newPrice;", "    }"], "ner_tags": [1, 0, 0]}
{"tokens": ["    function transferFrom(", "        address _from,", "        address _to,", "        uint256 _value", "    ) public override returns (bool) {", "        require(_allowances[_from][msg.sender] >= _value, \"Allowance too low\");", "", "        uint256 newValue = _allowances[_from][msg.sender] - _value;", "        _allowances[_from][msg.sender] = newValue;", "        emit Approval(_from, msg.sender, newValue);", "", "        uint256 creditAmount = creditsForTokenBalance(_value);", "        creditBalances[_from] = creditBalances[_from] - creditAmount;", "        creditBalances[_to] = creditBalances[_to] + creditAmount;", "        emit Transfer(_from, _to, _value);", "", "        return true;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function userAccrue(ERC20 producerToken, address user) public {", "        if (address(producerToken) == address(0)) revert ZeroAddress();", "        if (user == address(0)) revert ZeroAddress();", "", "        UserState storage u = producerTokens[producerToken].userStates[user];", "        uint256 balance = producerToken.balanceOf(user);", "", "        // Calculate the amount of rewards accrued by the user up to this call", "        uint256 rewards = u.rewards +", "            u.lastBalance *", "            (block.timestamp - u.lastUpdate);", "", "        u.lastUpdate = block.timestamp.safeCastTo32();", "        u.lastBalance = balance.safeCastTo224();", "        u.rewards = rewards;", "", "        emit UserAccrue(producerToken, user, block.timestamp, balance, rewards);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function initiateCloseOrder(", "        uint _id,", "        uint _percent,", "        PriceData calldata _priceData,", "        bytes calldata _signature,", "        address _stableVault,", "        address _outputToken,", "        address _trader", "    )", "        external", "    {", "        _validateProxy(_trader);", "        _checkDelay(_id, false);", "        _checkOwner(_id, _trader);", "        _checkVault(_stableVault, _outputToken);", "        IPosition.Trade memory _trade = position.trades(_id);", "        if (_trade.orderType != 0) revert(\"4\"); //IsLimit        ", "        (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);", "", "        if (_percent > DIVISION_CONSTANT || _percent == 0) revert BadClosePercent();", "        _closePosition(_id, _percent, _price, _stableVault, _outputToken, false); ", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function sellMalt(uint256 maxAmount)", "    external", "    onlyRoleMalt(STABILIZER_NODE_ROLE, \"Must have stabilizer node privs\")", "    onlyActive", "    returns (uint256 amountSold)", "  {", "    uint256[] memory traderIds = activeTraders;", "    uint256 length = traderIds.length;", "    uint256 profit;", "", "    uint256 totalMalt;", "    uint256[] memory traderMalt = new uint256[](length);", "", "    for (uint256 i; i < length; ++i) {", "      SwingTraderData memory trader = swingTraders[activeTraders[i]];", "", "      if (!trader.active) {", "        continue;", "      }", "", "      uint256 traderMaltBalance = malt.balanceOf(trader.traderContract);", "      totalMalt += traderMaltBalance;", "      traderMalt[i] = traderMaltBalance;", "    }", "", "    if (totalMalt == 0) {", "      return 0;", "    }", "", "    for (uint256 i; i < length; ++i) {", "      SwingTraderData memory trader = swingTraders[activeTraders[i]];", "      uint256 share = (maxAmount * traderMalt[i]) / totalMalt;", "", "      if (share == 0) {", "        continue;", "      }", "", "      if (amountSold + share > maxAmount) {", "        share = maxAmount - amountSold;", "      }", "", "      uint256 initialProfit = ISwingTrader(trader.traderContract).totalProfit();", "      try ISwingTrader(trader.traderContract).sellMalt(share) returns (", "        uint256 sold", "      ) {", "        uint256 finalProfit = ISwingTrader(trader.traderContract).totalProfit();", "        profit += (finalProfit - initialProfit);", "        amountSold += sold;", "      } catch {", "        // if it fails just continue", "      }", "", "      if (amountSold >= maxAmount) {", "        break;", "      }", "    }", "", "    if (amountSold + dustThreshold >= maxAmount) {", "      return maxAmount;", "    }", "", "    totalProfit += profit;", "", "    emit SellMalt(amountSold, profit);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": ["    function poolCheckpoint() public virtual override returns (bool) {", "        if (killed) {", "            return false;", "        }", "        uint256 currentRate = controller.inflationManager().getAmmRateForToken(ammToken);", "        // Update the integral of total token supply for the pool", "        uint256 timeElapsed = block.timestamp - uint256(ammLastUpdated);", "        if (totalStaked > 0) {", "            ammStakedIntegral += (currentRate * timeElapsed).scaledDiv(totalStaked);", "        }", "        ammLastUpdated = uint48(block.timestamp);", "        return true;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["\tfunction getExpectedAVAXRewardsAmt(uint256 duration, uint256 avaxAmt) public view returns (uint256) {", "\t\tProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));", "\t\tuint256 rate = dao.getExpectedAVAXRewardsRate();", "\t\treturn (avaxAmt.mulWadDown(rate) * duration) / 365 days;", "\t}"], "ner_tags": [0, 0, 0, 1, 0]}
{"tokens": ["    function _beforeTokenTransfer(", "        address from,", "        address to,", "        uint256 tokenId", "    ) internal override {", "        if (_dispatcherByProfile[tokenId] != address(0)) {", "            _setDispatcher(tokenId, address(0));", "        }", "        super._beforeTokenTransfer(from, to, tokenId);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function accrue() external returns (uint256 minted) {", "        if (block.timestamp - lastUpdate < updateDelay && !accessControlManager.isGovernorOrGuardian(msg.sender))", "            revert NotAllowed();", "        ITransmuter _transmuter = transmuter;", "        IAgToken _agToken = IAgToken(asset());", "        (uint64 collatRatio, uint256 stablecoinsIssued) = _transmuter.getCollateralRatio();", "        // It needs to deviate significantly (>0.1%) from the target in order to accrue", "        if (collatRatio > BASE_9 + BASE_6) {", "            // The surplus of profit minus a fee is distributed through this contract", "            minted = (collatRatio * stablecoinsIssued) / BASE_9 - stablecoinsIssued;", "            // Updating normalizer in order not to double count profits", "            _transmuter.updateNormalizer(minted, true);", "            uint256 surplusForProtocol = (minted * protocolSafetyFee) / BASE_9;", "            address _surplusManager = surplusManager;", "            _surplusManager = _surplusManager == address(0) ? address(_transmuter) : _surplusManager;", "            _agToken.mint(_surplusManager, surplusForProtocol);", "            uint256 surplus = minted - surplusForProtocol;", "            if (surplus != 0) {", "                // Adding new profits relaunches to zero the vesting period for the profits that were", "                // previously being vested", "                vestingProfit = (lockedProfit() + surplus);", "                lastUpdate = uint64(block.timestamp);", "                _agToken.mint(address(this), surplus);", "            }", "        } else if (collatRatio < BASE_9 - BASE_6) {", "            // If the protocol is under-collateralized, slashing the profits that are still being vested", "            uint256 missing = stablecoinsIssued - (collatRatio * stablecoinsIssued) / BASE_9;", "            uint256 currentLockedProfit = lockedProfit();", "            if (missing > currentLockedProfit) {", "                vestingProfit = 0;", "                missing = currentLockedProfit;", "            } else {", "                vestingProfit = currentLockedProfit - missing;", "                lastUpdate = uint64(block.timestamp);", "            }", "            if (missing > 0) {", "                _agToken.burnSelf(missing, address(this));", "                _transmuter.updateNormalizer(missing, false);", "            }", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function withdraw(uint256 _amount) external onlyOwner {", "        IsFrxEth(SFRX_ETH_ADDRESS).redeem(", "            _amount,", "            address(this),", "            address(this)", "        );", "        uint256 frxEthBalance = IERC20(FRX_ETH_ADDRESS).balanceOf(", "            address(this)", "        );", "        IsFrxEth(FRX_ETH_ADDRESS).approve(", "            FRX_ETH_CRV_POOL_ADDRESS,", "            frxEthBalance", "        );", "", "        uint256 minOut = (((ethPerDerivative(_amount) * _amount) / 10 ** 18) *", "            (10 ** 18 - maxSlippage)) / 10 ** 18;", "", "        IFrxEthEthPool(FRX_ETH_CRV_POOL_ADDRESS).exchange(", "            1,", "            0,", "            frxEthBalance,", "            minOut", "        );", "        // solhint-disable-next-line", "        (bool sent, ) = address(msg.sender).call{value: address(this).balance}(", "            \"\"", "        );", "        require(sent, \"Failed to send Ether\");", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function getAskOrderInfo(bytes memory params, address weth)", "        external", "        pure", "        override", "        returns (DataTypes.OrderInfo memory orderInfo)", "    {", "        (", "            OrderTypes.TakerOrder memory takerBid,", "            OrderTypes.MakerOrder memory makerAsk", "        ) = abi.decode(params, (OrderTypes.TakerOrder, OrderTypes.MakerOrder));", "        orderInfo.maker = makerAsk.signer;", "", "        OfferItem[] memory offer = new OfferItem[](1);", "        offer[0] = OfferItem(", "            ItemType.ERC721,", "            makerAsk.collection,", "            makerAsk.tokenId,", "            1,", "            1", "        );", "        orderInfo.offer = offer;", "", "        ConsiderationItem[] memory consideration = new ConsiderationItem[](1);", "", "        ItemType itemType = ItemType.ERC20;", "        address token = makerAsk.currency;", "        if (token == weth) {", "            itemType = ItemType.NATIVE;", "            token = address(0);", "        }", "        consideration[0] = ConsiderationItem(", "            itemType,", "            token,", "            0,", "            makerAsk.price, // TODO: take minPercentageToAsk into account", "            makerAsk.price,", "            payable(takerBid.taker)", "        );", "        orderInfo.id = abi.encodePacked(makerAsk.r, makerAsk.s, makerAsk.v);", "        orderInfo.consideration = consideration;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function onERC721Received(", "    address, /* operator_ */", "    address from_,", "    uint256 tokenId_,", "    bytes calldata // calldata data_", "  ) external override whenNotPaused returns (bytes4) {", "    CollateralStorage storage s = _loadCollateralSlot();", "    uint256 collateralId = msg.sender.computeId(tokenId_);", "", "    Asset memory incomingAsset = s.idToUnderlying[collateralId];", "    if (incomingAsset.tokenContract == address(0)) {", "      require(ERC721(msg.sender).ownerOf(tokenId_) == address(this));", "", "      if (s.clearingHouse[collateralId] == address(0)) {", "        address clearingHouse = ClonesWithImmutableArgs.clone(", "          s.ASTARIA_ROUTER.BEACON_PROXY_IMPLEMENTATION(),", "          abi.encodePacked(", "            address(s.ASTARIA_ROUTER),", "            uint8(IAstariaRouter.ImplementationType.ClearingHouse),", "            collateralId", "          )", "        );", "", "        s.clearingHouse[collateralId] = clearingHouse;", "      }", "      ERC721(msg.sender).safeTransferFrom(", "        address(this),", "        s.clearingHouse[collateralId],", "        tokenId_", "      );", "", "      if (msg.sender == address(this) || msg.sender == address(s.LIEN_TOKEN)) {", "        revert InvalidCollateral();", "      }", "", "      _mint(from_, collateralId);", "", "      s.idToUnderlying[collateralId] = Asset({", "        tokenContract: msg.sender,", "        tokenId: tokenId_", "      });", "", "      emit Deposit721(msg.sender, tokenId_, collateralId, from_);", "      return IERC721Receiver.onERC721Received.selector;", "    } else {", "      revert();", "    }", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function handlePayment(", "        uint256 gasUsed,", "        uint256 baseGas,", "        uint256 gasPrice,", "        uint256 tokenGasPriceFactor,", "        address gasToken,", "        address payable refundReceiver", "    ) private nonReentrant returns (uint256 payment) {", "        // uint256 startGas = gasleft();", "        // solhint-disable-next-line avoid-tx-origin", "        address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;", "        if (gasToken == address(0)) {", "            // For ETH we will only adjust the gas price to not be higher than the actual used gas price", "            payment = (gasUsed + baseGas) * (gasPrice < tx.gasprice ? gasPrice : tx.gasprice);", "            (bool success,) = receiver.call{value: payment}(\"\");", "            require(success, \"BSA011\");", "        } else {", "            payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);", "            require(transferToken(gasToken, receiver, payment), \"BSA012\");", "        }", "        // uint256 requiredGas = startGas - gasleft();", "        //console.log(\"hp %s\", requiredGas);", "    }"], "ner_tags": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function postIncomingMessages(", "        string calldata fromChainName,", "        uint256 startingCounter,", "        Message[] calldata messages,", "        Signature calldata signature ", "    )", "        external", "        override(IMessageProxy, MessageProxy)", "    {", "        bytes32 fromChainHash = keccak256(abi.encodePacked(fromChainName));", "        require(connectedChains[fromChainHash].inited, \"Chain is not initialized\");", "        require(messages.length <= MESSAGES_LENGTH, \"Too many messages\");", "        require(", "            _verifyMessages(", "                _hashedArray(messages, startingCounter, fromChainName),", "                signature", "            ),", "            \"Signature is not verified\"", "        );", "        require(", "            startingCounter == connectedChains[fromChainHash].incomingMessageCounter,", "            \"Starting counter is not qual to incoming message counter\");", "        for (uint256 i = 0; i < messages.length; i++) {", "            _callReceiverContract(fromChainHash, messages[i], startingCounter + 1);", "        }", "        connectedChains[fromChainHash].incomingMessageCounter += messages.length;", "        _topUpBalance();", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["  function drain(uint256 amount, address withdrawProxy)", "    public", "    onlyVault", "    returns (uint256)", "  {", "    uint256 balance = ERC20(asset()).balanceOf(address(this));", "    if (amount > balance) {", "      amount = balance;", "    }", "    ERC20(asset()).safeTransfer(withdrawProxy, amount);", "    return amount;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["    function initialize(", "        uint8 _topN,", "        uint _category,", "        uint _snapshot,", "        address[] calldata _assets,", "        uint[] calldata _capitalizations,", "        uint _totalCapitalization", "    ) external {", "        require(msg.sender == factory, \"TopNMarketCapIndex: FORBIDDEN\");", "", "        uint8 _totalWeight;", "        for (uint i; i < _assets.length; ++i) {", "            uint _i = _assets.length - 1 - i;", "            address asset = _assets[_i];", "            uint8 weight = _i == 0", "                ? IndexLibrary.MAX_WEIGHT - _totalWeight", "                : uint8((_capitalizations[_i] * type(uint8).max) / _totalCapitalization);", "            weightOf[asset] = weight;", "            require(asset != address(0), \"TopNMarketCapIndex: ZERO\");", "            if (weight > 0) {", "                assets.add(asset);", "                _totalWeight += weight;", "                emit UpdateAnatomy(asset, weight);", "            }", "        }", "        snapshot = _snapshot;", "        category = _category;", "        topN = _topN;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function redeem(uint256 principalAmount, address receiver, address holder) external override returns (uint256 underlyingAmount){", "        if (block.timestamp < maturity) {", "            revert Maturity(maturity);", "        }", "        if (holder == msg.sender) {", "            return IRedeemer(redeemer).authRedeem(underlying, maturity, msg.sender, receiver, principalAmount);", "        }", "        else {", "            require(_allowance[holder][msg.sender] >= underlyingAmount, 'not enough approvals');", "            return IRedeemer(redeemer).authRedeem(underlying, maturity, holder, receiver, principalAmount);     ", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["    function _combine(address _asset, uint256 _twap)", "        internal", "        view", "        returns (bool, uint256)", "    {", "        FeederRegistrar storage feederRegistrar = assetFeederMap[_asset];", "        uint256 currentBlock = block.number;", "        //first time just use the feeding value", "        if (assetPriceMap[_asset].twap == 0) {", "            return (true, _twap);", "        }", "        //use memory here so allocate with maximum length", "        uint256 feederSize = feeders.length;", "        uint256[] memory validPriceList = new uint256[](feederSize);", "        uint256 validNum = 0;", "        //aggeregate with price from all feeders", "        for (uint256 i = 0; i < feederSize; i++) {", "            PriceInformation memory priceInfo = feederRegistrar.feederPrice[", "                feeders[i]", "            ];", "            if (priceInfo.updatedAt > 0) {", "                uint256 diffBlock = currentBlock - priceInfo.updatedAt;", "                if (diffBlock <= config.expirationPeriod) {", "                    validPriceList[validNum] = priceInfo.twap;", "                    validNum++;", "                }", "            }", "        }", "        if (validNum < MIN_ORACLES_NUM) {", "            return (false, assetPriceMap[_asset].twap);", "        }", "        _quickSort(validPriceList, 0, int256(validNum - 1));", "        return (true, validPriceList[validNum / 2]);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["    function _decreaseLiquidity(", "        address user,", "        uint256 tokenId,", "        uint128 liquidityDecrease,", "        uint256 amount0Min,", "        uint256 amount1Min,", "        bool receiveEthAsWeth", "    ) internal returns (uint256 amount0, uint256 amount1) {", "        if (liquidityDecrease > 0) {", "            // amount0Min and amount1Min are price slippage checks", "            // if the amount received after burning is not greater than these minimums, transaction will fail", "            INonfungiblePositionManager.DecreaseLiquidityParams", "                memory params = INonfungiblePositionManager", "                    .DecreaseLiquidityParams({", "                        tokenId: tokenId,", "                        liquidity: liquidityDecrease,", "                        amount0Min: amount0Min,", "                        amount1Min: amount1Min,", "                        deadline: block.timestamp", "                    });", "", "            INonfungiblePositionManager(_underlyingAsset).decreaseLiquidity(", "                params", "            );", "        }", "", "        (", "            ,", "            ,", "            address token0,", "            address token1,", "            ,", "            ,", "            ,", "            ,", "            ,", "            ,", "            ,", "", "        ) = INonfungiblePositionManager(_underlyingAsset).positions(tokenId);", "", "        address weth = _addressesProvider.getWETH();", "        receiveEthAsWeth = (receiveEthAsWeth &&", "            (token0 == weth || token1 == weth));", "", "        INonfungiblePositionManager.CollectParams", "            memory collectParams = INonfungiblePositionManager.CollectParams({", "                tokenId: tokenId,", "                recipient: receiveEthAsWeth ? address(this) : user,", "                amount0Max: type(uint128).max,", "                amount1Max: type(uint128).max", "            });", "", "        (amount0, amount1) = INonfungiblePositionManager(_underlyingAsset)", "            .collect(collectParams);", "", "        if (receiveEthAsWeth) {", "            uint256 balanceWeth = IERC20(weth).balanceOf(address(this));", "            if (balanceWeth > 0) {", "                IWETH(weth).withdraw(balanceWeth);", "                _safeTransferETH(user, balanceWeth);", "            }", "", "            address pairToken = (token0 == weth) ? token1 : token0;", "            uint256 balanceToken = IERC20(pairToken).balanceOf(address(this));", "            if (balanceToken > 0) {", "                IERC20(pairToken).safeTransfer(user, balanceToken);", "            }", "        }", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _beforeTokenTransfer(address _from, address _to, uint256 _amount) internal override {", "        if (address(transferHookProcessor) != address(0)) ITransferHookProcessor(transferHookProcessor).beforeTokenTransfer(_from, _to, _amount);", "    }"], "ner_tags": [1, 1, 1]}
{"tokens": ["    function getPriceCanto(address token_) internal view returns(uint) {", "        erc20 token = erc20(token_);", "        address pair = pairFor(address(wcanto), address(token), false);", "        if (!isPair(pair)) {", "            return 0; // this pair does not exist with Canto", "        }", "        uint decimals = 10 ** token.decimals(); // get decimals of token", "        uint price = IBaseV1Pair(pair).quote(address(token), decimals, 8); // how much Canto is this asset worth?", "        return price * 1e18 / decimals; //return the scaled price", "    } "], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function _calculateAdditionalInterest() internal view returns (uint256) {", "        // Number of seconds since {accrue} was called", "        uint256 elapsedTime = block.timestamp - totalDebtAccruedAt;", "        if (elapsedTime == 0) {", "            return 0;", "        }", "", "        if (totalDebtAmount == 0) {", "            return 0;", "        }", "", "        // Accrue interest", "        uint256 interestPerYear = (totalDebtAmount *", "            settings.debtInterestApr.numerator) /", "            settings.debtInterestApr.denominator;", "        uint256 interestPerSec = interestPerYear / 365 days;", "", "        return elapsedTime * interestPerSec;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": ["    function setSubnodeOwner(", "        bytes32 parentNode,", "        string calldata label,", "        address owner,", "        uint32 fuses,", "        uint64 expiry", "    )", "        public", "        onlyTokenOwner(parentNode)", "        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))", "        returns (bytes32 node)", "    {", "        bytes32 labelhash = keccak256(bytes(label));", "        node = _makeNode(parentNode, labelhash);", "        _checkFusesAreSettable(node, fuses);", "        bytes memory name = _saveLabel(parentNode, node, label);", "        expiry = _checkParentFusesAndExpiry(parentNode, node, fuses, expiry);", "", "        if (ownerOf(uint256(node)) == address(0)) {", "            ens.setSubnodeOwner(parentNode, labelhash, address(this));", "            _wrap(node, name, owner, fuses, expiry);", "        } else {", "            _updateName(parentNode, node, label, owner, fuses, expiry);", "        }", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function accept(", "        uint256 proposalId,", "        uint256 snapIndex", "    ) public onlyDelegateCall returns (uint256 totalVotes) {", "        // Get the information about the proposal.", "        ProposalState storage info = _proposalStateByProposalId[proposalId];", "        ProposalStateValues memory values = info.values;", "", "        // Can only vote in certain proposal statuses.", "        {", "            ProposalStatus status = _getProposalStatus(values);", "            // Allow voting even if the proposal is passed/ready so it can", "            // potentially reach 100% consensus, which unlocks special", "            // behaviors for certain proposal types.", "            if (", "                status != ProposalStatus.Voting &&", "                status != ProposalStatus.Passed &&", "                status != ProposalStatus.Ready", "            ) {", "                revert BadProposalStatusError(status);", "            }", "        }", "", "        // Cannot vote twice.", "        if (info.hasVoted[msg.sender]) {", "            revert AlreadyVotedError(msg.sender);", "        }", "        // Mark the caller as having voted.", "        info.hasVoted[msg.sender] = true;", "", "        // Increase the total votes that have been cast on this proposal.", "        uint96 votingPower = getVotingPowerAt(msg.sender, values.proposedTime - 1, snapIndex);", "        values.votes += votingPower;", "        info.values = values;", "        emit ProposalAccepted(proposalId, msg.sender, votingPower);", "", "        // Update the proposal status if it has reached the pass threshold.", "        if (", "            values.passedTime == 0 &&", "            _areVotesPassing(", "                values.votes,", "                _governanceValues.totalVotingPower,", "                _governanceValues.passThresholdBps", "            )", "        ) {", "            info.values.passedTime = uint40(block.timestamp);", "            emit ProposalPassed(proposalId);", "        }", "        return values.votes;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function setFeeManager(address _feeM) external {", "        require(msg.sender == feeManager, \"!auth\");", "        feeManager = _feeM;", "        emit FeeManagerUpdated(_feeM);", "    }"], "ner_tags": [1, 0, 0, 0, 0]}
{"tokens": ["    function transferFrom(", "        address _from,", "        address _to,", "        uint _shares", "    ) external override nonReentrant onlyRole(ORDERER_ROLE) {", "        _transfer(_from, _to, _shares);", "    }"], "ner_tags": [0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["    function claimableBalance(address recipient) public view returns (uint256) {", "        uint256 locked = vesting[recipient].lockedAmounts;", "        uint256 claimed = vesting[recipient].claimedAmounts;", "        if (block.timestamp >= vesting[recipient].unlockEnd) {", "            return locked - claimed;", "        }", "        return", "            ((locked * (block.timestamp - vesting[recipient].unlockBegin)) /", "                (vesting[recipient].unlockEnd -", "                    vesting[recipient].unlockBegin)) - claimed;", "    }"], "ner_tags": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function recordMintReservesFor(uint256 _tierId, uint256 _count)", "    external", "    override", "    returns (uint256[] memory tokenIds)", "  {", "    // Get a reference to the tier.", "    JBStored721Tier storage _storedTier = _storedTierOf[msg.sender][_tierId];", "", "    // Get a reference to the number of reserved tokens mintable for the tier.", "    uint256 _numberOfReservedTokensOutstanding = _numberOfReservedTokensOutstandingFor(", "      msg.sender,", "      _tierId,", "      _storedTier", "    );", "", "    // Can't mint more reserves than expected.", "    if (_count > _numberOfReservedTokensOutstanding) revert INSUFFICIENT_RESERVES();", "", "    // Increment the number of reserved tokens minted.", "    numberOfReservesMintedFor[msg.sender][_tierId] += _count;", "", "    // Initialize an array with the appropriate length.", "    tokenIds = new uint256[](_count);", "", "    // Keep a reference to the number of burned in the tier.", "    uint256 _numberOfBurnedFromTier = numberOfBurnedFor[msg.sender][_tierId];", "", "    for (uint256 _i; _i < _count; ) {", "      // Generate the tokens.", "      tokenIds[_i] = _generateTokenId(", "        _tierId,", "        _storedTier.initialQuantity - --_storedTier.remainingQuantity + _numberOfBurnedFromTier", "      );", "", "      unchecked {", "        ++_i;", "      }", "    }", "  }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function issue(", "        ISetToken _setToken,", "        uint256 _quantity,", "        address _to", "    )", "        external", "        virtual", "        nonReentrant", "        onlyValidAndInitializedSet(_setToken)", "    {", "        require(_quantity > 0, \"Issue quantity must be > 0\");", "", "        address hookContract = _callManagerPreIssueHooks(_setToken, _quantity, msg.sender, _to);", "", "        _callModulePreIssueHooks(_setToken, _quantity);", "", "        (", "            uint256 quantityWithFees,", "            uint256 managerFee,", "            uint256 protocolFee", "        ) = calculateTotalFees(_setToken, _quantity, true);", "", "        (", "            address[] memory components,", "            uint256[] memory equityUnits,", "            uint256[] memory debtUnits", "        ) = _calculateRequiredComponentIssuanceUnits(_setToken, quantityWithFees, true);", "", "        _resolveEquityPositions(_setToken, quantityWithFees, _to, true, components, equityUnits);", "        _resolveDebtPositions(_setToken, quantityWithFees, true, components, debtUnits);", "        _resolveFees(_setToken, managerFee, protocolFee);", "", "        _setToken.mint(_to, _quantity);", "", "        emit SetTokenIssued(", "            _setToken,", "            msg.sender,", "            _to,", "            hookContract,", "            _quantity,", "            managerFee,", "            protocolFee", "        );", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function safeTransferFrom(", "    address from,", "    address to,", "    uint256 tokenId,", "    bytes memory data", "  ) public payable {", "    require(_isApproved(msg.sender, tokenId), \"ERC721: not approved sender\");", "    if (_isEventRegistered(HolographERC721Event.beforeSafeTransfer)) {", "      require(SourceERC721().beforeSafeTransfer(from, to, tokenId, data));", "    }", "    _transferFrom(from, to, tokenId);", "    if (_isContract(to)) {", "      require(", "        (ERC165(to).supportsInterface(ERC165.supportsInterface.selector) &&", "          ERC165(to).supportsInterface(ERC721TokenReceiver.onERC721Received.selector) &&", "          ERC721TokenReceiver(to).onERC721Received(address(this), from, tokenId, data) ==", "          ERC721TokenReceiver.onERC721Received.selector),", "        \"ERC721: onERC721Received fail\"", "      );", "    }", "    if (_isEventRegistered(HolographERC721Event.afterSafeTransfer)) {", "      require(SourceERC721().afterSafeTransfer(from, to, tokenId, data));", "    }", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function rawCall(", "        uint256 _gas,", "        address _address,", "        uint256 _value,", "        bytes calldata _data", "    ) internal returns (bool success) {", "        if (_value == 0) {", "            _loadFarCallABIIntoActivePtr(_gas, _data, false, false);", "", "            address callAddr = RAW_FAR_CALL_BY_REF_CALL_ADDRESS;", "            assembly {", "                success := call(_address, callAddr, 0, 0, 0xFFFF, 0, 0)", "            }", "        } else {", "            _loadFarCallABIIntoActivePtr(_gas, _data, false, true);", "", "            // If there is provided `msg.value` call the `MsgValueSimulator` to forward ether.", "            address msgValueSimulator = MSG_VALUE_SYSTEM_CONTRACT;", "            address callAddr = SYSTEM_CALL_BY_REF_CALL_ADDRESS;", "            // We need to supply the mask to the MsgValueSimulator to denote", "            // that the call should be a system one.", "            uint256 forwardMask = MSG_VALUE_SIMULATOR_IS_SYSTEM_BIT;", "", "            assembly {", "                success := call(msgValueSimulator, callAddr, _value, _address, 0xFFFF, forwardMask, 0)", "            }", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": ["  function _handlePayment(uint256 _amount) internal {", "    address recipient = royaltyVaultInitialized()", "      ? royaltyVault", "      : address(this);", "    payableToken.transferFrom(msg.sender, recipient, _amount);", "    emit NewPayment(msg.sender, recipient, _amount, royaltyVaultInitialized());", "  }"], "ner_tags": [0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["    function _afterTokenTransfer(", "        address _from,", "        address _to,", "        uint256 _tokenId", "    ) internal override {", "        // Transfer 1 vote from the sender to the recipient", "        _moveDelegateVotes(_from, _to, 1);", "", "        super._afterTokenTransfer(_from, _to, _tokenId);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["    function burn(address _address, uint256 _amount)", "        external", "        onlyRole(MINTER_BURNER_ROLE)", "    {", "        _burn(_address, _amount);", "    }"], "ner_tags": [0, 0, 1, 0, 0, 0]}
{"tokens": ["    function lockFor(", "        address _account,", "        uint256 _nftIndex,", "        uint256 _lockAmount", "    ) external onlyOwner nonReentrant {", "        jpeg.safeTransferFrom(_account, address(this), _lockAmount);", "", "        positions[_nftIndex] = LockPosition({", "            owner: _account,", "            unlockAt: block.timestamp + lockTime,", "            lockAmount: _lockAmount", "        });", "", "        emit Lock(_account, _nftIndex, _lockAmount);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": ["    function withdraw(uint256 vaultId) external nonReentrant {", "        // vaultId should always be odd", "        require(vaultId % 2 != 0, \"Not vault type\");", "", "        // check owner", "        require(msg.sender == ownerOf(vaultId), \"You are not the owner\");", "", "        Vault memory vault = _vaults[vaultId];", "", "        // check vault can be withdrawn", "        require(vault.isExercised == false, \"Vault already exercised\");", "        require(vault.isWithdrawing, \"Vault not in withdrawable state\");", "        require(block.timestamp > vault.currentExpiration, \"Option still active\");", "", "        // burn option and vault", "        uint256 optionId = vaultId + 1;", "        _burn(optionId);", "        _burn(vaultId);", "", "        emit Withdrawal(vaultId, msg.sender);", "", "        // claim any ETH still in the account", "        harvest();", "", "        // transfer the NFTs or ERC20s back to the owner", "        vault.tokenType == TokenType.ERC721", "            ? ERC721(vault.token).transferFrom(address(this), msg.sender, vault.tokenIdOrAmount)", "            : ERC20(vault.token).safeTransfer(msg.sender, vault.tokenIdOrAmount);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["    function setSubnodeRecord(", "        bytes32 parentNode,", "        string memory label,", "        address owner,", "        address resolver,", "        uint64 ttl,", "        uint32 fuses,", "        uint64 expiry", "    )", "        public", "        onlyTokenOwner(parentNode)", "        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))", "        returns (bytes32 node)", "    {", "        bytes32 labelhash = keccak256(bytes(label));", "        node = _makeNode(parentNode, labelhash);", "        _checkFusesAreSettable(node, fuses);", "        _saveLabel(parentNode, node, label);", "        expiry = _checkParentFusesAndExpiry(parentNode, node, fuses, expiry);", "        if (ownerOf(uint256(node)) == address(0)) {", "            ens.setSubnodeRecord(", "                parentNode,", "                labelhash,", "                address(this),", "                resolver,", "                ttl", "            );", "            _storeNameAndWrap(parentNode, node, label, owner, fuses, expiry);", "        } else {", "            ens.setSubnodeRecord(", "                parentNode,", "                labelhash,", "                address(this),", "                resolver,", "                ttl", "            );", "            _updateName(parentNode, node, label, owner, fuses, expiry);", "        }", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function proposeNewVaultImplementation(address _newVaultImplementation) external override onlyRole(IMPLEMENTER_ROLE) {", "        pendingVaultImplementation = _newVaultImplementation;", "        vaultUpdateTime = block.timestamp + UPDATE_TIME;", "    }"], "ner_tags": [1, 1, 1, 1]}
{"tokens": ["    function increasePledgeRewardPerVote(", "        uint256 pledgeId,", "        uint256 newRewardPerVote,", "        uint256 maxTotalRewardAmount,", "        uint256 maxFeeAmount", "    ) external whenNotPaused nonReentrant {", "        if(pledgeId >= pledgesIndex()) revert Errors.InvalidPledgeID();", "        address creator = pledgeOwner[pledgeId];", "        if(msg.sender != creator) revert Errors.NotPledgeCreator();", "", "        Pledge storage pledgeParams = pledges[pledgeId];", "        if(pledgeParams.closed) revert Errors.PledgeClosed();", "        if(pledgeParams.endTimestamp <= block.timestamp) revert Errors.ExpiredPledge();", "", "        uint256 oldRewardPerVote = pledgeParams.rewardPerVote;", "        if(newRewardPerVote <= oldRewardPerVote) revert Errors.RewardsPerVotesTooLow();", "        uint256 remainingDuration = pledgeParams.endTimestamp - block.timestamp;", "        uint256 rewardPerVoteDiff = newRewardPerVote - oldRewardPerVote;", "        uint256 totalRewardAmount = (rewardPerVoteDiff * pledgeParams.votesDifference * remainingDuration) / UNIT;", "        uint256 feeAmount = (totalRewardAmount * protocalFeeRatio) / MAX_PCT ;", "        if(totalRewardAmount > maxTotalRewardAmount) revert Errors.IncorrectMaxTotalRewardAmount();", "        if(feeAmount > maxFeeAmount) revert Errors.IncorrectMaxFeeAmount();", "", "        // Pull all the rewards in this contract", "        IERC20(pledgeParams.rewardToken).safeTransferFrom(creator, address(this), totalRewardAmount);", "        // And transfer the fees from the Pledge creator to the Chest contract", "        IERC20(pledgeParams.rewardToken).safeTransferFrom(creator, chestAddress, feeAmount);", "", "        // Update the Pledge parameters in storage", "        pledgeParams.rewardPerVote = newRewardPerVote;", "", "        pledgeAvailableRewardAmounts[pledgeId] += totalRewardAmount;", "", "        emit IncreasePledgeRewardPerVote(pledgeId, oldRewardPerVote, newRewardPerVote);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function initialize(", "        string memory _tokenName, ", "        string memory _tokenSymbol, ", "        address _assetAddress,", "        uint256 _assetID,", "        address _curator,", "        uint256 _initialTokenSupply,", "        uint256 _initialTokenPrice,", "        uint256 _minBuyoutTime", "    ) external override initializer payable {", "        uint32 _secondaryReserveRatio = uint32((msg.value * SCALE * 1e18) / (_initialTokenSupply * _initialTokenPrice));", "        require(_secondaryReserveRatio <= primaryReserveRatio, \"NibblVault: Excess initial funds\");", "        require(_secondaryReserveRatio >= MIN_SECONDARY_RESERVE_RATIO, \"NibblVault: secResRatio too low\");", "        INIT_EIP712(\"NibblVault\", \"1\");", "        __ERC20_init(_tokenName, _tokenSymbol);", "        unlocked = 1;", "        initialTokenPrice=_initialTokenPrice;", "        factory = payable(msg.sender);", "        assetAddress = _assetAddress;", "        assetID = _assetID;", "        curator = _curator;", "        initialTokenSupply = _initialTokenSupply;", "        uint _primaryReserveBalance = (primaryReserveRatio * _initialTokenSupply * _initialTokenPrice) / (SCALE * 1e18);", "        primaryReserveBalance = _primaryReserveBalance;", "        fictitiousPrimaryReserveBalance = _primaryReserveBalance;", "        secondaryReserveBalance = msg.value;", "        secondaryReserveRatio = _secondaryReserveRatio;", "        //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator", "        curatorFee = (((_secondaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO) * MIN_CURATOR_FEE) / (primaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO)) + MIN_CURATOR_FEE; //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator", "        minBuyoutTime = _minBuyoutTime;", "        _mint(_curator, _initialTokenSupply);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function claimRewardsToSelf(", "    address[] calldata assets,", "    uint256 amount,", "    address reward", "  ) external override returns (uint256) {", "    return _claimRewards(assets, amount, msg.sender, msg.sender, msg.sender, reward);", "  }"], "ner_tags": [1, 1, 1, 1, 1, 1, 0]}
{"tokens": ["    function mint(address _account, uint256 _amount) external onlyMinter {", "        _mint(_account, _amount);", "    }"], "ner_tags": [1, 1, 1]}
{"tokens": ["    function _fundingVote(", "        QuarterlyDistribution storage currentDistribution_,", "        Proposal storage proposal_,", "        address account_,", "        QuadraticVoter storage voter_,", "        FundingVoteParams memory voteParams_", "    ) internal returns (uint256 incrementalVotesUsed_) {", "        uint8  support = 1;", "        uint256 proposalId = proposal_.proposalId;", "", "        // determine if voter is voting for or against the proposal", "        voteParams_.votesUsed < 0 ? support = 0 : support = 1;", "", "        uint128 votingPower = voter_.votingPower;", "", "        // the total amount of voting power used by the voter before this vote executes", "        uint128 voterPowerUsedPreVote = votingPower - voter_.remainingVotingPower;", "", "        FundingVoteParams[] storage votesCast = voter_.votesCast;", "", "        // check that the voter hasn't already voted on a proposal by seeing if it's already in the votesCast array ", "        int256 voteCastIndex = _findProposalIndexOfVotesCast(proposalId, votesCast);", "", "        // voter had already cast a funding vote on this proposal", "        if (voteCastIndex != -1) {", "            // since we are converting from int256 to uint256, we can safely assume that the value will not overflow", "            FundingVoteParams storage existingVote = votesCast[uint256(voteCastIndex)];", "", "            // can't change the direction of a previous vote", "            if (support == 0 && existingVote.votesUsed > 0 || support == 1 && existingVote.votesUsed < 0) {", "                // if the vote is in the opposite direction of a previous vote,", "                // and the proposal is already in the votesCast array, revert can't change direction", "                revert FundingVoteWrongDirection();", "            }", "            else {", "                // update the votes cast for the proposal", "                existingVote.votesUsed += voteParams_.votesUsed;", "            }", "        }", "        // first time voting on this proposal, add the newly cast vote to the voter's votesCast array", "        else {", "            votesCast.push(voteParams_);", "        }", "", "        // calculate the cumulative cost of all votes made by the voter", "        // and check that attempted votes cast doesn't overflow uint128", "        uint256 sumOfTheSquareOfVotesCast = _sumSquareOfVotesCast(votesCast);", "        if (sumOfTheSquareOfVotesCast > type(uint128).max) revert InsufficientVotingPower();", "        uint128 cumulativeVotePowerUsed = SafeCast.toUint128(sumOfTheSquareOfVotesCast);", "", "        // check that the voter has enough voting power remaining to cast the vote", "        if (cumulativeVotePowerUsed > votingPower) revert InsufficientVotingPower();", "", "        // update voter voting power accumulator", "        voter_.remainingVotingPower = votingPower - cumulativeVotePowerUsed;", "", "        // calculate the change in voting power used by the voter in this vote in order to accurately track the total voting power used in the funding stage", "        // since we are moving from uint128 to uint256, we can safely assume that the value will not overflow", "        uint256 incrementalVotingPowerUsed = uint256(cumulativeVotePowerUsed - voterPowerUsedPreVote);", "", "        // update accumulator for total voting power used in the funding stage in order to calculate delegate rewards", "        currentDistribution_.fundingVotePowerCast += incrementalVotingPowerUsed;", "", "        // update proposal vote tracking", "        proposal_.fundingVotesReceived += SafeCast.toInt128(voteParams_.votesUsed);", "", "        // the incremental additional votes cast on the proposal to be used as a return value and emit value", "        incrementalVotesUsed_ = SafeCast.toUint256(Maths.abs(voteParams_.votesUsed));", "", "        // emit VoteCast instead of VoteCastWithParams to maintain compatibility with Tally", "        // emits the amount of incremental votes cast for the proposal, not the voting power cost or total votes on a proposal", "        emit VoteCast(", "            account_,", "            proposalId,", "            support,", "            incrementalVotesUsed_,", "            \"\"", "        );", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function getAssetPrice(address asset)", "        public", "        view", "        override", "        returns (uint256)", "    {", "        if (asset == BASE_CURRENCY) {", "            return BASE_CURRENCY_UNIT;", "        }", "", "        uint256 price = 0;", "        IEACAggregatorProxy source = IEACAggregatorProxy(assetsSources[asset]);", "        if (address(source) != address(0)) {", "            price = uint256(source.latestAnswer());", "        }", "        if (price == 0 && address(_fallbackOracle) != address(0)) {", "            price = _fallbackOracle.getAssetPrice(asset);", "        }", "", "        require(price != 0, Errors.ORACLE_PRICE_NOT_READY);", "        return price;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function _requestRoll() internal {", "        // Chainlink request cannot be currently in flight.", "        // Request is cleared in re-roll if conditions are correct.", "        if (request.currentChainlinkRequestId != 0) {", "            revert REQUEST_IN_FLIGHT();", "        }", "", "        // If the number has been drawn and", "        if (", "            request.hasChosenRandomNumber &&", "            // Draw timelock not yet used", "            request.drawTimelock != 0 &&", "            request.drawTimelock > block.timestamp", "        ) {", "            revert STILL_IN_WAITING_PERIOD_BEFORE_REDRAWING();", "        }", "", "        // Setup re-draw timelock", "        request.drawTimelock = block.timestamp + settings.drawBufferTime;", "", "        // Request first random round", "        request.currentChainlinkRequestId = coordinator.requestRandomWords({", "            keyHash: settings.keyHash,", "            subId: settings.subscriptionId,", "            minimumRequestConfirmations: minimumRequestConfirmations,", "            callbackGasLimit: callbackGasLimit,", "            numWords: wordsRequested", "        });", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": ["    function withdrawInternal(address from, address to, uint amount) internal {", "        uint limit = getWithdrawalLimitInternal(from);", "        require(limit >= amount, \"Insufficient withdrawal limit\");", "        IEscrow escrow = getEscrow(from);", "        escrow.pay(to, amount);", "        emit Withdraw(from, to, amount);", "    }"], "ner_tags": [0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["  function matchOneToOneOrders(", "    OrderTypes.MakerOrder[] calldata makerOrders1,", "    OrderTypes.MakerOrder[] calldata makerOrders2", "  ) external {", "    uint256 startGas = gasleft();", "    uint256 numMakerOrders = makerOrders1.length;", "    require(msg.sender == MATCH_EXECUTOR, 'OME');", "    require(numMakerOrders == makerOrders2.length, 'mismatched lengths');", "", "    // the below 3 variables are copied to memory once to save on gas", "    // an SLOAD costs minimum 100 gas where an MLOAD only costs minimum 3 gas", "    // since these values won't change during function execution, we can save on gas by copying them to memory once", "    // instead of SLOADing once for each loop iteration", "    uint16 protocolFeeBps = PROTOCOL_FEE_BPS;", "    uint32 wethTransferGasUnits = WETH_TRANSFER_GAS_UNITS;", "    address weth = WETH;", "    for (uint256 i = 0; i < numMakerOrders; ) {", "      uint256 startGasPerOrder = gasleft() + ((startGas - gasleft()) / numMakerOrders);", "      require(_complications.contains(makerOrders1[i].execParams[0]), 'invalid complication');", "      (bool canExec, uint256 execPrice) = IComplication(makerOrders1[i].execParams[0]).canExecMatchOneToOne(", "        makerOrders1[i],", "        makerOrders2[i]", "      );", "      require(canExec, 'cannot execute');", "      _matchOneToOneOrders(", "        makerOrders1[i],", "        makerOrders2[i],", "        startGasPerOrder,", "        execPrice,", "        protocolFeeBps,", "        wethTransferGasUnits,", "        weth", "      );", "      unchecked {", "        ++i;", "      }", "    }", "  }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function tokenURI(uint256 _id) public view override returns (string memory) {", "        if (_ownerOf[_id] == address(0)) revert TokenNotMinted(_id);", "        string memory bioText = bio[_id];", "        bytes memory bioTextBytes = bytes(bioText);", "        uint lengthInBytes = bioTextBytes.length;", "        // Insert a new line after 40 characters, taking into account unicode character", "        uint lines = (lengthInBytes - 1) / 40 + 1;", "        string[] memory strLines = new string[](lines);", "        bool prevByteWasContinuation;", "        uint256 insertedLines;", "        // Because we do not split on zero-width joiners, line in bytes can technically be much longer. Will be shortened to the needed length afterwards", "        bytes memory bytesLines = new bytes(80);", "        uint bytesOffset;", "        for (uint i; i < lengthInBytes; ++i) {", "            bytes1 character = bioTextBytes[i];", "            bytesLines[bytesOffset] = character;", "            bytesOffset++;", "            if ((i > 0 && (i + 1) % 40 == 0) || prevByteWasContinuation || i == lengthInBytes - 1) {", "                bytes1 nextCharacter;", "                if (i != lengthInBytes - 1) {", "                    nextCharacter = bioTextBytes[i + 1];", "                }", "                if (nextCharacter & 0xC0 == 0x80) {", "                    // Unicode continuation byte, top two bits are 10", "                    prevByteWasContinuation = true;", "                } else {", "                    // Do not split when the prev. or next character is a zero width joiner. Otherwise, \ud83d\udc68\u200d\ud83d\udc67\u200d\ud83d\udc66 could become \ud83d\udc68>\u200d\ud83d\udc67\u200d\ud83d\udc66", "                    // Furthermore, do not split when next character is skin tone modifier to avoid \ud83e\udd26\u200d\u2642\ufe0f\\n\ud83c\udffb", "                    if (", "                        // Note that we do not need to check i < lengthInBytes - 4, because we assume that it's a valid UTF8 string and these prefixes imply that another byte follows", "                        (nextCharacter == 0xE2 && bioTextBytes[i + 2] == 0x80 && bioTextBytes[i + 3] == 0x8D) ||", "                        (nextCharacter == 0xF0 &&", "                            bioTextBytes[i + 2] == 0x9F &&", "                            bioTextBytes[i + 3] == 0x8F &&", "                            uint8(bioTextBytes[i + 4]) >= 187 &&", "                            uint8(bioTextBytes[i + 4]) <= 191) ||", "                        (i >= 2 &&", "                            bioTextBytes[i - 2] == 0xE2 &&", "                            bioTextBytes[i - 1] == 0x80 &&", "                            bioTextBytes[i] == 0x8D)", "                    ) {", "                        prevByteWasContinuation = true;", "                        continue;", "                    }", "                    assembly {", "                        mstore(bytesLines, bytesOffset)", "                    }", "                    strLines[insertedLines++] = string(bytesLines);", "                    bytesLines = new bytes(80);", "                    prevByteWasContinuation = false;", "                    bytesOffset = 0;", "                }", "            }", "        }", "        string", "            memory svg = '<svg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"xMinYMin meet\" viewBox=\"0 0 400 100\"><style>text { font-family: sans-serif; font-size: 12px; }</style>';", "        string memory text = '<text x=\"50%\" y=\"50%\" dominant-baseline=\"middle\" text-anchor=\"middle\">';", "        for (uint i; i < lines; ++i) {", "            text = string.concat(text, '<tspan x=\"50%\" dy=\"20\">', strLines[i], \"</tspan>\");", "        }", "        string memory json = Base64.encode(", "            bytes(", "                string.concat(", "                    '{\"name\": \"Bio #',", "                    LibString.toString(_id),", "                    '\", \"description\": \"',", "                    bioText,", "                    '\", \"image\": \"data:image/svg+xml;base64,',", "                    Base64.encode(bytes(string.concat(svg, text, \"</text></svg>\"))),", "                    '\"}'", "                )", "            )", "        );", "        return string(abi.encodePacked(\"data:application/json;base64,\", json));", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0]}
{"tokens": ["    function borrowGivenDebtETHCollateral(", "        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,", "        IConvenience convenience,", "        IFactory factory,", "        IWETH weth,", "        IBorrow.BorrowGivenDebtETHCollateral calldata params", "    )", "        external", "        returns (", "            uint256 assetOut,", "            uint256 id,", "            IPair.Due memory dueOut", "        )", "    {", "        uint112 maxCollateral = MsgValue.getUint112();", "", "        (assetOut, id, dueOut) = _borrowGivenDebt(", "            natives,", "            IBorrow._BorrowGivenDebt(", "                convenience,", "                factory,", "                params.asset,", "                weth,", "                params.maturity,", "                address(this),", "                params.assetTo,", "                params.dueTo,", "                params.assetOut,", "                params.debtIn,", "                maxCollateral,", "                params.deadline", "            )", "        );", "", "        if (maxCollateral > dueOut.collateral) {", "            uint256 excess;", "            unchecked {", "                excess -= dueOut.collateral;", "            }", "            ETH.transfer(payable(msg.sender), excess);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": ["    function _createClaimUnchecked(", "            address _recipient, ", "            uint40 _startTimestamp, ", "            uint40 _endTimestamp, ", "            uint40 _cliffReleaseTimestamp, ", "            uint40 _releaseIntervalSecs, ", "            uint112 _linearVestAmount, ", "            uint112 _cliffAmount", "                ) private  hasNoClaim(_recipient) {", "", "        require(_recipient != address(0), \"INVALID_ADDRESS\");", "        require(_linearVestAmount + _cliffAmount > 0, \"INVALID_VESTED_AMOUNT\"); // Actually only one of linearvested/cliff amount must be 0, not necessarily both", "        require(_startTimestamp > 0, \"INVALID_START_TIMESTAMP\");", "        // Do we need to check whether _startTimestamp is greater than the current block.timestamp? ", "        // Or do we allow schedules that started in the past? ", "        // -> Conclusion: we want to allow this, for founders that might have forgotten to add some users, or to avoid issues with transactions not going through because of discoordination between block.timestamp and sender's local time", "        // require(_endTimestamp > 0, \"_endTimestamp must be valid\"); // not necessary because of the next condition (transitively)", "        require(_startTimestamp < _endTimestamp, \"INVALID_END_TIMESTAMP\"); // _endTimestamp must be after _startTimestamp", "        require(_releaseIntervalSecs > 0, \"INVALID_RELEASE_INTERVAL\");", "        require((_endTimestamp - _startTimestamp) % _releaseIntervalSecs == 0, \"INVALID_INTERVAL_LENGTH\");", "", "        // Potential TODO: sanity check, if _linearVestAmount == 0, should we perhaps force that start and end ts are the same?", "", "        // No point in allowing cliff TS without the cliff amount or vice versa.", "        // Both or neither of _cliffReleaseTimestamp and _cliffAmount must be set. If cliff is set, _cliffReleaseTimestamp must be before or at the _startTimestamp", "        require( ", "            (", "                _cliffReleaseTimestamp > 0 && ", "                _cliffAmount > 0 && ", "                _cliffReleaseTimestamp <= _startTimestamp", "            ) || (", "                _cliffReleaseTimestamp == 0 && ", "                _cliffAmount == 0", "        ), \"INVALID_CLIFF\");", "", "        Claim memory _claim = Claim({", "            startTimestamp: _startTimestamp,", "            endTimestamp: _endTimestamp,", "            cliffReleaseTimestamp: _cliffReleaseTimestamp,", "            releaseIntervalSecs: _releaseIntervalSecs,", "            cliffAmount: _cliffAmount,", "            linearVestAmount: _linearVestAmount,", "            amountWithdrawn: 0,", "            isActive: true", "        });", "        // Our total allocation is simply the full sum of the two amounts, _cliffAmount + _linearVestAmount", "        // Not necessary to use the more complex logic from _baseVestedAmount", "        uint112 allocatedAmount = _cliffAmount + _linearVestAmount;", "", "        // Still no effects up to this point (and tokenAddress is selected by contract deployer and is immutable), so no reentrancy risk ", "        require(tokenAddress.balanceOf(address(this)) >= numTokensReservedForVesting + allocatedAmount, \"INSUFFICIENT_BALANCE\");", "", "        // Done with checks", "", "        // Effects limited to lines below", "        claims[_recipient] = _claim; // store the claim", "        numTokensReservedForVesting += allocatedAmount; // track the allocated amount", "        vestingRecipients.push(_recipient); // add the vesting recipient to the list", "        emit ClaimCreated(_recipient, _claim); // let everyone know", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["    function increaseAmount(uint256 _value)", "        external", "        override", "        nonReentrant", "        checkBlocklist", "    {", "        LockedBalance memory locked_ = locked[msg.sender];", "        // Validate inputs", "        require(_value > 0, \"Only non zero amount\");", "        require(locked_.amount > 0, \"No lock\");", "        require(locked_.end > block.timestamp, \"Lock expired\");", "        // Update lock", "        address delegatee = locked_.delegatee;", "        uint256 unlockTime = locked_.end;", "        LockAction action = LockAction.INCREASE_AMOUNT;", "        LockedBalance memory newLocked;", "        if (delegatee == msg.sender) {", "            // Undelegated lock", "            action = LockAction.INCREASE_AMOUNT_AND_DELEGATION;", "            newLocked = _copyLock(locked_);", "            newLocked.amount += int128(int256(_value));", "            newLocked.delegated += int128(int256(_value));", "            locked[msg.sender] = newLocked;", "        } else {", "            // Delegated lock, update sender's lock first", "            locked_.amount += int128(int256(_value));", "            locked[msg.sender] = locked_;", "            // Then, update delegatee's lock and voting power (checkpoint)", "            locked_ = locked[delegatee];", "            require(locked_.amount > 0, \"Delegatee has no lock\");", "            require(locked_.end > block.timestamp, \"Delegatee lock expired\");", "            newLocked = _copyLock(locked_);", "            newLocked.delegated += int128(int256(_value));", "            locked[delegatee] = newLocked;", "            emit Deposit(", "                delegatee,", "                _value,", "                newLocked.end,", "                LockAction.DELEGATE,", "                block.timestamp", "            );", "        }", "        // Checkpoint only for delegatee", "        _checkpoint(delegatee, locked_, newLocked);", "        // Deposit locked tokens", "        require(", "            token.transferFrom(msg.sender, address(this), _value),", "            \"Transfer failed\"", "        );", "        emit Deposit(msg.sender, _value, unlockTime, action, block.timestamp);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0]}
{"tokens": ["    function _handleOpenFees(", "        uint _asset,", "        uint _positionSize,", "        address _trader,", "        address _tigAsset,", "        bool _isBot", "    )", "        internal", "        returns (uint _feePaid)", "    {", "        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);", "        Fees memory _fees = openFees;", "        unchecked {", "            _fees.daoFees = _fees.daoFees * asset.feeMultiplier / DIVISION_CONSTANT;", "            _fees.burnFees = _fees.burnFees * asset.feeMultiplier / DIVISION_CONSTANT;", "            _fees.referralFees = _fees.referralFees * asset.feeMultiplier / DIVISION_CONSTANT;", "            _fees.botFees = _fees.botFees * asset.feeMultiplier / DIVISION_CONSTANT;", "        }", "        address _referrer = tradingExtension.getRef(_trader); //referrals.getReferral(referrals.getReferred(_trader));", "        if (_referrer != address(0)) {", "            unchecked {", "                IStable(_tigAsset).mintFor(", "                    _referrer,", "                    _positionSize", "                    * _fees.referralFees // get referral fee%", "                    / DIVISION_CONSTANT // divide by 100%", "                );", "            }", "            _fees.daoFees = _fees.daoFees - _fees.referralFees*2;", "        }", "        if (_isBot) {", "            unchecked {", "                IStable(_tigAsset).mintFor(", "                    _msgSender(),", "                    _positionSize", "                    * _fees.botFees // get bot fee%", "                    / DIVISION_CONSTANT // divide by 100%", "                );", "            }", "            _fees.daoFees = _fees.daoFees - _fees.botFees;", "        } else {", "            _fees.botFees = 0;", "        }", "        unchecked {", "            uint _daoFeesPaid = _positionSize * _fees.daoFees / DIVISION_CONSTANT;", "            _feePaid =", "                _positionSize", "                * (_fees.burnFees + _fees.botFees) // get total fee%", "                / DIVISION_CONSTANT // divide by 100%", "                + _daoFeesPaid;", "            emit FeesDistributed(", "                _tigAsset,", "                _daoFeesPaid,", "                _positionSize * _fees.burnFees / DIVISION_CONSTANT,", "                _referrer != address(0) ? _positionSize * _fees.referralFees / DIVISION_CONSTANT : 0,", "                _positionSize * _fees.botFees / DIVISION_CONSTANT,", "                _referrer", "            );", "            IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);", "        }", "        gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this)));", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function sendOutTokenOrETH(", "      address token,", "      address receiver,", "      uint256 amount", "    )", "      external", "      returns (bool)", "    {", "        if(token == address(0)) { revert TransferFailed(); }", "        ", "        // both branches revert if call failed", "        if(token!= Denominations.ETH) { // ERC20", "            IERC20(token).safeTransfer(receiver, amount);", "        } else { // ETH", "            payable(receiver).transfer(amount);", "        }", "        return true;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["  function execute(ExecuteArgs calldata _args) external whenNotPaused nonReentrant returns (bytes32) {", "    (bytes32 transferId, bool reconciled) = _executeSanityChecks(_args);", "", "    // Set the relayer for this transaction to allow for future claim", "    s.transferRelayer[transferId] = msg.sender;", "", "    // execute router liquidity when this is a fast transfer", "    // asset will be adopted unless specified to be local in params", "    (uint256 amount, address asset) = _handleExecuteLiquidity(transferId, !reconciled, _args);", "", "    // execute the transaction", "    uint256 amountWithSponsors = _handleExecuteTransaction(_args, amount, asset, transferId, reconciled);", "", "    // emit event", "    emit Executed(transferId, _args.params.to, _args, asset, amountWithSponsors, msg.sender);", "", "    return transferId;", "  }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function execute(", "        TokenTransfer[] calldata tokenTransfers,", "        TradeData[] calldata tradeData,", "        address originator,", "        address recipient,", "        bool isAtomic", "    ) external payable nonReentrant {", "        if (recipient == address(0)) revert ZeroAddress();", "        uint256 tradeDataLength = tradeData.length;", "        if (tradeDataLength == 0) revert InvalidOrderLength();", "", "        uint256 tokenTransfersLength = tokenTransfers.length;", "        if (tokenTransfersLength == 0) {", "            originator = msg.sender;", "        } else if (msg.sender != erc20EnabledLooksRareAggregator) {", "            revert UseERC20EnabledLooksRareAggregator();", "        }", "", "        for (uint256 i; i < tradeDataLength; ) {", "            TradeData calldata singleTradeData = tradeData[i];", "            if (!_proxyFunctionSelectors[singleTradeData.proxy][singleTradeData.selector]) revert InvalidFunction();", "", "            (bytes memory proxyCalldata, bool maxFeeBpViolated) = _encodeCalldataAndValidateFeeBp(", "                singleTradeData,", "                recipient,", "                isAtomic", "            );", "            if (maxFeeBpViolated) {", "                if (isAtomic) {", "                    revert FeeTooHigh();", "                } else {", "                    unchecked {", "                        ++i;", "                    }", "                    continue;", "                }", "            }", "            (bool success, bytes memory returnData) = singleTradeData.proxy.delegatecall(proxyCalldata);", "", "            if (!success) {", "                if (isAtomic) {", "                    if (returnData.length > 0) {", "                        assembly {", "                            let returnDataSize := mload(returnData)", "                            revert(add(32, returnData), returnDataSize)", "                        }", "                    } else {", "                        revert TradeExecutionFailed();", "                    }", "                }", "            }", "", "            unchecked {", "                ++i;", "            }", "        }", "", "        if (tokenTransfersLength > 0) _returnERC20TokensIfAny(tokenTransfers, originator);", "        _returnETHIfAny(originator);", "", "        emit Sweep(originator);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0]}
{"tokens": ["    function deposit(uint256 _pid, uint256 _amount) public {", "        PoolInfo storage pool = poolInfo[_pid];", "        UserInfo storage user = userInfo[_pid][msg.sender];", "        updatePool(_pid);", "        if (user.amount > 0) {", "            uint256 pending = user", "                .amount", "                .mul(pool.accCvxPerShare)", "                .div(1e12)", "                .sub(user.rewardDebt);", "            safeRewardTransfer(msg.sender, pending);", "        }", "        pool.lpToken.safeTransferFrom(", "            address(msg.sender),", "            address(this),", "            _amount", "        );", "        user.amount = user.amount.add(_amount);", "        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);", "", "        //extra rewards", "        IRewarder _rewarder = pool.rewarder;", "        if (address(_rewarder) != address(0)) {", "            _rewarder.onReward(_pid, msg.sender, msg.sender, 0, user.amount);", "        }", "", "        emit Deposit(msg.sender, _pid, _amount);", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function buy(uint256 _amount) external payable {", "        uint24 amount = uint24(_amount);", "        Sale memory temp = sale;", "        IEscher721 nft = IEscher721(temp.edition);", "        require(block.timestamp >= temp.startTime, \"TOO SOON\");", "        require(block.timestamp < temp.endTime, \"TOO LATE\");", "        require(amount * sale.price == msg.value, \"WRONG PRICE\");", "        uint24 newId = amount + temp.currentId;", "", "        for (uint24 x = temp.currentId + 1; x <= newId; x++) {", "            nft.mint(msg.sender, x);", "        }", "        sale.currentId = newId;", "", "        emit Buy(msg.sender, amount, msg.value, temp);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function minter_burn_from(address b_address, uint256 b_amount) public onlyMinters {", "        super.burnFrom(b_address, b_amount);", "        emit TokenMinterBurned(b_address, msg.sender, b_amount);", "    }"], "ner_tags": [1, 0, 0, 0]}
{"tokens": ["    function _removeCollateral(", "        address sendTo,", "        IPaprController.Collateral calldata collateral,", "        uint256 oraclePrice,", "        uint256 cachedTarget", "    ) internal {", "        if (collateralOwner[collateral.addr][collateral.id] != msg.sender) {", "            revert IPaprController.OnlyCollateralOwner();", "        }", "", "        delete collateralOwner[collateral.addr][collateral.id];", "", "        uint16 newCount;", "        unchecked {", "            newCount = _vaultInfo[msg.sender][collateral.addr].count - 1;", "            _vaultInfo[msg.sender][collateral.addr].count = newCount;", "        }", "", "        // allows for onReceive hook to sell and repay debt before the", "        // debt check below", "        collateral.addr.safeTransferFrom(address(this), sendTo, collateral.id);", "", "        uint256 debt = _vaultInfo[msg.sender][collateral.addr].debt;", "        uint256 max = _maxDebt(oraclePrice * newCount, cachedTarget);", "", "        if (debt > max) {", "            revert IPaprController.ExceedsMaxDebt(debt, max);", "        }", "", "        emit RemoveCollateral(msg.sender, collateral.addr, collateral.id);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function swap(", "        address fromToken_,", "        address toToken_,", "        uint256 amountIn_", "    ) public payable override returns (uint256 amountOut) {", "        // Validating ETH value sent", "        require(msg.value == (fromToken_ == address(0) ? amountIn_ : 0), Error.INVALID_AMOUNT);", "        if (amountIn_ == 0) {", "            emit Swapped(fromToken_, toToken_, 0, 0);", "            return 0;", "        }", "", "        // Handling swap between the same token", "        if (fromToken_ == toToken_) {", "            if (fromToken_ == address(0)) {", "                payable(msg.sender).transfer(amountIn_);", "            }", "            emit Swapped(fromToken_, toToken_, amountIn_, amountIn_);", "            return amountIn_;", "        }", "", "        // Transferring to contract if ERC20", "        if (fromToken_ != address(0)) {", "            IERC20(fromToken_).safeTransferFrom(msg.sender, address(this), amountIn_);", "        }", "", "        // Swapping token via WETH", "        uint256 amountOut_ = _swapWethForToken(toToken_, _swapForWeth(fromToken_));", "        emit Swapped(fromToken_, toToken_, amountIn_, amountOut_);", "        return _returnTokens(toToken_, amountOut_);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function transferFrom(", "        address _from,", "        address _to,", "        uint256 _idx", "    ) external onlyOwner {", "        _transferFrom(_from, _to, _idx);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function convertToAssets(uint256 shares) public view virtual returns (uint256) {", "        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.", "", "        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);", "    }"], "ner_tags": [0, 0, 0, 1, 0]}
{"tokens": ["    function globalPause(address[] memory _addresses) external returns (address[] memory _updatedAddresses) {", "        require(msg.sender == CIRCUIT_BREAKER_ADDRESS, \"Circuit Breaker only\");", "        address _pairAddress;", "        uint256 _lengthOfArray = _addresses.length;", "        for (uint256 i = 0; i < _lengthOfArray; ) {", "            _pairAddress = _addresses[i];", "            try IFraxlendPair(_pairAddress).pause() {", "                _updatedAddresses[i] = _addresses[i];", "            } catch {}", "            unchecked {", "                i = i + 1;", "            }", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function _execMatchOneToOneOrders(", "    bytes32 sellOrderHash,", "    bytes32 buyOrderHash,", "    OrderTypes.MakerOrder calldata sell,", "    OrderTypes.MakerOrder calldata buy,", "    uint256 startGasPerOrder,", "    uint256 execPrice,", "    uint16 protocolFeeBps,", "    uint32 wethTransferGasUnits,", "    address weth", "  ) internal {", "    isUserOrderNonceExecutedOrCancelled[sell.signer][sell.constraints[5]] = true;", "    isUserOrderNonceExecutedOrCancelled[buy.signer][buy.constraints[5]] = true;", "    uint256 protocolFee = (protocolFeeBps * execPrice) / 10000;", "    uint256 remainingAmount = execPrice - protocolFee;", "    _transferMultipleNFTs(sell.signer, buy.signer, sell.nfts);", "    // transfer final amount (post-fees) to seller", "    IERC20(buy.execParams[1]).safeTransferFrom(buy.signer, sell.signer, remainingAmount);", "    _emitMatchEvent(", "      sellOrderHash,", "      buyOrderHash,", "      sell.signer,", "      buy.signer,", "      buy.execParams[0],", "      buy.execParams[1],", "      execPrice", "    );", "    uint256 gasCost = (startGasPerOrder - gasleft() + wethTransferGasUnits) * tx.gasprice;", "    // if the execution currency is weth, we can send the protocol fee and gas cost in one transfer to save gas", "    // else we need to send the protocol fee separately in the execution currency", "    if (buy.execParams[1] == weth) {", "      IERC20(weth).safeTransferFrom(buy.signer, address(this), protocolFee + gasCost);", "    } else {", "      IERC20(buy.execParams[1]).safeTransferFrom(buy.signer, address(this), protocolFee);", "      IERC20(weth).safeTransferFrom(buy.signer, address(this), gasCost);", "    }", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": ["    function proposalThresholdBps() external view returns (uint256) {", "        return settings.proposalThresholdBps;", "    }"], "ner_tags": [1, 0, 0]}
{"tokens": ["    function remove(uint256 lpTokenAmount, uint256 minBaseTokenOutputAmount, uint256 minFractionalTokenOutputAmount)", "        public", "        returns (uint256 baseTokenOutputAmount, uint256 fractionalTokenOutputAmount)", "    {", "        // *** Checks *** //", "", "        // calculate the output amounts", "        (baseTokenOutputAmount, fractionalTokenOutputAmount) = removeQuote(lpTokenAmount);", "", "        // check that the base token output amount is greater than the min amount", "        require(baseTokenOutputAmount >= minBaseTokenOutputAmount, \"Slippage: base token amount out\");", "", "        // check that the fractional token output amount is greater than the min amount", "        require(fractionalTokenOutputAmount >= minFractionalTokenOutputAmount, \"Slippage: fractional token out\");", "", "        // *** Effects *** //", "", "        // transfer fractional tokens to sender", "        _transferFrom(address(this), msg.sender, fractionalTokenOutputAmount);", "", "        // *** Interactions *** //", "", "        // burn lp tokens from sender", "        lpToken.burn(msg.sender, lpTokenAmount);", "", "        if (baseToken == address(0)) {", "            // if base token is native ETH then send ether to sender", "            msg.sender.safeTransferETH(baseTokenOutputAmount);", "        } else {", "            // transfer base tokens to sender", "            ERC20(baseToken).safeTransfer(msg.sender, baseTokenOutputAmount);", "        }", "", "        emit Remove(baseTokenOutputAmount, fractionalTokenOutputAmount, lpTokenAmount);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["    function execute(address target, bytes memory data) public payable onlyOwner returns (bytes memory) {", "        // call the target with the value and data", "        (bool success, bytes memory returnData) = target.call{value: msg.value}(data);", "", "        // if the call succeeded return the return data", "        if (success) return returnData;", "", "        // if we got an error bubble up the error message", "        if (returnData.length > 0) {", "            // solhint-disable-next-line no-inline-assembly", "            assembly {", "                let returnData_size := mload(returnData)", "                revert(add(32, returnData), returnData_size)", "            }", "        } else {", "            revert();", "        }", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _rebalance(address _collateral, uint256 _amountLeavingPool) internal {", "        LocalVariables_rebalance memory vars;", "", "        // how much has been allocated as per our internal records?", "        vars.currentAllocated = yieldingAmount[_collateral];", "        ", "        // what is the present value of our shares?", "        vars.yieldGenerator = IERC4626(yieldGenerator[_collateral]);", "        vars.ownedShares = vars.yieldGenerator.balanceOf(address(this));", "        vars.sharesToAssets = vars.yieldGenerator.convertToAssets(vars.ownedShares);", "", "        // if we have profit that's more than the threshold, record it for withdrawal and redistribution", "        vars.profit = vars.sharesToAssets.sub(vars.currentAllocated);", "        if (vars.profit < yieldClaimThreshold[_collateral]) {", "            vars.profit = 0;", "        }", "        ", "        // what % of the final pool balance would the current allocation be?", "        vars.finalBalance = collAmount[_collateral].sub(_amountLeavingPool);", "        vars.percentOfFinalBal = vars.finalBalance == 0 ? uint256(-1) : vars.currentAllocated.mul(10_000).div(vars.finalBalance);", "", "        // if abs(percentOfFinalBal - yieldingPercentage) > drift, we will need to deposit more or withdraw some", "        vars.yieldingPercentage = yieldingPercentage[_collateral];", "        vars.finalYieldingAmount = vars.finalBalance.mul(vars.yieldingPercentage).div(10_000);", "        vars.yieldingAmount = yieldingAmount[_collateral];", "        if (vars.percentOfFinalBal > vars.yieldingPercentage && vars.percentOfFinalBal.sub(vars.yieldingPercentage) > yieldingPercentageDrift) {", "            // we will end up overallocated, withdraw some", "            vars.toWithdraw = vars.currentAllocated.sub(vars.finalYieldingAmount);", "            vars.yieldingAmount = vars.yieldingAmount.sub(vars.toWithdraw);", "            yieldingAmount[_collateral] = vars.yieldingAmount;", "        } else if(vars.percentOfFinalBal < vars.yieldingPercentage && vars.yieldingPercentage.sub(vars.percentOfFinalBal) > yieldingPercentageDrift) {", "            // we will end up underallocated, deposit more", "            vars.toDeposit = vars.finalYieldingAmount.sub(vars.currentAllocated);", "            vars.yieldingAmount = vars.yieldingAmount.add(vars.toDeposit);", "            yieldingAmount[_collateral] = vars.yieldingAmount;", "        }", "", "        // + means deposit, - means withdraw", "        vars.netAssetMovement = int256(vars.toDeposit) - int256(vars.toWithdraw) - int256(vars.profit);", "        if (vars.netAssetMovement > 0) {", "            IERC20(_collateral).safeIncreaseAllowance(yieldGenerator[_collateral], uint256(vars.netAssetMovement));", "            IERC4626(yieldGenerator[_collateral]).deposit(uint256(vars.netAssetMovement), address(this));", "        } else if (vars.netAssetMovement < 0) {", "            IERC4626(yieldGenerator[_collateral]).withdraw(uint256(-vars.netAssetMovement), address(this), address(this));", "        }", "", "        // if we recorded profit, recalculate it for precision and distribute", "        if (vars.profit != 0) {", "            // profit is ultimately (coll at hand) + (coll allocated to yield generator) - (recorded total coll Amount in pool)", "            vars.profit = IERC20(_collateral).balanceOf(address(this)).add(vars.yieldingAmount).sub(collAmount[_collateral]);", "            if (vars.profit != 0) {", "                // distribute to treasury, staking pool, and stability pool", "                vars.treasurySplit = vars.profit.mul(yieldSplitTreasury).div(10_000);", "                if (vars.treasurySplit != 0) {", "                    IERC20(_collateral).safeTransfer(treasuryAddress, vars.treasurySplit);", "                }", "", "                vars.stakingSplit = vars.profit.mul(yieldSplitStaking).div(10_000);", "                if (vars.stakingSplit != 0) {", "                    IERC20(_collateral).safeTransfer(lqtyStakingAddress, vars.stakingSplit);", "                    ILQTYStaking(lqtyStakingAddress).increaseF_Collateral(_collateral, vars.stakingSplit);", "                }", "", "                vars.stabilityPoolSplit = vars.profit.sub(vars.treasurySplit.add(vars.stakingSplit));", "                if (vars.stabilityPoolSplit != 0) {", "                    IERC20(_collateral).safeTransfer(stabilityPoolAddress, vars.stabilityPoolSplit);", "                    IStabilityPool(stabilityPoolAddress).updateRewardSum(_collateral, vars.stabilityPoolSplit);   ", "                }", "            }", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function deposit(uint256 amount, address receiver)", "    public", "    virtual", "    returns (uint256)", "  {", "    VIData storage s = _loadVISlot();", "    require(s.allowList[msg.sender] && receiver == owner());", "    ERC20(asset()).safeTransferFrom(msg.sender, address(this), amount);", "    return amount;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["    function mint(uint256 shares, address to) public virtual returns (uint256 amount) {", "        amount = previewMint(shares); // No need to check for rounding error, previewMint rounds up.", "", "        // Need to transfer before minting or ERC777s could reenter.", "        asset.safeTransferFrom(msg.sender, address(this), amount);", "", "        _mint(to, amount);", "", "        emit Deposit(msg.sender, to, amount, shares);", "", "        afterDeposit(amount, shares);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function accrueUser(", "        ERC20 strategy,", "        address user,", "        RewardsState memory state", "    ) private returns (uint256) {", "        // load indices", "        uint224 strategyIndex = state.index;", "        uint224 supplierIndex = userIndex[strategy][user];", "", "        // sync user index to global", "        userIndex[strategy][user] = strategyIndex;", "", "        // if user hasn't yet accrued rewards, grant them interest from the strategy beginning if they have a balance", "        // zero balances will have no effect other than syncing to global index", "        if (supplierIndex == 0) {", "            supplierIndex = ONE;", "        }", "", "        uint224 deltaIndex = strategyIndex - supplierIndex;", "        // use the booster or token balance to calculate reward balance multiplier", "        uint256 supplierTokens = address(flywheelBooster) != address(0)", "            ? flywheelBooster.boostedBalanceOf(strategy, user)", "            : strategy.balanceOf(user);", "", "        // accumulate rewards by multiplying user tokens by rewardsPerToken index and adding on unclaimed", "        uint256 supplierDelta = (supplierTokens * deltaIndex) / ONE;", "        uint256 supplierAccrued = rewardsAccrued[user] + supplierDelta;", "", "        rewardsAccrued[user] = supplierAccrued;", "", "        emit AccrueRewards(strategy, user, supplierDelta, strategyIndex);", "", "        return supplierAccrued;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": ["  function _beforeCommitToLien(IAstariaRouter.Commitment calldata params)", "    internal", "    virtual", "    override(VaultImplementation)", "  {", "    VaultData storage s = _loadStorageSlot();", "", "    if (s.withdrawReserve > uint256(0)) {", "      transferWithdrawReserve();", "    }", "    if (timeToEpochEnd() == uint256(0)) {", "      processEpoch();", "    }", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["  function currentPrice(uint256 _decimals) external view override returns (uint256) {", "    // Get the latest round information. Only need the price is needed.", "    (, int256 _price, , , ) = feed.latestRoundData();", "", "    // Get a reference to the number of decimals the feed uses.", "    uint256 _feedDecimals = feed.decimals();", "", "    // Return the price, adjusted to the target decimals.", "    return uint256(_price).adjustDecimals(_feedDecimals, _decimals);", "  }"], "ner_tags": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function deployFor(address owner) public override returns (IMIMOProxy proxy) {", "    IMIMOProxy currentProxy = _currentProxies[owner];", "", "    // Do not deploy if the proxy already exists and the owner is the same.", "    if (address(currentProxy) != address(0) && currentProxy.owner() == owner) {", "      revert CustomErrors.PROXY_ALREADY_EXISTS(owner);", "    }", "", "    // Deploy the proxy via the factory.", "    proxy = factory.deployFor(owner);", "", "    // Set or override the current proxy for the owner.", "    _currentProxies[owner] = IMIMOProxy(proxy);", "  }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function safeTransferMany(address _to, uint[] calldata _ids) external {", "        unchecked {", "            for (uint i=0; i<_ids.length; i++) {", "                _transfer(_msgSender(), _to, _ids[i]);", "            }", "        }", "    }"], "ner_tags": [0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["    function wrap(", "        bytes calldata name,", "        address wrappedOwner,", "        address resolver", "    ) public override {", "        (bytes32 labelhash, uint256 offset) = name.readLabel(0);", "        bytes32 parentNode = name.namehash(offset);", "        bytes32 node = _makeNode(parentNode, labelhash);", "", "        if (parentNode == ETH_NODE) {", "            revert IncompatibleParent();", "        }", "", "        address owner = ens.owner(node);", "", "        if (", "            owner != msg.sender &&", "            !isApprovedForAll(owner, msg.sender) &&", "            !ens.isApprovedForAll(owner, msg.sender)", "        ) {", "            revert Unauthorised(node, msg.sender);", "        }", "", "        if (resolver != address(0)) {", "            ens.setResolver(node, resolver);", "        }", "", "        ens.setOwner(node, address(this));", "", "        _wrap(node, name, wrappedOwner, 0, 0);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    modifier updateReward(address account) {", "        rewardPerTokenStored = rewardPerToken();", "        lastUpdateTime = lastTimeRewardApplicable();", "        if (account != address(0)) {", "            rewards[account] = earned(account);", "            userRewardPerTokenPaid[account] = rewardPerTokenStored;", "        }", "        emit RewardUpdated(account, rewards[account], rewardPerTokenStored, lastUpdateTime);", "        _;", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": ["    function _updateTreasury(", "        uint24 distributionId_", "    ) private {", "        bytes32 fundedSlateHash = _distributions[distributionId_].fundedSlateHash;", "        uint256 fundsAvailable  = _distributions[distributionId_].fundsAvailable;", "", "        uint256[] memory fundingProposalIds = _fundedProposalSlates[fundedSlateHash];", "", "        uint256 totalTokensRequested;", "        uint256 numFundedProposals = fundingProposalIds.length;", "", "        for (uint i = 0; i < numFundedProposals; ) {", "            Proposal memory proposal = _standardFundingProposals[fundingProposalIds[i]];", "", "            totalTokensRequested += proposal.tokensRequested;", "", "            unchecked { ++i; }", "        }", "", "        // readd non distributed tokens to the treasury", "        treasury += (fundsAvailable - totalTokensRequested);", "", "        _isSurplusFundsUpdated[distributionId_] = true;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0]}
{"tokens": ["    function setTokenURI(uint256 tokenId, string calldata tokenUri)", "        external", "        override", "        returns (bool)", "    {", "        require(_exists(tokenId), \"Token does not exists\");", "        require(_isApprovedOrOwner(msg.sender, tokenId), \"Sender can not set token URI\");", "        _setTokenURI(tokenId, tokenUri);", "        return true;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["  function _transferERC721s(", "    address from,", "    address to,", "    OrderTypes.OrderItem calldata item", "  ) internal {", "    uint256 numTokens = item.tokens.length;", "    for (uint256 i = 0; i < numTokens; ) {", "      IERC721(item.collection).safeTransferFrom(from, to, item.tokens[i].tokenId);", "      unchecked {", "        ++i;", "      }", "    }", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["  function send(", "    uint256 gasLimit,", "    uint256 gasPrice,", "    uint32 toChain,", "    address msgSender,", "    uint256 nonce,", "    address holographableContract,", "    bytes calldata bridgeOutPayload", "  ) external payable {", "    require(msg.sender == _bridge(), \"HOLOGRAPH: bridge only call\");", "    CrossChainMessageInterface messagingModule = _messagingModule();", "    uint256 hlgFee = messagingModule.getHlgFee(toChain, gasLimit, gasPrice);", "    address hToken = _registry().getHToken(_holograph().getHolographChainId());", "    require(hlgFee < msg.value, \"HOLOGRAPH: not enough value\");", "    payable(hToken).transfer(hlgFee);", "    bytes memory encodedData = abi.encodeWithSelector(", "      HolographBridgeInterface.bridgeInRequest.selector,", "      /**", "       * @dev job nonce is an incremented value that is assigned to each bridge request to guarantee unique hashes", "       */", "      nonce,", "      /**", "       * @dev including the current holograph chain id (origin chain)", "       */", "      _holograph().getHolographChainId(),", "      /**", "       * @dev holographable contract have the same address across all chains, so our destination address will be the same", "       */", "      holographableContract,", "      /**", "       * @dev get the current chain's hToken for native gas token", "       */", "      hToken,", "      /**", "       * @dev recipient will be defined when operator picks up the job", "       */", "      address(0),", "      /**", "       * @dev value is set to zero for now", "       */", "      hlgFee,", "      /**", "       * @dev specify that function call should not revert", "       */", "      true,", "      /**", "       * @dev attach actual holographableContract function call", "       */", "      bridgeOutPayload", "    );", "    /**", "     * @dev add gas variables to the back for later extraction", "     */", "    encodedData = abi.encodePacked(encodedData, gasLimit, gasPrice);", "    /**", "     * @dev Send the data to the current Holograph Messaging Module", "     *      This will be changed to dynamically select which messaging module to use based on destination network", "     */", "    messagingModule.send{value: msg.value - hlgFee}(", "      gasLimit,", "      gasPrice,", "      toChain,", "      msgSender,", "      msg.value - hlgFee,", "      encodedData", "    );", "    /**", "     * @dev for easy indexing, an event is emitted with the payload hash for status tracking", "     */", "    emit CrossChainMessageSent(keccak256(encodedData));", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function createMarket(", "        string memory _tokenNameSuffix,", "        string memory _tokenSymbolSuffix,", "        address _governance,", "        address _collateral,", "        uint256 _floorLongPrice,", "        uint256 _ceilingLongPrice,", "        uint256 _floorValuation,", "        uint256 _ceilingValuation,", "        uint256 _mintingFee,", "        uint256 _redemptionFee,", "        uint256 _expiryTime", "    ) external override onlyOwner nonReentrant {", "        require(_validCollateral[_collateral], \"Invalid collateral\");", "", "        (", "            LongShortToken _longToken,", "            LongShortToken _shortToken", "        ) = _createPairTokens(_tokenNameSuffix, _tokenSymbolSuffix);", "        bytes32 _salt = keccak256(abi.encodePacked(_longToken, _shortToken));", "", "        PrePOMarket _newMarket = new PrePOMarket{salt: _salt}(", "            _governance,", "            _collateral,", "            ILongShortToken(address(_longToken)),", "            ILongShortToken(address(_shortToken)),", "            _floorLongPrice,", "            _ceilingLongPrice,", "            _floorValuation,", "            _ceilingValuation,", "            _mintingFee,", "            _redemptionFee,", "            _expiryTime,", "            false", "        );", "        _deployedMarkets[_salt] = address(_newMarket);", "", "        _longToken.transferOwnership(address(_newMarket));", "        _shortToken.transferOwnership(address(_newMarket));", "        emit MarketAdded(address(_newMarket), _salt);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function mintGenesisReward(address _rewardDistributor) external onlyOwner {", "        require(!isGenesisRewardMinted, 'already minted');", "        _mint(_rewardDistributor, 62_500_000 * 1e18);", "        isGenesisRewardMinted = true;", "    }"], "ner_tags": [1, 1, 1, 1, 1]}
{"tokens": ["    function initialize(address _owner) external onlyImpl {", "        require(_owner != address(0), \"Owner must be set\");", "        // Initial supply hard coded to 0 as tokens are only supposed", "        // to be minted through the bridge.", "        GraphTokenUpgradeable._initialize(_owner, 0);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0]}
{"tokens": ["    function setController(address _controller) public onlyOwner {", "        require(_controller != address(0), \"INVALID_CONTROLLER\");", "        controller = IController(_controller);", "    }"], "ner_tags": [1, 0, 0, 0]}
{"tokens": ["    function initialize(", "        address[] calldata _assets,", "        uint[] calldata _capitalizations,", "        uint _totalCapitalization", "    ) external {", "        require(msg.sender == factory, \"TrackedIndex: FORBIDDEN\");", "", "        uint8 totalWeight;", "        uint maxCapitalization = _capitalizations[0];", "        address maxCapitalizationAsset = _assets[0];", "        for (uint i; i < _assets.length; ++i) {", "            address asset = _assets[i];", "            uint8 weight = uint8((_capitalizations[i] * type(uint8).max) / _totalCapitalization);", "            if (_capitalizations[i] > maxCapitalization) {", "                emit UpdateAnatomy(maxCapitalizationAsset, weightOf[maxCapitalizationAsset]);", "                maxCapitalization = _capitalizations[i];", "                maxCapitalizationAsset = asset;", "            }", "            weightOf[asset] = weight;", "            totalWeight += weight;", "            assets.add(asset);", "            if (asset != maxCapitalizationAsset) {", "                emit UpdateAnatomy(asset, weight);", "            }", "        }", "        if (totalWeight < IndexLibrary.MAX_WEIGHT) {", "            weightOf[maxCapitalizationAsset] += IndexLibrary.MAX_WEIGHT - totalWeight;", "        }", "        emit UpdateAnatomy(maxCapitalizationAsset, weightOf[maxCapitalizationAsset]);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function tokenTransferFrom(", "    address token,", "    address from,", "    address to,", "    uint256 amount", "  ) external requiresAuth {", "    ERC20(token).safeTransferFrom(from, to, amount);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["  function flashAction(", "    IFlashAction receiver,", "    uint256 collateralId,", "    bytes calldata data", "  ) external onlyOwner(collateralId) {", "    address addr;", "    uint256 tokenId;", "    CollateralStorage storage s = _loadCollateralSlot();", "    (addr, tokenId) = getUnderlying(collateralId);", "", "    if (!s.flashEnabled[addr]) {", "      revert InvalidCollateralState(InvalidCollateralStates.FLASH_DISABLED);", "    }", "", "    if (", "      s.LIEN_TOKEN.getCollateralState(collateralId) == bytes32(\"ACTIVE_AUCTION\")", "    ) {", "      revert InvalidCollateralState(InvalidCollateralStates.AUCTION_ACTIVE);", "    }", "", "    bytes32 preTransferState;", "    //look to see if we have a security handler for this asset", "", "    address securityHook = s.securityHooks[addr];", "    if (securityHook != address(0)) {", "      preTransferState = ISecurityHook(securityHook).getState(addr, tokenId);", "    }", "    // transfer the NFT to the destination optimistically", "", "    ClearingHouse(s.clearingHouse[collateralId]).transferUnderlying(", "      addr,", "      tokenId,", "      address(receiver)", "    );", "", "    //trigger the flash action on the receiver", "    if (", "      receiver.onFlashAction(", "        IFlashAction.Underlying(s.clearingHouse[collateralId], addr, tokenId),", "        data", "      ) != keccak256(\"FlashAction.onFlashAction\")", "    ) {", "      revert FlashActionCallbackFailed();", "    }", "", "    if (", "      securityHook != address(0) &&", "      preTransferState != ISecurityHook(securityHook).getState(addr, tokenId)", "    ) {", "      revert FlashActionSecurityCheckFailed();", "    }", "", "    // validate that the NFT returned after the call", "", "    if (", "      IERC721(addr).ownerOf(tokenId) != address(s.clearingHouse[collateralId])", "    ) {", "      revert FlashActionNFTNotReturned();", "    }", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function getReserveBalance(ERC20 token_) external view returns (uint256) {", "        return token_.balanceOf(address(this)) + totalDebt[token_];", "    }"], "ner_tags": [0, 1, 0]}
{"tokens": ["  function buyFromPrivateSaleFor(", "    IERC721 nftContract,", "    uint256 tokenId,", "    uint256 amount,", "    uint256 deadline,", "    uint8 v,", "    bytes32 r,", "    bytes32 s", "  ) public payable nonReentrant {", "    if (deadline < block.timestamp) {", "      // The signed message from the seller has expired.", "      revert NFTMarketPrivateSale_Sale_Expired();", "    } else if (deadline > block.timestamp + 2 days) {", "      // Private sales typically expire in 24 hours, but 2 days is used here in order to ensure", "      // that transactions do not fail due to a minor timezone error or similar during signing.", "", "      // This prevents malicious actors from requesting signatures that never expire.", "      revert NFTMarketPrivateSale_Can_Be_Offered_For_24Hrs_Max();", "    }", "", "    if (amount > msg.value) {", "      // Withdraw additional ETH required from their available FETH balance.", "", "      unchecked {", "        // The if above ensures delta will not underflow", "        uint256 delta = amount - msg.value;", "        feth.marketWithdrawFrom(msg.sender, delta);", "      }", "    } else if (amount < msg.value) {", "      // The terms of the sale cannot change, so if too much ETH is sent then something went wrong.", "      revert NFTMarketPrivateSale_Too_Much_Value_Provided();", "    }", "", "    // The seller must have the NFT in their wallet when this function is called,", "    // otherwise the signature verification below will fail.", "    address payable seller = payable(nftContract.ownerOf(tokenId));", "", "    // Scoping this block to avoid a stack too deep error", "    {", "      bytes32 digest = keccak256(", "        abi.encodePacked(", "          \"\\x19\\x01\",", "          DOMAIN_SEPARATOR,", "          keccak256(abi.encode(BUY_FROM_PRIVATE_SALE_TYPEHASH, nftContract, tokenId, msg.sender, amount, deadline))", "        )", "      );", "", "      // Revert if the signature is invalid, the terms are not as expected, or if the seller transferred the NFT.", "      if (ecrecover(digest, v, r, s) != seller) {", "        revert NFTMarketPrivateSale_Signature_Verification_Failed();", "      }", "    }", "", "    // This should revert if the seller has not given the market contract approval.", "    nftContract.transferFrom(seller, msg.sender, tokenId);", "", "    // Distribute revenue for this sale.", "    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(", "      address(nftContract),", "      tokenId,", "      seller,", "      amount", "    );", "", "    emit PrivateSaleFinalized(", "      address(nftContract),", "      tokenId,", "      seller,", "      msg.sender,", "      f8nFee,", "      creatorFee,", "      ownerRev,", "      deadline", "    );", "  }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function execute(", "        address target,", "        bytes memory callData,", "        uint256 value", "    )", "        external", "        override", "        payable", "        onlyOwner // F: [OSW-6A]", "        returns (bytes memory)", "    {", "        return target.functionCallWithValue(callData, value); // F: [OSW-6]", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["    function checkSignatureTask(", "        bytes calldata _data,", "        bytes calldata _signature,", "        uint256 _taskID", "    ) internal {", "        // Calculate hash from bytes", "        bytes32 _hash = keccak256(_data);", "", "        // Local instance of subcontractor. To save gas.", "        address _sc = tasks[_taskID].subcontractor;", "", "        // When there is no contractor", "        if (contractor == address(0)) {", "            // Just check for B and SC sign", "            checkSignatureValidity(builder, _hash, _signature, 0);", "            checkSignatureValidity(_sc, _hash, _signature, 1);", "        }", "        // When there is a contractor", "        else {", "            // When builder has delegated his rights to contractor", "            if (contractorDelegated) {", "                // Check for GC and SC sign", "                checkSignatureValidity(contractor, _hash, _signature, 0);", "                checkSignatureValidity(_sc, _hash, _signature, 1);", "            }", "            // When builder has not delegated rights to contractor", "            else {", "                // Check for B, SC and GC signatures", "                checkSignatureValidity(builder, _hash, _signature, 0);", "                checkSignatureValidity(contractor, _hash, _signature, 1);", "                checkSignatureValidity(_sc, _hash, _signature, 2);", "            }", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["  function _stopLiens(", "    LienStorage storage s,", "    uint256 collateralId,", "    uint256 auctionWindow,", "    Stack[] calldata stack,", "    address liquidator", "  ) internal {", "    AuctionData memory auctionData;", "    auctionData.liquidator = liquidator;", "    auctionData.stack = new AuctionStack[](stack.length);", "    s.auctionData[collateralId].liquidator = liquidator;", "    uint256 i;", "    for (; i < stack.length; ) {", "      AuctionStack memory auctionStack;", "", "      auctionStack.lienId = stack[i].point.lienId;", "      auctionStack.end = stack[i].point.end;", "      uint88 owed = _getOwed(stack[i], block.timestamp);", "      auctionStack.amountOwed = owed;", "      s.lienMeta[auctionStack.lienId].atLiquidation = true;", "      auctionData.stack[i] = auctionStack;", "      address payee = _getPayee(s, auctionStack.lienId);", "      if (_isPublicVault(s, payee)) {", "        // update the public vault state and get the liquidation accountant back if any", "        address withdrawProxyIfNearBoundary = IPublicVault(payee)", "          .updateVaultAfterLiquidation(", "            auctionWindow,", "            IPublicVault.AfterLiquidationParams({", "              lienSlope: calculateSlope(stack[i]),", "              newAmount: owed,", "              lienEnd: stack[i].point.end", "            })", "          );", "", "        if (withdrawProxyIfNearBoundary != address(0)) {", "          _setPayee(s, auctionStack.lienId, withdrawProxyIfNearBoundary);", "        }", "      }", "      unchecked {", "        ++i;", "      }", "    }", "    s.collateralStateHash[collateralId] = ACTIVE_AUCTION;", "    auctionData.startTime = block.timestamp.safeCastTo48();", "    auctionData.endTime = (block.timestamp + auctionWindow).safeCastTo48();", "    auctionData.startAmount = stack[0]", "      .lien", "      .details", "      .liquidationInitialAsk", "      .safeCastTo88();", "    auctionData.endAmount = uint88(1000 wei);", "    s.COLLATERAL_TOKEN.getClearingHouse(collateralId).setAuctionData(", "      auctionData", "    );", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function contribute(", "        uint256 _poolId,", "        uint256 _quantity,", "        uint256 _price", "    ) public payable {", "        // Reverts if pool ID is not valid", "        _verifyPool(_poolId);", "        // Reverts if NFT has already been purchased OR termination period has passed", "        (, uint48 totalSupply, , , ) = _verifyUnsuccessfulState(_poolId);", "        // Reverts if ether contribution amount per Rae is less than minimum bid price per Rae", "        if (msg.value < _quantity * minBidPrices[_poolId] || _quantity == 0)", "            revert InvalidContribution();", "        // Reverts if ether payment amount is not equal to total amount being contributed", "        if (msg.value != _quantity * _price) revert InvalidPayment();", "", "        // Updates user and pool contribution amounts", "        userContributions[_poolId][msg.sender] += msg.value;", "        totalContributions[_poolId] += msg.value;", "", "        // Calculates remaining supply based on total possible supply and current filled quantity amount", "        uint256 remainingSupply = totalSupply - filledQuantities[_poolId];", "        // Calculates quantity amount being filled at any price", "        uint256 fillAtAnyPriceQuantity = remainingSupply < _quantity ? remainingSupply : _quantity;", "", "        // Checks if quantity amount being filled is greater than 0", "        if (fillAtAnyPriceQuantity > 0) {", "            // Inserts bid into end of queue", "            bidPriorityQueues[_poolId].insert(msg.sender, _price, fillAtAnyPriceQuantity);", "            // Increments total amount of filled quantities", "            filledQuantities[_poolId] += fillAtAnyPriceQuantity;", "        }", "", "        // Calculates unfilled quantity amount based on desired quantity and actual filled quantity amount", "        uint256 unfilledQuantity = _quantity - fillAtAnyPriceQuantity;", "        // Processes bids in queue to recalculate unfilled quantity amount", "        unfilledQuantity = processBidsInQueue(_poolId, unfilledQuantity, _price);", "", "        // Recalculates filled quantity amount based on updated unfilled quantity amount", "        uint256 filledQuantity = _quantity - unfilledQuantity;", "        // Updates minimum reserve price if filled quantity amount is greater than 0", "        if (filledQuantity > 0) minReservePrices[_poolId] = getMinPrice(_poolId);", "", "        // Emits event for contributing ether to pool based on desired quantity amount and price per Rae", "        emit Contribute(", "            _poolId,", "            msg.sender,", "            msg.value,", "            _quantity,", "            _price,", "            minReservePrices[_poolId]", "        );", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function initialize(address admin, Settings memory _settings)", "        public", "        initializer", "    {", "        // Set new settings", "        settings = _settings;", "", "        // Check values in memory:", "        if (_settings.drawBufferTime < HOUR_IN_SECONDS) {", "            revert REDRAW_TIMELOCK_NEEDS_TO_BE_MORE_THAN_AN_HOUR();", "        }", "        if (_settings.drawBufferTime > MONTH_IN_SECONDS) {", "            revert REDRAW_TIMELOCK_NEEDS_TO_BE_LESS_THAN_A_MONTH();", "        }", "", "        if (_settings.recoverTimelock < block.timestamp + WEEK_IN_SECONDS) {", "            revert RECOVER_TIMELOCK_NEEDS_TO_BE_AT_LEAST_A_WEEK();", "        }", "        if (", "            _settings.recoverTimelock >", "            block.timestamp + (MONTH_IN_SECONDS * 12)", "        ) {", "            revert RECOVER_TIMELOCK_NEEDS_TO_BE_LESS_THAN_A_YEAR();", "        }", "", "        // If NFT contract address is not a contract", "        if (_settings.token.code.length == 0) {", "            revert TOKEN_NEEDS_TO_BE_A_CONTRACT(_settings.token);", "        }", "", "        // If drawing token is not a contract", "        if (_settings.drawingToken.code.length == 0) {", "            revert TOKEN_NEEDS_TO_BE_A_CONTRACT(_settings.drawingToken);", "        }", "", "        // Validate token range: end needs to be greater than start", "        // and the size of the range needs to be at least 2 (end is exclusive)", "        if (", "            _settings.drawingTokenEndId < _settings.drawingTokenStartId ||", "            _settings.drawingTokenEndId - _settings.drawingTokenStartId < 2", "        ) {", "            revert DRAWING_TOKEN_RANGE_INVALID();", "        }", "", "        // Setup owner as admin", "        __Ownable_init(admin);", "", "        // Emit initialized event for indexing", "        emit InitializedDraw(msg.sender, settings);", "", "        // Get owner of raffled tokenId and ensure the current owner is the admin", "        try", "            IERC721EnumerableUpgradeable(_settings.token).ownerOf(", "                _settings.tokenId", "            )", "        returns (address nftOwner) {", "            // Check if address is the admin address", "            if (nftOwner != admin) {", "                revert DOES_NOT_OWN_NFT();", "            }", "        } catch {", "            revert TOKEN_BEING_OFFERED_NEEDS_TO_EXIST();", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function swapExactOut(", "    bytes32 canonicalId,", "    uint256 amountOut,", "    address assetIn,", "    address assetOut,", "    uint256 maxAmountIn,", "    uint256 deadline", "  ) external payable nonReentrant deadlineCheck(deadline) returns (uint256) {", "    return", "      s.swapStorages[canonicalId].swapOut(", "        getSwapTokenIndex(canonicalId, assetIn),", "        getSwapTokenIndex(canonicalId, assetOut),", "        amountOut,", "        maxAmountIn", "      );", "  }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function setRageQuit(uint40 newRageQuitTimestamp) external onlyHost {", "        uint40 oldRageQuitTimestamp = rageQuitTimestamp;", "", "        // Prevent disabling ragequit after initialization.", "        if (newRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY) {", "            revert CannotDisableRageQuitAfterInitializationError();", "        }", "", "        // Prevent setting timestamp if it is permanently enabled/disabled.", "        if (", "            oldRageQuitTimestamp == ENABLE_RAGEQUIT_PERMANENTLY ||", "            oldRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY", "        ) {", "            revert FixedRageQuitTimestampError(oldRageQuitTimestamp);", "        }", "", "        emit RageQuitSet(oldRageQuitTimestamp, rageQuitTimestamp = newRageQuitTimestamp);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _writeCheckpoint(", "        uint256 toTokenId,", "        uint256 nCheckpoints,", "        uint256[] memory _delegatedTokenIds", "    ) internal {", "        require(_delegatedTokenIds.length < 500, 'VVDelegation: Cannot stake more');", "", "        Checkpoint memory oldCheckpoint = checkpoints[toTokenId][nCheckpoints - 1];", "", "        if (nCheckpoints > 0 && oldCheckpoint.fromBlock == block.number) {", "            oldCheckpoint.delegatedTokenIds = _delegatedTokenIds;", "        } else {", "            checkpoints[toTokenId][nCheckpoints] = Checkpoint(block.number, _delegatedTokenIds);", "            numCheckpoints[toTokenId] = nCheckpoints + 1;", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function sharesToTokenAmount(uint256 _shares, address _tokenAddress) public view returns (uint256) {", "        return (_shares * totalReserve[_tokenAddress]) / totalSharesMinted[_tokenAddress];", "    }"], "ner_tags": [1, 0, 0]}
{"tokens": ["    function setPlatform(address _platform) external onlyOwner {", "        if (_platform == address(0)) revert ZeroAddress();", "", "        platform = _platform;", "", "        emit PlatformUpdated(_platform);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function withdraw(address e) external authorized(admin) returns (bool) {", "        uint256 when = withdrawals[e];", "        require (when != 0, 'no withdrawal scheduled');", "  ", "        require (block.timestamp >= when, 'withdrawal still on hold');", "  ", "        withdrawals[e] = 0;", "  ", "        IERC20 token = IERC20(e);", "        Safe.transfer(token, admin, token.balanceOf(address(this)));", "  ", "        return true;", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function initialize(", "        address _stakingToken,", "        address _yieldyToken,", "        address _tokeToken,", "        address _tokePool,", "        address _tokeManager,", "        address _tokeReward,", "        address _liquidityReserve,", "        address _feeAddress,", "        address _curvePool,", "        uint256 _epochDuration,", "        uint256 _firstEpochEndTime", "    ) external initializer {", "        OwnableUpgradeable.__Ownable_init();", "", "        // must have valid initial addresses", "        require(", "            _stakingToken != address(0) &&", "                _yieldyToken != address(0) &&", "                _tokeToken != address(0) &&", "                _tokePool != address(0) &&", "                _tokeManager != address(0) &&", "                _tokeReward != address(0) &&", "                _liquidityReserve != address(0),", "            \"Invalid address\"", "        );", "        STAKING_TOKEN = _stakingToken;", "        YIELDY_TOKEN = _yieldyToken;", "        TOKE_TOKEN = _tokeToken;", "        TOKE_POOL = _tokePool;", "        TOKE_MANAGER = _tokeManager;", "        TOKE_REWARD = _tokeReward;", "        LIQUIDITY_RESERVE = _liquidityReserve;", "        FEE_ADDRESS = _feeAddress;", "        CURVE_POOL = _curvePool;", "        COW_SETTLEMENT = 0x9008D19f58AAbD9eD0D60971565AA8510560ab41;", "        COW_RELAYER = 0xC92E8bdf79f0507f65a392b0ab4667716BFE0110;", "", "        timeLeftToRequestWithdrawal = 12 hours;", "", "        if (CURVE_POOL != address(0)) {", "            IERC20(TOKE_POOL).approve(CURVE_POOL, type(uint256).max);", "            setToAndFromCurve();", "        }", "", "        IERC20(STAKING_TOKEN).approve(TOKE_POOL, type(uint256).max);", "        IERC20Upgradeable(YIELDY_TOKEN).approve(", "            LIQUIDITY_RESERVE,", "            type(uint256).max", "        );", "        IERC20Upgradeable(YIELDY_TOKEN).approve(", "            LIQUIDITY_RESERVE,", "            type(uint256).max", "        );", "        IERC20Upgradeable(TOKE_TOKEN).approve(COW_RELAYER, type(uint256).max);", "", "        epoch = Epoch({", "            duration: _epochDuration,", "            number: 1,", "            timestamp: block.timestamp, // we know about the issues surrounding block.timestamp, using it here will not cause any problems", "            endTime: _firstEpochEndTime,", "            distribute: 0", "        });", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["  function removeNotional(address o, uint256 a) external authorized(admin) returns (bool) {", "", "    Vault memory vlt = vaults[o];", "", "    if (a > vlt.notional) { revert Exception(31, a, vlt.notional, address(0), address(0)); }", "", "    uint256 exchangeRate = Compounding.exchangeRate(protocol, cTokenAddr);", "", "    // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate", "    // otherwise, calculate marginal exchange rate between current and previous exchange rate.", "    uint256 yield;", "    if (maturityRate > 0) { // Calculate marginal interest", "      yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;", "    } else {", "      // calculate marginal interest", "      yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;", "    }", "", "    uint256 interest = (yield * vlt.notional) / 1e26;", "    // remove amount from position, Add interest to position, reset cToken exchange rate", "    vlt.redeemable += interest;", "    vlt.notional -= a;", "    vlt.exchangeRate = exchangeRate;", "", "    vaults[o] = vlt;", "", "    return true;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _updateTWAV(uint256 _valuation, uint32 _blockTimestamp) internal {", "        uint32 _timeElapsed; ", "        unchecked {", "            _timeElapsed = _blockTimestamp - lastBlockTimeStamp;", "        }", "", "        uint256 _prevCumulativeValuation = twavObservations[((twavObservationsIndex + TWAV_BLOCK_NUMBERS) - 1) % TWAV_BLOCK_NUMBERS].cumulativeValuation;", "        twavObservations[twavObservationsIndex] = TwavObservation(_blockTimestamp, _prevCumulativeValuation + (_valuation * _timeElapsed)); //add the previous observation to make it cumulative", "        twavObservationsIndex = (twavObservationsIndex + 1) % TWAV_BLOCK_NUMBERS;", "        lastBlockTimeStamp = _blockTimestamp;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["    function createLoan(", "        uint256 collateralTokenId,", "        address collateralContractAddress,", "        uint16 maxPerAnumInterest,", "        uint128 minLoanAmount,", "        address loanAssetContractAddress,", "        uint32 minDurationSeconds,", "        address mintBorrowTicketTo", "    )", "        external", "        override", "        returns (uint256 id) ", "    {", "        require(minDurationSeconds != 0, 'NFTLoanFacilitator: 0 duration');", "        require(minLoanAmount != 0, 'NFTLoanFacilitator: 0 loan amount');", "        require(collateralContractAddress != lendTicketContract,", "        'NFTLoanFacilitator: cannot use tickets as collateral');", "        require(collateralContractAddress != borrowTicketContract, ", "        'NFTLoanFacilitator: cannot use tickets as collateral');", "        ", "        IERC721(collateralContractAddress).transferFrom(msg.sender, address(this), collateralTokenId);", "", "        unchecked {", "            id = _nonce++;", "        }", "", "        Loan storage loan = loanInfo[id];", "        loan.loanAssetContractAddress = loanAssetContractAddress;", "        loan.loanAmount = minLoanAmount;", "        loan.collateralTokenId = collateralTokenId;", "        loan.collateralContractAddress = collateralContractAddress;", "        loan.perAnumInterestRate = maxPerAnumInterest;", "        loan.durationSeconds = minDurationSeconds;", "        ", "        IERC721Mintable(borrowTicketContract).mint(mintBorrowTicketTo, id);", "        emit CreateLoan(", "            id,", "            msg.sender,", "            collateralTokenId,", "            collateralContractAddress,", "            maxPerAnumInterest,", "            loanAssetContractAddress,", "            minLoanAmount,", "            minDurationSeconds", "        );", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["\tfunction slash(int256 index) private {", "\t\taddress nodeID = getAddress(keccak256(abi.encodePacked(\"minipool.item\", index, \".nodeID\")));", "\t\taddress owner = getAddress(keccak256(abi.encodePacked(\"minipool.item\", index, \".owner\")));", "\t\tuint256 duration = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".duration\")));", "\t\tuint256 avaxLiquidStakerAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".avaxLiquidStakerAmt\")));", "\t\tuint256 expectedAVAXRewardsAmt = getExpectedAVAXRewardsAmt(duration, avaxLiquidStakerAmt);", "\t\tuint256 slashGGPAmt = calculateGGPSlashAmt(expectedAVAXRewardsAmt);", "\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".ggpSlashAmt\")), slashGGPAmt);", "", "\t\temit GGPSlashed(nodeID, slashGGPAmt);", "", "\t\tStaking staking = Staking(getContractAddress(\"Staking\"));", "\t\tstaking.slashGGP(owner, slashGGPAmt);", "\t}"], "ner_tags": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function bid() external onlyDelegateCall {", "        // Check that the auction is still active.", "        {", "            CrowdfundLifecycle lc = getCrowdfundLifecycle();", "            if (lc != CrowdfundLifecycle.Active) {", "                revert WrongLifecycleError(lc);", "            }", "        }", "        // Mark as busy to prevent `burn()`, `bid()`, and `contribute()`", "        // getting called because this will result in a `CrowdfundLifecycle.Busy`.", "        _bidStatus = AuctionCrowdfundStatus.Busy;", "        // Make sure the auction is not finalized.", "        uint256 auctionId_ = auctionId;", "        if (market.isFinalized(auctionId_)) {", "            revert AuctionFinalizedError(auctionId_);", "        }", "        // Only bid if we are not already the highest bidder.", "        if (market.getCurrentHighestBidder(auctionId_) == address(this)) {", "            revert AlreadyHighestBidderError();", "        }", "        // Get the minimum necessary bid to be the highest bidder.", "        uint96 bidAmount = market.getMinimumBid(auctionId_).safeCastUint256ToUint96();", "        // Make sure the bid is less than the maximum bid.", "        if (bidAmount > maximumBid) {", "            revert ExceedsMaximumBidError(bidAmount, maximumBid);", "        }", "        lastBid = bidAmount;", "        // No need to check that we have `bidAmount` since this will attempt to", "        // transfer `bidAmount` ETH to the auction platform.", "        (bool s, bytes memory r) = address(market).delegatecall(abi.encodeCall(", "            IMarketWrapper.bid,", "            (auctionId_, bidAmount)", "        ));", "        if (!s) {", "            r.rawRevert();", "        }", "        emit Bid(bidAmount);", "", "        _bidStatus = AuctionCrowdfundStatus.Active;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function swapAndStartBridgeTokensViaAnyswap(", "        LiFiData memory _lifiData,", "        LibSwap.SwapData[] calldata _swapData,", "        AnyswapData memory _anyswapData", "    ) public payable {", "        address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();", "        if (_anyswapData.token != address(0) && underlyingToken != IAnyswapRouter(_anyswapData.router).wNATIVE()) {", "            if (underlyingToken == address(0)) {", "                underlyingToken = _anyswapData.token;", "            }", "", "            uint256 _fromTokenBalance = LibAsset.getOwnBalance(underlyingToken);", "", "            // Swap", "            _executeSwaps(_lifiData, _swapData);", "", "            uint256 _postSwapBalance = LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance;", "", "            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");", "", "            _anyswapData.amount = _postSwapBalance;", "        } else {", "            uint256 _fromBalance = address(this).balance;", "", "            // Swap", "            _executeSwaps(_lifiData, _swapData);", "", "            require(address(this).balance - _fromBalance >= _anyswapData.amount, \"ERR_INVALID_AMOUNT\");", "", "            uint256 _postSwapBalance = address(this).balance - _fromBalance;", "", "            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");", "", "            _anyswapData.amount = _postSwapBalance;", "        }", "", "        _startBridge(_anyswapData);", "", "        emit LiFiTransferStarted(", "            _lifiData.transactionId,", "            _lifiData.integrator,", "            _lifiData.referrer,", "            _lifiData.sendingAssetId,", "            _lifiData.receivingAssetId,", "            _lifiData.receiver,", "            _lifiData.amount,", "            _lifiData.destinationChainId,", "            block.timestamp", "        );", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function mint(", "        uint8 p,", "        address u,", "        uint256 m,", "        uint256 a", "    ) public returns (bool) {", "        //use market interface to fetch the market for the given market pair", "        address principal = IMarketPlace(marketPlace).markets(u, m, p);", "        //use safe transfer lib and ERC interface...", "        Safe.transferFrom(IERC20(principal), msg.sender, address(this), a);", "        //use ERC5095 interface...", "        IERC5095(principalToken(u, m)).mint(msg.sender, a);", "", "        emit Mint(p, u, m, a);", "", "        return true;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function _getFees(", "    address nftContract,", "    uint256 tokenId,", "    address payable seller,", "    uint256 price,", "    address payable buyReferrer", "  )", "    private", "    view", "    returns (", "      uint256 totalFees,", "      address payable[] memory creatorRecipients,", "      uint256[] memory creatorShares,", "      uint256 sellerRev,", "      uint256 buyReferrerFee", "    )", "  {", "    // Calculate the protocol fee", "    unchecked {", "      // SafeMath is not required when dividing by a non-zero constant.", "      totalFees = price / PROTOCOL_FEE_DENOMINATOR;", "    }", "", "    address payable creator;", "    try implementationAddress.internalGetTokenCreator(nftContract, tokenId) returns (address payable _creator) {", "      creator = _creator;", "    } catch // solhint-disable-next-line no-empty-blocks", "    {", "      // Fall through", "    }", "", "    try implementationAddress.internalGetImmutableRoyalties(nftContract, tokenId) returns (", "      address payable[] memory _recipients,", "      uint256[] memory _splitPerRecipientInBasisPoints", "    ) {", "      (creatorRecipients, creatorShares) = (_recipients, _splitPerRecipientInBasisPoints);", "    } catch // solhint-disable-next-line no-empty-blocks", "    {", "      // Fall through", "    }", "", "    if (creatorRecipients.length == 0) {", "      // Check mutable royalties only if we didn't find results from the immutable API", "      try implementationAddress.internalGetMutableRoyalties(nftContract, tokenId, creator) returns (", "        address payable[] memory _recipients,", "        uint256[] memory _splitPerRecipientInBasisPoints", "      ) {", "        (creatorRecipients, creatorShares) = (_recipients, _splitPerRecipientInBasisPoints);", "      } catch // solhint-disable-next-line no-empty-blocks", "      {", "        // Fall through", "      }", "    }", "", "    if (creatorRecipients.length != 0 || assumePrimarySale) {", "      uint256 creatorRev;", "      if (assumePrimarySale) {", "        // All revenue should go to the creator recipients", "        unchecked {", "          // totalFees is always < price.", "          creatorRev = price - totalFees;", "        }", "        if (creatorRecipients.length == 0) {", "          // If no creators were found via the royalty APIs, then set that recipient to the seller's address", "          creatorRecipients = new address payable[](1);", "          creatorRecipients[0] = seller;", "          creatorShares = new uint256[](1);", "          // The split amount is assumed to be 100% when only 1 recipient is returned", "        }", "      } else if (seller == creator || (creatorRecipients.length == 1 && seller == creatorRecipients[0])) {", "        // When sold by the creator, all revenue is split if applicable.", "        // If the seller is unknown, assume it's being sold by the creator.", "        unchecked {", "          // totalFees is always < price.", "          creatorRev = price - totalFees;", "        }", "      } else {", "        // Rounding favors the owner first, then creator, and foundation last.", "        unchecked {", "          // SafeMath is not required when dividing by a non-zero constant.", "          creatorRev = price / CREATOR_ROYALTY_DENOMINATOR;", "        }", "        sellerRev = price - totalFees - creatorRev;", "      }", "", "      // Cap the max number of recipients supported", "      creatorRecipients.capLength(MAX_ROYALTY_RECIPIENTS);", "      creatorShares.capLength(MAX_ROYALTY_RECIPIENTS);", "", "      // Sum the total shares defined", "      uint256 totalShares;", "      if (creatorRecipients.length > 1) {", "        unchecked {", "          for (uint256 i = 0; i < creatorRecipients.length; ++i) {", "            if (creatorShares[i] > BASIS_POINTS) {", "              // If the numbers are >100% we ignore the fee recipients and pay just the first instead", "              totalShares = 0;", "              break;", "            }", "            totalShares += creatorShares[i];", "          }", "        }", "", "        if (totalShares == 0) {", "          // If no shares were defined or shares were out of bounds, pay only the first recipient", "          creatorRecipients.capLength(1);", "          creatorShares.capLength(1);", "        }", "      }", "", "      // Send payouts to each additional recipient if more than 1 was defined", "      uint256 totalRoyaltiesDistributed;", "      for (uint256 i = 1; i < creatorRecipients.length; ) {", "        uint256 royalty = (creatorRev * creatorShares[i]) / totalShares;", "        totalRoyaltiesDistributed += royalty;", "        creatorShares[i] = royalty;", "        unchecked {", "          ++i;", "        }", "      }", "", "      // Send the remainder to the 1st creator, rounding in their favor", "      creatorShares[0] = creatorRev - totalRoyaltiesDistributed;", "    } else {", "      // No royalty recipients found.", "      unchecked {", "        // totalFees is always < price.", "        sellerRev = price - totalFees;", "      }", "    }", "", "    if (buyReferrer != address(0) && buyReferrer != msg.sender && buyReferrer != seller && buyReferrer != creator) {", "      unchecked {", "        buyReferrerFee = totalFees / BUY_REFERRER_PROTOCOL_FEE_DENOMINATOR;", "", "        // buyReferrerFee is always <= totalFees", "        totalFees -= buyReferrerFee;", "      }", "    }", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _returnDust() private {", "        uint256 _remainingETH = remainingETH;", "        assembly {", "            if gt(_remainingETH, 0) {", "                let callStatus := call(", "                    gas(),", "                    caller(),", "                    selfbalance(),", "                    0,", "                    0,", "                    0,", "                    0", "                )", "            }", "        }", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function batchRotateLPTokens(", "        address[] calldata _stakingFundsVaults,", "        LPToken[][] calldata _oldLPTokens,", "        LPToken[][] calldata _newLPTokens,", "        uint256[][] calldata _amounts", "    ) external {", "        uint256 numOfRotations = _stakingFundsVaults.length;", "        require(numOfRotations > 0, \"Empty arrays\");", "        require(numOfRotations == _oldLPTokens.length, \"Inconsistent arrays\");", "        require(numOfRotations == _newLPTokens.length, \"Inconsistent arrays\");", "        require(numOfRotations == _amounts.length, \"Inconsistent arrays\");", "        require(lpTokenETH.balanceOf(msg.sender) >= 0.5 ether, \"No common interest\");", "        for (uint256 i; i < numOfRotations; ++i) {", "            StakingFundsVault(payable(_stakingFundsVaults[i])).batchRotateLPTokens(_oldLPTokens[i], _newLPTokens[i], _amounts[i]);", "        }", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _getNewReceiverCooldown(", "        uint256 senderCooldown,", "        uint256 amount,", "        address receiver,", "        uint256 receiverBalance", "    ) internal view returns(uint256) {", "        uint256 receiverCooldown = cooldowns[receiver];", "", "        // If receiver has no cooldown, no need to set a new one", "        if(receiverCooldown == 0) return 0;", "", "        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);", "", "        // If last receiver cooldown is expired, set it back to 0", "        if(receiverCooldown < minValidCooldown) return 0;", "", "        // In case the given senderCooldown is 0 (sender has no cooldown, or minting)", "        uint256 _senderCooldown = senderCooldown < minValidCooldown ? block.timestamp : senderCooldown;", "", "        // If the sender cooldown is better, we keep the receiver cooldown", "        if(_senderCooldown < receiverCooldown) return receiverCooldown;", "", "        // Default new cooldown, weighted average based on the amount and the previous balance", "        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);", "", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["    function withdrawERC721(address _assetAddress, uint256 _assetID, address _to) external override boughtOut {", "        require(msg.sender == bidder,\"NibblVault: Only winner\");", "        IERC721(_assetAddress).safeTransferFrom(address(this), _to, _assetID);", "    }"], "ner_tags": [1, 0, 0, 0]}
{"tokens": ["    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {", "        _grantRole(role, account);", "    }"], "ner_tags": [1, 0, 0]}
{"tokens": ["    function settleBadDebt(address trader) external whenNotPaused {", "        (uint256 notionalPosition,) = clearingHouse.getTotalNotionalPositionAndUnrealizedPnl(trader);", "        require(notionalPosition == 0, \"Liquidate positions before settling bad debt\");", "", "        // The spot value of their collateral minus their vUSD obligation is a negative value", "        require(getSpotCollateralValue(trader) < 0, \"Above bad debt threshold\");", "", "        int vusdBal = margin[VUSD_IDX][trader];", "", "        // this check is not strictly required because getSpotCollateralValue(trader) < 0 is a stronger assertion", "        require(vusdBal < 0, \"Nothing to repay\");", "", "        uint badDebt = (-vusdBal).toUint256();", "        Collateral[] memory assets = supportedCollateral;", "", "        // This pulls the obligation", "        insuranceFund.seizeBadDebt(badDebt);", "        margin[VUSD_IDX][trader] = 0;", "", "        // Insurance fund gets all the available collateral", "        uint[] memory seized = new uint[](assets.length);", "        for (uint i = 1 /* skip vusd */; i < assets.length; i++) {", "            int amount = margin[i][trader];", "            if (amount > 0) {", "                margin[i][trader] = 0;", "                assets[i].token.safeTransfer(address(insuranceFund), amount.toUint256());", "                seized[i] = amount.toUint256();", "            }", "        }", "        emit SettledBadDebt(trader, seized, badDebt, _blockTimestamp());", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function repay(address user, uint amount) public {", "        uint debt = debts[user];", "        require(debt >= amount, \"Insufficient debt\");", "        debts[user] -= amount;", "        totalDebt -= amount;", "        dbr.onRepay(user, amount);", "        dola.transferFrom(msg.sender, address(this), amount);", "        emit Repay(user, msg.sender, amount);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function processBidsInQueue(", "        uint256 _poolId,", "        uint256 _quantity,", "        uint256 _price", "    ) private returns (uint256 quantity) {", "        quantity = _quantity;", "        while (quantity > 0) {", "            // Retrieves lowest bid in queue", "            Bid storage lowestBid = bidPriorityQueues[_poolId].getMin();", "            // Breaks out of while loop if given price is less than than lowest bid price", "            if (_price < lowestBid.price) {", "                break;", "            }", "", "            uint256 lowestBidQuantity = lowestBid.quantity;", "            // Checks if lowest bid quantity amount is greater than given quantity amount", "            if (lowestBidQuantity > quantity) {", "                // Decrements given quantity amount from lowest bid quantity", "                lowestBid.quantity -= quantity;", "                // Calculates partial contribution of bid by quantity amount and price", "                uint256 contribution = quantity * lowestBid.price;", "", "                // Decrements partial contribution amount of lowest bid from total and user contributions", "                totalContributions[_poolId] -= contribution;", "                userContributions[_poolId][lowestBid.owner] -= contribution;", "                // Increments pending balance of lowest bid owner", "                pendingBalances[lowestBid.owner] += contribution;", "", "                // Inserts new bid with given quantity amount into proper position of queue", "                bidPriorityQueues[_poolId].insert(msg.sender, _price, quantity);", "                // Resets quantity amount to exit while loop", "                quantity = 0;", "            } else {", "                // Calculates total contribution of bid by quantity amount and price", "                uint256 contribution = lowestBid.quantity * lowestBid.price;", "", "                // Decrements full contribution amount of lowest bid from total and user contributions", "                totalContributions[_poolId] -= contribution;", "                userContributions[_poolId][lowestBid.owner] -= contribution;", "                // Increments pending balance of lowest bid owner", "                pendingBalances[lowestBid.owner] += contribution;", "", "                // Removes lowest bid in queue", "                bidPriorityQueues[_poolId].delMin();", "                // Inserts new bid with lowest bid quantity amount into proper position of queue", "                bidPriorityQueues[_poolId].insert(msg.sender, _price, lowestBidQuantity);", "                // Decrements lowest bid quantity from total quantity amount", "                quantity -= lowestBidQuantity;", "            }", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _extraordinaryProposalSucceeded(", "        uint256 proposalId_,", "        uint256 tokensRequested_", "    ) internal view returns (bool) {", "        uint256 votesReceived          = uint256(_extraordinaryFundingProposals[proposalId_].votesReceived);", "        uint256 minThresholdPercentage = _getMinimumThresholdPercentage();", "", "        return", "            // succeeded if proposal's votes received doesn't exceed the minimum threshold required", "            (votesReceived >= tokensRequested_ + _getSliceOfNonTreasury(minThresholdPercentage))", "            &&", "            // succeeded if tokens requested are available for claiming from the treasury", "            (tokensRequested_ <= _getSliceOfTreasury(Maths.WAD - minThresholdPercentage))", "        ;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function withdrawBalance() public {", "        // Reverts if caller balance is insufficient", "        uint256 balance = pendingBalances[msg.sender];", "        if (balance == 0) revert InsufficientBalance();", "", "        // Resets pending balance amount", "        delete pendingBalances[msg.sender];", "", "        // Transfers pending ether balance to caller", "        payable(msg.sender).call{value: balance}(\"\");", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["  constructor(", "    uint8 _decimals,", "    string memory _description,", "    IGUniPool _pool,", "    AggregatorV3Interface _oracleA,", "    AggregatorV3Interface _oracleB", "  ) public {", "    require(address(_pool) != address(0), \"C000\");", "    require(address(_oracleA) != address(0), \"C000\");", "    require(address(_oracleB) != address(0), \"C000\");", "", "    decimals = _decimals;", "    description = _description;", "    pool = _pool;", "    oracleA = _oracleA;", "    oracleB = _oracleB;", "", "    uint256 decimalsA = ERC20(_pool.token0()).decimals();", "    _tokenDecimalsUnitA = 10**decimalsA;", "    _tokenDecimalsOffsetA = 10**(18 - decimalsA);", "", "    uint256 decimalsB = ERC20(_pool.token1()).decimals();", "    _tokenDecimalsUnitB = 10**decimalsB;", "    _tokenDecimalsOffsetB = 10**(18 - decimalsB);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0]}
{"tokens": ["    function swapPoolsAssets(", "        address[] calldata markets,", "        uint256[] calldata amountsOutMin,", "        address[][] calldata paths", "    ) external override returns (uint256) {", "        _checkAccessAllowed(\"swapPoolsAssets(address[],uint256[],address[][])\");", "        require(poolRegistry != address(0), \"Risk fund: Invalid pool registry.\");", "        require(markets.length == amountsOutMin.length, \"Risk fund: markets and amountsOutMin are unequal lengths\");", "        require(markets.length == paths.length, \"Risk fund: markets and paths are unequal lengths\");", "", "        uint256 totalAmount;", "        uint256 marketsCount = markets.length;", "", "        _ensureMaxLoops(marketsCount);", "", "        for (uint256 i; i < marketsCount; ++i) {", "            VToken vToken = VToken(markets[i]);", "            address comptroller = address(vToken.comptroller());", "", "            PoolRegistry.VenusPool memory pool = PoolRegistry(poolRegistry).getPoolByComptroller(comptroller);", "            require(pool.comptroller == comptroller, \"comptroller doesn't exist pool registry\");", "            require(Comptroller(comptroller).isMarketListed(vToken), \"market is not listed\");", "", "            uint256 swappedTokens = _swapAsset(vToken, comptroller, amountsOutMin[i], paths[i]);", "            poolReserves[comptroller] = poolReserves[comptroller] + swappedTokens;", "            totalAmount = totalAmount + swappedTokens;", "        }", "", "        emit SwappedPoolsAssets(markets, amountsOutMin, totalAmount);", "", "        return totalAmount;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function withdraw(address _nft, uint256[] calldata tokenIds, address token, uint256 tokenAmount) public onlyOwner {", "        // ~~~ Interactions ~~~ //", "", "        // transfer the nfts to the caller", "        for (uint256 i = 0; i < tokenIds.length; i++) {", "            ERC721(_nft).safeTransferFrom(address(this), msg.sender, tokenIds[i]);", "        }", "", "        if (token == address(0)) {", "            // transfer the ETH to the caller", "            msg.sender.safeTransferETH(tokenAmount);", "        } else {", "            // transfer the tokens to the caller", "            ERC20(token).transfer(msg.sender, tokenAmount);", "        }", "", "        // emit the withdraw event", "        emit Withdraw(_nft, tokenIds, token, tokenAmount);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _calcAuction(", "        DataTypes.Vault memory vault,", "        DataTypes.Series memory series,", "        address to,", "        DataTypes.Balances memory balances,", "        DataTypes.Debt memory debt", "    ) internal view returns (DataTypes.Auction memory) {", "        // We store the proportion of the vault to auction, which is the whole vault if the debt would be below dust.", "        DataTypes.Line storage line = lines[vault.ilkId][series.baseId];", "        uint128 art = uint256(balances.art).wmul(line.proportion).u128();", "        if (art < debt.min * (10**debt.dec)) art = balances.art;", "        uint128 ink = (art == balances.art)", "            ? balances.ink", "            : uint256(balances.ink).wmul(line.proportion).u128();", "", "        return", "            DataTypes.Auction({", "                owner: vault.owner,", "                start: uint32(block.timestamp), // Overflow is fine", "                seriesId: vault.seriesId,", "                baseId: series.baseId,", "                ilkId: vault.ilkId,", "                art: art,", "                ink: ink,", "                auctioneer: to", "            });", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function setParams(bytes32 what, uint64 param) external onlyGuardian {", "        if (param > BASE_9) revert InvalidParam();", "        else if (what == \"PF\") protocolSafetyFee = param;", "        else if (what == \"VP\") vestingPeriod = uint32(param);", "        else if (what == \"UD\") updateDelay = uint32(param);", "        else if (what == \"P\") paused = uint8(param);", "        else revert InvalidParam();", "        emit FiledUint64(param, what);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function recordAddTiers(JB721TierParams[] memory _tiersToAdd)", "    external", "    override", "    returns (uint256[] memory tierIds)", "  {", "    // Get a reference to the number of new tiers.", "    uint256 _numberOfNewTiers = _tiersToAdd.length;", "", "    // Keep a reference to the greatest tier ID.", "    uint256 _currentMaxTierIdOf = maxTierIdOf[msg.sender];", "", "    // Keep a reference to the current last sorted tier ID.", "    uint256 _currentLastSortIndex = _lastSortIndexOf(msg.sender);", "", "    // Initialize an array with the appropriate length.", "    tierIds = new uint256[](_numberOfNewTiers);", "", "    // Keep a reference to the starting sort ID for sorting new tiers if needed.", "    // There's no need for sorting if there are currently no tiers.", "    // If there's no sort index, start with the first index.", "    uint256 _startSortIndex = _currentMaxTierIdOf == 0 ? 0 : _firstSortIndexOf(msg.sender);", "", "    // Keep track of the previous index.", "    uint256 _previous;", "", "    // Keep a reference to the tier being iterated on.", "    JB721TierParams memory _tierToAdd;", "", "    // Keep a reference to the flags.", "    JBTiered721Flags memory _flags = _flagsOf[msg.sender];", "", "    for (uint256 _i; _i < _numberOfNewTiers; ) {", "      // Set the tier being iterated on.", "      _tierToAdd = _tiersToAdd[_i];", "", "      // Make sure the tier's contribution floor is greater than or equal to the previous contribution floor.", "      if (_i != 0 && _tierToAdd.contributionFloor < _tiersToAdd[_i - 1].contributionFloor)", "        revert INVALID_PRICE_SORT_ORDER();", "", "      // Make sure there are no voting units set if they're not allowed.", "      if (_flags.lockVotingUnitChanges && _tierToAdd.votingUnits != 0)", "        revert VOTING_UNITS_NOT_ALLOWED();", "", "      // Make sure a reserved rate isn't set if changes should be locked or if manual minting is allowed.", "      if (", "        (_flags.lockReservedTokenChanges || _tierToAdd.allowManualMint) &&", "        _tierToAdd.reservedRate != 0", "      ) revert RESERVED_RATE_NOT_ALLOWED();", "", "      // Make sure manual minting is not set if not allowed.", "      if (_flags.lockManualMintingChanges && _tierToAdd.allowManualMint)", "        revert MANUAL_MINTING_NOT_ALLOWED();", "", "      // Make sure there is some quantity.", "      if (_tierToAdd.initialQuantity == 0) revert NO_QUANTITY();", "", "      // Get a reference to the tier ID.", "      uint256 _tierId = _currentMaxTierIdOf + _i + 1;", "", "      // Add the tier with the iterative ID.", "      _storedTierOf[msg.sender][_tierId] = JBStored721Tier({", "        contributionFloor: uint80(_tierToAdd.contributionFloor),", "        lockedUntil: uint48(_tierToAdd.lockedUntil),", "        remainingQuantity: uint40(_tierToAdd.initialQuantity),", "        initialQuantity: uint40(_tierToAdd.initialQuantity),", "        votingUnits: uint16(_tierToAdd.votingUnits),", "        reservedRate: uint16(_tierToAdd.reservedRate),", "        allowManualMint: _tierToAdd.allowManualMint", "      });", "", "      // Set the reserved token beneficiary if needed.", "      if (", "        _tierToAdd.reservedTokenBeneficiary != address(0) &&", "        _tierToAdd.reservedTokenBeneficiary != defaultReservedTokenBeneficiaryOf[msg.sender]", "      ) {", "        if (_tierToAdd.shouldUseBeneficiaryAsDefault)", "          defaultReservedTokenBeneficiaryOf[msg.sender] = _tierToAdd.reservedTokenBeneficiary;", "        else _reservedTokenBeneficiaryOf[msg.sender][_tierId] = _tierToAdd.reservedTokenBeneficiary;", "      }", "", "      // Set the encodedIPFSUri if needed.", "      if (_tierToAdd.encodedIPFSUri != bytes32(0))", "        encodedIPFSUriOf[msg.sender][_tierId] = _tierToAdd.encodedIPFSUri;", "", "      if (_startSortIndex != 0) {", "        // Keep track of the sort index.", "        uint256 _currentSortIndex = _startSortIndex;", "", "        // Initialise a BitmapWord for isRemoved", "        JBBitmapWord memory _bitmapWord = _isTierRemoved[msg.sender].readId(_currentSortIndex);", "", "        // Keep a reference to the idex to iterate on next.", "        uint256 _next;", "", "        while (_currentSortIndex != 0) {", "          // Is the current index outside the currently stored word?", "          if (_bitmapWord.refreshBitmapNeeded(_currentSortIndex))", "            _bitmapWord = _isTierRemoved[msg.sender].readId(_currentSortIndex);", "", "          // Set the next index.", "          _next = _nextSortIndex(msg.sender, _currentSortIndex, _currentLastSortIndex);", "", "          // If the contribution floor is less than the tier being iterated on, store the order.", "          if (", "            _tierToAdd.contributionFloor <", "            _storedTierOf[msg.sender][_currentSortIndex].contributionFloor", "          ) {", "            // If the index being iterated on isn't the next index, set the after.", "            if (_currentSortIndex != _tierId + 1)", "              _tierIdAfter[msg.sender][_tierId] = _currentSortIndex;", "", "            // If this is the last tier being added, track the current last sort index if it's not already tracked.", "            if (", "              _i == _numberOfNewTiers - 1 && ", "              _trackedLastSortTierIdOf[msg.sender] != _currentLastSortIndex", "            ) _trackedLastSortTierIdOf[msg.sender] = _currentLastSortIndex;", "", "            // If the previous after index was set to something else, set the previous after.", "            if (_previous != _tierId - 1 || _tierIdAfter[msg.sender][_previous] != 0)", "              // Set the tier after the previous one being iterated on as the tier being added, or 0 if the index is incremented.", "              _tierIdAfter[msg.sender][_previous] = _previous == _tierId - 1 ? 0 : _tierId;", "", "            // For the next tier being added, start at this current index.", "            _startSortIndex = _currentSortIndex;", "", "            // The tier just added is the previous for the next tier being added.", "            _previous = _tierId;", "", "            // Set current to zero to break out of the loop.", "            _currentSortIndex = 0;", "          }", "          // If the tier being iterated on is the last tier, add the tier after it.", "          else if (_next == 0 || _next > _currentMaxTierIdOf) {", "            if (_tierId != _currentSortIndex + 1)", "              _tierIdAfter[msg.sender][_currentSortIndex] = _tierId;", "", "            // For the next tier being added, start at this current index.", "            _startSortIndex = _tierId;", "", "            // Break out.", "            _currentSortIndex = 0;", "", "            // If there's currently a last sort index tracked, override it.", "            if (_trackedLastSortTierIdOf[msg.sender] != 0) ", "              _trackedLastSortTierIdOf[msg.sender] = 0;", "          }", "          // Move on to the next index.", "          else {", "            // Set the previous index to be the current index.", "            _previous = _currentSortIndex;", "", "            // Go to the next index.", "            _currentSortIndex = _next;", "          }", "        }", "      }", "", "      // Set the tier ID in the returned value.", "      tierIds[_i] = _tierId;", "", "      unchecked {", "        ++_i;", "      }", "    }", "", "    maxTierIdOf[msg.sender] = _currentMaxTierIdOf + _numberOfNewTiers;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _transfer(address from, address to, uint256 amount) internal override {", "        if (from == address(0)) {", "            revert Errors.ERC20_TRANSFER_FROM_THE_ZERO_ADDRESS();", "        }", "        if (to == address(0)) {", "            revert Errors.ERC20_TRANSER_TO_THE_ZERO_ADDRESS();", "        }", "        _refreshCumulativeYield();", "        _refreshYield();", "", "        uint256 startingFromBalance = this.balanceOf(from);", "        if (startingFromBalance < amount) {", "            revert Errors.ERC20_TRANSFER_AMOUNT_EXCEEDS_BALANCE();", "        }", "        uint256 newFromBalance = startingFromBalance - amount;", "        uint256 newToBalance = this.balanceOf(to) + amount;", "", "        uint256 previousEpochCumulativeYield_ = _previousEpochCumulativeYield;", "        uint256 newFromBaseBalance = WadRayMath.wadToRay(newFromBalance).rayDiv(previousEpochCumulativeYield_);", "        uint256 newToBaseBalance = WadRayMath.wadToRay(newToBalance).rayDiv(previousEpochCumulativeYield_);", "", "        if (amount > 0) {", "            _totalBaseSupply -= (_baseBalances[from] - newFromBaseBalance);", "            _totalBaseSupply += (newToBaseBalance - _baseBalances[to]);", "            _baseBalances[from] = newFromBaseBalance;", "            _baseBalances[to] = newToBaseBalance;", "        }", "", "        emit Transfer(from, to, amount);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0]}
{"tokens": ["    function raiseDispute(bytes calldata _data, bytes calldata _signature)", "        external", "        override", "        onlyProject", "    {", "        // Recover signer from signature", "        address _signer = SignatureDecoder.recoverKey(", "            keccak256(_data),", "            _signature,", "            0", "        );", "", "        // Decode params from _data", "        (", "            address _project,", "            uint256 _taskID,", "            uint8 _actionType,", "            bytes memory _actionData,", "            bytes memory _reason", "        ) = abi.decode(_data, (address, uint256, uint8, bytes, bytes));", "", "        // Revert if _actionType is invalid", "        require(", "            _actionType > 0 && _actionType <= uint8(ActionType.TaskPay),", "            \"Disputes::!ActionType\"", "        );", "", "        // Store dispute details", "        Dispute storage _dispute = disputes[disputeCount];", "        _dispute.status = Status.Active;", "        _dispute.project = _project;", "        _dispute.taskID = _taskID;", "        _dispute.raisedBy = _signer;", "        _dispute.actionType = ActionType(_actionType);", "        _dispute.actionData = _actionData;", "", "        // Increment dispute counter and emit event", "        emit DisputeRaised(disputeCount++, _reason);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _startBridge(CBridgeData memory _cBridgeData) internal {", "        Storage storage s = getStorage();", "        address bridge = _bridge();", "", "        // Do CBridge stuff", "        require(s.cBridgeChainId != _cBridgeData.dstChainId, \"Cannot bridge to the same network.\");", "", "        if (LibAsset.isNativeAsset(_cBridgeData.token)) {", "            ICBridge(bridge).sendNative(", "                _cBridgeData.receiver,", "                _cBridgeData.amount,", "                _cBridgeData.dstChainId,", "                _cBridgeData.nonce,", "                _cBridgeData.maxSlippage", "            );", "        } else {", "            // Give CBridge approval to bridge tokens", "            LibAsset.approveERC20(IERC20(_cBridgeData.token), bridge, _cBridgeData.amount);", "            // solhint-disable check-send-result", "            ICBridge(bridge).send(", "                _cBridgeData.receiver,", "                _cBridgeData.token,", "                _cBridgeData.amount,", "                _cBridgeData.dstChainId,", "                _cBridgeData.nonce,", "                _cBridgeData.maxSlippage", "            );", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function _execute(", "    address tokenContract, // collateral token sending the fake nft", "    address to, // buyer", "    uint256 encodedMetaData, //retrieve token address from the encoded data", "    uint256 // space to encode whatever is needed,", "  ) internal {", "    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0)); // get the router from the immutable arg", "", "    ClearingHouseStorage storage s = _getStorage();", "    address paymentToken = bytes32(encodedMetaData).fromLast20Bytes();", "", "    uint256 currentOfferPrice = _locateCurrentAmount({", "      startAmount: s.auctionStack.startAmount,", "      endAmount: s.auctionStack.endAmount,", "      startTime: s.auctionStack.startTime,", "      endTime: s.auctionStack.endTime,", "      roundUp: true //we are a consideration we round up", "    });", "    uint256 payment = ERC20(paymentToken).balanceOf(address(this));", "", "    require(payment >= currentOfferPrice, \"not enough funds received\");", "", "    uint256 collateralId = _getArgUint256(21);", "    // pay liquidator fees here", "", "    ILienToken.AuctionStack[] storage stack = s.auctionStack.stack;", "", "    uint256 liquidatorPayment = ASTARIA_ROUTER.getLiquidatorFee(payment);", "", "    ERC20(paymentToken).safeTransfer(", "      s.auctionStack.liquidator,", "      liquidatorPayment", "    );", "", "    ERC20(paymentToken).safeApprove(", "      address(ASTARIA_ROUTER.TRANSFER_PROXY()),", "      payment - liquidatorPayment", "    );", "", "    ASTARIA_ROUTER.LIEN_TOKEN().payDebtViaClearingHouse(", "      paymentToken,", "      collateralId,", "      payment - liquidatorPayment,", "      s.auctionStack.stack", "    );", "", "    if (ERC20(paymentToken).balanceOf(address(this)) > 0) {", "      ERC20(paymentToken).safeTransfer(", "        ASTARIA_ROUTER.COLLATERAL_TOKEN().ownerOf(collateralId),", "        ERC20(paymentToken).balanceOf(address(this))", "      );", "    }", "    ASTARIA_ROUTER.COLLATERAL_TOKEN().settleAuction(collateralId);", "  }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function buy(", "        uint256 _tokenInAmount,", "        uint8 _daoId,", "        bytes32[] calldata _proof", "    ) external whenNotPaused returns (uint256 tokenOutAmount_) {", "        require(saleStart <= block.timestamp, \"TokenSale: not started\");", "        require(", "            block.timestamp < saleStart + saleDuration,", "            \"TokenSale: already ended\"", "        );", "        require(_tokenInAmount > 0, \"_tokenInAmount should be > 0\");", "        require(", "            totalTokenIn + _tokenInAmount <= tokenInLimit,", "            \"total amount exceeded\"", "        );", "", "        if (address(guestlist) != address(0)) {", "            require(guestlist.authorized(msg.sender, _proof), \"not authorized\");", "        }", "", "        uint256 boughtAmountTillNow = boughtAmounts[msg.sender];", "", "        if (boughtAmountTillNow > 0) {", "            require(", "                _daoId == daoVotedFor[msg.sender],", "                \"can't vote for multiple daos\"", "            );", "        } else {", "            daoVotedFor[msg.sender] = _daoId;", "        }", "", "        tokenOutAmount_ = getAmountOut(_tokenInAmount);", "", "        boughtAmounts[msg.sender] = boughtAmountTillNow + tokenOutAmount_;", "        daoCommitments[_daoId] += tokenOutAmount_;", "", "        totalTokenIn += _tokenInAmount;", "        totalTokenOutBought += tokenOutAmount_;", "", "        tokenIn.safeTransferFrom(msg.sender, saleRecipient, _tokenInAmount);", "", "        emit Sale(msg.sender, _daoId, _tokenInAmount, tokenOutAmount_);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": ["    function setCushionFactor(uint32 cushionFactor_) external onlyRole(\"operator_policy\") {", "        /// Confirm factor is within allowed values", "        if (cushionFactor_ > 10000 || cushionFactor_ < 100) revert Operator_InvalidParams();", "", "        /// Set factor", "        _config.cushionFactor = cushionFactor_;", "", "        emit CushionFactorChanged(cushionFactor_);", "    }"], "ner_tags": [0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function _execMatchOrders(", "    bytes32 sellOrderHash,", "    bytes32 buyOrderHash,", "    OrderTypes.MakerOrder calldata sell,", "    OrderTypes.MakerOrder calldata buy,", "    OrderTypes.OrderItem[] calldata constructedNfts,", "    uint256 startGasPerOrder,", "    uint256 execPrice,", "    uint16 protocolFeeBps,", "    uint32 wethTransferGasUnits,", "    address weth", "  ) internal {", "    uint256 protocolFee = (protocolFeeBps * execPrice) / 10000;", "    uint256 remainingAmount = execPrice - protocolFee;", "    _execMatchOrder(", "      sell.signer,", "      buy.signer,", "      sell.constraints[5],", "      buy.constraints[5],", "      constructedNfts,", "      buy.execParams[1],", "      remainingAmount", "    );", "    _emitMatchEvent(", "      sellOrderHash,", "      buyOrderHash,", "      sell.signer,", "      buy.signer,", "      buy.execParams[0],", "      buy.execParams[1],", "      execPrice", "    );", "    uint256 gasCost = (startGasPerOrder - gasleft() + wethTransferGasUnits) * tx.gasprice;", "    // if the execution currency is weth, we can send the protocol fee and gas cost in one transfer to save gas", "    // else we need to send the protocol fee separately in the execution currency", "    if (buy.execParams[1] == weth) {", "      IERC20(weth).safeTransferFrom(buy.signer, address(this), protocolFee + gasCost);", "    } else {", "      IERC20(buy.execParams[1]).safeTransferFrom(buy.signer, address(this), protocolFee);", "      IERC20(weth).safeTransferFrom(buy.signer, address(this), gasCost);", "    }", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": ["    function safeConcurTransfer(address _to, uint _amount) private {", "        uint concurBalance = concur.balanceOf(address(this));", "        bool transferSuccess = false;", "        if (_amount > concurBalance) {", "            transferSuccess = concur.transfer(_to, concurBalance);", "        } else {", "            transferSuccess = concur.transfer(_to, _amount);", "        }", "        require(transferSuccess, \"safeConcurTransfer: transfer failed\");", "    }"], "ner_tags": [0, 0, 0, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function withdrawToken(uint amount, uint tokenId) public lock {", "        totalSupply -= amount;", "        balanceOf[msg.sender] -= amount;", "        _safeTransfer(stake, msg.sender, amount);", "", "        if (tokenId > 0) {", "            require(tokenId == tokenIds[msg.sender]);", "            tokenIds[msg.sender] = 0;", "            IVoter(voter).detachTokenFromGauge(tokenId, msg.sender);", "        } else {", "            tokenId = tokenIds[msg.sender];", "        }", "", "        uint _derivedBalance = derivedBalances[msg.sender];", "        derivedSupply -= _derivedBalance;", "        _derivedBalance = derivedBalance(msg.sender);", "        derivedBalances[msg.sender] = _derivedBalance;", "        derivedSupply += _derivedBalance;", "", "        _writeCheckpoint(msg.sender, derivedBalances[msg.sender]);", "        _writeSupplyCheckpoint();", "", "        IVoter(voter).emitWithdraw(tokenId, msg.sender, amount);", "        emit Withdraw(msg.sender, tokenId, amount);", "    }"], "ner_tags": [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["\tfunction recordStakingStart(", "\t\taddress nodeID,", "\t\tbytes32 txID,", "\t\tuint256 startTime", "\t) external {", "\t\tint256 minipoolIndex = onlyValidMultisig(nodeID);", "\t\trequireValidStateTransition(minipoolIndex, MinipoolStatus.Staking);", "\t\tif (startTime > block.timestamp) {", "\t\t\trevert InvalidStartTime();", "\t\t}", "", "\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".status\")), uint256(MinipoolStatus.Staking));", "\t\tsetBytes32(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".txID\")), txID);", "\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".startTime\")), startTime);", "", "\t\t// If this is the first of many cycles, set the initialStartTime", "\t\tuint256 initialStartTime = getUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".initialStartTime\")));", "\t\tif (initialStartTime == 0) {", "\t\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".initialStartTime\")), startTime);", "\t\t}", "", "\t\taddress owner = getAddress(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".owner\")));", "\t\tuint256 avaxLiquidStakerAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxLiquidStakerAmt\")));", "\t\tStaking staking = Staking(getContractAddress(\"Staking\"));", "\t\tif (staking.getAVAXAssignedHighWater(owner) < staking.getAVAXAssigned(owner)) {", "\t\t\tstaking.increaseAVAXAssignedHighWater(owner, avaxLiquidStakerAmt);", "\t\t}", "", "\t\temit MinipoolStatusChanged(nodeID, MinipoolStatus.Staking);", "\t}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["    function addQuote(uint256 baseTokenAmount, uint256 fractionalTokenAmount) public view returns (uint256) {", "        uint256 lpTokenSupply = lpToken.totalSupply();", "        if (lpTokenSupply > 0) {", "            // calculate amount of lp tokens as a fraction of existing reserves", "            uint256 baseTokenShare = (baseTokenAmount * lpTokenSupply) / baseTokenReserves();", "            uint256 fractionalTokenShare = (fractionalTokenAmount * lpTokenSupply) / fractionalTokenReserves();", "            return Math.min(baseTokenShare, fractionalTokenShare);", "        } else {", "            // if there is no liquidity then init", "            return Math.sqrt(baseTokenAmount * fractionalTokenAmount);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function deposit(uint value, address _depositor, bool max_buy) external returns (uint) {", "        // amount of mute tokens", "        uint payout = payoutFor( value );", "        if(max_buy == true){", "          value = maxPurchaseAmount();", "          payout = maxDeposit();", "        } else {", "          // safety checks for custom purchase", "          require( payout >= ((10**18) / 100), \"Bond too small\" ); // must be > 0.01 payout token ( underflow protection )", "          require( payout <= maxPayout, \"Bond too large\"); // size protection because there is no slippage", "          require( payout <= maxDeposit(), \"Deposit too large\"); // size protection because there is no slippage", "        }", "", "", "        // total debt is increased", "        totalDebt = totalDebt.add( value );", "        totalPayoutGiven = totalPayoutGiven.add(payout); // total payout increased", "", "        customTreasury.sendPayoutTokens(payout);", "        TransferHelper.safeTransferFrom(lpToken, msg.sender, address(customTreasury), value ); // transfer principal bonded to custom treasury", "", "        // indexed events are emitted", "        emit BondCreated(value, payout, _depositor, block.timestamp);", "", "        bonds.push(Bonds(value, payout, _depositor, block.timestamp));", "        // redeem bond for user, mint dMute tokens for duration of vest period", "        IDMute(dMuteToken).LockTo(payout, bond_time_lock, _depositor);", "", "        terms[epoch].payoutTotal = terms[epoch].payoutTotal + payout;", "        terms[epoch].bondTotal = terms[epoch].bondTotal + value;", "        terms[epoch].lastTimestamp = block.timestamp;", "", "        // adjust price by a ~5% premium of delta", "        uint timeElapsed = block.timestamp - epochStart;", "        epochStart = epochStart.add(timeElapsed.mul(5).div(100));", "        // safety check", "        if(epochStart >= block.timestamp)", "          epochStart = block.timestamp;", "", "        // exhausted this bond, issue new one", "        if(terms[epoch].payoutTotal == maxPayout){", "            terms.push(BondTerms(0,0,0));", "            epochStart = block.timestamp;", "            epoch++;", "        }", "", "        return payout;", "    }"], "ner_tags": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _end(Sale memory _sale) internal {", "        emit End(_sale);", "        ISaleFactory(factory).feeReceiver().transfer(address(this).balance / 20);", "        selfdestruct(_sale.saleReceiver);", "    }"], "ner_tags": [0, 0, 0, 1, 0]}
{"tokens": ["  modifier onlyOwner(uint256 collateralId) {", "    require(ownerOf(collateralId) == msg.sender);", "    _;", "  }"], "ner_tags": [0, 1, 0, 0]}
{"tokens": ["  function _tokenToShares(uint256 _tokens) internal view returns (uint256) {", "    uint256 _supply = totalSupply();", "", "    // shares = (tokens * totalShares) / yieldSourceATokenTotalSupply", "    return _supply == 0 ? _tokens : _tokens.mul(_supply).div(aToken.balanceOf(address(this)));", "  }"], "ner_tags": [1, 1, 1, 1, 1, 1]}
{"tokens": ["    function close(bytes32 id) external payable override returns (bool) {", "        Credit memory credit = credits[id];", "        address b = borrower; // gas savings", "        if(msg.sender != credit.lender && msg.sender != b) {", "          revert CallerAccessDenied();", "        }", "", "        // ensure all money owed is accounted for. Accrue facility fee since prinicpal was paid off", "        credit = _accrue(credit, id);", "        uint256 facilityFee = credit.interestAccrued;", "        if(facilityFee > 0) {", "          // only allow repaying interest since they are skipping repayment queue.", "          // If principal still owed, _close() MUST fail", "          LineLib.receiveTokenOrETH(credit.token, b, facilityFee);", "", "          credit = _repay(credit, id, facilityFee);", "        }", "", "        _close(credit, id); // deleted; no need to save to storage", "", "        return true;", "    }"], "ner_tags": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function rescueTokens(address tokenToRescue, address to, uint256 amount) external virtual onlyOwner nonReentrant {", "        if (tokenToRescue == lpToken) {", "            require(amount <= IERC20(lpToken).balanceOf(address(this)).sub(_totalStakeLpToken),", "                \"MuteAmplifier::rescueTokens: that Token-Eth belongs to stakers\"", "            );", "        } else if (tokenToRescue == muteToken) {", "            if (totalStakers > 0) {", "                require(amount <= IERC20(muteToken).balanceOf(address(this)).sub(totalRewards.sub(totalClaimedRewards)),", "                    \"MuteAmplifier::rescueTokens: that muteToken belongs to stakers\"", "                );", "            }", "        }", "", "        IERC20(tokenToRescue).transfer(to, amount);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": ["    function executeAction(Actions action_, address target_) external onlyExecutor {", "        if (action_ == Actions.InstallModule) {", "            ensureContract(target_);", "            ensureValidKeycode(Module(target_).KEYCODE());", "            _installModule(Module(target_));", "        } else if (action_ == Actions.UpgradeModule) {", "            ensureContract(target_);", "            ensureValidKeycode(Module(target_).KEYCODE());", "            _upgradeModule(Module(target_));", "        } else if (action_ == Actions.ActivatePolicy) {", "            ensureContract(target_);", "            _activatePolicy(Policy(target_));", "        } else if (action_ == Actions.DeactivatePolicy) {", "            ensureContract(target_);", "            _deactivatePolicy(Policy(target_));", "        } else if (action_ == Actions.ChangeExecutor) {", "            executor = target_;", "        } else if (action_ == Actions.ChangeAdmin) {", "            admin = target_;", "        } else if (action_ == Actions.MigrateKernel) {", "            ensureContract(target_);", "            _migrateKernel(Kernel(target_));", "        }", "", "        emit ActionExecuted(action_, target_);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function getReward(", "        address _account,", "        address _token,", "        uint256 _startIndex", "    ) public {", "        _getReward(_account, _token, _startIndex);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _swapSupportingFeeOnTransferTokens(", "        address[] memory _pairs,", "        uint256[] memory _pairBinSteps,", "        IERC20[] memory _tokenPath,", "        address _to", "    ) private {", "        IERC20 _token;", "        uint256 _binStep;", "        address _recipient;", "        address _pair;", "", "        IERC20 _tokenNext = _tokenPath[0];", "", "        unchecked {", "            for (uint256 i; i < _pairs.length; ++i) {", "                _pair = _pairs[i];", "                _binStep = _pairBinSteps[i];", "", "                _token = _tokenNext;", "                _tokenNext = _tokenPath[i + 1];", "", "                _recipient = i + 1 == _pairs.length ? _to : _pairs[i + 1];", "", "                if (_binStep == 0) {", "                    (uint256 _reserve0, uint256 _reserve1, ) = IJoePair(_pair).getReserves();", "                    if (_token < _tokenNext) {", "                        uint256 _balance = _token.balanceOf(_pair);", "                        uint256 _amountOut = (_reserve1 * (_balance - _reserve0) * 997) / (_balance * 1_000);", "", "                        IJoePair(_pair).swap(0, _amountOut, _recipient, \"\");", "                    } else {", "                        uint256 _balance = _token.balanceOf(_pair);", "                        uint256 _amountOut = (_reserve0 * (_balance - _reserve1) * 997) / (_balance * 1_000);", "", "                        IJoePair(_pair).swap(_amountOut, 0, _recipient, \"\");", "                    }", "                } else {", "                    ILBPair(_pair).swap(_tokenNext == ILBPair(_pair).tokenY(), _recipient);", "                }", "            }", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    modifier update() {", "        if (_mostRecentValueCalcTime == 0) {", "            _mostRecentValueCalcTime = firstStakeTime;", "        }", "", "        uint256 totalCurrentStake = totalStake();", "", "        if (totalCurrentStake > 0 && _mostRecentValueCalcTime < endTime) {", "            uint256 value = 0;", "            uint256 sinceLastCalc = block.timestamp.sub(_mostRecentValueCalcTime);", "            uint256 perSecondReward = totalRewards.div(endTime.sub(firstStakeTime));", "", "            if (block.timestamp < endTime) {", "                value = sinceLastCalc.mul(perSecondReward);", "            } else {", "                uint256 sinceEndTime = block.timestamp.sub(endTime);", "                value = (sinceLastCalc.sub(sinceEndTime)).mul(perSecondReward);", "            }", "", "            _totalWeight = _totalWeight.add(value.mul(10**18).div(totalCurrentStake));", "", "            _mostRecentValueCalcTime = block.timestamp;", "", "            (uint fee0, uint fee1) = IMuteSwitchPairDynamic(lpToken).claimFees();", "", "            _totalWeightFee0 = _totalWeightFee0.add(fee0.mul(10**18).div(totalCurrentStake));", "            _totalWeightFee1 = _totalWeightFee1.add(fee1.mul(10**18).div(totalCurrentStake));", "", "            totalFees0 = totalFees0.add(fee0);", "            totalFees1 = totalFees1.add(fee1);", "        }", "", "        _;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": ["    modifier noContract(address _account) {", "        require(", "            !_account.isContract() || whitelistedContracts[_account],", "            \"Contracts not allowed\"", "        );", "        _;", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _allClaimableRewards(", "        address _account,", "        address _token,", "        uint256 _startIndex", "    ) internal view returns (uint256, uint256) {", "        uint256 latestEpoch = auraLocker.epochCount() - 1;", "        // e.g. tokenEpochs = 31, 21", "        uint256 tokenEpochs = rewardEpochs[_token].length;", "", "        // e.g. epochIndex = 0", "        uint256 epochIndex = userClaims[_token][_account];", "        // e.g. epochIndex = 27 > 0 ? 27 : 0 = 27", "        epochIndex = _startIndex > epochIndex ? _startIndex : epochIndex;", "", "        if (epochIndex >= tokenEpochs) {", "            return (0, tokenEpochs);", "        }", "", "        uint256 claimableTokens = 0;", "", "        for (uint256 i = epochIndex; i < tokenEpochs; i++) {", "            //only claimable after rewards are \"locked in\"", "            if (rewardEpochs[_token][i] < latestEpoch) {", "                claimableTokens += _claimableRewards(_account, _token, rewardEpochs[_token][i]);", "                //return index user claims should be set to", "                epochIndex = i + 1;", "            }", "        }", "        return (claimableTokens, epochIndex);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0]}
{"tokens": ["    constructor(", "        address rewardTokenAddress_,", "        uint256 endTime_,", "        uint256 startTime_,", "        uint256 totalParticipants_,", "        uint256 rewardAmountInWeiOrTokenId_,", "        string memory questId_,", "        address receiptContractAddress_", "    ) {", "        if (endTime_ <= block.timestamp) revert EndTimeInPast();", "        if (startTime_ <= block.timestamp) revert StartTimeInPast();", "        if (endTime_ <= startTime_) revert EndTimeLessThanOrEqualToStartTime();", "        endTime = endTime_;", "        startTime = startTime_;", "        rewardToken = rewardTokenAddress_;", "        totalParticipants = totalParticipants_;", "        rewardAmountInWeiOrTokenId = rewardAmountInWeiOrTokenId_;", "        questId = questId_;", "        rabbitHoleReceiptContract = RabbitHoleReceipt(receiptContractAddress_);", "        redeemedTokens = 0;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["    function executeDiamondCutProposal(Diamond.DiamondCutData calldata _diamondCut) external onlyGovernor {", "        Diamond.DiamondStorage storage diamondStorage = Diamond.getDiamondStorage();", "", "        bool approvedBySecurityCouncil = s.diamondCutStorage.securityCouncilEmergencyApprovals >=", "            SECURITY_COUNCIL_APPROVALS_FOR_EMERGENCY_UPGRADE;", "", "        bool upgradeNoticePeriodPassed = block.timestamp >=", "            s.diamondCutStorage.proposedDiamondCutTimestamp + UPGRADE_NOTICE_PERIOD;", "", "        require(approvedBySecurityCouncil || upgradeNoticePeriodPassed, \"a6\"); // notice period should expire", "        require(approvedBySecurityCouncil || !diamondStorage.isFrozen, \"f3\");", "        // should not be frozen or should have enough security council approvals", "", "        require(", "            s.diamondCutStorage.proposedDiamondCutHash ==", "                keccak256(abi.encode(_diamondCut.facetCuts, _diamondCut.initAddress)),", "            \"a4\"", "        ); // proposal should be created", "", "        require(_resetProposal(), \"a5\"); // failed reset proposal", "", "        if (diamondStorage.isFrozen) {", "            diamondStorage.isFrozen = false;", "            emit Unfreeze(s.diamondCutStorage.lastDiamondFreezeTimestamp);", "        }", "", "        Diamond.diamondCut(_diamondCut);", "", "        emit DiamondCutProposalExecution(_diamondCut);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function _validateCommitment(", "    RouterStorage storage s,", "    IAstariaRouter.Commitment calldata commitment,", "    uint256 timeToSecondEpochEnd", "  ) internal view returns (ILienToken.Lien memory lien) {", "    if (block.timestamp > commitment.lienRequest.strategy.deadline) {", "      revert InvalidCommitmentState(CommitmentState.EXPIRED);", "    }", "    uint8 nlrType = uint8(_sliceUint(commitment.lienRequest.nlrDetails, 0));", "    address strategyValidator = s.strategyValidators[nlrType];", "    if (strategyValidator == address(0)) {", "      revert InvalidStrategy(nlrType);", "    }", "    (bytes32 leaf, ILienToken.Details memory details) = IStrategyValidator(", "      strategyValidator", "    ).validateAndParse(", "        commitment.lienRequest,", "        s.COLLATERAL_TOKEN.ownerOf(", "          commitment.tokenContract.computeId(commitment.tokenId)", "        ),", "        commitment.tokenContract,", "        commitment.tokenId", "      );", "", "    if (details.rate == uint256(0) || details.rate > s.maxInterestRate) {", "      revert InvalidCommitmentState(CommitmentState.INVALID_RATE);", "    }", "", "    if (details.maxAmount < commitment.lienRequest.amount) {", "      revert InvalidCommitmentState(CommitmentState.INVALID_AMOUNT);", "    }", "", "    if (", "      !MerkleProofLib.verify(", "        commitment.lienRequest.merkle.proof,", "        commitment.lienRequest.merkle.root,", "        leaf", "      )", "    ) {", "      revert InvalidCommitmentState(CommitmentState.INVALID);", "    }", "", "    if (timeToSecondEpochEnd > 0 && details.duration > timeToSecondEpochEnd) {", "      details.duration = timeToSecondEpochEnd;", "    }", "", "    lien = ILienToken.Lien({", "      collateralType: nlrType,", "      details: details,", "      strategyRoot: commitment.lienRequest.merkle.root,", "      collateralId: commitment.tokenContract.computeId(commitment.tokenId),", "      vault: commitment.lienRequest.strategy.vault,", "      token: IAstariaVaultBase(commitment.lienRequest.strategy.vault).asset()", "    });", "  }"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function cash(address _vault, bytes32[] calldata _burnProof) external {", "        // Reverts if vault is not registered", "        (address token, uint256 id) = _verifyVault(_vault);", "        // Reverts if active listing has not been settled", "        Listing storage activeListing = activeListings[_vault];", "        // Reverts if listing has not been sold", "        if (!_verifySale(_vault)) {", "            revert NotSold();", "        } else if (activeListing.collateral != 0) {", "            uint256 collateral = activeListing.collateral;", "            activeListing.collateral = 0;", "            // Sets collateral amount to pending balances for withdrawal", "            pendingBalances[_vault][activeListing.proposer] = collateral;", "        }", "        // Reverts if token balance is insufficient", "        uint256 tokenBalance = _verifyBalance(token, id, 1);", "        // Calculates ether payment for withdrawal", "        uint256 payment = tokenBalance * activeListing.pricePerToken;", "", "        // Initializes vault transaction for burn", "        bytes memory data = abi.encodeCall(ISupply.burn, (msg.sender, tokenBalance));", "        // Executes burn of tokens from caller", "        IVault(payable(_vault)).execute(supply, data, _burnProof);", "", "        // Transfers payment to token holder", "        _sendEthOrWeth(msg.sender, payment);", "", "        // Emits event for cashing out of listing", "        emit Cash(_vault, msg.sender, payment);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    constructor() {", "        _transferOwnership(msg.sender);", "    }"], "ner_tags": [0, 1, 0]}
{"tokens": ["    function _getOracleData(UinswapV3PositionData memory positionData)", "        internal", "        view", "        returns (PairOracleData memory)", "    {", "        PairOracleData memory oracleData;", "        IPriceOracleGetter oracle = IPriceOracleGetter(", "            ADDRESSES_PROVIDER.getPriceOracle()", "        );", "        oracleData.token0Price = oracle.getAssetPrice(positionData.token0);", "        oracleData.token1Price = oracle.getAssetPrice(positionData.token1);", "", "        oracleData.token0Decimal = IERC20Detailed(positionData.token0)", "            .decimals();", "        oracleData.token1Decimal = IERC20Detailed(positionData.token1)", "            .decimals();", "", "        // TODO using bit shifting for the 2^96", "        // positionData.sqrtPriceX96;", "", "        if (oracleData.token1Decimal == oracleData.token0Decimal) {", "            // multiply by 10^18 then divide by 10^9 to preserve price in wei", "            oracleData.sqrtPriceX96 = uint160(", "                (SqrtLib.sqrt(", "                    ((oracleData.token0Price * (10**18)) /", "                        (oracleData.token1Price))", "                ) * 2**96) / 1E9", "            );", "        } else if (oracleData.token1Decimal > oracleData.token0Decimal) {", "            // multiple by 10^(decimalB - decimalA) to preserve price in wei", "            oracleData.sqrtPriceX96 = uint160(", "                (SqrtLib.sqrt(", "                    (oracleData.token0Price *", "                        (10 **", "                            (18 +", "                                oracleData.token1Decimal -", "                                oracleData.token0Decimal))) /", "                        (oracleData.token1Price)", "                ) * 2**96) / 1E9", "            );", "        } else {", "            // multiple by 10^(decimalA - decimalB) to preserve price in wei then divide by the same number", "            oracleData.sqrtPriceX96 = uint160(", "                (SqrtLib.sqrt(", "                    (oracleData.token0Price *", "                        (10 **", "                            (18 +", "                                oracleData.token0Decimal -", "                                oracleData.token1Decimal))) /", "                        (oracleData.token1Price)", "                ) * 2**96) /", "                    10 **", "                        (9 +", "                            oracleData.token0Decimal -", "                            oracleData.token1Decimal)", "            );", "        }", "", "        return oracleData;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": ["    function purchase(", "        uint256 _poolId,", "        address _market,", "        address _nftContract,", "        uint256 _tokenId,", "        uint256 _price,", "        bytes memory _purchaseOrder,", "        bytes32[] memory _purchaseProof", "    ) external {", "        // Reverts if pool ID is not valid", "        _verifyPool(_poolId);", "        // Reverts if NFT has already been purchased OR termination period has passed", "        (", "            address nftContract,", "            uint48 totalSupply,", "            ,", "            ,", "            bytes32 merkleRoot", "        ) = _verifyUnsuccessfulState(_poolId);", "        // Reverts if NFT contract is not equalt to NFT contract set on pool creation", "        if (_nftContract != nftContract) revert InvalidContract();", "        // Reverts if price is greater than total contribution amount of pool", "        if (_price > minReservePrices[_poolId] * filledQuantities[_poolId])", "            revert InvalidPurchase();", "", "        // Checks merkle proof based on size of array", "        if (_purchaseProof.length == 0) {", "            // Hashes tokenId to verify merkle root if proof is empty", "            if (bytes32(_tokenId) != merkleRoot) revert InvalidProof();", "        } else {", "            // Verifies merkle proof based on position of leaf node in tree", "            bytes32 leaf = keccak256(abi.encode(_tokenId));", "            if (!MerkleProof.verify(_purchaseProof, merkleRoot, leaf)) revert InvalidProof();", "        }", "", "        // Decrements actual price from total pool contributions", "        totalContributions[_poolId] -= _price;", "", "        // Encodes NFT contract and tokenId into purchase order", "        bytes memory nftData = abi.encode(_nftContract, _tokenId);", "        // Encodes arbitrary amount of data based on market buyer to execute purchase", "        _purchaseOrder = abi.encodePacked(nftData, _purchaseOrder);", "", "        // Executes purchase order transaction through market buyer contract and deploys new vault", "        address vault = IMarketBuyer(_market).execute{value: _price}(_purchaseOrder);", "", "        // Checks if NFT contract supports ERC165 and interface ID of ERC721 tokens", "        if (ERC165Checker.supportsInterface(_nftContract, _INTERFACE_ID_ERC721)) {", "            // Verifes vault is owner of ERC-721 token", "            if (IERC721(_nftContract).ownerOf(_tokenId) != vault) revert UnsuccessfulPurchase();", "        } else {", "            // Verifies vault is owner of CryptoPunk token", "            if (ICryptoPunk(_nftContract).punkIndexToAddress(_tokenId) != vault)", "                revert UnsuccessfulPurchase();", "        }", "", "        // Stores mapping value of poolId to newly deployed vault", "        poolToVault[_poolId] = vault;", "        // Sets pool state to successful", "        poolInfo[_poolId].success = true;", "", "        // Emits event for purchasing NFT at given price", "        emit Purchase(_poolId, vault, _nftContract, _tokenId, _price);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _baseVestedAmount(Claim memory _claim, uint40 _referenceTs) internal pure returns (uint112) {", "        uint112 vestAmt = 0;", "        ", "        // the condition to have anything vested is to be active", "        if(_claim.isActive) {", "            // no point of looking past the endTimestamp as nothing should vest afterwards", "            // So if we're past the end, just get the ref frame back to the end", "            if(_referenceTs > _claim.endTimestamp) {", "                _referenceTs = _claim.endTimestamp;", "            }", "", "            // If we're past the cliffReleaseTimestamp, we release the cliffAmount", "            // We don't check here that cliffReleaseTimestamp is after the startTimestamp ", "            if(_referenceTs >= _claim.cliffReleaseTimestamp) {", "                vestAmt += _claim.cliffAmount;", "            }", "", "            // Calculate the linearly vested amount - this is relevant only if we're past the schedule start", "            // at _referenceTs == _claim.startTimestamp, the period proportion will be 0 so we don't need to start the calc", "            if(_referenceTs > _claim.startTimestamp) {", "                uint40 currentVestingDurationSecs = _referenceTs - _claim.startTimestamp; // How long since the start", "                // Next, we need to calculated the duration truncated to nearest releaseIntervalSecs", "                uint40 truncatedCurrentVestingDurationSecs = (currentVestingDurationSecs / _claim.releaseIntervalSecs) * _claim.releaseIntervalSecs;", "                uint40 finalVestingDurationSecs = _claim.endTimestamp - _claim.startTimestamp; // length of the interval", "", "                // Calculate the linear vested amount - fraction_of_interval_completed * linearVestedAmount", "                // Since fraction_of_interval_completed is truncatedCurrentVestingDurationSecs / finalVestingDurationSecs, the formula becomes", "                // truncatedCurrentVestingDurationSecs / finalVestingDurationSecs * linearVestAmount, so we can rewrite as below to avoid ", "                // rounding errors", "                uint112 linearVestAmount = _claim.linearVestAmount * truncatedCurrentVestingDurationSecs / finalVestingDurationSecs;", "", "                // Having calculated the linearVestAmount, simply add it to the vested amount", "                vestAmt += linearVestAmount;", "            }", "        }", "        ", "        // Return the bigger of (vestAmt, _claim.amountWithdrawn)", "        // Rationale: no matter how we calculate the vestAmt, we can never return that less was vested than was already withdrawn.", "        // Case where this could be relevant - If the claim is inactive, vestAmt would be 0, yet if something was already withdrawn ", "        // on that claim, we want to return that as vested thus far - as we want the function to be monotonic.", "        return (vestAmt > _claim.amountWithdrawn) ? vestAmt : _claim.amountWithdrawn;", "    }"], "ner_tags": [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function checkSignatures(", "        bytes32 dataHash,", "        bytes memory data,", "        bytes memory signatures", "    ) public view virtual {", "        uint8 v;", "        bytes32 r;", "        bytes32 s;", "        uint256 i = 0;", "        address _signer;", "        (v, r, s) = signatureSplit(signatures, i);", "        //review", "        if(v == 0) {", "            // If v is 0 then it is a contract signature", "            // When handling contract signatures the address of the contract is encoded into r", "            _signer = address(uint160(uint256(r)));", "", "            // Check that signature data pointer (s) is not pointing inside the static part of the signatures bytes", "                // This check is not completely accurate, since it is possible that more signatures than the threshold are send.", "                // Here we only check that the pointer is not pointing inside the part that is being processed", "                require(uint256(s) >= uint256(1) * 65, \"BSA021\");", "", "                // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)", "                require(uint256(s) + 32 <= signatures.length, \"BSA022\");", "", "                // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length", "                uint256 contractSignatureLen;", "                // solhint-disable-next-line no-inline-assembly", "                assembly {", "                    contractSignatureLen := mload(add(add(signatures, s), 0x20))", "                }", "                require(uint256(s) + 32 + contractSignatureLen <= signatures.length, \"BSA023\");", "", "                // Check signature", "                bytes memory contractSignature;", "                // solhint-disable-next-line no-inline-assembly", "                assembly {", "                    // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s", "                    contractSignature := add(add(signatures, s), 0x20)", "                }", "                require(ISignatureValidator(_signer).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, \"BSA024\");", "        }", "        else if(v > 30) {", "            // If v > 30 then default va (27,28) has been adjusted for eth_sign flow", "            // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover", "            _signer = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);", "            require(_signer == owner, \"INVALID_SIGNATURE\");", "        } else {", "            _signer = ecrecover(dataHash, v, r, s);", "            require(_signer == owner, \"INVALID_SIGNATURE\");", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function div(FixedPointInt memory a, FixedPointInt memory b)", "        internal", "        pure", "        returns (FixedPointInt memory)", "    {", "        return FixedPointInt((a.value * _SCALING_FACTOR) / b.value);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["    function liquidateClean(", "        uint128 _sharesToLiquidate,", "        uint256 _deadline,", "        address _borrower", "    ) external whenNotPaused nonReentrant approvedLender(msg.sender) returns (uint256 _collateralForLiquidator) {", "        if (block.timestamp > _deadline) revert PastDeadline(block.timestamp, _deadline);", "", "        _addInterest();", "        uint256 _exchangeRate = _updateExchangeRate();", "", "        if (_isSolvent(_borrower, _exchangeRate)) {", "            revert BorrowerSolvent();", "        }", "", "        // Read from state", "        VaultAccount memory _totalBorrow = totalBorrow;", "        uint256 _userCollateralBalance = userCollateralBalance[_borrower];", "        uint128 _borrowerShares = userBorrowShares[_borrower].toUint128();", "", "        // Prevent stack-too-deep", "        int256 _leftoverCollateral;", "        {", "            // Checks & Calculations", "            // Determine the liquidation amount in collateral units (i.e. how much debt is liquidator going to repay)", "            uint256 _liquidationAmountInCollateralUnits = ((_totalBorrow.toAmount(_sharesToLiquidate, false) *", "                _exchangeRate) / EXCHANGE_PRECISION);", "", "            // We first optimistically calculate the amount of collateral to give the liquidator based on the higher clean liquidation fee", "            // This fee only applies if the liquidator does a full liquidation", "            uint256 _optimisticCollateralForLiquidator = (_liquidationAmountInCollateralUnits *", "                (LIQ_PRECISION + cleanLiquidationFee)) / LIQ_PRECISION;", "", "            // Because interest accrues every block, _liquidationAmountInCollateralUnits from a few lines up is an ever increasing value", "            // This means that leftoverCollateral can occasionally go negative by a few hundred wei (cleanLiqFee premium covers this for liquidator)", "            _leftoverCollateral = (_userCollateralBalance.toInt256() - _optimisticCollateralForLiquidator.toInt256());", "", "            // If cleanLiquidation fee results in no leftover collateral, give liquidator all the collateral", "            // This will only be true when there liquidator is cleaning out the position", "            _collateralForLiquidator = _leftoverCollateral <= 0", "                ? _userCollateralBalance", "                : (_liquidationAmountInCollateralUnits * (LIQ_PRECISION + dirtyLiquidationFee)) / LIQ_PRECISION;", "        }", "        // Calced here for use during repayment, grouped with other calcs before effects start", "        uint128 _amountLiquidatorToRepay = (_totalBorrow.toAmount(_sharesToLiquidate, true)).toUint128();", "", "        // Determine if and how much debt to writeoff", "        // Note: ensures that sharesToLiquidate is never larger than borrowerShares", "        uint128 _sharesToAdjust;", "        uint128 _amountToAdjust;", "        {", "            if (_leftoverCollateral <= 0) {", "                uint128 _leftoverBorrowShares = _borrowerShares - _sharesToLiquidate;", "                if (_leftoverBorrowShares > 0) {", "                    // Write off bad debt", "                    _sharesToAdjust = _leftoverBorrowShares;", "                    _amountToAdjust = (_totalBorrow.toAmount(_sharesToAdjust, false)).toUint128();", "", "                    // Effects: write to state", "                    totalAsset.amount -= _amountToAdjust;", "", "                    // Note: Ensure this memory stuct will be passed to _repayAsset for write to state", "                    _totalBorrow.amount -= _amountToAdjust;", "                    _totalBorrow.shares -= _sharesToAdjust;", "                }", "            }", "        }", "", "        // Effects & Interactions", "        // NOTE: reverts if _shares > userBorrowShares", "        _repayAsset(_totalBorrow, _amountLiquidatorToRepay, _sharesToLiquidate, msg.sender, _borrower); // liquidator repays shares on behalf of borrower", "        // NOTE: reverts if _collateralForLiquidator > userCollateralBalance", "        // Collateral is removed on behalf of borrower and sent to liquidator", "        // NOTE: reverts if _collateralForLiquidator > userCollateralBalance", "        _removeCollateral(_collateralForLiquidator, msg.sender, _borrower);", "        emit Liquidate(", "            _borrower,", "            _collateralForLiquidator,", "            _sharesToLiquidate,", "            _amountLiquidatorToRepay,", "            _sharesToAdjust,", "            _amountToAdjust", "        );", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _processExtraToken(address _token, uint256 _amount) internal {", "        require(_token != want, \"Not want, use _reportToVault\");", "        require(_token != address(0), \"Address 0\");", "        require(_amount != 0, \"Amount 0\");", "", "        IERC20Upgradeable(_token).safeTransfer(vault, _amount);", "        IVault(vault).reportAdditionalToken(_token);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["    function getAmountForShares(uint256 _shares)", "        external", "        view", "        override", "        returns (uint256)", "    {", "        if (totalSupply() == 0) {", "            return _shares;", "        }", "        return (_shares * totalAssets()) / totalSupply();", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function _isWrappedFCash(address _fCashPosition) internal view returns(bool){", "        if(!_fCashPosition.isContract()) {", "            return false;", "        }", "", "        try IWrappedfCash(_fCashPosition).getDecodedID() returns(uint16 _currencyId, uint40 _maturity){", "            try wrappedfCashFactory.computeAddress(_currencyId, _maturity) returns(address _computedAddress){", "                return _fCashPosition == _computedAddress;", "            } catch {", "                return false;", "            }", "        } catch {", "            return false;", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": ["    function setReservePrice(uint256 _reservePrice) external onlyOwner {", "        settings.reservePrice = _reservePrice;", "", "        emit ReservePriceUpdated(_reservePrice);", "    }"], "ner_tags": [1, 1, 1, 1, 1]}
{"tokens": ["    function validateOrder(Order calldata o)", "        public", "        view", "        returns (", "            uint256,", "            bytes32,", "            uint256", "        )", "    {", "        // match signature", "        bytes32 hashStruct = _hashOrder(o);", "        bytes32 hash = keccak256(abi.encodePacked('\\x19\\x01', EIP712_DOMAIN_TYPEHASH, hashStruct));", "        address signaturesigner = ecrecover(hash, o.v, o.r, o.s);", "        require(signaturesigner == o.signer, 'invalid signature');", "        if (signaturesigner != o.signer) {", "            return (0, hashStruct, 0);", "        }", "        //deadline", "        if (block.timestamp > o.deadline) {", "            return (1, hashStruct, 0);", "        }", "        // not cancelled by nonce or by hash", "        if (o.nonce != nonces[o.signer]) {", "            return (2, hashStruct, 0);", "        }", "        if (filled[hashStruct] >= o.tokenAmt) {", "            // handles erc1155", "            return (2, hashStruct, 0);", "        }", "        return (3, hashStruct, o.tokenAmt - filled[hashStruct]);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function reimburseLiquidityFees(", "    address _token,", "    uint256 _liquidityFee,", "    address _receiver", "  ) external override onlyConnext returns (uint256) {", "    uint256 sponsoredFee;", "", "    if (address(tokenExchanges[_token]) != address(0)) {", "      uint256 currentBalance = address(this).balance;", "      ITokenExchange tokenExchange = tokenExchanges[_token];", "", "      uint256 amountIn = tokenExchange.getInGivenExpectedOut(_token, _liquidityFee);", "      amountIn = currentBalance >= amountIn ? amountIn : currentBalance;", "", "      // sponsored fee may end being less than _liquidityFee due to slippage", "      sponsoredFee = tokenExchange.swapExactIn{value: amountIn}(_token, msg.sender);", "    } else {", "      uint256 balance = IERC20(_token).balanceOf(address(this));", "      sponsoredFee = balance < _liquidityFee ? balance : _liquidityFee;", "", "      // some ERC20 do not allow to transfer 0 amount", "      if (sponsoredFee > 0) {", "        IERC20(_token).safeTransfer(msg.sender, sponsoredFee);", "      }", "    }", "", "    emit ReimburseLiquidityFees(_token, sponsoredFee, _receiver);", "", "    return sponsoredFee;", "  }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function processYield() external override onlyAdmin {", "    // Claim Rewards(CRV, CVX, Extra incentive tokens)", "    address baseRewardPool = getBaseRewardPool();", "    IConvexBaseRewardPool(baseRewardPool).getReward();", "", "    // Transfer CRV to YieldManager", "    address _token = _addressesProvider.getAddress('CRV');", "    address _tokenFromConvex = IConvexBaseRewardPool(baseRewardPool).rewardToken();", "    require(_token == _tokenFromConvex, Errors.VT_INVALID_CONFIGURATION);", "    _transferYield(_token);", "", "    // Transfer CVX to YieldManager", "    _token = _addressesProvider.getAddress('CVX');", "    _tokenFromConvex = IConvexBooster(convexBooster).minter();", "    require(_token == _tokenFromConvex, Errors.VT_INVALID_CONFIGURATION);", "    _transferYield(_token);", "", "    // Transfer extra incentive token to YieldManager", "    uint256 extraRewardsLength = IConvexBaseRewardPool(baseRewardPool).extraRewardsLength();", "    for (uint256 i = 0; i < extraRewardsLength; i++) {", "      address _extraReward = IConvexBaseRewardPool(baseRewardPool).extraRewards(i);", "      address _rewardToken = IRewards(_extraReward).rewardToken();", "      _transferYield(_rewardToken);", "    }", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": ["    function triggerEndEpoch(uint256 marketIndex, uint256 epochEnd) public {", "        if(", "            vaultFactory.getVaults(marketIndex).length != VAULTS_LENGTH)", "                revert MarketDoesNotExist(marketIndex);", "        if(", "            block.timestamp < epochEnd)", "            revert EpochNotExpired();", "", "        address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);", "", "        Vault insrVault = Vault(vaultsAddress[0]);", "        Vault riskVault = Vault(vaultsAddress[1]);", "", "        if(insrVault.idExists(epochEnd) == false || riskVault.idExists(epochEnd) == false)", "            revert EpochNotExist();", "", "        //require this function cannot be called twice in the same epoch for the same vault", "        if(insrVault.idFinalTVL(epochEnd) != 0)", "            revert NotZeroTVL();", "        if(riskVault.idFinalTVL(epochEnd) != 0) ", "            revert NotZeroTVL();", "", "        insrVault.endEpoch(epochEnd, false);", "        riskVault.endEpoch(epochEnd, false);", "", "        insrVault.setClaimTVL(epochEnd, 0);", "        riskVault.setClaimTVL(epochEnd, insrVault.idFinalTVL(epochEnd));", "        insrVault.sendTokens(epochEnd, address(riskVault));", "", "        VaultTVL memory tvl = VaultTVL(", "            riskVault.idClaimTVL(epochEnd),", "            insrVault.idClaimTVL(epochEnd),", "            riskVault.idFinalTVL(epochEnd),", "            insrVault.idFinalTVL(epochEnd)", "        );", "", "        emit DepegInsurance(", "            keccak256(", "                abi.encodePacked(", "                    marketIndex,", "                    insrVault.idEpochBegin(epochEnd),", "                    epochEnd", "                )", "            ),", "            tvl,", "            false,", "            epochEnd,", "            block.timestamp,", "            getLatestPrice(insrVault.tokenInsured())", "        );", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["    function claimableRewards(address user) external view virtual override returns (uint256) {", "        uint256 ammStakedIntegral_ = ammStakedIntegral;", "        uint256 timeElapsed = block.timestamp - uint256(ammLastUpdated);", "        if (user == inflationRecipient) {", "            return", "                perUserShare[inflationRecipient] +", "                IController(controller).inflationManager().getAmmRateForToken(ammToken) *", "                timeElapsed;", "        }", "        if (!killed && totalStaked > 0) {", "            ammStakedIntegral_ +=", "                IController(controller).inflationManager().getAmmRateForToken(ammToken) *", "                timeElapsed.scaledDiv(totalStaked);", "        }", "        return", "            perUserShare[user] +", "            balances[user].scaledMul(ammStakedIntegral_ - perUserStakedIntegral[user]);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": ["    function setTimeBuffer(uint256 _timeBuffer) external onlyOwner {", "        settings.timeBuffer = SafeCast.toUint40(_timeBuffer);", "", "        emit TimeBufferUpdated(_timeBuffer);", "    }"], "ner_tags": [1, 1, 1, 1, 1]}
{"tokens": ["    function deliverBribes() external lock {", "        require(msg.sender == voter);", "        IBribe sb = IBribe(bribe);", "        uint bribeStart = block.timestamp - (block.timestamp % (7 days)) + BRIBE_LAG;", "        uint numRewards = sb.rewardsListLength();", "", "        for (uint i = 0; i < numRewards; i++) {", "            address token = sb.rewards(i);", "            uint epochRewards = sb.deliverReward(token, bribeStart);", "            if (epochRewards > 0) {", "                _notifyBribeAmount(token, epochRewards, bribeStart);", "            }", "        }", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function updateTaskHash(bytes calldata _data, bytes calldata _signature)", "        external", "        override", "    {", "        // Decode params from _data", "        (bytes memory _taskHash, uint256 _nonce, uint256 _taskID) = abi.decode(", "            _data,", "            (bytes, uint256, uint256)", "        );", "", "        // Revert if decoded nonce is incorrect. This indicates wrong data.", "        require(_nonce == hashChangeNonce, \"Project::!Nonce\");", "", "        // If subcontractor has confirmed then check signature using `checkSignatureTask`.", "        // Else check signature using `checkSignature`.", "        if (getAlerts(_taskID)[2]) {", "            // If subcontractor has confirmed.", "            checkSignatureTask(_data, _signature, _taskID);", "        } else {", "            // If subcontractor not has confirmed.", "            checkSignature(_data, _signature);", "        }", "", "        // Increment to ensure a set of data and signature cannot be re-used.", "        hashChangeNonce += 1;", "", "        emit TaskHashUpdated(_taskID, _taskHash);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function createClaim(", "            address _recipient, ", "            uint40 _startTimestamp, ", "            uint40 _endTimestamp, ", "            uint40 _cliffReleaseTimestamp, ", "            uint40 _releaseIntervalSecs, ", "            uint112 _linearVestAmount, ", "            uint112 _cliffAmount", "                ) external onlyAdmin {", "        _createClaimUnchecked(_recipient, _startTimestamp, _endTimestamp, _cliffReleaseTimestamp, _releaseIntervalSecs, _linearVestAmount, _cliffAmount);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function redeem(address payable _to) external override boughtOut returns(uint256 _amtOut){", "        uint256 _balance = balanceOf(msg.sender);", "        _amtOut = ((address(this).balance - feeAccruedCurator - totalUnsettledBids) * _balance) / totalSupply();", "        _burn(msg.sender, _balance);", "        safeTransferETH(_to, _amtOut);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0]}
{"tokens": ["    constructor(", "        address _factory,", "        address _admin,", "        address _l2Sequencer", "    ) {", "        if(_admin == address(0))", "            revert ZeroAddress();", "", "        if(_factory == address(0)) ", "            revert ZeroAddress();", "", "        if(_l2Sequencer == address(0))", "            revert ZeroAddress();", "        ", "        admin = _admin;", "        vaultFactory = VaultFactory(_factory);", "        sequencerUptimeFeed = AggregatorV2V3Interface(_l2Sequencer);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["    function notifyRewardAmount(uint256 reward)", "        external", "        updateReward(address(0))", "    {", "        require(", "            msg.sender == rewardsDistribution,", "            \"Caller is not RewardsDistribution contract\"", "        );", "", "        if (block.timestamp >= periodFinish) {", "            rewardRate = reward / rewardsDuration;", "        } else {", "            uint256 remaining = periodFinish - block.timestamp;", "            uint256 leftover = remaining * rewardRate;", "            rewardRate = (reward + leftover) / rewardsDuration;", "        }", "", "        // Ensure the provided reward amount is not more than the balance in the contract.", "        // This keeps the reward rate in the right range, preventing overflows due to", "        // very high values of rewardRate in the earned and rewardsPerToken functions;", "        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.", "        uint256 balance = rewardsToken.balanceOf(address(this));", "        require(", "            rewardRate <= balance / rewardsDuration,", "            \"Provided reward too high\"", "        );", "", "        lastUpdateTime = block.timestamp;", "        periodFinish = block.timestamp + rewardsDuration;", "        emit RewardAdded(reward);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function withdrawDETH(", "        address[] calldata _savETHVaults,", "        LPToken[][] calldata _lpTokens,", "        uint256[][] calldata _amounts", "    ) external {", "        uint256 numOfVaults = _savETHVaults.length;", "        require(numOfVaults > 0, \"Empty arrays\");", "        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");", "        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");", "", "        // Firstly capture current dETH balance and see how much has been deposited after the loop", "        uint256 dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this));", "        for (uint256 i; i < numOfVaults; ++i) {", "            SavETHVault vault = SavETHVault(_savETHVaults[i]);", "", "            // Simultaneously check the status of LP tokens held by the vault and the giant LP balance of the user", "            for (uint256 j; j < _lpTokens[i].length; ++j) {", "                LPToken token = _lpTokens[i][j];", "                uint256 amount = _amounts[i][j];", "", "                // Check the user has enough giant LP to burn and that the pool has enough savETH vault LP", "                _assertUserHasEnoughGiantLPToClaimVaultLP(token, amount);", "", "                require(vault.isDETHReadyForWithdrawal(address(token)), \"dETH is not ready for withdrawal\");", "", "                // Giant LP is burned 1:1 with LPs from sub-networks", "                require(lpTokenETH.balanceOf(msg.sender) >= amount, \"User does not own enough LP\");", "", "                // Burn giant LP from user before sending them dETH", "                lpTokenETH.burn(msg.sender, amount);", "", "                emit LPBurnedForDETH(address(token), msg.sender, amount);", "            }", "", "            // Ask", "            vault.burnLPTokens(_lpTokens[i], _amounts[i]);", "        }", "", "        // Calculate how much dETH has been received from burning", "        dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this)) - dETHReceivedFromAllSavETHVaults;", "", "        // Send giant LP holder dETH owed", "        getDETH().transfer(msg.sender, dETHReceivedFromAllSavETHVaults);", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function propose(", "        address _vault,", "        uint256 _collateral,", "        uint256 _pricePerToken,", "        OfferItem[] calldata _offer", "    ) external {", "        // Reverts if vault is not registered", "        (address token, uint256 id) = _verifyVault(_vault);", "        // Reverts if vault is not current owner of the assets", "        if (_verifySale(_vault)) revert NotOwner();", "        // Reverts if caller has insufficient token balance", "        _verifyBalance(token, id, _collateral);", "        // Initializes the mappings if this is the first time a proposal is being submitted for the vault", "        Listing storage proposedListing = proposedListings[_vault];", "        Listing storage activeListing = activeListings[_vault];", "        if (", "            proposedListings[_vault].proposer == address(0) &&", "            activeListings[_vault].proposer == address(0)", "        ) {", "            _setListing(proposedListing, address(this), 0, type(uint256).max, 0);", "            _setListing(activeListing, address(this), 0, type(uint256).max, 0);", "        }", "        // Reverts if price per token is not lower than both the proposed and active listings", "        if (", "            _pricePerToken >= proposedListing.pricePerToken ||", "            _pricePerToken >= activeListings[_vault].pricePerToken", "        ) revert NotLower();", "", "        // Calculates listing price based on price per token and total supply of Raes", "        uint256 listingPrice = _pricePerToken * IRae(token).totalSupply(id);", "", "        // Constructs Seaport order and sets the proposed listing", "        _constructOrder(_vault, listingPrice, _offer);", "        _setListing(proposedListing, msg.sender, _collateral, _pricePerToken, block.timestamp);", "", "        // Sets collateral amount to pending balances for withdrawal", "        pendingBalances[_vault][proposedListing.proposer] += proposedListing.collateral;", "", "        // Transfers new collateral amount from caller to this contract", "        IERC1155(token).safeTransferFrom(msg.sender, address(this), id, _collateral, \"\");", "", "        // Emits event for proposing new listing", "        emit Propose(_vault, msg.sender, _collateral, _pricePerToken, proposedListing.order);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _quoteRedemptionCurve(", "        uint256 amountBurnt", "    )", "        internal", "        view", "        returns (address[] memory tokens, uint256[] memory balances, uint256[] memory subCollateralsTracker)", "    {", "        TransmuterStorage storage ts = s.transmuterStorage();", "        uint64 collatRatio;", "        uint256 stablecoinsIssued;", "        (collatRatio, stablecoinsIssued, tokens, balances, subCollateralsTracker) = LibGetters.getCollateralRatio();", "        if (amountBurnt > stablecoinsIssued) revert TooBigAmountIn();", "        int64[] memory yRedemptionCurveMem = ts.yRedemptionCurve;", "        uint64 penaltyFactor;", "        // If the protocol is under-collateralized, a penalty factor is applied to the returned amount of each asset", "        if (collatRatio < BASE_9) {", "            uint64[] memory xRedemptionCurveMem = ts.xRedemptionCurve;", "            penaltyFactor = uint64(LibHelpers.piecewiseLinear(collatRatio, xRedemptionCurveMem, yRedemptionCurveMem));", "        }", "", "        uint256 balancesLength = balances.length;", "        for (uint256 i; i < balancesLength; ++i) {", "            // The amount given for each token in reserves does not depend on the price of the tokens in reserve:", "            // it is a proportion of the balance for each token computed as the ratio between the stablecoins", "            // burnt relative to the amount of stablecoins issued.", "            // If the protocol is over-collateralized, the amount of each token given is inversely proportional", "            // to the collateral ratio.", "            balances[i] = collatRatio >= BASE_9", "                ? (amountBurnt * balances[i] * (uint64(yRedemptionCurveMem[yRedemptionCurveMem.length - 1]))) /", "                    (stablecoinsIssued * collatRatio)", "                : (amountBurnt * balances[i] * penaltyFactor) / (stablecoinsIssued * BASE_9);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function setSubnodeOwner(", "        bytes32 parentNode,", "        string calldata label,", "        address newOwner,", "        uint32 fuses,", "        uint64 expiry", "    )", "        public", "        onlyTokenOwner(parentNode)", "        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))", "        returns (bytes32 node)", "    {", "        bytes32 labelhash = keccak256(bytes(label));", "        node = _makeNode(parentNode, labelhash);", "        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);", "", "        if (ens.owner(node) != address(this)) {", "            ens.setSubnodeOwner(parentNode, labelhash, address(this));", "            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);", "        } else {", "            _transferAndBurnFuses(node, newOwner, fuses, expiry);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["    function withdraw() external override nonReentrant {", "        LockedBalance memory locked_ = locked[msg.sender];", "        // Validate inputs", "        require(locked_.amount > 0, \"No lock\");", "        require(locked_.end <= block.timestamp, \"Lock not expired\");", "        require(locked_.delegatee == msg.sender, \"Lock delegated\");", "        // Update lock", "        uint256 value = uint256(uint128(locked_.amount));", "        LockedBalance memory newLocked = _copyLock(locked_);", "        newLocked.amount = 0;", "        newLocked.end = 0;", "        newLocked.delegated -= int128(int256(value));", "        newLocked.delegatee = address(0);", "        locked[msg.sender] = newLocked;", "        newLocked.delegated = 0;", "        // oldLocked can have either expired <= timestamp or zero end", "        // currentLock has only 0 end", "        // Both can have >= 0 amount", "        _checkpoint(msg.sender, locked_, newLocked);", "        // Send back deposited tokens", "        require(token.transfer(msg.sender, value), \"Transfer failed\");", "        emit Withdraw(msg.sender, value, LockAction.WITHDRAW, block.timestamp);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["    function sendToSplitter() external override {", "        uint256 balanceOfVault = getVaultBalance();", "", "        require(", "            balanceOfVault > 0,", "            \"Vault does not have enough royalty Asset to send\"", "        );", "        require(splitterProxy != address(0), \"Splitter is not set\");", "", "        uint256 platformShare = (balanceOfVault * platformFee) / 10000;", "        uint256 splitterShare = balanceOfVault - platformShare;", "", "        require(", "            IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,", "            \"Failed to transfer royalty Asset to splitter\"", "        );", "        require(", "            ISplitter(splitterProxy).incrementWindow(splitterShare) == true,", "            \"Failed to increment splitter window\"", "        );", "        require(", "            IERC20(royaltyAsset).transfer(", "                platformFeeRecipient,", "                platformShare", "            ) == true,", "            \"Failed to transfer royalty Asset to platform fee recipient\"", "        );", "", "        emit RoyaltySentToSplitter(splitterProxy, splitterShare);", "        emit FeeSentToPlatform(platformFeeRecipient, platformShare);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": ["    function incrementGauge(address gauge, uint112 weight) external returns (uint112 newUserWeight) {", "        uint32 currentCycle = _getGaugeCycleEnd();", "        _incrementGaugeWeight(msg.sender, gauge, weight, currentCycle);", "        return _incrementUserAndGlobalWeights(msg.sender, weight, currentCycle);", "    }"], "ner_tags": [0, 0, 0, 1, 0]}
{"tokens": ["    function votingPeriod() public pure override returns (uint256){", "         return 3;", "    }"], "ner_tags": [1, 1, 1]}
{"tokens": ["    function withdraw(uint256 _amount) external updateReward(msg.sender) {", "        require(_amount > 0, \"amount = 0\");", "        balanceOf[msg.sender] -= _amount;", "        totalSupply -= _amount;", "        stakingToken.transfer(msg.sender, _amount);", "        emit WithdrawToken(msg.sender, _amount, block.timestamp);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function setRewardPeriod(uint48 val) public governance {", "        require(val > 0 && val <= MAX_REWARD_PERIOD, \"invalid rewardPeriod\");", "        emit RewardPeriodSet(rewardPeriod, val);", "        rewardPeriod = val;", "        require(rewardPeriod * 2 <= unstakingDelay, \"unstakingDelay/rewardPeriod incompatible\");", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1]}
{"tokens": ["    function lendToProject(", "        uint256 _communityID,", "        address _project,", "        uint256 _lendingAmount,", "        bytes calldata _hash", "    )", "        external", "        virtual", "        override", "        nonReentrant", "        whenNotPaused", "        isPublishedToCommunity(_communityID, _project)", "    {", "        // Local instance of variable. For saving gas.", "        address _sender = _msgSender();", "", "        // Revert if sender is not community owner.", "        // Only community owner can lend.", "        require(", "            _sender == _communities[_communityID].owner,", "            \"Community::!owner\"", "        );", "", "        // Local instance of variable. For saving gas.", "        IProject _projectInstance = IProject(_project);", "", "        // Calculate lenderFee", "        uint256 _lenderFee = (_lendingAmount * _projectInstance.lenderFee()) /", "            (_projectInstance.lenderFee() + 1000);", "", "        // Calculate amount going to project. Lending amount - lending fee.", "        uint256 _amountToProject = _lendingAmount - _lenderFee;", "", "        // Revert if _amountToProject is not within further investment needed.", "        require(", "            _amountToProject <=", "                _communities[_communityID]", "                    .projectDetails[_project]", "                    .lendingNeeded -", "                    _communities[_communityID]", "                        .projectDetails[_project]", "                        .totalLent,", "            \"Community::lending>needed\"", "        );", "", "        // Local instance of variable. For saving gas.", "        IDebtToken _currency = _communities[_communityID].currency;", "        IDebtToken _wrappedToken = IDebtToken(", "            homeFi.wrappedToken(address(_currency))", "        );", "", "        // Update investment in Project", "        _projectInstance.lendToProject(_amountToProject);", "", "        // Update total lent by lender", "        _communities[_communityID]", "            .projectDetails[_project]", "            .totalLent += _amountToProject;", "", "        // First claim interest if principal lent > 0", "        if (", "            _communities[_communityID].projectDetails[_project].lentAmount > 0", "        ) {", "            claimInterest(_communityID, _project, _wrappedToken);", "        }", "", "        // Increment lent principal", "        _communities[_communityID]", "            .projectDetails[_project]", "            .lentAmount += _lendingAmount;", "", "        // Update lastTimestamp", "        _communities[_communityID]", "            .projectDetails[_project]", "            .lastTimestamp = block.timestamp;", "", "        // Transfer _lenderFee to HomeFi treasury from lender account", "        _currency.safeTransferFrom(_msgSender(), homeFi.treasury(), _lenderFee);", "", "        // Transfer _amountToProject to _project from lender account", "        _currency.safeTransferFrom(_msgSender(), _project, _amountToProject);", "", "        // Mint new _lendingAmount amount wrapped token to lender", "        _wrappedToken.mint(_sender, _lendingAmount);", "", "        emit LenderLent(_communityID, _project, _sender, _lendingAmount, _hash);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function updateveAssetWeight(address veAssetOperator, uint256 newWeight) external onlyOwner {", "        require(operators.contains(veAssetOperator), \"not an veAsset operator\");", "        totalWeight -= veAssetWeights[veAssetOperator];", "        veAssetWeights[veAssetOperator] = newWeight;", "        totalWeight += newWeight;", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0]}
{"tokens": ["    function _contribute(", "        address payable contributor,", "        address delegate,", "        uint96 amount,", "        uint256 tokenId,", "        bytes memory gateData", "    ) private returns (uint96 votingPower) {", "        // Require a non-null delegate.", "        if (delegate == address(0)) {", "            revert InvalidDelegateError();", "        }", "", "        // Must not be blocked by gatekeeper.", "        IGateKeeper _gateKeeper = gateKeeper;", "        if (_gateKeeper != IGateKeeper(address(0))) {", "            if (!_gateKeeper.isAllowed(contributor, gateKeeperId, gateData)) {", "                revert NotAllowedByGateKeeperError(", "                    contributor,", "                    _gateKeeper,", "                    gateKeeperId,", "                    gateData", "                );", "            }", "        }", "", "        votingPower = _processContribution(contributor, delegate, amount);", "", "        // OK to contribute with zero just to update delegate.", "        if (amount == 0) return 0;", "", "        if (tokenId == 0) {", "            // Mint contributor a new party card.", "            party.mint(contributor, votingPower, delegate);", "        } else if (disableContributingForExistingCard) {", "            revert ContributingForExistingCardDisabledError();", "        } else if (party.ownerOf(tokenId) == contributor) {", "            // Increase voting power of contributor's existing party card.", "            party.addVotingPower(tokenId, votingPower);", "        } else {", "            revert NotOwnerError();", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function buyAndReduceDebt(address account, ERC721 collateralAsset, IPaprController.SwapParams calldata params)", "        external", "        override", "        returns (uint256)", "    {", "        bool hasFee = params.swapFeeBips != 0;", "", "        (uint256 amountOut, uint256 amountIn) = UniswapHelpers.swap(", "            pool,", "            account,", "            token0IsUnderlying,", "            params.amount,", "            params.minOut,", "            params.sqrtPriceLimitX96,", "            abi.encode(msg.sender)", "        );", "", "        if (hasFee) {", "            underlying.transfer(params.swapFeeTo, amountIn * params.swapFeeBips / BIPS_ONE);", "        }", "", "        _reduceDebt({account: account, asset: collateralAsset, burnFrom: msg.sender, amount: amountOut});", "", "        return amountOut;", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _repayAnyDebt(", "        address account,", "        address underlying,", "        uint256 maximum,", "        CToken ctoken", "    ) internal returns (uint256) {", "        uint256 debt = ctoken.borrowBalanceCurrent(account);", "        if (debt == 0) return 0;", "        if (debt > maximum) debt = maximum;", "", "        uint256 err;", "        if (underlying == address(0)) {", "            CEther cether = CEther(address(ctoken));", "            err = cether.repayBorrowBehalf{value: debt}(account);", "        } else {", "            IERC20(underlying).safeApprove(address(ctoken), debt);", "            err = ctoken.repayBorrowBehalf(account, debt);", "        }", "        require(err == 0, Error.FAILED_REPAY_BORROW);", "", "        return debt;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function recordDistributionFor(", "    uint256 _projectId,", "    uint256 _amount,", "    uint256 _currency", "  )", "    external", "    override", "    nonReentrant", "    returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)", "  {", "    // Get a reference to the project's current funding cycle.", "    fundingCycle = fundingCycleStore.currentOf(_projectId);", "", "    // The funding cycle must not be configured to have distributions paused.", "    if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();", "", "    // The new total amount that has been distributed during this funding cycle.", "    uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[", "      IJBSingleTokenPaymentTerminal(msg.sender)", "    ][_projectId][fundingCycle.number] + _amount;", "", "    // Amount must be within what is still distributable.", "    (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(", "      directory.controllerOf(_projectId)", "    ).distributionLimitOf(", "        _projectId,", "        fundingCycle.configuration,", "        IJBSingleTokenPaymentTerminal(msg.sender),", "        IJBSingleTokenPaymentTerminal(msg.sender).token()", "      );", "", "    // Make sure the new used amount is within the distribution limit.", "    if (_newUsedDistributionLimitOf > _distributionLimitOf || _distributionLimitOf == 0)", "      revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();", "", "    // Make sure the currencies match.", "    if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();", "", "    // Get a reference to the terminal's currency.", "    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();", "", "    // Convert the amount to the balance's currency.", "    distributedAmount = (_currency == _balanceCurrency)", "      ? _amount", "      : PRBMath.mulDiv(", "        _amount,", "        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.", "        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)", "      );", "", "    // The amount being distributed must be available.", "    if (distributedAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])", "      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();", "", "    // Store the new amount.", "    usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][", "      fundingCycle.number", "    ] = _newUsedDistributionLimitOf;", "", "    // Removed the distributed funds from the project's token balance.", "    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =", "      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -", "      distributedAmount;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function fillCriteriaBid(", "        Order calldata o,", "        uint256 amount,", "        uint256 tokenId,", "        bytes32[] calldata proof,", "        address referrer,", "        Payment calldata p", "    ) public nonReentrant {", "        require(o.totalAmt >= o.exchange.paymentAmt + o.prePayment.paymentAmt + o.refererrAmt);", "        // require eth amt is sufficient", "        if (o.reservedAddress != address(0)) {", "            require(msg.sender == o.reservedAddress);", "        }", "        require(o.orderType == 2);", "        (uint256 status, bytes32 hashStruct, uint256 amountRemaining) = validateOrder(o);", "        require(status == 3);", "        require(amountRemaining >= amount);", "", "        filled[hashStruct] = filled[hashStruct] + amount;", "        // Proof verification is performed when there's a non-zero root.", "        if (o.root != bytes32(0)) {", "            _verifyProof(tokenId, o.root, proof);", "        }", "", "        if (o.isERC721) {", "            require(amount == 1, 'only 1 erc721 at 1 time');", "            ERC721 nftcontract = ERC721(o.collection);", "            nftcontract.transferFrom(msg.sender, o.signer, tokenId);", "        } else {", "            ERC1155 nftcontract = ERC1155(o.collection);", "            nftcontract.safeTransferFrom(msg.sender, o.signer, tokenId, amount, '');", "        }", "        emit OrderFilled(msg.sender, o.signer, 2, hashStruct, o.totalAmt * amount);", "        _settleBalances(o, amount, referrer, p);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function lend(", "        uint256 loanId,", "        uint16 interestRate,", "        uint128 amount,", "        uint32 durationSeconds,", "        address sendLendTicketTo", "    )", "        external", "        override", "        notClosed(loanId)", "    {", "        Loan storage loan = loanInfo[loanId];", "        ", "        if (loan.lastAccumulatedTimestamp == 0) {", "            address loanAssetContractAddress = loan.loanAssetContractAddress;", "            require(loanAssetContractAddress != address(0), \"NFTLoanFacilitator: invalid loan\");", "", "            require(interestRate <= loan.perAnumInterestRate, 'NFTLoanFacilitator: rate too high');", "            require(durationSeconds >= loan.durationSeconds, 'NFTLoanFacilitator: duration too low');", "            require(amount >= loan.loanAmount, 'NFTLoanFacilitator: amount too low');", "        ", "            loan.perAnumInterestRate = interestRate;", "            loan.lastAccumulatedTimestamp = uint40(block.timestamp);", "            loan.durationSeconds = durationSeconds;", "            loan.loanAmount = amount;", "", "            ERC20(loanAssetContractAddress).safeTransferFrom(msg.sender, address(this), amount);", "            uint256 facilitatorTake = amount * originationFeeRate / SCALAR;", "            ERC20(loanAssetContractAddress).safeTransfer(", "                IERC721(borrowTicketContract).ownerOf(loanId),", "                amount - facilitatorTake", "            );", "            IERC721Mintable(lendTicketContract).mint(sendLendTicketTo, loanId);", "        } else {", "            uint256 previousLoanAmount = loan.loanAmount;", "            // will underflow if amount < previousAmount", "            uint256 amountIncrease = amount - previousLoanAmount;", "", "            {", "                uint256 previousInterestRate = loan.perAnumInterestRate;", "                uint256 previousDurationSeconds = loan.durationSeconds;", "", "                require(interestRate <= previousInterestRate, 'NFTLoanFacilitator: rate too high');", "                require(durationSeconds >= previousDurationSeconds, 'NFTLoanFacilitator: duration too low');", "", "                require((previousLoanAmount * requiredImprovementRate / SCALAR) <= amountIncrease", "                || previousDurationSeconds + (previousDurationSeconds * requiredImprovementRate / SCALAR) <= durationSeconds ", "                || (previousInterestRate != 0 // do not allow rate improvement if rate already 0", "                    && previousInterestRate - (previousInterestRate * requiredImprovementRate / SCALAR) >= interestRate), ", "                \"NFTLoanFacilitator: proposed terms must be better than existing terms\");", "            }", "", "            uint256 accumulatedInterest = _interestOwed(", "                previousLoanAmount,", "                loan.lastAccumulatedTimestamp,", "                loan.perAnumInterestRate,", "                loan.accumulatedInterest", "            );", "", "            require(accumulatedInterest <= type(uint128).max,", "            \"NFTLoanFacilitator: accumulated interest exceeds uint128\");", "", "            loan.perAnumInterestRate = interestRate;", "            loan.lastAccumulatedTimestamp = uint40(block.timestamp);", "            loan.durationSeconds = durationSeconds;", "            loan.loanAmount = amount;", "            loan.accumulatedInterest = uint128(accumulatedInterest);", "", "            address currentLoanOwner = IERC721(lendTicketContract).ownerOf(loanId);", "            if (amountIncrease > 0) {", "                address loanAssetContractAddress = loan.loanAssetContractAddress;", "                ERC20(loanAssetContractAddress).safeTransferFrom(", "                    msg.sender,", "                    address(this),", "                    amount + accumulatedInterest", "                );", "                ERC20(loanAssetContractAddress).safeTransfer(", "                    currentLoanOwner,", "                    accumulatedInterest + previousLoanAmount", "                );", "                uint256 facilitatorTake = (amountIncrease * originationFeeRate / SCALAR);", "                ERC20(loanAssetContractAddress).safeTransfer(", "                    IERC721(borrowTicketContract).ownerOf(loanId),", "                    amountIncrease - facilitatorTake", "                );", "            } else {", "                ERC20(loan.loanAssetContractAddress).safeTransferFrom(", "                    msg.sender,", "                    currentLoanOwner,", "                    accumulatedInterest + previousLoanAmount", "                );", "            }", "            ILendTicket(lendTicketContract).loanFacilitatorTransfer(currentLoanOwner, sendLendTicketTo, loanId);", "            ", "            emit BuyoutLender(loanId, msg.sender, currentLoanOwner, accumulatedInterest, previousLoanAmount);", "        }", "", "        emit Lend(loanId, msg.sender, interestRate, amount, durationSeconds);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function getPriceNote(address token_, bool stable) internal view returns(uint) { ", "        erc20 token = erc20(token_);", "        address pair = pairFor(note, address(token), stable); // pairs with Note may be volatile or stable", "        if (!isPair(pair)) {", "            return 0; // this pair has not yet been deployed", "        }", "        uint decimals = 10 ** token.decimals();", "        uint price = IBaseV1Pair(pair).quote(address(token), decimals, 8);", "        return price * 1e18 / decimals; // divide by decimals now to maintain precision", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function deposit(Liquidity calldata _deposits) external {", "        Liquidity memory total = totalLiquidity;", "        Liquidity memory user = userLiquidity[msg.sender];", "        if(_deposits.usdm > 0) {", "            usdm.safeTransferFrom(msg.sender, address(this), uint256(_deposits.usdm));", "            total.usdm += _deposits.usdm;", "            user.usdm += _deposits.usdm;", "        }", "", "        if(_deposits.pool3 > 0) {", "            require(totalLiquidity.usdm > 4000000e18, \"usdm low\");", "            pool3.safeTransferFrom(msg.sender, address(this), uint256(_deposits.pool3));", "            total.pool3 += _deposits.pool3;", "            user.pool3 += _deposits.pool3;", "        }", "        totalLiquidity = total;", "        userLiquidity[msg.sender] = user;", "        emit Deposit(msg.sender, _deposits);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function approve(address to, uint256 tokenId) external payable {", "    address tokenOwner = _tokenOwner[tokenId];", "    require(to != tokenOwner, \"ERC721: cannot approve self\");", "    require(_isApproved(msg.sender, tokenId), \"ERC721: not approved sender\");", "    if (_isEventRegistered(HolographERC721Event.beforeApprove)) {", "      require(SourceERC721().beforeApprove(tokenOwner, to, tokenId));", "    }", "    _tokenApprovals[tokenId] = to;", "    emit Approval(tokenOwner, to, tokenId);", "    if (_isEventRegistered(HolographERC721Event.afterApprove)) {", "      require(SourceERC721().afterApprove(tokenOwner, to, tokenId));", "    }", "  }"], "ner_tags": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function disputeTree(string memory reason) external {", "        if (block.timestamp >= endOfDisputePeriod) revert InvalidDispute();", "        IERC20(disputeToken).safeTransferFrom(msg.sender, address(this), disputeAmount);", "        disputer = msg.sender;", "        emit Disputed(reason);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0]}
{"tokens": ["    function restructureCapTable(address[] calldata helpers, address[] calldata addressesToWipe) public {", "        require(zchf.equity() < MINIMUM_EQUITY);", "        checkQualified(msg.sender, helpers);", "        for (uint256 i = 0; i<addressesToWipe.length; i++){", "            address current = addressesToWipe[0];", "            _burn(current, balanceOf(current));", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["    function approve(address[] calldata u, address[] calldata a) external authorized(admin) returns (bool) {", "        uint256 len = u.length;", "        if (len != a.length) {", "            revert NotEqual('array length');", "        }", "        uint256 max = 2**256 - 1;", "", "        for (uint256 i; i < len; ) {", "            IERC20 uToken = IERC20(u[i]);", "            if (address(0) != (address(uToken))) {", "                Safe.approve(uToken, a[i], max);", "            }", "            unchecked {", "                i++;", "            }", "        }", "        return true;", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function getCollateralRequirement(", "        address _qTokenToMint,", "        address _qTokenForCollateral,", "        uint256 _optionsAmount,", "        uint8 _optionsDecimals,", "        uint8 _underlyingDecimals,", "        uint8 _strikeAssetDecimals", "    )", "        internal", "        view", "        returns (", "            address collateral,", "            QuantMath.FixedPointInt memory collateralAmount", "        )", "    {", "        QToken qTokenToMint = QToken(_qTokenToMint);", "        uint256 qTokenToMintStrikePrice = qTokenToMint.strikePrice();", "", "        uint256 qTokenForCollateralStrikePrice;", "", "        // check if we're getting the collateral requirement for a spread", "        if (_qTokenForCollateral != address(0)) {", "            QToken qTokenForCollateral = QToken(_qTokenForCollateral);", "            qTokenForCollateralStrikePrice = qTokenForCollateral.strikePrice();", "", "            // Check that expiries match", "            require(", "                qTokenToMint.expiryTime() == qTokenForCollateral.expiryTime(),", "                \"Controller: Can't create spreads from options with different expiries\"", "            );", "", "            // Check that the underlyings match", "            require(", "                qTokenToMint.underlyingAsset() ==", "                    qTokenForCollateral.underlyingAsset(),", "                \"Controller: Can't create spreads from options with different underlying assets\"", "            );", "", "            // Check that the option types match", "            require(", "                qTokenToMint.isCall() == qTokenForCollateral.isCall(),", "                \"Controller: Can't create spreads from options with different types\"", "            );", "", "            // Check that the options have a matching oracle", "            require(", "                qTokenToMint.oracle() == qTokenForCollateral.oracle(),", "                \"Controller: Can't create spreads from options with different oracles\"", "            );", "        } else {", "            // we're not getting the collateral requirement for a spread", "            qTokenForCollateralStrikePrice = 0;", "        }", "", "        collateralAmount = getOptionCollateralRequirement(", "            qTokenToMintStrikePrice,", "            qTokenForCollateralStrikePrice,", "            _optionsAmount,", "            qTokenToMint.isCall(),", "            _optionsDecimals,", "            _underlyingDecimals,", "            _strikeAssetDecimals", "        );", "", "        collateral = qTokenToMint.isCall()", "            ? qTokenToMint.underlyingAsset()", "            : qTokenToMint.strikeAsset();", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function doTransferOut(address payable to, uint amount) internal {", "        /* Send the Ether, with minimal gas and revert on failure */", "        to.transfer(amount);", "    }"], "ner_tags": [0, 0, 1, 0]}
{"tokens": ["  function _getUserAssetBalances(", "    address[] calldata assets,", "    address user", "  ) internal view override returns (RewardsDataTypes.UserAssetBalance[] memory userAssetBalances) {", "    userAssetBalances = new RewardsDataTypes.UserAssetBalance[](assets.length);", "    for (uint256 i = 0; i < assets.length; i++) {", "      userAssetBalances[i].asset = assets[i];", "      (userAssetBalances[i].userBalance, userAssetBalances[i].totalSupply) = IScaledBalanceToken(", "        assets[i]", "      ).getScaledUserBalanceAndSupply(user);", "    }", "    return userAssetBalances;", "  }"], "ner_tags": [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function set(", "    uint256 _projectId,", "    uint256 _domain,", "    JBGroupedSplits[] calldata _groupedSplits", "  )", "    external", "    override", "    requirePermissionAllowingOverride(", "      projects.ownerOf(_projectId),", "      _projectId,", "      JBOperations.SET_SPLITS,", "      address(directory.controllerOf(_projectId)) == msg.sender", "    )", "  {", "    // Push array length in stack", "    uint256 _groupedSplitsLength = _groupedSplits.length;", "", "    // Set each grouped splits.", "    for (uint256 _i = 0; _i < _groupedSplitsLength; ) {", "      // Get a reference to the grouped split being iterated on.", "      JBGroupedSplits memory _groupedSplit = _groupedSplits[_i];", "", "      // Set the splits for the group.", "      _set(_projectId, _domain, _groupedSplit.group, _groupedSplit.splits);", "", "      unchecked {", "        ++_i;", "      }", "    }", "  }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function getFunds(", "        string calldata schainName,", "        address erc1155OnMainnet,", "        address receiver,", "        uint256[] memory ids,", "        uint256[] memory amounts", "    )", "        external", "        override", "        onlySchainOwner(schainName)", "        whenKilled(keccak256(abi.encodePacked(schainName)))", "    {", "        bytes32 schainHash = keccak256(abi.encodePacked(schainName));", "        require(ids.length == amounts.length, \"Incorrect length of arrays\");", "        for (uint256 i = 0; i < ids.length; i++) {", "            require(transferredAmount[schainHash][erc1155OnMainnet][ids[i]] >= amounts[i], \"Incorrect amount\");", "        }", "        _removeTransferredAmount(schainHash, erc1155OnMainnet, ids, amounts);", "        IERC1155Upgradeable(erc1155OnMainnet).safeBatchTransferFrom(", "            address(this),", "            receiver,", "            ids,", "            amounts,", "            \"\"", "        );", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _handleDeposit(address _tigAsset, address _marginAsset, uint256 _margin, address _stableVault, ERC20PermitData calldata _permitData, address _trader) internal {", "        IStable tigAsset = IStable(_tigAsset);", "        if (_tigAsset != _marginAsset) {", "            if (_permitData.usePermit) {", "                ERC20Permit(_marginAsset).permit(_trader, address(this), _permitData.amount, _permitData.deadline, _permitData.v, _permitData.r, _permitData.s);", "            }", "            uint256 _balBefore = tigAsset.balanceOf(address(this));", "            uint _marginDecMultiplier = 10**(18-ExtendedIERC20(_marginAsset).decimals());", "            IERC20(_marginAsset).transferFrom(_trader, address(this), _margin/_marginDecMultiplier);", "            IERC20(_marginAsset).approve(_stableVault, type(uint).max);", "            IStableVault(_stableVault).deposit(_marginAsset, _margin/_marginDecMultiplier);", "            if (tigAsset.balanceOf(address(this)) != _balBefore + _margin) revert BadDeposit();", "            tigAsset.burnFrom(address(this), tigAsset.balanceOf(address(this)));", "        } else {", "            tigAsset.burnFrom(_trader, _margin);", "        }        ", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function buy(", "        address payable callTarget,", "        uint96 callValue,", "        bytes calldata callData,", "        FixedGovernanceOpts memory governanceOpts", "    )", "        external", "        returns (Party party_)", "    {", "        return _buy(", "            nftContract,", "            nftTokenId,", "            callTarget,", "            callValue,", "            callData,", "            governanceOpts", "        );", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function harvest()", "        public", "        returns (", "            ERC20[] memory _producerTokens,", "            ERC20[] memory rewardTokens,", "            uint256[] memory rewardAmounts", "        )", "    {", "        (_producerTokens, rewardTokens, rewardAmounts) = producer", "            .claimRewards();", "        uint256 pLen = _producerTokens.length;", "", "        // Iterate over the producer tokens and update reward state", "        for (uint256 i; i < pLen; ++i) {", "            ERC20 p = _producerTokens[i];", "            uint256 r = rewardAmounts[i];", "", "            // Update global reward accrual state and associate with the update of reward state", "            ProducerToken storage producerState = producerTokens[p];", "", "            _globalAccrue(producerState.globalState, p);", "", "            if (r != 0) {", "                producerState.rewardStates[rewardTokens[i]] += r;", "            }", "        }", "", "        emit Harvest(_producerTokens, rewardTokens, rewardAmounts);", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function buyAllAmount(", "        ERC20 buy_gem,", "        uint256 buy_amt,", "        ERC20 pay_gem,", "        uint256 max_fill_amount", "    ) external returns (uint256 fill_amt) {", "        require(!locked, \"Reentrancy attempt\");", "        uint256 offerId;", "        while (buy_amt > 0) {", "            //Meanwhile there is amount to buy", "            offerId = getBestOffer(buy_gem, pay_gem); //Get the best offer for the token pair", "            require(offerId != 0);", "", "            // There is a chance that buy_amt is smaller than 1 wei of the other token", "            if (", "                buy_amt * 1 ether <", "                wdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)", "            ) {", "                break; //We consider that all amount is sold", "            }", "            if (buy_amt >= offers[offerId].pay_amt) {", "                //If amount to buy is higher or equal than current offer amount to sell", "                fill_amt = add(fill_amt, offers[offerId].buy_amt); //Add amount sold to acumulator", "                buy_amt = sub(buy_amt, offers[offerId].pay_amt); //Decrease amount to buy", "                take(bytes32(offerId), uint128(offers[offerId].pay_amt)); //We take the whole offer", "            } else {", "                //if lower", "                fill_amt = add(", "                    fill_amt,", "                    rmul(", "                        buy_amt * 10**9,", "                        rdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)", "                    ) / 10**9", "                ); //Add amount sold to acumulator", "                take(bytes32(offerId), uint128(buy_amt)); //We take the portion of the offer that we need", "                buy_amt = 0; //All amount is bought", "            }", "        }", "        require(fill_amt <= max_fill_amount);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _reduceDebtWithoutBurn(address account, ERC721 asset, uint256 amount) internal {", "        _vaultInfo[account][asset].debt = uint200(_vaultInfo[account][asset].debt - amount);", "        emit ReduceDebt(account, asset, amount);", "    }"], "ner_tags": [1, 0, 0, 0]}
{"tokens": ["    function withdraw(", "        uint256 assets,", "        address receiver,", "        address owner", "    ) public override returns (uint256 shares) {", "        // Compound rewards and ensure they are properly accounted for prior to withdrawal calculation", "        compound(poolFee, 1, 0, true);", "", "        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.", "", "        if (msg.sender != owner) {", "            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.", "", "            if (allowed != type(uint256).max)", "                allowance[owner][msg.sender] = allowed - shares;", "        }", "", "        _burn(owner, shares);", "", "        emit Withdraw(msg.sender, receiver, owner, assets, shares);", "", "        asset.safeTransfer(receiver, assets);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _verifyUnsuccessfulState(uint256 _poolId)", "        internal", "        view", "        returns (", "            address,", "            uint48,", "            uint40,", "            bool,", "            bytes32", "        )", "    {", "        PoolInfo memory pool = poolInfo[_poolId];", "        if (pool.success || block.timestamp > pool.terminationPeriod) revert InvalidState();", "        return (", "            pool.nftContract,", "            pool.totalSupply,", "            pool.terminationPeriod,", "            pool.success,", "            pool.merkleRoot", "        );", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function initialize(", "        address timelock_,", "        address nouns_,", "        address vetoer_,", "        uint256 votingPeriod_,", "        uint256 votingDelay_,", "        uint256 proposalThresholdBPS_,", "        DynamicQuorumParams calldata dynamicQuorumParams_", "    ) public virtual {", "        require(address(timelock) == address(0), 'NounsDAO::initialize: can only initialize once');", "        require(msg.sender == admin, 'NounsDAO::initialize: admin only');", "        require(timelock_ != address(0), 'NounsDAO::initialize: invalid timelock address');", "        require(nouns_ != address(0), 'NounsDAO::initialize: invalid nouns address');", "        require(", "            votingPeriod_ >= MIN_VOTING_PERIOD && votingPeriod_ <= MAX_VOTING_PERIOD,", "            'NounsDAO::initialize: invalid voting period'", "        );", "        require(", "            votingDelay_ >= MIN_VOTING_DELAY && votingDelay_ <= MAX_VOTING_DELAY,", "            'NounsDAO::initialize: invalid voting delay'", "        );", "        require(", "            proposalThresholdBPS_ >= MIN_PROPOSAL_THRESHOLD_BPS && proposalThresholdBPS_ <= MAX_PROPOSAL_THRESHOLD_BPS,", "            'NounsDAO::initialize: invalid proposal threshold bps'", "        );", "", "        emit VotingPeriodSet(votingPeriod, votingPeriod_);", "        emit VotingDelaySet(votingDelay, votingDelay_);", "        emit ProposalThresholdBPSSet(proposalThresholdBPS, proposalThresholdBPS_);", "", "        timelock = INounsDAOExecutor(timelock_);", "        nouns = NounsTokenLike(nouns_);", "        vetoer = vetoer_;", "        votingPeriod = votingPeriod_;", "        votingDelay = votingDelay_;", "        proposalThresholdBPS = proposalThresholdBPS_;", "        _setDynamicQuorumParams(", "            dynamicQuorumParams_.minQuorumVotesBPS,", "            dynamicQuorumParams_.maxQuorumVotesBPS,", "            dynamicQuorumParams_.quorumCoefficient", "        );", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _cache(DataTypes.ExecuteMarketplaceParams memory params)", "        internal", "        pure", "        returns (MarketplaceLocalVars memory vars)", "    {", "        vars.isETH = params.credit.token == address(0);", "        vars.creditToken = vars.isETH ? params.weth : params.credit.token;", "        vars.creditAmount = params.credit.amount;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 0, 0]}
{"tokens": ["    function raiseDispute(bytes calldata _data, bytes calldata _signature)", "        external", "        override", "    {", "        // Recover the signer from the signature", "        address signer = SignatureDecoder.recoverKey(", "            keccak256(_data),", "            _signature,", "            0", "        );", "", "        // Decode params from _data", "        (address _project, uint256 _task, , , ) = abi.decode(", "            _data,", "            (address, uint256, uint8, bytes, bytes)", "        );", "", "        // Revert if decoded project address does not match this contract. Indicating incorrect _data.", "        require(_project == address(this), \"Project::!projectAddress\");", "", "        if (_task == 0) {", "            // Revet if sender is not builder or contractor", "            require(", "                signer == builder || signer == contractor,", "                \"Project::!(GC||Builder)\"", "            );", "        } else {", "            // Revet if sender is not builder, contractor or task's subcontractor", "            require(", "                signer == builder ||", "                    signer == contractor ||", "                    signer == tasks[_task].subcontractor,", "                \"Project::!(GC||Builder||SC)\"", "            );", "", "            if (signer == tasks[_task].subcontractor) {", "                // If sender is task's subcontractor, revert if invitation is not accepted.", "                require(getAlerts(_task)[2], \"Project::!SCConfirmed\");", "            }", "        }", "", "        // Make a call to Disputes contract raiseDisputes.", "        IDisputes(disputes).raiseDispute(_data, _signature);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function updateOriginationFeeRate(uint32 _originationFeeRate) external onlyOwner {", "        require(_originationFeeRate <= 5 * (10 ** (INTEREST_RATE_DECIMALS - 2)), \"NFTLoanFacilitator: max fee 5%\");", "        ", "        originationFeeRate = _originationFeeRate;", "", "        emit UpdateOriginationFeeRate(_originationFeeRate);", "    }"], "ner_tags": [0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["  function claimRewardsOnBehalf(", "    address[] calldata assets,", "    uint256 amount,", "    address user,", "    address to,", "    address reward", "  ) external override onlyAuthorizedClaimers(msg.sender, user) returns (uint256) {", "    require(user != address(0), 'INVALID_USER_ADDRESS');", "    require(to != address(0), 'INVALID_TO_ADDRESS');", "    return _claimRewards(assets, amount, msg.sender, user, to, reward);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1]}
{"tokens": ["    function _close(Credit memory credit, bytes32 id) internal virtual returns (bool) {", "        if(credit.principal > 0) { revert CloseFailedWithPrincipal(); }", "", "        // return the Lender's funds that are being repaid", "        if (credit.deposit + credit.interestRepaid > 0) {", "            LineLib.sendOutTokenOrETH(", "                credit.token,", "                credit.lender,", "                credit.deposit + credit.interestRepaid", "            );", "        }", "", "        delete credits[id]; // gas refunds", "", "        // remove from active list", "        ids.removePosition(id);", "        unchecked { --count; }", "", "        // If all credit lines are closed the the overall Line of Credit facility is declared 'repaid'.", "        if (count == 0) { _updateStatus(LineLib.STATUS.REPAID); }", "", "        emit CloseCreditPosition(id);", "", "        return true;", "    }"], "ner_tags": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function mint(TimeswapV2TokenMintParam calldata param) external override returns (bytes memory data) {", "        ParamLibrary.check(param);", "        changeInteractedIfNecessary(param.token0, param.token1, param.strike, param.maturity);", "        raiseGuard(param.token0, param.token1, param.strike, param.maturity);", "", "        address optionPair = OptionFactoryLibrary.getWithCheck(optionFactory, param.token0, param.token1);", "", "        uint256 long0BalanceTarget;", "        // mints TimeswapV2Token in case of the long0 position", "        if (param.long0Amount != 0) {", "            // get the initial balance of the long0 position and add the long0 amount to mint", "            long0BalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long0) + param.long0Amount;", "", "            TimeswapV2TokenPosition memory timeswapV2TokenPosition = TimeswapV2TokenPosition({", "                token0: param.token0,", "                token1: param.token1,", "                strike: param.strike,", "                maturity: param.maturity,", "                position: TimeswapV2OptionPosition.Long0", "            });", "", "            bytes32 key = timeswapV2TokenPosition.toKey();", "            // get the unique id of the TimeswapV2Token position", "            uint256 id = _timeswapV2TokenPositionIds[key];", "", "            // if the id is 0, it means that the position has not been minted yet", "            if (id == 0) {", "                id = totalSupply() + 1;", "                _timeswapV2TokenPositions[id] = timeswapV2TokenPosition;", "                _timeswapV2TokenPositionIds[key] = id;", "            }", "", "            // mint the TimeswapV2Token long0 position", "            console.log(\"reaches right before mint in timeswapv2Tokne::mint\");", "            _mint(param.long0To, id, (param.long0Amount), bytes(\"\"));", "        }", "", "        uint256 long1BalanceTarget;", "        // mints TimeswapV2Token in case of the long1 position", "        if (param.long1Amount != 0) {", "            // get the initial balance of the long1 position and add the long1 amount to mint", "            long1BalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long1) + param.long1Amount;", "", "            TimeswapV2TokenPosition memory timeswapV2TokenPosition = TimeswapV2TokenPosition({", "                token0: param.token0,", "                token1: param.token1,", "                strike: param.strike,", "                maturity: param.maturity,", "                position: TimeswapV2OptionPosition.Long1", "            });", "", "            bytes32 key = timeswapV2TokenPosition.toKey();", "            // get the unique id of the TimeswapV2Token position", "            uint256 id = _timeswapV2TokenPositionIds[key];", "", "            // if the id is 0, it means that the position has not been minted yet", "            if (id == 0) {", "                id = totalSupply() + 1;", "                _timeswapV2TokenPositions[id] = timeswapV2TokenPosition;", "                _timeswapV2TokenPositionIds[key] = id;", "            }", "", "            // mint the TimeswapV2Token long1 position", "            _mint(param.long1To, id, (param.long1Amount), bytes(\"\"));", "        }", "", "        uint256 shortBalanceTarget;", "        // mints TimeswapV2Token in case of the short position", "        if (param.shortAmount != 0) {", "            // get the initial balance of the short position and add the short amount to mint", "            shortBalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Short) + param.shortAmount;", "", "            TimeswapV2TokenPosition memory timeswapV2TokenPosition = TimeswapV2TokenPosition({", "                token0: param.token0,", "                token1: param.token1,", "                strike: param.strike,", "                maturity: param.maturity,", "                position: TimeswapV2OptionPosition.Short", "            });", "", "            bytes32 key = timeswapV2TokenPosition.toKey();", "            // get the unique id of the TimeswapV2Token position", "            uint256 id = _timeswapV2TokenPositionIds[key];", "", "            // if the id is 0, it means that the position has not been minted yet", "            if (id == 0) {", "                id = totalSupply() + 1;", "                _timeswapV2TokenPositions[id] = timeswapV2TokenPosition;", "                _timeswapV2TokenPositionIds[key] = id;", "            }", "", "            // mint the TimeswapV2Token short position", "            _mint(param.shortTo, id, (param.shortAmount), bytes(\"\"));", "        }", "        // console.log()", "        // ask the msg.sender to transfer the long0/long1/short amount to the this contract", "        data = ITimeswapV2TokenMintCallback(msg.sender).timeswapV2TokenMintCallback(", "            TimeswapV2TokenMintCallbackParam({", "                token0: param.token0,", "                token1: param.token1,", "                strike: param.strike,", "                maturity: param.maturity,", "                long0Amount: param.long0Amount,", "                long1Amount: param.long1Amount,", "                shortAmount: param.shortAmount,", "                data: param.data", "            })", "        );", "", "        // check if the long0 position token balance target is achieved. If not, revert the transaction", "        if (param.long0Amount != 0) Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long0), long0BalanceTarget);", "", "        // check if the long1 position token balance target is achieved. If not, revert the transaction", "        if (param.long1Amount != 0) Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long1), long1BalanceTarget);", "", "        // check if the short position token balance target is achieved. If not, revert the transaction", "        if (param.shortAmount != 0) Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Short), shortBalanceTarget);", "", "        lowerGuard(param.token0, param.token1, param.strike, param.maturity);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function setTimelock(address _timelock_address) public onlyByOwnGov {", "        require(_timelock_address != address(0), \"Zero address detected\"); ", "        timelock_address = _timelock_address;", "        emit TimelockChanged(_timelock_address);", "    }"], "ner_tags": [1, 0, 0, 0, 0]}
{"tokens": ["    function submitProposal(", "        Instruction[] calldata instructions_,", "        bytes32 title_,", "        string memory proposalURI_", "    ) external {", "        if (VOTES.balanceOf(msg.sender) * 10000 < VOTES.totalSupply() * SUBMISSION_REQUIREMENT)", "            revert NotEnoughVotesToPropose();", "", "        uint256 proposalId = INSTR.store(instructions_);", "        getProposalMetadata[proposalId] = ProposalMetadata(", "            title_,", "            msg.sender,", "            block.timestamp,", "            proposalURI_", "        );", "", "        emit ProposalSubmitted(proposalId);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function renew(string calldata name, uint256 duration)", "        external", "        payable", "        override", "    {", "        bytes32 label = keccak256(bytes(name));", "        IPriceOracle.Price memory price = rentPrice(name, duration);", "        require(", "            msg.value >= price.base,", "            \"ETHController: Not enough Ether provided for renewal\"", "        );", "", "        uint256 expires = base.renew(uint256(label), duration);", "", "        if (msg.value > price.base) {", "            payable(msg.sender).transfer(msg.value - price.base);", "        }", "", "        emit NameRenewed(name, label, msg.value, expires);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function getAmounts(", "        ILBPair.Bin memory bin,", "        FeeHelper.FeeParameters memory fp,", "        uint256 activeId,", "        bool swapForY,", "        uint256 amountIn", "    )", "        internal", "        pure", "        returns (", "            uint256 amountInToBin,", "            uint256 amountOutOfBin,", "            FeeHelper.FeesDistribution memory fees", "        )", "    {", "        uint256 _price = BinHelper.getPriceFromId(activeId, fp.binStep);", "", "        uint256 _reserve;", "        uint256 _maxAmountInToBin;", "        if (swapForY) {", "            _reserve = bin.reserveY;", "            _maxAmountInToBin = _reserve.shiftDivRoundUp(Constants.SCALE_OFFSET, _price);", "        } else {", "            _reserve = bin.reserveX;", "            _maxAmountInToBin = _price.mulShiftRoundUp(_reserve, Constants.SCALE_OFFSET);", "        }", "", "        fp.updateVolatilityAccumulated(activeId);", "        fees = fp.getFeeAmountDistribution(fp.getFeeAmount(_maxAmountInToBin));", "", "        if (_maxAmountInToBin + fees.total <= amountIn) {", "            amountInToBin = _maxAmountInToBin;", "            amountOutOfBin = _reserve;", "        } else {", "            fees = fp.getFeeAmountDistribution(fp.getFeeAmountFrom(amountIn));", "            amountInToBin = amountIn - fees.total;", "            amountOutOfBin = swapForY", "                ? _price.mulShiftRoundDown(amountInToBin, Constants.SCALE_OFFSET)", "                : amountInToBin.shiftDivRoundDown(Constants.SCALE_OFFSET, _price);", "            // Safety check in case rounding returns a higher value than expected", "            if (amountOutOfBin > _reserve) amountOutOfBin = _reserve;", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function addLiquidity(", "        uint256 stETHAmount,", "        uint256 xETHAmount,", "        uint256 minLpOut", "    ) external onlyRole(DEFAULT_ADMIN_ROLE) returns (uint256 lpOut) {", "        stETH.safeTransferFrom(msg.sender, address(this), stETHAmount);", "        xETH.mintShares(xETHAmount);", "", "        uint256[2] memory amounts;", "", "        amounts[xETHIndex] = xETHAmount;", "        amounts[stETHIndex] = stETHAmount;", "", "        IERC20(address(xETH)).safeApprove(address(curvePool), xETHAmount);", "        stETH.safeApprove(address(curvePool), stETHAmount);", "", "        lpOut = curvePool.add_liquidity(amounts, minLpOut);", "", "        /// @notice no need for safeApprove, direct transfer + deposit", "        IERC20(address(curvePool)).safeTransfer(address(cvxStaker), lpOut);", "        cvxStaker.depositAndStake(lpOut);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function buyPrincipalToken(", "        address u,", "        uint256 m,", "        uint128 a", "    ) external returns (uint128) {", "        IPool pool = IPool(pools[u][m]);", "        Safe.transfer(IERC20(address(pool.base())), address(pool), a);", "        return pool.buyFYToken(msg.sender, pool.buyFYTokenPreview(a), a);", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function _addReward(", "        address _token,", "        uint256 _amount,", "        uint256 _epoch", "    ) internal nonReentrant {", "        // Pull before reward accrual", "        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);", "", "        //convert to reward per token", "        uint256 supply = auraLocker.totalSupplyAtEpoch(_epoch);", "        uint256 rPerT = (_amount * 1e20) / supply;", "        rewardData[_token][_epoch] += rPerT;", "", "        //add epoch to list", "        uint256 len = rewardEpochs[_token].length;", "        if (len == 0 || rewardEpochs[_token][len - 1] < _epoch) {", "            rewardEpochs[_token].push(_epoch);", "        }", "", "        //event", "        emit RewardAdded(_token, _epoch, _amount);", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {", "    (address token0, address token1) = sortTokens(tokenA, tokenB);", "    pair = address(", "      uint160( // extra cast for newer solidity", "        uint256(", "          keccak256(", "            abi.encodePacked(", "              hex\"ff\",", "              factory,", "              keccak256(abi.encodePacked(token0, token1)),", "              hex\"e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303\" // init code hash", "            )", "          )", "        )", "      )", "    );", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function addFeedFor(", "    uint256 _currency,", "    uint256 _base,", "    IJBPriceFeed _feed", "  ) external override onlyOwner {", "    // There can't already be a feed for the specified currency.", "    if (feedFor[_currency][_base] != IJBPriceFeed(address(0))) revert PRICE_FEED_ALREADY_EXISTS();", "", "    // Store the feed.", "    feedFor[_currency][_base] = _feed;", "", "    emit AddFeed(_currency, _base, _feed);", "  }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function permit(", "        address owner,", "        address spender,", "        uint256 value,", "        uint256 deadline,", "        uint8 v,", "        bytes32 r,", "        bytes32 s", "    ) public virtual {", "        if (deadline < block.timestamp) {", "            revert Deadline(deadline, block.timestamp);", "        }", "        // Unchecked because the only math done is incrementing", "        // the owner's nonce which cannot realistically overflow.", "        unchecked {", "            address recoveredAddress = ecrecover(", "                keccak256(", "                    abi.encodePacked(", "                        \"\\x19\\x01\",", "                        DOMAIN_SEPARATOR(),", "                        keccak256(", "                            abi.encode(", "                                keccak256(", "                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"", "                                ),", "                                owner,", "                                spender,", "                                value,", "                                nonces[owner]++,", "                                deadline", "                            )", "                        )", "                    )", "                ),", "                v,", "                r,", "                s", "            );", "", "            if (recoveredAddress != address(0) && recoveredAddress != owner) {", "                revert Invalid(msg.sender, owner);", "            }", "", "            allowance[recoveredAddress][spender] = value;", "        }", "", "        emit Approval(owner, spender, value);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function moveWithheldETH(address payable to, uint256 amount) external onlyByOwnGov {", "        require(amount <= currentWithheldETH, \"Not enough withheld ETH in contract\");", "        currentWithheldETH -= amount;", "", "        (bool success,) = payable(to).call{ value: amount }(\"\");", "        require(success, \"Invalid transfer\");", "", "        emit WithheldETHMoved(to, amount);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function updateProjectHash(bytes calldata _data, bytes calldata _signature)", "        external", "        override", "    {", "        // Check for required signatures", "        checkSignature(_data, _signature);", "", "        // Decode params from _data", "        (bytes memory _hash, uint256 _nonce) = abi.decode(", "            _data,", "            (bytes, uint256)", "        );", "", "        // Revert if decoded nonce is incorrect. This indicates wrong _data.", "        require(_nonce == hashChangeNonce, \"Project::!Nonce\");", "", "        // Increment to ensure a set of data and signature cannot be re-used.", "        hashChangeNonce += 1;", "", "        emit HashUpdated(_hash);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function execute(", "        address payer,", "        bytes32 account,", "        address beneficiary,", "        bytes32 protocol,", "        uint256 maxWeiForGas", "    ) public override returns (bool) {", "        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);", "", "        ExecuteLocalVars memory vars;", "", "        vars.initialGas = gasleft();", "", "        Record storage position = _positions[payer][account][protocol];", "        require(position.threshold != 0, Error.NO_POSITION_EXISTS);", "        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);", "        require(block.timestamp > position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);", "", "        vars.topUpHandler = _getHandler(protocol, true);", "        vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);", "", "        // ensure that the position is actually below its set user factor threshold", "        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);", "", "        IAddressProvider addressProvider_ = addressProvider;", "        IGasBank gasBank = addressProvider_.getGasBank();", "", "        // fail early if the user does not have enough funds in the gas bank", "        // to cover the cost of the transaction", "        vars.estimatedRequiredGas = getEstimatedGasUsage();", "        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;", "", "        // compute the gas price that the user will be paying", "        vars.userGasPrice = block.basefee + position.priorityFee;", "        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;", "        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;", "", "        // ensure the current position allows for the gas to be paid", "        require(", "            vars.estimatedRequiredWeiForGas <=", "                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,", "            Error.ESTIMATED_GAS_TOO_HIGH", "        );", "", "        vars.gasBankBalance = gasBank.balanceOf(payer);", "        // ensure the user has enough funds in the gas bank to cover the gas", "        require(", "            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,", "            Error.GAS_BANK_BALANCE_TOO_LOW", "        );", "", "        vars.totalTopUpAmount = position.totalTopUpAmount;", "        vars.actionFee = getActionFee();", "        // add top-up fees to top-up amount", "        vars.minActionAmountToTopUp = position.singleTopUpAmount;", "        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(", "            ScaledMath.ONE + vars.actionFee", "        );", "", "        // if the amount that we want to top-up (including fees) is higher than", "        // the available topup amount, we lower this down to what is left of the position", "        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {", "            vars.actionAmountWithFees = vars.totalTopUpAmount;", "            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(", "                ScaledMath.ONE + vars.actionFee", "            );", "        }", "        ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);", "        vars.underlying = pool.getUnderlying();", "        vars.rate = pool.exchangeRate();", "", "        // compute the deposit tokens amount with and without fees", "        // we will need to unstake the amount with fees and to", "        // swap the amount without fees into action tokens", "        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);", "        if (position.depositTokenBalance < vars.depositAmountWithFees) {", "            vars.depositAmountWithFees = position.depositTokenBalance;", "            vars.minActionAmountToTopUp =", "                (vars.depositAmountWithFees * vars.rate) /", "                (ScaledMath.ONE + vars.actionFee);", "        }", "", "        // compute amount of LP tokens needed to pay for action", "        // rate is expressed in actionToken per depositToken", "        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);", "        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;", "", "        // will revert if vault does not exist", "        address vault = addressProvider_.getStakerVault(position.depositToken);", "", "        // unstake deposit tokens including fees", "        IStakerVault(vault).unstake(vars.depositAmountWithFees);", "        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);", "", "        // swap the amount without the fees", "        // as the fees are paid in deposit token, not in action token", "        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);", "", "        // compute how much of action token was actually redeemed and add fees to it", "        // this is to ensure that no funds get locked inside the contract", "        vars.totalActionTokenAmount =", "            vars.actionTokenAmount +", "            vars.depositTotalFeesAmount.scaledMul(vars.rate);", "", "        // at this point, we have exactly `vars.actionTokenAmount`", "        // (at least `position.singleTopUpAmount`) of action token", "        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract", "        // solhint-disable-next-line avoid-low-level-calls", "        uint256 value_;", "        if (position.actionToken == address(0)) {", "            value_ = vars.actionTokenAmount;", "        } else {", "            _approve(position.actionToken, vars.topUpHandler);", "        }", "        vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(", "            account,", "            position.actionToken,", "            vars.actionTokenAmount,", "            position.extra", "        );", "", "        require(vars.topupResult, Error.TOP_UP_FAILED);", "", "        // totalTopUpAmount is updated to reflect the new \"balance\" of the position", "        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {", "            position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();", "        } else {", "            position.totalTopUpAmount = 0;", "        }", "", "        position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();", "", "        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;", "        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);", "        if (vars.removePosition) {", "            if (position.depositTokenBalance > 0) {", "                // transfer any unused locked tokens to the payer", "                IStakerVault(vault).transfer(payer, position.depositTokenBalance);", "                IStakerVault(vault).decreaseActionLockedBalance(", "                    payer,", "                    position.depositTokenBalance", "                );", "            }", "            _removePosition(payer, account, protocol);", "        }", "", "        emit TopUp(", "            account,", "            protocol,", "            payer,", "            position.depositToken,", "            vars.depositAmountWithFees,", "            position.actionToken,", "            vars.actionTokenAmount", "        );", "", "        // compute gas used and reimburse the keeper by using the", "        // funds of payer in the gas bank", "        // TODO: add constant gas consumed for transfer and tx prologue", "        vars.gasConsumed = vars.initialGas - gasleft();", "", "        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;", "        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {", "            vars.reimbursedWeiForGas = vars.gasBankBalance;", "        }", "", "        // ensure that the keeper is not overpaying", "        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;", "        require(", "            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,", "            Error.GAS_TOO_HIGH", "        );", "        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);", "        if (vars.removePosition) {", "            gasBank.withdrawUnused(payer);", "        }", "", "        return true;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function scaleAmountByPercentage(uint256 amount, uint256 scaledPercent)", "        public", "        pure", "        returns (uint256 scaledAmount)", "    {", "        /*", "            Example:", "                If there is 100 ETH in the account, and someone has ", "                an allocation of 2%, we call this with 100 as the amount, and 200", "                as the scaled percent.", "", "                To find out the amount we use, for example: (100 * 200) / (100 * 100)", "                which returns 2 -- i.e. 2% of the 100 ETH balance.", "         */", "        scaledAmount = (amount * scaledPercent) / (10000);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["    function _beforeTokenTransfer(", "        address _from,", "        address _to,", "        uint256 _tokenId", "    ) internal virtual override {", "        super._beforeTokenTransfer(_from, _to, _tokenId);", "", "        if (", "            royaltyVault != address(0) &&", "            IRoyaltyVault(royaltyVault).getVaultBalance() > 0", "        ) {", "            IRoyaltyVault(royaltyVault).sendToSplitter();", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["    function initializePublicationCollectModule(", "        uint256 profileId,", "        uint256 pubId,", "        bytes calldata data", "    ) external override onlyHub returns (bytes memory) {", "        (uint256 amount, address currency, address recipient, uint16 referralFee) = abi.decode(", "            data,", "            (uint256, address, address, uint16)", "        );", "        if (", "            !_currencyWhitelisted(currency) ||", "            recipient == address(0) ||", "            referralFee > BPS_MAX ||", "            amount < BPS_MAX", "        ) revert Errors.InitParamsInvalid();", "", "        _dataByPublicationByProfile[profileId][pubId].referralFee = referralFee;", "        _dataByPublicationByProfile[profileId][pubId].recipient = recipient;", "        _dataByPublicationByProfile[profileId][pubId].currency = currency;", "        _dataByPublicationByProfile[profileId][pubId].amount = amount;", "", "        return data;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function _popOperator(uint256 pod, uint256 operatorIndex) private {", "    /**", "     * @dev only pop the operator if it's not a zero address", "     */", "    if (operatorIndex > 0) {", "      unchecked {", "        address operator = _operatorPods[pod][operatorIndex];", "        /**", "         * @dev mark operator as no longer bonded", "         */", "        _bondedOperators[operator] = 0;", "        /**", "         * @dev remove pod reference for operator", "         */", "        _operatorPodIndex[operator] = 0;", "        uint256 lastIndex = _operatorPods[pod].length - 1;", "        if (lastIndex != operatorIndex) {", "          /**", "           * @dev if operator is not last index, move last index to operator's current index", "           */", "          _operatorPods[pod][operatorIndex] = _operatorPods[pod][lastIndex];", "          _operatorPodIndex[_operatorPods[pod][operatorIndex]] = operatorIndex;", "        }", "        /**", "         * @dev delete last index", "         */", "        delete _operatorPods[pod][lastIndex];", "        /**", "         * @dev shorten array length", "         */", "        _operatorPods[pod].pop();", "      }", "    }", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function setPlatformFee(address _vault, uint256 _platformFee)", "    external", "    onlyOwner", "  {", "    IRoyaltyVault(_vault).setPlatformFee(_platformFee);", "  }"], "ner_tags": [1, 0, 0, 0, 0, 0]}
{"tokens": ["    function setFee(uint256 _fee) public payable onlyOwner {", "        require(_fee < 30, \"fee must be less than 3%\");", "", "        fee = _fee;", "", "        emit NewFee(_fee);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _call(", "        bytes32 id,", "        uint256 index,", "        address target,", "        uint256 value,", "        bytes memory data", "    ) private {", "        // solhint-disable-next-line avoid-low-level-calls", "        (bool success, ) = target.call{value: value}(data);", "        require(success, \"TimelockController: underlying transaction reverted\");", "", "        emit CallExecuted(id, index, target, value, data);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0]}
{"tokens": ["  function _transferYield(address _asset) internal {", "    require(_asset != address(0), Errors.VT_PROCESS_YIELD_INVALID);", "    uint256 yieldAmount = IERC20(_asset).balanceOf(address(this));", "", "    // transfer to treasury", "    if (_vaultFee > 0) {", "      uint256 treasuryAmount = _processTreasury(_asset, yieldAmount);", "      yieldAmount = yieldAmount.sub(treasuryAmount);", "    }", "", "    // transfer to yieldManager", "    address yieldManager = _addressesProvider.getAddress('YIELD_MANAGER');", "    TransferHelper.safeTransfer(_asset, yieldManager, yieldAmount);", "", "    emit ProcessYield(_asset, yieldAmount);", "  }"], "ner_tags": [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": ["  function totalAssets()", "    public", "    view", "    virtual", "    override(ERC4626Cloned)", "    returns (uint256)", "  {", "    VaultData storage s = _loadStorageSlot();", "    return _totalAssets(s);", "  }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function addValidators(Validator[] calldata validatorArray) external onlyByOwnGov {", "        uint arrayLength = validatorArray.length;", "        for (uint256 i = 0; i < arrayLength; ++i) {", "            addValidator(validatorArray[i]);", "        }", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0]}
{"tokens": ["    function fractionalTokenReserves() public view returns (uint256) {", "        return balanceOf[address(this)];", "    }"], "ner_tags": [0, 1, 0]}
{"tokens": ["    function _redeem(", "        uint256 amount,", "        address to,", "        uint256 deadline,", "        uint256[] memory minAmountOuts,", "        address[] memory forfeitTokens", "    ) internal returns (address[] memory tokens, uint256[] memory amounts) {", "        TransmuterStorage storage ts = s.transmuterStorage();", "        if (ts.isRedemptionLive == 0) revert Paused();", "        if (block.timestamp > deadline) revert TooLate();", "        uint256[] memory subCollateralsTracker;", "        (tokens, amounts, subCollateralsTracker) = _quoteRedemptionCurve(amount);", "        // Updating the normalizer enables to simultaneously and proportionally reduce the amount", "        // of stablecoins issued from each collateral without having to loop through each of them", "        _updateNormalizer(amount, false);", "", "        IAgToken(ts.agToken).burnSelf(amount, msg.sender);", "", "        address[] memory collateralListMem = ts.collateralList;", "        uint256 indexCollateral;", "        for (uint256 i; i < amounts.length; ++i) {", "            if (amounts[i] < minAmountOuts[i]) revert TooSmallAmountOut();", "            // If a token is in the `forfeitTokens` list, then it is not sent as part of the redemption process", "            if (amounts[i] > 0 && LibHelpers.checkList(tokens[i], forfeitTokens) < 0) {", "                Collateral storage collatInfo = ts.collaterals[collateralListMem[indexCollateral]];", "                if (collatInfo.onlyWhitelisted > 0 && !LibWhitelist.checkWhitelist(collatInfo.whitelistData, to))", "                    revert NotWhitelisted();", "                if (collatInfo.isManaged > 0)", "                    LibManager.release(tokens[i], to, amounts[i], collatInfo.managerData.config);", "                else IERC20(tokens[i]).safeTransfer(to, amounts[i]);", "            }", "            if (subCollateralsTracker[indexCollateral] - 1 <= i) ++indexCollateral;", "        }", "        emit Redeemed(amount, tokens, amounts, forfeitTokens, msg.sender, to);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function checkFees(uint64[] memory xFee, int64[] memory yFee, ActionType action) internal view {", "        uint256 n = xFee.length;", "        if (n != yFee.length || n == 0) revert InvalidParams();", "        if (", "            // Mint inflexion points should be in [0,BASE_9[", "            // We have: amountPostFee * (BASE_9 + yFeeMint) = amountPreFee * BASE_9", "            // Hence we consider BASE_12 as the max value (100% fees) for yFeeMint", "            (action == ActionType.Mint && (xFee[n - 1] >= BASE_9 || xFee[0] != 0 || yFee[n - 1] > int256(BASE_12))) ||", "            // Burn inflexion points should be in [0,BASE_9] but fees should be constant in", "            // the first segment [BASE_9, x_{n-1}[", "            (action == ActionType.Burn &&", "                (xFee[0] != BASE_9 || yFee[n - 1] > int256(BASE_9) || (n > 1 && (yFee[0] != yFee[1])))) ||", "            // Redemption inflexion points should be in [0,BASE_9]", "            (action == ActionType.Redeem && (xFee[n - 1] > BASE_9 || yFee[n - 1] < 0 || yFee[n - 1] > int256(BASE_9)))", "        ) revert InvalidParams();", "", "        for (uint256 i = 0; i < n - 1; ++i) {", "            if (", "                // xFee strictly increasing and yFee increasing for mints", "                (action == ActionType.Mint && (xFee[i] >= xFee[i + 1] || (yFee[i + 1] < yFee[i]))) ||", "                // xFee strictly decreasing and yFee increasing for burns", "                (action == ActionType.Burn && (xFee[i] <= xFee[i + 1] || (yFee[i + 1] < yFee[i]))) ||", "                // xFee strictly increasing and yFee should be in [0,BASE_9] for redemptions", "                (action == ActionType.Redeem && (xFee[i] >= xFee[i + 1] || yFee[i] < 0 || yFee[i] > int256(BASE_9)))", "            ) revert InvalidParams();", "        }", "", "        // If a mint or burn fee is negative, we need to check that accounts atomically minting", "        // (from any collateral) and then burning cannot get more than their initial value", "        if (yFee[0] < 0) {", "            if (!LibDiamond.isGovernor(msg.sender)) revert NotGovernor(); // Only governor can set negative fees", "            TransmuterStorage storage ts = s.transmuterStorage();", "            address[] memory collateralListMem = ts.collateralList;", "            uint256 length = collateralListMem.length;", "            if (action == ActionType.Mint) {", "                // This can be mathematically expressed by `(1-min_c(burnFee_c))<=(1+mintFee[0])`", "                for (uint256 i; i < length; ++i) {", "                    int64[] memory burnFees = ts.collaterals[collateralListMem[i]].yFeeBurn;", "                    if (burnFees[0] + yFee[0] < 0) revert InvalidNegativeFees();", "                }", "            }", "            if (action == ActionType.Burn) {", "                // This can be mathematically expressed by `(1-burnFee[0])<=(1+min_c(mintFee_c))`", "                for (uint256 i; i < length; ++i) {", "                    int64[] memory mintFees = ts.collaterals[collateralListMem[i]].yFeeMint;", "                    if (yFee[0] + mintFees[0] < 0) revert InvalidNegativeFees();", "                }", "            }", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function increaseDebtAndSell(", "        address proceedsTo,", "        ERC721 collateralAsset,", "        IPaprController.SwapParams calldata params,", "        ReservoirOracleUnderwriter.OracleInfo calldata oracleInfo", "    ) external override returns (uint256 amountOut) {", "        bool hasFee = params.swapFeeBips != 0;", "", "        (amountOut,) = UniswapHelpers.swap(", "            pool,", "            hasFee ? address(this) : proceedsTo,", "            !token0IsUnderlying,", "            params.amount,", "            params.minOut,", "            params.sqrtPriceLimitX96,", "            abi.encode(msg.sender, collateralAsset, oracleInfo)", "        );", "", "        if (hasFee) {", "            uint256 fee = amountOut * params.swapFeeBips / BIPS_ONE;", "            underlying.transfer(params.swapFeeTo, fee);", "            underlying.transfer(proceedsTo, amountOut - fee);", "        }", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _updateAddress(", "        address rateLimitedAddress,", "        uint112 _rateLimitPerSecond,", "        uint112 _bufferCap", "    ) internal {", "        RateLimitData storage rateLimitData = rateLimitPerAddress[", "            rateLimitedAddress", "        ];", "", "        require(", "            rateLimitData.lastBufferUsedTime != 0,", "            \"MultiRateLimited: rate limit address does not exist\"", "        );", "        require(", "            _rateLimitPerSecond <= MAX_RATE_LIMIT_PER_SECOND,", "            \"MultiRateLimited: rateLimitPerSecond too high\"", "        );", "", "        uint112 oldRateLimitPerSecond = rateLimitData.rateLimitPerSecond;", "", "        rateLimitData.lastBufferUsedTime = block.timestamp.toUint32();", "        rateLimitData.bufferCap = _bufferCap;", "        rateLimitData.rateLimitPerSecond = _rateLimitPerSecond;", "        rateLimitData.bufferStored = _bufferCap;", "", "        emit IndividualRateLimitPerSecondUpdate(", "            rateLimitedAddress,", "            oldRateLimitPerSecond,", "            _rateLimitPerSecond", "        );", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function verifyVestingSchedule(uint treeIndex, uint vestingTime, uint minTotalPayments, uint maxTotalPayments) public view returns (bool, uint, uint, uint) {", "        // vesting schedules for non-existing trees are invalid, I don't care how much you like uninitialized structs", "        if (treeIndex > numTrees) {", "            return (false, 0, 0, 0);", "        }", "", "        // memory not storage, since we do not edit the tree, and it's a view function anyways", "        MerkleTree memory tree = merkleTrees[treeIndex];", "", "        // vesting time must sit within the closed interval of [minEndTime, maxEndTime]", "        if (vestingTime > tree.maxEndTime || vestingTime < tree.minEndTime) {", "            return (false, 0, 0, 0);", "        }", "", "        uint totalCoins;", "        if (vestingTime == tree.maxEndTime) {", "            // this is to prevent dust accumulation from rounding errors", "            // maxEndTime results in max payments, no further computation necessary", "            totalCoins = maxTotalPayments;", "        } else {", "            // remember grade school algebra? slope = \u0394y / \u0394x", "            // this is the slope of eligible vesting schedules. In general, 0 < m < 1,", "            // (longer vesting schedules should result in less coins per second, hence \"resistor\")", "            // so we multiply by a precision factor to reduce rounding errors", "            // y axis = total coins released after vesting completed", "            // x axis = length of vesting schedule", "            // this is the line of valid end-points for the chosen vesting schedule line, see below", "            // NOTE: this reverts if minTotalPayments > maxTotalPayments, which is a good thing", "            uint paymentSlope = (maxTotalPayments - minTotalPayments) * PRECISION / (tree.maxEndTime - tree.minEndTime);", "", "            // y = mx + b = paymentSlope * (x - x0) + y0", "            // divide by precision factor here since we have completed the rounding error sensitive operations", "            totalCoins = (paymentSlope * (vestingTime - tree.minEndTime) / PRECISION) + minTotalPayments;", "        }", "", "        // this is a different slope, the slope of their chosen vesting schedule", "        // y axis = cumulative coins emitted", "        // x axis = time elapsed", "        // NOTE: vestingTime starts from block.timestamp, so doesn't include coins already available from pctUpFront", "        // totalCoins / vestingTime is wrong, we have to multiple by the proportion of the coins that are indexed", "        // by vestingTime, which is (100 - pctUpFront) / 100", "        uint coinsPerSecond = (totalCoins * (uint(100) - tree.pctUpFront)) / (vestingTime * 100);", "", "        // vestingTime is relative to initialization point", "        // endTime = block.timestamp + vestingTime", "        // vestingLength = totalCoins / coinsPerSecond", "        uint startTime = block.timestamp + vestingTime - (totalCoins / coinsPerSecond);", "", "        return (true, totalCoins, coinsPerSecond, startTime);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["    function processCollect(", "        uint256 referrerProfileId,", "        address collector,", "        uint256 profileId,", "        uint256 pubId,", "        bytes calldata data", "    ) external virtual override onlyHub {", "        _checkFollowValidity(profileId, collector);", "        if (referrerProfileId == profileId) {", "            _processCollect(collector, profileId, pubId, data);", "        } else {", "            _processCollectWithReferral(referrerProfileId, collector, profileId, pubId, data);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["  function addLiquidity(AddLiquidityParams calldata params) external payable checkDeadline(params.deadline) {", "    address lendgine = LendgineAddress.computeAddress(", "      factory, params.token0, params.token1, params.token0Exp, params.token1Exp, params.upperBound", "    );", "", "    uint256 r0 = ILendgine(lendgine).reserve0();", "    uint256 r1 = ILendgine(lendgine).reserve1();", "    uint256 totalLiquidity = ILendgine(lendgine).totalLiquidity();", "", "    uint256 amount0;", "    uint256 amount1;", "", "    if (totalLiquidity == 0) {", "      amount0 = params.amount0Min;", "      amount1 = params.amount1Min;", "    } else {", "      amount0 = FullMath.mulDivRoundingUp(params.liquidity, r0, totalLiquidity);", "      amount1 = FullMath.mulDivRoundingUp(params.liquidity, r1, totalLiquidity);", "    }", "", "    if (amount0 < params.amount0Min || amount1 < params.amount1Min) revert AmountError();", "", "    uint256 size = ILendgine(lendgine).deposit(", "      address(this),", "      params.liquidity,", "      abi.encode(", "        PairMintCallbackData({", "          token0: params.token0,", "          token1: params.token1,", "          token0Exp: params.token0Exp,", "          token1Exp: params.token1Exp,", "          upperBound: params.upperBound,", "          amount0: amount0,", "          amount1: amount1,", "          payer: msg.sender", "        })", "      )", "    );", "    if (size < params.sizeMin) revert AmountError();", "", "    Position memory position = positions[params.recipient][lendgine]; // SLOAD", "", "    (, uint256 rewardPerPositionPaid,) = ILendgine(lendgine).positions(address(this));", "    position.tokensOwed += FullMath.mulDiv(position.size, rewardPerPositionPaid - position.rewardPerPositionPaid, 1e18);", "    position.rewardPerPositionPaid = rewardPerPositionPaid;", "    position.size += size;", "", "    positions[params.recipient][lendgine] = position; // SSTORE", "", "    emit AddLiquidity(msg.sender, lendgine, params.liquidity, size, amount0, amount1, params.recipient);", "  }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function _convertAssetToExchangeToken(address asset, uint256 amount) internal {", "    UniswapAdapter.swapExactTokensForTokens(", "      _addressesProvider,", "      asset,", "      _exchangeToken,", "      amount,", "      UNISWAP_FEE,", "      SLIPPAGE", "    );", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["    function getReward() external updateReward(msg.sender) {", "        uint reward = rewards[msg.sender];", "        if (reward > 0) {", "            rewards[msg.sender] = 0;", "            IEUSD EUSD = IEUSD(configurator.getEUSDAddress());", "            uint256 balance = EUSD.sharesOf(address(this));", "            uint256 eUSDShare = balance >= reward ? reward : reward - balance;", "            EUSD.transferShares(msg.sender, eUSDShare);", "            if(reward > eUSDShare) {", "                ERC20 peUSD = ERC20(configurator.peUSD());", "                uint256 peUSDBalance = peUSD.balanceOf(address(this));", "                if(peUSDBalance >= reward - eUSDShare) {", "                    peUSD.transfer(msg.sender, reward - eUSDShare);", "                    emit ClaimReward(msg.sender, EUSD.getMintedEUSDByShares(eUSDShare), address(peUSD), reward - eUSDShare, block.timestamp);", "                } else {", "                    if(peUSDBalance > 0) {", "                        peUSD.transfer(msg.sender, peUSDBalance);", "                    }", "                    ERC20 token = ERC20(configurator.stableToken());", "                    uint256 tokenAmount = (reward - eUSDShare - peUSDBalance) * token.decimals() / 1e18;", "                    token.transfer(msg.sender, tokenAmount);", "                    emit ClaimReward(msg.sender, EUSD.getMintedEUSDByShares(eUSDShare), address(token), reward - eUSDShare, block.timestamp);", "                }", "            } else {", "                emit ClaimReward(msg.sender, EUSD.getMintedEUSDByShares(eUSDShare), address(0), 0, block.timestamp);", "            }", "           ", "        }", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function triggerEmergencyWithdraw(bool trigger) external onlyOwner {", "        emergency = trigger;", "    }"], "ner_tags": [1, 0, 0]}
{"tokens": ["  function _distributeFunds(", "    address nftContract,", "    uint256 tokenId,", "    address payable seller,", "    uint256 price,", "    address payable buyReferrer", "  )", "    internal", "    returns (", "      uint256 totalFees,", "      uint256 creatorRev,", "      uint256 sellerRev", "    )", "  {", "    address payable[] memory creatorRecipients;", "    uint256[] memory creatorShares;", "", "    uint256 buyReferrerFee;", "    (totalFees, creatorRecipients, creatorShares, sellerRev, buyReferrerFee) = _getFees(", "      nftContract,", "      tokenId,", "      seller,", "      price,", "      buyReferrer", "    );", "", "    // Pay the creator(s)", "    unchecked {", "      for (uint256 i = 0; i < creatorRecipients.length; ++i) {", "        _sendValueWithFallbackWithdraw(", "          creatorRecipients[i],", "          creatorShares[i],", "          SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS", "        );", "        // Sum the total creator rev from shares", "        // creatorShares is in ETH so creatorRev will not overflow here.", "        creatorRev += creatorShares[i];", "      }", "    }", "", "    // Pay the seller", "    _sendValueWithFallbackWithdraw(seller, sellerRev, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);", "", "    // Pay the protocol fee", "    _sendValueWithFallbackWithdraw(getFoundationTreasury(), totalFees, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);", "", "    // Pay the buy referrer fee", "    if (buyReferrerFee != 0) {", "      _sendValueWithFallbackWithdraw(buyReferrer, buyReferrerFee, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);", "      emit BuyReferralPaid(nftContract, tokenId, buyReferrer, buyReferrerFee, 0);", "      unchecked {", "        // Add the referrer fee back into the total fees so that all 3 return fields sum to the total price for events", "        totalFees += buyReferrerFee;", "      }", "    }", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function initialize(", "    uint256 _projectId,", "    IJBDirectory _directory,", "    string memory _name,", "    string memory _symbol,", "    IJBFundingCycleStore _fundingCycleStore,", "    string memory _baseUri,", "    IJBTokenUriResolver _tokenUriResolver,", "    string memory _contractUri,", "    JB721PricingParams memory _pricing,", "    IJBTiered721DelegateStore _store,", "    JBTiered721Flags memory _flags", "  ) public override {", "    // Make the original un-initializable.", "    require(address(this) != codeOrigin);", "    // Stop re-initialization.", "    require(address(store) == address(0));", "", "    // Initialize the sub class.", "    JB721Delegate._initialize(_projectId, _directory, _name, _symbol);", "", "    fundingCycleStore = _fundingCycleStore;", "    store = _store;", "    pricingCurrency = _pricing.currency;", "    pricingDecimals = _pricing.decimals;", "    prices = _pricing.prices;", "", "    // Store the base URI if provided.", "    if (bytes(_baseUri).length != 0) _store.recordSetBaseUri(_baseUri);", "", "    // Set the contract URI if provided.", "    if (bytes(_contractUri).length != 0) _store.recordSetContractUri(_contractUri);", "", "    // Set the token URI resolver if provided.", "    if (_tokenUriResolver != IJBTokenUriResolver(address(0)))", "      _store.recordSetTokenUriResolver(_tokenUriResolver);", "", "    // Record adding the provided tiers.", "    if (_pricing.tiers.length > 0) _store.recordAddTiers(_pricing.tiers);", "", "    // Set the flags if needed.", "    if (", "      _flags.lockReservedTokenChanges ||", "      _flags.lockVotingUnitChanges ||", "      _flags.lockManualMintingChanges ||", "      _flags.pausable", "    ) _store.recordFlags(_flags);", "", "    // Transfer ownership to the initializer.", "    _transferOwnership(msg.sender);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function setVcon(IERC20 _vcon) external onlyGovernor {", "        vcon = _vcon;", "", "        emit VconUpdate(_vcon);", "    }"], "ner_tags": [1, 0, 0, 0, 0]}
{"tokens": ["    event ProposalSubmitted(uint256 proposalId);"], "ner_tags": [1]}
{"tokens": ["    function _addInterest()", "        internal", "        returns (", "            uint256 _interestEarned,", "            uint256 _feesAmount,", "            uint256 _feesShare,", "            uint64 _newRate", "        )", "    {", "        // Add interest only once per block", "        CurrentRateInfo memory _currentRateInfo = currentRateInfo;", "        if (_currentRateInfo.lastTimestamp == block.timestamp) {", "            _newRate = _currentRateInfo.ratePerSec;", "            return (_interestEarned, _feesAmount, _feesShare, _newRate);", "        }", "", "        // Pull some data from storage to save gas", "        VaultAccount memory _totalAsset = totalAsset;", "        VaultAccount memory _totalBorrow = totalBorrow;", "", "        // If there are no borrows or contract is paused, no interest accrues and we reset interest rate", "        if (_totalBorrow.shares == 0 || paused()) {", "            if (!paused()) {", "                _currentRateInfo.ratePerSec = DEFAULT_INT;", "            }", "            _currentRateInfo.lastTimestamp = uint64(block.timestamp);", "            _currentRateInfo.lastBlock = uint64(block.number);", "", "            // Effects: write to storage", "            currentRateInfo = _currentRateInfo;", "        } else {", "            // We know totalBorrow.shares > 0", "            uint256 _deltaTime = block.timestamp - _currentRateInfo.lastTimestamp;", "", "            // NOTE: Violates Checks-Effects-Interactions pattern", "            // Be sure to mark external version NONREENTRANT (even though rateContract is trusted)", "            // Calc new rate", "            uint256 _utilizationRate = (UTIL_PREC * _totalBorrow.amount) / _totalAsset.amount;", "            if (_isPastMaturity()) {", "                _newRate = uint64(penaltyRate);", "            } else {", "                bytes memory _rateData = abi.encode(", "                    _currentRateInfo.ratePerSec,", "                    _deltaTime,", "                    _utilizationRate,", "                    block.number - _currentRateInfo.lastBlock", "                );", "                _newRate = IRateCalculator(rateContract).getNewRate(_rateData, rateInitCallData);", "            }", "", "            // Event must be here to use non-mutated values", "            emit UpdateRate(_currentRateInfo.ratePerSec, _deltaTime, _utilizationRate, _newRate);", "", "            // Effects: bookkeeping", "            _currentRateInfo.ratePerSec = _newRate;", "            _currentRateInfo.lastTimestamp = uint64(block.timestamp);", "            _currentRateInfo.lastBlock = uint64(block.number);", "", "            // Calculate interest accrued", "            _interestEarned = (_deltaTime * _totalBorrow.amount * _currentRateInfo.ratePerSec) / 1e18;", "", "            // Accumulate interest and fees, only if no overflow upon casting", "            if (", "                _interestEarned + _totalBorrow.amount <= type(uint128).max &&", "                _interestEarned + _totalAsset.amount <= type(uint128).max", "            ) {", "                _totalBorrow.amount += uint128(_interestEarned);", "                _totalAsset.amount += uint128(_interestEarned);", "                if (_currentRateInfo.feeToProtocolRate > 0) {", "                    _feesAmount = (_interestEarned * _currentRateInfo.feeToProtocolRate) / FEE_PRECISION;", "", "                    _feesShare = (_feesAmount * _totalAsset.shares) / (_totalAsset.amount - _feesAmount);", "", "                    // Effects: Give new shares to this contract, effectively diluting lenders an amount equal to the fees", "                    // We can safely cast because _feesShare < _feesAmount < interestEarned which is always less than uint128", "                    _totalAsset.shares += uint128(_feesShare);", "", "                    // Effects: write to storage", "                    _mint(address(this), _feesShare);", "                }", "                emit AddInterest(_interestEarned, _currentRateInfo.ratePerSec, _deltaTime, _feesAmount, _feesShare);", "            }", "", "            // Effects: write to storage", "            totalAsset = _totalAsset;", "            currentRateInfo = _currentRateInfo;", "            totalBorrow = _totalBorrow;", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function totalAssetValue(", "        ComponentCache memory components,", "        TradingRules memory rules,", "        Registry memory reg", "    ) private view returns (uint192 assetsLow, uint192 assetsHigh) {", "        // The low estimate is lower than the high estimate due to:", "        // - Using worst-case prices rather than best-case (price().low instead of price().high)", "        // - Discounting assets with unbounded worst-case price", "        // - Discounting dust amounts for collateral in the basket + non-dust assets", "", "        uint192 potentialDustLoss; // {UoA}", "", "        // Accumulate:", "        // - assetsHigh: sum(bal(e)*price(e).high for e ... )", "        // - potentialDustLoss: sum(minTradeVolume(e) for e ... )", "        // - assetsLow: sum(bal(e)*price(e).low for e ... )", "        for (uint256 i = 0; i < reg.erc20s.length; ++i) {", "            // Exclude RToken balances to avoid double counting value", "            if (reg.erc20s[i] == IERC20(address(components.rToken))) continue;", "", "            uint192 bal = reg.assets[i].bal(address(components.bm)); // {tok}", "", "            // For RSR, include the staking balance", "            if (reg.erc20s[i] == components.rsr) {", "                bal = bal.plus(reg.assets[i].bal(address(components.stRSR)));", "            }", "", "            (uint192 low, uint192 high) = reg.assets[i].price(); // {UoA/tok}", "            (uint192 lotLow, ) = reg.assets[i].lotPrice(); // {UoA/tok}", "", "            // Ignore dust amounts for assets not in the basket; their value is inaccessible", "            if (", "                components.bh.quantity(reg.erc20s[i]) == 0 &&", "                !TradeLib.isEnoughToSell(reg.assets[i], bal, lotLow, rules.minTradeVolume)", "            ) continue;", "", "            // Intentionally include value of IFFY/DISABLED collateral when low is nonzero", "            // {UoA} = {UoA} + {UoA/tok} * {tok}", "            assetsLow += low.mul(bal, FLOOR);", "            // += is same as Fix.plus", "", "            // assetsHigh += high.mul(bal, CEIL), where assetsHigh is [0, FIX_MAX]", "            // {UoA} = {UoA/tok} * {tok}", "            uint192 val = components.bm.safeMulDivCeil(high, bal, FIX_ONE);", "            if (uint256(assetsHigh) + val >= FIX_MAX) assetsHigh = FIX_MAX;", "            else assetsHigh += val;", "            // += is same as Fix.plus", "", "            // Accumulate potential losses to dust", "            potentialDustLoss = potentialDustLoss.plus(rules.minTradeVolume);", "        }", "", "        // Account for all the places dust could get stuck", "        // assetsLow' = max(assetsLow-potentialDustLoss, 0)", "        assetsLow = assetsLow.gt(potentialDustLoss) ? assetsLow.minus(potentialDustLoss) : FIX_ZERO;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function withdraw(address onBehalfOf, uint256 amount) external virtual {", "        require(onBehalfOf != address(0), \"TZA\");", "        require(amount > 0, \"ZERO_WITHDRAW\");", "        require(depositedAsset[msg.sender] >= amount, \"Withdraw amount exceeds deposited amount.\");", "        totalDepositedAsset -= amount;", "        depositedAsset[msg.sender] -= amount;", "", "        uint256 withdrawal = checkWithdrawal(msg.sender, amount);", "", "        collateralAsset.transfer(onBehalfOf, withdrawal);", "        if (borrowed[msg.sender] > 0) {", "            _checkHealth(msg.sender, getAssetPrice());", "        }", "        emit WithdrawAsset(msg.sender, address(collateralAsset), onBehalfOf, withdrawal, block.timestamp);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["\tfunction finishFailedMinipoolByMultisig(address nodeID) external {", "\t\tint256 minipoolIndex = onlyValidMultisig(nodeID);", "\t\trequireValidStateTransition(minipoolIndex, MinipoolStatus.Finished);", "\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".status\")), uint256(MinipoolStatus.Finished));", "\t\temit MinipoolStatusChanged(nodeID, MinipoolStatus.Finished);", "\t}"], "ner_tags": [1, 0, 0, 0, 0, 0]}
{"tokens": ["    function markValidatorReadyToDeposit(", "        bytes[] calldata _readyToDepositPubkey,", "        bytes[] calldata _frontRunPubkey,", "        bytes[] calldata _invalidSignaturePubkey", "    ) external override nonReentrant whenNotPaused {", "        UtilLib.onlyOperatorRole(msg.sender, staderConfig);", "        uint256 readyToDepositValidatorsLength = _readyToDepositPubkey.length;", "        uint256 frontRunValidatorsLength = _frontRunPubkey.length;", "        uint256 invalidSignatureValidatorsLength = _invalidSignaturePubkey.length;", "        if (", "            readyToDepositValidatorsLength + frontRunValidatorsLength + invalidSignatureValidatorsLength >", "            verifiedKeyBatchSize", "        ) {", "            revert TooManyVerifiedKeysReported();", "        }", "", "        for (uint256 i; i < readyToDepositValidatorsLength; ) {", "            uint256 validatorId = validatorIdByPubkey[_readyToDepositPubkey[i]];", "            onlyInitializedValidator(validatorId);", "            markKeyReadyToDeposit(validatorId);", "            emit ValidatorMarkedReadyToDeposit(_readyToDepositPubkey[i], validatorId);", "            unchecked {", "                ++i;", "            }", "        }", "", "        if (frontRunValidatorsLength > 0) {", "            IStaderInsuranceFund(staderConfig.getStaderInsuranceFund()).depositFund{", "                value: frontRunValidatorsLength * FRONT_RUN_PENALTY", "            }();", "        }", "", "        for (uint256 i; i < frontRunValidatorsLength; ) {", "            uint256 validatorId = validatorIdByPubkey[_frontRunPubkey[i]];", "            onlyInitializedValidator(validatorId);", "            handleFrontRun(validatorId);", "            emit ValidatorMarkedAsFrontRunned(_frontRunPubkey[i], validatorId);", "            unchecked {", "                ++i;", "            }", "        }", "", "        for (uint256 i; i < invalidSignatureValidatorsLength; ) {", "            uint256 validatorId = validatorIdByPubkey[_invalidSignaturePubkey[i]];", "            onlyInitializedValidator(validatorId);", "            handleInvalidSignature(validatorId);", "            emit ValidatorStatusMarkedAsInvalidSignature(_invalidSignaturePubkey[i], validatorId);", "            unchecked {", "                ++i;", "            }", "        }", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _processFullWithdrawal(", "        uint64 withdrawalAmountGwei,", "        uint40 validatorIndex,", "        uint256 beaconChainETHStrategyIndex,", "        address recipient,", "        VALIDATOR_STATUS status", "    ) internal {", "        uint256 amountToSend;", "", "        // if the validator has not previously been proven to be \"overcommitted\"", "        if (status == VALIDATOR_STATUS.ACTIVE) {", "            // if the withdrawal amount is greater than the REQUIRED_BALANCE_GWEI (i.e. the amount restaked on EigenLayer, per ETH validator)", "            if (withdrawalAmountGwei >= REQUIRED_BALANCE_GWEI) {", "                // then the excess is immediately withdrawable", "                amountToSend = uint256(withdrawalAmountGwei - REQUIRED_BALANCE_GWEI) * uint256(GWEI_TO_WEI);", "                // and the extra execution layer ETH in the contract is REQUIRED_BALANCE_GWEI, which must be withdrawn through EigenLayer's normal withdrawal process", "                restakedExecutionLayerGwei += REQUIRED_BALANCE_GWEI;", "            } else {", "                // otherwise, just use the full withdrawal amount to continue to \"back\" the podOwner's remaining shares in EigenLayer (i.e. none is instantly withdrawable)", "                restakedExecutionLayerGwei += withdrawalAmountGwei;", "                // remove and undelegate 'extra' (i.e. \"overcommitted\") shares in EigenLayer", "                eigenPodManager.recordOvercommittedBeaconChainETH(podOwner, beaconChainETHStrategyIndex, uint256(REQUIRED_BALANCE_GWEI - withdrawalAmountGwei) * GWEI_TO_WEI);", "            }", "        // if the validator *has* previously been proven to be \"overcommitted\"", "        } else if (status == VALIDATOR_STATUS.OVERCOMMITTED) {", "            // if the withdrawal amount is greater than the REQUIRED_BALANCE_GWEI (i.e. the amount restaked on EigenLayer, per ETH validator)", "            if (withdrawalAmountGwei >= REQUIRED_BALANCE_GWEI) {", "                // then the excess is immediately withdrawable", "                amountToSend = uint256(withdrawalAmountGwei - REQUIRED_BALANCE_GWEI) * uint256(GWEI_TO_WEI);", "                // and the extra execution layer ETH in the contract is REQUIRED_BALANCE_GWEI, which must be withdrawn through EigenLayer's normal withdrawal process", "                restakedExecutionLayerGwei += REQUIRED_BALANCE_GWEI;", "                /**", "                 * since in `verifyOvercommittedStake` the podOwner's beaconChainETH shares are decremented by `REQUIRED_BALANCE_WEI`, we must reverse the process here,", "                 * in order to allow the podOwner to complete their withdrawal through EigenLayer's normal withdrawal process", "                 */", "                eigenPodManager.restakeBeaconChainETH(podOwner, REQUIRED_BALANCE_WEI);", "            } else {", "                // otherwise, just use the full withdrawal amount to continue to \"back\" the podOwner's remaining shares in EigenLayer (i.e. none is instantly withdrawable)", "                restakedExecutionLayerGwei += withdrawalAmountGwei;", "                /**", "                 * since in `verifyOvercommittedStake` the podOwner's beaconChainETH shares are decremented by `REQUIRED_BALANCE_WEI`, we must reverse the process here,", "                 * in order to allow the podOwner to complete their withdrawal through EigenLayer's normal withdrawal process", "                 */", "                eigenPodManager.restakeBeaconChainETH(podOwner, uint256(withdrawalAmountGwei) * GWEI_TO_WEI);", "            }", "        // If the validator status is withdrawn, they have already processed their ETH withdrawal", "        }  else {", "            revert(\"EigenPod.verifyBeaconChainFullWithdrawal: VALIDATOR_STATUS is WITHDRAWN or invalid VALIDATOR_STATUS\");", "        }", "", "        // set the ETH validator status to withdrawn", "        validatorStatus[validatorIndex] = VALIDATOR_STATUS.WITHDRAWN;", "", "        emit FullWithdrawalRedeemed(validatorIndex, recipient, withdrawalAmountGwei);", "", "        // send ETH to the `recipient`, if applicable", "        if (amountToSend != 0) {", "            _sendETH(recipient, amountToSend);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function startDraw() external onlyOwner returns (uint256) {", "        // Only can be called on first drawing", "        if (request.currentChainlinkRequestId != 0) {", "            revert REQUEST_IN_FLIGHT();", "        }", "", "        // Emit setup draw user event", "        emit SetupDraw(msg.sender, settings);", "", "        // Request initial roll", "        _requestRoll();", "", "        // Attempt to transfer token into this address", "        try", "            IERC721EnumerableUpgradeable(settings.token).transferFrom(", "                msg.sender,", "                address(this),", "                settings.tokenId", "            )", "        {} catch {", "            revert TOKEN_NEEDS_TO_BE_APPROVED_TO_CONTRACT();", "        }", "", "        // Return the current chainlink request id", "        return request.currentChainlinkRequestId;", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function getPORFeedData()", "        internal", "        view", "        returns (", "            uint256,", "            uint256,", "            uint256", "        )", "    {", "        (, int256 totalETHBalanceInInt, , , ) = AggregatorV3Interface(staderConfig.getETHBalancePORFeedProxy())", "            .latestRoundData();", "        (, int256 totalETHXSupplyInInt, , , ) = AggregatorV3Interface(staderConfig.getETHXSupplyPORFeedProxy())", "            .latestRoundData();", "        return (uint256(totalETHBalanceInInt), uint256(totalETHXSupplyInInt), block.number);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0]}
{"tokens": ["    function updateMovingAverage() external permissioned {", "        // Revert if not initialized", "        if (!initialized) revert Price_NotInitialized();", "", "        // Cache numbe of observations to save gas.", "        uint32 numObs = numObservations;", "", "        // Get earliest observation in window", "        uint256 earliestPrice = observations[nextObsIndex];", "", "        uint256 currentPrice = getCurrentPrice();", "", "        // Calculate new moving average", "        if (currentPrice > earliestPrice) {", "            _movingAverage += (currentPrice - earliestPrice) / numObs;", "        } else {", "            _movingAverage -= (earliestPrice - currentPrice) / numObs;", "        }", "", "        // Push new observation into storage and store timestamp taken at", "        observations[nextObsIndex] = currentPrice;", "        lastObservationTime = uint48(block.timestamp);", "        nextObsIndex = (nextObsIndex + 1) % numObs;", "", "        emit NewObservation(block.timestamp, currentPrice, _movingAverage);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": ["  function mintCallback(", "    uint256 collateralTotal,", "    uint256 amount0,", "    uint256 amount1,", "    uint256,", "    bytes calldata data", "  )", "    external", "    override", "  {", "    MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));", "", "    address lendgine = LendgineAddress.computeAddress(", "      factory, decoded.token0, decoded.token1, decoded.token0Exp, decoded.token1Exp, decoded.upperBound", "    );", "    if (lendgine != msg.sender) revert ValidationError();", "", "    // swap all token0 to token1", "    uint256 collateralSwap = swap(", "      decoded.swapType,", "      SwapParams({", "        tokenIn: decoded.token0,", "        tokenOut: decoded.token1,", "        amount: SafeCast.toInt256(amount0),", "        recipient: msg.sender", "      }),", "      decoded.swapExtraData", "    );", "", "    // send token1 back", "    SafeTransferLib.safeTransfer(decoded.token1, msg.sender, amount1);", "", "    // pull the rest of tokens from the user", "    uint256 collateralIn = collateralTotal - amount1 - collateralSwap;", "    if (collateralIn > decoded.collateralMax) revert AmountError();", "", "    pay(decoded.token1, decoded.payer, msg.sender, collateralIn);", "  }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function buy(uint256[] calldata tokenIds, uint256[] calldata tokenWeights, MerkleMultiProof calldata proof)", "        public", "        payable", "        returns (uint256 netInputAmount, uint256 feeAmount, uint256 protocolFeeAmount)", "    {", "        // ~~~ Checks ~~~ //", "", "        // calculate the sum of weights of the NFTs to buy", "        uint256 weightSum = sumWeightsAndValidateProof(tokenIds, tokenWeights, proof);", "", "        // calculate the required net input amount and fee amount", "        (netInputAmount, feeAmount, protocolFeeAmount) = buyQuote(weightSum);", "", "        // check that the caller sent 0 ETH if the base token is not ETH", "        if (baseToken != address(0) && msg.value > 0) revert InvalidEthAmount();", "", "        // ~~~ Effects ~~~ //", "", "        // update the virtual reserves", "        virtualBaseTokenReserves += uint128(netInputAmount - feeAmount - protocolFeeAmount);", "        virtualNftReserves -= uint128(weightSum);", "", "        // ~~~ Interactions ~~~ //", "", "        // calculate the sale price (assume it's the same for each NFT even if weights differ)", "        uint256 salePrice = (netInputAmount - feeAmount - protocolFeeAmount) / tokenIds.length;", "        uint256 royaltyFeeAmount = 0;", "        for (uint256 i = 0; i < tokenIds.length; i++) {", "            // transfer the NFT to the caller", "            ERC721(nft).safeTransferFrom(address(this), msg.sender, tokenIds[i]);", "", "            if (payRoyalties) {", "                // get the royalty fee for the NFT", "                (uint256 royaltyFee,) = _getRoyalty(tokenIds[i], salePrice);", "", "                // add the royalty fee to the total royalty fee amount", "                royaltyFeeAmount += royaltyFee;", "            }", "        }", "", "        // add the royalty fee amount to the net input aount", "        netInputAmount += royaltyFeeAmount;", "", "        if (baseToken != address(0)) {", "            // transfer the base token from the caller to the contract", "            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), netInputAmount);", "", "            // if the protocol fee is set then pay the protocol fee", "            if (protocolFeeAmount > 0) ERC20(baseToken).safeTransfer(address(factory), protocolFeeAmount);", "        } else {", "            // check that the caller sent enough ETH to cover the net required input", "            if (msg.value < netInputAmount) revert InvalidEthAmount();", "", "            // if the protocol fee is set then pay the protocol fee", "            if (protocolFeeAmount > 0) factory.safeTransferETH(protocolFeeAmount);", "", "            // refund any excess ETH to the caller", "            if (msg.value > netInputAmount) msg.sender.safeTransferETH(msg.value - netInputAmount);", "        }", "", "        if (payRoyalties) {", "            for (uint256 i = 0; i < tokenIds.length; i++) {", "                // get the royalty fee for the NFT", "                (uint256 royaltyFee, address recipient) = _getRoyalty(tokenIds[i], salePrice);", "", "                // transfer the royalty fee to the recipient if it's greater than 0", "                if (royaltyFee > 0 && recipient != address(0)) {", "                    if (baseToken != address(0)) {", "                        ERC20(baseToken).safeTransfer(recipient, royaltyFee);", "                    } else {", "                        recipient.safeTransferETH(royaltyFee);", "                    }", "                }", "            }", "        }", "", "        // emit the buy event", "        emit Buy(tokenIds, tokenWeights, netInputAmount, feeAmount, protocolFeeAmount, royaltyFeeAmount);", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function withdraw(uint merkleIndex, uint tokenId, string memory uri, bytes32[] memory addressProof, bytes32[] memory metadataProof) external payable {", "        MerkleTree storage tree = merkleTrees[merkleIndex];", "        IVoterID id = IVoterID(tree.nftAddress);", "", "        // mint an identity first, this keeps the token-collision gas cost down", "        id.createIdentityFor(msg.sender, tokenId, uri);", "", "        // check that the merkle index is real", "        require(merkleIndex <= numTrees, 'merkleIndex out of range');", "", "        // verify that the metadata is real", "        require(verifyMetadata(tree.metadataMerkleRoot, tokenId, uri, metadataProof), \"The metadata proof could not be verified\");", "", "        // check eligibility of address", "        IEligibility(tree.eligibilityAddress).passThruGate(tree.eligibilityIndex, msg.sender, addressProof);", "", "        // check that the price is right", "        IPriceGate(tree.priceGateAddress).passThruGate{value: msg.value}(tree.priceIndex, msg.sender);", "", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function requestRandomSeed() external returns (bytes32) {", "        uint256 nextRevealTimestamp = gobblerRevealsData.nextRevealTimestamp;", "", "        // A new random seed cannot be requested before the next reveal timestamp.", "        if (block.timestamp < nextRevealTimestamp) revert RequestTooEarly();", "", "        // A random seed can only be requested when all gobblers from the previous seed have been revealed.", "        // This prevents a user from requesting additional randomness in hopes of a more favorable outcome.", "        if (gobblerRevealsData.toBeRevealed != 0) revert RevealsPending();", "", "        unchecked {", "            // Prevent revealing while we wait for the seed.", "            gobblerRevealsData.waitingForSeed = true;", "", "            // Compute the number of gobblers to be revealed with the seed.", "            uint256 toBeRevealed = currentNonLegendaryId - gobblerRevealsData.lastRevealedId;", "", "            // Ensure that there are more than 0 gobblers to be revealed,", "            // otherwise the contract could waste LINK revealing nothing.", "            if (toBeRevealed == 0) revert ZeroToBeRevealed();", "", "            // Lock in the number of gobblers to be revealed from seed.", "            gobblerRevealsData.toBeRevealed = uint56(toBeRevealed);", "", "            // We enable reveals for a set of gobblers every 24 hours.", "            // Timestamp overflow is impossible on human timescales.", "            gobblerRevealsData.nextRevealTimestamp = uint64(nextRevealTimestamp + 1 days);", "", "            emit RandomnessRequested(msg.sender, toBeRevealed);", "        }", "", "        // Call out to the randomness provider.", "        return randProvider.requestRandomBytes();", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function preRedeemHook(", "        address vToken,", "        address redeemer,", "        uint256 redeemTokens", "    ) external override {", "        _checkActionPauseState(vToken, Action.REDEEM);", "        oracle.updatePrice(vToken);", "        _checkRedeemAllowed(vToken, redeemer, redeemTokens);", "", "        // Keep the flywheel moving", "        uint256 rewardDistributorsCount = rewardsDistributors.length;", "", "        for (uint256 i; i < rewardDistributorsCount; ++i) {", "            rewardsDistributors[i].updateRewardTokenSupplyIndex(vToken);", "            rewardsDistributors[i].distributeSupplierRewardToken(vToken, redeemer);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function setCreationCode(bytes calldata _creationCode) external onlyOwner {", "        bytes memory _firstHalf = BytesLib.slice(_creationCode, 0, 13000);", "        contractAddress1 = SSTORE2.write(_firstHalf);", "        if (_creationCode.length > 13000) {", "            bytes memory _secondHalf = BytesLib.slice(_creationCode, 13000, _creationCode.length - 13000);", "            contractAddress2 = SSTORE2.write(_secondHalf);", "        }", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function enforceReserveRatio(", "        address underlyingAsset,", "        address underlyingQuote", "    )", "        internal", "        view", "        returns (address bathAssetAddress, address bathQuoteAddress)", "    {", "        bathAssetAddress = IBathHouse(bathHouse).tokenToBathToken(", "            underlyingAsset", "        );", "        bathQuoteAddress = IBathHouse(bathHouse).tokenToBathToken(", "            underlyingQuote", "        );", "        require(", "            (", "                IBathToken(bathAssetAddress).underlyingBalance().mul(", "                    IBathHouse(bathHouse).reserveRatio()", "                )", "            ).div(100) <= IERC20(underlyingAsset).balanceOf(bathAssetAddress),", "            \"Failed to meet asset pool reserve ratio\"", "        );", "        require(", "            (", "                IBathToken(bathQuoteAddress).underlyingBalance().mul(", "                    IBathHouse(bathHouse).reserveRatio()", "                )", "            ).div(100) <= IERC20(underlyingQuote).balanceOf(bathQuoteAddress),", "            \"Failed to meet quote pool reserve ratio\"", "        );", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function executeAction(ActionInfo calldata actionInfo) external payable {", "    // Initial checks that action is ready to execute.", "    Action storage action = actions[actionInfo.id];", "    ActionState currentState = getActionState(actionInfo);", "", "    if (currentState != ActionState.Queued) revert InvalidActionState(currentState);", "    if (block.timestamp < action.minExecutionTime) revert MinExecutionTimeNotReached();", "    if (msg.value != actionInfo.value) revert IncorrectMsgValue();", "", "    action.executed = true;", "", "    // Check pre-execution action guard.", "    ILlamaActionGuard guard = actionGuard[actionInfo.target][bytes4(actionInfo.data)];", "    if (guard != ILlamaActionGuard(address(0))) guard.validatePreActionExecution(actionInfo);", "", "    // Execute action.", "    (bool success, bytes memory result) =", "      executor.execute(actionInfo.target, actionInfo.value, action.isScript, actionInfo.data);", "", "    if (!success) revert FailedActionExecution(result);", "", "    // Check post-execution action guard.", "    if (guard != ILlamaActionGuard(address(0))) guard.validatePostActionExecution(actionInfo);", "", "    // Action successfully executed.", "    emit ActionExecuted(actionInfo.id, msg.sender, actionInfo.strategy, actionInfo.creator, result);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function distributeBonusTokenRewards(", "        address receiver,", "        uint256 sharesWithdrawn,", "        uint256 initialTotalSupply", "    ) internal {", "        if (bonusTokens.length > 0) {", "            for (uint256 index = 0; index < bonusTokens.length; index++) {", "                IERC20 token = IERC20(bonusTokens[index]);", "                // Note: Shares already burned in Bath Token _withdraw", "", "                // Pair each bonus token with a lightly adapted OZ Vesting wallet. Each time a user withdraws, they", "                //  are released their relative share of this pool, of vested BathBuddy rewards", "                // The BathBuddy pool should accrue ERC-20 rewards just like OZ VestingWallet and simply just release the withdrawer's relative share of releaseable() tokens", "                if (rewardsVestingWallet != IBathBuddy(0)) {", "                    rewardsVestingWallet.release(", "                        (token),", "                        receiver,", "                        sharesWithdrawn,", "                        initialTotalSupply,", "                        feeBPS", "                    );", "                }", "            }", "        }", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function depositAndClose()", "        external", "        payable", "        override", "        whileBorrowing", "        onlyBorrower", "        returns (bool)", "    {", "        bytes32 id = ids[0];", "        Credit memory credit = _accrue(credits[id], id);", "", "        // Borrower deposits the outstanding balance not already repaid", "        uint256 totalOwed = credit.principal + credit.interestAccrued;", "        LineLib.receiveTokenOrETH(credit.token, msg.sender, totalOwed);", "", "        // Borrower clears the debt then closes and deletes the credit line", "        _close(_repay(credit, id, totalOwed), id);", "", "        return true;", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function startBridgeTokensViaAnyswap(LiFiData memory _lifiData, AnyswapData calldata _anyswapData) public payable {", "        address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();", "        if (_anyswapData.token != address(0) && underlyingToken != IAnyswapRouter(_anyswapData.router).wNATIVE()) {", "            if (underlyingToken == address(0)) {", "                underlyingToken = _anyswapData.token;", "            }", "", "            uint256 _fromTokenBalance = LibAsset.getOwnBalance(underlyingToken);", "            LibAsset.transferFromERC20(underlyingToken, msg.sender, address(this), _anyswapData.amount);", "", "            require(", "                LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance == _anyswapData.amount,", "                \"ERR_INVALID_AMOUNT\"", "            );", "        } else {", "            require(msg.value == _anyswapData.amount, \"ERR_INVALID_AMOUNT\");", "        }", "", "        _startBridge(_anyswapData);", "", "        emit LiFiTransferStarted(", "            _lifiData.transactionId,", "            _lifiData.integrator,", "            _lifiData.referrer,", "            _lifiData.sendingAssetId,", "            _lifiData.receivingAssetId,", "            _lifiData.receiver,", "            _lifiData.amount,", "            _lifiData.destinationChainId,", "            block.timestamp", "        );", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function deploy(bytes memory _configData) external returns (address _pairAddress) {", "        (address _asset, address _collateral, , , , address _rateContract, ) = abi.decode(", "            _configData,", "            (address, address, address, address, uint256, address, bytes)", "        );", "        string memory _name = string(", "            abi.encodePacked(", "                \"FraxlendV1 - \",", "                IERC20(_collateral).safeName(),", "                \"/\",", "                IERC20(_asset).safeName(),", "                \" - \",", "                IRateCalculator(_rateContract).name(),", "                \" - \",", "                (deployedPairsArray.length + 1).toString()", "            )", "        );", "", "        _pairAddress = _deployFirst(", "            keccak256(abi.encodePacked(\"public\")),", "            _configData,", "            abi.encode(CIRCUIT_BREAKER_ADDRESS, COMPTROLLER_ADDRESS, TIME_LOCK_ADDRESS, FRAXLEND_WHITELIST_ADDRESS),", "            DEFAULT_MAX_LTV,", "            DEFAULT_LIQ_FEE,", "            0,", "            0,", "            false,", "            false", "        );", "", "        _deploySecond(_name, _pairAddress, _configData, new address[](0), new address[](0));", "", "        _logDeploy(_name, _pairAddress, _configData, DEFAULT_MAX_LTV, DEFAULT_LIQ_FEE, 0);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function proposalThreshold() public view returns (uint256) {", "        unchecked {", "            return (settings.token.totalSupply() * settings.proposalThresholdBps) / 10_000;", "        }", "    }"], "ner_tags": [1, 1, 1, 1, 1]}
{"tokens": ["    function createPledge(", "        address receiver,", "        address rewardToken,", "        uint256 targetVotes,", "        uint256 rewardPerVote, // reward/veToken/second", "        uint256 endTimestamp,", "        uint256 maxTotalRewardAmount,", "        uint256 maxFeeAmount", "    ) external whenNotPaused nonReentrant returns(uint256){", "        address creator = msg.sender;", "", "        if(receiver == address(0) || rewardToken == address(0)) revert Errors.ZeroAddress();", "        if(targetVotes < minTargetVotes) revert Errors.TargetVoteUnderMin();", "        if(minAmountRewardToken[rewardToken] == 0) revert Errors.TokenNotWhitelisted();", "        if(rewardPerVote < minAmountRewardToken[rewardToken]) revert Errors.RewardPerVoteTooLow();", "", "        if(endTimestamp == 0) revert Errors.NullEndTimestamp();", "        if(endTimestamp != _getRoundedTimestamp(endTimestamp)) revert Errors.InvalidEndTimestamp();", "", "        CreatePledgeVars memory vars;", "        vars.duration = endTimestamp - block.timestamp;", "        if(vars.duration < minDelegationTime) revert Errors.DurationTooShort();", "", "        // Get the missing votes for the given receiver to reach the target votes", "        // We ignore any delegated boost here because they might expire during the Pledge duration", "        // (we can have a future version of this contract using adjusted_balance)", "        vars.votesDifference = targetVotes - votingEscrow.balanceOf(receiver);", "", "        vars.totalRewardAmount = (rewardPerVote * vars.votesDifference * vars.duration) / UNIT;", "        vars.feeAmount = (vars.totalRewardAmount * protocalFeeRatio) / MAX_PCT ;", "        if(vars.totalRewardAmount > maxTotalRewardAmount) revert Errors.IncorrectMaxTotalRewardAmount();", "        if(vars.feeAmount > maxFeeAmount) revert Errors.IncorrectMaxFeeAmount();", "", "        // Pull all the rewards in this contract", "        IERC20(rewardToken).safeTransferFrom(creator, address(this), vars.totalRewardAmount);", "        // And transfer the fees from the Pledge creator to the Chest contract", "        IERC20(rewardToken).safeTransferFrom(creator, chestAddress, vars.feeAmount);", "", "        vars.newPledgeID = pledgesIndex();", "", "        // Add the total reards as available for the Pledge & write Pledge parameters in storage", "        pledgeAvailableRewardAmounts[vars.newPledgeID] += vars.totalRewardAmount;", "", "        pledges.push(Pledge(", "            targetVotes,", "            vars.votesDifference,", "            rewardPerVote,", "            receiver,", "            rewardToken,", "            safe64(endTimestamp),", "            false", "        ));", "", "        pledgeOwner[vars.newPledgeID] = creator;", "        ownerPledges[creator].push(vars.newPledgeID);", "", "        emit NewPledge(creator, receiver, rewardToken, targetVotes, rewardPerVote, endTimestamp);", "", "        return vars.newPledgeID;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _assertEtherIsReadyForValidatorStaking(bytes calldata blsPubKey) internal view {", "        address associatedSmartWallet = smartWalletOfKnot[blsPubKey];", "        require(associatedSmartWallet.balance >= 4 ether, \"Smart wallet balance must be at least 4 ether\");", "", "        LPToken stakingFundsLP = stakingFundsVault.lpTokenForKnot(blsPubKey);", "        require(address(stakingFundsLP) != address(0), \"No funds staked in staking funds vault\");", "        require(stakingFundsLP.totalSupply() == 4 ether, \"DAO staking funds vault balance must be at least 4 ether\");", "", "        LPToken savETHVaultLP = savETHVault.lpTokenForKnot(blsPubKey);", "        require(address(savETHVaultLP) != address(0), \"No funds staked in savETH vault\");", "        require(savETHVaultLP.totalSupply() == 24 ether, \"KNOT must have 24 ETH in savETH vault\");", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function repayDebt(RepayDebtParams calldata params)", "        external", "        override", "        nonReentrant(true)", "        isAuthorizedForToken(params.tokenId)", "        avoidsShortfall", "        returns (uint256 amountReturned)", "    {", "        require(!peripheryGuardianPaused, \"periphery functionality is paused\");", "        require(comptroller.markets(params.debtCToken).isListed, \"Debt CToken must be listed by comptroller\");", "        require(", "            params.underlying == CErc20Interface(params.debtCToken).underlying(),", "            \"Underlying must match CToken underlying\"", "        );", "", "        (, , address token0, address token1, , , , , , , , ) = nonfungiblePositionManager.positions(params.tokenId);", "        require(_checkSwapPath(params.swapPath0, token0, params.underlying), \"swapPath0 did not pass integrity check\");", "        require(_checkSwapPath(params.swapPath1, token1, params.underlying), \"swapPath1 did not pass integrity check\");", "", "        // remove params.liquidity from token (moves to token's fees)", "        if (params.liquidity > 0) _decreaseLiquidity(params.tokenId, params.liquidity);", "", "        uint256 amountOutTotal;", "", "        {", "            // collect all fees (includes decreased liquidity)", "            (uint256 amount0, uint256 amount1) = _collectMax(params.tokenId);", "", "            // calculate the totalAmount of debt asset we have.", "            // check if token0 or token1 are the debt asset. otherwise, swap token0 and token1 to debt asset using swapPaths", "            uint256 amountOutFrom0 = token0 == params.underlying ? amount0 : 0;", "            uint256 amountOutFrom1 = token1 == params.underlying ? amount1 : 0;", "", "            if (amountOutFrom0 == 0 && params.swapPath0.length > 0) amountOutFrom0 = _swap(params.swapPath0, amount0);", "            if (amountOutFrom1 == 0 && params.swapPath1.length > 0) amountOutFrom1 = _swap(params.swapPath1, amount1);", "", "            // total amount of debtAsset we've collected to use towards repay", "            amountOutTotal = amountOutFrom0.add(amountOutFrom1);", "        }", "", "        require(", "            amountOutTotal > params.repayAmount,", "            \"not enough liquidity burned: Repay debt must repay repayAmount of debt\"", "        );", "", "        // repay the debt for user with new funds", "        IERC20Detailed(params.underlying).approve(address(params.debtCToken), params.repayAmount);", "        uint256 succeeded = CErc20Interface(params.debtCToken).repayBorrowBehalf(msg.sender, params.repayAmount);", "        require(succeeded == 0, \"repay debt did not succeed\");", "        IERC20Detailed(params.underlying).approve(address(params.debtCToken), 0);", "", "        // return remnants to user", "        amountReturned = amountOutTotal > params.repayAmount ? amountOutTotal.sub(params.repayAmount) : 0;", "", "        if (amountReturned > 0) TransferHelper.safeTransfer(params.underlying, msg.sender, amountReturned);", "", "        emit RepayDebt(", "            msg.sender,", "            params.tokenId,", "            params.liquidity,", "            params.debtCToken,", "            params.underlying,", "            params.repayAmount,", "            amountReturned", "        );", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _mintSharesFor(", "        address recipient,", "        uint256 _amount,", "        uint256 _pool", "    ) internal {", "        uint256 shares;", "        if (totalSupply() == 0) {", "            shares = _amount;", "        } else {", "            shares = (_amount * totalSupply()) / _pool;", "        }", "        _mint(recipient, shares);", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": ["    function execute(bytes calldata input) external override {", "        (bytes memory data, bytes memory proof) = abi.decode(input, (bytes, bytes));", "", "        bytes32 messageHash = ECDSA.toEthSignedMessageHash(keccak256(data));", "", "        // TEST auth and getaway separately", "        bool currentOperators = IAxelarAuth(AUTH_MODULE).validateProof(messageHash, proof);", "", "        uint256 chainId;", "        bytes32[] memory commandIds;", "        string[] memory commands;", "        bytes[] memory params;", "", "        try AxelarGateway(this)._unpackLegacyCommands(data) returns (", "            uint256 chainId_,", "            bytes32[] memory commandIds_,", "            string[] memory commands_,", "            bytes[] memory params_", "        ) {", "            (chainId, commandIds, commands, params) = (chainId_, commandIds_, commands_, params_);", "        } catch {", "            (chainId, commandIds, commands, params) = abi.decode(data, (uint256, bytes32[], string[], bytes[]));", "        }", "", "        if (chainId != block.chainid) revert InvalidChainId();", "", "        uint256 commandsLength = commandIds.length;", "", "        if (commandsLength != commands.length || commandsLength != params.length) revert InvalidCommands();", "", "        for (uint256 i; i < commandsLength; ++i) {", "            bytes32 commandId = commandIds[i];", "", "            if (isCommandExecuted(commandId)) continue; /* Ignore if duplicate commandId received */", "", "            bytes4 commandSelector;", "            bytes32 commandHash = keccak256(abi.encodePacked(commands[i]));", "", "            if (commandHash == SELECTOR_DEPLOY_TOKEN) {", "                commandSelector = AxelarGateway.deployToken.selector;", "            } else if (commandHash == SELECTOR_MINT_TOKEN) {", "                commandSelector = AxelarGateway.mintToken.selector;", "            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL) {", "                commandSelector = AxelarGateway.approveContractCall.selector;", "            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT) {", "                commandSelector = AxelarGateway.approveContractCallWithMint.selector;", "            } else if (commandHash == SELECTOR_BURN_TOKEN) {", "                commandSelector = AxelarGateway.burnToken.selector;", "            } else if (commandHash == SELECTOR_TRANSFER_OPERATORSHIP) {", "                if (!currentOperators) continue;", "", "                commandSelector = AxelarGateway.transferOperatorship.selector;", "            } else {", "                continue; /* Ignore if unknown command received */", "            }", "", "            // Prevent a re-entrancy from executing this command before it can be marked as successful.", "            _setCommandExecuted(commandId, true);", "            (bool success, ) = address(this).call(abi.encodeWithSelector(commandSelector, params[i], commandId));", "", "            if (success) emit Executed(commandId);", "            else _setCommandExecuted(commandId, false);", "        }", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function payParams(JBPayParamsData calldata _data)", "        external", "        override", "        returns (uint256 weight, string memory memo, JBPayDelegateAllocation[] memory delegateAllocations)", "    {", "        // Find the total number of tokens to mint, as a fixed point number with 18 decimals", "        uint256 _tokenCount = PRBMath.mulDiv(_data.amount.value, _data.weight, 10 ** 18);", "", "        // Unpack the quote from the pool, given by the frontend", "        (,, uint256 _quote, uint256 _slippage) = abi.decode(_data.metadata, (bytes32, bytes32, uint256, uint256));", "", "        // If the amount swapped is bigger than the lowest received when minting, use the swap pathway", "        if (_tokenCount < _quote - (_quote * _slippage / SLIPPAGE_DENOMINATOR)) {", "            // Pass the quote and reserve rate via a mutex", "            mintedAmount = _tokenCount;", "            reservedRate = _data.reservedRate;", "", "            // Return this delegate as the one to use, and do not mint from the terminal", "            delegateAllocations = new JBPayDelegateAllocation[](1);", "            delegateAllocations[0] =", "                JBPayDelegateAllocation({delegate: IJBPayDelegate(this), amount: _data.amount.value});", "", "            return (0, _data.memo, delegateAllocations);", "        }", "", "        // If minting, do not use this as delegate", "        return (_data.weight, _data.memo, new JBPayDelegateAllocation[](0));", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function _updateBucketExchangeRateAndCalculateRewards(", "        address pool_,", "        uint256 bucketIndex_,", "        uint256 burnEpoch_,", "        uint256 totalBurned_,", "        uint256 interestEarned_", "    ) internal returns (uint256 rewards_) {", "        uint256 burnExchangeRate = bucketExchangeRates[pool_][bucketIndex_][burnEpoch_];", "", "        // update bucket exchange rate at epoch only if it wasn't previously updated", "        if (burnExchangeRate == 0) {", "            uint256 curBucketExchangeRate = IPool(pool_).bucketExchangeRate(bucketIndex_);", "", "            // record bucket exchange rate at epoch", "            bucketExchangeRates[pool_][bucketIndex_][burnEpoch_] = curBucketExchangeRate;", "", "            // retrieve the bucket exchange rate at the previous epoch", "            uint256 prevBucketExchangeRate = bucketExchangeRates[pool_][bucketIndex_][burnEpoch_ - 1];", "", "            // skip reward calculation if update at the previous epoch was missed and if exchange rate decreased due to bad debt", "            // prevents excess rewards from being provided from using a 0 value as an input to the interestFactor calculation below.", "            if (prevBucketExchangeRate != 0 && prevBucketExchangeRate < curBucketExchangeRate) {", "", "                // retrieve current deposit of the bucket", "                (, , , uint256 bucketDeposit, ) = IPool(pool_).bucketInfo(bucketIndex_);", "", "                uint256 burnFactor     = Maths.wmul(totalBurned_, bucketDeposit);", "                uint256 interestFactor = interestEarned_ == 0 ? 0 : Maths.wdiv(", "                    Maths.WAD - Maths.wdiv(prevBucketExchangeRate, curBucketExchangeRate),", "                    interestEarned_", "                );", "", "                // calculate rewards earned for updating bucket exchange rate ", "                rewards_ += Maths.wmul(UPDATE_CLAIM_REWARD, Maths.wmul(burnFactor, interestFactor));", "            }", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function transferERC20(address token, address from, address to, uint256 amount)", "        approvedContract", "        external", "        returns (bool)", "    {", "        require(revokedApproval[from] == false, \"User has revoked approval\");", "        return IERC20(token).transferFrom(from, to, amount);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function _forfeit(uint256 forfeited) internal {", "    require(forfeited <= declaredBalance, \"Cannot forfeit more than declared\");", "", "    declaredBalance = declaredBalance - forfeited;", "", "    collateralToken.safeTransfer(address(forfeitor), forfeited);", "    forfeitor.handleForfeit();", "", "    uint256 totalReward = collateralToken.balanceOf(address(this)) +", "      rewardMine.totalReleasedReward();", "", "    require(declaredBalance <= totalReward, \"Insufficient balance\");", "", "    emit Forfeit(forfeited);", "  }"], "ner_tags": [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function validateAndParse(", "    IAstariaRouter.NewLienRequest calldata params,", "    address borrower,", "    address collateralTokenContract,", "    uint256 collateralTokenId", "  )", "    external", "    view", "    override", "    returns (bytes32 leaf, ILienToken.Details memory ld)", "  {", "    IUNI_V3Validator.Details memory details = getLeafDetails(params.nlrDetails);", "", "    if (details.version != VERSION_TYPE) {", "      revert InvalidType();", "    }", "    if (details.borrower != address(0) && borrower != details.borrower) {", "      revert InvalidBorrower();", "    }", "", "    //ensure its also the correct token", "    if (details.lp != collateralTokenContract) {", "      revert InvalidCollateral();", "    }", "", "    (", "      ,", "      ,", "      address token0,", "      address token1,", "      uint24 fee,", "      int24 tickLower,", "      int24 tickUpper,", "      uint128 liquidity,", "      ,", "      ,", "      ,", "", "    ) = V3_NFT_POSITION_MGR.positions(collateralTokenId);", "", "    if (fee > details.fee) {", "      revert InvalidFee();", "    }", "", "    if (details.token0 != token0 || details.token1 != token1) {", "      revert InvalidPair();", "    }", "", "    //get pool from factory", "", "    //get pool state", "    //get slot 0", "    (uint160 poolSQ96, , , , , , ) = IUniswapV3PoolState(", "      V3_FACTORY.getPool(token0, token1, fee)", "    ).slot0();", "", "    (uint256 amount0, uint256 amount1) = LiquidityAmounts", "      .getAmountsForLiquidity(", "        poolSQ96,", "        TickMath.getSqrtRatioAtTick(tickLower),", "        TickMath.getSqrtRatioAtTick(tickUpper),", "        liquidity", "      );", "", "    if (details.amount0Min > amount0 || details.amount1Min > amount1) {", "      revert InvalidAmounts();", "    }", "    if (details.tickUpper != tickUpper || details.tickLower != tickLower) {", "      revert InvalidRange();", "    }", "", "    if (details.minLiquidity > liquidity) {", "      revert InvalidLiquidity();", "    }", "", "    leaf = keccak256(params.nlrDetails);", "    ld = details.lien;", "  }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function nftSell(uint256[] calldata tokenIds, uint256 minOutputAmount, bytes32[][] calldata proofs)", "        public", "        returns (uint256 outputAmount)", "    {", "        // wrap the incoming NFTs into fractional tokens", "        uint256 inputAmount = wrap(tokenIds, proofs);", "", "        // sell fractional tokens for base tokens", "        outputAmount = sell(inputAmount, minOutputAmount);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _getNonCaller(address _signerOne, address _signerTwo) internal view returns(address) {", "        return msg.sender == _signerOne ? _signerTwo : _signerOne;", "    }"], "ner_tags": [1, 1, 1]}
{"tokens": ["    function _validateOrderAndUpdateStatus(", "        AdvancedOrder memory advancedOrder,", "        CriteriaResolver[] memory criteriaResolvers,", "        bool revertOnInvalid,", "        bytes32[] memory priorOrderHashes", "    )", "        internal", "        returns (", "            bytes32 orderHash,", "            uint256 newNumerator,", "            uint256 newDenominator", "        )", "    {", "        // Retrieve the parameters for the order.", "        OrderParameters memory orderParameters = advancedOrder.parameters;", "", "        // Ensure current timestamp falls between order start time and end time.", "        if (", "            !_verifyTime(", "                orderParameters.startTime,", "                orderParameters.endTime,", "                revertOnInvalid", "            )", "        ) {", "            // Assuming an invalid time and no revert, return zeroed out values.", "            return (bytes32(0), 0, 0);", "        }", "", "        // Read numerator and denominator from memory and place on the stack.", "        uint256 numerator = uint256(advancedOrder.numerator);", "        uint256 denominator = uint256(advancedOrder.denominator);", "", "        // Ensure that the supplied numerator and denominator are valid.", "        if (numerator > denominator || numerator == 0) {", "            revert BadFraction();", "        }", "", "        // If attempting partial fill (n < d) check order type & ensure support.", "        if (", "            numerator < denominator &&", "            _doesNotSupportPartialFills(orderParameters.orderType)", "        ) {", "            // Revert if partial fill was attempted on an unsupported order.", "            revert PartialFillsNotEnabledForOrder();", "        }", "", "        // Retrieve current nonce and use it w/ parameters to derive order hash.", "        orderHash = _assertConsiderationLengthAndGetNoncedOrderHash(", "            orderParameters", "        );", "", "        // Ensure restricted orders have a valid submitter or pass a zone check.", "        _assertRestrictedAdvancedOrderValidity(", "            advancedOrder,", "            criteriaResolvers,", "            priorOrderHashes,", "            orderHash,", "            orderParameters.zoneHash,", "            orderParameters.orderType,", "            orderParameters.offerer,", "            orderParameters.zone", "        );", "", "        // Retrieve the order status using the derived order hash.", "        OrderStatus memory orderStatus = _orderStatus[orderHash];", "", "        // Ensure order is fillable and is not cancelled.", "        if (", "            !_verifyOrderStatus(", "                orderHash,", "                orderStatus,", "                false, // Allow partially used orders to be filled.", "                revertOnInvalid", "            )", "        ) {", "            // Assuming an invalid order status and no revert, return zero fill.", "            return (orderHash, 0, 0);", "        }", "", "        // If the order is not already validated, verify the supplied signature.", "        if (!orderStatus.isValidated) {", "            _verifySignature(", "                orderParameters.offerer,", "                orderHash,", "                advancedOrder.signature", "            );", "        }", "", "        // Read filled amount as numerator and denominator and put on the stack.", "        uint256 filledNumerator = orderStatus.numerator;", "        uint256 filledDenominator = orderStatus.denominator;", "", "        // If order currently has a non-zero denominator it is partially filled.", "        if (filledDenominator != 0) {", "            // If denominator of 1 supplied, fill all remaining amount on order.", "            if (denominator == 1) {", "                // Scale numerator & denominator to match current denominator.", "                numerator = filledDenominator;", "                denominator = filledDenominator;", "            }", "            // Otherwise, if supplied denominator differs from current one...", "            else if (filledDenominator != denominator) {", "                // scale current numerator by the supplied denominator, then...", "                filledNumerator *= denominator;", "", "                // the supplied numerator & denominator by current denominator.", "                numerator *= filledDenominator;", "                denominator *= filledDenominator;", "            }", "", "            // Once adjusted, if current+supplied numerator exceeds denominator:", "            if (filledNumerator + numerator > denominator) {", "                // Skip underflow check: denominator >= orderStatus.numerator", "                unchecked {", "                    // Reduce current numerator so it + supplied = denominator.", "                    numerator = denominator - filledNumerator;", "                }", "            }", "", "            // Skip overflow check: checked above unless numerator is reduced.", "            unchecked {", "                // Update order status and fill amount, packing struct values.", "                _orderStatus[orderHash].isValidated = true;", "                _orderStatus[orderHash].isCancelled = false;", "                _orderStatus[orderHash].numerator = uint120(", "                    filledNumerator + numerator", "                );", "                _orderStatus[orderHash].denominator = uint120(denominator);", "            }", "        } else {", "            // Update order status and fill amount, packing struct values.", "            _orderStatus[orderHash].isValidated = true;", "            _orderStatus[orderHash].isCancelled = false;", "            _orderStatus[orderHash].numerator = uint120(numerator);", "            _orderStatus[orderHash].denominator = uint120(denominator);", "        }", "", "        // Return order hash, a modified numerator, and a modified denominator.", "        return (orderHash, numerator, denominator);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function withdraw(", "        IERC4626 vault,", "        address to,", "        uint256 amount,", "        uint256 minSharesOut", "    ) public payable virtual override returns (uint256 sharesOut) {", "        if ((sharesOut = vault.withdraw(amount, to, msg.sender)) < minSharesOut) {", "            revert MinAmountError();", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function _withdrawUnderlying(uint256 _withdrawAmount) internal {", "        uint256 withdrawable = balanceOfPool();", "        _withdrawAmount = MathUpgradeable.min(_withdrawAmount, withdrawable);", "        ILendingPool(ADDRESSES_PROVIDER.getLendingPool()).withdraw(address(want), _withdrawAmount, address(this));", "    }"], "ner_tags": [0, 0, 0, 1, 0]}
{"tokens": ["    function tryAvertChallenge(uint256 _collateralAmount, uint256 _bidAmountZCHF) external onlyHub returns (bool) {", "        if (block.timestamp >= expiration){", "            return false; // position expired, let every challenge succeed", "        } else if (_bidAmountZCHF * ONE_DEC18 >= price * _collateralAmount){", "            // challenge averted, bid is high enough", "            challengedAmount -= _collateralAmount;", "            // Don't allow minter to close the position immediately so challenge can be repeated before", "            // the owner has a chance to mint more on an undercollateralized position", "            restrictMinting(1 days);", "            return true;", "        } else {", "            return false;", "        }", "    }"], "ner_tags": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function preSign(bytes calldata orderUid) external onlyOwner {", "        ICowSettlement(COW_SETTLEMENT).setPreSignature(orderUid, true);", "    }"], "ner_tags": [1, 0, 0]}
{"tokens": ["    function removeWrapping(string calldata symbol) external onlyOwner {", "        address axelarToken = gateway().tokenAddresses(symbol);", "        if (axelarToken == address(0)) revert('NotAxelarToken()');", "        address xc20Token = wrapped[axelarToken];", "        if (xc20Token == address(0)) revert('NotWrappingToken()');", "        wrapped[axelarToken] = address(0);", "        unwrapped[xc20Token] = address(0);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function register(uint256 _cidNFTID) external {", "        if (ERC721(cidNFT).ownerOf(_cidNFTID) != msg.sender)", "            // We only guarantee that a CID NFT is owned by the user at the time of registration", "            // ownerOf reverts if non-existing ID is provided", "            revert NFTNotOwnedByUser(_cidNFTID, msg.sender);", "        cidNFTs[msg.sender] = _cidNFTID;", "        emit CIDNFTAdded(msg.sender, _cidNFTID);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)", "        external", "        virtual", "        override", "        ensure(deadline)", "        returns (uint[] memory amounts)", "    {", "        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');", "        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);", "        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');", "        TransferHelper.safeTransferFrom(", "            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]", "        );", "        _swap(amounts, path, address(this));", "        IWETH(WETH).withdraw(amounts[amounts.length - 1]);", "        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["    function depositETHOverTargetWeight() external override nonReentrant {", "        if (block.number < lastExcessETHDepositBlock + excessETHDepositCoolDown) {", "            revert CooldownNotComplete();", "        }", "        IPoolUtils poolUtils = IPoolUtils(staderConfig.getPoolUtils());", "        (, uint256 availableETHForNewDeposit) = SafeMath.trySub(", "            address(this).balance,", "            IUserWithdrawalManager(staderConfig.getUserWithdrawManager()).ethRequestedForWithdraw()", "        );", "        if (availableETHForNewDeposit == 0) {", "            revert InsufficientBalance();", "        }", "        (uint256[] memory selectedPoolCapacity, uint8[] memory poolIdArray) = IPoolSelector(", "            staderConfig.getPoolSelector()", "        ).poolAllocationForExcessETHDeposit(availableETHForNewDeposit);", "", "        uint256 poolCount = poolIdArray.length;", "        for (uint256 i = 0; i < poolCount; i++) {", "            uint256 validatorToDeposit = selectedPoolCapacity[i];", "            if (validatorToDeposit == 0) {", "                continue;", "            }", "            address poolAddress = IPoolUtils(poolUtils).poolAddressById(poolIdArray[i]);", "            uint256 poolDepositSize = staderConfig.getStakedEthPerNode() -", "                IPoolUtils(poolUtils).getCollateralETH(poolIdArray[i]);", "", "            lastExcessETHDepositBlock = block.number;", "            //slither-disable-next-line arbitrary-send-eth", "            IStaderPoolBase(poolAddress).stakeUserETHToBeaconChain{value: validatorToDeposit * poolDepositSize}();", "            emit ETHTransferredToPool(i, poolAddress, validatorToDeposit * poolDepositSize);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function getWithdrawalLimit(address user) public view returns (uint) {", "        IEscrow escrow = predictEscrow(user);", "        uint collateralBalance = escrow.balance();", "        if(collateralBalance == 0) return 0;", "        uint debt = debts[user];", "        if(debt == 0) return collateralBalance;", "        if(collateralFactorBps == 0) return 0;", "        uint minimumCollateral = debt * 1 ether / oracle.viewPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;", "        if(collateralBalance <= minimumCollateral) return 0;", "        return collateralBalance - minimumCollateral;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["    function buyAllAmountForETH(", "        uint256 buy_amt,", "        ERC20 pay_gem,", "        uint256 max_fill_amount", "    ) external returns (uint256 fill) {", "        ERC20(pay_gem).transferFrom(msg.sender, address(this), max_fill_amount); //transfer pay here", "        fill = RubiconMarket(RubiconMarketAddress).buyAllAmount(", "            ERC20(wethAddress),", "            buy_amt,", "            pay_gem,", "            max_fill_amount", "        );", "        WETH9(wethAddress).withdraw(buy_amt); // Fill in WETH", "        msg.sender.transfer(buy_amt); // Return native ETH", "        // Return unspent coins to sender", "        if (max_fill_amount > fill) {", "            ERC20(pay_gem).transfer(msg.sender, max_fill_amount - fill);", "        }", "        return fill;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function isResolverCached() external view returns (bool) {", "        bytes32[] memory requiredOperators = resolverOperatorsRequired();", "        bytes32 name;", "        IOperatorResolver.Operator memory cacheTmp;", "        IOperatorResolver.Operator memory actualValue;", "        for (uint256 i = 0; i < requiredOperators.length; i++) {", "            name = requiredOperators[i];", "            cacheTmp = operatorCache[name];", "            actualValue = resolver.getOperator(name);", "            // false if our cache is invalid or if the resolver doesn't have the required address", "            if (", "                actualValue.implementation != cacheTmp.implementation ||", "                actualValue.selector != cacheTmp.selector ||", "                cacheTmp.implementation == address(0)", "            ) {", "                return false;", "            }", "        }", "        return true;", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function setWrapper(address _wrapper) external onlyOwner {", "    address old = address(s.wrapper);", "    if (old == _wrapper || !Address.isContract(_wrapper)) revert AssetFacet__setWrapper_invalidWrapper();", "", "    s.wrapper = IWrapped(_wrapper);", "    emit WrapperUpdated(old, _wrapper, msg.sender);", "  }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _executeFractionalize(", "        IProposalExecutionEngine.ExecuteProposalParams memory params", "    )", "        internal", "        returns (bytes memory nextProgressData)", "    {", "        // Decode the proposal data.", "        FractionalizeProposalData memory data =", "            abi.decode(params.proposalData, (FractionalizeProposalData));", "        // The supply of fractional vault ERC20 tokens will be equal to the total", "        // voting power of the party.", "        uint256 supply =", "            PartyGovernance(address(this)).getGovernanceValues().totalVotingPower;", "        // Create a vault around the NFT.", "        data.token.approve(address(VAULT_FACTORY), data.tokenId);", "        uint256 vaultId = VAULT_FACTORY.mint(", "            IERC721(address(this)).name(),", "            IERC721(address(this)).symbol(),", "            data.token,", "            data.tokenId,", "            supply,", "            data.listPrice,", "            0", "        );", "        // Get the vault we just created.", "        IFractionalV1Vault vault = VAULT_FACTORY.vaults(vaultId);", "        // Check that we now hold the correct amount of fractional tokens.", "        // Should always succeed.", "        assert(vault.balanceOf(address(this)) == supply);", "        // Remove ourselves as curator.", "        vault.updateCurator(address(0));", "        emit FractionalV1VaultCreated(", "            data.token,", "            data.tokenId,", "            vaultId,", "            vault,", "            data.listPrice", "        );", "        // Nothing left to do.", "        return \"\";", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function setLockedProfitDegradation(uint256 degradation) external {", "        _atLeastRole(ADMIN);", "        require(degradation <= DEGRADATION_COEFFICIENT, \"Degradation cannot be more than 100%\");", "        lockedProfitDegradation = degradation;", "        emit LockedProfitDegradationUpdated(degradation);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0]}
{"tokens": ["    function execute(bytes memory operatorData, bytes memory executionData) external payable {", "        // Decode the operator data.", "        CollectionBatchBuyOperationData memory op = abi.decode(", "            operatorData,", "            (CollectionBatchBuyOperationData)", "        );", "", "        // Decode the execution data.", "        CollectionBatchBuyExecutionData memory ex = abi.decode(", "            executionData,", "            (CollectionBatchBuyExecutionData)", "        );", "", "        if (op.minTokensBought == 0) {", "            // Must buy at least one token.", "            revert InvalidMinTokensBoughtError(0);", "        }", "", "        if (ex.numOfTokens < op.minTokensBought) {", "            // The number of tokens to buy must be greater than or equal to the", "            // minimum number of tokens to buy.", "            revert NumOfTokensCannotBeLessThanMin(ex.numOfTokens, op.minTokensBought);", "        }", "", "        // Lengths of arrays are updated at the end.", "        uint256[] memory tokenIds = new uint256[](ex.numOfTokens);", "", "        uint96 totalEthUsed;", "        uint256 tokensBought;", "        for (uint256 i; i < ex.calls.length; ++i) {", "            BuyCall memory call = ex.calls[i];", "", "            uint96 callValue;", "            for (uint256 j; j < call.tokensToBuy.length; ++j) {", "                TokenToBuy memory tokenToBuy = call.tokensToBuy[j];", "", "                if (op.nftTokenIdsMerkleRoot != bytes32(0)) {", "                    // Verify the token ID is in the merkle tree.", "                    _verifyTokenId(tokenToBuy.tokenId, op.nftTokenIdsMerkleRoot, tokenToBuy.proof);", "                }", "", "                // Check that the call value is under the maximum price.", "                uint96 price = tokenToBuy.price;", "                if (price > op.maximumPrice) {", "                    revert MaximumPriceError(price, op.maximumPrice);", "                }", "", "                // Add the price to the total value used for the call.", "                callValue += price;", "            }", "", "            uint256 balanceBefore = address(this).balance;", "            {", "                // Execute the call to buy the NFT.", "                (bool success, ) = _buy(call.target, callValue, call.data);", "", "                if (!success) continue;", "            }", "", "            {", "                uint96 ethUsed;", "                for (uint256 j; j < call.tokensToBuy.length; ++j) {", "                    uint256 tokenId = call.tokensToBuy[j].tokenId;", "                    uint96 price = call.tokensToBuy[j].price;", "", "                    // Check whether the NFT was successfully bought.", "                    if (op.nftContract.safeOwnerOf(tokenId) == address(this)) {", "                        ethUsed += price;", "                        ++tokensBought;", "", "                        // Add the token to the list of tokens to finalize.", "                        tokenIds[tokensBought - 1] = tokenId;", "                    }", "                }", "", "                // Check ETH spent for call is what was expected.", "                uint256 actualEthUsed = balanceBefore - address(this).balance;", "                if (ethUsed != actualEthUsed) {", "                    revert EthUsedForFailedBuyError(ethUsed, actualEthUsed);", "                }", "", "                totalEthUsed += ethUsed;", "            }", "        }", "", "        // This is to prevent this crowdfund from finalizing a loss if nothing", "        // was attempted to be bought (ie. `tokenIds` is empty) or all NFTs were", "        // bought for free.", "        if (totalEthUsed == 0) revert NothingBoughtError();", "", "        // Check number of tokens bought is not less than the minimum.", "        if (tokensBought < op.minTokensBought) {", "            revert NotEnoughTokensBoughtError(tokensBought, op.minTokensBought);", "        }", "", "        // Check total ETH used is not less than the minimum.", "        if (totalEthUsed < op.minTotalEthUsed) {", "            revert NotEnoughEthUsedError(totalEthUsed, op.minTotalEthUsed);", "        }", "", "        assembly {", "            // Update length of `tokenIds`", "            mstore(mload(ex), tokensBought)", "        }", "", "        // Transfer the NFTs to the party.", "        for (uint256 i; i < tokenIds.length; ++i) {", "            op.nftContract.safeTransferFrom(address(this), msg.sender, tokenIds[i]);", "        }", "", "        // Transfer unused ETH to the party.", "        uint256 unusedEth = msg.value - totalEthUsed;", "        if (unusedEth > 0) payable(msg.sender).transferEth(unusedEth);", "", "        emit CollectionBatchBuyOperationExecuted(", "            Party(payable(msg.sender)),", "            op.nftContract,", "            tokenIds,", "            totalEthUsed", "        );", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function authRedeemZcToken(uint8 p, address u, address c, address t, uint256 a) external authorized(marketPlace) returns(bool) {", "    // redeem underlying from compounding", "    if (!withdraw(p, u, c, a)) { revert Exception(7, 0, 0, address(0), address(0)); }", "    // transfer underlying back to msg.sender", "    Safe.transfer(IErc20(u), t, a);", "", "    return (true);", "  }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _exchangeRateStored() internal view virtual returns (uint256) {", "        uint256 _totalSupply = totalSupply;", "        if (_totalSupply == 0) {", "            /*", "             * If there are no tokens minted:", "             *  exchangeRate = initialExchangeRate", "             */", "            return initialExchangeRateMantissa;", "        } else {", "            /*", "             * Otherwise:", "             *  exchangeRate = (totalCash + totalBorrows + badDebt - totalReserves) / totalSupply", "             */", "            uint256 totalCash = _getCashPrior();", "            uint256 cashPlusBorrowsMinusReserves = totalCash + totalBorrows + badDebt - totalReserves;", "            uint256 exchangeRate = (cashPlusBorrowsMinusReserves * expScale) / _totalSupply;", "", "            return exchangeRate;", "        }", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["\tfunction submitBatch (", "\t\t// The validators that approve the batch", "\t\tValsetArgs memory _currentValset,", "\t\t// These are arrays of the parts of the validators signatures", "\t\tuint8[] memory _v,", "\t\tbytes32[] memory _r,", "\t\tbytes32[] memory _s,", "\t\t// The batch of transactions", "\t\tuint256[] memory _amounts,", "\t\taddress[] memory _destinations,", "\t\tuint256[] memory _fees,", "\t\tuint256 _batchNonce,", "\t\taddress _tokenContract,", "\t\t// a block height beyond which this batch is not valid", "\t\t// used to provide a fee-free timeout", "\t\tuint256 _batchTimeout", "\t) public nonReentrant {", "\t\t// CHECKS scoped to reduce stack depth", "\t\t{", "\t\t\t// Check that the batch nonce is higher than the last nonce for this token", "\t\t\trequire(", "\t\t\t\tstate_lastBatchNonces[_tokenContract] < _batchNonce,", "\t\t\t\t\"New batch nonce must be greater than the current nonce\"", "\t\t\t);", "", "\t\t\t// Check that the block height is less than the timeout height", "\t\t\trequire(", "\t\t\t\tblock.number < _batchTimeout,", "\t\t\t\t\"Batch timeout must be greater than the current block height\"", "\t\t\t);", "", "\t\t\t// Check that current validators, powers, and signatures (v,r,s) set is well-formed", "\t\t\trequire(", "\t\t\t\t_currentValset.validators.length == _currentValset.powers.length &&", "\t\t\t\t\t_currentValset.validators.length == _v.length &&", "\t\t\t\t\t_currentValset.validators.length == _r.length &&", "\t\t\t\t\t_currentValset.validators.length == _s.length,", "\t\t\t\t\"Malformed current validator set\"", "\t\t\t);", "", "\t\t\t// Check that the supplied current validator set matches the saved checkpoint", "\t\t\trequire(", "\t\t\t\tmakeCheckpoint(_currentValset, state_gravityId) == state_lastValsetCheckpoint,", "\t\t\t\t\"Supplied current validators and powers do not match checkpoint.\"", "\t\t\t);", "", "\t\t\t// Check that the transaction batch is well-formed", "\t\t\trequire(", "\t\t\t\t_amounts.length == _destinations.length && _amounts.length == _fees.length,", "\t\t\t\t\"Malformed batch of transactions\"", "\t\t\t);", "", "\t\t\trequire(", "\t\t\t\tisOrchestrator(_currentValset, msg.sender),", "\t\t\t\t\"The sender of the transaction is not validated orchestrator\"", "\t\t\t);", "", "\t\t\t// Check that enough current validators have signed off on the transaction batch and valset", "\t\t\tcheckValidatorSignatures(", "\t\t\t\t_currentValset.validators,", "\t\t\t\t_currentValset.powers,", "\t\t\t\t_v,", "\t\t\t\t_r,", "\t\t\t\t_s,", "\t\t\t\t// Get hash of the transaction batch and checkpoint", "\t\t\t\tkeccak256(", "\t\t\t\t\tabi.encode(", "\t\t\t\t\t\tstate_gravityId,", "\t\t\t\t\t\t// bytes32 encoding of \"transactionBatch\"", "\t\t\t\t\t\t0x7472616e73616374696f6e426174636800000000000000000000000000000000,", "\t\t\t\t\t\t_amounts,", "\t\t\t\t\t\t_destinations,", "\t\t\t\t\t\t_fees,", "\t\t\t\t\t\t_batchNonce,", "\t\t\t\t\t\t_tokenContract,", "\t\t\t\t\t\t_batchTimeout", "\t\t\t\t\t)", "\t\t\t\t),", "\t\t\t\tstate_powerThreshold", "\t\t\t);", "", "\t\t\t// ACTIONS", "", "\t\t\t// Store batch nonce", "\t\t\tstate_lastBatchNonces[_tokenContract] = _batchNonce;", "", "\t\t\t{", "\t\t\t\t// Send transaction amounts to destinations", "\t\t\t\tuint256 totalFee;", "\t\t\t\tfor (uint256 i = 0; i < _amounts.length; i++) {", "\t\t\t\t\tIERC20(_tokenContract).safeTransfer(_destinations[i], _amounts[i]);", "\t\t\t\t\ttotalFee = totalFee.add(_fees[i]);", "\t\t\t\t}", "", "\t\t\t\t// Send transaction fees to msg.sender", "\t\t\t\tIERC20(_tokenContract).safeTransfer(msg.sender, totalFee);", "\t\t\t}", "\t\t}", "", "\t\t// LOGS scoped to reduce stack depth", "\t\t{", "\t\t\tstate_lastEventNonce = state_lastEventNonce.add(1);", "\t\t\temit TransactionBatchExecutedEvent(_batchNonce, _tokenContract, state_lastEventNonce);", "\t\t}", "\t}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function setRoyaltyVault(address _royaltyVault)", "        external", "        onlyVaultUninitialized", "    {", "        require(", "            msg.sender == splitFactory || msg.sender == owner(),", "            \"CoreCollection: Only Split Factory or owner can initialize vault.\"", "        );", "        royaltyVault = _royaltyVault;", "        emit RoyaltyVaultInitialized(_royaltyVault);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function deposit(address user, uint amount) public {", "        IEscrow escrow = getEscrow(user);", "        collateral.transferFrom(msg.sender, address(escrow), amount);", "        if(callOnDepositCallback) {", "            escrow.onDeposit();", "        }", "        emit Deposit(user, amount);", "    }"], "ner_tags": [0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function withdraw(", "        uint256 id,", "        uint256 assets,", "        address receiver,", "        address owner", "    ) external virtual returns (uint256 shares) {", "        require(", "            msg.sender == owner || isApprovedForAll(owner, receiver),", "            \"Only owner can withdraw, or owner has approved receiver for all\"", "        );", "", "        shares = previewWithdraw(id, assets); // No need to check for rounding error, previewWithdraw rounds up.", "", "        beforeWithdraw(id, assets, shares);", "        _burn(owner, id, shares);", "", "        emit Withdraw(msg.sender, receiver, owner, id, assets, shares);", "        asset.safeTransfer(receiver, assets);", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function rotateLPTokens(LPToken _oldLPToken, LPToken _newLPToken, uint256 _amount) public {", "        require(address(_oldLPToken) != address(0), \"Zero address\");", "        require(address(_newLPToken) != address(0), \"Zero address\");", "        require(_oldLPToken != _newLPToken, \"Incorrect rotation to same token\");", "        require(_amount >= MIN_STAKING_AMOUNT, \"Amount cannot be zero\");", "        require(_amount <= _oldLPToken.balanceOf(msg.sender), \"Not enough balance\");", "        require(_oldLPToken.lastInteractedTimestamp(msg.sender) + 30 minutes < block.timestamp, \"Liquidity is still fresh\");", "        require(_amount + _newLPToken.totalSupply() <= 24 ether, \"Not enough mintable tokens\");", "", "        bytes memory blsPublicKeyOfPreviousKnot = KnotAssociatedWithLPToken[_oldLPToken];", "        bytes memory blsPublicKeyOfNewKnot = KnotAssociatedWithLPToken[_newLPToken];", "", "        require(blsPublicKeyOfPreviousKnot.length == 48, \"Incorrect BLS public key\");", "        require(blsPublicKeyOfNewKnot.length == 48, \"Incorrect BLS public key\");", "", "        require(", "            getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfPreviousKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,", "            \"Lifecycle status must be one\"", "        );", "", "        require(", "            getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfNewKnot) ==IDataStructures.LifecycleStatus.INITIALS_REGISTERED,", "            \"Lifecycle status must be one\"", "        );", "", "        // burn old tokens and mint new ones", "        _oldLPToken.burn(msg.sender, _amount);", "        emit LPTokenBurnt(blsPublicKeyOfPreviousKnot, address(_oldLPToken), msg.sender, _amount);", "", "        _newLPToken.mint(msg.sender, _amount);", "        emit LPTokenMinted(KnotAssociatedWithLPToken[_newLPToken], address(_newLPToken), msg.sender, _amount);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function claimWinningTickets(uint256[] calldata ticketIds) external override returns (uint256 claimedAmount) {", "        uint256 totalTickets = ticketIds.length;", "        for (uint256 i = 0; i < totalTickets; ++i) {", "            claimedAmount += claimWinningTicket(ticketIds[i]);", "        }", "        rewardToken.safeTransfer(msg.sender, claimedAmount);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function refresh() public {", "        // It's a waste of gas to require notPausedOrFrozen because assets can be updated directly", "        uint256 length = _erc20s.length();", "        for (uint256 i = 0; i < length; ++i) {", "            assets[IERC20(_erc20s.at(i))].refresh();", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["    function executeBatch(address[] calldata dest, bytes[] calldata func) external onlyOwner{", "        _requireFromEntryPointOrOwner();", "        require(dest.length == func.length, \"wrong array lengths\");", "        for (uint i = 0; i < dest.length;) {", "            _call(dest[i], 0, func[i]);", "            unchecked {", "                ++i;", "            }", "        }", "    }"], "ner_tags": [1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function earmarkFees() external returns (bool) {", "        //claim fee rewards", "        IStaker(staker).claimFees(feeDistro, feeToken);", "        //send fee rewards to reward contract", "        uint256 _balance = IERC20(feeToken).balanceOf(address(this));", "", "        uint256 _lockFeesIncentive = _balance.mul(lockFeesIncentive).div(FEE_DENOMINATOR);", "        uint256 _stakerLockFeesIncentive = _balance.mul(stakerLockFeesIncentive).div(", "            FEE_DENOMINATOR", "        );", "        if (_lockFeesIncentive > 0) {", "            IERC20(feeToken).safeTransfer(lockFees, _lockFeesIncentive);", "            IRewards(lockFees).queueNewRewards(_lockFeesIncentive);", "        }", "        if (_stakerLockFeesIncentive > 0) {", "            IERC20(feeToken).safeTransfer(stakerLockRewards, _stakerLockFeesIncentive);", "            IRewards(stakerLockRewards).queueNewRewards(feeToken, _stakerLockFeesIncentive);", "        }", "        return true;", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function lockFunds(", "        address stakerVaultAddress,", "        address payer,", "        address token,", "        uint256 lockAmount,", "        uint256 depositAmount", "    ) external {", "        uint256 amountLeft = lockAmount;", "        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);", "", "        // stake deposit amount", "        if (depositAmount > 0) {", "            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;", "            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);", "            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);", "            stakerVault.stake(depositAmount);", "            stakerVault.increaseActionLockedBalance(payer, depositAmount);", "            amountLeft -= depositAmount;", "        }", "", "        // use stake vault allowance if available and required", "        if (amountLeft > 0) {", "            uint256 balance = stakerVault.balanceOf(payer);", "            uint256 allowance = stakerVault.allowance(payer, address(this));", "            uint256 availableFunds = balance < allowance ? balance : allowance;", "            if (availableFunds >= amountLeft) {", "                stakerVault.transferFrom(payer, address(this), amountLeft);", "                amountLeft = 0;", "            }", "        }", "", "        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": ["\tfunction createMinipool(", "\t\taddress nodeID,", "\t\tuint256 duration,", "\t\tuint256 delegationFee,", "\t\tuint256 avaxAssignmentRequest", "\t) external payable whenNotPaused {", "\t\tif (nodeID == address(0)) {", "\t\t\trevert InvalidNodeID();", "\t\t}", "", "\t\tProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));", "\t\tif (", "\t\t\t// Current rule is matched funds must be 1:1 nodeOp:LiqStaker", "\t\t\tmsg.value != avaxAssignmentRequest ||", "\t\t\tavaxAssignmentRequest > dao.getMinipoolMaxAVAXAssignment() ||", "\t\t\tavaxAssignmentRequest < dao.getMinipoolMinAVAXAssignment()", "\t\t) {", "\t\t\trevert InvalidAVAXAssignmentRequest();", "\t\t}", "", "\t\tif (msg.value + avaxAssignmentRequest < dao.getMinipoolMinAVAXStakingAmt()) {", "\t\t\trevert InsufficientAVAXForMinipoolCreation();", "\t\t}", "", "\t\tStaking staking = Staking(getContractAddress(\"Staking\"));", "\t\tstaking.increaseMinipoolCount(msg.sender);", "\t\tstaking.increaseAVAXStake(msg.sender, msg.value);", "\t\tstaking.increaseAVAXAssigned(msg.sender, avaxAssignmentRequest);", "", "\t\tif (staking.getRewardsStartTime(msg.sender) == 0) {", "\t\t\tstaking.setRewardsStartTime(msg.sender, block.timestamp);", "\t\t}", "", "\t\tuint256 ratio = staking.getCollateralizationRatio(msg.sender);", "\t\tif (ratio < dao.getMinCollateralizationRatio()) {", "\t\t\trevert InsufficientGGPCollateralization();", "\t\t}", "", "\t\t// Get a Rialto multisig to assign for this minipool", "\t\tMultisigManager multisigManager = MultisigManager(getContractAddress(\"MultisigManager\"));", "\t\taddress multisig = multisigManager.requireNextActiveMultisig();", "", "\t\t// Create or update a minipool record for nodeID", "\t\t// If nodeID exists, only allow overwriting if node is finished or canceled", "\t\t// \t\t(completed its validation period and all rewards paid and processing is complete)", "\t\tint256 minipoolIndex = getIndexOf(nodeID);", "\t\tif (minipoolIndex != -1) {", "\t\t\trequireValidStateTransition(minipoolIndex, MinipoolStatus.Prelaunch);", "\t\t\tresetMinipoolData(minipoolIndex);", "\t\t\t// Also reset initialStartTime as we are starting a whole new validation", "\t\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".initialStartTime\")), 0);", "\t\t} else {", "\t\t\tminipoolIndex = int256(getUint(keccak256(\"minipool.count\")));", "\t\t\t// The minipoolIndex is stored 1 greater than actual value. The 1 is subtracted in getIndexOf()", "\t\t\tsetUint(keccak256(abi.encodePacked(\"minipool.index\", nodeID)), uint256(minipoolIndex + 1));", "\t\t\tsetAddress(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".nodeID\")), nodeID);", "\t\t\taddUint(keccak256(\"minipool.count\"), 1);", "\t\t}", "", "\t\t// Save the attrs individually in the k/v store", "\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".status\")), uint256(MinipoolStatus.Prelaunch));", "\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".duration\")), duration);", "\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".delegationFee\")), delegationFee);", "\t\tsetAddress(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".owner\")), msg.sender);", "\t\tsetAddress(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".multisigAddr\")), multisig);", "\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxNodeOpInitialAmt\")), msg.value);", "\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxNodeOpAmt\")), msg.value);", "\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxLiquidStakerAmt\")), avaxAssignmentRequest);", "", "\t\temit MinipoolStatusChanged(nodeID, MinipoolStatus.Prelaunch);", "", "\t\tVault vault = Vault(getContractAddress(\"Vault\"));", "\t\tvault.depositAVAX{value: msg.value}();", "\t}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _getVotesFunding(", "        address account_,", "        uint256 votingPower_,", "        uint256 remainingVotingPower_,", "        uint256 screeningStageEndBlock_", "    ) internal view returns (uint256 votes_) {", "        // voter has already allocated some of their budget this period", "        if (votingPower_ != 0) {", "            votes_ = remainingVotingPower_;", "        }", "        // voter hasn't yet called _castVote in this period", "        else {", "            votes_ = Maths.wpow(", "            _getVotesAtSnapshotBlocks(", "                account_,", "                screeningStageEndBlock_ - VOTING_POWER_SNAPSHOT_DELAY,", "                screeningStageEndBlock_", "            ), 2);", "        }", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function leverageSwap(bytes memory params, IERC20 token) internal {", "    (uint256 parToSell, bytes memory dexTxData, uint dexIndex) = abi.decode(", "      params,", "      (uint256, bytes, uint )", "    );", "    token.approve(address(a.core()), 2**256 - 1);", "    a.core().depositAndBorrow(address(token), token.balanceOf(address(this)), parToSell);", "    IERC20 par = IERC20(a.stablex());", "    aggregatorSwap(dexIndex, par, parToSell, dexTxData);", "  }"], "ner_tags": [1, 1, 1, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": ["    function setMinter(address _minter) external onlyOwner {", "        pendingMinter = _minter;", "        minterEnableDate = block.timestamp + 1 days;", "    }"], "ner_tags": [1, 1, 1, 1]}
{"tokens": ["    function slashQueuedWithdrawal(address recipient, QueuedWithdrawal calldata queuedWithdrawal, IERC20[] calldata tokens, uint256[] calldata indicesToSkip)", "        external", "        onlyOwner", "        onlyFrozen(queuedWithdrawal.delegatedAddress)", "        nonReentrant", "    {", "        require(tokens.length == queuedWithdrawal.strategies.length, \"StrategyManager.slashQueuedWithdrawal: input length mismatch\");", "", "        // find the withdrawalRoot", "        bytes32 withdrawalRoot = calculateWithdrawalRoot(queuedWithdrawal);", "", "        // verify that the queued withdrawal is pending", "        require(", "            withdrawalRootPending[withdrawalRoot],", "            \"StrategyManager.slashQueuedWithdrawal: withdrawal is not pending\"", "        );", "", "        // reset the storage slot in mapping of queued withdrawals", "        withdrawalRootPending[withdrawalRoot] = false;", "", "        // keeps track of the index in the `indicesToSkip` array", "        uint256 indicesToSkipIndex = 0;", "", "        uint256 strategiesLength = queuedWithdrawal.strategies.length;", "        for (uint256 i = 0; i < strategiesLength;) {", "            // check if the index i matches one of the indices specified in the `indicesToSkip` array", "            if (indicesToSkipIndex < indicesToSkip.length && indicesToSkip[indicesToSkipIndex] == i) {", "                unchecked {", "                    ++indicesToSkipIndex;", "                }", "            } else {", "                if (queuedWithdrawal.strategies[i] == beaconChainETHStrategy){", "                     //withdraw the beaconChainETH to the recipient", "                    _withdrawBeaconChainETH(queuedWithdrawal.depositor, recipient, queuedWithdrawal.shares[i]);", "                } else {", "                    // tell the strategy to send the appropriate amount of funds to the recipient", "                    queuedWithdrawal.strategies[i].withdraw(recipient, tokens[i], queuedWithdrawal.shares[i]);", "                }", "                unchecked {", "                    ++i;", "                }", "            }", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function withdraw(address _destination, uint256 _amount) external onlyOwner {", "        veToken.safeTransfer(_destination, _amount);", "", "        emit Withdraw(_destination, _amount);", "    }"], "ner_tags": [1, 0, 0, 0, 0]}
{"tokens": ["    function getPayAmount(", "        ERC20 pay_gem,", "        ERC20 buy_gem,", "        uint256 buy_amt", "    ) external view returns (uint256 fill_amt) {", "        uint256 offerId = getBestOffer(buy_gem, pay_gem); //Get best offer for the token pair", "        while (buy_amt > offers[offerId].pay_amt) {", "            fill_amt = add(fill_amt, offers[offerId].buy_amt); //Add amount to pay accumulator", "            buy_amt = sub(buy_amt, offers[offerId].pay_amt); //Decrease amount to buy", "            if (buy_amt > 0) {", "                //If we still need more offers", "                offerId = getWorseOffer(offerId); //We look for the next best offer", "                require(offerId != 0); //Fails if there are not enough offers to complete", "            }", "        }", "        fill_amt = add(", "            fill_amt,", "            rmul(", "                buy_amt * 10**9,", "                rdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)", "            ) / 10**9", "        ); //Add proportional amount of last offer to pay accumulator", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["    function claimForAllWindows(", "        uint256 percentageAllocation,", "        bytes32[] calldata merkleProof", "    ) external {", "        // Make sure that the user has this allocation granted.", "        require(", "            verifyProof(", "                merkleProof,", "                merkleRoot,", "                getNode(msg.sender, percentageAllocation)", "            ),", "            \"Invalid proof\"", "        );", "", "        uint256 amount = 0;", "        for (uint256 i = 0; i < currentWindow; i++) {", "            if (!isClaimed(msg.sender, i)) {", "                setClaimed(msg.sender, i);", "", "                amount += scaleAmountByPercentage(", "                    balanceForWindow[i],", "                    percentageAllocation", "                );", "            }", "        }", "", "        transferSplitAsset(msg.sender, amount);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": ["    function _userCheckpoint(address user) internal virtual returns (bool) {", "        poolCheckpoint();", "        perUserShare[user] += balances[user].scaledMul(", "            ammStakedIntegral - perUserStakedIntegral[user]", "        );", "        perUserStakedIntegral[user] = ammStakedIntegral;", "        return true;", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function withdraw(Liquidity calldata _withdrawal) external {", "        Liquidity memory total = totalLiquidity;", "        Liquidity memory user = userLiquidity[msg.sender];", "        if(_withdrawal.usdm > 0) {", "            require(unlockable, \"!unlock usdm\");", "            usdm.safeTransfer(msg.sender, uint256(_withdrawal.usdm));", "            total.usdm -= _withdrawal.usdm;", "            user.usdm -= _withdrawal.usdm;", "        }", "", "        if(_withdrawal.pool3 > 0) {", "            pool3.safeTransfer(msg.sender, uint256(_withdrawal.pool3));", "            total.pool3 -= _withdrawal.pool3;", "            user.pool3 -= _withdrawal.pool3;", "        }", "        totalLiquidity = total;", "        userLiquidity[msg.sender] = user;", "        emit Withdraw(msg.sender, _withdrawal);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function handleOps(UserOperation[] calldata ops, address payable beneficiary) public {", "", "        uint256 opslen = ops.length;", "        UserOpInfo[] memory opInfos = new UserOpInfo[](opslen);", "", "    unchecked {", "        for (uint256 i = 0; i < opslen; i++) {", "            _validatePrepayment(i, ops[i], opInfos[i], address(0));", "        }", "", "        uint256 collected = 0;", "", "        for (uint256 i = 0; i < opslen; i++) {", "            collected += _executeUserOp(i, ops[i], opInfos[i]);", "        }", "", "        _compensate(beneficiary, collected);", "    } //unchecked", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _minWethAmountOut(uint256 tokenAmount_, address token_)", "        internal", "        view", "        returns (uint256 minAmountOut)", "    {", "        return", "            tokenAmount_", "                .scaledMul(_addressProvider.getOracleProvider().getPriceETH(token_))", "                .scaledMul(slippageTolerance) * _decimalMultiplier(token_);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 1, 0]}
{"tokens": ["    function _withdraw(uint256 amount) internal override returns (bool) {", "        uint256 underlyingBalance = _underlyingBalance();", "", "        // Transferring from idle balance if enough", "        if (underlyingBalance >= amount) {", "            payable(vault).transfer(amount);", "            emit Withdraw(amount);", "            return true;", "        }", "", "        // Unstaking needed LP Tokens from Convex", "        uint256 requiredUnderlyingAmount = amount - underlyingBalance;", "        uint256 maxLpBurned = _maxLpBurned(requiredUnderlyingAmount);", "        uint256 requiredLpAmount = maxLpBurned - _lpBalance();", "        if (!rewards.withdrawAndUnwrap(requiredLpAmount, false)) return false;", "", "        // Removing needed liquidity from Curve", "        uint256[2] memory amounts;", "        // solhint-disable-next-line reentrancy", "        amounts[curveIndex] = requiredUnderlyingAmount;", "        curvePool.remove_liquidity_imbalance(amounts, maxLpBurned);", "        payable(vault).transfer(amount);", "        return true;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["    function updateURIDelegate(address _uriDelegate) public onlyRole(URI_SETTER_ROLE) {", "        tokenUriDelegate = _uriDelegate;", "    }"], "ner_tags": [1, 1, 1]}
{"tokens": ["    function update(LiquidityPosition storage liquidityPosition, uint256 long0FeeGrowth, uint256 long1FeeGrowth, uint256 shortFeeGrowth) internal {", "        uint160 liquidity = liquidityPosition.liquidity;", "", "        if (liquidity != 0) {", "            liquidityPosition.long0Fees += FeeCalculation.getFees(liquidity, liquidityPosition.long0FeeGrowth, long0FeeGrowth);", "            liquidityPosition.long1Fees += FeeCalculation.getFees(liquidity, liquidityPosition.long1FeeGrowth, long1FeeGrowth);", "            liquidityPosition.shortFees += FeeCalculation.getFees(liquidity, liquidityPosition.shortFeeGrowth, shortFeeGrowth);", "        }", "", "        liquidityPosition.long0FeeGrowth = long0FeeGrowth;", "        liquidityPosition.long1FeeGrowth = long1FeeGrowth;", "        liquidityPosition.shortFeeGrowth = shortFeeGrowth;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["    function topUp(", "        bytes32 account,", "        address underlying,", "        uint256 amount,", "        bytes memory extra", "    ) external override returns (bool) {", "        bool repayDebt = abi.decode(extra, (bool));", "        CToken ctoken = cTokenRegistry.fetchCToken(underlying);", "        uint256 initialTokens = ctoken.balanceOf(address(this));", "", "        address addr = account.addr();", "", "        if (repayDebt) {", "            amount -= _repayAnyDebt(addr, underlying, amount, ctoken);", "            if (amount == 0) return true;", "        }", "", "        uint256 err;", "        if (underlying == address(0)) {", "            err = ctoken.mint{value: amount}(amount);", "        } else {", "            IERC20(underlying).safeApprove(address(ctoken), amount);", "            err = ctoken.mint(amount);", "        }", "        require(err == 0, Error.FAILED_MINT);", "", "        uint256 newTokens = ctoken.balanceOf(address(this));", "        uint256 mintedTokens = newTokens - initialTokens;", "", "        bool success = ctoken.transfer(addr, mintedTokens);", "        require(success, Error.FAILED_TRANSFER);", "        return true;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _sendBadgerToTree(uint256 amount) internal {", "        IERC20Upgradeable(BADGER).safeTransfer(BADGER_TREE, amount);", "        _processExtraToken(address(BADGER), amount);", "    }"], "ner_tags": [1, 1, 1, 0]}
{"tokens": ["    function getHash(UserOperation calldata userOp)", "    public pure returns (bytes32) {", "        //can't use userOp.hash(), since it contains also the paymasterAndData itself.", "        return keccak256(abi.encode(", "                userOp.getSender(),", "                userOp.nonce,", "                keccak256(userOp.initCode),", "                keccak256(userOp.callData),", "                userOp.callGasLimit,", "                userOp.verificationGasLimit,", "                userOp.preVerificationGas,", "                userOp.maxFeePerGas,", "                userOp.maxPriorityFeePerGas", "            ));", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": ["    function stashRewards() external returns (bool) {", "        require(msg.sender == operator, \"!authorized\");", "", "        //after depositing/withdrawing, extra incentive tokens are transfered to the staking contract", "        //need to pull them off and stash here.", "        for (uint256 i = 0; i < tokenCount; i++) {", "            TokenInfo storage t = tokenInfo[i];", "            address token = t.token;", "            if (token == address(0)) continue;", "", "            //only stash if rewards are active", "            if (block.timestamp <= t.lastActiveTime + WEEK) {", "                uint256 before = IERC20(token).balanceOf(address(this));", "                IStaker(staker).withdraw(token);", "", "                //check for multiple pools claiming same token", "                uint256 activeCount = IRewardFactory(rewardFactory).activeRewardCount(token);", "                if (activeCount > 1) {", "                    //take difference of before/after(only send new tokens)", "                    uint256 amount = IERC20(token).balanceOf(address(this));", "                    amount = amount.sub(before);", "", "                    //send to arbitrator", "                    address arb = IDeposit(operator).rewardArbitrator();", "                    if (arb != address(0)) {", "                        IERC20(token).safeTransfer(arb, amount);", "                    }", "                }", "            }", "        }", "        return true;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": ["\tfunction verifySig(", "\t\taddress _signer,", "\t\tbytes32 _theHash,", "\t\tuint8 _v,", "\t\tbytes32 _r,", "\t\tbytes32 _s", "\t) private pure returns (bool) {", "\t\tbytes32 messageDigest = keccak256(", "\t\t\tabi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _theHash)", "\t\t);", "\t\treturn _signer == ecrecover(messageDigest, _v, _r, _s);", "\t}"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function quantity(IERC20 erc20) public view returns (uint192) {", "        try assetRegistry.toColl(erc20) returns (ICollateral coll) {", "            if (coll.status() == CollateralStatus.DISABLED) return FIX_ZERO;", "", "            uint192 refPerTok = coll.refPerTok(); // {ref/tok}", "            if (refPerTok > 0) {", "                // {tok/BU} = {ref/BU} / {ref/tok}", "                return basket.refAmts[erc20].div(refPerTok, CEIL);", "            } else {", "                return FIX_MAX;", "            }", "        } catch {", "            return FIX_ZERO;", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function addReward(", "        address _rewardsToken,", "        address _veAssetDeposits,", "        address _ve3Token,", "        address _ve3TokenStaking,", "        address _distributor,", "        bool _isVeAsset", "    ) external {", "        require(_msgSender() == owner() || operators.contains(_msgSender()), \"!Auth\");", "        require(rewardData[_rewardsToken].lastUpdateTime == 0);", "        require(_rewardsToken != address(stakingToken));", "        rewardTokens.push(_rewardsToken);", "", "        rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);", "        rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);", "        rewardDistributors[_rewardsToken][_distributor] = true;", "", "        rewardData[_rewardsToken].isVeAsset = _isVeAsset;", "        // if reward is veAsset", "        if (_isVeAsset) {", "            require(_ve3Token != address(0));", "            require(_ve3TokenStaking != address(0));", "            require(_veAssetDeposits != address(0));", "            rewardData[_rewardsToken].ve3Token = _ve3Token;", "            rewardData[_rewardsToken].ve3TokenStaking = _ve3TokenStaking;", "            rewardData[_rewardsToken].veAssetDeposits = _veAssetDeposits;", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _returnTokens(address token_, uint256 amount_)", "        internal", "        returns (uint256 amountReturned)", "    {", "        // Returning if ETH", "        if (token_ == address(0)) {", "            payable(msg.sender).transfer(amount_);", "            return amount_;", "        }", "", "        // Returning if ERC20", "        IERC20(token_).safeTransfer(msg.sender, amount_);", "        return amount_;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function exitMarket(address vTokenAddress) external override returns (uint256) {", "        _checkActionPauseState(vTokenAddress, Action.EXIT_MARKET);", "        VToken vToken = VToken(vTokenAddress);", "        /* Get sender tokensHeld and amountOwed underlying from the vToken */", "        (uint256 tokensHeld, uint256 amountOwed, ) = _safeGetAccountSnapshot(vToken, msg.sender);", "", "        /* Fail if the sender has a borrow balance */", "        if (amountOwed != 0) {", "            revert NonzeroBorrowBalance();", "        }", "", "        /* Fail if the sender is not permitted to redeem all of their tokens */", "        _checkRedeemAllowed(vTokenAddress, msg.sender, tokensHeld);", "", "        Market storage marketToExit = markets[address(vToken)];", "", "        /* Return true if the sender is not already \u2018in\u2019 the market */", "        if (!marketToExit.accountMembership[msg.sender]) {", "            return NO_ERROR;", "        }", "", "        /* Set vToken account membership to false */", "        delete marketToExit.accountMembership[msg.sender];", "", "        /* Delete vToken from the account\u2019s list of assets */", "        // load into memory for faster iteration", "        VToken[] memory userAssetList = accountAssets[msg.sender];", "        uint256 len = userAssetList.length;", "", "        uint256 assetIndex = len;", "        for (uint256 i; i < len; ++i) {", "            if (userAssetList[i] == vToken) {", "                assetIndex = i;", "                break;", "            }", "        }", "", "        // We *must* have found the asset in the list or our redundant data structure is broken", "        assert(assetIndex < len);", "", "        // copy last item in list to location of item to be removed, reduce length by 1", "        VToken[] storage storedList = accountAssets[msg.sender];", "        storedList[assetIndex] = storedList[storedList.length - 1];", "        storedList.pop();", "", "        emit MarketExited(vToken, msg.sender);", "", "        return NO_ERROR;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _getDelegateReward(", "        QuarterlyDistribution memory currentDistribution_,", "        QuadraticVoter memory voter_", "    ) internal pure returns (uint256 rewards_) {", "        // calculate the total voting power available to the voter that was allocated in the funding stage", "        uint256 votingPowerAllocatedByDelegatee = voter_.votingPower - voter_.remainingVotingPower;", "", "        // if none of the voter's voting power was allocated, they receive no rewards", "        if (votingPowerAllocatedByDelegatee == 0) return 0;", "", "        // calculate reward", "        // delegateeReward = 10 % of GBC distributed as per delegatee Voting power allocated", "        rewards_ = Maths.wdiv(", "            Maths.wmul(", "                currentDistribution_.fundsAvailable,", "                votingPowerAllocatedByDelegatee", "            ),", "            currentDistribution_.fundingVotePowerCast", "        ) / 10;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function initialize(", "        address timelock_,", "        address nouns_,", "        address vetoer_,", "        uint256 votingPeriod_,", "        uint256 votingDelay_,", "        uint256 proposalThresholdBPS_,", "        uint256 quorumVotesBPS_", "    ) public virtual {", "        require(address(timelock) == address(0), 'NounsDAO::initialize: can only initialize once');", "        require(msg.sender == admin, 'NounsDAO::initialize: admin only');", "        require(timelock_ != address(0), 'NounsDAO::initialize: invalid timelock address');", "        require(nouns_ != address(0), 'NounsDAO::initialize: invalid nouns address');", "        require(", "            votingPeriod_ >= MIN_VOTING_PERIOD && votingPeriod_ <= MAX_VOTING_PERIOD,", "            'NounsDAO::initialize: invalid voting period'", "        );", "        require(", "            votingDelay_ >= MIN_VOTING_DELAY && votingDelay_ <= MAX_VOTING_DELAY,", "            'NounsDAO::initialize: invalid voting delay'", "        );", "        require(", "            proposalThresholdBPS_ >= MIN_PROPOSAL_THRESHOLD_BPS && proposalThresholdBPS_ <= MAX_PROPOSAL_THRESHOLD_BPS,", "            'NounsDAO::initialize: invalid proposal threshold'", "        );", "        require(", "            quorumVotesBPS_ >= MIN_QUORUM_VOTES_BPS && quorumVotesBPS_ <= MAX_QUORUM_VOTES_BPS,", "            'NounsDAO::initialize: invalid proposal threshold'", "        );", "", "        emit VotingPeriodSet(votingPeriod, votingPeriod_);", "        emit VotingDelaySet(votingDelay, votingDelay_);", "        emit ProposalThresholdBPSSet(proposalThresholdBPS, proposalThresholdBPS_);", "        emit QuorumVotesBPSSet(quorumVotesBPS, quorumVotesBPS_);", "", "        timelock = INounsDAOExecutor(timelock_);", "        nouns = NounsTokenLike(nouns_);", "        vetoer = vetoer_;", "        votingPeriod = votingPeriod_;", "        votingDelay = votingDelay_;", "        proposalThresholdBPS = proposalThresholdBPS_;", "        quorumVotesBPS = quorumVotesBPS_;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function stakedLBRLpValue(address user) public view returns (uint256) {", "        uint256 totalLp = IEUSD(ethlbrLpToken).totalSupply();", "        (, int etherPrice, , , ) = etherPriceFeed.latestRoundData();", "        (, int lbrPrice, , , ) = lbrPriceFeed.latestRoundData();", "        uint256 etherInLp = (IEUSD(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).balanceOf(ethlbrLpToken) * uint(etherPrice)) / 1e8;", "        uint256 lbrInLp = (IEUSD(LBR).balanceOf(ethlbrLpToken) * uint(lbrPrice)) / 1e8;", "        uint256 userStaked = IEUSD(ethlbrStakePool).balanceOf(user);", "        return (userStaked * (lbrInLp + etherInLp)) / totalLp;", "    }"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 0, 0]}
{"tokens": ["    function deposit(", "        uint256 _pid,", "        uint256 _amount,", "        bool _stake", "    ) public returns (bool) {", "        require(!isShutdown, \"shutdown\");", "        PoolInfo storage pool = poolInfo[_pid];", "        require(pool.shutdown == false, \"pool is closed\");", "", "        //send to proxy to stake", "        address lptoken = pool.lptoken;", "        IERC20(lptoken).safeTransferFrom(msg.sender, staker, _amount);", "", "        //stake", "        address gauge = pool.gauge;", "        require(gauge != address(0), \"!gauge setting\");", "        IStaker(staker).deposit(lptoken, gauge);", "", "        //some gauges claim rewards when depositing, stash them in a seperate contract until next claim", "        address stash = pool.stash;", "        if (stash != address(0)) {", "            IStash(stash).stashRewards();", "        }", "", "        address token = pool.token;", "        if (_stake) {", "            //mint here and send to rewards on user behalf", "            ITokenMinter(token).mint(address(this), _amount);", "            address rewardContract = pool.veAssetRewards;", "            IERC20(token).safeApprove(rewardContract, _amount);", "            IRewards(rewardContract).stakeFor(msg.sender, _amount);", "        } else {", "            //add user balance directly", "            ITokenMinter(token).mint(msg.sender, _amount);", "        }", "", "        emit Deposited(msg.sender, _pid, _amount);", "        return true;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function depositGlp(", "        address token,", "        uint256 tokenAmount,", "        uint256 minUsdg,", "        uint256 minGlp,", "        address receiver", "    ) external nonReentrant returns (uint256) {", "        if (token == address(0)) revert ZeroAddress();", "        if (tokenAmount == 0) revert ZeroAmount();", "        if (minUsdg == 0) revert ZeroAmount();", "        if (minGlp == 0) revert ZeroAmount();", "        if (receiver == address(0)) revert ZeroAddress();", "", "        if (totalAssets() != 0) beforeDeposit(address(0), 0, 0);", "", "        // PirexGmx will do the check whether the token is whitelisted or not", "        ERC20 erc20Token = ERC20(token);", "", "        // Transfer token from the caller to the vault", "        // before approving PirexGmx to proceed with the deposit", "        erc20Token.safeTransferFrom(msg.sender, address(this), tokenAmount);", "", "        // Approve as needed here since it can be a new whitelisted token (unless it's the baseReward)", "        if (erc20Token != gmxBaseReward) {", "            erc20Token.safeApprove(platform, tokenAmount);", "        }", "", "        (, uint256 assets, ) = PirexGmx(platform).depositGlp(", "            token,", "            tokenAmount,", "            minUsdg,", "            minGlp,", "            address(this)", "        );", "", "        // Handle vault deposit after minting pxGLP", "        return _deposit(assets, receiver);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function compound(", "        uint256 minUsdg,", "        uint256 minGlp,", "        bool optOutIncentive", "    )", "        public", "        returns (", "            uint256 gmxBaseRewardAmountIn,", "            uint256 pxGmxAmountOut,", "            uint256 pxGlpAmountOut,", "            uint256 totalPxGlpFee,", "            uint256 totalPxGmxFee,", "            uint256 pxGlpIncentive,", "            uint256 pxGmxIncentive", "        )", "    {", "        if (minUsdg == 0) revert InvalidParam();", "        if (minGlp == 0) revert InvalidParam();", "", "        uint256 preClaimTotalAssets = asset.balanceOf(address(this));", "        uint256 preClaimPxGmxAmount = pxGmx.balanceOf(address(this));", "", "        PirexRewards(rewardsModule).claim(asset, address(this));", "        PirexRewards(rewardsModule).claim(pxGmx, address(this));", "", "        // Track the amount of rewards received", "        gmxBaseRewardAmountIn = gmxBaseReward.balanceOf(address(this));", "", "        if (gmxBaseRewardAmountIn != 0) {", "            // Deposit received rewards for pxGLP", "            (, pxGlpAmountOut, ) = PirexGmx(platform).depositGlp(", "                address(gmxBaseReward),", "                gmxBaseRewardAmountIn,", "                minUsdg,", "                minGlp,", "                address(this)", "            );", "        }", "", "        // Distribute fees if the amount of vault assets increased", "        uint256 newAssets = totalAssets() - preClaimTotalAssets;", "        if (newAssets != 0) {", "            totalPxGlpFee = (newAssets * platformFee) / FEE_DENOMINATOR;", "            pxGlpIncentive = optOutIncentive", "                ? 0", "                : (totalPxGlpFee * compoundIncentive) / FEE_DENOMINATOR;", "", "            if (pxGlpIncentive != 0)", "                asset.safeTransfer(msg.sender, pxGlpIncentive);", "", "            asset.safeTransfer(owner, totalPxGlpFee - pxGlpIncentive);", "        }", "", "        // Track the amount of pxGMX received", "        pxGmxAmountOut = pxGmx.balanceOf(address(this)) - preClaimPxGmxAmount;", "", "        if (pxGmxAmountOut != 0) {", "            // Calculate and distribute pxGMX fees if the amount of pxGMX increased", "            totalPxGmxFee = (pxGmxAmountOut * platformFee) / FEE_DENOMINATOR;", "            pxGmxIncentive = optOutIncentive", "                ? 0", "                : (totalPxGmxFee * compoundIncentive) / FEE_DENOMINATOR;", "", "            if (pxGmxIncentive != 0)", "                pxGmx.safeTransfer(msg.sender, pxGmxIncentive);", "", "            pxGmx.safeTransfer(owner, totalPxGmxFee - pxGmxIncentive);", "", "            // Update the pxGmx reward accrual", "            _harvest(pxGmxAmountOut - totalPxGmxFee);", "        } else {", "            // Required to keep the globalState up-to-date", "            _globalAccrue();", "        }", "", "        emit Compounded(", "            msg.sender,", "            minGlp,", "            gmxBaseRewardAmountIn,", "            pxGmxAmountOut,", "            pxGlpAmountOut,", "            totalPxGlpFee,", "            totalPxGmxFee,", "            pxGlpIncentive,", "            pxGmxIncentive", "        );", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function withdrawCollateral(", "    address _asset,", "    uint256 _amount,", "    address _to", "  ) external virtual {", "    // Before withdraw from lending pool, get the stAsset address and withdrawal amount", "    // Ex: In Lido vault, it will return stETH address and same amount", "    (address _stAsset, uint256 _stAssetAmount) = _getWithdrawalAmount(_asset, _amount);", "", "    // withdraw from lendingPool, it will convert user's aToken to stAsset", "    uint256 _amountToWithdraw = ILendingPool(_addressesProvider.getLendingPool()).withdrawFrom(", "      _stAsset,", "      _stAssetAmount,", "      msg.sender,", "      address(this)", "    );", "", "    // Withdraw from vault, it will convert stAsset to asset and send to user", "    // Ex: In Lido vault, it will return ETH or stETH to user", "    uint256 withdrawAmount = _withdrawFromYieldPool(_asset, _amountToWithdraw, _to);", "", "    if (_amount == type(uint256).max) {", "      uint256 decimal = IERC20Detailed(_asset).decimals();", "      _amount = _amountToWithdraw.mul(this.pricePerShare()).div(10**decimal);", "    }", "    require(withdrawAmount >= _amount.percentMul(99_00), Errors.VT_WITHDRAW_AMOUNT_MISMATCH);", "", "    emit WithdrawCollateral(_asset, _to, _amount);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenAmount */) external override onlyModule(_setToken) {", "        _redeemMaturedPositions(_setToken);", "    }"], "ner_tags": [1, 0, 0]}
{"tokens": ["    function updateTWAV() external override {", "        require(status == Status.buyout, \"NibblVault: Status!=Buyout\");", "        uint32 _blockTimestamp = uint32(block.timestamp % 2**32);", "        if (_blockTimestamp != lastBlockTimeStamp) {", "            _updateTWAV(getCurrentValuation(), _blockTimestamp);   ", "            _rejectBuyout(); //For the case when TWAV goes up when updated externally", "        }", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function liquidateAccount(address borrower, LiquidationOrder[] calldata orders) external {", "        // We will accrue interest and update the oracle prices later during the liquidation", "", "        AccountLiquiditySnapshot memory snapshot = _getCurrentLiquiditySnapshot(borrower, _getLiquidationThreshold);", "", "        if (snapshot.totalCollateral > minLiquidatableCollateral) {", "            // You should use the regular vToken.liquidateBorrow(...) call", "            revert CollateralExceedsThreshold(minLiquidatableCollateral, snapshot.totalCollateral);", "        }", "", "        uint256 collateralToSeize = mul_ScalarTruncate(", "            Exp({ mantissa: liquidationIncentiveMantissa }),", "            snapshot.borrows", "        );", "        if (collateralToSeize >= snapshot.totalCollateral) {", "            // There is not enough collateral to seize. Use healBorrow to repay some part of the borrow", "            // and record bad debt.", "            revert InsufficientCollateral(collateralToSeize, snapshot.totalCollateral);", "        }", "", "        if (snapshot.shortfall == 0) {", "            revert InsufficientShortfall();", "        }", "", "        uint256 ordersCount = orders.length;", "", "        _ensureMaxLoops(ordersCount);", "", "        for (uint256 i; i < ordersCount; ++i) {", "            if (!markets[address(orders[i].vTokenBorrowed)].isListed) {", "                revert MarketNotListed(address(orders[i].vTokenBorrowed));", "            }", "            if (!markets[address(orders[i].vTokenCollateral)].isListed) {", "                revert MarketNotListed(address(orders[i].vTokenCollateral));", "            }", "", "            LiquidationOrder calldata order = orders[i];", "            order.vTokenBorrowed.forceLiquidateBorrow(", "                msg.sender,", "                borrower,", "                order.repayAmount,", "                order.vTokenCollateral,", "                true", "            );", "        }", "", "        VToken[] memory borrowMarkets = accountAssets[borrower];", "        uint256 marketsCount = borrowMarkets.length;", "", "        for (uint256 i; i < marketsCount; ++i) {", "            (, uint256 borrowBalance, ) = _safeGetAccountSnapshot(borrowMarkets[i], borrower);", "            require(borrowBalance == 0, \"Nonzero borrow balance after liquidation\");", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0]}
{"tokens": ["    function utilizationRate(", "        uint256 cash,", "        uint256 borrows,", "        uint256 reserves", "    ) public pure returns (uint256) {", "        // Utilization rate is 0 when there are no borrows", "        if (borrows == 0) {", "            return 0;", "        }", "", "        return (borrows * BASE) / (cash + borrows - reserves);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function requestCPIData()", "        external", "        afterTimeInit", "        returns (bytes32 requestId)", "    {", "        require(", "            getDay(block.timestamp) > 14,", "            \"ScalingPriceOracle: cannot request data before the 15th\"", "        );", "", "        Chainlink.Request memory request = buildChainlinkRequest(", "            jobId,", "            address(this),", "            this.fulfill.selector", "        );", "", "        return sendChainlinkRequestTo(oracle, request, fee);", "    }"], "ner_tags": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _mintFresh(", "        address payer,", "        address minter,", "        uint256 mintAmount", "    ) internal {", "        /* Fail if mint not allowed */", "        comptroller.preMintHook(address(this), minter, mintAmount);", "", "        /* Verify market's block number equals current block number */", "        if (accrualBlockNumber != _getBlockNumber()) {", "            revert MintFreshnessCheck();", "        }", "", "        Exp memory exchangeRate = Exp({ mantissa: _exchangeRateStored() });", "", "        /////////////////////////", "        // EFFECTS & INTERACTIONS", "        // (No safe failures beyond this point)", "", "        /*", "         *  We call `_doTransferIn` for the minter and the mintAmount.", "         *  `_doTransferIn` reverts if anything goes wrong, since we can't be sure if", "         *  side-effects occurred. The function returns the amount actually transferred,", "         *  in case of a fee. On success, the vToken holds an additional `actualMintAmount`", "         *  of cash.", "         */", "        uint256 actualMintAmount = _doTransferIn(payer, mintAmount);", "", "        /*", "         * We get the current exchange rate and calculate the number of vTokens to be minted:", "         *  mintTokens = actualMintAmount / exchangeRate", "         */", "", "        uint256 mintTokens = div_(actualMintAmount, exchangeRate);", "", "        /*", "         * We calculate the new total supply of vTokens and minter token balance, checking for overflow:", "         *  totalSupplyNew = totalSupply + mintTokens", "         *  accountTokensNew = accountTokens[minter] + mintTokens", "         * And write them into storage", "         */", "        totalSupply = totalSupply + mintTokens;", "        uint256 balanceAfter = accountTokens[minter] + mintTokens;", "        accountTokens[minter] = balanceAfter;", "", "        /* We emit a Mint event, and a Transfer event */", "        emit Mint(minter, actualMintAmount, mintTokens, balanceAfter);", "        emit Transfer(address(0), minter, mintTokens);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function afterTokenTransfer(address, address _to, uint256) external {", "        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");", "        _setClaimedToMax(_to);", "    }"], "ner_tags": [0, 0, 1, 0]}
{"tokens": ["    function _transfer(", "        address from,", "        address to,", "        uint256 id,", "        uint256 amount,", "        bytes memory data", "    ) internal {", "        (address oldOwner, uint32 fuses, uint64 expiry) = getData(id);", "        if (oldOwner == to) {", "            return;", "        }", "", "        if (!_canTransfer(fuses)) {", "            revert OperationProhibited(bytes32(id));", "        }", "", "        require(", "            amount == 1 && oldOwner == from,", "            \"ERC1155: insufficient balance for transfer\"", "        );", "        _setData(id, to, fuses, expiry);", "", "        emit TransferSingle(msg.sender, from, to, id, amount);", "", "        _doSafeTransferAcceptanceCheck(msg.sender, from, to, id, amount, data);", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _setPoolCollateralFactors(address[] calldata pools, uint256[] calldata collateralFactorsMantissa)", "        external", "    {", "        require(msg.sender == admin, \"only admin can set collateral factors for pools\");", "        require(pools.length > 0, \"must have at least one pool\");", "        require(", "            pools.length == collateralFactorsMantissa.length,", "            \"Number of pools and collateralFactors must be equal\"", "        );", "        for (uint256 i = 0; i < pools.length; i++) {", "            poolCollateralFactors[pools[i]] = collateralFactorsMantissa[i];", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["    function redeemPxGlp(", "        address token,", "        uint256 amount,", "        uint256 minOut,", "        address receiver", "    )", "        external", "        whenNotPaused", "        nonReentrant", "        returns (", "            uint256,", "            uint256,", "            uint256", "        )", "    {", "        if (token == address(0)) revert ZeroAddress();", "        if (!gmxVault.whitelistedTokens(token)) revert InvalidToken(token);", "", "        return _redeemPxGlp(token, amount, minOut, receiver);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _executeArbitraryCalls(", "        IProposalExecutionEngine.ExecuteProposalParams memory params", "    )", "        internal", "        returns (bytes memory nextProgressData)", "    {", "        // Get the calls to execute.", "        (ArbitraryCall[] memory calls) = abi.decode(params.proposalData, (ArbitraryCall[]));", "        // Check whether the proposal was unanimously passed.", "        bool isUnanimous = params.flags & LibProposal.PROPOSAL_FLAG_UNANIMOUS", "            == LibProposal.PROPOSAL_FLAG_UNANIMOUS;", "        // If not unanimous, keep track of which preciouses we had before the calls", "        // so we can check that we still have them later.", "        bool[] memory hadPreciouses = new bool[](params.preciousTokenIds.length);", "        if (!isUnanimous) {", "            for (uint256 i = 0; i < hadPreciouses.length; ++i) {", "                hadPreciouses[i] = _getHasPrecious(", "                    params.preciousTokens[i],", "                    params.preciousTokenIds[i]", "                );", "            }", "        }", "        // Can only forward ETH attached to the call.", "        uint256 ethAvailable = msg.value;", "        for (uint256 i = 0; i < calls.length; ++i) {", "            // Execute an arbitrary call.", "            _executeSingleArbitraryCall(", "                i,", "                calls[i],", "                params.preciousTokens,", "                params.preciousTokenIds,", "                isUnanimous,", "                ethAvailable", "            );", "            // Update the amount of ETH available for the subsequent calls.", "            ethAvailable -= calls[i].value;", "            emit ArbitraryCallExecuted(params.proposalId, i, calls.length);", "        }", "        // If not a unanimous vote and we had a precious beforehand,", "        // ensure that we still have it now.", "        if (!isUnanimous) {", "            for (uint256 i = 0; i < hadPreciouses.length; ++i) {", "                if (hadPreciouses[i]) {", "                    if (!_getHasPrecious(params.preciousTokens[i], params.preciousTokenIds[i])) {", "                        revert PreciousLostError(", "                            params.preciousTokens[i],", "                            params.preciousTokenIds[i]", "                        );", "                    }", "                }", "            }", "        }", "        // No next step, so no progressData.", "        return '';", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function setTrustedForwarder(address _newForwarder)", "        external", "        override", "        onlyAdmin", "        noChange(trustedForwarder, _newForwarder)", "    {", "        trustedForwarder = _newForwarder;", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function getMaximumRewards(uint poolId, uint rewardIndex) public view returns (uint) {", "        Pool storage pool = pools[poolId];", "        // rewardsPerSecondPerToken * tokens * seconds", "        return pool.rewardsWeiPerSecondPerToken[rewardIndex] * pool.maximumDepositWei * (pool.endTime - pool.startTime) / 1e18;", "    }"], "ner_tags": [0, 0, 0, 1, 0]}
{"tokens": ["  function processCalls(", "    uint256 _nonce,", "    CallLib.Call[] calldata _calls,", "    address _sender,", "    uint256 _gasLimit,", "    uint256 _maxSubmissionCost,", "    uint256 _gasPriceBid", "  ) external payable returns (uint256) {", "    require(relayed[_getTxHash(_nonce, _calls, _sender, _gasLimit)], \"Relayer/calls-not-relayed\");", "", "    bytes memory _data = abi.encodeWithSignature(", "      \"executeCalls(uint256,address,(address,bytes)[])\",", "      _nonce,", "      _sender,", "      _calls", "    );", "", "    uint256 _ticketID = inbox.createRetryableTicket{ value: msg.value }(", "      address(executor),", "      0,", "      _maxSubmissionCost,", "      msg.sender,", "      msg.sender,", "      _gasLimit,", "      _gasPriceBid,", "      _data", "    );", "", "    emit ProcessedCalls(_nonce, msg.sender, _ticketID);", "", "    return _ticketID;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function newEpoch(", "        uint256 _startBlock,", "        uint256 _endBlock,", "        uint256 _rewardPerBlock", "    ) external onlyOwner {", "        require(_startBlock >= block.number, \"Invalid start block\");", "        require(_endBlock > _startBlock, \"Invalid end block\");", "        require(_rewardPerBlock > 0, \"Invalid reward per block\");", "", "        //update all pools to ensure that they have all been updated up to the last epoch's `endBlock`", "        _massUpdatePools();", "", "        uint256 remainingRewards = epoch.rewardPerBlock *", "            (epoch.endBlock - _blockNumber());", "        uint256 newRewards = _rewardPerBlock * (_endBlock - _startBlock);", "", "        epoch.startBlock = _startBlock;", "        epoch.endBlock = _endBlock;", "        epoch.rewardPerBlock = _rewardPerBlock;", "", "        if (remainingRewards > newRewards) {", "            jpeg.safeTransfer(msg.sender, remainingRewards - newRewards);", "        } else if (remainingRewards < newRewards) {", "            jpeg.safeTransferFrom(", "                msg.sender,", "                address(this),", "                newRewards - remainingRewards", "            );", "        }", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function withdraw(uint256 _tokenId) external nonreentrant {", "        assert(_isApprovedOrOwner(msg.sender, _tokenId));", "        require(attachments[_tokenId] == 0 && !voted[_tokenId], 'attached');", "", "        LockedBalance memory _locked = locked[_tokenId];", "        require(block.timestamp >= _locked.end, \"The lock didn't expire\");", "        uint256 value = uint256(int256(_locked.amount));", "", "        locked[_tokenId] = LockedBalance(0, 0);", "        uint256 supply_before = supply;", "        supply = supply_before - value;", "", "        // old_locked can have either expired <= timestamp or zero end", "        // _locked has only 0 end", "        // Both can have >= 0 amount", "        _checkpoint(_tokenId, _locked, LockedBalance(0, 0));", "", "        assert(IERC20(token).transfer(msg.sender, value));", "", "        // Burn the NFT", "        _burn(_tokenId);", "", "        emit Withdraw(msg.sender, _tokenId, value, block.timestamp);", "        emit Supply(supply_before, supply_before - value);", "    }"], "ner_tags": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _writeCheckpoint(address account, uint balance) internal {", "        uint _timestamp = block.timestamp;", "        uint _nCheckPoints = numCheckpoints[account];", "", "        if (_nCheckPoints > 0 && checkpoints[account][_nCheckPoints - 1].timestamp == _timestamp) {", "            checkpoints[account][_nCheckPoints - 1].balanceOf = balance;", "        } else {", "            bool prevVoteStatus = (_nCheckPoints > 0) ? checkpoints[account][_nCheckPoints].voted : false;", "            checkpoints[account][_nCheckPoints] = Checkpoint(_timestamp, balance, prevVoteStatus);", "            numCheckpoints[account] = _nCheckPoints + 1;", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["    function slashShares(", "        address slashedAddress,", "        address recipient,", "        IStrategy[] calldata strategies,", "        IERC20[] calldata tokens,", "        uint256[] calldata strategyIndexes,", "        uint256[] calldata shareAmounts", "    )", "        external", "        onlyOwner", "        onlyFrozen(slashedAddress)", "        nonReentrant", "    {", "        require(tokens.length == strategies.length, \"StrategyManager.slashShares: input length mismatch\");", "        uint256 strategyIndexIndex;", "        uint256 strategiesLength = strategies.length;", "        for (uint256 i = 0; i < strategiesLength;) {", "            // the internal function will return 'true' in the event the strategy was", "            // removed from the slashedAddress's array of strategies -- i.e. stakerStrategyList[slashedAddress]", "            if (_removeShares(slashedAddress, strategyIndexes[strategyIndexIndex], strategies[i], shareAmounts[i])) {", "                unchecked {", "                    ++strategyIndexIndex;", "                }", "            }", "", "            if (strategies[i] == beaconChainETHStrategy) {", "                 //withdraw the beaconChainETH to the recipient", "                _withdrawBeaconChainETH(slashedAddress, recipient, shareAmounts[i]);", "            }", "            else {", "                // withdraw the shares and send funds to the recipient", "                strategies[i].withdraw(recipient, tokens[i], shareAmounts[i]);", "            }", "", "            // increment the loop", "            unchecked {", "                ++i;", "            }", "        }", "", "        // modify delegated shares accordingly, if applicable", "        delegation.decreaseDelegatedShares(slashedAddress, strategies, shareAmounts);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function revokeClaim(address _recipient) external onlyAdmin hasActiveClaim(_recipient) {", "        // Fetch the claim", "        Claim storage _claim = claims[_recipient];", "        // Calculate what the claim should finally vest to", "        uint112 finalVestAmt = finalVestedAmount(_recipient);", "", "        // No point in revoking something that has been fully consumed", "        // so require that there be unconsumed amount", "        require( _claim.amountWithdrawn < finalVestAmt, \"NO_UNVESTED_AMOUNT\");", "", "        // The amount that is \"reclaimed\" is equal to the total allocation less what was already withdrawn", "        uint112 amountRemaining = finalVestAmt - _claim.amountWithdrawn;", "", "        // Deactivate the claim, and release the appropriate amount of tokens", "        _claim.isActive = false;    // This effectively reduces the liability by amountRemaining, so we can reduce the liability numTokensReservedForVesting by that much", "        numTokensReservedForVesting -= amountRemaining; // Reduces the allocation", "", "        // Tell everyone a claim has been revoked.", "        emit ClaimRevoked(_recipient, amountRemaining, uint40(block.timestamp), _claim);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function changeFor(", "    uint256 _projectId,", "    IJBToken _token,", "    address _newOwner", "  ) external override onlyController(_projectId) returns (IJBToken oldToken) {", "    // Can't remove the project's token if the project requires claiming tokens.", "    if (_token == IJBToken(address(0)) && requireClaimFor[_projectId])", "      revert CANT_REMOVE_TOKEN_IF_ITS_REQUIRED();", "", "    // Can't change to a token already in use.", "    if (projectOf[_token] != 0) revert TOKEN_ALREADY_IN_USE();", "", "    // Can't change to a token that doesn't use 18 decimals.", "    if (_token != IJBToken(address(0)) && _token.decimals() != 18)", "      revert TOKENS_MUST_HAVE_18_DECIMALS();", "", "    // Get a reference to the current token for the project.", "    oldToken = tokenOf[_projectId];", "", "    // Store the new token.", "    tokenOf[_projectId] = _token;", "", "    // Store the project for the new token if the new token isn't the zero address.", "    if (_token != IJBToken(address(0))) projectOf[_token] = _projectId;", "", "    // Reset the project for the old token if it isn't the zero address.", "    if (oldToken != IJBToken(address(0))) projectOf[oldToken] = 0;", "", "    // If there's a current token and a new owner was provided, transfer ownership of the old token to the new owner.", "    if (_newOwner != address(0) && oldToken != IJBToken(address(0)))", "      oldToken.transferOwnership(_projectId, _newOwner);", "", "    emit Change(_projectId, _token, oldToken, _newOwner, msg.sender);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["    function merge(uint256 _from, uint256 _to) external {", "        require(attachments[_from] == 0 && !voted[_from], 'attached');", "        require(_from != _to);", "        require(_isApprovedOrOwner(msg.sender, _from));", "        require(_isApprovedOrOwner(msg.sender, _to));", "", "        LockedBalance memory _locked0 = locked[_from];", "        LockedBalance memory _locked1 = locked[_to];", "        uint256 value0 = uint256(int256(_locked0.amount));", "        uint256 end = _locked0.end >= _locked1.end ? _locked0.end : _locked1.end;", "", "        locked[_from] = LockedBalance(0, 0);", "        _checkpoint(_from, _locked0, LockedBalance(0, 0));", "        _burn(_from);", "        _deposit_for(_to, value0, end, _locked1, DepositType.MERGE_TYPE);", "    }"], "ner_tags": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function rebalanceUp(", "        RebalanceUpQuote memory quote", "    )", "        external", "        onlyRole(REBALANCE_DEFENDER_ROLE)", "        afterCooldownPeriod", "        returns (uint256 xETHReceived)", "    {", "        if (quote.lpBurn == 0) revert ZeroValueProvided();", "", "        bool isRebalanceUp = preRebalanceCheck();", "        if (!isRebalanceUp) revert RebalanceUpNotAllowed();", "", "        if (quote.lpBurn > rebalanceUpCap) revert RebalanceUpCapExceeded();", "", "        quote = bestRebalanceUpQuote(quote);", "", "        uint256 amoLpBal = cvxStaker.stakedBalance();", "", "        // if (amoLpBal == 0 || quote.lpBurn > amoLpBal) revert LpBalanceTooLow();", "        if (quote.lpBurn > amoLpBal) revert LpBalanceTooLow();", "", "        cvxStaker.withdrawAndUnwrap(quote.lpBurn, false, address(this));", "", "        xETHReceived = curvePool.remove_liquidity_one_coin(", "            quote.lpBurn,", "            int128(int(xETHIndex)),", "            quote.min_xETHReceived", "        );", "", "        xETH.burnShares(xETHReceived);", "", "        emit RebalanceUpFinished(quote, xETHReceived);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function deposit(", "    uint256 assets,", "    address receiver", "  ) public virtual returns (uint256 shares) {", "    // Check for rounding error since we round down in previewDeposit.", "    require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");", "", "    require(shares > minDepositAmount(), \"VALUE_TOO_SMALL\");", "    // Need to transfer before minting or ERC777s could reenter.", "    ERC20(asset()).safeTransferFrom(msg.sender, address(this), assets);", "", "    _mint(receiver, shares);", "", "    emit Deposit(msg.sender, receiver, assets, shares);", "", "    afterDeposit(assets, shares);", "  }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function createCollectionFor(", "        bytes32 _merkleRoot,", "        address _controller,", "        address[] memory _plugins,", "        bytes4[] memory _selectors", "    ) public returns (address vault, address token) {", "        token = fNFTImplementation.clone(", "            abi.encodePacked(_controller, address(this))", "        );", "        vault = _deployVault(_merkleRoot, token, _plugins, _selectors);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function redeem(uint256 amount) external notFrozen {", "        require(amount > 0, \"Cannot redeem zero\");", "", "        // == Refresh ==", "        main.assetRegistry().refresh();", "", "        // == Checks and Effects ==", "        address redeemer = _msgSender();", "        require(balanceOf(redeemer) >= amount, \"not enough RToken\");", "        // Allow redemption during IFFY + UNPRICED", "        require(basketHandler.status() != CollateralStatus.DISABLED, \"collateral default\");", "", "        // Failure to melt results in a lower redemption price, so we can allow it when paused", "        // solhint-disable-next-line no-empty-blocks", "        try main.furnace().melt() {} catch {}", "", "        uint192 basketsNeeded_ = basketsNeeded; // gas optimization", "", "        // ==== Get basket redemption ====", "        // i.e, set (erc20s, amounts) = basketHandler.quote(amount * basketsNeeded / totalSupply)", "", "        // D18{BU} = D18{BU} * {qRTok} / {qRTok}", "        // downcast is safe: amount < totalSupply and basketsNeeded_ < 1e57 < 2^190 (just barely)", "        uint256 supply = totalSupply();", "        uint192 baskets = uint192(mulDiv256(basketsNeeded_, amount, supply));", "        emit Redemption(redeemer, amount, baskets);", "", "        (address[] memory erc20s, uint256[] memory amounts) = basketHandler.quote(baskets, FLOOR);", "", "        // ==== Prorate redemption ====", "        // i.e, set amounts = min(amounts, balances * amount / totalSupply)", "        //   where balances[i] = erc20s[i].balanceOf(this)", "", "        uint256 erc20length = erc20s.length;", "", "        // D18{1} = D18 * {qRTok} / {qRTok}", "        // downcast is safe: amount <= balanceOf(redeemer) <= totalSupply(), so prorate < 1e18", "        uint192 prorate = uint192((FIX_ONE_256 * amount) / supply);", "", "        // Bound each withdrawal by the prorata share, in case we're currently under-capitalized", "        for (uint256 i = 0; i < erc20length; ++i) {", "            // {qTok} = D18{1} * {qTok} / D18", "            uint256 prorata = (prorate *", "                IERC20Upgradeable(erc20s[i]).balanceOf(address(backingManager))) / FIX_ONE;", "            if (prorata < amounts[i]) amounts[i] = prorata;", "        }", "", "        // Revert if redemption exceeds battery capacity", "        battery.discharge(supply, amount); // reverts on over-redemption", "", "        basketsNeeded = basketsNeeded_ - baskets;", "        emit BasketsNeededChanged(basketsNeeded_, basketsNeeded);", "", "        // == Interactions ==", "        // Accept and burn RToken", "        _burn(redeemer, amount);", "", "        bool allZero = true;", "        for (uint256 i = 0; i < erc20length; ++i) {", "            if (amounts[i] == 0) continue;", "            if (allZero) allZero = false;", "", "            // Send withdrawal", "            IERC20Upgradeable(erc20s[i]).safeTransferFrom(", "                address(backingManager),", "                redeemer,", "                amounts[i]", "            );", "        }", "", "        if (allZero) revert(\"Empty redemption\");", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function withdrawRemainingTokens(address to_) public override onlyOwner {", "        super.withdrawRemainingTokens(to_);", "        IERC1155(rewardToken).safeTransferFrom(", "            address(this),", "            to_,", "            rewardAmountInWeiOrTokenId,", "            IERC1155(rewardToken).balanceOf(address(this), rewardAmountInWeiOrTokenId),", "            '0x00'", "        );", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["    function stake() external payable {", "        require(pauseStaking == false, \"staking is paused\");", "        require(msg.value >= minAmount, \"amount too low\");", "        require(msg.value <= maxAmount, \"amount too high\");", "", "        uint256 underlyingValue = 0;", "", "        // Getting underlying value in terms of ETH for each derivative", "        for (uint i = 0; i < derivativeCount; i++)", "            underlyingValue +=", "                (derivatives[i].ethPerDerivative(derivatives[i].balance()) *", "                    derivatives[i].balance()) /", "                10 ** 18;", "", "        uint256 totalSupply = totalSupply();", "        uint256 preDepositPrice; // Price of safETH in regards to ETH", "        if (totalSupply == 0)", "            preDepositPrice = 10 ** 18; // initializes with a price of 1", "        else preDepositPrice = (10 ** 18 * underlyingValue) / totalSupply;", "", "        uint256 totalStakeValueEth = 0; // total amount of derivatives worth of ETH in system", "        for (uint i = 0; i < derivativeCount; i++) {", "            uint256 weight = weights[i];", "            IDerivative derivative = derivatives[i];", "            if (weight == 0) continue;", "            uint256 ethAmount = (msg.value * weight) / totalWeight;", "", "            // This is slightly less than ethAmount because slippage", "            uint256 depositAmount = derivative.deposit{value: ethAmount}();", "            uint derivativeReceivedEthValue = (derivative.ethPerDerivative(", "                depositAmount", "            ) * depositAmount) / 10 ** 18;", "            totalStakeValueEth += derivativeReceivedEthValue;", "        }", "        // mintAmount represents a percentage of the total assets in the system", "        uint256 mintAmount = (totalStakeValueEth * 10 ** 18) / preDepositPrice;", "        _mint(msg.sender, mintAmount);", "        emit Staked(msg.sender, msg.value, mintAmount);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["    function _qTokenSymbol(", "        address _quantConfig,", "        address _underlyingAsset,", "        address _strikeAsset,", "        uint256 _strikePrice,", "        uint256 _expiryTime,", "        bool _isCall", "    ) internal view virtual returns (string memory tokenSymbol) {", "        string memory underlying = _assetSymbol(_quantConfig, _underlyingAsset);", "        string memory displayStrikePrice = _displayedStrikePrice(", "            _strikePrice,", "            _strikeAsset", "        );", "", "        // convert the expiry to a readable string", "        (uint256 year, uint256 month, uint256 day) = DateTime.timestampToDate(", "            _expiryTime", "        );", "", "        // get option type string", "        (string memory typeSymbol, ) = _getOptionType(_isCall);", "", "        // get option month string", "        (string memory monthSymbol, ) = _getMonth(month);", "", "        /// concatenated symbol string", "        tokenSymbol = string(", "            abi.encodePacked(", "                \"ROLLA\",", "                \"-\",", "                underlying,", "                \"-\",", "                _uintToChars(day),", "                monthSymbol,", "                _uintToChars(year),", "                \"-\",", "                displayStrikePrice,", "                \"-\",", "                typeSymbol", "            )", "        );", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": ["    function release(", "        uint _id,", "        address _releaser", "    ) external onlyManager() returns(uint amount, uint lockAmount, address asset, address _owner) {", "        Bond memory bond = idToBond(_id);", "        require(bond.expired, \"!expire\");", "        if (_releaser != bond.owner) {", "            unchecked {", "                require(bond.expireEpoch + 7 < epoch[bond.asset], \"Bond owner priority\");", "            }", "        }", "        amount = bond.amount;", "        unchecked {", "            totalShares[bond.asset] -= bond.shares;", "            (uint256 _claimAmount,) = claim(_id, bond.owner);", "            amount += _claimAmount;", "        }", "        asset = bond.asset;", "        lockAmount = bond.amount;", "        _owner = bond.owner;", "        _burn(_id);", "        emit Release(asset, lockAmount, _owner, _id);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["   function denyMinter(address _minter, address[] calldata _helpers, string calldata _message) override external {", "      if (block.timestamp > minters[_minter]) revert TooLate();", "      reserve.checkQualified(msg.sender, _helpers);", "      delete minters[_minter];", "      emit MinterDenied(_minter, _message);", "   }"], "ner_tags": [1, 0, 0, 0, 0, 0]}
{"tokens": ["    function vestedAmount(address token, uint64 timestamp)", "        public", "        view", "        returns (uint256)", "    {", "        return", "            _vestingSchedule(", "                IERC20(token).balanceOf(address(this)) + released(token),", "                timestamp", "            );", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function unregister(IAsset asset) external governance {", "        require(_erc20s.contains(address(asset.erc20())), \"no asset to unregister\");", "        require(assets[asset.erc20()] == asset, \"asset not found\");", "        uint192 quantity = basketHandler.quantity(asset.erc20());", "", "        _erc20s.remove(address(asset.erc20()));", "        assets[asset.erc20()] = IAsset(address(0));", "        emit AssetUnregistered(asset.erc20(), asset);", "", "        if (quantity > 0) basketHandler.disableBasket();", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function processWithdrawals() external {", "        uint reserve = reserveToken.balanceOf(address(this));", "        require(reserve >= withdrawals[start].amount, 'Cannot process withdrawals at this time: Not enough balance');", "        uint i = start;", "        while (i < withdrawals.length && (i - start) <= maxWithdrawalProcesses) {", "            Withdrawal memory withdrawal = withdrawals[i];", "            if (reserve < withdrawal.amount) {", "                break;", "            }", "            reserveToken.safeTransfer(withdrawal.usr, withdrawal.amount);", "            reserve -= withdrawal.amount;", "            i += 1;", "        }", "        start = i;", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _swap(", "        uint256 amountIn,", "        uint256 amountOut,", "        address tokenIn,", "        address tokenOut,", "        address to,", "        bool mint,", "        Collateral storage collatInfo,", "        bytes memory permitData", "    ) internal {", "        if (amountIn > 0 && amountOut > 0) {", "            TransmuterStorage storage ts = s.transmuterStorage();", "            if (mint) {", "                uint128 changeAmount = (amountOut.mulDiv(BASE_27, ts.normalizer, Math.Rounding.Up)).toUint128();", "                // The amount of stablecoins issued from a collateral are not stored as absolute variables, but", "                // as variables normalized by a `normalizer`", "                collatInfo.normalizedStables += uint216(changeAmount);", "                ts.normalizedStables += changeAmount;", "                if (permitData.length > 0) {", "                    PERMIT_2.functionCall(permitData);", "                } else if (collatInfo.isManaged > 0)", "                    IERC20(tokenIn).safeTransferFrom(", "                        msg.sender,", "                        LibManager.transferRecipient(collatInfo.managerData.config),", "                        amountIn", "                    );", "                else IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);", "                if (collatInfo.isManaged > 0) {", "                    LibManager.invest(amountIn, collatInfo.managerData.config);", "                }", "                IAgToken(tokenOut).mint(to, amountOut);", "            } else {", "                if (collatInfo.onlyWhitelisted > 0 && !LibWhitelist.checkWhitelist(collatInfo.whitelistData, to))", "                    revert NotWhitelisted();", "                uint128 changeAmount = ((amountIn * BASE_27) / ts.normalizer).toUint128();", "                // This will underflow when the system is trying to burn more stablecoins than what has been issued", "                // from this collateral", "                collatInfo.normalizedStables -= uint216(changeAmount);", "                ts.normalizedStables -= changeAmount;", "                IAgToken(tokenIn).burnSelf(amountIn, msg.sender);", "                if (collatInfo.isManaged > 0)", "                    LibManager.release(tokenOut, to, amountOut, collatInfo.managerData.config);", "                else IERC20(tokenOut).safeTransfer(to, amountOut);", "            }", "            emit Swap(tokenIn, tokenOut, amountIn, amountOut, msg.sender, to);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function depositGlp(", "        address token,", "        uint256 tokenAmount,", "        uint256 minUsdg,", "        uint256 minGlp,", "        address receiver", "    )", "        external", "        whenNotPaused", "        nonReentrant", "        returns (", "            uint256,", "            uint256,", "            uint256", "        )", "    {", "        if (token == address(0)) revert ZeroAddress();", "        if (!gmxVault.whitelistedTokens(token)) revert InvalidToken(token);", "", "        return _depositGlp(token, tokenAmount, minUsdg, minGlp, receiver);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function collateralShortfall(ComponentCache memory components, uint192 basketsTop)", "        private", "        view", "        returns (uint192 shortfall)", "    {", "        IERC20[] memory basketERC20s = components.bh.basketTokens();", "        uint256 len = basketERC20s.length;", "", "        // accumulate shortfall", "        for (uint256 i = 0; i < len; ++i) {", "            ICollateral coll = components.reg.toColl(basketERC20s[i]);", "", "            // {tok} = {BU} * {tok/BU}", "            // needed: quantity of erc20 needed for `basketsTop` BUs", "            uint192 needed = basketsTop.mul(components.bh.quantity(basketERC20s[i]), CEIL); // {tok}", "", "            // held: quantity of erc20 owned by the bm (BackingManager)", "            uint192 held = coll.bal(address(components.bm)); // {tok}", "", "            if (held.lt(needed)) {", "                // use the high estimate because it is the worst-case cost of acquisition", "                (, uint192 priceHigh) = coll.price(); // {UoA/tok}", "", "                // {UoA} = {UoA} + ({tok} - {tok}) * {UoA/tok}", "                shortfall = shortfall.plus(needed.minus(held).mul(priceHigh, CEIL));", "            }", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    modifier onlyByOwnGov() {", "        require(msg.sender == timelock_address || msg.sender == owner, \"Not owner or timelock\");", "        _;", "    }"], "ner_tags": [0, 1, 0, 0]}
{"tokens": ["    function setDefaultRoyalty(", "        address receiver,", "        uint96 feeNumerator", "    ) public onlyRole(DEFAULT_ADMIN_ROLE) {", "        _setDefaultRoyalty(receiver, feeNumerator);", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1]}
{"tokens": ["    function convertToShares(uint256 assets) public view override returns (uint256 shares) {", "        uint256 supply = totalSupply();", "        if (supply == 0) {", "            // Scales assets by the value of a single unit of fCash", "            uint256 unitfCashValue = _getPresentValue(uint256(Constants.INTERNAL_TOKEN_PRECISION));", "            return (assets * uint256(Constants.INTERNAL_TOKEN_PRECISION)) / unitfCashValue;", "        }", "", "        return (assets * totalSupply()) / totalAssets();", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function withdraw(uint256 _amount) public onlyOwner {", "        require(address(vault) != address(0), 'no vault');", "        require(payable(vault).send(_amount));", "    }"], "ner_tags": [0, 0, 1, 0]}
{"tokens": ["  function _payoutTokens(address[] memory tokenAddresses) private {", "    address payable[] memory addresses = _getPayoutAddresses();", "    uint256[] memory bps = _getPayoutBps();", "    ERC20 erc20;", "    uint256 balance;", "    uint256 sending;", "    for (uint256 t = 0; t < tokenAddresses.length; t++) {", "      erc20 = ERC20(tokenAddresses[t]);", "      balance = erc20.balanceOf(address(this));", "      require(balance > 10000, \"PA1D: Not enough tokens to transfer\");", "      // uint256 sent;", "      for (uint256 i = 0; i < addresses.length; i++) {", "        sending = ((bps[i] * balance) / 10000);", "        require(erc20.transfer(addresses[i], sending), \"PA1D: Couldn't transfer token\");", "        // sent = sent + sending;", "      }", "    }", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["    function withdrawETHForKnot(address _recipient, bytes calldata _blsPublicKeyOfKnot) external {", "        require(_recipient != address(0), \"Zero address\");", "        require(isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, \"BLS public key has already withdrawn or not a part of LSD network\");", "", "        address associatedSmartWallet = smartWalletOfKnot[_blsPublicKeyOfKnot];", "        require(smartWalletOfNodeRunner[msg.sender] == associatedSmartWallet, \"Not the node runner for the smart wallet \");", "        require(isNodeRunnerBanned(nodeRunnerOfSmartWallet[associatedSmartWallet]) == false, \"Node runner is banned from LSD network\");", "        require(associatedSmartWallet.balance >= 4 ether, \"Insufficient balance\");", "        require(", "            getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,", "            \"Initials not registered\"", "        );", "", "        // refund 4 ether from smart wallet to node runner's EOA", "        IOwnableSmartWallet(associatedSmartWallet).rawExecute(", "            _recipient,", "            \"\",", "            4 ether", "        );", "", "        // update the mapping", "        bannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;", "", "        emit ETHWithdrawnFromSmartWallet(associatedSmartWallet, _blsPublicKeyOfKnot, msg.sender);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["    function startBridgeTokensViaCBridge(LiFiData memory _lifiData, CBridgeData calldata _cBridgeData) public payable {", "        if (_cBridgeData.token != address(0)) {", "            uint256 _fromTokenBalance = LibAsset.getOwnBalance(_cBridgeData.token);", "", "            LibAsset.transferFromERC20(_cBridgeData.token, msg.sender, address(this), _cBridgeData.amount);", "", "            require(", "                LibAsset.getOwnBalance(_cBridgeData.token) - _fromTokenBalance == _cBridgeData.amount,", "                \"ERR_INVALID_AMOUNT\"", "            );", "        } else {", "            require(msg.value >= _cBridgeData.amount, \"ERR_INVALID_AMOUNT\");", "        }", "", "        _startBridge(_cBridgeData);", "", "        emit LiFiTransferStarted(", "            _lifiData.transactionId,", "            _lifiData.integrator,", "            _lifiData.referrer,", "            _lifiData.sendingAssetId,", "            _lifiData.receivingAssetId,", "            _lifiData.receiver,", "            _lifiData.amount,", "            _lifiData.destinationChainId,", "            block.timestamp", "        );", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function timeToTokens(uint256 _amount, uint256 _lock_time) internal pure returns (uint256){", "        uint256 week_time = 1 weeks;", "        uint256 max_lock = 52 weeks;", "", "        require(_lock_time >= week_time, \"dMute::Lock: INSUFFICIENT_TIME_PARAM\");", "        require(_lock_time <= max_lock, \"dMute::Lock: INSUFFICIENT_TIME_PARAM\");", "", "        // amount * % of time locked up from min to max", "        uint256 base_tokens = _amount.mul(_lock_time.mul(10**18).div(max_lock)).div(10**18);", "        // apply % min max bonus", "        //uint256 boosted_tokens = base_tokens.mul(lockBonus(lock_time)).div(10**18);", "", "        return base_tokens;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function rescueETH(address to) external onlyOwner {", "        uint256 withdrawAmount = address(this).balance - 1;", "        if (withdrawAmount == 0) revert InsufficientAmount();", "        _transferETH(to, withdrawAmount);", "    }"], "ner_tags": [1, 0, 0, 0, 0]}
{"tokens": ["    function executeMetaTransaction(", "        MetaAction memory metaAction,", "        bytes32 r,", "        bytes32 s,", "        uint8 v", "    ) external payable returns (bytes memory) {", "        require(", "            _verify(metaAction.from, metaAction, r, s, v),", "            \"signer and signature don't match\"", "        );", "", "        uint256 currentNonce = _nonces[metaAction.from];", "", "        // intentionally allow this to overflow to save gas,", "        // and it's impossible for someone to do 2 ^ 256 - 1 meta txs", "        unchecked {", "            _nonces[metaAction.from] = currentNonce + 1;", "        }", "", "        // Append the metaAction.from at the end so that it can be extracted later", "        // from the calling context (see _msgSender() below)", "        (bool success, bytes memory returnData) = address(this).call(", "            abi.encodePacked(", "                abi.encodeWithSelector(", "                    IController(address(this)).operate.selector,", "                    metaAction.actions", "                ),", "                metaAction.from", "            )", "        );", "", "        require(success, \"unsuccessful function call\");", "        emit MetaTransactionExecuted(", "            metaAction.from,", "            payable(msg.sender),", "            currentNonce", "        );", "        return returnData;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function liquidate(address user, uint repaidDebt) public {", "        require(repaidDebt > 0, \"Must repay positive debt\");", "        uint debt = debts[user];", "        require(getCreditLimitInternal(user) < debt, \"User debt is healthy\");", "        require(repaidDebt <= debt * liquidationFactorBps / 10000, \"Exceeded liquidation factor\");", "        uint price = oracle.getPrice(address(collateral), collateralFactorBps);", "        uint liquidatorReward = repaidDebt * 1 ether / price;", "        liquidatorReward += liquidatorReward * liquidationIncentiveBps / 10000;", "        debts[user] -= repaidDebt;", "        totalDebt -= repaidDebt;", "        dbr.onRepay(user, repaidDebt);", "        dola.transferFrom(msg.sender, address(this), repaidDebt);", "        IEscrow escrow = predictEscrow(user);", "        escrow.pay(msg.sender, liquidatorReward);", "        if(liquidationFeeBps > 0) {", "            uint liquidationFee = repaidDebt * 1 ether / price * liquidationFeeBps / 10000;", "            if(escrow.balance() >= liquidationFee) {", "                escrow.pay(gov, liquidationFee);", "            }", "        }", "        emit Liquidate(user, msg.sender, repaidDebt, liquidatorReward);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function redeemCollateral(", "        address _collateral,", "        address _redeemer,", "        uint _LUSDamount,", "        address _firstRedemptionHint,", "        address _upperPartialRedemptionHint,", "        address _lowerPartialRedemptionHint,", "        uint _partialRedemptionHintNICR,", "        uint _maxIterations,", "        uint _maxFeePercentage", "    )", "        external override", "    {", "        _requireCallerIsTroveManager();", "        _requireValidCollateralAddress(_collateral);", "        RedemptionTotals memory totals;", "", "        _requireValidMaxFeePercentage(_maxFeePercentage);", "        _requireAfterBootstrapPeriod();", "        totals.price = priceFeed.fetchPrice(_collateral);", "        ICollateralConfig collateralConfigCached = collateralConfig;", "        totals.collDecimals = collateralConfigCached.getCollateralDecimals(_collateral);", "        totals.collMCR = collateralConfigCached.getCollateralMCR(_collateral);", "        _requireTCRoverMCR(_collateral, totals.price, totals.collDecimals, totals.collMCR);", "        _requireAmountGreaterThanZero(_LUSDamount);", "        _requireLUSDBalanceCoversRedemption(lusdToken, _redeemer, _LUSDamount);", "", "        totals.totalLUSDSupplyAtStart = getEntireSystemDebt(_collateral);", "        // Confirm redeemer's balance is less than total LUSD supply", "        assert(lusdToken.balanceOf(_redeemer) <= totals.totalLUSDSupplyAtStart);", "", "        totals.remainingLUSD = _LUSDamount;", "", "        ISortedTroves sortedTrovesCached = sortedTroves;", "        if (_isValidFirstRedemptionHint(", "            sortedTrovesCached,", "            _collateral,", "            _firstRedemptionHint,", "            totals.price,", "            totals.collMCR)", "        ) {", "            totals.currentBorrower = _firstRedemptionHint;", "        } else {", "            totals.currentBorrower = sortedTrovesCached.getLast(_collateral);", "            // Find the first trove with ICR >= MCR", "            while (totals.currentBorrower != address(0) &&", "                troveManager.getCurrentICR(totals.currentBorrower, _collateral, totals.price) < totals.collMCR) ", "            {", "                totals.currentBorrower = sortedTrovesCached.getPrev(_collateral, totals.currentBorrower);", "            }", "        }", "", "        // Loop through the Troves starting from the one with lowest collateral ratio until _amount of LUSD is exchanged for collateral", "        if (_maxIterations == 0) { _maxIterations = uint(-1); }", "        while (totals.currentBorrower != address(0) && totals.remainingLUSD > 0 && _maxIterations > 0) {", "            _maxIterations--;", "            // Save the address of the Trove preceding the current one, before potentially modifying the list", "            address nextUserToCheck = sortedTrovesCached.getPrev(_collateral, totals.currentBorrower);", "", "            troveManager.applyPendingRewards(totals.currentBorrower, _collateral);", "", "            SingleRedemptionValues memory singleRedemption = _redeemCollateralFromTrove(", "                totals.currentBorrower,", "                _collateral,", "                totals.remainingLUSD,", "                totals.price,", "                _upperPartialRedemptionHint,", "                _lowerPartialRedemptionHint,", "                _partialRedemptionHintNICR,", "                collateralConfigCached", "            );", "", "            if (singleRedemption.cancelledPartial) break; // Partial redemption was cancelled (out-of-date hint, or new net debt < minimum), therefore we could not redeem from the last Trove", "", "            totals.totalLUSDToRedeem  = totals.totalLUSDToRedeem.add(singleRedemption.LUSDLot);", "            totals.totalCollateralDrawn = totals.totalCollateralDrawn.add(singleRedemption.collLot);", "", "            totals.remainingLUSD = totals.remainingLUSD.sub(singleRedemption.LUSDLot);", "            totals.currentBorrower = nextUserToCheck;", "        }", "        require(totals.totalCollateralDrawn > 0);", "", "        // Decay the baseRate due to time passed, and then increase it according to the size of this redemption.", "        // Use the saved total LUSD supply value, from before it was reduced by the redemption.", "        troveManager.updateBaseRateFromRedemption(", "            totals.totalCollateralDrawn,", "            totals.price,", "            totals.collDecimals,", "            totals.totalLUSDSupplyAtStart", "        );", "", "        // Calculate the ETH fee", "        totals.collateralFee = troveManager.getRedemptionFee(totals.totalCollateralDrawn);", "", "        _requireUserAcceptsFee(totals.collateralFee, totals.totalCollateralDrawn, _maxFeePercentage);", "", "        // Send the collateral fee to the LQTY staking contract", "        activePool.sendCollateral(_collateral, address(lqtyStaking), totals.collateralFee);", "        lqtyStaking.increaseF_Collateral(_collateral, totals.collateralFee);", "", "        totals.collateralToSendToRedeemer = totals.totalCollateralDrawn.sub(totals.collateralFee);", "", "        // Burn the total LUSD that is cancelled with debt, and send the redeemed collateral to _redeemer", "        troveManager.burnLUSDAndEmitRedemptionEvent(", "            _redeemer,", "            _collateral,", "            _LUSDamount,", "            totals.totalLUSDToRedeem,", "            totals.totalCollateralDrawn,", "            totals.collateralFee", "        );", "", "        // Update Active Pool LUSD, and send ETH to account", "        activePool.decreaseLUSDDebt(_collateral, totals.totalLUSDToRedeem);", "        activePool.sendCollateral(_collateral, _redeemer, totals.collateralToSendToRedeemer);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function deposit(uint _amount) external {", "        settlePendingObligation();", "        // we want to protect new LPs, when the insurance fund is in deficit", "        require(pendingObligation == 0, \"IF.deposit.pending_obligations\");", "", "        uint _pool = balance();", "        uint _totalSupply = totalSupply();", "        if (_totalSupply == 0 && _pool > 0) { // trading fee accumulated while there were no IF LPs", "            vusd.safeTransfer(governance, _pool);", "            _pool = 0;", "        }", "", "        vusd.safeTransferFrom(msg.sender, address(this), _amount);", "        uint shares = 0;", "        if (_pool == 0) {", "            shares = _amount;", "        } else {", "            shares = _amount * _totalSupply / _pool;", "        }", "        _mint(msg.sender, shares);", "        emit FundsAdded(msg.sender, _amount, block.timestamp);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function setSpreads(uint256 cushionSpread_, uint256 wallSpread_) external permissioned {", "        // Confirm spreads are within allowed values", "        if (", "            wallSpread_ > 10000 ||", "            wallSpread_ < 100 ||", "            cushionSpread_ > 10000 ||", "            cushionSpread_ < 100 ||", "            cushionSpread_ > wallSpread_", "        ) revert RANGE_InvalidParams();", "", "        // Set spreads", "        _range.wall.spread = wallSpread_;", "        _range.cushion.spread = cushionSpread_;", "", "        emit SpreadsChanged(wallSpread_, cushionSpread_);", "    }"], "ner_tags": [0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function vest(", "        address recipient,", "        uint256 _amount,", "        uint256 _unlockBegin", "    ) external {", "        require(msg.sender == vault, \"StakedCitadelVester: only xCTDL vault\");", "        require(_amount > 0, \"StakedCitadelVester: cannot vest 0\");", "", "        vesting[recipient].lockedAmounts =", "            vesting[recipient].lockedAmounts +", "            _amount;", "        vesting[recipient].unlockBegin = _unlockBegin;", "        vesting[recipient].unlockEnd = _unlockBegin + vestingDuration;", "", "        emit Vest(", "            recipient,", "            vesting[recipient].lockedAmounts,", "            _unlockBegin,", "            vesting[recipient].unlockEnd", "        );", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function initialize(address[] calldata _assets, uint8[] calldata _weights) external {", "        require(msg.sender == factory, \"ManagedIndex: FORBIDDEN\");", "", "        for (uint i; i < _assets.length; ++i) {", "            address asset = _assets[i];", "            uint8 weight = _weights[i];", "", "            weightOf[asset] = weight;", "            assets.add(asset);", "", "            emit UpdateAnatomy(asset, weight);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["  function create (", "    uint8 p,", "    address u,", "    uint256 m,", "    address c,", "    address sw,", "    string memory n,", "    string memory s,", "    uint8 d", "  ) external authorized(marketPlace) returns (address, address) {", "    address zct = address(new ZcToken(p, u, m, c, marketPlace, n, s, d));", "    address tracker = address(new VaultTracker(p, m, c, sw));", "", "    return (zct, tracker);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["    function _computeUpdate() internal view returns (uint256 newAccRewardsPerShare, uint256 currentBalance) {", "        currentBalance = vault.balanceOfJPEG() + jpeg.balanceOf(address(this));", "        uint256 newRewards = currentBalance - previousBalance;", "", "        newAccRewardsPerShare = accRewardPerShare + newRewards * 1e36 / totalStaked;", "    }"], "ner_tags": [0, 0, 1, 0, 0, 0]}
{"tokens": ["    function removeLiquidity(uint256 _steps, uint256 _burningLPs) external onlyGuardian {", "        uint256 removingLiquidity = _steps * step;", "        uint256[2] memory amounts = [removingLiquidity, removingLiquidity];", "        usdm3crv.remove_liquidity(_burningLPs, amounts);", "    }"], "ner_tags": [1, 0, 0, 0, 0]}
{"tokens": ["    function piecewiseLinear(uint64 x, uint64[] memory xArray, int64[] memory yArray) internal pure returns (int64) {", "        uint256 indexLowerBound = findLowerBound(true, xArray, 1, x);", "        if (indexLowerBound == xArray.length - 1) return yArray[xArray.length - 1];", "        return", "            yArray[indexLowerBound] +", "            ((yArray[indexLowerBound + 1] - yArray[indexLowerBound]) * int64(x - xArray[indexLowerBound])) /", "            int64(xArray[indexLowerBound + 1] - xArray[indexLowerBound]);", "    }"], "ner_tags": [0, 0, 0, 1, 1, 1, 1, 0]}
{"tokens": ["    function depositNative(", "        address receiver,", "        uint256 toChainId,", "        string memory tag", "    ) external payable whenNotPaused nonReentrant {", "        require(", "            tokenManager.getDepositConfig(toChainId, NATIVE).min <= msg.value &&", "                tokenManager.getDepositConfig(toChainId, NATIVE).max >= msg.value,", "            \"Deposit amount not in Cap limit\"", "        );", "        require(receiver != address(0), \"Receiver address cannot be 0\");", "        require(msg.value != 0, \"Amount cannot be 0\");", "", "        uint256 rewardAmount = getRewardAmount(msg.value, NATIVE);", "        if (rewardAmount != 0) {", "            incentivePool[NATIVE] = incentivePool[NATIVE] - rewardAmount;", "        }", "        liquidityProviders.increaseCurrentLiquidity(NATIVE, msg.value);", "        emit Deposit(_msgSender(), NATIVE, receiver, toChainId, msg.value + rewardAmount, rewardAmount, tag);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function getVotes(address _account, uint256 _timestamp) public view returns (uint256) {", "        return settings.token.getPastVotes(_account, _timestamp);", "    }"], "ner_tags": [0, 1, 0]}
{"tokens": ["    function _notifyReward(address _rewardsToken, uint256 _reward) internal updateReward(address(0)) {", "        RewardData storage rdata = rewardData[_rewardsToken];", "", "        if (block.timestamp >= rdata.periodFinish) {", "            rdata.rewardRate = _reward.div(rewardsDuration).to96();", "        } else {", "            uint256 remaining = uint256(rdata.periodFinish).sub(block.timestamp);", "            uint256 leftover = remaining.mul(rdata.rewardRate);", "            rdata.rewardRate = _reward.add(leftover).div(rewardsDuration).to96();", "        }", "", "        rdata.lastUpdateTime = block.timestamp.to32();", "        rdata.periodFinish = block.timestamp.add(rewardsDuration).to32();", "", "        emit RewardAdded(_rewardsToken, _reward);", "    }"], "ner_tags": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function nftRemove(uint256 lpTokenAmount, uint256 minBaseTokenOutputAmount, uint256[] calldata tokenIds)", "        public", "        returns (uint256 baseTokenOutputAmount, uint256 fractionalTokenOutputAmount)", "    {", "        // remove liquidity and send fractional tokens and base tokens to sender", "        (baseTokenOutputAmount, fractionalTokenOutputAmount) =", "            remove(lpTokenAmount, minBaseTokenOutputAmount, tokenIds.length * ONE);", "", "        // unwrap the fractional tokens into NFTs and send to sender", "        unwrap(tokenIds);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function validateListing(address _consideration, Order[] memory _orders) external {", "        uint256 ordersLength = _orders.length;", "        unchecked {", "            for (uint256 i; i < ordersLength; ++i) {", "                uint256 offerLength = _orders[i].parameters.offer.length;", "                for (uint256 j; j < offerLength; ++j) {", "                    OfferItem memory offer = _orders[i].parameters.offer[j];", "                    address token = offer.token;", "                    ItemType itemType = offer.itemType;", "                    if (itemType == ItemType.ERC721)", "                        IERC721(token).setApprovalForAll(conduit, true);", "                    if (itemType == ItemType.ERC1155)", "                        IERC1155(token).setApprovalForAll(conduit, true);", "                    if (itemType == ItemType.ERC20)", "                        IERC20(token).approve(conduit, type(uint256).max);", "                }", "            }", "        }", "        // Validates the order on-chain so no signature is required to fill it", "        assert(ConsiderationInterface(_consideration).validate(_orders));", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _redeemMaturedPositions(ISetToken _setToken)", "    internal", "    {", "        ISetToken.Position[] memory positions = _setToken.getPositions();", "        uint positionsLength = positions.length;", "", "        bool toUnderlying = redeemToUnderlying[_setToken];", "", "        for(uint256 i = 0; i < positionsLength; i++) {", "            // Check that the given position is an equity position", "            if(positions[i].unit > 0) {", "                address component = positions[i].component;", "                if(_isWrappedFCash(component)) {", "                    IWrappedfCashComplete fCashPosition = IWrappedfCashComplete(component);", "                    if(fCashPosition.hasMatured()) {", "                        (IERC20 receiveToken,) = fCashPosition.getToken(toUnderlying);", "                        if(address(receiveToken) == ETH_ADDRESS) {", "                            receiveToken = weth;", "                        }", "                        uint256 fCashBalance = fCashPosition.balanceOf(address(_setToken));", "                        _redeemFCashPosition(_setToken, fCashPosition, receiveToken, fCashBalance, 0);", "                    }", "                }", "            }", "        }", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function createProfile(DataTypes.CreateProfileData calldata vars)", "        external", "        override", "        whenNotPaused", "        onlyWhitelistedProfileCreator", "    {", "        uint256 profileId = ++_profileCounter;", "        _mint(vars.to, profileId);", "        PublishingLogic.createProfile(", "            vars,", "            profileId,", "            _profileIdByHandleHash,", "            _profileById,", "            _followModuleWhitelisted", "        );", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function addLiquidity(uint256 ethAmount, uint256 btrflyAmount) internal {", "        uint256[2] memory amounts = [ethAmount, btrflyAmount];", "        uint256 expectedAmount = ICurveCryptoPool(CURVEPOOL).calc_token_amount(", "            amounts", "        );", "        uint256 minAmount = expectedAmount - ((expectedAmount * slippage) / 1000);", "", "        ICurveCryptoPool(CURVEPOOL).add_liquidity(amounts, minAmount);", "    }"], "ner_tags": [0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function _payment(", "    LienStorage storage s,", "    Stack[] memory activeStack,", "    uint8 position,", "    uint256 amount,", "    address payer", "  ) internal returns (Stack[] memory, uint256) {", "    Stack memory stack = activeStack[position];", "    uint256 lienId = stack.point.lienId;", "", "    if (s.lienMeta[lienId].atLiquidation) {", "      revert InvalidState(InvalidStates.COLLATERAL_AUCTION);", "    }", "    uint64 end = stack.point.end;", "    // Blocking off payments for a lien that has exceeded the lien.end to prevent repayment unless the msg.sender() is the AuctionHouse", "    if (block.timestamp >= end) {", "      revert InvalidLoanState();", "    }", "    uint256 owed = _getOwed(stack, block.timestamp);", "    address lienOwner = ownerOf(lienId);", "    bool isPublicVault = _isPublicVault(s, lienOwner);", "", "    address payee = _getPayee(s, lienId);", "", "    if (amount > owed) amount = owed;", "    if (isPublicVault) {", "      IPublicVault(lienOwner).beforePayment(", "        IPublicVault.BeforePaymentParams({", "          interestOwed: owed - stack.point.amount,", "          amount: stack.point.amount,", "          lienSlope: calculateSlope(stack)", "        })", "      );", "    }", "", "    //bring the point up to block.timestamp, compute the owed", "    stack.point.amount = owed.safeCastTo88();", "    stack.point.last = block.timestamp.safeCastTo40();", "", "    if (stack.point.amount > amount) {", "      stack.point.amount -= amount.safeCastTo88();", "      //      // slope does not need to be updated if paying off the rest, since we neutralize slope in beforePayment()", "      if (isPublicVault) {", "        IPublicVault(lienOwner).afterPayment(calculateSlope(stack));", "      }", "    } else {", "      amount = stack.point.amount;", "      if (isPublicVault) {", "        // since the openLiens count is only positive when there are liens that haven't been paid off", "        // that should be liquidated, this lien should not be counted anymore", "        IPublicVault(lienOwner).decreaseEpochLienCount(", "          IPublicVault(lienOwner).getLienEpoch(end)", "        );", "      }", "      delete s.lienMeta[lienId]; //full delete of point data for the lien", "      _burn(lienId);", "      activeStack = _removeStackPosition(activeStack, position);", "    }", "", "    s.TRANSFER_PROXY.tokenTransferFrom(stack.lien.token, payer, payee, amount);", "", "    emit Payment(lienId, amount);", "    return (activeStack, amount);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["    function bumpExchangeRate() public {", "        // Claim from pool", "        pools.claim(poolId);", "        // Bump exchange rate", "        uint balance = alcx.balanceOf(address(this));", "", "        if (balance > 0) {", "            exchangeRate += (balance * exchangeRatePrecision) / totalSupply;", "            emit ExchangeRateChange(exchangeRate);", "            // Restake", "            pools.deposit(poolId, balance);", "        }", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function executeLimitOrder(", "        uint _id, ", "        PriceData calldata _priceData,", "        bytes calldata _signature", "    ) ", "        external", "    {", "        unchecked {", "            _checkDelay(_id, true);", "            tradingExtension._checkGas();", "            if (tradingExtension.paused()) revert TradingPaused();", "            require(block.timestamp >= limitDelay[_id]);", "            IPosition.Trade memory trade = position.trades(_id);", "            uint _fee = _handleOpenFees(trade.asset, trade.margin*trade.leverage/1e18, trade.trader, trade.tigAsset, true);", "            (uint256 _price, uint256 _spread) = tradingExtension.getVerifiedPrice(trade.asset, _priceData, _signature, 0);", "            if (trade.orderType == 0) revert(\"5\");", "            if (_price > trade.price+trade.price*limitOrderPriceRange/DIVISION_CONSTANT || _price < trade.price-trade.price*limitOrderPriceRange/DIVISION_CONSTANT) revert(\"6\"); //LimitNotMet", "            if (trade.direction && trade.orderType == 1) {", "                if (trade.price < _price) revert(\"6\"); //LimitNotMet", "            } else if (!trade.direction && trade.orderType == 1) {", "                if (trade.price > _price) revert(\"6\"); //LimitNotMet", "            } else if (!trade.direction && trade.orderType == 2) {", "                if (trade.price < _price) revert(\"6\"); //LimitNotMet", "                trade.price = _price;", "            } else {", "                if (trade.price > _price) revert(\"6\"); //LimitNotMet", "                trade.price = _price;", "            } ", "            if(trade.direction) {", "                trade.price += trade.price * _spread / DIVISION_CONSTANT;", "            } else {", "                trade.price -= trade.price * _spread / DIVISION_CONSTANT;", "            }", "            if (trade.direction) {", "                tradingExtension.modifyLongOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);", "            } else {", "                tradingExtension.modifyShortOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);", "            }", "            _updateFunding(trade.asset, trade.tigAsset);", "            position.executeLimitOrder(_id, trade.price, trade.margin - _fee);", "            emit LimitOrderExecuted(trade.asset, trade.direction, trade.price, trade.leverage, trade.margin - _fee, _id, trade.trader, _msgSender());", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _burn(uint _tokenId) internal {", "        require(_isApprovedOrOwner(msg.sender, _tokenId), \"caller is not owner nor approved\");", "", "        address owner = ownerOf(_tokenId);", "", "        // Clear approval", "        approve(address(0), _tokenId);", "        // TODO add delegates", "        // Remove token", "        _removeTokenFrom(msg.sender, _tokenId);", "        emit Transfer(owner, address(0), _tokenId);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["    function maxBuyAllAmount(", "        ERC20 buy_gem,", "        ERC20 pay_gem,", "        uint256 max_fill_amount", "    ) external returns (uint256 fill) {", "        //swaps msg.sender's entire balance in the trade", "        uint256 maxAmount = ERC20(buy_gem).balanceOf(msg.sender);", "        fill = RubiconMarket(RubiconMarketAddress).buyAllAmount(", "            buy_gem,", "            maxAmount,", "            pay_gem,", "            max_fill_amount", "        );", "        ERC20(buy_gem).transfer(msg.sender, fill);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function stake(uint256 lpTokenIn) external virtual update nonReentrant {", "        require(lpTokenIn > 0, \"MuteAmplifier::stake: missing stake\");", "        require(block.timestamp >= startTime && startTime !=0, \"MuteAmplifier::stake: not live yet\");", "        require(IERC20(muteToken).balanceOf(address(this)) > 0, \"MuteAmplifier::stake: no reward balance\");", "", "        if (firstStakeTime == 0) {", "            firstStakeTime = block.timestamp;", "        } else {", "            require(block.timestamp < endTime, \"MuteAmplifier::stake: staking is over\");", "        }", "", "        lpToken.safeTransferFrom(msg.sender, address(this), lpTokenIn);", "", "        if (totalUserStake(msg.sender) == 0) {", "            totalStakers = totalStakers.add(1);", "        }", "", "        _stake(lpTokenIn, msg.sender);", "", "        emit Stake(msg.sender, lpTokenIn);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function operate(SpigotState storage self, address revenueContract, bytes calldata data) external returns (bool) {", "        if(msg.sender != self.operator) { revert CallerAccessDenied(); }", "        ", "        // extract function signature from tx data and check whitelist", "        bytes4 func = bytes4(data);", "", "        if(!self.whitelistedFunctions[func]) { revert BadFunction(); }", "        ", "        // cant claim revenue via operate() because that fucks up accounting logic. Owner shouldn't whitelist it anyway but just in case", "        // also can't transfer ownership so Owner retains control of revenue contract", "        if(", "          func == self.settings[revenueContract].claimFunction ||", "          func == self.settings[revenueContract].transferOwnerFunction", "        ) { revert BadFunction(); }", "", "        (bool success,) = revenueContract.call(data);", "        if(!success) { revert BadFunction(); }", "", "        return true;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _applyCriteriaResolvers(", "        AdvancedOrder[] memory advancedOrders,", "        CriteriaResolver[] memory criteriaResolvers", "    ) internal pure {", "        // Skip overflow checks as all for loops are indexed starting at zero.", "        unchecked {", "            // Retrieve length of criteria resolvers array and place on stack.", "            uint256 totalCriteriaResolvers = criteriaResolvers.length;", "", "            // Retrieve length of orders array and place on stack.", "            uint256 totalAdvancedOrders = advancedOrders.length;", "", "            // Iterate over each criteria resolver.", "            for (uint256 i = 0; i < totalCriteriaResolvers; ++i) {", "                // Retrieve the criteria resolver.", "                CriteriaResolver memory criteriaResolver = (", "                    criteriaResolvers[i]", "                );", "", "                // Read the order index from memory and place it on the stack.", "                uint256 orderIndex = criteriaResolver.orderIndex;", "", "                // Ensure that the order index is in range.", "                if (orderIndex >= totalAdvancedOrders) {", "                    revert OrderCriteriaResolverOutOfRange();", "                }", "", "                // Skip criteria resolution for order if not fulfilled.", "                if (advancedOrders[orderIndex].numerator == 0) {", "                    continue;", "                }", "", "                // Retrieve the parameters for the order.", "                OrderParameters memory orderParameters = (", "                    advancedOrders[orderIndex].parameters", "                );", "", "                // Read component index from memory and place it on the stack.", "                uint256 componentIndex = criteriaResolver.index;", "", "                // Declare values for item's type and criteria.", "                ItemType itemType;", "                uint256 identifierOrCriteria;", "", "                // If the criteria resolver refers to an offer item...", "                if (criteriaResolver.side == Side.OFFER) {", "                    // Retrieve the offer.", "                    OfferItem[] memory offer = orderParameters.offer;", "", "                    // Ensure that the component index is in range.", "                    if (componentIndex >= offer.length) {", "                        revert OfferCriteriaResolverOutOfRange();", "                    }", "", "                    // Retrieve relevant item using the component index.", "                    OfferItem memory offerItem = offer[componentIndex];", "", "                    // Read item type and criteria from memory & place on stack.", "                    itemType = offerItem.itemType;", "                    identifierOrCriteria = offerItem.identifierOrCriteria;", "", "                    // Optimistically update item type to remove criteria usage.", "                    ItemType newItemType;", "                    assembly {", "                        newItemType := sub(3, eq(itemType, 4))", "                    }", "                    offerItem.itemType = newItemType;", "", "                    // Optimistically update identifier w/ supplied identifier.", "                    offerItem.identifierOrCriteria = criteriaResolver", "                        .identifier;", "                } else {", "                    // Otherwise, the resolver refers to a consideration item.", "                    ConsiderationItem[] memory consideration = (", "                        orderParameters.consideration", "                    );", "", "                    // Ensure that the component index is in range.", "                    if (componentIndex >= consideration.length) {", "                        revert ConsiderationCriteriaResolverOutOfRange();", "                    }", "", "                    // Retrieve relevant item using order and component index.", "                    ConsiderationItem memory considerationItem = (", "                        consideration[componentIndex]", "                    );", "", "                    // Read item type and criteria from memory & place on stack.", "                    itemType = considerationItem.itemType;", "                    identifierOrCriteria = (", "                        considerationItem.identifierOrCriteria", "                    );", "", "                    // Optimistically update item type to remove criteria usage.", "                    ItemType newItemType;", "                    assembly {", "                        newItemType := sub(3, eq(itemType, 4))", "                    }", "                    considerationItem.itemType = newItemType;", "", "                    // Optimistically update identifier w/ supplied identifier.", "                    considerationItem.identifierOrCriteria = (", "                        criteriaResolver.identifier", "                    );", "                }", "", "                // Ensure the specified item type indicates criteria usage.", "                if (!_isItemWithCriteria(itemType)) {", "                    revert CriteriaNotEnabledForItem();", "                }", "", "                // If criteria is not 0 (i.e. a collection-wide offer)...", "                if (identifierOrCriteria != uint256(0)) {", "                    // Verify identifier inclusion in criteria root using proof.", "                    _verifyProof(", "                        criteriaResolver.identifier,", "                        identifierOrCriteria,", "                        criteriaResolver.criteriaProof", "                    );", "                }", "            }", "", "            // Iterate over each advanced order.", "            for (uint256 i = 0; i < totalAdvancedOrders; ++i) {", "                // Retrieve the advanced order.", "                AdvancedOrder memory advancedOrder = advancedOrders[i];", "", "                // Skip criteria resolution for order if not fulfilled.", "                if (advancedOrder.numerator == 0) {", "                    continue;", "                }", "", "                // Retrieve the parameters for the order.", "                OrderParameters memory orderParameters = (", "                    advancedOrders[i].parameters", "                );", "", "                // Read consideration length from memory and place on stack.", "                uint256 totalItems = orderParameters.consideration.length;", "", "                // Iterate over each consideration item on the order.", "                for (uint256 j = 0; j < totalItems; ++j) {", "                    // Ensure item type no longer indicates criteria usage.", "                    if (", "                        _isItemWithCriteria(", "                            orderParameters.consideration[j].itemType", "                        )", "                    ) {", "                        revert UnresolvedConsiderationCriteria();", "                    }", "                }", "", "                // Read offer length from memory and place on stack.", "                totalItems = orderParameters.offer.length;", "", "                // Iterate over each offer item on the order.", "                for (uint256 j = 0; j < totalItems; ++j) {", "                    // Ensure item type no longer indicates criteria usage.", "                    if (", "                        _isItemWithCriteria(orderParameters.offer[j].itemType)", "                    ) {", "                        revert UnresolvedOfferCriteria();", "                    }", "                }", "            }", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function batchDepositERC20(", "        address _from,", "        address _to,", "        address[] calldata _tokens,", "        uint256[] calldata _amounts", "    ) external {", "        for (uint256 i = 0; i < _tokens.length; ) {", "            IERC20(_tokens[i]).transferFrom(_from, _to, _amounts[i]);", "            unchecked {", "                ++i;", "            }", "        }", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function allClaimableRewards(address user) external view override returns (uint256[3] memory) {", "        uint256 ammStakedIntegral_ = ammStakedIntegral;", "        uint256 crvStakedIntegral_ = crvStakedIntegral;", "        uint256 cvxStakedIntegral_ = cvxStakedIntegral;", "        uint256 timeElapsed = block.timestamp - uint256(ammLastUpdated);", "", "        // This might lead to some inaccuracies in between poolCheckpoints if someone sends CRV", "        uint256 crvEarned = IERC20(crv).balanceOf(address(this)) +", "            crvRewardsContract.earned(address(this)) -", "            _crvLastEarned;", "        uint256 cvxEarned = getCvxMintAmount(crvEarned);", "", "        if (!killed && totalStaked > 0) {", "            if (inflationRecipient == address(0)) {", "                ammStakedIntegral_ +=", "                    (IController(controller).inflationManager().getAmmRateForToken(ammToken)) *", "                    (timeElapsed).scaledDiv(totalStaked);", "            }", "            crvStakedIntegral_ += (crvEarned).scaledDiv(totalStaked);", "            cvxStakedIntegral_ += (cvxEarned).scaledDiv(totalStaked);", "        }", "        uint256 bkdRewards;", "        if (user == inflationRecipient) {", "            bkdRewards =", "                perUserShare[user] +", "                IController(controller).inflationManager().getAmmRateForToken(ammToken) *", "                timeElapsed;", "        } else {", "            bkdRewards =", "                perUserShare[user] +", "                balances[user].scaledMul(ammStakedIntegral_ - perUserStakedIntegral[user]);", "        }", "        uint256 crvRewards = perUserShareCrv[user] +", "            balances[user].scaledMul(crvStakedIntegral_ - perUserCrvStakedIntegral[user]);", "        uint256 cvxRewards = perUserShareCvx[user] +", "            balances[user].scaledMul(cvxStakedIntegral_ - perUserCvxStakedIntegral[user]);", "        uint256[3] memory allRewards = [bkdRewards, crvRewards, cvxRewards];", "        return allRewards;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function _getFees(", "    address nftContract,", "    uint256 tokenId,", "    address payable seller,", "    uint256 price", "  )", "    private", "    view", "    returns (", "      uint256 foundationFee,", "      address payable[] memory creatorRecipients,", "      uint256[] memory creatorShares,", "      uint256 creatorRev,", "      address payable ownerRevTo,", "      uint256 ownerRev", "    )", "  {", "    bool isCreator;", "    (creatorRecipients, creatorShares, isCreator) = _getCreatorPaymentInfo(nftContract, tokenId, seller);", "", "    // Calculate the Foundation fee", "    uint256 fee;", "    if (isCreator && !_nftContractToTokenIdToFirstSaleCompleted[nftContract][tokenId]) {", "      fee = PRIMARY_FOUNDATION_FEE_BASIS_POINTS;", "    } else {", "      fee = SECONDARY_FOUNDATION_FEE_BASIS_POINTS;", "    }", "", "    foundationFee = (price * fee) / BASIS_POINTS;", "", "    if (creatorRecipients.length > 0) {", "      if (isCreator) {", "        // When sold by the creator, all revenue is split if applicable.", "        creatorRev = price - foundationFee;", "      } else {", "        // Rounding favors the owner first, then creator, and foundation last.", "        creatorRev = (price * CREATOR_ROYALTY_BASIS_POINTS) / BASIS_POINTS;", "        ownerRevTo = seller;", "        ownerRev = price - foundationFee - creatorRev;", "      }", "    } else {", "      // No royalty recipients found.", "      ownerRevTo = seller;", "      ownerRev = price - foundationFee;", "    }", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function convertToShares(uint256 assets)", "        public", "        view", "        virtual", "        returns (uint256)", "    {", "        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.", "", "        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _pledge(uint256 pledgeId, address user, uint256 amount, uint256 endTimestamp) internal {", "        if(pledgeId >= pledgesIndex()) revert Errors.InvalidPledgeID();", "        if(amount == 0) revert Errors.NullValue();", "", "        // Load Pledge parameters & check the Pledge is still active", "        Pledge memory pledgeParams = pledges[pledgeId];", "        if(pledgeParams.closed) revert Errors.PledgeClosed();", "        if(pledgeParams.endTimestamp <= block.timestamp) revert Errors.ExpiredPledge();", "", "        // To join until the end of the pledge, user can input 0 as endTimestamp", "        // so it's override by the Pledge's endTimestamp", "        if(endTimestamp == 0) endTimestamp = pledgeParams.endTimestamp;", "        if(endTimestamp > pledgeParams.endTimestamp || endTimestamp != _getRoundedTimestamp(endTimestamp)) revert Errors.InvalidEndTimestamp();", "", "        // Calculated the effective Pledge duration", "        uint256 boostDuration = endTimestamp - block.timestamp;", "", "        // Check that the user has enough boost delegation available & set the correct allowance to this contract", "        delegationBoost.checkpoint_user(user);", "        if(delegationBoost.allowance(user, address(this)) < amount) revert Errors.InsufficientAllowance();", "        if(delegationBoost.delegable_balance(user) < amount) revert Errors.CannotDelegate();", "", "        // Check that this will not go over the Pledge target of votes", "        if(delegationBoost.adjusted_balance_of(pledgeParams.receiver) + amount > pledgeParams.targetVotes) revert Errors.TargetVotesOverflow();", "", "        // Creates the DelegationBoost", "        delegationBoost.boost(", "            pledgeParams.receiver,", "            amount,", "            endTimestamp,", "            user", "        );", "", "        // Re-calculate the new Boost bias & slope (using Boostv2 logic)", "        uint256 slope = amount / boostDuration;", "        uint256 bias = slope * boostDuration;", "", "        // Rewards are set in the Pledge as reward/veToken/sec", "        // To find the total amount of veToken delegated through the whole Boost duration", "        // based on the Boost bias & the Boost duration, to take in account that the delegated amount decreases", "        // each second of the Boost duration", "        uint256 totalDelegatedAmount = ((bias * boostDuration) + bias) / 2;", "        // Then we can calculate the total amount of rewards for this Boost", "        uint256 rewardAmount = (totalDelegatedAmount * pledgeParams.rewardPerVote) / UNIT;", "", "        if(rewardAmount > pledgeAvailableRewardAmounts[pledgeId]) revert Errors.RewardsBalanceTooLow();", "        pledgeAvailableRewardAmounts[pledgeId] -= rewardAmount;", "", "        // Send the rewards to the user", "        IERC20(pledgeParams.rewardToken).safeTransfer(user, rewardAmount);", "", "        emit Pledged(pledgeId, user, amount, endTimestamp);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function onERC1155Received(", "        address _operator,", "        address _from,", "        uint256 _id,", "        uint256 _value,", "        bytes calldata _data", "    ) external nonReentrant returns (bytes4) {", "        uint256 fCashID = getfCashId();", "        // Only accept erc1155 transfers from NotionalV2", "        require(", "            msg.sender == address(NotionalV2) &&", "            // Only accept the fcash id that corresponds to the listed currency and maturity", "            _id == fCashID &&", "            // Protect against signed value underflows", "            int256(_value) > 0,", "            \"Invalid\"", "        );", "", "        // Double check the account's position, these are not strictly necessary and add gas costs", "        // but might be good safe guards", "        AccountContext memory ac = NotionalV2.getAccountContext(address(this));", "        PortfolioAsset[] memory assets = NotionalV2.getAccountPortfolio(address(this));", "        require(", "            ac.hasDebt == 0x00 &&", "            assets.length == 1 &&", "            EncodeDecode.encodeERC1155Id(", "                assets[0].currencyId,", "                assets[0].maturity,", "                assets[0].assetType", "            ) == fCashID", "        );", "", "        // Update per account fCash balance, calldata from the ERC1155 call is", "        // passed via the ERC777 interface.", "        bytes memory userData;", "        bytes memory operatorData;", "        if (_operator == _from) userData = _data;", "        else operatorData = _data;", "", "        // We don't require a recipient ack here to maintain compatibility", "        // with contracts that don't support ERC777", "        _mint(_from, _value, userData, operatorData, false);", "", "        // This will allow the fCash to be accepted", "        return ERC1155_ACCEPTED;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function mint(TimeswapV2LiquidityTokenMintParam calldata param) external returns (bytes memory data) {", "        ParamLibrary.check(param);", "", "        TimeswapV2LiquidityTokenPosition memory timeswapV2LiquidityTokenPosition = TimeswapV2LiquidityTokenPosition({", "            token0: param.token0,", "            token1: param.token1,", "            strike: param.strike,", "            maturity: param.maturity", "        });", "", "        bytes32 key = timeswapV2LiquidityTokenPosition.toKey();", "        uint256 id = _timeswapV2LiquidityTokenPositionIds[key];", "", "        // if the position does not exist, create it", "        if (id == 0) {", "            id = totalSupply() + 1;", "            _timeswapV2LiquidityTokenPositions[id] = timeswapV2LiquidityTokenPosition;", "            _timeswapV2LiquidityTokenPositionIds[key] = id;", "        }", "", "        changeInteractedIfNecessary(key);", "        raiseGuard(key);", "", "        (, address poolPair) = PoolFactoryLibrary.getWithCheck(optionFactory, poolFactory, param.token0, param.token1);", "", "        // calculate the amount of liquidity tokens to mint", "        uint160 liquidityBalanceTarget = ITimeswapV2Pool(poolPair).liquidityOf(param.strike, param.maturity, address(this)) + param.liquidityAmount;", "", "        // mint the liquidity tokens to the recipient", "        _mint(param.to, id, param.liquidityAmount, bytes(\"\"));", "", "        // ask the msg.sender to transfer the liquidity to this contract", "        data = ITimeswapV2LiquidityTokenMintCallback(msg.sender).timeswapV2LiquidityTokenMintCallback(", "            TimeswapV2LiquidityTokenMintCallbackParam({", "                token0: param.token0,", "                token1: param.token1,", "                strike: param.strike,", "                maturity: param.maturity,", "                liquidityAmount: param.liquidityAmount,", "                data: param.data", "            })", "        );", "", "        // check if the enough liquidity amount target is received", "        Error.checkEnough(ITimeswapV2Pool(poolPair).liquidityOf(param.strike, param.maturity, address(this)), liquidityBalanceTarget);", "", "        // stop the reentrancy guard", "        lowerGuard(key);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function maxSellAllAmount(", "        ERC20 pay_gem,", "        ERC20 buy_gem,", "        uint256 min_fill_amount", "    ) external returns (uint256 fill) {", "        //swaps msg.sender entire balance in the trade", "        uint256 maxAmount = ERC20(buy_gem).balanceOf(msg.sender);", "        fill = RubiconMarket(RubiconMarketAddress).sellAllAmount(", "            pay_gem,", "            maxAmount,", "            buy_gem,", "            min_fill_amount", "        );", "        ERC20(buy_gem).transfer(msg.sender, fill);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function collect(TimeswapV2LiquidityTokenCollectParam calldata param) external returns (uint256 long0Fees, uint256 long1Fees, uint256 shortFees, bytes memory data) {", "        ParamLibrary.check(param);", "", "        bytes32 key = TimeswapV2LiquidityTokenPosition({token0: param.token0, token1: param.token1, strike: param.strike, maturity: param.maturity}).toKey();", "", "        // start the reentrancy guard", "        raiseGuard(key);", "", "        (, address poolPair) = PoolFactoryLibrary.getWithCheck(optionFactory, poolFactory, param.token0, param.token1);", "", "        // transfer the fees amount to the recipient", "        ITimeswapV2Pool(poolPair).transferFees(param.strike, param.maturity, param.to, long0Fees, long1Fees, shortFees);", "", "        uint256 id = _timeswapV2LiquidityTokenPositionIds[key];", "", "        _updateFeesPositions(msg.sender, address(0), id);", "", "        (long0Fees, long1Fees, shortFees) = _feesPositions[id][msg.sender].getFees(param.long0FeesDesired, param.long1FeesDesired, param.shortFeesDesired);", "", "        if (param.data.length != 0)", "            data = ITimeswapV2LiquidityTokenCollectCallback(msg.sender).timeswapV2LiquidityTokenCollectCallback(", "                TimeswapV2LiquidityTokenCollectCallbackParam({", "                    token0: param.token0,", "                    token1: param.token1,", "                    strike: param.strike,", "                    maturity: param.maturity,", "                    long0Fees: long0Fees,", "                    long1Fees: long1Fees,", "                    shortFees: shortFees,", "                    data: param.data", "                })", "            );", "", "        // burn the desired fees from the fees position", "        _feesPositions[id][msg.sender].burn(long0Fees, long1Fees, shortFees);", "", "        if (long0Fees != 0 || long1Fees != 0 || shortFees != 0) _removeTokenEnumeration(msg.sender, address(0), id, 0);", "", "        // stop the reentrancy guard", "        lowerGuard(key);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function setStrategy(IERC20 _token, IStrategy _strategy)", "        external", "        onlyRole(STRATEGIST_ROLE)", "    {", "        require(", "            approvedStrategies[_token][_strategy] == true,", "            \"STRATEGY_NOT_APPROVED\"", "        );", "", "        IStrategy _current = strategies[_token];", "        if (address(_current) != address(0)) {", "            //withdraw all funds from the current strategy", "            _current.withdrawAll();", "            _current.withdraw(address(jpeg));", "        }", "        strategies[_token] = _strategy;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["  function mint(MintParams calldata params) external payable checkDeadline(params.deadline) returns (uint256 shares) {", "    address lendgine = LendgineAddress.computeAddress(", "      factory, params.token0, params.token1, params.token0Exp, params.token1Exp, params.upperBound", "    );", "", "    shares = ILendgine(lendgine).mint(", "      address(this),", "      params.amountIn + params.amountBorrow,", "      abi.encode(", "        MintCallbackData({", "          token0: params.token0,", "          token1: params.token1,", "          token0Exp: params.token0Exp,", "          token1Exp: params.token1Exp,", "          upperBound: params.upperBound,", "          collateralMax: params.amountIn,", "          swapType: params.swapType,", "          swapExtraData: params.swapExtraData,", "          payer: msg.sender", "        })", "      )", "    );", "    if (shares < params.sharesMin) revert AmountError();", "", "    SafeTransferLib.safeTransfer(lendgine, params.recipient, shares);", "", "    emit Mint(msg.sender, lendgine, params.amountIn, shares, params.recipient);", "  }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function preLiquidateHook(", "        address vTokenBorrowed,", "        address vTokenCollateral,", "        address borrower,", "        uint256 repayAmount,", "        bool skipLiquidityCheck", "    ) external override {", "        // Pause Action.LIQUIDATE on BORROWED TOKEN to prevent liquidating it.", "        // If we want to pause liquidating to vTokenCollateral, we should pause", "        // Action.SEIZE on it", "        _checkActionPauseState(vTokenBorrowed, Action.LIQUIDATE);", "", "        oracle.updatePrice(vTokenBorrowed);", "        oracle.updatePrice(vTokenCollateral);", "", "        if (!markets[vTokenBorrowed].isListed) {", "            revert MarketNotListed(address(vTokenBorrowed));", "        }", "        if (!markets[vTokenCollateral].isListed) {", "            revert MarketNotListed(address(vTokenCollateral));", "        }", "", "        uint256 borrowBalance = VToken(vTokenBorrowed).borrowBalanceStored(borrower);", "", "        /* Allow accounts to be liquidated if the market is deprecated or it is a forced liquidation */", "        if (skipLiquidityCheck || isDeprecated(VToken(vTokenBorrowed))) {", "            if (repayAmount > borrowBalance) {", "                revert TooMuchRepay();", "            }", "            return;", "        }", "", "        /* The borrower must have shortfall and collateral > threshold in order to be liquidatable */", "        AccountLiquiditySnapshot memory snapshot = _getCurrentLiquiditySnapshot(borrower, _getLiquidationThreshold);", "", "        if (snapshot.totalCollateral <= minLiquidatableCollateral) {", "            /* The liquidator should use either liquidateAccount or healAccount */", "            revert MinimalCollateralViolated(minLiquidatableCollateral, snapshot.totalCollateral);", "        }", "", "        if (snapshot.shortfall == 0) {", "            revert InsufficientShortfall();", "        }", "", "        /* The liquidator may not repay more than what is allowed by the closeFactor */", "        uint256 maxClose = mul_ScalarTruncate(Exp({ mantissa: closeFactorMantissa }), borrowBalance);", "        if (repayAmount > maxClose) {", "            revert TooMuchRepay();", "        }", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function rebalanceToWeights() external onlyOwner {", "        uint256 ethAmountBefore = address(this).balance;", "        for (uint i = 0; i < derivativeCount; i++) {", "            if (derivatives[i].balance() > 0)", "                derivatives[i].withdraw(derivatives[i].balance());", "        }", "        uint256 ethAmountAfter = address(this).balance;", "        uint256 ethAmountToRebalance = ethAmountAfter - ethAmountBefore;", "", "        for (uint i = 0; i < derivativeCount; i++) {", "            if (weights[i] == 0 || ethAmountToRebalance == 0) continue;", "            uint256 ethAmount = (ethAmountToRebalance * weights[i]) /", "                totalWeight;", "            // Price will change due to slippage", "            derivatives[i].deposit{value: ethAmount}();", "        }", "        emit Rebalanced();", "    }"], "ner_tags": [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0]}
{"tokens": ["    function _withdraw(uint256 _shares) internal nonReentrant {", "        require(_shares != 0, \"0 Shares\");", "", "        uint256 r = (balance() * _shares) / totalSupply();", "        _burn(msg.sender, _shares);", "", "        // Check balance", "        uint256 b = token.balanceOf(address(this));", "        if (b < r) {", "            uint256 _toWithdraw = r - b;", "            IStrategy(strategy).withdraw(_toWithdraw);", "            uint256 _after = token.balanceOf(address(this));", "            uint256 _diff = _after - b;", "            if (_diff < _toWithdraw) {", "                r = b + _diff;", "            }", "        }", "", "        uint256 _fee = _calculateFee(r, withdrawalFee);", "        uint256 _amount = r - _fee;", "", "        // Send funds to vesting contract and setup vesting", "        IVesting(vesting).setupVesting(msg.sender, _amount, block.timestamp);", "        token.safeTransfer(vesting, _amount);", "", "        // After you burned the shares, and you have sent the funds, adding here is equivalent to depositing", "        // Process withdrawal fee", "        if(_fee > 0) {", "            _mintSharesFor(treasury, _fee, balance() - _fee);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function activateProposal(uint256 proposalId_) external {", "        ProposalMetadata memory proposal = getProposalMetadata[proposalId_];", "", "        if (msg.sender != proposal.submitter) {", "            revert NotAuthorizedToActivateProposal();", "        }", "", "        if (block.timestamp > proposal.submissionTimestamp + ACTIVATION_DEADLINE) {", "            revert SubmittedProposalHasExpired();", "        }", "", "        if (", "            (totalEndorsementsForProposal[proposalId_] * 100) <", "            VOTES.totalSupply() * ENDORSEMENT_THRESHOLD", "        ) {", "            revert NotEnoughEndorsementsToActivateProposal();", "        }", "", "        if (proposalHasBeenActivated[proposalId_] == true) {", "            revert ProposalAlreadyActivated();", "        }", "", "        if (block.timestamp < activeProposal.activationTimestamp + GRACE_PERIOD) {", "            revert ActiveProposalNotExpired();", "        }", "", "        activeProposal = ActivatedProposal(proposalId_, block.timestamp);", "", "        proposalHasBeenActivated[proposalId_] = true;", "", "        emit ProposalActivated(proposalId_, block.timestamp);", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function _checkpointEpoch() internal {", "        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);", "        uint256 epochindex = epochs.length;", "", "        //first epoch add in constructor, no need to check 0 length", "        //check to add", "        if (epochs[epochindex - 1].date < currentEpoch) {", "            //fill any epoch gaps until the next epoch date.", "            while (epochs[epochs.length - 1].date != currentEpoch) {", "                uint256 nextEpochDate = uint256(epochs[epochs.length - 1].date).add(rewardsDuration);", "                epochs.push(Epoch({ supply: 0, date: uint32(nextEpochDate) }));", "            }", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0]}
{"tokens": ["    function _requestWithdrawalFromTokemak(uint256 _amount) internal {", "        ITokePool tokePoolContract = ITokePool(TOKE_POOL);", "        uint256 balance = ITokePool(TOKE_POOL).balanceOf(address(this));", "", "        // the only way balance < _amount is when using unstakeAllFromTokemak", "        uint256 amountToRequest = balance < _amount ? balance : _amount;", "", "        if (amountToRequest > 0) tokePoolContract.requestWithdrawal(_amount);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function _handleExecuteTransaction(", "    ExecuteArgs calldata _args,", "    uint256 _amount,", "    address _asset, // adopted (or local if specified)", "    bytes32 _transferId,", "    bool _reconciled", "  ) private returns (uint256) {", "    // If the domain if sponsored", "    if (address(s.sponsorVault) != address(0)) {", "      // fast liquidity path", "      if (!_reconciled) {", "        // Vault will return the amount of the fee they sponsored in the native fee", "        // NOTE: some considerations here around fee on transfer tokens and ensuring", "        // there are no malicious `Vaults` that do not transfer the correct amount. Should likely do a", "        // balance read about it", "", "        uint256 starting = IERC20(_asset).balanceOf(address(this));", "        uint256 sponsored = s.sponsorVault.reimburseLiquidityFees(_asset, _args.amount, _args.params.to);", "", "        // Validate correct amounts are transferred", "        if (IERC20(_asset).balanceOf(address(this)) != starting + sponsored) {", "          revert BridgeFacet__handleExecuteTransaction_invalidSponsoredAmount();", "        }", "", "        _amount = _amount + sponsored;", "      }", "", "      // Should dust the recipient with the lesser of a vault-defined cap or the converted relayer fee", "      // If there is no conversion available (i.e. no oracles for origin domain asset <> dest asset pair),", "      // then the vault should just pay out the configured constant", "      s.sponsorVault.reimburseRelayerFees(_args.params.originDomain, payable(_args.params.to), _args.params.relayerFee);", "    }", "", "    // execute the the transaction", "    if (keccak256(_args.params.callData) == EMPTY) {", "      // no call data, send funds to the user", "      AssetLogic.transferAssetFromContract(_asset, _args.params.to, _amount);", "    } else {", "      // execute calldata w/funds", "      AssetLogic.transferAssetFromContract(_asset, address(s.executor), _amount);", "      (bool success, bytes memory returnData) = s.executor.execute(", "        IExecutor.ExecutorArgs(", "          _transferId,", "          _amount,", "          _args.params.to,", "          _args.params.recovery,", "          _asset,", "          _reconciled", "            ? LibCrossDomainProperty.formatDomainAndSenderBytes(_args.params.originDomain, _args.originSender)", "            : LibCrossDomainProperty.EMPTY_BYTES,", "          _args.params.callData", "        )", "      );", "", "      // If callback address is not zero, send on the PromiseRouter", "      if (_args.params.callback != address(0)) {", "        s.promiseRouter.send(_args.params.originDomain, _transferId, _args.params.callback, success, returnData);", "      }", "    }", "", "    return _amount;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": ["    function _calculateRefundAmount(uint96 votingPower) internal view returns (uint96 amount) {", "        amount = (votingPower * 1e4) / exchangeRateBps;", "", "        // Add back fee to contribution amount if applicable.", "        address payable fundingSplitRecipient_ = fundingSplitRecipient;", "        uint16 fundingSplitBps_ = fundingSplitBps;", "        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {", "            amount = (amount * 1e4) / (1e4 - fundingSplitBps_);", "        }", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _deposit(uint256 assets, address receiver)", "        internal", "        returns (uint256 shares)", "    {", "        uint256 _pool = underlyingBalance();", "        uint256 _before = underlyingToken.balanceOf(address(this));", "", "        // **Assume caller is depositor**", "        underlyingToken.transferFrom(msg.sender, address(this), assets);", "        uint256 _after = underlyingToken.balanceOf(address(this));", "        assets = _after.sub(_before); // Additional check for deflationary tokens", "", "        (totalSupply == 0) ? shares = assets : shares = (", "            assets.mul(totalSupply)", "        ).div(_pool);", "", "        // Send shares to designated target", "        _mint(receiver, shares);", "        emit LogDeposit(", "            assets,", "            underlyingToken,", "            shares,", "            msg.sender,", "            underlyingBalance(),", "            outstandingAmount,", "            totalSupply", "        );", "        emit Deposit(msg.sender, msg.sender, assets, shares);", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function getTokenPrice(uint256 tokenId) public view returns (uint256) {", "        UinswapV3PositionData memory positionData = getOnchainPositionData(", "            tokenId", "        );", "", "        PairOracleData memory oracleData = _getOracleData(positionData);", "", "        (uint256 liquidityAmount0, uint256 liquidityAmount1) = LiquidityAmounts", "            .getAmountsForLiquidity(", "                oracleData.sqrtPriceX96,", "                TickMath.getSqrtRatioAtTick(positionData.tickLower),", "                TickMath.getSqrtRatioAtTick(positionData.tickUpper),", "                positionData.liquidity", "            );", "", "        (", "            uint256 feeAmount0,", "            uint256 feeAmount1", "        ) = getLpFeeAmountFromPositionData(positionData);", "", "        return", "            (((liquidityAmount0 + feeAmount0) * oracleData.token0Price) /", "                10**oracleData.token0Decimal) +", "            (((liquidityAmount1 + feeAmount1) * oracleData.token1Price) /", "                10**oracleData.token1Decimal);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function _distributeCredit(address yieldToken, uint256 amount) internal {", "        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];", "", "        uint256 pendingCredit     = yieldTokenParams.pendingCredit;", "        uint256 distributedCredit = yieldTokenParams.distributedCredit;", "        uint256 unlockedCredit    = _calculateUnlockedCredit(yieldToken);", "        uint256 lockedCredit      = pendingCredit - (distributedCredit + unlockedCredit);", "", "        // Distribute any unlocked credit before overriding it.", "        if (unlockedCredit > 0) {", "            yieldTokenParams.accruedWeight += unlockedCredit * FIXED_POINT_SCALAR / yieldTokenParams.totalShares;", "        }", "", "        yieldTokenParams.pendingCredit         = amount + lockedCredit;", "        yieldTokenParams.distributedCredit     = 0;", "        yieldTokenParams.lastDistributionBlock = block.number;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function bid(", "        uint256 auctionId,", "        uint128 quoteAmount,", "        bytes32 commitment,", "        ECCMath.Point calldata pubKey,", "        bytes32 encryptedMessage,", "        bytes calldata encryptedPrivateKey,", "        bytes32[] calldata proof", "    ) external atState(idToAuction[auctionId], States.AcceptingBids) returns (uint256) {", "        Auction storage a = idToAuction[auctionId];", "        if (a.params.merkleRoot != bytes32(0)) {", "            bytes32 leaf = keccak256(abi.encodePacked(msg.sender));", "            if (!MerkleProofLib.verify(proof, a.params.merkleRoot, leaf)) {", "                revert InvalidProof();", "            }", "        }", "", "        // Seller cannot bid on their own auction", "        if (msg.sender == a.data.seller) {", "            revert UnauthorizedCaller();", "        }", "", "        if (quoteAmount == 0 || quoteAmount == type(uint128).max || quoteAmount < a.params.minimumBidQuote) {", "            revert InvalidBidAmount();", "        }", "", "        EncryptedBid memory ebid;", "        ebid.sender = msg.sender;", "        ebid.quoteAmount = quoteAmount;", "        ebid.commitment = commitment;", "        ebid.pubKey = pubKey;", "        ebid.encryptedMessage = encryptedMessage;", "", "        uint256 bidIndex = a.bids.length;", "        // Max of 1000 bids on an auction to prevent DOS", "        if (bidIndex >= 1000) {", "            revert InvalidState();", "        }", "", "        a.bids.push(ebid);", "", "        SafeTransferLib.safeTransferFrom(ERC20(a.params.quoteToken), msg.sender, address(this), quoteAmount);", "", "        emit Bid(", "            msg.sender, auctionId, bidIndex, quoteAmount, commitment, pubKey, encryptedMessage, encryptedPrivateKey", "        );", "", "        return bidIndex;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function donate(address yieldToken, uint256 amount) external override lock {", "        _onlyWhitelisted();", "        _checkArgument(amount != 0);", "", "        // Distribute any unlocked credit so that the accrued weight is up to date.", "        _distributeUnlockedCredit(yieldToken);", "", "        // Update the message sender's account. This will assure that any credit that was earned is not overridden.", "        _poke(msg.sender);", "", "        uint256 shares = _yieldTokens[yieldToken].totalShares - _accounts[msg.sender].balances[yieldToken];", "", "        _yieldTokens[yieldToken].accruedWeight += amount * FIXED_POINT_SCALAR / shares;", "        _accounts[msg.sender].lastAccruedWeights[yieldToken] = _yieldTokens[yieldToken].accruedWeight;", "", "        TokenUtils.safeBurnFrom(debtToken, msg.sender, amount);", "", "        emit Donate(msg.sender, yieldToken, amount);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _returnERC20TokensIfAny(TokenTransfer[] calldata tokenTransfers, address recipient) private {", "        uint256 tokenTransfersLength = tokenTransfers.length;", "        for (uint256 i; i < tokenTransfersLength; ) {", "            uint256 balance = IERC20(tokenTransfers[i].currency).balanceOf(address(this));", "            if (balance > 0) _executeERC20DirectTransfer(tokenTransfers[i].currency, recipient, balance);", "", "            unchecked {", "                ++i;", "            }", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)", "    external", "    virtual", "    override", "    returns (uint256)", "  {", "    return _distributeReservedTokensOf(_projectId, _memo);", "  }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["\tfunction registerMultisig(address addr) external onlyGuardian {", "\t\tint256 multisigIndex = getIndexOf(addr);", "\t\tif (multisigIndex != -1) {", "\t\t\trevert MultisigAlreadyRegistered();", "\t\t}", "\t\tuint256 index = getUint(keccak256(\"multisig.count\"));", "\t\tif (index >= MULTISIG_LIMIT) {", "\t\t\trevert MultisigLimitReached();", "\t\t}", "", "\t\tsetAddress(keccak256(abi.encodePacked(\"multisig.item\", index, \".address\")), addr);", "", "\t\t// The index is stored 1 greater than the actual value. The 1 is subtracted in getIndexOf().", "\t\tsetUint(keccak256(abi.encodePacked(\"multisig.index\", addr)), index + 1);", "\t\taddUint(keccak256(\"multisig.count\"), 1);", "\t\temit RegisteredMultisig(addr, msg.sender);", "\t}"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function initialize(", "        address _creator,", "        address _uri,", "        string memory _name,", "        string memory _symbol", "    ) public initializer {", "        __ERC721_init(_name, _symbol);", "        __AccessControl_init();", "", "        tokenUriDelegate = _uri;", "", "        _grantRole(DEFAULT_ADMIN_ROLE, _creator);", "        _grantRole(MINTER_ROLE, _creator);", "        _grantRole(URI_SETTER_ROLE, _creator);", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function verifyProposalSignature(", "        NounsDAOStorageV3.StorageV3 storage ds,", "        bytes memory proposalEncodeData,", "        NounsDAOStorageV3.ProposerSignature memory proposerSignature,", "        bytes32 typehash", "    ) internal view {", "        bytes32 sigHash = keccak256(proposerSignature.sig);", "        if (ds.cancelledSigs[proposerSignature.signer][sigHash]) revert SignatureIsCancelled();", "", "        bytes32 digest = sigDigest(typehash, proposalEncodeData, proposerSignature.expirationTimestamp, address(this));", "        if (!SignatureChecker.isValidSignatureNow(proposerSignature.signer, digest, proposerSignature.sig))", "            revert InvalidSignature();", "", "        if (block.timestamp > proposerSignature.expirationTimestamp) revert SignatureExpired();", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function unwrap(uint256[] calldata tokenIds) public returns (uint256 fractionalTokenAmount) {", "        // *** Effects *** //", "", "        // burn fractional tokens from sender", "        fractionalTokenAmount = tokenIds.length * ONE;", "        _burn(msg.sender, fractionalTokenAmount);", "", "        // *** Interactions *** //", "", "        // transfer nfts to sender", "        for (uint256 i = 0; i < tokenIds.length; i++) {", "            ERC721(nft).safeTransferFrom(address(this), msg.sender, tokenIds[i]);", "        }", "", "        emit Unwrap(tokenIds);", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": ["  function _getCreatorPaymentInfo(", "    address nftContract,", "    uint256 tokenId,", "    address seller", "  )", "    internal", "    view", "    returns (", "      address payable[] memory recipients,", "      uint256[] memory splitPerRecipientInBasisPoints,", "      bool isCreator", "    )", "  {", "    // All NFTs implement 165 so we skip that check, individual interfaces should return false if 165 is not implemented", "", "    // 1st priority: ERC-2981", "    if (nftContract.supportsERC165Interface(type(IRoyaltyInfo).interfaceId)) {", "      try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (", "        address receiver,", "        uint256 /* royaltyAmount */", "      ) {", "        if (receiver != address(0)) {", "          recipients = new address payable[](1);", "          recipients[0] = payable(receiver);", "          // splitPerRecipientInBasisPoints is not relevant when only 1 recipient is defined", "          if (receiver == seller) {", "            return (recipients, splitPerRecipientInBasisPoints, true);", "          }", "        }", "      } catch // solhint-disable-next-line no-empty-blocks", "      {", "        // Fall through", "      }", "    }", "", "    // 2nd priority: getRoyalties", "    if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetRoyalties).interfaceId)) {", "      try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (", "        address payable[] memory _recipients,", "        uint256[] memory recipientBasisPoints", "      ) {", "        if (_recipients.length > 0 && _recipients.length == recipientBasisPoints.length) {", "          bool hasRecipient;", "          unchecked {", "            // The array length cannot overflow 256 bits.", "            for (uint256 i = 0; i < _recipients.length; ++i) {", "              if (_recipients[i] != address(0)) {", "                hasRecipient = true;", "                if (_recipients[i] == seller) {", "                  return (_recipients, recipientBasisPoints, true);", "                }", "              }", "            }", "          }", "          if (hasRecipient) {", "            recipients = _recipients;", "            splitPerRecipientInBasisPoints = recipientBasisPoints;", "          }", "        }", "      } catch // solhint-disable-next-line no-empty-blocks", "      {", "        // Fall through", "      }", "    }", "", "    /* Overrides must support ERC-165 when registered, except for overrides defined by the registry owner.", "       If that results in an override w/o 165 we may need to upgrade the market to support or ignore that override. */", "    // The registry requires overrides are not 0 and contracts when set.", "    // If no override is set, the nftContract address is returned.", "    if (recipients.length == 0) {", "      try royaltyRegistry.getRoyaltyLookupAddress{ gas: READ_ONLY_GAS_LIMIT }(nftContract) returns (", "        address overrideContract", "      ) {", "        if (overrideContract != nftContract) {", "          nftContract = overrideContract;", "", "          // The functions above are repeated here if an override is set.", "", "          // 3rd priority: ERC-2981 override", "          if (nftContract.supportsERC165Interface(type(IRoyaltyInfo).interfaceId)) {", "            try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (", "              address receiver,", "              uint256 /* royaltyAmount */", "            ) {", "              if (receiver != address(0)) {", "                recipients = new address payable[](1);", "                recipients[0] = payable(receiver);", "                // splitPerRecipientInBasisPoints is not relevant when only 1 recipient is defined", "                if (receiver == seller) {", "                  return (recipients, splitPerRecipientInBasisPoints, true);", "                }", "              }", "            } catch // solhint-disable-next-line no-empty-blocks", "            {", "              // Fall through", "            }", "          }", "", "          // 4th priority: getRoyalties override", "          if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetRoyalties).interfaceId)) {", "            try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (", "              address payable[] memory _recipients,", "              uint256[] memory recipientBasisPoints", "            ) {", "              if (_recipients.length > 0 && _recipients.length == recipientBasisPoints.length) {", "                bool hasRecipient;", "                for (uint256 i = 0; i < _recipients.length; ++i) {", "                  if (_recipients[i] != address(0)) {", "                    hasRecipient = true;", "                    if (_recipients[i] == seller) {", "                      return (_recipients, recipientBasisPoints, true);", "                    }", "                  }", "                }", "                if (hasRecipient) {", "                  recipients = _recipients;", "                  splitPerRecipientInBasisPoints = recipientBasisPoints;", "                }", "              }", "            } catch // solhint-disable-next-line no-empty-blocks", "            {", "              // Fall through", "            }", "          }", "        }", "      } catch // solhint-disable-next-line no-empty-blocks", "      {", "        // Ignore out of gas errors and continue using the nftContract address", "      }", "    }", "", "    // 5th priority: getFee* from contract or override", "    if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetFees).interfaceId)) {", "      try IGetFees(nftContract).getFeeRecipients{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (", "        address payable[] memory _recipients", "      ) {", "        if (_recipients.length > 0) {", "          try IGetFees(nftContract).getFeeBps{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (", "            uint256[] memory recipientBasisPoints", "          ) {", "            if (_recipients.length == recipientBasisPoints.length) {", "              bool hasRecipient;", "              unchecked {", "                // The array length cannot overflow 256 bits.", "                for (uint256 i = 0; i < _recipients.length; ++i) {", "                  if (_recipients[i] != address(0)) {", "                    hasRecipient = true;", "                    if (_recipients[i] == seller) {", "                      return (_recipients, recipientBasisPoints, true);", "                    }", "                  }", "                }", "              }", "              if (hasRecipient) {", "                recipients = _recipients;", "                splitPerRecipientInBasisPoints = recipientBasisPoints;", "              }", "            }", "          } catch // solhint-disable-next-line no-empty-blocks", "          {", "            // Fall through", "          }", "        }", "      } catch // solhint-disable-next-line no-empty-blocks", "      {", "        // Fall through", "      }", "    }", "", "    // 6th priority: tokenCreator w/ or w/o requiring 165 from contract or override", "    try ITokenCreator(nftContract).tokenCreator{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (", "      address payable _creator", "    ) {", "      if (_creator != address(0)) {", "        if (recipients.length == 0) {", "          // Only pay the tokenCreator if there wasn't another royalty defined", "          recipients = new address payable[](1);", "          recipients[0] = _creator;", "          // splitPerRecipientInBasisPoints is not relevant when only 1 recipient is defined", "        }", "        return (recipients, splitPerRecipientInBasisPoints, _creator == seller);", "      }", "    } catch // solhint-disable-next-line no-empty-blocks", "    {", "      // Fall through", "    }", "", "    // 7th priority: owner from contract or override", "    try IOwnable(nftContract).owner{ gas: READ_ONLY_GAS_LIMIT }() returns (address owner) {", "      if (recipients.length == 0) {", "        // Only pay the owner if there wasn't another royalty defined", "        recipients = new address payable[](1);", "        recipients[0] = payable(owner);", "        // splitPerRecipientInBasisPoints is not relevant when only 1 recipient is defined", "      }", "      return (recipients, splitPerRecipientInBasisPoints, owner == seller);", "    } catch // solhint-disable-next-line no-empty-blocks", "    {", "      // Fall through", "    }", "", "    // If no valid payment address or creator is found, return 0 recipients", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function stake(bytes[] calldata _blsPubKeys, uint256[] calldata _sETHAmounts, address _onBehalfOf) external {", "        if (_blsPubKeys.length == 0) revert EmptyArray();", "        if (_blsPubKeys.length != _sETHAmounts.length) revert InconsistentArrayLengths();", "        if (_onBehalfOf == address(0)) revert ZeroAddress();", "", "        // Make sure we have the latest accrued information", "        updateAccruedETHPerShares();", "", "        for (uint256 i; i < _blsPubKeys.length; ++i) {", "            bytes memory _blsPubKey = _blsPubKeys[i];", "            uint256 _sETHAmount = _sETHAmounts[i];", "", "            if (_sETHAmount < 1 gwei) revert FreeFloatingStakeAmountTooSmall();", "            if (!isKnotRegistered[_blsPubKey] || isNoLongerPartOfSyndicate[_blsPubKey]) revert KnotIsNotRegisteredWithSyndicate();", "", "            if (block.number < priorityStakingEndBlock && !isPriorityStaker[_onBehalfOf]) revert NotPriorityStaker();", "", "            uint256 totalStaked = sETHTotalStakeForKnot[_blsPubKey];", "            if (totalStaked == 12 ether) revert KnotIsFullyStakedWithFreeFloatingSlotTokens();", "", "            if (_sETHAmount + totalStaked > 12 ether) revert InvalidStakeAmount();", "", "            totalFreeFloatingShares += _sETHAmount;", "            sETHTotalStakeForKnot[_blsPubKey] += _sETHAmount;", "            sETHStakedBalanceForKnot[_blsPubKey][_onBehalfOf] += _sETHAmount;", "            sETHUserClaimForKnot[_blsPubKey][_onBehalfOf] = (_sETHAmount * accumulatedETHPerFreeFloatingShare) / PRECISION;", "", "            (address stakeHouse,,,,,) = getStakeHouseUniverse().stakeHouseKnotInfo(_blsPubKey);", "            if (stakeHouse == address(0)) revert KnotIsNotAssociatedWithAStakeHouse();", "            IERC20 sETH = IERC20(getSlotRegistry().stakeHouseShareTokens(stakeHouse));", "            bool transferResult = sETH.transferFrom(msg.sender, address(this), _sETHAmount);", "            if (!transferResult) revert UnableToStakeFreeFloatingSlot();", "", "            emit Staked(_blsPubKey, _sETHAmount);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function mintAndDistribute()", "        external", "        onlyRole(POLICY_OPERATIONS_ROLE)", "        gacPausable", "        nonReentrant", "    {", "        uint256 cachedLastMintTimestamp = lastMintTimestamp;", "", "        uint256 mintable = supplySchedule.getMintable(cachedLastMintTimestamp);", "        citadelToken.mint(address(this), mintable);", "", "        uint256 lockingAmount = 0;", "        uint256 stakingAmount = 0;", "        uint256 fundingAmount = 0;", "", "        // 3 gas to store + 3 to read", "        // Saves 100 gas for each time we xCitadel", "        IVault cachedXCitadel = xCitadel;", "", "        // Saves gas below if true", "        uint256 cachedLockingBps = lockingBps;", "        if (cachedLockingBps != 0) {", "            lockingAmount = (mintable * cachedLockingBps) / MAX_BPS;", "", "            uint256 beforeAmount = cachedXCitadel.balanceOf(address(this));", "", "            IVault(cachedXCitadel).deposit(lockingAmount);", "", "            uint256 afterAmount = cachedXCitadel.balanceOf(address(this));", "", "            uint256 xCitadelToLockers = afterAmount - beforeAmount;", "", "            xCitadelLocker.notifyRewardAmount(", "                address(cachedXCitadel),", "                xCitadelToLockers", "            );", "            emit CitadelDistributionToLocking(", "                cachedLastMintTimestamp,", "                block.timestamp,", "                lockingAmount,", "                xCitadelToLockers", "            );", "        }", "", "        uint256 cachedStakingBps = stakingBps;", "        if (cachedStakingBps != 0) {", "            stakingAmount = (mintable * cachedStakingBps) / MAX_BPS;", "", "            IERC20Upgradeable(address(citadelToken)).safeTransfer(address(cachedXCitadel), stakingAmount);", "            emit CitadelDistributionToStaking(", "                cachedLastMintTimestamp,", "                block.timestamp,", "                stakingAmount", "            );", "        }", "", "        /// Saves gas if the if is true, if it's not costs 6 extra gas", "        uint256 cachedFundingBps = fundingBps;", "        if (cachedFundingBps != 0) {", "            fundingAmount = (mintable * cachedFundingBps) / MAX_BPS;", "", "            _transferToFundingPools(fundingAmount);", "            emit CitadelDistributionToFunding(", "                cachedLastMintTimestamp,", "                block.timestamp,", "                fundingAmount", "            );", "        }", "", "        emit CitadelDistribution(fundingAmount, stakingAmount, lockingAmount);", "", "        lastMintTimestamp = block.timestamp;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function notifyRewardAmount(address token, uint amount) external lock {", "      require(amount > 0);", "      if (!isReward[token]) {", "        require(rewards.length < MAX_REWARD_TOKENS, \"too many rewards tokens\");", "      }", "      // bribes kick in at the start of next bribe period", "      uint adjustedTstamp = getEpochStart(block.timestamp);", "      uint epochRewards = tokenRewardsPerEpoch[token][adjustedTstamp];", "", "      _safeTransferFrom(token, msg.sender, address(this), amount);", "      tokenRewardsPerEpoch[token][adjustedTstamp] = epochRewards + amount;", "", "      if (!isReward[token]) {", "          isReward[token] = true;", "          rewards.push(token);", "          IGauge(gauge).addBribeRewardToken(token);", "      }", "", "      emit NotifyReward(msg.sender, token, adjustedTstamp, amount);", "  }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function withdraw(", "        address _token,", "        address _gauge,", "        uint256 _amount", "    ) public returns (bool) {", "        require(msg.sender == operator, \"!auth\");", "        uint256 _balance = IERC20(_token).balanceOf(address(this));", "        if (_balance < _amount) {", "            _amount = _withdrawSome(_gauge, _amount.sub(_balance));", "            _amount = _amount.add(_balance);", "        }", "        IERC20(_token).safeTransfer(msg.sender, _amount);", "        return true;", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function reportFees(", "        address beneficiary,", "        uint256 amount,", "        address lpTokenAddress", "    ) external override returns (bool) {", "        lpTokenAddress; // silencing compiler warning", "        require(", "            IController(controller).addressProvider().isWhiteListedFeeHandler(msg.sender),", "            Error.ADDRESS_NOT_WHITELISTED", "        );", "        require(!killed, Error.CONTRACT_PAUSED);", "        if (!keeperRecords[beneficiary].firstEpochSet) {", "            keeperRecords[beneficiary].firstEpochSet = true;", "            keeperRecords[beneficiary].nextEpochToClaim = epoch;", "        }", "        keeperRecords[beneficiary].feesInPeriod[epoch] += amount;", "        perPeriodTotalFees[epoch] += amount;", "        return true;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _withdrawFromTokemak() internal {", "        ITokePool tokePoolContract = ITokePool(TOKE_POOL);", "        ITokeManager tokeManager = ITokeManager(TOKE_MANAGER);", "        RequestedWithdrawalInfo memory requestedWithdrawals = tokePoolContract", "            .requestedWithdrawals(address(this));", "        uint256 currentCycleIndex = tokeManager.getCurrentCycleIndex();", "", "        if (", "            requestedWithdrawals.amount > 0 &&", "            requestedWithdrawals.minCycle <= currentCycleIndex", "        ) {", "            tokePoolContract.withdraw(requestedWithdrawals.amount);", "            requestWithdrawalAmount -= requestedWithdrawals.amount;", "            withdrawalAmount += requestedWithdrawals.amount;", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["  function _currentTotalOverflowOf(", "    uint256 _projectId,", "    uint256 _decimals,", "    uint256 _currency", "  ) private view returns (uint256) {", "    // Get a reference to the project's terminals.", "    IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId);", "", "    // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals.", "    uint256 _ethOverflow;", "", "    // Add the current ETH overflow for each terminal.", "    for (uint256 _i = 0; _i < _terminals.length; _i++)", "      _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);", "", "    // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals.", "    uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH", "      ? _ethOverflow", "      : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));", "", "    // Adjust the decimals of the fixed point number if needed to match the target decimals.", "    return", "      (_decimals == 18)", "        ? _totalOverflow18Decimal", "        : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function approve(address to, uint256 tokenId)", "        public", "        override(ERC721, IERC721)", "        whenNotPaused", "        notBlacklisted(to)", "        notBlacklisted(msg.sender)", "    {", "        address owner = ERC721.ownerOf(tokenId);", "", "        if (to == owner) {", "            revert Errors.ERC721_APPROVAL_TO_CURRENT_OWNER();", "        }", "", "        if (_msgSender() != owner && !isApprovedForAll(owner, _msgSender())) {", "            revert Errors.ERC721_APPROVE_CALLER_IS_NOT_TOKEN_OWNER_OR_APPROVED_FOR_ALL();", "        }", "", "        _approve(to, tokenId);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function setContract(Contracts c, address contractAddress)", "        external", "        onlyOwner", "    {", "        if (contractAddress == address(0)) revert ZeroAddress();", "", "        emit SetContract(c, contractAddress);", "", "        if (c == Contracts.PirexFees) {", "            pirexFees = PirexFees(contractAddress);", "            return;", "        }", "", "        if (c == Contracts.RewardRouterV2) {", "            gmxRewardRouterV2 = IRewardRouterV2(contractAddress);", "            return;", "        }", "", "        if (c == Contracts.RewardTrackerGmx) {", "            rewardTrackerGmx = RewardTracker(contractAddress);", "            return;", "        }", "", "        if (c == Contracts.RewardTrackerGlp) {", "            rewardTrackerGlp = RewardTracker(contractAddress);", "            return;", "        }", "", "        if (c == Contracts.FeeStakedGlp) {", "            feeStakedGlp = RewardTracker(contractAddress);", "            return;", "        }", "", "        if (c == Contracts.StakedGmx) {", "            // Set the current stakedGmx (pending change) approval amount to 0", "            gmx.safeApprove(address(stakedGmx), 0);", "", "            stakedGmx = RewardTracker(contractAddress);", "", "            // Approve the new stakedGmx contract address allowance to the max", "            gmx.safeApprove(contractAddress, type(uint256).max);", "            return;", "        }", "", "        if (c == Contracts.StakedGlp) {", "            stakedGlp = IStakedGlp(contractAddress);", "            return;", "        }", "", "        if (c == Contracts.GmxVault) {", "            gmxVault = IVault(contractAddress);", "            return;", "        }", "", "        glpManager = contractAddress;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function sell(", "        uint256[] calldata tokenIds,", "        uint256[] calldata tokenWeights,", "        MerkleMultiProof calldata proof,", "        IStolenNftOracle.Message[] memory stolenNftProofs // put in memory to avoid stack too deep error", "    ) public returns (uint256 netOutputAmount, uint256 feeAmount, uint256 protocolFeeAmount) {", "        // ~~~ Checks ~~~ //", "", "        // calculate the sum of weights of the NFTs to sell", "        uint256 weightSum = sumWeightsAndValidateProof(tokenIds, tokenWeights, proof);", "", "        // calculate the net output amount and fee amount", "        (netOutputAmount, feeAmount, protocolFeeAmount) = sellQuote(weightSum);", "", "        //  check the nfts are not stolen", "        if (useStolenNftOracle) {", "            IStolenNftOracle(stolenNftOracle).validateTokensAreNotStolen(nft, tokenIds, stolenNftProofs);", "        }", "", "        // ~~~ Effects ~~~ //", "", "        // update the virtual reserves", "        virtualBaseTokenReserves -= uint128(netOutputAmount + protocolFeeAmount + feeAmount);", "        virtualNftReserves += uint128(weightSum);", "", "        // ~~~ Interactions ~~~ //", "", "        uint256 royaltyFeeAmount = 0;", "        for (uint256 i = 0; i < tokenIds.length; i++) {", "            // transfer each nft from the caller", "            ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);", "", "            if (payRoyalties) {", "                // calculate the sale price (assume it's the same for each NFT even if weights differ)", "                uint256 salePrice = (netOutputAmount + feeAmount + protocolFeeAmount) / tokenIds.length;", "", "                // get the royalty fee for the NFT", "                (uint256 royaltyFee, address recipient) = _getRoyalty(tokenIds[i], salePrice);", "", "                // tally the royalty fee amount", "                royaltyFeeAmount += royaltyFee;", "", "                // transfer the royalty fee to the recipient if it's greater than 0", "                if (royaltyFee > 0 && recipient != address(0)) {", "                    if (baseToken != address(0)) {", "                        ERC20(baseToken).safeTransfer(recipient, royaltyFee);", "                    } else {", "                        recipient.safeTransferETH(royaltyFee);", "                    }", "                }", "            }", "        }", "", "        // subtract the royalty fee amount from the net output amount", "        netOutputAmount -= royaltyFeeAmount;", "", "        if (baseToken == address(0)) {", "            // transfer ETH to the caller", "            msg.sender.safeTransferETH(netOutputAmount);", "", "            // if the protocol fee is set then pay the protocol fee", "            if (protocolFeeAmount > 0) factory.safeTransferETH(protocolFeeAmount);", "        } else {", "            // transfer base tokens to the caller", "            ERC20(baseToken).transfer(msg.sender, netOutputAmount);", "", "            // if the protocol fee is set then pay the protocol fee", "            if (protocolFeeAmount > 0) ERC20(baseToken).safeTransfer(address(factory), protocolFeeAmount);", "        }", "", "        // emit the sell event", "        emit Sell(tokenIds, tokenWeights, netOutputAmount, feeAmount, protocolFeeAmount, royaltyFeeAmount);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function register(", "        string calldata name,", "        address owner,", "        uint256 duration,", "        bytes32 secret,", "        address resolver,", "        bytes[] calldata data,", "        bool reverseRecord,", "        uint32 fuses,", "        uint64 wrapperExpiry", "    ) public payable override {", "        IPriceOracle.Price memory price = rentPrice(name, duration);", "        require(", "            msg.value >= (price.base + price.premium),", "            \"ETHRegistrarController: Not enough ether provided\"", "        );", "", "        _consumeCommitment(", "            name,", "            duration,", "            makeCommitment(", "                name,", "                owner,", "                duration,", "                secret,", "                resolver,", "                data,", "                reverseRecord,", "                fuses,", "                wrapperExpiry", "            )", "        );", "", "        uint256 expires = nameWrapper.registerAndWrapETH2LD(", "            name,", "            owner,", "            duration,", "            resolver,", "            fuses,", "            wrapperExpiry", "        );", "", "        _setRecords(resolver, keccak256(bytes(name)), data);", "", "        if (reverseRecord) {", "            _setReverseRecord(name, resolver, msg.sender);", "        }", "", "        emit NameRegistered(", "            name,", "            keccak256(bytes(name)),", "            owner,", "            price.base,", "            price.premium,", "            expires", "        );", "", "        if (msg.value > (price.base + price.premium)) {", "            payable(msg.sender).transfer(", "                msg.value - (price.base + price.premium)", "            );", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0]}
{"tokens": ["    function _initializeDiamondCut(address _init, bytes memory _calldata) private {", "        if (_init == address(0)) {", "            require(_calldata.length == 0, \"H\"); // Non-empty calldata for zero address", "        } else {", "            // Do not check whether `_init` is a contract since later we check that it returns data.", "            (bool success, bytes memory data) = _init.delegatecall(_calldata);", "            require(success, \"I\"); // delegatecall failed", "", "            // Check that called contract returns magic value to make sure that contract logic", "            // supposed to be used as diamond cut initializer.", "            require(data.length == 32, \"lp\");", "            require(abi.decode(data, (bytes32)) == DIAMOND_INIT_SUCCESS_RETURN_VALUE, \"lp1\");", "        }", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function collectPenalty() external {", "        uint256 amount = penaltyAccumulated;", "        penaltyAccumulated = 0;", "        require(token.transfer(penaltyRecipient, amount), \"Transfer failed\");", "        emit CollectPenalty(amount, penaltyRecipient);", "    }"], "ner_tags": [0, 0, 0, 1, 0, 0]}
{"tokens": ["    function _updateBucketExchangeRates(", "        address pool_,", "        uint256[] memory indexes_", "    ) internal returns (uint256 updatedRewards_) {", "        // get the current burn epoch from the given pool", "        uint256 curBurnEpoch = IPool(pool_).currentBurnEpoch();", "", "        // update exchange rates only if the pool has not yet burned any tokens without calculating any reward", "        if (curBurnEpoch == 0) {", "            for (uint256 i = 0; i < indexes_.length; ) {", "", "                _updateBucketExchangeRate(", "                    pool_,", "                    indexes_[i],", "                    curBurnEpoch", "                );", "", "                // iterations are bounded by array length (which is itself bounded), preventing overflow / underflow", "                unchecked { ++i; }", "            }", "        }", "", "        else {", "            // retrieve accumulator values used to calculate rewards accrued", "            (", "                uint256 curBurnTime,", "                uint256 totalBurned,", "                uint256 totalInterestEarned", "            ) = _getPoolAccumulators(pool_, curBurnEpoch, curBurnEpoch - 1);", "", "            if (block.timestamp <= curBurnTime + UPDATE_PERIOD) {", "", "                // update exchange rates and calculate rewards if tokens were burned and within allowed time period", "                for (uint256 i = 0; i < indexes_.length; ) {", "", "                    // calculate rewards earned for updating bucket exchange rate", "                    updatedRewards_ += _updateBucketExchangeRateAndCalculateRewards(", "                        pool_,", "                        indexes_[i],", "                        curBurnEpoch,", "                        totalBurned,", "                        totalInterestEarned", "                    );", "", "                    // iterations are bounded by array length (which is itself bounded), preventing overflow / underflow", "                    unchecked { ++i; }", "                }", "", "                uint256 rewardsCap            = Maths.wmul(UPDATE_CAP, totalBurned);", "                uint256 rewardsClaimedInEpoch = updateRewardsClaimed[curBurnEpoch];", "", "                // update total tokens claimed for updating bucket exchange rates tracker", "                if (rewardsClaimedInEpoch + updatedRewards_ >= rewardsCap) {", "                    // if update reward is greater than cap, set to remaining difference", "                    updatedRewards_ = rewardsCap - rewardsClaimedInEpoch;", "                }", "", "                // accumulate the full amount of additional rewards", "                updateRewardsClaimed[curBurnEpoch] += updatedRewards_;", "            }", "        }", "", "        // emit event with the list of bucket indexes updated", "        emit UpdateExchangeRates(msg.sender, pool_, indexes_, updatedRewards_);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function settleFunding()", "        override", "        external", "        onlyClearingHouse", "    {", "        if (ammState != AMMState.Active) return;", "        require(_blockTimestamp() >= nextFundingTime, \"settle funding too early\");", "", "        // premium = twapMarketPrice - twapIndexPrice", "        // timeFraction = fundingPeriod(1 hour) / 1 day", "        // premiumFraction = premium * timeFraction", "        int256 underlyingPrice = getUnderlyingTwapPrice(spotPriceTwapInterval);", "        int256 premium = getTwapPrice(spotPriceTwapInterval) - underlyingPrice;", "        int256 premiumFraction = (premium * int256(fundingPeriod)) / 1 days;", "", "        // update funding rate = premiumFraction / twapIndexPrice", "        _updateFundingRate(premiumFraction, underlyingPrice);", "", "        int256 premiumPerDtoken = posAccumulator * premiumFraction;", "", "        // makers pay slightly more to account for rounding off", "        premiumPerDtoken = (premiumPerDtoken / BASE_PRECISION) + 1;", "", "        cumulativePremiumFraction += premiumFraction;", "        cumulativePremiumPerDtoken += premiumPerDtoken;", "", "        // Updates for next funding event", "        // in order to prevent multiple funding settlement during very short time after network congestion", "        uint256 minNextValidFundingTime = _blockTimestamp() + fundingBufferPeriod;", "", "        // floor((nextFundingTime + fundingPeriod) / 3600) * 3600", "        uint256 nextFundingTimeOnHourStart = ((nextFundingTime + fundingPeriod) / 1 hours) * 1 hours;", "", "        // max(nextFundingTimeOnHourStart, minNextValidFundingTime)", "        nextFundingTime = nextFundingTimeOnHourStart > minNextValidFundingTime", "            ? nextFundingTimeOnHourStart", "            : minNextValidFundingTime;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function harvest() external override returns (int256 roi) {", "        _atLeastRole(KEEPER);", "        int256 availableCapital = IVault(vault).availableCapital();", "        uint256 debt = 0;", "        if (availableCapital < 0) {", "            debt = uint256(-availableCapital);", "        }", "", "        uint256 repayment = 0;", "        if (emergencyExit) {", "            uint256 amountFreed = _liquidateAllPositions();", "            if (amountFreed < debt) {", "                roi = -int256(debt - amountFreed);", "            } else if (amountFreed > debt) {", "                roi = int256(amountFreed - debt);", "            }", "", "            repayment = debt;", "            if (roi < 0) {", "                repayment -= uint256(-roi);", "            }", "        } else {", "            (roi, repayment) = _harvestCore(debt);", "        }", "", "        debt = IVault(vault).report(roi, repayment);", "        _adjustPosition(debt);", "", "        lastHarvestTimestamp = block.timestamp;", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function batchDepositERC721(", "        address _from,", "        address _to,", "        address[] calldata _tokens,", "        uint256[] calldata _ids", "    ) external {", "        for (uint256 i = 0; i < _tokens.length; ) {", "            IERC721(_tokens[i]).safeTransferFrom(_from, _to, _ids[i]);", "            unchecked {", "                ++i;", "            }", "        }", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _safeTransfer(", "        address from,", "        address to,", "        uint256 tokenId,", "        bytes memory", "    ) internal virtual {", "        _transfer(from, to, tokenId);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function refresh() public virtual override {", "        try this.tryPrice() returns (uint192 low, uint192 high, uint192) {", "            // {UoA/tok}, {UoA/tok}", "            // (0, 0) is a valid price; (0, FIX_MAX) is unpriced", "", "            // Save prices if priced", "            if (high < FIX_MAX) {", "                savedLowPrice = low;", "                savedHighPrice = high;", "                lastSave = uint48(block.timestamp);", "            } else {", "                // must be unpriced", "                assert(low == 0);", "            }", "        } catch (bytes memory errData) {", "            // see: docs/solidity-style.md#Catching-Empty-Data", "            if (errData.length == 0) revert(); // solhint-disable-line reason-string", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["    function withdrawAllAndUnwrap(", "        bool claim,", "        bool sendToOperator", "    ) external onlyOwner {", "        IBaseRewardPool(cvxPoolInfo.rewards).withdrawAllAndUnwrap(claim);", "        if (sendToOperator) {", "            uint256 totalBalance = clpToken.balanceOf(address(this));", "            clpToken.safeTransfer(operator, totalBalance);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["    function _finalize(uint96 totalContributions_) internal {", "        // Finalize the crowdfund.", "        delete expiry;", "", "        // Update the party's total voting power.", "        uint96 newVotingPower = (totalContributions_ * exchangeRateBps) / 1e4;", "        party.increaseTotalVotingPower(newVotingPower);", "", "        // Transfer fee to recipient if applicable.", "        address payable fundingSplitRecipient_ = fundingSplitRecipient;", "        uint16 fundingSplitBps_ = fundingSplitBps;", "        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {", "            uint96 feeAmount = (totalContributions_ * fundingSplitBps_) / 1e4;", "            totalContributions_ -= feeAmount;", "            fundingSplitRecipient_.transferEth(feeAmount);", "        }", "", "        // Transfer ETH to the party.", "        payable(address(party)).transferEth(totalContributions_);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function handlePaymentRevert(", "        uint256 gasUsed,", "        uint256 baseGas,", "        uint256 gasPrice,", "        uint256 tokenGasPriceFactor,", "        address gasToken,", "        address payable refundReceiver", "    ) external returns (uint256 payment) {", "        uint256 startGas = gasleft();", "        // solhint-disable-next-line avoid-tx-origin", "        address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;", "        if (gasToken == address(0)) {", "            // For ETH we will only adjust the gas price to not be higher than the actual used gas price", "            payment = (gasUsed + baseGas) * (gasPrice < tx.gasprice ? gasPrice : tx.gasprice);", "            (bool success,) = receiver.call{value: payment}(\"\");", "            require(success, \"BSA011\");", "        } else {", "            payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);", "            require(transferToken(gasToken, receiver, payment), \"BSA012\");", "        }", "        uint256 requiredGas = startGas - gasleft();", "        //console.log(\"hpr %s\", requiredGas);", "        // Convert response to string and return via error message", "        revert(string(abi.encodePacked(requiredGas)));", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _safeSubmitOrder(", "        address _inputToken,", "        address _outputToken,", "        uint256 _amountToSpend,", "        uint256 _nftId,", "        Order calldata _order", "    ) private {", "        (bool success, uint256[] memory amounts) = callOperator(_order, _inputToken, _outputToken);", "        if (success) {", "            require(amounts[1] <= _amountToSpend, \"NestedFactory::_safeSubmitOrder: Overspent\");", "            if (_amountToSpend > amounts[1]) {", "                IERC20(_inputToken).safeTransfer(_msgSender(), _amountToSpend - amounts[1]);", "            }", "        } else {", "            _safeTransferWithFees(IERC20(_inputToken), _amountToSpend, _msgSender(), _nftId);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function rejectProposal(address _vault, uint256 _amount) external payable {", "        // Reverts if vault is not registered", "        (address token, uint256 id) = _verifyVault(_vault);", "        // Reverts if vault is not current owner of the assets", "        if (_verifySale(_vault)) revert NotOwner();", "        // Reverts if collateral is less than amount of rejected tokens", "        Listing storage proposedListing = proposedListings[_vault];", "        if (proposedListing.collateral < _amount) revert InsufficientCollateral();", "        // Reverts if payment amount is incorrect", "        if (proposedListing.pricePerToken * _amount != msg.value) revert InvalidPayment();", "", "        // Store proposer in memory", "        address proposer = proposedListing.proposer;", "", "        // Decrements collateral amount", "        proposedListing.collateral -= _amount;", "", "        // Checks if proposed listing has been rejected", "        if (proposedListing.collateral == 0) {", "            // Resets proposed listing to default", "            _setListing(proposedListing, address(this), 0, type(uint256).max, 0);", "        }", "", "        // Transfers tokens to caller", "        IERC1155(token).safeTransferFrom(address(this), msg.sender, id, _amount, \"\");", "        // Sends ether to proposer", "        _sendEthOrWeth(proposer, msg.value);", "", "        // Emits event for rejecting a proposed listing", "        emit RejectProposal(_vault, msg.sender, _amount, msg.value, proposedListing.order);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _transferInputTokens(", "        uint256 _nftId,", "        IERC20 _inputToken,", "        uint256 _inputTokenAmount,", "        bool _fromReserve", "    ) private returns (IERC20, uint256) {", "        if (address(_inputToken) == ETH) {", "            require(address(this).balance >= _inputTokenAmount, \"NF: INVALID_AMOUNT_IN\");", "            weth.deposit{ value: _inputTokenAmount }();", "            return (IERC20(address(weth)), _inputTokenAmount);", "        }", "", "        uint256 balanceBefore = _inputToken.balanceOf(address(this));", "        if (_fromReserve) {", "            require(", "                nestedRecords.getAssetHolding(_nftId, address(_inputToken)) >= _inputTokenAmount,", "                \"NF: INSUFFICIENT_AMOUNT_IN\"", "            );", "            // Get input from reserve", "            reserve.withdraw(IERC20(_inputToken), _inputTokenAmount);", "        } else {", "            _inputToken.safeTransferFrom(_msgSender(), address(this), _inputTokenAmount);", "        }", "        return (_inputToken, _inputToken.balanceOf(address(this)) - balanceBefore);", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function deposit(uint256 _amount)", "        external", "        override", "        nonReentrant", "        returns (uint256)", "    {", "        require(_depositsAllowed, \"Deposits not allowed\");", "        _baseToken.safeTransferFrom(msg.sender, address(this), _amount);", "        // Calculate fees and shares to mint including latent contract funds", "        uint256 _amountToDeposit = _baseToken.balanceOf(address(this));", "        // Record deposit before fee is taken", "        if (address(_depositHook) != address(0)) {", "            _depositHook.hook(msg.sender, _amount, _amountToDeposit);", "        }", "        /**", "         * Add 1 to avoid rounding to zero, only process deposit if user is", "         * depositing an amount large enough to pay a fee.", "         */", "        uint256 _fee = (_amountToDeposit * _mintingFee) / FEE_DENOMINATOR + 1;", "        require(_amountToDeposit > _fee, \"Deposit amount too small\");", "        _baseToken.safeTransfer(_treasury, _fee);", "        _amountToDeposit -= _fee;", "", "        uint256 _valueBefore = _strategyController.totalValue();", "        _baseToken.approve(address(_strategyController), _amountToDeposit);", "        _strategyController.deposit(_amountToDeposit);", "        uint256 _valueAfter = _strategyController.totalValue();", "        _amountToDeposit = _valueAfter - _valueBefore;", "", "        uint256 _shares = 0;", "        if (totalSupply() == 0) {", "            _shares = _amountToDeposit;", "        } else {", "            /**", "             * # of shares owed = amount deposited / cost per share, cost per", "             * share = total supply / total value.", "             */", "            _shares = (_amountToDeposit * totalSupply()) / (_valueBefore);", "        }", "        _mint(msg.sender, _shares);", "        return _shares;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0]}
{"tokens": ["    function _returnETHIfAny(address recipient) internal {", "        assembly {", "            if gt(selfbalance(), 0) {", "                let status := call(gas(), recipient, selfbalance(), 0, 0, 0, 0)", "            }", "        }", "    }"], "ner_tags": [0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["  function priceFor(", "    uint256 _currency,", "    uint256 _base,", "    uint256 _decimals", "  ) external view override returns (uint256) {", "    // If the currency is the base, return 1 since they are priced the same. Include the desired number of decimals.", "    if (_currency == _base) return 10**_decimals;", "", "    // Get a reference to the feed.", "    IJBPriceFeed _feed = feedFor[_currency][_base];", "", "    // If it exists, return the price.", "    if (_feed != IJBPriceFeed(address(0))) return _feed.currentPrice(_decimals);", "", "    // Get the inverse feed.", "    _feed = feedFor[_base][_currency];", "", "    // If it exists, return the inverse price.", "    if (_feed != IJBPriceFeed(address(0)))", "      return PRBMath.mulDiv(10**_decimals, 10**_decimals, _feed.currentPrice(_decimals));", "", "    // No price feed available, revert.", "    revert PRICE_FEED_NOT_FOUND();", "  }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function pnl(bool _direction, uint _currentPrice, uint _price, uint _margin, uint _leverage, int256 accInterest) external pure returns (uint256 _positionSize, int256 _payout) {", "        unchecked {", "            uint _initPositionSize = _margin * _leverage / 1e18;", "            if (_direction && _currentPrice >= _price) {", "                _payout = int256(_margin) + int256(_initPositionSize * (1e18 * _currentPrice / _price - 1e18)/1e18) + accInterest;", "            } else if (_direction && _currentPrice < _price) {", "                _payout = int256(_margin) - int256(_initPositionSize * (1e18 - 1e18 * _currentPrice / _price)/1e18) + accInterest;", "            } else if (!_direction && _currentPrice <= _price) {", "                _payout = int256(_margin) + int256(_initPositionSize * (1e18 - 1e18 * _currentPrice / _price)/1e18) + accInterest;", "            } else {", "                _payout = int256(_margin) - int256(_initPositionSize * (1e18 * _currentPrice / _price - 1e18)/1e18) + accInterest;", "            }", "            _positionSize = _initPositionSize * _currentPrice / _price;", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["    function execute(Input calldata sell, Input calldata buy)", "        external", "        payable", "        whenOpen", "        setupExecution", "    {", "        _execute(sell, buy);", "        _returnDust();", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function getCurrentPrice(address _asset)", "        external", "        view", "        override(ProviderOracleManager, IProviderOracleManager)", "        returns (uint256)", "    {", "        address assetOracle = getAssetOracle(_asset);", "        IEACAggregatorProxy aggregator = IEACAggregatorProxy(assetOracle);", "        int256 answer = aggregator.latestAnswer();", "        require(", "            answer > 0,", "            \"ChainlinkOracleManager: No pricing data available\"", "        );", "", "        return", "            uint256(answer)", "                .fromScaledUint(CHAINLINK_ORACLE_DECIMALS)", "                .toScaledUint(strikeAssetDecimals, true);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["\tfunction inflate() internal {", "\t\tProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));", "\t\tuint256 inflationIntervalElapsedSeconds = (block.timestamp - getInflationIntervalStartTime());", "\t\t(uint256 currentTotalSupply, uint256 newTotalSupply) = getInflationAmt();", "", "\t\tTokenGGP ggp = TokenGGP(getContractAddress(\"TokenGGP\"));", "\t\tif (newTotalSupply > ggp.totalSupply()) {", "\t\t\trevert MaximumTokensReached();", "\t\t}", "", "\t\tuint256 newTokens = newTotalSupply - currentTotalSupply;", "", "\t\temit GGPInflated(newTokens);", "", "\t\tdao.setTotalGGPCirculatingSupply(newTotalSupply);", "", "\t\taddUint(keccak256(\"RewardsPool.InflationIntervalStartTime\"), inflationIntervalElapsedSeconds);", "\t\tsetUint(keccak256(\"RewardsPool.RewardsCycleTotalAmt\"), newTokens);", "\t}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["    function calculateAuctionPriceMultiplier(", "        uint256 auctionStartTimestamp,", "        uint256 currentTimestamp", "    ) external view override returns (uint256) {", "        uint256 ticks = PRBMathUD60x18.div(", "            currentTimestamp - auctionStartTimestamp,", "            _tickLength", "        );", "        return _calculateAuctionPriceMultiplierByTicks(ticks);", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function receiveRandomNumber(uint256 randomNumber) internal override onlyWhenExecutingDraw {", "        uint120 _winningTicket = TicketUtils.reconstructTicket(randomNumber, selectionSize, selectionMax);", "        uint128 drawFinalized = currentDraw++;", "        uint256 jackpotWinners = unclaimedCount[drawFinalized][_winningTicket];", "", "        if (jackpotWinners > 0) {", "            winAmount[drawFinalized][selectionSize] = drawRewardSize(drawFinalized, selectionSize) / jackpotWinners;", "        } else {", "            for (uint8 winTier = 1; winTier < selectionSize; ++winTier) {", "                winAmount[drawFinalized][winTier] = drawRewardSize(drawFinalized, winTier);", "            }", "        }", "", "        currentNetProfit = LotteryMath.calculateNewProfit(", "            currentNetProfit,", "            ticketsSold[drawFinalized],", "            ticketPrice,", "            jackpotWinners > 0,", "            fixedReward(selectionSize),", "            expectedPayout", "        );", "        winningTicket[drawFinalized] = _winningTicket;", "        drawExecutionInProgress = false;", "", "        uint256 ticketsSoldDuringDraw = nextTicketId - lastDrawFinalTicketId;", "        lastDrawFinalTicketId = nextTicketId;", "        referralDrawFinalize(drawFinalized, ticketsSoldDuringDraw);", "", "        emit FinishedExecutingDraw(drawFinalized, randomNumber, _winningTicket);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function mint(address user, uint256 amount) external returns (bool) {", "        require(configurator.tokenMiner(msg.sender), \"not authorized\");", "        require(totalSupply() + amount <= maxSupply, \"exceeding the maximum supply quantity.\");", "        try IProtocolRewardsPool(configurator.getProtocolRewardsPool()).refreshReward(user) {} catch {}", "        _mint(user, amount);", "        return true;", "    }"], "ner_tags": [0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["    event MutualConsentRegistered(", "        bytes32 _consentHash", "    );"], "ner_tags": [1, 1, 1]}
{"tokens": ["  function declareReward(uint256 amount)", "    external", "    onlyRoleMalt(REWARDER_ROLE, \"Only rewarder role\")", "    onlyActive", "  {", "    _rewardCheck(amount);", "", "    if (rewardMine.totalBonded() == 0) {", "      // There is no accounts to distribute the rewards to so forfeit it", "      _forfeit(amount);", "      return;", "    }", "", "    uint256 vestingBondedValue = vestingDistributor.bondedValue();", "    uint256 currentlyVested = vestingDistributor.getCurrentlyVested();", "", "    uint256 netVest = currentlyVested - previouslyVested;", "    uint256 netTime = block.timestamp - previouslyVestedTimestamp;", "", "    if (netVest == 0 || vestingBondedValue == 0) {", "      return;", "    }", "", "    uint256 linearBondedValue = rewardMine.valueOfBonded();", "", "    uint256 distributed = (linearBondedValue * netVest) / vestingBondedValue;", "    uint256 balance = collateralToken.balanceOf(address(this));", "", "    if (distributed > balance) {", "      distributed = balance;", "    }", "", "    if (distributed > 0) {", "      // Send vested amount to liquidity mine", "      collateralToken.safeTransfer(address(rewardMine), distributed);", "      rewardMine.releaseReward(distributed);", "    }", "", "    balance = collateralToken.balanceOf(address(this));", "", "    uint256 buf = bufferTime; // gas", "    uint256 bufferRequirement;", "", "    if (netTime < buf) {", "      bufferRequirement = (distributed * buf * 10000) / netTime / 10000;", "    } else {", "      bufferRequirement = distributed;", "    }", "", "    if (balance > bufferRequirement) {", "      // We have more than the buffer required. Forfeit the rest", "      uint256 net = balance - bufferRequirement;", "      _forfeit(net);", "    }", "", "    previouslyVested = currentlyVested;", "    previouslyVestedTimestamp = block.timestamp;", "", "    emit DeclareReward(amount, distributed, address(collateralToken));", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _transferAndBurnFuses(", "        bytes32 node,", "        address newOwner,", "        uint32 fuses,", "        uint64 expiry", "    ) internal {", "        (address owner, , ) = getData(uint256(node));", "        _transfer(owner, newOwner, uint256(node), 1, \"\");", "        _setFuses(node, newOwner, fuses, expiry);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 0]}
{"tokens": ["    function insert(", "        uint256 id, //maker (ask) id", "        uint256 pos //position to insert into", "    ) public returns (bool) {", "        require(!locked, \"Reentrancy attempt\");", "        require(!isOfferSorted(id)); //make sure offers[id] is not yet sorted", "        require(isActive(id)); //make sure offers[id] is active", "", "        _hide(id); //remove offer from unsorted offers list", "        _sort(id, pos); //put offer into the sorted offers list", "        emit LogInsert(msg.sender, id);", "        return true;", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function claimRewards(LotteryRewardType rewardType) external override returns (uint256 claimedAmount) {", "        address beneficiary = (rewardType == LotteryRewardType.FRONTEND) ? msg.sender : stakingRewardRecipient;", "        claimedAmount = LotteryMath.calculateRewards(ticketPrice, dueTicketsSoldAndReset(beneficiary), rewardType);", "", "        emit ClaimedRewards(beneficiary, claimedAmount, rewardType);", "        rewardToken.safeTransfer(beneficiary, claimedAmount);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function addPool(", "        address _lptoken,", "        address _gauge,", "        uint256 _stashVersion", "    ) external returns (bool) {", "        require(msg.sender == poolManager && !isShutdown, \"!add\");", "        require(_gauge != address(0) && _lptoken != address(0), \"!param\");", "", "        //the next pool's pid", "        uint256 pid = poolInfo.length;", "", "        //create a tokenized deposit", "        address token = ITokenFactory(tokenFactory).CreateDepositToken(_lptoken);", "        //create a reward contract for veAsset rewards", "        address newRewardPool = IRewardFactory(rewardFactory).CreateVeAssetRewards(pid, token);", "", "        //create a stash to handle extra incentives", "        address stash = IStashFactory(stashFactory).CreateStash(", "            pid,", "            veAsset,", "            _gauge,", "            staker,", "            _stashVersion", "        );", "", "        //add the new pool", "        poolInfo.push(", "            PoolInfo({", "                lptoken: _lptoken,", "                token: token,", "                gauge: _gauge,", "                veAssetRewards: newRewardPool,", "                stash: stash,", "                shutdown: false", "            })", "        );", "        gaugeMap[_gauge] = true;", "", "        //give stashes access to rewardfactory and voteproxy", "        //   voteproxy so it can grab the incentive tokens off the contract after claiming rewards", "        //   reward factory so that stashes can make new extra reward contracts if a new incentive is added to the gauge", "        if (stash != address(0)) {", "            poolInfo[pid].stash = stash;", "            IStaker(staker).setStashAccess(stash, true);", "            IRewardFactory(rewardFactory).setAccess(stash, true);", "        }", "        emit PoolAdded(_lptoken, _gauge, token, newRewardPool);", "", "        return true;", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _writeCheckpoint(", "        address _account,", "        uint256 _id,", "        uint256 _prevTotalVotes,", "        uint256 _newTotalVotes", "    ) private {", "        // Get the pointer to store the checkpoint", "        Checkpoint storage checkpoint = checkpoints[_account][_id];", "", "        // Record the updated voting weight and current time", "        checkpoint.votes = uint192(_newTotalVotes);", "        checkpoint.timestamp = uint64(block.timestamp);", "", "        emit DelegateVotesChanged(_account, _prevTotalVotes, _newTotalVotes);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0]}
{"tokens": ["    function changePayees(address[] calldata newPayees, uint256[] calldata newShares) external override onlyManager {", "        if (newPayees.length != newShares.length) {", "            revert Errors.PAYEES_AND_SHARES_MISMATCHED(newPayees.length, newShares.length);", "        }", "        if (newPayees.length == 0) {", "            revert Errors.NO_PAYEES();", "        }", "", "        _releaseIfAvailableIncome();", "", "        uint256 payeesLength = _payees.length();", "", "        if (payeesLength > 0) {", "            for (uint256 i = payeesLength; i > 0; i--) {", "                address payee = _payees.at(i - 1);", "                _payees.remove(payee);", "                delete _shares[payee];", "                emit PayeeRemoved(payee);", "            }", "            _totalShares = 0;", "        }", "", "        for (uint256 i; i < newPayees.length; i++) {", "            if (newPayees[i] == address(0)) {", "                revert Errors.CANNOT_SET_TO_ADDRESS_ZERO();", "            }", "            if (newShares[i] == 0) {", "                revert Errors.SHARE_CANNOT_BE_ZERO();", "            }", "", "            address payee = newPayees[i];", "            _payees.add(payee);", "            _shares[payee] = newShares[i];", "            _totalShares += newShares[i];", "", "            emit PayeeAdded(payee, newShares[i]);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": ["    function _mutualConsent(address _signerOne, address _signerTwo) internal returns(bool) {", "        if(msg.sender != _signerOne && msg.sender != _signerTwo) { revert Unauthorized(); }", "", "        address nonCaller = _getNonCaller(_signerOne, _signerTwo);", "", "        // The consent hash is defined by the hash of the transaction call data and sender of msg,", "        // which uniquely identifies the function, arguments, and sender.", "        bytes32 expectedHash = keccak256(abi.encodePacked(msg.data, nonCaller));", "", "        if (!mutualConsents[expectedHash]) {", "            bytes32 newHash = keccak256(abi.encodePacked(msg.data, msg.sender));", "", "            mutualConsents[newHash] = true;", "", "            emit MutualConsentRegistered(newHash);", "", "            return false;", "        }", "", "        delete mutualConsents[expectedHash];", "", "        return true;", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["\tfunction submitLogicCall(", "\t\t// The validators that approve the call", "\t\tValsetArgs memory _currentValset,", "\t\t// These are arrays of the parts of the validators signatures", "\t\tuint8[] memory _v,", "\t\tbytes32[] memory _r,", "\t\tbytes32[] memory _s,", "\t\tLogicCallArgs memory _args", "\t) public nonReentrant {", "\t\t// CHECKS scoped to reduce stack depth", "\t\t{", "\t\t\t// Check that the call has not timed out", "\t\t\trequire(block.number < _args.timeOut, \"Timed out\");", "", "\t\t\t// Check that the invalidation nonce is higher than the last nonce for this invalidation Id", "\t\t\trequire(", "\t\t\t\tstate_invalidationMapping[_args.invalidationId] < _args.invalidationNonce,", "\t\t\t\t\"New invalidation nonce must be greater than the current nonce\"", "\t\t\t);", "", "\t\t\t// Check that current validators, powers, and signatures (v,r,s) set is well-formed", "\t\t\trequire(", "\t\t\t\t_currentValset.validators.length == _currentValset.powers.length &&", "\t\t\t\t\t_currentValset.validators.length == _v.length &&", "\t\t\t\t\t_currentValset.validators.length == _r.length &&", "\t\t\t\t\t_currentValset.validators.length == _s.length,", "\t\t\t\t\"Malformed current validator set\"", "\t\t\t);", "", "\t\t\t// Check that the supplied current validator set matches the saved checkpoint", "\t\t\trequire(", "\t\t\t\tmakeCheckpoint(_currentValset, state_gravityId) == state_lastValsetCheckpoint,", "\t\t\t\t\"Supplied current validators and powers do not match checkpoint.\"", "\t\t\t);", "", "\t\t\t// Check that the token transfer list is well-formed", "\t\t\trequire(", "\t\t\t\t_args.transferAmounts.length == _args.transferTokenContracts.length,", "\t\t\t\t\"Malformed list of token transfers\"", "\t\t\t);", "", "\t\t\t// Check that the fee list is well-formed", "\t\t\trequire(", "\t\t\t\t_args.feeAmounts.length == _args.feeTokenContracts.length,", "\t\t\t\t\"Malformed list of fees\"", "\t\t\t);", "\t\t\trequire(", "\t\t\t\tisOrchestrator(_currentValset, msg.sender),", "\t\t\t\t\"The sender of the transaction is not validated orchestrator\"", "\t\t\t);", "\t\t}", "", "\t\tbytes32 argsHash = keccak256(", "\t\t\tabi.encode(", "\t\t\t\tstate_gravityId,", "\t\t\t\t// bytes32 encoding of \"logicCall\"", "\t\t\t\t0x6c6f67696343616c6c0000000000000000000000000000000000000000000000,", "\t\t\t\t_args.transferAmounts,", "\t\t\t\t_args.transferTokenContracts,", "\t\t\t\t_args.feeAmounts,", "\t\t\t\t_args.feeTokenContracts,", "\t\t\t\t_args.logicContractAddress,", "\t\t\t\t_args.payload,", "\t\t\t\t_args.timeOut,", "\t\t\t\t_args.invalidationId,", "\t\t\t\t_args.invalidationNonce", "\t\t\t)", "\t\t);", "", "\t\t{", "\t\t\t// Check that enough current validators have signed off on the transaction batch and valset", "\t\t\tcheckValidatorSignatures(", "\t\t\t\t_currentValset.validators,", "\t\t\t\t_currentValset.powers,", "\t\t\t\t_v,", "\t\t\t\t_r,", "\t\t\t\t_s,", "\t\t\t\t// Get hash of the transaction batch and checkpoint", "\t\t\t\targsHash,", "\t\t\t\tstate_powerThreshold", "\t\t\t);", "\t\t}", "", "\t\t// ACTIONS", "", "\t\t// Update invaldiation nonce", "\t\tstate_invalidationMapping[_args.invalidationId] = _args.invalidationNonce;", "", "\t\t// Send tokens to the logic contract", "\t\tfor (uint256 i = 0; i < _args.transferAmounts.length; i++) {", "\t\t\tIERC20(_args.transferTokenContracts[i]).safeTransfer(", "\t\t\t\t_args.logicContractAddress,", "\t\t\t\t_args.transferAmounts[i]", "\t\t\t);", "\t\t}", "", "\t\t// Make call to logic contract", "\t\tbytes memory returnData = Address.functionCall(_args.logicContractAddress, _args.payload);", "", "\t\t// Send fees to msg.sender", "\t\tfor (uint256 i = 0; i < _args.feeAmounts.length; i++) {", "\t\t\tIERC20(_args.feeTokenContracts[i]).safeTransfer(msg.sender, _args.feeAmounts[i]);", "\t\t}", "", "\t\t// LOGS scoped to reduce stack depth", "\t\t{", "\t\t\tstate_lastEventNonce = state_lastEventNonce.add(1);", "\t\t\temit LogicCallEvent(", "\t\t\t\t_args.invalidationId,", "\t\t\t\t_args.invalidationNonce,", "\t\t\t\treturnData,", "\t\t\t\tstate_lastEventNonce", "\t\t\t);", "\t\t}", "\t}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function removeLiquidity(uint256 _amount) external {", "        // check balance before removing liquidity", "        require(_amount <= balanceOf(msg.sender), \"Not enough lr tokens\");", "        // claim the stakingToken from previous unstakes", "        IStaking(stakingContract).claimWithdraw(address(this));", "", "        uint256 amountToWithdraw = _calculateReserveTokenValue(_amount);", "", "        // verify that we have enough stakingTokens", "        require(", "            IERC20Upgradeable(stakingToken).balanceOf(address(this)) >=", "                amountToWithdraw,", "            \"Not enough funds\"", "        );", "", "        _burn(msg.sender, _amount);", "        IERC20Upgradeable(stakingToken).safeTransfer(", "            msg.sender,", "            amountToWithdraw", "        );", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function withdrawETHForStaking(", "        address _smartWallet,", "        uint256 _amount", "    ) public onlyManager nonReentrant returns (uint256) {", "        require(_amount >= 24 ether, \"Amount cannot be less than 24 ether\");", "        require(address(this).balance >= _amount, \"Insufficient withdrawal amount\");", "        require(_smartWallet != address(0), \"Zero address\");", "        require(_smartWallet != address(this), \"This address\");", "", "        (bool result,) = _smartWallet.call{value: _amount}(\"\");", "        require(result, \"Transfer failed\");", "", "        emit ETHWithdrawnForStaking(_smartWallet, msg.sender, _amount);", "", "        return _amount;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function preBorrowHook(", "        address vToken,", "        address borrower,", "        uint256 borrowAmount", "    ) external override {", "        _checkActionPauseState(vToken, Action.BORROW);", "", "        oracle.updatePrice(vToken);", "", "        if (!markets[vToken].isListed) {", "            revert MarketNotListed(address(vToken));", "        }", "", "        if (!markets[vToken].accountMembership[borrower]) {", "            // only vTokens may call borrowAllowed if borrower not in market", "            _checkSenderIs(vToken);", "", "            // attempt to add borrower to the market or revert", "            _addToMarket(VToken(msg.sender), borrower);", "        }", "", "        if (oracle.getUnderlyingPrice(vToken) == 0) {", "            revert PriceError(address(vToken));", "        }", "", "        uint256 borrowCap = borrowCaps[vToken];", "        // Skipping the cap check for uncapped coins to save some gas", "        if (borrowCap != type(uint256).max) {", "            uint256 totalBorrows = VToken(vToken).totalBorrows();", "            uint256 nextTotalBorrows = totalBorrows + borrowAmount;", "            if (nextTotalBorrows > borrowCap) {", "                revert BorrowCapExceeded(vToken, borrowCap);", "            }", "        }", "", "        AccountLiquiditySnapshot memory snapshot = _getHypotheticalLiquiditySnapshot(", "            borrower,", "            VToken(vToken),", "            0,", "            borrowAmount,", "            _getCollateralFactor", "        );", "", "        if (snapshot.shortfall > 0) {", "            revert InsufficientLiquidity();", "        }", "", "        Exp memory borrowIndex = Exp({ mantissa: VToken(vToken).borrowIndex() });", "", "        // Keep the flywheel moving", "        uint256 rewardDistributorsCount = rewardsDistributors.length;", "", "        for (uint256 i; i < rewardDistributorsCount; ++i) {", "            rewardsDistributors[i].updateRewardTokenBorrowIndex(vToken, borrowIndex);", "            rewardsDistributors[i].distributeBorrowerRewardToken(vToken, borrower, borrowIndex);", "        }", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _withdrawAll() internal override returns (uint256) {", "        // Unstaking and withdrawing from Convex pool", "        uint256 stakedBalance = _stakedBalance();", "        if (stakedBalance > 0) {", "            if (!rewards.withdrawAndUnwrap(stakedBalance, false)) return 0;", "        }", "", "        // Removing liquidity from Curve", "        uint256 lpBalance = _lpBalance();", "        if (lpBalance > 0) {", "            curvePool.remove_liquidity_one_coin(", "                lpBalance,", "                int128(uint128(curveIndex)),", "                _minUnderlyingAccepted(lpBalance)", "            );", "        }", "", "        // Transferring underlying to vault", "        uint256 underlyingBalance = _underlyingBalance();", "        if (underlyingBalance == 0) return 0;", "        payable(vault).transfer(underlyingBalance);", "        return underlyingBalance;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["    function outboundTransfer(", "        address _l1Token,", "        address _to,", "        uint256 _amount,", "        uint256 _maxGas,", "        uint256 _gasPriceBid,", "        bytes calldata _data", "    ) external payable override notPaused returns (bytes memory) {", "        IGraphToken token = graphToken();", "        require(_l1Token == address(token), \"TOKEN_NOT_GRT\");", "        require(_amount > 0, \"INVALID_ZERO_AMOUNT\");", "        require(_to != address(0), \"INVALID_DESTINATION\");", "", "        // nested scopes to avoid stack too deep errors", "        address from;", "        uint256 seqNum;", "        {", "            uint256 maxSubmissionCost;", "            bytes memory outboundCalldata;", "            {", "                bytes memory extraData;", "                (from, maxSubmissionCost, extraData) = parseOutboundData(_data);", "                require(", "                    extraData.length == 0 || callhookWhitelist[msg.sender] == true,", "                    \"CALL_HOOK_DATA_NOT_ALLOWED\"", "                );", "                require(maxSubmissionCost > 0, \"NO_SUBMISSION_COST\");", "", "                {", "                    // makes sure only sufficient ETH is supplied as required for successful redemption on L2", "                    // if a user does not desire immediate redemption they should provide", "                    // a msg.value of AT LEAST maxSubmissionCost", "                    uint256 expectedEth = maxSubmissionCost.add(_maxGas.mul(_gasPriceBid));", "                    require(msg.value >= expectedEth, \"WRONG_ETH_VALUE\");", "                }", "                outboundCalldata = getOutboundCalldata(_l1Token, from, _to, _amount, extraData);", "            }", "            {", "                L2GasParams memory gasParams = L2GasParams(", "                    maxSubmissionCost,", "                    _maxGas,", "                    _gasPriceBid", "                );", "                // transfer tokens to escrow", "                token.transferFrom(from, escrow, _amount);", "                seqNum = sendTxToL2(", "                    inbox,", "                    l2Counterpart,", "                    from,", "                    msg.value,", "                    0,", "                    gasParams,", "                    outboundCalldata", "                );", "            }", "        }", "        emit DepositInitiated(_l1Token, from, _to, seqNum, _amount);", "", "        return abi.encode(seqNum);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function removeFilledTradeAmount(uint256 amt) external onlyPair {", "        outstandingAmount = outstandingAmount.sub(amt);", "        emit LogRemoveFilledTradeAmount(", "            IERC20(underlyingToken),", "            amt,", "            underlyingBalance(),", "            outstandingAmount,", "            totalSupply", "        );", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _addFounders(IManager.FounderParams[] calldata _founders) internal {", "        // Cache the number of founders", "        uint256 numFounders = _founders.length;", "", "        // Used to store the total percent ownership among the founders", "        uint256 totalOwnership;", "", "        unchecked {", "            // For each founder:", "            for (uint256 i; i < numFounders; ++i) {", "                // Cache the percent ownership", "                uint256 founderPct = _founders[i].ownershipPct;", "", "                // Continue if no ownership is specified", "                if (founderPct == 0) continue;", "", "                // Update the total ownership and ensure it's valid", "                if ((totalOwnership += uint8(founderPct)) > 100) revert INVALID_FOUNDER_OWNERSHIP();", "", "                // Compute the founder's id", "                uint256 founderId = settings.numFounders++;", "", "                // Get the pointer to store the founder", "                Founder storage newFounder = founder[founderId];", "", "                // Store the founder's vesting details", "                newFounder.wallet = _founders[i].wallet;", "                newFounder.vestExpiry = uint32(_founders[i].vestExpiry);", "                newFounder.ownershipPct = uint8(founderPct);", "", "                // Compute the vesting schedule", "                uint256 schedule = 100 / founderPct;", "", "                // Used to store the base token id the founder will recieve", "                uint256 baseTokenId;", "", "                // For each token to vest:", "                for (uint256 j; j < founderPct; ++j) {", "                    // Get the available token id", "                    baseTokenId = _getNextTokenId(baseTokenId);", "", "                    // Store the founder as the recipient", "                    tokenRecipient[baseTokenId] = newFounder;", "", "                    emit MintScheduled(baseTokenId, founderId, newFounder);", "", "                    // Update the base token id", "                    (baseTokenId += schedule) % 100;", "                }", "            }", "", "            // Store the founders' details", "            settings.totalOwnership = uint8(totalOwnership);", "            settings.numFounders = uint8(numFounders);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function mint(", "        Pool storage pool,", "        TimeswapV2PoolMintParam memory param,", "        uint96 blockTimestamp", "    ) external returns (uint160 liquidityAmount, uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {", "        // Update the state of the pool first for the short fee growth.", "        if (pool.liquidity != 0) updateDurationWeightBeforeMaturity(pool, blockTimestamp);", "        // Update the fee growth and fees of caller.", "        LiquidityPosition storage liquidityPosition = pool.liquidityPositions[param.to];", "", "        uint256 longAmount;", "        if (param.transaction == TimeswapV2PoolMint.GivenLiquidity) {", "            (longAmount, shortAmount) = ConstantProduct.calculateGivenLiquidityDelta(", "                pool.sqrtInterestRate,", "                liquidityAmount = param.delta.toUint160(),", "                DurationCalculation.unsafeDurationFromNowToMaturity(param.maturity, blockTimestamp),", "                true", "            );", "", "            if (longAmount == 0) Error.zeroOutput();", "            if (shortAmount == 0) Error.zeroOutput();", "        } else if (param.transaction == TimeswapV2PoolMint.GivenLong) {", "            (liquidityAmount, shortAmount) = ConstantProduct.calculateGivenLiquidityLong(", "                pool.sqrtInterestRate,", "                longAmount = param.delta,", "                DurationCalculation.unsafeDurationFromNowToMaturity(param.maturity, blockTimestamp),", "                true", "            );", "", "            if (liquidityAmount == 0) Error.zeroOutput();", "            if (shortAmount == 0) Error.zeroOutput();", "        } else if (param.transaction == TimeswapV2PoolMint.GivenShort) {", "            (liquidityAmount, longAmount) = ConstantProduct.calculateGivenLiquidityShort(", "                pool.sqrtInterestRate,", "                shortAmount = param.delta,", "                DurationCalculation.unsafeDurationFromNowToMaturity(param.maturity, blockTimestamp),", "                true", "            );", "", "            if (liquidityAmount == 0) Error.zeroOutput();", "            if (longAmount == 0) Error.zeroOutput();", "        } else if (param.transaction == TimeswapV2PoolMint.GivenLarger) {", "            (liquidityAmount, longAmount, shortAmount) = ConstantProduct.calculateGivenLiquidityLargerOrSmaller(", "                pool.sqrtInterestRate,", "                param.delta,", "                DurationCalculation.unsafeDurationFromNowToMaturity(param.maturity, blockTimestamp),", "                true", "            );", "", "            if (liquidityAmount == 0) Error.zeroOutput();", "            if (longAmount == 0) Error.zeroOutput();", "            if (shortAmount == 0) Error.zeroOutput();", "        }", "", "        // Ask the msg.sender how much long0 position and long1 position wanted.", "        (long0Amount, long1Amount, data) = ITimeswapV2PoolMintCallback(msg.sender).timeswapV2PoolMintChoiceCallback(", "            TimeswapV2PoolMintChoiceCallbackParam({", "                strike: param.strike,", "                maturity: param.maturity,", "                longAmount: longAmount,", "                shortAmount: shortAmount,", "                liquidityAmount: liquidityAmount,", "                data: param.data", "            })", "        );", "        Error.checkEnough(StrikeConversion.combine(long0Amount, long1Amount, param.strike, false), longAmount);", "", "        if (long0Amount != 0) pool.long0Balance += long0Amount;", "        if (long1Amount != 0) pool.long1Balance += long1Amount;", "", "        liquidityPosition.mint(liquidityAmount);", "        pool.liquidity += liquidityAmount;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function deployFor(address owner) public override returns (IMIMOProxy proxy) {", "    proxy = IMIMOProxy(mimoProxyBase.clone());", "    proxy.initialize();", "", "    // Transfer the ownership from this factory contract to the specified owner.", "    proxy.transferOwnership(owner);", "", "    // Mark the proxy as deployed.", "    _proxies[address(proxy)] = true;", "", "    // Log the proxy via en event.", "    emit DeployProxy(msg.sender, owner, address(proxy));", "  }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["  function _accrueInterest() private {", "    if (totalSupply == 0 || totalLiquidityBorrowed == 0) {", "      lastUpdate = block.timestamp;", "      return;", "    }", "", "    uint256 timeElapsed = block.timestamp - lastUpdate;", "    if (timeElapsed == 0) return;", "", "    uint256 _totalLiquidityBorrowed = totalLiquidityBorrowed; // SLOAD", "    uint256 totalLiquiditySupplied = totalLiquidity + _totalLiquidityBorrowed; // SLOAD", "", "    uint256 borrowRate = getBorrowRate(_totalLiquidityBorrowed, totalLiquiditySupplied);", "", "    uint256 dilutionLPRequested = (FullMath.mulDiv(borrowRate, _totalLiquidityBorrowed, 1e18) * timeElapsed) / 365 days;", "    uint256 dilutionLP = dilutionLPRequested > _totalLiquidityBorrowed ? _totalLiquidityBorrowed : dilutionLPRequested;", "    uint256 dilutionSpeculative = convertLiquidityToCollateral(dilutionLP);", "", "    totalLiquidityBorrowed = _totalLiquidityBorrowed - dilutionLP;", "    rewardPerPositionStored += FullMath.mulDiv(dilutionSpeculative, 1e18, totalPositionSize);", "    lastUpdate = block.timestamp;", "", "    emit AccrueInterest(timeElapsed, dilutionSpeculative, dilutionLP);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["\tfunction _withdrawLP () private {", "\t\tuint256 amount;", "\t\tassembly{", "\t\t\tamount := calldataload(0x24)", "\t\t}", "", "\t\t// Validate that the caller has cleared their asset timelock.", "\t\tLPPosition storage lpPosition = stakerLPPosition[msg.sender];", "\t\tif (block.timestamp < lpPosition.timelockEndTime) {", "\t\t\trevert TimelockNotCleared(lpPosition.timelockEndTime);", "\t\t}", "", "\t\t// Validate that the caller has enough staked LP tokens to withdraw.", "\t\tif (lpPosition.amount < amount) {", "\t\t\trevert NotEnoughLPTokens(amount, lpPosition.amount);", "\t\t}", "", "\t\t/*", "\t\t\tAttempt to transfer the LP tokens held in escrow by this staking contract ", "\t\t\tback to the caller.", "\t\t*/", "\t\t_assetTransfer(LP, msg.sender, amount);", "", "\t\t// Update caller staking information and asset data.", "\t\tPoolData storage pool = _pools[AssetType.LP];", "\t\tunchecked {", "\t\t\tuint256 points = amount * 100 / 1e18 * lpPosition.multiplier / _DIVISOR;", "", "\t\t\t// Update the caller's LP token stake.", "\t\t\tlpPosition.amount -= amount;", "\t\t\tlpPosition.points -= points;", "", "\t\t\t// Update the pool point weights for rewards.", "\t\t\tpool.totalPoints -= points;", "\t\t}", "", "\t\t// If all LP tokens are withdrawn, we must clear the multiplier.", "\t\tif (lpPosition.amount == 0) {", "\t\t\tlpPosition.multiplier = 0;", "\t\t}", "", "\t\t// Emit an event recording this LP withdraw.", "\t\temit Withdraw(", "\t\t\tmsg.sender,", "\t\t\tLP,", "\t\t\tamount", "\t\t);", "\t}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function distribute(", "        uint256 amount,", "        ITokenDistributor.TokenType tokenType,", "        address token,", "        uint256 tokenId", "    )", "        external", "        onlyWhenNotGloballyDisabled", "        onlyDelegateCall", "        returns (ITokenDistributor.DistributionInfo memory distInfo)", "    {", "        // Ignore if the party is calling functions on itself, like with", "        // `FractionalizeProposal` and `DistributionProposal`.", "        if (msg.sender != address(this)) {", "            // Must not require a vote to create a distribution, otherwise", "            // distributions can only be created through a distribution", "            // proposal.", "            if (_getSharedProposalStorage().opts.distributionsRequireVote) {", "                revert DistributionsRequireVoteError();", "            }", "            // Must be an active member.", "            VotingPowerSnapshot memory snap = _getLastVotingPowerSnapshotForVoter(msg.sender);", "            if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {", "                revert OnlyActiveMemberError();", "            }", "        }", "        // Prevent creating a distribution if the party has not started.", "        if (_getTotalVotingPower() == 0) {", "            revert PartyNotStartedError();", "        }", "        // Get the address of the token distributor.", "        ITokenDistributor distributor = ITokenDistributor(", "            _GLOBALS.getAddress(LibGlobals.GLOBAL_TOKEN_DISTRIBUTOR)", "        );", "        emit DistributionCreated(tokenType, token, tokenId);", "        // Create a native token distribution.", "        address payable feeRecipient_ = feeRecipient;", "        uint16 feeBps_ = feeBps;", "        if (tokenType == ITokenDistributor.TokenType.Native) {", "            return", "                distributor.createNativeDistribution{ value: amount }(this, feeRecipient_, feeBps_);", "        }", "        // Otherwise must be an ERC20 token distribution.", "        assert(tokenType == ITokenDistributor.TokenType.Erc20);", "        IERC20(token).compatTransfer(address(distributor), amount);", "        return distributor.createErc20Distribution(IERC20(token), this, feeRecipient_, feeBps_);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function getEpochStart(uint timestamp) public view returns (uint) {", "    uint bribeStart = timestamp - (timestamp % (7 days)) + BRIBE_LAG;", "    uint bribeEnd = bribeStart + DURATION - COOLDOWN;", "    return timestamp < bribeEnd ? bribeStart : bribeStart + 7 days;", "  }"], "ner_tags": [1, 0, 0, 0, 0]}
{"tokens": ["    function _mintFCashPosition(", "        ISetToken _setToken,", "        IWrappedfCashComplete _fCashPosition,", "        IERC20 _sendToken,", "        uint256 _fCashAmount,", "        uint256 _maxSendAmount", "    )", "    internal", "    returns(uint256 sentAmount)", "    {", "        if(_fCashAmount == 0) return 0;", "", "        bool fromUnderlying = _isUnderlying(_fCashPosition, _sendToken);", "", "", "        _approve(_setToken, _fCashPosition, _sendToken, _maxSendAmount);", "", "        uint256 preTradeSendTokenBalance = _sendToken.balanceOf(address(_setToken));", "        uint256 preTradeReceiveTokenBalance = _fCashPosition.balanceOf(address(_setToken));", "", "        _mint(_setToken, _fCashPosition, _maxSendAmount, _fCashAmount, fromUnderlying);", "", "", "        (sentAmount,) = _updateSetTokenPositions(", "            _setToken,", "            address(_sendToken),", "            preTradeSendTokenBalance,", "            address(_fCashPosition),", "            preTradeReceiveTokenBalance", "        );", "", "        require(sentAmount <= _maxSendAmount, \"Overspent\");", "        emit FCashMinted(_setToken, _fCashPosition, _sendToken, _fCashAmount, sentAmount);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _lend(", "        address lender,", "        uint256 tokenId,", "        TokenLoanParams memory accepted,", "        bool skim", "    ) internal {", "        TokenLoan memory loan = tokenLoan[tokenId];", "        require(loan.status == LOAN_REQUESTED, \"NFTPair: not available\");", "        TokenLoanParams memory params = tokenLoanParams[tokenId];", "", "        // Valuation has to be an exact match, everything else must be at least", "        // as good for the lender as `accepted`.", "        require(", "            params.valuation == accepted.valuation &&", "                params.duration <= accepted.duration &&", "                params.annualInterestBPS >= accepted.annualInterestBPS &&", "                params.ltvBPS >= accepted.ltvBPS,", "            \"NFTPair: bad params\"", "        );", "", "        if (params.oracle != INFTOracle(0)) {", "            (, uint256 rate) = params.oracle.get(address(this), tokenId);", "            require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, \"Oracle: price too low.\");", "        }", "", "        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);", "        // No overflow: at most 128 + 16 bits (fits in BentoBox)", "        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;", "        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;", "", "        if (skim) {", "            require(", "                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),", "                \"NFTPair: skim too much\"", "            );", "        } else {", "            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);", "        }", "        // No underflow: follows from OPEN_FEE_BPS <= BPS", "        uint256 borrowerShare = totalShare - openFeeShare;", "        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);", "        // No overflow: addends (and result) must fit in BentoBox", "        feesEarnedShare += protocolFeeShare;", "", "        loan.lender = lender;", "        loan.status = LOAN_OUTSTANDING;", "        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..", "        tokenLoan[tokenId] = loan;", "", "        emit LogLend(lender, tokenId);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function withdraw(", "        uint256 assets,", "        address receiver,", "        address owner", "    ) external override returns (uint256 shares) {", "        shares = previewWithdraw(assets); // previewWithdraw() rounds up so exactly \"assets\" are withdrawn and not 1 wei less", "        if (msg.sender != owner) _spendAllowance(owner, msg.sender, shares);", "        _withdraw(shares, receiver, owner);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["    function getBadCollateralRatio(address pool) external view returns(uint256) {", "        if(vaultBadCollateralRatio[pool] == 0) return vaultSafeCollateralRatio[pool] - 1e19;", "        return vaultBadCollateralRatio[pool];", "    }"], "ner_tags": [0, 1, 0, 0]}
{"tokens": ["    function getMetadata(uint256 proposalId_) public view returns (ProposalMetadata memory) {", "        return getProposalMetadata[proposalId_];", "    }"], "ner_tags": [1, 1, 1]}
{"tokens": ["    function end(uint256 _challengeNumber, bool postponeCollateralReturn) public {", "        Challenge storage challenge = challenges[_challengeNumber];", "        require(challenge.challenger != address(0x0));", "        require(block.timestamp >= challenge.end, \"period has not ended\");", "        // challenge must have been successful, because otherwise it would have immediately ended on placing the winning bid", "        returnCollateral(challenge, postponeCollateralReturn);", "        // notify the position that will send the collateral to the bidder. If there is no bid, send the collateral to msg.sender", "        address recipient = challenge.bidder == address(0x0) ? msg.sender : challenge.bidder;", "        (address owner, uint256 effectiveBid, uint256 volume, uint256 repayment, uint32 reservePPM) = challenge.position.notifyChallengeSucceeded(recipient, challenge.bid, challenge.size);", "        if (effectiveBid < challenge.bid) {", "            // overbid, return excess amount", "            IERC20(zchf).transfer(challenge.bidder, challenge.bid - effectiveBid);", "        }", "        uint256 reward = (volume * CHALLENGER_REWARD) / 1000_000;", "        uint256 fundsNeeded = reward + repayment;", "        if (effectiveBid > fundsNeeded){", "            zchf.transfer(owner, effectiveBid - fundsNeeded);", "        } else if (effectiveBid < fundsNeeded){", "            zchf.notifyLoss(fundsNeeded - effectiveBid); // ensure we have enough to pay everything", "        }", "        zchf.transfer(challenge.challenger, reward); // pay out the challenger reward", "        zchf.burn(repayment, reservePPM); // Repay the challenged part", "        emit ChallengeSucceeded(address(challenge.position), challenge.bid, _challengeNumber);", "        delete challenges[_challengeNumber];", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function rigidRedemption(address provider, uint256 eusdAmount) external virtual {", "        require(configurator.isRedemptionProvider(provider), \"provider is not a RedemptionProvider\");", "        require(borrowed[provider] >= eusdAmount, \"eusdAmount cannot surpass providers debt\");", "        uint256 assetPrice = getAssetPrice();", "        uint256 providerCollateralRatio = (depositedAsset[provider] * assetPrice * 100) / borrowed[provider];", "        require(providerCollateralRatio >= 100 * 1e18, \"provider's collateral ratio should more than 100%\");", "        _repay(msg.sender, provider, eusdAmount);", "        uint256 collateralAmount = (((eusdAmount * 1e18) / assetPrice) * (10000 - configurator.redemptionFee())) / 10000;", "        depositedAsset[provider] -= collateralAmount;", "        totalDepositedAsset -= collateralAmount;", "        collateralAsset.transfer(msg.sender, collateralAmount);", "        emit RigidRedemption(msg.sender, provider, eusdAmount, collateralAmount, block.timestamp);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function recordMintBestAvailableTier(uint256 _amount)", "    external", "    override", "    returns (", "      uint256 tokenId,", "      uint256 tierId,", "      uint256 leftoverAmount", "    )", "  {", "    // Keep a reference to the last tier ID.", "    uint256 _lastTierId = _lastSortIndexOf(msg.sender);", "", "    // Keep a reference to the tier being iterated on.", "    JBStored721Tier memory _storedTier;", "", "    // Keep a reference to the starting sort ID for sorting new tiers if needed.", "    // There's no need for sorting if there are currently no tiers.", "    // If there's no sort index, start with the first index.", "    uint256 _currentSortIndex = _firstSortIndexOf(msg.sender);", "", "    // Keep a reference to the best contribution floor.", "    uint256 _bestContributionFloor;", "", "    // Initialise a BitmapWord to read isRemoved", "    JBBitmapWord memory _bitmapWord = _isTierRemoved[msg.sender].readId(_currentSortIndex);", "", "    while (_currentSortIndex != 0) {", "      // Set the tier being iterated on. Tier's are 1 indexed.", "      _storedTier = _storedTierOf[msg.sender][_currentSortIndex];", "", "      // Is the current index outside the currently stored word?", "      if (_bitmapWord.refreshBitmapNeeded(_currentSortIndex))", "        _bitmapWord = _isTierRemoved[msg.sender].readId(_currentSortIndex);", "", "      // If the contribution floor has gone over, break out of the loop.", "      if (_storedTier.contributionFloor > _amount) _currentSortIndex = 0;", "      else {", "        // If the tier is not removed, check to see if it's optimal.", "        // Set the tier as the best available so far if there is still a remaining quantity.", "        if (", "          !_bitmapWord.isTierIdRemoved(_currentSortIndex) &&", "          _storedTier.contributionFloor > _bestContributionFloor &&", "          (_storedTier.remainingQuantity -", "            _numberOfReservedTokensOutstandingFor(msg.sender, _currentSortIndex, _storedTier)) !=", "          0", "        ) {", "          tierId = _currentSortIndex;", "          _bestContributionFloor = _storedTier.contributionFloor;", "        }", "", "        // Set the next sort index.", "        _currentSortIndex = _nextSortIndex(msg.sender, _currentSortIndex, _lastTierId);", "      }", "    }", "", "    // If there's no best tier, return.", "    if (tierId == 0) leftoverAmount = _amount;", "    else {", "      // Keep a reference to the best tier.", "      JBStored721Tier storage _bestStoredTier = _storedTierOf[msg.sender][tierId];", "", "      // Make the token ID.", "      unchecked {", "        // Keep a reference to the token ID.", "        tokenId = _generateTokenId(", "          tierId,", "          _bestStoredTier.initialQuantity -", "            --_bestStoredTier.remainingQuantity +", "            numberOfBurnedFor[msg.sender][tierId]", "        );", "      }", "", "      // Set the leftover amount.", "      leftoverAmount = _amount - _bestContributionFloor;", "    }", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function slurp(ERC4626 vault) external nonReentrant requiresLocalOrMasterAuth {", "        // Ensure the Safe has Fei currently boosting the Vault.", "        require(getTotalFeiBoostedForVault[vault] != 0, \"NO_FEI_BOOSTED\");", "", "        // Compute the amount of Fei interest the Safe generated by boosting the Vault.", "        uint256 interestEarned = vault.assetsOf(address(this)) - getTotalFeiBoostedForVault[vault];", "", "        // Compute what percentage of the interest earned will go back to the Safe.", "        uint256 protocolFeePercent = master.clerk().getFeePercentageForSafe(this, asset);", "", "        // Compute the amount of Fei the protocol will retain as fees.", "        uint256 protocolFeeAmount = interestEarned.mulWadDown(protocolFeePercent);", "", "        // Compute the amount of Fei the Safe will retain as interest.", "        uint256 safeInterestAmount = interestEarned - protocolFeeAmount;", "", "        // Increase the boost total proportionately.", "        totalFeiBoosted += safeInterestAmount;", "", "        unchecked {", "            // Update the total Fei held in the Vault proportionately.", "            // Cannot overflow because the total cannot be less than a single Vault.", "            getTotalFeiBoostedForVault[vault] += safeInterestAmount;", "        }", "", "        emit VaultSlurped(msg.sender, vault, protocolFeeAmount, safeInterestAmount);", "", "        // If we have unaccrued fees, withdraw them from the Vault and transfer them to the Master.", "        if (protocolFeeAmount != 0) vault.withdraw(protocolFeeAmount, address(master), address(this));", "", "        // Call the Master to allow it to update its accounting.", "        master.onSafeSlurp(asset, vault, safeInterestAmount);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function refreshedAssetPerBaseInUQ(address _asset) external override returns (uint) {", "        (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) = address(pair).currentCumulativePrices();", "        uint32 timeElapsed = blockTimestamp - blockTimestampLast;", "", "        if (timeElapsed >= MIN_UPDATE_INTERVAL) {", "            price0Average = (price0Cumulative - price0CumulativeLast) / timeElapsed;", "            price1Average = (price1Cumulative - price1CumulativeLast) / timeElapsed;", "", "            price0CumulativeLast = price0Cumulative;", "            price1CumulativeLast = price1Cumulative;", "            blockTimestampLast = blockTimestamp;", "        }", "", "        return lastAssetPerBaseInUQ(_asset);", "    }"], "ner_tags": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _saveTransferredAmount(bytes32 schainHash, address erc20Token, uint256 amount) private {", "        transferredAmount[schainHash][erc20Token] += amount;", "    }"], "ner_tags": [1, 1, 1]}
{"tokens": ["    function transferOwnership(address newOwner)", "        public", "        override(IOwnableSmartWallet, Ownable)", "    {", "        // Only the owner themselves or an address that is approved for transfers", "        // is authorized to do this", "        require(", "            isTransferApproved(owner(), msg.sender),", "            \"OwnableSmartWallet: Transfer is not allowed\"", "        ); // F: [OSW-4]", "", "        // Approval is revoked, in order to avoid unintended transfer allowance", "        // if this wallet ever returns to the previous owner", "        if (msg.sender != owner()) {", "            _setApproval(owner(), msg.sender, false); // F: [OSW-5]", "        }", "        _transferOwnership(newOwner); // F: [OSW-5]", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function _onDepositETH() internal override {", "        _setClaimedToMax(msg.sender);", "    }"], "ner_tags": [1, 1, 1]}
{"tokens": ["    function depositAssetToMint(uint256 assetAmount, uint256 mintAmount) external virtual {", "        require(assetAmount >= 1 ether, \"Deposit should not be less than 1 stETH.\");", "", "        bool success = collateralAsset.transferFrom(msg.sender, address(this), assetAmount);", "        require(success, \"TF\");", "", "        totalDepositedAsset += assetAmount;", "        depositedAsset[msg.sender] += assetAmount;", "        depositedTime[msg.sender] = block.timestamp;", "", "        if (mintAmount > 0) {", "            _mintEUSD(msg.sender, msg.sender, mintAmount, getAssetPrice());", "        }", "        emit DepositAsset(msg.sender, address(collateralAsset), assetAmount, block.timestamp);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function settleVault(address _vault, uint256 _proposalId) external {", "        // Reverts if the migration was not proposed", "        Proposal storage proposal = migrationInfo[_vault][_proposalId];", "        if (!(proposal.isCommited)) revert NotProposed();", "        // Reverts if the migration was unsuccessful", "        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);", "        if (current != State.SUCCESS) revert UnsuccessfulMigration();", "        // Reverts if the new vault has already been deployed", "        if (proposal.newVault != address(0))", "            revert NewVaultAlreadyDeployed(proposal.newVault);", "", "        // Gets the merkle root for the vault and given proposal ID", "        bytes32[] memory merkleTree = generateMerkleTree(proposal.modules);", "        bytes32 merkleRoot = getRoot(merkleTree);", "        // Deploys a new vault with set permissions and plugins", "        address newVault = IVaultRegistry(registry).create(", "            merkleRoot,", "            proposal.plugins,", "            proposal.selectors", "        );", "        // Sets address of the newly deployed vault", "        proposal.newVault = newVault;", "        // Emits event for settling the new vault", "        emit VaultMigrated(", "            _vault,", "            newVault,", "            _proposalId,", "            proposal.modules,", "            proposal.plugins,", "            proposal.selectors", "        );", "    }"], "ner_tags": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function exercise(Order memory order, uint256[] calldata floorAssetTokenIds) public payable {", "        /* ~~~ CHECKS ~~~ */", "", "        bytes32 orderHash = hashOrder(order);", "", "        // check user owns the position", "        require(ownerOf(uint256(orderHash)) == msg.sender, \"Not owner\");", "", "        // check position is long", "        require(order.isLong, \"Can only exercise long positions\");", "", "        // check position has not expired", "        require(block.timestamp < positionExpirations[uint256(orderHash)], \"Position has expired\");", "", "        // check floor asset token ids length is 0 unless the position type is put", "        !order.isCall", "            ? require(floorAssetTokenIds.length == order.floorTokens.length, \"Wrong amount of floor tokenIds\")", "            : require(floorAssetTokenIds.length == 0, \"Invalid floor tokenIds length\");", "", "        /* ~~~ EFFECTS ~~~ */", "", "        // send the long position to 0xdead.", "        // instead of doing a standard burn by sending to 0x000...000, sending", "        // to 0xdead ensures that the same position id cannot be minted again.", "        transferFrom(msg.sender, address(0xdead), uint256(orderHash));", "", "        // mark the position as exercised", "        exercisedPositions[uint256(orderHash)] = true;", "", "        emit ExercisedOrder(orderHash, floorAssetTokenIds, order);", "", "        /* ~~~ INTERACTIONS ~~~ */", "", "        if (order.isCall) {", "            // -- exercising a call option", "", "            // transfer strike from exerciser to putty", "            // handle the case where the taker uses native ETH instead of WETH to pay the strike", "            if (weth == order.baseAsset && msg.value > 0) {", "                // check enough ETH was sent to cover the strike", "                require(msg.value == order.strike, \"Incorrect ETH amount sent\");", "", "                // convert ETH to WETH", "                // we convert the strike ETH to WETH so that the logic in withdraw() works", "                // - because withdraw() assumes an ERC20 interface on the base asset.", "                IWETH(weth).deposit{value: msg.value}();", "            } else {", "                ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);", "            }", "", "            // transfer assets from putty to exerciser", "            _transferERC20sOut(order.erc20Assets);", "            _transferERC721sOut(order.erc721Assets);", "            _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[uint256(orderHash)]);", "        } else {", "            // -- exercising a put option", "", "            // save the floor asset token ids to the short position", "            uint256 shortPositionId = uint256(hashOppositeOrder(order));", "            positionFloorAssetTokenIds[shortPositionId] = floorAssetTokenIds;", "", "            // transfer strike from putty to exerciser", "            ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike);", "", "            // transfer assets from exerciser to putty", "            _transferERC20sIn(order.erc20Assets, msg.sender);", "            _transferERC721sIn(order.erc721Assets, msg.sender);", "            _transferFloorsIn(order.floorTokens, floorAssetTokenIds, msg.sender);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function unstakeFor(", "        address src,", "        address dst,", "        uint256 amount", "    ) public override returns (bool) {", "        ILiquidityPool pool = addressProvider.getPoolForToken(token);", "        uint256 allowance_ = _allowances[src][msg.sender];", "        require(", "            src == msg.sender || allowance_ >= amount || address(pool) == msg.sender,", "            Error.UNAUTHORIZED_ACCESS", "        );", "        require(balances[src] >= amount, Error.INSUFFICIENT_BALANCE);", "        address lpGauge = currentAddresses[_LP_GAUGE];", "        if (lpGauge != address(0)) {", "            ILpGauge(lpGauge).userCheckpoint(src);", "        }", "        uint256 oldBal = IERC20(token).balanceOf(address(this));", "", "        if (src != dst) {", "            pool.handleLpTokenTransfer(src, dst, amount);", "        }", "", "        IERC20(token).safeTransfer(dst, amount);", "", "        uint256 unstaked = oldBal.uncheckedSub(IERC20(token).balanceOf(address(this)));", "", "        if (src != msg.sender && allowance_ != type(uint256).max && address(pool) != msg.sender) {", "            // update allowance", "            _allowances[src][msg.sender] -= unstaked;", "        }", "        balances[src] -= unstaked;", "", "        if (strategies[src]) {", "            strategiesTotalStaked -= unstaked;", "        } else {", "            _poolTotalStaked -= unstaked;", "        }", "        emit Unstaked(src, amount);", "        return true;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": ["    function _updateUserFeesOnDeposit(", "        address account,", "        address from,", "        uint256 amountAdded", "    ) internal {", "        WithdrawalFeeMeta storage meta = withdrawalFeeMetas[account];", "        uint256 balance = lpToken.balanceOf(account) +", "            staker.stakedAndActionLockedBalanceOf(account);", "        uint256 newCurrentFeeRatio = getNewCurrentFees(", "            meta.timeToWait,", "            meta.lastActionTimestamp,", "            meta.feeRatio", "        );", "        uint256 shareAdded = amountAdded.scaledDiv(amountAdded + balance);", "        uint256 shareExisting = ScaledMath.ONE - shareAdded;", "        uint256 feeOnDeposit;", "        if (from == address(0)) {", "            feeOnDeposit = getMaxWithdrawalFee();", "        } else {", "            WithdrawalFeeMeta storage fromMeta = withdrawalFeeMetas[from];", "            feeOnDeposit = getNewCurrentFees(", "                fromMeta.timeToWait,", "                fromMeta.lastActionTimestamp,", "                fromMeta.feeRatio", "            );", "        }", "", "        uint256 newFeeRatio = shareExisting.scaledMul(newCurrentFeeRatio) +", "            shareAdded.scaledMul(feeOnDeposit);", "", "        meta.feeRatio = uint64(newFeeRatio);", "        meta.timeToWait = uint64(getWithdrawalFeeDecreasePeriod());", "        meta.lastActionTimestamp = uint64(_getTime());", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0]}
{"tokens": ["    function claimGovFees() public {", "        address[] memory assets = bondNFT.getAssets();", "", "        for (uint i=0; i < assets.length; i++) {", "            uint balanceBefore = IERC20(assets[i]).balanceOf(address(this));", "            IGovNFT(govNFT).claim(assets[i]);", "            uint balanceAfter = IERC20(assets[i]).balanceOf(address(this));", "            IERC20(assets[i]).approve(address(bondNFT), type(uint256).max);", "            bondNFT.distribute(assets[i], balanceAfter - balanceBefore);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["    function finalize(uint256 auctionId, uint256[] memory bidIndices, uint128 clearingBase, uint128 clearingQuote)", "        public", "        atState(idToAuction[auctionId], States.RevealPeriod)", "    {", "        Auction storage a = idToAuction[auctionId];", "        uint256 sellerPriv = a.data.privKey;", "        if (sellerPriv == 0) {", "            revert InvalidPrivateKey();", "        }", "", "        if (bidIndices.length != a.bids.length) {", "            revert InvalidCalldata();", "        }", "", "        FinalizeData memory data;", "        data.reserveQuotePerBase = a.params.reserveQuotePerBase;", "        data.totalBaseAmount = a.params.totalBaseAmount;", "        data.previousQuotePerBase = type(uint256).max;", "", "        // Last filled bid is the clearing price", "        a.data.lowestBase = clearingBase;", "        a.data.lowestQuote = clearingQuote;", "", "        // Bitmap of all the bid indices that have been processed", "        uint256[] memory seenBidMap = new uint256[]((bidIndices.length/256)+1);", "", "        // Fill orders from highest price to lowest price", "        for (uint256 i; i < bidIndices.length; i++) {", "            uint256 bidIndex = bidIndices[i];", "            EncryptedBid storage b = a.bids[bidIndex];", "", "            // Verify this bid index hasn't been seen before", "            uint256 bitmapIndex = bidIndex / 256;", "            uint256 bitMap = seenBidMap[bitmapIndex];", "            uint256 indexBit = 1 << (bidIndex % 256);", "            if (bitMap & indexBit == 1) revert InvalidState();", "            seenBidMap[bitmapIndex] = bitMap | indexBit;", "", "            // G^k1^k2 == G^k2^k1", "            ECCMath.Point memory sharedPoint = ECCMath.ecMul(b.pubKey, sellerPriv);", "            // If the bidder public key isn't on the bn128 curve", "            if (sharedPoint.x == 1 && sharedPoint.y == 1) continue;", "", "            bytes32 decryptedMessage = ECCMath.decryptMessage(sharedPoint, b.encryptedMessage);", "            // If the bidder didn't faithfully submit commitment or pubkey", "            // Or the bid was cancelled", "            if (computeCommitment(decryptedMessage) != b.commitment) continue;", "", "            // First 128 bits are the base amount, last are random salt", "            uint128 baseAmount = uint128(uint256(decryptedMessage >> 128));", "", "            // Require that bids are passed in descending price", "            uint256 quotePerBase = FixedPointMathLib.mulDivDown(b.quoteAmount, type(uint128).max, baseAmount);", "            if (quotePerBase >= data.previousQuotePerBase) {", "                // If last bid was the same price, make sure we filled the earliest bid first", "                if (quotePerBase == data.previousQuotePerBase) {", "                    if (data.previousIndex > bidIndex) revert InvalidSorting();", "                } else {", "                    revert InvalidSorting();", "                }", "            }", "", "            // Only fill if above reserve price", "            if (quotePerBase < data.reserveQuotePerBase) continue;", "", "            // Auction has been fully filled", "            if (data.filledBase == data.totalBaseAmount) continue;", "", "            data.previousQuotePerBase = quotePerBase;", "            data.previousIndex = bidIndex;", "", "            // Fill the remaining unfilled base amount", "            if (data.filledBase + baseAmount > data.totalBaseAmount) {", "                baseAmount = data.totalBaseAmount - data.filledBase;", "            }", "", "            b.filledBaseAmount = baseAmount;", "            data.filledBase += baseAmount;", "        }", "", "        if (data.previousQuotePerBase != FixedPointMathLib.mulDivDown(clearingQuote, type(uint128).max, clearingBase)) {", "            revert InvalidCalldata();", "        }", "", "        // seenBidMap[0:len-1] should be full", "        for (uint256 i; i < seenBidMap.length - 1; i++) {", "            if (seenBidMap[i] != type(uint256).max) {", "                revert InvalidState();", "            }", "        }", "", "        // seenBidMap[-1] should only have the last N bits set", "        if (seenBidMap[seenBidMap.length - 1] != (1 << (bidIndices.length % 256)) - 1) {", "            revert InvalidState();", "        }", "", "        if (data.filledBase > data.totalBaseAmount) {", "            revert InvalidState();", "        }", "", "        // Transfer the left over baseToken", "        if (data.totalBaseAmount != data.filledBase) {", "            uint128 unsoldBase = data.totalBaseAmount - data.filledBase;", "            a.params.totalBaseAmount = data.filledBase;", "            SafeTransferLib.safeTransfer(ERC20(a.params.baseToken), a.data.seller, unsoldBase);", "        }", "", "        // Calculate quote amount based on clearing price", "        uint256 filledQuote = FixedPointMathLib.mulDivDown(clearingQuote, data.filledBase, clearingBase);", "", "        SafeTransferLib.safeTransfer(ERC20(a.params.quoteToken), a.data.seller, filledQuote);", "", "        emit AuctionFinalized(auctionId, bidIndices, data.filledBase, filledQuote);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function _setUniV3LpVault(IUniV3LpVault newVault) public returns (uint256) {", "        // Check caller is admin", "        if (msg.sender != admin) {", "            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);", "        }", "", "        // Track the old vault for the comptroller", "        IUniV3LpVault oldVault = uniV3LpVault;", "", "        // Set comptroller's uniV3LpVault to newVault", "        uniV3LpVault = newVault;", "", "        // Emit NewUniV3LpVault(oldVault, newVault)", "        emit NewUniV3LpVault(oldVault, newVault);", "", "        return uint256(Error.NO_ERROR);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function getPrice() public view returns (uint256) {", "        Sale memory temp = sale;", "        (uint256 start, uint256 end) = (temp.startTime, temp.endTime);", "        if (block.timestamp < start) return type(uint256).max;", "        if (temp.currentId == temp.finalId) return temp.finalPrice;", "", "        uint256 timeElapsed = end > block.timestamp ? block.timestamp - start : end - start;", "        return temp.startPrice - (temp.dropPerSecond * timeElapsed);", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": ["  function setPermission(", "    address envoy,", "    address target,", "    bytes4 selector,", "    bool permission", "  ) public override {", "    if (owner != msg.sender) {", "      revert CustomErrors.NOT_OWNER(owner, msg.sender);", "    }", "    _permissions[envoy][target][selector] = permission;", "  }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _deployFirst(", "        bytes32 _saltSeed,", "        bytes memory _configData,", "        bytes memory _immutables,", "        uint256 _maxLTV,", "        uint256 _liquidationFee,", "        uint256 _maturityDate,", "        uint256 _penaltyRate,", "        bool _isBorrowerWhitelistActive,", "        bool _isLenderWhitelistActive", "    ) private returns (address _pairAddress) {", "        {", "            // _saltSeed is the same for all public pairs so duplicates cannot be created", "            bytes32 salt = keccak256(abi.encodePacked(_saltSeed, _configData));", "            require(deployedPairsBySalt[salt] == address(0), \"FraxlendPairDeployer: Pair already deployed\");", "", "            bytes memory _creationCode = BytesLib.concat(", "                SSTORE2.read(contractAddress1),", "                SSTORE2.read(contractAddress2)", "            );", "            bytes memory bytecode = abi.encodePacked(", "                _creationCode,", "                abi.encode(", "                    _configData,", "                    _immutables,", "                    _maxLTV,", "                    _liquidationFee,", "                    _maturityDate,", "                    _penaltyRate,", "                    _isBorrowerWhitelistActive,", "                    _isLenderWhitelistActive", "                )", "            );", "", "            assembly {", "                _pairAddress := create2(0, add(bytecode, 32), mload(bytecode), salt)", "            }", "            require(_pairAddress != address(0), \"FraxlendPairDeployer: create2 failed\");", "", "            deployedPairsBySalt[salt] = _pairAddress;", "        }", "", "        return _pairAddress;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _setBufferCap(uint256 newBufferCap) internal {", "        _updateBufferStored();", "", "        uint256 oldBufferCap = bufferCap;", "        bufferCap = newBufferCap;", "", "        emit BufferCapUpdate(oldBufferCap, newBufferCap);", "    }"], "ner_tags": [0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _updateAccumulatedETHPerLP(uint256 _numOfShares) internal {", "        if (_numOfShares > 0) {", "            uint256 received = totalRewardsReceived();", "            uint256 unprocessed = received - totalETHSeen;", "", "            if (unprocessed > 0) {", "                emit ETHReceived(unprocessed);", "", "                // accumulated ETH per minted share is scaled to avoid precision loss. it is scaled down later", "                accumulatedETHPerLPShare += (unprocessed * PRECISION) / _numOfShares;", "", "                totalETHSeen = received;", "            }", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["  function isValidRefinance(", "    ILienToken.Lien calldata newLien,", "    uint8 position,", "    ILienToken.Stack[] calldata stack", "  ) public view returns (bool) {", "    RouterStorage storage s = _loadRouterSlot();", "    uint256 maxNewRate = uint256(stack[position].lien.details.rate) -", "      s.minInterestBPS;", "", "    if (newLien.collateralId != stack[0].lien.collateralId) {", "      revert InvalidRefinanceCollateral(newLien.collateralId);", "    }", "    return", "      (newLien.details.rate <= maxNewRate &&", "        newLien.details.duration + block.timestamp >=", "        stack[position].point.end) ||", "      (block.timestamp + newLien.details.duration - stack[position].point.end >=", "        s.minDurationIncrease &&", "        newLien.details.rate <= stack[position].lien.details.rate);", "  }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function clearExtraRewards() external {", "        require(msg.sender == rewardManager, \"!authorized\");", "        delete extraRewards;", "    }"], "ner_tags": [1, 0, 0, 0]}
{"tokens": ["    function sqrt(uint256 value, bool roundUp) internal pure returns (uint256 result) {", "        if (value == type(uint256).max) return result = type(uint128).max;", "        if (value == 0) return 0;", "        unchecked {", "            uint256 estimate = (value + 1) >> 1;", "            result = value;", "            while (estimate < result) {", "                result = estimate;", "                estimate = (value / estimate + estimate) >> 1;", "            }", "        }", "", "        if (roundUp && value % result != 0) result++;", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": ["    constructor(", "        address _gmxBaseReward,", "        address _gmx,", "        address _asset,", "        string memory _name,", "        string memory _symbol,", "        address _platform,", "        address _rewardsModule", "    ) Owned(msg.sender) PirexERC4626(ERC20(_asset), _name, _symbol) {", "        if (_gmxBaseReward == address(0)) revert ZeroAddress();", "        if (_gmx == address(0)) revert ZeroAddress();", "        if (_asset == address(0)) revert ZeroAddress();", "        if (bytes(_name).length == 0) revert InvalidAssetParam();", "        if (bytes(_symbol).length == 0) revert InvalidAssetParam();", "        if (_platform == address(0)) revert ZeroAddress();", "        if (_rewardsModule == address(0)) revert ZeroAddress();", "", "        gmxBaseReward = ERC20(_gmxBaseReward);", "        gmx = ERC20(_gmx);", "        platform = _platform;", "        rewardsModule = _rewardsModule;", "", "        // Approve the Uniswap V3 router to manage our base reward (inbound swap token)", "        gmxBaseReward.safeApprove(address(SWAP_ROUTER), type(uint256).max);", "        gmx.safeApprove(_platform, type(uint256).max);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["    function buy(uint256 _amount) external payable {", "        Sale memory sale_ = sale;", "        IEscher721 nft = IEscher721(sale_.edition);", "        require(block.timestamp >= sale_.startTime, \"TOO SOON\");", "        require(_amount * sale_.price == msg.value, \"WRONG PRICE\");", "        uint48 newId = uint48(_amount) + sale_.currentId;", "        require(newId <= sale_.finalId, \"TOO MANY\");", "", "        for (uint48 x = sale_.currentId + 1; x <= newId; x++) {", "            nft.mint(msg.sender, x);", "        }", "", "        sale.currentId = newId;", "", "        emit Buy(msg.sender, _amount, msg.value, sale);", "", "        if (newId == sale_.finalId) _end(sale);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["    function _requestLoan(", "        address collateralProvider,", "        uint256 tokenId,", "        TokenLoanParams memory params,", "        address to,", "        bool skim", "    ) private {", "        // Edge case: valuation can be zero. That effectively gifts the NFT and", "        // is therefore a bad idea, but does not break the contract.", "        require(tokenLoan[tokenId].status == LOAN_INITIAL, \"NFTPair: loan exists\");", "        if (skim) {", "            require(collateral.ownerOf(tokenId) == address(this), \"NFTPair: skim failed\");", "        } else {", "            collateral.transferFrom(collateralProvider, address(this), tokenId);", "        }", "        TokenLoan memory loan;", "        loan.borrower = to;", "        loan.status = LOAN_REQUESTED;", "        tokenLoan[tokenId] = loan;", "        tokenLoanParams[tokenId] = params;", "", "        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function increaseF_Collateral(address _collateral, uint _collFee) external override {", "        _requireCallerIsTroveManagerOrActivePool();", "        uint collFeePerLQTYStaked;", "     ", "        if (totalLQTYStaked > 0) {collFeePerLQTYStaked = _collFee.mul(DECIMAL_PRECISION).div(totalLQTYStaked);}", "", "        F_Collateral[_collateral] = F_Collateral[_collateral].add(collFeePerLQTYStaked);", "        emit F_CollateralUpdated(_collateral, F_Collateral[_collateral]);", "    }"], "ner_tags": [0, 0, 0, 0, 1, 1, 1, 0, 0]}
{"tokens": ["    modifier onlyRole(bytes32 role) {", "        GovernanceTimelock.checkOnlyRole(role, msg.sender);", "        _;", "    }"], "ner_tags": [1, 1, 1, 1]}
{"tokens": ["    modifier noContract(address _account) {", "        require(", "            !_account.isContract() || whitelistedContracts[_account],", "            \"Contracts aren't allowed to farm\"", "        );", "        _;", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _storeRebase(", "        uint256 _previousCirculating,", "        uint256 _profit,", "        uint256 _epoch", "    ) internal {", "        uint256 rebasePercent = (_profit * WAD) / _previousCirculating;", "", "        rebases.push(", "            Rebase({", "                epoch: _epoch,", "                rebase: rebasePercent,", "                totalStakedBefore: _previousCirculating,", "                totalStakedAfter: _totalSupply,", "                amountRebased: _profit,", "                index: getIndex(),", "                blockNumberOccurred: block.number", "            })", "        );", "", "        emit LogSupply(_epoch, block.timestamp, _totalSupply);", "        emit LogRebase(_epoch, rebasePercent, getIndex());", "    }"], "ner_tags": [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["\tfunction calculateAndDistributeRewards(address stakerAddr, uint256 totalEligibleGGPStaked) external onlyMultisig {", "\t\tStaking staking = Staking(getContractAddress(\"Staking\"));", "\t\tstaking.requireValidStaker(stakerAddr);", "", "\t\tRewardsPool rewardsPool = RewardsPool(getContractAddress(\"RewardsPool\"));", "\t\tif (rewardsPool.getRewardsCycleCount() == 0) {", "\t\t\trevert RewardsCycleNotStarted();", "\t\t}", "", "\t\tif (staking.getLastRewardsCycleCompleted(stakerAddr) == rewardsPool.getRewardsCycleCount()) {", "\t\t\trevert RewardsAlreadyDistributedToStaker(stakerAddr);", "\t\t}", "\t\tstaking.setLastRewardsCycleCompleted(stakerAddr, rewardsPool.getRewardsCycleCount());", "\t\tuint256 ggpEffectiveStaked = staking.getEffectiveGGPStaked(stakerAddr);", "\t\tuint256 percentage = ggpEffectiveStaked.divWadDown(totalEligibleGGPStaked);", "\t\tuint256 rewardsCycleTotal = getRewardsCycleTotal();", "\t\tuint256 rewardsAmt = percentage.mulWadDown(rewardsCycleTotal);", "\t\tif (rewardsAmt > rewardsCycleTotal) {", "\t\t\trevert InvalidAmount();", "\t\t}", "", "\t\tstaking.resetAVAXAssignedHighWater(stakerAddr);", "\t\tstaking.increaseGGPRewards(stakerAddr, rewardsAmt);", "", "\t\t// check if their rewards time should be reset", "\t\tuint256 minipoolCount = staking.getMinipoolCount(stakerAddr);", "\t\tif (minipoolCount == 0) {", "\t\t\tstaking.setRewardsStartTime(stakerAddr, 0);", "\t\t}", "\t}"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function canBatchContracts() external view returns (Batch[] memory) {", "        uint256 contractsLength = contracts.length;", "        Batch[] memory batch = new Batch[](contractsLength);", "        for (uint256 i; i < contractsLength; ) {", "            bool canBatch = IStaking(contracts[i]).canBatchTransactions();", "            batch[i] = Batch(contracts[i], canBatch);", "            unchecked {", "                ++i;", "            }", "        }", "        return batch;", "    }"], "ner_tags": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function addMinter(address minter_address) public onlyByOwnGov {", "        require(minter_address != address(0), \"Zero address detected\");", "", "        require(minters[minter_address] == false, \"Address already exists\");", "        minters[minter_address] = true; ", "        minters_array.push(minter_address);", "", "        emit MinterAdded(minter_address);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external override {", "        // Check if this is really a callback", "        if (msg.sender != address(pool)) revert JuiceBuyback_Unauthorized();", "", "        // Unpack the data", "        (uint256 _minimumAmountReceived) = abi.decode(data, (uint256));", "", "        // Assign 0 and 1 accordingly", "        uint256 _amountReceived = uint256(-(_projectTokenIsZero ? amount0Delta : amount1Delta));", "        uint256 _amountToSend = uint256(_projectTokenIsZero ? amount1Delta : amount0Delta);", "", "        // Revert if slippage is too high", "        if (_amountReceived < _minimumAmountReceived) revert JuiceBuyback_MaximumSlippage();", "", "        // Wrap and transfer the weth to the pool", "        weth.deposit{value: _amountToSend}();", "        weth.transfer(address(pool), _amountToSend);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function processEpoch() public {", "    // check to make sure epoch is over", "    if (timeToEpochEnd() > 0) {", "      revert InvalidState(InvalidStates.EPOCH_NOT_OVER);", "    }", "    VaultData storage s = _loadStorageSlot();", "", "    if (s.withdrawReserve > 0) {", "      revert InvalidState(InvalidStates.WITHDRAW_RESERVE_NOT_ZERO);", "    }", "", "    WithdrawProxy currentWithdrawProxy = WithdrawProxy(", "      s.epochData[s.currentEpoch].withdrawProxy", "    );", "", "    // split funds from previous WithdrawProxy with PublicVault if hasn't been already", "    if (s.currentEpoch != 0) {", "      WithdrawProxy previousWithdrawProxy = WithdrawProxy(", "        s.epochData[s.currentEpoch - 1].withdrawProxy", "      );", "      if (", "        address(previousWithdrawProxy) != address(0) &&", "        previousWithdrawProxy.getFinalAuctionEnd() != 0", "      ) {", "        previousWithdrawProxy.claim();", "      }", "    }", "", "    if (s.epochData[s.currentEpoch].liensOpenForEpoch > 0) {", "      revert InvalidState(InvalidStates.LIENS_OPEN_FOR_EPOCH_NOT_ZERO);", "    }", "", "    // reset liquidationWithdrawRatio to prepare for re calcualtion", "    s.liquidationWithdrawRatio = 0;", "", "    // check if there are LPs withdrawing this epoch", "    if ((address(currentWithdrawProxy) != address(0))) {", "      uint256 proxySupply = currentWithdrawProxy.totalSupply();", "", "      s.liquidationWithdrawRatio = proxySupply", "        .mulDivDown(1e18, totalSupply())", "        .safeCastTo88();", "", "      currentWithdrawProxy.setWithdrawRatio(s.liquidationWithdrawRatio);", "      uint256 expected = currentWithdrawProxy.getExpected();", "", "      unchecked {", "        if (totalAssets() > expected) {", "          s.withdrawReserve = (totalAssets() - expected)", "            .mulWadDown(s.liquidationWithdrawRatio)", "            .safeCastTo88();", "        } else {", "          s.withdrawReserve = 0;", "        }", "      }", "      _setYIntercept(", "        s,", "        s.yIntercept -", "          totalAssets().mulDivDown(s.liquidationWithdrawRatio, 1e18)", "      );", "      // burn the tokens of the LPs withdrawing", "      _burn(address(this), proxySupply);", "    }", "", "    // increment epoch", "    unchecked {", "      s.currentEpoch++;", "    }", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function redeemAllowed(address cAsset, address redeemer, uint redeemTokens) external returns (uint) {", "        uint allowed = redeemAllowedInternal(cAsset, redeemer, redeemTokens);", "        if (allowed != uint(Error.NO_ERROR)) {", "            return allowed;", "        }", "", "        // Keep the flywheel moving", "        // updateCompSupplyIndex(cAsset);", "        // distributeSupplierComp(cAsset, redeemer);", "", "        return uint(Error.NO_ERROR);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0]}
{"tokens": ["    function sendFundsToUser(", "        address tokenAddress,", "        uint256 amount,", "        address payable receiver,", "        bytes memory depositHash,", "        uint256 tokenGasPrice,", "        uint256 fromChainId", "    ) external nonReentrant onlyExecutor tokenChecks(tokenAddress) whenNotPaused {", "        uint256 initialGas = gasleft();", "        require(", "            tokenManager.getTransferConfig(tokenAddress).min <= amount &&", "                tokenManager.getTransferConfig(tokenAddress).max >= amount,", "            \"Withdraw amnt not in Cap limits\"", "        );", "        require(receiver != address(0), \"Bad receiver address\");", "", "        (bytes32 hashSendTransaction, bool status) = checkHashStatus(tokenAddress, amount, receiver, depositHash);", "", "        require(!status, \"Already Processed\");", "        processedHash[hashSendTransaction] = true;", "", "        uint256 amountToTransfer = getAmountToTransfer(initialGas, tokenAddress, amount, tokenGasPrice);", "        liquidityProviders.decreaseCurrentLiquidity(tokenAddress, amountToTransfer);", "", "        if (tokenAddress == NATIVE) {", "            require(address(this).balance >= amountToTransfer, \"Not Enough Balance\");", "            (bool success, ) = receiver.call{value: amountToTransfer}(\"\");", "            require(success, \"Native Transfer Failed\");", "        } else {", "            require(IERC20Upgradeable(tokenAddress).balanceOf(address(this)) >= amountToTransfer, \"Not Enough Balance\");", "            SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(tokenAddress), receiver, amountToTransfer);", "        }", "", "        emit AssetSent(tokenAddress, amount, amountToTransfer, receiver, depositHash, fromChainId);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function _requestLienAndIssuePayout(", "    IAstariaRouter.Commitment calldata c,", "    address receiver", "  )", "    internal", "    returns (", "      uint256 newLienId,", "      ILienToken.Stack[] memory stack,", "      uint256 slope,", "      uint256 payout", "    )", "  {", "    _validateCommitment(c, receiver);", "    (newLienId, stack, slope) = ROUTER().requestLienPosition(c, recipient());", "    payout = _handleProtocolFee(c.lienRequest.amount);", "    ERC20(asset()).safeTransfer(receiver, payout);", "  }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function getReward(bool _lock) public updateReward(msg.sender) returns (bool) {", "        uint256 reward = rewards[msg.sender];", "        if (reward > 0) {", "            rewards[msg.sender] = 0;", "            if (_lock) {", "                auraLocker.lock(msg.sender, reward);", "            } else {", "                uint256 penalty = (reward * 2) / 10;", "                pendingPenalty += penalty;", "                rewardToken.safeTransfer(msg.sender, reward - penalty);", "            }", "            emit RewardPaid(msg.sender, reward, _lock);", "        }", "        return true;", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": ["    function beat() external nonReentrant {", "        if (!active) revert Heart_BeatStopped();", "        if (block.timestamp < lastBeat + frequency()) revert Heart_OutOfCycle();", "", "        // Update the moving average on the Price module", "        PRICE.updateMovingAverage();", "", "        // Trigger price range update and market operations", "        _operator.operate();", "", "        // Update the last beat timestamp", "        lastBeat += frequency();", "", "        // Issue reward to sender", "        _issueReward(msg.sender);", "", "        emit Beat(block.timestamp);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function lzReceive(", "        uint16 _srcChainId,", "        bytes memory _srcAddress,", "        uint64 _nonce,", "        bytes memory _payload", "    ) external override {", "        require(_msgSender() == address(endpoint), \"!Endpoint\");", "        (bool success, bytes memory reason) = address(this).excessivelySafeCall(gasleft()*4/5, 150, abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload));", "        // try-catch all errors/exceptions", "        if (!success) {", "            failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);", "            emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, reason);", "        }", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function swapAndStartBridgeTokensViaNXTP(", "        LiFiData memory _lifiData,", "        LibSwap.SwapData[] calldata _swapData,", "        ITransactionManager.PrepareArgs memory _nxtpData", "    ) public payable {", "        address sendingAssetId = _nxtpData.invariantData.sendingAssetId;", "        uint256 _sendingAssetIdBalance = LibAsset.getOwnBalance(sendingAssetId);", "", "        // Swap", "        _executeSwaps(_lifiData, _swapData);", "", "        uint256 _postSwapBalance = LibAsset.getOwnBalance(sendingAssetId) - _sendingAssetIdBalance;", "", "        require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");", "", "        _nxtpData.amount = _postSwapBalance;", "", "        _startBridge(_lifiData.transactionId, _nxtpData);", "", "        emit LiFiTransferStarted(", "            _lifiData.transactionId,", "            _lifiData.integrator,", "            _lifiData.referrer,", "            _lifiData.sendingAssetId,", "            _lifiData.receivingAssetId,", "            _lifiData.receiver,", "            _lifiData.amount,", "            _lifiData.destinationChainId,", "            block.timestamp", "        );", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function purchaseOtherEarnings(address user, bool useEUSD) external updateReward(user) {", "        require(isOtherEarningsClaimable(user), \"The rewards of the user cannot be bought out\");", "        if(useEUSD) {", "            require(isEUSDBuyoutAllowed, \"The purchase using EUSD is not permitted.\");", "        }", "        uint256 reward = rewards[user];", "        if (reward > 0) {", "            rewards[user] = 0;", "            uint256 biddingFee = (reward * biddingFeeRatio) / 10000;", "            if(useEUSD) {", "                (, int lbrPrice, , , ) = lbrPriceFeed.latestRoundData();", "                biddingFee = biddingFee * uint256(lbrPrice) / 1e8;", "                bool success = EUSD.transferFrom(msg.sender, address(configurator), biddingFee);", "                require(success, \"TF\");", "                try configurator.distributeRewards() {} catch {}", "            } else {", "                IesLBR(LBR).burn(msg.sender, biddingFee);", "            }", "            IesLBR(esLBR).mint(msg.sender, reward);", "", "            emit ClaimedOtherEarnings(msg.sender, user, reward, biddingFee, useEUSD, block.timestamp);", "        }", "    }"], "ner_tags": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function batch(bytes[] calldata calls, bool revertOnFail) external payable {", "    for (uint256 i = 0; i < calls.length; i++) {", "      (bool success, bytes memory result) = address(this).delegatecall(calls[i]);", "      if (!success && revertOnFail) {", "        _getRevertMsg(result);", "      }", "    }", "  }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    constructor(address coreAddress) {", "        _core = ICore(coreAddress);", "", "        _volt = ICore(coreAddress).volt();", "        _vcon = ICore(coreAddress).vcon();", "", "        _setContractAdminRole(ICore(coreAddress).GOVERN_ROLE());", "    }"], "ner_tags": [0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["    function _createAuction() private {", "        // Get the next token available for bidding", "        try token.mint() returns (uint256 tokenId) {", "            // Store the token id", "            auction.tokenId = tokenId;", "", "            // Cache the current timestamp", "            uint256 startTime = block.timestamp;", "", "            // Used to store the auction end time", "            uint256 endTime;", "", "            // Cannot realistically overflow", "            unchecked {", "                // Compute the auction end time", "                endTime = startTime + settings.duration;", "            }", "", "            // Store the auction start and end time", "            auction.startTime = uint40(startTime);", "            auction.endTime = uint40(endTime);", "", "            // Reset data from the previous auction", "            auction.highestBid = 0;", "            auction.highestBidder = address(0);", "            auction.settled = false;", "", "            emit AuctionCreated(tokenId, startTime, endTime);", "", "            // Pause the contract if token minting failed", "        } catch Error(string memory) {", "            _pause();", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["  function _reconcile(uint32 _origin, bytes memory _message) internal {", "    // Parse tokenId and action from the message.", "    bytes29 msg_ = _message.ref(0).mustBeMessage();", "    bytes29 tokenId = msg_.tokenId();", "    bytes29 action = msg_.action();", "", "    // Assert that the action is valid.", "    if (!action.isTransfer()) {", "      revert BridgeFacet__reconcile_invalidAction();", "    }", "", "    // Load the transferId.", "    bytes32 transferId = action.transferId();", "", "    // Ensure the transaction has not already been handled (i.e. previously reconciled).", "    if (s.reconciledTransfers[transferId]) {", "      revert BridgeFacet__reconcile_alreadyReconciled();", "    }", "", "    // NOTE: `tokenId` and `amount` must be in plaintext in the message so funds can *only* be minted by", "    // `handle`. They are both used in the generation of the `transferId` so routers must provide them", "    // correctly to be reimbursed.", "", "    // Get the appropriate local token contract for the given tokenId on this chain.", "    // NOTE: If the token is of remote origin and there is no existing representation token contract,", "    // the TokenRegistry will deploy a new one.", "    address token = s.tokenRegistry.ensureLocalToken(tokenId.domain(), tokenId.id());", "", "    // Load amount once.", "    uint256 amount = action.amnt();", "", "    // Mint tokens if the asset is of remote origin (i.e. is representational).", "    // NOTE: If the asset IS of local origin (meaning it's canonical), then the tokens will already be held", "    // in escrow in this contract (from previous `xcall`s).", "    if (!s.tokenRegistry.isLocalOrigin(token)) {", "      IBridgeToken(token).mint(address(this), amount);", "", "      // Update the recorded `detailsHash` for the token (name, symbol, decimals).", "      // TODO: do we need to keep this", "      bytes32 details = action.detailsHash();", "      IBridgeToken(token).setDetailsHash(details);", "    }", "", "    // Mark the transfer as reconciled.", "    s.reconciledTransfers[transferId] = true;", "", "    // If the transfer was executed using fast-liquidity provided by routers, then this value would be set", "    // to the participating routers.", "    // NOTE: If the transfer was not executed using fast-liquidity, then the funds will be reserved for", "    // execution (i.e. funds will be delivered to the transfer's recipient in a subsequent `execute` call).", "    address[] memory routers = s.routedTransfers[transferId];", "", "    // If fast transfer was made using portal liquidity, we need to repay", "    // FIXME: routers can repay any-amount out-of-band using the `repayAavePortal` method", "    // or by interacting with the aave contracts directly", "    uint256 portalTransferAmount = s.portalDebt[transferId] + s.portalFeeDebt[transferId];", "", "    uint256 toDistribute = amount;", "    uint256 pathLen = routers.length;", "    if (portalTransferAmount != 0) {", "      // ensure a router took on credit risk", "      if (pathLen != 1) revert BridgeFacet__reconcile_noPortalRouter();", "      toDistribute = _reconcileProcessPortal(amount, token, routers[0], transferId);", "    }", "", "    if (pathLen != 0) {", "      // fast liquidity path", "      // Credit each router that provided liquidity their due 'share' of the asset.", "      uint256 routerAmt = toDistribute / pathLen;", "      for (uint256 i; i < pathLen; ) {", "        s.routerBalances[routers[i]][token] += routerAmt;", "        unchecked {", "          i++;", "        }", "      }", "    }", "", "    emit Reconciled(transferId, _origin, routers, token, amount, msg.sender);", "  }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _getMarginFraction(int256 accountValue, uint notionalPosition) private pure returns(int256) {", "        if (notionalPosition == 0) {", "            return type(int256).max;", "        }", "        return accountValue * PRECISION.toInt256() / notionalPosition.toInt256();", "    }"], "ner_tags": [0, 0, 0, 0, 1, 0]}
{"tokens": ["  function executeJob(bytes calldata bridgeInRequestPayload) external payable {", "    /**", "     * @dev derive the payload hash for use in mappings", "     */", "    bytes32 hash = keccak256(bridgeInRequestPayload);", "    /**", "     * @dev check that job exists", "     */", "    require(_operatorJobs[hash] > 0, \"HOLOGRAPH: invalid job\");", "    uint256 gasLimit = 0;", "    uint256 gasPrice = 0;", "    assembly {", "      /**", "       * @dev extract gasLimit", "       */", "      gasLimit := calldataload(sub(add(bridgeInRequestPayload.offset, bridgeInRequestPayload.length), 0x40))", "      /**", "       * @dev extract gasPrice", "       */", "      gasPrice := calldataload(sub(add(bridgeInRequestPayload.offset, bridgeInRequestPayload.length), 0x20))", "    }", "    /**", "     * @dev unpack bitwise packed operator job details", "     */", "    OperatorJob memory job = getJobDetails(hash);", "    /**", "     * @dev to prevent replay attacks, remove job from mapping", "     */", "    delete _operatorJobs[hash];", "    /**", "     * @dev check that a specific operator was selected for the job", "     */", "    if (job.operator != address(0)) {", "      /**", "       * @dev switch pod to index based value", "       */", "      uint256 pod = job.pod - 1;", "      /**", "       * @dev check if sender is not the selected primary operator", "       */", "      if (job.operator != msg.sender) {", "        /**", "         * @dev sender is not selected operator, need to check if allowed to do job", "         */", "        uint256 elapsedTime = block.timestamp - uint256(job.startTimestamp);", "        uint256 timeDifference = elapsedTime / job.blockTimes;", "        /**", "         * @dev validate that initial selected operator time slot is still active", "         */", "        require(timeDifference > 0, \"HOLOGRAPH: operator has time\");", "        /**", "         * @dev check that the selected missed the time slot due to a gas spike", "         */", "        require(gasPrice >= tx.gasprice, \"HOLOGRAPH: gas spike detected\");", "        /**", "         * @dev check if time is within fallback operator slots", "         */", "        if (timeDifference < 6) {", "          uint256 podIndex = uint256(job.fallbackOperators[timeDifference - 1]);", "          /**", "           * @dev do a quick sanity check to make sure operator did not leave from index or is a zero address", "           */", "          if (podIndex > 0 && podIndex < _operatorPods[pod].length) {", "            address fallbackOperator = _operatorPods[pod][podIndex];", "            /**", "             * @dev ensure that sender is currently valid backup operator", "             */", "            require(fallbackOperator == msg.sender, \"HOLOGRAPH: invalid fallback\");", "          }", "        }", "        /**", "         * @dev time to reward the current operator", "         */", "        uint256 amount = _getBaseBondAmount(pod);", "        /**", "         * @dev select operator that failed to do the job, is slashed the pod base fee", "         */", "        _bondedAmounts[job.operator] -= amount;", "        /**", "         * @dev the slashed amount is sent to current operator", "         */", "        _bondedAmounts[msg.sender] += amount;", "        /**", "         * @dev check if slashed operator has enough tokens bonded to stay", "         */", "        if (_bondedAmounts[job.operator] >= amount) {", "          /**", "           * @dev enough bond amount leftover, put operator back in", "           */", "          _operatorPods[pod].push(job.operator);", "          _operatorPodIndex[job.operator] = _operatorPods[pod].length - 1;", "          _bondedOperators[job.operator] = job.pod;", "        } else {", "          /**", "           * @dev slashed operator does not have enough tokens bonded, return remaining tokens only", "           */", "          uint256 leftovers = _bondedAmounts[job.operator];", "          if (leftovers > 0) {", "            _bondedAmounts[job.operator] = 0;", "            _utilityToken().transfer(job.operator, leftovers);", "          }", "        }", "      } else {", "        /**", "         * @dev the selected operator is executing the job", "         */", "        _operatorPods[pod].push(msg.sender);", "        _operatorPodIndex[job.operator] = _operatorPods[pod].length - 1;", "        _bondedOperators[msg.sender] = job.pod;", "      }", "    }", "    /**", "     * @dev ensure that there is enough has left for the job", "     */", "    require(gasleft() > gasLimit, \"HOLOGRAPH: not enough gas left\");", "    /**", "     * @dev execute the job", "     */", "    try", "      HolographOperatorInterface(address(this)).nonRevertingBridgeCall{value: msg.value}(", "        msg.sender,", "        bridgeInRequestPayload", "      )", "    {", "      /// @dev do nothing", "    } catch {", "      _failedJobs[hash] = true;", "      emit FailedOperatorJob(hash);", "    }", "    /**", "     * @dev every executed job (even if failed) increments total message counter by one", "     */", "    ++_inboundMessageCounter;", "    /**", "     * @dev reward operator (with HLG) for executing the job", "     * @dev this is out of scope and is purposefully omitted from code", "     */", "    ////  _bondedOperators[msg.sender] += reward;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function addMerkleTree(", "        bytes32 metadataMerkleRoot,", "        bytes32 ipfsHash,", "        address nftAddress,", "        address priceGateAddress,", "        address eligibilityAddress,", "        uint eligibilityIndex,", "        uint priceIndex) external {", "        require(msg.sender == treeAdder, 'Only treeAdder can add trees');", "        MerkleTree storage tree = merkleTrees[++numTrees];", "        tree.metadataMerkleRoot = metadataMerkleRoot;", "        tree.ipfsHash = ipfsHash;", "        tree.nftAddress = nftAddress;", "        tree.priceGateAddress = priceGateAddress;", "        tree.eligibilityAddress = eligibilityAddress;", "        tree.eligibilityIndex = eligibilityIndex;", "        tree.priceIndex = priceIndex;", "        emit MerkleTreeAdded(numTrees, nftAddress);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _deactivatePolicy(Policy policy_) internal {", "        if (!policy_.isActive()) revert Kernel_PolicyNotActivated(address(policy_));", "", "        // Revoke permissions", "        Permissions[] memory requests = policy_.requestPermissions();", "        _setPolicyPermissions(policy_, requests, false);", "", "        // Remove policy from all policy data structures", "        uint256 idx = getPolicyIndex[policy_];", "        Policy lastPolicy = activePolicies[activePolicies.length - 1];", "", "        activePolicies[idx] = lastPolicy;", "        activePolicies.pop();", "        getPolicyIndex[lastPolicy] = idx;", "        delete getPolicyIndex[policy_];", "", "        // Remove policy from module dependents", "        _pruneFromDependents(policy_);", "", "        // Set policy status to inactive", "        policy_.setActiveStatus(false);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function escrow(bytes calldata _data, bytes calldata _signature)", "        external", "        virtual", "        override", "        whenNotPaused", "    {", "        // Decode params from _data", "        (", "            uint256 _communityID,", "            address _builder,", "            address _lender,", "            address _agent,", "            address _project,", "            uint256 _repayAmount,", "            bytes memory _details", "        ) = abi.decode(", "                _data,", "                (uint256, address, address, address, address, uint256, bytes)", "            );", "", "        // Compute hash from bytes", "        bytes32 _hash = keccak256(_data);", "", "        // Local instance of variable. For saving gas.", "        IProject _projectInstance = IProject(_project);", "", "        // Revert if decoded builder is not decoded project's builder", "        require(_builder == _projectInstance.builder(), \"Community::!Builder\");", "", "        // Revert if decoded _communityID's owner is not decoded _lender", "        require(", "            _lender == _communities[_communityID].owner,", "            \"Community::!Owner\"", "        );", "", "        // check signatures", "        checkSignatureValidity(_lender, _hash, _signature, 0); // must be lender", "        checkSignatureValidity(_builder, _hash, _signature, 1); // must be builder", "        checkSignatureValidity(_agent, _hash, _signature, 2); // must be agent or escrow", "", "        // Internal call to reduce debt", "        _reduceDebt(_communityID, _project, _repayAmount, _details);", "        emit DebtReducedByEscrow(_agent);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function _distributeProfit(uint256 rewarded) internal {", "    if (rewarded == 0) {", "      return;", "    }", "    rewarded = _replenishLiquidityExtension(rewarded);", "    if (rewarded == 0) {", "      return;", "    }", "    // Ensure starting at 0", "    collateralToken.safeApprove(address(auction), 0);", "    collateralToken.safeApprove(address(auction), rewarded);", "    rewarded = auction.allocateArbRewards(rewarded);", "    // Reset approval", "    collateralToken.safeApprove(address(auction), 0);", "", "    if (rewarded == 0) {", "      return;", "    }", "", "    uint256 distributeCut = (rewarded * distributeBps) / 10000;", "    uint256 daoCut = (distributeCut * daoRewardCutBps) / 10000;", "    distributeCut -= daoCut;", "", "    // globaIC value comes back in malt.decimals(). Convert to collateralToken.decimals", "    uint256 globalSwingTraderDeficit = (maltDataLab.maltToRewardDecimals(", "      globalIC.swingTraderCollateralDeficit()", "    ) * maltDataLab.priceTarget()) / (10**collateralToken.decimals());", "", "    // this is already in collateralToken.decimals()", "    uint256 lpCut;", "    uint256 swingTraderCut;", "", "    if (globalSwingTraderDeficit == 0) {", "      lpCut = distributeCut;", "    } else {", "      uint256 runwayDeficit = rewardThrottle.runwayDeficit();", "", "      if (runwayDeficit == 0) {", "        swingTraderCut = distributeCut;", "      } else {", "        uint256 totalDeficit = runwayDeficit + globalSwingTraderDeficit;", "", "        uint256 globalSwingTraderRatio = maltDataLab.maltToRewardDecimals(", "          globalIC.swingTraderCollateralRatio()", "        );", "", "        // Already in collateralToken.decimals", "        uint256 poolSwingTraderRatio = impliedCollateralService", "          .swingTraderCollateralRatio();", "", "        if (poolSwingTraderRatio < globalSwingTraderRatio) {", "          swingTraderCut = (distributeCut * swingTraderPreferenceBps) / 10000;", "          lpCut = distributeCut - swingTraderCut;", "        } else {", "          lpCut =", "            (((distributeCut * runwayDeficit) / totalDeficit) *", "              (10000 - lpThrottleBps)) /", "            10000;", "          swingTraderCut = distributeCut - lpCut;", "        }", "      }", "    }", "", "    // Treasury gets paid after everyone else", "    uint256 treasuryCut = rewarded - daoCut - lpCut - swingTraderCut;", "", "    assert(treasuryCut <= rewarded);", "", "    if (swingTraderCut > 0) {", "      collateralToken.safeTransfer(address(swingTrader), swingTraderCut);", "    }", "", "    if (treasuryCut > 0) {", "      collateralToken.safeTransfer(treasury, treasuryCut);", "    }", "", "    if (daoCut > 0) {", "      collateralToken.safeTransfer(dao, daoCut);", "    }", "", "    if (lpCut > 0) {", "      collateralToken.safeTransfer(address(rewardThrottle), lpCut);", "      rewardThrottle.handleReward();", "    }", "", "    emit RewardDistribution(swingTraderCut, lpCut, daoCut, treasuryCut);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _setClaimedToMax(address _user) internal {", "        // New ETH stakers are not entitled to ETH earned by", "        claimed[_user][address(lpTokenETH)] = (accumulatedETHPerLPShare * lpTokenETH.balanceOf(_user)) / PRECISION;", "    }"], "ner_tags": [0, 0, 1, 0]}
{"tokens": ["    function withdraw(Order memory order) public {", "        /* ~~~ CHECKS ~~~ */", "", "        // check order is short", "        require(!order.isLong, \"Must be short position\");", "", "        bytes32 orderHash = hashOrder(order);", "", "        // check msg.sender owns the position", "        require(ownerOf(uint256(orderHash)) == msg.sender, \"Not owner\");", "", "        uint256 longPositionId = uint256(hashOppositeOrder(order));", "        bool isExercised = exercisedPositions[longPositionId];", "", "        // check long position has either been exercised or is expired", "        require(block.timestamp > positionExpirations[longPositionId] || isExercised, \"Must be exercised or expired\");", "", "        /* ~~~ EFFECTS ~~~ */", "", "        // send the short position to 0xdead.", "        // instead of doing a standard burn by sending to 0x000...000, sending", "        // to 0xdead ensures that the same position id cannot be minted again.", "        transferFrom(msg.sender, address(0xdead), uint256(orderHash));", "", "        emit WithdrawOrder(orderHash, order);", "", "        /* ~~~ INTERACTIONS ~~~ */", "", "        // transfer strike to owner if put is expired or call is exercised", "        if ((order.isCall && isExercised) || (!order.isCall && !isExercised)) {", "            // send the fee to the admin/DAO if fee is greater than 0%", "            uint256 feeAmount = 0;", "            if (fee > 0) {", "                feeAmount = (order.strike * fee) / 1000;", "                ERC20(order.baseAsset).safeTransfer(owner(), feeAmount);", "            }", "", "            ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike - feeAmount);", "", "            return;", "        }", "", "        // transfer assets from putty to owner if put is exercised or call is expired", "        if ((order.isCall && !isExercised) || (!order.isCall && isExercised)) {", "            _transferERC20sOut(order.erc20Assets);", "            _transferERC721sOut(order.erc721Assets);", "", "            // for call options the floor token ids are saved in the long position in fillOrder(),", "            // and for put options the floor tokens ids are saved in the short position in exercise()", "            uint256 floorPositionId = order.isCall ? longPositionId : uint256(orderHash);", "            _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[floorPositionId]);", "", "            return;", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _burn(uint256 tokenId) internal override(ERC721Upgradeable) {", "        super._burn(tokenId);", "    }"], "ner_tags": [1, 1, 1]}
{"tokens": ["    function swap(", "        ERC20 tokenIn_,", "        uint256 amountIn_,", "        uint256 minAmountOut_", "    ) external override onlyWhileActive nonReentrant returns (uint256 amountOut) {", "        if (tokenIn_ == ohm) {", "            /// Revert if lower wall is inactive", "            if (!RANGE.active(false)) revert Operator_WallDown();", "", "            /// Calculate amount out (checks for sufficient capacity)", "            amountOut = getAmountOut(tokenIn_, amountIn_);", "", "            /// Revert if amount out less than the minimum specified", "            /// @dev even though price is fixed most of the time,", "            /// it is possible that the amount out could change on a sender", "            /// due to the wall prices being updated before their transaction is processed.", "            /// This would be the equivalent of the heart.beat front-running the sender.", "            if (amountOut < minAmountOut_)", "                revert Operator_AmountLessThanMinimum(amountOut, minAmountOut_);", "", "            /// Decrement wall capacity", "            _updateCapacity(false, amountOut);", "", "            /// If wall is down after swap, deactive the cushion as well", "            _checkCushion(false);", "", "            /// Transfer OHM from sender", "            ohm.safeTransferFrom(msg.sender, address(this), amountIn_);", "", "            /// Burn OHM", "            MINTR.burnOhm(address(this), amountIn_);", "", "            /// Withdraw and transfer reserve to sender", "            TRSRY.withdrawReserves(msg.sender, reserve, amountOut);", "", "            emit Swap(ohm, reserve, amountIn_, amountOut);", "        } else if (tokenIn_ == reserve) {", "            /// Revert if upper wall is inactive", "            if (!RANGE.active(true)) revert Operator_WallDown();", "", "            /// Calculate amount out (checks for sufficient capacity)", "            amountOut = getAmountOut(tokenIn_, amountIn_);", "", "            /// Revert if amount out less than the minimum specified", "            /// @dev even though price is fixed most of the time,", "            /// it is possible that the amount out could change on a sender", "            /// due to the wall prices being updated before their transaction is processed.", "            /// This would be the equivalent of the heart.beat front-running the sender.", "            if (amountOut < minAmountOut_)", "                revert Operator_AmountLessThanMinimum(amountOut, minAmountOut_);", "", "            /// Decrement wall capacity", "            _updateCapacity(true, amountOut);", "", "            /// If wall is down after swap, deactive the cushion as well", "            _checkCushion(true);", "", "            /// Transfer reserves to treasury", "            reserve.safeTransferFrom(msg.sender, address(TRSRY), amountIn_);", "", "            /// Mint OHM to sender", "            MINTR.mintOhm(msg.sender, amountOut);", "", "            emit Swap(reserve, ohm, amountIn_, amountOut);", "        } else {", "            revert Operator_InvalidParams();", "        }", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function checkSignature(bytes calldata _data, bytes calldata _signature)", "        internal", "    {", "        // Calculate hash from bytes", "        bytes32 _hash = keccak256(_data);", "", "        // When there is no contractor", "        if (contractor == address(0)) {", "            // Check for builder's signature", "            checkSignatureValidity(builder, _hash, _signature, 0);", "        }", "        // When there is a contractor", "        else {", "            // When builder has delegated his rights to contractor", "            if (contractorDelegated) {", "                //  Check contractor's signature", "                checkSignatureValidity(contractor, _hash, _signature, 0);", "            }", "            // When builder has not delegated rights to contractor", "            else {", "                // Check for both B and GC signatures", "                checkSignatureValidity(builder, _hash, _signature, 0);", "                checkSignatureValidity(contractor, _hash, _signature, 1);", "            }", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _processCollectWithReferral(", "        uint256 referrerProfileId,", "        address collector,", "        uint256 profileId,", "        uint256 pubId,", "        bytes calldata data", "    ) internal {", "        uint256 amount = _dataByPublicationByProfile[profileId][pubId].amount;", "        address currency = _dataByPublicationByProfile[profileId][pubId].currency;", "        _validateDataIsExpected(data, currency, amount);", "", "        uint256 referralFee = _dataByPublicationByProfile[profileId][pubId].referralFee;", "        address treasury;", "        uint256 treasuryAmount;", "", "        // Avoids stack too deep", "        {", "            uint16 treasuryFee;", "            (treasury, treasuryFee) = _treasuryData();", "            treasuryAmount = (amount * treasuryFee) / BPS_MAX;", "        }", "", "        uint256 adjustedAmount = amount - treasuryAmount;", "", "        if (referralFee != 0) {", "            // The reason we levy the referral fee on the adjusted amount is so that referral fees", "            // don't bypass the treasury fee, in essence referrals pay their fair share to the treasury.", "            uint256 referralAmount = (adjustedAmount * referralFee) / BPS_MAX;", "            adjustedAmount = adjustedAmount - referralAmount;", "", "            address referralRecipient = IERC721(HUB).ownerOf(referrerProfileId);", "", "            IERC20(currency).safeTransferFrom(collector, referralRecipient, referralAmount);", "        }", "        address recipient = _dataByPublicationByProfile[profileId][pubId].recipient;", "", "        IERC20(currency).safeTransferFrom(collector, recipient, adjustedAmount);", "        IERC20(currency).safeTransferFrom(collector, treasury, treasuryAmount);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": ["  function executeOperation(", "    address[] calldata assets,", "    uint256[] calldata amounts,", "    uint256[] calldata premiums,", "    address initiator,", "    bytes calldata params", "  ) external override returns (bool) {", "    (address owner, uint256 vaultId, SwapData memory swapData) = abi.decode(params, (address, uint256, SwapData));", "    IMIMOProxy mimoProxy = IMIMOProxy(proxyRegistry.getCurrentProxy(owner));", "", "    if (initiator != address(mimoProxy)) {", "      revert CustomErrors.INITIATOR_NOT_AUTHORIZED(initiator, address(mimoProxy));", "    }", "    if (msg.sender != address(lendingPool)) {", "      revert CustomErrors.CALLER_NOT_LENDING_POOL(msg.sender, address(lendingPool));", "    }", "", "    IERC20 vaultCollateral = IERC20(assets[0]);", "    uint256 amount = amounts[0];", "    vaultCollateral.safeTransfer(address(mimoProxy), amounts[0]);", "    uint256 flashloanRepayAmount = amount + premiums[0];", "", "    IMIMOProxy(mimoProxy).execute(", "      address(this),", "      abi.encodeWithSignature(", "        \"emptyVaultOperation(address,uint256,uint256,(uint256,bytes))\",", "        vaultCollateral,", "        vaultId,", "        amount,", "        swapData", "      )", "    );", "", "    require(flashloanRepayAmount <= vaultCollateral.balanceOf(address(this)), Errors.CANNOT_REPAY_FLASHLOAN);", "", "    vaultCollateral.safeIncreaseAllowance(address(lendingPool), flashloanRepayAmount);", "", "    return true;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0]}
{"tokens": ["    function withdrawBAKC(", "        ApeCoinStaking _apeCoinStaking,", "        uint256 poolId,", "        ApeCoinStaking.PairNftWithAmount[] memory _nftPairs,", "        address _apeRecipient", "    ) external {", "        ApeCoinStaking.PairNftWithAmount[]", "            memory _otherPairs = new ApeCoinStaking.PairNftWithAmount[](0);", "", "        if (poolId == BAYC_POOL_ID) {", "            _apeCoinStaking.withdrawBAKC(_nftPairs, _otherPairs);", "        } else {", "            _apeCoinStaking.withdrawBAKC(_otherPairs, _nftPairs);", "        }", "", "        uint256 balance = _apeCoinStaking.apeCoin().balanceOf(address(this));", "", "        _apeCoinStaking.apeCoin().safeTransfer(_apeRecipient, balance);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _transfer(", "        address from,", "        address to,", "        uint256 _id", "    ) internal override {", "        Bond memory bond = idToBond(_id);", "        require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\");", "        require(!bond.expired, \"Expired!\");", "        unchecked {", "            require(block.timestamp > bond.mintTime + 300, \"Recent update\");", "            userDebt[from][bond.asset] += bond.pending;", "            bondPaid[_id][bond.asset] += bond.pending;", "        }", "        super._transfer(from, to, _id);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _delegateToPool(", "        DataTypes.ExecuteMarketplaceParams memory params,", "        MarketplaceLocalVars memory vars", "    ) internal returns (uint256, uint256) {", "        uint256 price = 0;", "", "        for (uint256 i = 0; i < params.orderInfo.consideration.length; i++) {", "            ConsiderationItem memory item = params.orderInfo.consideration[i];", "            require(", "                item.startAmount == item.endAmount,", "                Errors.INVALID_MARKETPLACE_ORDER", "            );", "            require(", "                item.itemType == ItemType.ERC20 ||", "                    (vars.isETH && item.itemType == ItemType.NATIVE),", "                Errors.INVALID_ASSET_TYPE", "            );", "            require(", "                item.token == params.credit.token,", "                Errors.CREDIT_DOES_NOT_MATCH_ORDER", "            );", "            price += item.startAmount;", "        }", "", "        uint256 downpayment = price - vars.creditAmount;", "        if (!vars.isETH) {", "            IERC20(vars.creditToken).safeTransferFrom(", "                params.orderInfo.taker,", "                address(this),", "                downpayment", "            );", "            _checkAllowance(vars.creditToken, params.marketplace.operator);", "            // convert to (priceEth, downpaymentEth)", "            price = 0;", "            downpayment = 0;", "        } else {", "            require(params.ethLeft >= downpayment, Errors.PAYNOW_NOT_ENOUGH);", "        }", "", "        return (price, downpayment);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function preTransferHook(", "        address vToken,", "        address src,", "        address dst,", "        uint256 transferTokens", "    ) external override {", "        _checkActionPauseState(vToken, Action.TRANSFER);", "", "        oracle.updatePrice(vToken);", "", "        // Currently the only consideration is whether or not", "        //  the src is allowed to redeem this many tokens", "        _checkRedeemAllowed(vToken, src, transferTokens);", "", "        // Keep the flywheel moving", "        uint256 rewardDistributorsCount = rewardsDistributors.length;", "", "        for (uint256 i; i < rewardDistributorsCount; ++i) {", "            rewardsDistributors[i].updateRewardTokenSupplyIndex(vToken);", "            rewardsDistributors[i].distributeSupplierRewardToken(vToken, src);", "            rewardsDistributors[i].distributeSupplierRewardToken(vToken, dst);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function depositErc20(", "        uint256 toChainId,", "        address tokenAddress,", "        address receiver,", "        uint256 amount,", "        string memory tag", "    ) public tokenChecks(tokenAddress) whenNotPaused nonReentrant {", "        require(", "            tokenManager.getDepositConfig(toChainId, tokenAddress).min <= amount &&", "                tokenManager.getDepositConfig(toChainId, tokenAddress).max >= amount,", "            \"Deposit amount not in Cap limit\"", "        );", "        require(receiver != address(0), \"Receiver address cannot be 0\");", "        require(amount != 0, \"Amount cannot be 0\");", "        address sender = _msgSender();", "", "        uint256 rewardAmount = getRewardAmount(amount, tokenAddress);", "        if (rewardAmount != 0) {", "            incentivePool[tokenAddress] = incentivePool[tokenAddress] - rewardAmount;", "        }", "        liquidityProviders.increaseCurrentLiquidity(tokenAddress, amount);", "        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(tokenAddress), sender, address(this), amount);", "        // Emit (amount + reward amount) in event", "        emit Deposit(sender, tokenAddress, receiver, toChainId, amount + rewardAmount, rewardAmount, tag);", "    }"], "ner_tags": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function unwrap(uint256 amount, address recipient) external override returns (uint256) {", "        TokenUtils.safeTransferFrom(token, msg.sender, address(this), amount);", "", "        uint256 balanceBefore = TokenUtils.safeBalanceOf(token, address(this));", "", "        uint256 amountWithdrawn = IYearnVaultV2(token).withdraw(amount, recipient, MAXIMUM_SLIPPAGE);", "", "        uint256 balanceAfter = TokenUtils.safeBalanceOf(token, address(this));", "", "        // If the Yearn vault did not burn all of the shares then revert. This is critical in mathematical operations", "        // performed by the system because the system always expects that all of the tokens were unwrapped. In Yearn,", "        // this sometimes does not happen in cases where strategies cannot withdraw all of the requested tokens (an", "        // example strategy where this can occur is with Compound and AAVE where funds may not be accessible because", "        // they were lent out).", "        if (balanceBefore - balanceAfter != amount) {", "            revert IllegalState();", "        }", "", "        return amountWithdrawn;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _returnETHIfAnyWithOneWeiLeft() internal {", "        assembly {", "            if gt(selfbalance(), 1) {", "                let status := call(gas(), caller(), sub(selfbalance(), 1), 0, 0, 0, 0)", "            }", "        }", "    }"], "ner_tags": [0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["    function register(uint256 id, address owner, uint duration) external override returns(uint) {", "      return _register(id, owner, duration, true);", "    }"], "ner_tags": [1, 0, 0]}
{"tokens": ["  function populateFromPreviousThrottle(address previousThrottle, uint256 epoch)", "    external", "    onlyRoleMalt(ADMIN_ROLE, \"Only admin role\")", "  {", "    RewardThrottle previous = RewardThrottle(previousThrottle);", "    uint256 _activeEpoch = activeEpoch; // gas", "", "    for (uint256 i = _activeEpoch; i < epoch; ++i) {", "      (", "        uint256 profit,", "        uint256 rewarded,", "        uint256 bondedValue,", "        uint256 desiredAPR,", "        uint256 epochsPerYear,", "        uint256 cumulativeCashflowApr,", "        uint256 cumulativeApr", "      ) = previous.epochData(i);", "", "      state[i].bondedValue = bondedValue;", "      state[i].profit = profit;", "      state[i].rewarded = rewarded;", "      state[i].epochsPerYear = epochsPerYear;", "      state[i].desiredAPR = desiredAPR;", "      state[i].cumulativeCashflowApr = cumulativeCashflowApr;", "      state[i].cumulativeApr = cumulativeApr;", "    }", "", "    activeEpoch = epoch;", "  }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function mintLegendaryGobbler(uint256[] calldata gobblerIds) external returns (uint256 gobblerId) {", "        gobblerId = FIRST_LEGENDARY_GOBBLER_ID + legendaryGobblerAuctionData.numSold; // Assign id.", "", "        // If the gobbler id would be greater than the max supply, there are no remaining legendaries.", "        if (gobblerId > MAX_SUPPLY) revert NoRemainingLegendaryGobblers();", "", "        // This will revert if the auction hasn't started yet, no need to check here as well.", "        uint256 cost = legendaryGobblerPrice();", "", "        if (gobblerIds.length < cost) revert InsufficientGobblerAmount(cost);", "", "        // Overflow should not occur in here, as most math is on emission multiples, which are inherently small.", "        unchecked {", "            uint256 burnedMultipleTotal; // The legendary's emissionMultiple will be 2x the sum of the gobblers burned.", "", "            /*//////////////////////////////////////////////////////////////", "                                    BATCH BURN LOGIC", "            //////////////////////////////////////////////////////////////*/", "", "            uint256 id; // Storing outside the loop saves ~7 gas per iteration.", "", "            for (uint256 i = 0; i < cost; ++i) {", "                id = gobblerIds[i];", "", "                if (id >= FIRST_LEGENDARY_GOBBLER_ID) revert CannotBurnLegendary(id);", "", "                require(getGobblerData[id].owner == msg.sender, \"WRONG_FROM\");", "", "                burnedMultipleTotal += getGobblerData[id].emissionMultiple;", "", "                emit Transfer(msg.sender, getGobblerData[id].owner = address(0), id);", "            }", "", "            /*//////////////////////////////////////////////////////////////", "                                 LEGENDARY MINTING LOGIC", "            //////////////////////////////////////////////////////////////*/", "", "            // The legendary's emissionMultiple is 2x the sum of the multiples of the gobblers burned.", "            getGobblerData[gobblerId].emissionMultiple = uint32(burnedMultipleTotal * 2);", "", "            // Update the user's user data struct in one big batch. We add burnedMultipleTotal to their", "            // emission multiple (not burnedMultipleTotal * 2) to account for the standard gobblers that", "            // were burned and hence should have their multiples subtracted from the user's total multiple.", "            getUserData[msg.sender].lastBalance = uint128(gooBalance(msg.sender)); // Checkpoint balance.", "            getUserData[msg.sender].lastTimestamp = uint64(block.timestamp); // Store time alongside it.", "            getUserData[msg.sender].emissionMultiple += uint32(burnedMultipleTotal); // Update multiple.", "            // We subtract the amount of gobblers burned, and then add 1 to factor in the new legendary.", "            getUserData[msg.sender].gobblersOwned = uint32(getUserData[msg.sender].gobblersOwned - cost + 1);", "", "            // New start price is the max of LEGENDARY_GOBBLER_INITIAL_START_PRICE and cost * 2.", "            legendaryGobblerAuctionData.startPrice = uint120(", "                cost <= LEGENDARY_GOBBLER_INITIAL_START_PRICE / 2 ? LEGENDARY_GOBBLER_INITIAL_START_PRICE : cost * 2", "            );", "            legendaryGobblerAuctionData.numSold += 1; // Increment the # of legendaries sold.", "", "            // If gobblerIds has 1,000 elements this should cost around ~270,000 gas.", "            emit LegendaryGobblerMinted(msg.sender, gobblerId, gobblerIds[:cost]);", "", "            _mint(msg.sender, gobblerId);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function deny(address[] calldata helpers, string calldata message) public {", "        if (block.timestamp >= start) revert TooLate();", "        IReserve(zchf.reserve()).checkQualified(msg.sender, helpers);", "        cooldown = expiration; // since expiration is immutable, we put it under cooldown until the end", "        emit PositionDenied(msg.sender, message);", "    }"], "ner_tags": [0, 0, 0, 1, 0, 0]}
{"tokens": ["    function getEthUsdPrice() public view returns (uint256) {", "        address pairAddress = IUniswapV2Factory(UNISWAP_FACTORY).getPair(", "            USDC,", "            WETH", "        );", "        require(pairAddress != address(0x00), \"pair not found\");", "        IUniswapV2Pair pair = IUniswapV2Pair(pairAddress);", "        (uint256 left, uint256 right, ) = pair.getReserves();", "        (uint256 usdcReserves, uint256 ethReserves) = (USDC < WETH)", "            ? (left, right)", "            : (right, left);", "        uint8 ethDecimals = ERC20(WETH).decimals();", "        //uint8 usdcDecimals = ERC20(USDC).decimals();", "        //returns price in 6 decimals", "        return", "            IUniswapV2Router01(UNISWAP_ROUTER).getAmountOut(", "                10**ethDecimals,", "                ethReserves,", "                usdcReserves", "            );", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function togglePauseDepositEther() external onlyByOwnGov {", "        depositEtherPaused = !depositEtherPaused;", "", "        emit DepositEtherPaused(depositEtherPaused);", "    }"], "ner_tags": [1, 0, 0, 0, 0]}
{"tokens": ["    function addValidator(Validator calldata validator) public onlyByOwnGov {", "        validators.push(validator);", "        emit ValidatorAdded(validator.pubKey, curr_withdrawal_pubkey);", "    }"], "ner_tags": [1, 0, 0, 0]}
{"tokens": ["    function getFunds(string calldata schainName, address erc20OnMainnet, address receiver, uint amount)", "        external", "        override", "        onlySchainOwner(schainName)", "        whenKilled(keccak256(abi.encodePacked(schainName)))", "    {", "        bytes32 schainHash = keccak256(abi.encodePacked(schainName));", "        require(transferredAmount[schainHash][erc20OnMainnet] >= amount, \"Incorrect amount\");", "        _removeTransferredAmount(schainHash, erc20OnMainnet, amount);", "        require(", "            ERC20Upgradeable(erc20OnMainnet).transfer(receiver, amount),", "            \"Transfer was failed\"", "        );", "    }"], "ner_tags": [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _calculateNewRewards(", "        address ajnaPool_,", "        uint256 interestEarned_,", "        uint256 nextEpoch_,", "        uint256 epoch_,", "        uint256 rewardsClaimedInEpoch_", "    ) internal view returns (uint256 newRewards_) {", "        (", "            ,", "            // total interest accumulated by the pool over the claim period", "            uint256 totalBurnedInPeriod,", "            // total tokens burned over the claim period", "            uint256 totalInterestEarnedInPeriod", "        ) = _getPoolAccumulators(ajnaPool_, nextEpoch_, epoch_);", "", "        // calculate rewards earned", "        newRewards_ = totalInterestEarnedInPeriod == 0 ? 0 : Maths.wmul(", "            REWARD_FACTOR,", "            Maths.wdiv(", "                Maths.wmul(interestEarned_, totalBurnedInPeriod),", "                totalInterestEarnedInPeriod", "            )", "        );", "", "        uint256 rewardsCapped = Maths.wmul(REWARD_CAP, totalBurnedInPeriod);", "", "        // Check rewards claimed - check that less than 80% of the tokens for a given burn event have been claimed.", "        if (rewardsClaimedInEpoch_ + newRewards_ > rewardsCapped) {", "", "            // set claim reward to difference between cap and reward", "            newRewards_ = rewardsCapped - rewardsClaimedInEpoch_;", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["    function _calculateTotal(", "        uint256 _scalar,", "        uint256 _lastTotalSupply,", "        uint256 _totalEth,", "        uint256 _totalFractions", "    ) private pure returns (uint256) {", "        return", "            (_totalEth * _scalar) /", "            (_scalar - ((_totalFractions * _scalar) / _lastTotalSupply));", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["  function distributeYield(uint256 _offset, uint256 _count) external onlyAdmin {", "    // 1. convert from asset to exchange token via uniswap", "    for (uint256 i = 0; i < _count; i++) {", "      address asset = _assetsList[_offset + i];", "      require(asset != address(0), Errors.UL_INVALID_INDEX);", "      uint256 _amount = IERC20Detailed(asset).balanceOf(address(this));", "      _convertAssetToExchangeToken(asset, _amount);", "    }", "    uint256 exchangedAmount = IERC20Detailed(_exchangeToken).balanceOf(address(this));", "", "    // 2. convert from exchange token to other stable assets via curve swap", "    AssetYield[] memory assetYields = _getAssetYields(exchangedAmount);", "    for (uint256 i = 0; i < assetYields.length; i++) {", "      if (assetYields[i].amount > 0) {", "        uint256 _amount = _convertToStableCoin(assetYields[i].asset, assetYields[i].amount);", "        // 3. deposit Yield to pool for suppliers", "        _depositYield(assetYields[i].asset, _amount);", "      }", "    }", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": ["    function getFunds(string calldata schainName, address payable receiver, uint amount)", "        external", "        override", "        onlySchainOwner(schainName)", "        whenKilled(keccak256(abi.encodePacked(schainName)))", "    {", "        require(receiver != address(0), \"Receiver address has to be set\");", "        bytes32 schainHash = keccak256(abi.encodePacked(schainName));", "        require(transferredAmount[schainHash] >= amount, \"Incorrect amount\");", "        _removeTransferredAmount(schainHash, amount);", "        receiver.sendValue(amount);", "    }"], "ner_tags": [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function checkSignatureValidity(", "        address _address,", "        bytes32 _hash,", "        bytes memory _signature,", "        uint256 _signatureIndex", "    ) internal {", "        address _recoveredSignature = SignatureDecoder.recoverKey(", "            _hash,", "            _signature,", "            _signatureIndex", "        );", "        require(", "            _recoveredSignature == _address || approvedHashes[_address][_hash],", "            \"Project::invalid signature\"", "        );", "        // delete from approvedHash", "        delete approvedHashes[_address][_hash];", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function _executeNonAtomicOrders(", "        BasicOrder[] calldata orders,", "        bytes[] calldata ordersExtraData,", "        address recipient,", "        uint256 feeBp,", "        address feeRecipient", "    ) private {", "        uint256 fee;", "        address lastOrderCurrency;", "        for (uint256 i; i < orders.length; ) {", "            OrderExtraData memory orderExtraData = abi.decode(ordersExtraData[i], (OrderExtraData));", "            AdvancedOrder memory advancedOrder;", "            advancedOrder.parameters = _populateParameters(orders[i], orderExtraData);", "            advancedOrder.numerator = orderExtraData.numerator;", "            advancedOrder.denominator = orderExtraData.denominator;", "            advancedOrder.signature = orders[i].signature;", "", "            address currency = orders[i].currency;", "            uint256 price = orders[i].price;", "", "            try", "                marketplace.fulfillAdvancedOrder{value: currency == address(0) ? price : 0}(", "                    advancedOrder,", "                    new CriteriaResolver[](0),", "                    bytes32(0),", "                    recipient", "                )", "            {", "                if (feeRecipient != address(0)) {", "                    uint256 orderFee = (price * feeBp) / 10000;", "                    if (currency == lastOrderCurrency) {", "                        fee += orderFee;", "                    } else {", "                        if (fee > 0) _transferFee(fee, lastOrderCurrency, feeRecipient);", "", "                        lastOrderCurrency = currency;", "                        fee = orderFee;", "                    }", "                }", "            } catch {}", "", "            unchecked {", "                ++i;", "            }", "        }", "", "        if (fee > 0) _transferFee(fee, lastOrderCurrency, feeRecipient);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["    function isRewardClaimed(bytes32 _identifier, uint256 _index)", "        public", "        view", "        returns (bool)", "    {", "        // Get the group index for the specified index along with the bit index", "        // and check if the corresponding bit index is flipped", "        Reward memory reward = rewards[_identifier];", "        uint256 claimedGroup = _index / 256;", "        uint256 claimedIndex = _index % 256;", "        uint256 claimedGroupState = claimed[_identifier][reward.updateCount][", "            claimedGroup", "        ];", "        uint256 mask = (1 << claimedIndex);", "        return claimedGroupState & mask == mask;", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function depositERC20(", "        string calldata schainName,", "        address erc20OnMainnet,", "        uint256 amount", "    )", "        external", "        override", "        rightTransaction(schainName, msg.sender)", "        whenNotKilled(keccak256(abi.encodePacked(schainName)))", "    {", "        bytes32 schainHash = keccak256(abi.encodePacked(schainName));", "        address contractReceiver = schainLinks[schainHash];", "        require(contractReceiver != address(0), \"Unconnected chain\");", "        require(", "            ERC20Upgradeable(erc20OnMainnet).allowance(msg.sender, address(this)) >= amount,", "            \"DepositBox was not approved for ERC20 token\"", "        );", "        bytes memory data = _receiveERC20(", "            schainName,", "            erc20OnMainnet,", "            msg.sender,", "            amount", "        );", "        _saveTransferredAmount(schainHash, erc20OnMainnet, amount);", "        require(", "            ERC20Upgradeable(erc20OnMainnet).transferFrom(", "                msg.sender,", "                address(this),", "                amount", "            ),", "            \"Transfer was failed\"", "        );", "        messageProxy.postOutgoingMessage(", "            schainHash,", "            contractReceiver,", "            data", "        );", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function addGate(uint priceFloor, uint priceDecay, uint priceIncrease, uint priceIncreaseDenominator, address beneficiary) external {", "        // prefix operator increments then evaluates", "        Gate storage gate = gates[++numGates];", "        gate.priceFloor = priceFloor;", "        gate.decayFactor = priceDecay;", "        gate.priceIncreaseFactor = priceIncrease;", "        gate.priceIncreaseDenominator = priceIncreaseDenominator;", "        gate.beneficiary = beneficiary;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["    function intToUint(int256 a) internal pure returns (uint256) {", "        if (a < 0) {", "            return uint256(-a);", "        } else {", "            return uint256(a);", "        }", "    }"], "ner_tags": [0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["    function estimatedAPR() external view returns (uint256 apr) {", "        uint256 currentlyVestingProfit = vestingProfit;", "        uint256 weightedAssets = vestingPeriod * totalAssets();", "        if (currentlyVestingProfit != 0 && weightedAssets != 0)", "            apr = (currentlyVestingProfit * 3600 * 24 * 365 * BASE_18) / weightedAssets;", "    }"], "ner_tags": [0, 0, 0, 0, 1, 0]}
{"tokens": ["    function refund() public {", "        Receipt memory r = receipts[msg.sender];", "        uint80 price = uint80(getPrice()) * r.amount;", "        uint80 owed = r.balance - price;", "        require(owed > 0, \"NOTHING TO REFUND\");", "        receipts[msg.sender].balance = price;", "        payable(msg.sender).transfer(owed);", "    }"], "ner_tags": [0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function _lockCurve() internal {", "        if(cooldown) {", "          return;", "        }", "", "        uint256 crvBalance = IERC20(crvBpt).balanceOf(address(this));", "        if(crvBalance > 0){", "            IERC20(crvBpt).safeTransfer(staker, crvBalance);", "        }", "        ", "        //increase ammount", "        uint256 crvBalanceStaker = IERC20(crvBpt).balanceOf(staker);", "        if(crvBalanceStaker == 0){", "            return;", "        }", "        ", "        //increase amount", "        IStaker(staker).increaseAmount(crvBalanceStaker);", "        ", "", "        uint256 unlockAt = block.timestamp + MAXTIME;", "        uint256 unlockInWeeks = (unlockAt/WEEK)*WEEK;", "", "        //increase time too if over 2 week buffer", "        if(unlockInWeeks.sub(unlockTime) > 2){", "            IStaker(staker).increaseTime(unlockAt);", "            unlockTime = unlockInWeeks;", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": ["  modifier onlyOwner() {", "    if (msg.sender == holographer()) {", "      require(msgSender() == _getOwner(), \"ERC721: owner only function\");", "    } else {", "      require(msg.sender == _getOwner(), \"ERC721: owner only function\");", "    }", "    _;", "  }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function setBadCollateralRatio(address pool, uint256 newRatio) external onlyRole(DAO) {", "        require(newRatio >= 130 * 1e18 && newRatio <= 150 * 1e18 && newRatio <= vaultSafeCollateralRatio[pool] + 1e19, \"LNA\");", "        vaultBadCollateralRatio[pool] = newRatio;", "        emit SafeCollateralRatioChanged(pool, newRatio);", "    }"], "ner_tags": [0, 1, 0, 0, 0]}
{"tokens": ["    function cash(address _vault, bytes32[] calldata _burnProof) external {", "        // Reverts if address is not a registered vault", "        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(", "            _vault", "        );", "        if (id == 0) revert NotVault(_vault);", "        // Reverts if auction state is not successful", "        (, , State current, , uint256 ethBalance, ) = this.buyoutInfo(_vault);", "        State required = State.SUCCESS;", "        if (current != required) revert InvalidState(required, current);", "        // Reverts if caller has a balance of zero fractional tokens", "        uint256 tokenBalance = IERC1155(token).balanceOf(msg.sender, id);", "        if (tokenBalance == 0) revert NoFractions();", "", "        // Initializes vault transaction", "        bytes memory data = abi.encodeCall(", "            ISupply.burn,", "            (msg.sender, tokenBalance)", "        );", "        // Executes burn of fractional tokens from caller", "        IVault(payable(_vault)).execute(supply, data, _burnProof);", "", "        // Transfers buyout share amount to caller based on total supply", "        uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);", "        uint256 buyoutShare = (tokenBalance * ethBalance) /", "            (totalSupply + tokenBalance);", "        _sendEthOrWeth(msg.sender, buyoutShare);", "        // Emits event for cashing out of buyout pool", "        emit Cash(_vault, msg.sender, buyoutShare);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0]}
{"tokens": ["    modifier beforeTicketRegistrationDeadline(uint128 drawId) {", "        // slither-disable-next-line timestamp", "        if (block.timestamp > ticketRegistrationDeadline(drawId)) {", "            revert TicketRegistrationClosed(drawId);", "        }", "        _;", "    }"], "ner_tags": [0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["    function getAssetPrice(address asset) public view returns (uint256) {", "        try IERC165(asset).supportsInterface(INTERFACE_ID_ERC721) returns (", "            bool supported", "        ) {", "            if (supported == true) {", "                return INFTOracle(BEND_DAO).getAssetPrice(asset);", "            }", "        } catch {}", "", "        address pairAddress = IUniswapV2Factory(UNISWAP_FACTORY).getPair(", "            WETH,", "            asset", "        );", "        require(pairAddress != address(0x00), \"pair not found\");", "        IUniswapV2Pair pair = IUniswapV2Pair(pairAddress);", "        (uint256 left, uint256 right, ) = pair.getReserves();", "        (uint256 tokenReserves, uint256 ethReserves) = (asset < WETH)", "            ? (left, right)", "            : (right, left);", "        uint8 decimals = ERC20(asset).decimals();", "        //returns price in 18 decimals", "        return", "            IUniswapV2Router01(UNISWAP_ROUTER).getAmountOut(", "                10**decimals,", "                tokenReserves,", "                ethReserves", "            );", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function _burn(", "        address _account,", "        uint256 _id,", "        uint256 _amount", "    ) internal virtual {", "        if (_account == address(0)) revert LBToken__BurnFromAddress0();", "", "        uint256 _accountBalance = _balances[_id][_account];", "        if (_accountBalance < _amount) revert LBToken__BurnExceedsBalance(_account, _id, _amount);", "", "        _beforeTokenTransfer(address(0), _account, _id, _amount);", "", "        unchecked {", "            _balances[_id][_account] = _accountBalance - _amount;", "            _totalSupplies[_id] -= _amount;", "        }", "", "        _remove(_account, _id, _accountBalance, _amount);", "", "        emit TransferSingle(msg.sender, _account, address(0), _id, _amount);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function sellFractions(address _vault, uint256 _amount) external {", "        // Reverts if address is not a registered vault", "        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(", "            _vault", "        );", "        if (id == 0) revert NotVault(_vault);", "        (uint256 startTime, , State current, uint256 fractionPrice, , ) = this", "            .buyoutInfo(_vault);", "        // Reverts if auction state is not live", "        State required = State.LIVE;", "        if (current != required) revert InvalidState(required, current);", "        // Reverts if current time is greater than end time of proposal period", "        uint256 endTime = startTime + PROPOSAL_PERIOD;", "        if (block.timestamp > endTime)", "            revert TimeExpired(block.timestamp, endTime);", "", "        // Transfers fractional tokens to pool from caller", "        IERC1155(token).safeTransferFrom(", "            msg.sender,", "            address(this),", "            id,", "            _amount,", "            \"\"", "        );", "", "        // Updates ether balance of pool", "        uint256 ethAmount = fractionPrice * _amount;", "        buyoutInfo[_vault].ethBalance -= ethAmount;", "        // Transfers ether amount to caller", "        _sendEthOrWeth(msg.sender, ethAmount);", "        // Emits event for selling fractions into pool", "        emit SellFractions(msg.sender, _amount);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function _handleStrategistInterestReward(", "    VaultData storage s,", "    uint256 interestOwing,", "    uint256 amount", "  ) internal virtual {", "    if (VAULT_FEE() != uint256(0)) {", "      uint256 x = (amount > interestOwing) ? interestOwing : amount;", "      uint256 fee = x.mulDivDown(VAULT_FEE(), 10000);", "      uint88 feeInShares = convertToShares(fee).safeCastTo88();", "      s.strategistUnclaimedShares += feeInShares;", "      emit StrategistFee(feeInShares);", "    }", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["    function _buys(uint256 id, uint256 amount) internal returns (bool) {", "        require(buyEnabled);", "        if (amount == offers[id].pay_amt) {", "            if (isOfferSorted(id)) {", "                //offers[id] must be removed from sorted list because all of it is bought", "                _unsort(id);", "            } else {", "                _hide(id);", "            }", "        }", "", "        require(super.buy(id, amount));", "", "        // If offer has become dust during buy, we cancel it", "        if (", "            isActive(id) &&", "            offers[id].pay_amt < _dust[address(offers[id].pay_gem)]", "        ) {", "            dustId = id; //enable current msg.sender to call cancel(id)", "            cancel(id);", "        }", "        return true;", "    }"], "ner_tags": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _getUserBalanceForERC721(", "        DataTypes.CalculateUserAccountDataParams memory params,", "        CalculateUserAccountDataVars memory vars", "    ) private view returns (uint256 totalValue) {", "        INToken nToken = INToken(vars.xTokenAddress);", "        bool isAtomicPrice = nToken.getAtomicPricingConfig();", "        if (isAtomicPrice) {", "            uint256 totalBalance = nToken.balanceOf(params.user);", "", "            for (uint256 index = 0; index < totalBalance; index++) {", "                uint256 tokenId = nToken.tokenOfOwnerByIndex(", "                    params.user,", "                    index", "                );", "                if (", "                    ICollateralizableERC721(vars.xTokenAddress)", "                        .isUsedAsCollateral(tokenId)", "                ) {", "                    totalValue += _getTokenPrice(", "                        params.oracle,", "                        vars.currentReserveAddress,", "                        tokenId", "                    );", "                }", "            }", "        } else {", "            uint256 assetPrice = _getAssetPrice(", "                params.oracle,", "                vars.currentReserveAddress", "            );", "            totalValue =", "                ICollateralizableERC721(vars.xTokenAddress)", "                    .collateralizedBalanceOf(params.user) *", "                assetPrice;", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["    function requestPermissions()", "        external", "        view", "        override", "        onlyKernel", "        returns (Permissions[] memory requests)", "    {", "        requests = new Permissions[](2);", "        requests[0] = Permissions(INSTR.KEYCODE(), INSTR.store.selector);", "        requests[1] = Permissions(VOTES.KEYCODE(), VOTES.transferFrom.selector);", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function getWithdrawalLimitInternal(address user) internal returns (uint) {", "        IEscrow escrow = predictEscrow(user);", "        uint collateralBalance = escrow.balance();", "        if(collateralBalance == 0) return 0;", "        uint debt = debts[user];", "        if(debt == 0) return collateralBalance;", "        if(collateralFactorBps == 0) return 0;", "        uint minimumCollateral = debt * 1 ether / oracle.getPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;", "        if(collateralBalance <= minimumCollateral) return 0;", "        return collateralBalance - minimumCollateral;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["    function removeLiquidity(uint256 _nftId, uint256 _amount)", "        external", "        nonReentrant", "        onlyValidLpToken(_nftId, _msgSender())", "        whenNotPaused", "    {", "        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);", "        require(_isSupportedToken(_tokenAddress), \"ERR__TOKEN_NOT_SUPPORTED\");", "", "        require(_amount != 0, \"ERR__INVALID_AMOUNT\");", "        require(nftSuppliedLiquidity >= _amount, \"ERR__INSUFFICIENT_LIQUIDITY\");", "        whiteListPeriodManager.beforeLiquidityRemoval(_msgSender(), _tokenAddress, _amount);", "        // Claculate how much shares represent input amount", "        uint256 lpSharesForInputAmount = _amount * getTokenPriceInLPShares(_tokenAddress);", "", "        // Calculate rewards accumulated", "        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);", "        ", "        uint256 lpFeeAccumulated;", "", "        // Handle edge cases where eligibleLiquidity is less than what was supplied by very small amount ", "        if(nftSuppliedLiquidity > eligibleLiquidity) {", "            lpFeeAccumulated = 0;", "        } else {", "            unchecked {", "                lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;", "            }", "        }", "        // Calculate amount of lp shares that represent accumulated Fee", "        uint256 lpSharesRepresentingFee = lpFeeAccumulated * getTokenPriceInLPShares(_tokenAddress);", "", "        totalLPFees[_tokenAddress] -= lpFeeAccumulated;", "        uint256 amountToWithdraw = _amount + lpFeeAccumulated;", "        uint256 lpSharesToBurn = lpSharesForInputAmount + lpSharesRepresentingFee;", "", "        // Handle round off errors to avoid dust lp token in contract", "        if (totalNFTShares - lpSharesToBurn < BASE_DIVISOR) {", "            lpSharesToBurn = totalNFTShares;", "        }", "        totalReserve[_tokenAddress] -= amountToWithdraw;", "        totalLiquidity[_tokenAddress] -= _amount;", "        totalSharesMinted[_tokenAddress] -= lpSharesToBurn;", "", "        _decreaseCurrentLiquidity(_tokenAddress, _amount);", "", "        _burnSharesFromNft(_nftId, lpSharesToBurn, _amount, _tokenAddress);", "", "        _transferFromLiquidityPool(_tokenAddress, _msgSender(), amountToWithdraw);", "", "        emit LiquidityRemoved(_tokenAddress, amountToWithdraw, _msgSender());", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function withdrawReserves(", "        address to_,", "        ERC20 token_,", "        uint256 amount_", "    ) public {", "        _checkApproval(msg.sender, token_, amount_);", "", "        token_.safeTransfer(to_, amount_);", "", "        emit Withdrawal(msg.sender, to_, token_, amount_);", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    constructor(Kernel kernel_) Policy(kernel_) {}"], "ner_tags": [1]}
{"tokens": ["    function withdraw(uint amount) public {", "        _updateRewardForAllTokens();", "", "        uint tokenId = 0;", "        if (amount == balanceOf[msg.sender]) {", "            tokenId = tokenIds[msg.sender];", "        }", "        withdrawToken(amount, tokenId);", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function _swap(bytes memory swapPath, uint256 amount) internal returns (uint256 amountOut) {", "        IERC20Detailed(swapPath.toAddress(0)).approve(address(swapRouter), amount);", "        amountOut = swapRouter.exactInput(", "            ISwapRouter.ExactInputParams(swapPath, address(this), block.timestamp + 200, amount, 0)", "        );", "        IERC20Detailed(swapPath.toAddress(0)).approve(address(swapRouter), 0);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function recordPaymentFrom(", "    address _payer,", "    JBTokenAmount calldata _amount,", "    uint256 _projectId,", "    uint256 _baseWeightCurrency,", "    address _beneficiary,", "    string calldata _memo,", "    bytes memory _metadata", "  )", "    external", "    override", "    nonReentrant", "    returns (", "      JBFundingCycle memory fundingCycle,", "      uint256 tokenCount,", "      IJBPayDelegate delegate,", "      string memory memo", "    )", "  {", "    // Get a reference to the current funding cycle for the project.", "    fundingCycle = fundingCycleStore.currentOf(_projectId);", "", "    // The project must have a funding cycle configured.", "    if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();", "", "    // Must not be paused.", "    if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();", "", "    // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals.", "    uint256 _weight;", "", "    // If the funding cycle has configured a data source, use it to derive a weight and memo.", "    if (fundingCycle.useDataSourceForPay()) {", "      // Create the params that'll be sent to the data source.", "      JBPayParamsData memory _data = JBPayParamsData(", "        IJBSingleTokenPaymentTerminal(msg.sender),", "        _payer,", "        _amount,", "        _projectId,", "        fundingCycle.configuration,", "        _beneficiary,", "        fundingCycle.weight,", "        fundingCycle.reservedRate(),", "        _memo,", "        _metadata", "      );", "      (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(", "        _data", "      );", "    }", "    // Otherwise use the funding cycle's weight", "    else {", "      _weight = fundingCycle.weight;", "      memo = _memo;", "    }", "", "    // If there's no amount being recorded, there's nothing left to do.", "    if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);", "", "    // Add the amount to the token balance of the project.", "    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =", "      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +", "      _amount.value;", "", "    // If there's no weight, token count must be 0 so there's nothing left to do.", "    if (_weight == 0) return (fundingCycle, 0, delegate, memo);", "", "    // Get a reference to the number of decimals in the amount. (prevents stack too deep).", "    uint256 _decimals = _amount.decimals;", "", "    // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor.", "    // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`.", "    uint256 _weightRatio = _amount.currency == _baseWeightCurrency", "      ? 10**_decimals", "      : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);", "", "    // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has.", "    tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["    function _setClaimed(bytes32 _identifier, uint256 _index) internal {", "        Reward memory reward = rewards[_identifier];", "        uint256 claimedGroup = _index / 256;", "        uint256 claimedIndex = _index % 256;", "", "        // Flip the bit state to mark the corresponding index as claimed", "        claimed[_identifier][reward.updateCount][claimedGroup] =", "            claimed[_identifier][reward.updateCount][claimedGroup] |", "            (1 << claimedIndex);", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function setNewBlock(", "        bytes32 _prevBlockHash,", "        uint256 _newTimestamp,", "        uint256 _expectedNewNumber,", "        uint256 _baseFee", "    ) external onlyBootloader {", "        (uint256 currentBlockNumber, uint256 currentBlockTimestamp) = getBlockNumberAndTimestamp();", "        require(_newTimestamp >= currentBlockTimestamp, \"Timestamps should be incremental\");", "        require(currentBlockNumber + 1 == _expectedNewNumber, \"The provided block number is not correct\");", "", "        blockHash[currentBlockNumber] = _prevBlockHash;", "", "        // Setting new block number and timestamp", "        currentBlockInfo = (currentBlockNumber + 1) * BLOCK_INFO_BLOCK_NUMBER_PART + _newTimestamp;", "", "        baseFee = _baseFee;", "", "        // The correctness of this block hash and the timestamp will be checked on L1:", "        SystemContractHelper.toL1(false, bytes32(_newTimestamp), _prevBlockHash);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function setFee(uint256 f) external authorized(admin) returns (bool) {", "        feenominator = f;", "        return true;", "    }"], "ner_tags": [1, 0, 0, 0]}
{"tokens": ["    function fundPool(uint poolId) internal {", "        Pool storage pool = pools[poolId];", "        bool success = true;", "        uint amount;", "        for (uint i = 0; i < pool.rewardFunding.length; i++) {", "            amount = getMaximumRewards(poolId, i);", "            // transfer the tokens from pool-creator to this contract", "            success = success && IERC20(pool.rewardTokens[i]).transferFrom(msg.sender, address(this), amount);", "            // bookkeeping to make sure pools don't share tokens", "            pool.rewardFunding[i] += amount;", "        }", "        require(success, 'Token deposits failed');", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["  function _redeemFutureEpoch(", "    VaultData storage s,", "    uint256 shares,", "    address receiver,", "    address owner,", "    uint64 epoch", "  ) internal virtual returns (uint256 assets) {", "    // check to ensure that the requested epoch is not in the past", "", "    ERC20Data storage es = _loadERC20Slot();", "", "    if (msg.sender != owner) {", "      uint256 allowed = es.allowance[owner][msg.sender]; // Saves gas for limited approvals.", "", "      if (allowed != type(uint256).max) {", "        es.allowance[owner][msg.sender] = allowed - shares;", "      }", "    }", "", "    if (epoch < s.currentEpoch) {", "      revert InvalidState(InvalidStates.EPOCH_TOO_LOW);", "    }", "    require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");", "    // check for rounding error since we round down in previewRedeem.", "", "    //this will underflow if not enough balance", "    es.balanceOf[owner] -= shares;", "", "    // Cannot overflow because the sum of all user", "    // balances can't exceed the max uint256 value.", "    unchecked {", "      es.balanceOf[address(this)] += shares;", "    }", "", "    emit Transfer(owner, address(this), shares);", "    // Deploy WithdrawProxy if no WithdrawProxy exists for the specified epoch", "    _deployWithdrawProxyIfNotDeployed(s, epoch);", "", "    emit Withdraw(msg.sender, receiver, owner, assets, shares);", "", "    // WithdrawProxy shares are minted 1:1 with PublicVault shares", "    WithdrawProxy(s.epochData[epoch].withdrawProxy).mint(shares, receiver);", "  }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function withdraw(uint256 _pid, uint256 _amount) public {", "        PoolInfo storage pool = poolInfo[_pid];", "        UserInfo storage user = userInfo[_pid][msg.sender];", "        require(user.amount >= _amount, \"withdraw: not good\");", "        updatePool(_pid);", "        uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(", "            user.rewardDebt", "        );", "        safeRewardTransfer(msg.sender, pending);", "        user.amount = user.amount.sub(_amount);", "        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);", "        pool.lpToken.safeTransfer(address(msg.sender), _amount);", "", "        //extra rewards", "        IRewarder _rewarder = pool.rewarder;", "        if (address(_rewarder) != address(0)) {", "            _rewarder.onReward(_pid, msg.sender, msg.sender, pending, user.amount);", "        }", "", "        emit RewardPaid(msg.sender, _pid, pending);", "        emit Withdraw(msg.sender, _pid, _amount);", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["\tfunction convertToShares(uint256 assets) public view virtual returns (uint256) {", "\t\tuint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.", "", "\t\treturn supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());", "\t}"], "ner_tags": [0, 0, 0, 1, 0]}
{"tokens": ["    function changeFee(", "        address tokenAddress,", "        uint256 _equilibriumFee,", "        uint256 _maxFee", "    ) external override onlyOwner whenNotPaused {", "        require(_equilibriumFee != 0, \"Equilibrium Fee cannot be 0\");", "        require(_maxFee != 0, \"Max Fee cannot be 0\");", "        tokensInfo[tokenAddress].equilibriumFee = _equilibriumFee;", "        tokensInfo[tokenAddress].maxFee = _maxFee;", "        emit FeeChanged(tokenAddress, tokensInfo[tokenAddress].equilibriumFee, tokensInfo[tokenAddress].maxFee);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}
{"tokens": ["    function transferFrom(address from, address to, uint256 amount) public returns (bool) {", "        address spender = _msgSender();", "        if (!configurator.mintVault(spender)) {", "            _spendAllowance(from, spender, amount);", "        }", "        _transfer(from, to, amount);", "        return true;", "    }"], "ner_tags": [0, 0, 1, 1, 1, 0, 0, 0]}
{"tokens": ["  function repay(", "    ILineOfCredit.Credit memory credit,", "    bytes32 id,", "    uint256 amount", "  )", "    external", "    returns (ILineOfCredit.Credit memory)", "  { unchecked {", "      if (amount <= credit.interestAccrued) {", "          credit.interestAccrued -= amount;", "          credit.interestRepaid += amount;", "          emit RepayInterest(id, amount);", "          return credit;", "      } else {", "          uint256 interest = credit.interestAccrued;", "          uint256 principalPayment = amount - interest;", "", "          // update individual credit line denominated in token", "          credit.principal -= principalPayment;", "          credit.interestRepaid += interest;", "          credit.interestAccrued = 0;", "", "          emit RepayInterest(id, interest);", "          emit RepayPrincipal(id, principalPayment);", "", "          return credit;", "      }", "  } }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function list(address _vault, bytes32[] calldata _listProof) public {", "        // Reverts if vault is not registered", "        (address token, uint256 id) = _verifyVault(_vault);", "        // Reverts if vault is not current owner of the assets", "        if (_verifySale(_vault)) revert NotOwner();", "        // Reverts if collateral of proposed listing has been rejected", "        Listing storage proposedListing = proposedListings[_vault];", "        if (proposedListing.collateral == 0) revert Rejected();", "        // Reverts if proposal period has not elapsed", "        if (proposedListing.proposalDate + PROPOSAL_PERIOD > block.timestamp)", "            revert TimeNotElapsed();", "", "        // Sets remaining collateral amount of proposer for withdrawal", "        Listing memory activeListing = activeListings[_vault];", "        pendingBalances[_vault][activeListing.proposer] = activeListing.collateral;", "", "        // Calculates new listing price", "        uint256 newPrice = proposedListing.pricePerToken * IRae(token).totalSupply(id);", "", "        // Structures the order array", "        Order[] memory order = new Order[](1);", "        order[0] = proposedListing.order;", "", "        // Replaces active listing with the successfully proposed listing", "        activeListings[_vault] = proposedListing;", "        // Resets proposed listing to default", "        _setListing(proposedListing, address(this), 0, type(uint256).max, 0);", "", "        // List order on Seaport", "        bytes memory data = abi.encodeCall(ISeaportLister.validateListing, (seaport, order));", "        IVault(payable(_vault)).execute(seaportLister, data, _listProof);", "", "        // Emits event for successful listing", "        emit List(_vault, newPrice, activeListings[_vault].order);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function addGas(", "        bytes32 txHash,", "        uint256 logIndex,", "        address gasToken,", "        uint256 gasFeeAmount,", "        address refundAddress", "    ) external override {", "        _safeTransferFrom(gasToken, msg.sender, gasFeeAmount);", "", "        emit GasAdded(txHash, logIndex, gasToken, gasFeeAmount, refundAddress);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function popValidators(uint256 times) public onlyByOwnGov {", "        // Loop through and remove validator entries at the end", "        for (uint256 i = 0; i < times; ++i) {", "            validators.pop();", "        }", "", "        emit ValidatorsPopped(times);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function executeOperation(", "        address[] calldata assets,", "        uint256[] calldata amounts,", "        uint256[] calldata premiums,", "        address initiator,", "        bytes calldata params", "    ) external override returns (bool) {", "        require(msg.sender == address(LENDING_POOL), \"Flashloan from untrusted lending pool\");", "        require(initiator == address(LP_VAULT), \"Flashloan must be initiated from LP Vault\");", "        //", "        // This contract now has the funds requested.", "        // Your logic goes here.", "        //", "", "        IUniV3LpVault.FlashFocusParams memory focusParams = abi.decode(params, (IUniV3LpVault.FlashFocusParams));", "        IERC20(assets[0]).approve(address(LP_VAULT), amounts[0]);", "        focusParams.asset = assets[0];", "        focusParams.amount = amounts[0];", "        focusParams.premium = premiums[0];", "", "        LP_VAULT.flashFocusCall(focusParams);", "", "        // Approve the LendingPool contract allowance to *pull* the owed amount", "        uint256 amountOwing = amounts[0].add(premiums[0]);", "        IERC20(assets[0]).transferFrom(address(LP_VAULT), address(this), amountOwing);", "        IERC20(assets[0]).approve(address(LENDING_POOL), amountOwing);", "", "        return true;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["    function swapForETH(", "        uint256 pay_amt,", "        uint256 buy_amt_min,", "        address[] calldata route, // First address is what is being payed, Last address is what is being bought", "        uint256 expectedMarketFeeBPS", "    ) external payable returns (uint256 fill) {", "        require(", "            route[route.length - 1] == wethAddress,", "            \"target of swap is not WETH\"", "        );", "        //Transfer tokens here first and account for fee", "        require(", "            ERC20(route[0]).transferFrom(", "                msg.sender,", "                address(this),", "                pay_amt.add(pay_amt.mul(expectedMarketFeeBPS).div(10000))", "            ),", "            \"initial ERC20 transfer failed\"", "        );", "        fill = _swap(", "            pay_amt,", "            buy_amt_min,", "            route,", "            expectedMarketFeeBPS,", "            address(this)", "        );", "", "        WETH9(wethAddress).withdraw(fill);", "        // msg.sender.transfer(fill);", "        msg.sender.transfer(fill);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["    function _swap(", "        uint256 pay_amt,", "        uint256 buy_amt_min,", "        address[] calldata route, // First address is what is being payed, Last address is what is being bought", "        uint256 expectedMarketFeeBPS,", "        address to // Recipient of swap outputs!", "    ) internal returns (uint256) {", "        address _market = RubiconMarketAddress;", "        uint256 currentAmount = 0;", "        for (uint256 i = 0; i < route.length - 1; i++) {", "            (address input, address output) = (route[i], route[i + 1]);", "            uint256 _pay = i == 0", "                ? pay_amt", "                : (", "                    currentAmount.sub(", "                        currentAmount.mul(expectedMarketFeeBPS).div(10000)", "                    )", "                );", "            if (ERC20(input).allowance(address(this), _market) == 0) {", "                approveAssetOnMarket(input);", "            }", "            uint256 fillAmount = RubiconMarket(_market).sellAllAmount(", "                ERC20(input),", "                _pay,", "                ERC20(output),", "                0 //naively assume no fill_amt here for loop purposes?", "            );", "            currentAmount = fillAmount;", "        }", "        require(currentAmount >= buy_amt_min, \"didnt clear buy_amt_min\");", "", "        // send tokens back to sender if not keeping here", "        if (to != address(this)) {", "            ERC20(route[route.length - 1]).transfer(to, currentAmount);", "        }", "", "        emit LogSwap(", "            pay_amt,", "            route[0],", "            buy_amt_min,", "            route[route.length - 1],", "            keccak256(abi.encodePacked(route[0], route[route.length - 1])),", "            currentAmount,", "            to", "        );", "        return currentAmount;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function sendWithdrawalRequests() external {", "        uint256 contractsLength = contracts.length;", "        for (uint256 i; i < contractsLength; ) {", "            if (", "                contracts[i] != address(0) &&", "                IStaking(contracts[i]).canBatchTransactions()", "            ) {", "                IStaking(contracts[i]).sendWithdrawalRequests();", "            }", "            unchecked {", "                ++i;", "            }", "        }", "    }"], "ner_tags": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function getOwnedTokenIdsOfQuest(", "        string memory questId_,", "        address claimingAddress_", "    ) public view returns (uint[] memory) {", "        uint msgSenderBalance = balanceOf(claimingAddress_);", "        uint[] memory tokenIdsForQuest = new uint[](msgSenderBalance);", "        uint foundTokens = 0;", "", "        for (uint i = 0; i < msgSenderBalance; i++) {", "            uint tokenId = tokenOfOwnerByIndex(claimingAddress_, i);", "            if (keccak256(bytes(questIdForTokenId[tokenId])) == keccak256(bytes(questId_))) {", "                tokenIdsForQuest[i] = tokenId;", "                foundTokens++;", "            }", "        }", "", "        uint[] memory filteredTokens = new uint[](foundTokens);", "        uint filterTokensIndexTracker = 0;", "", "        for (uint i = 0; i < msgSenderBalance; i++) {", "            if (tokenIdsForQuest[i] > 0) {", "                filteredTokens[filterTokensIndexTracker] = tokenIdsForQuest[i];", "                filterTokensIndexTracker++;", "            }", "        }", "        return filteredTokens;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0]}
{"tokens": ["    function getTellorCurrentValue(bytes32 _queryId)", "        external", "        view", "        override", "        returns (", "            bool ifRetrieve,", "            uint256 value,", "            uint256 _timestampRetrieved", "        )", "    {", "        (bytes memory data, uint256 timestamp) = getDataBefore(_queryId, block.timestamp - 20 minutes);", "        uint256 _value = abi.decode(data, (uint256));", "        if (timestamp == 0 || _value == 0) return (false, _value, timestamp);", "        return (true, _value, timestamp);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["    function handleStratOrderAtID(uint256 id) internal {", "        StrategistTrade memory info = strategistTrades[id];", "        address _asset = info.askAsset;", "        address _quote = info.bidAsset;", "", "        address bathAssetAddress = IBathHouse(bathHouse).tokenToBathToken(", "            _asset", "        );", "        address bathQuoteAddress = IBathHouse(bathHouse).tokenToBathToken(", "            _quote", "        );", "        order memory offer1 = getOfferInfo(info.askId); //ask", "        order memory offer2 = getOfferInfo(info.bidId); //bid", "        uint256 askDelta = info.askPayAmt - offer1.pay_amt;", "        uint256 bidDelta = info.bidPayAmt - offer2.pay_amt;", "", "        // if real", "        if (info.askId != 0) {", "            // if delta > 0 - delta is fill => handle any amount of fill here", "            if (askDelta > 0) {", "                logFill(askDelta, info.strategist, info.askAsset);", "                IBathToken(bathAssetAddress).removeFilledTradeAmount(askDelta);", "                // not a full fill", "                if (askDelta != info.askPayAmt) {", "                    IBathToken(bathAssetAddress).cancel(", "                        info.askId,", "                        info.askPayAmt.sub(askDelta)", "                    );", "                }", "            }", "            // otherwise didn't fill so cancel", "            else {", "                IBathToken(bathAssetAddress).cancel(info.askId, info.askPayAmt); // pas amount too", "            }", "        }", "", "        // if real", "        if (info.bidId != 0) {", "            // if delta > 0 - delta is fill => handle any amount of fill here", "            if (bidDelta > 0) {", "                logFill(bidDelta, info.strategist, info.bidAsset);", "                IBathToken(bathQuoteAddress).removeFilledTradeAmount(bidDelta);", "                // not a full fill", "                if (bidDelta != info.bidPayAmt) {", "                    IBathToken(bathQuoteAddress).cancel(", "                        info.bidId,", "                        info.bidPayAmt.sub(bidDelta)", "                    );", "                }", "            }", "            // otherwise didn't fill so cancel", "            else {", "                IBathToken(bathQuoteAddress).cancel(info.bidId, info.bidPayAmt); // pass amount too", "            }", "        }", "", "        // Delete the order from outOffersByStrategist", "        uint256 target = getIndexFromElement(", "            id,", "            outOffersByStrategist[_asset][_quote][info.strategist]", "        );", "        uint256[] storage current = outOffersByStrategist[_asset][_quote][", "            info.strategist", "        ];", "        current[target] = current[current.length - 1];", "        current.pop(); // Assign the last value to the value we want to delete and pop, best way to do this in solc AFAIK", "", "        emit LogScrubbedStratTrade(", "            id,", "            askDelta,", "            _asset,", "            bathAssetAddress,", "            bidDelta,", "            _quote,", "            bathQuoteAddress", "        );", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function stake(", "        uint256 tokenId_", "    ) external override {", "        address ajnaPool = PositionManager(address(positionManager)).poolKey(tokenId_);", "", "        // check that msg.sender is owner of tokenId", "        if (IERC721(address(positionManager)).ownerOf(tokenId_) != msg.sender) revert NotOwnerOfDeposit();", "", "        StakeInfo storage stakeInfo = stakes[tokenId_];", "        stakeInfo.owner    = msg.sender;", "        stakeInfo.ajnaPool = ajnaPool;", "", "        uint256 curBurnEpoch = IPool(ajnaPool).currentBurnEpoch();", "", "        // record the staking epoch", "        stakeInfo.stakingEpoch = uint96(curBurnEpoch);", "", "        // initialize last time interaction at staking epoch", "        stakeInfo.lastClaimedEpoch = uint96(curBurnEpoch);", "", "        uint256[] memory positionIndexes = positionManager.getPositionIndexes(tokenId_);", "", "        for (uint256 i = 0; i < positionIndexes.length; ) {", "", "            uint256 bucketId = positionIndexes[i];", "", "            BucketState storage bucketState = stakeInfo.snapshot[bucketId];", "", "            // record the number of lps in bucket at the time of staking", "            bucketState.lpsAtStakeTime = uint128(positionManager.getLP(", "                tokenId_,", "                bucketId", "            ));", "            // record the bucket exchange rate at the time of staking", "            bucketState.rateAtStakeTime = uint128(IPool(ajnaPool).bucketExchangeRate(bucketId));", "", "            // iterations are bounded by array length (which is itself bounded), preventing overflow / underflow", "            unchecked { ++i; }", "        }", "", "        emit Stake(msg.sender, ajnaPool, tokenId_);", "", "        // transfer LP NFT to this contract", "        IERC721(address(positionManager)).transferFrom(msg.sender, address(this), tokenId_);", "", "        // calculate rewards for updating exchange rates, if any", "        uint256 updateReward = _updateBucketExchangeRates(", "            ajnaPool,", "            positionIndexes", "        );", "", "        // transfer rewards to sender", "        _transferAjnaRewards(updateReward);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function execute(", "        address _target,", "        bytes calldata _data,", "        bytes32[] calldata _proof", "    ) external payable returns (bool success, bytes memory response) {", "        bytes4 selector;", "        assembly {", "            selector := calldataload(_data.offset)", "        }", "", "        // Generate leaf node by hashing module, target and function selector.", "        bytes32 leaf = keccak256(abi.encode(msg.sender, _target, selector));", "        // Check that the caller is either a module with permission to call or the owner.", "        if (!MerkleProof.verify(_proof, merkleRoot, leaf)) {", "            if (msg.sender != owner)", "                revert NotAuthorized(msg.sender, _target, selector);", "        }", "", "        (success, response) = _execute(_target, _data);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function projectCost() public view override returns (uint256 _cost) {", "        // Local instance of taskCount. To save gas.", "        uint256 _length = taskCount;", "", "        // Iterate over all tasks to sum their cost", "        for (uint256 _taskID = 1; _taskID <= _length; _taskID++) {", "            _cost += tasks[_taskID].cost;", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["    function claimAndTrade(", "        address claimToken,", "        address targetToken,", "        address payable swapTarget,", "        address spigot,", "        uint256 unused,", "        bytes calldata zeroExTradeData", "    )", "        external ", "        returns(uint256, uint256)", "    {", "        // can't trade into same token. causes double count for unused tokens", "        if(claimToken == targetToken) { revert BadTradingPair(); }", "", "        // snapshot token balances now to diff after trade executes", "        uint256 oldClaimTokens = LineLib.getBalance(claimToken);", "        uint256 oldTargetTokens = LineLib.getBalance(targetToken);", "        ", "        // @dev claim has to be called after we get balance", "        // reverts if there are no tokens to claim", "        uint256 claimed = ISpigot(spigot).claimEscrow(claimToken);", "", "        trade(", "            claimed + unused,", "            claimToken,", "            swapTarget,", "            zeroExTradeData", "        );", "        ", "        // underflow revert ensures we have more tokens than we started with", "        uint256 tokensBought = LineLib.getBalance(targetToken) - oldTargetTokens;", "", "        if(tokensBought == 0) { revert TradeFailed(); } // ensure tokens bought", "", "        uint256 newClaimTokens = LineLib.getBalance(claimToken);", "", "        // ideally we could use oracle to calculate # of tokens to receive", "        // but sellToken might not have oracle. buyToken must have oracle", "", "        emit TradeSpigotRevenue(", "            claimToken,", "            claimed,", "            targetToken,", "            tokensBought", "        );", "", "        // used reserve revenue to repay debt", "        if(oldClaimTokens > newClaimTokens) {", "          uint256 diff = oldClaimTokens - newClaimTokens;", "", "          // used more tokens than we had in revenue reserves.", "          // prevent borrower from pulling idle lender funds to repay other lenders", "          if(diff > unused) revert UsedExcessTokens(claimToken,  unused); ", "          // reduce reserves by consumed amount", "          else return (", "            tokensBought,", "            unused - diff", "          );", "        } else { unchecked {", "          // excess revenue in trade. store in reserves", "          return (", "            tokensBought,", "            unused + (newClaimTokens - oldClaimTokens)", "          );", "        } }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function autoWithdraw(uint256 _amount) internal {", "        // Reduce amount from totalLent", "        totalLent -= _amount;", "", "        // Transfer amount to builder address", "        currency.safeTransfer(builder, _amount);", "", "        emit AutoWithdrawn(_amount);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _voteSucceeded(uint256 proposalId) internal view override returns (bool){", "        return proposalData[proposalId].supportVotes[1] > proposalData[proposalId].supportVotes[0];", "    }"], "ner_tags": [0, 1, 0]}
{"tokens": ["    function nftAdd(", "        uint256 baseTokenAmount,", "        uint256[] calldata tokenIds,", "        uint256 minLpTokenAmount,", "        bytes32[][] calldata proofs", "    ) public payable returns (uint256 lpTokenAmount) {", "        // wrap the incoming NFTs into fractional tokens", "        uint256 fractionalTokenAmount = wrap(tokenIds, proofs);", "", "        // add liquidity using the fractional tokens and base tokens", "        lpTokenAmount = add(baseTokenAmount, fractionalTokenAmount, minLpTokenAmount);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function execute(address target, bytes calldata data) public payable override returns (bytes memory response) {", "    // Check that the caller is either the owner or an envoy.", "    if (owner != msg.sender) {", "      bytes4 selector;", "      assembly {", "        selector := calldataload(data.offset)", "      }", "      if (!_permissions[msg.sender][target][selector]) {", "        revert CustomErrors.EXECUTION_NOT_AUTHORIZED(owner, msg.sender, target, selector);", "      }", "    }", "", "    // Check that the target is a valid contract.", "    if (target.code.length == 0) {", "      revert CustomErrors.TARGET_INVALID(target);", "    }", "", "    // Save the owner address in memory. This local variable cannot be modified during the DELEGATECALL.", "    address owner_ = owner;", "", "    // Reserve some gas to ensure that the function has enough to finish the execution.", "    uint256 stipend = gasleft() - minGasReserve;", "", "    // Delegate call to the target contract.", "    bool success;", "    (success, response) = target.delegatecall{ gas: stipend }(data);", "", "    // Check that the owner has not been changed.", "    if (owner_ != owner) {", "      revert CustomErrors.OWNER_CHANGED(owner_, owner);", "    }", "", "    // Log the execution.", "    emit Execute(target, data, response);", "", "    // Check if the call was successful or not.", "    if (!success) {", "      // If there is return data, the call reverted with a reason or a custom error.", "      if (response.length > 0) {", "        assembly {", "          let returndata_size := mload(response)", "          revert(add(32, response), returndata_size)", "        }", "      } else {", "        revert CustomErrors.EXECUTION_REVERTED();", "      }", "    }", "  }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _acceptAdmin() external returns (uint256) {", "        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)", "        if (msg.sender != pendingAdmin || msg.sender == address(0)) {", "            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);", "        }", "        // Save current values for inclusion in log", "        address oldAdmin = admin;", "        address oldPendingAdmin = pendingAdmin;", "        // Store admin with value pendingAdmin", "        admin = pendingAdmin;", "        // Clear the pending value", "        pendingAdmin = address(0);", "        emit NewAdmin(oldAdmin, admin);", "        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);", "        return uint256(Error.NO_ERROR);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function deposit(uint256 amount, address to) public virtual returns (uint256 shares) {", "        // Check for rounding error since we round down in previewDeposit.", "        require((shares = previewDeposit(amount)) != 0, \"ZERO_SHARES\");", "", "        // Need to transfer before minting or ERC777s could reenter.", "        asset.safeTransferFrom(msg.sender, address(this), amount);", "", "        _mint(to, shares);", "", "        emit Deposit(msg.sender, to, amount, shares);", "", "        afterDeposit(amount, shares);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function withdraw() hasActiveClaim(_msgSender()) external {", "        // Get the message sender claim - if any", "", "        Claim storage usrClaim = claims[_msgSender()];", "", "        // we can use block.timestamp directly here as reference TS, as the function itself will make sure to cap it to endTimestamp", "        // Conversion of timestamp to uint40 should be safe since 48 bit allows for a lot of years.", "        uint112 allowance = vestedAmount(_msgSender(), uint40(block.timestamp));", "", "        // Make sure we didn't already withdraw more that we're allowed.", "        require(allowance > usrClaim.amountWithdrawn, \"NOTHING_TO_WITHDRAW\");", "", "        // Calculate how much can we withdraw (equivalent to the above inequality)", "        uint112 amountRemaining = allowance - usrClaim.amountWithdrawn;", "", "        // \"Double-entry bookkeeping\"", "        // Carry out the withdrawal by noting the withdrawn amount, and by transferring the tokens.", "        usrClaim.amountWithdrawn += amountRemaining;", "        // Reduce the allocated amount since the following transaction pays out so the \"debt\" gets reduced", "        numTokensReservedForVesting -= amountRemaining;", "        ", "        // After the \"books\" are set, transfer the tokens", "        // Reentrancy note - internal vars have been changed by now", "        // Also following Checks-effects-interactions pattern", "        tokenAddress.safeTransfer(_msgSender(), amountRemaining);", "", "        // Let withdrawal known to everyone.", "        emit Claimed(_msgSender(), amountRemaining);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function addAsset(address _asset, address _assetAggregator) external override {", "        require(registry.hasRole(ASSET_MANAGER_ROLE, msg.sender), \"ChainlinkPriceOracle: FORBIDDEN\");", "        require(_asset != address(0), \"ChainlinkPriceOracle: ZERO\");", "", "        assetInfoOf[_asset] = AssetInfo({", "            aggregator: AggregatorV2V3Interface(_assetAggregator),", "            answerDecimals: AggregatorV2V3Interface(_assetAggregator).decimals(),", "            decimals: IERC20Metadata(_asset).decimals(),", "            lastAssetPerBaseInUQ: 0", "        });", "", "        refreshedAssetPerBaseInUQ(_asset);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["\tfunction recreateMinipool(address nodeID) external whenNotPaused {", "\t\tint256 minipoolIndex = onlyValidMultisig(nodeID);", "\t\trequireValidStateTransition(minipoolIndex, MinipoolStatus.Prelaunch);", "\t\tMinipool memory mp = getMinipool(minipoolIndex);", "\t\t// Compound the avax plus rewards", "\t\t// NOTE Assumes a 1:1 nodeOp:liqStaker funds ratio", "\t\tuint256 compoundedAvaxNodeOpAmt = mp.avaxNodeOpAmt + mp.avaxNodeOpRewardAmt;", "\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxNodeOpAmt\")), compoundedAvaxNodeOpAmt);", "\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxLiquidStakerAmt\")), compoundedAvaxNodeOpAmt);", "", "\t\tStaking staking = Staking(getContractAddress(\"Staking\"));", "\t\t// Only increase AVAX stake by rewards amount we are compounding", "\t\t// since AVAX stake is only decreased by withdrawMinipool()", "\t\tstaking.increaseAVAXStake(mp.owner, mp.avaxNodeOpRewardAmt);", "\t\tstaking.increaseAVAXAssigned(mp.owner, compoundedAvaxNodeOpAmt);", "\t\tstaking.increaseMinipoolCount(mp.owner);", "", "\t\tif (staking.getRewardsStartTime(mp.owner) == 0) {", "\t\t\t// Edge case where calculateAndDistributeRewards has reset their rewards time even though they are still cycling", "\t\t\t// So we re-set it here to their initial start time for this minipool", "\t\t\tstaking.setRewardsStartTime(mp.owner, mp.initialStartTime);", "\t\t}", "", "\t\tProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));", "\t\tuint256 ratio = staking.getCollateralizationRatio(mp.owner);", "\t\tif (ratio < dao.getMinCollateralizationRatio()) {", "\t\t\trevert InsufficientGGPCollateralization();", "\t\t}", "", "\t\tresetMinipoolData(minipoolIndex);", "", "\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".status\")), uint256(MinipoolStatus.Prelaunch));", "", "\t\temit MinipoolStatusChanged(nodeID, MinipoolStatus.Prelaunch);", "\t}"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function upgrade(", "        bytes32 parentNode,", "        string calldata label,", "        address wrappedOwner,", "        address resolver", "    ) public {", "        bytes32 labelhash = keccak256(bytes(label));", "        bytes32 node = _makeNode(parentNode, labelhash);", "        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);", "        upgradeContract.setSubnodeRecord(", "            parentNode,", "            label,", "            wrappedOwner,", "            resolver,", "            0,", "            fuses,", "            expiry", "        );", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function previewRedeem(uint256 shares)", "        public", "        view", "        returns (uint256 assets)", "    {", "        uint256 r = (underlyingBalance().mul(shares)).div(totalSupply);", "        uint256 _fee = r.mul(feeBPS).div(10000);", "        assets = r.sub(_fee);", "    }"], "ner_tags": [1, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _verifyDripsHistory(", "        bytes32 historyHash,", "        DripsHistory[] memory dripsHistory,", "        bytes32 finalHistoryHash", "    ) private pure returns (bytes32[] memory historyHashes) {", "        historyHashes = new bytes32[](dripsHistory.length);", "        for (uint256 i = 0; i < dripsHistory.length; i++) {", "            DripsHistory memory drips = dripsHistory[i];", "            bytes32 dripsHash = drips.dripsHash;", "            if (drips.receivers.length != 0) {", "                require(dripsHash == 0, \"Drips history entry with hash and receivers\");", "                dripsHash = _hashDrips(drips.receivers);", "            }", "            historyHashes[i] = historyHash;", "            historyHash = _hashDripsHistory(historyHash, dripsHash, drips.updateTime, drips.maxEnd);", "        }", "        // slither-disable-next-line incorrect-equality,timestamp", "        require(historyHash == finalHistoryHash, \"Invalid drips history\");", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["    function _submitOrder(", "        address _inputToken,", "        address _outputToken,", "        uint256 _nftId,", "        Order calldata _order,", "        bool _toReserve", "    ) private returns (uint256 amountSpent) {", "        (bool success, uint256[] memory amounts) = callOperator(_order, _inputToken, _outputToken);", "        // We raise the following error in case the call to the operator failed", "        // We do not check the calldata to raise the specific error for now", "        require(success, \"NF: OPERATOR_CALL_FAILED\");", "", "        if (_toReserve) {", "            _transferToReserveAndStore(IERC20(_outputToken), amounts[0], _nftId);", "        }", "        amountSpent = amounts[1];", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function remove(", "        uint256 _cidNFTID,", "        string calldata _subprotocolName,", "        uint256 _key,", "        uint256 _nftIDToRemove,", "        AssociationType _type", "    ) public {", "        SubprotocolRegistry.SubprotocolData memory subprotocolData = subprotocolRegistry.getSubprotocol(", "            _subprotocolName", "        );", "        address subprotocolOwner = subprotocolData.owner;", "        if (subprotocolOwner == address(0)) revert SubprotocolDoesNotExist(_subprotocolName);", "        address cidNFTOwner = ownerOf[_cidNFTID];", "        if (", "            cidNFTOwner != msg.sender &&", "            getApproved[_cidNFTID] != msg.sender &&", "            !isApprovedForAll[cidNFTOwner][msg.sender]", "        ) revert NotAuthorizedForCIDNFT(msg.sender, _cidNFTID, cidNFTOwner);", "", "        ERC721 nftToRemove = ERC721(subprotocolData.nftAddress);", "        if (_type == AssociationType.ORDERED) {", "            // We do not have to check if ordered is supported by the subprotocol. If not, the value will not be unset (which is checked below)", "            uint256 currNFTID = cidData[_cidNFTID][_subprotocolName].ordered[_key];", "            if (currNFTID == 0)", "                // This check is technically not necessary (because the NFT transfer would fail), but we include it to have more meaningful errors", "                revert OrderedValueNotSet(_cidNFTID, _subprotocolName, _key);", "            delete cidData[_cidNFTID][_subprotocolName].ordered[_key];", "            nftToRemove.safeTransferFrom(address(this), msg.sender, currNFTID);", "            emit OrderedDataRemoved(_cidNFTID, _subprotocolName, _key, _nftIDToRemove);", "        } else if (_type == AssociationType.PRIMARY) {", "            uint256 currNFTID = cidData[_cidNFTID][_subprotocolName].primary;", "            if (currNFTID == 0) revert PrimaryValueNotSet(_cidNFTID, _subprotocolName);", "            delete cidData[_cidNFTID][_subprotocolName].primary;", "            nftToRemove.safeTransferFrom(address(this), msg.sender, currNFTID);", "            emit PrimaryDataRemoved(_cidNFTID, _subprotocolName, _nftIDToRemove);", "        } else if (_type == AssociationType.ACTIVE) {", "            IndexedArray storage activeData = cidData[_cidNFTID][_subprotocolName].active;", "            uint256 arrayPosition = activeData.positions[_nftIDToRemove]; // Index + 1, 0 if non-existant", "            if (arrayPosition == 0) revert ActiveArrayDoesNotContainID(_cidNFTID, _subprotocolName, _nftIDToRemove);", "            uint256 arrayLength = activeData.values.length;", "            // Swap only necessary if not already the last element", "            if (arrayPosition != arrayLength) {", "                uint256 befSwapLastNFTID = activeData.values[arrayLength - 1];", "                activeData.values[arrayPosition - 1] = befSwapLastNFTID;", "                activeData.positions[befSwapLastNFTID] = arrayPosition;", "            }", "            activeData.values.pop();", "            activeData.positions[_nftIDToRemove] = 0;", "            nftToRemove.safeTransferFrom(address(this), msg.sender, _nftIDToRemove);", "            emit ActiveDataRemoved(_cidNFTID, _subprotocolName, _nftIDToRemove);", "        }", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function safeTransferFrom(", "        address from,", "        address to,", "        uint256 id,", "        uint256 amount,", "        bytes calldata data", "        ) public virtual override {", "            // Unused.", "            from;", "            to;", "            id;", "            amount;", "            data;", "", "            revert(\"CNFT: Use safeBatchTransferFrom instead\");", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["    function _claim(", "        bytes32 _rewardIdentifier,", "        uint256 _index,", "        address _account,", "        uint256 _amount,", "        bytes32[] calldata _merkleProof", "    ) internal {", "        Reward memory reward = rewards[_rewardIdentifier];", "        require(reward.merkleRoot != 0, \"Distribution not enabled\");", "        require(", "            !isRewardClaimed(_rewardIdentifier, _index),", "            \"Reward already claimed\"", "        );", "", "        // Verify the merkle proof", "        bytes32 node = keccak256(abi.encodePacked(_index, _account, _amount));", "        require(", "            MerkleProof.verify(_merkleProof, reward.merkleRoot, node),", "            \"Invalid proof\"", "        );", "", "        _setClaimed(_rewardIdentifier, _index);", "", "        // Check whether the reward is in the form of native tokens or ERC20", "        // by checking if the token address is set to the bribe vault or not", "        address token = reward.token;", "        if (token != bribeVault) {", "            IERC20(token).safeTransfer(_account, _amount);", "        } else {", "            payable(_account).transfer(_amount);", "        }", "", "        emit RewardClaimed(", "            _rewardIdentifier,", "            token,", "            _account,", "            reward.updateCount,", "            _index,", "            _amount", "        );", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function claimRewards(address _to) external onlyManagerOrOwner returns (bool) {", "    require(_to != address(0), \"AaveV3YS/payee-not-zero-address\");", "", "    address[] memory _assets = new address[](1);", "    _assets[0] = address(aToken);", "", "    (address[] memory _rewardsList, uint256[] memory _claimedAmounts) = rewardsController", "      .claimAllRewards(_assets, _to);", "", "    emit Claimed(msg.sender, _to, _rewardsList, _claimedAmounts);", "    return true;", "  }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": ["    function updateSlate(", "        uint256[] calldata proposalIds_,", "        uint24 distributionId_", "    ) external override returns (bool newTopSlate_) {", "        QuarterlyDistribution storage currentDistribution = _distributions[distributionId_];", "", "        // store number of proposals for reduced gas cost of iterations", "        uint256 numProposalsInSlate = proposalIds_.length;", "", "        // check the each proposal in the slate is valid, and get the sum of the proposals fundingVotesReceived", "        uint256 sum = _validateSlate(distributionId_, currentDistribution.endBlock, currentDistribution.fundsAvailable, proposalIds_, numProposalsInSlate);", "", "        // get pointers for comparing proposal slates", "        bytes32 currentSlateHash = currentDistribution.fundedSlateHash;", "        bytes32 newSlateHash     = keccak256(abi.encode(proposalIds_));", "", "        // check if slate of proposals is better than the existing slate, and is thus the new top slate", "        newTopSlate_ = currentSlateHash == 0 ||", "            (currentSlateHash!= 0 && sum > _sumProposalFundingVotes(_fundedProposalSlates[currentSlateHash]));", "", "        // if slate of proposals is new top slate, update state", "        if (newTopSlate_) {", "            uint256[] storage existingSlate = _fundedProposalSlates[newSlateHash];", "", "            for (uint i = 0; i < numProposalsInSlate; ) {", "", "                // update list of proposals to fund", "                existingSlate.push(proposalIds_[i]);", "", "                unchecked { ++i; }", "            }", "", "            // update hash to point to the new leading slate of proposals", "            currentDistribution.fundedSlateHash = newSlateHash;", "", "            emit FundedSlateUpdated(", "                distributionId_,", "                newSlateHash", "            );", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _unlock(address user) internal {", "        require(user != address(0)); //Never supposed to happen, but security check", "        require(userLocks[user].length > 0, \"hPAL: No Lock\");", "", "        // Get the user current Lock", "        // And calculate the end of the Lock", "        uint256 currentUserLockIndex = userLocks[user].length - 1;", "        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];", "        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;", "", "        require(block.timestamp > userCurrentLockEnd, \"hPAL: Not expired\");", "        require(currentUserLock.amount > 0, \"hPAL: No Lock\");", "", "        // Remove amount from total locked supply", "        currentTotalLocked -= currentUserLock.amount;", "        totalLocks.push(TotalLock(", "            safe224(currentTotalLocked),", "            safe32(block.number)", "        ));", "", "        // Remove the bonus multiplier", "        userCurrentBonusRatio[user] = 0;", "        userBonusRatioDecrease[user] = 0;", "", "        // Set the user Lock as an empty Lock", "        userLocks[user].push(UserLock(", "            safe128(0),", "            safe48(block.timestamp),", "            safe48(0),", "            safe32(block.number)", "        ));", "", "        emit Unlock(user, currentUserLock.amount, currentTotalLocked);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function exchangeRate() public view returns (uint256) {", "        /// @dev if there are no tokens minted, return the initial exchange rate", "        uint256 _totalSupply = totalSupply();", "        if (_totalSupply == 0) {", "            return INITIAL_EXCHANGE_RATE;", "        }", "", "        /// @dev calculate the cash on hand by removing locked funds from the total xETH balance", "        /// @notice this balanceOf call will include any lockedFunds,", "        /// @notice as the locked funds are also in xETH", "        uint256 cashMinusLocked = xETH.balanceOf(address(this)) - lockedFunds;", "", "        /// @dev return the exchange rate by dividing the cash on hand by the total supply", "        return (cashMinusLocked * BASE_UNIT) / _totalSupply;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["    function pendingReward(uint256 _pid, address _user)", "        external", "        view", "        returns (uint256)", "    {", "        PoolInfo storage pool = poolInfo[_pid];", "        UserInfo storage user = userInfo[_pid][_user];", "        uint256 accRewardPerShare = pool.accRewardPerShare;", "        uint256 blockNumber = _blockNumber();", "        //normalizing the pool's `lastRewardBlock` ensures that no rewards are distributed by staking outside of an epoch", "        uint256 lastRewardBlock = _normalizeBlockNumber(pool.lastRewardBlock);", "        uint256 lpSupply = pool.lpToken.balanceOf(address(this));", "        //if blockNumber is greater than the pool's `lastRewardBlock` the pool's `accRewardPerShare` is outdated,", "        //we need to calculate the up to date amount to return an accurate reward value", "        if (blockNumber > lastRewardBlock && lpSupply != 0) {", "            uint256 reward = ((blockNumber - lastRewardBlock) *", "                epoch.rewardPerBlock *", "                1e36 *", "                pool.allocPoint) / totalAllocPoint;", "            accRewardPerShare += reward / lpSupply;", "        }", "        return", "            //rewards that the user had already accumulated but not claimed", "            userRewards[_user] +", "            //subtracting the user's `lastAccRewardPerShare` from the pool's `accRewardPerShare` results in the amount of rewards per share", "            //the pool has accumulated since the user's last claim, multiplying it by the user's shares results in the amount of new rewards claimable", "            //by the user", "            (user.amount * (accRewardPerShare - user.lastAccRewardPerShare)) /", "            1e36;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function redeem(", "    IERC4626 vault,", "    address to,", "    uint256 shares,", "    uint256 minAmountOut", "  ) public payable virtual override returns (uint256 amountOut) {", "", "    ERC20(address(vault)).safeApprove(address(vault), shares);", "    if ((amountOut = vault.redeem(shares, to, msg.sender)) < minAmountOut) {", "      revert MinAmountError();", "    }", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["    constructor(", "        Kernel kernel_,", "        ERC20[2] memory tokens_,", "        uint256[3] memory rangeParams_ // [thresholdFactor, cushionSpread, wallSpread]", "    ) Module(kernel_) {", "        _range = Range({", "            low: Side({", "                active: false,", "                lastActive: uint48(block.timestamp),", "                capacity: 0,", "                threshold: 0,", "                market: type(uint256).max", "            }),", "            high: Side({", "                active: false,", "                lastActive: uint48(block.timestamp),", "                capacity: 0,", "                threshold: 0,", "                market: type(uint256).max", "            }),", "            cushion: Band({low: Line({price: 0}), high: Line({price: 0}), spread: rangeParams_[1]}),", "            wall: Band({low: Line({price: 0}), high: Line({price: 0}), spread: rangeParams_[2]})", "        });", "", "        thresholdFactor = rangeParams_[0];", "        ohm = tokens_[0];", "        reserve = tokens_[1];", "", "        emit SpreadsChanged(rangeParams_[1], rangeParams_[2]);", "        emit ThresholdFactorChanged(rangeParams_[0]);", "    }"], "ner_tags": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function accrueInterest() public virtual override returns (uint256) {", "        /* Remember the initial block number */", "        uint256 currentBlockNumber = _getBlockNumber();", "        uint256 accrualBlockNumberPrior = accrualBlockNumber;", "", "        /* Short-circuit accumulating 0 interest */", "        if (accrualBlockNumberPrior == currentBlockNumber) {", "            return NO_ERROR;", "        }", "", "        /* Read the previous values out of storage */", "        uint256 cashPrior = _getCashPrior();", "        uint256 borrowsPrior = totalBorrows;", "        uint256 reservesPrior = totalReserves;", "        uint256 borrowIndexPrior = borrowIndex;", "", "        /* Calculate the current borrow interest rate */", "        uint256 borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);", "        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");", "", "        /* Calculate the number of blocks elapsed since the last accrual */", "        uint256 blockDelta = currentBlockNumber - accrualBlockNumberPrior;", "", "        /*", "         * Calculate the interest accumulated into borrows and reserves and the new index:", "         *  simpleInterestFactor = borrowRate * blockDelta", "         *  interestAccumulated = simpleInterestFactor * totalBorrows", "         *  totalBorrowsNew = interestAccumulated + totalBorrows", "         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves", "         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex", "         */", "", "        Exp memory simpleInterestFactor = mul_(Exp({ mantissa: borrowRateMantissa }), blockDelta);", "        uint256 interestAccumulated = mul_ScalarTruncate(simpleInterestFactor, borrowsPrior);", "        uint256 totalBorrowsNew = interestAccumulated + borrowsPrior;", "        uint256 totalReservesNew = mul_ScalarTruncateAddUInt(", "            Exp({ mantissa: reserveFactorMantissa }),", "            interestAccumulated,", "            reservesPrior", "        );", "        uint256 borrowIndexNew = mul_ScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);", "", "        /////////////////////////", "        // EFFECTS & INTERACTIONS", "        // (No safe failures beyond this point)", "", "        /* We write the previously calculated values into storage */", "        accrualBlockNumber = currentBlockNumber;", "        borrowIndex = borrowIndexNew;", "        totalBorrows = totalBorrowsNew;", "        totalReserves = totalReservesNew;", "", "        /* We emit an AccrueInterest event */", "        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);", "", "        return NO_ERROR;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _redeemPxGlp(", "        address token,", "        uint256 amount,", "        uint256 minOut,", "        address receiver", "    )", "        internal", "        returns (", "            uint256 redeemed,", "            uint256 postFeeAmount,", "            uint256 feeAmount", "        )", "    {", "        if (amount == 0) revert ZeroAmount();", "        if (minOut == 0) revert ZeroAmount();", "        if (receiver == address(0)) revert ZeroAddress();", "", "        // Calculate the post-fee and fee amounts based on the fee type and total amount", "        (postFeeAmount, feeAmount) = _computeAssetAmounts(", "            Fees.Redemption,", "            amount", "        );", "", "        // Burn pxGLP before redeeming the underlying GLP", "        pxGlp.burn(msg.sender, postFeeAmount);", "", "        // Transfer pxGLP from caller to the fee distribution contract", "        if (feeAmount != 0) {", "            ERC20(pxGlp).safeTransferFrom(", "                msg.sender,", "                address(pirexFees),", "                feeAmount", "            );", "        }", "", "        // Unstake and redeem the underlying GLP for ERC20 tokens", "        redeemed = token == address(0)", "            ? gmxRewardRouterV2.unstakeAndRedeemGlpETH(", "                postFeeAmount,", "                minOut,", "                receiver", "            )", "            : gmxRewardRouterV2.unstakeAndRedeemGlp(", "                token,", "                postFeeAmount,", "                minOut,", "                receiver", "            );", "", "        emit RedeemGlp(", "            msg.sender,", "            receiver,", "            token,", "            amount,", "            minOut,", "            redeemed,", "            postFeeAmount,", "            feeAmount", "        );", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function approveStrategist(address strategist) public onlyAdmin {", "        approvedStrategists[strategist] = true;", "    }"], "ner_tags": [1, 0, 0]}
{"tokens": ["    function characterToUnicodeBytes(", "        uint8 _fontClass,", "        uint16 _characterIndex,", "        uint256 _characterModifier", "    ) internal pure returns (bytes memory) {", "        if (_fontClass == 0) {", "            // Emojis", "            uint256 byteOffset;", "            uint256 numBytes;", "            bool supportsSkinToneModifier;", "            if (_characterIndex < EMOJIS_LE_THREE_BYTES) {", "                numBytes = 3;", "                byteOffset = _characterIndex * 3;", "                supportsSkinToneModifier = _characterIndex >= EMOJIS_LE_THREE_BYTES - EMOJIS_MOD_SKIN_TONE_THREE_BYTES;", "            } else if (_characterIndex < EMOJIS_LE_FOUR_BYTES) {", "                numBytes = 4;", "                byteOffset = EMOJIS_BYTE_OFFSET_FOUR_BYTES + (_characterIndex - EMOJIS_LE_THREE_BYTES) * 4;", "                supportsSkinToneModifier = _characterIndex >= EMOJIS_LE_FOUR_BYTES - EMOJIS_MOD_SKIN_TONE_FOUR_BYTES;", "            } else if (_characterIndex < EMOJIS_LE_SIX_BYTES) {", "                numBytes = 6;", "                byteOffset = EMOJIS_BYTE_OFFSET_SIX_BYTES + (_characterIndex - EMOJIS_LE_FOUR_BYTES) * 6;", "            } else if (_characterIndex < EMOJIS_LE_SEVEN_BYTES) {", "                numBytes = 7;", "                byteOffset = EMOJIS_BYTE_OFFSET_SEVEN_BYTES + (_characterIndex - EMOJIS_LE_SIX_BYTES) * 7;", "            } else if (_characterIndex < EMOJIS_LE_EIGHT_BYTES) {", "                numBytes = 8;", "                byteOffset = EMOJIS_BYTE_OFFSET_EIGHT_BYTES + (_characterIndex - EMOJIS_LE_SEVEN_BYTES) * 8;", "            } else {", "                numBytes = 14;", "                byteOffset = EMOJIS_BYTE_OFFSET_FOURTEEN_BYTES + (_characterIndex - EMOJIS_LE_EIGHT_BYTES) * 14;", "            }", "            bytes memory character = abi.encodePacked(", "                EMOJIS[byteOffset],", "                EMOJIS[byteOffset + 1],", "                EMOJIS[byteOffset + 2]", "            );", "            for (uint256 i = 3; i < numBytes; ++i) {", "                character = abi.encodePacked(character, EMOJIS[byteOffset + i]);", "            }", "            if (_characterModifier != 0) {", "                if (!supportsSkinToneModifier) revert EmojiDoesNotSupportSkinToneModifier(_characterIndex);", "                if (_characterModifier == 1) {", "                    character = abi.encodePacked(character, hex\"F09F8FBB\");", "                } else if (_characterModifier == 2) {", "                    character = abi.encodePacked(character, hex\"F09F8FBC\");", "                } else if (_characterModifier == 3) {", "                    character = abi.encodePacked(character, hex\"F09F8FBD\");", "                } else if (_characterModifier == 4) {", "                    character = abi.encodePacked(character, hex\"F09F8FBE\");", "                } else if (_characterModifier == 5) {", "                    character = abi.encodePacked(character, hex\"F09F8FBF\");", "                } else {", "                    revert InvalidSkinToneModifierProvided(_characterModifier);", "                }", "            }", "            return character;", "        } else if (_fontClass == 1) {", "            // Basic, sans-serif text", "            uint8 asciiStartingIndex = 97; // Starting index for (lowercase) characters", "            if (_characterIndex > 25) {", "                asciiStartingIndex = 22; // Starting index for (lowercase) characters - 25", "            }", "            return abi.encodePacked(bytes1(asciiStartingIndex + uint8(_characterIndex)));", "        } else if (_fontClass == 7) {", "            // Zalgo", "            uint8 asciiStartingIndex = 97;", "            uint256 numAbove = (_characterModifier % 7) + 1;", "            // We do not reuse the same seed for the following generations to avoid any symmetries, e.g. that 2 chars above would also always result in 2 chars below", "            _characterModifier = iteratePRNG(_characterModifier);", "            uint256 numMiddle = _characterModifier % 2;", "            _characterModifier = iteratePRNG(_characterModifier);", "            uint256 numBelow = (_characterModifier % 7) + 1;", "            bytes memory character = abi.encodePacked(bytes1(asciiStartingIndex + uint8(_characterIndex)));", "            for (uint256 i; i < numAbove; ++i) {", "                _characterModifier = iteratePRNG(_characterModifier);", "                uint256 characterIndex = (_characterModifier % ZALGO_NUM_ABOVE) * 2;", "                character = abi.encodePacked(", "                    character,", "                    ZALGO_ABOVE_LETTER[characterIndex],", "                    ZALGO_ABOVE_LETTER[characterIndex + 1]", "                );", "            }", "            for (uint256 i; i < numMiddle; ++i) {", "                _characterModifier = iteratePRNG(_characterModifier);", "                uint256 characterIndex = (_characterModifier % ZALGO_NUM_OVER) * 2;", "                character = abi.encodePacked(", "                    character,", "                    ZALGO_OVER_LETTER[characterIndex],", "                    ZALGO_OVER_LETTER[characterIndex + 1]", "                );", "            }", "            for (uint256 i; i < numBelow; ++i) {", "                _characterModifier = iteratePRNG(_characterModifier);", "                uint256 characterIndex = (_characterModifier % ZALGO_NUM_BELOW) * 2;", "                character = abi.encodePacked(", "                    character,", "                    ZALGO_BELOW_LETTER[characterIndex],", "                    ZALGO_BELOW_LETTER[characterIndex + 1]", "                );", "            }", "            return character;", "        } else {", "            bytes memory startingSequence;", "            if (_fontClass == 2) {", "                // Script", "                // Those 3 characters come from a different UTF-8 block, we therefore hardcode them", "                if (_characterIndex == 4) return hex\"F09D9192\";", "                if (_characterIndex == 6) return hex\"F09D9194\";", "                if (_characterIndex == 14) return hex\"F09D919C\";", "                startingSequence = hex\"F09D92B6\";", "            } else if (_fontClass == 3) {", "                // Script Bold", "                startingSequence = hex\"F09D93AA\";", "            } else if (_fontClass == 4) {", "                // Olde", "                startingSequence = hex\"F09D949E\";", "            } else if (_fontClass == 5) {", "                // Olde Bold", "                startingSequence = hex\"F09D9686\";", "            } else if (_fontClass == 6) {", "                // Squiggle", "                // Font: \u03b1\u10a6\u0188\u0503\u04bd\u03dd\u0260\u050b\u03b9\u029d\u0199\u0285\u0271\u0273\u03c3\u03c1\u03d9\u027e\u0282\u019a\u03c5\u028b\u026fx\u10e7\u0225", "                // Hex encoding: CEB1 E182A6 C688 D483 D2BD CF9D C9A0 D48B CEB9 CA9D C699 CA85 C9B1 C9B3 CF83 CF81 CF99 C9BE CA82 C69A CF85 CA8B C9AF 78 E183A7 C8A5", "                if (_characterIndex == 0) {", "                    return abi.encodePacked(FONT_SQUIGGLE[0], FONT_SQUIGGLE[1]);", "                } else if (_characterIndex == 1) {", "                    return abi.encodePacked(FONT_SQUIGGLE[2], FONT_SQUIGGLE[3], FONT_SQUIGGLE[4]);", "                } else if (_characterIndex < 23 || _characterIndex == 25) {", "                    uint256 offset = (_characterIndex - 2) * 2;", "                    return abi.encodePacked(FONT_SQUIGGLE[5 + offset], FONT_SQUIGGLE[6 + offset]);", "                } else if (_characterIndex == 23) {", "                    return abi.encodePacked(FONT_SQUIGGLE[47]);", "                } else if (_characterIndex == 24) {", "                    return abi.encodePacked(FONT_SQUIGGLE[48], FONT_SQUIGGLE[49], FONT_SQUIGGLE[50]);", "                }", "            } else if (_fontClass == 8) {", "                // Blocks", "                startingSequence = hex\"F09F84B0\";", "            } else if (_fontClass == 9) {", "                // Blocks inverted", "                startingSequence = hex\"F09F85B0\";", "            }", "            return _getUtfSequence(startingSequence, uint8(_characterIndex));", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _checkRedeemAllowed(", "        address vToken,", "        address redeemer,", "        uint256 redeemTokens", "    ) internal view {", "        if (!markets[vToken].isListed) {", "            revert MarketNotListed(address(vToken));", "        }", "", "        /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */", "        if (!markets[vToken].accountMembership[redeemer]) {", "            return;", "        }", "", "        /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */", "        AccountLiquiditySnapshot memory snapshot = _getHypotheticalLiquiditySnapshot(", "            redeemer,", "            VToken(vToken),", "            redeemTokens,", "            0,", "            _getCollateralFactor", "        );", "        if (snapshot.shortfall > 0) {", "            revert InsufficientLiquidity();", "        }", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function burnFees() external override {", "        IBkdLocker bkdLocker = IBkdLocker(addressProvider.getBKDLocker());", "        IFeeBurner feeBurner = addressProvider.getFeeBurner();", "        address targetLpToken = bkdLocker.rewardToken();", "        address[] memory pools = addressProvider.allPools();", "        uint256 ethBalance = address(this).balance;", "        address[] memory tokens = new address[](pools.length);", "        for (uint256 i; i < pools.length; i = i.uncheckedInc()) {", "            ILiquidityPool pool = ILiquidityPool(pools[i]);", "            address underlying = pool.getUnderlying();", "            if (underlying != address(0)) {", "                _approve(underlying, address(feeBurner));", "            }", "            tokens[i] = underlying;", "        }", "        feeBurner.burnToTarget{value: ethBalance}(tokens, targetLpToken);", "        uint256 burnedAmount = IERC20(targetLpToken).balanceOf(address(this));", "        IERC20(targetLpToken).safeApprove(address(bkdLocker), burnedAmount);", "        bkdLocker.depositFees(burnedAmount);", "        emit Burned(targetLpToken, burnedAmount);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function liquidate(uint256 _nftIndex)", "        external", "        onlyRole(LIQUIDATOR_ROLE)", "        validNFTIndex(_nftIndex)", "        nonReentrant", "    {", "        accrue();", "", "        address posOwner = positionOwner[_nftIndex];", "        require(posOwner != address(0), \"position_not_exist\");", "", "        Position storage position = positions[_nftIndex];", "        require(position.liquidatedAt == 0, \"liquidated\");", "", "        uint256 debtAmount = _getDebtAmount(_nftIndex);", "        require(", "            debtAmount >= _getLiquidationLimit(_nftIndex),", "            \"position_not_liquidatable\"", "        );", "", "        // burn all payment", "        stablecoin.burnFrom(msg.sender, debtAmount);", "", "        // update debt portion", "        totalDebtPortion -= position.debtPortion;", "        totalDebtAmount -= debtAmount;", "        position.debtPortion = 0;", "", "        bool insured = position.borrowType == BorrowType.USE_INSURANCE;", "        if (insured) {", "            position.debtAmountForRepurchase = debtAmount;", "            position.liquidatedAt = block.timestamp;", "            position.liquidator = msg.sender;", "        } else {", "            // transfer nft to liquidator", "            positionOwner[_nftIndex] = address(0);", "            delete positions[_nftIndex];", "            positionIndexes.remove(_nftIndex);", "            nftContract.safeTransferFrom(address(this), msg.sender, _nftIndex);", "        }", "", "        emit Liquidated(msg.sender, posOwner, _nftIndex, insured);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function exit() external {", "        withdraw(_balances[msg.sender]);", "        getReward();", "    }"], "ner_tags": [1, 0, 0, 0]}
{"tokens": ["    function executeSetMinter() external onlyOwner {", "        if (minter == address(0)) {", "            minter = pendingMinter;", "        } else {", "            require(minterEnableDate <= block.timestamp, 'GolomToken: wait for timelock');", "            minter = pendingMinter;", "        }", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function swap(bool _swapForY, address _to)", "        external", "        override", "        nonReentrant", "        returns (uint256 amountXOut, uint256 amountYOut)", "    {", "        PairInformation memory _pair = _pairInformation;", "", "        uint256 _amountIn = _swapForY", "            ? tokenX.received(_pair.reserveX, _pair.feesX.total)", "            : tokenY.received(_pair.reserveY, _pair.feesY.total);", "", "        if (_amountIn == 0) revert LBPair__InsufficientAmounts();", "", "        FeeHelper.FeeParameters memory _fp = _feeParameters;", "        _fp.updateVariableFeeParameters(_pair.activeId);", "        uint256 _startId = _pair.activeId;", "", "        uint256 _amountOut;", "        // Performs the actual swap, bin per bin", "        // It uses the findFirstBin function to make sure the bin we're currently looking at", "        // has liquidity in it.", "        while (true) {", "            Bin memory _bin = _bins[_pair.activeId];", "            if ((!_swapForY && _bin.reserveX != 0) || (_swapForY && _bin.reserveY != 0)) {", "                (uint256 _amountInToBin, uint256 _amountOutOfBin, FeeHelper.FeesDistribution memory _fees) = _bin", "                    .getAmounts(_fp, _pair.activeId, _swapForY, _amountIn);", "", "                _bin.updateFees(_swapForY ? _pair.feesX : _pair.feesY, _fees, _swapForY, totalSupply(_pair.activeId));", "", "                _bin.updateReserves(_pair, _swapForY, _amountInToBin.safe112(), _amountOutOfBin.safe112());", "", "                _amountIn -= _amountInToBin + _fees.total;", "                _amountOut += _amountOutOfBin;", "", "                _bins[_pair.activeId] = _bin;", "", "                if (_swapForY) {", "                    emit Swap(", "                        msg.sender,", "                        _to,", "                        _pair.activeId,", "                        _amountInToBin,", "                        0,", "                        0,", "                        _amountOutOfBin,", "                        _fp.volatilityAccumulated,", "                        _fees.total,", "                        0", "                    );", "                } else {", "                    emit Swap(", "                        msg.sender,", "                        _to,", "                        _pair.activeId,", "                        0,", "                        _amountInToBin,", "                        _amountOutOfBin,", "                        0,", "                        _fp.volatilityAccumulated,", "                        0,", "                        _fees.total", "                    );", "                }", "            }", "", "            if (_amountIn != 0) {", "                _pair.activeId = _tree.findFirstBin(_pair.activeId, _swapForY);", "            } else {", "                break;", "            }", "        }", "", "        if (_amountOut == 0) revert LBPair__BrokenSwapSafetyCheck(); // Safety check", "", "        // We use oracleSize so it can start filling empty slot that were added recently", "        uint256 _updatedOracleId = _oracle.update(", "            _pair.oracleSize,", "            _pair.oracleSampleLifetime,", "            _pair.oracleLastTimestamp,", "            _pair.oracleId,", "            _pair.activeId,", "            _fp.volatilityAccumulated,", "            _startId.absSub(_pair.activeId)", "        );", "", "        // We update the oracleId and lastTimestamp if the sample write on another slot", "        if (_updatedOracleId != _pair.oracleId || _pair.oracleLastTimestamp == 0) {", "            // Can't overflow as the updatedOracleId < oracleSize", "            _pair.oracleId = uint16(_updatedOracleId);", "            _pair.oracleLastTimestamp = block.timestamp.safe40();", "", "            // We increase the activeSize if the updated sample is written in a new slot", "            // Can't overflow as _updatedOracleId < maxSize = 2**16-1", "            unchecked {", "                if (_updatedOracleId == _pair.oracleActiveSize) ++_pair.oracleActiveSize;", "            }", "        }", "", "        _feeParameters = _fp;", "        _pairInformation = _pair;", "", "        if (_swapForY) {", "            amountYOut = _amountOut;", "            tokenY.safeTransfer(_to, _amountOut);", "        } else {", "            amountXOut = _amountOut;", "            tokenX.safeTransfer(_to, _amountOut);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _depositGlp(", "        address token,", "        uint256 tokenAmount,", "        uint256 minUsdg,", "        uint256 minGlp,", "        address receiver", "    )", "        internal", "        returns (", "            uint256 deposited,", "            uint256 postFeeAmount,", "            uint256 feeAmount", "        )", "    {", "        if (tokenAmount == 0) revert ZeroAmount();", "        if (minUsdg == 0) revert ZeroAmount();", "        if (minGlp == 0) revert ZeroAmount();", "        if (receiver == address(0)) revert ZeroAddress();", "", "        if (token == address(0)) {", "            // Mint and stake GLP using ETH", "            deposited = gmxRewardRouterV2.mintAndStakeGlpETH{", "                value: tokenAmount", "            }(minUsdg, minGlp);", "        } else {", "            ERC20 t = ERC20(token);", "", "            // Intake user ERC20 tokens and approve GLP Manager contract for amount", "            t.safeTransferFrom(msg.sender, address(this), tokenAmount);", "            t.safeApprove(glpManager, tokenAmount);", "", "            // Mint and stake GLP using ERC20 tokens", "            deposited = gmxRewardRouterV2.mintAndStakeGlp(", "                token,", "                tokenAmount,", "                minUsdg,", "                minGlp", "            );", "        }", "", "        // Calculate the post-fee and fee amounts based on the fee type and total deposited", "        (postFeeAmount, feeAmount) = _computeAssetAmounts(", "            Fees.Deposit,", "            deposited", "        );", "", "        // Mint pxGLP for the receiver", "        pxGlp.mint(receiver, postFeeAmount);", "", "        // Mint pxGLP for fee distribution contract", "        if (feeAmount != 0) {", "            pxGlp.mint(address(pirexFees), feeAmount);", "        }", "", "        emit DepositGlp(", "            msg.sender,", "            receiver,", "            token,", "            tokenAmount,", "            minUsdg,", "            minGlp,", "            deposited,", "            postFeeAmount,", "            feeAmount", "        );", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _activatePolicy(Policy policy_) internal {", "        if (policy_.isActive()) revert Kernel_PolicyAlreadyActivated(address(policy_));", "", "        // Add policy to list of active policies", "        activePolicies.push(policy_);", "        getPolicyIndex[policy_] = activePolicies.length - 1;", "", "        // Record module dependencies", "        Keycode[] memory dependencies = policy_.configureDependencies();", "        uint256 depLength = dependencies.length;", "", "        for (uint256 i; i < depLength; ) {", "            Keycode keycode = dependencies[i];", "", "            moduleDependents[keycode].push(policy_);", "            getDependentIndex[keycode][policy_] = moduleDependents[keycode].length - 1;", "", "            unchecked {", "                ++i;", "            }", "        }", "", "        // Grant permissions for policy to access restricted module functions", "        Permissions[] memory requests = policy_.requestPermissions();", "        _setPolicyPermissions(policy_, requests, true);", "", "        // Set policy status to active", "        policy_.setActiveStatus(true);", "    }"], "ner_tags": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function _sendToDistributor(uint256 amount, uint256 epoch) internal {", "    if (amount == 0) {", "      return;", "    }", "", "    (", "      uint256[] memory poolIds,", "      uint256[] memory allocations,", "      address[] memory distributors", "    ) = bonding.poolAllocations();", "", "    uint256 length = poolIds.length;", "    uint256 balance = collateralToken.balanceOf(address(this));", "    uint256 rewarded;", "", "    for (uint256 i; i < length; ++i) {", "      uint256 share = (amount * allocations[i]) / 1e18;", "", "      if (share == 0) {", "        continue;", "      }", "", "      if (share > balance) {", "        share = balance;", "      }", "", "      collateralToken.safeTransfer(distributors[i], share);", "      IDistributor(distributors[i]).declareReward(share);", "      balance -= share;", "      rewarded += share;", "", "      if (balance == 0) {", "        break;", "      }", "    }", "", "    state[epoch].rewarded = state[epoch].rewarded + rewarded;", "    state[epoch + 1].cumulativeCashflowApr =", "      state[epoch].cumulativeCashflowApr +", "      epochCashflowAPR(epoch);", "    state[epoch + 1].cumulativeApr =", "      state[epoch].cumulativeApr +", "      epochAPR(epoch);", "    state[epoch].bondedValue = bonding.averageBondedValue(epoch);", "  }"], "ner_tags": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function liquidate(ILienToken.Stack[] memory stack, uint8 position)", "    public", "    returns (OrderParameters memory listedOrder)", "  {", "    if (!canLiquidate(stack[position])) {", "      revert InvalidLienState(LienState.HEALTHY);", "    }", "", "    RouterStorage storage s = _loadRouterSlot();", "    uint256 auctionWindowMax = s.auctionWindow + s.auctionWindowBuffer;", "", "    s.LIEN_TOKEN.stopLiens(", "      stack[position].lien.collateralId,", "      auctionWindowMax,", "      stack,", "      msg.sender", "    );", "    emit Liquidation(stack[position].lien.collateralId, position);", "    listedOrder = s.COLLATERAL_TOKEN.auctionVault(", "      ICollateralToken.AuctionVaultParams({", "        settlementToken: stack[position].lien.token,", "        collateralId: stack[position].lien.collateralId,", "        maxDuration: auctionWindowMax,", "        startingPrice: stack[0].lien.details.liquidationInitialAsk,", "        endingPrice: 1_000 wei", "      })", "    );", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": ["    function _lockCrv() internal {", "        if (prepareWithdrawal) return;", "", "        uint256 currentBalance = IERC20(CRV).balanceOf(address(this));", "        if (currentBalance != 0) {", "            // Checks if we can get a better rate on Curve Pool", "            uint256 amountOut = ICurveSwap(CVX_CRV_CRV_CURVE_POOL).get_dy(", "                _CRV_INDEX,", "                _CVX_CRV_INDEX,", "                currentBalance", "            );", "            if (amountOut > currentBalance) {", "                ICurveSwap(CVX_CRV_CRV_CURVE_POOL).exchange(", "                    _CRV_INDEX,", "                    _CVX_CRV_INDEX,", "                    currentBalance,", "                    0", "                );", "            } else {", "                // Swap CRV for cxvCRV and stake", "                ICrvDepositor(CRV_DEPOSITOR).deposit(currentBalance, false, address(0));", "            }", "            IRewardStaking(CVX_CRV_STAKING).stakeAll();", "            return;", "        }", "", "        if (IERC20(CVX_CRV).balanceOf(address(this)) > 0)", "            IRewardStaking(CVX_CRV_STAKING).stakeAll();", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function buy(uint256 _minAmtOut, address _to) external override payable notBoughtOut lock whenNotPaused returns(uint256 _purchaseReturn) {", "        //Make update on the first tx of the block", "        if (status == Status.buyout) {", "            uint32 _blockTimestamp = uint32(block.timestamp % 2**32);", "            if (_blockTimestamp != lastBlockTimeStamp) {", "                _updateTWAV(getCurrentValuation(), _blockTimestamp);   ", "                _rejectBuyout();", "            }", "        }", "        uint256 _initialTokenSupply = initialTokenSupply;", "        uint256 _totalSupply = totalSupply();", "        if (_totalSupply >= _initialTokenSupply) {", "            _purchaseReturn = _buyPrimaryCurve(msg.value, _totalSupply);", "        } else {", "            uint256 _lowerCurveDiff = getMaxSecondaryCurveBalance() - secondaryReserveBalance;", "            if (_lowerCurveDiff >= msg.value) {", "                _purchaseReturn = _buySecondaryCurve(msg.value, _totalSupply);", "            } else {", "                //Gas Optimization", "                _purchaseReturn = _initialTokenSupply - _totalSupply;", "                secondaryReserveBalance += _lowerCurveDiff;", "                // _purchaseReturn = _buySecondaryCurve(_to, _lowerCurveDiff);", "                _purchaseReturn += _buyPrimaryCurve(msg.value - _lowerCurveDiff, _totalSupply + _purchaseReturn);", "            } ", "        }", "        require(_minAmtOut <= _purchaseReturn, \"NibblVault: Return too low\");", "        _mint(_to, _purchaseReturn);", "        emit Buy(msg.sender, _purchaseReturn, msg.value);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _encodeOrderHashes(", "        MemoryPointer srcLength,", "        MemoryPointer dstLength", "    ) internal view returns (uint256 size) {", "        // Read length of the array from source and write to destination.", "        uint256 length = srcLength.readUint256();", "        dstLength.write(length);", "", "        unchecked {", "            // Determine head & tail size as one word per element in the array.", "            uint256 headAndTailSize = length * OneWord;", "", "            // Copy the tail starting from the next element of the source to the", "            // next element of the destination.", "            srcLength.next().offset(headAndTailSize).copy(", "                dstLength.next(),", "                headAndTailSize", "            );", "", "            // Set size to the length of the tail plus one word for length.", "            size = headAndTailSize + OneWord;", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function _depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount, bool _enableTransferHook) internal {", "        require(_amount >= MIN_STAKING_AMOUNT, \"Min amount not reached\");", "        require(_blsPublicKeyOfKnot.length == 48, \"Invalid BLS public key\");", "", "        // LP token issued for the KNOT", "        // will be zero for a new KNOT because the mapping doesn't exist", "        LPToken lpToken = lpTokenForKnot[_blsPublicKeyOfKnot];", "        if(address(lpToken) != address(0)) {", "            // KNOT and it's LP token is already registered", "            // mint the respective LP tokens for the user", "", "            // total supply after minting the LP token must not exceed maximum staking amount per validator", "            require(lpToken.totalSupply() + _amount <= maxStakingAmountPerValidator, \"Amount exceeds the staking limit for the validator\");", "", "            // mint LP tokens for the depoistor with 1:1 ratio of LP tokens and ETH supplied", "            lpToken.mint(msg.sender, _amount);", "            emit LPTokenMinted(_blsPublicKeyOfKnot, address(lpToken), msg.sender, _amount);", "        }", "        else {", "            // check that amount doesn't exceed max staking amount per validator", "            require(_amount <= maxStakingAmountPerValidator, \"Amount exceeds the staking limit for the validator\");", "            ", "            // mint new LP tokens for the new KNOT", "            // add the KNOT in the mapping", "            string memory tokenNumber = Strings.toString(numberOfLPTokensIssued);", "            string memory tokenName = string(abi.encodePacked(baseLPTokenName, tokenNumber));", "            string memory tokenSymbol = string(abi.encodePacked(baseLPTokenSymbol, tokenNumber));", "", "            // deploy new LP token and optionally enable transfer notifications", "            LPToken newLPToken = _enableTransferHook ?", "                             LPToken(lpTokenFactory.deployLPToken(address(this), address(this), tokenSymbol, tokenName)) :", "                             LPToken(lpTokenFactory.deployLPToken(address(this), address(0), tokenSymbol, tokenName));", "", "            // increase the count of LP tokens", "            numberOfLPTokensIssued++;", "", "            // register the BLS Public Key with the LP token", "            lpTokenForKnot[_blsPublicKeyOfKnot] = newLPToken;", "            KnotAssociatedWithLPToken[newLPToken] = _blsPublicKeyOfKnot;", "", "            // mint LP tokens for the depoistor with 1:1 ratio of LP tokens and ETH supplied", "            newLPToken.mint(msg.sender, _amount);", "            emit NewLPTokenIssued(_blsPublicKeyOfKnot, address(newLPToken), msg.sender, _amount);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function settleFunding() override external whenNotPaused {", "        for (uint i = 0; i < amms.length; i++) {", "            amms[i].settleFunding();", "        }", "    }"], "ner_tags": [1, 0, 0, 0, 0]}
{"tokens": ["  function bondUtilityToken(", "    address operator,", "    uint256 amount,", "    uint256 pod", "  ) external {", "    /**", "     * @dev an operator can only bond to one pod at any give time per network", "     */", "    require(_bondedOperators[operator] == 0 && _bondedAmounts[operator] == 0, \"HOLOGRAPH: operator is bonded\");", "    unchecked {", "      /**", "       * @dev get the current bonding minimum for selected pod", "       */", "      uint256 current = _getCurrentBondAmount(pod - 1);", "      require(current <= amount, \"HOLOGRAPH: bond amount too small\");", "      /**", "       * @dev check if selected pod is greater than currently existing pods", "       */", "      if (_operatorPods.length < pod) {", "        /**", "         * @dev activate pod(s) up until the selected pod", "         */", "        for (uint256 i = _operatorPods.length; i <= pod; i++) {", "          /**", "           * @dev add zero address into pod to mitigate empty pod issues", "           */", "          _operatorPods.push([address(0)]);", "        }", "      }", "      /**", "       * @dev prevent bonding to a pod with more than uint16 max value", "       */", "      require(_operatorPods[pod - 1].length < type(uint16).max, \"HOLOGRAPH: too many operators\");", "      _operatorPods[pod - 1].push(operator);", "      _operatorPodIndex[operator] = _operatorPods[pod - 1].length - 1;", "      _bondedOperators[operator] = pod;", "      _bondedAmounts[operator] = amount;", "      /**", "       * @dev transfer tokens last, to prevent reentrancy attacks", "       */", "      require(_utilityToken().transferFrom(msg.sender, address(this), amount), \"HOLOGRAPH: token transfer failed\");", "    }", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function bid(uint256 _challengeNumber, uint256 _bidAmountZCHF, uint256 expectedSize) external {", "        Challenge storage challenge = challenges[_challengeNumber];", "        if (block.timestamp >= challenge.end) revert TooLate();", "        if (expectedSize != challenge.size) revert UnexpectedSize();", "        if (challenge.bid > 0) {", "            zchf.transfer(challenge.bidder, challenge.bid); // return old bid", "        }", "        emit NewBid(_challengeNumber, _bidAmountZCHF, msg.sender);", "        // ask position if the bid was high enough to avert the challenge", "        if (challenge.position.tryAvertChallenge(challenge.size, _bidAmountZCHF)) {", "            // bid was high enough, let bidder buy collateral from challenger", "            zchf.transferFrom(msg.sender, challenge.challenger, _bidAmountZCHF);", "            challenge.position.collateral().transfer(msg.sender, challenge.size);", "            emit ChallengeAverted(address(challenge.position), _challengeNumber);", "            delete challenges[_challengeNumber];", "        } else {", "            // challenge is not averted, update bid", "            if (_bidAmountZCHF < minBid(challenge)) revert BidTooLow(_bidAmountZCHF, minBid(challenge));", "            uint256 earliestEnd = block.timestamp + 30 minutes;", "            if (earliestEnd >= challenge.end) {", "                // bump remaining time like ebay does when last minute bids come in", "                // An attacker trying to postpone the challenge forever must increase the bid by 0.5%", "                // every 30 minutes, or double it every three days, making the attack hard to sustain", "                // for a prolonged period of time.", "                challenge.end = earliestEnd;", "            }", "            zchf.transferFrom(msg.sender, address(this), _bidAmountZCHF);", "            challenge.bid = _bidAmountZCHF;", "            challenge.bidder = msg.sender;", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function _initialize(CrowdfundOptions memory opts)", "        internal", "    {", "        CrowdfundNFT._initialize(opts.name, opts.symbol);", "        // Check that BPS values do not exceed the max.", "        if (opts.governanceOpts.feeBps > 1e4) {", "            revert InvalidBpsError(opts.governanceOpts.feeBps);", "        }", "        if (opts.governanceOpts.passThresholdBps > 1e4) {", "            revert InvalidBpsError(opts.governanceOpts.passThresholdBps);", "        }", "        if (opts.splitBps > 1e4) {", "            revert InvalidBpsError(opts.splitBps);", "        }", "        governanceOptsHash = _hashFixedGovernanceOpts(opts.governanceOpts);", "        splitRecipient = opts.splitRecipient;", "        splitBps = opts.splitBps;", "        // If the deployer passed in some ETH during deployment, credit them", "        // for the initial contribution.", "        uint96 initialBalance = address(this).balance.safeCastUint256ToUint96();", "        if (initialBalance > 0) {", "            // If this contract has ETH, either passed in during deployment or", "            // pre-existing, credit it to the `initialContributor`.", "            _contribute(opts.initialContributor, initialBalance, opts.initialDelegate, 0, \"\");", "        }", "        // Set up gatekeeper after initial contribution (initial always gets in).", "        gateKeeper = opts.gateKeeper;", "        gateKeeperId = opts.gateKeeperId;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function setPlatformFee(uint256 _platformFee) external override onlyOwner {", "        platformFee = _platformFee;", "        emit NewRoyaltyVaultPlatformFee(_platformFee);", "    }"], "ner_tags": [1, 0, 0, 0]}
{"tokens": ["  function addNotional(address o, uint256 a) external authorized(admin) returns (bool) {", "    uint256 exchangeRate = Compounding.exchangeRate(protocol, cTokenAddr);", "", "    Vault memory vlt = vaults[o];", "", "    if (vlt.notional > 0) {", "      uint256 yield;", "", "      // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate", "      // otherwise, calculate marginal exchange rate between current and previous exchange rate.", "      if (maturityRate > 0) { // Calculate marginal interest", "        yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;", "      } else {", "        yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;", "      }", "", "      uint256 interest = (yield * vlt.notional) / 1e26;", "      // add interest and amount to position, reset cToken exchange rate", "      vlt.redeemable += interest;", "      vlt.notional += a;", "    } else {", "      vlt.notional = a;", "    }", "", "    vlt.exchangeRate = exchangeRate;", "    vaults[o] = vlt;", "", "    return true;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function checkSignatureValidity(", "        address _address,", "        bytes32 _hash,", "        bytes memory _signature,", "        uint256 _signatureIndex", "    ) internal virtual {", "        // Decode signer", "        address _recoveredSignature = SignatureDecoder.recoverKey(", "            _hash,", "            _signature,", "            _signatureIndex", "        );", "", "        // Revert if decoded signer does not match expected address", "        // Or if hash is not approved by the expected address.", "        require(", "            _recoveredSignature == _address || approvedHashes[_address][_hash],", "            \"Community::invalid signature\"", "        );", "", "        // Delete from approvedHash. So that signature cannot be reused.", "        delete approvedHashes[_address][_hash];", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function addCredit(", "        uint128 drate,", "        uint128 frate,", "        uint256 amount,", "        address token,", "        address lender", "    )", "        external", "        payable", "        override", "        whileActive", "        mutualConsent(lender, borrower)", "        returns (bytes32)", "    {", "        LineLib.receiveTokenOrETH(token, lender, amount);", "", "        bytes32 id = _createCredit(lender, token, amount);", "", "        require(interestRate.setRate(id, drate, frate));", "        ", "        return id;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function executeProposal(ExecuteProposalParams memory params)", "        external", "        onlyDelegateCall", "        returns (bytes memory nextProgressData)", "    {", "        // Must have a valid proposal ID.", "        if (params.proposalId == 0) {", "            revert ZeroProposalIdError();", "        }", "        Storage storage stor = _getStorage();", "        uint256 currentInProgressProposalId = stor.currentInProgressProposalId;", "        if (currentInProgressProposalId == 0) {", "            // No proposal is currently in progress.", "            // Mark this proposal as the one in progress.", "            stor.currentInProgressProposalId = params.proposalId;", "        } else if (currentInProgressProposalId != params.proposalId) {", "            // Only one proposal can be in progress at a time.", "            revert ProposalExecutionBlockedError(", "                params.proposalId,", "                currentInProgressProposalId", "            );", "        }", "        {", "            bytes32 nextProgressDataHash = stor.nextProgressDataHash;", "            if (nextProgressDataHash == 0) { // Expecting no progress data.", "                // This is the state if there is no current `InProgress` proposal.", "                assert(currentInProgressProposalId == 0);", "                if (params.progressData.length != 0) {", "                    revert ProposalProgressDataInvalidError(", "                        keccak256(params.progressData),", "                        nextProgressDataHash", "                    );", "                }", "            } else { // Expecting progress data.", "                bytes32 progressDataHash = keccak256(params.progressData);", "                // Progress data must match the one stored.", "                if (nextProgressDataHash != progressDataHash) {", "                    revert ProposalProgressDataInvalidError(", "                        progressDataHash,", "                        nextProgressDataHash", "                    );", "                }", "            }", "            // Temporarily set the expected next progress data hash to an", "            // unachievable constant to act as a reentrancy guard.", "            stor.nextProgressDataHash = bytes32(type(uint256).max);", "        }", "", "        // Note that we do not enforce that the proposal has not been executed", "        // (and completed) before in this contract. That is enforced by PartyGovernance.", "", "        // Execute the proposal.", "        ProposalType pt;", "        (pt, params.proposalData) = _extractProposalType(params.proposalData);", "        nextProgressData = _execute(pt, params);", "", "        // If progress data is empty, the proposal is complete.", "        if (nextProgressData.length == 0) {", "            stor.currentInProgressProposalId = 0;", "            stor.nextProgressDataHash = 0;", "        } else {", "            // Remember the next progress data.", "            stor.nextProgressDataHash = keccak256(nextProgressData);", "        }", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function readOracle() public view override returns (Decimal.D256 memory) {", "        (Decimal.D256 memory _peg, bool valid) = oracle.read();", "        if (!valid && address(backupOracle) != address(0)) {", "            (_peg, valid) = backupOracle.read();", "        }", "        require(valid, \"OracleRef: oracle invalid\");", "", "        // Scale the oracle price by token decimals delta if necessary", "        uint256 scalingFactor;", "        if (decimalsNormalizer < 0) {", "            scalingFactor = 10**(-1 * decimalsNormalizer).toUint256();", "            _peg = _peg.div(scalingFactor);", "        } else {", "            scalingFactor = 10**decimalsNormalizer.toUint256();", "            _peg = _peg.mul(scalingFactor);", "        }", "", "        // Invert the oracle price if necessary", "        if (doInvert) {", "            _peg = invert(_peg);", "        }", "        return _peg;", "    }"], "ner_tags": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function refreshedAssetPerBaseInUQ(address _asset) public override returns (uint) {", "        AssetInfo storage assetInfo = assetInfoOf[_asset];", "", "        (, int basePrice, , , ) = baseAggregator.latestRoundData();", "        (, int quotePrice, , , ) = assetInfo.aggregator.latestRoundData();", "", "        require(basePrice > 0 && quotePrice > 0, \"ChainlinkPriceOracle: NEGATIVE\");", "", "        uint assetPerBaseInUQ = ((uint(basePrice) * 10**assetInfo.decimals).mulDiv(", "            FixedPoint112.Q112,", "            (uint(quotePrice) * 10**baseDecimals)", "        ) * 10**assetInfo.answerDecimals) / 10**baseAnswerDecimals;", "        assetInfo.lastAssetPerBaseInUQ = assetPerBaseInUQ;", "        return assetPerBaseInUQ;", "    }"], "ner_tags": [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _mint(address _address, uint256 _amount) internal override {", "        require(_address != address(0), \"Mint to the zero address\");", "", "        uint256 creditAmount = _amount * rebasingCreditsPerToken;", "        creditBalances[_address] = creditBalances[_address] + creditAmount;", "        rebasingCredits = rebasingCredits + creditAmount;", "", "        _totalSupply = _totalSupply + _amount;", "", "        require(_totalSupply < MAX_SUPPLY, \"Max supply\");", "        emit Transfer(address(0), _address, _amount);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["    function getUserLock(address user) external view returns(UserLock memory) {", "        //If the contract is blocked (emergency mode)", "        //Or if the user does not have a Lock yet", "        //Return an empty lock", "        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);", "        uint256 lastUserLockIndex = userLocks[user].length - 1;", "        return userLocks[user][lastUserLockIndex];", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function change(Change[] calldata changes, uint256 deadline) public payable {", "        // check deadline has not passed (if any)", "        if (block.timestamp > deadline && deadline != 0) {", "            revert DeadlinePassed();", "        }", "", "        // loop through and execute the changes", "        for (uint256 i = 0; i < changes.length; i++) {", "            Change memory _change = changes[i];", "", "            // transfer NFTs from caller", "            for (uint256 j = 0; j < changes[i].inputTokenIds.length; j++) {", "                ERC721(_change.nft).safeTransferFrom(msg.sender, address(this), _change.inputTokenIds[j]);", "            }", "", "            // approve pair to transfer NFTs from router", "            ERC721(_change.nft).setApprovalForAll(_change.pool, true);", "", "            // execute change", "            PrivatePool(_change.pool).change{value: msg.value}(", "                _change.inputTokenIds,", "                _change.inputTokenWeights,", "                _change.inputProof,", "                _change.stolenNftProofs,", "                _change.outputTokenIds,", "                _change.outputTokenWeights,", "                _change.outputProof", "            );", "", "            // transfer NFTs to caller", "            for (uint256 j = 0; j < changes[i].outputTokenIds.length; j++) {", "                ERC721(_change.nft).safeTransferFrom(address(this), msg.sender, _change.outputTokenIds[j]);", "            }", "        }", "", "        // refund any surplus ETH to the caller", "        if (address(this).balance > 0) {", "            msg.sender.safeTransferETH(address(this).balance);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function getVotes(uint256 tokenId) external view returns (uint256) {", "        uint256[] memory delegated = _getCurrentDelegated(tokenId);", "        uint256 votes = 0;", "        for (uint256 index = 0; index < delegated.length; index++) {", "            votes = votes + this.balanceOfNFT(delegated[index]);", "        }", "        return votes;", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function migrateVaultERC20(", "        address _vault,", "        uint256 _proposalId,", "        address _token,", "        uint256 _amount,", "        bytes32[] calldata _erc20TransferProof", "    ) external {", "        address newVault = migrationInfo[_vault][_proposalId].newVault;", "        // Withdraws an ERC-20 token from the old vault and transfers to the new vault", "        IBuyout(buyout).withdrawERC20(", "            _vault,", "            _token,", "            newVault,", "            _amount,", "            _erc20TransferProof", "        );", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function initializeClone(address owner, uint256 _price, uint256 _limit, uint256 _coll, uint256 _mint) external onlyHub {", "        if(_coll < minimumCollateral) revert InsufficientCollateral();", "        setOwner(owner);", "        ", "        price = _mint * ONE_DEC18 / _coll;", "        if (price > _price) revert InsufficientCollateral();", "        limit = _limit;", "        mintInternal(owner, _mint, _coll);", "", "        emit PositionOpened(owner, original, address(zchf), address(collateral), _price);", "    }"], "ner_tags": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function calculateUnclaimedFreeFloatingETHShare(bytes memory _blsPubKey, address _user) public view returns (uint256) {", "        // Check the user has staked sETH for the KNOT", "        uint256 stakedBal = sETHStakedBalanceForKnot[_blsPubKey][_user];", "        if (stakedBal < 1 gwei) revert FreeFloatingStakeAmountTooSmall();", "", "        // Get the amount of ETH eligible for the user based on their staking amount", "        uint256 accumulatedETHPerShare = _getCorrectAccumulatedETHPerFreeFloatingShareForBLSPublicKey(_blsPubKey);", "        uint256 userShare = (accumulatedETHPerShare * stakedBal) / PRECISION;", "", "        // Calculate how much their unclaimed share of ETH is based on total ETH claimed so far", "        return userShare - sETHUserClaimForKnot[_blsPubKey][_user];", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["    function inviteContractor(bytes calldata _data, bytes calldata _signature)", "        external", "        override", "    {", "        // Revert if contractor has already confirmed his invitation", "        require(!contractorConfirmed, \"Project::GC accepted\");", "", "        // Decode params from _data", "        (address _contractor, address _projectAddress) = abi.decode(", "            _data,", "            (address, address)", "        );", "", "        // Revert if decoded project address does not match this contract. Indicating incorrect _data.", "        require(_projectAddress == address(this), \"Project::!projectAddress\");", "", "        // Revert if contractor address is invalid.", "        require(_contractor != address(0), \"Project::0 address\");", "", "        // Store new contractor", "        contractor = _contractor;", "        contractorConfirmed = true;", "", "        // Check signature for builder and contractor", "        checkSignature(_data, _signature);", "", "        emit ContractorInvited(contractor);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["    function getNewCurrentFees(", "        uint256 timeToWait,", "        uint256 lastActionTimestamp,", "        uint256 feeRatio", "    ) public view returns (uint256) {", "        uint256 timeElapsed = _getTime() - lastActionTimestamp;", "        uint256 minFeePercentage = getMinWithdrawalFee();", "        if (timeElapsed >= timeToWait) {", "            return minFeePercentage;", "        }", "        uint256 elapsedShare = timeElapsed.scaledDiv(timeToWait);", "        return feeRatio - (feeRatio - minFeePercentage).scaledMul(elapsedShare);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["    function redeem(", "        uint256 shares,", "        address receiver,", "        address owner", "    ) public override returns (uint256) {", "        // It is more accurate and gas efficient to check the balance of the", "        // receiver here than rely on the previewRedeem method.", "        uint256 balanceBefore = IERC20(asset()).balanceOf(receiver);", "", "        if (msg.sender != owner) {", "            _spendAllowance(owner, msg.sender, shares);", "        }", "        _redeemInternal(shares, receiver, owner);", "", "        uint256 balanceAfter = IERC20(asset()).balanceOf(receiver);", "        uint256 assets = balanceAfter - balanceBefore;", "        emit Withdraw(msg.sender, receiver, owner, assets, shares);", "        return assets;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": ["    function rageQuit(", "        uint256[] calldata tokenIds,", "        IERC20[] calldata withdrawTokens,", "        address receiver", "    ) external {", "        // Check if ragequit is allowed.", "        uint40 currentRageQuitTimestamp = rageQuitTimestamp;", "        if (currentRageQuitTimestamp != ENABLE_RAGEQUIT_PERMANENTLY) {", "            if (", "                currentRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY ||", "                currentRageQuitTimestamp < block.timestamp", "            ) {", "                revert CannotRageQuitError(currentRageQuitTimestamp);", "            }", "        }", "", "        // Used as a reentrancy guard. Will be updated back after ragequit.", "        delete rageQuitTimestamp;", "", "        for (uint256 i; i < tokenIds.length; ++i) {", "            uint256 tokenId = tokenIds[i];", "", "            // Must be retrieved before burning the token.", "            uint256 shareOfVotingPower = getDistributionShareOf(tokenId);", "", "            // Burn caller's party card. This will revert if caller is not the owner", "            // of the card.", "            burn(tokenId);", "", "            // Withdraw fair share of tokens from the party.", "            IERC20 prevToken;", "            for (uint256 j; j < withdrawTokens.length; ++j) {", "                IERC20 token = withdrawTokens[j];", "", "                // Prevent null and duplicate transfers.", "                if (prevToken >= token) revert InvalidTokenOrderError();", "", "                prevToken = token;", "", "                // Check if token is ETH.", "                if (address(token) == ETH_ADDRESS) {", "                    // Transfer fair share of ETH to receiver.", "                    uint256 amount = (address(this).balance * shareOfVotingPower) / 1e18;", "                    if (amount != 0) {", "                        payable(receiver).transferEth(amount);", "                    }", "                } else {", "                    // Transfer fair share of tokens to receiver.", "                    uint256 amount = (token.balanceOf(address(this)) * shareOfVotingPower) / 1e18;", "                    if (amount != 0) {", "                        token.compatTransfer(receiver, amount);", "                    }", "                }", "            }", "        }", "", "        // Update ragequit timestamp back to before.", "        rageQuitTimestamp = currentRageQuitTimestamp;", "", "        emit RageQuit(tokenIds, withdrawTokens, receiver);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyByOwnGov {", "        require(IERC20(tokenAddress).transfer(owner, tokenAmount), \"recoverERC20: Transfer failed\");", "", "        emit EmergencyERC20Recovered(tokenAddress, tokenAmount);", "    }"], "ner_tags": [1, 0, 0, 0, 0]}
{"tokens": ["    function mintAirdrop(address _airdrop) external onlyOwner {", "        require(!isAirdropMinted, 'already minted');", "        _mint(_airdrop, 150_000_000 * 1e18);", "        isAirdropMinted = true;", "    }"], "ner_tags": [1, 1, 1, 1, 1]}
{"tokens": ["    function migrateVaultERC721(", "        address _vault,", "        uint256 _proposalId,", "        address _token,", "        uint256 _tokenId,", "        bytes32[] calldata _erc721TransferProof", "    ) external {", "        address newVault = migrationInfo[_vault][_proposalId].newVault;", "        // Withdraws an ERC-721 token from the old vault and transfers to the new vault", "        IBuyout(buyout).withdrawERC721(", "            _vault,", "            _token,", "            newVault,", "            _tokenId,", "            _erc721TransferProof", "        );", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function createClone(address target) internal returns (address result) {", "        bytes20 targetBytes = bytes20(target);", "        assembly {", "            let clone := mload(0x40)", "            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)", "            mstore(add(clone, 0x14), targetBytes)", "            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)", "            result := create(0, clone, 0x37)", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["    function _isForFounder(uint256 _tokenId) private returns (bool) {", "        // Get the base token id", "        uint256 baseTokenId = _tokenId % 100;", "", "        // If there is no scheduled recipient:", "        if (tokenRecipient[baseTokenId].wallet == address(0)) {", "            return false;", "", "            // Else if the founder is still vesting:", "        } else if (block.timestamp < tokenRecipient[baseTokenId].vestExpiry) {", "            // Mint the token to the founder", "            _mint(tokenRecipient[baseTokenId].wallet, _tokenId);", "", "            return true;", "", "            // Else the founder has finished vesting:", "        } else {", "            // Remove them from future lookups", "            delete tokenRecipient[baseTokenId];", "", "            return false;", "        }", "    }"], "ner_tags": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function withdrawAll() public payable onlyOwner {", "        require(address(vault) != address(0), 'no vault');", "        require(payable(vault).send(address(this).balance));", "    }"], "ner_tags": [0, 0, 1, 0]}
{"tokens": ["    function transferOwnership(address _newOwner) public onlyOwner {", "        emit OwnerUpdated(_owner, _newOwner);", "", "        _owner = _newOwner;", "    }"], "ner_tags": [1, 0, 0, 0, 0]}
{"tokens": ["    function verifyOvercommittedStake(", "        uint40 validatorIndex,", "        BeaconChainProofs.ValidatorFieldsAndBalanceProofs calldata proofs,", "        bytes32[] calldata validatorFields,", "        uint256 beaconChainETHStrategyIndex,", "        uint64 oracleBlockNumber", "    ) external onlyWhenNotPaused(PAUSED_EIGENPODS_VERIFY_OVERCOMMITTED) {", "       // ensure that the blockNumber being proven against is not \"too stale\", i.e. that the validator was *recently* overcommitted.", "        require(oracleBlockNumber + VERIFY_OVERCOMMITTED_WINDOW_BLOCKS >= block.number,", "            \"EigenPod.verifyOvercommittedStake: specified blockNumber is too far in past\");", "", "        require(validatorStatus[validatorIndex] == VALIDATOR_STATUS.ACTIVE, \"EigenPod.verifyOvercommittedStake: Validator not active\");", "", "        // deserialize the balance field from the balanceRoot", "        uint64 validatorCurrentBalanceGwei = BeaconChainProofs.getBalanceFromBalanceRoot(validatorIndex, proofs.balanceRoot);        ", "", "        require(validatorCurrentBalanceGwei < REQUIRED_BALANCE_GWEI,", "            \"EigenPod.verifyOvercommittedStake: validator's balance must be less than the restaked balance per validator\");", "        ", "        // verify ETH validator proof", "        bytes32 beaconStateRoot = eigenPodManager.getBeaconChainStateRoot(oracleBlockNumber);", " ", "        /**", "         * If validator's balance is zero, then either they have fully withdrawn or they have been slashed down zero.", "         * If the validator *has* been slashed, then this function can proceed. If they have *not* been slashed, then", "         * the `verifyAndProcessWithdrawal` function should be called instead.", "         */", "        if (validatorCurrentBalanceGwei == 0) {", "            uint64 slashedStatus = Endian.fromLittleEndianUint64(validatorFields[BeaconChainProofs.VALIDATOR_SLASHED_INDEX]);", "            require(slashedStatus == 1, \"EigenPod.verifyOvercommittedStake: Validator must be slashed to be overcommitted\");", "            //Verify the validator fields, which contain the validator's slashed status", "            BeaconChainProofs.verifyValidatorFields(", "                validatorIndex,", "                beaconStateRoot,", "                proofs.validatorFieldsProof,", "                validatorFields", "            );", "        }", "        // verify ETH validator's current balance, which is stored in the `balances` container of the beacon state", "       BeaconChainProofs.verifyValidatorBalance(", "            validatorIndex,", "            beaconStateRoot,", "            proofs.validatorBalanceProof,", "            proofs.balanceRoot", "        );", "", "        // mark the ETH validator as overcommitted", "        validatorStatus[validatorIndex] = VALIDATOR_STATUS.OVERCOMMITTED;", "", "        emit ValidatorOvercommitted(validatorIndex);", "", "        // remove and undelegate shares in EigenLayer", "        eigenPodManager.recordOvercommittedBeaconChainETH(podOwner, beaconChainETHStrategyIndex, REQUIRED_BALANCE_WEI);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["    function _buy(", "        IERC721 token,", "        uint256 tokenId,", "        address payable callTarget,", "        uint96 callValue,", "        bytes calldata callData,", "        FixedGovernanceOpts memory governanceOpts", "    )", "        internal", "        onlyDelegateCall", "        returns (Party party_)", "    {", "        // Ensure the call target isn't trying to reenter or trying to do", "        // anything weird with `PartyFactory`.", "        IPartyFactory partyFactory = _getPartyFactory();", "        if (callTarget == address(partyFactory) || callTarget == address(this)) {", "            revert InvalidCallTargetError(callTarget);", "        }", "        // Check that the crowdfund is still active.", "        CrowdfundLifecycle lc = getCrowdfundLifecycle();", "        if (lc != CrowdfundLifecycle.Active) {", "            revert WrongLifecycleError(lc);", "        }", "        // Used to store the price the NFT was bought for.", "        uint96 settledPrice_;", "        {", "            uint96 maximumPrice_ = maximumPrice;", "            if (maximumPrice_ != 0 && callValue > maximumPrice_) {", "                revert MaximumPriceError(callValue, maximumPrice);", "            }", "            // If the purchase would be free, set the settled price to", "            // `totalContributions` so everybody who contributed wins.", "            settledPrice_ = callValue == 0 ? totalContributions : callValue;", "            if (settledPrice_ == 0) {", "                // Still zero, which means no contributions.", "                revert NoContributionsError();", "            }", "            settledPrice = settledPrice_;", "        }", "        {", "            // Execute the call to buy the NFT.", "            (bool s, bytes memory r) = callTarget.call{ value: callValue }(callData);", "            if (!s) {", "                r.rawRevert();", "            }", "        }", "        // Make sure we acquired the NFT we want.", "        if (token.safeOwnerOf(tokenId) != address(this)) {", "            revert FailedToBuyNFTError(token, tokenId);", "        }", "        emit Won(", "            // Create a party around the newly bought NFT.", "            party_ = _createParty(partyFactory, governanceOpts, token, tokenId),", "            token,", "            tokenId,", "            settledPrice_", "        );", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function initiateMarketOrder(", "        TradeInfo calldata _tradeInfo,", "        PriceData calldata _priceData,", "        bytes calldata _signature,", "        ERC20PermitData calldata _permitData,", "        address _trader", "    )", "        external", "    {", "        _validateProxy(_trader);", "        _checkDelay(position.getCount(), true);", "        _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);", "        address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();", "        tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);", "        tradingExtension._setReferral(_tradeInfo.referral, _trader);", "        uint256 _marginAfterFees = _tradeInfo.margin - _handleOpenFees(_tradeInfo.asset, _tradeInfo.margin*_tradeInfo.leverage/1e18, _trader, _tigAsset, false);", "        uint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18;", "        _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);", "        uint256 _isLong = _tradeInfo.direction ? 1 : 2;", "        (uint256 _price,) = tradingExtension.getVerifiedPrice(_tradeInfo.asset, _priceData, _signature, _isLong);", "        IPosition.MintTrade memory _mintTrade = IPosition.MintTrade(", "            _trader,", "            _marginAfterFees,", "            _tradeInfo.leverage,", "            _tradeInfo.asset,", "            _tradeInfo.direction,", "            _price,", "            _tradeInfo.tpPrice,", "            _tradeInfo.slPrice,", "            0,", "            _tigAsset", "        );", "        _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);", "        unchecked {", "            if (_tradeInfo.direction) {", "                tradingExtension.modifyLongOi(_tradeInfo.asset, _tigAsset, true, _positionSize);", "            } else {", "                tradingExtension.modifyShortOi(_tradeInfo.asset, _tigAsset, true, _positionSize);", "            }", "        }", "        _updateFunding(_tradeInfo.asset, _tigAsset);", "        position.mint(", "            _mintTrade", "        );", "        unchecked {", "            emit PositionOpened(_tradeInfo, 0, _price, position.getCount()-1, _trader, _marginAfterFees);", "        }   ", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function _createPublicVault(", "    address strategist,", "    address delegate,", "    uint256 epochLength", "  ) internal returns (address publicVault) {", "    vm.startPrank(strategist);", "    //bps", "    publicVault = ASTARIA_ROUTER.newPublicVault(", "      epochLength,", "      delegate,", "      address(WETH9),", "      uint256(0),", "      false,", "      new address[](0),", "      uint256(0)", "    );", "    vm.stopPrank();", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function unpause() external onlyOwner {", "        _unpause();", "", "        // If this is the first auction:", "        if (auction.tokenId == 0) {", "            // Transfer ownership of the contract to the DAO", "            transferOwnership(settings.treasury);", "", "            // Start the first auction", "            _createAuction();", "        }", "        // Else if the contract was paused and the previous auction was settled:", "        else if (auction.settled) {", "            // Start the next auction", "            _createAuction();", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function removeRouterLiquidityFor(", "    uint256 _amount,", "    address _local,", "    address payable _to,", "    address _router", "  ) external nonReentrant whenNotPaused {", "    // Caller must be the router owner", "    if (msg.sender != getRouterOwner(_router)) revert RoutersFacet__removeRouterLiquidityFor_notOwner();", "", "    // Remove liquidity", "    _removeLiquidityForRouter(_amount, _local, _to, _router);", "  }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function verifySignature(bytes memory name, RRUtils.SignedSet memory rrset, RRSetWithSignature memory data, bytes memory proof) internal view {", "        // o  The RRSIG RR's Signer's Name field MUST be the name of the zone", "        //    that contains the RRset.", "        if(rrset.signerName.length > name.length", "            || !rrset.signerName.equals(0, name, name.length - rrset.signerName.length))", "        {", "            revert InvalidSignerName(name, rrset.signerName);", "        }", "", "        RRUtils.RRIterator memory proofRR = proof.iterateRRs(0);", "        // Check the proof", "        if (proofRR.dnstype == DNSTYPE_DS) {", "            verifyWithDS(rrset, data, proofRR);", "        } else if (proofRR.dnstype == DNSTYPE_DNSKEY) {", "            verifyWithKnownKey(rrset, data, proofRR);", "        } else {", "            revert InvalidProofType(proofRR.dnstype);", "        }", "    }"], "ner_tags": [0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function _distributePayoutsOf(", "    uint256 _projectId,", "    uint256 _amount,", "    uint256 _currency,", "    uint256 _minReturnedTokens,", "    string calldata _memo", "  ) internal returns (uint256 netLeftoverDistributionAmount) {", "    // Record the distribution.", "    (JBFundingCycle memory _fundingCycle, uint256 _distributedAmount) = store.recordDistributionFor(", "      _projectId,", "      _amount,", "      _currency", "    );", "", "    // The amount being distributed must be at least as much as was expected.", "    if (_distributedAmount < _minReturnedTokens) revert INADEQUATE_DISTRIBUTION_AMOUNT();", "", "    // Get a reference to the project owner, which will receive tokens from paying the platform fee", "    // and receive any extra distributable funds not allocated to payout splits.", "    address payable _projectOwner = payable(projects.ownerOf(_projectId));", "", "    // Define variables that will be needed outside the scoped section below.", "    // Keep a reference to the fee amount that was paid.", "    uint256 _fee;", "", "    // Scoped section prevents stack too deep. `_feeDiscount`, `_feeEligibleDistributionAmount`, and `_leftoverDistributionAmount` only used within scope.", "    {", "      // Get the amount of discount that should be applied to any fees taken.", "      // If the fee is zero or if the fee is being used by an address that doesn't incur fees, set the discount to 100% for convinience.", "      uint256 _feeDiscount = fee == 0 || isFeelessAddress[msg.sender]", "        ? JBConstants.MAX_FEE_DISCOUNT", "        : _currentFeeDiscount(_projectId);", "", "      // The amount distributed that is eligible for incurring fees.", "      uint256 _feeEligibleDistributionAmount;", "", "      // The amount leftover after distributing to the splits.", "      uint256 _leftoverDistributionAmount;", "", "      // Payout to splits and get a reference to the leftover transfer amount after all splits have been paid.", "      // Also get a reference to the amount that was distributed to splits from which fees should be taken.", "      (_leftoverDistributionAmount, _feeEligibleDistributionAmount) = _distributeToPayoutSplitsOf(", "        _projectId,", "        _fundingCycle.configuration,", "        payoutSplitsGroup,", "        _distributedAmount,", "        _feeDiscount", "      );", "", "      // Leftover distribution amount is also eligible for a fee since the funds are going out of the ecosystem to _beneficiary.", "      unchecked {", "        _feeEligibleDistributionAmount += _leftoverDistributionAmount;", "      }", "", "      // Take the fee.", "      _fee = _feeDiscount == JBConstants.MAX_FEE_DISCOUNT || _feeEligibleDistributionAmount == 0", "        ? 0", "        : _takeFeeFrom(", "          _projectId,", "          _fundingCycle,", "          _feeEligibleDistributionAmount,", "          _projectOwner,", "          _feeDiscount", "        );", "", "      // Get a reference to how much to distribute to the project owner, which is the leftover amount minus any fees.", "", "      unchecked {", "        netLeftoverDistributionAmount = _leftoverDistributionAmount == 0", "          ? 0", "          : _leftoverDistributionAmount -", "            _feeAmount(_leftoverDistributionAmount, fee, _feeDiscount);", "      }", "", "      // Transfer any remaining balance to the project owner.", "      if (netLeftoverDistributionAmount > 0)", "        _transferFrom(address(this), _projectOwner, netLeftoverDistributionAmount);", "    }", "", "    emit DistributePayouts(", "      _fundingCycle.configuration,", "      _fundingCycle.number,", "      _projectId,", "      _projectOwner,", "      _amount,", "      _distributedAmount,", "      _fee,", "      netLeftoverDistributionAmount,", "      _memo,", "      msg.sender", "    );", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function execute(address target, uint256 value, bool isScript, bytes calldata data)", "    external", "    returns (bool success, bytes memory result)", "  {", "    if (msg.sender != LLAMA_CORE) revert OnlyLlamaCore();", "    (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);", "  }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function callContractWithToken(", "        string memory destinationChain,", "        string memory destinationContractAddress,", "        bytes memory payload,", "        string memory symbol,", "        uint256 amount", "    ) external {", "        _burnTokenFrom(msg.sender, symbol, amount);", "        emit ContractCallWithToken(", "            msg.sender,", "            destinationChain,", "            destinationContractAddress,", "            keccak256(payload),", "            payload,", "            symbol,", "            amount", "        );", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function donate(address _rewardToken, uint256 _amount) external {", "        IERC20(_rewardToken).safeTransferFrom(msg.sender, address(this), _amount);", "        rewardTokenInfo[_rewardToken].queuedRewards += _amount;", "    }"], "ner_tags": [0, 1, 0, 0]}
{"tokens": ["    function sellUnderlying(", "        address u,", "        uint256 m,", "        uint128 a", "    ) external returns (uint128) {", "        IPool pool = IPool(pools[u][m]);", "        Safe.transfer(IERC20(address(pool.base())), address(pool), a);", "        return pool.sellBase(msg.sender, pool.sellBasePreview(a));", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function delegate(uint256 tokenId, uint256 toTokenId) external {", "        require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');", "        require(this.balanceOfNFT(tokenId) >= MIN_VOTING_POWER_REQUIRED, 'VEDelegation: Need more voting power');", "", "        delegates[tokenId] = toTokenId;", "        uint256 nCheckpoints = numCheckpoints[toTokenId];", "", "        if (nCheckpoints > 0) {", "            Checkpoint storage checkpoint = checkpoints[toTokenId][nCheckpoints - 1];", "            checkpoint.delegatedTokenIds.push(tokenId);", "            _writeCheckpoint(toTokenId, nCheckpoints, checkpoint.delegatedTokenIds);", "        } else {", "            uint256[] memory array = new uint256[](1);", "            array[0] = tokenId;", "            _writeCheckpoint(toTokenId, nCheckpoints, array);", "        }", "", "        emit DelegateChanged(tokenId, toTokenId, msg.sender);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": ["    function getMerkleRoot() public view returns (bytes32) {", "        if (block.timestamp >= endOfDisputePeriod) return tree.merkleRoot;", "        else return lastTree.merkleRoot;", "    }"], "ner_tags": [0, 1, 0, 0]}
{"tokens": ["    function setVoteStatus(address account, bool voted) external {", "        require(msg.sender == voter);", "        uint nCheckpoints = numCheckpoints[account];", "        if (nCheckpoints == 0) {", "            checkpoints[account][0] = Checkpoint(block.timestamp, 0, voted);", "            numCheckpoints[account] = 1;", "        } else {", "            checkpoints[account][nCheckpoints - 1].voted = voted;", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["  function handleBuyoutLien(BuyoutLienParams calldata params)", "    public", "    onlyLienToken", "  {", "    VaultData storage s = _loadStorageSlot();", "", "    unchecked {", "      uint48 newSlope = s.slope - params.lienSlope.safeCastTo48();", "      _setSlope(s, newSlope);", "      s.yIntercept += params.increaseYIntercept.safeCastTo88();", "      s.last = block.timestamp.safeCastTo40();", "    }", "", "    _decreaseEpochLienCount(s, getLienEpoch(params.lienEnd.safeCastTo64()));", "    emit YInterceptChanged(s.yIntercept);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}
{"tokens": ["    function _convertSharesToYieldTokens(address yieldToken, uint256 shares) internal view returns (uint256) {", "        uint256 totalShares = _yieldTokens[yieldToken].totalShares;", "        if (totalShares == 0) {", "          return shares;", "        }", "        return (shares * _calculateUnrealizedActiveBalance(yieldToken)) / totalShares;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["    function _delegate(address delegator, address delegatee) internal {", "        // Move delegation from the old delegate to the given delegate", "        address oldDelegatee = delegates[delegator];", "        uint256 delegatorBalance = balanceOf(delegator);", "        delegates[delegator] = delegatee;", "", "        // update the the Delegate chekpoint for the delegatee", "        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));", "", "        emit DelegateChanged(delegator, oldDelegatee, delegatee);", "", "        // and write the checkpoints for Votes", "        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function compound(", "        uint24 fee,", "        uint256 amountOutMinimum,", "        uint160 sqrtPriceLimitX96,", "        bool optOutIncentive", "    )", "        public", "        returns (", "            uint256 gmxBaseRewardAmountIn,", "            uint256 gmxAmountOut,", "            uint256 pxGmxMintAmount,", "            uint256 totalFee,", "            uint256 incentive", "        )", "    {", "        if (fee == 0) revert InvalidParam();", "        if (amountOutMinimum == 0) revert InvalidParam();", "", "        uint256 assetsBeforeClaim = asset.balanceOf(address(this));", "", "        PirexRewards(rewardsModule).claim(asset, address(this));", "", "        // Swap entire reward balance for GMX", "        gmxBaseRewardAmountIn = gmxBaseReward.balanceOf(address(this));", "", "        if (gmxBaseRewardAmountIn != 0) {", "            gmxAmountOut = SWAP_ROUTER.exactInputSingle(", "                IV3SwapRouter.ExactInputSingleParams({", "                    tokenIn: address(gmxBaseReward),", "                    tokenOut: address(gmx),", "                    fee: fee,", "                    recipient: address(this),", "                    amountIn: gmxBaseRewardAmountIn,", "                    amountOutMinimum: amountOutMinimum,", "                    sqrtPriceLimitX96: sqrtPriceLimitX96", "                })", "            );", "", "            // Deposit entire GMX balance for pxGMX, increasing the asset/share amount", "            (, pxGmxMintAmount, ) = PirexGmx(platform).depositGmx(", "                gmx.balanceOf(address(this)),", "                address(this)", "            );", "        }", "", "        // Only distribute fees if the amount of vault assets increased", "        if ((totalAssets() - assetsBeforeClaim) != 0) {", "            totalFee =", "                ((asset.balanceOf(address(this)) - assetsBeforeClaim) *", "                    platformFee) /", "                FEE_DENOMINATOR;", "            incentive = optOutIncentive", "                ? 0", "                : (totalFee * compoundIncentive) / FEE_DENOMINATOR;", "", "            if (incentive != 0) asset.safeTransfer(msg.sender, incentive);", "", "            asset.safeTransfer(owner, totalFee - incentive);", "        }", "", "        emit Compounded(", "            msg.sender,", "            fee,", "            amountOutMinimum,", "            sqrtPriceLimitX96,", "            gmxBaseRewardAmountIn,", "            gmxAmountOut,", "            pxGmxMintAmount,", "            totalFee,", "            incentive", "        );", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function deliverReward(address token, uint epochStart) external lock returns (uint) {", "    require(msg.sender == gauge);", "    uint rewardPerEpoch = tokenRewardsPerEpoch[token][epochStart];", "    if (rewardPerEpoch > 0) {", "      _safeTransfer(token, address(gauge), rewardPerEpoch);", "    }", "    return rewardPerEpoch;", "  }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _execute(address _target, bytes calldata _data)", "        internal", "        returns (bool success, bytes memory response)", "    {", "        // Check that the target is a valid contract", "        uint256 codeSize;", "        assembly {", "            codeSize := extcodesize(_target)", "        }", "        if (codeSize == 0) revert TargetInvalid(_target);", "        // Save the owner address in memory to ensure that it cannot be modified during the DELEGATECALL", "        address owner_ = owner;", "        // Reserve some gas to ensure that the function has enough to finish the execution", "        uint256 stipend = gasleft() - MIN_GAS_RESERVE;", "", "        // Delegate call to the target contract", "        (success, response) = _target.delegatecall{gas: stipend}(_data);", "        if (owner_ != owner) revert OwnerChanged(owner_, owner);", "", "        // Revert if execution was unsuccessful", "        if (!success) {", "            if (response.length == 0) revert ExecutionReverted();", "            _revertedWithReason(response);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function redeem(", "        address to,", "        uint256 amountVoltIn,", "        uint256 minAmountOut", "    )", "        external", "        virtual", "        override", "        nonReentrant", "        whenNotPaused", "        whileRedemptionsNotPaused", "        returns (uint256 amountOut)", "    {", "        _depleteBuffer(amountVoltIn); /// deplete buffer first to save gas on buffer exhaustion sad path", "", "        updateOracle();", "", "        amountOut = _getRedeemAmountOut(amountVoltIn);", "        require(", "            amountOut >= minAmountOut,", "            \"PegStabilityModule: Redeem not enough out\"", "        );", "", "        IERC20(volt()).safeTransferFrom(", "            msg.sender,", "            address(this),", "            amountVoltIn", "        );", "", "        pcvDeposit.withdraw(to, amountOut);", "", "        emit Redeem(to, amountVoltIn, amountOut);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": ["    function _validateAccountPrepayment(uint256 opIndex, UserOperation calldata op, UserOpInfo memory opInfo, address aggregator, uint256 requiredPrefund)", "    internal returns (uint256 gasUsedByValidateAccountPrepayment, address actualAggregator, uint256 deadline) {", "    unchecked {", "        uint256 preGas = gasleft();", "        MemoryUserOp memory mUserOp = opInfo.mUserOp;", "        address sender = mUserOp.sender;", "        _createSenderIfNeeded(opIndex, opInfo, op.initCode);", "        if (aggregator == SIMULATE_FIND_AGGREGATOR) {", "            numberMarker();", "", "            if (sender.code.length == 0) {", "                // it would revert anyway. but give a meaningful message", "                revert FailedOp(0, address(0), \"AA20 account not deployed\");", "            }", "            if (mUserOp.paymaster != address(0) && mUserOp.paymaster.code.length == 0) {", "                // it would revert anyway. but give a meaningful message", "                revert FailedOp(0, address(0), \"AA30 paymaster not deployed\");", "            }", "            try IAggregatedAccount(sender).getAggregator() returns (address userOpAggregator) {", "                aggregator = actualAggregator = userOpAggregator;", "            } catch {", "                aggregator = actualAggregator = address(0);", "            }", "        }", "        uint256 missingAccountFunds = 0;", "        address paymaster = mUserOp.paymaster;", "        if (paymaster == address(0)) {", "            uint256 bal = balanceOf(sender);", "            missingAccountFunds = bal > requiredPrefund ? 0 : requiredPrefund - bal;", "        }", "        try IAccount(sender).validateUserOp{gas : mUserOp.verificationGasLimit}(op, opInfo.userOpHash, aggregator, missingAccountFunds) returns (uint256 _deadline) {", "            // solhint-disable-next-line not-rely-on-time", "            if (_deadline != 0 && _deadline < block.timestamp) {", "                revert FailedOp(opIndex, address(0), \"AA22 expired\");", "            }", "            deadline = _deadline;", "        } catch Error(string memory revertReason) {", "            revert FailedOp(opIndex, address(0), revertReason);", "        } catch {", "            revert FailedOp(opIndex, address(0), \"AA23 reverted (or OOG)\");", "        }", "        if (paymaster == address(0)) {", "            DepositInfo storage senderInfo = deposits[sender];", "            uint256 deposit = senderInfo.deposit;", "            if (requiredPrefund > deposit) {", "                revert FailedOp(opIndex, address(0), \"AA21 didn't pay prefund\");", "            }", "            senderInfo.deposit = uint112(deposit - requiredPrefund);", "        }", "        gasUsedByValidateAccountPrepayment = preGas - gasleft();", "    }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function safeTransferFrom(", "        address _from,", "        address _to,", "        uint256 _idx", "    ) external onlyOwner {", "        _transferFrom(_from, _to, _idx);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function increaseDebt(", "        address mintTo,", "        ERC721 asset,", "        uint256 amount,", "        ReservoirOracleUnderwriter.OracleInfo calldata oracleInfo", "    ) external override {", "        _increaseDebt({account: msg.sender, asset: asset, mintTo: mintTo, amount: amount, oracleInfo: oracleInfo});", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function rethAddress() private view returns (address) {", "        return", "            RocketStorageInterface(ROCKET_STORAGE_ADDRESS).getAddress(", "                keccak256(", "                    abi.encodePacked(\"contract.address\", \"rocketTokenRETH\")", "                )", "            );", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function _mint(", "        address _account,", "        uint256 _id,", "        uint256 _amount", "    ) internal virtual {", "        if (_account == address(0)) revert LBToken__MintToAddress0();", "", "        _beforeTokenTransfer(address(0), _account, _id, _amount);", "", "        _totalSupplies[_id] += _amount;", "", "        uint256 _accountBalance = _balances[_id][_account];", "        unchecked {", "            _balances[_id][_account] = _accountBalance + _amount;", "        }", "", "        _add(_account, _id, _accountBalance, _amount);", "", "        emit TransferSingle(msg.sender, address(0), _account, _id, _amount);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function submitSDPrice(SDPriceData calldata _sdPriceData) external override trustedNodeOnly checkMinTrustedNodes {", "        if (_sdPriceData.reportingBlockNumber >= block.number) {", "            revert ReportingFutureBlockData();", "        }", "        if (_sdPriceData.reportingBlockNumber % updateFrequencyMap[SD_PRICE_UF] > 0) {", "            revert InvalidReportingBlock();", "        }", "        if (_sdPriceData.reportingBlockNumber <= lastReportedSDPriceData.reportingBlockNumber) {", "            revert ReportingPreviousCycleData();", "        }", "", "        // Get submission keys", "        bytes32 nodeSubmissionKey = keccak256(abi.encode(msg.sender, _sdPriceData.reportingBlockNumber));", "        bytes32 submissionCountKey = keccak256(abi.encode(_sdPriceData.reportingBlockNumber));", "        uint8 submissionCount = attestSubmission(nodeSubmissionKey, submissionCountKey);", "        insertSDPrice(_sdPriceData.sdPriceInETH);", "        // Emit SD Price submitted event", "        emit SDPriceSubmitted(msg.sender, _sdPriceData.sdPriceInETH, _sdPriceData.reportingBlockNumber, block.number);", "", "        // price can be derived once more than 66% percent oracles have submitted price", "        if ((submissionCount == (2 * trustedNodesCount) / 3 + 1)) {", "            lastReportedSDPriceData = _sdPriceData;", "            lastReportedSDPriceData.sdPriceInETH = getMedianValue(sdPrices);", "            delete sdPrices;", "", "            // Emit SD Price updated event", "            emit SDPriceUpdated(_sdPriceData.sdPriceInETH, _sdPriceData.reportingBlockNumber, block.number);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function unwrap(", "        uint256 amount,", "        address recipient", "    ) external lock onlyAlchemist returns (uint256) {", "        SafeERC20.safeTransferFrom(token, msg.sender, address(this), amount);", "", "        uint256 startingBalance = IERC20(underlyingToken).balanceOf(address(this));", "", "        uint256 error;", "        if ((error = ICERC20(token).redeem(amount)) != NO_ERROR) {", "            revert FuseError(error);", "        }", "", "        uint256 endingBalance = IERC20(underlyingToken).balanceOf(address(this));", "        uint256 redeemedAmount = endingBalance - startingBalance;", "", "        SafeERC20.safeTransfer(underlyingToken, recipient, redeemedAmount);", "", "        return redeemedAmount;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function mintFromFixedPriceSale(", "    address nftContract,", "    uint16 count,", "    address payable buyReferrer", "  ) external payable returns (uint256 firstTokenId) {", "    // Validate input params.", "    if (count == 0) {", "      revert NFTDropMarketFixedPriceSale_Must_Buy_At_Least_One_Token();", "    }", "", "    FixedPriceSaleConfig memory saleConfig = nftContractToFixedPriceSaleConfig[nftContract];", "", "    // Confirm that the buyer will not exceed the limit specified after minting.", "    if (IERC721(nftContract).balanceOf(msg.sender) + count > saleConfig.limitPerAccount) {", "      if (saleConfig.limitPerAccount == 0) {", "        // Provide a more targeted error if the collection has not been listed.", "        revert NFTDropMarketFixedPriceSale_Must_Have_Sale_In_Progress();", "      }", "      revert NFTDropMarketFixedPriceSale_Cannot_Buy_More_Than_Limit(saleConfig.limitPerAccount);", "    }", "", "    // Calculate the total cost, considering the `count` requested.", "    uint256 mintCost;", "    unchecked {", "      // Can not overflow as 2^80 * 2^16 == 2^96 max which fits in 256 bits.", "      mintCost = uint256(saleConfig.price) * count;", "    }", "", "    // The sale price is immutable so the buyer is aware of how much they will be paying when their tx is broadcasted.", "    if (msg.value > mintCost) {", "      // Since price is known ahead of time, if too much ETH is sent then something went wrong.", "      revert NFTDropMarketFixedPriceSale_Too_Much_Value_Provided(mintCost);", "    }", "    // Withdraw from the user's available FETH balance if insufficient msg.value was included.", "    _tryUseFETHBalance(mintCost, false);", "", "    // Mint the NFTs.", "    firstTokenId = INFTDropCollectionMint(nftContract).mintCountTo(count, msg.sender);", "", "    // Distribute revenue from this sale.", "    (uint256 totalFees, uint256 creatorRev, ) = _distributeFunds(", "      nftContract,", "      firstTokenId,", "      saleConfig.seller,", "      mintCost,", "      buyReferrer", "    );", "", "    emit MintFromFixedPriceDrop(nftContract, msg.sender, firstTokenId, count, totalFees, creatorRev);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function migrateFractions(address _vault, uint256 _proposalId) external {", "        // Reverts if address is not a registered vault", "        (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);", "        if (id == 0) revert NotVault(_vault);", "        // Reverts if buyout state is not successful", "        (, address proposer, State current, , , ) = IBuyout(buyout).buyoutInfo(", "            _vault", "        );", "        State required = State.SUCCESS;", "        if (current != required) revert IBuyout.InvalidState(required, current);", "        // Reverts if proposer of buyout is not this contract", "        if (proposer != address(this)) revert NotProposalBuyout();", "", "        // Gets the last total supply of fractions for the vault", "        (, , , , , uint256 lastTotalSupply) = IBuyout(buyout).buyoutInfo(", "            _vault", "        );", "        // Calculates the total ether amount of a successful proposal", "        uint256 totalInEth = _calculateTotal(", "            1 ether,", "            lastTotalSupply,", "            migrationInfo[_vault][_proposalId].totalEth,", "            migrationInfo[_vault][_proposalId].totalFractions", "        );", "        // Calculates balance of caller based on ether contribution", "        uint256 balanceContributedInEth = _calculateContribution(", "            totalInEth,", "            lastTotalSupply,", "            userProposalEth[_proposalId][msg.sender],", "            userProposalFractions[_proposalId][msg.sender]", "        );", "", "        // Gets the token and fraction ID of the new vault", "        address newVault = migrationInfo[_vault][_proposalId].newVault;", "        (address token, uint256 newFractionId) = IVaultRegistry(registry)", "            .vaultToToken(newVault);", "        // Calculates share amount of fractions for the new vault based on the new total supply", "        uint256 newTotalSupply = IVaultRegistry(registry).totalSupply(newVault);", "        uint256 shareAmount = (balanceContributedInEth * newTotalSupply) /", "            totalInEth;", "", "        // Transfers fractional tokens to caller based on share amount", "        IFERC1155(token).safeTransferFrom(", "            address(this),", "            msg.sender,", "            newFractionId,", "            shareAmount,", "            \"\"", "        );", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function claimRewards(", "        address _recipient,", "        bytes[] calldata _blsPubKeys", "    ) external nonReentrant {", "        for (uint256 i; i < _blsPubKeys.length; ++i) {", "            require(", "                liquidStakingNetworkManager.isBLSPublicKeyBanned(_blsPubKeys[i]) == false,", "                \"Unknown BLS public key\"", "            );", "", "            // Ensure that the BLS key has its derivatives minted", "            require(", "                getAccountManager().blsPublicKeyToLifecycleStatus(_blsPubKeys[i]) == IDataStructures.LifecycleStatus.TOKENS_MINTED,", "                \"Derivatives not minted\"", "            );", "", "            if (i == 0 && !Syndicate(payable(liquidStakingNetworkManager.syndicate())).isNoLongerPartOfSyndicate(_blsPubKeys[i])) {", "                // Withdraw any ETH accrued on free floating SLOT from syndicate to this contract", "                // If a partial list of BLS keys that have free floating staked are supplied, then partial funds accrued will be fetched", "                _claimFundsFromSyndicateForDistribution(", "                    liquidStakingNetworkManager.syndicate(),", "                    _blsPubKeys", "                );", "", "                // Distribute ETH per LP", "                updateAccumulatedETHPerLP();", "            }", "", "            // If msg.sender has a balance for the LP token associated with the BLS key, then send them any accrued ETH", "            LPToken token = lpTokenForKnot[_blsPubKeys[i]];", "            require(address(token) != address(0), \"Invalid BLS key\");", "            require(token.lastInteractedTimestamp(msg.sender) + 30 minutes < block.timestamp, \"Last transfer too recent\");", "            _distributeETHRewardsToUserForToken(msg.sender, address(token), token.balanceOf(msg.sender), _recipient);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function payFees(", "        address payer,", "        address beneficiary,", "        uint256 amount,", "        address lpTokenAddress", "    ) external override returns (bool) {", "        require(msg.sender == actionContract, Error.UNAUTHORIZED_ACCESS);", "        // Handle keeper fees", "        uint256 keeperAmount = amount.scaledMul(getKeeperFeeFraction());", "        uint256 treasuryAmount = amount.scaledMul(getTreasuryFeeFraction());", "        LpToken lpToken = LpToken(lpTokenAddress);", "", "        lpToken.safeTransferFrom(msg.sender, address(this), amount);", "", "        address keeperGauge = getKeeperGauge(lpTokenAddress);", "        if (keeperGauge != address(0)) {", "            IKeeperGauge(keeperGauge).reportFees(beneficiary, keeperAmount, lpTokenAddress);", "        }", "", "        // Accrue keeper and treasury fees here for periodic claiming", "        keeperRecords[beneficiary][lpTokenAddress] += keeperAmount;", "        treasuryAmounts[lpTokenAddress] += treasuryAmount;", "", "        // Handle LP fees", "        uint256 lpAmount = amount - keeperAmount - treasuryAmount;", "        lpToken.burn(lpAmount);", "        emit FeesPayed(payer, beneficiary, lpTokenAddress, amount, keeperAmount, lpAmount);", "        return true;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function initialize(", "        address _treasury,", "        address _token,", "        address _vetoer,", "        uint256 _votingDelay,", "        uint256 _votingPeriod,", "        uint256 _proposalThresholdBps,", "        uint256 _quorumThresholdBps", "    ) external initializer {", "        // Ensure the caller is the contract manager", "        if (msg.sender != address(manager)) revert ONLY_MANAGER();", "", "        // Ensure non-zero addresses are provided", "        if (_treasury == address(0)) revert ADDRESS_ZERO();", "        if (_token == address(0)) revert ADDRESS_ZERO();", "", "        // Store the governor settings", "        settings.treasury = Treasury(payable(_treasury));", "        settings.token = Token(_token);", "        settings.vetoer = _vetoer;", "        settings.votingDelay = SafeCast.toUint48(_votingDelay);", "        settings.votingPeriod = SafeCast.toUint48(_votingPeriod);", "        settings.proposalThresholdBps = SafeCast.toUint16(_proposalThresholdBps);", "        settings.quorumThresholdBps = SafeCast.toUint16(_quorumThresholdBps);", "", "        // Initialize EIP-712 support", "        __EIP712_init(string.concat(settings.token.symbol(), \" GOV\"), \"1\");", "", "        // Grant ownership to the treasury", "        __Ownable_init(_treasury);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function createContract(", "        string memory _name,", "        string memory _symbol,", "        address _uri", "    ) external returns (address escherClone) {", "        require(escher.hasRole(escher.CREATOR_ROLE(), msg.sender), \"NOT AUTHORIZED\");", "", "        escherClone = implementation.clone();", "        address uriClone = _uri.clone();", "", "        Escher721(escherClone).initialize(msg.sender, uriClone, _name, _symbol);", "        ITokenUriDelegate(uriClone).initialize(msg.sender);", "", "        emit NewEscher721Contract(msg.sender, escherClone, uriClone);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function claimRevenue(SpigotState storage self, address revenueContract, address token, bytes calldata data)", "        external", "        returns (uint256 claimed)", "    {", "        claimed = _claimRevenue(self, revenueContract, token, data);", "", "        // splits revenue stream according to Spigot settings", "        uint256 escrowedAmount = claimed * self.settings[revenueContract].ownerSplit / 100;", "        // update escrowed balance", "        self.escrowed[token] = self.escrowed[token] + escrowedAmount;", "        ", "        // send non-escrowed tokens to Treasury if non-zero", "        if(claimed > escrowedAmount) {", "            require(LineLib.sendOutTokenOrETH(token, self.treasury, claimed - escrowedAmount));", "        }", "", "        emit ClaimRevenue(token, claimed, escrowedAmount, revenueContract);", "        ", "        return claimed;", "    }"], "ner_tags": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _verifySuccessfulState(uint256 _poolId)", "        internal", "        view", "        returns (", "            address,", "            uint48,", "            uint40,", "            bool,", "            bytes32", "        )", "    {", "        PoolInfo memory pool = poolInfo[_poolId];", "        if (!pool.success && block.timestamp < pool.terminationPeriod) revert InvalidState();", "        return (", "            pool.nftContract,", "            pool.totalSupply,", "            pool.terminationPeriod,", "            pool.success,", "            pool.merkleRoot", "        );", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    constructor(address _dao, address _curvePool) {", "        GovernanceTimelock = IGovernanceTimelock(_dao);", "        curvePool = ICurvePool(_curvePool);", "    }"], "ner_tags": [1, 0, 0, 0]}
{"tokens": ["    function regenerate(bool high_, uint256 capacity_) external permissioned {", "        uint256 threshold = (capacity_ * thresholdFactor) / FACTOR_SCALE;", "", "        if (high_) {", "            // Re-initialize the high side", "            _range.high = Side({", "                active: true,", "                lastActive: uint48(block.timestamp),", "                capacity: capacity_,", "                threshold: threshold,", "                market: _range.high.market", "            });", "        } else {", "            // Reinitialize the low side", "            _range.low = Side({", "                active: true,", "                lastActive: uint48(block.timestamp),", "                capacity: capacity_,", "                threshold: threshold,", "                market: _range.low.market", "            });", "        }", "", "        emit WallUp(high_, block.timestamp, capacity_);", "    }"], "ner_tags": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function getReward() external updateReward(msg.sender) {", "        require(!isOtherEarningsClaimable(msg.sender), \"Insufficient DLP, unable to claim rewards\");", "        uint256 reward = rewards[msg.sender];", "        if (reward > 0) {", "            rewards[msg.sender] = 0;", "            IesLBR(esLBR).mint(msg.sender, reward);", "            emit ClaimReward(msg.sender, reward, block.timestamp);", "        }", "    }"], "ner_tags": [0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function instantUnstake(uint256 _amount, address _recipient)", "        external", "        onlyStakingContract", "    {", "        require(isReserveEnabled, \"Not enabled yet\");", "        // claim the stakingToken from previous unstakes", "        IStaking(stakingContract).claimWithdraw(address(this));", "", "        uint256 amountMinusFee = _amount - ((_amount * fee) / BASIS_POINTS);", "", "        IERC20Upgradeable(rewardToken).safeTransferFrom(", "            msg.sender,", "            address(this),", "            _amount", "        );", "", "        IERC20Upgradeable(stakingToken).safeTransfer(", "            _recipient,", "            amountMinusFee", "        );", "        unstakeAllRewardTokens();", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["    function withdrawContribution(address _vault, uint256 _proposalId)", "        external", "    {", "        // Reverts if address is not a registered vault", "        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(", "            _vault", "        );", "        if (id == 0) revert NotVault(_vault);", "        // Reverts if caller has no fractional balance to withdraw", "        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);", "        if (", "            current != State.INACTIVE ||", "            migrationInfo[_vault][_proposalId].newVault != address(0)", "        ) revert NoContributionToWithdraw();", "", "        // Temporarily store user's fractions for the transfer", "        uint256 userFractions = userProposalFractions[_proposalId][msg.sender];", "        // Updates fractional balance of caller", "        userProposalFractions[_proposalId][msg.sender] = 0;", "        // Withdraws fractional tokens from contract back to caller", "        IFERC1155(token).safeTransferFrom(", "            address(this),", "            msg.sender,", "            id,", "            userFractions,", "            \"\"", "        );", "", "        // Temporarily store user's eth for the transfer", "        uint256 userEth = userProposalEth[_proposalId][msg.sender];", "        // Udpates ether balance of caller", "        userProposalEth[_proposalId][msg.sender] = 0;", "        // Withdraws ether from contract back to caller", "        payable(msg.sender).transfer(userEth);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0]}
{"tokens": ["    function withdraw() external onlyOwner {", "        uint256 amount = payableToken.balanceOf(address(this));", "        payableToken.transferFrom(address(this), msg.sender, amount);", "        emit NewWithdrawal(msg.sender, amount);", "    }"], "ner_tags": [0, 0, 1, 0, 0]}
{"tokens": ["    function removeFeeder(address _feeder)", "        external", "        onlyWhenFeederExisted(_feeder)", "    {", "        _removeFeeder(_feeder);", "    }"], "ner_tags": [1, 1, 1, 0, 0, 0]}
{"tokens": ["  function areNumItemsValid(", "    OrderTypes.MakerOrder calldata sell,", "    OrderTypes.MakerOrder calldata buy,", "    OrderTypes.OrderItem[] calldata constructedNfts", "  ) public pure returns (bool) {", "    uint256 numConstructedItems = 0;", "    uint256 nftsLength = constructedNfts.length;", "    for (uint256 i = 0; i < nftsLength; ) {", "      unchecked {", "        numConstructedItems += constructedNfts[i].tokens.length;", "        ++i;", "      }", "    }", "    return numConstructedItems >= buy.constraints[0] && buy.constraints[0] <= sell.constraints[0];", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["    function getPrice(address token, uint collateralFactorBps) external returns (uint) {", "        if(fixedPrices[token] > 0) return fixedPrices[token];", "        if(feeds[token].feed != IChainlinkFeed(address(0))) {", "            // get price from feed", "            uint price = feeds[token].feed.latestAnswer();", "            require(price > 0, \"Invalid feed price\");", "            // normalize price", "            uint8 feedDecimals = feeds[token].feed.decimals();", "            uint8 tokenDecimals = feeds[token].tokenDecimals;", "            uint8 decimals = 36 - feedDecimals - tokenDecimals;", "            uint normalizedPrice = price * (10 ** decimals);", "            // potentially store price as today's low", "            uint day = block.timestamp / 1 days;", "            uint todaysLow = dailyLows[token][day];", "            if(todaysLow == 0 || normalizedPrice < todaysLow) {", "                dailyLows[token][day] = normalizedPrice;", "                todaysLow = normalizedPrice;", "                emit RecordDailyLow(token, normalizedPrice);", "            }", "            // get yesterday's low", "            uint yesterdaysLow = dailyLows[token][day - 1];", "            // calculate new borrowing power based on collateral factor", "            uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;", "            uint twoDayLow = todaysLow > yesterdaysLow && yesterdaysLow > 0 ? yesterdaysLow : todaysLow;", "            if(twoDayLow > 0 && newBorrowingPower > twoDayLow) {", "                uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;", "                return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;", "            }", "            return normalizedPrice;", "", "        }", "        revert(\"Price not found\");", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function createProject(bytes memory _hash, address _currency)", "        external", "        override", "        nonReentrant", "    {", "        // Revert if currency not supported by HomeFi", "        validCurrency(_currency);", "", "        address _sender = _msgSender();", "", "        // Create a new project Clone and mint a new NFT for it", "        address _project = projectFactoryInstance.createProject(", "            _currency,", "            _sender", "        );", "        mintNFT(_sender, string(_hash));", "", "        // Update project related mappings", "        projects[projectCount] = _project;", "        projectTokenId[_project] = projectCount;", "", "        emit ProjectAdded(projectCount, _project, _sender, _currency, _hash);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    modifier updateReward(address _account) {", "        {", "            Balances storage userBalance = balances[_account];", "            uint256 rewardTokensLength = rewardTokens.length;", "            for (uint256 i = 0; i < rewardTokensLength; i++) {", "                address token = rewardTokens[i];", "                uint256 newRewardPerToken = _rewardPerToken(token);", "                rewardData[token].rewardPerTokenStored = newRewardPerToken.to96();", "                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(rewardData[token].periodFinish).to32();", "                if (_account != address(0)) {", "                    userData[_account][token] = UserData({", "                        rewardPerTokenPaid: newRewardPerToken.to128(),", "                        rewards: _earned(_account, token, userBalance.locked).to128()", "                    });", "                }", "            }", "        }", "        _;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function quote(uint192 amount, RoundingMode rounding)", "        external", "        view", "        returns (address[] memory erc20s, uint256[] memory quantities)", "    {", "        uint256 length = basket.erc20s.length;", "        erc20s = new address[](length);", "        quantities = new uint256[](length);", "", "        for (uint256 i = 0; i < length; ++i) {", "            erc20s[i] = address(basket.erc20s[i]);", "", "            // {qTok} = {tok/BU} * {BU} * {tok} * {qTok/tok}", "            quantities[i] = quantity(basket.erc20s[i]).mul(amount, rounding).shiftl_toUint(", "                int8(IERC20Metadata(address(basket.erc20s[i])).decimals()),", "                rounding", "            );", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["    constructor(address _governance) ERC20('Golom', 'GOL') ERC20Permit('Golom') {", "        _transferOwnership(_governance); // set the new owner", "    }"], "ner_tags": [1, 1, 1]}
{"tokens": ["    function batchRotateLPTokens(", "        address[] calldata _savETHVaults,", "        LPToken[][] calldata _oldLPTokens,", "        LPToken[][] calldata _newLPTokens,", "        uint256[][] calldata _amounts", "    ) external {", "        uint256 numOfRotations = _savETHVaults.length;", "        require(numOfRotations > 0, \"Empty arrays\");", "        require(numOfRotations == _oldLPTokens.length, \"Inconsistent arrays\");", "        require(numOfRotations == _newLPTokens.length, \"Inconsistent arrays\");", "        require(numOfRotations == _amounts.length, \"Inconsistent arrays\");", "        require(lpTokenETH.balanceOf(msg.sender) >= 0.5 ether, \"No common interest\");", "        for (uint256 i; i < numOfRotations; ++i) {", "            SavETHVault(_savETHVaults[i]).batchRotateLPTokens(_oldLPTokens[i], _newLPTokens[i], _amounts[i]);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["    function buy(uint256 _amount) external {", "        uint256 startingTrayId = _nextTokenId();", "        if (prelaunchMinted == type(uint256).max) {", "            // Still in prelaunch phase", "            if (msg.sender != owner) revert OnlyOwnerCanMintPreLaunch();", "            if (startingTrayId + _amount - 1 > PRE_LAUNCH_MINT_CAP) revert MintExceedsPreLaunchAmount();", "        } else {", "            SafeTransferLib.safeTransferFrom(note, msg.sender, revenueAddress, _amount * trayPrice);", "        }", "        for (uint256 i; i < _amount; ++i) {", "            TileData[TILES_PER_TRAY] memory trayTiledata;", "            for (uint256 j; j < TILES_PER_TRAY; ++j) {", "                lastHash = keccak256(abi.encode(lastHash));", "                trayTiledata[j] = _drawing(uint256(lastHash));", "            }", "            tiles[startingTrayId + i] = trayTiledata;", "        }", "        _mint(msg.sender, _amount); // We do not use _safeMint on purpose here to disallow callbacks and save gas", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function stakeFor(address account, uint256 amount) public override notPaused returns (bool) {", "        require(IERC20(token).balanceOf(msg.sender) >= amount, Error.INSUFFICIENT_BALANCE);", "", "        address lpGauge = currentAddresses[_LP_GAUGE];", "        if (lpGauge != address(0)) {", "            ILpGauge(lpGauge).userCheckpoint(account);", "        }", "", "        uint256 oldBal = IERC20(token).balanceOf(address(this));", "", "        if (msg.sender != account) {", "            ILiquidityPool pool = addressProvider.getPoolForToken(token);", "            pool.handleLpTokenTransfer(msg.sender, account, amount);", "        }", "", "        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);", "        uint256 staked = IERC20(token).balanceOf(address(this)) - oldBal;", "        require(staked == amount, Error.INVALID_AMOUNT);", "        balances[account] += staked;", "", "        if (strategies[account]) {", "            strategiesTotalStaked += staked;", "        } else {", "            _poolTotalStaked += staked;", "        }", "        emit Staked(account, amount);", "        return true;", "    }"], "ner_tags": [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function recordUsedAllowanceOf(", "    uint256 _projectId,", "    uint256 _amount,", "    uint256 _currency", "  )", "    external", "    override", "    nonReentrant", "    returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)", "  {", "    // Get a reference to the project's current funding cycle.", "    fundingCycle = fundingCycleStore.currentOf(_projectId);", "", "    // Get a reference to the new used overflow allowance for this funding cycle configuration.", "    uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[", "      IJBSingleTokenPaymentTerminal(msg.sender)", "    ][_projectId][fundingCycle.configuration] + _amount;", "", "    // There must be sufficient allowance available.", "    (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(", "      directory.controllerOf(_projectId)", "    ).overflowAllowanceOf(", "        _projectId,", "        fundingCycle.configuration,", "        IJBSingleTokenPaymentTerminal(msg.sender),", "        IJBSingleTokenPaymentTerminal(msg.sender).token()", "      );", "", "    // Make sure the new used amount is within the allowance.", "    if (_newUsedOverflowAllowanceOf > _overflowAllowanceOf || _overflowAllowanceOf == 0)", "      revert INADEQUATE_CONTROLLER_ALLOWANCE();", "", "    // Make sure the currencies match.", "    if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();", "", "    // Get a reference to the terminal's currency.", "    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();", "", "    // Convert the amount to this store's terminal's token.", "    usedAmount = (_currency == _balanceCurrency)", "      ? _amount", "      : PRBMath.mulDiv(", "        _amount,", "        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.", "        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)", "      );", "", "    // The amount being distributed must be available in the overflow.", "    if (", "      usedAmount >", "      _overflowDuring(", "        IJBSingleTokenPaymentTerminal(msg.sender),", "        _projectId,", "        fundingCycle,", "        _balanceCurrency", "      )", "    ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();", "", "    // Store the incremented value.", "    usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][", "      fundingCycle.configuration", "    ] = _newUsedOverflowAllowanceOf;", "", "    // Update the project's balance.", "    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =", "      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -", "      usedAmount;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function deposit(", "        uint256 id,", "        uint256 assets,", "        address receiver", "    ) public virtual returns (uint256 shares) {", "        // Check for rounding error since we round down in previewDeposit.", "        require((shares = previewDeposit(id, assets)) != 0, \"ZERO_SHARES\");", "", "        // Need to transfer before minting or ERC777s could reenter.", "        asset.safeTransferFrom(msg.sender, address(this), assets);", "", "        _mint(receiver, id, shares, EMPTY);", "", "        emit Deposit(msg.sender, receiver, id, assets, shares);", "", "        afterDeposit(id, assets, shares);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function fullCapacity(bool high_) public view override returns (uint256) {", "        uint256 reservesInTreasury = TRSRY.getReserveBalance(reserve);", "        uint256 capacity = (reservesInTreasury * _config.reserveFactor) / FACTOR_SCALE;", "        if (high_) {", "            capacity =", "                (capacity.mulDiv(", "                    10**ohmDecimals * 10**PRICE.decimals(),", "                    10**reserveDecimals * RANGE.price(true, true)", "                ) * (FACTOR_SCALE + RANGE.spread(true) * 2)) /", "                FACTOR_SCALE;", "        }", "        return capacity;", "    }"], "ner_tags": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function redeemParams(JBRedeemParamsData calldata _data)", "    external", "    view", "    override", "    returns (", "      uint256 reclaimAmount,", "      string memory memo,", "      JBRedemptionDelegateAllocation[] memory delegateAllocations", "    )", "  {", "    // Make sure fungible project tokens aren't being redeemed too.", "    if (_data.tokenCount > 0) revert UNEXPECTED_TOKEN_REDEEMED();", "", "    // Check the 4 bytes interfaceId and handle the case where the metadata was not intended for this contract", "    if (", "      _data.metadata.length < 4 || bytes4(_data.metadata[0:4]) != type(IJB721Delegate).interfaceId", "    ) {", "      revert INVALID_REDEMPTION_METADATA();", "    }", "", "    // Set the only delegate allocation to be a callback to this contract.", "    delegateAllocations = new JBRedemptionDelegateAllocation[](1);", "    delegateAllocations[0] = JBRedemptionDelegateAllocation(this, 0);", "", "    // If redemption rate is 0, nothing can be reclaimed from the treasury", "    if (_data.redemptionRate == 0) return (0, _data.memo, delegateAllocations);", "", "    // Decode the metadata", "    (, uint256[] memory _decodedTokenIds) = abi.decode(_data.metadata, (bytes4, uint256[]));", "", "    // Get a reference to the redemption rate of the provided tokens.", "    uint256 _redemptionWeight = _redemptionWeightOf(_decodedTokenIds);", "", "    // Get a reference to the total redemption weight.", "    uint256 _total = _totalRedemptionWeight();", "", "    // Get a reference to the linear proportion.", "    uint256 _base = PRBMath.mulDiv(_data.overflow, _redemptionWeight, _total);", "", "    // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary.", "    if (_data.redemptionRate == JBConstants.MAX_REDEMPTION_RATE)", "      return (_base, _data.memo, delegateAllocations);", "", "    // Return the weighted overflow, and this contract as the delegate so that tokens can be deleted.", "    return (", "      PRBMath.mulDiv(", "        _base,", "        _data.redemptionRate +", "          PRBMath.mulDiv(", "            _redemptionWeight,", "            JBConstants.MAX_REDEMPTION_RATE - _data.redemptionRate,", "            _total", "          ),", "        JBConstants.MAX_REDEMPTION_RATE", "      ),", "      _data.memo,", "      delegateAllocations", "    );", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function _acceptOffer(address nftContract, uint256 tokenId) private {", "    Offer memory offer = nftContractToIdToOffer[nftContract][tokenId];", "", "    // Remove offer", "    delete nftContractToIdToOffer[nftContract][tokenId];", "    // Withdraw ETH from the buyer's account in the FETH token contract.", "    feth.marketWithdrawLocked(offer.buyer, offer.expiration, offer.amount);", "", "    // Distribute revenue for this sale leveraging the ETH received from the FETH contract in the line above.", "    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(", "      nftContract,", "      tokenId,", "      payable(msg.sender),", "      offer.amount", "    );", "", "    // Transfer the NFT to the buyer.", "    try", "      IERC721(nftContract).transferFrom(msg.sender, offer.buyer, tokenId) // solhint-disable-next-line no-empty-blocks", "    {", "      // NFT was in the seller's wallet so the transfer is complete.", "    } catch {", "      // If the transfer fails then attempt to transfer from escrow instead.", "      // This should revert if the NFT is not in escrow of the `msg.sender` is not the owner of this NFT.", "      _transferFromEscrow(nftContract, tokenId, offer.buyer, msg.sender);", "    }", "", "    emit OfferAccepted(nftContract, tokenId, offer.buyer, msg.sender, f8nFee, creatorFee, ownerRev);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": ["    function rigidRedemption(address provider, uint256 peusdAmount) external virtual {", "        require(configurator.isRedemptionProvider(provider), \"provider is not a RedemptionProvider\");", "        require(borrowed[provider] >= peusdAmount, \"peusdAmount cannot surpass providers debt\");", "        uint256 assetPrice = getAssetPrice();", "        uint256 providerCollateralRatio = (depositedAsset[provider] * assetPrice * 100) / borrowed[provider];", "        require(providerCollateralRatio >= 100 * 1e18, \"provider's collateral ratio should more than 100%\");", "        _repay(msg.sender, provider, peusdAmount);", "        uint256 collateralAmount = (((peusdAmount * 1e18) / assetPrice) * (10000 - configurator.redemptionFee())) / 10000;", "        depositedAsset[provider] -= collateralAmount;", "        collateralAsset.transfer(msg.sender, collateralAmount);", "        emit RigidRedemption(msg.sender, provider, peusdAmount, collateralAmount, block.timestamp);", "    }"], "ner_tags": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function buy(Buy[] calldata buys, uint256 deadline, bool payRoyalties) public payable {", "        // check that the deadline has not passed (if any)", "        if (block.timestamp > deadline && deadline != 0) {", "            revert DeadlinePassed();", "        }", "", "        // loop through and execute the the buys", "        for (uint256 i = 0; i < buys.length; i++) {", "            if (buys[i].isPublicPool) {", "                // execute the buy against a public pool", "                uint256 inputAmount = Pair(buys[i].pool).nftBuy{value: buys[i].baseTokenAmount}(", "                    buys[i].tokenIds, buys[i].baseTokenAmount, 0", "                );", "", "                // pay the royalties if buyer has opted-in", "                if (payRoyalties) {", "                    uint256 salePrice = inputAmount / buys[i].tokenIds.length;", "                    for (uint256 j = 0; j < buys[i].tokenIds.length; j++) {", "                        // get the royalty fee and recipient", "                        (uint256 royaltyFee, address royaltyRecipient) =", "                            getRoyalty(buys[i].nft, buys[i].tokenIds[j], salePrice);", "", "                        if (royaltyFee > 0) {", "                            // transfer the royalty fee to the royalty recipient", "                            royaltyRecipient.safeTransferETH(royaltyFee);", "                        }", "                    }", "                }", "            } else {", "                // execute the buy against a private pool", "                PrivatePool(buys[i].pool).buy{value: buys[i].baseTokenAmount}(", "                    buys[i].tokenIds, buys[i].tokenWeights, buys[i].proof", "                );", "            }", "", "            for (uint256 j = 0; j < buys[i].tokenIds.length; j++) {", "                // transfer the NFT to the caller", "                ERC721(buys[i].nft).safeTransferFrom(address(this), msg.sender, buys[i].tokenIds[j]);", "            }", "        }", "", "        // refund any surplus ETH to the caller", "        if (address(this).balance > 0) {", "            msg.sender.safeTransferETH(address(this).balance);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0]}
{"tokens": ["  function _handleExecuteLiquidity(", "    bytes32 _transferId,", "    bool _isFast,", "    ExecuteArgs calldata _args", "  ) private returns (uint256, address) {", "    uint256 toSwap = _args.amount;", "", "    // If this is a fast liquidity path, we should handle deducting from applicable routers' liquidity.", "    // If this is a slow liquidity path, the transfer must have been reconciled (if we've reached this point),", "    // and the funds would have been custodied in this contract. The exact custodied amount is untracked in state", "    // (since the amount is hashed in the transfer ID itself) - thus, no updates are required.", "    if (_isFast) {", "      uint256 pathLen = _args.routers.length;", "", "      // Calculate amount that routers will provide with the fast-liquidity fee deducted.", "      toSwap = _getFastTransferAmount(_args.amount, s.LIQUIDITY_FEE_NUMERATOR, s.LIQUIDITY_FEE_DENOMINATOR);", "", "      // Save the addressess of all routers providing liquidity for this transfer.", "      s.routedTransfers[_transferId] = _args.routers;", "", "      // If router does not have enough liquidity, try to use Aave Portals.", "      // only one router should be responsible for taking on this credit risk, and it should only", "      // deal with transfers expecting adopted assets (to avoid introducing runtime slippage)", "      if (", "        !_args.params.receiveLocal &&", "        pathLen == 1 &&", "        s.routerBalances[_args.routers[0]][_args.local] < toSwap &&", "        s.aavePool != address(0)", "      ) {", "        if (!s.routerPermissionInfo.approvedForPortalRouters[_args.routers[0]])", "          revert BridgeFacet__execute_notApprovedForPortals();", "", "        // Portal provides the adopted asset so we early return here", "        return _executePortalTransfer(_transferId, toSwap, _args.local, _args.routers[0]);", "      } else {", "        // for each router, assert they are approved, and deduct liquidity", "        uint256 routerAmount = toSwap / pathLen;", "        for (uint256 i; i < pathLen; ) {", "          // decrement routers liquidity", "          s.routerBalances[_args.routers[i]][_args.local] -= routerAmount;", "", "          unchecked {", "            i++;", "          }", "        }", "      }", "    }", "", "    // if the local asset is specified, or the adopted asset was overridden (i.e. when", "    // user facing slippage conditions outside of their boundaries), exit", "    if (_args.params.receiveLocal || s.receiveLocalOverrides[_transferId]) {", "      return (toSwap, _args.local);", "    }", "", "    // swap out of mad* asset into adopted asset if needed", "    return AssetLogic.swapFromLocalAssetIfNeeded(_args.local, toSwap, _args.params.slippageTol);", "  }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function notifyRewardAmount(uint256 reward) internal updateReward(address(0)) {", "        historicalRewards = historicalRewards.add(reward);", "        if (block.timestamp >= periodFinish) {", "            rewardRate = reward.div(duration);", "        } else {", "            uint256 remaining = periodFinish.sub(block.timestamp);", "            uint256 leftover = remaining.mul(rewardRate);", "            reward = reward.add(leftover);", "            rewardRate = reward.div(duration);", "        }", "        currentRewards = reward;", "        lastUpdateTime = block.timestamp;", "        periodFinish = block.timestamp.add(duration);", "        emit RewardAdded(reward);", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function _processOutputOrders(uint256 _nftId, BatchedOutputOrders[] calldata _batchedOrders) private {", "        uint256 batchedOrdersLength = _batchedOrders.length;", "        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\");", "        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");", "", "        for (uint256 i = 0; i < batchedOrdersLength; i++) {", "            (uint256 feesAmount, uint256 amountBought) = _submitOutOrders(", "                _nftId,", "                _batchedOrders[i],", "                _batchedOrders[i].toReserve", "            );", "            _transferFeeWithRoyalty(feesAmount, _batchedOrders[i].outputToken, _nftId);", "            if (!_batchedOrders[i].toReserve) {", "                _safeTransferAndUnwrap(_batchedOrders[i].outputToken, amountBought - feesAmount, _msgSender());", "            }", "        }", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function addSwingTrader(", "    uint256 traderId,", "    address _swingTrader,", "    bool active,", "    string calldata name", "  ) external onlyRoleMalt(ADMIN_ROLE, \"Must have admin privs\") {", "    SwingTraderData storage trader = swingTraders[traderId];", "    require(traderId > 2 && trader.id == 0, \"TraderId already used\");", "    require(_swingTrader != address(0), \"addr(0)\");", "", "    swingTraders[traderId] = SwingTraderData({", "      id: traderId,", "      index: activeTraders.length,", "      traderContract: _swingTrader,", "      name: name,", "      active: active", "    });", "", "    activeTraders.push(traderId);", "", "    emit AddSwingTrader(traderId, name, active, _swingTrader);", "  }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function shutdownPool(uint256 _pid) external returns (bool) {", "        require(msg.sender == poolManager, \"!auth\");", "        PoolInfo storage pool = poolInfo[_pid];", "", "        //withdraw from gauge", "        try IStaker(staker).withdrawAll(pool.lptoken, pool.gauge) {} catch {}", "", "        pool.shutdown = true;", "        gaugeMap[pool.gauge] = false;", "", "        emit PoolShuttedDown(_pid);", "        return true;", "    }"], "ner_tags": [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function withdraw(", "        address token,", "        uint256 amount,", "        address recipient", "    ) external onlyOwner {", "        require(recipient != address(0), \"Invalid recipient\");", "        IERC20(token).transfer(recipient, amount);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function swapValidator(uint256 from_idx, uint256 to_idx) public onlyByOwnGov {", "        // Get the original values", "        Validator memory fromVal = validators[from_idx];", "        Validator memory toVal = validators[to_idx];", "", "        // Set the swapped values", "        validators[to_idx] = fromVal;", "        validators[from_idx] = toVal;", "", "        emit ValidatorsSwapped(fromVal.pubKey, toVal.pubKey, from_idx, to_idx);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _harvestCore(uint256 _debt) internal override returns (int256 roi, uint256 repayment) {", "        _claimRewards();", "        uint256 numSteps = steps.length;", "        for (uint256 i = 0; i < numSteps; i = i.uncheckedInc()) {", "            address[2] storage step = steps[i];", "            IERC20Upgradeable startToken = IERC20Upgradeable(step[0]);", "            uint256 amount = startToken.balanceOf(address(this));", "            if (amount == 0) {", "                continue;", "            }", "            _swapVelo(step[0], step[1], amount, VELO_ROUTER);", "        }", "", "        uint256 allocated = IVault(vault).strategies(address(this)).allocated;", "        uint256 totalAssets = balanceOf();", "        uint256 toFree = _debt;", "", "        if (totalAssets > allocated) {", "            uint256 profit = totalAssets - allocated;", "            toFree += profit;", "            roi = int256(profit);", "        } else if (totalAssets < allocated) {", "            roi = -int256(allocated - totalAssets);", "        }", "", "        (uint256 amountFreed, uint256 loss) = _liquidatePosition(toFree);", "        repayment = MathUpgradeable.min(_debt, amountFreed);", "        roi -= int256(loss);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["    function encodeTransactionData(", "        Transaction memory _tx,", "        FeeRefund memory refundInfo,", "        uint256 _nonce", "    ) public view returns (bytes memory) {", "        bytes32 safeTxHash =", "            keccak256(", "                abi.encode(", "                    ACCOUNT_TX_TYPEHASH,", "                    _tx.to,", "                    _tx.value,", "                    keccak256(_tx.data),", "                    _tx.operation,", "                    _tx.targetTxGas,", "                    refundInfo.baseGas,", "                    refundInfo.gasPrice,", "                    refundInfo.gasToken,", "                    refundInfo.refundReceiver,", "                    _nonce", "                )", "            );", "        return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), safeTxHash);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0]}
{"tokens": ["    function _transferTo(", "        address paymentToken,", "        address from,", "        address to,", "        uint256 amount", "    ) internal {", "        if (amount == 0) {", "            return;", "        }", "", "        if (paymentToken == address(0)) {", "            /* Transfer funds in ETH. */", "            require(to != address(0), \"Transfer to zero address\");", "            (bool success,) = payable(to).call{value: amount}(\"\");", "            require(success, \"ETH transfer failed\");", "        } else if (paymentToken == POOL) {", "            /* Transfer Pool funds. */", "            bool success = IPool(POOL).transferFrom(from, to, amount);", "            require(success, \"Pool transfer failed\");", "        } else if (paymentToken == WETH) {", "            /* Transfer funds in WETH. */", "            executionDelegate.transferERC20(WETH, from, to, amount);", "        } else {", "            revert(\"Invalid payment token\");", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["    function _mintToken(", "        string memory symbol,", "        address account,", "        uint256 amount", "    ) internal {", "        address tokenAddress = tokenAddresses(symbol);", "", "        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);", "", "        if (_getTokenType(symbol) == TokenType.External) {", "            _checkTokenStatus(symbol);", "", "            bool success = _callERC20Token(", "                tokenAddress,", "                abi.encodeWithSelector(IERC20.transfer.selector, account, amount)", "            );", "", "            if (!success) revert MintFailed(symbol);", "        } else {", "            BurnableMintableCappedERC20(tokenAddress).mint(account, amount);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": ["    function _depositToTreasury(uint256 amount) internal override {", "        payable(addressProvider.getTreasury()).transfer(amount);", "    }"], "ner_tags": [0, 1, 0]}
{"tokens": ["    function calculateGaugeAllocation(address gauge, uint256 quantity) external view returns (uint256) {", "        if (_deprecatedGauges.contains(gauge)) return 0;", "        uint32 currentCycle = _getGaugeCycleEnd();", "", "        uint112 total = _getStoredWeight(_totalWeight, currentCycle);", "        uint112 weight = _getStoredWeight(_getGaugeWeight[gauge], currentCycle);", "        return (quantity * weight) / total;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["    modifier mutualConsent(address _signerOne, address _signerTwo) {", "      if(_mutualConsent(_signerOne, _signerTwo))  {", "        // Run whatever code needed 2/2 consent", "        _;", "      }", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1]}
{"tokens": ["    function buyOption(uint256 vaultId) external payable returns (uint256 optionId) {", "        Vault memory vault = _vaults[vaultId];", "", "        // vaultId should always be odd", "        require(vaultId % 2 != 0, \"Not vault type\");", "", "        // check vault exists", "        require(ownerOf(vaultId) != address(0), \"Vault does not exist\");", "", "        // check that the vault still has the NFTs as collateral", "        require(vault.isExercised == false, \"Vault already exercised\");", "", "        // check that the vault is not in withdrawing state", "        require(vault.isWithdrawing == false, \"Vault is being withdrawn\");", "", "        // check enough eth was sent to cover premium", "        uint256 premium = getPremium(vaultId);", "        require(msg.value >= premium, \"Incorrect ETH amount sent\");", "", "        // check option associated with the vault has expired", "        uint32 auctionStartTimestamp = vault.currentExpiration;", "        require(block.timestamp >= auctionStartTimestamp, \"Auction not started\");", "", "        // set new currentStrike", "        vault.currentStrike = getDutchAuctionStrike(", "            strikeOptions[vault.dutchAuctionStartingStrikeIndex],", "            vault.currentExpiration + AUCTION_DURATION,", "            vault.dutchAuctionReserveStrike", "        );", "", "        // set new expiration", "        vault.currentExpiration = uint32(block.timestamp) + (vault.durationDays * 1 days);", "", "        // update the vault with the new option expiration and strike", "        _vaults[vaultId] = vault;", "", "        // force transfer the vault's associated option from old owner to new owner", "        // option id for a respective vault is always vaultId + 1", "        optionId = vaultId + 1;", "        _forceTransfer(msg.sender, optionId);", "", "        // increment vault beneficiary's unclaimed premiums", "        address beneficiary = getVaultBeneficiary(vaultId);", "        ethBalance[beneficiary] += msg.value;", "", "        emit BoughtOption(optionId, msg.sender, vault.token);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function batchDepositETHForStaking(", "        address[] calldata _savETHVaults,", "        uint256[] calldata _ETHTransactionAmounts,", "        bytes[][] calldata _blsPublicKeys,", "        uint256[][] calldata _stakeAmounts", "    ) public {", "        uint256 numOfSavETHVaults = _savETHVaults.length;", "        require(numOfSavETHVaults > 0, \"Empty arrays\");", "        require(numOfSavETHVaults == _ETHTransactionAmounts.length, \"Inconsistent array lengths\");", "        require(numOfSavETHVaults == _blsPublicKeys.length, \"Inconsistent array lengths\");", "        require(numOfSavETHVaults == _stakeAmounts.length, \"Inconsistent array lengths\");", "", "        // For every vault specified, supply ETH for at least 1 BLS public key of a LSDN validator", "        for (uint256 i; i < numOfSavETHVaults; ++i) {", "            uint256 transactionAmount = _ETHTransactionAmounts[i];", "", "            // As ETH is being deployed to a savETH pool vault, it is no longer idle", "            idleETH -= transactionAmount;", "", "            SavETHVault savETHPool = SavETHVault(_savETHVaults[i]);", "            require(", "                liquidStakingDerivativeFactory.isLiquidStakingManager(address(savETHPool.liquidStakingManager())),", "                \"Invalid liquid staking manager\"", "            );", "", "            // Deposit ETH for staking of BLS key", "            savETHPool.batchDepositETHForStaking{ value: transactionAmount }(", "                _blsPublicKeys[i],", "                _stakeAmounts[i]", "            );", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _getAbiParams() internal view returns (uint256 value, bool isSystemCall, address to) {", "        value = SystemContractHelper.getExtraAbiData(0);", "        uint256 addressAsUint = SystemContractHelper.getExtraAbiData(1);", "        uint256 mask = SystemContractHelper.getExtraAbiData(2);", "", "        isSystemCall = (mask & MSG_VALUE_SIMULATOR_IS_SYSTEM_BIT) != 0;", "", "        to = address(uint160(addressAsUint));", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function liquidation(address provider, address onBehalfOf, uint256 assetAmount) external virtual {", "        uint256 assetPrice = getAssetPrice();", "        uint256 onBehalfOfCollateralRatio = (depositedAsset[onBehalfOf] * assetPrice * 100) / getBorrowedOf(onBehalfOf);", "        require(onBehalfOfCollateralRatio < configurator.getBadCollateralRatio(address(this)), \"Borrowers collateral ratio should below badCollateralRatio\");", "", "        require(assetAmount * 2 <= depositedAsset[onBehalfOf], \"a max of 50% collateral can be liquidated\");", "        require(PeUSD.allowance(provider, address(this)) > 0, \"provider should authorize to provide liquidation EUSD\");", "        uint256 peusdAmount = (assetAmount * assetPrice) / 1e18;", "", "        _repay(provider, onBehalfOf, peusdAmount);", "        uint256 reducedAsset = (assetAmount * 11) / 10;", "        depositedAsset[onBehalfOf] -= reducedAsset;", "        uint256 reward2keeper;", "        if (provider == msg.sender) {", "            collateralAsset.transfer(msg.sender, reducedAsset);", "        } else {", "            reward2keeper = (reducedAsset * configurator.vaultKeeperRatio(address(this))) / 110;", "            collateralAsset.transfer(provider, reducedAsset - reward2keeper);", "            collateralAsset.transfer(msg.sender, reward2keeper);", "        }", "        emit LiquidationRecord(provider, msg.sender, onBehalfOf, peusdAmount, reducedAsset, reward2keeper, false, block.timestamp);", "    }"], "ner_tags": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function wrap(", "        uint256 amount,", "        address recipient", "    ) external onlyAlchemist returns (uint256) {", "        SafeERC20.safeTransferFrom(underlyingToken, msg.sender, address(this), amount);", "        SafeERC20.safeApprove(underlyingToken, token, amount);", "", "        uint256 startingBalance = IERC20(token).balanceOf(address(this));", "", "        uint256 error;", "        if ((error = ICERC20(token).mint(amount)) != NO_ERROR) {", "            revert FuseError(error);", "        }", "", "        uint256 endingBalance = IERC20(token).balanceOf(address(this));", "        uint256 mintedAmount = endingBalance - startingBalance;", "", "        SafeERC20.safeTransfer(token, recipient, mintedAmount);", "", "        return mintedAmount;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function viewPrice(address token, uint collateralFactorBps) external view returns (uint) {", "        if(fixedPrices[token] > 0) return fixedPrices[token];", "        if(feeds[token].feed != IChainlinkFeed(address(0))) {", "            // get price from feed", "            uint price = feeds[token].feed.latestAnswer();", "            require(price > 0, \"Invalid feed price\");", "            // normalize price", "            uint8 feedDecimals = feeds[token].feed.decimals();", "            uint8 tokenDecimals = feeds[token].tokenDecimals;", "            uint8 decimals = 36 - feedDecimals - tokenDecimals;", "            uint normalizedPrice = price * (10 ** decimals);", "            uint day = block.timestamp / 1 days;", "            // get today's low", "            uint todaysLow = dailyLows[token][day];", "            // get yesterday's low", "            uint yesterdaysLow = dailyLows[token][day - 1];", "            // calculate new borrowing power based on collateral factor", "            uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;", "            uint twoDayLow = todaysLow > yesterdaysLow && yesterdaysLow > 0 ? yesterdaysLow : todaysLow;", "            if(twoDayLow > 0 && newBorrowingPower > twoDayLow) {", "                uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;", "                return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;", "            }", "            return normalizedPrice;", "", "        }", "        revert(\"Price not found\");", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function cancel(bytes32 _proposalId) external {", "        // Ensure the proposal hasn't been executed", "        if (state(_proposalId) == ProposalState.Executed) revert PROPOSAL_ALREADY_EXECUTED();", "", "        // Get a copy of the proposal", "        Proposal memory proposal = proposals[_proposalId];", "", "        // Cannot realistically underflow and `getVotes` would revert", "        unchecked {", "            // Ensure the caller is the proposer or the proposer's voting weight has dropped below the proposal threshold", "            if (msg.sender != proposal.proposer && getVotes(proposal.proposer, block.timestamp - 1) > proposal.proposalThreshold)", "                revert INVALID_CANCEL();", "        }", "", "        // Update the proposal as canceled", "        proposals[_proposalId].canceled = true;", "", "        // If the proposal was queued:", "        if (settings.treasury.isQueued(_proposalId)) {", "            // Cancel the proposal", "            settings.treasury.cancel(_proposalId);", "        }", "", "        emit ProposalCanceled(_proposalId);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _calcRewardIntegral(", "        uint256 _pid,", "        uint256 _index,", "        address _account,", "        uint256 _balance,", "        uint256 _supply", "    ) internal {", "        RewardType memory reward = rewards[_pid][_index];", "", "        //get difference in balance and remaining rewards", "        //getReward is unguarded so we use remaining to keep track of how much was actually claimed", "        uint256 bal = IERC20(reward.token).balanceOf(address(this));", "        uint256 d_reward = bal - reward.remaining;", "        // send 20 % of cvx / crv reward to treasury", "        if (reward.token == cvx || reward.token == crv) {", "            IERC20(reward.token).transfer(treasury, d_reward / 5);", "            d_reward = (d_reward * 4) / 5;", "        }", "        IERC20(reward.token).transfer(address(claimContract), d_reward);", "", "        if (_supply > 0 && d_reward > 0) {", "            reward.integral =", "                reward.integral +", "                uint128((d_reward * 1e20) / _supply);", "        }", "", "        //update user integrals", "        uint256 userI = userReward[_pid][_index][_account].integral;", "        if (userI < reward.integral) {", "            userReward[_pid][_index][_account].integral = reward.integral;", "            claimContract.pushReward(", "                _account,", "                reward.token,", "                (_balance * (reward.integral - userI)) / 1e20", "            );", "        }", "", "        //update remaining reward here since balance could have changed if claiming", "        if (bal != reward.remaining) {", "            reward.remaining = uint128(bal);", "        }", "", "        rewards[_pid][_index] = reward;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": ["    function approveAssetOnMarket(address toApprove) public {", "        // Approve exchange", "        ERC20(toApprove).approve(RubiconMarketAddress, 2**256 - 1);", "    }"], "ner_tags": [0, 0, 1, 0]}
{"tokens": ["    function withdraw(address token, uint256 amount) external override onlyVault returns (bool) {", "        require(canWithdraw(msg.sender), Error.RESERVE_ACCESS_EXCEEDED);", "        uint256 accountBalance = _balances[msg.sender][token];", "        require(accountBalance >= amount, Error.INSUFFICIENT_BALANCE);", "", "        _balances[msg.sender][token] -= amount;", "        _lastWithdrawal[msg.sender] = block.timestamp;", "", "        if (token == address(0)) {", "            payable(msg.sender).transfer(amount);", "        } else {", "            IERC20(token).safeTransfer(msg.sender, amount);", "        }", "        emit Withdraw(msg.sender, token, amount);", "        return true;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _minWethAmountOut(uint256 tokenAmount_, address token_)", "        internal", "        view", "        returns (uint256 minAmountOut)", "    {", "        uint256 priceInEth_ = _getPriceInEth(token_);", "        if (priceInEth_ == 0) return 0;", "        return", "            tokenAmount_.scaledMul(priceInEth_).scaledMul(slippageTolerance).scaleFrom(", "                IERC20Full(token_).decimals()", "            );", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function setLiquidityPool(address _liquidityPool) external onlyOwner {", "        liquidityPool = ILiquidityPool(_liquidityPool);", "    }"], "ner_tags": [1, 0, 0]}
{"tokens": ["  function afterDeposit(uint256 assets, uint256 shares)", "    internal", "    virtual", "    override", "  {", "    VaultData storage s = _loadStorageSlot();", "", "    unchecked {", "      s.yIntercept += assets.safeCastTo88();", "    }", "    VIData storage v = _loadVISlot();", "    if (v.depositCap != 0 && totalAssets() >= v.depositCap) {", "      revert InvalidState(InvalidStates.DEPOSIT_CAP_EXCEEDED);", "    }", "    emit YInterceptChanged(s.yIntercept);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function withdraw(uint8 p, address u, address c, uint256 a) internal returns (bool) {", "    // TODO as stated elsewhere, we may choose to simply return true in all and not attempt to measure against any expected return", "    if (p == uint8(Protocols.Compound)) { // TODO is Rari a drop in here?", "      return ICompound(c).redeemUnderlying(a) == 0;", "    } else if (p == uint8(Protocols.Yearn)) {", "      // yearn vault api states that withdraw returns uint256", "      return IYearn(c).withdraw(a) >= 0;", "    } else if (p == uint8(Protocols.Aave)) {", "      // Aave v2 docs state that withraw returns uint256", "      // TODO explain the withdraw args", "      return IAave(aaveAddr).withdraw(u, a, address(this)) >= 0;", "    } else if (p == uint8(Protocols.Euler)) {", "      // Euler withdraw is void", "      // TODO explain the 0", "      IEuler(c).withdraw(0, a);", "      return true;", "    } else {", "      // we will allow protocol[0] to also function as a catchall for Erc4626", "      return IErc4626(c).withdraw(a, address(this), address(this)) >= 0;", "    }", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function rebalance(Pool storage pool, TimeswapV2PoolRebalanceParam memory param, uint256 transactionFee, uint256 protocolFee) external returns (uint256 long0Amount, uint256 long1Amount) {", "        if (pool.liquidity == 0) Error.requireLiquidity();", "", "        // No need to update short fee growth.", "", "        uint256 longFees;", "        if (param.isLong0ToLong1) {", "            if (param.transaction == TimeswapV2PoolRebalance.GivenLong0) {", "                (long1Amount, longFees) = ConstantSum.calculateGivenLongIn(param.strike, long0Amount = param.delta, transactionFee, true);", "", "                if (long1Amount == 0) Error.zeroOutput();", "", "                pool.long1Balance -= (long1Amount + longFees);", "            } else if (param.transaction == TimeswapV2PoolRebalance.GivenLong1) {", "                uint256 long1AmountAdjustFees = FeeCalculation.removeFees(pool.long0Balance, transactionFee);", "", "                if ((long1Amount = param.delta) == long1AmountAdjustFees) {", "                    long0Amount = ConstantSum.calculateGivenLongOutAlreadyAdjustFees(param.strike, pool.long1Balance, true);", "", "                    longFees = pool.long1Balance.unsafeSub(long1Amount);", "                    pool.long1Balance = 0;", "                } else {", "                    (long0Amount, longFees) = ConstantSum.calculateGivenLongOut(param.strike, long1Amount, transactionFee, true);", "", "                    pool.long1Balance -= (long1Amount + longFees);", "                }", "", "                if (long0Amount == 0) Error.zeroOutput();", "            }", "", "            pool.long0Balance += long0Amount;", "", "            (pool.long1FeeGrowth, pool.long1ProtocolFees) = FeeCalculation.update(pool.liquidity, pool.long1FeeGrowth, pool.long1ProtocolFees, longFees, protocolFee);", "        } else {", "            if (param.transaction == TimeswapV2PoolRebalance.GivenLong0) {", "                uint256 long0AmountAdjustFees = FeeCalculation.removeFees(pool.long0Balance, transactionFee);", "", "                if ((long0Amount = param.delta) == long0AmountAdjustFees) {", "                    long1Amount = ConstantSum.calculateGivenLongOutAlreadyAdjustFees(param.strike, pool.long0Balance, false);", "", "                    longFees = pool.long0Balance.unsafeSub(long0Amount);", "                    pool.long0Balance = 0;", "                } else {", "                    (long1Amount, longFees) = ConstantSum.calculateGivenLongOut(param.strike, long0Amount, transactionFee, false);", "", "                    pool.long0Balance -= (long0Amount + longFees);", "                }", "", "                if (long1Amount == 0) Error.zeroOutput();", "            } else if (param.transaction == TimeswapV2PoolRebalance.GivenLong1) {", "                (long0Amount, longFees) = ConstantSum.calculateGivenLongIn(param.strike, long1Amount = param.delta, transactionFee, false);", "", "                if (long0Amount == 0) Error.zeroOutput();", "", "                pool.long0Balance -= (long0Amount + longFees);", "            }", "", "            pool.long1Balance += long1Amount;", "", "            (pool.long0FeeGrowth, pool.long0ProtocolFees) = FeeCalculation.update(pool.liquidity, pool.long0FeeGrowth, pool.long0ProtocolFees, longFees, protocolFee);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function setSafeCollateralRatio(address pool, uint256 newRatio) external checkRole(TIMELOCK) {", "        if(IVault(pool).vaultType() == 0) {", "            require(newRatio >= 160 * 1e18, \"eUSD vault safe collateralRatio should more than 160%\");", "        } else {", "            require(newRatio >= vaultBadCollateralRatio[pool] + 1e19, \"PeUSD vault safe collateralRatio should more than bad collateralRatio\");", "        }", "        vaultSafeCollateralRatio[pool] = newRatio;", "        emit SafeCollateralRatioChanged(pool, newRatio);", "    }"], "ner_tags": [0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _globalAccrue(GlobalState storage globalState, ERC20 producerToken)", "        internal", "    {", "        uint256 totalSupply = producerToken.totalSupply();", "        uint256 lastUpdate = globalState.lastUpdate;", "        uint256 lastSupply = globalState.lastSupply;", "", "        // Calculate rewards, the product of seconds elapsed and last supply", "        // Only calculate and update states when needed", "        if (block.timestamp != lastUpdate || totalSupply != lastSupply) {", "            uint256 rewards = globalState.rewards +", "                (block.timestamp - lastUpdate) *", "                lastSupply;", "", "            globalState.lastUpdate = block.timestamp.safeCastTo32();", "            globalState.lastSupply = totalSupply.safeCastTo224();", "            globalState.rewards = rewards;", "", "            emit GlobalAccrue(", "                producerToken,", "                block.timestamp,", "                totalSupply,", "                rewards", "            );", "        }", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function gib(address to, uint256 assetAmount) external nonReentrant requiresLocalOrMasterAuth {", "        emit SafeGibbed(msg.sender, to, assetAmount);", "", "        // Withdraw the specified amount of assets from the Turbo Fuse Pool.", "        require(assetTurboCToken.redeemUnderlying(assetAmount) == 0, \"REDEEM_FAILED\");", "", "        // Transfer the assets to the authorized caller.", "        asset.safeTransfer(to, assetAmount);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _afterTokenTransfer(address, address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory) internal virtual override {", "        for (uint256 i; i < ids.length; ) {", "            if (amounts[i] != 0) _removeTokenEnumeration(from, to, ids[i], amounts[i]);", "", "            unchecked {", "                ++i;", "            }", "        }", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function mint(address onBehalfOf, uint256 amount) external {", "        require(onBehalfOf != address(0), \"MINT_TO_THE_ZERO_ADDRESS\");", "        require(amount > 0, \"ZERO_MINT\");", "        _mintEUSD(msg.sender, onBehalfOf, amount, getAssetPrice());", "    }"], "ner_tags": [1, 0, 0, 0, 0]}
{"tokens": ["    function reduceDebt(", "        uint256 _communityID,", "        address _project,", "        uint256 _repayAmount,", "        bytes memory _details", "    ) external virtual override whenNotPaused {", "        // Revert if sender is not _communityID owner (lender)", "        require(", "            _msgSender() == _communities[_communityID].owner,", "            \"Community::!Owner\"", "        );", "", "        // Internal call to reduce debt", "        _reduceDebt(_communityID, _project, _repayAmount, _details);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function _withdrawFromYieldPool(", "    address _asset,", "    uint256 _amount,", "    address _to", "  ) internal override returns (uint256) {", "    address LIDO = _addressesProvider.getAddress('LIDO');", "    if (_asset == address(0)) {", "      // Case of ETH withdraw request from user, so exchange stETH -> ETH via curve", "      uint256 receivedETHAmount = CurveswapAdapter.swapExactTokensForTokens(", "        _addressesProvider,", "        _addressesProvider.getAddress('STETH_ETH_POOL'),", "        LIDO,", "        ETH,", "        _amount,", "        200", "      );", "", "      // send ETH to user", "      (bool sent, bytes memory data) = address(_to).call{value: receivedETHAmount}('');", "      return receivedETHAmount;", "      require(sent, Errors.VT_COLLATERAL_WITHDRAW_INVALID);", "    } else {", "      // Case of stETH withdraw request from user, so directly send", "      require(_asset == LIDO, Errors.VT_COLLATERAL_WITHDRAW_INVALID);", "      IERC20(LIDO).safeTransfer(_to, _amount);", "    }", "    return _amount;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _updateDAORevenueCommission(uint256 _commissionPercentage) internal {", "        require(_commissionPercentage <= MODULO, \"Invalid commission\");", "", "        emit DAOCommissionUpdated(daoCommissionPercentage, _commissionPercentage);", "", "        daoCommissionPercentage = _commissionPercentage;", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function _depositFor(address _recipient, uint256 _amount)", "        internal", "        nonReentrant", "    {", "        require(_recipient != address(0), \"Address 0\");", "        require(_amount != 0, \"Amount 0\");", "        require(!pausedDeposit, \"pausedDeposit\"); // dev: deposits are paused", "", "        uint256 _pool = balance();", "        uint256 _before = token.balanceOf(address(this));", "        token.safeTransferFrom(msg.sender, address(this), _amount);", "        uint256 _after = token.balanceOf(address(this));", "        _mintSharesFor(_recipient, _after - _before, _pool);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0]}
{"tokens": ["    function areOperatorsImported(bytes32[] calldata names, Operator[] calldata destinations)", "        external", "        view", "        override", "        returns (bool)", "    {", "        uint256 namesLength = names.length;", "        require(namesLength == destinations.length, \"OR: INPUTS_LENGTH_MUST_MATCH\");", "        for (uint256 i = 0; i < namesLength; i++) {", "            if (", "                operators[names[i]].implementation != destinations[i].implementation &&", "                operators[names[i]].selector != destinations[i].selector", "            ) {", "                return false;", "            }", "        }", "        return true;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function configureDependencies() external override returns (Keycode[] memory dependencies) {", "        dependencies = new Keycode[](2);", "        dependencies[0] = toKeycode(\"INSTR\");", "        dependencies[1] = toKeycode(\"VOTES\");", "", "        INSTR = OlympusInstructions(getModuleAddress(dependencies[0]));", "        VOTES = OlympusVotes(getModuleAddress(dependencies[1]));", "    }"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["    function swapAndStartBridgeTokensViaCBridge(", "        LiFiData memory _lifiData,", "        LibSwap.SwapData[] calldata _swapData,", "        CBridgeData memory _cBridgeData", "    ) public payable {", "        if (_cBridgeData.token != address(0)) {", "            uint256 _fromTokenBalance = LibAsset.getOwnBalance(_cBridgeData.token);", "", "            // Swap", "            _executeSwaps(_lifiData, _swapData);", "", "            uint256 _postSwapBalance = LibAsset.getOwnBalance(_cBridgeData.token) - _fromTokenBalance;", "", "            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");", "", "            _cBridgeData.amount = _postSwapBalance;", "        } else {", "            uint256 _fromBalance = address(this).balance;", "", "            // Swap", "            _executeSwaps(_lifiData, _swapData);", "", "            uint256 _postSwapBalance = address(this).balance - _fromBalance;", "", "            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");", "", "            _cBridgeData.amount = _postSwapBalance;", "        }", "", "        _startBridge(_cBridgeData);", "", "        emit LiFiTransferStarted(", "            _lifiData.transactionId,", "            _lifiData.integrator,", "            _lifiData.referrer,", "            _lifiData.sendingAssetId,", "            _lifiData.receivingAssetId,", "            _lifiData.receiver,", "            _lifiData.amount,", "            _lifiData.destinationChainId,", "            block.timestamp", "        );", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _transfer(", "        TokenType tokenType,", "        address token,", "        address payable recipient,", "        uint256 amount", "    )", "        private", "    {", "        bytes32 balanceId = _getBalanceId(tokenType, token);", "        // Reduce stored token balance.", "        _storedBalances[balanceId] -= amount;", "        if (tokenType == TokenType.Native) {", "            recipient.transferEth(amount);", "        } else {", "            assert(tokenType == TokenType.Erc20);", "            IERC20(token).compatTransfer(recipient, amount);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["    function finalizePendingNFTValueETH(uint256 _nftIndex)", "        external", "        validNFTIndex(_nftIndex)", "    {", "        uint256 pendingValue = pendingNFTValueETH[_nftIndex];", "        require(pendingValue > 0, \"no_pending_value\");", "        uint256 toLockJpeg = (((pendingValue *", "            _ethPriceUSD() *", "            settings.creditLimitRate.numerator) /", "            settings.creditLimitRate.denominator) *", "            settings.valueIncreaseLockRate.numerator) /", "            settings.valueIncreaseLockRate.denominator /", "            _jpegPriceUSD();", "", "        //lock JPEG using JPEGLock", "        jpegLocker.lockFor(msg.sender, _nftIndex, toLockJpeg);", "", "        nftTypes[_nftIndex] = CUSTOM_NFT_HASH;", "        nftValueETH[_nftIndex] = pendingValue;", "        //clear pending value", "        pendingNFTValueETH[_nftIndex] = 0;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _doTransferOut(address payable to, uint256 amount) internal override {", "        to.transfer(amount);", "    }"], "ner_tags": [0, 1, 0]}
{"tokens": ["    function getPastDelegate(address account, uint256 blockNumber)", "        public", "        view", "        returns (address)", "    {", "        require(", "            blockNumber < block.number,", "            \"hPAL: invalid blockNumber\"", "        );", "", "        // no checkpoints written", "        uint256 nbCheckpoints = delegateCheckpoints[account].length;", "        if (nbCheckpoints == 0) return address(0);", "", "        // last checkpoint check", "        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {", "            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;", "        }", "", "        // no checkpoint old enough", "        if (delegateCheckpoints[account][0].fromBlock > blockNumber) {", "            return address(0);", "        }", "", "        uint256 high = nbCheckpoints - 1; // last checkpoint already checked", "        uint256 low = 0;", "        uint256 mid;", "        while (low < high) {", "            mid = Math.average(low, high);", "            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {", "                return delegateCheckpoints[account][mid].delegate;", "            }", "            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {", "                high = mid;", "            } else {", "                low = mid + 1;", "            }", "        }", "        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function redeem(uint256 principalAmount, address receiver, address holder) external override returns (uint256 underlyingAmount){", "        // If maturity is not yet reached", "        if (block.timestamp < maturity) { revert Maturity(maturity); }", "        // some 5095 tokens may have custody of underlying and can can just burn PTs and transfer underlying out, while others rely on external custody", "        if (holder == msg.sender) {", "            return redeemer.authRedeem(protocol, underlying, maturity, msg.sender, receiver, principalAmount);", "        }", "        else {", "            uint256 allowed = allowance[holder][msg.sender];", "            if (allowed >= principalAmount) { revert Approvals(allowed, principalAmount); }", "            allowance[holder][msg.sender] -= principalAmount;  ", "            return redeemer.authRedeem(protocol, underlying, maturity, holder, receiver, principalAmount);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0]}
{"tokens": ["    function forceDeployOnAddresses(ForceDeployment[] calldata _deployments) external payable {", "        require(msg.sender == FORCE_DEPLOYER, \"Can only be called by FORCE_DEPLOYER_CONTRACT\");", "", "        uint256 deploymentsLength = _deployments.length;", "        // We need to ensure that the `value` provided by the call is enough to provide `value`", "        // for all of the deployments", "        uint256 sumOfValues = 0;", "        for (uint256 i = 0; i < deploymentsLength; ++i) {", "            sumOfValues += _deployments[i].value;", "        }", "        require(msg.value == sumOfValues, \"`value` provided is not equal to the combined `value`s of deployments\");", "", "        for (uint256 i = 0; i < deploymentsLength; ++i) {", "            this.forceDeployOnAddress{value: _deployments[i].value}(_deployments[i], msg.sender);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["    function _executeKeeperPoolWeight(", "        bytes32 key,", "        address pool,", "        bool isWeightManager", "    ) internal returns (bool) {", "        IKeeperGauge(_keeperGauges.get(pool)).poolCheckpoint();", "        totalKeeperPoolWeight = totalKeeperPoolWeight - currentUInts256[key] + pendingUInts256[key];", "        totalKeeperPoolWeight = totalKeeperPoolWeight > 0 ? totalKeeperPoolWeight : 0;", "        isWeightManager ? _setConfig(key, pendingUInts256[key]) : _executeUInt256(key);", "        emit NewKeeperWeight(pool, currentUInts256[key]);", "        return true;", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function compare(bytes memory self, uint offset, uint len, bytes memory other, uint otheroffset, uint otherlen) internal pure returns (int) {", "        uint shortest = len;", "        if (otherlen < len)", "        shortest = otherlen;", "", "        uint selfptr;", "        uint otherptr;", "", "        assembly {", "            selfptr := add(self, add(offset, 32))", "            otherptr := add(other, add(otheroffset, 32))", "        }", "        for (uint idx = 0; idx < shortest; idx += 32) {", "            uint a;", "            uint b;", "            assembly {", "                a := mload(selfptr)", "                b := mload(otherptr)", "            }", "            if (a != b) {", "                // Mask out irrelevant bytes and check again", "                uint mask;", "                if (shortest > 32) {", "                    mask = type(uint256).max;", "                } else {", "                    mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);", "                }", "                int diff = int(a & mask) - int(b & mask);", "                if (diff != 0)", "                return diff;", "            }", "            selfptr += 32;", "            otherptr += 32;", "        }", "", "        return int(len) - int(otherlen);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function reweight(address[] calldata _updatedAssets, uint8[] calldata _updatedWeights) external override {", "        require(", "            _updatedAssets.length > 1 &&", "                _updatedWeights.length == _updatedAssets.length &&", "                _updatedAssets.length <= IIndexRegistry(registry).maxComponents(),", "            \"ManagedIndex: INVALID\"", "        );", "", "        uint virtualEvaluationInBase;", "        IPhuturePriceOracle oracle = IPhuturePriceOracle(IIndexRegistry(registry).priceOracle());", "        for (uint i; i < assets.length(); ++i) {", "            uint priceAssetPerBaseInUQ = oracle.refreshedAssetPerBaseInUQ(assets.at(i));", "            uint availableAssets = IvToken(IvTokenFactory(vTokenFactory).createOrReturnVTokenOf(assets.at(i)))", "                .assetBalanceOf(address(this));", "            virtualEvaluationInBase += availableAssets.mulDiv(FixedPoint112.Q112, priceAssetPerBaseInUQ);", "        }", "", "        IOrderer orderer = IOrderer(IIndexRegistry(registry).orderer());", "        uint orderId = orderer.placeOrder();", "", "        uint _totalWeight = IndexLibrary.MAX_WEIGHT;", "", "        for (uint i; i < _updatedAssets.length; ++i) {", "            address asset = _updatedAssets[i];", "            require(asset != address(0), \"ManagedIndex: ZERO\");", "", "            uint8 newWeight = _updatedWeights[i];", "", "            if (i > 0) {", "                // makes sure that there are no duplicate assets", "                require(_updatedAssets[i - 1] < asset, \"ManagedIndex: SORT\");", "            }", "", "            if (newWeight > 0) {", "                require(IAccessControl(registry).hasRole(ASSET_ROLE, asset), \"ManagedIndex: INVALID_ASSET\");", "                assets.add(asset);", "                inactiveAssets.remove(asset);", "", "                uint8 prevWeight = weightOf[asset];", "                if (prevWeight != newWeight) {", "                    emit UpdateAnatomy(asset, newWeight);", "                }", "", "                _totalWeight = _totalWeight + newWeight - prevWeight;", "                weightOf[asset] = newWeight;", "", "                uint amountInBase = (virtualEvaluationInBase * weightOf[asset]) / IndexLibrary.MAX_WEIGHT;", "                uint amountInAsset = amountInBase.mulDiv(oracle.refreshedAssetPerBaseInUQ(asset), FixedPoint112.Q112);", "                (uint newShares, uint oldShares) = IvToken(IvTokenFactory(vTokenFactory).createOrReturnVTokenOf(asset))", "                    .shareChange(address(this), amountInAsset);", "", "                if (newShares > oldShares) {", "                    orderer.addOrderDetails(orderId, asset, newShares - oldShares, IOrderer.OrderSide.Buy);", "                } else if (oldShares > newShares) {", "                    orderer.addOrderDetails(orderId, asset, oldShares - newShares, IOrderer.OrderSide.Sell);", "                }", "            } else {", "                require(assets.remove(asset), \"ManagedIndex: INVALID\");", "                inactiveAssets.add(asset);", "", "                _totalWeight -= weightOf[asset];", "", "                delete weightOf[asset];", "", "                emit UpdateAnatomy(asset, 0);", "            }", "        }", "        address[] memory _inactiveAssets = inactiveAssets.values();", "        for (uint i; i < _inactiveAssets.length; ++i) {", "            uint shares = IvToken(IvTokenFactory(vTokenFactory).vTokenOf(_inactiveAssets[i])).balanceOf(address(this));", "            if (shares > 0) {", "                orderer.addOrderDetails(orderId, _inactiveAssets[i], shares, IOrderer.OrderSide.Sell);", "            } else {", "                inactiveAssets.remove(_inactiveAssets[i]);", "            }", "        }", "        require(_totalWeight == IndexLibrary.MAX_WEIGHT, \"ManagedIndex: MAX\");", "    }"], "ner_tags": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function removeAddress(address _address) external onlyOwner {", "        uint256 contractsLength = contracts.length;", "        for (uint256 i; i < contractsLength; ) {", "            if (contracts[i] == _address) {", "                delete contracts[i];", "            }", "            unchecked {", "                ++i;", "            }", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _harvest() internal override returns (TokenAmount[] memory harvested) {", "        uint256 auraBalBalanceBefore = AURABAL.balanceOf(address(this));", "", "        // Claim auraBAL from locker", "        LOCKER.getReward(address(this));", "", "        harvested = new TokenAmount[](1);", "        harvested[0].token = address(AURA);", "", "        uint256 auraBalEarned = AURABAL.balanceOf(address(this)).sub(auraBalBalanceBefore);", "        // auraBAL -> BAL/ETH BPT -> WETH -> AURA", "        if (auraBalEarned > 0) {", "            // Common structs for swaps", "            IBalancerVault.SingleSwap memory singleSwap;", "            IBalancerVault.FundManagement memory fundManagement = IBalancerVault.FundManagement({", "                sender: address(this),", "                fromInternalBalance: false,", "                recipient: payable(address(this)),", "                toInternalBalance: false", "            });", "", "            // Swap auraBal -> BAL/ETH BPT", "            singleSwap = IBalancerVault.SingleSwap({", "                poolId: AURABAL_BALETH_BPT_POOL_ID,", "                kind: IBalancerVault.SwapKind.GIVEN_IN,", "                assetIn: IAsset(address(AURABAL)),", "                assetOut: IAsset(address(BALETH_BPT)),", "                amount: auraBalEarned,", "                userData: new bytes(0)", "            });", "            uint256 balEthBptEarned = BALANCER_VAULT.swap(singleSwap, fundManagement, 0, type(uint256).max);", "", "            // Withdraw BAL/ETH BPT -> WETH", "            uint256 wethBalanceBefore = WETH.balanceOf(address(this));", "", "            IAsset[] memory assets = new IAsset[](2);", "            assets[0] = IAsset(address(BAL));", "            assets[1] = IAsset(address(WETH));", "            IBalancerVault.ExitPoolRequest memory exitPoolRequest = IBalancerVault.ExitPoolRequest({", "                assets: assets,", "                minAmountsOut: new uint256[](2),", "                userData: abi.encode(ExitKind.EXACT_BPT_IN_FOR_ONE_TOKEN_OUT, balEthBptEarned, BPT_WETH_INDEX),", "                toInternalBalance: false", "            });", "            BALANCER_VAULT.exitPool(BAL_ETH_POOL_ID, address(this), payable(address(this)), exitPoolRequest);", "", "            // Swap WETH -> AURA", "            uint256 wethEarned = WETH.balanceOf(address(this)).sub(wethBalanceBefore);", "            singleSwap = IBalancerVault.SingleSwap({", "                poolId: AURA_ETH_POOL_ID,", "                kind: IBalancerVault.SwapKind.GIVEN_IN,", "                assetIn: IAsset(address(WETH)),", "                assetOut: IAsset(address(AURA)),", "                amount: wethEarned,", "                userData: new bytes(0)", "            });", "            harvested[0].amount = BALANCER_VAULT.swap(singleSwap, fundManagement, 0, type(uint256).max);", "        }", "", "        _reportToVault(harvested[0].amount);", "        if (harvested[0].amount > 0) {", "            _deposit(harvested[0].amount);", "        }", "    }"], "ner_tags": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function getPFP(uint256 _pfpID) public view returns (address nftContract, uint256 nftID) {", "        if (_ownerOf[_pfpID] == address(0)) revert TokenNotMinted(_pfpID);", "        ProfilePictureData storage pictureData = pfp[_pfpID];", "        nftContract = pictureData.nftContract;", "        nftID = pictureData.nftID;", "        uint256 cidNFTID = cidNFT.getPrimaryCIDNFT(subprotocolName, _pfpID);", "        IAddressRegistry addressRegistry = cidNFT.addressRegistry();", "        if (cidNFTID == 0 || addressRegistry.getAddress(cidNFTID) != ERC721(nftContract).ownerOf(nftID)) {", "            nftContract = address(0);", "            nftID = 0; // Strictly not needed because nftContract has to be always checked, but reset nevertheless to 0", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function swap(bytes32 transactionId, SwapData calldata _swapData) internal {", "        uint256 fromAmount = _swapData.fromAmount;", "        uint256 toAmount = LibAsset.getOwnBalance(_swapData.receivingAssetId);", "        address fromAssetId = _swapData.sendingAssetId;", "        if (!LibAsset.isNativeAsset(fromAssetId) && LibAsset.getOwnBalance(fromAssetId) < fromAmount) {", "            LibAsset.transferFromERC20(fromAssetId, msg.sender, address(this), fromAmount);", "        }", "", "        if (!LibAsset.isNativeAsset(fromAssetId)) {", "            LibAsset.approveERC20(IERC20(fromAssetId), _swapData.approveTo, fromAmount);", "        }", "", "        // solhint-disable-next-line avoid-low-level-calls", "        (bool success, bytes memory res) = _swapData.callTo.call{ value: msg.value }(_swapData.callData);", "        if (!success) {", "            string memory reason = LibUtil.getRevertMsg(res);", "            revert(reason);", "        }", "", "        toAmount = LibAsset.getOwnBalance(_swapData.receivingAssetId) - toAmount;", "        emit AssetSwapped(", "            transactionId,", "            _swapData.callTo,", "            _swapData.sendingAssetId,", "            _swapData.receivingAssetId,", "            fromAmount,", "            toAmount,", "            block.timestamp", "        );", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function mulDivDown(", "        uint256 x,", "        uint256 y,", "        uint256 denominator", "    ) internal pure returns (uint256 z) {", "        /// @solidity memory-safe-assembly", "        assembly {", "            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))", "            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {", "                revert(0, 0)", "            }", "", "            // Divide x * y by the denominator.", "            z := div(mul(x, y), denominator)", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _addGauge(address gauge) internal returns (uint112 weight) {", "        bool newAdd = _gauges.add(gauge);", "        bool previouslyDeprecated = _deprecatedGauges.remove(gauge);", "        // add and fail loud if zero address or already present and not deprecated", "        if (gauge == address(0) || !(newAdd || previouslyDeprecated)) revert InvalidGaugeError();", "", "        uint32 currentCycle = _getGaugeCycleEnd();", "", "        // Check if some previous weight exists and re-add to total. Gauge and user weights are preserved.", "        weight = _getGaugeWeight[gauge].currentWeight;", "        if (weight > 0) {", "            _writeGaugeWeight(_totalWeight, _add, weight, currentCycle);", "        }", "", "        emit AddGauge(gauge);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": ["    function _approveStakerVaultSpendingLpTokens() internal {", "        address staker_ = address(staker);", "        address lpToken_ = address(lpToken);", "        if (staker_ == address(0) || lpToken_ == address(0)) return;", "        IERC20(lpToken_).safeApprove(staker_, type(uint256).max);", "    }"], "ner_tags": [0, 0, 0, 0, 1, 0]}
{"tokens": ["    function recordOvercommittedBeaconChainETH(address overcommittedPodOwner, uint256 beaconChainETHStrategyIndex, uint256 amount)", "        external", "        onlyEigenPodManager", "        nonReentrant", "    {", "        // get `overcommittedPodOwner`'s shares in the enshrined beacon chain ETH strategy", "        uint256 userShares = stakerStrategyShares[overcommittedPodOwner][beaconChainETHStrategy];", "        // if the amount exceeds the user's shares, then record it as an amount to be \"paid off\" when the user completes a withdrawal", "        if (amount > userShares) {", "            uint256 debt = amount - userShares;", "            beaconChainETHSharesToDecrementOnWithdrawal[overcommittedPodOwner] += debt;", "            amount -= debt;", "        }", "        // removes shares for the enshrined beacon chain ETH strategy", "        if (amount != 0) {", "            _removeShares(overcommittedPodOwner, beaconChainETHStrategyIndex, beaconChainETHStrategy, amount);            ", "        }", "        // create array wrappers for call to DelegationManager", "        IStrategy[] memory strategies = new IStrategy[](1);", "        strategies[0] = beaconChainETHStrategy;", "        uint256[] memory shareAmounts = new uint256[](1);", "        shareAmounts[0] = amount;", "        // modify delegated shares accordingly, if applicable", "        delegation.decreaseDelegatedShares(overcommittedPodOwner, strategies, shareAmounts);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function initialize(address _controller) external onlyImpl {", "        Managed._initialize(_controller);", "    }"], "ner_tags": [1, 0, 0]}
{"tokens": ["    function getCurrentOraclePrice() public view override returns (uint256) {", "        int256 oraclePriceInt = oraclePrice.toInt256();", "", "        int256 timeDelta = Math.min(block.timestamp - startTime, TIMEFRAME).toInt256();", "        int256 pricePercentageChange = oraclePriceInt * monthlyChangeRateBasisPoints / Constants.BP_INT;", "        int256 priceDelta = pricePercentageChange * timeDelta / TIMEFRAME.toInt256();", "", "        return (oraclePriceInt + priceDelta).toUint256();", "    }"], "ner_tags": [0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function distributeRewards() external override {", "        uint8 poolId = VaultProxy(payable(address(this))).poolId();", "        uint256 validatorId = VaultProxy(payable(address(this))).id();", "        IStaderConfig staderConfig = VaultProxy(payable(address(this))).staderConfig();", "        uint256 totalRewards = address(this).balance;", "        if (!staderConfig.onlyOperatorRole(msg.sender) && totalRewards > staderConfig.getRewardsThreshold()) {", "            emit DistributeRewardFailed(totalRewards, staderConfig.getRewardsThreshold());", "            revert InvalidRewardAmount();", "        }", "        if (totalRewards == 0) {", "            revert NotEnoughRewardToDistribute();", "        }", "        (uint256 userShare, uint256 operatorShare, uint256 protocolShare) = IPoolUtils(staderConfig.getPoolUtils())", "            .calculateRewardShare(poolId, totalRewards);", "", "        // Distribute rewards", "        IStaderStakePoolManager(staderConfig.getStakePoolManager()).receiveWithdrawVaultUserShare{value: userShare}();", "        UtilLib.sendValue(payable(staderConfig.getStaderTreasury()), protocolShare);", "        IOperatorRewardsCollector(staderConfig.getOperatorRewardsCollector()).depositFor{value: operatorShare}(", "            getOperatorAddress(poolId, validatorId, staderConfig)", "        );", "        emit DistributedRewards(userShare, operatorShare, protocolShare);", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    constructor(address _cidNFT, string memory _subprotocolName) ERC721(\"Profile Picture\", \"PFP\") {", "        cidNFT = ICidNFT(_cidNFT);", "        subprotocolName = _subprotocolName;", "        if (block.chainid == 7700) {", "            // Register CSR on Canto mainnnet", "            Turnstile turnstile = Turnstile(0xEcf044C5B4b867CFda001101c617eCd347095B44);", "            turnstile.register(tx.origin);", "        }", "    }"], "ner_tags": [0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function createOpenEdition(OpenEdition.Sale calldata sale) external returns (address clone) {", "        require(IEscher721(sale.edition).hasRole(bytes32(0x00), msg.sender), \"NOT AUTHORIZED\");", "        require(sale.startTime >= block.timestamp, \"START TIME IN PAST\");", "        require(sale.endTime > sale.startTime, \"END TIME BEFORE START\");", "", "        clone = implementation.clone();", "        OpenEdition(clone).initialize(sale);", "", "        emit NewOpenEditionContract(msg.sender, sale.edition, clone, sale);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function mint(", "    address to,", "    uint256 collateral,", "    bytes calldata data", "  )", "    external", "    override", "    nonReentrant", "    returns (uint256 shares)", "  {", "    _accrueInterest();", "", "    uint256 liquidity = convertCollateralToLiquidity(collateral);", "    shares = convertLiquidityToShare(liquidity);", "", "    if (collateral == 0 || liquidity == 0 || shares == 0) revert InputError();", "    if (liquidity > totalLiquidity) revert CompleteUtilizationError();", "    // next check is for the case when liquidity is borrowed but then was completely accrued", "    if (totalSupply > 0 && totalLiquidityBorrowed == 0) revert CompleteUtilizationError();", "", "    totalLiquidityBorrowed += liquidity;", "    (uint256 amount0, uint256 amount1) = burn(to, liquidity);", "    _mint(to, shares);", "", "    uint256 balanceBefore = Balance.balance(token1);", "    IMintCallback(msg.sender).mintCallback(collateral, amount0, amount1, liquidity, data);", "    uint256 balanceAfter = Balance.balance(token1);", "", "    if (balanceAfter < balanceBefore + collateral) revert InsufficientInputError();", "", "    emit Mint(msg.sender, collateral, shares, liquidity, to);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["  function _transferFromEscrow(", "    address nftContract,", "    uint256 tokenId,", "    address recipient,", "    address seller", "  ) internal virtual override {", "    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];", "    if (auctionId != 0) {", "      ReserveAuction storage auction = auctionIdToAuction[auctionId];", "      if (auction.endTime == 0) {", "        // The auction has not received any bids yet so it may be invalided.", "", "        if (auction.seller != seller) {", "          // The account trying to transfer the NFT is not the current owner.", "          revert NFTMarketReserveAuction_Not_Matching_Seller(auction.seller);", "        }", "", "        // Remove the auction.", "        delete nftContractToTokenIdToAuctionId[nftContract][tokenId];", "        delete auctionIdToAuction[auctionId];", "", "        emit ReserveAuctionInvalidated(auctionId);", "      } else {", "        // If the auction has started, the highest bidder will be the new owner.", "", "        if (auction.bidder != seller) {", "          revert NFTMarketReserveAuction_Not_Matching_Seller(auction.bidder);", "        }", "", "        // Finalization will revert if the auction has not yet ended.", "        _finalizeReserveAuction(auctionId, false);", "", "        // Finalize includes the transfer, so we are done here.", "        return;", "      }", "    }", "", "    super._transferFromEscrow(nftContract, tokenId, recipient, seller);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": ["  function emptyVaultOperation(", "    IERC20 vaultCollateral,", "    uint256 amount,", "    uint256 flashloanRepayAmount,", "    bytes memory params", "  ) internal {", "    // Use par to repay debt", "    (uint256 vaultId, bytes memory dexTxData, uint dexIndex) = abi.decode(params, (uint256, bytes, uint));", "", "    aggregatorSwap(dexIndex, vaultCollateral, amount, dexTxData); // swap assets for par to repay back loan", "", "    IERC20 par = IERC20(a.stablex());", "    par.approve(address(a.core()), par.balanceOf(address(this)));", "", "    // Repay the par debt", "    a.core().repayAll(vaultId);", "    uint256 vaultBalance = a.vaultsData().vaultCollateralBalance(vaultId);", "    // Withdraw all collateral", "    a.core().withdraw(vaultId, vaultBalance);", "", "    require(vaultCollateral.balanceOf(address(this)) >= flashloanRepayAmount, \"SV101\");", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function getCollateralRatio()", "        internal", "        view", "        returns (", "            uint64 collatRatio,", "            uint256 stablecoinsIssued,", "            address[] memory tokens,", "            uint256[] memory balances,", "            uint256[] memory subCollateralsTracker", "        )", "    {", "        TransmuterStorage storage ts = s.transmuterStorage();", "        uint256 totalCollateralization;", "        address[] memory collateralList = ts.collateralList;", "        uint256 collateralListLength = collateralList.length;", "        uint256 subCollateralsAmount;", "        // Building the `subCollateralsTracker` array which is useful when later sending the tokens as part of the", "        // redemption", "        subCollateralsTracker = new uint256[](collateralListLength);", "        for (uint256 i; i < collateralListLength; ++i) {", "            if (ts.collaterals[collateralList[i]].isManaged == 0) ++subCollateralsAmount;", "            else subCollateralsAmount += ts.collaterals[collateralList[i]].managerData.subCollaterals.length;", "            subCollateralsTracker[i] = subCollateralsAmount;", "        }", "        balances = new uint256[](subCollateralsAmount);", "        tokens = new address[](subCollateralsAmount);", "", "        {", "            uint256 countCollat;", "            for (uint256 i; i < collateralListLength; ++i) {", "                Collateral storage collateral = ts.collaterals[collateralList[i]];", "                uint256 collateralBalance; // Will be either the balance or the value of assets managed", "                if (collateral.isManaged > 0) {", "                    // If a collateral is managed, the balances of the sub-collaterals cannot be directly obtained by", "                    // calling `balanceOf` of the sub-collaterals", "                    uint256[] memory subCollateralsBalances;", "                    (subCollateralsBalances, collateralBalance) = LibManager.totalAssets(collateral.managerData.config);", "                    uint256 numSubCollats = subCollateralsBalances.length;", "                    for (uint256 k; k < numSubCollats; ++k) {", "                        tokens[countCollat + k] = address(collateral.managerData.subCollaterals[k]);", "                        balances[countCollat + k] = subCollateralsBalances[k];", "                    }", "                    countCollat += numSubCollats;", "                } else {", "                    collateralBalance = IERC20(collateralList[i]).balanceOf(address(this));", "                    tokens[countCollat] = collateralList[i];", "                    balances[countCollat++] = collateralBalance;", "                }", "                uint256 oracleValue = LibOracle.readRedemption(collateral.oracleConfig);", "                totalCollateralization +=", "                    (oracleValue * LibHelpers.convertDecimalTo(collateralBalance, collateral.decimals, 18)) /", "                    BASE_18;", "            }", "        }", "        // The `stablecoinsIssued` value need to be rounded up because it is then used as a divizer when computing", "        // the amount of stablecoins issued", "        stablecoinsIssued = uint256(ts.normalizedStables).mulDiv(ts.normalizer, BASE_27, Math.Rounding.Up);", "        if (stablecoinsIssued > 0)", "            collatRatio = uint64(totalCollateralization.mulDiv(BASE_9, stablecoinsIssued, Math.Rounding.Up));", "        else collatRatio = type(uint64).max;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["    function buyAllAmountWithETH(", "        ERC20 buy_gem,", "        uint256 buy_amt,", "        uint256 max_fill_amount,", "        uint256 expectedMarketFeeBPS", "    ) external payable returns (uint256 fill) {", "        address _weth = address(wethAddress);", "        uint256 _before = ERC20(_weth).balanceOf(address(this));", "        uint256 max_fill_withFee = max_fill_amount.add(", "            max_fill_amount.mul(expectedMarketFeeBPS).div(10000)", "        );", "        require(", "            msg.value >= max_fill_withFee,", "            \"must send as much ETH as max_fill_withFee\"", "        );", "        WETH9(wethAddress).deposit{value: max_fill_withFee}(); // Pay with native ETH -> WETH", "        // An amount in WETH", "        fill = RubiconMarket(RubiconMarketAddress).buyAllAmount(", "            buy_gem,", "            buy_amt,", "            ERC20(wethAddress),", "            max_fill_amount", "        );", "        ERC20(buy_gem).transfer(msg.sender, buy_amt);", "", "        uint256 _after = ERC20(_weth).balanceOf(address(this));", "        uint256 delta = _after - _before;", "", "        // Return unspent coins to sender", "        if (delta > 0) {", "            WETH9(wethAddress).withdraw(delta);", "            msg.sender.transfer(delta);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["    function fund(address[] calldata _recipient, uint256[] calldata _amount) external nonReentrant {", "        require(!initialised, \"initialised already\");", "", "        uint256 totalAmount = 0;", "        for (uint256 i = 0; i < _recipient.length; i++) {", "            uint256 amount = _amount[i];", "", "            totalLocked[_recipient[i]] += amount;", "            totalAmount += amount;", "", "            emit Funded(_recipient[i], amount);", "        }", "        rewardToken.safeTransferFrom(msg.sender, address(this), totalAmount);", "        initialised = true;", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function maxWithdraw(address owner) public view virtual returns (uint256) {", "        return convertToAssets(balanceOf[owner]);", "    }"], "ner_tags": [1, 0, 0]}
{"tokens": ["    function DOMAIN_SEPARATOR() external view returns (bytes32) {", "        return _domainSeparatorV4();", "    }"], "ner_tags": [1, 0, 0]}
{"tokens": ["    function setMarketPlace(address m) external authorized(admin) returns (bool) {", "        if (marketPlace != address(0)) {", "            revert Exists(marketPlace);", "        }", "        marketPlace = m;", "        return true;", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function harvest(uint256 minOutCurve) external onlyRole(STRATEGIST_ROLE) {", "        convexConfig.baseRewardPool.getReward(address(this), true);", "", "        //Prevent `Stack too deep` errors", "        {", "            DexConfig memory dex = dexConfig;", "            IERC20[] memory rewardTokens = strategyConfig.rewardTokens;", "            IERC20 _weth = weth;", "            for (uint256 i = 0; i < rewardTokens.length; i++) {", "                uint256 balance = rewardTokens[i].balanceOf(address(this));", "", "                if (balance > 0)", "                    //minOut is not needed here, we already have it on the Curve deposit", "                    _swapUniswapV2(", "                        dex.uniswapV2,", "                        rewardTokens[i],", "                        _weth,", "                        balance,", "                        0", "                    );", "            }", "", "            uint256 wethBalance = _weth.balanceOf(address(this));", "            require(wethBalance > 0, \"NOOP\");", "", "            //handle sending jpeg here", "", "            _weth.safeIncreaseAllowance(address(dex.uniswapV3), wethBalance);", "", "            //minOut is not needed here, we already have it on the Curve deposit", "            ISwapRouter.ExactInputParams memory params = ISwapRouter", "                .ExactInputParams(", "                    abi.encodePacked(weth, uint24(500), usdc),", "                    address(this),", "                    block.timestamp,", "                    wethBalance,", "                    0", "                );", "", "            dex.uniswapV3.exactInput(params);", "        }", "", "        StrategyConfig memory strategy = strategyConfig;", "        CurveConfig memory curve = curveConfig;", "", "        uint256 usdcBalance = usdc.balanceOf(address(this));", "", "        //take the performance fee", "        uint256 fee = (usdcBalance * performanceFee.numerator) /", "            performanceFee.denominator;", "        usdc.safeTransfer(strategy.controller.feeAddress(), fee);", "        usdcBalance -= fee;", "", "        uint256 pusdCurveBalance = curve.curve.balances(curve.pusdIndex);", "        //USDC has 6 decimals while PUSD has 18. We need to convert the USDC", "        //balance to 18 decimals to compare it with the PUSD balance", "        uint256 usdcCurveBalance = curve.curve.balances(curve.usdcIndex) *", "            10**12;", "", "        //The curve pool has 4 tokens, we are doing a single asset deposit with either USDC or PUSD", "        uint256[4] memory liquidityAmounts = [uint256(0), 0, 0, 0];", "        if (usdcCurveBalance > pusdCurveBalance) {", "            //if there's more USDC than PUSD in the pool, use USDC as collateral to mint PUSD", "            //and deposit it into the Curve pool", "            usdc.safeIncreaseAllowance(", "                address(strategy.usdcVault),", "                usdcBalance", "            );", "            strategy.usdcVault.deposit(usdcBalance);", "", "            //check the vault's credit limit, it should be 1:1 for USDC", "            uint256 toBorrow = strategy.usdcVault.getCreditLimit(usdcBalance);", "", "            strategy.usdcVault.borrow(toBorrow);", "            liquidityAmounts[curve.pusdIndex] = toBorrow;", "", "            pusd.safeIncreaseAllowance(address(curve.curve), toBorrow);", "        } else {", "            //if there's more PUSD than USDC in the pool, deposit USDC", "            liquidityAmounts[curve.usdcIndex] = usdcBalance;", "            usdc.safeIncreaseAllowance(address(curve.curve), usdcBalance);", "        }", "", "        curve.curve.add_liquidity(liquidityAmounts, minOutCurve);", "", "        uint256 wantBalance = balanceOfWant();", "", "        deposit();", "", "        earned += wantBalance;", "        emit Harvested(wantBalance);", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function moveFundsToUpgradedContract() external {", "        uint256 userWalletBalance = IYieldy(OLD_YIELDY_TOKEN).balanceOf(", "            msg.sender", "        );", "", "        IYieldy(OLD_YIELDY_TOKEN).transferFrom(", "            msg.sender,", "            address(this),", "            userWalletBalance", "        );", "", "        IStaking(OLD_CONTRACT).instantUnstake(false);", "", "        IStaking(NEW_CONTRACT).stake(userWalletBalance, msg.sender);", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function pay(PayParam calldata param)", "        external ", "        override ", "        lock ", "        returns (", "            uint128 assetIn, ", "            uint128 collateralOut", "        ) ", "    {", "        require(block.timestamp < param.maturity, 'E202');", "        require(param.owner != address(0), 'E201');", "        require(param.to != address(0), 'E201');", "        require(param.to != address(this), 'E204');", "        require(param.ids.length == param.assetsIn.length, 'E205');", "        require(param.ids.length == param.collateralsOut.length, 'E205');", "", "        Pool storage pool = pools[param.maturity];", "", "        Due[] storage dues = pool.dues[param.owner];", "        require(dues.length >= param.ids.length, 'E205');", "", "        for (uint256 i; i < param.ids.length;) {", "            Due storage due = dues[param.ids[i]];", "            require(due.startBlock != BlockNumber.get(), 'E207');", "            if (param.owner != msg.sender) require(param.collateralsOut[i] == 0, 'E213');", "            require(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303');", "            due.debt -= param.assetsIn[i];", "            due.collateral -= param.collateralsOut[i];", "            assetIn += param.assetsIn[i];", "            collateralOut += param.collateralsOut[i];", "            unchecked { ++i; }", "        }", "", "        pool.state.reserves.asset += assetIn;", "        pool.state.reserves.collateral -= collateralOut;", "", "        if (collateralOut != 0) collateral.safeTransfer(param.to, collateralOut);", "", "        if (assetIn != 0) Callback.pay(asset, assetIn, param.data);", "", "        emit Pay(", "            param.maturity, ", "            msg.sender, ", "            param.to, ", "            param.owner, ", "            param.ids, ", "            param.assetsIn, ", "            param.collateralsOut, ", "            assetIn, ", "            collateralOut", "        );", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    modifier isDisaster(uint256 marketIndex, uint256 epochEnd) {", "        address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);", "        if(", "            vaultsAddress.length != VAULTS_LENGTH", "            )", "            revert MarketDoesNotExist(marketIndex);", "", "        address vaultAddress = vaultsAddress[0];", "        Vault vault = Vault(vaultAddress);", "", "        if(vault.idExists(epochEnd) == false)", "            revert EpochNotExist();", "", "        if(", "            vault.strikePrice() < getLatestPrice(vault.tokenInsured())", "            )", "            revert PriceNotAtStrikePrice(getLatestPrice(vault.tokenInsured()));", "", "        if(", "            vault.idEpochBegin(epochEnd) > block.timestamp)", "            revert EpochNotStarted();", "", "        if(", "            block.timestamp > epochEnd", "            )", "            revert EpochExpired();", "        _;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["\tfunction distributeMultisigAllotment(", "\t\tuint256 allotment,", "\t\tVault vault,", "\t\tTokenGGP ggp", "\t) internal {", "\t\tMultisigManager mm = MultisigManager(getContractAddress(\"MultisigManager\"));", "", "\t\tuint256 enabledCount;", "\t\tuint256 count = mm.getCount();", "\t\taddress[] memory enabledMultisigs = new address[](count);", "", "\t\t// there should never be more than a few multisigs, so a loop should be fine here", "\t\tfor (uint256 i = 0; i < count; i++) {", "\t\t\t(address addr, bool enabled) = mm.getMultisig(i);", "\t\t\tif (enabled) {", "\t\t\t\tenabledMultisigs[enabledCount] = addr;", "\t\t\t\tenabledCount++;", "\t\t\t}", "\t\t}", "", "\t\t// Dirty hack to cut unused elements off end of return value (from RP)", "\t\t// solhint-disable-next-line no-inline-assembly", "\t\tassembly {", "\t\t\tmstore(enabledMultisigs, enabledCount)", "\t\t}", "", "\t\tuint256 tokensPerMultisig = allotment / enabledCount;", "\t\tfor (uint256 i = 0; i < enabledMultisigs.length; i++) {", "\t\t\tvault.withdrawToken(enabledMultisigs[i], ggp, tokensPerMultisig);", "\t\t}", "\t}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["    function deposit(uint256 _amount) public noContract(msg.sender) {", "        require(_amount > 0, \"INVALID_AMOUNT\");", "        uint256 balanceBefore = balance();", "        token.safeTransferFrom(msg.sender, address(this), _amount);", "        uint256 supply = totalSupply();", "        uint256 shares;", "        if (supply == 0) {", "            shares = _amount;", "        } else {", "            //balanceBefore can't be 0 if totalSupply is > 0", "            shares = (_amount * supply) / balanceBefore;", "        }", "        _mint(msg.sender, shares);", "", "        emit Deposit(msg.sender, _amount);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": ["  function _buyoutLien(", "    LienStorage storage s,", "    ILienToken.LienActionBuyout calldata params", "  ) internal returns (Stack[] memory newStack, Stack memory newLien) {", "    //the borrower shouldn't incur more debt from the buyout than they already owe", "    (, newLien) = _createLien(s, params.encumber);", "    if (", "      !s.ASTARIA_ROUTER.isValidRefinance({", "        newLien: params.encumber.lien,", "        position: params.position,", "        stack: params.encumber.stack", "      })", "    ) {", "      revert InvalidRefinance();", "    }", "", "    if (", "      s.collateralStateHash[params.encumber.lien.collateralId] == ACTIVE_AUCTION", "    ) {", "      revert InvalidState(InvalidStates.COLLATERAL_AUCTION);", "    }", "    (uint256 owed, uint256 buyout) = _getBuyout(", "      s,", "      params.encumber.stack[params.position]", "    );", "", "    if (params.encumber.lien.details.maxAmount < owed) {", "      revert InvalidBuyoutDetails(params.encumber.lien.details.maxAmount, owed);", "    }", "", "    uint256 potentialDebt = 0;", "    for (uint256 i = params.encumber.stack.length; i > 0; ) {", "      uint256 j = i - 1;", "      // should not be able to purchase lien if any lien in the stack is expired (and will be liquidated)", "      if (block.timestamp >= params.encumber.stack[j].point.end) {", "        revert InvalidState(InvalidStates.EXPIRED_LIEN);", "      }", "", "      potentialDebt += _getOwed(", "        params.encumber.stack[j],", "        params.encumber.stack[j].point.end", "      );", "", "      if (", "        potentialDebt >", "        params.encumber.stack[j].lien.details.liquidationInitialAsk", "      ) {", "        revert InvalidState(InvalidStates.INITIAL_ASK_EXCEEDED);", "      }", "", "      unchecked {", "        --i;", "      }", "    }", "", "    address payee = _getPayee(", "      s,", "      params.encumber.stack[params.position].point.lienId", "    );", "    s.TRANSFER_PROXY.tokenTransferFrom(", "      params.encumber.stack[params.position].lien.token,", "      msg.sender,", "      payee,", "      buyout", "    );", "", "    if (_isPublicVault(s, payee)) {", "      IPublicVault(payee).handleBuyoutLien(", "        IPublicVault.BuyoutLienParams({", "          lienSlope: calculateSlope(params.encumber.stack[params.position]),", "          lienEnd: params.encumber.stack[params.position].point.end,", "          increaseYIntercept: buyout -", "            params.encumber.stack[params.position].point.amount", "        })", "      );", "    }", "", "    newStack = _replaceStackAtPositionWithNewLien(", "      s,", "      params.encumber.stack,", "      params.position,", "      newLien,", "      params.encumber.stack[params.position].point.lienId", "    );", "    uint256 maxPotentialDebt;", "    uint256 n = newStack.length;", "    uint256 i;", "    for (i; i < n; ) {", "      maxPotentialDebt += _getOwed(newStack[i], newStack[i].point.end);", "      //no need to check validity before the position we're buying", "      if (i == params.position) {", "        if (maxPotentialDebt > params.encumber.lien.details.maxPotentialDebt) {", "          revert InvalidState(InvalidStates.DEBT_LIMIT);", "        }", "      }", "      if (", "        i > params.position &&", "        (maxPotentialDebt > newStack[i].lien.details.maxPotentialDebt)", "      ) {", "        revert InvalidState(InvalidStates.DEBT_LIMIT);", "      }", "      unchecked {", "        ++i;", "      }", "    }", "", "    s.collateralStateHash[params.encumber.lien.collateralId] = keccak256(", "      abi.encode(newStack)", "    );", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function fuse(CharacterData[] calldata _characterList) external {", "        uint256 numCharacters = _characterList.length;", "        if (numCharacters > 13 || numCharacters == 0) revert InvalidNumberOfCharacters(numCharacters);", "        uint256 fusingCosts = 2**(13 - numCharacters) * 1e18;", "        SafeTransferLib.safeTransferFrom(note, msg.sender, revenueAddress, fusingCosts);", "        uint256 namespaceIDToMint = ++nextNamespaceIDToMint;", "        Tray.TileData[] storage nftToMintCharacters = nftCharacters[namespaceIDToMint];", "        bytes memory bName = new bytes(numCharacters * 33); // Used to convert into a string. Can be 33 times longer than the string at most (longest zalgo characters is 33 bytes)", "        uint256 numBytes;", "        // Extract unique trays for burning them later on", "        uint256 numUniqueTrays;", "        uint256[] memory uniqueTrays = new uint256[](_characterList.length);", "        for (uint256 i; i < numCharacters; ++i) {", "            bool isLastTrayEntry = true;", "            uint256 trayID = _characterList[i].trayID;", "            uint8 tileOffset = _characterList[i].tileOffset;", "            // Check for duplicate characters in the provided list. 1/2 * n^2 loop iterations, but n is bounded to 13 and we do not perform any storage operations", "            for (uint256 j = i + 1; j < numCharacters; ++j) {", "                if (_characterList[j].trayID == trayID) {", "                    isLastTrayEntry = false;", "                    if (_characterList[j].tileOffset == tileOffset) revert FusingDuplicateCharactersNotAllowed();", "                }", "            }", "            Tray.TileData memory tileData = tray.getTile(trayID, tileOffset); // Will revert if tileOffset is too high", "            uint8 characterModifier = tileData.characterModifier;", "", "            if (tileData.fontClass != 0 && _characterList[i].skinToneModifier != 0) {", "                revert CannotFuseCharacterWithSkinTone();", "            }", "            ", "            if (tileData.fontClass == 0) {", "                // Emoji", "                characterModifier = _characterList[i].skinToneModifier;", "            }", "            bytes memory charAsBytes = Utils.characterToUnicodeBytes(0, tileData.characterIndex, characterModifier);", "            tileData.characterModifier = characterModifier;", "            uint256 numBytesChar = charAsBytes.length;", "            for (uint256 j; j < numBytesChar; ++j) {", "                bName[numBytes + j] = charAsBytes[j];", "            }", "            numBytes += numBytesChar;", "            nftToMintCharacters.push(tileData);", "            // We keep track of the unique trays NFTs (for burning them) and only check the owner once for the last occurence of the tray", "            if (isLastTrayEntry) {", "                uniqueTrays[numUniqueTrays++] = trayID;", "                // Verify address is allowed to fuse", "                address trayOwner = tray.ownerOf(trayID);", "                if (", "                    trayOwner != msg.sender &&", "                    tray.getApproved(trayID) != msg.sender &&", "                    !tray.isApprovedForAll(trayOwner, msg.sender)", "                ) revert CallerNotAllowedToFuse();", "            }", "        }", "        // Set array to the real length (in bytes) to avoid zero bytes in the end when doing the string conversion", "        assembly {", "            mstore(bName, numBytes)", "        }", "        string memory nameToRegister = string(bName);", "        uint256 currentRegisteredID = nameToToken[nameToRegister];", "        if (currentRegisteredID != 0) revert NameAlreadyRegistered(currentRegisteredID);", "        nameToToken[nameToRegister] = namespaceIDToMint;", "        tokenToName[namespaceIDToMint] = nameToRegister;", "", "        for (uint256 i; i < numUniqueTrays; ++i) {", "            tray.burn(uniqueTrays[i]);", "        }", "        _mint(msg.sender, namespaceIDToMint);", "        // Although _mint already emits an event, we additionally emit one because of the name", "        emit NamespaceFused(msg.sender, namespaceIDToMint, nameToRegister);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _validateOrderParameters(Order calldata order, bytes32 orderHash)", "        internal", "        view", "        returns (bool)", "    {", "        return (", "            /* Order must have a trader. */", "            (order.trader != address(0)) &&", "            /* Order must not be cancelled or filled. */", "            (!cancelledOrFilled[orderHash]) &&", "            /* Order must be settleable. */", "            (order.listingTime < block.timestamp) &&", "            (block.timestamp < order.expirationTime)", "        );", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["    function _hashFixedGovernanceOpts(FixedGovernanceOpts memory opts)", "        internal", "        pure", "        returns (bytes16 h)", "    {", "        // Hash in place.", "        assembly {", "            // Replace the address[] hosts field with its hash temporarily.", "            let oldHostsFieldValue := mload(opts)", "            mstore(opts, keccak256(add(mload(opts), 0x20), mul(mload(mload(opts)), 32)))", "            // Hash the entire struct.", "            h := keccak256(opts, 0xC0)", "            // Restore old hosts field value.", "            mstore(opts, oldHostsFieldValue)", "        }", "    }"], "ner_tags": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function add(address _token, uint _allocationPoints, uint16 _depositFee, uint _startBlock) public onlyOwner {", "        require(_token != address(0), \"zero address\");", "        uint lastRewardBlock = block.number > _startBlock ? block.number : _startBlock;", "        totalAllocPoint = totalAllocPoint.add(_allocationPoints);", "        require(pid[_token] == 0, \"already registered\"); // pid starts from 0", "        poolInfo.push(", "            PoolInfo({", "                depositToken: IERC20(_token),", "                allocPoint: _allocationPoints,", "                lastRewardBlock: lastRewardBlock,", "                accConcurPerShare: 0,", "                depositFeeBP: _depositFee", "            })", "        );", "        pid[_token] = poolInfo.length - 1;", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function setLpToken(address _lpToken) external onlyOwner {", "        _setLPToken(_lpToken);", "    }"], "ner_tags": [1, 0, 0]}
{"tokens": ["  function totalRedemptionWeight(address _nft) public view override returns (uint256 weight) {", "    // Keep a reference to the greatest tier ID.", "    uint256 _maxTierId = maxTierIdOf[_nft];", "", "    // Keep a reference to the tier being iterated on.", "    JBStored721Tier memory _storedTier;", "", "    // Add each token's tier's contribution floor to the weight.", "    for (uint256 _i; _i < _maxTierId; ) {", "      // Keep a reference to the stored tier.", "      _storedTier = _storedTierOf[_nft][_i + 1];", "", "      // Add the tier's contribution floor multiplied by the quantity minted.", "      weight +=", "        (_storedTier.contributionFloor *", "          (_storedTier.initialQuantity - _storedTier.remainingQuantity)) +", "        _numberOfReservedTokensOutstandingFor(_nft, _i, _storedTier);", "", "      unchecked {", "        ++_i;", "      }", "    }", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function xcall(XCallArgs calldata _args) external payable whenNotPaused nonReentrant returns (bytes32) {", "    // Sanity checks.", "    {", "      // Correct origin domain.", "      if (_args.params.originDomain != s.domain) {", "        revert BridgeFacet__xcall_wrongDomain();", "      }", "", "      // Recipient is defined.", "      if (_args.params.to == address(0)) {", "        revert BridgeFacet__xcall_emptyTo();", "      }", "", "      // If callback address is not set, callback fee should be 0.", "      if (_args.params.callback == address(0) && _args.params.callbackFee > 0) {", "        revert BridgeFacet__xcall_nonZeroCallbackFeeForCallback();", "      }", "", "      // Callback is contract if supplied.", "      if (_args.params.callback != address(0) && !Address.isContract(_args.params.callback)) {", "        revert BridgeFacet__xcall_callbackNotAContract();", "      }", "    }", "", "    bytes32 transferId;", "    bytes memory message;", "    XCalledEventArgs memory eventArgs;", "    {", "      // Get the remote BridgeRouter address; revert if not found.", "      bytes32 remote = _mustHaveRemote(_args.params.destinationDomain);", "", "      // Get the true transacting asset ID (using wrapper instead of native, if applicable).", "      address transactingAssetId = _args.transactingAssetId == address(0)", "        ? address(s.wrapper)", "        : _args.transactingAssetId;", "", "      // Check that the asset is supported -- can be either adopted or local.", "      ConnextMessage.TokenId memory canonical = s.adoptedToCanonical[transactingAssetId];", "      if (canonical.id == bytes32(0)) {", "        // Here, the asset is *not* the adopted asset. The only other valid option", "        // is for this asset to be the local asset (i.e. transferring madEth on optimism)", "        // NOTE: it *cannot* be the canonical asset. the canonical asset is only used on", "        // the canonical domain, where it is *also* the adopted asset.", "        if (s.tokenRegistry.isLocalOrigin(transactingAssetId)) {", "          // revert, using a token of local origin that is not registered as adopted", "          revert BridgeFacet__xcall_notSupportedAsset();", "        }", "", "        (uint32 canonicalDomain, bytes32 canonicalId) = s.tokenRegistry.getTokenId(transactingAssetId);", "        canonical = ConnextMessage.TokenId(canonicalDomain, canonicalId);", "      }", "", "      transferId = _getTransferId(_args, canonical);", "      s.nonce += 1;", "", "      // Store the relayer fee", "      s.relayerFees[transferId] = _args.params.relayerFee;", "", "      // Transfer funds of transacting asset to the contract from the user.", "      // NOTE: Will wrap any native asset transferred to wrapped-native automatically.", "      (, uint256 amount) = AssetLogic.handleIncomingAsset(", "        _args.transactingAssetId,", "        _args.amount,", "        _args.params.relayerFee + _args.params.callbackFee", "      );", "", "      // Swap to the local asset from adopted if applicable.", "      (uint256 bridgedAmt, address bridged) = AssetLogic.swapToLocalAssetIfNeeded(", "        canonical,", "        transactingAssetId,", "        amount,", "        _args.params.slippageTol", "      );", "", "      // Transfer callback fee to PromiseRouter if set", "      if (_args.params.callbackFee != 0) {", "        s.promiseRouter.initCallbackFee{value: _args.params.callbackFee}(transferId);", "      }", "", "      message = _formatMessage(_args, bridged, transferId, bridgedAmt);", "      s.xAppConnectionManager.home().dispatch(_args.params.destinationDomain, remote, message);", "", "      // Format arguments for XCalled event that will be emitted below.", "      eventArgs = XCalledEventArgs({", "        transactingAssetId: transactingAssetId,", "        amount: amount,", "        bridgedAmt: bridgedAmt,", "        bridged: bridged", "      });", "    }", "", "    // emit event", "    emit XCalled(transferId, _args, eventArgs, s.nonce - 1, message, msg.sender);", "", "    return transferId;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _autoStakeWithSyndicate(address _associatedSmartWallet, bytes memory _blsPubKey) internal {", "        IERC20 sETH = IERC20(getSlotRegistry().stakeHouseShareTokens(stakehouse));", "", "        uint256 stakeAmount = 12 ether;", "        IOwnableSmartWallet(_associatedSmartWallet).execute(", "            address(sETH),", "            abi.encodeWithSelector(", "                IERC20.transfer.selector,", "                address(this),", "                stakeAmount", "            )", "        );", "", "        // Create the payload for staking", "        bytes[] memory stakingKeys = new bytes[](1);", "        stakingKeys[0] = _blsPubKey;", "", "        uint256[] memory stakeAmounts = new uint256[](1);", "        stakeAmounts[0] = stakeAmount;", "", "        // Stake the sETH to be received by the LPs of the Staking Funds Vault (fees and mev)", "        Syndicate(payable(syndicate)).stake(stakingKeys, stakeAmounts, address(stakingFundsVault));", "    }"], "ner_tags": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function increaseLockDuration(uint256 duration) external {", "        if(emergency) revert EmergencyBlock();", "        require(userLocks[msg.sender].length != 0, \"hPAL: No Lock\");", "        // Find the current Lock", "        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;", "        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];", "        // Update user rewards before any change on their balance (staked and locked)", "        _updateUserRewards(msg.sender);", "        // Call the _lock method with the current amount, and the new duration", "        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function ethPerDerivative(uint256 _amount) public view returns (uint256) {", "        uint256 frxAmount = IsFrxEth(SFRX_ETH_ADDRESS).convertToAssets(", "            10 ** 18", "        );", "        return ((10 ** 18 * frxAmount) /", "            IFrxEthEthPool(FRX_ETH_CRV_POOL_ADDRESS).price_oracle());", "    }"], "ner_tags": [0, 0, 0, 0, 1, 1, 0]}
{"tokens": ["    function createLPDASale(LPDA.Sale calldata sale) external returns (address clone) {", "        require(IEscher721(sale.edition).hasRole(bytes32(0x00), msg.sender), \"NOT AUTHORIZED\");", "        require(sale.saleReceiver != address(0), \"INVALID SALE RECEIVER\");", "        require(sale.startTime >= block.timestamp, \"INVALID START TIME\");", "        require(sale.endTime > sale.startTime, \"INVALID END TIME\");", "        require(sale.finalId > sale.currentId, \"INVALID FINAL ID\");", "        require(sale.startPrice > 0, \"INVALID START PRICE\");", "        require(sale.dropPerSecond > 0, \"INVALID DROP PER SECOND\");", "", "        clone = implementation.clone();", "        LPDA(clone).initialize(sale);", "", "        emit NewLPDAContract(msg.sender, sale.edition, clone, sale);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function claimRewards(address beneficiary) external virtual override returns (uint256) {", "        require(", "            msg.sender == beneficiary || _roleManager().hasRole(Roles.GAUGE_ZAP, msg.sender),", "            Error.UNAUTHORIZED_ACCESS", "        );", "        _userCheckpoint(beneficiary);", "        uint256 amount = perUserShare[beneficiary];", "        if (amount <= 0) return 0;", "        perUserShare[beneficiary] = 0;", "        controller.inflationManager().mintRewards(beneficiary, amount);", "        emit RewardClaimed(beneficiary, amount);", "        return amount;", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function deposit(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {", "        address msgSender = _msgSender();", "", "        require(", "            lpToken.isApprovedForAll(msgSender, address(this)) || lpToken.getApproved(_nftId) == address(this),", "            \"ERR__NOT_APPROVED\"", "        );", "", "        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);", "        amount /= liquidityProviders.BASE_DIVISOR();", "", "        require(rewardTokens[baseToken] != address(0), \"ERR__POOL_NOT_INITIALIZED\");", "        require(rewardRateLog[baseToken].length != 0, \"ERR__POOL_NOT_INITIALIZED\");", "", "        NFTInfo storage nft = nftInfo[_nftId];", "        require(!nft.isStaked, \"ERR__NFT_ALREADY_STAKED\");", "", "        lpToken.safeTransferFrom(msgSender, address(this), _nftId);", "", "        PoolInfo memory pool = updatePool(baseToken);", "        nft.isStaked = true;", "        nft.staker = _to;", "        nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;", "", "        nftIdsStaked[_to].push(_nftId);", "        totalSharesStaked[baseToken] += amount;", "", "        emit LogDeposit(msgSender, baseToken, _nftId);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["    function updateQuorumThresholdBps(uint256 _newQuorumVotesBps) external onlyOwner {", "        emit QuorumVotesBpsUpdated(settings.quorumThresholdBps, _newQuorumVotesBps);", "", "        settings.quorumThresholdBps = SafeCast.toUint16(_newQuorumVotesBps);", "    }"], "ner_tags": [1, 0, 0, 0, 0]}
{"tokens": ["    function withdrawETH(uint256 _amount) external nonReentrant {", "        require(_amount >= MIN_STAKING_AMOUNT, \"Invalid amount\");", "        require(lpTokenETH.balanceOf(msg.sender) >= _amount, \"Invalid balance\");", "        require(idleETH >= _amount, \"Come back later or withdraw less ETH\");", "", "        idleETH -= _amount;", "", "        lpTokenETH.burn(msg.sender, _amount);", "        (bool success,) = msg.sender.call{value: _amount}(\"\");", "        require(success, \"Failed to transfer ETH\");", "", "        emit LPBurnedForETH(msg.sender, _amount);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": ["    function previewWithdraw(uint256 assets) public view override returns (uint256 shares) {", "        if (totalSupply() == 0 || _freeFunds() == 0) return 0;", "        shares = roundUpDiv(assets * totalSupply(), _freeFunds());", "    }"], "ner_tags": [0, 0, 1, 0]}
{"tokens": ["    function _transfer(address to, uint256 amount) internal override {", "        payable(to).transfer(amount);", "    }"], "ner_tags": [0, 1, 0]}
{"tokens": ["    function removeValidator(uint256 remove_idx, bool dont_care_about_ordering) public onlyByOwnGov {", "        // Get the pubkey for the validator to remove (for informational purposes)", "        bytes memory removed_pubkey = validators[remove_idx].pubKey;", "", "        // Less gassy to swap and pop", "        if (dont_care_about_ordering){", "            // Swap the (validator to remove) with the (last validator in the array)", "            swapValidator(remove_idx, validators.length - 1);", "", "            // Pop off the validator to remove, which is now at the end of the array", "            validators.pop();", "        }", "        // More gassy, loop", "        else {", "            // Save the original validators", "            Validator[] memory original_validators = validators;", "", "            // Clear the original validators list", "            delete validators;", "", "            // Fill the new validators array with all except the value to remove", "            for (uint256 i = 0; i < original_validators.length; ++i) {", "                if (i != remove_idx) {", "                    validators.push(original_validators[i]);", "                }", "            }", "        }", "", "        emit ValidatorRemoved(removed_pubkey, remove_idx, dont_care_about_ordering);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function LockTo(uint256 _amount, uint256 _lock_time, address to) public nonReentrant {", "        require(IERC20(MuteToken).balanceOf(msg.sender) >= _amount, \"dMute::Lock: INSUFFICIENT_BALANCE\");", "", "        //transfer tokens to this contract", "        IERC20(MuteToken).transferFrom(msg.sender, address(this), _amount);", "", "        // calculate dTokens to mint", "        uint256 tokens_to_mint = timeToTokens(_amount, _lock_time);", "", "        require(tokens_to_mint > 0, 'dMute::Lock: INSUFFICIENT_TOKENS_MINTED');", "", "        _mint(to, tokens_to_mint);", "", "        _userLocks[to].push(UserLockInfo(_amount, block.timestamp.add(_lock_time), tokens_to_mint));", "", "        emit LockEvent(to, _amount, tokens_to_mint, _lock_time);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function recoverKey(", "        bytes32 messageHash,", "        bytes memory messageSignatures,", "        uint256 pos", "    ) internal pure returns (address) {", "        if (messageSignatures.length % 65 != 0) {", "            return (address(0));", "        }", "", "        uint8 v;", "        bytes32 r;", "        bytes32 s;", "        (v, r, s) = signatureSplit(messageSignatures, pos);", "", "        // If the version is correct return the signer address", "        if (v != 27 && v != 28) {", "            return (address(0));", "        } else {", "            // solium-disable-next-line arg-overflow", "            return ecrecover(toEthSignedMessageHash(messageHash), v, r, s);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["    function mint(address _to, uint256 _amount) external {", "        require(operators.contains(_msgSender()), \"not an operator\");", "", "        uint256 supply = totalSupply;", "", "        //use current supply to gauge cliff", "        //this will cause a bit of overflow into the next cliff range", "        //but should be within reasonable levels.", "        //requires a max supply check though", "        uint256 cliff = supply.div(reductionPerCliff);", "        //mint if below total cliffs", "        if (cliff < totalCliffs) {", "            //for reduction% take inverse of current cliff", "            uint256 reduction = totalCliffs.sub(cliff);", "            //reduce", "            _amount = _amount.mul(reduction).div(totalCliffs);", "", "            //supply cap check", "            uint256 amtTillMax = maxSupply.sub(supply);", "            if (_amount > amtTillMax) {", "                _amount = amtTillMax;", "            }", "", "            //mint", "            veToken.safeTransfer(_to, _amount);", "            totalSupply += _amount;", "        }", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function setVestingDistributor(address _vestingDistributor)", "    external", "    onlyRoleMalt(ADMIN_ROLE, \"Must have admin privs\")", "  {", "    require(_vestingDistributor != address(0), \"SetVestDist: No addr(0)\");", "    vestingDistributor = IVestingDistributor(_vestingDistributor);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["    function mintWithUnderlying(address u, uint256 m, uint256 a, uint256 ptBought, uint256 minRatio, uint256 maxRatio) external returns (uint256, uint256, uint256) {", "        IPool pool = IPool(pools[u][m]);", "        Safe.transferFrom(ERC20(address(pool.base())), msg.sender, address(pool), a);", "        return pool.mintWithBase(msg.sender, msg.sender, ptBought, minRatio, maxRatio);", "    }"], "ner_tags": [0, 0, 1, 0, 0]}
{"tokens": ["  function _encodeStrategyData(", "    VIData storage s,", "    IAstariaRouter.StrategyDetailsParam calldata strategy,", "    bytes32 root", "  ) internal view returns (bytes memory) {", "    bytes32 hash = keccak256(", "      abi.encode(STRATEGY_TYPEHASH, s.strategistNonce, strategy.deadline, root)", "    );", "    return", "      abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), hash);", "  }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function decimals()", "    public", "    pure", "    virtual", "    override(IERC20Metadata)", "    returns (uint8)", "  {", "    return 18;", "  }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["    function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {", "        require(", "            blockNumber < block.number,", "            \"hPAL: invalid blockNumber\"", "        );", "", "        UserLock memory emptyLock = UserLock(", "            0,", "            0,", "            0,", "            0", "        );", "", "        // no checkpoints written", "        uint256 nbCheckpoints = userLocks[account].length;", "        if (nbCheckpoints == 0) return emptyLock;", "", "        // last checkpoint check", "        if (userLocks[account][nbCheckpoints - 1].fromBlock <= blockNumber) {", "            return userLocks[account][nbCheckpoints - 1];", "        }", "", "        // no checkpoint old enough", "        if (userLocks[account][0].fromBlock > blockNumber) {", "            return emptyLock;", "        }", "", "        uint256 high = nbCheckpoints - 1; // last checkpoint already checked", "        uint256 low = 0;", "        uint256 mid;", "        while (low < high) {", "            mid = Math.average(low, high);", "            if (userLocks[account][mid].fromBlock == blockNumber) {", "                return userLocks[account][mid];", "            }", "            if (userLocks[account][mid].fromBlock > blockNumber) {", "                high = mid;", "            } else {", "                low = mid + 1;", "            }", "        }", "        return high == 0 ? emptyLock : userLocks[account][high - 1];", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function finalize() public {", "        Sale memory temp = sale;", "        require(block.timestamp >= temp.endTime, \"TOO SOON\");", "        ISaleFactory(factory).feeReceiver().transfer(address(this).balance / 20);", "        _end(temp);", "    }"], "ner_tags": [0, 0, 0, 1, 0, 0]}
{"tokens": ["    function tokenURI(uint256 tokenId) public view returns (string memory) {", "        // forgefmt: disable-next-item", "        bytes memory metadata = abi.encodePacked(", "            \"{\",", "                '\"name\": \"Private Pool ',Strings.toString(tokenId),'\",',", "                '\"description\": \"Caviar private pool AMM position.\",',", "                '\"image\": ','\"data:image/svg+xml;base64,', Base64.encode(svg(tokenId)),'\",',", "                '\"attributes\": [',", "                    attributes(tokenId),", "                \"]\",", "            \"}\"", "        );", "", "        return string(abi.encodePacked(\"data:application/json;base64,\", Base64.encode(metadata)));", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function add(", "        uint256 _cidNFTID,", "        string calldata _subprotocolName,", "        uint256 _key,", "        uint256 _nftIDToAdd,", "        AssociationType _type", "    ) external {", "        SubprotocolRegistry.SubprotocolData memory subprotocolData = subprotocolRegistry.getSubprotocol(", "            _subprotocolName", "        );", "        address subprotocolOwner = subprotocolData.owner;", "        if (subprotocolOwner == address(0)) revert SubprotocolDoesNotExist(_subprotocolName);", "        address cidNFTOwner = ownerOf[_cidNFTID];", "        if (", "            cidNFTOwner != msg.sender &&", "            getApproved[_cidNFTID] != msg.sender &&", "            !isApprovedForAll[cidNFTOwner][msg.sender]", "        ) revert NotAuthorizedForCIDNFT(msg.sender, _cidNFTID, cidNFTOwner);", "        if (_nftIDToAdd == 0) revert NFTIDZeroDisallowedForSubprotocols(); // ID 0 is disallowed in subprotocols", "", "        // The CID Protocol safeguards the NFTs of subprotocols. Note that these NFTs are usually pointers to other data / NFTs (e.g., to an image NFT for profile pictures)", "        ERC721 nftToAdd = ERC721(subprotocolData.nftAddress);", "        nftToAdd.safeTransferFrom(msg.sender, address(this), _nftIDToAdd);", "        // Charge fee (subprotocol & CID fee) if configured", "        uint96 subprotocolFee = subprotocolData.fee;", "        if (subprotocolFee != 0) {", "            uint256 cidFee = (subprotocolFee * CID_FEE_BPS) / 10_000;", "            SafeTransferLib.safeTransferFrom(note, msg.sender, cidFeeWallet, cidFee);", "            SafeTransferLib.safeTransferFrom(note, msg.sender, subprotocolOwner, subprotocolFee - cidFee);", "        }", "        if (_type == AssociationType.ORDERED) {", "            if (!subprotocolData.ordered) revert AssociationTypeNotSupportedForSubprotocol(_type, _subprotocolName);", "            if (cidData[_cidNFTID][_subprotocolName].ordered[_key] != 0) {", "                // Remove to ensure that user gets NFT back", "                remove(_cidNFTID, _subprotocolName, _key, 0, _type);", "            }", "            cidData[_cidNFTID][_subprotocolName].ordered[_key] = _nftIDToAdd;", "            emit OrderedDataAdded(_cidNFTID, _subprotocolName, _key, _nftIDToAdd);", "        } else if (_type == AssociationType.PRIMARY) {", "            if (!subprotocolData.primary) revert AssociationTypeNotSupportedForSubprotocol(_type, _subprotocolName);", "            if (cidData[_cidNFTID][_subprotocolName].primary != 0) {", "                // Remove to ensure that user gets NFT back", "                remove(_cidNFTID, _subprotocolName, 0, 0, _type);", "            }", "            cidData[_cidNFTID][_subprotocolName].primary = _nftIDToAdd;", "            emit PrimaryDataAdded(_cidNFTID, _subprotocolName, _nftIDToAdd);", "        } else if (_type == AssociationType.ACTIVE) {", "            if (!subprotocolData.active) revert AssociationTypeNotSupportedForSubprotocol(_type, _subprotocolName);", "            IndexedArray storage activeData = cidData[_cidNFTID][_subprotocolName].active;", "            uint256 lengthBeforeAddition = activeData.values.length;", "            if (lengthBeforeAddition == 0) {", "                uint256[] memory nftIDsToAdd = new uint256[](1);", "                nftIDsToAdd[0] = _nftIDToAdd;", "                activeData.values = nftIDsToAdd;", "                activeData.positions[_nftIDToAdd] = 1; // Array index + 1", "            } else {", "                // Check for duplicates", "                if (activeData.positions[_nftIDToAdd] != 0)", "                    revert ActiveArrayAlreadyContainsID(_cidNFTID, _subprotocolName, _nftIDToAdd);", "                activeData.values.push(_nftIDToAdd);", "                activeData.positions[_nftIDToAdd] = lengthBeforeAddition + 1;", "            }", "            emit ActiveDataAdded(_cidNFTID, _subprotocolName, _nftIDToAdd, lengthBeforeAddition);", "        }", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function buyFractions(address _vault, uint256 _amount) external payable {", "        // Reverts if address is not a registered vault", "        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(", "            _vault", "        );", "        if (id == 0) revert NotVault(_vault);", "        // Reverts if auction state is not live", "        (uint256 startTime, , State current, uint256 fractionPrice, , ) = this", "            .buyoutInfo(_vault);", "        State required = State.LIVE;", "        if (current != required) revert InvalidState(required, current);", "        // Reverts if current time is greater than end time of rejection period", "        uint256 endTime = startTime + REJECTION_PERIOD;", "        if (block.timestamp > endTime)", "            revert TimeExpired(block.timestamp, endTime);", "        // Reverts if payment amount does not equal price of fractional amount", "        if (msg.value != fractionPrice * _amount) revert InvalidPayment();", "", "        // Transfers fractional tokens to caller", "        IERC1155(token).safeTransferFrom(", "            address(this),", "            msg.sender,", "            id,", "            _amount,", "            \"\"", "        );", "        // Updates ether balance of pool", "        buyoutInfo[_vault].ethBalance += msg.value;", "        // Emits event for buying fractions from pool", "        emit BuyFractions(msg.sender, _amount);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function refPerTok() public view override returns (uint192) {", "        uint256 rate = ICToken(address(erc20)).exchangeRateStored();", "        int8 shiftLeft = 8 - int8(referenceERC20Decimals) - 18;", "        return shiftl_toFix(rate, shiftLeft);", "    }"], "ner_tags": [0, 1, 0, 0, 0]}
{"tokens": ["  function _distributeFunds(", "    address nftContract,", "    uint256 tokenId,", "    address payable seller,", "    uint256 price", "  )", "    internal", "    returns (", "      uint256 foundationFee,", "      uint256 creatorFee,", "      uint256 ownerRev", "    )", "  {", "    address payable[] memory creatorRecipients;", "    uint256[] memory creatorShares;", "", "    address payable ownerRevTo;", "    (foundationFee, creatorRecipients, creatorShares, creatorFee, ownerRevTo, ownerRev) = _getFees(", "      nftContract,", "      tokenId,", "      seller,", "      price", "    );", "", "    _sendValueWithFallbackWithdraw(getFoundationTreasury(), foundationFee, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);", "", "    if (creatorFee > 0) {", "      if (creatorRecipients.length > 1) {", "        uint256 maxCreatorIndex = creatorRecipients.length - 1;", "        if (maxCreatorIndex > MAX_ROYALTY_RECIPIENTS_INDEX) {", "          maxCreatorIndex = MAX_ROYALTY_RECIPIENTS_INDEX;", "        }", "", "        // Determine the total shares defined so it can be leveraged to distribute below", "        uint256 totalShares;", "        unchecked {", "          // The array length cannot overflow 256 bits.", "          for (uint256 i = 0; i <= maxCreatorIndex; ++i) {", "            if (creatorShares[i] > BASIS_POINTS) {", "              // If the numbers are >100% we ignore the fee recipients and pay just the first instead", "              maxCreatorIndex = 0;", "              break;", "            }", "            // The check above ensures totalShares wont overflow.", "            totalShares += creatorShares[i];", "          }", "        }", "        if (totalShares == 0) {", "          maxCreatorIndex = 0;", "        }", "", "        // Send payouts to each additional recipient if more than 1 was defined", "        uint256 totalDistributed;", "        for (uint256 i = 1; i <= maxCreatorIndex; ++i) {", "          uint256 share = (creatorFee * creatorShares[i]) / totalShares;", "          totalDistributed += share;", "          _sendValueWithFallbackWithdraw(creatorRecipients[i], share, SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS);", "        }", "", "        // Send the remainder to the 1st creator, rounding in their favor", "        _sendValueWithFallbackWithdraw(", "          creatorRecipients[0],", "          creatorFee - totalDistributed,", "          SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS", "        );", "      } else {", "        _sendValueWithFallbackWithdraw(creatorRecipients[0], creatorFee, SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS);", "      }", "    }", "    _sendValueWithFallbackWithdraw(ownerRevTo, ownerRev, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);", "", "    _nftContractToTokenIdToFirstSaleCompleted[nftContract][tokenId] = true;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _sendRewardsForNft(uint256 _nftId, address payable _to) internal {", "        NFTInfo storage nft = nftInfo[_nftId];", "        require(nft.isStaked, \"ERR__NFT_NOT_STAKED\");", "", "        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);", "        amount /= liquidityProviders.BASE_DIVISOR();", "", "        PoolInfo memory pool = updatePool(baseToken);", "        uint256 pending;", "        uint256 amountSent;", "        if (amount > 0) {", "            pending = ((amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION) - nft.rewardDebt + nft.unpaidRewards;", "            if (rewardTokens[baseToken] == NATIVE) {", "                uint256 balance = address(this).balance;", "                if (pending > balance) {", "                    unchecked {", "                        nft.unpaidRewards = pending - balance;", "                    }", "                    (bool success, ) = _to.call{value: balance}(\"\");", "                    require(success, \"ERR__NATIVE_TRANSFER_FAILED\");", "                    amountSent = balance;", "                } else {", "                    nft.unpaidRewards = 0;", "                    (bool success, ) = _to.call{value: pending}(\"\");", "                    require(success, \"ERR__NATIVE_TRANSFER_FAILED\");", "                    amountSent = pending;", "                }", "            } else {", "                IERC20Upgradeable rewardToken = IERC20Upgradeable(rewardTokens[baseToken]);", "                uint256 balance = rewardToken.balanceOf(address(this));", "                if (pending > balance) {", "                    unchecked {", "                        nft.unpaidRewards = pending - balance;", "                    }", "                    amountSent = _sendErc20AndGetSentAmount(rewardToken, balance, _to);", "                } else {", "                    nft.unpaidRewards = 0;", "                    amountSent = _sendErc20AndGetSentAmount(rewardToken, pending, _to);", "                }", "            }", "        }", "        nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;", "        emit LogOnReward(_msgSender(), baseToken, amountSent, _to);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function depositFor(", "        address account,", "        uint256 depositAmount,", "        uint256 minTokenAmount", "    ) public payable override notPaused returns (uint256) {", "        uint256 rate = exchangeRate();", "", "        if (isCapped()) {", "            uint256 lpBalance = lpToken.balanceOf(account);", "            uint256 stakedAndLockedBalance = staker.stakedAndActionLockedBalanceOf(account);", "            uint256 currentUnderlyingBalance = (lpBalance + stakedAndLockedBalance).scaledMul(rate);", "            require(", "                currentUnderlyingBalance + depositAmount <= depositCap,", "                Error.EXCEEDS_DEPOSIT_CAP", "            );", "        }", "", "        _doTransferIn(msg.sender, depositAmount);", "        uint256 mintedLp = depositAmount.scaledDiv(rate);", "        require(mintedLp >= minTokenAmount, Error.INVALID_AMOUNT);", "", "        lpToken.mint(account, mintedLp);", "        _rebalanceVault();", "", "        if (msg.sender == account || address(this) == account) {", "            emit Deposit(msg.sender, depositAmount, mintedLp);", "        } else {", "            emit DepositFor(msg.sender, account, depositAmount, mintedLp);", "        }", "        return mintedLp;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function buy(uint256 _amount) external payable {", "        uint48 amount = uint48(_amount);", "        Sale memory temp = sale;", "        IEscher721 nft = IEscher721(temp.edition);", "        require(block.timestamp >= temp.startTime, \"TOO SOON\");", "        uint256 price = getPrice();", "        require(msg.value >= amount * price, \"WRONG PRICE\");", "", "        amountSold += amount;", "        uint48 newId = amount + temp.currentId;", "        require(newId <= temp.finalId, \"TOO MANY\");", "", "        receipts[msg.sender].amount += amount;", "        receipts[msg.sender].balance += uint80(msg.value);", "", "        for (uint256 x = temp.currentId + 1; x <= newId; x++) {", "            nft.mint(msg.sender, x);", "        }", "", "        sale.currentId = newId;", "", "        emit Buy(msg.sender, amount, msg.value, temp);", "", "        if (newId == temp.finalId) {", "            sale.finalPrice = uint80(price);", "            uint256 totalSale = price * amountSold;", "            uint256 fee = totalSale / 20;", "            ISaleFactory(factory).feeReceiver().transfer(fee);", "            temp.saleReceiver.transfer(totalSale - fee);", "            _end();", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": ["  function _overflowDuring(", "    IJBSingleTokenPaymentTerminal _terminal,", "    uint256 _projectId,", "    JBFundingCycle memory _fundingCycle,", "    uint256 _balanceCurrency", "  ) private view returns (uint256) {", "    // Get the current balance of the project.", "    uint256 _balanceOf = balanceOf[_terminal][_projectId];", "", "    // If there's no balance, there's no overflow.", "    if (_balanceOf == 0) return 0;", "", "    // Get a reference to the distribution limit during the funding cycle.", "    (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(", "      directory.controllerOf(_projectId)", "    ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());", "", "    // Get a reference to the amount still distributable during the funding cycle.", "    uint256 _distributionLimitRemaining = _distributionLimit -", "      usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];", "", "    // Convert the _distributionRemaining to be in terms of the provided currency.", "    if (_distributionLimitRemaining != 0 && _distributionLimitCurrency != _balanceCurrency)", "      _distributionLimitRemaining = PRBMath.mulDiv(", "        _distributionLimitRemaining,", "        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.", "        prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)", "      );", "", "    // Overflow is the balance of this project minus the amount that can still be distributed.", "    return _balanceOf > _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function unauthorize(address user) public {", "        address sender = _msgSender();", "        require(_authorized[sender].remove(user), \"Address is not authorized\");", "        emit Unauthorized(sender, user);", "    }"], "ner_tags": [1, 1, 1, 1, 1]}
{"tokens": ["    function finalize(FixedGovernanceOpts memory governanceOpts)", "        external", "        onlyDelegateCall", "        returns (Party party_)", "    {", "        // Check that the auction is still active and has not passed the `expiry` time.", "        CrowdfundLifecycle lc = getCrowdfundLifecycle();", "        if (lc != CrowdfundLifecycle.Active && lc != CrowdfundLifecycle.Expired) {", "            revert WrongLifecycleError(lc);", "        }", "        // Mark as busy to prevent burn(), bid(), and contribute()", "        // getting called because this will result in a `CrowdfundLifecycle.Busy`.", "        _bidStatus = AuctionCrowdfundStatus.Busy;", "", "        uint96 lastBid_ = lastBid;", "        // Only finalize on the market if we placed a bid.", "        if (lastBid_ != 0) {", "            uint256 auctionId_ = auctionId;", "            // Finalize the auction if it isn't finalized.", "            if (!market.isFinalized(auctionId_)) {", "                // Note that even if this crowdfund has expired but the auction is still", "                // ongoing, this call can fail and block finalization until the auction ends.", "                (bool s, bytes memory r) = address(market).call(abi.encodeCall(", "                    IMarketWrapper.finalize,", "                    auctionId_", "                ));", "                if (!s) {", "                    r.rawRevert();", "                }", "            }", "        } else {", "            // If we never placed a bid, the auction must have expired.", "            if (lc != CrowdfundLifecycle.Expired) {", "                revert AuctionNotExpiredError();", "            }", "        }", "        // Are we now in possession of the NFT?", "        if (nftContract.safeOwnerOf(nftTokenId) == address(this)) {", "            if (lastBid_ == 0) {", "                // The NFT was gifted to us. Everyone who contributed wins.", "                lastBid_ = totalContributions;", "                if (lastBid_ == 0) {", "                    // Nobody ever contributed. The NFT is effectively burned.", "                    revert NoContributionsError();", "                }", "                lastBid = lastBid_;", "            }", "            // Create a governance party around the NFT.", "            party_ = _createParty(", "                _getPartyFactory(),", "                governanceOpts,", "                nftContract,", "                nftTokenId", "            );", "            emit Won(lastBid_, party_);", "        } else {", "            // Clear `lastBid` so `_getFinalPrice()` is 0 and people can redeem their", "            // full contributions when they burn their participation NFTs.", "            lastBid = 0;", "            emit Lost();", "        }", "", "        _bidStatus = AuctionCrowdfundStatus.Finalized;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function cancel(NounsDAOStorageV3.StorageV3 storage ds, uint256 proposalId) external {", "        NounsDAOStorageV3.ProposalState proposalState = stateInternal(ds, proposalId);", "        if (", "            proposalState == NounsDAOStorageV3.ProposalState.Canceled ||", "            proposalState == NounsDAOStorageV3.ProposalState.Defeated ||", "            proposalState == NounsDAOStorageV3.ProposalState.Expired ||", "            proposalState == NounsDAOStorageV3.ProposalState.Executed ||", "            proposalState == NounsDAOStorageV3.ProposalState.Vetoed", "        ) {", "            revert CantCancelProposalAtFinalState();", "        }", "", "        NounsDAOStorageV3.Proposal storage proposal = ds._proposals[proposalId];", "        address proposer = proposal.proposer;", "        NounsTokenLike nouns = ds.nouns;", "", "        uint256 votes = nouns.getPriorVotes(proposer, block.number - 1);", "        bool msgSenderIsProposer = proposer == msg.sender;", "        address[] memory signers = proposal.signers;", "        for (uint256 i = 0; i < signers.length; ++i) {", "            msgSenderIsProposer = msgSenderIsProposer || msg.sender == signers[i];", "            votes += nouns.getPriorVotes(signers[i], block.number - 1);", "        }", "", "        require(", "            msgSenderIsProposer || votes <= proposal.proposalThreshold,", "            'NounsDAO::cancel: proposer above threshold'", "        );", "", "        proposal.canceled = true;", "        INounsDAOExecutor timelock = getProposalTimelock(ds, proposal);", "        for (uint256 i = 0; i < proposal.targets.length; i++) {", "            timelock.cancelTransaction(", "                proposal.targets[i],", "                proposal.values[i],", "                proposal.signatures[i],", "                proposal.calldatas[i],", "                proposal.eta", "            );", "        }", "", "        emit ProposalCanceled(proposalId);", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function clonePosition(address position, uint256 _initialCollateral, uint256 _initialMint) public validPos(position) returns (address) {", "        IPosition existing = IPosition(position);", "        uint256 limit = existing.reduceLimitForClone(_initialMint);", "        address pos = POSITION_FACTORY.clonePosition(position);", "        zchf.registerPosition(pos);", "        existing.collateral().transferFrom(msg.sender, address(pos), _initialCollateral);", "        IPosition(pos).initializeClone(msg.sender, existing.price(), limit, _initialCollateral, _initialMint);", "        return address(pos);", "    }"], "ner_tags": [0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function setThresholdFactor(uint256 thresholdFactor_) external permissioned {", "        if (thresholdFactor_ > 10000 || thresholdFactor_ < 100) revert RANGE_InvalidParams();", "        thresholdFactor = thresholdFactor_;", "", "        emit ThresholdFactorChanged(thresholdFactor_);", "    }"], "ner_tags": [0, 1, 0, 0, 0, 0]}
{"tokens": ["    function postIncomingMessages(", "        string calldata fromSchainName,", "        uint256 startingCounter,", "        Message[] calldata messages,", "        Signature calldata sign", "    )", "        external", "        override(IMessageProxy, MessageProxy)", "        messageInProgressLocker", "    {", "        uint256 gasTotal = gasleft();", "        bytes32 fromSchainHash = keccak256(abi.encodePacked(fromSchainName));", "        require(_checkSchainBalance(fromSchainHash), \"Schain wallet has not enough funds\");", "        require(connectedChains[fromSchainHash].inited, \"Chain is not initialized\");", "        require(messages.length <= MESSAGES_LENGTH, \"Too many messages\");", "        require(", "            startingCounter == connectedChains[fromSchainHash].incomingMessageCounter,", "            \"Starting counter is not equal to incoming message counter\");", "", "        require(", "            _verifyMessages(", "                fromSchainName,", "                _hashedArray(messages, startingCounter, fromSchainName),", "                sign", "            ),", "            \"Signature is not verified\"", "        );", "        uint additionalGasPerMessage = ", "            (gasTotal - gasleft() + headerMessageGasCost + messages.length * messageGasCost) / messages.length;", "        uint notReimbursedGas = 0;", "        for (uint256 i = 0; i < messages.length; i++) {", "            gasTotal = gasleft();", "            if (isContractRegistered(bytes32(0), messages[i].destinationContract)) {", "                address receiver = _getGasPayer(fromSchainHash, messages[i], startingCounter + i);", "                _callReceiverContract(fromSchainHash, messages[i], startingCounter + i);", "                notReimbursedGas += communityPool.refundGasByUser(", "                    fromSchainHash,", "                    payable(msg.sender),", "                    receiver,", "                    gasTotal - gasleft() + additionalGasPerMessage", "                );", "            } else {", "                _callReceiverContract(fromSchainHash, messages[i], startingCounter + i);", "                notReimbursedGas += gasTotal - gasleft() + additionalGasPerMessage;", "            }", "        }", "        connectedChains[fromSchainHash].incomingMessageCounter += messages.length;", "        communityPool.refundGasBySchainWallet(fromSchainHash, payable(msg.sender), notReimbursedGas);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": ["    function _calcTotalClaimable(", "        address beneficiary,", "        uint256 startEpoch,", "        uint256 endEpoch", "    ) internal view returns (uint256) {", "        uint256 totalClaimable;", "        for (uint256 i = startEpoch; i < endEpoch; i = i.uncheckedInc()) {", "            totalClaimable += (", "                keeperRecords[beneficiary].feesInPeriod[i].scaledDiv(perPeriodTotalFees[i])", "            ).scaledMul(perPeriodTotalInflation[i]);", "        }", "        return totalClaimable;", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function flashFocusCall(FlashFocusParams calldata params) external override {", "        address owner = ownerOf[params.tokenId];", "        (, , address token0, address token1, , , , , , , , ) = nonfungiblePositionManager.positions(params.tokenId);", "", "        bool tokenOfPool = params.asset == token0 || params.asset == token1;", "", "        require(!peripheryGuardianPaused, \"periphery functionality is paused\");", "        require(msg.sender == address(flashLoan), \"Can only be called from our flashLoan contract\");", "        require(flashLoanAuthorized[owner], \"flashLoan action must have been authorized by tokenId owner\");", "        require(", "            tokenOfPool || params.swapPath.length > 0,", "            \"flashLoaned asset must be a pool asset or swapping to token0\"", "        );", "        require(_checkSwapPath(params.swapPath, params.asset, token0), \"swapPath did not pass integrity check\");", "", "        flashLoanAuthorized[owner] = false;", "", "        // transfer flashLoaned assets to vault", "        IERC20Detailed(params.asset).transferFrom(msg.sender, address(this), params.amount);", "", "        uint256 amount0;", "        uint256 amount1;", "", "        {", "            // creating local scope, avoiding stack too deep", "", "            // calculate our starting amounts of each asset", "            uint256 amountIn0 = params.asset == token0 ? params.amount : 0;", "            uint256 amountIn1 = params.asset == token1 ? params.amount : 0;", "", "            // swap everything to token0 if swap path is provided and params.asset is neither of the tokens", "            if (!tokenOfPool && params.swapPath.length > 0) amountIn0 = _swap(params.swapPath, params.amount);", "", "            (, , , , uint24 fee, , , , , , , ) = nonfungiblePositionManager.positions(params.tokenId);", "", "            // trade assets to expectedAmounts (assuming correct off-chain computation)", "            (amount0, amount1) = _prepareForDeposit(", "                token0,", "                token1,", "                fee,", "                params.expectedAmount0,", "                params.expectedAmount1,", "                amountIn0,", "                amountIn1", "            );", "        }", "", "        // attempt to deposit amount0 and amount1 into our range", "        (uint256 amountTaken0, uint256 amountTaken1) = _increaseLiquidity(", "            params.tokenId,", "            token0,", "            token1,", "            amount0,", "            amount1,", "            params.amount0Min,", "            params.amount1Min", "        );", "", "        {", "            // another local scope :)", "            uint256 owedBack = params.amount.add(params.premium);", "", "            // borrow the flashloaned asset in preparation for closing loan", "            uint256 success = CErc20Interface(comptroller.cTokensByUnderlying(params.asset)).borrowBehalf(", "                owner,", "                owedBack", "            );", "            require(success == 0, \"borrow failed\");", "", "            // approve borrowed assets for flashLoan to pull", "            IERC20Detailed(params.asset).approve(msg.sender, owedBack);", "        }", "", "        uint256 amountReturned0 = amount0 > amountTaken0 ? amount0.sub(amountTaken0) : 0;", "        uint256 amountReturned1 = amount1 > amountTaken1 ? amount1.sub(amountTaken1) : 0;", "", "        // send back remnants to user", "        if (amountReturned0 > 0) TransferHelper.safeTransfer(token0, msg.sender, amountReturned0);", "        if (amountReturned1 > 0) TransferHelper.safeTransfer(token1, msg.sender, amountReturned1);", "        emit FlashFocus(", "            msg.sender,", "            params.tokenId,", "            params.asset,", "            params.amount,", "            amountTaken0,", "            amountTaken1,", "            amountReturned0,", "            amountReturned1", "        );", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function lock(uint256 amount, uint256 duration) external {", "        if(emergency) revert EmergencyBlock();", "        // Update user rewards before any change on their balance (staked and locked)", "        _updateUserRewards(msg.sender);", "        if(delegates[msg.sender] == address(0)){", "            // If the user does not deelegate currently, automatically self-delegate", "            _delegate(msg.sender, msg.sender);", "        }", "        _lock(msg.sender, amount, duration, LockAction.LOCK);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function previewWithdraw(uint256 assets)", "        public", "        view", "        override", "        returns (uint256)", "    {", "        // Calculate shares based on the specified assets' proportion of the pool", "        uint256 shares = convertToShares(assets);", "", "        // Save 1 SLOAD", "        uint256 _totalSupply = totalSupply;", "", "        // Factor in additional shares to fulfill withdrawal if user is not the last to withdraw", "        return", "            (_totalSupply == 0 || _totalSupply - shares == 0)", "                ? shares", "                : (shares * FEE_DENOMINATOR) /", "                    (FEE_DENOMINATOR - withdrawalPenalty);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function setFlywheelRewards(IFlywheelRewards newFlywheelRewards) external requiresAuth {", "        uint256 oldRewardBalance = rewardToken.balanceOf(address(flywheelRewards));", "        if (oldRewardBalance > 0) {", "            rewardToken.safeTransferFrom(address(flywheelRewards), address(newFlywheelRewards), oldRewardBalance);", "        }", "", "        flywheelRewards = newFlywheelRewards;", "", "        emit FlywheelRewardsUpdate(address(newFlywheelRewards));", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": ["    function setDuration(uint256 _duration) external onlyOwner {", "        settings.duration = SafeCast.toUint40(_duration);", "", "        emit DurationUpdated(_duration);", "    }"], "ner_tags": [1, 1, 1, 1, 1]}
{"tokens": ["    function swapTokensGeneric(LiFiData memory _lifiData, LibSwap.SwapData[] calldata _swapData) public payable {", "        uint256 receivingAssetIdBalance = LibAsset.getOwnBalance(_lifiData.receivingAssetId);", "", "        // Swap", "        _executeSwaps(_lifiData, _swapData);", "", "        uint256 postSwapBalance = LibAsset.getOwnBalance(_lifiData.receivingAssetId) - receivingAssetIdBalance;", "", "        LibAsset.transferAsset(_lifiData.receivingAssetId, payable(msg.sender), postSwapBalance);", "", "        emit LiFiTransferStarted(", "            _lifiData.transactionId,", "            _lifiData.integrator,", "            _lifiData.referrer,", "            _lifiData.sendingAssetId,", "            _lifiData.receivingAssetId,", "            _lifiData.receiver,", "            _lifiData.amount,", "            _lifiData.destinationChainId,", "            block.timestamp", "        );", "    }"], "ner_tags": [0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function claim(uint256 _poolId, bytes32[] calldata _mintProof) external {", "        // Reverts if pool ID is not valid", "        _verifyPool(_poolId);", "        // Reverts if purchase has not been made AND termination period has not passed", "        (, , , bool success, ) = _verifySuccessfulState(_poolId);", "        // Reverts if contribution balance of user is insufficient", "        uint256 contribution = userContributions[_poolId][msg.sender];", "        if (contribution == 0) revert InsufficientBalance();", "", "        // Deletes user contribution from storage", "        delete userContributions[_poolId][msg.sender];", "", "        // Set up scoped values for iteration", "        uint256 totalQty;", "        uint256 reservePrice = minReservePrices[_poolId];", "        uint256[] memory bidIds = getOwnerToBidIds(_poolId, msg.sender);", "        uint256 length = bidIds.length;", "", "        // Iterates through all active bidIds of the caller", "        if (success) {", "            for (uint256 i; i < length; ++i) {", "                // Gets bid quantity from storage", "                Bid storage bid = bidPriorityQueues[_poolId].bidIdToBidMap[bidIds[i]];", "                uint256 quantity = bid.quantity;", "                // Resets bid quantity amount", "                bid.quantity = 0;", "                // Increments total quantity of Raes to be minted", "                totalQty += quantity;", "                // Decrements quantity price from total user contribution balance", "                contribution -= quantity * reservePrice;", "            }", "", "            // Mints total quantity of Raes to caller", "            _mintRaes(poolToVault[_poolId], msg.sender, totalQty, _mintProof);", "        }", "", "        // Transfers remaining contribution balance back to caller", "        payable(msg.sender).call{value: contribution}(\"\");", "", "        // Withdraws pending balance of caller if available", "        if (pendingBalances[msg.sender] > 0) withdrawBalance();", "", "        // Emits event for claiming tokens and receiving ether refund", "        emit Claim(_poolId, msg.sender, totalQty, contribution);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function createPair(address tokenA, address tokenB, bool stable) external returns (address pair) {", "        require(tokenA != tokenB, \"IA\"); // BaseV1: IDENTICAL_ADDRESSES", "        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);", "        require(token0 != address(0), \"ZA\"); // BaseV1: ZERO_ADDRESS", "        require(getPair[token0][token1][stable] == address(0), \"PE\"); // BaseV1: PAIR_EXISTS - single check is sufficient", "        bytes32 salt = keccak256(abi.encodePacked(token0, token1, stable)); // notice salt includes stable as well, 3 parameters", "        (_temp0, _temp1, _temp) = (token0, token1, stable);", "        pair = address(new BaseV1Pair{salt:salt}());", "        getPair[token0][token1][stable] = pair;", "        getPair[token1][token0][stable] = pair; // populate mapping in the reverse direction", "        allPairs.push(pair);", "        isPair[pair] = true;", "        emit PairCreated(token0, token1, stable, pair, allPairs.length);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function createLock(uint256 _value, uint256 _unlockTime)", "        external", "        override", "        nonReentrant", "        checkBlocklist", "    {", "        uint256 unlock_time = _floorToWeek(_unlockTime); // Locktime is rounded down to weeks", "        LockedBalance memory locked_ = locked[msg.sender];", "        // Validate inputs", "        require(_value > 0, \"Only non zero amount\");", "        require(locked_.amount == 0, \"Lock exists\");", "        require(unlock_time >= locked_.end, \"Only increase lock end\"); // from using quitLock, user should increaseAmount instead", "        require(unlock_time > block.timestamp, \"Only future lock end\");", "        require(unlock_time <= block.timestamp + MAXTIME, \"Exceeds maxtime\");", "        // Update lock and voting power (checkpoint)", "        locked_.amount += int128(int256(_value));", "        locked_.end = unlock_time;", "        locked_.delegated += int128(int256(_value));", "        locked_.delegatee = msg.sender;", "        locked[msg.sender] = locked_;", "        _checkpoint(msg.sender, LockedBalance(0, 0, 0, address(0)), locked_);", "        // Deposit locked tokens", "        require(", "            token.transferFrom(msg.sender, address(this), _value),", "            \"Transfer failed\"", "        );", "        emit Deposit(", "            msg.sender,", "            _value,", "            unlock_time,", "            LockAction.CREATE,", "            block.timestamp", "        );", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _payFees(", "        address payer,", "        address beneficiary,", "        uint256 feeAmount,", "        address depositToken", "    ) internal {", "        address feeHandler = getFeeHandler();", "        IERC20(depositToken).safeApprove(feeHandler, feeAmount);", "        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["    function getOracle2_Price() public view returns (int256 price) {", "        (", "            uint80 roundID2,", "            int256 price2,", "            ,", "            uint256 timeStamp2,", "            uint80 answeredInRound2", "        ) = priceFeed2.latestRoundData();", "", "        require(price2 > 0, \"Chainlink price <= 0\");", "        require(", "            answeredInRound2 >= roundID2,", "            \"RoundID from Oracle is outdated!\"", "        );", "        require(timeStamp2 != 0, \"Timestamp == 0 !\");", "", "        return price2;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["    function _settleZoraAuction(", "        uint256 auctionId,", "        uint40 minExpiry,", "        IERC721 token,", "        uint256 tokenId", "    )", "        internal", "        override", "        returns (bool sold)", "    {", "        // Getting the state of an auction is super expensive so it seems", "        // cheaper to just let `endAuction()` fail and react to the error.", "        try ZORA.endAuction(auctionId) {", "            // Check whether auction cancelled due to a failed transfer during", "            // settlement by seeing if we now possess the NFT.", "            if (token.safeOwnerOf(tokenId) == address(this)) {", "                emit ZoraAuctionFailed(auctionId);", "                return false;", "            }", "        } catch (bytes memory errData) {", "            bytes32 errHash = keccak256(errData);", "            if (errHash == AUCTION_HASNT_BEGUN_ERROR_HASH) {", "                // No bids placed.", "                // Cancel if we're past the timeout.", "                if (minExpiry > uint40(block.timestamp)) {", "                    revert ZoraListingNotExpired(auctionId, minExpiry);", "                }", "                ZORA.cancelAuction(auctionId);", "                emit ZoraAuctionExpired(auctionId, minExpiry);", "                return false;", "            } else if (errHash != AUCTION_DOESNT_EXIST_ERROR_HASH) {", "                // Otherwise, we should get an auction doesn't exist error,", "                // because someone else must have called `endAuction()`.", "                // If we didn't then something is wrong, so revert.", "                errData.rawRevert();", "            }", "            // Already ended by someone else. Nothing to do.", "        }", "        emit ZoraAuctionSold(auctionId);", "        return true;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function transferBribes(", "        Common.Distribution[] calldata distributions,", "        uint256[] calldata amounts,", "        uint256[] calldata fees", "    ) external onlyRole(DEFAULT_ADMIN_ROLE) {", "        require(distributions.length > 0, \"Invalid distributions\");", "        require(", "            distributions.length == amounts.length &&", "                distributions.length == fees.length,", "            \"Distributions, amounts, and fees must contain the same # of elements\"", "        );", "", "        // Transfer the bribe funds to fee recipient and reward distributor", "        for (uint256 i = 0; i < distributions.length; i++) {", "            bytes32 rewardIdentifier = distributions[i].rewardIdentifier;", "            uint256 distributorAmount = amounts[i];", "            uint256 feeAmount = fees[i];", "            address token = distributions[i].token;", "            require(", "                rewardToBribes[rewardIdentifier].length > 0,", "                \"Invalid reward identifier\"", "            );", "            require(token != address(0), \"Invalid token address\");", "            require(distributorAmount > 0, \"Invalid pending reward amount\");", "", "            // Check whether it's a native token reward", "            if (token == address(this)) {", "                (bool sentFeeRecipient, ) = feeRecipient.call{value: feeAmount}(", "                    \"\"", "                );", "                require(", "                    sentFeeRecipient,", "                    \"Failed to transfer to fee recipient\"", "                );", "", "                (bool sentDistributor, ) = distributor.call{", "                    value: distributorAmount", "                }(\"\");", "                require(sentDistributor, \"Failed to transfer to distributor\");", "            } else {", "                IERC20(token).transfer(feeRecipient, feeAmount);", "                IERC20(token).transfer(distributor, distributorAmount);", "            }", "", "            emit TransferBribe(", "                rewardIdentifier,", "                token,", "                distributions[i].proof,", "                feeAmount,", "                distributorAmount", "            );", "        }", "", "        // Update the rewards' metadata", "        IRewardDistributor(distributor).updateRewardsMetadata(distributions);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function withdraw(", "        address _assetAddress,", "        address _to,", "        uint256 _amount", "    ) public {", "        LibDiamond.enforceIsContractOwner();", "        address sendTo = (_to == address(0)) ? msg.sender : _to;", "        uint256 assetBalance;", "        if (_assetAddress == NATIVE_ASSET) {", "            address self = address(this); // workaround for a possible solidity bug", "            assert(_amount <= self.balance);", "            payable(sendTo).transfer(_amount);", "        } else {", "            assetBalance = IERC20(_assetAddress).balanceOf(address(this));", "            assert(_amount <= assetBalance);", "            IERC20(_assetAddress).safeTransfer(sendTo, _amount);", "        }", "        emit LogWithdraw(sendTo, _assetAddress, _amount);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _payInk(", "        DataTypes.Auction memory auction_,", "        address to,", "        uint256 liquidatorCut,", "        uint256 auctioneerCut", "    ) internal {", "        // If liquidatorCut is 0, then auctioneerCut is 0 too, so no need to double check", "        if (liquidatorCut > 0) {", "            IJoin ilkJoin = ladle.joins(auction_.ilkId);", "            require(ilkJoin != IJoin(address(0)), \"Join not found\");", "", "            // Pay auctioneer's cut if necessary", "            if (auctioneerCut > 0) {", "                ilkJoin.exit(auction_.auctioneer, auctioneerCut.u128());", "            }", "", "            // Give collateral to the liquidator", "            ilkJoin.exit(to, liquidatorCut.u128());", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function redeem(address to, uint256 amountIn) external nonReentrant {", "        IERC20(redeemedToken).safeTransferFrom(msg.sender, address(this), amountIn);", "", "        (address[] memory tokens, uint256[] memory amountsOut) = previewRedeem(amountIn);", "", "        uint256 base = redeemBase;", "        redeemBase = base - amountIn; // decrement the base for future redemptions", "        for (uint256 i = 0; i < tokens.length; i++) {", "            IERC20(tokens[i]).safeTransfer(to, amountsOut[i]);", "        }", "", "        emit Redeemed(msg.sender, to, amountIn, base);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function placeMarketMakingTrades(", "        address[2] memory tokenPair, // ASSET, Then Quote", "        uint256 askNumerator, // Quote / Asset", "        uint256 askDenominator, // Asset / Quote", "        uint256 bidNumerator, // size in ASSET", "        uint256 bidDenominator // size in QUOTES", "    ) public onlyApprovedStrategist(msg.sender) returns (uint256 id) {", "        // Require at least one order is non-zero", "        require(", "            (askNumerator > 0 && askDenominator > 0) ||", "                (bidNumerator > 0 && bidDenominator > 0),", "            \"one order must be non-zero\"", "        );", "", "        address _underlyingAsset = tokenPair[0];", "        address _underlyingQuote = tokenPair[1];", "", "        (", "            address bathAssetAddress,", "            address bathQuoteAddress", "        ) = enforceReserveRatio(_underlyingAsset, _underlyingQuote);", "", "        require(", "            bathAssetAddress != address(0) && bathQuoteAddress != address(0),", "            \"tokenToBathToken error\"", "        );", "", "        // Calculate new bid and/or ask", "        order memory ask = order(", "            askNumerator,", "            IERC20(_underlyingAsset),", "            askDenominator,", "            IERC20(_underlyingQuote)", "        );", "        order memory bid = order(", "            bidNumerator,", "            IERC20(_underlyingQuote),", "            bidDenominator,", "            IERC20(_underlyingAsset)", "        );", "", "        // Place new bid and/or ask", "        // Note: placeOffer returns a zero if an incomplete order", "        uint256 newAskID = IBathToken(bathAssetAddress).placeOffer(", "            ask.pay_amt,", "            ask.pay_gem,", "            ask.buy_amt,", "            ask.buy_gem", "        );", "", "        uint256 newBidID = IBathToken(bathQuoteAddress).placeOffer(", "            bid.pay_amt,", "            bid.pay_gem,", "            bid.buy_amt,", "            bid.buy_gem", "        );", "", "        // Strategist trade is recorded so they can get paid and the trade is logged for time", "        StrategistTrade memory outgoing = StrategistTrade(", "            newAskID,", "            ask.pay_amt,", "            _underlyingAsset,", "            newBidID,", "            bid.pay_amt,", "            _underlyingQuote,", "            msg.sender,", "            block.timestamp", "        );", "", "        // Give each trade a unique id for easy handling by strategists", "        id = _next_id();", "        strategistTrades[id] = outgoing;", "        // Allow strategists to easily call a list of their outstanding offers", "        outOffersByStrategist[_underlyingAsset][_underlyingQuote][msg.sender]", "            .push(id);", "", "        emit LogStrategistTrade(", "            id,", "            bytes32(outgoing.askId),", "            bytes32(outgoing.bidId),", "            outgoing.askAsset,", "            outgoing.bidAsset,", "            block.timestamp,", "            outgoing.strategist", "        );", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function _payoutToken(address tokenAddress) private {", "    address payable[] memory addresses = _getPayoutAddresses();", "    uint256[] memory bps = _getPayoutBps();", "    uint256 length = addresses.length;", "    ERC20 erc20 = ERC20(tokenAddress);", "    uint256 balance = erc20.balanceOf(address(this));", "    require(balance > 10000, \"PA1D: Not enough tokens to transfer\");", "    uint256 sending;", "    //uint256 sent;", "    for (uint256 i = 0; i < length; i++) {", "      sending = ((bps[i] * balance) / 10000);", "      require(erc20.transfer(addresses[i], sending), \"PA1D: Couldn't transfer token\");", "      // sent = sent + sending;", "    }", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["    function setReserveFactor(uint32 reserveFactor_) external onlyRole(\"operator_policy\") {", "        /// Confirm factor is within allowed values", "        if (reserveFactor_ > 10000 || reserveFactor_ < 100) revert Operator_InvalidParams();", "", "        /// Set factor", "        _config.reserveFactor = reserveFactor_;", "", "        emit ReserveFactorChanged(reserveFactor_);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function flashLoan(", "        address _to,", "        uint256 _amountXOut,", "        uint256 _amountYOut,", "        bytes calldata _data", "    ) external override nonReentrant {", "        FeeHelper.FeeParameters memory _fp = _feeParameters;", "", "        uint256 _fee = factory.flashLoanFee();", "", "        FeeHelper.FeesDistribution memory _feesX = _fp.getFeeAmountDistribution(_getFlashLoanFee(_amountXOut, _fee));", "        FeeHelper.FeesDistribution memory _feesY = _fp.getFeeAmountDistribution(_getFlashLoanFee(_amountYOut, _fee));", "", "        (uint256 _reserveX, uint256 _reserveY, uint256 _id) = _getReservesAndId();", "", "        tokenX.safeTransfer(_to, _amountXOut);", "        tokenY.safeTransfer(_to, _amountYOut);", "", "        ILBFlashLoanCallback(_to).LBFlashLoanCallback(", "            msg.sender,", "            _amountXOut,", "            _amountYOut,", "            _feesX.total,", "            _feesY.total,", "            _data", "        );", "", "        _feesX.flashLoanHelper(_pairInformation.feesX, tokenX, _reserveX);", "        _feesY.flashLoanHelper(_pairInformation.feesY, tokenY, _reserveY);", "", "        uint256 _totalSupply = totalSupply(_id);", "", "        _bins[_id].accTokenXPerShare += _feesX.getTokenPerShare(_totalSupply);", "        _bins[_id].accTokenYPerShare += _feesY.getTokenPerShare(_totalSupply);", "", "        emit FlashLoan(msg.sender, _to, _amountXOut, _amountYOut, _feesX.total, _feesY.total);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0]}
{"tokens": ["    function transferAllowed(address cAsset, address src, address dst, uint transferTokens) external returns (uint) {", "        // Pausing is a very serious situation - we revert to sound the alarms", "        require(!transferGuardianPaused, \"transfer is paused\");", "", "        // Currently the only consideration is whether or not", "        //  the src is allowed to redeem this many tokens", "        uint allowed = redeemAllowedInternal(cAsset, src, transferTokens);", "        if (allowed != uint(Error.NO_ERROR)) {", "            return allowed;", "        }", "", "        // Keep the flywheel moving", "        // updateCompSupplyIndex(cAsset);", "        // distributeSupplierComp(cAsset, src);", "        // distributeSupplierComp(cAsset, dst);", "", "        return uint(Error.NO_ERROR);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": ["    function execute(bytes calldata input) external override {", "        (bytes memory data, bytes[] memory signatures) = abi.decode(input, (bytes, bytes[]));", "", "        _execute(data, signatures);", "    }"], "ner_tags": [1, 0, 0, 0, 0]}
{"tokens": ["    function depositAndRepay(uint256 amount)", "        external", "        payable", "        override", "        whileBorrowing", "        returns (bool)", "    {", "        bytes32 id = ids[0];", "        Credit memory credit = credits[id];", "        credit = _accrue(credit, id);", "", "        require(amount <= credit.principal + credit.interestAccrued);", "", "        credits[id] = _repay(credit, id, amount);", "", "        LineLib.receiveTokenOrETH(credit.token, msg.sender, amount);", "", "        return true;", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _lock(address _account, uint256 _amount) internal {", "        require(_amount > 0, \"Cannot stake 0\");", "        require(!isShutdown, \"shutdown\");", "", "        Balances storage bal = balances[_account];", "", "        //must try check pointing epoch first", "        _checkpointEpoch();", "", "        //add user balances", "        uint112 lockAmount = _amount.to112();", "        bal.locked = bal.locked.add(lockAmount);", "", "        //add to total supplies", "        lockedSupply = lockedSupply.add(_amount);", "", "        //add user lock records or add to current", "        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);", "        uint256 unlockTime = currentEpoch.add(lockDuration);", "        uint256 idx = userLocks[_account].length;", "        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {", "            userLocks[_account].push(LockedBalance({ amount: lockAmount, unlockTime: uint32(unlockTime) }));", "        } else {", "            LockedBalance storage userL = userLocks[_account][idx - 1];", "            userL.amount = userL.amount.add(lockAmount);", "        }", "", "        address delegatee = delegates(_account);", "        if (delegatee != address(0)) {", "            delegateeUnlocks[delegatee][unlockTime] += lockAmount;", "            _checkpointDelegate(delegatee, lockAmount, 0);", "        }", "", "        //update epoch supply, epoch checkpointed above so safe to add to latest", "        Epoch storage e = epochs[epochs.length - 1];", "        e.supply = e.supply.add(lockAmount);", "", "        emit Staked(_account, lockAmount, lockAmount);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function recall(uint amount) public {", "        require(msg.sender == lender, \"Only lender can recall\");", "        dola.transfer(msg.sender, amount);", "    }"], "ner_tags": [0, 0, 1, 0]}
{"tokens": ["    function setDebtInterestApr(Rate memory _debtInterestApr)", "        external", "        onlyRole(DAO_ROLE)", "    {", "        _validateRate(_debtInterestApr);", "        settings.debtInterestApr = _debtInterestApr;", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function repayLender(", "        uint256 _communityID,", "        address _project,", "        uint256 _repayAmount", "    )", "        external", "        virtual", "        override", "        nonReentrant", "        whenNotPaused", "        onlyProjectBuilder(_project)", "    {", "        // Internally call reduce debt", "        _reduceDebt(_communityID, _project, _repayAmount, \"0x\");", "", "        // Local instance of variable. For saving gas.", "        address _lender = _communities[_communityID].owner;", "", "        // Transfer repayment to lender", "        _communities[_communityID].currency.safeTransferFrom(", "            _msgSender(),", "            _lender,", "            _repayAmount", "        );", "", "        emit RepayLender(_communityID, _project, _lender, _repayAmount);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function initiateWithdrawal(uint256 _amount) external override {", "        /**", "         * Checking the balance before initiation is necessary since a user", "         * could initiate an unlimited withdrawal amount ahead of time,", "         * negating the protection a delayed withdrawal offers.", "         */", "        require(balanceOf(msg.sender) >= _amount, \"Insufficient balance\");", "        _accountToWithdrawalRequest[msg.sender].amount = _amount;", "        _accountToWithdrawalRequest[msg.sender].blockNumber = block.number;", "    }"], "ner_tags": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function executeAsSmartWallet(", "        address _nodeRunner,", "        address _to,", "        bytes calldata _data,", "        uint256 _value", "    ) external payable onlyDAO {", "        address smartWallet = smartWalletOfNodeRunner[_nodeRunner];", "        require(smartWallet != address(0), \"No wallet found\");", "        IOwnableSmartWallet(smartWallet).execute(", "            _to,", "            _data,", "            _value", "        );", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function fundingVote(", "        FundingVoteParams[] memory voteParams_", "    ) external override returns (uint256 votesCast_) {", "        uint24 currentDistributionId = _currentDistributionId;", "", "        QuarterlyDistribution storage currentDistribution = _distributions[currentDistributionId];", "        QuadraticVoter        storage voter               = _quadraticVoters[currentDistributionId][msg.sender];", "", "        uint256 endBlock = currentDistribution.endBlock;", "", "        uint256 screeningStageEndBlock = _getScreeningStageEndBlock(endBlock);", "", "        // check that the funding stage is active", "        if (block.number <= screeningStageEndBlock || block.number > endBlock) revert InvalidVote();", "", "        uint128 votingPower = voter.votingPower;", "", "        // if this is the first time a voter has attempted to vote this period,", "        // set initial voting power and remaining voting power", "        if (votingPower == 0) {", "", "            // calculate the voting power available to the voting power in this funding stage", "            uint128 newVotingPower = SafeCast.toUint128(_getVotesFunding(msg.sender, votingPower, voter.remainingVotingPower, screeningStageEndBlock));", "", "            voter.votingPower          = newVotingPower;", "            voter.remainingVotingPower = newVotingPower;", "        }", "", "        uint256 numVotesCast = voteParams_.length;", "", "        for (uint256 i = 0; i < numVotesCast; ) {", "            Proposal storage proposal = _standardFundingProposals[voteParams_[i].proposalId];", "", "            // check that the proposal is part of the current distribution period", "            if (proposal.distributionId != currentDistributionId) revert InvalidVote();", "", "            // check that the proposal being voted on is in the top ten screened proposals", "            if (_findProposalIndex(voteParams_[i].proposalId, _topTenProposals[currentDistributionId]) == -1) revert InvalidVote();", "", "            // cast each successive vote", "            votesCast_ += _fundingVote(", "                currentDistribution,", "                proposal,", "                msg.sender,", "                voter,", "                voteParams_[i]", "            );", "", "            unchecked { ++i; }", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function approveMarket() external onlyBathHouse {", "        underlyingToken.approve(RubiconMarketAddress, 2**256 - 1);", "    }"], "ner_tags": [0, 1, 0]}
{"tokens": ["  function sourceTransfer(address to, uint256 tokenId) external onlySource {", "    address wallet = _tokenOwner[tokenId];", "    _transferFrom(wallet, to, tokenId);", "  }"], "ner_tags": [1, 0, 0, 0]}
{"tokens": ["    function addTasks(bytes calldata _data, bytes calldata _signature)", "        external", "        override", "    {", "        // If the sender is disputes contract, then do not check for signatures.", "        if (_msgSender() != disputes) {", "            // Check for required signatures", "            checkSignature(_data, _signature);", "        }", "", "        // Decode params from _data", "        (", "            bytes[] memory _hash,", "            uint256[] memory _taskCosts,", "            uint256 _taskCount,", "            address _projectAddress", "        ) = abi.decode(_data, (bytes[], uint256[], uint256, address));", "", "        // Revert if decoded taskCount is incorrect. This indicates wrong data.", "        require(_taskCount == taskCount, \"Project::!taskCount\");", "", "        // Revert if decoded project address does not match this contract. Indicating incorrect _data.", "        require(_projectAddress == address(this), \"Project::!projectAddress\");", "", "        // Revert if IPFS hash array length is not equal to task cost array length.", "        uint256 _length = _hash.length;", "        require(_length == _taskCosts.length, \"Project::Lengths !match\");", "", "        // Loop over all the new tasks.", "        for (uint256 i = 0; i < _length; i++) {", "            // Increment local task counter.", "            _taskCount += 1;", "", "            // Check task cost precision. Revert if too precise.", "            checkPrecision(_taskCosts[i]);", "", "            // Initialize task.", "            tasks[_taskCount].initialize(_taskCosts[i]);", "        }", "", "        // Update task counter equal to local task counter.", "        taskCount = _taskCount;", "", "        emit TasksAdded(_taskCosts, _hash);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function _packAndStoreIntrinsicPropertiesOf(", "    uint256 _configuration,", "    uint256 _projectId,", "    uint256 _number,", "    uint256 _weight,", "    uint256 _basedOn,", "    uint256 _start", "  ) private {", "    // weight in bits 0-87.", "    uint256 packed = _weight;", "", "    // basedOn in bits 88-143.", "    packed |= _basedOn << 88;", "", "    // start in bits 144-199.", "    packed |= _start << 144;", "", "    // number in bits 200-255.", "    packed |= _number << 200;", "", "    // Store the packed value.", "    _packedIntrinsicPropertiesOf[_projectId][_configuration] = packed;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": ["    function redeem(", "        uint8 p,", "        address u,", "        uint256 m,", "        address d,", "        address o", "    ) public returns (bool) {", "        // Check the principal is Sense", "        if (p != uint8(MarketPlace.Principals.Sense)) {", "            revert Invalid('principal');", "        }", "", "        // Get the principal token for the given market", "        IERC20 token = IERC20(IMarketPlace(marketPlace).markets(u, m, p));", "", "        // Get the balance of tokens to be redeemed by the user", "        uint256 amount = token.balanceOf(lender);", "", "        // Transfer the user's tokens to the redeem contract", "        Safe.transferFrom(token, lender, address(this), amount);", "", "        // Redeem the tokens from the Sense contract", "        ISense(d).redeem(o, m, amount);", "", "        emit Redeem(p, u, m, amount);", "        return true;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["    function initializeReceiverWith(", "        address _fantomSender,", "        uint256 _eligibleWEVE,", "        uint256 _redeemableUSDC,", "        uint256 _redeemableVELO", "    ) external {", "        require(msg.sender == deployer, \"ONLY_DEPLOYER\");", "        require(fantomSender == address(0), \"ALREADY_INITIALIZED\");", "        require(", "            USDC.transferFrom(msg.sender, address(this), _redeemableUSDC),", "            \"USDC_TRANSFER_FAILED\"", "        );", "        require(", "            VELO.mintToRedemptionReceiver(_redeemableVELO),", "            \"VELO_MINT_FAILED\"", "        );", "        fantomSender = _fantomSender;", "        eligibleWEVE = _eligibleWEVE;", "        redeemableUSDC = _redeemableUSDC;", "        redeemableVELO = _redeemableVELO;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function invariant(uint256 amount0, uint256 amount1, uint256 liquidity) public view override returns (bool) {", "    if (liquidity == 0) return (amount0 == 0 && amount1 == 0);", "", "    uint256 scale0 = FullMath.mulDiv(amount0, 1e18, liquidity) * token0Scale;", "    uint256 scale1 = FullMath.mulDiv(amount1, 1e18, liquidity) * token1Scale;", "", "    if (scale1 > 2 * upperBound) revert InvariantError();", "", "    uint256 a = scale0 * 1e18;", "    uint256 b = scale1 * upperBound;", "    uint256 c = (scale1 * scale1) / 4;", "    uint256 d = upperBound * upperBound;", "", "    return a + b >= c + d;", "  }"], "ner_tags": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function supportsInterface(", "        bytes4 interfaceId", "    )", "        public", "        view", "        override(ERC721Upgradeable, AccessControlUpgradeable, ERC2981Upgradeable)", "        returns (bool)", "    {", "        return super.supportsInterface(interfaceId);", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function auction(bytes12 vaultId, address to)", "        external", "        returns (DataTypes.Auction memory auction_)", "    {", "        DataTypes.Vault memory vault = cauldron.vaults(vaultId);", "        if (vault.owner == address(this) || otherWitches[vault.owner]) {", "            revert VaultAlreadyUnderAuction(vaultId, vault.owner);", "        }", "        DataTypes.Series memory series = cauldron.series(vault.seriesId);", "        if (ignoredPairs[vault.ilkId][series.baseId]) {", "            revert VaultNotLiquidable(vaultId, vault.ilkId, series.baseId);", "        }", "", "        require(cauldron.level(vaultId) < 0, \"Not undercollateralized\");", "", "        DataTypes.Balances memory balances = cauldron.balances(vaultId);", "        DataTypes.Debt memory debt = cauldron.debt(series.baseId, vault.ilkId);", "", "        // There is a limit on how much collateral can be concurrently put at auction, but it is a soft limit.", "        // If the limit has been surpassed, no more vaults of that collateral can be put for auction.", "        // This avoids the scenario where some vaults might be too large to be auctioned.", "        DataTypes.Limits memory limits_ = limits[vault.ilkId][", "            series.baseId", "        ];", "        require(limits_.sum <= limits_.max, \"Collateral limit reached\");", "", "        auction_ = _calcAuction(vault, series, to, balances, debt);", "", "        limits_.sum += auction_.ink;", "        limits[vault.ilkId][series.baseId] = limits_;", "", "        auctions[vaultId] = auction_;", "", "        _auctionStarted(vaultId);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function fillOrder(", "        Order memory order,", "        bytes calldata signature,", "        uint256[] memory floorAssetTokenIds", "    ) public payable returns (uint256 positionId) {", "        /* ~~~ CHECKS ~~~ */", "", "        bytes32 orderHash = hashOrder(order);", "", "        // check signature is valid using EIP-712", "        require(SignatureChecker.isValidSignatureNow(order.maker, orderHash, signature), \"Invalid signature\");", "", "        // check order is not cancelled", "        require(!cancelledOrders[orderHash], \"Order has been cancelled\");", "", "        // check msg.sender is allowed to fill the order", "        require(order.whitelist.length == 0 || isWhitelisted(order.whitelist, msg.sender), \"Not whitelisted\");", "", "        // check duration is valid", "        require(order.duration < 10_000 days, \"Duration too long\");", "", "        // check order has not expired", "        require(block.timestamp < order.expiration, \"Order has expired\");", "", "        // check base asset exists", "        require(order.baseAsset.code.length > 0, \"baseAsset is not contract\");", "", "        // check floor asset token ids length is 0 unless the order type is call and side is long", "        order.isCall && order.isLong", "            ? require(floorAssetTokenIds.length == order.floorTokens.length, \"Wrong amount of floor tokenIds\")", "            : require(floorAssetTokenIds.length == 0, \"Invalid floor tokens length\");", "", "        /*  ~~~ EFFECTS ~~~ */", "", "        // create long/short position for maker", "        _mint(order.maker, uint256(orderHash));", "", "        // create opposite long/short position for taker", "        bytes32 oppositeOrderHash = hashOppositeOrder(order);", "        positionId = uint256(oppositeOrderHash);", "        _mint(msg.sender, positionId);", "", "        // save floorAssetTokenIds if filling a long call order", "        if (order.isLong && order.isCall) {", "            positionFloorAssetTokenIds[uint256(orderHash)] = floorAssetTokenIds;", "        }", "", "        // save the long position expiration", "        positionExpirations[order.isLong ? uint256(orderHash) : positionId] = block.timestamp + order.duration;", "", "        emit FilledOrder(orderHash, floorAssetTokenIds, order);", "", "        /* ~~~ INTERACTIONS ~~~ */", "", "        // transfer premium to whoever is short from whomever is long", "        if (order.isLong) {", "            ERC20(order.baseAsset).safeTransferFrom(order.maker, msg.sender, order.premium);", "        } else {", "            // handle the case where the user uses native ETH instead of WETH to pay the premium", "            if (weth == order.baseAsset && msg.value > 0) {", "                // check enough ETH was sent to cover the premium", "                require(msg.value == order.premium, \"Incorrect ETH amount sent\");", "", "                // convert ETH to WETH and send premium to maker", "                // converting to WETH instead of forwarding native ETH to the maker has two benefits;", "                // 1) active market makers will mostly be using WETH not native ETH", "                // 2) attack surface for re-entrancy is reduced", "                IWETH(weth).deposit{value: msg.value}();", "                IWETH(weth).transfer(order.maker, msg.value);", "            } else {", "                ERC20(order.baseAsset).safeTransferFrom(msg.sender, order.maker, order.premium);", "            }", "        }", "", "        // filling short put: transfer strike from maker to contract", "        if (!order.isLong && !order.isCall) {", "            ERC20(order.baseAsset).safeTransferFrom(order.maker, address(this), order.strike);", "            return positionId;", "        }", "", "        // filling long put: transfer strike from taker to contract", "        if (order.isLong && !order.isCall) {", "            // handle the case where the taker uses native ETH instead of WETH to deposit the strike", "            if (weth == order.baseAsset && msg.value > 0) {", "                // check enough ETH was sent to cover the strike", "                require(msg.value == order.strike, \"Incorrect ETH amount sent\");", "", "                // convert ETH to WETH", "                // we convert the strike ETH to WETH so that the logic in exercise() works", "                // - because exercise() assumes an ERC20 interface on the base asset.", "                IWETH(weth).deposit{value: msg.value}();", "            } else {", "                ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);", "            }", "", "            return positionId;", "        }", "", "        // filling short call: transfer assets from maker to contract", "        if (!order.isLong && order.isCall) {", "            _transferERC20sIn(order.erc20Assets, order.maker);", "            _transferERC721sIn(order.erc721Assets, order.maker);", "            return positionId;", "        }", "", "        // filling long call: transfer assets from taker to contract", "        if (order.isLong && order.isCall) {", "            _transferERC20sIn(order.erc20Assets, msg.sender);", "            _transferERC721sIn(order.erc721Assets, msg.sender);", "            _transferFloorsIn(order.floorTokens, floorAssetTokenIds, msg.sender);", "            return positionId;", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function cancel() external onlyOwner {", "        require(block.timestamp < sale.startTime, \"TOO LATE\");", "        _end(sale);", "    }"], "ner_tags": [1, 0, 0, 0]}
{"tokens": ["    constructor(bytes memory delegateData) {", "        // Reading the implementation of the AxelarDepositService", "        // and delegating the call back to it", "        // solhint-disable-next-line avoid-low-level-calls", "        (bool success, ) = IAxelarDepositService(msg.sender).receiverImplementation().delegatecall(delegateData);", "", "        // if not success revert with the original revert data", "        if (!success) {", "            // solhint-disable-next-line no-inline-assembly", "            assembly {", "                let ptr := mload(0x40)", "                let size := returndatasize()", "                returndatacopy(ptr, 0, size)", "                revert(ptr, size)", "            }", "        }", "", "        selfdestruct(payable(msg.sender));", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["    function batchRemoveDex(address[] calldata _dexs) external {", "        LibDiamond.enforceIsContractOwner();", "", "        for (uint256 i; i < _dexs.length; i++) {", "            if (s.dexWhitelist[_dexs[i]] == false) {", "                continue;", "            }", "            s.dexWhitelist[_dexs[i]] = false;", "            for (uint256 j; j < s.dexs.length; j++) {", "                if (s.dexs[j] == _dexs[i]) {", "                    _removeDex(j);", "                    return;", "                }", "            }", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": ["    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {", "        // votes with delegation for the given block", "        uint256 votes = _getPastVotes(user, blockNumber);", "", "", "        // check if user has a lock at that block", "        UserLock memory pastLock = _getPastLock(user, blockNumber);", "        // and if there is a lock, and user self-delegated, add the bonus voting power ", "        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user && pastLock.duration >= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;", "", "        return votes + bonusVotes;", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function getBuyAmount(", "        ERC20 buy_gem,", "        ERC20 pay_gem,", "        uint256 pay_amt", "    ) external view returns (uint256 fill_amt) {", "        uint256 offerId = getBestOffer(buy_gem, pay_gem); //Get best offer for the token pair", "        while (pay_amt > offers[offerId].buy_amt) {", "            fill_amt = add(fill_amt, offers[offerId].pay_amt); //Add amount to buy accumulator", "            pay_amt = sub(pay_amt, offers[offerId].buy_amt); //Decrease amount to pay", "            if (pay_amt > 0) {", "                //If we still need more offers", "                offerId = getWorseOffer(offerId); //We look for the next best offer", "                require(offerId != 0); //Fails if there are not enough offers to complete", "            }", "        }", "        fill_amt = add(", "            fill_amt,", "            rmul(", "                pay_amt * 10**9,", "                rdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)", "            ) / 10**9", "        ); //Add proportional amount of last offer to buy accumulator", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["    function _getFinalContribution(address contributor)", "        internal", "        view", "        returns (uint256 ethUsed, uint256 ethOwed, uint256 votingPower)", "    {", "        uint256 totalEthUsed = _getFinalPrice();", "        {", "            Contribution[] storage contributions = _contributionsByContributor[contributor];", "            uint256 numContributions = contributions.length;", "            for (uint256 i = 0; i < numContributions; ++i) {", "                Contribution memory c = contributions[i];", "                if (c.previousTotalContributions >= totalEthUsed) {", "                    // This entire contribution was not used.", "                    ethOwed += c.amount;", "                } else if (c.previousTotalContributions + c.amount <= totalEthUsed) {", "                    // This entire contribution was used.", "                    ethUsed += c.amount;", "                } else {", "                    // This contribution was partially used.", "                    uint256 partialEthUsed = totalEthUsed - c.previousTotalContributions;", "                    ethUsed += partialEthUsed;", "                    ethOwed = c.amount - partialEthUsed;", "                }", "            }", "        }", "        // one SLOAD with optimizer on", "        address splitRecipient_ = splitRecipient;", "        uint256 splitBps_ = splitBps;", "        if (splitRecipient_ == address(0)) {", "            splitBps_ = 0;", "        }", "        votingPower = ((1e4 - splitBps_) * ethUsed) / 1e4;", "        if (splitRecipient_ == contributor) {", "            // Split recipient is also the contributor so just add the split", "            // voting power.", "            votingPower += (splitBps_ * totalEthUsed + (1e4 - 1)) / 1e4; // round up", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function vestedAmount(address _recipient, uint40 _referenceTs) public view returns (uint112) {", "        Claim storage _claim = claims[_recipient];", "        return _baseVestedAmount(_claim, _referenceTs);", "    }"], "ner_tags": [0, 0, 1, 0]}
{"tokens": ["    function _poolCheckpoint() internal returns (bool) {", "        uint256 currentRate = inflationManager.getLpRateForStakerVault(address(stakerVault));", "        // Update the integral of total token supply for the pool", "        uint256 poolTotalStaked = stakerVault.getPoolTotalStaked();", "        if (poolTotalStaked > 0) {", "            poolStakedIntegral += (currentRate * (block.timestamp - poolLastUpdate)).scaledDiv(", "                poolTotalStaked", "            );", "        }", "        poolLastUpdate = block.timestamp;", "        return true;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0]}
{"tokens": ["  function internalGetMutableRoyalties(", "    address nftContract,", "    uint256 tokenId,", "    address payable creator", "  ) external view returns (address payable[] memory recipients, uint256[] memory splitPerRecipientInBasisPoints) {", "    /* Overrides must support ERC-165 when registered, except for overrides defined by the registry owner.", "       If that results in an override w/o 165 we may need to upgrade the market to support or ignore that override. */", "    // The registry requires overrides are not 0 and contracts when set.", "    // If no override is set, the nftContract address is returned.", "", "    try royaltyRegistry.getRoyaltyLookupAddress{ gas: READ_ONLY_GAS_LIMIT }(nftContract) returns (", "      address overrideContract", "    ) {", "      if (overrideContract != nftContract) {", "        nftContract = overrideContract;", "", "        // The functions above are repeated here if an override is set.", "", "        // 3rd priority: ERC-2981 override", "        if (nftContract.supportsERC165InterfaceUnchecked(type(IRoyaltyInfo).interfaceId)) {", "          try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (", "            address receiver,", "            uint256 /* royaltyAmount */", "          ) {", "            recipients = new address payable[](1);", "            recipients[0] = payable(receiver);", "            splitPerRecipientInBasisPoints = new uint256[](1);", "            // The split amount is assumed to be 100% when only 1 recipient is returned", "            return (recipients, splitPerRecipientInBasisPoints);", "          } catch // solhint-disable-next-line no-empty-blocks", "          {", "            // Fall through", "          }", "        }", "", "        // 4th priority: getRoyalties override", "        if (recipients.length == 0 && nftContract.supportsERC165InterfaceUnchecked(type(IGetRoyalties).interfaceId)) {", "          try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (", "            address payable[] memory _recipients,", "            uint256[] memory recipientBasisPoints", "          ) {", "            if (_recipients.length != 0 && _recipients.length == recipientBasisPoints.length) {", "              return (_recipients, recipientBasisPoints);", "            }", "          } catch // solhint-disable-next-line no-empty-blocks", "          {", "            // Fall through", "          }", "        }", "      }", "    } catch // solhint-disable-next-line no-empty-blocks", "    {", "      // Ignore out of gas errors and continue using the nftContract address", "    }", "", "    // 5th priority: getFee* from contract or override", "    if (nftContract.supportsERC165InterfaceUnchecked(type(IGetFees).interfaceId)) {", "      try IGetFees(nftContract).getFeeRecipients{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (", "        address payable[] memory _recipients", "      ) {", "        if (_recipients.length != 0) {", "          try IGetFees(nftContract).getFeeBps{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (", "            uint256[] memory recipientBasisPoints", "          ) {", "            if (_recipients.length == recipientBasisPoints.length) {", "              return (_recipients, recipientBasisPoints);", "            }", "          } catch // solhint-disable-next-line no-empty-blocks", "          {", "            // Fall through", "          }", "        }", "      } catch // solhint-disable-next-line no-empty-blocks", "      {", "        // Fall through", "      }", "    }", "", "    // 6th priority: tokenCreator w/ or w/o requiring 165 from contract or override", "    if (creator != address(0)) {", "      // Only pay the tokenCreator if there wasn't another royalty defined", "      recipients = new address payable[](1);", "      recipients[0] = creator;", "      splitPerRecipientInBasisPoints = new uint256[](1);", "      // The split amount is assumed to be 100% when only 1 recipient is returned", "      return (recipients, splitPerRecipientInBasisPoints);", "    }", "", "    // 7th priority: owner from contract or override", "    try IOwnable(nftContract).owner{ gas: READ_ONLY_GAS_LIMIT }() returns (address owner) {", "      if (owner != address(0)) {", "        // Only pay the owner if there wasn't another royalty defined", "        recipients = new address payable[](1);", "        recipients[0] = payable(owner);", "        splitPerRecipientInBasisPoints = new uint256[](1);", "        // The split amount is assumed to be 100% when only 1 recipient is returned", "        return (recipients, splitPerRecipientInBasisPoints);", "      }", "    } catch // solhint-disable-next-line no-empty-blocks", "    {", "      // Fall through", "    }", "", "    // If no valid payment address or creator is found, return 0 recipients", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function updateCapacity(bool high_, uint256 capacity_) external permissioned {", "        if (high_) {", "            // Update capacity", "            _range.high.capacity = capacity_;", "", "            // If the new capacity is below the threshold, deactivate the wall if they are currently active", "            if (capacity_ < _range.high.threshold && _range.high.active) {", "                // Set wall to inactive", "                _range.high.active = false;", "                _range.high.lastActive = uint48(block.timestamp);", "", "                emit WallDown(true, block.timestamp, capacity_);", "            }", "        } else {", "            // Update capacity", "            _range.low.capacity = capacity_;", "", "            // If the new capacity is below the threshold, deactivate the wall if they are currently active", "            if (capacity_ < _range.low.threshold && _range.low.active) {", "                // Set wall to inactive", "                _range.low.active = false;", "                _range.low.lastActive = uint48(block.timestamp);", "", "                emit WallDown(false, block.timestamp, capacity_);", "            }", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function proposeExtraordinary(", "        uint256 endBlock_,", "        address[] memory targets_,", "        uint256[] memory values_,", "        bytes[] memory calldatas_,", "        string memory description_) external override returns (uint256 proposalId_) {", "", "        proposalId_ = _hashProposal(targets_, values_, calldatas_, keccak256(abi.encode(DESCRIPTION_PREFIX_HASH_EXTRAORDINARY, keccak256(bytes(description_)))));", "", "        ExtraordinaryFundingProposal storage newProposal = _extraordinaryFundingProposals[proposalId_];", "", "        // check if proposal already exists (proposal id not 0)", "        if (newProposal.proposalId != 0) revert ProposalAlreadyExists();", "", "        // check proposal length is within limits of 1 month maximum", "        if (block.number + MAX_EFM_PROPOSAL_LENGTH < endBlock_) revert InvalidProposal();", "", "        uint128 totalTokensRequested = _validateCallDatas(targets_, values_, calldatas_);", "", "        // check tokens requested are available for claiming from the treasury", "        if (uint256(totalTokensRequested) > _getSliceOfTreasury(Maths.WAD - _getMinimumThresholdPercentage())) revert InvalidProposal();", "", "        // store newly created proposal", "        newProposal.proposalId      = proposalId_;", "        newProposal.startBlock      = SafeCast.toUint128(block.number);", "        newProposal.endBlock        = SafeCast.toUint128(endBlock_);", "        newProposal.tokensRequested = totalTokensRequested;", "", "        emit ProposalCreated(", "            proposalId_,", "            msg.sender,", "            targets_,", "            values_,", "            new string[](targets_.length),", "            calldatas_,", "            block.number,", "            endBlock_,", "            description_", "        );", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function transferNotionalFee(address f, uint256 a) external authorized(admin) returns(bool) {", "    Vault memory oVault = vaults[f];", "    Vault memory sVault = vaults[swivel];", "", "    // remove notional from its owner", "    oVault.notional -= a;", "", "    uint256 exchangeRate = Compounding.exchangeRate(protocol, cTokenAddr);", "", "    // check if exchangeRate has been stored already this block. If not, calculate marginal interest + store exchangeRate", "    uint256 yield;", "    if (sVault.exchangeRate != exchangeRate) {", "      // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate", "      // otherwise, calculate marginal exchange rate between current and previous exchange rate.", "      if (maturityRate > 0) { ", "        // calculate marginal interest", "          yield = ((maturityRate * 1e26) / sVault.exchangeRate) - 1e26;", "      } else {", "          yield = ((exchangeRate * 1e26) / sVault.exchangeRate) - 1e26;", "      }", "      uint256 interest = (yield * sVault.notional) / 1e26;", "      // add interest and amount, reset cToken exchange rate", "      sVault.redeemable += interest;", "      sVault.exchangeRate = exchangeRate;", "    }", "    // add notional to swivel's vault", "    sVault.notional += a;", "    // store the adjusted vaults", "    vaults[swivel] = sVault;", "    vaults[f] = oVault;", "    return true;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _burnDebtTokens(", "        DataTypes.ReserveData storage liquidationAssetReserve,", "        DataTypes.ExecuteLiquidateParams memory params,", "        ExecuteLiquidateLocalVars memory vars", "    ) internal {", "        _depositETH(params, vars);", "", "        // Transfers the debt asset being repaid to the xToken, where the liquidity is kept", "        IERC20(params.liquidationAsset).safeTransferFrom(", "            vars.payer,", "            vars.liquidationAssetReserveCache.xTokenAddress,", "            vars.actualLiquidationAmount", "        );", "        // Handle payment", "        IPToken(vars.liquidationAssetReserveCache.xTokenAddress)", "            .handleRepayment(params.liquidator, vars.actualLiquidationAmount);", "        // Burn borrower's debt token", "        vars", "            .liquidationAssetReserveCache", "            .nextScaledVariableDebt = IVariableDebtToken(", "            vars.liquidationAssetReserveCache.variableDebtTokenAddress", "        ).burn(", "                params.borrower,", "                vars.actualLiquidationAmount,", "                vars.liquidationAssetReserveCache.nextVariableBorrowIndex", "            );", "        // Update borrow & supply rate", "        liquidationAssetReserve.updateInterestRates(", "            vars.liquidationAssetReserveCache,", "            params.liquidationAsset,", "            vars.actualLiquidationAmount,", "            0", "        );", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function rescueERC20(address currency, address to) external onlyOwner {", "        uint256 withdrawAmount = IERC20(currency).balanceOf(address(this)) - 1;", "        if (withdrawAmount == 0) revert InsufficientAmount();", "        _executeERC20DirectTransfer(currency, to, withdrawAmount);", "    }"], "ner_tags": [1, 0, 0, 0, 0]}
{"tokens": ["    function exercise(uint256 optionId) external payable {", "        // optionId should always be even", "        require(optionId % 2 == 0, \"Not option type\");", "", "        // check owner", "        require(msg.sender == ownerOf(optionId), \"You are not the owner\");", "", "        uint256 vaultId = optionId - 1;", "        Vault memory vault = _vaults[vaultId];", "", "        // check option hasn't expired", "        require(block.timestamp < vault.currentExpiration, \"Option has expired\");", "", "        // check correct ETH amount was sent to pay the strike", "        require(msg.value == vault.currentStrike, \"Incorrect ETH sent for strike\");", "", "        // burn the option token", "        _burn(optionId);", "", "        // mark the vault as exercised", "        vault.isExercised = true;", "        _vaults[vaultId] = vault;", "", "        // collect protocol fee", "        uint256 fee = 0;", "        if (feeRate > 0) {", "            fee = (msg.value * feeRate) / 1e18;", "            protocolUnclaimedFees += fee;", "        }", "", "        // increment vault beneficiary's ETH balance", "        ethBalance[getVaultBeneficiary(vaultId)] += msg.value - fee;", "", "        emit ExercisedOption(optionId, msg.sender);", "", "        // transfer the NFTs or ERC20s to the exerciser", "        vault.tokenType == TokenType.ERC721", "            ? ERC721(vault.token).transferFrom(address(this), msg.sender, vault.tokenIdOrAmount)", "            : ERC20(vault.token).safeTransfer(msg.sender, vault.tokenIdOrAmount);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _rewardPerToken(address _rewardsToken) internal view returns (uint256) {", "        if (lockedSupply == 0) {", "            return rewardData[_rewardsToken].rewardPerTokenStored;", "        }", "        return", "            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(", "                _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish)", "                    .sub(rewardData[_rewardsToken].lastUpdateTime)", "                    .mul(rewardData[_rewardsToken].rewardRate)", "                    .mul(1e18)", "                    .div(lockedSupply)", "            );", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function _reconcileProcessPortal(", "    uint256 _amount,", "    address _local,", "    address _router,", "    bytes32 _transferId", "  ) private returns (uint256) {", "    // When repaying a portal, should use available liquidity if there is not enough balance from", "    // the bridge. First, calculate the amount to be repaid in adopted asset then swap for exactly", "    // that amount. This prevents having to swap excess (i.e. from positive amm slippage) from debt", "    // repayment back into local asset to credit routers", "", "    // Calculates the amount to be repaid to the portal in adopted asset", "    (uint256 totalRepayAmount, uint256 backUnbackedAmount, uint256 portalFee) = _calculatePortalRepayment(", "      _amount,", "      _transferId,", "      _local", "    );", "", "    // Update the debt amounts before swapping", "    s.portalDebt[_transferId] -= backUnbackedAmount;", "    s.portalFeeDebt[_transferId] -= portalFee;", "", "    // Swap for exact `totalRepayAmount` of adopted asset to repay aave, with a maximum of the minted amount", "    // as the slippage ceiling", "    // amountIn is the amount that was actually taken to perform the swap (i.e. amount of local asset swapped)", "    // NOTE: this function can revert if the slippage ceiling is hit. Using the low-level calls helps us", "    // handle the case where slippage was hit", "    (bool swapSuccess, uint256 amountIn, address adopted) = AssetLogic.swapFromLocalAssetIfNeededForExactOut(", "      _local,", "      totalRepayAmount,", "      _amount", "    );", "    if (!swapSuccess) {", "      // Reset values", "      s.portalDebt[_transferId] += backUnbackedAmount;", "      s.portalFeeDebt[_transferId] += portalFee;", "      // Emit debt event of full portal value and exit", "      emit AavePortalRepaymentDebt(_transferId, adopted, s.portalDebt[_transferId], s.portalFeeDebt[_transferId]);", "      return (_amount);", "    }", "", "    // Edge case with some tokens: Example USDT in ETH Mainnet, after the backUnbacked call there could be a remaining allowance if not the whole amount is pulled by aave.", "    // Later, if we try to increase the allowance it will fail. USDT demands if allowance is not 0, it has to be set to 0 first.", "    // TODO: Should we call approve(0) and approve(totalRepayAmount) instead? or with a try catch to not affect gas on all cases?", "    // Example: https://github.com/aave/aave-v3-periphery/blob/ca184e5278bcbc10d28c3dbbc604041d7cfac50b/contracts/adapters/paraswap/ParaSwapRepayAdapter.sol#L138-L140", "    SafeERC20.safeIncreaseAllowance(IERC20(adopted), s.aavePool, totalRepayAmount);", "", "    (bool success, ) = s.aavePool.call(", "      abi.encodeWithSelector(IAavePool.backUnbacked.selector, adopted, backUnbackedAmount, portalFee)", "    );", "", "    if (success) {", "      emit AavePortalRepayment(_transferId, adopted, backUnbackedAmount, portalFee);", "    } else {", "      // Reset values", "      s.portalDebt[_transferId] += backUnbackedAmount;", "      s.portalFeeDebt[_transferId] += portalFee;", "", "      // Decrease the allowance", "      SafeERC20.safeDecreaseAllowance(IERC20(adopted), s.aavePool, totalRepayAmount);", "", "      // Update the amount repaid to 0, so the amount is credited to the router", "      amountIn = 0;", "      emit AavePortalRepaymentDebt(_transferId, adopted, s.portalDebt[_transferId], s.portalFeeDebt[_transferId]);", "    }", "", "    // NOTE: Aave accounts a global unbacked variable per asset for all, not by address/bridge.", "    // Someone can repay more than it should, so then a the moment of calling backUnbacked()", "    // aave can pull a smaller amount than backUnbackedAmount. So there will be an extra amount of assets that needs to be assigned", "    // See https://github.com/aave/aave-v3-core/blob/feb3f20885c73025f40cc272b59e7eacfaa02fe4/contracts/protocol/libraries/logic/BridgeLogic.sol#L121", "    // If we wanted to handle this difference, we should check the balance before and after calling", "    // `backUnbacked` and credit the difference to the router", "", "    // Calculate the amount to distribute to the router. There are cases (i.e. positive slippage)", "    // where router has gained extra because of the AMM, these funds should be distributed.", "    // Because we are using the `_amount` a sthe maximum amount in, the `amountIn` should always be", "    // <= _amount (i.e. this will be +ive)", "    return (_amount - amountIn);", "  }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _transferFrom(", "        address _from,", "        address _to,", "        uint256 _tokenId,", "        address _sender", "    ) internal virtual {", "        require(attachments[_tokenId] == 0 && !voted[_tokenId], 'attached');", "        // Check requirements", "        require(_isApprovedOrOwner(_sender, _tokenId));", "        // Clear approval. Throws if `_from` is not the current owner", "        _clearApproval(_from, _tokenId);", "        // Remove NFT. Throws if `_tokenId` is not a valid NFT", "        _removeTokenFrom(_from, _tokenId);", "        // Add NFT", "        _addTokenTo(_to, _tokenId);", "        // Set the block of ownership transfer (for Flash NFT protection)", "        ownership_change[_tokenId] = block.number;", "        // Log the transfer", "        emit Transfer(_from, _to, _tokenId);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function trackPool() external onlyActive returns (bool) {", "    (uint256 reserve0, uint256 reserve1, uint32 blockTimestampLast) = stakeToken", "      .getReserves();", "", "    if (blockTimestampLast < maltPriceTimestampLast) {", "      // stale data", "      return false;", "    }", "", "    uint256 kLast = reserve0 * reserve1;", "", "    uint256 rootK = Babylonian.sqrt(kLast);", "", "    uint256 price;", "    uint256 priceCumulative;", "", "    if (address(malt) < address(collateralToken)) {", "      priceCumulative = stakeToken.price0CumulativeLast();", "    } else {", "      priceCumulative = stakeToken.price1CumulativeLast();", "    }", "", "    if (", "      blockTimestampLast > maltPriceTimestampLast &&", "      maltPriceCumulativeLast != 0", "    ) {", "      price = FixedPoint", "        .uq112x112(", "          uint224(", "            (priceCumulative - maltPriceCumulativeLast) /", "              (blockTimestampLast - maltPriceTimestampLast)", "          )", "        )", "        .mul(priceTarget)", "        .decode144();", "    } else if (", "      maltPriceCumulativeLast > 0 && priceCumulative == maltPriceCumulativeLast", "    ) {", "      (, , , , , price, ) = poolMA.getLiveSample();", "    }", "", "    if (price != 0) {", "      // Use rootK to slow down growth of cumulativeValue", "      poolMA.update(price, rootK);", "      emit TrackPool(price, rootK);", "    }", "", "    maltPriceCumulativeLast = priceCumulative;", "    maltPriceTimestampLast = blockTimestampLast;", "", "    return true;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _contribute(", "        address payable contributor,", "        address delegate,", "        uint96 amount,", "        bytes memory gateData", "    ) private returns (uint96 votingPower) {", "        // Require a non-null delegate.", "        if (delegate == address(0)) {", "            revert InvalidDelegateError();", "        }", "", "        // Must not be blocked by gatekeeper.", "        IGateKeeper _gateKeeper = gateKeeper;", "        if (_gateKeeper != IGateKeeper(address(0))) {", "            if (!_gateKeeper.isAllowed(contributor, gateKeeperId, gateData)) {", "                revert NotAllowedByGateKeeperError(", "                    contributor,", "                    _gateKeeper,", "                    gateKeeperId,", "                    gateData", "                );", "            }", "        }", "", "        votingPower = _processContribution(contributor, delegate, amount);", "", "        // OK to contribute with zero just to update delegate.", "        if (amount == 0) return 0;", "", "        uint256 previousVotingPower = pendingVotingPower[contributor];", "", "        pendingVotingPower[contributor] += votingPower;", "", "        // Mint a crowdfund NFT if this is their first contribution.", "        if (previousVotingPower == 0) _mint(contributor);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["  function _getAssetYields(uint256 _totalYieldAmount) internal view returns (AssetYield[] memory) {", "    // Get total borrowing asset volume and volumes and assets", "    (", "      uint256 totalVolume,", "      uint256[] memory volumes,", "      address[] memory assets,", "      uint256 length", "    ) = ILendingPool(_addressesProvider.getLendingPool()).getBorrowingAssetAndVolumes();", "", "    if (totalVolume == 0) return new AssetYield[](0);", "", "    AssetYield[] memory assetYields = new AssetYield[](length);", "    uint256 extraYieldAmount = _totalYieldAmount;", "", "    for (uint256 i = 0; i < length; i++) {", "      assetYields[i].asset = assets[i];", "      if (i != length - 1) {", "        // Distribute yieldAmount based on percent of asset volume", "        assetYields[i].amount = _totalYieldAmount.percentMul(", "          volumes[i].mul(PercentageMath.PERCENTAGE_FACTOR).div(totalVolume)", "        );", "        extraYieldAmount = extraYieldAmount.sub(assetYields[i].amount);", "      } else {", "        // without calculation, set remained extra amount", "        assetYields[i].amount = extraYieldAmount;", "      }", "    }", "", "    return assetYields;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["     function CLOCK_MODE() public override view returns (string memory){", "       require(clock() == block.number, \"Votes: broken clock mode\");", "        return \"mode=blocknumber&from=default\";", "    }"], "ner_tags": [0, 1, 0, 0]}
{"tokens": ["    function withdrawForETH(uint256 shares, address targetPool)", "        external", "        payable", "        returns (uint256 withdrawnWETH)", "    {", "        IERC20 target = IBathToken(targetPool).underlyingToken();", "        require(target == ERC20(wethAddress), \"target pool not weth pool\");", "        require(", "            IBathToken(targetPool).balanceOf(msg.sender) >= shares,", "            \"don't own enough shares\"", "        );", "        IBathToken(targetPool).transferFrom(msg.sender, address(this), shares);", "        withdrawnWETH = IBathToken(targetPool).withdraw(shares);", "        WETH9(wethAddress).withdraw(withdrawnWETH);", "", "        //Send back withdrawn native eth to sender", "        msg.sender.transfer(withdrawnWETH);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["    function mint(", "        TimeswapV2OptionMintParam calldata param", "    ) external override noDelegateCall returns (uint256 token0AndLong0Amount, uint256 token1AndLong1Amount, uint256 shortAmount, bytes memory data) {", "        ParamLibrary.check(param, blockTimestamp());", "        addOptionEnumerationIfNecessary(param.strike, param.maturity);", "", "        Option storage option = options[param.strike][param.maturity];", "", "        // does main mint logic calculation", "        (token0AndLong0Amount, token1AndLong1Amount, shortAmount) = option.mint(param.strike, param.long0To, param.long1To, param.shortTo, param.transaction, param.amount0, param.amount1);", "", "        // update token0 and token1 balance target for any previous concurrent option transactions.", "        processing.updateProcess(token0AndLong0Amount, token1AndLong1Amount, true, true);", "", "        // add a new process", "        // stores the token0 and token1 balance target required from the msg.sender to achieve.", "        Process storage currentProcess = (processing.push() = Process(", "            param.strike,", "            param.maturity,", "            IERC20(token0).balanceOf(address(this)) + token0AndLong0Amount,", "            IERC20(token1).balanceOf(address(this)) + token1AndLong1Amount", "        ));", "", "        // ask the msg.sender to transfer token0 and/or token1 to this contract.", "        data = ITimeswapV2OptionMintCallback(msg.sender).timeswapV2OptionMintCallback(", "            TimeswapV2OptionMintCallbackParam({", "                strike: param.strike,", "                maturity: param.maturity,", "                token0AndLong0Amount: token0AndLong0Amount,", "                token1AndLong1Amount: token1AndLong1Amount,", "                shortAmount: shortAmount,", "                data: param.data", "            })", "        );", "", "        // check if the token0 balance target is achieved.", "        if (token0AndLong0Amount != 0) Error.checkEnough(IERC20(token0).balanceOf(address(this)), currentProcess.balance0Target);", "", "        // check if the token1 balance target is achieved.", "        if (token1AndLong1Amount != 0) Error.checkEnough(IERC20(token1).balanceOf(address(this)), currentProcess.balance1Target);", "", "        // finish the process.", "        processing.pop();", "", "        emit Mint(param.strike, param.maturity, msg.sender, param.long0To, param.long1To, param.shortTo, token0AndLong0Amount, token1AndLong1Amount, shortAmount);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _handleWithdraw(IPosition.Trade memory _trade, address _stableVault, address _outputToken, uint _toMint) internal {", "        IStable(_trade.tigAsset).mintFor(address(this), _toMint);", "        if (_outputToken == _trade.tigAsset) {", "            IERC20(_outputToken).transfer(_trade.trader, _toMint);", "        } else {", "            uint256 _balBefore = IERC20(_outputToken).balanceOf(address(this));", "            IStableVault(_stableVault).withdraw(_outputToken, _toMint);", "            if (IERC20(_outputToken).balanceOf(address(this)) != _balBefore + _toMint/(10**(18-ExtendedIERC20(_outputToken).decimals()))) revert BadWithdraw();", "            IERC20(_outputToken).transfer(_trade.trader, IERC20(_outputToken).balanceOf(address(this)) - _balBefore);", "        }        ", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["  function transferWithdrawReserve() public {", "    VaultData storage s = _loadStorageSlot();", "", "    if (s.currentEpoch == uint64(0)) {", "      return;", "    }", "", "    address currentWithdrawProxy = s", "      .epochData[s.currentEpoch - 1]", "      .withdrawProxy;", "    // prevents transfer to a non-existent WithdrawProxy", "    // withdrawProxies are indexed by the epoch where they're deployed", "    if (currentWithdrawProxy != address(0)) {", "      uint256 withdrawBalance = ERC20(asset()).balanceOf(address(this));", "", "      // prevent transfer of more assets then are available", "      if (s.withdrawReserve <= withdrawBalance) {", "        withdrawBalance = s.withdrawReserve;", "        s.withdrawReserve = 0;", "      } else {", "        unchecked {", "          s.withdrawReserve -= withdrawBalance.safeCastTo88();", "        }", "      }", "", "      ERC20(asset()).safeTransfer(currentWithdrawProxy, withdrawBalance);", "      WithdrawProxy(currentWithdrawProxy).increaseWithdrawReserveReceived(", "        withdrawBalance", "      );", "      emit WithdrawReserveTransferred(withdrawBalance);", "    }", "", "    address withdrawProxy = s.epochData[s.currentEpoch].withdrawProxy;", "    if (", "      s.withdrawReserve > 0 &&", "      timeToEpochEnd() == 0 &&", "      withdrawProxy != address(0)", "    ) {", "      address currentWithdrawProxy = s", "        .epochData[s.currentEpoch - 1]", "        .withdrawProxy;", "      uint256 drainBalance = WithdrawProxy(withdrawProxy).drain(", "        s.withdrawReserve,", "        s.epochData[s.currentEpoch - 1].withdrawProxy", "      );", "      unchecked {", "        s.withdrawReserve -= drainBalance.safeCastTo88();", "      }", "      WithdrawProxy(currentWithdrawProxy).increaseWithdrawReserveReceived(", "        drainBalance", "      );", "    }", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _checkValidity(address _asset, uint256 _twap)", "        internal", "        view", "        returns (bool)", "    {", "        require(_twap > 0, \"NFTOracle: price should be more than 0\");", "        PriceInformation memory assetPriceMapEntry = assetPriceMap[_asset];", "        uint256 _priorTwap = assetPriceMapEntry.twap;", "        uint256 _updatedAt = assetPriceMapEntry.updatedAt;", "        uint256 priceDeviation;", "        //first price is always valid", "        if (_priorTwap == 0 || _updatedAt == 0) {", "            return true;", "        }", "        priceDeviation = _twap > _priorTwap", "            ? (_twap * 100) / _priorTwap", "            : (_priorTwap * 100) / _twap;", "", "        // config maxPriceDeviation as multiple directly(not percent) for simplicity", "        if (priceDeviation >= config.maxPriceDeviation) {", "            return false;", "        }", "        return true;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function tokenURI(", "        uint256 _tokenId", "    ) public view override(ERC721Upgradeable) returns (string memory) {", "        return ITokenUriDelegate(tokenUriDelegate).tokenURI(_tokenId);", "    }"], "ner_tags": [1, 1, 1, 1, 1]}
{"tokens": ["    function depositEther() external nonReentrant {", "        // Initial pause check", "        require(!depositEtherPaused, \"Depositing ETH is paused\");", "", "        // See how many deposits can be made. Truncation desired.", "        uint256 numDeposits = (address(this).balance - currentWithheldETH) / DEPOSIT_SIZE;", "        require(numDeposits > 0, \"Not enough ETH in contract\");", "", "        // Give each deposit chunk to an empty validator", "        for (uint256 i = 0; i < numDeposits; ++i) {", "            // Get validator information", "            (", "                bytes memory pubKey,", "                bytes memory withdrawalCredential,", "                bytes memory signature,", "                bytes32 depositDataRoot", "            ) = getNextValidator(); // Will revert if there are not enough free validators", "", "            // Make sure the validator hasn't been deposited into already, to prevent stranding an extra 32 eth", "            // until withdrawals are allowed", "            require(!activeValidators[pubKey], \"Validator already has 32 ETH\");", "", "            // Deposit the ether in the ETH 2.0 deposit contract", "            depositContract.deposit{value: DEPOSIT_SIZE}(", "                pubKey,", "                withdrawalCredential,", "                signature,", "                depositDataRoot", "            );", "", "            // Set the validator as used so it won't get an extra 32 ETH", "            activeValidators[pubKey] = true;", "", "            emit DepositSent(pubKey, withdrawalCredential);", "        }", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function burn(address _recipient) external override {", "        uint value = balanceOf(address(this));", "        require(value > 0, \"Index: INSUFFICIENT_AMOUNT\");", "        uint length = assets.length();", "", "        bool containsBlacklistedAssets;", "        for (uint i; i < length; ++i) {", "            if (!IAccessControl(registry).hasRole(ASSET_ROLE, assets.at(i))) {", "                containsBlacklistedAssets = true;", "                break;", "            }", "        }", "", "        if (!containsBlacklistedAssets) {", "            address feePool = IIndexRegistry(registry).feePool();", "", "            uint fee = (value * IFeePool(feePool).burningFeeInBPOf(address(this))) / BP.DECIMAL_FACTOR;", "", "            if (fee > 0) {", "                // AUM charged in _transfer method", "                _transfer(address(this), feePool, fee);", "                value -= fee;", "            } else {", "                _chargeAUMFee(feePool);", "            }", "        }", "", "        address orderer = IIndexRegistry(registry).orderer();", "        uint lastOrderId = IOrderer(orderer).lastOrderIdOf(address(this));", "        for (uint i; i < length + inactiveAssets.length(); ++i) {", "            address asset = i < length ? assets.at(i) : inactiveAssets.at(i - length);", "            if (containsBlacklistedAssets && IAccessControl(registry).hasRole(SKIPPED_ASSET_ROLE, asset)) {", "                continue;", "            }", "", "            IvToken vToken = IvToken(IvTokenFactory(vTokenFactory).vTokenOf(asset));", "            uint indexAssetBalance = vToken.balanceOf(address(this));", "            uint accountBalance = (value * indexAssetBalance) / totalSupply();", "            if (accountBalance == 0) {", "                continue;", "            }", "", "            // calculate index value in vault to be burned", "            vToken.transfer(address(vToken), accountBalance);", "            vToken.burn(_recipient);", "            if (lastOrderId > 0) {", "                IOrderer(orderer).reduceOrderAsset(asset, totalSupply() - value, totalSupply());", "            }", "        }", "", "        _burn(address(this), value);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function withdraw(uint poolId, uint receiptId) external {", "        Pool storage pool = pools[poolId];", "        require(pool.id == poolId, 'Uninitialized pool');", "        Receipt storage receipt = pool.receipts[receiptId];", "        require(receipt.id == receiptId, 'Can only withdraw real receipts');", "        require(receipt.owner == msg.sender || block.timestamp > pool.endTime, 'Can only withdraw your own deposit');", "        require(receipt.timeWithdrawn == 0, 'Can only withdraw once per receipt');", "", "        // close re-entry gate", "        receipt.timeWithdrawn = block.timestamp;", "", "        uint[] memory rewards = getRewards(poolId, receiptId);", "        pool.totalDepositsWei -= receipt.amountDepositedWei;", "        bool success = true;", "", "        for (uint i = 0; i < rewards.length; i++) {", "            pool.rewardsWeiClaimed[i] += rewards[i];", "            pool.rewardFunding[i] -= rewards[i];", "            uint tax = (pool.taxPerCapita * rewards[i]) / 1000;", "            uint transferAmount = rewards[i] - tax;", "            taxes[poolId][i] += tax;", "            success = success && IERC20(pool.rewardTokens[i]).transfer(receipt.owner, transferAmount);", "        }", "", "        success = success && IERC20(pool.depositToken).transfer(receipt.owner, receipt.amountDepositedWei);", "        require(success, 'Token transfer failed');", "", "        emit WithdrawalOccurred(poolId, receiptId, receipt.owner);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": ["    function getPriceLP(IBaseV1Pair pair) internal view returns(uint) {", "        uint[] memory supply = pair.sampleSupply(8, 1);", "        uint[] memory prices; ", "        uint[] memory unitReserves; ", "        uint[] memory assetReserves; ", "        address token0 = pair.token0();", "        address token1 = pair.token1();", "        uint decimals;", "", "        if (pair.stable()) { // stable pairs will be priced in terms of Note", "            if (token0 == note) { //token0 is the unit, token1 will be priced with respect to this asset initially", "                decimals = 10 ** (erc20(token1).decimals()); // we must normalize the price of token1 to 18 decimals", "                prices = pair.sample(token1, decimals, 8, 1);", "                (unitReserves, assetReserves) = pair.sampleReserves(8, 1);", "            } else {", "                decimals = 10 ** (erc20(token0).decimals());", "                prices = pair.sample(token0, decimals, 8, 1);", "                (assetReserves, unitReserves) = pair.sampleReserves(8, 1);", "            }", "        } else { // non-stable pairs will be priced in terms of Canto", "            if (token0 == address(wcanto)) { // token0 is Canto, and the unit asset of this pair is Canto", "                decimals = 10 ** (erc20(token1).decimals());", "                prices = pair.sample(token1, decimals, 8, 1);", "                (unitReserves, assetReserves) = pair.sampleReserves(8, 1);", "            } else {", "                decimals = 10 ** (erc20(token0)).decimals();", "                prices = pair.sample(token0, decimals, 8, 1);", "                (assetReserves, unitReserves) = pair.sampleReserves(8, 1);", "            }", "        }", "        uint LpPricesCumulative;", "", "        for(uint i; i < 8; ++i) {", "            uint token0TVL = assetReserves[i] * (prices[i] / decimals);", "            uint token1TVL = unitReserves[i]; // price of the unit asset is always 1", "            LpPricesCumulative += (token0TVL + token1TVL) * 1e18 / supply[i];", "        }", "        uint LpPrice = LpPricesCumulative / 8; // take the average of the cumulative prices ", "        ", "        if (pair.stable()) { // this asset has been priced in terms of Note", "            return LpPrice;", "        }", "        // this asset has been priced in terms of Canto", "        return LpPrice * getPriceNote(address(wcanto), false) / 1e18; // return the price in terms of Note", "    }   "], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function getPriceUSD(address asset) public view override returns (uint256) {", "        address feed = feeds[asset];", "        require(feed != address(0), Error.ASSET_NOT_SUPPORTED);", "", "        (, int256 answer, , uint256 updatedAt, ) = AggregatorV2V3Interface(feed).latestRoundData();", "", "        require(block.timestamp <= updatedAt + stalePriceDelay, Error.STALE_PRICE);", "        require(answer >= 0, Error.NEGATIVE_PRICE);", "", "        uint256 price = uint256(answer);", "        uint8 decimals = AggregatorV2V3Interface(feed).decimals();", "        return price.scaleFrom(decimals);", "    }"], "ner_tags": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function claimAndRepay(address claimToken, bytes calldata zeroExTradeData)", "        external", "        whileBorrowing", "        nonReentrant", "        returns (uint256)", "    {", "        bytes32 id = ids[0];", "        Credit memory credit = _accrue(credits[id], id);", "", "        if (msg.sender != borrower && msg.sender != credit.lender) {", "            revert CallerAccessDenied();", "        }", "", "        uint256 newTokens = claimToken == credit.token ?", "          spigot.claimEscrow(claimToken) :  // same asset. dont trade", "          _claimAndTrade(                   // trade revenue token for debt obligation", "              claimToken,", "              credit.token,", "              zeroExTradeData", "          );", "", "        uint256 repaid = newTokens + unusedTokens[credit.token];", "        uint256 debt = credit.interestAccrued + credit.principal;", "", "        // cap payment to debt value", "        if (repaid > debt) repaid = debt;", "        // update unused amount based on usage", "        if (repaid > newTokens) {", "            // using bought + unused to repay line", "            unusedTokens[credit.token] -= repaid - newTokens;", "        } else {", "            // high revenue and bought more than we need", "            unusedTokens[credit.token] += newTokens - repaid;", "        }", "", "        credits[id] = _repay(credit, id, repaid);", "", "        emit RevenuePayment(claimToken, repaid);", "", "        return newTokens;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function removeLiquidity(", "        uint256 lpAmount,", "        uint256 minStETHOut,", "        uint256 minXETHOut", "    )", "        external", "        onlyRole(DEFAULT_ADMIN_ROLE)", "        returns (uint256[2] memory outputs)", "    {", "        /// @dev check if AMO owns enough LP", "        uint256 amoBalance = cvxStaker.stakedBalance();", "", "        if (lpAmount > amoBalance) {", "            revert LpBalanceTooLow();", "        }", "", "        cvxStaker.withdrawAndUnwrap(lpAmount, false, address(this));", "", "        uint256[2] memory minAmounts;", "", "        minAmounts[xETHIndex] = minXETHOut;", "        minAmounts[stETHIndex] = minStETHOut;", "", "        outputs = curvePool.remove_liquidity(lpAmount, minAmounts);", "", "        xETH.burnShares(outputs[xETHIndex]);", "        stETH.safeTransfer(msg.sender, outputs[stETHIndex]);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function redeem(", "        uint256 amount,", "        address receiver,", "        uint256 deadline,", "        uint256[] memory minAmountOuts", "    ) external returns (address[] memory tokens, uint256[] memory amounts) {", "        return _redeem(amount, receiver, deadline, minAmountOuts, new address[](0));", "    }"], "ner_tags": [0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["    function getPricePerFullShare() external view returns (uint256) {", "        uint256 supply = totalSupply();", "        if (supply == 0) return 0;", "        return (balance() * 1e18) / supply;", "    }"], "ner_tags": [0, 0, 0, 1, 0]}
{"tokens": ["    function provideLiquidity(bytes32 _poolId, IVault.JoinPoolRequest memory _request) public {", "        require(msg.sender == provider, \"!auth\");", "        require(_request.assets.length == 2 && _request.maxAmountsIn.length == 2, \"!valid\");", "        require(pairToken.balanceOf(address(this)) > minPairAmount, \"!minLiq\");", "", "        for (uint256 i = 0; i < 2; i++) {", "            address asset = address(_request.assets[i]);", "            require(asset == address(startToken) || asset == address(pairToken), \"!asset\");", "", "            IERC20 tkn = IERC20(asset);", "            uint256 bal = tkn.balanceOf(address(this));", "            require(bal > 0 && bal == _request.maxAmountsIn[i], \"!bal\");", "", "            tkn.safeApprove(address(bVault), 0);", "            tkn.safeApprove(address(bVault), bal);", "        }", "", "        (address pool, ) = bVault.getPool(_poolId);", "        uint256 supplyBefore = IERC20(pool).totalSupply();", "        require(supplyBefore == 0, \"!init\");", "", "        bVault.joinPool(_poolId, address(this), dao, _request);", "", "        uint256 balAfter = IERC20(pool).balanceOf(dao);", "        require(balAfter > 0, \"!mint\");", "", "        emit LiquidityProvided(_request.maxAmountsIn, balAfter);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function bulkExecute(Execution[] calldata executions)", "        external", "        payable", "        whenOpen", "        setupExecution", "    {", "        /*", "        REFERENCE", "        uint256 executionsLength = executions.length;", "        for (uint8 i=0; i < executionsLength; i++) {", "            bytes memory data = abi.encodeWithSelector(this._execute.selector, executions[i].sell, executions[i].buy);", "            (bool success,) = address(this).delegatecall(data);", "        }", "        _returnDust(remainingETH);", "        */", "        uint256 executionsLength = executions.length;", "        for (uint8 i = 0; i < executionsLength; i++) {", "            assembly {", "                let memPointer := mload(0x40)", "", "                let order_location := calldataload(add(executions.offset, mul(i, 0x20)))", "                let order_pointer := add(executions.offset, order_location)", "", "                let size", "                switch eq(add(i, 0x01), executionsLength)", "                case 1 {", "                    size := sub(calldatasize(), order_pointer)", "                }", "                default {", "                    let next_order_location := calldataload(add(executions.offset, mul(add(i, 0x01), 0x20)))", "                    let next_order_pointer := add(executions.offset, next_order_location)", "                    size := sub(next_order_pointer, order_pointer)", "                }", "", "                mstore(memPointer, 0xe04d94ae00000000000000000000000000000000000000000000000000000000) // _execute", "                calldatacopy(add(0x04, memPointer), order_pointer, size)", "                // must be put in separate transaction to bypass failed executions", "                // must be put in delegatecall to maintain the authorization from the caller", "                let result := delegatecall(gas(), address(), memPointer, add(size, 0x04), 0, 0)", "            }", "        }", "        _returnDust();", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function safeTransferMany(address _to, uint[] calldata _ids) external {", "        for (uint i=0; i<_ids.length; i++) {", "            _transfer(_msgSender(), _to, _ids[i]);", "        }", "    }"], "ner_tags": [0, 0, 1, 0, 0]}
{"tokens": ["  function checkRewardUnderflow() public onlyActive {", "    uint256 epoch = timekeeper.epoch();", "", "    uint256 _activeEpoch = activeEpoch; // gas", "", "    // Fill in gaps so we have a fresh foundation to calculate from", "    _fillInEpochGaps(epoch);", "", "    if (epoch > _activeEpoch) {", "      for (uint256 i = _activeEpoch; i < epoch; ++i) {", "        uint256 underflow = _getRewardUnderflow(i);", "", "        if (underflow > 0) {", "          uint256 balance = overflowPool.requestCapital(underflow);", "", "          _sendToDistributor(balance, i);", "        }", "      }", "    }", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": ["    function _validateSignatures(", "        bytes32 messageHash,", "        address[] memory operators,", "        uint256[] memory weights,", "        uint256 threshold,", "        bytes[] memory signatures", "    ) internal pure {", "        uint256 operatorsLength = operators.length;", "        uint256 operatorIndex = 0;", "        uint256 weight = 0;", "        // looking for signers within operators", "        // assuming that both operators and signatures are sorted", "        for (uint256 i = 0; i < signatures.length; ++i) {", "            address signer = ECDSA.recover(messageHash, signatures[i]);", "            // looping through remaining operators to find a match", "            for (; operatorIndex < operatorsLength && signer != operators[operatorIndex]; ++operatorIndex) {}", "            // checking if we are out of operators", "            if (operatorIndex == operatorsLength) revert MalformedSigners();", "            // return if weight sum above threshold", "            weight += weights[operatorIndex];", "            // weight needs to reach or surpass threshold", "            if (weight >= threshold) return;", "            // increasing operators index if match was found", "            ++operatorIndex;", "        }", "        // if weight sum below threshold", "        revert MalformedSigners();", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _squeezeDripsResult(", "        uint256 userId,", "        uint256 assetId,", "        uint256 senderId,", "        bytes32 historyHash,", "        DripsHistory[] memory dripsHistory", "    )", "        internal", "        view", "        returns (", "            uint128 amt,", "            uint256 squeezedNum,", "            uint256[] memory squeezedRevIdxs,", "            bytes32[] memory historyHashes,", "            uint256 currCycleConfigs", "        )", "    {", "        {", "            DripsState storage sender = _dripsStorage().states[assetId][senderId];", "            historyHashes = _verifyDripsHistory(historyHash, dripsHistory, sender.dripsHistoryHash);", "            // If the last update was not in the current cycle,", "            // there's only the single latest history entry to squeeze in the current cycle.", "            currCycleConfigs = 1;", "            // slither-disable-next-line timestamp", "            if (sender.updateTime >= _currCycleStart()) currCycleConfigs = sender.currCycleConfigs;", "        }", "        squeezedRevIdxs = new uint256[](dripsHistory.length);", "        uint32[2 ** 32] storage nextSqueezed =", "            _dripsStorage().states[assetId][userId].nextSqueezed[senderId];", "        uint32 squeezeEndCap = _currTimestamp();", "        for (uint256 i = 1; i <= dripsHistory.length && i <= currCycleConfigs; i++) {", "            DripsHistory memory drips = dripsHistory[dripsHistory.length - i];", "            if (drips.receivers.length != 0) {", "                uint32 squeezeStartCap = nextSqueezed[currCycleConfigs - i];", "                if (squeezeStartCap < _currCycleStart()) squeezeStartCap = _currCycleStart();", "                if (squeezeStartCap < squeezeEndCap) {", "                    squeezedRevIdxs[squeezedNum++] = i;", "                    amt += _squeezedAmt(userId, drips, squeezeStartCap, squeezeEndCap);", "                }", "            }", "            squeezeEndCap = drips.updateTime;", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": ["    function getPriorVotes(uint256 tokenId, uint256 blockNumber) public view returns (uint256) {", "        require(blockNumber < block.number, 'VEDelegation: not yet determined');", "        uint256[] memory delegatednft = _getPriorDelegated(tokenId, blockNumber);", "        uint256 votes = 0;", "        for (uint256 index = 0; index < delegatednft.length; index++) {", "            votes = votes + this.balanceOfAtNFT(delegatednft[index], blockNumber);", "        }", "        return votes;", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function stake(uint amount) external {", "        // Get current exchange rate between ALCX and gALCX", "        bumpExchangeRate();", "        // Then receive new deposits", "        bool success = alcx.transferFrom(msg.sender, address(this), amount);", "        require(success, \"Transfer failed\");", "        pools.deposit(poolId, amount);", "        // gAmount always <= amount", "        uint gAmount = amount * exchangeRatePrecision / exchangeRate;", "        _mint(msg.sender, gAmount);", "        emit Stake(msg.sender, gAmount, amount);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}
{"tokens": ["    function canBatchContractByIndex(uint256 _index)", "        external", "        view", "        returns (address, bool)", "    {", "        return (", "            contracts[_index],", "            IStaking(contracts[_index]).canBatchTransactions()", "        );", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["\tfunction withdrawMinipoolFunds(address nodeID) external nonReentrant {", "\t\tint256 minipoolIndex = requireValidMinipool(nodeID);", "\t\taddress owner = onlyOwner(minipoolIndex);", "\t\trequireValidStateTransition(minipoolIndex, MinipoolStatus.Finished);", "\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".status\")), uint256(MinipoolStatus.Finished));", "", "\t\tuint256 avaxNodeOpAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxNodeOpAmt\")));", "\t\tuint256 avaxNodeOpRewardAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxNodeOpRewardAmt\")));", "\t\tuint256 totalAvaxAmt = avaxNodeOpAmt + avaxNodeOpRewardAmt;", "", "\t\tStaking staking = Staking(getContractAddress(\"Staking\"));", "\t\tstaking.decreaseAVAXStake(owner, avaxNodeOpAmt);", "", "\t\tVault vault = Vault(getContractAddress(\"Vault\"));", "\t\tvault.withdrawAVAX(totalAvaxAmt);", "\t\towner.safeTransferETH(totalAvaxAmt);", "\t}"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _updateExchangeRate() internal returns (uint256 _exchangeRate) {", "        ExchangeRateInfo memory _exchangeRateInfo = exchangeRateInfo;", "        if (_exchangeRateInfo.lastTimestamp == block.timestamp) {", "            return _exchangeRate = _exchangeRateInfo.exchangeRate;", "        }", "", "        uint256 _price = uint256(1e36);", "        if (oracleMultiply != address(0)) {", "            (, int256 _answer, , , ) = AggregatorV3Interface(oracleMultiply).latestRoundData();", "            if (_answer <= 0) {", "                revert OracleLTEZero(oracleMultiply);", "            }", "            _price = _price * uint256(_answer);", "        }", "", "        if (oracleDivide != address(0)) {", "            (, int256 _answer, , , ) = AggregatorV3Interface(oracleDivide).latestRoundData();", "            if (_answer <= 0) {", "                revert OracleLTEZero(oracleDivide);", "            }", "            _price = _price / uint256(_answer);", "        }", "", "        _exchangeRate = _price / oracleNormalization;", "", "        // write to storage, if no overflow", "        if (_exchangeRate > type(uint224).max) revert PriceTooLarge();", "        _exchangeRateInfo.exchangeRate = uint224(_exchangeRate);", "        _exchangeRateInfo.lastTimestamp = uint32(block.timestamp);", "        exchangeRateInfo = _exchangeRateInfo;", "        emit UpdateExchangeRate(_exchangeRate);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function init(address _owner, address _entryPointAddress, address _handler) public override initializer { ", "        require(owner == address(0), \"Already initialized\");", "        require(address(_entryPoint) == address(0), \"Already initialized\");", "        require(_owner != address(0),\"Invalid owner\");", "        require(_entryPointAddress != address(0), \"Invalid Entrypoint\");", "        require(_handler != address(0), \"Invalid Entrypoint\");", "        owner = _owner;", "        _entryPoint =  IEntryPoint(payable(_entryPointAddress));", "        if (_handler != address(0)) internalSetFallbackHandler(_handler);", "        setupModules(address(0), bytes(\"\"));", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function cancelForETH(uint256 id) external returns (bool outcome) {", "        (uint256 pay_amt, ERC20 pay_gem, , ) = RubiconMarket(", "            RubiconMarketAddress", "        ).getOffer(id);", "        require(", "            address(pay_gem) == wethAddress,", "            \"trying to cancel a non WETH order\"", "        );", "        // Cancel order and receive WETH here in amount of pay_amt", "        outcome = RubiconMarket(RubiconMarketAddress).cancel(id);", "        WETH9(wethAddress).withdraw(pay_amt);", "        msg.sender.transfer(pay_amt);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["    constructor(", "        uint256 _minDelay,", "        address[] memory _proposers,", "        address[] memory _executors", "    )", "        TimelockController(_minDelay, _proposers, _executors)", "    // solhint-disable-next-line no-empty-blocks", "    {", "        minDelay = _minDelay;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["    function _distributeETHRewardsToUserForToken(", "        address _user,", "        address _token,", "        uint256 _balance,", "        address _recipient", "    ) internal {", "        require(_recipient != address(0), \"Zero address\");", "        uint256 balance = _balance;", "        if (balance > 0) {", "            // Calculate how much ETH rewards the address is owed / due ", "            uint256 due = ((accumulatedETHPerLPShare * balance) / PRECISION) - claimed[_user][_token];", "            if (due > 0) {", "                claimed[_user][_token] = due;", "", "                totalClaimed += due;", "", "                (bool success, ) = _recipient.call{value: due}(\"\");", "                require(success, \"Failed to transfer\");", "", "                emit ETHDistributed(_user, _recipient, due);", "            }", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function claimRewards(address[] calldata _tokens) external override {", "        for (uint256 i = 0; i < _tokens.length; i++) {", "            uint256 getting = reward[msg.sender][_tokens[i]];", "            IERC20(_tokens[i]).safeTransfer(msg.sender, getting);", "            reward[msg.sender][_tokens[i]] = 0;", "        }", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function setSubnodeRecord(", "        bytes32 parentNode,", "        string memory label,", "        address newOwner,", "        address resolver,", "        uint64 ttl,", "        uint32 fuses,", "        uint64 expiry", "    )", "        public", "        onlyTokenOwner(parentNode)", "        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))", "    {", "        bytes32 labelhash = keccak256(bytes(label));", "        bytes32 node = _makeNode(parentNode, labelhash);", "        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);", "        if (ens.owner(node) != address(this)) {", "            ens.setSubnodeRecord(", "                parentNode,", "                labelhash,", "                address(this),", "                resolver,", "                ttl", "            );", "            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);", "        } else {", "            ens.setSubnodeRecord(", "                parentNode,", "                labelhash,", "                address(this),", "                resolver,", "                ttl", "            );", "            _transferAndBurnFuses(node, newOwner, fuses, expiry);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["  function _appendStack(", "    LienStorage storage s,", "    Stack[] memory stack,", "    Stack memory newSlot", "  ) internal returns (Stack[] memory newStack) {", "    if (stack.length >= s.maxLiens) {", "      revert InvalidState(InvalidStates.MAX_LIENS);", "    }", "", "    newStack = new Stack[](stack.length + 1);", "    newStack[stack.length] = newSlot;", "", "    uint256 potentialDebt = _getOwed(newSlot, newSlot.point.end);", "    for (uint256 i = stack.length; i > 0; ) {", "      uint256 j = i - 1;", "      newStack[j] = stack[j];", "      if (block.timestamp >= newStack[j].point.end) {", "        revert InvalidState(InvalidStates.EXPIRED_LIEN);", "      }", "", "      unchecked {", "        potentialDebt += _getOwed(newStack[j], newStack[j].point.end);", "      }", "      if (potentialDebt > newStack[j].lien.details.liquidationInitialAsk) {", "        revert InvalidState(InvalidStates.INITIAL_ASK_EXCEEDED);", "      }", "", "      unchecked {", "        --i;", "      }", "    }", "    if (", "      stack.length > 0 && potentialDebt > newSlot.lien.details.maxPotentialDebt", "    ) {", "      revert InvalidState(InvalidStates.DEBT_LIMIT);", "    }", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function release(", "        IERC20 token,", "        address recipient,", "        uint256 sharesWithdrawn,", "        uint256 initialTotalSupply,", "        uint256 poolFee", "    ) external override {", "        require(", "            msg.sender == beneficiary,", "            \"Caller is not the Bath Token beneficiary of these rewards\"", "        );", "        uint256 releasable = vestedAmount(", "            address(token),", "            uint64(block.timestamp)", "        ) - released(address(token));", "        if (releasable > 0) {", "            uint256 amount = releasable.mul(sharesWithdrawn).div(", "                initialTotalSupply", "            );", "            uint256 _fee = amount.mul(poolFee).div(10000);", "", "            // If FeeTo == address(this) then the fee is effectively accrued by the pool", "            // Assume the caller is the liquidity pool and they receive the fee", "            // Keep tokens here by not transfering the _fee anywhere, it is accrued to the Bath Token's Bath Buddy", "            // token.transfer(address(this), _fee);", "", "            uint256 amountWithdrawn = amount.sub(_fee);", "            token.transfer(recipient, amountWithdrawn);", "", "            _erc20Released[address(token)] += amount;", "            emit ERC20Released(address(token), amount);", "", "            emit LogClaimBonusToken(", "                recipient,", "                msg.sender,", "                amountWithdrawn,", "                sharesWithdrawn,", "                token,", "                releasable", "            );", "        }", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function mint(bytes[] calldata _addList) external {", "        _mint(msg.sender, ++numMinted); // We do not use _safeMint here on purpose. If a contract calls this method, he expects to get an NFT back", "        bytes4 addSelector = this.add.selector;", "        for (uint256 i = 0; i < _addList.length; ++i) {", "            (", "                bool success, /*bytes memory result*/", "", "            ) = address(this).delegatecall(abi.encodePacked(addSelector, _addList[i]));", "            if (!success) revert AddCallAfterMintingFailed(i);", "        }", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["\tfunction getPoolReward (", "\t\tAssetType _assetType,", "\t\taddress _recipient", "\t) public view returns (uint256, uint256) {", "", "\t\t/*", "\t\t\tDuring the very first stake, there will not be any points in the pool. In ", "\t\t\tthis case, do not attempt to grant any rewards so as to prevent reversion.", "\t\t*/", "\t\tPoolData storage pool = _pools[_assetType];", "\t\tif (pool.totalPoints != 0) {", "", "\t\t\t// Calculate the total number of points accrued to the `_recipient`.", "\t\t\tuint256 points;", "\t\t\tif (_assetType == AssetType.S1_CITIZEN) {", "\t\t\t\tfor (uint256 i; i < _stakerS1Position[_recipient].length; ) {", "\t\t\t\t\tuint256 citizenId = _stakerS1Position[_recipient][i];", "\t\t\t\t\tStakedS1Citizen memory s1Citizen = stakedS1[_recipient][citizenId];", "\t\t\t\t\tunchecked {", "\t\t\t\t\t\tpoints += s1Citizen.points;", "\t\t\t\t\t\ti++;", "\t\t\t\t\t}", "\t\t\t\t}", "\t\t\t} else if (_assetType == AssetType.S2_CITIZEN) {", "\t\t\t\tfor (uint256 i; i < _stakerS2Position[_recipient].length; ) {", "\t\t\t\t\tuint256 citizenId = _stakerS2Position[_recipient][i];", "\t\t\t\t\tStakedS2Citizen memory s2Citizen = stakedS2[_recipient][citizenId];", "\t\t\t\t\tunchecked {", "\t\t\t\t\t\tpoints += s2Citizen.points;", "\t\t\t\t\t\ti++;", "\t\t\t\t\t}", "\t\t\t\t}", "\t\t\t} else if (_assetType == AssetType.LP) {", "\t\t\t\tunchecked {", "\t\t\t\t\tpoints += stakerLPPosition[_recipient].points;", "\t\t\t\t}", "\t\t\t} else {", "\t\t\t\trevert InvalidAssetType(uint256(_assetType));", "\t\t\t}", "", "\t\t\t/*", "\t\t\t\tDetermine the reward for the `_recipient` based on their points total. ", "\t\t\t\tIterate through the entire array of pool reward windows to find the ", "\t\t\t\tapplicable time period.", "\t\t\t*/", "\t\t\tuint256 totalReward;", "\t\t\tuint256 lastPoolRewardTime = lastRewardTime[_recipient][_assetType];", "\t\t\tuint256 windowCount = pool.rewardCount;", "\t\t\tfor (uint256 i; i < windowCount; ) {", "\t\t\t\tRewardWindow memory window = pool.rewardWindows[i];", "", "\t\t\t\t/*", "\t\t\t\t\tIf the last reward time is less than the starting time of this ", "\t\t\t\t\twindow, then the reward was accrued in the previous window.", "\t\t\t\t*/", "\t\t\t\tif (lastPoolRewardTime < window.startTime) {", "\t\t\t\t\tuint256 currentRewardRate = pool.rewardWindows[i - 1].reward;", "", "\t\t\t\t\t/*", "\t\t\t\t\t\tIterate forward to the present timestamp over any unclaimed reward ", "\t\t\t\t\t\twindows.", "\t\t\t\t\t*/", "\t\t\t\t\tfor (uint256 j = i; j < windowCount; ) {", "", "\t\t\t\t\t\t// If the current time falls within this window, complete.", "\t\t\t\t\t\tif (block.timestamp <= window.startTime) {", "\t\t\t\t\t\t\tunchecked {", "\t\t\t\t\t\t\t\tuint256 timeSinceReward = block.timestamp - lastPoolRewardTime;", "\t\t\t\t\t\t\t\ttotalReward += currentRewardRate * timeSinceReward;\t", "\t\t\t\t\t\t\t}", "", "\t\t\t\t\t\t\t// We have no forward goto and thus include this bastardry.", "\t\t\t\t\t\t\ti = windowCount;", "\t\t\t\t\t\t\tbreak;", "", "\t\t\t\t\t\t// Otherwise, accrue the remainder of this window and iterate.", "\t\t\t\t\t\t} else {", "\t\t\t\t\t\t\tunchecked {", "\t\t\t\t\t\t\t\tuint256 timeSinceReward = window.startTime - lastPoolRewardTime;", "\t\t\t\t\t\t\t\ttotalReward += currentRewardRate * timeSinceReward;", "\t\t\t\t\t\t\t}", "\t\t\t\t\t\t\tcurrentRewardRate = window.reward;", "\t\t\t\t\t\t\tlastPoolRewardTime = window.startTime;", "", "\t\t\t\t\t\t\t/*", "\t\t\t\t\t\t\t\tHandle the special case of overrunning the final window by ", "\t\t\t\t\t\t\t\tfulfilling the prior window and then jumping forward to use the ", "\t\t\t\t\t\t\t\tfinal reward window.", "\t\t\t\t\t\t\t*/", "\t\t\t\t\t\t\tif (j == windowCount - 1) {", "\t\t\t\t\t\t\t\tunchecked {", "\t\t\t\t\t\t\t\t\tuint256 timeSinceReward =", "\t\t\t\t\t\t\t\t\t\tblock.timestamp - lastPoolRewardTime;", "\t\t\t\t\t\t\t\t\ttotalReward += currentRewardRate * timeSinceReward;", "\t\t\t\t\t\t\t\t}", "\t", "\t\t\t\t\t\t\t\t// We have no forward goto and thus include this bastardry.", "\t\t\t\t\t\t\t\ti = windowCount;", "\t\t\t\t\t\t\t\tbreak;", "\t", "\t\t\t\t\t\t\t// Otherwise, iterate.", "\t\t\t\t\t\t\t} else {", "\t\t\t\t\t\t\t\twindow = pool.rewardWindows[j + 1];", "\t\t\t\t\t\t\t}", "\t\t\t\t\t\t}", "\t\t\t\t\t\tunchecked { j++; }", "\t\t\t\t\t}", "", "\t\t\t\t/*", "\t\t\t\t\tOtherwise, the last reward rate, and therefore the entireity of ", "\t\t\t\t\taccrual, falls in the last window.", "\t\t\t\t*/", "\t\t\t\t} else if (i == windowCount - 1) {", "\t\t\t\t\tunchecked {", "\t\t\t\t\t\tuint256 timeSinceReward = block.timestamp - lastPoolRewardTime;", "\t\t\t\t\t\ttotalReward = window.reward * timeSinceReward;", "\t\t\t\t\t}", "\t\t\t\t\tbreak;", "\t\t\t\t}", "\t\t\t\tunchecked { i++; }", "\t\t\t}", "", "\t\t\t// Return final shares.", "\t\t\tunchecked {", "\t\t\t\tuint256 share = points * _PRECISION / pool.totalPoints * totalReward;", "\t\t\t\tuint256 daoShare = share * pool.daoTax / (100 * _DIVISOR);", "\t\t\t\tshare /= _PRECISION;", "\t\t\t\tdaoShare /= _PRECISION;", "\t\t\t\treturn ((share - daoShare), daoShare);", "\t\t\t}", "\t\t}", "\t\treturn (0, 0);", "\t}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": ["  function setAutomation(uint256 vaultId, AutomatedVault calldata autoParams) external override {", "    address vaultOwner = a.vaultsData().vaultOwner(vaultId);", "    address mimoProxy = address(proxyRegistry.getCurrentProxy(msg.sender));", "", "    if (mimoProxy != vaultOwner && vaultOwner != msg.sender) {", "      revert CustomErrors.CALLER_NOT_VAULT_OWNER(mimoProxy, vaultOwner);", "    }", "", "    uint256 toVaultMcr = a.config().collateralMinCollateralRatio(autoParams.toCollateral);", "    uint256 maxVarFee = (autoParams.targetRatio.wadDiv(toVaultMcr + autoParams.mcrBuffer) + WadRayMath.WAD).wadDiv(", "      autoParams.targetRatio", "    );", "", "    if (autoParams.varFee >= maxVarFee) {", "      revert CustomErrors.VARIABLE_FEE_TOO_HIGH(maxVarFee, autoParams.varFee);", "    }", "", "    _automatedVaults[vaultId] = autoParams;", "", "    emit AutomationSet(vaultId, autoParams);", "  }"], "ner_tags": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function createFixedSale(FixedPrice.Sale calldata _sale) external returns (address clone) {", "        require(IEscher721(_sale.edition).hasRole(bytes32(0x00), msg.sender), \"NOT AUTHORIZED\");", "        require(_sale.startTime >= block.timestamp, \"START TIME IN PAST\");", "        require(_sale.finalId > _sale.currentId, \"FINAL ID BEFORE CURRENT\");", "", "        clone = implementation.clone();", "        FixedPrice(clone).initialize(_sale);", "", "        emit NewFixedPriceContract(msg.sender, _sale.edition, clone, _sale);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function store(Instruction[] calldata instructions_) external permissioned returns (uint256) {", "        uint256 length = instructions_.length;", "        uint256 instructionsId = ++totalInstructions;", "", "        Instruction[] storage instructions = storedInstructions[instructionsId];", "", "        if (length == 0) revert INSTR_InstructionsCannotBeEmpty();", "", "        for (uint256 i; i < length; ) {", "            Instruction calldata instruction = instructions_[i];", "            ensureContract(instruction.target);", "", "            // If the instruction deals with a module, make sure the module has a valid keycode (UPPERCASE A-Z ONLY)", "            if (", "                instruction.action == Actions.InstallModule ||", "                instruction.action == Actions.UpgradeModule", "            ) {", "                Module module = Module(instruction.target);", "                ensureValidKeycode(module.KEYCODE());", "            } else if (instruction.action == Actions.ChangeExecutor && i != length - 1) {", "                // Throw an error if ChangeExecutor exists and is not the last Action in the instruction list.", "                // This exists because if ChangeExecutor is not the last item in the list of instructions,", "                // the Kernel will not recognize any of the following instructions as valid, since the policy", "                // executing the list of instructions no longer has permissions in the Kernel. To avoid this issue", "                // and prevent invalid proposals from being saved, we perform this check.", "                revert INSTR_InvalidChangeExecutorAction();", "            }", "", "            instructions.push(instructions_[i]);", "            unchecked {", "                ++i;", "            }", "        }", "", "        emit InstructionsStored(instructionsId);", "", "        return instructionsId;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _incrementGaugeWeight(", "        address user,", "        address gauge,", "        uint112 weight,", "        uint32 cycle", "    ) internal {", "        if (_deprecatedGauges.contains(gauge)) revert InvalidGaugeError();", "        unchecked {", "            if (cycle - block.timestamp <= incrementFreezeWindow) revert IncrementFreezeError();", "        }", "", "        bool added = _userGauges[user].add(gauge); // idempotent add", "        if (added && _userGauges[user].length() > maxGauges && !canContractExceedMaxGauges[user])", "            revert MaxGaugeError();", "", "        getUserGaugeWeight[user][gauge] += weight;", "", "        _writeGaugeWeight(_getGaugeWeight[gauge], _add, weight, cycle);", "", "        emit IncrementGaugeWeight(user, gauge, weight, cycle);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function setApprovalForAll(address to, bool approved) external {", "    require(to != msg.sender, \"ERC721: cannot approve self\");", "    if (_isEventRegistered(HolographERC721Event.beforeApprovalAll)) {", "      require(SourceERC721().beforeApprovalAll(to, approved));", "    }", "    _operatorApprovals[msg.sender][to] = approved;", "    emit ApprovalForAll(msg.sender, to, approved);", "    if (_isEventRegistered(HolographERC721Event.afterApprovalAll)) {", "      require(SourceERC721().afterApprovalAll(to, approved));", "    }", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["    function previewWithdraw(uint256 assets)", "        public", "        view", "        returns (uint256 shares)", "    {", "        if (totalSupply == 0) {", "            shares = 0;", "        } else {", "            uint256 amountWithdrawn;", "            uint256 _fee = assets.mul(feeBPS).div(10000);", "            amountWithdrawn = assets.sub(_fee);", "            shares = convertToShares(amountWithdrawn);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["    function buy(uint256 id, uint256 amount)", "        public", "        override", "        can_buy(id)", "        returns (bool)", "    {", "        require(!locked, \"Reentrancy attempt\");", "", "        //Optional distribution on trade", "        if (AqueductDistributionLive) {", "            IAqueduct(AqueductAddress).distributeToMakerAndTaker(", "                getOwner(id),", "                msg.sender", "            );", "        }", "        function(uint256, uint256) returns (bool) fn = matchingEnabled", "            ? _buys", "            : super.buy;", "", "        return fn(id, amount);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function getUnderlyingPrice(CToken cToken) external view returns (uint) {", "        if (address(cToken) == cEtherAddress) {", "            // ether always worth 1", "            return 1e18;", "        }", "", "        // For now, we only have USDC and ETH.", "        int256 usdcPrice = ChainlinkFeed(0x986b5E1e1755e3C2440e960477f25201B0a8bbD4).latestAnswer();", "        if (usdcPrice <= 0) {", "            return 0;", "        }", "", "        // Checck for overflow.", "        uint256 result = uint256(usdcPrice) * 1e12;", "        if (result / uint256(usdcPrice) != 1e12) {", "            return 0;", "        }", "", "        return result;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function tokenURI(uint256 _id) public view override returns (string memory) {", "        if (ownerOf[_id] == address(0))", "            // According to ERC721, this revert for non-existing tokens is required", "            revert TokenNotMinted(_id);", "        return string(abi.encodePacked(baseURI, _id, \".json\"));", "    }"], "ner_tags": [0, 0, 0, 0, 1, 0]}
{"tokens": ["    function isOtherEarningsClaimable(address user) public view returns (bool) {", "        return (stakedLBRLpValue(user) * 10000) / stakedOf(user) < 500;", "    }"], "ner_tags": [0, 1, 0]}
{"tokens": ["    function _transferFrom(", "        address _from,", "        address _to,", "        uint256 _tokenId,", "        address _sender", "    ) internal override {", "        require(attachments[_tokenId] == 0 && !voted[_tokenId], 'attached');", "", "        // remove the delegation", "        this.removeDelegation(_tokenId);", "", "        // Check requirements", "        require(_isApprovedOrOwner(_sender, _tokenId));", "        // Clear approval. Throws if `_from` is not the current owner", "        _clearApproval(_from, _tokenId);", "        // Remove NFT. Throws if `_tokenId` is not a valid NFT", "        _removeTokenFrom(_from, _tokenId);", "        // Add NFT", "        _addTokenTo(_to, _tokenId);", "        // Set the block of ownership transfer (for Flash NFT protection)", "        ownership_change[_tokenId] = block.number;", "        // Log the transfer", "        emit Transfer(_from, _to, _tokenId);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function createAuction(", "        AuctionParameters calldata auctionParams,", "        Timings calldata timings,", "        bytes calldata encryptedSellerPrivKey", "    ) external returns (uint256) {", "        if (timings.endTimestamp <= block.timestamp) {", "            revert InvalidTimestamp();", "        }", "        if (timings.startTimestamp >= timings.endTimestamp) {", "            revert InvalidTimestamp();", "        }", "        if (timings.endTimestamp > timings.vestingStartTimestamp) {", "            revert InvalidTimestamp();", "        }", "        if (timings.vestingStartTimestamp > timings.vestingEndTimestamp) {", "            revert InvalidTimestamp();", "        }", "        if (timings.cliffPercent > 1e18) {", "            revert InvalidCliffPercent();", "        }", "        // Revert if the min bid is more than the total reserve of the auction", "        if (", "            FixedPointMathLib.mulDivDown(", "                auctionParams.minimumBidQuote, type(uint128).max, auctionParams.totalBaseAmount", "            ) > auctionParams.reserveQuotePerBase", "        ) {", "            revert InvalidReserve();", "        }", "", "        uint256 auctionId = ++currentAuctionId;", "", "        Auction storage a = idToAuction[auctionId];", "        a.timings = timings;", "", "        a.data.seller = msg.sender;", "        a.data.lowestQuote = type(uint128).max;", "", "        a.params = auctionParams;", "", "        // Passes https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol#L9", "        // Transfer base tokens to auction contract and check for tax tokens", "        uint256 balanceBeforeTransfer = ERC20(auctionParams.baseToken).balanceOf(address(this));", "", "        SafeTransferLib.safeTransferFrom(", "            ERC20(auctionParams.baseToken), msg.sender, address(this), auctionParams.totalBaseAmount", "        );", "", "        uint256 balanceAfterTransfer = ERC20(auctionParams.baseToken).balanceOf(address(this));", "        if (balanceAfterTransfer - balanceBeforeTransfer != auctionParams.totalBaseAmount) {", "            revert UnexpectedBalanceChange();", "        }", "", "        emit AuctionCreated(auctionId, msg.sender, auctionParams, timings, encryptedSellerPrivKey);", "", "        return auctionId;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function createProfile(", "        DataTypes.CreateProfileData calldata vars,", "        uint256 profileId,", "        mapping(bytes32 => uint256) storage _profileIdByHandleHash,", "        mapping(uint256 => DataTypes.ProfileStruct) storage _profileById,", "        mapping(address => bool) storage _followModuleWhitelisted", "    ) external {", "        _validateHandle(vars.handle);", "", "        bytes32 handleHash = keccak256(bytes(vars.handle));", "", "        if (_profileIdByHandleHash[handleHash] != 0) revert Errors.HandleTaken();", "        _profileIdByHandleHash[handleHash] = profileId;", "", "        _profileById[profileId].handle = vars.handle;", "        _profileById[profileId].imageURI = vars.imageURI;", "        _profileById[profileId].followNFTURI = vars.followNFTURI;", "", "        if (vars.followModule != address(0)) {", "            _profileById[profileId].followModule = vars.followModule;", "        }", "", "        bytes memory followModuleReturnData = _initFollowModule(", "            profileId,", "            vars.followModule,", "            vars.followModuleData,", "            _followModuleWhitelisted", "        );", "", "        _emitProfileCreated(profileId, vars, followModuleReturnData);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _transferAjnaRewards(uint256 rewardsEarned_) internal {", "        // check that rewards earned isn't greater than remaining balance", "        // if remaining balance is greater, set to remaining balance", "        uint256 ajnaBalance = IERC20(ajnaToken).balanceOf(address(this));", "        if (rewardsEarned_ > ajnaBalance) rewardsEarned_ = ajnaBalance;", "", "        if (rewardsEarned_ != 0) {", "            // transfer rewards to sender", "            IERC20(ajnaToken).safeTransfer(msg.sender, rewardsEarned_);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function setSwivel(address s) external authorized(admin) returns (bool) {", "        swivelAddr = s;", "        return true;", "    }"], "ner_tags": [1, 0, 0, 0]}
{"tokens": ["  function unbondUtilityToken(address operator, address recipient) external {", "    /**", "     * @dev validate that operator is currently bonded", "     */", "    require(_bondedOperators[operator] != 0, \"HOLOGRAPH: operator not bonded\");", "    /**", "     * @dev check if sender is not actual operator", "     */", "    if (msg.sender != operator) {", "      /**", "       * @dev check if operator is a smart contract", "       */", "      require(_isContract(operator), \"HOLOGRAPH: operator not contract\");", "      /**", "       * @dev check if smart contract is owned by sender", "       */", "      require(Ownable(operator).isOwner(msg.sender), \"HOLOGRAPH: sender not owner\");", "    }", "    /**", "     * @dev get current bonded amount by operator", "     */", "    uint256 amount = _bondedAmounts[operator];", "    /**", "     * @dev unset operator bond amount before making a transfer", "     */", "    _bondedAmounts[operator] = 0;", "    /**", "     * @dev remove all operator references", "     */", "    _popOperator(_bondedOperators[operator] - 1, _operatorPodIndex[operator]);", "    /**", "     * @dev transfer tokens to recipient", "     */", "    require(_utilityToken().transfer(recipient, amount), \"HOLOGRAPH: token transfer failed\");", "  }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0]}
{"tokens": ["    function removeDelegation(uint256 tokenId) external {", "        require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');", "        uint256 nCheckpoints = numCheckpoints[tokenId];", "        Checkpoint storage checkpoint = checkpoints[tokenId][nCheckpoints - 1];", "        removeElement(checkpoint.delegatedTokenIds, tokenId);", "        _writeCheckpoint(tokenId, nCheckpoints, checkpoint.delegatedTokenIds);", "    }"], "ner_tags": [0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function seizeRSR(uint256 rsrAmount) external notPausedOrFrozen {", "        require(_msgSender() == address(backingManager), \"not backing manager\");", "        require(rsrAmount > 0, \"Amount cannot be zero\");", "        uint192 initRate = exchangeRate();", "", "        uint256 rsrBalance = rsr.balanceOf(address(this));", "        require(rsrAmount <= rsrBalance, \"Cannot seize more RSR than we hold\");", "", "        uint256 seizedRSR;", "        uint256 rewards = rsrRewards();", "", "        // Remove RSR from stakeRSR", "        uint256 stakeRSRToTake = (stakeRSR * rsrAmount + (rsrBalance - 1)) / rsrBalance;", "        stakeRSR -= stakeRSRToTake;", "        seizedRSR = stakeRSRToTake;", "", "        // update stakeRate, possibly beginning a new stake era", "        if (stakeRSR > 0) {", "            // Downcast is safe: totalStakes is 1e38 at most so expression maximum value is 1e56", "            stakeRate = uint192((FIX_ONE_256 * totalStakes + (stakeRSR - 1)) / stakeRSR);", "        }", "        if (stakeRSR == 0 || stakeRate > MAX_STAKE_RATE) {", "            seizedRSR += stakeRSR;", "            beginEra();", "        }", "", "        // Remove RSR from draftRSR", "        uint256 draftRSRToTake = (draftRSR * rsrAmount + (rsrBalance - 1)) / rsrBalance;", "        draftRSR -= draftRSRToTake;", "        seizedRSR += draftRSRToTake;", "", "        // update draftRate, possibly beginning a new draft era", "        if (draftRSR > 0) {", "            // Downcast is safe: totalDrafts is 1e38 at most so expression maximum value is 1e56", "            draftRate = uint192((FIX_ONE_256 * totalDrafts + (draftRSR - 1)) / draftRSR);", "        }", "", "        if (draftRSR == 0 || draftRate > MAX_DRAFT_RATE) {", "            seizedRSR += draftRSR;", "            beginDraftEra();", "        }", "", "        // Remove RSR from yet-unpaid rewards (implicitly)", "        seizedRSR += (rewards * rsrAmount + (rsrBalance - 1)) / rsrBalance;", "", "        // Transfer RSR to caller", "        emit ExchangeRateSet(initRate, exchangeRate());", "        IERC20Upgradeable(address(rsr)).safeTransfer(_msgSender(), seizedRSR);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function revokeCollateral(address collateral) internal {", "        TransmuterStorage storage ts = s.transmuterStorage();", "        Collateral storage collatInfo = ts.collaterals[collateral];", "        if (collatInfo.decimals == 0 || collatInfo.normalizedStables > 0) revert NotCollateral();", "        uint8 isManaged = collatInfo.isManaged;", "        if (isManaged > 0) {", "            (, uint256 totalValue) = LibManager.totalAssets(collatInfo.managerData.config);", "            if (totalValue > 0) revert ManagerHasAssets();", "        }", "        delete ts.collaterals[collateral];", "        address[] memory collateralListMem = ts.collateralList;", "        uint256 length = collateralListMem.length;", "        for (uint256 i; i < length - 1; ++i) {", "            if (collateralListMem[i] == collateral) {", "                ts.collateralList[i] = collateralListMem[length - 1];", "                break;", "            }", "        }", "        ts.collateralList.pop();", "        emit CollateralRevoked(collateral);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _increaseDebt(", "        address account,", "        ERC721 asset,", "        address mintTo,", "        uint256 amount,", "        ReservoirOracleUnderwriter.OracleInfo memory oracleInfo", "    ) internal {", "        uint256 cachedTarget = updateTarget();", "", "        uint256 newDebt = _vaultInfo[account][asset].debt + amount;", "        uint256 oraclePrice =", "            underwritePriceForCollateral(asset, ReservoirOracleUnderwriter.PriceKind.LOWER, oracleInfo);", "", "        uint256 max = _maxDebt(_vaultInfo[account][asset].count * oraclePrice, cachedTarget);", "", "        if (newDebt > max) revert IPaprController.ExceedsMaxDebt(newDebt, max);", "", "        if (newDebt >= 1 << 200) revert IPaprController.DebtAmountExceedsUint200();", "", "        _vaultInfo[account][asset].debt = uint200(newDebt);", "        PaprToken(address(papr)).mint(mintTo, amount);", "", "        emit IncreaseDebt(account, asset, amount);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function togglePauseSubmits() external onlyByOwnGov {", "        submitPaused = !submitPaused;", "", "        emit SubmitPaused(submitPaused);", "    }"], "ner_tags": [1, 0, 0, 0, 0]}
{"tokens": ["    function mint(address to, uint256 tokenId) public virtual onlyRole(MINTER_ROLE) {", "        _mint(to, tokenId);", "    }"], "ner_tags": [1, 1, 1]}
{"tokens": ["  function withdraw() external {", "    withdrawFor(payable(msg.sender));", "  }"], "ner_tags": [1, 1, 1]}
{"tokens": ["    function executeDraw() external override whenNotExecutingDraw {", "        // slither-disable-next-line timestamp", "        if (block.timestamp < drawScheduledAt(currentDraw)) {", "            revert ExecutingDrawTooEarly();", "        }", "        returnUnclaimedJackpotToThePot();", "        drawExecutionInProgress = true;", "        requestRandomNumber();", "        emit StartedExecutingDraw(currentDraw);", "    }"], "ner_tags": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function end(address _vault, bytes32[] calldata _burnProof) external {", "        // Reverts if address is not a registered vault", "        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(", "            _vault", "        );", "        if (id == 0) revert NotVault(_vault);", "        // Reverts if auction state is not live", "        (", "            uint256 startTime,", "            address proposer,", "            State current,", "            ,", "            uint256 ethBalance,", "", "        ) = this.buyoutInfo(_vault);", "        State required = State.LIVE;", "        if (current != required) revert InvalidState(required, current);", "        // Reverts if current time is less than or equal to end time of auction", "        uint256 endTime = startTime + REJECTION_PERIOD;", "        if (block.timestamp <= endTime)", "            revert TimeNotElapsed(block.timestamp, endTime);", "", "        uint256 tokenBalance = IERC1155(token).balanceOf(address(this), id);", "        // Checks totalSupply of auction pool to determine if buyout is successful or not", "        if (", "            (tokenBalance * 1000) /", "                IVaultRegistry(registry).totalSupply(_vault) >", "            500", "        ) {", "            // Initializes vault transaction", "            bytes memory data = abi.encodeCall(", "                ISupply.burn,", "                (address(this), tokenBalance)", "            );", "            // Executes burn of fractional tokens from pool", "            IVault(payable(_vault)).execute(supply, data, _burnProof);", "            // Sets buyout state to successful", "            buyoutInfo[_vault].state = State.SUCCESS;", "            // Emits event for ending successful auction", "            emit End(_vault, State.SUCCESS, proposer);", "        } else {", "            // Deletes auction info", "            delete buyoutInfo[_vault];", "            // Transfers fractions and ether back to proposer of the buyout pool", "            IERC1155(token).safeTransferFrom(", "                address(this),", "                proposer,", "                id,", "                tokenBalance,", "                \"\"", "            );", "            _sendEthOrWeth(proposer, ethBalance);", "            // Emits event for ending unsuccessful auction", "            emit End(_vault, State.INACTIVE, proposer);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": ["    function excessIncomeDistribution(uint256 stETHAmount) external override {", "        uint256 excessAmount = collateralAsset.balanceOf(address(this)) - totalDepositedAsset;", "        require(excessAmount > 0 && stETHAmount > 0, \"Only LSD excess income can be exchanged\");", "        uint256 realAmount = stETHAmount > excessAmount ? excessAmount : stETHAmount;", "        uint256 payAmount = (((realAmount * getAssetPrice()) / 1e18) * getDutchAuctionDiscountPrice()) / 10000;", "", "        uint256 income = feeStored + _newFee();", "        if (payAmount > income) {", "            bool success = EUSD.transferFrom(msg.sender, address(configurator), income);", "            require(success, \"TF\");", "", "            try configurator.distributeRewards() {} catch {}", "", "            uint256 sharesAmount = EUSD.getSharesByMintedEUSD(payAmount - income);", "            if (sharesAmount == 0) {", "                //EUSD totalSupply is 0: assume that shares correspond to EUSD 1-to-1", "                sharesAmount = (payAmount - income);", "            }", "            //Income is distributed to LBR staker.", "            EUSD.burnShares(msg.sender, sharesAmount);", "            feeStored = 0;", "            emit FeeDistribution(address(configurator), income, block.timestamp);", "        } else {", "            bool success = EUSD.transferFrom(msg.sender, address(configurator), payAmount);", "            require(success, \"TF\");", "            try configurator.distributeRewards() {} catch {}", "            feeStored = income - payAmount;", "            emit FeeDistribution(address(configurator), payAmount, block.timestamp);", "        }", "", "        lastReportTime = block.timestamp;", "        collateralAsset.transfer(msg.sender, realAmount);", "        emit LSDValueCaptured(realAmount, payAmount, getDutchAuctionDiscountPrice(), block.timestamp);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function getUnderlyingPrice(CToken ctoken) external override view returns(uint) {", "         address underlying;", "        { //manual scope to pop symbol off of stack", "        string memory symbol = ctoken.symbol();", "        if (compareStrings(symbol, \"cCANTO\")) {", "            underlying = address(wcanto);", "            return getPriceNote(address(wcanto), false);", "        } else {", "            underlying = address(ICErc20(address(ctoken)).underlying()); // We are getting the price for a CErc20 lending market", "        }", "        //set price statically to 1 when the Comptroller is retrieving Price", "        if (compareStrings(symbol, \"cNOTE\")) { // note in terms of note will always be 1 ", "            return 1e18; // Stable coins supported by the lending market are instantiated by governance and their price will always be 1 note", "        } ", "        else if (compareStrings(symbol, \"cUSDT\") && (msg.sender == Comptroller )) {", "            uint decimals = erc20(underlying).decimals();", "            return 1e18 * 1e18 / (10 ** decimals); //Scale Price as a mantissa to maintain precision in comptroller", "        } ", "        else if (compareStrings(symbol, \"cUSDC\") && (msg.sender == Comptroller)) {", "            uint decimals = erc20(underlying).decimals();", "            return 1e18 * 1e18 / (10 ** decimals); //Scale Price as a mantissa to maintain precision in comptroller", "        }", "        }", "        ", "        if (isPair(underlying)) { // this is an LP Token", "            return getPriceLP(IBaseV1Pair(underlying));", "        }", "        // this is not an LP Token", "        else {", "            if (isStable[underlying]) {", "                return getPriceNote(underlying, true); // value has already been scaled", "            }", "", "            return getPriceCanto(underlying) * getPriceNote(address(wcanto), false) / 1e18;", "        }   ", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _minTokenAmountOut(uint256 wethAmount_, address token_)", "        internal", "        view", "        returns (uint256 minAmountOut)", "    {", "        return", "            wethAmount_", "                .scaledDiv(_addressProvider.getOracleProvider().getPriceETH(token_))", "                .scaledMul(slippageTolerance) / _decimalMultiplier(token_);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 1, 0]}
{"tokens": ["    function migrateVaultERC1155(", "        address _vault,", "        uint256 _proposalId,", "        address _token,", "        uint256 _id,", "        uint256 _amount,", "        bytes32[] calldata _erc1155TransferProof", "    ) external {", "        address newVault = migrationInfo[_vault][_proposalId].newVault;", "        // Withdraws an ERC-1155 token from the old vault and transfers to the new vault", "        IBuyout(buyout).withdrawERC1155(", "            _vault,", "            _token,", "            newVault,", "            _id,", "            _amount,", "            _erc1155TransferProof", "        );", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function redeem(uint256 _longAmount, uint256 _shortAmount)", "        external", "        override", "        nonReentrant", "    {", "        require(", "            _longToken.balanceOf(msg.sender) >= _longAmount,", "            \"Insufficient long tokens\"", "        );", "        require(", "            _shortToken.balanceOf(msg.sender) >= _shortAmount,", "            \"Insufficient short tokens\"", "        );", "", "        uint256 _collateralOwed;", "        if (_finalLongPrice <= MAX_PRICE) {", "            uint256 _shortPrice = MAX_PRICE - _finalLongPrice;", "            _collateralOwed =", "                (_finalLongPrice * _longAmount + _shortPrice * _shortAmount) /", "                MAX_PRICE;", "        } else {", "            require(", "                _longAmount == _shortAmount,", "                \"Long and Short must be equal\"", "            );", "            _collateralOwed = _longAmount;", "        }", "", "        _longToken.burnFrom(msg.sender, _longAmount);", "        _shortToken.burnFrom(msg.sender, _shortAmount);", "        /**", "         * Add 1 to avoid rounding to zero, only process if user is redeeming", "         * an amount large enough to pay a fee", "         */", "        uint256 _fee = (_collateralOwed * _redemptionFee) /", "            FEE_DENOMINATOR +", "            1;", "        require(_collateralOwed > _fee, \"Redemption amount too small\");", "        _collateral.transfer(_treasury, _fee);", "        _collateralOwed -= _fee;", "        _collateral.transfer(msg.sender, _collateralOwed);", "", "        emit Redemption(msg.sender, _collateralOwed);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function sourceBurn(uint256 tokenId) external onlySource {", "    address wallet = _tokenOwner[tokenId];", "    _burn(wallet, tokenId);", "  }"], "ner_tags": [1, 0, 0, 0]}
{"tokens": ["    function depositBribe(", "        bytes32 bribeIdentifier,", "        bytes32 rewardIdentifier,", "        address briber", "    ) external payable onlyRole(DEPOSITOR_ROLE) {", "        require(bribeIdentifier.length > 0, \"Invalid bribeIdentifier\");", "        require(rewardIdentifier.length > 0, \"Invalid rewardIdentifier\");", "        require(briber != address(0), \"Invalid briber\");", "        require(msg.value > 0, \"Value must be greater than 0\");", "", "        Bribe storage b = bribes[bribeIdentifier];", "        address currentToken = b.token;", "        require(", "            // For native tokens, the token address is set to this contract to prevent", "            // overwriting storage - the address can be anything but address(this) safer", "            currentToken == address(0) || currentToken == address(this),", "            \"Cannot change token\"", "        );", "", "        b.amount += msg.value; // Allow bribers to increase bribe", "", "        // Only set the token address and update the reward-to-bribe mapping if not yet set", "        if (currentToken == address(0)) {", "            b.token = address(this);", "            rewardToBribes[rewardIdentifier].push(bribeIdentifier);", "        }", "", "        emit DepositBribe(", "            bribeIdentifier,", "            rewardIdentifier,", "            b.token,", "            msg.value,", "            b.amount,", "            briber", "        );", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function repayLoan(ERC20 token_, uint256 amount_) external nonReentrant {", "        if (reserveDebt[token_][msg.sender] == 0) revert TRSRY_NoDebtOutstanding();", "", "        // Deposit from caller first (to handle nonstandard token transfers)", "        uint256 prevBalance = token_.balanceOf(address(this));", "        token_.safeTransferFrom(msg.sender, address(this), amount_);", "", "        uint256 received = token_.balanceOf(address(this)) - prevBalance;", "", "        // Subtract debt from caller", "        reserveDebt[token_][msg.sender] -= received;", "        totalDebt[token_] -= received;", "", "        emit DebtRepaid(token_, msg.sender, received);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _executeLpPoolWeight(", "        bytes32 key,", "        address lpToken,", "        address stakerVault,", "        bool isWeightManager", "    ) internal returns (bool) {", "        IStakerVault(stakerVault).poolCheckpoint();", "        totalLpPoolWeight = totalLpPoolWeight - currentUInts256[key] + pendingUInts256[key];", "        totalLpPoolWeight = totalLpPoolWeight > 0 ? totalLpPoolWeight : 0;", "        isWeightManager ? _setConfig(key, pendingUInts256[key]) : _executeUInt256(key);", "        emit NewLpWeight(lpToken, currentUInts256[key]);", "        return true;", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function _validateSwingTraderTrigger(uint256 livePrice, uint256 entryPrice)", "    internal", "    returns (bool)", "  {", "    if (usePrimedWindow) {", "      if (livePrice > entryPrice) {", "        return false;", "      }", "", "      if (block.number > primedBlock + primedWindow) {", "        primedBlock = block.number;", "        malt.mint(msg.sender, defaultIncentive * (10**malt.decimals()));", "        emit MintMalt(defaultIncentive * (10**malt.decimals()));", "        return false;", "      }", "", "      if (primedBlock == block.number) {", "        return false;", "      }", "    }", "", "    return true;", "  }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function addExtraReward(address _reward) external {", "        require(msg.sender == rewardManager, \"!authorized\");", "        require(_reward != address(0), \"!reward setting\");", "", "        extraRewards.push(_reward);", "    }"], "ner_tags": [0, 0, 0, 0, 1, 0]}
{"tokens": ["    constructor(", "        Kernel kernel_,", "        IBondAuctioneer auctioneer_,", "        IBondCallback callback_,", "        ERC20[2] memory tokens_, // [ohm, reserve]", "        uint32[8] memory configParams // [cushionFactor, cushionDuration, cushionDebtBuffer, cushionDepositInterval, reserveFactor, regenWait, regenThreshold, regenObserve]", "    ) Policy(kernel_) {", "        /// Check params are valid", "        if (address(auctioneer_) == address(0) || address(callback_) == address(0))", "            revert Operator_InvalidParams();", "", "        if (configParams[1] > uint256(7 days) || configParams[1] < uint256(1 days))", "            revert Operator_InvalidParams();", "", "        if (configParams[2] < uint32(10_000)) revert Operator_InvalidParams();", "", "        if (configParams[3] < uint32(1 hours) || configParams[3] > configParams[1])", "            revert Operator_InvalidParams();", "", "        if (configParams[4] > 10000 || configParams[4] < 100) revert Operator_InvalidParams();", "", "        if (", "            configParams[5] < 1 hours ||", "            configParams[6] > configParams[7] ||", "            configParams[7] == uint32(0)", "        ) revert Operator_InvalidParams();", "", "        auctioneer = auctioneer_;", "        callback = callback_;", "        ohm = tokens_[0];", "        ohmDecimals = tokens_[0].decimals();", "        reserve = tokens_[1];", "        reserveDecimals = tokens_[1].decimals();", "", "        Regen memory regen = Regen({", "            count: uint32(0),", "            lastRegen: uint48(block.timestamp),", "            nextObservation: uint32(0),", "            observations: new bool[](configParams[7])", "        });", "", "        _config = Config({", "            cushionFactor: configParams[0],", "            cushionDuration: configParams[1],", "            cushionDebtBuffer: configParams[2],", "            cushionDepositInterval: configParams[3],", "            reserveFactor: configParams[4],", "            regenWait: configParams[5],", "            regenThreshold: configParams[6],", "            regenObserve: configParams[7]", "        });", "", "        _status = Status({low: regen, high: regen});", "", "        emit CushionFactorChanged(configParams[0]);", "        emit CushionParamsChanged(configParams[1], configParams[2], configParams[3]);", "        emit ReserveFactorChanged(configParams[4]);", "        emit RegenParamsChanged(configParams[5], configParams[6], configParams[7]);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function declareInsolvent() external whileBorrowing returns(bool) {", "        if(arbiter != msg.sender) { revert CallerAccessDenied(); }", "        if(LineLib.STATUS.LIQUIDATABLE != _updateStatus(_healthcheck())) {", "            revert NotLiquidatable();", "        }", "", "        if(_canDeclareInsolvent()) {", "            _updateStatus(LineLib.STATUS.INSOLVENT);", "            return true;", "        } else {", "          return false;", "        }", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _calculateUnrealizedDebt(address owner) internal view returns (int256) {", "        int256 debt = _accounts[owner].debt;", "", "        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;", "        for (uint256 i = 0; i < depositedTokens.values.length; i++) {", "            address yieldToken = depositedTokens.values[i];", "", "            uint256 currentAccruedWeight = _yieldTokens[yieldToken].accruedWeight;", "            uint256 lastAccruedWeight    = _accounts[owner].lastAccruedWeights[yieldToken];", "            uint256 unlockedCredit       = _calculateUnlockedCredit(yieldToken);", "", "            currentAccruedWeight += unlockedCredit > 0", "                ? unlockedCredit * FIXED_POINT_SCALAR / _yieldTokens[yieldToken].totalShares", "                : 0;", "", "            if (currentAccruedWeight == lastAccruedWeight) {", "                continue;", "            }", "", "            uint256 balance = _accounts[owner].balances[yieldToken];", "            uint256 unrealizedCredit = ((currentAccruedWeight - lastAccruedWeight) * balance) / FIXED_POINT_SCALAR;", "", "            debt -= SafeCast.toInt256(unrealizedCredit);", "        }", "", "        return debt;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _claimAsStaker(address _recipient, bytes[] calldata _blsPubKeys) internal {", "        if (_blsPubKeys.length == 0) revert EmptyArray();", "        if (_recipient == address(0)) revert ZeroAddress();", "        if (_recipient == address(this)) revert ZeroAddress();", "", "        // Make sure we have the latest accrued information", "        updateAccruedETHPerShares();", "", "        for (uint256 i; i < _blsPubKeys.length; ++i) {", "            bytes memory _blsPubKey = _blsPubKeys[i];", "            if (!isKnotRegistered[_blsPubKey]) revert KnotIsNotRegisteredWithSyndicate();", "", "            uint256 unclaimedUserShare = calculateUnclaimedFreeFloatingETHShare(_blsPubKey, msg.sender);", "", "            // this means that user can call the funtion even if there is nothing to claim but the", "            // worst that will happen is that they will just waste gas. this is needed for unstaking", "            if (unclaimedUserShare > 0) {", "                // Increase total claimed at the contract level", "                totalClaimed += unclaimedUserShare;", "", "                // Work out which accumulated ETH per free floating share value was used", "                uint256 accumulatedETHPerShare = _getCorrectAccumulatedETHPerFreeFloatingShareForBLSPublicKey(_blsPubKey);", "", "                // Update the total ETH claimed by the free floating SLOT holder based on their share of sETH", "                sETHUserClaimForKnot[_blsPubKey][msg.sender] =", "                (accumulatedETHPerShare * sETHStakedBalanceForKnot[_blsPubKey][msg.sender]) / PRECISION;", "", "                // Send ETH to user", "                (bool success,) = _recipient.call{value: unclaimedUserShare}(\"\");", "                if (!success) revert TransferFailed();", "", "                emit ETHClaimed(", "                    _blsPubKey,", "                    msg.sender,", "                    _recipient,", "                    unclaimedUserShare,", "                    false", "                );", "            }", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function _feeAmount(", "    uint256 _amount,", "    uint256 _fee,", "    uint256 _feeDiscount", "  ) internal pure returns (uint256) {", "    // Calculate the discounted fee.", "    uint256 _discountedFee = _fee -", "      PRBMath.mulDiv(_fee, _feeDiscount, JBConstants.MAX_FEE_DISCOUNT);", "", "    // The amount of tokens from the `_amount` to pay as a fee.", "    return", "      _amount - PRBMath.mulDiv(_amount, JBConstants.MAX_FEE, _discountedFee + JBConstants.MAX_FEE);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": ["    function returnToLender(uint256 _communityID, address _project)", "        public", "        view", "        override", "        returns (", "            uint256, // principal + interest", "            uint256, // principal", "            uint256, // total interest", "            uint256 // unclaimedInterest", "        )", "    {", "        // Local instance of variables. For saving gas.", "        ProjectDetails storage _communityProject = _communities[_communityID]", "            .projectDetails[_project];", "        uint256 _lentAmount = _communityProject.lentAmount;", "", "        // Calculate number of days difference current and last timestamp", "        uint256 _noOfDays = (block.timestamp -", "            _communityProject.lastTimestamp) / 86400; // 24*60*60", "", "        /// Interest formula = (principal * APR * days) / (365 * 1000)", "        // prettier-ignore", "        uint256 _unclaimedInterest = ", "                _lentAmount *", "                _communities[_communityID].projectDetails[_project].apr *", "                _noOfDays /", "                365000;", "", "        // Old (already rTokens claimed) + new interest", "        uint256 _totalInterest = _unclaimedInterest +", "            _communityProject.interest;", "", "        return (", "            _lentAmount + _totalInterest,", "            _lentAmount,", "            _totalInterest,", "            _unclaimedInterest", "        );", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function setName(string calldata name_) external governance {", "        name = name_;", "    }"], "ner_tags": [1, 0, 0]}
{"tokens": ["    function mint(address _recipient, uint256 _mintAmount) external onlyMintVault MintPaused returns (uint256 newTotalShares) {", "        require(_recipient != address(0), \"MINT_TO_THE_ZERO_ADDRESS\");", "", "        uint256 sharesAmount = getSharesByMintedEUSD(_mintAmount);", "        if (sharesAmount == 0) {", "            //EUSD totalSupply is 0: assume that shares correspond to EUSD 1-to-1", "            sharesAmount = _mintAmount;", "        }", "", "        newTotalShares = _totalShares.add(sharesAmount);", "        _totalShares = newTotalShares;", "", "        shares[_recipient] = shares[_recipient].add(sharesAmount);", "", "        _totalSupply += _mintAmount;", "", "        emit Transfer(address(0), _recipient, _mintAmount);", "    }"], "ner_tags": [0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function updateRewardsMetadata(Common.Distribution[] calldata distributions)", "        external", "        onlyRole(DEFAULT_ADMIN_ROLE)", "    {", "        require(distributions.length > 0, \"Invalid distributions\");", "        IRewardDistributor(distributor).updateRewardsMetadata(distributions);", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function registerBLSPublicKeys(", "        bytes[] calldata _blsPublicKeys,", "        bytes[] calldata _blsSignatures,", "        address _eoaRepresentative", "    ) external payable nonReentrant {", "        uint256 len = _blsPublicKeys.length;", "        require(len >= 1, \"No value provided\");", "        require(len == _blsSignatures.length, \"Unequal number of array values\");", "        require(msg.value == len * 4 ether, \"Insufficient ether provided\");", "        require(!Address.isContract(_eoaRepresentative), \"Only EOA representative permitted\");", "        require(_isNodeRunnerValid(msg.sender) == true, \"Unrecognised node runner\");", "        require(isNodeRunnerBanned(msg.sender) == false, \"Node runner is banned from LSD network\");", "", "        address smartWallet = smartWalletOfNodeRunner[msg.sender];", "", "        if(smartWallet == address(0)) {", "            // create new wallet owned by liquid staking manager", "            smartWallet = smartWalletFactory.createWallet(address(this));", "            emit SmartWalletCreated(smartWallet, msg.sender);", "", "            // associate node runner with the newly created wallet", "            smartWalletOfNodeRunner[msg.sender] = smartWallet;", "            nodeRunnerOfSmartWallet[smartWallet] = msg.sender;", "", "            _authorizeRepresentative(smartWallet, _eoaRepresentative, true);", "        }", "", "        // Ensure that the node runner does not whitelist multiple EOA representatives - they can only have 1 active at a time", "        if(smartWalletRepresentative[smartWallet] != address(0)) {", "            require(smartWalletRepresentative[smartWallet] == _eoaRepresentative, \"Different EOA specified - rotate outside\");", "        }", "", "        {", "            // transfer ETH to smart wallet", "            (bool result,) = smartWallet.call{value: msg.value}(\"\");", "            require(result, \"Transfer failed\");", "            emit WalletCredited(smartWallet, msg.value);", "        }", "", "        for(uint256 i; i < len; ++i) {", "            bytes calldata _blsPublicKey = _blsPublicKeys[i];", "", "            // check if the BLS public key is part of LSD network and is not banned", "            require(isBLSPublicKeyPartOfLSDNetwork(_blsPublicKey) == false, \"BLS public key is banned or not a part of LSD network\");", "", "            require(", "                getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKey) == IDataStructures.LifecycleStatus.UNBEGUN,", "                \"Lifecycle status must be zero\"", "            );", "", "            // register validtor initals for each of the KNOTs", "            IOwnableSmartWallet(smartWallet).execute(", "                address(getTransactionRouter()),", "                abi.encodeWithSelector(", "                    ITransactionRouter.registerValidatorInitials.selector,", "                    smartWallet,", "                    _blsPublicKey,", "                    _blsSignatures[i]", "                )", "            );", "", "            // register the smart wallet with the BLS public key", "            smartWalletOfKnot[_blsPublicKey] = smartWallet;", "", "            emit NewLSDValidatorRegistered(msg.sender, _blsPublicKey);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _execute(bytes memory data, bytes[] memory signatures) internal {", "        uint256 signatureCount = signatures.length;", "", "        address[] memory signers = new address[](signatureCount);", "", "        for (uint256 i; i < signatureCount; i++) {", "            signers[i] = ECDSA.recover(ECDSA.toEthSignedMessageHash(keccak256(data)), signatures[i]);", "        }", "", "        (", "            uint256 chainId,", "            Role signersRole,", "            bytes32[] memory commandIds,", "            string[] memory commands,", "            bytes[] memory params", "        ) = abi.decode(data, (uint256, Role, bytes32[], string[], bytes[]));", "", "        if (chainId != block.chainid) revert InvalidChainId();", "", "        if (!_isSortedAscAndContainsNoDuplicate(signers)) revert MalformedSigners();", "", "        uint256 commandsLength = commandIds.length;", "", "        if (commandsLength != commands.length || commandsLength != params.length) revert InvalidCommands();", "", "        bool areValidCurrentOwners;", "        bool areValidRecentOwners;", "        bool areValidRecentOperators;", "", "        if (signersRole == Role.Owner) {", "            areValidCurrentOwners = _areValidOwnersInEpoch(_ownerEpoch(), signers);", "            areValidRecentOwners = areValidCurrentOwners || _areValidPreviousOwners(signers);", "        } else if (signersRole == Role.Operator) {", "            areValidRecentOperators = _areValidRecentOperators(signers);", "        }", "", "        for (uint256 i; i < commandsLength; i++) {", "            bytes32 commandId = commandIds[i];", "", "            if (isCommandExecuted(commandId)) continue; /* Ignore if duplicate commandId received */", "", "            bytes4 commandSelector;", "            bytes32 commandHash = keccak256(abi.encodePacked(commands[i]));", "", "            if (commandHash == SELECTOR_DEPLOY_TOKEN) {", "                if (!areValidRecentOwners) continue;", "", "                commandSelector = AxelarGatewayMultisig.deployToken.selector;", "            } else if (commandHash == SELECTOR_MINT_TOKEN) {", "                if (!areValidRecentOperators && !areValidRecentOwners) continue;", "", "                commandSelector = AxelarGatewayMultisig.mintToken.selector;", "            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL) {", "                if (!areValidRecentOperators && !areValidRecentOwners) continue;", "", "                commandSelector = AxelarGatewayMultisig.approveContractCall.selector;", "            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT) {", "                if (!areValidRecentOperators && !areValidRecentOwners) continue;", "", "                commandSelector = AxelarGatewayMultisig.approveContractCallWithMint.selector;", "            } else if (commandHash == SELECTOR_BURN_TOKEN) {", "                if (!areValidRecentOperators && !areValidRecentOwners) continue;", "", "                commandSelector = AxelarGatewayMultisig.burnToken.selector;", "            } else if (commandHash == SELECTOR_TRANSFER_OWNERSHIP) {", "                if (!areValidCurrentOwners) continue;", "", "                commandSelector = AxelarGatewayMultisig.transferOwnership.selector;", "            } else if (commandHash == SELECTOR_TRANSFER_OPERATORSHIP) {", "                if (!areValidCurrentOwners) continue;", "", "                commandSelector = AxelarGatewayMultisig.transferOperatorship.selector;", "            } else {", "                continue; /* Ignore if unknown command received */", "            }", "", "            // Prevent a re-entrancy from executing this command before it can be marked as successful.", "            _setCommandExecuted(commandId, true);", "            (bool success, ) = address(this).call(abi.encodeWithSelector(commandSelector, params[i], commandId));", "            _setCommandExecuted(commandId, success);", "", "            if (success) {", "                emit Executed(commandId);", "            }", "        }", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function commitToLiens(IAstariaRouter.Commitment[] memory commitments)", "    public", "    whenNotPaused", "    returns (uint256[] memory lienIds, ILienToken.Stack[] memory stack)", "  {", "    RouterStorage storage s = _loadRouterSlot();", "", "    uint256 totalBorrowed;", "    lienIds = new uint256[](commitments.length);", "    _transferAndDepositAssetIfAble(", "      s,", "      commitments[0].tokenContract,", "      commitments[0].tokenId", "    );", "", "    uint256 i;", "    for (; i < commitments.length; ) {", "      if (i != 0) {", "        commitments[i].lienRequest.stack = stack;", "      }", "      uint256 payout;", "      (lienIds[i], stack, payout) = _executeCommitment(s, commitments[i]);", "      totalBorrowed += payout;", "      unchecked {", "        ++i;", "      }", "    }", "", "    ERC20(IAstariaVaultBase(commitments[0].lienRequest.strategy.vault).asset())", "      .safeTransfer(msg.sender, totalBorrowed);", "  }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _mint(address beneficiary, uint256 amount) internal returns (bool) {", "        totalAvailableToNow += ((block.timestamp - lastEvent) * currentTotalInflation);", "        uint256 newTotalMintedToNow = totalMintedToNow + amount;", "        require(newTotalMintedToNow <= totalAvailableToNow, \"Mintable amount exceeded\");", "        totalMintedToNow = newTotalMintedToNow;", "        lastEvent = block.timestamp;", "        token.mint(beneficiary, amount);", "        _executeInflationRateUpdate();", "        emit TokensMinted(beneficiary, amount);", "        return true;", "    }"], "ner_tags": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function vcon() public view override returns (IERC20) {", "        return _vcon;", "    }"], "ner_tags": [1, 0, 0]}
{"tokens": ["    constructor() {}"], "ner_tags": [1]}
{"tokens": ["  function underlying(uint8 p, address c) internal view returns (address) {", "    if (p == uint8(Protocols.Compound)) {", "      return ICompoundToken(c).underlying();", "    } else if (p == uint8(Protocols.Rari)) {", "      return ICompoundToken(c).underlying();", "    } else if (p == uint8(Protocols.Yearn)) {", "      return IYearnVault(c).underlying();", "    } else if (p == uint8(Protocols.Aave)) {", "      return IAaveToken(c).UNDERLYING_ASSET_ADDRESS();", "    } else if (p == uint8(Protocols.Euler)) {", "      return IEulerToken(c).underlyingAsset();", "    } else {", "      return IErc4626(c).asset();      ", "    }", "  }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["\tfunction isEligible(address stakerAddr) external view returns (bool) {", "\t\tStaking staking = Staking(getContractAddress(\"Staking\"));", "\t\tuint256 rewardsStartTime = staking.getRewardsStartTime(stakerAddr);", "\t\tuint256 elapsedSecs = (block.timestamp - rewardsStartTime);", "\t\tProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));", "\t\treturn (rewardsStartTime != 0 && elapsedSecs >= dao.getRewardsEligibilityMinSeconds());", "\t}"], "ner_tags": [0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["    function addNativeGas(", "        bytes32 txHash,", "        uint256 logIndex,", "        address refundAddress", "    ) external payable override {", "        if (msg.value == 0) revert NothingReceived();", "", "        emit NativeGasAdded(txHash, logIndex, msg.value, refundAddress);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function depositBribeERC20(", "        bytes32 bribeIdentifier,", "        bytes32 rewardIdentifier,", "        address token,", "        uint256 amount,", "        address briber", "    ) external onlyRole(DEPOSITOR_ROLE) {", "        require(bribeIdentifier.length > 0, \"Invalid bribeIdentifier\");", "        require(rewardIdentifier.length > 0, \"Invalid rewardIdentifier\");", "        require(token != address(0), \"Invalid token\");", "        require(amount > 0, \"Amount must be greater than 0\");", "        require(briber != address(0), \"Invalid briber\");", "", "        Bribe storage b = bribes[bribeIdentifier];", "        address currentToken = b.token;", "        require(", "            // If bribers want to bribe with a different token they need a new identifier", "            currentToken == address(0) || currentToken == token,", "            \"Cannot change token\"", "        );", "", "        // Since this method is called by a depositor contract, we must transfer from the account", "        // that called the depositor contract - amount must be approved beforehand", "        IERC20(token).safeTransferFrom(briber, address(this), amount);", "", "        b.amount += amount; // Allow bribers to increase bribe", "", "        // Only set the token address and update the reward-to-bribe mapping if not yet set", "        if (currentToken == address(0)) {", "            b.token = token;", "            rewardToBribes[rewardIdentifier].push(bribeIdentifier);", "        }", "", "        emit DepositBribe(", "            bribeIdentifier,", "            rewardIdentifier,", "            token,", "            amount,", "            b.amount,", "            briber", "        );", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function change(", "        uint256[] memory inputTokenIds,", "        uint256[] memory inputTokenWeights,", "        MerkleMultiProof memory inputProof,", "        IStolenNftOracle.Message[] memory stolenNftProofs,", "        uint256[] memory outputTokenIds,", "        uint256[] memory outputTokenWeights,", "        MerkleMultiProof memory outputProof", "    ) public payable returns (uint256 feeAmount, uint256 protocolFeeAmount) {", "        // ~~~ Checks ~~~ //", "", "        // check that the caller sent 0 ETH if base token is not ETH", "        if (baseToken != address(0) && msg.value > 0) revert InvalidEthAmount();", "", "        // check that NFTs are not stolen", "        if (useStolenNftOracle) {", "            IStolenNftOracle(stolenNftOracle).validateTokensAreNotStolen(nft, inputTokenIds, stolenNftProofs);", "        }", "", "        // fix stack too deep", "        {", "            // calculate the sum of weights for the input nfts", "            uint256 inputWeightSum = sumWeightsAndValidateProof(inputTokenIds, inputTokenWeights, inputProof);", "", "            // calculate the sum of weights for the output nfts", "            uint256 outputWeightSum = sumWeightsAndValidateProof(outputTokenIds, outputTokenWeights, outputProof);", "", "            // check that the input weights are greater than or equal to the output weights", "            if (inputWeightSum < outputWeightSum) revert InsufficientInputWeight();", "", "            // calculate the fee amount", "            (feeAmount, protocolFeeAmount) = changeFeeQuote(inputWeightSum);", "        }", "", "        // ~~~ Interactions ~~~ //", "", "        if (baseToken != address(0)) {", "            // transfer the fee amount of base tokens from the caller", "            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), feeAmount);", "", "            // if the protocol fee is non-zero then transfer the protocol fee to the factory", "            if (protocolFeeAmount > 0) ERC20(baseToken).safeTransferFrom(msg.sender, factory, protocolFeeAmount);", "        } else {", "            // check that the caller sent enough ETH to cover the fee amount and protocol fee", "            if (msg.value < feeAmount + protocolFeeAmount) revert InvalidEthAmount();", "", "            // if the protocol fee is non-zero then transfer the protocol fee to the factory", "            if (protocolFeeAmount > 0) factory.safeTransferETH(protocolFeeAmount);", "", "            // refund any excess ETH to the caller", "            if (msg.value > feeAmount + protocolFeeAmount) {", "                msg.sender.safeTransferETH(msg.value - feeAmount - protocolFeeAmount);", "            }", "        }", "", "        // transfer the input nfts from the caller", "        for (uint256 i = 0; i < inputTokenIds.length; i++) {", "            ERC721(nft).safeTransferFrom(msg.sender, address(this), inputTokenIds[i]);", "        }", "", "        // transfer the output nfts to the caller", "        for (uint256 i = 0; i < outputTokenIds.length; i++) {", "            ERC721(nft).safeTransferFrom(address(this), msg.sender, outputTokenIds[i]);", "        }", "", "        // emit the change event", "        emit Change(inputTokenIds, inputTokenWeights, outputTokenIds, outputTokenWeights, feeAmount, protocolFeeAmount);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _transferERC20sIn(ERC20Asset[] memory assets, address from) internal {", "        for (uint256 i = 0; i < assets.length; i++) {", "            address token = assets[i].token;", "            uint256 tokenAmount = assets[i].tokenAmount;", "", "            require(token.code.length > 0, \"ERC20: Token is not contract\");", "            require(tokenAmount > 0, \"ERC20: Amount too small\");", "", "            ERC20(token).safeTransferFrom(from, address(this), tokenAmount);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["  function divuu(uint256 x, uint256 y) private pure returns (uint128) {", "    require(y != 0);", "", "    uint256 result;", "", "    if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) result = (x << 64) / y;", "    else {", "      uint256 msb = 192;", "      uint256 xc = x >> 192;", "      if (xc >= 0x100000000) {", "        xc >>= 32;", "        msb += 32;", "      }", "      if (xc >= 0x10000) {", "        xc >>= 16;", "        msb += 16;", "      }", "      if (xc >= 0x100) {", "        xc >>= 8;", "        msb += 8;", "      }", "      if (xc >= 0x10) {", "        xc >>= 4;", "        msb += 4;", "      }", "      if (xc >= 0x4) {", "        xc >>= 2;", "        msb += 2;", "      }", "      if (xc >= 0x2) msb += 1; // No need to shift xc anymore", "", "      result = (x << (255 - msb)) / (((y - 1) >> (msb - 191)) + 1);", "      require(result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);", "", "      uint256 hi = result * (y >> 128);", "      uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);", "", "      uint256 xh = x >> 192;", "      uint256 xl = x << 64;", "", "      if (xl < lo) xh -= 1;", "      xl -= lo; // We rely on overflow behavior here", "      lo = hi << 128;", "      if (xl < lo) xh -= 1;", "      xl -= lo; // We rely on overflow behavior here", "", "      assert(xh == hi >> 128);", "", "      result += xl / y;", "    }", "", "    require(result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);", "    return uint128(result);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function moveLiquidity(", "        MoveLiquidityParams calldata params_", "    ) external override mayInteract(params_.pool, params_.tokenId) nonReentrant {", "        Position storage fromPosition = positions[params_.tokenId][params_.fromIndex];", "", "        MoveLiquidityLocalVars memory vars;", "        vars.depositTime = fromPosition.depositTime;", "", "        // handle the case where owner attempts to move liquidity after they've already done so", "        if (vars.depositTime == 0) revert RemovePositionFailed();", "", "        // ensure bucketDeposit accounts for accrued interest", "        IPool(params_.pool).updateInterest();", "", "        // retrieve info of bucket from which liquidity is moved  ", "        (", "            vars.bucketLP,", "            vars.bucketCollateral,", "            vars.bankruptcyTime,", "            vars.bucketDeposit,", "        ) = IPool(params_.pool).bucketInfo(params_.fromIndex);", "", "        // check that bucket hasn't gone bankrupt since memorialization", "        if (vars.depositTime <= vars.bankruptcyTime) revert BucketBankrupt();", "", "        // calculate the max amount of quote tokens that can be moved, given the tracked LP", "        vars.maxQuote = _lpToQuoteToken(", "            vars.bucketLP,", "            vars.bucketCollateral,", "            vars.bucketDeposit,", "            fromPosition.lps,", "            vars.bucketDeposit,", "            _priceAt(params_.fromIndex)", "        );", "", "        EnumerableSet.UintSet storage positionIndex = positionIndexes[params_.tokenId];", "", "        // remove bucket index from which liquidity is moved from tracked positions", "        if (!positionIndex.remove(params_.fromIndex)) revert RemovePositionFailed();", "", "        // update bucket set at which a position has liquidity", "        // slither-disable-next-line unused-return", "        positionIndex.add(params_.toIndex);", "", "        // move quote tokens in pool", "        (", "            vars.lpbAmountFrom,", "            vars.lpbAmountTo,", "        ) = IPool(params_.pool).moveQuoteToken(", "            vars.maxQuote,", "            params_.fromIndex,", "            params_.toIndex,", "            params_.expiry", "        );", "", "        Position storage toPosition = positions[params_.tokenId][params_.toIndex];", "", "        // update position LP state", "        fromPosition.lps -= vars.lpbAmountFrom;", "        toPosition.lps   += vars.lpbAmountTo;", "        // update position deposit time to the from bucket deposit time", "        toPosition.depositTime = vars.depositTime;", "", "        emit MoveLiquidity(", "            ownerOf(params_.tokenId),", "            params_.tokenId,", "            params_.fromIndex,", "            params_.toIndex,", "            vars.lpbAmountFrom,", "            vars.lpbAmountTo", "        );", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function rejectActive(", "        address _vault,", "        uint256 _amount,", "        bytes32[] calldata _delistProof", "    ) external payable {", "        // Reverts if vault is not registered", "        (address token, uint256 id) = _verifyVault(_vault);", "        // Reverts if vault is not current owner of the assets", "        if (_verifySale(_vault)) revert NotOwner();", "        // Reverts if collateral is less than amount of rejected tokens", "        Listing storage activeListing = activeListings[_vault];", "        if (activeListing.collateral < _amount) revert InsufficientCollateral();", "        // Reverts if payment amount is incorrect", "        if (activeListing.pricePerToken * _amount != msg.value) revert InvalidPayment();", "", "        // Store proposer in memory", "        address proposer = activeListing.proposer;", "", "        // Decrements collateral amount", "        activeListing.collateral -= _amount;", "", "        // Checks if active listing has been rejected", "        if (activeListing.collateral == 0) {", "            // Cancels the Seaport Order", "            _delist(_vault, _delistProof);", "            // Resets active listing to default", "            delete activeListings[_vault];", "            _setListing(activeListing, address(this), 0, type(uint256).max, 0);", "            // Emits event for delisting assets", "            emit Delist(_vault, activeListing.order);", "        }", "", "        // Transfers tokens to caller", "        IERC1155(token).safeTransferFrom(address(this), msg.sender, id, _amount, \"\");", "        // Sends ether to proposer", "        _sendEthOrWeth(proposer, msg.value);", "", "        // Emits event for rejecting an active listing", "        emit RejectActive(_vault, msg.sender, _amount, msg.value, activeListing.order);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["    function _beforeTokenTransfer(", "        address from,", "        address to,", "        uint256 amount", "    ) internal virtual override {", "        if(from != address(0)) { //check must be skipped on minting", "            // Only allow the balance that is unlocked to be transfered", "            require(amount <= _availableBalanceOf(from), \"hPAL: Available balance too low\");", "        }", "", "        // Update user rewards before any change on their balance (staked and locked)", "        _updateUserRewards(from);", "", "        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0 ", "", "        if(from != to) {", "            // Update user rewards before any change on their balance (staked and locked)", "            _updateUserRewards(to);", "            // => we don't want a self-transfer to double count new claimable rewards", "            // + no need to update the cooldown on a self-transfer", "", "            uint256 previousToBalance = balanceOf(to);", "            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);", "        }", "", "        // If from transfer all of its balance, reset the cooldown to 0", "        uint256 previousFromBalance = balanceOf(from);", "        if(previousFromBalance == amount && fromCooldown != 0) {", "            cooldowns[from] = 0;", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": ["    function stake(", "        bytes[] calldata _blsPublicKeyOfKnots,", "        bytes[] calldata _ciphertexts,", "        bytes[] calldata _aesEncryptorKeys,", "        IDataStructures.EIP712Signature[] calldata _encryptionSignatures,", "        bytes32[] calldata _dataRoots", "    ) external {", "        uint256 numOfValidators = _blsPublicKeyOfKnots.length;", "        require(numOfValidators > 0, \"No data\");", "        require(numOfValidators == _ciphertexts.length, \"Inconsistent array lengths\");", "        require(numOfValidators == _aesEncryptorKeys.length, \"Inconsistent array lengths\");", "        require(numOfValidators == _encryptionSignatures.length, \"Inconsistent array lengths\");", "        require(numOfValidators == _dataRoots.length, \"Inconsistent array lengths\");", "", "        for (uint256 i; i < numOfValidators; ++i) {", "            bytes calldata blsPubKey = _blsPublicKeyOfKnots[i];", "            // check if BLS public key is registered with liquid staking derivative network and not banned", "            require(isBLSPublicKeyBanned(blsPubKey) == false, \"BLS public key is banned or not a part of LSD network\");", "", "            address associatedSmartWallet = smartWalletOfKnot[blsPubKey];", "            require(associatedSmartWallet != address(0), \"Unknown BLS public key\");", "            require(", "                getAccountManager().blsPublicKeyToLifecycleStatus(blsPubKey) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,", "                \"Initials not registered\"", "            );", "", "            // check minimum balance of smart wallet, dao staking fund vault and savETH vault", "            _assertEtherIsReadyForValidatorStaking(blsPubKey);", "", "            _stake(", "                _blsPublicKeyOfKnots[i],", "                _ciphertexts[i],", "                _aesEncryptorKeys[i],", "                _encryptionSignatures[i],", "                _dataRoots[i]", "            );", "", "            address representative = smartWalletRepresentative[associatedSmartWallet];", "", "            if(representative != address(0)) {", "                // unauthorize the EOA representative on the Stakehouse", "                _authorizeRepresentative(associatedSmartWallet, representative, false);", "                // make the representative dormant before unauthorizing it", "                smartWalletDormantRepresentative[associatedSmartWallet] = representative;", "                emit DormantRepresentative(associatedSmartWallet, representative);", "            }", "        }", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function tokenURI(uint256 id) public view override returns (string memory) {", "        return PrivatePoolMetadata(privatePoolMetadata).tokenURI(id);", "    }"], "ner_tags": [1, 0, 0]}
{"tokens": ["    function _prepareBasicFulfillmentFromCalldata(", "        BasicOrderParameters calldata parameters,", "        OrderType orderType,", "        ItemType receivedItemType,", "        ItemType additionalRecipientsItemType,", "        address additionalRecipientsToken,", "        ItemType offeredItemType", "    ) internal {", "        // Ensure this function cannot be triggered during a reentrant call.", "        _setReentrancyGuard();", "", "        // Ensure current timestamp falls between order start time and end time.", "        _verifyTime(parameters.startTime, parameters.endTime, true);", "", "        // Verify that calldata offsets for all dynamic types were produced by", "        // default encoding. This ensures that the constants we use for calldata", "        // pointers to dynamic types are the same as those calculated by", "        // Solidity using their offsets.", "        _assertValidBasicOrderParameterOffsets();", "", "        // Ensure supplied consideration array length is not less than original.", "        _assertConsiderationLengthIsNotLessThanOriginalConsiderationLength(", "            parameters.additionalRecipients.length + 1,", "            parameters.totalOriginalAdditionalRecipients", "        );", "", "        // Declare stack element for the order hash.", "        bytes32 orderHash;", "", "        {", "            /**", "             * First, handle consideration items. Memory Layout:", "             *  0x60: final hash of the array of consideration item hashes", "             *  0x80-0x160: reused space for EIP712 hashing of each item", "             *   - 0x80: ConsiderationItem EIP-712 typehash (constant)", "             *   - 0xa0: itemType", "             *   - 0xc0: token", "             *   - 0xe0: identifier", "             *   - 0x100: startAmount", "             *   - 0x120: endAmount", "             *   - 0x140: recipient", "             *  0x160-END_ARR: array of consideration item hashes", "             *   - 0x160: primary consideration item EIP712 hash", "             *   - 0x180-END_ARR: additional recipient item EIP712 hashes", "             *  END_ARR: beginning of data for OrderFulfilled event", "             *   - END_ARR + 0x120: length of ReceivedItem array", "             *   - END_ARR + 0x140: beginning of data for first ReceivedItem", "             * (Note: END_ARR = 0x180 + RECIPIENTS_LENGTH * 0x20)", "             */", "", "            // Load consideration item typehash from runtime and place on stack.", "            bytes32 typeHash = _CONSIDERATION_ITEM_TYPEHASH;", "", "            // Utilize assembly to enable reuse of memory regions and use", "            // constant pointers when possible.", "            assembly {", "                /*", "                 * 1. Calculate the EIP712 ConsiderationItem hash for the", "                 * primary consideration item of the basic order.", "                 */", "", "                // Write ConsiderationItem type hash and item type to memory.", "                mstore(BasicOrder_considerationItem_typeHash_ptr, typeHash)", "                mstore(", "                    BasicOrder_considerationItem_itemType_ptr,", "                    receivedItemType", "                )", "", "                // Copy calldata region with (token, identifier, amount) from", "                // BasicOrderParameters to ConsiderationItem. The", "                // considerationAmount is written to startAmount and endAmount", "                // as basic orders do not have dynamic amounts.", "                calldatacopy(", "                    BasicOrder_considerationItem_token_ptr,", "                    BasicOrder_considerationToken_cdPtr,", "                    ThreeWords", "                )", "", "                // Copy calldata region with considerationAmount and offerer", "                // from BasicOrderParameters to endAmount and recipient in", "                // ConsiderationItem.", "                calldatacopy(", "                    BasicOrder_considerationItem_endAmount_ptr,", "                    BasicOrder_considerationAmount_cdPtr,", "                    TwoWords", "                )", "", "                // Calculate EIP712 ConsiderationItem hash and store it in the", "                // array of EIP712 consideration hashes.", "                mstore(", "                    BasicOrder_considerationHashesArray_ptr,", "                    keccak256(", "                        BasicOrder_considerationItem_typeHash_ptr,", "                        EIP712_ConsiderationItem_size", "                    )", "                )", "", "                /*", "                 * 2. Write a ReceivedItem struct for the primary consideration", "                 * item to the consideration array in OrderFulfilled.", "                 */", "", "                // Get the length of the additional recipients array.", "                let totalAdditionalRecipients := calldataload(", "                    BasicOrder_additionalRecipients_length_cdPtr", "                )", "", "                // Calculate pointer to length of OrderFulfilled consideration", "                // array.", "                let eventConsiderationArrPtr := add(", "                    OrderFulfilled_consideration_length_baseOffset,", "                    mul(totalAdditionalRecipients, OneWord)", "                )", "", "                // Set the length of the consideration array to the number of", "                // additional recipients, plus one for the primary consideration", "                // item.", "                mstore(", "                    eventConsiderationArrPtr,", "                    add(", "                        calldataload(", "                            BasicOrder_additionalRecipients_length_cdPtr", "                        ),", "                        1", "                    )", "                )", "", "                // Overwrite the consideration array pointer so it points to the", "                // body of the first element", "                eventConsiderationArrPtr := add(", "                    eventConsiderationArrPtr,", "                    OneWord", "                )", "", "                // Set itemType at start of the ReceivedItem memory region.", "                mstore(eventConsiderationArrPtr, receivedItemType)", "", "                // Copy calldata region (token, identifier, amount & recipient)", "                // from BasicOrderParameters to ReceivedItem memory.", "                calldatacopy(", "                    add(eventConsiderationArrPtr, Common_token_offset),", "                    BasicOrder_considerationToken_cdPtr,", "                    FourWords", "                )", "", "                /*", "                 * 3. Calculate EIP712 ConsiderationItem hashes for original", "                 * additional recipients and add a ReceivedItem for each to the", "                 * consideration array in the OrderFulfilled event. The original", "                 * additional recipients are all the considerations signed by", "                 * the offerer aside from the primary consideration of the", "                 * order. Uses memory region from 0x80-0x160 as a buffer for", "                 * calculating EIP712 ConsiderationItem hashes.", "                 */", "", "                // Put pointer to consideration hashes array on the stack.", "                // This will be updated as each additional recipient is hashed", "                let", "                    considerationHashesPtr", "                := BasicOrder_considerationHashesArray_ptr", "", "                // Write item type, token, & identifier for additional recipient", "                // to memory region for hashing EIP712 ConsiderationItem; these", "                // values will be reused for each recipient.", "                mstore(", "                    BasicOrder_considerationItem_itemType_ptr,", "                    additionalRecipientsItemType", "                )", "                mstore(", "                    BasicOrder_considerationItem_token_ptr,", "                    additionalRecipientsToken", "                )", "                mstore(BasicOrder_considerationItem_identifier_ptr, 0)", "", "                // Read length of the additionalRecipients array from calldata", "                // and iterate.", "                totalAdditionalRecipients := calldataload(", "                    BasicOrder_totalOriginalAdditionalRecipients_cdPtr", "                )", "                let i := 0", "                // prettier-ignore", "                for {} lt(i, totalAdditionalRecipients) {", "                    i := add(i, 1)", "                } {", "                    /*", "                     * Calculate EIP712 ConsiderationItem hash for recipient.", "                     */", "", "                    // Retrieve calldata pointer for additional recipient.", "                    let additionalRecipientCdPtr := add(", "                        BasicOrder_additionalRecipients_data_cdPtr,", "                        mul(AdditionalRecipients_size, i)", "                    )", "", "                    // Copy startAmount from calldata to the ConsiderationItem", "                    // struct.", "                    calldatacopy(", "                        BasicOrder_considerationItem_startAmount_ptr,", "                        additionalRecipientCdPtr,", "                        OneWord", "                    )", "", "                    // Copy endAmount and recipient from calldata to the", "                    // ConsiderationItem struct.", "                    calldatacopy(", "                        BasicOrder_considerationItem_endAmount_ptr,", "                        additionalRecipientCdPtr,", "                        AdditionalRecipients_size", "                    )", "", "                    // Add 1 word to the pointer as part of each loop to reduce", "                    // operations needed to get local offset into the array.", "                    considerationHashesPtr := add(", "                        considerationHashesPtr,", "                        OneWord", "                    )", "", "                    // Calculate EIP712 ConsiderationItem hash and store it in", "                    // the array of consideration hashes.", "                    mstore(", "                        considerationHashesPtr,", "                        keccak256(", "                            BasicOrder_considerationItem_typeHash_ptr,", "                            EIP712_ConsiderationItem_size", "                        )", "                    )", "", "                    /*", "                     * Write ReceivedItem to OrderFulfilled data.", "                     */", "", "                    // At this point, eventConsiderationArrPtr points to the", "                    // beginning of the ReceivedItem struct of the previous", "                    // element in the array. Increase it by the size of the", "                    // struct to arrive at the pointer for the current element.", "                    eventConsiderationArrPtr := add(", "                        eventConsiderationArrPtr,", "                        ReceivedItem_size", "                    )", "", "                    // Write itemType to the ReceivedItem struct.", "                    mstore(", "                        eventConsiderationArrPtr,", "                        additionalRecipientsItemType", "                    )", "", "                    // Write token to the next word of the ReceivedItem struct.", "                    mstore(", "                        add(eventConsiderationArrPtr, OneWord),", "                        additionalRecipientsToken", "                    )", "", "                    // Copy endAmount & recipient words to ReceivedItem struct.", "                    calldatacopy(", "                        add(", "                            eventConsiderationArrPtr,", "                            ReceivedItem_amount_offset", "                        ),", "                        additionalRecipientCdPtr,", "                        TwoWords", "                    )", "                }", "", "                /*", "                 * 4. Hash packed array of ConsiderationItem EIP712 hashes:", "                 *   `keccak256(abi.encodePacked(receivedItemHashes))`", "                 * Note that it is set at 0x60 \u2014 all other memory begins at", "                 * 0x80. 0x60 is the \"zero slot\" and will be restored at the end", "                 * of the assembly section and before required by the compiler.", "                 */", "                mstore(", "                    receivedItemsHash_ptr,", "                    keccak256(", "                        BasicOrder_considerationHashesArray_ptr,", "                        mul(add(totalAdditionalRecipients, 1), OneWord)", "                    )", "                )", "", "                /*", "                 * 5. Add a ReceivedItem for each tip to the consideration array", "                 * in the OrderFulfilled event. The tips are all the", "                 * consideration items that were not signed by the offerer and", "                 * were provided by the fulfiller.", "                 */", "", "                // Overwrite length to length of the additionalRecipients array.", "                totalAdditionalRecipients := calldataload(", "                    BasicOrder_additionalRecipients_length_cdPtr", "                )", "                // prettier-ignore", "                for {} lt(i, totalAdditionalRecipients) {", "                    i := add(i, 1)", "                } {", "                    // Retrieve calldata pointer for additional recipient.", "                    let additionalRecipientCdPtr := add(", "                        BasicOrder_additionalRecipients_data_cdPtr,", "                        mul(AdditionalRecipients_size, i)", "                    )", "", "                    // At this point, eventConsiderationArrPtr points to the", "                    // beginning of the ReceivedItem struct of the previous", "                    // element in the array. Increase it by the size of the", "                    // struct to arrive at the pointer for the current element.", "                    eventConsiderationArrPtr := add(", "                        eventConsiderationArrPtr,", "                        ReceivedItem_size", "                    )", "", "                    // Write itemType to the ReceivedItem struct.", "                    mstore(", "                        eventConsiderationArrPtr,", "                        additionalRecipientsItemType", "                    )", "", "                    // Write token to the next word of the ReceivedItem struct.", "                    mstore(", "                        add(eventConsiderationArrPtr, OneWord),", "                        additionalRecipientsToken", "                    )", "", "                    // Copy endAmount & recipient words to ReceivedItem struct.", "                    calldatacopy(", "                        add(", "                            eventConsiderationArrPtr,", "                            ReceivedItem_amount_offset", "                        ),", "                        additionalRecipientCdPtr,", "                        TwoWords", "                    )", "                }", "            }", "        }", "", "        {", "            /**", "             * Next, handle offered items. Memory Layout:", "             *  EIP712 data for OfferItem", "             *   - 0x80:  OfferItem EIP-712 typehash (constant)", "             *   - 0xa0:  itemType", "             *   - 0xc0:  token", "             *   - 0xe0:  identifier (reused for offeredItemsHash)", "             *   - 0x100: startAmount", "             *   - 0x120: endAmount", "             */", "", "            // Place offer item typehash on the stack.", "            bytes32 typeHash = _OFFER_ITEM_TYPEHASH;", "", "            // Utilize assembly to enable reuse of memory regions when possible.", "            assembly {", "                /*", "                 * 1. Calculate OfferItem EIP712 hash", "                 */", "", "                // Write the OfferItem typeHash to memory.", "                mstore(BasicOrder_offerItem_typeHash_ptr, typeHash)", "", "                // Write the OfferItem item type to memory.", "                mstore(BasicOrder_offerItem_itemType_ptr, offeredItemType)", "", "                // Copy calldata region with (offerToken, offerIdentifier,", "                // offerAmount) from OrderParameters to (token, identifier,", "                // startAmount) in OfferItem struct. The offerAmount is written", "                // to startAmount and endAmount as basic orders do not have", "                // dynamic amounts.", "                calldatacopy(", "                    BasicOrder_offerItem_token_ptr,", "                    BasicOrder_offerToken_cdPtr,", "                    ThreeWords", "                )", "", "                // Copy offerAmount from calldata to endAmount in OfferItem", "                // struct.", "                calldatacopy(", "                    BasicOrder_offerItem_endAmount_ptr,", "                    BasicOrder_offerAmount_cdPtr,", "                    OneWord", "                )", "", "                // Compute EIP712 OfferItem hash, write result to scratch space:", "                //   `keccak256(abi.encode(offeredItem))`", "                mstore(", "                    0,", "                    keccak256(", "                        BasicOrder_offerItem_typeHash_ptr,", "                        EIP712_OfferItem_size", "                    )", "                )", "", "                /*", "                 * 2. Calculate hash of array of EIP712 hashes and write the", "                 * result to the corresponding OfferItem struct:", "                 *   `keccak256(abi.encodePacked(offerItemHashes))`", "                 */", "                mstore(BasicOrder_order_offerHashes_ptr, keccak256(0, OneWord))", "", "                /*", "                 * 3. Write SpentItem to offer array in OrderFulfilled event.", "                 */", "                let eventConsiderationArrPtr := add(", "                    OrderFulfilled_offer_length_baseOffset,", "                    mul(", "                        calldataload(", "                            BasicOrder_additionalRecipients_length_cdPtr", "                        ),", "                        OneWord", "                    )", "                )", "", "                // Set a length of 1 for the offer array.", "                mstore(eventConsiderationArrPtr, 1)", "", "                // Write itemType to the SpentItem struct.", "                mstore(add(eventConsiderationArrPtr, OneWord), offeredItemType)", "", "                // Copy calldata region with (offerToken, offerIdentifier,", "                // offerAmount) from OrderParameters to (token, identifier,", "                // amount) in SpentItem struct.", "                calldatacopy(", "                    add(eventConsiderationArrPtr, AdditionalRecipients_size),", "                    BasicOrder_offerToken_cdPtr,", "                    ThreeWords", "                )", "            }", "        }", "", "        {", "            /**", "             * Once consideration items and offer items have been handled,", "             * derive the final order hash. Memory Layout:", "             *  0x80-0x1c0: EIP712 data for order", "             *   - 0x80:   Order EIP-712 typehash (constant)", "             *   - 0xa0:   orderParameters.offerer", "             *   - 0xc0:   orderParameters.zone", "             *   - 0xe0:   keccak256(abi.encodePacked(offerHashes))", "             *   - 0x100:  keccak256(abi.encodePacked(considerationHashes))", "             *   - 0x120:  orderParameters.basicOrderType (% 4 = orderType)", "             *   - 0x140:  orderParameters.startTime", "             *   - 0x160:  orderParameters.endTime", "             *   - 0x180:  orderParameters.zoneHash", "             *   - 0x1a0:  orderParameters.salt", "             *   - 0x1c0:  orderParameters.conduitKey", "             *   - 0x1e0:  _nonces[orderParameters.offerer] (from storage)", "             */", "", "            // Read the offerer from calldata and place on the stack.", "            address offerer;", "            assembly {", "                offerer := calldataload(BasicOrder_offerer_cdPtr)", "            }", "", "            // Read offerer's current nonce from storage and place on the stack.", "            uint256 nonce = _getNonce(offerer);", "", "            // Load order typehash from runtime code and place on stack.", "            bytes32 typeHash = _ORDER_TYPEHASH;", "", "            assembly {", "                // Set the OrderItem typeHash in memory.", "                mstore(BasicOrder_order_typeHash_ptr, typeHash)", "", "                // Copy offerer and zone from OrderParameters in calldata to the", "                // Order struct.", "                calldatacopy(", "                    BasicOrder_order_offerer_ptr,", "                    BasicOrder_offerer_cdPtr,", "                    TwoWords", "                )", "", "                // Copy receivedItemsHash from zero slot to the Order struct.", "                mstore(", "                    BasicOrder_order_considerationHashes_ptr,", "                    mload(receivedItemsHash_ptr)", "                )", "", "                // Write the supplied orderType to the Order struct.", "                mstore(BasicOrder_order_orderType_ptr, orderType)", "", "                // Copy startTime, endTime, zoneHash, salt & conduit from", "                // calldata to the Order struct.", "                calldatacopy(", "                    BasicOrder_order_startTime_ptr,", "                    BasicOrder_startTime_cdPtr,", "                    FiveWords", "                )", "", "                // Take offerer's nonce retrieved from storage, write to struct.", "                mstore(BasicOrder_order_nonce_ptr, nonce)", "", "                // Compute the EIP712 Order hash.", "                orderHash := keccak256(", "                    BasicOrder_order_typeHash_ptr,", "                    EIP712_Order_size", "                )", "            }", "        }", "", "        assembly {", "            /**", "             * After the order hash has been derived, emit OrderFulfilled event:", "             *   event OrderFulfilled(", "             *     bytes32 orderHash,", "             *     address indexed offerer,", "             *     address indexed zone,", "             *     address fulfiller,", "             *     SpentItem[] offer,", "             *       > (itemType, token, id, amount)", "             *     ReceivedItem[] consideration", "             *       > (itemType, token, id, amount, recipient)", "             *   )", "             * topic0 - OrderFulfilled event signature", "             * topic1 - offerer", "             * topic2 - zone", "             * data:", "             *  - 0x00: orderHash", "             *  - 0x20: fulfiller", "             *  - 0x40: offer arr ptr (0x80)", "             *  - 0x60: consideration arr ptr (0x120)", "             *  - 0x80: offer arr len (1)", "             *  - 0xa0: offer.itemType", "             *  - 0xc0: offer.token", "             *  - 0xe0: offer.identifier", "             *  - 0x100: offer.amount", "             *  - 0x120: 1 + recipients.length", "             *  - 0x140: recipient 0", "             */", "", "            // Derive pointer to start of OrderFulfilled event data", "            let eventDataPtr := add(", "                OrderFulfilled_baseOffset,", "                mul(", "                    calldataload(BasicOrder_additionalRecipients_length_cdPtr),", "                    OneWord", "                )", "            )", "", "            // Write the order hash to the head of the event's data region.", "            mstore(eventDataPtr, orderHash)", "", "            // Write the fulfiller (i.e. the caller) next.", "            mstore(add(eventDataPtr, OrderFulfilled_fulfiller_offset), caller())", "", "            // Write the SpentItem and ReceivedItem array offsets (constants).", "            mstore(", "                // SpentItem array offset", "                add(eventDataPtr, OrderFulfilled_offer_head_offset),", "                OrderFulfilled_offer_body_offset", "            )", "            mstore(", "                // ReceivedItem array offset", "                add(eventDataPtr, OrderFulfilled_consideration_head_offset),", "                OrderFulfilled_consideration_body_offset", "            )", "", "            // Derive total data size including SpentItem and ReceivedItem data.", "            // SpentItem portion is already included in the baseSize constant,", "            // as there can only be one element in the array.", "            let dataSize := add(", "                OrderFulfilled_baseSize,", "                mul(", "                    calldataload(BasicOrder_additionalRecipients_length_cdPtr),", "                    ReceivedItem_size", "                )", "            )", "", "            // Emit OrderFulfilled log with three topics (the event signature", "            // as well as the two indexed arguments, the offerer and the zone).", "            log3(", "                // Supply the pointer for event data in memory.", "                eventDataPtr,", "                // Supply the size of event data in memory.", "                dataSize,", "                // Supply the OrderFulfilled event signature.", "                OrderFulfilled_selector,", "                // Supply the first topic (the offerer).", "                calldataload(BasicOrder_offerer_cdPtr),", "                // Supply the second topic (the zone).", "                calldataload(BasicOrder_zone_cdPtr)", "            )", "", "            // Restore the zero slot.", "            mstore(ZeroSlot, 0)", "        }", "", "        // Determine whether order is restricted and, if so, that it is valid.", "        _assertRestrictedBasicOrderValidity(", "            orderHash,", "            parameters.zoneHash,", "            orderType,", "            parameters.offerer,", "            parameters.zone", "        );", "", "        // Verify and update the status of the derived order.", "        _validateBasicOrderAndUpdateStatus(", "            orderHash,", "            parameters.offerer,", "            parameters.signature", "        );", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function initialize(uint treeIndex, address destination, uint totalCoins, uint startTime, uint endTime, uint lockPeriodEndTime, bytes32[] memory proof) external {", "        // must not initialize multiple times", "        require(!initialized[destination][treeIndex], \"Already initialized\");", "        // leaf hash is digest of vesting schedule parameters and destination", "        // NOTE: use abi.encode, not abi.encodePacked to avoid possible (but unlikely) collision", "        bytes32 leaf = keccak256(abi.encode(destination, totalCoins, startTime, endTime, lockPeriodEndTime));", "        // memory because we read only", "        MerkleTree memory tree = merkleTrees[treeIndex];", "        // call to MerkleLib to check if the submitted data is correct", "        require(tree.rootHash.verifyProof(leaf, proof), \"The proof could not be verified.\");", "        // set initialized, preventing double initialization", "        initialized[destination][treeIndex] = true;", "        // precompute how many coins are released per second", "        uint coinsPerSecond = totalCoins / (endTime - startTime);", "        // create the tranche struct and assign it", "        tranches[destination][treeIndex] = Tranche(", "            totalCoins,  // total coins to be released", "            totalCoins,  // currentCoins starts as totalCoins", "            startTime,", "            endTime,", "            coinsPerSecond,", "            startTime,    // lastWithdrawal starts as startTime", "            lockPeriodEndTime", "        );", "        // if we've passed the lock time go ahead and perform a withdrawal now", "        if (lockPeriodEndTime < block.timestamp) {", "            withdraw(treeIndex, destination);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function initialize(", "        address feeHandler,", "        bytes32[] calldata protocols,", "        address[] calldata handlers", "    ) external initializer onlyGovernance {", "        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);", "        _setConfig(_FEE_HANDLER_KEY, feeHandler);", "        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);", "        for (uint256 i = 0; i < protocols.length; i++) {", "            bytes32 protocolKey = _getProtocolKey(protocols[i]);", "            _setConfig(protocolKey, handlers[i]);", "            _updateTopUpHandler(protocols[i], address(0), handlers[i]);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function _transferToEscrow(address nftContract, uint256 tokenId) internal virtual override {", "    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];", "    if (auctionId == 0) {", "      // NFT is not in auction", "      super._transferToEscrow(nftContract, tokenId);", "      return;", "    }", "    // Using storage saves gas since most of the data is not needed", "    ReserveAuction storage auction = auctionIdToAuction[auctionId];", "    if (auction.endTime == 0) {", "      // Reserve price set, confirm the seller is a match", "      if (auction.seller != msg.sender) {", "        revert NFTMarketReserveAuction_Not_Matching_Seller(auction.seller);", "      }", "    } else {", "      // Auction in progress, confirm the highest bidder is a match", "      if (auction.bidder != msg.sender) {", "        revert NFTMarketReserveAuction_Not_Matching_Seller(auction.bidder);", "      }", "", "      // Finalize auction but leave NFT in escrow, reverts if the auction has not ended", "      _finalizeReserveAuction(auctionId, true);", "    }", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function changeTokenOf(", "    uint256 _projectId,", "    IJBToken _token,", "    address _newOwner", "  )", "    external", "    virtual", "    override", "    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)", "  {", "    // Get a reference to the project's current funding cycle.", "    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);", "", "    // The current funding cycle must not be paused.", "    if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();", "", "    // Change the token in the store.", "    tokenStore.changeFor(_projectId, _token, _newOwner);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {", "        TokenLoan memory loan = tokenLoan[tokenId];", "        if (loan.status == LOAN_OUTSTANDING) {", "            // The lender can change terms so long as the changes are strictly", "            // the same or better for the borrower:", "            require(msg.sender == loan.lender, \"NFTPair: not the lender\");", "            TokenLoanParams memory cur = tokenLoanParams[tokenId];", "            require(", "                params.duration >= cur.duration &&", "                    params.valuation <= cur.valuation &&", "                    params.annualInterestBPS <= cur.annualInterestBPS &&", "                    params.ltvBPS <= cur.ltvBPS,", "                \"NFTPair: worse params\"", "            );", "        } else if (loan.status == LOAN_REQUESTED) {", "            // The borrower has already deposited the collateral and can", "            // change whatever they like", "            require(msg.sender == loan.borrower, \"NFTPair: not the borrower\");", "        } else {", "            // The loan has not been taken out yet; the borrower needs to", "            // provide collateral.", "            revert(\"NFTPair: no collateral\");", "        }", "        tokenLoanParams[tokenId] = params;", "        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);", "    }"], "ner_tags": [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
