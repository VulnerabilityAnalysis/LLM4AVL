{"tokens": ["    function balanceOfJPEG() external view returns (uint256) {", "        uint256 availableBalance = jpeg.balanceOf(address(this));", "", "        IBaseRewardPool baseRewardPool = convexConfig.baseRewardPool;", "        uint256 length = baseRewardPool.extraRewardsLength();", "        for (uint256 i = 0; i < length; i++) {", "            IBaseRewardPool extraReward = IBaseRewardPool(baseRewardPool.extraRewards(i));", "            if (address(jpeg) == extraReward.rewardToken()) {", "                availableBalance += extraReward.earned();", "                //we found jpeg, no need to continue the loop", "                break;", "            }", "        }", "", "        return availableBalance;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function allocateFunds() public override {", "        // Max amount out times this loop will run", "        // This is to ensure the transaction do not run out of gas (max gas limit)", "        uint256 _maxLoop = 50;", "", "        // Difference of totalLent and totalAllocated is what can be used to allocate new tasks", "        uint256 _costToAllocate = totalLent - totalAllocated;", "", "        // Bool if max loop limit is exceeded", "        bool _exceedLimit;", "", "        // Local instance of lastAllocatedChangeOrderTask. To save gas.", "        uint256 i = lastAllocatedChangeOrderTask;", "", "        // Local instance of lastAllocatedTask. To save gas.", "        uint256 j = lastAllocatedTask;", "", "        // Initialize empty array in which allocated tasks will be added.", "        uint256[] memory _tasksAllocated = new uint256[](", "            taskCount - j + _changeOrderedTask.length - i", "        );", "", "        // Number of times a loop has run.", "        uint256 _loopCount;", "", "        /// CHANGE ORDERED TASK FUNDING ///", "", "        // Any tasks added to _changeOrderedTask will be allocated first", "        if (_changeOrderedTask.length > 0) {", "            // Loop from lastAllocatedChangeOrderTask to _changeOrderedTask length (until _maxLoop)", "            for (; i < _changeOrderedTask.length; i++) {", "                // Local instance of task cost. To save gas.", "                uint256 _taskCost = tasks[_changeOrderedTask[i]].cost;", "", "                // If _maxLoop limit is reached then stop looping", "                if (_loopCount >= _maxLoop) {", "                    _exceedLimit = true;", "                    break;", "                }", "", "                // If there is enough funds to allocate this task", "                if (_costToAllocate >= _taskCost) {", "                    // Reduce task cost from _costToAllocate", "                    _costToAllocate -= _taskCost;", "", "                    // Mark the task as allocated", "                    tasks[_changeOrderedTask[i]].fundTask();", "", "                    // Add task to _tasksAllocated array", "                    _tasksAllocated[_loopCount] = _changeOrderedTask[i];", "", "                    // Increment loop counter", "                    _loopCount++;", "                }", "                // If there are not enough funds to allocate this task then stop looping", "                else {", "                    break;", "                }", "            }", "", "            // If all the change ordered tasks are allocated, then delete", "            // the changeOrderedTask array and reset lastAllocatedChangeOrderTask.", "            if (i == _changeOrderedTask.length) {", "                lastAllocatedChangeOrderTask = 0;", "                delete _changeOrderedTask;", "            }", "            // Else store the last allocated change order task index.", "            else {", "                lastAllocatedChangeOrderTask = i;", "            }", "        }", "", "        /// TASK FUNDING ///", "", "        // If lastAllocatedTask is lesser than taskCount, that means there are un-allocated tasks", "        if (j < taskCount) {", "            // Loop from lastAllocatedTask + 1 to taskCount (until _maxLoop)", "            for (++j; j <= taskCount; j++) {", "                // Local instance of task cost. To save gas.", "                uint256 _taskCost = tasks[j].cost;", "", "                // If _maxLoop limit is reached then stop looping", "                if (_loopCount >= _maxLoop) {", "                    _exceedLimit = true;", "                    break;", "                }", "", "                // If there is enough funds to allocate this task", "                if (_costToAllocate >= _taskCost) {", "                    // Reduce task cost from _costToAllocate", "                    _costToAllocate -= _taskCost;", "", "                    // Mark the task as allocated", "                    tasks[j].fundTask();", "", "                    // Add task to _tasksAllocated array", "                    _tasksAllocated[_loopCount] = j;", "", "                    // Increment loop counter", "                    _loopCount++;", "                }", "                // If there are not enough funds to allocate this task then stop looping", "                else {", "                    break;", "                }", "            }", "", "            // If all pending tasks are allocated store lastAllocatedTask equal to taskCount", "            if (j > taskCount) {", "                lastAllocatedTask = taskCount;", "            }", "            // If not all tasks are allocated store updated lastAllocatedTask", "            else {", "                lastAllocatedTask = --j;", "            }", "        }", "", "        // If any tasks is allocated, then emit event", "        if (_loopCount > 0) emit TaskAllocated(_tasksAllocated);", "", "        // If allocation was incomplete, then emit event", "        if (_exceedLimit) emit IncompleteAllocation();", "", "        // Update totalAllocated with all allocations", "        totalAllocated = totalLent - _costToAllocate;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function swap(TimeswapV2OptionSwapParam calldata param) external override noDelegateCall returns (uint256 token0AndLong0Amount, uint256 token1AndLong1Amount, bytes memory data) {", "        if (!hasInteracted[param.strike][param.maturity]) Error.inactiveOptionChoice(param.strike, param.maturity);", "        ParamLibrary.check(param, blockTimestamp());", "", "        Option storage option = options[param.strike][param.maturity];", "", "        // does main swap logic calculation", "        (token0AndLong0Amount, token1AndLong1Amount) = option.swap(param.strike, param.longTo, param.isLong0ToLong1, param.transaction, param.amount);", "", "        // update token0 and token1 balance target for any previous concurrent option transactions.", "        processing.updateProcess(token0AndLong0Amount, token1AndLong1Amount, !param.isLong0ToLong1, param.isLong0ToLong1);", "", "        // add a new process", "        // stores the token0 and token1 balance target required from the msg.sender to achieve.", "        Process storage currentProcess = (processing.push() = Process(", "            param.strike,", "            param.maturity,", "            param.isLong0ToLong1 ? IERC20(token0).balanceOf(address(this)) - token0AndLong0Amount : IERC20(token0).balanceOf(address(this)) + token0AndLong0Amount,", "            param.isLong0ToLong1 ? IERC20(token1).balanceOf(address(this)) + token1AndLong1Amount : IERC20(token1).balanceOf(address(this)) - token1AndLong1Amount", "        ));", "", "        // transfer token to recipient.", "        IERC20(param.isLong0ToLong1 ? token0 : token1).safeTransfer(param.tokenTo, param.isLong0ToLong1 ? token0AndLong0Amount : token1AndLong1Amount);", "", "        // ask the msg.sender to transfer token0 or token1 to this contract.", "        data = ITimeswapV2OptionSwapCallback(msg.sender).timeswapV2OptionSwapCallback(", "            TimeswapV2OptionSwapCallbackParam({", "                strike: param.strike,", "                maturity: param.maturity,", "                isLong0ToLong1: param.isLong0ToLong1,", "                token0AndLong0Amount: token0AndLong0Amount,", "                token1AndLong1Amount: token1AndLong1Amount,", "                data: param.data", "            })", "        );", "", "        // check if the token0 or token1 balance target is achieved.", "        Error.checkEnough(IERC20(param.isLong0ToLong1 ? token1 : token0).balanceOf(address(this)), param.isLong0ToLong1 ? currentProcess.balance1Target : currentProcess.balance0Target);", "", "        if (param.isLong0ToLong1) option.long0[msg.sender] -= token0AndLong0Amount;", "        else option.long1[msg.sender] -= token1AndLong1Amount;", "", "        // finish the process.", "        processing.pop();", "", "        emit Swap(param.strike, param.maturity, msg.sender, param.tokenTo, param.longTo, param.isLong0ToLong1, token0AndLong0Amount, token1AndLong1Amount);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _constructOrder(", "        address _vault,", "        uint256 _listingPrice,", "        OfferItem[] calldata _offer", "    ) internal {", "        Order storage order = proposedListings[_vault].order;", "        OrderParameters storage orderParams = order.parameters;", "        {", "            orderParams.offerer = _vault;", "            orderParams.startTime = block.timestamp;", "            // order doesn't expire in human time scales and needs explicit cancellations", "            orderParams.endTime = type(uint256).max;", "            orderParams.zone = zone;", "            // 0: no partial fills, anyone can execute", "            orderParams.orderType = OrderType.FULL_OPEN;", "            orderParams.conduitKey = conduitKey;", "            // 1 Consideration for the listing itself + 1 consideration for the fees", "            orderParams.totalOriginalConsiderationItems = 3;", "        }", "", "        // Builds the order params from the offer items", "        unchecked {", "            for (uint256 i = 0; i < _offer.length; ++i) {", "                orderParams.offer.push(_offer[i]);", "            }", "        }", "", "        uint256 openseaFees = _listingPrice / 40;", "        uint256 tesseraFees = _listingPrice / 20;", "", "        // Attaches the actual consideration of the order", "        orderParams.consideration.push(", "            ConsiderationItem(", "                ItemType.NATIVE,", "                address(0),", "                0,", "                _listingPrice,", "                _listingPrice,", "                payable(address(this))", "            )", "        );", "", "        // Attaches a payment to the fee receiver to the consideration", "        orderParams.consideration.push(", "            ConsiderationItem(", "                ItemType.NATIVE,", "                address(0),", "                0,", "                openseaFees,", "                openseaFees,", "                OPENSEA_RECIPIENT", "            )", "        );", "", "        // Attaches a payment to the fee receiver to the consideration", "        orderParams.consideration.push(", "            ConsiderationItem(ItemType.NATIVE, address(0), 0, tesseraFees, tesseraFees, feeReceiver)", "        );", "", "        uint256 counter = ISeaport(seaport).getCounter(_vault);", "        vaultOrderHash[_vault] = _getOrderHash(orderParams, counter);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["    function changeController(address _controller) public onlyFactory {", "        if(_controller == address(0))", "            revert AddressZero();", "        controller = _controller;", "    }"], "ner_tags": [1, 0, 0, 0, 0]}
{"tokens": ["    function _quorumReached(uint256 proposalId) internal view override returns (bool){", "        return proposalData[proposalId].supportVotes[1] + proposalData[proposalId].supportVotes[2] >= quorum(proposalSnapshot(proposalId));", "    }"], "ner_tags": [0, 1, 0]}
{"tokens": ["  function createMarket(", "    uint8 p,", "    uint256 m,", "    address c,", "    string memory n,", "    string memory s", "  ) external authorized(admin) unpaused(p) returns (bool) {", "    if (swivel == address(0)) { revert Exception(21, 0, 0, address(0), address(0)); }", "", "    address underAddr = Compounding.underlying(p, c);", "", "    if (markets[p][underAddr][m].vaultTracker != address(0)) { revert Exception(22, 0, 0, address(0), address(0)); }", "", "    (address zct, address tracker) = ICreator(creator).create(p, underAddr, m, c, swivel, n, s, IErc20(underAddr).decimals()) ;", "", "    markets[p][underAddr][m] = Market(c, zct, tracker, 0);", "", "    emit Create(p, underAddr, m, c, zct, tracker);", "", "    return true;", "  }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function initialize(", "        ERC20 token,", "        address market,", "        address _feeTo", "    ) external {", "        require(!initialized);", "        string memory _symbol = string(", "            abi.encodePacked((\"bath\"), token.symbol())", "        );", "        symbol = _symbol;", "        underlyingToken = token;", "        RubiconMarketAddress = market;", "        bathHouse = msg.sender; //NOTE: assumed admin is creator on BathHouse", "", "        uint256 chainId;", "        assembly {", "            chainId := chainid()", "        }", "        DOMAIN_SEPARATOR = keccak256(", "            abi.encode(", "                keccak256(", "                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"", "                ),", "                keccak256(bytes(name)),", "                keccak256(bytes(\"1\")),", "                chainId,", "                address(this)", "            )", "        );", "        name = string(abi.encodePacked(_symbol, (\" v1\")));", "        decimals = token.decimals(); // v1 Change - 4626 Adherence", "", "        // Add infinite approval of Rubicon Market for this asset", "        IERC20(address(token)).approve(RubiconMarketAddress, 2**256 - 1);", "        emit LogInit(block.timestamp);", "", "        feeTo = address(this); //This contract is the fee recipient, rewarding HODLers", "        feeBPS = 3; //Fee set to 3 BPS initially", "", "        // Complete constract instantiation", "        initialized = true;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function withdraw(uint treeIndex, address destination, uint value, bytes32[] memory proof) public {", "        // no withdrawing from uninitialized merkle trees", "        require(treeIndex <= numTrees, \"Provided merkle index doesn't exist\");", "        // no withdrawing same airdrop twice", "        require(!withdrawn[destination][treeIndex], \"You have already withdrawn your entitled token.\");", "        // compute merkle leaf, this is first element of proof", "        bytes32 leaf = keccak256(abi.encode(destination, value));", "        // storage because we edit", "        MerkleTree storage tree = merkleTrees[treeIndex];", "        // this calls to MerkleLib, will return false if recursive hashes do not end in merkle root", "        require(tree.merkleRoot.verifyProof(leaf, proof), \"The proof could not be verified.\");", "        // close re-entrance gate, prevent double claims", "        withdrawn[destination][treeIndex] = true;", "        // update struct", "        tree.tokenBalance -= value;", "        tree.spentTokens += value;", "        // transfer the tokens", "        // NOTE: if the token contract is malicious this call could re-enter this function", "        // which will fail because withdrawn will be set to true", "        require(IERC20(tree.tokenAddress).transfer(destination, value), \"ERC20 transfer failed\");", "        emit WithdrawalOccurred(treeIndex, destination, value);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function transferFrom(", "        address from,", "        address to,", "        uint256 id", "    ) public override {", "        require(from == getGobblerData[id].owner, \"WRONG_FROM\");", "", "        require(to != address(0), \"INVALID_RECIPIENT\");", "", "        require(", "            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],", "            \"NOT_AUTHORIZED\"", "        );", "", "        delete getApproved[id];", "", "        getGobblerData[id].owner = to;", "", "        unchecked {", "            uint32 emissionMultiple = getGobblerData[id].emissionMultiple; // Caching saves gas.", "", "            // We update their last balance before updating their emission multiple to avoid", "            // penalizing them by retroactively applying their new (lower) emission multiple.", "            getUserData[from].lastBalance = uint128(gooBalance(from));", "            getUserData[from].lastTimestamp = uint64(block.timestamp);", "            getUserData[from].emissionMultiple -= emissionMultiple;", "            getUserData[from].gobblersOwned -= 1;", "", "            // We update their last balance before updating their emission multiple to avoid", "            // overpaying them by retroactively applying their new (higher) emission multiple.", "            getUserData[to].lastBalance = uint128(gooBalance(to));", "            getUserData[to].lastTimestamp = uint64(block.timestamp);", "            getUserData[to].emissionMultiple += emissionMultiple;", "            getUserData[to].gobblersOwned += 1;", "        }", "", "        emit Transfer(from, to, id);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function getTokenIdStakingAmount(", "        uint256 poolId,", "        ApeCoinStaking _apeCoinStaking,", "        uint256 tokenId", "    ) public view returns (uint256) {", "        (uint256 apeStakedAmount, ) = _apeCoinStaking.nftPosition(", "            poolId,", "            tokenId", "        );", "", "        uint256 apeReward = _apeCoinStaking.pendingRewards(", "            poolId,", "            address(this),", "            tokenId", "        );", "", "        (uint256 bakcTokenId, bool isPaired) = _apeCoinStaking.mainToBakc(", "            poolId,", "            tokenId", "        );", "", "        if (isPaired) {", "            (uint256 bakcStakedAmount, ) = _apeCoinStaking.nftPosition(", "                BAKC_POOL_ID,", "                bakcTokenId", "            );", "            apeStakedAmount += bakcStakedAmount;", "        }", "", "        return apeStakedAmount + apeReward;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function reclaimVotes(uint256 proposalId_) external {", "        uint256 userVotes = userVotesForProposal[proposalId_][msg.sender];", "", "        if (userVotes == 0) {", "            revert CannotReclaimZeroVotes();", "        }", "", "        if (proposalId_ == activeProposal.proposalId) {", "            revert CannotReclaimTokensForActiveVote();", "        }", "", "        if (tokenClaimsForProposal[proposalId_][msg.sender] == true) {", "            revert VotingTokensAlreadyReclaimed();", "        }", "", "        tokenClaimsForProposal[proposalId_][msg.sender] = true;", "", "        VOTES.transferFrom(address(this), msg.sender, userVotes);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {", "        require(", "            blockNumber < block.number,", "            \"hPAL: invalid blockNumber\"", "        );", "", "        TotalLock memory emptyLock = TotalLock(", "            0,", "            0", "        );", "", "        uint256 nbCheckpoints = totalLocks.length;", "", "        // last checkpoint check", "        if (totalLocks[nbCheckpoints - 1].fromBlock <= blockNumber) {", "            return totalLocks[nbCheckpoints - 1];", "        }", "", "        // no checkpoint old enough", "        if (totalLocks[0].fromBlock > blockNumber) {", "            return emptyLock;", "        }", "", "        uint256 high = nbCheckpoints - 1; // last checkpoint already checked", "        uint256 low = 0;", "        uint256 mid;", "        while (low < high) {", "            mid = Math.average(low, high);", "            if (totalLocks[mid].fromBlock == blockNumber) {", "                return totalLocks[mid];", "            }", "            if (totalLocks[mid].fromBlock > blockNumber) {", "                high = mid;", "            } else {", "                low = mid + 1;", "            }", "        }", "        return high == 0 ? emptyLock : totalLocks[high - 1];", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _assertUserHasEnoughGiantLPToClaimVaultLP(LPToken _token, uint256 _amount) internal view {", "        require(_amount >= MIN_STAKING_AMOUNT, \"Invalid amount\");", "        require(_token.balanceOf(address(this)) >= _amount, \"Pool does not own specified LP\");", "        require(lpTokenETH.lastInteractedTimestamp(msg.sender) + 1 days < block.timestamp, \"Too new\");", "    }"], "ner_tags": [0, 0, 0, 1, 0]}
{"tokens": ["    function setAllowedCollateral(IPaprController.CollateralAllowedConfig[] calldata collateralConfigs)", "        external", "        override", "        onlyOwner", "    {", "        for (uint256 i = 0; i < collateralConfigs.length;) {", "            if (collateralConfigs[i].collateral == address(0)) revert IPaprController.InvalidCollateral();", "", "            isAllowed[collateralConfigs[i].collateral] = collateralConfigs[i].allowed;", "            emit AllowCollateral(collateralConfigs[i].collateral, collateralConfigs[i].allowed);", "            unchecked {", "                ++i;", "            }", "        }", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function deploy() external override returns (IMIMOProxy proxy) {", "    proxy = deployFor(msg.sender);", "  }"], "ner_tags": [1, 1, 1]}
{"tokens": ["    function setApprovalFor(", "        address withdrawer_,", "        ERC20 token_,", "        uint256 amount_", "    ) external permissioned {", "        withdrawApproval[withdrawer_][token_] = amount_;", "", "        emit ApprovedForWithdrawal(withdrawer_, token_, amount_);", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["  function setFee(uint16[] memory i, uint16[] memory d) external authorized(admin) returns (bool) {", "    uint256 len = i.length;", "", "    if (len != d.length) { revert Exception(19, len, d.length, address(0), address(0)); }", "", "    if (feeChange == 0) { revert Exception(16, 0, 0, address(0), address(0)); }", "", "    if (block.timestamp < feeChange) { revert Exception(17, block.timestamp, feeChange, address(0), address(0)); }", "", "    for (uint256 x; x < len;) {", "      if (d[x] < MIN_FEENOMINATOR) { revert Exception(18, uint256(d[x]), 0, address(0), address(0)); }", "", "      feenominators[x] = d[x];", "      emit SetFee(i[x], d[x]);", "", "      unchecked {", "        x++;", "      }", "    }", "", "    feeChange = 0;", "", "    return true;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function replaceAdmin(address _newAdmin)", "        external", "        override", "        onlyAdmin", "        nonZero(_newAdmin)", "        noChange(admin, _newAdmin)", "    {", "        // Replace admin", "        admin = _newAdmin;", "", "        emit AdminReplaced(_newAdmin);", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function getLatestPrice(address _token)", "        public", "        view", "        returns (int256 nowPrice)", "    {", "        (", "            ,", "            /*uint80 roundId*/", "            int256 answer,", "            uint256 startedAt, /*uint256 updatedAt*/ /*uint80 answeredInRound*/", "            ,", "", "        ) = sequencerUptimeFeed.latestRoundData();", "", "        // Answer == 0: Sequencer is up", "        // Answer == 1: Sequencer is down", "        bool isSequencerUp = answer == 0;", "        if (!isSequencerUp) {", "            revert SequencerDown();", "        }", "", "        // Make sure the grace period has passed after the sequencer is back up.", "        uint256 timeSinceUp = block.timestamp - startedAt;", "        if (timeSinceUp <= GRACE_PERIOD_TIME) {", "            revert GracePeriodNotOver();", "        }", "", "        AggregatorV3Interface priceFeed = AggregatorV3Interface(", "            vaultFactory.tokenToOracle(_token)", "        );", "        (", "            uint80 roundID,", "            int256 price,", "            ,", "            uint256 timeStamp,", "            uint80 answeredInRound", "        ) = priceFeed.latestRoundData();", "", "        uint256 decimals = 10**(18-(priceFeed.decimals()));", "        price = price * int256(decimals);", "", "        if(price <= 0)", "            revert OraclePriceZero();", "", "        if(answeredInRound < roundID)", "            revert RoundIDOutdated();", "", "        if(timeStamp == 0)", "            revert TimestampZero();", "", "        return price;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function sellPrincipalToken(", "        address u,", "        uint256 m,", "        uint128 a", "    ) external returns (uint128) {", "        IPool pool = IPool(pools[u][m]);", "        Safe.transfer(IERC20(address(pool.fyToken())), address(pool), a);", "        return pool.sellFYToken(msg.sender, pool.sellFYTokenPreview(a));", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function upgradeETH2LD(", "        string calldata label,", "        address wrappedOwner,", "        address resolver", "    ) public {", "        bytes32 labelhash = keccak256(bytes(label));", "        bytes32 node = _makeNode(ETH_NODE, labelhash);", "        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);", "", "        upgradeContract.wrapETH2LD(", "            label,", "            wrappedOwner,", "            fuses,", "            expiry,", "            resolver", "        );", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function previewWithdraw(uint256 id, uint256 assets)", "        public", "        view", "        virtual", "        returns (uint256)", "    {", "        uint256 supply = totalSupply(id); // Saves an extra SLOAD if totalSupply is non-zero.", "", "        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets(id));", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": ["  constructor(uint8 p, uint256 m, address c, address s) {", "    admin = msg.sender;", "    protocol = p;", "    maturity = m;", "    cTokenAddr = c;", "    swivel = s;", "", "    // instantiate swivel's vault (unblocking transferNotionalFee)", "    vaults[s] = Vault({", "      notional: 0,", "      redeemable: 0,", "      exchangeRate: Compounding.exchangeRate(p, c)", "    });", "  }"], "ner_tags": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _processExpiredLocks(", "        address _account,", "        bool _relock,", "        address _rewardAddress,", "        uint256 _checkDelay", "    ) internal updateReward(_account) {", "        LockedBalance[] storage locks = userLocks[_account];", "        Balances storage userBalance = balances[_account];", "        uint112 locked;", "        uint256 length = locks.length;", "        uint256 reward = 0;", "        uint256 expiryTime = _checkDelay == 0 && _relock", "            ? block.timestamp.add(rewardsDuration)", "            : block.timestamp.sub(_checkDelay);", "        require(length > 0, \"no locks\");", "        // e.g. now = 16", "        // if contract is shutdown OR latest lock unlock time (e.g. 17) <= now - (1)", "        // e.g. 17 <= (16 + 1)", "        if (isShutdown || locks[length - 1].unlockTime <= expiryTime) {", "            //if time is beyond last lock, can just bundle everything together", "            locked = userBalance.locked;", "", "            //dont delete, just set next index", "            userBalance.nextUnlockIndex = length.to32();", "", "            //check for kick reward", "            //this wont have the exact reward rate that you would get if looped through", "            //but this section is supposed to be for quick and easy low gas processing of all locks", "            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch", "            if (_checkDelay > 0) {", "                uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);", "                uint256 epochsover = currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(rewardsDuration);", "                uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);", "                reward = uint256(locks[length - 1].amount).mul(rRate).div(denominator);", "            }", "        } else {", "            //use a processed index(nextUnlockIndex) to not loop as much", "            //deleting does not change array length", "            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;", "            for (uint256 i = nextUnlockIndex; i < length; i++) {", "                //unlock time must be less or equal to time", "                if (locks[i].unlockTime > expiryTime) break;", "", "                //add to cumulative amounts", "                locked = locked.add(locks[i].amount);", "", "                //check for kick reward", "                //each epoch over due increases reward", "                if (_checkDelay > 0) {", "                    uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);", "                    uint256 epochsover = currentEpoch.sub(uint256(locks[i].unlockTime)).div(rewardsDuration);", "                    uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);", "                    reward = reward.add(uint256(locks[i].amount).mul(rRate).div(denominator));", "                }", "                //set next unlock index", "                nextUnlockIndex++;", "            }", "            //update next unlock index", "            userBalance.nextUnlockIndex = nextUnlockIndex;", "        }", "        require(locked > 0, \"no exp locks\");", "", "        //update user balances and total supplies", "        userBalance.locked = userBalance.locked.sub(locked);", "        lockedSupply = lockedSupply.sub(locked);", "", "        //checkpoint the delegatee", "        _checkpointDelegate(delegates(_account), 0, 0);", "", "        emit Withdrawn(_account, locked, _relock);", "", "        //send process incentive", "        if (reward > 0) {", "            //reduce return amount by the kick reward", "            locked = locked.sub(reward.to112());", "", "            //transfer reward", "            stakingToken.safeTransfer(_rewardAddress, reward);", "            emit KickReward(_rewardAddress, _account, reward);", "        }", "", "        //relock or return to user", "        if (_relock) {", "            _lock(_account, locked);", "        } else {", "            stakingToken.safeTransfer(_account, locked);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function unwrap(", "        bytes32 parentNode,", "        bytes32 labelhash,", "        address newController", "    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {", "        if (parentNode == ETH_NODE) {", "            revert IncompatibleParent();", "        }", "        _unwrap(_makeNode(parentNode, labelhash), newController);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function withdrawCollateral(address target, uint256 amount) public onlyOwner noChallenge noCooldown {", "        uint256 balance = internalWithdrawCollateral(target, amount);", "        checkCollateral(balance, price);", "    }"], "ner_tags": [1, 0, 0, 0]}
{"tokens": ["    function _beforeTokenTransfer(", "        address _from,", "        address _to,", "        uint256 _id,", "        uint256 _amount", "    ) internal override(LBToken) {", "        unchecked {", "            super._beforeTokenTransfer(_from, _to, _id, _amount);", "", "            Bin memory _bin = _bins[_id];", "", "            if (_from != _to) {", "                if (_from != address(0) && _from != address(this)) {", "                    uint256 _balanceFrom = balanceOf(_from, _id);", "", "                    _cacheFees(_bin, _from, _id, _balanceFrom, _balanceFrom - _amount);", "                }", "", "                if (_to != address(0) && _to != address(this)) {", "                    uint256 _balanceTo = balanceOf(_to, _id);", "", "                    _cacheFees(_bin, _to, _id, _balanceTo, _balanceTo + _amount);", "                }", "            }", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": ["    function previewWithdraw(uint256 underlyingAmount) external override view returns (uint256 principalAmount){", "        if (block.timestamp < maturity) {", "            return 0;", "        }", "        return (underlyingAmount * IRedeemer(redeemer).markets(protocol, underlying, maturity).maturityRate / IRedeemer(redeemer).getExchangeRate(protocol, cToken));", "    }"], "ner_tags": [0, 0, 0, 0, 1, 0]}
{"tokens": ["    function _populateParameters(BasicOrder calldata order, OrderExtraData memory orderExtraData)", "        private", "        pure", "        returns (OrderParameters memory parameters)", "    {", "        uint256 recipientsLength = orderExtraData.recipients.length;", "", "        parameters.offerer = order.signer;", "        parameters.zone = orderExtraData.zone;", "        parameters.zoneHash = orderExtraData.zoneHash;", "        parameters.salt = orderExtraData.salt;", "        parameters.conduitKey = orderExtraData.conduitKey;", "        parameters.orderType = orderExtraData.orderType;", "        parameters.startTime = order.startTime;", "        parameters.endTime = order.endTime;", "        parameters.totalOriginalConsiderationItems = recipientsLength;", "", "        OfferItem[] memory offer = new OfferItem[](1);", "        // Seaport enums start with NATIVE and ERC20 so plus 2", "        offer[0].itemType = ItemType(uint8(order.collectionType) + 2);", "        offer[0].token = order.collection;", "        offer[0].identifierOrCriteria = order.tokenIds[0];", "        uint256 amount = order.amounts[0];", "        offer[0].startAmount = amount;", "        offer[0].endAmount = amount;", "        parameters.offer = offer;", "", "        ConsiderationItem[] memory consideration = new ConsiderationItem[](recipientsLength);", "        for (uint256 j; j < recipientsLength; ) {", "            // We don't need to assign value to identifierOrCriteria as it is always 0.", "            uint256 recipientAmount = orderExtraData.recipients[j].amount;", "            consideration[j].startAmount = recipientAmount;", "            consideration[j].endAmount = recipientAmount;", "            consideration[j].recipient = payable(orderExtraData.recipients[j].recipient);", "            consideration[j].itemType = order.currency == address(0) ? ItemType.NATIVE : ItemType.ERC20;", "            consideration[j].token = order.currency;", "", "            unchecked {", "                ++j;", "            }", "        }", "        parameters.consideration = consideration;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function unstake(", "        address _unclaimedETHRecipient,", "        address _sETHRecipient,", "        bytes[] calldata _blsPubKeys,", "        uint256[] calldata _sETHAmounts", "    ) external nonReentrant {", "        if (_blsPubKeys.length == 0) revert EmptyArray();", "        if (_blsPubKeys.length != _sETHAmounts.length) revert InconsistentArrayLengths();", "        if (_unclaimedETHRecipient == address(0)) revert ZeroAddress();", "        if (_sETHRecipient == address(0)) revert ZeroAddress();", "", "        // Claim all ETH owed before unstaking but even if nothing is owed `updateAccruedETHPerShares` will be called", "        _claimAsStaker(_unclaimedETHRecipient, _blsPubKeys);", "", "        for (uint256 i; i < _blsPubKeys.length; ++i) {", "            bytes memory _blsPubKey = _blsPubKeys[i];", "            uint256 _sETHAmount = _sETHAmounts[i];", "            if (sETHStakedBalanceForKnot[_blsPubKey][msg.sender] < _sETHAmount) revert NothingStaked();", "", "            (address stakeHouse,,,,,) = getStakeHouseUniverse().stakeHouseKnotInfo(_blsPubKey);", "            IERC20 sETH = IERC20(getSlotRegistry().stakeHouseShareTokens(stakeHouse));", "", "            // Only decrease totalFreeFloatingShares in the event that the knot is still active in the syndicate", "            if (!isNoLongerPartOfSyndicate[_blsPubKey]) {", "                totalFreeFloatingShares -= _sETHAmount;", "            }", "", "            sETHTotalStakeForKnot[_blsPubKey] -= _sETHAmount;", "            sETHStakedBalanceForKnot[_blsPubKey][msg.sender] -= _sETHAmount;", "", "            bool transferResult = sETH.transfer(_sETHRecipient, _sETHAmount);", "            if (!transferResult) revert TransferFailed();", "", "            emit UnStaked(_blsPubKey, _sETHAmount);", "        }", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function _shouldAdjustSupply(uint256 exchangeRate, bool stabilizeToPeg)", "    internal", "    view", "    returns (bool)", "  {", "    uint256 decimals = collateralToken.decimals();", "    uint256 priceTarget;", "", "    if (stabilizeToPeg) {", "      priceTarget = maltDataLab.priceTarget();", "    } else {", "      priceTarget = maltDataLab.getActualPriceTarget();", "    }", "", "    uint256 upperThreshold = (priceTarget * upperStabilityThresholdBps) / 10000;", "    uint256 lowerThreshold = (priceTarget * lowerStabilityThresholdBps) / 10000;", "", "    return", "      (exchangeRate <= (priceTarget - lowerThreshold) &&", "        !auction.auctionExists(auction.currentAuctionId())) ||", "      exchangeRate >= (priceTarget + upperThreshold);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function pushDraft(address account, uint256 rsrAmount)", "        internal", "        returns (uint256 index, uint64 availableAt)", "    {", "        // draftAmount: how many drafts to create and assign to the user", "        // pick draftAmount as big as we can such that (newTotalDrafts <= newDraftRSR * draftRate)", "        draftRSR += rsrAmount;", "        // newTotalDrafts: {qDrafts} = D18{qDrafts/qRSR} * {qRSR} / D18", "        uint256 newTotalDrafts = (draftRate * draftRSR) / FIX_ONE;", "        uint256 draftAmount = newTotalDrafts - totalDrafts;", "        totalDrafts = newTotalDrafts;", "", "        // Push drafts into account's draft queue", "        CumulativeDraft[] storage queue = draftQueues[draftEra][account];", "        index = queue.length;", "", "        uint192 oldDrafts = index > 0 ? queue[index - 1].drafts : 0;", "        uint64 lastAvailableAt = index > 0 ? queue[index - 1].availableAt : 0;", "        availableAt = uint64(block.timestamp) + unstakingDelay;", "        if (lastAvailableAt > availableAt) {", "            availableAt = lastAvailableAt;", "        }", "", "        queue.push(CumulativeDraft(uint176(oldDrafts + draftAmount), availableAt));", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": ["    function whenFinished(uint256 amtRToken) private returns (uint192 finished) {", "        // Calculate the issuance rate (if this is the first issuance in the block)", "        if (lastIssRateBlock < block.number) {", "            lastIssRateBlock = block.number;", "", "            // D18{rTok/block} = D18{1/block} * D18{rTok} / D18{1}", "            // uint192 downcast is safe, max value representations are 1e18 * 1e48 / 1e18", "            lastIssRate = uint192((issuanceRate * totalSupply()) / FIX_ONE);", "            // uint192(<) is equivalent to Fix.lt", "            if (lastIssRate < MIN_BLOCK_ISSUANCE_LIMIT) lastIssRate = MIN_BLOCK_ISSUANCE_LIMIT;", "        }", "", "        // make `before` be the fractional-block when this issuance should start;", "        // before = max(allVestAt, block.number - 1)", "        uint192 before = allVestAt; // D18{block number}", "        // uint192 downcast is safe: block numbers are smaller than 1e38", "        uint192 nowStart = uint192(FIX_ONE * (block.number - 1)); // D18{block} = D18{1} * {block}", "        if (nowStart > before) before = nowStart;", "", "        // finished: D18{block} = D18{block} + D18{1} * D18{RTok} / D18{rtok/block}", "        // uint192() downcast here is safe because:", "        //   lastIssRate is at least 1e24 (from MIN_ISS_RATE), and", "        //   amtRToken is at most 1e48, so", "        //   what's downcast is at most (1e18 * 1e48 / 1e24) = 1e38 < 2^192-1", "        finished = before + uint192((FIX_ONE_256 * amtRToken + (lastIssRate - 1)) / lastIssRate);", "        allVestAt = finished;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": ["    function refresh() public virtual override {", "        // == Refresh ==", "        // Update the Compound Protocol", "        ICToken(address(erc20)).exchangeRateCurrent();", "", "        // Intentional and correct for the super call to be last!", "        super.refresh(); // already handles all necessary default checks", "    }"], "ner_tags": [0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["    function createErc20Distribution(", "        IERC20 token,", "        ITokenDistributorParty party,", "        address payable feeRecipient,", "        uint16 feeBps", "    )", "        external", "        returns (DistributionInfo memory info)", "    {", "        info = _createDistribution(CreateDistributionArgs({", "            party: party,", "            tokenType: TokenType.Erc20,", "            token: address(token),", "            currentTokenBalance: token.balanceOf(address(this)),", "            feeRecipient: feeRecipient,", "            feeBps: feeBps", "        }));", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["    function _executeSwaps(LiFiData memory _lifiData, LibSwap.SwapData[] calldata _swapData) internal {", "        // Swap", "        for (uint8 i; i < _swapData.length; i++) {", "            require(", "                ls.dexWhitelist[_swapData[i].approveTo] == true && ls.dexWhitelist[_swapData[i].callTo] == true,", "                \"Contract call not allowed!\"", "            );", "", "            LibSwap.swap(_lifiData.transactionId, _swapData[i]);", "        }", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function _executeFundsTransfer(", "        address seller,", "        address buyer,", "        address paymentToken,", "        Fee[] calldata fees,", "        uint256 price", "    ) internal {", "        if (msg.sender == buyer && paymentToken == address(0)) {", "            require(remainingETH >= price);", "            remainingETH -= price;", "        }", "", "        /* Take fee. */", "        uint256 receiveAmount = _transferFees(fees, paymentToken, buyer, price);", "", "        /* Transfer remainder to seller. */", "        _transferTo(paymentToken, buyer, seller, receiveAmount);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function issue(address recipient, uint256 amtRToken)", "        public", "        notPausedOrFrozen", "        returns (uint256)", "    {", "        require(amtRToken > 0, \"Cannot issue zero\");", "", "        // == Refresh ==", "        assetRegistry.refresh();", "", "        address issuer = _msgSender(); // OK to save: it can't be changed in reentrant runs", "", "        uint48 basketNonce = basketHandler.nonce();", "        IssueQueue storage queue = issueQueues[recipient];", "", "        // Refund issuances against old baskets", "        if (queue.basketNonce > 0 && queue.basketNonce != basketNonce) {", "            // == Interaction ==", "            // This violates simple CEI, so we have to renew any potential transient state!", "            refundSpan(recipient, queue.left, queue.right);", "", "            // Refresh collateral after interaction", "            assetRegistry.refresh();", "", "            // Refresh local values after potential reentrant changes to contract state.", "            basketNonce = basketHandler.nonce();", "            queue = issueQueues[recipient];", "        }", "", "        // == Checks-effects block ==", "        CollateralStatus status = basketHandler.status();", "        require(status == CollateralStatus.SOUND, \"basket unsound\");", "", "        furnace.melt();", "", "        // AT THIS POINT:", "        //   all contract invariants hold", "        //   furnace melting is up-to-date", "        //   asset states are up-to-date", "        //   queue.basketNonce = basketHandler.nonce()", "", "        // Compute the whole issuance span. We want to accumulate the issuance:", "        // iss = {when: vestingEnd' - vestingEnd, amtRToken, amtBaskets, deposits}", "", "        // amtBaskets: the BU change to be recorded by this issuance", "        // D18{BU} = D18{BU} * {qRTok} / {qRTok}", "        // Downcast is safe because an actual quantity of qBUs fits in uint192", "        uint192 amtBaskets = uint192(", "            totalSupply() > 0 ? mulDiv256(basketsNeeded, amtRToken, totalSupply()) : amtRToken", "        );", "", "        (address[] memory erc20s, uint256[] memory deposits) = basketHandler.quote(", "            amtBaskets,", "            CEIL", "        );", "", "        // Add amtRToken's worth of issuance delay to allVestAt", "        uint192 vestingEnd = whenFinished(amtRToken); // D18{block number}", "", "        // ==== If the issuance can fit in this block, and nothing is blocking it, then", "        // just do a \"quick issuance\" of iss instead of putting the issuance in the queue:", "        // effects and actions if we go this way are the combined actions to create and vest iss:", "        //   basketsNeeded += iss.amtBaskets", "        //   mint(recipient, iss.amtRToken)", "        //   for each token index i, erc20s[i].transferFrom(issuer, backingManager, iss.deposits[i])", "        if (", "            // D18{blocks} <= D18{1} * {blocks}", "            vestingEnd <= FIX_ONE_256 * block.number &&", "            queue.left == queue.right &&", "            status == CollateralStatus.SOUND", "        ) {", "            // Fixlib optimization:", "            // D18{BU} = D18{BU} + D18{BU}; uint192(+) is the same as Fix.plus", "            uint192 newBasketsNeeded = basketsNeeded + amtBaskets;", "            emit BasketsNeededChanged(basketsNeeded, newBasketsNeeded);", "            basketsNeeded = newBasketsNeeded;", "", "            // Note: We don't need to update the prev queue entry because queue.left = queue.right", "            emit Issuance(recipient, amtRToken, amtBaskets);", "", "            // == Interactions then return: transfer tokens ==", "            // Complete issuance", "            _mint(recipient, amtRToken);", "", "            for (uint256 i = 0; i < erc20s.length; ++i) {", "                IERC20Upgradeable(erc20s[i]).safeTransferFrom(", "                    issuer,", "                    address(backingManager),", "                    deposits[i]", "                );", "            }", "", "            // All RTokens instantly issued", "            return amtRToken;", "        }", "", "        // ==== Otherwise, we're going to create and enqueue the issuance \"iss\":", "        // effects and actions down this route are:", "        //   lastItem'(recipient) = lastItem(recipient) + iss", "        //   for each token index i, erc20s[i].transferFrom(issuer, this, iss.deposits[i])", "        // Append issuance to queue (whether that needs a new allocation with push() or not)", "        IssueItem storage curr = (queue.right < queue.items.length)", "            ? queue.items[queue.right]", "            : queue.items.push();", "        curr.when = vestingEnd;", "", "        uint256 basketSize = erc20s.length; // gas optimization", "", "        // Accumulate", "        if (queue.right > 0) {", "            IssueItem storage prev = queue.items[queue.right - 1];", "            curr.amtRToken = prev.amtRToken + amtRToken;", "", "            // D18{BU} = D18{BU} + D18{BU}; uint192(+) is the same as Fix.plus", "            curr.amtBaskets = prev.amtBaskets + amtBaskets;", "", "            curr.deposits = new uint256[](deposits.length);", "            for (uint256 i = 0; i < basketSize; ++i) {", "                curr.deposits[i] = prev.deposits[i] + deposits[i];", "            }", "        } else {", "            // queue.right == 0", "            curr.amtRToken = amtRToken;", "            curr.amtBaskets = amtBaskets;", "            curr.deposits = deposits;", "        }", "", "        // overwrite intentionally: we may have stale values in `tokens` and `basketNonce`", "        queue.basketNonce = basketNonce;", "        queue.tokens = erc20s;", "        queue.right++;", "", "        emit IssuanceStarted(", "            recipient,", "            queue.right - 1,", "            amtRToken,", "            amtBaskets,", "            erc20s,", "            deposits,", "            vestingEnd", "        );", "", "        // Increment liabilities", "        for (uint256 i = 0; i < basketSize; ++i) {", "            liabilities[IERC20(erc20s[i])] += deposits[i];", "        }", "", "        // == Interactions: accept collateral ==", "        for (uint256 i = 0; i < basketSize; ++i) {", "            IERC20Upgradeable(erc20s[i]).safeTransferFrom(issuer, address(this), deposits[i]);", "        }", "", "        // No RTokens instantly issued", "        return 0;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function liquidatePosition(address trader)", "        override", "        external", "        onlyClearingHouse", "        returns (int realizedPnl, uint quoteAsset)", "    {", "        // don't need an ammState check because there should be no active positions", "        Position memory position = positions[trader];", "        bool isLongPosition = position.size > 0 ? true : false;", "        // sending market orders can fk the trader. @todo put some safe guards around price of liquidations", "        if (isLongPosition) {", "            (realizedPnl, quoteAsset) = _reducePosition(trader, -position.size, 0);", "        } else {", "            (realizedPnl, quoteAsset) = _reducePosition(trader, -position.size, type(uint).max);", "        }", "        _emitPositionChanged(trader, realizedPnl);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function notifyRewardAmount(uint256 _amount) external onlyOwner updateReward(address(0)) {", "        if (block.timestamp >= finishAt) {", "            rewardRatio = _amount / duration;", "        } else {", "            uint256 remainingRewards = (finishAt - block.timestamp) * rewardRatio;", "            rewardRatio = (_amount + remainingRewards) / duration;", "        }", "", "        require(rewardRatio > 0, \"reward ratio = 0\");", "", "        finishAt = block.timestamp + duration;", "        updatedAt = block.timestamp;", "        emit NotifyRewardChanged(_amount, block.timestamp);", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function nftBuy(uint256[] calldata tokenIds, uint256 maxInputAmount) public payable returns (uint256 inputAmount) {", "        // buy fractional tokens using base tokens", "        inputAmount = buy(tokenIds.length * ONE, maxInputAmount);", "", "        // unwrap the fractional tokens into NFTs and send to sender", "        unwrap(tokenIds);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function onMinted(uint256 _tokenId) external returns (bool) {", "        // Ensure the caller is the token contract", "        if (msg.sender != settings.token) revert ONLY_TOKEN();", "", "        // Compute some randomness for the token id", "        uint256 seed = _generateSeed(_tokenId);", "", "        // Get the pointer to store generated attributes", "        uint16[16] storage tokenAttributes = attributes[_tokenId];", "", "        // Cache the total number of properties available", "        uint256 numProperties = properties.length;", "", "        // Store the total as reference in the first slot of the token's array of attributes", "        tokenAttributes[0] = uint16(numProperties);", "", "        unchecked {", "            // For each property:", "            for (uint256 i = 0; i < numProperties; ++i) {", "                // Get the number of items to choose from", "                uint256 numItems = properties[i].items.length;", "", "                // Use the token's seed to select an item", "                tokenAttributes[i + 1] = uint16(seed % numItems);", "", "                // Adjust the randomness", "                seed >>= 16;", "            }", "        }", "", "        return true;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": ["  function claim() public {", "    WPStorage storage s = _loadSlot();", "", "    if (s.finalAuctionEnd == 0) {", "      revert InvalidState(InvalidStates.CANT_CLAIM);", "    }", "", "    if (PublicVault(VAULT()).getCurrentEpoch() < CLAIMABLE_EPOCH()) {", "      revert InvalidState(InvalidStates.PROCESS_EPOCH_NOT_COMPLETE);", "    }", "    if (block.timestamp < s.finalAuctionEnd) {", "      revert InvalidState(InvalidStates.FINAL_AUCTION_NOT_OVER);", "    }", "", "    uint256 transferAmount = 0;", "    uint256 balance = ERC20(asset()).balanceOf(address(this)) -", "      s.withdrawReserveReceived; // will never underflow because withdrawReserveReceived is always increased by the transfer amount from the PublicVault", "", "    if (balance < s.expected) {", "      PublicVault(VAULT()).decreaseYIntercept(", "        (s.expected - balance).mulWadDown(1e18 - s.withdrawRatio)", "      );", "    } else {", "      PublicVault(VAULT()).increaseYIntercept(", "        (balance - s.expected).mulWadDown(1e18 - s.withdrawRatio)", "      );", "    }", "", "    if (s.withdrawRatio == uint256(0)) {", "      ERC20(asset()).safeTransfer(VAULT(), balance);", "    } else {", "      transferAmount = uint256(s.withdrawRatio).mulDivDown(", "        balance,", "        10**ERC20(asset()).decimals()", "      );", "", "      unchecked {", "        balance -= transferAmount;", "      }", "", "      if (balance > 0) {", "        ERC20(asset()).safeTransfer(VAULT(), balance);", "      }", "    }", "    s.finalAuctionEnd = 0;", "", "    emit Claimed(address(this), transferAmount, VAULT(), balance);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function decrease(LinearGrowthLimiter storage self, uint256 amount) internal {", "        uint256 value = self.get();", "        self.lastValue = value - amount;", "        self.lastBlock = block.number;", "    }"], "ner_tags": [1, 0, 0, 0, 0]}
{"tokens": ["    function getPoolBadDebt(address comptrollerAddress) external view returns (BadDebtSummary memory) {", "        uint256 totalBadDebtUsd;", "", "        // Get every market in the pool", "        ComptrollerViewInterface comptroller = ComptrollerViewInterface(comptrollerAddress);", "        VToken[] memory markets = comptroller.getAllMarkets();", "        PriceOracle priceOracle = comptroller.oracle();", "", "        BadDebt[] memory badDebts = new BadDebt[](markets.length);", "", "        BadDebtSummary memory badDebtSummary;", "        badDebtSummary.comptroller = comptrollerAddress;", "        badDebtSummary.badDebts = badDebts;", "", "        // // Calculate the bad debt is USD per market", "        for (uint256 i; i < markets.length; ++i) {", "            BadDebt memory badDebt;", "            badDebt.vTokenAddress = address(markets[i]);", "            badDebt.badDebtUsd =", "                VToken(address(markets[i])).badDebt() *", "                priceOracle.getUnderlyingPrice(address(markets[i]));", "            badDebtSummary.badDebts[i] = badDebt;", "            totalBadDebtUsd = totalBadDebtUsd + badDebt.badDebtUsd;", "        }", "", "        badDebtSummary.totalBadDebtUsd = totalBadDebtUsd;", "", "        return badDebtSummary;", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function processFees(uint256 _projectId)", "    external", "    virtual", "    override", "    requirePermissionAllowingOverride(", "      projects.ownerOf(_projectId),", "      _projectId,", "      JBOperations.PROCESS_FEES,", "      msg.sender == owner()", "    )", "  {", "    // Get a reference to the project's held fees.", "    JBFee[] memory _heldFees = _heldFeesOf[_projectId];", "", "    // Delete the held fees.", "    delete _heldFeesOf[_projectId];", "", "    // Push array length in stack", "    uint256 _heldFeeLength = _heldFees.length;", "", "    // Process each fee.", "    for (uint256 _i = 0; _i < _heldFeeLength; ) {", "      // Get the fee amount.", "      uint256 _amount = _feeAmount(", "        _heldFees[_i].amount,", "        _heldFees[_i].fee,", "        _heldFees[_i].feeDiscount", "      );", "", "      // Process the fee.", "      _processFee(_amount, _heldFees[_i].beneficiary);", "", "      emit ProcessFee(_projectId, _amount, true, _heldFees[_i].beneficiary, msg.sender);", "", "      unchecked {", "        ++_i;", "      }", "    }", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _getCashPrior() internal view virtual returns (uint256) {", "        IERC20Upgradeable token = IERC20Upgradeable(underlying);", "        return token.balanceOf(address(this));", "    }"], "ner_tags": [1, 0, 0, 0]}
{"tokens": ["    function _withdraw(", "        uint256 _shares,", "        address _receiver,", "        address _owner", "    ) internal nonReentrant returns (uint256 value) {", "        require(_shares != 0, \"Invalid amount\");", "        value = (_freeFunds() * _shares) / totalSupply();", "        _burn(_owner, _shares);", "", "        if (value > token.balanceOf(address(this))) {", "            uint256 totalLoss = 0;", "            uint256 queueLength = withdrawalQueue.length;", "            uint256 vaultBalance = 0;", "            for (uint256 i = 0; i < queueLength; i = i.uncheckedInc()) {", "                vaultBalance = token.balanceOf(address(this));", "                if (value <= vaultBalance) {", "                    break;", "                }", "", "                address stratAddr = withdrawalQueue[i];", "                uint256 strategyBal = strategies[stratAddr].allocated;", "                if (strategyBal == 0) {", "                    continue;", "                }", "", "                uint256 remaining = value - vaultBalance;", "                uint256 loss = IStrategy(stratAddr).withdraw(Math.min(remaining, strategyBal));", "                uint256 actualWithdrawn = token.balanceOf(address(this)) - vaultBalance;", "", "                // Withdrawer incurs any losses from withdrawing as reported by strat", "                if (loss != 0) {", "                    value -= loss;", "                    totalLoss += loss;", "                    _reportLoss(stratAddr, loss);", "                }", "", "                strategies[stratAddr].allocated -= actualWithdrawn;", "                totalAllocated -= actualWithdrawn;", "            }", "", "            vaultBalance = token.balanceOf(address(this));", "            if (value > vaultBalance) {", "                value = vaultBalance;", "            }", "", "            require(", "                totalLoss <= ((value + totalLoss) * withdrawMaxLoss) / PERCENT_DIVISOR,", "                \"Withdraw loss exceeds slippage\"", "            );", "        }", "", "        token.safeTransfer(_receiver, value);", "        emit Withdraw(msg.sender, _receiver, _owner, value, _shares);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function createQuest(", "        address rewardTokenAddress_,", "        uint256 endTime_,", "        uint256 startTime_,", "        uint256 totalParticipants_,", "        uint256 rewardAmountOrTokenId_,", "        string memory contractType_,", "        string memory questId_", "    ) public onlyRole(CREATE_QUEST_ROLE) returns (address) {", "        if (quests[questId_].questAddress != address(0)) revert QuestIdUsed();", "", "        if (keccak256(abi.encodePacked(contractType_)) == keccak256(abi.encodePacked('erc20'))) {", "            if (rewardAllowlist[rewardTokenAddress_] == false) revert RewardNotAllowed();", "", "            Erc20Quest newQuest = new Erc20Quest(", "                rewardTokenAddress_,", "                endTime_,", "                startTime_,", "                totalParticipants_,", "                rewardAmountOrTokenId_,", "                questId_,", "                address(rabbitholeReceiptContract),", "                questFee,", "                protocolFeeRecipient", "            );", "", "            emit QuestCreated(", "                msg.sender,", "                address(newQuest),", "                questId_,", "                contractType_,", "                rewardTokenAddress_,", "                endTime_,", "                startTime_,", "                totalParticipants_,", "                rewardAmountOrTokenId_", "            );", "            quests[questId_].questAddress = address(newQuest);", "            quests[questId_].totalParticipants = totalParticipants_;", "            newQuest.transferOwnership(msg.sender);", "            ++questIdCount;", "            return address(newQuest);", "        }", "", "        if (keccak256(abi.encodePacked(contractType_)) == keccak256(abi.encodePacked('erc1155'))) {", "            if (msg.sender != owner()) revert OnlyOwnerCanCreate1155Quest();", "", "            Erc1155Quest newQuest = new Erc1155Quest(", "                rewardTokenAddress_,", "                endTime_,", "                startTime_,", "                totalParticipants_,", "                rewardAmountOrTokenId_,", "                questId_,", "                address(rabbitholeReceiptContract)", "            );", "", "            emit QuestCreated(", "                msg.sender,", "                address(newQuest),", "                questId_,", "                contractType_,", "                rewardTokenAddress_,", "                endTime_,", "                startTime_,", "                totalParticipants_,", "                rewardAmountOrTokenId_", "            );", "            quests[questId_].questAddress = address(newQuest);", "            quests[questId_].totalParticipants = totalParticipants_;", "            newQuest.transferOwnership(msg.sender);", "            ++questIdCount;", "            return address(newQuest);", "        }", "", "        revert QuestTypeInvalid();", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function _removeContract(string memory _name) internal {", "    bytes32 hashedName = keccak256(abi.encodePacked(_name));", "    Contract storage currentContract = globalContracts[hashedName];", "    currentContract.contractAddress = address(0);", "    currentContract.index = 0;", "", "    uint256 index = currentContract.index;", "    string memory lastContract = contracts[contracts.length - 1];", "    contracts[index] = lastContract;", "    contracts.pop();", "    emit RemoveContract(hashedName);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function addCollateral(EscrowState storage self, address oracle, uint256 amount, address token)", "        external", "        returns (uint256)", "    {", "        require(amount > 0);", "        if(!self.enabled[token])  { revert InvalidCollateral(); }", "", "        LineLib.receiveTokenOrETH(token, msg.sender, amount);", "", "        self.deposited[token].amount += amount;", "", "        emit AddCollateral(token, amount);", "", "        return _getLatestCollateralRatio(self, oracle);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": ["  function _set(", "    uint256 _projectId,", "    uint256 _domain,", "    uint256 _group,", "    JBSplit[] memory _splits", "  ) internal {", "    // Get a reference to the project's current splits.", "    JBSplit[] memory _currentSplits = _getStructsFor(_projectId, _domain, _group);", "", "    // Check to see if all locked splits are included.", "    for (uint256 _i = 0; _i < _currentSplits.length; _i++) {", "      // If not locked, continue.", "      if (block.timestamp >= _currentSplits[_i].lockedUntil) continue;", "", "      // Keep a reference to whether or not the locked split being iterated on is included.", "      bool _includesLocked = false;", "", "      for (uint256 _j = 0; _j < _splits.length; _j++) {", "        // Check for sameness.", "        if (", "          _splits[_j].percent == _currentSplits[_i].percent &&", "          _splits[_j].beneficiary == _currentSplits[_i].beneficiary &&", "          _splits[_j].allocator == _currentSplits[_i].allocator &&", "          _splits[_j].projectId == _currentSplits[_i].projectId &&", "          // Allow lock extention.", "          _splits[_j].lockedUntil >= _currentSplits[_i].lockedUntil", "        ) _includesLocked = true;", "      }", "", "      if (!_includesLocked) revert PREVIOUS_LOCKED_SPLITS_NOT_INCLUDED();", "    }", "", "    // Add up all the percents to make sure they cumulative are under 100%.", "    uint256 _percentTotal = 0;", "", "    for (uint256 _i = 0; _i < _splits.length; _i++) {", "      // The percent should be greater than 0.", "      if (_splits[_i].percent == 0) revert INVALID_SPLIT_PERCENT();", "", "      // ProjectId should be within a uint56", "      if (_splits[_i].projectId > type(uint56).max) revert INVALID_PROJECT_ID();", "", "      // Add to the total percents.", "      _percentTotal = _percentTotal + _splits[_i].percent;", "", "      // Validate the total does not exceed the expected value.", "      if (_percentTotal > JBConstants.SPLITS_TOTAL_PERCENT) revert INVALID_TOTAL_PERCENT();", "", "      uint256 _packedSplitParts1;", "", "      // prefer claimed in bit 0.", "      if (_splits[_i].preferClaimed) _packedSplitParts1 = 1;", "      // prefer add to balance in bit 1.", "      if (_splits[_i].preferAddToBalance) _packedSplitParts1 |= 1 << 1;", "      // percent in bits 2-33.", "      _packedSplitParts1 |= _splits[_i].percent << 2;", "      // projectId in bits 32-89.", "      _packedSplitParts1 |= _splits[_i].projectId << 34;", "      // beneficiary in bits 90-249.", "      _packedSplitParts1 |= uint256(uint160(address(_splits[_i].beneficiary))) << 90;", "", "      // Store the first spit part.", "      _packedSplitParts1Of[_projectId][_domain][_group][_i] = _packedSplitParts1;", "", "      // If there's data to store in the second packed split part, pack and store.", "      if (_splits[_i].lockedUntil > 0 || _splits[_i].allocator != IJBSplitAllocator(address(0))) {", "        // Locked until should be within a uint48", "        if (_splits[_i].lockedUntil > type(uint48).max) revert INVALID_LOCKED_UNTIL();", "", "        // lockedUntil in bits 0-47.", "        uint256 _packedSplitParts2 = uint48(_splits[_i].lockedUntil);", "        // allocator in bits 48-207.", "        _packedSplitParts2 |= uint256(uint160(address(_splits[_i].allocator))) << 48;", "", "        // Store the second split part.", "        _packedSplitParts2Of[_projectId][_domain][_group][_i] = _packedSplitParts2;", "", "        // Otherwise if there's a value stored in the indexed position, delete it.", "      } else if (_packedSplitParts2Of[_projectId][_domain][_group][_i] > 0)", "        delete _packedSplitParts2Of[_projectId][_domain][_group][_i];", "", "      emit SetSplit(_projectId, _domain, _group, _splits[_i], msg.sender);", "    }", "", "    // Set the new length of the splits.", "    _splitCountOf[_projectId][_domain][_group] = _splits.length;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function create(", "        address _baseToken,", "        address _nft,", "        uint128 _virtualBaseTokenReserves,", "        uint128 _virtualNftReserves,", "        uint56 _changeFee,", "        uint16 _feeRate,", "        bytes32 _merkleRoot,", "        bool _useStolenNftOracle,", "        bool _payRoyalties,", "        bytes32 _salt,", "        uint256[] memory tokenIds, // put in memory to avoid stack too deep error", "        uint256 baseTokenAmount", "    ) public payable returns (PrivatePool privatePool) {", "        // check that the msg.value is equal to the base token amount if the base token is ETH or the msg.value is equal", "        // to zero if the base token is not ETH", "        if ((_baseToken == address(0) && msg.value != baseTokenAmount) || (_baseToken != address(0) && msg.value > 0)) {", "            revert PrivatePool.InvalidEthAmount();", "        }", "", "        // deploy a minimal proxy clone of the private pool implementation", "        privatePool = PrivatePool(payable(privatePoolImplementation.cloneDeterministic(_salt)));", "", "        // mint the nft to the caller", "        _safeMint(msg.sender, uint256(uint160(address(privatePool))));", "", "        // initialize the pool", "        privatePool.initialize(", "            _baseToken,", "            _nft,", "            _virtualBaseTokenReserves,", "            _virtualNftReserves,", "            _changeFee,", "            _feeRate,", "            _merkleRoot,", "            _useStolenNftOracle,", "            _payRoyalties", "        );", "", "        if (_baseToken == address(0)) {", "            // transfer eth into the pool if base token is ETH", "            address(privatePool).safeTransferETH(baseTokenAmount);", "        } else {", "            // deposit the base tokens from the caller into the pool", "            ERC20(_baseToken).transferFrom(msg.sender, address(privatePool), baseTokenAmount);", "        }", "", "        // deposit the nfts from the caller into the pool", "        for (uint256 i = 0; i < tokenIds.length; i++) {", "            ERC721(_nft).safeTransferFrom(msg.sender, address(privatePool), tokenIds[i]);", "        }", "", "        // emit create event", "        emit Create(address(privatePool), tokenIds, baseTokenAmount);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function execute(ExecutorArgs memory _args) external payable override onlyConnext returns (bool, bytes memory) {", "    // Check if the callTo is a contract", "    bool success;", "    bytes memory returnData;", "", "    bool isNative = _args.assetId == address(0);", "", "    if (!AddressUpgradeable.isContract(_args.to)) {", "      _handleFailure(isNative, false, _args.assetId, payable(_args.to), payable(_args.recovery), _args.amount);", "      // Emit event", "      emit Executed(", "        _args.transferId,", "        _args.to,", "        _args.recovery,", "        _args.assetId,", "        _args.amount,", "        _args.properties,", "        _args.callData,", "        returnData,", "        success", "      );", "      return (success, returnData);", "    }", "", "    // If it is not ether, approve the callTo", "    // We approve here rather than transfer since many external contracts", "    // simply require an approval, and it is unclear if they can handle", "    // funds transferred directly to them (i.e. Uniswap)", "", "    if (!isNative) {", "      SafeERC20Upgradeable.safeIncreaseAllowance(IERC20Upgradeable(_args.assetId), _args.to, _args.amount);", "    }", "", "    // If it should set the properties, set them.", "    // NOTE: safe to set the properties always because modifier will revert if", "    // it is the wrong type on conversion, and revert occurs with empty type as", "    // well", "    properties = _args.properties;", "", "    // Set the amount as well", "    amnt = _args.amount;", "", "    // Ensure there is enough gas to handle failures", "    uint256 gas = gasleft() - FAILURE_GAS;", "", "    // Try to execute the callData", "    // the low level call will return `false` if its execution reverts", "    (success, returnData) = ExcessivelySafeCall.excessivelySafeCall(", "      _args.to,", "      gas,", "      isNative ? _args.amount : 0,", "      MAX_COPY,", "      _args.callData", "    );", "", "    // Unset properties", "    properties = LibCrossDomainProperty.EMPTY_BYTES;", "", "    // Unset amount", "    amnt = 0;", "", "    // Handle failure cases", "    if (!success) {", "      _handleFailure(isNative, true, _args.assetId, payable(_args.to), payable(_args.recovery), _args.amount);", "    }", "", "    // Emit event", "    emit Executed(", "      _args.transferId,", "      _args.to,", "      _args.recovery,", "      _args.assetId,", "      _args.amount,", "      _args.properties,", "      _args.callData,", "      returnData,", "      success", "    );", "    return (success, returnData);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function setWithholdRatio(uint256 newRatio) external onlyByOwnGov {", "        require (newRatio <= RATIO_PRECISION, \"Ratio cannot surpass 100%\");", "        withholdRatio = newRatio;", "        emit WithholdRatioSet(newRatio);", "    }"], "ner_tags": [1, 0, 0, 0, 0]}
{"tokens": ["    function setStartingIndex() public {", "        require(", "            startingIndex == 0,", "            \"CoreCollection: Starting index is already set\"", "        );", "", "        startingIndex =", "            (uint256(", "                keccak256(abi.encodePacked(\"CoreCollection\", block.number))", "            ) % maxSupply) +", "            1;", "        startingIndexBlock = uint256(block.number);", "        emit StartingIndexSet(startingIndex);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": ["  function _handleProtocolFee(uint256 amount) internal returns (uint256) {", "    address feeTo = ROUTER().feeTo();", "    bool feeOn = feeTo != address(0);", "    if (feeOn) {", "      uint256 fee = ROUTER().getProtocolFee(amount);", "", "      unchecked {", "        amount -= fee;", "      }", "      ERC20(asset()).safeTransfer(feeTo, fee);", "    }", "    return amount;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["    function balanceOfPool(address _gauge) public view returns (uint256) {", "        return IGauge(_gauge).balanceOf(address(this));", "    }"], "ner_tags": [1, 0, 0]}
{"tokens": ["    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {", "        if (", "            fuses & ~PARENT_CANNOT_CONTROL != 0 &&", "            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=", "            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)", "        ) {", "            revert OperationProhibited(node);", "        }", "    }"], "ner_tags": [0, 1, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": ["    function follow(", "        address follower,", "        uint256[] calldata profileIds,", "        bytes[] calldata followModuleDatas,", "        address followNFTImpl,", "        mapping(uint256 => DataTypes.ProfileStruct) storage _profileById,", "        mapping(bytes32 => uint256) storage _profileIdByHandleHash", "    ) external {", "        if (profileIds.length != followModuleDatas.length) revert Errors.ArrayMismatch();", "        for (uint256 i = 0; i < profileIds.length; ++i) {", "            string memory handle = _profileById[profileIds[i]].handle;", "            if (_profileIdByHandleHash[keccak256(bytes(handle))] == 0)", "                revert Errors.TokenDoesNotExist();", "", "            address followModule = _profileById[profileIds[i]].followModule;", "", "            address followNFT = _profileById[profileIds[i]].followNFT;", "", "            if (followNFT == address(0)) {", "                followNFT = Clones.clone(followNFTImpl);", "                _profileById[profileIds[i]].followNFT = followNFT;", "", "                bytes4 firstBytes = bytes4(bytes(handle));", "", "                string memory followNFTName = string(", "                    abi.encodePacked(handle, Constants.FOLLOW_NFT_NAME_SUFFIX)", "                );", "                string memory followNFTSymbol = string(", "                    abi.encodePacked(firstBytes, Constants.FOLLOW_NFT_SYMBOL_SUFFIX)", "                );", "", "                IFollowNFT(followNFT).initialize(profileIds[i], followNFTName, followNFTSymbol);", "                emit Events.FollowNFTDeployed(profileIds[i], followNFT, block.timestamp);", "            }", "", "            IFollowNFT(followNFT).mint(follower);", "", "            if (followModule != address(0)) {", "                IFollowModule(followModule).processFollow(", "                    follower,", "                    profileIds[i],", "                    followModuleDatas[i]", "                );", "            }", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function withdraw(uint256 underlyingAmount, address receiver, address holder) external override returns (uint256 principalAmount){", "        if (block.timestamp < maturity) {", "            revert Maturity(maturity);", "        }", "        if (holder == msg.sender) {", "            return IRedeemer(redeemer).authRedeem(underlying, maturity, msg.sender, receiver, underlyingAmount);", "        }", "        else {", "            require(_allowance[holder][msg.sender] >= underlyingAmount, 'not enough approvals');", "            return IRedeemer(redeemer).authRedeem(underlying, maturity, holder, receiver, underlyingAmount);     ", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["    function _startBridge(AnyswapData memory _anyswapData) internal {", "        // Check chain id", "        require(block.chainid != _anyswapData.toChainId, \"Cannot bridge to the same network.\");", "        address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();", "", "        if (underlyingToken == IAnyswapRouter(_anyswapData.router).wNATIVE()) {", "            IAnyswapRouter(_anyswapData.router).anySwapOutNative{ value: _anyswapData.amount }(", "                _anyswapData.token,", "                _anyswapData.recipient,", "                _anyswapData.toChainId", "            );", "            return;", "        }", "", "        if (_anyswapData.token != address(0)) {", "            // Has underlying token?", "            if (underlyingToken != address(0)) {", "                // Give Anyswap approval to bridge tokens", "                LibAsset.approveERC20(IERC20(underlyingToken), _anyswapData.router, _anyswapData.amount);", "", "                IAnyswapRouter(_anyswapData.router).anySwapOutUnderlying(", "                    _anyswapData.token,", "                    _anyswapData.recipient,", "                    _anyswapData.amount,", "                    _anyswapData.toChainId", "                );", "            } else {", "                // Give Anyswap approval to bridge tokens", "                LibAsset.approveERC20(IERC20(_anyswapData.token), _anyswapData.router, _anyswapData.amount);", "", "                IAnyswapRouter(_anyswapData.router).anySwapOut(", "                    _anyswapData.token,", "                    _anyswapData.recipient,", "                    _anyswapData.amount,", "                    _anyswapData.toChainId", "                );", "            }", "        }", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function getRouterOwner(address _router) public view returns (address) {", "    address _owner = s.routerPermissionInfo.routerOwners[_router];", "    return _owner == address(0) ? _router : _owner;", "  }"], "ner_tags": [1, 0, 0, 0]}
{"tokens": ["    function _getAmountsIn(", "        uint256[] memory _pairBinSteps,", "        address[] memory _pairs,", "        IERC20[] memory _tokenPath,", "        uint256 _amountOut", "    ) private view returns (uint256[] memory amountsIn) {", "        amountsIn = new uint256[](_tokenPath.length);", "        // Avoid doing -1, as `_pairs.length == _pairBinSteps.length-1`", "        amountsIn[_pairs.length] = _amountOut;", "", "        for (uint256 i = _pairs.length; i != 0; i--) {", "            IERC20 _token = _tokenPath[i - 1];", "            uint256 _binStep = _pairBinSteps[i - 1];", "", "            address _pair = _pairs[i - 1];", "", "            if (_binStep == 0) {", "                (uint256 _reserveIn, uint256 _reserveOut, ) = IJoePair(_pair).getReserves();", "                if (_token > _tokenPath[i]) {", "                    (_reserveIn, _reserveOut) = (_reserveOut, _reserveIn);", "                }", "", "                uint256 amountOut_ = amountsIn[i];", "                // Legacy uniswap way of rounding", "                amountsIn[i - 1] = (_reserveIn * amountOut_ * 1_000) / (_reserveOut - amountOut_ * 997) + 1;", "            } else {", "                (amountsIn[i - 1], ) = getSwapIn(ILBPair(_pair), amountsIn[i], ILBPair(_pair).tokenX() == _token);", "            }", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function buy(uint256 outputAmount, uint256 maxInputAmount) public payable returns (uint256 inputAmount) {", "        // *** Checks *** //", "", "        // check that correct eth input was sent - if the baseToken equals address(0) then native ETH is used", "        require(baseToken == address(0) ? msg.value == maxInputAmount : msg.value == 0, \"Invalid ether input\");", "", "        // calculate required input amount using xyk invariant", "        inputAmount = buyQuote(outputAmount);", "", "        // check that the required amount of base tokens is less than the max amount", "        require(inputAmount <= maxInputAmount, \"Slippage: amount in\");", "", "        // *** Effects *** //", "", "        // transfer fractional tokens to sender", "        _transferFrom(address(this), msg.sender, outputAmount);", "", "        // *** Interactions *** //", "", "        if (baseToken == address(0)) {", "            // refund surplus eth", "            uint256 refundAmount = maxInputAmount - inputAmount;", "            if (refundAmount > 0) msg.sender.safeTransferETH(refundAmount);", "        } else {", "            // transfer base tokens in", "            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), inputAmount);", "        }", "", "        emit Buy(inputAmount, outputAmount);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["    function _min(uint256 x, uint256 y) private pure returns (uint256) {", "        return x <= y ? x : y;", "    }"], "ner_tags": [1, 1, 1]}
{"tokens": ["    function accept(", "        uint256 proposalId,", "        uint256 snapIndex", "    ) public onlyDelegateCall returns (uint256 totalVotes) {", "        // Get the information about the proposal.", "        ProposalState storage info = _proposalStateByProposalId[proposalId];", "        ProposalStateValues memory values = info.values;", "", "        // Can only vote in certain proposal statuses.", "        {", "            ProposalStatus status = _getProposalStatus(values);", "            // Allow voting even if the proposal is passed/ready so it can", "            // potentially reach 100% consensus, which unlocks special", "            // behaviors for certain proposal types.", "            if (", "                status != ProposalStatus.Voting &&", "                status != ProposalStatus.Passed &&", "                status != ProposalStatus.Ready", "            ) {", "                revert BadProposalStatusError(status);", "            }", "        }", "", "        // Prevent voting in the same block as the last burn timestamp.", "        // This is to prevent an exploit where a member can burn their card to", "        // reduce the total voting power of the party, then propose and vote in", "        // the same block since `getVotingPowerAt()` uses `values.proposedTime - 1`.", "        // This would allow them to use the voting power snapshot just before", "        // their card was burned to vote, potentially passing a proposal that", "        // would have otherwise not passed.", "        if (lastBurnTimestamp == block.timestamp) {", "            revert CannotRageQuitAndAcceptError();", "        }", "", "        // Cannot vote twice.", "        if (info.hasVoted[msg.sender]) {", "            revert AlreadyVotedError(msg.sender);", "        }", "        // Mark the caller as having voted.", "        info.hasVoted[msg.sender] = true;", "", "        // Increase the total votes that have been cast on this proposal.", "        uint96 votingPower = getVotingPowerAt(msg.sender, values.proposedTime - 1, snapIndex);", "        values.votes += votingPower;", "        info.values = values;", "        emit ProposalAccepted(proposalId, msg.sender, votingPower);", "", "        // Update the proposal status if it has reached the pass threshold.", "        if (", "            values.passedTime == 0 &&", "            _areVotesPassing(", "                values.votes,", "                values.totalVotingPower,", "                _governanceValues.passThresholdBps", "            )", "        ) {", "            info.values.passedTime = uint40(block.timestamp);", "            emit ProposalPassed(proposalId);", "        }", "        return values.votes;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function withdraw(uint treeIndex, address destination) public {", "        // cannot withdraw from an uninitialized vesting schedule", "        require(initialized[destination][treeIndex], \"You must initialize your account first.\");", "        // storage because we will modify it", "        Tranche storage tranche = tranches[destination][treeIndex];", "        // no withdrawals before lock time ends", "        require(block.timestamp > tranche.lockPeriodEndTime, 'Must wait until after lock period');", "        // revert if there's nothing left", "        require(tranche.currentCoins >  0, 'No coins left to withdraw');", "", "        // declaration for branched assignment", "        uint currentWithdrawal = 0;", "", "        // if after vesting period ends, give them the remaining coins", "        if (block.timestamp >= tranche.endTime) {", "            currentWithdrawal = tranche.currentCoins;", "        } else {", "            // compute allowed withdrawal", "            currentWithdrawal = (block.timestamp - tranche.lastWithdrawalTime) * tranche.coinsPerSecond;", "        }", "", "        // decrease allocation of coins", "        tranche.currentCoins -= currentWithdrawal;", "        // this makes sure coins don't get double withdrawn", "        tranche.lastWithdrawalTime = block.timestamp;", "", "        // update the tree balance so trees can't take each other's tokens", "        MerkleTree storage tree = merkleTrees[treeIndex];", "        tree.tokenBalance -= currentWithdrawal;", "", "        // Transfer the tokens, if the token contract is malicious, this will make the whole tree malicious", "        // but this does not allow re-entrance due to struct updates and it does not effect other trees.", "        // It is also consistent with the ethereum general security model:", "        // other contracts do what they want, it's our job to protect our contract", "        IERC20(tree.tokenAddress).transfer(destination, currentWithdrawal);", "        emit WithdrawalOccurred(treeIndex, destination, currentWithdrawal, tranche.currentCoins);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["    function anchorTime() internal view returns (uint64){", "        return uint64(block.number << BLOCK_TIME_RESOLUTION_BITS);", "    }"], "ner_tags": [0, 1, 0]}
{"tokens": ["    function addExtraReward(address _reward) external returns (bool) {", "        require(msg.sender == rewardManager, \"!authorized\");", "        require(_reward != address(0), \"!reward setting\");", "        require(extraRewards.length < EXTRA_REWARD_POOLS, \"!extra reward pools exceed\");", "", "        extraRewards.push(_reward);", "        emit ExtraRewardAdded(_reward);", "        return true;", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function authorize(address user) public {", "        address sender = _msgSender();", "        require(_authorized[sender].add(user), \"Address already is authorized\");", "        emit Authorized(sender, user);", "    }"], "ner_tags": [1, 1, 1, 1, 1]}
{"tokens": ["  function settleAuction(uint256 collateralId) public {", "    CollateralStorage storage s = _loadCollateralSlot();", "    if (", "      s.collateralIdToAuction[collateralId] == bytes32(0) &&", "      ERC721(s.idToUnderlying[collateralId].tokenContract).ownerOf(", "        s.idToUnderlying[collateralId].tokenId", "      ) !=", "      s.clearingHouse[collateralId]", "    ) {", "      revert InvalidCollateralState(InvalidCollateralStates.NO_AUCTION);", "    }", "    require(msg.sender == s.clearingHouse[collateralId]);", "    _settleAuction(s, collateralId);", "    delete s.idToUnderlying[collateralId];", "    _burn(collateralId);", "  }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function execute(", "        address to,", "        uint256 value,", "        bytes memory data,", "        Enum.Operation operation,", "        uint256 txGas", "    ) internal returns (bool success) {", "        if (operation == Enum.Operation.DelegateCall) {", "            // solhint-disable-next-line no-inline-assembly", "            assembly {", "                success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)", "            }", "        } else {", "            // solhint-disable-next-line no-inline-assembly", "            assembly {", "                success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)", "            }", "        }", "        // Emit events here..", "        if (success) emit ExecutionSuccess(to, value, data, operation, txGas);", "        else emit ExecutionFailure(to, value, data, operation, txGas);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function initialize(", "        address _baseToken,", "        address _nft,", "        uint128 _virtualBaseTokenReserves,", "        uint128 _virtualNftReserves,", "        uint56 _changeFee,", "        uint16 _feeRate,", "        bytes32 _merkleRoot,", "        bool _useStolenNftOracle,", "        bool _payRoyalties", "    ) public {", "        // prevent duplicate initialization", "        if (initialized) revert AlreadyInitialized();", "", "        // check that the fee rate is less than 50%", "        if (_feeRate > 5_000) revert FeeRateTooHigh();", "", "        // set the state variables", "        baseToken = _baseToken;", "        nft = _nft;", "        virtualBaseTokenReserves = _virtualBaseTokenReserves;", "        virtualNftReserves = _virtualNftReserves;", "        changeFee = _changeFee;", "        feeRate = _feeRate;", "        merkleRoot = _merkleRoot;", "        useStolenNftOracle = _useStolenNftOracle;", "        payRoyalties = _payRoyalties;", "", "        // mark the pool as initialized", "        initialized = true;", "", "        // emit the event", "        emit Initialize(", "            _baseToken,", "            _nft,", "            _virtualBaseTokenReserves,", "            _virtualNftReserves,", "            _changeFee,", "            _feeRate,", "            _merkleRoot,", "            _useStolenNftOracle,", "            _payRoyalties", "        );", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function migrate(address oldPoolAddress_) public override {", "        ILiquidityPool oldPool_ = ILiquidityPool(oldPoolAddress_);", "        IERC20 lpToken_ = IERC20(oldPool_.getLpToken());", "        uint256 lpTokenAmount_ = lpToken_.balanceOf(msg.sender);", "        require(lpTokenAmount_ != 0, \"No LP Tokens\");", "        require(oldPool_.getWithdrawalFee(msg.sender, lpTokenAmount_) == 0, \"withdrawal fee not 0\");", "        lpToken_.safeTransferFrom(msg.sender, address(this), lpTokenAmount_);", "        uint256 underlyingAmount_ = oldPool_.redeem(lpTokenAmount_);", "        address underlying_ = oldPool_.getUnderlying();", "        ILiquidityPool newPool_ = _underlyingNewPools[underlying_];", "        uint256 ethValue_ = underlying_ == address(0) ? underlyingAmount_ : 0;", "        newPool_.depositFor{value: ethValue_}(msg.sender, underlyingAmount_);", "        emit Migrated(msg.sender, address(oldPool_), address(newPool_), lpTokenAmount_);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["    function _collateralPriceUsd() internal view returns (uint256) {", "        int256 answer = oracle.latestAnswer();", "        uint8 decimals = oracle.decimals();", "", "        require(answer > 0, \"invalid_oracle_answer\");", "", "        //check chainlink's precision and convert it to 18 decimals", "        return", "            decimals > 18", "                ? uint256(answer) / 10**(decimals - 18)", "                : uint256(answer) * 10**(18 - decimals);", "    }"], "ner_tags": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function block(address addr) external {", "        require(msg.sender == manager, \"Only manager\");", "        require(_isContract(addr), \"Only contracts\");", "        _blocklist[addr] = true;", "        IVotingEscrow(ve).forceUndelegate(addr);", "    }"], "ner_tags": [0, 0, 1, 0, 0, 0]}
{"tokens": ["    function less(ERC4626 vault, uint256 feiAmount) external nonReentrant requiresLocalOrMasterAuth {", "        // Update the total Fei deposited into the Vault proportionately.", "        getTotalFeiBoostedForVault[vault] -= feiAmount;", "", "        unchecked {", "            // Decrease the boost total proportionately.", "            // Cannot underflow because the total cannot be less than a single Vault.", "            totalFeiBoosted -= feiAmount;", "        }", "", "        emit VaultLessened(msg.sender, vault, feiAmount);", "", "        // Withdraw the specified amount of Fei from the Vault.", "        vault.withdraw(feiAmount, address(this), address(this));", "", "        // Get out current amount of Fei debt in the Turbo Fuse Pool.", "        uint256 feiDebt = feiTurboCToken.borrowBalanceCurrent(address(this));", "", "        // If our debt balance decreased, repay the minimum.", "        // The surplus Fei will accrue as fees and can be sweeped.", "        if (feiAmount > feiDebt) feiAmount = feiDebt;", "", "        // Repay Fei debt in the Turbo Fuse Pool, unless we would repay nothing.", "        if (feiAmount != 0) require(feiTurboCToken.repayBorrow(feiAmount) == 0, \"REPAY_FAILED\");", "", "        // Call the Master to allow it to update its accounting.", "        master.onSafeLess(asset, vault, feiAmount);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": ["\tfunction _cancelMinipoolAndReturnFunds(address nodeID, int256 index) private {", "\t\trequireValidStateTransition(index, MinipoolStatus.Canceled);", "\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".status\")), uint256(MinipoolStatus.Canceled));", "", "\t\taddress owner = getAddress(keccak256(abi.encodePacked(\"minipool.item\", index, \".owner\")));", "\t\tuint256 avaxNodeOpAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".avaxNodeOpAmt\")));", "\t\tuint256 avaxLiquidStakerAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".avaxLiquidStakerAmt\")));", "", "\t\tStaking staking = Staking(getContractAddress(\"Staking\"));", "\t\tstaking.decreaseAVAXStake(owner, avaxNodeOpAmt);", "\t\tstaking.decreaseAVAXAssigned(owner, avaxLiquidStakerAmt);", "", "\t\tstaking.decreaseMinipoolCount(owner);", "", "\t\temit MinipoolStatusChanged(nodeID, MinipoolStatus.Canceled);", "", "\t\tVault vault = Vault(getContractAddress(\"Vault\"));", "\t\tvault.withdrawAVAX(avaxNodeOpAmt);", "\t\towner.safeTransferETH(avaxNodeOpAmt);", "\t}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["  function _paymentAH(", "    LienStorage storage s,", "    address token,", "    AuctionStack[] memory stack,", "    uint256 position,", "    uint256 payment,", "    address payer", "  ) internal returns (uint256) {", "    uint256 lienId = stack[position].lienId;", "    uint256 end = stack[position].end;", "    uint256 owing = stack[position].amountOwed;", "    //checks the lien exists", "    address payee = _getPayee(s, lienId);", "    uint256 remaining = 0;", "    if (owing > payment.safeCastTo88()) {", "      remaining = owing - payment;", "    } else {", "      payment = owing;", "    }", "    if (payment > 0)", "      s.TRANSFER_PROXY.tokenTransferFrom(token, payer, payee, payment);", "", "    delete s.lienMeta[lienId]; //full delete", "    delete stack[position];", "    _burn(lienId);", "", "    if (_isPublicVault(s, payee)) {", "      IPublicVault(payee).updateAfterLiquidationPayment(", "        IPublicVault.LiquidationPaymentParams({remaining: remaining})", "      );", "    }", "    emit Payment(lienId, payment);", "    return payment;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function addToPosition(", "        uint _id,", "        uint _addMargin,", "        PriceData calldata _priceData,", "        bytes calldata _signature,", "        address _stableVault,", "        address _marginAsset,", "        ERC20PermitData calldata _permitData,", "        address _trader", "    )", "        external", "    {", "        _validateProxy(_trader);", "        _checkOwner(_id, _trader);", "        _checkDelay(_id, true);", "        IPosition.Trade memory _trade = position.trades(_id);", "        tradingExtension.validateTrade(_trade.asset, _trade.tigAsset, _trade.margin + _addMargin, _trade.leverage);", "        _checkVault(_stableVault, _marginAsset);", "        if (_trade.orderType != 0) revert(\"4\"); //IsLimit", "        uint _fee = _handleOpenFees(_trade.asset, _addMargin*_trade.leverage/1e18, _trader, _trade.tigAsset, false);", "        _handleDeposit(", "            _trade.tigAsset,", "            _marginAsset,", "            _addMargin - _fee,", "            _stableVault,", "            _permitData,", "            _trader", "        );", "        position.setAccInterest(_id);", "        unchecked {", "            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, _trade.direction ? 1 : 2);", "            uint _positionSize = (_addMargin - _fee) * _trade.leverage / 1e18;", "            if (_trade.direction) {", "                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, true, _positionSize);", "            } else {", "                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, true, _positionSize);     ", "            }", "            _updateFunding(_trade.asset, _trade.tigAsset);", "            _addMargin -= _fee;", "            uint _newMargin = _trade.margin + _addMargin;", "            uint _newPrice = _trade.price*_trade.margin/_newMargin + _price*_addMargin/_newMargin;", "", "            position.addToPosition(", "                _trade.id,", "                _newMargin,", "                _newPrice", "            );", "            ", "            emit AddToPosition(_trade.id, _newMargin, _newPrice, _trade.trader);", "        }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function reserves(uint granularity) external view returns(uint, uint) {", "        (uint[] memory _reserves0, uint[] memory _reserves1)= sampleReserves(granularity, 1);", "        uint reserveAverageCumulative0;", "        uint reserveAverageCumulative1;", "", "        for (uint i = 0; i < _reserves0.length; ++i) {", "            reserveAverageCumulative0 += _reserves0[i]; //normalize the reserves for TWAP LP Oracle pricing, ", "            reserveAverageCumulative1 += _reserves1[i]; //", "        }", "", "        return (reserveAverageCumulative0 / granularity, reserveAverageCumulative1 / granularity);", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function resetDefaultRoyalty() public onlyRole(DEFAULT_ADMIN_ROLE) {", "        _deleteDefaultRoyalty();", "    }"], "ner_tags": [1, 1, 1]}
{"tokens": ["    function performSwap(", "        IERC20 sellToken,", "        IERC20 buyToken,", "        bytes calldata swapCallData", "    ) external payable override returns (uint256[] memory amounts, address[] memory tokens) {", "        require(sellToken != buyToken, \"PSO: SAME_INPUT_OUTPUT\");", "        amounts = new uint256[](2);", "        tokens = new address[](2);", "        uint256 buyBalanceBeforePurchase = buyToken.balanceOf(address(this));", "        uint256 sellBalanceBeforePurchase = sellToken.balanceOf(address(this));", "", "        ExchangeHelpers.setMaxAllowance(sellToken, tokenTransferProxy);", "        (bool success, ) = augustusSwapper.call(swapCallData);", "        require(success, \"PSO: SWAP_FAILED\");", "", "        uint256 amountBought = buyToken.balanceOf(address(this)) - buyBalanceBeforePurchase;", "        uint256 amountSold = sellBalanceBeforePurchase - sellToken.balanceOf(address(this));", "        require(amountBought != 0, \"PSO: INVALID_AMOUNT_BOUGHT\");", "        require(amountSold != 0, \"PSO: INVALID_AMOUNT_SOLD\");", "", "        // Output amounts", "        amounts[0] = amountBought;", "        amounts[1] = amountSold;", "        // Output token", "        tokens[0] = address(buyToken);", "        tokens[1] = address(sellToken);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function removeMinter(address minter_address) public onlyByOwnGov {", "        require(minter_address != address(0), \"Zero address detected\");", "        require(minters[minter_address] == true, \"Address nonexistant\");", "        ", "        // Delete from the mapping", "        delete minters[minter_address];", "", "        // 'Delete' from the array by setting the address to 0x0", "        for (uint i = 0; i < minters_array.length; i++){ ", "            if (minters_array[i] == minter_address) {", "                minters_array[i] = address(0); // This will leave a null in the array and keep the indices the same", "                break;", "            }", "        }", "", "        emit MinterRemoved(minter_address);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function execTransaction(", "        Transaction memory _tx,", "        uint256 batchId,", "        FeeRefund memory refundInfo,", "        bytes memory signatures", "    ) public payable virtual override returns (bool success) {", "        // initial gas = 21k + non_zero_bytes * 16 + zero_bytes * 4", "        //            ~= 21k + calldata.length * [1/3 * 16 + 2/3 * 4]", "        uint256 startGas = gasleft() + 21000 + msg.data.length * 8;", "        //console.log(\"init %s\", 21000 + msg.data.length * 8);", "        bytes32 txHash;", "        // Use scope here to limit variable lifetime and prevent `stack too deep` errors", "        {", "            bytes memory txHashData =", "                encodeTransactionData(", "                    // Transaction info", "                    _tx,", "                    // Payment info", "                    refundInfo,", "                    // Signature info", "                    nonces[batchId]", "                );", "            // Increase nonce and execute transaction.", "            // Default space aka batchId is 0", "            nonces[batchId]++;", "            txHash = keccak256(txHashData);", "            checkSignatures(txHash, txHashData, signatures);", "        }", "", "", "        // We require some gas to emit the events (at least 2500) after the execution and some to perform code until the execution (500)", "        // We also include the 1/64 in the check that is not send along with a call to counteract potential shortings because of EIP-150", "        require(gasleft() >= max((_tx.targetTxGas * 64) / 63,_tx.targetTxGas + 2500) + 500, \"BSA010\");", "        // Use scope here to limit variable lifetime and prevent `stack too deep` errors", "        {", "            // If the gasPrice is 0 we assume that nearly all available gas can be used (it is always more than targetTxGas)", "            // We only substract 2500 (compared to the 3000 before) to ensure that the amount passed is still higher than targetTxGas", "            success = execute(_tx.to, _tx.value, _tx.data, _tx.operation, refundInfo.gasPrice == 0 ? (gasleft() - 2500) : _tx.targetTxGas);", "            // If no targetTxGas and no gasPrice was set (e.g. both are 0), then the internal tx is required to be successful", "            // This makes it possible to use `estimateGas` without issues, as it searches for the minimum gas where the tx doesn't revert", "            require(success || _tx.targetTxGas != 0 || refundInfo.gasPrice != 0, \"BSA013\");", "            // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls", "            uint256 payment = 0;", "            // uint256 extraGas;", "            if (refundInfo.gasPrice > 0) {", "                //console.log(\"sent %s\", startGas - gasleft());", "                // extraGas = gasleft();", "                payment = handlePayment(startGas - gasleft(), refundInfo.baseGas, refundInfo.gasPrice, refundInfo.tokenGasPriceFactor, refundInfo.gasToken, refundInfo.refundReceiver);", "                emit WalletHandlePayment(txHash, payment);", "            }", "            // extraGas = extraGas - gasleft();", "            //console.log(\"extra gas %s \", extraGas);", "        }", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function addLiquidityOnlyStETH(", "        uint256 stETHAmount,", "        uint256 minLpOut", "    ) external onlyRole(DEFAULT_ADMIN_ROLE) returns (uint256 lpOut) {", "        stETH.safeTransferFrom(msg.sender, address(this), stETHAmount);", "", "        uint256[2] memory amounts;", "", "        amounts[stETHIndex] = stETHAmount;", "", "        stETH.safeApprove(address(curvePool), stETHAmount);", "", "        lpOut = curvePool.add_liquidity(amounts, minLpOut);", "", "        /// @notice no need for safeApprove, direct transfer + deposit", "        IERC20(address(curvePool)).safeTransfer(address(cvxStaker), lpOut);", "        cvxStaker.depositAndStake(lpOut);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function getAmountToTransfer(", "        uint256 initialGas,", "        address tokenAddress,", "        uint256 amount,", "        uint256 tokenGasPrice", "    ) internal returns (uint256 amountToTransfer) {", "        uint256 transferFeePerc = getTransferFee(tokenAddress, amount);", "        uint256 lpFee;", "        if (transferFeePerc > tokenManager.getTokensInfo(tokenAddress).equilibriumFee) {", "            // Here add some fee to incentive pool also", "            lpFee = (amount * tokenManager.getTokensInfo(tokenAddress).equilibriumFee) / BASE_DIVISOR;", "            incentivePool[tokenAddress] =", "                (incentivePool[tokenAddress] +", "                    (amount * (transferFeePerc - tokenManager.getTokensInfo(tokenAddress).equilibriumFee))) /", "                BASE_DIVISOR;", "        } else {", "            lpFee = (amount * transferFeePerc) / BASE_DIVISOR;", "        }", "        uint256 transferFeeAmount = (amount * transferFeePerc) / BASE_DIVISOR;", "", "        liquidityProviders.addLPFee(tokenAddress, lpFee);", "", "        uint256 totalGasUsed = initialGas - gasleft();", "        totalGasUsed = totalGasUsed + tokenManager.getTokensInfo(tokenAddress).transferOverhead;", "        totalGasUsed = totalGasUsed + baseGas;", "", "        uint256 gasFee = totalGasUsed * tokenGasPrice;", "        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress] + gasFee;", "        gasFeeAccumulated[tokenAddress][_msgSender()] = gasFeeAccumulated[tokenAddress][_msgSender()] + gasFee;", "        amountToTransfer = amount - (transferFeeAmount + gasFee);", "", "        emit FeeDetails(lpFee, transferFeeAmount, gasFee);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function addVoteEscrow(address _voteEscrow) external onlyOwner {", "        if (address(ve) == address(0)) {", "            ve = VE(pendingVoteEscrow);", "        } else {", "            voteEscrowEnableDate = block.timestamp + 1 days;", "            pendingVoteEscrow = _voteEscrow;", "        }", "    }"], "ner_tags": [0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["  function _finalizeReserveAuction(uint256 auctionId, bool keepInEscrow) private {", "    ReserveAuction memory auction = auctionIdToAuction[auctionId];", "", "    if (auction.endTime >= block.timestamp) {", "      revert NFTMarketReserveAuction_Cannot_Finalize_Auction_In_Progress(auction.endTime);", "    }", "", "    // Remove the auction.", "    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];", "    delete auctionIdToAuction[auctionId];", "", "    if (!keepInEscrow) {", "      /*", "       * Save gas by calling core directly since it cannot have another escrow requirement", "       * (buy price set or another auction listed) until this one has been finalized.", "       */", "      NFTMarketCore._transferFromEscrow(auction.nftContract, auction.tokenId, auction.bidder, address(0));", "    }", "", "    // Distribute revenue for this sale.", "    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(", "      auction.nftContract,", "      auction.tokenId,", "      auction.seller,", "      auction.amount", "    );", "", "    emit ReserveAuctionFinalized(auctionId, auction.seller, auction.bidder, f8nFee, creatorFee, ownerRev);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": ["    function removeCollateral(uint256 tokenId, address to) public {", "        TokenLoan memory loan = tokenLoan[tokenId];", "        if (loan.status == LOAN_REQUESTED) {", "            // We are withdrawing collateral that is not in use:", "            require(msg.sender == loan.borrower, \"NFTPair: not the borrower\");", "        } else if (loan.status == LOAN_OUTSTANDING) {", "            // We are seizing collateral towards the lender. The loan has to be", "            // expired and not paid off, or underwater and not paid off:", "            require(to == loan.lender, \"NFTPair: not the lender\");", "", "            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration > block.timestamp) {", "                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];", "                // No underflow: loan.startTime is only ever set to a block timestamp", "                // Cast is safe: if this overflows, then all loans have expired anyway", "                uint256 interest = calculateInterest(", "                    loanParams.valuation,", "                    uint64(block.timestamp - loan.startTime),", "                    loanParams.annualInterestBPS", "                ).to128();", "                uint256 amount = loanParams.valuation + interest;", "                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);", "                require(rate.mul(loanParams.ltvBPS) / BPS < amount, \"NFT is still valued\");", "            }", "        }", "        // If there somehow is collateral but no accompanying loan, then anyone", "        // can claim it by first requesting a loan with `skim` set to true, and", "        // then withdrawing. So we might as well allow it here..", "        delete tokenLoan[tokenId];", "        collateral.transferFrom(address(this), to, tokenId);", "        emit LogRemoveCollateral(tokenId, to);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function mint(uint256 liquidity, bytes calldata data) internal {", "    uint120 _reserve0 = reserve0; // SLOAD", "    uint120 _reserve1 = reserve1; // SLOAD", "    uint256 _totalLiquidity = totalLiquidity; // SLOAD", "", "    uint256 balance0Before = Balance.balance(token0);", "    uint256 balance1Before = Balance.balance(token1);", "    IPairMintCallback(msg.sender).pairMintCallback(liquidity, data);", "    uint256 amount0In = Balance.balance(token0) - balance0Before;", "    uint256 amount1In = Balance.balance(token1) - balance1Before;", "", "    if (!invariant(_reserve0 + amount0In, _reserve1 + amount1In, _totalLiquidity + liquidity)) {", "      revert InvariantError();", "    }", "", "    reserve0 = _reserve0 + SafeCast.toUint120(amount0In); // SSTORE", "    reserve1 = _reserve1 + SafeCast.toUint120(amount1In); // SSTORE", "    totalLiquidity = _totalLiquidity + liquidity; // SSTORE", "", "    emit Mint(amount0In, amount1In, liquidity);", "  }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function stake(uint256 _amount) public updateReward(msg.sender) returns (bool) {", "        require(_amount > 0, \"RewardPool : Cannot stake 0\");", "", "        //also stake to linked rewards", "        for (uint256 i = 0; i < extraRewards.length; i++) {", "            IRewards(extraRewards[i]).stake(msg.sender, _amount);", "        }", "", "        _totalSupply = _totalSupply.add(_amount);", "        _balances[msg.sender] = _balances[msg.sender].add(_amount);", "", "        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);", "        emit Staked(msg.sender, _amount);", "", "        return true;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function setManagement(uint256 vaultId, ManagedVault calldata mgtParams) external override {", "    address vaultOwner = a.vaultsData().vaultOwner(vaultId);", "    address mimoProxy = address(proxyRegistry.getCurrentProxy(msg.sender));", "", "    if (mimoProxy != vaultOwner && vaultOwner != msg.sender) {", "      revert CustomErrors.CALLER_NOT_VAULT_OWNER(mimoProxy, vaultOwner);", "    }", "    if (!_managers[mgtParams.manager]) {", "      revert CustomErrors.MANAGER_NOT_LISTED();", "    }", "", "    _managedVaults[vaultId] = mgtParams;", "", "    emit ManagementSet(vaultId, mgtParams);", "  }"], "ner_tags": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function burn(uint256 amount, address recipient) external override lock returns (uint256) {", "        _onlyWhitelisted();", "", "        _checkArgument(amount > 0);", "        _checkArgument(recipient != address(0));", "", "        // Distribute unlocked credit to depositors.", "        _distributeUnlockedCreditDeposited(recipient);", "", "        // Update the recipient's account, decrease the debt of the recipient by the number of tokens burned.", "        _poke(recipient);", "", "        // Check that the debt is greater than zero.", "        //", "        // It is possible that the number of debt which is repayable is equal to or less than zero after realizing the", "        // credit that was earned since the last update. We do not want to perform a noop so we need to check that the", "        // amount of debt to repay is greater than zero.", "        int256 debt;", "        _checkState((debt = _accounts[recipient].debt) > 0);", "", "        // Limit how much debt can be repaid up to the current amount of debt that the account has. This prevents", "        // situations where the user may be trying to repay their entire debt, but it decreases since they send the", "        // transaction and causes a revert because burning can never decrease the debt below zero.", "        //", "        // Casts here are safe because it is asserted that debt is greater than zero.", "        uint256 credit = amount > uint256(debt) ? uint256(debt) : amount;", "", "        // Update the recipient's debt.", "        _updateDebt(recipient, -SafeCast.toInt256(credit));", "", "        // Burn the tokens from the message sender.", "        TokenUtils.safeBurnFrom(debtToken, msg.sender, credit);", "", "        emit Burn(msg.sender, credit, recipient);", "", "        return credit;", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function supportsInterface(bytes4 interfaceId)", "        external", "        view", "        virtual", "        override(IERC165)", "        returns (bool)", "    {", "        return", "            interfaceId == type(IERC721Enumerable).interfaceId ||", "            interfaceId == type(IERC721Metadata).interfaceId;", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function batchDepositETHForStaking(bytes[] calldata _blsPublicKeyOfKnots, uint256[] calldata _amounts) external payable {", "        uint256 numOfValidators = _blsPublicKeyOfKnots.length;", "        require(numOfValidators > 0, \"Empty arrays\");", "        require(numOfValidators == _amounts.length, \"Inconsistent array lengths\");", "", "        // Update accrued ETH to contract per LP", "        updateAccumulatedETHPerLP();", "", "        uint256 totalAmount;", "        for (uint256 i; i < numOfValidators; ++i) {", "            require(liquidStakingNetworkManager.isBLSPublicKeyBanned(_blsPublicKeyOfKnots[i]) == false, \"BLS public key is not part of LSD network\");", "            require(", "                getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnots[i]) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,", "                \"Lifecycle status must be one\"", "            );", "", "            LPToken tokenForKnot = lpTokenForKnot[_blsPublicKeyOfKnots[i]];", "            if (address(tokenForKnot) != address(0)) {", "                // Give anything owed to the user before making updates to user state", "                _distributeETHRewardsToUserForToken(", "                    msg.sender,", "                    address(tokenForKnot),", "                    tokenForKnot.balanceOf(msg.sender),", "                    msg.sender", "                );", "            }", "", "            uint256 amount = _amounts[i];", "            totalAmount += amount;", "", "            _depositETHForStaking(_blsPublicKeyOfKnots[i], amount, true);", "", "            // Ensure user cannot get historical rewards", "            tokenForKnot = lpTokenForKnot[_blsPublicKeyOfKnots[i]];", "            claimed[msg.sender][address(tokenForKnot)] = (tokenForKnot.balanceOf(msg.sender) * accumulatedETHPerLPShare) / PRECISION;", "        }", "", "        // Ensure that the sum of LP tokens issued equals the ETH deposited into the contract", "        require(msg.value == totalAmount, \"Invalid ETH amount attached\");", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _end(Sale memory _sale) internal {", "        emit End(_sale);", "        selfdestruct(_sale.saleReceiver);", "    }"], "ner_tags": [0, 0, 1, 0]}
{"tokens": ["    function quitLock() external override nonReentrant {", "        LockedBalance memory locked_ = locked[msg.sender];", "        // Validate inputs", "        require(locked_.amount > 0, \"No lock\");", "        require(locked_.end > block.timestamp, \"Lock expired\");", "        require(locked_.delegatee == msg.sender, \"Lock delegated\");", "        // Update lock", "        uint256 value = uint256(uint128(locked_.amount));", "        LockedBalance memory newLocked = _copyLock(locked_);", "        newLocked.amount = 0;", "        newLocked.delegated -= int128(int256(value));", "        newLocked.delegatee = address(0);", "        locked[msg.sender] = newLocked;", "        newLocked.end = 0;", "        newLocked.delegated = 0;", "        // oldLocked can have either expired <= timestamp or zero end", "        // currentLock has only 0 end", "        // Both can have >= 0 amount", "        _checkpoint(msg.sender, locked_, newLocked);", "        // apply penalty", "        uint256 penaltyRate = _calculatePenaltyRate(locked_.end);", "        uint256 penaltyAmount = (value * penaltyRate) / 10**18; // quitlock_penalty is in 18 decimals precision", "        penaltyAccumulated += penaltyAmount;", "        uint256 remainingAmount = value - penaltyAmount;", "        // Send back remaining tokens", "        require(token.transfer(msg.sender, remainingAmount), \"Transfer failed\");", "        emit Withdraw(msg.sender, value, LockAction.QUIT, block.timestamp);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["    function donate(IERC20 _token, uint256 _amount) external {", "        require(activated[_token] != 0, \"!activated\");", "        savedTokens[_token] += _amount;", "        _token.safeTransferFrom(msg.sender, address(this), _amount);", "    }"], "ner_tags": [0, 0, 1, 0, 0]}
{"tokens": ["    function init() external {", "        if (nonce != 0) revert Initialized(owner, msg.sender, nonce);", "        nonce = 1;", "        owner = msg.sender;", "        emit TransferOwnership(address(0), msg.sender);", "    }"], "ner_tags": [0, 1, 0, 0, 0, 0]}
{"tokens": ["    function multiSend(bytes memory transactions) public payable {", "        require(address(this) != multisendSingleton, \"MultiSend should only be called via delegatecall\");", "        // solhint-disable-next-line no-inline-assembly", "        assembly {", "            let length := mload(transactions)", "            let i := 0x20", "            for {", "                // Pre block is not used in \"while mode\"", "            } lt(i, length) {", "                // Post block is not used in \"while mode\"", "            } {", "                // First byte of the data is the operation.", "                // We shift by 248 bits (256 - 8 [operation byte]) it right since mload will always load 32 bytes (a word).", "                // This will also zero out unused data.", "                let operation := shr(0xf8, mload(add(transactions, i)))", "                // We offset the load address by 1 byte (operation byte)", "                // We shift it right by 96 bits (256 - 160 [20 address bytes]) to right-align the data and zero out unused data.", "                let to := shr(0x60, mload(add(transactions, add(i, 0x01))))", "                // We offset the load address by 21 byte (operation byte + 20 address bytes)", "                let value := mload(add(transactions, add(i, 0x15)))", "                // We offset the load address by 53 byte (operation byte + 20 address bytes + 32 value bytes)", "                let dataLength := mload(add(transactions, add(i, 0x35)))", "                // We offset the load address by 85 byte (operation byte + 20 address bytes + 32 value bytes + 32 data length bytes)", "                let data := add(transactions, add(i, 0x55))", "                let success := 0", "                switch operation", "                    case 0 {", "                        success := call(gas(), to, value, data, dataLength, 0, 0)", "                    }", "                    case 1 {", "                        success := delegatecall(gas(), to, data, dataLength, 0, 0)", "                    }", "                if eq(success, 0) {", "                    revert(0, 0)", "                }", "                // Next entry starts at 85 byte + data length", "                i := add(i, add(0x55, dataLength))", "            }", "        }", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function limitClose(", "        uint _id,", "        bool _tp,", "        PriceData calldata _priceData,", "        bytes calldata _signature", "    )", "        external", "    {", "        _checkDelay(_id, false);", "        (uint _limitPrice, address _tigAsset) = tradingExtension._limitClose(_id, _tp, _priceData, _signature);", "        _closePosition(_id, DIVISION_CONSTANT, _limitPrice, address(0), _tigAsset, true);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["    function updateAccumulatedETHPerLP() public {", "        _updateAccumulatedETHPerLP(totalShares);", "    }"], "ner_tags": [0, 1, 0]}
{"tokens": ["    function deposit(address _recipient, uint _pid, uint _amount) external nonReentrant onlyDepositor {", "        PoolInfo storage pool = poolInfo[_pid];", "        UserInfo storage user = userInfo[_pid][_msgSender()];", "        updatePool(_pid);", "       ", "        if(user.amount > 0) {  ", "            uint pending = user.amount * pool.accConcurPerShare / _concurShareMultiplier - user.rewardDebt;", "            if (pending > 0) {", "                safeConcurTransfer(_recipient, pending);", "            }", "        }", "", "        if (_amount > 0) {", "            if (pool.depositFeeBP > 0) {", "                uint depositFee = _amount.mul(pool.depositFeeBP).div(_perMille);", "                user.amount = SafeCast.toUint128(user.amount + _amount - depositFee);", "            } else {", "                user.amount = SafeCast.toUint128(user.amount + _amount);", "            }", "        }     ", "", "        user.rewardDebt = SafeCast.toUint128(user.amount * pool.accConcurPerShare / _concurShareMultiplier);", "        emit Deposit(_recipient, _pid, _amount);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    modifier onlyMinter() {", "        require(msg.sender == minter, 'GolomToken: only reward distributor can enable');", "        _;", "    }"], "ner_tags": [1, 1, 1, 1]}
{"tokens": ["    modifier onlyL1Counterpart() {", "        require(", "            msg.sender == AddressAliasHelper.applyL1ToL2Alias(l1Counterpart),", "            \"ONLY_COUNTERPART_GATEWAY\"", "        );", "        _;", "    }"], "ner_tags": [0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["    function forceReplenish(address user, uint amount) public {", "        uint deficit = dbr.deficitOf(user);", "        require(deficit > 0, \"No DBR deficit\");", "        require(deficit >= amount, \"Amount > deficit\");", "        uint replenishmentCost = amount * dbr.replenishmentPriceBps() / 10000;", "        uint replenisherReward = replenishmentCost * replenishmentIncentiveBps / 10000;", "        debts[user] += replenishmentCost;", "        uint collateralValue = getCollateralValueInternal(user);", "        require(collateralValue >= debts[user], \"Exceeded collateral value\");", "        totalDebt += replenishmentCost;", "        dbr.onForceReplenish(user, amount);", "        dola.transfer(msg.sender, replenisherReward);", "        emit ForceReplenish(user, msg.sender, amount, replenishmentCost, replenisherReward);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function executeMintMultiple(", "        MintableERC721Data storage erc721Data,", "        bool ATOMIC_PRICING,", "        address to,", "        DataTypes.ERC721SupplyParams[] calldata tokenData", "    )", "        external", "        returns (", "            uint64 oldCollateralizedBalance,", "            uint64 newCollateralizedBalance", "        )", "    {", "        require(to != address(0), \"ERC721: mint to the zero address\");", "        uint64 oldBalance = erc721Data.userState[to].balance;", "        oldCollateralizedBalance = erc721Data", "            .userState[to]", "            .collateralizedBalance;", "        uint256 oldTotalSupply = erc721Data.allTokens.length;", "        uint64 collateralizedTokens = 0;", "", "        for (uint256 index = 0; index < tokenData.length; index++) {", "            uint256 tokenId = tokenData[index].tokenId;", "", "            require(", "                !_exists(erc721Data, tokenId),", "                \"ERC721: token already minted\"", "            );", "", "            _addTokenToAllTokensEnumeration(", "                erc721Data,", "                tokenId,", "                oldTotalSupply + index", "            );", "            _addTokenToOwnerEnumeration(", "                erc721Data,", "                to,", "                tokenId,", "                oldBalance + index", "            );", "", "            erc721Data.owners[tokenId] = to;", "", "            if (", "                tokenData[index].useAsCollateral &&", "                !erc721Data.isUsedAsCollateral[tokenId]", "            ) {", "                erc721Data.isUsedAsCollateral[tokenId] = true;", "                collateralizedTokens++;", "            }", "", "            emit Transfer(address(0), to, tokenId);", "        }", "", "        newCollateralizedBalance =", "            oldCollateralizedBalance +", "            collateralizedTokens;", "        erc721Data", "            .userState[to]", "            .collateralizedBalance = newCollateralizedBalance;", "", "        uint64 newBalance = oldBalance + uint64(tokenData.length);", "        _checkBalanceLimit(erc721Data, ATOMIC_PRICING, newBalance);", "        erc721Data.userState[to].balance = newBalance;", "", "        // calculate incentives", "        IRewardController rewardControllerLocal = erc721Data.rewardController;", "        if (address(rewardControllerLocal) != address(0)) {", "            rewardControllerLocal.handleAction(to, oldTotalSupply, oldBalance);", "        }", "", "        return (oldCollateralizedBalance, newCollateralizedBalance);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function executeProposal() external {", "        uint256 netVotes = yesVotesForProposal[activeProposal.proposalId] -", "            noVotesForProposal[activeProposal.proposalId];", "        if (netVotes * 100 < VOTES.totalSupply() * EXECUTION_THRESHOLD) {", "            revert NotEnoughVotesToExecute();", "        }", "", "        if (block.timestamp < activeProposal.activationTimestamp + EXECUTION_TIMELOCK) {", "            revert ExecutionTimelockStillActive();", "        }", "", "        Instruction[] memory instructions = INSTR.getInstructions(activeProposal.proposalId);", "", "        for (uint256 step; step < instructions.length; ) {", "            kernel.executeAction(instructions[step].action, instructions[step].target);", "            unchecked {", "                ++step;", "            }", "        }", "", "        emit ProposalExecuted(activeProposal.proposalId);", "", "        // deactivate the active proposal", "        activeProposal = ActivatedProposal(0, 0);", "    }"], "ner_tags": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _withdrawAll() internal override {", "        //NOTE: This probably will always fail unless we have all tokens expired", "        require(", "            balanceOfPool() == 0 && LOCKER.balanceOf(address(this)) == 0,", "            \"You have to wait for unlock or have to manually rebalance out of it\"", "        );", "", "        // Make sure to call prepareWithdrawAll before _withdrawAll", "    }"], "ner_tags": [0, 0, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": ["    function rotateEOARepresentative(address _newRepresentative) external {", "        require(_newRepresentative != address(0), \"Zero address\");", "        require(isNodeRunnerBanned(msg.sender) == false, \"Node runner is banned from LSD network\");", "", "        address smartWallet = smartWalletOfNodeRunner[msg.sender];", "        require(smartWallet != address(0), \"No smart wallet\");", "        require(stakedKnotsOfSmartWallet[smartWallet] == 0, \"Not all KNOTs are minted\");", "        require(smartWalletRepresentative[smartWallet] != _newRepresentative, \"Invalid rotation to same EOA\");", "", "        // unauthorize old representative", "        _authorizeRepresentative(smartWallet, smartWalletRepresentative[smartWallet], false);", "", "        // authorize new representative", "        _authorizeRepresentative(smartWallet, _newRepresentative, true);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  function createSplitProxy(string memory _splitId)", "    private", "    returns (address splitProxy)", "  {", "    splitProxy = address(", "      new SplitProxy{salt: keccak256(abi.encode(merkleRoot))}()", "    );", "", "    splits[_splitId] = splitProxy;", "", "    emit SplitCreated(splitProxy, _splitId);", "", "    delete merkleRoot;", "    delete splitAsset;", "  }"], "ner_tags": [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function setRoyalties(", "        uint256 _id,", "        address _receiver,", "        uint256 _percentage", "    ) external onlyController {", "        royaltyAddress[_id] = _receiver;", "        royaltyPercent[_id] = _percentage;", "        emit SetRoyalty(_receiver, _id, _percentage);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function resetPosition(", "        bytes32 account,", "        bytes32 protocol,", "        bool unstake", "    ) external override returns (bool) {", "        address payer = msg.sender;", "        Record memory position = _positions[payer][account][protocol];", "        require(position.threshold != 0, Error.NO_POSITION_EXISTS);", "", "        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist", "        IStakerVault staker = IStakerVault(vault);", "        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);", "        if (unstake) {", "            staker.unstake(position.depositTokenBalance);", "            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);", "        } else {", "            staker.transfer(payer, position.depositTokenBalance);", "        }", "", "        _removePosition(payer, account, protocol);", "        addressProvider.getGasBank().withdrawUnused(payer);", "        return true;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function delegate(address _addr)", "        external", "        override", "        nonReentrant", "        checkBlocklist", "    {", "        LockedBalance memory locked_ = locked[msg.sender];", "        // Validate inputs", "        require(!IBlocklist(blocklist).isBlocked(_addr), \"Blocked contract\");", "        require(locked_.amount > 0, \"No lock\");", "        require(locked_.delegatee != _addr, \"Already delegated\");", "        // Update locks", "        int128 value = locked_.amount;", "        address delegatee = locked_.delegatee;", "        LockedBalance memory fromLocked;", "        LockedBalance memory toLocked;", "        locked_.delegatee = _addr;", "        if (delegatee == msg.sender) {", "            // Delegate", "            fromLocked = locked_;", "            toLocked = locked[_addr];", "        } else if (_addr == msg.sender) {", "            // Undelegate", "            fromLocked = locked[delegatee];", "            toLocked = locked_;", "        } else {", "            // Re-delegate", "            fromLocked = locked[delegatee];", "            toLocked = locked[_addr];", "            // Update owner lock if not involved in delegation", "            locked[msg.sender] = locked_;", "        }", "        require(toLocked.amount > 0, \"Delegatee has no lock\");", "        require(toLocked.end > block.timestamp, \"Delegatee lock expired\");", "        require(toLocked.end >= fromLocked.end, \"Only delegate to longer lock\");", "        _delegate(delegatee, fromLocked, value, LockAction.UNDELEGATE);", "        _delegate(_addr, toLocked, value, LockAction.DELEGATE);", "    }"], "ner_tags": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}
{"tokens": ["    function createNewMarket(", "        uint256 _withdrawalFee,", "        address _token,", "        int256 _strikePrice,", "        uint256 epochBegin,", "        uint256 epochEnd,", "        address _oracle,", "        string memory _name", "    ) public onlyAdmin returns (address insr, address rsk) {", "        if(", "            IController(controller).getVaultFactory() != address(this)", "            )", "            revert AddressFactoryNotInController();", "", "        if(controller == address(0))", "            revert ControllerNotSet();", "", "        marketIndex += 1;", "", "        //y2kUSDC_99*RISK or y2kUSDC_99*HEDGE", "", "        Vault hedge = new Vault(", "            WETH,", "            string(abi.encodePacked(_name,\"HEDGE\")),", "            \"hY2K\",", "            treasury,", "            _token,", "            _strikePrice,", "            controller", "        );", "", "        Vault risk = new Vault(", "            WETH,", "            string(abi.encodePacked(_name,\"RISK\")),", "            \"rY2K\",", "            treasury,", "            _token,", "            _strikePrice,", "            controller", "        );", "", "        indexVaults[marketIndex] = [address(hedge), address(risk)];", "", "        if (tokenToOracle[_token] == address(0)) {", "            tokenToOracle[_token] = _oracle;", "        }", "", "        emit MarketCreated(", "            marketIndex,", "            address(hedge),", "            address(risk),", "            _token,", "            _name,", "            _strikePrice", "        );", "", "        MarketVault memory marketVault = MarketVault(marketIndex, epochBegin, epochEnd, hedge, risk, _withdrawalFee);", "", "        _createEpoch(marketVault);", "", "        return (address(hedge), address(risk));", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function markValidatorReadyToDeposit(", "        bytes[] calldata _readyToDepositPubkey,", "        bytes[] calldata _frontRunPubkey,", "        bytes[] calldata _invalidSignaturePubkey", "    ) external override nonReentrant whenNotPaused {", "        UtilLib.onlyOperatorRole(msg.sender, staderConfig);", "        uint256 readyToDepositValidatorsLength = _readyToDepositPubkey.length;", "        uint256 frontRunValidatorsLength = _frontRunPubkey.length;", "        uint256 invalidSignatureValidatorsLength = _invalidSignaturePubkey.length;", "", "        if (", "            readyToDepositValidatorsLength + frontRunValidatorsLength + invalidSignatureValidatorsLength >", "            verifiedKeyBatchSize", "        ) {", "            revert TooManyVerifiedKeysReported();", "        }", "", "        //handle the front run validators", "        for (uint256 i; i < frontRunValidatorsLength; ) {", "            uint256 validatorId = validatorIdByPubkey[_frontRunPubkey[i]];", "            // only PRE_DEPOSIT status check will also include validatorId = 0 check", "            // as status for that will be INITIALIZED(default status)", "            onlyPreDepositValidator(validatorId);", "            handleFrontRun(validatorId);", "            emit ValidatorMarkedAsFrontRunned(_frontRunPubkey[i], validatorId);", "            unchecked {", "                ++i;", "            }", "        }", "", "        //handle the invalid signature validators", "        for (uint256 i; i < invalidSignatureValidatorsLength; ) {", "            uint256 validatorId = validatorIdByPubkey[_invalidSignaturePubkey[i]];", "            // only PRE_DEPOSIT status check will also include validatorId = 0 check", "            // as status for that will be INITIALIZED(default status)", "            onlyPreDepositValidator(validatorId);", "            validatorRegistry[validatorId].status = ValidatorStatus.INVALID_SIGNATURE;", "            emit ValidatorStatusMarkedAsInvalidSignature(_invalidSignaturePubkey[i], validatorId);", "            unchecked {", "                ++i;", "            }", "        }", "", "        address permissionedPool = staderConfig.getPermissionedPool();", "        uint256 totalDefectedKeys = frontRunValidatorsLength + invalidSignatureValidatorsLength;", "        if (totalDefectedKeys > 0) {", "            decreaseTotalActiveValidatorCount(totalDefectedKeys);", "            IPermissionedPool(permissionedPool).transferETHOfDefectiveKeysToSSPM(totalDefectedKeys);", "        }", "        IPermissionedPool(permissionedPool).fullDepositOnBeaconChain(_readyToDepositPubkey);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function removeLiquidity(", "        IERC20 _tokenX,", "        IERC20 _tokenY,", "        uint16 _binStep,", "        uint256 _amountXMin,", "        uint256 _amountYMin,", "        uint256[] memory _ids,", "        uint256[] memory _amounts,", "        address _to,", "        uint256 _deadline", "    ) external override ensure(_deadline) returns (uint256 amountX, uint256 amountY) {", "        ILBPair _LBPair = _getLBPairInformation(_tokenX, _tokenY, _binStep);", "        if (_tokenX != _LBPair.tokenX()) {", "            (_tokenX, _tokenY) = (_tokenY, _tokenX);", "            (_amountXMin, _amountYMin) = (_amountYMin, _amountXMin);", "        }", "", "        (amountX, amountY) = _removeLiquidity(_LBPair, _amountXMin, _amountYMin, _ids, _amounts, _to);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["    constructor(address _governance) {", "        // sets governance as owner", "        _transferOwnership(_governance);", "", "        uint256 chainId;", "        assembly {", "            chainId := chainid()", "        }", "", "        EIP712_DOMAIN_TYPEHASH = keccak256(", "            abi.encode(", "                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),", "                keccak256(bytes('GOLOM.IO')),", "                keccak256(bytes('1')),", "                chainId,", "                address(this)", "            )", "        );", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function claimRewards(", "        address _recipient,", "        address[] calldata _stakingFundsVaults,", "        bytes[][] calldata _blsPublicKeysForKnots", "    ) external {", "        uint256 numOfVaults = _stakingFundsVaults.length;", "        require(numOfVaults > 0, \"Empty array\");", "        require(numOfVaults == _blsPublicKeysForKnots.length, \"Inconsistent array lengths\");", "        for (uint256 i; i < numOfVaults; ++i) {", "            StakingFundsVault(payable(_stakingFundsVaults[i])).claimRewards(", "                address(this),", "                _blsPublicKeysForKnots[i]", "            );", "        }", "", "        updateAccumulatedETHPerLP();", "", "        _distributeETHRewardsToUserForToken(", "            msg.sender,", "            address(lpTokenETH),", "            lpTokenETH.balanceOf(msg.sender),", "            _recipient", "        );", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": ["    function borrowInternal(address borrower, address to, uint amount) internal {", "        require(!borrowPaused, \"Borrowing is paused\");", "        if(borrowController != IBorrowController(address(0))) {", "            require(borrowController.borrowAllowed(msg.sender, borrower, amount), \"Denied by borrow controller\");", "        }", "        uint credit = getCreditLimitInternal(borrower);", "        debts[borrower] += amount;", "        require(credit >= debts[borrower], \"Exceeded credit limit\");", "        totalDebt += amount;", "        dbr.onBorrow(borrower, amount);", "        dola.transfer(to, amount);", "        emit Borrow(borrower, amount);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["    function previewAccumulatedETH(", "        address _user,", "        address[] calldata _stakingFundsVaults,", "        LPToken[][] calldata _lpTokens", "    ) external view returns (uint256) {", "        require(_stakingFundsVaults.length == _lpTokens.length, \"Inconsistent array lengths\");", "", "        uint256 accumulated;", "        for (uint256 i; i < _stakingFundsVaults.length; ++i) {", "            accumulated = StakingFundsVault(payable(_stakingFundsVaults[i])).batchPreviewAccumulatedETH(", "                address(this),", "                _lpTokens[i]", "            );", "        }", "", "        return _previewAccumulatedETH(_user, address(lpTokenETH), lpTokenETH.balanceOf(_user), lpTokenETH.totalSupply(), accumulated);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function sub512(uint256 minuend0, uint256 minuend1, uint256 subtrahend0, uint256 subtrahend1) internal pure returns (uint256 difference0, uint256 difference1) {", "        assembly {", "            difference0 := sub(minuend0, subtrahend0)", "            difference1 := sub(sub(minuend1, subtrahend1), lt(minuend0, subtrahend0))", "        }", "", "        if (subtrahend1 > minuend1 || (subtrahend1 == minuend1 && subtrahend0 > minuend0)) revert SubUnderflow(minuend0, minuend1, subtrahend0, subtrahend1);", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _exit(", "        bytes32 chainHash,", "        address messageReceiver,", "        address contractOnMainChain,", "        address to,", "        uint256 amount", "    )", "        private", "    {", "        bool isMainChainToken;", "        ERC20BurnableUpgradeable contractOnSchain = clonesErc20[chainHash][contractOnMainChain];", "        if (address(contractOnSchain) == address(0)) {", "            contractOnSchain = ERC20BurnableUpgradeable(contractOnMainChain);", "            isMainChainToken = true;", "        }", "        require(address(contractOnSchain).isContract(), \"No token clone on schain\");", "        require(contractOnSchain.balanceOf(msg.sender) >= amount, \"Insufficient funds\");", "        require(", "            contractOnSchain.allowance(", "                msg.sender,", "                address(this)", "            ) >= amount,", "            \"Transfer is not approved by token holder\"", "        );", "        bytes memory data = Messages.encodeTransferErc20Message(address(contractOnMainChain), to, amount);", "        if (isMainChainToken) {", "            data = _receiveERC20(", "                chainHash,", "                address(contractOnSchain),", "                msg.sender,", "                amount", "            );", "            _saveTransferredAmount(chainHash, address(contractOnSchain), amount);", "            require(", "                contractOnSchain.transferFrom(msg.sender, address(this), amount),", "                \"Transfer was failed\"", "            );", "        } else {", "            require(", "                contractOnSchain.transferFrom(msg.sender, address(this), amount),", "                \"Transfer was failed\"", "            );", "            contractOnSchain.burn(amount);", "        }", "        messageProxy.postOutgoingMessage(", "            chainHash,", "            messageReceiver,", "            data", "        );", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function getCurrentPrice() public view returns (uint256) {", "        if (!initialized) revert Price_NotInitialized();", "", "        // Get prices from feeds", "        uint256 ohmEthPrice;", "        uint256 reserveEthPrice;", "        {", "            (, int256 ohmEthPriceInt, , uint256 updatedAt, ) = _ohmEthPriceFeed.latestRoundData();", "            // Use a multiple of observation frequency to determine what is too old to use.", "            // Price feeds will not provide an updated answer if the data doesn't change much.", "            // This would be similar to if the feed just stopped updating; therefore, we need a cutoff.", "            if (updatedAt < block.timestamp - 3 * uint256(observationFrequency))", "                revert Price_BadFeed(address(_ohmEthPriceFeed));", "            ohmEthPrice = uint256(ohmEthPriceInt);", "", "            int256 reserveEthPriceInt;", "            (, reserveEthPriceInt, , updatedAt, ) = _reserveEthPriceFeed.latestRoundData();", "            if (updatedAt < block.timestamp - uint256(observationFrequency))", "                revert Price_BadFeed(address(_reserveEthPriceFeed));", "            reserveEthPrice = uint256(reserveEthPriceInt);", "        }", "", "        // Convert to OHM/RESERVE price", "        uint256 currentPrice = (ohmEthPrice * _scaleFactor) / reserveEthPrice;", "", "        return currentPrice;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function redeemToUnderlying(", "        uint256 amount,", "        address receiver,", "        uint32 maxImpliedRate", "    ) external override {", "        redeem(", "            amount,", "            RedeemOpts({", "                redeemToUnderlying: true,", "                transferfCash: false,", "                receiver: receiver,", "                maxImpliedRate: maxImpliedRate", "            })", "        );", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function transferFrom(", "        address sender,", "        address recipient,", "        uint256 amount", "    ) public virtual override returns (bool) {", "        _transfer(sender, recipient, amount);", "", "        uint256 currentAllowance = _allowances[sender][_msgSender()];", "        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");", "        unchecked {", "            _approve(sender, _msgSender(), currentAllowance - amount);", "        }", "", "        return true;", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function createVault(", "        uint256 tokenIdOrAmount,", "        address token,", "        uint8 premiumIndex,", "        uint8 durationDays,", "        uint8 dutchAuctionStartingStrikeIndex,", "        uint256 dutchAuctionReserveStrike,", "        TokenType tokenType", "    ) external returns (uint256 vaultId) {", "        require(premiumIndex < premiumOptions.length, \"Invalid premium index\");", "        require(dutchAuctionStartingStrikeIndex < strikeOptions.length, \"Invalid strike index\");", "        require(dutchAuctionReserveStrike < strikeOptions[dutchAuctionStartingStrikeIndex], \"Reserve strike too small\");", "        require(durationDays > 0, \"durationDays too small\");", "        require(tokenType == TokenType.ERC721 || tokenType == TokenType.ERC20, \"Invalid token type\");", "", "        Vault memory vault = Vault({", "            tokenIdOrAmount: tokenIdOrAmount,", "            token: token,", "            premiumIndex: premiumIndex,", "            durationDays: durationDays,", "            dutchAuctionStartingStrikeIndex: dutchAuctionStartingStrikeIndex,", "            currentExpiration: uint32(block.timestamp),", "            isExercised: false,", "            isWithdrawing: false,", "            tokenType: tokenType,", "            currentStrike: 0,", "            dutchAuctionReserveStrike: dutchAuctionReserveStrike", "        });", "", "        // vault index should always be odd", "        vaultIndex += 2;", "        vaultId = vaultIndex;", "        _vaults[vaultId] = vault;", "", "        // give msg.sender vault token", "        _mint(msg.sender, vaultId);", "", "        emit NewVault(vaultId, msg.sender, token);", "", "        // transfer the NFTs or ERC20s to the contract", "        vault.tokenType == TokenType.ERC721", "            ? ERC721(vault.token).transferFrom(msg.sender, address(this), vault.tokenIdOrAmount)", "            : ERC20(vault.token).safeTransferFrom(msg.sender, address(this), vault.tokenIdOrAmount);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0]}
{"tokens": ["    function _getCollateralValue(EscrowState storage self, address oracle) public returns (uint256) {", "        uint256 collateralValue;", "        // gas savings", "        uint256 length = self.collateralTokens.length;", "        IOracle o = IOracle(oracle); ", "        IEscrow.Deposit memory d;", "        for (uint256 i; i < length; ++i) {", "            address token = self.collateralTokens[i];", "            d = self.deposited[token];", "             // new var so we don't override original deposit amount for 4626 tokens", "            uint256 deposit = d.amount;", "            if (deposit != 0) {", "                if (d.isERC4626) {", "                    // this conversion could shift, hence it is best to get it each time", "                    (bool success, bytes memory assetAmount) = token.call(", "                        abi.encodeWithSignature(", "                            \"previewRedeem(uint256)\",", "                            deposit", "                        )", "                    );", "                    if (!success) continue;", "                    deposit = abi.decode(assetAmount, (uint256));", "                }", "", "                collateralValue += CreditLib.calculateValue(", "                  o.getLatestAnswer(d.asset),", "                  deposit,", "                  d.assetDecimals", "                );", "            }", "        }", "", "        return collateralValue;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": ["    function onERC721Received(", "        address operator,", "        address from,", "        uint256 id,", "        bytes memory", "    ) external virtual override returns (bytes4) {", "        // only accept MoonBird tokens", "        require(msg.sender == _underlyingAsset, Errors.OPERATION_NOT_SUPPORTED);", "", "        // if the operator is the pool, this means that the pool is transferring the token to this contract", "        // which can happen during a normal supplyERC721 pool tx", "        if (operator == address(POOL)) {", "            return this.onERC721Received.selector;", "        }", "", "        // supply the received token to the pool and set it as collateral", "        DataTypes.ERC721SupplyParams[]", "            memory tokenData = new DataTypes.ERC721SupplyParams[](1);", "", "        tokenData[0] = DataTypes.ERC721SupplyParams({", "            tokenId: id,", "            useAsCollateral: true", "        });", "", "        POOL.supplyERC721FromNToken(_underlyingAsset, tokenData, from);", "", "        return this.onERC721Received.selector;", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function buy(uint256 id, uint256 quantity)", "        public", "        virtual", "        can_buy(id)", "        synchronized", "        returns (bool)", "    {", "        OfferInfo memory _offer = offers[id];", "        uint256 spend = mul(quantity, _offer.buy_amt) / _offer.pay_amt;", "", "        require(uint128(spend) == spend, \"spend is not an int\");", "        require(uint128(quantity) == quantity, \"quantity is not an int\");", "", "        ///@dev For backwards semantic compatibility.", "        if (", "            quantity == 0 ||", "            spend == 0 ||", "            quantity > _offer.pay_amt ||", "            spend > _offer.buy_amt", "        ) {", "            return false;", "        }", "", "        // Fee logic added on taker trades", "        uint256 fee = mul(spend, feeBPS) / 10000;", "        require(", "            _offer.buy_gem.transferFrom(msg.sender, feeTo, fee),", "            \"Insufficient funds to cover fee\"", "        );", "", "        offers[id].pay_amt = sub(_offer.pay_amt, quantity);", "        offers[id].buy_amt = sub(_offer.buy_amt, spend);", "        require(", "            _offer.buy_gem.transferFrom(msg.sender, _offer.owner, spend),", "            \"_offer.buy_gem.transferFrom(msg.sender, _offer.owner, spend) failed - check that you can pay the fee\"", "        );", "        require(", "            _offer.pay_gem.transfer(msg.sender, quantity),", "            \"_offer.pay_gem.transfer(msg.sender, quantity) failed\"", "        );", "", "        emit LogItemUpdate(id);", "        emit LogTake(", "            bytes32(id),", "            keccak256(abi.encodePacked(_offer.pay_gem, _offer.buy_gem)),", "            _offer.owner,", "            _offer.pay_gem,", "            _offer.buy_gem,", "            msg.sender,", "            uint128(quantity),", "            uint128(spend),", "            uint64(block.timestamp)", "        );", "        emit FeeTake(", "            bytes32(id),", "            keccak256(abi.encodePacked(_offer.pay_gem, _offer.buy_gem)),", "            _offer.buy_gem,", "            msg.sender,", "            feeTo,", "            fee,", "            uint64(block.timestamp)", "        );", "        emit LogTrade(", "            quantity,", "            address(_offer.pay_gem),", "            spend,", "            address(_offer.buy_gem)", "        );", "", "        if (offers[id].pay_amt == 0) {", "            delete offers[id];", "            emit OfferDeleted(id);", "        }", "", "        return true;", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function _issueReward(address to_) internal {", "        rewardToken.safeTransfer(to_, reward);", "        emit RewardIssued(to_, reward);", "    }"], "ner_tags": [1, 1, 1, 1]}
{"tokens": ["  function authRedeem(uint8 p, address u, uint256 m, address f, address t, uint256 a) public authorized(markets[p][u][m].zcToken) returns (uint256 underlyingAmount) {", "    Market memory market = markets[p][u][m];", "    // if the market has not matured, mature it...", "    if (market.maturityRate == 0) {", "      if (!matureMarket(p, u, m)) { revert Exception(30, 0, 0, address(0), address(0)); }", "", "      if (!IZcToken(market.zcToken).burn(f, a)) { revert Exception(29, 0, 0, address(0), address(0)); }", "", "      ISwivel(swivel).authRedeem(p, u, market.cTokenAddr, t, a);", "", "      return (a);", "    } else {", "", "      if (!IZcToken(market.zcToken).burn(f, a)) { revert Exception(29, 0, 0, address(0), address(0)); }", "", "      uint256 amount = calculateReturn(p, u, m, a);", "      ISwivel(swivel).authRedeem(p, u, market.cTokenAddr, t, amount);", "", "      return (amount);", "    }", "  }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    function payEther(uint256 payAmt, address payAddress) internal {", "        if (payAmt > 0) {", "            // if royalty has to be paid", "            payable(payAddress).transfer(payAmt); // royalty transfer to royaltyaddress", "        }", "    }"], "ner_tags": [0, 0, 0, 1, 0, 0]}
{"tokens": ["    function onERC721Received(address from, address, uint256 _id, bytes calldata data)", "        external", "        override", "        returns (bytes4)", "    {", "        IPaprController.OnERC721ReceivedArgs memory request = abi.decode(data, (IPaprController.OnERC721ReceivedArgs));", "", "        IPaprController.Collateral memory collateral = IPaprController.Collateral(ERC721(msg.sender), _id);", "", "        _addCollateralToVault(from, collateral);", "", "        if (request.swapParams.minOut > 0) {", "            _increaseDebtAndSell(from, request.proceedsTo, ERC721(msg.sender), request.swapParams, request.oracleInfo);", "        } else if (request.debt > 0) {", "            _increaseDebt(from, collateral.addr, request.proceedsTo, request.debt, request.oracleInfo);", "        }", "", "        return ERC721TokenReceiver.onERC721Received.selector;", "    }"], "ner_tags": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
